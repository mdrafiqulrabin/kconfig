/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --comma-operators --argc --bitfields --no-arrays --pointers --structs --no-unions --packed-struct --divs --no-muls --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-longlong --float --jumps --no-volatiles --no-compound-assignment --no-consts --no-inline-function --no-volatile-pointers --const-pointers --no-global-variables --builtins --no-int8 --uint8
 * Seed:      3415424298
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 3;
   signed f1 : 12;
   int32_t  f2;
   unsigned f3 : 18;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_29(void);
static struct S0  func_30(uint32_t  p_31, int16_t  p_32, uint32_t  p_33, uint32_t  p_34);
static uint16_t  func_40(int32_t  p_41);
static int32_t * func_44(int32_t  p_45);
static int32_t * func_47(uint16_t * p_48, float  p_49, uint8_t  p_50);
static float  func_56(int32_t * p_57, struct S0  p_58, uint16_t ** p_59);
static struct S0  func_62(float  p_63, uint8_t  p_64);
static uint32_t  func_76(uint16_t ** p_77, int32_t  p_78, uint16_t * p_79, int32_t * p_80, int32_t * p_81);
static uint16_t ** func_82(uint16_t ** p_83, uint16_t ** p_84, struct S0  p_85);
static uint32_t  func_93(int32_t * p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_29(void)
{ /* block id: 36 */
    uint32_t l_35 = 0x7A81A82E;
    uint16_t l_43 = 65529U;
    uint16_t *l_42 = &l_43;
    float l_507 = (-0x10.Fp+1);
    float *l_506 = &l_507;
    float *l_508 = &l_507;
    uint16_t l_514 = 0U;
    uint16_t *l_513 = &l_514;
    struct S0 l_525 = {0,-37,0x8852DD88,97};
    struct S0 *l_524 = &l_525;
    uint8_t l_527 = 0xFB;
    uint8_t *l_526 = &l_527;
    int32_t *l_529 = &l_525.f2;
    int32_t **l_528 = &l_529;
    struct S0 l_530 = {1,-6,-1,484};
    (*l_524) = func_30(l_35, l_35, (safe_rshift_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_u(func_40((0U == ((*l_42) = l_35))), (l_506 == l_508))) & (safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((l_35 & ((*l_513) = ((l_35 != 0x5B5C) <= 0U))), 3)), l_35))) , l_43), 5)), l_35);
    (*l_528) = func_47(&l_43, l_525.f3, ((*l_526) = l_525.f0));
    return l_530;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_30(uint32_t  p_31, int16_t  p_32, uint32_t  p_33, uint32_t  p_34)
{ /* block id: 360 */
    struct S0 l_515 = {1,19,0x85BCDF6C,460};
    struct S0 *l_516 = (void*)0;
    struct S0 *l_517 = &l_515;
    int32_t l_519 = 0x6B300AB5;
    int32_t *l_518 = &l_519;
    struct S0 **l_521 = &l_516;
    struct S0 ***l_520 = &l_521;
    struct S0 ****l_522 = &l_520;
    struct S0 l_523 = {0,63,0xFCC4A9D1,486};
    (*l_518) = (((*l_517) = l_515) , p_32);
    (*l_522) = l_520;
    return l_523;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_40(int32_t  p_41)
{ /* block id: 38 */
    uint32_t l_46 = 4294967295U;
    int32_t l_483 = (-1);
    int32_t *l_482 = &l_483;
    int32_t **l_481 = &l_482;
    uint16_t l_489 = 0xE666;
    uint16_t *l_488 = &l_489;
    int32_t ***l_491 = &l_481;
    int32_t ****l_490 = &l_491;
    int32_t ****l_492 = &l_491;
    uint8_t l_504 = 247U;
    (*l_481) = func_44(l_46);
    for (l_46 = 0; (l_46 != 41); l_46 = safe_add_func_uint16_t_u_u(l_46, 1))
    { /* block id: 346 */
        struct S0 l_486 = {0,54,0xD587327D,61};
        struct S0 *l_487 = &l_486;
        int32_t ***l_493 = &l_481;
        int32_t *l_501 = &l_486.f2;
        int32_t l_503 = 2;
        int32_t *l_502 = &l_503;
        int32_t *l_505 = &l_483;
        (*l_487) = l_486;
        (*l_487) = (*l_487);
        (**l_491) = func_47(l_488, (((l_490 == (l_492 = (void*)0)) , l_493) != (((*l_502) = (safe_div_func_uint32_t_u_u((((*l_488) = (safe_div_func_uint16_t_u_u(((((*l_501) = (p_41 | (l_483 = (safe_add_func_int16_t_s_s(p_41, ((l_482 != ((!p_41) , (void*)0)) & p_41)))))) == p_41) == p_41), p_41))) == (-1)), p_41))) , (*l_490))), l_504);
        (*l_505) = ((*l_501) = p_41);
    }
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(int32_t  p_45)
{ /* block id: 39 */
    uint16_t l_55 = 1U;
    uint16_t *l_54 = &l_55;
    uint16_t *l_328 = (void*)0;
    uint16_t **l_327 = &l_328;
    struct S0 *l_368 = (void*)0;
    int32_t l_413 = 5;
    int32_t *l_412 = &l_413;
    int32_t *l_415 = &l_413;
    int32_t *l_420 = (void*)0;
    uint8_t l_450 = 0x4D;
    int32_t *l_480 = (void*)0;
    if ((5U != (p_45 , p_45)))
    { /* block id: 40 */
        uint16_t l_52 = 1U;
        uint16_t *l_51 = &l_52;
        uint16_t **l_53 = &l_51;
        int32_t l_61 = 0;
        int32_t *l_60 = &l_61;
        uint8_t l_66 = 255U;
        uint8_t *l_65 = &l_66;
        float l_348 = 0x0.Bp-1;
        float *l_347 = &l_348;
        int32_t **l_365 = &l_60;
        int16_t l_372 = 0x3D4B;
        int16_t *l_371 = &l_372;
        int32_t *l_373 = &l_61;
        struct S0 l_398 = {1,-27,0,54};
        int32_t *l_416 = &l_61;
        (*l_365) = func_47((l_54 = ((*l_53) = l_51)), ((*l_347) = func_56(l_60, func_62((*l_60), ((*l_65) = 0x4A)), l_327)), l_55);
        if (__builtin_bswap32(((safe_lshift_func_uint16_t_u_u((p_45 <= l_55), (l_368 != (l_55 , l_368)))) < (safe_add_func_int32_t_s_s(((*l_373) = __builtin_ia32_crc32qi(((l_55 > (((*l_371) = 0x14B1) != l_55)) && (((*l_51) = 0xDE78) > l_55)), p_45)), l_55)))))
        { /* block id: 271 */
lbl_374:
            (*l_373) = l_55;
        }
        else
        { /* block id: 273 */
            uint8_t *l_379 = &l_66;
            uint8_t **l_380 = &l_65;
            uint8_t **l_381 = &l_379;
            float l_382 = 0x1.91985Dp-40;
            int32_t l_387 = 0xB794F4AF;
            struct S0 *l_388 = (void*)0;
            struct S0 l_390 = {0,38,-1,361};
            struct S0 *l_389 = &l_390;
            struct S0 l_392 = {0,-53,0xCB149EEA,460};
            struct S0 *l_391 = &l_392;
            struct S0 *l_393 = (void*)0;
            struct S0 l_395 = {0,-57,1,470};
            struct S0 *l_394 = &l_395;
            int32_t *l_414 = &l_413;
            int32_t *l_417 = &l_395.f2;
            int32_t *l_419 = (void*)0;
            if (l_55)
                goto lbl_374;
            (*l_394) = ((*l_391) = ((*l_389) = func_62((safe_add_func_float_f_f(0x9.5p+1, 0x4.Bp+1)), (l_55 , ((p_45 || ((((safe_mod_func_int32_t_s_s((((*l_381) = ((*l_380) = l_379)) == &l_66), p_45)) < ((l_55 , (safe_rshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s(l_55, (-1))), 9))) || l_387)) >= (-1)) < p_45)) == l_55)))));
            for (l_387 = 0; (l_387 <= (-9)); l_387 = safe_sub_func_int32_t_s_s(l_387, 1))
            { /* block id: 282 */
                int32_t l_408 = 0x39AC4197;
                int32_t *l_410 = &l_392.f2;
                (*l_391) = l_398;
                for (l_55 = (-24); (l_55 >= 11); l_55 = safe_add_func_int16_t_s_s(l_55, 6))
                { /* block id: 286 */
                    uint32_t *l_404 = (void*)0;
                    uint32_t **l_403 = &l_404;
                    for (l_398.f2 = 0; (l_398.f2 <= 13); l_398.f2++)
                    { /* block id: 289 */
                        uint32_t ***l_405 = &l_403;
                        (*l_405) = l_403;
                    }
                }
                for (l_61 = (-9); (l_61 >= (-23)); l_61 = safe_sub_func_int32_t_s_s(l_61, 1))
                { /* block id: 295 */
                    int32_t *l_409 = &l_387;
                    int32_t *l_411 = &l_61;
                    int32_t *l_418 = &l_395.f2;
                    if (l_408)
                    { /* block id: 296 */
                        (*l_365) = (void*)0;
                        (*l_365) = (*l_365);
                    }
                    else
                    { /* block id: 299 */
                        (*l_347) = l_408;
                    }
                    return l_419;
                }
                (*l_415) = (*l_416);
            }
        }
        return l_420;
    }
    else
    { /* block id: 308 */
        uint8_t **l_444 = (void*)0;
        uint8_t ***l_443 = &l_444;
        uint8_t ****l_442 = &l_443;
        int32_t l_449 = 0;
        int32_t l_457 = 0x4F28CE03;
        uint32_t l_477 = 4294967286U;
        for (p_45 = 15; (p_45 <= (-3)); p_45 = safe_sub_func_int16_t_s_s(p_45, 6))
        { /* block id: 311 */
            struct S0 l_425 = {0,13,-3,231};
            uint16_t l_456 = 65534U;
            uint16_t **l_476 = &l_54;
            int32_t *l_479 = (void*)0;
            for (l_413 = 0; (l_413 >= (-10)); l_413 = safe_sub_func_uint32_t_u_u(l_413, 1))
            { /* block id: 314 */
                struct S0 *l_426 = &l_425;
                int32_t l_432 = 0xB619E40E;
                int32_t l_448 = 0x32C7D45E;
                (*l_426) = l_425;
                for (l_55 = 0; (l_55 < 21); l_55 = safe_add_func_uint32_t_u_u(l_55, 9))
                { /* block id: 318 */
                    int32_t l_431 = 2;
                    int32_t l_446 = 5;
                    uint32_t l_462 = 0xE289E865;
                    uint32_t *l_461 = &l_462;
                    int16_t l_464 = 0x9EC2;
                    int16_t *l_463 = &l_464;
                    int32_t **l_478 = &l_420;
                    for (l_425.f2 = 0; (l_425.f2 == 10); l_425.f2 = safe_add_func_uint32_t_u_u(l_425.f2, 9))
                    { /* block id: 321 */
                        uint32_t l_440 = 0xB557AA6E;
                        uint32_t *l_439 = &l_440;
                        uint32_t **l_438 = &l_439;
                        uint32_t ***l_437 = &l_438;
                        uint8_t *****l_445 = &l_442;
                        int32_t *l_447 = &l_432;
                        l_449 = ((((*l_447) = (l_431 != ((l_432 > (l_446 = (safe_add_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(1U, (((l_437 != ((((*l_439) = l_431) , (safe_unary_minus_func_int32_t_s((l_432 , (((*l_445) = l_442) != &l_443))))) , &l_438)) <= p_45) , p_45))), (-1))))) != (*l_415)))) > p_45) > l_448);
                    }
                    l_446 = (p_45 || (l_450 , (((0x479D4BE2 || (l_425.f2 = p_45)) , (p_45 && (safe_sub_func_uint16_t_u_u((l_449 = (~(safe_mod_func_uint16_t_u_u(l_456, p_45)))), l_457)))) ^ ((safe_lshift_func_int16_t_s_u(((*l_463) = (safe_unary_minus_func_uint32_t_u(((*l_461) = ((*l_415) != l_432))))), p_45)) && p_45))));
                    (*l_478) = (((safe_div_func_int16_t_s_s(p_45, ((safe_div_func_uint32_t_u_u((safe_div_func_int16_t_s_s((~0x222758ED), ((*l_463) = (safe_add_func_int32_t_s_s(l_449, (safe_div_func_uint32_t_u_u(func_76(l_476, l_432, (*l_476), &l_446, ((*l_478) = func_47((*l_476), l_477, p_45))), (*l_415)))))))), p_45)) || p_45))) ^ p_45) , l_479);
                    if ((*l_412))
                        break;
                }
            }
            return l_479;
        }
    }
    return l_480;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_47(uint16_t * p_48, float  p_49, uint8_t  p_50)
{ /* block id: 260 */
    int32_t l_352 = (-9);
    int32_t *l_351 = &l_352;
    int32_t *l_354 = &l_352;
    int32_t *l_356 = &l_352;
    int32_t *l_357 = &l_352;
    int32_t *l_358 = &l_352;
    int32_t *l_362 = &l_352;
    int32_t *l_363 = &l_352;
    int32_t *l_364 = (void*)0;
    for (p_50 = 0; (p_50 <= 23); p_50 = safe_add_func_int16_t_s_s(p_50, 7))
    { /* block id: 263 */
        int32_t *l_353 = &l_352;
        int32_t *l_355 = &l_352;
        int32_t *l_359 = &l_352;
        int32_t *l_360 = &l_352;
        int32_t *l_361 = (void*)0;
        return l_361;
    }
    return l_364;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_56(int32_t * p_57, struct S0  p_58, uint16_t ** p_59)
{ /* block id: 250 */
    uint8_t l_329 = 0xD1;
    int16_t l_331 = (-1);
    int16_t *l_330 = &l_331;
    int32_t l_333 = 0;
    int32_t *l_332 = &l_333;
    int32_t l_336 = 0xD70B6333;
    int32_t *l_335 = &l_336;
    int32_t **l_334 = &l_335;
    float l_345 = 0x1.0p-1;
    int32_t *l_346 = &l_336;
    (*l_334) = (((*l_332) = ((func_62(l_329, p_58.f0) , l_330) == &l_331)) , l_332);
    (**l_334) = ((*l_335) < 3U);
    (*p_57) = __builtin_ffs((safe_div_func_int32_t_s_s(func_93(((*l_334) = p_57)), (safe_sub_func_uint16_t_u_u((l_336 = ((safe_add_func_int32_t_s_s((func_93(((p_58.f3 < (-8)) , (void*)0)) | ((((safe_sub_func_int32_t_s_s((l_329 && __builtin_parity(p_58.f1)), p_58.f1)) , p_58.f2) , (*p_57)) != 3U)), 6U)) < p_58.f0)), l_331)))));
    (*l_334) = l_346;
    return p_58.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_62(float  p_63, uint8_t  p_64)
{ /* block id: 44 */
    int16_t l_67 = (-8);
    uint16_t l_88 = 65535U;
    uint16_t *l_87 = &l_88;
    uint16_t **l_86 = &l_87;
    uint16_t **l_89 = &l_87;
    struct S0 l_90 = {0,6,1,300};
    int32_t *l_258 = &l_90.f2;
    if (((l_67 != (safe_div_func_uint16_t_u_u(((**l_86) = (((safe_add_func_int32_t_s_s((3U || l_67), ((((safe_mod_func_uint32_t_u_u(l_67, (safe_mod_func_uint16_t_u_u(l_67, p_64)))) <= (func_76(func_82(l_86, (l_89 = (void*)0), l_90), p_64, (*l_86), l_258, l_258) > p_64)) || 0) , (*l_258)))) ^ 0xF2429CAB) == p_64)), p_64))) != (*l_258)))
    { /* block id: 204 */
        int32_t *l_274 = (void*)0;
        int16_t *l_283 = &l_67;
        struct S0 *l_306 = (void*)0;
        float l_309 = 0x6.2p+1;
        float *l_308 = &l_309;
        if ((*l_258))
        { /* block id: 205 */
            int32_t *l_262 = &l_90.f2;
            int32_t **l_263 = &l_262;
            struct S0 l_264 = {1,-28,2,267};
            struct S0 *l_265 = &l_90;
            (*l_263) = l_262;
            (*l_265) = (l_264 = ((*l_262) , l_264));
        }
        else
        { /* block id: 209 */
            float l_266 = 0x0.Ap+1;
            int32_t l_268 = (-1);
            int32_t *l_267 = &l_268;
lbl_271:
            (*l_267) = ((*l_258) = __builtin_popcountll(p_64));
            if ((safe_lshift_func_int16_t_s_s((*l_267), 5)))
            { /* block id: 212 */
                int32_t l_304 = (-1);
                if (l_90.f2)
                    goto lbl_271;
                for (p_64 = 0; (p_64 < 56); p_64++)
                { /* block id: 216 */
                    int32_t **l_275 = &l_258;
                    uint16_t **l_293 = &l_87;
                    (*l_275) = l_274;
                    for (l_90.f2 = 10; (l_90.f2 <= (-14)); l_90.f2 = safe_sub_func_uint16_t_u_u(l_90.f2, 5))
                    { /* block id: 220 */
                        int32_t ***l_280 = &l_275;
                        float *l_282 = &l_266;
                        (*l_282) = (safe_sub_func_float_f_f((((*l_280) = &l_258) == (void*)0), (!p_63)));
                    }
                    if (((void*)0 != l_283))
                    { /* block id: 224 */
                        int32_t ***l_285 = &l_275;
                        int32_t ****l_284 = &l_285;
                        struct S0 *l_286 = &l_90;
                        if (p_64)
                            break;
                        (*l_284) = &l_275;
                        (*l_286) = l_90;
                    }
                    else
                    { /* block id: 228 */
                        struct S0 ***l_287 = (void*)0;
                        struct S0 ****l_288 = (void*)0;
                        struct S0 ****l_289 = &l_287;
                        uint32_t l_295 = 4294967293U;
                        uint32_t *l_294 = &l_295;
                        float *l_302 = &l_266;
                        int32_t l_303 = 0x0B3DA9CE;
                        (*l_289) = l_287;
                        if (p_64)
                            continue;
                        (*l_267) = ((((safe_div_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u(p_64)), __builtin_popcountl((((*l_294) = (p_64 && ((void*)0 != l_293))) == (safe_div_func_int16_t_s_s(((((safe_sub_func_float_f_f(((((safe_add_func_float_f_f(((*l_302) = (p_64 > p_64)), ((func_93(l_274) == (l_303 > p_63)) != 0x0.58F65Cp-91))) > p_63) > p_63) > 0x0.7p+1), (*l_267))) < 0x3.4p-1) , 4294967294U) && l_304), l_303)))))) | p_64) | 8) != 6);
                    }
                }
            }
            else
            { /* block id: 236 */
                float l_305 = 0x9.6p+1;
                struct S0 **l_307 = &l_306;
                (*l_267) = p_64;
                (*l_307) = l_306;
            }
        }
        (*l_308) = 0x1.75DE99p-3;
    }
    else
    { /* block id: 242 */
        uint32_t l_315 = 0U;
        uint32_t *l_314 = &l_315;
        uint32_t *l_316 = (void*)0;
        uint32_t l_318 = 1U;
        uint32_t *l_317 = &l_318;
        uint32_t l_320 = 0x6536C698;
        uint32_t *l_319 = &l_320;
        float l_326 = 0x0.5p-1;
        float *l_325 = &l_326;
        (*l_258) = (!(!(((*l_319) = (safe_add_func_uint16_t_u_u((((*l_258) , ((*l_314) = 0x58A89B08)) ^ ((*l_317) = ((p_64 ^ 0xEB6C887C) | p_64))), 5U))) , ((safe_add_func_int16_t_s_s(((*l_258) , p_64), (safe_add_func_uint16_t_u_u((*l_258), 0xEA4A)))) || p_64))));
        (*l_325) = p_64;
    }
    return l_90;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_76(uint16_t ** p_77, int32_t  p_78, uint16_t * p_79, int32_t * p_80, int32_t * p_81)
{ /* block id: 200 */
    int32_t l_261 = (-8);
    int32_t *l_260 = &l_261;
    int32_t **l_259 = &l_260;
    (*l_259) = &p_78;
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t ** func_82(uint16_t ** p_83, uint16_t ** p_84, struct S0  p_85)
{ /* block id: 46 */
    uint8_t l_92 = 255U;
    uint8_t *l_91 = &l_92;
    int32_t l_96 = 3;
    int32_t *l_95 = &l_96;
    uint32_t l_185 = 5U;
    uint32_t *l_184 = &l_185;
    uint8_t l_195 = 6U;
    uint16_t **l_221 = (void*)0;
    struct S0 l_232 = {1,-3,-1,252};
    int32_t *l_239 = &l_232.f2;
    struct S0 *l_241 = (void*)0;
    struct S0 l_242 = {1,-24,-1,436};
    uint8_t ***l_243 = (void*)0;
    struct S0 **l_245 = &l_241;
    struct S0 ***l_244 = &l_245;
    uint8_t *l_251 = (void*)0;
    float *l_252 = (void*)0;
    float l_254 = 0x0.1p-1;
    float *l_253 = &l_254;
    uint16_t l_255 = 0x0172;
    float l_257 = 0xE.22381Dp-6;
    float *l_256 = &l_257;
    if (((p_85 , ((void*)0 == l_91)) <= ((*l_184) = (l_92 , (l_92 , (((((2 >= func_93(l_95)) & __builtin_bswap64(p_85.f0)) , (void*)0) == (*p_83)) <= (*l_95)))))))
    { /* block id: 145 */
        int32_t *l_186 = &l_96;
        uint16_t l_213 = 65535U;
        uint16_t *l_220 = &l_213;
        uint16_t **l_219 = &l_220;
        struct S0 l_233 = {0,-61,5,99};
        struct S0 *l_234 = &l_233;
        if (p_85.f3)
        { /* block id: 146 */
            int32_t **l_187 = &l_95;
            (*l_187) = l_186;
            (*l_187) = (*l_187);
        }
        else
        { /* block id: 149 */
            int32_t l_212 = 0x13BFE599;
            int32_t *l_214 = &l_96;
            struct S0 l_231 = {0,14,0,141};
            for (l_185 = 10; (l_185 < 4); l_185 = safe_sub_func_uint32_t_u_u(l_185, 1))
            { /* block id: 152 */
                uint32_t l_190 = 4294967295U;
                uint8_t **l_205 = &l_91;
                uint8_t ***l_204 = &l_205;
                if (l_190)
                { /* block id: 153 */
                    int32_t l_201 = 3;
                    int32_t **l_215 = &l_214;
                    (*l_95) = (((0xEEB2DE19 > (safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(l_195, ((**p_83) = (((((safe_add_func_uint32_t_u_u(__builtin_clzll(((~((safe_mod_func_uint16_t_u_u((l_201 & (safe_sub_func_int32_t_s_s((0x12151E35 != (*l_95)), (l_204 == (void*)0)))), (safe_add_func_uint32_t_u_u((((safe_lshift_func_int16_t_s_s((*l_186), 3)) < ((((safe_add_func_uint16_t_u_u(l_212, 0x75F8)) , l_213) , l_212) <= 0x68A2AEEF)) == 0x43DC), p_85.f1)))) , (-6))) , 0xC00CB0D776FE5E69LL)), p_85.f1)) , 65528U) != (**p_83)) && p_85.f1) , 0U)))), l_190))) == p_85.f1) && p_85.f0);
                    (*l_186) = (*l_95);
                    (*l_215) = l_214;
                    for (l_212 = 0; (l_212 >= (-1)); l_212 = safe_sub_func_int16_t_s_s(l_212, 1))
                    { /* block id: 160 */
                        int32_t l_218 = 6;
                        if (l_218)
                            break;
                        (**l_215) = p_85.f3;
                        l_219 = (void*)0;
                    }
                }
                else
                { /* block id: 165 */
                    if ((*l_214))
                        break;
                }
                return l_221;
            }
            if (((p_85.f1 , __builtin_ffsl((*l_95))) != (safe_rshift_func_uint16_t_u_s((**p_83), (safe_add_func_uint32_t_u_u(0x04F2ECF3, (*l_214)))))))
            { /* block id: 170 */
                int32_t *l_226 = &l_96;
                int32_t **l_227 = &l_95;
                (*l_227) = (l_226 = (void*)0);
            }
            else
            { /* block id: 173 */
                uint16_t **l_228 = &l_220;
                return p_83;
            }
            for (l_195 = (-14); (l_195 == 23); l_195 = safe_add_func_uint16_t_u_u(l_195, 4))
            { /* block id: 178 */
                if (p_85.f2)
                    break;
            }
            p_85 = l_231;
        }
        (*l_234) = ((l_96 , l_232) , l_233);
        (*l_234) = p_85;
        for (l_185 = (-23); (l_185 < 13); l_185 = safe_add_func_int16_t_s_s(l_185, 2))
        { /* block id: 187 */
            int32_t **l_237 = &l_186;
            (*l_237) = &l_96;
        }
    }
    else
    { /* block id: 190 */
        int32_t *l_238 = (void*)0;
        int32_t **l_240 = &l_239;
        l_238 = &l_96;
        (*l_240) = l_239;
    }
    l_241 = &l_232;
    (*l_241) = (p_85.f3 , (l_242 = p_85));
    (*l_256) = ((l_243 == l_243) < (((((l_244 != &l_245) > (safe_add_func_float_f_f(((0xC2F4BCE8 != (*l_239)) , p_85.f0), (!((*l_253) = (safe_div_func_float_f_f((((*l_239) , (&l_195 == l_251)) != 0x4.3A8E69p+91), p_85.f3))))))) > p_85.f3) >= (*l_239)) != l_255));
    return l_221;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_93(int32_t * p_94)
{ /* block id: 47 */
    int32_t l_99 = (-9);
    int32_t *l_98 = &l_99;
    int32_t **l_97 = &l_98;
    uint16_t l_102 = 0x468F;
    uint16_t *l_101 = &l_102;
    uint16_t l_104 = 65530U;
    uint16_t *l_103 = &l_104;
    uint8_t l_108 = 0x61;
    uint8_t *l_107 = &l_108;
    uint8_t *l_110 = &l_108;
    uint8_t **l_109 = &l_110;
    struct S0 l_111 = {1,0,0xC93CBC91,57};
    int32_t *l_112 = &l_111.f2;
    float l_113 = (-0x1.9p+1);
    int32_t l_115 = 0xDE0C47FC;
    int32_t *l_114 = &l_115;
    struct S0 *l_174 = &l_111;
    struct S0 **l_173 = &l_174;
    int32_t l_183 = 0xA2DF7CCA;
    (*l_97) = (void*)0;
    return l_183;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 123
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 25
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 15
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 24
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 25

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 122
   depth: 2, occurrence: 22
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 4
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 194

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 123
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 6
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 389

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 233
   level: 2, occurrence: 48
   level: 3, occurrence: 13
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 67
XXX number of pointers point to scalars: 105
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 22.7
XXX average alias set size: 1.14

XXX times a non-volatile is read: 467
XXX times a non-volatile is write: 300
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 19
   depth: 2, occurrence: 17
   depth: 3, occurrence: 15
   depth: 4, occurrence: 15
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 16.2
XXX percentage an existing variable is used: 83.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

