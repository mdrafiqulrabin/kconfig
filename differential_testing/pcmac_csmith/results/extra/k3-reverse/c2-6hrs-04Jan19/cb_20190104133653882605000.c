/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-comma-operators --argc --bitfields --arrays --no-pointers --structs --unions --packed-struct --divs --muls --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --longlong --float --jumps --volatiles --no-compound-assignment --consts --inline-function --volatile-pointers --const-pointers --no-global-variables --builtins --int8 --uint8
 * Seed:      15406052327911479902
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const unsigned f0 : 29;
   int8_t  f1;
   uint32_t  f2;
   uint64_t  f3;
};

struct S1 {
   uint32_t  f0;
   const uint32_t  f1;
   int32_t  f2;
   int8_t  f3;
   int32_t  f4;
   signed f5 : 30;
   int32_t  f6;
};

struct S2 {
   const float  f0;
   const int32_t  f1;
   int32_t  f2;
   int16_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_33(void);
inline static uint8_t  func_42(uint8_t  p_43);
inline static uint16_t  func_66(struct S0  p_67);
static float  func_75(int16_t  p_76, const int64_t  p_77, uint32_t  p_78);
static float  func_100(int32_t  p_101);
static float  func_105(struct S1  p_106, int32_t  p_107, struct S0  p_108);
inline static struct S1  func_109(float  p_110);
inline static float  func_111(const int64_t  p_112, int64_t  p_113);
inline static uint64_t  func_114(int64_t  p_115);
static float  func_116(uint32_t  p_117, uint32_t  p_118, struct S2  p_119, struct S0  p_120);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_33(void)
{ /* block id: 36 */
    int32_t l_34 = 1L;
    int32_t l_53[4][7] = {{5L,5L,5L,5L,5L,5L,5L},{0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L},{5L,5L,5L,5L,5L,5L,5L},{0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L,0xC9D536C3L}};
    int32_t l_54 = 6L;
    int i, j;
    for (l_34 = 0; (l_34 == (-16)); l_34 = safe_sub_func_int64_t_s_s(l_34, 4))
    { /* block id: 39 */
        uint32_t l_39 = 0x29F19B52L;
        int32_t l_40[2];
        int32_t l_50 = (-1L);
        int16_t l_244 = (-1L);
        int i;
        for (i = 0; i < 2; i++)
            l_40[i] = 0x33BD0D81L;
        if (((safe_rshift_func_uint8_t_u_u((((l_39 = l_34) >= (l_40[0] = (l_40[0] ^ 0x7B4AD293D0AE446FLL))) <= (~(l_54 = (func_42(l_34) >= (l_53[2][5] = ((safe_div_func_int32_t_s_s((safe_rshift_func_int8_t_s_u((0x7E9FB133L || ((safe_mul_func_uint16_t_u_u(l_50, (safe_mod_func_uint64_t_u_u((65526UL >= 0x8827L), 0x0C7F43A495B2841CLL)))) ^ 6L)), 1)), l_34)) <= l_50)))))), 1)) <= 0x3EB6B3EEF59DFF04LL))
        { /* block id: 46 */
            uint32_t l_55[2][9] = {{0x8198303FL,0x8198303FL,0x3C5EACAAL,0xDDC18638L,0xE2BF2DCFL,0x3C5EACAAL,0xE2BF2DCFL,0xDDC18638L,0x3C5EACAAL},{0x8198303FL,0x8198303FL,0x3C5EACAAL,0xDDC18638L,0xE2BF2DCFL,0x3C5EACAAL,0xE2BF2DCFL,0xDDC18638L,0x3C5EACAAL}};
            int i, j;
            if (l_55[1][0])
                break;
        }
        else
        { /* block id: 48 */
            uint32_t l_56 = 0x97603614L;
            return l_56;
        }
        l_54 = l_39;
        if (func_42(l_50))
        { /* block id: 52 */
            struct S0 l_68 = {12853,-1L,4UL,0xC45F480A87E9A86FLL};
            int32_t l_210 = 1L;
            int32_t l_213 = 0x84E98FBDL;
            l_53[2][5] = (safe_lshift_func_int16_t_s_s((safe_unary_minus_func_int32_t_s((l_54 = (safe_mod_func_uint8_t_u_u((safe_add_func_int32_t_s_s((l_40[1] = (-1L)), (safe_rshift_func_uint16_t_u_u(l_50, 12)))), (((0L <= (l_210 = (1L == (func_66(l_68) < l_54)))) > __builtin_parityl((l_213 = (safe_rshift_func_int16_t_s_s((l_34 == (l_50 <= l_68.f0)), 7))))) ^ l_34)))))), l_39));
            l_213 = (safe_div_func_uint64_t_u_u(l_210, (l_53[2][5] | l_210)));
        }
        else
        { /* block id: 135 */
            uint32_t l_216 = 0x15DD58F1L;
            int32_t l_250[2];
            int i;
            for (i = 0; i < 2; i++)
                l_250[i] = (-1L);
            if (l_216)
            { /* block id: 136 */
                int32_t l_226 = 1L;
                int32_t l_229 = 6L;
                l_229 = (safe_add_func_float_f_f(((l_53[1][0] = l_54) == (l_216 >= (safe_sub_func_float_f_f(0x7.14B42Ap+70, (l_40[1] > (safe_div_func_float_f_f((!(safe_add_func_float_f_f(0x1.Bp-1, (l_50 = ((((l_226 != (((safe_div_func_float_f_f(l_216, 0x9.AE8C75p+33)) >= (l_216 == l_216)) <= l_226)) != l_226) < l_226) != l_216))))), l_226))))))), l_39));
                return l_34;
            }
            else
            { /* block id: 141 */
                for (l_50 = 0; (l_50 >= 28); ++l_50)
                { /* block id: 144 */
                    return l_50;
                }
            }
            l_40[1] = (safe_mul_func_float_f_f((0x1.Ep+1 < (-0x7.8p-1)), (safe_mul_func_float_f_f(l_50, (safe_mul_func_float_f_f(__builtin_ctz(l_53[2][2]), ((safe_div_func_float_f_f(((__builtin_clzl(((l_250[0] = (safe_mul_func_uint8_t_u_u((l_40[0] = l_50), (safe_sub_func_uint32_t_u_u((l_244 < ((~__builtin_popcountl((safe_add_func_int64_t_s_s((safe_rshift_func_uint16_t_u_s(l_216, l_244)), l_39)))) | 0UL)), l_53[0][1]))))) <= l_50)) != l_216) < 0xD.469CA0p+84), l_216)) == 0x1.6B1092p-9)))))));
        }
        if (l_244)
            break;
    }
    return l_53[0][6];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_42(uint8_t  p_43)
{ /* block id: 42 */
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_66(struct S0  p_67)
{ /* block id: 54 */
    int16_t l_71 = 1L;
    int32_t l_72 = 0x7817F253L;
    int8_t l_94 = 0x32L;
    int32_t l_96[2][6] = {{0x0E0461AFL,0x0E0461AFL,0x81D3E15EL,0x0E0461AFL,0x0E0461AFL,0x81D3E15EL},{0x0E0461AFL,0x0E0461AFL,0x81D3E15EL,0x0E0461AFL,0x0E0461AFL,0x81D3E15EL}};
    int32_t l_97 = 0L;
    int i, j;
    for (p_67.f3 = 8; (p_67.f3 != 2); p_67.f3--)
    { /* block id: 57 */
        int16_t l_91 = 0xD1FFL;
        int32_t l_93[6] = {0xB64809F7L,0xB64809F7L,0L,0xB64809F7L,0xB64809F7L,0L};
        int32_t l_95 = 1L;
        int i;
        l_72 = l_71;
        for (l_72 = (-1); (l_72 > 29); l_72 = safe_add_func_uint64_t_u_u(l_72, 6))
        { /* block id: 61 */
            int64_t l_199 = 0x1B74B7467CF25E2ELL;
            int32_t l_200 = (-6L);
            l_95 = (l_94 = (l_93[3] = ((func_75(p_67.f0, (safe_div_func_uint16_t_u_u(((((safe_add_func_int64_t_s_s(func_42((safe_lshift_func_int8_t_s_u((((safe_lshift_func_uint16_t_u_u(((0UL | (p_67.f0 & (func_42(l_71) | 0UL))) <= ((safe_add_func_uint64_t_u_u(l_72, (safe_sub_func_uint8_t_u_u(0x67L, l_71)))) || p_67.f2)), 2)) | p_67.f2) && p_67.f0), 2))), 1UL)) || (-6L)) || l_91) ^ 0x01L), l_91)), p_67.f1) > p_67.f1) >= p_67.f0)));
            l_97 = (l_96[0][1] = (-1L));
            for (l_71 = (-3); (l_71 >= 20); l_71++)
            { /* block id: 71 */
                int32_t l_190 = 9L;
                l_190 = func_100(p_67.f2);
            }
            for (l_91 = 5; (l_91 >= 0); l_91 -= 1)
            { /* block id: 116 */
                int i;
                l_200 = (l_93[l_91] = (func_114((l_93[l_91] = ((l_93[l_91] != ((safe_rshift_func_uint8_t_u_s((((safe_rshift_func_uint16_t_u_s((65535UL <= 0xD523L), 5)) > l_93[l_91]) ^ (safe_mul_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((__builtin_parity((l_95 = 6UL)) || l_199), (0x1322C40B45B73C7DLL < p_67.f2))), p_67.f3))), 7)) | p_67.f3)) && l_199))) & 4294967295UL));
                l_96[0][1] = l_96[0][1];
                l_93[l_91] = (safe_unary_minus_func_int8_t_s(((safe_mod_func_int8_t_s_s((l_97 && (p_67.f3 < (0xEC5B9867C341A536LL && p_67.f0))), l_93[0])) <= (safe_sub_func_int16_t_s_s(0x1922L, (l_200 = ((safe_add_func_int64_t_s_s((l_96[0][0] = l_96[0][1]), l_199)) >= (((safe_mul_func_uint16_t_u_u(0x5CE6L, p_67.f1)) < 4294967286UL) || p_67.f2))))))));
                if (l_97)
                    break;
            }
        }
    }
    return p_67.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_75(int16_t  p_76, const int64_t  p_77, uint32_t  p_78)
{ /* block id: 62 */
    uint32_t l_92 = 0x35235ED9L;
    return l_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_100(int32_t  p_101)
{ /* block id: 72 */
    int16_t l_104 = 0x74D5L;
    struct S0 l_177[8] = {{8292,5L,0UL,0x17E293C1CF12C9E7LL},{8292,5L,0UL,0x17E293C1CF12C9E7LL},{9721,0x5DL,0xBE87DA6AL,2UL},{8292,5L,0UL,0x17E293C1CF12C9E7LL},{8292,5L,0UL,0x17E293C1CF12C9E7LL},{9721,0x5DL,0xBE87DA6AL,2UL},{8292,5L,0UL,0x17E293C1CF12C9E7LL},{8292,5L,0UL,0x17E293C1CF12C9E7LL}};
    int32_t l_179 = 0L;
    int i;
    l_179 = (safe_sub_func_float_f_f(l_104, func_105(func_109((func_111((func_114(p_101) && (!(safe_mul_func_uint8_t_u_u(((safe_add_func_uint16_t_u_u(l_104, ((p_101 != p_101) & l_104))) != __builtin_ctzl(func_42(l_104))), (-7L))))), p_101) > l_104)), l_104, l_177[3])));
    l_179 = (p_101 & (-1L));
    l_179 = (safe_add_func_int16_t_s_s(p_101, (safe_add_func_uint64_t_u_u(((0xA314E8DBFCDDE50ALL && 0xC52370E7266255C8LL) < ((safe_add_func_uint64_t_u_u((__builtin_ctzl(p_101) == p_101), (safe_mod_func_int64_t_s_s(l_179, l_177[3].f2)))) & (p_101 != l_104))), l_177[3].f0))));
    return p_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_105(struct S1  p_106, int32_t  p_107, struct S0  p_108)
{ /* block id: 105 */
    int32_t l_178 = 0xA0EB5DC2L;
    p_106.f6 = l_178;
    return p_108.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_109(float  p_110)
{ /* block id: 88 */
    int8_t l_148[7];
    int32_t l_161 = (-1L);
    int32_t l_162 = (-9L);
    int32_t l_163 = 0x5F3850ECL;
    int8_t l_167 = 1L;
    int32_t l_172 = (-5L);
    int32_t l_173 = 0xC6B87B52L;
    int32_t l_174 = (-1L);
    struct S1 l_176[10][2] = {{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}},{{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L},{0x5843DDAEL,1UL,-1L,0xA7L,7L,28884,1L}}};
    int i, j;
    for (i = 0; i < 7; i++)
        l_148[i] = 0xCEL;
lbl_175:
    l_163 = ((safe_mul_func_float_f_f((l_162 = (safe_sub_func_float_f_f(((safe_mul_func_float_f_f((safe_div_func_float_f_f(l_148[5], (safe_sub_func_float_f_f(l_148[5], (l_148[5] > (safe_mul_func_float_f_f((p_110 = (0x5.6A0A4Bp-26 > (safe_sub_func_float_f_f(((-0x3.1p-1) == (p_110 != ((safe_add_func_float_f_f((p_110 == (safe_div_func_float_f_f(((l_161 = (0x4.1DB1EAp-23 >= (safe_sub_func_float_f_f(0x8.30C378p-68, l_148[2])))) <= 0x7.698F8Dp-20), p_110))), p_110)) < l_148[1]))), p_110)))), l_148[5]))))))), l_148[2])) < 0x5.787EC6p-99), (-0x1.1p+1)))), l_148[3])) < 0x1.1p+1);
    l_174 = (((l_162 = (255UL | (l_163 = l_163))) != (((l_148[5] && (safe_add_func_int32_t_s_s(l_148[0], (~(l_167 && (l_148[5] <= (l_173 = (l_172 = (l_161 = ((l_148[5] & ((safe_mod_func_uint8_t_u_u(l_167, func_42(l_161))) > 0x7CL)) && l_167)))))))))) < l_167) & 0x083ECD7AL)) & l_148[5]);
    for (l_162 = 0; (l_162 <= 6); l_162 += 1)
    { /* block id: 101 */
        if (l_161)
            goto lbl_175;
    }
    return l_176[8][0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_111(const int64_t  p_112, int64_t  p_113)
{ /* block id: 84 */
    uint64_t l_138 = 18446744073709551607UL;
    int32_t l_139 = 1L;
    l_138 = p_112;
    l_139 = 0x6CBE952DL;
    return p_113;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_114(int64_t  p_115)
{ /* block id: 73 */
    uint32_t l_125 = 18446744073709551615UL;
    int32_t l_126[5][7][4] = {{{0L,0x74A9F0F7L,0x74A9F0F7L,0L},{1L,0x74A9F0F7L,(-5L),(-8L)},{(-8L),0x151F1203L,(-5L),0x0DBADF69L},{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L},{0L,0x151F1203L,(-9L),(-8L)},{0L,0x74A9F0F7L,0x74A9F0F7L,0L},{1L,0x74A9F0F7L,(-5L),(-8L)}},{{(-8L),0x151F1203L,(-5L),0x0DBADF69L},{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L},{0L,0x151F1203L,(-9L),(-8L)},{0L,0x74A9F0F7L,0x74A9F0F7L,0L},{1L,0x74A9F0F7L,(-5L),(-8L)},{(-8L),0x151F1203L,(-5L),0x0DBADF69L},{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L}},{{0L,0x151F1203L,(-9L),(-8L)},{0L,0x74A9F0F7L,0x74A9F0F7L,0L},{1L,0x74A9F0F7L,(-5L),(-8L)},{(-8L),0x151F1203L,(-5L),0x0DBADF69L},{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L},{0L,0x151F1203L,(-9L),(-8L)},{0L,0x74A9F0F7L,0x74A9F0F7L,0L}},{{1L,0x74A9F0F7L,(-5L),(-8L)},{(-8L),0x151F1203L,(-5L),0x0DBADF69L},{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L},{0L,0x151F1203L,(-9L),(-8L)},{0L,0x74A9F0F7L,0x74A9F0F7L,0L},{1L,0x74A9F0F7L,(-5L),(-8L)},{(-8L),0x151F1203L,(-5L),0x0DBADF69L}},{{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L},{0L,0x151F1203L,(-9L),(-8L)},{0L,0x74A9F0F7L,0x74A9F0F7L,0L},{1L,0x74A9F0F7L,(-5L),(-8L)},{(-8L),0x151F1203L,(-5L),0x0DBADF69L},{1L,0xC30626F2L,0x74A9F0F7L,0x0DBADF69L},{0L,0x151F1203L,(-9L),(-8L)}}};
    float l_127 = 0xE.48FED4p+32;
    int32_t l_128 = (-1L);
    struct S2 l_129[2] = {{0x8.Ep-1,-1L,-1L,-1L},{0x8.Ep-1,-1L,-1L,-1L}};
    struct S0 l_130 = {22000,0x84L,0x27D48C05L,0x145734C7933BFEBFLL};
    int i, j, k;
    l_129[0].f2 = func_116(p_115, (safe_sub_func_int16_t_s_s((safe_add_func_uint64_t_u_u((l_126[2][2][0] = l_125), l_125)), (__builtin_clzl(p_115) >= ((l_128 = ((l_125 >= p_115) & p_115)) <= (((__builtin_ia32_crc32qi(p_115, p_115) < l_125) != l_125) <= l_125))))), l_129[0], l_130);
    l_129[0].f2 = (-0x6.4p+1);
    l_126[1][3][3] = (p_115 || func_42(p_115));
    return p_115;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_116(uint32_t  p_117, uint32_t  p_118, struct S2  p_119, struct S0  p_120)
{ /* block id: 76 */
    int64_t l_131 = (-1L);
    int32_t l_132 = 0x9F1547C5L;
    l_132 = l_131;
    p_119.f2 = (-1L);
    return p_120.f3;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 58
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 4
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 8

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 11, occurrence: 1
   depth: 14, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 179
XXX times a non-volatile is write: 62
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 52
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 7
   depth: 2, occurrence: 10
   depth: 3, occurrence: 8
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 27.6
XXX percentage an existing variable is used: 72.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

