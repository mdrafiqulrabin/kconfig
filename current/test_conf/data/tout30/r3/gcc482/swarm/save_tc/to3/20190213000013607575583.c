/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-comma-operators --no-argc --no-bitfields --no-arrays --pointers --structs --no-unions --no-packed-struct --divs --muls --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --longlong --float --jumps --no-volatiles --no-compound-assignment --no-consts --inline-function --volatile-pointers --const-pointers --no-global-variables --builtins --no-int8 --no-uint8
 * Seed:      2998532724
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
};

struct S1 {
   int64_t  f0;
   uint64_t  f1;
   uint64_t  f2;
   struct S0  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_33(void);
static struct S0 * func_34(uint32_t  p_35, int32_t  p_36);
static uint64_t  func_38(struct S0 * p_39, struct S0 * p_40, struct S1  p_41, int32_t  p_42);
inline static struct S0 * func_45(uint32_t  p_46, float  p_47, struct S0 ** p_48, uint32_t  p_49, struct S1  p_50);
inline static uint32_t  func_51(float  p_52, uint64_t  p_53, struct S0 ** p_54, struct S0 * p_55, uint16_t  p_56);
static float  func_57(struct S0 ** p_58, uint16_t  p_59);
inline static struct S0 ** func_60(int16_t  p_61, struct S0 * p_62, int32_t  p_63);
inline static struct S0 * func_64(int32_t  p_65);
inline static struct S0  func_73(struct S0  p_74, struct S0 ** p_75, int16_t  p_76, int16_t  p_77);
static int32_t  func_82(uint32_t  p_83, int32_t ** p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_33(void)
{ /* block id: 36 */
    int64_t l_37 = (-2L);
    struct S0 *l_43 = (void*)0;
    struct S0 **l_44 = &l_43;
    uint32_t *l_194 = (void*)0;
    int32_t l_196 = 1L;
    int32_t *l_195 = &l_196;
    struct S0 l_400 = {-9L};
    struct S0 *l_399 = &l_400;
    int32_t l_403 = 0x63BB0C62L;
    int64_t l_404 = 3L;
    struct S0 **l_405 = &l_399;
    struct S1 l_406 = {0L,0xE3A75C545DF848EFLL,18446744073709551608UL,{1L}};
    uint64_t *l_440 = &l_406.f2;
    uint16_t *****l_444 = (void*)0;
    uint32_t l_446 = 0x7FC44B10L;
    uint32_t *l_445 = &l_446;
    int16_t l_484 = 0x7D3AL;
    (*l_44) = func_34((l_37 ^ ((*l_440) = func_38(((*l_44) = l_43), func_45((l_403 = (func_51((l_37 >= ((func_57(func_60(l_37, func_64(l_37), ((*l_195) = (safe_add_func_int16_t_s_s((l_37 == l_37), (l_194 != (void*)0))))), l_37) <= l_37) > l_37)), l_37, l_44, l_399, l_400.f0) ^ 4294967295UL)), l_404, l_405, l_404, l_406), l_406, l_37))), l_406.f3.f0);
    if (((((*l_445) = (l_444 == l_444)) && ((safe_mod_func_uint16_t_u_u(l_400.f0, ((&l_196 != (void*)0) ^ (safe_rshift_func_int16_t_s_u(l_37, l_406.f2))))) && (safe_mul_func_int16_t_s_s(l_404, ((safe_add_func_uint16_t_u_u((l_406.f0 & l_406.f1), l_406.f2)) || l_196))))) ^ l_406.f2))
    { /* block id: 319 */
        struct S0 *l_457 = &l_400;
        int32_t *l_458 = &l_403;
        int32_t *l_459 = (void*)0;
        int32_t l_460 = (-1L);
        l_460 = (safe_sub_func_int32_t_s_s((((*l_405) = l_457) == l_457), ((*l_458) = (l_458 == &l_403))));
        l_406 = l_406;
    }
    else
    { /* block id: 324 */
        int64_t l_474 = 0xA0B9FCD69D5A18F3LL;
        int32_t l_475 = 1L;
        int32_t l_476 = 0x9EBD0323L;
        int32_t l_480 = 0x6E516010L;
        struct S1 *l_482 = &l_406;
        for (l_37 = (-24); (l_37 > (-11)); l_37 = safe_add_func_int64_t_s_s(l_37, 2))
        { /* block id: 327 */
            struct S1 **l_483 = &l_482;
            l_444 = (void*)0;
            for (l_196 = 0; (l_196 != 18); l_196 = safe_add_func_uint32_t_u_u(l_196, 3))
            { /* block id: 331 */
                int16_t l_469 = 0x1EE3L;
                float l_477 = (-0x1.Bp-1);
                int64_t *l_478 = &l_406.f0;
                int64_t *l_479 = &l_474;
                int32_t *l_481 = &l_480;
                for (l_406.f3.f0 = 25; (l_406.f3.f0 < (-12)); l_406.f3.f0--)
                { /* block id: 334 */
                    for (l_404 = (-19); (l_404 != 28); l_404 = safe_add_func_uint16_t_u_u(l_404, 1))
                    { /* block id: 337 */
                        if (l_469)
                            break;
                    }
                }
                (*l_481) = (l_469 && ((((*l_479) = ((*l_478) = (((safe_add_func_uint16_t_u_u(__builtin_ffsl(l_406.f1), (safe_sub_func_int16_t_s_s((__builtin_bswap32(l_474) != (__builtin_clzll(__builtin_ctzll(l_474)) || (l_476 = (l_475 = l_474)))), l_474)))) < l_474) & l_474))) != l_480) != 9UL));
            }
            (*l_483) = l_482;
        }
    }
    return l_484;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_34(uint32_t  p_35, int32_t  p_36)
{ /* block id: 314 */
    struct S1 l_441 = {-2L,0UL,18446744073709551615UL,{-1L}};
    struct S0 *l_442 = &l_441.f3;
    struct S0 *l_443 = (void*)0;
    l_441 = l_441;
    return l_443;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_38(struct S0 * p_39, struct S0 * p_40, struct S1  p_41, int32_t  p_42)
{ /* block id: 310 */
    int64_t **l_437 = (void*)0;
    int64_t ***l_438 = &l_437;
    int32_t l_439 = (-5L);
    (*l_438) = l_437;
    return l_439;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_45(uint32_t  p_46, float  p_47, struct S0 ** p_48, uint32_t  p_49, struct S1  p_50)
{ /* block id: 295 */
    float l_407 = 0xD.A9B2B1p+77;
    int32_t l_408 = 2L;
    struct S0 **l_409 = (void*)0;
    uint64_t l_415 = 0xD2DD311D72E1F03ALL;
    uint64_t *l_414 = &l_415;
    uint32_t *l_416 = (void*)0;
    uint32_t *l_417 = (void*)0;
    uint32_t l_419 = 4294967295UL;
    uint32_t *l_418 = &l_419;
    int32_t *l_420 = &l_408;
    int32_t **l_421 = &l_420;
    float *l_428 = &l_407;
    int32_t ****l_431 = (void*)0;
    float l_433 = 0xC.C0743Bp-2;
    float *l_432 = &l_433;
    (*l_420) = (p_50.f1 | func_51(l_408, p_49, l_409, (*p_48), (((*l_418) = ((((*l_414) = ((safe_mul_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(p_46, 6)), p_50.f1)) > (l_408 == l_408))) > 0xD65FEBDA90EAA7AALL) & l_408)) | p_49)));
lbl_436:
    (*l_421) = &l_408;
    (*l_432) = (((safe_add_func_float_f_f((safe_add_func_float_f_f((((safe_div_func_float_f_f((**l_421), (**l_421))) >= p_50.f2) != (l_428 != (void*)0)), 0x0.5C516Fp-73)), ((((*l_428) = (safe_mul_func_float_f_f((**l_421), p_50.f2))) == (((l_431 == (void*)0) >= p_50.f0) > p_50.f0)) >= p_50.f3.f0))) <= (**l_421)) != 0x9.23DFDCp-65);
    for (l_415 = 0; (l_415 < 48); l_415 = safe_add_func_int64_t_s_s(l_415, 1))
    { /* block id: 304 */
        if (l_415)
            goto lbl_436;
        if (p_50.f0)
            continue;
        (**p_48) = (**p_48);
    }
    return (*p_48);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_51(float  p_52, uint64_t  p_53, struct S0 ** p_54, struct S0 * p_55, uint16_t  p_56)
{ /* block id: 291 */
    int32_t l_402 = (-1L);
    int32_t *l_401 = &l_402;
    l_401 = l_401;
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_57(struct S0 ** p_58, uint16_t  p_59)
{ /* block id: 203 */
    uint16_t l_286 = 65535UL;
    uint16_t *l_285 = &l_286;
    uint16_t **l_284 = &l_285;
    uint16_t ***l_283 = &l_284;
    uint16_t ****l_287 = &l_283;
    int32_t l_288 = 0xF4331D11L;
    int32_t l_314 = 0x655B2EAFL;
    int64_t l_315 = 0x838847EDA4BA7FAELL;
    struct S0 l_323 = {0x5351L};
    float l_352 = 0x3.584AD0p+56;
    float *l_351 = &l_352;
    float **l_350 = &l_351;
    int32_t *l_358 = (void*)0;
    int32_t **l_357 = &l_358;
    int32_t ***l_356 = &l_357;
    struct S1 l_364 = {0x324B573957DEBA7DLL,0x984E9515FB0BF56ELL,0xE30F08B5B5E61D60LL,{0L}};
    int16_t *l_380 = &l_364.f3.f0;
    int16_t **l_379 = &l_380;
    int16_t ***l_378 = &l_379;
    int16_t ****l_393 = &l_378;
    int16_t ****l_394 = &l_378;
    float l_396 = 0x0.7p+1;
    float *l_395 = &l_396;
    struct S0 l_397 = {-4L};
    struct S0 *l_398 = &l_323;
    (*l_287) = l_283;
    if ((l_288 = l_286))
    { /* block id: 206 */
        int32_t *l_290 = &l_288;
        int32_t **l_289 = &l_290;
        struct S1 l_305 = {0x0FE0D3B134FB932FLL,0x9E5AFB12AC07442CLL,18446744073709551615UL,{0x1903L}};
        struct S1 *l_304 = &l_305;
        int64_t *l_308 = &l_305.f0;
        int32_t *l_316 = (void*)0;
        int32_t l_318 = 0x8052E4B5L;
        int32_t *l_317 = &l_318;
        uint16_t **l_344 = &l_285;
        float l_349 = 0x3.98DA61p-87;
        float *l_348 = &l_349;
        float **l_347 = &l_348;
        (*l_289) = &l_288;
        for (l_288 = 0; (l_288 <= 27); l_288 = safe_add_func_uint32_t_u_u(l_288, 1))
        { /* block id: 210 */
            uint16_t *****l_293 = &l_287;
            (*l_293) = (void*)0;
            for (l_286 = (-12); (l_286 <= 15); l_286 = safe_add_func_int16_t_s_s(l_286, 4))
            { /* block id: 214 */
                int32_t *l_296 = (void*)0;
                int32_t l_298 = 0xB43A37B5L;
                int32_t *l_297 = &l_298;
                int32_t *l_299 = (void*)0;
                int32_t *l_300 = (void*)0;
                int32_t l_302 = 0x7D206A69L;
                int32_t *l_301 = &l_302;
                int32_t **l_303 = &l_296;
                float l_307 = 0x1.9p+1;
                float *l_306 = &l_307;
                (*l_301) = ((*l_297) = __builtin_popcountll((l_286 >= (&l_290 == (void*)0))));
                (*l_303) = ((*l_289) = &l_288);
                (*l_303) = (*l_303);
                (*l_306) = (__builtin_ctzll((**l_289)) == (l_304 == (void*)0));
            }
        }
        if ((((*l_308) = (65535UL || p_59)) > ((safe_mul_func_int16_t_s_s(p_59, ((safe_add_func_uint16_t_u_u(0x3C32L, (l_314 = (!(l_288 = (*l_290)))))) != (&l_290 != &l_290)))) | (p_59 | (((((*l_317) = l_315) >= l_286) >= p_59) >= l_315)))))
        { /* block id: 227 */
            uint16_t l_360 = 0x6F7AL;
            int32_t *l_362 = &l_314;
            struct S1 l_365 = {1L,0xED47F7B9D4476A29LL,18446744073709551615UL,{0x315BL}};
            int16_t *l_377 = &l_365.f3.f0;
            int16_t **l_376 = &l_377;
            int16_t ***l_375 = &l_376;
            struct S1 *l_388 = &l_365;
            for (l_318 = 0; (l_318 < 19); l_318++)
            { /* block id: 230 */
                for (l_286 = (-4); (l_286 <= 43); l_286++)
                { /* block id: 233 */
                    struct S0 *l_324 = &l_323;
                    int32_t **l_325 = (void*)0;
                    int32_t **l_326 = (void*)0;
                    int32_t **l_327 = (void*)0;
                    int32_t **l_328 = (void*)0;
                    int32_t **l_329 = &l_316;
                    (*l_324) = l_323;
                    (*l_329) = ((*l_289) = &l_314);
                    (*l_329) = &l_314;
                }
            }
            for (l_318 = 0; (l_318 >= (-15)); l_318 = safe_sub_func_int64_t_s_s(l_318, 1))
            { /* block id: 242 */
                int32_t **l_336 = &l_290;
                int32_t l_338 = 0x02868524L;
                int32_t *l_337 = &l_338;
                struct S1 l_345 = {0x7EB5314A3952FBA1LL,0UL,0x748AC1276B3610BELL,{0x485AL}};
                int32_t l_383 = 1L;
                struct S0 *l_385 = &l_305.f3;
                struct S0 **l_384 = &l_385;
                uint32_t l_389 = 0UL;
            }
        }
        else
        { /* block id: 278 */
            return p_59;
        }
    }
    else
    { /* block id: 281 */
        int16_t l_390 = 0L;
        (*l_357) = (**l_356);
        return l_390;
    }
    (*l_395) = (safe_sub_func_float_f_f(((l_394 = (l_393 = &l_378)) == &l_378), (p_59 < ((*l_351) = ((void*)0 == p_58)))));
    (*l_398) = l_397;
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 ** func_60(int16_t  p_61, struct S0 * p_62, int32_t  p_63)
{ /* block id: 140 */
    float l_200 = 0x8.FDB648p+17;
    int32_t l_201 = 8L;
    uint16_t l_215 = 2UL;
    uint16_t *l_214 = &l_215;
    int32_t l_220 = 1L;
    struct S1 l_264 = {0x558E0F9DADCB9365LL,0xCBFF38EDED3E824FLL,0xA8155E1EFB666E45LL,{0L}};
    struct S0 *l_278 = &l_264.f3;
    struct S0 **l_277 = &l_278;
    struct S0 **l_279 = &l_278;
    struct S0 **l_280 = &l_278;
    struct S0 **l_281 = &l_278;
    struct S0 **l_282 = (void*)0;
    for (p_61 = 0; (p_61 <= 17); p_61 = safe_add_func_int64_t_s_s(p_61, 9))
    { /* block id: 143 */
        float l_199 = 0xD.8F47D9p-74;
        int32_t l_218 = 0x958E107FL;
        int32_t l_233 = 0L;
        int32_t *l_232 = &l_233;
        int32_t *l_241 = &l_218;
        int32_t **l_240 = &l_241;
        int32_t ***l_239 = &l_240;
        struct S1 l_262 = {-9L,0x029CE55DAC31F8A2LL,0x8C1CB93B745A2F1ELL,{-9L}};
        struct S1 *l_261 = &l_262;
        if (l_201)
        { /* block id: 144 */
            struct S0 l_202 = {2L};
            struct S0 *l_203 = &l_202;
            uint16_t *l_216 = (void*)0;
            (*l_203) = l_202;
            for (p_63 = (-7); (p_63 >= 9); p_63++)
            { /* block id: 148 */
                int32_t **l_209 = (void*)0;
                int32_t ***l_208 = &l_209;
                int32_t ****l_207 = &l_208;
                int32_t *****l_206 = &l_207;
                int32_t ****l_211 = &l_208;
                int32_t *****l_210 = &l_211;
                int32_t ****l_213 = &l_208;
                int32_t *****l_212 = &l_213;
                uint16_t **l_217 = &l_216;
                int32_t *l_219 = &l_201;
                (*l_212) = ((*l_210) = ((*l_206) = (void*)0));
                l_220 = ((((*l_219) = ((l_214 != ((*l_217) = l_216)) && l_218)) == l_218) & l_202.f0);
            }
        }
        else
        { /* block id: 156 */
            uint32_t l_229 = 0UL;
            int32_t l_231 = 1L;
            int32_t *l_230 = &l_231;
            int32_t ***l_254 = (void*)0;
            struct S1 l_267 = {0x433CC30774E2FFC6LL,1UL,18446744073709551610UL,{-1L}};
            for (p_63 = 0; (p_63 > 11); p_63 = safe_add_func_int32_t_s_s(p_63, 6))
            { /* block id: 159 */
                int16_t l_236 = 0xA897L;
                int16_t *l_235 = &l_236;
                struct S0 l_237 = {-5L};
                int32_t ***l_253 = &l_240;
                if ((p_63 != ((*l_235) = (safe_rshift_func_int16_t_s_s((safe_mod_func_uint32_t_u_u(p_63, (p_61 && (safe_lshift_func_uint16_t_u_s(l_229, (l_230 == l_232)))))), (+l_231))))))
                { /* block id: 161 */
                    struct S0 *l_238 = &l_237;
                    int32_t l_246 = 1L;
                    (*l_238) = l_237;
                    (***l_239) = (l_239 == &l_240);
                    for (l_233 = 0; (l_233 <= 27); l_233 = safe_add_func_uint16_t_u_u(l_233, 4))
                    { /* block id: 166 */
                        float *l_247 = &l_199;
                        float **l_248 = &l_247;
                        (*l_241) = ((l_246 | ((((*l_248) = l_247) == (void*)0) <= p_63)) > l_236);
                    }
                }
                else
                { /* block id: 170 */
                    uint32_t l_260 = 8UL;
                    uint32_t *l_259 = &l_260;
                    for (l_218 = 8; (l_218 >= (-1)); l_218--)
                    { /* block id: 173 */
                        (*l_240) = l_230;
                    }
                    (*l_241) = ((0x02E4CAB5L | (((safe_sub_func_int64_t_s_s(p_63, p_63)) > (l_253 != l_254)) != (***l_253))) <= ((safe_add_func_uint32_t_u_u(((*l_259) = (safe_div_func_uint64_t_u_u((p_63 ^ l_215), (p_63 && l_201)))), 0xBF7B4E91L)) & (***l_239)));
                    (**l_240) = (*l_241);
                }
            }
            if ((func_82(p_63, (*l_239)) == p_61))
            { /* block id: 181 */
                int32_t *l_270 = &l_233;
                int32_t *l_271 = &l_233;
                int32_t l_274 = 0xFB48A0A5L;
                if ((0UL > 0xDB23535E1361682ELL))
                { /* block id: 182 */
                    struct S1 **l_263 = &l_261;
                    int32_t *l_265 = (void*)0;
                    struct S1 l_268 = {0xD1C8C2AAD6875EE9LL,0x912E25FB50D92D6BLL,0xA406F6B8A0B9BCC1LL,{0xF950L}};
                    (***l_239) = l_201;
                    (*l_263) = l_261;
                    if (p_63)
                    { /* block id: 185 */
                        int32_t **l_266 = &l_265;
                        (*l_261) = l_264;
                        (*l_266) = ((**l_239) = l_265);
                        (*l_266) = (*l_240);
                        l_265 = (void*)0;
                    }
                    else
                    { /* block id: 191 */
                        l_268 = l_267;
                    }
                }
                else
                { /* block id: 194 */
                    (**l_240) = ((((p_63 != (+(l_270 == l_271))) < (p_61 & __builtin_clzl((~(p_61 != (safe_unary_minus_func_int64_t_s(l_274))))))) == ((p_63 < 0xCF79L) > 0xFBA9A8C7L)) | 0xC24070B36999CFFFLL);
                }
            }
            else
            { /* block id: 197 */
                struct S0 *l_276 = &l_264.f3;
                struct S0 **l_275 = &l_276;
                (*l_275) = (void*)0;
            }
        }
    }
    return l_282;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_64(int32_t  p_65)
{ /* block id: 38 */
    uint32_t l_66 = 0x68F57F54L;
    float l_68 = 0x1.2BFEEDp-14;
    float *l_67 = &l_68;
    int32_t l_70 = (-1L);
    int32_t *l_69 = &l_70;
    int32_t *l_71 = &l_70;
    int32_t **l_72 = &l_69;
    struct S0 **l_79 = (void*)0;
    struct S0 l_105 = {4L};
    struct S0 *l_104 = &l_105;
    struct S0 *l_107 = &l_105;
    struct S0 *l_111 = &l_105;
    int32_t l_122 = 0xE5B6057BL;
    uint16_t l_129 = 0UL;
    struct S0 *l_160 = &l_105;
    struct S0 *l_190 = &l_105;
    struct S0 *l_191 = (void*)0;
    (*l_67) = l_66;
    (*l_69) = l_66;
    l_69 = &p_65;
    if ((((*l_72) = (l_71 = &p_65)) != &p_65))
    { /* block id: 44 */
        struct S0 l_78 = {-7L};
        struct S0 *l_88 = &l_78;
        struct S0 **l_87 = &l_88;
        int16_t l_92 = 0x5F81L;
        int16_t *l_91 = &l_92;
        int16_t l_94 = (-6L);
        int16_t *l_93 = &l_94;
        int32_t **l_95 = &l_71;
        (**l_87) = func_73(l_78, l_79, ((*l_93) = (safe_mod_func_uint32_t_u_u((p_65 < (*l_69)), func_82((((__builtin_ctzll(p_65) >= ((safe_mul_func_int16_t_s_s(((l_79 == l_87) || ((*l_93) = ((*l_91) = __builtin_bswap64((((safe_add_func_uint16_t_u_u((p_65 & 0L), 0xBECCL)) <= 65534UL) > 1L))))), (*l_69))) && l_94)) & (*l_69)) != 0x45104F36L), l_95)))), (**l_95));
    }
    else
    { /* block id: 54 */
        int64_t l_103 = 3L;
        struct S0 *l_106 = &l_105;
        struct S0 *l_109 = &l_105;
        struct S0 *l_110 = &l_105;
        struct S0 *l_112 = (void*)0;
        float *l_130 = &l_68;
        int32_t **l_141 = &l_71;
        int32_t *l_187 = &l_70;
        struct S0 **l_188 = &l_104;
        struct S0 *l_189 = &l_105;
        for (l_66 = 0; (l_66 > 51); l_66 = safe_add_func_int32_t_s_s(l_66, 4))
        { /* block id: 57 */
            float l_102 = 0x1.8p+1;
            struct S0 *l_108 = &l_105;
            (*l_67) = (safe_sub_func_float_f_f((l_102 > (l_103 = 0x8.8438CFp-7)), 0x5.Ep-1));
            return l_112;
        }
        if ((&l_69 != &l_69))
        { /* block id: 62 */
            int32_t *l_131 = (void*)0;
            struct S0 *l_135 = &l_105;
            struct S1 l_147 = {-1L,0x609845791C840D7ALL,1UL,{-1L}};
            for (p_65 = 0; (p_65 != 13); p_65++)
            { /* block id: 65 */
                int16_t **l_117 = (void*)0;
                int32_t l_120 = 5L;
                struct S0 **l_125 = &l_106;
                int32_t ***l_142 = &l_141;
                uint16_t *l_143 = (void*)0;
                uint16_t *l_144 = &l_129;
                for (l_66 = 0; (l_66 >= 26); l_66 = safe_add_func_uint32_t_u_u(l_66, 1))
                { /* block id: 68 */
                    int16_t ***l_118 = &l_117;
                    int32_t l_119 = 0xC62902D2L;
                    (*l_118) = l_117;
                }
                for (l_66 = 0; (l_66 == 35); l_66 = safe_add_func_int16_t_s_s(l_66, 2))
                { /* block id: 85 */
                    int32_t *l_134 = &l_122;
                    if ((*l_71))
                        break;
                    (*l_134) = (__builtin_parity(p_65) != (-3L));
                    return l_112;
                }
                l_120 = (safe_div_func_int16_t_s_s((0L | (l_103 != (~0L))), ((*l_144) = (safe_sub_func_uint32_t_u_u((0x1657L != (((*l_142) = l_141) == &l_69)), (((*l_72) = l_131) != l_130))))));
                for (l_105.f0 = (-28); (l_105.f0 != 8); l_105.f0 = safe_add_func_uint16_t_u_u(l_105.f0, 6))
                { /* block id: 96 */
                    struct S1 *l_148 = &l_147;
                    struct S0 *l_149 = &l_147.f3;
                    (*l_148) = l_147;
                    if (p_65)
                        continue;
                    return l_112;
                }
            }
        }
        else
        { /* block id: 102 */
            int32_t ***l_150 = (void*)0;
            int32_t **l_163 = &l_71;
            struct S0 *l_182 = &l_105;
            if ((l_150 != (void*)0))
            { /* block id: 103 */
                int32_t l_158 = 0xBE4CD0C3L;
                struct S0 *l_159 = (void*)0;
                int32_t l_164 = 0xDF0E7D16L;
                int16_t l_181 = (-4L);
                p_65 = p_65;
                for (l_70 = 0; (l_70 != (-10)); l_70 = safe_sub_func_uint64_t_u_u(l_70, 1))
                { /* block id: 107 */
                    int32_t *l_153 = &l_122;
                    int16_t *l_165 = (void*)0;
                    int16_t *l_166 = &l_105.f0;
                    int32_t **l_167 = &l_69;
                    l_153 = (void*)0;
                    if (((safe_mul_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u(p_65, l_158)) && p_65), ((*l_166) = (((l_160 = l_159) != l_159) ^ (l_164 = ((safe_mul_func_uint16_t_u_u(func_82(l_158, l_163), (**l_141))) == p_65)))))) | p_65))
                    { /* block id: 112 */
                        int16_t **l_173 = &l_166;
                        int16_t ***l_172 = &l_173;
                        uint32_t l_175 = 1UL;
                        uint32_t *l_174 = &l_175;
                        uint32_t l_177 = 0UL;
                        uint32_t *l_176 = &l_177;
                        uint16_t *l_180 = &l_129;
                        l_167 = &l_153;
                        (**l_72) = (safe_mul_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(((l_164 = (((**l_141) & (-1L)) <= ((((safe_rshift_func_uint16_t_u_s(((*l_180) = ((((**l_173) = l_164) || ((0xFAD0BDB4F01B87C5LL & 0x7CE49567760C7165LL) != l_164)) <= l_164)), 12)) & l_175) || l_181) | (-7L)))) & 1UL), 65531UL)), (**l_141)));
                    }
                    else
                    { /* block id: 120 */
                        (**l_72) = 0xA1FB0DB9L;
                        return l_159;
                    }
                }
            }
            else
            { /* block id: 125 */
                struct S0 *l_186 = &l_105;
                for (l_66 = 0; (l_66 > 51); l_66 = safe_add_func_int32_t_s_s(l_66, 1))
                { /* block id: 128 */
                    struct S0 *l_185 = &l_105;
                    return l_112;
                }
                (*l_141) = (void*)0;
            }
            (*l_141) = l_187;
        }
        (*l_106) = func_73((*l_106), &l_107, (*l_187), __builtin_parity(((((*l_188) = l_106) != l_189) | (((*l_187) > (**l_141)) > p_65))));
    }
    return l_191;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_73(struct S0  p_74, struct S0 ** p_75, int16_t  p_76, int16_t  p_77)
{ /* block id: 51 */
    struct S0 l_97 = {0x6B3FL};
    return l_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_82(uint32_t  p_83, int32_t ** p_84)
{ /* block id: 47 */
    struct S1 l_96 = {0xE6E1851AA8C97D73LL,0xF31A33FFEA361F88LL,0xD77871239B759721LL,{-1L}};
    l_96 = l_96;
    return (**p_84);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 137
   depth: 1, occurrence: 6
   depth: 2, occurrence: 11
XXX total union variables: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 125
   depth: 2, occurrence: 30
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 11, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 25, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 188

XXX times a variable address is taken: 170
XXX times a pointer is dereferenced on RHS: 41
breakdown:
   depth: 1, occurrence: 22
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 101
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 10
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 253

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 161
   level: 2, occurrence: 53
   level: 3, occurrence: 10
   level: 4, occurrence: 0
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 77
XXX number of pointers point to scalars: 67
XXX number of pointers point to structs: 44
XXX percent of pointers has null in alias set: 28.7
XXX average alias set size: 1.14

XXX times a non-volatile is read: 434
XXX times a non-volatile is write: 276
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 16
   depth: 2, occurrence: 17
   depth: 3, occurrence: 20
   depth: 4, occurrence: 24
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 23.6
XXX percentage an existing variable is used: 76.4
********************* end of statistics **********************/

