/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-comma-operators --no-argc --no-bitfields --no-arrays --pointers --structs --unions --no-packed-struct --no-divs --no-muls --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --longlong --no-float --jumps --no-volatiles --no-compound-assignment --consts --inline-function --no-volatile-pointers --no-const-pointers --builtins --no-int8 --uint8
 * Seed:      3349908906
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint64_t  f0;
   int16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   int16_t  f4;
   uint32_t  f5;
   const uint64_t  f6;
   int64_t  f7;
};

/* --- GLOBAL VARIABLES --- */
static int64_t g_3 = 0x8A59C17633EFC07ELL;
static int32_t g_46 = 0xCF162C80L;
static uint16_t g_66 = 65529UL;
static int32_t g_70 = 0x7039802EL;
static struct S0 g_80 = {0x2F470B9C45D18828LL,0x9701L,4294967295UL,0x394210ABL,0xCA24L,4294967293UL,1UL,-5L};
static int32_t ***g_85 = (void*)0;
static struct S0 g_89 = {1UL,-8L,0x4720237AL,-1L,-6L,4294967291UL,1UL,0x75CAB9BE056EFF52LL};
static uint16_t g_91 = 0UL;
static uint16_t *g_90 = &g_91;
static struct S0 *g_125 = (void*)0;
static struct S0 **g_124 = &g_125;
static int32_t *g_129 = &g_70;
static int32_t ****g_140 = (void*)0;
static int32_t *****g_139 = &g_140;
static int16_t g_179 = (-6L);
static uint16_t g_188 = 0xD8D2L;
static int64_t *g_192 = &g_89.f7;
static int64_t **g_191 = &g_192;
static uint32_t g_231 = 0xDC9C167BL;
static uint16_t **g_254 = (void*)0;
static uint16_t ***g_253 = &g_254;
static const int32_t g_285 = 0xA4237FCBL;
static const int32_t *g_291 = &g_70;
static uint64_t g_331 = 1UL;
static struct S0 ***g_338 = &g_124;
static struct S0 ****g_337 = &g_338;
static const int32_t **g_406 = &g_291;
static const int32_t ***g_405 = &g_406;
static int32_t *g_410 = &g_80.f3;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_27(void);
static const int32_t  func_28(struct S0  p_29, uint16_t  p_30, uint32_t  p_31, int32_t  p_32);
static struct S0  func_33(int32_t  p_34, uint32_t  p_35, int64_t  p_36, struct S0  p_37, int32_t  p_38);
inline static uint32_t  func_39(const uint32_t  p_40, uint16_t  p_41);
static uint32_t  func_47(int32_t * p_48, int32_t  p_49, int32_t * p_50, const uint16_t  p_51);
inline static int32_t * func_52(int32_t * p_53, int32_t * p_54);
static int32_t * func_55(int32_t * p_56, const int32_t * p_57, int32_t  p_58);
inline static int32_t * func_59(int16_t  p_60, int32_t * p_61, uint32_t  p_62, int64_t  p_63);
static int16_t  func_64(int64_t  p_65);
inline static uint16_t  func_74(struct S0  p_75, int32_t * p_76, struct S0  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_66 g_80 g_85 g_90 g_89.f0 g_89.f3 g_89.f6 g_91 g_70 g_124 g_125 g_139 g_89.f1 g_89.f5 g_179 g_191 g_192 g_291 g_46 g_331 g_405 g_89.f7 g_410 g_406
 * writes: g_3 g_46 g_70 g_66 g_80.f3 g_85 g_80.f5 g_80.f2 g_89.f3 g_124 g_129 g_125 g_89.f1 g_80.f7 g_91 g_89.f4 g_188 g_89.f7 g_80.f0 g_253 g_291 g_405 g_231 g_80.f4 g_410
 */
static int32_t  func_27(void)
{ /* block id: 36 */
    int32_t l_42 = 0xE45DB0FFL;
    int32_t *l_45 = &g_46;
    uint64_t l_166 = 0x040C694B4B0C768CLL;
    const uint64_t l_167 = 0x1D07C0FF9DDB2936LL;
    struct S0 l_178 = {0xB4ECD82EB3127663LL,0xCE8CL,1UL,1L,0x9B38L,4294967295UL,1UL,0x0058932948FFD3BALL};
    int32_t l_206 = 0x326B5A98L;
    uint16_t l_408 = 0x8705L;
lbl_379:
    (*l_45) = func_28(func_33(((*l_45) = __builtin_ia32_crc32qi((func_39(g_3, l_42) != l_42), l_42)), func_47(func_52(func_55(func_59(func_64(g_66), l_45, g_89.f6, g_89.f5), l_45, g_89.f0), l_45), l_166, l_45, l_167), g_80.f1, l_178, g_179), l_206, g_89.f6, l_178.f6);
    if ((*l_45))
    { /* block id: 386 */
        int32_t l_377 = 1L;
        uint8_t l_400 = 0x55L;
        int32_t l_412 = 0x55851CC5L;
        int32_t *l_413 = &g_89.f3;
        if ((+g_91))
        { /* block id: 387 */
            uint32_t l_378 = 0x83237871L;
            (*l_45) = (safe_sub_func_uint64_t_u_u((safe_lshift_func_int16_t_s_s(l_377, 13)), g_89.f0));
            (*l_45) = ((l_377 >= (*g_291)) || l_378);
            if (l_378)
                goto lbl_379;
            (*l_45) = ((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(g_46, (*g_291))), 14)) || (safe_mod_func_int64_t_s_s(l_377, (safe_rshift_func_uint16_t_u_u(((*g_90) = (l_377 | l_377)), 12)))));
        }
        else
        { /* block id: 393 */
            uint64_t l_392 = 18446744073709551615UL;
            int32_t **l_404 = &g_129;
            int32_t ***l_403 = &l_404;
            for (l_377 = 0; (l_377 == (-4)); l_377--)
            { /* block id: 396 */
                uint8_t l_399 = 0xC0L;
                const int32_t ****l_407 = &g_405;
                uint32_t *l_409 = &g_231;
                for (g_89.f3 = (-10); (g_89.f3 >= 17); g_89.f3++)
                { /* block id: 399 */
                    const int32_t *l_395 = &g_70;
                    if (l_392)
                    { /* block id: 400 */
                        uint16_t ****l_393 = &g_253;
                        int32_t l_394 = 0x7E666062L;
                        const int32_t **l_396 = &g_291;
                        if ((*g_291))
                            break;
                        (*l_393) = &g_254;
                        if (l_394)
                            break;
                        (*l_396) = l_395;
                    }
                    else
                    { /* block id: 405 */
                        return g_80.f2;
                    }
                    if (l_377)
                        continue;
                }
                if ((g_80.f1 ^ func_39(((*l_409) = ((__builtin_popcountl(g_331) == l_392) | (((safe_rshift_func_uint16_t_u_s((((l_399 >= ((l_400 & 4UL) == __builtin_ctz((safe_lshift_func_int16_t_s_u(((l_403 != ((*l_407) = g_405)) | (*g_192)), 15))))) > 0x0C50B6E6383F7E49LL) ^ g_89.f7), 14)) && l_408) != (*l_45)))), (*l_45))))
                { /* block id: 412 */
                    uint32_t l_411 = 0x6A5420B6L;
                    (*l_404) = g_410;
                    return l_411;
                }
                else
                { /* block id: 415 */
                    l_412 = (*g_410);
                    return (*l_45);
                }
            }
            l_413 = l_45;
        }
        l_413 = l_45;
        (*l_413) = (*l_413);
    }
    else
    { /* block id: 424 */
        const int32_t *l_414 = (void*)0;
        l_414 = (*g_406);
        for (l_42 = (-15); (l_42 <= (-18)); l_42--)
        { /* block id: 428 */
            return g_179;
        }
    }
    for (g_80.f4 = 3; (g_80.f4 < (-26)); g_80.f4 = safe_sub_func_uint64_t_u_u(g_80.f4, 5))
    { /* block id: 434 */
        int64_t l_428 = 6L;
        for (l_206 = 0; (l_206 < (-22)); l_206--)
        { /* block id: 437 */
            uint32_t l_421 = 7UL;
            if (l_421)
            { /* block id: 438 */
                return g_179;
            }
            else
            { /* block id: 440 */
                uint8_t l_422 = 0UL;
                return l_422;
            }
        }
        for (g_80.f0 = 12; (g_80.f0 == 57); g_80.f0 = safe_add_func_uint64_t_u_u(g_80.f0, 9))
        { /* block id: 446 */
            struct S0 l_425 = {18446744073709551615UL,0x116BL,0x00AB5CC9L,0x25971B6AL,0xE92CL,0xF0828740L,0x8EA8668655AB4E19LL,0xCD54B43B3CD1F539LL};
            struct S0 l_426 = {9UL,0xA466L,1UL,0x852DD881L,0x32B3L,1UL,1UL,0x0546763C7AD4AB23LL};
            int32_t **l_427 = &g_410;
            const uint32_t *l_433 = &g_231;
            (*l_45) = func_74(l_425, &g_70, l_426);
            (*g_406) = ((*l_427) = &g_46);
            (**l_427) = (l_428 = ((*l_45) > 0xD836L));
            for (l_425.f0 = (-16); (l_425.f0 > 35); l_425.f0 = safe_add_func_int32_t_s_s(l_425.f0, 4))
            { /* block id: 454 */
                uint32_t *l_432 = &g_231;
                uint32_t **l_431 = &l_432;
                int32_t l_434 = 4L;
                l_434 = ((((*l_431) = &g_231) != l_433) || (func_64((**l_427)) == (**l_427)));
            }
        }
    }
    return (*l_45);
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_291 g_70
 * writes: g_46
 */
static const int32_t  func_28(struct S0  p_29, uint16_t  p_30, uint32_t  p_31, int32_t  p_32)
{ /* block id: 209 */
    int32_t *l_212 = &g_89.f3;
    int32_t **l_259 = &l_212;
    int32_t ***l_258 = &l_259;
    uint16_t l_286 = 65532UL;
    int32_t *l_347 = &g_80.f3;
    int32_t l_349 = (-6L);
    int64_t **l_357 = (void*)0;
    for (g_46 = 0; (g_46 <= 14); g_46 = safe_add_func_uint16_t_u_u(g_46, 2))
    { /* block id: 212 */
        int32_t *****l_219 = &g_140;
        uint16_t **l_245 = &g_90;
        struct S0 l_261 = {0x1A16B741F67890D7LL,-8L,4294967293UL,0x4172F5B4L,0xCB99L,0xFCC591C3L,18446744073709551612UL,0x6B89E33894EB692CLL};
        int32_t *l_277 = &g_46;
        int64_t **l_297 = &g_192;
        uint32_t l_316 = 0x0A48598CL;
        struct S0 l_318 = {0x4FDA778AEBD939EDLL,0xBC62L,0xD0DC95D9L,0xC584207BL,0L,5UL,0xF22320127E57FD0BLL,-1L};
    }
    return (*g_291);
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_90 g_80.f3 g_191 g_91 g_192 g_3
 * writes: g_70 g_91 g_66 g_188 g_89.f7 g_3 g_80.f0 g_80.f2 g_46
 */
static struct S0  func_33(int32_t  p_34, uint32_t  p_35, int64_t  p_36, struct S0  p_37, int32_t  p_38)
{ /* block id: 193 */
    int32_t l_203 = 7L;
    for (g_70 = (-14); (g_70 >= (-15)); --g_70)
    { /* block id: 196 */
        int32_t *l_182 = &g_46;
        uint16_t *l_186 = &g_66;
        uint16_t *l_187 = &g_188;
        int64_t **l_193 = &g_192;
        int64_t **l_194 = &g_192;
        uint64_t *l_201 = (void*)0;
        uint64_t *l_202 = &g_80.f0;
        int32_t *l_204 = (void*)0;
        int32_t *l_205 = &g_46;
        l_182 = &p_34;
        (*l_205) = (safe_unary_minus_func_uint32_t_u((g_80.f2 = ((safe_add_func_uint16_t_u_u(((*l_187) = ((*l_186) = ((*g_90) = 0x00CDL))), g_80.f3)) && ((-1L) >= (safe_add_func_uint16_t_u_u(((l_193 = g_191) == l_194), ((((+(((**g_191) = (safe_mod_func_uint16_t_u_u(p_37.f3, (*g_90)))) != ((((*l_182) = (safe_sub_func_uint16_t_u_u((((*l_202) = func_39((+((*l_182) < p_37.f2)), (*g_90))) < l_203), 1L))) > l_203) | l_203))) | p_38) < p_37.f2) < 4294967287UL))))))));
    }
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_3
 */
inline static uint32_t  func_39(const uint32_t  p_40, uint16_t  p_41)
{ /* block id: 37 */
    for (g_3 = 0; (g_3 > 26); g_3 = safe_add_func_uint64_t_u_u(g_3, 1))
    { /* block id: 40 */
        return g_3;
    }
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_124
 * writes: g_91 g_125
 */
static uint32_t  func_47(int32_t * p_48, int32_t  p_49, int32_t * p_50, const uint16_t  p_51)
{ /* block id: 181 */
    int32_t *l_168 = (void*)0;
    int32_t **l_169 = &l_168;
    struct S0 *l_172 = (void*)0;
    p_50 = l_168;
    (*l_169) = l_168;
    for (g_91 = (-13); (g_91 == 30); g_91 = safe_add_func_int16_t_s_s(g_91, 1))
    { /* block id: 186 */
        struct S0 **l_173 = &l_172;
        struct S0 *l_175 = &g_80;
        struct S0 **l_174 = &l_175;
        struct S0 *l_177 = &g_80;
        struct S0 **l_176 = &l_177;
        (*l_176) = ((*l_174) = ((*l_173) = ((*g_124) = l_172)));
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads : g_89.f3 g_70
 * writes:
 */
inline static int32_t * func_52(int32_t * p_53, int32_t * p_54)
{ /* block id: 172 */
    int32_t l_163 = 0x5FBAF3FAL;
    int32_t *l_164 = &g_89.f3;
    if ((1UL && l_163))
    { /* block id: 173 */
        return p_54;
    }
    else
    { /* block id: 175 */
        int32_t l_165 = 0x8C699ED9L;
        p_54 = (l_164 = p_54);
        l_165 = (*p_53);
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_80.f0 g_85 g_90 g_70 g_89.f3 g_80.f2
 * writes: g_80.f3 g_85 g_89.f3 g_80.f7 g_80.f5 g_70 g_80.f2
 */
static int32_t * func_55(int32_t * p_56, const int32_t * p_57, int32_t  p_58)
{ /* block id: 152 */
    struct S0 l_151 = {0xEB2DE199855EAA69LL,0x5101L,9UL,0xB434E9FAL,0x9CDCL,0xEB25118CL,0x2C6A0115AE511602LL,0L};
    int32_t *l_152 = &g_89.f3;
    int32_t *l_162 = &l_151.f3;
    if ((g_91 | func_74(l_151, l_152, l_151)))
    { /* block id: 153 */
        int64_t *l_153 = &g_80.f7;
        (*l_152) = (&g_90 != (void*)0);
        (*l_152) = (*p_56);
        (*p_56) = __builtin_ffsl((((*l_152) | ((*l_153) = ((g_70 >= p_58) & (*p_56)))) >= (g_80.f5 = 0xBFE599A2L)));
        (*p_56) = (p_58 < 0UL);
    }
    else
    { /* block id: 160 */
        return l_152;
    }
    (*l_152) = (safe_lshift_func_int16_t_s_u(g_80.f2, 2));
    (*p_56) = (*p_56);
    for (g_80.f2 = 0; (g_80.f2 == 5); g_80.f2 = safe_add_func_uint32_t_u_u(g_80.f2, 9))
    { /* block id: 167 */
        int64_t ***l_158 = (void*)0;
        int64_t ***l_159 = (void*)0;
        int64_t **l_161 = (void*)0;
        int64_t ***l_160 = &l_161;
        (*l_160) = (void*)0;
        p_57 = p_56;
    }
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_70
 */
inline static int32_t * func_59(int16_t  p_60, int32_t * p_61, uint32_t  p_62, int64_t  p_63)
{ /* block id: 149 */
    int32_t *l_150 = &g_70;
    (*l_150) = p_62;
    return l_150;
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_80 g_85 g_90 g_70 g_89.f0 g_89.f3 g_89.f6 g_91 g_124 g_125 g_89.f1 g_139
 * writes: g_70 g_66 g_80.f3 g_85 g_80.f5 g_80.f2 g_89.f3 g_124 g_129 g_125 g_89.f1 g_80.f7 g_91 g_89.f4
 */
static int16_t  func_64(int64_t  p_65)
{ /* block id: 45 */
    uint32_t l_67 = 0UL;
    uint64_t l_68 = 0xF5EB7F464F6128B2LL;
    int32_t *l_69 = &g_70;
    uint16_t *l_71 = &g_66;
    struct S0 l_78 = {0x3D476FC58AC37448LL,0xA863L,0x74C89AEDL,0x93E35F20L,-1L,0x5DCFD1F9L,18446744073709551611UL,5L};
    int32_t **l_79 = &l_69;
    uint8_t l_93 = 0x54L;
    (*l_69) = (l_67 | (((g_66 <= 0L) < l_68) && g_66));
    if ((((*l_71) = (&g_70 != (void*)0)) ^ (((safe_rshift_func_uint16_t_u_s(func_74(l_78, ((*l_79) = l_69), g_80), 10)) >= l_78.f7) > ((p_65 == 6UL) >= g_80.f1))))
    { /* block id: 60 */
        int32_t **l_95 = &l_69;
        int32_t *l_97 = &g_80.f3;
        int32_t l_108 = 0L;
        struct S0 l_111 = {18446744073709551615UL,0x21ACL,0UL,0x69EA8502L,0x0630L,4294967295UL,0xB10B9BD427A37A7FLL,0xAE90203C69C835A8LL};
        if (__builtin_clzll(l_93))
        { /* block id: 61 */
            int32_t *l_94 = &g_80.f3;
            int32_t ***l_96 = &l_79;
            l_94 = &g_70;
            (*l_96) = l_95;
            (*l_79) = (*l_79);
            l_97 = ((*l_79) = (void*)0);
        }
        else
        { /* block id: 67 */
            int64_t l_107 = 0x6500C2479274D830LL;
            for (g_80.f5 = 0; (g_80.f5 < 51); g_80.f5++)
            { /* block id: 70 */
                (*l_97) = (*l_97);
            }
            for (g_80.f2 = 0; (g_80.f2 >= 14); g_80.f2 = safe_add_func_uint32_t_u_u(g_80.f2, 1))
            { /* block id: 75 */
                const int32_t *l_104 = &g_70;
                for (g_70 = 0; (g_70 == (-11)); g_70--)
                { /* block id: 78 */
                    const int32_t **l_105 = (void*)0;
                    const int32_t **l_106 = &l_104;
                    (*l_106) = l_104;
                    if (p_65)
                        continue;
                    if (l_107)
                        break;
                }
            }
            (*l_95) = &g_70;
        }
        l_108 = p_65;
        for (l_67 = 22; (l_67 <= 37); l_67++)
        { /* block id: 89 */
            (*l_79) = (*l_79);
            if ((g_89.f0 >= g_89.f3))
            { /* block id: 91 */
                int16_t l_114 = (-1L);
                if (((((safe_add_func_uint16_t_u_u(((l_114 > (&l_97 != (void*)0)) | (p_65 < ((safe_mod_func_uint64_t_u_u(((safe_rshift_func_int16_t_s_s(g_89.f3, (((9L ^ g_89.f6) > p_65) | p_65))) == 0x3859L), 5UL)) && (*g_90)))), g_70)) > 0x70AB71361DE361C4LL) > l_114) != g_80.f2))
                { /* block id: 92 */
                    (*l_79) = (*l_95);
                }
                else
                { /* block id: 94 */
                    int32_t *l_119 = &g_70;
                    (*l_119) = 0xC05FCAF6L;
                    for (l_111.f7 = (-27); (l_111.f7 >= (-14)); l_111.f7++)
                    { /* block id: 98 */
                        return p_65;
                    }
                    (*l_119) = (p_65 >= (*l_119));
                    return l_114;
                }
            }
            else
            { /* block id: 104 */
                int32_t *l_132 = (void*)0;
                int32_t *l_135 = (void*)0;
                int32_t *l_136 = &g_80.f3;
                for (g_89.f3 = 0; (g_89.f3 != (-20)); g_89.f3 = safe_sub_func_uint16_t_u_u(g_89.f3, 2))
                { /* block id: 107 */
                    struct S0 ***l_126 = &g_124;
                    int32_t l_127 = (-1L);
                    (*l_126) = g_124;
                    if (p_65)
                    { /* block id: 109 */
                        l_127 = p_65;
                    }
                    else
                    { /* block id: 111 */
                        int32_t ****l_128 = &g_85;
                        (*l_128) = (void*)0;
                        g_129 = ((*l_95) = (*l_79));
                        if (p_65)
                            break;
                        (**l_126) = (**l_126);
                    }
                    for (g_89.f1 = 4; (g_89.f1 <= 18); g_89.f1 = safe_add_func_int16_t_s_s(g_89.f1, 5))
                    { /* block id: 120 */
                        (*l_79) = &l_127;
                    }
                    return g_80.f5;
                }
                (*l_95) = l_132;
                (*l_136) = (safe_rshift_func_uint16_t_u_s(1UL, 3));
            }
            (*l_79) = &g_70;
        }
        for (g_80.f7 = 7; (g_80.f7 == 9); g_80.f7++)
        { /* block id: 132 */
            int32_t *****l_141 = &g_140;
            (*l_95) = (void*)0;
            l_141 = g_139;
        }
    }
    else
    { /* block id: 136 */
        uint16_t l_142 = 1UL;
        uint16_t l_143 = 9UL;
        int16_t *l_144 = (void*)0;
        int16_t *l_145 = &g_89.f4;
        uint16_t **l_147 = &g_90;
        uint16_t ***l_146 = &l_147;
        uint16_t **l_149 = &l_71;
        uint16_t ***l_148 = &l_149;
        (*l_79) = (*l_79);
        if (((__builtin_ffs(l_142) || (0x86F5F88D2697764DLL <= (l_143 != (*l_69)))) & ((g_89.f1 == (p_65 == ((*l_145) = (p_65 <= ((*g_90) = p_65))))) ^ 1UL)))
        { /* block id: 140 */
            (*l_79) = (*l_79);
        }
        else
        { /* block id: 142 */
            return p_65;
        }
        (*l_148) = ((*l_146) = &g_90);
    }
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads : g_80.f3 g_80.f0 g_85 g_90
 * writes: g_80.f3 g_85 g_70 g_89.f3
 */
inline static uint16_t  func_74(struct S0  p_75, int32_t * p_76, struct S0  p_77)
{ /* block id: 49 */
    struct S0 *l_88 = &g_89;
    uint16_t *l_92 = &g_91;
    for (g_80.f3 = 0; (g_80.f3 >= 10); g_80.f3 = safe_add_func_int16_t_s_s(g_80.f3, 1))
    { /* block id: 52 */
        int32_t *l_84 = &g_70;
        int32_t **l_83 = &l_84;
        int32_t ****l_86 = (void*)0;
        int32_t ****l_87 = &g_85;
        if (g_80.f0)
            break;
        (*l_83) = &g_70;
        (*l_87) = g_85;
        l_88 = &p_75;
    }
    (*p_76) = (g_90 != l_92);
    return p_75.f4;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_46, "g_46", print_hash_value);
    transparent_crc(g_66, "g_66", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc(g_80.f0, "g_80.f0", print_hash_value);
    transparent_crc(g_80.f1, "g_80.f1", print_hash_value);
    transparent_crc(g_80.f2, "g_80.f2", print_hash_value);
    transparent_crc(g_80.f3, "g_80.f3", print_hash_value);
    transparent_crc(g_80.f4, "g_80.f4", print_hash_value);
    transparent_crc(g_80.f5, "g_80.f5", print_hash_value);
    transparent_crc(g_80.f6, "g_80.f6", print_hash_value);
    transparent_crc(g_80.f7, "g_80.f7", print_hash_value);
    transparent_crc(g_89.f0, "g_89.f0", print_hash_value);
    transparent_crc(g_89.f1, "g_89.f1", print_hash_value);
    transparent_crc(g_89.f2, "g_89.f2", print_hash_value);
    transparent_crc(g_89.f3, "g_89.f3", print_hash_value);
    transparent_crc(g_89.f4, "g_89.f4", print_hash_value);
    transparent_crc(g_89.f5, "g_89.f5", print_hash_value);
    transparent_crc(g_89.f6, "g_89.f6", print_hash_value);
    transparent_crc(g_89.f7, "g_89.f7", print_hash_value);
    transparent_crc(g_91, "g_91", print_hash_value);
    transparent_crc(g_179, "g_179", print_hash_value);
    transparent_crc(g_188, "g_188", print_hash_value);
    transparent_crc(g_231, "g_231", print_hash_value);
    transparent_crc(g_285, "g_285", print_hash_value);
    transparent_crc(g_331, "g_331", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 111
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 35
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 21, occurrence: 1
   depth: 26, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 149

XXX times a variable address is taken: 139
XXX times a pointer is dereferenced on RHS: 74
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 130
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 606

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 508
   level: 2, occurrence: 64
   level: 3, occurrence: 21
   level: 4, occurrence: 50
   level: 5, occurrence: 38
XXX number of pointers point to pointers: 64
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 6
XXX percent of pointers has null in alias set: 21.5
XXX average alias set size: 1.34

XXX times a non-volatile is read: 483
XXX times a non-volatile is write: 359
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 128
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 32
   depth: 2, occurrence: 26
   depth: 3, occurrence: 11
   depth: 4, occurrence: 18
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 20.4
XXX percentage an existing variable is used: 79.6
********************* end of statistics **********************/

