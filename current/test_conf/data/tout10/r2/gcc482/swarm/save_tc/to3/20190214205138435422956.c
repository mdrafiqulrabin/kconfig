/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-comma-operators --no-argc --no-bitfields --no-arrays --no-pointers --structs --no-unions --packed-struct --no-divs --muls --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-longlong --float --jumps --no-volatiles --no-compound-assignment --consts --no-inline-function --volatile-pointers --const-pointers --no-global-variables --builtins --int8 --no-uint8
 * Seed:      1048101236
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   int32_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_35(void);
static uint16_t  func_43(uint32_t  p_44, struct S0  p_45, struct S0  p_46, uint32_t  p_47);
static uint32_t  func_60(const int8_t  p_61, struct S0  p_62);
static int32_t  func_69(struct S0  p_70, struct S0  p_71, uint32_t  p_72);
static struct S0  func_75(int32_t  p_76);
static int32_t  func_79(int32_t  p_80, struct S0  p_81);
static uint16_t  func_105(int32_t  p_106, float  p_107, uint32_t  p_108, int16_t  p_109, uint32_t  p_110);
static float  func_129(const int16_t  p_130, float  p_131);
static const float  func_135(int32_t  p_136, struct S0  p_137, const int32_t  p_138, const uint32_t  p_139, int16_t  p_140);
static struct S0  func_141(uint32_t  p_142);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(void)
{ /* block id: 36 */
    int32_t l_36 = (-3);
    float l_39 = (-0x7.1p+1);
    int32_t l_40 = (-1);
    int32_t l_54 = 0x0040B319;
    int32_t l_57 = 8;
    struct S0 l_58 = {0U,4294967293U,0x5C8A2DB6};
    struct S0 l_59 = {1U,4294967291U,0x60546153};
    int16_t l_219 = 0x91CA;
    uint16_t l_240 = 0U;
    for (l_36 = 0; (l_36 == 29); l_36 = safe_add_func_uint16_t_u_u(l_36, 1))
    { /* block id: 39 */
        l_40 = 0x1912530A;
    }
    if (__builtin_ffsl(((l_36 > (safe_mod_func_int16_t_s_s((l_40 = l_40), l_36))) < (l_59.f2 = (((l_58.f2 = func_43(((0xFA8F || (((l_57 = (l_36 && (safe_sub_func_int32_t_s_s((safe_mul_func_int16_t_s_s(((l_54 = (safe_mul_func_int16_t_s_s((-6), l_36))) && l_36), (safe_sub_func_int32_t_s_s(((((0x8991 ^ l_36) & l_36) == l_36) == 0x40BF68D2), l_36)))), 1)))) ^ l_36) < 0xEEDF)) | 5), l_58, l_59, l_59.f0)) != l_59.f0) || l_58.f1)))))
    { /* block id: 68 */
        int16_t l_94 = 4;
        int32_t l_95 = 0;
        l_58.f2 = l_94;
        l_95 = 0x6057BAD6;
        return l_95;
    }
    else
    { /* block id: 72 */
        int16_t l_114 = 0xAB5B;
        int32_t l_115 = 5;
        int16_t l_200 = 1;
        struct S0 l_203 = {0x522CE914,0x91B56909,0x2C5253E1};
        int32_t l_208 = (-1);
        int16_t l_226 = 0xB235;
        int32_t l_287 = 0x7EDA4BA7;
        for (l_36 = 0; (l_36 != 23); ++l_36)
        { /* block id: 75 */
            uint32_t l_118 = 0x79293E9D;
            int32_t l_192 = 0x8807F30B;
            struct S0 l_195 = {0x8119176D,0U,-1};
            float l_259 = 0x3.Cp-1;
            struct S0 l_276 = {0x51D552A8,0U,0xC1DC0149};
            for (l_58.f2 = 0; (l_58.f2 > (-17)); l_58.f2 = safe_sub_func_uint16_t_u_u(l_58.f2, 1))
            { /* block id: 78 */
                struct S0 l_102 = {4294967295U,0xEE040EEA,0x4458F597};
                int32_t l_211 = (-1);
                uint16_t l_252 = 0x6BC9;
                int32_t l_253 = 0;
                int32_t l_286 = 1;
                for (l_58.f1 = 17; (l_58.f1 < 52); l_58.f1 = safe_add_func_uint16_t_u_u(l_58.f1, 5))
                { /* block id: 81 */
                    l_102 = l_58;
                }
                if ((safe_lshift_func_uint16_t_u_s(func_105((~(0x8A5C ^ (safe_mod_func_int32_t_s_s(l_114, (__builtin_clzl(__builtin_clzl((l_115 = func_60(l_58.f1, l_59)))) && l_57))))), __builtin_popcountl((safe_rshift_func_int16_t_s_s(l_114, l_102.f2))), l_114, l_118, l_118), 3)))
                { /* block id: 158 */
                    struct S0 l_194 = {0xAD958E10,0xFD1B8A4D,0xDA33BDD3};
                    l_192 = (!0U);
                    l_195 = func_75((l_115 = func_43((+l_192), l_194, l_194, l_59.f1)));
                    for (l_192 = 21; (l_192 > 8); l_192 = safe_sub_func_int32_t_s_s(l_192, 2))
                    { /* block id: 164 */
                        l_200 = ((((l_115 = l_102.f2) <= __builtin_parityll(l_114)) ^ l_192) > (((safe_rshift_func_int16_t_s_s((0x3F83878C | (l_194.f2 | 0xAE044C02)), 9)) >= l_59.f0) <= ((l_59.f0 == l_114) & l_102.f2)));
                    }
                }
                else
                { /* block id: 168 */
                    if (l_57)
                        break;
                    return l_195.f2;
                }
                if ((__builtin_ffsl(l_114) >= (safe_mul_func_int16_t_s_s(func_69(l_203, func_75((l_40 = l_203.f1)), (safe_rshift_func_uint16_t_u_s((l_115 = (safe_lshift_func_uint16_t_u_u(l_195.f1, 10))), l_195.f0))), l_102.f1))))
                { /* block id: 174 */
                    int8_t l_218 = 0;
                    int32_t l_227 = 0x8204FB6B;
                    struct S0 l_249 = {1U,0x9BCC19F9,0x07BA8037};
                    l_102.f2 = (l_54 = ((l_192 < ((l_203.f2 = ((l_195.f2 = l_208) > (l_102.f1 > (safe_mod_func_int32_t_s_s(l_102.f1, l_211))))) | (safe_lshift_func_int16_t_s_u((l_227 = (safe_sub_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_s(l_218, l_219)) & (l_226 = (safe_lshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(0xF5FF, l_195.f0)), l_203.f0)), l_208)))), l_200))), 1)))) == l_102.f2));
                    l_59 = func_75((func_79(((l_115 = (safe_lshift_func_uint16_t_u_s((safe_add_func_int16_t_s_s(l_118, ((l_195.f2 = (safe_lshift_func_uint16_t_u_u(func_79(l_203.f0, func_75(l_102.f1)), l_227))) >= l_218))), 14))) || (safe_add_func_int16_t_s_s(__builtin_bswap64((safe_mod_func_uint16_t_u_u((l_102.f2 > (safe_sub_func_int32_t_s_s((l_203.f0 <= l_240), l_59.f1))), 0x1D0C))), 1))), l_203) & l_203.f1));
                    if (((safe_sub_func_uint32_t_u_u((safe_mod_func_int16_t_s_s(((3U | (safe_mod_func_int16_t_s_s(0x4C25, l_59.f2))) > ((l_253 = (l_102.f2 = (safe_rshift_func_int16_t_s_u(((func_60(l_200, l_249) ^ __builtin_clzl((safe_lshift_func_uint16_t_u_u(l_249.f0, l_252)))) != 0x1C93), 14)))) != 0U)), l_59.f0)), (-1))) >= l_59.f0))
                    { /* block id: 186 */
                        return l_102.f2;
                    }
                    else
                    { /* block id: 188 */
                        int8_t l_254 = 3;
                        return l_254;
                    }
                }
                else
                { /* block id: 191 */
                    uint32_t l_258 = 0xA5EDEFCC;
                    int32_t l_260 = (-1);
                    uint32_t l_274 = 0xB609877F;
                    for (l_54 = (-11); (l_54 < (-13)); l_54 = safe_sub_func_int32_t_s_s(l_54, 7))
                    { /* block id: 194 */
                        uint32_t l_257 = 0xE94D96B2;
                        int32_t l_275 = (-1);
                        l_257 = __builtin_popcount(l_114);
                        l_260 = func_69(l_102, l_203, ((l_59.f2 == __builtin_bswap64((l_195.f2 = l_258))) || func_105(l_257, (l_59.f1 != 0x1.3p-1), (0x3947 || l_58.f1), l_200, l_102.f0)));
                        l_115 = (+(__builtin_parityll(((((l_102.f2 = l_257) ^ (safe_add_func_uint16_t_u_u((l_203.f0 ^ (safe_mod_func_uint16_t_u_u(l_200, (safe_mod_func_uint32_t_u_u(l_115, func_79((safe_lshift_func_int16_t_s_s(((l_260 = l_59.f1) ^ (((l_258 <= (0xA048263A >= l_257)) >= l_102.f1) < l_257)), 12)), l_59)))))), l_102.f0))) < l_211) & l_102.f0)) < (-0x2.Bp+1)));
                        l_275 = (l_274 = ((safe_sub_func_uint16_t_u_u(l_192, (0xB0E2667C | (safe_add_func_uint16_t_u_u(__builtin_parityl(l_258), l_257))))) | __builtin_ffsll(l_102.f2)));
                    }
                    l_276 = l_58;
                    l_203.f2 = (safe_add_func_float_f_f((0xB.231903p+78 <= ((l_253 != (!((l_102.f2 = (-0x1.Dp-1)) != 0x7.EB4871p-33))) < (((((safe_sub_func_float_f_f((((l_115 = l_58.f0) >= l_114) != func_129(((safe_mod_func_int16_t_s_s((l_195.f2 ^ (safe_mul_func_uint16_t_u_u(l_211, l_208))), l_258)) || l_195.f0), l_274)), l_58.f1)) < l_54) != l_286) == l_287) == l_260))), l_258));
                }
            }
        }
        l_203 = func_75(l_203.f1);
        l_203 = l_203;
    }
    return l_58.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_43(uint32_t  p_44, struct S0  p_45, struct S0  p_46, uint32_t  p_47)
{ /* block id: 45 */
    int32_t l_63 = 0x8ED9E8BD;
    struct S0 l_73 = {6U,0x36CCC853,0x3C4855F0};
    int16_t l_74 = 0;
    struct S0 l_85 = {0xF3843C9D,4294967287U,-2};
    p_46.f2 = (func_60((l_63 & (__builtin_popcount((safe_mul_func_uint16_t_u_u(l_63, (safe_unary_minus_func_uint16_t_u((l_73.f2 = (safe_mod_func_int32_t_s_s(((4294967295U != l_63) | func_69(l_73, l_73, l_74)), p_45.f2)))))))) || 65535U)), l_85) < l_63);
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_60(const int8_t  p_61, struct S0  p_62)
{ /* block id: 58 */
    float l_86 = 0x1.Bp+1;
    int32_t l_91 = 0x796D0A3A;
    int32_t l_92 = 0xCBDA1257;
    int32_t l_93 = 0;
    l_93 = (p_62.f1 != (p_62.f2 = (safe_mod_func_uint16_t_u_u(p_62.f0, (safe_mul_func_int16_t_s_s(p_62.f2, (l_92 = (l_91 = p_62.f0))))))));
    return l_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_69(struct S0  p_70, struct S0  p_71, uint32_t  p_72)
{ /* block id: 46 */
    int8_t l_77 = (-1);
    int32_t l_78 = 0;
    p_70 = func_75(((p_70.f0 != ((l_78 = l_77) > p_70.f1)) == (8U & func_79((l_77 || 0x1936), p_70))));
    p_70 = p_70;
    l_78 = p_71.f1;
    return p_71.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_75(int32_t  p_76)
{ /* block id: 51 */
    struct S0 l_84 = {0xA0404C69,8U,0x75637402};
    return l_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_79(int32_t  p_80, struct S0  p_81)
{ /* block id: 48 */
    p_81.f2 = (safe_rshift_func_uint16_t_u_u(0xDC3D, 8));
    return p_81.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_105(int32_t  p_106, float  p_107, uint32_t  p_108, int16_t  p_109, uint32_t  p_110)
{ /* block id: 85 */
    uint32_t l_121 = 0xC470FE6C;
    int32_t l_159 = 0x952B13B0;
    struct S0 l_162 = {4294967295U,0x44AC5510,1};
    float l_163 = 0x0.1B912Cp-21;
    int32_t l_164 = 1;
    if ((0xDBEA || 0x9F13))
    { /* block id: 86 */
        uint16_t l_124 = 8U;
        int32_t l_160 = 0;
        for (p_110 = (-26); (p_110 > 50); p_110 = safe_add_func_uint32_t_u_u(p_110, 6))
        { /* block id: 89 */
            int16_t l_143 = 0x2E54;
            struct S0 l_161 = {0x7D7CE495,0x7760C716,0x2FD558AF};
            l_160 = (l_121 != (safe_sub_func_float_f_f(l_124, (safe_add_func_float_f_f((((l_159 = ((safe_add_func_float_f_f(func_129(p_106, (0x4.5DD30Cp+83 < (-0x8.Dp-1))), (safe_sub_func_float_f_f(((func_135(l_124, func_141(l_143), p_108, p_109, p_106) <= p_109) >= l_143), p_109)))) != 0x8.A8DCBEp+32)) > p_107) != p_106), l_121)))));
            l_162 = l_161;
            p_106 = p_110;
            return l_162.f0;
        }
        return l_160;
    }
    else
    { /* block id: 118 */
        const int32_t l_176 = 0x76DE95A8;
        struct S0 l_186 = {1U,4294967288U,1};
lbl_178:
        l_164 = 0;
        for (l_159 = (-12); (l_159 == 4); l_159 = safe_add_func_uint16_t_u_u(l_159, 1))
        { /* block id: 122 */
            struct S0 l_172 = {0xB7FEC2A5,1U,6};
            for (l_162.f1 = 0; (l_162.f1 <= 23); ++l_162.f1)
            { /* block id: 125 */
                int8_t l_177 = 0x41;
                struct S0 l_180 = {7U,0x12E294E6,0x00BB5F28};
                for (l_121 = 1; (l_121 != 48); l_121 = safe_add_func_int16_t_s_s(l_121, 1))
                { /* block id: 128 */
                    float l_179 = (-0x7.2p-1);
                    if (p_110)
                    { /* block id: 129 */
                        struct S0 l_171 = {0x24A1A4E4,1U,-1};
                        l_172 = l_171;
                    }
                    else
                    { /* block id: 131 */
                        int8_t l_175 = 0x37;
                        l_177 = ((safe_rshift_func_uint16_t_u_s(p_110, (l_175 = __builtin_parity(p_109)))) ^ l_176);
                        if (l_176)
                            goto lbl_178;
                        if (l_175)
                            continue;
                        if (p_109)
                            continue;
                    }
                    l_180 = l_180;
                }
                for (l_162.f0 = 0; (l_162.f0 != 54); l_162.f0 = safe_add_func_int16_t_s_s(l_162.f0, 1))
                { /* block id: 142 */
                    uint16_t l_183 = 5U;
                    if (l_162.f1)
                        break;
                    l_183 = l_176;
                    if (l_183)
                        break;
                }
                l_172.f2 = ((safe_add_func_float_f_f((p_107 = func_43(l_121, l_186, func_75(l_177), (p_110 <= p_110))), (((((safe_sub_func_float_f_f(p_106, (l_180.f2 != l_172.f1))) <= p_109) < l_172.f0) < p_106) >= p_110))) == p_109);
            }
        }
    }
    for (p_106 = (-19); (p_106 != (-15)); p_106 = safe_add_func_uint32_t_u_u(p_106, 1))
    { /* block id: 154 */
        return l_159;
    }
    return p_106;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_129(const int16_t  p_130, float  p_131)
{ /* block id: 90 */
    uint32_t l_132 = 0x8D308ECB;
    l_132 = (-1);
    return l_132;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_135(int32_t  p_136, struct S0  p_137, const int32_t  p_138, const uint32_t  p_139, int16_t  p_140)
{ /* block id: 108 */
    float l_157 = 0xD.8B997Ap-52;
    int32_t l_158 = 0x5B98692F;
    l_158 = 0;
    return p_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_141(uint32_t  p_142)
{ /* block id: 93 */
    int32_t l_148 = 0;
    struct S0 l_152 = {4294967286U,0x67FC1DF0,0x7D168D33};
    for (p_142 = 10; (p_142 >= 41); p_142 = safe_add_func_int16_t_s_s(p_142, 1))
    { /* block id: 96 */
        int8_t l_151 = 0xD3;
        l_152.f2 = (safe_sub_func_int16_t_s_s((__builtin_parityll(l_148) != (safe_rshift_func_uint16_t_u_s((p_142 > l_151), 12))), func_69(func_75(p_142), func_75(func_60(l_151, l_152)), l_152.f0)));
    }
    for (p_142 = 0; (p_142 < 15); p_142 = safe_add_func_int32_t_s_s(p_142, 4))
    { /* block id: 101 */
        uint16_t l_155 = 0x7F7B;
        struct S0 l_156 = {0x7BB088A0,0U,-9};
        l_155 = 0xB2F6CA1B;
        return l_156;
    }
    l_152 = l_152;
    l_152.f2 = l_152.f0;
    return l_152;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 70
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 18
   depth: 5, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 240
XXX times a non-volatile is write: 85
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 82
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 15
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6
   depth: 4, occurrence: 17
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 28.9
XXX percentage an existing variable is used: 71.1
********************* end of statistics **********************/

