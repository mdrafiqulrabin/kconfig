/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-comma-operators --argc --bitfields --no-arrays --pointers --structs --no-unions --packed-struct --divs --no-muls --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --longlong --float --jumps --no-volatiles --no-compound-assignment --consts --no-inline-function --no-volatile-pointers --no-const-pointers --no-global-variables --builtins --no-int8 --no-uint8
 * Seed:      2883606640
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   float  f0;
   float  f1;
   uint32_t  f2;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 21;
   float  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_35(void);
static uint16_t  func_53(uint64_t  p_54, uint32_t  p_55, int64_t  p_56, uint16_t * p_57);
static uint64_t * func_60(int32_t  p_61);
static int32_t **** func_69(uint64_t * p_70, uint64_t  p_71, int32_t * p_72);
static int32_t  func_75(uint64_t * p_76);
static uint64_t ** func_80(int16_t  p_81, struct S0  p_82, float  p_83);
static int32_t * func_92(int32_t * p_93, int32_t ** p_94, uint16_t * p_95);
static int32_t ** func_98(int32_t *** p_99, int64_t  p_100, uint64_t  p_101);
static int32_t *** func_102(struct S1  p_103, uint16_t  p_104, int64_t  p_105, int32_t *** p_106);
static struct S1  func_107(uint32_t  p_108);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_35(void)
{ /* block id: 36 */
    const float l_38 = 0x1.Fp+1;
    int32_t l_39 = 0xC77DCDA7L;
    uint16_t l_43 = 65535UL;
    uint16_t *l_42 = &l_43;
    uint16_t l_45 = 0x3196L;
    uint16_t *l_44 = &l_45;
    int32_t *l_46 = &l_39;
    uint64_t l_59 = 18446744073709551615UL;
    uint64_t *l_58 = &l_59;
    uint64_t *l_687 = (void*)0;
    float l_714 = 0x0.AD60E8p-75;
lbl_712:
    (*l_46) = (safe_add_func_int16_t_s_s(l_39, ((*l_44) = ((*l_42) = (safe_sub_func_uint16_t_u_u(__builtin_ctzll(l_39), l_39))))));
    if (((safe_add_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s((((void*)0 == &l_39) <= func_53(((*l_58) = (*l_46)), (*l_46), (__builtin_popcount((((l_687 = func_60(((void*)0 != &l_39))) != l_58) >= (l_42 != l_44))) & (*l_46)), &l_43)), 3)) <= 0x2B233D5AL), 1)), (*l_46))) || 0xBDA9L))
    { /* block id: 434 */
        if (l_43)
            goto lbl_712;
    }
    else
    { /* block id: 436 */
        int32_t **l_713 = &l_46;
        (*l_713) = &l_39;
        (**l_713) = (*l_46);
    }
    return l_714;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_53(uint64_t  p_54, uint32_t  p_55, int64_t  p_56, uint16_t * p_57)
{ /* block id: 416 */
    uint64_t l_694 = 0x3C018DC6315FFA73LL;
    int32_t l_700 = (-1L);
    int32_t *l_699 = &l_700;
    uint32_t ****l_702 = (void*)0;
    uint16_t l_706 = 65528UL;
    uint16_t *l_705 = &l_706;
    int32_t **l_707 = &l_699;
    struct S0 *l_710 = (void*)0;
    struct S0 **l_711 = &l_710;
    if ((safe_sub_func_int64_t_s_s((safe_lshift_func_uint16_t_u_u(((safe_div_func_int32_t_s_s(__builtin_clzl(p_56), l_694)) & p_56), 15)), 0xA864731757C94430LL)))
    { /* block id: 417 */
        uint32_t l_695 = 0xB16BDFAAL;
        int32_t l_697 = (-2L);
        int32_t *l_696 = &l_697;
        (*l_696) = l_695;
    }
    else
    { /* block id: 419 */
        int32_t *l_698 = (void*)0;
        int32_t **l_701 = &l_698;
        uint32_t *****l_703 = &l_702;
        (*l_701) = (l_699 = l_698);
lbl_704:
        (*l_701) = (void*)0;
        (*l_703) = l_702;
        if (p_56)
            goto lbl_704;
    }
    (*l_707) = func_92(&l_700, &l_699, l_705);
    for (p_54 = 0; (p_54 <= 31); p_54 = safe_add_func_uint64_t_u_u(p_54, 1))
    { /* block id: 429 */
        return (*p_57);
    }
    (*l_711) = l_710;
    return (*p_57);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t * func_60(int32_t  p_61)
{ /* block id: 41 */
    int32_t **l_63 = (void*)0;
    int32_t ***l_62 = &l_63;
    int16_t l_544 = 0L;
    int32_t ****l_670 = &l_62;
    uint64_t **l_673 = (void*)0;
    uint64_t *l_686 = (void*)0;
    (*l_62) = (void*)0;
    for (p_61 = 0; (p_61 == (-16)); p_61 = safe_sub_func_int16_t_s_s(p_61, 1))
    { /* block id: 45 */
        int32_t l_66 = 0x9A97A8D1L;
        int32_t l_680 = 0x65544F09L;
        int32_t *l_685 = &l_680;
        int32_t **l_684 = &l_685;
        for (l_66 = 0; (l_66 <= 11); l_66 = safe_add_func_int64_t_s_s(l_66, 1))
        { /* block id: 48 */
            uint64_t l_74 = 0UL;
            uint64_t *l_73 = &l_74;
            int32_t l_541 = 0xE6D9B8B5L;
            uint32_t l_543 = 0x4FBB8765L;
            uint32_t *l_542 = &l_543;
            int32_t ****l_669 = &l_62;
            int32_t *****l_668 = &l_669;
            struct S1 l_682 = {637,0x3.A2988Ap+64};
            struct S1 *l_681 = &l_682;
            l_670 = ((*l_668) = func_69(l_73, (func_75(&l_74) & (safe_unary_minus_func_uint64_t_u(((p_61 | p_61) || (__builtin_ctzll(((p_61 ^ ((*l_542) = (~l_541))) <= ((p_61 || (l_544 | p_61)) != p_61))) <= p_61))))), &l_66));
            if (p_61)
            { /* block id: 403 */
                int64_t l_675 = (-6L);
                int64_t *l_674 = &l_675;
                int64_t l_677 = (-6L);
                int64_t *l_676 = &l_677;
                float l_679 = 0x5.0p+1;
                float *l_678 = &l_679;
                (*l_678) = __builtin_parityll((((*l_674) = __builtin_ia32_crc32qi(p_61, (safe_lshift_func_int16_t_s_s((l_673 != l_673), 2)))) <= ((*l_676) = (p_61 > (-1L)))));
                l_680 = l_66;
            }
            else
            { /* block id: 408 */
                struct S1 **l_683 = &l_681;
                (*l_683) = l_681;
            }
        }
        (*l_684) = &l_680;
    }
    return l_686;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t **** func_69(uint64_t * p_70, uint64_t  p_71, int32_t * p_72)
{ /* block id: 293 */
    int32_t l_546 = 0L;
    int32_t *l_545 = &l_546;
    uint16_t *l_547 = (void*)0;
    int32_t **l_548 = &l_545;
    int32_t *l_550 = &l_546;
    int32_t **l_549 = &l_550;
    uint16_t **l_553 = &l_547;
    uint16_t l_561 = 0x3BFCL;
    uint32_t *l_567 = (void*)0;
    uint32_t **l_566 = &l_567;
    int32_t **l_593 = &l_545;
    uint32_t l_597 = 0xE69EFEEBL;
    int32_t ***l_622 = &l_548;
    int32_t ****l_621 = &l_622;
    struct S0 l_650 = {0xC.A61A78p+6,0x1.6p-1,7UL};
    struct S0 *l_658 = &l_650;
    int32_t ****l_662 = &l_622;
    int32_t ****l_663 = &l_622;
    int32_t ****l_664 = &l_622;
    int32_t ****l_665 = &l_622;
    int32_t ****l_666 = &l_622;
    int32_t ****l_667 = (void*)0;
    (*l_549) = ((*l_548) = func_92(l_545, &l_545, l_547));
lbl_568:
    for (p_71 = 0; (p_71 > 45); p_71 = safe_add_func_uint16_t_u_u(p_71, 1))
    { /* block id: 298 */
        const uint16_t l_556 = 0xC7DBL;
        const uint16_t *l_555 = &l_556;
        const uint16_t **l_554 = &l_555;
        int32_t *l_557 = (void*)0;
        int32_t *l_558 = (void*)0;
        int32_t l_559 = (-1L);
        int32_t *l_560 = &l_546;
        (*l_560) = (l_559 = ((l_553 != l_554) <= 0xE4174E2B277425FALL));
    }
    if ((l_546 = __builtin_clzl(l_561)))
    { /* block id: 303 */
        uint64_t l_570 = 0xBFB580818782F027LL;
        uint64_t *l_569 = &l_570;
        int32_t l_590 = 0L;
        int32_t ***l_620 = &l_593;
        int32_t ****l_619 = &l_620;
        struct S1 l_630 = {941,0x6.Ap-1};
        uint64_t **l_647 = &l_569;
        uint64_t ***l_646 = &l_647;
        uint64_t ****l_645 = &l_646;
        uint64_t *****l_644 = &l_645;
        for (l_561 = (-19); (l_561 <= 29); l_561 = safe_add_func_uint16_t_u_u(l_561, 1))
        { /* block id: 306 */
            uint64_t l_574 = 1UL;
            uint16_t **l_577 = &l_547;
            uint64_t **l_586 = (void*)0;
            int32_t ****l_591 = (void*)0;
            for (l_546 = 0; (l_546 > 14); l_546 = safe_add_func_int32_t_s_s(l_546, 1))
            { /* block id: 309 */
                int32_t *l_592 = &l_590;
                uint16_t *l_596 = &l_561;
                if ((9UL && ((p_71 ^ 0xEBEA63802CE8FD7ELL) && (l_566 != (void*)0))))
                { /* block id: 310 */
                    if (l_546)
                        goto lbl_568;
                    if ((func_75(l_569) >= (*p_70)))
                    { /* block id: 312 */
                        int16_t l_573 = 0xEA96L;
                        uint16_t ***l_578 = &l_553;
                        uint64_t **l_581 = &l_569;
                        int32_t *l_587 = (void*)0;
                        int32_t l_589 = (-7L);
                        int32_t *l_588 = &l_589;
                        l_574 = ((safe_sub_func_int16_t_s_s(l_573, 7UL)) <= (p_71 > __builtin_ctzll((*p_70))));
                        (*l_588) = (safe_sub_func_uint16_t_u_u((l_577 == ((*l_578) = &l_547)), ((safe_add_func_int32_t_s_s(5L, (l_581 != &p_70))) & (__builtin_ffsll((((safe_add_func_uint64_t_u_u(l_573, 0x6119070582BCD2E3LL)) >= (l_586 != (void*)0)) >= 5UL)) != p_71))));
                        (*l_588) = 0x60A1FF25L;
                        l_590 = 1L;
                    }
                    else
                    { /* block id: 318 */
                        return l_591;
                    }
                    p_72 = p_72;
                    (*l_593) = func_92(func_92(l_592, &l_545, (*l_553)), l_593, (*l_577));
                }
                else
                { /* block id: 323 */
                    if ((*p_72))
                        break;
                }
                for (l_574 = 0; (l_574 >= 33); l_574 = safe_add_func_int16_t_s_s(l_574, 1))
                { /* block id: 328 */
                    (*l_593) = func_92(p_72, &p_72, l_596);
                }
            }
            if (l_597)
            { /* block id: 332 */
                struct S1 *l_598 = (void*)0;
                uint16_t ***l_603 = &l_553;
                int32_t *l_623 = (void*)0;
                if ((*p_72))
                { /* block id: 333 */
                    int64_t l_608 = 1L;
                    if ((*p_72))
                    { /* block id: 334 */
                        struct S1 **l_599 = &l_598;
                        float l_601 = 0x1.303DC8p-64;
                        float *l_600 = &l_601;
                        (*l_549) = p_72;
                        (*l_599) = l_598;
                        (*l_600) = 0x1.EB192Fp-33;
                    }
                    else
                    { /* block id: 338 */
                        uint32_t l_602 = 8UL;
                        if (l_602)
                            break;
                    }
                    if (((((l_603 == (void*)0) <= (safe_mod_func_uint16_t_u_u((p_71 || (safe_mod_func_uint32_t_u_u(l_608, p_71))), 0x4D82L))) == ((*p_70) = (((safe_sub_func_uint16_t_u_u((safe_div_func_uint32_t_u_u((0x10BBA5B3L == p_71), (safe_sub_func_int32_t_s_s((!(((p_71 & 65535UL) > 7UL) && l_570)), p_71)))), 4UL)) || p_71) <= p_71))) == (-8L)))
                    { /* block id: 342 */
                        uint32_t l_616 = 18446744073709551613UL;
                        if (l_616)
                            break;
                    }
                    else
                    { /* block id: 344 */
                        int32_t ***l_618 = (void*)0;
                        int32_t ****l_617 = &l_618;
                        return l_591;
                    }
                    if ((*p_72))
                        continue;
                    (***l_619) = l_623;
                }
                else
                { /* block id: 349 */
                    if ((*p_72))
                        break;
                }
                if ((*p_72))
                    break;
            }
            else
            { /* block id: 353 */
                return l_591;
            }
            if ((*p_72))
            { /* block id: 356 */
                struct S1 l_626 = {1054,0x3.57BACDp-51};
                for (l_546 = 0; (l_546 >= (-25)); l_546 = safe_sub_func_int16_t_s_s(l_546, 4))
                { /* block id: 359 */
                    struct S1 *l_627 = &l_626;
                    float l_629 = 0x0.Ap-1;
                    int32_t l_631 = 1L;
                    (*l_627) = l_626;
                    if ((l_626.f0 = (*p_72)))
                    { /* block id: 362 */
                        float *l_628 = &l_626.f1;
                        (*l_628) = ((void*)0 != &l_570);
                        l_629 = 0x6.4p-1;
                        (*l_627) = l_630;
                    }
                    else
                    { /* block id: 366 */
                        int32_t *****l_632 = &l_591;
                        if (l_631)
                            break;
                        l_631 = (*p_72);
                        (*l_632) = l_591;
                        return l_591;
                    }
                }
            }
            else
            { /* block id: 373 */
                const uint16_t l_640 = 0xE6C2L;
                int32_t l_642 = 0x5EBA5869L;
                for (l_574 = 22; (l_574 != 40); l_574 = safe_add_func_uint16_t_u_u(l_574, 3))
                { /* block id: 376 */
                    uint64_t *l_639 = &l_574;
                    int32_t l_641 = 0L;
                    uint16_t *l_643 = &l_561;
                    l_642 = (l_641 = (safe_add_func_int64_t_s_s((safe_lshift_func_uint16_t_u_u(p_71, l_640)), l_641)));
                    (*l_549) = func_92(((**l_622) = p_72), (**l_621), l_643);
                }
            }
        }
        l_644 = l_644;
    }
    else
    { /* block id: 385 */
        float l_649 = 0xB.C35ACBp+86;
        float *l_648 = &l_649;
        struct S0 *l_651 = (void*)0;
        struct S0 *l_652 = &l_650;
        int32_t l_655 = 0x664DF6DFL;
        int32_t ***l_659 = (void*)0;
        uint16_t *l_660 = &l_561;
        (*l_648) = p_71;
        (**l_622) = l_648;
        (*l_652) = l_650;
        if ((safe_mul_func_uint16_t_u_u(l_655, ((*l_545) > (((*p_70) = l_655) & ((3L ^ l_655) > ((void*)0 == &p_71)))))))
        { /* block id: 390 */
            int32_t l_661 = 2L;
            l_658 = (void*)0;
            (*l_549) = ((*l_593) = func_92(p_72, func_98(l_659, p_71, (*p_70)), l_660));
            l_661 = (-2L);
        }
        else
        { /* block id: 395 */
            if (l_650.f2)
                goto lbl_568;
            (*l_648) = (***l_622);
        }
    }
    return l_667;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_75(uint64_t * p_76)
{ /* block id: 49 */
    int32_t l_77 = 0x17005583L;
    uint32_t l_399 = 1UL;
    int32_t l_401 = 0xC6D23637L;
    int32_t *l_403 = &l_401;
    int32_t **l_402 = &l_403;
    uint64_t l_459 = 0UL;
    struct S0 l_481 = {0x0.9p-1,0x0.Ep+1,0xD4D1B9F4L};
    int32_t *l_490 = (void*)0;
    struct S1 l_493 = {1143,0x0.1p-1};
    struct S1 *l_492 = &l_493;
    struct S1 **l_491 = &l_492;
    float l_530 = 0x5.551FEEp-71;
    float *l_535 = &l_481.f1;
    float *l_536 = &l_493.f1;
    int16_t l_537 = 0x5159L;
    uint64_t l_538 = 0xCF4C983524AB5D2ELL;
    for (l_77 = 24; (l_77 <= (-16)); l_77 = safe_sub_func_int16_t_s_s(l_77, 8))
    { /* block id: 52 */
        uint16_t l_84 = 1UL;
        struct S0 l_85 = {-0x1.Bp-1,0x9.Ep+1,4UL};
        int32_t *l_89 = &l_77;
        int32_t **l_88 = &l_89;
        int32_t *l_90 = &l_77;
        uint64_t **l_348 = (void*)0;
        uint64_t ***l_347 = &l_348;
        uint16_t l_441 = 0xC275L;
        struct S0 *l_450 = &l_85;
        struct S0 **l_449 = &l_450;
        (*l_347) = func_80(l_84, l_85, ((safe_add_func_float_f_f((l_77 <= (((*l_88) = (void*)0) != l_90)), (!(*l_90)))) != ((void*)0 != &p_76)));
        for (l_85.f2 = 0; (l_85.f2 != 47); l_85.f2 = safe_add_func_uint16_t_u_u(l_85.f2, 1))
        { /* block id: 203 */
            int32_t l_357 = 0x4E24FC96L;
            int32_t ***l_359 = &l_88;
            const struct S0 *l_362 = &l_85;
            uint16_t *l_382 = &l_84;
            uint16_t *l_434 = (void*)0;
            const uint32_t l_474 = 0UL;
            for (l_84 = 4; (l_84 > 54); l_84 = safe_add_func_uint16_t_u_u(l_84, 1))
            { /* block id: 206 */
                int32_t l_361 = 0x0DE8F57CL;
                int32_t **l_381 = (void*)0;
                float l_396 = (-0x4.8p+1);
                int32_t *l_425 = (void*)0;
                int32_t *l_426 = &l_361;
                struct S0 *l_448 = &l_85;
                struct S0 **l_447 = &l_448;
                struct S1 **l_494 = &l_492;
            }
            for (l_399 = 0; (l_399 >= 9); l_399 = safe_add_func_uint16_t_u_u(l_399, 1))
            { /* block id: 266 */
                int64_t l_499 = 0L;
                uint32_t l_503 = 0x084D59CCL;
                uint32_t *l_502 = &l_503;
                int32_t l_504 = (-8L);
                int64_t l_506 = 0L;
                int64_t *l_505 = &l_506;
                uint64_t *l_507 = &l_459;
                float *l_508 = (void*)0;
                float *l_509 = &l_481.f1;
                float *l_519 = &l_85.f0;
                struct S1 *l_520 = &l_493;
                (*l_509) = (0xF.3F4B0Cp-0 > ((*l_403) = (__builtin_bswap32((**l_402)) < (__builtin_bswap64(((*l_507) = ((((*p_76) = l_499) != ((safe_sub_func_int64_t_s_s((*l_90), ((((*l_505) = ((l_504 = ((__builtin_ffsl((*l_90)) <= (l_499 != ((*l_502) = (*l_90)))) && l_474)) > l_499)) | l_357) >= l_499))) <= (*l_403))) >= l_499))) > (-0x1.Ap-1)))));
                (*l_519) = (((safe_sub_func_float_f_f((l_499 > (!(safe_add_func_float_f_f((-l_506), (((*l_509) = ((**l_402) = l_499)) != (safe_sub_func_float_f_f(0xE.B296C2p-89, ((*l_90) < l_499)))))))), ((((!(l_499 < ((-0x9.Dp+1) <= l_504))) >= 0xA.3813D3p-96) >= l_357) == (-0x7.Dp-1)))) == l_357) == l_504);
                (*l_491) = l_520;
                for (l_357 = (-8); (l_357 != 28); l_357 = safe_add_func_int16_t_s_s(l_357, 1))
                { /* block id: 280 */
                    int16_t l_523 = 0x0C5EL;
                    (*l_403) = __builtin_clz(l_523);
                    return l_503;
                }
            }
            (*l_88) = func_92((**l_359), func_98(&l_402, (**l_402), (*p_76)), l_434);
        }
    }
    l_537 = (__builtin_popcount((*l_403)) > ((((*l_536) = ((*l_403) < ((*l_535) = (safe_add_func_float_f_f((safe_sub_func_float_f_f((**l_402), ((((safe_add_func_float_f_f(((**l_402) >= 0x0.9p-1), 0x2.0EF8D4p-28)) >= l_530) > (safe_div_func_float_f_f((safe_sub_func_float_f_f(((**l_402) >= (*l_403)), 0x1.Ep+1)), 0x6.3F5346p-2))) >= (**l_402)))), (**l_402)))))) <= (**l_402)) <= (**l_402)));
    return l_538;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t ** func_80(int16_t  p_81, struct S0  p_82, float  p_83)
{ /* block id: 54 */
    int32_t l_97 = 0x77135672L;
    int32_t *l_96 = &l_97;
    int64_t *l_115 = (void*)0;
    int64_t l_117 = 1L;
    int64_t *l_116 = &l_117;
    int32_t l_122 = 0xC16B31B7L;
    int16_t l_124 = 0x3C69L;
    int16_t *l_123 = &l_124;
    int64_t l_126 = 0L;
    int64_t *l_125 = &l_126;
    int16_t l_128 = (-1L);
    int16_t *l_127 = &l_128;
    uint16_t l_130 = 0x9C2DL;
    uint16_t *l_129 = &l_130;
    int32_t **l_219 = (void*)0;
    int32_t ***l_218 = &l_219;
    int32_t ****l_245 = &l_218;
    int32_t **l_268 = &l_96;
    int32_t l_294 = 0x1355ABE8L;
    uint64_t l_332 = 18446744073709551615UL;
    uint64_t *l_331 = &l_332;
    uint64_t **l_330 = &l_331;
    uint64_t **l_346 = (void*)0;
    (*l_268) = func_92(l_96, func_98(((*l_245) = func_102(func_107((safe_unary_minus_func_uint16_t_u(((*l_129) = ((safe_unary_minus_func_uint16_t_u((safe_sub_func_int64_t_s_s((p_82.f2 && (((safe_sub_func_int64_t_s_s(p_81, ((((*l_116) = (*l_96)) && (-5L)) >= (safe_div_func_int16_t_s_s(((*l_127) = (safe_lshift_func_int16_t_s_s((l_122 = (*l_96)), (((*l_123) = p_82.f2) < (((*l_125) = (*l_96)) != (p_81 || (*l_96))))))), p_81))))) < 0x38B87B6FF578636BLL) != 18446744073709551615UL)), (*l_96))))) > p_81))))), p_81, (*l_96), l_218)), (*l_96), p_81), l_129);
lbl_345:
    for (l_117 = 24; (l_117 <= (-11)); l_117 = safe_sub_func_uint64_t_u_u(l_117, 1))
    { /* block id: 136 */
        struct S0 l_281 = {0x5.Bp-1,0x7.Bp-1,0UL};
        struct S0 *l_280 = &l_281;
        int32_t l_288 = 0xF432E68CL;
        int32_t **l_289 = &l_96;
        int32_t l_304 = (-1L);
        uint16_t *l_311 = (void*)0;
        uint64_t **l_333 = &l_331;
        struct S1 l_340 = {-1063,0x2.35C5DCp-43};
        if ((0xBA11L | p_81))
        { /* block id: 137 */
            float l_272 = 0x1.9p+1;
            float *l_271 = &l_272;
            float *l_273 = (void*)0;
            float *l_274 = (void*)0;
            float l_276 = 0x3.3C9283p-54;
            float *l_275 = &l_276;
            struct S0 l_277 = {0x1.8p-1,-0x1.9p+1,0x6651808FL};
            struct S0 *l_278 = (void*)0;
            struct S0 *l_279 = &l_277;
            (*l_275) = ((*l_271) = (-0x2.Cp+1));
            (*l_279) = l_277;
        }
        else
        { /* block id: 141 */
            uint32_t **l_282 = (void*)0;
            uint32_t ***l_283 = &l_282;
            if (p_81)
                break;
            l_280 = l_280;
            (*l_283) = l_282;
            if (l_117)
                goto lbl_345;
        }
    }
    (*l_268) = (*l_268);
    return l_346;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_92(int32_t * p_93, int32_t ** p_94, uint16_t * p_95)
{ /* block id: 128 */
    int32_t *l_263 = (void*)0;
    int32_t **l_264 = &l_263;
    int32_t l_266 = (-6L);
    int32_t *l_265 = &l_266;
    int32_t *l_267 = (void*)0;
    (*l_264) = l_263;
    l_265 = ((*l_264) = (void*)0);
    return l_267;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_98(int32_t *** p_99, int64_t  p_100, uint64_t  p_101)
{ /* block id: 115 */
    int32_t *l_248 = (void*)0;
    int32_t **l_247 = &l_248;
    int32_t ***l_246 = &l_247;
    int32_t l_257 = 0xFD110C5EL;
    int32_t *l_258 = (void*)0;
    int32_t l_260 = (-6L);
    int32_t *l_259 = &l_260;
    int32_t **l_261 = &l_248;
    int32_t **l_262 = (void*)0;
    p_99 = l_246;
    if (p_101)
    { /* block id: 117 */
        int32_t l_250 = 0x48D9708BL;
        int32_t *l_249 = &l_250;
        (*l_249) = (p_100 > p_100);
    }
    else
    { /* block id: 119 */
        int32_t l_252 = 0x519D29D4L;
        int32_t *l_251 = &l_252;
        float l_254 = 0x5.5807E8p-88;
        float *l_253 = &l_254;
        (**p_99) = (*l_247);
        l_251 = (**l_246);
        (*l_253) = p_101;
    }
    (*l_259) = (safe_div_func_int32_t_s_s((l_257 = l_257), p_100));
    (**p_99) = (**p_99);
    return l_262;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_102(struct S1  p_103, uint16_t  p_104, int64_t  p_105, int32_t *** p_106)
{ /* block id: 101 */
    uint32_t l_235 = 0x20E94A99L;
    int32_t l_238 = 0xC20038BEL;
    int32_t l_243 = 0x286A1EBDL;
    for (p_105 = 0; (p_105 == (-17)); p_105 = safe_sub_func_int64_t_s_s(p_105, 1))
    { /* block id: 104 */
        uint32_t l_223 = 4294967295UL;
        int16_t l_237 = (-6L);
        int16_t *l_236 = &l_237;
        int32_t *l_239 = &l_238;
        struct S1 l_241 = {-754,-0x2.5p-1};
        struct S1 *l_240 = &l_241;
        uint32_t l_242 = 0UL;
        float *l_244 = &l_241.f1;
        (*l_240) = func_107(((((__builtin_parityll(p_103.f0) >= (!l_223)) & (safe_sub_func_int32_t_s_s((~(((((*l_239) = (safe_add_func_int32_t_s_s((l_235 = (safe_div_func_uint64_t_u_u((safe_unary_minus_func_uint64_t_u(1UL)), (p_103.f0 ^ ((safe_rshift_func_uint16_t_u_s((safe_unary_minus_func_int32_t_s(2L)), 4)) > 1UL))))), (((*l_236) = (0x563820F02422DCD2LL && p_105)) || l_238)))) | p_105) > p_105) != p_103.f0)), p_105))) & p_104) >= p_103.f0));
        l_243 = ((*l_239) = __builtin_parity(l_242));
        (*l_244) = (-0x10.Fp+1);
    }
    return p_106;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_107(uint32_t  p_108)
{ /* block id: 61 */
    int32_t l_134 = (-1L);
    int32_t *l_133 = &l_134;
    int32_t **l_132 = &l_133;
    int32_t ***l_131 = &l_132;
    int32_t ****l_135 = &l_131;
    int32_t ***l_137 = &l_132;
    int32_t ****l_136 = &l_137;
    uint64_t l_146 = 5UL;
    uint64_t *l_145 = &l_146;
    int64_t l_201 = 1L;
    uint32_t l_202 = 0x5718CB29L;
    struct S0 l_213 = {0x3.33A66Ap-28,-0x3.Ep+1,18446744073709551610UL};
    const struct S0 *l_212 = &l_213;
    struct S1 l_217 = {328,0xC.142B0Cp+60};
    (*l_136) = ((*l_135) = l_131);
    if (((safe_unary_minus_func_uint64_t_u((safe_rshift_func_int16_t_s_u((-1L), 7)))) >= (safe_lshift_func_int16_t_s_s(((*l_136) == (void*)0), ((safe_lshift_func_int16_t_s_s((***l_131), ((***l_137) < p_108))) < (l_145 == &l_146))))))
    { /* block id: 64 */
        int32_t l_153 = (-1L);
        for (p_108 = 0; (p_108 > 35); p_108 = safe_add_func_int32_t_s_s(p_108, 1))
        { /* block id: 67 */
            float l_156 = 0x3.116ABEp-86;
            int32_t l_157 = 1L;
            uint64_t **l_160 = &l_145;
            const uint64_t l_164 = 18446744073709551615UL;
            const uint64_t *l_163 = &l_164;
            const uint64_t **l_162 = &l_163;
            const uint64_t ***l_161 = &l_162;
            float *l_171 = &l_156;
            float l_173 = (-0x4.4p+1);
            float *l_172 = &l_173;
            (****l_135) = (safe_add_func_float_f_f(((safe_div_func_float_f_f(l_153, p_108)) > (safe_sub_func_float_f_f((__builtin_ctzll(l_157) < ((*l_172) = (safe_add_func_float_f_f(p_108, ((((*l_161) = l_160) != &l_145) == ((*l_171) = ((safe_div_func_float_f_f(((safe_div_func_float_f_f((safe_sub_func_float_f_f(p_108, p_108)), 0x1.BB6FCEp-15)) == p_108), (***l_131))) == l_164))))))), p_108))), l_153));
        }
    }
    else
    { /* block id: 73 */
        int32_t ***l_174 = (void*)0;
        int64_t *l_179 = (void*)0;
        int64_t l_181 = 0x040F3C6490BB395FLL;
        int64_t *l_180 = &l_181;
        uint32_t *l_188 = (void*)0;
        uint32_t l_190 = 4294967290UL;
        uint32_t *l_189 = &l_190;
        uint32_t *l_191 = (void*)0;
        uint32_t l_193 = 0x8EE533B9L;
        uint32_t *l_192 = &l_193;
        int32_t l_194 = 7L;
        const struct S0 l_211 = {0x0.5p-1,0xA.F6F4DFp-62,0x48D72D27L};
        const struct S0 *l_210 = &l_211;
        struct S1 l_214 = {-125,0x0.Bp-1};
        (*l_136) = l_174;
        (**l_132) = ((safe_div_func_uint16_t_u_u(0x0DA5L, p_108)) < (((void*)0 == &l_145) ^ (safe_div_func_uint64_t_u_u(18446744073709551609UL, ((*l_180) = p_108)))));
        (***l_135) = (**l_131);
        if ((safe_sub_func_int16_t_s_s((0x7B59L || __builtin_bswap64(p_108)), ((l_194 = ((*l_192) = (safe_div_func_int32_t_s_s(__builtin_ctzll(p_108), ((*l_189) = (safe_div_func_int64_t_s_s(p_108, (4294967292UL & p_108)))))))) & ((safe_sub_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(__builtin_popcount((0x7ADE520EL | 0L)), 3)), l_201)), p_108)) <= 0x3C35L)))))
        { /* block id: 81 */
            (***l_131) = l_202;
            for (l_193 = 0; (l_193 == 10); l_193 = safe_add_func_uint16_t_u_u(l_193, 5))
            { /* block id: 85 */
                struct S1 l_205 = {803,0x2.Ap+1};
                if (p_108)
                    break;
                return l_205;
            }
            if ((~(**l_132)))
            { /* block id: 89 */
                int32_t *l_207 = &l_194;
                struct S1 l_208 = {1423,0x1.9CFF13p+84};
                struct S1 *l_209 = &l_208;
                (**l_131) = l_207;
                (*l_209) = l_208;
                l_212 = l_210;
            }
            else
            { /* block id: 93 */
                return l_214;
            }
        }
        else
        { /* block id: 96 */
            float *l_215 = (void*)0;
            float *l_216 = &l_214.f1;
            (*l_216) = 0x0.9p-1;
        }
    }
    return l_217;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 177
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 12
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 4

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 166
   depth: 2, occurrence: 27
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 4
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 248

XXX times a variable address is taken: 213
XXX times a pointer is dereferenced on RHS: 93
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 21
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 145
breakdown:
   depth: 1, occurrence: 131
   depth: 2, occurrence: 10
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 648

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 470
   level: 2, occurrence: 142
   level: 3, occurrence: 71
   level: 4, occurrence: 10
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 101
XXX number of pointers point to scalars: 123
XXX number of pointers point to structs: 24
XXX percent of pointers has null in alias set: 30.6
XXX average alias set size: 1.19

XXX times a non-volatile is read: 634
XXX times a non-volatile is write: 380
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 33
   depth: 2, occurrence: 24
   depth: 3, occurrence: 20
   depth: 4, occurrence: 17
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 20.2
XXX percentage an existing variable is used: 79.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

