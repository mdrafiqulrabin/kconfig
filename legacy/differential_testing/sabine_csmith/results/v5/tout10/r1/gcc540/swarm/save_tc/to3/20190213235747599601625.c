/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --comma-operators --no-argc --bitfields --no-arrays --pointers --structs --no-unions --no-packed-struct --no-divs --muls --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-longlong --float --jumps --volatiles --no-compound-assignment --no-consts --no-inline-function --volatile-pointers --const-pointers --no-global-variables --no-builtins --no-int8 --uint8
 * Seed:      2438941944
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static float  func_3(int16_t  p_4);
static int32_t * func_5(int32_t * p_6, int32_t  p_7, int32_t * p_8, int32_t * p_9, int32_t * p_10);
static int32_t * func_11(uint8_t  p_12, int32_t * p_13, uint32_t  p_14, int32_t * p_15);
static int32_t  func_18(int32_t * p_19, int16_t  p_20);
static int32_t  func_23(int32_t * p_24, uint32_t  p_25, int32_t * p_26);
static int32_t * func_27(int16_t  p_28, float  p_29);
static uint16_t  func_31(int32_t  p_32);
static int32_t * func_35(int32_t * p_36, uint16_t  p_37, uint16_t  p_38, uint32_t  p_39, int32_t * p_40);
static int32_t * func_41(int32_t * p_42, uint16_t  p_43, int32_t * p_44);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_2 = 1U;
    float l_492 = 0x2.4F21E3p-73;
    float *l_491 = &l_492;
    (*l_491) = (l_2 == func_3(l_2));
    return l_2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_3(int16_t  p_4)
{ /* block id: 1 */
    int32_t l_22 = 0xC80FC3A0;
    int32_t *l_21 = &l_22;
    int32_t **l_260 = &l_21;
    int32_t ***l_259 = &l_260;
    int32_t ****l_258 = &l_259;
    int32_t ****l_261 = (void*)0;
    int32_t l_264 = (-3);
    int32_t *l_418 = &l_264;
    uint16_t l_481 = 0x720E;
    uint16_t *l_480 = &l_481;
    uint16_t **l_479 = &l_480;
    uint16_t ***l_478 = &l_479;
    uint16_t ***l_482 = &l_479;
    float *l_483 = (void*)0;
    float l_485 = (-0x10.3p+1);
    float *l_484 = &l_485;
    int32_t *l_486 = &l_22;
    (*l_260) = func_5(((***l_258) = func_11((p_4 < (safe_add_func_int32_t_s_s((0xB4C8 | (func_18(l_21, (*l_21)) , (safe_rshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s((p_4 && ((((((!((l_258 != l_261) < ((safe_add_func_int32_t_s_s(((****l_258) == p_4), 1)) & (***l_259)))) != p_4) == l_264) <= p_4) , p_4) > (**l_260))), 0x49F5)), p_4)))), p_4))), (**l_259), p_4, (*l_260))), p_4, l_418, &l_264, &l_264);
    (*l_484) = (l_478 == (l_482 = (void*)0));
    (***l_258) = l_486;
    for (l_481 = 21; (l_481 >= 11); --l_481)
    { /* block id: 225 */
        float l_489 = 0x0.Bp+1;
        int32_t l_490 = 0x2281E60A;
        if (p_4)
            break;
        (*l_21) = l_490;
        if ((**l_260))
            break;
    }
    return p_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_5(int32_t * p_6, int32_t  p_7, int32_t * p_8, int32_t * p_9, int32_t * p_10)
{ /* block id: 194 */
    int32_t l_420 = 0;
    int32_t *l_419 = &l_420;
    int32_t ****l_421 = (void*)0;
    int32_t *****l_422 = &l_421;
    int32_t **l_425 = &l_419;
    int32_t ***l_424 = &l_425;
    int32_t ****l_423 = &l_424;
    float *l_439 = (void*)0;
    float **l_438 = &l_439;
    float ***l_437 = &l_438;
    uint32_t l_472 = 0x7ABAD2AF;
    int32_t *l_477 = (void*)0;
    (***l_423) = func_35(l_419, ((void*)0 == l_419), ((((*l_422) = l_421) != l_423) || 65534U), p_7, func_35(((safe_sub_func_uint16_t_u_u(((safe_add_func_int32_t_s_s((*p_6), 0x6DBC43BF)) & p_7), (****l_423))) , &p_7), p_7, (*l_419), (***l_424), (**l_424)));
    l_422 = &l_421;
    for (l_420 = 0; (l_420 < 10); l_420 = safe_add_func_uint32_t_u_u(l_420, 2))
    { /* block id: 200 */
        int32_t l_434 = 9;
        float ***l_440 = &l_438;
        int32_t ****l_449 = &l_424;
        uint32_t l_461 = 0U;
        uint32_t *l_460 = &l_461;
        uint32_t **l_459 = &l_460;
    }
    return l_477;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_11(uint8_t  p_12, int32_t * p_13, uint32_t  p_14, int32_t * p_15)
{ /* block id: 106 */
    int32_t l_282 = 0;
    int32_t l_284 = 1;
    int16_t l_321 = 0xD36D;
    int16_t *l_320 = &l_321;
    int16_t **l_319 = &l_320;
    uint32_t l_358 = 0x7A7D8746;
    int16_t ***l_398 = &l_319;
    int16_t ****l_397 = &l_398;
    for (p_14 = (-12); (p_14 == 18); p_14 = safe_add_func_int32_t_s_s(p_14, 1))
    { /* block id: 109 */
        int16_t l_276 = 0x0841;
        int16_t *l_275 = &l_276;
        float l_283 = 0x5.5p+1;
        uint16_t l_286 = 65531U;
        uint16_t *l_285 = &l_286;
        int32_t l_288 = (-4);
        int32_t *l_287 = &l_288;
        int32_t l_324 = 0x7886D37C;
        uint16_t **l_328 = &l_285;
        uint16_t ***l_327 = &l_328;
        int32_t *l_336 = &l_324;
        uint32_t l_339 = 4294967288U;
        int32_t *l_341 = &l_288;
        int32_t *l_363 = &l_288;
        (*l_287) = (safe_lshift_func_uint16_t_u_u(((*l_285) = ((l_284 = ((*l_275) = (safe_add_func_int32_t_s_s((safe_unary_minus_func_int32_t_s((+(safe_add_func_uint16_t_u_u(p_14, (((void*)0 != l_275) != ((l_282 = (safe_sub_func_int16_t_s_s(1, ((safe_mul_func_uint16_t_u_u((((*p_15) = ((5 || (p_12 , (*p_13))) == (*p_15))) <= (~(p_14 <= 0xDFA4))), p_14)) >= l_276)))) | p_14))))))), l_284)))) <= p_12)), p_14));
        for (l_288 = (-1); (l_288 > (-24)); --l_288)
        { /* block id: 118 */
            uint32_t l_293 = 5U;
            int32_t l_294 = 0;
            int32_t l_312 = 2;
            uint8_t l_333 = 0xDC;
            float *l_349 = &l_283;
            float **l_348 = &l_349;
            float ***l_347 = &l_348;
            float ****l_346 = &l_347;
            uint8_t l_379 = 0x38;
            uint16_t l_401 = 0x7CDB;
        }
    }
    for (p_12 = (-9); (p_12 < 36); p_12 = safe_add_func_uint32_t_u_u(p_12, 8))
    { /* block id: 189 */
        int16_t l_414 = 0x5BDF;
        float *l_415 = (void*)0;
        float l_417 = 0x4.5FD386p-61;
        float *l_416 = &l_417;
        (*l_416) = (((!l_321) >= l_358) <= (l_414 > p_12));
    }
    return p_15;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_18(int32_t * p_19, int16_t  p_20)
{ /* block id: 2 */
    uint32_t l_243 = 0x5BD8F16D;
    int32_t *l_244 = (void*)0;
    float l_247 = (-0x5.7p+1);
    float *l_246 = &l_247;
    (*p_19) = func_23(func_27(((*p_19) && (safe_unary_minus_func_uint16_t_u(func_31(p_20)))), p_20), ((safe_rshift_func_int16_t_s_u(((safe_lshift_func_uint16_t_u_u(((safe_mod_func_int32_t_s_s(((safe_add_func_float_f_f((0x3.7p+1 > 0xD.50D544p-80), ((((l_243 > (p_20 == p_20)) < l_243) > l_243) <= l_243))) , (-5)), p_20)) == l_243), 14)) <= 0xF118), l_243)) & l_243), l_244);
    (*l_246) = 0x5.7p+1;
    for (l_243 = 0; (l_243 <= 35); l_243 = safe_add_func_int32_t_s_s(l_243, 1))
    { /* block id: 101 */
        int32_t l_251 = 0x0C19E018;
        int32_t *l_250 = &l_251;
        int32_t **l_252 = &l_250;
        (*l_252) = l_250;
        (*l_252) = func_41(p_19, ((*l_250) , ((*l_250) , 0xB3C1)), l_246);
    }
    return l_243;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_23(int32_t * p_24, uint32_t  p_25, int32_t * p_26)
{ /* block id: 95 */
    uint8_t l_245 = 0x6C;
    return l_245;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_27(int16_t  p_28, float  p_29)
{ /* block id: 86 */
    int16_t l_228 = 0xF95C;
    int16_t *l_227 = &l_228;
    int16_t **l_226 = &l_227;
    int16_t ***l_225 = &l_226;
    int16_t ****l_229 = &l_225;
    int32_t *l_234 = (void*)0;
lbl_233:
    (*l_229) = l_225;
    for (l_228 = 0; (l_228 <= 26); l_228 = safe_add_func_uint32_t_u_u(l_228, 1))
    { /* block id: 90 */
        uint8_t l_232 = 255U;
        l_232 = 0x3.A69D0Dp-96;
    }
    if (l_228)
        goto lbl_233;
    return l_234;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_31(int32_t  p_32)
{ /* block id: 3 */
    int32_t l_51 = 0x638299FA;
    int32_t *l_50 = &l_51;
    int32_t **l_96 = &l_50;
    int32_t ***l_95 = &l_96;
    int32_t ****l_94 = &l_95;
    int16_t l_136 = (-6);
    int16_t *l_135 = &l_136;
    int32_t l_147 = 0xA964D50E;
    float l_183 = 0x6.8E2B3Dp+11;
    float *l_182 = &l_183;
    float **l_181 = &l_182;
    for (p_32 = (-18); (p_32 < (-1)); p_32 = safe_add_func_uint32_t_u_u(p_32, 9))
    { /* block id: 6 */
        int32_t l_46 = 0xAA08BBD1;
        int32_t *l_45 = &l_46;
        uint16_t l_53 = 0x77A1;
        uint16_t *l_52 = &l_53;
        int32_t **l_76 = (void*)0;
        int32_t **l_77 = &l_45;
        (*l_77) = func_35(func_41(l_45, (~((*l_52) = (safe_lshift_func_uint16_t_u_s(((void*)0 != l_50), 14)))), &l_51), p_32, p_32, ((safe_lshift_func_uint16_t_u_s(((p_32 , ((1 & p_32) , 8U)) & 0x6CBC8CA9), 9)) , 0xF39588DF), l_50);
        (**l_77) = (+(((**l_77) != (**l_77)) , (*l_45)));
    }
    for (l_51 = (-9); (l_51 != 0); l_51 = safe_add_func_int32_t_s_s(l_51, 1))
    { /* block id: 23 */
        int32_t **l_93 = &l_50;
        int32_t ***l_92 = &l_93;
        int32_t ****l_91 = &l_92;
        uint16_t l_98 = 0x8973;
        uint16_t *l_97 = &l_98;
        float l_151 = (-0x1.6p-1);
        float *l_150 = &l_151;
        float **l_149 = &l_150;
        float ***l_164 = &l_149;
        if ((*l_50))
            break;
        for (p_32 = 6; (p_32 >= (-9)); --p_32)
        { /* block id: 27 */
            uint16_t **l_99 = (void*)0;
            uint16_t *l_101 = &l_98;
            uint16_t **l_100 = &l_101;
            int32_t l_102 = 0x24A17051;
            int32_t l_104 = 0xCBFA339B;
            int32_t *l_103 = &l_104;
            float l_105 = 0x6.EF108Cp-12;
            uint32_t l_122 = 0x1CDA016E;
            float ***l_162 = &l_149;
            int32_t *l_221 = &l_147;
        }
    }
    for (l_136 = (-30); (l_136 > 26); ++l_136)
    { /* block id: 82 */
        int32_t l_224 = 0xB0853695;
        if (l_224)
            break;
    }
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(int32_t * p_36, uint16_t  p_37, uint16_t  p_38, uint32_t  p_39, int32_t * p_40)
{ /* block id: 16 */
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(int32_t * p_42, uint16_t  p_43, int32_t * p_44)
{ /* block id: 8 */
    uint32_t l_62 = 4294967295U;
    int32_t l_66 = (-1);
    int32_t *l_65 = &l_66;
    int32_t **l_67 = &l_65;
    int32_t *l_71 = &l_66;
    int32_t **l_70 = &l_71;
    int32_t ***l_73 = &l_70;
    int32_t ****l_72 = &l_73;
    (*l_67) = ((safe_add_func_int32_t_s_s(((0U == 0x2F093D7F) > (((*p_44) = ((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(1U, (safe_add_func_int32_t_s_s(l_62, (-1))))), 11)) | (((p_43 >= (((safe_mod_func_int16_t_s_s(0xA932, p_43)) == (((void*)0 != p_42) > (-1))) && (-1))) , p_44) == l_65))) >= (*l_65))), (*l_65))) , p_44);
    (*l_65) = (safe_add_func_int16_t_s_s((**l_67), (((*l_70) = (*l_67)) != (*l_67))));
    (*l_72) = &l_67;
    (*l_67) = p_42;
    return p_42;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 103
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 154

XXX times a variable address is taken: 145
XXX times a pointer is dereferenced on RHS: 110
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 24
   depth: 3, occurrence: 10
   depth: 4, occurrence: 17
XXX times a pointer is dereferenced on LHS: 88
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 7
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 309

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 194
   level: 2, occurrence: 52
   level: 3, occurrence: 34
   level: 4, occurrence: 36
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 78
XXX number of pointers point to scalars: 76
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20.1
XXX average alias set size: 1.28

XXX times a non-volatile is read: 650
XXX times a non-volatile is write: 241
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 47
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 14

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
********************* end of statistics **********************/

