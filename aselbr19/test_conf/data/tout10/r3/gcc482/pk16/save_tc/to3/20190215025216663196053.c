/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --comma-operators --no-argc --bitfields --no-arrays --pointers --structs --no-unions --no-packed-struct --no-divs --no-muls --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-longlong --float --jumps --no-volatiles --compound-assignment --no-consts --inline-function --no-volatile-pointers --no-const-pointers --builtins --no-int8 --no-uint8
 * Seed:      534274112
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   float  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint16_t  f4;
   int32_t  f5;
   int32_t  f6;
};

struct S1 {
   unsigned f0 : 11;
   uint32_t  f1;
   int16_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static float g_5 = 0xE.B3921Dp+30;
static int32_t g_6 = 0;
static int32_t g_30 = 8;
static int32_t *g_71 = &g_30;
static int32_t **g_70 = &g_71;
static int32_t g_84 = 0x45435D7D;
static int16_t g_88 = 0x20EA;
static int32_t g_91 = 0xA0F0C0ED;
static float *g_96 = &g_5;
static float **g_95 = &g_96;
static int32_t **g_105 = &g_71;
static int32_t ***g_104 = &g_105;
static struct S1 *g_138 = (void*)0;
static int32_t g_142 = 1;
static uint16_t g_159 = 65533U;
static struct S0 g_164 = {0x5.2p-1,0xC045D86B,0x6617F50B,0x85FA8931,65534U,0,0x09CA3844};
static struct S0 *g_224 = &g_164;
static int32_t g_245 = 0xC09D1445;
static float ***g_280 = &g_95;
static struct S1 g_323 = {25,0xD5BF0DDE,1};
static float ****g_334 = &g_280;
static float g_416 = (-0x1.Fp-1);
static uint32_t g_469 = 3U;
static float ***g_509 = (void*)0;
static int32_t g_529 = (-7);
static int64_t g_621 = 1;
static float g_654 = (-0x8.8p-1);
static uint32_t g_690 = 9U;
static int64_t ***g_745 = (void*)0;
static uint16_t g_754 = 65533U;
static struct S1 g_776 = {3,0xD83BC5D9,0x09A5};
static uint32_t g_793 = 0x3BF149A4;
static struct S1 **g_797 = &g_138;
static struct S1 ***g_796 = &g_797;
static uint32_t *g_816 = &g_776.f1;
static uint32_t **g_815 = &g_816;
static uint32_t ***g_814 = &g_815;
static int32_t *g_862 = &g_164.f2;
static uint64_t g_952 = 4294967295U;
static uint32_t g_970 = 0x2C3FD18F;
static int16_t ****g_1004 = (void*)0;
static int64_t *g_1021 = &g_621;
static int64_t **g_1020 = &g_1021;
static int16_t **g_1059 = (void*)0;
static int16_t ***g_1058 = &g_1059;
static int64_t g_1062 = 0x5997E65D50E8C33CLL;
static uint32_t g_1078 = 0x75AC33AC;
static int32_t g_1102 = 0x7AC1AC90;
static int32_t **g_1158 = &g_71;
static uint16_t g_1165 = 0x90EB;


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_26(void);
static struct S0  func_32(int32_t * p_33, float  p_34, int32_t * p_35, uint32_t  p_36, int32_t ** p_37);
inline static int32_t * func_38(uint32_t  p_39, int32_t * p_40, int32_t * p_41, int32_t * p_42, int32_t  p_43);
static int32_t  func_46(uint32_t  p_47, uint16_t  p_48, struct S1  p_49, int32_t ** p_50);
static uint32_t  func_51(int32_t * p_52, int32_t ** p_53, uint32_t  p_54, int32_t * p_55, int32_t * p_56);
static int32_t * func_57(int32_t ** p_58, struct S1  p_59, int32_t * p_60, float  p_61, int32_t ** p_62);
inline static struct S1  func_64(int32_t ** p_65, int32_t ** p_66, float  p_67, float  p_68, int32_t * p_69);
inline static int32_t ** func_73(int32_t *** p_74);
static int32_t *** func_75(int32_t ** p_76, int32_t ** p_77, int32_t  p_78);
static int32_t ** func_79(int32_t ** p_80, float  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_1062
 * writes: g_6 g_1062
 */
inline static struct S0  func_26(void)
{ /* block id: 36 */
    int32_t **l_94 = &g_71;
    int32_t l_530 = 0x75822D8E;
    int32_t l_531 = 0xF5CA1866;
    uint32_t l_775 = 6U;
    uint32_t l_876 = 0x71410287;
    int32_t **l_961 = &g_71;
    struct S1 **l_995 = (void*)0;
    uint32_t l_1035 = 0x6A667679;
    uint32_t l_1042 = 0xB5E78202;
    uint32_t l_1048 = 0x6C764D73;
    int16_t ****l_1063 = &g_1058;
    int32_t **l_1093 = &g_862;
    int32_t l_1126 = 0;
    float l_1145 = 0x0.5p-1;
    struct S1 l_1159 = {12,0U,0xEF15};
    struct S0 l_1168 = {0xA.A87AFDp-60,0xC8493559,1,-1,65535U,-2,-3};
    for (g_6 = 0; (g_6 != (-14)); g_6 = safe_sub_func_uint16_t_u_u(g_6, 1))
    { /* block id: 39 */
        int32_t *l_29 = &g_30;
        int32_t **l_31 = &l_29;
        int32_t ***l_63 = (void*)0;
        int32_t ***l_72 = &g_70;
        int32_t ****l_456 = &g_104;
        uint16_t l_603 = 0x1389;
        struct S1 l_918 = {41,0x039CBAF8,0};
        float *l_950 = &g_654;
        struct S1 **l_997 = &g_138;
        int32_t **l_1049 = &l_29;
        float ****l_1050 = &g_280;
        int32_t l_1057 = 0x143DEE84;
        int16_t ***l_1060 = &g_1059;
        float l_1070 = 0x0.3p+1;
        (*l_31) = l_29;
    }
    for (g_1062 = (-8); (g_1062 > 10); g_1062 = safe_add_func_uint32_t_u_u(g_1062, 1))
    { /* block id: 898 */
        int32_t *l_1160 = &l_530;
        int32_t *l_1162 = &g_245;
        int32_t l_1166 = 0x646AD36D;
    }
    return l_1168;
}


/* ------------------------------------------ */
/* 
 * reads : g_224 g_164 g_754 g_776.f1 g_84 g_816 g_814 g_815 g_6 g_862 g_469 g_159 g_245
 * writes: g_88 g_84 g_776.f1 g_469 g_164.f2 g_245
 */
static struct S0  func_32(int32_t * p_33, float  p_34, int32_t * p_35, uint32_t  p_36, int32_t ** p_37)
{ /* block id: 690 */
    int64_t *l_879 = &g_621;
    uint16_t l_880 = 0xFEFD;
    uint16_t *l_883 = &l_880;
    int32_t l_886 = 0x72817B4F;
    int16_t *l_887 = &g_88;
    int32_t l_888 = (-1);
    struct S0 l_907 = {0x3.ED6A18p-70,0xE00128AC,0x10FC2DB7,-6,0xFBC1,1,0};
    struct S1 **l_910 = (void*)0;
    (*p_35) |= (safe_mod_func_uint32_t_u_u((((&g_621 != l_879) & (l_886 = (l_880 || ((safe_add_func_int16_t_s_s((0x3F371066 >= (((*l_883) = l_880) && (4294967295U <= l_880))), (((0U < ((*l_887) = (safe_sub_func_uint16_t_u_u(((*g_224) , 0xFA93), l_886)))) ^ l_888) > 65535U))) , g_754)))) < g_776.f1), 4294967290U));
    if (l_880)
    { /* block id: 695 */
        for (g_84 = 0; (g_84 <= 23); g_84 = safe_add_func_uint16_t_u_u(g_84, 1))
        { /* block id: 698 */
            return (*g_224);
        }
    }
    else
    { /* block id: 701 */
        int16_t **l_898 = (void*)0;
        int16_t **l_899 = &l_887;
        int32_t l_900 = 1;
        int32_t *l_903 = &g_164.f6;
        struct S1 l_904 = {40,4294967295U,0x7EF4};
        uint32_t *l_905 = &g_469;
        struct S0 l_906 = {0x9.5E07FAp-65,0x841F0598,0,0x7ABB0528,65535U,-1,-3};
lbl_911:
        l_907 = (((*l_905) |= (((***g_814) = (*g_816)) >= (p_36 >= ((__builtin_clzll(((safe_lshift_func_uint16_t_u_u(__builtin_clz(p_36), __builtin_ctz(((((safe_sub_func_uint32_t_u_u((((!(safe_lshift_func_int16_t_s_s(((((*l_899) = &g_88) != l_883) <= l_900), (l_904.f1 | 8U)))) ^ p_36) <= 0xEF6C42C9), (**p_37))) , 8U) != (*g_862)) <= l_888)))) & 0x2110)) & p_36) == p_36)))) , l_906);
        (**p_37) = (safe_add_func_int32_t_s_s((((p_36 || g_159) , l_907.f2) < p_36), p_36));
        if (l_906.f6)
            goto lbl_911;
    }
    return (*g_224);
}


/* ------------------------------------------ */
/* 
 * reads : g_142 g_164.f3 g_104 g_105 g_793 g_280 g_95 g_71 g_621 g_469 g_164.f5 g_164.f4 g_88 g_70 g_797 g_138 g_796 g_323.f1 g_159 g_814 g_754 g_30 g_96 g_5 g_815 g_816 g_776.f1 g_334 g_529 g_323 g_862 g_164.f2
 * writes: g_138 g_159 g_796 g_164.f4 g_88 g_323.f1 g_469 g_71 g_142 g_30 g_776.f1 g_280 g_5 g_529 g_323 g_164.f2
 */
inline static int32_t * func_38(uint32_t  p_39, int32_t * p_40, int32_t * p_41, int32_t * p_42, int32_t  p_43)
{ /* block id: 584 */
    struct S1 *l_784 = &g_323;
    struct S1 **l_785 = &g_138;
    int32_t l_795 = 0xAA319762;
    int16_t *l_799 = (void*)0;
    int16_t *l_801 = &g_88;
    struct S0 l_802 = {0x2.85D29Ep+99,0x110FF960,-1,0x6DA54FC3,0xB966,0xB01CEB84,-1};
    float ***l_826 = (void*)0;
    int32_t l_828 = (-4);
    int64_t *l_858 = &g_621;
    int32_t ***l_863 = &g_105;
    (*l_785) = l_784;
    if ((*p_42))
    { /* block id: 586 */
        uint32_t *l_787 = &g_323.f1;
        uint32_t **l_786 = &l_787;
        uint32_t ***l_788 = &l_786;
        float **l_794 = (void*)0;
        uint16_t *l_798 = &g_164.f4;
        int16_t **l_800 = &l_799;
        uint32_t l_803 = 0U;
        struct S0 l_811 = {0x9.F1F201p+28,0x501150BD,-1,0xCAEAAD01,0U,-4,0xFBDBBB19};
        (*l_788) = l_786;
        (*p_41) |= (safe_sub_func_uint32_t_u_u(p_43, (g_164.f3 >= (safe_mod_func_int16_t_s_s(func_51(p_41, (*g_104), ((g_793 , (l_794 == (*g_280))) >= l_795), &l_795, (**g_104)), p_43)))));
        g_796 = &l_785;
        if (((g_469 != (((*l_787) = (0x8C9FB058 < (((*l_801) &= (((**g_105) , ((*l_798) ^= 1U)) ^ ((((*l_800) = l_799) == l_801) != ((g_469 != p_43) , ((l_802 , l_803) >= p_39))))) & p_39))) <= g_142)) > 7U))
        { /* block id: 594 */
            return p_42;
        }
        else
        { /* block id: 596 */
            int32_t l_806 = (-7);
            struct S0 l_810 = {0x6.Fp+1,-8,0x84773549,-1,0U,7,1};
            float *l_849 = (void*)0;
            for (g_469 = 17; (g_469 < 7); g_469 = safe_sub_func_int16_t_s_s(g_469, 1))
            { /* block id: 599 */
                struct S1 *l_807 = &g_776;
                (*g_70) = (void*)0;
                if ((*p_41))
                    break;
                if (l_806)
                    continue;
                l_807 = ((**g_796) = (*g_797));
            }
            for (g_323.f1 = 0; (g_323.f1 > 25); g_323.f1 = safe_add_func_uint32_t_u_u(g_323.f1, 1))
            { /* block id: 608 */
                float l_848 = 0xA.595A4Ap-98;
                l_811 = l_810;
                for (l_811.f5 = 17; (l_811.f5 > (-18)); l_811.f5 = safe_sub_func_uint32_t_u_u(l_811.f5, 8))
                { /* block id: 612 */
                    uint32_t ****l_817 = &l_788;
                    float ***l_825 = &g_95;
                    if (l_810.f1)
                        break;
                    (*l_817) = ((g_164.f4 || (l_795 ^ g_159)) , g_814);
                    if (l_811.f1)
                    { /* block id: 615 */
                        uint32_t *l_818 = &g_469;
                        (*p_42) ^= (((*l_818) = g_88) , (0xEEED ^ g_754));
                        (**g_104) = p_40;
                        (*p_40) &= (*p_42);
                        (***g_104) ^= l_811.f1;
                    }
                    else
                    { /* block id: 621 */
                        uint16_t l_827 = 0x9355;
                        l_828 = ((*g_96) >= (((safe_mod_func_uint32_t_u_u((***g_814), (*p_40))) , ((***g_814) = p_39)) , (safe_sub_func_float_f_f(p_43, (((safe_sub_func_float_f_f((&l_794 == ((*g_334) = l_825)), ((l_825 == l_826) == l_827))) , 65535U) , p_39)))));
                        (*g_105) = p_41;
                        (***g_280) = ((****g_334) == ((safe_sub_func_float_f_f((((((**g_815) == (safe_mod_func_int32_t_s_s(((*p_42) &= l_810.f4), ((p_43 == l_810.f2) && g_164.f3)))) , ((l_802.f2 == (safe_add_func_float_f_f((safe_sub_func_float_f_f(0x0.0p+1, (safe_add_func_float_f_f((****g_334), 0xB.3D2609p-29)))), (-0x1.4p+1)))) != p_39)) == l_802.f4) == p_43), 0x6.482602p-60)) <= p_39));
                    }
                }
                for (g_469 = 0; (g_469 != 12); g_469 = safe_add_func_uint32_t_u_u(g_469, 2))
                { /* block id: 632 */
                    struct S0 l_841 = {0x5.B1E06Ep-18,0x05D30FE7,7,1,65534U,0xA3BFABFC,0xF5C69347};
                    if (l_810.f1)
                    { /* block id: 633 */
                        (*p_40) = ((*p_41) = ((*p_42) &= l_811.f2));
                        l_811.f2 = (*g_96);
                        if ((*p_41))
                            break;
                        l_841 = l_841;
                    }
                    else
                    { /* block id: 640 */
                        int16_t ***l_843 = (void*)0;
                        int16_t ****l_842 = &l_843;
                        (***g_280) = (-0x8.7p+1);
                        (*l_842) = &l_800;
                    }
                    for (l_795 = 0; (l_795 <= 8); l_795 = safe_add_func_int32_t_s_s(l_795, 8))
                    { /* block id: 646 */
                        (*p_41) &= 0x48B0DD09;
                    }
                    for (l_811.f3 = (-6); (l_811.f3 <= (-3)); l_811.f3 = safe_add_func_int32_t_s_s(l_811.f3, 4))
                    { /* block id: 651 */
                        if ((*p_40))
                            break;
                        if (l_806)
                            continue;
                        (*g_105) = (**g_104);
                    }
                }
            }
            l_811.f5 = ((****g_334) = l_806);
        }
    }
    else
    { /* block id: 661 */
        return (*g_70);
    }
    for (g_529 = 0; (g_529 <= (-3)); g_529 = safe_sub_func_int16_t_s_s(g_529, 3))
    { /* block id: 666 */
        uint16_t l_853 = 0x94F2;
        struct S1 l_865 = {22,4294967292U,0xD4F6};
        int32_t **l_866 = &g_71;
        int64_t **l_867 = &l_858;
        struct S0 l_872 = {0x4.609CB5p+42,1,0x31E439D7,-2,0x84E9,0x6A629B83,0};
        (*g_105) = (**g_104);
        l_802.f5 = (****g_334);
        if ((((**l_785) = (***g_796)) , (((g_142 < (&g_797 == (void*)0)) , (~l_853)) , (*p_41))))
        { /* block id: 670 */
            int32_t l_861 = 0x6BD91148;
            uint32_t l_864 = 0x90C86521;
            int64_t **l_868 = &l_858;
            (**l_863) = p_42;
            l_868 = l_867;
            (*g_862) |= (safe_lshift_func_int16_t_s_u(((l_861 <= 0xF88A5DE6) ^ (**l_866)), p_43));
            return p_42;
        }
        else
        { /* block id: 679 */
            struct S0 l_871 = {0x1.0p+1,0xF5081418,0x52C0D390,0x6C625493,0U,0x2FB35020,0x8B052276};
            l_872 = l_871;
        }
        for (l_872.f1 = 0; (l_872.f1 <= 17); l_872.f1 = safe_add_func_uint16_t_u_u(l_872.f1, 4))
        { /* block id: 684 */
            uint32_t l_875 = 0U;
            (*g_862) ^= (*p_42);
            (*g_862) &= (l_875 | ((((((*l_863) == &p_40) , (*p_40)) , l_802) , (void*)0) == (void*)0));
        }
    }
    return (**l_863);
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_71 g_164.f5 g_70 g_690 g_105 g_164.f2
 * writes: g_91 g_71 g_164.f5 g_690 g_164.f2
 */
static int32_t  func_46(uint32_t  p_47, uint16_t  p_48, struct S1  p_49, int32_t ** p_50)
{ /* block id: 561 */
    uint32_t l_779 = 1U;
    for (g_91 = 0; (g_91 <= 14); g_91 = safe_add_func_uint16_t_u_u(g_91, 1))
    { /* block id: 564 */
        return (**p_50);
    }
    if (l_779)
    { /* block id: 567 */
        (*g_70) = (*p_50);
        (**g_70) |= 0;
    }
    else
    { /* block id: 570 */
        for (g_690 = (-19); (g_690 < 11); g_690 = safe_add_func_int16_t_s_s(g_690, 1))
        { /* block id: 573 */
            for (g_91 = (-25); (g_91 < 15); g_91 = safe_add_func_uint16_t_u_u(g_91, 1))
            { /* block id: 576 */
                if ((**p_50))
                    break;
            }
            if ((**g_70))
                break;
        }
    }
    (*g_105) = (*g_70);
    return (**g_105);
}


/* ------------------------------------------ */
/* 
 * reads : g_159 g_621
 * writes: g_159
 */
static uint32_t  func_51(int32_t * p_52, int32_t ** p_53, uint32_t  p_54, int32_t * p_55, int32_t * p_56)
{ /* block id: 443 */
    int16_t l_619 = (-1);
    uint16_t l_628 = 9U;
    int64_t *l_633 = &g_621;
    uint32_t *l_652 = &g_323.f1;
    int32_t l_714 = 0x9A0DE9C7;
    float **l_727 = &g_96;
    int32_t l_735 = 0xCDC86EF9;
    for (g_159 = 0; (g_159 > 53); g_159 = safe_add_func_uint32_t_u_u(g_159, 1))
    { /* block id: 446 */
        float ****l_607 = &g_280;
        int32_t l_618 = (-1);
        int64_t *l_620 = &g_621;
        int32_t *l_622 = &g_164.f6;
        int32_t ***l_627 = &g_70;
        uint32_t l_641 = 6U;
        struct S1 l_658 = {9,0U,-1};
        float l_769 = (-0x2.9p-1);
    }
    return g_621;
}


/* ------------------------------------------ */
/* 
 * reads : g_104 g_105 g_71 g_164.f5 g_323.f1 g_862 g_164.f2
 * writes: g_164.f5 g_323.f1 g_71 g_164.f2 g_862
 */
static int32_t * func_57(int32_t ** p_58, struct S1  p_59, int32_t * p_60, float  p_61, int32_t ** p_62)
{ /* block id: 432 */
    int32_t *l_599 = (void*)0;
    (**p_62) = (***g_104);
    if (g_164.f5)
        goto lbl_600;
lbl_600:
    l_599 = l_599;
    (**p_62) |= 1;
    for (g_323.f1 = 0; (g_323.f1 <= 16); g_323.f1 = safe_add_func_int32_t_s_s(g_323.f1, 1))
    { /* block id: 439 */
        (*p_62) = (*g_105);
    }
    return (*p_62);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_164.f5 g_164.f3 g_164.f4 g_323.f1 g_159 g_138 g_529 g_323 g_334 g_280 g_95 g_96 g_5 g_105 g_142 g_104 g_91 g_245 g_30 g_164.f1 g_164.f2
 * writes: g_71 g_164.f4 g_323.f1 g_164.f5 g_529 g_164.f1 g_5 g_245 g_95 g_70 g_104
 */
inline static struct S1  func_64(int32_t ** p_65, int32_t ** p_66, float  p_67, float  p_68, int32_t * p_69)
{ /* block id: 395 */
    int32_t *l_532 = &g_164.f5;
    int32_t l_535 = 0x6857043F;
    float *****l_542 = &g_334;
    struct S1 *l_553 = &g_323;
    struct S0 l_564 = {0xE.68C20Fp-16,0x2FC90116,0x4B60DB3B,0xBB48C1FA,9U,-5,2};
    int32_t ****l_588 = &g_104;
    uint32_t l_596 = 0xA7F45F28;
    (*p_65) = l_532;
    if ((**p_66))
    { /* block id: 397 */
        float l_543 = 0x5.4p-1;
        int32_t l_546 = (-9);
        uint32_t *l_551 = (void*)0;
        uint32_t *l_552 = &g_323.f1;
        int32_t *l_560 = &g_164.f3;
        uint32_t l_577 = 4294967295U;
        (*p_69) ^= (((((safe_add_func_int32_t_s_s(l_535, (((**p_66) = ((safe_lshift_func_uint16_t_u_s((safe_add_func_int32_t_s_s((safe_add_func_int16_t_s_s(((g_164.f4 ^= g_164.f3) && ((((void*)0 != l_542) || ((*l_532) >= (safe_sub_func_uint16_t_u_u(l_546, l_546)))) <= (safe_sub_func_int16_t_s_s((*l_532), ((safe_sub_func_uint32_t_u_u(((*l_552) ^= (*l_532)), 0x6B83DD4F)) , 65535U))))), (*l_532))), 0x2B3BF130)), l_546)) <= g_159)) < l_546))) || (*l_532)) , l_553) == g_138) ^ 1);
        for (l_546 = 0; (l_546 != (-21)); l_546 = safe_sub_func_int16_t_s_s(l_546, 7))
        { /* block id: 404 */
            uint32_t l_574 = 0xB7A54E82;
            float l_578 = 0xE.8CAD33p-78;
            int32_t l_579 = 1;
            for (g_164.f4 = 0; (g_164.f4 == 21); g_164.f4 = safe_add_func_uint16_t_u_u(g_164.f4, 1))
            { /* block id: 407 */
                return (*l_553);
            }
            for (g_164.f1 = 0; (g_164.f1 <= 18); g_164.f1 = safe_add_func_int16_t_s_s(g_164.f1, 3))
            { /* block id: 412 */
                uint32_t l_563 = 0U;
                l_560 = (*p_66);
                l_579 = (((*g_96) = (((****g_334) <= (p_68 <= ((((safe_lshift_func_int16_t_s_s(g_323.f0, l_563)) , l_564) , (*g_105)) == ((safe_rshift_func_uint16_t_u_u(((*l_560) , (safe_unary_minus_func_uint32_t_u(((safe_lshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u(l_574, (((safe_lshift_func_uint16_t_u_u(l_577, l_574)) && (*l_532)) || 0xEA1CE980))), 3)), g_323.f1)) || (*l_560))))), g_164.f5)) , (void*)0)))) >= l_563)) != (*l_532));
            }
            (*p_69) |= l_574;
        }
        (**g_95) = (*l_532);
        (*g_96) = (safe_add_func_float_f_f((0x9.6p-1 != (*l_560)), (((((~((((safe_sub_func_uint16_t_u_u(8U, ((*l_532) ^ g_142))) , ((*p_69) |= (safe_add_func_int16_t_s_s(((*l_560) & (!(*l_560))), (0x113F != (l_588 != (void*)0)))))) & (*g_71)) , (*l_560))) , 0x5.Ap+1) != (****l_588)) == (****g_334)) <= p_68)));
    }
    else
    { /* block id: 422 */
        uint16_t l_589 = 0xE40B;
        int32_t ***l_595 = &g_70;
        float *l_597 = (void*)0;
        int32_t l_598 = 0x28A4CDD3;
        (*p_65) = (*p_65);
        (*p_69) = __builtin_ctz(((l_589 ^ (((*l_532) <= (g_164.f3 ^ (((safe_lshift_func_uint16_t_u_s(((((p_67 = ((*g_96) = (((safe_add_func_float_f_f((p_68 = (((!((0xC.09CE1Dp+1 == (&p_66 == ((*l_588) = func_75((**l_588), ((*l_595) = func_73(func_75(func_73((l_589 , &p_65)), (**l_588), l_589))), g_164.f1)))) != p_67)) <= p_67) >= 0xD.068A80p+60)), p_67)) > 0xE.F423FFp+37) <= l_596))) , 0x6D2DC129) && 0xE7C021B5) < 0x3982), g_164.f2)) ^ l_598) & (*l_532)))) ^ g_164.f2)) , (*l_532)));
    }
    return (*l_553);
}


/* ------------------------------------------ */
/* 
 * reads : g_105 g_71 g_30 g_91 g_164.f4 g_245 g_323.f2 g_164.f5
 * writes: g_323.f1 g_164.f4 g_245 g_71
 */
inline static int32_t ** func_73(int32_t *** p_74)
{ /* block id: 348 */
    int16_t l_461 = 0x71DC;
    uint32_t *l_462 = &g_323.f1;
    int32_t *l_463 = (void*)0;
    int32_t *l_464 = &g_245;
    struct S0 l_465 = {0xA.78CE95p+22,0x2A08CD04,-9,0x4BD26459,0U,-2,0xD75C92E5};
    int32_t ****l_484 = &g_104;
    (*l_464) &= ((safe_add_func_int32_t_s_s((***p_74), ((*l_462) = (safe_mod_func_uint32_t_u_u(g_91, l_461))))) & (g_164.f4 &= l_461));
    if (((*l_464) = (((*l_464) == g_323.f2) && (l_465 , ((1U < ((*l_464) >= (-9))) || (g_30 < (((void*)0 == &l_465) != (***p_74))))))))
    { /* block id: 353 */
        return (*p_74);
    }
    else
    { /* block id: 355 */
        float l_466 = 0x9.4CD46Dp+16;
        int32_t l_467 = 0x25C8B556;
        uint32_t *l_468 = &g_469;
        int32_t l_471 = (-1);
        int16_t *l_472 = &g_323.f2;
        int32_t ***l_476 = &g_105;
        float **l_479 = (void*)0;
        int32_t **l_494 = &l_463;
        struct S0 l_498 = {0x8.4D6DA2p-64,0x80001A53,0x0ADA1600,0x4EE1541A,0x7F74,0,0x84B74016};
        float ****l_508 = (void*)0;
        uint16_t *l_512 = &l_498.f4;
        struct S1 l_513 = {6,0xB5CBB0CC,0x4700};
    }
    (*g_105) = (**p_74);
    return (*p_74);
}


/* ------------------------------------------ */
/* 
 * reads : g_95
 * writes: g_95
 */
static int32_t *** func_75(int32_t ** p_76, int32_t ** p_77, int32_t  p_78)
{ /* block id: 54 */
    float ***l_97 = &g_95;
    float **l_98 = &g_96;
    struct S0 l_101 = {0xE.B13122p-82,1,-5,0x5444FE37,4U,-1,-1};
    struct S1 l_115 = {6,0U,0xDB03};
    int32_t *l_153 = (void*)0;
    struct S1 l_190 = {31,0xA14961C1,-5};
    int32_t l_241 = 1;
    uint32_t l_258 = 4294967289U;
    int32_t ***l_264 = &g_105;
    uint16_t l_270 = 65535U;
    float l_272 = 0x7.A90DBDp-85;
    struct S0 **l_328 = &g_224;
    int32_t l_414 = 0x97AA9BFB;
    l_98 = ((*l_97) = g_95);
    return l_264;
}


/* ------------------------------------------ */
/* 
 * reads : g_84 g_91 g_71 g_30 g_164.f5 g_164.f2 g_862
 * writes: g_5 g_84 g_88 g_91
 */
static int32_t ** func_79(int32_t ** p_80, float  p_81)
{ /* block id: 43 */
    float l_82 = 0x9.FB1158p-96;
    float *l_83 = &g_5;
    int32_t **l_89 = &g_71;
    (*l_83) = l_82;
    for (g_84 = (-7); (g_84 <= 15); g_84 = safe_add_func_uint32_t_u_u(g_84, 3))
    { /* block id: 47 */
        int16_t *l_87 = &g_88;
        int32_t *l_90 = &g_91;
        struct S1 l_92 = {22,4294967295U,0x9538};
        struct S1 *l_93 = &l_92;
        (*l_90) ^= (((*l_87) = 0x5CD4) < (l_89 != (void*)0));
        if ((**p_80))
            continue;
        (*l_93) = l_92;
    }
    return &g_71;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc_bytes (&g_5, sizeof(g_5), "g_5", print_hash_value);
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    transparent_crc(g_84, "g_84", print_hash_value);
    transparent_crc(g_88, "g_88", print_hash_value);
    transparent_crc(g_91, "g_91", print_hash_value);
    transparent_crc(g_142, "g_142", print_hash_value);
    transparent_crc(g_159, "g_159", print_hash_value);
    transparent_crc_bytes (&g_164.f0, sizeof(g_164.f0), "g_164.f0", print_hash_value);
    transparent_crc(g_164.f1, "g_164.f1", print_hash_value);
    transparent_crc(g_164.f2, "g_164.f2", print_hash_value);
    transparent_crc(g_164.f3, "g_164.f3", print_hash_value);
    transparent_crc(g_164.f4, "g_164.f4", print_hash_value);
    transparent_crc(g_164.f5, "g_164.f5", print_hash_value);
    transparent_crc(g_164.f6, "g_164.f6", print_hash_value);
    transparent_crc(g_245, "g_245", print_hash_value);
    transparent_crc(g_323.f0, "g_323.f0", print_hash_value);
    transparent_crc(g_323.f1, "g_323.f1", print_hash_value);
    transparent_crc(g_323.f2, "g_323.f2", print_hash_value);
    transparent_crc_bytes (&g_416, sizeof(g_416), "g_416", print_hash_value);
    transparent_crc(g_469, "g_469", print_hash_value);
    transparent_crc(g_529, "g_529", print_hash_value);
    transparent_crc(g_621, "g_621", print_hash_value);
    transparent_crc_bytes (&g_654, sizeof(g_654), "g_654", print_hash_value);
    transparent_crc(g_690, "g_690", print_hash_value);
    transparent_crc(g_754, "g_754", print_hash_value);
    transparent_crc(g_776.f0, "g_776.f0", print_hash_value);
    transparent_crc(g_776.f1, "g_776.f1", print_hash_value);
    transparent_crc(g_776.f2, "g_776.f2", print_hash_value);
    transparent_crc(g_793, "g_793", print_hash_value);
    transparent_crc(g_952, "g_952", print_hash_value);
    transparent_crc(g_970, "g_970", print_hash_value);
    transparent_crc(g_1062, "g_1062", print_hash_value);
    transparent_crc(g_1078, "g_1078", print_hash_value);
    transparent_crc(g_1102, "g_1102", print_hash_value);
    transparent_crc(g_1165, "g_1165", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 291
   depth: 1, occurrence: 54
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 47
breakdown:
   indirect level: 0, occurrence: 34
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 7
XXX times a bitfields struct on RHS: 49
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 14

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 23
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 292

XXX times a variable address is taken: 286
XXX times a pointer is dereferenced on RHS: 374
breakdown:
   depth: 1, occurrence: 231
   depth: 2, occurrence: 93
   depth: 3, occurrence: 33
   depth: 4, occurrence: 17
XXX times a pointer is dereferenced on LHS: 339
breakdown:
   depth: 1, occurrence: 274
   depth: 2, occurrence: 39
   depth: 3, occurrence: 20
   depth: 4, occurrence: 6
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 1891

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1174
   level: 2, occurrence: 674
   level: 3, occurrence: 329
   level: 4, occurrence: 92
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 124
XXX number of pointers point to scalars: 147
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 21.9
XXX average alias set size: 1.31

XXX times a non-volatile is read: 1860
XXX times a non-volatile is write: 931
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 10

XXX stmts: 114
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 29
   depth: 2, occurrence: 17
   depth: 3, occurrence: 11
   depth: 4, occurrence: 6
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

