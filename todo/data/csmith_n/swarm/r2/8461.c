/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3788057504
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_4 = 0xE1265AB3L;
static int32_t g_10 = (-1L);
static int32_t g_47 = (-1L);
static int32_t g_70 = (-5L);
static int32_t *g_88 = &g_10;
static int32_t **g_87 = &g_88;
static int32_t g_130 = 0x4FC3DD16L;
static int32_t **g_267 = (void*)0;
static uint64_t g_282 = 1UL;
static int32_t *****g_480 = (void*)0;
static uint16_t g_506 = 0x7606L;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
inline static int32_t * func_2(uint8_t  p_3);
inline static int32_t  func_13(int32_t  p_14);
inline static int64_t  func_15(int32_t  p_16, int16_t  p_17, uint32_t  p_18);
static uint16_t  func_23(int32_t * p_24, uint32_t  p_25, int32_t * p_26, int32_t * p_27, int16_t  p_28);
inline static int32_t * func_29(int32_t  p_30, int32_t  p_31, int32_t * p_32);
inline static int32_t * func_33(int32_t * p_34, int32_t * p_35);
static int32_t * func_36(int64_t  p_37, uint32_t  p_38, uint8_t  p_39);
static uint16_t  func_40(uint8_t  p_41, uint16_t  p_42);
static uint8_t  func_43(uint32_t  p_44);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_10 g_47 g_70 g_87 g_88 g_130 g_282 g_506 g_480
 * writes: g_47 g_70 g_4 g_88 g_130 g_282 g_10
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_684 = (void*)0;
    l_684 = func_2((g_4 > (g_4 != ((int16_t)0xDED6L << (int16_t)0))));
    /* statement id: 292 */
    assert (l_684 == &g_10);
    (*g_88) = ((uint16_t)65535UL * (uint16_t)((((uint16_t)((g_506 || (1UL > ((int32_t)((uint16_t)(g_480 == (void*)0) + (uint16_t)g_10) % (int32_t)((uint16_t)(((int16_t)(0x8DFEA1CEL && 0UL) >> (int16_t)15) > (-(int64_t)((-10L) ^ (*l_684)))) << (uint16_t)14)))) == g_506) + (uint16_t)0x33EAL) > (-1L)) >= (*l_684)));
    (*g_88) = 0xFA85D347L;
    return g_70;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_4 g_47 g_70 g_87 g_88 g_130 g_282 g_506
 * writes: g_47 g_70 g_4 g_88 g_130 g_282 g_10
 */
inline static int32_t * func_2(uint8_t  p_3)
{ /* block id: 1 */
    int32_t *l_9 = &g_10;
    int32_t l_636 = 0x86064A47L;
    (*l_9) = ((uint16_t)(l_9 != l_9) * (uint16_t)((int32_t)func_13((func_15(((uint16_t)(*l_9) * (uint16_t)((-3L) & (((((uint16_t)g_10 >> (uint16_t)(((func_23(func_29(p_3, p_3, func_33(&g_10, l_9)), p_3, &g_10, l_9, g_282) != p_3) && 7L) && (-1L))) > (*l_9)) || 0x0FA4L) != p_3))), (*l_9), l_636) < p_3)) % (int32_t)p_3));
    return (*g_87);
    /* statement id: 291 */
    //assert (func_2_rv == &g_10);
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_10 g_506 g_4 g_70 g_282 g_87
 * writes: g_47 g_10 g_88
 */
inline static int32_t  func_13(int32_t  p_14)
{ /* block id: 280 */
    int32_t *l_662 = &g_10;
    uint64_t l_676 = 0x309D1BD77567B505LL;
    l_662 = l_662;
    for (g_47 = (-29); (g_47 >= 3); ++g_47)
    { /* block id: 284 */
        int16_t l_677 = 0xB3D5L;
        int32_t l_682 = (-1L);
        int32_t l_683 = 5L;
        (*l_662) = (((int16_t)(((0xB067AF5FL | (*l_662)) < (((int16_t)(((uint16_t)(p_14 != (((uint64_t)(-(int16_t)((int32_t)((p_14 | (l_676 > l_677)) <= (*l_662)) % (int32_t)(((-2L) ^ ((int16_t)(((((uint32_t)(l_677 || g_506) % (uint32_t)l_682) || g_4) <= g_10) || 0x10934648L) * (int16_t)l_683)) || g_4))) + (uint64_t)g_70) ^ p_14)) >> (uint16_t)8) | g_282) >> (int16_t)g_282) && 0x16ADC4BF5E63CD8ELL)) != 0xCF4CA57ED3892F7ELL) << (int16_t)10) || 0xC68C20FEF92FC901LL);
        if (l_677)
            break;
    }
    (*g_87) = l_662;
    /* statement id: 288 */
    assert (g_88 == &g_10);
    return (*l_662);
}


/* ------------------------------------------ */
/* 
 * reads : g_130 g_506 g_282 g_87 g_88
 * writes: g_282 g_88
 */
inline static int64_t  func_15(int32_t  p_16, int16_t  p_17, uint32_t  p_18)
{ /* block id: 269 */
    uint8_t l_645 = 0UL;
    int32_t l_655 = 5L;
    int32_t *l_659 = &l_655;
    int32_t ***l_661 = &g_267;
    int32_t ****l_660 = &l_661;
    l_655 = (g_130 && ((uint32_t)7UL + (uint32_t)(((uint16_t)(((uint16_t)p_16 * (uint16_t)(((uint16_t)l_645 * (uint16_t)(~((uint16_t)p_17 << (uint16_t)2))) | ((((int16_t)l_645 * (int16_t)l_645) ^ p_17) != ((int16_t)(((((uint16_t)p_16 * (uint16_t)p_17) & l_645) >= g_506) != l_645) << (int16_t)5)))) >= 0xC560375822D8EBADLL) >> (uint16_t)12) != p_18)));
    l_655 = ((p_17 >= 0x1547B91E947ADE20LL) != p_18);
    for (g_282 = 0; (g_282 <= 56); ++g_282)
    { /* block id: 274 */
        int32_t *l_658 = &g_47;
        (*g_87) = (*g_87);
        l_659 = l_658;
        /* statement id: 276 */
        assert (l_659 == &g_47);
    }
    /* facts after for loop */
    assert (l_659 == &g_47 || l_659 == &l_655);
    l_660 = l_660;
    return g_506;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_282 g_87 g_47 g_88
 * writes: g_88 g_47
 */
static uint16_t  func_23(int32_t * p_24, uint32_t  p_25, int32_t * p_26, int32_t * p_27, int16_t  p_28)
{ /* block id: 164 */
    int32_t l_379 = (-5L);
    int32_t ***l_384 = &g_87;
    int32_t **l_389 = (void*)0;
    int16_t l_394 = 0L;
    int64_t l_450 = 6L;
    uint32_t l_466 = 0x127619C6L;
    int32_t ****l_577 = &l_384;
    int32_t *****l_576 = &l_577;
    if ((l_379 | ((uint32_t)((((int16_t)(l_384 == l_384) >> (int16_t)3) <= ((int32_t)(*p_27) % (int32_t)(0xD116E590L ^ (((((((int32_t)((l_389 == &g_88) & ((int32_t)((((((int32_t)(*p_27) + (int32_t)(*p_27)) == l_379) || 0x0C48DCC073444A49LL) <= p_25) == 0x0FCFL) - (int32_t)0x7D6F02A8L)) + (int32_t)(*p_26)) || 8UL) | l_394) > 18446744073709551615UL) == p_28) ^ p_25)))) > g_282) % (uint32_t)(*p_26))))
    { /* block id: 165 */
        l_379 = (*p_26);
    }
    else
    { /* block id: 167 */
        int32_t *l_395 = &g_47;
        uint8_t l_415 = 246UL;
        (**l_384) = l_395;
        /* statement id: 168 */
        assert (g_88 == &g_47);
        (*g_88) = (((int32_t)((((int16_t)((uint16_t)((int16_t)((uint64_t)g_47 - (uint64_t)((((int32_t)(-1L) % (int32_t)((uint16_t)65532UL >> (uint16_t)(((uint16_t)((***l_384) || (-(int32_t)(((((uint64_t)l_415 + (uint64_t)((&p_27 == (void*)0) <= ((*l_395) | ((&l_389 == (void*)0) > 0xEF2E56CCL)))) && (-6L)) <= (*l_395)) > 65531UL))) * (uint16_t)p_28) ^ g_10))) ^ p_25) || 0xF378C7E5L)) << (int16_t)8) % (uint16_t)(*l_395)) >> (int16_t)11) > 0UL) && 5L) - (int32_t)0x80EDC81BL) < (***l_384));
    }
    /* facts after branching */
    assert (g_88 == &g_47 || g_88 == 0);
    for (p_25 = 0; (p_25 < 43); p_25 += 1)
    { /* block id: 173 */
        uint64_t l_429 = 18446744073709551615UL;
        int32_t *l_455 = &g_47;
        uint16_t l_469 = 1UL;
        int32_t ****l_525 = (void*)0;
        int32_t *l_534 = &g_130;
        int32_t l_554 = (-1L);
        uint16_t l_557 = 0x1069L;
        int32_t **l_612 = &l_455;
    }
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_47 g_10 g_4 g_87 g_88 g_130
 * writes: g_130 g_47 g_70 g_4 g_88
 */
inline static int32_t * func_29(int32_t  p_30, int32_t  p_31, int32_t * p_32)
{ /* block id: 161 */
    int32_t ***l_372 = &g_267;
    int32_t ****l_371 = &l_372;
    int32_t l_374 = (-1L);
    uint16_t l_375 = 0x6D41L;
    uint8_t l_378 = 254UL;
    (*g_87) = func_33(func_36(((uint64_t)((g_70 > ((void*)0 != l_371)) >= (-(int32_t)(p_31 >= l_374))) - (uint64_t)((l_375 && (p_30 == ((uint16_t)p_31 >> (uint16_t)2))) && g_47)), g_10, l_378), &l_374);
    /* statement id: 162 */
    assert (g_88 == 0);
    return (*g_87);
    /* statement id: 163 */
    //assert (func_29_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_4 g_47 g_70 g_87 g_88 g_130
 * writes: g_47 g_70 g_4 g_88 g_130
 */
inline static int32_t * func_33(int32_t * p_34, int32_t * p_35)
{ /* block id: 2 */
    uint32_t l_45 = 8UL;
    int32_t *l_368 = (void*)0;
    (*g_87) = func_36(((0x0627L ^ func_40(func_43(l_45), (&g_10 != p_35))) > ((int16_t)((uint16_t)g_130 << (uint16_t)12) << (int16_t)14)), ((int16_t)(((((void*)0 != p_34) | l_45) == 0x9E5FAA0FL) || (*p_34)) * (int16_t)l_45), g_10);
    /* statement id: 159 */
    assert (g_88 == &g_130);
    return l_368;
    /* statement id: 160 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_130
 */
static int32_t * func_36(int64_t  p_37, uint32_t  p_38, uint8_t  p_39)
{ /* block id: 155 */
    int32_t *l_367 = &g_130;
    l_367 = l_367;
    (*l_367) = 0x1DB44341L;
    return l_367;
    /* statement id: 158 */
    //assert (func_36_rv == &g_130);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_4 g_47 g_70 g_87 g_88 g_130
 * writes: g_47 g_70 g_4 g_88
 */
static uint16_t  func_40(uint8_t  p_41, uint16_t  p_42)
{ /* block id: 5 */
    int32_t *l_46 = &g_47;
    int32_t *l_98 = &g_10;
    uint32_t l_243 = 0UL;
    int64_t l_251 = 0x788A37CDCD6FD788LL;
    uint16_t l_255 = 65528UL;
    int32_t l_260 = 0xE881EA7AL;
    int64_t l_304 = 1L;
lbl_108:
    l_46 = &g_10;
    /* statement id: 6 */
    assert (l_46 == &g_10);
    if (p_41)
    { /* block id: 7 */
        uint32_t l_48 = 0x606DC068L;
        int32_t *l_53 = &g_47;
        int32_t l_197 = 1L;
        int32_t ***l_252 = &g_87;
        if ((l_48 | ((int32_t)((uint16_t)((l_53 != &g_47) != 0x97E65FBCL) >> (uint16_t)(g_10 < g_4)) % (int32_t)p_42)))
        { /* block id: 8 */
            uint32_t l_54 = 18446744073709551611UL;
            int32_t *l_198 = &g_10;
            int32_t l_203 = (-7L);
            uint8_t l_233 = 255UL;
            int32_t l_283 = (-1L);
            if (l_54)
            { /* block id: 9 */
                return p_41;
            }
            else
            { /* block id: 11 */
                uint8_t l_69 = 0xCEL;
                if ((((int16_t)(((uint16_t)((((&g_47 == &g_10) >= ((int16_t)(((int16_t)(&g_47 != &g_10) * (int16_t)(l_46 != (void*)0)) || (*l_53)) << (int16_t)(0x2CC6L > (((int64_t)((int16_t)((int16_t)((g_10 || l_69) || p_41) % (int16_t)p_42) << (int16_t)12) % (int64_t)(*l_46)) <= p_41)))) && 0x9538E5EFB48CA181LL) < p_41) << (uint16_t)7) & g_70) << (int16_t)12) == (*l_46)))
                { /* block id: 12 */
                    int32_t l_73 = 4L;
                    int32_t **l_74 = &l_53;
                    for (l_48 = 0; (l_48 >= 15); ++l_48)
                    { /* block id: 15 */
                        (*l_53) = 1L;
                        if (l_73)
                            continue;
                        if (g_70)
                            continue;
                        if (g_4)
                            continue;
                    }
                    (*l_74) = l_46;
                    /* statement id: 21 */
                    assert (l_53 == &g_10);
                    return p_41;
                }
                else
                { /* block id: 23 */
                    uint16_t l_77 = 0x8062L;
                    int32_t *l_103 = &g_47;
                    for (g_70 = 0; (g_70 != (-15)); g_70 -= 5)
                    { /* block id: 26 */
                        (*l_53) = l_77;
                        (*l_53) = ((int16_t)((9L ^ (((((uint16_t)((int16_t)1L * (int16_t)(~0x95B172C6L)) + (uint16_t)((uint16_t)(&l_46 == (void*)0) * (uint16_t)(*l_53))) > (g_87 != (void*)0)) >= (*l_53)) ^ p_41)) < p_42) % (int16_t)0x16A1L);
                    }
                    for (g_4 = 0; (g_4 == 44); g_4 += 9)
                    { /* block id: 32 */
                        int16_t l_91 = 0xC7DCL;
                        (*l_53) = l_91;
                        (*l_53) = ((((uint32_t)p_42 + (uint32_t)(((void*)0 == &g_88) ^ (((uint16_t)0xEBE3L * (uint16_t)l_77) < ((p_42 || ((uint16_t)g_10 * (uint16_t)(l_98 == l_53))) > 8L)))) < l_69) ^ l_77);
                        (*l_53) = (((int64_t)(p_41 || (-1L)) - (int64_t)(((0x33A1L && (((uint16_t)((void*)0 == (*g_87)) << (uint16_t)(l_103 == (void*)0)) <= g_10)) || ((int64_t)l_69 + (int64_t)(*l_103))) > g_4)) ^ (*l_53));
                        (*l_103) = (*g_88);
                    }
                    (*l_53) = ((int16_t)0L << (int16_t)5);
                }
                if (l_54)
                    goto lbl_108;
            }
            for (p_41 = 18; (p_41 >= 48); p_41 += 1)
            { /* block id: 44 */
                uint64_t l_145 = 0x7F256DA865B3CABDLL;
                uint8_t l_168 = 247UL;
                int32_t **l_202 = &l_198;
                int32_t ***l_247 = &g_87;
                int32_t ****l_246 = &l_247;
                int16_t l_284 = 0x9D14L;
                int32_t l_287 = 0xA60E0309L;
            }
        }
        else
        { /* block id: 109 */
            int32_t **l_301 = &l_53;
            for (l_197 = 0; (l_197 < (-10)); l_197 -= 8)
            { /* block id: 112 */
                uint32_t l_321 = 0UL;
                int32_t l_336 = (-1L);
                (*l_53) = (((int16_t)((uint16_t)((uint16_t)((65535UL > ((*l_46) && ((uint32_t)(((uint32_t)0x964B614FL - (uint32_t)((*l_53) || ((5UL < (((void*)0 != l_301) && g_4)) && ((int32_t)1L % (int32_t)p_41)))) | (*l_53)) % (uint32_t)p_41))) ^ (-1L)) % (uint16_t)l_304) << (uint16_t)4) << (int16_t)12) < p_42);
                for (l_304 = (-5); (l_304 >= 17); ++l_304)
                { /* block id: 116 */
                    int32_t ****l_309 = &l_252;
                    uint8_t l_333 = 3UL;
                    int32_t l_335 = 0x90960BBCL;
                }
            }
            (**l_301) = ((int64_t)p_42 - (int64_t)(!((int16_t)(~((((p_41 > ((uint64_t)((((int16_t)(((l_46 == (*g_87)) == ((p_41 ^ (((*l_98) || (**g_87)) | 65535UL)) && 65532UL)) > 0x41FFL) >> (int16_t)0) == g_4) && 0x809BL) - (uint64_t)0x3D6E52BDFDB65664LL)) & p_42) <= g_4) < p_42)) * (int16_t)g_4)));
        }
    }
    else
    { /* block id: 139 */
        int32_t *l_350 = &g_10;
        int32_t ***l_359 = &g_267;
        int32_t *l_360 = &g_47;
        for (l_243 = 18; (l_243 != 48); l_243 += 3)
        { /* block id: 142 */
            (*g_87) = l_350;
            /* statement id: 143 */
            assert (g_88 == &g_10);
        }
        for (p_42 = (-1); (p_42 != 47); p_42 += 2)
        { /* block id: 147 */
            int64_t l_353 = 4L;
            int32_t *l_354 = &g_130;
            l_353 = (**g_87);
            (*g_87) = l_354;
            /* statement id: 149 */
            assert (g_88 == &g_130);
        }
        (*l_360) = (((g_4 ^ ((-1L) >= ((uint16_t)((((uint32_t)0xE39DC23CL - (uint32_t)(l_359 == (void*)0)) < 0x871D96F4L) <= 18446744073709551615UL) * (uint16_t)1L))) ^ 6UL) >= 2L);
        (*g_87) = (*g_87);
    }
    return g_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_43(uint32_t  p_44)
{ /* block id: 3 */
    return p_44;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_10, "g_10", print_hash_value);
    transparent_crc(g_47, "g_47", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc(g_130, "g_130", print_hash_value);
    transparent_crc(g_282, "g_282", print_hash_value);
    transparent_crc(g_506, "g_506", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 129
XXX total union variables: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 2
   depth: 28, occurrence: 1

XXX total number of pointers: 74

XXX times a variable address is taken: 95
XXX times a pointer is dereferenced on RHS: 133
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 17
   depth: 3, occurrence: 6
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 76
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 41
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 545

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 309
   level: 2, occurrence: 75
   level: 3, occurrence: 51
   level: 4, occurrence: 26
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 40
XXX number of pointers point to scalars: 34
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.6
XXX average alias set size: 1.14

XXX times a non-volatile is read: 774
XXX times a non-volatile is write: 221
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 69
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 12
   depth: 2, occurrence: 7
   depth: 3, occurrence: 5
   depth: 4, occurrence: 6
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
********************* end of statistics **********************/

