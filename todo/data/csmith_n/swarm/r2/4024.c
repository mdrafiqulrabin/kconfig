/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      960898204
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int8_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   uint8_t  f3;
   signed f4 : 11;
   uint32_t  f5;
   int16_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_29(void);
static int32_t  func_37(uint16_t  p_38, int8_t  p_39, int32_t  p_40, uint16_t  p_41);
static uint32_t  func_42(const int32_t  p_43, float  p_44, struct S0  p_45);
static float  func_46(struct S0  p_47, uint16_t  p_48);
static struct S0  func_49(uint32_t  p_50, const int32_t  p_51, uint16_t  p_52, const uint32_t  p_53, uint32_t  p_54);
static uint16_t  func_60(uint8_t  p_61, float  p_62);
static struct S0  func_76(uint32_t  p_77, struct S0  p_78, uint8_t  p_79, uint32_t  p_80, const int16_t  p_81);
static struct S0  func_83(int16_t  p_84);
static int16_t  func_92(float  p_93, uint16_t  p_94);
static int16_t  func_97(int8_t  p_98, float  p_99, uint8_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 0xD56974ED;
    struct S0 l_31 = {0x16,0U,0U,8U,40,5U,0xAF86};
    uint32_t l_503 = 4294967292U;
    int16_t l_517 = 2;
    int32_t l_556 = 0x3DD12690;
    uint32_t l_678 = 0x4D9BEBD0;
    int32_t l_702 = 0;
    float l_715 = 0x9.BF2748p+65;
    int32_t l_716 = 6;
    int8_t l_754 = 0xBE;
    uint32_t l_755 = 4294967295U;
    if ((l_30 != l_30))
    { /* block id: 37 */
        struct S0 l_32 = {-1,0U,4U,0x15,25,0xFF4CAA5D,-4};
        const uint16_t l_429 = 0xB9CB;
        uint16_t l_509 = 0x8D4C;
        int32_t l_534 = 0x1A95B7A0;
        uint32_t l_540 = 1U;
        int8_t l_565 = (-6);
        int32_t l_571 = 0;
        int32_t l_572 = 0x4E6A35BA;
        int32_t l_574 = 1;
        float l_687 = 0x0.580BC6p+66;
        int32_t l_703 = 0x2CEA0B91;
        float l_718 = 0x6.Fp-1;
        float l_725 = 0x0.Ap-1;
lbl_679:
        l_32 = l_31;
lbl_599:
        if (((int32_t)((uint16_t)l_31.f2 >> (uint16_t)11) + (int32_t)func_37((func_42(l_32.f4, l_32.f6, l_31) || ((((int32_t)l_31.f4 % (int32_t)__builtin_ia32_crc32qi(l_32.f0, ((0x98E7 ^ l_31.f4) < l_32.f5))) < l_429) <= l_31.f6)), l_32.f1, l_31.f2, l_32.f6)))
        { /* block id: 250 */
            int8_t l_498 = (-9);
            l_31.f4 = (0x0.Ep-1 <= ((float)l_31.f2 - (float)(((((float)0x5.8D60D7p+26 - (float)((float)(func_97(l_31.f6, l_31.f4, l_429) >= l_498) + (float)l_31.f1)) > l_498) != l_498) > l_30)));
        }
        else
        { /* block id: 252 */
            uint16_t l_502 = 0x8435;
            if ((~(((int8_t)l_502 + (int8_t)0xB8) < l_502)))
            { /* block id: 253 */
                uint32_t l_518 = 0x17C25CDB;
                int32_t l_525 = (-1);
                l_503 = l_31.f5;
                for (l_32.f2 = 0; (l_32.f2 > 22); l_32.f2 += 4)
                { /* block id: 257 */
                    int32_t l_512 = 2;
                    if (((l_31.f0 ^ l_502) && ((((!(l_32.f0 >= ((((uint32_t)func_60(l_502, l_509) - (uint32_t)((int16_t)((l_512 < ((int16_t)l_512 >> (int16_t)1)) != ((int16_t)0x479D >> (int16_t)l_517)) << (int16_t)l_502)) == 0) != 0xE3))) != l_502) ^ 0U) > l_503)))
                    { /* block id: 258 */
                        int16_t l_521 = 1;
                        l_518++;
                        l_31.f4 = ((l_521 || func_97(l_521, l_518, l_30)) <= l_502);
                        l_512 = (l_521 > 0U);
                    }
                    else
                    { /* block id: 262 */
                        float l_522 = (-0x1.4p-1);
                        int32_t l_526 = 0xD8F93519;
                        l_31.f4 = (l_518 > __builtin_ctzll((__builtin_popcount((l_518 != ((l_31.f4 <= (-4)) > l_518))) || l_31.f2)));
                        l_525 = ((uint8_t)l_31.f6 - (uint8_t)l_512);
                        l_31.f4 = l_526;
                        l_512 = l_30;
                    }
                    return l_32;
                }
            }
            else
            { /* block id: 270 */
                float l_535 = 0x6.C9D2B8p-19;
                int32_t l_536 = 0xC96593BA;
                if (((int32_t)(((((uint32_t)(l_31.f1 || (((uint8_t)(-(int16_t)((l_534 && l_536) == l_32.f2)) - (uint8_t)(l_536 >= (l_32.f1 >= (l_536 ^ l_31.f2)))) >= ((uint8_t)l_31.f4 << (uint8_t)4))) % (uint32_t)l_502) > l_429) != l_536) & l_32.f0) % (int32_t)l_502))
                { /* block id: 271 */
                    int8_t l_539 = 5;
                    l_540--;
                }
                else
                { /* block id: 273 */
                    uint16_t l_543 = 0x8B7F;
                    l_536 ^= (0 != l_543);
                }
            }
            for (l_32.f1 = 0; (l_32.f1 >= 43); ++l_32.f1)
            { /* block id: 279 */
                for (l_503 = (-10); (l_503 > 16); l_503 += 9)
                { /* block id: 282 */
                    return l_32;
                }
            }
        }
        for (l_534 = 0; (l_534 <= (-27)); l_534 -= 1)
        { /* block id: 289 */
            uint16_t l_558 = 0x80E5;
            struct S0 l_566 = {-1,4294967295U,1U,0x9A,40,1U,-1};
            int32_t l_573 = (-1);
            uint8_t l_643 = 0x95;
            int32_t l_693 = (-6);
            int32_t l_696 = 3;
            int32_t l_708 = 0xD5DC21CE;
            int32_t l_709 = 0xBC8258A4;
            int32_t l_711 = (-1);
            int32_t l_712 = 0xAE8BF914;
            uint32_t l_720 = 0U;
            if (l_32.f2)
            { /* block id: 290 */
                int16_t l_557 = 0x3413;
                int32_t l_575 = 0xE355F6F7;
                int32_t l_576 = (-7);
                struct S0 l_596 = {-10,4294967292U,0x84C99681,0xBB,19,5U,0x6CBC};
                if (((uint8_t)(((int16_t)l_31.f0 >> (int16_t)9) && ((uint32_t)(l_556 > ((l_557 < (l_558 < ((uint8_t)func_97((l_31.f0 & (((int8_t)(-1) - (int8_t)((((int16_t)(l_31.f1 <= l_558) % (int16_t)func_37(l_556, l_557, l_558, l_32.f3)) != 0x00) >= l_509)) >= l_517)), l_558, l_32.f4) + (uint8_t)l_32.f5))) >= l_565)) + (uint32_t)l_30)) % (uint8_t)l_558))
                { /* block id: 291 */
                    float l_567 = 0x0.5p+1;
                    int32_t l_577 = 1;
                    if (l_557)
                    { /* block id: 292 */
                        l_31 = l_566;
                        l_32.f4 ^= (l_565 | 0U);
                        l_566 = l_31;
                    }
                    else
                    { /* block id: 296 */
                        float l_568 = 0xC.F5E573p+97;
                        int32_t l_569 = 6;
                        int32_t l_570 = 0;
                        int32_t l_578 = 0x87B39429;
                        int32_t l_579 = 0;
                        uint32_t l_580 = 4294967293U;
                        ++l_580;
                        return l_31;
                    }
                    l_575 = (l_576 ^ func_42(((uint8_t)l_576 >> (uint8_t)7), ((float)func_42((~(((((int32_t)(-1) - (int32_t)(((uint8_t)(((l_566.f0 ^ l_566.f1) | ((int16_t)l_558 + (int16_t)0x07FC)) >= l_32.f2) - (uint8_t)((uint16_t)l_32.f4 << (uint16_t)l_576)) & 0x34E82969)) != 7) | l_577) || 0x7075255A)), l_31.f0, l_596) + (float)0x0.Fp+1), l_32));
                    if (l_596.f4)
                        break;
                }
                else
                { /* block id: 302 */
                    for (l_558 = 0; (l_558 <= 15); l_558 += 1)
                    { /* block id: 305 */
                        return l_32;
                    }
                    if (l_32.f5)
                        goto lbl_599;
                }
            }
            else
            { /* block id: 310 */
                const float l_606 = 0x6.491805p+9;
                int32_t l_608 = (-1);
                uint32_t l_622 = 0x53D06A86;
                struct S0 l_639 = {0x8A,1U,0x75C3B7B6,0x2E,15,4294967295U,0x356A};
                struct S0 l_669 = {-1,4294967292U,4294967295U,0xB2,30,1U,0x9704};
                int32_t l_689 = 0x0FBB20BA;
                int32_t l_690 = 0x073C874F;
                int32_t l_692 = 1;
                int32_t l_695 = 6;
                int32_t l_697 = 0x153BD710;
                int32_t l_699 = 0x487A47EE;
                int32_t l_700 = 7;
                int32_t l_701 = (-1);
                int32_t l_704 = 1;
                int32_t l_705 = 0xDD222846;
                int32_t l_707 = 0x8CD3E274;
                int32_t l_713 = 0;
                int32_t l_714 = 2;
                if (((uint16_t)(1U || ((uint8_t)9U + (uint8_t)1)) >> (uint16_t)6))
                { /* block id: 311 */
                    float l_607 = 0xE.2DC59Fp-51;
                    int32_t l_617 = (-1);
                    float l_620 = (-0x3.7p-1);
                    uint8_t l_621 = 0x38;
                    uint8_t l_638 = 255U;
                    for (l_540 = 0; (l_540 < 56); l_540++)
                    { /* block id: 314 */
                        l_608 = (l_509 | __builtin_ffsl((l_566.f2 && l_32.f0)));
                    }
                    for (l_32.f0 = (-15); (l_32.f0 == 11); ++l_32.f0)
                    { /* block id: 319 */
                        float l_623 = 0x0.4C73AFp-26;
                        int32_t l_624 = 0x215AE740;
                        l_622 = (0xA0 && __builtin_ffs(((uint8_t)((uint16_t)l_608 << (uint16_t)((int16_t)0x5901 >> (int16_t)l_617)) >> (uint8_t)((l_608 | func_60((((uint32_t)((0xAEE35622 >= (((l_608 >= l_31.f6) <= (((l_558 == l_608) < l_566.f0) != 0)) | 9)) ^ 0x3F) + (uint32_t)l_608) > l_608), l_608)) >= l_621))));
                        l_556 = (l_608 < __builtin_clzl(func_97(l_32.f5, l_624, l_566.f3)));
                        l_608 = l_566.f0;
                    }
                    l_31.f4 = (l_617 != ((((float)(l_608 >= (((float)l_31.f4 - (float)0x6.Dp+1) <= l_31.f2)) + (float)(-0x1.8p+1)) > ((float)(((float)l_31.f2 - (float)(((-(float)(((float)l_31.f5 - (float)(((float)l_608 + (float)l_617) >= l_31.f1)) > l_638)) >= l_622) < l_31.f3)) == l_622) - (float)0xE.307D6Fp-5)) <= l_517));
                }
                else
                { /* block id: 325 */
                    return l_639;
                }
                if (func_97(l_32.f6, l_566.f5, l_31.f4))
                { /* block id: 328 */
                    int16_t l_648 = 0x1B01;
                    const int16_t l_650 = 1;
                    int32_t l_663 = (-1);
                    if (l_573)
                    { /* block id: 329 */
                        int32_t l_640 = 1;
                        int32_t l_641 = (-1);
                        int32_t l_642 = 0x9C3ADEF4;
                        ++l_643;
                        l_639.f4 = ((!(~__builtin_bswap32(l_648))) != 0x60);
                        l_663 |= ((~func_42(l_650, (((float)(l_31.f5 >= ((!(((((-0x1.5p+1) == l_639.f2) > ((float)(-0x10.Ap-1) + (float)(((float)l_648 - (float)(((float)l_639.f2 + (float)((float)l_503 - (float)((!__builtin_popcountl(l_30)) >= l_650))) < l_650)) >= (-0x1.1p-1)))) >= (-0x8.Bp-1)) < l_31.f3)) == l_558)) - (float)l_31.f3) > l_622), l_32)) == l_640);
                        l_642 &= (!(((int8_t)l_650 >> (int8_t)7) || func_97(((l_503 <= ((int16_t)(l_650 | l_639.f6) + (int16_t)((3 != l_534) || (l_639.f5 < (((l_650 == (l_641 == 0x8065F4F5)) ^ 0) || 1U))))) ^ 4294967293U), l_566.f5, l_639.f3)));
                    }
                    else
                    { /* block id: 334 */
                        l_669 = l_566;
                    }
                    l_573 ^= func_97(((((-(int8_t)((uint8_t)(((int16_t)0xE638 << (int16_t)15) < func_60((-(uint8_t)l_31.f3), (((((0x0.0p-1 > ((float)func_37((8U <= (l_678 | l_650)), l_608, l_650, (l_32.f3 || l_663)) - (float)l_31.f3)) >= l_571) < l_566.f2) < (-0x2.Ep-1)) > 0x0.Cp+1))) >> (uint8_t)l_32.f6)) ^ l_32.f3) & l_650) || l_31.f2), l_566.f6, l_31.f5);
                    if (l_556)
                        goto lbl_679;
                }
                else
                { /* block id: 339 */
                    uint8_t l_685 = 0xAC;
                    int32_t l_686 = (-8);
                    int32_t l_688 = 9;
                    int32_t l_691 = 0xDEFF4A30;
                    int32_t l_694 = (-3);
                    int32_t l_698 = 0xBA1C90C6;
                    int32_t l_706 = 1;
                    int32_t l_710 = 2;
                    int32_t l_717 = 0x4EE46C74;
                    int32_t l_719 = 0x1C507E00;
                    l_608 |= 6;
                    l_566 = l_669;
                    l_31.f4 |= ((int8_t)0 * (int8_t)((uint8_t)(!0x3DC31E78) << (uint8_t)l_685));
                    l_720++;
                }
            }
            l_32.f4 = (0xA3 >= l_32.f1);
        }
        l_571 = ((int32_t)l_32.f4 - (int32_t)l_31.f0);
    }
    else
    { /* block id: 349 */
        uint32_t l_726 = 4U;
        int32_t l_735 = (-1);
        if (l_726)
        { /* block id: 350 */
            int16_t l_729 = 0x4D74;
            int32_t l_730 = 9;
            l_730 = ((float)l_729 + (float)l_729);
            l_730 = l_726;
            l_730 = (((l_729 < 0x2.Bp-1) < (((l_730 <= ((float)l_729 - (float)l_729)) <= (((l_31.f3 > __builtin_clz((l_726 >= (((uint32_t)(l_31.f6 & l_729) - (uint32_t)l_735) > l_730)))) == l_726) > l_726)) == l_678)) == l_503);
            l_702 &= l_31.f2;
        }
        else
        { /* block id: 355 */
            int32_t l_736 = 0x9C922CC6;
            l_735 ^= (l_736 > 65534U);
            return l_31;
        }
    }
    l_702 = (-(float)(0x8.EBBB52p+76 > (0xD.7DAFF8p-98 > ((l_702 > ((float)((l_30 < __builtin_ctz(l_716)) <= ((float)((((0x2.848602p+25 >= __builtin_ffsl(((uint16_t)0xF08A >> (uint16_t)l_31.f6))) > (-0x2.Dp-1)) == l_30) >= 0x0.Cp+1) + (float)l_30)) - (float)l_678)) < (-0x1.Bp+1)))));
    l_31 = func_76((l_31.f3 <= l_31.f4), func_83(l_517), (((int32_t)__builtin_parity(((int16_t)(-10) % (int16_t)((uint8_t)((uint16_t)((l_556 > ((int8_t)(l_754 >= l_755) - (int8_t)l_31.f3)) < 250U) << (uint16_t)l_31.f5) % (uint8_t)0x75))) % (int32_t)4U) <= l_716), l_31.f6, l_755);
    return l_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_37(uint16_t  p_38, int8_t  p_39, int32_t  p_40, uint16_t  p_41)
{ /* block id: 235 */
    uint32_t l_432 = 5U;
    int32_t l_438 = 1;
    int32_t l_439 = 0;
    int32_t l_440 = 1;
    int32_t l_448 = 0xC42388AC;
    int32_t l_450 = 0x07E1C385;
    int32_t l_452 = 0x8A57F9CF;
    int32_t l_453 = 0x72BB7433;
    int32_t l_456 = 0x04496637;
    int32_t l_457 = 0x63B7FDE9;
    int32_t l_467 = 1;
    int32_t l_470 = 0xF14767FC;
    int32_t l_473 = 0x1B5C3F10;
    if (((int16_t)3 << (int16_t)0))
    { /* block id: 236 */
        struct S0 l_435 = {-1,0U,4294967288U,6U,7,0x589DB1A4,-3};
        l_432--;
        l_435 = l_435;
    }
    else
    { /* block id: 239 */
        int32_t l_436 = 1;
        int32_t l_437 = 0xEEAD4B14;
        int32_t l_441 = 0xC37ED356;
        int32_t l_442 = (-9);
        int32_t l_443 = 0xD24E1954;
        int32_t l_444 = 0xB81EF6E2;
        int32_t l_445 = (-1);
        int32_t l_446 = (-1);
        int32_t l_447 = 0;
        int32_t l_449 = 1;
        int32_t l_451 = 1;
        int32_t l_454 = 0;
        int32_t l_455 = 0xA5227E1B;
        int32_t l_458 = 1;
        int32_t l_459 = (-9);
        int32_t l_460 = (-1);
        int32_t l_461 = 0x47325FCA;
        int32_t l_462 = 1;
        int32_t l_463 = 0xE5EA0DF4;
        int32_t l_464 = (-1);
        int32_t l_465 = 0;
        int32_t l_466 = 0x37B45C48;
        int32_t l_468 = 0x8976597A;
        int32_t l_469 = 0xD0770E1C;
        int32_t l_471 = (-1);
        int32_t l_472 = 0;
        uint16_t l_474 = 0x514F;
        l_474--;
        l_469 = p_40;
    }
    for (l_457 = 0; (l_457 > 20); l_457++)
    { /* block id: 245 */
        uint8_t l_489 = 0xAB;
        l_438 |= p_39;
        l_470 = ((int16_t)(func_92((p_40 < func_97(((uint32_t)__builtin_ctzl((((int8_t)((int8_t)(((uint8_t)l_439 % (uint8_t)0xBD) && l_489) + (int8_t)(func_97(l_470, p_39, p_39) != ((((int16_t)p_38 + (int16_t)p_39) & l_473) <= l_457))) - (int8_t)p_39) == p_38)) + (uint32_t)l_489), l_489, p_38)), l_457) | l_440) << (int16_t)p_41);
    }
    return l_452;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_42(const int32_t  p_43, float  p_44, struct S0  p_45)
{ /* block id: 39 */
    uint32_t l_55 = 0U;
    p_44 = func_46(func_49(l_55, ((int8_t)((int32_t)(-2) % (int32_t)1U) + (int8_t)(0xA5 && p_43)), (__builtin_ffs(p_45.f1) & func_60(l_55, l_55)), l_55, p_45.f5), l_55);
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_46(struct S0  p_47, uint16_t  p_48)
{ /* block id: 216 */
    uint16_t l_390 = 0x5544;
    int32_t l_405 = 0x32F1ED42;
    uint32_t l_426 = 1U;
    p_47.f4 |= l_390;
    if (((uint8_t)((((int8_t)func_97(p_47.f3, p_47.f4, p_47.f6) << (int8_t)5) == l_390) && l_390) - (uint8_t)l_390))
    { /* block id: 218 */
        int8_t l_402 = 0x27;
        int32_t l_403 = 0;
        p_47 = p_47;
        if ((__builtin_ctz(p_47.f6) < (l_390 == (((((uint8_t)((0 > ((((p_47.f4 == p_47.f6) ^ ((int16_t)((!(l_402 >= p_47.f2)) <= p_47.f3) << (int16_t)l_390)) <= 0xBA9F) && p_47.f2)) != 0x005EBF63) << (uint8_t)1) > l_403) && 0x47) | 0))))
        { /* block id: 220 */
            uint8_t l_404 = 0x7E;
            p_47 = p_47;
            l_405 = l_404;
        }
        else
        { /* block id: 223 */
            return l_390;
        }
        l_405 = (__builtin_ia32_crc32qi((247U <= (__builtin_parityll(l_402) >= ((~((uint8_t)l_403 >> (uint8_t)((-10) <= ((uint16_t)l_390 >> (uint16_t)__builtin_parity(p_47.f1))))) <= (-1)))), p_47.f2) == p_47.f2);
        l_403 = ((int16_t)l_405 + (int16_t)func_60(p_47.f1, (l_402 == l_402)));
    }
    else
    { /* block id: 228 */
        uint32_t l_415 = 0x4A1A6138;
        l_405 = ((((int32_t)(0x1A2D > l_415) + (int32_t)(p_48 == ((0xCD39AF57 > l_405) != l_415))) ^ 0x04) == l_415);
    }
    l_405 = ((float)((float)((float)(0x6.10D614p-75 < ((0x4.AAB0F4p-75 > ((float)__builtin_ffsll(((int16_t)((l_405 && p_47.f4) >= __builtin_popcountll(l_390)) << (int16_t)__builtin_ctzl(((l_405 ^ 0) && p_47.f6)))) - (float)0x6.8p-1)) <= 0x8.88DCC8p-4)) + (float)l_390) - (float)l_390) - (float)l_390);
    return l_426;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_49(uint32_t  p_50, const int32_t  p_51, uint16_t  p_52, const uint32_t  p_53, uint32_t  p_54)
{ /* block id: 213 */
    uint32_t l_388 = 0xFE8B0F75;
    struct S0 l_389 = {0xC4,0xCFE875B2,1U,0U,-18,0U,1};
    l_388 = p_54;
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_60(uint8_t  p_61, float  p_62)
{ /* block id: 40 */
    int32_t l_72 = 0x86D6A6C3;
    int32_t l_218 = 0x4E10F472;
    int32_t l_222 = 0;
    int32_t l_225 = 0x79ADF89C;
    int32_t l_229 = 0x534DAAF5;
    int32_t l_242 = 1;
    int32_t l_245 = 0x77E6723F;
    int32_t l_247 = 0x9C243D1E;
    int32_t l_251 = (-1);
    int32_t l_254 = (-1);
    int32_t l_258 = (-1);
    int32_t l_260 = (-1);
    int32_t l_267 = 0x042F7866;
    int32_t l_274 = 0x2693F941;
    uint16_t l_285 = 65535U;
    struct S0 l_378 = {0x99,0x54374190,0x95BB7E84,0xFF,-19,4294967290U,0x9CC3};
    uint8_t l_379 = 0xA2;
    if (p_61)
    { /* block id: 41 */
        uint32_t l_73 = 9U;
        int32_t l_215 = 0xC017CA1D;
        int32_t l_221 = 0x64EAFE29;
        int32_t l_223 = 0x23DC5B1D;
        int32_t l_226 = 7;
        int32_t l_228 = 0x3BF82D50;
        int32_t l_232 = 0x71376D48;
        int32_t l_234 = 3;
        int32_t l_236 = 0x2AC5C648;
        int32_t l_239 = 0x91E0753C;
        int32_t l_244 = 7;
        int32_t l_255 = 0x8B1C4E8F;
        int32_t l_261 = (-9);
        int32_t l_263 = 9;
        int32_t l_269 = 0;
        int32_t l_270 = (-2);
        int32_t l_271 = 0;
        int32_t l_273 = (-1);
        int32_t l_275 = 0xE84A3AFC;
        int32_t l_277 = (-8);
        int32_t l_284 = 0x0D722C87;
        for (p_61 = 0; (p_61 < 28); p_61 += 7)
        { /* block id: 44 */
            int32_t l_65 = 0xA04D97F6;
            int32_t l_216 = 0xD3F7C766;
            int32_t l_217 = 8;
            int32_t l_227 = 0x42B4722C;
            int32_t l_237 = 0xE730205D;
            int32_t l_243 = 0x83C71B25;
            int32_t l_246 = 0;
            int32_t l_262 = 1;
            int32_t l_264 = 1;
            int32_t l_268 = 1;
            int32_t l_272 = 0x82150C06;
            int32_t l_279 = 1;
            int32_t l_281 = 4;
            int32_t l_282 = 3;
            for (l_65 = (-18); (l_65 <= (-22)); l_65--)
            { /* block id: 47 */
                int32_t l_68 = 1;
                int32_t l_219 = 0;
                int32_t l_220 = 0x6632E42D;
                int32_t l_224 = (-1);
                int32_t l_230 = 7;
                float l_231 = 0x3.D6E393p+71;
                int32_t l_233 = (-5);
                int32_t l_235 = 0;
                int32_t l_238 = (-6);
                int32_t l_240 = 1;
                int32_t l_241 = 0xE635219D;
                int32_t l_248 = (-7);
                int32_t l_249 = 3;
                int32_t l_250 = 0;
                int32_t l_252 = 0x289D617F;
                int32_t l_253 = 0x02B38FC1;
                int32_t l_256 = 0xD46ABB7C;
                int32_t l_257 = 1;
                int32_t l_259 = 0x140FF6F9;
                int32_t l_265 = 1;
                int32_t l_266 = 0;
                int32_t l_276 = (-1);
                int32_t l_278 = (-1);
                int32_t l_280 = 0xB4B7A3AE;
                int32_t l_283 = 0x0ACF16FA;
                float l_290 = 0x1.5p+1;
                for (l_68 = 0; (l_68 < 14); ++l_68)
                { /* block id: 50 */
                    int32_t l_71 = (-3);
                    struct S0 l_82 = {1,4294967286U,4294967295U,0U,42,0x1708C993,3};
                    l_72 = l_71;
                    l_73--;
                    l_82 = func_76(p_61, l_82, p_61, (l_73 == (l_73 ^ l_71)), __builtin_bswap32(p_61));
                }
                ++l_285;
                for (l_243 = 0; (l_243 == 7); l_243 += 7)
                { /* block id: 149 */
                    if (l_285)
                        break;
                    for (l_215 = (-14); (l_215 == 18); ++l_215)
                    { /* block id: 153 */
                        return p_61;
                    }
                }
                for (l_256 = 29; (l_256 != (-27)); l_256 -= 4)
                { /* block id: 159 */
                    const uint32_t l_295 = 0U;
                    int32_t l_304 = 0xE402FC24;
                    l_304 |= (l_295 >= ((uint32_t)((uint8_t)((int16_t)4 >> (int16_t)0) - (uint8_t)l_267) - (uint32_t)func_92(l_246, ((int16_t)__builtin_ia32_crc32qi(l_295, p_61) % (int16_t)l_224))));
                }
            }
        }
        l_254 |= ((uint8_t)(9 && ((uint32_t)((((l_274 && ((((uint16_t)p_61 << (uint16_t)(p_61 >= (0x52 ^ l_225))) || ((int16_t)(((int8_t)l_258 << (int8_t)p_61) & ((int8_t)l_73 % (int8_t)0x1B)) << (int16_t)7)) != p_61)) || p_61) > l_275) > l_215) - (uint32_t)p_61)) - (uint8_t)p_61);
    }
    else
    { /* block id: 165 */
        uint16_t l_319 = 65530U;
        p_62 = ((-0x1.Dp+1) > ((float)__builtin_ctzll(l_319) + (float)0xA.8C6A7Ep+20));
    }
    l_260 |= ((-(uint8_t)(p_61 & ((((func_92(l_254, l_267) & l_245) < 7) != l_267) || ((uint8_t)l_218 % (uint8_t)(~l_222))))) < l_222);
    if (p_61)
    { /* block id: 169 */
        const int16_t l_324 = 0xCAFA;
        int32_t l_327 = 0x3DBD0510;
        struct S0 l_361 = {-2,1U,0U,0xCF,-41,1U,1};
        int16_t l_373 = 0xF9CC;
        p_62 = l_324;
        for (l_258 = 0; (l_258 == 5); ++l_258)
        { /* block id: 173 */
            int32_t l_328 = 0x609A675D;
            int32_t l_362 = 0x2DACE22F;
            struct S0 l_364 = {0x9A,0x927434CF,1U,0xA5,30,0x2DC099E8,0};
            if (p_61)
                break;
            l_327 = p_61;
            if ((((l_328 > func_97(p_61, l_267, p_61)) ^ l_328) != ((int8_t)p_61 << (int8_t)__builtin_clz((l_324 | ((~(l_328 == p_61)) || l_324))))))
            { /* block id: 176 */
                uint32_t l_336 = 0x67B04CF6;
                for (l_222 = 14; (l_222 == 13); l_222--)
                { /* block id: 179 */
                    int32_t l_345 = 0x958A2EDE;
                    l_345 = ((uint16_t)((l_336 <= ((uint16_t)((int8_t)(((uint8_t)(p_61 <= ((!((func_92(((p_62 > (((p_62 != func_97(p_61, l_328, p_61)) <= (!((l_229 == 0x4.Ap-1) == l_328))) != p_61)) <= l_327), p_61) < p_61) == l_336)) < 1)) >> (uint8_t)4) && p_61) % (int8_t)l_328) << (uint16_t)0)) > p_61) >> (uint16_t)p_61);
                    l_251 = l_336;
                }
                l_327 ^= p_61;
            }
            else
            { /* block id: 184 */
                int32_t l_349 = 0x331D1B60;
                const int8_t l_357 = 6;
                uint16_t l_358 = 0x6704;
                struct S0 l_363 = {0x94,0x726B39FB,0x44A9B6D2,1U,-23,1U,0x86D4};
                l_327 = ((uint32_t)((p_61 >= (((((!0x4767) == l_349) < (l_349 || __builtin_ffs((func_97(((4294967295U | l_349) < (func_92(l_324, l_222) >= p_61)), p_62, p_61) >= 1U)))) != p_61) & l_328)) >= l_267) % (uint32_t)0x6841CB19);
                if (l_349)
                    break;
                if (__builtin_ctzll((~((((p_61 == p_61) < ((((uint16_t)((uint8_t)(__builtin_bswap32((p_61 | (l_349 | ((((l_328 ^ ((uint16_t)p_61 >> (uint16_t)l_357)) > ((((p_61 && p_61) == l_327) ^ 0x03) ^ p_61)) != l_328) ^ 0x1EA57665)))) & p_61) >> (uint8_t)l_358) << (uint16_t)l_328) == l_72) >= p_61)) ^ l_357) != 0xAC969B5C))))
                { /* block id: 187 */
                    uint32_t l_359 = 0x27EA5D77;
                    const struct S0 l_360 = {0xB8,0x973A8124,0xA164EB47,0x5B,-21,1U,-1};
                    p_62 = (p_61 <= l_359);
                    if (l_349)
                        break;
                    l_361 = l_360;
                    l_362 ^= p_61;
                }
                else
                { /* block id: 192 */
                    const uint16_t l_374 = 0U;
                    int32_t l_375 = (-2);
                    l_364 = l_363;
                    l_375 = (((p_61 < (((uint16_t)(((uint32_t)((p_61 > ((uint8_t)0x87 + (uint8_t)253U)) && (((uint8_t)l_364.f2 >> (uint8_t)p_61) == (l_373 & ((l_374 >= (p_61 && 0x18)) || p_61)))) + (uint32_t)p_61) ^ l_72) >> (uint16_t)15) & l_374)) ^ p_61) || l_364.f5);
                    if (l_72)
                        break;
                    l_362 ^= (((uint8_t)(l_285 && __builtin_parityl(l_254)) << (uint8_t)4) && l_327);
                }
            }
            l_361 = l_378;
        }
    }
    else
    { /* block id: 201 */
        float l_382 = 0x8.5345E8p-17;
        int32_t l_383 = (-9);
        p_62 = (-0x5.8p+1);
        l_378 = l_378;
        l_254 = (l_379 == ((uint32_t)(l_383 <= func_92((-(float)(0xA.55F1F0p-52 >= __builtin_parityll(l_267))), p_61)) + (uint32_t)l_242));
        for (l_254 = (-8); (l_254 == (-27)); l_254 -= 6)
        { /* block id: 207 */
            uint32_t l_387 = 3U;
            l_225 = (-4);
            l_383 = l_387;
        }
    }
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_76(uint32_t  p_77, struct S0  p_78, uint8_t  p_79, uint32_t  p_80, const int16_t  p_81)
{ /* block id: 53 */
    int32_t l_87 = (-1);
    const int32_t l_128 = 0x9042C8AC;
    p_78 = func_83((((int8_t)l_87 + (int8_t)__builtin_popcount(((p_78.f6 && (((int8_t)((int16_t)func_92(p_77, l_87) + (int16_t)(l_87 & l_87)) >> (int8_t)p_78.f1) | ((int8_t)(((int16_t)l_128 - (int16_t)0xBAB3) >= p_78.f5) + (int8_t)p_81))) == l_87))) > 1U));
    p_78 = p_78;
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_83(int16_t  p_84)
{ /* block id: 65 */
    uint8_t l_129 = 0U;
    struct S0 l_130 = {0,4294967294U,0xE57A5C46,0xF0,-9,0U,-3};
    int32_t l_135 = 0;
    float l_148 = 0x1.81BCF5p+78;
    l_129 |= p_84;
    l_130 = l_130;
    if (((uint16_t)0xB3FC << (uint16_t)((int32_t)0x97BD6D72 % (int32_t)(l_135 | p_84))))
    { /* block id: 68 */
        uint8_t l_138 = 0xD9;
        int32_t l_159 = 0xE358E79F;
        struct S0 l_160 = {-9,4294967295U,0x94C902CE,0x10,42,4294967295U,-4};
        struct S0 l_164 = {0xAB,6U,4294967291U,1U,-37,0x6493B66A,0x959E};
        if (func_97(p_84, l_130.f5, p_84))
        { /* block id: 69 */
            int32_t l_144 = (-1);
            uint32_t l_147 = 0xD0D1FC1C;
            for (l_130.f2 = 0; (l_130.f2 <= 4); ++l_130.f2)
            { /* block id: 72 */
                l_138 = 0xD808B432;
            }
            l_135 = ((((float)((((float)(((-(float)l_144) < p_84) != l_129) + (float)((float)l_147 - (float)l_138)) < ((((l_148 == (((l_130.f5 == ((float)((__builtin_popcount(l_138) <= (-0x10.0p+1)) >= 0x0.9p+1) + (float)l_144)) == l_144) != l_138)) >= l_147) < p_84) < 0x1.91C459p+58)) >= l_138) + (float)p_84) <= l_147) != p_84);
            l_135 = ((uint8_t)((l_144 <= ((l_144 && (-1)) == p_84)) ^ (l_138 < (((uint8_t)(((uint8_t)((l_144 & l_144) && ((uint16_t)p_84 - (uint16_t)p_84)) >> (uint8_t)3) != l_130.f4) << (uint8_t)p_84) >= 0x9B))) % (uint8_t)p_84);
        }
        else
        { /* block id: 77 */
            l_159 &= l_138;
            l_160 = l_160;
        }
        for (l_160.f1 = 0; (l_160.f1 >= 21); l_160.f1 += 5)
        { /* block id: 83 */
            struct S0 l_163 = {1,0x2E0D3681,0xC3B0D5B0,1U,17,4294967295U,-1};
            int32_t l_176 = 0x9CF0C6C1;
            int32_t l_177 = 0x540FA7CF;
            int32_t l_179 = (-1);
            int32_t l_182 = 0xABB6E3EA;
            uint32_t l_192 = 0x4B315FCE;
            l_164 = l_163;
            if (((uint16_t)65530U >> (uint16_t)((func_92(l_135, p_84) < (((((int8_t)(!l_130.f0) << (int8_t)(((int32_t)l_130.f6 - (int32_t)(0x99B7D335 && l_160.f0)) != p_84)) == p_84) >= 4294967295U) || 255U)) ^ 0x2D)))
            { /* block id: 85 */
                uint8_t l_172 = 0xB3;
                struct S0 l_173 = {0xFB,0x9008C5D1,0x8DA6205C,1U,-36,4294967293U,-10};
                l_164.f4 ^= ((l_172 >= ((l_129 < 1) <= l_129)) == p_84);
                l_164 = l_173;
            }
            else
            { /* block id: 88 */
                for (l_164.f1 = 18; (l_164.f1 < 5); l_164.f1 -= 7)
                { /* block id: 91 */
                    int8_t l_178 = (-1);
                    int32_t l_180 = 0xEEB66546;
                    int32_t l_181 = 0x95D89284;
                    int32_t l_183 = 0x6ABC8BB2;
                    uint8_t l_184 = 0x47;
                    l_184++;
                }
                l_164.f4 = 0x46FF5C8C;
            }
            for (l_164.f5 = (-1); (l_164.f5 > 26); l_164.f5 += 6)
            { /* block id: 98 */
                l_130.f4 = 0x24AF2DFD;
            }
            for (l_163.f3 = 17; (l_163.f3 <= 44); l_163.f3 += 9)
            { /* block id: 103 */
                uint16_t l_191 = 0x38F8;
                int32_t l_195 = 0x90F7100B;
                uint32_t l_196 = 0x0D73480D;
                l_191 = __builtin_bswap32(p_84);
                if (l_192)
                { /* block id: 105 */
                    for (l_163.f0 = (-12); (l_163.f0 != (-11)); ++l_163.f0)
                    { /* block id: 108 */
                        l_176 = l_163.f2;
                        l_195 = func_97(l_163.f4, l_160.f3, l_130.f0);
                        return l_164;
                    }
                }
                else
                { /* block id: 113 */
                    l_177 = (func_97(l_196, l_195, p_84) > (-(int8_t)0x11));
                }
                l_163.f4 = (p_84 >= p_84);
            }
        }
        l_164 = l_160;
    }
    else
    { /* block id: 120 */
        uint8_t l_200 = 0xCD;
        if (((uint8_t)p_84 >> (uint8_t)2))
        { /* block id: 121 */
            struct S0 l_208 = {0,0x482F0B70,4294967293U,0x5A,-5,1U,0x2045};
            uint32_t l_209 = 0x4D960969;
            ++l_200;
            if (l_135)
            { /* block id: 123 */
                uint16_t l_203 = 0U;
                l_203++;
                for (l_130.f1 = 0; (l_130.f1 <= 14); l_130.f1++)
                { /* block id: 127 */
                    return l_208;
                }
            }
            else
            { /* block id: 130 */
                return l_130;
            }
            l_135 &= l_209;
            l_135 = ((float)(((float)0x3.211D86p-42 + (float)l_130.f2) < (!(-0x5.1p-1))) + (float)0x0.7p+1);
        }
        else
        { /* block id: 135 */
            return l_130;
        }
    }
    l_130 = l_130;
    return l_130;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_92(float  p_93, uint16_t  p_94)
{ /* block id: 54 */
    uint8_t l_101 = 0xC9;
    int32_t l_109 = 0x44E30A6D;
    l_109 = (p_94 >= ((int8_t)(func_97(l_101, (((((float)(!((l_101 == (l_101 <= p_93)) < (l_101 == (((float)p_93 - (float)(p_93 == (l_101 <= 0x7.6FE95Bp+76))) > p_93)))) - (float)l_101) == l_101) != 0xE.9870F1p+77) <= 0x0.Ap+1), l_101) & l_101) >> (int8_t)5));
    p_93 = ((float)((float)(l_109 < ((float)((float)l_109 - (float)((float)l_109 - (float)l_101)) + (float)(((-(float)((float)l_109 + (float)(0x1.B6D913p-11 != (-(float)l_109)))) < p_93) == 0x0.Bp-1))) + (float)0x1.9p+1) - (float)p_93);
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_97(int8_t  p_98, float  p_99, uint8_t  p_100)
{ /* block id: 55 */
    for (p_100 = 0; (p_100 > 9); p_100++)
    { /* block id: 58 */
        if (p_100)
            break;
    }
    return p_98;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 281
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 22
XXX times a bitfields struct on RHS: 38
XXX times a single bitfield on LHS: 14
XXX times a single bitfield on RHS: 18

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 209
   depth: 2, occurrence: 39
   depth: 3, occurrence: 3
   depth: 4, occurrence: 8
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 8, occurrence: 4
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 4
   depth: 17, occurrence: 6
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 604
XXX times a non-volatile is write: 136
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 192
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 30
   depth: 2, occurrence: 35
   depth: 3, occurrence: 28
   depth: 4, occurrence: 41
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 33.8
XXX percentage an existing variable is used: 66.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

