/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3429239998
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int8_t g_4 = (-4);
static int32_t g_44 = 0xA3062A4B;
static int32_t g_50 = 0xF6A1C3D0;
static const int32_t *g_52 = &g_44;
static const int32_t **g_51 = &g_52;
static const uint32_t g_138 = 0x817F253A;
static int32_t **g_169 = (void*)0;
static int32_t ***g_168 = &g_169;
static int32_t *****g_190 = (void*)0;
static int8_t g_234 = 1;
static int32_t *g_294 = &g_50;


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_25(void);
static int16_t  func_31(const int16_t  p_32, uint32_t  p_33, int8_t  p_34);
inline static int32_t * func_39(int32_t * p_40, int32_t * p_41, int32_t * p_42);
static int32_t  func_72(int16_t  p_73, int32_t  p_74, int32_t  p_75, const int32_t  p_76);
inline static int32_t * func_78(uint32_t  p_79, uint32_t  p_80, int32_t  p_81, int32_t  p_82, int32_t * p_83);
static int32_t  func_96(uint32_t  p_97, const int32_t ** p_98, int32_t  p_99);
inline static const int32_t ** func_100(int32_t * p_101, int32_t *** p_102, uint32_t  p_103);
inline static int32_t *** func_104(int32_t ** p_105, uint32_t  p_106, uint32_t  p_107, uint16_t  p_108);
static int32_t ** func_109(uint32_t  p_110, int32_t  p_111, uint16_t  p_112, uint32_t  p_113, int32_t *** p_114);
inline static int16_t  func_116(int32_t  p_117, int16_t  p_118, uint32_t  p_119, int32_t *** p_120);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_44 g_51 g_138 g_52 g_168 g_50 g_190 g_234 g_294 g_169
 * writes: g_44 g_50 g_51 g_52 g_4 g_234 g_294 g_169
 */
inline static int16_t  func_25(void)
{ /* block id: 36 */
    const int16_t l_26 = 1;
    int32_t *l_450 = &g_50;
    (*l_450) = (l_26 & ((int16_t)((int16_t)func_31((((int16_t)(((int32_t)g_4 + (int32_t)g_4) < g_4) - (int16_t)(l_26 & (((g_4 & 4294967289U) & g_4) & l_26))) == l_26), l_26, g_4) >> (int16_t)15) + (int16_t)g_138));
    return (*l_450);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_44 g_51 g_138 g_52 g_168 g_50 g_190 g_234 g_294 g_169
 * writes: g_44 g_50 g_51 g_52 g_4 g_234 g_294 g_169
 */
static int16_t  func_31(const int16_t  p_32, uint32_t  p_33, int8_t  p_34)
{ /* block id: 37 */
    int32_t *l_43 = &g_44;
    int32_t **l_54 = &l_43;
    int8_t l_61 = 0x30;
    const uint32_t l_77 = 0xFE29F19B;
    int32_t *l_379 = &g_50;
    int32_t *****l_449 = (void*)0;
    (*l_54) = func_39(l_43, &g_44, l_43);
    if (((uint16_t)__builtin_bswap32((p_32 >= ((int16_t)((uint16_t)l_61 << (uint16_t)((*l_43) && (((int32_t)(!((((int16_t)((uint32_t)(-(uint16_t)(((int16_t)((*l_43) != (((func_72(((void*)0 == &l_54), p_34, (((__builtin_clzl((**l_54)) == p_32) && (**l_54)) <= 0x31355901), l_77) >= p_34) || 0x4D50) >= (**l_54))) - (int16_t)p_34) ^ g_44)) + (uint32_t)g_138) * (int16_t)(*l_43)) | p_32) <= 65529U)) + (int32_t)g_44) | 65527U))) >> (int16_t)1))) - (uint16_t)(*l_43)))
    { /* block id: 217 */
        int32_t *l_328 = &g_44;
        int32_t *l_367 = &g_50;
        int32_t ****l_372 = (void*)0;
        int32_t *l_446 = &g_50;
        for (g_4 = 0; (g_4 == 12); ++g_4)
        { /* block id: 220 */
            int32_t *l_332 = &g_50;
            int32_t ****l_343 = (void*)0;
            int32_t ***l_356 = &g_169;
            uint32_t l_405 = 0U;
            if ((l_328 == (void*)0))
            { /* block id: 221 */
                int16_t l_329 = 0xA992;
                uint32_t l_336 = 0x2069CC72;
                int32_t *l_353 = &g_44;
                uint32_t l_366 = 4U;
                int32_t *l_376 = (void*)0;
                int32_t *****l_387 = &l_343;
                if (l_329)
                { /* block id: 222 */
                    uint32_t l_333 = 0x60F23907;
                    int32_t l_334 = 0xBF066108;
                    int32_t *l_335 = &l_334;
                    int32_t ****l_340 = &g_168;
                    int32_t *****l_339 = &l_340;
                    (*l_54) = (void*)0;
                    for (g_44 = 5; (g_44 != 5); g_44 += 9)
                    { /* block id: 226 */
                        (*g_51) = l_332;
                    }
                    l_334 = (g_138 != l_333);
                    if (func_116((__builtin_bswap64((p_34 && (*l_332))) || (l_335 == &l_334)), g_50, l_336, &l_54))
                    { /* block id: 230 */
                        uint16_t l_349 = 0U;
                        int32_t l_352 = 0x35B3B32C;
                        (*g_294) = ((&g_51 == &l_54) != (__builtin_ctzll(((int16_t)(l_339 != (void*)0) - (int16_t)((uint16_t)((void*)0 == l_343) % (uint16_t)0xCDB7))) && (-(uint16_t)((uint16_t)g_4 * (uint16_t)0))));
                        l_352 = (((int16_t)((__builtin_popcountll((p_32 <= (p_34 > 8))) && (((l_349 != ((uint16_t)p_34 << (uint16_t)12)) > p_32) & __builtin_ffsll(p_32))) <= (*l_332)) << (int16_t)0) != l_336);
                        (*l_54) = func_39(l_353, func_39(l_328, func_39((*l_54), &l_352, &l_352), l_353), (*l_54));
                    }
                    else
                    { /* block id: 234 */
                        (*l_353) = (p_34 | 0x6280);
                        (*l_328) = ((int16_t)(func_116((((&l_43 == (void*)0) || (*l_353)) ^ (l_328 != l_328)), g_50, __builtin_ffsll(g_234), l_356) >= 1) % (int16_t)0xE775);
                        (*l_353) = ((uint16_t)(((int16_t)((uint32_t)(~p_32) - (uint32_t)((int16_t)g_4 + (int16_t)(p_32 & (__builtin_ctzll(p_32) || (__builtin_popcount(p_34) != 6U))))) * (int16_t)1U) == l_366) % (uint16_t)0xE069);
                        (*g_51) = l_367;
                    }
                }
                else
                { /* block id: 240 */
                    int32_t ****l_371 = &g_168;
                    (*l_43) = (((void*)0 != (*l_54)) >= ((*l_353) | ((((-(uint32_t)((int16_t)0 >> (int16_t)12)) <= ((l_371 != l_372) && (~(&g_51 != (void*)0)))) || (*l_332)) ^ (*l_353))));
                    for (l_329 = 0; (l_329 != (-21)); l_329 -= 1)
                    { /* block id: 244 */
                        int32_t *l_377 = (void*)0;
                        int32_t *l_378 = (void*)0;
                        (*g_51) = l_353;
                        l_377 = l_378;
                        (*l_332) = (**l_54);
                        l_379 = l_332;
                    }
                    (*l_328) = (*l_328);
                    (*l_379) = 0xE9E5505F;
                }
                (*g_294) = ((uint16_t)(~((uint32_t)((uint16_t)p_32 * (uint16_t)((p_33 && ((void*)0 == l_387)) == ((int16_t)(*l_353) - (int16_t)((uint16_t)(((int16_t)(0x4264617A <= (g_138 > ((int32_t)((uint16_t)g_4 << (uint16_t)15) % (int32_t)9U))) - (int16_t)g_234) ^ g_50) % (uint16_t)0x4ECB)))) % (uint32_t)(*l_353))) >> (uint16_t)p_33);
            }
            else
            { /* block id: 254 */
                int32_t l_406 = 0x3028F6AD;
                int32_t *l_426 = &g_44;
                int32_t ***l_443 = &l_54;
                (*l_356) = (*g_168);
                if (((-(int32_t)((9U & ((*l_379) < ((((uint16_t)((int16_t)p_33 >> (int16_t)15) >> (uint16_t)(p_34 <= (func_116((9 < (((((int16_t)(l_405 > g_234) + (int16_t)0x50CE) || (*g_294)) != (*l_367)) <= g_138)), g_4, g_4, &l_54) | l_406))) || l_406) & (*l_43)))) > l_406)) == 0U))
                { /* block id: 256 */
                    int32_t *l_423 = &g_50;
                    (*l_367) = ((int16_t)((*l_379) == (p_32 < ((uint32_t)((void*)0 != g_190) - (uint32_t)(((uint16_t)p_34 * (uint16_t)0x94C4) >= ((int16_t)((uint16_t)(((-(int16_t)((uint16_t)p_33 << (uint16_t)((-(int16_t)l_406) ^ p_34))) || 1U) >= p_33) * (uint16_t)0) >> (int16_t)(**l_54)))))) + (int16_t)65532U);
                    if (p_34)
                        continue;
                    if (((*l_356) == (void*)0))
                    { /* block id: 259 */
                        return g_4;
                    }
                    else
                    { /* block id: 261 */
                        int32_t *l_424 = &g_50;
                        l_424 = l_423;
                        (*g_51) = (*l_54);
                    }
                    (*g_51) = (void*)0;
                }
                else
                { /* block id: 266 */
                    int32_t *l_425 = (void*)0;
                    int32_t *l_444 = &g_44;
                    l_426 = l_425;
                    if (p_32)
                    { /* block id: 268 */
                        int16_t l_427 = 1;
                        l_427 = (*l_332);
                        if (p_34)
                            break;
                        (*l_54) = l_425;
                    }
                    else
                    { /* block id: 272 */
                        int32_t *l_445 = &g_44;
                        (***l_443) = ((1U != (1 <= (!4294967292U))) < ((uint16_t)((int16_t)(func_116(((g_4 || 0x1689) == ((uint32_t)p_33 + (uint32_t)((int16_t)(((p_32 > ((g_138 ^ ((int16_t)((int16_t)((int32_t)(-1) + (int32_t)0x3D20C551) * (int16_t)0) % (int16_t)g_138)) < p_32)) >= g_44) != g_138) >> (int16_t)p_34))), g_44, (*l_328), l_443) >= 4294967292U) + (int16_t)g_234) * (uint16_t)g_138));
                        l_425 = func_39(l_444, l_445, l_446);
                        (*l_446) = p_34;
                        l_445 = (**l_443);
                    }
                    for (p_33 = (-22); (p_33 > 25); p_33 += 6)
                    { /* block id: 280 */
                        (*g_294) = (1 == (((*l_54) == l_425) || g_44));
                        (*l_328) = (1 && 0x0C28ACF7);
                    }
                }
            }
            (*l_54) = l_446;
            l_449 = l_449;
        }
    }
    else
    { /* block id: 289 */
        (*l_43) = 0;
        (*g_294) = 3;
    }
    return (**l_54);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_44 g_51
 * writes: g_44 g_50 g_51
 */
inline static int32_t * func_39(int32_t * p_40, int32_t * p_41, int32_t * p_42)
{ /* block id: 38 */
    (*p_41) = ((-8) <= ((int16_t)(g_4 == g_4) << (int16_t)10));
    for (g_44 = 20; (g_44 <= (-28)); g_44 -= 7)
    { /* block id: 42 */
        int32_t *l_49 = &g_50;
        const int32_t ***l_53 = &g_51;
        (*l_49) = __builtin_ctzl(g_4);
        (*l_53) = g_51;
    }
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_51 g_138 g_52 g_168 g_4 g_50 g_190 g_234 g_294
 * writes: g_52 g_50 g_4 g_51 g_234 g_294
 */
static int32_t  func_72(int16_t  p_73, int32_t  p_74, int32_t  p_75, const int32_t  p_76)
{ /* block id: 48 */
    int16_t l_121 = 0xF1E5;
    int32_t **l_123 = (void*)0;
    int32_t ***l_122 = &l_123;
    int32_t ***l_126 = &l_123;
    uint32_t l_210 = 0x73C3FA53;
    int32_t *l_211 = &g_44;
    int32_t **l_312 = (void*)0;
    int32_t **l_313 = &g_294;
    (*l_313) = func_78((((int16_t)((((uint32_t)((int32_t)((int32_t)((uint16_t)((int32_t)(g_44 ^ 0xF5F1) % (int32_t)p_74) % (uint16_t)(((func_96(p_73, func_100(&g_50, func_104(func_109(p_73, (!p_74), (func_116(__builtin_popcount(l_121), l_121, p_76, l_122) | p_74), p_75, l_126), p_74, p_73, p_73), p_74), p_75) < g_44) >= p_74) ^ g_138)) + (int32_t)l_210) - (int32_t)p_74) + (uint32_t)4294967288U) != p_73) == g_138) * (int16_t)0) & 0x80477419), g_138, p_76, p_76, l_211);
    (*g_51) = &p_74;
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_50 g_234 g_4 g_51 g_138 g_52 g_190 g_294
 * writes: g_50 g_52 g_4 g_51 g_234
 */
inline static int32_t * func_78(uint32_t  p_79, uint32_t  p_80, int32_t  p_81, int32_t  p_82, int32_t * p_83)
{ /* block id: 144 */
    uint32_t l_213 = 1U;
    int32_t *l_240 = &g_50;
    int32_t **l_239 = &l_240;
    uint32_t l_303 = 4294967295U;
    if ((*p_83))
    { /* block id: 145 */
        int16_t l_212 = 0x87EC;
        int32_t *l_216 = (void*)0;
        int32_t *l_217 = &g_50;
        int32_t ***l_223 = (void*)0;
        const int32_t **l_255 = &g_52;
        l_213 = l_212;
        (*l_217) = ((uint16_t)l_212 >> (uint16_t)__builtin_popcountll(l_213));
        for (p_82 = 0; (p_82 > 23); p_82++)
        { /* block id: 150 */
            int32_t **l_222 = &l_217;
            uint16_t l_224 = 0x8A67;
            int32_t ****l_233 = &g_168;
            (**l_222) = ((int32_t)(((*p_83) || (0xC3721EA1 & (&p_83 != l_222))) != (((0x47188FCF && (&g_169 != l_223)) || (((-7) & (0x3ECD7A14 == 0xB4E0D6F0)) > (*p_83))) <= (**l_222))) + (int32_t)l_224);
            (**l_222) = ((uint32_t)((int16_t)((((*l_222) != (void*)0) <= __builtin_ffsl((l_213 <= (((*p_83) <= ((uint32_t)1U - (uint32_t)((int32_t)(&l_223 == l_233) % (int32_t)5))) == g_234)))) != (*p_83)) * (int16_t)0x26FF) % (uint32_t)l_213);
            if (((0x906C09E5 > ((int16_t)3 << (int16_t)(((((((((((*l_217) != g_44) > g_234) || ((-1) < (((int32_t)(l_213 | (*p_83)) + (int32_t)(l_239 == &p_83)) & (*p_83)))) & g_4) <= 1U) > p_81) || (*p_83)) >= 0x2662) ^ (**l_222)) <= 3))) && 4294967295U))
            { /* block id: 153 */
                int32_t *****l_241 = &l_233;
                l_241 = &l_233;
            }
            else
            { /* block id: 155 */
                const int32_t *l_242 = &g_50;
                int32_t ****l_250 = &l_223;
                (*g_51) = l_242;
                if ((*p_83))
                { /* block id: 157 */
                    int32_t l_243 = 0x4B716627;
                    (*l_217) = ((l_243 > (g_44 | ((uint32_t)0U % (uint32_t)g_44))) > p_80);
                    for (g_4 = (-18); (g_4 > 17); g_4 += 9)
                    { /* block id: 161 */
                        (*l_222) = &p_81;
                    }
                    for (l_213 = (-21); (l_213 < 21); ++l_213)
                    { /* block id: 166 */
                        (**l_222) = ((__builtin_ia32_crc32qi((((void*)0 != &p_81) | g_50), g_44) || __builtin_popcountl(p_79)) < 0xCDD416DD);
                    }
                }
                else
                { /* block id: 169 */
                    (**l_239) = (((void*)0 != l_250) || (g_138 | (p_81 == 0x739138BC)));
                }
                (**l_239) = (**l_222);
                if ((*p_83))
                    continue;
            }
        }
        for (l_212 = 0; (l_212 >= 13); ++l_212)
        { /* block id: 178 */
            int32_t l_262 = (-2);
            int32_t *****l_311 = (void*)0;
            if (((uint16_t)func_96((**l_239), l_255, (*p_83)) >> (uint16_t)12))
            { /* block id: 179 */
                int32_t l_277 = 1;
                (*l_240) = (__builtin_clzll(g_50) != 8U);
                if (((g_234 == __builtin_clzll((*l_240))) & 0U))
                { /* block id: 181 */
                    uint16_t l_265 = 0x3615;
                    int32_t ***l_276 = &g_169;
                    for (g_234 = 10; (g_234 >= (-19)); g_234 -= 1)
                    { /* block id: 184 */
                        int32_t l_275 = 3;
                        (*l_217) = (((int32_t)(*l_240) + (int32_t)((uint32_t)p_80 - (uint32_t)l_262)) & (((int32_t)0xB81DFD58 % (int32_t)__builtin_ctzll(((l_265 == (((int16_t)p_82 % (int16_t)(~((int16_t)((int16_t)(0U > ((int32_t)(*p_83) - (int32_t)func_116(l_275, l_262, p_79, l_276))) % (int16_t)l_277) * (int16_t)g_234))) != 4294967295U)) <= g_138))) != g_44));
                        return &g_44;
                    }
                }
                else
                { /* block id: 188 */
                    uint32_t l_289 = 5U;
                    (*l_217) = __builtin_bswap64(((uint16_t)((g_50 <= (((uint16_t)((int16_t)(9 > (__builtin_clzll(g_234) && ((((uint32_t)(-(uint32_t)g_138) + (uint32_t)(((((int32_t)(-4) % (int32_t)func_116(p_79, l_289, g_234, &l_239)) ^ 0x890C0586) == (*p_83)) >= 1U)) || p_82) == 0U))) * (int16_t)l_262) << (uint16_t)g_50) >= l_289)) <= 4294967295U) << (uint16_t)8));
                    return &g_44;
                }
                for (g_4 = 0; (g_4 < (-22)); g_4 -= 4)
                { /* block id: 194 */
                    (*g_51) = (*g_51);
                    (*l_217) = (*p_83);
                    for (p_80 = 0; (p_80 < 26); p_80 += 1)
                    { /* block id: 199 */
                        return g_294;
                    }
                }
                (*g_51) = &p_81;
            }
            else
            { /* block id: 204 */
                (*l_255) = (*g_51);
                (**l_239) = ((uint32_t)((*p_83) || (__builtin_clzll(((int32_t)(*p_83) % (int32_t)(*l_240))) | ((uint16_t)((uint16_t)p_79 * (uint16_t)l_303) * (uint16_t)(((uint32_t)((uint16_t)__builtin_ia32_crc32qi(p_82, ((int16_t)l_262 << (int16_t)(((~(l_311 != l_311)) || (*l_217)) || 1U))) + (uint16_t)p_82) + (uint32_t)3) < p_82)))) + (uint32_t)(*l_217));
                (*l_239) = &p_81;
            }
        }
    }
    else
    { /* block id: 210 */
        (*g_51) = (*g_51);
    }
    return &g_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_51 g_44 g_138 g_52 g_50 g_190
 * writes: g_4 g_52 g_51 g_50
 */
static int32_t  func_96(uint32_t  p_97, const int32_t ** p_98, int32_t  p_99)
{ /* block id: 104 */
    const uint16_t l_182 = 0x4015;
    int32_t *l_199 = (void*)0;
    int32_t ***l_203 = &g_169;
    for (g_4 = 18; (g_4 == 4); g_4 -= 1)
    { /* block id: 107 */
        int16_t l_184 = 0x1386;
        int32_t ***l_198 = &g_169;
        int32_t *l_201 = &g_44;
        int32_t *l_206 = &g_50;
        (*g_51) = (void*)0;
        for (p_99 = (-11); (p_99 <= 14); p_99 += 8)
        { /* block id: 111 */
            int32_t ****l_183 = &g_168;
            int32_t l_200 = (-1);
            if ((((void*)0 == &g_168) | ((uint32_t)__builtin_clzl(func_116(((int16_t)p_97 * (int16_t)(__builtin_clz(g_4) | l_182)), g_44, g_138, &g_169)) % (uint32_t)(-1))))
            { /* block id: 112 */
                (*g_51) = (*g_51);
                (*g_51) = (*g_51);
            }
            else
            { /* block id: 115 */
                int16_t l_197 = 0xFEBF;
                int32_t *l_205 = (void*)0;
                if ((l_183 == &g_168))
                { /* block id: 116 */
                    int32_t *l_202 = &g_50;
                    if (func_116(l_184, g_50, (1U != ((int16_t)(((((uint16_t)g_44 + (uint16_t)(~(((((void*)0 != g_190) < (((int16_t)g_44 >> (int16_t)((uint16_t)((p_97 & ((int32_t)0x0892C684 % (int32_t)g_138)) < l_182) * (uint16_t)0x6667)) > g_4)) != l_197) & 1))) <= g_4) | l_184) | g_44) >> (int16_t)l_182)), l_198))
                    { /* block id: 117 */
                        (*p_98) = l_199;
                        l_200 = g_138;
                        (*g_51) = (*g_51);
                        (*g_51) = l_201;
                    }
                    else
                    { /* block id: 122 */
                        const int32_t ***l_204 = &g_51;
                        (*l_204) = func_100(l_202, l_203, g_44);
                        return p_97;
                    }
                    (*p_98) = l_205;
                }
                else
                { /* block id: 127 */
                    return p_99;
                }
            }
            (*g_51) = (*p_98);
        }
        (*l_206) = (*l_201);
        for (p_99 = (-21); (p_99 == 28); p_99 += 8)
        { /* block id: 136 */
            const int32_t *l_209 = &g_44;
            (*g_51) = l_209;
            (*g_51) = l_209;
        }
    }
    (*p_98) = l_199;
    (*g_51) = (void*)0;
    return l_182;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t ** func_100(int32_t * p_101, int32_t *** p_102, uint32_t  p_103)
{ /* block id: 101 */
    int32_t *****l_170 = (void*)0;
    const int32_t **l_171 = &g_52;
    l_170 = l_170;
    return l_171;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_168
 * writes: g_50 g_52
 */
inline static int32_t *** func_104(int32_t ** p_105, uint32_t  p_106, uint32_t  p_107, uint16_t  p_108)
{ /* block id: 97 */
    uint16_t l_166 = 0U;
    int32_t *l_167 = &g_50;
    g_50 = l_166;
    (*g_51) = l_167;
    return g_168;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_138 g_44 g_52
 * writes: g_50 g_52
 */
static int32_t ** func_109(uint32_t  p_110, int32_t  p_111, uint16_t  p_112, uint32_t  p_113, int32_t *** p_114)
{ /* block id: 52 */
    int32_t l_140 = 0;
    uint32_t l_161 = 0x5BC70674;
    int32_t *l_165 = (void*)0;
    for (p_110 = (-26); (p_110 <= 15); p_110++)
    { /* block id: 55 */
        int32_t l_131 = (-2);
        for (p_111 = 0; (p_111 <= 20); p_111++)
        { /* block id: 58 */
            int32_t *l_132 = &g_50;
            (*l_132) = l_131;
        }
        (*g_51) = &l_131;
        for (p_112 = 0; (p_112 >= 26); p_112 += 4)
        { /* block id: 64 */
            uint16_t l_139 = 0x2643;
            int32_t l_141 = 0x2D756AA3;
            int32_t *l_142 = &g_50;
            int32_t *l_146 = &l_140;
            int8_t l_151 = 0x86;
            uint32_t l_160 = 0xC7BDE7BC;
            (*l_142) = (((int16_t)(-6) << (int16_t)(((((void*)0 == p_114) < (-(uint32_t)(l_131 || __builtin_parityl(((0x0C3E == g_138) | (((((l_139 < g_44) ^ (0x104D == l_140)) <= g_44) ^ p_111) && l_131)))))) || (**g_51)) && p_110)) | l_141);
            (*g_51) = &l_131;
            if ((*g_52))
            { /* block id: 67 */
                const int32_t ***l_148 = (void*)0;
                const int32_t ****l_147 = &l_148;
                for (p_111 = 0; (p_111 > (-28)); p_111 -= 1)
                { /* block id: 70 */
                    int32_t *l_145 = &l_131;
                    if (l_140)
                        break;
                    l_146 = l_145;
                    if (l_140)
                        continue;
                }
                (*l_147) = (void*)0;
                (*l_142) = ((uint16_t)(0x5683E25F > l_140) << (uint16_t)__builtin_ia32_crc32qi(l_151, p_111));
            }
            else
            { /* block id: 77 */
                const uint32_t l_157 = 0xE15E87F6;
                for (l_141 = 0; (l_141 != 15); l_141++)
                { /* block id: 80 */
                    (*l_142) = ((&g_51 == (void*)0) < (((uint32_t)((**g_51) != ((*g_52) < (*g_52))) % (uint32_t)(~l_157)) != (p_113 || ((*l_146) != 0U))));
                }
                if (l_160)
                    break;
                (*l_142) = l_161;
            }
        }
        (*g_51) = &l_131;
    }
    if (((int32_t)0x5FDEB794 + (int32_t)((g_44 & (-1)) | ((void*)0 != &p_114))))
    { /* block id: 89 */
        (*g_51) = &l_140;
    }
    else
    { /* block id: 91 */
        int32_t *l_164 = &g_50;
        l_165 = l_164;
        (*g_51) = &l_140;
        l_165 = l_164;
    }
    return (*p_114);
}


/* ------------------------------------------ */
/* 
 * reads : g_51
 * writes: g_52
 */
inline static int16_t  func_116(int32_t  p_117, int16_t  p_118, uint32_t  p_119, int32_t *** p_120)
{ /* block id: 49 */
    int32_t *l_124 = (void*)0;
    int8_t l_125 = 0xC5;
    (*g_51) = l_124;
    return l_125;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_234, "g_234", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 104
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 188
   depth: 2, occurrence: 27
   depth: 3, occurrence: 2
   depth: 4, occurrence: 6
   depth: 5, occurrence: 5
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 28, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 92

XXX times a variable address is taken: 93
XXX times a pointer is dereferenced on RHS: 79
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 13
XXX times a pointer is dereferenced on LHS: 79
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 470

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 375
   level: 2, occurrence: 113
   level: 3, occurrence: 31
   level: 4, occurrence: 6
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 45
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.4
XXX average alias set size: 1.32

XXX times a non-volatile is read: 512
XXX times a non-volatile is write: 204
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 156
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 22
   depth: 2, occurrence: 15
   depth: 3, occurrence: 25
   depth: 4, occurrence: 32
   depth: 5, occurrence: 35

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
********************* end of statistics **********************/

