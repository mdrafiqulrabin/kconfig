/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2850824782
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   uint32_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static struct S0  func_30(uint32_t  p_31, int32_t  p_32, uint16_t  p_33, struct S0  p_34, float  p_35);
inline static struct S0  func_37(struct S0  p_38, struct S0  p_39, int32_t  p_40, uint32_t  p_41);
static struct S0  func_42(struct S0  p_43, int16_t  p_44, uint32_t  p_45, uint32_t  p_46);
static struct S0  func_47(uint32_t  p_48);
static struct S0  func_54(uint32_t  p_55, int8_t  p_56);
inline static uint16_t  func_76(uint32_t  p_77, int32_t  p_78, uint32_t  p_79, int32_t  p_80, float  p_81);
static uint32_t  func_85(int8_t  p_86, int32_t  p_87);
inline static float  func_97(uint32_t  p_98);
static int32_t  func_107(float  p_108, int16_t  p_109);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_36 = 4294967295U;
    struct S0 l_419 = {0xC10FEC88,0x62FC,0x26670401,0xF7FF7380,4294967293U,1U};
    l_419 = func_30(l_36, l_36, l_36, func_37(func_42(func_47(((int16_t)l_36 >> (int16_t)8)), l_36, l_36, l_36), l_419, l_419.f3, l_419.f1), l_419.f4);
    return l_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_30(uint32_t  p_31, int32_t  p_32, uint16_t  p_33, struct S0  p_34, float  p_35)
{ /* block id: 180 */
    float l_424 = 0x4.3p+1;
    int32_t l_425 = 1;
    uint32_t l_426 = 7U;
    struct S0 l_427 = {1U,0x0E28,0xF59E0E92,0xB7875852,0U,0x593E4FAC};
    l_426 = ((uint16_t)l_425 * (uint16_t)p_31);
    return l_427;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_37(struct S0  p_38, struct S0  p_39, int32_t  p_40, uint32_t  p_41)
{ /* block id: 177 */
    float l_420 = 0x5.7p-1;
    int32_t l_421 = (-4);
    l_421 = p_39.f1;
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_42(struct S0  p_43, int16_t  p_44, uint32_t  p_45, uint32_t  p_46)
{ /* block id: 41 */
    struct S0 l_417 = {0x68B05920,0U,0x0A357053,1,0U,0x15BD37BD};
    int8_t l_418 = 0xB8;
    l_417 = func_54(p_43.f2, p_43.f4);
    l_418 = l_417.f0;
    l_417.f3 = 7;
    p_43 = p_43;
    return l_417;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_47(uint32_t  p_48)
{ /* block id: 37 */
    uint16_t l_51 = 0x3C44;
    int32_t l_52 = 0x44F34D89;
    struct S0 l_53 = {2U,65533U,0U,-9,0xCCFDEF05,0xE082ADE8};
    l_51 = p_48;
    l_52 = p_48;
    return l_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_54(uint32_t  p_55, int8_t  p_56)
{ /* block id: 42 */
    float l_72 = (-0x5.6p-1);
    int32_t l_73 = 0x4F7CB2C1;
    uint32_t l_82 = 4294967295U;
    float l_392 = 0x1.BF82B2p-29;
    int32_t l_412 = 0xEAA90E3A;
    uint32_t l_413 = 0xAB2B7545;
    uint16_t l_414 = 0xFAAB;
    int32_t l_415 = 0;
    struct S0 l_416 = {4294967295U,65535U,0xC02E2F53,0,4294967290U,0x7D4182CB};
    for (p_56 = 0; (p_56 == 24); p_56 += 5)
    { /* block id: 45 */
        int16_t l_70 = 0xF37D;
        int32_t l_390 = 0xFF306726;
        l_73 = (((int16_t)((int16_t)(p_56 > (((~0xCE71C9EE) || ((((int16_t)((uint16_t)0U % (uint16_t)p_55) * (int16_t)((int16_t)0xF1C2 * (int16_t)p_55)) < __builtin_ffsll(l_70)) != __builtin_parityl((~p_55)))) ^ 1)) * (int16_t)p_56) << (int16_t)9) | p_55);
        l_73 = (((uint16_t)func_76(l_82, l_82, ((uint32_t)p_56 + (uint32_t)(__builtin_parityl(p_55) & (0U && (func_85(l_82, p_55) || 0x9EE725D3)))), p_56, p_55) << (uint16_t)l_70) > p_55);
        for (l_73 = (-4); (l_73 < 19); l_73 += 3)
        { /* block id: 163 */
            uint32_t l_389 = 0U;
            l_390 = l_389;
        }
        l_73 = (p_56 > l_82);
    }
    l_73 = p_55;
    l_412 = ((!((l_392 != l_73) < (l_82 >= ((float)(+p_55) / (float)(p_55 >= ((float)((((float)((-0x7.Dp+1) == ((float)l_82 - (float)func_97((l_73 & (((int32_t)((uint16_t)__builtin_clzll(((uint16_t)((uint16_t)((((int16_t)func_76(l_82, l_412, l_73, l_412, p_56) / (int16_t)0x7BF9) || l_413) == p_56) << (uint16_t)p_55) >> (uint16_t)l_413)) << (uint16_t)l_82) % (int32_t)0xDE64486F) <= l_414))))) + (float)0x0.4p+1) == l_415) > l_413) * (float)l_414)))))) <= (-0x1.2p-1));
    l_416 = l_416;
    return l_416;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_76(uint32_t  p_77, int32_t  p_78, uint32_t  p_79, int32_t  p_80, float  p_81)
{ /* block id: 158 */
    uint32_t l_386 = 0x7B09AB5F;
    return l_386;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_85(int8_t  p_86, int32_t  p_87)
{ /* block id: 47 */
    int32_t l_379 = (-7);
    int32_t l_384 = 1;
    struct S0 l_385 = {0x5246273A,0xDB63,0x8C6F954E,0x6FA8E486,4294967295U,0xDE4736B5};
    for (p_86 = 0; (p_86 > (-1)); p_86 -= 1)
    { /* block id: 50 */
        uint32_t l_90 = 0x318E2BB1;
        if (l_90)
            break;
        l_379 = ((float)(((float)((((float)(-0x1.8p+1) - (float)p_86) != (l_90 == p_86)) == (func_97(l_90) == ((float)p_87 + (float)((float)(+((float)(l_90 > ((float)p_87 + (float)p_87)) / (float)l_90)) - (float)0xF.8453F7p+55)))) - (float)l_90) < l_90) + (float)p_87);
        return l_90;
    }
    l_384 = __builtin_popcountl(func_107((((-0x5.2p-1) <= (p_86 > (((float)(p_87 == (-0x1.Dp-1)) + (float)(l_379 != p_87)) >= ((float)func_107(l_379, p_87) + (float)l_379)))) >= p_86), p_87));
    l_385 = l_385;
    return l_385.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_97(uint32_t  p_98)
{ /* block id: 52 */
    float l_99 = 0xA.EA093Ep+24;
    int32_t l_100 = 3;
    int8_t l_199 = 9;
    struct S0 l_216 = {0x16AA09A3,0U,0x1EFC347C,0,0xD9846AC9,0x2BC75856};
    int16_t l_234 = 0xA27B;
    uint16_t l_265 = 0x1765;
    int32_t l_288 = 5;
    int32_t l_307 = 2;
    struct S0 l_368 = {4U,65527U,4294967295U,-2,0xC854347F,0xA0CE1D5C};
    uint32_t l_369 = 0x9F8DC624;
    l_100 = l_100;
    l_100 = p_98;
    for (p_98 = 0; (p_98 != 32); p_98 += 1)
    { /* block id: 57 */
        int32_t l_135 = 0;
        int32_t l_147 = 1;
        int32_t l_204 = 0xFE8AC17F;
        struct S0 l_218 = {4294967295U,6U,0xFFC910CF,0x7CF8FE10,4294967295U,0U};
        if ((((uint16_t)(((int32_t)func_107(l_100, l_100) + (int32_t)((uint32_t)l_135 % (uint32_t)__builtin_bswap32(p_98))) == (-(int16_t)((int16_t)((int32_t)(func_107(((float)((float)((float)__builtin_parityll(__builtin_parity(p_98)) - (float)l_100) * (float)l_100) + (float)l_100), l_147) < 3) % (int32_t)l_100) >> (int16_t)11))) % (uint16_t)p_98) | 0xD651))
        { /* block id: 65 */
            int16_t l_179 = 0x5226;
            int32_t l_196 = (-10);
            struct S0 l_217 = {0xDD90FB3C,0U,0xEDC9179A,0,4294967294U,0xD507010F};
            for (l_147 = 0; (l_147 >= (-9)); l_147 -= 2)
            { /* block id: 68 */
                l_100 = ((uint32_t)(l_147 | ((__builtin_bswap64(p_98) <= (-4)) & ((uint16_t)0U << (uint16_t)10))) - (uint32_t)((uint32_t)((int16_t)func_107(l_135, p_98) << (int16_t)3) + (uint32_t)((int32_t)p_98 % (int32_t)p_98)));
                l_100 = p_98;
                l_100 = p_98;
                return p_98;
            }
            if (((int16_t)((int16_t)((int16_t)((uint32_t)p_98 / (uint32_t)((int32_t)__builtin_clz(p_98) + (int32_t)l_135)) >> (int16_t)(-(int32_t)(__builtin_bswap64(__builtin_popcountll(p_98)) <= 1))) * (int16_t)(p_98 != l_135)) + (int16_t)l_147))
            { /* block id: 74 */
                int16_t l_195 = 0xB1BB;
                l_196 = ((float)(__builtin_parityll((((((int32_t)((((uint16_t)l_100 >> (uint16_t)11) && ((uint32_t)(((l_179 | (((int16_t)p_98 << (int16_t)2) & (!((uint32_t)l_179 % (uint32_t)((uint16_t)((((uint16_t)__builtin_popcountll(p_98) << (uint16_t)((int32_t)(p_98 <= ((+(-(int16_t)((((uint16_t)((p_98 ^ l_179) && (-4)) >> (uint16_t)13) == p_98) > p_98))) || l_135)) / (int32_t)0x5982E876)) | p_98) ^ l_147) >> (uint16_t)p_98))))) | 9U) | l_100) + (uint32_t)l_179)) && l_195) + (int32_t)l_179) & 65535U) <= l_135) <= 0xB48C)) > 0x9.490DA0p+26) - (float)0x0.0p-1);
                l_100 = p_98;
                if (l_196)
                    continue;
            }
            else
            { /* block id: 78 */
                int32_t l_211 = 0;
                for (l_135 = 0; (l_135 >= 25); l_135++)
                { /* block id: 81 */
                    int16_t l_206 = 0x8E98;
                    if (l_199)
                        break;
                    l_100 = ((uint16_t)((p_98 > (((int16_t)l_204 << (int16_t)14) > l_135)) == ((-(int16_t)l_206) ^ ((uint16_t)(((int32_t)(((l_211 | 0x3B27) <= (((int16_t)((((uint16_t)((l_100 > (l_204 && p_98)) == l_211) >> (uint16_t)l_206) == 0x304A0B4B) <= l_196) - (int16_t)p_98) || l_211)) <= p_98) - (int32_t)l_206) | p_98) - (uint16_t)p_98))) >> (uint16_t)10);
                    l_211 = l_211;
                }
                l_217 = l_216;
                l_211 = l_211;
                l_135 = __builtin_clzll(l_135);
            }
            l_218 = l_217;
        }
        else
        { /* block id: 91 */
            uint32_t l_219 = 0U;
            int32_t l_309 = 1;
            uint32_t l_320 = 1U;
            if ((65534U | ((p_98 ^ (0x8D21332A && (((l_219 != (p_98 & ((uint16_t)((uint16_t)p_98 >> (uint16_t)(((uint16_t)(((func_107(p_98, (1U | l_219)) == p_98) <= 1U) && p_98) - (uint16_t)1U) ^ p_98)) >> (uint16_t)l_219))) >= 0) && p_98))) | p_98)))
            { /* block id: 92 */
                uint32_t l_231 = 0x3CA1DE74;
                int32_t l_244 = 0x1F0D64EE;
                struct S0 l_245 = {0U,2U,0x7826B081,0x9AE0601F,0xE91F21F2,0U};
                int32_t l_259 = 0xC93FC3FC;
                if (p_98)
                { /* block id: 93 */
                    int32_t l_242 = (-4);
                    if ((-(uint16_t)(0xF29C22F7 >= ((0x48DD3C90 > ((__builtin_parity(((uint16_t)((l_219 < __builtin_ctzl(((int32_t)((((l_219 || (l_231 > (((uint16_t)0U / (uint16_t)l_234) || p_98))) || ((-1) || 0x5E6F)) <= 0x5245F2AE) & p_98) + (int32_t)p_98))) && p_98) % (uint16_t)p_98)) <= l_231) != 0x1761CDC3)) && p_98))))
                    { /* block id: 94 */
                        l_242 = ((float)(+(((l_231 > ((-0x1.4p+1) <= ((float)p_98 * (float)l_216.f2))) == ((p_98 < p_98) >= func_107((p_98 <= 0x7.F510E3p+11), ((int16_t)(l_231 > l_219) / (int16_t)l_231)))) < l_147)) * (float)p_98);
                    }
                    else
                    { /* block id: 96 */
                        uint32_t l_243 = 4294967288U;
                        l_244 = l_243;
                    }
                    l_244 = p_98;
                    l_245 = l_218;
                }
                else
                { /* block id: 101 */
                    int8_t l_255 = 0xDB;
                    for (l_216.f2 = 22; (l_216.f2 < 28); l_216.f2 += 1)
                    { /* block id: 104 */
                        uint32_t l_256 = 4294967291U;
                        int32_t l_270 = 0x1929A791;
                        l_256 = ((uint32_t)__builtin_ctzl(l_218.f2) - (uint32_t)((int16_t)((+((-9) < (4 <= ((((int16_t)((((p_98 <= l_199) || p_98) && 0xD50CF4A1) & l_219) << (int16_t)l_255) ^ (-8)) <= p_98)))) || p_98) >> (int16_t)4));
                        l_270 = ((int16_t)l_259 + (int16_t)((uint32_t)((uint32_t)(-(uint32_t)(l_218.f4 >= p_98)) + (uint32_t)(((p_98 <= (4294967292U >= (l_265 == ((int16_t)((uint32_t)p_98 - (uint32_t)l_259) / (int16_t)l_216.f3)))) > p_98) != l_234)) % (uint32_t)l_218.f0));
                    }
                }
            }
            else
            { /* block id: 109 */
                uint16_t l_286 = 0U;
                int32_t l_289 = 0x7A455B6F;
                int16_t l_308 = 0x5224;
                struct S0 l_310 = {0xE2A1E260,1U,4294967289U,2,0x93766C54,4294967287U};
                l_135 = 0xE7FC4C37;
                if ((p_98 != p_98))
                { /* block id: 111 */
                    uint32_t l_287 = 0x0E2ED7CC;
                    l_289 = ((int32_t)((int32_t)(((((uint16_t)p_98 + (uint16_t)((uint16_t)(-(uint16_t)((4294967290U == ((int16_t)0x5D05 % (int16_t)0xFEA6)) <= ((int16_t)p_98 + (int16_t)((uint32_t)(__builtin_ffsll(p_98) ^ (l_286 != 0xC62B)) + (uint32_t)p_98)))) / (uint16_t)l_286)) ^ 4294967295U) >= p_98) || l_287) + (int32_t)l_288) + (int32_t)p_98);
                    for (l_218.f0 = 0; (l_218.f0 == 41); l_218.f0 += 1)
                    { /* block id: 115 */
                        int32_t l_304 = (-1);
                        l_309 = ((int16_t)(((int16_t)((uint32_t)((int16_t)((int16_t)p_98 % (int16_t)((((uint32_t)l_304 / (uint32_t)p_98) <= p_98) ^ (func_107((p_98 >= (__builtin_popcountl(l_100) == ((float)l_307 - (float)p_98))), l_219) || 0))) + (int16_t)l_287) + (uint32_t)l_219) * (int16_t)l_219) ^ p_98) + (int16_t)l_308);
                        l_289 = func_107(p_98, p_98);
                    }
                    l_310 = l_218;
                }
                else
                { /* block id: 120 */
                    if (p_98)
                        break;
                }
                for (l_310.f0 = 0; (l_310.f0 >= 42); l_310.f0 += 2)
                { /* block id: 125 */
                    l_310.f3 = p_98;
                }
            }
            l_218.f3 = __builtin_ctzll((!((uint16_t)l_218.f3 * (uint16_t)((int32_t)(((uint32_t)(((func_107(__builtin_popcountll(func_107(l_320, ((int32_t)((uint16_t)((p_98 ^ (0x94085A30 <= __builtin_ctzll((p_98 != 7)))) > p_98) % (uint16_t)l_216.f4) + (int32_t)l_216.f0))), l_218.f4) & l_216.f0) | l_288) >= l_216.f1) / (uint32_t)l_219) <= 0x03AC) - (int32_t)l_309))));
            for (l_216.f4 = 10; (l_216.f4 > 19); l_216.f4 += 1)
            { /* block id: 132 */
                int8_t l_349 = 0x82;
                struct S0 l_350 = {0x219075D6,0x8AE4,0x6314A1B8,0,0xC94A6896,1U};
                l_309 = 0x6351895D;
                if ((p_98 & ((int32_t)p_98 + (int32_t)(((uint16_t)2U >> (uint16_t)7) != (((uint32_t)((int16_t)(((uint32_t)(p_98 && ((((-(uint32_t)p_98) <= l_309) < (((uint32_t)(0x6B0D & ((int32_t)(!((uint16_t)(((int32_t)__builtin_popcountl((l_349 < p_98)) / (int32_t)l_349) && p_98) * (uint16_t)0x0287)) / (int32_t)p_98)) - (uint32_t)0x8882CB28) || p_98)) & l_216.f4)) - (uint32_t)p_98) | l_216.f2) + (int16_t)0x3535) + (uint32_t)p_98) != 0x159C)))))
                { /* block id: 134 */
                    l_218.f3 = 0;
                    l_100 = func_107(p_98, l_219);
                }
                else
                { /* block id: 137 */
                    int32_t l_365 = 0;
                    l_350 = func_47(l_218.f3);
                    l_309 = ((float)p_98 + (float)(((func_107(__builtin_ctz(p_98), ((int32_t)l_219 / (int32_t)((int16_t)(-8) >> (int16_t)12))) < ((float)__builtin_ffs(((int32_t)(l_216.f0 > (4 && (((int32_t)(((int32_t)(__builtin_ffs(l_365) > p_98) % (int32_t)4294967295U) == 1) + (int32_t)0xDE7F64FB) || p_98))) + (int32_t)0)) / (float)0x1.Ep+1)) <= l_216.f4) <= l_350.f0));
                }
                l_309 = p_98;
            }
            for (l_218.f3 = 0; (l_218.f3 < 26); l_218.f3 += 8)
            { /* block id: 145 */
                if (l_288)
                    break;
            }
        }
        l_368 = l_218;
    }
    return l_369;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_107(float  p_108, int16_t  p_109)
{ /* block id: 58 */
    uint16_t l_126 = 0x50AA;
    int32_t l_132 = (-1);
    for (p_109 = (-1); (p_109 == 20); p_109 += 3)
    { /* block id: 61 */
        int32_t l_131 = 0x22B755D7;
        l_132 = ((uint16_t)((uint16_t)p_109 / (uint16_t)((uint16_t)(((int16_t)(p_109 >= ((uint16_t)((uint16_t)(p_109 <= ((p_109 || ((uint16_t)l_126 - (uint16_t)__builtin_popcountl(__builtin_clzl(((uint16_t)((int32_t)p_109 / (int32_t)1) % (uint16_t)l_131))))) && p_109)) >> (uint16_t)9) >> (uint16_t)5)) << (int16_t)10) && (-6)) << (uint16_t)4)) * (uint16_t)l_126);
    }
    return l_126;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 70
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 17
   depth: 3, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 4
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 23, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 340
XXX times a non-volatile is write: 65
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 10
   depth: 2, occurrence: 8
   depth: 3, occurrence: 19
   depth: 4, occurrence: 16
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 21.6
XXX percentage an existing variable is used: 78.4
********************* end of statistics **********************/

