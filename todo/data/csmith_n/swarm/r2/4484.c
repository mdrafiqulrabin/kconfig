/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2541455312
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int64_t  f1;
   int32_t  f2;
};

struct S1 {
   signed f0 : 5;
   signed f1 : 11;
   const unsigned f2 : 8;
   unsigned f3 : 20;
   int32_t  f4;
   const unsigned f5 : 2;
};

/* --- GLOBAL VARIABLES --- */
static struct S1 g_20 = {-2,24,1,543,1L,1};
static int32_t g_38 = 0xFE96F77DL;
static int32_t *g_39 = &g_38;
static uint32_t g_51 = 0xA9FF1DB0L;
static struct S0 g_103 = {0x2C7FF412L,5L,-3L};
static struct S1 **g_111 = (void*)0;
static const float g_151 = 0x9.1p+1;
static float g_182 = (-0x1.Dp-1);
static int32_t **g_283 = &g_39;
static int32_t ***g_282 = &g_283;
static struct S1 ***g_288 = &g_111;
static struct S0 *g_302 = (void*)0;
static struct S0 **g_301 = &g_302;
static int32_t ****g_330 = &g_282;
static int32_t *****g_329 = &g_330;
static int32_t g_529 = 0xFB99274EL;
static struct S1 g_534 = {-4,-22,5,752,0x2E5400C0L,1};
static struct S0 g_800 = {4294967295UL,0xA50C4C096AB468F8LL,8L};
static struct S1 ***g_878 = &g_111;
static float g_901 = 0x0.3p-1;
static struct S0 ***g_924 = (void*)0;
static struct S0 ****g_923 = &g_924;


/* --- FORWARD DECLARATIONS --- */
static const int16_t  func_1(void);
static struct S0  func_2(const uint32_t  p_3, float  p_4, int32_t  p_5, const uint16_t  p_6, uint32_t  p_7);
static uint32_t  func_8(int64_t  p_9, int64_t  p_10, uint32_t  p_11, float  p_12, int64_t  p_13);
static const uint32_t  func_15(struct S1  p_16, struct S1  p_17, uint16_t  p_18, int32_t  p_19);
static struct S1  func_21(int64_t  p_22, uint16_t  p_23, int32_t  p_24);
static float  func_43(int32_t * p_44, int32_t * p_45, struct S1  p_46, int32_t * p_47, uint16_t  p_48);
static int32_t  func_52(int16_t  p_53, int32_t * p_54);
static int32_t * func_56(int32_t * p_57);
static int32_t * func_58(int32_t * p_59, uint16_t  p_60, uint16_t  p_61);
static int32_t * func_62(struct S0  p_63, int16_t  p_64, const struct S1  p_65, const int32_t  p_66, uint64_t  p_67);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_20 g_51 g_38 g_103.f0 g_111 g_39 g_103 g_282 g_283 g_301 g_329 g_288 g_330 g_182 g_302 g_529 g_534.f3 g_534.f5 g_534.f0 g_534.f1 g_534.f2 g_151 g_534.f4 g_800 g_534 g_878 g_923
 * writes: g_39 g_103.f0 g_103 g_38 g_282 g_288 g_111 g_182 g_20.f4 g_302 g_51 g_529 g_283 g_330 g_534.f4 g_800 g_901
 */
static const int16_t  func_1(void)
{ /* block id: 0 */
    uint64_t l_14 = 18446744073709551615UL;
    int64_t l_40 = 0x0F6DAE1DC630DE2FLL;
    int16_t l_819 = 0x27F5L;
    struct S0 *l_837 = &g_800;
    struct S1 *l_840 = &g_534;
    int64_t l_847 = 0x535FDC7472D0E3FCLL;
    struct S0 ****l_850 = (void*)0;
    float l_863 = 0x7.81921Fp-27;
    struct S1 ****l_873 = (void*)0;
    int32_t *l_905 = &g_38;
    int32_t *****l_938 = &g_330;
    (*l_837) = func_2(func_8(l_14, (func_15(g_20, func_21((safe_sub_func_int64_t_s_s(g_20.f0, g_20.f5)), l_14, (safe_mod_func_int32_t_s_s(((l_14 == ((((safe_add_func_uint64_t_u_u(g_20.f2, 0UL)) != ((safe_rshift_func_int16_t_s_u((safe_sub_func_int64_t_s_s(((safe_rshift_func_int16_t_s_s(l_14, g_20.f1)) ^ g_20.f0), l_14)), l_14)) > (-10L))) <= (-1L)) < g_20.f5)) & l_14), 1L))), l_40, l_40) ^ l_14), g_51, g_534.f5, l_14), l_819, l_14, g_20.f3, g_20.f1);
    /* statement id: 428 */
    //assert (g_39 == &g_529 || g_39 == dangling || g_39 == &g_38 || g_39 == 0);
    assert (g_288 == 0 || g_288 == &g_111);
    //assert (g_302 == dangling || g_302 == 0);
    for (l_819 = 0; (l_819 >= (-10)); l_819 = safe_sub_func_int32_t_s_s(l_819, 5))
    { /* block id: 431 */
        struct S1 **l_841 = &l_840;
        (*l_841) = l_840;
        return l_14;
    }
    if ((((safe_rshift_func_uint16_t_u_s((safe_mod_func_int64_t_s_s(((+g_103.f0) || l_847), (safe_sub_func_uint64_t_u_u((((l_850 != (void*)0) | (safe_sub_func_int64_t_s_s((safe_add_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(((&l_840 == g_111) && 0x5721L), (0xA763D063B484452DLL && (((safe_rshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((safe_sub_func_int64_t_s_s((((&g_800 == (void*)0) > l_847) ^ 0x74D3L), g_534.f0)) || g_800.f0), 13)), g_103.f0)) <= l_847) <= g_534.f5)))), g_103.f1)), l_819))) < l_819), l_819)))), g_103.f0)) < g_38) | l_40))
    { /* block id: 435 */
        int16_t l_864 = 0x6736L;
        int32_t *l_879 = &g_38;
        struct S0 l_900 = {4294967295UL,0xDEC79F3AB891ADD4LL,-1L};
        const struct S1 l_902 = {1,-22,2,518,1L,1};
        const uint32_t l_921 = 0x0141344CL;
        (**g_282) = (void*)0;
        /* statement id: 436 */
        assert (g_39 == 0);
        if (((((g_529 == l_864) & ((safe_add_func_uint32_t_u_u(((****g_329) == (****g_329)), (0xAC039FDACCA4815CLL && ((safe_rshift_func_uint16_t_u_u(((**g_329) != (**g_329)), g_529)) == (safe_rshift_func_int16_t_s_u(((safe_mod_func_uint64_t_u_u((l_873 == (void*)0), g_534.f3)) ^ 0xBAE8CD4CL), l_847)))))) < 0x5C6BA5BBL)) ^ 65531UL) | g_20.f2))
        { /* block id: 437 */
            struct S1 *l_874 = (void*)0;
            l_840 = l_874;
            /* statement id: 438 */
            assert (l_840 == 0);
        }
        else
        { /* block id: 439 */
            uint16_t l_877 = 0xD962L;
            const struct S0 *l_890 = (void*)0;
            const struct S0 **l_889 = &l_890;
            const struct S0 ***l_888 = &l_889;
            uint32_t l_898 = 0x24FDEA8EL;
            const struct S1 l_899 = {4,31,13,832,6L,0};
            const uint32_t l_941 = 0xF8917472L;
            const struct S0 l_946 = {0xA3F542FBL,-1L,0xABBACD75L};
            for (g_534.f4 = 0; (g_534.f4 < 15); g_534.f4 = safe_add_func_uint16_t_u_u(g_534.f4, 8))
            { /* block id: 442 */
                (*l_837) = func_2(g_103.f2, g_534.f3, l_877, l_40, (&g_111 != g_878));
            }
            /* facts after for loop */
            assert (g_39 == &g_38 || g_39 == 0);
            (*g_283) = l_879;
            /* statement id: 445 */
            assert (g_39 == &g_38);
            if ((!(((void*)0 != (***g_329)) > 65533UL)))
            { /* block id: 446 */
                float *l_885 = &g_182;
                const struct S1 **l_891 = (void*)0;
                int32_t l_897 = 8L;
                int32_t *l_906 = &g_38;
                (*l_885) = (safe_div_func_float_f_f(0xA.B55087p+85, (safe_sub_func_float_f_f((0x1.Fp-1 <= 0x0.8p-1), g_529))));
                (*g_283) = func_62((*l_837), (safe_add_func_uint64_t_u_u(((void*)0 != l_888), ((((void*)0 == l_891) <= (*l_879)) != ((safe_div_func_int64_t_s_s((safe_lshift_func_int16_t_s_u(((-2L) ^ ((+((&g_111 != (void*)0) != l_897)) && g_103.f1)), 8)), 0xCE2368F93503782DLL)) <= l_898)))), l_899, l_899.f0, (*l_879));
                /* statement id: 448 */
                assert (g_39 == 0);
                l_906 = func_62(l_900, ((l_899.f5 >= (l_877 == l_877)) > (l_847 | g_20.f5)), l_902, (safe_lshift_func_int16_t_s_s((l_905 != (void*)0), 4)), g_20.f1);
                /* statement id: 449 */
                assert (l_906 == 0);
                g_800 = g_800;
            }
            else
            { /* block id: 451 */
                int16_t l_919 = 0x7F72L;
                int32_t *****l_934 = (void*)0;
                (*g_283) = func_58(l_905, ((((*****g_329) >= (*l_905)) && ((((((safe_mod_func_uint32_t_u_u(0xB5975FD7L, g_38)) ^ (safe_lshift_func_int16_t_s_u((safe_unary_minus_func_int64_t_s((+(safe_lshift_func_int16_t_s_s((0UL < (*l_905)), 1))))), g_534.f5))) < ((safe_rshift_func_int16_t_s_s(((safe_mod_func_uint32_t_u_u(((-8L) < l_919), l_919)) < 0UL), (*l_879))) >= g_20.f0)) <= g_20.f5) | (*l_905)) || (-8L))) < g_800.f0), g_534.f0);
                if ((**g_283))
                { /* block id: 453 */
                    int16_t l_920 = 0x1701L;
                    float *l_922 = &g_901;
                    (*l_922) = (g_20.f0 >= ((l_920 < 0x6.CB2A15p+8) != l_921));
                    (*l_837) = (*l_837);
                    (*l_837) = l_900;
                }
                else
                { /* block id: 457 */
                    int32_t l_935 = 1L;
                    int64_t l_942 = 3L;
                    float *l_943 = &g_182;
                    (*l_879) = (g_923 != (void*)0);
                    (*l_943) = ((*l_879) > ((+(((safe_div_func_float_f_f((((safe_sub_func_float_f_f((safe_sub_func_float_f_f(((safe_add_func_float_f_f((((void*)0 == l_934) == l_935), ((safe_div_func_float_f_f((l_938 != &g_330), (l_898 <= l_877))) > (safe_div_func_float_f_f(0x3.1p-1, l_941))))) <= g_20.f2), 0x0.8p-1)), 0x9.6p+1)) > l_942) > (*****l_938)), g_800.f0)) <= 0xE.C11018p-2) == l_942)) <= 0x1.B1A58Ep-37));
                    for (l_942 = 0; (l_942 <= (-23)); l_942 = safe_sub_func_int64_t_s_s(l_942, 3))
                    { /* block id: 462 */
                        (***g_330) = l_879;
                        (****l_938) = func_58((****l_938), g_534.f3, (g_534.f5 < (l_938 != (void*)0)));
                        (*l_879) = (*l_905);
                        (*l_837) = l_946;
                    }
                }
                (*g_283) = func_56(func_56((***g_330)));
            }
            /* facts after branching */
            assert (g_39 == &g_38 || g_39 == 0);
        }
        /* facts after branching */
        assert (g_39 == &g_38 || g_39 == 0);
        assert (l_840 == &g_534 || l_840 == 0);
        return (*l_905);
    }
    else
    { /* block id: 473 */
        for (l_40 = 29; (l_40 == 7); --l_40)
        { /* block id: 476 */
            return g_534.f2;
        }
    }
    return (*l_905);
}


/* ------------------------------------------ */
/* 
 * reads : g_800.f2 g_38 g_51 g_534.f5 g_534.f1 g_20.f0 g_20.f5 g_103.f2 g_534.f4 g_800.f0 g_20.f1 g_282 g_283
 * writes: g_800.f2 g_39
 */
static struct S0  func_2(const uint32_t  p_3, float  p_4, int32_t  p_5, const uint16_t  p_6, uint32_t  p_7)
{ /* block id: 418 */
    uint64_t l_823 = 0UL;
    struct S0 l_824 = {4294967295UL,0L,-8L};
    const struct S1 l_827 = {1,33,1,328,1L,0};
    for (g_800.f2 = 0; (g_800.f2 == 11); g_800.f2 = safe_add_func_int64_t_s_s(g_800.f2, 1))
    { /* block id: 421 */
        float *l_822 = (void*)0;
        int32_t l_836 = 0x2FBFB54FL;
        l_823 = (0x1.Bp-1 == 0x1.2p-1);
        if (p_3)
            continue;
        if (l_823)
            continue;
        (**g_282) = func_58(func_58(func_62(l_824, (safe_rshift_func_uint16_t_u_u((l_822 != (void*)0), 13)), l_827, ((safe_lshift_func_int16_t_s_s((((safe_unary_minus_func_uint32_t_u(g_38)) | (+(((((((l_827.f0 & (safe_rshift_func_int16_t_s_s((((((safe_add_func_uint64_t_u_u(l_836, g_51)) || (p_5 || g_534.f5)) || g_51) || l_827.f5) <= g_534.f1), 0))) & 1UL) > g_38) != g_20.f0) <= 0x55A3633F547F1673LL) != g_38) | l_836))) && g_20.f5), g_103.f2)) != p_6), g_534.f4), l_836, l_827.f3), g_800.f0, g_20.f1);
        /* statement id: 425 */
        assert (g_39 == &g_38);
    }
    return l_824;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_329 g_330 g_282 g_283 g_529 g_534.f2 g_534.f5 g_103.f2 g_534.f1 g_20.f2 g_20.f4 g_20.f1 g_534.f0 g_151 g_534.f3 g_103.f1 g_20.f5 g_39 g_38 g_534.f4 g_20 g_103.f0 g_111 g_182 g_800 g_534
 * writes: g_51 g_39 g_182 g_103.f1 g_103.f0 g_529 g_283 g_38 g_330 g_103 g_282 g_534.f4 g_800
 */
static uint32_t  func_8(int64_t  p_9, int64_t  p_10, uint32_t  p_11, float  p_12, int64_t  p_13)
{ /* block id: 307 */
    int32_t *l_600 = &g_529;
    const struct S1 *l_601 = &g_534;
    struct S1 ***l_624 = &g_111;
    int32_t ****l_633 = &g_282;
    int64_t l_680 = 0L;
    struct S0 l_715 = {4294967293UL,0L,1L};
    for (g_51 = 0; (g_51 <= 7); g_51++)
    { /* block id: 310 */
        (****g_329) = l_600;
        /* statement id: 311 */
        assert (g_39 == &g_529);
    }
    /* facts after for loop */
    //assert (g_39 == &g_529 || g_39 == dangling || g_39 == &g_38 || g_39 == 0);
    if (((0xE6268CC5L ^ (&g_534 == l_601)) >= (safe_sub_func_int32_t_s_s(((*l_600) > ((p_11 >= (safe_lshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s((((p_9 & (((safe_lshift_func_uint16_t_u_s(((*l_600) > (p_11 ^ p_13)), g_534.f2)) >= (*l_600)) == 0x760A1376L)) || 0L) == 0xD867L), p_9)), 10))) != 0UL)), g_534.f5))))
    { /* block id: 313 */
        const uint32_t l_625 = 0x1209BC66L;
        int32_t *l_626 = &g_529;
        if (((((*g_329) != (*g_329)) && ((void*)0 != l_601)) < (((((-6L) <= 1L) || g_103.f2) == ((safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(((safe_add_func_int32_t_s_s((safe_mod_func_int64_t_s_s((safe_add_func_int64_t_s_s((((((safe_add_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s((l_624 == &g_111), p_13)), (*l_600))) | (-1L)) ^ g_534.f1) | l_625) | g_20.f2), (*l_600))), p_10)), p_13)) && 65535UL), 5)), g_534.f1)) <= 1L)) >= l_625)))
        { /* block id: 314 */
            (***l_633) = func_58(l_626, (safe_unary_minus_func_uint32_t_u((safe_unary_minus_func_uint64_t_u((safe_lshift_func_int16_t_s_s((p_10 == (safe_div_func_uint16_t_u_u((0x299EL < g_103.f2), (g_20.f4 ^ (((void*)0 != &g_302) != ((void*)0 == l_633)))))), g_20.f1)))))), (*l_626));
            /* statement id: 315 */
            assert (g_39 == &g_38);
            (****g_329) = (void*)0;
            /* statement id: 316 */
            assert (g_39 == 0);
        }
        else
        { /* block id: 317 */
            uint16_t l_641 = 1UL;
            int32_t *l_652 = &g_529;
            if ((p_9 ^ (safe_unary_minus_func_uint64_t_u((4UL <= (safe_mod_func_uint16_t_u_u(((*g_329) == (*g_329)), (g_534.f2 ^ 65535UL))))))))
            { /* block id: 318 */
                uint16_t l_642 = 0xD644L;
                g_182 = ((safe_div_func_float_f_f(((&g_330 != (void*)0) != g_534.f0), (safe_add_func_float_f_f((g_103.f2 != (l_641 < ((l_642 > (((!(-0x3.4p+1)) < (safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_add_func_float_f_f(g_20.f2, ((safe_sub_func_float_f_f(g_151, g_534.f3)) != p_9))), (*l_626))), 0x5.555F3Dp+95))) >= 0x1.Fp-1)) == p_11))), 0x0.1p-1)))) >= p_12);
            }
            else
            { /* block id: 320 */
                (***g_330) = l_652;
                /* statement id: 321 */
                assert (g_39 == &g_529);
            }
            for (g_103.f1 = 3; (g_103.f1 > 22); g_103.f1 = safe_add_func_uint16_t_u_u(g_103.f1, 1))
            { /* block id: 325 */
                (****g_329) = func_56(l_652);
                /* statement id: 326 */
                assert (g_39 == &g_38);
                (*g_283) = func_58((****g_329), (safe_rshift_func_uint16_t_u_s(((**g_330) != (void*)0), (safe_lshift_func_int16_t_s_u(g_20.f4, g_38)))), g_20.f5);
            }
            (*l_652) = (g_103.f1 < 0x9B07L);
        }
    }
    else
    { /* block id: 331 */
        int32_t l_661 = 0L;
        uint16_t l_670 = 0xF4E9L;
        int32_t l_688 = 0L;
        int32_t *l_697 = (void*)0;
        struct S0 l_698 = {0x3E2A152FL,0x2680E869EB959068LL,0L};
        struct S0 **l_726 = &g_302;
        struct S1 ***l_742 = &g_111;
        struct S1 ***l_743 = &g_111;
        int16_t l_761 = 0x3EB5L;
        if (((safe_mod_func_int64_t_s_s((((void*)0 != (*l_633)) & g_103.f1), l_661)) | ((p_10 & (safe_add_func_int32_t_s_s(((safe_sub_func_int64_t_s_s((~(p_11 >= (~p_9))), 0x935FFDEF3D8D72F7LL)) && (safe_add_func_uint16_t_u_u(((((p_10 < g_38) == 1UL) >= l_670) & 0xAA95L), g_534.f4))), (*l_600)))) | 0x52DF604EL)))
        { /* block id: 332 */
            const struct S1 *l_671 = &g_534;
            float *l_672 = &g_182;
            int32_t l_681 = 1L;
            int32_t l_694 = 0x24FA4624L;
            struct S0 *l_721 = &l_698;
            (*l_672) = (l_671 != (void*)0);
            (*g_282) = (**g_330);
            if ((((**l_633) == (*g_282)) > ((safe_mod_func_int16_t_s_s((((safe_lshift_func_uint16_t_u_u(8UL, 2)) || ((!g_534.f3) >= (((void*)0 == l_601) ^ (safe_div_func_int16_t_s_s(((l_680 & g_534.f1) | 4L), g_20.f1))))) <= 4294967293UL), l_681)) | 4294967294UL)))
            { /* block id: 335 */
                float *l_692 = &g_182;
                int32_t l_693 = 0xB7FC4CAEL;
                struct S0 l_699 = {0xDD07DE99L,0xB76A7D8E0714DF50LL,-4L};
                int32_t *l_700 = &l_688;
                float l_711 = 0xA.C77D33p-55;
                if (((safe_lshift_func_uint16_t_u_s((safe_div_func_int16_t_s_s(((safe_add_func_int32_t_s_s(l_688, ((void*)0 == l_672))) || (((+0x6BAEL) == (l_600 != l_692)) || ((((l_693 > (l_672 == l_672)) | l_693) || l_694) > 0xBEEFL))), l_694)), l_688)) < g_534.f0))
                { /* block id: 336 */
                    for (p_10 = 0; (p_10 < (-20)); p_10 = safe_sub_func_int64_t_s_s(p_10, 7))
                    { /* block id: 339 */
                        (***g_330) = l_697;
                        /* statement id: 340 */
                        assert (g_39 == 0);
                    }
                    l_699 = l_698;
                    (***l_633) = func_58(l_700, g_534.f2, g_529);
                    /* statement id: 343 */
                    assert (g_39 == &g_38);
                }
                else
                { /* block id: 344 */
                    uint16_t l_710 = 0xE13DL;
                    int32_t *l_718 = (void*)0;
                    struct S0 l_720 = {0UL,-6L,-6L};
                    for (g_38 = 0; (g_38 >= 17); g_38 = safe_add_func_int64_t_s_s(g_38, 1))
                    { /* block id: 347 */
                        struct S0 l_703 = {0xDEC077EBL,-9L,7L};
                        float *l_712 = (void*)0;
                        (*g_329) = (*g_329);
                        (***g_330) = func_62(l_703, (safe_mod_func_uint16_t_u_u((g_38 >= (safe_rshift_func_int16_t_s_s((g_20.f2 | 0x0E7CL), (safe_rshift_func_int16_t_s_s(p_13, 0))))), 5L)), func_21(l_710, g_534.f2, (l_710 >= l_703.f2)), p_13, (*l_700));
                        /* statement id: 349 */
                        assert (g_39 == 0);
                        (*l_692) = (l_697 != l_712);
                    }
                    (**g_282) = &l_693;
                    /* statement id: 352 */
                    assert (g_39 == &l_693);
                    for (l_693 = 0; (l_693 >= (-14)); l_693--)
                    { /* block id: 355 */
                        struct S0 *l_716 = &g_103;
                        const struct S1 **l_717 = &l_671;
                        int32_t *l_719 = &l_698.f2;
                        (*l_716) = l_715;
                        (*l_717) = l_671;
                        l_719 = l_718;
                        /* statement id: 358 */
                        assert (l_719 == 0);
                        l_720 = l_699;
                    }
                    if (((l_721 == (void*)0) < ((((safe_div_func_uint32_t_u_u(0UL, ((g_51 & (0x75A922C9L <= (!0x2A79L))) & (~(*g_39))))) >= p_11) < ((*l_600) > g_534.f1)) ^ (**g_283))))
                    { /* block id: 361 */
                        (*l_600) = (((-8L) <= ((&l_633 != &g_330) | ((((*l_700) || (****l_633)) != (l_726 != &g_302)) | (safe_lshift_func_uint16_t_u_s(p_10, 3))))) <= (((**g_330) != (**g_330)) >= 0xEA872D6CL));
                        (***g_330) = (*g_283);
                    }
                    else
                    { /* block id: 364 */
                        (***l_633) = (void*)0;
                        /* statement id: 365 */
                        assert (g_39 == 0);
                    }
                    /* facts after branching */
                    assert (g_39 == 0 || g_39 == &l_693);
                }
                /* facts after branching */
                assert (g_39 == 0 || g_39 == &l_693 || g_39 == &g_38);
            }
            else
            { /* block id: 368 */
                const int32_t ****l_730 = (void*)0;
                const int32_t *****l_729 = &l_730;
                (*l_600) = (l_729 == &l_633);
                (*l_600) = ((g_534.f3 | p_11) > (safe_lshift_func_uint16_t_u_s(g_103.f0, 9)));
                return g_20.f3;
            }
            /* facts after branching */
            //assert (g_39 == 0 || g_39 == dangling || g_39 == &g_38);
            (*l_600) = (&l_715 == l_721);
        }
        else
        { /* block id: 374 */
            uint16_t l_758 = 0x533BL;
            uint32_t l_759 = 2UL;
            struct S1 ***l_787 = &g_111;
            struct S0 l_789 = {4294967287UL,0x5094B4BF2F429F9BLL,0L};
            struct S1 ****l_792 = &l_743;
            for (p_9 = 0; (p_9 < 13); p_9++)
            { /* block id: 377 */
                int64_t l_762 = (-1L);
                struct S0 *l_788 = &l_698;
                struct S0 ***l_791 = &l_726;
                struct S0 ****l_790 = &l_791;
                if ((safe_rshift_func_uint16_t_u_s(((+g_51) ^ p_9), 4)))
                { /* block id: 378 */
                    struct S0 *l_738 = (void*)0;
                    struct S0 *l_739 = &l_715;
                    (*l_739) = l_715;
                }
                else
                { /* block id: 380 */
                    uint32_t l_760 = 0x5FFDA5A6L;
                    const struct S1 l_779 = {-4,-18,6,929,0x2E7B214BL,0};
                    if (((((safe_sub_func_int64_t_s_s(((l_742 == l_743) & p_9), ((safe_add_func_uint16_t_u_u((((safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(1UL, (&g_534 != (void*)0))), (safe_sub_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((((safe_mod_func_int32_t_s_s(((l_697 == l_600) >= (((safe_mod_func_uint16_t_u_u(l_758, p_9)) != 0xFE8FL) <= l_759)), (*l_600))) | p_13) > l_758), 13)), (-5L))))) >= 0xBE30CC54L) | l_760), l_761)) || g_103.f1))) & 18446744073709551608UL) == l_762) ^ p_13))
                    { /* block id: 381 */
                        int64_t l_776 = 0x11948A072CF99CCCLL;
                        float *l_777 = &g_182;
                        struct S0 l_778 = {0UL,-1L,-1L};
                        (*l_777) = (safe_sub_func_float_f_f((safe_div_func_float_f_f(l_760, (safe_sub_func_float_f_f((safe_div_func_float_f_f(((void*)0 == (*l_742)), (!((((p_12 >= (safe_sub_func_float_f_f(p_11, p_13))) != (safe_add_func_float_f_f(((l_759 >= (((0x9.Dp-1 >= l_762) <= (-0x6.5p+1)) != p_12)) < (-0x1.8p+1)), p_12))) != g_182) < g_534.f1)))), l_776)))), l_759));
                        (***l_633) = func_62(l_778, l_760, l_779, ((!((safe_add_func_uint32_t_u_u((p_10 & (safe_lshift_func_uint16_t_u_u((((safe_rshift_func_uint16_t_u_u((l_758 ^ 0x54F4BB6D4EFFE755LL), ((l_787 == &g_111) & (p_9 > g_534.f3)))) != p_10) & 4294967288UL), 3))), 0x074EB5B2L)) <= p_13)) < p_11), p_10);
                        /* statement id: 383 */
                        assert (g_39 == 0);
                        l_788 = &l_778;
                        /* statement id: 384 */
                        assert (l_788 == &l_778);
                        if (p_9)
                            continue;
                    }
                    else
                    { /* block id: 386 */
                        return g_20.f3;
                    }
                    /* facts after branching */
                    assert (g_39 == 0);
                    //assert (l_788 == dangling);
                    (*l_600) = (l_762 || l_759);
                }
                /* facts after branching */
                //assert (l_788 == dangling || l_788 == &l_698);
                g_103 = l_789;
                (*l_790) = &g_301;
                /* statement id: 392 */
                assert (l_791 == &g_301);
            }
            (*l_792) = &g_111;
        }
    }
    (*l_633) = (*l_633);
    for (g_529 = 2; (g_529 < (-30)); g_529--)
    { /* block id: 400 */
        int32_t **l_805 = &g_39;
        int32_t *l_807 = &g_38;
        struct S0 l_808 = {0x54288256L,1L,-1L};
        struct S1 *l_817 = &g_20;
        struct S0 *l_818 = &g_800;
        for (p_13 = 0; (p_13 == (-26)); p_13 = safe_sub_func_uint64_t_u_u(p_13, 7))
        { /* block id: 403 */
            const struct S1 l_806 = {-2,11,14,647,0x03509C0EL,1};
            for (g_534.f4 = (-10); (g_534.f4 >= (-24)); --g_534.f4)
            { /* block id: 406 */
                float l_799 = 0x6.9834FEp+89;
                l_799 = (-0x7.Ap+1);
            }
            (****g_329) = (void*)0;
            /* statement id: 409 */
            assert (g_39 == 0);
            (***l_633) = func_62(g_800, (safe_rshift_func_int16_t_s_s(0x1C55L, (safe_lshift_func_uint16_t_u_s(((p_11 & 2L) | (l_805 != (**l_633))), p_9)))), l_806, l_806.f2, g_800.f2);
            if (p_10)
                continue;
        }
        (***l_633) = l_807;
        /* statement id: 413 */
        assert (g_39 == &g_38);
        (**g_282) = func_62(l_808, p_10, (*l_601), (*l_807), (safe_add_func_uint32_t_u_u((*l_807), (safe_rshift_func_int16_t_s_u(((safe_div_func_int32_t_s_s(((((safe_rshift_func_int16_t_s_u((*l_600), ((void*)0 == l_817))) >= p_13) != (*l_807)) >= 0x5E9D1439AC81547CLL), (***g_282))) != (-1L)), 12)))));
        /* statement id: 414 */
        assert (g_39 == 0);
        (*l_818) = l_715;
    }
    return (*l_600);
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_20.f5 g_20.f0 g_38 g_20 g_103.f0 g_111 g_39 g_103 g_282 g_283 g_301 g_329 g_288 g_330 g_182 g_302 g_529 g_534.f3 g_534.f5 g_534.f0 g_534.f1
 * writes: g_39 g_103.f0 g_103 g_38 g_282 g_288 g_111 g_182 g_20.f4 g_302
 */
static const uint32_t  func_15(struct S1  p_16, struct S1  p_17, uint16_t  p_18, int32_t  p_19)
{ /* block id: 4 */
    int32_t *l_49 = &g_38;
    struct S1 l_50 = {-0,19,4,686,-3L,0};
    int16_t l_592 = 0xB63EL;
    float l_593 = 0x0.7p+1;
    float *l_594 = &g_182;
    struct S0 l_595 = {0xE2BDF2BCL,0x897FFD160FA78A98LL,1L};
    struct S0 *l_596 = &g_103;
    uint32_t l_597 = 18446744073709551609UL;
    (*l_594) = (((((((0x1.1p-1 <= ((0x0.6F5761p+98 < 0x4.CA7276p+93) < (safe_sub_func_float_f_f(func_43(l_49, l_49, l_50, l_49, g_51), l_592)))) == 0xD.16B16Bp-84) != l_593) >= g_20.f1) < g_534.f1) > g_529) <= g_534.f0);
    /* statement id: 303 */
    //assert (g_39 == dangling || g_39 == &g_38 || g_39 == 0);
    assert (g_288 == 0 || g_288 == &g_111);
    //assert (g_302 == dangling || g_302 == 0);
    (*l_596) = l_595;
    (*l_594) = l_597;
    return (*l_49);
}


/* ------------------------------------------ */
/* 
 * reads : g_20
 * writes: g_39
 */
static struct S1  func_21(int64_t  p_22, uint16_t  p_23, int32_t  p_24)
{ /* block id: 1 */
    int32_t *l_37 = &g_38;
    g_39 = l_37;
    /* statement id: 2 */
    assert (g_39 == &g_38);
    return g_20;
}


/* ------------------------------------------ */
/* 
 * reads : g_20.f5 g_20.f0 g_38 g_20 g_103.f0 g_111 g_39 g_103 g_282 g_283 g_301 g_329 g_288 g_51 g_330 g_182 g_302 g_529 g_534.f3 g_534.f5 g_534.f0
 * writes: g_39 g_103.f0 g_103 g_38 g_282 g_288 g_111 g_182 g_20.f4 g_302
 */
static float  func_43(int32_t * p_44, int32_t * p_45, struct S1  p_46, int32_t * p_47, uint16_t  p_48)
{ /* block id: 5 */
    int64_t l_55 = 0x94A2283564F69674LL;
    struct S0 l_68 = {7UL,1L,0L};
    int32_t *l_69 = &l_68.f2;
    int32_t l_78 = 0xA889E4E2L;
    int64_t l_304 = 0x1C6678C4744A534BLL;
    struct S1 ***l_307 = &g_111;
    int32_t *****l_315 = (void*)0;
    uint32_t l_371 = 9UL;
    const struct S1 l_404 = {-2,-3,5,478,-2L,1};
    struct S0 **l_415 = &g_302;
    int32_t ***l_445 = &g_283;
    int32_t *l_505 = &l_68.f2;
    struct S1 *l_533 = &g_534;
    int64_t l_591 = 0xA732BECF8EA86473LL;
    if (func_52(l_55, func_56(func_58(func_62(l_68, (((l_69 != (void*)0) != g_20.f5) > ((((*l_69) & p_46.f5) | (((~((safe_rshift_func_uint16_t_u_u(((p_46.f3 == (safe_rshift_func_int16_t_s_u(0x6D3CL, (*l_69)))) >= g_20.f0), (*l_69))) < (*p_47))) & (-1L)) == 0x7863L)) | (*l_69))), g_20, g_38, p_46.f2), p_46.f3, l_78))))
    { /* block id: 123 */
        uint64_t l_267 = 0xA77DD4E24FC960D3LL;
        int32_t **l_273 = &g_39;
        struct S1 ***l_287 = (void*)0;
        int64_t l_338 = 0xEF78231FD8CBC5EBLL;
        struct S0 l_340 = {0xBDC25A6BL,0x54AB4E643068DE9FLL,1L};
        struct S0 *l_341 = (void*)0;
        struct S0 *l_342 = &g_103;
        for (l_68.f2 = (-9); (l_68.f2 >= (-3)); l_68.f2 = safe_add_func_uint32_t_u_u(l_68.f2, 4))
        { /* block id: 126 */
            struct S1 *l_263 = (void*)0;
            int32_t l_266 = 0L;
            for (g_38 = 0; (g_38 > 16); g_38 = safe_add_func_uint32_t_u_u(g_38, 1))
            { /* block id: 129 */
                struct S1 *l_261 = (void*)0;
                int32_t *l_268 = (void*)0;
                int32_t *l_269 = &g_103.f2;
                struct S0 *l_270 = &g_103;
                for (l_55 = 0; (l_55 > (-1)); --l_55)
                { /* block id: 132 */
                    l_261 = &p_46;
                    /* statement id: 133 */
                    assert (l_261 == &p_46);
                }
                /* facts after for loop */
                assert (l_261 == &p_46 || l_261 == 0);
                (*l_269) = (((safe_unary_minus_func_int64_t_s((l_263 != (void*)0))) != ((g_111 != g_111) && (safe_lshift_func_int16_t_s_u(p_46.f5, (l_266 > ((*g_39) && 0x3D6F2558L)))))) | l_267);
                (*l_270) = g_103;
                return g_20.f0;
            }
            return g_103.f0;
        }
        for (p_48 = (-19); (p_48 >= 18); p_48++)
        { /* block id: 143 */
            int32_t ***l_274 = &l_273;
            struct S0 l_279 = {0x61DF2DE5L,-1L,0x9CEF6D55L};
            (*l_274) = l_273;
            if ((*g_39))
                continue;
            for (l_267 = 0; (l_267 > 50); l_267 = safe_add_func_int16_t_s_s(l_267, 3))
            { /* block id: 148 */
                struct S0 *l_285 = &g_103;
                int32_t l_297 = 0xB0BCA765L;
                struct S1 **l_305 = (void*)0;
                int32_t ****l_322 = &l_274;
                int32_t *****l_321 = &l_322;
                uint64_t l_337 = 1UL;
                float *l_339 = &g_182;
                if ((safe_sub_func_uint32_t_u_u((**l_273), ((void*)0 == p_45))))
                { /* block id: 149 */
                    if ((*g_39))
                        break;
                }
                else
                { /* block id: 151 */
                    int32_t ****l_290 = &l_274;
                    int32_t *****l_289 = &l_290;
                    if ((l_69 == (void*)0))
                    { /* block id: 152 */
                        struct S0 *l_280 = (void*)0;
                        struct S0 *l_281 = &l_279;
                        (*l_281) = l_279;
                    }
                    else
                    { /* block id: 154 */
                        int32_t ****l_284 = &g_282;
                        struct S0 **l_286 = &l_285;
                        (*l_284) = g_282;
                        (*l_286) = l_285;
                        g_288 = l_287;
                        /* statement id: 157 */
                        assert (g_288 == 0);
                    }
                    (*l_289) = (void*)0;
                    /* statement id: 159 */
                    assert (l_290 == 0);
                }
                if ((*l_69))
                    break;
                if ((safe_lshift_func_uint16_t_u_s((((((safe_lshift_func_uint16_t_u_s((safe_div_func_uint16_t_u_u(l_297, (g_20.f0 | (((safe_unary_minus_func_int16_t_s((g_20.f2 ^ 0x8535F4C0952EE98ALL))) || (**g_283)) > ((&l_273 != (void*)0) == p_46.f2))))), 8)) != (g_301 != &l_285)) > g_20.f0) | (-3L)) == l_297), g_20.f1)))
                { /* block id: 162 */
                    const uint32_t l_303 = 0x4AB442EEL;
                    if ((***l_274))
                    { /* block id: 163 */
                        (**l_273) = l_303;
                    }
                    else
                    { /* block id: 165 */
                        (**g_282) = &l_78;
                        /* statement id: 166 */
                        assert (g_39 == &l_78);
                    }
                }
                else
                { /* block id: 168 */
                    struct S1 ***l_308 = &l_305;
                    l_297 = 0x1.CB4F3Fp+17;
                    if (l_304)
                    { /* block id: 170 */
                        struct S1 ***l_306 = &g_111;
                        (**l_274) = (*g_283);
                        (*l_285) = l_68;
                        (*l_306) = l_305;
                    }
                    else
                    { /* block id: 174 */
                        l_308 = l_307;
                        /* statement id: 175 */
                        assert (l_308 == &g_111);
                        if (l_297)
                            continue;
                        (**g_283) = ((safe_sub_func_uint64_t_u_u(g_20.f5, (0x349FL >= (**l_273)))) >= (safe_rshift_func_uint16_t_u_u(p_46.f2, (((g_20.f5 > ((p_46.f3 < (safe_sub_func_uint16_t_u_u((4294967295UL && (g_103.f2 && (((g_20.f1 == 0x0ADA1813L) ^ g_103.f0) ^ 1UL))), 1L))) & (-8L))) || 5UL) > 0UL))));
                        (*g_39) = ((void*)0 == l_315);
                    }
                    /* facts after branching */
                    assert (l_308 == &g_111 || l_308 == &l_305);
                    (**l_274) = (*g_283);
                }
                (*l_339) = (safe_sub_func_float_f_f(((-((safe_add_func_float_f_f((l_321 != (void*)0), (((((((safe_div_func_float_f_f((*****l_321), (safe_div_func_float_f_f((p_46.f2 >= (0x4.F85C99p-14 != (safe_sub_func_float_f_f((&l_322 != g_329), (safe_div_func_float_f_f(((safe_add_func_float_f_f(((safe_add_func_float_f_f(l_337, (-0x1.6p+1))) > (*l_69)), (****l_322))) == 0x3.9p-1), 0x8.E69F63p-1)))))), g_20.f2)))) != (***l_274)) > 0x9.B6A83Ep-62) != g_103.f0) < p_48) > 0x5.0A7560p+11) != 0x1.3p+1))) <= l_338)) > (-0x5.Fp-1)), 0x9.98CFF1p+64));
            }
        }
        /* facts after for loop */
        assert (g_39 == &l_78 || g_39 == &g_38);
        assert (g_288 == 0 || g_288 == &g_111);
        (*l_342) = l_340;
        return g_103.f2;
        /* statement id: 186 */
        //assert (g_39 == dangling || g_39 == &g_38);
    }
    else
    { /* block id: 187 */
        uint16_t l_362 = 0xA9CAL;
        struct S1 *l_370 = &g_20;
        struct S1 **l_369 = &l_370;
        for (p_46.f4 = (-29); (p_46.f4 > (-7)); p_46.f4++)
        { /* block id: 190 */
            uint16_t l_353 = 0xB716L;
            if ((safe_add_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s(0UL, 5)) != (**g_283)), (18446744073709551615UL & (safe_rshift_func_int16_t_s_u(((p_46.f5 == (safe_unary_minus_func_uint64_t_u((+l_353)))) ^ (l_353 ^ ((-3L) == 65535UL))), 15))))))
            { /* block id: 191 */
                int32_t l_372 = (-1L);
                for (p_48 = 0; (p_48 >= 36); p_48++)
                { /* block id: 194 */
                    int32_t l_361 = (-2L);
                    for (g_20.f4 = 24; (g_20.f4 != (-9)); g_20.f4 = safe_sub_func_uint64_t_u_u(g_20.f4, 3))
                    { /* block id: 197 */
                        float *l_360 = &g_182;
                        (*l_360) = g_38;
                        l_361 = 0x3.5p+1;
                        (*g_301) = &l_68;
                        /* statement id: 200 */
                        assert (g_302 == &l_68);
                    }
                }
                if (l_362)
                    break;
                (***g_282) = (safe_lshift_func_int16_t_s_u((safe_div_func_int64_t_s_s(((0L || g_103.f0) == g_103.f1), (((safe_mod_func_int16_t_s_s(((*g_288) == l_369), g_51)) ^ p_46.f1) ^ ((((((void*)0 == &g_302) && 0xDF492D8EL) > g_20.f5) < l_371) | p_46.f0)))), l_372));
            }
            else
            { /* block id: 205 */
                for (g_20.f4 = 26; (g_20.f4 < (-19)); --g_20.f4)
                { /* block id: 208 */
                    struct S0 *l_375 = &l_68;
                    (*l_375) = l_68;
                }
            }
        }
        /* facts after for loop */
        assert (g_302 == &l_68 || g_302 == 0);
    }
    /* facts after branching */
    assert (g_302 == &l_68 || g_302 == 0);
    if ((0UL != (&g_111 == (void*)0)))
    { /* block id: 214 */
        float l_380 = (-0x1.8p-1);
        int32_t l_381 = 0x32531323L;
        struct S1 ***l_397 = &g_111;
        struct S0 l_414 = {0x355559ACL,1L,0x15A37453L};
        struct S1 *l_452 = (void*)0;
        struct S1 **l_451 = &l_452;
        struct S0 **l_469 = (void*)0;
        if (((safe_lshift_func_uint16_t_u_s(0UL, 11)) > ((safe_add_func_uint16_t_u_u(((((void*)0 != (*l_307)) ^ (*l_69)) != (p_46.f5 <= l_381)), ((safe_unary_minus_func_uint64_t_u(((0x3459L && (+p_46.f0)) ^ (&p_46 != &p_46)))) < 4294967294UL))) || (*p_47))))
        { /* block id: 215 */
            int32_t *l_386 = &l_78;
            float *l_403 = &g_182;
            (***g_330) = l_386;
            /* statement id: 216 */
            assert (g_39 == &l_78);
            (*l_403) = ((+(safe_sub_func_float_f_f(((safe_add_func_float_f_f((safe_sub_func_float_f_f((((safe_sub_func_float_f_f((g_182 >= (+((((l_397 != &g_111) <= (g_103.f2 > 0x9.7p-1)) < (((((0x5.B9F420p+49 == (-((safe_add_func_float_f_f(0x0.0E1589p+68, (0x1.066E18p-56 <= (((((safe_div_func_float_f_f((((((*l_386) <= p_46.f5) == (*l_386)) < 0xC.1C7195p+46) <= (*l_386)), g_103.f2)) < p_46.f0) > (*l_69)) != 0xE.85CBB0p+3) == l_381)))) != (*l_69)))) != p_46.f0) <= 0x4.64ED35p+79) < 0x2.3A33DEp-46) >= p_46.f0)) != 0xF.1256B1p-70))), p_46.f3)) > p_46.f5) != 0x1.2p+1), (-0x5.3p-1))), 0x5.5p-1)) != (*l_386)), 0x1.F6DF07p-92))) == g_20.f0);
            (****g_329) = func_62(g_103, (*l_386), l_404, ((safe_div_func_uint64_t_u_u((safe_rshift_func_int16_t_s_u((safe_div_func_uint64_t_u_u((((safe_lshift_func_int16_t_s_s((-10L), 8)) & ((**g_330) == &p_47)) & ((-1L) >= (0xDBFFA52AL <= (*g_39)))), g_103.f0)), 5)), g_20.f0)) | g_20.f3), p_46.f0);
            /* statement id: 218 */
            assert (g_39 == 0);
        }
        else
        { /* block id: 219 */
            float *l_413 = &g_182;
            int32_t *****l_418 = (void*)0;
            struct S0 l_446 = {0xD566D08CL,1L,-6L};
            (*l_413) = 0x2.Fp+1;
            l_68 = l_414;
            if (((&g_302 != l_415) ^ ((safe_rshift_func_uint16_t_u_u(l_414.f2, 4)) >= (((g_20.f3 <= ((*p_44) <= (l_418 == l_315))) <= p_46.f0) ^ (safe_rshift_func_uint16_t_u_s((safe_div_func_int64_t_s_s((&g_330 != l_315), 0x2F5C83813D3AF03ELL)), p_46.f5))))))
            { /* block id: 222 */
                struct S0 l_423 = {1UL,0L,0xB42ED0FAL};
                struct S0 *l_424 = &g_103;
                (*l_424) = l_423;
            }
            else
            { /* block id: 224 */
                for (l_68.f0 = 0; (l_68.f0 == 37); l_68.f0 = safe_add_func_int16_t_s_s(l_68.f0, 2))
                { /* block id: 227 */
                    int16_t l_430 = 3L;
                }
                (***g_330) = (***g_330);
            }
        }
        /* facts after branching */
        assert (g_39 == &g_38 || g_39 == 0);
        for (p_46.f4 = 0; (p_46.f4 < (-13)); p_46.f4--)
        { /* block id: 240 */
            g_103 = l_414;
        }
        (*l_451) = &p_46;
        /* statement id: 243 */
        assert (l_452 == &p_46);
        if ((*p_45))
        { /* block id: 244 */
            if ((!(~p_46.f0)))
            { /* block id: 245 */
                (**g_282) = (**g_282);
            }
            else
            { /* block id: 247 */
                (*l_451) = &p_46;
            }
        }
        else
        { /* block id: 250 */
            struct S0 *l_466 = &l_68;
            int32_t l_474 = 8L;
            float *l_477 = &l_380;
            (*l_69) = ((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((((((void*)0 == (**g_329)) | (g_51 & ((g_103.f2 < g_103.f1) && (&g_302 != (void*)0)))) <= (safe_mod_func_uint64_t_u_u((((safe_lshift_func_int16_t_s_s((!(*p_44)), 5)) & (safe_rshift_func_uint16_t_u_u((p_48 && 0x36B3A9FC1B618116LL), 9))) > g_103.f0), g_103.f2))) != (-1L)), 4)), p_46.f5)) >= 0xCF3EL);
            (*l_466) = l_414;
            (*l_477) = (safe_div_func_float_f_f(((l_415 == l_469) == (((-0x7.2p-1) <= ((safe_div_func_float_f_f((((&g_302 != l_415) < (safe_add_func_float_f_f(l_474, (safe_div_func_float_f_f(0x2.C62C78p+72, p_46.f5))))) <= ((void*)0 != p_44)), 0x1.Dp+1)) != p_46.f3)) > l_381)), l_381));
            (*l_415) = (*g_301);
        }
    }
    else
    { /* block id: 256 */
        float *l_478 = &g_182;
        int32_t l_485 = 1L;
        struct S0 l_487 = {2UL,8L,0x4515674DL};
        float l_499 = 0x3.CBE0E9p-48;
        int32_t l_538 = 0x9A361035L;
        int32_t ****l_558 = &l_445;
        (***g_330) = (**g_282);
        if (((p_45 == l_478) ^ (((safe_sub_func_uint32_t_u_u(g_20.f2, (safe_mod_func_uint32_t_u_u(((safe_lshift_func_uint16_t_u_s(((l_485 <= l_485) && (0x82F0L < ((*g_301) == (*g_301)))), 0)) < (+(65534UL ^ p_46.f0))), 0x12FE5C71L)))) <= g_51) < 0xB857C05AC7BDA490LL)))
        { /* block id: 258 */
            struct S0 l_488 = {0x3C505BFEL,0xEF02D1D452304329LL,9L};
            const struct S1 l_530 = {0,-3,14,414,1L,0};
            int32_t l_543 = 0xCE2155AAL;
            int64_t l_587 = (-1L);
            l_488 = l_487;
            (*l_478) = (safe_sub_func_float_f_f(p_46.f0, (safe_div_func_float_f_f(((((*g_288) == (*g_288)) < (safe_add_func_float_f_f(((safe_sub_func_float_f_f(((((((g_20.f0 < (g_51 == (safe_sub_func_float_f_f((((0x0.2p-1 < l_499) == (*l_69)) > (***l_445)), g_20.f3)))) > g_103.f1) >= (-0x1.Ep-1)) == p_46.f5) > p_46.f2) > g_20.f5), l_487.f2)) == l_485), (***l_445)))) <= l_488.f0), (-0x9.0p-1)))));
            if ((!((l_488.f2 < (safe_add_func_int64_t_s_s((((l_505 != (void*)0) != ((safe_lshift_func_uint16_t_u_s((!0x1FDBL), 8)) > (18446744073709551615UL ^ 18446744073709551614UL))) > (safe_div_func_uint16_t_u_u((*l_69), (safe_div_func_int64_t_s_s(((safe_sub_func_uint64_t_u_u(((void*)0 != p_47), 0UL)) > (-10L)), 18446744073709551606UL))))), l_488.f2))) & (***g_282))))
            { /* block id: 261 */
                int32_t l_525 = 0x2866269DL;
                int64_t l_527 = 0x31B66011E23A6EA5LL;
                float *l_531 = &l_499;
                l_488 = g_103;
                for (l_68.f1 = 14; (l_68.f1 < 16); l_68.f1 = safe_add_func_int16_t_s_s(l_68.f1, 1))
                { /* block id: 265 */
                    struct S0 l_528 = {0x6A7C08CAL,0x3961EA5B732AD42BLL,4L};
                    float *l_532 = &g_182;
                    l_527 = (safe_lshift_func_uint16_t_u_s((((((safe_unary_minus_func_uint32_t_u(((safe_unary_minus_func_int64_t_s(((0xB28E3F98E29903CBLL || (g_20.f3 >= g_103.f1)) | ((((safe_lshift_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_s(l_525, 3)) | 0x6B07355CL), (safe_unary_minus_func_int32_t_s((*p_44))))) > p_48) & ((((g_103.f0 < (0x0419C6E569B6153CLL && 1L)) & g_20.f0) != g_20.f4) > p_46.f3)) <= p_46.f5)))) & g_20.f2))) > 0x225837F9L) != p_46.f4) != l_487.f1) <= (*p_47)), 6));
                    (*g_283) = func_62(l_528, g_529, l_530, g_103.f1, (l_531 != l_532));
                    /* statement id: 267 */
                    assert (g_39 == 0);
                }
                /* facts after for loop */
                assert (g_39 == 0 || g_39 == &g_38);
            }
            else
            { /* block id: 269 */
                struct S0 *l_535 = &l_68;
                l_533 = (void*)0;
                /* statement id: 270 */
                assert (l_533 == 0);
                (***g_330) = (void*)0;
                /* statement id: 271 */
                assert (g_39 == 0);
                (*l_535) = l_487;
                (***g_330) = p_47;
                /* statement id: 273 */
                assert (g_39 == &g_38);
            }
            /* facts after branching */
            assert (g_39 == 0 || g_39 == &g_38);
            assert (l_533 == 0 || l_533 == &g_534);
            if (((safe_rshift_func_uint16_t_u_u((l_538 ^ (safe_sub_func_uint64_t_u_u((((0L < (safe_sub_func_int16_t_s_s(p_46.f3, (((l_487.f2 | l_543) && ((safe_mod_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((safe_add_func_int16_t_s_s((((g_103.f0 & (&p_45 == (**g_330))) != ((((safe_lshift_func_uint16_t_u_s(p_46.f1, l_530.f4)) >= (*l_505)) > 0xD223A280L) >= l_487.f0)) >= l_488.f0), 7L)), g_20.f2)), g_38)) && l_487.f1)) ^ p_46.f1)))) || p_46.f0) ^ l_487.f0), (*l_505)))), 1)) < 5L))
            { /* block id: 275 */
                return p_46.f2;
                /* statement id: 276 */
                //assert (g_302 == dangling || g_302 == 0);
            }
            else
            { /* block id: 277 */
                const uint32_t l_566 = 1UL;
                for (l_488.f2 = 0; (l_488.f2 <= 2); l_488.f2++)
                { /* block id: 280 */
                    int16_t l_588 = 0x2984L;
                    for (g_20.f4 = 17; (g_20.f4 < 4); g_20.f4 = safe_sub_func_uint64_t_u_u(g_20.f4, 4))
                    { /* block id: 283 */
                        int32_t l_565 = 0x227B02F8L;
                        (*l_478) = (((g_20.f2 <= (safe_div_func_float_f_f(((*g_329) != l_558), (safe_sub_func_float_f_f(l_488.f2, (g_20.f3 < (((safe_div_func_float_f_f(((*g_282) != (void*)0), (safe_add_func_float_f_f(0x0.6p+1, (((-0x3.2p+1) != g_20.f0) >= l_565))))) <= p_46.f4) >= 0x9.26D1AAp+69))))))) != g_182) > l_566);
                        (**l_445) = p_45;
                        /* statement id: 285 */
                        assert (g_39 == &g_38);
                    }
                    (*l_478) = (((safe_add_func_float_f_f((safe_div_func_float_f_f((((l_530.f5 >= ((safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f(0x1.Fp-1, ((0x6.0A7928p+92 == ((0xE.3A0385p+34 != g_534.f3) == ((l_543 <= (p_46.f2 <= (safe_add_func_float_f_f((safe_sub_func_float_f_f((g_534.f5 >= (safe_add_func_float_f_f((safe_div_func_float_f_f(((safe_add_func_float_f_f(g_534.f0, 0xE.CC87DAp-90)) < l_587), p_46.f4)), 0xD.EA8684p+5))), 0x8.40A298p+86)), l_588)))) != p_46.f1))) == g_20.f2))), g_20.f3)), 0x3.84A9D0p-81)) <= p_46.f2)) <= p_46.f4) <= 0xA.322F8Bp-91), l_588)), 0x0.47EFB9p-69)) != p_46.f2) == p_46.f0);
                    if (l_566)
                        continue;
                }
            }
        }
        else
        { /* block id: 291 */
            (**l_445) = (***g_330);
        }
        /* facts after branching */
        assert (g_39 == 0 || g_39 == &g_38);
        assert (l_533 == 0 || l_533 == &g_534);
        for (g_20.f4 = 0; (g_20.f4 != (-27)); g_20.f4 = safe_sub_func_uint64_t_u_u(g_20.f4, 9))
        { /* block id: 296 */
            l_533 = (void*)0;
            /* statement id: 297 */
            assert (l_533 == 0);
            return g_182;
            /* statement id: 298 */
            //assert (g_302 == dangling || g_302 == 0);
        }
    }
    /* facts after branching */
    assert (g_39 == &g_38 || g_39 == 0);
    assert (l_533 == 0 || l_533 == &g_534);
    (*p_44) = (*p_45);
    return l_591;
    /* statement id: 302 */
    //assert (g_302 == dangling || g_302 == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_38
 * writes: g_103
 */
static int32_t  func_52(int16_t  p_53, int32_t * p_54)
{ /* block id: 120 */
    struct S0 l_252 = {7UL,5L,0x897A575BL};
    struct S0 *l_253 = (void*)0;
    struct S0 *l_254 = &g_103;
    (*l_254) = l_252;
    return (*p_54);
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_20.f1 g_20.f5 g_20.f2 g_103.f0 g_529
 * writes: g_39 g_103.f0
 */
static int32_t * func_56(int32_t * p_57)
{ /* block id: 11 */
    uint32_t l_82 = 9UL;
    int32_t **l_87 = (void*)0;
    int32_t **l_88 = &g_39;
    const int64_t l_91 = 1L;
    const struct S1 l_104 = {3,16,5,611,0xC74B559EL,0};
    struct S1 *l_113 = &g_20;
    struct S1 **l_112 = &l_113;
    struct S0 l_119 = {4294967295UL,0xE211E8D53535970ALL,0L};
    struct S0 **l_161 = (void*)0;
    (*l_88) = func_58(p_57, (safe_add_func_int32_t_s_s((l_82 == ((*p_57) <= ((((safe_rshift_func_uint16_t_u_s(g_20.f1, 2)) == (18446744073709551613UL == ((safe_lshift_func_int16_t_s_u(0xCA68L, 11)) && (l_82 & 1L)))) > l_82) ^ g_20.f5))), 4294967291UL)), g_20.f2);
    /* statement id: 12 */
    assert (g_39 == &g_38);
    for (l_82 = 0; (l_82 < 1); l_82 = safe_add_func_int32_t_s_s(l_82, 4))
    { /* block id: 15 */
        int32_t l_100 = 0xA171313FL;
        struct S1 *l_101 = &g_20;
        struct S0 l_110 = {0xE7D7DB6CL,0x3C429AA74C462F11LL,0x52BC438EL};
        if ((*p_57))
            break;
        if (l_91)
            continue;
    }
    for (g_103.f0 = (-3); (g_103.f0 == 14); g_103.f0++)
    { /* block id: 28 */
        struct S0 *l_120 = &l_119;
        int32_t l_125 = 0xF9328A2DL;
        struct S0 l_129 = {7UL,8L,0xDBBC6626L};
        struct S1 *l_196 = &g_20;
        (*l_120) = l_119;
    }
    return &g_38;
    /* statement id: 119 */
    //assert (func_56_rv == &g_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_58(int32_t * p_59, uint16_t  p_60, uint16_t  p_61)
{ /* block id: 9 */
    int32_t *l_79 = &g_38;
    return l_79;
    /* statement id: 10 */
    //assert (func_58_rv == &g_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(struct S0  p_63, int16_t  p_64, const struct S1  p_65, const int32_t  p_66, uint64_t  p_67)
{ /* block id: 6 */
    struct S1 *l_76 = (void*)0;
    struct S1 **l_75 = &l_76;
    int32_t *l_77 = (void*)0;
    (*l_75) = &g_20;
    /* statement id: 7 */
    assert (l_76 == &g_20);
    return l_77;
    /* statement id: 8 */
    //assert (func_62_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_20.f0, "g_20.f0", print_hash_value);
    transparent_crc(g_20.f1, "g_20.f1", print_hash_value);
    transparent_crc(g_20.f2, "g_20.f2", print_hash_value);
    transparent_crc(g_20.f3, "g_20.f3", print_hash_value);
    transparent_crc(g_20.f4, "g_20.f4", print_hash_value);
    transparent_crc(g_20.f5, "g_20.f5", print_hash_value);
    transparent_crc(g_38, "g_38", print_hash_value);
    transparent_crc(g_51, "g_51", print_hash_value);
    transparent_crc(g_103.f0, "g_103.f0", print_hash_value);
    transparent_crc(g_103.f1, "g_103.f1", print_hash_value);
    transparent_crc(g_103.f2, "g_103.f2", print_hash_value);
    transparent_crc_bytes (&g_151, sizeof(g_151), "g_151", print_hash_value);
    transparent_crc_bytes (&g_182, sizeof(g_182), "g_182", print_hash_value);
    transparent_crc(g_529, "g_529", print_hash_value);
    transparent_crc(g_534.f0, "g_534.f0", print_hash_value);
    transparent_crc(g_534.f1, "g_534.f1", print_hash_value);
    transparent_crc(g_534.f2, "g_534.f2", print_hash_value);
    transparent_crc(g_534.f3, "g_534.f3", print_hash_value);
    transparent_crc(g_534.f4, "g_534.f4", print_hash_value);
    transparent_crc(g_534.f5, "g_534.f5", print_hash_value);
    transparent_crc(g_800.f0, "g_800.f0", print_hash_value);
    transparent_crc(g_800.f1, "g_800.f1", print_hash_value);
    transparent_crc(g_800.f2, "g_800.f2", print_hash_value);
    transparent_crc_bytes (&g_901, sizeof(g_901), "g_901", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 176
   depth: 1, occurrence: 39
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 41
breakdown:
   indirect level: 0, occurrence: 11
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 18
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 22
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 165

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 250
   depth: 2, occurrence: 42
   depth: 3, occurrence: 5
   depth: 4, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 4
   depth: 15, occurrence: 7
   depth: 16, occurrence: 5
   depth: 17, occurrence: 2
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 32, occurrence: 3

XXX total number of pointers: 159

XXX times a variable address is taken: 169
XXX times a pointer is dereferenced on RHS: 163
breakdown:
   depth: 1, occurrence: 118
   depth: 2, occurrence: 24
   depth: 3, occurrence: 11
   depth: 4, occurrence: 6
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 130
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 13
   depth: 3, occurrence: 17
   depth: 4, occurrence: 6
XXX times a pointer is compared with null: 52
XXX times a pointer is compared with address of another variable: 23
XXX times a pointer is compared with another pointer: 28
XXX times a pointer is qualified to be dereferenced: 536

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 282
   level: 2, occurrence: 107
   level: 3, occurrence: 49
   level: 4, occurrence: 29
   level: 5, occurrence: 13
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 43
XXX percent of pointers has null in alias set: 29.6
XXX average alias set size: 1.16

XXX times a non-volatile is read: 1115
XXX times a non-volatile is write: 398
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 221
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 32
   depth: 2, occurrence: 45
   depth: 3, occurrence: 45
   depth: 4, occurrence: 31
   depth: 5, occurrence: 38

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

