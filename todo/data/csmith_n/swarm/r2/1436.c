/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3096847806
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   volatile uint8_t  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint8_t g_7 = 1UL;
static int32_t g_37 = 0x2FE81720L;
static uint16_t g_62 = 0x6D20L;
static uint16_t g_67 = 65528UL;
static uint32_t g_69 = 0UL;
static int32_t g_86 = (-3L);
static int16_t g_106 = 0x2C65L;
static int64_t g_125 = 0x59DFF04C396C7BFBLL;
static int32_t g_135 = 0L;
static int32_t g_140 = (-1L);
static struct S0 g_141 = {5L,0xE5L};/* VOLATILE GLOBAL g_141 */
static struct S0 g_142 = {0x3F3F2C75L,0UL};/* VOLATILE GLOBAL g_142 */
static int32_t *g_153 = &g_135;
static int32_t **g_170 = &g_153;
static volatile struct S0 g_179 = {0x3AD1FF0DL,1UL};/* VOLATILE GLOBAL g_179 */
static uint32_t g_186 = 1UL;
static int32_t g_196 = 0L;
static struct S0 g_200 = {0xA7DDF25EL,0x12L};/* VOLATILE GLOBAL g_200 */
static int32_t *g_207 = &g_196;
static uint32_t g_219 = 0x7FD6875AL;
static struct S0 g_222 = {0xC12B9BE3L,7UL};/* VOLATILE GLOBAL g_222 */
static volatile uint32_t g_235 = 4294967295UL;/* VOLATILE GLOBAL g_235 */
static volatile uint32_t *g_234 = &g_235;
static volatile uint32_t **g_233 = &g_234;
static int32_t g_265 = (-8L);
static uint8_t g_286 = 1UL;
static uint64_t g_288 = 18446744073709551609UL;
static uint32_t **g_291 = (void*)0;
static volatile struct S0 g_294 = {1L,0xCCL};/* VOLATILE GLOBAL g_294 */
static struct S0 g_318 = {-4L,1UL};/* VOLATILE GLOBAL g_318 */
static volatile uint16_t g_333 = 1UL;/* VOLATILE GLOBAL g_333 */
static volatile uint16_t *g_332 = &g_333;
static volatile uint16_t **g_331 = &g_332;
static uint16_t ****g_340 = (void*)0;
static uint16_t *****g_339 = &g_340;


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_28(void);
inline static struct S0  func_31(uint32_t  p_32);
inline static uint32_t  func_41(uint32_t  p_42, int32_t  p_43, int32_t * p_44);
inline static int32_t * func_45(int32_t * p_46, int32_t  p_47, int32_t * p_48);
static int32_t  func_49(uint32_t  p_50, int32_t * p_51, uint16_t  p_52, int32_t * p_53);
static int32_t * func_54(uint32_t  p_55, uint8_t  p_56, uint32_t  p_57);
inline static int16_t  func_81(int32_t  p_82, int16_t  p_83);
static uint32_t  func_89(int32_t  p_90, uint16_t * p_91, uint8_t  p_92, int32_t  p_93, uint32_t  p_94);
inline static int32_t  func_96(uint8_t  p_97, uint8_t  p_98, int32_t * p_99, uint32_t  p_100, int32_t  p_101);
inline static uint64_t  func_113(int32_t * p_114, int16_t  p_115, int64_t  p_116, int32_t * p_117);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_37 g_62 g_69 g_142.f1 g_170 g_153 g_186 g_135 g_140 g_222 g_233 g_141.f0 g_141 g_142.f0 g_67 g_234 g_235 g_265 g_200.f0 g_291 g_294 g_125 g_86 g_196 g_106 g_318 g_288 g_331 g_339 g_200
 * writes: g_7 g_62 g_67 g_69 g_86 g_106 g_125 g_153 g_207 g_219 g_135 g_140 g_142 g_186 g_222 g_200.f0 g_286 g_179 g_288 g_318 g_331 g_37
 */
inline static uint8_t  func_28(void)
{ /* block id: 36 */
    uint64_t l_33 = 0x15E82AA9DADE661FLL;
    for (g_7 = (-5); (g_7 != 47); g_7 += 1)
    { /* block id: 39 */
        struct S0 *l_343 = (void*)0;
        struct S0 *l_344 = &g_318;
        (*l_344) = func_31(l_33);
        /* statement id: 272 */
        //assert (g_153 == &g_222.f0 || g_153 == dangling || g_153 == &g_135 || g_153 == &g_86);
        assert (g_207 == &g_37 || g_207 == &g_196);
        return g_142.f1;
    }
    (*g_170) = (*g_170);
    for (g_125 = 7; (g_125 <= 7); g_125++)
    { /* block id: 278 */
        if (l_33)
            break;
        return l_33;
    }
    return g_222.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_37 g_62 g_69 g_142.f1 g_170 g_153 g_186 g_135 g_140 g_222 g_233 g_141.f0 g_141 g_142.f0 g_67 g_234 g_235 g_265 g_200.f0 g_291 g_294 g_125 g_86 g_196 g_106 g_318 g_288 g_331 g_339 g_200
 * writes: g_62 g_67 g_69 g_86 g_106 g_125 g_153 g_207 g_219 g_135 g_140 g_142 g_186 g_222 g_200.f0 g_286 g_179 g_288 g_318 g_331 g_37
 */
inline static struct S0  func_31(uint32_t  p_32)
{ /* block id: 40 */
    int32_t *l_38 = &g_37;
    uint16_t *l_60 = (void*)0;
    uint16_t *l_61 = &g_62;
    uint16_t *l_65 = (void*)0;
    uint16_t *l_66 = &g_67;
    uint32_t *l_68 = &g_69;
    for (p_32 = 0; (p_32 == 40); p_32++)
    { /* block id: 43 */
        int32_t *l_36 = &g_37;
        l_38 = l_36;
    }
    (*l_38) = ((uint64_t)(func_41(g_7, (*l_38), func_45(l_38, func_49(p_32, func_54(((((-1L) | ((*l_61) = ((uint16_t)p_32 >> (uint16_t)g_7))) != ((*l_68) = ((uint16_t)((*l_66) = ((*l_38) >= g_37)) + (uint16_t)(*l_38)))) <= p_32), g_7, g_37), g_141.f0, l_38), l_38)) ^ 2L) / (uint64_t)(*l_38));
    /* statement id: 268 */
    //assert (g_153 == &g_222.f0 || g_153 == dangling || g_153 == &g_135 || g_153 == &g_86);
    assert (g_207 == &g_37 || g_207 == &g_196);
    l_38 = l_38;
    l_38 = l_38;
    return g_200;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_41(uint32_t  p_42, int32_t  p_43, int32_t * p_44)
{ /* block id: 266 */
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_170 g_288 g_222 g_69 g_331 g_37 g_153 g_339
 * writes: g_153 g_288 g_318 g_69 g_331 g_86
 */
inline static int32_t * func_45(int32_t * p_46, int32_t  p_47, int32_t * p_48)
{ /* block id: 243 */
    uint8_t l_322 = 1UL;
    int32_t *l_342 = &g_37;
    if (l_322)
    { /* block id: 244 */
        int32_t *l_323 = &g_86;
        (*g_170) = l_323;
        /* statement id: 245 */
        assert (g_153 == &g_86);
        for (g_288 = (-10); (g_288 > 39); g_288 += 3)
        { /* block id: 248 */
            for (l_322 = (-22); (l_322 > 20); l_322++)
            { /* block id: 251 */
                struct S0 *l_328 = &g_318;
                (*l_328) = g_222;
                for (g_69 = 26; (g_69 < 51); g_69 += 1)
                { /* block id: 255 */
                    volatile uint16_t ***l_334 = (void*)0;
                    volatile uint16_t ***l_335 = &g_331;
                    (*l_335) = g_331;
                }
            }
            (**g_170) = (((uint16_t)((g_37 != 0x620EL) | g_69) % (uint16_t)0xA4DFL) <= p_47);
        }
    }
    else
    { /* block id: 261 */
        uint32_t l_338 = 0UL;
        uint16_t *****l_341 = &g_340;
        l_338 = l_322;
        l_341 = g_339;
    }
    /* facts after branching */
    //assert (g_153 == &g_222.f0 || g_153 == dangling || g_153 == &g_135 || g_153 == &g_86);
    return l_342;
    /* statement id: 265 */
    //assert (func_45_rv == &g_37);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_49(uint32_t  p_50, int32_t * p_51, uint16_t  p_52, int32_t * p_53)
{ /* block id: 241 */
    int32_t l_321 = 0x16E78BE3L;
    return l_321;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_62 g_69 g_37 g_142.f1 g_170 g_153 g_186 g_135 g_140 g_222 g_233 g_141.f0 g_141 g_142.f0 g_67 g_234 g_235 g_265 g_200.f0 g_291 g_294 g_125 g_86 g_196 g_106 g_318
 * writes: g_86 g_67 g_106 g_125 g_153 g_207 g_219 g_135 g_140 g_142 g_186 g_69 g_222 g_200.f0 g_286 g_179 g_62
 */
static int32_t * func_54(uint32_t  p_55, uint8_t  p_56, uint32_t  p_57)
{ /* block id: 49 */
    uint64_t l_84 = 2UL;
    int64_t l_88 = 1L;
    uint32_t *l_239 = &g_186;
    uint32_t *l_240 = &g_69;
    uint16_t **l_246 = (void*)0;
    uint16_t ***l_245 = &l_246;
    int32_t ***l_276 = (void*)0;
    int32_t ****l_275 = &l_276;
    uint64_t *l_287 = &g_288;
    if (((uint32_t)(((((int32_t)((uint32_t)(~p_57) / (uint32_t)((*l_240) = ((uint16_t)__builtin_ffsll(g_7) + (uint16_t)((int16_t)func_81(l_84, g_62) + (int16_t)((l_88 | (((g_7 | ((*l_239) = func_89((!0x9FFBL), &g_62, p_55, g_62, l_84))) >= 1UL) ^ p_55)) >= 0xDF6E3992L))))) + (int32_t)p_55) >= 18446744073709551615UL) || p_55) != g_141.f0) - (uint32_t)p_56))
    { /* block id: 164 */
        int32_t *l_241 = &g_222.f0;
        (*g_170) = l_241;
        /* statement id: 165 */
        assert (g_153 == &g_222.f0);
        return l_240;
        /* statement id: 166 */
        //assert (func_54_rv == &g_69);
    }
    else
    { /* block id: 167 */
        int32_t ***l_273 = &g_170;
        int32_t ****l_272 = &l_273;
        uint16_t ***l_289 = &l_246;
        for (g_135 = 5; (g_135 != 19); g_135 += 1)
        { /* block id: 170 */
            struct S0 *l_244 = &g_222;
            uint16_t ****l_247 = (void*)0;
            uint16_t ****l_248 = &l_245;
            (*l_244) = g_141;
            (*l_248) = l_245;
        }
        for (g_142.f0 = 0; (g_142.f0 < (-25)); g_142.f0 -= 6)
        { /* block id: 176 */
            struct S0 *l_251 = &g_200;
            struct S0 **l_252 = &l_251;
            struct S0 *l_254 = &g_200;
            struct S0 **l_253 = &l_254;
            (*l_253) = ((*l_252) = l_251);
        }
        for (g_67 = (-20); (g_67 < 34); g_67++)
        { /* block id: 182 */
            int32_t *l_257 = &g_200.f0;
            int64_t *l_268 = &l_88;
            int64_t **l_267 = &l_268;
            uint64_t *l_284 = (void*)0;
            uint64_t *l_285 = &l_84;
            uint32_t **l_292 = &l_239;
            (*l_257) = 0xB307BF79L;
            if (p_56)
                break;
            if (l_84)
            { /* block id: 185 */
                int32_t l_266 = 0x46BDDA40L;
                l_266 = (((uint32_t)(*g_234) % (uint32_t)((uint32_t)p_56 % (uint32_t)((*l_240) = ((int16_t)(!g_265) - (int16_t)p_55)))) <= (*l_257));
                (*g_170) = &l_266;
                /* statement id: 188 */
                assert (g_153 == &l_266);
                if (p_57)
                    break;
                //assert (g_153 == dangling);
            }
            else
            { /* block id: 190 */
                int64_t ***l_269 = &l_267;
                int32_t *l_277 = &g_222.f0;
                (*l_269) = l_267;
                for (g_69 = 0; (g_69 != 55); g_69 += 5)
                { /* block id: 194 */
                    int32_t *****l_274 = &l_272;
                    l_275 = ((*l_274) = l_272);
                    /* statement id: 196 */
                    assert (l_275 == &l_273);
                    (***l_272) = l_257;
                    /* statement id: 197 */
                    assert (g_153 == &g_200.f0);
                    (****l_275) = (*l_257);
                    (**l_273) = (****l_274);
                }
                /* facts after for loop */
                //assert (g_153 == &g_200.f0 || g_153 == &g_222.f0 || g_153 == dangling || g_153 == &g_135);
                (*l_257) = p_55;
                l_257 = ((***l_272) = l_277);
                /* statement id: 203 */
                assert (g_153 == &g_222.f0);
                assert (l_257 == &g_222.f0);
            }
            /* facts after branching */
            //assert (g_153 == &g_222.f0 || g_153 == dangling);
            assert (l_257 == &g_222.f0 || l_257 == &g_200.f0);
            if (((g_286 = (((uint64_t)((int32_t)__builtin_popcountll(p_57) / (int32_t)0x956FC2D7L) % (uint64_t)((*l_285) = p_57)) | 0x17F37F7A672AF336LL)) ^ (((void*)0 != l_287) >= ((*l_239) = (((void*)0 != l_289) & p_56)))))
            { /* block id: 208 */
                uint32_t **l_290 = &l_240;
                int32_t *l_293 = (void*)0;
                volatile struct S0 *l_295 = (void*)0;
                uint64_t l_312 = 18446744073709551615UL;
                (*l_257) = (0x5B34L | (l_290 == (l_292 = g_291)));
                /* statement id: 210 */
                assert (l_292 == 0);
                l_293 = l_257;
                /* statement id: 211 */
                assert (l_293 == &g_222.f0 || l_293 == &g_200.f0);
                g_179 = g_294;
                for (g_125 = 1; (g_125 <= 5); g_125 += 2)
                { /* block id: 215 */
                    int32_t l_300 = (-1L);
                    int32_t **l_303 = &l_293;
                    uint16_t *l_313 = &g_62;
                    int16_t *l_314 = &g_106;
                    (*l_257) = ((int16_t)g_222.f0 + (int16_t)((l_300 <= ((*l_239) = ((uint64_t)(&g_86 == ((*l_303) = &l_300)) - (uint64_t)1L))) | g_7));
                    /* statement id: 218 */
                    assert (l_293 == &l_300);
                    (**l_303) = __builtin_bswap32(((((((**l_303) = ((int16_t)(func_81(((**l_303) = p_56), (((int32_t)p_56 - (int32_t)(g_186 || __builtin_ctzll(((*l_285) = g_222.f1)))) <= ((uint16_t)(((l_312 | ((((g_67 <= (((*l_314) = ((((*l_313) = (((**l_267) = (*l_257)) <= (g_86 <= g_141.f0))) == p_55) < 5UL)) | 0x6B7EL)) && g_222.f0) > p_56) ^ 9L)) | g_196) >= p_57) >> (uint16_t)13))) == p_56) + (int16_t)g_135)) >= 6UL) > p_57) && (**g_233)) != 0UL));
                    for (g_106 = (-16); (g_106 == 21); g_106++)
                    { /* block id: 228 */
                        int32_t *l_317 = &l_300;
                        struct S0 *l_319 = &g_222;
                        l_317 = l_257;
                        /* statement id: 229 */
                        assert (l_317 == &g_222.f0 || l_317 == &g_200.f0);
                        (*l_319) = g_318;
                    }
                    return l_257;
                    /* statement id: 232 */
                    //assert (func_54_rv == &g_222.f0 || func_54_rv == &g_200.f0);
                }
            }
            else
            { /* block id: 234 */
                int32_t *l_320 = (void*)0;
                l_257 = l_257;
                l_320 = l_257;
                /* statement id: 236 */
                assert (l_320 == &g_222.f0 || l_320 == &g_200.f0);
            }
            /* facts after branching */
            assert (l_292 == &l_239 || l_292 == 0);
        }
        /* facts after for loop */
        //assert (g_153 == &g_222.f0 || g_153 == dangling || g_153 == &g_135);
        assert (l_275 == &l_273 || l_275 == &l_276);
    }
    /* facts after branching */
    //assert (g_153 == &g_222.f0 || g_153 == dangling || g_153 == &g_135);
    assert (g_207 == &g_37 || g_207 == &g_196);
    //assert (l_275 == dangling || l_275 == &l_276);
    return &g_135;
    /* statement id: 240 */
    //assert (func_54_rv == &g_135);
}


/* ------------------------------------------ */
/* 
 * reads : g_69
 * writes: g_86
 */
inline static int16_t  func_81(int32_t  p_82, int16_t  p_83)
{ /* block id: 50 */
    int32_t *l_85 = &g_86;
    uint32_t l_87 = 0x2CFB6473L;
    (*l_85) = g_69;
    return l_87;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_62 g_37 g_142.f1 g_170 g_153 g_186 g_69 g_135 g_140 g_222 g_233
 * writes: g_67 g_106 g_125 g_153 g_207 g_219 g_135 g_140 g_142 g_186
 */
static uint32_t  func_89(int32_t  p_90, uint16_t * p_91, uint8_t  p_92, int32_t  p_93, uint32_t  p_94)
{ /* block id: 53 */
    uint16_t *l_102 = &g_67;
    int16_t *l_105 = &g_106;
    int32_t *l_109 = &g_37;
    uint16_t *l_110 = &g_62;
    int32_t *l_238 = &g_142.f0;
    (*l_238) = func_96((__builtin_ffs((0x67E6L ^ ((*l_102) = g_7))) ^ p_90), (((*l_105) = ((uint16_t)0x328DL >> (uint16_t)14)) < ((int16_t)1L % (int16_t)g_7)), l_109, (l_110 == (void*)0), p_90);
    /* statement id: 160 */
    //assert (g_153 == &g_135 || g_153 == dangling);
    assert (g_207 == &g_37 || g_207 == &g_196);
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_37 g_142.f1 g_170 g_153 g_186 g_69 g_135 g_140 g_222 g_7 g_233
 * writes: g_125 g_153 g_207 g_219 g_67 g_135 g_140 g_142 g_186
 */
inline static int32_t  func_96(uint8_t  p_97, uint8_t  p_98, int32_t * p_99, uint32_t  p_100, int32_t  p_101)
{ /* block id: 56 */
    int32_t *l_119 = &g_37;
    int32_t **l_118 = &l_119;
    int64_t *l_124 = &g_125;
    int32_t *l_127 = &g_37;
    int32_t **l_126 = &l_127;
    int32_t *l_229 = &g_200.f0;
    int32_t l_236 = 1L;
    if ((g_62 || ((uint64_t)7UL % (uint64_t)func_113(((*l_118) = &g_37), ((int64_t)g_62 % (int64_t)0xA1C1E9AD3EE7732ALL), ((*l_124) = (p_101 <= ((int16_t)p_100 >> (int16_t)6))), ((*l_126) = &g_37)))))
    { /* block id: 131 */
        int32_t ***l_204 = (void*)0;
        int32_t ***l_205 = &l_118;
        uint32_t *l_231 = (void*)0;
        uint32_t **l_230 = &l_231;
        if (((p_101 <= (*l_127)) > (__builtin_parity(p_100) || (g_142.f1 != (func_113((*g_170), __builtin_popcountl((((*l_205) = &p_99) == (void*)0)), p_98, (*g_170)) != p_100)))))
        { /* block id: 133 */
lbl_224:
            (*l_118) = (*l_126);
            (*g_170) = &p_101;
            /* statement id: 135 */
            assert (g_153 == &p_101);
        }
        else
        { /* block id: 136 */
            int32_t *l_206 = &g_196;
            uint32_t *l_227 = &g_186;
            int32_t l_228 = 0xC4CB4500L;
            uint32_t ***l_232 = &l_230;
            if ((l_206 == (g_207 = l_127)))
            { /* block id: 138 */
                uint32_t *l_216 = (void*)0;
                uint32_t *l_217 = (void*)0;
                uint32_t *l_218 = &g_219;
                uint16_t *l_220 = &g_67;
                int32_t l_221 = (-8L);
                g_140 = ((*g_153) = ((uint16_t)((int16_t)(0x2565L >= __builtin_clzl(g_186)) >> (int16_t)((__builtin_ctzl(((((((-5L) == ((uint32_t)(((((g_69 && ((*l_218) = (g_142.f1 & __builtin_clz(p_97)))) > (((*l_220) = 0xD957L) == p_100)) == 0x1801899B7E06FDCCLL) && (-1L)) ^ p_100) - (uint32_t)l_221)) & 0x0892C684B1517602LL) ^ (**g_170)) & p_101) > g_140)) && (**g_170)) || p_97)) >> (uint16_t)l_221));
            }
            else
            { /* block id: 143 */
                struct S0 *l_223 = &g_142;
lbl_225:
                (*l_223) = g_222;
                if (g_222.f0)
                    goto lbl_224;
                if (g_186)
                    goto lbl_225;
            }
            /* facts after branching */
            assert (g_207 == &g_37);
            (**g_170) = __builtin_clzll((1L > (((*l_227) = (~g_7)) & l_228)));
            (*g_170) = &l_228;
            /* statement id: 150 */
            assert (g_153 == &l_228);
            (**g_170) = ((func_113((l_229 = &p_101), ((*g_153) == (l_236 = (p_98 >= (((*l_232) = l_230) != g_233)))), (p_98 || (g_186 < 0UL)), (*g_170)) | 1UL) == g_69);
            /* statement id: 154 */
            assert (l_229 == &p_101);
        }
        /* facts after branching */
        assert (l_118 == &l_119 || l_118 == &p_99);
        //assert (g_153 == dangling || g_153 == &p_101);
        assert (g_207 == &g_37 || g_207 == &g_196);
        assert (l_229 == &p_101 || l_229 == &g_200.f0);
    }
    else
    { /* block id: 156 */
        uint32_t l_237 = 4UL;
        return l_237;
    }
    /* facts after branching */
    assert (l_118 == &l_119 || l_118 == &p_99);
    //assert (g_153 == dangling || g_153 == &p_101);
    assert (g_207 == &g_37 || g_207 == &g_196);
    assert (l_229 == &p_101 || l_229 == &g_200.f0);
    return (*p_99);
    /* statement id: 159 */
    //assert (g_153 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_113(int32_t * p_114, int16_t  p_115, int64_t  p_116, int32_t * p_117)
{ /* block id: 60 */
    uint8_t l_130 = 0UL;
    struct S0 *l_172 = &g_142;
    uint16_t *l_178 = &g_67;
    uint16_t **l_177 = &l_178;
    int32_t l_185 = 0xF28F66BBL;
    uint32_t *l_197 = &g_69;
    int32_t **l_202 = (void*)0;
    int32_t **l_203 = &g_153;
    return p_116;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_37, "g_37", print_hash_value);
    transparent_crc(g_62, "g_62", print_hash_value);
    transparent_crc(g_67, "g_67", print_hash_value);
    transparent_crc(g_69, "g_69", print_hash_value);
    transparent_crc(g_86, "g_86", print_hash_value);
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc(g_140, "g_140", print_hash_value);
    transparent_crc(g_141.f0, "g_141.f0", print_hash_value);
    transparent_crc(g_141.f1, "g_141.f1", print_hash_value);
    transparent_crc(g_142.f0, "g_142.f0", print_hash_value);
    transparent_crc(g_142.f1, "g_142.f1", print_hash_value);
    transparent_crc(g_179.f0, "g_179.f0", print_hash_value);
    transparent_crc(g_179.f1, "g_179.f1", print_hash_value);
    transparent_crc(g_186, "g_186", print_hash_value);
    transparent_crc(g_196, "g_196", print_hash_value);
    transparent_crc(g_200.f0, "g_200.f0", print_hash_value);
    transparent_crc(g_200.f1, "g_200.f1", print_hash_value);
    transparent_crc(g_219, "g_219", print_hash_value);
    transparent_crc(g_222.f0, "g_222.f0", print_hash_value);
    transparent_crc(g_222.f1, "g_222.f1", print_hash_value);
    transparent_crc(g_235, "g_235", print_hash_value);
    transparent_crc(g_265, "g_265", print_hash_value);
    transparent_crc(g_286, "g_286", print_hash_value);
    transparent_crc(g_288, "g_288", print_hash_value);
    transparent_crc(g_294.f0, "g_294.f0", print_hash_value);
    transparent_crc(g_294.f1, "g_294.f1", print_hash_value);
    transparent_crc(g_318.f0, "g_318.f0", print_hash_value);
    transparent_crc(g_318.f1, "g_318.f1", print_hash_value);
    transparent_crc(g_333, "g_333", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 69
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 33, occurrence: 1

XXX total number of pointers: 122

XXX times a variable address is taken: 100
XXX times a pointer is dereferenced on RHS: 28
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 4
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 74
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 248

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 195
   level: 2, occurrence: 38
   level: 3, occurrence: 18
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 44
XXX number of pointers point to scalars: 68
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 25.4
XXX average alias set size: 1.25

XXX times a non-volatile is read: 271
XXX times a non-volatile is write: 214
XXX times a volatile is read: 9
XXX    times read thru a pointer: 2
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 151
XXX percentage of non-volatile access: 98

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 16
   depth: 2, occurrence: 15
   depth: 3, occurrence: 19
   depth: 4, occurrence: 9
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 23.8
XXX percentage an existing variable is used: 76.2
********************* end of statistics **********************/

