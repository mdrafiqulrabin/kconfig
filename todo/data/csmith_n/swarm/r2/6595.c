/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      1041117138
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_10 = 1L;
static int32_t g_32 = 0xF06E85FCL;
static int32_t * volatile g_31 = &g_32;/* VOLATILE GLOBAL g_31 */
static int32_t g_40 = (-10L);
static volatile int32_t g_77 = 0xBA309CE0L;/* VOLATILE GLOBAL g_77 */
static volatile int32_t g_78 = 0x8C8ECA74L;/* VOLATILE GLOBAL g_78 */
static volatile int32_t g_79 = (-1L);/* VOLATILE GLOBAL g_79 */
static int32_t g_80 = (-1L);
static int32_t *g_85 = &g_80;
static int32_t ** volatile g_84 = &g_85;/* VOLATILE GLOBAL g_84 */
static int32_t **g_113 = &g_85;
static int32_t *** volatile g_112 = &g_113;/* VOLATILE GLOBAL g_112 */
static int32_t * volatile g_142 = (void*)0;/* VOLATILE GLOBAL g_142 */
static int32_t ** volatile g_144 = &g_85;/* VOLATILE GLOBAL g_144 */
static int32_t ** volatile *g_152 = &g_84;
static int32_t ** volatile * volatile *g_151 = &g_152;
static int32_t ** volatile * volatile * volatile *g_150 = &g_151;
static int32_t g_212 = 0x2CD46132L;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_2(int32_t  p_3, uint16_t  p_4, int32_t * p_5, uint16_t  p_6, uint8_t  p_7);
static uint8_t  func_11(uint16_t  p_12);
static uint16_t  func_16(int32_t  p_17);
static int16_t  func_20(uint32_t  p_21);
static uint16_t  func_24(int16_t  p_25, int32_t * p_26, int32_t * p_27);
static int32_t * func_41(int32_t * p_42, int32_t  p_43);
static uint32_t  func_49(uint32_t  p_50, uint16_t  p_51);
static int16_t  func_54(int32_t * p_55);
static int32_t * func_56(uint8_t  p_57, uint8_t  p_58, uint8_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_31 g_32 g_40 g_84 g_80 g_85 g_112 g_113 g_144 g_150 g_151 g_152 g_78 g_212 g_77 g_79
 * writes: g_32 g_40 g_80 g_85 g_113 g_84 g_10
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_8 = 0x25B3B9DAL;
    int32_t *l_9 = &g_10;
    int32_t *l_310 = &g_80;
    l_9 = func_2(l_8, (0x40FC0272L && l_8), l_9, (*l_9), func_11(g_10));
    /* statement id: 156 */
    assert (l_9 == &g_80);
    //assert (g_85 == &g_80 || g_85 == dangling || g_85 == 0);
    assert (g_84 == 0 || g_84 == &g_85);
    (*l_9) = (((((!g_32) & (((g_40 && ((*g_150) == (*g_150))) & (!(*l_9))) <= 0UL)) <= g_32) | ((0x5E1AL < (l_9 != l_310)) >= g_10)) | 0xD465L);
    (*g_113) = (void*)0;
    /* statement id: 158 */
    assert (g_85 == 0);
    return (*l_9);
}


/* ------------------------------------------ */
/* 
 * reads : g_10
 * writes: g_10
 */
static int32_t * func_2(int32_t  p_3, uint16_t  p_4, int32_t * p_5, uint16_t  p_6, uint8_t  p_7)
{ /* block id: 153 */
    int32_t *l_307 = &g_80;
    (*p_5) = (*p_5);
    return l_307;
    /* statement id: 155 */
    //assert (func_2_rv == &g_80);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_31 g_32 g_40 g_84 g_80 g_85 g_112 g_113 g_144 g_150 g_151 g_152 g_78 g_212 g_77 g_79
 * writes: g_32 g_40 g_80 g_85 g_113 g_84
 */
static uint8_t  func_11(uint16_t  p_12)
{ /* block id: 1 */
    uint16_t l_28 = 6UL;
    int32_t *l_29 = &g_10;
    uint8_t l_283 = 0UL;
    int32_t ****l_297 = (void*)0;
    int32_t l_298 = 0L;
    l_283 = ((p_12 && ((uint16_t)((((-(int16_t)(func_16(((int16_t)func_20((((int16_t)g_10 + (int16_t)g_10) < (g_10 < (0xEC5EL <= (func_24(l_28, l_29, l_29) | 0xBC25L))))) << (int16_t)9)) < (*l_29))) | p_12) || 0UL) >= g_10) % (uint16_t)0xA204L)) || p_12);
    /* statement id: 149 */
    //assert (g_85 == &g_80 || g_85 == dangling || g_85 == 0);
    assert (g_84 == 0 || g_84 == &g_85);
    l_298 = (((int16_t)((((g_212 > (((uint32_t)((int16_t)(((uint32_t)(4294967295UL ^ (+(p_12 < p_12))) % (uint32_t)1L) ^ 0x0D202A2DL) - (int16_t)(0L | (((((uint32_t)(*l_29) + (uint32_t)((uint16_t)(l_297 == (void*)0) - (uint16_t)p_12)) != (-8L)) > (*l_29)) > g_78))) + (uint32_t)p_12) < p_12)) | 0xF2345B20L) | (*l_29)) && g_40) >> (int16_t)7) > (*l_29));
    l_298 = ((*l_29) <= ((int32_t)p_12 % (int32_t)((int16_t)p_12 - (int16_t)(p_12 == (((int32_t)p_12 % (int32_t)(((0xA9801741L != ((((uint16_t)(((4294967292UL < p_12) > (*l_29)) >= 0x6D7D79F0L) << (uint16_t)7) < 0x25A8L) < g_212)) | (*l_29)) | p_12)) | p_12)))));
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_144 g_85 g_113 g_32 g_150 g_84 g_151 g_152 g_78 g_40 g_10 g_212 g_112 g_77 g_80 g_79
 * writes: g_85 g_32 g_40 g_84
 */
static uint16_t  func_16(int32_t  p_17)
{ /* block id: 73 */
    int32_t ***l_146 = &g_113;
    int32_t ****l_145 = &l_146;
    int32_t *l_147 = &g_32;
    int32_t ** volatile * volatile * volatile *l_153 = &g_151;
    int32_t ***l_169 = &g_113;
    uint32_t l_208 = 2UL;
    int32_t l_260 = 0x166651E2L;
    int32_t l_268 = 0x91A87AE2L;
    uint16_t l_269 = 0UL;
    int32_t l_282 = 1L;
    (*g_113) = (*g_144);
    (*g_113) = (void*)0;
    /* statement id: 75 */
    assert (g_85 == 0);
    (*l_147) = (&g_112 == l_145);
    if (((((((&g_112 != &g_112) <= 4294967295UL) < (*l_147)) > ((int16_t)0L >> (int16_t)7)) == (*l_147)) || 0x3CA64ADDL))
    { /* block id: 77 */
        l_153 = g_150;
    }
    else
    { /* block id: 79 */
        int32_t l_154 = (-1L);
        int32_t *l_230 = (void*)0;
        if (l_154)
        { /* block id: 80 */
            int32_t l_163 = 0xDF57287CL;
            int32_t l_229 = (-5L);
            for (p_17 = 17; (p_17 < (-21)); p_17 -= 3)
            { /* block id: 83 */
                int32_t l_164 = 0x1A1128F6L;
            }
            (****l_153) = (*g_84);
            (**l_169) = (void*)0;
            for (g_32 = 0; (g_32 <= (-19)); --g_32)
            { /* block id: 106 */
                uint8_t l_209 = 0xBCL;
                uint32_t l_231 = 0x95C60AA6L;
                int32_t ***l_234 = &g_113;
                int32_t l_237 = 0x89C804F7L;
                l_163 = (l_163 < ((int32_t)0L + (int32_t)(((int32_t)(((uint16_t)((+((uint16_t)(g_78 == (((p_17 <= ((((p_17 & l_208) != (p_17 & (&g_85 != &g_85))) && 0x8327L) < 1UL)) <= l_209) && g_40)) >> (uint16_t)p_17)) < g_10) % (uint16_t)0xD11FL) && 1UL) + (int32_t)l_209) > l_163)));
                if ((((uint16_t)g_212 >> (uint16_t)(((uint16_t)(((uint16_t)(l_154 <= (p_17 == l_154)) << (uint16_t)7) > l_209) - (uint16_t)(l_209 ^ p_17)) == ((int16_t)0x2F75L << (int16_t)11))) >= (((*l_146) != (*g_112)) < l_154)))
                { /* block id: 108 */
                    uint16_t l_221 = 65535UL;
                    l_221 = 1L;
                    l_230 = func_56(((-7L) | (((int32_t)(l_221 && (+((l_163 < (p_17 < ((uint32_t)(*l_147) + (uint32_t)l_154))) != l_229))) + (int32_t)l_163) > g_77)), g_212, g_212);
                    /* statement id: 110 */
                    assert (l_230 == &g_10);
                    if (l_231)
                        break;
                    if (p_17)
                        continue;
                }
                else
                { /* block id: 113 */
                    int32_t ***l_235 = &g_113;
                    int32_t *****l_236 = &l_145;
                    l_237 = (((((l_231 > (-3L)) && (!(((~(l_229 > (l_234 != l_235))) == ((((void*)0 != l_236) > (p_17 != (p_17 == p_17))) != 0x16CEL)) <= 0xE54DL))) == 0x0B9B3221L) ^ g_77) <= g_80);
                    for (l_154 = 7; (l_154 >= (-12)); l_154 -= 1)
                    { /* block id: 117 */
                        l_163 = 0x9875E5E2L;
                    }
                }
                if (((((((int16_t)((*l_145) != (void*)0) << (int16_t)6) || (((int32_t)(*l_147) % (int32_t)(*l_147)) && ((int16_t)(0x7D5AL ^ ((int32_t)(((*g_112) != &g_85) == (*l_147)) - (int32_t)((~p_17) != p_17))) + (int16_t)0x36A7L))) & 0x675DL) < 0xE16E7FE3L) >= 0x6BD1L))
                { /* block id: 121 */
                    int32_t *l_252 = &g_32;
                    (*g_152) = (*g_112);
                    for (g_40 = 12; (g_40 <= 5); --g_40)
                    { /* block id: 125 */
                        int32_t *l_251 = &l_154;
                        (***g_151) = l_251;
                        /* statement id: 126 */
                        assert (g_85 == &l_154);
                        (****l_153) = l_252;
                        /* statement id: 127 */
                        assert (g_85 == &g_32);
                        (**l_169) = &l_163;
                        /* statement id: 128 */
                        assert (g_85 == &l_163);
                    }
                    for (l_229 = 0; (l_229 != 24); l_229++)
                    { /* block id: 132 */
                        int32_t l_255 = (-1L);
                        int32_t *l_270 = &l_237;
                        l_255 = (l_255 == ((uint16_t)g_79 + (uint16_t)((((((int16_t)g_32 - (int16_t)l_260) > ((((((uint16_t)((g_10 && g_80) >= ((((uint32_t)((g_32 < ((((int16_t)((+(g_10 == 65528UL)) > 0UL) % (int16_t)p_17) ^ l_163) > l_268)) || 0xCD56L) - (uint32_t)l_229) || p_17) && 65535UL)) % (uint16_t)0x71EDL) || g_10) > 0x9C3AL) || p_17) || 4294967295UL)) && 65533UL) || l_269) == p_17)));
                        l_255 = 0xB2D896DFL;
                        (*l_270) = p_17;
                    }
                }
                else
                { /* block id: 137 */
                    int32_t l_281 = 5L;
                    l_163 = (((uint16_t)p_17 - (uint16_t)9L) > (((int32_t)((uint32_t)0xAE4665AAL % (uint32_t)((int16_t)((g_212 & (65532UL != 0x52A2L)) ^ ((((p_17 == g_79) <= 0L) < p_17) != p_17)) % (int16_t)65535UL)) % (int32_t)l_281) == g_10));
                }
            }
            /* facts after for loop */
            assert (g_85 == &l_163 || g_85 == 0);
            assert (l_230 == &g_10 || l_230 == 0);
        }
        else
        { /* block id: 141 */
            return p_17;
        }
        /* facts after branching */
        //assert (g_85 == dangling || g_85 == 0);
        assert (l_230 == &g_10 || l_230 == 0);
        (***g_150) = (void*)0;
        /* statement id: 144 */
        assert (g_84 == 0);
        (*l_147) = 0L;
        (*l_147) = p_17;
    }
    /* facts after branching */
    //assert (g_85 == dangling || g_85 == 0);
    assert (g_84 == 0 || g_84 == &g_85);
    return l_282;
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_40 g_10 g_31 g_84 g_80 g_85 g_112 g_113 g_144
 * writes: g_32 g_40 g_80 g_85 g_113
 */
static int16_t  func_20(uint32_t  p_21)
{ /* block id: 5 */
    int32_t *l_63 = &g_32;
    for (p_21 = 0; (p_21 != 30); p_21++)
    { /* block id: 8 */
        int32_t *l_44 = &g_10;
        for (g_32 = 0; (g_32 <= 4); g_32 += 7)
        { /* block id: 11 */
            int32_t *l_37 = (void*)0;
            int32_t *l_38 = (void*)0;
            int32_t *l_39 = &g_40;
            (*l_39) = (-6L);
            (*g_144) = func_41(l_44, (!((~((uint32_t)func_49(((int16_t)func_54(func_56(((((!(((uint16_t)((void*)0 != &g_10) >> (uint16_t)5) >= g_32)) < ((((void*)0 == l_63) | (((uint16_t)(((uint32_t)(((int16_t)0x1ED3L << (int16_t)(!((int16_t)(*l_39) >> (int16_t)(l_37 == l_63)))) ^ g_10) - (uint32_t)p_21) > (*l_63)) << (uint16_t)g_40) < 4294967295UL)) < (*l_63))) ^ (*g_31)) != g_10), p_21, g_10)) % (int16_t)(*l_63)), p_21) - (uint32_t)g_10)) < (*l_63))));
        }
        (*g_113) = (*g_144);
        (*g_113) = l_44;
        /* statement id: 70 */
        assert (g_85 == &g_10);
    }
    /* facts after for loop */
    assert (g_85 == &g_10 || g_85 == &g_80);
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_10
 * writes: g_32
 */
static uint16_t  func_24(int16_t  p_25, int32_t * p_26, int32_t * p_27)
{ /* block id: 2 */
    int32_t *l_30 = &g_10;
    (*g_31) = (l_30 != p_27);
    return (*l_30);
}


/* ------------------------------------------ */
/* 
 * reads : g_112 g_40 g_85 g_10 g_80 g_113 g_84
 * writes: g_113 g_40 g_80
 */
static int32_t * func_41(int32_t * p_42, int32_t  p_43)
{ /* block id: 47 */
    int32_t **l_111 = &g_85;
    int16_t l_133 = 1L;
    int32_t *l_143 = &g_40;
    for (p_43 = 0; (p_43 <= (-5)); --p_43)
    { /* block id: 50 */
        uint32_t l_131 = 6UL;
        int32_t *l_132 = (void*)0;
        (*g_112) = l_111;
        for (g_40 = (-9); (g_40 > (-12)); --g_40)
        { /* block id: 54 */
            int32_t ** volatile *l_117 = (void*)0;
            int32_t ** volatile **l_116 = &l_117;
            (*l_116) = &g_84;
            /* statement id: 55 */
            assert (l_117 == &g_84);
        }
        for (g_40 = 0; (g_40 >= 26); g_40++)
        { /* block id: 59 */
            int32_t *l_134 = &g_80;
            (*l_134) = (((uint16_t)p_43 - (uint16_t)(((((int16_t)(((((int16_t)((uint16_t)(**l_111) << (uint16_t)((+1UL) != ((uint16_t)(p_43 == (**g_113)) >> (uint16_t)8))) << (int16_t)((**g_84) || (**l_111))) == l_131) <= ((p_42 != l_132) && 0L)) ^ p_43) - (int16_t)g_10) < g_10) > g_10) == l_133)) <= (-1L));
            (*l_134) = (0x86BEL > (!((int32_t)((((**l_111) | (**l_111)) == (((uint32_t)(**l_111) - (uint32_t)(5L != (*l_134))) < ((uint16_t)(((3UL ^ (**l_111)) && (&l_111 == (void*)0)) > (*l_134)) + (uint16_t)(**l_111)))) && (*l_134)) % (int32_t)(**l_111))));
            return (*g_84);
            /* statement id: 62 */
            //assert (func_41_rv == &g_10 || func_41_rv == &g_80);
        }
    }
    (*l_143) = (*p_42);
    return (*g_84);
    /* statement id: 66 */
    //assert (func_41_rv == &g_10 || func_41_rv == &g_80);
}


/* ------------------------------------------ */
/* 
 * reads : g_40 g_80 g_10 g_85 g_84
 * writes: g_40 g_80 g_85
 */
static uint32_t  func_49(uint32_t  p_50, uint16_t  p_51)
{ /* block id: 29 */
    int32_t **l_88 = &g_85;
    int32_t ***l_87 = &l_88;
    int32_t *l_96 = &g_10;
    int32_t **l_107 = &g_85;
    int16_t l_108 = 1L;
    (*l_87) = (void*)0;
    /* statement id: 30 */
    assert (l_88 == 0);
    for (p_50 = (-24); (p_50 < 2); p_50 += 3)
    { /* block id: 33 */
        uint16_t l_95 = 0UL;
        for (g_40 = 0; (g_40 < 20); g_40 += 1)
        { /* block id: 36 */
            for (g_80 = 14; (g_80 == (-11)); g_80--)
            { /* block id: 39 */
                return l_95;
            }
        }
    }
    l_96 = l_96;
    (*l_107) = func_56((-(uint32_t)((((*l_96) || 65535UL) < (-3L)) > (p_50 ^ p_50))), (~(((int16_t)((uint16_t)((int16_t)(((uint16_t)(p_50 | ((l_107 != (*l_87)) || ((*l_107) == (*g_84)))) >> (uint16_t)7) & l_108) + (int16_t)g_40) << (uint16_t)g_80) << (int16_t)9) | g_80)), p_50);
    /* statement id: 45 */
    assert (g_85 == &g_10);
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads : g_40 g_84 g_80
 * writes: g_40 g_80 g_85
 */
static int16_t  func_54(int32_t * p_55)
{ /* block id: 17 */
    for (g_40 = 0; (g_40 <= (-16)); --g_40)
    { /* block id: 20 */
        for (g_80 = 0; (g_80 != 0); g_80 += 1)
        { /* block id: 23 */
            int32_t **l_83 = (void*)0;
            int32_t ***l_86 = &l_83;
            (*g_84) = p_55;
            /* statement id: 24 */
            assert (g_85 == &g_10);
            (*l_86) = &g_85;
            /* statement id: 25 */
            assert (l_83 == &g_85);
        }
    }
    return g_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_40
 */
static int32_t * func_56(uint8_t  p_57, uint8_t  p_58, uint8_t  p_59)
{ /* block id: 13 */
    int32_t *l_73 = &g_10;
    int32_t *l_74 = &g_40;
    (*l_74) = ((void*)0 == l_73);
    l_73 = l_74;
    /* statement id: 15 */
    assert (l_73 == &g_40);
    return &g_10;
    /* statement id: 16 */
    //assert (func_56_rv == &g_10);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_10, "g_10", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    transparent_crc(g_40, "g_40", print_hash_value);
    transparent_crc(g_77, "g_77", print_hash_value);
    transparent_crc(g_78, "g_78", print_hash_value);
    transparent_crc(g_79, "g_79", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_212, "g_212", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 50
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 18
   depth: 8, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 57

XXX times a variable address is taken: 55
XXX times a pointer is dereferenced on RHS: 61
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 35
breakdown:
   depth: 1, occurrence: 26
   depth: 2, occurrence: 3
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 293

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 150
   level: 2, occurrence: 58
   level: 3, occurrence: 53
   level: 4, occurrence: 21
   level: 5, occurrence: 17
XXX number of pointers point to pointers: 24
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 19.3
XXX average alias set size: 1.25

XXX times a non-volatile is read: 326
XXX times a non-volatile is write: 102
XXX times a volatile is read: 24
XXX    times read thru a pointer: 5
XXX times a volatile is write: 19
XXX    times written thru a pointer: 15
XXX times a volatile is available for access: 98
XXX percentage of non-volatile access: 90.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 80
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 13
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 10
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 13.8
XXX percentage an existing variable is used: 86.2
********************* end of statistics **********************/

