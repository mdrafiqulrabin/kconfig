/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      822911474
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U1 {
   uint32_t  f0;
};

union U3 {
   const int32_t  f0;
   volatile uint16_t  f1;
   const int16_t  f2;
   int32_t  f3;
};

union U4 {
   uint8_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 0xEA66E58D;
static volatile int32_t g_67 = 1;/* VOLATILE GLOBAL g_67 */
static const volatile int32_t *g_66 = &g_67;
static int32_t g_72 = 9;
static union U3 g_83 = {0};/* VOLATILE GLOBAL g_83 */
static union U3 *g_82 = &g_83;
static union U3 g_85 = {-10};/* VOLATILE GLOBAL g_85 */
static union U4 g_135 = {9U};
static union U4 *g_134 = &g_135;
static int32_t **g_137 = (void*)0;
static int32_t ***g_136 = &g_137;
static int32_t g_192 = 9;
static int32_t g_226 = 0x877F8201;
static uint32_t g_228 = 4294967294U;
static union U1 g_234 = {0x23E7C5B9};
static int32_t *g_236 = &g_72;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_27(void);
inline static int32_t  func_28(union U4  p_29, int32_t  p_30, union U1  p_31);
inline static union U4  func_32(uint32_t  p_33, uint8_t  p_34, int32_t  p_35, uint32_t  p_36);
inline static uint8_t  func_37(union U4  p_38);
inline static union U4  func_39(union U4  p_40, union U1  p_41, uint32_t  p_42, int16_t  p_43, int32_t  p_44);
static union U4  func_45(uint8_t  p_46);
static uint8_t  func_47(uint8_t  p_48, uint8_t  p_49);
static uint16_t  func_57(union U4  p_58, const union U1  p_59, union U4  p_60, int16_t  p_61);
inline static union U4  func_62(uint32_t  p_63, uint8_t  p_64);
static int32_t * const  func_73(union U4  p_74, uint32_t  p_75, const int32_t  p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_66 g_67 g_72 g_82 g_85.f3 g_83.f2 g_85.f1 g_85.f2 g_83.f3 g_134 g_136 g_135.f0 g_83.f0 g_137 g_192 g_85.f0 g_226 g_228 g_234 g_83.f1 g_234.f0 g_135
 * writes: g_72 g_83.f3 g_82 g_85.f3 g_136 g_192 g_137 g_236 g_226
 */
static int32_t  func_27(void)
{ /* block id: 36 */
    int16_t l_65 = 0x4489;
    const union U1 l_90 = {1U};
    union U4 l_91 = {253U};
    uint32_t l_176 = 0U;
    uint32_t l_227 = 4294967288U;
    int32_t *l_248 = &g_85.f3;
    union U3 **l_250 = &g_82;
    union U3 ***l_249 = &l_250;
    int32_t **l_251 = &l_248;
    uint32_t l_252 = 0x1289C804;
    (*l_248) = func_28(func_32(g_6, func_37(func_39(func_45(func_47((safe_lshift_func_int16_t_s_u(((safe_mul_func_int16_t_s_s((g_6 && (safe_mod_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(0x5FCB4448)), 0x0CBB))), func_57(func_62(l_65, g_6), l_90, l_91, g_85.f3))) ^ l_65), 2)), l_176)), l_90, g_6, l_91.f0, g_135.f0)), l_227, g_6), l_227, g_234);
    /* statement id: 146 */
    assert (g_82 == &g_83 || g_82 == &g_85);
    assert (g_236 == &g_226);
    (*l_249) = &g_82;
    (*l_251) = l_248;
    (*l_248) = func_57(l_91, g_234, (*g_134), g_83.f3);
    return l_252;
}


/* ------------------------------------------ */
/* 
 * reads : g_83.f1 g_85.f3 g_192 g_234.f0 g_135.f0 g_226
 * writes: g_236 g_226
 */
inline static int32_t  func_28(union U4  p_29, int32_t  p_30, union U1  p_31)
{ /* block id: 142 */
    int32_t *l_235 = &g_226;
    union U3 **l_245 = (void*)0;
    g_236 = l_235;
    /* statement id: 143 */
    assert (g_236 == &g_226);
    (*l_235) = (g_83.f1 | (safe_sub_func_int16_t_s_s(g_85.f3, ((p_31.f0 != (safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(g_192, (((65535U > (safe_lshift_func_uint16_t_u_u((l_245 != l_245), (((safe_sub_func_uint16_t_u_u(g_234.f0, 0x60D9)) <= g_135.f0) | 0)))) >= 0x5E86) != (*l_235)))), g_226))) & 0xD83BFFE3))));
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads : g_228 g_85.f3 g_66 g_67 g_72 g_82
 * writes: g_72
 */
inline static union U4  func_32(uint32_t  p_33, uint8_t  p_34, int32_t  p_35, uint32_t  p_36)
{ /* block id: 139 */
    union U3 **l_229 = (void*)0;
    int32_t **l_230 = (void*)0;
    int32_t *l_232 = &g_226;
    int32_t **l_231 = &l_232;
    union U4 l_233 = {1U};
    (*l_231) = func_73(func_62(g_228, (65533U < (p_34 | (((void*)0 != l_229) <= g_85.f3)))), (&g_134 == (void*)0), p_36);
    /* statement id: 140 */
    assert (l_232 == &g_72);
    return l_233;
    /* statement id: 141 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_136 g_192 g_85.f2 g_66 g_67 g_83.f3 g_137 g_135.f0 g_72 g_82 g_85.f0 g_226
 * writes: g_137 g_83.f3 g_85.f3 g_72
 */
inline static uint8_t  func_37(union U4  p_38)
{ /* block id: 128 */
    int32_t **l_195 = (void*)0;
    union U3 **l_205 = &g_82;
    int32_t *l_223 = &g_85.f3;
    (*g_136) = l_195;
    if ((safe_add_func_uint32_t_u_u((safe_unary_minus_func_uint32_t_u(__builtin_clzll(g_192))), (safe_rshift_func_uint16_t_u_s(g_85.f2, 5)))))
    { /* block id: 130 */
        const int32_t ***l_203 = (void*)0;
        union U3 **l_206 = &g_82;
        int16_t l_207 = 1;
        int32_t l_208 = 0x2B29A1D6;
        l_208 = ((safe_add_func_int16_t_s_s(((((*g_66) < (((void*)0 == l_203) >= g_83.f3)) & (0xBAEC & g_85.f2)) < ((!0x73B84CAB) < ((l_205 == l_206) | l_207))), g_85.f2)) > 0x98F6BB93);
        return p_38.f0;
    }
    else
    { /* block id: 133 */
        int32_t l_215 = 0x1E2C77FF;
        int32_t *l_220 = &g_83.f3;
        int32_t **l_219 = &l_220;
        (*l_219) = func_73(func_45(p_38.f0), g_135.f0, (((safe_add_func_int32_t_s_s((safe_mod_func_uint32_t_u_u((safe_mul_func_int16_t_s_s(0xE9A9, g_72)), l_215)), (safe_sub_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(((((l_215 == g_192) & __builtin_clz((l_215 < g_135.f0))) || 0xF530D896) & 0xDD21))), (-1))))) > p_38.f0) || g_135.f0));
        /* statement id: 134 */
        assert (l_220 == &g_72);
        (*l_223) = ((p_38.f0 <= ((safe_rshift_func_uint16_t_u_u(((((*l_219) != l_223) & (((p_38.f0 | p_38.f0) | 0U) && g_135.f0)) ^ (p_38.f0 <= ((void*)0 != l_205))), 13)) || p_38.f0)) ^ p_38.f0);
        (*l_220) = (safe_mul_func_uint16_t_u_u(p_38.f0, g_85.f0));
    }
    return g_226;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_82 g_192
 */
inline static union U4  func_39(union U4  p_40, union U1  p_41, uint32_t  p_42, int16_t  p_43, int32_t  p_44)
{ /* block id: 119 */
    union U4 l_190 = {0xB2};
    int32_t *l_194 = &g_192;
    for (p_40.f0 = (-20); (p_40.f0 != 52); p_40.f0 = safe_add_func_int32_t_s_s(p_40.f0, 2))
    { /* block id: 122 */
        union U3 **l_187 = &g_82;
        union U4 l_191 = {0U};
        int32_t *l_193 = &g_192;
        (*l_187) = &g_85;
        /* statement id: 123 */
        assert (g_82 == &g_85);
    }
    (*l_194) = p_41.f0;
    return p_40;
    /* statement id: 127 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_85.f3 g_136 g_137
 * writes: g_83.f3 g_85.f3
 */
static union U4  func_45(uint8_t  p_46)
{ /* block id: 109 */
    int32_t *l_180 = &g_83.f3;
    union U4 l_184 = {0xDF};
    (*l_180) = 8;
    /* statement id: 110 */
    for (g_85.f3 = 0; (g_85.f3 > 4); g_85.f3 = safe_add_func_uint32_t_u_u(g_85.f3, 4))
    { /* block id: 113 */
        union U4 l_183 = {0x78};
        (*l_180) = __builtin_ffs(((*g_136) == (void*)0));
        if (p_46)
            break;
        return l_183;
        /* statement id: 116 */
            }
    /* facts after for loop */
    return l_184;
    /* statement id: 118 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_6 g_66 g_67 g_72 g_82 g_135.f0 g_83.f0 g_83.f3
 * writes: g_72
 */
static uint8_t  func_47(uint8_t  p_48, uint8_t  p_49)
{ /* block id: 106 */
    uint32_t l_177 = 0x4B528247;
    int32_t *l_179 = &g_72;
    int32_t **l_178 = &l_179;
    (*l_178) = func_73(func_62(g_6, l_177), g_135.f0, ((l_177 || g_83.f0) >= g_83.f3));
    return g_6;
}


/* ------------------------------------------ */
/* 
 * reads : g_82 g_85.f3 g_6 g_66 g_67 g_72 g_83.f2 g_85.f1 g_85.f2 g_83.f3 g_134 g_136 g_135.f0
 * writes: g_72 g_83.f3 g_82 g_85.f3 g_136
 */
static uint16_t  func_57(union U4  p_58, const union U1  p_59, union U4  p_60, int16_t  p_61)
{ /* block id: 51 */
    int16_t l_94 = 0xAC86;
    int32_t *l_97 = &g_85.f3;
    uint32_t l_114 = 0xDF249A23;
    for (p_58.f1 = 0; (p_58.f1 <= 5); p_58.f1 = safe_add_func_uint32_t_u_u(p_58.f1, 5))
    { /* block id: 54 */
        int32_t *l_128 = &g_85.f3;
        l_97 = func_73(p_58, l_94, ((-1) < __builtin_popcountl((p_61 < (l_97 != (void*)0)))));
        /* statement id: 55 */
        assert (l_97 == &g_72);
        (*l_97) = 0x364560F9;
        for (g_83.f3 = 0; (g_83.f3 >= (-9)); g_83.f3 = safe_sub_func_int32_t_s_s(g_83.f3, 1))
        { /* block id: 59 */
            uint32_t l_112 = 0x596DEF04;
            for (l_94 = 17; (l_94 == 17); l_94 = safe_add_func_uint32_t_u_u(l_94, 1))
            { /* block id: 62 */
                for (p_60.f0 = 1; (p_60.f0 > 5); p_60.f0 = safe_add_func_int32_t_s_s(p_60.f0, 5))
                { /* block id: 65 */
                    int32_t l_113 = (-10);
                    (*l_97) = ((safe_mul_func_int16_t_s_s((__builtin_clz(g_85.f3) & ((void*)0 != l_97)), ((safe_add_func_uint16_t_u_u((1 & (safe_sub_func_uint32_t_u_u(g_6, ((*g_66) | (safe_rshift_func_int16_t_s_s((l_112 > (((((void*)0 == g_82) == l_113) <= (*l_97)) ^ l_114)), 9)))))), g_83.f2)) == 65529U))) < g_6);
                    for (l_113 = 0; (l_113 >= 6); l_113 = safe_add_func_int16_t_s_s(l_113, 1))
                    { /* block id: 69 */
                        const int32_t *l_119 = &g_85.f3;
                        const int32_t **l_118 = &l_119;
                        const int32_t ***l_117 = &l_118;
                        (*l_117) = (void*)0;
                        /* statement id: 70 */
                        assert (l_118 == 0);
                    }
                    if ((g_6 && ((safe_lshift_func_int16_t_s_u((safe_add_func_int16_t_s_s(g_85.f1, g_85.f2)), ((&g_72 == (void*)0) & (safe_lshift_func_int16_t_s_u((safe_mul_func_uint32_t_u_u((*l_97), (g_83.f3 < ((((-7) || (l_128 == l_128)) && 1U) < (*l_128))))), p_58.f1))))) >= 0x179D)))
                    { /* block id: 72 */
                        union U3 **l_129 = &g_82;
                        union U4 *l_131 = (void*)0;
                        union U4 **l_130 = &l_131;
                        (*l_129) = &g_85;
                        /* statement id: 73 */
                        assert (g_82 == &g_85);
                        (*l_130) = (void*)0;
                    }
                    else
                    { /* block id: 75 */
                        (*l_97) = (p_58.f0 < (safe_sub_func_uint32_t_u_u((8U >= p_58.f0), (g_134 != &g_135))));
                    }
                }
                (*l_128) = 0x03F479F8;
                /* statement id: 79 */
            }
            g_136 = g_136;
            if (p_58.f1)
                continue;
        }
        /* facts after for loop */
        (*l_128) = ((*l_97) || __builtin_ffs((!1U)));
        /* statement id: 84 */
    }
    /* facts after for loop */
        assert (l_97 == &g_72 || l_97 == &g_85.f3);
    (*l_97) = (safe_lshift_func_uint16_t_u_s((*l_97), ((safe_lshift_func_int16_t_s_u(((safe_rshift_func_int16_t_s_s(((((p_60.f0 != ((*l_97) == (safe_unary_minus_func_uint16_t_u((~0xF30E))))) <= (safe_mul_func_int16_t_s_s((*l_97), (&p_60 != &g_135)))) != ((((safe_sub_func_int16_t_s_s(((((g_135.f0 <= (safe_lshift_func_int16_t_s_s(g_85.f1, g_72))) ^ p_60.f0) < p_61) > 4U), p_58.f0)) < p_59.f0) | 2U) <= 0x3334)) <= g_6), 4)) == g_85.f2), g_85.f2)) <= 0)));
    /* statement id: 86 */
    (*l_97) = (safe_unary_minus_func_uint16_t_u(g_72));
    for (g_72 = 0; (g_72 < 5); g_72 = safe_add_func_uint32_t_u_u(g_72, 1))
    { /* block id: 90 */
        int32_t *l_157 = (void*)0;
        int32_t *l_158 = &g_85.f3;
        (*l_158) = (safe_unary_minus_func_int32_t_s((-7)));
        /* statement id: 91 */
        if (__builtin_clzll(g_72))
        { /* block id: 92 */
            int32_t *l_159 = (void*)0;
            int32_t *l_160 = &g_85.f3;
            int32_t *l_161 = &g_83.f3;
            int32_t ***l_169 = &g_137;
            int16_t l_173 = 0xFBB0;
            (*l_161) = (*l_97);
            /* statement id: 93 */
            (*l_160) = ((65529U >= 1) & (p_58.f0 < p_61));
            for (g_83.f3 = 0; (g_83.f3 <= (-29)); g_83.f3 = safe_sub_func_int16_t_s_s(g_83.f3, 2))
            { /* block id: 97 */
                uint8_t l_166 = 0xC2;
                (*l_160) = ((p_59.f0 <= g_135.f0) != ((safe_mul_func_uint16_t_u_u(__builtin_ctz(l_166), ((safe_sub_func_int16_t_s_s(((void*)0 != l_169), (safe_unary_minus_func_uint32_t_u(p_58.f0)))) < g_85.f1))) & (~(!(*l_161)))));
            }
            if (l_173)
                break;
        }
        else
        { /* block id: 101 */
            union U4 l_174 = {0x7D};
            int32_t **l_175 = &l_157;
            (*l_175) = func_73(l_174, l_174.f0, p_58.f1);
            /* statement id: 102 */
            assert (l_157 == &g_72);
        }
        /* facts after branching */
        assert (l_157 == &g_72 || l_157 == 0);
    }
    return g_135.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_67 g_72 g_82
 * writes: g_72
 */
inline static union U4  func_62(uint32_t  p_63, uint8_t  p_64)
{ /* block id: 37 */
    const volatile int32_t *l_68 = &g_67;
    union U4 l_77 = {0x3E};
    int32_t *l_89 = &g_83.f3;
    int32_t **l_88 = &l_89;
    l_68 = g_66;
    for (p_63 = 0; (p_63 == 37); ++p_63)
    { /* block id: 41 */
        int32_t *l_71 = &g_72;
        (*l_71) = 0x49EF57A5;
    }
    (*l_88) = func_73(l_77, p_63, (((safe_mul_func_uint16_t_u_u((l_68 == l_68), ((l_68 != &g_67) >= ((safe_add_func_uint16_t_u_u(65535U, (0 ^ (((*g_66) <= g_72) == g_72)))) <= 0xB38A83A5)))) || g_67) < 0x3DB47DC4));
    /* statement id: 49 */
    assert (l_89 == &g_72);
    return l_77;
    /* statement id: 50 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_82
 * writes:
 */
static int32_t * const  func_73(union U4  p_74, uint32_t  p_75, const int32_t  p_76)
{ /* block id: 44 */
    union U3 *l_84 = &g_85;
    const int32_t *l_86 = &g_72;
    int32_t l_87 = 8;
    l_84 = g_82;
    /* statement id: 45 */
    assert (l_84 == &g_83 || l_84 == &g_85);
    l_86 = &p_76;
    /* statement id: 46 */
    assert (l_86 == &p_76);
    l_87 = 0xF4926A67;
    return &g_72;
    /* statement id: 48 */
    //assert (func_73_rv == &g_72);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_67, "g_67", print_hash_value);
    transparent_crc(g_72, "g_72", print_hash_value);
    transparent_crc(g_83.f0, "g_83.f0", print_hash_value);
    transparent_crc(g_83.f1, "g_83.f1", print_hash_value);
    transparent_crc(g_83.f2, "g_83.f2", print_hash_value);
    transparent_crc(g_83.f3, "g_83.f3", print_hash_value);
    transparent_crc(g_85.f0, "g_85.f0", print_hash_value);
    transparent_crc(g_85.f1, "g_85.f1", print_hash_value);
    transparent_crc(g_85.f2, "g_85.f2", print_hash_value);
    transparent_crc(g_85.f3, "g_85.f3", print_hash_value);
    transparent_crc(g_135.f0, "g_135.f0", print_hash_value);
    transparent_crc(g_192, "g_192", print_hash_value);
    transparent_crc(g_226, "g_226", print_hash_value);
    transparent_crc(g_228, "g_228", print_hash_value);
    transparent_crc(g_234.f0, "g_234.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 54
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 22, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 51

XXX times a variable address is taken: 52
XXX times a pointer is dereferenced on RHS: 17
breakdown:
   depth: 1, occurrence: 17
XXX times a pointer is dereferenced on LHS: 33
breakdown:
   depth: 1, occurrence: 33
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 127

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 128
   level: 2, occurrence: 5
   level: 3, occurrence: 11
XXX number of pointers point to pointers: 23
XXX number of pointers point to scalars: 24
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 19.6
XXX average alias set size: 1.12

XXX times a non-volatile is read: 217
XXX times a non-volatile is write: 84
XXX times a volatile is read: 8
XXX    times read thru a pointer: 3
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 102
XXX percentage of non-volatile access: 97.4

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 68
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 16
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 23.2
XXX percentage an existing variable is used: 76.8
********************* end of statistics **********************/

