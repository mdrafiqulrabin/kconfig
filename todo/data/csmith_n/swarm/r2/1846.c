/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2587662570
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   float  f0;
   uint32_t  f1;
   int32_t  f2;
   const uint32_t  f3;
   signed f4 : 31;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_28(void);
static int32_t * func_29(float  p_30, int32_t * p_31, float  p_32, const int32_t * p_33, int32_t * p_34);
static union U0  func_38(int32_t * const  p_39, float  p_40, int32_t * p_41, int32_t  p_42);
static int32_t * const  func_43(uint16_t  p_44, int16_t  p_45);
static int32_t  func_54(uint32_t  p_55, uint32_t  p_56, uint16_t  p_57, uint16_t  p_58, int32_t  p_59);
static uint32_t  func_60(int8_t  p_61, int16_t  p_62, int16_t  p_63, uint16_t  p_64);
static int8_t  func_65(int32_t * p_66, const union U0  p_67, float  p_68, int32_t * const  p_69);
static int32_t * func_70(union U0  p_71, int32_t  p_72, uint32_t  p_73, int32_t * p_74, float  p_75);
static union U0  func_76(const uint32_t  p_77, float  p_78);
static int32_t * const  func_80(int32_t  p_81, int32_t * p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_35 = 6U;
    int32_t l_46 = 0x33147F59;
    const uint32_t l_79 = 4294967295U;
    const union U0 l_120 = {0x0.Ep+1};
    int8_t l_390 = 1;
    float l_392 = (-0x1.Bp-1);
    float *l_391 = &l_392;
    int32_t *l_393 = &l_46;
    int32_t **l_421 = &l_393;
    int32_t *l_422 = &l_46;
    int32_t * const l_426 = (void*)0;
    uint32_t l_431 = 4294967293U;
lbl_430:
    (*l_421) = func_29(((*l_391) = (l_35 >= (((l_35 >= ((int16_t)((func_38(func_43(l_46, l_35), ((func_54(((&l_46 == (void*)0) && ((func_60(func_65(func_70(func_76(((((l_46 ^ l_35) , (-0x1.1p+1)) , l_35) , l_79), l_46), l_46, l_35, &l_46, l_46), l_120, l_120.f4, &l_46), l_120.f2, l_120.f4, l_120.f1) || 0xE0827B68) < l_120.f1)), l_46, l_79, l_79, l_120.f2) , (void*)0) == (void*)0), &l_46, l_46) , &l_46) != &l_46) - (int16_t)0)) != l_390) , l_120.f1))), &l_46, l_35, &l_46, l_393);
    (*l_391) = (**l_421);
    for (l_46 = 0; (l_46 != 14); l_46 += 7)
    { /* block id: 246 */
        const int32_t *l_429 = &l_120.f2;
        l_429 = l_429;
        if ((*l_429))
            continue;
        if (l_120.f1)
            goto lbl_430;
        if ((*l_429))
            break;
    }
    (*l_421) = (*l_421);
    return l_431;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_29(float  p_30, int32_t * p_31, float  p_32, const int32_t * p_33, int32_t * p_34)
{ /* block id: 235 */
    int32_t l_396 = 0x5E8AD480;
    int8_t l_397 = (-1);
    int8_t **l_405 = (void*)0;
    int8_t *l_407 = &l_397;
    int8_t **l_406 = &l_407;
    union U0 l_413 = {0x4.9p-1};
    float l_414 = 0x6.C83041p-63;
    uint32_t *l_415 = (void*)0;
    uint32_t l_417 = 7U;
    uint32_t *l_416 = &l_417;
    float *l_418 = &l_414;
    int32_t *l_420 = &l_413.f2;
    int32_t **l_419 = &l_420;
    (*l_418) = (((((((uint32_t)(l_396 && (l_397 != ((int16_t)(l_396 , (-(uint16_t)l_397)) - (int16_t)((int16_t)(((int16_t)(&l_397 == ((*l_406) = &l_397)) << (int16_t)(+((*l_416) = (0xAF920992 < (((uint16_t)__builtin_clzll((((uint16_t)((l_413 , ((*p_34) = (((l_413.f3 , l_397) != l_397) >= l_413.f2))) != (-1)) >> (uint16_t)8) & l_413.f4)) << (uint16_t)0) && l_413.f4))))) > l_413.f3) + (int16_t)l_396)))) % (uint32_t)l_413.f2) > l_397) , (-0x1.5p+1)) , l_413.f3) ^ 0x0CD7) , 0x5.CB414Fp+98);
    (*l_419) = p_33;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_38(int32_t * const  p_39, float  p_40, int32_t * p_41, int32_t  p_42)
{ /* block id: 230 */
    int32_t l_388 = (-1);
    int32_t *l_387 = &l_388;
    int32_t **l_386 = &l_387;
    union U0 l_389 = {0x7.7E6AA6p-17};
    (*l_386) = &p_42;
    (**l_386) = (**l_386);
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_43(uint16_t  p_44, int16_t  p_45)
{ /* block id: 37 */
    uint16_t l_47 = 3U;
    int32_t l_49 = 0x89D9E62B;
    int32_t * const l_48 = &l_49;
    int32_t * const l_50 = &l_49;
    int32_t * const l_51 = &l_49;
    int32_t * const l_52 = &l_49;
    int32_t * const l_53 = (void*)0;
    l_47 = (-1);
    return l_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_54(uint32_t  p_55, uint32_t  p_56, uint16_t  p_57, uint16_t  p_58, int32_t  p_59)
{ /* block id: 221 */
    uint16_t *****l_375 = (void*)0;
    uint16_t l_381 = 0U;
    uint16_t *l_380 = &l_381;
    uint16_t **l_379 = &l_380;
    uint16_t ***l_378 = &l_379;
    uint16_t ****l_377 = &l_378;
    uint16_t *****l_376 = &l_377;
    int32_t l_382 = 0x7E57FD0B;
    l_382 = ((l_375 = l_375) != l_376);
    for (p_58 = 0; (p_58 == 26); p_58 += 2)
    { /* block id: 226 */
        int8_t l_385 = 0x41;
        return l_385;
    }
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_60(int8_t  p_61, int16_t  p_62, int16_t  p_63, uint16_t  p_64)
{ /* block id: 93 */
    const int32_t ***l_186 = (void*)0;
    int32_t l_191 = 0;
    int32_t *l_190 = &l_191;
    int32_t **l_189 = &l_190;
    int32_t ***l_188 = &l_189;
    int32_t ****l_187 = &l_188;
    uint16_t **l_249 = (void*)0;
    float l_279 = 0x0.2p+1;
    union U0 l_282 = {0x0.3p-1};
    union U0 *l_281 = &l_282;
    int32_t *****l_291 = &l_187;
    uint32_t l_305 = 0xE296A022;
    int32_t **l_373 = (void*)0;
    int32_t **l_374 = &l_190;
    if (((uint32_t)(((*l_187) = l_186) != &l_189) - (uint32_t)(p_64 ^ 0x86F5F88D)))
    { /* block id: 95 */
        int32_t *****l_192 = &l_187;
        float l_197 = 0x3.AC6A97p+8;
        uint16_t l_201 = 65535U;
        uint16_t *l_200 = &l_201;
        const union U0 l_202 = {0x3.D73A52p+75};
        int32_t *l_203 = (void*)0;
        int32_t *l_204 = &l_191;
        (*l_189) = (void*)0;
        l_192 = &l_187;
        (*l_204) = (((uint16_t)(((int16_t)p_63 >> (int16_t)((p_61 , __builtin_bswap64(p_61)) > ((uint16_t)((void*)0 == l_200) - (uint16_t)((p_64 , (p_64 , l_202.f4)) <= p_62)))) | 0xFA99) << (uint16_t)13) < p_61);
    }
    else
    { /* block id: 99 */
        int32_t l_216 = (-2);
        uint16_t l_231 = 65530U;
        union U0 l_234 = {0x9.80E9A8p-37};
        uint16_t *l_243 = &l_231;
        uint16_t **l_242 = &l_243;
        uint16_t ***l_285 = &l_242;
        uint16_t **** const l_284 = &l_285;
        int32_t *****l_290 = &l_187;
        int8_t l_304 = 7;
        int8_t *l_303 = &l_304;
        float *l_306 = &l_234.f0;
        int16_t *l_347 = (void*)0;
        int16_t l_349 = 0xEF7D;
        int16_t *l_348 = &l_349;
        float *l_350 = &l_279;
        float *l_351 = &l_282.f0;
        for (p_64 = (-10); (p_64 > 44); p_64 += 1)
        { /* block id: 102 */
            int32_t *l_207 = &l_191;
            int32_t *****l_218 = &l_187;
            if (((*l_190) = 0x3C7BDA22))
            { /* block id: 104 */
                int32_t *l_209 = &l_191;
                if (p_62)
                { /* block id: 105 */
                    int32_t **l_208 = &l_207;
                    (*l_189) = (*l_189);
                    (*l_208) = func_80(p_61, l_207);
                    (*l_189) = l_209;
                }
                else
                { /* block id: 109 */
                    return p_61;
                }
                return p_64;
            }
            else
            { /* block id: 113 */
                int32_t l_210 = 0xC349BFD9;
                float l_213 = 0x8.6D9266p-57;
                int32_t *****l_217 = &l_187;
                float *l_219 = &l_213;
                int32_t l_220 = 0x07C0FF9D;
                (*l_219) = (((((((0x5392 ^ l_210) && (((uint32_t)(((*l_207) == (((&p_62 == &p_62) >= l_210) < (((((float)0x5.6A51DAp+31 - (float)((&l_210 == ((*l_190) , l_207)) >= 0x3.DF3E0Ap-62)) == p_62) , p_64) != p_61))) > p_64) - (uint32_t)p_64) || l_216)) ^ p_61) , l_217) != l_218) < p_64) != 0x9.0p-1);
                (*l_207) = p_61;
                return l_220;
            }
        }
        if (((uint16_t)(p_62 & l_216) + (uint16_t)(p_63 <= (((l_216 == 0U) , ((float)func_65(&l_216, (p_62 , func_76(((**l_189) >= __builtin_parityll(p_64)), p_64)), p_63, (*l_189)) / (float)(*l_190))) , p_64))))
        { /* block id: 119 */
            uint32_t l_225 = 0x3B4ECD82;
            uint16_t **l_226 = (void*)0;
            uint16_t ***l_227 = (void*)0;
            uint16_t ***l_228 = &l_226;
            const uint16_t *l_240 = &l_231;
            const uint16_t **l_239 = &l_240;
            int32_t l_250 = 2;
            int32_t l_292 = 3;
            l_225 = l_216;
            (*l_228) = l_226;
            for (p_62 = 18; (p_62 != (-23)); p_62--)
            { /* block id: 124 */
                uint16_t ***l_241 = &l_226;
                int32_t *l_244 = &l_234.f2;
                const union U0 l_245 = {0x1.1p-1};
                float *l_246 = (void*)0;
                float *l_247 = (void*)0;
                float *l_248 = &l_234.f0;
                int32_t l_269 = 0x515C9F24;
            }
        }
        else
        { /* block id: 153 */
            int8_t l_302 = (-1);
            int8_t *l_301 = &l_302;
            const union U0 l_316 = {0x9.D75513p+17};
            int32_t * const l_317 = &l_234.f2;
            uint16_t *****l_327 = (void*)0;
            int32_t *l_344 = &l_282.f2;
            for (l_282.f1 = (-30); (l_282.f1 != 59); l_282.f1 += 1)
            { /* block id: 156 */
                int8_t l_299 = 5;
                int8_t *l_298 = &l_299;
                int8_t **l_300 = (void*)0;
                int32_t *l_307 = &l_191;
                int32_t **l_308 = &l_307;
                uint16_t *****l_328 = (void*)0;
                l_305 = (((float)(0x6.A748A0p-95 >= (!(p_64 , 0x8.Ep-1))) - (float)0x0.BE244Cp+58) != ((l_301 = l_298) != (p_64 , (p_63 , l_303))));
                (*l_308) = func_80(((void*)0 == l_306), l_307);
                for (l_216 = (-12); (l_216 <= 15); l_216 += 1)
                { /* block id: 162 */
                    int16_t l_311 = 0xC423;
                    int32_t *l_312 = &l_282.f2;
                    float *l_313 = &l_279;
                    uint16_t **l_322 = &l_243;
                }
                if ((p_63 != ((*l_317) < ((uint32_t)p_61 * (uint32_t)((((*l_317) && l_234.f2) >= ((int16_t)p_61 << (int16_t)((l_234 , l_327) != ((*l_281) , l_328)))) == p_64)))))
                { /* block id: 180 */
                    const uint16_t *l_332 = (void*)0;
                    const uint16_t ** const l_331 = &l_332;
                    for (l_302 = 0; (l_302 < (-20)); l_302 -= 9)
                    { /* block id: 183 */
                        (**l_189) = (l_331 != ((**l_284) = l_249));
                    }
                }
                else
                { /* block id: 187 */
                    uint32_t l_339 = 0U;
                    (*l_317) = ((**l_189) = ((*l_317) & 0U));
                }
            }
        }
        (*l_351) = ((p_64 , func_65((*l_189), (*l_281), p_62, (((int16_t)((*l_348) = (**l_189)) + (int16_t)((*l_243) = p_63)) , (*l_189)))) != ((*l_350) = ((*l_306) = p_61)));
        (*l_190) = p_62;
    }
    if (p_64)
    { /* block id: 200 */
        int32_t *l_352 = &l_191;
        const union U0 l_353 = {-0x1.4p-1};
        float *l_354 = &l_279;
        uint32_t *l_355 = (void*)0;
        uint32_t *l_356 = &l_305;
        uint64_t l_360 = 0U;
        uint64_t *l_359 = &l_360;
        uint32_t l_365 = 0x561EA1B5;
        uint32_t *l_364 = &l_365;
        int16_t l_367 = 1;
        int16_t *l_366 = &l_367;
        int32_t l_368 = 0x9A27EF06;
        (*l_354) = func_65(l_352, l_353, (*l_352), l_352);
        (*l_354) = (((((*l_352) > (((*l_356) = (((*l_291) = (void*)0) == (void*)0)) ^ ((uint32_t)p_61 + (uint32_t)((__builtin_parityll(((*l_359) = ((*l_352) || (*l_352)))) < ((*l_366) = ((0xF8506E6F || ((int32_t)(-(int16_t)(((*l_364) = 0x1D7BB205) || p_61)) / (int32_t)(*l_352))) | 1U))) <= p_63)))) != (*l_352)) < l_368) , 0x0.07F543p-6);
        if ((0x509F != 0x4ABE))
        { /* block id: 208 */
            (*l_189) = l_356;
        }
        else
        { /* block id: 210 */
            return p_62;
        }
    }
    else
    { /* block id: 213 */
        uint32_t l_369 = 0x1DCC9798;
        int16_t l_370 = 0x2458;
        int16_t *l_371 = &l_370;
        int32_t **l_372 = &l_190;
        (*l_189) = (*l_189);
        (*l_189) = (l_369 , (void*)0);
        (*l_372) = func_43(p_61, ((*l_371) = l_370));
    }
    (*l_374) = func_43(p_64, p_64);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_65(int32_t * p_66, const union U0  p_67, float  p_68, int32_t * const  p_69)
{ /* block id: 65 */
    int32_t l_121 = 0x8952EB5F;
    int16_t * const l_125 = (void*)0;
    int32_t l_138 = 0x14D69EA8;
    int8_t l_153 = (-4);
    float l_162 = 0x6.594573p+0;
    union U0 l_168 = {0xF.4E49CAp+28};
    int32_t l_179 = (-1);
    for (l_121 = (-21); (l_121 > (-15)); l_121 += 1)
    { /* block id: 68 */
        int32_t l_124 = (-1);
        int16_t *l_165 = (void*)0;
        int16_t l_167 = (-1);
        int16_t *l_166 = &l_167;
        float *l_169 = &l_168.f0;
        float **l_170 = (void*)0;
        float **l_171 = &l_169;
        float *l_176 = &l_162;
        int32_t *l_180 = &l_138;
        float l_182 = 0xB.54F4E0p+79;
        float *l_181 = &l_182;
        int8_t l_183 = (-1);
        if (l_124)
        { /* block id: 69 */
            l_124 = __builtin_ctzl(((0xA9706E18 | 0x21BA6C3C) ^ (l_125 == (void*)0)));
        }
        else
        { /* block id: 71 */
            int32_t *l_128 = &l_124;
            float l_133 = 0x4.2280F2p-95;
            float *l_132 = &l_133;
            float l_135 = 0xC.92B0D2p-26;
            float *l_134 = &l_135;
            uint16_t l_155 = 65527U;
            uint16_t *l_154 = &l_155;
            int32_t **l_156 = (void*)0;
            int32_t **l_157 = &l_128;
            for (l_124 = 0; (l_124 < 28); l_124 += 1)
            { /* block id: 74 */
                int32_t **l_129 = &l_128;
                (*l_129) = l_128;
            }
            (*l_134) = (((float)l_121 - (float)((*l_132) = l_121)) == l_124);
            (*l_157) = func_43(((int16_t)l_138 >> (int16_t)((((uint32_t)(((uint16_t)p_67.f3 << (uint16_t)(0x9F6C4539 != ((int16_t)p_67.f4 >> (int16_t)p_67.f4))) , ((uint16_t)0U % (uint16_t)((int32_t)((uint16_t)(((*l_154) = (((int32_t)l_153 - (int32_t)(*l_128)) | __builtin_bswap64(l_124))) , 0xF314) >> (uint16_t)p_67.f3) % (int32_t)(*l_128)))) - (uint32_t)0xF0DA5B00) ^ p_67.f3) ^ (*l_128))), p_67.f1);
        }
        l_168.f4 = (func_76(((((int32_t)(p_67.f4 , (l_153 , ((int16_t)1 >> (int16_t)4))) / (int32_t)l_124) , (*p_69)) , p_67.f4), ((0x70AB7136 & ((int16_t)((*l_166) = l_121) << (int16_t)(((*l_171) = l_169) != (void*)0))) , l_168.f3)) , (*p_69));
        (*l_181) = (p_67.f2 > ((float)((*l_176) = ((float)(l_176 == (void*)0) / (float)((((((-7) >= ((uint16_t)l_121 >> (uint16_t)15)) < (l_168.f4 = l_179)) || (-4)) > ((*l_180) = (p_69 == (void*)0))) , l_168.f4))) - (float)(-0x7.Cp-1)));
        (*l_176) = (l_121 != ((**l_171) = l_183));
    }
    return p_67.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_70(union U0  p_71, int32_t  p_72, uint32_t  p_73, int32_t * p_74, float  p_75)
{ /* block id: 48 */
    const int32_t l_94 = 8;
    const int32_t *l_93 = &l_94;
    const int32_t **l_92 = &l_93;
    int32_t *l_100 = (void*)0;
    int32_t l_107 = 0x31B86626;
    int32_t ***l_108 = (void*)0;
    int32_t **l_109 = &l_100;
    int16_t l_118 = (-5);
    int16_t *l_117 = &l_118;
    int32_t **l_119 = &l_100;
    (*l_92) = p_74;
    if ((*l_93))
    { /* block id: 50 */
        int32_t **l_95 = (void*)0;
        const int32_t **l_96 = &l_93;
        (*l_96) = func_80((*p_74), p_74);
    }
    else
    { /* block id: 52 */
        int32_t l_98 = (-1);
        int32_t *l_97 = &l_98;
        int32_t **l_99 = (void*)0;
        float l_104 = (-0x1.1p-1);
        float *l_103 = &l_104;
        int32_t ***l_106 = &l_99;
        int32_t ****l_105 = &l_106;
        p_74 = func_80((*l_93), (l_100 = l_97));
        (*l_103) = (((&l_97 == &p_74) != (((float)(*l_97) - (float)0x1.9p-1) >= 0x8.Bp+1)) == p_71.f3);
        (*l_105) = &l_92;
    }
    l_107 = p_71.f3;
    (*l_119) = (((l_109 = (void*)0) == (p_72 , &l_93)) , func_43(p_71.f2, ((*l_117) = ((0x7AE9 > ((int16_t)((uint16_t)(+(((p_72 = ((uint16_t)(0xAC0E >= ((p_71.f1 == (p_75 = p_75)) , p_72)) - (uint16_t)p_71.f3)) , 0x137C) , 0x1441E233)) + (uint16_t)p_71.f3) % (int16_t)0x9279)) , 0x8E54))));
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_76(const uint32_t  p_77, float  p_78)
{ /* block id: 40 */
    int32_t l_84 = 0xD1B3002E;
    int32_t *l_83 = &l_84;
    int32_t **l_89 = (void*)0;
    int32_t **l_90 = &l_83;
    union U0 l_91 = {0x9.499936p+36};
    (*l_90) = func_80(p_77, (l_83 = (void*)0));
    return l_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_80(int32_t  p_81, int32_t * p_82)
{ /* block id: 42 */
    int16_t l_85 = 0x161E;
    float *l_86 = (void*)0;
    float l_88 = 0x3.Cp+1;
    float *l_87 = &l_88;
    (*l_87) = l_85;
    p_82 = func_43(l_85, (l_85 < l_85));
    return l_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 107
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 1
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 11

XXX max expression depth: 50
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 12
   depth: 3, occurrence: 7
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 29, occurrence: 1
   depth: 50, occurrence: 1

XXX total number of pointers: 144

XXX times a variable address is taken: 125
XXX times a pointer is dereferenced on RHS: 61
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 82
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 6
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 296

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 299
   level: 2, occurrence: 35
   level: 3, occurrence: 8
   level: 4, occurrence: 21
   level: 5, occurrence: 23
XXX number of pointers point to pointers: 57
XXX number of pointers point to scalars: 86
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 32.6
XXX average alias set size: 1.27

XXX times a non-volatile is read: 477
XXX times a non-volatile is write: 207
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 86
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 26
   depth: 2, occurrence: 11
   depth: 3, occurrence: 10
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 19.7
XXX percentage an existing variable is used: 80.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

