/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1701712234
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   int32_t  f3;
};
#pragma pack(pop)

struct S1 {
   int16_t  f0;
   int16_t  f1;
   struct S0  f2;
   uint16_t  f3;
   int32_t  f4;
   uint32_t  f5;
   uint16_t  f6;
   struct S0  f7;
   uint32_t  f8;
   uint32_t  f9;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   int32_t  f0;
   uint16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   struct S1  f5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_32(void);
static int32_t * func_33(struct S1  p_34);
inline static struct S1  func_35(uint32_t  p_36, int32_t * p_37, uint32_t  p_38);
static uint16_t  func_47(int32_t * p_48, int32_t * p_49, uint32_t  p_50, int32_t  p_51, uint32_t  p_52);
inline static int32_t * func_53(int32_t * p_54);
inline static int32_t * func_58(int32_t * p_59, int32_t * p_60, struct S2  p_61);
static struct S2  func_63(int32_t * p_64);
inline static int32_t * func_65(int32_t * p_66);
inline static int32_t * func_67(int32_t * p_68, int32_t * p_69, uint32_t  p_70, int32_t * p_71, uint16_t  p_72);
static int32_t * func_73(int32_t  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_32(void)
{ /* block id: 36 */
    float l_39 = 0xA.F9AA2Ap-32;
    int32_t l_40 = 0xB0402AD9;
    int32_t *****l_369 = (void*)0;
    uint16_t l_372 = 0x8410;
    uint32_t l_483 = 4294967295U;
    int16_t l_484 = 0;
    int32_t l_485 = 0x0B31DAE6;
    int32_t **l_514 = (void*)0;
    int32_t *l_516 = &l_40;
    int32_t **l_515 = &l_516;
    struct S1 l_518 = {0x2AFC,0,{0xCC2C9941,1U,0x31484B6A,0x02537505},0x5D73,0x916AF594,0xDCB649C3,0x984D,{0x5A5727B4,0U,4294967288U,0},4294967295U,0x2FB8001C};
    struct S1 *l_517 = &l_518;
    struct S1 **l_519 = &l_517;
    struct S0 *l_520 = &l_518.f7;
    int32_t l_521 = 0xE0FFBBD8;
    (*l_515) = func_33(func_35(l_40, &l_40, (safe_sub_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u(((((safe_rshift_func_int16_t_s_s((0xE249 | func_47(func_53(&l_40), func_73((safe_sub_func_int16_t_s_s(((void*)0 == l_369), ((-4) >= (safe_sub_func_uint32_t_u_u((l_40 >= l_40), l_40)))))), l_40, l_372, l_372)), l_483)) > l_484) < l_372) && l_483), l_485)), 1U))));
    /* statement id: 354 */
    assert (l_516 == 0);
    (*l_519) = l_517;
    l_520 = l_520;
    (**l_519) = (**l_519);
    return l_521;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_33(struct S1  p_34)
{ /* block id: 345 */
    int32_t l_505 = (-8);
    int32_t *l_504 = &l_505;
    int32_t **l_506 = (void*)0;
    int32_t **l_507 = &l_504;
    struct S1 l_510 = {7,9,{0xA9A726B9,1U,4U,8},0xF5C0,-1,0x8136A070,65535U,{0xB21F454D,0xD267C304,0x68933E06,1},9U,0x6285FF0C};
    int32_t *l_513 = (void*)0;
    (*l_507) = func_58(l_504, &l_505, func_63(&l_505));
    for (p_34.f7.f2 = 0; (p_34.f7.f2 <= 35); p_34.f7.f2 = safe_add_func_uint16_t_u_u(p_34.f7.f2, 7))
    { /* block id: 349 */
        struct S1 *l_511 = (void*)0;
        struct S1 *l_512 = &l_510;
        if ((*l_504))
            break;
        (*l_512) = l_510;
    }
    return l_513;
    /* statement id: 353 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_35(uint32_t  p_36, int32_t * p_37, uint32_t  p_38)
{ /* block id: 337 */
    int16_t l_490 = (-1);
    struct S1 l_503 = {0,3,{0xDAA854A0,0x1D39A723,0x06634409,0},0U,0,0x946319EE,0x89D2,{0xF288E209,1U,0U,-1},4294967292U,2U};
    for (p_38 = 0; (p_38 >= 11); p_38++)
    { /* block id: 340 */
        struct S0 l_494 = {0xF7C43971,0U,4294967295U,0};
        struct S0 *l_493 = &l_494;
        struct S2 *l_497 = (void*)0;
        struct S2 **l_496 = &l_497;
        struct S2 ***l_495 = &l_496;
        int32_t l_501 = (-1);
        struct S1 l_502 = {5,1,{0U,0x5CC6E994,0U,0x7DF5BFB4},8U,0xB7A77C9F,0x559CCFF4,0xF858,{4294967287U,0xCB742988,4294967295U,0xD796F1BD},0x93795F68,1U};
        (*p_37) = __builtin_ffs(((safe_sub_func_uint32_t_u_u(l_490, p_38)) && (safe_add_func_uint16_t_u_u((((((((l_493 == &l_494) != l_490) > l_494.f1) ^ ((void*)0 == l_495)) < ((safe_add_func_int32_t_s_s((((safe_unary_minus_func_uint16_t_u(((p_38 ^ 0x8B9E0529) >= p_38))) < l_494.f2) | p_38), l_494.f2)) > l_494.f2)) & l_494.f1) & l_501), (-5)))));
        return l_502;
    }
    return l_503;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_47(int32_t * p_48, int32_t * p_49, uint32_t  p_50, int32_t  p_51, uint32_t  p_52)
{ /* block id: 232 */
    uint32_t l_373 = 0x71296E83;
    int32_t *l_383 = (void*)0;
    struct S2 l_386 = {-8,0xFD47,4294967295U,0,4294967295U,{0x9F8B,0xE7D3,{0xABB14D2F,0xF113294E,4294967289U,0x94788031},0xBF4D,1,0xD3573AB6,65535U,{4294967295U,0U,0x3C19C4D3,0x810F01A4},1U,0x7A64AF95}};
    int32_t *l_388 = &l_386.f3;
    struct S0 *l_464 = &l_386.f5.f7;
    float l_474 = 0x8.9B04F5p+22;
    uint32_t l_475 = 0U;
    int32_t ***l_481 = (void*)0;
    int32_t ****l_480 = &l_481;
    if (l_373)
    { /* block id: 233 */
        struct S2 l_376 = {0x03491F1D,0xA135,0x0FEDED20,0xD68BB182,0x76054796,{0x6145,0xA4BA,{0x2CAA2936,4U,0xE85252CC,0xE9CAF662},0x58EC,0xB1D56724,0U,65535U,{0x11565686,0x8D53836E,8U,0xEC22B56A},0x14C93DE2,0xEB3A9716}};
        struct S2 *l_375 = &l_376;
        struct S2 **l_374 = &l_375;
        struct S2 ***l_377 = (void*)0;
        struct S2 ***l_378 = &l_374;
        int32_t *l_379 = &l_376.f3;
        (*l_378) = l_374;
        p_48 = l_379;
        /* statement id: 235 */
        assert (p_48 == &l_376.f3);
    }
    else
    { /* block id: 236 */
        uint32_t l_380 = 0xF16101AD;
        int32_t **l_389 = &l_388;
        l_380 = 0xC5D2D450;
        for (p_51 = 0; (p_51 != (-8)); p_51 = safe_sub_func_uint32_t_u_u(p_51, 8))
        { /* block id: 240 */
            int32_t l_385 = 1;
            int32_t *l_384 = &l_385;
            struct S2 *l_387 = &l_386;
            p_48 = func_58(l_383, l_384, l_386);
            (*l_384) = (*l_384);
            (*l_387) = l_386;
            if (l_380)
                break;
        }
        (*l_389) = func_65(l_388);
        for (l_386.f5.f7.f0 = 14; (l_386.f5.f7.f0 != 46); l_386.f5.f7.f0++)
        { /* block id: 249 */
            struct S1 *l_393 = &l_386.f5;
            struct S1 **l_392 = &l_393;
            struct S1 ***l_394 = &l_392;
            struct S0 l_395 = {0xF493DF09,0x625CD101,4294967289U,0xCB9F973F};
            struct S0 *l_396 = &l_386.f5.f2;
            (*l_394) = l_392;
            (*l_396) = l_395;
        }
    }
    /* facts after branching */
    //assert (p_48 == 0 || p_48 == dangling);
    if ((*l_388))
    { /* block id: 254 */
        struct S0 l_397 = {3U,0xD04B0EF1,0x55D81726,-1};
        struct S0 *l_398 = (void*)0;
        struct S0 *l_399 = &l_397;
        int16_t l_400 = (-1);
        int32_t *l_414 = &l_386.f3;
        struct S2 *l_435 = (void*)0;
        int32_t **l_446 = (void*)0;
        int32_t ***l_445 = &l_446;
        int32_t ****l_444 = &l_445;
        int32_t *****l_443 = &l_444;
        struct S2 *l_457 = &l_386;
        struct S0 *l_460 = &l_397;
        (*l_399) = l_397;
        if (l_400)
        { /* block id: 256 */
            uint16_t l_409 = 0xFCB8;
            float l_420 = 0x2.D0CF83p+49;
            float *l_419 = &l_420;
            int32_t **l_437 = &l_388;
            for (l_386.f5.f7.f0 = (-10); (l_386.f5.f7.f0 == 5); l_386.f5.f7.f0 = safe_add_func_uint32_t_u_u(l_386.f5.f7.f0, 6))
            { /* block id: 259 */
                struct S2 l_404 = {1,3U,0x027B496D,0x1ECDCD1B,4294967295U,{-5,-10,{0x347D94C0,4294967291U,0x71C74AF8,0xADA67DD0},65535U,0x4880C111,4294967295U,65535U,{0U,0x71857507,0x2753B200,-8},0x1835DE46,9U}};
                float l_418 = (-0x6.8p+1);
                float *l_417 = &l_418;
                int32_t **l_421 = &l_383;
                struct S2 **l_436 = &l_435;
                if ((safe_unary_minus_func_uint32_t_u(p_50)))
                { /* block id: 260 */
                    struct S2 *l_405 = &l_404;
                    (*l_405) = l_404;
                }
                else
                { /* block id: 262 */
                    int16_t l_406 = (-4);
                    (*l_388) = ((0xF388 <= l_406) || (safe_rshift_func_uint16_t_u_u(p_50, (l_409 < ((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((l_414 != (void*)0) && (safe_rshift_func_int16_t_s_s((0xD6B8 | (l_417 != l_419)), 2))), 1)), 0x90953721)) >= p_51)))));
                    (*l_414) = 0x8F11FF99;
                    return p_51;
                }
                (*l_421) = &p_51;
                /* statement id: 267 */
                assert (l_383 == &p_51);
                if (l_409)
                { /* block id: 268 */
                    struct S2 *l_426 = &l_386;
                    for (p_50 = (-21); (p_50 <= 19); p_50 = safe_add_func_int16_t_s_s(p_50, 4))
                    { /* block id: 271 */
                        int16_t l_425 = 1;
                        struct S2 **l_427 = &l_426;
                        (*l_417) = (+l_425);
                        (*l_427) = l_426;
                    }
                }
                else
                { /* block id: 275 */
                    int32_t *l_428 = (void*)0;
                    struct S2 *l_429 = &l_404;
                    struct S0 *l_432 = (void*)0;
                    (*l_429) = func_63(l_428);
                    (*l_421) = (*l_421);
                    for (l_404.f5.f7.f2 = 0; (l_404.f5.f7.f2 == 16); l_404.f5.f7.f2 = safe_add_func_uint16_t_u_u(l_404.f5.f7.f2, 6))
                    { /* block id: 280 */
                        struct S0 **l_433 = &l_399;
                        struct S0 *l_434 = &l_397;
                        (*l_433) = l_432;
                        /* statement id: 281 */
                        assert (l_399 == 0);
                        (*l_434) = l_404.f5.f2;
                        (*l_417) = l_409;
                    }
                    (**l_421) = (**l_421);
                }
                (*l_436) = l_435;
            }
            /* facts after for loop */
            assert (l_383 == &p_51 || l_383 == 0);
            assert (l_399 == 0 || l_399 == &l_397);
            (*l_437) = l_414;
        }
        else
        { /* block id: 290 */
            int32_t l_438 = (-10);
            struct S1 l_455 = {-8,0xBC46,{0x7FDA709C,4294967289U,3U,0x278321D2},65533U,0x795B1DAE,0xBE9D4291,65535U,{1U,0xDB9889D1,0x34C7ABA1,0x2A7D4FD7},0xDED30F8E,8U};
            int32_t *l_459 = &l_386.f3;
            if (l_438)
            { /* block id: 291 */
                int32_t **l_442 = &l_388;
                int32_t ***l_441 = &l_442;
                int32_t ****l_440 = &l_441;
                int32_t *****l_439 = &l_440;
                l_443 = l_439;
                /* statement id: 292 */
                assert (l_443 == &l_440);
                (*****l_443) = ((+p_51) >= (safe_rshift_func_uint16_t_u_u(p_52, (***l_441))));
                return p_50;
            }
            else
            { /* block id: 295 */
                for (l_386.f5.f8 = 0; (l_386.f5.f8 <= 30); ++l_386.f5.f8)
                { /* block id: 298 */
                    uint16_t l_454 = 0x7973;
                    struct S2 **l_458 = &l_457;
                    for (l_386.f5.f2.f0 = 0; (l_386.f5.f2.f0 <= 46); l_386.f5.f2.f0 = safe_add_func_uint16_t_u_u(l_386.f5.f2.f0, 2))
                    { /* block id: 301 */
                        struct S1 *l_456 = &l_455;
                        if (l_454)
                            break;
                        (*l_456) = l_455;
                        if (p_50)
                            continue;
                    }
                    (*l_458) = l_457;
                }
            }
            l_386 = func_63(l_459);
        }
        /* facts after branching */
        assert (l_383 == &p_51 || l_383 == 0);
        assert (l_399 == 0 || l_399 == &l_397);
        (*l_460) = l_386.f5.f7;
        return p_51;
    }
    else
    { /* block id: 313 */
        struct S0 *l_463 = &l_386.f5.f7;
        int32_t l_465 = 0x2A8583C1;
        struct S2 *l_467 = &l_386;
        for (l_386.f5.f2.f3 = (-26); (l_386.f5.f2.f3 != 13); l_386.f5.f2.f3 = safe_add_func_uint32_t_u_u(l_386.f5.f2.f3, 1))
        { /* block id: 316 */
            p_49 = &p_51;
            /* statement id: 317 */
            assert (p_49 == &p_51);
        }
        /* facts after for loop */
        assert (p_49 == &p_51 || p_49 == 0);
        (*l_388) = (l_463 != l_464);
        (*l_463) = (*l_464);
        if (l_465)
        { /* block id: 321 */
            int16_t l_466 = 0xA2D4;
            return l_466;
        }
        else
        { /* block id: 323 */
            int32_t **l_470 = &l_388;
            int32_t ***l_469 = &l_470;
            int32_t ****l_468 = &l_469;
            int32_t *****l_471 = &l_468;
            l_467 = l_467;
            (*l_471) = l_468;
        }
    }
    /* facts after branching */
    assert (p_49 == &p_51 || p_49 == 0);
    if ((((*l_388) || ((p_50 & (*l_388)) < ((p_50 == 9) > p_51))) || ((((((*l_388) <= (safe_rshift_func_uint16_t_u_u((p_52 & p_52), p_50))) | l_475) || (-9)) & 0x2F0F) < (*l_388))))
    { /* block id: 328 */
        struct S2 l_476 = {0,65535U,4294967295U,0x234D0FD1,0x070692F1,{1,-1,{0xFEE40A20,0xAEE6F00A,0x1CB4F494,-7},0xB7F9,1,0x8662F953,0x0170,{0U,0x4D4FD9CD,1U,-1},1U,3U}};
        struct S2 *l_477 = &l_476;
        int32_t **l_478 = (void*)0;
        int32_t **l_479 = &l_388;
        (*l_477) = l_476;
        (*l_479) = &p_51;
        /* statement id: 330 */
        assert (l_388 == &p_51);
    }
    else
    { /* block id: 331 */
        int32_t *****l_482 = &l_480;
        (*l_482) = l_480;
        (*l_464) = (*l_464);
        return p_50;
    }
    /* facts after branching */
    assert (l_388 == &p_51);
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_53(int32_t * p_54)
{ /* block id: 37 */
    int32_t l_55 = 0;
    struct S0 l_287 = {4294967292U,0xCFF6E7AD,1U,0xA349501C};
    int32_t ****l_294 = (void*)0;
    struct S1 l_361 = {0xE0A8,-1,{0x095EA4B4,6U,0x5ABCEF0E,0x3F2DD334},0x36D0,0,0x32692EE7,65534U,{0xB9314465,0U,0x915E499D,3},2U,1U};
    struct S1 *l_365 = (void*)0;
    int32_t *l_366 = (void*)0;
    for (l_55 = 5; (l_55 != 26); ++l_55)
    { /* block id: 40 */
        int32_t *l_62 = &l_55;
        struct S0 *l_288 = (void*)0;
        struct S0 *l_289 = &l_287;
        struct S1 *l_305 = (void*)0;
        struct S1 **l_304 = &l_305;
        struct S2 l_329 = {0,65530U,8U,0,0x237F5912,{0x1D7B,0xE90C,{1U,0xF13F1AD5,4294967295U,0x8BDF08E9},0xBEAD,1,4294967294U,0xB8D2,{4294967289U,0U,0x90BD2ADC,0x10259AAC},4294967295U,0x4689E1DE}};
        struct S2 *l_328 = &l_329;
        struct S2 **l_327 = &l_328;
        uint32_t l_336 = 3U;
        p_54 = func_58(&l_55, l_62, func_63(func_65(func_67(p_54, func_73((safe_lshift_func_uint16_t_u_s((((safe_sub_func_int32_t_s_s((l_55 ^ l_55), l_55)) != (~l_55)) | (*l_62)), 7))), l_55, l_62, l_55))));
        /* statement id: 189 */
        assert (p_54 == &l_55);
        (*l_289) = l_287;
        for (l_287.f3 = 0; (l_287.f3 >= 0); l_287.f3 = safe_add_func_int32_t_s_s(l_287.f3, 9))
        { /* block id: 193 */
            uint32_t l_306 = 0xCA6B271C;
            struct S0 *l_307 = (void*)0;
            int32_t **l_312 = &l_62;
            uint16_t l_320 = 0x6DC3;
            int32_t l_324 = (-1);
            struct S2 **l_330 = &l_328;
            struct S1 l_360 = {-1,0xC818,{0U,4294967293U,4294967295U,1},65535U,0xF02563EA,1U,65531U,{4294967295U,4294967295U,0x71B91601,-1},4294967293U,4294967291U};
        }
    }
    /* facts after for loop */
    //assert (p_54 == &l_55 || p_54 == &l_40);
    for (l_287.f0 = 19; (l_287.f0 < 51); l_287.f0 = safe_add_func_uint16_t_u_u(l_287.f0, 1))
    { /* block id: 227 */
        int32_t *l_364 = (void*)0;
        return l_364;
        /* statement id: 228 */
        //assert (func_53_rv == 0);
    }
    l_361 = l_361;
    return l_366;
    /* statement id: 231 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_58(int32_t * p_59, int32_t * p_60, struct S2  p_61)
{ /* block id: 186 */
    struct S0 l_286 = {0xF7E49803,0x9DBEF7E3,0xAD08A1AE,0x70507263};
    struct S0 *l_285 = &l_286;
    (*l_285) = p_61.f5.f7;
    return p_59;
    /* statement id: 188 */
    //assert (func_58_rv == &l_55 || func_58_rv == 0 || func_58_rv == &l_505);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_63(int32_t * p_64)
{ /* block id: 134 */
    int32_t l_216 = 9;
    int32_t *l_215 = &l_216;
    struct S0 l_245 = {0x50500275,0xAC017E48,0xCF2ABC83,0};
    struct S0 *l_244 = &l_245;
    struct S0 **l_283 = (void*)0;
    struct S2 l_284 = {-5,0x65CD,0xAB566C38,0x2C973D22,0xD79FE6A8,{0xD9D5,0x7327,{0xD6E50475,0U,0U,0xDF9D4AEB},3U,0,4294967286U,0x5F97,{0xF9E345E4,1U,0U,0xE6660620},4294967293U,0x2D0A057B}};
    (*l_215) = (p_64 != (void*)0);
    if ((*l_215))
    { /* block id: 136 */
        uint16_t l_226 = 65535U;
        for (l_216 = (-16); (l_216 < (-12)); l_216++)
        { /* block id: 139 */
            int32_t l_219 = 0xA8AC3DA4;
            float l_221 = 0xC.EEF7D3p+42;
            float *l_220 = &l_221;
            struct S1 l_225 = {0x8608,0x183C,{8U,0U,3U,6},0U,0xD95EC47E,0U,65530U,{4294967293U,2U,1U,8},4294967294U,0x1F9F82BC};
            struct S1 *l_224 = &l_225;
            int32_t **l_227 = &l_215;
            struct S2 l_228 = {0xDDE4CA51,0xF9BB,0xD7BB2051,1,7U,{9,0xE561,{4294967287U,0x5D2C1E1A,4294967293U,1},4U,0xA9F9E3E2,1U,65527U,{0x985D1017,4294967295U,9U,0xF067A4A6},1U,4294967289U}};
            (*l_220) = l_219;
            (*l_227) = func_67(&l_216, l_220, (safe_add_func_int16_t_s_s((l_219 | 2U), ((l_224 != &l_225) != __builtin_ffs(l_225.f0)))), l_220, l_226);
            /* statement id: 141 */
            assert (l_215 == &l_221);
            return l_228;
        }
        for (l_226 = 0; (l_226 < 1); ++l_226)
        { /* block id: 146 */
            uint32_t l_231 = 4294967295U;
            (*l_215) = l_231;
            if (l_231)
                break;
        }
    }
    else
    { /* block id: 150 */
        int32_t l_232 = 1;
        float l_234 = 0x0.5p-1;
        float *l_233 = &l_234;
        int32_t **l_237 = &l_215;
        int32_t ***l_236 = &l_237;
        int32_t ****l_235 = &l_236;
        int32_t *****l_238 = &l_235;
        (*l_233) = l_232;
        (*l_238) = l_235;
    }
    for (l_216 = 0; (l_216 > (-29)); l_216 = safe_sub_func_uint16_t_u_u(l_216, 1))
    { /* block id: 156 */
        int32_t l_243 = (-1);
        struct S0 *l_250 = &l_245;
        int32_t ***l_256 = (void*)0;
        int32_t ****l_255 = &l_256;
        int32_t *****l_254 = &l_255;
        struct S1 l_271 = {0x0A6B,-1,{4294967295U,4294967295U,4294967291U,-2},0x6E9A,5,0x2DB557AA,65535U,{0x2847284A,3U,0xA085F5C8,6},0x0442118A,0x615F0D0E};
        struct S2 l_282 = {0xBBE1737A,0x7C1C,4294967295U,0xA45DB5CE,4294967295U,{1,0x540B,{4294967287U,4294967295U,1U,-10},0U,0x952EC49B,0U,0xE3C6,{0xD2BE7B58,0x1B3ED8FF,0U,1},4294967289U,0xAD659D5D}};
    }
    return l_284;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(int32_t * p_66)
{ /* block id: 130 */
    struct S2 l_211 = {-1,0x28E4,0x56B4D16B,0x2D8D44CA,1U,{0x204F,1,{1U,0xA1730DD1,0U,0xE85835DA},3U,-7,1U,0xCE44,{0x2C3DB623,4294967295U,4294967290U,0x4B36488E},0xABA9483A,0x459D30CC}};
    struct S2 *l_210 = &l_211;
    struct S2 **l_212 = (void*)0;
    struct S2 **l_213 = &l_210;
    int32_t *l_214 = &l_211.f3;
    (*l_213) = l_210;
    l_211.f5 = l_211.f5;
    return p_66;
    /* statement id: 133 */
    //assert (func_65_rv == &l_55 || func_65_rv == 0 || func_65_rv == &l_386.f3);
}


/* ------------------------------------------ */
/* 
 * reads : l_40
 * writes:
 */
inline static int32_t * func_67(int32_t * p_68, int32_t * p_69, uint32_t  p_70, int32_t * p_71, uint16_t  p_72)
{ /* block id: 45 */
    int16_t l_88 = 8;
    int32_t l_106 = 0x5D88D3DE;
    int32_t *l_105 = &l_106;
    int32_t **l_104 = &l_105;
    struct S1 l_117 = {-5,0,{0U,0x65C328A7,0U,0xF2B8E86F},1U,0xD2697764,1U,0x404B,{6U,0x55BC6D30,0U,-1},4294967293U,4294967295U};
    struct S1 *l_116 = &l_117;
    int32_t l_128 = 0x6E21E60E;
    int32_t l_145 = 0;
    int32_t ***l_177 = &l_104;
    int32_t ****l_176 = &l_177;
    struct S0 *l_208 = (void*)0;
    struct S0 **l_209 = &l_208;
    if (l_88)
    { /* block id: 46 */
        int16_t l_90 = 0xC532;
        float l_92 = (-0x1.1p+1);
        float *l_91 = &l_92;
        int32_t l_103 = (-7);
        int32_t *l_102 = &l_103;
        int32_t **l_101 = &l_102;
        int32_t l_107 = 0xDA5B0066;
        uint32_t l_157 = 4294967292U;
        struct S1 *l_171 = (void*)0;
        struct S2 l_187 = {0xB9CBAC53,0U,0x80E9152D,0,0U,{7,-1,{7U,0xCE85C987,3U,0x9411A3A2},0xF7D7,1,0x87EBBFD0,0x9B15,{0U,7U,0x7EA0FBE6,0x9C13BAC8},0xDC9C167B,5U}};
        struct S2 *l_186 = &l_187;
        (*l_91) = (+l_90);
        if ((safe_rshift_func_int16_t_s_s(l_88, 6)))
        { /* block id: 48 */
            int32_t l_100 = (-9);
            struct S1 l_108 = {0x1AF0,-2,{0x0E7A3683,0xADEC5ABB,1U,0x38E40FFF},0x0E59,-3,0x28A4BD3C,65535U,{5U,4294967295U,0x3B42EBA3,0x59457360},0U,0U};
            struct S1 *l_109 = &l_108;
            (*l_102) = (safe_lshift_func_int16_t_s_u((!(((safe_rshift_func_uint16_t_u_s((l_100 && ((void*)0 != p_68)), 3)) >= ((l_101 != l_104) == (p_71 == p_68))) < (l_100 >= l_107))), 0));
            (*l_105) = l_100;
            (*l_109) = l_108;
            (*l_101) = (*l_104);
            /* statement id: 52 */
            assert (l_102 == &l_106);
        }
        else
        { /* block id: 53 */
            int32_t *l_121 = &l_107;
            for (l_90 = (-28); (l_90 != 14); l_90 = safe_add_func_int16_t_s_s(l_90, 7))
            { /* block id: 56 */
                struct S0 l_122 = {4294967295U,9U,2U,9};
                if ((*p_71))
                { /* block id: 57 */
                    uint32_t l_112 = 0x4B11C873;
                    struct S1 l_114 = {0xB082,0xE8F0,{0x39A98420,0x5A07D037,0U,0xF88E352C},0xD3C6,-10,0xF9B13E43,0x0B9C,{4294967289U,2U,1U,-1},5U,0x6DDE4B23};
                    struct S1 *l_113 = &l_114;
                    struct S1 **l_118 = &l_116;
                    if (l_112)
                    { /* block id: 58 */
                        struct S1 **l_115 = &l_113;
                        (*l_115) = l_113;
                    }
                    else
                    { /* block id: 60 */
                        (**l_104) = (*p_68);
                        p_68 = p_68;
                        (*l_104) = func_73(p_72);
                        /* statement id: 63 */
                        assert (l_105 == 0);
                    }
                    /* facts after branching */
                    assert (l_105 == 0 || l_105 == &l_106);
                    (*l_102) = (*p_71);
                    (*l_118) = l_116;
                }
                else
                { /* block id: 67 */
                    (*l_91) = (*l_102);
                    for (l_117.f1 = (-28); (l_117.f1 < (-20)); ++l_117.f1)
                    { /* block id: 71 */
                        struct S0 *l_123 = &l_117.f2;
                        (*l_104) = l_121;
                        /* statement id: 72 */
                        assert (l_105 == &l_107);
                        (*l_123) = l_122;
                    }
                    /* facts after for loop */
                    assert (l_105 == &l_107 || l_105 == &l_106);
                }
                /* facts after branching */
                assert (l_105 == &l_107 || l_105 == &l_106 || l_105 == 0);
                (*l_91) = p_70;
                return p_69;
                /* statement id: 77 */
                //assert (func_67_rv == 0 || func_67_rv == &l_221 || func_67_rv == &l_55);
            }
        }
        /* facts after branching */
        assert (l_102 == &l_103 || l_102 == &l_106);
        if ((p_70 < ((**l_104) | (2 | (safe_lshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s((p_72 == ((*l_102) | p_72)), (*l_102))), l_128))))))
        { /* block id: 80 */
            int32_t ***l_131 = &l_101;
            int32_t l_140 = (-1);
            struct S1 l_161 = {0,0x3BA7,{4294967295U,4294967295U,0xAC7BCD1F,2},0x840E,-2,0U,65534U,{0x465C56C7,7U,0x97FC644E,0x8EE9C46A},4294967287U,0U};
            struct S1 **l_165 = &l_116;
            for (l_106 = (-4); (l_106 >= (-22)); l_106 = safe_sub_func_int16_t_s_s(l_106, 1))
            { /* block id: 83 */
                int32_t ****l_132 = &l_131;
                float l_148 = (-0x6.0p-1);
                float l_159 = 0x0.6p-1;
                (*l_132) = l_131;
            }
            (*l_91) = (safe_add_func_float_f_f((***l_131), ((*l_105) > (-(**l_104)))));
        }
        else
        { /* block id: 111 */
            int32_t *****l_178 = &l_176;
            struct S1 *l_192 = &l_187.f5;
            (*l_178) = l_176;
            (*l_104) = func_73((safe_sub_func_uint16_t_u_u((((safe_rshift_func_int16_t_s_s(7, 8)) & ((safe_mod_func_int16_t_s_s(((~p_70) > (****l_176)), (***l_177))) == ((void*)0 == l_186))) != (safe_sub_func_int16_t_s_s(((****l_176) >= (0x91CB || ((p_70 | (***l_177)) & p_70))), 0xC7C5))), 0xF58A)));
            /* statement id: 113 */
            assert (l_105 == 0);
            (*l_102) = (safe_lshift_func_int16_t_s_s(((p_70 && (l_192 == &l_117)) || p_72), 12));
        }
        /* facts after branching */
        assert (l_105 == 0 || l_105 == &l_106);
        (**l_177) = (void*)0;
        /* statement id: 116 */
        assert (l_105 == 0);
    }
    else
    { /* block id: 117 */
        int32_t l_195 = 3;
        int32_t l_200 = (-1);
        float l_206 = 0x2.94EB69p-0;
        float *l_205 = &l_206;
        for (l_117.f0 = 16; (l_117.f0 == 16); l_117.f0 = safe_add_func_int32_t_s_s(l_117.f0, 1))
        { /* block id: 120 */
            return p_71;
            /* statement id: 121 */
            //assert (func_67_rv == &l_55 || func_67_rv == &l_221);
        }
        (*l_205) = ((l_195 != ((safe_add_func_float_f_f((p_70 > p_72), (p_72 == (((safe_add_func_float_f_f((l_200 >= (p_70 != (safe_sub_func_float_f_f(__builtin_popcountl(p_72), (safe_add_func_float_f_f(l_195, l_195)))))), l_195)) >= (-0x1.1p+1)) != p_70)))) <= l_195)) <= l_195);
        (***l_176) = p_71;
        /* statement id: 124 */
        //assert (l_105 == &l_55 || l_105 == &l_221);
        l_145 = (+((l_195 <= p_70) ^ p_72));
    }
    /* facts after branching */
    //assert (l_105 == &l_55 || l_105 == 0 || l_105 == &l_221);
    (**l_177) = (*l_104);
    (*l_209) = l_208;
    return p_69;
    /* statement id: 129 */
    //assert (func_67_rv == 0 || func_67_rv == &l_221 || func_67_rv == &l_55);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_73(int32_t  p_74)
{ /* block id: 41 */
    int32_t *l_80 = (void*)0;
    int32_t **l_81 = &l_80;
    int32_t l_83 = 0xC88640E9;
    int32_t *l_82 = &l_83;
    int32_t *l_84 = &l_83;
    int32_t *l_85 = &l_83;
    int32_t *l_86 = &l_83;
    int32_t *l_87 = (void*)0;
    (*l_81) = l_80;
    (*l_81) = (*l_81);
    return l_87;
    /* statement id: 44 */
    //assert (func_73_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 3
breakdown:
   depth: 0, occurrence: 142
   depth: 1, occurrence: 4
   depth: 2, occurrence: 9
   depth: 3, occurrence: 6
XXX total union variables: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 188
   depth: 2, occurrence: 27
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 187

XXX times a variable address is taken: 150
XXX times a pointer is dereferenced on RHS: 88
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 21
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 98
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 299

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 380
   level: 2, occurrence: 68
   level: 3, occurrence: 32
   level: 4, occurrence: 19
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 80
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 54
XXX percent of pointers has null in alias set: 29.4
XXX average alias set size: 1.26

XXX times a non-volatile is read: 572
XXX times a non-volatile is write: 260
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 145
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 39
   depth: 2, occurrence: 30
   depth: 3, occurrence: 12
   depth: 4, occurrence: 16
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 29.2
XXX percentage an existing variable is used: 70.8
********************* end of statistics **********************/

