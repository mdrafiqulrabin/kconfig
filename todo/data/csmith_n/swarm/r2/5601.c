/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3848318972
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_32(void);
inline static float  func_38(int8_t  p_39, float  p_40, uint16_t  p_41);
static uint64_t  func_55(int32_t ** p_56, int8_t  p_57);
static int8_t  func_60(int64_t  p_61);
static int32_t * func_64(float * p_65, uint32_t  p_66, int32_t ** p_67, int32_t  p_68, float * p_69);
inline static float * func_70(uint16_t  p_71);
static uint16_t  func_72(int32_t  p_73, uint32_t  p_74, int32_t * const  p_75, int32_t  p_76, uint64_t  p_77);
inline static int64_t  func_86(int8_t  p_87, float * p_88, int16_t  p_89, int32_t ** const  p_90, int32_t * p_91);
static uint64_t  func_92(int32_t * p_93);
inline static int32_t * func_101(const int8_t  p_102, uint64_t  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(void)
{ /* block id: 36 */
    float l_37 = 0x0.F0EBF9p-37;
    int32_t l_42 = 0x51EF9953L;
    uint32_t l_47 = 0x971DB956L;
    float *l_50 = &l_37;
    int32_t *l_59 = (void*)0;
    int32_t **l_58 = &l_59;
    int32_t **l_254 = (void*)0;
    int32_t l_255 = 0L;
    (*l_50) = (safe_sub_func_float_f_f((((safe_sub_func_float_f_f(l_37, func_38(((l_42 ^ 65535UL) < (safe_rshift_func_uint16_t_u_s(((-1L) > l_42), ((((((safe_mul_func_int16_t_s_s(((((l_42 < l_42) < l_42) != 0xB0D5L) <= l_42), l_42)) | l_42) && 0xF4923579L) != l_42) >= l_42) < l_47)))), l_42, l_47))) >= l_47) > l_47), 0x1.Ap-1));
    if (l_47)
    { /* block id: 41 */
        int32_t *l_52 = &l_42;
        int32_t **l_51 = &l_52;
        int32_t l_252 = 0x617F3B7BL;
        (*l_51) = &l_42;
        (*l_50) = __builtin_clzl((safe_mod_func_uint16_t_u_u(((((*l_52) < (**l_51)) | func_55(l_58, func_60(((**l_51) & l_42)))) > (safe_rshift_func_uint16_t_u_u((**l_51), 12))), ((**l_51) && l_252))));
    }
    else
    { /* block id: 143 */
        int32_t **l_253 = &l_59;
        l_254 = l_253;
    }
    return l_255;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_38(int8_t  p_39, float  p_40, uint16_t  p_41)
{ /* block id: 37 */
    int32_t *l_49 = (void*)0;
    int32_t **l_48 = &l_49;
    (*l_48) = (void*)0;
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_55(int32_t ** p_56, int8_t  p_57)
{ /* block id: 126 */
    float l_217 = 0x1.Cp-1;
    int32_t l_218 = 0xCA1C3D12L;
    const uint64_t l_219 = 1UL;
    int32_t *l_220 = &l_218;
    float **l_249 = (void*)0;
    (*l_220) = (safe_lshift_func_uint16_t_u_u((p_57 | (p_57 && (l_218 < l_219))), p_57));
    if ((!(safe_lshift_func_int16_t_s_u((*l_220), 15))))
    { /* block id: 128 */
        uint32_t l_224 = 18446744073709551613UL;
        return l_224;
    }
    else
    { /* block id: 130 */
        float ***l_225 = (void*)0;
        float ****l_226 = (void*)0;
        float ****l_227 = &l_225;
        int32_t l_232 = 0x7ED1FF4DL;
        float l_239 = 0x1.9p-1;
        (*l_227) = l_225;
        for (p_57 = 0; (p_57 < 3); p_57 = safe_add_func_int64_t_s_s(p_57, 9))
        { /* block id: 134 */
            float *l_236 = &l_217;
            int32_t l_240 = 0xB1D96761L;
            (*l_220) = (safe_sub_func_float_f_f(l_232, __builtin_popcountl(l_232)));
            l_232 = (safe_add_func_float_f_f((__builtin_popcount(((((~(l_236 != l_236)) | 0x7D3FL) | 4L) & 0xE6DEFB24L)) > (safe_mul_func_float_f_f(p_57, p_57))), (((l_239 <= 0x0.Fp+1) >= 0x3.Fp+1) > l_240)));
        }
    }
    (*l_220) = ((safe_sub_func_uint16_t_u_u((*l_220), p_57)) | (safe_lshift_func_uint16_t_u_s((((safe_lshift_func_int16_t_s_s((p_57 <= (__builtin_popcount(p_57) >= ((*l_220) >= 0xF0278575L))), 1)) | (safe_sub_func_int16_t_s_s(((*l_220) | (((*l_220) == (*l_220)) <= (-5L))), p_57))) ^ (*l_220)), 14)));
    (*p_56) = &l_218;
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_60(int64_t  p_61)
{ /* block id: 43 */
    int32_t l_80 = 2L;
    int32_t l_82 = 7L;
    int32_t * const l_81 = &l_82;
    float l_172 = (-0x1.Dp+1);
    float *l_171 = &l_172;
    int32_t l_175 = 0xB3B6C1D0L;
    int32_t *l_174 = &l_175;
    int32_t ** const l_173 = &l_174;
    for (p_61 = 0; (p_61 >= 2); p_61 = safe_add_func_uint16_t_u_u(p_61, 1))
    { /* block id: 46 */
        int64_t l_85 = (-1L);
        int32_t *l_176 = (void*)0;
        (*l_173) = func_64(func_70(func_72((safe_rshift_func_uint16_t_u_s(l_80, 1)), l_80, l_81, ((safe_sub_func_uint64_t_u_u((l_85 <= p_61), (l_85 == func_86(((*l_81) && func_92(&l_82)), l_171, l_85, l_173, l_176)))) > p_61), p_61)), p_61, &l_176, p_61, l_176);
    }
    (*l_81) = ((safe_lshift_func_int16_t_s_s((p_61 == (*l_81)), 1)) < p_61);
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_64(float * p_65, uint32_t  p_66, int32_t ** p_67, int32_t  p_68, float * p_69)
{ /* block id: 119 */
    int16_t l_212 = 1L;
    l_212 = 0x5DB3B990L;
    return (*p_67);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_70(uint16_t  p_71)
{ /* block id: 117 */
    float l_209 = 0x8.6F0F13p-34;
    float *l_208 = &l_209;
    float *l_210 = &l_209;
    float *l_211 = (void*)0;
    return l_211;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_72(int32_t  p_73, uint32_t  p_74, int32_t * const  p_75, int32_t  p_76, uint64_t  p_77)
{ /* block id: 104 */
    uint64_t l_181 = 0x959E53F41FD33E80LL;
    float l_186 = 0x0.8p+1;
    float *l_185 = &l_186;
    float **l_184 = &l_185;
    if ((((p_77 & (safe_add_func_int16_t_s_s((l_181 || ((safe_sub_func_uint64_t_u_u((l_184 == (void*)0), ((p_74 | (l_181 | l_181)) == l_181))) ^ l_181)), 65535UL))) == 0x1B73CF63L) & (*p_75)))
    { /* block id: 105 */
        int32_t l_189 = 0x9F68FA65L;
        int32_t *l_188 = &l_189;
        int32_t **l_187 = &l_188;
        int16_t l_190 = 5L;
        int32_t l_191 = 0xF0E40F49L;
        (*l_187) = l_185;
        (*p_75) = ((l_190 >= ((0UL | ((void*)0 == p_75)) && (0x85B6L <= l_181))) & (__builtin_clz(l_191) >= (__builtin_bswap32((safe_mod_func_uint16_t_u_u((((safe_mod_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u((((&p_76 != &p_73) | (*l_188)) && (*p_75)))), l_181)) && p_73) != 0L), (*l_188)))) || 0xC6C1L)));
        (*l_188) = l_181;
    }
    else
    { /* block id: 109 */
        int32_t *l_197 = (void*)0;
        l_197 = &p_76;
        if (l_181)
            goto lbl_198;
lbl_198:
        (*p_75) = func_92(l_185);
        (**l_184) = l_181;
        (**l_184) = ((l_181 <= (((safe_add_func_float_f_f((*l_197), p_73)) >= (safe_sub_func_float_f_f((*l_197), (safe_add_func_float_f_f(p_74, (-(l_181 > l_181))))))) > (safe_mul_func_float_f_f(((*l_197) >= 0x1.Bp-1), p_77)))) < l_181);
    }
    return l_181;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_86(int8_t  p_87, float * p_88, int16_t  p_89, int32_t ** const  p_90, int32_t * p_91)
{ /* block id: 100 */
    int64_t l_177 = 0x28D9ABBA40B5A963LL;
    int32_t *l_178 = (void*)0;
    (*p_90) = func_101(p_89, l_177);
    l_178 = (*p_90);
    return p_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_92(int32_t * p_93)
{ /* block id: 47 */
    const int8_t l_95 = (-1L);
    float l_97 = (-0x10.Cp-1);
    float *l_96 = &l_97;
    int32_t l_98 = 1L;
lbl_166:
    (*l_96) = (!l_95);
lbl_126:
    (*p_93) = (*p_93);
    for (l_98 = (-1); (l_98 > 23); l_98++)
    { /* block id: 52 */
        const uint64_t l_104 = 0xDB650F83943CDC18LL;
        int32_t *l_119 = &l_98;
        int32_t **l_118 = &l_119;
        int32_t l_120 = 0xA49BFE1AL;
        float **l_159 = &l_96;
        float ***l_158 = &l_159;
        float ****l_157 = &l_158;
        uint64_t l_170 = 18446744073709551615UL;
        (*l_118) = func_101(l_104, (0x6605L || 65526UL));
        for (l_120 = 0; (l_120 > (-3)); l_120 = safe_sub_func_int16_t_s_s(l_120, 7))
        { /* block id: 59 */
            int32_t l_123 = 0x4BAD57ADL;
            float **l_165 = &l_96;
            for (l_123 = 0; (l_123 == (-10)); l_123 = safe_sub_func_uint64_t_u_u(l_123, 2))
            { /* block id: 62 */
                float l_130 = 0xD.F45EF5p+82;
                int32_t *l_131 = (void*)0;
                int32_t l_144 = (-2L);
                uint64_t l_147 = 0xBD0D1FC1C174C20FLL;
                float ** const *l_162 = &l_159;
                float ** const **l_161 = &l_162;
                float ** const ***l_160 = &l_161;
                if (l_98)
                    goto lbl_126;
                if ((safe_sub_func_int32_t_s_s(((l_119 == p_93) < 0xC454249152248422LL), (((~l_98) | __builtin_ffsl(l_95)) >= 65530UL))))
                { /* block id: 64 */
                    float l_140 = 0x1.Cp+1;
                    int32_t l_141 = 0xC65C41F2L;
                    (*p_93) = 0x216BAB3DL;
                    if ((l_131 != p_93))
                    { /* block id: 66 */
                        float l_136 = 0x2.9p-1;
                        int32_t l_139 = 0x651924C0L;
                        uint64_t l_146 = 0x1AA1EC4391174088LL;
                        float **l_155 = &l_96;
                        float ***l_154 = &l_155;
                        (*l_96) = ((safe_add_func_float_f_f(0x4.3B3A31p+46, 0x7.1E8AE5p+17)) >= (safe_mul_func_float_f_f(l_136, (safe_sub_func_float_f_f((((l_139 <= l_140) != l_123) < (((void*)0 == p_93) == l_141)), 0x7.D3579Fp-80)))));
                        (*p_93) = ((l_95 == (safe_mod_func_uint32_t_u_u(l_98, l_144))) | ((l_141 ^ (((!l_146) != (l_147 ^ l_141)) | (safe_mod_func_uint64_t_u_u((safe_add_func_int16_t_s_s(l_141, (safe_mul_func_int16_t_s_s(l_141, 0xCF51L)))), l_141)))) ^ 0x773D59F1L));
                        if (l_98)
                            goto lbl_126;
                        (*l_154) = (void*)0;
                    }
                    else
                    { /* block id: 71 */
                        int64_t l_156 = 1L;
                        (*l_118) = (void*)0;
                        (*l_118) = &l_141;
                        return l_156;
                    }
                    (*l_118) = p_93;
                    (*l_118) = (void*)0;
                }
                else
                { /* block id: 78 */
                    (*l_96) = (0x1.114629p+29 < l_98);
                }
                (*l_160) = l_157;
                if (__builtin_clzll((((safe_add_func_int64_t_s_s(l_98, (((void*)0 != l_165) >= l_95))) < (&l_96 == l_165)) && (((l_123 & (*p_93)) < l_95) != l_147))))
                { /* block id: 82 */
                    if ((*p_93))
                        break;
                    if (l_104)
                        goto lbl_166;
                }
                else
                { /* block id: 85 */
                    int64_t l_169 = 0L;
                    for (l_144 = 0; (l_144 < 13); l_144++)
                    { /* block id: 88 */
                        return l_169;
                    }
                    (*l_118) = &l_98;
                }
            }
            if ((*p_93))
                break;
        }
        (*l_118) = func_101(l_98, l_170);
        if ((*p_93))
            break;
    }
    return l_98;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_101(const int8_t  p_102, uint64_t  p_103)
{ /* block id: 53 */
    int16_t l_105 = 6L;
    float l_107 = 0x6.D16080p-82;
    float *l_106 = &l_107;
    int32_t l_109 = 0xA9A78915L;
    int32_t *l_108 = &l_109;
    int32_t *l_110 = &l_109;
    int32_t *l_111 = &l_109;
    int32_t *l_112 = &l_109;
    int32_t *l_113 = &l_109;
    int32_t *l_114 = &l_109;
    int32_t *l_115 = &l_109;
    int32_t *l_116 = &l_109;
    int32_t *l_117 = (void*)0;
    (*l_106) = __builtin_parityll(l_105);
    return l_117;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 73
XXX total union variables: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 4
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 61

XXX times a variable address is taken: 50
XXX times a pointer is dereferenced on RHS: 33
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 4
XXX times a pointer is dereferenced on LHS: 34
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 107

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 141
   level: 2, occurrence: 26
   level: 3, occurrence: 0
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 31.1
XXX average alias set size: 1.18

XXX times a non-volatile is read: 253
XXX times a non-volatile is write: 81
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 71
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 19
   depth: 2, occurrence: 4
   depth: 3, occurrence: 4
   depth: 4, occurrence: 9
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 16.1
XXX percentage an existing variable is used: 83.9
********************* end of statistics **********************/

