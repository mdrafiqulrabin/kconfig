/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      864096126
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   volatile int64_t  f0;
};

union U1 {
   uint32_t  f0;
   float  f1;
   uint32_t  f2;
   uint64_t  f3;
   uint64_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_11 = 6L;
static int32_t *g_10 = &g_11;
static float g_55 = (-0x1.8p-1);
static volatile int32_t *g_71 = (void*)0;
static int32_t g_73 = 0x27E5571BL;
static volatile float **g_108 = (void*)0;
static int32_t g_116 = 0x24AAD4D8L;
static int32_t **g_133 = &g_10;
static int32_t ***g_132 = &g_133;
static int32_t ****g_131 = &g_132;
static volatile int16_t g_161 = 0xECF7L;/* VOLATILE GLOBAL g_161 */
static uint32_t g_162 = 0xD10A60FEL;
static int32_t g_170 = 1L;
static volatile int32_t g_181 = 9L;/* VOLATILE GLOBAL g_181 */
static union U0 g_214 = {8L};/* VOLATILE GLOBAL g_214 */
static union U0 *g_213 = &g_214;
static int32_t g_276 = 0L;
static union U1 g_330 = {0x2BAF1258L};
static union U1 *g_331 = &g_330;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_2(float  p_3, int16_t  p_4, float  p_5, int16_t  p_6, int32_t * p_7);
static float  func_8(int32_t * p_9);
static float  func_14(int16_t  p_15, int32_t * p_16, int32_t * p_17, int32_t * p_18, int32_t * p_19);
static int32_t * func_21(uint64_t  p_22, int32_t * p_23, int32_t  p_24, int32_t * p_25);
static uint64_t  func_26(uint32_t  p_27, uint32_t  p_28, int32_t * p_29, int32_t * p_30);
static int16_t  func_31(int16_t  p_32, int32_t * p_33, uint64_t  p_34, uint16_t  p_35);
static int16_t  func_40(uint32_t  p_41, int32_t * p_42, int64_t  p_43, int32_t * p_44);
static int32_t * func_45(int32_t * p_46);
static int32_t * func_47(int32_t * p_48, int32_t * p_49, int32_t * p_50, uint16_t  p_51);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_11 g_71 g_73 g_55 g_108 g_131 g_116 g_132 g_133 g_161 g_162 g_170 g_181 g_213 g_214.f0 g_276
 * writes: g_55 g_73 g_10 g_11 g_116 g_133 g_108 g_170 g_213 g_331
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_209 = 0UL;
    int32_t *l_210 = &g_170;
    int32_t **l_332 = &l_210;
    (*l_332) = func_2(func_8(g_10), l_209, g_170, g_162, l_210);
    /* statement id: 112 */
    assert (g_10 == &g_170 || g_10 == &g_11 || g_10 == &g_55);
    //assert (g_133 == dangling);
    assert (l_210 == &g_170 || l_210 == &g_11);
    (*l_332) = (*l_332);
    return g_116;
}


/* ------------------------------------------ */
/* 
 * reads : g_170 g_213 g_116 g_10 g_73 g_11 g_214.f0 g_181 g_71 g_55 g_161 g_276 g_108 g_131 g_132 g_162
 * writes: g_170 g_10 g_213 g_55 g_73 g_11 g_331
 */
static int32_t * func_2(float  p_3, int16_t  p_4, float  p_5, int16_t  p_6, int32_t * p_7)
{ /* block id: 75 */
    int32_t *l_211 = &g_170;
    int32_t **l_212 = &g_10;
    union U0 *l_222 = &g_214;
    uint64_t l_238 = 1UL;
    float *l_253 = &g_55;
    float **l_252 = &l_253;
    int32_t *l_255 = &g_11;
    uint32_t l_299 = 18446744073709551606UL;
    (*p_7) = 0x55D9A899L;
    (*l_212) = l_211;
    /* statement id: 77 */
    assert (g_10 == &g_170);
    if ((*l_211))
    { /* block id: 78 */
        union U0 **l_215 = (void*)0;
        union U0 *l_216 = (void*)0;
        int32_t l_219 = (-1L);
        l_216 = g_213;
        /* statement id: 79 */
        assert (l_216 == &g_214);
        (*p_7) = (((int32_t)l_219 + (int32_t)(((1L && ((uint32_t)((void*)0 == l_222) + (uint32_t)(((int16_t)((((int16_t)(((int64_t)g_116 + (int64_t)((uint32_t)((**l_212) & (!(g_73 != ((uint64_t)((int32_t)((int64_t)p_4 % (int64_t)g_11) + (int32_t)0x8E8C6B87L) - (uint64_t)p_4)))) + (uint32_t)p_6)) >= g_214.f0) >> (int16_t)l_238) && (*l_211)) && g_181) << (int16_t)10) && (**l_212)))) && 0xC54E2A72L) | p_6)) == 0xDD49A4E4L);
    }
    else
    { /* block id: 81 */
        int32_t ***l_244 = &g_133;
        float *l_247 = &g_55;
        union U1 *l_329 = &g_330;
        (*l_212) = p_7;
        for (p_6 = 0; (p_6 < 8); p_6 += 1)
        { /* block id: 85 */
            union U0 **l_241 = (void*)0;
            int32_t l_251 = 0x986BF88CL;
            uint32_t l_277 = 0x25E2EDC9L;
            g_213 = l_222;
            if ((((void*)0 != &g_214) == (((((uint16_t)g_73 * (uint16_t)(&l_212 == l_244)) >= ((int16_t)(l_247 == l_211) << (int16_t)5)) || (0xFF2D55D3BE87DA6ALL >= ((uint16_t)((-(uint16_t)(g_116 & l_251)) < g_73) * (uint16_t)l_251))) & (*p_7))))
            { /* block id: 87 */
                float ***l_254 = &l_252;
                (*l_254) = l_252;
                p_7 = func_45(l_255);
                /* statement id: 89 */
                assert (g_10 == &g_55);
                assert (p_7 == &g_11);
                (*p_7) = 1L;
            }
            else
            { /* block id: 91 */
                int32_t l_275 = 1L;
                int32_t ***l_279 = &g_133;
                float l_286 = 0xA.67C341p-64;
                l_277 = (p_6 || (((uint16_t)(0x6197L || ((uint64_t)((void*)0 == &l_222) + (uint64_t)((!(p_6 >= (0x4769L | ((uint16_t)((int64_t)((int16_t)(((((uint16_t)(~(((~((uint16_t)((g_161 || (((int16_t)(&p_7 != &p_7) - (int16_t)g_170) <= g_214.f0)) ^ (*p_7)) >> (uint16_t)p_4)) >= g_73) || (*l_211))) * (uint16_t)p_6) ^ 8UL) == l_275) > 0UL) >> (int16_t)9) % (int64_t)5L) >> (uint16_t)g_170)))) < g_276))) * (uint16_t)1UL) | 65534UL));
                (**l_212) = (-(uint64_t)(l_279 != (void*)0));
                (*l_255) = (((void*)0 != g_108) & ((uint32_t)((int16_t)p_6 >> (int16_t)((int32_t)(((((void*)0 == (*g_131)) != (*g_10)) == ((uint16_t)p_6 - (uint16_t)(((uint16_t)((void*)0 != l_241) >> (uint16_t)(**l_212)) == g_161))) != p_6) + (int32_t)0x7DED8AAAL)) - (uint32_t)(*p_7)));
                (**l_252) = ((float)g_55 + (float)((float)((float)((void*)0 == &g_71) - (float)(((0x2.0AEFE7p-15 > 0x6.9D880Bp-58) >= l_251) >= 0x1.Bp+1)) + (float)0x1.5p-1));
            }
        }
        /* facts after for loop */
        assert (g_10 == &g_170 || g_10 == &g_55);
        assert (p_7 == &g_170 || p_7 == &g_11);
        for (g_170 = (-2); (g_170 > (-14)); g_170 -= 8)
        { /* block id: 100 */
            uint64_t l_310 = 0x3E714B42A01C24B0LL;
            int32_t *l_312 = &g_11;
            float **l_321 = (void*)0;
            (*l_212) = func_21(l_299, p_7, ((((uint16_t)((g_162 || (((uint16_t)(((uint64_t)((((uint32_t)(g_73 > l_310) % (uint32_t)g_11) & l_310) & (((~(p_6 & (*g_10))) | (*p_7)) >= l_310)) + (uint64_t)p_4) | g_276) % (uint16_t)p_4) ^ l_310)) >= 0x120DL) / (uint16_t)p_4) ^ g_170) ^ g_181), l_312);
            /* statement id: 101 */
            assert (g_10 == &g_170 || g_10 == &g_11);
            for (l_238 = 11; (l_238 == 3); l_238 -= 3)
            { /* block id: 104 */
                int32_t l_328 = 0xCEBFDD09L;
                (*l_312) = ((int32_t)((void*)0 == &p_7) - (int32_t)((uint16_t)((uint16_t)((*p_7) | (l_321 != g_108)) * (uint16_t)((((uint16_t)((((uint32_t)((((uint32_t)((p_7 == p_7) != ((&g_108 == &l_252) & l_328)) % (uint32_t)l_328) ^ g_170) <= (*l_211)) - (uint32_t)p_6) & g_214.f0) != g_170) + (uint16_t)(**l_212)) >= 2L) & 0L)) % (uint16_t)l_328));
            }
            if ((*p_7))
                continue;
            g_331 = l_329;
        }
        /* facts after for loop */
        assert (g_10 == &g_170 || g_10 == &g_11 || g_10 == &g_55);
    }
    /* facts after branching */
    assert (g_10 == &g_170 || g_10 == &g_11 || g_10 == &g_55);
    assert (p_7 == &g_170 || p_7 == &g_11);
    return p_7;
    /* statement id: 111 */
    //assert (func_2_rv == &g_170 || func_2_rv == &g_11);
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_71 g_73 g_55 g_10 g_108 g_131 g_116 g_132 g_133 g_161 g_162 g_170 g_181
 * writes: g_55 g_73 g_10 g_11 g_116 g_133 g_108
 */
static float  func_8(int32_t * p_9)
{ /* block id: 1 */
    uint64_t l_20 = 0x07207182B4746A1CLL;
    uint16_t l_168 = 0x9A2FL;
    int32_t *l_169 = &g_170;
    float *l_207 = (void*)0;
    float *l_208 = &g_55;
    (*l_208) = ((float)func_14(l_20, func_21(func_26(((((func_31((((uint64_t)((int16_t)func_40(g_11, func_45(func_47(&g_11, p_9, &g_11, ((((int32_t)(*p_9) + (int32_t)g_11) > ((((((void*)0 != &g_11) & l_20) ^ l_20) < g_11) && 0xECA6L)) ^ l_20))), l_20, p_9) >> (int16_t)g_161) % (uint64_t)g_162) == 0x42138682L), p_9, g_162, l_20) < 0xC94FL) & l_20) < g_162) & 0L), l_168, p_9, l_169), p_9, (*l_169), p_9), l_169, l_169, l_169) * (float)0x0.187883p+44);
    /* statement id: 73 */
    assert (g_10 == 0);
    //assert (g_133 == dangling);
    return (*l_169);
}


/* ------------------------------------------ */
/* 
 * reads : g_181 g_116 g_55 g_11 g_162 g_161 g_170 g_108
 * writes: g_10 g_55 g_108
 */
static float  func_14(int16_t  p_15, int32_t * p_16, int32_t * p_17, int32_t * p_18, int32_t * p_19)
{ /* block id: 67 */
    int32_t **l_182 = &g_10;
    int32_t l_195 = (-6L);
    float *l_198 = &g_55;
    int16_t l_205 = 1L;
    volatile float ***l_206 = &g_108;
    (*l_182) = (void*)0;
    /* statement id: 68 */
    assert (g_10 == 0);
    (*l_198) = ((float)(((float)((((g_181 < g_116) == (!g_55)) == (!(((float)((-0x4.9p-1) > g_11) / (float)0x8.1p-1) <= ((float)((float)l_195 - (float)p_15) * (float)((float)g_55 + (float)g_162))))) <= l_195) - (float)p_15) != 0x1.10CE24p-73) - (float)0xD.FD0DEDp+72);
    l_205 = ((int16_t)((((int64_t)0L % (int64_t)0x5419F12A095ECA5DLL) != g_161) > ((uint32_t)g_170 - (uint32_t)0x94C73A16L)) * (int16_t)g_116);
    (*l_206) = g_108;
    return p_15;
}


/* ------------------------------------------ */
/* 
 * reads : g_162 g_181
 * writes: g_55 g_11
 */
static int32_t * func_21(uint64_t  p_22, int32_t * p_23, int32_t  p_24, int32_t * p_25)
{ /* block id: 63 */
    float *l_171 = (void*)0;
    float *l_172 = &g_55;
    int32_t l_177 = 0L;
    uint32_t l_178 = 0x933BFEBFL;
    (*l_172) = p_22;
    (*p_25) = ((int64_t)(((uint32_t)(0xC07334A22360892CLL | l_177) - (uint32_t)(p_22 >= ((void*)0 == &g_132))) ^ l_178) + (int64_t)((0xCEABDB128D63D52ELL <= ((l_172 != (void*)0) != g_162)) <= g_181));
    return p_23;
    /* statement id: 66 */
    //assert (func_21_rv == &g_11 || func_21_rv == &g_170);
}


/* ------------------------------------------ */
/* 
 * reads : g_132 g_73
 * writes: g_133
 */
static uint64_t  func_26(uint32_t  p_27, uint32_t  p_28, int32_t * p_29, int32_t * p_30)
{ /* block id: 60 */
    (*g_132) = &p_30;
    /* statement id: 61 */
    assert (g_133 == &p_30);
    return g_73;
    /* statement id: 62 */
    //assert (g_133 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_11
 * writes:
 */
static int16_t  func_31(int16_t  p_32, int32_t * p_33, uint64_t  p_34, uint16_t  p_35)
{ /* block id: 57 */
    float *l_164 = &g_55;
    float **l_163 = &l_164;
    float ***l_165 = (void*)0;
    float ***l_166 = (void*)0;
    float ***l_167 = &l_163;
    (*l_167) = l_163;
    return g_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_73 g_108 g_11 g_71 g_55 g_131 g_116 g_132 g_133
 * writes: g_11 g_73 g_55 g_10 g_116
 */
static int16_t  func_40(uint32_t  p_41, int32_t * p_42, int64_t  p_43, int32_t * p_44)
{ /* block id: 11 */
    int32_t *l_99 = &g_73;
lbl_147:
    l_99 = l_99;
    (*p_44) = ((int32_t)(l_99 == l_99) / (int32_t)4294967295UL);
    for (g_11 = 0; (g_11 > 11); g_11++)
    { /* block id: 16 */
        uint16_t l_109 = 0x14BDL;
        int32_t *l_113 = (void*)0;
        int32_t l_117 = 0x6A0FEE19L;
        int16_t l_142 = 1L;
        if ((-(uint64_t)0xC45F480A87E9A86FLL))
        { /* block id: 17 */
            float **l_107 = (void*)0;
            int32_t l_112 = 1L;
            (*g_10) = 0xAE94942BL;
            if ((~0x26611625L))
            { /* block id: 19 */
                int32_t **l_106 = &g_10;
                (*l_106) = &g_73;
                /* statement id: 20 */
                assert (g_10 == &g_73);
                if ((*l_99))
                    continue;
                l_107 = (void*)0;
                if (((g_108 == (void*)0) == l_109))
                { /* block id: 23 */
                    for (p_43 = 0; (p_43 == (-8)); p_43 -= 6)
                    { /* block id: 26 */
                        (*l_106) = func_45(&g_73);
                        return l_112;
                    }
                }
                else
                { /* block id: 30 */
                    (**l_106) = (*l_99);
                    if ((65535UL && p_41))
                    { /* block id: 32 */
                        p_42 = l_113;
                        /* statement id: 33 */
                        assert (p_42 == 0);
                        return g_73;
                    }
                    else
                    { /* block id: 35 */
                        int32_t ***l_115 = &l_106;
                        int32_t ****l_114 = &l_115;
                        (*l_114) = &l_106;
                        g_116 = (*l_99);
                        if ((*p_44))
                            break;
                    }
                }
            }
            else
            { /* block id: 41 */
                return l_117;
            }
            /* facts after branching */
            assert (g_10 == &g_73);
            return l_112;
        }
        else
        { /* block id: 45 */
            int32_t **l_122 = &l_113;
            int32_t ***l_121 = &l_122;
            uint32_t l_143 = 9UL;
            int32_t l_144 = 0x5D1DBC6BL;
            float *l_145 = (void*)0;
            float *l_146 = &g_55;
            (*l_146) = ((float)(-(float)(((void*)0 == l_121) >= (-0x1.Cp+1))) - (float)((float)(((!((float)(-(float)(((float)(&l_121 == g_131) / (float)(p_41 > ((float)((g_11 < (((0x9.2p-1 <= ((float)((((((float)((float)(p_41 == l_142) * (float)p_43) * (float)0xC.CCE59Dp+28) <= (-0x1.Cp-1)) < 0x0.Ap+1) < 0x4.BC7067p-21) < p_43) / (float)l_143)) == g_55) > p_41)) >= (*l_99)) * (float)p_43))) > l_144)) * (float)0xC.0C0D0Cp+65)) >= 0x2.65EE81p+44) < p_43) / (float)0x0.7p+1));
            if (l_144)
                goto lbl_147;
        }
        return p_41;
    }
    for (g_73 = 18; (g_73 <= (-21)); g_73--)
    { /* block id: 53 */
        uint16_t l_157 = 65535UL;
        int32_t *l_160 = (void*)0;
        (*p_42) = (-(uint64_t)(!(((0x1CED5100589B8435LL <= (((uint16_t)(((p_41 > 1L) | (((!(((int32_t)l_157 - (int32_t)((g_116 != (l_160 != l_99)) > (p_41 <= (p_41 ^ 18446744073709551615UL)))) < (*p_44))) && (****g_131)) || 3UL)) || 0x151F1203DB6A5591LL) * (uint16_t)g_73) > 1UL)) >= g_116) & 0UL)));
    }
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_73 g_71 g_55
 * writes: g_55 g_73 g_10
 */
static int32_t * func_45(int32_t * p_46)
{ /* block id: 8 */
    int32_t *l_93 = &g_11;
    int32_t **l_98 = &l_93;
    (*l_98) = func_47(l_93, p_46, p_46, ((int16_t)((l_93 == p_46) < (((((void*)0 != p_46) & ((*l_93) ^ ((((void*)0 == l_93) > (*l_93)) != (*l_93)))) ^ g_73) <= (*l_93))) << (int16_t)15));
    /* statement id: 9 */
    assert (g_10 == &g_55);
    return p_46;
    /* statement id: 10 */
    //assert (func_45_rv == &g_11 || func_45_rv == &g_73);
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_71 g_73 g_55
 * writes: g_55 g_73 g_10
 */
static int32_t * func_47(int32_t * p_48, int32_t * p_49, int32_t * p_50, uint16_t  p_51)
{ /* block id: 2 */
    float *l_54 = &g_55;
    int16_t l_59 = 0x029BL;
    int32_t *l_72 = &g_73;
    (*l_54) = 0xE.60E2EFp-10;
    (*l_72) = ((((uint32_t)(!(((g_11 <= l_59) == ((int32_t)((uint64_t)l_59 % (uint64_t)(((uint16_t)((uint16_t)(-(uint32_t)(g_11 < (((int16_t)((0L < ((void*)0 == g_71)) <= l_59) * (int16_t)l_59) && 0x565E139A53AA4807LL))) >> (uint16_t)1) * (uint16_t)1L) | g_11)) % (int32_t)l_59)) > 0x406997B9FFBDD2A4LL)) - (uint32_t)0x0B0B8B0EL) ^ 0L) >= 0x3B9FL);
    (*l_72) = ((float)((float)(((float)(g_11 > ((float)((((float)((*l_72) != g_55) * (float)((!(((float)0x4.1p-1 + (float)((-0x1.Dp+1) >= (!(g_55 > ((((float)(((((float)(*l_72) + (float)(p_51 >= (!(*l_72)))) >= (*l_72)) <= 0xA.0C7F43p+76) >= g_73) / (float)p_51) == 0xC.EE8FA1p-16) >= g_73))))) == p_51)) == g_73)) == 0x3.9D536Cp+52) != g_11) / (float)(*l_72))) - (float)g_55) != (-0x4.Ep-1)) + (float)g_73) * (float)g_73);
    g_10 = l_54;
    /* statement id: 6 */
    assert (g_10 == &g_55);
    return p_48;
    /* statement id: 7 */
    //assert (func_47_rv == &g_11);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_11, "g_11", print_hash_value);
    transparent_crc_bytes (&g_55, sizeof(g_55), "g_55", print_hash_value);
    transparent_crc(g_73, "g_73", print_hash_value);
    transparent_crc(g_116, "g_116", print_hash_value);
    transparent_crc(g_161, "g_161", print_hash_value);
    transparent_crc(g_162, "g_162", print_hash_value);
    transparent_crc(g_170, "g_170", print_hash_value);
    transparent_crc(g_181, "g_181", print_hash_value);
    transparent_crc(g_214.f0, "g_214.f0", print_hash_value);
    transparent_crc(g_276, "g_276", print_hash_value);
    transparent_crc(g_330.f0, "g_330.f0", print_hash_value);
    transparent_crc_bytes (&g_330.f1, sizeof(g_330.f1), "g_330.f1", print_hash_value);
    transparent_crc(g_330.f2, "g_330.f2", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 55
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 43
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 43, occurrence: 1

XXX total number of pointers: 75

XXX times a variable address is taken: 58
XXX times a pointer is dereferenced on RHS: 37
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 4
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 33
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 151

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 143
   level: 2, occurrence: 28
   level: 3, occurrence: 22
   level: 4, occurrence: 5
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20
XXX average alias set size: 1.21

XXX times a non-volatile is read: 282
XXX times a non-volatile is write: 86
XXX times a volatile is read: 11
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 68
XXX percentage of non-volatile access: 97.1

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 75
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 8
   depth: 2, occurrence: 11
   depth: 3, occurrence: 13
   depth: 4, occurrence: 3
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

