/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      841592484
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
};

union U1 {
   float  f0;
   float  f1;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 0;
static struct S0 g_44 = {0x82};
static volatile int32_t g_55 = 0xAD706983;/* VOLATILE GLOBAL g_55 */
static volatile int32_t *g_54 = &g_55;
static int32_t *g_90 = (void*)0;
static int32_t ***g_139 = (void*)0;
static struct S0 *g_201 = (void*)0;
static struct S0 **g_200 = &g_201;
static float g_222[2] = {0xF.202B76p-70,0xF.202B76p-70};
static struct S0 g_224 = {1U};
static volatile union U1 g_235 = {0xE.DA364Dp-21};/* VOLATILE GLOBAL g_235 */
static union U1 g_279 = {0x5.Dp+1};
static union U1 *g_278 = &g_279;
static int16_t g_445 = (-8);
static volatile int32_t **g_456 = &g_54;
static volatile union U1 ****g_482 = (void*)0;
static volatile union U1 *****g_481 = &g_482;
static uint16_t g_519 = 0U;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_25(void);
inline static struct S0  func_26(uint16_t  p_27, float  p_28);
static uint16_t  func_34(uint32_t  p_35, uint8_t  p_36, int16_t  p_37, float  p_38);
static uint32_t  func_41(struct S0  p_42, int16_t  p_43);
static int32_t  func_51(uint16_t  p_52, int32_t  p_53);
static int16_t  func_56(int32_t * p_57, uint8_t  p_58, int32_t  p_59);
static uint8_t  func_61(struct S0  p_62, struct S0  p_63, int32_t * p_64, int32_t * p_65);
static int32_t * func_73(int32_t * p_74, struct S0  p_75, int32_t  p_76);
static int32_t * func_77(struct S0  p_78);
static int32_t * func_81(uint16_t  p_82, int32_t * p_83, int32_t * p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_44 g_5 g_54 g_55 g_456 g_222 g_445 g_224.f0 g_481 g_200 g_201 g_519 g_278 g_279
 * writes: g_55 g_44.f0 g_222 g_224 g_279.f0 g_54
 */
inline static int32_t  func_25(void)
{ /* block id: 36 */
    int32_t l_29 = 2;
    int32_t l_477 = 0xE64F4765;
    int32_t l_502 = 0x8FF8E282;
    struct S0 *l_504 = &g_224;
    uint32_t l_518 = 2U;
    float l_538 = 0xA.0EEACAp+74;
    int16_t l_539 = 0xE68D;
    (*l_504) = func_26((l_29 , (safe_div_func_int32_t_s_s(l_29, (safe_lshift_func_uint16_t_u_s(func_34((65535U || ((safe_sub_func_uint32_t_u_u(func_41(g_44, g_5), (l_29 >= (safe_lshift_func_uint16_t_u_s(((g_44.f0 > ((l_29 >= l_29) , l_29)) , g_224.f0), g_5))))) > l_477)), g_44.f0, l_29, g_5), 0))))), l_502);
    for (g_224.f0 = (-9); (g_224.f0 >= 58); g_224.f0 = safe_add_func_int16_t_s_s(g_224.f0, 5))
    { /* block id: 488 */
        int32_t l_511 = 0x030C7EED;
        uint32_t l_514[5];
        float *l_520 = &g_279.f0;
        int i;
        for (i = 0; i < 5; i++)
            l_514[i] = 0xB14EE1F5;
        (*l_520) = (safe_sub_func_float_f_f((0xA.F4E655p-12 > (safe_sub_func_float_f_f((l_511 < g_222[0]), ((((((g_224.f0 && (0xA181349E | ((safe_add_func_float_f_f(l_514[4], (((l_29 < (safe_add_func_float_f_f(l_29, (-0x7.CD5B8Dp+52)))) >= l_518) > g_519))) , 0xAF12338E))) , g_44) , l_502) != 0xD.0CD68Cp+38) , g_44.f0) , g_5)))), l_511));
        (*g_456) = ((safe_rshift_func_int16_t_s_s(l_29, g_445)) , (*g_456));
    }
    (**g_456) = (**g_456);
    for (g_44.f0 = 0; (g_44.f0 == 1); g_44.f0++)
    { /* block id: 495 */
        int32_t l_531 = 0x8593EF35;
        int32_t *l_540 = &l_29;
        l_540 = ((safe_rshift_func_int16_t_s_s((l_477 & (safe_rshift_func_uint16_t_u_u((func_56(&l_29, (safe_sub_func_int32_t_s_s(((l_531 , ((safe_div_func_uint16_t_u_u(((safe_add_func_int32_t_s_s(0, ((*g_278) , (0x8228 > ((*g_456) == (void*)0))))) < (safe_add_func_uint16_t_u_u(g_44.f0, 1U))), 0xB590)) <= l_477)) <= l_539), 0x24136BE7)), l_29) < (*g_54)), 15))), g_445)) , (void*)0);
        /* statement id: 496 */
        assert (l_540 == 0);
        (*g_456) = (*g_456);
    }
    return l_539;
}


/* ------------------------------------------ */
/* 
 * reads : g_54
 * writes: g_55
 */
inline static struct S0  func_26(uint16_t  p_27, float  p_28)
{ /* block id: 482 */
    struct S0 l_503 = {0x47};
    (*g_54) = 0xEC4BF4F2;
    return l_503;
}


/* ------------------------------------------ */
/* 
 * reads : g_44.f0 g_481 g_200 g_201 g_445 g_54 g_55
 * writes: g_44.f0 g_222 g_55
 */
static uint16_t  func_34(uint32_t  p_35, uint8_t  p_36, int16_t  p_37, float  p_38)
{ /* block id: 471 */
    int32_t *l_480 = (void*)0;
    volatile union U1 *****l_483[1];
    float *l_484[5];
    union U1 ****l_500 = (void*)0;
    union U1 *****l_499 = &l_500;
    int32_t l_501[2][7] = {{0,2,2,0,2,2,0},{2,0,2,2,0,2,2}};
    int i, j;
    for (i = 0; i < 1; i++)
        l_483[i] = (void*)0;
    for (i = 0; i < 5; i++)
        l_484[i] = &g_279.f0;
    for (g_44.f0 = 0; (g_44.f0 <= 1); g_44.f0 += 1)
    { /* block id: 474 */
        int32_t *l_478 = &g_5;
        int32_t **l_479 = &l_478;
        (*l_479) = l_478;
        (*l_479) = l_480;
        /* statement id: 476 */
        assert (l_478 == 0);
    }
    l_483[0] = g_481;
    /* statement id: 478 */
    //assert (l_483[0] == &g_482 || l_483[0] == 0);
    g_222[0] = (-0x10.Ap+1);
    (*g_54) = (safe_lshift_func_int16_t_s_u(((safe_mod_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(((*g_200) == (void*)0), (g_445 && (safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u((l_484[0] == l_484[0]), p_36)), (safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_u(((p_36 == (((&g_482 != l_499) , p_37) == (*g_54))) >= 0x551B), p_37)), p_35))))))), 1)) >= l_501[0][5]), 7));
    return g_44.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_5 g_55 g_456 g_222 g_445 g_224.f0
 * writes: g_55
 */
static uint32_t  func_41(struct S0  p_42, int16_t  p_43)
{ /* block id: 37 */
    int32_t *l_45 = &g_5;
    int32_t l_50 = (-6);
    float *l_471 = &g_279.f0;
    float **l_470 = &l_471;
    int32_t **l_474 = &l_45;
    l_45 = (void*)0;
    /* statement id: 38 */
    assert (l_45 == 0);
    if ((safe_add_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(l_50, 11)), ((func_51((((((((((void*)0 == &l_50) | p_42.f0) || (0x2E43 < (g_54 != &g_55))) && (((4294967295U != 4294967288U) | 0xE8E2) | 65530U)) < 1U) != l_50) || p_43) , p_43), p_42.f0) | l_50) || g_55))))
    { /* block id: 462 */
        int32_t **l_449 = &l_45;
        (*l_449) = &l_50;
        /* statement id: 463 */
        assert (l_45 == &l_50);
    }
    else
    { /* block id: 464 */
        uint16_t l_463 = 0U;
        uint16_t l_468 = 0x1AD1;
        struct S0 ***l_469 = &g_200;
        float ***l_472 = &l_470;
        int32_t *l_473 = &g_5;
        (**g_456) = (((safe_add_func_uint32_t_u_u((((safe_sub_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((g_5 > (((void*)0 != g_456) & ((((safe_div_func_float_f_f(g_222[1], (((((safe_sub_func_uint32_t_u_u(g_5, (safe_add_func_uint16_t_u_u(l_463, (safe_lshift_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(((0x03C2 != (__builtin_clzl(g_5) || 4294967288U)) , g_445), g_5)) ^ g_224.f0), p_42.f0)))))) != g_445) & l_468) , (void*)0) != l_469))) , 0x5929E0D4) | (-1)) == l_468))), (**g_456))), p_42.f0)) & g_224.f0) & p_42.f0), 4294967293U)) , p_43) <= p_43);
        (*l_472) = l_470;
        l_473 = &l_50;
        /* statement id: 467 */
        assert (l_473 == &l_50);
    }
    /* facts after branching */
    assert (l_45 == 0 || l_45 == &l_50);
    (*l_474) = &l_50;
    /* statement id: 469 */
    assert (l_45 == &l_50);
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes:
 */
static int32_t  func_51(uint16_t  p_52, int32_t  p_53)
{ /* block id: 39 */
    int32_t *l_60 = &g_5;
    struct S0 l_66 = {1U};
    struct S0 l_448 = {0x63};
    return (*l_60);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_56(int32_t * p_57, uint8_t  p_58, int32_t  p_59)
{ /* block id: 448 */
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_5 g_55 g_235 g_224.f0 g_54 g_222 g_200 g_139 g_201 g_235.f1 g_278 g_279 g_235.f0 g_279.f1
 * writes: g_90 g_44.f0 g_5 g_224 g_222 g_55 g_201 g_54 g_278 g_44 g_279.f1 g_279.f0 g_235.f0
 */
static uint8_t  func_61(struct S0  p_62, struct S0  p_63, int32_t * p_64, int32_t * p_65)
{ /* block id: 40 */
    int32_t l_214 = 1;
    struct S0 *l_215 = &g_44;
    uint32_t l_216 = 4294967293U;
    int32_t **l_443 = (void*)0;
    int32_t **l_444 = &g_90;
    (*l_444) = func_73(func_77(g_44), p_62, (((((((((l_214 , p_63.f0) ^ l_214) != ((l_214 && g_44.f0) < (l_215 == l_215))) || 0x4BBCF4FF) || l_216) < g_44.f0) | (*p_64)) < p_63.f0) > 0x810F));
    /* statement id: 445 */
    assert (g_54 == 0 || g_54 == &g_55);
    assert (g_90 == &g_5 || g_90 == 0);
    //assert (g_201 == dangling || g_201 == 0);
    //assert (g_278 == dangling || g_278 == &g_279);
    p_63 = p_63;
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_44.f0 g_5 g_235 g_224.f0 g_54 g_55 g_44 g_222 g_200 g_139 g_201 g_235.f1 g_278 g_279 g_235.f0 g_279.f1
 * writes: g_44.f0 g_90 g_5 g_224 g_222 g_55 g_201 g_54 g_278 g_44 g_279.f1 g_279.f0 g_235.f0
 */
static int32_t * func_73(int32_t * p_74, struct S0  p_75, int32_t  p_76)
{ /* block id: 171 */
    int32_t *l_219 = &g_5;
    struct S0 *l_221 = (void*)0;
    int32_t ****l_225[4];
    union U1 l_241[10][7][3] = {{{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}}},{{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}}},{{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}},{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}}},{{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}},{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}}},{{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}},{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}}},{{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}},{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}}},{{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}},{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}}},{{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}},{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}}},{{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}},{{0x9.8C824Bp-79},{0xA.B33238p-40},{0x0.2p-1}}},{{{0x1.59681Ap+30},{0x3.B354ACp+11},{0x1.59681Ap+30}},{{0x9.8C824Bp-79},{0x0.2p-1},{0x0.178792p+67}},{{0x7.FA486Ap+45},{0x3.B354ACp+11},{0x6.7393B2p-12}},{{0xA.B33238p-40},{0xA.B33238p-40},{0x0.178792p+67}},{{0x1.59681Ap+30},{0x5.2DAAACp+99},{0x1.59681Ap+30}},{{0xA.B33238p-40},{0x0.2p-1},{0x0.2p-1}},{{0x7.FA486Ap+45},{0x5.2DAAACp+99},{0x6.7393B2p-12}}}};
    struct S0 l_275 = {0x38};
    int32_t *l_299 = &g_5;
    uint32_t l_371 = 8U;
    uint8_t l_419 = 255U;
    int i, j, k;
    for (i = 0; i < 4; i++)
        l_225[i] = &g_139;
    for (g_44.f0 = 0; (g_44.f0 != 32); g_44.f0 = safe_add_func_int16_t_s_s(g_44.f0, 2))
    { /* block id: 174 */
        int32_t **l_220 = &g_90;
        (*l_220) = l_219;
        /* statement id: 175 */
        assert (g_90 == &g_5);
    }
    /* facts after for loop */
    assert (g_90 == &g_5 || g_90 == 0);
    if ((((p_75.f0 == ((void*)0 != l_221)) , (*l_219)) , (*p_74)))
    { /* block id: 177 */
        for (g_44.f0 = 0; (g_44.f0 <= 1); g_44.f0 += 1)
        { /* block id: 180 */
            for (g_5 = 0; (g_5 <= 1); g_5 += 1)
            { /* block id: 183 */
                struct S0 *l_223 = &g_224;
                (*l_223) = p_75;
            }
        }
    }
    else
    { /* block id: 187 */
        float *l_226 = &g_222[1];
        (*l_226) = (&g_139 == l_225[1]);
    }
    if ((*p_74))
    { /* block id: 190 */
        uint32_t l_229 = 0x88F4ACA7;
        uint16_t l_230 = 0xF14C;
        struct S0 l_242[4][1][1] = {{{{246U}}},{{{0x31}}},{{{246U}}},{{{0x31}}}};
        union U1 *l_253 = (void*)0;
        int32_t *l_259 = &g_5;
        uint32_t l_263[5];
        int32_t *l_271 = &g_5;
        union U1 **l_273[8];
        union U1 ***l_272[1];
        int i, j, k;
        for (i = 0; i < 5; i++)
            l_263[i] = 1U;
        for (i = 0; i < 8; i++)
            l_273[i] = &l_253;
        for (i = 0; i < 1; i++)
            l_272[i] = &l_273[3];
        if ((safe_div_func_uint32_t_u_u((((l_229 & p_76) ^ l_229) & l_230), __builtin_clz((safe_rshift_func_uint16_t_u_u(((*l_219) | (safe_mod_func_int32_t_s_s((g_235 , (*p_74)), (g_5 , (~(safe_sub_func_int32_t_s_s(g_224.f0, l_229))))))), 1))))))
        { /* block id: 191 */
            float *l_245 = (void*)0;
            float *l_246[3];
            int i;
            for (i = 0; i < 3; i++)
                l_246[i] = &g_222[0];
            (*l_219) = (g_44.f0 , (((((*l_219) & (safe_add_func_uint16_t_u_u((l_241[7][5][1] , (g_224.f0 ^ __builtin_popcount((0x0DAC7CBA == (l_229 >= (l_242[0][0][0] , ((p_75 , ((safe_rshift_func_int16_t_s_s((-1), p_75.f0)) >= 0x2AB0)) ^ (*p_74)))))))), g_44.f0))) , (void*)0) != &g_139) , 0xC.1F7841p+85));
            (*p_74) = (*g_54);
        }
        else
        { /* block id: 194 */
            struct S0 *l_247 = &g_224;
            int32_t l_250 = 0x920B7C3F;
            int32_t *l_252 = &l_250;
            for (p_76 = 0; (p_76 <= 0); p_76 += 1)
            { /* block id: 197 */
                struct S0 l_251[5][8] = {{{0x6D},{0xD1},{0xD1},{0x6D},{0xD1},{0xD1},{0x6D},{0x93}},{{0xD1},{0xD1},{0x6D},{0xD1},{0xD1},{0x6D},{0xD1},{0xD1}},{{0x93},{0xD1},{0x93},{0x93},{0xD1},{0x93},{0x93},{0xD1}},{{0xD1},{0x93},{0x93},{0xD1},{0x93},{0x93},{0xD1},{0x93}},{{0xD1},{0xD1},{0x6D},{0xD1},{0xD1},{0x6D},{0xD1},{0xD1}}};
                int32_t *l_257 = &l_250;
                int i, j;
                for (g_44.f0 = 0; (g_44.f0 <= 0); g_44.f0 += 1)
                { /* block id: 200 */
                    if (l_229)
                    { /* block id: 201 */
                        l_247 = l_247;
                        (*l_247) = p_75;
                        g_90 = p_74;
                    }
                    else
                    { /* block id: 205 */
                        l_252 = func_81((safe_add_func_int16_t_s_s(p_75.f0, l_250)), p_74, func_77(l_251[2][7]));
                        /* statement id: 206 */
                        assert (l_252 == &g_5);
                    }
                    if (l_242[0][0][0].f0)
                        continue;
                    for (g_5 = 0; (g_5 <= 0); g_5 += 1)
                    { /* block id: 211 */
                        union U1 **l_254 = (void*)0;
                        union U1 **l_255 = &l_253;
                        int i, j, k;
                        (*l_255) = (((void*)0 == &l_241[(p_76 + 4)][(p_76 + 6)][(g_44.f0 + 2)]) , l_253);
                        p_75 = l_242[(g_44.f0 + 2)][g_44.f0][p_76];
                        g_90 = p_74;
                    }
                }
                if ((g_224.f0 < __builtin_parity(l_229)))
                { /* block id: 217 */
                    int32_t *l_256[6] = {&g_5,&g_5,&g_5,&g_5,&g_5,&g_5};
                    int i;
                    p_74 = p_74;
                    p_74 = l_256[1];
                }
                else
                { /* block id: 220 */
                    int32_t *l_258[10] = {&l_250,&l_250,&l_250,&l_250,&l_250,&l_250,&l_250,&l_250,&l_250,&l_250};
                    int i;
                    return l_259;
                    /* statement id: 221 */
                    //assert (g_201 == dangling || g_201 == 0);
                    //assert (func_73_rv == &g_5);
                }
                for (l_230 = 0; (l_230 <= 3); l_230 += 1)
                { /* block id: 225 */
                    float *l_261[7] = {&l_241[7][5][1].f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0};
                    int i;
                    for (g_5 = 3; (g_5 >= 0); g_5 -= 1)
                    { /* block id: 228 */
                        float *l_260 = &l_241[7][5][1].f1;
                        int i;
                        l_257 = (void*)0;
                        /* statement id: 229 */
                        assert (l_257 == 0);
                        (*g_54) = __builtin_clzl(g_224.f0);
                        (*l_260) = (p_75.f0 == g_5);
                    }
                    g_222[0] = g_222[0];
                    for (l_229 = 0; (l_229 <= 2); l_229 += 1)
                    { /* block id: 236 */
                        (*g_200) = &p_75;
                        /* statement id: 237 */
                        assert (g_201 == &p_75);
                        p_74 = (void*)0;
                        /* statement id: 238 */
                        assert (p_74 == 0);
                    }
                    g_90 = p_74;
                    for (p_75.f0 = 0; (p_75.f0 <= 2); p_75.f0 += 1)
                    { /* block id: 243 */
                        union U1 l_262 = {0xE.C8B339p-78};
                        l_252 = (void*)0;
                        /* statement id: 244 */
                        assert (l_252 == 0);
                        (*g_54) = (g_139 == (void*)0);
                        (*l_247) = ((__builtin_bswap32((&l_221 == &g_201)) , l_262) , p_75);
                    }
                }
                /* facts after for loop */
                assert (l_257 == 0 || l_257 == &l_250);
            }
            /* facts after for loop */
            assert (g_201 == &p_75 || g_201 == 0);
            assert (p_74 == 0 || p_74 == &g_5);
            assert (l_252 == 0 || l_252 == &g_5 || l_252 == &l_250);
            if (((*l_259) | (g_55 || l_263[4])))
            { /* block id: 250 */
                int32_t l_282[10] = {8,0x68218E07,8,(-10),(-10),8,0x68218E07,8,(-10),(-10)};
                union U1 l_285 = {0x9.57BD71p-31};
                int32_t l_289 = 0;
                int32_t *l_290 = &l_250;
                int i;
                for (p_76 = 1; (p_76 <= 4); p_76 += 1)
                { /* block id: 253 */
                    union U1 *l_277 = &l_241[2][2][0];
                    int32_t l_288 = 5;
                    if ((safe_mod_func_int32_t_s_s((g_44.f0 , (safe_rshift_func_int16_t_s_s(p_76, 8))), ((safe_lshift_func_int16_t_s_s((!__builtin_ctz(g_224.f0)), 1)) && 0xDF3BDAC9))))
                    { /* block id: 254 */
                        l_271 = p_74;
                        (*l_259) = p_76;
                    }
                    else
                    { /* block id: 257 */
                        union U1 ****l_274 = &l_272[0];
                        (*l_274) = l_272[0];
                        g_54 = (void*)0;
                        /* statement id: 259 */
                        assert (g_54 == 0);
                        p_74 = p_74;
                    }
                    for (p_75.f0 = 0; (p_75.f0 <= 7); p_75.f0 += 1)
                    { /* block id: 264 */
                        int32_t l_276 = 9;
                        l_275 = p_75;
                        if (l_276)
                            continue;
                        g_278 = l_277;
                        /* statement id: 267 */
                        assert ((g_278 >= &l_241[0][0][0] && g_278 <= &l_241[9][6][2]));
                    }
                    (*l_259) = (p_75.f0 == (safe_add_func_int32_t_s_s(p_75.f0, (l_282[4] == (p_76 || ((safe_sub_func_int16_t_s_s(((l_285 , p_76) | ((safe_sub_func_int16_t_s_s((((-4) < p_76) ^ (l_282[5] || l_288)), g_224.f0)) < p_75.f0)), 65530U)) <= g_44.f0))))));
                }
                /* facts after for loop */
                assert (g_54 == 0 || g_54 == &g_55);
                assert (l_271 == 0 || l_271 == &g_5);
                assert ((g_278 >= &l_241[0][0][0] && g_278 <= &l_241[9][6][2]) || g_278 == &g_279);
                l_289 = p_76;
                if (__builtin_clzll(l_250))
                { /* block id: 272 */
                    (*g_200) = (*g_200);
                }
                else
                { /* block id: 274 */
                    l_290 = func_77(p_75);
                    /* statement id: 275 */
                    assert (l_290 == &g_5);
                }
                /* facts after branching */
                assert (l_290 == &g_5 || l_290 == &l_250);
                return p_74;
                /* statement id: 277 */
                //assert (g_201 == dangling || g_201 == 0);
                //assert (g_278 == dangling || g_278 == &g_279);
                //assert (func_73_rv == 0 || func_73_rv == &g_5);
            }
            else
            { /* block id: 278 */
                return p_74;
                /* statement id: 279 */
                //assert (g_201 == dangling || g_201 == 0);
                //assert (func_73_rv == 0 || func_73_rv == &g_5);
            }
        }
    }
    else
    { /* block id: 282 */
        uint32_t l_291 = 0x447D9160;
        struct S0 l_348 = {0xB5};
        int32_t *l_380 = (void*)0;
        union U1 l_382 = {0x4.C16334p+54};
        union U1 *l_394 = &g_279;
        if (l_291)
        { /* block id: 283 */
            g_90 = ((*p_74) , p_74);
            /* statement id: 284 */
            assert (g_90 == &g_5);
            return &g_5;
            /* statement id: 285 */
            //assert (func_73_rv == &g_5);
        }
        else
        { /* block id: 286 */
            struct S0 l_292 = {0x5E};
            (*p_74) = (*p_74);
            for (l_275.f0 = 0; (l_275.f0 <= 3); l_275.f0 += 1)
            { /* block id: 290 */
                struct S0 *l_294 = &l_292;
                for (l_291 = 0; (l_291 <= 3); l_291 += 1)
                { /* block id: 293 */
                    int i;
                    g_90 = p_74;
                    /* statement id: 294 */
                    assert (g_90 == &g_5);
                    for (p_75.f0 = 0; (p_75.f0 <= 3); p_75.f0 += 1)
                    { /* block id: 297 */
                        struct S0 *l_293[2][6] = {{&g_224,&g_224,&g_224,&g_44,&g_44,&g_224},{&l_292,&l_292,&g_44,&l_275,&g_44,&l_292}};
                        int i, j;
                        g_44 = l_292;
                        if (l_292.f0)
                            continue;
                        l_292 = p_75;
                    }
                }
                (*l_294) = l_292;
            }
        }
        if ((safe_rshift_func_uint16_t_u_u(((((*g_200) != (void*)0) & (*g_54)) == p_75.f0), 4)))
        { /* block id: 306 */
            float *l_297[8][10][3] = {{{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0}},{{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0}},{{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0}},{{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&g_279.f0,&g_279.f0,&l_241[7][5][1].f0},{&g_279.f0,&l_241[7][5][1].f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,(void*)0,&l_241[7][5][1].f0},{&g_279.f0,(void*)0,&g_279.f0},{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0}},{{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0},{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0}},{{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0},{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0}},{{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0},{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0}},{{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0},{&g_279.f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&g_279.f0,&l_241[7][5][1].f0},{&l_241[7][5][1].f0,&g_279.f0,(void*)0},{&l_241[7][5][1].f0,&l_241[7][5][1].f0,&g_279.f0},{&l_241[7][5][1].f0,&g_279.f0,&g_279.f0}}};
            int32_t l_298 = 0;
            int i, j, k;
            l_298 = (g_235.f1 != 0xE.A71606p-71);
        }
        else
        { /* block id: 308 */
            l_299 = p_74;
            for (g_5 = 0; (g_5 != 16); g_5 = safe_add_func_int16_t_s_s(g_5, 8))
            { /* block id: 312 */
                struct S0 l_304 = {255U};
                int32_t l_306[2];
                int i;
                for (i = 0; i < 2; i++)
                    l_306[i] = 7;
                for (l_275.f0 = 0; (l_275.f0 < 41); l_275.f0 = safe_add_func_int32_t_s_s(l_275.f0, 1))
                { /* block id: 315 */
                    struct S0 *l_305 = &l_304;
                    float *l_307 = &l_241[7][5][1].f1;
                    (*l_305) = l_304;
                    l_306[0] = ((*g_200) == (*g_200));
                    (*l_307) = p_76;
                    return p_74;
                    /* statement id: 319 */
                    //assert (func_73_rv == &g_5);
                }
            }
            for (g_44.f0 = 16; (g_44.f0 != 13); g_44.f0--)
            { /* block id: 324 */
                uint32_t l_310 = 0xB6566BB2;
                if ((*p_74))
                    break;
                if (l_310)
                    continue;
            }
            return p_74;
            /* statement id: 328 */
            //assert (func_73_rv == &g_5);
        }
        if ((*p_74))
        { /* block id: 330 */
            int32_t l_311 = 0x69B8EB79;
            float *l_320 = &l_241[7][5][1].f1;
            if (l_311)
            { /* block id: 331 */
                float l_318[6][9] = {{(-0x1.Bp+1),(-0x1.Bp+1),0xA.28B6AEp+63,0xF.966B25p-82,0x0.41685Ap+87,0xF.966B25p-82,0xA.28B6AEp+63,(-0x1.Bp+1),(-0x1.Bp+1)},{0xE.69EFC3p+91,0x3.Bp+1,(-0x1.Bp+1),0xF.966B25p-82,(-0x1.Bp+1),0x8.418BB6p+19,0xE.69EFC3p+91,0xD.577488p-4,0x8.418BB6p+19},{0xF.966B25p-82,0x3.Bp+1,0xA.28B6AEp+63,0x8.418BB6p+19,0xC.639A1Fp+79,0x7.D1D10Dp+50,0x7.D1D10Dp+50,0xC.639A1Fp+79,0x8.418BB6p+19},{0xE.69EFC3p+91,(-0x1.Bp+1),0xE.69EFC3p+91,0x7.D1D10Dp+50,0x5.Ep-1,0xA.28B6AEp+63,0x7.D1D10Dp+50,0xD.577488p-4,(-0x1.Bp+1)},{(-0x1.Bp+1),0xD.577488p-4,0x7.D1D10Dp+50,0xA.28B6AEp+63,0x5.Ep-1,0x7.D1D10Dp+50,0xE.69EFC3p+91,(-0x1.Bp+1),0xE.69EFC3p+91},{0x8.418BB6p+19,0xC.639A1Fp+79,0x7.D1D10Dp+50,0x7.D1D10Dp+50,0xC.639A1Fp+79,0x8.418BB6p+19,0xA.28B6AEp+63,0x3.Bp+1,0xF.966B25p-82}};
                int32_t l_322 = 0xF9073540;
                union U1 **l_338 = &g_278;
                union U1 ***l_337 = &l_338;
                union U1 ****l_336 = &l_337;
                uint16_t l_341 = 1U;
                struct S0 l_350[4][7][3] = {{{{246U},{1U},{0x9F}},{{0x90},{0x6D},{1U}},{{0x6D},{6U},{246U}},{{0xD4},{1U},{0x90}},{{0x90},{0x24},{0U}},{{8U},{1U},{246U}},{{0xFA},{0x6B},{1U}}},{{{0x3F},{0xD4},{1U}},{{0xDF},{0U},{0xBD}},{{0U},{255U},{0x21}},{{0xC8},{246U},{0x21}},{{0x68},{0xFA},{0xBD}},{{0x6B},{0x6D},{1U}},{{1U},{0U},{1U}}},{{{3U},{246U},{246U}},{{0x21},{254U},{0U}},{{0x91},{8U},{0x90}},{{0U},{0x9F},{255U}},{{0x91},{0x68},{0x85}},{{0x21},{0x7C},{6U}},{{3U},{0x3F},{0xD4}}},{{{1U},{6U},{254U}},{{0x6B},{0xC8},{254U}},{{0x68},{0xBD},{0xA8}},{{0xC8},{0xBD},{3U}},{{0U},{0xC8},{0xFA}},{{0xDF},{6U},{1U}},{{0x3F},{0x3F},{0U}}}};
                int i, j, k;
                for (l_275.f0 = 0; (l_275.f0 <= 1); l_275.f0 += 1)
                { /* block id: 334 */
                    union U1 **l_319 = &g_278;
                    uint8_t l_321 = 0U;
                    union U1 ***l_335 = &l_319;
                    union U1 ****l_334[3];
                    int i;
                    for (i = 0; i < 3; i++)
                        l_334[i] = &l_335;
                    if ((*g_54))
                        break;
                    (*g_54) = (safe_sub_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(((((l_291 , __builtin_clz(((safe_lshift_func_int16_t_s_s((((p_76 <= p_75.f0) , ((l_319 == &g_278) <= (((l_320 == p_74) != (*l_299)) ^ l_311))) >= 0xB425), l_321)) != 0x633F))) , g_44.f0) , l_322) < l_322), l_322)), 0));
                    if (l_321)
                    { /* block id: 337 */
                        int32_t l_333[8] = {0,0,0,0,0,0,0,0};
                        int i;
                        g_222[l_275.f0] = 0x7.686B53p+38;
                        g_222[l_275.f0] = (((((safe_mod_func_uint16_t_u_u(0U, (safe_rshift_func_int16_t_s_u(((((g_5 , (((*g_278) , (!(!((l_322 != 0x089E) <= (*g_54))))) < ((safe_lshift_func_int16_t_s_s((-4), (((g_44.f0 <= p_76) & p_76) == l_333[7]))) || 0))) != g_224.f0) , 0U) != p_76), g_44.f0)))) , l_334[0]) != l_336) > p_75.f0) , g_44.f0);
                        (*l_320) = (g_44.f0 , (safe_div_func_float_f_f(l_341, ((__builtin_ffsll((*l_219)) < p_76) <= __builtin_popcount(g_224.f0)))));
                    }
                    else
                    { /* block id: 341 */
                        return &g_5;
                        /* statement id: 342 */
                        //assert (func_73_rv == &g_5);
                    }
                    if ((safe_unary_minus_func_uint16_t_u((safe_mod_func_uint32_t_u_u((!(&l_335 == &l_335)), (*p_74))))))
                    { /* block id: 344 */
                        (*l_320) = (safe_sub_func_float_f_f(((p_76 <= p_75.f0) != (&l_221 != (void*)0)), ((((*g_54) == (g_5 ^ p_75.f0)) , 0x1.8p+1) != g_224.f0)));
                    }
                    else
                    { /* block id: 346 */
                        struct S0 *l_349 = &g_44;
                        (*l_349) = l_348;
                        (*g_54) = (-4);
                        (*l_349) = l_350[1][1][2];
                    }
                }
            }
            else
            { /* block id: 352 */
                return p_74;
                /* statement id: 353 */
                //assert (func_73_rv == &g_5);
            }
        }
        else
        { /* block id: 355 */
            int32_t *l_357[2][2];
            struct S0 *l_379 = &g_44;
            int32_t ****l_381 = &g_139;
            uint32_t l_422 = 8U;
            int i, j;
            for (i = 0; i < 2; i++)
            {
                for (j = 0; j < 2; j++)
                    l_357[i][j] = &g_5;
            }
            for (l_291 = 3; (l_291 >= 27); l_291 = safe_add_func_uint32_t_u_u(l_291, 5))
            { /* block id: 358 */
                (*g_200) = (*g_200);
                if ((*g_54))
                    break;
            }
            for (l_291 = (-24); (l_291 > 41); l_291 = safe_add_func_int16_t_s_s(l_291, 6))
            { /* block id: 364 */
                float l_372 = 0x4.7663FDp+5;
                int32_t l_373 = 0x4DF2F42F;
                for (p_75.f0 = 3; (p_75.f0 != 53); p_75.f0++)
                { /* block id: 367 */
                    l_357[0][1] = &g_5;
                }
                for (p_76 = 0; (p_76 <= 1); p_76 += 1)
                { /* block id: 372 */
                    float *l_376 = &g_279.f1;
                    struct S0 ***l_377 = &g_200;
                    struct S0 ****l_378 = &l_377;
                    int i, j;
                    l_357[p_76][p_76] = l_357[p_76][p_76];
                    g_222[p_76] = (((safe_add_func_float_f_f(((!p_75.f0) <= ((0xB.9F3FECp+94 != ((safe_add_func_float_f_f(((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(((*l_219) , (g_44.f0 , (g_224.f0 , (safe_lshift_func_uint16_t_u_s(((g_55 < (*p_74)) ^ (0xC7448AAE ^ (safe_rshift_func_int16_t_s_s(p_75.f0, g_44.f0)))), 3))))), p_75.f0)), l_371)) , 0xD.8DAF1Ap+17), l_372)) != p_75.f0)) < l_373)), 0x8.FCA08Cp-90)) > g_224.f0) == (-0x1.9p+1));
                    (*l_376) = (safe_div_func_float_f_f(g_235.f0, p_76));
                    /* statement id: 375 */
                                        (*l_378) = l_377;
                }
            }
            (*l_379) = l_348;
            if ((*g_54))
            { /* block id: 380 */
                int32_t l_385 = 0xD80B2405;
lbl_404:
                p_74 = l_380;
                /* statement id: 381 */
                assert (p_74 == 0);
                if (((g_224.f0 , 0xC109) ^ ((-10) >= (((l_381 == l_225[1]) , func_81((l_382 , 65532U), l_380, p_74)) == (void*)0))))
                { /* block id: 382 */
                    uint32_t l_386 = 4294967295U;
                    if ((g_224.f0 == (safe_div_func_uint16_t_u_u((l_385 , ((p_74 != (void*)0) & l_386)), (p_75.f0 && g_224.f0)))))
                    { /* block id: 383 */
                        p_74 = func_77(p_75);
                        /* statement id: 384 */
                        assert (p_74 == &g_5);
                    }
                    else
                    { /* block id: 385 */
                        (*g_54) = l_385;
                    }
                    /* facts after branching */
                    assert (p_74 == 0 || p_74 == &g_5);
                    for (l_385 = 13; (l_385 > (-24)); l_385 = safe_sub_func_int32_t_s_s(l_385, 8))
                    { /* block id: 390 */
                        int32_t l_392 = 8;
                        float *l_393 = &g_279.f0;
                        p_74 = &g_5;
                        /* statement id: 391 */
                        assert (p_74 == &g_5);
                        (*l_393) = ((safe_sub_func_float_f_f((-0x10.Dp-1), (!l_392))) > g_235.f0);
                    }
                    l_394 = &g_279;
                }
                else
                { /* block id: 395 */
                    int32_t *l_395 = &l_385;
                    struct S0 l_396 = {0U};
                    union U1 l_397 = {0x2.93C3BFp-93};
                    if (p_75.f0)
                    { /* block id: 396 */
                        return p_74;
                        /* statement id: 397 */
                        //assert (func_73_rv == 0);
                    }
                    else
                    { /* block id: 398 */
                        float *l_398 = (void*)0;
                        float *l_399 = &g_279.f0;
                        l_396 = p_75;
                        (*l_379) = ((l_397 , p_75) , g_44);
                        (*l_399) = (0x1.7p-1 >= g_235.f0);
                    }
                }
                /* facts after branching */
                assert (p_74 == 0 || p_74 == &g_5);
                for (g_44.f0 = (-15); (g_44.f0 <= 54); g_44.f0 = safe_add_func_uint16_t_u_u(g_44.f0, 1))
                { /* block id: 406 */
                    int32_t *l_406 = &g_5;
                    float *l_407 = &l_382.f1;
                    (*g_200) = ((*l_299) , (*g_200));
                    for (l_385 = 0; (l_385 != 4); l_385++)
                    { /* block id: 410 */
                        int32_t *l_405[3][8] = {{&l_385,&g_5,&g_5,&g_5,&l_385,&l_385,&g_5,&g_5},{&g_5,&g_5,&g_5,(void*)0,&l_385,&g_5,&l_385,&g_5},{&l_385,&g_5,(void*)0,&g_5,&l_385,&g_5,&g_5,&g_5}};
                        int i, j;
                        if (l_275.f0)
                            goto lbl_404;
                        l_406 = l_405[2][6];
                        (*l_219) = (g_55 ^ p_76);
                        p_74 = p_74;
                    }
                    /* facts after for loop */
                    assert (l_406 == 0 || l_406 == &l_385 || l_406 == &g_5);
                    (*l_407) = (&g_139 == l_381);
                    /* statement id: 416 */
                                    }
            }
            else
            { /* block id: 418 */
                int32_t l_408[10] = {0xC1FF58AC,0xF4806CCE,0xC1FF58AC,0xF4806CCE,0xC1FF58AC,0xF4806CCE,0xC1FF58AC,0xF4806CCE,0xC1FF58AC,0xF4806CCE};
                int32_t *l_414 = &l_408[3];
                int i;
                l_414 = func_81((((g_5 , (g_224.f0 < ((g_224.f0 , (g_224.f0 , (((p_75 , l_408[3]) < (safe_lshift_func_int16_t_s_s((__builtin_parityll(g_224.f0) , ((safe_unary_minus_func_uint32_t_u((((safe_mod_func_uint16_t_u_u((p_76 , g_224.f0), 0x782C)) > (*l_299)) | p_75.f0))) >= p_75.f0)), 6))) < (*g_54)))) ^ g_5))) > 65535U) , 0x59FF), &g_5, p_74);
                /* statement id: 419 */
                assert (l_414 == &g_5);
                p_74 = p_74;
                if (((__builtin_popcount(p_76) <= ((safe_add_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s((l_241[4][2][0] , (65530U > l_419)), 0)) || ((*g_278) , (p_75 , g_55))), (safe_mod_func_uint32_t_u_u(((g_44.f0 != p_75.f0) , 0x4AF8F418), l_422)))) != 3U)) <= p_76))
                { /* block id: 421 */
                    for (l_348.f0 = 0; (l_348.f0 <= 7); l_348.f0 = safe_add_func_uint32_t_u_u(l_348.f0, 1))
                    { /* block id: 424 */
                        if ((*p_74))
                            break;
                    }
                }
                else
                { /* block id: 427 */
                    uint8_t l_429 = 0x5B;
                    l_380 = ((safe_div_func_uint16_t_u_u(0x603D, ((safe_add_func_int32_t_s_s((*g_54), l_429)) , p_75.f0))) , p_74);
                    /* statement id: 428 */
                    assert (l_380 == &g_5);
                    for (l_348.f0 = (-26); (l_348.f0 < 12); l_348.f0++)
                    { /* block id: 431 */
                        struct S0 l_432 = {0xEA};
                        (*l_379) = (p_75 , l_432);
                    }
                }
                /* facts after branching */
                assert (l_380 == &g_5 || l_380 == 0);
            }
            /* facts after branching */
            assert (p_74 == 0 || p_74 == &g_5);
            assert (l_380 == &g_5 || l_380 == 0);
        }
        /* facts after branching */
        assert (p_74 == 0 || p_74 == &g_5);
        assert (l_380 == &g_5 || l_380 == 0);
        g_235.f0 = (-((-0x1.2p+1) == ((g_224.f0 , ((*g_54) , (p_75.f0 <= ((safe_sub_func_float_f_f(((g_44.f0 >= p_75.f0) , (-0x1.6p-1)), p_76)) == (safe_add_func_float_f_f((safe_sub_func_float_f_f(((-(g_235.f0 != l_348.f0)) != g_279.f1), g_5)), (-0x9.7p+1))))))) == 0x0.CA3004p-10)));
    }
    /* facts after branching */
    assert (p_74 == 0 || p_74 == &g_5);
    for (g_224.f0 = 0; (g_224.f0 <= 51); g_224.f0 = safe_add_func_int32_t_s_s(g_224.f0, 6))
    { /* block id: 441 */
        g_90 = p_74;
    }
    return p_74;
    /* statement id: 444 */
    //assert (func_73_rv == 0 || func_73_rv == &g_5);
}


/* ------------------------------------------ */
/* 
 * reads : g_44.f0 g_5 g_44 g_55
 * writes: g_90
 */
static int32_t * func_77(struct S0  p_78)
{ /* block id: 41 */
    int32_t *l_86 = (void*)0;
    uint16_t l_93 = 1U;
    int32_t *l_102 = (void*)0;
    int32_t *l_103 = &g_5;
    int32_t **l_124 = (void*)0;
    int32_t *l_133 = &g_5;
    struct S0 l_191 = {255U};
    struct S0 *l_199 = &g_44;
    struct S0 **l_198 = &l_199;
    for (p_78.f0 = 0; (p_78.f0 <= 28); p_78.f0 = safe_add_func_int16_t_s_s(p_78.f0, 7))
    { /* block id: 44 */
        int16_t l_85[2];
        int32_t **l_89[1];
        int32_t l_100[3][4][8] = {{{0x730A6A1D,0x18A95D68,1,(-1),0xE7447E38,0x25DDBF1A,5,0x59668C86},{(-5),(-8),(-9),0xD5754278,(-1),0x25DDBF1A,0x8DD589E8,(-3)},{0x8D2902D4,0x18A95D68,0xF8735943,3,3,0x730A6A1D,0,0x6D4D43A6},{(-3),0x3C289E41,0x17DA69ED,(-1),0x730A6A1D,1,0xE908AE34,0x484BB253}},{{0xCDF46991,0xE908AE34,(-1),0x8DD589E8,0xD5754278,1,0x2391BE15,1},{(-8),(-1),0x59668C86,0,0x59668C86,(-1),(-8),0},{(-1),0,0xE908AE34,0x25DDBF1A,7,0x8DD589E8,0x1A1F9570,0x8D2902D4},{0x25DDBF1A,6,(-5),0xF8735943,7,0x6D4D43A6,0x17DA69ED,0}},{{(-1),1,0,0x8D2902D4,0x59668C86,0xCDF46991,0,0x18A95D68},{(-8),3,0xD1830F2B,0xCDF46991,0xF8735943,0,0x730A6A1D,7},{(-1),0x8DD589E8,0x8ACF152C,0x17DA69ED,0xFBF91089,0xF8735943,0xE7447E38,0xE7447E38},{0x3C289E41,0x730A6A1D,0,0,0x730A6A1D,0x3C289E41,0,0}}};
        uint8_t l_101 = 0x57;
        union U1 l_110 = {0x3.BB719Dp-98};
        struct S0 l_135[9][10] = {{{0x11},{1U},{1U},{0x8A},{0x6F},{0x11},{0x8A},{2U},{0x8A},{0x11}},{{0x6F},{1U},{0x85},{1U},{0x6F},{0x3A},{1U},{2U},{8U},{0x6F}},{{0x6F},{0x8A},{1U},{1U},{0x11},{0x11},{1U},{1U},{0x8A},{0x6F}},{{0x11},{1U},{1U},{0x8A},{0x6F},{0x11},{0x8A},{2U},{0x8A},{0x11}},{{0x6F},{1U},{0x85},{1U},{0x6F},{0x3A},{1U},{2U},{8U},{0x6F}},{{0x6F},{0x8A},{1U},{1U},{0x11},{0x11},{1U},{1U},{0x8A},{0x6F}},{{0x11},{1U},{1U},{0x8A},{0x6F},{0x11},{0x8A},{2U},{0x8A},{0x11}},{{0x6F},{1U},{0x85},{1U},{0x6F},{0x3A},{1U},{2U},{8U},{0x6F}},{{0x6F},{0x8A},{1U},{1U},{0x11},{0x11},{1U},{1U},{0x8A},{0x6F}}};
        int32_t l_185[5];
        uint32_t l_187[6] = {1U,4294967294U,1U,1U,4294967294U,1U};
        int i, j, k;
        for (i = 0; i < 2; i++)
            l_85[i] = (-1);
        for (i = 0; i < 1; i++)
            l_89[i] = &l_86;
        for (i = 0; i < 5; i++)
            l_185[i] = 0x6DD524B9;
        g_90 = func_81(l_85[0], l_86, l_86);
        /* statement id: 48 */
        assert (g_90 == 0);
        g_90 = func_81(((l_86 != (((safe_add_func_float_f_f((0x4.E48205p+24 != (g_44.f0 , p_78.f0)), (g_44.f0 <= __builtin_clz(l_93)))) == (((safe_sub_func_float_f_f((safe_add_func_float_f_f((((safe_div_func_float_f_f(((g_44 , l_100[0][3][6]) < 0x0.Bp-1), g_5)) >= 0x6.A90853p+36) <= g_44.f0), l_101)), (-0x1.9p+1))) >= g_55) <= g_5)) , (void*)0)) != g_5), &g_5, l_102);
    }
    return l_103;
    /* statement id: 170 */
    //assert (func_77_rv == &g_5);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_81(uint16_t  p_82, int32_t * p_83, int32_t * p_84)
{ /* block id: 45 */
    int32_t *l_88 = (void*)0;
    int32_t **l_87 = &l_88;
    (*l_87) = (void*)0;
    return p_84;
    /* statement id: 47 */
    //assert (func_81_rv == 0 || func_81_rv == &g_5 || (func_81_rv >= &l_100[0][0][0] && func_81_rv <= &l_100[2][3][7]));
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_44.f0, "g_44.f0", print_hash_value);
    transparent_crc(g_55, "g_55", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        transparent_crc_bytes(&g_222[i], sizeof(g_222[i]), "g_222[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_224.f0, "g_224.f0", print_hash_value);
    transparent_crc_bytes (&g_235.f0, sizeof(g_235.f0), "g_235.f0", print_hash_value);
    transparent_crc_bytes (&g_235.f1, sizeof(g_235.f1), "g_235.f1", print_hash_value);
    transparent_crc_bytes (&g_279.f0, sizeof(g_279.f0), "g_279.f0", print_hash_value);
    transparent_crc_bytes (&g_279.f1, sizeof(g_279.f1), "g_279.f1", print_hash_value);
    transparent_crc(g_445, "g_445", print_hash_value);
    transparent_crc(g_519, "g_519", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 138
   depth: 1, occurrence: 18
XXX total union variables: 7

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 205
   depth: 2, occurrence: 49
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 20, occurrence: 4
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 28, occurrence: 1

XXX total number of pointers: 129

XXX times a variable address is taken: 183
XXX times a pointer is dereferenced on RHS: 65
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 70
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 613

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 197
   level: 2, occurrence: 24
   level: 3, occurrence: 5
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 43
XXX number of pointers point to scalars: 63
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 35.7
XXX average alias set size: 1.37

XXX times a non-volatile is read: 617
XXX times a non-volatile is write: 249
XXX times a volatile is read: 41
XXX    times read thru a pointer: 20
XXX times a volatile is write: 14
XXX    times written thru a pointer: 11
XXX times a volatile is available for access: 218
XXX percentage of non-volatile access: 94

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 185
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 21
   depth: 2, occurrence: 19
   depth: 3, occurrence: 26
   depth: 4, occurrence: 41
   depth: 5, occurrence: 48

XXX percentage a fresh-made variable is used: 18.5
XXX percentage an existing variable is used: 81.5
********************* end of statistics **********************/

