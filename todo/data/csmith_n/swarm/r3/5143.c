/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      194264916
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   uint64_t  f1;
   uint64_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_28(void);
inline static union U0 * func_35(uint64_t  p_36, int32_t  p_37);
inline static int32_t * func_45(int32_t * p_46);
static int32_t * func_47(uint16_t  p_48, uint64_t  p_49, int32_t ** p_50, union U0  p_51);
inline static int16_t  func_76(uint32_t  p_77, uint32_t  p_78, union U0  p_79);
inline static int32_t * func_89(int16_t  p_90, int32_t * p_91, int16_t  p_92);
inline static int16_t  func_93(int32_t ** p_94, int32_t * p_95, int32_t ** p_96, int32_t  p_97, union U0 * p_98);
static int32_t * func_102(uint32_t  p_103);
inline static uint64_t  func_112(uint16_t  p_113, uint64_t  p_114, int64_t  p_115, int32_t * p_116, union U0 * p_117);
static int32_t * func_119(int64_t  p_120, uint32_t  p_121, int32_t ** p_122, union U0 * p_123);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_28(void)
{ /* block id: 36 */
    int32_t *l_30 = (void*)0;
    int32_t **l_29 = &l_30;
    int32_t l_31 = (-1L);
    (*l_29) = (void*)0;
    if ((l_31 >= (!(0xFAD5BEFAL & __builtin_ffsll(((uint16_t)0x30A9L << (uint16_t)l_31))))))
    { /* block id: 38 */
        int64_t l_38 = 0L;
        union U0 *l_622 = (void*)0;
        union U0 **l_621 = &l_622;
        (*l_621) = func_35(l_38, (0xDAB551FA4C821046LL && 0x120DD93BA6AED1D2LL));
    }
    else
    { /* block id: 369 */
        int32_t l_623 = 2L;
        return l_623;
    }
    return l_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_35(uint64_t  p_36, int32_t  p_37)
{ /* block id: 39 */
    union U0 l_57 = {0x18EB0BADL};
    union U0 *l_56 = &l_57;
    int32_t l_61 = 0xBEBB6F2BL;
    int32_t *l_60 = &l_61;
    int32_t *l_453 = &l_61;
    int32_t **l_452 = &l_453;
    union U0 ****l_477 = (void*)0;
    union U0 l_516 = {0UL};
    int32_t **l_518 = &l_453;
    int32_t l_551 = (-2L);
    union U0 *l_618 = &l_516;
    union U0 *l_619 = &l_516;
    union U0 *l_620 = (void*)0;
    for (p_37 = 14; (p_37 < 16); p_37 += 1)
    { /* block id: 42 */
        int32_t l_42 = 0x6C5051DDL;
        int32_t *l_41 = &l_42;
        int32_t **l_43 = (void*)0;
        int32_t **l_44 = &l_41;
        union U0 l_69 = {0x3A6825D8L};
        union U0 **l_472 = (void*)0;
        union U0 ***l_471 = &l_472;
        union U0 ****l_470 = &l_471;
        union U0 *****l_469 = &l_470;
        uint16_t l_473 = 65533UL;
        int32_t l_488 = 0x2E0E3DBFL;
        int64_t l_501 = (-1L);
        (*l_44) = l_41;
    }
    (**l_452) = 0xA661446CL;
    return l_620;
    /* statement id: 367 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_45(int32_t * p_46)
{ /* block id: 250 */
    int16_t l_426 = 9L;
    int32_t l_428 = (-8L);
    int32_t *l_427 = &l_428;
    (*p_46) = (l_426 >= l_426);
    return p_46;
    /* statement id: 252 */
    //assert (func_45_rv == &l_61);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_47(uint16_t  p_48, uint64_t  p_49, int32_t ** p_50, union U0  p_51)
{ /* block id: 44 */
    int32_t l_73 = 1L;
    for (p_49 = 0; (p_49 != 0); p_49 += 8)
    { /* block id: 47 */
        uint16_t l_72 = 1UL;
        (**p_50) = l_72;
        return (*p_50);
        /* statement id: 49 */
        //assert (func_47_rv == &l_61 || func_47_rv == &l_42);
    }
    if (l_73)
    { /* block id: 51 */
        uint32_t l_85 = 0x6CCC853DL;
        union U0 l_88 = {0x9B759721L};
        (**p_50) = (__builtin_clz((((int16_t)func_76(((+((uint16_t)((uint32_t)p_48 % (uint32_t)l_85) << (uint16_t)(l_85 ^ l_73))) == ((int16_t)1L - (int16_t)((*p_50) == (void*)0))), l_85, l_88) << (int16_t)6) & 6UL)) == l_73);
        (**p_50) = ((int32_t)1L + (int32_t)p_48);
    }
    else
    { /* block id: 245 */
        (*p_50) = (*p_50);
    }
    (**p_50) = (((int16_t)0xE8A7L + (int16_t)__builtin_bswap32(p_48)) < ((-5L) <= 0x96B21A96L));
    return (*p_50);
    /* statement id: 249 */
    //assert (func_47_rv == &l_61 || func_47_rv == &l_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_76(uint32_t  p_77, uint32_t  p_78, union U0  p_79)
{ /* block id: 52 */
    int32_t l_101 = 0x91E6DCF6L;
    int32_t *l_100 = &l_101;
    int32_t **l_99 = &l_100;
    union U0 l_169 = {0x46EC4B94L};
    union U0 *l_168 = &l_169;
    (*l_99) = func_89(func_93(l_99, func_102((*l_100)), &l_100, (p_77 | ((int16_t)(((int16_t)__builtin_ctzl((*l_100)) - (int16_t)((&l_100 != &l_100) || (**l_99))) | 5UL) - (int16_t)0x5FB1L)), l_168), (*l_99), (**l_99));
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_89(int16_t  p_90, int32_t * p_91, int16_t  p_92)
{ /* block id: 237 */
    int32_t **l_418 = (void*)0;
    int32_t l_421 = 0x3AA0D65FL;
    int32_t *l_420 = &l_421;
    int32_t **l_419 = &l_420;
    (*l_419) = p_91;
    /* statement id: 238 */
    //assert (l_420 == &l_101 || l_420 == &l_42);
    (**l_419) = (*p_91);
    return p_91;
    /* statement id: 240 */
    //assert (func_89_rv == &l_101 || func_89_rv == &l_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_93(int32_t ** p_94, int32_t * p_95, int32_t ** p_96, int32_t  p_97, union U0 * p_98)
{ /* block id: 71 */
    uint16_t l_170 = 0x39C9L;
    int32_t l_179 = 0xC6BEA79CL;
    int32_t *l_178 = &l_179;
    int32_t **l_177 = &l_178;
    union U0 l_181 = {4UL};
    union U0 *l_180 = &l_181;
    union U0 **l_182 = &l_180;
    int32_t l_219 = 0xD5BCDDAFL;
    union U0 ***l_269 = &l_182;
    int32_t l_286 = 6L;
    (**l_177) = ((1UL || (l_170 | ((uint16_t)p_97 >> (uint16_t)5))) == ((int64_t)l_170 % (int64_t)((int16_t)0x9D48L << (int16_t)(l_177 == &l_178))));
    (*l_182) = l_180;
    for (l_181.f0 = 28; (l_181.f0 < 37); l_181.f0 += 1)
    { /* block id: 76 */
        uint32_t l_189 = 4294967295UL;
        int32_t l_195 = 0L;
        union U0 *l_197 = &l_181;
        uint64_t l_236 = 18446744073709551606UL;
        union U0 ***l_265 = &l_182;
        union U0 ****l_318 = &l_265;
        union U0 *****l_317 = &l_318;
        int32_t **l_344 = &l_178;
        int32_t l_364 = (-10L);
        union U0 *l_415 = (void*)0;
    }
    return p_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_102(uint32_t  p_103)
{ /* block id: 53 */
    uint64_t l_118 = 0xE311B86553ECF384LL;
    union U0 l_131 = {18446744073709551615UL};
    union U0 *l_130 = &l_131;
    int32_t l_150 = (-7L);
    int32_t *l_149 = &l_150;
    int32_t **l_148 = &l_149;
    int16_t l_159 = (-10L);
    int64_t l_160 = 6L;
    int32_t *l_161 = &l_150;
    int32_t *l_162 = &l_150;
    int32_t *l_163 = (void*)0;
    for (p_103 = 0; (p_103 > 11); p_103 += 1)
    { /* block id: 56 */
        int32_t l_107 = 1L;
        int32_t *l_106 = &l_107;
        union U0 *l_135 = &l_131;
        uint64_t l_143 = 0x3C0C33ADB549FED5LL;
        int32_t *l_144 = (void*)0;
        int32_t *l_145 = &l_107;
        l_106 = (void*)0;
        /* statement id: 57 */
        assert (l_106 == 0);
        (*l_145) = ((uint16_t)((((uint32_t)p_103 - (uint32_t)((func_112(__builtin_bswap64(l_118), p_103, l_118, func_119(l_118, (((uint16_t)((0x8E34L == p_103) != ((uint16_t)((int32_t)p_103 + (int32_t)p_103) << (uint16_t)11)) << (uint16_t)p_103) != 4294967295UL), &l_106, l_130), l_135) && 0xE316ED2767F92971LL) || l_131.f0)) == p_103) ^ 4294967295UL) * (uint16_t)l_143);
        /* statement id: 66 */
        //assert (l_106 == dangling);
        if (l_131.f0)
            break;
    }
    (*l_149) = (l_131.f0 && ((int16_t)((void*)0 == l_148) - (int16_t)((int16_t)p_103 >> (int16_t)((**l_148) ^ (((int16_t)(((uint16_t)((uint16_t)((**l_148) < (l_159 | (**l_148))) % (uint16_t)(**l_148)) * (uint16_t)p_103) | (**l_148)) + (int16_t)(*l_149)) & l_160)))));
    return l_163;
    /* statement id: 70 */
    //assert (func_102_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_112(uint16_t  p_113, uint64_t  p_114, int64_t  p_115, int32_t * p_116, union U0 * p_117)
{ /* block id: 63 */
    uint32_t l_136 = 0UL;
    int32_t *l_139 = (void*)0;
    int32_t **l_142 = &l_139;
    (*l_142) = func_119(((l_136 & ((uint64_t)p_114 + (uint64_t)((((p_116 != l_139) >= p_115) == 0UL) || 1L))) | 0L), ((int16_t)((p_113 != 0xD1CB9B5B590B87A3LL) <= p_114) - (int16_t)p_113), &l_139, p_117);
    return p_114;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_119(int64_t  p_120, uint32_t  p_121, int32_t ** p_122, union U0 * p_123)
{ /* block id: 58 */
    int32_t l_133 = 5L;
    int32_t *l_132 = &l_133;
    int32_t *l_134 = (void*)0;
    (*p_122) = (void*)0;
    (*p_122) = l_132;
    /* statement id: 60 */
    //assert (l_106 == &l_133);
    (*p_122) = (*p_122);
    return l_134;
    /* statement id: 62 */
    //assert (l_106 == dangling);
    //assert (func_119_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 150
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 8, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 123

XXX times a variable address is taken: 120
XXX times a pointer is dereferenced on RHS: 138
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 48
XXX times a pointer is dereferenced on LHS: 103
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 26
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 440

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 309
   level: 2, occurrence: 133
   level: 3, occurrence: 1
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 47
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 36.6
XXX average alias set size: 1.59

XXX times a non-volatile is read: 796
XXX times a non-volatile is write: 275
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 41
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 11

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
********************* end of statistics **********************/

