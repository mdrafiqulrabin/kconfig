/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      661245552
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_29(void);
static int32_t * func_30(int64_t  p_31);
static float  func_40(int32_t * p_41, float  p_42, int32_t * p_43);
static float  func_46(uint32_t  p_47, uint32_t  p_48);
static int32_t * func_57(uint32_t  p_58, uint64_t  p_59, float * p_60, int16_t  p_61, uint64_t  p_62);
static float * func_64(int32_t * p_65);
static int32_t * func_66(int64_t  p_67, uint16_t  p_68, int16_t  p_69, float  p_70, uint32_t  p_71);
static uint16_t  func_78(uint64_t  p_79, uint32_t  p_80, float * p_81, float * p_82, uint32_t  p_83);
static int32_t * func_88(uint32_t  p_89, int32_t * p_90, int16_t  p_91, uint64_t  p_92, uint32_t  p_93);
static int32_t * func_95(float * p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_29(void)
{ /* block id: 36 */
    uint64_t l_32 = 0x6C218E9934B0B4EFLL;
    int32_t *l_341 = (void*)0;
    int32_t **l_342 = &l_341;
    int32_t l_343 = 0x2D552EA1L;
    l_341 = func_30(l_32);
    (*l_342) = (void*)0;
    return l_343;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(int64_t  p_31)
{ /* block id: 37 */
    int32_t l_34 = 0xE80D68F9L;
    int32_t *l_33 = &l_34;
    float l_339 = 0x3.4p+1;
    float *l_338 = &l_339;
    int32_t *l_340 = (void*)0;
    (*l_33) = p_31;
    for (l_34 = 22; (l_34 <= 11); l_34 = safe_sub_func_int64_t_s_s(l_34, 4))
    { /* block id: 41 */
        if (p_31)
            break;
    }
    (*l_338) = (safe_div_func_float_f_f((!0x5.28D9BAp+45), func_40(&l_34, (safe_add_func_float_f_f((func_46((*l_33), ((safe_sub_func_int16_t_s_s((*l_33), 0x7B83L)) || (p_31 || 0UL))) == p_31), (*l_33))), &l_34)));
    return l_340;
    /* statement id: 227 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_40(int32_t * p_41, float  p_42, int32_t * p_43)
{ /* block id: 47 */
    int32_t l_54 = 7L;
    int32_t *l_53 = &l_54;
    float l_56 = 0x2.B5BF7Cp+98;
    float *l_55 = &l_56;
    float *l_63 = &l_56;
    float *l_86 = &l_56;
    float *l_87 = &l_56;
    int32_t **l_337 = (void*)0;
    (*l_55) = (p_43 == l_53);
    (*l_53) = (*l_53);
    l_53 = func_57(((void*)0 != l_63), (*l_53), func_64(func_66((*l_53), (*l_53), ((safe_sub_func_uint16_t_u_u(__builtin_clzll((safe_div_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(func_78((*l_53), (safe_mul_func_int16_t_s_s(__builtin_popcountl((*l_53)), 1L)), l_86, l_87, (*l_53)), (*l_53))), (*l_53)))), (*l_53))) ^ (*l_53)), (*l_53), (*l_53))), (*l_53), (*l_53));
    /* statement id: 224 */
    assert (l_53 == 0);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_46(uint32_t  p_47, uint32_t  p_48)
{ /* block id: 44 */
    int32_t l_52 = 0x423637B3L;
    int32_t *l_51 = &l_52;
    l_51 = (void*)0;
    /* statement id: 45 */
    assert (l_51 == 0);
    return l_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_57(uint32_t  p_58, uint64_t  p_59, float * p_60, int16_t  p_61, uint64_t  p_62)
{ /* block id: 220 */
    float l_336 = 0x6.9841E6p-9;
    float *l_335 = &l_336;
    (*l_335) = (-0x9.Cp-1);
    (*l_335) = p_58;
    return p_60;
    /* statement id: 223 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_64(int32_t * p_65)
{ /* block id: 215 */
    uint16_t l_325 = 0xEAC2L;
    int32_t l_333 = 0xBC3C5A20L;
    int32_t *l_332 = &l_333;
    int32_t **l_334 = &l_332;
    (*l_332) = (safe_sub_func_float_f_f(0x1.Ap+1, __builtin_clz(((safe_lshift_func_int16_t_s_s(l_325, 3)) == ((safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((safe_mul_func_int16_t_s_s(l_325, l_325)), 15)), 0)) | (p_65 == l_332))))));
    (*l_332) = __builtin_popcountl((*l_332));
    (*l_334) = &l_333;
    return p_65;
    /* statement id: 219 */
    //assert (func_64_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_66(int64_t  p_67, uint16_t  p_68, int16_t  p_69, float  p_70, uint32_t  p_71)
{ /* block id: 211 */
    int32_t l_310 = 1L;
    int32_t *l_309 = &l_310;
    float l_317 = 0x2.Bp+1;
    float *l_316 = &l_317;
    float **l_315 = &l_316;
    float ***l_314 = &l_315;
    float ****l_318 = (void*)0;
    float ****l_319 = &l_314;
    int32_t *l_320 = (void*)0;
    (*l_309) = func_78(p_71, p_69, func_88(p_71, l_309, ((safe_add_func_int16_t_s_s((*l_309), (~p_71))) < (*l_309)), p_69, p_68), l_309, p_69);
    (*l_319) = l_314;
    return l_320;
    /* statement id: 214 */
    //assert (func_66_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_78(uint64_t  p_79, uint32_t  p_80, float * p_81, float * p_82, uint32_t  p_83)
{ /* block id: 50 */
    int32_t l_94 = 1L;
    float l_98 = 0xC.206F6Ep-34;
    float *l_97 = &l_98;
    int32_t l_134 = 0x9A1B0F83L;
    int32_t *l_182 = (void*)0;
    int32_t **l_181 = &l_182;
    float **l_221 = &l_97;
    float ***l_220 = &l_221;
    float ****l_219 = &l_220;
    float *****l_218 = &l_219;
    int32_t l_245 = (-1L);
lbl_267:
    (*l_181) = func_88(l_94, func_95(l_97), l_94, ((safe_div_func_int32_t_s_s(l_94, l_94)) || (l_134 && l_94)), l_134);
    /* statement id: 121 */
    assert (l_182 == &l_98);
    if ((**l_181))
    { /* block id: 122 */
        uint16_t l_183 = 0x71FAL;
        int16_t l_191 = 7L;
        float ***l_199 = (void*)0;
        float ****l_198 = &l_199;
        int32_t **l_211 = &l_182;
        float *l_277 = (void*)0;
        uint32_t l_278 = 0x7EA93C71L;
        int64_t l_282 = 1L;
        uint32_t l_289 = 0x45EB1093L;
        (*p_82) = (l_183 < (*p_82));
        (*l_181) = (*l_181);
        if (l_183)
        { /* block id: 125 */
            int16_t l_188 = (-10L);
            (*l_181) = func_88((safe_sub_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(l_188, 15)), (((void*)0 == p_81) <= __builtin_ffsll((safe_rshift_func_uint16_t_u_s(p_83, (**l_181))))))), (*l_181), l_191, l_188, l_188);
            (*p_81) = (**l_181);
            if (__builtin_popcountl(l_191))
            { /* block id: 128 */
                float **l_193 = &l_97;
                float ***l_192 = &l_193;
                int32_t l_202 = 0xF3C5D46AL;
                (*l_192) = &p_82;
                /* statement id: 129 */
                assert (l_193 == &p_82);
                for (l_183 = 0; (l_183 >= 41); l_183 = safe_add_func_int64_t_s_s(l_183, 6))
                { /* block id: 132 */
                    int32_t l_196 = 0L;
                    float ****l_197 = &l_192;
                    (*l_181) = p_81;
                    /* statement id: 133 */
                    //assert (l_182 == &l_56 || l_182 == &l_310);
                    if (l_196)
                        continue;
                    if (__builtin_clzl(p_79))
                    { /* block id: 135 */
                        l_198 = l_197;
                        /* statement id: 136 */
                        assert (l_198 == &l_192);
                        return p_79;
                    }
                    else
                    { /* block id: 138 */
                        (*l_181) = &l_196;
                        /* statement id: 139 */
                        assert (l_182 == &l_196);
                        if (p_79)
                            break;
                        //assert (l_182 == dangling);
                    }
                    /* facts after branching */
                    assert (l_182 == &l_196);
                    for (p_79 = 0; (p_79 >= 43); p_79 = safe_add_func_int16_t_s_s(p_79, 1))
                    { /* block id: 144 */
                        if (l_202)
                            break;
                        (**l_181) = (safe_sub_func_uint16_t_u_u(((l_196 == p_80) != p_80), p_83));
                        (**l_181) = (__builtin_parityl(p_80) > p_80);
                    }
                }
                /* facts after for loop */
                //assert (l_182 == dangling || l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
                (*l_181) = p_82;
                /* statement id: 150 */
                //assert (l_182 == &l_56 || l_182 == &l_310);
                for (p_79 = (-21); (p_79 >= 12); p_79 = safe_add_func_int64_t_s_s(p_79, 1))
                { /* block id: 153 */
                    (*l_181) = func_95((**l_192));
                    (*l_181) = p_81;
                }
            }
            else
            { /* block id: 157 */
                for (l_94 = 0; (l_94 <= 18); l_94 = safe_add_func_uint16_t_u_u(l_94, 1))
                { /* block id: 160 */
                    (*p_82) = l_188;
                    (*l_181) = func_95(p_81);
                    /* statement id: 162 */
                    //assert (l_182 == &l_56 || l_182 == &l_310);
                }
                /* facts after for loop */
                //assert (l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
                for (p_80 = 0; (p_80 != 27); p_80 = safe_add_func_uint32_t_u_u(p_80, 3))
                { /* block id: 166 */
                    int32_t ***l_212 = (void*)0;
                    int32_t ***l_213 = (void*)0;
                    int32_t ***l_214 = &l_181;
                    (*l_214) = l_211;
                }
                for (l_134 = 0; (l_134 >= (-3)); l_134--)
                { /* block id: 171 */
                    float *****l_217 = &l_198;
                    l_218 = l_217;
                    /* statement id: 172 */
                    assert (l_218 == &l_198);
                    (*l_211) = p_81;
                    /* statement id: 173 */
                    //assert (l_182 == &l_56 || l_182 == &l_310);
                }
                /* facts after for loop */
                assert (l_218 == &l_198 || l_218 == &l_219);
            }
            /* facts after branching */
            //assert (l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
            assert (l_218 == &l_198 || l_218 == &l_219);
        }
        else
        { /* block id: 176 */
            int32_t l_227 = 0L;
            uint32_t l_235 = 0xC1E94944L;
            int32_t l_252 = 1L;
            float *l_274 = &l_98;
            for (p_79 = 0; (p_79 < 44); p_79++)
            { /* block id: 179 */
                uint8_t l_246 = 0UL;
                if (p_80)
                { /* block id: 180 */
                    (**l_181) = 3L;
                }
                else
                { /* block id: 182 */
                    uint64_t l_226 = 9UL;
                    int32_t *l_228 = &l_227;
                    float ***l_266 = &l_221;
                    for (l_134 = 0; (l_134 >= 7); l_134 = safe_add_func_int32_t_s_s(l_134, 1))
                    { /* block id: 185 */
                        (*p_81) = l_226;
                        (*****l_218) = l_227;
                        (*l_211) = l_228;
                        /* statement id: 188 */
                        assert (l_182 == &l_227);
                    }
                    /* facts after for loop */
                    //assert (l_182 == &l_227 || l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
                    if ((0xCD5FL && (safe_div_func_uint64_t_u_u((safe_mod_func_int32_t_s_s(((safe_div_func_uint32_t_u_u((((p_79 <= l_227) & (l_235 <= (~(p_83 | ((safe_rshift_func_int16_t_s_s((**l_211), ((safe_mul_func_uint16_t_u_u((**l_181), (safe_div_func_int16_t_s_s((safe_add_func_int16_t_s_s(p_80, (((l_245 > 0x98E65B96L) && (*l_182)) != p_80))), (**l_211))))) <= (-4L)))) & l_246))))) == 18446744073709551615UL), 0x66428892L)) <= 0x3EC7EDD3L), (*l_228))), p_83))))
                    { /* block id: 190 */
                        float ***l_251 = &l_221;
                        int32_t l_259 = 0x50C62AA6L;
                        (**l_181) = 0x888CA29FL;
                        l_259 = (safe_rshift_func_uint16_t_u_u(((safe_div_func_uint64_t_u_u(((l_251 != (**l_218)) && l_252), p_79)) > (safe_sub_func_int64_t_s_s(l_252, l_246))), (((safe_lshift_func_uint16_t_u_s(((safe_div_func_uint16_t_u_u(((**l_211) != (l_259 | ((safe_sub_func_uint16_t_u_u(((safe_mod_func_int16_t_s_s(__builtin_popcountll(l_227), p_83)) != 0xBD7AL), l_259)) == p_79))), l_235)) | p_79), 9)) > (*l_228)) <= l_235)));
                        (*p_82) = (safe_sub_func_float_f_f((l_227 < ((**l_181) == (*p_82))), 0x7.1p-1));
                        (**l_218) = l_266;
                    }
                    else
                    { /* block id: 195 */
                        return p_83;
                    }
                    (**l_218) = l_266;
                }
                /* facts after branching */
                //assert (l_182 == &l_227 || l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
                if (l_94)
                    goto lbl_267;
                //assert (l_182 == dangling || l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
                if (l_246)
                    break;
                (*l_211) = func_88(p_83, p_81, p_80, ((safe_mul_func_uint16_t_u_u(p_83, p_80)) == (safe_div_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(((void*)0 == l_274), 11)), p_83))), (safe_rshift_func_int16_t_s_s(p_80, 7)));
                /* statement id: 202 */
                //assert (l_182 == &l_56 || l_182 == &l_310);
            }
            /* facts after for loop */
            //assert (l_182 == &l_227 || l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
            (*l_181) = func_95(func_88(l_252, p_81, (**l_211), l_278, ((safe_add_func_uint64_t_u_u(l_235, __builtin_bswap32(((~__builtin_parity((l_282 && (safe_add_func_uint64_t_u_u((safe_sub_func_uint64_t_u_u(p_83, (safe_sub_func_int64_t_s_s(l_227, l_289)))), 3L))))) != (**l_211))))) && p_83)));
            /* statement id: 204 */
            //assert (l_182 == &l_56 || l_182 == &l_310);
        }
        /* facts after branching */
        //assert (l_182 == &l_56 || l_182 == &l_98 || l_182 == &l_310);
        assert (l_218 == &l_198 || l_218 == &l_219);
        return p_80;
    }
    else
    { /* block id: 207 */
        uint8_t l_292 = 0x2FL;
        (*l_97) = (safe_div_func_float_f_f((*l_182), ((l_292 < (0x1.5p-1 >= (__builtin_ctz((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((__builtin_ia32_crc32qi((safe_sub_func_int16_t_s_s(p_83, p_79)), l_292) ^ ((safe_add_func_uint32_t_u_u(((((((safe_mul_func_int16_t_s_s(l_292, (safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((safe_add_func_int16_t_s_s((*l_182), p_80)), (*l_182))), p_83)))) > 0xD84F3E2910136EA5LL) <= l_292) > p_83) != p_80) != (*l_182)), 3L)) && p_80)), 2)), 0x9ED5L))) >= (*p_81)))) <= (*p_81))));
    }
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads : l_56 l_310
 * writes: l_56 l_310
 */
static int32_t * func_88(uint32_t  p_89, int32_t * p_90, int16_t  p_91, uint64_t  p_92, uint32_t  p_93)
{ /* block id: 90 */
    int32_t l_135 = 0L;
    float l_139 = 0x0.1463D9p+15;
    float *l_138 = &l_139;
    int32_t *l_180 = &l_135;
    (*p_90) = (0xEB2A14D5L && l_135);
    for (p_89 = 12; (p_89 >= 5); p_89--)
    { /* block id: 94 */
        int32_t *l_141 = &l_135;
        int32_t **l_140 = &l_141;
        (*l_140) = func_95(l_138);
        /* statement id: 95 */
        assert (l_141 == &l_139);
        if ((**l_140))
            break;
    }
    if ((safe_mod_func_int64_t_s_s(0x4FDEA94120B1A556LL, p_92)))
    { /* block id: 98 */
        uint32_t l_146 = 0xB7A17131L;
        float *l_151 = &l_139;
        int32_t **l_161 = (void*)0;
        int32_t *l_163 = &l_135;
        int32_t **l_162 = &l_163;
        (*l_138) = 0x0.A173F2p+81;
        (*p_90) = (((p_92 & l_135) != 1UL) ^ l_135);
        if ((safe_mod_func_int64_t_s_s(l_146, p_92)))
        { /* block id: 101 */
            int32_t *l_148 = &l_135;
            int32_t **l_147 = &l_148;
            (*l_147) = p_90;
            /* statement id: 102 */
            //assert (l_148 == &l_98 || l_148 == &l_56 || l_148 == &l_310);
            l_135 = (safe_lshift_func_uint16_t_u_u(0xE46AL, 14));
        }
        else
        { /* block id: 104 */
            int32_t *l_153 = &l_135;
            int32_t **l_152 = &l_153;
            (*l_152) = func_95(l_151);
            /* statement id: 105 */
            assert (l_153 == &l_139);
            for (l_135 = 6; (l_135 < 8); l_135 = safe_add_func_uint32_t_u_u(l_135, 1))
            { /* block id: 108 */
                int32_t l_156 = 7L;
                (*l_152) = func_95(l_153);
                (*l_151) = (func_46(l_135, (l_156 < l_156)) > (safe_sub_func_float_f_f((safe_mul_func_float_f_f(l_156, (-0x8.0p-1))), (0x0.Cp-1 < p_91))));
                (**l_152) = (p_90 != (void*)0);
            }
        }
        (*l_162) = &l_135;
    }
    else
    { /* block id: 115 */
        uint16_t l_170 = 3UL;
        int32_t l_175 = 0x8CB29726L;
        float *l_176 = &l_139;
        int32_t **l_177 = (void*)0;
        int32_t *l_179 = &l_175;
        int32_t **l_178 = &l_179;
        l_175 = (safe_mul_func_uint16_t_u_u(((p_93 != 1L) >= (safe_rshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s((p_89 != (*p_90)), ((((0xD7DBL | (((-8L) <= l_170) || (safe_rshift_func_int16_t_s_u((safe_mul_func_int16_t_s_s(((p_92 ^ (-1L)) || l_170), 65535UL)), l_170)))) | (*p_90)) && p_91) && p_93))), l_135))), p_92));
        (*l_178) = func_95(l_176);
        /* statement id: 117 */
        assert (l_179 == &l_139);
        return p_90;
        /* statement id: 118 */
        //assert (func_88_rv == &l_98 || func_88_rv == &l_56 || func_88_rv == &l_310);
    }
    return p_90;
    /* statement id: 120 */
    //assert (func_88_rv == &l_98 || func_88_rv == &l_56 || func_88_rv == &l_310);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_56 l_310
 */
static int32_t * func_95(float * p_96)
{ /* block id: 51 */
    int32_t l_101 = 0L;
    int32_t l_131 = 1L;
    int32_t *l_130 = &l_131;
    if ((safe_add_func_int32_t_s_s((l_101 < (safe_rshift_func_uint16_t_u_s((((((l_101 <= 0x172ABF77L) | 0x5672L) > ((safe_mod_func_uint64_t_u_u(((l_101 < l_101) <= (l_101 != (safe_add_func_uint16_t_u_u(((!l_101) <= __builtin_popcountll(l_101)), 0UL)))), l_101)) && l_101)) & l_101) ^ 0x5B7DL), l_101))), 1L)))
    { /* block id: 52 */
        uint32_t l_111 = 0x02220C99L;
        int32_t l_124 = (-9L);
        int32_t *l_123 = &l_124;
        for (l_101 = (-27); (l_101 == 14); l_101++)
        { /* block id: 55 */
            int32_t l_113 = 1L;
            int32_t *l_112 = &l_113;
            (*p_96) = 0x1.03168Fp-69;
            (*l_112) = l_111;
        }
        for (l_101 = 0; (l_101 != 14); l_101 = safe_add_func_int64_t_s_s(l_101, 7))
        { /* block id: 61 */
            int32_t l_119 = 0x2962DE1BL;
            int32_t *l_118 = &l_119;
            int32_t *l_120 = &l_119;
            for (l_111 = (-27); (l_111 < 3); l_111++)
            { /* block id: 64 */
                int32_t **l_121 = &l_120;
                l_118 = (void*)0;
                /* statement id: 65 */
                assert (l_118 == 0);
                if (((void*)0 != l_120))
                { /* block id: 66 */
                    int32_t ***l_122 = &l_121;
                    (*l_122) = l_121;
                }
                else
                { /* block id: 68 */
                    return p_96;
                    /* statement id: 69 */
                    //assert (func_95_rv == &l_98 || func_95_rv == &l_139 || func_95_rv == &l_56 || func_95_rv == &l_310);
                }
                (*l_121) = p_96;
                /* statement id: 71 */
                //assert (l_120 == &l_98 || l_120 == &l_139 || l_120 == &l_56 || l_120 == &l_310);
            }
            /* facts after for loop */
            assert (l_118 == 0 || l_118 == &l_119);
            //assert (l_120 == &l_98 || l_120 == &l_119 || l_120 == &l_139 || l_120 == &l_56 || l_120 == &l_310);
        }
        for (l_101 = 25; (l_101 == (-22)); --l_101)
        { /* block id: 76 */
            l_123 = &l_124;
        }
    }
    else
    { /* block id: 79 */
        for (l_101 = 0; (l_101 > (-26)); --l_101)
        { /* block id: 82 */
            uint32_t l_129 = 0x9C2D96A1L;
            (*p_96) = l_129;
            (*l_130) = (l_130 != (void*)0);
        }
        return p_96;
        /* statement id: 86 */
        //assert (func_95_rv == &l_98 || func_95_rv == &l_139 || func_95_rv == &l_56 || func_95_rv == &l_310);
    }
    (*l_130) = __builtin_ctz((*l_130));
    return p_96;
    /* statement id: 89 */
    //assert (func_95_rv == &l_98 || func_95_rv == &l_139 || func_95_rv == &l_56 || func_95_rv == &l_310);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 69
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 131
   depth: 2, occurrence: 36
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 81

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 50
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 13
XXX times a pointer is dereferenced on LHS: 58
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 7
   depth: 3, occurrence: 0
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 113

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 353
   level: 2, occurrence: 71
   level: 3, occurrence: 1
   level: 4, occurrence: 0
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 33
XXX number of pointers point to scalars: 48
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.7
XXX average alias set size: 1.36

XXX times a non-volatile is read: 357
XXX times a non-volatile is write: 153
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 117
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 20
   depth: 2, occurrence: 15
   depth: 3, occurrence: 17
   depth: 4, occurrence: 17
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
********************* end of statistics **********************/

