/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      4055159930
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const float  f0;
   uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint8_t g_4 = 0x32;
static const int32_t g_38 = 0xC829ED89;
static const int32_t *g_37 = &g_38;
static uint8_t g_39 = 6U;
static int32_t g_79 = 0xF2BBA2D3;
static int32_t *g_78 = &g_79;
static float g_100 = (-0x1.8p+1);
static float g_102 = 0x3.7A89A4p+69;
static uint32_t g_138 = 4294967288U;
static int16_t g_153 = 1;
static int16_t *g_152 = &g_153;
static uint32_t g_156 = 0xBF2F7726;
static float *g_184 = &g_102;
static float **g_183 = &g_184;
static struct S0 g_188 = {0xD.2AE737p+71,3U};
static struct S0 g_200 = {0x0.1p+1,65533U};
static struct S0 *g_199 = &g_200;
static float g_203 = 0x8.337B5Bp+25;
static int32_t g_233 = 1;
static int32_t *g_232 = &g_233;
static struct S0 g_249 = {0x3.2p-1,65526U};
static uint16_t g_276 = 0x3327;
static float g_281 = 0x8.507D8Cp-15;
static volatile float ****g_284 = (void*)0;
static uint32_t *g_319 = (void*)0;
static int16_t g_341 = 0x6E64;
static int16_t **g_374 = (void*)0;
static int16_t ***g_373 = &g_374;
static int16_t g_401 = 0x63A0;
static struct S0 g_406 = {0x5.AFFD95p+8,65526U};
static int32_t g_434 = 1;
static const volatile float g_452 = 0x0.DD5242p-72;/* VOLATILE GLOBAL g_452 */
static uint32_t g_490 = 1U;
static volatile int32_t g_498 = 4;/* VOLATILE GLOBAL g_498 */
static volatile int32_t *g_497 = &g_498;
static volatile int32_t **g_496 = &g_497;
static volatile int32_t ***g_495 = &g_496;
static const uint32_t *g_504 = &g_138;
static const uint32_t **g_503 = &g_504;
static uint16_t g_545 = 0xD41C;
static int32_t g_554 = 0;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_30(void);
inline static int32_t * func_33(const int32_t * p_34, float  p_35, float  p_36);
static int32_t  func_44(uint32_t  p_45);
inline static int32_t  func_46(int16_t  p_47, int16_t  p_48, uint8_t  p_49);
static int16_t  func_54(int32_t  p_55, int32_t * p_56, const int32_t * p_57);
inline static int16_t  func_58(int32_t * p_59, struct S0  p_60, const int32_t * p_61, struct S0  p_62, int32_t  p_63);
static int32_t * func_64(int32_t  p_65, int32_t * p_66, uint32_t  p_67, uint16_t  p_68, int32_t * p_69);
inline static int32_t  func_72(int32_t  p_73, int32_t  p_74, int32_t * p_75, int32_t * p_76, uint32_t  p_77);
inline static int32_t * func_82(int32_t  p_83, int32_t * p_84, int32_t * p_85);
static int32_t * func_91(int16_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_183 g_184
 * writes: g_4 g_102
 */
inline static int32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_43 = 0;
    int32_t l_257 = (-10);
    struct S0 l_405 = {0x0.Ap-1,65528U};
    for (g_4 = (-13); (g_4 != 17); ++g_4)
    { /* block id: 39 */
        uint8_t l_42 = 250U;
        int32_t l_256 = 0xCED4DE4F;
        int32_t *l_433 = &g_434;
        uint32_t *l_520 = &g_490;
        int32_t **l_636 = &g_78;
        int32_t **l_637 = &g_232;
    }
    (**g_183) = (l_257 < (-0x1.2p-1));
    return l_405.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_200.f1 g_152 g_153 g_79
 * writes: g_200.f1 g_100 g_102
 */
inline static int32_t * func_33(const int32_t * p_34, float  p_35, float  p_36)
{ /* block id: 409 */
    int32_t *l_559 = &g_554;
    int32_t **l_560 = &l_559;
    (*l_560) = l_559;
    for (g_200.f1 = 0; (g_200.f1 < 33); g_200.f1 = safe_add_func_uint32_t_u_u(g_200.f1, 6))
    { /* block id: 413 */
        int16_t **l_577 = &g_152;
        uint32_t **l_594 = &g_319;
        uint32_t ***l_593 = &l_594;
        uint32_t ****l_592 = &l_593;
        uint32_t ****l_601 = &l_593;
        int32_t l_606 = (-2);
        float l_630 = 0x6.ED448Ep-59;
    }
    (*l_560) = func_91((*g_152));
    return &g_554;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_4 g_183 g_184 g_102 g_232 g_233 g_496 g_497 g_554 g_434 g_37 g_38
 * writes: g_79 g_249.f1 g_490 g_203 g_102 g_545 g_497 g_434
 */
static int32_t  func_44(uint32_t  p_45)
{ /* block id: 369 */
    float l_527 = 0x5.D0FBAFp-25;
    int32_t l_535 = 0xC008A783;
    const int32_t **l_550 = &g_37;
    const int32_t ***l_549 = &l_550;
    int32_t l_553 = 0x1DD35ECE;
    for (g_79 = 0; (g_79 != (-8)); g_79 = safe_sub_func_uint32_t_u_u(g_79, 1))
    { /* block id: 372 */
        uint32_t l_536 = 0x09F09360;
        if (p_45)
            break;
        for (g_249.f1 = 28; (g_249.f1 != 49); ++g_249.f1)
        { /* block id: 376 */
            uint32_t *l_525 = &g_490;
            float ***l_531 = &g_183;
            float ****l_530 = &l_531;
            float *l_537 = &g_203;
            int32_t l_538 = 1;
            uint32_t *l_544 = &l_536;
            (*g_184) = ((__builtin_parityl(((*l_525) = 7U)) < ((!((**g_183) > l_527)) <= ((safe_add_func_float_f_f(p_45, ((void*)0 != l_530))) <= 0x1.Cp-1))) < ((-(((*l_537) = (l_536 = (safe_div_func_float_f_f(((*g_184) <= (-0x1.7p+1)), l_535)))) < p_45)) != l_538));
            l_538 = (safe_sub_func_int16_t_s_s((safe_add_func_uint32_t_u_u((!(((*g_232) ^ (p_45 <= __builtin_bswap64((l_538 && (((*l_544) = ((-1) < 0x6A90D4DF)) && (g_545 = p_45)))))) == l_538)), 0x37A2098E)), (-1)));
        }
        for (g_490 = (-9); (g_490 >= 37); g_490++)
        { /* block id: 387 */
            const uint32_t **l_551 = &g_504;
            (*g_496) = (*g_496);
            (*g_496) = (void*)0;
            if ((~((void*)0 != l_549)))
            { /* block id: 390 */
                return p_45;
            }
            else
            { /* block id: 392 */
                const uint32_t ***l_552 = &l_551;
                (*l_552) = l_551;
                (**g_183) = (**g_183);
                if (l_553)
                    break;
            }
            return g_554;
        }
    }
    for (g_434 = (-3); (g_434 < (-17)); g_434--)
    { /* block id: 402 */
        float l_557 = 0x8.AD60F1p-81;
        uint32_t *l_558 = &g_138;
        l_557 = __builtin_bswap32((**l_550));
        (*g_496) = (void*)0;
        (*g_184) = (l_558 == (void*)0);
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_37 g_38 g_232 g_233 g_39 g_156 g_184 g_496 g_497 g_495 g_503 g_504 g_138 g_498
 * writes: g_79 g_78 g_232 g_233 g_156 g_102 g_497 g_503 g_406.f1 g_100 g_203
 */
inline static int32_t  func_46(int16_t  p_47, int16_t  p_48, uint8_t  p_49)
{ /* block id: 327 */
    int32_t *l_441 = &g_79;
    const struct S0 *l_447 = &g_188;
    const struct S0 **l_446 = &l_447;
    int32_t l_464 = 4;
    int16_t ****l_467 = &g_373;
    int16_t ****l_470 = &g_373;
    uint32_t **l_477 = &g_319;
    int32_t **l_481 = (void*)0;
    int32_t **l_482 = &g_78;
    const int32_t **l_492 = &g_37;
    const int32_t ***l_491 = &l_492;
    for (g_79 = 0; (g_79 < (-14)); g_79--)
    { /* block id: 330 */
        uint32_t l_443 = 0xEED81015;
        for (p_49 = 0; (p_49 >= 10); p_49++)
        { /* block id: 333 */
            int32_t **l_442 = &g_78;
            (*l_442) = l_441;
        }
        return l_443;
    }
    if ((safe_mod_func_int16_t_s_s(((void*)0 == l_446), 0xC0E4)))
    { /* block id: 338 */
        int16_t l_457 = 0;
        int32_t *l_460 = &g_233;
        int32_t **l_461 = &g_232;
        (*l_441) = (safe_sub_func_uint16_t_u_u((0xD624D23C != (*g_37)), p_47));
        (*l_441) = (((safe_rshift_func_uint16_t_u_u(p_47, 7)) > p_49) > __builtin_clzl(((*g_232) >= (safe_lshift_func_int16_t_s_s((((p_49 || g_39) == (safe_sub_func_int16_t_s_s(l_457, 1U))) || (safe_div_func_int16_t_s_s((__builtin_parityll((l_457 && p_47)) <= 0xF754496E), (*l_441)))), p_48)))));
        (*l_461) = l_460;
    }
    else
    { /* block id: 342 */
        int16_t *****l_468 = (void*)0;
        int16_t *****l_469 = &l_467;
        uint32_t **l_478 = &g_319;
        uint32_t *l_479 = &g_156;
        int32_t l_480 = 0xB76A64C9;
        l_480 = (safe_rshift_func_uint16_t_u_s((((((*l_441) = p_47) | ((*g_232) = 0)) && (l_464 == 1U)) | (safe_lshift_func_uint16_t_u_s((((*l_469) = l_467) == l_470), (safe_rshift_func_int16_t_s_s((safe_sub_func_int16_t_s_s(((p_48 = (-1)) > (safe_add_func_uint32_t_u_u(((*l_479) = (l_477 == l_478)), 0x8CCA9902))), 65535U)), p_49))))), l_480));
    }
    (*l_482) = &g_233;
    for (g_156 = 0; (g_156 >= 18); g_156 = safe_add_func_uint16_t_u_u(g_156, 4))
    { /* block id: 353 */
        int32_t *l_485 = &g_233;
        uint32_t *l_489 = &g_490;
        const int32_t ****l_493 = (void*)0;
        const int32_t ****l_494 = &l_491;
        const uint32_t ***l_505 = (void*)0;
        const uint32_t ***l_506 = &g_503;
        uint16_t *l_509 = (void*)0;
        uint16_t *l_510 = &g_406.f1;
        uint32_t ***l_513 = &l_477;
        uint32_t ***l_514 = &l_477;
        float **l_515 = &g_184;
        float *l_516 = &g_100;
        float *l_517 = &g_203;
        (*g_184) = (*l_441);
        (**g_495) = (*g_496);
        (*l_482) = func_82(((safe_add_func_uint16_t_u_u((((void*)0 != l_489) && ((safe_add_func_uint16_t_u_u((((*l_506) = g_503) == (void*)0), (safe_rshift_func_uint16_t_u_u(((*l_510) = p_47), 3)))) != ((*g_504) > ((safe_sub_func_uint32_t_u_u((*g_504), (p_48 && (*l_485)))) == (*g_497))))), p_48)) & p_49), &g_233, l_485);
        (*l_485) = (((((l_514 = l_513) == (void*)0) == ((*g_184) = (l_515 == (void*)0))) < (__builtin_popcountl(p_48) == ((*l_517) = ((*l_516) = p_49)))) <= (safe_sub_func_float_f_f(0xA.24430Bp+13, 0xC.9607C9p+59)));
    }
    return (*g_37);
}


/* ------------------------------------------ */
/* 
 * reads : g_233
 * writes: g_232
 */
static int16_t  func_54(int32_t  p_55, int32_t * p_56, const int32_t * p_57)
{ /* block id: 324 */
    int32_t *l_435 = &g_233;
    int32_t **l_436 = &g_232;
    (*l_436) = l_435;
    return (*l_435);
}


/* ------------------------------------------ */
/* 
 * reads : g_37 g_38 g_4 g_200.f1 g_79 g_233 g_152 g_153
 * writes: g_319 g_406.f1 g_79 g_233
 */
inline static int16_t  func_58(int32_t * p_59, struct S0  p_60, const int32_t * p_61, struct S0  p_62, int32_t  p_63)
{ /* block id: 311 */
    uint8_t l_407 = 251U;
    int32_t **l_411 = &g_78;
    int32_t ***l_410 = &l_411;
    int32_t **l_413 = &g_78;
    int32_t ***l_412 = &l_413;
    uint8_t l_414 = 5U;
    int16_t ****l_419 = (void*)0;
    uint16_t *l_420 = &g_406.f1;
    const int32_t *l_422 = &g_38;
    const int32_t **l_421 = &l_422;
    uint32_t **l_425 = &g_319;
    uint16_t l_428 = 65529U;
    (*l_421) = p_61;
    (*p_59) = (((*g_37) && (safe_div_func_int16_t_s_s(((((*l_425) = p_59) == &g_138) || 0x0263), (__builtin_clz((l_428 = (**l_421))) || ((((*l_420) = p_62.f1) <= g_200.f1) != (*p_59)))))) ^ (*g_152));
    return (*g_152);
}


/* ------------------------------------------ */
/* 
 * reads : g_152 g_153 g_200.f1 g_4 g_232 g_79 g_184 g_233 g_78 g_183 g_102 g_284 g_276 g_37 g_38 g_138 g_373
 * writes: g_233 g_102 g_100 g_78 g_203 g_276 g_281 g_79 g_284 g_249.f1 g_153 g_319 g_232 g_199 g_341 g_138 g_373 g_200.f1 g_401
 */
static int32_t * func_64(int32_t  p_65, int32_t * p_66, uint32_t  p_67, uint16_t  p_68, int32_t * p_69)
{ /* block id: 192 */
    struct S0 **l_258 = (void*)0;
    int32_t l_270 = (-1);
    int32_t l_282 = 0xB0956CD0;
    uint32_t l_292 = 0xCC336A52;
    int32_t *l_316 = &l_282;
    int32_t **l_324 = &l_316;
    int32_t ***l_323 = &l_324;
    int16_t *l_368 = &g_341;
    int32_t *l_372 = (void*)0;
    int32_t l_376 = (-3);
    int16_t *l_399 = (void*)0;
    int16_t *l_400 = &g_401;
    if (((l_258 == &g_199) >= (*g_152)))
    { /* block id: 193 */
        uint32_t l_259 = 4294967295U;
        int32_t *l_260 = &g_79;
        int32_t **l_261 = &l_260;
        (*l_261) = func_82(((*g_232) = (l_259 ^ __builtin_ffs((p_68 == g_200.f1)))), l_260, l_260);
        for (p_67 = 19; (p_67 <= 56); p_67++)
        { /* block id: 198 */
            g_78 = &p_65;
            (*l_261) = &p_65;
        }
    }
    else
    { /* block id: 202 */
        uint32_t l_264 = 5U;
        int32_t **l_265 = &g_78;
        float *l_271 = &g_203;
        float *l_277 = &g_100;
        float *l_280 = &g_281;
        int16_t *l_366 = (void*)0;
        (*l_265) = func_91(l_264);
        l_282 = (((safe_sub_func_float_f_f(((*g_184) = 0x4.D4A7C3p+80), (safe_sub_func_float_f_f((((*l_271) = l_270) > (g_276 = ((safe_add_func_float_f_f(__builtin_bswap32(g_233), (**l_265))) < (safe_add_func_float_f_f(0x0.Cp-1, l_270))))), ((*l_277) = l_270))))) != ((*l_280) = (safe_sub_func_float_f_f((p_68 == p_68), 0x0.6p-1)))) != 0x8.Bp-1);
        if (((void*)0 == &g_233))
        { /* block id: 210 */
            int32_t l_283 = 0xC68DCB92;
            volatile float *****l_285 = &g_284;
            (**g_183) = ((*l_277) = l_283);
            (*g_78) = (*p_66);
            (*l_285) = g_284;
            (*l_265) = func_91((p_68 > g_4));
        }
        else
        { /* block id: 216 */
            uint32_t *l_320 = &g_138;
            int32_t ***l_325 = &l_265;
            int32_t *l_394 = &l_376;
            if ((*g_232))
            { /* block id: 217 */
                struct S0 *l_328 = &g_188;
                int32_t l_339 = 0x01380ACB;
                for (g_79 = 0; (g_79 == (-30)); g_79 = safe_sub_func_int16_t_s_s(g_79, 4))
                { /* block id: 220 */
                    int32_t l_303 = 0x0F00DC92;
                    uint16_t *l_304 = &g_249.f1;
                    uint16_t *l_305 = &g_276;
                    int32_t l_326 = 1;
                    struct S0 **l_329 = &g_199;
                    (*p_66) = (safe_sub_func_int16_t_s_s(((p_67 && (safe_add_func_int16_t_s_s((l_292 == (~(*g_152))), ((~p_68) | 5)))) > (__builtin_parityll(((**l_265) || ((*p_66) = ((*p_69) = (safe_rshift_func_uint16_t_u_u((safe_add_func_int32_t_s_s((*p_66), (safe_lshift_func_int16_t_s_s(((safe_div_func_int16_t_s_s((*g_152), ((*l_305) = ((*l_304) = (l_303 = g_276))))) >= 0x24AF), 12)))), (**l_265))))))) & (*g_78))), 0xDA5D));
                    if ((safe_div_func_int16_t_s_s(p_65, (safe_add_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(p_65, 11)), ((*g_152) = ((((*g_152) | 0x6CEE) < (4294967286U > p_65)) && (((*l_305) = ((*l_304) = (~p_67))) & __builtin_ffs((*g_78))))))))))
                    { /* block id: 230 */
                        int32_t *l_315 = &g_233;
                        uint32_t *l_318 = &g_156;
                        uint32_t **l_317 = &l_318;
                        (*g_232) = 0xC5A0F633;
                        (*g_232) = (-1);
                        l_316 = l_315;
                        (*l_315) = ((g_319 = ((*l_317) = &g_138)) == l_320);
                    }
                    else
                    { /* block id: 237 */
                        int32_t **l_327 = &g_232;
                        (*l_265) = &g_79;
                        l_326 = (safe_sub_func_float_f_f((*l_316), ((*g_184) = ((p_65 != 0xB.7CE13Fp-0) < (l_323 == l_325)))));
                        (*l_327) = ((**l_323) = ((*l_265) = &p_65));
                    }
                    (*l_329) = l_328;
                }
                for (g_153 = 0; (g_153 > (-2)); g_153--)
                { /* block id: 249 */
                    int16_t *l_340 = &g_341;
                    int32_t l_365 = 0xEA91A948;
                    if (((0x6E75 != ((*l_340) = (safe_add_func_int32_t_s_s((safe_mod_func_uint32_t_u_u(p_65, (**l_265))), (((safe_lshift_func_int16_t_s_u((safe_unary_minus_func_int32_t_s(0xDF0A7BC6)), p_65)) == ((__builtin_bswap32(p_65) <= p_68) <= l_339)) < (*g_37)))))) || 4294967295U))
                    { /* block id: 251 */
                        return &g_233;
                    }
                    else
                    { /* block id: 253 */
                        const int32_t *l_343 = &l_339;
                        const int32_t **l_342 = &l_343;
                        (**g_183) = 0x1.4p+1;
                        (*l_342) = &g_38;
                        (*g_78) = (safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_s(((*l_340) = 0x106F), (*g_152))), ((__builtin_popcountll((safe_div_func_int32_t_s_s((((**l_324) = (((*p_66) & (*p_69)) & (((-1) | (*g_37)) == p_68))) == (*p_66)), ((*l_320) = 0x64EF6050)))) || g_233) && g_200.f1)));
                    }
                    for (g_276 = (-16); (g_276 <= 49); ++g_276)
                    { /* block id: 263 */
                        float ****l_352 = (void*)0;
                        float *****l_353 = (void*)0;
                        float *****l_354 = (void*)0;
                        float *****l_355 = &l_352;
                        uint16_t *l_358 = &g_249.f1;
                        int16_t **l_367 = &l_340;
                        (*l_355) = l_352;
                        (*g_184) = ((((safe_sub_func_float_f_f(__builtin_popcountll((((*l_358) = 0xDD63) >= (!p_67))), (safe_div_func_float_f_f(0x0.3p-1, (*g_184))))) <= (*g_184)) <= (-(g_203 = ((safe_add_func_float_f_f(((l_365 <= l_365) != (**l_265)), l_339)) < (**g_183))))) >= (*l_316));
                        (**l_325) = (**l_323);
                        (*l_324) = func_82((((*l_367) = l_366) != l_368), &g_79, &g_233);
                    }
                    if ((***l_325))
                        break;
                    (*g_232) = (*p_66);
                }
            }
            else
            { /* block id: 275 */
                uint16_t l_387 = 0x42A3;
                for (g_138 = (-13); (g_138 == 20); ++g_138)
                { /* block id: 278 */
                    int32_t *l_371 = (void*)0;
                    l_372 = func_82((*g_232), l_371, &g_233);
                    return &g_79;
                }
                if (__builtin_bswap32((***l_325)))
                { /* block id: 282 */
                    int16_t ****l_375 = &g_373;
                    (*l_375) = g_373;
                    (*l_265) = &p_65;
                    (**l_323) = func_91(l_376);
                }
                else
                { /* block id: 286 */
                    float l_390 = 0x4.9FF855p-51;
                    int32_t l_391 = (-4);
                    for (g_200.f1 = 22; (g_200.f1 >= 57); g_200.f1++)
                    { /* block id: 289 */
                        (*l_265) = func_82((p_66 == (*g_183)), (*l_265), (g_232 = &p_65));
                        p_66 = func_91(p_68);
                    }
                    (*l_265) = func_82((*g_232), ((**l_325) = func_91((safe_lshift_func_int16_t_s_u((safe_add_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(((g_233 <= __builtin_bswap32((**l_265))) || ((*l_320) = l_387)), (safe_div_func_int16_t_s_s(p_65, (***l_325))))) <= l_391), (safe_div_func_int16_t_s_s(((*g_152) = ((**l_265) | p_65)), g_276)))), g_79)), 9)))), (**l_323));
                    (*l_324) = (**l_323);
                    (*l_324) = func_82((**l_324), &g_79, ((**l_325) = func_82((*g_37), l_394, &g_79)));
                }
            }
        }
        (**l_265) = (-1);
    }
    (*p_66) = ((safe_add_func_int32_t_s_s((p_67 && (((*g_152) = p_65) == (*l_316))), (***l_323))) >= (((*l_400) = ((*l_368) = (safe_add_func_int16_t_s_s(__builtin_parityll(g_200.f1), (*l_316))))) | ((!(safe_lshift_func_int16_t_s_s(0, 3))) | (*l_316))));
    return &g_233;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_4 g_38 g_39 g_78 g_37 g_138 g_152 g_183 g_184 g_102 g_153 g_156 g_232 g_554
 * writes: g_79 g_100 g_102 g_78 g_138 g_153 g_156 g_199 g_233
 */
inline static int32_t  func_72(int32_t  p_73, int32_t  p_74, int32_t * p_75, int32_t * p_76, uint32_t  p_77)
{ /* block id: 40 */
    int32_t *l_86 = &g_79;
    int16_t l_93 = 0x3A0D;
    float l_116 = (-0x10.8p+1);
    int32_t l_186 = 1;
    const int32_t **l_192 = &g_37;
    struct S0 *l_254 = &g_200;
    int32_t **l_255 = &g_78;
    for (g_79 = (-22); (g_79 >= (-12)); g_79 = safe_add_func_int16_t_s_s(g_79, 7))
    { /* block id: 43 */
        int16_t *l_94 = (void*)0;
        int16_t *l_95 = &l_93;
        int32_t **l_104 = &g_78;
        float *l_109 = (void*)0;
        float **l_108 = &l_109;
        int32_t l_117 = 6;
        int32_t l_154 = 0;
        struct S0 *l_248 = &g_249;
        const int32_t **l_250 = (void*)0;
        const int32_t **l_251 = (void*)0;
        const int32_t *l_253 = &l_117;
        const int32_t **l_252 = &l_253;
        p_75 = func_82((p_77 && ((&p_73 != l_86) >= (1U & (safe_sub_func_int32_t_s_s((*p_76), (safe_mod_func_uint32_t_u_u(g_4, 0xD9FD593B))))))), l_86, ((*l_104) = func_91(((*l_95) = ((g_38 ^ (*l_86)) && l_93)))));
        if (__builtin_ia32_crc32qi((__builtin_clzl(g_39) < (((*l_108) = func_91((*l_86))) == l_86)), g_79))
        { /* block id: 57 */
            float l_135 = 0x5.8E4507p+51;
            int32_t l_136 = 1;
            int32_t l_158 = 8;
            const int32_t *l_164 = (void*)0;
            struct S0 *l_187 = &g_188;
            uint32_t *l_210 = &g_156;
            uint32_t *l_211 = &g_138;
            for (p_73 = (-21); (p_73 == (-14)); p_73 = safe_add_func_uint16_t_u_u(p_73, 3))
            { /* block id: 60 */
                const int32_t *l_113 = &g_38;
                const int32_t **l_112 = &l_113;
                const int32_t *l_115 = &g_38;
                const int32_t **l_114 = &l_115;
                uint32_t *l_137 = &g_138;
                int32_t *l_139 = &l_136;
                float *l_140 = (void*)0;
                float *l_141 = (void*)0;
                float *l_142 = &l_135;
                (*l_114) = ((*l_112) = (void*)0);
                l_117 = (p_73 <= g_79);
                (*l_139) = ((g_39 <= ((safe_sub_func_int32_t_s_s((safe_add_func_uint32_t_u_u(((*l_137) = (safe_mod_func_uint16_t_u_u((((*p_76) | ((safe_unary_minus_func_int16_t_s((*l_86))) == ((void*)0 != p_76))) > (safe_add_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(((*l_95) = (**l_104)), 3)) ^ (((safe_lshift_func_uint16_t_u_u(g_39, 11)) != p_77) & (safe_add_func_int16_t_s_s((**l_104), p_74)))), p_73))), l_136))), 0x685684CF)), g_79)) || (*p_75))) > (*g_37));
                (*l_142) = g_4;
            }
            if ((*g_37))
            { /* block id: 69 */
                int32_t *l_147 = &l_136;
                int16_t *l_151 = &l_93;
                uint32_t *l_155 = &g_156;
                uint32_t *l_157 = &g_138;
                float **l_185 = (void*)0;
                if ((((0x2F7292F9 ^ (*g_78)) & (*p_76)) || ((*l_157) = (g_4 != (safe_sub_func_int32_t_s_s(((*l_147) = (safe_add_func_uint32_t_u_u(g_138, (*g_78)))), ((~((*l_155) = (safe_mod_func_int32_t_s_s(((**l_104) || (((*g_152) = (l_151 != g_152)) > g_79)), l_154)))) > p_74)))))))
                { /* block id: 74 */
                    uint16_t l_161 = 0xB194;
                    const int32_t **l_163 = (void*)0;
                    (*l_104) = func_82(((*g_78) && ((*l_157) = (l_158 = l_136))), func_91((*l_86)), l_147);
                    if ((safe_lshift_func_uint16_t_u_s(l_161, 8)))
                    { /* block id: 78 */
                        (*l_147) = __builtin_clz((0xC02A0D86 == (*g_78)));
                        (*l_104) = func_91((*l_147));
                    }
                    else
                    { /* block id: 81 */
                        int32_t l_162 = (-6);
                        if (l_162)
                            break;
                    }
                    (*l_104) = &p_73;
                    l_164 = &g_38;
                }
                else
                { /* block id: 86 */
                    uint16_t l_174 = 0x7427;
                    if ((**l_104))
                        break;
                    (*l_104) = func_91((l_174 = (safe_lshift_func_int16_t_s_u(((*p_76) >= ((safe_rshift_func_uint16_t_u_s(65529U, 10)) && ((((safe_add_func_int32_t_s_s((*g_37), (~p_77))) != __builtin_bswap32((safe_add_func_uint32_t_u_u(g_38, 0x70F823F9)))) > (&g_79 != &l_136)) > 65534U))), 10))));
                    for (l_158 = 14; (l_158 > (-7)); --l_158)
                    { /* block id: 92 */
                        float *l_177 = &l_116;
                        float *l_178 = &g_102;
                        (*l_178) = ((*l_177) = 0x0.D83467p-99);
                    }
                    l_186 = (safe_add_func_int32_t_s_s((p_73 != (safe_add_func_int32_t_s_s(__builtin_popcount((**l_104)), (*p_75)))), (((g_183 == l_185) | __builtin_clzll(p_77)) & p_77)));
                }
                (*l_147) = __builtin_bswap64(((0x7CD2 | (**l_104)) && g_138));
                if ((*g_37))
                { /* block id: 99 */
                    struct S0 **l_189 = &l_187;
                    (*l_189) = l_187;
                    (*l_147) = (*p_75);
                }
                else
                { /* block id: 102 */
                    struct S0 *l_197 = &g_188;
                    for (l_136 = 1; (l_136 < (-14)); --l_136)
                    { /* block id: 105 */
                        const int32_t ***l_193 = &l_192;
                        const int32_t ***l_194 = (void*)0;
                        const int32_t **l_196 = &g_37;
                        const int32_t ***l_195 = &l_196;
                        struct S0 **l_198 = (void*)0;
                        int32_t *l_201 = &l_117;
                        (*l_195) = ((*l_193) = l_192);
                        (*l_104) = func_82((*g_37), &l_186, &l_186);
                        (*l_201) = ((g_199 = l_197) != (void*)0);
                        if ((*g_37))
                            break;
                    }
                }
            }
            else
            { /* block id: 114 */
                int32_t *l_204 = &l_136;
                (*l_204) = (safe_unary_minus_func_int16_t_s(0));
                if ((*g_37))
                { /* block id: 116 */
                    float *l_205 = &l_116;
                    (*l_205) = ((**g_183) = (((-0x1.5p+1) <= (*g_184)) > __builtin_ffsll((*l_204))));
                    for (l_117 = 0; (l_117 > 16); ++l_117)
                    { /* block id: 121 */
                        if ((*p_75))
                            break;
                        if ((*g_37))
                            continue;
                    }
                    p_75 = &p_73;
                    if ((*p_76))
                        continue;
                }
                else
                { /* block id: 127 */
                    (**g_183) = (**g_183);
                    if ((*g_37))
                        continue;
                }
                (*l_104) = &g_79;
            }
            (**g_183) = __builtin_ffs((safe_lshift_func_uint16_t_u_u((((*l_86) | 0x569110DD) == (((*g_37) && ((*l_211) = ((*l_210) = 4294967295U))) && (*g_152))), p_73)));
            l_158 = (safe_mod_func_int32_t_s_s(((-10) < (-1)), g_39));
        }
        else
        { /* block id: 137 */
            p_75 = (p_76 = &l_186);
        }
        if ((**l_104))
        { /* block id: 141 */
            float ***l_214 = &l_108;
            int32_t *l_215 = &l_186;
            (*l_215) = (((*l_214) = &l_109) == (void*)0);
        }
        else
        { /* block id: 144 */
            uint32_t l_222 = 0U;
            int16_t *l_230 = &g_153;
            struct S0 *l_247 = &g_200;
            (*l_104) = &p_73;
            for (p_74 = 16; (p_74 == (-12)); --p_74)
            { /* block id: 148 */
                int16_t l_231 = (-2);
                int32_t **l_243 = (void*)0;
                int32_t **l_244 = &g_232;
                if ((*p_75))
                    break;
                if ((*p_76))
                    continue;
            }
            for (g_156 = (-3); (g_156 == 22); g_156 = safe_add_func_int32_t_s_s(g_156, 1))
            { /* block id: 179 */
                g_78 = &p_73;
            }
            l_248 = l_247;
        }
        (*l_252) = (*l_192);
    }
    (*g_232) = ((*p_75) = (l_254 == (void*)0));
    (*l_255) = &g_233;
    return (*l_86);
}


/* ------------------------------------------ */
/* 
 * reads : g_79
 * writes: g_102 g_100 g_78
 */
inline static int32_t * func_82(int32_t  p_83, int32_t * p_84, int32_t * p_85)
{ /* block id: 51 */
    float *l_105 = &g_102;
    int32_t l_106 = 0x8344157F;
    int32_t **l_107 = &g_78;
    (*l_105) = 0xB.7FE6D7p-12;
    (*l_107) = func_91(l_106);
    return &g_79;
}


/* ------------------------------------------ */
/* 
 * reads : g_79
 * writes: g_100 g_102
 */
static int32_t * func_91(int16_t  p_92)
{ /* block id: 45 */
    int32_t *l_96 = &g_79;
    int32_t **l_97 = &l_96;
    float *l_98 = (void*)0;
    float *l_99 = &g_100;
    float *l_101 = &g_102;
    int32_t *l_103 = &g_79;
    (*l_97) = l_96;
    (*l_101) = (((*l_99) = g_79) > (0xF.90EB5Cp-63 == ((*l_96) <= (*l_96))));
    return l_103;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_38, "g_38", print_hash_value);
    transparent_crc(g_39, "g_39", print_hash_value);
    transparent_crc(g_79, "g_79", print_hash_value);
    transparent_crc_bytes (&g_100, sizeof(g_100), "g_100", print_hash_value);
    transparent_crc_bytes (&g_102, sizeof(g_102), "g_102", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_153, "g_153", print_hash_value);
    transparent_crc(g_156, "g_156", print_hash_value);
    transparent_crc_bytes (&g_188.f0, sizeof(g_188.f0), "g_188.f0", print_hash_value);
    transparent_crc(g_188.f1, "g_188.f1", print_hash_value);
    transparent_crc_bytes (&g_200.f0, sizeof(g_200.f0), "g_200.f0", print_hash_value);
    transparent_crc(g_200.f1, "g_200.f1", print_hash_value);
    transparent_crc_bytes (&g_203, sizeof(g_203), "g_203", print_hash_value);
    transparent_crc(g_233, "g_233", print_hash_value);
    transparent_crc_bytes (&g_249.f0, sizeof(g_249.f0), "g_249.f0", print_hash_value);
    transparent_crc(g_249.f1, "g_249.f1", print_hash_value);
    transparent_crc(g_276, "g_276", print_hash_value);
    transparent_crc_bytes (&g_281, sizeof(g_281), "g_281", print_hash_value);
    transparent_crc(g_341, "g_341", print_hash_value);
    transparent_crc(g_401, "g_401", print_hash_value);
    transparent_crc_bytes (&g_406.f0, sizeof(g_406.f0), "g_406.f0", print_hash_value);
    transparent_crc(g_406.f1, "g_406.f1", print_hash_value);
    transparent_crc(g_434, "g_434", print_hash_value);
    transparent_crc_bytes (&g_452, sizeof(g_452), "g_452", print_hash_value);
    transparent_crc(g_490, "g_490", print_hash_value);
    transparent_crc(g_498, "g_498", print_hash_value);
    transparent_crc(g_545, "g_545", print_hash_value);
    transparent_crc(g_554, "g_554", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 138
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 179
   depth: 2, occurrence: 41
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 8, occurrence: 4
   depth: 9, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 4
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2

XXX total number of pointers: 214

XXX times a variable address is taken: 220
XXX times a pointer is dereferenced on RHS: 135
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 28
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 185
breakdown:
   depth: 1, occurrence: 164
   depth: 2, occurrence: 21
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 651

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1268
   level: 2, occurrence: 200
   level: 3, occurrence: 31
   level: 4, occurrence: 2
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 105
XXX number of pointers point to scalars: 100
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 19.2
XXX average alias set size: 1.27

XXX times a non-volatile is read: 619
XXX times a non-volatile is write: 465
XXX times a volatile is read: 1
XXX    times read thru a pointer: 1
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 45
XXX percentage of non-volatile access: 99.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 164
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 26
   depth: 2, occurrence: 24
   depth: 3, occurrence: 21
   depth: 4, occurrence: 33
   depth: 5, occurrence: 27

XXX percentage a fresh-made variable is used: 23.2
XXX percentage an existing variable is used: 76.8
********************* end of statistics **********************/

