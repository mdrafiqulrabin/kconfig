/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1133667102
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const unsigned f0 : 29;
   const signed f1 : 30;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_4[3] = {65529U,65529U,65529U};
static struct S0 g_34 = {17283,20295};
static int32_t g_76 = 0x22CFB647;
static int32_t *g_75 = &g_76;
static float g_84 = (-0x1.9p+1);
static int32_t g_88 = 0xBF5F1E61;
static int32_t **g_126 = &g_75;
static int32_t ***g_125[7] = {&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126};
static int32_t ****g_223 = &g_125[2];
static struct S0 *g_496 = &g_34;
static struct S0 **g_495 = &g_496;
static const volatile uint32_t g_511[5] = {0x2CD02E7B,0x2CD02E7B,0x2CD02E7B,0x2CD02E7B,0x2CD02E7B};
static volatile int32_t g_518 = 0x63382AA1;/* VOLATILE GLOBAL g_518 */
static volatile int32_t g_519[4][3] = {{(-3),(-3),(-3)},{0x212092F1,0x212092F1,0x212092F1},{(-3),(-3),(-3)},{0x212092F1,0x212092F1,0x212092F1}};
static volatile int32_t g_520 = 0x3101D57B;/* VOLATILE GLOBAL g_520 */
static int32_t g_521[9] = {0x47BAFCFD,0x47BAFCFD,0x47BAFCFD,0x47BAFCFD,0x47BAFCFD,0x47BAFCFD,0x47BAFCFD,0x47BAFCFD,0x47BAFCFD};
static volatile int32_t g_523 = 0;/* VOLATILE GLOBAL g_523 */
static volatile int32_t g_524 = 0x7714C3A9;/* VOLATILE GLOBAL g_524 */
static volatile int32_t g_525 = 0x09BC145E;/* VOLATILE GLOBAL g_525 */
static volatile int32_t g_526 = (-1);/* VOLATILE GLOBAL g_526 */
static volatile int32_t g_527 = 0x513F74BD;/* VOLATILE GLOBAL g_527 */
static int32_t g_528 = 0xE9EE0BA2;
static uint32_t g_552 = 4294967295U;
static volatile uint32_t g_601 = 4294967295U;/* VOLATILE GLOBAL g_601 */
static uint32_t g_695 = 4294967295U;
static const int16_t g_733 = 7;
static volatile uint16_t g_742 = 0xF1AB;/* VOLATILE GLOBAL g_742 */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_26(void);
static struct S0 * func_27(struct S0 * p_28, uint32_t  p_29, struct S0  p_30, int16_t  p_31, int8_t  p_32);
static int32_t  func_36(uint16_t  p_37, struct S0 * p_38, uint32_t  p_39);
static struct S0 * func_41(int8_t  p_42, struct S0 * p_43, uint8_t  p_44, uint32_t  p_45);
static struct S0 * func_46(struct S0 * p_47, const struct S0 * p_48, int32_t  p_49, struct S0 * p_50, struct S0 * p_51);
static struct S0 * func_52(struct S0  p_53, struct S0 * p_54);
static struct S0  func_55(struct S0 * p_56, int16_t  p_57, int16_t  p_58, int16_t  p_59, struct S0 * p_60);
static struct S0 * func_61(float  p_62, struct S0 * p_63);
static struct S0 * func_64(struct S0 * p_65);
static int8_t  func_71(const uint32_t  p_72, struct S0 * p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_34.f1 g_75 g_76 g_88 g_126 g_223 g_125 g_528 g_4 g_520 g_521 g_34.f0 g_495 g_496 g_34 g_519 g_527 g_511 g_523 g_526 g_695 g_518 g_733 g_742 g_601 g_552
 * writes: g_75 g_76 g_88 g_521 g_223 g_528 g_84 g_519 g_695 g_552 g_496
 */
static uint16_t  func_26(void)
{ /* block id: 36 */
    struct S0 *l_33 = &g_34;
    int32_t l_40 = 0;
    struct S0 *l_608 = (void*)0;
    const struct S0 *l_610 = &g_34;
    (*g_495) = func_27(l_33, (0x198AB79A != ((0x072C02A3 > (((~func_36(l_40, func_41(l_40, func_46(func_52(func_55(func_61(l_40, func_64(&g_34)), g_34.f1, l_40, l_40, (*g_495)), l_608), l_610, l_40, (*g_495), (*g_495)), l_40, l_40), l_40)) >= 0xD4326F65) , l_40)) != 6)), (*l_610), g_34.f1, g_34.f1);
    /* statement id: 530 */
    assert (g_75 == 0);
    return l_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_518 g_552 g_495 g_496
 * writes:
 */
static struct S0 * func_27(struct S0 * p_28, uint32_t  p_29, struct S0  p_30, int16_t  p_31, int8_t  p_32)
{ /* block id: 527 */
    uint16_t l_835 = 0x5159;
    int8_t l_838 = 1;
    float *l_839[3][6][2] = {{{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84}},{{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84}},{{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84},{&g_84,&g_84}}};
    int32_t l_840 = 0x9BB91A0D;
    int i, j, k;
    l_840 = (((((((((safe_add_func_int32_t_s_s(l_835, (g_4[1] && ((((p_29 < (((p_31 < l_835) > (-0x6.6p+1)) < (((safe_sub_func_float_f_f(p_29, (-0x1.Dp-1))) , __builtin_ctz((g_518 || 0U))) > 0x6.14D5E2p-63))) , l_838) && 0xC5D5B8CF) , l_838)))) > p_32) | (-1)) , 0x7.9D0A38p+8) != 0xD.D3A4E1p-76) == 0xE.1E55E3p+86) <= l_835) != g_552) != p_30.f1);
    return (*g_495);
    /* statement id: 529 */
    //assert (func_27_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_520 g_4 g_733 g_126 g_75 g_223 g_125
 * writes: g_84 g_75
 */
static int32_t  func_36(uint16_t  p_37, struct S0 * p_38, uint32_t  p_39)
{ /* block id: 522 */
    uint8_t l_824 = 0U;
    int32_t **l_830 = &g_75;
    float *l_831 = (void*)0;
    float *l_832 = &g_84;
    (*l_832) = (safe_add_func_float_f_f((((safe_add_func_float_f_f((safe_div_func_float_f_f(g_520, (+0x8.Ep+1))), (safe_div_func_float_f_f((safe_sub_func_float_f_f(((p_39 == (((1 != (l_824 != (l_824 < (((safe_mod_func_uint8_t_u_u((l_824 || ((safe_mod_func_int8_t_s_s((+(__builtin_ffsll(l_824) && g_4[1])), p_37)) ^ 2U)), 8)) , (void*)0) == l_830)))) , g_733) , (-0x1.Fp+1))) > 0xE.F755A6p-98), 0x6.082521p-43)), p_37)))) < g_733) , p_39), 0xE.9F4247p+74));
    (*g_126) = (void*)0;
    /* statement id: 524 */
    assert (g_75 == 0);
    (***g_223) = (p_39 , (*g_126));
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads : g_76 g_34.f0 g_527 g_223 g_125 g_126 g_75 g_495 g_496 g_511 g_4 g_34 g_528 g_88 g_521 g_519 g_523 g_526 g_695 g_518 g_733 g_742 g_601 g_552 g_520
 * writes: g_76 g_75 g_84 g_528 g_519 g_521 g_88 g_695 g_552
 */
static struct S0 * func_41(int8_t  p_42, struct S0 * p_43, uint8_t  p_44, uint32_t  p_45)
{ /* block id: 387 */
    const uint32_t l_624 = 0x912BDF9B;
    struct S0 l_625 = {14369,-21140};
    int32_t *****l_638 = &g_223;
    int32_t l_760[10] = {(-10),(-10),(-10),(-10),(-10),(-10),(-10),(-10),(-10),(-10)};
    const uint32_t l_764 = 8U;
    int32_t ****l_795 = (void*)0;
    int i;
    for (g_76 = 1; (g_76 < 8); ++g_76)
    { /* block id: 390 */
        uint16_t l_621 = 0U;
        int32_t *l_628 = &g_76;
        int32_t *****l_637 = &g_223;
        uint16_t l_696 = 9U;
        struct S0 *l_718 = (void*)0;
        int32_t l_751 = (-1);
        uint16_t l_765 = 1U;
        int32_t l_766 = 0;
        g_84 = (safe_add_func_float_f_f(((g_34.f0 != l_621) > g_527), (p_45 <= (safe_add_func_float_f_f(l_624, func_71(g_76, func_52(l_625, p_43)))))));
        for (g_528 = (-7); (g_528 >= (-3)); g_528 = safe_add_func_int8_t_s_s(g_528, 2))
        { /* block id: 394 */
            (***g_223) = l_628;
            /* statement id: 395 */
            assert (g_75 == &g_76);
        }
        (***g_223) = l_628;
        /* statement id: 397 */
        assert (g_75 == &g_76);
        if (((func_71((safe_div_func_int16_t_s_s((!((0xE8261AC7 & (9U & (safe_lshift_func_uint8_t_u_u(250U, 6)))) | (func_71(((*l_628) || (8 | func_71((g_511[1] , l_624), p_43))), p_43) > g_4[1]))), p_45)), (*g_495)) , 6) > 0x31EB8E84))
        { /* block id: 398 */
            struct S0 *l_639 = (void*)0;
            const int32_t l_643 = 0xFDBF40DD;
            struct S0 *l_648 = &g_34;
            const int16_t l_653 = 0xD938;
            int32_t **l_656 = (void*)0;
            float *l_669 = &g_84;
            int16_t l_767 = 0;
            int32_t l_768 = 0xDE0FE639;
            const int32_t ****l_785[4];
            int i;
            for (i = 0; i < 4; i++)
                l_785[i] = (void*)0;
            if (__builtin_ffsl(g_511[4]))
            { /* block id: 399 */
                int8_t l_634 = 1;
                int32_t *l_644 = &g_521[1];
                int8_t l_705 = (-4);
                struct S0 *l_735 = &g_34;
                int32_t *****l_741 = &g_223;
                struct S0 *l_743 = &l_625;
                if ((l_634 & ((*g_496) , ((((p_45 <= (safe_lshift_func_int16_t_s_u(((*p_43) , ((func_71(__builtin_parityl(((p_44 , l_628) == ((((l_637 == l_638) < g_4[2]) == 1) , (void*)0))), p_43) , 6) ^ g_511[3])), 10))) ^ 0x15E293CA) > 0xF5) < 4294967291U))))
                { /* block id: 400 */
                    return l_639;
                    /* statement id: 401 */
                    //assert (func_41_rv == 0);
                }
                else
                { /* block id: 402 */
                    int8_t l_654[4][3];
                    int i, j;
                    for (i = 0; i < 4; i++)
                    {
                        for (j = 0; j < 3; j++)
                            l_654[i][j] = 0x41;
                    }
                    if ((!(safe_mod_func_uint16_t_u_u(g_34.f1, l_643))))
                    { /* block id: 403 */
                        (*g_126) = l_644;
                        /* statement id: 404 */
                        assert ((g_75 >= &g_521[0] && g_75 <= &g_521[8]));
                    }
                    else
                    { /* block id: 405 */
                        struct S0 *l_645 = &l_625;
                        l_638 = &g_223;
                        if (p_42)
                            break;
                        return (*g_495);
                        /* statement id: 408 */
                        //assert (func_41_rv == &g_34);
                    }
                    /* facts after branching */
                    assert ((g_75 >= &g_521[0] && g_75 <= &g_521[8]));
                    for (g_528 = (-6); (g_528 >= 15); g_528 = safe_add_func_int32_t_s_s(g_528, 9))
                    { /* block id: 412 */
                        float *l_655[6] = {&g_84,&g_84,&g_84,&g_84,&g_84,&g_84};
                        int i;
                        g_84 = ((0x4.8CED35p+12 != ((p_45 == p_42) , (func_71(g_88, func_46(l_648, p_43, p_44, ((0x0F92 != (safe_rshift_func_int8_t_s_s(((((safe_mod_func_int8_t_s_s(((void*)0 != &g_125[2]), l_653)) , p_44) <= 0x0F) > l_654[2][2]), p_44))) , (void*)0), (*g_495))) != g_4[1]))) >= 0x1.Fp+1);
                        g_84 = (((((&g_496 == ((*****l_638) , &l_648)) , l_656) == ((5 | ((p_42 || (safe_sub_func_int16_t_s_s((safe_sub_func_int32_t_s_s((0 > ((p_42 >= (*l_644)) || 0x41)), (*g_75))), 0x30B2))) <= p_45)) , (***l_638))) || 2U) , g_523);
                        return l_639;
                        /* statement id: 415 */
                        //assert (func_41_rv == 0);
                    }
                    for (g_528 = 2; (g_528 >= 0); g_528 -= 1)
                    { /* block id: 419 */
                        const float *l_672 = &g_84;
                        int i, j;
                        if (g_519[(g_528 + 1)][g_528])
                            break;
                        if (p_44)
                            break;
                        g_519[(g_528 + 1)][g_528] = __builtin_popcount(p_42);
                        (*****l_637) = (safe_mod_func_int32_t_s_s((safe_div_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s((g_519[0][1] , ((void*)0 == l_669)), 4)), p_44)), (p_45 | (safe_sub_func_uint32_t_u_u(((l_672 != l_644) <= ((safe_lshift_func_uint8_t_u_s(g_76, __builtin_clz(p_44))) >= 0x71)), 0U)))));
                    }
                    for (l_634 = 14; (l_634 > (-1)); l_634 = safe_sub_func_uint32_t_u_u(l_634, 2))
                    { /* block id: 427 */
                        return p_43;
                        /* statement id: 428 */
                        //assert (func_41_rv == &g_34);
                    }
                }
                /* facts after branching */
                assert ((g_75 >= &g_521[0] && g_75 <= &g_521[8]));
                if (((safe_sub_func_uint32_t_u_u(((void*)0 == &g_223), p_45)) <= 0xA3))
                { /* block id: 431 */
                    int32_t **l_682 = &l_628;
                    struct S0 *l_683[9];
                    int i;
                    for (i = 0; i < 9; i++)
                        l_683[i] = &g_34;
                    for (l_621 = (-28); (l_621 >= 10); l_621 = safe_add_func_uint16_t_u_u(l_621, 1))
                    { /* block id: 434 */
                        int32_t *l_681 = &g_528;
                        (*g_126) = l_681;
                        /* statement id: 435 */
                        assert (g_75 == &g_528);
                    }
                    /* facts after for loop */
                    assert (g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]));
                    if (((l_682 == (**g_223)) , func_71(g_526, l_683[5])))
                    { /* block id: 437 */
                        uint16_t l_688[6];
                        int i;
                        for (i = 0; i < 6; i++)
                            l_688[i] = 9U;
                        (*l_669) = (safe_add_func_float_f_f(p_45, (((((safe_lshift_func_uint8_t_u_u((p_42 < 4294967295U), 1)) > g_527) == ((l_688[4] >= (safe_add_func_float_f_f((!((g_4[1] == p_42) == (((((~(g_88 <= ((((safe_div_func_uint16_t_u_u(g_695, p_45)) <= (*l_644)) == 0x60D6F371) <= (-4)))) , 0xF.48CC5Fp-2) <= (-0x1.Bp-1)) , 0xB.A95BB7p+14) < 0x8.9F0CF2p+39))), g_521[1]))) , l_696)) <= 8) , 0xE.B67564p-58)));
                    }
                    else
                    { /* block id: 439 */
                        (*****l_637) = (**g_126);
                    }
                }
                else
                { /* block id: 442 */
                    (*l_669) = g_526;
                    (****l_637) = l_644;
                }
                /* facts after branching */
                assert (g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]));
                if (func_71(p_42, (*g_495)))
                { /* block id: 446 */
                    for (l_696 = 1; (l_696 == 13); ++l_696)
                    { /* block id: 449 */
                        int32_t *l_699 = &g_88;
                        l_699 = (void*)0;
                        /* statement id: 450 */
                        assert (l_699 == 0);
                    }
                }
                else
                { /* block id: 452 */
                    int32_t l_734[3][7][2] = {{{0,9},{0xB76F5E99,9},{0,(-6)},{(-6),0},{9,0xB76F5E99},{9,0},{(-6),(-6)}},{{0,9},{0xB76F5E99,9},{0,(-6)},{(-6),0},{9,0xB76F5E99},{9,0},{(-6),(-6)}},{{0,9},{0xB76F5E99,9},{0,(-6)},{(-6),0},{9,0xB76F5E99},{9,0},{(-6),(-6)}}};
                    int i, j, k;
                    for (g_88 = 10; (g_88 > (-22)); --g_88)
                    { /* block id: 455 */
                        uint16_t l_704 = 0x1CCB;
                    }
                    (****l_638) = (((*p_43) , ((safe_lshift_func_int16_t_s_u(g_518, 6)) || func_71((((safe_lshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s((((safe_div_func_uint16_t_u_u((g_519[0][1] , (((safe_rshift_func_uint16_t_u_u(((safe_sub_func_int8_t_s_s((func_55(l_718, ((((safe_mod_func_int32_t_s_s(((safe_rshift_func_uint16_t_u_u(g_511[1], 0)) && (0xFA == (safe_rshift_func_int8_t_s_s(((safe_div_func_uint16_t_u_u((safe_add_func_int8_t_s_s(func_71((((0x3B1C424F && ((((safe_add_func_uint16_t_u_u(((safe_div_func_int16_t_s_s(((void*)0 != &g_496), p_45)) , 1U), 8U)) != 0) != 0x7C4A) && 2U)) && (*****l_638)) , 8U), (*g_495)), g_511[4])), p_44)) | p_42), 5)))), (*l_644))) & g_733) , (*****l_637)) != g_4[0]), p_45, (*l_644), p_43) , 0x7F), g_528)) == p_42), l_734[1][6][1])) & 0) && p_45)), 6)) < p_42) == l_734[1][6][1]), 5)), p_44)) & p_45) > 65535U), l_735))) , (***g_223));
                    (*l_669) = p_44;
                }
                if ((safe_lshift_func_int16_t_s_s(p_42, ((((((~__builtin_ffs(p_42)) , (((void*)0 == (*l_637)) <= __builtin_clzll((safe_add_func_uint16_t_u_u((__builtin_parityl(((__builtin_ctz(p_42) || p_44) , p_45)) >= g_34.f0), 0xB098))))) , (*****l_637)) & p_42) , l_741) == (void*)0))))
                { /* block id: 463 */
                    (****l_637) = (void*)0;
                    /* statement id: 464 */
                    assert (g_75 == 0);
                    return (*g_495);
                    /* statement id: 465 */
                    //assert (func_41_rv == &g_34);
                }
                else
                { /* block id: 466 */
                    uint32_t l_750[9][1] = {{0x196397DD},{0x651CCAF7},{0x196397DD},{0x651CCAF7},{0x196397DD},{0x651CCAF7},{0x196397DD},{0x651CCAF7},{0x196397DD}};
                    int i, j;
                    for (l_621 = 0; (l_621 <= 8); l_621 += 1)
                    { /* block id: 469 */
                        int i;
                        (*l_669) = g_521[l_621];
                    }
                    if ((func_71((*****l_741), &l_625) <= ((g_742 , (__builtin_clz((l_743 == (g_695 , (*g_495)))) > (safe_div_func_uint16_t_u_u(l_625.f0, 8U)))) & p_45)))
                    { /* block id: 472 */
                        g_84 = (0x7.6p+1 == g_601);
                        (****l_637) = (****l_638);
                        (*g_126) = (****l_741);
                        (***g_223) = (void*)0;
                        /* statement id: 476 */
                        assert (g_75 == 0);
                    }
                    else
                    { /* block id: 477 */
                        (*l_669) = (((g_742 , (g_511[1] , 0xC907)) | ((safe_mod_func_uint8_t_u_u((safe_sub_func_int8_t_s_s((6 | ((*p_43) , (g_552 != g_4[0]))), ((l_750[5][0] || 7) ^ p_44))), p_42)) , l_751)) , p_44);
                        (**g_126) = (**g_126);
                    }
                    /* facts after branching */
                    assert (g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]) || g_75 == 0);
                    (*l_669) = p_45;
                    for (l_696 = 23; (l_696 != 28); ++l_696)
                    { /* block id: 484 */
                        uint16_t l_755 = 65535U;
                        (*l_644) = ((!(&g_125[2] == (void*)0)) ^ l_755);
                        (*l_669) = 0x6.408C66p-95;
                    }
                }
                /* facts after branching */
                assert (g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]) || g_75 == 0);
            }
            else
            { /* block id: 489 */
                struct S0 l_770 = {16470,-17340};
                int32_t *l_771 = &l_766;
                if (((((((p_45 != ((safe_div_func_float_f_f((g_528 == (g_519[2][2] , (g_520 < ((func_71((safe_lshift_func_uint8_t_u_s(l_760[8], (+(p_44 > (g_528 || ((g_521[0] , (safe_lshift_func_int16_t_s_s(((func_71(l_764, p_43) > g_76) | l_765), l_766))) >= p_44)))))), p_43) , p_45) == 0xC.3632B3p-29)))), (-0x10.0p+1))) == 0x5.D35FB6p+98)) , 0x5E10AEC7) , l_767) , g_526) == p_45) || 0xD0))
                { /* block id: 490 */
                    l_768 = (*****l_638);
                }
                else
                { /* block id: 492 */
                    int32_t *****l_769[5][3][10] = {{{&g_223,&g_223,(void*)0,&g_223,&g_223,&g_223,(void*)0,&g_223,&g_223,(void*)0},{&g_223,(void*)0,&g_223,(void*)0,&g_223,(void*)0,&g_223,&g_223,&g_223,&g_223},{&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223}},{{&g_223,(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223},{&g_223,(void*)0,(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,(void*)0,(void*)0},{(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223}},{{&g_223,(void*)0,&g_223,(void*)0,&g_223,&g_223,(void*)0,&g_223,(void*)0,&g_223},{&g_223,&g_223,(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,(void*)0,(void*)0},{(void*)0,&g_223,(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223}},{{&g_223,&g_223,&g_223,(void*)0,&g_223,(void*)0,&g_223,&g_223,(void*)0,(void*)0},{&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223},{&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,(void*)0}},{{&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223},{&g_223,(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223},{(void*)0,(void*)0,&g_223,&g_223,&g_223,&g_223,&g_223,(void*)0,(void*)0,&g_223}}};
                    int i, j, k;
                    l_771 = ((l_769[1][0][2] != (func_71(((1 | 255U) < p_42), func_52(l_770, &l_625)) , l_637)) , (*g_126));
                    /* statement id: 493 */
                    assert (l_771 == &g_76);
                }
                /* facts after branching */
                assert (l_771 == &g_76 || l_771 == &l_766);
                if (p_45)
                    continue;
                l_768 = __builtin_clzll(((!((void*)0 == (*g_495))) != (((safe_mod_func_uint16_t_u_u(((safe_mod_func_int16_t_s_s((((((safe_mod_func_uint32_t_u_u((safe_add_func_uint32_t_u_u(((*****l_638) , __builtin_clz((safe_sub_func_int32_t_s_s((safe_sub_func_uint8_t_u_u((l_785[0] == &g_125[2]), ((((void*)0 == &l_785[2]) == (+((safe_lshift_func_uint8_t_u_u(((safe_lshift_func_int16_t_s_s(((*g_496) , 0x798B), 4)) <= p_45), 5)) , g_4[0]))) <= 3U))), g_552)))), 0x8F907F78)), 1U)) | g_528) >= 4294967294U) != p_45) == (*****l_638)), (*****l_638))) ^ p_44), 0x22E2)) & 0) , g_695)));
            }
            /* facts after branching */
            assert (g_75 == &g_76 || g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]) || g_75 == 0);
            for (l_768 = (-29); (l_768 != 24); l_768 = safe_add_func_uint8_t_u_u(l_768, 1))
            { /* block id: 500 */
                int32_t ****l_796[8][8] = {{(void*)0,&g_125[3],&g_125[2],&g_125[2],&g_125[2],&g_125[2],&g_125[2],&g_125[3]},{(void*)0,&g_125[5],&g_125[2],&g_125[2],&g_125[2],(void*)0,(void*)0,&g_125[3]},{(void*)0,&g_125[2],(void*)0,&g_125[2],(void*)0,&g_125[2],(void*)0,&g_125[5]},{&g_125[1],&g_125[2],&g_125[2],(void*)0,&g_125[2],&g_125[2],&g_125[2],&g_125[2]},{&g_125[2],&g_125[2],&g_125[2],&g_125[2],&g_125[2],(void*)0,&g_125[2],&g_125[2]},{&g_125[1],&g_125[5],(void*)0,&g_125[2],(void*)0,&g_125[2],(void*)0,&g_125[2]},{(void*)0,&g_125[3],(void*)0,(void*)0,&g_125[2],&g_125[2],&g_125[2],&g_125[5]},{(void*)0,&g_125[3],&g_125[2],&g_125[2],&g_125[2],&g_125[2],&g_125[2],&g_125[3]}};
                const int32_t *****l_797 = &l_785[0];
                int i, j;
                l_766 = (safe_add_func_int32_t_s_s((l_795 != l_796[1][7]), g_34.f1));
                (*l_797) = l_785[0];
            }
        }
        else
        { /* block id: 504 */
            int16_t l_803[7][5][1] = {{{3},{0x9F99},{0xBC6F},{0x276C},{0xBC6F}},{{0x9F99},{3},{8},{0},{1}},{{0x7A6B},{1},{0},{8},{3}},{{0x9F99},{0xBC6F},{0x276C},{0xBC6F},{0x9F99}},{{3},{8},{0},{1},{0x7A6B}},{{1},{0},{8},{3},{0x9F99}},{{0xBC6F},{0x276C},{0xBC6F},{0x9F99},{3}}};
            int32_t l_806 = 1;
            int i, j, k;
            for (g_695 = 0; (g_695 <= 9); g_695 += 1)
            { /* block id: 507 */
                int i;
                (*g_126) = (l_760[g_695] , (***g_223));
            }
            l_806 = (~(((safe_mod_func_int16_t_s_s((-1), g_76)) < func_71((*****l_638), l_718)) >= (((safe_sub_func_int8_t_s_s(l_803[3][3][0], (safe_sub_func_uint8_t_u_u(0xAF, p_44)))) && (p_45 > 0x05E746CE)) > 0)));
        }
        /* facts after branching */
        assert (g_75 == &g_76 || g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]) || g_75 == 0);
    }
    /* facts after for loop */
    assert (g_75 == &g_76 || g_75 == &g_528 || (g_75 >= &g_521[0] && g_75 <= &g_521[8]) || g_75 == 0);
    for (g_552 = 0; (g_552 <= 43); g_552++)
    { /* block id: 515 */
        int32_t *l_811 = (void*)0;
        int32_t *l_812 = &g_528;
        g_84 = (0x5.C9DF5Ep+66 == (safe_sub_func_float_f_f(p_42, ((*g_495) != p_43))));
        (*l_812) = p_45;
        if (p_45)
            break;
    }
    (****l_638) = (***g_223);
    return (*g_495);
    /* statement id: 521 */
    //assert (func_41_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_495 g_496 g_75 g_521 g_519
 * writes: g_75
 */
static struct S0 * func_46(struct S0 * p_47, const struct S0 * p_48, int32_t  p_49, struct S0 * p_50, struct S0 * p_51)
{ /* block id: 384 */
    int32_t l_613 = 0x6706623F;
    int32_t *l_616[7];
    int i;
    for (i = 0; i < 7; i++)
        l_616[i] = &g_521[0];
    p_49 = ((func_71((((__builtin_popcountll(((l_613 != l_613) <= (((safe_sub_func_float_f_f(0x3.BBC591p+60, func_71(p_49, (*g_495)))) , (4U >= (4294967287U == ((&g_223 == &g_223) & 1U)))) || p_49))) < 0U) <= 0) == p_49), (*g_495)) ^ g_521[0]) > g_519[0][1]);
    return p_50;
    /* statement id: 386 */
    //assert (func_46_rv == &g_34 || func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_223 g_125 g_126 g_75 g_495 g_496
 * writes:
 */
static struct S0 * func_52(struct S0  p_53, struct S0 * p_54)
{ /* block id: 381 */
    int32_t *l_609 = &g_76;
    l_609 = (***g_223);
    /* statement id: 382 */
    assert ((l_609 >= &g_521[0] && l_609 <= &g_521[8]) || l_609 == &g_76 || l_609 == &g_528 || l_609 == 0);
    return (*g_495);
    /* statement id: 383 */
    //assert (func_52_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_496 g_34
 * writes:
 */
static struct S0  func_55(struct S0 * p_56, int16_t  p_57, int16_t  p_58, int16_t  p_59, struct S0 * p_60)
{ /* block id: 379 */
    return (*g_496);
}


/* ------------------------------------------ */
/* 
 * reads : g_88 g_126 g_75 g_223 g_125 g_76 g_528 g_4 g_520 g_521 g_34.f0 g_495 g_496
 * writes: g_88 g_75 g_76 g_521 g_223 g_528 g_84
 */
static struct S0 * func_61(float  p_62, struct S0 * p_63)
{ /* block id: 239 */
    uint16_t l_420 = 0U;
    int32_t *****l_438 = &g_223;
    struct S0 l_468 = {9394,-30305};
    int32_t *l_522 = &g_521[1];
    int8_t l_600 = 1;
    if (l_420)
    { /* block id: 240 */
        const int16_t l_430 = 0xAB8E;
        int32_t ***l_435 = &g_126;
        float *l_437[1];
        int32_t *****l_498[5] = {&g_223,&g_223,&g_223,&g_223,&g_223};
        int i;
        for (i = 0; i < 1; i++)
            l_437[i] = &g_84;
        for (g_88 = 0; (g_88 != (-17)); g_88--)
        { /* block id: 243 */
            uint32_t l_427 = 0U;
            float *l_436 = (void*)0;
            int32_t l_470 = 0xDB1226E4;
            struct S0 *l_512 = (void*)0;
        }
        (**l_435) = (*g_126);
        (*****l_438) = (*****l_438);
    }
    else
    { /* block id: 291 */
        float l_545 = (-0x1.Bp+1);
        int32_t *****l_548 = &g_223;
        int32_t l_599 = (-7);
        for (g_88 = (-9); (g_88 >= 14); g_88 = safe_add_func_int8_t_s_s(g_88, 1))
        { /* block id: 294 */
            int32_t *****l_547[7] = {&g_223,&g_223,&g_223,&g_223,&g_223,&g_223,&g_223};
            int i;
            for (l_420 = 8; (l_420 > 28); l_420 = safe_add_func_uint16_t_u_u(l_420, 9))
            { /* block id: 297 */
                float l_544 = 0x1.8p+1;
                int32_t **l_546 = &l_522;
                for (g_76 = 0; (g_76 <= 2); g_76 += 1)
                { /* block id: 300 */
                    for (g_521[0] = 2; (g_521[0] >= 0); g_521[0] -= 1)
                    { /* block id: 303 */
                        (*l_438) = &g_125[2];
                        (*g_126) = l_522;
                        /* statement id: 305 */
                        assert ((g_75 >= &g_521[0] && g_75 <= &g_521[8]));
                    }
                    for (g_528 = 0; (g_528 <= 2); g_528 += 1)
                    { /* block id: 309 */
                        uint8_t l_543 = 1U;
                        int i;
                        g_84 = ((0xD.298685p+24 > (safe_sub_func_float_f_f(((safe_div_func_float_f_f((g_4[g_528] , ((g_4[g_76] <= (safe_add_func_float_f_f(g_520, ((void*)0 == &g_223)))) < (safe_add_func_float_f_f(((safe_div_func_float_f_f(p_62, 0xA.FC5E81p-54)) == (safe_sub_func_float_f_f((((safe_add_func_float_f_f(0x1.Cp+1, l_543)) >= 0x1.8p-1) , (-0x1.Fp-1)), g_528))), l_544)))), p_62)) != g_521[8]), g_34.f0))) == l_545);
                        (*g_126) = (***g_223);
                    }
                    for (g_528 = 0; (g_528 <= 2); g_528 += 1)
                    { /* block id: 315 */
                        (*l_522) = ((void*)0 == l_546);
                    }
                }
                /* facts after for loop */
                assert ((g_75 >= &g_521[0] && g_75 <= &g_521[8]) || g_75 == &g_76);
                return (*g_495);
                /* statement id: 319 */
                //assert (func_61_rv == &g_34);
            }
            l_548 = l_547[2];
        }
        for (g_88 = 26; (g_88 < 23); g_88--)
        { /* block id: 325 */
            int16_t l_565 = 1;
            struct S0 *l_591 = (void*)0;
            int32_t *l_594 = (void*)0;
            int32_t *l_595[6][10][4] = {{{&g_521[2],&g_76,&g_88,&g_88},{&g_88,&g_76,&g_88,&g_88},{&g_521[0],&g_76,&g_521[0],&g_521[0]},{(void*)0,&g_88,&g_88,(void*)0},{&g_528,&g_88,&g_88,&g_521[0]},{&g_521[0],&g_76,(void*)0,&g_88},{&g_528,&g_76,(void*)0,(void*)0},{&g_88,&g_76,(void*)0,(void*)0},{&g_76,&g_76,&g_521[0],&g_88},{&g_521[0],&g_76,&g_76,(void*)0}},{{&g_521[0],&g_76,&g_88,(void*)0},{&g_521[0],&g_88,&g_76,(void*)0},{&g_76,&g_76,&g_88,(void*)0},{&g_88,&g_76,&g_76,&g_88},{&g_521[2],&g_76,&g_88,(void*)0},{(void*)0,&g_76,&g_76,(void*)0},{&g_521[2],&g_88,&g_521[0],(void*)0},{&g_88,&g_76,(void*)0,(void*)0},{&g_76,&g_76,&g_521[0],&g_88},{&g_521[0],&g_76,&g_76,(void*)0}},{{&g_521[0],&g_76,&g_88,(void*)0},{&g_521[0],&g_88,&g_76,(void*)0},{&g_76,&g_76,&g_88,(void*)0},{&g_88,&g_76,&g_76,&g_88},{&g_521[2],&g_76,&g_88,(void*)0},{(void*)0,&g_76,&g_76,(void*)0},{&g_521[2],&g_88,&g_521[0],(void*)0},{&g_88,&g_76,(void*)0,(void*)0},{&g_76,&g_76,&g_521[0],&g_88},{&g_521[0],&g_76,&g_76,(void*)0}},{{&g_521[0],&g_76,&g_88,(void*)0},{&g_521[0],&g_88,&g_76,(void*)0},{&g_76,&g_76,&g_88,(void*)0},{&g_88,&g_76,&g_76,&g_88},{&g_521[2],&g_76,&g_88,(void*)0},{(void*)0,&g_76,&g_76,(void*)0},{&g_521[2],&g_88,&g_521[0],(void*)0},{&g_88,&g_76,(void*)0,(void*)0},{&g_76,&g_76,&g_521[0],&g_88},{&g_521[0],&g_76,&g_76,(void*)0}},{{&g_521[0],&g_76,&g_88,(void*)0},{&g_521[0],&g_88,&g_76,(void*)0},{&g_76,&g_76,&g_88,(void*)0},{&g_88,&g_76,&g_76,&g_88},{&g_521[2],&g_76,&g_88,(void*)0},{(void*)0,&g_76,&g_76,(void*)0},{&g_521[2],&g_88,&g_521[0],(void*)0},{&g_88,&g_76,(void*)0,(void*)0},{&g_76,&g_76,&g_521[0],&g_88},{&g_521[0],&g_76,&g_76,(void*)0}},{{&g_521[0],&g_76,&g_88,(void*)0},{&g_521[0],&g_88,&g_76,(void*)0},{&g_76,&g_76,&g_88,(void*)0},{&g_88,&g_76,&g_76,&g_88},{&g_521[2],&g_76,&g_528,&g_88},{&g_88,&g_88,&g_76,&g_88},{&g_521[0],&g_76,&g_88,&g_88},{(void*)0,&g_88,&g_76,&g_88},{&g_88,(void*)0,&g_88,(void*)0},{(void*)0,(void*)0,&g_76,&g_88}}};
            int i, j, k;
        }
    }
    for (l_600 = (-9); (l_600 == 1); l_600 = safe_add_func_int16_t_s_s(l_600, 6))
    { /* block id: 374 */
        const int32_t *l_606 = &g_521[1];
        const int32_t **l_605 = &l_606;
        const int32_t ***l_604 = &l_605;
        struct S0 *l_607 = (void*)0;
        (****l_438) = ((0x9F55 | (l_604 == (*g_223))) , (***g_223));
        return l_607;
        /* statement id: 376 */
        //assert (func_61_rv == 0);
    }
    return p_63;
    /* statement id: 378 */
    //assert (func_61_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_34.f1 g_75 g_76
 * writes: g_75 g_76
 */
static struct S0 * func_64(struct S0 * p_65)
{ /* block id: 37 */
    uint16_t l_66 = 1U;
    struct S0 l_79 = {9190,-7653};
    uint32_t l_80 = 0xCF47A0CA;
    int16_t l_122 = 0xF0D8;
    const int32_t *l_144 = &g_76;
    const int32_t *l_145[9];
    int32_t ****l_152 = &g_125[2];
    int32_t l_189 = 9;
    uint16_t l_334 = 0x7AE7;
    struct S0 *l_345 = (void*)0;
    struct S0 **l_344[2][1];
    float l_383[1];
    int i, j;
    for (i = 0; i < 9; i++)
        l_145[i] = &g_88;
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 1; j++)
            l_344[i][j] = &l_345;
    }
    for (i = 0; i < 1; i++)
        l_383[i] = 0x9.9p-1;
    g_76 = ((l_66 , (g_34.f1 & (((safe_sub_func_int16_t_s_s((safe_rshift_func_int8_t_s_s(func_71(g_34.f1, p_65), ((0x17 <= l_66) != ((l_66 , l_79) , l_80)))), (-6))) , 7U) != g_34.f1))) , l_79.f0);
    for (g_76 = 0; (g_76 < 7); g_76 = safe_add_func_int8_t_s_s(g_76, 6))
    { /* block id: 44 */
        int32_t *l_86 = &g_76;
        int32_t l_95 = 0;
        int8_t l_100 = 7;
        struct S0 *l_115 = (void*)0;
        float l_162 = 0x4.CDC407p-36;
        int8_t l_246 = (-6);
        int32_t ****l_273 = &g_125[2];
    }
    return &g_34;
    /* statement id: 238 */
    //assert (func_64_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_75
 * writes: g_75
 */
static int8_t  func_71(const uint32_t  p_72, struct S0 * p_73)
{ /* block id: 38 */
    uint8_t l_74 = 252U;
    int32_t **l_77 = &g_75;
    int32_t l_78[5];
    int i;
    for (i = 0; i < 5; i++)
        l_78[i] = 1;
    (*l_77) = ((l_74 , p_72) , g_75);
    return l_78[2];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    for (i = 0; i < 3; i++)
    {
        transparent_crc(g_4[i], "g_4[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_34.f0, "g_34.f0", print_hash_value);
    transparent_crc(g_34.f1, "g_34.f1", print_hash_value);
    transparent_crc(g_76, "g_76", print_hash_value);
    transparent_crc_bytes (&g_84, sizeof(g_84), "g_84", print_hash_value);
    transparent_crc(g_88, "g_88", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        transparent_crc(g_511[i], "g_511[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_518, "g_518", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 3; j++)
        {
            transparent_crc(g_519[i][j], "g_519[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_520, "g_520", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        transparent_crc(g_521[i], "g_521[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_523, "g_523", print_hash_value);
    transparent_crc(g_524, "g_524", print_hash_value);
    transparent_crc(g_525, "g_525", print_hash_value);
    transparent_crc(g_526, "g_526", print_hash_value);
    transparent_crc(g_527, "g_527", print_hash_value);
    transparent_crc(g_528, "g_528", print_hash_value);
    transparent_crc(g_552, "g_552", print_hash_value);
    transparent_crc(g_601, "g_601", print_hash_value);
    transparent_crc(g_695, "g_695", print_hash_value);
    transparent_crc(g_733, "g_733", print_hash_value);
    transparent_crc(g_742, "g_742", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 186
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 19
   indirect level: 2, occurrence: 4
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 48
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 55

XXX max expression depth: 49
breakdown:
   depth: 1, occurrence: 109
   depth: 2, occurrence: 30
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 33, occurrence: 1
   depth: 49, occurrence: 1

XXX total number of pointers: 151

XXX times a variable address is taken: 441
XXX times a pointer is dereferenced on RHS: 212
breakdown:
   depth: 1, occurrence: 122
   depth: 2, occurrence: 18
   depth: 3, occurrence: 24
   depth: 4, occurrence: 22
   depth: 5, occurrence: 26
XXX times a pointer is dereferenced on LHS: 105
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 5
   depth: 3, occurrence: 12
   depth: 4, occurrence: 17
   depth: 5, occurrence: 5
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 995

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 305
   level: 2, occurrence: 44
   level: 3, occurrence: 46
   level: 4, occurrence: 77
   level: 5, occurrence: 60
XXX number of pointers point to pointers: 50
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 39
XXX percent of pointers has null in alias set: 33.8
XXX average alias set size: 1.33

XXX times a non-volatile is read: 1316
XXX times a non-volatile is write: 406
XXX times a volatile is read: 35
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 139
XXX percentage of non-volatile access: 98

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 112
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 14
   depth: 2, occurrence: 7
   depth: 3, occurrence: 12
   depth: 4, occurrence: 24
   depth: 5, occurrence: 30

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

