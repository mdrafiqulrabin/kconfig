/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2387615718
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static uint64_t g_6 = 18446744073709551610UL;
static int32_t g_19 = (-8L);
static int32_t *g_18 = &g_19;
static struct S0 g_62 = {1L,-9L,0L,0xC4B0538FL};
static float g_77 = 0x7.0p-1;
static volatile struct S0 **g_79 = (void*)0;
static float *g_150 = &g_77;
static float **g_149 = &g_150;
static uint32_t g_184 = 0x598B098BL;
static volatile int32_t g_200 = (-1L);/* VOLATILE GLOBAL g_200 */
static volatile int32_t *g_199 = &g_200;
static int32_t *g_209 = (void*)0;
static volatile int32_t **g_397 = &g_199;
static volatile int32_t ***g_396 = &g_397;
static volatile float g_523 = (-0x1.2p+1);/* VOLATILE GLOBAL g_523 */
static volatile float *g_522 = &g_523;
static volatile float **g_521 = &g_522;
static volatile float ***g_520 = &g_521;
static volatile float ****g_519 = &g_520;
static struct S0 ***g_571 = (void*)0;
static struct S0 ****g_570 = &g_571;
static struct S0 *****g_569 = &g_570;
static uint8_t g_633 = 6UL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_7(uint32_t  p_8);
inline static int32_t * func_9(struct S0  p_10, uint16_t  p_11, float  p_12, int32_t * p_13, int32_t * p_14);
static int32_t * func_20(int32_t * p_21, int32_t * p_22, uint8_t  p_23);
static int32_t * func_24(int32_t  p_25);
static int32_t * func_26(uint32_t  p_27, int32_t  p_28, struct S0  p_29, struct S0  p_30, int64_t  p_31);
inline static uint32_t  func_32(int32_t  p_33, uint64_t  p_34, uint64_t  p_35, int32_t * p_36, int16_t  p_37);
static uint64_t  func_41(int64_t  p_42, int16_t  p_43, float  p_44, int32_t * p_45);
static int64_t  func_46(uint16_t  p_47, float  p_48, uint32_t  p_49, uint64_t  p_50, uint64_t  p_51);
static struct S0 * func_52(int32_t  p_53, int64_t  p_54, int16_t  p_55);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_18 g_19 g_62.f3 g_62.f1 g_62.f2 g_79 g_62.f0 g_77 g_149 g_150 g_199 g_62 g_209 g_184 g_200 g_396 g_397 g_519 g_522 g_523 g_520 g_521 g_569 g_633
 * writes: g_6 g_77 g_62.f2 g_184 g_199 g_149 g_200 g_209 g_62 g_18 g_19 g_396 g_397 g_523 g_569
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_5 = 0x62C9CC14L;
    int32_t *l_752 = &g_19;
    struct S0 l_775 = {-5L,0L,0x483DF40FL,1UL};
    struct S0 *l_776 = (void*)0;
    struct S0 *l_777 = &g_62;
    if ((safe_lshift_func_uint16_t_u_u((~0xFD4914D2EDC7555BLL), 12)))
    { /* block id: 1 */
        int32_t **l_753 = &g_18;
        g_6 = l_5;
        if (g_6)
        { /* block id: 3 */
            int32_t **l_750 = &g_209;
            (*l_750) = func_7(g_6);
            /* statement id: 349 */
            //assert (g_18 == dangling || g_18 == &g_19);
            assert (g_199 == 0 || g_199 == &g_200);
            assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
            //assert (g_569 == dangling || g_569 == &g_570);
        }
        else
        { /* block id: 350 */
            int32_t l_751 = 0x2BC37ECBL;
            return l_751;
        }
        /* facts after branching */
        //assert (g_18 == dangling || g_18 == &g_19);
        assert (g_199 == 0 || g_199 == &g_200);
        assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
        //assert (g_569 == dangling || g_569 == &g_570);
        (*l_753) = l_752;
        /* statement id: 353 */
        assert (g_18 == &g_19);
    }
    else
    { /* block id: 354 */
        int64_t l_760 = 0x8FC39003DEAD04C6LL;
        uint16_t l_771 = 0x8DEAL;
        (*g_18) = 1L;
        (*g_150) = (safe_mul_func_float_f_f((safe_add_func_float_f_f((((safe_sub_func_float_f_f(0x0.Bp-1, (*l_752))) != l_760) != (((*l_752) >= ((void*)0 != &l_752)) >= (l_760 >= ((safe_sub_func_float_f_f(((safe_sub_func_float_f_f(((safe_mul_func_float_f_f(((safe_sub_func_float_f_f(((((0x0.Dp+1 > (safe_sub_func_float_f_f((*l_752), 0x1.Bp-1))) >= (**g_521)) > (**g_149)) >= l_771), (**g_149))) < (-0x1.5p+1)), (*l_752))) != (-0x1.Dp+1)), (**g_149))) != (*g_150)), (**g_149))) == 0xD.98B494p-56)))), (**g_149))), l_760));
        for (g_62.f2 = 28; (g_62.f2 <= (-18)); g_62.f2 = safe_sub_func_uint32_t_u_u(g_62.f2, 4))
        { /* block id: 359 */
            int32_t **l_774 = &l_752;
            (*l_774) = l_752;
        }
    }
    /* facts after branching */
    assert (g_199 == 0 || g_199 == &g_200);
    assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
    //assert (g_569 == dangling || g_569 == &g_570);
    (*l_777) = l_775;
    return g_62.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_18 g_19 g_6 g_62.f3 g_62.f1 g_62.f2 g_79 g_62.f0 g_77 g_149 g_150 g_199 g_62 g_209 g_184 g_200 g_396 g_397 g_519 g_522 g_523 g_520 g_521 g_569 g_633
 * writes: g_77 g_62.f2 g_184 g_199 g_149 g_200 g_209 g_62 g_18 g_19 g_396 g_6 g_397 g_523 g_569
 */
static int32_t * func_7(uint32_t  p_8)
{ /* block id: 4 */
    struct S0 l_15 = {0x4272BA75L,0x592C6EEDL,0xE12AA53FL,0xD3ECF04BL};
    int32_t *l_367 = (void*)0;
    int32_t l_368 = 8L;
    int32_t **l_399 = (void*)0;
    int32_t **l_400 = (void*)0;
    int32_t **l_401 = &l_367;
    struct S0 *l_403 = &l_15;
    struct S0 **l_402 = &l_403;
    uint64_t l_445 = 18446744073709551608UL;
    int32_t **l_471 = (void*)0;
    int32_t l_488 = 0x0BCE5FE1L;
    float l_504 = 0x0.3p-1;
    volatile int32_t *l_510 = &g_200;
    int16_t l_513 = 1L;
    int32_t ****l_516 = (void*)0;
    int32_t l_682 = (-1L);
    uint32_t l_683 = 0xBF669DB1L;
    uint32_t l_731 = 0x7E5613BDL;
    int32_t l_732 = 7L;
    (*l_401) = func_9(l_15, ((safe_rshift_func_uint16_t_u_u(65526UL, 7)) <= (g_18 == &g_19)), g_19, func_20(func_24(l_15.f3), l_367, l_368), &g_19);
    /* statement id: 170 */
    assert (g_199 == 0 || g_199 == &g_200);
    assert (g_209 == &g_19);
    if ((l_402 == &l_403))
    { /* block id: 171 */
        float l_410 = 0x9.2p+1;
        float **l_418 = &g_150;
        int32_t *l_446 = &l_15.f2;
        struct S0 l_452 = {0x1655B861L,0x5999D3E9L,-5L,18446744073709551609UL};
        float ***l_518 = (void*)0;
        float ****l_517 = &l_518;
        int32_t *l_559 = (void*)0;
        if ((safe_lshift_func_uint16_t_u_s(p_8, (p_8 && 0L))))
        { /* block id: 172 */
            float **l_417 = &g_150;
            int32_t l_422 = (-1L);
            float l_442 = 0xB.94AFA8p-58;
            int32_t *l_447 = &g_62.f2;
            struct S0 l_455 = {0x90F250EAL,0xE945F99EL,0xF71AB1ABL,0x68E2F515L};
            int32_t *l_489 = (void*)0;
            float ***l_507 = &l_418;
            (*l_401) = func_24((0x41481E0D7E1F17AFLL != (p_8 & 0xD7B4E7EDL)));
            /* statement id: 173 */
            assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
            assert (l_367 == &g_19);
            if (((safe_add_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((((((0xB363L || (((4294967288UL < ((p_8 | g_19) > (safe_mul_func_int16_t_s_s((safe_mod_func_uint64_t_u_u(0x38DFE0E4C69024ADLL, ((safe_mul_func_int16_t_s_s((l_417 != l_418), (~g_6))) ^ (safe_lshift_func_uint16_t_u_s(0x22C9L, p_8))))), 0L)))) || 0UL) >= p_8)) <= g_184) | 65528UL) < 0xC9FBL) ^ p_8), l_422)), (*l_367))) & p_8))
            { /* block id: 174 */
                int32_t ***l_423 = &l_400;
                uint32_t l_441 = 0x602D2994L;
                struct S0 l_454 = {0x88EC6B02L,1L,0x29830DE3L,1UL};
                int32_t *l_470 = (void*)0;
                (*l_423) = &l_367;
                /* statement id: 175 */
                assert (l_400 == &l_367);
                if (p_8)
                { /* block id: 176 */
                    int32_t l_443 = (-9L);
                    (*l_402) = func_52(g_200, g_62.f2, (**l_401));
                    /* statement id: 177 */
                    assert (l_403 == &g_62);
                    (*g_397) = (*g_397);
                    (**l_423) = (void*)0;
                    /* statement id: 179 */
                    assert (l_367 == 0);
                    if (p_8)
                    { /* block id: 180 */
                        (**g_396) = (*g_397);
                    }
                    else
                    { /* block id: 182 */
                        struct S0 l_444 = {0L,0L,0x568B13B5L,0x8CCA986AL};
                        (*g_18) = (safe_rshift_func_int16_t_s_u(((((void*)0 != &l_401) && ((safe_sub_func_int64_t_s_s((((safe_add_func_uint16_t_u_u((safe_sub_func_int32_t_s_s(p_8, p_8)), ((safe_mod_func_int32_t_s_s((((g_184 < (g_200 || (safe_mul_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s(((~(p_8 < (((-1L) && (safe_sub_func_uint32_t_u_u(l_441, 0x5027362AL))) & p_8))) ^ p_8), 6)), g_6)))) ^ p_8) > 1UL), p_8)) || 0xB79CL))) && g_62.f1) & g_62.f0), p_8)) > l_443)) <= p_8), 15));
                        (*l_401) = func_26(l_422, g_62.f0, l_444, l_444, l_445);
                        /* statement id: 184 */
                        assert (l_367 == &g_62.f2 || l_367 == &g_19);
                    }
                    /* facts after branching */
                    assert (l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
                }
                else
                { /* block id: 186 */
                    (*l_403) = g_62;
                    return l_447;
                    /* statement id: 188 */
                    //assert (func_7_rv == &g_62.f2);
                }
                /* facts after branching */
                assert (l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
                assert (l_403 == &g_62);
                for (g_6 = 0; (g_6 >= 9); g_6 = safe_add_func_int32_t_s_s(g_6, 4))
                { /* block id: 192 */
                    struct S0 l_456 = {0x46C3AE12L,-7L,0xFC20A5E3L,18446744073709551609UL};
                    float l_468 = 0x8.Ap-1;
                    for (l_445 = (-30); (l_445 <= 45); ++l_445)
                    { /* block id: 195 */
                        uint32_t l_453 = 4294967294UL;
                        (**l_402) = l_452;
                        l_453 = (*g_18);
                    }
                    if (p_8)
                    { /* block id: 199 */
                        int32_t **l_463 = &l_446;
                        (**l_402) = l_454;
                        (*l_403) = l_455;
                        (**l_402) = l_456;
                        (*g_18) = (safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((&g_149 == &g_149), 9)), (((1UL <= ((((safe_unary_minus_func_int16_t_s(((g_62.f1 <= (1L < (~((l_463 != &l_367) == (((((safe_mul_func_int16_t_s_s(g_184, ((safe_mod_func_uint64_t_u_u(((p_8 && p_8) || p_8), g_184)) <= (-3L)))) ^ p_8) == p_8) || 4294967286UL) && p_8))))) >= (*l_447)))) | 0x09B4L) || p_8) < g_62.f2)) & (*l_446)) != (*g_18))));
                    }
                    else
                    { /* block id: 204 */
                        int32_t *l_469 = &l_422;
                        (*g_396) = (*g_396);
                        l_469 = (void*)0;
                        /* statement id: 206 */
                        assert (l_469 == 0);
                        l_456 = l_456;
                        return l_470;
                        /* statement id: 208 */
                        //assert (func_7_rv == 0);
                    }
                    if (((((((l_471 != (*g_396)) > (safe_lshift_func_int16_t_s_u(((safe_mul_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((p_8 == ((safe_rshift_func_uint16_t_u_s(((((l_367 != l_470) < (~((p_8 < ((safe_mul_func_uint16_t_u_u(p_8, p_8)) != (p_8 < p_8))) && (-1L)))) < (*l_446)) >= (*g_18)), 6)) > (*l_446))), 4)), (-1L))) == (*l_447)), 0x2739L)) < (*l_446)), 0))) < p_8) & l_456.f3) != g_62.f3) || g_62.f3))
                    { /* block id: 210 */
                        struct S0 ***l_485 = &l_402;
                        struct S0 ****l_486 = &l_485;
                        (*l_486) = l_485;
                    }
                    else
                    { /* block id: 212 */
                        float l_487 = 0x1.Bp-1;
                        if ((*g_18))
                            break;
                    }
                    (*l_401) = l_446;
                    /* statement id: 215 */
                    assert (l_367 == &l_15.f2);
                }
                /* facts after for loop */
                assert (l_367 == &l_15.f2 || l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
                (**l_402) = l_452;
            }
            else
            { /* block id: 218 */
                (*l_447) = (*g_18);
                l_447 = func_24(l_488);
                /* statement id: 220 */
                assert (l_447 == &g_19);
                l_446 = func_20(l_489, &g_19, (*l_446));
                /* statement id: 221 */
                assert (g_209 == &g_19);
                assert (l_446 == &g_19);
            }
            /* facts after branching */
            assert (l_367 == &l_15.f2 || l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
            assert (l_400 == 0 || l_400 == &l_367);
            assert (l_403 == &l_15 || l_403 == &g_62);
            assert (l_446 == &g_19 || l_446 == &l_15.f2);
            assert (l_447 == &g_19 || l_447 == &g_62.f2);
            (*g_150) = (safe_sub_func_float_f_f(((*g_150) == (((((**g_149) <= ((safe_mul_func_float_f_f((safe_mul_func_float_f_f((p_8 < 0x9.7EDB1Dp+50), (safe_add_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f((safe_sub_func_float_f_f((**g_149), (*g_150))), p_8)), 0xF.750B7Dp+74)), (0xD.ED6686p+54 < 0x0.0p+1))))), (*g_150))) > l_504)) <= (*l_446)) > 0x8.FACA5Bp-45) < 0x9.A8397Fp-57)), (*l_447)));
            for (g_62.f3 = 0; (g_62.f3 < 34); ++g_62.f3)
            { /* block id: 226 */
                float ****l_508 = (void*)0;
                float ****l_509 = &l_507;
                (*l_509) = l_507;
            }
        }
        else
        { /* block id: 229 */
            l_510 = (*g_397);
            /* statement id: 230 */
            assert (l_510 == 0 || l_510 == &g_200);
        }
        /* facts after branching */
        assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
        assert (l_367 == &l_15.f2 || l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
        assert (l_400 == 0 || l_400 == &l_367);
        assert (l_403 == &l_15 || l_403 == &g_62);
        assert (l_446 == &g_19 || l_446 == &l_15.f2);
        assert (l_510 == 0 || l_510 == &g_200);
        if ((safe_mul_func_uint16_t_u_u((l_513 < (safe_add_func_int16_t_s_s(((l_516 != &g_396) < 0xB25957CCL), (l_517 != g_519)))), (safe_rshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s(0xEF1A464FL, (*l_446))), (safe_mod_func_uint16_t_u_u(g_19, 0x9066L)))), 8)))))
        { /* block id: 232 */
            struct S0 **l_538 = &l_403;
            int32_t **l_551 = &g_209;
            for (g_62.f0 = 9; (g_62.f0 >= (-10)); g_62.f0 = safe_sub_func_uint32_t_u_u(g_62.f0, 1))
            { /* block id: 235 */
                struct S0 *l_541 = (void*)0;
                struct S0 l_544 = {0L,0L,6L,18446744073709551615UL};
                struct S0 l_556 = {1L,7L,-1L,1UL};
                for (l_368 = (-27); (l_368 == 26); l_368 = safe_add_func_uint64_t_u_u(l_368, 9))
                { /* block id: 238 */
                    if ((*l_446))
                        break;
                }
                (*g_396) = (*g_396);
                if (p_8)
                { /* block id: 242 */
                    if (p_8)
                        break;
                    for (g_6 = 0; (g_6 < 2); ++g_6)
                    { /* block id: 246 */
                        (*l_402) = func_52(g_19, ((void*)0 != l_538), g_62.f0);
                        /* statement id: 247 */
                        assert (l_403 == &g_62);
                        (*g_18) = (safe_mod_func_int16_t_s_s(((void*)0 != l_541), (safe_rshift_func_int16_t_s_u((((void*)0 != l_541) | p_8), 14))));
                        l_544 = (**l_538);
                    }
                }
                else
                { /* block id: 251 */
                    (***g_520) = (((**g_149) != (p_8 <= 0x0.Ep-1)) != (((((safe_mul_func_float_f_f((safe_sub_func_float_f_f((safe_mul_func_float_f_f(((void*)0 != l_551), (((safe_mul_func_float_f_f((((*g_522) <= (safe_add_func_float_f_f((*g_150), ((0x9.52BDE5p-79 != l_544.f2) != (**g_149))))) >= (**g_149)), (**g_149))) > 0x8.7428ADp+28) < 0xC.CA26BFp+62))), (**g_149))), 0x7.1p-1)) < l_544.f2) < p_8) != 0x9.3C039Cp+74) == 0x1.Fp-1));
                    l_556 = g_62;
                    if (p_8)
                        break;
                    (*g_18) = (+(!p_8));
                }
            }
        }
        else
        { /* block id: 258 */
            return &g_19;
            /* statement id: 259 */
            //assert (func_7_rv == &g_19);
        }
        return l_559;
        /* statement id: 261 */
        //assert (func_7_rv == 0);
    }
    else
    { /* block id: 262 */
        uint16_t l_564 = 0x7E82L;
        int32_t *l_565 = (void*)0;
        struct S0 l_599 = {-1L,0L,0L,0x5795398DL};
        for (p_8 = 0; (p_8 >= 49); p_8 = safe_add_func_uint16_t_u_u(p_8, 2))
        { /* block id: 265 */
            struct S0 l_576 = {0L,-5L,-1L,0x8345F794L};
            int32_t *l_600 = &g_19;
            float ***l_611 = &g_149;
            if ((safe_rshift_func_uint16_t_u_u(0x3EE4L, 3)))
            { /* block id: 266 */
                l_565 = func_24((((p_8 ^ l_564) || (-8L)) != 0x306B87F0L));
                /* statement id: 267 */
                assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
                assert (l_565 == &g_19);
                return &g_19;
                /* statement id: 268 */
                //assert (g_18 == dangling || g_18 == &g_19);
                //assert (func_7_rv == &g_19);
            }
            else
            { /* block id: 269 */
                struct S0 ***l_568 = &l_402;
                struct S0 ****l_567 = &l_568;
                struct S0 *****l_566 = &l_567;
                int32_t l_597 = 1L;
                g_569 = l_566;
                /* statement id: 270 */
                assert (g_569 == &l_567);
                for (g_62.f3 = 0; (g_62.f3 != 49); g_62.f3 = safe_add_func_int16_t_s_s(g_62.f3, 1))
                { /* block id: 273 */
                    int32_t *l_575 = &l_15.f2;
                    struct S0 l_580 = {0x0B1B8946L,-2L,0x67795B5AL,0x8DA103A0L};
                    if (p_8)
                    { /* block id: 274 */
                        return l_565;
                        /* statement id: 275 */
                        //assert (g_18 == dangling || g_18 == &g_19);
                        //assert (g_569 == dangling);
                        //assert (func_7_rv == 0);
                    }
                    else
                    { /* block id: 276 */
                        struct S0 l_574 = {0x421538CDL,0xA551108CL,5L,0x61B7E0B9L};
                        (**l_402) = l_574;
                        (*g_397) = (**g_396);
                        g_18 = l_575;
                        /* statement id: 279 */
                        assert (g_18 == &l_15.f2);
                        (*l_401) = l_575;
                        /* statement id: 280 */
                        assert (l_367 == &l_15.f2);
                    }
                    /* facts after branching */
                    assert (g_18 == &l_15.f2);
                    assert (l_367 == &l_15.f2);
                    if ((*l_575))
                    { /* block id: 282 */
                        struct S0 l_577 = {0xDF3AD5F5L,0x97D93D1BL,1L,0x776C4493L};
                        l_576 = (****l_567);
                        (***l_568) = l_577;
                        (*****g_569) = l_577;
                        (*l_401) = func_26(g_62.f3, (p_8 <= (safe_rshift_func_uint16_t_u_s(0x5ACCL, p_8))), (***l_568), l_580, ((g_6 ^ ((!p_8) && (((p_8 ^ (*l_575)) ^ 0x59193DCADF483330LL) || 65535UL))) == 0x3D13L));
                        /* statement id: 286 */
                        assert (l_367 == &g_62.f2 || l_367 == &g_19);
                    }
                    else
                    { /* block id: 287 */
                        int32_t *l_598 = &l_576.f2;
                        (*l_401) = func_26(((safe_sub_func_uint32_t_u_u((safe_mod_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u((!(safe_lshift_func_uint16_t_u_s((safe_sub_func_uint64_t_u_u((safe_add_func_uint64_t_u_u(0x08A87D9368AF208DLL, ((((*g_519) != (*g_519)) | ((&g_397 != &g_397) ^ (g_62.f0 == (safe_add_func_int32_t_s_s(l_576.f1, 0xA7BCA6CFL))))) < 0L))), (*l_575))), 6))), l_597)), 2UL)), g_62.f0)) <= p_8), p_8, (****l_567), l_580, p_8);
                        /* statement id: 288 */
                        assert (l_367 == &g_62.f2 || l_367 == &g_19);
                        l_598 = func_26(g_62.f2, p_8, l_576, (**l_402), p_8);
                        /* statement id: 289 */
                        assert (l_598 == &g_62.f2 || l_598 == &g_19);
                    }
                    /* facts after branching */
                    assert (l_367 == &g_62.f2 || l_367 == &g_19);
                    (*l_401) = func_26(l_597, p_8, (**l_402), l_580, p_8);
                }
                (**g_396) = (**g_396);
            }
            /* facts after branching */
            //assert (g_569 == dangling);
            l_576 = l_599;
            g_209 = l_600;
            for (l_15.f3 = (-18); (l_15.f3 <= 14); l_15.f3 = safe_add_func_int32_t_s_s(l_15.f3, 6))
            { /* block id: 299 */
                float ***l_604 = &g_149;
                float ****l_603 = &l_604;
                int32_t l_615 = 0xD9628E17L;
                struct S0 l_634 = {0x4597391EL,2L,2L,0x2CE783B0L};
                int32_t *l_636 = &l_15.f2;
            }
        }
        /* facts after for loop */
        assert (g_18 == &l_15.f2 || g_18 == &g_19);
        assert (l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
        //assert (g_569 == dangling || g_569 == &g_570);
        (****g_519) = p_8;
    }
    /* facts after branching */
    assert (g_18 == &l_15.f2 || g_18 == &g_19);
    assert (l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
    //assert (g_569 == dangling || g_569 == &g_570);
    if ((safe_rshift_func_int16_t_s_s(((0L && ((*l_510) <= (*g_209))) >= (((safe_lshift_func_int16_t_s_u(((safe_lshift_func_uint16_t_u_u((((safe_sub_func_int32_t_s_s((((g_62.f0 & ((safe_rshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_u(((safe_sub_func_uint64_t_u_u((p_8 <= (safe_lshift_func_uint16_t_u_u((g_62.f2 != (safe_lshift_func_uint16_t_u_s(65535UL, 13))), (safe_lshift_func_uint16_t_u_u((((safe_sub_func_uint16_t_u_u(((p_8 == (~0x8A66L)) || g_62.f0), p_8)) || g_633) ^ 0x31543DE1L), g_62.f1))))), g_19)) && g_62.f0), g_62.f1)) == g_184), l_682)) || g_6)) & g_62.f0) | l_683), (*g_18))) & g_184) > p_8), 4)) || p_8), p_8)) != g_6) == p_8)), 13)))
    { /* block id: 321 */
        for (g_6 = 0; (g_6 >= 22); g_6 = safe_add_func_uint32_t_u_u(g_6, 5))
        { /* block id: 324 */
            volatile float ****l_686 = &g_520;
            struct S0 l_689 = {0x56256E6DL,0xBC9B87A3L,0L,0x3E529422L};
            int32_t *l_711 = (void*)0;
            l_686 = &g_520;
            for (g_184 = 0; (g_184 > 60); ++g_184)
            { /* block id: 328 */
                int32_t *l_690 = &l_15.f2;
                l_689 = (**l_402);
                (*l_401) = l_690;
                /* statement id: 330 */
                assert (l_367 == &l_15.f2);
            }
            (**g_396) = (void*)0;
            /* statement id: 332 */
            assert (g_199 == 0);
            for (g_184 = 0; (g_184 != 15); g_184 = safe_add_func_int16_t_s_s(g_184, 5))
            { /* block id: 335 */
                uint8_t l_698 = 0xD7L;
                l_689.f2 = (safe_add_func_uint32_t_u_u(((safe_sub_func_uint32_t_u_u((p_8 || ((((0UL & ((+l_698) >= 0L)) != p_8) < (safe_lshift_func_int16_t_s_s((l_689.f3 ^ (safe_unary_minus_func_uint16_t_u(g_200))), ((safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(((safe_sub_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((+(-3L)), (g_184 < g_633))), p_8)) && p_8), g_184)), 0xF4A3A3F1L)) || g_62.f3)))) & g_184)), (*g_18))) == l_698), 0UL));
                (**l_402) = l_689;
                (*g_397) = (void*)0;
                l_711 = l_711;
            }
        }
        /* facts after for loop */
        assert (l_367 == &l_15.f2 || l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
    }
    else
    { /* block id: 342 */
        int32_t l_712 = 0x81C403D4L;
        uint8_t l_746 = 6UL;
        int64_t l_749 = 0xDF84ACC2E609E4DDLL;
        (*g_397) = (void*)0;
        /* statement id: 343 */
        assert (g_199 == 0);
        (*g_18) = (l_712 | ((safe_lshift_func_int16_t_s_u((safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((((safe_add_func_int64_t_s_s(((safe_sub_func_int16_t_s_s((*l_510), g_62.f1)) | (p_8 == p_8)), g_62.f1)) >= ((safe_lshift_func_uint16_t_u_u((safe_mod_func_int16_t_s_s(l_712, ((safe_rshift_func_int16_t_s_u(l_712, (safe_lshift_func_int16_t_s_u((l_712 == g_6), 8)))) | 65535UL))), g_62.f3)) && l_731)) >= l_732), 7)), 0x97CDL)), g_6)) > p_8));
        (*l_401) = func_24((safe_unary_minus_func_uint16_t_u(((((safe_mul_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s((-1L), 2)) == p_8), (safe_lshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s(((safe_mod_func_uint32_t_u_u(p_8, (g_19 || (safe_rshift_func_uint16_t_u_s(p_8, 12))))) ^ p_8), (-7L))), ((((l_746 ^ (safe_rshift_func_int16_t_s_u(g_62.f2, l_749))) > p_8) < p_8) ^ 0xB6A569083807D5FFLL))))) < l_712) == l_712) <= (*g_18)))));
        /* statement id: 345 */
        assert (g_199 == 0 || g_199 == &g_200);
        assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
        assert (l_367 == &g_19);
    }
    /* facts after branching */
    assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
    assert (l_367 == &l_15.f2 || l_367 == &g_62.f2 || l_367 == &g_19 || l_367 == 0);
    (*g_397) = (void*)0;
    /* statement id: 347 */
    assert (g_199 == 0);
    return &g_19;
    /* statement id: 348 */
    //assert (g_18 == dangling || g_18 == &g_19);
    //assert (func_7_rv == &g_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_200 g_18 g_62.f1 g_19 g_6 g_62.f3 g_62.f2 g_79 g_62.f0 g_77 g_149 g_150 g_199 g_62 g_209 g_184 g_396 g_397
 * writes: g_18 g_19 g_77 g_62.f2 g_184 g_199 g_149 g_200 g_209 g_62 g_396
 */
inline static int32_t * func_9(struct S0  p_10, uint16_t  p_11, float  p_12, int32_t * p_13, int32_t * p_14)
{ /* block id: 154 */
    int32_t **l_383 = (void*)0;
    int32_t **l_384 = &g_18;
    float ***l_385 = &g_149;
    (*l_384) = p_14;
    (*g_18) = ((0UL != (&g_149 == l_385)) > (safe_mul_func_uint16_t_u_u(1UL, g_200)));
    (*l_384) = func_20(&g_19, func_24(g_62.f1), (safe_mod_func_uint32_t_u_u((safe_add_func_uint16_t_u_u((**l_384), g_19)), (**l_384))));
    for (g_19 = 0; (g_19 > (-30)); g_19 = safe_sub_func_uint16_t_u_u(g_19, 1))
    { /* block id: 160 */
        for (g_62.f2 = 0; (g_62.f2 == (-18)); g_62.f2 = safe_sub_func_uint64_t_u_u(g_62.f2, 2))
        { /* block id: 163 */
            volatile int32_t ****l_398 = &g_396;
            (*l_398) = g_396;
            (*l_384) = p_14;
            (**g_396) = (void*)0;
            /* statement id: 166 */
            assert (g_199 == 0);
        }
    }
    return p_13;
    /* statement id: 169 */
    //assert (func_9_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_19 g_6 g_62.f3 g_62.f1 g_62.f2 g_79 g_62.f0 g_77 g_18 g_149 g_150 g_199 g_62 g_209 g_184 g_200
 * writes: g_77 g_62.f2 g_184 g_199 g_149 g_200 g_209 g_62
 */
static int32_t * func_20(int32_t * p_21, int32_t * p_22, uint8_t  p_23)
{ /* block id: 144 */
    int32_t **l_369 = &g_209;
    struct S0 *l_372 = &g_62;
    int32_t *l_379 = (void*)0;
    int32_t *l_380 = &g_62.f2;
    (*l_369) = func_24((p_23 & p_23));
    /* statement id: 145 */
    assert (g_209 == &g_19);
    (*l_380) = (safe_mod_func_int16_t_s_s(((l_372 == l_372) >= (((**l_369) == (&g_19 == p_21)) == (+(safe_rshift_func_int16_t_s_u((((~(((&l_372 != (void*)0) | (safe_rshift_func_int16_t_s_s((&l_372 != &l_372), g_62.f1))) || p_23)) > g_62.f1) & p_23), 9))))), p_23));
    (*l_369) = (*l_369);
    for (g_62.f2 = 0; (g_62.f2 <= 15); ++g_62.f2)
    { /* block id: 150 */
        if ((**l_369))
            break;
    }
    return p_22;
    /* statement id: 153 */
    //assert (func_20_rv == 0 || func_20_rv == &g_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_19 g_6 g_62.f3 g_62.f1 g_62.f2 g_79 g_62.f0 g_77 g_18 g_149 g_150 g_199 g_62 g_209 g_184 g_200 l_15.f2
 * writes: g_77 g_62.f2 g_184 g_199 g_149 g_200 g_209 g_62
 */
static int32_t * func_24(int32_t  p_25)
{ /* block id: 5 */
    int32_t *l_38 = &g_19;
    struct S0 l_130 = {-5L,0L,1L,0x26D5D5E4L};
    int32_t **l_225 = (void*)0;
    int32_t **l_226 = &g_209;
    int32_t l_261 = (-1L);
    float *l_264 = (void*)0;
    struct S0 *l_295 = &l_130;
    struct S0 **l_294 = &l_295;
    float **l_303 = &l_264;
    struct S0 l_366 = {0x87E90FEDL,0x67E6C5E4L,0x9FEB1DF3L,8UL};
    (*l_226) = func_26(func_32(p_25, p_25, ((&g_19 != l_38) & ((safe_sub_func_uint64_t_u_u((func_41(func_46((g_19 <= p_25), g_6, p_25, g_19, p_25), p_25, p_25, l_38) == 18446744073709551615UL), g_62.f1)) <= p_25)), l_38, (*l_38)), p_25, l_130, l_130, g_6);
    /* statement id: 98 */
    assert (g_209 == &g_62.f2 || g_209 == &g_19);
    (*l_226) = (*l_226);
    for (l_130.f2 = 0; (l_130.f2 <= (-15)); l_130.f2 = safe_sub_func_uint16_t_u_u(l_130.f2, 6))
    { /* block id: 102 */
        int32_t l_234 = (-10L);
        int16_t l_247 = 0L;
        float l_248 = (-0x4.3p+1);
        int32_t l_282 = 0xFF84D383L;
        struct S0 l_284 = {0xC3C3C14CL,0x033E0742L,0x6B5376D6L,0UL};
        float ***l_309 = &l_303;
        int32_t *l_322 = (void*)0;
        (*g_150) = (!(((safe_sub_func_float_f_f(((safe_add_func_float_f_f(l_234, (*l_38))) == (safe_add_func_float_f_f((safe_add_func_float_f_f(((safe_mul_func_float_f_f(((**g_149) > (safe_add_func_float_f_f(0x0.Fp+1, ((((&l_130 == (void*)0) != (safe_add_func_float_f_f((safe_sub_func_float_f_f(0x9.E5F86Dp+98, p_25)), 0x7.A63EE4p+55))) < (*g_150)) == 0x9.Bp-1)))), l_247)) >= (**g_149)), (-0x7.Bp+1))), (*g_150)))), l_248)) < p_25) <= 0xD.075437p+40));
        if ((safe_add_func_int64_t_s_s((safe_mul_func_uint16_t_u_u((safe_sub_func_int64_t_s_s(g_184, (safe_mod_func_uint64_t_u_u(((0L >= ((safe_add_func_uint64_t_u_u(p_25, (safe_sub_func_uint16_t_u_u((l_261 < ((safe_sub_func_uint32_t_u_u((*l_38), ((*g_149) == l_264))) || 0x88AFL)), (p_25 || g_62.f2))))) > 65535UL)) <= 0x4F255190L), g_62.f1)))), g_200)), g_62.f1)))
        { /* block id: 104 */
            struct S0 l_283 = {0xEB332806L,0x6E3AF0B7L,0x57CF0979L,0xA851268EL};
            (*l_226) = (void*)0;
            /* statement id: 105 */
            assert (g_209 == 0);
            for (l_247 = (-13); (l_247 <= 0); l_247 = safe_add_func_uint16_t_u_u(l_247, 1))
            { /* block id: 108 */
                struct S0 *l_279 = &l_130;
                struct S0 **l_278 = &l_279;
                int32_t l_280 = 4L;
                uint64_t l_281 = 4UL;
                (*l_226) = func_26(((((safe_rshift_func_uint16_t_u_s((safe_add_func_int32_t_s_s(((~(safe_rshift_func_int16_t_s_u(((((safe_sub_func_uint64_t_u_u(((&l_264 == &l_264) <= (safe_add_func_uint64_t_u_u(((void*)0 == l_278), l_234))), (l_280 < (((p_25 && (((l_281 == p_25) == 18446744073709551611UL) <= 1UL)) < l_247) < 0xA1925262L)))) != l_281) > l_282) <= 0x185A11B4L), (*l_38)))) ^ p_25), 0x210D50EAL)), 0)) == p_25) || 1L) ^ 0x29113732L), p_25, l_283, l_284, l_284.f1);
                /* statement id: 109 */
                assert (g_209 == &g_62.f2 || g_209 == &g_19);
                for (l_281 = 0; (l_281 < 22); l_281 = safe_add_func_uint32_t_u_u(l_281, 3))
                { /* block id: 112 */
                    int32_t l_300 = 0xCFF01D18L;
                    if (((safe_rshift_func_int16_t_s_u((safe_add_func_int32_t_s_s(((safe_mod_func_int32_t_s_s((((g_19 >= (safe_unary_minus_func_uint64_t_u((1UL != (l_294 == (void*)0))))) == 0x32B65486D1CC4FA7LL) | (safe_rshift_func_int16_t_s_s(1L, 1))), (safe_mul_func_int16_t_s_s(0x82DCL, ((p_25 || 0x988CC22BL) | p_25))))) <= l_283.f2), g_62.f0)), l_300)) < 0x770EC7795BC2652CLL))
                    { /* block id: 113 */
                        return &g_19;
                        /* statement id: 114 */
                        //assert (func_24_rv == &g_19);
                    }
                    else
                    { /* block id: 115 */
                        struct S0 *l_301 = (void*)0;
                        struct S0 *l_302 = &g_62;
                        (*l_278) = l_301;
                        /* statement id: 116 */
                        assert (l_279 == 0);
                        (*l_302) = l_283;
                    }
                    /* facts after branching */
                    assert (l_279 == 0);
                    if (l_234)
                        break;
                }
                /* facts after for loop */
                assert (l_279 == 0 || l_279 == &l_130);
                l_303 = (void*)0;
                /* statement id: 121 */
                assert (l_303 == 0);
                l_284 = (*l_295);
            }
            /* facts after for loop */
            assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
            (**g_149) = (-0x9.9p-1);
        }
        else
        { /* block id: 125 */
            uint8_t l_321 = 0xE6L;
            l_322 = func_26((((safe_add_func_uint64_t_u_u((+0x6F4F445BL), 0x185641E5C071142ALL)) <= (safe_sub_func_int64_t_s_s(l_234, ((&g_149 != l_309) <= (safe_unary_minus_func_int16_t_s(((safe_rshift_func_uint16_t_u_s((g_62.f2 != (((safe_add_func_int32_t_s_s(0xA1EFB264L, (safe_mul_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u(g_62.f0, (((((safe_rshift_func_int16_t_s_u(0L, 1)) != g_62.f0) & 0xC80CL) <= l_321) & l_284.f3))) ^ 0x56E99656D3FD831ALL), 0xC6C7L)))) < g_184) || 2L)), l_321)) & 4294967295UL))))))) <= 0xAE104904L), p_25, l_284, g_62, g_62.f0);
            /* statement id: 126 */
            assert (l_322 == &g_62.f2 || l_322 == &g_19);
        }
        /* facts after branching */
        assert (l_322 == &g_62.f2 || l_322 == &g_19 || l_322 == 0);
        for (l_247 = 2; (l_247 == (-5)); l_247 = safe_sub_func_uint64_t_u_u(l_247, 5))
        { /* block id: 130 */
            int32_t *l_325 = &l_284.f2;
            struct S0 *l_339 = &g_62;
            (*l_226) = l_325;
            /* statement id: 131 */
            assert (g_209 == &l_284.f2);
            (*l_226) = func_26((((*l_325) || (safe_mod_func_int64_t_s_s((&l_295 != g_79), (safe_sub_func_uint16_t_u_u((((safe_add_func_uint16_t_u_u((+(*g_209)), (safe_lshift_func_int16_t_s_u((safe_mod_func_uint32_t_u_u(((safe_mul_func_uint16_t_u_u(((((l_339 != (*l_294)) != g_62.f2) > ((safe_sub_func_int32_t_s_s(((safe_add_func_int64_t_s_s((safe_rshift_func_int16_t_s_u(0x3559L, p_25)), 0x620ECA3B4123FC93LL)) && g_184), (*l_325))) & 0x2525L)) || 0x4CE0L), g_62.f2)) || 1L), (-9L))), g_62.f0)))) < p_25) && (*l_38)), (*l_38)))))) && p_25), g_6, (*l_295), g_62, g_200);
            /* statement id: 132 */
            assert (g_209 == &g_62.f2 || g_209 == &g_19);
            (*l_325) = ((safe_sub_func_uint64_t_u_u((safe_add_func_int16_t_s_s((p_25 >= ((safe_add_func_uint64_t_u_u(((safe_sub_func_uint32_t_u_u((safe_add_func_int16_t_s_s((g_200 || (((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s((safe_add_func_int32_t_s_s((*g_209), (p_25 != (0x6402E7404A6E0F1FLL <= (((safe_lshift_func_uint16_t_u_s(p_25, 7)) != 0x9E56L) != (0x69C6L || ((((*g_149) != (*g_149)) || (*l_325)) & p_25))))))), 0x452FD6F0L)), (**l_226))) && p_25) && p_25)), 0x6A00L)), 1UL)) & p_25), p_25)) <= 4294967287UL)), p_25)), g_62.f2)) == g_62.f3);
            for (l_284.f1 = 0; (l_284.f1 < (-3)); l_284.f1--)
            { /* block id: 136 */
                l_366 = g_62;
            }
        }
        (*l_226) = (*l_226);
    }
    /* facts after for loop */
    assert (g_209 == &g_62.f2 || g_209 == &g_19 || g_209 == 0);
    assert (l_303 == 0 || l_303 == &l_264);
    g_200 = (8UL & g_62.f2);
    return &g_19;
    /* statement id: 143 */
    //assert (func_24_rv == &g_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_62.f2 g_6 g_62.f3 g_149 g_150 g_77 g_19 g_18 g_62.f1 g_199 g_62 g_209 l_15.f2
 * writes: g_77 g_62.f2 g_184 g_199 g_149 g_200 g_209
 */
static int32_t * func_26(uint32_t  p_27, int32_t  p_28, struct S0  p_29, struct S0  p_30, int64_t  p_31)
{ /* block id: 33 */
    struct S0 *l_137 = &g_62;
    int32_t l_140 = 1L;
    uint8_t l_173 = 0xF9L;
    float ***l_212 = &g_149;
    int32_t **l_222 = &g_209;
    if ((safe_lshift_func_uint16_t_u_u((((-1L) | ((safe_mul_func_uint16_t_u_u(g_62.f2, 0xDF94L)) || (g_6 == ((safe_rshift_func_int16_t_s_u((l_137 == l_137), (p_30.f1 & p_29.f1))) != (safe_add_func_int16_t_s_s(0x064FL, g_62.f3)))))) < l_140), 13)))
    { /* block id: 34 */
        int32_t *l_142 = (void*)0;
        int32_t **l_141 = &l_142;
        struct S0 *l_145 = &g_62;
        (*l_141) = &l_140;
        /* statement id: 35 */
        assert (l_142 == &l_140);
        for (p_28 = 0; (p_28 == 12); ++p_28)
        { /* block id: 38 */
            l_145 = (void*)0;
            /* statement id: 39 */
            assert (l_145 == 0);
            (*l_141) = &g_19;
            /* statement id: 40 */
            assert (l_142 == &g_19);
        }
        /* facts after for loop */
        assert (l_142 == &g_19 || l_142 == &l_140);
        assert (l_145 == 0 || l_145 == &g_62);
        (**g_149) = ((safe_add_func_float_f_f(((((!((void*)0 == g_149)) == (p_27 <= (**g_149))) != (safe_add_func_float_f_f(0x1.1p-1, (safe_mul_func_float_f_f((*g_150), (safe_mul_func_float_f_f(((&g_19 != (void*)0) == (((safe_add_func_float_f_f(((**g_149) <= p_30.f2), (**g_149))) == p_30.f2) != (**l_141))), (*l_142)))))))) != l_140), (**g_149))) <= 0xA.FE13ADp-65);
    }
    else
    { /* block id: 43 */
        uint16_t l_162 = 0x1E77L;
        int32_t *l_174 = (void*)0;
        int32_t *l_175 = &g_62.f2;
        int32_t *l_176 = &g_19;
        int32_t **l_177 = (void*)0;
        int32_t l_183 = (-6L);
        (*l_175) = (l_140 != (((+(((safe_add_func_int16_t_s_s(l_162, (safe_rshift_func_uint16_t_u_s(p_29.f2, (safe_add_func_uint64_t_u_u(p_27, p_29.f1)))))) || (*g_18)) | ((safe_mod_func_uint64_t_u_u((safe_add_func_uint32_t_u_u(p_29.f2, (((0xE630L == (((l_162 > (-1L)) & 1L) > g_62.f3)) | l_140) >= 4294967294UL))), 0x24A31001084B88B5LL)) <= l_173))) > p_30.f2) && 6UL));
        l_174 = l_176;
        /* statement id: 45 */
        assert (l_174 == &g_19);
        for (g_62.f2 = (-23); (g_62.f2 < 29); g_62.f2 = safe_add_func_uint64_t_u_u(g_62.f2, 1))
        { /* block id: 48 */
            int32_t *l_182 = &g_19;
            struct S0 l_191 = {0x248B132FL,0x06C70737L,-1L,0xD89A0F2DL};
            struct S0 *l_197 = &l_191;
            for (p_29.f1 = 18; (p_29.f1 < (-18)); p_29.f1 = safe_sub_func_int64_t_s_s(p_29.f1, 6))
            { /* block id: 51 */
                return l_182;
                /* statement id: 52 */
                //assert (func_26_rv == &g_19);
            }
            g_184 = l_183;
            if (((void*)0 == &l_182))
            { /* block id: 55 */
                struct S0 *l_195 = &g_62;
                int32_t *l_201 = &l_140;
                float ***l_202 = (void*)0;
                float ***l_203 = &g_149;
                (**g_149) = l_140;
                if (((safe_add_func_int64_t_s_s(g_62.f1, (safe_rshift_func_int16_t_s_s(g_62.f2, 9)))) == (safe_lshift_func_int16_t_s_u((1L & (*l_182)), p_29.f1))))
                { /* block id: 57 */
                    struct S0 **l_196 = (void*)0;
                    int32_t **l_198 = &l_174;
                    l_191 = l_191;
                    for (l_183 = 0; (l_183 <= 25); l_183 = safe_add_func_int64_t_s_s(l_183, 3))
                    { /* block id: 61 */
                        int32_t *l_194 = &g_62.f2;
                        return l_194;
                        /* statement id: 62 */
                        //assert (func_26_rv == &g_62.f2);
                    }
                    l_197 = l_195;
                    /* statement id: 64 */
                    assert (l_197 == &g_62);
                    (*l_198) = (void*)0;
                    /* statement id: 65 */
                    assert (l_174 == 0);
                }
                else
                { /* block id: 66 */
                    g_199 = (void*)0;
                    /* statement id: 67 */
                    assert (g_199 == 0);
                    if (p_29.f1)
                        continue;
                    (*l_197) = p_29;
                }
                /* facts after branching */
                assert (l_197 == &l_191 || l_197 == &g_62);
                (*l_201) = l_173;
                (*l_203) = &g_150;
            }
            else
            { /* block id: 73 */
                volatile int32_t **l_204 = &g_199;
                (*l_204) = &g_200;
                /* statement id: 74 */
                assert (g_199 == &g_200);
                (*l_204) = &g_200;
                (*g_199) = 0xE6A1E35DL;
            }
            /* facts after branching */
            assert (l_197 == &l_191 || l_197 == &g_62);
            for (p_31 = (-6); (p_31 <= (-30)); p_31 = safe_sub_func_uint64_t_u_u(p_31, 2))
            { /* block id: 80 */
                float ***l_211 = &g_149;
                int32_t **l_213 = &g_209;
                uint32_t l_223 = 0x0B73EB7BL;
                int32_t *l_224 = &l_183;
                for (l_162 = 0; (l_162 == 45); l_162 = safe_add_func_uint64_t_u_u(l_162, 1))
                { /* block id: 83 */
                    if ((*g_18))
                    { /* block id: 84 */
                        return &g_19;
                        /* statement id: 85 */
                        //assert (func_26_rv == &g_19);
                    }
                    else
                    { /* block id: 86 */
                        struct S0 *l_210 = &l_191;
                        g_209 = &g_19;
                        /* statement id: 87 */
                        assert (g_209 == &g_19);
                        (*l_210) = (*l_197);
                    }
                    /* facts after branching */
                    assert (g_209 == &g_19);
                }
                l_212 = l_211;
                (*l_213) = l_182;
                /* statement id: 92 */
                assert (g_209 == &g_19);
                (*l_224) = ((0x6EDFE9C0AA097D27LL > (safe_rshift_func_uint16_t_u_s(((safe_mul_func_int16_t_s_s((*l_182), (safe_add_func_uint16_t_u_u(((p_29.f3 != 0xD907B652L) < ((safe_mul_func_uint16_t_u_u(p_30.f0, (**l_213))) == (*l_182))), (l_222 == (void*)0))))) != p_29.f2), l_223))) == g_62.f0);
            }
        }
        /* facts after for loop */
        assert (l_174 == &g_19 || l_174 == 0);
    }
    return &g_19;
    /* statement id: 97 */
    //assert (func_26_rv == &g_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_18 g_19 g_62.f3 g_62.f2 g_62.f0 l_15.f2
 * writes:
 */
inline static uint32_t  func_32(int32_t  p_33, uint64_t  p_34, uint64_t  p_35, int32_t * p_36, int16_t  p_37)
{ /* block id: 30 */
    uint32_t l_121 = 0x95055D0CL;
    int32_t **l_122 = &g_18;
    int32_t l_129 = 1L;
    l_129 = (((l_121 || (&g_18 != l_122)) == (p_36 != &g_19)) < ((safe_add_func_uint16_t_u_u(((safe_sub_func_uint64_t_u_u(p_34, ((((safe_add_func_uint64_t_u_u((0xBE63L != (((**l_122) == g_62.f3) > (**l_122))), 0xC5172592CB3A5686LL)) & 0x8B96L) >= 9L) | 0x17DDL))) >= (**l_122)), g_62.f2)) & 0x1050BF12L));
    return g_62.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_19 g_62.f3 g_6 g_62.f0 g_62.f1 g_62.f2 g_77 g_18 l_15.f2
 * writes: g_77
 */
static uint64_t  func_41(int64_t  p_42, int16_t  p_43, float  p_44, int32_t * p_45)
{ /* block id: 14 */
    float *l_110 = &g_77;
    float **l_109 = &l_110;
    struct S0 l_116 = {0x9E1CF7F8L,0L,-9L,0x1B9AEE73L};
    if ((g_19 | g_62.f3))
    { /* block id: 15 */
        int32_t *l_95 = &g_62.f2;
        int32_t **l_94 = &l_95;
        (*l_94) = p_45;
        /* statement id: 16 */
        assert (l_95 == &g_19);
        (*l_94) = &g_19;
    }
    else
    { /* block id: 18 */
        uint8_t l_106 = 4UL;
        int32_t **l_107 = &g_18;
        float *l_108 = &g_77;
        int32_t *l_112 = (void*)0;
        int32_t **l_111 = &l_112;
        (*l_108) = ((safe_mul_func_float_f_f((g_6 != g_62.f0), (safe_mul_func_float_f_f((0x4.35785Fp+33 >= (safe_mul_func_float_f_f((safe_mul_func_float_f_f(g_62.f1, ((safe_sub_func_float_f_f(g_62.f2, g_62.f2)) < g_77))), l_106))), ((((&g_18 == l_107) >= 0x9.97EF05p-70) >= g_62.f0) < (**l_107)))))) == 0x4.B8B7E0p-67);
        l_109 = l_109;
        (*l_111) = &g_19;
        /* statement id: 21 */
        assert (l_112 == &g_19);
    }
    if ((&g_18 != &g_18))
    { /* block id: 23 */
        int32_t **l_113 = (void*)0;
        int32_t *l_115 = &g_19;
        int32_t **l_114 = &l_115;
        (*l_114) = l_110;
        /* statement id: 24 */
        assert (l_115 == &g_77);
    }
    else
    { /* block id: 25 */
        struct S0 *l_117 = &l_116;
        int16_t l_118 = 0x5478L;
        (*l_117) = l_116;
        return l_118;
    }
    return l_116.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_19 g_62.f3 g_62.f1 g_62.f2 g_79 g_62.f0
 * writes: g_77
 */
static int64_t  func_46(uint16_t  p_47, float  p_48, uint32_t  p_49, uint64_t  p_50, uint64_t  p_51)
{ /* block id: 6 */
    uint16_t l_60 = 6UL;
    struct S0 *l_61 = &g_62;
    struct S0 *l_69 = &g_62;
    struct S0 **l_78 = &l_61;
    int32_t l_91 = 0L;
    int32_t l_92 = 0x1292777EL;
    int32_t *l_93 = &l_92;
    (*l_78) = func_52((safe_sub_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((((l_60 != 0xA5D0C9ADL) & (((l_61 != &g_62) <= (safe_sub_func_int16_t_s_s(0x40C0L, ((~((safe_sub_func_uint32_t_u_u(g_19, l_60)) & ((+(&g_62 == l_69)) >= p_47))) == 0UL)))) <= g_62.f3)) > l_60) && (-2L)), g_62.f1)), l_60)), g_19, p_50);
    l_91 = ((((void*)0 != g_79) < ((safe_add_func_float_f_f((0x7.D72FAFp+77 != (g_62.f1 >= (safe_mul_func_float_f_f(((l_60 > (safe_add_func_float_f_f((safe_sub_func_float_f_f(((&g_62 == (void*)0) <= p_48), ((-(safe_add_func_float_f_f((g_62.f1 > l_60), g_62.f3))) < 0xD.35292Fp+80))), g_19))) >= (-0x1.Ap+1)), g_62.f1)))), 0x5.B79911p+30)) < 0x3.EB44D5p-8)) != g_62.f0);
    (*l_93) = (l_92 != l_92);
    return g_62.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_62.f3 g_62.f2 g_19
 * writes: g_77
 */
static struct S0 * func_52(int32_t  p_53, int64_t  p_54, int16_t  p_55)
{ /* block id: 7 */
    struct S0 *l_74 = &g_62;
    int32_t *l_75 = &g_19;
    float *l_76 = &g_77;
    (*l_76) = (((safe_add_func_float_f_f(g_62.f3, ((&g_62 != (void*)0) <= (safe_sub_func_float_f_f(((p_54 >= (l_74 != (void*)0)) >= g_62.f2), (l_75 == &g_19)))))) < 0x1.Bp+1) < (*l_75));
    return l_74;
    /* statement id: 9 */
    //assert (func_52_rv == &g_62);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_19, "g_19", print_hash_value);
    transparent_crc(g_62.f0, "g_62.f0", print_hash_value);
    transparent_crc(g_62.f1, "g_62.f1", print_hash_value);
    transparent_crc(g_62.f2, "g_62.f2", print_hash_value);
    transparent_crc(g_62.f3, "g_62.f3", print_hash_value);
    transparent_crc_bytes (&g_77, sizeof(g_77), "g_77", print_hash_value);
    transparent_crc(g_184, "g_184", print_hash_value);
    transparent_crc(g_200, "g_200", print_hash_value);
    transparent_crc_bytes (&g_523, sizeof(g_523), "g_523", print_hash_value);
    transparent_crc(g_633, "g_633", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 127
   depth: 1, occurrence: 23
XXX total union variables: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 259
   depth: 2, occurrence: 37
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 5
   depth: 7, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 4
   depth: 20, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 146

XXX times a variable address is taken: 159
XXX times a pointer is dereferenced on RHS: 127
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 44
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 100
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 15
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 19
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 482

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1358
   level: 2, occurrence: 455
   level: 3, occurrence: 13
   level: 4, occurrence: 8
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 30.1
XXX average alias set size: 1.26

XXX times a non-volatile is read: 820
XXX times a non-volatile is write: 292
XXX times a volatile is read: 13
XXX    times read thru a pointer: 6
XXX times a volatile is write: 4
XXX    times written thru a pointer: 3
XXX times a volatile is available for access: 142
XXX percentage of non-volatile access: 98.5

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 211
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 35
   depth: 2, occurrence: 35
   depth: 3, occurrence: 39
   depth: 4, occurrence: 30
   depth: 5, occurrence: 36

XXX percentage a fresh-made variable is used: 18.1
XXX percentage an existing variable is used: 81.9
********************* end of statistics **********************/

