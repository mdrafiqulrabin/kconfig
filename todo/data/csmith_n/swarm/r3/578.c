/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      259846496
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const int64_t  f0;
   volatile int32_t  f1;
   int16_t  f2;
   const uint64_t  f3;
   uint32_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int8_t g_3 = 0xDAL;
static int32_t g_31 = 6L;
static int32_t *g_30 = &g_31;
static int32_t g_39 = 4L;
static struct S0 g_62 = {-1L,1L,0L,0x5AD058BBE58ED0BDLL,0xF23D37F4L};/* VOLATILE GLOBAL g_62 */
static int32_t ** volatile g_64 = &g_30;/* VOLATILE GLOBAL g_64 */
static int32_t g_74 = 1L;
static struct S0 * volatile g_76 = &g_62;/* VOLATILE GLOBAL g_76 */
static struct S0 * volatile * volatile g_75 = &g_76;/* VOLATILE GLOBAL g_75 */
static int32_t g_80 = 0xA3B7DC4BL;
static int32_t * volatile g_79 = &g_80;/* VOLATILE GLOBAL g_79 */
static uint32_t g_91 = 18446744073709551615UL;
static uint16_t g_95 = 65533UL;
static uint16_t g_99 = 0xAD94L;
static int32_t g_104[7] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
static int32_t * volatile g_103[3][10][8] = {{{&g_104[3],&g_104[5],&g_104[5],&g_104[3],&g_104[4],(void*)0,&g_39,(void*)0},{&g_31,&g_31,&g_104[3],(void*)0,&g_31,&g_104[4],(void*)0,&g_39},{&g_104[4],&g_31,&g_39,&g_31,&g_104[4],(void*)0,&g_39,&g_104[0]},{&g_39,&g_104[5],&g_31,&g_104[4],&g_39,&g_104[4],&g_31,&g_104[5]},{&g_104[4],(void*)0,(void*)0,&g_39,&g_104[4],&g_39,(void*)0,&g_31},{&g_31,&g_31,&g_104[0],&g_31,(void*)0,&g_39,&g_39,&g_104[3]},{&g_104[5],&g_31,&g_39,&g_31,&g_31,(void*)0,&g_104[5],&g_104[5]},{&g_31,(void*)0,&g_104[5],&g_104[5],(void*)0,&g_31,&g_31,&g_39},{&g_104[4],(void*)0,&g_104[3],&g_39,&g_39,(void*)0,&g_31,&g_104[0]},{&g_104[4],&g_104[4],&g_31,&g_39,&g_31,&g_104[4],(void*)0,&g_39}},{{(void*)0,&g_31,&g_104[4],&g_104[5],&g_31,(void*)0,&g_31,&g_104[5]},{(void*)0,&g_31,(void*)0,&g_31,&g_104[0],&g_104[4],&g_39,&g_104[3]},{&g_104[4],&g_104[4],&g_104[4],&g_31,(void*)0,&g_104[5],&g_104[0],&g_31},{&g_104[4],&g_104[2],&g_31,(void*)0,&g_104[0],&g_104[4],&g_31,&g_104[4]},{(void*)0,&g_104[4],(void*)0,&g_31,&g_31,(void*)0,&g_104[4],(void*)0},{(void*)0,&g_39,&g_39,&g_39,&g_31,&g_104[4],&g_104[4],&g_104[4]},{&g_104[4],&g_39,&g_104[4],&g_104[0],&g_39,&g_104[4],&g_104[5],&g_31},{&g_104[4],&g_39,(void*)0,&g_31,(void*)0,(void*)0,&g_39,(void*)0},{&g_31,&g_104[4],(void*)0,&g_104[4],&g_31,&g_104[4],&g_104[2],&g_39},{&g_104[5],&g_104[2],(void*)0,&g_104[4],(void*)0,&g_104[5],&g_104[3],&g_104[4]}},{{&g_31,&g_104[4],(void*)0,&g_104[5],&g_104[4],&g_104[4],&g_104[2],(void*)0},{(void*)0,&g_31,(void*)0,&g_39,(void*)0,(void*)0,&g_39,(void*)0},{&g_31,&g_31,(void*)0,&g_104[2],&g_104[4],&g_104[4],&g_104[5],(void*)0},{(void*)0,&g_104[4],&g_104[4],&g_104[3],&g_104[5],(void*)0,&g_104[4],(void*)0},{&g_104[4],(void*)0,&g_39,&g_104[2],&g_104[4],&g_31,&g_104[4],(void*)0},{&g_31,(void*)0,(void*)0,&g_39,(void*)0,(void*)0,&g_31,(void*)0},{&g_39,&g_31,&g_31,&g_104[5],&g_104[4],&g_39,&g_104[0],&g_104[4]},{&g_104[4],&g_31,&g_104[4],&g_104[4],&g_104[4],&g_31,&g_39,&g_39},{&g_39,&g_104[0],(void*)0,&g_104[4],(void*)0,&g_31,&g_104[2],&g_39},{(void*)0,&g_31,&g_31,(void*)0,&g_104[4],(void*)0,&g_104[0],&g_39}}};
static int32_t * volatile g_105 = &g_104[4];/* VOLATILE GLOBAL g_105 */
static int32_t g_118 = 0x542D3F7CL;
static int64_t g_121 = 0x2417F16C3B14A51ELL;
static struct S0 g_165 = {0xF3D6CDB74EB91FBALL,0L,0xA936L,0xBAC331A2D7867E7CLL,0x7241C05FL};/* VOLATILE GLOBAL g_165 */
static uint64_t g_186 = 7UL;
static struct S0 g_206 = {0x8A6757B94B598FB1LL,0L,0L,0xE04B37A05F2A7C57LL,1UL};/* VOLATILE GLOBAL g_206 */
static volatile int16_t g_209[4] = {0x31FDL,0x31FDL,0x31FDL,0x31FDL};
static volatile int16_t *g_208[5] = {&g_209[3],&g_209[3],&g_209[3],&g_209[3],&g_209[3]};
static volatile int16_t ** volatile g_207 = &g_208[1];/* VOLATILE GLOBAL g_207 */
static volatile int16_t ** volatile * volatile g_210 = &g_207;/* VOLATILE GLOBAL g_210 */
static struct S0 *g_217 = &g_206;
static struct S0 **g_216 = &g_217;
static struct S0 *** volatile g_215 = &g_216;/* VOLATILE GLOBAL g_215 */
static int32_t * volatile * volatile g_225 = &g_79;/* VOLATILE GLOBAL g_225 */
static int32_t ** volatile g_254 = &g_30;/* VOLATILE GLOBAL g_254 */
static int32_t **g_258 = (void*)0;
static int32_t *** volatile g_257 = &g_258;/* VOLATILE GLOBAL g_257 */
static int64_t g_270 = 0x34A52FFC3B98C0DELL;
static int32_t ** volatile g_275[1] = {&g_30};
static int16_t *g_324 = &g_62.f2;
static int16_t ** const g_323[6] = {&g_324,&g_324,&g_324,&g_324,&g_324,&g_324};
static int16_t ** const *g_322[7][8] = {{&g_323[2],&g_323[2],&g_323[3],(void*)0,&g_323[3],&g_323[2],&g_323[2],&g_323[2]},{&g_323[2],(void*)0,&g_323[2],&g_323[2],(void*)0,&g_323[2],&g_323[2],&g_323[2]},{(void*)0,&g_323[2],&g_323[2],&g_323[2],(void*)0,&g_323[2],&g_323[2],(void*)0},{&g_323[2],&g_323[2],&g_323[2],&g_323[2],&g_323[3],(void*)0,&g_323[3],&g_323[2]},{&g_323[2],&g_323[3],&g_323[2],&g_323[2],&g_323[2],&g_323[2],&g_323[2],&g_323[2]},{&g_323[3],&g_323[3],&g_323[2],(void*)0,&g_323[4],(void*)0,&g_323[2],&g_323[3]},{&g_323[3],&g_323[2],&g_323[2],&g_323[2],&g_323[2],&g_323[2],&g_323[2],&g_323[3]}};
static int16_t ** const **g_321 = &g_322[1][0];
static int32_t ** volatile g_333[2][3] = {{&g_30,&g_30,&g_30},{&g_30,&g_30,&g_30}};
static int32_t ***g_374 = &g_258;
static int32_t **** volatile g_373 = &g_374;/* VOLATILE GLOBAL g_373 */
static int32_t g_396 = (-7L);
static int32_t * const g_395 = &g_396;
static int32_t * const *g_394 = &g_395;
static int32_t ** volatile g_431 = (void*)0;/* VOLATILE GLOBAL g_431 */
static int32_t ** volatile g_432 = &g_30;/* VOLATILE GLOBAL g_432 */
static int32_t g_453 = 0xBA095CF3L;
static int32_t * const *g_455 = &g_30;
static int32_t * const ** volatile g_454 = &g_455;/* VOLATILE GLOBAL g_454 */
static const uint32_t g_464 = 0x655FDF32L;
static const uint32_t g_466 = 0UL;
static const uint32_t *g_465 = &g_466;
static int32_t ** volatile g_487 = &g_30;/* VOLATILE GLOBAL g_487 */
static int32_t ** volatile g_488 = &g_30;/* VOLATILE GLOBAL g_488 */
static int32_t ** volatile g_493 = &g_30;/* VOLATILE GLOBAL g_493 */
static int64_t g_524 = 0xABE2860F0DB80E53LL;
static uint32_t g_531 = 18446744073709551614UL;
static int16_t ***g_571[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
static int32_t g_610 = 2L;
static int32_t * volatile g_612 = &g_453;/* VOLATILE GLOBAL g_612 */
static const int32_t *g_617 = &g_118;
static const int32_t **g_616 = &g_617;
static const int32_t *** volatile g_615 = &g_616;/* VOLATILE GLOBAL g_615 */
static int32_t * volatile g_618 = &g_104[3];/* VOLATILE GLOBAL g_618 */
static int32_t *g_633 = &g_31;
static int32_t ** volatile g_632 = &g_633;/* VOLATILE GLOBAL g_632 */
static int32_t ** volatile g_636 = (void*)0;/* VOLATILE GLOBAL g_636 */
static int32_t ** volatile g_639[5][6][4] = {{{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30},{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30}},{{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30},{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30}},{{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30},{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30}},{{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30},{&g_30,&g_633,&g_633,&g_30},{&g_633,&g_30,&g_633,&g_633},{&g_30,&g_30,&g_633,&g_30}},{{&g_30,&g_633,&g_633,&g_633},{&g_633,&g_633,&g_633,&g_633},{&g_633,&g_633,&g_30,&g_633},{&g_633,&g_633,&g_633,&g_633},{&g_633,&g_633,&g_633,&g_633},{&g_633,&g_633,&g_30,&g_633}}};
static int32_t ** volatile g_640[5][8][2] = {{{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0}},{{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0}},{{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0}},{{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0}},{{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0},{(void*)0,(void*)0},{&g_633,(void*)0}}};
static int32_t **g_658 = &g_30;
static int32_t ***g_657 = &g_658;
static int32_t ****g_656 = &g_657;
static int32_t *****g_655 = &g_656;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_22(void);
static int32_t * func_26(int8_t  p_27, int32_t * p_28);
static int32_t * func_41(int32_t  p_42, uint16_t  p_43);
static uint16_t  func_50(int64_t  p_51, int32_t  p_52, int32_t * p_53, int32_t * p_54);
inline static int32_t * func_56(uint16_t  p_57);
inline static uint16_t  func_58(int64_t  p_59);
static int32_t * func_65(uint64_t  p_66, struct S0 * p_67, uint16_t  p_68, int16_t  p_69);
inline static uint32_t  func_70(int32_t  p_71, int32_t * const * p_72);
static int32_t * func_108(uint32_t  p_109, int32_t * p_110, struct S0 ** p_111, int16_t  p_112);
static int32_t * func_113(int64_t  p_114, int32_t  p_115, int32_t  p_116, uint32_t  p_117);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_30 g_31 g_80 g_95 g_62.f2 g_39 g_453 g_633 g_455 g_210 g_207 g_208 g_209
 * writes: g_3 g_31 g_80 g_95 g_91 g_453 g_30 g_655
 */
static int16_t  func_22(void)
{ /* block id: 36 */
    int8_t l_29 = 0xC4L;
    int32_t **l_650 = (void*)0;
    int32_t **l_651 = &g_30;
    int32_t ***l_654 = &l_650;
    int32_t ****l_653 = &l_654;
    int32_t *****l_652[10][6][4] = {{{(void*)0,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{(void*)0,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653}},{{(void*)0,(void*)0,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,(void*)0,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,(void*)0}},{{&l_653,&l_653,(void*)0,(void*)0},{(void*)0,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{(void*)0,&l_653,&l_653,&l_653}},{{&l_653,(void*)0,&l_653,&l_653},{(void*)0,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{(void*)0,&l_653,&l_653,(void*)0},{&l_653,&l_653,(void*)0,&l_653}},{{&l_653,(void*)0,&l_653,&l_653},{&l_653,(void*)0,&l_653,&l_653},{&l_653,(void*)0,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,(void*)0,&l_653},{&l_653,&l_653,&l_653,&l_653}},{{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,(void*)0,&l_653},{&l_653,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653}},{{(void*)0,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,(void*)0,&l_653,&l_653},{&l_653,(void*)0,&l_653,&l_653},{&l_653,(void*)0,&l_653,&l_653}},{{&l_653,&l_653,&l_653,(void*)0},{(void*)0,&l_653,&l_653,&l_653},{&l_653,(void*)0,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653}},{{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,(void*)0},{(void*)0,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653}},{{&l_653,&l_653,(void*)0,&l_653},{&l_653,&l_653,&l_653,(void*)0},{&l_653,&l_653,&l_653,(void*)0},{&l_653,&l_653,(void*)0,&l_653},{&l_653,&l_653,&l_653,&l_653},{&l_653,&l_653,&l_653,&l_653}}};
    int i, j, k;
    for (g_3 = 0; (g_3 <= 1); g_3 += 6)
    { /* block id: 39 */
        uint16_t l_25 = 0x2733L;
        return l_25;
    }
    (*l_651) = func_26(l_29, g_30);
    g_655 = l_652[2][1][3];
    /* statement id: 545 */
    assert (g_655 == 0 || g_655 == &l_653);
    return (***g_210);
    /* statement id: 546 */
    //assert (g_655 == 0 || g_655 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_80 g_95 g_62.f2 g_3 g_39 g_453 g_633 g_455 g_30
 * writes: g_31 g_80 g_95 g_91 g_453
 */
static int32_t * func_26(int8_t  p_27, int32_t * p_28)
{ /* block id: 42 */
    int32_t *l_553 = &g_453;
    for (p_27 = 17; (p_27 > (-30)); p_27 -= 8)
    { /* block id: 45 */
        int32_t *l_40 = &g_39;
        for (g_31 = 0; (g_31 < 21); g_31 += 4)
        { /* block id: 48 */
            int32_t l_55 = 0x44D99649L;
            int32_t **l_641[5][6] = {{(void*)0,(void*)0,&l_40,(void*)0,(void*)0,&l_40},{(void*)0,(void*)0,&l_40,(void*)0,(void*)0,&l_40},{(void*)0,(void*)0,&l_40,(void*)0,(void*)0,&l_40},{(void*)0,(void*)0,&l_40,(void*)0,(void*)0,&l_40},{(void*)0,(void*)0,&l_40,(void*)0,(void*)0,&l_40}};
            int i, j;
        }
        for (g_80 = 14; (g_80 != (-20)); --g_80)
        { /* block id: 530 */
            int32_t *l_644 = &g_31;
            return l_644;
            /* statement id: 531 */
            //assert (func_26_rv == &g_31);
        }
        for (g_95 = 19; (g_95 > 45); g_95 += 9)
        { /* block id: 535 */
            uint32_t *l_647 = (void*)0;
            (*l_553) = (__builtin_popcountl((g_91 = g_62.f2)) == (*l_40));
            (*g_633) = ((*l_553) > p_27);
        }
    }
    (*l_553) = (*l_553);
    (**g_455) = (((uint64_t)p_27 + (uint64_t)p_27) && ((*l_553) < p_27));
    return p_28;
    /* statement id: 543 */
    //assert (func_26_rv == &g_31);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(int32_t  p_42, uint16_t  p_43)
{ /* block id: 523 */
    int32_t *l_637[3];
    int32_t *l_638 = &g_80;
    int i;
    for (i = 0; i < 3; i++)
        l_637[i] = &g_453;
    l_637[1] = &p_42;
    /* statement id: 524 */
    //assert (l_637[0] == &p_42 || l_637[0] == &g_453);
    return l_638;
    /* statement id: 525 */
    //assert (func_41_rv == &g_80);
}


/* ------------------------------------------ */
/* 
 * reads : g_80 g_209 g_165.f3 g_571 g_62.f3 g_3 g_31 g_62.f1 g_324 g_610 g_62.f4 g_165.f0 g_612 g_615 g_104 g_118 g_618 g_465 g_466 g_79 g_632
 * writes: g_80 g_121 g_571 g_206.f4 g_62.f2 g_453 g_616 g_104 g_99 g_118 g_39 g_30 g_633
 */
static uint16_t  func_50(int64_t  p_51, int32_t  p_52, int32_t * p_53, int32_t * p_54)
{ /* block id: 478 */
    uint16_t l_611 = 0x0E7CL;
    const int32_t *l_614 = &g_118;
    const int32_t **l_613 = &l_614;
    int32_t *l_628 = &g_74;
    for (g_80 = 0; (g_80 <= 3); g_80 += 1)
    { /* block id: 481 */
        int8_t l_577 = 0x8EL;
        struct S0 **l_630[8];
        int32_t l_634[5];
        int32_t **l_635 = &g_633;
        int i;
        for (i = 0; i < 8; i++)
            l_630[i] = (void*)0;
        for (i = 0; i < 5; i++)
            l_634[i] = 0x559F092AL;
        for (g_121 = 3; (g_121 >= 0); g_121 -= 1)
        { /* block id: 484 */
            uint64_t *l_559[8][1];
            uint64_t **l_558 = &l_559[5][0];
            uint64_t ***l_557 = &l_558;
            int32_t * const ** volatile *l_562 = &g_454;
            int16_t l_580[6][2] = {{0xE931L,1L},{0xE931L,1L},{0xE931L,1L},{0xE931L,1L},{0xE931L,1L},{0xE931L,1L}};
            uint32_t l_623[2][6][4] = {{{18446744073709551615UL,0x64BE8962L,0x45486C48L,0x64BE8962L},{18446744073709551615UL,0x2FA0518DL,0xE0860E16L,0x64BE8962L},{0xE0860E16L,0x64BE8962L,0xE0860E16L,0x2FA0518DL},{18446744073709551615UL,0x64BE8962L,0x45486C48L,0x64BE8962L},{18446744073709551615UL,0x2FA0518DL,0xE0860E16L,0x64BE8962L},{0xE0860E16L,0x64BE8962L,0xE0860E16L,0x2FA0518DL}},{{18446744073709551615UL,0x64BE8962L,0x45486C48L,0x64BE8962L},{18446744073709551615UL,0x2FA0518DL,0xE0860E16L,0x64BE8962L},{0xE0860E16L,0x64BE8962L,0xE0860E16L,0x2FA0518DL},{18446744073709551615UL,0x64BE8962L,0x45486C48L,0x64BE8962L},{18446744073709551615UL,0x2FA0518DL,0xE0860E16L,0x64BE8962L},{0xE0860E16L,0x64BE8962L,0xE0860E16L,0x2FA0518DL}}};
            struct S0 **l_629[3];
            int i, j, k;
            for (i = 0; i < 8; i++)
            {
                for (j = 0; j < 1; j++)
                    l_559[i][j] = &g_186;
            }
            for (i = 0; i < 3; i++)
                l_629[i] = &g_217;
            if ((((int16_t)(-(int32_t)(l_557 != &l_558)) * (int16_t)((int64_t)g_209[g_80] % (int64_t)g_165.f3)) <= (-5L)))
            { /* block id: 485 */
                int16_t **l_574[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                int16_t ***l_573 = &l_574[4];
                int16_t ****l_572 = &l_573;
                int32_t l_582 = 0x7567B505L;
                int i;
                l_562 = &g_454;
                l_582 = ((uint16_t)((uint64_t)((uint16_t)(((uint64_t)(((*l_572) = (g_571[1] = g_571[3])) != (void*)0) % (uint64_t)__builtin_clz(((int16_t)(l_577 == ((((uint32_t)9UL - (uint32_t)1L) <= (g_62.f3 != l_580[4][0])) <= (-(uint16_t)l_577))) * (int16_t)(&g_322[6][2] != (void*)0)))) || p_52) >> (uint16_t)4) + (uint64_t)p_51) << (uint16_t)0);
                /* statement id: 489 */
                assert (l_573 == 0);
            }
            else
            { /* block id: 490 */
                int8_t l_597 = 0xEDL;
                uint16_t *l_624 = &g_99;
                uint64_t l_625 = 0x1464A109D7277B6CLL;
                for (g_206.f4 = (-14); (g_206.f4 != 25); g_206.f4 += 3)
                { /* block id: 493 */
                    uint64_t l_600 = 0x9853B42015616ADCLL;
                    int64_t *l_605 = (void*)0;
                    int64_t **l_604 = &l_605;
                    const int64_t *l_607 = &g_62.f0;
                    const int64_t **l_606 = &l_607;
                    if ((*p_54))
                        break;
                    (*g_612) = (((int32_t)(p_52 = ((uint16_t)g_62.f1 * (uint16_t)((p_51 || ((int16_t)0xCB5DL % (int16_t)((int64_t)(((uint16_t)((uint16_t)l_597 + (uint16_t)((int32_t)l_600 % (int32_t)((int16_t)((*g_324) = (~(((*l_604) = &p_51) != ((*l_606) = &g_524)))) >> (int16_t)p_52))) >> (uint16_t)((int16_t)g_610 % (int16_t)p_51)) == g_62.f4) % (int64_t)l_597))) || l_611))) % (int32_t)p_51) || g_165.f0);
                    /* statement id: 499 */
                    assert (l_605 == 0 || l_605 == &p_51);
                    assert (l_607 == &g_62.f0 || l_607 == &g_524);
                    (*g_615) = l_613;
                    /* statement id: 500 */
                    assert (g_616 == &l_614);
                    if ((*p_53))
                        continue;
                }
                (*g_618) = (l_597 > p_52);
                if ((((int16_t)(((*g_465) != ((((uint16_t)p_51 << (uint16_t)l_623[0][0][0]) != l_611) & 0x29DFF944EB7B80AFLL)) & ((g_80 || (((*g_465) > p_52) == ((*l_624) = g_610))) && 2L)) >> (int16_t)p_51) || 7UL))
                { /* block id: 505 */
                    if (l_625)
                        break;
                    (*g_79) = 1L;
                }
                else
                { /* block id: 508 */
                    for (g_39 = 7; (g_39 >= 11); ++g_39)
                    { /* block id: 511 */
                        int32_t **l_631 = &g_30;
                        (*g_632) = ((*l_631) = &p_52);
                        /* statement id: 513 */
                        assert (g_30 == &p_52);
                        assert (g_633 == &p_52);
                    }
                }
                if ((*p_53))
                    continue;
            }
        }
        /* facts after for loop */
        //assert (g_633 == &p_52 || g_633 == &g_31 || g_633 == dangling);
        l_634[4] = __builtin_clzl(g_165.f3);
        (*l_635) = &l_634[4];
        /* statement id: 520 */
        assert ((g_633 >= &l_634[0] && g_633 <= &l_634[4]));
    }
    /* facts after for loop */
    //assert (g_30 == &p_52 || g_30 == dangling || g_30 == &g_118);
    assert (g_616 == &l_614 || g_616 == &g_617);
    //assert (g_633 == dangling || g_633 == &g_31);
    return l_611;
    /* statement id: 522 */
    //assert (g_30 == dangling || g_30 == &g_118);
    //assert (g_616 == dangling || g_616 == &g_617);
}


/* ------------------------------------------ */
/* 
 * reads : g_209 g_30 g_165.f2 g_3 g_225 g_79 g_91 g_215 g_216 g_62.f4 g_31 g_217 g_64 g_254 g_257 g_104 g_95 g_121 g_118 g_206.f2 g_210 g_207 g_208 g_62.f3 g_165.f0 g_165.f3 g_373 g_105 g_321 g_322 g_74 g_270 g_62.f0 g_206.f0 g_396 g_324 g_99 g_432 g_39 g_454 g_186 g_455 g_487 g_488 g_493 g_75 g_76 g_465 g_466 g_62.f2
 * writes: g_99 g_186 g_118 g_104 g_270 g_103 g_91 g_62.f4 g_30 g_62.f2 g_258 g_95 g_206.f4 g_374 g_394 g_455 g_322 g_217 g_165.f2 g_121 g_165.f4
 */
inline static int32_t * func_56(uint16_t  p_57)
{ /* block id: 243 */
    uint16_t *l_281 = &g_99;
    int32_t l_282 = 2L;
    const int16_t ***l_283 = (void*)0;
    const int16_t ****l_284 = &l_283;
    int32_t *l_292 = (void*)0;
    struct S0 **l_339 = &g_217;
    int32_t *l_398[9][3] = {{(void*)0,(void*)0,&g_74},{&g_396,&g_74,&g_74},{&g_74,(void*)0,&g_396},{&g_396,(void*)0,&g_396},{(void*)0,&g_74,&g_396},{(void*)0,(void*)0,&g_74},{&g_396,&g_74,&g_74},{&g_74,(void*)0,&g_396},{&g_396,(void*)0,&g_396}};
    int32_t **l_397 = &l_398[5][0];
    uint32_t l_469 = 1UL;
    int32_t *l_541 = &g_31;
    int32_t ***l_544 = (void*)0;
    int i, j;
    if (((uint64_t)(0L == ((int16_t)((((void*)0 != &g_216) ^ __builtin_popcountll((((*l_281) = p_57) >= (0x38252909L && ((((p_57 || l_282) < (((*l_284) = l_283) != (void*)0)) >= 0x25E57FDA3C6B0DC2LL) > p_57))))) && 0xE04204A9L) << (int16_t)l_282)) + (uint64_t)(-2L)))
    { /* block id: 246 */
        int8_t l_287 = 0x72L;
        int32_t *l_288 = (void*)0;
        int32_t *l_289 = &g_104[6];
        int64_t *l_290[7] = {&g_270,&g_121,&g_270,&g_270,&g_121,&g_270,&g_270};
        int32_t *l_291 = &g_31;
        uint32_t l_336[3];
        int32_t l_403[9];
        uint16_t *l_411 = &g_99;
        uint16_t *l_412 = &g_99;
        int64_t l_471 = 2L;
        int32_t *l_536[2];
        int32_t *l_539[9] = {(void*)0,(void*)0,&g_104[4],(void*)0,(void*)0,&g_104[4],(void*)0,(void*)0,&g_104[4]};
        int32_t *l_540 = &l_403[6];
        int i;
        for (i = 0; i < 3; i++)
            l_336[i] = 0x4894D465L;
        for (i = 0; i < 9; i++)
            l_403[i] = 0x08D93545L;
        for (i = 0; i < 2; i++)
            l_536[i] = (void*)0;
        l_282 = (((p_57 != p_57) == ((uint64_t)(g_186 = 6UL) % (uint64_t)g_209[1])) <= ((*l_289) = ((*g_30) = l_287)));
        if (((l_282 = (g_270 = __builtin_parityll(g_165.f2))) < 0xB3B63D6E52BDFDB6LL))
        { /* block id: 253 */
            return l_289;
            /* statement id: 254 */
            //assert ((func_56_rv >= &g_104[0] && func_56_rv <= &g_104[6]));
        }
        else
        { /* block id: 255 */
            int32_t *l_296 = &g_74;
            int32_t l_303[10] = {0L,0L,0L,0L,0L,0L,0L,0L,0L,0L};
            uint64_t *l_346 = (void*)0;
            const int16_t *l_381 = (void*)0;
            const int16_t **l_380 = &l_381;
            const int16_t ***l_379 = &l_380;
            int64_t l_415[4] = {0xFAC8F3660658193ELL,0xFAC8F3660658193ELL,0xFAC8F3660658193ELL,0xFAC8F3660658193ELL};
            struct S0 **l_478[7];
            int i;
            for (i = 0; i < 7; i++)
                l_478[i] = &g_217;
            if (l_282)
            { /* block id: 256 */
                int32_t l_307 = 0x99B40CF0L;
                int16_t **l_364 = (void*)0;
                uint64_t *l_368 = &g_186;
                int32_t * const *l_369 = &l_289;
                uint32_t *l_370 = &g_206.f4;
                if (p_57)
                { /* block id: 257 */
                    int32_t * volatile *l_293 = &g_103[1][4][4];
                    l_292 = l_291;
                    /* statement id: 258 */
                    assert (l_292 == &g_31);
                    (*l_293) = (*g_225);
                    /* statement id: 259 */
                    //assert (g_103[0][0][0] == &g_118 || g_103[0][0][0] == &g_39 || g_103[0][0][0] == 0 || g_103[0][0][0] == &g_31 || (g_103[0][0][0] >= &g_104[0] && g_103[0][0][0] <= &g_104[6]));
                    for (g_91 = 0; (g_91 == 37); g_91 += 4)
                    { /* block id: 262 */
                        int8_t l_317 = 0L;
                        int32_t * const *l_318 = &l_292;
                        (*l_293) = func_108(p_57, l_296, (*g_215), ((uint16_t)((*l_281) = ((int16_t)((g_62.f4 ^ (((int16_t)(*l_291) >> (int16_t)l_303[8]) ^ ((uint32_t)4294967295UL + (uint32_t)((*g_216) == (void*)0)))) <= 0xF4DC4D79L) << (int16_t)(*l_292))) + (uint16_t)8L));
                        if (p_57)
                            continue;
                        (*l_293) = func_108((((*l_281) = (-(int16_t)(g_104[5] < l_307))) || (((uint16_t)((*l_281) = (0x855315CE64B5874ELL || p_57)) - (uint16_t)(((void*)0 != &l_296) & ((int64_t)(((g_95 && ((uint16_t)((uint64_t)(-(uint32_t)p_57) - (uint64_t)(*l_289)) << (uint16_t)p_57)) < 0x4BA5L) ^ (*l_289)) % (int64_t)p_57))) || p_57)), l_288, (*g_215), g_121);
                        if ((**g_254))
                            continue;
                    }
                    /* facts after for loop */
                    //assert (g_103[0][0][0] == &g_74 || g_103[0][0][0] == &g_118 || g_103[0][0][0] == &g_39 || g_103[0][0][0] == 0 || g_103[0][0][0] == &g_31 || (g_103[0][0][0] >= &g_104[0] && g_103[0][0][0] <= &g_104[6]));
                }
                else
                { /* block id: 271 */
                    int16_t ** const ***l_325[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                    int32_t l_328 = 0x3B6ED5BFL;
                    int32_t ***l_330[8] = {&g_258,&g_258,&g_258,&g_258,&g_258,&g_258,&g_258,&g_258};
                    int32_t ****l_329 = &l_330[6];
                    int32_t l_335[8] = {0L,0x8A0DD309L,0x8A0DD309L,0L,0x8A0DD309L,0x8A0DD309L,0L,0x8A0DD309L};
                    int16_t **l_350 = &g_324;
                    int16_t ***l_349 = &l_350;
                    int i;
                    (*l_289) = (__builtin_parity(((int32_t)p_57 - (int32_t)__builtin_ffsl(((g_206.f2 > g_118) < 0L)))) != (***g_210));
                    (*l_329) = &g_258;
                    for (g_95 = (-1); (g_95 < 21); ++g_95)
                    { /* block id: 278 */
                        int32_t **l_334 = &l_291;
                    }
                    if (((int16_t)(((((*g_30) = ((int16_t)(((uint16_t)(__builtin_ffs((__builtin_clzl(((((((l_307 ^ l_307) & (p_57 & 0x9897B1F19CB7C384LL)) < (-1L)) >= p_57) <= 2L) & l_335[4])) < l_307)) ^ p_57) >> (uint16_t)9) || p_57) * (int16_t)p_57)) ^ g_62.f3) ^ 4UL) != p_57) << (int16_t)1))
                    { /* block id: 286 */
                        int64_t l_356 = 6L;
                        int32_t * const *l_363 = (void*)0;
                        (*l_289) = ((uint16_t)0x53ACL << (uint16_t)(p_57 = ((*l_281) = ((~((((*l_289) <= l_303[2]) & ((uint16_t)__builtin_parity(g_165.f0) << (uint16_t)13)) & __builtin_ctz(l_356))) && __builtin_popcountll(((int64_t)l_335[6] % (int64_t)((int16_t)((int32_t)l_303[9] % (int32_t)l_307) * (int16_t)p_57)))))));
                    }
                    else
                    { /* block id: 291 */
                        int32_t ** const l_367 = (void*)0;
                        int32_t ** const *l_366[3];
                        int32_t ** const **l_365 = &l_366[2];
                        int i;
                        for (i = 0; i < 3; i++)
                            l_366[i] = &l_367;
                        (*l_349) = l_364;
                        /* statement id: 292 */
                        assert (l_350 == 0);
                        (*l_289) = (((*l_365) = (void*)0) == ((*l_329) = (*l_329)));
                        /* statement id: 295 */
                        //assert (l_366[0] == 0 || l_366[0] == &l_367);
                    }
                    /* facts after branching */
                    assert (l_350 == 0 || l_350 == &g_324);
                }
                /* facts after branching */
                //assert (g_103[0][0][0] == &g_74 || g_103[0][0][0] == &g_118 || g_103[0][0][0] == &g_39 || g_103[0][0][0] == 0 || g_103[0][0][0] == &g_31 || (g_103[0][0][0] >= &g_104[0] && g_103[0][0][0] <= &g_104[6]));
                assert (l_292 == 0 || l_292 == &g_31);
                (*l_289) = (((*l_368) = p_57) > (l_303[8] = (g_209[1] && __builtin_ia32_crc32qi((g_62.f4 = ((*l_370) = g_165.f3)), (**l_369)))));
                (**l_369) = (((int16_t)1L >> (int16_t)13) < 0xB09B5B278B60CCDDLL);
                (*g_373) = &g_258;
            }
            else
            { /* block id: 305 */
                int32_t **l_384 = &l_288;
                (**g_254) = ((uint16_t)((int32_t)(*g_105) + (int32_t)(g_62.f4 == (((*l_284) = l_379) == (*g_321)))) % (uint16_t)((uint16_t)0xE4DEL << (uint16_t)((g_3 <= (*l_291)) & g_74)));
                /* statement id: 307 */
                assert (l_283 == &l_380);
                l_291 = ((*l_384) = l_289);
                /* statement id: 309 */
                assert ((l_288 >= &g_104[0] && l_288 <= &g_104[6]));
                assert ((l_291 >= &g_104[0] && l_291 <= &g_104[6]));
                for (g_270 = 5; (g_270 >= 0); g_270 -= 1)
                { /* block id: 312 */
                    int32_t *l_385 = (void*)0;
                    if (p_57)
                        break;
                    (*l_384) = (void*)0;
                    /* statement id: 314 */
                    assert (l_288 == 0);
                    if ((*g_79))
                        break;
                    (*l_384) = l_385;
                    for (g_91 = 0; (g_91 <= 4); g_91 += 1)
                    { /* block id: 319 */
                        uint64_t l_386 = 0x194D7DD9766D7FA7LL;
                        int32_t * const l_389 = (void*)0;
                        int32_t * const *l_388 = &l_389;
                        int32_t * const **l_387 = &l_388;
                        int32_t * const *l_391 = (void*)0;
                        int32_t * const **l_390 = &l_391;
                        int32_t * const *l_392 = &l_296;
                        int32_t * const **l_393[1][4];
                        uint32_t *l_404 = &l_336[1];
                        int i, j;
                        for (i = 0; i < 1; i++)
                        {
                            for (j = 0; j < 4; j++)
                                l_393[i][j] = &l_392;
                        }
                        (*l_289) = (__builtin_ctzl((l_386 < p_57)) && 0x2934L);
                        (*l_284) = (void*)0;
                        /* statement id: 321 */
                        assert (l_283 == 0);
                        (*l_291) = p_57;
                        (*l_384) = func_108(((*l_404) = ((l_403[6] = ((g_62.f0 != ((g_394 = l_392) == (l_397 = (void*)0))) <= ((uint32_t)((int32_t)(__builtin_ctzl(((**l_387) != (*g_225))) > __builtin_clzll(__builtin_popcountl(g_104[4]))) % (int32_t)(-3L)) - (uint32_t)0xC410BDACL))) != 0x9F8BF95130F8F43FLL)), l_385, &g_217, p_57);
                        /* statement id: 329 */
                        assert (g_394 == &l_296);
                        assert (l_397 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_283 == 0 || l_283 == &l_380);
                assert (l_288 == 0 || (l_288 >= &g_104[0] && l_288 <= &g_104[6]));
                assert (g_394 == &l_296 || g_394 == &g_395);
                assert (l_397 == 0 || (l_397 >= &l_398[0][0] && l_397 <= &l_398[8][2]));
                (*l_384) = &l_282;
                /* statement id: 332 */
                assert (l_288 == &l_282);
            }
            /* facts after branching */
            //assert (g_103[0][0][0] == &g_74 || g_103[0][0][0] == &g_118 || g_103[0][0][0] == &g_39 || g_103[0][0][0] == 0 || g_103[0][0][0] == &g_31 || (g_103[0][0][0] >= &g_104[0] && g_103[0][0][0] <= &g_104[6]));
            assert (l_283 == 0 || l_283 == &l_380);
            assert (l_288 == &l_282 || l_288 == 0);
            assert ((l_291 >= &g_104[0] && l_291 <= &g_104[6]) || l_291 == &g_31);
            assert (l_292 == 0 || l_292 == &g_31);
            assert (g_394 == &l_296 || g_394 == &g_395);
            assert (l_397 == 0 || (l_397 >= &l_398[0][0] && l_397 <= &l_398[8][2]));
            (*l_289) = p_57;
            if (((*g_30) = (*g_30)))
            { /* block id: 336 */
                int32_t l_416 = 2L;
                uint64_t l_419 = 18446744073709551614UL;
                (*g_30) = (((int16_t)((uint32_t)((int16_t)__builtin_ctzll(((l_411 = l_411) == (l_412 = &g_99))) >> (int16_t)1) % (uint32_t)((p_57 ^ (((((g_31 || (*g_30)) ^ (((p_57 == ((int32_t)(g_95 < l_415[0]) - (int32_t)0x7FD844EAL)) != l_415[0]) & g_206.f0)) <= p_57) != l_303[8]) != l_416)) ^ (-4L))) << (int16_t)8) <= l_415[2]);
                (*l_289) = ((*g_30) = (*g_79));
                (*g_30) = (l_416 ^ (((uint64_t)(p_57 & ((-8L) < ((__builtin_ctzl(p_57) < (g_396 & p_57)) && l_419))) % (uint64_t)0x78AF1776FCDEE4A8LL) | 1UL));
            }
            else
            { /* block id: 343 */
                uint32_t l_428 = 0x0A345A6BL;
                for (g_62.f4 = 0; (g_62.f4 <= 2); g_62.f4 += 1)
                { /* block id: 346 */
                    int32_t l_422 = (-1L);
                    int i;
                    l_422 = ((*l_289) = ((int16_t)l_336[g_62.f4] * (int16_t)((*g_324) = ((g_95 ^ p_57) >= l_415[2]))));
                    if (l_303[8])
                        continue;
                    for (g_91 = 0; (g_91 <= 2); g_91 += 1)
                    { /* block id: 353 */
                        uint32_t l_425 = 1UL;
                        int32_t *l_426[8] = {(void*)0,(void*)0,&g_104[4],(void*)0,(void*)0,&g_104[4],(void*)0,(void*)0};
                        int32_t **l_427 = &l_288;
                        int i;
                        l_425 = ((int16_t)0L >> (int16_t)g_99);
                        (*l_427) = l_426[7];
                        /* statement id: 355 */
                        assert ((l_288 >= &g_104[0] && l_288 <= &g_104[6]) || l_288 == 0 || (l_288 >= &l_303[0] && l_288 <= &l_303[9]));
                        if (l_428)
                            break;
                    }
                }
                /* facts after for loop */
                assert ((l_288 >= &g_104[0] && l_288 <= &g_104[6]) || l_288 == 0 || (l_288 >= &l_303[0] && l_288 <= &l_303[9]) || l_288 == &l_282);
                for (g_270 = 25; (g_270 < 1); g_270 -= 8)
                { /* block id: 361 */
                    (*g_432) = &l_403[6];
                    /* statement id: 362 */
                    assert ((g_30 >= &l_403[0] && g_30 <= &l_403[8]));
                }
                /* facts after for loop */
                assert ((g_30 >= &l_403[0] && g_30 <= &l_403[8]) || g_30 == &g_118);
            }
            /* facts after branching */
            assert ((g_30 >= &l_403[0] && g_30 <= &l_403[8]) || g_30 == &g_118);
            assert ((l_288 >= &g_104[0] && l_288 <= &g_104[6]) || l_288 == 0 || (l_288 >= &l_303[0] && l_288 <= &l_303[9]) || l_288 == &l_282);
            if (((int16_t)p_57 - (int16_t)((**g_207) && 0x977AL)))
            { /* block id: 365 */
                uint16_t l_439 = 0x6048L;
                (*g_30) = 0x972D0B17L;
                (**g_254) = (((int16_t)(((((int16_t)l_439 >> (int16_t)(p_57 || ((int16_t)l_439 * (int16_t)((uint16_t)((p_57 & (((int64_t)(((&g_186 == (void*)0) == (((p_57 > g_165.f0) < (((uint16_t)((void*)0 != g_105) * (uint16_t)p_57) && l_439)) != (*l_291))) < g_39) - (int64_t)p_57) > 0xC299F0A3863662FDLL)) == p_57) + (uint16_t)1UL)))) == 0x4D63L) & p_57) <= 1L) << (int16_t)g_165.f0) >= 0x0CA63DC5F1FE5527LL);
            }
            else
            { /* block id: 368 */
                int32_t * const l_452 = &g_453;
                int32_t * const *l_451[6] = {&l_452,&l_452,&l_452,&l_452,&l_452,&l_452};
                int32_t * const **l_450 = &l_451[0];
                int32_t *l_479 = &l_403[4];
                int i;
                (*l_284) = (*l_284);
                for (p_57 = 0; (p_57 == 46); p_57 += 8)
                { /* block id: 372 */
                    (*g_30) = (p_57 <= ((((void*)0 != &g_103[1][4][4]) | g_95) < g_62.f0));
                }
                (*g_454) = ((*l_450) = &g_30);
                /* statement id: 376 */
                //assert (l_451[0] == &g_30 || l_451[0] == &l_452);
                for (g_186 = (-18); (g_186 != 53); ++g_186)
                { /* block id: 379 */
                    const uint32_t *l_463 = &g_464;
                    const uint32_t **l_462 = &l_463;
                    uint32_t *l_470[5] = {&g_62.f4,&g_62.f4,&g_62.f4,&g_62.f4,&g_62.f4};
                    int32_t **l_472 = &l_289;
                    uint64_t **l_474 = &l_346;
                    uint64_t ***l_473 = &l_474;
                    int i;
                }
            }
        }
        /* facts after branching */
        assert ((g_30 >= &l_403[0] && g_30 <= &l_403[8]) || g_30 == &g_118);
        //assert (g_103[0][0][0] == &g_74 || g_103[0][0][0] == &g_118 || g_103[0][0][0] == &g_39 || g_103[0][0][0] == 0 || g_103[0][0][0] == &g_31 || (g_103[0][0][0] >= &g_104[0] && g_103[0][0][0] <= &g_104[6]));
        //assert (l_283 == 0 || l_283 == dangling);
        //assert ((l_288 >= &g_104[0] && l_288 <= &g_104[6]) || l_288 == 0 || l_288 == dangling || l_288 == &l_282);
        assert ((l_291 >= &g_104[0] && l_291 <= &g_104[6]) || l_291 == &g_31);
        assert (l_292 == 0 || l_292 == &g_31);
        //assert (g_394 == dangling || g_394 == &g_395);
        assert (l_397 == 0 || (l_397 >= &l_398[0][0] && l_397 <= &l_398[8][2]));
        if ((0x16D8L || 65535UL))
        { /* block id: 398 */
            int32_t l_483 = 0x1BA8990CL;
            int32_t * const **l_512 = &g_455;
            int32_t *l_522 = &l_483;
            (*g_454) = (*g_454);
lbl_518:
            for (g_91 = (-17); (g_91 <= 34); g_91 += 1)
            { /* block id: 402 */
                int32_t *l_489 = &l_282;
                l_483 = ((**g_254) = (*g_105));
                for (l_471 = 0; (l_471 != (-1)); --l_471)
                { /* block id: 407 */
                    int32_t *l_490 = &g_31;
                    for (g_62.f2 = 1; (g_62.f2 >= 0); g_62.f2 -= 1)
                    { /* block id: 410 */
                        int32_t *l_486 = &l_403[6];
                        int i, j;
                        (*g_321) = (*g_321);
                        (*g_487) = l_486;
                        /* statement id: 412 */
                        assert ((g_30 >= &l_403[0] && g_30 <= &l_403[8]));
                        (*g_488) = &l_483;
                        /* statement id: 413 */
                        assert (g_30 == &l_483);
                        return l_490;
                        /* statement id: 414 */
                        //assert (g_30 == dangling);
                        //assert (func_56_rv == &g_31);
                    }
                    for (g_206.f4 = 0; (g_206.f4 != 27); g_206.f4++)
                    { /* block id: 418 */
                        struct S0 * volatile *l_494 = &g_217;
                        int64_t l_505 = 0xD05D88306CF942CELL;
                        uint32_t *l_508 = &l_336[1];
                        int32_t l_509 = 0x427DAAF3L;
                        (*g_493) = l_489;
                        /* statement id: 419 */
                        assert (g_30 == &l_282);
                        (*l_494) = (*g_75);
                        /* statement id: 420 */
                        assert (g_217 == &g_62);
                        (*l_289) = ((uint32_t)(*g_465) % (uint32_t)((((int16_t)((0x3D4E0716L < (((*g_324) = (((int16_t)((*l_489) = ((int16_t)((int16_t)p_57 * (int16_t)(p_57 < (g_95 = l_505))) << (int16_t)(*l_490))) << (int16_t)5) | ((uint16_t)p_57 * (uint16_t)__builtin_parityl(((*l_508) = (*l_291)))))) | p_57)) == l_509) >> (int16_t)10) & 18446744073709551615UL) | 0x9221L));
                    }
                }
            }
            (**g_455) = (*l_289);
            if (((l_483 > (g_62.f3 < (((*g_30) = (((*l_291) && (((*l_281) = g_466) <= ((int16_t)p_57 >> (int16_t)10))) > g_62.f3)) || l_282))) <= g_62.f2))
            { /* block id: 433 */
                int16_t *l_517 = &g_206.f2;
                for (g_186 = (-17); (g_186 <= 5); ++g_186)
                { /* block id: 436 */
                    (***l_512) = (l_517 != (void*)0);
                    if ((*l_289))
                        continue;
                }
            }
            else
            { /* block id: 440 */
                int32_t * const *l_527 = &l_292;
                int32_t *l_534[10][10][2] = {{{&g_104[4],&g_31},{&l_403[6],&g_453},{&g_104[5],&g_104[2]},{(void*)0,&g_80},{&g_31,&l_282},{&g_104[4],&l_282},{&g_31,&g_80},{(void*)0,&g_104[2]},{&g_104[5],&g_453},{&l_403[6],&g_31}},{{&g_104[4],&g_80},{&l_282,&l_403[6]},{&g_104[2],&g_104[2]},{&g_31,&l_403[6]},{&l_483,&g_104[2]},{&g_104[4],&g_39},{&l_483,&g_104[4]},{&g_453,&g_104[4]},{&g_80,&g_31},{&g_80,(void*)0}},{{&g_31,&g_104[5]},{&l_403[3],&l_403[6]},{&l_403[6],&g_104[4]},{&g_104[4],&l_282},{&g_104[2],&g_104[2]},{&g_31,&g_31},{&g_80,&l_483},{&l_403[6],&g_104[4]},{&g_453,&l_483},{&g_80,&g_453}},{{&g_31,&g_453},{&g_80,&l_483},{&g_453,&g_104[4]},{&l_403[6],&l_483},{&g_80,&g_31},{&g_31,&g_104[2]},{&g_104[2],&l_282},{&g_104[4],&g_104[4]},{&l_403[6],&l_403[6]},{&l_403[3],&g_104[5]}},{{&g_31,(void*)0},{&g_80,&g_31},{&g_80,&g_104[4]},{&g_80,&g_31},{&g_80,(void*)0},{&g_31,&g_104[5]},{&l_403[3],&l_403[6]},{&l_403[6],&g_104[4]},{&g_104[4],&l_282},{&g_104[2],&g_104[2]}},{{&g_31,&g_31},{&g_80,&l_483},{&l_403[6],&g_104[4]},{&g_453,&l_483},{&g_80,&g_453},{&g_31,&g_453},{&g_80,&l_483},{&g_453,&g_104[4]},{&l_403[6],&l_483},{&g_80,&g_31}},{{&g_31,&g_104[2]},{&g_104[2],&l_282},{&g_104[4],&g_104[4]},{&l_403[6],&l_403[6]},{&l_403[3],&g_104[5]},{&g_31,(void*)0},{&g_80,&g_31},{&g_80,&g_104[4]},{&g_80,&g_31},{&g_80,(void*)0}},{{&g_31,&g_104[5]},{&l_403[3],&l_403[6]},{&l_403[6],&g_104[4]},{&g_104[4],&l_282},{&g_104[2],&g_104[2]},{&g_31,&g_31},{&g_80,&l_483},{&l_403[6],&g_104[4]},{&g_453,&l_483},{&g_80,&g_453}},{{&g_31,&g_453},{&g_80,&l_483},{&g_453,&g_104[4]},{&l_403[6],&l_483},{&g_80,&g_31},{&g_31,&g_104[2]},{&g_104[2],&l_282},{&g_104[4],&g_104[4]},{&l_403[6],&l_403[6]},{&l_403[3],&g_104[5]}},{{&g_31,(void*)0},{&g_80,&g_31},{&g_80,&g_104[4]},{&g_80,&g_31},{&g_80,(void*)0},{&g_31,&g_104[5]},{&l_403[3],&l_403[6]},{&l_403[6],&g_104[4]},{&g_104[4],&l_282},{&g_104[2],&g_104[2]}}};
                int i, j, k;
                if (g_206.f0)
                    goto lbl_518;
                for (l_287 = 0; (l_287 > (-15)); l_287 -= 3)
                { /* block id: 444 */
                    int32_t *l_521 = &g_80;
                }
                (*l_289) = (-5L);
            }
        }
        else
        { /* block id: 462 */
            struct S0 **l_537 = &g_217;
            int32_t *l_538 = &l_403[6];
            l_538 = func_108(l_282, func_108(p_57, (l_536[1] = l_289), l_537, p_57), l_537, (*l_291));
            /* statement id: 464 */
            //assert ((l_536[0] >= &g_104[0] && l_536[0] <= &g_104[6]) || l_536[0] == 0);
            assert ((l_538 >= &g_104[0] && l_538 <= &g_104[6]));
        }
        /* facts after branching */
        assert (g_30 == &l_282 || (g_30 >= &l_403[0] && g_30 <= &l_403[8]) || g_30 == &g_118);
        assert (g_217 == &g_62 || g_217 == &g_206);
        //assert ((l_536[0] >= &g_104[0] && l_536[0] <= &g_104[6]) || l_536[0] == 0);
        return l_541;
        /* statement id: 466 */
        //assert (g_30 == dangling || g_30 == &g_118);
        //assert (func_56_rv == &g_31);
    }
    else
    { /* block id: 467 */
        uint32_t *l_542[5] = {&g_206.f4,&g_206.f4,&g_206.f4,&g_206.f4,&g_206.f4};
        int32_t l_543 = (-1L);
        uint32_t l_545 = 4294967295UL;
        int16_t *l_548 = (void*)0;
        int16_t *l_549 = &g_165.f2;
        struct S0 ***l_550[7] = {&g_216,&l_339,&g_216,&g_216,&l_339,&g_216,&g_216};
        struct S0 ****l_551 = &l_550[0];
        int32_t l_552 = 0xA919443BL;
        int i;
        l_552 = (((l_543 = (*g_465)) & ((((l_545 = ((void*)0 == l_544)) == 5L) ^ 18446744073709551607UL) || ((*l_549) = (((int16_t)((*g_324) = l_545) << (int16_t)12) & p_57)))) ^ (&l_339 != ((*l_551) = l_550[0])));
    }
    for (p_57 = 0; p_57 < 3; p_57 += 1)
    {
        for (g_121 = 0; g_121 < 10; g_121 += 1)
        {
            for (g_165.f4 = 0; g_165.f4 < 8; g_165.f4 += 1)
            {
                g_103[p_57][g_121][g_165.f4] = &g_453;
            }
        }
    }
    //assert (g_103[0][0][0] == &g_453 || g_103[0][0][0] == &g_39 || g_103[0][0][0] == 0 || g_103[0][0][0] == &g_31 || (g_103[0][0][0] >= &g_104[0] && g_103[0][0][0] <= &g_104[6]));
    return (*g_64);
    /* statement id: 476 */
    //assert (func_56_rv == &g_118);
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_31 g_75 g_79 g_3 g_80 g_91 g_105 g_99 g_118 g_39 g_104 g_30 g_62.f3 g_62.f0 g_207 g_208 g_209 g_165.f1 g_186 g_254 g_257 g_165.f0 g_62.f1 g_225
 * writes: g_30 g_74 g_80 g_95 g_99 g_104 g_121 g_91 g_3 g_206.f4 g_62.f4 g_62.f2 g_258 g_186 g_270 g_118 g_79
 */
inline static uint16_t  func_58(int64_t  p_59)
{ /* block id: 55 */
    struct S0 *l_61 = &g_62;
    struct S0 **l_60 = &l_61;
    int32_t *l_63 = (void*)0;
    int32_t *l_73 = &g_74;
    uint32_t *l_90[7][9] = {{&g_91,&g_91,(void*)0,&g_91,&g_91,&g_91,&g_91,&g_91,(void*)0},{&g_91,&g_91,(void*)0,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91},{&g_91,(void*)0,&g_91,(void*)0,&g_91,&g_91,&g_91,(void*)0,&g_91},{&g_91,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91},{&g_91,(void*)0,&g_91,(void*)0,&g_91,&g_91,&g_91,(void*)0,&g_91},{&g_91,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91,&g_91},{&g_91,(void*)0,&g_91,(void*)0,&g_91,&g_91,&g_91,(void*)0,&g_91}};
    int32_t l_92 = 7L;
    uint16_t *l_93 = (void*)0;
    uint16_t *l_94 = &g_95;
    int32_t *l_96 = &g_80;
    int32_t l_97 = 1L;
    uint16_t *l_98 = &g_99;
    int32_t **l_276[10];
    int i, j;
    for (i = 0; i < 10; i++)
        l_276[i] = &l_96;
    (*l_60) = (void*)0;
    /* statement id: 56 */
    assert (l_61 == 0);
    (*g_64) = l_63;
    /* statement id: 57 */
    assert (g_30 == 0);
    (*g_225) = func_65(g_31, ((*l_60) = (void*)0), ((*l_98) = (func_70(((*l_73) = p_59), &g_30) && ((int32_t)((*l_96) = (((*l_94) = ((p_59 != (((uint64_t)(((((uint32_t)((int16_t)__builtin_popcountl((l_92 = p_59)) % (int16_t)65535UL) % (uint32_t)g_31) >= g_80) && p_59) || 1UL) % (uint64_t)0x18188558B047C147LL) > p_59)) >= g_91)) | p_59)) + (int32_t)l_97))), l_97);
    /* statement id: 241 */
    assert (g_30 == &g_118);
    assert (g_79 == &g_118);
    //assert (g_258 == dangling || g_258 == 0);
    return g_209[1];
}


/* ------------------------------------------ */
/* 
 * reads : g_105 g_99 g_118 g_75 g_79 g_39 g_104 g_64 g_30 g_91 g_62.f3 g_3 g_62.f0 g_207 g_208 g_209 g_165.f1 g_186 g_254 g_257 g_80 g_165.f0 g_62.f1
 * writes: g_80 g_104 g_99 g_121 g_91 g_3 g_30 g_74 g_206.f4 g_62.f4 g_62.f2 g_258 g_186 g_270 g_118
 */
static int32_t * func_65(uint64_t  p_66, struct S0 * p_67, uint16_t  p_68, int16_t  p_69)
{ /* block id: 68 */
    int32_t **l_100 = &g_30;
    int32_t *l_101 = (void*)0;
    int32_t *l_102 = &g_80;
    int32_t l_271 = 9L;
    int32_t *l_274 = &g_118;
    (*g_105) = ((*l_102) = (&g_79 != l_100));
    for (g_99 = (-9); (g_99 <= 17); ++g_99)
    { /* block id: 73 */
        uint16_t l_119[1][10] = {{0x77DFL,0x77DFL,0x77DFL,0x77DFL,0x77DFL,0x77DFL,0x77DFL,0x77DFL,0x77DFL,0x77DFL}};
        int64_t *l_120 = &g_121;
        struct S0 **l_251 = &g_217;
        int32_t *l_259[8] = {&g_104[4],&g_104[4],&g_104[4],&g_104[4],&g_104[4],&g_104[4],&g_104[4],&g_104[4]};
        int32_t * const *l_268 = &l_102;
        uint64_t *l_269[5][10] = {{&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186},{&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186},{&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186},{&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186},{&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186,&g_186}};
        int i, j;
        l_259[6] = func_108(p_68, func_113(((((g_118 ^ func_70(p_69, &g_30)) & l_119[0][4]) | ((*l_120) = g_39)) && (&l_101 != (void*)0)), p_68, p_66, g_104[4]), l_251, p_68);
        /* statement id: 226 */
        //assert (l_259[0] == &g_118 || (l_259[0] >= &g_104[0] && l_259[0] <= &g_104[6]));
        (*g_105) = (l_271 = ((**l_268) = ((((int16_t)((((uint32_t)((uint32_t)p_66 - (uint32_t)func_70((0x6B9971ADL >= ((uint16_t)(*l_102) << (uint16_t)2)), l_268)) % (uint32_t)p_68) > g_104[4]) ^ ((g_186 = 18446744073709551615UL) == ((((g_270 = (p_69 >= p_68)) < 0L) ^ g_62.f3) != p_68))) % (int16_t)9UL) || (-1L)) | g_104[6])));
    }
    /* facts after for loop */
    //assert (g_258 == dangling || g_258 == 0);
    for (g_186 = 9; (g_186 < 49); ++g_186)
    { /* block id: 235 */
        (*l_100) = (*g_64);
    }
    (*l_100) = func_113(g_165.f0, p_69, ((*l_274) = g_62.f1), p_66);
    /* statement id: 239 */
    assert (g_30 == &g_118);
    return (*l_100);
    /* statement id: 240 */
    //assert (func_65_rv == &g_118);
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_79
 * writes: g_80 g_118
 */
inline static uint32_t  func_70(int32_t  p_71, int32_t * const * p_72)
{ /* block id: 60 */
    struct S0 *l_78[5];
    struct S0 **l_77[4] = {&l_78[3],&l_78[3],&l_78[3],&l_78[3]};
    int32_t l_81 = 1L;
    int i;
    for (i = 0; i < 5; i++)
        l_78[i] = (void*)0;
    (*g_79) = (g_75 == l_77[1]);
    l_81 = l_81;
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads : g_62.f4 g_64 g_30 g_254 g_257
 * writes: g_62.f4 g_30 g_62.f2 g_258
 */
static int32_t * func_108(uint32_t  p_109, int32_t * p_110, struct S0 ** p_111, int16_t  p_112)
{ /* block id: 213 */
    p_111 = p_111;
    for (g_62.f4 = 13; (g_62.f4 != 13); g_62.f4 += 9)
    { /* block id: 217 */
        (*g_254) = (*g_64);
        for (g_62.f2 = 0; (g_62.f2 == (-1)); g_62.f2 -= 4)
        { /* block id: 221 */
            (*g_257) = &p_110;
            /* statement id: 222 */
            assert (g_258 == &p_110);
        }
    }
    /* facts after for loop */
    //assert (g_258 == &p_110 || g_258 == 0 || g_258 == dangling);
    return p_110;
    /* statement id: 225 */
    //assert (g_258 == dangling || g_258 == 0);
    //assert (func_108_rv == &g_118 || func_108_rv == &g_74 || func_108_rv == 0 || func_108_rv == &g_206.f4 || func_108_rv == &g_62.f4 || (func_108_rv >= &g_104[0] && func_108_rv <= &g_104[6]));
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_30 g_91 g_104 g_62.f3 g_79 g_3 g_75 g_105 g_99 g_74 g_39 g_62.f0 g_207 g_208 g_209 g_165.f1 g_186
 * writes: g_80 g_91 g_3 g_104 g_30 g_74 g_206.f4 g_118
 */
static int32_t * func_113(int64_t  p_114, int32_t  p_115, int32_t  p_116, uint32_t  p_117)
{ /* block id: 75 */
    int32_t l_128[3];
    uint16_t *l_132 = (void*)0;
    int32_t *l_135[2][4] = {{&g_104[4],&g_104[4],&g_104[4],&g_104[4]},{&g_104[4],&g_104[4],&g_104[4],&g_104[4]}};
    int32_t l_196 = 0xFF2BCAE1L;
    uint16_t l_224 = 0xBC6DL;
    uint32_t *l_245 = (void*)0;
    uint32_t *l_246 = &g_206.f4;
    struct S0 ***l_247 = &g_216;
    uint16_t *l_250 = &l_224;
    int i, j;
    for (i = 0; i < 3; i++)
        l_128[i] = 0x43E010D3L;
    if (((int64_t)(((*g_64) != (void*)0) || p_116) - (int64_t)((uint16_t)((int16_t)p_115 << (int16_t)l_128[2]) >> (uint16_t)((((uint16_t)(!g_91) + (uint16_t)((void*)0 != l_132)) > (((uint16_t)(((g_80 = l_128[2]) > (-6L)) | g_104[4]) % (uint16_t)65528UL) & 1L)) > g_62.f3))))
    { /* block id: 77 */
        (*g_79) = ((int16_t)p_117 >> (int16_t)15);
    }
    else
    { /* block id: 79 */
        const int32_t *l_142 = (void*)0;
        int32_t l_147 = 2L;
        int32_t *l_160[4][8][3] = {{{&g_118,&g_118,&g_118},{&g_118,&g_74,&g_74},{&g_118,&g_118,&g_118},{&g_74,(void*)0,&g_74},{&g_74,(void*)0,&g_118},{&g_74,&g_74,&g_74},{&g_118,(void*)0,&g_74},{&g_74,(void*)0,&g_74}},{{&g_118,&g_118,&g_118},{&g_74,&g_74,&g_118},{&g_118,&g_118,&g_118},{&g_74,&g_74,&g_74},{&g_118,&g_118,&g_118},{&g_74,(void*)0,&g_74},{&g_74,&g_74,&g_118},{&g_74,&g_118,&g_118}},{{&g_118,(void*)0,&g_118},{&g_118,&g_118,&g_74},{&g_118,&g_74,&g_74},{&g_74,(void*)0,&g_74},{&g_118,&g_74,&g_118},{&g_74,&g_74,(void*)0},{(void*)0,&g_118,&g_74},{&g_74,&g_74,(void*)0}},{{(void*)0,(void*)0,&g_74},{&g_74,&g_74,(void*)0},{&g_118,&g_118,&g_118},{(void*)0,&g_74,(void*)0},{&g_118,&g_118,&g_118},{(void*)0,&g_74,&g_74},{&g_74,(void*)0,(void*)0},{(void*)0,&g_74,&g_74}}};
        struct S0 *l_163[3];
        int32_t **l_169[9] = {&g_30,&g_30,&g_30,&g_30,&g_30,&g_30,&g_30,&g_30,&g_30};
        int16_t *l_234 = &g_165.f2;
        int16_t **l_233 = &l_234;
        int16_t ** const *l_232 = &l_233;
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_163[i] = (void*)0;
        if (((int16_t)((uint16_t)0x6F09L >> (uint16_t)7) - (int16_t)(((&g_74 == l_142) || ((uint64_t)((uint16_t)l_147 << (uint16_t)9) % (uint64_t)(p_117 & ((uint16_t)p_117 * (uint16_t)func_70(__builtin_bswap32(l_147), &g_30))))) || g_91)))
        { /* block id: 80 */
            return &g_118;
            /* statement id: 81 */
            //assert (func_113_rv == &g_118);
        }
        else
        { /* block id: 82 */
            uint32_t l_150 = 0x04FC3DD1L;
            int32_t **l_168[10] = {(void*)0,&l_135[0][3],(void*)0,(void*)0,&l_135[0][3],(void*)0,(void*)0,&l_135[0][3],(void*)0,(void*)0};
            int i;
            l_150 = (*g_105);
            l_147 = (-1L);
lbl_167:
            for (g_91 = 0; (g_91 <= 6); g_91 += 1)
            { /* block id: 87 */
                const int32_t l_151 = 1L;
                int32_t *l_159[4][3][8] = {{{(void*)0,(void*)0,&g_118,&g_118,&g_74,&g_74,&g_74,&g_118},{&g_118,&g_118,&g_118,&g_74,(void*)0,&g_118,&g_118,(void*)0},{&g_74,&g_118,(void*)0,&g_74,&g_118,&g_74,(void*)0,&g_118}},{{&g_74,(void*)0,&g_118,&g_118,(void*)0,&g_74,&g_118,&g_118},{&g_118,&g_118,&g_74,&g_74,&g_74,&g_118,&g_118,(void*)0},{(void*)0,&g_74,&g_118,&g_74,&g_118,&g_118,(void*)0,&g_118}},{{&g_118,&g_118,(void*)0,&g_118,&g_118,&g_74,&g_118,&g_74},{(void*)0,(void*)0,&g_118,&g_118,&g_74,&g_74,&g_74,&g_118},{&g_118,&g_118,&g_118,&g_74,(void*)0,&g_118,&g_118,(void*)0}},{{&g_74,&g_118,(void*)0,&g_74,&g_118,&g_74,(void*)0,&g_118},{&g_74,(void*)0,&g_118,&g_118,(void*)0,&g_74,&g_118,&g_118},{&g_118,&g_118,&g_74,&g_74,&g_74,&g_118,&g_118,(void*)0}}};
                int32_t **l_158 = &l_159[2][2][5];
                int32_t * const *l_161 = &l_135[1][1];
                uint32_t *l_162 = &l_150;
                struct S0 *l_164 = &g_165;
                int32_t **l_166 = &l_135[0][1];
                int i, j, k;
                for (g_80 = 0; (g_80 <= 6); g_80 += 1)
                { /* block id: 90 */
                    for (g_3 = 6; (g_3 >= 0); g_3 -= 1)
                    { /* block id: 93 */
                        int i;
                        if (g_104[g_3])
                            break;
                        if (p_116)
                            continue;
                        g_104[g_91] = (l_151 ^ g_99);
                    }
                    if (p_117)
                        goto lbl_167;
                }
                if (g_104[g_91])
                    break;
                g_104[g_91] = ((uint16_t)(((*l_162) = ((int16_t)func_70(((uint16_t)(((*l_158) = &g_74) != (l_160[0][4][2] = &p_115)) >> (uint16_t)(18446744073709551615UL & g_104[g_91])), l_161) * (int16_t)0x11A8L)) > (l_163[2] == l_164)) << (uint16_t)11);
                (*l_166) = (*l_161);
            }
            (*g_64) = (void*)0;
            /* statement id: 107 */
            assert (g_30 == 0);
        }
        /* facts after branching */
        assert (g_30 == 0);
        //assert (l_160[0][0][0] == &p_115 || l_160[0][0][0] == 0 || l_160[0][0][0] == &g_74 || l_160[0][0][0] == &g_118);
        (*g_64) = (*g_64);
        for (g_74 = 0; (g_74 != (-14)); --g_74)
        { /* block id: 112 */
            int32_t *l_172 = &g_39;
            int32_t l_179 = 1L;
            uint64_t *l_184 = (void*)0;
            uint64_t *l_185 = &g_186;
            uint16_t *l_187 = &g_95;
            int16_t *l_188 = (void*)0;
            int16_t ** const *l_235 = (void*)0;
            l_172 = l_172;
            if (p_117)
                continue;
        }
        (*g_64) = (void*)0;
    }
    (*g_79) = (((uint16_t)((uint16_t)g_39 * (uint16_t)(g_62.f0 >= ((int16_t)(((((*l_246) = p_114) < (l_247 != (void*)0)) || (**g_207)) && (__builtin_popcountl(g_165.f1) <= __builtin_clzl((((*l_250) = (((uint16_t)g_104[1] * (uint16_t)0x9379L) || g_186)) != g_186)))) * (int16_t)p_115))) % (uint16_t)1L) != g_62.f0);
    return &g_118;
    /* statement id: 212 */
    //assert (func_113_rv == &g_118);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_22();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc(g_39, "g_39", print_hash_value);
    transparent_crc(g_62.f0, "g_62.f0", print_hash_value);
    transparent_crc(g_62.f1, "g_62.f1", print_hash_value);
    transparent_crc(g_62.f2, "g_62.f2", print_hash_value);
    transparent_crc(g_62.f3, "g_62.f3", print_hash_value);
    transparent_crc(g_62.f4, "g_62.f4", print_hash_value);
    transparent_crc(g_74, "g_74", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_91, "g_91", print_hash_value);
    transparent_crc(g_95, "g_95", print_hash_value);
    transparent_crc(g_99, "g_99", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_104[i], "g_104[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_118, "g_118", print_hash_value);
    transparent_crc(g_121, "g_121", print_hash_value);
    transparent_crc(g_165.f0, "g_165.f0", print_hash_value);
    transparent_crc(g_165.f1, "g_165.f1", print_hash_value);
    transparent_crc(g_165.f2, "g_165.f2", print_hash_value);
    transparent_crc(g_165.f3, "g_165.f3", print_hash_value);
    transparent_crc(g_165.f4, "g_165.f4", print_hash_value);
    transparent_crc(g_186, "g_186", print_hash_value);
    transparent_crc(g_206.f0, "g_206.f0", print_hash_value);
    transparent_crc(g_206.f1, "g_206.f1", print_hash_value);
    transparent_crc(g_206.f2, "g_206.f2", print_hash_value);
    transparent_crc(g_206.f3, "g_206.f3", print_hash_value);
    transparent_crc(g_206.f4, "g_206.f4", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        transparent_crc(g_209[i], "g_209[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_270, "g_270", print_hash_value);
    transparent_crc(g_396, "g_396", print_hash_value);
    transparent_crc(g_453, "g_453", print_hash_value);
    transparent_crc(g_464, "g_464", print_hash_value);
    transparent_crc(g_466, "g_466", print_hash_value);
    transparent_crc(g_524, "g_524", print_hash_value);
    transparent_crc(g_531, "g_531", print_hash_value);
    transparent_crc(g_610, "g_610", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 143
XXX total union variables: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 168
   depth: 2, occurrence: 47
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 233

XXX times a variable address is taken: 551
XXX times a pointer is dereferenced on RHS: 85
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 151
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 1034

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 516
   level: 2, occurrence: 57
   level: 3, occurrence: 16
   level: 4, occurrence: 14
XXX number of pointers point to pointers: 119
XXX number of pointers point to scalars: 106
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 29.2
XXX average alias set size: 1.58

XXX times a non-volatile is read: 608
XXX times a non-volatile is write: 391
XXX times a volatile is read: 53
XXX    times read thru a pointer: 10
XXX times a volatile is write: 42
XXX    times written thru a pointer: 7
XXX times a volatile is available for access: 653
XXX percentage of non-volatile access: 91.3

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 167
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 22
   depth: 2, occurrence: 22
   depth: 3, occurrence: 35
   depth: 4, occurrence: 30
   depth: 5, occurrence: 25

XXX percentage a fresh-made variable is used: 14.8
XXX percentage an existing variable is used: 85.2
********************* end of statistics **********************/

