/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      923880466
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int16_t  f0;
   const float  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 5UL;
static int32_t g_37 = 0x86992F1EL;
static int32_t g_41 = 1L;
static volatile int32_t g_63 = 0x35A60C43L;/* VOLATILE GLOBAL g_63 */
static int32_t * const g_97 = &g_37;
static int32_t * const *g_96 = &g_97;
static volatile union U0 g_99 = {0x27ABL};/* VOLATILE GLOBAL g_99 */
static int32_t g_105 = 0x26996DCEL;
static uint32_t g_116 = 4294967295UL;
static float g_130 = 0x0.2408B3p+61;
static float g_131 = (-0x1.Ap-1);
static int16_t g_148 = 0xD506L;
static float g_149 = 0xD.0B1440p+59;
static int16_t g_181 = (-8L);
static union U0 g_184 = {-4L};
static union U0 g_186 = {0x0C1FL};
static union U0 *g_185 = &g_186;
static int32_t *g_192 = &g_37;
static int32_t **g_191 = &g_192;
static int32_t ***g_190 = &g_191;
static int32_t ****g_189 = &g_190;
static int32_t **** const *g_188 = &g_189;
static const int16_t g_202 = 0xF842L;
static int16_t g_211 = (-9L);
static union U0 *g_221 = (void*)0;
static union U0 ** volatile g_220 = &g_221;/* VOLATILE GLOBAL g_220 */
static int32_t ** volatile g_235 = &g_192;/* VOLATILE GLOBAL g_235 */
static int32_t ** volatile g_238 = &g_192;/* VOLATILE GLOBAL g_238 */
static uint16_t g_268 = 0x0890L;
static union U0 g_279 = {0xE30FL};
static const int32_t *g_284 = &g_105;
static const int32_t ** volatile g_283 = &g_284;/* VOLATILE GLOBAL g_283 */
static uint32_t g_371 = 18446744073709551606UL;
static uint32_t * volatile g_392 = &g_116;/* VOLATILE GLOBAL g_392 */
static uint32_t * volatile *g_391 = &g_392;
static union U0 g_394 = {0xAA44L};
static uint16_t g_463 = 1UL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
inline static const int32_t  func_45(uint32_t  p_46, int32_t * const  p_47, const union U0  p_48, uint16_t  p_49);
static int32_t * func_50(float  p_51, float  p_52, int32_t * p_53, float  p_54, uint32_t  p_55);
static float  func_58(int16_t  p_59);
inline static int32_t * func_64(int16_t  p_65);
inline static int32_t  func_71(const int32_t * p_72);
static int32_t * func_73(int32_t  p_74);
static int16_t  func_79(int32_t  p_80, union U0  p_81);
inline static union U0  func_83(uint16_t  p_84, int32_t * const * p_85, int32_t * const  p_86, int32_t * p_87, int32_t  p_88);
static int32_t * const * func_89(int16_t  p_90, const uint16_t  p_91, int32_t * p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_37 g_41 g_63 g_96 g_99 g_97 g_116 g_105 g_188 g_130 g_184 g_202 g_189 g_190 g_184.f0 g_181 g_211 g_220 g_186.f0 g_192 g_191 g_235 g_238 g_221 g_283 g_279.f0 g_148 g_149 g_99.f0 g_284 g_268 g_371 g_279.f2 g_394 g_394.f0 g_392 g_185 g_186
 * writes: g_3 g_37 g_41 g_96 g_105 g_116 g_130 g_131 g_148 g_181 g_63 g_185 g_188 g_211 g_221 g_192 g_149 g_186.f2 g_186.f0 g_268 g_190 g_284 g_184.f0 g_371 g_279.f2 g_394.f0
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    uint16_t l_62 = 0x891FL;
    int32_t l_469 = (-1L);
    const int32_t l_488 = 8L;
    int32_t * const l_492 = &l_469;
    const union U0 l_493 = {1L};
    int32_t *l_494 = &g_105;
    if ((g_3 , (+(((int32_t)g_3 + (int32_t)g_3) & (g_3 < 0x02314AF1L)))))
    { /* block id: 37 */
        int32_t l_366 = 1L;
        if (g_3)
        { /* block id: 38 */
            int32_t l_42 = 7L;
            for (g_3 = 0; (g_3 != 52); g_3 += 1)
            { /* block id: 41 */
                int32_t l_40 = 0x8CCA6991L;
                for (g_37 = 0; (g_37 == 18); g_37 += 3)
                { /* block id: 44 */
                    g_41 = __builtin_parityl(l_40);
                    return l_42;
                }
            }
        }
        else
        { /* block id: 49 */
            int32_t *l_44 = &g_37;
            int32_t **l_43 = &l_44;
            (*l_43) = (void*)0;
            /* statement id: 50 */
            assert (l_44 == 0);
            return g_41;
        }
        l_469 = func_45(g_3, func_50(((float)g_3 - (float)func_58(((int16_t)l_62 - (int16_t)(&g_37 != ((*g_191) = (g_63 , func_64(g_41))))))), l_366, &l_366, g_202, l_62), g_394, g_394.f0);
        /* statement id: 307 */
        //assert (g_185 == dangling || g_185 == &g_186 || g_185 == &g_184 || g_185 == 0);
        assert (g_221 == &g_186 || g_221 == 0);
        assert (g_284 == &g_105 || g_284 == &g_37);
        (**g_188) = (*g_189);
    }
    else
    { /* block id: 309 */
        int16_t *l_481 = (void*)0;
        int16_t *l_482 = (void*)0;
        int16_t *l_483 = &g_184.f0;
        int16_t *l_484 = &g_394.f0;
        int32_t l_487 = (-8L);
        float *l_489 = &g_149;
        int32_t l_490 = 0L;
        (*g_191) = (***g_189);
        (*l_489) = ((((int16_t)((*l_484) = (((int16_t)g_105 << (int16_t)((int16_t)(g_148 = 0xBD32L) / (int16_t)3L)) <= ((int16_t)2L + (int16_t)((*l_483) = ((int16_t)((*g_392) < (~l_469)) + (int16_t)0x288FL))))) * (int16_t)((int32_t)__builtin_ffsll(((((((((g_186.f0 <= (g_186.f0 <= 0x3E78L)) >= 0xA181L) > l_487) , 4294967288UL) & 0x26658B07L) < l_62) , (*g_185)) , g_268)) + (int32_t)0UL)) , l_488) <= g_37);
        l_490 = ((*****g_188) = (**g_235));
    }
    /* facts after branching */
    //assert (g_185 == dangling || g_185 == &g_186 || g_185 == &g_184 || g_185 == 0);
    assert (g_221 == &g_186 || g_221 == 0);
    assert (g_284 == &g_105 || g_284 == &g_37);
    (**g_190) = ((+(0x6EC54ABDL == func_45(l_62, l_492, l_493, g_63))) , l_494);
    /* statement id: 318 */
    assert (g_192 == &g_105);
    return (*l_494);
}


/* ------------------------------------------ */
/* 
 * reads : g_96 g_97 g_37
 * writes:
 */
inline static const int32_t  func_45(uint32_t  p_46, int32_t * const  p_47, const union U0  p_48, uint16_t  p_49)
{ /* block id: 304 */
    int32_t *l_468 = (void*)0;
    l_468 = (*g_96);
    /* statement id: 305 */
    assert (l_468 == &g_37);
    return (*l_468);
}


/* ------------------------------------------ */
/* 
 * reads : g_188 g_189 g_190 g_191 g_37 g_371 g_3 g_116 g_279.f2
 * writes: g_192 g_371 g_130 g_37 g_279.f2 g_149
 */
static int32_t * func_50(float  p_51, float  p_52, int32_t * p_53, float  p_54, uint32_t  p_55)
{ /* block id: 248 */
    int32_t l_367 = 0L;
    int32_t *l_368 = &g_37;
    uint32_t *l_369 = (void*)0;
    uint32_t *l_370 = &g_371;
    float *l_376 = (void*)0;
    float *l_377 = &g_130;
    int32_t l_380 = 0xE8225371L;
    union U0 l_385 = {1L};
    int32_t l_416 = 2L;
    const int32_t ***l_449 = (void*)0;
    const int32_t ****l_448 = &l_449;
    int32_t *l_467 = &g_37;
    (****g_188) = l_368;
    /* statement id: 249 */
    assert (g_192 == &g_37);
    (**g_190) = l_368;
    (*l_368) = ((0xCB85B4EBL <= (0x6666EC8DL & (((*l_370) = 0xB6E1421FL) , ((int32_t)(((uint32_t)(*l_368) % (uint32_t)((((*l_377) = 0xF.AA5749p+8) , (((g_371 <= (*p_53)) ^ ((((int32_t)(__builtin_clzl(p_55) <= p_55) - (int32_t)(*l_368)) , (*p_53)) || p_55)) & p_55)) && g_116)) <= (-1L)) + (int32_t)(*l_368))))) ^ l_380);
    for (g_279.f2 = 26; (g_279.f2 > (-26)); g_279.f2 -= 4)
    { /* block id: 256 */
        union U0 *l_395 = &g_394;
        int32_t l_413 = 0x395D112DL;
        uint32_t l_426 = 0xDB310052L;
        int32_t l_456 = 0x881E371CL;
        int32_t l_465 = 1L;
        g_149 = 0x6.2p+1;
    }
    /* facts after for loop */
    return l_467;
    /* statement id: 303 */
    //assert (func_50_rv == &g_37);
}


/* ------------------------------------------ */
/* 
 * reads : g_268 g_116 g_191 g_188 g_189 g_190 g_211 g_99.f0 g_284 g_105 g_37 g_96 g_97 g_279.f0 g_220 g_221 g_202 g_3 g_148
 * writes: g_192 g_37 g_184.f0 g_221 g_130
 */
static float  func_58(int16_t  p_59)
{ /* block id: 245 */
    union U0 l_354 = {-1L};
    const int32_t *l_364 = &g_37;
    int32_t l_365 = (-1L);
    l_365 = (((l_354 , p_59) , (p_59 | (g_268 || __builtin_ctzl((+(((int16_t)((int32_t)l_354.f0 / (int32_t)((g_116 >= __builtin_popcountll((((uint16_t)((uint32_t)((func_71(l_364) , (g_202 <= 4UL)) | p_59) % (uint32_t)p_59) / (uint16_t)p_59) <= p_59))) , g_99.f0)) % (int16_t)p_59) | 0xC1F3D91AL)))))) ^ g_148);
    return g_99.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_96 g_99 g_97 g_41 g_37 g_3 g_116 g_105 g_188 g_130 g_63 g_184 g_202 g_189 g_190 g_184.f0 g_181 g_211 g_220 g_186.f0 g_192 g_191 g_235 g_238 g_221 g_283 g_279.f0 g_148 g_149 g_99.f0 g_284
 * writes: g_96 g_37 g_105 g_116 g_41 g_130 g_131 g_148 g_181 g_63 g_185 g_188 g_211 g_221 g_192 g_149 g_186.f2 g_186.f0 g_268 g_190 g_284 g_184.f0
 */
inline static int32_t * func_64(int16_t  p_65)
{ /* block id: 53 */
    uint16_t l_75 = 0x6A96L;
    int32_t *l_353 = (void*)0;
    (*g_97) = (~((uint16_t)((int32_t)func_71(func_73(l_75)) - (int32_t)(((uint16_t)0x6BE4L - (uint16_t)(0x3130L <= ((__builtin_parityl(p_65) == ((-1L) <= g_3)) != p_65))) ^ 0L)) * (uint16_t)65526UL));
    /* statement id: 241 */
    assert (g_192 == &g_105 || g_192 == 0 || g_192 == &g_37);
    (***g_189) = (**g_190);
    return l_353;
    /* statement id: 243 */
    //assert (func_64_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_191 g_188 g_189 g_190 g_211 g_99.f0 g_284 g_105 g_37 g_96 g_97 g_279.f0 g_220 g_221 g_202 g_116 g_3
 * writes: g_192 g_37 g_184.f0 g_221 g_130
 */
inline static int32_t  func_71(const int32_t * p_72)
{ /* block id: 226 */
    uint32_t l_312 = 0x5E02EBC2L;
    int32_t *l_313 = (void*)0;
    union U0 l_325 = {0L};
    float ***l_326 = (void*)0;
    int32_t *** const l_330 = &g_191;
    int16_t *l_331 = &g_184.f0;
    int16_t l_332 = 0xD04EL;
    uint32_t *l_340 = &g_116;
    uint32_t **l_339 = &l_340;
    float *l_341 = &g_130;
    int32_t * const * const *l_344 = &g_96;
    int32_t * const * const **l_343 = &l_344;
    int32_t * const * const ***l_342 = &l_343;
    int16_t l_348 = (-1L);
    if (l_312)
    { /* block id: 227 */
        const int32_t l_324 = 0x747AEA97L;
        float *l_329 = &g_131;
        float **l_328 = &l_329;
        float *** const l_327 = &l_328;
        (*g_191) = l_313;
        /* statement id: 228 */
        assert (g_192 == 0);
        (**g_96) = ((int32_t)((uint32_t)((((uint32_t)((int16_t)((((((****g_188) = l_313) == &l_324) ^ (l_326 == l_327)) <= g_211) > g_99.f0) >> (int16_t)9) - (uint32_t)0xDAC5A14FL) & l_324) , 0xDD64F156L) % (uint32_t)4294967295UL) - (int32_t)(*g_284));
    }
    else
    { /* block id: 231 */
        (**g_96) = (*g_284);
    }
    (**g_96) = (((*l_331) = ((void*)0 != l_330)) >= (l_332 < g_279.f0));
    (*g_220) = (*g_220);
    (****l_343) = ((((int32_t)(g_202 && (((float)(((*l_339) = l_313) == p_72) - (float)((*l_341) = 0x0.8993ECp+83)) , (g_116 , ((void*)0 == l_342)))) / (int32_t)((int32_t)((~g_3) < 65534UL) % (int32_t)0x8C7E989DL)) >= (**g_96)) , (****l_343));
    /* statement id: 239 */
    assert (l_340 == &g_116 || l_340 == 0);
    return l_348;
}


/* ------------------------------------------ */
/* 
 * reads : g_96 g_99 g_97 g_41 g_37 g_3 g_116 g_105 g_188 g_130 g_63 g_184 g_202 g_189 g_190 g_184.f0 g_181 g_211 g_220 g_186.f0 g_192 g_191 g_235 g_238 g_221 g_283 g_279.f0 g_148 g_149
 * writes: g_96 g_37 g_105 g_116 g_41 g_130 g_131 g_148 g_181 g_63 g_185 g_188 g_211 g_221 g_192 g_149 g_186.f2 g_186.f0 g_268 g_190 g_284
 */
static int32_t * func_73(int32_t  p_74)
{ /* block id: 54 */
    int16_t l_93 = 0xE20BL;
    int32_t * const **l_98 = &g_96;
    union U0 l_102 = {0x4B80L};
    int32_t l_103 = 0x3D57951FL;
    int32_t *l_104 = &g_105;
    int32_t *l_106 = (void*)0;
    (*l_104) = (p_74 & (((int16_t)(-(int16_t)func_79(p_74, ((!0x83395465L) , func_83(p_74, ((*l_98) = func_89(l_93, ((uint16_t)(((((*l_98) = g_96) != (g_99 , &g_97)) ^ ((*l_104) = (((((uint32_t)((((*g_97) = ((l_102 , 0UL) >= p_74)) ^ l_103) <= 0x03BAL) / (uint32_t)p_74) <= p_74) || p_74) == p_74))) > 0xAE3649E8L) << (uint16_t)g_41), l_104)), g_97, l_106, p_74)))) + (int16_t)p_74) , p_74));
    /* statement id: 223 */
    assert (g_192 == &g_105 || g_192 == 0 || g_192 == &g_37);
    (*l_104) = (-1L);
    return (*g_238);
    /* statement id: 225 */
    //assert (func_73_rv == &g_105 || func_73_rv == 0 || func_73_rv == &g_37);
}


/* ------------------------------------------ */
/* 
 * reads : g_188 g_189 g_190 g_191 g_220 g_221 g_97 g_37 g_116 g_192 g_105 g_186.f0 g_283 g_3 g_41 g_279.f0 g_148 g_149
 * writes: g_186.f2 g_192 g_186.f0 g_185 g_268 g_190 g_211 g_284 g_37 g_116 g_131
 */
static int16_t  func_79(int32_t  p_80, union U0  p_81)
{ /* block id: 173 */
    const uint16_t l_256 = 65535UL;
    const uint32_t *l_269 = &g_3;
    const int32_t *l_289 = &g_105;
    uint32_t l_300 = 0x816CB2FFL;
    uint16_t *l_306 = &g_268;
    uint32_t *l_307 = &g_116;
    int32_t l_308 = (-3L);
    float *l_309 = &g_131;
    float **l_311 = (void*)0;
    float ***l_310 = &l_311;
    for (p_80 = (-16); (p_80 <= (-12)); p_80 += 4)
    { /* block id: 176 */
        uint32_t l_246 = 0x297C0C01L;
        const int32_t *l_282 = &g_37;
        int16_t *l_288 = &g_211;
        if ((0x0F59ADD7L ^ (p_81.f0 != l_246)))
        { /* block id: 177 */
            for (p_81.f2 = 0; (p_81.f2 < 4); p_81.f2++)
            { /* block id: 180 */
                int32_t *l_251 = &g_105;
                for (g_186.f2 = (-3); (g_186.f2 > (-12)); g_186.f2 -= 2)
                { /* block id: 183 */
                    (****g_188) = &p_80;
                    /* statement id: 184 */
                    assert (g_192 == &p_80);
                }
                /* facts after for loop */
                assert (g_192 == &p_80 || g_192 == &g_105 || g_192 == 0 || g_192 == &g_37);
                (**g_190) = l_251;
                /* statement id: 186 */
                assert (g_192 == &g_105);
                for (g_186.f0 = 0; (g_186.f0 <= 14); g_186.f0 += 2)
                { /* block id: 189 */
                    union U0 **l_257 = &g_185;
                    uint16_t *l_266 = (void*)0;
                    uint16_t *l_267 = &g_268;
                    if (((uint16_t)((l_256 , (((*l_257) = &p_81) == (*g_220))) & ((int16_t)(((int32_t)(*g_97) - (int32_t)p_81.f2) == (&g_116 != ((((uint32_t)g_116 + (uint32_t)p_81.f0) > ((uint16_t)((*l_267) = (__builtin_popcountl(l_246) == (***g_190))) >> (uint16_t)6)) , l_269))) >> (int16_t)9)) >> (uint16_t)1))
                    { /* block id: 192 */
                        (*g_189) = (*g_189);
                    }
                    else
                    { /* block id: 194 */
                        union U0 *l_278 = &g_279;
                        (***g_189) = (((*g_220) != (((uint16_t)p_81.f2 * (uint16_t)(((int32_t)((0x7F17L | p_81.f0) > (+(g_105 && l_256))) - (int32_t)((uint16_t)(+l_256) - (uint16_t)0x8384L)) >= g_186.f0)) , &p_81)) , (void*)0);
                        /* statement id: 195 */
                        assert (g_192 == 0);
                        l_278 = ((*l_257) = &p_81);
                        /* statement id: 197 */
                        assert (l_278 == &p_81);
                    }
                    /* facts after branching */
                    assert (g_185 == &p_81);
                    assert (g_192 == 0 || g_192 == &g_105);
                    return p_81.f0;
                    /* statement id: 199 */
                    //assert (g_185 == dangling);
                }
                /* facts after for loop */
                for (g_211 = (-25); (g_211 <= (-12)); g_211++)
                { /* block id: 203 */
                    return p_81.f0;
                }
            }
            /* facts after for loop */
                        (*g_283) = l_282;
            /* statement id: 207 */
            assert (g_284 == &g_37);
            (*g_97) = ((uint16_t)(!(l_288 == &g_148)) * (uint16_t)(*l_282));
        }
        else
        { /* block id: 209 */
            (****g_188) = (void*)0;
            /* statement id: 210 */
            assert (g_192 == 0);
            (*g_97) = l_256;
        }
        (*g_97) = (-1L);
    }
    l_289 = l_269;
    /* statement id: 215 */
    assert (l_289 == &g_3);
    (*l_310) = (((*l_309) = ((g_105 <= (((((float)(((float)((float)((l_308 = ((*l_307) = ((uint16_t)(((uint16_t)g_3 * (uint16_t)(l_300 < (~(g_186.f0 = (*l_289))))) && (g_41 , ((((uint16_t)(((*l_289) < (((uint16_t)(*l_289) >> (uint16_t)(((((*l_306) = (*l_289)) && g_279.f0) ^ p_81.f0) & p_80)) != 5L)) == p_80) >> (uint16_t)p_80) == g_148) , 0x904A074EL))) * (uint16_t)(*l_289)))) , g_186.f0) * (float)(*l_289)) / (float)(*l_289)) > (*l_289)) + (float)0x3.BEA07Ap-51) != p_80) == (*l_289)) < 0xB.AF087Ep-55)) == g_149)) , (void*)0);
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads : g_97 g_37 g_3 g_116 g_105 g_41 g_99 g_96 g_188 g_130 g_63 g_184 g_202 g_189 g_190 g_184.f0 g_181 g_211 g_220 g_186.f0 g_192 g_191 g_235 g_238
 * writes: g_116 g_41 g_130 g_131 g_148 g_105 g_37 g_181 g_63 g_185 g_188 g_211 g_221 g_192 g_149
 */
inline static union U0  func_83(uint16_t  p_84, int32_t * const * p_85, int32_t * const  p_86, int32_t * p_87, int32_t  p_88)
{ /* block id: 61 */
    uint32_t l_111 = 0x0F05BA84L;
    int32_t *l_113 = &g_105;
    int32_t **l_112 = &l_113;
    int32_t ***l_114 = &l_112;
    uint32_t *l_115 = &g_116;
    const int32_t *l_118 = &g_105;
    const int32_t ** const l_117 = &l_118;
    const int32_t **l_139 = &l_118;
    const int32_t ***l_138 = &l_139;
    float l_199 = (-0x8.3p+1);
    union U0 l_234 = {0x58CCL};
    union U0 l_243 = {0L};
    if (((((*g_97) | __builtin_ffs((*g_97))) <= __builtin_ffsl((g_41 = ((uint16_t)(((*l_115) = __builtin_ctzll((((int16_t)l_111 << (int16_t)13) != (((*l_114) = l_112) != &p_87)))) , 0x67BEL) >> (uint16_t)(&p_86 == l_117))))) >= p_88))
    { /* block id: 65 */
        const int32_t ***l_142 = &l_139;
        uint16_t l_150 = 0x1085L;
        const int32_t ** const *l_152 = &l_139;
        const int32_t ** const **l_151 = &l_152;
        for (g_116 = 0; (g_116 >= 44); g_116 += 2)
        { /* block id: 68 */
            int32_t l_126 = 0xEAAC298BL;
            float *l_129 = &g_130;
            const int32_t ****l_140 = (void*)0;
            const int32_t ****l_141 = (void*)0;
            int16_t *l_147 = &g_148;
            g_131 = (((((uint16_t)p_88 << (uint16_t)4) > (((!((float)0x6.267706p-69 / (float)(p_88 == (l_126 == (**l_117))))) > ((float)(((*l_129) = p_84) != __builtin_clz(g_37)) * (float)p_84)) , 4294967291UL)) <= p_88) , g_105);
            (*g_97) = ((uint32_t)((((((**l_112) = (((g_41 < 0x24C43DCCL) , ((uint32_t)l_126 + (uint32_t)((int16_t)(((((l_142 = l_138) != (((uint16_t)g_116 << (uint16_t)((uint16_t)((g_99 , p_88) >= p_84) >> (uint16_t)((*l_147) = ((*g_97) == p_88)))) , &l_112)) > (*g_97)) >= g_3) || (*l_113)) + (int16_t)0x4D78L))) ^ 1UL)) >= 4294967291UL) & l_150) <= 9UL) < g_41) / (uint32_t)0x583F0299L);
            (**l_138) = (*l_112);
        }
        (*l_151) = &l_117;
        /* statement id: 77 */
        assert (l_152 == &l_117);
    }
    else
    { /* block id: 78 */
        uint32_t l_165 = 0x640828D0L;
        int32_t * const *l_174 = &l_113;
        uint32_t l_212 = 0xD79527A0L;
        int32_t l_213 = 2L;
        union U0 l_225 = {0x6D5BL};
        for (g_105 = (-22); (g_105 <= 3); g_105 += 1)
        { /* block id: 81 */
            return g_99;
            /* statement id: 82 */
                    }
        (*l_113) = (g_41 <= (((g_3 != 9L) == ((uint16_t)(((((*l_115) = (((int16_t)((void*)0 != (*g_96)) % (int16_t)((uint16_t)((int32_t)((*g_97) = ((((float)__builtin_ctz(((*l_113) = l_165)) * (float)((((float)p_88 + (float)p_84) <= 0xF.6D738Fp-46) >= 0xA.6A42CAp+25)) == 0xB.34A9EDp+42) , 0x687184D5L)) / (int32_t)l_165) / (uint16_t)p_84)) & l_165)) <= l_165) && (**l_139)) && p_84) - (uint16_t)0xC279L)) && (-1L)));
        for (g_37 = 0; (g_37 >= 5); g_37 += 9)
        { /* block id: 90 */
            float *l_170 = &g_130;
            int32_t *l_182 = &g_37;
            union U0 * const l_183 = &g_184;
            int32_t l_201 = 0L;
            float l_222 = (-0x8.2p+1);
            (*l_170) = p_84;
            if (__builtin_clzll(g_37))
            { /* block id: 92 */
                int32_t * const ***l_197 = (void*)0;
                int16_t *l_198 = &g_148;
                int32_t *l_200 = (void*)0;
                for (g_105 = (-26); (g_105 >= 20); g_105 += 4)
                { /* block id: 95 */
                    int32_t **l_173 = &l_113;
                    int32_t * const **l_175 = (void*)0;
                    int32_t * const **l_176 = &l_174;
                    int16_t *l_179 = &g_148;
                    int16_t *l_180 = &g_181;
                    int32_t l_187 = 0xFEA62FCBL;
                    (*l_173) = (*p_85);
                    /* statement id: 96 */
                    assert (l_113 == &g_37);
                    if ((*g_97))
                        continue;
                    if ((p_88 != (((((*l_176) = l_174) != (void*)0) , func_89((**l_174), ((g_99 , ((int16_t)((*l_180) = ((**l_117) <= (((*l_179) = __builtin_ia32_crc32qi((**l_173), g_37)) > 0xED70L))) * (int16_t)0xFC2CL)) || 0xC16ADBBAL), l_182)) == (void*)0)))
                    { /* block id: 101 */
                        g_63 = (**l_174);
                        g_185 = l_183;
                        /* statement id: 103 */
                        assert (g_185 == &g_184);
                    }
                    else
                    { /* block id: 104 */
                        int32_t **l_193 = &l_182;
                        l_187 = (-9L);
                        g_188 = g_188;
                        (*l_193) = (*g_96);
                        if ((*g_97))
                            break;
                    }
                }
                /* facts after for loop */
                assert (l_113 == &g_37 || l_113 == &g_105);
                l_201 = ((**l_174) >= (((!((g_130 >= (g_63 == ((**g_96) , p_84))) , ((int16_t)((*l_198) = ((void*)0 != l_197)) >> (int16_t)(p_84 , (p_84 , g_37))))) >= g_41) != (*l_182)));
                l_201 = (p_84 != 1L);
            }
            else
            { /* block id: 114 */
                return (*l_183);
                /* statement id: 115 */
                            }
            /* facts after branching */
            assert (l_113 == &g_37 || l_113 == &g_105);
            if (__builtin_parityl((g_41 > ((g_202 , (l_213 = (((**l_174) > (-1L)) & ((uint16_t)((g_211 = (((int16_t)(g_202 , ((((uint16_t)((uint16_t)1UL >> (uint16_t)9) - (uint16_t)((void*)0 != (*g_189))) , (g_184.f0 || g_63)) & g_181)) / (int16_t)g_105) , 1L)) != l_212) >> (uint16_t)15)))) | (*p_86)))))
            { /* block id: 119 */
                g_185 = (void*)0;
                /* statement id: 120 */
                assert (g_185 == 0);
                for (g_211 = 3; (g_211 < 11); g_211 += 4)
                { /* block id: 123 */
                    union U0 *l_218 = &g_186;
                    for (g_41 = (-6); (g_41 > (-6)); g_41 += 8)
                    { /* block id: 126 */
                        union U0 **l_219 = &g_185;
                        (*g_220) = ((*l_219) = l_218);
                        /* statement id: 128 */
                        assert (g_185 == &g_186);
                        assert (g_221 == &g_186);
                    }
                }
                /* facts after for loop */
                assert (g_185 == &g_186 || g_185 == 0);
            }
            else
            { /* block id: 131 */
                const int32_t l_228 = 0x7F8201C6L;
                if (((**l_174) < (*l_118)))
                { /* block id: 132 */
                    l_213 = __builtin_ffsll(g_186.f0);
                    for (l_165 = 0; (l_165 == 50); l_165++)
                    { /* block id: 136 */
                        return l_225;
                        /* statement id: 137 */
                                            }
                    for (g_41 = 11; (g_41 > 12); g_41 += 4)
                    { /* block id: 141 */
                        int16_t l_229 = 1L;
                        l_229 = l_228;
                        (*l_170) = p_84;
                    }
                }
                else
                { /* block id: 145 */
                    g_105 = (*g_192);
                    if ((*p_86))
                        break;
                    for (g_181 = 0; (g_181 <= (-26)); g_181 -= 4)
                    { /* block id: 150 */
                        (****g_188) = (void*)0;
                        /* statement id: 151 */
                        assert (g_192 == 0);
                    }
                    /* facts after for loop */
                    assert (g_192 == 0 || g_192 == &g_37);
                }
                /* facts after branching */
                assert (g_192 == 0 || g_192 == &g_37);
                (*l_170) = ((float)(*l_182) + (float)(**l_117));
                if ((*p_86))
                    break;
            }
            /* facts after branching */
            assert (g_192 == 0 || g_192 == &g_37);
            return l_234;
            /* statement id: 157 */
                    }
        /* facts after for loop */
        assert (l_113 == &g_37 || l_113 == &g_105);
        assert (g_192 == 0 || g_192 == &g_37);
    }
    /* facts after branching */
    assert (l_113 == &g_37 || l_113 == &g_105);
    assert (g_192 == 0 || g_192 == &g_37);
    (*g_235) = (*p_85);
    /* statement id: 160 */
    assert (g_192 == &g_37);
    for (g_211 = 11; (g_211 > (-28)); --g_211)
    { /* block id: 163 */
        (*g_238) = (*p_85);
        for (g_37 = 0; (g_37 > (-9)); g_37 -= 1)
        { /* block id: 167 */
            int32_t l_241 = 1L;
            float *l_242 = &g_149;
            p_87 = (****g_188);
            /* statement id: 168 */
            assert (p_87 == &g_37);
            (*l_242) = l_241;
        }
    }
    /* facts after for loop */
    assert (p_87 == &g_37 || p_87 == 0);
    return l_243;
    /* statement id: 172 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const * func_89(int16_t  p_90, const uint16_t  p_91, int32_t * p_92)
{ /* block id: 58 */
    return &g_97;
    /* statement id: 59 */
    //assert (func_89_rv == &g_97);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_37, "g_37", print_hash_value);
    transparent_crc(g_41, "g_41", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_99.f0, "g_99.f0", print_hash_value);
    transparent_crc(g_105, "g_105", print_hash_value);
    transparent_crc(g_116, "g_116", print_hash_value);
    transparent_crc_bytes (&g_130, sizeof(g_130), "g_130", print_hash_value);
    transparent_crc_bytes (&g_131, sizeof(g_131), "g_131", print_hash_value);
    transparent_crc(g_148, "g_148", print_hash_value);
    transparent_crc_bytes (&g_149, sizeof(g_149), "g_149", print_hash_value);
    transparent_crc(g_181, "g_181", print_hash_value);
    transparent_crc(g_184.f0, "g_184.f0", print_hash_value);
    transparent_crc(g_186.f0, "g_186.f0", print_hash_value);
    transparent_crc(g_202, "g_202", print_hash_value);
    transparent_crc(g_211, "g_211", print_hash_value);
    transparent_crc(g_268, "g_268", print_hash_value);
    transparent_crc(g_279.f0, "g_279.f0", print_hash_value);
    transparent_crc(g_371, "g_371", print_hash_value);
    transparent_crc(g_394.f0, "g_394.f0", print_hash_value);
    transparent_crc(g_463, "g_463", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 114
XXX total union variables: 13

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 124
   depth: 2, occurrence: 28
   depth: 3, occurrence: 2
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 3
   depth: 24, occurrence: 3
   depth: 32, occurrence: 2

XXX total number of pointers: 120

XXX times a variable address is taken: 109
XXX times a pointer is dereferenced on RHS: 89
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 97
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 4, occurrence: 7
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 434

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 633
   level: 2, occurrence: 196
   level: 3, occurrence: 36
   level: 4, occurrence: 61
   level: 5, occurrence: 16
XXX number of pointers point to pointers: 49
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.7
XXX average alias set size: 1.18

XXX times a non-volatile is read: 503
XXX times a non-volatile is write: 282
XXX times a volatile is read: 22
XXX    times read thru a pointer: 0
XXX times a volatile is write: 8
XXX    times written thru a pointer: 2
XXX times a volatile is available for access: 147
XXX percentage of non-volatile access: 96.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 113
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 19
   depth: 2, occurrence: 18
   depth: 3, occurrence: 14
   depth: 4, occurrence: 16
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 22.1
XXX percentage an existing variable is used: 77.9
********************* end of statistics **********************/

