/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      3649912362
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int16_t g_14 = 0x2337L;
static int32_t g_42 = 0x42C3B03CL;
static int32_t g_58 = 0x12AEAFD7L;
static int32_t **g_71 = (void*)0;
static int32_t ***g_170 = &g_71;
static int32_t g_192 = 1L;
static int32_t *g_299 = &g_58;
static int32_t ****g_325 = &g_170;


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_1(void);
static uint64_t  func_9(uint32_t  p_10, int16_t  p_11);
static int16_t  func_19(int16_t  p_20);
inline static int16_t  func_28(uint64_t  p_29, int64_t  p_30, uint32_t  p_31);
static uint16_t  func_33(int64_t  p_34, int32_t  p_35);
static int64_t  func_38(int32_t  p_39);
static int32_t * func_46(int32_t  p_47, int32_t  p_48, int16_t  p_49, int32_t  p_50, int32_t * p_51);
static uint64_t  func_59(int32_t * p_60);
inline static int32_t * func_61(int16_t  p_62, uint16_t  p_63);
inline static uint16_t  func_64(int32_t * p_65, int32_t ** p_66, int64_t  p_67, int32_t ** p_68, int32_t ** p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_42 g_58 g_71 g_192 g_299
 * writes: g_58 g_192 g_299 g_325 g_170 g_42
 */
inline static int16_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_32 = 0xEC13L;
    uint32_t l_359 = 4294967295UL;
    int32_t l_380 = 0L;
    int32_t ***l_381 = &g_71;
    int16_t l_390 = 0x03E0L;
    int32_t *l_391 = &g_42;
    int32_t *l_397 = &g_42;
    l_380 = (safe_add_func_uint64_t_u_u(0UL, ((safe_rshift_func_uint16_t_u_u(((((18446744073709551615UL & (safe_mod_func_uint32_t_u_u((~func_9((safe_sub_func_int32_t_s_s(g_14, (safe_mod_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(((65529UL < func_19(((((safe_lshift_func_uint16_t_u_s(((((g_14 , ((((((+((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_int16_t_s_s((func_28((l_32 || 0x86255D58L), g_14, l_32) , 0xD855L), g_14)) , 0UL), 0)) , g_192)) , g_42) && 1L) ^ 1UL) , (-7L)) >= l_32)) & l_32) && l_359) || g_14), 13)) , 0UL) , l_32) , l_359))) , g_14), g_14)), 0x7F2FL)))), l_32)), (-1L)))) == (-10L)) , l_32) < 0x8077E666L), l_32)) | l_32)));
    /* statement id: 142 */
    assert (g_170 == 0 || g_170 == &g_71);
    assert (g_299 == 0);
    assert (g_325 == 0 || g_325 == &g_170);
    (*l_391) = (((l_32 , l_381) == ((safe_add_func_int16_t_s_s(g_192, (((safe_rshift_func_uint16_t_u_s((g_42 & (((safe_rshift_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(0x254592D4L, (1L | ((((&g_71 != (l_380 , &g_71)) , (*l_381)) != (*l_381)) , g_192)))), 10)) >= 0x0679324EL) || g_58)), l_380)) ^ g_42) && l_390))) , (void*)0)) > l_380);
    for (l_390 = 0; (l_390 <= (-20)); --l_390)
    { /* block id: 146 */
        uint32_t l_396 = 18446744073709551608UL;
        int32_t **l_398 = &l_391;
    }
    return g_192;
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_42 g_14
 * writes: g_192
 */
static uint64_t  func_9(uint32_t  p_10, int16_t  p_11)
{ /* block id: 138 */
    int64_t l_369 = 0x308A2A7BF1E7EB24LL;
    int32_t *l_378 = (void*)0;
    int32_t l_379 = 1L;
    l_379 = (safe_lshift_func_uint16_t_u_u((1L && (safe_lshift_func_int16_t_s_u(g_58, (p_11 < (safe_mod_func_uint32_t_u_u(((g_58 != (safe_div_func_uint64_t_u_u(((((l_369 < 65529UL) < (safe_sub_func_int16_t_s_s((safe_div_func_uint16_t_u_u((safe_add_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_s((1UL || ((((void*)0 == l_378) , p_11) ^ p_10)), g_42)), 18446744073709551615UL)), l_369)), p_10))) && g_14) && p_10), (-10L)))) , g_58), p_11)))))), p_10));
    g_192 = p_11;
    return g_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_19(int16_t  p_20)
{ /* block id: 135 */
    uint64_t l_360 = 1UL;
    l_360 = 0xEC247854L;
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_42 g_58 g_71 g_192 g_299
 * writes: g_58 g_192 g_299 g_325 g_170
 */
inline static int16_t  func_28(uint64_t  p_29, int64_t  p_30, uint32_t  p_31)
{ /* block id: 1 */
    int64_t l_40 = 0x40F213ED423CB8E0LL;
    int32_t l_358 = 0L;
    l_358 = (65532UL ^ func_33(((safe_sub_func_int16_t_s_s((g_14 | func_38(l_40)), (((p_29 <= ((safe_lshift_func_int16_t_s_u(g_14, 12)) >= (-4L))) , func_46(((g_42 , func_38((g_42 , 0L))) , 0x0402AD92L), g_42, g_42, l_40, &g_42)) == (void*)0))) || g_42), l_40));
    /* statement id: 133 */
    assert (g_170 == 0 || g_170 == &g_71);
    assert (g_299 == 0);
    assert (g_325 == 0 || g_325 == &g_170);
    return l_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_192 g_14 g_58 g_299 g_42
 * writes: g_299 g_192 g_325 g_170
 */
static uint16_t  func_33(int64_t  p_34, int32_t  p_35)
{ /* block id: 110 */
    int32_t ****l_324 = (void*)0;
    int32_t l_328 = 0L;
    int32_t l_338 = 0x250CD725L;
    int32_t **l_350 = &g_299;
    int32_t **l_351 = &g_299;
    g_299 = (void*)0;
    /* statement id: 111 */
    assert (g_299 == 0);
    for (g_192 = 21; (g_192 < (-6)); g_192--)
    { /* block id: 114 */
        int32_t ****l_337 = &g_170;
        int32_t **l_342 = &g_299;
        int32_t **l_349 = &g_299;
        for (p_35 = 0; (p_35 > (-14)); p_35 = safe_sub_func_int32_t_s_s(p_35, 9))
        { /* block id: 117 */
            uint32_t l_327 = 5UL;
            g_325 = l_324;
            /* statement id: 118 */
            assert (g_325 == 0);
            (*l_337) = ((safe_unary_minus_func_int32_t_s(((((g_14 >= (((0x6D8EL < (l_327 ^ (p_34 != ((l_328 >= ((safe_lshift_func_int16_t_s_u(((p_35 | ((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u((l_337 == &g_170), 2)), 14)) >= (0xE775L >= l_338)), 15)) != p_34)) , p_35), p_35)) || (-6L))) | p_35)))) & p_35) ^ 0xBA78A4743BEBD9D3LL)) >= 0x504472EFL) | 0x496AL) , 0x89A8E6CAL))) , (void*)0);
            /* statement id: 119 */
            assert (g_170 == 0);
            for (l_328 = 0; (l_328 < (-9)); --l_328)
            { /* block id: 122 */
                int32_t l_341 = 0L;
                l_341 = 0x589104F7L;
            }
            if (p_35)
                continue;
        }
        (*l_342) = &l_338;
        /* statement id: 127 */
        assert (g_299 == &l_338);
        (**l_349) = ((((((safe_mod_func_uint32_t_u_u(p_34, g_58)) || (safe_mod_func_int32_t_s_s(((l_349 == ((**l_342) , l_350)) > ((void*)0 != l_351)), p_35))) == ((safe_lshift_func_uint16_t_u_s(((safe_div_func_uint64_t_u_u((safe_add_func_uint16_t_u_u(((*l_351) == (void*)0), 0x4DA4L)), g_192)) != p_34), 10)) == p_35)) >= p_34) && g_42) < p_35);
        (*l_349) = (*l_350);
    }
    /* facts after for loop */
    assert (g_170 == 0 || g_170 == &g_71);
    assert (g_299 == &l_338 || g_299 == 0);
    assert (g_325 == 0 || g_325 == &g_170);
    (*l_351) = (void*)0;
    /* statement id: 131 */
    assert (g_299 == 0);
    return g_14;
}


/* ------------------------------------------ */
/* 
 * reads : g_42
 * writes:
 */
static int64_t  func_38(int32_t  p_39)
{ /* block id: 2 */
    int32_t *l_41 = &g_42;
    int32_t **l_43 = &l_41;
    (*l_43) = l_41;
    return g_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_42 g_58 g_71 g_192 g_299
 * writes: g_58 g_192 g_299
 */
static int32_t * func_46(int32_t  p_47, int32_t  p_48, int16_t  p_49, int32_t  p_50, int32_t * p_51)
{ /* block id: 5 */
    int64_t l_52 = 0x33C66883CE717999LL;
    int32_t ****l_313 = &g_170;
    int32_t *l_319 = &g_42;
    if (l_52)
    { /* block id: 6 */
        int32_t *l_57 = &g_58;
        (*l_57) = (safe_mod_func_uint16_t_u_u((func_38(g_14) , g_14), (safe_div_func_int16_t_s_s(1L, p_50))));
        (*l_57) = func_38((*l_57));
    }
    else
    { /* block id: 9 */
        int32_t *l_70 = &g_58;
        (*l_70) = (func_59(func_61(p_47, func_64(l_70, &l_70, l_52, &l_70, g_71))) < g_14);
        /* statement id: 100 */
        assert (g_299 == &g_58);
        for (l_52 = 0; (l_52 < (-8)); l_52 = safe_sub_func_uint16_t_u_u(l_52, 7))
        { /* block id: 103 */
            int32_t ****l_308 = (void*)0;
            int32_t *l_318 = (void*)0;
            (*l_70) = (safe_div_func_int16_t_s_s((((safe_lshift_func_uint16_t_u_u((&g_170 == (g_14 , l_308)), p_48)) & (((safe_sub_func_int16_t_s_s(((safe_mod_func_int64_t_s_s((&g_170 != l_313), ((safe_mod_func_int16_t_s_s((-1L), p_49)) ^ ((safe_sub_func_int32_t_s_s(((65534UL || p_47) , (*p_51)), (*l_70))) > (-6L))))) & p_49), p_48)) > g_58) > 0UL)) == (*l_70)), g_192));
            return l_318;
            /* statement id: 105 */
            //assert (func_46_rv == 0);
        }
        return l_319;
        /* statement id: 107 */
        //assert (func_46_rv == &g_42);
    }
    return &g_58;
    /* statement id: 109 */
    //assert (func_46_rv == &g_58);
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_14 g_299
 * writes: g_58 g_192 g_299
 */
static uint64_t  func_59(int32_t * p_60)
{ /* block id: 96 */
    uint32_t l_300 = 0x9BDB669DL;
    int32_t **l_301 = &g_299;
    (*p_60) = l_300;
    (*l_301) = func_61(g_58, g_14);
    /* statement id: 98 */
    assert (g_299 == &g_58);
    return (**l_301);
}


/* ------------------------------------------ */
/* 
 * reads : g_14
 * writes: g_192 g_299
 */
inline static int32_t * func_61(int16_t  p_62, uint16_t  p_63)
{ /* block id: 86 */
    int64_t l_289 = 0L;
    int64_t l_292 = 0xD59A27EF067A4A60LL;
    int32_t ***l_293 = (void*)0;
    int32_t *l_294 = &g_192;
    int32_t **l_295 = &l_294;
    (*l_294) = ((safe_rshift_func_uint16_t_u_u(((0x5540E2C7L & p_62) || (((safe_add_func_int32_t_s_s(p_62, ((0x48284AA0L && l_289) && (safe_div_func_int32_t_s_s((((0x2051E2B1555576E5LL | 4L) & (((((l_292 , ((p_62 & l_289) , p_63)) != p_62) | p_62) , l_293) == (void*)0)) | g_14), p_63))))) & g_14) , p_62)), 6)) , l_292);
    (*l_295) = (void*)0;
    /* statement id: 88 */
    assert (l_294 == 0);
    for (p_62 = 0; (p_62 < (-14)); p_62 = safe_sub_func_uint32_t_u_u(p_62, 8))
    { /* block id: 91 */
        int32_t *l_298 = &g_192;
        g_299 = l_298;
        /* statement id: 92 */
        assert (g_299 == &g_192);
        (*l_295) = (p_63 , (*l_295));
    }
    return &g_58;
    /* statement id: 95 */
    //assert (func_61_rv == &g_58);
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_71 g_42 g_14 g_192
 * writes: g_58
 */
inline static uint16_t  func_64(int32_t * p_65, int32_t ** p_66, int64_t  p_67, int32_t ** p_68, int32_t ** p_69)
{ /* block id: 10 */
    int32_t *l_73 = &g_58;
    int32_t **l_72 = &l_73;
    int32_t ***l_74 = &l_72;
    int32_t l_122 = 0L;
    int32_t l_123 = 4L;
    int32_t *l_160 = &g_42;
    uint32_t l_178 = 0xB624CAB1L;
    uint32_t l_270 = 6UL;
    (*l_74) = l_72;
    if (((((safe_rshift_func_uint16_t_u_s((&p_65 == (void*)0), (((((((safe_sub_func_uint16_t_u_u((safe_div_func_uint16_t_u_u((((**l_72) , (((18446744073709551610UL & (((g_71 != ((!(**p_68)) , (*l_74))) < (safe_mod_func_uint64_t_u_u((***l_74), g_42))) >= 1L)) >= g_58) , g_42)) , p_67), p_67)), g_14)) < 0UL) || g_58) ^ 0xD174L) && (-1L)) ^ 0x29C6L) | (**l_72)))) || (***l_74)) || g_42) ^ g_14))
    { /* block id: 12 */
        int32_t ***l_121 = (void*)0;
        (**p_66) = 0xABC0A086L;
        for (p_67 = 10; (p_67 >= (-26)); p_67 = safe_sub_func_uint64_t_u_u(p_67, 4))
        { /* block id: 16 */
            int32_t l_120 = 0x9AA20CFBL;
            (***l_74) = (((safe_rshift_func_uint16_t_u_u(((~(((-9L) | (safe_rshift_func_uint16_t_u_s(((safe_lshift_func_uint16_t_u_s((((g_14 ^ (safe_mod_func_uint64_t_u_u((((g_42 ^ (safe_sub_func_int32_t_s_s((g_14 && (safe_add_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(0x6BA1441EL, (safe_rshift_func_int16_t_s_u(((safe_lshift_func_uint16_t_u_u((!(((safe_add_func_int64_t_s_s((0xA58EL <= (safe_rshift_func_uint16_t_u_s((g_58 ^ (safe_sub_func_uint16_t_u_u(((-9L) <= ((safe_sub_func_uint16_t_u_u((((((((safe_mod_func_int32_t_s_s((((((safe_add_func_uint64_t_u_u((***l_74), 0x0F98811FBA6500C2LL)) > g_58) ^ l_120) , g_42) ^ l_120), (-5L))) , p_67) , l_121) == &l_72) <= 9L) | l_120) < l_120), p_67)) && g_14)), l_122))), p_67))), 0xAE90203C69C835A8LL)) <= p_67) != l_120)), 4)) | g_14), 12)))), 0xEC5EL))), (**p_66)))) != g_14) & (-1L)), (**l_72)))) , 1UL) == g_42), g_14)) ^ 1UL), 4))) >= 0UL)) , 0xD3DEL), p_67)) <= l_123) ^ 0UL);
        }
    }
    else
    { /* block id: 19 */
        int32_t ***l_130 = (void*)0;
        int32_t l_159 = 1L;
        int64_t l_232 = 1L;
        for (g_58 = 0; (g_58 != (-24)); g_58 = safe_sub_func_uint64_t_u_u(g_58, 3))
        { /* block id: 22 */
            uint64_t l_126 = 0xC5ABB530338E40FFLL;
            int32_t ***l_185 = &l_72;
            uint16_t l_205 = 0xE4B6L;
        }
        (***l_74) = ((((&l_74 == ((safe_add_func_int16_t_s_s(0x230FL, (g_42 < p_67))) , &g_170)) < p_67) >= (l_270 , p_67)) ^ (safe_div_func_int64_t_s_s((((safe_lshift_func_uint16_t_u_s((((0xC0CA2B1CL > l_232) == 0x20CEAFF0F1770DDCLL) & (***l_74)), p_67)) ^ p_67) & g_58), g_42)));
        (**p_68) = (safe_rshift_func_int16_t_s_s(((&l_130 == &g_170) , ((((safe_mod_func_int16_t_s_s(g_58, 0x054EL)) ^ (**p_68)) , (((+p_67) , (*l_72)) != (void*)0)) , (safe_add_func_int64_t_s_s((+(((g_42 != g_14) , (*l_74)) != (void*)0)), (**l_72))))), 4));
        (**l_72) = (4294967295UL != ((safe_lshift_func_int16_t_s_s(0xE722L, g_14)) >= g_192));
    }
    return p_67;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_14, "g_14", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_58, "g_58", print_hash_value);
    transparent_crc(g_192, "g_192", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 71
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 10, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 39, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 49

XXX times a variable address is taken: 64
XXX times a pointer is dereferenced on RHS: 74
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 21
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 43
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 351

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 118
   level: 2, occurrence: 82
   level: 3, occurrence: 63
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 28
XXX number of pointers point to scalars: 21
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 38.8
XXX average alias set size: 1.33

XXX times a non-volatile is read: 512
XXX times a non-volatile is write: 122
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 54
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 17
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 11.9
XXX percentage an existing variable is used: 88.1
********************* end of statistics **********************/

