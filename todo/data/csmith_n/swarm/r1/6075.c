/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2562689410
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_32(void);
static int32_t  func_58(float  p_59);
static int16_t  func_68(int32_t  p_69, int32_t * p_70, int32_t * p_71, int32_t * p_72);
static int32_t * func_74(int32_t * p_75);
static float  func_79(int32_t * p_80, int32_t * p_81, float  p_82, int32_t * p_83);
static int32_t * func_84(uint8_t  p_85, uint32_t  p_86);
static uint16_t  func_89(int32_t  p_90, int32_t  p_91, int32_t * p_92, int32_t * p_93);
static int32_t  func_94(uint32_t  p_95);
static int32_t * func_97(int32_t * p_98, float  p_99);
static int32_t * func_100(uint16_t  p_101, int32_t * p_102, uint16_t  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(void)
{ /* block id: 36 */
    float l_35 = 0x8.58905Bp+36;
    int32_t l_36 = 0xB7C7008BL;
    int32_t *l_37 = &l_36;
    int32_t *l_42 = &l_36;
    int32_t l_62 = 0x49A7E128L;
    uint16_t l_793 = 0x8B95L;
    float ****l_812 = (void*)0;
    int32_t ****l_869 = (void*)0;
    int32_t *****l_868 = &l_869;
    int32_t *l_888 = &l_62;
    int32_t l_928 = 0x0FF97AADL;
    int32_t *l_960 = &l_62;
    float l_972 = 0x6.578DF2p+57;
    int32_t **l_984 = &l_37;
    uint16_t l_985 = 65528UL;
    (*l_37) = (safe_sub_func_int16_t_s_s(l_36, 1L));
    for (l_36 = 0; (l_36 >= 0); l_36 = safe_sub_func_uint16_t_u_u(l_36, 1))
    { /* block id: 40 */
        int32_t l_45 = 3L;
        int16_t l_829 = 0xEB1BL;
        int32_t *l_834 = &l_62;
        float **l_854 = (void*)0;
        int32_t *l_890 = &l_62;
        int32_t *****l_902 = (void*)0;
        int32_t **l_911 = &l_42;
        float *l_929 = &l_35;
        int32_t ***l_951 = &l_911;
        float ***l_970 = &l_854;
        int32_t **l_980 = &l_890;
    }
    l_960 = &l_62;
    (*l_960) = ((l_984 != &l_960) < (*l_888));
    return l_985;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_58(float  p_59)
{ /* block id: 41 */
    int32_t *l_73 = (void*)0;
    int32_t l_787 = (-5L);
    int32_t *l_788 = &l_787;
    int32_t l_789 = 1L;
    (*l_788) = (safe_mul_func_uint16_t_u_u(((+(((safe_rshift_func_int16_t_s_u(func_68((l_73 == (void*)0), l_73, func_74(l_73), l_73), 7)) & 0x4571L) != l_787)) < 0x155E385DL), l_787));
    l_73 = &l_787;
    /* statement id: 481 */
    assert (l_73 == &l_787);
    return l_789;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_68(int32_t  p_69, int32_t * p_70, int32_t * p_71, int32_t * p_72)
{ /* block id: 362 */
    const int32_t l_592 = 0x5EC4223FL;
    float l_603 = 0x6.755A46p-46;
    float *l_602 = &l_603;
    float **l_601 = &l_602;
    int32_t l_607 = 0x6EF0D57DL;
    int32_t *l_606 = &l_607;
    int32_t ***l_612 = (void*)0;
    int32_t ****l_611 = &l_612;
    int32_t *****l_610 = &l_611;
    int32_t ****l_617 = &l_612;
    int32_t l_619 = (-1L);
    int32_t *l_618 = &l_619;
    int32_t l_676 = 1L;
    uint16_t l_744 = 1UL;
    uint32_t l_764 = 0x657BC1B8L;
    (*l_606) |= (func_94((safe_rshift_func_int16_t_s_s((l_592 < (safe_lshift_func_uint16_t_u_s((safe_mul_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((0x86F9L < (l_601 == (void*)0)), 15)), 2)) > (safe_lshift_func_uint16_t_u_u(((l_592 == (l_592 > (((p_69 != __builtin_bswap64(l_592)) & p_69) > l_592))) && 1L), 2))), l_592)), 15))), 2))) < 4294967293UL);
    (*l_618) ^= __builtin_ia32_crc32qi((safe_sub_func_int16_t_s_s((((*l_606) < (((p_69 == ((void*)0 != l_610)) == 0x6F12B3CDL) != (p_69 & p_69))) == (safe_rshift_func_int16_t_s_u((1L && (safe_sub_func_int16_t_s_s(((l_617 == (void*)0) == p_69), p_69))), p_69))), p_69)), p_69);
    p_72 = p_72;
    if ((*l_606))
    { /* block id: 366 */
        int32_t **l_620 = (void*)0;
        int32_t **l_621 = &l_606;
        (*l_621) = func_74(p_70);
        /* statement id: 367 */
        //assert (l_606 == 0 || l_606 == &l_62);
    }
    else
    { /* block id: 368 */
        int32_t l_632 = 3L;
        const uint16_t l_640 = 0x5629L;
        int32_t **l_654 = &l_606;
        int32_t ***l_653 = &l_654;
        int32_t *****l_656 = &l_611;
        float ***l_667 = &l_601;
        uint32_t l_688 = 8UL;
        int16_t l_727 = 0L;
        uint32_t l_745 = 0xEAC8CFD3L;
        uint32_t l_763 = 0xB00A2339L;
        if ((safe_mul_func_uint16_t_u_u((safe_add_func_int16_t_s_s((p_69 ^ p_69), (((safe_mul_func_uint16_t_u_u(p_69, 0x7078L)) ^ (safe_mod_func_uint32_t_u_u((p_69 ^ (safe_add_func_int32_t_s_s((l_632 & (((safe_sub_func_int16_t_s_s((*l_606), (!(safe_sub_func_uint32_t_u_u((func_94((safe_add_func_int32_t_s_s(l_632, l_632))) != 0x56E3L), l_632))))) > 0UL) > p_69)), 0xC37D7D59L))), l_632))) != 0x6653L))), l_640)))
        { /* block id: 369 */
            for (l_632 = 0; (l_632 < 6); l_632 = safe_add_func_int32_t_s_s(l_632, 4))
            { /* block id: 372 */
                uint32_t l_643 = 18446744073709551615UL;
                return l_643;
            }
        }
        else
        { /* block id: 375 */
            uint8_t l_644 = 0UL;
            const float *l_648 = (void*)0;
            const float **l_647 = &l_648;
            const float ***l_646 = &l_647;
            int32_t *****l_655 = &l_611;
            (*l_602) = ((__builtin_parity(__builtin_ffs(func_94(p_69))) >= (0x7.5p-1 < l_644)) == (-l_632));
            (*l_618) = func_94((l_632 >= (((p_69 == ((void*)0 != l_646)) & (((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s((l_653 == (void*)0), 15)), 5)) | func_89(l_644, p_69, func_84(l_644, l_644), p_70)) || p_69)) == 1L)));
            (*l_618) |= (((void*)0 == (*l_611)) || (&l_611 == l_655));
            (*l_606) = (***l_653);
        }
    }
    /* facts after branching */
    //assert (l_606 == &l_607 || l_606 == 0 || l_606 == &l_62);
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(int32_t * p_75)
{ /* block id: 42 */
    int32_t l_76 = 5L;
    int32_t *l_589 = &l_76;
    for (l_76 = 1; (l_76 > 15); l_76 = safe_add_func_uint32_t_u_u(l_76, 1))
    { /* block id: 45 */
        uint8_t l_87 = 253UL;
        int32_t *l_88 = &l_76;
        int32_t *l_96 = &l_76;
        float l_588 = (-0x1.8p-1);
        float *l_587 = &l_588;
        (*l_587) = (0xA.CF54CEp-79 < func_79(func_84(l_87, (((((p_75 == l_88) ^ (func_89(__builtin_parity(((void*)0 != l_88)), func_94(((*l_88) & (l_96 != (void*)0))), p_75, p_75) ^ (*l_88))) != 4L) > (*l_96)) > (*l_96))), p_75, (*l_88), &l_76));
        if (l_76)
            continue;
    }
    l_589 = func_100(l_76, &l_76, l_76);
    (*l_589) ^= 1L;
    return p_75;
    /* statement id: 361 */
    //assert (func_74_rv == 0 || func_74_rv == &l_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_79(int32_t * p_80, int32_t * p_81, float  p_82, int32_t * p_83)
{ /* block id: 332 */
    int32_t l_533 = 0xBD691C87L;
    float *l_545 = (void*)0;
    float **l_544 = &l_545;
    float ***l_543 = &l_544;
    for (l_533 = 0; (l_533 <= (-22)); l_533 = safe_sub_func_uint16_t_u_u(l_533, 1))
    { /* block id: 335 */
        uint8_t l_538 = 2UL;
        int32_t l_548 = 2L;
        int32_t l_586 = 0xAB30C8E3L;
        int32_t *l_585 = &l_586;
        if ((safe_rshift_func_int16_t_s_s((l_538 != ((l_533 || (safe_mul_func_int16_t_s_s(l_538, (safe_add_func_uint16_t_u_u((l_543 != &l_544), l_538))))) || (safe_lshift_func_int16_t_s_u(l_548, (safe_lshift_func_uint16_t_u_u((safe_sub_func_int32_t_s_s(((l_533 <= (((void*)0 == &l_533) >= 4294967294UL)) < l_533), 0x7C9AF682L)), l_533)))))), 3)))
        { /* block id: 336 */
            int32_t l_556 = 0x2B2B3AC4L;
            int32_t *l_555 = &l_556;
            (*l_555) |= l_548;
        }
        else
        { /* block id: 338 */
            int16_t l_563 = 0x32D3L;
            for (l_548 = 0; (l_548 >= 14); l_548 = safe_add_func_uint32_t_u_u(l_548, 1))
            { /* block id: 341 */
                int32_t l_575 = 0x4D5F3130L;
                int32_t *l_584 = (void*)0;
                for (l_538 = (-26); (l_538 != 32); l_538 = safe_add_func_int16_t_s_s(l_538, 1))
                { /* block id: 344 */
                    const int32_t *l_562 = (void*)0;
                    const int32_t **l_561 = &l_562;
                    int32_t l_565 = 0x4E1A6480L;
                    int32_t *l_564 = &l_565;
                    int32_t **l_583 = &l_564;
                    int32_t ***l_582 = &l_583;
                    int32_t ****l_581 = &l_582;
                    int32_t *****l_580 = &l_581;
                    (*l_561) = (void*)0;
                    (*l_564) |= l_563;
                    (*****l_580) = ((safe_mul_func_uint16_t_u_u(((((~(safe_lshift_func_int16_t_s_s((-1L), (~l_563)))) && (0x89CF6B4FL >= (((l_533 <= (safe_mod_func_uint16_t_u_u((((!l_575) | (safe_sub_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u(l_548, l_533)), 1UL))) == ((void*)0 != l_580)), l_538))) | l_538) != l_575))) || l_575) & 0x3FFF13A0L), (***l_582))) <= 0x13F9ECF2L);
                }
                if ((*p_83))
                    break;
                l_585 = l_584;
                /* statement id: 350 */
                assert (l_585 == 0);
                p_82 = l_575;
            }
            /* facts after for loop */
            assert (l_585 == 0 || l_585 == &l_586);
        }
        /* facts after branching */
        assert (l_585 == 0 || l_585 == &l_586);
    }
    return l_533;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_84(uint8_t  p_85, uint32_t  p_86)
{ /* block id: 322 */
    int16_t l_508 = 0L;
    float l_515 = 0x9.6C2D3Cp-85;
    float *l_514 = &l_515;
    float **l_513 = &l_514;
    int32_t l_530 = 2L;
    int32_t *l_531 = &l_530;
    int32_t *l_532 = (void*)0;
    if ((0x7D80L <= ((0x3D8B528FL && (0UL == (l_508 & (safe_lshift_func_uint16_t_u_u(0x2C25L, ((((((p_85 == ((0L < p_86) != (safe_lshift_func_uint16_t_u_s(((l_513 == &l_514) > l_508), l_508)))) != 5L) | p_85) != p_85) >= 0x7AF6C178L) < p_86)))))) != p_85)))
    { /* block id: 323 */
        int32_t l_517 = 9L;
        int32_t *l_516 = &l_517;
        int32_t **l_520 = &l_516;
        int32_t ***l_519 = &l_520;
        int32_t ****l_518 = &l_519;
        int32_t *****l_521 = &l_518;
        (*l_516) ^= (&l_514 == &l_514);
        (*l_521) = l_518;
        l_530 &= ((safe_mul_func_uint16_t_u_u((((!0UL) || (((*****l_521) < (func_94((safe_mul_func_uint16_t_u_u(((**l_520) | (!(p_85 ^ p_85))), (p_86 < l_508)))) && (safe_add_func_uint32_t_u_u(0x9E3C7521L, p_86)))) == (*****l_521))) ^ 0xB991L), (*****l_521))) & p_85);
    }
    else
    { /* block id: 327 */
        (**l_513) = p_86;
    }
    (*l_531) |= (p_85 | l_508);
    return l_532;
    /* statement id: 331 */
    //assert (func_84_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_89(int32_t  p_90, int32_t  p_91, int32_t * p_92, int32_t * p_93)
{ /* block id: 318 */
    int16_t l_494 = 0xE94BL;
    int32_t l_503 = 0L;
    int32_t *l_502 = &l_503;
    int32_t **l_501 = &l_502;
    int32_t ***l_500 = &l_501;
    int32_t ****l_499 = &l_500;
    l_494 = p_90;
    (*l_502) = ((safe_sub_func_int16_t_s_s((safe_mul_func_int16_t_s_s(l_494, (0x22421167L <= (l_499 == &l_500)))), (((0L != (safe_mod_func_int32_t_s_s(__builtin_ctzl((*l_502)), (safe_rshift_func_int16_t_s_u(0x3571L, func_94((***l_500))))))) & p_91) < 0x78D6L))) | 0x369067EFL);
    return p_90;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_94(uint32_t  p_95)
{ /* block id: 46 */
    int32_t *l_104 = (void*)0;
    int32_t **l_154 = &l_104;
    int32_t l_160 = 0xCA6ABCE8L;
    int32_t *l_159 = &l_160;
    int32_t l_177 = 0x99B8081AL;
    uint8_t l_215 = 0UL;
    float l_219 = 0x1.5p+1;
    float *l_218 = &l_219;
    float **l_217 = &l_218;
    const int32_t l_492 = 8L;
    int32_t l_493 = (-1L);
    (*l_154) = func_97(func_100((0x6AAE11E5L <= 0x375426BEL), l_104, p_95), __builtin_popcount(p_95));
    (*l_159) = (((safe_sub_func_int32_t_s_s((safe_sub_func_int32_t_s_s(p_95, p_95)), ((p_95 | ((p_95 >= 0xA262L) & 0xB6E2L)) < ((void*)0 != &l_104)))) <= (p_95 > 1UL)) | p_95);
    for (l_160 = (-3); (l_160 != 5); l_160 = safe_add_func_int32_t_s_s(l_160, 8))
    { /* block id: 88 */
        uint16_t l_171 = 65535UL;
        int32_t **l_172 = &l_159;
        int32_t l_174 = 0x9F6E7EE2L;
        int32_t *l_173 = &l_174;
        float l_176 = 0x6.A34682p-18;
        float *l_175 = &l_176;
        (*l_173) ^= ((safe_mod_func_int32_t_s_s((safe_lshift_func_int16_t_s_s(0x7CD5L, 7)), (safe_add_func_int16_t_s_s(0xF8BEL, (((safe_mul_func_uint16_t_u_u(p_95, p_95)) == l_171) >= ((0xE0C0L ^ p_95) ^ (l_172 != (void*)0))))))) & 2UL);
        (*l_175) = ((*l_173) != __builtin_parity(p_95));
    }
    return l_493;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_97(int32_t * p_98, float  p_99)
{ /* block id: 50 */
    float l_110 = 0x0.E1D9D3p+60;
    int32_t l_111 = 0x4F586FD7L;
    int32_t *l_152 = &l_111;
    p_99 = (p_99 >= (safe_add_func_float_f_f(l_110, ((l_111 < ((&l_111 == &l_111) <= 0x5.F7EBA0p+14)) != ((l_111 >= p_99) < (l_111 >= 0x8.7FF731p+77))))));
    if ((safe_add_func_uint16_t_u_u(((((l_111 && l_111) != (safe_rshift_func_uint16_t_u_s(((0x7B51L >= ((safe_add_func_uint32_t_u_u(((__builtin_clzl(l_111) ^ (l_111 & (safe_unary_minus_func_int16_t_s(l_111)))) | (l_111 & ((safe_sub_func_uint32_t_u_u((0L < l_111), 0UL)) <= 0x1EA7L))), (-2L))) == 0x65AED0E3L)) > (-3L)), 1))) | l_111) < l_111), (-7L))))
    { /* block id: 52 */
        uint8_t l_123 = 0UL;
        int32_t *l_124 = &l_111;
        int32_t l_132 = 0x5F07B865L;
        (*l_124) = (safe_rshift_func_int16_t_s_s(((l_111 < l_111) ^ l_123), 2));
        l_132 |= ((l_111 | (*l_124)) || (~(safe_add_func_uint16_t_u_u((((safe_mul_func_int16_t_s_s((0xC9E8L == (safe_add_func_int16_t_s_s((((0xCC2FL != l_111) <= __builtin_ia32_crc32qi((&l_111 == p_98), (p_98 != &l_111))) == 1UL), l_111))), (*l_124))) < 0xA6A81A3AL) >= l_111), (*l_124)))));
    }
    else
    { /* block id: 55 */
        int32_t *l_135 = &l_111;
        int32_t l_137 = 0L;
        int32_t *l_136 = &l_137;
        int32_t l_145 = 0xCC0FEBE7L;
        (*l_136) |= (safe_sub_func_uint16_t_u_u((l_111 ^ ((void*)0 != l_135)), (l_111 || 0x298BL)));
        if (__builtin_ctzll((l_111 < ((l_111 ^ (*l_135)) >= 1L))))
        { /* block id: 57 */
            uint16_t l_142 = 0x7D68L;
            int32_t *l_153 = (void*)0;
            for (l_111 = 28; (l_111 < (-15)); l_111 = safe_sub_func_uint16_t_u_u(l_111, 1))
            { /* block id: 60 */
                int32_t **l_140 = (void*)0;
                int32_t **l_141 = &l_136;
                (*l_141) = p_98;
                /* statement id: 61 */
                //assert (l_136 == 0 || l_136 == &l_265 || l_136 == &l_354 || l_136 == &l_427 || l_136 == &l_632 || l_136 == &l_62);
                (*l_141) = p_98;
                return p_98;
                /* statement id: 63 */
                //assert (func_97_rv == 0 || func_97_rv == &l_265 || func_97_rv == &l_354 || func_97_rv == &l_427 || func_97_rv == &l_632 || func_97_rv == &l_62);
            }
            (*l_135) = l_111;
            if ((l_142 && ((0x3C673DF2L && (safe_mod_func_int16_t_s_s(l_142, 1UL))) || l_145)))
            { /* block id: 66 */
                int32_t *l_146 = &l_137;
                (*l_136) = (0x26E3L ^ l_111);
                l_135 = l_146;
                /* statement id: 68 */
                assert (l_135 == &l_137);
            }
            else
            { /* block id: 69 */
                return p_98;
                /* statement id: 70 */
                //assert (func_97_rv == 0 || func_97_rv == &l_265 || func_97_rv == &l_354 || func_97_rv == &l_427 || func_97_rv == &l_632 || func_97_rv == &l_62);
            }
            /* facts after branching */
            assert (l_135 == &l_137);
            for (l_111 = 16; (l_111 != (-24)); l_111 = safe_sub_func_uint16_t_u_u(l_111, 5))
            { /* block id: 74 */
                const int32_t *l_150 = &l_145;
                const int32_t **l_149 = &l_150;
                int32_t *l_151 = &l_137;
                p_98 = &l_145;
                /* statement id: 75 */
                assert (p_98 == &l_145);
                (*l_149) = p_98;
                return l_153;
                /* statement id: 77 */
                //assert (func_97_rv == 0);
            }
        }
        else
        { /* block id: 79 */
            return p_98;
            /* statement id: 80 */
            //assert (func_97_rv == 0 || func_97_rv == &l_265 || func_97_rv == &l_354 || func_97_rv == &l_427 || func_97_rv == &l_632 || func_97_rv == &l_62);
        }
        /* facts after branching */
        assert (l_135 == &l_137);
    }
    return p_98;
    /* statement id: 83 */
    //assert (func_97_rv == 0 || func_97_rv == &l_265 || func_97_rv == &l_354 || func_97_rv == &l_427 || func_97_rv == &l_632 || func_97_rv == &l_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_100(uint16_t  p_101, int32_t * p_102, uint16_t  p_103)
{ /* block id: 47 */
    int32_t l_107 = (-10L);
    int32_t *l_106 = &l_107;
    (*l_106) ^= (~p_101);
    return p_102;
    /* statement id: 49 */
    //assert (func_100_rv == 0 || func_100_rv == &l_160 || func_100_rv == &l_265 || func_100_rv == &l_76 || func_100_rv == &l_632);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 239
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 14
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 186

XXX times a variable address is taken: 174
XXX times a pointer is dereferenced on RHS: 133
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 5
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 154
breakdown:
   depth: 1, occurrence: 127
   depth: 2, occurrence: 19
   depth: 3, occurrence: 7
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 39
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 848

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 546
   level: 2, occurrence: 109
   level: 3, occurrence: 72
   level: 4, occurrence: 47
   level: 5, occurrence: 60
XXX number of pointers point to pointers: 90
XXX number of pointers point to scalars: 96
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 32.3
XXX average alias set size: 1.37

XXX times a non-volatile is read: 1063
XXX times a non-volatile is write: 433
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 78
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 15
   depth: 2, occurrence: 12
   depth: 3, occurrence: 14
   depth: 4, occurrence: 3

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
********************* end of statistics **********************/

