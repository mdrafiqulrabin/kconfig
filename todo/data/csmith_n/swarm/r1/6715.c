/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3674811574
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint32_t  f1;
   uint64_t  f2;
   uint32_t  f3;
};

struct S1 {
   uint64_t  f0;
   int64_t  f1;
   int64_t  f2;
   int32_t  f3;
   int64_t  f4;
   uint32_t  f5;
};

struct S2 {
   int16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int16_t  func_9(uint32_t  p_10, struct S0  p_11);
static uint32_t  func_12(struct S0  p_13, int16_t  p_14, uint64_t  p_15);
static struct S0  func_16(int32_t  p_17, int16_t  p_18, uint16_t  p_19, int32_t  p_20, uint64_t  p_21);
static int16_t  func_22(uint32_t  p_23, struct S1  p_24, uint64_t  p_25);
static uint32_t  func_26(uint16_t  p_27, uint16_t  p_28, uint32_t  p_29, uint32_t  p_30, struct S2  p_31);
static int16_t  func_35(uint64_t  p_36, int32_t  p_37, uint32_t  p_38, int16_t  p_39);
static uint32_t  func_42(struct S2  p_43, int32_t  p_44, uint32_t  p_45, uint32_t  p_46);
static uint32_t  func_52(struct S0  p_53, int32_t  p_54, int64_t  p_55, struct S1  p_56, struct S0  p_57);
static struct S0  func_58(struct S1  p_59, int32_t  p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = (-1L);
    int64_t l_40 = 0x589AFCA8629342BBLL;
    uint16_t l_41 = 0xABA4L;
    struct S2 l_366 = {0x4C7AL};
    struct S1 l_370 = {0x3832C0FE8FB8EA65LL,0x41D896C24658D136LL,0xEE10B6CEE0769A12LL,1L,-6L,0x02EE2763L};
    for (l_2 = 0; (l_2 != 24); l_2 += 6)
    { /* block id: 3 */
        int32_t l_34 = 0xA9C5A74DL;
        struct S0 l_434 = {0x272BL,18446744073709551614UL,0x1E353AB2A3786C04LL,4294967291UL};
        int32_t *l_528 = (void*)0;
        int32_t *l_529 = &l_370.f3;
        (*l_529) = ((int16_t)0L % (int16_t)((int16_t)func_9(func_12(func_16(l_2, func_22(func_26(l_2, l_2, l_2, ((int32_t)(l_34 && func_35((l_34 > l_34), l_2, l_40, l_41)) + (int32_t)l_41), l_366), l_370, l_34), l_34, l_366.f0, l_370.f2), l_34, l_370.f0), l_434) >> (int16_t)10));
    }
    return l_370.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_9(uint32_t  p_10, struct S0  p_11)
{ /* block id: 130 */
    int32_t l_443 = 0L;
    int32_t ***l_448 = (void*)0;
    int32_t *l_452 = &l_443;
    int32_t **l_451 = &l_452;
    int32_t *l_526 = &l_443;
    if ((p_10 > ((int16_t)(((int32_t)p_11.f2 % (int32_t)((int16_t)p_10 + (int16_t)((int16_t)l_443 >> (int16_t)13))) || ((uint64_t)p_11.f1 % (uint64_t)((int16_t)((void*)0 == l_448) << (int16_t)(&l_448 == (void*)0)))) << (int16_t)9)))
    { /* block id: 131 */
        int32_t *l_450 = (void*)0;
        int32_t **l_449 = &l_450;
        int32_t *****l_453 = (void*)0;
        int32_t ****l_460 = &l_448;
        uint16_t l_461 = 0xEAA2L;
        if (((((l_443 || (l_449 == l_451)) && p_11.f3) ^ (((l_453 == l_453) || ((uint16_t)(((int64_t)((uint32_t)((((((&l_448 != l_460) > p_10) > 1L) <= l_461) <= 0x5C1E7DB1L) ^ 0x466FL) + (uint32_t)(**l_451)) + (int64_t)0xA9926A0A94815146LL) && p_11.f3) << (uint16_t)1)) && 0xC79DL)) <= p_10))
        { /* block id: 132 */
            struct S2 l_462 = {0x50EAL};
            struct S2 *l_463 = &l_462;
            (*l_463) = l_462;
        }
        else
        { /* block id: 134 */
            int32_t l_465 = 4L;
            int32_t *l_464 = &l_465;
            (*l_464) ^= (*l_452);
        }
    }
    else
    { /* block id: 137 */
        int32_t ****l_482 = &l_448;
        int32_t l_483 = (-1L);
        struct S1 l_522 = {8UL,-5L,-1L,-2L,0L,0UL};
        if (((uint64_t)((uint64_t)(((int16_t)(0x5732L <= p_11.f2) >> (int16_t)0) & ((int16_t)(p_10 >= ((uint16_t)((((int16_t)0xE618L >> (int16_t)((4L >= 2UL) & (p_11.f3 || ((uint16_t)((uint16_t)(l_482 == l_482) << (uint16_t)l_483) << (uint16_t)13)))) && p_10) != 1L) >> (uint16_t)p_11.f3)) >> (int16_t)(**l_451))) % (uint64_t)p_11.f1) % (uint64_t)l_483))
        { /* block id: 138 */
            uint32_t l_498 = 1UL;
            int32_t **l_505 = (void*)0;
            for (p_11.f3 = 0; (p_11.f3 != 49); p_11.f3 += 7)
            { /* block id: 141 */
                struct S2 l_492 = {0xABE1L};
                int32_t **l_506 = &l_452;
                int32_t l_507 = (-7L);
                for (p_10 = (-8); (p_10 > 8); p_10 += 2)
                { /* block id: 144 */
                    struct S2 l_490 = {0x27AFL};
                    for (p_11.f2 = 0; (p_11.f2 != 29); ++p_11.f2)
                    { /* block id: 147 */
                        struct S2 *l_491 = &l_490;
                        int32_t ****l_497 = &l_448;
                        (*l_491) = l_490;
                        (*l_491) = l_492;
                        if (p_10)
                            continue;
                        l_507 ^= ((((uint16_t)((p_11.f0 < (1UL <= p_10)) == ((int64_t)((l_497 == &l_448) <= (*l_452)) + (int64_t)l_498)) + (uint16_t)((int64_t)l_498 % (int64_t)((uint16_t)((+((!((l_505 == l_506) < 0xA6877B9976B92B54LL)) > (-1L))) > 0x5ECD1025L) << (uint16_t)p_11.f0))) < 0xAB6F6539L) | l_490.f0);
                    }
                    return p_11.f2;
                }
            }
            (*l_452) |= (-1L);
            for (p_11.f1 = (-1); (p_11.f1 == 17); ++p_11.f1)
            { /* block id: 159 */
                int32_t *l_510 = (void*)0;
                struct S1 l_513 = {0x8151DF120B1F7176LL,0L,0xF1E166002CCF0DE6LL,0L,0x5B001480D2A5A220LL,0x3FC7AFDEL};
                struct S1 *l_512 = &l_513;
                struct S1 **l_511 = &l_512;
                (*l_451) = l_510;
                /* statement id: 160 */
                assert (l_452 == 0);
                (*l_511) = (void*)0;
                /* statement id: 161 */
                assert (l_512 == 0);
            }
            /* facts after for loop */
            assert (l_452 == 0 || l_452 == &l_443);
        }
        else
        { /* block id: 163 */
            int32_t *l_514 = &l_443;
            (*l_451) = l_514;
            (*l_451) = (*l_451);
            for (p_11.f2 = 11; (p_11.f2 <= 54); p_11.f2 += 3)
            { /* block id: 168 */
                int32_t *l_527 = (void*)0;
            }
        }
        /* facts after branching */
        assert (l_452 == 0 || l_452 == &l_443);
    }
    /* facts after branching */
    assert (l_452 == 0 || l_452 == &l_443);
    return p_11.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_12(struct S0  p_13, int16_t  p_14, uint64_t  p_15)
{ /* block id: 127 */
    int32_t l_432 = 0xB1F8B39EL;
    int32_t *l_431 = &l_432;
    int32_t **l_430 = &l_431;
    uint32_t l_433 = 0x15B618ADL;
    (*l_430) = (void*)0;
    /* statement id: 128 */
    assert (l_431 == 0);
    return l_433;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_16(int32_t  p_17, int16_t  p_18, uint16_t  p_19, int32_t  p_20, uint64_t  p_21)
{ /* block id: 107 */
    int32_t l_390 = 0x64D8A8CEL;
    struct S0 l_410 = {0xE380L,0xDBFFB3CFL,1UL,4294967293UL};
    int32_t l_423 = 1L;
    int32_t *l_422 = &l_423;
    int32_t **l_421 = &l_422;
    int32_t ***l_420 = &l_421;
    int32_t ****l_419 = &l_420;
    struct S1 l_426 = {0x5AF559F17BF1807CLL,1L,9L,-1L,0xF9D90B8971933DCALL,0x1D593650L};
    struct S1 *l_425 = &l_426;
    struct S1 **l_424 = &l_425;
    if (((((uint32_t)(((uint16_t)((uint16_t)(!((uint64_t)(+((((((l_390 > ((((((int16_t)(-(int64_t)(((uint32_t)(((uint32_t)((uint16_t)(((p_18 >= l_390) > p_20) <= p_21) << (uint16_t)(&p_17 == &p_17)) - (uint32_t)(((4294967290UL >= ((0xB691L >= l_390) & p_18)) > p_20) >= 0x9C4FL)) >= 4294967291UL) + (uint32_t)0x942E4CE6L) != l_390)) - (int16_t)p_20) != (-1L)) || l_390) < 0x5113E63DB50818E7LL) & p_17)) <= p_18) == 0x70D4B94C9C09685FLL) > l_390) ^ l_390) == 0x06FFC55FL)) - (uint64_t)0x6F657B8970AAFF5BLL)) - (uint16_t)p_20) >> (uint16_t)7) ^ l_390) - (uint32_t)(-10L)) || p_19) >= p_21))
    { /* block id: 108 */
        int32_t *l_402 = (void*)0;
        int32_t ***l_418 = (void*)0;
        int32_t ****l_417 = &l_418;
        struct S1 l_427 = {0xE161E205DDFC62B8LL,0L,1L,1L,3L,0xC1BFB96DL};
        for (p_17 = 0; (p_17 > (-6)); p_17 -= 1)
        { /* block id: 111 */
            int32_t **l_403 = &l_402;
            int32_t l_409 = 0x8AC25AD5L;
            int32_t *l_408 = &l_409;
            (*l_403) = l_402;
            if (l_390)
                continue;
            (*l_408) ^= (0L != (3L & ((((uint16_t)(l_408 == &p_17) << (uint16_t)12) == p_19) != (-2L))));
            return l_410;
        }
        if (((((p_21 || ((int64_t)(((uint64_t)(l_417 == &l_418) % (uint64_t)((&l_418 == l_419) | (**l_421))) > (((****l_419) < ((void*)0 != l_424)) || p_19)) % (int64_t)(-1L))) != p_18) | 1L) >= p_17))
        { /* block id: 117 */
            struct S1 l_428 = {0xADD43F1477426CD3LL,0L,0x2D67FBCB9C969782LL,0xD7283E07L,1L,1UL};
            struct S0 l_429 = {-1L,4UL,0xBDBAEF624EA28F76LL,2UL};
            l_428 = l_427;
            return l_429;
        }
        else
        { /* block id: 120 */
            (*l_425) = (*l_425);
        }
    }
    else
    { /* block id: 123 */
        (***l_419) = &p_17;
        /* statement id: 124 */
        assert (l_422 == &p_17);
    }
    /* facts after branching */
    assert (l_422 == &p_17 || l_422 == &l_423);
    return l_410;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_22(uint32_t  p_23, struct S1  p_24, uint64_t  p_25)
{ /* block id: 103 */
    uint32_t l_375 = 0x883E4B16L;
    int32_t l_379 = 0x78B3AE40L;
    int32_t *l_378 = &l_379;
    (*l_378) = ((uint16_t)((uint32_t)l_375 % (uint32_t)((int64_t)p_24.f5 + (int64_t)p_24.f0)) >> (uint16_t)6);
    (*l_378) = (p_24.f1 == p_24.f5);
    return p_24.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_26(uint16_t  p_27, uint16_t  p_28, uint32_t  p_29, uint32_t  p_30, struct S2  p_31)
{ /* block id: 100 */
    int32_t l_368 = 0x55EF6E4DL;
    int32_t *l_367 = &l_368;
    int32_t **l_369 = &l_367;
    (*l_369) = l_367;
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_35(uint64_t  p_36, int32_t  p_37, uint32_t  p_38, int16_t  p_39)
{ /* block id: 4 */
    struct S2 l_47 = {0xFFD0L};
    struct S1 l_61 = {0x71E9572AB10E3A11LL,1L,0xFF79C94D23A2CC37LL,3L,-7L,4294967288UL};
    struct S0 l_173 = {1L,0x7002FB21L,0xD5BDE6C51A86194BLL,1UL};
    uint64_t l_177 = 0UL;
    int32_t **l_210 = (void*)0;
    int32_t ***l_209 = &l_210;
    int32_t l_269 = 0x06AF2D10L;
    int32_t l_272 = (-1L);
    int32_t l_295 = 0x490DEC96L;
    int32_t l_305 = 0xC534E026L;
    int32_t l_306 = (-8L);
    int32_t l_326 = 0x85C4E4F8L;
    int32_t *l_352 = &l_305;
    int32_t ****l_359 = &l_209;
    int32_t *****l_358 = &l_359;
    int32_t *l_364 = (void*)0;
    int32_t *l_365 = &l_326;
    if (((func_42(l_47, (((uint32_t)((int16_t)(0x3781CDFFL ^ func_52(func_58(l_61, l_61.f4), (l_61.f5 == (((((uint16_t)((int64_t)(0x6D37E95C8E435D7CLL != (2L || (-(uint16_t)(l_61.f5 <= p_36)))) + (int64_t)(-2L)) - (uint16_t)0xDA6FL) >= p_38) || 0xD279C3978F7D0102LL) | 0UL)), l_61.f5, l_61, l_173)) - (int16_t)l_47.f0) - (uint32_t)l_47.f0) >= l_177), p_39, l_61.f2) >= 7L) & l_61.f0))
    { /* block id: 53 */
        int32_t ***l_211 = &l_210;
        uint16_t l_212 = 0x521AL;
        int32_t *l_213 = &l_61.f3;
        (*l_213) &= (l_61.f1 & ((l_209 != l_211) & l_212));
    }
    else
    { /* block id: 55 */
        int32_t l_218 = 0L;
        int32_t l_235 = 0xA08E5E6BL;
        int32_t l_262 = (-6L);
        int32_t l_265 = 0xAEC3AFA7L;
        int32_t **l_353 = &l_352;
        for (p_37 = (-23); (p_37 >= 13); p_37++)
        { /* block id: 58 */
            struct S0 l_219 = {0x198EL,18446744073709551613UL,0xDD9185341A822638LL,4294967295UL};
            int32_t l_245 = 4L;
            int32_t l_268 = 0x4B791F81L;
            int32_t l_271 = 4L;
            int32_t l_286 = 0xC21F15DCL;
            int32_t l_307 = 8L;
            int32_t l_321 = 1L;
            uint32_t l_335 = 0UL;
            struct S1 *l_342 = &l_61;
            int32_t *l_351 = &l_268;
            for (l_61.f5 = 0; (l_61.f5 > 34); l_61.f5 += 7)
            { /* block id: 61 */
                int32_t *l_233 = (void*)0;
                int32_t l_256 = 0x39945770L;
                int32_t l_263 = (-1L);
                int32_t l_292 = 0x5DCDB808L;
                int32_t l_302 = 0L;
                int32_t l_303 = 0L;
                uint32_t l_328 = 0x1B163B82L;
            }
            (*l_351) &= l_286;
            l_352 = &l_262;
            /* statement id: 92 */
            assert (l_352 == &l_262);
        }
        /* facts after for loop */
        assert (l_352 == &l_262 || l_352 == &l_305);
        (**l_353) = ((((*l_209) != l_353) < 0x011DL) != p_38);
        (**l_353) &= ((int64_t)((int16_t)p_37 << (int16_t)4) + (int64_t)((*l_209) != (void*)0));
    }
    /* facts after branching */
    //assert (l_352 == dangling || l_352 == &l_305);
    l_358 = (void*)0;
    /* statement id: 97 */
    assert (l_358 == 0);
    (*l_365) = (-(uint64_t)((int32_t)(-(int32_t)p_37) % (int32_t)0x25B8E2C0L));
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_42(struct S2  p_43, int32_t  p_44, uint32_t  p_45, uint32_t  p_46)
{ /* block id: 44 */
    int16_t l_187 = 0x7D6CL;
    struct S1 l_195 = {0x63F38E196A4908DBLL,-1L,0x5CD855B04A482743LL,-8L,0L,0x5155342CL};
    struct S1 *l_194 = &l_195;
    uint32_t l_202 = 18446744073709551615UL;
    int16_t l_203 = 4L;
    int32_t *l_204 = &l_195.f3;
    int32_t l_208 = (-2L);
    int32_t *l_207 = &l_208;
    for (p_45 = (-13); (p_45 != 51); p_45 += 1)
    { /* block id: 47 */
        int32_t l_181 = 9L;
        int32_t *l_180 = &l_181;
        int32_t **l_182 = &l_180;
        (*l_182) = l_180;
    }
    (*l_204) = (((((p_44 <= ((uint16_t)0xD573L << (uint16_t)1)) & ((uint16_t)l_187 >> (uint16_t)((uint16_t)((int32_t)((uint16_t)(((void*)0 == l_194) || ((int64_t)p_44 + (int64_t)0x6A46236CA140F996LL)) >> (uint16_t)6) - (int32_t)((((((uint64_t)((int32_t)((l_195.f2 != p_44) || 65526UL) + (int32_t)8UL) - (uint64_t)l_202) && p_46) | l_203) < l_195.f0) || l_202)) + (uint16_t)65535UL))) ^ l_195.f3) != l_202) != 4294967288UL);
    (*l_207) |= ((((int32_t)p_43.f0 % (int32_t)0xE024C018L) & (*l_204)) && (*l_204));
    return p_43.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_52(struct S0  p_53, int32_t  p_54, int64_t  p_55, struct S1  p_56, struct S0  p_57)
{ /* block id: 41 */
    struct S1 l_175 = {0x3F8FB61F0D97DA6ELL,0x96BD5CD4344FC8F3LL,-1L,-1L,1L,0UL};
    struct S1 *l_174 = &l_175;
    struct S1 **l_176 = &l_174;
    (*l_176) = l_174;
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_58(struct S1  p_59, int32_t  p_60)
{ /* block id: 5 */
    int64_t l_69 = 0xDA569FAA33FE686BLL;
    int64_t l_90 = 0x716CFB31DF95200CLL;
    uint16_t l_91 = 0x7303L;
    int64_t l_107 = 0L;
    uint16_t l_131 = 0x47D0L;
    int32_t *l_137 = (void*)0;
    int32_t **l_136 = &l_137;
    int32_t ***l_135 = &l_136;
    int32_t l_160 = (-1L);
    int32_t *l_159 = &l_160;
    struct S0 l_165 = {0x437FL,2UL,18446744073709551610UL,4294967295UL};
    if ((((((((uint32_t)((((int32_t)((uint16_t)(!(l_69 < p_60)) >> (uint16_t)14) % (int32_t)(p_59.f3 ^ ((uint16_t)(0xAB159BBC08F52837LL != ((((uint16_t)((uint16_t)(0xA6866C5D8998D42FLL > p_59.f3) << (uint16_t)(((((uint16_t)((uint32_t)((int16_t)(((int16_t)(((((uint16_t)((9L > p_59.f2) != ((((uint16_t)((uint32_t)0x19957B09L % (uint32_t)l_69) + (uint16_t)l_90) || 0x819A8027L) != 5L)) >> (uint16_t)13) > p_59.f1) <= p_59.f0) | 18446744073709551615UL) << (int16_t)p_59.f2) != (-1L)) << (int16_t)5) + (uint32_t)l_90) << (uint16_t)7) | p_59.f5) != l_69) ^ l_90)) >> (uint16_t)15) & 1UL) || 0x8FA0D634L)) >> (uint16_t)13))) > p_59.f5) ^ p_59.f2) + (uint32_t)l_91) <= 0x8C36L) <= p_59.f5) >= 0x3D07L) ^ 0xE4AEL) | p_59.f5))
    { /* block id: 6 */
        for (l_90 = (-10); (l_90 > (-11)); l_90 -= 1)
        { /* block id: 9 */
            p_59.f3 &= 0xD66C2530L;
        }
    }
    else
    { /* block id: 12 */
        int32_t l_94 = 0x82D785ABL;
        int32_t l_106 = 0x6F4C769FL;
        int32_t *l_134 = &l_94;
        int32_t **l_133 = &l_134;
        int32_t ***l_132 = &l_133;
        uint32_t l_157 = 18446744073709551608UL;
        l_94 = p_59.f4;
        if (((uint16_t)(((l_94 == 0xEE50A8E0L) > ((((((0x7823L == ((((int32_t)(0L | (-(uint64_t)p_59.f2)) % (int32_t)(((uint64_t)0x8B0A975422B1FF20LL + (uint64_t)(((uint32_t)(0xF1EF1A95A077DDA0LL <= ((((((p_59.f2 || ((int16_t)(4UL == 18446744073709551610UL) >> (int16_t)p_59.f4)) > l_106) >= 0x9888A159L) == p_59.f4) > p_59.f2) != 0x894E1783L)) % (uint32_t)l_107) | p_59.f5)) ^ l_106)) != l_90) < p_59.f0)) < l_106) != 0xA04901E3L) | l_106) < p_60) <= 3L)) >= p_59.f4) % (uint16_t)l_107))
        { /* block id: 14 */
            int32_t *l_108 = &l_94;
            int32_t **l_109 = &l_108;
            int32_t l_130 = 0x36CBA869L;
            (*l_109) = l_108;
            p_59.f3 |= ((int16_t)1L >> (int16_t)(0UL == (((uint16_t)((-(uint32_t)((uint32_t)6UL + (uint32_t)p_59.f2)) > ((+0L) && ((uint16_t)1UL + (uint16_t)((int16_t)((uint16_t)(0x21F7AE59L > p_59.f1) - (uint16_t)((uint16_t)(p_59.f0 & 0UL) >> (uint16_t)l_90)) - (int16_t)(**l_109))))) >> (uint16_t)l_91) & 0xC8AADDF9L)));
            for (l_107 = 19; (l_107 == (-27)); l_107 -= 2)
            { /* block id: 19 */
                int32_t **l_163 = (void*)0;
            }
        }
        else
        { /* block id: 34 */
            int32_t *l_164 = &l_94;
            (*l_133) = l_164;
        }
        (*l_133) = (*l_136);
        /* statement id: 37 */
        assert (l_134 == 0);
    }
    (*l_136) = (*l_136);
    return l_165;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 103
   depth: 1, occurrence: 17
XXX total union variables: 0

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 14
   depth: 4, occurrence: 5
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 33, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 143

XXX times a variable address is taken: 129
XXX times a pointer is dereferenced on RHS: 25
breakdown:
   depth: 1, occurrence: 15
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 45
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 296

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 77
   level: 2, occurrence: 33
   level: 3, occurrence: 16
   level: 4, occurrence: 10
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 95
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 23.8
XXX average alias set size: 1.1

XXX times a non-volatile is read: 357
XXX times a non-volatile is write: 126
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 73
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 15
   depth: 2, occurrence: 23
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 31.3
XXX percentage an existing variable is used: 68.7
********************* end of statistics **********************/

