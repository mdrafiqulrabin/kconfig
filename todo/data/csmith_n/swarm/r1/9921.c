/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      192972656
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const uint16_t  f0;
   uint32_t  f1;
   int32_t  f2;
   uint32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   int16_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 0x6182EAC4L;
static uint32_t g_34 = 0UL;
static uint16_t g_48 = 0x637BL;
static uint16_t *g_47 = &g_48;
static uint32_t g_90 = 0x5AB8BF51L;
static uint32_t g_99 = 4294967288UL;
static uint32_t g_106 = 0xEBAC3F40L;
static int32_t g_108 = 1L;
static uint16_t g_111 = 65530UL;
static const struct S0 g_122 = {65535UL,0x79E4B39CL,3L,7UL,0UL,0x6B30262AL,0x89E4L};
static const struct S0 *g_121 = &g_122;
static struct S0 g_130 = {0x0980L,1UL,0x31463D90L,0xC214255FL,9UL,0xF357798EL,0x4FF9L};
static struct S0 **g_166 = (void*)0;
static struct S0 ***g_165 = &g_166;
static uint32_t *g_169 = &g_130.f4;
static uint32_t **g_168 = &g_169;
static int32_t *g_220 = (void*)0;
static int32_t **g_219 = &g_220;
static int32_t g_234 = 6L;
static uint8_t g_248 = 0x0FL;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_25(void);
static uint16_t  func_39(uint16_t * p_40, uint16_t  p_41);
static uint16_t * func_42(uint16_t * p_43, uint16_t * p_44, uint32_t  p_45, uint16_t * p_46);
static uint16_t * func_49(const int32_t  p_50);
static uint16_t  func_53(const uint16_t * p_54, uint16_t  p_55);
static const int16_t  func_70(int32_t  p_71, int16_t  p_72, uint16_t  p_73);
static uint32_t  func_75(uint16_t * p_76);
static uint16_t * func_77(const uint16_t * p_78, uint16_t ** p_79, uint16_t  p_80, int32_t  p_81);
static uint16_t * func_82(int32_t  p_83, uint32_t  p_84, int16_t  p_85, uint16_t  p_86);
static uint16_t  func_102(uint32_t  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_47 g_48 g_108 g_106 g_121 g_99 g_122.f4 g_122.f6 g_130.f1 g_122.f2 g_130.f0 g_165 g_168 g_130.f2 g_122.f0 g_130.f3 g_111 g_122.f5 g_219 g_234 g_130.f4 g_220 g_169 g_122.f1
 * writes: g_34 g_90 g_99 g_106 g_108 g_111 g_121 g_130.f2 g_130.f3 g_165 g_130.f6 g_220 g_169 g_248 g_48 g_219
 */
static uint32_t  func_25(void)
{ /* block id: 36 */
    uint32_t l_30 = 0x770B168FL;
    uint16_t *l_33 = (void*)0;
    uint16_t **l_241 = &l_33;
    int16_t l_242 = 6L;
    int32_t *l_251 = &g_130.f2;
    int32_t ***l_252 = &g_219;
    (*l_251) = ((safe_mul_func_uint16_t_u_u((g_5 | (((safe_sub_func_uint16_t_u_u(((__builtin_bswap32(l_30) > g_5) != __builtin_clzl((safe_mul_func_uint16_t_u_u((g_34 = 0x5526L), (~0xA720L))))), ((safe_unary_minus_func_uint32_t_u((safe_mul_func_uint16_t_u_u(func_39(((*l_241) = func_42(g_47, ((*l_241) = func_49(l_30)), l_242, &g_48)), g_122.f0), 65532UL)))) >= l_30))) | 4294967295UL) ^ 2UL)), 0x5E75L)) < l_242);
    (*l_252) = (void*)0;
    return (*g_169);
}


/* ------------------------------------------ */
/* 
 * reads : g_219 g_220
 * writes: g_220 g_130.f2
 */
static uint16_t  func_39(uint16_t * p_40, uint16_t  p_41)
{ /* block id: 185 */
    uint32_t l_250 = 1UL;
    (*g_219) = (*g_219);
    (*g_220) = l_250;
    return l_250;
}


/* ------------------------------------------ */
/* 
 * reads : g_219 g_220 g_130.f2 g_130.f3 g_168 g_169 g_122.f1
 * writes: g_220 g_169 g_248 g_48 g_130.f2
 */
static uint16_t * func_42(uint16_t * p_43, uint16_t * p_44, uint32_t  p_45, uint16_t * p_46)
{ /* block id: 171 */
    int32_t *l_243 = &g_130.f2;
    uint8_t *l_246 = (void*)0;
    uint8_t *l_247 = &g_248;
    (*g_219) = l_243;
    (*g_219) = l_243;
    if ((safe_lshift_func_int16_t_s_u(((-3L) && (((**g_219) >= (*g_220)) < ((((((*p_43) = __builtin_ia32_crc32qi(g_130.f3, ((*l_247) = (((*g_168) = (*g_168)) != g_220)))) <= ((p_45 = 0x83A1E9C1L) | (*l_243))) == (-1L)) | g_122.f1) < 0xE8E0L))), 1)))
    { /* block id: 178 */
        int32_t *l_249 = &g_130.f2;
        l_249 = (*g_219);
    }
    else
    { /* block id: 180 */
        (*g_220) = (0x2E7EL > p_45);
    }
    return &g_111;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_48 g_5 g_108 g_106 g_121 g_99 g_122.f4 g_122.f6 g_130.f1 g_122.f2 g_130.f0 g_165 g_168 g_130.f2 g_122.f0 g_130.f3 g_111 g_122.f5 g_219 g_234 g_130.f4 g_220
 * writes: g_90 g_99 g_106 g_108 g_111 g_121 g_130.f2 g_130.f3 g_165 g_130.f6 g_220
 */
static uint16_t * func_49(const int32_t  p_50)
{ /* block id: 38 */
    const uint16_t *l_56 = &g_48;
    int32_t l_225 = 0x3A2588FAL;
    int32_t *l_237 = &g_108;
    uint16_t *l_240 = &g_111;
    if (((*l_237) = (safe_add_func_int16_t_s_s((p_50 != func_53(l_56, (*g_47))), (l_225 < __builtin_bswap32((safe_rshift_func_uint16_t_u_u((safe_div_func_int32_t_s_s((safe_mod_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s((l_225 == p_50), g_234)) | ((safe_sub_func_int16_t_s_s(g_130.f4, (*g_47))) > g_48)), 0xF55BL)), g_130.f4)), 10))))))))
    { /* block id: 161 */
        return &g_111;
    }
    else
    { /* block id: 163 */
        uint32_t l_238 = 1UL;
        int32_t l_239 = (-1L);
        l_238 = (*l_237);
        l_239 = ((*l_237) = p_50);
        (*g_219) = (*g_219);
    }
    return l_240;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_48 g_5 g_108 g_106 g_121 g_99 g_122.f4 g_122.f6 g_130.f1 g_122.f2 g_130.f0 g_165 g_168 g_130.f2 g_122.f0 g_130.f3 g_111 g_122.f5 g_219
 * writes: g_90 g_99 g_106 g_108 g_111 g_121 g_130.f2 g_130.f3 g_165 g_130.f6
 */
static uint16_t  func_53(const uint16_t * p_54, uint16_t  p_55)
{ /* block id: 39 */
    uint16_t *l_58 = &g_48;
    uint16_t **l_57 = &l_58;
    int32_t l_69 = 1L;
    int32_t l_74 = 1L;
    uint16_t **l_205 = &l_58;
    int16_t *l_208 = &g_130.f6;
    int32_t **l_223 = (void*)0;
    l_57 = (void*)0;
    if (((safe_sub_func_int32_t_s_s((0xD370L > ((safe_rshift_func_int16_t_s_s(((safe_lshift_func_int16_t_s_u((((void*)0 != &g_47) < (safe_add_func_uint16_t_u_u((((safe_div_func_int16_t_s_s((l_69 = (-1L)), p_55)) > (*g_47)) | func_70(l_74, ((*l_208) = ((func_75(((*l_205) = func_77(func_82((safe_mod_func_uint32_t_u_u((l_74 <= (*g_47)), g_5)), g_5, p_55, (*p_54)), &l_58, (*g_47), l_74))) < 0x5FEEA2D5L) < l_74)), l_74)), l_74))), 13)) > p_55), 6)) >= g_122.f5)), p_55)) | l_74))
    { /* block id: 148 */
        uint16_t l_212 = 1UL;
        int32_t *l_213 = &l_74;
        l_212 = p_55;
        (*l_213) = 0xEAF5C805L;
    }
    else
    { /* block id: 151 */
        int32_t **l_214 = (void*)0;
        int32_t *l_216 = &g_5;
        int32_t **l_215 = &l_216;
        int32_t ***l_221 = (void*)0;
        int32_t ***l_222 = &l_214;
        uint16_t l_224 = 0x1B31L;
        (*l_215) = &l_69;
        (**l_215) = (((safe_rshift_func_int16_t_s_u(0x6C97L, (*g_47))) & (g_130.f0 != (l_74 = l_74))) | (l_224 = (((*g_47) || 0L) || (((*l_222) = g_219) == l_223))));
        l_74 = g_130.f0;
    }
    return (*p_54);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_70(int32_t  p_71, int16_t  p_72, uint16_t  p_73)
{ /* block id: 145 */
    int32_t *l_210 = &g_5;
    int32_t **l_209 = &l_210;
    const int16_t l_211 = 0x14A6L;
    (*l_209) = &g_108;
    return l_211;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_75(uint16_t * p_76)
{ /* block id: 141 */
    struct S0 *l_206 = &g_130;
    int16_t l_207 = 0xC2FEL;
    l_206 = l_206;
    return l_207;
}


/* ------------------------------------------ */
/* 
 * reads : g_111 g_130.f3 g_5 g_99
 * writes: g_111 g_108 g_99
 */
static uint16_t * func_77(const uint16_t * p_78, uint16_t ** p_79, uint16_t  p_80, int32_t  p_81)
{ /* block id: 125 */
    int32_t *l_198 = (void*)0;
    int32_t **l_197 = &l_198;
    uint16_t *l_204 = &g_111;
lbl_203:
    (*l_197) = &p_81;
    for (g_111 = (-21); (g_111 <= 30); g_111 = safe_add_func_int32_t_s_s(g_111, 8))
    { /* block id: 129 */
        (*l_198) = (func_102(__builtin_popcount(g_130.f3)) >= g_111);
        for (g_99 = (-18); (g_99 > 3); g_99 = safe_add_func_int16_t_s_s(g_99, 6))
        { /* block id: 133 */
            (*l_197) = &g_5;
            return (*p_79);
        }
        if (g_111)
            goto lbl_203;
    }
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_108 g_5 g_106 g_121 g_99 g_122.f4 g_47 g_122.f6 g_130.f1 g_122.f2 g_130.f0 g_165 g_168 g_130.f2 g_122.f0 g_130.f3 g_111
 * writes: g_90 g_99 g_106 g_108 g_111 g_121 g_130.f2 g_130.f3 g_165
 */
static uint16_t * func_82(int32_t  p_83, uint32_t  p_84, int16_t  p_85, uint16_t  p_86)
{ /* block id: 42 */
    int32_t l_109 = 4L;
    uint16_t l_112 = 0x1B79L;
    int32_t *l_119 = &g_5;
    int32_t **l_118 = &l_119;
    struct S0 *l_132 = &g_130;
    int32_t *l_137 = &g_130.f2;
    int16_t l_154 = (-4L);
    if (p_85)
    { /* block id: 43 */
        uint32_t *l_89 = &g_90;
        uint32_t *l_98 = &g_99;
        int32_t l_104 = 1L;
        uint32_t *l_105 = &g_106;
        uint16_t *l_110 = &g_111;
        int32_t *l_113 = &l_104;
        int32_t **l_116 = (void*)0;
        int32_t **l_117 = &l_113;
        if (((0x22527051L <= (__builtin_parity((((*l_89) = 0UL) < ((*l_113) = (safe_mul_func_uint16_t_u_u(((((+g_48) | (safe_mod_func_uint16_t_u_u((1UL && (p_84 || __builtin_ctzl(((safe_add_func_uint32_t_u_u(((*l_98) = 0x6251CA2AL), ((safe_mod_func_uint32_t_u_u((((*l_110) = (func_102(((*l_105) = l_104)) && (l_109 = __builtin_ctz(g_108)))) | 0x4C67L), l_104)) | 0xB492L))) <= 0x7968679DL)))), l_112))) & l_104) | p_83), 0x2BE3L))))) | l_112)) | p_84))
        { /* block id: 53 */
            for (g_106 = 0; (g_106 != 12); g_106 = safe_add_func_int32_t_s_s(g_106, 6))
            { /* block id: 56 */
                return &g_48;
            }
        }
        else
        { /* block id: 59 */
            return &g_48;
        }
        (*l_117) = &l_104;
        (*l_113) = p_83;
    }
    else
    { /* block id: 64 */
        int32_t ***l_120 = &l_118;
        const struct S0 **l_123 = (void*)0;
        uint32_t *l_144 = &g_99;
        int32_t l_151 = 0xAECEF6A3L;
        uint16_t *l_164 = &g_48;
        uint32_t **l_170 = &g_169;
        (*l_120) = l_118;
        g_121 = g_121;
        for (g_99 = 0; (g_99 <= 10); g_99 = safe_add_func_int32_t_s_s(g_99, 1))
        { /* block id: 69 */
            uint32_t l_126 = 1UL;
            struct S0 *l_129 = &g_130;
            struct S0 **l_131 = &l_129;
            const struct S0 **l_133 = &g_121;
            int32_t l_134 = (-10L);
            uint32_t l_161 = 4294967292UL;
            int32_t ***l_189 = &l_118;
            if ((g_130.f2 = (p_84 >= (l_126 & ((((safe_add_func_uint32_t_u_u((((((*l_131) = l_129) != l_132) < func_102(g_122.f4)) | l_126), (&g_130 == ((*l_133) = &g_122)))) <= (*g_47)) == g_122.f6) >= 0x2A54L)))))
            { /* block id: 73 */
                l_134 = __builtin_clzll(g_130.f1);
                (*l_118) = (*l_118);
            }
            else
            { /* block id: 76 */
                const uint32_t l_152 = 4294967288UL;
                int32_t l_153 = 0x29AA74C4L;
                const struct S0 *l_155 = &g_122;
                uint32_t *l_156 = (void*)0;
                uint32_t *l_157 = &g_130.f3;
                if (p_84)
                    break;
                for (p_84 = 0; (p_84 != 39); p_84 = safe_add_func_uint32_t_u_u(p_84, 1))
                { /* block id: 80 */
                    l_137 = ((**l_120) = &g_108);
                }
                (*l_137) = (safe_sub_func_uint32_t_u_u((safe_sub_func_int16_t_s_s(8L, __builtin_clzll((((safe_add_func_int32_t_s_s((l_134 & (l_144 == &g_90)), (safe_add_func_uint16_t_u_u(((l_153 = ((g_122.f2 <= (safe_lshift_func_uint16_t_u_u(__builtin_ffsl((0x768AL == (0xAAA5L || (safe_add_func_uint16_t_u_u((l_134 > l_151), l_152))))), 13))) & (*g_47))) > l_154), 0x3ED5L)))) | g_130.f0) == (***l_120))))), 1L));
                if (__builtin_clzl(((*l_157) = (l_132 == l_155))))
                { /* block id: 87 */
                    struct S0 ****l_167 = &g_165;
                    for (l_153 = 0; (l_153 <= (-26)); l_153--)
                    { /* block id: 90 */
                        int32_t *l_160 = &l_134;
                        uint16_t **l_163 = &g_47;
                        uint16_t ***l_162 = &l_163;
                        (*l_118) = l_160;
                        (**l_118) = l_161;
                        (*l_162) = &g_47;
                        return l_164;
                    }
                    (*l_167) = g_165;
                    l_170 = g_168;
                }
                else
                { /* block id: 98 */
                    int16_t l_193 = 1L;
                    for (l_134 = 25; (l_134 <= 3); --l_134)
                    { /* block id: 101 */
                        int16_t *l_181 = &l_154;
                        uint16_t *l_186 = &g_111;
                        const int32_t l_190 = 0x79C7D366L;
                        if (g_48)
                            break;
                        (*l_137) = ((((safe_div_func_int32_t_s_s((0x24BB92A5L != (~((safe_rshift_func_int16_t_s_u(((*l_181) = (safe_rshift_func_uint16_t_u_s((*g_47), (!(**l_118))))), ((*l_186) = (safe_div_func_int32_t_s_s(__builtin_ffsll(p_85), (safe_add_func_int32_t_s_s(g_130.f2, p_85))))))) || (safe_rshift_func_int16_t_s_s(((void*)0 == l_189), p_86))))), p_85)) && (*g_47)) & l_190) == (**l_118));
                        (*l_137) = (((&p_85 == g_47) && (***l_120)) > g_122.f0);
                        if (l_153)
                            break;
                    }
                    for (l_151 = 0; (l_151 != (-25)); --l_151)
                    { /* block id: 111 */
                        struct S0 **l_196 = &l_129;
                        l_193 = (-1L);
                        (**l_120) = &g_108;
                        if (g_130.f3)
                            continue;
                        (*l_137) = (func_102(((safe_sub_func_int32_t_s_s(p_85, 0xD0841373L)) >= (((*g_47) < ((l_196 == (void*)0) | ((((**l_189) = &g_108) == l_144) < g_111))) <= (g_5 <= 0x6FEDBD15L)))) | l_152);
                    }
                    return l_164;
                }
            }
        }
    }
    g_108 = 0x24636B98L;
    return &g_111;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_108
 */
static uint16_t  func_102(uint32_t  p_103)
{ /* block id: 47 */
    int32_t *l_107 = &g_108;
    (*l_107) = 0x8A7CF5EEL;
    return p_103;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_48, "g_48", print_hash_value);
    transparent_crc(g_90, "g_90", print_hash_value);
    transparent_crc(g_99, "g_99", print_hash_value);
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc(g_108, "g_108", print_hash_value);
    transparent_crc(g_111, "g_111", print_hash_value);
    transparent_crc(g_122.f0, "g_122.f0", print_hash_value);
    transparent_crc(g_122.f1, "g_122.f1", print_hash_value);
    transparent_crc(g_122.f2, "g_122.f2", print_hash_value);
    transparent_crc(g_122.f3, "g_122.f3", print_hash_value);
    transparent_crc(g_122.f4, "g_122.f4", print_hash_value);
    transparent_crc(g_122.f5, "g_122.f5", print_hash_value);
    transparent_crc(g_122.f6, "g_122.f6", print_hash_value);
    transparent_crc(g_130.f0, "g_130.f0", print_hash_value);
    transparent_crc(g_130.f1, "g_130.f1", print_hash_value);
    transparent_crc(g_130.f2, "g_130.f2", print_hash_value);
    transparent_crc(g_130.f3, "g_130.f3", print_hash_value);
    transparent_crc(g_130.f4, "g_130.f4", print_hash_value);
    transparent_crc(g_130.f5, "g_130.f5", print_hash_value);
    transparent_crc(g_130.f6, "g_130.f6", print_hash_value);
    transparent_crc(g_234, "g_234", print_hash_value);
    transparent_crc(g_248, "g_248", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 55
XXX total union variables: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 12
   depth: 4, occurrence: 3
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 79

XXX times a variable address is taken: 77
XXX times a pointer is dereferenced on RHS: 29
breakdown:
   depth: 1, occurrence: 24
   depth: 2, occurrence: 3
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 51
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 137

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 96
   level: 2, occurrence: 20
   level: 3, occurrence: 8
XXX number of pointers point to pointers: 29
XXX number of pointers point to scalars: 45
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 13.9
XXX average alias set size: 1.15

XXX times a non-volatile is read: 209
XXX times a non-volatile is write: 136
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 78
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 20
   depth: 2, occurrence: 5
   depth: 3, occurrence: 7
   depth: 4, occurrence: 7
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 25.7
XXX percentage an existing variable is used: 74.3
********************* end of statistics **********************/

