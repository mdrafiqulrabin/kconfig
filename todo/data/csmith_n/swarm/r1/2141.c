/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1891305280
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   float  f0;
   uint32_t  f1;
   float  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static float g_3 = (-0x1.Dp-1);
static uint16_t g_5 = 0x7DC4;
static int32_t g_46 = 0x40C3F30B;
static int32_t *g_45 = &g_46;
static struct S0 g_83 = {0x1.8p+1,0xEFB48CA1,0x0.88558Bp+77};
static int32_t g_154 = 0x819422B6;
static int32_t ***g_208 = (void*)0;
static int32_t ****g_207 = &g_208;
static float *g_246 = &g_83.f2;
static float **g_245 = &g_246;
static int16_t g_254 = 1;
static uint16_t g_259 = 1U;
static int32_t g_268 = 0xBC908AEC;
static int16_t g_278 = 0x1036;
static struct S0 **g_323 = (void*)0;
static struct S0 g_376 = {0x6.0p-1,0x116317C2,0x5.614BA5p+21};
static float ***g_465 = &g_245;
static float ****g_464 = &g_465;
static struct S0 ***g_513 = &g_323;
static struct S0 ****g_512 = &g_513;
static int32_t *g_519 = &g_154;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_29(void);
inline static int32_t * func_32(uint16_t  p_33, uint16_t  p_34, uint16_t  p_35, uint32_t  p_36);
inline static int32_t * func_42(int32_t * p_43, int32_t  p_44);
inline static float  func_49(int32_t * p_50, uint16_t  p_51, uint32_t  p_52, uint16_t  p_53);
static int32_t * func_54(int32_t * p_55, int32_t  p_56, int32_t * p_57, int32_t * p_58);
static int32_t * func_61(int32_t * p_62);
inline static int32_t * func_63(int32_t * p_64);
inline static int32_t * func_65(int32_t * p_66, uint32_t  p_67);
static uint16_t  func_68(int32_t * p_69);
inline static struct S0  func_70(int32_t  p_71);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_45 g_154 g_46 g_465 g_519 g_376.f1 g_278 g_259 g_464 g_245 g_246
 * writes: g_5 g_46 g_245 g_45 g_83.f2
 */
static int16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_37 = 0x01355FFF;
    uint32_t l_535 = 0x382A8CA7;
    for (g_5 = (-26); (g_5 == 33); g_5 = safe_add_func_uint32_t_u_u(g_5, 7))
    { /* block id: 39 */
        float l_38 = 0xA.5132D7p+68;
        int32_t l_41 = (-1);
        uint32_t l_532 = 3U;
        g_45 = func_32((l_37 >= l_37), g_5, ((safe_mod_func_int32_t_s_s(l_41, g_5)) , 1U), l_37);
        (****g_464) = (((!(safe_mul_func_int16_t_s_s(l_37, (((safe_div_func_uint16_t_u_u(l_37, 1)) < (safe_sub_func_uint16_t_u_u((g_376.f1 >= (l_532 && (l_37 | g_278))), (safe_add_func_uint32_t_u_u(l_41, (l_37 < g_259)))))) != (-1))))) , 0U) , 0x2.6B1E96p+18);
    }
    return l_535;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_46 g_465 g_519 g_154
 * writes: g_46 g_245
 */
inline static int32_t * func_32(uint16_t  p_33, uint16_t  p_34, uint16_t  p_35, uint32_t  p_36)
{ /* block id: 40 */
    int32_t **l_523 = (void*)0;
    int32_t *l_524 = (void*)0;
    l_524 = func_42(g_45, (*g_45));
    l_524 = func_42(&g_268, (*g_519));
    return l_524;
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_465
 * writes: g_46 g_245
 */
inline static int32_t * func_42(int32_t * p_43, int32_t  p_44)
{ /* block id: 41 */
    int32_t *l_59 = (void*)0;
    struct S0 l_60 = {0x1.Fp+1,4294967295U,0x2.BDB62Bp+40};
    int32_t l_471 = 0x5A6EB08D;
    float **l_477 = &g_246;
    int32_t *l_494 = &g_154;
    struct S0 *l_508 = &g_83;
    struct S0 **l_507 = &l_508;
    int32_t ****l_509 = &g_208;
    struct S0 ****l_520 = &g_513;
    int32_t ****l_522 = &g_208;
    for (g_46 = 0; (g_46 <= (-27)); g_46 = safe_sub_func_uint16_t_u_u(g_46, 5))
    { /* block id: 44 */
        float l_123 = 0x1.FCBABAp+6;
        float l_369 = 0xF.874EE3p+93;
        int32_t l_370 = 0;
        int32_t *l_450 = (void*)0;
        int32_t *l_456 = &g_46;
        float ***l_458 = &g_245;
        struct S0 l_463 = {-0x10.4p-1,4294967287U,0x0.Bp-1};
        int32_t l_485 = 0xC64F53CB;
        struct S0 ****l_514 = &g_513;
        uint16_t l_518 = 0U;
        struct S0 *****l_521 = (void*)0;
    }
    l_522 = l_509;
    (*g_465) = l_477;
    return &g_154;
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_154 g_83 g_254 g_259 g_246 g_5 g_45 g_3 g_323 g_376.f1 g_207 g_208 g_278
 * writes: g_376 g_83 g_259 g_45 g_3
 */
inline static float  func_49(int32_t * p_50, uint16_t  p_51, uint32_t  p_52, uint16_t  p_53)
{ /* block id: 223 */
    int32_t l_374 = 7;
    struct S0 *l_375 = &g_376;
    int32_t *l_377 = &g_46;
    int32_t l_380 = 1;
    struct S0 ***l_381 = &g_323;
    int32_t *l_383 = &g_154;
    float ***l_401 = &g_245;
    for (p_53 = 0; (p_53 >= 7); ++p_53)
    { /* block id: 226 */
        int32_t *l_373 = &g_46;
        int32_t **l_378 = (void*)0;
        int32_t **l_379 = &l_377;
    }
    if ((*l_377))
    { /* block id: 232 */
        struct S0 ****l_382 = &l_381;
        (*l_382) = l_381;
    }
    else
    { /* block id: 234 */
        struct S0 *l_386 = (void*)0;
        l_383 = p_50;
        for (p_52 = (-19); (p_52 <= 29); p_52 = safe_add_func_uint32_t_u_u(p_52, 3))
        { /* block id: 238 */
            struct S0 **l_387 = &l_375;
            (*l_387) = l_386;
        }
    }
    if ((*l_383))
    { /* block id: 242 */
        struct S0 l_388 = {0x9.D116E5p-85,8U,0x2.01F773p+63};
        struct S0 *l_389 = &g_376;
        (*l_389) = l_388;
    }
    else
    { /* block id: 244 */
        struct S0 *l_390 = &g_83;
        int32_t l_398 = 0xFBF402CE;
        float ***l_400 = &g_245;
        float ***l_448 = &g_245;
        float ****l_449 = &l_400;
        (*l_390) = g_83;
        for (p_51 = 2; (p_51 <= 28); ++p_51)
        { /* block id: 248 */
            int32_t *l_393 = &l_380;
            float **l_399 = &g_246;
            struct S0 **l_445 = (void*)0;
            float ****l_447 = &l_400;
            if ((p_53 && ((((((((safe_sub_func_int32_t_s_s((g_46 , (*p_50)), l_398)) , l_399) == l_399) , l_400) != l_401) == g_254) ^ 0U) != 1U)))
            { /* block id: 249 */
                return p_51;
            }
            else
            { /* block id: 251 */
                struct S0 l_402 = {0x0.7702C5p+43,3U,0x8.25E17Dp+92};
                (*l_390) = l_402;
                (**l_399) = ((+(((~((safe_mod_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(((*p_50) <= p_53), 2)), ((safe_rshift_func_int16_t_s_u(p_51, 4)) == (*l_383)))) < g_46), g_259)) != 0x5C0EDC9B)) , 0xC32C68FE) , (*l_377))) , (-0x1.3p+1));
            }
            for (g_259 = 0; (g_259 <= 55); g_259 = safe_add_func_int32_t_s_s(g_259, 1))
            { /* block id: 257 */
                int16_t l_425 = (-1);
                struct S0 l_436 = {0x1.3p-1,0x0A8E17AF,0xE.D41997p-99};
                l_425 = (safe_add_func_uint32_t_u_u((((*g_246) == (safe_sub_func_float_f_f(((safe_mod_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint16_t_u_s(l_398, ((func_70((*p_50)) , g_254) , (p_52 && g_259)))) ^ (1U | (*l_393))), p_53)), g_154)) , l_398), p_52))) , p_52), (*p_50)));
                for (g_376.f1 = 29; (g_376.f1 <= 32); g_376.f1 = safe_add_func_int16_t_s_s(g_376.f1, 7))
                { /* block id: 261 */
                    for (l_380 = (-26); (l_380 >= (-19)); l_380 = safe_add_func_uint16_t_u_u(l_380, 3))
                    { /* block id: 264 */
                        int32_t **l_430 = &l_377;
                        (*l_430) = p_50;
                    }
                }
                for (p_53 = (-11); (p_53 > 46); p_53++)
                { /* block id: 270 */
                    struct S0 l_435 = {0xA.AC3ADBp-70,1U,0x2.8F4729p-95};
                    for (l_398 = 0; (l_398 == (-8)); --l_398)
                    { /* block id: 273 */
                        l_436 = l_435;
                    }
                }
                (*l_393) = ((safe_div_func_uint32_t_u_u((*l_383), (((safe_sub_func_int32_t_s_s((((((&l_390 != g_323) || l_436.f1) & (((g_376.f1 , __builtin_clzll(p_51)) , (0x8BBA == (safe_div_func_int16_t_s_s((((safe_sub_func_int16_t_s_s(((*g_207) != (*g_207)), p_53)) , (*l_381)) != l_445), p_52)))) ^ (*l_377))) == l_398) < p_53), 0U)) && g_278) & (-5)))) > 0);
            }
            (*g_246) = (-(l_447 != (void*)0));
        }
        (*l_449) = l_448;
    }
    l_380 = (g_259 <= (*l_377));
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_278 g_268 g_154 g_46 g_246 g_83.f2 g_254 g_83 g_45 g_3
 * writes: g_45 g_3 g_83.f1 g_83
 */
static int32_t * func_54(int32_t * p_55, int32_t  p_56, int32_t * p_57, int32_t * p_58)
{ /* block id: 213 */
    int16_t l_346 = 0;
    struct S0 *l_359 = &g_83;
    struct S0 **l_358 = &l_359;
    int32_t *l_365 = &g_154;
    int32_t *l_368 = &g_46;
    if (__builtin_parityll(__builtin_bswap64((9U <= (((safe_sub_func_int16_t_s_s(((~g_5) , (g_278 | g_268)), ((l_346 != p_56) || (safe_add_func_int32_t_s_s((*p_58), ((0x979E | (l_346 >= g_268)) != 0x49B17201)))))) >= 0xD1871B91) > 5U)))))
    { /* block id: 214 */
        uint32_t l_349 = 4294967295U;
        uint32_t l_364 = 0x5E941047;
        int32_t **l_366 = (void*)0;
        int32_t *l_367 = &g_154;
        l_367 = (((*p_58) != __builtin_clzl((g_46 == (l_349 != (safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s((((*g_246) >= (safe_sub_func_float_f_f((safe_sub_func_float_f_f(((void*)0 != l_358), (__builtin_ffsl((safe_mod_func_int32_t_s_s(((((safe_lshift_func_int16_t_s_s(g_254, 13)) != l_364) ^ g_5) ^ 0xA435), 4))) < p_56))), 0x1.6p-1))) , p_56), 10)), g_268)))))) , l_365);
        return l_365;
    }
    else
    { /* block id: 217 */
        l_365 = &p_56;
    }
    p_55 = &p_56;
    (*l_359) = func_70(__builtin_parity(g_268));
    return l_368;
}


/* ------------------------------------------ */
/* 
 * reads : g_154 g_46 g_207 g_208 g_246 g_254 g_268 g_278 g_259 g_83.f1
 * writes: g_154 g_83.f2 g_254 g_83.f1
 */
static int32_t * func_61(int32_t * p_62)
{ /* block id: 185 */
    struct S0 *l_279 = &g_83;
    struct S0 **l_280 = &l_279;
    int32_t l_281 = 7;
    int32_t l_285 = 4;
    float ***l_288 = &g_245;
    float ***l_310 = &g_245;
    (*l_280) = l_279;
    if (((l_281 != l_281) == l_281))
    { /* block id: 187 */
        int32_t *l_282 = &g_154;
        int32_t l_301 = 1;
        struct S0 l_341 = {0x9.7p-1,4294967288U,0x0.Dp-1};
        (*l_282) = (*p_62);
        (*l_282) = (*l_282);
        (*g_246) = (safe_div_func_float_f_f(l_285, (((*g_207) != (*g_207)) != ((*l_282) , (((safe_unary_minus_func_uint16_t_u((~l_285))) , l_288) == (void*)0)))));
        for (g_254 = (-12); (g_254 < 3); ++g_254)
        { /* block id: 193 */
            int32_t l_291 = 7;
            struct S0 *l_339 = &g_83;
            (*l_282) = ((l_291 , ((safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s(g_268, 7)), (*l_282))) , ((safe_sub_func_int32_t_s_s((l_291 || __builtin_parityll(l_281)), (safe_add_func_uint32_t_u_u(l_281, (0xFD50 < ((safe_unary_minus_func_int16_t_s((((g_278 || l_291) , (*l_282)) | l_281))) == l_301)))))) >= l_291))) == g_259);
            for (g_83.f1 = 0; (g_83.f1 >= 54); ++g_83.f1)
            { /* block id: 197 */
                uint32_t l_309 = 0U;
                struct S0 l_340 = {0xB.0A924Ap-82,0xB91C458B,0x9.678778p-44};
                int32_t **l_342 = &l_282;
            }
        }
    }
    else
    { /* block id: 209 */
        return p_62;
    }
    return &g_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_83.f1 g_154 g_46 g_83 g_5 g_207 g_45 g_254 g_259 g_246 g_278
 * writes: g_83.f1 g_154 g_83.f2 g_45 g_245 g_268 g_83
 */
inline static int32_t * func_63(int32_t * p_64)
{ /* block id: 118 */
    float l_171 = 0x5.BDD5AFp-34;
    int32_t l_172 = (-3);
    int32_t **l_179 = &g_45;
    int32_t ***l_178 = &l_179;
    int32_t ****l_177 = &l_178;
    struct S0 l_231 = {0x1.2A1733p+28,3U,0xF.27325Ep-19};
    int16_t l_241 = 0xF13C;
    float l_242 = 0xF.94B598p+75;
    float *l_244 = (void*)0;
    float **l_243 = &l_244;
    float l_277 = 0x9.9575F5p-73;
    for (g_83.f1 = 0; (g_83.f1 <= 9); ++g_83.f1)
    { /* block id: 121 */
        float *l_173 = (void*)0;
        float *l_174 = &g_83.f2;
        int32_t l_195 = 0;
        int32_t l_214 = 0x62234214;
        int32_t l_230 = (-1);
        for (g_154 = 8; (g_154 != 22); ++g_154)
        { /* block id: 124 */
            float l_163 = 0x1.Ep-1;
            int32_t l_165 = 1;
            int32_t *l_166 = &l_165;
            (*l_166) = ((((*p_64) <= (*p_64)) > (((!g_46) <= l_165) || 0xA4BB)) >= (*p_64));
        }
        (*l_174) = (safe_sub_func_float_f_f((safe_div_func_float_f_f(l_171, l_172)), __builtin_parityll(g_46)));
        for (g_154 = 16; (g_154 != (-6)); g_154 = safe_sub_func_int16_t_s_s(g_154, 1))
        { /* block id: 130 */
            int32_t *****l_180 = (void*)0;
            int32_t *****l_181 = &l_177;
            struct S0 l_182 = {0xF.DDD0EBp+48,0xBDD0B693,-0x9.6p+1};
            (*l_181) = l_177;
            if ((l_182 , (((safe_add_func_int16_t_s_s(((*p_64) <= 0x28E2A20A), (safe_div_func_int16_t_s_s(g_46, ((safe_sub_func_float_f_f((safe_add_func_float_f_f((((safe_mod_func_int16_t_s_s(g_83.f1, (safe_lshift_func_uint16_t_u_s(g_46, 10)))) != l_195) , (safe_sub_func_float_f_f((safe_sub_func_float_f_f(0x8.7p-1, (safe_sub_func_float_f_f((g_154 < l_195), 0x1.8p+1)))), (-0x3.4p-1)))), l_195)), (-0x8.7p-1))) , g_154))))) , g_83) , (*p_64))))
            { /* block id: 132 */
                for (l_195 = (-3); (l_195 <= (-29)); l_195 = safe_sub_func_int16_t_s_s(l_195, 4))
                { /* block id: 135 */
                    uint32_t l_206 = 0x91CC097D;
                    int32_t l_210 = 0x81F2D68B;
                    (**l_178) = &g_46;
                    if ((safe_div_func_uint16_t_u_u(g_5, l_206)))
                    { /* block id: 137 */
                        int32_t ****l_209 = &l_178;
                        l_210 = (g_207 != l_209);
                    }
                    else
                    { /* block id: 139 */
                        if (l_206)
                            break;
                        (***l_177) = p_64;
                    }
                }
                return p_64;
            }
            else
            { /* block id: 145 */
                float l_215 = 0x4.B6B4A2p+31;
                int32_t l_227 = 0x12CE41FC;
                struct S0 *l_229 = &l_182;
                struct S0 **l_228 = &l_229;
                for (l_195 = (-6); (l_195 >= 22); ++l_195)
                { /* block id: 148 */
                    float l_213 = (-0x1.2p+1);
                    int32_t **l_216 = (void*)0;
                    struct S0 *l_226 = &g_83;
                    struct S0 **l_225 = &l_226;
                    l_230 = ((((l_214 | l_214) , l_216) == (g_154 , (void*)0)) == (!(safe_sub_func_int16_t_s_s(((safe_unary_minus_func_uint16_t_u((safe_div_func_int32_t_s_s(((safe_add_func_uint16_t_u_u(((*p_64) < ((l_225 != (l_227 , l_228)) == l_227)), l_182.f1)) , (*p_64)), l_214)))) <= l_195), g_5))));
                }
                (*l_174) = l_227;
                (**l_228) = l_231;
                (****l_181) = p_64;
            }
        }
        g_83.f2 = ((safe_add_func_float_f_f(l_214, ((*l_179) != (void*)0))) != g_5);
    }
    (**l_178) = p_64;
    g_245 = l_243;
    for (g_154 = 0; (g_154 != 17); ++g_154)
    { /* block id: 162 */
        uint32_t l_251 = 0xA6F621B4;
        for (l_172 = 14; (l_172 != (-14)); l_172 = safe_sub_func_int32_t_s_s(l_172, 7))
        { /* block id: 165 */
            uint32_t l_252 = 0x14CE61BC;
            int32_t **l_253 = (void*)0;
            float ***l_269 = (void*)0;
            if (((((((&g_83 != &g_83) > (l_251 > ((void*)0 == (*l_243)))) , l_252) || (0xE542F5EF | (l_253 == (((-5) > (**l_179)) , l_253)))) && g_254) <= (-1)))
            { /* block id: 166 */
                float l_260 = 0xB.C6DFB0p-70;
                uint32_t l_261 = 0xBFA45521;
                uint32_t l_264 = 0x6FF74A9D;
                float ****l_270 = &l_269;
                struct S0 *l_271 = (void*)0;
                struct S0 *l_272 = &g_83;
                if (((safe_div_func_int32_t_s_s((((g_259 & l_252) < (((**l_177) == ((*g_45) , &p_64)) & g_254)) & ((g_46 & (*p_64)) < (l_261 || l_251))), 0xD2DBEE02)) ^ g_154))
                { /* block id: 167 */
                    int32_t *l_265 = &g_154;
                    struct S0 *l_266 = &l_231;
                    (*l_179) = (__builtin_ctz(((-2) < (((l_264 != (*p_64)) <= ((*g_45) == (*g_45))) ^ (*p_64)))) , l_265);
                    (*l_266) = g_83;
                }
                else
                { /* block id: 170 */
                    int32_t *l_267 = &g_268;
                    (*l_267) = (g_83.f1 ^ __builtin_popcountll(l_261));
                    (*l_267) = 0x9F92A775;
                    return (**l_178);
                }
                (*l_270) = l_269;
                (*l_272) = g_83;
            }
            else
            { /* block id: 177 */
                return (*l_179);
            }
            (*g_246) = (((safe_add_func_float_f_f(((void*)0 == p_64), (*g_246))) > (safe_sub_func_float_f_f(((l_277 == 0x4.24BE17p-74) >= g_278), (*g_246)))) < __builtin_ia32_crc32qi((g_254 & 0xABF4), g_83.f1));
        }
        (*g_246) = (*g_246);
    }
    return (***l_177);
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_5 g_45 g_83 g_3
 * writes: g_45 g_3 g_83.f1 g_83 g_154
 */
inline static int32_t * func_65(int32_t * p_66, uint32_t  p_67)
{ /* block id: 88 */
    int16_t l_135 = 0x3DD1;
    int32_t *l_156 = (void*)0;
    int32_t *l_157 = &g_154;
    int32_t *l_158 = &g_46;
    if ((*p_66))
    { /* block id: 89 */
        uint32_t l_124 = 0U;
        int32_t l_136 = 0x2E2238E9;
        int32_t **l_150 = &g_45;
        if (l_124)
        { /* block id: 90 */
            int32_t *l_125 = &g_46;
            p_66 = l_125;
        }
        else
        { /* block id: 92 */
            int16_t l_130 = 7;
            int32_t *l_142 = &g_46;
            l_136 = (__builtin_ffs((*p_66)) & (safe_sub_func_uint32_t_u_u(((safe_mod_func_uint32_t_u_u(g_5, (l_130 , ((((((func_68(&g_46) != (((safe_rshift_func_int16_t_s_s((-6), (safe_div_func_int16_t_s_s((((p_67 < l_135) < l_130) < 0U), p_67)))) < 0xBC89) || g_5)) , 65526U) ^ g_5) ^ p_67) , l_135) & g_5)))) <= g_5), l_130)));
            for (l_130 = (-28); (l_130 > 28); l_130++)
            { /* block id: 96 */
                struct S0 *l_139 = (void*)0;
                struct S0 *l_140 = &g_83;
                int32_t **l_141 = &g_45;
                int32_t *l_143 = &l_136;
                (*l_140) = func_70(l_135);
                (*l_141) = &g_46;
                if ((*p_66))
                    break;
                (*l_143) = func_68(l_142);
            }
        }
        for (l_136 = 22; (l_136 < 28); l_136 = safe_add_func_int16_t_s_s(l_136, 7))
        { /* block id: 105 */
            int32_t **l_146 = (void*)0;
            int32_t **l_147 = (void*)0;
            int32_t **l_148 = (void*)0;
            int32_t **l_149 = &g_45;
            (*l_149) = p_66;
            return p_66;
        }
        (*l_150) = (void*)0;
        (*l_150) = (*l_150);
    }
    else
    { /* block id: 111 */
        struct S0 l_151 = {0x0.Cp+1,0xD61F34F6,0x5.D68C91p-33};
        struct S0 *l_152 = &g_83;
        int32_t *l_153 = &g_154;
        int32_t **l_155 = &g_45;
        (*l_152) = l_151;
        (*l_153) = 0;
        (*l_155) = &g_154;
    }
    (*l_157) = (l_156 == (void*)0);
    return l_158;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_46 g_5 g_83 g_3
 * writes: g_45 g_3 g_83.f1
 */
static uint16_t  func_68(int32_t * p_69)
{ /* block id: 45 */
    uint32_t l_111 = 0x8F345D26;
    float *l_118 = &g_3;
    (*l_118) = (func_70((*g_45)) , ((safe_add_func_float_f_f((((safe_sub_func_float_f_f(0x0.54C0A2p-43, l_111)) > (safe_sub_func_float_f_f((safe_add_func_float_f_f(((((g_46 == g_83.f2) >= g_3) , (safe_sub_func_float_f_f((__builtin_popcountll(g_46) != l_111), l_111))) <= g_3), g_83.f1)), l_111))) == g_46), l_111)) != g_3));
    return l_111;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_46 g_83 g_45 g_3
 * writes: g_45 g_3 g_83.f1
 */
inline static struct S0  func_70(int32_t  p_71)
{ /* block id: 46 */
    uint16_t l_72 = 6U;
    struct S0 l_73 = {0x2.Ep+1,4294967295U,0x1.9p+1};
    float *l_81 = &g_3;
    uint32_t l_93 = 0x4358B9E0;
    int32_t l_104 = 0;
    int32_t **l_105 = (void*)0;
    int32_t *l_106 = (void*)0;
    if (l_72)
    { /* block id: 47 */
        float *l_74 = &l_73.f0;
        int32_t **l_75 = &g_45;
        struct S0 l_82 = {-0x6.3p+1,0x86A8E7E6,0x1.Cp+1};
        l_73 = l_73;
        (*l_74) = l_73.f1;
        (*l_75) = &g_46;
        if ((safe_lshift_func_int16_t_s_s(g_5, 7)))
        { /* block id: 51 */
            int32_t *l_80 = &g_46;
            struct S0 l_88 = {-0x1.Cp+1,0x7EAD942A,0x1.1p+1};
            for (l_73.f1 = 14; (l_73.f1 <= 6); l_73.f1 = safe_sub_func_uint32_t_u_u(l_73.f1, 1))
            { /* block id: 54 */
                int32_t ***l_87 = &l_75;
                if ((g_46 >= g_46))
                { /* block id: 55 */
                    (*l_75) = &g_46;
                }
                else
                { /* block id: 57 */
                    (*l_75) = l_80;
                    if (p_71)
                        continue;
                    if (p_71)
                        continue;
                }
                if ((l_74 != l_81))
                { /* block id: 62 */
                    return l_82;
                }
                else
                { /* block id: 64 */
                    struct S0 *l_84 = (void*)0;
                    struct S0 *l_85 = (void*)0;
                    struct S0 *l_86 = &l_82;
                    (*l_86) = g_83;
                }
                if ((**l_75))
                    break;
                (*l_87) = &g_45;
            }
            (*l_75) = (l_88 , &g_46);
        }
        else
        { /* block id: 71 */
            (*l_81) = (l_75 != ((**l_75) , l_75));
            for (g_83.f1 = 0; (g_83.f1 != 38); g_83.f1 = safe_add_func_int32_t_s_s(g_83.f1, 1))
            { /* block id: 75 */
                struct S0 *l_92 = &g_83;
                struct S0 **l_91 = &l_92;
                (*l_91) = &l_73;
                if (l_93)
                    break;
            }
            (*l_81) = ((g_5 , (g_5 , (safe_add_func_float_f_f(__builtin_ctz(g_46), (((((safe_lshift_func_uint16_t_u_u((safe_div_func_uint16_t_u_u((p_71 == (safe_lshift_func_uint16_t_u_u((safe_div_func_int16_t_s_s(l_104, (l_73.f1 ^ ((0x3.3p+1 == ((void*)0 == &g_46)) , (**l_75))))), g_83.f1))), p_71)), g_46)) , p_71) , p_71) , g_46) < g_83.f2))))) < g_3);
        }
    }
    else
    { /* block id: 81 */
        (*l_81) = l_73.f1;
    }
    l_106 = &g_46;
    return l_73;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc_bytes (&g_3, sizeof(g_3), "g_3", print_hash_value);
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_46, "g_46", print_hash_value);
    transparent_crc_bytes (&g_83.f0, sizeof(g_83.f0), "g_83.f0", print_hash_value);
    transparent_crc(g_83.f1, "g_83.f1", print_hash_value);
    transparent_crc_bytes (&g_83.f2, sizeof(g_83.f2), "g_83.f2", print_hash_value);
    transparent_crc(g_154, "g_154", print_hash_value);
    transparent_crc(g_254, "g_254", print_hash_value);
    transparent_crc(g_259, "g_259", print_hash_value);
    transparent_crc(g_268, "g_268", print_hash_value);
    transparent_crc(g_278, "g_278", print_hash_value);
    transparent_crc_bytes (&g_376.f0, sizeof(g_376.f0), "g_376.f0", print_hash_value);
    transparent_crc(g_376.f1, "g_376.f1", print_hash_value);
    transparent_crc_bytes (&g_376.f2, sizeof(g_376.f2), "g_376.f2", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 34
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2

XXX total number of pointers: 137

XXX times a variable address is taken: 128
XXX times a pointer is dereferenced on RHS: 88
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 73
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 420

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 418
   level: 2, occurrence: 68
   level: 3, occurrence: 56
   level: 4, occurrence: 32
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 65
XXX number of pointers point to scalars: 52
XXX number of pointers point to structs: 20
XXX percent of pointers has null in alias set: 24.1
XXX average alias set size: 1.24

XXX times a non-volatile is read: 583
XXX times a non-volatile is write: 208
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 138
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 35
   depth: 2, occurrence: 21
   depth: 3, occurrence: 27
   depth: 4, occurrence: 16
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 20.9
XXX percentage an existing variable is used: 79.1
********************* end of statistics **********************/

