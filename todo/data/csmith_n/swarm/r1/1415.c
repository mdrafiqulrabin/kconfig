/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      1782668726
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static float  func_2(uint8_t  p_3, int16_t  p_4, uint8_t  p_5, uint16_t  p_6);
static int32_t  func_8(uint16_t  p_9, float  p_10, uint32_t  p_11);
static uint16_t  func_12(uint32_t  p_13);
static float  func_32(uint32_t  p_33, int32_t  p_34, int32_t ** p_35, int32_t * p_36);
static uint16_t  func_45(const int32_t  p_46, int32_t ** p_47);
static int32_t ** func_48(int32_t * p_49, const uint32_t  p_50, uint32_t  p_51, uint32_t  p_52, int32_t ** p_53);
static uint32_t  func_57(int32_t ** p_58, int32_t * p_59, int32_t ** p_60, int32_t  p_61, int32_t * p_62);
static int32_t ** func_63(uint32_t  p_64, uint32_t  p_65, int32_t  p_66);
static int32_t  func_68(uint16_t  p_69, uint32_t  p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_7 = 1U;
    float l_397 = 0xB.C3C239p+15;
    float *l_396 = &l_397;
    uint32_t l_400 = 4294967289U;
    int32_t l_406 = 0x5E43229E;
    int32_t *l_405 = &l_406;
    int32_t **l_404 = &l_405;
    int32_t l_407 = (-6);
    uint32_t l_460 = 1U;
    (*l_396) = func_2((l_7 <= func_8(func_12(l_7), ((float)(l_396 == (void*)0) - (float)((((float)l_7 - (float)0x3.DC0262p-68) > (((((l_400 > (((-(float)(((float)(l_404 == &l_405) - (float)0x1.C1E7DBp+69) != (*l_405))) >= 0x0.3p+1) == 0xA.FA9926p+54)) != (**l_404)) == (**l_404)) >= l_407) == (*l_405))) == (**l_404))), (*l_405))), (*l_405), (*l_405), (**l_404));
    return l_460;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_2(uint8_t  p_3, int16_t  p_4, uint8_t  p_5, uint16_t  p_6)
{ /* block id: 215 */
    int32_t ***l_432 = (void*)0;
    int32_t ****l_431 = &l_432;
    int32_t *****l_430 = &l_431;
    const int32_t l_453 = 0;
    int32_t l_457 = 8;
    int32_t *l_456 = &l_457;
    int32_t **l_458 = &l_456;
    int32_t *l_459 = (void*)0;
    for (p_5 = 0; (p_5 == 34); p_5 += 9)
    { /* block id: 218 */
        int32_t l_429 = 0x41E83EE8;
        int32_t *l_428 = &l_429;
        int32_t **l_427 = &l_428;
        int32_t ***l_426 = &l_427;
        int32_t ****l_425 = &l_426;
        int32_t *****l_424 = &l_425;
        int16_t l_446 = 0x6D76;
        uint32_t l_452 = 0x0B1F7176;
        float l_455 = 0x7.2073FCp+66;
        float *l_454 = &l_455;
        if ((65534U != 0))
        { /* block id: 219 */
            float *l_447 = (void*)0;
            float *l_448 = (void*)0;
            float l_450 = 0x1.C6C3B8p+48;
            float *l_449 = &l_450;
            int32_t **l_451 = &l_428;
            (*l_449) = ((((float)p_4 - (float)(l_424 != l_430)) != ((float)(((float)((float)(p_5 > p_3) - (float)((((float)((float)(((float)((p_3 <= ((0x3.F6BA0Bp-8 == (((+l_446) < (((0x8.61AEF1p-81 <= (***l_426)) < p_5) > 0x0.1p+1)) >= (-0x7.3p+1))) != p_6)) >= 0xB.976B92p+5) - (float)(*****l_424)) >= p_4) - (float)0xE.5B1BD5p+0) - (float)0x8.58023Ap+14) == p_4) >= p_5)) + (float)0xD.D7E8BEp+9) >= 0x0.9p+1) + (float)p_5)) > p_6);
            l_452 = ((void*)0 == l_451);
        }
        else
        { /* block id: 222 */
            return p_6;
        }
        (*l_454) = l_453;
        if (p_5)
            break;
        (**l_426) = (*l_427);
    }
    (*l_458) = l_456;
    (*l_458) = l_459;
    /* statement id: 230 */
    assert (l_456 == 0);
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_8(uint16_t  p_9, float  p_10, uint32_t  p_11)
{ /* block id: 211 */
    int32_t **l_409 = (void*)0;
    int32_t ***l_408 = &l_409;
    float l_416 = (-0x1.6p-1);
    float *l_415 = &l_416;
    float **l_414 = &l_415;
    float ***l_413 = &l_414;
    int32_t l_417 = 1;
    uint32_t l_418 = 1U;
    int32_t *l_419 = &l_417;
    (*l_419) = (((p_11 < (((((p_11 == (l_408 == &l_409)) > p_11) >= ((int16_t)(!((((((void*)0 == l_413) < ((void*)0 == &l_414)) | l_417) || p_9) || p_11)) << (int16_t)10)) == l_418) > p_9)) && p_9) || p_11);
    (*l_415) = p_10;
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_12(uint32_t  p_13)
{ /* block id: 1 */
    uint32_t l_15 = 0U;
    int32_t *l_42 = (void*)0;
    float ***l_336 = (void*)0;
    int32_t ***l_344 = (void*)0;
    int32_t **l_348 = &l_42;
    int32_t l_371 = 0xB78B4E16;
    int32_t *l_370 = &l_371;
    const uint16_t l_372 = 0xE041;
    uint8_t l_373 = 0x20;
    const int32_t *l_391 = &l_371;
    const int32_t *****l_393 = (void*)0;
    if ((+(65535U > l_15)))
    { /* block id: 2 */
        const int32_t *l_41 = (void*)0;
        const int32_t **l_40 = &l_41;
        int32_t ****l_335 = (void*)0;
        int32_t **l_346 = &l_42;
        int32_t ***l_345 = &l_346;
        for (p_13 = 0; (p_13 >= 21); p_13 += 7)
        { /* block id: 5 */
            int32_t *l_18 = (void*)0;
            int32_t l_20 = (-1);
            int32_t *l_19 = &l_20;
            (*l_19) = 0;
        }
        if ((+p_13))
        { /* block id: 8 */
            return p_13;
        }
        else
        { /* block id: 10 */
            int32_t l_24 = 1;
            int32_t *l_23 = &l_24;
            int32_t **l_22 = &l_23;
            (*l_22) = (void*)0;
            /* statement id: 11 */
            assert (l_23 == 0);
        }
        for (l_15 = 0; (l_15 == 38); l_15 += 1)
        { /* block id: 15 */
            int32_t l_39 = 0x3EE67684;
            int32_t *l_38 = &l_39;
            int32_t **l_37 = &l_38;
            float l_332 = 0xA.AFF5B7p-74;
            float *l_331 = &l_332;
            float **l_338 = &l_331;
            float ***l_337 = &l_338;
            int32_t *****l_341 = &l_335;
            if (p_13)
                break;
            (*l_331) = ((+0x1.Ap-1) > ((float)((((float)func_32(p_13, (l_37 != l_40), &l_38, l_42) - (float)(((p_13 <= 0x8.DB5081p+19) > 0xA.B6996Ep-33) <= p_13)) < p_13) != p_13) - (float)p_13));
            (***l_337) = (((float)((l_335 == (void*)0) <= (l_336 == l_337)) + (float)((float)(((&l_335 == l_341) != ((float)(l_15 < p_13) - (float)p_13)) < p_13) + (float)0x8.D427E3p+82)) < 0x6.3CF3B6p+47);
        }
        l_345 = l_344;
        /* statement id: 180 */
        assert (l_345 == 0);
    }
    else
    { /* block id: 181 */
        int32_t **l_347 = &l_42;
        (*l_347) = (void*)0;
    }
    l_348 = func_63(p_13, p_13, p_13);
    /* statement id: 184 */
    assert (l_348 == 0);
    for (l_15 = (-16); (l_15 >= 35); l_15 += 1)
    { /* block id: 187 */
        return p_13;
    }
    for (l_15 = 0; (l_15 == 30); l_15++)
    { /* block id: 192 */
        const int32_t ***l_354 = (void*)0;
        const int32_t ****l_353 = &l_354;
        int32_t l_355 = 0x85C60F54;
        int32_t *l_375 = (void*)0;
        float l_389 = (-0x1.2p+1);
        float *l_388 = &l_389;
        float **l_387 = &l_388;
        float ***l_386 = &l_387;
        l_355 = ((void*)0 == l_353);
    }
    return p_13;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_32(uint32_t  p_33, int32_t  p_34, int32_t ** p_35, int32_t * p_36)
{ /* block id: 17 */
    int32_t l_55 = (-1);
    int32_t *l_54 = &l_55;
    (**p_35) = ((uint16_t)func_45(p_33, func_48(l_54, (*l_54), (*l_54), (-(uint32_t)func_57(&l_54, &l_55, func_63((((~(**p_35)) && func_68((&p_36 == (void*)0), p_33)) > p_33), p_33, (**p_35)), (*l_54), &l_55)), &l_54)) >> (uint16_t)3);
    /* statement id: 175 */
    assert (l_54 == 0);
    return l_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(const int32_t  p_46, int32_t ** p_47)
{ /* block id: 42 */
    int32_t l_118 = 1;
    int32_t *l_117 = &l_118;
    int32_t **l_116 = &l_117;
    float l_141 = 0x1.Ap+1;
    int32_t ***l_155 = &l_116;
    int32_t ****l_154 = &l_155;
    int32_t *l_257 = &l_118;
    uint8_t l_276 = 0x6A;
    int32_t l_300 = 6;
    (*l_116) = (void*)0;
    /* statement id: 43 */
    assert (l_117 == 0);
    if (((((p_46 & ((int32_t)l_118 + (int32_t)((uint32_t)(~((uint32_t)(l_118 != ((int16_t)((int16_t)(+((uint16_t)p_46 << (uint16_t)8)) << (int16_t)14) % (int16_t)(((uint32_t)(-(int16_t)(p_46 || (((0 != (((uint16_t)(((int16_t)((&p_47 != (void*)0) <= l_118) >> (int16_t)l_118) > p_46) >> (uint16_t)12) >= p_46)) ^ (-1)) != p_46))) + (uint32_t)p_46) && l_118))) - (uint32_t)p_46)) - (uint32_t)l_118))) < p_46) ^ p_46) <= p_46))
    { /* block id: 44 */
        uint8_t l_142 = 0xF6;
        int32_t l_143 = (-6);
        float *l_147 = &l_141;
        uint8_t l_158 = 0x4C;
        int32_t *l_159 = &l_143;
        l_143 = (-(uint32_t)(l_142 > ((0xC938 >= (l_142 >= (p_46 | (p_46 < 0xA981A8B4)))) || l_142)));
        for (l_118 = 0; (l_118 != (-24)); l_118 -= 8)
        { /* block id: 48 */
            float *l_146 = &l_141;
            int32_t *l_148 = &l_143;
            (*l_148) = (l_146 == l_147);
            for (l_142 = 0; (l_142 >= 46); l_142 += 1)
            { /* block id: 52 */
                int32_t *l_153 = &l_118;
                for (l_143 = 0; (l_143 > 11); l_143 += 1)
                { /* block id: 55 */
                    (*l_116) = l_153;
                    /* statement id: 56 */
                    assert (l_117 == &l_118);
                }
                (*l_148) = (p_46 > ((1 & 4294967289U) | (l_154 != (void*)0)));
                (*l_148) = 0x6EB84F5D;
            }
            for (l_142 = 10; (l_142 > 15); l_142 += 1)
            { /* block id: 63 */
                (**l_155) = (*l_116);
                if (l_142)
                    continue;
                if (l_158)
                    break;
            }
            (*l_148) = 0x3AC2B988;
        }
        /* facts after for loop */
        assert (l_117 == &l_118 || l_117 == 0);
        (*l_159) = l_143;
    }
    else
    { /* block id: 71 */
        uint8_t l_162 = 0x08;
        int32_t *l_189 = &l_118;
        int32_t ***l_195 = &l_116;
        int32_t *****l_288 = &l_154;
        float *l_325 = (void*)0;
        float **l_324 = &l_325;
        float ***l_323 = &l_324;
        for (l_118 = (-22); (l_118 <= (-6)); l_118++)
        { /* block id: 74 */
            if (l_162)
                break;
        }
        for (l_118 = 6; (l_118 < 18); l_118++)
        { /* block id: 79 */
            uint8_t l_165 = 1U;
            int32_t *l_197 = &l_118;
            int32_t ****l_225 = &l_195;
            int16_t l_242 = 0x9880;
            uint32_t l_303 = 5U;
            uint32_t l_318 = 3U;
            float ***l_326 = &l_324;
            float *l_330 = &l_141;
            l_165 = p_46;
            for (l_162 = 20; (l_162 != 38); l_162 += 6)
            { /* block id: 83 */
                uint16_t l_178 = 4U;
                int32_t ***l_194 = &l_116;
                int32_t l_198 = 0x74371E87;
                const float *l_251 = (void*)0;
                int32_t *l_262 = &l_198;
                if ((((int16_t)((uint16_t)(l_165 | (((((p_46 != 0x1097) <= ((((int16_t)(65535U >= ((((uint32_t)0xE9EB336D % (uint32_t)1U) <= (((int32_t)l_162 % (int32_t)l_165) & (l_165 > p_46))) | l_165)) >> (int16_t)p_46) & l_178) < l_162)) & p_46) <= p_46) > 1)) << (uint16_t)6) >> (int16_t)2) >= l_165))
                { /* block id: 84 */
                    float *l_191 = &l_141;
                    float **l_190 = &l_191;
                    if (((((uint16_t)0x6194 >> (uint16_t)4) | ((p_46 <= ((((int16_t)((p_47 != (void*)0) < 9) >> (int16_t)9) ^ ((uint32_t)((int16_t)0x5645 + (int16_t)((int16_t)(l_162 ^ l_165) >> (int16_t)p_46)) + (uint32_t)4294967289U)) > 0x0D9D044D)) <= p_46)) ^ 0U))
                    { /* block id: 85 */
                        float ***l_192 = &l_190;
                        (***l_154) = l_189;
                        /* statement id: 86 */
                        assert (l_117 == &l_118);
                        (*l_192) = l_190;
                    }
                    else
                    { /* block id: 88 */
                        uint16_t l_193 = 1U;
                        return l_193;
                    }
                    /* facts after branching */
                    assert (l_117 == &l_118);
                }
                else
                { /* block id: 91 */
                    float *l_196 = &l_141;
                    (*l_196) = (l_194 != l_195);
                    (*l_196) = p_46;
                    (**l_195) = l_197;
                    /* statement id: 94 */
                    assert (l_117 == &l_118);
                    (*l_196) = 0x4.15E00Dp-57;
                }
                /* facts after branching */
                assert (l_117 == &l_118);
                if (((void*)0 == l_189))
                { /* block id: 97 */
                    int16_t l_208 = 1;
                    int32_t l_211 = (-8);
                    l_198 = (4294967290U & ((**l_195) == l_197));
                    l_211 = (((uint32_t)(((*l_195) != (void*)0) != (((((int16_t)((((int16_t)(0xED6A ^ ((*l_189) > ((p_46 | (*l_197)) && (!(***l_194))))) % (int16_t)((((uint32_t)((l_208 != (((((((((uint16_t)(p_46 == (****l_154)) - (uint16_t)l_208) || p_46) < (***l_195)) | (*l_197)) | p_46) < p_46) & l_208) && p_46)) <= p_46) % (uint32_t)0x02A2B83A) >= 0x5CDD) && l_208)) & p_46) < (*l_197)) + (int16_t)p_46) & 0x93E6) || (***l_195)) >= p_46)) % (uint32_t)0x4488D3AE) ^ p_46);
                }
                else
                { /* block id: 100 */
                    int16_t l_240 = (-1);
                    int32_t *l_244 = &l_198;
                    if (((uint32_t)((uint32_t)p_46 % (uint32_t)(*l_189)) - (uint32_t)0U))
                    { /* block id: 101 */
                        const float l_216 = 0x2.5341A8p+12;
                        int32_t *l_217 = &l_198;
                        float *l_218 = (void*)0;
                        float *l_219 = &l_141;
                        if ((***l_194))
                            break;
                        (*l_217) = 0x0E86BA87;
                        (*l_219) = (*l_217);
                        (*l_217) = ((uint32_t)(!((void*)0 == &l_219)) % (uint32_t)(p_46 ^ 0xD4A0325B));
                    }
                    else
                    { /* block id: 106 */
                        float *l_223 = (void*)0;
                        float *l_224 = &l_141;
                        int32_t *****l_226 = &l_154;
                        (*l_224) = p_46;
                        (***l_154) = l_197;
                        (***l_154) = (**l_155);
                        (*l_226) = l_225;
                        /* statement id: 110 */
                        assert (l_154 == &l_195);
                    }
                    if ((***l_194))
                    { /* block id: 112 */
                        uint8_t l_241 = 4U;
                        float *l_243 = &l_141;
                        (*l_243) = ((**l_116) <= ((((((float)((float)(((((float)p_46 + (float)p_46) < ((((((float)((((((((((((float)((((((p_46 < ((((****l_154) <= ((((**l_116) == (!(****l_225))) <= p_46) > (((float)(*l_117) - (float)l_240) <= l_240))) >= p_46) <= p_46)) > p_46) > l_241) != (**l_116)) <= p_46) >= p_46) + (float)p_46) < (****l_154)) <= l_240) < 0x1.2p+1) >= 0x1.0p+1) == (****l_225)) <= 0x7.CA4CA2p+98) < (****l_225)) == (*l_189)) >= l_240) < l_241) + (float)p_46) > (**l_116)) == 0x6.A46BAFp-12) <= l_242) == (-0x4.3p-1))) != 0x7.91D3E5p+84) != p_46) - (float)p_46) - (float)p_46) > (****l_154)) >= 0x4.C3AFA7p-22) > 0xE.490432p-5) > (-0x1.Ap-1)));
                        (*l_116) = l_244;
                        /* statement id: 114 */
                        assert (l_117 == &l_198);
                    }
                    else
                    { /* block id: 115 */
                        float *l_249 = &l_141;
                        int32_t l_250 = (-2);
                        (***l_225) = l_244;
                        /* statement id: 116 */
                        assert (l_117 == &l_198);
                        (***l_194) = ((uint16_t)((((int16_t)((0x621B0013 | (*l_244)) > (((p_46 == (((((((void*)0 == l_249) ^ l_250) < 0) | 2U) != ((*l_189) != (***l_194))) & 0xDEC96D48)) && 4U) >= 0x6A48)) % (int16_t)0x1F0A) > l_250) || (***l_194)) >> (uint16_t)p_46);
                        (***l_194) = (l_251 == (void*)0);
                    }
                    /* facts after branching */
                    assert (l_117 == &l_198);
                }
                /* facts after branching */
                assert (l_117 == &l_198 || l_117 == &l_118);
                for (l_242 = (-18); (l_242 == 4); l_242 += 7)
                { /* block id: 123 */
                    for (l_178 = 0; (l_178 != 31); l_178++)
                    { /* block id: 126 */
                        int32_t *l_256 = &l_198;
                        (***l_225) = l_256;
                        /* statement id: 127 */
                        assert (l_117 == &l_198);
                    }
                    (***l_225) = l_257;
                    /* statement id: 129 */
                    assert (l_117 == &l_118);
                    if ((***l_194))
                        continue;
                }
                (*l_262) = ((((((&l_195 == (void*)0) <= 0x7ECD) ^ ((uint16_t)((((*l_194) == (*l_195)) ^ ((((0x82698C18 && (***l_155)) & (((-1) <= (p_46 & 4294967291U)) | (*l_117))) == (****l_225)) <= (*l_117))) ^ p_46) >> (uint16_t)p_46)) != 1U) > 1U) || (***l_194));
            }
            for (l_165 = 4; (l_165 > 52); l_165 += 6)
            { /* block id: 136 */
                const float ***l_267 = (void*)0;
                int32_t ***l_268 = (void*)0;
                float l_271 = 0x6.3E1BB0p-66;
                int32_t l_277 = 1;
                float *l_319 = (void*)0;
                float *l_320 = &l_271;
                if (((uint16_t)(p_46 || ((((((void*)0 == &l_155) ^ ((void*)0 == l_267)) ^ ((l_268 == &p_47) < ((int16_t)p_46 >> (int16_t)12))) | ((int32_t)((uint16_t)((*l_257) | 0x2E64F090) >> (uint16_t)10) - (int32_t)l_276)) != l_277)) - (uint16_t)(*l_189)))
                { /* block id: 137 */
                    int32_t *l_280 = (void*)0;
                    for (l_276 = 0; (l_276 <= 54); l_276 += 1)
                    { /* block id: 140 */
                        (***l_154) = l_280;
                        /* statement id: 141 */
                        assert (l_117 == 0);
                    }
                }
                else
                { /* block id: 143 */
                    int32_t *l_281 = &l_277;
                    (*l_281) = (l_197 == (void*)0);
                    (*l_116) = &l_277;
                    /* statement id: 145 */
                    assert (l_117 == &l_277);
                    if (p_46)
                    { /* block id: 146 */
                        uint16_t l_282 = 65535U;
                        if ((*l_281))
                            break;
                        //assert (l_117 == dangling);
                        (*l_281) = (*l_117);
                        (***l_195) = l_282;
                    }
                    else
                    { /* block id: 150 */
                        (***l_225) = (***l_154);
                        (**l_195) = (***l_225);
                        return p_46;
                    }
                }
                /* facts after branching */
                //assert (l_117 == &l_277 || l_117 == dangling || l_117 == &l_118 || l_117 == 0);
                for (l_242 = 0; (l_242 <= 2); l_242 += 1)
                { /* block id: 158 */
                    int32_t l_285 = 0xB3185A65;
                    int32_t *l_292 = &l_118;
                    uint16_t l_295 = 65531U;
                    int32_t l_296 = 0x2EE27637;
                    if (l_285)
                        break;
                    l_296 = (((l_285 ^ (((((int32_t)(l_288 == l_288) + (int32_t)((+(((int16_t)((void*)0 == l_292) % (int16_t)p_46) | (5U ^ ((uint16_t)0x3957 >> (uint16_t)11)))) & p_46)) == (*l_197)) > 0xE8FB) | p_46)) >= l_295) && (*l_292));
                    for (l_285 = 0; (l_285 != 8); l_285 += 2)
                    { /* block id: 163 */
                        const uint32_t l_299 = 0xFDE01A91;
                        l_300 = l_299;
                        (**l_195) = &l_296;
                        /* statement id: 165 */
                        assert (l_117 == &l_296);
                    }
                    /* facts after for loop */
                    //assert (l_117 == &l_296 || l_117 == &l_277 || l_117 == dangling || l_117 == &l_118 || l_117 == 0);
                }
                (*l_320) = (0xF.75ACE0p-30 == (((float)(-0x1.7p-1) + (float)(p_46 <= l_303)) > (p_46 != ((float)((float)((float)((((float)(((((void*)0 == &l_277) != (-(float)((-(float)((float)(p_46 != ((float)p_46 - (float)p_46)) - (float)0x2.C83B8Cp-5)) >= p_46))) == 0x1.5p-1) < (-0x5.4p+1)) - (float)(*l_197)) != p_46) <= 0xC.BBC024p-76) + (float)l_318) + (float)0xA.7ADA85p+57) + (float)(-0x2.6p+1)))));
            }
            (*l_330) = (((float)((void*)0 != (*l_288)) - (float)(l_323 != l_326)) <= (((*l_189) == (p_46 > ((float)(0x0.Dp+1 != ((+p_46) < (((**l_225) != (void*)0) == p_46))) + (float)(*l_189)))) <= p_46));
        }
        /* facts after for loop */
        //assert (l_117 == dangling || l_117 == &l_118 || l_117 == 0);
        assert (l_154 == &l_195 || l_154 == &l_155);
        return p_46;
    }
    /* facts after branching */
    assert (l_117 == &l_118 || l_117 == 0);
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_48(int32_t * p_49, const uint32_t  p_50, uint32_t  p_51, uint32_t  p_52, int32_t ** p_53)
{ /* block id: 37 */
    int32_t *l_105 = (void*)0;
    int32_t l_108 = 6;
    int32_t **l_109 = &l_105;
    float l_111 = (-0x1.9p+1);
    float *l_110 = &l_111;
    int32_t **l_112 = &l_105;
    int32_t **l_113 = &l_105;
    int32_t **l_114 = &l_105;
    int32_t **l_115 = (void*)0;
    (*p_53) = l_105;
    /* statement id: 38 */
    //assert (l_54 == 0);
    (*l_110) = ((float)l_108 + (float)((void*)0 == l_109));
    (*l_109) = (*p_53);
    return l_115;
    /* statement id: 41 */
    //assert (func_48_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_57(int32_t ** p_58, int32_t * p_59, int32_t ** p_60, int32_t  p_61, int32_t * p_62)
{ /* block id: 32 */
    uint16_t l_102 = 0U;
    int32_t l_104 = 0x3094EEE5;
    int32_t *l_103 = &l_104;
    l_102 = 0x2.4714FEp-38;
    p_62 = l_103;
    /* statement id: 34 */
    assert (p_62 == &l_104);
    l_103 = (*p_58);
    /* statement id: 35 */
    //assert (l_103 == &l_55);
    return (*l_103);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_63(uint32_t  p_64, uint32_t  p_65, int32_t  p_66)
{ /* block id: 29 */
    int32_t l_98 = (-1);
    int32_t *l_97 = &l_98;
    int32_t **l_99 = &l_97;
    int32_t **l_100 = &l_97;
    int32_t **l_101 = (void*)0;
    (*l_97) = 0x0950C43C;
    return l_101;
    /* statement id: 31 */
    //assert (func_63_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_68(uint16_t  p_69, uint32_t  p_70)
{ /* block id: 18 */
    int32_t l_79 = 9;
    int32_t *l_78 = &l_79;
    uint16_t l_87 = 1U;
    float l_89 = 0x7.FE686Bp-3;
    float *l_88 = &l_89;
    (*l_88) = (p_70 >= ((float)0x0.3p+1 + (float)(((((float)(!(!(-(float)(0x8.9752EEp-15 >= (((l_78 != &l_79) < ((float)(0xF.CF8610p-29 < (((+((0x6.B036C8p+16 < (((((((((float)(-0x2.Ap-1) + (float)(((((((((float)(((void*)0 != &l_78) != p_70) - (float)(-0x9.Cp+1)) == (*l_78)) <= (*l_78)) >= p_69) >= p_69) != p_70) < (*l_78)) == p_69)) < (*l_78)) >= p_69) >= 0x7.6F84B8p-86) != 0x5.8A133Ap+35) > p_70) > 0x3.A2DD44p-21) != (-0x1.9p+1))) > p_70)) < 0x1.A47BFEp-4) > 0x0.Dp+1)) - (float)0x3.E384C8p-64)) > (*l_78)))))) + (float)(*l_78)) <= (*l_78)) != 0x0.8p+1) <= l_87)));
    if ((0x68172882 | p_70))
    { /* block id: 20 */
        const int32_t *l_92 = &l_79;
        const int32_t **l_91 = &l_92;
        const int32_t ***l_90 = &l_91;
        int32_t ****l_93 = (void*)0;
        int32_t ***l_95 = (void*)0;
        int32_t ****l_94 = &l_95;
        (*l_94) = l_90;
        /* statement id: 21 */
        assert (l_95 == &l_91);
        (*l_91) = &l_79;
        (**l_95) = &l_79;
        return p_70;
    }
    else
    { /* block id: 25 */
        int32_t **l_96 = &l_78;
        (*l_96) = &l_79;
    }
    return p_70;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 106
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 153
   depth: 2, occurrence: 28
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 30, occurrence: 1
   depth: 35, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 133

XXX times a variable address is taken: 123
XXX times a pointer is dereferenced on RHS: 80
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 13
   depth: 3, occurrence: 13
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 65
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 7
   depth: 3, occurrence: 12
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 364

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 136
   level: 2, occurrence: 54
   level: 3, occurrence: 63
   level: 4, occurrence: 30
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 69
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.3
XXX average alias set size: 1.13

XXX times a non-volatile is read: 567
XXX times a non-volatile is write: 197
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 131
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 22
   depth: 2, occurrence: 18
   depth: 3, occurrence: 13
   depth: 4, occurrence: 20
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 14.4
XXX percentage an existing variable is used: 85.6
********************* end of statistics **********************/

