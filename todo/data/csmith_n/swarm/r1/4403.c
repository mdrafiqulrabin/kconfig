/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3807309804
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 0x8A61928CL;
static int32_t g_36 = 0x1E124DC4L;
static volatile int32_t g_61 = 0x1CAF1E2CL;/* VOLATILE GLOBAL g_61 */
static volatile int32_t *g_60 = &g_61;
static uint16_t g_106 = 0x90C9L;
static volatile int32_t **g_118 = &g_60;
static volatile int32_t ***g_117 = &g_118;
static int32_t *g_136 = (void*)0;
static int32_t **g_135 = &g_136;
static uint32_t g_291 = 0x9593E8CAL;
static uint64_t g_292 = 1UL;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_26(void);
static int32_t * func_27(int32_t * p_28, int32_t  p_29);
inline static int32_t * func_30(uint64_t  p_31, int32_t  p_32, int32_t * p_33, int16_t  p_34);
static int32_t * func_37(int32_t  p_38, int16_t  p_39);
static int32_t  func_41(int32_t  p_42, int32_t * p_43);
inline static int32_t * func_45(int32_t * p_46);
static int32_t * func_47(int32_t * p_48);
inline static int32_t ** func_50(uint32_t  p_51, int32_t ** p_52, uint16_t  p_53, int32_t * p_54);
static uint32_t  func_57(int32_t  p_58, uint16_t  p_59);
inline static uint32_t  func_66(int32_t  p_67, uint32_t  p_68, int16_t  p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_36 g_61 g_106 g_135 g_117 g_118 g_136 g_60 g_291 g_292
 * writes: g_36 g_60 g_135 g_136 g_3 g_106 g_118 g_61
 */
static int32_t  func_26(void)
{ /* block id: 36 */
    int32_t *l_35 = &g_36;
    l_35 = func_27(func_30(g_3, g_3, l_35, (*l_35)), (~((int16_t)g_291 + (int16_t)g_291)));
    /* statement id: 211 */
    assert (g_60 == &g_61 || g_60 == 0);
    //assert (g_136 == 0 || g_136 == &g_36 || g_136 == dangling);
    return (*l_35);
}


/* ------------------------------------------ */
/* 
 * reads : g_292 g_106
 * writes: g_61
 */
static int32_t * func_27(int32_t * p_28, int32_t  p_29)
{ /* block id: 208 */
    uint32_t l_293 = 0x241E0B0FL;
    g_61 = (g_292 , (g_106 , l_293));
    return &g_36;
    /* statement id: 210 */
    //assert (func_27_rv == &g_36);
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_61 g_3 g_106 g_135 g_117 g_118 g_136 g_60
 * writes: g_36 g_60 g_135 g_136 g_3 g_106 g_118
 */
inline static int32_t * func_30(uint64_t  p_31, int32_t  p_32, int32_t * p_33, int16_t  p_34)
{ /* block id: 37 */
    uint32_t l_40 = 0xAB6DAD81L;
    int32_t *l_44 = &g_36;
    int32_t **l_284 = &l_44;
    (*l_284) = func_37(l_40, (((g_36 , p_31) && ((l_40 ^ (func_41(g_36, l_44) | (((((!g_3) , (*g_117)) == (void*)0) ^ 6L) & g_3))) == 0x18219F00L)) , g_3));
    /* statement id: 201 */
    assert (l_44 == 0 || l_44 == &g_36);
    assert (g_60 == &g_61 || g_60 == 0);
    //assert (g_136 == 0 || g_136 == &g_36 || g_136 == dangling);
    for (g_106 = 0; (g_106 == 51); g_106++)
    { /* block id: 204 */
        int32_t *l_287 = (void*)0;
        return l_287;
        /* statement id: 205 */
        //assert (func_30_rv == 0);
    }
    return &g_36;
    /* statement id: 207 */
    //assert (func_30_rv == &g_36);
}


/* ------------------------------------------ */
/* 
 * reads : g_117 g_118 g_36 g_3 g_106 g_135 g_136 g_60 g_61
 * writes: g_3 g_106 g_36 g_136 g_60 g_118
 */
static int32_t * func_37(int32_t  p_38, int16_t  p_39)
{ /* block id: 99 */
    int32_t l_152 = 8L;
    int32_t *l_153 = &l_152;
    int16_t l_175 = 0xC87CL;
    int32_t ***l_207 = &g_135;
    int32_t ****l_206 = &l_207;
    int32_t *l_280 = &l_152;
    int32_t *l_281 = &l_152;
    int32_t *l_282 = &l_152;
    int32_t *l_283 = &g_36;
    if (p_38)
    { /* block id: 100 */
        uint32_t l_145 = 0x3B377FB2L;
        int32_t ***l_160 = &g_135;
        uint32_t l_215 = 0x75D6FB8AL;
        int32_t *****l_216 = &l_206;
        int16_t l_218 = 0x6674L;
        int32_t *l_223 = &g_36;
        if (((uint32_t)(l_145 , ((((int16_t)((uint64_t)(p_38 ^ p_39) + (uint64_t)p_39) - (int16_t)((*g_117) != (void*)0)) <= (-(uint16_t)(!g_36))) != __builtin_popcountll(l_152))) - (uint32_t)4UL))
        { /* block id: 101 */
            int32_t l_177 = 9L;
lbl_169:
            l_153 = &l_152;
            for (p_38 = 3; (p_38 < 22); p_38++)
            { /* block id: 105 */
                uint32_t l_170 = 1UL;
                int32_t *l_176 = &l_152;
                for (g_3 = 0; (g_3 >= (-25)); g_3 -= 1)
                { /* block id: 108 */
                    int16_t l_162 = 0xC01DL;
                    int32_t l_163 = 0xC1B3EE27L;
                    uint64_t l_168 = 1UL;
                    for (g_106 = 21; (g_106 != 52); g_106++)
                    { /* block id: 111 */
                        int32_t ****l_161 = &l_160;
                        (*l_161) = (l_145 , l_160);
                        (*l_153) = func_66(p_39, ((((((func_66(__builtin_ffsll(l_162), l_163, g_36) >= ((uint16_t)((int64_t)(((p_38 == (-1L)) == 0xA6E12AA013F98BF1LL) , p_39) % (int64_t)g_106) + (uint16_t)0L)) > 0xDF05FF3C1E06D60ALL) , 9UL) & l_168) , (*g_135)) != (**g_117)), g_61);
                        (***l_161) = (*g_135);
                    }
                    if (l_145)
                        goto lbl_169;
                    (**g_117) = (**g_117);
                }
                (*l_153) = l_170;
                for (l_145 = (-25); (l_145 == 30); ++l_145)
                { /* block id: 122 */
                    int32_t *l_186 = &l_152;
                    l_175 = (g_3 || ((uint16_t)p_38 << (uint16_t)14));
                    (*g_135) = l_176;
                    /* statement id: 124 */
                    assert (g_136 == &l_152);
                    if (l_177)
                        continue;
                    (*g_136) = (l_177 >= (((int64_t)(*l_153) - (int64_t)(-1L)) && ((uint16_t)(((int16_t)0xA882L - (int16_t)((p_38 , ((((0xA27731F37730FBAALL ^ (p_39 , ((uint16_t)(((*l_153) | 0x233E6B62B2D3F7E2LL) & g_61) << (uint16_t)g_3))) > 0xDCE7L) , l_176) == l_186)) && 0UL)) <= (**g_135)) << (uint16_t)15)));
                }
            }
        }
        else
        { /* block id: 129 */
            return (**l_160);
            /* statement id: 130 */
            //assert (func_37_rv == 0 || func_37_rv == &g_36);
        }
        /* facts after branching */
        assert (g_136 == &l_152 || g_136 == 0 || g_136 == &g_36);
        (*l_153) = ((g_3 >= ((int16_t)(((((uint32_t)((((int16_t)(((((((int16_t)(__builtin_ffsll(((*g_117) != (func_57(p_38, p_39) , (*l_160)))) <= 0xACFB1E1FL) >> (int16_t)g_106) && 0xC376L) & 0x566EL) | 0x45DB4FB4L) | 65529UL) , 0x3482L) - (int16_t)1UL) & g_106) != 0x08CE353FEDF4294BLL) - (uint32_t)p_39) > g_106) >= g_3) , 0x0A78L) << (int16_t)p_39)) , p_38);
        /* statement id: 132 */
        assert (g_60 == 0);
        if (((__builtin_bswap64(g_3) & ((g_3 ^ (-6L)) == ((int64_t)g_106 + (int64_t)((g_3 | (((g_36 , p_39) <= p_38) , (*l_153))) || 4L)))) || (*l_153)))
        { /* block id: 133 */
            int32_t **l_217 = (void*)0;
            (*g_135) = &p_38;
            /* statement id: 134 */
            assert (g_136 == &p_38);
            for (p_38 = (-4); (p_38 != 3); p_38++)
            { /* block id: 137 */
                (*l_153) = __builtin_clzl(((uint32_t)g_36 % (uint32_t)p_38));
                for (l_145 = 0; (l_145 >= 60); ++l_145)
                { /* block id: 141 */
                    uint32_t l_205 = 4294967295UL;
                    int32_t *****l_208 = &l_206;
                    for (g_3 = 0; (g_3 != 29); ++g_3)
                    { /* block id: 144 */
                        (*l_153) = ((*l_153) == ((void*)0 == (**g_117)));
                    }
                    (*l_208) = (((p_38 > p_39) , l_205) , l_206);
                    if ((***l_160))
                        continue;
                    if (p_39)
                        continue;
                }
            }
            (**l_207) = &p_38;
            (*****l_216) = ((int16_t)(((((uint16_t)func_66(((int16_t)(((***l_160) , (*l_206)) == (void*)0) >> (int16_t)14), (*l_153), l_215) << (uint16_t)13) || g_36) , (((**l_206) != (((void*)0 != l_216) , l_217)) ^ l_218)) >= 0x56941D11L) << (int16_t)p_39);
        }
        else
        { /* block id: 154 */
            uint64_t l_221 = 0xA015E9F7B3F3958ALL;
            int32_t *l_222 = &l_152;
            for (l_218 = (-18); (l_218 >= 24); l_218 += 5)
            { /* block id: 157 */
                if (l_221)
                    break;
            }
            return l_223;
            /* statement id: 160 */
            //assert (g_136 == dangling || g_136 == 0 || g_136 == &g_36);
            //assert (func_37_rv == &g_36);
        }
        /* facts after branching */
        assert (g_136 == &p_38);
        l_206 = &l_207;
    }
    else
    { /* block id: 163 */
        int32_t *****l_244 = (void*)0;
        int32_t l_245 = 3L;
        uint32_t l_257 = 0x6C4033B0L;
        if (((int16_t)__builtin_popcountll(g_36) - (int16_t)((int16_t)((((~g_106) , g_106) && g_106) ^ 5UL) << (int16_t)11)))
        { /* block id: 164 */
            uint32_t l_253 = 4294967295UL;
            int32_t l_261 = 0xF85720E6L;
            uint16_t l_270 = 0xFC96L;
            (**l_207) = &p_38;
            /* statement id: 165 */
            assert (g_136 == &p_38);
            if (((uint16_t)((((int16_t)__builtin_ctzll(((uint16_t)((int16_t)(((uint32_t)g_36 - (uint32_t)(-(int64_t)(((((uint16_t)p_39 << (uint16_t)10) & g_61) , p_39) == g_106))) ^ ((uint16_t)g_36 >> (uint16_t)(l_244 != (void*)0))) >> (int16_t)g_3) << (uint16_t)g_3)) << (int16_t)l_245) >= g_3) , p_39) << (uint16_t)1))
            { /* block id: 166 */
                (**l_207) = (***l_206);
            }
            else
            { /* block id: 168 */
                int32_t **l_252 = &g_136;
                (**l_252) = (((int64_t)0x046C61679470CC65LL + (int64_t)(0L || __builtin_ctzll((g_36 != ((uint64_t)((uint64_t)(l_252 != (*g_117)) - (uint64_t)18446744073709551615UL) + (uint64_t)(((l_253 != (-1L)) , (void*)0) == (**g_117))))))) < (****l_206));
                for (l_175 = 0; (l_175 < 22); ++l_175)
                { /* block id: 172 */
                    int32_t *l_256 = &g_36;
                    l_256 = (*l_252);
                    /* statement id: 173 */
                    assert (l_256 == &p_38);
                    (***l_206) = func_47((*g_135));
                    /* statement id: 174 */
                    assert (g_136 == &g_36);
                    (*g_135) = (l_257 , &p_38);
                    /* statement id: 175 */
                    assert (g_136 == &p_38);
                    l_261 = ((((p_39 , (((uint16_t)(5L ^ g_106) >> (uint16_t)(~(*l_153))) , (*l_252))) != (*l_252)) & p_38) , (**g_135));
                }
                (**l_252) = ((((p_39 , func_50(((((g_106 > g_3) != __builtin_ia32_crc32qi(g_36, g_3)) , ((((((((uint16_t)(((uint64_t)((uint16_t)(0x138EL & (**l_252)) << (uint16_t)12) + (uint64_t)g_36) >= 0L) >> (uint16_t)1) ^ (***l_207)) ^ p_39) != 18446744073709551610UL) && p_38) , g_36) ^ 0x5A16B7DE68C300E8LL)) == (**l_252)), l_252, (*l_153), (**l_207))) == (void*)0) , l_261) & (****l_206));
                /* statement id: 178 */
                assert (g_60 == 0);
            }
            (*g_136) = (((l_261 & l_253) | l_270) <= p_38);
            for (l_152 = (-16); (l_152 >= 10); l_152 += 3)
            { /* block id: 183 */
                (**g_135) = p_39;
                (****l_206) = (*g_136);
                (*g_136) = l_270;
            }
        }
        else
        { /* block id: 188 */
            volatile int32_t ****l_274 = (void*)0;
            volatile int32_t *****l_273 = &l_274;
            (*g_117) = (*g_117);
            (*l_273) = &g_117;
            /* statement id: 190 */
            assert (l_274 == &g_117);
        }
        /* facts after branching */
        assert (g_136 == 0 || g_136 == &g_36 || g_136 == &p_38);
        (*l_153) = ((((((int16_t)g_36 >> (int16_t)4) ^ l_245) , p_38) > p_38) , ((__builtin_bswap32(g_61) , &g_117) != &l_207));
        for (p_38 = 0; (p_38 == 25); p_38 += 7)
        { /* block id: 195 */
            int32_t *l_279 = &g_36;
            return l_279;
            /* statement id: 196 */
            //assert (g_136 == 0 || g_136 == &g_36 || g_136 == dangling);
            //assert (func_37_rv == &g_36);
        }
    }
    /* facts after branching */
    assert (g_136 == 0 || g_136 == &g_36 || g_136 == &p_38);
    (*l_153) = ((void*)0 == &g_118);
    return l_283;
    /* statement id: 200 */
    //assert (g_136 == 0 || g_136 == &g_36 || g_136 == dangling);
    //assert (func_37_rv == &g_36);
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_61 g_3 g_106 g_135 g_117 g_118 g_136
 * writes: g_36 g_60 g_135 g_136
 */
static int32_t  func_41(int32_t  p_42, int32_t * p_43)
{ /* block id: 38 */
    int32_t *l_141 = &g_36;
    p_43 = func_45(func_47(&g_36));
    /* statement id: 96 */
    assert (g_60 == 0);
    (*g_135) = l_141;
    /* statement id: 97 */
    assert (g_136 == &g_36);
    return (*g_136);
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_61 g_3 g_106 g_135 g_117 g_118
 * writes: g_36 g_60 g_135
 */
inline static int32_t * func_45(int32_t * p_46)
{ /* block id: 41 */
    int16_t l_133 = 0x37E5L;
    int32_t l_134 = 0xD41FC1B3L;
    int32_t ***l_138 = (void*)0;
    int32_t ***l_139 = &g_135;
    int32_t ****l_140 = &l_139;
    (*p_46) = (&g_36 != p_46);
    (*l_139) = func_50(((int16_t)((func_57((*p_46), g_36) , 0xBAD4L) != ((6L <= ((((__builtin_ctzl(((~(((int16_t)__builtin_clzl(((__builtin_popcount(l_133) < (2L && l_133)) <= l_133)) >> (int16_t)l_133) || g_106)) <= g_3)) ^ l_133) && g_106) && l_133) < 65532UL)) , l_134)) << (int16_t)15), g_135, l_133, p_46);
    /* statement id: 93 */
    assert (g_60 == 0);
    (*l_140) = l_138;
    /* statement id: 94 */
    assert (l_139 == 0);
    return p_46;
    /* statement id: 95 */
    //assert (func_45_rv == &g_36);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_47(int32_t * p_48)
{ /* block id: 39 */
    int32_t *l_49 = &g_36;
    return l_49;
    /* statement id: 40 */
    //assert (func_47_rv == &g_36);
}


/* ------------------------------------------ */
/* 
 * reads : g_117 g_118
 * writes: g_60
 */
inline static int32_t ** func_50(uint32_t  p_51, int32_t ** p_52, uint16_t  p_53, int32_t * p_54)
{ /* block id: 90 */
    int32_t **l_137 = &g_136;
    (**g_117) = (void*)0;
    /* statement id: 91 */
    assert (g_60 == 0);
    return l_137;
    /* statement id: 92 */
    //assert (func_50_rv == &g_136);
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_61 g_3 g_106
 * writes: g_60 g_36
 */
static uint32_t  func_57(int32_t  p_58, uint16_t  p_59)
{ /* block id: 43 */
    int32_t *l_62 = &g_36;
    int16_t l_107 = 0x2093L;
lbl_65:
    g_60 = (void*)0;
    /* statement id: 44 */
    assert (g_60 == 0);
    if ((l_62 == (void*)0))
    { /* block id: 45 */
        for (p_59 = 4; (p_59 < 44); p_59 += 6)
        { /* block id: 48 */
            if (p_59)
                goto lbl_65;
        }
    }
    else
    { /* block id: 51 */
        int64_t l_70 = 0x7D8EB7BFBC35CF45LL;
        int32_t *l_86 = &g_36;
        int16_t l_122 = (-1L);
        (*l_62) = (*l_62);
        if ((func_66(l_70, ((uint64_t)l_70 % (uint64_t)g_61), (*l_62)) , (p_58 > 0x95A4792DL)))
        { /* block id: 57 */
            (*l_86) = (l_86 != &p_58);
        }
        else
        { /* block id: 59 */
            int32_t **l_87 = &l_62;
            int32_t l_119 = 0x187EA63FL;
            int64_t l_125 = (-1L);
            (*l_87) = &g_36;
            for (g_36 = 4; (g_36 != 11); g_36 += 7)
            { /* block id: 63 */
                int32_t ***l_90 = &l_87;
                int32_t *l_95 = &g_36;
                uint32_t l_103 = 1UL;
                (*l_90) = l_87;
            }
            (*l_86) = ((int64_t)(**l_87) % (int64_t)l_125);
            if (__builtin_ctz(__builtin_ctzl(g_106)))
            { /* block id: 80 */
                return g_36;
            }
            else
            { /* block id: 82 */
                return g_106;
            }
        }
    }
    (*l_62) = (*l_62);
    (*l_62) = ((*l_62) , ((p_59 > func_66(((uint64_t)((((((((*l_62) ^ p_58) | ((int16_t)(p_58 && 0x8AE5L) % (int16_t)(*l_62))) , ((p_59 , (*l_62)) > 1UL)) == 0x926F2DC1L) > p_59) , 0L) , p_58) + (uint64_t)g_36), (*l_62), g_61)) <= g_106));
    return (*l_62);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_36
 * writes: g_36
 */
inline static uint32_t  func_66(int32_t  p_67, uint32_t  p_68, int16_t  p_69)
{ /* block id: 53 */
    int16_t l_81 = (-1L);
    int32_t l_82 = 0xD48A24E2L;
    int32_t *l_85 = &g_36;
    l_82 = ((int64_t)(((int16_t)((int32_t)((int16_t)((void*)0 == &g_60) - (int16_t)((l_81 | ((void*)0 != &p_67)) || p_68)) % (int32_t)g_3) >> (int16_t)p_68) == 0x9B2BL) % (int64_t)(-3L));
    (*l_85) = (((uint64_t)5UL - (uint64_t)p_68) != l_81);
    return (*l_85);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_36, "g_36", print_hash_value);
    transparent_crc(g_61, "g_61", print_hash_value);
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc(g_291, "g_291", print_hash_value);
    transparent_crc(g_292, "g_292", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 71
XXX total union variables: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 22
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 56

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 60
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 45
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 9
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 260

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 119
   level: 2, occurrence: 49
   level: 3, occurrence: 30
   level: 4, occurrence: 4
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 23
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25
XXX average alias set size: 1.23

XXX times a non-volatile is read: 372
XXX times a non-volatile is write: 133
XXX times a volatile is read: 9
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 96
XXX percentage of non-volatile access: 98.1

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 11
   depth: 2, occurrence: 22
   depth: 3, occurrence: 16
   depth: 4, occurrence: 15
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 16
XXX percentage an existing variable is used: 84
********************* end of statistics **********************/

