/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      4251551234
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_25 = 0xE780CA9F;
static float * volatile g_40 = (void*)0;/* VOLATILE GLOBAL g_40 */
static float g_42 = 0xA.D03B15p-31;
static float * volatile *g_46 = (void*)0;
static float * volatile ** volatile g_45 = &g_46;/* VOLATILE GLOBAL g_45 */
static float g_89 = 0x0.8p+1;
static int32_t g_107 = 0x6E024B17;
static int32_t *g_108 = &g_107;
static int32_t g_117 = 0x0CD53B18;
static int32_t ** volatile g_134 = &g_108;/* VOLATILE GLOBAL g_134 */
static int32_t ** volatile g_136 = &g_108;/* VOLATILE GLOBAL g_136 */
static const int32_t **g_174 = (void*)0;
static const int32_t *** volatile g_173 = &g_174;/* VOLATILE GLOBAL g_173 */
static float *g_176 = (void*)0;
static float **g_175 = &g_176;
static int32_t * volatile g_184 = &g_107;/* VOLATILE GLOBAL g_184 */
static volatile int32_t g_221 = 0x477A9A3A;/* VOLATILE GLOBAL g_221 */
static int32_t ** volatile g_234 = &g_108;/* VOLATILE GLOBAL g_234 */
static int32_t * volatile g_270 = (void*)0;/* VOLATILE GLOBAL g_270 */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_30(void);
inline static const int32_t  func_32(uint32_t  p_33, int32_t * p_34);
static float  func_52(uint32_t  p_53, float ** p_54);
inline static uint32_t  func_58(float * p_59, int32_t  p_60, uint32_t  p_61);
inline static float * func_62(uint32_t  p_63, float * p_64);
static int32_t * func_69(int32_t * p_70, uint32_t  p_71, float ** p_72, uint32_t  p_73, float * p_74);
static float ** func_76(uint32_t  p_77, int32_t  p_78);
static uint16_t  func_90(int32_t * p_91, int32_t * p_92, const float  p_93, float  p_94, float  p_95);
static int32_t * func_96(int16_t  p_97, float * p_98, const float * p_99);
inline static const uint32_t  func_103(uint32_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_25 g_45 g_107 g_234 g_175 g_176 g_117 g_136 g_108
 * writes: g_25 g_42 g_46 g_108 g_89 g_117
 */
inline static uint16_t  func_30(void)
{ /* block id: 36 */
    int32_t *l_31 = &g_25;
    uint32_t l_246 = 1U;
    uint32_t l_257 = 1U;
    int32_t *l_271 = (void*)0;
    int32_t *l_272 = &g_117;
    (*l_31) = 0x631E19E9;
    if (func_32((g_25 ^ (*l_31)), l_31))
    { /* block id: 158 */
        (*g_234) = l_31;
        /* statement id: 159 */
        assert (g_108 == &g_25);
    }
    else
    { /* block id: 160 */
        float *l_237 = (void*)0;
        int32_t *l_252 = (void*)0;
        uint16_t l_268 = 65535U;
        int32_t l_269 = 0;
        if (((int16_t)(l_237 != (*g_175)) >> (int16_t)g_25))
        { /* block id: 161 */
            float *l_251 = &g_89;
            int32_t l_261 = 9;
            for (g_25 = 0; (g_25 > 20); g_25++)
            { /* block id: 164 */
                uint32_t l_240 = 0xEC1F001D;
                l_252 = func_62(((0xECA2 > l_240) ^ (+g_107)), func_62(((int16_t)((uint32_t)(g_107 && l_246) % (uint32_t)((int16_t)((((uint16_t)g_117 / (uint16_t)(-1)) || 65535U) == ((void*)0 == (*g_175))) >> (int16_t)g_25)) / (int16_t)0x40BD), l_251));
                /* statement id: 165 */
                assert (l_252 == &g_42);
            }
            /* facts after for loop */
            assert (l_252 == &g_42 || l_252 == 0);
            (*l_251) = (((float)((float)(*l_31) - (float)(*l_31)) + (float)l_257) > ((void*)0 != (*g_175)));
            for (l_246 = 5; (l_246 <= 38); l_246 += 1)
            { /* block id: 170 */
                int32_t **l_260 = &g_108;
                (*l_260) = (*g_136);
                (*l_260) = (void*)0;
                /* statement id: 172 */
                assert (g_108 == 0);
                if (l_261)
                    break;
            }
            /* facts after for loop */
            assert (g_108 == 0 || g_108 == &g_107);
            if (__builtin_popcountl(g_25))
            { /* block id: 175 */
                return (*l_31);
            }
            else
            { /* block id: 177 */
                float l_262 = 0x5.FD6D6Ap+36;
                const int32_t l_263 = 0x4344C071;
                l_31 = &l_261;
                /* statement id: 178 */
                assert (l_31 == &l_261);
                (*l_31) = l_263;
            }
            /* facts after branching */
            assert (l_31 == &l_261);
        }
        else
        { /* block id: 181 */
            float ***l_264 = (void*)0;
            float ****l_265 = &l_264;
            (*l_265) = l_264;
        }
        /* facts after branching */
        //assert (l_31 == &g_25 || l_31 == dangling);
        assert (g_108 == 0 || g_108 == &g_107);
        assert (l_252 == &g_42 || l_252 == 0);
        l_269 = ((float)g_25 / (float)l_268);
    }
    /* facts after branching */
    //assert (l_31 == &g_25 || l_31 == dangling);
    assert (g_46 == &g_40 || g_46 == 0);
    assert (g_108 == 0 || g_108 == &g_107 || g_108 == &g_25);
    (*l_272) = ((void*)0 == &g_136);
    return (*l_272);
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_45 g_107
 * writes: g_25 g_42 g_46
 */
inline static const int32_t  func_32(uint32_t  p_33, int32_t * p_34)
{ /* block id: 38 */
    uint32_t l_39 = 0xC3D21462;
    int32_t *l_194 = &g_107;
    float ***l_202 = (void*)0;
    float ****l_201 = &l_202;
    uint32_t l_226 = 0x3D5CCC3D;
    (*p_34) = 0x21CD4309;
    for (g_25 = 2; (g_25 == (-14)); g_25 -= 1)
    { /* block id: 42 */
        float *l_41 = &g_42;
        (*l_41) = __builtin_parity(((int16_t)p_33 >> (int16_t)__builtin_popcountl(l_39)));
    }
    for (l_39 = 0; (l_39 > 49); l_39 += 2)
    { /* block id: 47 */
        int32_t l_47 = 0x78E60D74;
        float *l_232 = &g_42;
        int32_t *l_233 = (void*)0;
        (*g_45) = &g_40;
        /* statement id: 48 */
        assert (g_46 == &g_40);
    }
    /* facts after for loop */
    assert (g_46 == &g_40 || g_46 == 0);
    return (*l_194);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_46 g_25 g_107 g_108 g_89 g_134 g_117 g_136 g_173 g_175 g_176 g_42 g_184
 * writes: g_25 g_42 g_107 g_108 g_117 g_89 g_174
 */
static float  func_52(uint32_t  p_53, float ** p_54)
{ /* block id: 53 */
    float l_65 = 0xF.CF9E8Bp+58;
    int32_t l_66 = (-4);
    float **l_68 = (void*)0;
    uint32_t l_187 = 0x3DA0ACF1;
    g_25 = 0x0284818A;
    if ((func_58(func_62(l_66, (*p_54)), ((l_68 == (*g_45)) != p_53), (__builtin_parityl(p_53) || 1U)) && p_53))
    { /* block id: 123 */
        (*g_184) = p_53;
    }
    else
    { /* block id: 125 */
        int32_t *l_185 = &g_117;
        int32_t **l_186 = &g_108;
        (*l_186) = l_185;
        /* statement id: 126 */
        assert (g_108 == &g_117);
    }
    /* facts after branching */
    assert (g_108 == &g_117 || g_108 == 0 || g_108 == &g_42);
    return l_187;
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_45 g_46 g_107 g_108 g_89 g_134 g_117 g_136 g_173 g_175 g_176 g_42
 * writes: g_42 g_107 g_108 g_117 g_89 g_174
 */
inline static uint32_t  func_58(float * p_59, int32_t  p_60, uint32_t  p_61)
{ /* block id: 58 */
    uint16_t l_75 = 7U;
    float **l_79 = (void*)0;
    int32_t **l_179 = &g_108;
    (*l_179) = func_69(func_62(l_75, p_59), g_25, func_76(((void*)0 != l_79), (((l_79 != (*g_45)) && ((p_59 == (void*)0) > p_61)) | g_25)), g_25, (*g_175));
    /* statement id: 120 */
    assert (g_108 == 0 || g_108 == &g_42);
    (*p_59) = ((float)(((float)(*p_59) + (float)(*p_59)) != l_75) - (float)(&l_79 != &l_79));
    return g_25;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_42 g_89
 */
inline static float * func_62(uint32_t  p_63, float * p_64)
{ /* block id: 55 */
    float *l_67 = &g_42;
    (*p_64) = __builtin_ctz(p_63);
    return l_67;
    /* statement id: 57 */
    //assert (func_62_rv == &g_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int32_t * p_70, uint32_t  p_71, float ** p_72, uint32_t  p_73, float * p_74)
{ /* block id: 113 */
    for (p_73 = (-11); (p_73 < 16); p_73 += 1)
    { /* block id: 116 */
        return p_74;
        /* statement id: 117 */
        //assert (func_69_rv == 0 || func_69_rv == &g_42);
    }
    return p_70;
    /* statement id: 119 */
    //assert (func_69_rv == &g_42 || func_69_rv == &g_25);
}


/* ------------------------------------------ */
/* 
 * reads : g_25 g_107 g_108 g_89 g_134 g_117 g_136 g_45 g_46 g_173 g_175
 * writes: g_107 g_108 g_117 g_89 g_174
 */
static float ** func_76(uint32_t  p_77, int32_t  p_78)
{ /* block id: 59 */
    uint16_t l_84 = 0x29BF;
    float *l_88 = &g_89;
    float **l_87 = &l_88;
    float ***l_86 = &l_87;
    int32_t l_159 = 0x0924423C;
    const int32_t **l_172 = (void*)0;
    if (((uint16_t)((uint16_t)(((l_84 > 1U) < (l_84 || 0x0040)) < (~(l_86 != (void*)0))) / (uint16_t)func_90(func_96(((int16_t)l_84 + (int16_t)(!func_103(l_84))), (**l_86), (*l_87)), l_88, p_77, p_77, l_84)) - (uint16_t)0x7C8A))
    { /* block id: 83 */
        float ***l_125 = &l_87;
        int32_t l_130 = 0x27B92311;
        for (g_107 = 0; (g_107 == 13); g_107 += 1)
        { /* block id: 86 */
            uint16_t l_133 = 65528U;
            (***l_86) = (((((float)((float)p_78 / (float)(l_125 != (void*)0)) / (float)(((0x0.Ep+1 <= p_77) == __builtin_popcountll(g_25)) >= g_89)) < (p_78 != 0x4.C8BEBEp-74)) != l_84) != (-0x4.Cp+1));
            (***l_125) = ((float)((float)(l_130 < ((float)(l_84 != ((-0x1.Cp-1) >= l_84)) - (float)p_77)) - (float)l_133) + (float)((l_84 == l_84) != p_78));
        }
    }
    else
    { /* block id: 90 */
        int16_t l_135 = 0xCC8E;
        int32_t l_149 = 2;
        (*g_134) = l_88;
        /* statement id: 91 */
        assert (g_108 == &g_89);
        (*g_108) = l_135;
        (*g_136) = func_96((((g_117 && p_77) | 0x4CEB) ^ p_77), (*l_87), (**l_86));
        /* statement id: 93 */
        assert (g_108 == &g_117);
        if (((int16_t)(9 == (((int32_t)(p_78 | (((int16_t)l_84 << (int16_t)8) | func_103(g_107))) - (int32_t)((&g_46 == (void*)0) >= (**g_134))) == (*g_108))) - (int16_t)0U))
        { /* block id: 94 */
            float **l_143 = (void*)0;
            int32_t l_144 = (-1);
            l_144 = ((*g_45) == l_143);
            (**l_87) = (((float)((&l_87 != &g_46) < (0x0.Ap-1 <= ((float)(&l_144 == (void*)0) + (float)l_144))) / (float)l_149) < p_78);
            (*g_108) = (+(l_84 <= (((void*)0 != (*g_136)) ^ ((uint16_t)0xFF4A + (uint16_t)((int32_t)(((int32_t)p_77 / (int32_t)func_103((l_84 && func_103(g_117)))) == 0x48FAEAFA) / (int32_t)0x1C728F08)))));
        }
        else
        { /* block id: 98 */
            int32_t l_160 = 0x86B2CC90;
            for (l_84 = 0; (l_84 >= 35); l_84 += 1)
            { /* block id: 101 */
                (*g_108) = l_159;
                l_160 = p_78;
                if (l_135)
                    goto lbl_161;
            }
            (*g_108) = (**g_134);
lbl_161:
            (*g_108) = (&l_159 != (void*)0);
            l_159 = (l_149 < ((float)((float)((float)p_78 + (float)((float)((float)(p_77 < l_135) / (float)(-0x1.2p+1)) / (float)(-0x1.4p-1))) / (float)p_77) + (float)0xE.F56540p-15));
        }
    }
    /* facts after branching */
    assert (g_108 == &g_117 || g_108 == &g_107);
    (*g_173) = l_172;
    return g_175;
    /* statement id: 112 */
    //assert (func_76_rv == &g_176);
}


/* ------------------------------------------ */
/* 
 * reads : g_108 g_107 g_25
 * writes: g_89 g_107
 */
static uint16_t  func_90(int32_t * p_91, int32_t * p_92, const float  p_93, float  p_94, float  p_95)
{ /* block id: 79 */
    (*p_92) = (*g_108);
    (*g_108) = 2;
    return g_25;
}


/* ------------------------------------------ */
/* 
 * reads : g_107 g_108
 * writes: g_108 g_107 g_117
 */
static int32_t * func_96(int16_t  p_97, float * p_98, const float * p_99)
{ /* block id: 63 */
    int16_t l_118 = 0;
lbl_111:
    g_108 = &g_107;
    /* statement id: 64 */
    assert (g_108 == &g_107);
    for (p_97 = (-5); (p_97 >= 28); p_97 += 2)
    { /* block id: 67 */
        const int32_t *l_113 = &g_25;
        const int32_t **l_112 = &l_113;
        if (p_97)
            goto lbl_111;
        (*l_112) = p_99;
        /* statement id: 69 */
        assert (l_113 == &g_89);
        for (g_107 = 0; (g_107 >= (-4)); g_107 -= 1)
        { /* block id: 72 */
            int32_t *l_116 = &g_117;
            (*l_116) = (*g_108);
        }
        (*l_112) = &g_25;
        /* statement id: 75 */
        assert (l_113 == &g_25);
    }
    (*g_108) = l_118;
    return &g_117;
    /* statement id: 78 */
    //assert (func_96_rv == &g_117);
}


/* ------------------------------------------ */
/* 
 * reads : g_25
 * writes: g_107
 */
inline static const uint32_t  func_103(uint32_t  p_104)
{ /* block id: 60 */
    int32_t *l_106 = &g_107;
    (*l_106) = (~g_25);
    return p_104;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_25, "g_25", print_hash_value);
    transparent_crc_bytes (&g_42, sizeof(g_42), "g_42", print_hash_value);
    transparent_crc_bytes (&g_89, sizeof(g_89), "g_89", print_hash_value);
    transparent_crc(g_107, "g_107", print_hash_value);
    transparent_crc(g_117, "g_117", print_hash_value);
    transparent_crc(g_221, "g_221", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 58
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 18
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1

XXX total number of pointers: 66

XXX times a variable address is taken: 51
XXX times a pointer is dereferenced on RHS: 37
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 4
XXX times a pointer is dereferenced on LHS: 45
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 172

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 132
   level: 2, occurrence: 37
   level: 3, occurrence: 12
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.8
XXX average alias set size: 1.29

XXX times a non-volatile is read: 252
XXX times a non-volatile is write: 111
XXX times a volatile is read: 11
XXX    times read thru a pointer: 0
XXX times a volatile is write: 7
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 85
XXX percentage of non-volatile access: 95.3

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 72
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 17
   depth: 2, occurrence: 15
   depth: 3, occurrence: 10

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
********************* end of statistics **********************/

