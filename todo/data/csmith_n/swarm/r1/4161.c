/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1692188708
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
};

struct S1 {
   signed f0 : 13;
   const uint16_t  f1;
   struct S0  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
static int32_t * func_32(int32_t * const  p_33, int32_t  p_34);
static struct S1  func_35(int32_t * p_36, int32_t  p_37);
static uint16_t  func_40(struct S0  p_41);
static uint8_t  func_47(int32_t * p_48, uint16_t  p_49, int32_t  p_50);
static int32_t * func_51(struct S0  p_52, const int32_t * p_53, uint32_t  p_54);
static struct S0  func_55(int32_t  p_56);
static int16_t  func_67(int32_t * p_68);
static int32_t * func_70(uint32_t  p_71, uint16_t  p_72, int32_t * p_73, uint32_t  p_74, const int32_t * p_75);
static int32_t * func_81(const int32_t  p_82, int32_t  p_83, uint16_t  p_84, uint32_t  p_85, uint32_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_39 = (-1L);
    int32_t *l_38 = &l_39;
    struct S0 l_42 = {-1L};
    struct S1 l_791 = {27,1UL,{1L}};
    int16_t *l_792 = (void*)0;
    uint16_t l_793 = 0x28C9L;
    uint8_t l_795 = 251UL;
    uint8_t *l_794 = &l_795;
    int32_t **l_796 = (void*)0;
    int32_t *l_798 = &l_39;
    int32_t **l_797 = &l_798;
    int16_t l_813 = (-1L);
    int32_t **l_821 = (void*)0;
    struct S0 l_833 = {1L};
    const int32_t *l_839 = (void*)0;
    const int32_t **l_838 = &l_839;
    (*l_797) = func_32(((*l_797) = (l_38 = (func_35(l_38, (func_40(l_42) | ((*l_38) , (*l_38)))) , (((*l_794) = (func_47(func_81((((*l_38) = (l_791 , (*l_38))) || ((*l_38) = (*l_38))), l_791.f2.f0, l_793, l_791.f1, l_791.f1), l_793, l_791.f1) && (*l_38))) , (void*)0)))), l_791.f0);
    for (l_793 = 0; (l_793 > 19); l_793 += 7)
    { /* block id: 540 */
        int32_t l_811 = 2L;
        uint32_t l_815 = 4294967295UL;
        uint32_t *l_814 = &l_815;
        int32_t ***l_816 = (void*)0;
        const int32_t l_825 = 0x64843835L;
        const int32_t *l_824 = &l_825;
        const int32_t **l_823 = &l_824;
        const int32_t ***l_822 = &l_823;
        int32_t **l_826 = (void*)0;
        int32_t ***l_827 = &l_826;
        uint32_t l_830 = 0x97600A12L;
        struct S0 l_831 = {0xD1DA1815L};
        uint16_t l_851 = 0UL;
        int32_t l_865 = 0xC7B048EAL;
        if ((l_42.f0 = (__builtin_clzll(((((((l_811 == (-(int16_t)l_813)) , 4294967295UL) >= ((*l_814) = l_811)) , l_816) == (void*)0) < ((((uint16_t)__builtin_ia32_crc32qi(((uint16_t)(((((*l_822) = l_821) != ((*l_827) = l_826)) , ((uint16_t)1UL / (uint16_t)l_825)) & l_811) << (uint16_t)5), l_825) << (uint16_t)l_811) > l_830) & l_825))) <= l_830)))
        { /* block id: 545 */
            struct S0 *l_832 = (void*)0;
            int32_t *l_837 = &l_811;
            int32_t **l_836 = &l_837;
            int16_t *l_840 = &l_813;
            const int16_t * const l_841 = (void*)0;
            int32_t l_842 = 0x951A9C63L;
            uint16_t l_844 = 0x5ED0L;
            uint16_t *l_843 = &l_844;
            l_833 = (l_831 = l_831);
            if (((uint16_t)((*l_843) = ((l_831.f0 | (l_815 , (((l_836 == ((*l_822) = l_838)) | ((-1L) || ((l_840 = l_840) == (l_831 , l_841)))) >= l_842))) == l_842)) << (uint16_t)1))
            { /* block id: 551 */
                struct S0 *l_849 = &l_791.f2;
                int32_t l_850 = 0x4E82E3EFL;
                (*l_849) = func_55((l_831.f0 = ((int16_t)__builtin_ffsl((l_842 , l_811)) >> (int16_t)((int16_t)l_844 >> (int16_t)15))));
                l_851 = (l_850 >= 0x39B39D6DL);
            }
            else
            { /* block id: 555 */
                int32_t l_852 = 0x5ADDF612L;
                return l_852;
            }
        }
        else
        { /* block id: 558 */
            struct S0 l_855 = {-1L};
            struct S0 l_860 = {0L};
            int32_t l_862 = 0xE6A9D74EL;
            int32_t *l_866 = (void*)0;
            int32_t *l_867 = &l_855.f0;
            for (l_813 = 0; (l_813 == (-19)); --l_813)
            { /* block id: 561 */
                struct S0 *l_856 = (void*)0;
                int32_t l_861 = 0x59640320L;
                l_42 = l_855;
                l_861 = (((!((int32_t)(func_40(l_860) , (-9L)) % (int32_t)l_861)) != ((l_862 , 1UL) <= l_862)) != (((int16_t)(l_860.f0 <= (l_825 >= l_860.f0)) - (int16_t)l_861) ^ 0x6CC2L));
            }
            if (l_851)
                continue;
            l_831.f0 = ((*l_867) = (l_865 = l_831.f0));
        }
        if (l_851)
            break;
    }
    return l_791.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_32(int32_t * const  p_33, int32_t  p_34)
{ /* block id: 533 */
    uint32_t *l_800 = (void*)0;
    uint32_t **l_799 = &l_800;
    uint32_t l_804 = 1UL;
    const uint32_t *l_803 = &l_804;
    const uint32_t **l_802 = &l_803;
    const uint32_t ***l_801 = &l_802;
    uint16_t l_808 = 0xD31AL;
    uint16_t *l_807 = &l_808;
    uint16_t ** const l_806 = &l_807;
    uint16_t ** const *l_805 = &l_806;
    (*l_801) = l_799;
    l_805 = l_805;
    return l_800;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_35(int32_t * p_36, int32_t  p_37)
{ /* block id: 526 */
    struct S1 l_790 = {-16,65535UL,{-3L}};
    return l_790;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_40(struct S0  p_41)
{ /* block id: 37 */
    int32_t *l_44 = (void*)0;
    int32_t l_58 = 3L;
    int32_t *l_57 = &l_58;
    int32_t l_623 = (-1L);
    int16_t l_719 = (-1L);
    int16_t *l_718 = &l_719;
    int32_t *l_720 = &l_623;
    uint32_t l_733 = 4UL;
    uint32_t *l_732 = &l_733;
    uint32_t * const * const l_731 = &l_732;
    uint16_t l_747 = 0x194EL;
    int32_t l_748 = 1L;
    struct S0 l_752 = {0x35CCD274L};
    struct S0 *l_751 = &l_752;
    struct S0 **l_750 = &l_751;
    struct S0 ***l_749 = &l_750;
    struct S1 l_777 = {-47,0xCB3BL,{1L}};
    struct S1 *l_776 = &l_777;
    (*l_720) = ((!((((void*)0 != l_44) <= (p_41.f0 , __builtin_bswap64(((int16_t)((*l_718) = (p_41.f0 , (0x9687FD07L != (func_47(func_51(func_55(((*l_57) = (-6L))), l_44, func_67(l_44)), p_41.f0, l_623) , l_623)))) + (int16_t)l_623)))) <= p_41.f0)) >= p_41.f0);
    if ((*l_720))
    { /* block id: 460 */
        int32_t *l_738 = (void*)0;
        int32_t l_744 = (-8L);
        uint16_t l_754 = 4UL;
        uint16_t *l_753 = &l_754;
        uint16_t l_756 = 65535UL;
        uint16_t *l_755 = &l_756;
        if (((*l_720) = p_41.f0))
        { /* block id: 462 */
            uint32_t l_725 = 0x120BF921L;
            struct S0 l_727 = {0x2A8F651CL};
            struct S0 *l_726 = &l_727;
            struct S0 **l_728 = &l_726;
            (*l_728) = (((uint16_t)((uint32_t)p_41.f0 / (uint32_t)l_725) + (uint16_t)(0xBBC7A37EL >= (*l_720))) , l_726);
            (*l_720) = ((int32_t)(((((void*)0 == l_731) <= (p_41.f0 <= 0x8C1CL)) || (p_41.f0 | p_41.f0)) <= ((p_41.f0 & __builtin_ffsl(p_41.f0)) ^ 0x6C2EC222L)) + (int32_t)p_41.f0);
            if (p_41.f0)
                goto lbl_746;
        }
        else
        { /* block id: 465 */
            uint8_t l_734 = 247UL;
            struct S0 l_735 = {-1L};
            l_735 = func_55(l_734);
        }
lbl_746:
        for (l_58 = (-13); (l_58 <= (-1)); l_58 += 3)
        { /* block id: 470 */
            int32_t *l_741 = &l_623;
            uint32_t l_743 = 0x8A1C189AL;
            uint32_t *l_742 = &l_743;
            uint32_t **l_745 = &l_732;
            l_744 = func_47((l_720 = l_738), ((-(int16_t)((((*l_741) = (-(uint16_t)(__builtin_ffs(p_41.f0) & 0x0576B422L))) < ((*l_742) = p_41.f0)) | p_41.f0)) , 0x94C0L), p_41.f0);
            l_745 = l_745;
        }
        l_744 = (func_47(&l_623, (l_747 ^ ((((*l_755) = ((*l_753) = (p_41.f0 != ((l_748 && 0x1C30060BL) && ((void*)0 == l_749))))) | p_41.f0) < p_41.f0)), p_41.f0) , 0xE5830D69L);
    }
    else
    { /* block id: 481 */
        uint32_t l_760 = 0xF85BBE8EL;
        uint32_t *l_759 = &l_760;
        if ((((((*l_759) = p_41.f0) >= (*l_720)) <= (*l_720)) <= 0UL))
        { /* block id: 483 */
            p_41.f0 = p_41.f0;
        }
        else
        { /* block id: 485 */
            return p_41.f0;
        }
        for (l_719 = 0; (l_719 <= 2); l_719 += 1)
        { /* block id: 490 */
            if (l_760)
                break;
            (*l_720) = p_41.f0;
        }
    }
    if (p_41.f0)
    { /* block id: 495 */
        int32_t *l_763 = &l_58;
        int32_t l_767 = 0x482A337BL;
        struct S1 l_771 = {71,65535UL,{1L}};
        struct S1 *l_770 = &l_771;
        struct S1 **l_772 = &l_770;
        if (p_41.f0)
        { /* block id: 496 */
            int32_t *l_764 = &l_748;
            uint16_t *l_768 = &l_747;
            (*l_764) = (l_763 == l_763);
            (***l_749) = func_55(((int16_t)p_41.f0 << (int16_t)((*l_768) = l_767)));
        }
        else
        { /* block id: 500 */
            int32_t **l_769 = &l_44;
            (*l_769) = &l_623;
        }
        (*l_772) = l_770;
    }
    else
    { /* block id: 504 */
        struct S1 *l_773 = (void*)0;
        struct S1 **l_774 = &l_773;
        struct S0 *l_775 = (void*)0;
        int32_t l_783 = 0xC1A9DF62L;
        (*l_774) = l_773;
        (*l_751) = (**l_750);
        if (((p_41.f0 != p_41.f0) < p_41.f0))
        { /* block id: 507 */
            uint16_t l_778 = 0x19ECL;
            (**l_749) = l_775;
            l_776 = (*l_774);
            if ((__builtin_clzll(p_41.f0) & l_778))
            { /* block id: 510 */
                int32_t **l_779 = &l_44;
                (*l_779) = &l_623;
                return p_41.f0;
            }
            else
            { /* block id: 513 */
                uint16_t l_780 = 0x9302L;
                return l_780;
            }
        }
        else
        { /* block id: 516 */
            struct S0 *l_781 = &l_777.f2;
            int32_t l_782 = 0x94E7C67DL;
            uint32_t *l_784 = (void*)0;
            uint32_t *l_785 = (void*)0;
            uint32_t l_787 = 7UL;
            uint32_t *l_786 = &l_787;
            const int32_t *l_789 = &l_782;
            const int32_t **l_788 = &l_789;
            (*l_781) = ((**l_750) = func_55(p_41.f0));
            (*l_788) = ((***l_749) , func_70((l_782 , p_41.f0), l_782, func_70(((p_41.f0 , p_41.f0) , ((*l_732) = (((*l_786) = (func_47(&l_782, (p_41.f0 & 0x870CD68BL), p_41.f0) , l_783)) >= p_41.f0))), p_41.f0, &l_748, p_41.f0, &l_782), p_41.f0, &l_623));
            (*l_788) = &l_748;
        }
    }
    return p_41.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_47(int32_t * p_48, uint16_t  p_49, int32_t  p_50)
{ /* block id: 405 */
    int32_t *l_625 = (void*)0;
    int32_t **l_624 = &l_625;
    int32_t l_626 = 0xB48A85BEL;
    int32_t l_631 = 0xC3738603L;
    int32_t l_633 = 7L;
    int32_t *l_632 = &l_633;
    int32_t *l_634 = (void*)0;
    int32_t *l_635 = (void*)0;
    int32_t *l_636 = &l_626;
    uint16_t l_677 = 0UL;
    uint16_t *l_676 = &l_677;
    uint16_t **l_675 = &l_676;
    uint16_t *** const l_674 = &l_675;
    uint16_t *** const *l_673 = &l_674;
    struct S0 l_678 = {0x721F8B3BL};
    struct S1 l_693 = {-32,0UL,{0x8E454BE5L}};
    uint16_t ***l_705 = &l_675;
    uint16_t ****l_704 = &l_705;
    uint16_t *****l_703 = &l_704;
    uint32_t l_716 = 0x41C9C6DDL;
    if (((*l_636) = (func_67((((func_67(((*l_624) = p_48)) >= (-6L)) && (((-1L) > (l_626 > (__builtin_ctzl(l_626) != (l_631 = ((((int32_t)(((uint16_t)func_67(p_48) / (uint16_t)p_49) < 0L) / (int32_t)l_626) <= l_626) | p_50))))) | l_626)) , l_632)) , l_631)))
    { /* block id: 409 */
        uint16_t l_641 = 1UL;
        uint16_t *l_640 = &l_641;
        uint16_t **l_639 = &l_640;
        uint16_t ***l_638 = &l_639;
        uint16_t ****l_637 = &l_638;
        const uint16_t *l_645 = &l_641;
        const uint16_t **l_644 = &l_645;
        const uint16_t ***l_643 = &l_644;
        const uint16_t ****l_642 = &l_643;
        struct S0 l_651 = {0L};
        struct S0 *l_650 = &l_651;
        struct S0 **l_649 = &l_650;
        int32_t *l_652 = &l_633;
        struct S0 **l_657 = &l_650;
        struct S0 l_662 = {0L};
        int32_t *l_690 = &l_651.f0;
        uint32_t **l_692 = (void*)0;
        int16_t l_696 = 0xCD0DL;
        (*l_642) = ((*l_637) = (void*)0);
        if (((((uint16_t)(__builtin_clzl((!(l_649 != &l_650))) != func_67(l_652)) - (uint16_t)(0x5ADB4B4BL >= l_641)) & (-4L)) && __builtin_ctz(((p_49 = ((uint16_t)((**l_639) = (p_50 , 8UL)) % (uint16_t)l_651.f0)) < 0x32B3L))))
        { /* block id: 414 */
            struct S0 l_663 = {1L};
            l_663 = (l_662 = func_55((((((int16_t)p_49 << (int16_t)p_49) <= (-3L)) != ((**l_639) = ((void*)0 == l_657))) >= (l_651.f0 = ((int16_t)(*l_636) >> (int16_t)((((((0x9FD1L <= (((uint16_t)((*l_637) == (*l_637)) / (uint16_t)(*l_636)) == (-6L))) , (*l_636)) , 0x508C9860L) || (-1L)) ^ p_50) < p_49))))));
        }
        else
        { /* block id: 419 */
            uint8_t l_685 = 0xD3L;
            int32_t *l_689 = &l_651.f0;
            int32_t *l_691 = &l_631;
            struct S1 l_701 = {5,0x6A3FL,{1L}};
            uint16_t *****l_702 = &l_637;
            struct S0 ** const l_706 = (void*)0;
            for (p_50 = 0; (p_50 > (-1)); --p_50)
            { /* block id: 422 */
                const uint16_t *** const l_672 = (void*)0;
                const uint16_t *** const *l_671 = &l_672;
                const uint16_t *** const **l_670 = &l_671;
                int32_t *l_688 = &l_631;
                l_678 = func_55(((*l_652) = (l_651.f0 = ((int16_t)((int32_t)l_662.f0 + (int32_t)(((*l_670) = &l_638) == l_673)) % (int16_t)6L))));
                for (l_677 = 16; (l_677 > 5); --l_677)
                { /* block id: 429 */
                    (*l_636) = p_49;
                    return p_50;
                }
                for (l_626 = 11; (l_626 != (-21)); l_626 -= 8)
                { /* block id: 435 */
                    int32_t l_686 = 0L;
                    int32_t l_687 = 0xD2A44B60L;
                    for (l_662.f0 = 0; (l_662.f0 < 18); l_662.f0 += 7)
                    { /* block id: 438 */
                        l_687 = (l_686 = l_685);
                        p_48 = l_688;
                    }
                    l_690 = l_689;
                }
                l_689 = l_691;
            }
            (*l_636) = func_67(((((l_692 != l_692) , (65534UL > ((((l_693 , (((((int16_t)l_696 / (int16_t)((uint32_t)((uint16_t)__builtin_ffsl(((*l_632) = ((l_701 , &l_642) == (l_703 = l_702)))) % (uint16_t)p_49) % (uint32_t)0x962C3572L)) | (*l_690)) >= p_50) == 0xB69AL)) , (*l_689)) , l_706) == (void*)0))) , (*l_691)) , (void*)0));
        }
        return p_50;
    }
    else
    { /* block id: 452 */
        struct S0 l_713 = {0L};
        struct S0 *l_717 = &l_713;
        (*l_717) = ((((int16_t)(-3L) % (int16_t)((*l_636) = (l_716 = __builtin_popcountl(((uint16_t)((int16_t)(l_713 , ((((void*)0 != &l_632) , func_67(p_48)) ^ ((void*)0 == l_676))) << (int16_t)6) + (uint16_t)((int32_t)((((((p_50 ^ l_713.f0) >= 4294967288UL) & l_713.f0) , l_713.f0) ^ p_49) >= 0x4871L) - (int32_t)4294967288UL)))))) != 0x5839886FL) , l_678);
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(struct S0  p_52, const int32_t * p_53, uint32_t  p_54)
{ /* block id: 403 */
    int32_t l_618 = 0x0DB4193CL;
    int32_t *l_617 = &l_618;
    int32_t *l_619 = &l_618;
    int32_t *l_620 = &l_618;
    int32_t *l_621 = &l_618;
    int32_t *l_622 = (void*)0;
    return l_622;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_55(int32_t  p_56)
{ /* block id: 39 */
    uint32_t l_69 = 0x53EBFF78L;
    int32_t *l_76 = (void*)0;
    const uint16_t **l_509 = (void*)0;
    uint16_t l_547 = 0UL;
    struct S0 l_548 = {0x8F2025E4L};
    int32_t l_585 = 0xB8A28680L;
    uint8_t l_613 = 0xC0L;
    for (p_56 = (-28); (p_56 <= (-18)); ++p_56)
    { /* block id: 42 */
        int32_t l_61 = 5L;
        struct S0 l_64 = {0x7DF7DC23L};
        int32_t *l_492 = &l_61;
        uint16_t l_525 = 0x44FEL;
        int32_t **l_530 = &l_76;
        for (l_61 = (-21); (l_61 >= 19); l_61 += 1)
        { /* block id: 45 */
            return l_64;
        }
    }
    if (p_56)
    { /* block id: 318 */
        int32_t l_532 = 0L;
        int32_t *l_531 = &l_532;
        int32_t **l_533 = &l_531;
        (*l_533) = l_531;
    }
    else
    { /* block id: 320 */
        int32_t *l_536 = (void*)0;
        struct S0 l_551 = {0xB7091DFAL};
        uint32_t l_553 = 3UL;
        uint32_t *l_552 = &l_553;
        uint16_t *l_554 = &l_547;
        int32_t *l_614 = &l_548.f0;
        struct S0 *l_616 = &l_551;
        struct S0 **l_615 = &l_616;
        for (p_56 = 0; (p_56 == 11); p_56 += 8)
        { /* block id: 323 */
            int32_t **l_537 = &l_76;
            int32_t **l_538 = (void*)0;
            int32_t l_540 = 0x200000DFL;
            int32_t *l_539 = &l_540;
            uint32_t l_542 = 0xE44EC54BL;
            uint32_t *l_541 = &l_542;
            (*l_537) = (p_56 , l_536);
            (*l_537) = func_81(((((void*)0 != l_538) == p_56) , p_56), ((*l_539) = 0xD8D51A2AL), p_56, ((*l_541) = p_56), ((p_56 != p_56) < p_56));
        }
        if ((__builtin_ffsl(((((*l_554) = ((uint16_t)p_56 + (uint16_t)(((((uint16_t)(((l_547 && ((l_548 , 0xE8EEL) & 65535UL)) == ((*l_552) = ((int16_t)(l_551 , 0x74C5L) % (int16_t)(__builtin_parityll(p_56) , p_56)))) & 4294967294UL) >> (uint16_t)l_551.f0) || 0x2946L) , 1L) , 65535UL))) == p_56) | (-7L))) < 0x7D86DE9CL))
        { /* block id: 331 */
            int32_t l_557 = 0x92343FF1L;
            int32_t *l_558 = (void*)0;
            int32_t *l_559 = &l_548.f0;
            uint32_t l_566 = 1UL;
            int32_t ***l_571 = (void*)0;
            int32_t ****l_570 = &l_571;
            struct S0 l_581 = {0x4CB1B0AFL};
            if (((int32_t)l_557 / (int32_t)(p_56 ^ ((*l_559) = func_67(l_76)))))
            { /* block id: 333 */
                int16_t l_562 = 0x7FB6L;
                struct S0 l_565 = {0xE08F61FBL};
                struct S0 *l_578 = &l_548;
                uint32_t *l_580 = &l_69;
                uint32_t **l_579 = &l_580;
                for (l_548.f0 = 0; (l_548.f0 >= 9); l_548.f0 += 1)
                { /* block id: 336 */
                    struct S0 l_563 = {0xF58AC76AL};
                    if ((func_67(&l_557) , l_562))
                    { /* block id: 337 */
                        struct S0 *l_564 = (void*)0;
                        l_565 = l_563;
                        if (l_562)
                            break;
                        if (p_56)
                            break;
                        if (l_565.f0)
                            break;
                    }
                    else
                    { /* block id: 342 */
                        l_563.f0 = l_566;
                        return l_551;
                    }
                    for (l_547 = 0; (l_547 < 20); l_547 += 1)
                    { /* block id: 348 */
                        uint32_t l_569 = 0x9699E69CL;
                        int32_t *l_572 = &l_557;
                        int32_t **l_573 = &l_558;
                        l_551.f0 = p_56;
                        (*l_573) = func_70(l_569, ((void*)0 != l_570), func_81(p_56, ((*l_572) = (((((p_56 | ((-1L) || func_67(&p_56))) , ((*l_559) >= p_56)) , p_56) ^ 0xE6A1F405L) | 65530UL)), l_563.f0, p_56, l_563.f0), l_562, l_558);
                        (*l_573) = (void*)0;
                    }
                    l_536 = (void*)0;
                }
                (*l_578) = (((uint16_t)((*l_554) = p_56) / (uint16_t)((int16_t)p_56 - (int16_t)p_56)) , l_551);
                l_565.f0 = (((func_67(l_76) , l_558) != ((*l_579) = &l_69)) , ((((*l_570) != (*l_570)) < p_56) == (((((p_56 < (((((*l_578) , p_56) , (*l_559)) | p_56) , p_56)) , 0x4B2BL) >= p_56) > 0x05ECL) < 4294967287UL)));
                (*l_578) = l_581;
            }
            else
            { /* block id: 361 */
                return l_581;
            }
            (*l_559) = p_56;
            if (__builtin_clz(p_56))
            { /* block id: 365 */
                int16_t l_584 = 0x14AEL;
                l_551.f0 = (l_585 = (((int32_t)0x66D94D7CL + (int32_t)l_584) , ((*l_559) = 0x0040A6EFL)));
            }
            else
            { /* block id: 369 */
                int32_t **l_586 = &l_76;
                int16_t l_599 = 5L;
                int16_t *l_598 = &l_599;
                (*l_586) = (void*)0;
                for (l_566 = 0; (l_566 == 27); l_566 += 1)
                { /* block id: 373 */
                    if (p_56)
                    { /* block id: 374 */
                        struct S0 *l_589 = &l_581;
                        (*l_589) = l_551;
                    }
                    else
                    { /* block id: 376 */
                        return l_581;
                    }
                    for (l_547 = (-29); (l_547 != 16); ++l_547)
                    { /* block id: 381 */
                        struct S0 *l_595 = &l_581;
                        struct S0 **l_594 = &l_595;
                        struct S0 ***l_593 = &l_594;
                        struct S0 ****l_592 = &l_593;
                        struct S0 ***l_597 = (void*)0;
                        struct S0 ****l_596 = &l_597;
                        (*l_596) = ((*l_592) = (void*)0);
                    }
                }
                (*l_586) = ((p_56 < ((*l_554) = (p_56 != (1L < (p_56 , (((*l_598) = 0xB21EL) && p_56)))))) , l_552);
            }
        }
        else
        { /* block id: 390 */
            int32_t **l_600 = &l_76;
            int32_t *l_605 = &l_585;
            int32_t l_607 = 0xE00E04B5L;
            int32_t *l_606 = &l_607;
            int32_t *l_611 = &l_551.f0;
            uint8_t l_612 = 0xF5L;
            (*l_600) = &l_585;
            l_548.f0 = (((((uint16_t)1UL + (uint16_t)((((*l_552) = p_56) < ((((*l_611) = ((uint16_t)((((*l_76) = p_56) != 0x64E9A230L) || func_67(func_81(((*l_605) = p_56), ((*l_606) = p_56), (-(uint32_t)((p_56 == p_56) , (((uint16_t)p_56 + (uint16_t)p_56) || 0xBB908CFFL))), p_56, p_56))) + (uint16_t)p_56)) , (*l_76)) >= p_56)) && l_612)) >= p_56) == 0x517D98B2L) > p_56);
        }
        (*l_614) = l_613;
        (*l_615) = &l_551;
    }
    return l_548;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_67(int32_t * p_68)
{ /* block id: 301 */
    int16_t l_488 = (-5L);
    int32_t l_490 = 0L;
    int32_t *l_489 = &l_490;
    uint32_t l_491 = 4294967295UL;
    (*l_489) = (__builtin_ffsl((l_488 = 0L)) , l_488);
    return l_491;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_70(uint32_t  p_71, uint16_t  p_72, int32_t * p_73, uint32_t  p_74, const int32_t * p_75)
{ /* block id: 48 */
    uint8_t l_77 = 1UL;
    int32_t l_79 = 0xCA1AEA07L;
    int32_t *l_78 = &l_79;
    int32_t l_397 = 0x5DE88017L;
    int32_t *l_396 = &l_397;
    int32_t * const *l_395 = &l_396;
    struct S0 l_425 = {0x7396CAC7L};
    struct S0 *l_424 = &l_425;
    int32_t *l_487 = &l_79;
    (*l_78) = l_77;
    if ((*l_78))
    { /* block id: 50 */
        uint32_t l_80 = 18446744073709551611UL;
        int32_t **l_87 = (void*)0;
        int32_t **l_88 = (void*)0;
        int32_t **l_89 = &l_78;
        int32_t **l_399 = &l_396;
        int32_t ***l_398 = &l_399;
        (*l_78) = l_80;
        (*l_89) = func_81((p_75 == p_75), l_80, (((*l_89) = p_73) == p_73), p_71, l_77);
        (*l_398) = l_395;
    }
    else
    { /* block id: 231 */
        struct S1 l_413 = {50,0x199EL,{9L}};
        int32_t **l_420 = &l_396;
        int32_t **l_422 = &l_78;
        struct S0 **l_426 = &l_424;
        int32_t l_442 = (-2L);
        for (p_71 = (-30); (p_71 <= 45); p_71 += 1)
        { /* block id: 234 */
            const int32_t *l_403 = &l_79;
            const int32_t **l_402 = &l_403;
            int16_t *l_407 = (void*)0;
            int16_t l_409 = (-4L);
            int16_t *l_408 = &l_409;
            int32_t *l_423 = &l_413.f2.f0;
            (*l_402) = &l_79;
            (*l_78) = (~((l_413.f0 = ((int16_t)((((*l_408) = (0x3EEE2655L != 0x835CBDD6L)) <= (!((uint16_t)(l_413 , p_72) << (uint16_t)14))) & 0xF83AA05CL) << (int16_t)2)) , 0xBF3CL));
            (*l_423) = ((*l_78) = (((uint32_t)(((uint16_t)l_413.f2.f0 / (uint16_t)(((uint32_t)(((void*)0 == l_420) , l_413.f2.f0) - (uint32_t)(-(int16_t)(p_72 == p_72))) || (l_422 != (void*)0))) , (**l_422)) + (uint32_t)p_71) < (*l_78)));
        }
        (*l_426) = l_424;
        for (l_397 = 0; (l_397 != 0); l_397 += 5)
        { /* block id: 245 */
            uint16_t l_440 = 0x30E4L;
            int32_t *l_445 = &l_442;
            for (p_72 = (-6); (p_72 != 9); p_72 += 1)
            { /* block id: 248 */
                int32_t l_441 = 0x69292E41L;
                int32_t l_443 = 0x2907BF89L;
                for (l_77 = 0; (l_77 > 17); l_77 += 8)
                { /* block id: 251 */
                    uint32_t l_444 = 4294967295UL;
                    (*l_78) = ((*l_78) | 0L);
                    if (p_74)
                    { /* block id: 253 */
                        return p_73;
                    }
                    else
                    { /* block id: 255 */
                        uint32_t l_437 = 0xF3D29A96L;
                        int16_t l_439 = 3L;
                        int16_t *l_438 = &l_439;
                        l_444 = ((p_74 , ((l_443 = (((*l_78) < (**l_422)) < (p_72 , ((p_71 , (((int32_t)(((*l_438) = ((p_72 , 5L) > ((uint32_t)(1UL & p_71) / (uint32_t)l_437))) == p_71) + (int32_t)l_440) >= l_441)) , l_442)))) ^ l_441)) ^ p_74);
                        return p_73;
                    }
                }
            }
            return p_73;
        }
        for (l_442 = 19; (l_442 < 19); l_442 += 5)
        { /* block id: 267 */
            uint32_t l_453 = 0x580AB61AL;
            int32_t l_455 = 0x68E1F56DL;
            int32_t l_472 = 0L;
            uint32_t l_481 = 0x6242BDF6L;
            uint32_t *l_480 = &l_481;
            for (l_79 = 0; (l_79 <= 20); l_79 += 1)
            { /* block id: 270 */
                int32_t *l_450 = &l_425.f0;
                int32_t *l_470 = (void*)0;
                int32_t *l_471 = &l_413.f2.f0;
                int16_t l_476 = 0L;
                int16_t *l_475 = &l_476;
                uint16_t l_478 = 0xE596L;
                uint16_t *l_477 = &l_478;
                (*l_450) = (1UL ^ p_74);
                if (((int16_t)l_453 << (int16_t)7))
                { /* block id: 272 */
                    int32_t *l_454 = &l_397;
                    (**l_426) = (**l_426);
                    return p_73;
                }
                else
                { /* block id: 275 */
                    int32_t ** const *l_457 = &l_420;
                    int32_t ** const **l_456 = &l_457;
                    (*l_450) = l_455;
                    (*l_450) = (p_71 < p_74);
                    (*l_456) = &l_395;
                    for (l_425.f0 = 18; (l_425.f0 > 27); ++l_425.f0)
                    { /* block id: 281 */
                        int32_t * const ***l_460 = (void*)0;
                        const int32_t *l_465 = (void*)0;
                        const int32_t **l_464 = &l_465;
                        const int32_t ***l_463 = &l_464;
                        const int32_t ****l_462 = &l_463;
                        const int32_t *****l_461 = &l_462;
                        (*l_461) = l_460;
                    }
                }
                (*l_422) = p_73;
                l_425.f0 = (((__builtin_parityl(((*l_450) > ((((**l_426) , ((int32_t)((((*l_477) = ((l_472 = ((*l_471) = l_79)) != (((int16_t)((*l_475) = p_71) << (int16_t)8) == l_455))) <= (l_450 != (void*)0)) != ((p_72 && l_455) < p_72)) / (int32_t)p_72)) <= p_72) > l_453))) <= 2UL) > p_74) >= p_71);
            }
            (*l_422) = func_81(((65535UL < p_74) == l_455), p_74, p_71, ((*l_480) = (~p_72)), p_71);
            if (l_481)
                break;
            return p_73;
        }
    }
    (*l_487) = (l_425.f0 = ((uint32_t)(((int16_t)p_71 - (int16_t)(~l_425.f0)) , 4294967295UL) - (uint32_t)p_74));
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_81(const int32_t  p_82, int32_t  p_83, uint16_t  p_84, uint32_t  p_85, uint32_t  p_86)
{ /* block id: 53 */
    uint32_t l_94 = 0x9F1AA496L;
    int16_t l_96 = 9L;
    int16_t *l_95 = &l_96;
    int32_t *l_100 = (void*)0;
    int32_t * const *l_99 = &l_100;
    struct S1 l_101 = {57,65535UL,{0xDA5A1D01L}};
    int32_t *l_102 = &l_101.f2.f0;
    int32_t l_104 = 0x86846FFDL;
    int32_t *l_103 = &l_104;
    int16_t l_106 = 0xF34FL;
    int16_t *l_105 = &l_106;
    int32_t *l_192 = &l_101.f2.f0;
    int32_t *l_194 = &l_101.f2.f0;
    const int32_t *l_257 = &l_104;
    struct S0 *l_263 = (void*)0;
    int32_t *l_380 = &l_101.f2.f0;
    int32_t *l_387 = &l_104;
    int32_t *l_388 = &l_104;
    int32_t *l_389 = &l_104;
    int32_t *l_390 = &l_104;
    int32_t *l_391 = &l_104;
    int32_t *l_392 = &l_101.f2.f0;
    int32_t *l_393 = &l_104;
    int32_t *l_394 = (void*)0;
lbl_351:
    if (((int16_t)(((*l_105) = (p_84 & (p_83 != ((*l_103) = (((uint16_t)l_94 + (uint16_t)((*l_95) = l_94)) , ((l_96 > 5L) < ((int32_t)p_86 + (int32_t)((*l_102) = ((((p_82 | (l_99 == &l_100)) & 0xFBEBD5D2L) , l_101) , p_85))))))))) >= 5L) + (int16_t)p_84))
    { /* block id: 58 */
        struct S0 *l_109 = (void*)0;
        const struct S0 *l_111 = &l_101.f2;
        int32_t l_118 = (-1L);
        int32_t *l_120 = (void*)0;
        for (l_104 = 0; (l_104 < 28); l_104 += 1)
        { /* block id: 61 */
            struct S0 **l_110 = &l_109;
            struct S0 **l_112 = &l_109;
            int32_t l_116 = 0L;
            (*l_110) = l_109;
            (*l_112) = l_111;
            for (l_106 = 5; (l_106 > 26); l_106 += 4)
            { /* block id: 66 */
                uint32_t l_117 = 18446744073709551615UL;
                int32_t *l_119 = &l_104;
                (*l_102) = ((**l_110) , (-(int32_t)((l_116 ^ ((l_117 = p_85) , l_118)) && ((p_86 == (0xC2D9L && p_86)) ^ l_118))));
                return l_120;
            }
            for (p_84 = (-27); (p_84 >= 33); ++p_84)
            { /* block id: 73 */
                int32_t **l_123 = (void*)0;
                int32_t ***l_124 = &l_123;
                int32_t **l_126 = &l_103;
                int32_t ***l_125 = &l_126;
                (*l_125) = ((*l_124) = l_123);
            }
        }
        (*l_103) = (p_83 <= ((*l_102) = p_86));
    }
    else
    { /* block id: 80 */
        const struct S0 *l_130 = &l_101.f2;
        const struct S0 **l_129 = &l_130;
        (*l_102) = ((int16_t)((*l_95) = p_86) - (int16_t)(l_129 != (((*l_103) ^ (-(int32_t)((uint16_t)p_82 - (uint16_t)__builtin_ctzl((*l_103))))) , &l_130)));
    }
    if (p_84)
    { /* block id: 84 */
        uint32_t l_145 = 0xDCB14003L;
        uint16_t l_153 = 3UL;
        uint16_t *l_152 = &l_153;
        int32_t l_163 = 1L;
        int32_t *l_186 = &l_104;
        int32_t *l_187 = &l_101.f2.f0;
        int32_t *l_190 = &l_101.f2.f0;
        int32_t *l_197 = &l_101.f2.f0;
        int32_t *l_198 = &l_104;
        int32_t *l_202 = (void*)0;
        struct S0 l_296 = {0xC3CE05E5L};
        struct S0 *l_295 = &l_296;
        int32_t l_322 = 0x33CC853FL;
        int32_t **l_384 = &l_186;
        int32_t ***l_383 = &l_384;
        for (p_85 = (-4); (p_85 != 32); p_85 += 9)
        { /* block id: 87 */
            int16_t l_138 = 0xE056L;
            uint16_t l_144 = 65535UL;
            uint16_t *l_143 = &l_144;
            int32_t *l_177 = &l_104;
            int32_t *l_188 = &l_104;
            struct S0 *l_226 = &l_101.f2;
            uint32_t l_242 = 0xB290D558L;
            const int32_t *l_350 = &l_163;
            struct S1 l_360 = {20,0xDD19L,{0x7B85D46DL}};
            uint16_t l_363 = 1UL;
            int32_t **l_373 = (void*)0;
            int32_t ***l_372 = &l_373;
            int32_t *l_381 = (void*)0;
        }
    }
    else
    { /* block id: 220 */
        for (p_85 = (-3); (p_85 <= 19); p_85 += 1)
        { /* block id: 223 */
            l_257 = &p_82;
        }
    }
    if (p_83)
        goto lbl_351;
    return l_394;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 201
   depth: 1, occurrence: 20
   depth: 2, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 2
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 2

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 177
   depth: 2, occurrence: 42
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 6
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 4
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 4
   depth: 22, occurrence: 3
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 291

XXX times a variable address is taken: 279
XXX times a pointer is dereferenced on RHS: 78
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 190
breakdown:
   depth: 1, occurrence: 184
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 763

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 586
   level: 2, occurrence: 90
   level: 3, occurrence: 10
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 121
XXX number of pointers point to scalars: 143
XXX number of pointers point to structs: 27
XXX percent of pointers has null in alias set: 28.2
XXX average alias set size: 1.18

XXX times a non-volatile is read: 873
XXX times a non-volatile is write: 485
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 174
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 34
   depth: 2, occurrence: 49
   depth: 3, occurrence: 29
   depth: 4, occurrence: 17
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 15.5
XXX percentage an existing variable is used: 84.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

