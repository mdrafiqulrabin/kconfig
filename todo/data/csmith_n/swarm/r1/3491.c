/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2257134662
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 17;
   signed f1 : 2;
};

union U1 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_29(void);
static uint32_t  func_31(union U1  p_32, uint32_t  p_33, uint32_t  p_34);
static union U1  func_35(int16_t  p_36, int16_t  p_37);
static uint16_t  func_42(int32_t  p_43, uint16_t  p_44, union U1  p_45);
static uint32_t  func_50(union U1  p_51, int32_t  p_52, int32_t  p_53, int32_t  p_54, uint8_t  p_55);
static int32_t  func_57(uint32_t  p_58, int32_t  p_59, struct S0  p_60, uint8_t  p_61, union U1  p_62);
static int32_t  func_63(struct S0  p_64);
static struct S0  func_66(uint16_t  p_67, int32_t  p_68, uint8_t  p_69, int32_t  p_70);
static uint8_t  func_72(uint32_t  p_73, union U1  p_74);
static int16_t  func_80(union U1  p_81, struct S0  p_82, int32_t  p_83, int32_t  p_84, uint16_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_29(void)
{ /* block id: 36 */
    uint8_t l_30 = 0U;
    union U1 l_56 = {0x1B7E};
    struct S0 l_65 = {290,-1};
    int32_t l_216 = 0x60AC8F59;
    uint8_t l_217 = 0xC8;
    uint32_t l_465 = 0x1B602BB1;
    uint16_t l_762 = 0x949C;
    int32_t l_770 = 0x68E7C36F;
    int32_t l_771 = 0xD0A2C06C;
    int32_t l_772 = 1;
    int32_t l_774 = 0x751C5180;
    int32_t l_776 = 0xB88F3010;
    uint16_t l_777 = 0x2D43;
    uint16_t l_845 = 0x44D1;
    uint32_t l_864 = 0x511F5895;
    uint16_t l_869 = 65535U;
    struct S0 l_880 = {286,0};
    if ((l_30 ^ func_31(func_35(((int16_t)(((uint16_t)func_42(((uint16_t)((uint32_t)func_50(l_56, func_57(l_56.f0, func_63(l_65), l_65, l_65.f1, l_56), l_216, l_56.f0, l_217) - (uint32_t)l_65.f0) - (uint16_t)l_65.f1), l_216, l_56) + (uint16_t)l_216) >= 0x85136B3A) << (int16_t)9), l_217), l_216, l_465)))
    { /* block id: 302 */
        struct S0 l_739 = {113,-0};
        for (l_216 = (-22); (l_216 >= 13); l_216 += 5)
        { /* block id: 305 */
            return l_739;
        }
    }
    else
    { /* block id: 308 */
        int16_t l_740 = 0;
        int32_t l_741 = 9;
        struct S0 l_763 = {334,-1};
        int32_t l_768 = (-6);
        int32_t l_769 = 1;
        int32_t l_773 = 8;
        int32_t l_775 = 0x54ED3843;
        l_741 = (l_740 & 0xB37FD4A8);
        l_65.f1 = (((uint32_t)l_740 + (uint32_t)((uint16_t)0x1603 >> (uint16_t)13)) && func_31(func_35((((int16_t)1 >> (int16_t)l_741) || (l_740 & (!((uint32_t)(__builtin_ffsll(l_30) > ((int16_t)(((uint16_t)l_741 - (uint16_t)(((int16_t)(((uint16_t)(((((uint16_t)((+(9 && 4294967295U)) & (-2)) >> (uint16_t)6) > 0x11B1) != l_56.f0) <= l_741) * (uint16_t)l_217) ^ 1) << (int16_t)3) | l_465)) != l_740) * (int16_t)0xC909)) + (uint32_t)l_56.f0)))), l_741), l_465, l_762));
        if (l_741)
        { /* block id: 311 */
            struct S0 l_764 = {179,0};
            l_764 = l_763;
        }
        else
        { /* block id: 313 */
            uint8_t l_765 = 0x76;
            l_765++;
        }
        ++l_777;
    }
    if ((+l_770))
    { /* block id: 318 */
        uint32_t l_783 = 0x4436EE8E;
        int32_t l_784 = (-10);
        l_784 = (((-1) < ((int16_t)(__builtin_ctz(l_783) & (l_65.f1 || l_783)) * (int16_t)l_465)) == (l_65.f1 || l_783));
    }
    else
    { /* block id: 320 */
        struct S0 l_785 = {218,-1};
        uint32_t l_816 = 9U;
        struct S0 l_850 = {176,-0};
        int16_t l_857 = 0x46F5;
        l_785 = l_785;
        l_785.f1 = ((uint16_t)__builtin_ctzl((l_785.f1 && (l_785.f1 < (1U == l_785.f0)))) >> (uint16_t)((uint16_t)func_63(l_785) >> (uint16_t)6));
        for (l_465 = 0; (l_465 <= 46); l_465 += 9)
        { /* block id: 325 */
            struct S0 l_794 = {316,-1};
            int32_t l_807 = 0x9D0716E2;
            int32_t l_820 = 0xB08666BF;
            uint32_t l_854 = 0x182F604C;
            for (l_770 = 21; (l_770 != (-22)); l_770 -= 1)
            { /* block id: 328 */
                int32_t l_797 = 8;
                l_794 = func_66(func_63(l_794), l_777, ((int16_t)0x1CBD + (int16_t)l_794.f0), (l_797 > ((__builtin_ctzl((l_794.f1 <= (l_797 ^ l_30))) && l_797) || l_771)));
                for (l_762 = 6; (l_762 == 29); ++l_762)
                { /* block id: 332 */
                    int16_t l_806 = (-3);
                    l_807 |= ((__builtin_popcountl(((int16_t)(l_794.f1 || ((uint16_t)l_785.f1 % (uint16_t)((l_776 < (0x8E984CCD > (((uint32_t)(l_794.f1 | 1) + (uint32_t)l_30) == 1))) && l_56.f0))) - (int16_t)0U)) > l_806) != l_806);
                }
                l_776 &= ((l_807 < ((uint32_t)l_771 % (uint32_t)(-1))) > 0x7EBA);
            }
            l_794.f1 &= l_807;
            if (((func_57(l_774, l_794.f1, func_66(((int32_t)((l_785.f1 & ((int32_t)l_465 - (int32_t)(l_785.f0 == l_772))) > __builtin_parity(l_774)) + (int32_t)(__builtin_popcountll(((int16_t)((0x9506 > l_807) > 0x6551176F) % (int16_t)l_785.f1)) > l_785.f0)), l_816, l_794.f0, l_785.f1), l_794.f1, l_56) || 4) > l_794.f0))
            { /* block id: 338 */
                int32_t l_819 = 0x059050B0;
                l_820 &= (((int16_t)l_819 * (int16_t)l_807) >= (8 || (l_807 & (l_819 || func_63(l_794)))));
                for (l_776 = 0; (l_776 <= 22); l_776 += 1)
                { /* block id: 342 */
                    int32_t l_825 = 9;
                    for (l_217 = 0; (l_217 != 35); ++l_217)
                    { /* block id: 345 */
                        l_785.f1 &= l_825;
                    }
                    for (l_217 = 2; (l_217 >= 3); l_217++)
                    { /* block id: 350 */
                        uint32_t l_830 = 0x4DC0FC55;
                        int32_t l_846 = 1;
                        l_807 &= ((int16_t)l_830 * (int16_t)((uint16_t)((int32_t)(l_819 == ((0x6E13 == (__builtin_parity(((((uint16_t)(((uint16_t)((l_819 == ((int16_t)l_830 * (int16_t)(l_830 ^ (l_771 && l_830)))) ^ (((l_825 <= 0x4E1930AB) <= l_830) && 0x389FCEBD)) << (uint16_t)2) < l_56.f0) * (uint16_t)l_819) > 0x2ACCF7AE) ^ l_830)) && l_216)) || 0U)) + (int32_t)0x754B3FA2) % (uint16_t)4U));
                        l_846 |= (__builtin_ctzl(l_816) & ((5 >= ((int16_t)(l_825 | l_816) >> (int16_t)0)) != (l_845 == 0x5E833D13)));
                    }
                    l_819 = l_762;
                }
                for (l_771 = (-14); (l_771 == (-26)); l_771 -= 5)
                { /* block id: 358 */
                    uint16_t l_849 = 65535U;
                    l_819 = l_849;
                }
            }
            else
            { /* block id: 361 */
                int32_t l_853 = 0xEBEF4F7F;
                l_850 = l_794;
                l_850.f1 = ((uint16_t)l_853 >> (uint16_t)2);
                l_854++;
            }
            l_857 &= l_794.f0;
        }
    }
    l_770 = ((__builtin_bswap64(((l_776 ^ 0x87727B7B) || ((l_56.f0 > l_762) >= (((((-10) < ((int32_t)((uint32_t)((uint16_t)l_217 % (uint16_t)func_72(l_864, func_35(l_774, l_772))) - (uint32_t)0xCC84B07D) + (int32_t)l_772)) != 7U) == l_774) || l_762)))) && l_216) != 0);
    for (l_774 = 0; (l_774 <= (-3)); l_774 -= 3)
    { /* block id: 372 */
        union U1 l_867 = {0xD2DD};
        struct S0 l_868 = {357,1};
        struct S0 l_878 = {160,0};
        if ((1U < func_80(l_867, l_868, l_869, (l_762 & l_465), l_772)))
        { /* block id: 373 */
            uint32_t l_871 = 6U;
            l_871 ^= (l_867.f0 | (-(int16_t)0x0D39));
            if ((l_30 & l_868.f0))
            { /* block id: 375 */
                uint16_t l_876 = 1U;
                for (l_845 = 11; (l_845 > 13); ++l_845)
                { /* block id: 378 */
                    uint32_t l_877 = 9U;
                    l_877 ^= ((uint32_t)(l_876 == l_771) + (uint32_t)l_871);
                }
                return l_868;
            }
            else
            { /* block id: 382 */
                return l_878;
            }
        }
        else
        { /* block id: 385 */
            struct S0 l_879 = {133,1};
            l_868 = l_879;
            l_868 = l_879;
            l_868.f1 = l_770;
        }
    }
    return l_880;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(union U1  p_32, uint32_t  p_33, uint32_t  p_34)
{ /* block id: 198 */
    uint32_t l_473 = 9U;
    int32_t l_474 = (-5);
    int32_t l_477 = 0xF13B944B;
    struct S0 l_478 = {286,0};
    int32_t l_489 = (-1);
    union U1 l_509 = {0xC77A};
    uint32_t l_650 = 0x33653A6F;
    uint16_t l_655 = 0x94A9;
    int32_t l_689 = (-1);
    int32_t l_692 = (-1);
    int32_t l_696 = 1;
    int32_t l_716 = 0x85495EE4;
    int32_t l_718 = 0x1B6551E6;
    uint32_t l_725 = 0x58B95C07;
    for (p_32.f0 = 0; (p_32.f0 == 25); p_32.f0 += 2)
    { /* block id: 201 */
        int16_t l_468 = 9;
        int32_t l_483 = 0x06A94A03;
        struct S0 l_484 = {311,-1};
        l_474 = ((l_468 != ((uint16_t)((+((-(int16_t)(p_34 ^ l_468)) != l_473)) | (l_468 == (0x3C04D749 <= (__builtin_popcountl(l_468) < p_33)))) << (uint16_t)7)) && 0x25F35571);
        if (((int16_t)l_477 + (int16_t)func_63(l_478)))
        { /* block id: 203 */
            l_483 = (((int16_t)0x6527 >> (int16_t)1) == ((((int16_t)(-1) - (int16_t)1U) >= p_34) <= 0x69D8));
            l_478 = l_478;
        }
        else
        { /* block id: 206 */
            int16_t l_485 = (-1);
            struct S0 l_488 = {276,0};
            uint32_t l_490 = 0xB8BFFC5A;
            int32_t l_501 = (-1);
            l_488.f1 = ((func_57(p_33, l_478.f0, l_484, l_485, p_32) < p_32.f0) & (((uint32_t)func_63(l_488) - (uint32_t)l_489) && l_490));
            if (p_33)
                break;
            l_501 ^= ((uint16_t)(((0xB9CF || ((uint16_t)(((int16_t)((p_33 != ((int32_t)__builtin_clzl(p_34) + (int32_t)l_489)) != p_34) * (int16_t)((l_477 & (((int16_t)(l_477 <= (l_488.f1 || p_32.f0)) >> (int16_t)p_34) < l_483)) >= p_32.f0)) | p_32.f0) * (uint16_t)l_489)) && l_489) | l_483) >> (uint16_t)9);
        }
        l_483 ^= p_33;
        l_474 = l_468;
    }
    l_477 = l_473;
    if (l_477)
    { /* block id: 215 */
        uint32_t l_504 = 0x283B7F0C;
        int32_t l_510 = 0xA1112B7D;
        union U1 l_511 = {65535U};
        struct S0 l_512 = {128,-1};
        l_510 |= func_57(p_34, l_473, l_478, ((p_32.f0 >= (((uint16_t)l_504 << (uint16_t)(0x03B84FF0 && ((0x1E926790 >= (((((((uint16_t)p_33 >> (uint16_t)((int32_t)p_34 % (int32_t)0x20EA23E7)) && p_34) || l_504) && 4294967295U) | 1) >= l_504)) >= 0x478A))) <= 0x6686D26A)) | p_32.f0), l_509);
        l_477 |= func_50(l_511, l_478.f1, p_33, l_489, p_33);
        l_512 = l_478;
    }
    else
    { /* block id: 219 */
        uint16_t l_513 = 0xEF49;
        int32_t l_516 = 0x9CD92F0E;
        struct S0 l_544 = {315,1};
        int16_t l_553 = (-1);
        union U1 l_578 = {1U};
        uint16_t l_627 = 65530U;
        uint8_t l_638 = 255U;
        int32_t l_691 = 1;
        int32_t l_697 = (-1);
        int32_t l_698 = 0x298B975F;
        int32_t l_704 = 1;
        int32_t l_706 = 0;
        int32_t l_708 = 0x3AB8DFB2;
        int32_t l_710 = 0x36CAB4AA;
        int32_t l_713 = 0x09D5741A;
        uint8_t l_734 = 0xC1;
lbl_666:
        l_513++;
lbl_633:
        l_516 |= (l_509.f0 & p_33);
        if (((p_34 > (l_516 && 2U)) < p_33))
        { /* block id: 222 */
            uint32_t l_554 = 0x7F0C31D8;
            for (p_32.f0 = (-7); (p_32.f0 <= 42); ++p_32.f0)
            { /* block id: 225 */
                uint8_t l_525 = 248U;
                for (l_489 = 0; (l_489 != (-14)); l_489 -= 1)
                { /* block id: 228 */
                    uint32_t l_528 = 0U;
                    for (l_477 = 0; (l_477 > (-18)); l_477 -= 1)
                    { /* block id: 231 */
                        struct S0 l_538 = {239,0};
                        union U1 l_539 = {0x9FE3};
                        l_478.f1 &= ((uint16_t)(p_34 == __builtin_ctzll(p_33)) * (uint16_t)(l_525 > (p_34 < ((int16_t)(l_528 ^ (1 != ((int16_t)((((uint16_t)func_72((((((((-1) & ((!((int32_t)((int16_t)(func_57(l_473, p_34, l_538, p_33, l_539) == l_538.f0) << (int16_t)14) + (int32_t)p_32.f0)) & 4)) > 4294967294U) >= p_34) < p_32.f0) | l_525) || 0xCE5B), l_539) << (uint16_t)l_525) | p_32.f0) && 0xDC60) >> (int16_t)2))) * (int16_t)p_34))));
                        l_478.f1 = ((uint16_t)((l_516 < (p_34 == (((((func_63(l_544) > l_538.f1) & 0x647428AD) && ((int32_t)l_538.f0 - (int32_t)((((int16_t)(((((((uint16_t)((uint16_t)__builtin_ffsl(l_474) + (uint16_t)p_32.f0) % (uint16_t)5U) && p_34) >= l_538.f0) & p_32.f0) >= 0) >= l_538.f0) << (int16_t)3) > l_513) == 0U))) == 0x4832) != l_538.f1))) & l_525) >> (uint16_t)7);
                        l_553 = l_538.f0;
                        if (p_32.f0)
                            continue;
                    }
                    l_478.f1 = l_554;
                }
                if (l_554)
                    break;
            }
            for (l_554 = 13; (l_554 >= 3); l_554 -= 3)
            { /* block id: 243 */
                int32_t l_560 = 0;
                l_544.f1 = l_473;
                l_477 &= ((uint16_t)((!p_32.f0) ^ 0x9824) * (uint16_t)p_32.f0);
                l_560 = l_473;
            }
        }
        else
        { /* block id: 248 */
            int16_t l_563 = 0x6A28;
            struct S0 l_625 = {317,-1};
            uint32_t l_637 = 0x4998F574;
            int32_t l_685 = 0x14E7C9A6;
            int32_t l_686 = 1;
            int32_t l_687 = 0xB04DB3ED;
            int32_t l_688 = 0xE2F7F8A9;
            int32_t l_690 = 0x8E68345F;
            int32_t l_693 = 0xF77B1D39;
            int32_t l_695 = (-2);
            int32_t l_700 = 0;
            int32_t l_709 = 0xF790AEDD;
            int32_t l_711 = 0x7A9BC827;
            int32_t l_714 = 0x297CDD38;
            int32_t l_720 = 0x8BA00F09;
            if ((l_478.f1 | ((int16_t)(__builtin_ctzl(l_563) >= l_553) - (int16_t)(65528U == ((uint16_t)((int16_t)((!((((l_478.f0 >= l_477) != (l_513 < ((0xADA17A87 == l_513) == p_34))) || p_32.f0) ^ 0x985698F1)) ^ p_33) * (int16_t)p_32.f0) - (uint16_t)p_34)))))
            { /* block id: 249 */
                uint8_t l_579 = 1U;
                int32_t l_594 = 0x449C6FEA;
                int32_t l_616 = 0xE56B5A29;
                struct S0 l_626 = {88,1};
                uint32_t l_645 = 1U;
                int32_t l_669 = 0xE529422D;
                int32_t l_699 = 0;
                int32_t l_703 = 0xF4F4F292;
                int32_t l_705 = (-1);
                int32_t l_707 = (-10);
                int32_t l_712 = 1;
                int32_t l_715 = 0x1F55BF52;
                int32_t l_717 = 1;
                int32_t l_722 = 0x8012DD5B;
                l_579 = (p_33 > (func_42(((uint16_t)(0x5A58 < ((((uint16_t)((uint16_t)((4294967295U >= l_563) > l_563) << (uint16_t)0) * (uint16_t)__builtin_ffs(p_33)) == (((!(((int32_t)func_80(l_578, l_544, l_477, l_478.f1, p_34) + (int32_t)p_33) > p_33)) == 0x7AF5) <= p_33)) >= l_478.f1)) + (uint16_t)l_477), p_32.f0, p_32) & p_32.f0));
                if ((((int16_t)(-1) % (int16_t)__builtin_ctzl(((((int16_t)0x14FB + (int16_t)l_578.f0) > 0x236D) && (((p_34 == __builtin_bswap32(p_34)) || ((+p_33) == ((__builtin_ia32_crc32qi(p_33, p_32.f0) || l_563) != l_579))) && l_477)))) > 0x7FCE))
                { /* block id: 251 */
                    uint32_t l_606 = 0x328D9628;
                    union U1 l_624 = {0x8170};
                    for (l_553 = 23; (l_553 == 27); l_553 += 6)
                    { /* block id: 254 */
                        int16_t l_589 = 0xA8C1;
                        struct S0 l_597 = {122,-0};
                        l_594 = (((l_478.f1 == l_589) && l_563) >= (+(l_589 | ((uint16_t)p_32.f0 << (uint16_t)((!(l_589 < 0x2BFA8556)) <= (p_34 ^ (0xD14A2641 | p_32.f0)))))));
                        l_544.f1 = ((int16_t)func_63(l_597) * (int16_t)((int16_t)((uint32_t)l_553 - (uint32_t)l_563) + (int16_t)0x03B8));
                        l_516 = (((((int16_t)((((uint16_t)(((l_563 & l_606) && (((((uint16_t)p_33 * (uint16_t)((uint16_t)0U - (uint16_t)(((uint32_t)(!l_589) + (uint32_t)l_563) ^ (((p_34 <= (((((p_34 < ((uint16_t)0x6309 * (uint16_t)p_33)) != p_34) & p_33) <= l_563) < l_597.f1)) && 65530U) != l_589)))) & p_32.f0) >= l_594) & 1)) != p_33) >> (uint16_t)p_34) == p_34) >= l_616) >> (int16_t)9) && p_33) || l_589) || l_616);
                        l_474 = ((int32_t)((uint16_t)(~p_33) << (uint16_t)(((uint32_t)func_80(l_624, l_625, l_544.f0, l_594, p_34) % (uint32_t)((__builtin_clz(p_32.f0) | 3U) & l_477)) <= 65535U)) % (int32_t)p_33);
                    }
                }
                else
                { /* block id: 260 */
                    uint16_t l_630 = 0x70FC;
                    int32_t l_651 = 0;
                    if (p_32.f0)
                    { /* block id: 261 */
                        l_544 = l_626;
                        l_478.f1 |= ((p_32.f0 ^ l_627) < ((((int16_t)((__builtin_popcountll(l_616) < 0x76A8) != p_34) << (int16_t)l_626.f0) < p_34) > l_630));
                        return l_625.f1;
                    }
                    else
                    { /* block id: 265 */
                        int32_t l_631 = 0x76D4B4B8;
                        int32_t l_632 = 0x19768BD4;
                        l_632 = l_631;
                        if (l_513)
                            goto lbl_633;
                    }
                    l_626.f1 = (func_80(func_35(((int16_t)p_34 * (int16_t)(0x58C4 <= (__builtin_bswap64(p_33) ^ ((~l_637) || (l_638 < ((uint16_t)(p_32.f0 > (((int16_t)((int16_t)__builtin_ctz(l_474) % (int16_t)l_638) * (int16_t)0x77B2) == p_33)) + (uint16_t)l_478.f0)))))), l_473), l_478, l_474, l_645, l_630) || p_32.f0);
                    l_651 &= (p_33 <= (__builtin_popcountl(p_32.f0) || ((int16_t)func_63(l_626) >> (int16_t)((int16_t)(l_650 < func_72(l_625.f1, p_32)) * (int16_t)l_509.f0))));
                    for (l_474 = 8; (l_474 < 19); l_474 += 3)
                    { /* block id: 273 */
                        uint32_t l_654 = 0x84D747E7;
                        l_655 = (l_654 && l_654);
                        l_651 |= ((uint32_t)(4294967286U != p_33) + (uint32_t)0x4FD8D2CE);
                    }
                }
                for (l_616 = (-27); (l_616 != (-18)); l_616 += 3)
                { /* block id: 280 */
                    int32_t l_664 = 0x6C7D905A;
                    struct S0 l_665 = {240,-1};
                    l_477 = ((uint16_t)((int32_t)((((((0x7E5E < p_32.f0) >= l_478.f1) > 0x857B8DB2) > l_626.f1) >= (((__builtin_clzll(p_34) ^ (0x4543A18D <= (l_627 <= l_544.f1))) != 65528U) || l_513)) || p_34) - (int32_t)0) % (uint16_t)l_563);
                    if (l_664)
                    { /* block id: 282 */
                        l_665 = l_544;
                    }
                    else
                    { /* block id: 284 */
                        if (l_625.f1)
                            goto lbl_666;
                    }
                    l_626.f1 ^= (l_664 ^ 0xB14C);
                }
                if ((((uint16_t)l_669 * (uint16_t)((int32_t)p_34 % (int32_t)((-8) | (p_33 != (0xD6B38145 & l_616))))) > (~(l_579 | ((uint32_t)(((4294967295U <= (l_478.f1 != 0x77A5EA84)) > p_32.f0) ^ p_34) - (uint32_t)p_32.f0)))))
                { /* block id: 289 */
                    l_478.f1 = ((int16_t)1 << (int16_t)(0x3BBE > ((((uint32_t)p_32.f0 + (uint32_t)p_33) & l_478.f1) >= ((uint32_t)0x47427DF7 + (uint32_t)((uint16_t)p_32.f0 >> (uint16_t)0)))));
                    l_625.f1 = (-(uint16_t)l_553);
                }
                else
                { /* block id: 292 */
                    struct S0 l_684 = {265,0};
                    int32_t l_694 = 1;
                    int32_t l_701 = 1;
                    int32_t l_702 = 4;
                    int32_t l_719 = 4;
                    int32_t l_721 = (-4);
                    int32_t l_723 = 0xACC4F9FF;
                    int32_t l_724 = (-1);
                    l_684 = l_626;
                    ++l_725;
                }
            }
            else
            { /* block id: 296 */
                int16_t l_728 = 1;
                int32_t l_729 = 0x35FB31B7;
                int32_t l_730 = (-6);
                int32_t l_731 = 1;
                int32_t l_732 = (-1);
                int32_t l_733 = 4;
                ++l_734;
            }
        }
    }
    return l_696;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_35(int16_t  p_36, int16_t  p_37)
{ /* block id: 195 */
    struct S0 l_463 = {180,-1};
    union U1 l_464 = {0xB940};
    l_463 = l_463;
    return l_464;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_42(int32_t  p_43, uint16_t  p_44, union U1  p_45)
{ /* block id: 78 */
    int16_t l_234 = 0x4378;
    uint32_t l_240 = 1U;
    union U1 l_243 = {4U};
    int32_t l_289 = 0;
    int32_t l_290 = 1;
    int32_t l_354 = (-1);
    struct S0 l_376 = {232,-0};
    if ((((uint16_t)(l_234 | ((int16_t)p_45.f0 * (int16_t)(l_234 == l_234))) % (uint16_t)((((~p_44) != ((int16_t)(__builtin_clzl(l_234) ^ ((((l_240 >= func_72(p_45.f0, p_45)) >= 3) < p_45.f0) < 0x37C9)) << (int16_t)l_234)) || 0xFE9C) | l_234)) == 0x27A38486))
    { /* block id: 79 */
        struct S0 l_244 = {282,-1};
        if (((uint16_t)(func_80(l_243, l_244, p_43, p_43, p_43) || ((-1) && l_240)) - (uint16_t)l_244.f1))
        { /* block id: 80 */
            uint8_t l_245 = 1U;
            int32_t l_246 = 0;
            int16_t l_267 = (-1);
            p_43 &= l_245;
            l_246 = 0xA68AF11E;
            l_244.f1 = ((((l_245 <= ((uint16_t)(((uint16_t)__builtin_ctz(l_246) * (uint16_t)((uint16_t)((uint32_t)((int16_t)((uint32_t)(((int16_t)(((((uint16_t)(((int16_t)((uint16_t)__builtin_popcountll(((l_243.f0 < (l_246 == l_267)) < (0 != p_45.f0))) * (uint16_t)p_43) % (int16_t)p_44) & l_246) >> (uint16_t)12) | p_45.f0) != 0xBEB8) | 0x0075) >> (int16_t)p_44) >= 0U) % (uint32_t)(-1)) - (int16_t)l_244.f0) - (uint32_t)l_240) % (uint16_t)p_45.f0)) > l_244.f1) - (uint16_t)0x3619)) <= l_246) ^ p_45.f0) >= 0xA2A3);
        }
        else
        { /* block id: 84 */
            uint32_t l_268 = 3U;
            struct S0 l_271 = {1,0};
            ++l_268;
            l_271 = l_271;
            p_43 = ((uint32_t)(p_43 <= ((uint16_t)l_244.f0 * (uint16_t)l_243.f0)) - (uint32_t)1U);
        }
        return l_243.f0;
    }
    else
    { /* block id: 90 */
        int32_t l_283 = 8;
        int32_t l_288 = 2;
        int32_t l_291 = 0xB70B1722;
        union U1 l_315 = {0xD924};
        int32_t l_348 = 0xD0620ECA;
        int32_t l_351 = (-10);
        int32_t l_352 = 0xF67B546B;
        uint8_t l_403 = 1U;
        struct S0 l_410 = {223,0};
        if ((p_43 > 3U))
        { /* block id: 91 */
            uint8_t l_284 = 0U;
            struct S0 l_287 = {146,-0};
            union U1 l_297 = {0xF5AF};
            struct S0 l_339 = {273,-0};
            int32_t l_344 = 9;
            int16_t l_346 = 0x2E37;
            int32_t l_350 = 0;
            for (p_44 = 0; (p_44 <= 35); ++p_44)
            { /* block id: 94 */
                int32_t l_280 = 6;
                int32_t l_337 = 0x3569C191;
                int32_t l_343 = 0x60ED1AFC;
                int32_t l_345 = 0x5198B6F5;
                int32_t l_349 = 0x303632AA;
                int32_t l_353 = 0x5F94D6FD;
                for (l_243.f0 = 26; (l_243.f0 <= 6); l_243.f0 -= 4)
                { /* block id: 97 */
                    int32_t l_286 = (-1);
                    uint8_t l_307 = 0x88;
                    int32_t l_308 = 0xDCF2B0F9;
                    int32_t l_316 = 0xDBC68AE5;
                    l_287 = func_66(l_280, p_44, ((uint32_t)(l_283 < ((p_45.f0 != l_284) & l_234)) + (uint32_t)(~((((((((p_45.f0 ^ p_45.f0) & (__builtin_clzll(p_43) && p_45.f0)) & l_280) || 0x332A91C8) | 0) <= 0x7A196789) || 0x32A1) & l_286))), p_43);
                    if (l_283)
                        break;
                    if (p_43)
                    { /* block id: 100 */
                        uint32_t l_292 = 0x750AFB25;
                        l_292++;
                    }
                    else
                    { /* block id: 102 */
                        uint16_t l_306 = 0x01D1;
                        l_291 ^= ((int16_t)((func_80(l_297, l_287, ((int16_t)((((p_44 <= ((((((0x290A != 0x21CE) && p_43) < (((((uint32_t)(((-1) & (((((uint16_t)((uint32_t)(p_44 & __builtin_popcountll(p_43)) % (uint32_t)p_45.f0) >> (uint16_t)10) || 0) & p_43) == 0)) & l_289) + (uint32_t)2U) <= p_43) > l_306) <= p_44)) | p_43) && 9U) ^ 0x5911)) && l_280) >= l_289) == l_307) % (int16_t)p_44), p_45.f0, l_280) == 4294967295U) != l_283) >> (int16_t)l_306);
                        l_288 = p_45.f0;
                        l_308 |= 0xD5404555;
                        l_289 ^= (((uint16_t)p_44 % (uint16_t)((int32_t)(0xF4F445BD && ((0x11DE2C0B > func_72((p_43 <= (p_45.f0 == l_280)), l_315)) < l_316)) + (int32_t)0U)) <= 1U);
                    }
                }
                for (l_243.f0 = 0; (l_243.f0 < 59); l_243.f0++)
                { /* block id: 111 */
                    int16_t l_338 = 0x2AB7;
                    int32_t l_347 = (-5);
                    if ((l_315.f0 != (((uint16_t)(+__builtin_clz(l_280)) >> (uint16_t)func_57((__builtin_popcountll(((int16_t)l_315.f0 + (int16_t)((uint16_t)l_240 + (uint16_t)((int16_t)func_72(((int16_t)((+4294967290U) ^ (p_43 ^ l_280)) * (int16_t)((uint16_t)(((uint32_t)((uint32_t)p_44 - (uint32_t)0U) - (uint32_t)p_44) && 0x44A6914E) % (uint16_t)p_44)), l_315) * (int16_t)l_337)))) | 0x8DB9), l_338, l_339, p_43, p_45)) | p_43)))
                    { /* block id: 112 */
                        uint8_t l_340 = 253U;
                        ++l_340;
                        if (p_45.f0)
                            break;
                    }
                    else
                    { /* block id: 115 */
                        uint16_t l_355 = 65533U;
                        ++l_355;
                        p_43 = (l_347 && ((uint16_t)p_44 * (uint16_t)0));
                    }
                }
                for (l_234 = 0; (l_234 != (-28)); l_234 -= 4)
                { /* block id: 122 */
                    uint16_t l_366 = 0x6402;
                    if ((0x5C46 | (((int16_t)(((int16_t)func_50(p_45, (p_43 || __builtin_parityll(l_351)), p_43, l_348, l_290) << (int16_t)11) && (-6)) << (int16_t)p_44) || l_366)))
                    { /* block id: 123 */
                        if (l_354)
                            break;
                        l_291 = (l_354 != l_343);
                        return l_339.f0;
                    }
                    else
                    { /* block id: 127 */
                        l_289 ^= l_288;
                        if (l_352)
                            continue;
                    }
                }
            }
            for (p_45.f0 = 4; (p_45.f0 < 30); p_45.f0 += 7)
            { /* block id: 135 */
                l_290 |= 1;
                return l_344;
            }
            l_354 = ((int16_t)l_346 * (int16_t)__builtin_ctz(l_287.f1));
            l_352 = 7;
        }
        else
        { /* block id: 141 */
            uint8_t l_375 = 0xE3;
            int32_t l_387 = (-1);
            union U1 l_395 = {0x24FD};
            int32_t l_398 = 0xF7604812;
            if (((uint16_t)((int32_t)(l_375 ^ p_44) + (int32_t)__builtin_ia32_crc32qi(func_57((0xFE3B < 0x060A), l_375, l_376, l_234, p_45), l_375)) >> (uint16_t)14))
            { /* block id: 142 */
                int32_t l_379 = (-6);
                struct S0 l_390 = {333,1};
                if (((uint32_t)l_375 % (uint32_t)(l_379 | 0x48760730)))
                { /* block id: 143 */
                    l_387 &= (((int16_t)(!(p_45.f0 ^ (l_288 == (p_45.f0 <= ((int16_t)((int32_t)(p_43 == (l_354 == (__builtin_parityll(__builtin_popcountl(p_44)) & 0xEAFD2468))) + (int32_t)0xEEC10E84) - (int16_t)p_45.f0))))) >> (int16_t)p_44) < 0x8AC7DD00);
                    return l_351;
                }
                else
                { /* block id: 146 */
                    uint16_t l_391 = 1U;
                    for (l_354 = 0; (l_354 != 0); l_354 += 9)
                    { /* block id: 149 */
                        l_387 = l_375;
                        l_289 |= __builtin_parity(l_379);
                        l_289 &= func_80(l_315, l_390, l_391, p_44, p_44);
                    }
                    l_390 = l_376;
                    return l_379;
                }
            }
            else
            { /* block id: 157 */
                uint8_t l_392 = 0xBB;
                l_290 = func_72(l_392, p_45);
            }
lbl_438:
            l_291 |= (((uint16_t)l_375 + (uint16_t)0x7592) >= func_80(l_395, func_66((p_45.f0 ^ ((uint16_t)(p_45.f0 >= 0U) * (uint16_t)0xA27D)), (((l_395.f0 & (l_315.f0 <= l_351)) >= l_398) || p_43), l_234, l_398), l_395.f0, l_376.f0, p_43));
            for (l_243.f0 = 0; (l_243.f0 <= 2); l_243.f0 += 6)
            { /* block id: 163 */
                uint32_t l_411 = 0x6F462669;
                int32_t l_420 = 2;
                int32_t l_422 = 0x74CAC6F1;
                int32_t l_423 = 3;
                int32_t l_425 = 9;
                uint32_t l_426 = 0xF7151830;
                struct S0 l_436 = {300,-1};
                if ((((int16_t)l_398 << (int16_t)(3U > __builtin_parityl(l_403))) == (__builtin_bswap32(p_45.f0) >= (((uint16_t)(((((uint32_t)((uint16_t)7U << (uint16_t)(func_57(p_44, l_376.f0, l_410, l_411, p_45) | 4294967292U)) % (uint32_t)l_289) < 0x5009) || 0x7A24) || p_44) * (uint16_t)l_395.f0) > 0x5140))))
                { /* block id: 164 */
                    int32_t l_417 = 0xAF6B08F5;
                    if ((l_283 > (-(int32_t)(-6))))
                    { /* block id: 165 */
                        int32_t l_419 = (-1);
                        int32_t l_421 = 1;
                        int32_t l_424 = 1;
                        p_43 = ((uint16_t)(((int16_t)func_63(func_66(l_417, l_352, p_43, (0x0D59 | 0xC367))) << (int16_t)((l_417 >= (0x5800 | 65535U)) ^ l_387)) ^ p_44) % (uint16_t)p_43);
                        l_288 = ((0xE62F || ((+__builtin_clzl(l_288)) ^ p_43)) < l_419);
                        ++l_426;
                        if (p_45.f0)
                            continue;
                    }
                    else
                    { /* block id: 170 */
                        uint32_t l_435 = 4294967295U;
                        union U1 l_437 = {6U};
                        p_43 = ((int16_t)p_43 >> (int16_t)14);
                        l_422 |= ((((int32_t)(p_44 != p_44) - (int32_t)func_57(((int16_t)l_290 >> (int16_t)l_435), p_43, l_436, p_45.f0, l_437)) && 0xD602) < p_45.f0);
                    }
                    l_436 = l_436;
                    if (l_403)
                        goto lbl_438;
                }
                else
                { /* block id: 176 */
                    uint16_t l_445 = 65535U;
                    union U1 l_458 = {0x408F};
                    struct S0 l_459 = {328,1};
                    l_423 ^= l_290;
                    p_43 = ((((int16_t)((uint16_t)(((uint16_t)l_445 << (uint16_t)6) != ((p_43 && ((uint16_t)p_43 * (uint16_t)l_445)) != (l_395.f0 == (((uint16_t)((uint16_t)p_43 >> (uint16_t)((uint16_t)l_348 << (uint16_t)((uint16_t)((int16_t)func_72(l_395.f0, l_458) % (int16_t)65527U) << (uint16_t)p_43))) >> (uint16_t)6) > 0x39703B16)))) >> (uint16_t)p_44) % (int16_t)0x99D3) || l_403) > l_283);
                    l_459 = l_459;
                    p_43 = l_411;
                }
                return p_44;
            }
            p_43 = __builtin_parity(l_375);
        }
        l_348 |= (4U || l_403);
        for (l_315.f0 = (-7); (l_315.f0 < 9); l_315.f0 += 2)
        { /* block id: 189 */
            uint16_t l_462 = 0xAEE1;
            if (p_43)
                break;
            if (l_462)
                continue;
        }
    }
    return l_290;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_50(union U1  p_51, int32_t  p_52, int32_t  p_53, int32_t  p_54, uint8_t  p_55)
{ /* block id: 75 */
    int32_t l_220 = 0x10F9C02E;
    int32_t l_230 = 0xE436C4CA;
    int32_t l_231 = 0x5AF14B1F;
    l_231 = ((int16_t)(l_220 || l_220) - (int16_t)((((((uint16_t)(l_220 && 0x5D39) >> (uint16_t)l_220) >= ((uint16_t)((uint16_t)0x2298 * (uint16_t)(4294967295U <= (((int16_t)(l_220 <= (+(0xD89A < l_220))) - (int16_t)0x63BB) && p_52))) - (uint16_t)l_230)) ^ l_230) <= 0xADAB8F03) | 0x852E7831));
    return l_231;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_57(uint32_t  p_58, int32_t  p_59, struct S0  p_60, uint8_t  p_61, union U1  p_62)
{ /* block id: 72 */
    uint32_t l_211 = 1U;
    int32_t l_214 = (-7);
    int32_t l_215 = 0x1F9A04B7;
    l_215 = (l_211 || (((int16_t)((0x605C96C5 & p_61) == (p_60.f1 || p_59)) - (int16_t)p_61) | (((l_211 | __builtin_ffsll((0 <= l_211))) < l_214) != p_61)));
    return l_214;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(struct S0  p_64)
{ /* block id: 37 */
    uint8_t l_79 = 5U;
    union U1 l_86 = {65531U};
    struct S0 l_87 = {237,1};
    l_87 = func_66(p_64.f0, (p_64.f1 & (~(p_64.f0 | p_64.f0))), func_72(((int32_t)((int32_t)l_79 - (int32_t)((func_80(l_86, l_87, p_64.f0, l_87.f0, p_64.f1) != 0xD0C9) && l_87.f1)) + (int32_t)0xF88485BD), l_86), l_86.f0);
    return l_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_66(uint16_t  p_67, int32_t  p_68, uint8_t  p_69, int32_t  p_70)
{ /* block id: 56 */
    union U1 l_187 = {0xC69F};
    struct S0 l_188 = {271,-1};
    if ((((uint16_t)p_67 + (uint16_t)((int16_t)((((int16_t)func_80(l_187, l_188, (((-(uint16_t)0x3FB1) < p_67) > func_72(p_69, l_187)), p_69, l_188.f0) % (int16_t)l_188.f0) | p_67) >= p_67) >> (int16_t)p_67)) > p_68))
    { /* block id: 57 */
        union U1 l_198 = {0x9CDF};
        p_68 ^= ((uint16_t)l_187.f0 - (uint16_t)(func_72((((uint16_t)((uint16_t)__builtin_clz(l_188.f0) * (uint16_t)((uint16_t)p_70 % (uint16_t)p_69)) << (uint16_t)l_188.f1) != func_72(p_69, l_198)), l_198) || p_69));
        for (p_67 = 0; (p_67 < 7); p_67 += 4)
        { /* block id: 61 */
            struct S0 l_201 = {283,1};
            return l_201;
        }
        l_188.f1 = p_70;
    }
    else
    { /* block id: 65 */
        uint16_t l_204 = 1U;
        p_68 = ((uint32_t)l_204 % (uint32_t)((int16_t)((func_80(l_187, l_188, p_70, l_204, p_70) > ((((((int16_t)(7U >= ((uint16_t)(p_67 < p_70) << (uint16_t)13)) + (int16_t)p_68) & l_204) && 0U) < l_187.f0) && (-7))) & 1U) << (int16_t)p_70));
    }
    p_68 ^= p_70;
    return l_188;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_72(uint32_t  p_73, union U1  p_74)
{ /* block id: 40 */
    union U1 l_89 = {0x470E};
    struct S0 l_90 = {289,1};
    int32_t l_102 = 0x086CC6B0;
    int32_t l_103 = 0;
    int32_t l_104 = (-1);
    int32_t l_105 = 0x822C3E50;
    int32_t l_106 = 0x2DE1722B;
    int32_t l_107 = (-7);
    int32_t l_108 = (-9);
    int32_t l_109 = 0x9FA00A4E;
    int32_t l_110 = (-8);
    int32_t l_111 = 0xD1334807;
    int32_t l_112 = 0xFD26F361;
    int32_t l_113 = 0xFA70DAEE;
    int32_t l_114 = 0x9E4C0C5D;
    int32_t l_115 = (-10);
    int32_t l_116 = 0x4D501105;
    int32_t l_117 = 0x7E287B83;
    int32_t l_118 = 0x4AE77DDB;
    int32_t l_119 = 0xE81D84CB;
    int32_t l_120 = 0x99115BA0;
    int32_t l_121 = (-2);
    int32_t l_122 = 1;
    int32_t l_123 = 0x7BB92158;
    int32_t l_124 = 0x2A96A4AF;
    int32_t l_125 = 0x7EF5E135;
    int32_t l_126 = (-9);
    int32_t l_127 = 1;
    int32_t l_128 = 7;
    int32_t l_129 = 1;
    int32_t l_130 = 0x381B91F4;
    int32_t l_131 = 0x258348F9;
    int32_t l_132 = (-7);
    int32_t l_133 = 1;
    int32_t l_134 = (-1);
    int32_t l_135 = 0xAEF9AD35;
    int32_t l_136 = 0x6E08938C;
    int32_t l_137 = 1;
    int32_t l_138 = 0x34E2D8D8;
    int32_t l_139 = 0x8B64E3C6;
    int32_t l_140 = 5;
    int32_t l_141 = 0x9BDD3DE9;
    int32_t l_142 = (-6);
    int32_t l_143 = (-2);
    int32_t l_144 = 1;
    int32_t l_145 = (-1);
    int32_t l_146 = 0;
    int32_t l_147 = 0x4BE07DEC;
    int32_t l_148 = 0xF18CA9A6;
    int32_t l_149 = 0;
    int32_t l_150 = 4;
    int32_t l_151 = (-1);
    int32_t l_152 = 1;
    int32_t l_153 = (-1);
    int32_t l_154 = 0x66DF6EF7;
    int32_t l_155 = 0xE20A5F0D;
    int32_t l_156 = 0xCF7F8006;
    int32_t l_157 = (-4);
    int32_t l_158 = (-3);
    int32_t l_159 = 0x14660508;
    int32_t l_160 = 0x68EE181C;
    int32_t l_161 = 0x547896B8;
    int32_t l_162 = 0x5DEAEDAB;
    int32_t l_163 = 1;
    int32_t l_164 = 0xABFABC74;
    int32_t l_165 = 0xEC161236;
    int32_t l_166 = 0x95055D0C;
    int32_t l_167 = 0xC7269306;
    int32_t l_168 = 6;
    int32_t l_169 = 0xCAA3977A;
    int32_t l_170 = (-10);
    int32_t l_171 = 1;
    int32_t l_172 = 0x97626F05;
    int32_t l_173 = 0x1D28FF55;
    int32_t l_174 = 0xDB6E2759;
    int32_t l_175 = 0x7FEFA8C4;
    int32_t l_176 = 0;
    int32_t l_177 = 1;
    uint16_t l_178 = 0U;
    if (func_80(l_89, l_90, p_73, p_73, (((+((int16_t)p_74.f0 >> (int16_t)15)) == 0x4275) <= p_73)))
    { /* block id: 41 */
        int16_t l_97 = 0xFC7B;
        int32_t l_98 = 0xF6F8F643;
        l_90.f1 &= ((-1) && l_89.f0);
        for (p_74.f0 = 22; (p_74.f0 >= 15); p_74.f0 -= 1)
        { /* block id: 45 */
            l_98 = ((+p_74.f0) <= l_97);
        }
    }
    else
    { /* block id: 48 */
        uint32_t l_100 = 0x7029BB2D;
        int32_t l_101 = 0x1BF39352;
        l_90.f1 |= ((!l_89.f0) > p_73);
        l_101 = l_100;
    }
    l_90 = l_90;
    l_90 = l_90;
    l_178++;
    return l_105;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_80(union U1  p_81, struct S0  p_82, int32_t  p_83, int32_t  p_84, uint16_t  p_85)
{ /* block id: 38 */
    uint32_t l_88 = 0xC82F3C07;
    return l_88;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 297
   depth: 1, occurrence: 36
XXX total union variables: 18

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 36
breakdown:
   indirect level: 0, occurrence: 36
XXX full-bitfields structs in the program: 36
breakdown:
   indirect level: 0, occurrence: 36
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 20
XXX times a bitfields struct on RHS: 51
XXX times a single bitfield on LHS: 21
XXX times a single bitfield on RHS: 71

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 219
   depth: 2, occurrence: 45
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 5
   depth: 9, occurrence: 3
   depth: 10, occurrence: 2
   depth: 11, occurrence: 4
   depth: 12, occurrence: 3
   depth: 13, occurrence: 7
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 18, occurrence: 4
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 746
XXX times a non-volatile is write: 150
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 210
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 33
   depth: 2, occurrence: 38
   depth: 3, occurrence: 31
   depth: 4, occurrence: 37
   depth: 5, occurrence: 43

XXX percentage a fresh-made variable is used: 31.9
XXX percentage an existing variable is used: 68.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

