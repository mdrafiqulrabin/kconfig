/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3207169406
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 13;
   int32_t  f1;
   signed f2 : 22;
   signed : 0;
   signed f3 : 5;
   unsigned f4 : 29;
};

struct S1 {
   int8_t  f0;
   const int32_t  f1;
   int32_t  f2;
   int16_t  f3;
   uint8_t  f4;
   struct S0  f5;
   uint32_t  f6;
   const float  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_1(void);
static float  func_6(uint32_t  p_7, struct S0  p_8);
static int32_t * func_11(struct S0  p_12, const float  p_13, int16_t  p_14, uint64_t  p_15);
inline static uint32_t  func_17(int32_t * p_18, int32_t * p_19, uint64_t  p_20);
static int32_t * func_21(uint16_t  p_22, int32_t * p_23);
inline static int32_t * func_24(int32_t  p_25, int32_t * p_26);
static int32_t  func_31(int32_t * p_32, int32_t * p_33);
static int32_t * func_34(int32_t  p_35, int8_t  p_36, int32_t * p_37);
static uint16_t  func_38(uint8_t  p_39);
static int16_t  func_44(const int32_t * const  p_45);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_1(void)
{ /* block id: 0 */
    int16_t l_9 = 0L;
    struct S0 l_10[3] = {{-4,4L,1548,4,11466},{-4,4L,1548,4,11466},{-4,4L,1548,4,11466}};
    uint8_t l_1777 = 6UL;
    uint32_t l_1778 = 18446744073709551613UL;
    float l_1780 = 0x1.540055p+10;
    float *l_1779[5];
    int32_t l_1786 = (-7L);
    int32_t *l_1785 = &l_1786;
    struct S1 l_1804 = {0x83L,0xF164F1A7L,0x58B88DEAL,1L,0x3EL,{12,8L,-884,1,17878},0xE77B4C8BL,0x0.8p+1};
    struct S1 * const l_1803[1][10] = {{(void*)0,&l_1804,(void*)0,&l_1804,&l_1804,(void*)0,&l_1804,(void*)0,&l_1804,&l_1804}};
    struct S1 * const *l_1802 = &l_1803[0][5];
    struct S1 * const **l_1801 = &l_1802;
    struct S1 * const ***l_1800[2];
    struct S1 * const ****l_1799 = &l_1800[0];
    int32_t *l_1805 = (void*)0;
    struct S1 *****l_1849 = (void*)0;
    const struct S0 *l_1855[1];
    const struct S0 **l_1854[8][1][4] = {{{&l_1855[0],&l_1855[0],(void*)0,&l_1855[0]}},{{&l_1855[0],(void*)0,&l_1855[0],(void*)0}},{{&l_1855[0],(void*)0,(void*)0,&l_1855[0]}},{{(void*)0,&l_1855[0],&l_1855[0],&l_1855[0]}},{{(void*)0,&l_1855[0],(void*)0,&l_1855[0]}},{{&l_1855[0],&l_1855[0],&l_1855[0],&l_1855[0]}},{{&l_1855[0],&l_1855[0],(void*)0,&l_1855[0]}},{{&l_1855[0],&l_1855[0],(void*)0,&l_1855[0]}}};
    const struct S0 ***l_1853[4] = {&l_1854[2][0][2],&l_1854[2][0][2],&l_1854[2][0][2],&l_1854[2][0][2]};
    const struct S0 ****l_1852 = &l_1853[3];
    uint64_t l_1886[1];
    uint16_t l_1900 = 6UL;
    int32_t l_1910 = 0x2F3CB41DL;
    uint32_t l_1949 = 1UL;
    int32_t **l_1951 = (void*)0;
    int32_t **l_1952 = (void*)0;
    int32_t **l_1953 = &l_1805;
    struct S0 l_1954 = {-51,-5L,-1383,-0,7129};
    int i, j, k;
    for (i = 0; i < 5; i++)
        l_1779[i] = &l_1780;
    for (i = 0; i < 2; i++)
        l_1800[i] = &l_1801;
    for (i = 0; i < 1; i++)
        l_1855[i] = &l_1804.f5;
    for (i = 0; i < 1; i++)
        l_1886[i] = 0x7CC9B895BCAF930ELL;
    l_10[0].f2 = (safe_add_func_float_f_f(((((safe_div_func_float_f_f(func_6(l_9, l_10[0]), 0x3.E1D78Cp-13)) >= (!((safe_add_func_float_f_f(((l_10[0].f3 > (safe_sub_func_float_f_f((safe_sub_func_float_f_f((0xC.9BF7F8p+69 == (((safe_div_func_float_f_f(l_10[0].f0, (safe_div_func_float_f_f((0xA.138124p-45 <= l_10[0].f2), l_9)))) > (-0x1.Ap-1)) <= l_9)), l_1777)), 0x3.DB85C6p+76))) != l_10[0].f4), l_9)) == 0xF.06628Ap-73))) <= l_10[0].f0) > l_1778), l_10[0].f0));
    for (l_9 = 14; (l_9 != 18); ++l_9)
    { /* block id: 948 */
        int64_t l_1788 = 1L;
        uint32_t l_1798[1][10][2] = {{{0x4D8C251BL,0UL},{18446744073709551611UL,18446744073709551611UL},{0UL,0x4D8C251BL},{0x1A8BF73DL,0x4D8C251BL},{0UL,18446744073709551611UL},{18446744073709551611UL,0UL},{0x4D8C251BL,0x1A8BF73DL},{0x4D8C251BL,0UL},{18446744073709551611UL,18446744073709551611UL},{0UL,0x4D8C251BL}}};
        const struct S1 *l_1824 = &l_1804;
        const struct S1 **l_1823 = &l_1824;
        uint32_t l_1871 = 0xB9DD785DL;
        struct S0 *l_1893 = &l_10[2];
        struct S0 **l_1892 = &l_1893;
        int32_t **** const *l_1894 = (void*)0;
        uint8_t l_1950[2];
        int i, j, k;
        for (i = 0; i < 2; i++)
            l_1950[i] = 249UL;
    }
    (*l_1953) = &l_1910;
    /* statement id: 1061 */
    assert (l_1805 == &l_1910);
    return l_1954;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_6(uint32_t  p_7, struct S0  p_8)
{ /* block id: 1 */
    struct S0 l_16 = {11,0x00457023L,471,0,9462};
    const int32_t l_47[8][2] = {{0x11E8E103L,9L},{0x11E8E103L,9L},{0x11E8E103L,9L},{0x11E8E103L,9L},{0x11E8E103L,9L},{0x11E8E103L,9L},{0x11E8E103L,9L},{0x11E8E103L,9L}};
    const int32_t * const l_46[7] = {&l_47[4][0],&l_47[4][0],&l_47[4][0],&l_47[4][0],&l_47[4][0],&l_47[4][0],&l_47[4][0]};
    int32_t l_60[9][9][3] = {{{0x3775ED14L,(-2L),0L},{(-1L),0xCD35A08CL,0x41A78517L},{8L,0x5799F9A5L,0L},{0x3AC07AC3L,(-3L),(-5L)},{0x87E9A86FL,0L,2L},{(-1L),(-3L),0x8AA3AE43L},{(-4L),0x5799F9A5L,0x6AB569F1L},{1L,0xCD35A08CL,(-5L)},{(-4L),(-2L),(-2L)}},{{(-1L),1L,0x41A78517L},{0x87E9A86FL,0x5799F9A5L,(-2L)},{0x3AC07AC3L,0x5AD8B3B4L,(-5L)},{8L,0L,0x6AB569F1L},{(-1L),0x5AD8B3B4L,0x8AA3AE43L},{0x3775ED14L,0x5799F9A5L,2L},{1L,1L,(-5L)},{0x3775ED14L,(-2L),0L},{(-1L),0xCD35A08CL,0x41A78517L}},{{8L,0x5799F9A5L,0L},{0x3AC07AC3L,(-3L),(-5L)},{0x87E9A86FL,0L,2L},{(-1L),(-3L),0x8AA3AE43L},{(-4L),0x5799F9A5L,0x6AB569F1L},{1L,0xCD35A08CL,(-5L)},{(-4L),(-2L),(-2L)},{(-1L),1L,0x41A78517L},{0x87E9A86FL,0x5799F9A5L,(-2L)}},{{0x3AC07AC3L,0x5AD8B3B4L,(-5L)},{8L,0L,0x6AB569F1L},{(-1L),0x5AD8B3B4L,0x8AA3AE43L},{0x3775ED14L,0x5799F9A5L,2L},{1L,1L,(-5L)},{0x3775ED14L,(-2L),0L},{(-1L),0xCD35A08CL,0x41A78517L},{8L,0x5799F9A5L,0L},{0x3AC07AC3L,(-3L),(-5L)}},{{0x87E9A86FL,0L,2L},{(-1L),(-3L),0x8AA3AE43L},{(-4L),0x5799F9A5L,0x6AB569F1L},{1L,0xCD35A08CL,(-5L)},{(-4L),(-2L),(-2L)},{(-1L),1L,0x41A78517L},{0x87E9A86FL,0x5799F9A5L,(-2L)},{0x3AC07AC3L,0x5AD8B3B4L,(-5L)},{8L,0L,0x6AB569F1L}},{{(-1L),0x5AD8B3B4L,0x8AA3AE43L},{0x3775ED14L,0x5799F9A5L,2L},{1L,1L,(-5L)},{0x3775ED14L,0xB68B63C9L,0xA84720AFL},{0x2C1C4229L,0x0C68D18EL,0x4ADD7D53L},{0x81B62C3DL,0L,0xA84720AFL},{(-5L),0x15DB8BE4L,0xF2C75BC6L},{(-1L),0xA84720AFL,0x5E333AB1L},{0x2C1C4229L,0x15DB8BE4L,0L}},{{(-1L),0L,(-1L)},{(-1L),0x0C68D18EL,0xF2C75BC6L},{(-1L),0xB68B63C9L,0xB68B63C9L},{0x2C1C4229L,0x4AAD4D87L,0x4ADD7D53L},{(-1L),0L,0xB68B63C9L},{(-5L),(-1L),0xF2C75BC6L},{0x81B62C3DL,0xA84720AFL,(-1L)},{0x2C1C4229L,(-1L),0L},{0x5799F9A5L,0L,0x5E333AB1L}},{{(-1L),0x4AAD4D87L,0xF2C75BC6L},{0x5799F9A5L,0xB68B63C9L,0xA84720AFL},{0x2C1C4229L,0x0C68D18EL,0x4ADD7D53L},{0x81B62C3DL,0L,0xA84720AFL},{(-5L),0x15DB8BE4L,0xF2C75BC6L},{(-1L),0xA84720AFL,0x5E333AB1L},{0x2C1C4229L,0x15DB8BE4L,0L},{(-1L),0L,(-1L)},{(-1L),0x0C68D18EL,0xF2C75BC6L}},{{(-1L),0xB68B63C9L,0xB68B63C9L},{0x2C1C4229L,0x4AAD4D87L,0x4ADD7D53L},{(-1L),0L,0xB68B63C9L},{(-5L),(-1L),0xF2C75BC6L},{0x81B62C3DL,0xA84720AFL,(-1L)},{0x2C1C4229L,(-1L),0L},{0x5799F9A5L,0L,0x5E333AB1L},{(-1L),0x4AAD4D87L,0xF2C75BC6L},{0x5799F9A5L,0xB68B63C9L,0xA84720AFL}}};
    int32_t *l_59 = &l_60[6][5][2];
    int32_t *l_81 = &l_60[6][5][2];
    int32_t **l_1755 = &l_59;
    int32_t ***l_1760 = &l_1755;
    int32_t ****l_1759[7] = {&l_1760,&l_1760,&l_1760,&l_1760,&l_1760,&l_1760,&l_1760};
    int32_t *****l_1758 = &l_1759[2];
    struct S0 *l_1763[3];
    struct S0 **l_1762[1][2][7] = {{{&l_1763[2],(void*)0,&l_1763[2],&l_1763[2],(void*)0,&l_1763[2],&l_1763[2]},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}}};
    float l_1765 = 0x5.DCE3A2p-92;
    float *l_1764 = &l_1765;
    int i, j, k;
    for (i = 0; i < 3; i++)
        l_1763[i] = &l_16;
    (*l_1755) = func_11(l_16, l_16.f0, p_8.f4, (func_17(func_21(l_16.f1, func_24((safe_rshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s((-1L), func_31(func_34((func_38(p_7) != ((0x9E84L | func_44(l_46[0])) <= p_7)), p_8.f1, l_59), l_81))), 13)), l_81)), l_59, p_8.f2) && (-1L)));
    /* statement id: 941 */
    assert (l_59 == 0);
    (*l_1764) = (safe_sub_func_float_f_f((l_1758 == &l_1759[1]), (-(l_1762[0][1][6] != (void*)0))));
    (*l_81) = p_8.f0;
    return p_7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_11(struct S0  p_12, const float  p_13, int16_t  p_14, uint64_t  p_15)
{ /* block id: 645 */
    struct S1 l_1166[4][6] = {{{-3L,0xAAB2319DL,0L,0x4E31L,8UL,{27,-10L,-664,-1,12581},0x2F86BD53L,0x4.21E532p+68},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{-1L,0x2F3CD3D6L,0L,0L,1UL,{-18,6L,1585,-3,18506},7UL,0x1.4p+1},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{-3L,0xAAB2319DL,0L,0x4E31L,8UL,{27,-10L,-664,-1,12581},0x2F86BD53L,0x4.21E532p+68},{-3L,0xAAB2319DL,0L,0x4E31L,8UL,{27,-10L,-664,-1,12581},0x2F86BD53L,0x4.21E532p+68}},{{0x9AL,1L,0x9B7ED56DL,0L,6UL,{-16,0L,523,-4,4329},0x35BF33B2L,0x1.0p+1},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{0x9AL,1L,0x9B7ED56DL,0L,6UL,{-16,0L,523,-4,4329},0x35BF33B2L,0x1.0p+1},{0xC7L,0xB40D3D28L,0x925D86A7L,0xC681L,1UL,{56,0x9E5B5684L,-553,4,6157},4294967286UL,0xC.F25A76p-96},{0x9AL,1L,0x9B7ED56DL,0L,6UL,{-16,0L,523,-4,4329},0x35BF33B2L,0x1.0p+1}},{{0x9AL,1L,0x9B7ED56DL,0L,6UL,{-16,0L,523,-4,4329},0x35BF33B2L,0x1.0p+1},{0xC7L,0xB40D3D28L,0x925D86A7L,0xC681L,1UL,{56,0x9E5B5684L,-553,4,6157},4294967286UL,0xC.F25A76p-96},{0x9AL,1L,0x9B7ED56DL,0L,6UL,{-16,0L,523,-4,4329},0x35BF33B2L,0x1.0p+1},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{0x9AL,1L,0x9B7ED56DL,0L,6UL,{-16,0L,523,-4,4329},0x35BF33B2L,0x1.0p+1}},{{-3L,0xAAB2319DL,0L,0x4E31L,8UL,{27,-10L,-664,-1,12581},0x2F86BD53L,0x4.21E532p+68},{-3L,0xAAB2319DL,0L,0x4E31L,8UL,{27,-10L,-664,-1,12581},0x2F86BD53L,0x4.21E532p+68},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{-1L,0x2F3CD3D6L,0L,0L,1UL,{-18,6L,1585,-3,18506},7UL,0x1.4p+1},{2L,1L,4L,0L,7UL,{85,0x04BF44D0L,-612,-2,19427},1UL,0x6.EEE4F5p-91},{-3L,0xAAB2319DL,0L,0x4E31L,8UL,{27,-10L,-664,-1,12581},0x2F86BD53L,0x4.21E532p+68}}};
    struct S1 *l_1165 = &l_1166[2][3];
    float l_1174 = 0x8.917866p+5;
    float *l_1173 = &l_1174;
    int32_t * const l_1180 = &l_1166[2][3].f2;
    struct S0 *l_1181 = &l_1166[2][3].f5;
    struct S0 **l_1207[7];
    struct S0 ***l_1206 = &l_1207[6];
    int32_t ***l_1224 = (void*)0;
    int32_t **** const l_1223 = &l_1224;
    int32_t **** const *l_1222 = &l_1223;
    int32_t *l_1355 = &l_1166[2][3].f2;
    int32_t *l_1399[6] = {&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2};
    int32_t *l_1401 = &l_1166[2][3].f2;
    struct S1 **l_1406 = (void*)0;
    struct S1 ***l_1405 = &l_1406;
    struct S1 ****l_1414[6][6][5] = {{{&l_1405,&l_1405,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405}},{{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,(void*)0}},{{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,(void*)0,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405}},{{(void*)0,&l_1405,&l_1405,(void*)0,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,(void*)0,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405}},{{&l_1405,(void*)0,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,(void*)0,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,(void*)0,&l_1405,&l_1405,&l_1405},{&l_1405,(void*)0,&l_1405,&l_1405,&l_1405}},{{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405},{&l_1405,(void*)0,&l_1405,&l_1405,&l_1405},{(void*)0,&l_1405,&l_1405,&l_1405,(void*)0},{&l_1405,&l_1405,&l_1405,&l_1405,&l_1405}}};
    struct S1 *****l_1413[6];
    int32_t **** const l_1434 = &l_1224;
    uint32_t l_1467 = 0x3B519FC7L;
    int32_t *l_1518 = &l_1166[2][3].f2;
    int32_t *l_1521 = &l_1166[2][3].f2;
    int32_t *l_1523 = &l_1166[2][3].f2;
    int32_t *l_1526 = (void*)0;
    int32_t *l_1570[4][1] = {{(void*)0},{&l_1166[2][3].f2},{(void*)0},{&l_1166[2][3].f2}};
    int32_t *l_1573 = &l_1166[2][3].f2;
    int32_t *l_1574[10][10] = {{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,(void*)0,(void*)0,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2},{&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,(void*)0,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2,&l_1166[2][3].f2}};
    struct S1 ** const l_1604 = &l_1165;
    struct S1 ** const *l_1606 = (void*)0;
    struct S1 ** const **l_1605[6][4][3] = {{{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606}},{{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606}},{{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606}},{{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606}},{{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606}},{{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606},{&l_1606,&l_1606,&l_1606}}};
    int16_t l_1610[8][10] = {{0x5B73L,0x1DD2L,7L,7L,0x1DD2L,0x5B73L,8L,0xC9A5L,0x57EEL,0L},{1L,0L,0L,4L,0xC9A5L,4L,0L,0L,1L,0x5B73L},{1L,7L,0xF09AL,8L,4L,0x5B73L,0x5B73L,4L,8L,0xF09AL},{0x5B73L,0x5B73L,4L,8L,0xF09AL,7L,1L,0L,1L,7L},{0L,4L,0xC9A5L,4L,0L,0L,1L,0x5B73L,0x57EEL,0x57EEL},{8L,0x5B73L,0x1DD2L,7L,7L,0x1DD2L,0x5B73L,8L,0xC9A5L,0x57EEL},{0L,7L,0x5B73L,(-1L),0L,1L,0L,0L,4L,0x1DD2L},{0x57EEL,0xF09AL,4L,7L,0xC9A5L,0L,(-1L),(-1L),0L,0xC9A5L}};
    uint64_t l_1666 = 2UL;
    int i, j, k;
    for (i = 0; i < 7; i++)
        l_1207[i] = &l_1181;
    for (i = 0; i < 6; i++)
        l_1413[i] = &l_1414[0][3][2];
    (*l_1173) = (((safe_div_func_float_f_f((-((void*)0 != l_1165)), p_14)) < (((l_1166[2][3].f4 > l_1166[2][3].f5.f2) != (l_1166[2][3].f5.f3 != (((safe_div_func_float_f_f(((0x1.375098p+5 == (((safe_div_func_float_f_f(0xC.88CE5Ep+34, (safe_add_func_float_f_f(0x6.5D4BD0p+39, l_1166[2][3].f5.f1)))) != p_12.f1) == (-0x6.1p-1))) != l_1166[2][3].f0), 0x0.05F18Bp-33)) < l_1166[2][3].f4) >= l_1166[2][3].f3))) >= 0x0.Fp+1)) <= p_12.f3);
    return l_1526;
    /* statement id: 940 */
    //assert (func_11_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_17(int32_t * p_18, int32_t * p_19, uint64_t  p_20)
{ /* block id: 236 */
    int8_t l_502 = 0xE0L;
    int32_t l_520 = (-7L);
    uint64_t l_523[1];
    const int32_t *l_550 = &l_520;
    int32_t *l_560 = &l_520;
    int32_t **l_559 = &l_560;
    int32_t ***l_558 = &l_559;
    int32_t ****l_557 = &l_558;
    int32_t l_584 = (-1L);
    struct S1 l_670[6] = {{0x55L,0x34D4D672L,0xFBCA9A83L,0L,0x19L,{51,0x7180E244L,490,4,14346},0x92AC536DL,0x6.EBE8A9p-53},{0x5AL,-9L,-3L,7L,251UL,{44,9L,1953,1,10925},4294967291UL,0x5.78A6A4p-25},{0x55L,0x34D4D672L,0xFBCA9A83L,0L,0x19L,{51,0x7180E244L,490,4,14346},0x92AC536DL,0x6.EBE8A9p-53},{0x55L,0x34D4D672L,0xFBCA9A83L,0L,0x19L,{51,0x7180E244L,490,4,14346},0x92AC536DL,0x6.EBE8A9p-53},{0x5AL,-9L,-3L,7L,251UL,{44,9L,1953,1,10925},4294967291UL,0x5.78A6A4p-25},{0x55L,0x34D4D672L,0xFBCA9A83L,0L,0x19L,{51,0x7180E244L,490,4,14346},0x92AC536DL,0x6.EBE8A9p-53}};
    struct S1 *l_669 = &l_670[5];
    struct S1 **l_668 = &l_669;
    const struct S0 *l_678 = (void*)0;
    const int32_t **** const *l_684 = (void*)0;
    int16_t l_704 = 0L;
    struct S1 ***l_840 = &l_668;
    struct S1 *** const *l_839[3];
    int i;
    for (i = 0; i < 1; i++)
        l_523[i] = 18446744073709551606UL;
    for (i = 0; i < 3; i++)
        l_839[i] = &l_840;
lbl_580:
    (*p_19) = (safe_lshift_func_int16_t_s_s((safe_add_func_uint8_t_u_u((((safe_div_func_int8_t_s_s(((safe_sub_func_int16_t_s_s((safe_div_func_uint64_t_u_u((((*p_19) && (3L ^ (safe_add_func_int32_t_s_s(((safe_sub_func_int16_t_s_s(l_502, (safe_rshift_func_uint8_t_u_s(p_20, ((*p_19) ^ 2L))))) <= p_20), l_502)))) ^ ((0x213FEFA52EACE01CLL & p_20) > 0xAE3AL)), p_20)), l_502)) ^ l_502), p_20)) <= 65535UL) != 0x8ADB94A2503CB891LL), p_20)), 12));
    if (((~p_20) >= (safe_add_func_int32_t_s_s(l_502, ((l_502 && (safe_mod_func_int16_t_s_s(p_20, ((((l_502 & 1UL) & (((safe_sub_func_int8_t_s_s((safe_add_func_uint16_t_u_u(((safe_mod_func_int64_t_s_s(p_20, 0x66BDF84D0554B130LL)) < (safe_div_func_int32_t_s_s((safe_mod_func_int16_t_s_s(p_20, 0xCF83L)), 7UL))), p_20)), 255UL)) <= l_520) > 0xA8L)) || 3UL) || 0xA745L)))) && p_20)))))
    { /* block id: 238 */
        int16_t l_533 = 0x1EE3L;
        uint16_t l_573 = 0x9347L;
        struct S0 l_585 = {-66,0xA061AEBBL,1840,3,4226};
        for (p_20 = (-6); (p_20 == 17); ++p_20)
        { /* block id: 241 */
            uint32_t l_528[10] = {18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL};
            int32_t *l_553 = &l_520;
            int16_t l_574[3][6] = {{0x73DFL,0x73DFL,0x73DFL,0x73DFL,0x73DFL,0x73DFL},{0x73DFL,0x73DFL,0x73DFL,0x73DFL,0x73DFL,0x73DFL},{0x73DFL,0x73DFL,0x73DFL,0x73DFL,0x73DFL,0x73DFL}};
            int8_t l_575[4] = {2L,2L,2L,2L};
            struct S1 ***l_577 = (void*)0;
            int i, j;
            for (l_502 = 0; (l_502 <= 0); l_502 += 1)
            { /* block id: 244 */
                int32_t *l_525 = &l_520;
                int32_t **l_524 = &l_525;
                struct S0 l_537 = {76,8L,1395,3,17969};
                int i;
                (*l_524) = p_19;
                /* statement id: 245 */
                //assert ((l_525 >= &l_60[0][0][0] && l_525 <= &l_60[8][8][2]));
                if (((l_523[l_502] > ((p_20 ^ (safe_rshift_func_int8_t_s_u(((0x04736130EB746EEELL < p_20) == l_528[7]), (p_20 >= (safe_div_func_int64_t_s_s((safe_rshift_func_int8_t_s_s((-1L), p_20)), p_20)))))) & l_533)) ^ (*l_525)))
                { /* block id: 246 */
                    struct S0 *l_538 = &l_537;
                    for (l_520 = 0; (l_520 >= 0); l_520 -= 1)
                    { /* block id: 249 */
                        struct S1 l_535 = {1L,0L,-6L,0x303AL,0x4FL,{-2,1L,-662,-4,19179},0x657BC51AL,0xC.26C140p+41};
                        struct S1 *l_534 = &l_535;
                        struct S1 **l_536 = &l_534;
                        (*l_536) = l_534;
                        return l_528[7];
                    }
                    (*l_538) = l_537;
                    (*l_524) = p_19;
                }
                else
                { /* block id: 255 */
                    int32_t l_556 = (-1L);
                    for (l_533 = 2; (l_533 <= 9); l_533 += 1)
                    { /* block id: 258 */
                        int32_t *l_539 = &l_520;
                        int i;
                        (*l_524) = func_21(l_523[l_502], l_539);
                        /* statement id: 259 */
                        assert (l_525 == &l_520);
                        (**l_524) = ((safe_mod_func_uint32_t_u_u(((((safe_sub_func_uint32_t_u_u((((safe_div_func_uint16_t_u_u(l_523[l_502], (safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s((l_550 == p_19), 7)), ((safe_lshift_func_uint16_t_u_s((((void*)0 != l_553) || (safe_add_func_uint16_t_u_u(l_523[l_502], l_556))), (4L & p_20))) & p_20))))) == p_20) & 247UL), (*p_19))) == 4294967294UL) & l_556) || l_533), (*p_19))) != p_20);
                    }
                    /* facts after for loop */
                    //assert (l_525 == &l_520 || (l_525 >= &l_60[0][0][0] && l_525 <= &l_60[8][8][2]));
                }
                /* facts after branching */
                //assert (l_525 == &l_520 || (l_525 >= &l_60[0][0][0] && l_525 <= &l_60[8][8][2]));
                if (l_575[2])
                { /* block id: 264 */
                    for (l_520 = 0; (l_520 <= 0); l_520 += 1)
                    { /* block id: 267 */
                        uint16_t l_576 = 65535UL;
                        l_576 = 1L;
                    }
                }
                else
                { /* block id: 270 */
                    struct S1 ****l_578 = &l_577;
                    (*l_559) = p_19;
                    /* statement id: 271 */
                    //assert ((l_560 >= &l_60[0][0][0] && l_560 <= &l_60[8][8][2]));
                    (*l_578) = l_577;
                }
                for (l_537.f1 = 0; (l_537.f1 >= 0); l_537.f1 -= 1)
                { /* block id: 276 */
                    int64_t l_579 = 0x1F3662B9F71369ECLL;
                    int32_t *l_581 = &l_520;
                    if (l_579)
                    { /* block id: 277 */
                        if ((*p_19))
                            break;
                        if (l_537.f1)
                            goto lbl_580;
                    }
                    else
                    { /* block id: 280 */
                        int32_t l_582[7] = {0x15C9F554L,0x15C9F554L,0x15C9F554L,0x15C9F554L,0x15C9F554L,0x15C9F554L,0x15C9F554L};
                        int i;
                        (*l_524) = l_581;
                        /* statement id: 281 */
                        assert (l_525 == &l_520);
                        if (l_582[2])
                            break;
                        if (l_573)
                            continue;
                    }
                    for (l_579 = 0; (l_579 <= 0); l_579 += 1)
                    { /* block id: 287 */
                        int i, j;
                        (**l_559) = l_574[(l_579 + 1)][(l_537.f1 + 5)];
                    }
                    for (l_520 = 0; (l_520 <= 0); l_520 += 1)
                    { /* block id: 292 */
                        int64_t l_583 = 0xEE9452A1EE547531LL;
                        struct S0 *l_586 = &l_585;
                        (**l_558) = func_34(l_583, l_584, p_19);
                        /* statement id: 293 */
                        //assert ((l_560 >= &l_60[0][0][0] && l_560 <= &l_60[8][8][2]));
                        (*l_586) = l_585;
                        (*l_586) = (*l_586);
                    }
                }
            }
        }
    }
    else
    { /* block id: 300 */
        uint32_t l_605 = 1UL;
        int32_t *l_606 = &l_520;
        l_606 = func_24(((((safe_sub_func_int32_t_s_s(((safe_rshift_func_int8_t_s_u((((((safe_sub_func_int32_t_s_s((safe_div_func_uint8_t_u_u(((void*)0 == l_560), (safe_rshift_func_int16_t_s_u(p_20, ((safe_div_func_uint16_t_u_u(p_20, (*l_550))) || (safe_mod_func_int16_t_s_s((p_20 || (((safe_mod_func_uint8_t_u_u(((safe_mod_func_int16_t_s_s(p_20, p_20)) == (*l_550)), p_20)) >= p_20) > (*l_560))), 0xF9FAL))))))), l_605)) > p_20) | 0UL) || 0x9AA23FD6L) >= p_20), 6)) >= l_605), l_605)) >= p_20) <= (*l_560)) <= (**l_559)), p_18);
        /* statement id: 301 */
        assert (l_606 == 0);
        return p_20;
    }
    if ((*p_19))
    { /* block id: 304 */
        float l_608 = (-0x2.Fp-1);
        float *l_607 = &l_608;
        int32_t l_613 = 0x6ABB6672L;
        int32_t l_627 = (-1L);
        int32_t ***** const l_685[2][10] = {{&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557},{&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557,&l_557}};
        int i, j;
    }
    else
    { /* block id: 366 */
        int32_t **l_700[7];
        struct S0 *l_703 = &l_670[5].f5;
        float l_773[4][7][3] = {{{(-0x2.Fp+1),0xC.750D5Dp-68,0x0.Fp-1},{(-0x3.4p+1),(-0x7.5p-1),0x0.B2D842p+97},{(-0x7.5p-1),0xB.6C2A29p+76,(-0x3.8p+1)},{(-0x7.5p-1),0xE.C7FB8Fp-9,(-0x2.Fp+1)},{(-0x3.4p+1),(-0x3.4p+1),0x8.6p+1},{(-0x2.Fp+1),(-0x10.Fp+1),0x3.4BEA50p+48},{0x1.9p+1,0x1.1F6FFBp+52,0x4.Fp+1}},{{0xE.C7FB8Fp-9,0x4.Fp+1,0x0.4p-1},{0x8.6p+1,0x1.9p+1,0x4.Fp+1},{0x4.1p-1,(-0x6.8p+1),0x3.4BEA50p+48},{0x3.4BEA50p+48,0xD.D670ECp-90,0x8.6p+1},{0x0.Cp+1,0x3.4BEA50p+48,(-0x2.Fp+1)},{0x3.Fp-1,(-0x9.Dp+1),(-0x3.8p+1)},{(-0x10.Fp+1),(-0x9.Dp+1),0x0.B2D842p+97}},{{0x0.Fp-1,0x3.4BEA50p+48,0x0.Fp-1},{0x1.Fp-1,0xD.D670ECp-90,(-0x9.Dp+1)},{0x3.2p+1,(-0x6.8p+1),0xB.6C2A29p+76},{0xC.750D5Dp-68,0x1.9p+1,0x3.Fp-1},{(-0x9.Dp+1),0x4.Fp+1,0x0.8p-1},{0xC.750D5Dp-68,0x1.1F6FFBp+52,0x0.Cp+1},{0x3.2p+1,(-0x10.Fp+1),(-0x6.8p+1)}},{{0x1.Fp-1,(-0x3.4p+1),(-0x7.5p-1)},{0x0.Fp-1,0xE.C7FB8Fp-9,0xD.D670ECp-90},{(-0x10.Fp+1),0xB.6C2A29p+76,0xD.D670ECp-90},{0x3.Fp-1,(-0x7.5p-1),(-0x7.5p-1)},{0x0.Cp+1,0xC.750D5Dp-68,(-0x6.8p+1)},{0x3.4BEA50p+48,0x1.CB4D8Dp-2,0x0.Cp+1},{0x4.1p-1,0xE.806607p-61,0x0.8p-1}}};
        float *l_772 = &l_773[2][5][0];
        int16_t l_775 = (-8L);
        int32_t l_847 = (-4L);
        struct S0 ** const l_899 = &l_703;
        struct S0 ** const *l_898[6];
        struct S1 *l_906 = (void*)0;
        uint64_t l_1037[5][2] = {{18446744073709551614UL,0xAEE96A091401D7B7LL},{18446744073709551615UL,0UL},{0xAEE96A091401D7B7LL,0UL},{18446744073709551615UL,0xAEE96A091401D7B7LL},{18446744073709551614UL,18446744073709551614UL}};
        struct S1 *l_1109 = (void*)0;
        struct S1 *** const * const l_1111 = &l_840;
        int i, j, k;
        for (i = 0; i < 7; i++)
            l_700[i] = &l_560;
        for (i = 0; i < 6; i++)
            l_898[i] = &l_899;
        for (l_584 = 10; (l_584 > 14); l_584 = safe_add_func_uint64_t_u_u(l_584, 9))
        { /* block id: 369 */
            (**l_557) = l_700[4];
            for (l_502 = 6; (l_502 >= 0); l_502 -= 1)
            { /* block id: 373 */
                struct S0 l_701 = {-7,0x77A5DEB6L,-838,-0,8385};
                struct S0 *l_702 = &l_701;
                int i;
            }
        }
    }
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_21(uint16_t  p_22, int32_t * p_23)
{ /* block id: 66 */
    int16_t l_186 = 3L;
    const struct S0 l_197 = {37,0x8D48762EL,1821,-2,3748};
    const struct S0 *l_196 = &l_197;
    const struct S0 **l_195 = &l_196;
    const struct S0 ***l_194 = &l_195;
    const struct S0 ****l_193[8][3][7] = {{{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,(void*)0,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194}},{{(void*)0,&l_194,&l_194,&l_194,&l_194,(void*)0,&l_194},{&l_194,&l_194,(void*)0,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,(void*)0,&l_194,&l_194}},{{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194}},{{(void*)0,&l_194,(void*)0,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,(void*)0,&l_194,&l_194,&l_194,&l_194,&l_194}},{{(void*)0,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,(void*)0,&l_194,&l_194},{&l_194,&l_194,(void*)0,&l_194,(void*)0,&l_194,&l_194}},{{&l_194,&l_194,&l_194,(void*)0,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,(void*)0,&l_194}},{{&l_194,&l_194,(void*)0,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194}},{{&l_194,&l_194,&l_194,(void*)0,&l_194,&l_194,(void*)0},{&l_194,&l_194,&l_194,&l_194,&l_194,&l_194,&l_194},{&l_194,&l_194,(void*)0,&l_194,&l_194,&l_194,&l_194}}};
    int32_t l_215 = 0x88E424F5L;
    int32_t *l_214 = &l_215;
    int32_t **l_301 = &l_214;
    int32_t ***l_300 = &l_301;
    int32_t **** const l_299 = &l_300;
    int32_t *l_312 = &l_215;
    int32_t *l_317 = &l_215;
    struct S0 l_325 = {80,0x15D83151L,-1564,0,12371};
    struct S0 * const l_324 = &l_325;
    struct S0 * const *l_323 = &l_324;
    struct S0 * const * const *l_322 = &l_323;
    struct S0 * const * const **l_321 = &l_322;
    const int16_t l_393[6] = {1L,1L,1L,1L,1L,1L};
    int32_t l_425 = 6L;
    const int16_t l_469 = (-5L);
    int32_t *l_487 = &l_215;
    int i, j, k;
    for (p_22 = 0; (p_22 <= 17); p_22 = safe_add_func_uint16_t_u_u(p_22, 1))
    { /* block id: 69 */
        int32_t l_165 = 8L;
        int32_t l_172[5];
        uint8_t l_182 = 251UL;
        struct S0 l_219 = {-68,1L,-1328,-4,3845};
        struct S0 *l_218 = &l_219;
        struct S0 **l_217 = &l_218;
        struct S0 *l_253[10] = {&l_219,&l_219,&l_219,&l_219,&l_219,&l_219,&l_219,&l_219,&l_219,&l_219};
        int32_t ***l_260 = (void*)0;
        int32_t ****l_259 = &l_260;
        int64_t l_267 = 0xE7206C0E4DF456CFLL;
        int32_t *l_309 = &l_172[2];
        int32_t *l_318 = &l_172[3];
        struct S0 ****l_373 = (void*)0;
        int i;
        for (i = 0; i < 5; i++)
            l_172[i] = (-5L);
    }
    for (p_22 = (-13); (p_22 == 6); p_22++)
    { /* block id: 226 */
        int32_t l_472 = 0x49F1F120L;
        struct S0 *l_485 = (void*)0;
        if ((p_22 >= ((safe_mod_func_uint64_t_u_u((p_22 == ((~((l_469 || (((safe_lshift_func_int16_t_s_u(((l_472 < (*l_312)) >= (!((safe_add_func_int32_t_s_s((*l_317), ((safe_lshift_func_uint16_t_u_s(((l_472 && (****l_299)) > (safe_add_func_uint8_t_u_u(((**l_301) > l_472), (*l_214)))), l_472)) < (-9L)))) <= 0x33F0EB3FL))), 15)) <= l_472) >= l_472)) >= p_22)) | p_22)), l_472)) < l_472)))
        { /* block id: 227 */
            int32_t *l_480 = &l_215;
            return p_23;
            /* statement id: 228 */
            //assert (func_21_rv == 0 || func_21_rv == &l_520 || (func_21_rv >= &l_693[0][0][0] && func_21_rv <= &l_693[0][1][3]) || (func_21_rv >= &l_60[0][0][0] && func_21_rv <= &l_60[8][8][2]) || (func_21_rv >= &l_670[0].f2 && func_21_rv <= &l_670[5].f2) || (func_21_rv >= &l_1166[0][0].f2 && func_21_rv <= &l_1166[3][5].f2) || func_21_rv == &l_1656);
        }
        else
        { /* block id: 229 */
            float l_484 = 0x3.Ep-1;
            float *l_483 = &l_484;
            int32_t l_486 = 1L;
            (*l_483) = ((safe_add_func_float_f_f((p_22 < p_22), p_22)) == 0x5.93CC9Bp-9);
            (**l_194) = l_485;
            /* statement id: 231 */
            assert (l_196 == 0);
            if (l_486)
                break;
        }
        /* facts after branching */
        assert (l_196 == 0);
    }
    /* facts after for loop */
    assert (l_196 == 0 || l_196 == &l_197);
    return p_23;
    /* statement id: 235 */
    //assert (func_21_rv == 0 || func_21_rv == &l_520 || (func_21_rv >= &l_693[0][0][0] && func_21_rv <= &l_693[0][1][3]) || (func_21_rv >= &l_60[0][0][0] && func_21_rv <= &l_60[8][8][2]) || (func_21_rv >= &l_670[0].f2 && func_21_rv <= &l_670[5].f2) || (func_21_rv >= &l_1166[0][0].f2 && func_21_rv <= &l_1166[3][5].f2) || func_21_rv == &l_1656);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_24(int32_t  p_25, int32_t * p_26)
{ /* block id: 63 */
    int32_t l_162 = (-1L);
    int32_t *l_161[5] = {&l_162,&l_162,&l_162,&l_162,&l_162};
    int32_t **l_160[8] = {&l_161[1],&l_161[1],&l_161[1],&l_161[1],&l_161[1],&l_161[1],&l_161[1],&l_161[1]};
    int i;
    p_26 = (void*)0;
    /* statement id: 64 */
    assert (p_26 == 0);
    return p_26;
    /* statement id: 65 */
    //assert (func_24_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(int32_t * p_32, int32_t * p_33)
{ /* block id: 18 */
    int32_t l_82 = (-1L);
    float l_93 = 0xB.F56D68p+9;
    float *l_92 = &l_93;
    int32_t l_101 = 0L;
    struct S0 *l_132 = (void*)0;
    struct S0 l_133 = {69,0x9F48E8C6L,107,-1,20253};
    int32_t *l_156[7];
    int i;
    for (i = 0; i < 7; i++)
        l_156[i] = &l_101;
    for (l_82 = 0; (l_82 <= (-17)); l_82--)
    { /* block id: 21 */
        int32_t l_85 = 0xD48C05A1L;
        int32_t *l_86 = &l_82;
        int32_t **l_87 = &l_86;
        (*l_87) = func_34(((65532UL || l_85) || l_85), l_82, l_86);
        for (l_85 = 0; (l_85 < (-2)); l_85 = safe_sub_func_int8_t_s_s(l_85, 3))
        { /* block id: 25 */
            int16_t l_94[5];
            int32_t l_95 = 0x02CBC4CBL;
            int i;
            for (i = 0; i < 5; i++)
                l_94[i] = 0x42B3L;
            (*p_32) = ((l_82 <= ((safe_rshift_func_int16_t_s_s(l_82, 5)) && (l_92 != (void*)0))) > 0x6F68L);
            for (l_95 = 0; l_95 < 5; l_95 += 1)
            {
                l_94[l_95] = (-1L);
            }
            for (l_95 = 0; (l_95 <= 4); l_95 += 1)
            { /* block id: 30 */
                int i;
                (*l_87) = func_34(l_94[l_95], ((void*)0 != &p_33), func_34(l_95, l_82, p_32));
                /* statement id: 31 */
                //assert ((l_86 >= &l_60[0][0][0] && l_86 <= &l_60[8][8][2]));
            }
        }
        /* facts after for loop */
        //assert ((l_86 >= &l_60[0][0][0] && l_86 <= &l_60[8][8][2]) || l_86 == &l_82);
        (*l_87) = func_34((*l_86), l_82, p_33);
        /* statement id: 34 */
        //assert ((l_86 >= &l_60[0][0][0] && l_86 <= &l_60[8][8][2]));
    }
    for (l_82 = 0; (l_82 != 12); l_82 = safe_add_func_int16_t_s_s(l_82, 6))
    { /* block id: 38 */
        int32_t l_98 = 8L;
        struct S0 l_125 = {-29,0L,-1498,3,14639};
        struct S0 *l_124 = &l_125;
        struct S0 **l_123[3];
        int32_t *l_151 = &l_101;
        int i;
        for (i = 0; i < 3; i++)
            l_123[i] = &l_124;
        for (l_98 = 0; (l_98 <= (-3)); l_98--)
        { /* block id: 41 */
            const float *l_119 = &l_93;
            int32_t l_127 = 0x5652690AL;
            l_101 = l_82;
            if ((safe_lshift_func_int8_t_s_s((-1L), 5)))
            { /* block id: 43 */
                int32_t *l_105[4];
                int32_t **l_104 = &l_105[2];
                struct S0 **l_126 = &l_124;
                int i;
                for (i = 0; i < 4; i++)
                    l_105[i] = &l_82;
                (*l_104) = p_33;
                /* statement id: 44 */
                //assert ((l_105[0] >= &l_60[0][0][0] && l_105[0] <= &l_60[8][8][2]) || l_105[0] == &l_82);
                p_33 = func_34((safe_sub_func_uint16_t_u_u((safe_sub_func_uint64_t_u_u(l_98, ((~(safe_mod_func_uint64_t_u_u((safe_rshift_func_uint8_t_u_s((0xF1L && (safe_lshift_func_int8_t_s_u(l_98, l_98))), (l_82 ^ (((void*)0 == l_105[2]) < (*p_33))))), 0x341DB1EA26DAF190LL))) & (**l_104)))), l_101)), l_82, p_32);
                l_125.f0 = (safe_mod_func_int16_t_s_s((l_119 != (void*)0), (~(((safe_mod_func_int8_t_s_s(l_98, (0x85L | ((l_123[1] == l_126) >= l_82)))) & (l_127 != (l_127 != l_125.f0))) > l_127))));
            }
            else
            { /* block id: 47 */
                uint32_t l_134[3];
                int8_t l_150 = 0x7AL;
                int i;
                for (i = 0; i < 3; i++)
                    l_134[i] = 0x5AE8A67AL;
                (*l_92) = (safe_sub_func_float_f_f(0x4.AC2E3Dp+60, (safe_div_func_float_f_f(l_101, ((l_132 == l_132) >= 0x9.8FCF75p-56)))));
                (*l_124) = l_133;
                l_151 = func_34(l_134[2], l_125.f4, func_34((safe_lshift_func_int16_t_s_s((safe_add_func_uint64_t_u_u((safe_sub_func_int32_t_s_s(l_134[2], 7UL)), (safe_lshift_func_uint16_t_u_s((((l_134[2] & (safe_sub_func_uint32_t_u_u(l_134[1], (safe_rshift_func_int16_t_s_s(((safe_rshift_func_int8_t_s_u(l_98, (safe_unary_minus_func_uint32_t_u((l_133.f2 < (((l_127 | l_134[2]) && l_134[2]) | l_150)))))) ^ l_127), l_125.f1))))) && l_150) || 0x5CC310F3L), l_127)))), l_98)), l_127, p_32));
                /* statement id: 50 */
                //assert ((l_151 >= &l_60[0][0][0] && l_151 <= &l_60[8][8][2]));
                (*l_92) = l_150;
            }
        }
        /* facts after for loop */
        //assert ((l_151 >= &l_60[0][0][0] && l_151 <= &l_60[8][8][2]) || l_151 == &l_101);
        l_156[0] = func_34((*l_151), l_133.f0, func_34((l_133.f1 >= (safe_sub_func_int8_t_s_s(0L, (safe_add_func_uint32_t_u_u(0x65E8A440L, (1L == (*l_151))))))), (*l_151), &l_98));
        /* statement id: 54 */
        //assert (l_156[0] == &l_98 || l_156[0] == dangling || l_156[0] == &l_101);
        for (l_98 = 0; (l_98 != (-22)); --l_98)
        { /* block id: 57 */
            int32_t **l_159 = &l_156[0];
            (*l_159) = &l_101;
            (*l_159) = &l_101;
        }
    }
    /* facts after for loop */
    //assert (l_156[0] == dangling || l_156[0] == &l_101);
    return (*p_33);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(int32_t  p_35, int8_t  p_36, int32_t * p_37)
{ /* block id: 11 */
    struct S0 l_75[8][9][2] = {{{{-31,0x7F612420L,590,-1,3145},{-78,1L,1088,-1,17521}},{{-31,0x7F612420L,590,-1,3145},{-31,0x7F612420L,590,-1,3145}},{{-78,1L,1088,-1,17521},{-31,0x7F612420L,590,-1,3145}},{{-31,0x7F612420L,590,-1,3145},{-78,1L,1088,-1,17521}},{{-31,0x7F612420L,590,-1,3145},{-31,0x7F612420L,590,-1,3145}},{{-78,1L,1088,-1,17521},{-31,0x7F612420L,590,-1,3145}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}},{{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}},{{-78,1L,1088,-1,17521},{57,0x452CA465L,-559,-0,229}},{{-78,1L,1088,-1,17521},{-78,1L,1088,-1,17521}},{{57,0x452CA465L,-559,-0,229},{-78,1L,1088,-1,17521}}}};
    struct S0 *l_74[9][8][3] = {{{(void*)0,&l_75[7][4][1],&l_75[7][4][1]},{&l_75[2][4][1],&l_75[6][4][1],&l_75[2][4][1]},{(void*)0,&l_75[2][4][1],(void*)0},{&l_75[2][4][1],&l_75[6][0][0],&l_75[2][4][1]},{&l_75[6][0][1],&l_75[6][0][1],&l_75[7][4][1]},{&l_75[1][1][0],&l_75[6][0][0],&l_75[2][4][1]},{&l_75[7][4][1],&l_75[2][4][1],&l_75[0][3][0]},{&l_75[1][1][0],&l_75[6][4][1],&l_75[1][1][0]}},{{&l_75[6][0][1],&l_75[7][4][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[2][4][1]},{(void*)0,&l_75[7][4][1],&l_75[7][4][1]},{&l_75[2][4][1],&l_75[6][4][1],&l_75[2][4][1]},{(void*)0,&l_75[2][4][1],(void*)0},{&l_75[2][4][1],&l_75[6][0][0],&l_75[2][4][1]},{&l_75[6][0][1],&l_75[6][0][1],&l_75[7][4][1]},{&l_75[1][1][0],&l_75[6][0][0],&l_75[2][4][1]}},{{&l_75[7][4][1],&l_75[2][4][1],&l_75[0][3][0]},{&l_75[1][1][0],&l_75[6][4][1],&l_75[1][1][0]},{&l_75[6][0][1],&l_75[7][4][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[1][1][0]},{&l_75[0][3][0],(void*)0,(void*)0},{&l_75[1][1][0],&l_75[3][6][0],(void*)0},{&l_75[0][3][0],&l_75[6][0][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[2][4][1],(void*)0}},{{&l_75[7][4][1],&l_75[7][4][1],(void*)0},{&l_75[2][4][1],&l_75[2][4][1],&l_75[1][1][0]},{(void*)0,&l_75[6][0][1],&l_75[2][4][1]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[2][4][1]},{&l_75[7][4][1],(void*)0,&l_75[2][4][1]},{&l_75[2][4][1],&l_75[6][0][0],&l_75[1][1][0]},{&l_75[0][3][0],(void*)0,(void*)0},{&l_75[1][1][0],&l_75[3][6][0],(void*)0}},{{&l_75[0][3][0],&l_75[6][0][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[2][4][1],(void*)0},{&l_75[7][4][1],&l_75[7][4][1],(void*)0},{&l_75[2][4][1],&l_75[2][4][1],&l_75[1][1][0]},{(void*)0,&l_75[6][0][1],&l_75[2][4][1]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[2][4][1]},{&l_75[7][4][1],(void*)0,&l_75[2][4][1]},{&l_75[2][4][1],&l_75[6][0][0],&l_75[1][1][0]}},{{&l_75[0][3][0],(void*)0,(void*)0},{&l_75[1][1][0],&l_75[3][6][0],(void*)0},{&l_75[0][3][0],&l_75[6][0][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[2][4][1],(void*)0},{&l_75[7][4][1],&l_75[7][4][1],(void*)0},{&l_75[2][4][1],&l_75[2][4][1],&l_75[1][1][0]},{(void*)0,&l_75[6][0][1],&l_75[2][4][1]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[2][4][1]}},{{&l_75[7][4][1],(void*)0,&l_75[2][4][1]},{&l_75[2][4][1],&l_75[6][0][0],&l_75[1][1][0]},{&l_75[0][3][0],(void*)0,(void*)0},{&l_75[1][1][0],&l_75[3][6][0],(void*)0},{&l_75[0][3][0],&l_75[6][0][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[2][4][1],(void*)0},{&l_75[7][4][1],&l_75[7][4][1],(void*)0},{&l_75[2][4][1],&l_75[2][4][1],&l_75[1][1][0]}},{{(void*)0,&l_75[6][0][1],&l_75[2][4][1]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[2][4][1]},{&l_75[7][4][1],(void*)0,&l_75[2][4][1]},{&l_75[2][4][1],&l_75[6][0][0],&l_75[1][1][0]},{&l_75[0][3][0],(void*)0,(void*)0},{&l_75[1][1][0],&l_75[3][6][0],(void*)0},{&l_75[0][3][0],&l_75[6][0][1],&l_75[0][3][0]},{&l_75[2][4][1],&l_75[2][4][1],(void*)0}},{{&l_75[7][4][1],&l_75[7][4][1],(void*)0},{&l_75[2][4][1],&l_75[2][4][1],&l_75[1][1][0]},{(void*)0,&l_75[6][0][1],&l_75[2][4][1]},{&l_75[2][4][1],&l_75[3][6][0],&l_75[2][4][1]},{&l_75[7][4][1],(void*)0,&l_75[2][4][1]},{&l_75[2][4][1],&l_75[6][0][0],&l_75[1][1][0]},{&l_75[0][3][0],(void*)0,(void*)0},{&l_75[1][1][0],&l_75[3][6][0],(void*)0}}};
    struct S0 **l_73[9][4] = {{&l_74[3][4][0],&l_74[6][5][2],&l_74[3][4][0],&l_74[6][5][2]},{&l_74[6][5][2],(void*)0,&l_74[3][6][1],&l_74[7][4][2]},{&l_74[7][4][2],&l_74[6][5][2],&l_74[6][5][2],(void*)0},{&l_74[2][5][1],&l_74[6][5][2],&l_74[6][5][2],&l_74[2][5][1]},{&l_74[7][4][2],&l_74[6][5][2],&l_74[3][6][1],&l_74[3][4][0]},{&l_74[6][5][2],&l_74[7][5][0],&l_74[3][4][0],&l_74[6][6][2]},{&l_74[3][4][0],&l_74[6][6][2],&l_74[6][7][2],&l_74[6][6][2]},{&l_74[6][5][2],&l_74[7][5][0],&l_74[6][5][2],&l_74[3][4][0]},{(void*)0,&l_74[6][5][2],&l_74[6][5][2],&l_74[6][5][2]}};
    struct S0 ** const *l_72 = &l_73[8][1];
    int i, j, k;
    for (p_35 = 24; (p_35 != 14); p_35--)
    { /* block id: 14 */
        int32_t l_67 = 0xC135235EL;
        int32_t *l_66 = &l_67;
        int32_t **l_65[4][6][3] = {{{&l_66,&l_66,&l_66},{&l_66,&l_66,(void*)0},{&l_66,(void*)0,(void*)0},{(void*)0,&l_66,(void*)0},{&l_66,(void*)0,&l_66},{(void*)0,&l_66,&l_66}},{{&l_66,&l_66,&l_66},{&l_66,&l_66,&l_66},{&l_66,(void*)0,&l_66},{(void*)0,(void*)0,(void*)0},{&l_66,&l_66,(void*)0},{(void*)0,&l_66,(void*)0}},{{&l_66,&l_66,(void*)0},{&l_66,(void*)0,(void*)0},{&l_66,&l_66,(void*)0},{(void*)0,(void*)0,(void*)0},{&l_66,&l_66,(void*)0},{&l_66,&l_66,(void*)0}},{{(void*)0,(void*)0,&l_66},{(void*)0,&l_66,&l_66},{&l_66,(void*)0,&l_66},{&l_66,&l_66,&l_66},{(void*)0,&l_66,&l_66},{&l_66,&l_66,(void*)0}}};
        struct S0 ** const l_78 = &l_74[2][5][2];
        float l_80 = 0x1.Cp-1;
        float *l_79 = &l_80;
        int i, j, k;
        (*l_79) = (safe_sub_func_float_f_f(((l_65[0][0][2] != &l_66) > (safe_div_func_float_f_f((safe_sub_func_float_f_f(((void*)0 != l_72), (safe_add_func_float_f_f((p_37 != (void*)0), ((void*)0 != l_78))))), 0x7.1B5D95p+5))), 0x1.3EC180p+70));
    }
    return p_37;
    /* statement id: 17 */
    //assert ((func_34_rv >= &l_60[0][0][0] && func_34_rv <= &l_60[8][8][2]) || func_34_rv == &l_82 || func_34_rv == &l_98 || func_34_rv == 0 || (func_34_rv >= &l_172[0] && func_34_rv <= &l_172[4]) || func_34_rv == &l_215 || func_34_rv == &l_520 || func_34_rv == &l_1174 || func_34_rv == &l_1301 || (func_34_rv >= &l_1166[0][0].f2 && func_34_rv <= &l_1166[3][5].f2) || func_34_rv == &l_1786);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_38(uint8_t  p_39)
{ /* block id: 2 */
    int32_t l_42 = 0xD029B4CCL;
    int32_t *l_41 = &l_42;
    int32_t **l_40 = &l_41;
    struct S0 l_43 = {-0,-1L,-188,-1,5345};
    (*l_40) = (void*)0;
    /* statement id: 3 */
    assert (l_41 == 0);
    l_43 = l_43;
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_44(const int32_t * const  p_45)
{ /* block id: 6 */
    const struct S0 **l_48 = (void*)0;
    struct S0 l_51 = {-0,-2L,32,-1,8451};
    struct S0 *l_50 = &l_51;
    struct S0 **l_49[8] = {&l_50,&l_50,&l_50,&l_50,&l_50,&l_50,&l_50,&l_50};
    struct S0 *l_52 = &l_51;
    int32_t l_54 = 0xDFE90167L;
    int32_t * const l_53 = &l_54;
    int32_t *l_56 = &l_54;
    int32_t **l_55 = &l_56;
    struct S0 ***l_57 = &l_49[0];
    uint8_t l_58 = 0x59L;
    int i;
    l_52 = (void*)0;
    /* statement id: 7 */
    assert (l_52 == 0);
    (*l_55) = l_53;
    (*l_57) = &l_50;
    return l_58;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 453
   depth: 1, occurrence: 35
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 135
breakdown:
   indirect level: 0, occurrence: 35
   indirect level: 1, occurrence: 36
   indirect level: 2, occurrence: 24
   indirect level: 3, occurrence: 20
   indirect level: 4, occurrence: 16
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 113
XXX times a bitfields struct on LHS: 17
XXX times a bitfields struct on RHS: 62
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 158

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 21
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 14, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 442

XXX times a variable address is taken: 1045
XXX times a pointer is dereferenced on RHS: 262
breakdown:
   depth: 1, occurrence: 196
   depth: 2, occurrence: 35
   depth: 3, occurrence: 14
   depth: 4, occurrence: 14
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 203
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 35
   depth: 3, occurrence: 16
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 90
XXX times a pointer is compared with address of another variable: 23
XXX times a pointer is compared with another pointer: 49
XXX times a pointer is qualified to be dereferenced: 2064

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 585
   level: 2, occurrence: 182
   level: 3, occurrence: 121
   level: 4, occurrence: 118
   level: 5, occurrence: 16
XXX number of pointers point to pointers: 230
XXX number of pointers point to scalars: 152
XXX number of pointers point to structs: 60
XXX percent of pointers has null in alias set: 32.6
XXX average alias set size: 1.33

XXX times a non-volatile is read: 2195
XXX times a non-volatile is write: 695
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 13

XXX stmts: 93
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 12
   depth: 2, occurrence: 14
   depth: 3, occurrence: 12
   depth: 4, occurrence: 10
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 15.3
XXX percentage an existing variable is used: 84.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

