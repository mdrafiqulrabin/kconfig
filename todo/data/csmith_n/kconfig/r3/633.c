/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      296715824
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int16_t  f0;
   int32_t  f1;
   uint32_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static const uint32_t g_6 = 3U;
static int32_t g_16[4][6][2] = {{{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B},{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B}},{{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B},{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B}},{{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B},{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B}},{{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0x27A4129B,0x27A4129B},{0xC42FF18C,0x27A4129B},{0x27A4129B,0xC42FF18C},{0xC42FF18C,0xC42FF18C}}};
static int32_t g_20 = (-6);
static int32_t *g_19 = &g_20;
static int32_t g_66 = 0x3AC46406;
static int32_t g_80 = 0;
static struct S0 g_110 = {0x0FED,0x2739EBEB,0U};
static struct S0 g_118 = {0,0x66BA4606,7U};
static int32_t **g_257[2][2][8] = {{{&g_19,&g_19,&g_19,&g_19,&g_19,&g_19,&g_19,(void*)0},{(void*)0,&g_19,&g_19,&g_19,&g_19,&g_19,&g_19,&g_19}},{{(void*)0,(void*)0,(void*)0,&g_19,&g_19,&g_19,(void*)0,&g_19},{&g_19,&g_19,&g_19,&g_19,&g_19,&g_19,&g_19,&g_19}}};
static int32_t ***g_256 = &g_257[0][0][3];
static int32_t ****g_255[2][8] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
static int32_t *** const *g_317[10][9] = {{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256,&g_256}};
static const struct S0 *g_322 = &g_110;
static const struct S0 **g_321[5] = {&g_322,&g_322,&g_322,&g_322,&g_322};
static const struct S0 ***g_320 = &g_321[4];
static const struct S0 * const *g_360 = (void*)0;
static uint32_t g_750 = 0x3D582886;
static const uint32_t g_755 = 4294967292U;
static int32_t g_934 = 1;
static struct S0 *g_1071 = &g_118;
static struct S0 **g_1070 = &g_1071;
static struct S0 ***g_1069 = &g_1070;
static struct S0 ****g_1068[4][3] = {{&g_1069,&g_1069,&g_1069},{&g_1069,&g_1069,&g_1069},{&g_1069,&g_1069,&g_1069},{&g_1069,&g_1069,&g_1069}};
static struct S0 *****g_1067 = &g_1068[2][1];
static int32_t g_1286 = 1;
static int32_t g_1331 = 8;
static uint32_t g_1371 = 0x0F85BB97;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
inline static int32_t  func_2(int16_t  p_3, int8_t  p_4, uint32_t  p_5);
static const int16_t  func_7(int16_t  p_8, int32_t  p_9);
inline static int32_t * func_21(const int32_t * p_22, int32_t * p_23);
static int32_t * func_24(int8_t  p_25, int32_t * p_26, struct S0  p_27, uint32_t  p_28);
static uint16_t  func_41(int32_t  p_42, int32_t  p_43, const int32_t * p_44, uint16_t  p_45);
inline static int32_t  func_52(int16_t  p_53);
static uint8_t  func_56(int32_t * p_57, uint32_t  p_58, int32_t * p_59, uint16_t  p_60, uint32_t  p_61);
static int32_t * func_62(uint8_t  p_63);
static int32_t * func_67(int32_t  p_68, uint8_t  p_69, int32_t * p_70, int32_t * p_71, int32_t  p_72);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_16 g_20 g_66 g_320 g_321 g_118.f1 g_256 g_257 g_118.f2 g_80 g_118.f0 g_934 g_110.f0 g_110.f2 g_110 g_755 g_750 g_1067 g_1068 g_1069 g_1070 g_1071 g_19 g_1331 g_118 g_1371 g_1286 g_322
 * writes: g_16 g_19 g_20 g_66 g_110.f2 g_322 g_255 g_110.f0 g_110.f1 g_118 g_750 g_934 g_80 g_1071 g_1331 g_1067 g_110 g_1069 g_1286
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_11 = 0x2BA7B7E8;
    uint32_t l_1184 = 0U;
    int32_t ** const ***l_1186 = (void*)0;
    const int8_t l_1194 = 0x62;
    int32_t *l_1207 = (void*)0;
    int32_t l_1257 = 0x5D4CBC0D;
    int32_t l_1332[1];
    int32_t * const *l_1344[9][4][5] = {{{&l_1207,&g_19,(void*)0,(void*)0,&l_1207},{&l_1207,(void*)0,(void*)0,(void*)0,&l_1207},{&g_19,&g_19,&g_19,(void*)0,(void*)0},{&l_1207,&l_1207,&l_1207,(void*)0,&l_1207}},{{&l_1207,&g_19,&l_1207,(void*)0,(void*)0},{&l_1207,&l_1207,&g_19,&l_1207,&l_1207},{&g_19,&l_1207,&l_1207,(void*)0,&l_1207},{(void*)0,(void*)0,&g_19,&l_1207,&g_19}},{{(void*)0,&g_19,(void*)0,&l_1207,&g_19},{(void*)0,(void*)0,&l_1207,&g_19,&g_19},{&l_1207,&l_1207,&l_1207,&l_1207,&g_19},{&g_19,&g_19,&l_1207,&l_1207,(void*)0}},{{&l_1207,&g_19,&l_1207,&g_19,&g_19},{(void*)0,(void*)0,&l_1207,(void*)0,&l_1207},{(void*)0,&l_1207,&l_1207,(void*)0,&g_19},{(void*)0,&g_19,&l_1207,&l_1207,(void*)0}},{{&l_1207,&l_1207,(void*)0,&g_19,&g_19},{&g_19,(void*)0,&g_19,&l_1207,&g_19},{(void*)0,&g_19,&g_19,(void*)0,&g_19},{&g_19,&g_19,(void*)0,(void*)0,&g_19}},{{&l_1207,&l_1207,&g_19,&g_19,&l_1207},{(void*)0,(void*)0,&g_19,&l_1207,&g_19},{(void*)0,&g_19,(void*)0,&l_1207,&g_19},{(void*)0,(void*)0,&l_1207,&g_19,&g_19}},{{&l_1207,&l_1207,&l_1207,&l_1207,&g_19},{&g_19,&g_19,&l_1207,&l_1207,(void*)0},{&l_1207,&g_19,&l_1207,&g_19,&g_19},{(void*)0,(void*)0,&l_1207,(void*)0,&l_1207}},{{(void*)0,&l_1207,&l_1207,(void*)0,&g_19},{(void*)0,&g_19,&l_1207,&l_1207,(void*)0},{&l_1207,&l_1207,(void*)0,&g_19,&g_19},{&g_19,(void*)0,&g_19,&l_1207,&g_19}},{{(void*)0,&g_19,&g_19,(void*)0,&g_19},{&g_19,&g_19,(void*)0,(void*)0,&g_19},{&l_1207,&l_1207,&g_19,&g_19,&l_1207},{(void*)0,(void*)0,&g_19,&l_1207,&g_19}}};
    int32_t * const **l_1343 = &l_1344[6][2][0];
    int32_t l_1354 = 0xABF8B76F;
    int16_t l_1359 = 0x4BD9;
    struct S0 * const l_1402 = &g_110;
    int8_t l_1404 = 0x80;
    int32_t l_1406 = 4;
    uint8_t l_1410 = 253U;
    int i, j, k;
    for (i = 0; i < 1; i = i + 1)
        l_1332[i] = 0x89908750;
    if (func_2(((g_6 <= 1) <= ((7 & 5) || (((func_7(g_6, (~((((0x9934 != 0xB4EF) && l_11) | g_6) < g_6))) & 0U) && 0x9A) | 8U))), l_1184, l_11))
    { /* block id: 772 */
        uint16_t l_1189 = 0xBE7A;
        int32_t l_1195 = 0x81F955DA;
        int32_t **l_1196 = (void*)0;
        int32_t **l_1197 = (void*)0;
        int32_t **l_1198 = &g_19;
        struct S0 *****l_1247 = &g_1068[1][2];
        uint8_t l_1253 = 0U;
        int32_t ****l_1265 = &g_256;
        int32_t *l_1277[6][8] = {{(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1]},{(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1]},{(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1]},{(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1]},{(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1]},{(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1],(void*)0,&g_16[0][1][1]}};
        int i, j;
        l_1195 = ((&g_317[4][1] != l_1186) == (safe_sub_func_int32_t_s_s(0, ((((6 || g_6) > 7U) || l_1189) ^ (0x6C10 && (((safe_add_func_int16_t_s_s((safe_mod_func_int32_t_s_s(((((l_1189 | 0xDD) <= l_1194) > g_110.f1) != l_1189), 4294967287U)), l_1189)) != l_1189) ^ g_118.f1))))));
        (*l_1198) = &l_1195;
        /* statement id: 774 */
        assert (g_19 == &l_1195);
        for (l_1195 = 1; (l_1195 >= 0); l_1195 -= 1)
        { /* block id: 777 */
            int32_t *l_1199 = &g_16[0][1][1];
            int32_t *l_1229 = &g_16[0][1][1];
            int8_t l_1254 = (-1);
            int32_t ****l_1266[8][6] = {{&g_256,(void*)0,&g_256,(void*)0,&g_256,(void*)0},{&g_256,&g_256,&g_256,(void*)0,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,(void*)0,&g_256,&g_256,&g_256,(void*)0},{&g_256,(void*)0,&g_256,(void*)0,&g_256,(void*)0},{&g_256,&g_256,&g_256,(void*)0,&g_256,&g_256},{&g_256,&g_256,&g_256,&g_256,&g_256,&g_256},{&g_256,(void*)0,&g_256,&g_256,&g_256,(void*)0}};
            int32_t *l_1288 = &g_16[0][1][1];
            int i, j;
            for (g_934 = 1; (g_934 >= 0); g_934 -= 1)
            { /* block id: 780 */
                uint8_t l_1200 = 0x32;
                int32_t l_1228 = 7;
                l_1199 = func_62(g_118.f0);
                if (l_1200)
                    break;
                if ((safe_rshift_func_uint16_t_u_s(((*g_19) || (safe_add_func_uint16_t_u_u(((65534U < g_118.f0) ^ g_20), ((void*)0 == (****g_1067))))), 1)))
                { /* block id: 783 */
                    uint8_t l_1205[1][9][2] = {{{1U,5U},{1U,5U},{1U,5U},{1U,5U},{1U,5U},{1U,5U},{1U,5U},{1U,5U},{1U,5U}}};
                    int i, j, k;
                    return l_1205[0][2][1];
                    /* statement id: 784 */
                    //assert (g_19 == dangling);
                }
                else
                { /* block id: 785 */
                    int32_t *l_1206 = (void*)0;
                    l_1207 = l_1206;
                }
                for (g_80 = 0; (g_80 <= 1); g_80 += 1)
                { /* block id: 790 */
                    int16_t l_1212 = 0x7EAA;
                    struct S0 ***l_1221 = &g_1070;
                    uint32_t l_1224 = 0x4BEB788A;
                    uint32_t l_1227 = 0xE6F1CFB8;
                    for (l_1189 = 0; (l_1189 <= 1); l_1189 += 1)
                    { /* block id: 793 */
                        int i, j, k;
                        l_1228 = (safe_sub_func_int8_t_s_s(g_16[(g_934 + 2)][l_1189][l_1189], (safe_sub_func_uint16_t_u_u(0U, ((l_1212 != (safe_lshift_func_uint8_t_u_s((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s((safe_add_func_uint16_t_u_u(((**g_1067) == l_1221), ((((safe_mod_func_int16_t_s_s(g_118.f2, l_1224)) | ((((safe_mod_func_uint32_t_u_u((((g_20 ^ 1U) <= g_118.f0) || 0x38), g_118.f2)) >= l_1227) > (*g_19)) < g_20)) ^ 0xCE) || g_16[1][5][1]))), l_1200)), 0)), 1))) != (**l_1198))))));
                        l_1229 = &l_1228;
                        /* statement id: 795 */
                        assert (l_1229 == &l_1228);
                    }
                }
                /* facts after for loop */
                //assert (l_1229 == &l_1228 || (l_1229 >= &g_16[0][0][0] && l_1229 <= &g_16[3][5][1]) || l_1229 == dangling);
            }
            /* facts after for loop */
            assert (l_1199 == 0 || (l_1199 >= &g_16[0][0][0] && l_1199 <= &g_16[3][5][1]) || l_1199 == &g_20);
            //assert (l_1229 == dangling || (l_1229 >= &g_16[0][0][0] && l_1229 <= &g_16[3][5][1]));
            for (l_1184 = 0; (l_1184 <= 1); l_1184 += 1)
            { /* block id: 801 */
                int8_t l_1232 = 0x2A;
                int32_t l_1271[5] = {1,1,1,1,1};
                int32_t *l_1287 = &g_16[0][1][1];
                int8_t l_1318 = 7;
                int32_t *****l_1320[6];
                int i;
                for (i = 0; i < 6; i = i + 1)
                    l_1320[i] = (void*)0;
            }
        }
    }
    else
    { /* block id: 848 */
        uint32_t l_1334 = 0xC16FC1C9;
        int32_t **l_1350 = &l_1207;
        uint16_t l_1352 = 65528U;
        struct S0 **** const l_1353 = &g_1069;
        uint32_t l_1369[8][2] = {{0x8A2C8F9B,0x8A2C8F9B},{0x8A2C8F9B,0x2874FDE9},{0x8A2C8F9B,0x8A2C8F9B},{0x8A2C8F9B,0x2874FDE9},{0x8A2C8F9B,0x8A2C8F9B},{0x8A2C8F9B,0x2874FDE9},{0x8A2C8F9B,0x8A2C8F9B},{0x8A2C8F9B,0x2874FDE9}};
        int32_t ***** const l_1375 = &g_255[1][3];
        int i, j;
        l_1207 = &l_1257;
        /* statement id: 849 */
        assert (l_1207 == &l_1257);
        if ((safe_add_func_int8_t_s_s((safe_add_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u((safe_add_func_uint8_t_u_u(g_1331, g_110.f1)), 1)) && l_1332[0]), (~l_1334))), l_1334)))
        { /* block id: 850 */
            const int32_t *l_1338 = &g_80;
            int32_t * const *l_1342 = &g_19;
            int32_t * const **l_1341 = &l_1342;
            const struct S0 l_1355 = {0x0386,0x852B8789,0U};
            int8_t l_1358 = 0xD4;
            int32_t *****l_1376 = &g_255[1][3];
            int32_t *l_1383 = &g_16[0][5][0];
            for (g_118.f2 = 19; (g_118.f2 >= 59); g_118.f2 = safe_add_func_uint16_t_u_u(g_118.f2, 7))
            { /* block id: 853 */
                int8_t l_1337 = (-9);
                int32_t l_1345[8][1][9] = {{{0,0,0x4CD8C7A1,0x9C8257D1,1,(-1),(-1),0x9A30B074,(-7)}},{{0x1E8D18A2,1,0xC881DB12,(-9),0x1E8D18A2,(-9),0xC881DB12,1,0x1E8D18A2}},{{1,(-1),0x4CD8C7A1,(-7),0,0x9A30B074,0x9C8257D1,(-1),(-1)}},{{(-1),1,(-6),0x26863CAA,(-6),1,(-1),0x26863CAA,(-1)}},{{1,0,0x9C8257D1,(-1),(-7),(-1),0x4CD8C7A1,0x4CD8C7A1,(-1)}},{{0x1E8D18A2,(-5),(-1),(-5),0x1E8D18A2,0x26863CAA,(-1),0x26863CAA,0x1E8D18A2}},{{0,0x9C8257D1,(-1),(-7),(-1),0x4CD8C7A1,0x4CD8C7A1,(-1),(-7)}},{{(-6),0x26863CAA,(-6),1,(-1),0x26863CAA,(-1),1,(-6)}}};
                int i, j, k;
                if (l_1337)
                { /* block id: 854 */
                    const int32_t **l_1339 = &l_1338;
                    (*l_1339) = l_1338;
                    l_1345[3][0][6] = ((((*l_1207) | (g_934 | l_1337)) >= l_1334) < ((safe_unary_minus_func_uint16_t_u((l_1341 == l_1343))) ^ (*l_1338)));
                }
                else
                { /* block id: 857 */
                    uint8_t l_1351 = 255U;
                    struct S0 l_1356 = {-9,9,0U};
                    struct S0 ***l_1357 = &g_1070;
                    l_1345[3][0][6] = (safe_add_func_uint32_t_u_u((((safe_sub_func_uint8_t_u_u((((l_1350 == (*l_1341)) == (0xD2 >= g_110.f2)) && l_1345[3][0][6]), (g_16[0][1][1] ^ (l_1351 >= l_1352)))) != (((void*)0 != l_1353) != g_16[0][1][1])) < g_16[1][0][0]), l_1354));
                    (*l_1350) = &l_1345[3][0][6];
                    /* statement id: 859 */
                    assert ((l_1207 >= &l_1345[0][0][0] && l_1207 <= &l_1345[7][0][8]));
                    l_1356 = l_1355;
                    l_1358 = (l_1357 == (**g_1067));
                }
                /* facts after branching */
                assert ((l_1207 >= &l_1345[0][0][0] && l_1207 <= &l_1345[7][0][8]) || l_1207 == &l_1257);
                if ((**l_1350))
                    break;
                //assert (l_1207 == dangling || l_1207 == &l_1257);
                return l_1359;
            }
            /* facts after for loop */
            //assert (l_1207 == dangling || l_1207 == &l_1257);
            for (g_118.f0 = 2; (g_118.f0 >= 0); g_118.f0 -= 1)
            { /* block id: 868 */
                int32_t * const l_1360 = &l_1332[0];
                uint16_t l_1362 = 1U;
                for (l_1184 = 0; (l_1184 <= 1); l_1184 += 1)
                { /* block id: 871 */
                    int i, j;
                    (**g_1069) = (***l_1353);
                    for (g_1331 = 1; (g_1331 >= 0); g_1331 -= 1)
                    { /* block id: 875 */
                        int32_t **l_1361 = &g_19;
                        struct S0 ***l_1367[7][2] = {{&g_1070,&g_1070},{(void*)0,&g_1070},{&g_1070,&g_1070},{(void*)0,&g_1070},{&g_1070,(void*)0},{&g_1070,&g_1070},{&g_1070,(void*)0}};
                        int i, j, k;
                        (*l_1350) = (void*)0;
                        /* statement id: 876 */
                        assert (l_1207 == 0);
                        (*l_1350) = &g_16[g_118.f0][(g_1331 + 3)][l_1184];
                        /* statement id: 877 */
                        assert ((l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]));
                        (*l_1361) = l_1360;
                        /* statement id: 878 */
                        assert ((g_19 >= &l_1332[0] && g_19 <= &l_1332[0]));
                        (*l_1361) = func_62(((((((g_118.f0 && (l_1362 > (((safe_mod_func_uint32_t_u_u(((((safe_lshift_func_uint8_t_u_s((l_1367[4][1] == (void*)0), (*l_1360))) & ((**l_1350) > 3)) | ((((((safe_unary_minus_func_uint8_t_u((&l_1355 == (void*)0))) >= (*l_1360)) && g_110.f0) == g_118.f0) || 0x511F) == g_118.f0)) > g_1331), g_80)) || l_1369[2][0]) ^ g_66))) & 0xFDD5170D) & 0xAA3DA45F) <= (-2)) <= (*l_1338)) != 0));
                        /* statement id: 879 */
                        assert (g_19 == 0 || (g_19 >= &g_16[0][0][0] && g_19 <= &g_16[3][5][1]) || g_19 == &g_20);
                    }
                }
                /* facts after for loop */
                assert (g_19 == 0 || (g_19 >= &g_16[0][0][0] && g_19 <= &g_16[3][5][1]) || g_19 == &g_20);
                //assert ((l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]) || l_1207 == dangling || l_1207 == &l_1257);
                for (l_1358 = 2; (l_1358 >= 0); l_1358 -= 1)
                { /* block id: 884 */
                    for (g_118.f2 = 0; (g_118.f2 <= 2); g_118.f2 += 1)
                    { /* block id: 887 */
                        struct S0 *l_1370 = &g_110;
                        g_1067 = &g_1068[2][1];
                        (*l_1370) = (*g_1071);
                        (*l_1370) = (****l_1353);
                        (**g_1067) = (**g_1067);
                    }
                }
                return g_1371;
            }
            (**g_1070) = (****l_1353);
            if ((((safe_unary_minus_func_int16_t_s((safe_add_func_int32_t_s_s((l_1375 != l_1376), (-2))))) <= (0x88681D24 && 0x3B1EF944)) && 0x6CCE))
            { /* block id: 897 */
                uint32_t l_1384 = 0U;
                for (g_1286 = 0; (g_1286 >= 9); g_1286 = safe_add_func_int32_t_s_s(g_1286, 1))
                { /* block id: 900 */
                    int32_t * const l_1379 = &g_16[0][1][1];
                    int32_t **l_1380 = &l_1207;
                    (*l_1380) = l_1379;
                    /* statement id: 901 */
                    assert ((l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]));
                    for (g_1331 = (-17); (g_1331 < (-12)); g_1331 = safe_add_func_uint16_t_u_u(g_1331, 3))
                    { /* block id: 904 */
                        (*l_1350) = l_1383;
                        if (l_1384)
                            break;
                    }
                }
                /* facts after for loop */
                //assert ((l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]) || l_1207 == dangling || l_1207 == &l_1257);
                (***g_1069) = (***g_320);
            }
            else
            { /* block id: 910 */
                int32_t l_1387[7] = {(-1),(-1),(-1),(-1),(-1),(-1),(-1)};
                int i;
                (*l_1383) = (safe_sub_func_uint32_t_u_u((g_110.f2 > g_1371), (l_1387[2] | ((255U < (l_1387[1] | (((safe_sub_func_int32_t_s_s((safe_unary_minus_func_uint16_t_u(((safe_add_func_int32_t_s_s(((g_80 ^ 0xE784) == (1U < (safe_rshift_func_uint16_t_u_s(g_1331, 7)))), g_110.f2)) | 1))), g_1371)) == g_1371) | g_16[2][3][0]))) ^ g_750))));
                (*l_1350) = &l_1387[2];
                /* statement id: 912 */
                assert ((l_1207 >= &l_1387[0] && l_1207 <= &l_1387[6]));
            }
            /* facts after branching */
            //assert ((l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]) || l_1207 == dangling || l_1207 == &l_1257);
        }
        else
        { /* block id: 914 */
            int32_t ****l_1399 = &g_256;
            int32_t l_1401 = 9;
            struct S0 **l_1403 = &g_1071;
            for (l_1359 = 0; (l_1359 <= 1); l_1359 += 1)
            { /* block id: 917 */
                uint8_t l_1400 = 9U;
            }
            (*l_1403) = l_1402;
            /* statement id: 931 */
            assert (g_1071 == &g_110);
        }
        /* facts after branching */
        assert (g_1071 == &g_110 || g_1071 == &g_118);
        //assert ((l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]) || l_1207 == dangling || l_1207 == &l_1257);
        for (l_1334 = 0; (l_1334 <= 0); l_1334 += 1)
        { /* block id: 935 */
            int i;
            l_1332[l_1334] = l_1404;
            for (g_118.f0 = 2; (g_118.f0 >= 0); g_118.f0 -= 1)
            { /* block id: 939 */
                int32_t *l_1405 = (void*)0;
                (*l_1350) = l_1405;
                /* statement id: 940 */
                assert (l_1207 == 0);
                for (l_11 = 0; (l_11 <= 3); l_11 += 1)
                { /* block id: 943 */
                    struct S0 *l_1408 = &g_110;
                    for (g_110.f1 = 0; (g_110.f1 <= 2); g_110.f1 += 1)
                    { /* block id: 946 */
                        int32_t *l_1407 = (void*)0;
                        int i, j;
                        (*l_1350) = l_1407;
                        l_1332[l_1334] = ((****g_1067) != l_1408);
                    }
                    l_1332[l_1334] = l_1332[l_1334];
                    return g_110.f0;
                }
            }
        }
        /* facts after for loop */
        //assert (l_1207 == 0 || (l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]) || l_1207 == dangling || l_1207 == &l_1257);
    }
    /* facts after branching */
    //assert (g_19 == 0 || g_19 == &g_20 || g_19 == dangling);
    assert (g_322 == &g_118 || g_322 == &g_110);
    assert (g_1071 == &g_110 || g_1071 == &g_118);
    //assert (l_1207 == 0 || (l_1207 >= &g_16[0][0][0] && l_1207 <= &g_16[3][5][1]) || l_1207 == dangling || l_1207 == &l_1257);
    l_1410 = (~(0x52CE7777 < (&g_255[1][1] != (void*)0)));
    return g_110.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_20
 * writes: g_20
 */
inline static int32_t  func_2(int16_t  p_3, int8_t  p_4, uint32_t  p_5)
{ /* block id: 769 */
    int32_t *l_1185 = &g_20;
    (*l_1185) = p_4;
    return (*l_1185);
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_20 g_66 g_320 g_321 g_118.f1 g_6 g_256 g_257 g_118.f2 g_80 g_118.f0 g_934 g_110.f0 g_110.f2 g_110 g_755 g_750 g_1067 g_1068 g_1069 g_1070 g_1071
 * writes: g_16 g_19 g_20 g_66 g_110.f2 g_322 g_255 g_110.f0 g_110.f1 g_118 g_750 g_934
 */
static const int16_t  func_7(int16_t  p_8, int32_t  p_9)
{ /* block id: 1 */
    int16_t l_31 = 0x5A52;
    int8_t l_1153 = 0xE5;
    for (p_9 = 10; (p_9 == 3); p_9 = safe_sub_func_int16_t_s_s(p_9, 4))
    { /* block id: 4 */
        int16_t l_32 = 1;
        int32_t *l_1154 = &g_16[1][4][1];
        struct S0 l_1155 = {0xD746,-4,0x9A432F9C};
        for (p_8 = 0; (p_8 < 17); p_8 = safe_add_func_uint16_t_u_u(p_8, 5))
        { /* block id: 7 */
            int32_t *l_51 = &g_16[0][1][1];
            int32_t **l_1180 = (void*)0;
            int32_t **l_1181 = &l_1154;
            for (g_16[0][1][1] = 0; (g_16[0][1][1] != 8); g_16[0][1][1] = safe_add_func_int8_t_s_s(g_16[0][1][1], 4))
            { /* block id: 10 */
                g_19 = (void*)0;
                /* statement id: 11 */
                assert (g_19 == 0);
            }
            (*l_1181) = func_21(func_24((safe_add_func_uint16_t_u_u(((l_31 | p_8) | (l_32 > (((safe_sub_func_uint8_t_u_u((safe_sub_func_int32_t_s_s(((safe_add_func_int32_t_s_s((((((safe_add_func_int8_t_s_s(((g_16[2][5][1] == func_41(((l_31 ^ p_8) <= (safe_add_func_uint8_t_u_u((safe_add_func_int16_t_s_s((~((void*)0 != l_51)), (func_52(p_9) > l_32))), g_934))), g_6, l_51, p_9)) != 0), l_1153)) && l_32) < 65535U) || g_750) ^ p_8), p_9)) || (*l_51)), 0)), g_16[0][1][1])) >= 0) & g_16[0][5][0]))), l_1153)), l_1154, l_1155, p_9), l_51);
        }
        for (g_934 = 0; (g_934 <= 27); g_934 = safe_add_func_uint8_t_u_u(g_934, 9))
        { /* block id: 764 */
            (*l_1154) = p_9;
        }
    }
    /* facts after for loop */
    assert (g_19 == 0 || g_19 == &g_20);
    assert (g_322 == &g_118 || g_322 == &g_110);
    return l_1153;
}


/* ------------------------------------------ */
/* 
 * reads : g_934 g_750 g_1067 g_1068 g_1069 g_1070 g_1071
 * writes: g_934 g_750 g_118
 */
inline static int32_t * func_21(const int32_t * p_22, int32_t * p_23)
{ /* block id: 747 */
    uint8_t l_1177[6];
    int32_t *l_1179 = &g_16[0][1][1];
    int i;
    for (i = 0; i < 6; i = i + 1)
        l_1177[i] = 0x10;
    for (g_934 = 2; (g_934 >= 0); g_934 -= 1)
    { /* block id: 750 */
        int32_t *l_1174 = &g_16[3][1][1];
        return l_1174;
        /* statement id: 751 */
        //assert ((func_21_rv >= &g_16[0][0][0] && func_21_rv <= &g_16[3][5][1]));
    }
    for (g_750 = (-10); (g_750 <= 60); g_750 = safe_add_func_int8_t_s_s(g_750, 3))
    { /* block id: 755 */
        struct S0 l_1178 = {0x8587,7,0U};
        if (l_1177[2])
            break;
        (*****g_1067) = l_1178;
    }
    return l_1179;
    /* statement id: 759 */
    //assert ((func_21_rv >= &g_16[0][0][0] && func_21_rv <= &g_16[3][5][1]));
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_80 g_934 g_16
 * writes: g_255
 */
static int32_t * func_24(int8_t  p_25, int32_t * p_26, struct S0  p_27, uint32_t  p_28)
{ /* block id: 740 */
    uint16_t l_1158 = 0x8200;
    uint32_t l_1170 = 0xD5B8B2FC;
    int32_t **** const l_1171 = &g_256;
    if ((safe_sub_func_uint8_t_u_u(l_1158, (safe_add_func_uint8_t_u_u(l_1158, ((((p_27.f2 <= (safe_rshift_func_int16_t_s_s(p_27.f1, 1))) < (p_28 | 0xE2B3)) && ((safe_sub_func_uint32_t_u_u(((safe_lshift_func_int16_t_s_s((+(g_6 & (((safe_mod_func_uint8_t_u_u((l_1170 && l_1170), g_80)) >= 0xB2) & l_1170))), g_934)) > p_27.f1), (*p_26))) > 0x28)) < l_1170))))))
    { /* block id: 741 */
        int32_t *****l_1172[8] = {&g_255[1][3],&g_255[1][3],&g_255[1][3],&g_255[1][3],&g_255[1][3],&g_255[1][3],&g_255[1][3],&g_255[1][3]};
        int32_t *****l_1173 = &g_255[1][3];
        int i;
        (*l_1173) = l_1171;
    }
    else
    { /* block id: 743 */
        return p_26;
        /* statement id: 744 */
        //assert ((func_24_rv >= &g_16[0][0][0] && func_24_rv <= &g_16[3][5][1]));
    }
    return p_26;
    /* statement id: 746 */
    //assert ((func_24_rv >= &g_16[0][0][0] && func_24_rv <= &g_16[3][5][1]));
}


/* ------------------------------------------ */
/* 
 * reads : g_934 g_6 g_110.f2 g_118.f0 g_66 g_118.f2 g_16 g_110.f0 g_755 g_118.f1 g_750
 * writes: g_118.f0 g_934
 */
static uint16_t  func_41(int32_t  p_42, int32_t  p_43, const int32_t * p_44, uint16_t  p_45)
{ /* block id: 639 */
    struct S0 l_996 = {0xA75D,0x845808D5,1U};
    struct S0 *l_997 = &l_996;
    int32_t l_1013 = 0x23DDFB26;
    int32_t **** const l_1057 = (void*)0;
    int32_t l_1077 = 2;
    int16_t l_1113 = 0xA585;
    struct S0 *l_1139[4][7] = {{&g_110,&g_110,&l_996,(void*)0,&l_996,&g_110,&g_110},{&g_110,&l_996,(void*)0,&l_996,&g_110,&g_110,&l_996},{&g_110,(void*)0,&g_110,&l_996,&l_996,&g_110,(void*)0},{&l_996,(void*)0,(void*)0,(void*)0,(void*)0,&l_996,(void*)0}};
    int i, j;
    (*l_997) = l_996;
    l_1013 = (l_996.f2 < ((safe_mod_func_uint16_t_u_u(((safe_add_func_uint16_t_u_u(p_43, g_934)) <= (safe_unary_minus_func_int8_t_s((((!l_996.f2) ^ g_6) || (((0xFE && ((l_996.f1 || (0U && (safe_add_func_int32_t_s_s((((safe_rshift_func_uint8_t_u_u((((+(safe_add_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_u((l_996.f0 <= 1), p_42)) ^ l_996.f1), 0x33123C37))) > l_996.f0) <= (-1)), 5)) ^ p_42) <= g_934), g_110.f2)))) == 0x2BD9A13E)) == p_42) != 0x3F))))), l_996.f2)) != p_43));
    for (g_118.f0 = 3; (g_118.f0 > (-17)); g_118.f0 = safe_sub_func_int16_t_s_s(g_118.f0, 5))
    { /* block id: 644 */
        struct S0 ****l_1021 = (void*)0;
        int32_t l_1053 = 2;
        const uint32_t l_1138 = 8U;
        struct S0 * const *l_1151 = &l_997;
        struct S0 * const **l_1150 = &l_1151;
        struct S0 * const ***l_1149 = &l_1150;
        struct S0 * const ****l_1148 = &l_1149;
        int32_t *l_1152 = &l_1013;
        for (g_934 = 2; (g_934 == (-13)); g_934 = safe_sub_func_int32_t_s_s(g_934, 3))
        { /* block id: 647 */
            const uint32_t l_1031[9][8][3] = {{{8U,4294967292U,0xFB5FA903},{4294967295U,4294967286U,0x6FFCBF7B},{0x0B60C276,4U,0U},{0x45BF16FB,0x674D7D84,9U},{0x49CB712E,0xB7B7CD50,1U},{0x0A45B3C7,0U,0x7AC1306D},{0xA7F59FDB,0xFB5FA903,0x8AC28E68},{0xFB5FA903,0xADEE523C,0U}},{{0x6EB8035A,4294967294U,4294967294U},{3U,1U,1U},{0x6D639133,0x15ACEB8B,0xADEE523C},{0x6D639133,0x9859114C,0x6EB8035A},{3U,4294967294U,4294967295U},{0x6EB8035A,0xCC628CFB,0U},{0xFB5FA903,4294967295U,4294967289U},{0xA7F59FDB,0x090D478E,0xA6EEB155}},{{0x0A45B3C7,5U,4294967294U},{0x49CB712E,0x723BAD94,0x45BF16FB},{0x45BF16FB,0x45BF16FB,0x909ACAE4},{0x0B60C276,0x7AC1306D,4294967294U},{4294967295U,3U,0U},{8U,4294967286U,0x9859114C},{4294967294U,4294967295U,0U},{4294967289U,0xEDD8A2E8,4294967294U}},{{0xAC6FF8F2,0x9A5C2732,0x909ACAE4},{0xA6EEB155,0xB8AABBF1,0x45BF16FB},{4U,4294967289U,4294967294U},{1U,0x7129D38D,0xA6EEB155},{0x6FFCBF7B,0x6D639133,4294967289U},{0x22AFB85B,0x0C17F5D1,0U},{4294967286U,0x1B959FEB,4294967295U},{0x090D478E,0x909ACAE4,0x6EB8035A}},{{4294967291U,0x0D9EADCE,0xADEE523C},{0U,0x0D9EADCE,1U},{1U,0x909ACAE4,4294967294U},{0x8AC28E68,0x1B959FEB,0U},{0x0D9EADCE,0x0C17F5D1,0x8AC28E68},{0x639501AE,0x6D639133,0x7AC1306D},{0x723BAD94,0x7129D38D,1U},{4294967294U,4294967289U,9U}},{{0U,0xB8AABBF1,0U},{0x0C17F5D1,0x9A5C2732,0x6FFCBF7B},{4294967295U,0xEDD8A2E8,0xFB5FA903},{5U,4294967295U,0xB7B7CD50},{1U,4294967286U,0xC2B6C093},{5U,3U,4294967294U},{4294967295U,0x7AC1306D,4294967287U},{0x0C17F5D1,0x45BF16FB,0x674D7D84}},{{0U,0x723BAD94,0x639501AE},{4294967294U,5U,0xA7F59FDB},{0x723BAD94,0x090D478E,0x7129D38D},{0x639501AE,4294967295U,3U},{0x0D9EADCE,0xCC628CFB,1U},{0x8AC28E68,4294967294U,0x0C17F5D1},{0xEBF676A2,0xF0CD7D9B,4294967292U},{5U,4294967295U,4294967292U}},{{4294967286U,0U,0xC2B6C093},{0x0C17F5D1,0x090D478E,0U},{0x723BAD94,4294967295U,8U},{0xAC6FF8F2,0x1B959FEB,5U},{0xFB5FA903,0x9859114C,1U},{4294967286U,9U,0x6EB8035A},{4294967294U,0xA7F59FDB,0xA7F59FDB},{1U,4294967294U,0xB8AABBF1}},{{4294967289U,4294967294U,4294967295U},{1U,0x0B60C276,0x22AFB85B},{4U,1U,9U},{0x15ACEB8B,0x0B60C276,0x1B959FEB},{0x8AC28E68,4294967294U,0xFB5FA903},{0x674D7D84,4294967294U,0x9859114C},{0x0A45B3C7,0xA7F59FDB,0xEDD8A2E8},{1U,9U,0U}}};
            int32_t l_1054 = 0;
            int i, j, k;
            if (l_996.f1)
            { /* block id: 648 */
                struct S0 *** const l_1023 = (void*)0;
                struct S0 *** const *l_1022 = &l_1023;
                int32_t l_1028 = 0x25F133F7;
                l_1054 = (safe_rshift_func_uint16_t_u_u((~(((l_1021 == l_1022) & ((safe_lshift_func_int16_t_s_s((safe_mod_func_int8_t_s_s((l_1028 <= (0xE2 <= l_996.f0)), (safe_add_func_uint32_t_u_u((l_1031[8][6][0] | (safe_rshift_func_uint8_t_u_u((safe_unary_minus_func_int8_t_s((safe_mod_func_uint32_t_u_u((safe_mod_func_int16_t_s_s((0x6A >= (safe_add_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(((safe_sub_func_int16_t_s_s(0x2147, (safe_mod_func_int16_t_s_s(((safe_mod_func_int8_t_s_s(((safe_add_func_uint8_t_u_u(((safe_add_func_uint16_t_u_u(((((l_1031[5][0][0] < g_66) != g_118.f2) >= g_118.f2) > p_43), g_934)) & p_43), 0xDF)) != 0x89), p_43)) ^ 0x8DF2A10B), l_1053)))) <= g_16[3][0][1]), g_110.f0)), g_755))), 65535U)), 6)))), 4))), l_1031[8][6][0])))), 9)) == p_45)) != l_996.f1)), g_118.f1));
            }
            else
            { /* block id: 650 */
                uint8_t l_1055 = 0x04;
                int32_t *l_1056 = &l_1053;
                (*l_1056) = l_1055;
            }
            if ((*p_44))
                continue;
        }
        for (g_934 = 8; (g_934 >= 2); g_934 -= 1)
        { /* block id: 657 */
            struct S0 **l_1060 = &l_997;
            struct S0 ***l_1059 = &l_1060;
            struct S0 ****l_1058[2];
            int32_t *l_1147 = (void*)0;
            int i, j;
            for (i = 0; i < 2; i = i + 1)
                l_1058[i] = &l_1059;
        }
    }
    l_1013 = 0x68E17AB1;
    return g_750;
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_66 g_320 g_321 g_118.f1 g_16 g_6 g_256 g_257 g_110.f2 g_110.f0 g_118.f2 g_80 g_118.f0 g_934 g_110.f1 g_110 g_750
 * writes: g_20 g_66 g_110.f2 g_322 g_255 g_110.f0 g_110.f1 g_118 g_750
 */
inline static int32_t  func_52(int16_t  p_53)
{ /* block id: 13 */
    int32_t l_54 = 1;
    int32_t *l_718 = (void*)0;
    uint16_t l_993[8] = {4U,65527U,4U,65527U,4U,65527U,4U,65527U};
    int8_t l_994 = 0x85;
    int16_t l_995 = 0x5C08;
    int i;
    l_995 = (((l_54 || (((!(((func_56(func_62(l_54), l_54, l_718, ((g_118.f2 == ((g_80 ^ g_118.f1) >= (p_53 ^ p_53))) || p_53), g_118.f0) ^ g_80) > 0xE166A0C7) != 9)) < g_16[0][0][0]) >= l_993[0])) | l_994) && l_993[1]);
    return l_993[0];
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_20 g_934 g_110.f0 g_256 g_257 g_118.f1 g_110.f2 g_110 g_118.f2 g_750 g_6 g_80 g_16 g_118.f0
 * writes: g_66 g_110.f1 g_110.f0 g_110.f2 g_118 g_750
 */
static uint8_t  func_56(int32_t * p_57, uint32_t  p_58, int32_t * p_59, uint16_t  p_60, uint32_t  p_61)
{ /* block id: 449 */
    struct S0 *l_721 = &g_110;
    struct S0 **l_720[2][6] = {{&l_721,&l_721,&l_721,&l_721,&l_721,&l_721},{&l_721,&l_721,&l_721,&l_721,&l_721,&l_721}};
    struct S0 ***l_719 = &l_720[1][5];
    int32_t *l_722 = &g_66;
    int32_t ***l_727 = &g_257[0][0][3];
    int32_t *****l_749[1][10] = {{&g_255[1][0],&g_255[1][3],&g_255[1][0],&g_255[1][3],&g_255[1][0],&g_255[1][3],&g_255[1][0],&g_255[1][3],&g_255[1][0],&g_255[1][3]}};
    int8_t l_813 = (-10);
    const int32_t * const *l_858 = (void*)0;
    const int32_t * const ** const l_857[8][2] = {{&l_858,&l_858},{&l_858,&l_858},{&l_858,&l_858},{&l_858,&l_858},{&l_858,&l_858},{&l_858,&l_858},{&l_858,&l_858},{&l_858,&l_858}};
    uint16_t l_862 = 65535U;
    uint8_t l_867[2][5] = {{247U,247U,247U,247U,247U},{0U,0U,0U,0U,0U}};
    struct S0 ****l_944 = &l_719;
    struct S0 **** const *l_943 = &l_944;
    int32_t l_950[7] = {0xD113A143,0xD113A143,0xD113A143,0xD113A143,0xD113A143,0xD113A143,0xD113A143};
    int32_t *l_960[5];
    int32_t ***l_979 = (void*)0;
    int8_t l_992[5][7][7] = {{{0,0x61,0,0xFD,0x61,0xE5,0x75},{0,0,0xCF,0x5C,7,(-1),0},{0x20,(-1),0x79,0x13,0xAD,9,0x19},{(-1),0xE5,0,0x19,(-1),0xB3,(-1)},{(-6),0x3E,0x41,0,3,0,0x41},{5,5,(-8),1,(-1),0xC0,0x19},{(-1),(-6),0x67,0,0x29,0,(-1)}},{{(-1),0xC3,0x72,(-1),(-1),0x29,0x42},{0,0x22,6,(-1),3,8,1},{0xA5,(-1),0,(-6),(-1),0x42,0x7C},{0xCF,0x19,0x72,0x79,0xE5,(-8),0xE7},{0,0xCF,3,(-1),0,0xFA,0},{(-6),(-7),1,(-1),0,9,0x56},{0xC0,0x6E,9,0,0xBC,9,0x6C}},{{0x29,0,0x13,0x41,(-1),0xFA,0xBC},{0,0x61,0x0A,0x29,1,(-8),0x24},{0xC3,0x56,0x79,0x61,0x5C,0xF5,1},{0xE4,0x24,0xC6,0xBC,0x72,(-1),0x72},{(-1),0xC0,0xC0,(-1),(-7),6,0},{(-8),0x56,0x6C,0xC3,0x29,0xE7,1},{(-6),0x41,0x22,0x3E,0xE4,0x16,0}},{{0xB3,0x80,0xF5,0x61,(-7),1,0x72},{1,0x6E,(-7),9,0x3E,0x6C,1},{0,0x3E,0xFD,0xE5,0xE4,3,0x24},{0x61,(-7),8,(-1),(-7),0xC0,0xBC},{0x61,(-7),0,0x80,0xCF,1,0x6C},{0,0x61,7,0x56,0x72,0,0x56},{0,0x79,0xF5,(-7),(-8),2,0}},{{0x61,0,(-7),0x73,0x61,1,0xE7},{0x61,1,0x8A,(-6),(-1),0xDF,(-6)},{0,(-1),0xC0,0x79,0,0x73,0},{1,0,0xDA,0xDA,0,1,0xF5},{0xB3,(-1),0x1F,(-6),0,0xC3,0x5C},{(-6),9,0x0A,0x72,1,0,(-7)},{(-8),(-1),1,0x5A,0x24,0x6C,9}}};
    int i, j, k;
    for (i = 0; i < 5; i = i + 1)
        l_960[i] = &g_16[1][4][1];
lbl_763:
    (*l_722) = (l_719 == &g_360);
    (*l_722) = (safe_sub_func_uint16_t_u_u(((*l_719) == (*l_719)), ((p_61 || (*l_722)) >= (safe_add_func_int32_t_s_s((*l_722), (*l_722))))));
    if (((*l_722) ^ ((l_727 == l_727) & g_20)))
    { /* block id: 452 */
        int16_t l_734 = (-9);
        int32_t l_751[7][7] = {{1,1,0xB22C7E0B,0xF9D10797,1,0xB22C7E0B,1},{0xF9D10797,(-1),(-1),0xF9D10797,1,4,0xF9D10797},{4,1,1,1,1,(-2),0xB22C7E0B},{1,(-1),1,4,4,1,(-1)},{1,0xB22C7E0B,(-2),1,0xFFBDC15E,0xFFBDC15E,1},{(-2),(-1),(-2),0xFFBDC15E,(-1),0xB22C7E0B,0xB22C7E0B},{(-1),1,1,1,(-1),1,4}};
        int32_t *l_795 = &g_80;
        uint8_t l_809 = 1U;
        const struct S0 *l_815 = &g_118;
        int32_t ****l_820[9] = {&l_727,&l_727,&l_727,&l_727,&l_727,&l_727,&l_727,&l_727,&l_727};
        uint8_t l_849 = 0x94;
        int i, j;
        for (p_58 = 0; (p_58 == 17); p_58 = safe_add_func_uint32_t_u_u(p_58, 9))
        { /* block id: 455 */
            int32_t l_735 = 6;
            int32_t l_748[4];
            struct S0 l_765 = {0x7AE7,0,0x768B6D5C};
            int32_t l_766 = 0x1F7F55F6;
            struct S0 ****l_818 = &l_719;
            struct S0 *****l_817 = &l_818;
            int32_t ****l_819 = &g_256;
            int32_t l_833 = 0x0F88D581;
            uint8_t l_886 = 0x01;
            int i;
            for (i = 0; i < 4; i = i + 1)
                l_748[i] = 0xF6814602;
        }
        p_57 = p_57;
    }
    else
    { /* block id: 574 */
        uint8_t l_929 = 247U;
        int32_t l_935 = (-1);
        l_935 = (((safe_mod_func_int32_t_s_s((((~p_60) ^ p_60) <= (+1)), (((((void*)0 == l_749[0][5]) && ((safe_sub_func_int16_t_s_s(p_58, l_929)) < (safe_rshift_func_int16_t_s_u((((safe_add_func_uint16_t_u_u(g_66, g_934)) <= p_60) != l_929), g_20)))) | g_110.f0) & p_61))) && 0x26) <= l_929);
    }
    for (g_110.f1 = 12; (g_110.f1 == (-23)); --g_110.f1)
    { /* block id: 579 */
        int32_t l_938 = 0xA1B443B9;
        const int32_t ****l_940 = (void*)0;
        const int32_t *****l_939 = &l_940;
        struct S0 ***** const l_945 = &l_944;
        int32_t l_991[4];
        int i;
        for (i = 0; i < 4; i = i + 1)
            l_991[i] = (-1);
        p_59 = func_67(((l_938 <= (p_58 | (l_939 == &l_940))) >= (safe_sub_func_int32_t_s_s((l_943 == l_945), ((safe_mod_func_uint32_t_u_u(((((void*)0 == (*g_256)) <= (safe_rshift_func_int16_t_s_s(g_118.f1, g_110.f2))) != p_61), (-5))) | 65535U)))), l_950[3], p_59, &l_938, p_61);
        /* statement id: 580 */
        assert ((p_59 >= &g_16[0][0][0] && p_59 <= &g_16[3][5][1]) || p_59 == 0);
        for (g_110.f0 = 0; (g_110.f0 >= 0); g_110.f0 -= 1)
        { /* block id: 583 */
            int32_t *l_951[10] = {&l_950[1],&g_16[0][1][1],&g_16[0][1][1],&l_950[1],&g_16[0][1][1],&g_16[0][1][1],&l_950[1],&g_16[0][1][1],&g_16[0][1][1],&l_950[1]};
            const struct S0 *l_961[3];
            int i, j;
            for (i = 0; i < 3; i = i + 1)
                l_961[i] = &g_118;
            for (g_110.f2 = 0; (g_110.f2 <= 0); g_110.f2 += 1)
            { /* block id: 586 */
                g_118 = (***l_719);
            }
            p_59 = l_951[5];
            /* statement id: 589 */
            assert ((p_59 >= &g_16[0][0][0] && p_59 <= &g_16[3][5][1]) || (p_59 >= &l_950[0] && p_59 <= &l_950[6]));
            for (p_58 = 0; (p_58 <= 0); p_58 += 1)
            { /* block id: 592 */
                int32_t *****l_952 = &g_255[1][3];
                struct S0 *l_954 = &g_118;
                int i, j;
                l_749[p_58][(p_58 + 4)] = l_952;
            }
        }
        /* facts after for loop */
        assert ((p_59 >= &g_16[0][0][0] && p_59 <= &g_16[3][5][1]) || (p_59 >= &l_950[0] && p_59 <= &l_950[6]) || p_59 == 0);
        if (p_58)
            break;
        for (p_60 = 0; (p_60 < 39); p_60 = safe_add_func_uint8_t_u_u(p_60, 2))
        { /* block id: 605 */
            uint8_t l_965 = 248U;
            int32_t ***l_974 = &g_257[0][0][3];
            (**l_719) = (****l_945);
            for (p_61 = 0; (p_61 <= 4); p_61 += 1)
            { /* block id: 609 */
                int32_t ***l_968 = &g_257[1][1][4];
                int8_t l_970[7] = {0,0x46,0,0,0x46,0,0};
                int i;
                for (g_118.f2 = 0; (g_118.f2 <= 0); g_118.f2 += 1)
                { /* block id: 612 */
                    return p_58;
                }
                if (l_965)
                { /* block id: 615 */
                    for (g_750 = 0; (g_750 <= 4); g_750 += 1)
                    { /* block id: 618 */
                        if (l_938)
                            goto lbl_763;
                    }
                    return p_60;
                }
                else
                { /* block id: 622 */
                    int32_t ***l_969 = &g_257[1][1][6];
                    l_970[3] = (safe_add_func_int8_t_s_s((l_968 == l_969), g_6));
                    for (g_750 = 0; (g_750 <= 4); g_750 += 1)
                    { /* block id: 626 */
                        uint32_t l_973[6];
                        int i;
                        for (i = 0; i < 6; i = i + 1)
                            l_973[i] = 1U;
                        (*l_722) = (safe_rshift_func_uint8_t_u_u(l_965, 2));
                        return l_973[4];
                    }
                }
            }
            p_57 = func_67((*l_722), (((((l_974 == l_974) | (safe_rshift_func_uint8_t_u_s((((((65535U >= ((void*)0 != l_979)) <= (p_61 <= (safe_add_func_int32_t_s_s((((((safe_mod_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((0x8039D4A6 > ((((safe_rshift_func_uint16_t_u_u((!p_58), g_118.f2)) >= p_58) && p_61) >= g_118.f2)), p_60)), g_80)) != p_61) > g_80) ^ 0) & g_16[1][2][1]), p_61)))) && g_118.f0) || p_61) > 0xFE89BF2A), p_61))) || 0U) < p_61) < g_118.f0), p_59, p_59, l_991[0]);
            /* statement id: 632 */
            assert ((p_57 >= &g_16[0][0][0] && p_57 <= &g_16[3][5][1]) || p_57 == 0);
            if (l_992[0][4][5])
                continue;
        }
    }
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_66 g_320 g_321 g_118.f1 g_16 g_6 g_256 g_257 g_110.f2 g_110.f0
 * writes: g_20 g_66 g_110.f2 g_322 g_255 g_110.f0
 */
static int32_t * func_62(uint8_t  p_63)
{ /* block id: 14 */
    int32_t l_64[8][4] = {{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)},{(-4),(-4),(-4),(-4)}};
    int32_t l_65 = (-5);
    int32_t ***l_527 = &g_257[0][0][3];
    int32_t *****l_549 = &g_255[0][7];
    struct S0 *l_566 = &g_118;
    int32_t *l_587 = &l_65;
    struct S0 **l_601 = &l_566;
    struct S0 ***l_600 = &l_601;
    struct S0 ****l_599 = &l_600;
    int32_t l_617[2][5] = {{(-1),(-1),(-1),(-1),(-1)},{(-1),(-1),(-1),(-1),(-1)}};
    int32_t *l_644 = (void*)0;
    struct S0 * const *l_716 = &l_566;
    int32_t *l_717 = &g_16[0][1][1];
    int i, j;
    for (g_20 = 3; (g_20 >= 0); g_20 -= 1)
    { /* block id: 17 */
        int32_t *l_73 = (void*)0;
        l_65 = p_63;
        for (p_63 = 0; (p_63 <= 3); p_63 += 1)
        { /* block id: 21 */
            int32_t *l_520 = &g_20;
            for (l_65 = 0; (l_65 <= 3); l_65 += 1)
            { /* block id: 24 */
                int i, j;
                if (l_64[(g_20 + 2)][g_20])
                    break;
                for (g_66 = 3; (g_66 >= 0); g_66 -= 1)
                { /* block id: 28 */
                    int32_t *l_519 = &g_80;
                    int i, j;
                    l_519 = func_67(l_64[(g_66 + 4)][g_20], l_64[(g_66 + 4)][g_20], &g_16[3][3][0], l_73, p_63);
                    /* statement id: 307 */
                    assert ((l_519 >= &g_16[0][0][0] && l_519 <= &g_16[3][5][1]) || l_519 == 0);
                }
            }
            return l_520;
            /* statement id: 310 */
            //assert (func_62_rv == &g_20);
        }
    }
    if (((safe_sub_func_int8_t_s_s((-1), p_63)) && (((void*)0 != (*g_320)) > ((safe_sub_func_int16_t_s_s(((safe_add_func_int8_t_s_s(((g_118.f1 || g_16[3][4][1]) < (l_527 != l_527)), ((safe_sub_func_uint32_t_u_u(((~p_63) >= 2), 0x6BAE004E)) ^ 0x05762946))) != 1U), p_63)) <= 0x98))))
    { /* block id: 313 */
        const int32_t l_542 = (-8);
        for (g_66 = 0; (g_66 > 4); g_66 = safe_add_func_int32_t_s_s(g_66, 1))
        { /* block id: 316 */
            int32_t l_543 = (-7);
            int32_t *l_550 = &l_543;
            (*l_550) = (((safe_mod_func_int32_t_s_s(((safe_mod_func_uint32_t_u_u(g_16[0][1][1], (safe_add_func_uint32_t_u_u((safe_unary_minus_func_int32_t_s(l_542)), l_543)))) == ((safe_unary_minus_func_int32_t_s((((safe_add_func_uint8_t_u_u(g_6, ((*g_256) != (void*)0))) & 0U) == l_542))) > (&g_317[8][0] == l_549))), l_543)) | p_63) | g_6);
        }
    }
    else
    { /* block id: 319 */
        int32_t l_551 = 0;
        int32_t **** const *l_552 = &g_255[1][3];
        int32_t *l_555 = &g_66;
        struct S0 * const l_590 = &g_110;
        const uint8_t l_641 = 7U;
        int16_t l_669 = 0xC5E3;
        int32_t l_683[4] = {0x81921F77,0x81921F77,0x81921F77,0x81921F77};
        uint8_t l_696 = 0xB5;
        struct S0 * const *l_715 = (void*)0;
        struct S0 * const **l_714[3];
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_714[i] = &l_715;
        if ((l_551 & (l_552 != &g_317[8][0])))
        { /* block id: 320 */
            int32_t *l_553[9];
            int32_t **l_554[1][5][9] = {{{&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19},{&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19},{&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19},{&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19},{&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19,&l_553[5],&g_19,&g_19}}};
            int32_t l_579 = 0;
            struct S0 l_583 = {0xE9C0,-1,0x91747C4D};
            struct S0 **l_627 = (void*)0;
            int32_t *l_631 = &g_20;
            int32_t *l_632 = &g_16[0][1][1];
            int32_t *****l_663[2][2];
            int i, j, k;
            for (i = 0; i < 9; i = i + 1)
                l_553[i] = &g_80;
            for (i = 0; i < 2; i = i + 1)
            {
                for (j = 0; j < 2; j = j + 1)
                    l_663[i][j] = &g_255[1][3];
            }
            l_555 = l_553[5];
            /* statement id: 321 */
            assert (l_555 == &g_80);
            for (g_110.f2 = (-11); (g_110.f2 != 43); g_110.f2 = safe_add_func_int8_t_s_s(g_110.f2, 6))
            { /* block id: 324 */
                int32_t *l_568 = &g_66;
                struct S0 l_628 = {1,0xAC8007F8,0x41A3404E};
            }
            l_587 = l_632;
            /* statement id: 383 */
            assert ((l_587 >= &g_16[0][0][0] && l_587 <= &g_16[3][5][1]));
            for (l_551 = 0; (l_551 <= 1); l_551 += 1)
            { /* block id: 386 */
                int8_t l_642 = 0;
                int32_t *l_643 = (void*)0;
                uint8_t l_651 = 8U;
                struct S0 *l_692 = &g_118;
                int32_t l_706[3];
                int i;
                for (i = 0; i < 3; i = i + 1)
                    l_706[i] = (-9);
            }
        }
        else
        { /* block id: 436 */
            struct S0 *l_707 = &g_118;
            int32_t *l_708 = &g_16[3][4][0];
            (**g_320) = l_707;
            /* statement id: 437 */
            assert (g_322 == &g_118);
            return l_708;
            /* statement id: 438 */
            //assert ((func_62_rv >= &g_16[0][0][0] && func_62_rv <= &g_16[3][5][1]));
        }
        /* facts after branching */
        assert (l_555 == &g_80);
        assert ((l_587 >= &g_16[0][0][0] && l_587 <= &g_16[3][5][1]));
        (*l_549) = &g_256;
        for (g_110.f0 = 0; (g_110.f0 <= (-14)); --g_110.f0)
        { /* block id: 443 */
            int32_t *l_711 = &l_683[3];
            int32_t *l_712[7][6] = {{(void*)0,(void*)0,(void*)0,(void*)0,&g_20,(void*)0},{(void*)0,&g_20,(void*)0,(void*)0,(void*)0,(void*)0},{&g_20,&g_20,(void*)0,&g_16[0][1][1],(void*)0,&g_20},{(void*)0,&g_20,&g_16[0][1][1],&g_16[0][1][1],&g_20,(void*)0},{&g_20,(void*)0,&g_16[0][1][1],(void*)0,&g_20,&g_20},{(void*)0,(void*)0,(void*)0,(void*)0,&g_20,(void*)0},{(void*)0,&g_20,(void*)0,(void*)0,(void*)0,(void*)0}};
            int32_t *l_713 = (void*)0;
            int i, j;
            return l_713;
            /* statement id: 444 */
            //assert (func_62_rv == 0);
        }
        l_716 = &l_590;
        /* statement id: 446 */
        assert (l_716 == &l_590);
    }
    /* facts after branching */
    assert ((l_587 >= &g_16[0][0][0] && l_587 <= &g_16[3][5][1]) || l_587 == &l_65);
    //assert (l_716 == dangling || l_716 == &l_566);
    return l_717;
    /* statement id: 448 */
    //assert ((func_62_rv >= &g_16[0][0][0] && func_62_rv <= &g_16[3][5][1]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_67(int32_t  p_68, uint8_t  p_69, int32_t * p_70, int32_t * p_71, int32_t  p_72)
{ /* block id: 29 */
    int32_t *l_74 = &g_66;
    int32_t *l_128 = &g_80;
    struct S0 *l_170 = &g_110;
    int32_t l_192[8][1][1];
    int32_t * const *l_197 = &l_128;
    int32_t * const * const *l_196 = &l_197;
    int32_t * const * const **l_195[4][3];
    const int32_t ****l_323 = (void*)0;
    int16_t l_332 = (-4);
    int32_t l_376 = (-1);
    uint32_t l_377 = 0xA793669B;
    int32_t *l_385 = &l_192[4][0][0];
    const int32_t *l_386 = &g_66;
    struct S0 **l_419[5][10] = {{&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170},{&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170},{&l_170,&l_170,&l_170,&l_170,&l_170,(void*)0,&l_170,&l_170,&l_170,&l_170},{&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170},{&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170,&l_170}};
    struct S0 ***l_418 = &l_419[2][8];
    int8_t l_511 = 2;
    uint16_t l_517 = 0x981B;
    int32_t *l_518[9][4] = {{(void*)0,(void*)0,&g_16[0][1][1],(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,&g_16[0][1][1],(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,&g_16[0][1][1],(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0}};
    int i, j, k;
    for (i = 0; i < 8; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
        {
            for (k = 0; k < 1; k = k + 1)
                l_192[i][j][k] = 0x8EFB34F4;
        }
    }
    for (i = 0; i < 4; i = i + 1)
    {
        for (j = 0; j < 3; j = j + 1)
            l_195[i][j] = &l_196;
    }
    return l_518[3][0];
    /* statement id: 306 */
    //assert ((func_67_rv >= &g_16[0][0][0] && func_67_rv <= &g_16[3][5][1]) || func_67_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_6, "g_6", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        for (j = 0; j < 6; j = j + 1)
        {
            for (k = 0; k < 2; k = k + 1)
            {
                transparent_crc(g_16[i][j][k], "g_16[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_20, "g_20", print_hash_value);
    transparent_crc(g_66, "g_66", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_110.f0, "g_110.f0", print_hash_value);
    transparent_crc(g_110.f1, "g_110.f1", print_hash_value);
    transparent_crc(g_110.f2, "g_110.f2", print_hash_value);
    transparent_crc(g_118.f0, "g_118.f0", print_hash_value);
    transparent_crc(g_118.f1, "g_118.f1", print_hash_value);
    transparent_crc(g_118.f2, "g_118.f2", print_hash_value);
    transparent_crc(g_750, "g_750", print_hash_value);
    transparent_crc(g_755, "g_755", print_hash_value);
    transparent_crc(g_934, "g_934", print_hash_value);
    transparent_crc(g_1286, "g_1286", print_hash_value);
    transparent_crc(g_1331, "g_1331", print_hash_value);
    transparent_crc(g_1371, "g_1371", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 346
   depth: 1, occurrence: 21
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 50
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 6, occurrence: 4
   depth: 7, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 2
   depth: 31, occurrence: 2
   depth: 35, occurrence: 1

XXX total number of pointers: 285

XXX times a variable address is taken: 788
XXX times a pointer is dereferenced on RHS: 169
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 26
   depth: 3, occurrence: 7
   depth: 4, occurrence: 7
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 124
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 19
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 66
XXX times a pointer is compared with address of another variable: 27
XXX times a pointer is compared with another pointer: 41
XXX times a pointer is qualified to be dereferenced: 2871

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 439
   level: 2, occurrence: 209
   level: 3, occurrence: 147
   level: 4, occurrence: 69
   level: 5, occurrence: 40
XXX number of pointers point to pointers: 148
XXX number of pointers point to scalars: 98
XXX number of pointers point to structs: 39
XXX percent of pointers has null in alias set: 34
XXX average alias set size: 1.57

XXX times a non-volatile is read: 1551
XXX times a non-volatile is write: 533
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 17

XXX stmts: 154
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 29
   depth: 2, occurrence: 32
   depth: 3, occurrence: 25
   depth: 4, occurrence: 23
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 15.1
XXX percentage an existing variable is used: 84.9
********************* end of statistics **********************/

