/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1834148576
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_29(void);
static int32_t * func_30(uint32_t  p_31, const uint16_t  p_32, const int32_t * p_33);
inline static uint16_t  func_38(int32_t * p_39, int32_t  p_40);
inline static const int32_t * func_56(int32_t * p_57, uint8_t  p_58, const float * p_59, int32_t  p_60, uint32_t  p_61);
static int32_t * func_62(int32_t  p_63, int16_t  p_64, uint32_t  p_65, int32_t * p_66, uint16_t  p_67);
static int32_t * func_72(float * p_73, int32_t * p_74, uint16_t  p_75, int32_t  p_76, int32_t  p_77);
inline static int32_t * func_78(int16_t  p_79);
static int64_t  func_80(uint64_t  p_81, int16_t  p_82, uint32_t  p_83, int64_t  p_84, float  p_85);
inline static float  func_111(int32_t * p_112);
inline static int32_t * func_113(int32_t * p_114, int32_t * p_115, uint32_t  p_116, int32_t  p_117);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_29(void)
{ /* block id: 36 */
    uint16_t l_34 = 0x4307L;
    const int32_t *l_35 = (void*)0;
    int32_t l_336 = 0x9D45B81CL;
    int32_t *l_335 = &l_336;
    int32_t **l_334 = &l_335;
    float l_340 = (-0x1.4p+1);
    float *l_339 = &l_340;
    (*l_334) = func_30(l_34, l_34, l_35);
    /* statement id: 165 */
    assert (l_335 == 0);
    (*l_339) = ((0x0.3p+1 < __builtin_clzl(((int16_t)l_336 << (int16_t)13))) >= __builtin_clz(l_34));
    return l_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(uint32_t  p_31, const uint16_t  p_32, const int32_t * p_33)
{ /* block id: 37 */
    int32_t l_37 = 1L;
    int32_t *l_36 = &l_37;
    int32_t l_42 = 6L;
    const float l_43 = 0x2.31EA06p+28;
    float l_88 = 0x1.5p-1;
    int32_t l_315 = 0L;
    float *l_325 = &l_88;
    float *l_330 = &l_88;
    int32_t *l_333 = (void*)0;
    if (((p_33 != l_36) != ((p_32 & __builtin_popcountl(p_32)) & ((((((-1L) >= func_38(&l_37, ((*l_36) >= ((*l_36) <= p_31)))) | l_42) == p_31) >= 0x6DD3ED23C5AD058BLL) ^ 0x58ED0BD2F23D37F4LL))))
    { /* block id: 41 */
        uint64_t l_53 = 8UL;
        int32_t **l_308 = &l_36;
        float *l_323 = &l_88;
        for (l_37 = (-13); (l_37 != 0); l_37 += 1)
        { /* block id: 44 */
            float l_47 = 0x3.263393p-51;
            float *l_46 = &l_47;
            int32_t l_48 = 1L;
            (*l_46) = 0x1.9634D7p-98;
            (*l_46) = l_48;
            (*l_46) = (((float)(0x0.3F8DE9p+85 >= p_32) + (float)(0x5.2097E6p-11 > ((((float)(l_53 == p_31) / (float)((float)(-0x6.1p+1) - (float)(((0xC.20A048p+93 == p_31) != ((l_48 < (-0x5.9p-1)) >= (-0x9.0p-1))) == p_31))) >= l_53) >= p_32))) != l_48);
        }
        (*l_308) = func_56(func_62(p_32, ((+p_32) >= ((((uint16_t)l_53 << (uint16_t)6) != (*l_36)) > (+0x2303L))), ((*l_36) & 5L), func_72(l_36, func_78(((func_80(((int32_t)(*l_36) + (int32_t)4L), (*l_36), p_32, p_32, (*l_36)) >= (*l_36)) >= l_53)), (*l_36), l_53, l_53), (*l_36)), (*l_36), p_33, p_32, l_53);
        /* statement id: 156 */
        assert (l_36 == 0);
        (*l_323) = (p_31 > ((float)((float)((float)(l_315 >= ((-(float)0x9.EEFEA8p+70) != (p_32 >= p_32))) - (float)(((float)(!(p_31 == (p_31 > ((+(((float)p_32 / (float)p_32) < p_32)) >= p_31)))) + (float)0x6.E7ADD0p+25) >= p_32)) + (float)p_31) + (float)0xB.741E85p-88));
    }
    else
    { /* block id: 158 */
        const int32_t *l_324 = &l_37;
        l_324 = p_33;
        /* statement id: 159 */
        assert (l_324 == 0);
    }
    /* facts after branching */
    assert (l_36 == &l_37 || l_36 == 0);
    (*l_325) = l_315;
    p_33 = &l_315;
    /* statement id: 162 */
    assert (p_33 == &l_315);
    (*l_330) = ((float)(((float)(p_33 != l_330) - (float)((float)p_31 - (float)(((-0x5.Dp-1) == p_32) <= ((-0x3.8p-1) == func_38(&l_42, l_37))))) > 0x7.DE4146p+90) / (float)0xD.B52019p+96);
    return l_333;
    /* statement id: 164 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_96 p_76
 */
inline static uint16_t  func_38(int32_t * p_39, int32_t  p_40)
{ /* block id: 38 */
    const int16_t l_41 = (-1L);
    (*p_39) = l_41;
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_56(int32_t * p_57, uint8_t  p_58, const float * p_59, int32_t  p_60, uint32_t  p_61)
{ /* block id: 143 */
    uint32_t l_298 = 0xCEA1EC8DL;
    const int32_t l_300 = 1L;
    const int32_t *l_299 = &l_300;
    const int32_t *l_302 = &l_300;
    const int32_t *l_303 = (void*)0;
    if ((0xAF2F86AFL && ((uint16_t)(0x24E9D99575F59378LL ^ 0x4BE17463E53FBDC8LL) - (uint16_t)__builtin_parity(l_298))))
    { /* block id: 144 */
        const int32_t *l_301 = &l_300;
        return l_303;
        /* statement id: 145 */
        //assert (func_56_rv == 0);
    }
    else
    { /* block id: 146 */
        const int32_t *l_307 = (void*)0;
        for (l_298 = 0; (l_298 >= 41); l_298++)
        { /* block id: 149 */
            int32_t l_306 = 0xEC65FD91L;
            if (p_61)
                break;
            if (l_306)
                continue;
            if ((*l_302))
                break;
        }
        return l_307;
        /* statement id: 154 */
        //assert (func_56_rv == 0);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(int32_t  p_63, int16_t  p_64, uint32_t  p_65, int32_t * p_66, uint16_t  p_67)
{ /* block id: 140 */
    float l_282 = 0x1.D245C5p-93;
    float *l_281 = &l_282;
    float **l_280 = &l_281;
    const int32_t l_285 = 9L;
    int32_t *l_288 = (void*)0;
    int32_t l_290 = 0L;
    int32_t *l_289 = &l_290;
    int32_t *l_291 = &l_290;
    int32_t *l_292 = &l_290;
    int32_t *l_293 = &l_290;
    int32_t *l_294 = &l_290;
    int32_t *l_295 = (void*)0;
    (*l_289) = ((uint16_t)(p_63 || (p_67 <= (l_280 == (void*)0))) << (uint16_t)((uint16_t)l_285 + (uint16_t)((uint16_t)l_285 << (uint16_t)7)));
    return l_295;
    /* statement id: 142 */
    //assert (func_62_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_72(float * p_73, int32_t * p_74, uint16_t  p_75, int32_t  p_76, int32_t  p_77)
{ /* block id: 128 */
    int32_t l_254 = 6L;
    int32_t l_257 = 0L;
    int32_t *l_259 = &l_257;
    int32_t **l_258 = &l_259;
    float l_265 = 0x2.D9ACFFp-9;
    float *l_264 = &l_265;
    int32_t *l_269 = &l_257;
    int32_t *l_271 = (void*)0;
    int32_t *l_272 = &l_257;
    int32_t *l_273 = &l_257;
    int32_t *l_274 = &l_257;
    int32_t *l_275 = &l_257;
    int32_t *l_276 = &l_257;
    int32_t *l_277 = (void*)0;
    l_257 = ((l_254 | 0L) ^ (p_75 < ((int16_t)(-1L) >> (int16_t)l_254)));
    (*l_258) = &p_76;
    /* statement id: 130 */
    assert (l_259 == &p_76);
    (*l_264) = (((float)(((float)func_111(func_113((*l_258), &p_76, p_77, ((3UL > ((void*)0 != &p_74)) < (*l_259)))) + (float)(*p_73)) <= 0x9.Ap+1) - (float)(*p_73)) >= (*p_73));
    if (__builtin_ctzl(func_38((*l_258), (func_38((*l_258), ((*l_259) && ((int16_t)0L << (int16_t)(((void*)0 == &l_258) > p_76)))) < (p_75 <= 0xAE87L)))))
    { /* block id: 132 */
        int32_t *l_268 = &l_257;
        int32_t *l_270 = &l_257;
        (*l_258) = &p_76;
        return l_271;
        /* statement id: 134 */
        //assert (func_72_rv == 0);
    }
    else
    { /* block id: 135 */
        p_74 = &p_76;
        /* statement id: 136 */
        assert (p_74 == &p_76);
        (*l_258) = &p_76;
    }
    /* facts after branching */
    assert (p_74 == &p_76);
    return l_277;
    /* statement id: 139 */
    //assert (func_72_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_78(int16_t  p_79)
{ /* block id: 115 */
    const uint32_t l_232 = 0x7743CD8DL;
    int32_t l_234 = 1L;
    int32_t *l_233 = &l_234;
    int32_t *l_246 = &l_234;
    int32_t *l_247 = &l_234;
    int32_t *l_248 = &l_234;
    int32_t *l_249 = &l_234;
    int32_t *l_250 = &l_234;
    int32_t *l_251 = (void*)0;
    (*l_233) = (((uint16_t)p_79 + (uint16_t)(~__builtin_ffsll(p_79))) != l_232);
    for (p_79 = 0; (p_79 != (-10)); p_79 -= 5)
    { /* block id: 119 */
        int32_t **l_245 = &l_233;
        for (l_234 = 28; (l_234 > (-13)); l_234 -= 4)
        { /* block id: 122 */
            float l_242 = 0xB.64F655p-23;
            float *l_241 = &l_242;
            float **l_240 = &l_241;
            float ***l_239 = &l_240;
            float ** const *l_244 = &l_240;
            float ** const **l_243 = &l_244;
            (*l_243) = l_239;
        }
        (*l_245) = &l_234;
    }
    return l_251;
    /* statement id: 127 */
    //assert (func_78_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_80(uint64_t  p_81, int16_t  p_82, uint32_t  p_83, int64_t  p_84, float  p_85)
{ /* block id: 49 */
    int32_t l_96 = 0x66A4358BL;
    int32_t *l_118 = &l_96;
    int32_t *l_220 = &l_96;
    float **l_224 = (void*)0;
    if (p_84)
    { /* block id: 50 */
        uint32_t l_92 = 0UL;
        float l_102 = 0x7.693CDBp-49;
        float *l_101 = &l_102;
        uint16_t l_121 = 0x0016L;
        (*l_101) = ((-(float)(((float)l_92 + (float)(!p_82)) >= (((float)l_96 - (float)((&l_96 != &l_96) >= ((float)((float)p_81 / (float)(l_96 > ((void*)0 != &l_96))) - (float)0x8.261810p-61))) < p_84))) == p_85);
        (*l_101) = (((float)(((float)((float)((float)((func_111(func_113(&l_96, &l_96, func_38(l_118, ((p_82 | (l_121 <= (*l_118))) | (((int16_t)8L >> (int16_t)8) | (*l_118)))), l_121)) <= 0xB.157731p-53) <= 0x9.620FE3p+56) - (float)0xA.043A1Fp-33) - (float)l_92) / (float)p_84) <= p_84) / (float)p_84) != p_82);
    }
    else
    { /* block id: 71 */
        uint64_t l_172 = 1UL;
        int32_t l_183 = 0xB33A3617L;
        int32_t *l_182 = &l_183;
        int32_t **l_223 = &l_118;
        int32_t ***l_222 = &l_223;
        float l_228 = (-0x1.Bp+1);
        const float *l_227 = &l_228;
        const float **l_226 = &l_227;
        const float ***l_225 = &l_226;
        if (l_172)
        { /* block id: 72 */
            float l_173 = 0x0.9p+1;
            int32_t l_174 = 0x14779B98L;
            l_174 = ((*l_118) > ((1L > l_172) != p_81));
            return l_172;
        }
        else
        { /* block id: 75 */
            int32_t *l_190 = (void*)0;
            int64_t l_211 = 0xCF306C016F782758LL;
            if (((*l_118) ^ 0xB74EB91FBA64A4A9LL))
            { /* block id: 76 */
                int32_t *l_191 = &l_183;
                float l_199 = 0x2.419DF0p-95;
                float *l_198 = &l_199;
                for (l_96 = 4; (l_96 != (-26)); l_96 -= 5)
                { /* block id: 79 */
                    int32_t *l_181 = &l_96;
                    for (p_81 = (-4); (p_81 >= 53); ++p_81)
                    { /* block id: 82 */
                        int32_t **l_179 = (void*)0;
                        int32_t **l_180 = &l_118;
                        (*l_180) = (void*)0;
                        /* statement id: 83 */
                        assert (l_118 == 0);
                    }
                    l_182 = l_181;
                    /* statement id: 85 */
                    assert (l_182 == &l_96);
                    p_85 = (0xB.32B9FEp-44 <= ((float)p_85 / (float)((float)p_82 + (float)((-0x6.6p+1) <= ((((float)(l_190 == l_191) / (float)(((float)((float)((((float)(*l_191) - (float)((void*)0 == l_181)) == (*l_181)) >= (-0x1.7p-1)) + (float)0x0.8p-1) - (float)0x2.Ap-1) < (-0x7.2p+1))) <= p_82) < 0xB.E2A20Ap-0)))));
                    (*l_191) = 1L;
                }
                /* facts after for loop */
                assert (l_118 == 0 || l_118 == &l_96);
                assert (l_182 == &l_96 || l_182 == &l_183);
                (*l_182) = ((&l_96 != &l_96) && (*l_191));
                (*l_198) = (*l_182);
                return p_82;
            }
            else
            { /* block id: 92 */
                int32_t * const *l_207 = (void*)0;
                int32_t **l_221 = &l_220;
                for (l_96 = 0; (l_96 < 28); l_96++)
                { /* block id: 95 */
                    int32_t l_206 = 0xC99DD4A8L;
                    float l_209 = 0xD.D859D8p-91;
                    float *l_208 = &l_209;
                    int32_t *l_212 = (void*)0;
                    int64_t l_213 = 0x58001A0E296350F6LL;
                    (*l_208) = ((0x0.2p+1 >= 0x7.E3C26Fp-49) < ((float)(((float)0x6.5A54E7p-24 + (float)(*l_182)) <= l_206) - (float)(0x9.BE310Ap-10 <= ((void*)0 != l_207))));
                    l_212 = func_113(l_190, l_208, (~l_206), l_211);
                    /* statement id: 97 */
                    assert (l_212 == &l_209);
                    (*l_212) = l_213;
                    (*l_208) = (*l_212);
                }
                for (l_183 = 19; (l_183 >= (-3)); l_183 -= 1)
                { /* block id: 103 */
                    int32_t **l_219 = &l_182;
                    (*l_118) = ((!6UL) != ((uint16_t)(l_118 != l_118) << (uint16_t)6));
                    (*l_219) = (void*)0;
                    /* statement id: 105 */
                    assert (l_182 == 0);
                }
                /* facts after for loop */
                assert (l_182 == 0 || l_182 == &l_183);
                (*l_221) = l_220;
            }
            /* facts after branching */
            assert (l_182 == 0 || l_182 == &l_183);
        }
        /* facts after branching */
        assert (l_182 == 0 || l_182 == &l_183);
        (*l_222) = &l_220;
        /* statement id: 110 */
        assert (l_223 == &l_220);
        (*l_225) = l_224;
        /* statement id: 111 */
        assert (l_226 == 0);
        l_220 = (void*)0;
        /* statement id: 112 */
        assert (l_220 == 0);
    }
    /* facts after branching */
    assert (l_220 == 0 || l_220 == &l_96);
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_111(int32_t * p_112)
{ /* block id: 60 */
    uint8_t l_141 = 0UL;
    uint16_t l_155 = 0x54EFL;
    float l_167 = 0x1.6p-1;
    float *l_166 = &l_167;
    if (l_141)
    { /* block id: 61 */
        uint32_t l_142 = 3UL;
        float l_157 = 0x4.40FDB0p+86;
        float *l_156 = &l_157;
        l_142 = (*p_112);
        (*l_156) = (((float)(((float)(__builtin_clz(((uint16_t)((int16_t)(l_141 <= ((uint64_t)0x2835E52A12E21983LL - (uint64_t)0L)) + (int16_t)(l_142 != ((int16_t)l_141 << (int16_t)12))) >> (uint16_t)1)) < 0x1.E841A1p-98) - (float)__builtin_ctzl(l_142)) > 0xF.7C9A86p-31) + (float)l_141) != l_155);
        (*p_112) = (l_155 < (func_38(p_112, (((uint16_t)((int16_t)((uint16_t)(((int32_t)(func_38(p_112, ((l_166 != (void*)0) != ((uint32_t)0UL - (uint32_t)(((p_112 != p_112) == 1L) >= l_155)))) != l_142) / (int32_t)l_142) ^ l_142) + (uint16_t)0xB163L) - (int16_t)l_142) + (uint16_t)0x543FL) < l_155)) >= l_142));
    }
    else
    { /* block id: 65 */
        int32_t *l_171 = (void*)0;
        int32_t **l_170 = &l_171;
        (*l_170) = p_112;
        /* statement id: 66 */
        //assert (l_171 == &l_96 || l_171 == &p_76);
    }
    p_112 = p_112;
    return l_141;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_113(int32_t * p_114, int32_t * p_115, uint32_t  p_116, int32_t  p_117)
{ /* block id: 52 */
    float l_137 = (-0x1.7p+1);
    float *l_136 = &l_137;
    int32_t l_138 = 0L;
    for (p_116 = 9; (p_116 == 5); p_116 -= 8)
    { /* block id: 55 */
        float l_127 = 0x1.5F43E0p+27;
        float *l_126 = &l_127;
        (*l_126) = p_116;
    }
    (*p_115) = ((uint16_t)(((0x63A29C5DL && 4294967288UL) ^ ((uint32_t)((-6L) != ((uint32_t)((int16_t)(l_136 == p_115) + (int16_t)l_138) / (uint32_t)((uint32_t)(l_138 == l_138) + (uint32_t)((*p_115) | l_138)))) % (uint32_t)(*p_115))) ^ p_117) << (uint16_t)6);
    return p_115;
    /* statement id: 59 */
    //assert (func_113_rv == &l_96 || func_113_rv == &l_209 || func_113_rv == &p_76);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 80
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 94

XXX times a variable address is taken: 84
XXX times a pointer is dereferenced on RHS: 34
breakdown:
   depth: 1, occurrence: 34
XXX times a pointer is dereferenced on LHS: 37
breakdown:
   depth: 1, occurrence: 37
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 144

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 98
   level: 2, occurrence: 8
XXX number of pointers point to pointers: 20
XXX number of pointers point to scalars: 74
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 34
XXX average alias set size: 1.23

XXX times a non-volatile is read: 279
XXX times a non-volatile is write: 94
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 81
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 24
   depth: 2, occurrence: 10
   depth: 3, occurrence: 7
   depth: 4, occurrence: 10
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 12.2
XXX percentage an existing variable is used: 87.8
********************* end of statistics **********************/

