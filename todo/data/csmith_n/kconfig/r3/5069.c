/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2313804879
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   unsigned f2 : 13;
   const signed f3 : 27;
   int32_t  f4;
   const uint32_t  f5;
   const unsigned f6 : 20;
   int32_t  f7;
   int32_t  f8;
};
#pragma pack(pop)

union U1 {
   uint16_t  f0;
   uint32_t  f1;
};

union U2 {
   uint32_t  f0;
   int16_t  f1;
   const int32_t  f2;
};

union U3 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_35(void);
static float  func_50(float  p_51, uint32_t  p_52, int32_t * p_53, int32_t * p_54, int32_t * p_55);
static int32_t * func_56(int32_t * p_57, union U1  p_58, int16_t  p_59, struct S0  p_60);
inline static int32_t * func_61(uint32_t  p_62);
inline static int32_t * func_64(uint32_t  p_65, const int32_t * p_66);
inline static const int32_t * func_67(int32_t * p_68, float  p_69, uint32_t  p_70, uint32_t  p_71);
inline static int32_t  func_74(struct S0  p_75);
static struct S0  func_76(int32_t * p_77, float  p_78);
static int32_t * func_79(float  p_80, int32_t * p_81, uint32_t  p_82);
static float  func_83(union U2  p_84, uint32_t  p_85, const uint32_t  p_86, union U1  p_87, int32_t * p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(void)
{ /* block id: 36 */
    int32_t l_37 = 0;
    int32_t *l_36 = &l_37;
    struct S0 l_1051 = {0xF15A4238,1U,8,-10505,-1,0xFA954BBA,615,8,0xCFB3D05F};
    union U1 l_1216 = {0x4624};
    union U1 * const l_1215 = &l_1216;
    int32_t l_1230 = 1;
    l_36 = (void*)0;
    /* statement id: 37 */
    assert (l_36 == 0);
    for (l_37 = (-1); (l_37 >= 23); ++l_37)
    { /* block id: 40 */
        int32_t l_40 = 0x3650DFA0;
        union U1 l_1050 = {0x5B88};
        for (l_40 = 0; (l_40 < 6); l_40 += 1)
        { /* block id: 43 */
            return l_40;
        }
        if (l_37)
            continue;
        for (l_40 = 0; (l_40 >= 29); l_40++)
        { /* block id: 49 */
            int32_t l_45 = 0x3421AD7B;
            float l_1199 = 0x4.39CA9Dp-92;
            float *l_1198 = &l_1199;
            for (l_45 = 0; (l_45 < 19); l_45 += 4)
            { /* block id: 52 */
                int32_t l_49 = 0;
                int32_t *l_48 = &l_49;
                (*l_48) = l_40;
            }
            if (l_40)
                continue;
            (*l_1198) = (0x2.C51723p+12 == (func_50(((0x0.50BA43p+50 < ((void*)0 != &l_45)) == (&l_37 == &l_40)), l_40, func_56(func_61(l_45), l_1050, l_45, l_1051), &l_40, &l_37) >= l_45));
        }
    }
    for (l_37 = 0; (l_37 <= 23); l_37 += 6)
    { /* block id: 724 */
        int32_t l_1212 = 0;
        union U1 *l_1217 = &l_1216;
        int32_t *l_1221 = &l_1212;
        int32_t l_1229 = 0;
        struct S0 l_1233 = {0U,0xB1B536E1,46,2122,0xC37BFA85,0x4C7CEB3B,743,1,0x6E90074C};
        for (l_1051.f1 = 0; (l_1051.f1 != 60); l_1051.f1 += 6)
        { /* block id: 727 */
            const float l_1204 = 0xD.6740E6p-24;
            int32_t l_1205 = 0;
            const int32_t l_1213 = 0xCFBFE820;
            struct S0 ***l_1214 = (void*)0;
            if (l_1205)
            { /* block id: 728 */
                union U2 l_1207 = {0x8889CA5A};
                union U2 *l_1206 = &l_1207;
                union U2 **l_1208 = &l_1206;
                (*l_1208) = l_1206;
            }
            else
            { /* block id: 730 */
                uint32_t l_1209 = 0U;
                l_1209 = l_1205;
                if (((int32_t)(l_1212 ^ l_1213) + (int32_t)((void*)0 != l_1214)))
                { /* block id: 732 */
                    uint32_t l_1218 = 4294967295U;
                    float l_1220 = (-0x6.Ep-1);
                    float *l_1219 = &l_1220;
                    l_1217 = l_1215;
                    (*l_1219) = ((-0x10.2p-1) != (l_1218 != l_1212));
                }
                else
                { /* block id: 735 */
                    uint16_t l_1222 = 0x7C98;
                    int32_t *l_1225 = (void*)0;
                    int32_t **l_1226 = &l_1221;
                    int32_t *l_1234 = &l_1229;
                    l_1221 = &l_1205;
                    /* statement id: 736 */
                    assert (l_1221 == &l_1205);
                    (*l_1221) = (__builtin_bswap64(l_1222) & ((int16_t)(*l_1221) << (int16_t)13));
                    (*l_1226) = l_1225;
                    /* statement id: 738 */
                    assert (l_1221 == 0);
                    (*l_1234) = (l_1209 <= ((int16_t)(((l_1229 == l_1230) > 0xA4043DE1) > l_1209) >> (int16_t)(l_1209 || ((uint16_t)0x768F << (uint16_t)func_74(l_1233)))));
                }
            }
        }
        /* facts after for loop */
        assert (l_1221 == 0 || l_1221 == &l_1212);
    }
    return l_1051.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_50(float  p_51, uint32_t  p_52, int32_t * p_53, int32_t * p_54, int32_t * p_55)
{ /* block id: 709 */
    const uint32_t l_1168 = 0xDE9F35DA;
    int32_t l_1169 = 0x102AE166;
    union U2 l_1174 = {1U};
    union U2 *l_1173 = &l_1174;
    union U2 **l_1172 = &l_1173;
    union U2 ***l_1171 = &l_1172;
    union U2 ****l_1170 = &l_1171;
    union U1 * const l_1177 = (void*)0;
    struct S0 l_1187 = {0x408187F9,0xFF0F6820,79,6812,8,0x3A867287,944,0x1549748C,0x73CF0DC1};
    struct S0 *l_1186 = &l_1187;
    struct S0 ** const l_1185 = &l_1186;
    float *l_1196 = (void*)0;
    int32_t *l_1197 = &l_1169;
    l_1169 = l_1168;
lbl_1182:
    if (((((*p_55) > l_1168) | (l_1170 == &l_1171)) ^ (((l_1174.f2 <= l_1169) != p_52) < ((int16_t)0x2F5F << (int16_t)11))))
    { /* block id: 711 */
        union U1 l_1180 = {0x5866};
        union U1 *l_1179 = &l_1180;
        union U1 **l_1178 = &l_1179;
        (*l_1178) = l_1177;
        /* statement id: 712 */
        assert (l_1179 == 0);
    }
    else
    { /* block id: 713 */
        union U2 **l_1181 = &l_1173;
        (**l_1170) = l_1181;
        if (l_1169)
            goto lbl_1182;
    }
    (*l_1197) = ((l_1185 != &l_1186) != (l_1187.f0 >= (__builtin_popcountll((0x99132A86 < ((int32_t)((int32_t)((uint16_t)0x8DA2 + (uint16_t)((int16_t)((void*)0 != l_1196) + (int16_t)l_1187.f1)) + (int32_t)0x0ACE1137) - (int32_t)l_1187.f4))) < 0x519A)));
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(int32_t * p_57, union U1  p_58, int16_t  p_59, struct S0  p_60)
{ /* block id: 633 */
    int32_t l_1053 = 0xAF974929;
    int32_t l_1073 = 0x4CD6B0E4;
    struct S0 *l_1088 = (void*)0;
    int32_t l_1126 = 0x56BF6861;
    int32_t ****l_1141 = (void*)0;
    union U2 *l_1143 = (void*)0;
    float l_1154 = 0x3.A536F0p-49;
    float *l_1153 = &l_1154;
    int32_t *l_1167 = &l_1053;
    if (__builtin_ctzl((~l_1053)))
    { /* block id: 634 */
        int16_t l_1054 = (-7);
        l_1054 = l_1053;
    }
    else
    { /* block id: 636 */
        union U1 *l_1055 = (void*)0;
        union U1 **l_1056 = &l_1055;
        int32_t **l_1057 = (void*)0;
        const float l_1063 = 0x3.Ap+1;
        const float *l_1062 = &l_1063;
        const float **l_1061 = &l_1062;
        const float ***l_1060 = &l_1061;
        struct S0 l_1087 = {0U,1U,14,-1360,0x6E5EA604,0x74B2349F,603,0x2B7D6727,0xB4650D37};
        int32_t l_1097 = (-1);
        (*l_1056) = l_1055;
        p_57 = p_57;
        for (p_60.f8 = 0; (p_60.f8 <= 2); p_60.f8++)
        { /* block id: 641 */
            const float ****l_1064 = &l_1060;
            int32_t l_1065 = 0x608445ED;
            const union U2 l_1079 = {4294967288U};
            const union U2 *l_1078 = &l_1079;
            union U2 l_1110 = {4294967295U};
            union U2 *l_1109 = &l_1110;
            union U2 ** const l_1108 = &l_1109;
            union U2 ** const *l_1107 = &l_1108;
            uint32_t l_1122 = 0x9A4CD7DD;
            union U1 ***l_1134 = &l_1056;
            (*l_1064) = l_1060;
            if ((p_60.f0 && l_1065))
            { /* block id: 643 */
                uint16_t l_1080 = 0x1B5C;
                int32_t *l_1081 = &l_1065;
                float l_1085 = 0x0.Ep+1;
                float *l_1084 = &l_1085;
                float **l_1083 = &l_1084;
                float ***l_1082 = &l_1083;
                uint16_t l_1090 = 3U;
                struct S0 **l_1114 = &l_1088;
                struct S0 ***l_1113 = &l_1114;
                l_1053 = ((uint32_t)l_1065 % (uint32_t)func_74(p_60));
                for (p_60.f4 = 1; (p_60.f4 == (-20)); p_60.f4 -= 2)
                { /* block id: 647 */
                    int32_t l_1072 = 0x8AF2FE59;
                    l_1081 = func_64((((uint16_t)(l_1072 || ((__builtin_popcount(l_1073) != __builtin_parityll((((int16_t)p_60.f0 + (int16_t)(((uint16_t)((((l_1078 != (void*)0) && l_1079.f0) >= l_1053) == ((((p_60.f6 ^ 0xBDBAF770) < l_1072) <= 0U) != p_60.f7)) >> (uint16_t)8) && 0x277B6D6D)) == 0xD05FFCFD))) == p_60.f2)) % (uint16_t)p_58.f0) < l_1080), p_57);
                    /* statement id: 648 */
                    assert (l_1081 == 0);
                    if (l_1065)
                        continue;
                }
                /* facts after for loop */
                assert (l_1081 == 0 || l_1081 == &l_1065);
                (***l_1082) = ((((p_60.f8 <= (&l_1065 != (void*)0)) == (((l_1082 == (void*)0) >= p_60.f1) != 0xC.6B46FEp-20)) != (+(func_74(l_1087) == l_1053))) > 0x5.3ECC96p-94);
                if (__builtin_ctzl(l_1079.f2))
                { /* block id: 652 */
                    int32_t l_1092 = (-7);
                    const int32_t *l_1096 = &l_1065;
                    const int32_t **l_1095 = &l_1096;
                    if (l_1073)
                    { /* block id: 653 */
                        struct S0 **l_1089 = &l_1088;
                        (*l_1089) = l_1088;
                    }
                    else
                    { /* block id: 655 */
                        struct S0 **l_1091 = &l_1088;
                        if (l_1090)
                            break;
                        (*l_1091) = &p_60;
                        /* statement id: 657 */
                        assert (l_1088 == &p_60);
                    }
                    (*l_1095) = func_61(((l_1092 > ((int16_t)(-2) % (int16_t)p_60.f5)) || ((((p_60.f4 > ((p_60.f4 | l_1087.f6) == ((void*)0 == (*l_1064)))) ^ l_1065) == l_1092) | 0xE3CE)));
                    /* statement id: 659 */
                    assert (l_1096 == 0);
                }
                else
                { /* block id: 660 */
                    const int32_t *l_1098 = &l_1097;
                    struct S0 ***l_1115 = &l_1114;
                    p_57 = func_64(l_1097, func_64(p_59, l_1098));
                    l_1098 = p_57;
                    /* statement id: 662 */
                    assert (l_1098 == 0);
                    for (l_1053 = 0; (l_1053 <= 0); l_1053 += 8)
                    { /* block id: 665 */
                        int16_t l_1125 = 0xD389;
                        l_1122 = ((-0x1.Cp+1) >= ((l_1113 == l_1115) <= ((&l_1056 != &l_1056) == (((float)((p_60.f6 < ((float)((float)l_1073 + (float)p_60.f2) + (float)func_74(p_60))) <= l_1079.f2) + (float)0xE.22D4DEp-59) == 0x5.F46DC4p-27))));
                        (**l_1113) = &p_60;
                        /* statement id: 667 */
                        assert (l_1088 == &p_60);
                        l_1126 = ((uint16_t)p_58.f0 + (uint16_t)__builtin_ia32_crc32qi(p_60.f7, __builtin_popcountl(l_1125)));
                    }
                    for (l_1087.f1 = 0; (l_1087.f1 > 10); l_1087.f1 += 3)
                    { /* block id: 672 */
                        union U2 **l_1131 = &l_1109;
                        union U2 ***l_1130 = &l_1131;
                        union U2 ****l_1129 = &l_1130;
                        (*l_1129) = &l_1108;
                        /* statement id: 673 */
                        assert (l_1130 == &l_1108);
                        (*l_1114) = (*l_1114);
                        if (l_1110.f2)
                            continue;
                    }
                }
            }
            else
            { /* block id: 678 */
                union U1 ***l_1135 = &l_1056;
                int32_t *l_1136 = &l_1097;
                float l_1138 = (-0x1.Fp+1);
                float *l_1137 = &l_1138;
                if (l_1073)
                    break;
                (*l_1136) = (l_1079.f0 | (l_1134 != l_1135));
                (*l_1136) = __builtin_ctz(l_1126);
                (*l_1137) = (0x4.F4CC36p-2 > 0x9.9p-1);
            }
            for (l_1087.f7 = 0; (l_1087.f7 > (-26)); l_1087.f7 -= 6)
            { /* block id: 686 */
                int32_t *l_1142 = &l_1126;
                (*l_1142) = ((void*)0 == l_1141);
                (**l_1107) = l_1143;
                /* statement id: 688 */
                assert (l_1109 == 0);
                return p_57;
                /* statement id: 689 */
                //assert (func_56_rv == 0);
            }
        }
        /* facts after for loop */
        assert (l_1088 == &p_60 || l_1088 == 0);
        if (p_60.f7)
            goto lbl_1164;
    }
    /* facts after branching */
    assert (l_1088 == &p_60 || l_1088 == 0);
    (*l_1153) = (((float)((float)(((float)l_1053 + (float)p_60.f8) != (((((-0x1.Ep+1) == (((-(float)((0x3.A0074Fp+50 > ((((((float)(p_60.f4 > p_60.f8) + (float)l_1073) != p_59) <= 0x1.Ap-1) != l_1126) > 0x1.AF148Dp-61)) == (-0x3.1p-1))) != 0x7.66E0CBp+30) <= 0xF.356D40p+39)) >= 0x9.51C033p-5) <= l_1053) == 0xC.42A01Bp-4)) + (float)0xC.80AFBAp-59) - (float)p_60.f3) != p_58.f0);
lbl_1164:
    for (l_1053 = 0; (l_1053 != (-2)); l_1053--)
    { /* block id: 696 */
        struct S0 **l_1163 = (void*)0;
        struct S0 ***l_1162 = &l_1163;
        for (l_1126 = 0; (l_1126 == 23); l_1126++)
        { /* block id: 699 */
            float l_1159 = 0x5.0p+1;
            int32_t l_1161 = 0;
            int32_t *l_1160 = &l_1161;
            (*l_1153) = p_60.f8;
            (*l_1160) = 0x2D8B0B99;
        }
        (*l_1162) = &l_1088;
        /* statement id: 703 */
        assert (l_1163 == &l_1088);
        return p_57;
        /* statement id: 704 */
        //assert (func_56_rv == 0);
    }
    (*l_1167) = ((int16_t)p_60.f7 >> (int16_t)(0U < p_60.f0));
    return p_57;
    /* statement id: 708 */
    //assert (func_56_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_61(uint32_t  p_62)
{ /* block id: 56 */
    uint32_t l_63 = 4294967291U;
    int32_t l_73 = 0x8BAC8E9B;
    int32_t *l_72 = &l_73;
    union U2 l_89 = {1U};
    union U1 l_90 = {0xD045};
    int32_t **l_1047 = &l_72;
    int32_t *l_1048 = &l_73;
    int32_t *l_1049 = (void*)0;
    l_63 = (0x0.8p+1 > 0x9.96ADD8p+1);
    (*l_1047) = func_64(l_63, func_67(l_72, p_62, ((p_62 & (__builtin_popcountl(p_62) < (func_74(func_76(func_79((__builtin_clzll(p_62) >= (func_83(l_89, p_62, (*l_72), l_90, &l_73) >= (*l_72))), &l_73, (*l_72)), p_62)) < 0xBA60086D))) >= (-8)), p_62));
    /* statement id: 631 */
    assert (l_72 == 0);
    return l_1049;
    /* statement id: 632 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_64(uint32_t  p_65, const int32_t * p_66)
{ /* block id: 357 */
    uint32_t l_480 = 8U;
    int32_t ***l_491 = (void*)0;
    int32_t ****l_490 = &l_491;
    int32_t *****l_489 = &l_490;
    int32_t l_508 = 0;
    int32_t *l_507 = &l_508;
    int32_t *l_510 = &l_508;
    int32_t *l_512 = &l_508;
    int32_t *l_514 = (void*)0;
    union U3 l_521 = {1};
    union U3 *l_520 = &l_521;
    const int32_t *l_553 = &l_521.f0;
    const float **l_562 = (void*)0;
    union U3 **l_567 = (void*)0;
    union U3 ***l_566 = &l_567;
    union U3 ****l_565 = &l_566;
    union U2 * const l_578 = (void*)0;
    union U2 * const *l_577 = &l_578;
    union U2 * const **l_576 = &l_577;
    union U2 * const ***l_575 = &l_576;
    float l_640 = 0xA.C35E81p-31;
    int32_t *l_679 = &l_508;
    int32_t *l_715 = &l_508;
    int32_t *l_720 = &l_521.f0;
    int32_t *l_721 = &l_508;
    float **l_731 = (void*)0;
    float ***l_730 = &l_731;
    float ****l_729 = &l_730;
    float *****l_728 = &l_729;
    uint32_t l_749 = 4294967287U;
    float *l_761 = &l_640;
    struct S0 l_766 = {0xEEBB0FB5,0xAF0DE5BA,2,-7931,1,0xE826677C,807,0x6CB54591,1};
    int32_t l_769 = 1;
    uint32_t l_791 = 4294967288U;
    uint16_t l_794 = 65528U;
    int32_t *l_819 = &l_521.f0;
    struct S0 l_843 = {4294967295U,0xDB7C8F3D,76,-7304,0x7E02B9F2,0x92573088,62,1,0x78C7D05C};
    struct S0 *l_842 = &l_843;
    union U1 *l_850 = (void*)0;
    union U1 **l_849 = &l_850;
    int32_t l_861 = 0x109C3168;
    uint32_t l_894 = 0xA9B4528A;
    int32_t *l_947 = (void*)0;
    int32_t * const *l_984 = &l_507;
    int32_t * const **l_983 = &l_984;
    int32_t * const ***l_982 = &l_983;
    int32_t * const ****l_981 = &l_982;
    int32_t *l_986 = &l_508;
    int32_t *l_1004 = &l_508;
    int32_t *l_1042 = &l_521.f0;
    int32_t *l_1043 = &l_521.f0;
    int32_t *l_1044 = &l_508;
    int32_t *l_1045 = &l_521.f0;
    int32_t *l_1046 = (void*)0;
    return l_1046;
    /* statement id: 630 */
    //assert (func_64_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_67(int32_t * p_68, float  p_69, uint32_t  p_70, uint32_t  p_71)
{ /* block id: 344 */
    const int32_t *l_466 = (void*)0;
    int32_t l_467 = 1;
    uint32_t l_471 = 8U;
    float l_476 = 0x0.9B1E88p+94;
    uint16_t l_477 = 0xDA2C;
    int32_t *l_479 = (void*)0;
    int32_t **l_478 = &l_479;
    for (p_70 = 29; (p_70 <= 41); p_70 += 1)
    { /* block id: 347 */
        struct S0 *l_461 = (void*)0;
        struct S0 **l_460 = &l_461;
        float l_463 = (-0x8.Bp-1);
        float *l_462 = &l_463;
        uint32_t l_464 = 1U;
        int32_t l_465 = 0xA41E0572;
        (*l_462) = ((void*)0 == l_460);
        if (p_70)
            goto lbl_468;
        l_465 = l_464;
        return l_466;
        /* statement id: 350 */
        //assert (func_67_rv == 0);
    }
lbl_468:
    (*p_68) = l_467;
    l_467 = (__builtin_ctz(p_70) <= (((float)(0x1.0p-1 >= (l_471 <= ((__builtin_clz((((p_71 | (0x331F || p_70)) > ((uint16_t)((int16_t)(p_71 ^ (0x5CF2 >= p_70)) >> (int16_t)1) - (uint16_t)1)) != l_477)) != l_471) >= 0xA.B6543Dp-41))) + (float)p_69) > p_70));
    (*l_478) = &l_467;
    /* statement id: 355 */
    assert (l_479 == &l_467);
    return p_68;
    /* statement id: 356 */
    //assert (func_67_rv == &l_73 || func_67_rv == &l_521.f0 || func_67_rv == &l_508 || func_67_rv == &l_1000);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_74(struct S0  p_75)
{ /* block id: 248 */
    union U3 l_338 = {1};
    const union U3 *l_337 = &l_338;
    const union U3 **l_336 = &l_337;
    float *l_343 = (void*)0;
    float **l_342 = &l_343;
    float l_429 = 0xE.B432B1p-81;
    float *l_428 = &l_429;
    union U1 l_431 = {0x1A13};
    const union U1 *l_430 = &l_431;
    union U1 *l_433 = &l_431;
    union U1 **l_432 = &l_433;
    float * const **l_439 = (void*)0;
    float * const ***l_438 = &l_439;
    float * const ****l_437 = &l_438;
    for (p_75.f7 = 6; (p_75.f7 == 21); ++p_75.f7)
    { /* block id: 251 */
        uint16_t l_330 = 0x2E3C;
        uint16_t l_352 = 0x426A;
        const union U3 **l_355 = &l_337;
        struct S0 **l_376 = (void*)0;
        union U1 l_400 = {65535U};
        union U1 * const l_399 = &l_400;
        union U2 l_409 = {4294967295U};
        float *l_426 = (void*)0;
        int32_t l_427 = 0xF109A50A;
        for (p_75.f4 = 23; (p_75.f4 > 10); p_75.f4 -= 1)
        { /* block id: 254 */
            int32_t l_329 = 0xF8BE54F4;
            int32_t *l_328 = &l_329;
            float *l_331 = (void*)0;
            float l_333 = 0x0.2p+1;
            float *l_332 = &l_333;
            (*l_328) = 8;
            (*l_328) = (l_330 | (*l_328));
            (*l_332) = 0x4.4C7034p+27;
        }
        if (((p_75.f5 <= __builtin_parityl(p_75.f8)) & (((uint16_t)(__builtin_ctzl((p_75.f8 ^ ((void*)0 != l_336))) > ((0xEF0B >= (l_330 > l_338.f0)) && l_338.f0)) + (uint16_t)l_338.f0) == p_75.f4)))
        { /* block id: 259 */
            float l_340 = 0x6.8p-1;
            int32_t *l_341 = &l_338.f0;
            (*l_341) = (!l_330);
        }
        else
        { /* block id: 261 */
            float **l_344 = &l_343;
            int32_t *l_345 = &l_338.f0;
            int32_t **l_348 = (void*)0;
            int32_t **l_349 = (void*)0;
            const int32_t *l_351 = &l_338.f0;
            const int32_t **l_350 = &l_351;
            union U3 * const l_354 = &l_338;
            const int32_t ***l_368 = &l_350;
            const int32_t ****l_367 = &l_368;
            const int32_t *****l_366 = &l_367;
            uint32_t l_425 = 1U;
            (*l_350) = l_343;
            /* statement id: 262 */
            assert (l_351 == 0);
            if (l_352)
            { /* block id: 263 */
                int32_t *l_353 = (void*)0;
                int32_t ***l_356 = &l_348;
                union U3 *l_361 = &l_338;
                struct S0 l_371 = {0xF9AE73C0,0xCD686306,78,-645,0x280A0174,0x9BFD1996,753,1,0x32F4C1B1};
                struct S0 *l_370 = &l_371;
                struct S0 **l_369 = &l_370;
                union U2 l_406 = {1U};
                union U2 *l_405 = &l_406;
                union U2 **l_404 = &l_405;
                union U2 ***l_403 = &l_404;
                union U1 l_414 = {4U};
                l_353 = l_353;
                (*l_350) = l_353;
                for (p_75.f8 = 0; (p_75.f8 <= 28); p_75.f8++)
                { /* block id: 268 */
                    int16_t l_372 = 0;
                    (*l_345) = ((0 >= ((uint16_t)(l_361 != (*l_355)) << (uint16_t)((((uint32_t)((((int16_t)(l_366 != &l_367) >> (int16_t)15) >= ((l_369 == (void*)0) <= (-1))) | (p_75.f0 || 4)) + (uint32_t)l_372) ^ 0x49E5) || p_75.f3))) == p_75.f7);
                    for (p_75.f4 = 6; (p_75.f4 >= (-14)); p_75.f4 -= 9)
                    { /* block id: 272 */
                        int32_t **l_375 = &l_345;
                        struct S0 ***l_377 = &l_376;
                        (*l_356) = l_375;
                        /* statement id: 273 */
                        assert (l_348 == &l_345);
                        (*l_377) = l_376;
                    }
                    for (l_371.f7 = (-8); (l_371.f7 == 18); l_371.f7++)
                    { /* block id: 278 */
                        uint32_t l_380 = 0x9D66F257;
                        l_380 = (l_372 & (-1));
                    }
                    for (l_352 = 14; (l_352 <= 45); l_352++)
                    { /* block id: 283 */
                        const float *** const *l_383 = (void*)0;
                        float ***l_386 = &l_342;
                        float ****l_385 = &l_386;
                        float *****l_384 = &l_385;
                        int32_t l_387 = (-1);
                        (*l_384) = l_383;
                        /* statement id: 284 */
                        assert (l_385 == 0);
                        if (p_75.f1)
                            break;
                        l_387 = p_75.f2;
                        l_387 = ((int16_t)0xB149 << (int16_t)0);
                    }
                }
                /* facts after for loop */
                assert (l_348 == &l_345 || l_348 == 0);
                if (l_338.f0)
                { /* block id: 290 */
                    int32_t *l_390 = (void*)0;
                    float l_392 = (-0x5.9p+1);
                    float *l_391 = &l_392;
                    l_390 = (void*)0;
                    (*l_391) = __builtin_ctzll(p_75.f0);
                }
                else
                { /* block id: 293 */
                    union U2 ** const *l_408 = &l_404;
                    union U2 ** const **l_407 = &l_408;
                    int32_t l_413 = 0x3F58FC13;
                    for (l_371.f0 = 0; (l_371.f0 <= 56); l_371.f0++)
                    { /* block id: 296 */
                        const int32_t l_397 = 0x50B8F977;
                        union U1 *l_402 = &l_400;
                        union U1 **l_401 = &l_402;
                        (*l_345) = p_75.f6;
                        (*l_345) = ((int16_t)l_330 - (int16_t)(l_397 > (~p_75.f8)));
                        (*l_401) = l_399;
                        (*l_345) = (0x811D19BC || 0xEA2BC010);
                    }
                    (*l_407) = l_403;
                    l_338.f0 = func_83(l_409, ((0xB19B & (l_338.f0 & (p_75.f0 && (((!(p_75.f3 >= (p_75.f5 == (p_75.f6 ^ p_75.f2)))) ^ p_75.f0) & l_413)))) | l_413), l_400.f0, l_414, l_343);
                    (**l_403) = (void*)0;
                    /* statement id: 304 */
                    assert (l_405 == 0);
                }
                /* facts after branching */
                assert (l_405 == 0 || l_405 == &l_406);
            }
            else
            { /* block id: 306 */
                (***l_367) = (****l_366);
                if (p_75.f0)
                    continue;
            }
            /* facts after branching */
            assert (l_348 == &l_345 || l_348 == 0);
            for (p_75.f8 = 0; (p_75.f8 > 8); ++p_75.f8)
            { /* block id: 312 */
                int32_t l_424 = 0xF7A6D099;
                l_338.f0 = (((float)p_75.f8 - (float)(l_338.f0 < p_75.f3)) > ((float)(((float)(-0x4.5p+1) + (float)(0x4.F9226Bp+30 != __builtin_ffs(((((void*)0 == (**l_366)) > ((-(uint16_t)l_409.f0) ^ l_424)) <= 0x25EB0296)))) == 0x0.5p+1) + (float)(-0x4.7p+1)));
            }
            (*l_345) = (l_425 == p_75.f6);
        }
        l_427 = l_409.f2;
    }
    (*l_428) = 0xE.365FFFp-67;
    (*l_432) = l_430;
    for (l_338.f0 = 23; (l_338.f0 < 2); --l_338.f0)
    { /* block id: 323 */
        uint32_t l_442 = 0xBBA59C75;
        int32_t *l_452 = (void*)0;
        int32_t *l_453 = (void*)0;
        int32_t l_455 = (-8);
        int32_t *l_454 = &l_455;
        const int32_t *l_457 = &l_338.f0;
        const int32_t **l_456 = &l_457;
        if ((p_75.f3 || p_75.f7))
        { /* block id: 324 */
            int32_t l_436 = 4;
            l_442 = (((__builtin_ffsl(l_436) == (p_75.f1 <= (l_437 != &l_438))) > l_436) != ((float)0x0.Ep-1 + (float)p_75.f0));
        }
        else
        { /* block id: 326 */
            int32_t l_448 = (-5);
            (*l_428) = p_75.f6;
            for (p_75.f8 = (-3); (p_75.f8 < (-22)); p_75.f8 -= 8)
            { /* block id: 330 */
                int32_t *l_449 = &l_448;
                (*l_449) = (p_75.f1 > ((uint16_t)(-(int32_t)l_448) >> (uint16_t)p_75.f4));
                for (l_442 = 19; (l_442 >= 46); l_442 += 3)
                { /* block id: 334 */
                    (*l_449) = (l_431.f0 & ((void*)0 != &l_448));
                }
                (*l_449) = l_442;
            }
        }
        (*l_454) = (0x7D5DB6B6 > l_442);
        (*l_456) = &l_455;
        /* statement id: 341 */
        assert (l_457 == &l_455);
    }
    return l_338.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_76(int32_t * p_77, float  p_78)
{ /* block id: 147 */
    int32_t l_194 = 0;
    int32_t *l_199 = &l_194;
    int32_t **l_198 = &l_199;
    int32_t ***l_197 = &l_198;
    int32_t ****l_196 = &l_197;
    int32_t *****l_195 = &l_196;
    union U1 l_209 = {0x7E99};
    union U1 *l_208 = &l_209;
    union U1 **l_207 = &l_208;
    int32_t l_255 = 0;
    const int16_t l_261 = 0xA370;
    float l_262 = 0x1.8DE1EEp+53;
    struct S0 l_323 = {1U,4294967295U,46,-4726,1,9U,247,0xC2108D3F,0};
    if (((~((-5) <= (l_194 != (5U | (((void*)0 == l_195) < (-1)))))) <= 0x5947))
    { /* block id: 148 */
        union U1 l_206 = {0xDF05};
        union U1 *l_205 = &l_206;
        union U1 **l_204 = &l_205;
        float l_233 = 0x1.Cp+1;
        float *l_232 = &l_233;
        struct S0 * const l_241 = (void*)0;
        int32_t l_258 = 0x6B702C53;
        int32_t ***l_263 = &l_198;
lbl_264:
        for (l_194 = 22; (l_194 >= 9); l_194 -= 6)
        { /* block id: 151 */
            union U3 *l_211 = (void*)0;
            union U3 ** const l_210 = &l_211;
            int32_t l_213 = (-5);
            union U2 l_240 = {4294967295U};
            union U2 *l_239 = &l_240;
            union U2 **l_238 = &l_239;
        }
        if (((uint16_t)(l_261 | l_258) << (uint16_t)9))
        { /* block id: 181 */
            (**l_195) = l_263;
            (*l_232) = 0xD.1AFFA9p-13;
        }
        else
        { /* block id: 184 */
            if (l_261)
                goto lbl_264;
            (*l_232) = (0x2.8666C9p+20 > p_78);
        }
    }
    else
    { /* block id: 188 */
        int16_t l_265 = 0x36CB;
        uint16_t l_272 = 0x2A22;
        union U2 l_296 = {0xC4599D9C};
        union U2 *l_295 = &l_296;
        union U2 ** const l_294 = &l_295;
        (***l_197) = (***l_197);
        if ((l_265 == (0x0A4E >= ((int16_t)((uint16_t)(((***l_197) || l_265) != 0x24CA) >> (uint16_t)((int16_t)l_265 - (int16_t)((*****l_195) ^ l_265))) >> (int16_t)0))))
        { /* block id: 190 */
            int16_t l_278 = 0x53D7;
            if (l_272)
            { /* block id: 191 */
                int32_t l_282 = 0;
                for (l_255 = 3; (l_255 > (-16)); l_255--)
                { /* block id: 194 */
                    float *l_275 = &l_262;
                    (*l_275) = p_78;
                }
                for (l_272 = (-18); (l_272 != 57); l_272 += 1)
                { /* block id: 199 */
                    uint32_t l_279 = 0U;
                    (*l_198) = func_79(l_278, p_77, l_279);
                    /* statement id: 200 */
                    //assert (l_199 == &l_73);
                    for (l_279 = (-25); (l_279 > 17); l_279 += 4)
                    { /* block id: 203 */
                        float *l_283 = &l_262;
                        int32_t l_284 = (-3);
                        (*l_198) = p_77;
                        (*l_283) = l_282;
                        (*****l_195) = l_284;
                    }
                }
                /* facts after for loop */
                //assert (l_199 == &l_73 || l_199 == &l_194);
            }
            else
            { /* block id: 209 */
                uint16_t l_297 = 1U;
                for (l_209.f0 = 5; (l_209.f0 >= 8); l_209.f0 += 1)
                { /* block id: 212 */
                    union U3 l_288 = {1};
                    union U3 *l_287 = &l_288;
                    union U3 **l_289 = &l_287;
                    (*l_289) = l_287;
                    for (l_278 = 10; (l_278 == 3); l_278 -= 9)
                    { /* block id: 216 */
                        (**l_197) = p_77;
                        /* statement id: 217 */
                        //assert (l_199 == &l_73);
                    }
                    for (l_278 = (-3); (l_278 < (-21)); --l_278)
                    { /* block id: 221 */
                        (*l_199) = ((void*)0 != l_294);
                        (*****l_195) = l_297;
                    }
                }
                /* facts after for loop */
                //assert (l_199 == &l_73 || l_199 == &l_194);
            }
            /* facts after branching */
            //assert (l_199 == &l_73 || l_199 == &l_194);
            (*p_77) = l_278;
            (*p_77) = 0x8DE423DF;
            (*****l_195) = ((uint16_t)0xCFC3 << (uint16_t)12);
        }
        else
        { /* block id: 230 */
            union U3 *l_302 = (void*)0;
            union U3 ** const l_301 = &l_302;
            union U3 ** const *l_300 = &l_301;
            union U3 **l_305 = (void*)0;
            union U3 ***l_304 = &l_305;
            union U3 ****l_303 = &l_304;
            (***l_196) = p_77;
            /* statement id: 231 */
            //assert (l_199 == &l_73);
            (*l_303) = l_300;
            /* statement id: 232 */
            assert (l_304 == &l_301);
        }
        /* facts after branching */
        //assert (l_199 == &l_73 || l_199 == &l_194);
    }
    /* facts after branching */
    //assert (l_199 == &l_73 || l_199 == &l_194);
    for (l_194 = (-25); (l_194 <= (-17)); l_194 += 8)
    { /* block id: 237 */
        int32_t *l_308 = &l_194;
        int32_t **** const l_319 = &l_197;
        union U1 *l_320 = (void*)0;
        (***l_196) = p_77;
        /* statement id: 238 */
        //assert (l_199 == &l_73);
        (****l_319) = (0xE14E == (*l_308));
        (*l_207) = l_320;
        /* statement id: 240 */
        assert (l_208 == 0);
    }
    /* facts after for loop */
    assert (l_208 == 0 || l_208 == &l_209);
    for (l_194 = 0; (l_194 != (-8)); l_194--)
    { /* block id: 244 */
        return l_323;
    }
    return l_323;
}


/* ------------------------------------------ */
/* 
 * reads : l_73
 * writes: l_73
 */
static int32_t * func_79(float  p_80, int32_t * p_81, uint32_t  p_82)
{ /* block id: 61 */
    float l_96 = 0xD.566A56p-30;
    int32_t l_97 = 0;
    union U3 l_102 = {0x54F43723};
    union U3 *l_101 = &l_102;
    union U2 l_139 = {0xDB7A7163};
    union U2 *l_138 = &l_139;
    float **l_144 = (void*)0;
    int32_t *l_191 = (void*)0;
    int32_t **l_190 = &l_191;
    int32_t ***l_189 = &l_190;
    int32_t ****l_188 = &l_189;
    int32_t *****l_187 = &l_188;
    (*p_81) = ((int16_t)p_82 + (int16_t)p_82);
    if (l_97)
    { /* block id: 63 */
        for (p_82 = 0; (p_82 >= 20); ++p_82)
        { /* block id: 66 */
            union U3 *l_100 = (void*)0;
            l_101 = l_100;
            /* statement id: 67 */
            assert (l_101 == 0);
        }
        /* facts after for loop */
        assert (l_101 == 0 || l_101 == &l_102);
    }
    else
    { /* block id: 69 */
        const int32_t *l_106 = (void*)0;
        const int32_t **l_105 = &l_106;
        int32_t ***l_107 = (void*)0;
        int32_t * const *l_109 = (void*)0;
        int32_t * const **l_108 = &l_109;
        int32_t *l_140 = &l_97;
        float ***l_152 = &l_144;
        union U3 *l_164 = &l_102;
        for (l_97 = 0; (l_97 < (-8)); l_97--)
        { /* block id: 72 */
            (*p_81) = (*p_81);
            if ((*p_81))
                break;
        }
        (*l_108) = l_105;
        /* statement id: 76 */
        assert (l_109 == &l_106);
        if ((*p_81))
        { /* block id: 77 */
            int32_t ****l_113 = (void*)0;
            union U2 *l_137 = (void*)0;
            int32_t *l_141 = &l_97;
            union U1 l_162 = {0x3898};
            for (l_97 = 0; (l_97 >= 16); ++l_97)
            { /* block id: 80 */
                int32_t **** const l_112 = &l_107;
                int32_t *l_135 = &l_102.f0;
                l_113 = l_112;
                /* statement id: 81 */
                assert (l_113 == &l_107);
            }
            /* facts after for loop */
            assert (l_113 == &l_107 || l_113 == 0);
            if (((*p_81) && 0xC5CC1C00))
            { /* block id: 103 */
                float *l_136 = &l_96;
                (*l_136) = (p_80 < (((-0x10.Ep+1) == l_102.f0) > p_80));
                l_138 = l_137;
                /* statement id: 105 */
                assert (l_138 == 0);
                return p_81;
                /* statement id: 106 */
                //assert (func_79_rv == &l_73 || func_79_rv == &l_496 || func_79_rv == &l_1000);
            }
            else
            { /* block id: 107 */
                const union U2 *l_143 = &l_139;
                const union U2 **l_142 = &l_143;
                float ***l_145 = &l_144;
                int32_t l_160 = 0x54C37BB7;
                int32_t l_161 = (-1);
                (*l_142) = &l_139;
                (*l_145) = l_144;
                if ((l_139.f2 ^ l_102.f0))
                { /* block id: 110 */
                    uint32_t l_146 = 0x45E11D14;
                    int32_t ***l_147 = (void*)0;
                    l_146 = 0xE759864E;
                    if (((((void*)0 != l_147) >= (l_139.f1 && (((*l_141) > ((int16_t)((uint16_t)((l_152 != l_145) <= 0x88299C91) >> (uint16_t)p_82) % (int16_t)p_82)) >= p_82))) & 0))
                    { /* block id: 112 */
                        union U2 l_153 = {3U};
                        float *l_163 = &l_96;
                        union U3 **l_165 = &l_101;
                        p_81 = p_81;
                        (*l_163) = func_83(l_153, (((uint32_t)(((((((l_139.f0 >= p_82) <= ((int32_t)(!l_153.f0) - (int32_t)(l_153.f0 || ((!(p_82 != ((((p_82 & (((*p_81) && p_82) && (*p_81))) & l_160) && 8U) != l_153.f1))) && l_153.f1)))) == l_160) < p_82) <= 0x7134) == l_161) < p_82) + (uint32_t)(*p_81)) <= 0xE8507785), l_161, l_162, &l_161);
                        (*l_165) = l_164;
                        (*l_105) = p_81;
                        /* statement id: 116 */
                        //assert (l_106 == &l_73 || l_106 == &l_496 || l_106 == &l_1000);
                    }
                    else
                    { /* block id: 117 */
                        float *l_166 = &l_96;
                        (*l_166) = 0xF.84D70Bp+71;
                    }
                    /* facts after branching */
                    //assert (l_106 == 0 || l_106 == &l_73 || l_106 == &l_496 || l_106 == &l_1000);
                }
                else
                { /* block id: 120 */
                    return p_81;
                    /* statement id: 121 */
                    //assert (func_79_rv == &l_73 || func_79_rv == &l_496 || func_79_rv == &l_1000);
                }
                /* facts after branching */
                //assert (l_106 == 0 || l_106 == &l_73 || l_106 == &l_496 || l_106 == &l_1000);
                return p_81;
                /* statement id: 123 */
                //assert (func_79_rv == &l_73 || func_79_rv == &l_496 || func_79_rv == &l_1000);
            }
        }
        else
        { /* block id: 125 */
            float l_167 = 0x4.3E1DE8p-9;
            int32_t l_182 = (-7);
            int32_t *****l_192 = &l_188;
            l_167 = l_97;
            for (p_82 = 0; (p_82 != 23); p_82 += 1)
            { /* block id: 129 */
                uint32_t l_176 = 0x17DDF175;
                float *l_181 = &l_96;
                (*l_105) = (void*)0;
                /* statement id: 130 */
                assert (l_106 == 0);
                if ((1U || ((uint32_t)((((((uint32_t)l_176 - (uint32_t)((((int16_t)((void*)0 == l_152) % (int16_t)(-1)) > p_82) ^ p_82)) == ((uint32_t)(l_181 != l_181) % (uint32_t)l_182)) ^ p_82) > 0) && p_82) + (uint32_t)(*p_81))))
                { /* block id: 131 */
                    int32_t **l_183 = &l_140;
                    (*l_183) = (**l_108);
                    /* statement id: 132 */
                    assert (l_140 == 0);
                    if ((*p_81))
                    { /* block id: 133 */
                        (*p_81) = ((int16_t)p_82 << (int16_t)7);
                        if ((*p_81))
                            break;
                    }
                    else
                    { /* block id: 136 */
                        uint16_t l_186 = 0xA01C;
                        (*p_81) = ((*p_81) <= l_186);
                    }
                }
                else
                { /* block id: 139 */
                    (*l_105) = p_81;
                    /* statement id: 140 */
                    //assert (l_106 == &l_73 || l_106 == &l_496 || l_106 == &l_1000);
                }
                /* facts after branching */
                //assert (l_106 == &l_73 || l_106 == 0 || l_106 == &l_496 || l_106 == &l_1000);
            }
            /* facts after for loop */
            //assert (l_106 == &l_73 || l_106 == 0 || l_106 == &l_496 || l_106 == &l_1000);
            assert (l_140 == &l_97 || l_140 == 0);
            l_192 = l_187;
        }
        /* facts after branching */
        //assert (l_106 == &l_73 || l_106 == 0 || l_106 == &l_496 || l_106 == &l_1000);
        assert (l_140 == &l_97 || l_140 == 0);
    }
    /* facts after branching */
    assert (l_101 == 0 || l_101 == &l_102);
    return p_81;
    /* statement id: 146 */
    //assert (func_79_rv == &l_73 || func_79_rv == &l_496 || func_79_rv == &l_1000);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_83(union U2  p_84, uint32_t  p_85, const uint32_t  p_86, union U1  p_87, int32_t * p_88)
{ /* block id: 58 */
    int32_t l_91 = 0;
    l_91 = (((((p_86 ^ l_91) >= ((uint16_t)1U << (uint16_t)((&l_91 == (void*)0) || l_91))) & ((p_86 > l_91) <= p_84.f2)) >= 0x38D59A43) != 1);
    return l_91;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 369
   depth: 1, occurrence: 16
XXX total union variables: 13

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 35
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 9
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 28
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 22

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 251
   depth: 2, occurrence: 63
   depth: 3, occurrence: 8
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 373

XXX times a variable address is taken: 385
XXX times a pointer is dereferenced on RHS: 130
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 16
   depth: 3, occurrence: 9
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 194
breakdown:
   depth: 1, occurrence: 172
   depth: 2, occurrence: 10
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 55
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 25
XXX times a pointer is qualified to be dereferenced: 1176

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 431
   level: 2, occurrence: 75
   level: 3, occurrence: 81
   level: 4, occurrence: 52
   level: 5, occurrence: 34
XXX number of pointers point to pointers: 187
XXX number of pointers point to scalars: 127
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 28.4
XXX average alias set size: 1.22

XXX times a non-volatile is read: 1287
XXX times a non-volatile is write: 552
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 4
XXX backward jumps: 6

XXX stmts: 221
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 37
   depth: 2, occurrence: 39
   depth: 3, occurrence: 38
   depth: 4, occurrence: 37
   depth: 5, occurrence: 34

XXX percentage a fresh-made variable is used: 19.4
XXX percentage an existing variable is used: 80.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

