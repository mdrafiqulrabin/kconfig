/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3403685096
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   const int16_t  f1;
   int16_t  f2;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 17;
   struct S0  f1;
   uint16_t  f2;
   struct S0  f3;
   uint16_t  f4;
   int16_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
inline static int32_t * const  func_34(int32_t  p_35);
static int32_t * func_37(struct S1  p_38, int32_t ** p_39, const struct S1  p_40, const struct S1  p_41);
static struct S1  func_42(uint32_t  p_43, uint32_t  p_44, int32_t * p_45);
static int32_t * func_49(uint32_t  p_50, int16_t  p_51, uint16_t  p_52, int32_t ** p_53, uint32_t  p_54);
static uint16_t  func_55(uint16_t  p_56, int32_t ** p_57);
static int32_t  func_58(struct S1  p_59, uint16_t  p_60);
static float  func_66(uint32_t  p_67, int32_t ** p_68, struct S0  p_69);
inline static struct S0  func_70(int32_t  p_71, int32_t *** p_72);
inline static int32_t *** func_73(int32_t  p_74, struct S0  p_75);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_32 = 0x99333C7D;
    int32_t *l_31 = &l_32;
    int32_t **l_33 = &l_31;
    int32_t l_36 = 0xBD4856CD;
    int32_t **l_677 = &l_31;
    (*l_33) = l_31;
    (*l_677) = func_34(l_36);
    /* statement id: 495 */
    assert (l_31 == 0);
    return l_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_34(int32_t  p_35)
{ /* block id: 38 */
    int32_t l_47 = 0xC114FF6A;
    int32_t *l_46 = &l_47;
    const int32_t *l_48 = &l_47;
    struct S1 l_61 = {297,{0x33DF123E,0xBB05,7},0x21A0,{0x57C1F20C,-1,0x20C2},0x88A0,0x7B2E};
    int32_t **l_673 = &l_46;
    int32_t * const l_674 = &l_47;
    int32_t * const l_675 = &l_47;
    int32_t * const l_676 = (void*)0;
    (*l_673) = func_37(func_42(p_35, (l_46 == l_48), func_49((*l_46), ((&l_48 == &l_46) < func_55((0x1810 > (__builtin_ffs(((func_58(l_61, (*l_46)) == 0x778ADEA0) & (*l_48))) || (*l_48))), &l_46)), p_35, &l_46, (*l_46))), &l_46, l_61, l_61);
    /* statement id: 493 */
    assert (l_46 == 0);
    return l_676;
    /* statement id: 494 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(struct S1  p_38, int32_t ** p_39, const struct S1  p_40, const struct S1  p_41)
{ /* block id: 481 */
    struct S1 l_660 = {138,{0xCCE658A8,0x54D1,-7},65528U,{0U,0x8C86,0},8U,1};
    struct S1 *l_659 = &l_660;
lbl_672:
    for (p_38.f3.f2 = (-14); (p_38.f3.f2 > 15); p_38.f3.f2 += 3)
    { /* block id: 484 */
        struct S1 l_657 = {234,{4294967295U,0xAC3D,1},65535U,{2U,0x898C,2},0x6C41,0};
        struct S1 *l_656 = &l_657;
        struct S1 **l_658 = (void*)0;
        float l_671 = 0x5.733284p-98;
        float *l_670 = &l_671;
        l_659 = l_656;
        /* statement id: 485 */
        assert (l_659 == &l_657);
        (**p_39) = l_657.f3.f0;
        if ((**p_39))
            continue;
        //assert (l_659 == dangling);
        (*l_670) = (((0xA.51063Bp-70 <= p_40.f2) >= p_38.f3.f1) > (((float)(p_40.f4 > (p_41.f5 <= l_660.f1.f2)) - (float)((float)__builtin_ia32_crc32qi(((~((uint16_t)l_657.f0 - (uint16_t)p_41.f0)) ^ ((uint32_t)4294967294U + (uint32_t)l_660.f3.f1)), l_657.f0) + (float)p_41.f1.f1)) <= 0x0.Bp-1));
        if (l_657.f0)
            goto lbl_672;
        //assert (l_659 == dangling);
    }
    (*p_39) = (void*)0;
    /* statement id: 491 */
    //assert (l_46 == 0);
    return (*p_39);
    /* statement id: 492 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_42(uint32_t  p_43, uint32_t  p_44, int32_t * p_45)
{ /* block id: 477 */
    int32_t l_646 = (-7);
    int32_t *l_645 = &l_646;
    int32_t **l_647 = (void*)0;
    int32_t **l_648 = &l_645;
    struct S0 l_650 = {1U,-2,0x5477};
    struct S0 *l_649 = &l_650;
    const struct S0 **l_651 = (void*)0;
    struct S0 **l_652 = &l_649;
    struct S1 l_653 = {284,{0x7930573B,-10,0},1U,{0x178BEB20,0x2D62,6},0x5AAE,0x5E33};
    (*l_648) = l_645;
    (*l_652) = l_649;
    return l_653;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(uint32_t  p_50, int16_t  p_51, uint16_t  p_52, int32_t ** p_53, uint32_t  p_54)
{ /* block id: 399 */
    const uint16_t l_534 = 65535U;
    float l_545 = 0x5.C4297Ap+95;
    int32_t l_553 = 2;
    int32_t *l_552 = &l_553;
    struct S0 l_558 = {0x96CAA051,0x8EE5,8};
    struct S0 * const l_557 = &l_558;
    struct S1 l_602 = {190,{0x81DD4E56,0xDBCE,0xD1AC},0xEC8E,{0x039433C6,0xA252,0x6B5A},1U,0x565E};
    int32_t *l_603 = &l_553;
    int32_t l_644 = 0x81FB296F;
    for (p_50 = 18; (p_50 == 18); ++p_50)
    { /* block id: 402 */
        uint16_t l_546 = 65531U;
        struct S0 l_579 = {0xA32952D9,0x9B59,0x4913};
        int32_t *l_583 = &l_553;
        int32_t **l_608 = &l_583;
        int32_t ***l_607 = &l_608;
        int32_t ****l_606 = &l_607;
        int32_t *****l_605 = &l_606;
    }
    (*l_603) = (*l_603);
    return (*p_53);
    /* statement id: 476 */
    //assert (func_49_rv == &l_47);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_55(uint16_t  p_56, int32_t ** p_57)
{ /* block id: 385 */
    int32_t * const l_497 = (void*)0;
    int32_t *l_499 = (void*)0;
    int32_t **l_498 = &l_499;
    struct S1 **l_505 = (void*)0;
    struct S1 ** const *l_504 = &l_505;
    struct S0 l_512 = {4294967295U,-8,4};
    struct S0 *l_511 = &l_512;
    (*l_498) = l_497;
    if (((uint16_t)p_56 << (uint16_t)12))
    { /* block id: 387 */
        const uint32_t l_516 = 7U;
        for (p_56 = 13; (p_56 != 40); p_56++)
        { /* block id: 390 */
            struct S0 *l_510 = (void*)0;
            int32_t l_515 = (-1);
            float l_518 = (-0x1.5p+1);
            float *l_517 = &l_518;
            struct S1 l_519 = {320,{4294967295U,0x6024,-1},65534U,{0x1D59A99D,4,0xA86E},0xA56C,0xB197};
            struct S1 ***l_528 = &l_505;
            int32_t *l_529 = &l_515;
            (*l_517) = ((l_504 != &l_505) > ((((-0x1.9p+1) < (+((float)(+(l_510 != l_511)) + (float)((float)l_515 + (float)p_56)))) <= (0x5.41B354p-36 > (((((((0x7.24B5A7p-76 < p_56) != p_56) >= p_56) != l_516) <= 0x0.7p-1) <= p_56) > 0x0.80D964p+94))) != p_56));
            (*l_517) = l_515;
            (*l_529) = func_58(l_519, ((int16_t)(__builtin_ia32_crc32qi(p_56, l_516) >= ((int16_t)9 << (int16_t)(((int16_t)((l_519.f5 > ((uint16_t)0x796C >> (uint16_t)14)) | ((void*)0 != l_528)) >> (int16_t)0) | (-1)))) << (int16_t)l_515));
        }
    }
    else
    { /* block id: 395 */
        return p_56;
    }
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_58(struct S1  p_59, uint16_t  p_60)
{ /* block id: 39 */
    int32_t l_64 = 0;
    int32_t *l_63 = &l_64;
    int32_t **l_62 = &l_63;
    int32_t ***l_65 = &l_62;
    struct S0 l_78 = {0x5C685B35,1,0x58E9};
    (*l_65) = l_62;
    (**l_62) = ((func_66(p_59.f3.f1, (*l_65), func_70((((*l_63) <= 9) == (p_59.f3.f2 & ((*l_62) != (*l_62)))), func_73((((int32_t)(***l_65) - (int32_t)__builtin_ctzl((**l_62))) == 1), l_78))) <= p_59.f1.f2) > (*l_63));
    return p_59.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_66(uint32_t  p_67, int32_t ** p_68, struct S0  p_69)
{ /* block id: 47 */
    int32_t l_91 = 9;
    int32_t *l_90 = &l_91;
    float *l_92 = (void*)0;
    float l_94 = 0x0.8p-1;
    float *l_93 = &l_94;
    int32_t l_113 = (-1);
    int32_t *l_126 = &l_91;
    int32_t ** const l_146 = &l_90;
    uint32_t l_173 = 4294967289U;
    int32_t ** const *l_188 = &l_146;
    int32_t ** const ** const l_187 = &l_188;
    struct S1 l_193 = {314,{0xBD1A66B9,-9,0xE436},0x85E4,{1U,0x342E,3},0U,0x1F4F};
    struct S1 *l_192 = &l_193;
    struct S1 **l_191 = &l_192;
    struct S0 *l_206 = (void*)0;
    int32_t *l_246 = &l_113;
    int32_t l_266 = 0x9FC50761;
    struct S0 **l_283 = &l_206;
    uint32_t l_402 = 0xD78697EF;
    int32_t *l_450 = &l_113;
    struct S1 ***l_493 = (void*)0;
    struct S1 ****l_492 = &l_493;
    (*l_93) = (((void*)0 != l_90) == p_69.f1);
    for (l_91 = 0; (l_91 == 12); ++l_91)
    { /* block id: 51 */
        uint32_t l_97 = 4294967289U;
        uint32_t l_98 = 0x9A650DEC;
        struct S1 l_148 = {96,{4294967295U,0,0x5B98},0xA9A9,{4294967295U,1,0xFD32},0xAA63,0x172F};
        struct S1 *l_147 = &l_148;
        int32_t l_215 = 0xB7E2CB60;
    }
    return p_69.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_70(int32_t  p_71, int32_t *** p_72)
{ /* block id: 44 */
    int32_t l_88 = 0xD8B2F938;
    int32_t *l_87 = &l_88;
    int32_t **l_86 = &l_87;
    struct S0 l_89 = {4294967291U,-8,0};
    (*l_86) = &p_71;
    /* statement id: 45 */
    assert (l_87 == &p_71);
    return l_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t *** func_73(int32_t  p_74, struct S0  p_75)
{ /* block id: 41 */
    float l_80 = 0x9.0DD067p-81;
    float *l_79 = &l_80;
    int32_t l_84 = 0x95E1C378;
    int32_t *l_83 = &l_84;
    int32_t **l_82 = &l_83;
    int32_t ***l_81 = &l_82;
    int32_t ***l_85 = (void*)0;
    (*l_79) = p_75.f0;
    return l_85;
    /* statement id: 43 */
    //assert (func_73_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 165
   depth: 1, occurrence: 3
   depth: 2, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 4

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
   depth: 14, occurrence: 2
   depth: 17, occurrence: 2
   depth: 25, occurrence: 1

XXX total number of pointers: 168

XXX times a variable address is taken: 165
XXX times a pointer is dereferenced on RHS: 155
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 58
   depth: 3, occurrence: 9
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 141
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 29
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 452

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 268
   level: 2, occurrence: 139
   level: 3, occurrence: 22
   level: 4, occurrence: 16
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 52
XXX number of pointers point to structs: 31
XXX percent of pointers has null in alias set: 23.8
XXX average alias set size: 1.23

XXX times a non-volatile is read: 898
XXX times a non-volatile is write: 396
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 5
XXX backward jumps: 6

XXX stmts: 37
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 7
   depth: 2, occurrence: 3

XXX percentage a fresh-made variable is used: 23.7
XXX percentage an existing variable is used: 76.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

