/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3010550424
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   uint32_t  f4;
};

union U1 {
   int16_t  f0;
   int16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   signed f4 : 26;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_31(void);
inline static struct S0  func_32(uint16_t  p_33);
static int16_t  func_38(struct S0  p_39, int16_t  p_40, int32_t  p_41);
inline static struct S0  func_42(uint16_t  p_43);
inline static int32_t  func_58(uint32_t  p_59, struct S0  p_60);
inline static int32_t  func_64(uint32_t  p_65);
inline static struct S0  func_67(int32_t  p_68, int32_t  p_69, uint32_t  p_70);
static uint32_t  func_72(int16_t  p_73, int32_t  p_74, struct S0  p_75, uint16_t  p_76, int32_t  p_77);
static int32_t  func_80(uint32_t  p_81, struct S0  p_82);
static uint32_t  func_91(uint32_t  p_92, int16_t  p_93, int32_t  p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_47 = 5;
    int32_t l_48 = (-3);
    int32_t l_49 = 0x6BB64548;
    int32_t l_50 = 0xB6652F09;
    uint16_t l_240 = 0xCF2E;
    int32_t l_245 = 3;
    struct S0 l_246 = {4294967295U,65535U,0xB5C86E0D,0,0x90666A6A};
    uint32_t l_247 = 4294967286U;
    l_246 = func_32(((int32_t)((int16_t)func_38(func_42(((int16_t)(!l_47) >> (int16_t)((l_50 = (l_49 = (l_48 = l_47))) && (~l_49)))), l_240, (((((int16_t)((func_58(((8 & (((l_240 | l_47) < (l_245 = (l_240 >= l_240))) == 0x0608)) && l_245), l_246) || l_245) & l_47) % (int16_t)l_246.f2) | l_246.f4) , l_247) && l_47)) >> (int16_t)l_246.f4) % (int32_t)2U));
    return l_246.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_32(uint16_t  p_33)
{ /* block id: 207 */
    uint16_t l_352 = 0x7B00;
    int32_t l_353 = 7;
    int32_t l_354 = (-1);
    struct S0 l_355 = {0x02C7A5C5,0U,0x9911B011,0,0U};
    l_354 = (l_353 = l_352);
    l_353 &= (-1);
    l_354 &= l_353;
    l_354 = func_64(l_354);
    return l_355;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_38(struct S0  p_39, int16_t  p_40, int32_t  p_41)
{ /* block id: 134 */
    uint32_t l_248 = 0U;
    struct S0 l_249 = {4294967288U,1U,4294967286U,0,0x29273612};
    struct S0 l_274 = {4294967289U,0x8E97,0U,0x0136C29E,1U};
    uint32_t l_298 = 0x83CCC9B7;
    int32_t l_341 = 6;
    l_249 = func_42(l_248);
    for (l_249.f1 = 1; (l_249.f1 < 16); l_249.f1 += 1)
    { /* block id: 138 */
        int16_t l_252 = 0xEBB1;
        int32_t l_276 = 0;
        struct S0 l_281 = {0xB612D4DC,0x4D1B,7U,0xD819F3F1,4U};
        uint16_t l_327 = 65526U;
        uint32_t l_340 = 4294967295U;
        uint32_t l_344 = 0x055DAE04;
        l_252 |= __builtin_parityl(l_248);
        if (((int16_t)p_39.f4 << (int16_t)3))
        { /* block id: 140 */
            int16_t l_257 = 0xD5F5;
            struct S0 l_261 = {0x6CC735A5,0x3612,3U,3,9U};
            for (p_41 = (-30); (p_41 < 16); p_41 += 1)
            { /* block id: 143 */
                int32_t l_264 = 0xFE4C1CF0;
                int32_t l_272 = 0x3804D962;
                struct S0 l_273 = {0xBB8F7548,0x9A67,4294967295U,0xBD6D18A2,4294967295U};
                uint16_t l_275 = 1U;
                uint16_t l_299 = 65535U;
                l_257 = 1;
                for (p_39.f0 = 15; (p_39.f0 < 2); p_39.f0 -= 3)
                { /* block id: 147 */
                    struct S0 l_260 = {1U,6U,0x9B06FB9F,0xB8033DE5,0x51DF1B90};
                    l_261 = l_260;
                    if (l_252)
                        break;
                    p_39.f3 ^= (l_273.f3 = (func_91(((uint16_t)l_252 * (uint16_t)((-1) || p_41)), ((0xC0E0 ^ ((l_264 = 0xE965) == (p_39.f1 = (1 | (-(int32_t)l_261.f3))))) == ((((int16_t)(((int16_t)((int32_t)func_72(l_272, l_252, l_273, l_273.f2, l_260.f2) + (int32_t)1U) >> (int16_t)p_39.f2) , p_40) << (int16_t)l_273.f0) >= l_252) <= p_40)), p_41) > 0x0F83735A));
                    l_274 = l_273;
                }
                if ((p_39.f0 ^ (0x3E88C3CE > l_274.f3)))
                { /* block id: 156 */
                    uint16_t l_297 = 0x79F6;
                    l_276 = l_275;
                    l_274.f3 = (l_276 < ((uint16_t)(((int16_t)((l_281 , (((!l_272) > 0xC576) , func_58(((p_39.f3 &= l_281.f4) , ((((int16_t)(((p_39.f1 | ((int32_t)(((int32_t)(((uint32_t)(((int32_t)((int16_t)(((l_281.f3 = ((p_40 = l_274.f2) > ((uint16_t)l_257 << (uint16_t)p_39.f2))) == l_248) <= l_297) >> (int16_t)3) + (int32_t)0U) | p_39.f2) + (uint32_t)7) , l_275) % (int32_t)4294967291U) & 1U) % (int32_t)0x0F7FBA5C)) != p_39.f0) < 0x7A7D) << (int16_t)l_298) ^ 0x3CF452AD) && (-2))), l_249))) == l_261.f2) - (int16_t)l_299) <= 0x4DEAF234) << (uint16_t)l_281.f0));
                    p_39.f3 |= 0;
                    l_272 &= func_58(l_257, p_39);
                }
                else
                { /* block id: 164 */
                    int32_t l_324 = 0x111D3FE6;
                    int32_t l_347 = 0;
                    int32_t l_348 = 0x67E77126;
                    for (l_274.f2 = (-19); (l_274.f2 != 42); l_274.f2 += 1)
                    { /* block id: 167 */
                        int32_t l_312 = 0x600E6A57;
                        int32_t l_316 = (-1);
                        int32_t l_323 = 1;
                        l_276 = (l_249.f3 &= ((((uint16_t)((uint16_t)l_276 % (uint16_t)((uint16_t)((uint16_t)(l_324 = ((uint16_t)(((p_39.f1 = l_312) & ((int32_t)(4294967295U != (-(uint32_t)p_40)) % (int32_t)l_312)) & p_39.f3) * (uint16_t)((p_39.f0 | ((l_316 ^= p_39.f2) , ((((((l_273.f3 = (((int16_t)(((int32_t)(l_323 |= ((int16_t)(l_316 < l_272) >> (int16_t)12)) - (int32_t)4294967287U) > l_324) >> (int16_t)p_40) ^ p_39.f3)) != 0x65BEFB07) , p_39.f4) < l_324) || p_40) , l_274.f3))) && l_272))) - (uint16_t)p_40) + (uint16_t)l_273.f4)) >> (uint16_t)14) , 1U) != 0x27D5));
                        p_39.f3 ^= 0x9CC34788;
                        l_324 ^= p_39.f3;
                        l_281.f3 &= 1;
                    }
                    if ((__builtin_bswap32(l_261.f3) != 0x14E59211))
                    { /* block id: 179 */
                        uint32_t l_330 = 0xF2F72A91;
                        int32_t l_342 = 6;
                        l_330 ^= ((int32_t)(p_39.f0 == (l_327 == (9U | (p_39.f1 = (((int16_t)(p_39.f4 < 0xACA3) << (int16_t)0) ^ 0xCBF5E0FD))))) + (int32_t)(l_261.f4 ^ func_80(p_39.f4, l_261)));
                        l_341 ^= (((l_272 , ((l_281.f3 = (((int16_t)p_39.f3 >> (int16_t)10) , 0xE41F)) < ((uint16_t)(l_340 &= __builtin_bswap32((p_39.f0 >= (!((int16_t)(((uint16_t)l_330 * (uint16_t)(((l_249.f3 |= l_281.f4) | (l_274.f3 = ((1 != l_324) != func_72(p_41, l_330, p_39, p_39.f2, p_39.f3)))) | p_39.f2)) & p_39.f4) + (int16_t)l_324))))) + (uint16_t)p_39.f0))) | 65528U) > l_281.f1);
                        l_342 = l_324;
                    }
                    else
                    { /* block id: 188 */
                        struct S0 l_343 = {8U,0x02B6,0x4AA25C52,-1,0U};
                        p_39 = l_343;
                        if (l_261.f0)
                            break;
                        l_343.f3 = ((__builtin_ffs(l_344) | l_324) >= ((int16_t)(l_347 = l_343.f2) << (int16_t)l_348));
                    }
                    l_324 ^= (p_39.f3 = (((uint16_t)(p_39.f0 ^ 0xA3CD) >> (uint16_t)((__builtin_parityl(l_274.f0) && ((func_58((p_39.f0 | (p_40 == (p_39.f0 | (((((p_39.f1 , (l_272 = (l_275 > 0x75B3))) , 0x4CAF) ^ 0) & l_347) > p_39.f2)))), p_39) && l_348) && p_40)) || p_39.f3)) <= l_281.f2));
                }
                p_39 = func_67(l_248, (l_276 = p_39.f3), l_273.f0);
            }
            if (l_252)
                break;
        }
        else
        { /* block id: 202 */
            uint32_t l_351 = 4294967295U;
            return l_351;
        }
    }
    return p_39.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_42(uint16_t  p_43)
{ /* block id: 40 */
    int16_t l_56 = 9;
    int32_t l_173 = 0x52F1CB2A;
    int32_t l_183 = 4;
    int32_t l_185 = 0x988898D0;
    union U1 l_192 = {1};
    struct S0 l_200 = {0U,0x339A,0U,4,0x125292E0};
    int32_t l_214 = 0xD788D995;
    struct S0 l_215 = {0x9A10EB1A,0x0853,0x953446F3,-1,0U};
    uint16_t l_216 = 0x2488;
    int32_t l_217 = 0xE8EBB9B1;
    int32_t l_218 = 0;
    int32_t l_219 = (-7);
    int32_t l_220 = 0x29B7C7E5;
    union U1 l_221 = {0x14C2};
    int32_t l_235 = 0x5B5E6331;
    for (p_43 = 0; (p_43 >= 4); p_43 += 7)
    { /* block id: 43 */
        int16_t l_57 = 0xB49A;
        int32_t l_66 = 1;
        int32_t l_176 = 0x1638C063;
        int32_t l_177 = 0;
        int32_t l_178 = 0xE7F41821;
        union U1 l_193 = {0x5C09};
        l_57 = ((int16_t)l_56 - (int16_t)l_56);
        l_185 = func_58(((-(int32_t)((uint16_t)(l_173 &= (func_64((l_66 &= l_56)) , l_56)) - (uint16_t)l_56)) >= (l_178 = (l_177 = (((int16_t)p_43 + (int16_t)((l_176 = p_43) >= p_43)) , l_56)))), func_67(((int16_t)(((l_183 &= (((uint16_t)(p_43 & 3U) * (uint16_t)l_57) || 0xD16D)) | 0xF02E390C) , l_57) - (int16_t)1U), p_43, p_43));
        l_177 = ((l_66 = (0x6330 != (((uint16_t)l_56 >> (uint16_t)8) , 0))) ^ (l_183 = ((uint16_t)(((int32_t)__builtin_clz((l_192 , (__builtin_popcount(((l_193 = l_192) , (((((((((int32_t)(l_200.f3 = func_80(((((int32_t)(-1) - (int32_t)l_193.f1) || ((int16_t)func_64(p_43) >> (int16_t)l_193.f0)) , 4294967295U), l_200)) % (int32_t)0x49FD6B0D) ^ p_43) || 4) | l_185) , p_43) && 0xBD2D3370) && l_200.f4) & l_192.f0))) , p_43))) + (int32_t)p_43) <= 1) - (uint16_t)p_43)));
    }
    l_220 = ((l_192.f4 = (((int16_t)(p_43 != ((uint16_t)(l_200.f3 ^= 0x68CC) << (uint16_t)((int16_t)((uint16_t)(l_173 = l_192.f0) * (uint16_t)((l_183 &= (-10)) >= ((int16_t)l_200.f1 * (int16_t)l_200.f0))) % (int16_t)1))) - (int16_t)((l_219 = (l_218 = (((l_185 = (-1)) ^ (~((int16_t)(l_217 = (l_215.f3 = ((((func_58((l_214 = p_43), l_215) > l_200.f4) ^ l_215.f4) < 0x92F54D7D) , l_216))) >> (int16_t)p_43))) ^ l_218))) | p_43)) <= l_216)) , l_219);
    l_217 = ((l_221 = l_192) , ((uint16_t)func_64((((int32_t)l_200.f3 - (int32_t)((int16_t)l_217 % (int16_t)((uint32_t)l_200.f0 - (uint32_t)((l_214 <= p_43) || p_43)))) , (~(((uint16_t)(l_173 = (((uint16_t)p_43 >> (uint16_t)(l_200.f1 | 4)) >= 0x81FCDCBA)) >> (uint16_t)p_43) ^ l_215.f1)))) << (uint16_t)p_43));
    l_221.f3 = ((func_64(l_235) >= __builtin_clzll(((p_43 || (l_215.f4 == ((uint16_t)65528U >> (uint16_t)l_221.f4))) , ((l_200.f4 , ((uint32_t)(__builtin_clz((l_185 = 0x59D00192)) , p_43) + (uint32_t)4294967295U)) != 1U)))) ^ 0x07AD);
    return l_215;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_58(uint32_t  p_59, struct S0  p_60)
{ /* block id: 107 */
    int32_t l_184 = 1;
    return l_184;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_64(uint32_t  p_65)
{ /* block id: 46 */
    uint32_t l_71 = 8U;
    uint32_t l_119 = 4294967295U;
    struct S0 l_120 = {1U,0x8F9F,1U,0x7EAB3286,1U};
    struct S0 l_167 = {0x307C177F,65535U,0x08C6B94E,0xEA996BB9,4294967294U};
    union U1 l_168 = {0xAF5B};
    l_120 = func_67(p_65, l_71, func_72(((int16_t)((func_80(((int16_t)(0U > ((uint16_t)(((0U != ((uint32_t)p_65 - (uint32_t)((-(uint32_t)(1U >= 0x08A8)) , __builtin_bswap32((~((0x79B1 <= (func_91(p_65, p_65, p_65) < 1)) != 0U)))))) != l_71) < 0x503A) >> (uint16_t)l_119)) * (int16_t)p_65), l_120) , p_65) >= l_120.f2) >> (int16_t)l_120.f2), l_120.f2, l_120, l_119, l_71));
    for (l_120.f0 = 0; (l_120.f0 <= 11); l_120.f0 += 1)
    { /* block id: 85 */
        int16_t l_157 = (-4);
        struct S0 l_166 = {0x0ACBBF45,0xDDAA,0U,0x784999CA,4294967295U};
        l_167 = ((((int32_t)1 - (int32_t)(l_119 < l_71)) , (l_157 || __builtin_ctz((l_120.f3 = ((uint16_t)((uint16_t)p_65 - (uint16_t)p_65) * (uint16_t)((uint16_t)((int16_t)(0 > (__builtin_bswap32(p_65) & 0xD0B1)) << (int16_t)10) - (uint16_t)p_65)))))) , l_166);
        l_166.f3 = p_65;
        if (p_65)
            continue;
        if (l_120.f0)
            break;
    }
    if ((l_168 , (((l_167.f0 && l_120.f3) , l_168) , l_119)))
    { /* block id: 92 */
        union U1 l_170 = {0x7CF2};
        struct S0 l_171 = {0xC7F9DB91,0x04C5,0U,-3,4294967287U};
        l_168.f4 = l_167.f1;
        l_120.f3 = (l_120.f2 == p_65);
        l_171 = ((__builtin_bswap32((!l_120.f0)) == ((l_170.f3 = (l_170 , l_120.f1)) > l_120.f0)) , l_171);
    }
    else
    { /* block id: 97 */
        int16_t l_172 = 0x2475;
        l_172 |= __builtin_popcount(l_120.f3);
    }
    l_120.f3 = p_65;
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_67(int32_t  p_68, int32_t  p_69, uint32_t  p_70)
{ /* block id: 71 */
    int32_t l_133 = 0xF99D2484;
    int32_t l_135 = (-1);
    struct S0 l_136 = {0xEF4A51DB,0U,4294967287U,0x863885E3,0xC3E796DA};
    int32_t l_145 = 0xF0B25D92;
    int32_t l_150 = (-1);
    uint32_t l_151 = 0xD649878E;
    int32_t l_152 = (-1);
    l_133 = p_70;
    l_152 |= (-(int16_t)(func_72(l_133, ((l_135 = 0x8CF6) , ((l_136 , p_69) | ((uint32_t)((int16_t)((((int32_t)0x92195432 % (int32_t)(l_135 = 0xD2F2FD22)) > (l_151 = __builtin_popcount(((uint32_t)((l_145 ^= (p_70 , 0x7F86)) | (((uint16_t)((uint16_t)((l_150 = __builtin_ffsl((func_80(l_136.f4, l_136) >= p_68))) >= p_70) * (uint16_t)l_136.f1) - (uint16_t)p_69) , 0x7740)) - (uint32_t)0U)))) & l_136.f2) >> (int16_t)3) + (uint32_t)1))), l_136, p_68, l_136.f3) >= 0x99EB));
    l_135 &= (l_136.f3 = l_136.f3);
    return l_136;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_72(int16_t  p_73, int32_t  p_74, struct S0  p_75, uint16_t  p_76, int32_t  p_77)
{ /* block id: 68 */
    p_77 = (p_74 | ((uint32_t)p_73 + (uint32_t)0xEF1402E7));
    return p_75.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_80(uint32_t  p_81, struct S0  p_82)
{ /* block id: 62 */
    struct S0 l_121 = {4294967295U,0xAAE8,0x0F1DDE4E,-2,4294967295U};
    int32_t l_129 = (-1);
    int32_t l_130 = 0xED54F57E;
    l_121 = p_82;
    l_130 &= (l_121.f3 | (65535U == (((uint32_t)(p_82.f2 , ((uint16_t)(p_82.f1 |= (~((uint16_t)(l_121.f3 , l_121.f4) * (uint16_t)0x325A))) >> (uint16_t)10)) + (uint32_t)__builtin_parityl(l_121.f0)) || (((l_129 = (p_82.f3 > p_82.f0)) >= 0) , l_121.f2))));
    return l_121.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_91(uint32_t  p_92, int16_t  p_93, int32_t  p_94)
{ /* block id: 47 */
    uint32_t l_102 = 0x466640DD;
    int32_t l_108 = 1;
    int32_t l_114 = 2;
    int32_t l_118 = (-8);
    for (p_94 = (-19); (p_94 >= 7); p_94 += 1)
    { /* block id: 50 */
        uint16_t l_107 = 65527U;
        int32_t l_115 = (-1);
        int32_t l_116 = 0x8F7D061D;
        int32_t l_117 = (-8);
        l_118 |= (~(((int16_t)p_94 << (int16_t)((int32_t)l_102 % (int32_t)(l_117 = ((int32_t)((l_116 &= (l_115 = __builtin_ia32_crc32qi((p_93 == ((((uint16_t)(l_107 <= p_93) * (uint16_t)(-1)) || (l_108 |= (p_92 = p_93))) | ((uint32_t)(l_114 = ((int16_t)p_94 * (int16_t)(~p_94))) + (uint32_t)p_93))), p_93))) > 0x76AF) % (int32_t)(-4))))) | l_107));
        l_116 = __builtin_parity(l_115);
    }
    p_94 |= p_93;
    return l_118;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 86
   depth: 1, occurrence: 17
XXX total union variables: 5

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 6
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 1

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 17
   depth: 3, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 3
   depth: 17, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 2
   depth: 32, occurrence: 3
   depth: 33, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 311
XXX times a non-volatile is write: 121
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 76
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 15
   depth: 2, occurrence: 3
   depth: 3, occurrence: 4
   depth: 4, occurrence: 11
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 24
XXX percentage an existing variable is used: 76
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

