/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2168041116
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   int32_t  f1;
   uint16_t  f2;
};

struct S1 {
   signed f0 : 16;
   unsigned f1 : 7;
   signed f2 : 12;
   signed f3 : 18;
   signed f4 : 8;
   signed f5 : 1;
   unsigned f6 : 12;
   signed f7 : 25;
   unsigned : 0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_30(void);
inline static struct S1  func_31(uint16_t  p_32, struct S0  p_33, uint16_t  p_34, struct S1  p_35);
static struct S0  func_37(uint32_t  p_38, int8_t  p_39);
inline static uint16_t  func_50(struct S0  p_51, uint32_t  p_52);
inline static int16_t  func_60(int32_t  p_61, int32_t  p_62);
inline static struct S1  func_70(int32_t  p_71);
static struct S0  func_88(int32_t  p_89, uint32_t  p_90, int8_t  p_91, struct S0  p_92);
static int32_t  func_99(struct S0  p_100);
inline static int16_t  func_118(uint16_t  p_119, uint16_t  p_120, uint16_t  p_121, uint32_t  p_122, int8_t  p_123);
inline static uint16_t  func_124(int32_t  p_125);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(void)
{ /* block id: 36 */
    uint32_t l_36 = 5U;
    struct S0 l_53 = {0x10EF,-1,1U};
    int32_t l_198 = 0xEA1F2CDD;
    uint32_t l_199 = 0xCDC079AD;
    struct S1 l_222 = {193,10,-36,-424,7,-0,48,2538};
    struct S0 l_256 = {0x83FD,0x632D29E3,65532U};
    int32_t l_303 = 3;
    uint32_t l_326 = 4294967287U;
    struct S1 l_375 = {-150,2,-50,-462,-15,-0,32,-65};
    l_222 = func_31(l_36, func_37((((__builtin_ctzll((l_36 , l_36)) && ((uint16_t)((int16_t)((uint16_t)((uint16_t)l_36 << (uint16_t)9) + (uint16_t)(l_198 = ((uint16_t)(l_53.f1 = func_50(l_53, l_53.f0)) % (uint16_t)((int16_t)__builtin_ia32_crc32qi(l_53.f0, l_53.f0) * (int16_t)0xEAFE)))) % (int16_t)l_53.f0) % (uint16_t)l_199)) != l_36) , l_36), l_53.f2), l_199, l_222);
    for (l_198 = (-7); (l_198 == (-9)); l_198 -= 1)
    { /* block id: 123 */
        int16_t l_238 = 1;
        int32_t l_240 = 0;
        struct S0 l_248 = {0U,8,65535U};
        int32_t l_268 = 1;
        int16_t l_279 = 0xA313;
        struct S1 l_301 = {-148,3,12,-265,-14,-0,37,-1797};
        uint32_t l_304 = 0xD96D4E70;
        uint32_t l_356 = 0x4C876800;
        uint32_t l_357 = 3U;
        uint16_t l_364 = 0xBBC8;
        struct S1 l_373 = {223,2,-24,44,-7,0,45,-1837};
        int32_t l_374 = 0xC998FD2F;
        if ((l_222.f3 = (l_238 > l_222.f1)))
        { /* block id: 125 */
            int32_t l_244 = (-1);
            struct S0 l_247 = {65535U,-7,0xE317};
            int32_t l_251 = 0x6E15FCF3;
            struct S0 l_278 = {0x767E,0,0U};
            struct S1 l_280 = {-107,2,-30,51,-3,-0,40,5145};
            int32_t l_327 = 1;
            l_222.f3 ^= (l_36 , (l_238 | (__builtin_ctzll(l_222.f7) && (-(uint32_t)l_238))));
            if ((l_240 ^= l_222.f2))
            { /* block id: 128 */
                int32_t l_243 = 5;
                l_244 ^= ((int16_t)(l_243 |= 1) >> (int16_t)0);
                return l_244;
            }
            else
            { /* block id: 132 */
                int16_t l_253 = 0x301E;
                int16_t l_265 = 0xDBD0;
                int32_t l_297 = 0x3A81244A;
                struct S1 l_302 = {-73,1,16,354,2,0,41,3719};
                for (l_53.f2 = 0; (l_53.f2 > 11); l_53.f2 += 2)
                { /* block id: 135 */
                    uint32_t l_252 = 0xBB3E879F;
                    l_248 = l_247;
                    for (l_36 = (-22); (l_36 != 21); l_36 += 1)
                    { /* block id: 139 */
                        l_244 = l_251;
                    }
                    if (l_252)
                        break;
                }
                if (l_253)
                { /* block id: 144 */
                    struct S0 l_257 = {0U,0x83BBFEA0,0x6ECE};
                    for (l_240 = 0; (l_240 <= (-5)); l_240 -= 7)
                    { /* block id: 147 */
                        return l_247.f2;
                    }
                    l_257 = l_256;
                }
                else
                { /* block id: 151 */
                    int8_t l_258 = 0xD7;
                    int32_t l_266 = 0x3906056C;
                    l_222.f2 = l_253;
                    l_258 &= __builtin_clz(l_199);
                    for (l_240 = 0; (l_240 > 10); l_240 += 1)
                    { /* block id: 156 */
                        int32_t l_267 = 8;
                        struct S0 l_269 = {0xB14A,9,0x09E1};
                        l_222.f4 = (0xF8AC < ((uint16_t)l_247.f1 * (uint16_t)__builtin_ctzl(l_222.f5)));
                        l_222.f4 = ((l_53.f2 || ((int16_t)(l_247.f1 &= ((l_265 ^ l_248.f1) | (l_266 = l_258))) * (int16_t)((((l_268 ^= (l_267 ^ (6U || l_222.f7))) == ((((l_269 , ((int16_t)(l_251 = (((uint16_t)func_118(func_99(func_88(((int32_t)((int16_t)(l_265 >= l_253) << (int16_t)l_248.f2) % (int32_t)0x22B61524), l_253, l_244, l_278)), l_248.f2, l_258, l_279, l_279) >> (uint16_t)7) || l_269.f1)) % (int16_t)0x7671)) & l_248.f2) & l_279) & l_256.f0)) | 0x57DA) != 1))) , l_266);
                        l_280 = l_222;
                    }
                }
                for (l_53.f2 = 14; (l_53.f2 == 23); l_53.f2 += 5)
                { /* block id: 168 */
                    struct S0 l_285 = {0x9FFB,0xCE056BAF,3U};
                    int16_t l_288 = 1;
                    struct S1 l_298 = {-82,8,10,-20,3,0,35,2027};
                    for (l_238 = 0; (l_238 == (-25)); l_238 -= 1)
                    { /* block id: 171 */
                        return l_53.f2;
                    }
                    l_285 = l_247;
                    l_240 |= ((((uint16_t)(l_288 | (l_280.f4 >= ((uint16_t)(__builtin_parityl(((l_53.f0 > l_265) || l_285.f2)) | ((l_285.f1 = (l_297 &= ((l_244 = (l_248.f1 ^= (-1))) ^ ((int16_t)((int16_t)(0xF8BD != (l_265 < l_285.f2)) - (int16_t)65533U) << (int16_t)0)))) , 4294967291U)) * (uint16_t)0x4803))) << (uint16_t)4) ^ l_288) || l_268);
                    l_304 = __builtin_popcountll((((l_298 , ((l_279 | ((l_222.f1 , ((int16_t)(l_265 > (l_297 = l_279)) >> (int16_t)13)) <= (((l_302 = l_301) , l_288) && l_285.f1))) == l_238)) <= l_248.f1) , l_303));
                }
            }
            l_301.f4 = l_280.f2;
            l_222.f4 = ((l_301.f0 = (l_222.f3 = func_60(l_279, (((__builtin_ctzll(((uint16_t)((((uint16_t)(l_222.f7 != l_301.f6) << (uint16_t)((uint32_t)(((int32_t)((((((int32_t)((uint16_t)(((int16_t)(-(uint16_t)l_251) >> (int16_t)((l_240 > (l_247.f1 = __builtin_clz(l_251))) < 1)) < (((uint32_t)((uint16_t)((int16_t)(0x45E8 < l_222.f3) >> (int16_t)13) + (uint16_t)l_53.f1) % (uint32_t)l_222.f1) | 0)) << (uint16_t)6) - (int32_t)l_278.f1) && l_222.f3) != 65527U) <= 0xC18ECF1C) , l_326) - (int32_t)l_280.f0) >= 0x7F55) + (uint32_t)0U)) > 0xFDBE8BD6) ^ l_280.f1) >> (uint16_t)8)) | 0) ^ l_256.f1) >= l_327)))) && 0x63CE);
        }
        else
        { /* block id: 190 */
            uint16_t l_328 = 0xFB6F;
            struct S0 l_329 = {0xEF46,0x0E203554,0x086D};
            int32_t l_333 = 6;
            if (l_328)
            { /* block id: 191 */
                int16_t l_330 = 0x9ABA;
                int32_t l_346 = (-8);
                int32_t l_365 = (-10);
                struct S1 l_367 = {-15,0,-58,507,-2,0,55,-4647};
                l_248 = l_329;
                l_330 ^= ((l_329.f1 = 1U) || 2U);
                for (l_329.f1 = 0; (l_329.f1 <= (-8)); l_329.f1 -= 5)
                { /* block id: 197 */
                    uint32_t l_334 = 7U;
                    struct S0 l_366 = {0x1E98,0x751C5C74,0x1C2B};
                    l_333 = 0x96C32E4B;
                    if (l_334)
                    { /* block id: 199 */
                        int32_t l_338 = 0xAACD87D6;
                        int16_t l_341 = 0xF5FF;
                        l_240 = (!((uint16_t)l_338 % (uint16_t)(l_346 = ((int16_t)((((l_330 , l_341) | (l_333 &= l_330)) == ((l_256.f1 = __builtin_popcountll(((uint16_t)0U * (uint16_t)(l_222.f2 &= ((l_256.f2 && l_330) | ((l_240 & (((uint16_t)l_248.f0 >> (uint16_t)11) | 0x7EE41A93)) , l_330)))))) && l_330)) < 1) >> (int16_t)l_330))));
                    }
                    else
                    { /* block id: 205 */
                        struct S0 l_349 = {0x793B,0xB70A786B,0x301D};
                        l_301.f3 = __builtin_ctz(((l_222.f0 = (((int16_t)l_330 >> (int16_t)13) || (func_99(l_349) & ((uint16_t)(((int16_t)l_334 << (int16_t)((l_329.f0 == l_334) > l_301.f4)) != l_334) << (uint16_t)((uint16_t)func_60(l_256.f0, l_198) * (uint16_t)l_334))))) >= l_301.f6));
                        l_248 = func_88((l_356 , (-9)), l_346, (func_88(l_301.f5, l_334, l_357, func_88((l_365 = ((l_349.f2 < ((!((((int16_t)((uint16_t)(l_346 , (((!l_330) < l_364) & l_301.f7)) << (uint16_t)12) << (int16_t)8) == (-3)) <= 0xF470)) | l_364)) >= (-2))), l_248.f1, l_349.f0, l_248)) , l_334), l_366);
                        l_346 = l_366.f1;
                    }
                    l_367 = func_70(l_365);
                    l_367.f2 = l_238;
                }
            }
            else
            { /* block id: 215 */
                uint16_t l_368 = 1U;
                l_368 ^= __builtin_ffsl(l_333);
            }
            if (l_328)
                break;
        }
        l_53.f1 = ((((uint16_t)0x534B >> (uint16_t)((((uint16_t)(((l_222 , (l_256.f2 && (func_124((l_222.f1 ^ l_304)) ^ l_222.f3))) != (l_373 , (l_374 = (((((((l_256.f1 = l_36) , l_301) , l_279) == l_222.f4) >= l_238) ^ l_53.f2) >= l_301.f3)))) != l_356) << (uint16_t)15) == l_248.f0) == 0x61B5C3F1)) > l_373.f4) > 65535U);
        l_248 = l_256;
        l_375 = l_222;
    }
    l_53.f1 ^= ((int16_t)((uint16_t)(l_198 = (l_375.f2 > (l_222.f5 <= l_375.f1))) >> (uint16_t)11) % (int16_t)65535U);
    l_303 |= ((uint16_t)((int16_t)(l_375.f3 = func_118((l_375.f5 = l_36), ((0x8A46 >= (0xFE8A64E1 != (3U != (l_375.f7 &= (0 >= l_222.f2))))) < (((((l_53.f1 , (l_375.f2 <= l_198)) ^ 3) || l_375.f3) >= 0x6B52) == 0x251B02FE)), l_222.f2, l_256.f1, l_375.f4)) << (int16_t)l_53.f0) << (uint16_t)l_256.f2);
    return l_222.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_31(uint16_t  p_32, struct S0  p_33, uint16_t  p_34, struct S1  p_35)
{ /* block id: 114 */
    int16_t l_225 = (-1);
    int8_t l_226 = (-5);
    int32_t l_231 = 0;
    uint32_t l_232 = 5U;
    int32_t l_235 = 0x791142BF;
    l_235 = ((((uint16_t)0x9CB1 + (uint16_t)(l_225 || (l_226 ^= p_33.f2))) , ((p_35.f7 == ((p_35.f3 == ((((int16_t)(l_232 = ((l_231 = 0x24BD3771) <= p_35.f3)) >> (int16_t)11) , ((int16_t)p_35.f5 + (int16_t)0x44C7)) > p_33.f0)) < 0x00AF)) | 0x2080C0C3)) == l_225);
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_37(uint32_t  p_38, int8_t  p_39)
{ /* block id: 106 */
    uint32_t l_202 = 0x84F02785;
    int32_t l_215 = (-1);
    int32_t l_216 = (-1);
    int32_t l_217 = (-4);
    int32_t l_218 = 0x6F9448B1;
    int32_t l_219 = 0x2693F941;
    int32_t l_220 = 1;
    struct S0 l_221 = {65535U,0x58FFC12B,0x3EB4};
    l_220 ^= (((((uint16_t)(l_219 = ((l_202 >= ((((l_202 < (((uint16_t)((((uint16_t)((uint16_t)p_39 << (uint16_t)(((int16_t)(((uint32_t)((int16_t)(l_215 = (p_38 & p_38)) << (int16_t)(l_216 = 0xC212)) + (uint32_t)l_202) != (l_218 |= (0x17F3 & (((l_217 ^= ((p_38 , p_38) & 0x43BE)) <= p_38) ^ 1)))) >> (int16_t)l_202) > 0x68770074)) * (uint16_t)0) , l_216) | p_38) << (uint16_t)p_39) > 0x5638069D)) && l_217) && l_215) , p_38)) | l_202)) % (uint16_t)l_202) && p_38) | p_38) > 0xF005D3D9);
    return l_221;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_50(struct S0  p_51, uint32_t  p_52)
{ /* block id: 37 */
    uint32_t l_65 = 4294967292U;
    int32_t l_74 = 0xC34309E9;
    struct S0 l_101 = {0x9F80,0x5C327FA8,0xB22E};
    struct S1 l_192 = {12,1,2,-369,-8,-0,0,1840};
    int32_t l_195 = (-1);
    for (p_51.f1 = 0; (p_51.f1 != (-30)); p_51.f1 -= 1)
    { /* block id: 40 */
        int32_t l_79 = 0;
        int32_t l_80 = (-1);
        int32_t l_87 = 1;
        int32_t l_164 = 0x2C1C9F68;
        struct S0 l_191 = {1U,1,65535U};
        l_87 &= ((int16_t)((4294967293U ^ __builtin_parityl(((int16_t)(((p_51.f2 = (func_60(p_51.f2, p_51.f2) , ((uint16_t)l_65 << (uint16_t)1))) | ((int16_t)l_65 * (int16_t)((uint16_t)((func_70(((int16_t)(l_80 = (l_79 = ((l_74 = (p_51.f1 <= p_51.f1)) || ((int16_t)(((int32_t)l_79 - (int32_t)l_79) >= 1) % (int16_t)0x0955)))) + (int16_t)l_65)) , 0x3E9F) <= p_51.f0) * (uint16_t)l_65))) && p_51.f0) * (int16_t)l_65))) ^ l_65) - (int16_t)5);
        l_191 = func_88(p_51.f0, (l_74 | (((l_87 |= (l_65 && (l_80 = (l_79 = ((uint16_t)65526U * (uint16_t)(l_80 || (((uint16_t)(p_51.f1 & ((int32_t)__builtin_clz((func_99(l_101) >= (l_101.f0 > p_52))) + (int32_t)4294967295U)) % (uint16_t)p_52) <= 6U))))))) , 7U) ^ l_65)), l_164, p_51);
    }
    l_192 = l_192;
    p_51.f1 = (l_195 = ((uint16_t)(p_51.f1 != p_51.f0) + (uint16_t)(l_192.f4 && l_192.f7)));
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_60(int32_t  p_61, int32_t  p_62)
{ /* block id: 41 */
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_70(int32_t  p_71)
{ /* block id: 47 */
    int32_t l_85 = 0;
    struct S1 l_86 = {-75,5,-7,-371,-5,0,51,5699};
    l_85 |= ((int16_t)p_71 >> (int16_t)((int16_t)0x8C99 * (int16_t)0xB93D));
    return l_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_88(int32_t  p_89, uint32_t  p_90, int8_t  p_91, struct S0  p_92)
{ /* block id: 88 */
    int8_t l_165 = 0xFC;
    int32_t l_175 = 0xAEEB6654;
    int32_t l_176 = 0xE3EA3A5B;
    int32_t l_177 = 0xF814AE1D;
    struct S0 l_178 = {65535U,0x17623E6E,0U};
    uint16_t l_190 = 0U;
    p_92.f1 = func_99(((((((0 || l_165) || (p_92.f1 == __builtin_parityll(((((uint16_t)(0xFF93 <= ((l_165 < (((uint16_t)(~(((uint16_t)(p_92.f2 = ((0x4120 == ((p_92.f2 < l_165) != ((((int16_t)(l_176 |= ((l_175 &= p_92.f2) | 0x4F27)) >> (int16_t)15) , 0xC8BB) <= l_165))) , 9U)) * (uint16_t)0U) == l_165)) >> (uint16_t)l_165) | 0x358C7ECC)) ^ p_92.f1)) % (uint16_t)p_89) && 5) >= p_91)))) | l_165) | p_91) & l_177) , l_178));
    l_178 = l_178;
    l_175 = ((((uint16_t)(p_92 , ((-7) > ((uint32_t)func_99(p_92) + (uint32_t)((int16_t)l_177 - (int16_t)4U)))) >> (uint16_t)12) & (l_176 = ((int16_t)((((!(((int16_t)(p_92.f1 > ((p_89 = (l_190 != l_178.f0)) == p_92.f1)) >> (int16_t)2) == 0xD747)) , l_178.f1) && l_175) , l_190) * (int16_t)l_178.f0))) < l_165);
    return p_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_99(struct S0  p_100)
{ /* block id: 51 */
    int32_t l_104 = (-3);
    int32_t l_162 = 0x170A64D1;
    int32_t l_163 = 4;
    for (p_100.f2 = 12; (p_100.f2 >= 36); p_100.f2 += 4)
    { /* block id: 54 */
        p_100.f1 ^= l_104;
    }
    l_104 = (p_100.f1 = (-(uint32_t)(((uint16_t)((((int32_t)l_104 - (int32_t)0U) > ((int16_t)(l_163 &= ((__builtin_popcountll((l_162 = ((p_100.f1 & (((((uint16_t)((int16_t)p_100.f0 - (int16_t)l_104) >> (uint16_t)6) < (1U <= (((int16_t)func_118((func_124(p_100.f2) , p_100.f0), p_100.f0, p_100.f1, l_104, p_100.f1) - (int16_t)p_100.f0) >= 0x6046493B))) == (-5)) == l_104)) == p_100.f2))) ^ 4294967295U) , (-7))) * (int16_t)l_104)) >= 1) << (uint16_t)10) == p_100.f0)));
    return p_100.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_118(uint16_t  p_119, uint16_t  p_120, uint16_t  p_121, uint32_t  p_122, int8_t  p_123)
{ /* block id: 63 */
    int32_t l_148 = 2;
    uint32_t l_153 = 4294967295U;
    int32_t l_154 = 0x9D357D0D;
    int16_t l_155 = 1;
    struct S1 l_161 = {42,2,-51,-182,1,0,1,395};
    if ((l_154 ^= (l_153 |= ((uint32_t)p_119 % (uint32_t)((uint16_t)((p_121 = p_121) , l_148) - (uint16_t)(((uint16_t)p_123 % (uint16_t)((int32_t)(((p_123 >= ((l_148 < l_148) >= p_119)) , 0U) , 0x8FD8E19E) + (int32_t)0xD9114629)) >= l_148))))))
    { /* block id: 67 */
        int32_t l_156 = 0xD18C2020;
        struct S1 l_157 = {243,4,-46,31,5,0,62,-3096};
        int32_t l_159 = 0x93BB8539;
        l_154 = ((l_155 , l_156) & (l_159 = (p_120 == ((l_157 = func_70(l_155)) , (-(int32_t)(l_148 = p_122))))));
    }
    else
    { /* block id: 72 */
        struct S1 l_160 = {148,9,13,-91,1,0,37,-1992};
        l_161 = (l_160 = func_70(p_122));
    }
    l_154 = (l_161.f4 ^ (l_161.f7 &= (l_161.f2 = 0x5A9B4FB0)));
    return l_161.f7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_124(int32_t  p_125)
{ /* block id: 57 */
    int32_t l_126 = 0xB3D6DB51;
    uint16_t l_138 = 0xE98D;
    int8_t l_139 = 6;
    int32_t l_142 = 1;
    int32_t l_143 = (-8);
    l_126 = (((l_126 < ((int32_t)__builtin_popcountl((l_143 = (l_126 && ((uint16_t)(~l_126) * (uint16_t)((((((p_125 && (l_142 ^= ((uint16_t)((uint16_t)p_125 + (uint16_t)__builtin_ctzl((((int16_t)(l_139 ^= (0xA549A7EF < l_138)) - (int16_t)((int16_t)l_138 + (int16_t)(l_138 || l_126))) || p_125))) % (uint16_t)0x6589))) && l_126) >= l_138) <= l_126) , 4U) <= 0x5353))))) - (int32_t)0xC05F70B0)) || p_125) || l_143);
    return p_125;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 84
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX full-bitfields structs in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 9
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 18
XXX times a single bitfield on RHS: 41

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 14
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 2

XXX total number of pointers: 0

XXX times a non-volatile is read: 347
XXX times a non-volatile is write: 124
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 78
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 9
   depth: 2, occurrence: 6
   depth: 3, occurrence: 9
   depth: 4, occurrence: 16
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 24.6
XXX percentage an existing variable is used: 75.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

