/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2944002775
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 10;
   const unsigned f1 : 25;
   const signed f2 : 24;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
static const float  func_13(uint8_t  p_14, int64_t  p_15, struct S0  p_16);
static uint8_t  func_17(struct S0 * const  p_18, int32_t  p_19, struct S0 ** p_20, struct S0 * p_21, struct S0 * const * p_22);
inline static struct S0 * func_23(struct S0 ** p_24, struct S0 ** p_25, const uint64_t  p_26);
static struct S0 ** func_27(int16_t  p_28, uint16_t  p_29, const struct S0 * p_30, const struct S0  p_31);
inline static int16_t  func_32(uint32_t  p_33, struct S0 ** p_34);
static int32_t  func_35(uint8_t  p_36, int32_t  p_37, struct S0 * p_38, struct S0 * p_39, int64_t  p_40);
inline static int8_t  func_41(uint8_t  p_42, const struct S0 ** p_43, struct S0 * p_44, int8_t  p_45);
static int16_t  func_53(struct S0 * p_54, struct S0 * const * p_55);
inline static struct S0 * func_56(struct S0 ** p_57, uint16_t  p_58);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x4A18885CL;
    struct S0 l_6 = {13,232,-3645};
    const struct S0 *l_5 = &l_6;
    struct S0 *l_47 = &l_6;
    struct S0 **l_46 = &l_47;
    int8_t l_1033 = 0xD2L;
    for (l_2 = 0; (l_2 <= 25); l_2++)
    { /* block id: 3 */
        struct S0 *l_8 = &l_6;
        struct S0 **l_7 = &l_8;
        (*l_7) = l_5;
    }
    l_6.f0 = (((((safe_sub_func_float_f_f((safe_sub_func_float_f_f((&l_5 == (void*)0), func_13(func_17(func_23(func_27(func_32(((l_6.f2 == func_35(l_6.f0, ((func_41(((void*)0 == &l_6), &l_5, &l_6, ((l_46 != &l_5) == 0xDE0D6158L)) > l_6.f1) <= 1L), (*l_46), (*l_46), l_6.f0)) > 8L), &l_47), l_6.f2, (*l_46), (*l_47)), &l_47, l_2), l_6.f2, &l_47, (*l_46), &l_47), l_2, l_6))), l_2)) == l_2) <= 0x0.6p-1) <= l_1033) != l_6.f1);
    /* statement id: 620 */
    assert (l_47 == 0 || l_47 == &l_6);
    return l_1033;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_13(uint8_t  p_14, int64_t  p_15, struct S0  p_16)
{ /* block id: 513 */
    int32_t l_841 = 0x1CB87502L;
    int32_t * const l_840[8] = {&l_841,&l_841,&l_841,&l_841,&l_841,&l_841,&l_841,&l_841};
    int32_t **l_842 = (void*)0;
    int32_t *l_844 = &l_841;
    int32_t **l_843 = &l_844;
    int32_t l_849 = 0x50757340L;
    int32_t **l_856 = (void*)0;
    int32_t ***l_864 = (void*)0;
    int32_t ****l_863 = &l_864;
    int32_t *****l_862 = &l_863;
    int32_t ** const l_888 = &l_844;
    struct S0 l_896 = {12,871,366};
    struct S0 *l_895 = &l_896;
    const int16_t l_983[5][4] = {{0x332CL,0x332CL,0x332CL,0x332CL},{0x332CL,0x332CL,0x332CL,0x332CL},{0x332CL,0x332CL,0x332CL,0x332CL},{0x332CL,0x332CL,0x332CL,0x332CL},{0x332CL,0x332CL,0x332CL,0x332CL}};
    float l_998[3][8][1] = {{{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)}},{{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)}},{{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)},{0x6.E2A436p+35},{(-0x1.Ap-1)}}};
    float *l_997 = &l_998[1][5][0];
    int8_t l_1031 = 0x38L;
    const uint16_t l_1032[9][2] = {{0UL,0x3882L},{65535UL,0UL},{0x3882L,65533UL},{0x3882L,0UL},{65535UL,0x3882L},{0UL,65533UL},{0x4CDAL,0x4CDAL},{65535UL,0x4CDAL},{0x4CDAL,65533UL}};
    int i, j, k;
lbl_929:
    (*l_843) = l_840[4];
    /* statement id: 514 */
    assert (l_844 == &l_841);
    if (((safe_add_func_int32_t_s_s((0x9CL >= (safe_rshift_func_int8_t_s_s(p_15, (0L | l_849)))), (safe_sub_func_uint16_t_u_u((safe_add_func_int8_t_s_s((safe_div_func_uint64_t_u_u((l_856 != (void*)0), (safe_add_func_uint64_t_u_u(p_16.f1, p_14)))), (safe_rshift_func_int8_t_s_s((((p_15 | p_14) == 0xEBADL) != p_16.f2), 0)))), (**l_843))))) == 0x5DFBL))
    { /* block id: 515 */
        int32_t *l_861[8];
        struct S0 **l_945 = &l_895;
        struct S0 ***l_944 = &l_945;
        int i;
        for (i = 0; i < 8; i++)
            l_861[i] = &l_849;
lbl_886:
        (*l_843) = l_861[2];
        /* statement id: 516 */
        assert (l_844 == &l_841 || l_844 == &l_849);
        for (l_849 = 0; (l_849 <= 7); l_849 += 1)
        { /* block id: 519 */
            uint32_t l_884 = 0x0BD5FA54L;
            int32_t *l_885[7] = {(void*)0,(void*)0,&l_849,(void*)0,(void*)0,&l_849,(void*)0};
            struct S0 * const *l_956 = &l_895;
            struct S0 * const **l_955 = &l_956;
            int i;
            if (((void*)0 != l_862))
            { /* block id: 520 */
                struct S0 l_868 = {16,3698,-2547};
                struct S0 *l_867[10][9][2] = {{{&l_868,(void*)0},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,(void*)0}},{{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868}},{{(void*)0,(void*)0},{&l_868,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868}},{{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868},{&l_868,(void*)0},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868}},{{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868}},{{(void*)0,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,(void*)0}},{{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,(void*)0},{&l_868,&l_868},{(void*)0,&l_868},{&l_868,&l_868}},{{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868}},{{&l_868,(void*)0},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,(void*)0},{&l_868,&l_868},{&l_868,&l_868}},{{&l_868,&l_868},{(void*)0,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868},{&l_868,&l_868}}};
                int32_t *l_887 = &l_841;
                int i, j, k;
                for (p_15 = 7; (p_15 >= 2); p_15 -= 1)
                { /* block id: 523 */
                    int8_t l_869 = 0xDAL;
                    int i;
                    if ((safe_sub_func_uint8_t_u_u(((l_867[9][4][0] == (void*)0) ^ l_869), (safe_add_func_uint32_t_u_u(((-5L) && ((((safe_mod_func_int16_t_s_s((safe_div_func_uint32_t_u_u(((((safe_add_func_uint64_t_u_u((((safe_sub_func_int32_t_s_s((safe_sub_func_int32_t_s_s(p_16.f0, p_16.f2)), (safe_sub_func_uint8_t_u_u(l_868.f0, p_16.f0)))) < l_868.f0) != 0xEBL), 2UL)) == p_16.f0) & 0x9CL) & 4294967295UL), l_869)), 0xB90BL)) ^ p_16.f1) || 0xAEL) >= (-3L))), l_884)))))
                    { /* block id: 524 */
                        (*l_843) = l_885[0];
                        /* statement id: 525 */
                        assert (l_844 == 0 || l_844 == &l_849);
                    }
                    else
                    { /* block id: 526 */
                        if (l_868.f0)
                            goto lbl_886;
                    }
                    for (l_841 = 1; (l_841 >= 0); l_841 -= 1)
                    { /* block id: 531 */
                        int i;
                        l_861[l_849] = l_887;
                    }
                    if (p_14)
                        continue;
                    (*l_887) = (l_888 != (void*)0);
                }
                /* facts after for loop */
                assert (l_844 == 0 || l_844 == &l_849 || l_844 == &l_841);
            }
            else
            { /* block id: 537 */
                uint8_t l_899 = 0x6EL;
                int32_t l_918 = 1L;
                const struct S0 *l_954 = &l_896;
                const struct S0 **l_953[4];
                const struct S0 ***l_952 = &l_953[1];
                float l_972 = 0x9.C6F49Dp+9;
                float *l_971 = &l_972;
                int i;
                for (i = 0; i < 4; i++)
                    l_953[i] = &l_954;
                for (p_14 = (-7); (p_14 == 21); p_14++)
                { /* block id: 540 */
                    const uint32_t l_894 = 1UL;
                    if ((safe_add_func_uint16_t_u_u(0xAA0CL, 0xF1D4L)))
                    { /* block id: 541 */
                        uint64_t l_893[5][1];
                        int i, j;
                        for (i = 0; i < 5; i++)
                        {
                            for (j = 0; j < 1; j++)
                                l_893[i][j] = 18446744073709551610UL;
                        }
                        if (p_16.f0)
                            break;
                        p_16.f0 = l_893[3][0];
                        return l_894;
                    }
                    else
                    { /* block id: 545 */
                        if (l_884)
                            goto lbl_886;
                    }
                    l_918 = ((l_895 == (void*)0) <= (safe_add_func_float_f_f(((l_899 < (-0x3.5p-1)) != (-(!((safe_add_func_float_f_f((safe_sub_func_float_f_f((p_16.f0 == ((((+(safe_sub_func_float_f_f(p_14, (safe_add_func_float_f_f(0x4.16BA7Ep-71, (safe_div_func_float_f_f((safe_add_func_float_f_f((safe_sub_func_float_f_f(((-0x2.Fp+1) != ((+(p_16.f0 >= 0x0.Ep+1)) >= 0xD.11B6CCp-33)), p_16.f2)), l_894)), l_899))))))) > l_894) <= p_16.f2) != p_16.f1)), 0x5.AD6C90p+51)), 0x5.7BB4E0p+55)) == p_14)))), 0xC.5E029Ep-39)));
                    if (p_16.f1)
                        continue;
                }
                for (l_899 = 0; (l_899 < 11); ++l_899)
                { /* block id: 553 */
                    uint16_t l_934[6][4] = {{0UL,0UL,0UL,0UL},{65534UL,0UL,0x8DBBL,0UL},{0UL,0x0B2DL,0x8DBBL,0x8DBBL},{65534UL,65534UL,0UL,0x8DBBL},{0UL,0x0B2DL,0UL,0UL},{0UL,0UL,0UL,0UL}};
                    int i, j;
                    for (p_15 = (-12); (p_15 < 7); p_15++)
                    { /* block id: 556 */
                        float l_923 = 0x1.8p+1;
                        int32_t l_924 = 0xAD6E88C5L;
                        float *l_925 = (void*)0;
                        float *l_926 = &l_923;
                        l_918 = l_924;
                        (*l_926) = 0xC.D31E24p-67;
                    }
                    for (p_15 = 22; (p_15 < 25); p_15 = safe_add_func_int64_t_s_s(p_15, 3))
                    { /* block id: 562 */
                        struct S0 * const *l_936 = &l_895;
                        struct S0 * const **l_935 = &l_936;
                        float l_938 = 0x1.2C1799p-12;
                        float *l_937[7] = {&l_938,&l_938,&l_938,&l_938,&l_938,&l_938,&l_938};
                        int32_t l_943 = 5L;
                        int i;
                        if (l_849)
                            goto lbl_929;
                        l_918 = (safe_add_func_float_f_f(((0xE.50CDA3p-21 <= (-0x1.7p-1)) == p_16.f2), (safe_sub_func_float_f_f(((&l_896 != (void*)0) < l_934[5][3]), ((-0x10.Dp+1) < ((l_935 == &l_936) != 0x5.669808p+68))))));
                        p_16.f0 = (!(((0x49E6B8DE175FC7BELL < (safe_lshift_func_uint8_t_u_s((p_16.f1 | ((~p_16.f1) == l_899)), (l_844 != (void*)0)))) >= ((-8L) <= l_943)) & (((void*)0 != l_944) <= p_14)));
                        if (p_16.f1)
                            continue;
                    }
                    p_16.f0 = (((safe_mod_func_int8_t_s_s((**l_843), p_16.f0)) > (safe_rshift_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u((l_952 != l_955), 12)) <= (((safe_div_func_uint64_t_u_u((safe_add_func_uint32_t_u_u((+(safe_rshift_func_uint8_t_u_s(1UL, (safe_unary_minus_func_int8_t_s((safe_mod_func_int64_t_s_s((-10L), 4L))))))), ((safe_div_func_int32_t_s_s(p_16.f0, (safe_mod_func_int64_t_s_s((l_899 != (*l_844)), p_16.f1)))) > l_934[5][3]))), p_16.f2)) == 0xCF92B94C6EABC549LL) || 0x85E38FEFL)), 5))) && 0L);
                }
                (*l_971) = 0x8.29805Ap+49;
            }
            /* facts after branching */
            assert (l_844 == 0 || l_844 == &l_849 || l_844 == &l_841);
            (*l_843) = l_861[2];
            /* statement id: 572 */
            assert (l_844 == &l_841 || l_844 == &l_849);
            for (p_15 = 23; (p_15 != (-13)); --p_15)
            { /* block id: 575 */
                int16_t l_990 = 0x2C24L;
                int64_t l_996 = (-1L);
                p_16.f0 = (p_16.f1 <= ((safe_div_func_uint16_t_u_u(p_16.f2, (safe_sub_func_int16_t_s_s(0x9373L, (p_16.f1 <= ((0UL <= (safe_div_func_uint64_t_u_u(((safe_sub_func_uint32_t_u_u(l_983[4][1], (((safe_sub_func_uint64_t_u_u((safe_lshift_func_int16_t_s_u((safe_sub_func_int8_t_s_s((l_990 <= (!(p_15 ^ ((((((safe_mod_func_int16_t_s_s((65535UL < p_15), p_16.f2)) > p_16.f2) != p_16.f2) <= l_996) ^ 0x2E38L) != p_16.f1)))), p_15)), p_15)), l_996)) & 0x0C41C2154FBB949ELL) >= p_16.f1))) >= l_996), 0xFB902FAC48821260LL))) < p_16.f2)))))) == p_15));
            }
            (*l_945) = func_56(&l_895, p_16.f1);
        }
    }
    else
    { /* block id: 580 */
        return p_16.f1;
    }
    /* facts after branching */
    assert (l_844 == &l_841 || l_844 == &l_849);
    (*l_997) = p_15;
    for (l_849 = 0; (l_849 <= 0); l_849 += 1)
    { /* block id: 586 */
        int32_t ****l_999 = &l_864;
        int16_t l_1009 = 0xB92FL;
        const struct S0 *l_1012 = &l_896;
        struct S0 **l_1021 = (void*)0;
        struct S0 ***l_1020[5][1] = {{&l_1021},{&l_1021},{&l_1021},{&l_1021},{&l_1021}};
        int i, j;
        if (p_16.f0)
        { /* block id: 587 */
            const int8_t l_1002 = 0x54L;
            struct S0 **l_1013 = &l_895;
            (*l_862) = l_999;
            (*l_1013) = func_23(func_27((safe_sub_func_int64_t_s_s((l_1002 == (((~18446744073709551615UL) ^ (0x9FL == 1L)) && (((p_16.f2 > (safe_lshift_func_int16_t_s_s((!0x2BF49C96EEF14273LL), l_1002))) < (l_1009 > (safe_mod_func_uint16_t_u_u((l_1009 < p_14), 65527UL)))) && p_16.f2))), p_15)), p_15, l_1012, p_16), l_1013, p_16.f0);
        }
        else
        { /* block id: 590 */
            int32_t l_1018 = 0x62A730B8L;
            int32_t *l_1017 = &l_1018;
            for (l_841 = 0; (l_841 >= 0); l_841 -= 1)
            { /* block id: 593 */
                int16_t l_1028 = (-5L);
                for (p_15 = 0; (p_15 >= 0); p_15 -= 1)
                { /* block id: 596 */
                    int32_t l_1019[7][8] = {{0xF8C7052BL,(-9L),0xDF07A381L,0x0F05DE70L,0xF865FBB0L,0x9F708D66L,0xF865FBB0L,0x0F05DE70L},{8L,0L,8L,(-1L),0x0F05DE70L,0x9F708D66L,0xDF07A381L,0xDF07A381L},{0xDF07A381L,(-9L),0xF8C7052BL,0xF8C7052BL,(-9L),0xDF07A381L,0x0F05DE70L,0xF865FBB0L},{0xDF07A381L,0x1809F494L,0L,(-9L),0x0F05DE70L,(-9L),0L,0x1809F494L},{8L,0L,0x9F708D66L,(-9L),0xF865FBB0L,(-1L),(-1L),0xF865FBB0L},{0xF8C7052BL,0xF865FBB0L,0xF865FBB0L,0xF8C7052BL,8L,0x1809F494L,(-1L),0xDF07A381L},{0L,0xF8C7052BL,0x9F708D66L,(-1L),0x9F708D66L,0xF8C7052BL,0L,0x0F05DE70L}};
                    int32_t *****l_1027 = &l_863;
                    int i, j, k;
                    l_998[l_841][(l_841 + 7)][p_15] = 0xC.3531FBp-76;
                    for (l_1009 = 0; (l_1009 == 18); ++l_1009)
                    { /* block id: 600 */
                        int32_t *l_1016 = &l_841;
                        l_1017 = l_1016;
                        /* statement id: 601 */
                        assert (l_1017 == &l_841);
                    }
                    if (l_1019[5][4])
                        continue;
                    if ((((((void*)0 == l_1020[0][0]) >= (!((safe_add_func_uint16_t_u_u(p_14, ((void*)0 != &p_16))) >= (safe_rshift_func_int16_t_s_s((&l_863 != l_1027), (l_1028 | p_14)))))) >= (*l_1017)) || p_16.f1))
                    { /* block id: 604 */
                        if (l_1009)
                            goto lbl_929;
                        (*l_997) = (safe_add_func_float_f_f(p_14, l_1031));
                        (*l_843) = (void*)0;
                        /* statement id: 607 */
                        assert (l_844 == 0);
                        if (p_16.f1)
                            continue;
                    }
                    else
                    { /* block id: 609 */
                        return p_16.f2;
                    }
                    /* facts after branching */
                    assert (l_844 == 0);
                }
                if (l_1028)
                    break;
            }
            /* facts after for loop */
            //assert (l_844 == 0 || l_844 == &l_841 || l_844 == &l_849 || l_844 == dangling);
            assert (l_1017 == &l_841 || l_1017 == &l_1018);
            if (p_15)
                break;
            (*l_843) = &l_1018;
            /* statement id: 616 */
            assert (l_844 == &l_1018);
        }
    }
    /* facts after for loop */
    //assert (l_844 == 0 || l_844 == &l_841 || l_844 == &l_849 || l_844 == dangling);
    return l_1032[6][0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_17(struct S0 * const  p_18, int32_t  p_19, struct S0 ** p_20, struct S0 * p_21, struct S0 * const * p_22)
{ /* block id: 403 */
    uint64_t l_662[1][8][6] = {{{0x27B0D8139886D652LL,0x27B0D8139886D652LL,18446744073709551612UL,0x72359BBDDC900614LL,18446744073709551612UL,0x27B0D8139886D652LL},{18446744073709551612UL,0x2656BD8D2A5D6B3DLL,0x72359BBDDC900614LL,0x72359BBDDC900614LL,0x2656BD8D2A5D6B3DLL,18446744073709551612UL},{0x27B0D8139886D652LL,18446744073709551612UL,0x72359BBDDC900614LL,18446744073709551612UL,0x27B0D8139886D652LL,0x27B0D8139886D652LL},{3UL,18446744073709551612UL,18446744073709551612UL,3UL,0x2656BD8D2A5D6B3DLL,3UL},{3UL,0x2656BD8D2A5D6B3DLL,3UL,18446744073709551612UL,18446744073709551612UL,3UL},{0x27B0D8139886D652LL,0x27B0D8139886D652LL,18446744073709551612UL,0x72359BBDDC900614LL,18446744073709551612UL,0x27B0D8139886D652LL},{18446744073709551612UL,0x2656BD8D2A5D6B3DLL,0x72359BBDDC900614LL,0x72359BBDDC900614LL,0x2656BD8D2A5D6B3DLL,18446744073709551612UL},{0x27B0D8139886D652LL,18446744073709551612UL,0x72359BBDDC900614LL,18446744073709551612UL,0x27B0D8139886D652LL,0x27B0D8139886D652LL}}};
    int32_t l_703 = 0xBBBFFE47L;
    int32_t *l_702 = &l_703;
    const int32_t *l_710[6] = {&l_703,&l_703,&l_703,&l_703,&l_703,&l_703};
    const int32_t * const *l_709 = &l_710[5];
    const int32_t * const **l_708[10][10] = {{(void*)0,(void*)0,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709},{&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,(void*)0,&l_709,&l_709},{&l_709,(void*)0,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709},{&l_709,&l_709,&l_709,(void*)0,&l_709,&l_709,(void*)0,&l_709,&l_709,&l_709},{&l_709,&l_709,&l_709,&l_709,(void*)0,&l_709,&l_709,&l_709,(void*)0,&l_709},{&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709},{&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,(void*)0,&l_709},{&l_709,&l_709,&l_709,(void*)0,&l_709,&l_709,&l_709,&l_709,(void*)0,&l_709},{&l_709,&l_709,(void*)0,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709},{&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,&l_709,(void*)0,(void*)0}};
    const int32_t * const ***l_707 = &l_708[5][3];
    const int32_t * const ****l_706 = &l_707;
    int32_t **l_813[4] = {&l_702,&l_702,&l_702,&l_702};
    int32_t ***l_812 = &l_813[1];
    int32_t ****l_811[5];
    float *l_838[9];
    float l_839 = (-0x10.9p-1);
    int i, j, k;
    for (i = 0; i < 5; i++)
        l_811[i] = &l_812;
    for (i = 0; i < 9; i++)
        l_838[i] = (void*)0;
lbl_837:
    for (p_19 = 0; (p_19 != 24); ++p_19)
    { /* block id: 406 */
        struct S0 *l_661 = (void*)0;
        int32_t l_663 = (-6L);
        int32_t *l_704 = (void*)0;
        (*p_20) = l_661;
        /* statement id: 407 */
        //assert (l_47 == 0);
        for (l_663 = 0; (l_663 >= 0); l_663 -= 1)
        { /* block id: 410 */
            int8_t l_683 = 0xE7L;
            const int32_t l_684 = 0xF242D1BBL;
            float l_686 = 0x6.9603BEp-5;
            float *l_685[10] = {&l_686,&l_686,&l_686,&l_686,&l_686,&l_686,&l_686,&l_686,&l_686,&l_686};
            int32_t l_687 = 0x1F67D85EL;
            const int32_t **l_701 = (void*)0;
            const int32_t *** const l_700[4] = {&l_701,&l_701,&l_701,&l_701};
            int i;
            l_687 = ((safe_add_func_float_f_f(0x3.651B41p+91, (l_662[0][6][2] < (safe_div_func_float_f_f((safe_div_func_float_f_f(((((((safe_sub_func_float_f_f(((safe_div_func_float_f_f(0x1.6p+1, p_19)) >= (+l_663)), (((safe_div_func_float_f_f(((p_19 > (+(safe_sub_func_float_f_f(((+((p_19 < ((safe_div_func_float_f_f(0x0.2p+1, 0xB.E27C89p+91)) >= 0x0.593B5Ep+88)) != p_19)) > l_683), (-0x2.3p+1))))) <= l_683), l_662[0][5][5])) == l_684) == l_662[0][3][2]))) != l_684) != l_684) == l_662[0][6][2]) > l_684) > p_19), p_19)), 0x0.6404F4p-33))))) != p_19);
            if (((safe_lshift_func_uint8_t_u_u(p_19, ((((safe_lshift_func_int8_t_s_s((((safe_div_func_uint32_t_u_u((((((safe_mod_func_uint32_t_u_u(p_19, l_662[0][0][2])) <= (p_19 != (l_684 && (safe_lshift_func_int8_t_s_s((((0x1C57L & ((l_700[0] == (void*)0) | (0xD405L < l_663))) && p_19) & p_19), p_19))))) ^ 0x84BAL) != p_19) < l_663), 5UL)) > p_19) == 1UL), 6)) | p_19) < l_663) > l_662[0][7][1]))) > 0x42BCL))
            { /* block id: 412 */
                l_702 = &p_19;
                /* statement id: 413 */
                assert (l_702 == &p_19);
                l_704 = &p_19;
                /* statement id: 414 */
                assert (l_704 == &p_19);
            }
            else
            { /* block id: 415 */
                int64_t l_705 = (-7L);
                return l_705;
            }
            /* facts after branching */
            assert (l_702 == &p_19);
            assert (l_704 == &p_19);
            for (l_683 = 0; (l_683 >= 0); l_683 -= 1)
            { /* block id: 420 */
                int i, j, k;
                return l_662[l_663][(l_663 + 6)][(l_663 + 1)];
            }
        }
        /* facts after for loop */
        assert (l_704 == &p_19 || l_704 == 0);
        l_702 = &l_703;
        /* statement id: 424 */
        assert (l_702 == &l_703);
    }
lbl_832:
    (*l_706) = (void*)0;
    /* statement id: 426 */
    assert (l_707 == 0);
    for (l_703 = 4; (l_703 >= 0); l_703 -= 1)
    { /* block id: 429 */
        int32_t **l_734 = &l_702;
        int32_t ***l_733 = &l_734;
        int32_t l_740 = 0xF3FC9C0BL;
        float l_777 = (-0x1.4p+1);
        struct S0 *l_783 = (void*)0;
        struct S0 * const *l_782[4][4][3] = {{{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783},{(void*)0,&l_783,&l_783}},{{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783},{&l_783,(void*)0,&l_783},{&l_783,&l_783,&l_783}},{{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783}},{{&l_783,&l_783,&l_783},{&l_783,&l_783,(void*)0},{&l_783,&l_783,&l_783},{&l_783,&l_783,&l_783}}};
        struct S0 **l_831 = &l_783;
        struct S0 ***l_830 = &l_831;
        struct S0 ****l_829 = &l_830;
        struct S0 *****l_828 = &l_829;
        int i, j, k;
        if (p_19)
        { /* block id: 430 */
            int32_t **l_711 = &l_702;
            float l_717 = 0x0.BB0B7Ap+10;
            float *l_716 = &l_717;
            (*l_711) = l_710[(l_703 + 1)];
            (*l_716) = (((safe_add_func_float_f_f(p_19, (safe_div_func_float_f_f(0xA.C4FE22p-62, p_19)))) == (0x1.8p+1 > (((&p_19 == l_710[(l_703 + 1)]) <= 0x4.9p-1) > p_19))) != p_19);
        }
        else
        { /* block id: 433 */
            uint8_t l_723 = 0x52L;
            int32_t ***l_753 = &l_734;
            const int32_t **l_778 = &l_710[(l_703 + 1)];
            uint64_t l_799 = 0x48E94F0E620C4767LL;
            const struct S0 l_805 = {-16,4404,1972};
            const struct S0 *l_804 = &l_805;
            const struct S0 **l_803[3][6][7] = {{{&l_804,&l_804,&l_804,&l_804,&l_804,&l_804,&l_804},{&l_804,&l_804,&l_804,&l_804,&l_804,&l_804,&l_804},{(void*)0,&l_804,(void*)0,&l_804,&l_804,(void*)0,&l_804},{&l_804,&l_804,&l_804,&l_804,&l_804,&l_804,&l_804},{(void*)0,&l_804,&l_804,(void*)0,&l_804,(void*)0,&l_804},{&l_804,&l_804,&l_804,&l_804,&l_804,&l_804,&l_804}},{{&l_804,&l_804,&l_804,&l_804,&l_804,&l_804,&l_804},{&l_804,&l_804,&l_804,(void*)0,(void*)0,&l_804,&l_804},{(void*)0,&l_804,&l_804,&l_804,&l_804,(void*)0,&l_804},{&l_804,(void*)0,(void*)0,&l_804,&l_804,&l_804,(void*)0},{&l_804,&l_804,(void*)0,&l_804,(void*)0,&l_804,&l_804},{&l_804,(void*)0,&l_804,(void*)0,&l_804,&l_804,(void*)0}},{{&l_804,&l_804,&l_804,(void*)0,(void*)0,&l_804,&l_804},{(void*)0,&l_804,&l_804,&l_804,&l_804,(void*)0,&l_804},{&l_804,(void*)0,(void*)0,&l_804,&l_804,&l_804,(void*)0},{&l_804,&l_804,(void*)0,&l_804,(void*)0,&l_804,&l_804},{&l_804,(void*)0,&l_804,(void*)0,&l_804,&l_804,(void*)0},{&l_804,&l_804,&l_804,(void*)0,(void*)0,&l_804,&l_804}}};
            const struct S0 ***l_802[6] = {&l_803[1][5][4],&l_803[1][5][4],&l_803[1][5][4],&l_803[1][5][4],&l_803[1][5][4],&l_803[1][5][4]};
            int i, j, k;
            for (p_19 = 3; (p_19 <= 9); p_19 += 1)
            { /* block id: 436 */
                float l_719 = 0x0.F5194Bp-57;
                float *l_718 = &l_719;
                int32_t l_720 = 0x3EEA8B85L;
                int32_t l_735 = 0x81FEEAEDL;
                int32_t * const l_736 = (void*)0;
                int32_t ***l_752 = &l_734;
                (*l_718) = 0x6.6p+1;
                for (l_720 = 9; (l_720 >= 0); l_720 -= 1)
                { /* block id: 440 */
                    int16_t l_745 = 1L;
                }
                (*l_718) = (safe_sub_func_float_f_f((((-0x9.2p-1) >= (-0x1.5p-1)) <= ((l_752 != l_753) > (safe_add_func_float_f_f((safe_add_func_float_f_f((safe_sub_func_float_f_f(0x4.Cp-1, 0x0.0p-1)), ((((0x5.5FD5D9p-86 == (p_19 <= ((safe_div_func_float_f_f((safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_add_func_float_f_f((!p_19), 0x6.596903p+94)), (***l_752))) <= 0x2.AFDE03p-28), p_19)), (-0x8.7p-1))) < p_19))) != 0x0.116E2Ep-44) >= p_19) > p_19))), p_19)))), 0x1.B7F5C0p-22));
            }
            if ((((safe_add_func_uint8_t_u_u(((***l_733) || (0x823147B8E4310D22LL < ((***l_753) >= ((0x2EL > ((0xCCL >= 253UL) > p_19)) > (safe_lshift_func_int16_t_s_u(((safe_div_func_int64_t_s_s((***l_753), 18446744073709551615UL)) & 0x980DL), 10)))))), p_19)) & 0L) < 0UL))
            { /* block id: 452 */
                struct S0 **l_784 = &l_783;
                int32_t l_787[6][1] = {{(-1L)},{0xE75832D1L},{(-1L)},{0xE75832D1L},{(-1L)},{0xE75832D1L}};
                int i, j;
                for (l_740 = 1; (l_740 <= 9); l_740 += 1)
                { /* block id: 455 */
                    for (l_723 = 0; (l_723 <= 9); l_723 += 1)
                    { /* block id: 458 */
                        return p_19;
                    }
                }
                for (l_723 = 0; (l_723 <= 9); l_723 += 1)
                { /* block id: 464 */
                    return p_19;
                }
                for (l_740 = 9; (l_740 >= 0); l_740 -= 1)
                { /* block id: 469 */
                    struct S0 * const l_781 = (void*)0;
                    struct S0 * const *l_780 = &l_781;
                    struct S0 * const **l_779[7] = {&l_780,&l_780,&l_780,&l_780,&l_780,&l_780,&l_780};
                    float *l_785 = (void*)0;
                    float *l_786[9] = {&l_777,&l_777,&l_777,&l_777,&l_777,&l_777,&l_777,&l_777,&l_777};
                    int i;
                    l_778 = &l_710[(l_703 + 1)];
                    l_782[3][3][1] = &p_18;
                    l_787[5][0] = (0x2.80CB69p-13 != (l_784 != (void*)0));
                }
                /* facts after for loop */
                //assert (l_782[0][0][0] == &p_18 || l_782[0][0][0] == 0 || l_782[0][0][0] == &l_783);
                return l_787[5][0];
            }
            else
            { /* block id: 475 */
                struct S0 * const *l_796 = &l_783;
                int32_t *l_800 = &l_740;
                struct S0 ****l_801 = (void*)0;
                float l_808[5];
                int32_t ****l_824[4];
                int i;
                for (i = 0; i < 5; i++)
                    l_808[i] = 0x9.317329p+42;
                for (i = 0; i < 4; i++)
                    l_824[i] = &l_812;
                for (l_723 = 1; (l_723 <= 9); l_723 += 1)
                { /* block id: 478 */
                    if ((**l_778))
                        break;
                    (*l_778) = (*l_734);
                }
                (*l_800) = (0x4C493BFAL ^ ((0xBF47A88BC5A0E90ALL && ((!(safe_div_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_s(((safe_unary_minus_func_uint64_t_u((!0x8632L))) ^ ((void*)0 == &p_22)), (safe_unary_minus_func_uint64_t_u((((((&p_21 == l_796) <= 0xCC2AF0CBC0B14902LL) != (safe_lshift_func_int8_t_s_u((**l_709), 6))) | (**l_734)) || 0xFAD9L))))), p_19))) >= (**l_734))) > l_799));
                l_802[1] = (void*)0;
                /* statement id: 483 */
                //assert (l_802[0] == 0 || (l_802[0] >= &l_803[0][0][0] && l_802[0] <= &l_803[2][5][6]));
                for (l_799 = 2; (l_799 <= 9); l_799 += 1)
                { /* block id: 486 */
                    int8_t l_825 = 1L;
                    if (p_19)
                        break;
                    if ((((safe_sub_func_uint16_t_u_u(p_19, p_19)) >= 0UL) & (**l_734)))
                    { /* block id: 488 */
                        int32_t ****l_810 = &l_753;
                        int32_t *****l_809[10][3] = {{&l_810,(void*)0,&l_810},{&l_810,(void*)0,&l_810},{(void*)0,&l_810,&l_810},{&l_810,&l_810,&l_810},{&l_810,&l_810,&l_810},{&l_810,&l_810,(void*)0},{&l_810,&l_810,&l_810},{(void*)0,&l_810,&l_810},{&l_810,&l_810,&l_810},{&l_810,&l_810,&l_810}};
                        int i, j;
                        l_811[2] = &l_753;
                    }
                    else
                    { /* block id: 490 */
                        float l_819 = 0x0.Cp-1;
                        float *l_826 = (void*)0;
                        float *l_827 = &l_808[1];
                        (*l_778) = &p_19;
                        (*l_827) = (0x7.A5869Cp-44 >= (+((((safe_add_func_float_f_f(((void*)0 == l_801), ((-0x1.6p+1) == (((((safe_div_func_float_f_f((l_819 >= 0x1.6p+1), (safe_add_func_float_f_f((0x2.5p-1 >= (safe_sub_func_float_f_f(0x4.4p-1, ((void*)0 == l_824[1])))), 0xD.04F310p+98)))) <= p_19) > p_19) > p_19) != l_825)))) == (***l_733)) > (-0x1.Bp-1)) == p_19)));
                        l_828 = l_828;
                    }
                    if (l_740)
                        goto lbl_832;
                    //assert (l_811[0] == &l_812 || l_811[0] == dangling);
                    (*l_800) = ((0xEB79B396L || ((((-1L) != p_19) < 0x462421A746E7527BLL) | ((safe_div_func_uint32_t_u_u(((4294967295UL > (((((l_825 < l_825) != (safe_sub_func_int32_t_s_s(((((***l_753) <= (**l_778)) != 4294967295UL) != 1L), l_825))) > l_825) >= p_19) && (**l_778))) && p_19), 0xA2731A63L)) || p_19))) & 0xCBC9L);
                }
                /* facts after for loop */
                //assert (l_811[0] == &l_753 || l_811[0] == &l_812 || l_811[0] == dangling);
            }
            /* facts after branching */
            //assert (l_811[0] == &l_753 || l_811[0] == &l_812 || l_811[0] == dangling);
            //assert (l_802[0] == 0 || (l_802[0] >= &l_803[0][0][0] && l_802[0] <= &l_803[2][5][6]));
        }
        for (p_19 = 9; (p_19 >= 3); p_19 -= 1)
        { /* block id: 502 */
            for (l_740 = 9; (l_740 >= 0); l_740 -= 1)
            { /* block id: 505 */
                if (p_19)
                    break;
                if (l_703)
                    goto lbl_837;
            }
        }
    }
    l_839 = p_19;
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_23(struct S0 ** p_24, struct S0 ** p_25, const uint64_t  p_26)
{ /* block id: 390 */
    int32_t l_650 = (-1L);
    int32_t *l_658[7][3] = {{&l_650,(void*)0,&l_650},{&l_650,&l_650,&l_650},{&l_650,(void*)0,&l_650},{&l_650,&l_650,&l_650},{&l_650,(void*)0,&l_650},{&l_650,&l_650,&l_650},{&l_650,(void*)0,&l_650}};
    int i, j;
    for (l_650 = 2; (l_650 != 28); l_650++)
    { /* block id: 393 */
        int32_t l_653 = 1L;
        for (l_653 = 0; (l_653 >= 2); l_653 = safe_add_func_uint8_t_u_u(l_653, 2))
        { /* block id: 396 */
            int32_t l_657 = 0x5017AC22L;
            int32_t *l_656 = &l_657;
            (*l_656) = l_650;
            return (*p_25);
            /* statement id: 398 */
            //assert (func_23_rv == &l_6 || func_23_rv == &l_896);
        }
    }
    l_658[0][2] = (void*)0;
    return (*p_25);
    /* statement id: 402 */
    //assert (func_23_rv == &l_6 || func_23_rv == &l_896);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 ** func_27(int16_t  p_28, uint16_t  p_29, const struct S0 * p_30, const struct S0  p_31)
{ /* block id: 388 */
    struct S0 *l_644 = (void*)0;
    struct S0 **l_643 = &l_644;
    struct S0 **l_645 = &l_644;
    struct S0 **l_646 = &l_644;
    struct S0 **l_647 = &l_644;
    struct S0 **l_648[6] = {&l_644,&l_644,&l_644,&l_644,&l_644,&l_644};
    struct S0 **l_649 = (void*)0;
    int i;
    return l_649;
    /* statement id: 389 */
    //assert (func_27_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_32(uint32_t  p_33, struct S0 ** p_34)
{ /* block id: 324 */
    struct S0 ***l_520 = (void*)0;
    struct S0 ****l_519 = &l_520;
    int32_t l_533 = 1L;
    int32_t *l_542[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int32_t **l_541 = &l_542[2];
    int32_t ***l_540 = &l_541;
    int32_t ****l_539[5];
    int32_t *****l_538[4][5] = {{&l_539[3],&l_539[3],&l_539[3],&l_539[3],&l_539[3]},{&l_539[3],&l_539[2],&l_539[3],&l_539[2],&l_539[3]},{&l_539[3],&l_539[3],&l_539[3],&l_539[3],&l_539[3]},{&l_539[3],&l_539[2],&l_539[3],&l_539[2],&l_539[3]}};
    uint32_t l_543 = 0xC5310A4CL;
    int32_t l_638 = 0xC2350783L;
    int i, j;
    for (i = 0; i < 5; i++)
        l_539[i] = &l_540;
    for (p_33 = 8; (p_33 < 13); p_33 = safe_add_func_uint64_t_u_u(p_33, 5))
    { /* block id: 327 */
        float l_518 = 0x4.Fp+1;
        float *l_517 = &l_518;
        (*l_517) = 0x9.6D3FF1p+77;
    }
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(uint8_t  p_36, int32_t  p_37, struct S0 * p_38, struct S0 * p_39, int64_t  p_40)
{ /* block id: 81 */
    int8_t l_147 = 1L;
    uint32_t l_152[3];
    int32_t l_210 = 1L;
    int32_t *l_209 = &l_210;
    const struct S0 *l_263 = (void*)0;
    struct S0 l_321 = {-8,1450,-3129};
    struct S0 *l_320 = &l_321;
    struct S0 **l_337 = &l_320;
    struct S0 ***l_336 = &l_337;
    uint16_t l_340 = 0xD853L;
    uint32_t l_441 = 0x91DA7255L;
    int32_t *l_453 = (void*)0;
    int32_t **l_474 = &l_453;
    int32_t ***l_473 = &l_474;
    int32_t ****l_472 = &l_473;
    int32_t *****l_471 = &l_472;
    int i;
    for (i = 0; i < 3; i++)
        l_152[i] = 0x28CA5283L;
lbl_479:
    for (p_40 = 0; (p_40 < (-18)); --p_40)
    { /* block id: 84 */
        int32_t l_149 = 0x89525BE5L;
        int32_t *l_148 = &l_149;
        struct S0 l_156 = {-18,1419,-1460};
        struct S0 *l_155 = &l_156;
        int32_t l_182 = 0x6E321628L;
        int32_t ****l_215[4];
        int32_t *****l_214[2][5][8] = {{{&l_215[1],&l_215[1],&l_215[1],&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0},{&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1]},{(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1]},{&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0},{&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1]}},{{(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1]},{&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0},{&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1],&l_215[1]},{(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1]},{&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0,(void*)0,&l_215[1],(void*)0}}};
        uint64_t l_332 = 1UL;
        int32_t *l_452 = (void*)0;
        int i, j, k;
        for (i = 0; i < 4; i++)
            l_215[i] = (void*)0;
        (*l_148) = l_147;
        for (p_36 = 0; (p_36 < 36); ++p_36)
        { /* block id: 88 */
            struct S0 l_154 = {-10,2642,616};
            struct S0 *l_153 = &l_154;
            uint32_t l_168 = 0x449593A4L;
            int32_t ** const l_190 = (void*)0;
            for (p_37 = 2; (p_37 >= 0); p_37 -= 1)
            { /* block id: 91 */
                int32_t **l_158 = &l_148;
                int32_t ***l_157[2];
                int32_t ****l_159 = &l_157[1];
                int i;
                for (i = 0; i < 2; i++)
                    l_157[i] = &l_158;
                l_155 = l_153;
                /* statement id: 92 */
                assert (l_155 == &l_154);
                (*l_159) = l_157[1];
                (***l_159) = &p_37;
                /* statement id: 94 */
                assert (l_148 == &p_37);
                for (l_147 = 2; (l_147 >= 0); l_147 -= 1)
                { /* block id: 97 */
                    int64_t l_169 = 7L;
                    struct S0 *l_178 = (void*)0;
                    int32_t *l_187 = (void*)0;
                    int32_t l_197 = (-10L);
                    float l_199 = 0x5.F0D3ECp-21;
                    float *l_198 = &l_199;
                    int i;
                }
            }
            /* facts after for loop */
            //assert (l_155 == &l_154 || l_155 == dangling || l_155 == &l_156);
        }
        /* facts after for loop */
        assert (l_148 == &p_37 || l_148 == &l_149);
        //assert (l_155 == dangling || l_155 == &l_156);
        for (l_147 = 0; (l_147 >= (-3)); --l_147)
        { /* block id: 119 */
            int8_t l_204 = 0xFCL;
            int32_t *****l_216 = (void*)0;
            (*l_148) = 0x7864A00AL;
            (*l_148) = (safe_rshift_func_int8_t_s_u(l_204, (safe_sub_func_int8_t_s_s(p_37, (((-1L) | 4294967291UL) == p_40)))));
            for (l_204 = 0; (l_204 == (-22)); l_204 = safe_sub_func_uint64_t_u_u(l_204, 3))
            { /* block id: 124 */
                int32_t ** const l_211 = &l_209;
                int32_t **l_213 = (void*)0;
                int32_t ***l_212 = &l_213;
                l_209 = &p_37;
                /* statement id: 125 */
                assert (l_209 == &p_37);
                (*l_212) = l_211;
                /* statement id: 126 */
                assert (l_213 == &l_209);
                l_216 = l_214[1][0][1];
            }
            /* facts after for loop */
            assert ((l_216 >= &l_215[0] && l_216 <= &l_215[3]) || l_216 == 0);
            if (p_36)
                continue;
        }
    }
    (*l_209) = ((!((safe_mod_func_int8_t_s_s((((void*)0 != l_471) == 0x63A9FF3373FF71A9LL), 0x6AL)) >= (safe_lshift_func_int8_t_s_s((p_40 < (p_36 || (p_37 ^ 3UL))), (safe_lshift_func_uint16_t_u_s(p_40, 14)))))) ^ 0xEDL);
    if (l_147)
        goto lbl_479;
    for (p_36 = 0; (p_36 <= 2); p_36 += 1)
    { /* block id: 292 */
        int32_t *l_487 = (void*)0;
        for (l_441 = 0; (l_441 <= 2); l_441 += 1)
        { /* block id: 295 */
            uint16_t l_498 = 1UL;
            int32_t l_514 = 0L;
            (*l_474) = (void*)0;
            /* statement id: 296 */
            assert (l_453 == 0);
            (****l_471) = &p_37;
            /* statement id: 297 */
            assert (l_453 == &p_37);
            for (l_340 = 0; (l_340 <= 2); l_340 += 1)
            { /* block id: 300 */
                struct S0 ****l_490 = &l_336;
                int i;
                if ((safe_sub_func_uint8_t_u_u(((void*)0 != &l_337), (l_152[p_36] >= ((**l_471) == (void*)0)))))
                { /* block id: 301 */
                    int i;
                    if (l_152[p_36])
                        break;
                }
                else
                { /* block id: 303 */
                    float l_494 = 0x3.BEF064p-87;
                    int i;
                    if (l_152[l_340])
                    { /* block id: 304 */
                        int32_t *l_486 = &l_210;
                        int i;
                        (***l_473) = (safe_add_func_int8_t_s_s((l_152[p_36] ^ 0xC8L), l_152[p_36]));
                        l_487 = l_486;
                        /* statement id: 306 */
                        assert (l_487 == &l_210);
                    }
                    else
                    { /* block id: 307 */
                        (**l_474) = p_40;
                    }
                    if ((l_152[p_36] | ((safe_lshift_func_uint16_t_u_s(((p_36 < 4L) > (l_490 != (void*)0)), 6)) | 0xB600AA30L)))
                    { /* block id: 310 */
                        int32_t *l_491[4] = {&l_210,&l_210,&l_210,&l_210};
                        int i;
                        (****l_471) = l_491[0];
                        /* statement id: 311 */
                        assert (l_453 == &l_210);
                    }
                    else
                    { /* block id: 312 */
                        float *l_495 = &l_494;
                        int32_t l_499 = 1L;
                        (*l_495) = (safe_div_func_float_f_f(0x1.4p+1, l_494));
                        (*l_495) = (safe_add_func_float_f_f((p_36 > (l_498 >= p_36)), ((((l_499 > (safe_sub_func_float_f_f(l_152[p_36], (p_37 == (((safe_add_func_float_f_f((l_152[p_36] < ((-0x1.0p+1) != (((*l_471) != (*l_471)) <= p_36))), p_36)) == l_152[p_36]) == (-0x1.3p-1)))))) != 0xE.74BF43p+6) != p_36) < (***l_473))));
                    }
                    (*l_209) = l_498;
                }
                l_514 = (safe_mod_func_uint16_t_u_u((p_37 >= 0x48L), ((safe_rshift_func_uint8_t_u_u(p_36, (safe_rshift_func_int8_t_s_s(p_40, 5)))) | ((safe_sub_func_int64_t_s_s((**l_474), (safe_rshift_func_uint16_t_u_s((*l_209), 3)))) >= 1UL))));
            }
            /* facts after for loop */
            assert (l_453 == &p_37 || l_453 == &l_210);
        }
        /* facts after for loop */
        assert (l_453 == &p_37 || l_453 == &l_210 || l_453 == 0);
        assert (l_487 == 0 || l_487 == &l_210);
        return p_40;
    }
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_41(uint8_t  p_42, const struct S0 ** p_43, struct S0 * p_44, int8_t  p_45)
{ /* block id: 6 */
    int16_t l_52[4][3][10] = {{{9L,0L,0x2457L,0x1448L,0xA4D2L,1L,0xA4D2L,0x1448L,0x2457L,0L},{9L,1L,5L,0x0A34L,(-2L),0xC1CCL,0x1448L,0x89E7L,0xA4D2L,8L},{8L,1L,0x1448L,0x18B2L,0x33BEL,0xC1CCL,0xAAFEL,0xA91EL,1L,3L}},{{9L,5L,0x9363L,0xA91EL,0x7695L,1L,1L,0x7695L,0xA91EL,0x9363L},{9L,9L,3L,1L,0xA91EL,0xAAFEL,0xC1CCL,0x33BEL,0x18B2L,0x1448L},{3L,0xA91EL,8L,0xA4D2L,0x89E7L,0x1448L,0xC1CCL,(-2L),0x0A34L,5L}},{{0x33BEL,9L,0L,0x2457L,0x1448L,0xA4D2L,1L,0xA4D2L,0x1448L,0x2457L},{1L,5L,1L,0xC1CCL,(-10L),0x33BEL,0xAAFEL,9L,(-8L),1L},{(-1L),1L,0x7695L,(-2L),9L,0L,0x1448L,9L,0x89E7L,8L}},{{0x9363L,1L,1L,(-1L),(-8L),5L,0xA4D2L,0xA4D2L,5L,(-8L)},{8L,0L,0L,8L,1L,5L,0x33BEL,(-2L),3L,0L},{(-10L),0xA91EL,0L,5L,8L,3L,0xAAFEL,5L,9L,8L}}};
    struct S0 l_61 = {16,1915,3367};
    struct S0 *l_60 = &l_61;
    struct S0 **l_59 = &l_60;
    int32_t l_89 = 0x1B2A7AC8L;
    int32_t *l_88 = &l_89;
    int i, j, k;
    (*l_88) = (safe_sub_func_int32_t_s_s((p_45 || (safe_lshift_func_int16_t_s_u(l_52[3][1][5], 8))), ((func_53(func_56(l_59, l_52[3][1][5]), &l_60) <= (safe_div_func_uint64_t_u_u((safe_mod_func_int64_t_s_s((safe_lshift_func_uint16_t_u_s((&p_44 != (void*)0), p_45)), p_42)), l_52[3][1][5]))) & l_61.f2)));
    (*l_88) = (p_42 & (((void*)0 == &p_43) <= (*l_88)));
    for (l_89 = 2; (l_89 == (-25)); l_89--)
    { /* block id: 20 */
        int32_t *l_92 = &l_89;
        int32_t l_94[5] = {(-9L),(-9L),(-9L),(-9L),(-9L)};
        int32_t *l_93 = &l_94[0];
        int i;
        (*l_93) = (l_92 != (void*)0);
    }
    for (p_45 = 0; (p_45 < (-10)); --p_45)
    { /* block id: 25 */
        int32_t **l_97[6][6][7] = {{{&l_88,(void*)0,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88},{&l_88,&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88}},{{&l_88,(void*)0,&l_88,(void*)0,(void*)0,&l_88,(void*)0},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,(void*)0,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88},{&l_88,&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88}},{{&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88},{&l_88,(void*)0,&l_88,(void*)0,(void*)0,&l_88,(void*)0},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,(void*)0,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88}},{{&l_88,&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88},{&l_88,(void*)0,&l_88,(void*)0,(void*)0,&l_88,(void*)0},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88}},{{&l_88,(void*)0,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88}},{{&l_88,&l_88,&l_88,&l_88,&l_88,(void*)0,&l_88},{&l_88,&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,(void*)0,&l_88},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,(void*)0,&l_88,&l_88,&l_88},{&l_88,&l_88,&l_88,&l_88,&l_88,&l_88,&l_88}}};
        struct S0 **l_144[6][9] = {{&l_60,(void*)0,&l_60,&l_60,&l_60,&l_60,&l_60,(void*)0,(void*)0},{(void*)0,&l_60,&l_60,&l_60,(void*)0,&l_60,&l_60,&l_60,&l_60},{&l_60,&l_60,&l_60,&l_60,&l_60,&l_60,&l_60,&l_60,&l_60},{&l_60,(void*)0,&l_60,&l_60,&l_60,(void*)0,&l_60,(void*)0,&l_60},{&l_60,&l_60,&l_60,&l_60,(void*)0,&l_60,&l_60,&l_60,(void*)0},{&l_60,(void*)0,(void*)0,&l_60,&l_60,&l_60,&l_60,&l_60,(void*)0}};
        int i, j, k;
        l_88 = &l_89;
        for (p_42 = 0; (p_42 <= 5); p_42 += 1)
        { /* block id: 29 */
            (*l_88) = (*l_88);
            (*l_59) = (void*)0;
            /* statement id: 31 */
            assert (l_60 == 0);
            return p_45;
        }
        for (l_89 = 0; (l_89 <= 2); l_89 += 1)
        { /* block id: 36 */
            float l_116 = 0x1.Dp+1;
            int32_t l_117 = 7L;
            for (p_42 = 0; (p_42 <= 2); p_42 += 1)
            { /* block id: 39 */
                int32_t l_98 = 4L;
                float l_134 = 0x2.9C6B38p-43;
                int32_t l_135[4][6] = {{0L,(-1L),0L,(-1L),0L,(-1L)},{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)},{0L,(-1L),0L,(-1L),0L,(-1L)},{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)}};
                int i, j;
                for (l_98 = 2; (l_98 >= 0); l_98 -= 1)
                { /* block id: 42 */
                    int32_t l_99 = 0L;
                    int32_t l_102 = (-1L);
                    for (l_99 = 1; (l_99 <= 5); l_99 += 1)
                    { /* block id: 45 */
                        float l_101 = (-0x1.0p-1);
                        float *l_100[1][8] = {{&l_101,(void*)0,&l_101,(void*)0,&l_101,(void*)0,&l_101,(void*)0}};
                        int i, j, k;
                        l_102 = (0xA.713C04p+10 <= l_52[(p_42 + 1)][l_98][(l_89 + 6)]);
                        l_61.f0 = p_45;
                        l_117 = (safe_div_func_uint16_t_u_u((safe_mod_func_int8_t_s_s(((safe_add_func_int64_t_s_s(((((~p_42) > (safe_mod_func_uint8_t_u_u(l_98, (safe_add_func_uint16_t_u_u(p_45, p_42))))) & ((((((-2L) || (((safe_sub_func_uint8_t_u_u(p_42, p_45)) || ((*p_43) == (void*)0)) & p_42)) >= (*l_88)) ^ 0L) <= (*l_88)) < 3UL)) < l_52[(p_42 + 1)][l_98][(l_89 + 6)]), 0x3E5AF5969A1B29E6LL)) > 1L), p_45)), 0xD1FBL));
                        if (l_98)
                            continue;
                    }
                    if ((*l_88))
                    { /* block id: 51 */
                        if ((*l_88))
                            break;
                        return l_102;
                    }
                    else
                    { /* block id: 54 */
                        float *l_118 = &l_116;
                        int32_t l_119 = 8L;
                        (*l_118) = ((*l_59) != (*p_43));
                        return l_119;
                    }
                }
                l_117 = (!(p_42 > (safe_sub_func_int32_t_s_s((safe_sub_func_int8_t_s_s(((~0x65L) >= (((safe_div_func_int8_t_s_s(p_45, (((safe_mod_func_uint8_t_u_u(((safe_rshift_func_uint8_t_u_u(251UL, (safe_mod_func_int8_t_s_s((((void*)0 == &l_117) | (p_42 || l_98)), l_135[2][0])))) ^ p_45), p_45)) & l_117) && 0x04L))) && p_42) < 0x21FBL)), p_45)), l_135[2][0]))));
            }
            for (l_117 = 0; (l_117 <= 2); l_117 += 1)
            { /* block id: 63 */
                const struct S0 ***l_136 = (void*)0;
                struct S0 * const *l_139 = &l_60;
                struct S0 * const **l_138 = &l_139;
                struct S0 * const ***l_137 = &l_138;
                (*l_137) = l_136;
                /* statement id: 64 */
                assert (l_138 == 0);
            }
        }
        for (p_42 = 0; (p_42 == 38); p_42++)
        { /* block id: 69 */
            for (l_89 = (-9); (l_89 > 15); l_89 = safe_add_func_int16_t_s_s(l_89, 9))
            { /* block id: 72 */
                return p_45;
            }
            (*l_88) = (l_144[1][3] != &p_44);
            (*p_43) = (*p_43);
            (*p_43) = (*p_43);
        }
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_53(struct S0 * p_54, struct S0 * const * p_55)
{ /* block id: 12 */
    int32_t l_72 = 0xB56AE7BBL;
    int32_t *l_71 = &l_72;
    struct S0 l_76 = {-8,5177,838};
    struct S0 *l_75[2];
    struct S0 **l_74 = &l_75[0];
    float l_78[2];
    float *l_77[5][5] = {{&l_78[0],&l_78[0],&l_78[0],&l_78[0],&l_78[0]},{&l_78[0],&l_78[0],&l_78[0],&l_78[0],&l_78[0]},{&l_78[0],&l_78[0],&l_78[0],&l_78[0],&l_78[0]},{&l_78[0],&l_78[0],&l_78[0],&l_78[0],&l_78[0]},{&l_78[0],&l_78[0],&l_78[0],&l_78[0],&l_78[0]}};
    struct S0 ***l_79 = (void*)0;
    struct S0 ***l_80[4][2] = {{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0}};
    uint16_t l_81[7][7] = {{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL},{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL},{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL},{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL},{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL},{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL},{0x12A4L,0UL,0UL,0x12A4L,4UL,65535UL,4UL}};
    int i, j;
    for (i = 0; i < 2; i++)
        l_75[i] = &l_76;
    for (i = 0; i < 2; i++)
        l_78[i] = 0x0.3p+1;
    (*l_71) = ((safe_sub_func_float_f_f((l_71 != &l_72), (-0x4.4p+1))) == (!(l_74 != (void*)0)));
    p_55 = &p_54;
    /* statement id: 14 */
    assert (p_55 == &p_54);
    return l_81[2][0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_56(struct S0 ** p_57, uint16_t  p_58)
{ /* block id: 7 */
    uint16_t l_62[6][1] = {{0UL},{0UL},{0UL},{0UL},{0UL},{0UL}};
    float l_64 = 0x9.19CCD2p-22;
    float *l_63[5];
    int32_t l_65[3][4] = {{2L,2L,2L,2L},{2L,2L,2L,2L},{2L,2L,2L,2L}};
    int32_t *l_66[8][9] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,&l_65[1][3],(void*)0,&l_65[2][2],&l_65[2][2],(void*)0,&l_65[1][3],(void*)0},{(void*)0,(void*)0,&l_65[0][0],(void*)0,(void*)0,(void*)0,&l_65[0][0],(void*)0,(void*)0},{&l_65[2][2],(void*)0,&l_65[1][3],(void*)0,(void*)0,&l_65[1][3],(void*)0,&l_65[2][2],&l_65[2][2]},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_65[2][2],(void*)0,(void*)0,(void*)0,(void*)0,&l_65[2][2],&l_65[1][3],&l_65[1][3],&l_65[2][2]},{(void*)0,(void*)0,&l_65[0][0],(void*)0,(void*)0,(void*)0,&l_65[0][0],(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,&l_65[2][2],&l_65[1][3],&l_65[1][3],&l_65[2][2],(void*)0}};
    int32_t l_68 = 0xC1528976L;
    int i, j;
    for (i = 0; i < 5; i++)
        l_63[i] = &l_64;
    l_65[1][3] = (l_62[2][0] != l_62[3][0]);
    l_66[6][3] = &l_65[0][3];
    l_68 = (~p_58);
    return (*p_57);
    /* statement id: 11 */
    //assert (func_56_rv == &l_61 || func_56_rv == &l_896);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 207
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 46
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 16
   indirect level: 3, occurrence: 13
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 83
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 51

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 199
   depth: 2, occurrence: 59
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 41, occurrence: 1

XXX total number of pointers: 235

XXX times a variable address is taken: 652
XXX times a pointer is dereferenced on RHS: 84
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 12
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 99
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 51
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 706

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 263
   level: 2, occurrence: 67
   level: 3, occurrence: 54
   level: 4, occurrence: 20
   level: 5, occurrence: 9
XXX number of pointers point to pointers: 133
XXX number of pointers point to scalars: 71
XXX number of pointers point to structs: 31
XXX percent of pointers has null in alias set: 31.5
XXX average alias set size: 1.31

XXX times a non-volatile is read: 928
XXX times a non-volatile is write: 365
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 8

XXX stmts: 200
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 22
   depth: 2, occurrence: 36
   depth: 3, occurrence: 37
   depth: 4, occurrence: 31
   depth: 5, occurrence: 38

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

