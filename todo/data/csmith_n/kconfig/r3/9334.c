/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3893856470
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_28(void);
static uint8_t  func_42(int16_t  p_43, int64_t  p_44);
inline static const uint32_t  func_52(const int32_t * const  p_53);
inline static int32_t * func_54(uint16_t  p_55, uint32_t  p_56);
inline static int32_t * func_57(int32_t * p_58, int32_t * p_59, int32_t  p_60);
inline static int32_t * func_61(int32_t * const  p_62);
static int32_t * const  func_65(int32_t * p_66, uint16_t  p_67, float * p_68, uint16_t  p_69);
inline static int32_t * func_70(int64_t  p_71, float * p_72, uint32_t  p_73, int32_t * p_74, const int16_t  p_75);
static uint16_t  func_84(const float * const  p_85, float  p_86, int32_t * p_87);
inline static float * const  func_88(int16_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_28(void)
{ /* block id: 36 */
    uint16_t l_29 = 0xBB6BL;
    const int32_t l_2074 = 1L;
    float l_2087 = 0x0.8p-1;
    float *l_2086 = &l_2087;
    int32_t l_2090 = (-4L);
    int32_t *l_2089 = &l_2090;
    int32_t ***l_2093 = (void*)0;
    int32_t ****l_2092 = &l_2093;
    int32_t **** const *l_2091 = &l_2092;
    uint8_t l_2097 = 0x7BL;
    if (l_29)
    { /* block id: 37 */
        uint8_t l_2021 = 4UL;
        int32_t l_2061 = 0L;
        int32_t *l_2060 = &l_2061;
        for (l_29 = 0; (l_29 != 33); l_29++)
        { /* block id: 40 */
            int32_t l_32 = 0L;
            int64_t l_51 = 0x6EA3D88101AEDF47LL;
            uint32_t l_2069 = 0x3DBE72AEL;
            int32_t l_2075 = 0x307F65FCL;
            float *l_2079 = (void*)0;
            int32_t **l_2082 = &l_2060;
            int32_t ***l_2081 = &l_2082;
            int32_t ****l_2080 = &l_2081;
            for (l_32 = (-7); (l_32 <= 13); l_32 = safe_add_func_int64_t_s_s(l_32, 2))
            { /* block id: 43 */
                int32_t l_35 = 0xA32FD2D1L;
                for (l_35 = (-14); (l_35 < 12); l_35 = safe_add_func_uint16_t_u_u(l_35, 9))
                { /* block id: 46 */
                    int32_t l_39 = 7L;
                    int32_t *l_38 = &l_39;
                    float l_41 = 0x4.068CD5p-91;
                    float *l_40 = &l_41;
                    int32_t l_2059 = 0x516B340CL;
                    int32_t *l_2058 = &l_2059;
                    (*l_38) ^= (0xC326874BE76D238ELL && l_32);
                    (*l_40) = (*l_38);
                    (*l_2058) ^= ((func_42(((safe_mul_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u(((l_29 != (*l_38)) > (l_35 >= (safe_lshift_func_int16_t_s_s(l_35, (((l_35 > 0x26L) < l_51) ^ (1L | (func_52(func_54((*l_38), l_29)) & 0xED51BADDL))))))), 0xD24AD4E9A257E261LL)), l_2021)) && l_35), l_2021) < l_35) > l_35);
                    (*l_2058) = l_2021;
                }
                (*l_2060) &= (l_2060 == (void*)0);
            }
            if ((safe_sub_func_int16_t_s_s(((safe_mul_func_int16_t_s_s((*l_2060), l_29)) | (safe_add_func_int8_t_s_s((l_32 >= (~l_2069)), (safe_div_func_int64_t_s_s((l_32 && ((safe_sub_func_uint32_t_u_u(((&l_32 != &l_32) > l_29), (*l_2060))) != l_2074)), 0x05C982900F32E80DLL))))), 0xFB0FL)))
            { /* block id: 355 */
                return l_2075;
            }
            else
            { /* block id: 357 */
                const int32_t l_2076 = (-1L);
                float *l_2088 = &l_2087;
                (*l_2060) = 6L;
                (*l_2060) |= l_2076;
                (*l_2060) = (__builtin_parityll((*l_2060)) ^ ((safe_sub_func_int32_t_s_s(((void*)0 != l_2079), (l_2080 == (void*)0))) != (!func_42((safe_add_func_int8_t_s_s(((*l_2060) ^ ((l_2086 == l_2088) | (*l_2060))), 0xB0L)), (****l_2080)))));
            }
        }
    }
    else
    { /* block id: 363 */
        return l_2074;
    }
    (*l_2089) = func_52(&l_2074);
    l_2091 = l_2091;
    for (l_2090 = 0; (l_2090 < (-8)); l_2090 = safe_sub_func_uint64_t_u_u(l_2090, 1))
    { /* block id: 370 */
        int16_t l_2096 = 0L;
        if ((*l_2089))
            break;
        l_2096 = (-1L);
    }
    return l_2097;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_42(int16_t  p_43, int64_t  p_44)
{ /* block id: 341 */
    int32_t ***l_2022 = (void*)0;
    float l_2024 = (-0x1.4p-1);
    float *l_2023 = &l_2024;
    int32_t l_2030 = 0xD8C7612DL;
    uint32_t l_2041 = 0xA43FC34FL;
    const uint16_t l_2042 = 0UL;
    int32_t l_2043 = 0x0BB4699BL;
    int32_t *l_2044 = (void*)0;
    l_2044 = &l_2030;
    /* statement id: 342 */
    assert (l_2044 == &l_2030);
    (*l_2044) = (safe_div_func_uint8_t_u_u((safe_sub_func_int64_t_s_s(((~((void*)0 == &l_2044)) >= ((safe_mul_func_int8_t_s_s((p_43 || p_44), 0L)) ^ (safe_sub_func_int8_t_s_s((1UL <= p_44), (safe_mod_func_uint32_t_u_u(p_44, ((-7L) | p_43))))))), (*l_2044))), (-1L)));
    for (l_2043 = 19; (l_2043 >= (-6)); l_2043 = safe_sub_func_uint64_t_u_u(l_2043, 1))
    { /* block id: 346 */
        (*l_2044) = (-5L);
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_52(const int32_t * const  p_53)
{ /* block id: 324 */
    int64_t l_1993 = (-4L);
    int32_t *l_1994 = (void*)0;
    int32_t l_1996 = 0L;
    int32_t *l_1995 = &l_1996;
    int32_t ***l_1999 = (void*)0;
    int32_t ****l_1998 = &l_1999;
    int32_t *****l_1997 = &l_1998;
    int32_t *l_2002 = &l_1996;
    const int32_t *l_2003 = &l_1996;
    int64_t l_2009 = 0x98A637AB0D70142CLL;
    const uint32_t l_2020 = 0x1966971AL;
    (*l_1995) |= l_1993;
    if (((&l_1996 == &l_1996) & (((0xEA216EF0A4FD427ELL == (*l_1995)) != ((*l_1995) && (l_1997 != &l_1998))) != ((safe_add_func_int16_t_s_s(func_84(p_53, (*l_1995), l_2002), (*l_1995))) | 0x02FFF7E7L))))
    { /* block id: 326 */
        l_2003 = p_53;
        /* statement id: 327 */
        //assert (l_2003 == 0 || l_2003 == &l_2074);
    }
    else
    { /* block id: 328 */
        uint32_t l_2004 = 0xE0F61E65L;
        int32_t *l_2008 = (void*)0;
        int32_t l_2010 = 0xF3C71CA7L;
        (*l_2002) = l_2004;
        l_2010 ^= (((!(safe_lshift_func_int8_t_s_u(func_84(func_57(l_2008, func_57(&l_1996, l_2008, l_2009), (*l_2002)), l_2004, l_2008), 1))) || 0UL) == l_2004);
        return l_2010;
    }
    /* facts after branching */
    //assert (l_2003 == 0 || l_2003 == &l_2074);
    for (l_2009 = 0; (l_2009 < (-27)); l_2009 = safe_sub_func_int32_t_s_s(l_2009, 6))
    { /* block id: 335 */
        int16_t l_2015 = 2L;
        int32_t l_2017 = 0L;
        int32_t *l_2016 = &l_2017;
        const int32_t **l_2018 = (void*)0;
        int32_t **l_2019 = &l_2002;
        (*l_2016) ^= func_84(p_53, (0x9.F1D77Ap-58 <= ((safe_mul_func_float_f_f(l_2015, ((l_2015 > 0xF.F5BF3Cp+11) >= ((l_2015 <= (0x8.B645EAp+41 < l_2015)) == (*l_1995))))) != l_2015)), &l_1996);
        (*l_1998) = (**l_1997);
        (*l_2019) = p_53;
        /* statement id: 338 */
        //assert (l_2002 == 0 || l_2002 == &l_2074);
    }
    /* facts after for loop */
    //assert (l_2002 == 0 || l_2002 == &l_1996 || l_2002 == &l_2074);
    return l_2020;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_54(uint16_t  p_55, uint32_t  p_56)
{ /* block id: 49 */
    int32_t l_64 = 0L;
    int32_t * const l_63 = &l_64;
    int32_t l_1960 = 1L;
    int32_t *l_1959 = &l_1960;
    int32_t ***l_1967 = (void*)0;
    int32_t ****l_1966 = &l_1967;
    int32_t ***** const l_1965 = &l_1966;
    int32_t **l_1988 = &l_1959;
    int32_t * const l_1989 = (void*)0;
    int32_t *l_1990 = &l_64;
    int32_t *l_1991 = &l_1960;
    int32_t *l_1992 = (void*)0;
    (*l_1988) = func_57(func_61(l_63), l_1959, (3UL | ((safe_add_func_int8_t_s_s((safe_mul_func_uint8_t_u_u(((l_1965 == (void*)0) > (safe_div_func_int8_t_s_s(p_56, 0x42L))), p_55)), 0xF4L)) || p_55)));
    /* statement id: 321 */
    assert (l_1959 == 0);
    (*l_1988) = (*l_1988);
    return l_1992;
    /* statement id: 323 */
    //assert (func_54_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_57(int32_t * p_58, int32_t * p_59, int32_t  p_60)
{ /* block id: 318 */
    int32_t l_1971 = 0xF1D7EE46L;
    int32_t *l_1970 = &l_1971;
    uint8_t l_1982 = 255UL;
    int32_t **l_1983 = &l_1970;
    int32_t *l_1984 = &l_1971;
    int32_t *l_1985 = &l_1971;
    int32_t *l_1986 = &l_1971;
    int32_t *l_1987 = (void*)0;
    (*l_1983) = &l_1971;
    return l_1987;
    /* statement id: 320 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_61(int32_t * const  p_62)
{ /* block id: 50 */
    uint16_t l_91 = 65530UL;
    int32_t l_98 = 0L;
    int32_t *l_97 = &l_98;
    int8_t l_111 = 0x50L;
    uint64_t l_957 = 0UL;
    int32_t **l_1921 = &l_97;
    int32_t ****l_1929 = (void*)0;
    int32_t *****l_1928 = &l_1929;
    int8_t l_1945 = 0x68L;
    uint8_t l_1946 = 0x1EL;
    const float l_1947 = (-0x7.4p-1);
    int16_t l_1948 = 0x166AL;
    uint8_t l_1949 = 0UL;
    int32_t *l_1958 = (void*)0;
    (*l_1921) = func_65(func_70(((safe_sub_func_int32_t_s_s((((safe_mul_func_int16_t_s_s((((safe_mod_func_int16_t_s_s(0x9DDAL, (safe_div_func_uint16_t_u_u(func_84(func_88(__builtin_parityll((__builtin_bswap32((~l_91)) > (((0L == l_91) >= (0x3A11L || ((((l_91 <= l_91) != ((void*)0 != p_62)) & 0UL) | l_91))) >= l_91)))), l_91, l_97), (*l_97))))) & l_111) || (*l_97)), (*l_97))) >= (*l_97)) < (*l_97)), (*p_62))) && (*l_97)), l_97, (*l_97), &l_98, (*l_97)), l_111, l_97, l_957);
    (*l_1921) = func_88(((**l_1921) != ((**l_1921) >= (((void*)0 == (*l_1921)) <= (*l_97)))));
    /* statement id: 308 */
    assert (l_97 == 0);
    (*p_62) = (((safe_div_func_uint64_t_u_u(((l_1928 != (void*)0) != ((safe_mod_func_int32_t_s_s(((safe_mod_func_uint64_t_u_u(((*p_62) || (safe_sub_func_int64_t_s_s((safe_mod_func_int8_t_s_s(l_91, (safe_add_func_int64_t_s_s((!(__builtin_parityl(l_91) != (safe_mul_func_uint16_t_u_u(0UL, func_84(p_62, l_98, (*l_1921)))))), l_1946)))), l_1945))), 0x4F73D1D156A481BDLL)) | l_957), l_111)) >= l_98)), l_1948)) != l_98) && l_1949);
    for (l_1949 = 0; (l_1949 >= 57); l_1949 = safe_add_func_uint32_t_u_u(l_1949, 5))
    { /* block id: 312 */
        const int32_t **l_1952 = (void*)0;
        int32_t **l_1953 = &l_97;
        int32_t l_1956 = 0x61896F86L;
        int32_t **l_1957 = &l_97;
        (*l_1953) = p_62;
        /* statement id: 313 */
        //assert (l_97 == &l_64 || l_97 == &l_1971);
        l_1956 &= (safe_add_func_uint64_t_u_u(1UL, (**l_1921)));
        (*l_1957) = p_62;
    }
    /* facts after for loop */
    //assert (l_97 == &l_64 || l_97 == 0 || l_97 == &l_1971);
    return l_1958;
    /* statement id: 317 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_65(int32_t * p_66, uint16_t  p_67, float * p_68, uint16_t  p_69)
{ /* block id: 189 */
    int32_t l_958 = 0x2769300BL;
    int32_t *l_982 = &l_958;
    int32_t **l_981 = &l_982;
    int32_t ***l_980 = &l_981;
    int32_t **** const l_979 = &l_980;
    int32_t **** const *l_978 = &l_979;
    uint8_t l_983 = 248UL;
    int32_t l_1022 = (-4L);
    int32_t l_1023 = 0x8B886543L;
    int32_t l_1027 = (-1L);
    int32_t l_1041 = 0xD6015E6FL;
    uint8_t l_1088 = 0xCEL;
    int32_t l_1156 = 0x0574AFD1L;
    int32_t l_1160 = 8L;
    int32_t l_1165 = 1L;
    int16_t l_1176 = (-1L);
    int32_t l_1190 = 0xFF973A43L;
    int32_t l_1204 = 0x9DCB5690L;
    int32_t l_1221 = 0xA193AE4FL;
    int32_t l_1225 = (-6L);
    int32_t l_1243 = 0x5E3B09CDL;
    int32_t l_1244 = 0x878790BBL;
    int32_t l_1251 = 0x249E643CL;
    int32_t l_1279 = 0x12E92DBFL;
    int32_t l_1295 = 0L;
    int32_t l_1301 = (-6L);
    int32_t l_1303 = 0x4EE91578L;
    int32_t l_1311 = 0x230573A1L;
    int32_t l_1315 = 0L;
    int32_t l_1319 = 0x15DFC926L;
    int32_t l_1320 = 0x1F455B02L;
    int32_t l_1356 = (-1L);
    int32_t l_1361 = (-8L);
    int32_t l_1385 = (-1L);
    int32_t l_1407 = 0x9939738CL;
    int32_t l_1428 = 0xC956BABEL;
    int32_t l_1443 = 0x024B0C67L;
    int32_t l_1451 = 7L;
    uint64_t l_1462 = 0UL;
    int32_t l_1479 = 6L;
    float *l_1483 = (void*)0;
    uint32_t l_1498 = 0x81F29ADAL;
    (*p_68) = ((*p_68) < l_958);
    (*p_66) &= (safe_mul_func_int16_t_s_s((255UL || p_67), __builtin_parityl(p_67)));
    for (p_69 = 0; (p_69 > 28); p_69 = safe_add_func_int16_t_s_s(p_69, 3))
    { /* block id: 194 */
        int8_t l_969 = 0x0AL;
        uint32_t l_984 = 0x0C95A2D9L;
        for (l_958 = 0; (l_958 < (-6)); l_958 = safe_sub_func_uint8_t_u_u(l_958, 4))
        { /* block id: 197 */
            (*p_68) = (*p_68);
        }
        (***l_980) = (safe_rshift_func_uint8_t_u_s((safe_mul_func_uint16_t_u_u(l_969, (safe_mul_func_uint8_t_u_u((safe_sub_func_uint64_t_u_u((safe_mul_func_uint8_t_u_u((safe_mod_func_uint64_t_u_u(p_69, l_969)), ((((*p_66) && l_958) && l_958) != __builtin_bswap64(l_969)))), ((((void*)0 == l_978) != l_983) >= l_984))), 0xEEL)))), l_984));
    }
    for (l_958 = (-23); (l_958 <= (-18)); l_958 = safe_add_func_uint64_t_u_u(l_958, 8))
    { /* block id: 204 */
        uint32_t l_995 = 6UL;
        float l_1016 = 0x1.3p-1;
        int32_t l_1040 = 1L;
        int32_t l_1047 = 0xDE009277L;
        int32_t l_1117 = 0xA9FE20B2L;
        int32_t l_1146 = 0x9E097414L;
        int32_t l_1166 = 0x2DFCA730L;
        int32_t l_1169 = (-1L);
        int32_t l_1173 = (-5L);
        int32_t l_1183 = 1L;
        int32_t l_1248 = 0x7E7559BAL;
        int32_t l_1265 = 1L;
        int32_t l_1270 = (-4L);
        int32_t l_1273 = 0x49CE2F00L;
        int32_t l_1291 = (-1L);
        int32_t l_1293 = 1L;
        int32_t l_1304 = 0x486C2D6AL;
        int32_t l_1312 = (-3L);
        int32_t l_1336 = (-1L);
        int32_t l_1339 = (-6L);
        int32_t l_1347 = 0x4B2FB893L;
        int32_t l_1357 = 0x07DF9474L;
        int32_t l_1380 = 0xF60A16BFL;
        int32_t l_1382 = 0x37533C60L;
        int32_t l_1386 = 0xE2818373L;
        int32_t l_1389 = 5L;
        int32_t l_1395 = 0x40562B0EL;
        int32_t l_1422 = 0L;
        int32_t l_1424 = 0L;
        int32_t l_1426 = 0x7688DBADL;
        int32_t l_1477 = (-1L);
        uint32_t l_1575 = 0x19C1D5E6L;
    }
    return p_68;
    /* statement id: 306 */
    //assert (func_65_rv == &l_98);
}


/* ------------------------------------------ */
/* 
 * reads : l_98
 * writes: l_98
 */
inline static int32_t * func_70(int64_t  p_71, float * p_72, uint32_t  p_73, int32_t * p_74, const int16_t  p_75)
{ /* block id: 66 */
    float l_112 = 0x4.7p-1;
    int32_t l_114 = 0x91C1AAD5L;
    int32_t *l_113 = &l_114;
    int32_t l_200 = (-1L);
    int32_t l_213 = 0x573AC2B9L;
    int32_t l_221 = 0x223408E3L;
    int32_t l_226 = 0x7987148AL;
    uint8_t l_231 = 0xC4L;
    int32_t l_306 = (-2L);
    int16_t l_325 = 0x722CL;
    int32_t l_337 = 0x9968936EL;
    int32_t l_347 = 0x19F7A439L;
    int32_t l_350 = 0xCDDA5586L;
    int32_t l_363 = 0x26385603L;
    int32_t l_366 = 0x4BC6AF4CL;
    int32_t l_381 = 0L;
    int32_t l_383 = 0x0FA09440L;
    int32_t l_386 = 0xB8073F35L;
    int32_t l_414 = 0xFD8273ADL;
    int64_t l_465 = 0x559E1138FA42621BLL;
    int32_t l_497 = 0L;
    int32_t l_506 = 0x8ED7BAA0L;
    int32_t l_524 = 0L;
    int32_t l_533 = 0xE76BDE14L;
    int32_t l_563 = 0L;
    int32_t l_565 = (-3L);
    int32_t l_595 = 0x8C2E6879L;
    int32_t l_597 = 0x59D0C1D5L;
    int32_t l_606 = 0xD8EACDA7L;
    int32_t l_617 = 0L;
    int32_t l_657 = 0xC10A686AL;
    int32_t l_687 = 6L;
    int32_t l_725 = 0x4F3B56E7L;
    int32_t l_736 = (-1L);
    int32_t l_762 = 0x9CEF0DF0L;
    int32_t l_784 = 1L;
    int32_t l_802 = 0x6ABC1FAAL;
    int32_t l_816 = 0xD8044210L;
    int32_t l_839 = (-1L);
    int16_t l_892 = 0x8C48L;
    uint32_t l_934 = 0x63C31E38L;
    (*p_74) ^= ((p_71 >= p_71) != 1UL);
    (*l_113) ^= (*p_74);
    if (l_114)
        goto lbl_115;
lbl_115:
    (*p_74) |= (*l_113);
    for (p_71 = 28; (p_71 <= 26); p_71 = safe_sub_func_uint64_t_u_u(p_71, 1))
    { /* block id: 73 */
        uint32_t l_118 = 18446744073709551615UL;
        int32_t *l_121 = &l_114;
        int8_t l_124 = 0xE1L;
        int32_t l_190 = 0L;
        int8_t l_194 = 0x4EL;
        int32_t **l_253 = &l_113;
        int32_t ***l_252 = &l_253;
        int32_t l_307 = 0x75515534L;
        int32_t l_323 = 0xC323CAD4L;
        int32_t l_345 = 1L;
        int32_t l_353 = 0xD7C10739L;
        int32_t l_360 = 0x284A6CA7L;
        int32_t l_401 = (-1L);
        int32_t l_431 = 0x5EE61869L;
        int32_t l_460 = (-7L);
        int32_t l_462 = 0x0A6FF864L;
        int32_t l_466 = 9L;
        int32_t l_528 = (-10L);
        int32_t l_551 = 1L;
        int32_t l_571 = 0x0211C2E6L;
        int32_t l_577 = 0x6AF418E2L;
        int32_t l_598 = (-7L);
        int32_t l_602 = 5L;
        int32_t l_604 = 1L;
        int32_t l_615 = 0xA8A0955AL;
        int32_t l_628 = (-7L);
        int32_t l_646 = 0x2FD6FEC2L;
        int32_t l_647 = 7L;
        int32_t l_663 = 0x197BD910L;
        int32_t l_664 = 0x73B3B5CCL;
        int32_t l_677 = (-1L);
        int32_t l_706 = 2L;
        int32_t l_712 = 0x18E70DCBL;
        int32_t l_733 = 0x12ED9C82L;
        int32_t l_765 = 0L;
        int32_t l_791 = (-4L);
        int32_t l_803 = 4L;
        int32_t l_807 = 0x77426CD3L;
        int32_t l_826 = 0xB601889AL;
        int32_t *l_879 = &l_460;
        int32_t l_891 = 3L;
        int32_t ****l_918 = &l_252;
        int32_t *****l_917 = &l_918;
    }
    return p_72;
    /* statement id: 188 */
    //assert (func_70_rv == &l_98 || func_70_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_84(const float * const  p_85, float  p_86, int32_t * p_87)
{ /* block id: 56 */
    int16_t l_101 = (-3L);
    int32_t l_103 = 1L;
    int32_t *l_102 = &l_103;
    int16_t l_110 = (-8L);
    p_87 = (void*)0;
    /* statement id: 57 */
    assert (p_87 == 0);
    (*l_102) = (safe_lshift_func_uint16_t_u_u((l_101 || __builtin_clzl(l_101)), l_101));
    for (l_103 = 0; (l_103 >= (-20)); l_103 = safe_sub_func_int64_t_s_s(l_103, 9))
    { /* block id: 61 */
        int32_t *l_106 = (void*)0;
        int32_t **l_107 = &l_106;
        int32_t l_109 = 1L;
        int32_t *l_108 = &l_109;
        (*l_107) = l_106;
        (*l_108) = (-1L);
    }
    return l_110;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * const  func_88(int16_t  p_89)
{ /* block id: 51 */
    int32_t *l_92 = (void*)0;
    int32_t l_94 = 0x7DFF937BL;
    int32_t *l_93 = &l_94;
    int32_t **l_95 = &l_92;
    float * const l_96 = (void*)0;
    l_92 = l_92;
    (*l_93) ^= ((void*)0 == l_92);
    (*l_95) = &l_94;
    /* statement id: 54 */
    assert (l_92 == &l_94);
    return l_96;
    /* statement id: 55 */
    //assert (func_88_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 400
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 12, occurrence: 4
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 20, occurrence: 2
   depth: 35, occurrence: 1

XXX total number of pointers: 1343

XXX times a variable address is taken: 1064
XXX times a pointer is dereferenced on RHS: 128
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 13
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2
   depth: 5, occurrence: 6
XXX times a pointer is dereferenced on LHS: 97
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 3294

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 356
   level: 2, occurrence: 65
   level: 3, occurrence: 36
   level: 4, occurrence: 34
   level: 5, occurrence: 40
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 1281
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.9
XXX average alias set size: 1.03

XXX times a non-volatile is read: 716
XXX times a non-volatile is write: 282
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 74
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 42
   depth: 1, occurrence: 19
   depth: 2, occurrence: 3
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4

XXX percentage a fresh-made variable is used: 30.2
XXX percentage an existing variable is used: 69.8
********************* end of statistics **********************/

