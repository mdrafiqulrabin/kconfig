/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1661696034
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   int32_t  f2;
   float  f3;
   uint16_t  f4;
   uint16_t  f5;
   int16_t  f6;
   const int16_t  f7;
};

struct S1 {
   const signed f0 : 15;
   unsigned f1 : 19;
   int32_t  f2;
   float  f3;
   float  f4;
   const struct S0  f5;
   int32_t  f6;
   int32_t  f7;
   uint16_t  f8;
   const int16_t  f9;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_27(void);
static int32_t * func_28(uint16_t  p_29, int32_t * p_30, int32_t * p_31);
inline static int32_t * func_35(int32_t * p_36);
static int32_t * func_40(uint32_t  p_41, int16_t  p_42, uint32_t  p_43, float  p_44, int16_t  p_45);
static int16_t  func_46(uint16_t  p_47, int32_t * p_48);
inline static uint32_t  func_51(uint32_t  p_52, int32_t * p_53);
inline static uint32_t  func_54(int16_t  p_55, int32_t * p_56, struct S1  p_57, int32_t * p_58, struct S1  p_59);
inline static int32_t * func_68(struct S1  p_69, int32_t * p_70, struct S1  p_71);
static struct S1  func_72(int32_t * p_73, int32_t * p_74);
inline static int32_t * func_75(int32_t  p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_27(void)
{ /* block id: 36 */
    int32_t l_32 = 0x9A20B287;
    int32_t l_34 = 1;
    int32_t *l_33 = &l_34;
    int32_t **l_756 = &l_33;
    (*l_756) = func_28(l_32, l_33, func_35(&l_34));
    (*l_756) = func_75((*l_33));
    /* statement id: 554 */
    assert (l_33 == 0);
    return l_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_28(uint16_t  p_29, int32_t * p_30, int32_t * p_31)
{ /* block id: 546 */
    float l_754 = 0x1.Dp+1;
    float *l_753 = &l_754;
    float **l_752 = &l_753;
    for (p_29 = 0; (p_29 >= 55); ++p_29)
    { /* block id: 549 */
        float ***l_755 = &l_752;
        (*l_755) = l_752;
    }
    return p_30;
    /* statement id: 552 */
    //assert (func_28_rv == &l_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_35(int32_t * p_36)
{ /* block id: 37 */
    int32_t l_37 = 0x2044653F;
    struct S1 l_369 = {-41,260,-1,-0x1.4p+1,0xC.2D33CDp-71,{1,0xDD7A7D4E,0xA64805D4,0x4.6E4623p+10,65535U,3U,0xB566,0x6466},0xB96BC2F6,-1,0xBBDB,0xF537};
    struct S1 *l_368 = &l_369;
    struct S1 **l_367 = &l_368;
    int32_t *l_672 = (void*)0;
    float *l_680 = (void*)0;
    float *l_681 = &l_369.f4;
    if ((l_37 <= l_37))
    { /* block id: 38 */
        int32_t *l_49 = &l_37;
        int32_t l_374 = 0xF0863EA2;
        for (l_37 = 23; (l_37 > (-28)); l_37 -= 7)
        { /* block id: 41 */
            int32_t **l_671 = &l_49;
        }
        return l_672;
        /* statement id: 485 */
        //assert (func_35_rv == 0);
    }
    else
    { /* block id: 486 */
        int16_t l_678 = 0xD444;
        for (l_369.f2 = 0; (l_369.f2 >= 0); l_369.f2 += 8)
        { /* block id: 489 */
            uint16_t l_677 = 9U;
            int32_t **l_679 = &l_672;
            (*p_36) = (((int32_t)(*p_36) + (int32_t)func_46(l_677, &l_37)) || l_678);
            (*l_679) = (void*)0;
        }
    }
    (*l_681) = l_369.f5.f0;
    for (l_369.f2 = 19; (l_369.f2 > (-6)); l_369.f2 -= 5)
    { /* block id: 497 */
        const int16_t l_688 = 0xD93C;
        float **l_692 = &l_681;
        int32_t **l_694 = &l_672;
        (*p_36) = __builtin_clzl(((uint16_t)((uint16_t)(65527U <= l_688) << (uint16_t)(((((*p_36) || ((!(((((void*)0 != l_692) & (((-2) & (+l_688)) || 0x8FA08E01)) && (&l_692 != &l_692)) & l_369.f7)) | l_688)) == l_688) != 0x9D83) < 0x4204F4B9)) >> (uint16_t)l_688));
        (*l_694) = &l_37;
        /* statement id: 499 */
        assert (l_672 == &l_37);
    }
    /* facts after for loop */
    assert (l_672 == &l_37 || l_672 == 0);
    for (l_369.f6 = 17; (l_369.f6 <= (-25)); l_369.f6 -= 7)
    { /* block id: 503 */
        int32_t l_702 = 0x34EB755A;
        struct S1 l_703 = {32,639,1,-0x1.Dp+1,0x0.F991E3p-57,{0,4294967290U,-6,-0x1.0p+1,0xEA86,4U,-2,0xB89A},-4,0xB14CCE04,0xB75B,3};
        if (l_369.f5.f2)
            break;
        for (l_37 = 11; (l_37 == 21); l_37 += 5)
        { /* block id: 507 */
            uint16_t l_699 = 0x54C5;
            struct S1 l_704 = {36,9,0x44624887,0xE.5B6D13p+13,-0x1.Fp+1,{0x15F5E4D8,0x130743C4,7,0x0.Cp+1,65529U,6U,-1,0x264E},4,0xA68565ED,0xCE03,0xAAA1};
            struct S1 *l_714 = (void*)0;
            (*p_36) = (l_699 != l_699);
            if (((uint16_t)func_54(l_702, &l_702, l_703, p_36, l_704) >> (uint16_t)6))
            { /* block id: 509 */
                uint32_t l_710 = 0U;
                int32_t *l_712 = (void*)0;
                int32_t **l_713 = &l_672;
                (*p_36) = ((int32_t)2 - (int32_t)l_703.f0);
                if (((uint16_t)0xCF6D - (uint16_t)l_704.f5.f6))
                { /* block id: 511 */
                    (*p_36) = (l_710 == l_710);
                    if (l_704.f1)
                        break;
                }
                else
                { /* block id: 514 */
                    const uint32_t l_711 = 0xC5F107DE;
                    (*l_681) = (l_711 <= l_711);
                }
                if (l_704.f5.f6)
                    continue;
                (*l_713) = l_712;
                /* statement id: 518 */
                assert (l_672 == 0);
            }
            else
            { /* block id: 519 */
                l_714 = (void*)0;
            }
            for (l_369.f2 = 0; (l_369.f2 == (-7)); --l_369.f2)
            { /* block id: 524 */
                uint32_t l_717 = 5U;
                int32_t *l_718 = &l_704.f2;
                int32_t **l_725 = (void*)0;
                (*p_36) = ((func_46(l_717, l_718) && ((uint16_t)((*l_718) != ((uint16_t)__builtin_popcount((((int16_t)(((1 == l_703.f0) == (((*p_36) >= l_703.f5.f4) <= (((-7) & (*l_718)) & 0x9F8C9900))) < l_704.f2) << (int16_t)l_704.f5.f4) > 0x1D01)) >> (uint16_t)(*l_718))) >> (uint16_t)15)) || l_703.f5.f0);
                l_672 = &l_702;
                /* statement id: 526 */
                assert (l_672 == &l_702);
                if ((*p_36))
                    continue;
                if (l_703.f0)
                    break;
            }
            for (l_699 = 27; (l_699 != 23); l_699 -= 4)
            { /* block id: 532 */
                float l_734 = 0x8.Bp-1;
                int32_t l_737 = 0xDDA95D63;
                struct S1 *l_738 = &l_369;
                (*p_36) = ((int16_t)(((uint16_t)(((uint16_t)l_703.f0 << (uint16_t)5) == (l_704.f5.f5 && l_703.f5.f7)) << (uint16_t)((int16_t)__builtin_ctzll(l_737) - (int16_t)(l_738 != (void*)0))) >= ((int16_t)((*p_36) ^ l_703.f5.f0) >> (int16_t)2)) + (int16_t)0x342A);
                for (l_369.f2 = (-20); (l_369.f2 > 5); ++l_369.f2)
                { /* block id: 536 */
                    int32_t **l_744 = &l_672;
                    int32_t ***l_743 = &l_744;
                    (*l_743) = (void*)0;
                    /* statement id: 537 */
                    assert (l_744 == 0);
                    (*l_681) = (!((((float)l_704.f0 - (float)l_703.f5.f5) != ((l_369.f8 == (((-0x7.Ep+1) <= l_703.f1) > (((float)(func_51(l_737, p_36) < __builtin_popcountll(l_737)) - (float)l_737) == l_703.f5.f0))) < 0xD.745CECp+29)) == (-0x1.6p+1)));
                    (*l_681) = l_703.f5.f1;
                }
            }
        }
        /* facts after for loop */
        //assert (l_672 == &l_702 || l_672 == &l_37 || l_672 == 0 || l_672 == dangling);
        if ((*p_36))
            continue;
        //assert (l_672 == &l_37 || l_672 == 0 || l_672 == dangling);
    }
    /* facts after for loop */
    //assert (l_672 == dangling || l_672 == &l_37 || l_672 == 0);
    return p_36;
    /* statement id: 545 */
    //assert (func_35_rv == &l_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_40(uint32_t  p_41, int16_t  p_42, uint32_t  p_43, float  p_44, int16_t  p_45)
{ /* block id: 236 */
    const struct S1 ***l_378 = (void*)0;
    const struct S1 **** const l_377 = &l_378;
    int32_t l_382 = 0x53794E85;
    int32_t *l_386 = &l_382;
    struct S1 l_413 = {124,393,-7,0x0.E927DCp-90,0x0.5CFD58p+70,{1,2U,0,0x0.7p-1,65535U,0x7D7D,0x70F1,-1},0,0x0AADFC8F,0xBCA3,3};
    struct S1 *l_412 = &l_413;
    struct S0 l_425 = {0x617BD3B6,0xAF083671,0x64957EB5,0x0.Bp-1,0x8AE7,0xFF7B,0x54B7,0x3B86};
    struct S0 *l_424 = &l_425;
    struct S0 **l_423 = &l_424;
    float *l_448 = (void*)0;
    float **l_447 = &l_448;
    float ** const *l_446 = &l_447;
    float *l_465 = &l_413.f4;
    const struct S0 *l_524 = (void*)0;
    const int32_t *l_533 = &l_382;
    const int32_t **l_532 = &l_533;
    const int32_t ***l_531 = &l_532;
    const int32_t ****l_530 = &l_531;
    int32_t *l_628 = &l_382;
    int32_t *l_645 = (void*)0;
    int32_t *l_654 = &l_382;
    int32_t *l_655 = &l_382;
    int32_t *l_657 = &l_382;
    int32_t *l_658 = &l_413.f2;
    int32_t *l_659 = &l_382;
    int32_t *l_660 = &l_382;
    int32_t *l_661 = &l_413.f2;
    int32_t *l_662 = &l_413.f2;
    int32_t *l_663 = &l_413.f2;
    int32_t *l_664 = &l_413.f2;
    int32_t *l_665 = &l_382;
    int32_t *l_666 = &l_382;
    int32_t *l_667 = &l_413.f2;
    int32_t *l_668 = &l_382;
    int32_t *l_669 = &l_382;
    int32_t *l_670 = (void*)0;
lbl_476:
    for (p_45 = 7; (p_45 < (-3)); p_45 -= 7)
    { /* block id: 239 */
        const int16_t l_385 = 0;
        struct S1 *l_419 = &l_413;
        int32_t *l_428 = &l_382;
        float ***l_457 = &l_447;
        int32_t *l_462 = &l_382;
    }
lbl_502:
    (*l_465) = ((float)0x1.6p-1 - (float)func_54(p_41, &l_382, (*l_412), &l_382, (*l_412)));
    if ((((int16_t)(&l_412 == (void*)0) >> (int16_t)__builtin_clzll((*l_386))) != (p_41 < (0xB9DF > __builtin_bswap32((&l_423 == &l_423))))))
    { /* block id: 315 */
        uint32_t l_474 = 0U;
        int32_t *l_475 = &l_413.f2;
        int32_t *l_488 = (void*)0;
        struct S1 l_491 = {-107,514,-6,0x1.1p+1,0x4.DFE641p+60,{0,6U,0,0x0.3296E9p-26,0xEEE9,6U,0x36B3,-5},0x3E9CCB2E,-5,0x3191,0x7B8E};
        float ****l_504 = (void*)0;
        struct S1 *l_508 = (void*)0;
        int32_t *l_515 = &l_413.f2;
        for (p_41 = 0; (p_41 != 54); ++p_41)
        { /* block id: 318 */
            int16_t l_473 = 0x2F23;
            int32_t *l_486 = &l_382;
            int32_t l_499 = (-1);
            for (l_413.f7 = (-30); (l_413.f7 > 27); ++l_413.f7)
            { /* block id: 321 */
                int16_t l_472 = 0xF8E3;
                (*l_465) = ((l_472 <= p_43) < l_474);
                l_475 = l_475;
            }
            if ((*l_386))
            { /* block id: 325 */
                int16_t l_477 = (-2);
                int32_t l_480 = (-7);
                int32_t **l_489 = &l_486;
                if (l_413.f1)
                    goto lbl_476;
                l_480 = (l_477 >= ((uint32_t)l_473 + (uint32_t)p_45));
                for (l_425.f2 = 0; (l_425.f2 == (-12)); --l_425.f2)
                { /* block id: 330 */
                    struct S1 *l_483 = &l_413;
                    struct S1 **l_484 = &l_412;
                    int32_t *l_487 = &l_382;
                    (*l_484) = l_483;
                    (*l_465) = (-(float)((&l_378 != (void*)0) == l_477));
                    return l_488;
                    /* statement id: 333 */
                    //assert (func_40_rv == 0);
                }
                (*l_489) = (void*)0;
                /* statement id: 335 */
                assert (l_486 == 0);
            }
            else
            { /* block id: 336 */
                struct S1 l_490 = {-144,346,0x17D37ABF,0xB.B3D3DDp+62,0x4.96A1F4p+67,{0,0xE6516F62,0xE6B0F8BA,0x8.43A99Ep+11,8U,6U,0,0xBEF9},0,0xB364926A,0U,-3};
                int32_t **l_492 = &l_475;
                float ****l_498 = (void*)0;
                int32_t *l_511 = &l_413.f2;
                (*l_492) = func_68(l_490, l_475, l_491);
                for (l_490.f7 = 0; (l_490.f7 == (-6)); --l_490.f7)
                { /* block id: 340 */
                    uint32_t l_495 = 1U;
                    struct S1 l_503 = {-146,420,-2,0xF.657440p-35,0x3.4FFF47p-14,{0xA4846FCA,6U,0,-0x1.Ap+1,0x3276,65535U,0x5B92,3},0x4AE0E502,1,65528U,-8};
                    float ** const **l_505 = &l_446;
                    struct S1 l_506 = {112,12,0xF01D9B6F,0xD.01407Ap-29,-0x1.Cp-1,{0xE6791457,4294967287U,2,0x8.BFD595p-28,1U,1U,0xDD31,0xE942},0x1363FEBE,0,3U,1};
                    int32_t *l_507 = &l_491.f2;
                    (*l_492) = (void*)0;
                    /* statement id: 341 */
                    assert (l_475 == 0);
                    if (l_495)
                        break;
                    if ((((uint32_t)(&l_446 != l_498) - (uint32_t)(l_499 != (0xE7EF7F5E >= ((p_42 <= 0x3F19BAA0) > p_43)))) & ((uint32_t)p_41 + (uint32_t)((func_46(p_45, &l_382) < p_41) != 65535U))))
                    { /* block id: 343 */
                        if (l_491.f1)
                            goto lbl_502;
                        if ((*l_386))
                            continue;
                    }
                    else
                    { /* block id: 346 */
                        (*l_492) = func_68(l_503, func_75((l_504 != l_505)), l_506);
                        (*l_465) = p_41;
                        l_507 = (void*)0;
                        /* statement id: 349 */
                        assert (l_507 == 0);
                        l_508 = &l_491;
                        /* statement id: 350 */
                        assert (l_508 == &l_491);
                    }
                    /* facts after branching */
                    assert (l_507 == 0 || l_507 == &l_491.f2);
                }
                for (l_490.f6 = 0; (l_490.f6 >= 16); l_490.f6 += 6)
                { /* block id: 355 */
                    int32_t *l_512 = &l_490.f2;
                    (*l_386) = (*l_486);
                    if (p_45)
                        break;
                    return l_488;
                    /* statement id: 358 */
                    //assert (func_40_rv == 0);
                }
                for (l_491.f8 = (-29); (l_491.f8 == 48); l_491.f8++)
                { /* block id: 362 */
                    int32_t ** const *l_516 = (void*)0;
                    int32_t ***l_518 = &l_492;
                    int32_t ****l_517 = &l_518;
                    l_475 = l_515;
                    /* statement id: 363 */
                    assert (l_475 == &l_413.f2);
                    (*l_517) = l_516;
                    /* statement id: 364 */
                    assert (l_518 == 0);
                }
            }
            /* facts after branching */
            assert (l_486 == &l_382 || l_486 == 0);
        }
        /* facts after for loop */
        assert (l_475 == 0 || l_475 == &l_413.f2);
        assert (l_508 == &l_491 || l_508 == 0);
    }
    else
    { /* block id: 368 */
        int32_t *l_546 = (void*)0;
        uint32_t l_577 = 0xA0BF7875;
        int32_t l_600 = 0x51A33E66;
        struct S1 l_603 = {-75,482,0x5B7B7121,0x9.Ep-1,-0x1.5p-1,{0x81DE384B,1U,0x5455D2C6,0x1.4p-1,1U,5U,1,-8},7,0xB3F16D4D,0x958B,0xC90E};
        int32_t *l_639 = &l_382;
        int32_t *l_641 = &l_382;
        int32_t *l_642 = &l_413.f2;
        if (p_42)
        { /* block id: 369 */
            const uint32_t l_521 = 0xECE66188;
            struct S1 l_545 = {-86,289,0x166F9012,-0x1.1p+1,0x1.C6F9ADp-17,{0x78B3FBFA,0x4407815D,-9,-0x1.Dp+1,0x228B,0xFCAD,0,0x062F},0,-3,65535U,0xA4DD};
            int32_t *l_553 = &l_382;
            const struct S1 l_557 = {26,129,-3,0x0.079872p-77,0x1.C5409Dp+39,{0x3E3703D4,0x6281A325,0xEB74CCD8,0x6.8F94D1p-8,0xF4DF,0x6F85,-6,1},7,0,65535U,0x9B6F};
            const struct S1 *l_556 = &l_557;
            int32_t *l_602 = &l_600;
            uint32_t l_607 = 0xCA3E4B44;
            struct S1 **l_627 = &l_412;
            struct S1 ***l_626 = &l_627;
            if (((void*)0 == (*l_447)))
            { /* block id: 370 */
                int32_t *l_527 = &l_382;
                int32_t ** const l_536 = (void*)0;
                int32_t ** const *l_535 = &l_536;
                int32_t ** const **l_534 = &l_535;
                const struct S1 *l_547 = &l_413;
                for (p_42 = 2; (p_42 <= (-9)); p_42--)
                { /* block id: 373 */
                    struct S0 *l_528 = (void*)0;
                }
                for (l_545.f7 = (-19); (l_545.f7 >= 13); l_545.f7++)
                { /* block id: 394 */
                    int32_t *l_552 = &l_413.f2;
                    (**l_531) = func_68(l_545, l_546, func_72(l_552, l_553));
                    /* statement id: 395 */
                    assert (l_533 == 0);
                    (**l_531) = (*l_532);
                }
                /* facts after for loop */
                assert (l_533 == 0 || l_533 == &l_382);
                (***l_530) = (**l_531);
                (***l_530) = l_546;
                /* statement id: 399 */
                assert (l_533 == 0);
            }
            else
            { /* block id: 400 */
                struct S1 *l_562 = &l_545;
                int32_t l_581 = 0xEE3F8290;
                uint32_t l_617 = 0x07C3206A;
                (*l_532) = l_546;
                /* statement id: 401 */
                assert (l_533 == 0);
lbl_592:
                for (l_413.f8 = 0; (l_413.f8 == 11); l_413.f8 += 1)
                { /* block id: 404 */
                    l_556 = (void*)0;
                    /* statement id: 405 */
                    assert (l_556 == 0);
                }
                for (l_545.f8 = 0; (l_545.f8 != 52); l_545.f8 += 1)
                { /* block id: 409 */
                    const uint32_t l_568 = 4294967295U;
                    int32_t *l_576 = &l_382;
                    for (l_425.f1 = 29; (l_425.f1 < 5); l_425.f1 -= 1)
                    { /* block id: 412 */
                        struct S1 **l_563 = &l_412;
                        float *l_564 = &l_545.f4;
                        uint32_t l_575 = 0xF080F728;
                        (*l_563) = l_562;
                        /* statement id: 413 */
                        assert (l_412 == &l_545);
                        (*l_386) = p_43;
                        (*l_576) = ((func_51((((l_564 != (**l_446)) & ((!((int16_t)(((l_568 && (((uint32_t)(0x5BCC > l_568) % (uint32_t)0xBEADD9E8) || ((uint32_t)((uint16_t)l_568 + (uint16_t)p_42) - (uint32_t)(((l_568 == (*l_553)) >= p_45) <= p_41)))) <= (-2)) != l_575) % (int16_t)p_45)) ^ l_575)) != p_41), l_576) != l_575) == l_575);
                        if (l_577)
                            continue;
                    }
                    (*l_576) = (*l_576);
                    l_581 = (((int16_t)(-(int32_t)p_43) % (int16_t)p_42) < (*l_576));
                }
                if (((int32_t)(p_45 ^ ((uint16_t)65530U >> (uint16_t)l_581)) + (int32_t)(-(int32_t)(((p_42 == p_42) && ((-9) && ((int32_t)(2U || ((*l_553) >= ((void*)0 != &l_424))) - (int32_t)p_42))) != 65531U))))
                { /* block id: 421 */
                    int32_t *l_589 = &l_413.f2;
                    struct S1 l_599 = {-0,581,0x23D0AE86,-0x9.1p-1,0x1.Cp+1,{0xC7076DC8,0U,-1,0xD.539A67p+17,0x5D68,9U,0,0xEC52},0x49B9EA43,6,0x1F31,0x62F5};
                    l_589 = l_589;
                    if ((((uint16_t)(func_54(p_45, &l_581, (*l_562), l_546, func_72(&l_581, &l_581)) != ((((0x0210C1FD & 0xC2F8884A) | 0x9A13) < p_42) ^ p_45)) >> (uint16_t)5) > p_42))
                    { /* block id: 423 */
                        (**l_531) = func_75(p_42);
                        (*l_589) = (*l_589);
                        if (l_413.f5.f4)
                            goto lbl_592;
                    }
                    else
                    { /* block id: 427 */
                        (*l_386) = ((*l_553) >= func_46(p_45, l_546));
                        (*l_465) = 0x5.A39B11p+93;
                    }
                    (*l_386) = __builtin_popcountl((((int16_t)((65535U | 0x305E) & ((int32_t)(p_45 <= ((uint16_t)p_45 >> (uint16_t)5)) + (int32_t)func_54(p_45, l_546, func_72(func_75(l_581), func_75(__builtin_ia32_crc32qi(l_581, (*l_386)))), &l_382, l_599))) << (int16_t)p_43) ^ p_43));
                }
                else
                { /* block id: 432 */
                    int32_t *l_604 = (void*)0;
                    struct S1 l_606 = {143,366,0xE3A9BAEC,0x2.E49804p+54,-0x1.0p-1,{0x00422E32,0U,1,0xB.9FF846p-70,0x23DB,5U,0xC6AB,-1},0x1E281811,0xFC0008E9,65535U,-1};
                    uint32_t l_625 = 4294967293U;
                    if (__builtin_bswap64(l_600))
                    { /* block id: 433 */
                        int32_t l_601 = 0x62F8D9F0;
                        struct S1 l_605 = {159,392,0xFAF23E3C,0xA.1047FFp+57,0x1.3p-1,{0x3E583418,0x3C334C97,5,-0x1.6p-1,65530U,0U,1,1},0x79604E55,0xA433C18C,65528U,0x369E};
                        p_44 = (l_601 < 0xF.1F8EF4p+28);
                        (*l_532) = func_68(func_72(l_602, func_68(l_603, l_604, l_605)), &l_581, l_606);
                        /* statement id: 435 */
                        assert (l_533 == &l_581);
                    }
                    else
                    { /* block id: 436 */
                        int32_t l_608 = 0x56E0A0F9;
                        int32_t *l_616 = &l_606.f2;
                        (*l_532) = (void*)0;
                        (*l_602) = (*l_553);
                        (*l_602) = ((p_42 == ((((l_607 >= (*l_553)) | l_608) >= p_45) && ((((uint16_t)(l_608 != (-7)) >> (uint16_t)(((uint16_t)(!((uint16_t)(((l_616 != l_602) != 0) >= p_41) % (uint16_t)p_41)) - (uint16_t)65535U) | p_45)) && 0x1D55) | (*l_616)))) || (-8));
                    }
                    /* facts after branching */
                    assert (l_533 == 0 || l_533 == &l_581);
                    (*l_532) = func_75((p_41 && (p_45 > l_617)));
                    /* statement id: 441 */
                    assert (l_533 == 0);
                    (**l_531) = &l_600;
                    /* statement id: 442 */
                    assert (l_533 == &l_600);
                    for (l_413.f6 = (-22); (l_413.f6 <= 7); ++l_413.f6)
                    { /* block id: 445 */
                        struct S1 l_624 = {-5,723,0x68C63D8A,0x1.Fp+1,0x3.CF5AACp+60,{0x257852AE,4294967288U,1,-0x1.1p+1,0x73E6,0U,0x68BD,0x67D3},-7,0x8E5C880D,0U,1};
                        (**l_531) = func_75(((uint16_t)func_54((((((*l_553) ^ (p_42 < 0x6228CDCA)) > (((p_45 >= l_617) ^ ((uint32_t)p_42 + (uint32_t)(p_41 ^ (((p_45 && p_45) >= 0xEF630404) ^ 0x506D42E6)))) & p_41)) && p_43) < (*l_602)), &l_382, l_603, &l_600, l_624) - (uint16_t)p_41));
                        /* statement id: 446 */
                        assert (l_533 == 0);
                        if (l_624.f5.f2)
                            goto lbl_592;
                        if (l_625)
                            continue;
                        (*l_532) = l_604;
                    }
                    /* facts after for loop */
                    assert (l_533 == 0 || l_533 == &l_600);
                }
                /* facts after branching */
                assert (l_533 == 0 || l_533 == &l_600);
            }
            /* facts after branching */
            assert (l_412 == &l_545 || l_412 == &l_413);
            assert (l_533 == 0 || l_533 == &l_600);
            assert (l_556 == 0 || l_556 == &l_557);
            (*l_626) = &l_556;
            /* statement id: 453 */
            assert (l_627 == &l_556);
            (***l_530) = func_68(func_72(l_628, l_553), func_68(l_603, &l_382, l_603), l_603);
            /* statement id: 454 */
            assert (l_533 == &l_382);
            for (l_603.f2 = 0; (l_603.f2 != (-20)); l_603.f2 -= 1)
            { /* block id: 457 */
                int32_t *l_631 = &l_600;
                (**l_531) = l_631;
                /* statement id: 458 */
                assert (l_533 == &l_600);
                for (l_545.f7 = (-23); (l_545.f7 == 7); l_545.f7 += 1)
                { /* block id: 461 */
                    int32_t * const *l_636 = &l_386;
                    int32_t **l_637 = &l_602;
                    for (l_413.f2 = 0; (l_413.f2 != 0); l_413.f2 += 9)
                    { /* block id: 464 */
                        p_44 = p_41;
                        (*l_386) = ((void*)0 == l_636);
                        (*l_628) = (*l_631);
                    }
                    (*l_637) = (*l_636);
                    /* statement id: 469 */
                    assert (l_602 == &l_382);
                }
            }
            /* facts after for loop */
            assert (l_533 == &l_600 || l_533 == &l_382);
            assert (l_602 == &l_382 || l_602 == &l_600);
        }
        else
        { /* block id: 472 */
            int32_t *l_638 = &l_603.f2;
            int32_t *l_640 = &l_603.f2;
            int32_t *l_643 = &l_413.f2;
            int32_t *l_644 = &l_382;
            return l_645;
            /* statement id: 473 */
            //assert (func_40_rv == 0);
        }
        /* facts after branching */
        //assert (l_412 == dangling || l_412 == &l_413);
        assert (l_533 == &l_600 || l_533 == &l_382);
        (*l_639) = (((float)0xC.F4CFEEp+7 - (float)((float)(-0x10.2p-1) + (float)(*l_641))) >= (**l_532));
    }
    /* facts after branching */
    //assert (l_412 == dangling || l_412 == &l_413);
    //assert (l_533 == dangling || l_533 == &l_382);
    for (l_425.f0 = 0; (l_425.f0 != 15); ++l_425.f0)
    { /* block id: 479 */
        int32_t *l_652 = &l_413.f2;
        int32_t *l_653 = &l_382;
        int32_t *l_656 = (void*)0;
        return l_656;
        /* statement id: 480 */
        //assert (func_40_rv == 0);
    }
    return l_670;
    /* statement id: 482 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_46(uint16_t  p_47, int32_t * p_48)
{ /* block id: 42 */
    uint32_t l_50 = 4294967290U;
    int32_t l_67 = (-1);
    int32_t *l_66 = &l_67;
    struct S1 l_286 = {-12,45,0,0x3.5E1C89p-76,0x1.6p+1,{9,0U,1,0x5.Dp+1,8U,1U,0x24FC,-10},0x33B5AC01,0x37A76346,2U,0x7A79};
    int32_t **l_294 = &l_66;
    const int16_t l_296 = 1;
    int32_t *l_322 = &l_67;
    struct S1 *l_335 = &l_286;
    struct S1 **l_334 = &l_335;
    struct S1 ***l_333 = &l_334;
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : l_37 l_34
 * writes:
 */
inline static uint32_t  func_51(uint32_t  p_52, int32_t * p_53)
{ /* block id: 172 */
    int32_t l_293 = 0xFB2146FE;
    int32_t *l_292 = &l_293;
    int32_t **l_291 = &l_292;
    (*l_291) = p_53;
    /* statement id: 173 */
    //assert (l_292 == &l_67 || l_292 == &l_37 || l_292 == &l_427 || l_292 == &l_382 || l_292 == &l_34);
    (*l_291) = p_53;
    return (*l_292);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_54(int16_t  p_55, int32_t * p_56, struct S1  p_57, int32_t * p_58, struct S1  p_59)
{ /* block id: 169 */
    uint32_t l_290 = 0x9CADE458;
    p_58 = p_58;
    return l_290;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_68(struct S1  p_69, int32_t * p_70, struct S1  p_71)
{ /* block id: 166 */
    uint16_t l_287 = 3U;
    int32_t l_289 = 0xA07E403E;
    int32_t *l_288 = &l_289;
    l_288 = func_75(l_287);
    /* statement id: 167 */
    assert (l_288 == 0);
    return p_70;
    /* statement id: 168 */
    //assert (func_68_rv == &l_67 || func_68_rv == 0 || func_68_rv == &l_37 || func_68_rv == &l_413.f2 || func_68_rv == &l_382 || func_68_rv == &l_581);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_72(int32_t * p_73, int32_t * p_74)
{ /* block id: 158 */
    uint16_t l_258 = 0x4AA4;
    uint32_t l_259 = 1U;
    uint16_t l_269 = 0x5E31;
    int32_t l_275 = 0xDC7D750D;
    struct S1 l_283 = {98,116,0x3A04C8BE,0xA.84F500p-11,0x1.77EAE8p+9,{-6,0xBFAE00D6,0xFD04E3DF,0x1.8p-1,0x6B58,0U,0x13D9,0x3D4E},1,8,2U,0x8333};
    struct S1 *l_282 = &l_283;
    struct S1 **l_281 = &l_282;
    struct S1 ***l_280 = &l_281;
    struct S1 l_285 = {-95,150,0x33B8448D,0x1.C5529Ep+49,0x5.D6B5ECp-48,{0,0x497D294A,0xA51FE324,-0x1.2p-1,5U,0x7469,0xE7A6,-1},0,1,9U,4};
    if (l_258)
    { /* block id: 159 */
        uint32_t l_272 = 1U;
        float l_277 = 0x1.3p+1;
        float *l_276 = &l_277;
        (*l_276) = __builtin_parity(((l_259 || l_259) != (~((int16_t)((int32_t)(l_259 != (((uint16_t)l_259 - (uint16_t)(((uint32_t)l_259 + (uint32_t)(l_269 <= 1U)) > (((((((uint16_t)l_272 - (uint16_t)((int16_t)l_272 % (int16_t)(-10))) | l_272) || l_272) < 0x8DE3217A) | l_275) & l_275))) || l_272)) + (int32_t)l_272) >> (int16_t)11))));
    }
    else
    { /* block id: 161 */
        int32_t * const *l_278 = (void*)0;
        int32_t *l_279 = &l_275;
        struct S1 ****l_284 = &l_280;
        (*l_279) = ((void*)0 != l_278);
        (*l_284) = l_280;
    }
    return l_285;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_75(int32_t  p_76)
{ /* block id: 43 */
    int32_t l_80 = (-4);
    int32_t *l_79 = &l_80;
    uint16_t l_81 = 0U;
    struct S0 l_98 = {0x90E36F36,1U,1,0x4.CF8258p+26,6U,0x9E25,0x2E96,-1};
    const struct S0 *l_97 = &l_98;
    const struct S0 **l_96 = &l_97;
    int16_t l_140 = 0xFA60;
    int32_t *l_148 = &l_80;
    int32_t *l_150 = &l_80;
    float *l_193 = &l_98.f3;
    float ** const l_192 = &l_193;
    float ** const *l_191 = &l_192;
    const struct S1 ***l_197 = (void*)0;
    uint16_t l_239 = 0x497D;
    int32_t *l_241 = &l_80;
    int32_t *l_246 = &l_80;
    int32_t *l_247 = &l_80;
    int32_t *l_248 = &l_80;
    int32_t *l_249 = &l_80;
    int32_t *l_250 = &l_80;
    int32_t *l_251 = &l_80;
    int32_t *l_252 = &l_80;
    int32_t *l_253 = &l_80;
    int32_t *l_254 = &l_80;
    int32_t *l_255 = &l_80;
    int32_t *l_256 = &l_80;
    int32_t *l_257 = (void*)0;
    (*l_79) = p_76;
    if (p_76)
        goto lbl_99;
lbl_99:
    if (((*l_79) != p_76))
    { /* block id: 45 */
        (*l_79) = ((p_76 & (p_76 < ((l_81 || (p_76 & 0x4AC9)) && p_76))) && p_76);
    }
    else
    { /* block id: 47 */
        float l_83 = (-0x3.Cp+1);
        float *l_82 = &l_83;
        struct S0 **l_84 = (void*)0;
        struct S0 l_87 = {-1,3U,0x6EA79F15,0xC.9DC621p-82,0x3C2A,0U,0xED76,-1};
        struct S0 *l_86 = &l_87;
        struct S0 **l_85 = &l_86;
        (*l_82) = (*l_79);
        (*l_85) = (void*)0;
        /* statement id: 49 */
        assert (l_86 == 0);
        for (l_81 = 0; (l_81 <= 11); l_81++)
        { /* block id: 52 */
            int32_t **l_90 = (void*)0;
            int32_t **l_91 = &l_79;
            uint32_t l_92 = 0x9F779DD1;
            if ((*l_79))
                break;
            (*l_91) = &p_76;
            /* statement id: 54 */
            assert (l_79 == &p_76);
            if (l_92)
                continue;
        }
        /* facts after for loop */
        assert (l_79 == &p_76 || l_79 == &l_80);
        (*l_79) = ((!(((((uint16_t)p_76 - (uint16_t)(&l_86 == l_96)) ^ 0U) > ((*l_79) | p_76)) >= ((__builtin_parity(p_76) > (&l_97 == &l_97)) || (*l_79)))) > 0xFD0B78A1);
    }
    /* facts after branching */
    assert (l_79 == &p_76 || l_79 == &l_80);
    for (l_98.f0 = 0; (l_98.f0 > (-20)); l_98.f0--)
    { /* block id: 62 */
        uint16_t l_107 = 65535U;
        int32_t *l_142 = &l_80;
        int32_t *l_153 = &l_80;
        struct S0 l_162 = {0x892DAB10,9U,0xA894EA7F,0x1.2p-1,65535U,0x481C,0x0FAE,0x7F40};
        struct S0 *l_161 = &l_162;
        struct S1 l_196 = {101,689,0xD67D768E,0xE.0C6443p+87,0x1.Ep+1,{0,0x5B907267,1,-0x1.2p+1,0xA1E9,8U,-1,-1},0,0x3434F96D,0xEFD3,0x0965};
        struct S1 *l_195 = &l_196;
        struct S1 **l_194 = &l_195;
        uint32_t l_238 = 0xCD3A8A00;
        int32_t **l_245 = &l_241;
    }
    return l_257;
    /* statement id: 157 */
    //assert (func_75_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 233
   depth: 1, occurrence: 0
   depth: 2, occurrence: 21
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 44
breakdown:
   indirect level: 0, occurrence: 21
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 19
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 43
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 7

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 166
   depth: 2, occurrence: 43
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 9, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2

XXX total number of pointers: 258

XXX times a variable address is taken: 272
XXX times a pointer is dereferenced on RHS: 108
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 148
breakdown:
   depth: 1, occurrence: 131
   depth: 2, occurrence: 11
   depth: 3, occurrence: 6
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 817

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 373
   level: 2, occurrence: 39
   level: 3, occurrence: 30
   level: 4, occurrence: 7
XXX number of pointers point to pointers: 96
XXX number of pointers point to scalars: 134
XXX number of pointers point to structs: 28
XXX percent of pointers has null in alias set: 27.5
XXX average alias set size: 1.32

XXX times a non-volatile is read: 815
XXX times a non-volatile is write: 391
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 7

XXX stmts: 157
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 21
   depth: 2, occurrence: 16
   depth: 3, occurrence: 31
   depth: 4, occurrence: 32
   depth: 5, occurrence: 27

XXX percentage a fresh-made variable is used: 11.5
XXX percentage an existing variable is used: 88.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

