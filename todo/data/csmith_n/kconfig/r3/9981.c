/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2426466920
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
   unsigned f1 : 15;
   signed f2 : 7;
   unsigned f3 : 13;
   unsigned f4 : 30;
   unsigned f5 : 18;
   signed f6 : 11;
   signed f7 : 24;
   signed f8 : 9;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_13 = 8;
static int32_t g_126 = 2;
static struct S0 g_127 = {0x0CD8,139,-2,54,23245,188,-16,-3970,-19};
static uint32_t g_208 = 4294967295U;
static struct S0 g_253 = {0xCB94,39,8,84,21982,127,43,-1373,-3};
static int32_t g_264 = (-1);
static uint16_t g_349 = 0x32E1;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_27(void);
static struct S0  func_28(uint32_t  p_29, uint32_t  p_30);
static int32_t  func_46(uint16_t  p_47, uint16_t  p_48, uint32_t  p_49, int32_t  p_50);
static uint16_t  func_51(struct S0  p_52, int32_t  p_53);
static int32_t  func_55(uint16_t  p_56, int32_t  p_57, struct S0  p_58, int16_t  p_59);
static uint32_t  func_62(int32_t  p_63, int16_t  p_64, uint32_t  p_65, int32_t  p_66, int16_t  p_67);
static struct S0  func_77(uint32_t  p_78);
static struct S0  func_81(uint16_t  p_82, uint32_t  p_83);
static int16_t  func_90(int16_t  p_91, int16_t  p_92, int16_t  p_93, int32_t  p_94, uint32_t  p_95);
static uint16_t  func_100(int32_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_13 g_127 g_126 g_208 g_253 g_264 g_349
 * writes: g_13 g_126 g_127 g_208 g_253
 */
static uint32_t  func_27(void)
{ /* block id: 36 */
    uint16_t l_39 = 0x09B4;
    struct S0 l_54 = {0xD73C,169,8,26,27289,451,-31,-2820,18};
    l_54 = func_28((((int16_t)0x2DB8 << (int16_t)((int16_t)__builtin_popcountl(((uint16_t)((int16_t)l_39 << (int16_t)15) + (uint16_t)((-2) > (((0x3D4752E4 || ((int16_t)(((int32_t)func_46(func_51(l_54, g_13), ((((int16_t)func_90(l_39, ((1U <= l_54.f7) & l_54.f7), l_54.f3, g_349, l_39) << (int16_t)g_349) && l_54.f0) >= 0xCF64), l_54.f8, l_39) % (int32_t)g_349) & g_349) >> (int16_t)g_349)) >= l_54.f7) == g_264)))) >> (int16_t)g_349)) && g_127.f1), g_349);
    return l_54.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_127.f7 g_208 g_253.f7 g_253.f8 g_127.f2 g_127.f8 g_13 g_126 g_127 g_253.f5
 * writes: g_253.f2 g_126 g_127
 */
static struct S0  func_28(uint32_t  p_29, uint32_t  p_30)
{ /* block id: 209 */
    uint32_t l_392 = 4294967295U;
    uint32_t l_393 = 2U;
    uint16_t l_394 = 0U;
    uint32_t l_395 = 0x19D07E72;
    uint32_t l_417 = 4294967294U;
    struct S0 l_418 = {0x5D72,123,-3,59,26403,497,-41,-2888,12};
    g_253.f2 = ((int16_t)((uint16_t)((-(uint32_t)((((uint32_t)((p_30 | (-(uint32_t)((1U <= l_392) > (l_392 >= l_393)))) >= l_394) % (uint32_t)g_127.f7) ^ p_29) == (p_29 & l_393))) || g_208) + (uint16_t)g_253.f7) + (int16_t)l_394);
    l_418 = func_81(l_395, ((int16_t)(-(uint16_t)(((int16_t)g_253.f7 - (int16_t)func_100((g_253.f8 == __builtin_popcountl((((int32_t)__builtin_ffsll(((((uint32_t)g_253.f8 - (uint32_t)(l_394 == ((int16_t)((uint32_t)(((int16_t)(((uint16_t)(((((uint32_t)l_395 + (uint32_t)g_127.f2) <= ((uint16_t)p_30 + (uint16_t)p_30)) | (-1)) ^ l_392) << (uint16_t)0) && l_392) << (int16_t)l_393) && 0x7548190C) % (uint32_t)g_208) % (int16_t)g_127.f8))) && l_417) > p_29)) - (int32_t)g_126) & 0xB65AA121))))) ^ g_208)) - (int16_t)p_29));
    if ((l_418.f0 < __builtin_ffs(g_127.f0)))
    { /* block id: 212 */
        uint32_t l_419 = 0x75F23333;
        l_419 = g_126;
    }
    else
    { /* block id: 214 */
        uint32_t l_422 = 8U;
        l_418.f7 = __builtin_bswap64(((g_253.f5 && 0U) != p_30));
        l_422 = ((int16_t)g_127.f6 + (int16_t)g_127.f6);
    }
    return l_418;
}


/* ------------------------------------------ */
/* 
 * reads : g_253.f6 g_127.f4
 * writes:
 */
static int32_t  func_46(uint16_t  p_47, uint16_t  p_48, uint32_t  p_49, int32_t  p_50)
{ /* block id: 206 */
    int32_t l_383 = (-5);
    l_383 = (g_253.f6 ^ ((uint16_t)g_127.f4 >> (uint16_t)13));
    return g_127.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_127 g_126 g_208 g_253 g_264 g_349
 * writes: g_13 g_126 g_127 g_208 g_253
 */
static uint16_t  func_51(struct S0  p_52, int32_t  p_53)
{ /* block id: 37 */
    int32_t l_68 = 0x41911659;
    uint32_t l_75 = 4294967293U;
    uint32_t l_76 = 1U;
    struct S0 l_316 = {0x627F,144,-4,64,28931,96,-17,-638,-5};
    int32_t l_365 = 0;
    uint32_t l_366 = 0x4FFB7BE2;
    int16_t l_367 = 0x31F8;
    uint32_t l_368 = 0U;
    int16_t l_369 = 0;
    if (func_55((((uint16_t)(__builtin_ctz(func_62((l_68 != g_13), l_68, (g_13 < ((((int16_t)(((((uint32_t)((((int16_t)__builtin_bswap64(l_75) << (int16_t)11) < l_68) != ((__builtin_parityll(g_13) < l_75) || p_53)) % (uint32_t)g_13) > 0x888327BC) & g_13) | p_52.f6) >> (int16_t)15) != 0x39A24791) <= l_76)), g_13, g_13)) != 0x49478B05) - (uint16_t)l_68) & l_75), l_76, g_253, g_253.f1))
    { /* block id: 166 */
        int32_t l_315 = 0x2ADD3FD6;
        struct S0 l_317 = {65535U,23,-5,56,12030,396,37,560,18};
        p_52.f2 = (l_315 ^ 0);
        l_317 = l_316;
    }
    else
    { /* block id: 169 */
        uint32_t l_324 = 0x95AFFE87;
        uint32_t l_325 = 1U;
        for (p_52.f0 = 18; (p_52.f0 < 38); p_52.f0 += 7)
        { /* block id: 172 */
            uint16_t l_350 = 0x31B2;
            g_253.f6 = (p_52.f4 >= g_127.f4);
            for (g_253.f0 = 0; (g_253.f0 >= 47); g_253.f0 += 4)
            { /* block id: 176 */
                int32_t l_337 = 0;
                if (((int32_t)g_253.f0 - (int32_t)l_324))
                { /* block id: 177 */
                    uint32_t l_332 = 0x4B7888E8;
                    if (p_52.f3)
                    { /* block id: 178 */
                        p_52.f6 = l_325;
                        g_253.f8 = 0x8EAB9743;
                        p_52.f8 = ((uint16_t)65535U >> (uint16_t)1);
                    }
                    else
                    { /* block id: 182 */
                        p_52.f2 = ((int32_t)func_62(g_253.f8, ((uint16_t)func_100(l_332) - (uint16_t)(5U & (((l_316.f3 ^ ((((int16_t)((int32_t)5 % (int32_t)g_253.f5) << (int16_t)14) | __builtin_parityll((l_332 == g_253.f2))) >= (-1))) < p_52.f5) > 9))), l_332, p_52.f6, l_337) - (int32_t)0U);
                        g_127.f7 = 1;
                        if (p_52.f0)
                            continue;
                    }
                    g_127.f6 = (1 > l_332);
                    return l_324;
                }
                else
                { /* block id: 189 */
                    struct S0 l_340 = {0x22AD,137,2,62,3306,334,-43,-1782,1};
                    for (l_337 = 0; (l_337 == 17); l_337 += 1)
                    { /* block id: 192 */
                        struct S0 l_341 = {65535U,9,-8,86,1088,392,12,-1814,4};
                        l_341 = l_340;
                    }
                }
                g_127.f2 = __builtin_popcount((!g_127.f7));
                if (l_337)
                    break;
                p_52.f7 = (((int16_t)(((int16_t)((int16_t)func_62(g_349, p_53, g_253.f5, l_350, p_53) >> (int16_t)p_52.f3) << (int16_t)g_253.f7) >= p_52.f6) % (int16_t)l_316.f0) && g_13);
            }
        }
    }
    p_52.f6 = ((int16_t)func_90(p_52.f2, (((int32_t)(g_208 ^ g_13) - (int32_t)p_52.f5) | l_316.f5), ((__builtin_ctzl((!((int16_t)0 - (int16_t)((((uint32_t)(((uint16_t)((p_52.f5 || ((((-(uint32_t)__builtin_ctzl((((uint16_t)l_365 << (uint16_t)(p_52.f5 | l_366)) || l_68))) == (-6)) && p_52.f5) >= g_208)) || p_52.f5) % (uint16_t)p_52.f6) <= 0x3293) + (uint32_t)l_365) | 0xEAB548E3) | p_52.f5)))) < l_367) & 0xD53B), p_52.f3, g_349) << (int16_t)14);
    l_369 = l_368;
    p_52.f2 = (-(uint16_t)(((uint32_t)(((int32_t)((int16_t)__builtin_parity(__builtin_ffsl((l_316.f5 != ((uint16_t)p_52.f1 >> (uint16_t)p_52.f8)))) + (int16_t)g_253.f3) % (int32_t)__builtin_ffs(g_126)) ^ (p_52.f8 && l_316.f5)) % (uint32_t)p_52.f3) == p_52.f4));
    return l_365;
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_127.f2 g_127.f8 g_127.f1 g_253.f4 g_253.f7 g_264 g_253.f2 g_253.f0 g_127.f0 g_208 g_253.f3 g_253.f8 g_126 g_127 g_253.f1
 * writes: g_127.f0 g_208 g_253 g_126 g_127.f6 g_127.f8
 */
static int32_t  func_55(uint16_t  p_56, int32_t  p_57, struct S0  p_58, int16_t  p_59)
{ /* block id: 129 */
    int16_t l_260 = (-8);
    int32_t l_266 = 0x13BD95B1;
    if (((int32_t)((int16_t)((((uint16_t)__builtin_ffsll(l_260) << (uint16_t)12) & g_127.f2) <= __builtin_clzl((g_127.f8 & (p_58.f1 != ((g_127.f1 != (g_253.f4 < (0x9870 != g_127.f1))) & p_58.f0))))) - (int16_t)(-3)) + (int32_t)0x5D1FD822))
    { /* block id: 130 */
        uint32_t l_265 = 0x89CFB0AB;
        uint32_t l_267 = 0xF31CA428;
        l_266 = (p_57 >= ((uint32_t)g_253.f4 + (uint32_t)(((((func_90((-(uint32_t)((g_127.f1 < (p_58.f2 == func_100(__builtin_ffsll(l_260)))) < g_253.f7)), g_264, l_265, l_265, l_260) <= 0xE9A5C54A) | p_57) != p_58.f2) && l_265) > p_58.f5)));
        l_267 = func_100(g_253.f2);
        for (l_260 = 12; (l_260 == 3); l_260 -= 1)
        { /* block id: 135 */
            uint16_t l_274 = 65535U;
            l_274 = (((int16_t)g_253.f0 >> (int16_t)3) < ((int16_t)__builtin_popcount(p_58.f0) + (int16_t)(p_58.f0 || g_253.f0)));
            return l_274;
        }
        for (g_127.f0 = 0; (g_127.f0 < 22); g_127.f0 += 1)
        { /* block id: 141 */
            int32_t l_312 = 0xEFD4EDF9;
            for (g_208 = 0; (g_208 < 27); g_208 += 4)
            { /* block id: 144 */
                int32_t l_311 = 1;
                if (((uint32_t)(((int16_t)func_100(g_253.f3) + (int16_t)g_253.f0) ^ func_100(g_253.f4)) + (uint32_t)((uint16_t)(p_56 ^ (((uint16_t)((uint16_t)(func_100(g_253.f8) < ((int16_t)(-(int16_t)((int16_t)__builtin_clzll(l_267) << (int16_t)g_127.f0)) << (int16_t)2)) >> (uint16_t)2) + (uint16_t)p_59) >= g_126)) << (uint16_t)3)))
                { /* block id: 145 */
                    g_253 = g_127;
                    for (g_126 = 14; (g_126 == 5); g_126 -= 8)
                    { /* block id: 149 */
                        g_127.f6 = p_58.f7;
                    }
                    p_58 = p_58;
                    p_58.f6 = ((uint16_t)(4294967295U >= (-(uint16_t)__builtin_ctz((((uint16_t)(((int16_t)(-5) + (int16_t)(!(((((int16_t)((int16_t)0x6ACC + (int16_t)func_100((p_56 | l_267))) << (int16_t)(g_253.f1 & ((uint16_t)(-(uint32_t)1U) >> (uint16_t)l_311))) >= g_253.f7) < p_58.f0) ^ p_58.f2))) > 0x2716) << (uint16_t)p_58.f6) == p_58.f8)))) >> (uint16_t)p_58.f2);
                }
                else
                { /* block id: 154 */
                    g_127.f8 = p_58.f8;
                }
            }
            l_312 = g_208;
        }
    }
    else
    { /* block id: 160 */
        uint32_t l_313 = 6U;
        int32_t l_314 = 0x28B2EF74;
        l_266 = (l_313 && (l_314 < 4294967293U));
        g_127.f6 = 0x7C2A5B5B;
    }
    p_58.f6 = (g_253.f7 || g_253.f1);
    return p_58.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_127 g_126 g_208
 * writes: g_13 g_126 g_127
 */
static uint32_t  func_62(int32_t  p_63, int16_t  p_64, uint32_t  p_65, int32_t  p_66, int16_t  p_67)
{ /* block id: 38 */
    struct S0 l_249 = {1U,54,3,11,19901,282,7,1903,-3};
    l_249 = func_77(p_65);
    p_66 = ((uint16_t)p_66 >> (uint16_t)15);
    l_249.f2 = (g_13 && (-(int16_t)__builtin_clzl(p_66)));
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_127 g_126 g_208
 * writes: g_13 g_126 g_127
 */
static struct S0  func_77(uint32_t  p_78)
{ /* block id: 39 */
    struct S0 l_140 = {0xE999,1,0,49,21296,258,26,-613,8};
    if (p_78)
    { /* block id: 40 */
        uint32_t l_84 = 8U;
        for (g_13 = 0; (g_13 == (-5)); g_13 -= 1)
        { /* block id: 43 */
            int16_t l_143 = (-6);
            int32_t l_150 = 3;
            int32_t l_242 = 0x614CAE8D;
            l_140 = func_81(g_13, l_84);
            l_140 = g_127;
            if (((int16_t)0xAF8A << (int16_t)5))
            { /* block id: 69 */
                uint32_t l_149 = 5U;
                l_143 = p_78;
                if (p_78)
                    continue;
                g_127.f2 = g_127.f1;
                l_150 = (((int16_t)(1 || p_78) << (int16_t)4) != (g_127.f2 == (((int16_t)(0x72C9 | (0x211E331E || (!l_149))) << (int16_t)2) ^ (((0xCEA4 != 0x99C4) == l_149) & l_149))));
            }
            else
            { /* block id: 74 */
                int32_t l_151 = 1;
                uint16_t l_241 = 0x11BE;
                if (((g_127.f5 > g_13) > (((((l_151 >= p_78) != (__builtin_ctzl(l_140.f0) > ((uint16_t)l_140.f3 + (uint16_t)((int32_t)l_151 - (int32_t)((0x1938 || g_126) || l_84))))) >= 4294967295U) & 0xE51B7A5A) > l_140.f3)))
                { /* block id: 75 */
                    int16_t l_156 = (-7);
                    uint32_t l_157 = 8U;
                    if (l_156)
                        break;
                    g_127.f8 = func_90((p_78 <= p_78), g_127.f3, ((0x26DA >= 5U) && 0xB23C), func_90(l_157, ((int16_t)p_78 % (int16_t)g_127.f5), g_127.f0, p_78, p_78), p_78);
                    l_140.f7 = (g_127.f4 >= (l_156 > 6U));
                    for (l_143 = 0; (l_143 > 14); l_143 += 1)
                    { /* block id: 81 */
                        int32_t l_171 = 0x6254A217;
                        g_127.f6 = (((int16_t)((__builtin_bswap64(((uint32_t)4294967289U - (uint32_t)((uint16_t)(((int32_t)g_127.f8 % (int32_t)p_78) > (-(int16_t)func_100(p_78))) - (uint16_t)g_13))) || p_78) > (p_78 & p_78)) << (int16_t)g_127.f2) ^ 65528U);
                        l_171 = p_78;
                        g_127 = l_140;
                        l_140.f2 = ((uint32_t)l_84 - (uint32_t)func_100(p_78));
                    }
                }
                else
                { /* block id: 87 */
                    uint32_t l_207 = 0x69ADF10B;
                    struct S0 l_243 = {0x624B,150,7,72,2237,183,-23,3514,19};
                    if (__builtin_bswap32(g_127.f8))
                    { /* block id: 88 */
                        g_127.f2 = p_78;
                        if (p_78)
                            break;
                    }
                    else
                    { /* block id: 91 */
                        int32_t l_184 = (-1);
                        l_184 = (((((uint16_t)(((uint32_t)((((int16_t)(0x7F06 != ((int16_t)(p_78 | ((l_151 == 2) || p_78)) + (int16_t)l_143)) >> (int16_t)1) == (((uint16_t)g_127.f6 << (uint16_t)func_100((g_127.f2 || (0x62C939D4 ^ l_84)))) && 0)) < l_151) - (uint32_t)0xAEA757CB) >= g_127.f8) - (uint16_t)g_127.f0) <= 0x5D8EA33B) | 0) >= g_127.f5);
                        g_127.f8 = ((int32_t)((int16_t)l_151 << (int16_t)11) + (int32_t)__builtin_clzl((l_150 & ((g_127.f2 || p_78) == ((int16_t)p_78 >> (int16_t)g_127.f2)))));
                        l_140.f6 = (((uint16_t)((int32_t)((int32_t)(((func_90(g_127.f4, ((uint16_t)((int16_t)((((int16_t)((g_126 ^ (p_78 <= (((-(uint32_t)p_78) < (0x36C12986 | (((int16_t)(l_84 ^ ((~__builtin_ia32_crc32qi(l_84, l_151)) & p_78)) >> (int16_t)12) != l_184))) >= 65535U))) && 0x585B) << (int16_t)12) ^ p_78) != l_151) << (int16_t)g_127.f8) - (uint16_t)g_127.f1), g_127.f6, l_150, g_127.f0) > g_127.f0) == l_207) < g_208) + (int32_t)g_127.f2) % (int32_t)l_150) % (uint16_t)l_150) >= (-3));
                        l_140.f2 = (((uint16_t)8U + (uint16_t)((int16_t)((int16_t)((int16_t)g_127.f8 << (int16_t)2) % (int16_t)g_13) << (int16_t)func_100(l_84))) < (p_78 <= (g_127.f7 >= ((uint16_t)func_90(g_127.f8, ((uint32_t)0U + (uint32_t)0x30DA47F4), g_127.f8, l_151, p_78) >> (uint16_t)14))));
                    }
                    l_151 = ((((uint32_t)0x5E4C5809 + (uint32_t)p_78) && (g_127.f3 >= ((int16_t)g_127.f5 - (int16_t)g_127.f5))) | (g_127.f1 ^ (-1)));
                    if (func_90((((uint16_t)(((((int16_t)(((((int16_t)(0x2CBE | (((~(-(int16_t)__builtin_parity(g_127.f0))) < func_100((~p_78))) || ((int16_t)(((uint32_t)__builtin_clz(p_78) + (uint32_t)(((-(int16_t)g_208) ^ ((l_241 | (-6)) >= p_78)) <= g_127.f0)) < l_242) + (int16_t)g_208))) >> (int16_t)l_84) && l_151) ^ p_78) != p_78) - (int16_t)0x173F) == 4294967286U) && (-1)) >= p_78) % (uint16_t)0x72B1) >= 0xE2E2), p_78, g_13, p_78, l_140.f3))
                    { /* block id: 98 */
                        if (p_78)
                            break;
                        l_140.f2 = func_100(g_127.f1);
                    }
                    else
                    { /* block id: 101 */
                        return l_243;
                    }
                }
                g_127 = l_140;
            }
        }
    }
    else
    { /* block id: 108 */
        uint32_t l_244 = 4294967290U;
        struct S0 l_248 = {0x18AA,87,6,54,30880,152,-41,3181,4};
        if (((g_127.f0 || g_127.f7) && g_126))
        { /* block id: 109 */
            g_127.f7 = l_244;
            g_127 = g_127;
        }
        else
        { /* block id: 112 */
            uint16_t l_247 = 0x5336;
            for (p_78 = (-16); (p_78 >= 12); p_78 += 1)
            { /* block id: 115 */
                return g_127;
            }
            l_247 = l_140.f8;
            g_13 = (0xFDC9A4B1 & (l_244 | p_78));
            return l_248;
        }
        l_248.f2 = p_78;
    }
    return g_127;
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_127
 * writes: g_126 g_127
 */
static struct S0  func_81(uint16_t  p_82, uint32_t  p_83)
{ /* block id: 44 */
    uint32_t l_85 = 4294967295U;
    int32_t l_124 = 0xE4DFDC5D;
    struct S0 l_128 = {0xF4B6,16,7,57,15890,233,-13,3536,-2};
    l_85 = p_82;
    if ((0x1342F278 >= (((uint32_t)l_85 - (uint32_t)g_13) <= ((int16_t)func_90(((uint16_t)__builtin_popcountl(((uint16_t)func_100((~g_13)) - (uint16_t)(-9))) << (uint16_t)7), l_124, ((l_85 ^ l_124) & l_85), p_83, p_83) << (int16_t)l_85))))
    { /* block id: 56 */
        g_126 = 0x8307115A;
        g_127 = g_127;
        g_127 = l_128;
    }
    else
    { /* block id: 60 */
        g_127 = l_128;
        g_127 = g_127;
        g_127.f7 = g_127.f2;
    }
    l_128.f6 = (((uint16_t)(g_127.f1 & (((!l_128.f8) && l_85) > ((uint16_t)(65535U >= (l_128.f3 <= g_127.f5)) << (uint16_t)((uint32_t)(l_128.f7 == (__builtin_ctzl((((uint16_t)(l_128.f1 | ((((int16_t)((l_128.f2 | 0xA811) && 9U) - (int16_t)p_83) && 1) > p_82)) >> (uint16_t)7) < g_127.f8)) == p_83)) - (uint32_t)p_83)))) << (uint16_t)g_127.f2) < g_127.f1);
    return l_128;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_90(int16_t  p_91, int16_t  p_92, int16_t  p_93, int32_t  p_94, uint32_t  p_95)
{ /* block id: 53 */
    int32_t l_125 = 6;
    l_125 = p_95;
    return l_125;
}


/* ------------------------------------------ */
/* 
 * reads : g_13
 * writes:
 */
static uint16_t  func_100(int32_t  p_101)
{ /* block id: 46 */
    int32_t l_116 = 1;
    int32_t l_123 = 7;
    for (p_101 = (-29); (p_101 <= 18); p_101 += 5)
    { /* block id: 49 */
        uint32_t l_107 = 5U;
        l_123 = ((uint16_t)(l_107 < (-3)) + (uint16_t)((uint32_t)__builtin_popcountl((p_101 <= ((((uint16_t)((uint16_t)p_101 << (uint16_t)9) % (uint16_t)((int32_t)(l_116 >= ((uint16_t)l_107 - (uint16_t)((-(int16_t)((int16_t)(g_13 >= ((~((g_13 & (((l_116 & g_13) && 1U) <= 0x772B8ADF)) && l_116)) != l_116)) >> (int16_t)l_116)) & g_13))) % (int32_t)0xB137123A)) && g_13) ^ l_116))) % (uint32_t)g_13));
    }
    return p_101;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_13, "g_13", print_hash_value);
    transparent_crc(g_126, "g_126", print_hash_value);
    transparent_crc(g_127.f0, "g_127.f0", print_hash_value);
    transparent_crc(g_127.f1, "g_127.f1", print_hash_value);
    transparent_crc(g_127.f2, "g_127.f2", print_hash_value);
    transparent_crc(g_127.f3, "g_127.f3", print_hash_value);
    transparent_crc(g_127.f4, "g_127.f4", print_hash_value);
    transparent_crc(g_127.f5, "g_127.f5", print_hash_value);
    transparent_crc(g_127.f6, "g_127.f6", print_hash_value);
    transparent_crc(g_127.f7, "g_127.f7", print_hash_value);
    transparent_crc(g_127.f8, "g_127.f8", print_hash_value);
    transparent_crc(g_208, "g_208", print_hash_value);
    transparent_crc(g_253.f0, "g_253.f0", print_hash_value);
    transparent_crc(g_253.f1, "g_253.f1", print_hash_value);
    transparent_crc(g_253.f2, "g_253.f2", print_hash_value);
    transparent_crc(g_253.f3, "g_253.f3", print_hash_value);
    transparent_crc(g_253.f4, "g_253.f4", print_hash_value);
    transparent_crc(g_253.f5, "g_253.f5", print_hash_value);
    transparent_crc(g_253.f6, "g_253.f6", print_hash_value);
    transparent_crc(g_253.f7, "g_253.f7", print_hash_value);
    transparent_crc(g_253.f8, "g_253.f8", print_hash_value);
    transparent_crc(g_264, "g_264", print_hash_value);
    transparent_crc(g_349, "g_349", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 63
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 16
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 34
XXX times a single bitfield on RHS: 126

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 126
   depth: 2, occurrence: 25
   depth: 3, occurrence: 9
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 427
XXX times a non-volatile is write: 82
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 116
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 22
   depth: 2, occurrence: 15
   depth: 3, occurrence: 12
   depth: 4, occurrence: 16
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

