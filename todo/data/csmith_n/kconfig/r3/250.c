/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2651996264
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_30(void);
inline static int32_t * const  func_31(int32_t * const  p_32);
inline static int32_t * func_33(int32_t * p_34, int16_t  p_35, int32_t * p_36, uint32_t  p_37);
inline static int32_t * func_38(int32_t * p_39, int32_t * p_40, uint64_t  p_41, int32_t * p_42);
static int32_t  func_47(int32_t  p_48);
static const int64_t  func_50(const int32_t * p_51, uint32_t  p_52);
inline static int32_t * func_53(uint64_t  p_54, int32_t * p_55);
static int16_t  func_58(int32_t * const  p_59);
inline static int32_t * const  func_60(int32_t  p_61);
inline static uint64_t  func_69(int32_t * p_70, const int32_t  p_71, int64_t  p_72, int32_t * p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_30(void)
{ /* block id: 36 */
    int32_t l_44 = 0x8963EC58L;
    int32_t *l_43 = &l_44;
    float l_332 = 0xD.AD8558p+43;
    int32_t l_333 = 0xF0498DF5L;
    int32_t **l_387 = &l_43;
    float **l_388 = (void*)0;
    float ***l_389 = &l_388;
    float l_391 = (-0x9.Ep+1);
    uint32_t l_395 = 0xCE934E2DL;
    (*l_387) = func_31(func_33(func_38(l_43, &l_44, ((uint32_t)5UL - (uint32_t)func_47(((__builtin_ctz((*l_43)) ^ (0x1F0EF2F3L < ((__builtin_parity((*l_43)) ^ (*l_43)) == (*l_43)))) || 0xFF29C214F1636717LL))), &l_44), l_333, &l_333, l_333));
    (*l_387) = (*l_387);
    (*l_389) = l_388;
    (*l_43) = (-(float)(((((void*)0 != &l_43) >= (func_69((*l_387), func_50((*l_387), (**l_387)), ((uint64_t)(**l_387) - (uint64_t)(!((*l_43) && ((**l_387) > (*l_43))))), (*l_387)) < l_333)) >= 0x6.3p+1) >= 0xA.6ECEDAp+44));
    return l_395;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_31(int32_t * const  p_32)
{ /* block id: 230 */
    uint8_t l_371 = 0x02L;
    int32_t l_374 = (-1L);
    int32_t *l_373 = &l_374;
    int32_t **l_372 = &l_373;
    uint32_t l_381 = 18446744073709551615UL;
    float l_386 = 0xC.734024p-33;
    float *l_385 = &l_386;
    float **l_384 = &l_385;
    float ***l_383 = &l_384;
    float ****l_382 = &l_383;
    (*l_372) = func_60(((-(int16_t)(l_371 && l_371)) != (*p_32)));
    /* statement id: 231 */
    assert (l_373 == 0);
    (*p_32) = (((((uint32_t)((uint16_t)((int16_t)0L >> (int16_t)14) >> (uint16_t)3) / (uint32_t)l_381) <= 1UL) >= 18446744073709551615UL) || ((void*)0 != l_382));
    return p_32;
    /* statement id: 233 */
    //assert (func_31_rv == &l_44);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_33(int32_t * p_34, int16_t  p_35, int32_t * p_36, uint32_t  p_37)
{ /* block id: 202 */
    int32_t l_334 = 0x03AD83EAL;
    int32_t l_336 = (-1L);
    int32_t *l_335 = &l_336;
    int32_t **l_337 = &l_335;
    int32_t **l_338 = &l_335;
    float **l_339 = (void*)0;
    int64_t l_342 = 9L;
    int32_t *l_369 = &l_336;
    (*l_337) = func_53(l_334, l_335);
    /* statement id: 203 */
    assert (l_335 == 0 || l_335 == &l_336);
    (*l_337) = p_36;
    /* statement id: 204 */
    //assert (l_335 == &l_333);
    (*l_338) = func_60((**l_337));
    /* statement id: 205 */
    assert (l_335 == 0);
    if (((void*)0 == l_339))
    { /* block id: 206 */
        int64_t l_347 = 5L;
        int32_t ***l_354 = &l_338;
lbl_355:
        (*p_34) = ((uint64_t)(func_50(p_36, l_342) >= p_37) - (uint64_t)((int32_t)((uint64_t)(((__builtin_clz(l_347) >= p_35) | p_35) != 0x2DF8891E8048C251LL) % (uint64_t)p_35) % (int32_t)0x99ECD058L));
        if ((*p_36))
        { /* block id: 208 */
            if (l_342)
                goto lbl_355;
        }
        else
        { /* block id: 210 */
            int32_t *l_356 = &l_336;
            (*l_338) = l_356;
            /* statement id: 211 */
            assert (l_335 == &l_336);
        }
        /* facts after branching */
        assert (l_335 == &l_336 || l_335 == 0);
        (**l_354) = (*l_337);
        for (l_336 = 0; (l_336 <= 19); ++l_336)
        { /* block id: 216 */
            (*l_338) = (**l_354);
        }
    }
    else
    { /* block id: 219 */
        int32_t **l_359 = (void*)0;
        int32_t **l_360 = (void*)0;
        int32_t **l_361 = &l_335;
        float ****l_362 = (void*)0;
        float *** const *l_364 = (void*)0;
        float *** const **l_363 = &l_364;
        (*l_361) = func_60((*p_36));
        (*l_363) = l_362;
        (*p_34) = ((int16_t)p_37 << (int16_t)p_35);
        for (l_342 = 18; (l_342 > 10); l_342 -= 3)
        { /* block id: 225 */
            if ((*p_34))
                break;
        }
    }
    /* facts after branching */
    assert (l_335 == &l_336 || l_335 == 0);
    return p_34;
    /* statement id: 229 */
    //assert (func_33_rv == &l_44);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_38(int32_t * p_39, int32_t * p_40, uint64_t  p_41, int32_t * p_42)
{ /* block id: 192 */
    float l_329 = 0xC.DA2760p+39;
    float *l_328 = &l_329;
    int32_t l_331 = 0xE4E2F047L;
    int32_t *l_330 = &l_331;
    for (p_41 = 0; (p_41 >= 31); p_41++)
    { /* block id: 195 */
        int32_t l_325 = 0L;
        float l_327 = (-0x2.6p+1);
        float *l_326 = &l_327;
        if ((*p_42))
            break;
        (*p_40) = l_325;
        (*p_42) = ((void*)0 != l_326);
    }
    (*l_328) = 0x7.648EDAp+80;
    return p_42;
    /* statement id: 201 */
    //assert (func_38_rv == &l_44);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_47(int32_t  p_48)
{ /* block id: 37 */
    const int32_t *l_62 = (void*)0;
    int32_t l_216 = (-1L);
    const float ***l_298 = (void*)0;
    int32_t *l_319 = (void*)0;
    int32_t **l_318 = &l_319;
    if (((-(int64_t)func_50(func_53((((&p_48 == (void*)0) != func_58(func_60((l_62 == (void*)0)))) >= (l_216 > p_48)), &p_48), l_216)) < l_216))
    { /* block id: 141 */
        uint8_t l_263 = 0x9AL;
        for (p_48 = 0; (p_48 < (-22)); --p_48)
        { /* block id: 144 */
            int32_t **l_260 = (void*)0;
            int32_t *l_262 = &l_216;
            int32_t **l_261 = &l_262;
            int32_t *l_264 = (void*)0;
            (*l_261) = (void*)0;
            /* statement id: 145 */
            assert (l_262 == 0);
            l_216 = (p_48 <= (0x15C3C2E1L ^ l_263));
            l_216 = (func_58(func_60(((int16_t)((-9L) || l_216) << (int16_t)5))) <= 0xE.493D40p-24);
            if (p_48)
                continue;
        }
    }
    else
    { /* block id: 150 */
        uint32_t l_278 = 0x45E16A52L;
        int32_t *l_284 = &l_216;
        int32_t **l_283 = &l_284;
        uint32_t l_289 = 0UL;
        int32_t **l_316 = &l_284;
        for (p_48 = 24; (p_48 == 24); p_48 += 2)
        { /* block id: 153 */
            uint16_t l_269 = 65535UL;
            int32_t *l_282 = &l_216;
            int32_t **l_281 = &l_282;
            float l_304 = 0xA.06700Ep+85;
            float *l_303 = &l_304;
            int64_t l_315 = 1L;
            if (l_269)
            { /* block id: 154 */
                int32_t *l_270 = (void*)0;
                int32_t *l_271 = &l_216;
                float l_280 = (-0x4.Dp-1);
                float *l_279 = &l_280;
                (*l_271) = 0xAB9AC39EL;
                (*l_279) = (l_269 >= ((float)0x0.Dp+1 - (float)((float)(-0x5.Cp+1) / (float)((float)p_48 / (float)l_278))));
            }
            else
            { /* block id: 157 */
                uint32_t l_287 = 1UL;
                int32_t ***l_288 = &l_283;
                l_283 = l_281;
                /* statement id: 158 */
                assert (l_283 == &l_282);
                l_216 = ((int32_t)0xB852C9F5L - (int32_t)l_287);
                (**l_281) = (((&l_283 != l_288) && (__builtin_parity((***l_288)) <= l_289)) != (((((__builtin_ia32_crc32qi((***l_288), p_48) > (p_48 && p_48)) ^ 1UL) > (-1L)) != 4294967293UL) >= 18446744073709551615UL));
                if ((p_48 || (__builtin_ffsl(p_48) ^ p_48)))
                { /* block id: 161 */
                    int32_t *l_295 = &l_216;
                    if (((int16_t)(!__builtin_clzll(((&l_281 != &l_281) ^ (p_48 <= (((int16_t)func_50((**l_288), (***l_288)) >> (int16_t)5) >= __builtin_popcountl(p_48)))))) + (int16_t)0xEF02L))
                    { /* block id: 162 */
                        float l_297 = 0x0.0p-1;
                        float *l_296 = &l_297;
                        (*l_281) = l_295;
                        (*l_296) = ((**l_281) < (*l_295));
                    }
                    else
                    { /* block id: 165 */
                        return p_48;
                    }
                    if (l_269)
                        goto lbl_320;
                    (**l_288) = &l_216;
                    l_298 = l_298;
                    (*l_283) = (*l_281);
                }
                else
                { /* block id: 171 */
                    float l_301 = 0x0.7D9547p-1;
                    for (l_289 = 0; (l_289 > 19); l_289 += 6)
                    { /* block id: 174 */
                        int16_t l_302 = 0xEB42L;
                        if ((***l_288))
                            break;
                        return l_302;
                    }
                }
            }
            /* facts after branching */
            //assert (l_283 == &l_282 || l_283 == dangling || l_283 == &l_284);
            (*l_303) = (&l_284 == &l_282);
        }
        /* facts after for loop */
        //assert (l_283 == dangling || l_283 == &l_284);
        (*l_316) = &p_48;
        /* statement id: 183 */
        assert (l_284 == &p_48);
        (*l_284) = (-(int64_t)__builtin_parity((l_62 != (void*)0)));
        (*l_316) = (*l_316);
    }
lbl_320:
    (*l_318) = &p_48;
    /* statement id: 187 */
    assert (l_319 == &p_48);
    (*l_318) = (*l_318);
    p_48 = ((uint32_t)((void*)0 != &l_319) + (uint32_t)1L);
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_50(const int32_t * p_51, uint32_t  p_52)
{ /* block id: 130 */
    int64_t l_239 = 0x5BDD16FCC1B0773BLL;
    int32_t l_245 = 0L;
    int32_t * const l_244 = &l_245;
    const int32_t **l_253 = (void*)0;
    int32_t *l_256 = (void*)0;
    uint64_t l_257 = 0x2D1DD9B939D7BC26LL;
    if (p_52)
    { /* block id: 131 */
        int32_t l_241 = 0L;
        int32_t *l_240 = &l_241;
        float l_249 = 0x9.2465FAp+38;
        float *l_248 = &l_249;
        (*l_240) = l_239;
        (*l_244) = (p_52 | (((uint16_t)((void*)0 != &p_51) << (uint16_t)0) >= (0x079EL < func_58(l_244))));
        (*l_248) = ((float)((p_52 >= p_52) >= ((*l_240) >= p_52)) + (float)(*l_240));
    }
    else
    { /* block id: 135 */
        int32_t **l_250 = (void*)0;
        int32_t *l_252 = &l_245;
        int32_t **l_251 = &l_252;
        (*l_251) = &l_245;
    }
    (*l_244) = p_52;
    l_257 = (*l_244);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_53(uint64_t  p_54, int32_t * p_55)
{ /* block id: 105 */
    float *l_223 = (void*)0;
    int32_t l_228 = 2L;
    for (p_54 = 14; (p_54 >= 9); p_54--)
    { /* block id: 108 */
        int32_t l_220 = (-6L);
        int32_t *l_219 = &l_220;
        (*p_55) = 0xB798DF4DL;
        return p_55;
        /* statement id: 110 */
        //assert (func_53_rv == &p_48 || func_53_rv == &l_245 || func_53_rv == &l_336);
    }
    if (((int64_t)(p_55 == l_223) + (int64_t)(((p_54 || ((l_223 == l_223) || (l_223 != (void*)0))) | (p_55 == (void*)0)) < p_54)))
    { /* block id: 112 */
        return l_223;
        /* statement id: 113 */
        //assert (func_53_rv == 0);
    }
    else
    { /* block id: 114 */
        int32_t *l_233 = (void*)0;
        int32_t **l_232 = &l_233;
        for (p_54 = 0; (p_54 >= 28); p_54++)
        { /* block id: 117 */
            int32_t **l_229 = (void*)0;
            int32_t *l_231 = &l_228;
            int32_t **l_230 = &l_231;
            (*l_230) = func_60((__builtin_popcount(p_54) > (l_228 | (0x0DBE1DBCL != (*p_55)))));
            /* statement id: 118 */
            assert (l_231 == 0);
        }
        (*l_232) = p_55;
        /* statement id: 120 */
        //assert (l_233 == &p_48 || l_233 == &l_245 || l_233 == &l_336);
    }
    for (l_228 = 0; (l_228 != 21); l_228++)
    { /* block id: 124 */
        float **l_237 = &l_223;
        float ***l_236 = &l_237;
        int32_t *l_238 = &l_228;
        (*p_55) = (*p_55);
        (*l_236) = &l_223;
        return p_55;
        /* statement id: 127 */
        //assert (func_53_rv == &p_48 || func_53_rv == &l_245 || func_53_rv == &l_336);
    }
    return p_55;
    /* statement id: 129 */
    //assert (func_53_rv == &p_48 || func_53_rv == &l_245 || func_53_rv == &l_336);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_58(int32_t * const  p_59)
{ /* block id: 92 */
    float *l_201 = (void*)0;
    float **l_200 = &l_201;
    int32_t l_202 = 0xD4B5287AL;
    l_200 = l_200;
    for (l_202 = 0; (l_202 >= (-27)); l_202 -= 8)
    { /* block id: 96 */
        int32_t l_205 = (-4L);
        for (l_205 = 9; (l_205 >= (-25)); --l_205)
        { /* block id: 99 */
            int32_t l_215 = 0x0BABF467L;
            int32_t *l_214 = &l_215;
            (*l_214) = ((int32_t)((uint16_t)l_205 >> (uint16_t)((int16_t)l_205 >> (int16_t)13)) / (int32_t)0xA5BA27C4L);
            if (l_205)
                break;
        }
    }
    return l_202;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_60(int32_t  p_61)
{ /* block id: 38 */
    int32_t l_66 = (-10L);
    int32_t *l_65 = &l_66;
    float l_148 = 0x3.492987p+20;
    uint32_t l_149 = 0xFC9F35A7L;
    int32_t * const l_161 = &l_66;
    int32_t * const l_187 = &l_66;
    int32_t * const l_188 = &l_66;
    int32_t * const l_189 = &l_66;
    int32_t * const l_190 = &l_66;
    int32_t * const l_191 = &l_66;
    int32_t * const l_192 = &l_66;
    int32_t * const l_193 = &l_66;
    int32_t * const l_194 = &l_66;
    int32_t * const l_195 = &l_66;
    int32_t * const l_196 = &l_66;
    int32_t * const l_197 = &l_66;
    int32_t * const l_198 = &l_66;
    int32_t * const l_199 = (void*)0;
    if (((int16_t)0x20C3L / (int16_t)(p_61 || ((void*)0 != l_65))))
    { /* block id: 39 */
        int32_t *l_74 = &l_66;
        int32_t *l_75 = &l_66;
        uint32_t l_128 = 7UL;
        (*l_75) = ((((uint64_t)func_69(l_74, p_61, p_61, l_75) / (uint64_t)((int16_t)l_128 << (int16_t)5)) <= l_128) == 0x4DBBL);
    }
    else
    { /* block id: 69 */
        uint16_t l_147 = 0xA371L;
        int32_t *l_150 = &l_66;
        uint64_t l_152 = 0x121EC5D866FAEDDALL;
        int32_t **l_154 = (void*)0;
        int32_t ***l_153 = &l_154;
        int32_t * const l_159 = &l_66;
        const int64_t l_173 = (-1L);
        int32_t * const l_176 = (void*)0;
        const int16_t l_181 = 0x23FBL;
        if (((int16_t)p_61 - (int16_t)__builtin_parity(((int64_t)((uint64_t)((int16_t)(0xC7DF6318L >= ((((uint32_t)(((p_61 == ((int32_t)(*l_65) % (int32_t)((((uint32_t)(__builtin_popcountll(((uint16_t)((0L != (((int16_t)__builtin_popcountll(l_147) - (int16_t)0x7CD1L) < (p_61 || p_61))) == 0UL) << (uint16_t)11)) | l_147) + (uint32_t)l_147) != p_61) && 1UL))) >= 0L) || l_147) / (uint32_t)l_147) > 7L) | p_61)) << (int16_t)p_61) - (uint64_t)0xBDDE1E780F4AA1FFLL) - (int64_t)p_61))))
        { /* block id: 70 */
            int32_t * const l_157 = &l_66;
            int32_t * const l_158 = &l_66;
            float *l_163 = &l_148;
            int32_t *l_168 = (void*)0;
            if (((p_61 >= l_149) && 18446744073709551607UL))
            { /* block id: 71 */
                int32_t **l_151 = &l_65;
                (*l_151) = l_150;
                (*l_151) = &p_61;
                /* statement id: 73 */
                assert (l_65 == &p_61);
                (*l_65) = p_61;
            }
            else
            { /* block id: 75 */
                int16_t l_155 = (-3L);
                int32_t * const l_156 = &l_66;
                int32_t * const l_160 = &l_66;
                int32_t * const l_162 = (void*)0;
                l_155 = (l_152 <= ((void*)0 == l_153));
                (*l_65) = p_61;
                return l_162;
                /* statement id: 78 */
                //assert (func_60_rv == 0);
            }
            /* facts after branching */
            assert (l_65 == &p_61);
            (*l_163) = (*l_65);
            (*l_163) = (0x1.3A172Fp-2 == ((((float)p_61 / (float)p_61) != __builtin_clz((*l_158))) > ((((float)((void*)0 != l_168) - (float)((float)(*l_157) + (float)((float)(*l_159) + (float)l_173))) <= p_61) == p_61)));
            l_168 = (void*)0;
        }
        else
        { /* block id: 83 */
            int32_t * const l_174 = &l_66;
            int32_t * const l_175 = &l_66;
            (*l_65) = p_61;
            return l_176;
            /* statement id: 85 */
            //assert (func_60_rv == 0);
        }
        /* facts after branching */
        assert (l_65 == &p_61);
        (*l_65) = (((float)p_61 + (float)func_69(&l_66, (0xCEA4L & ((uint16_t)__builtin_ffsll((*l_161)) + (uint16_t)(l_181 < ((*l_150) | ((*l_65) && (((int32_t)(&l_66 == &l_66) / (int32_t)p_61) <= p_61)))))), p_61, &l_66)) > p_61);
        p_61 = (*l_65);
    }
    /* facts after branching */
    assert (l_65 == &p_61 || l_65 == &l_66);
    (*l_161) = (((uint32_t)(func_69(&l_66, (*l_161), (*l_161), &l_66) >= p_61) / (uint32_t)p_61) | ((~0x01D1870374A045A3LL) != p_61));
    return l_199;
    /* statement id: 91 */
    //assert (func_60_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_69(int32_t * p_70, const int32_t  p_71, int64_t  p_72, int32_t * p_73)
{ /* block id: 40 */
    uint32_t l_76 = 1UL;
    float l_78 = 0x7.4F9898p+87;
    float *l_77 = &l_78;
    int32_t l_83 = 7L;
    int32_t *l_82 = &l_83;
    int32_t **l_81 = &l_82;
    int64_t l_108 = 0L;
    (*l_77) = l_76;
    (*p_70) = ((int32_t)l_76 - (int32_t)l_76);
    (*l_81) = p_73;
    /* statement id: 43 */
    //assert (l_82 == &l_66 || l_82 == &l_216 || l_82 == &l_44);
    if ((*p_70))
    { /* block id: 44 */
        int64_t l_98 = 0x1A0E57C1F20CF680LL;
        int16_t l_99 = 1L;
        (*l_81) = p_70;
        (*l_82) = ((int16_t)((uint16_t)(**l_81) >> (uint16_t)1) >> (int16_t)((int32_t)((uint32_t)((uint32_t)((int16_t)((uint16_t)65528UL >> (uint16_t)p_72) >> (int16_t)14) % (uint32_t)4294967295UL) - (uint32_t)(l_98 > ((0xE6AFL <= ((((l_98 | ((l_99 != (p_73 != p_73)) ^ (*l_82))) <= p_71) | p_71) & p_72)) != l_99))) / (int32_t)(*p_73)));
        (*l_82) = (*l_82);
    }
    else
    { /* block id: 48 */
        float l_105 = 0xB.7C8A60p+55;
        int32_t l_106 = 0x2A19D8D7L;
        int32_t **l_122 = (void*)0;
        (*l_82) = (((void*)0 != &l_82) & __builtin_parity(((int32_t)(((uint16_t)(!(l_106 || ((-(uint32_t)l_108) || l_106))) << (uint16_t)__builtin_popcount((p_71 ^ __builtin_ffsll((((int64_t)(__builtin_ctzl(((uint16_t)(l_106 || 7L) >> (uint16_t)((int16_t)(((int16_t)1L % (int16_t)p_72) >= 5UL) >> (int16_t)5))) >= l_106) + (int64_t)p_72) && 0x93872454177E56D7LL))))) || 0x0717L) - (int32_t)(*p_73))));
        (**l_81) = ((void*)0 == &l_106);
        for (l_106 = 0; (l_106 > (-17)); l_106--)
        { /* block id: 53 */
            int32_t *l_119 = (void*)0;
        }
    }
    return (**l_81);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 103
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 22
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 124

XXX times a variable address is taken: 115
XXX times a pointer is dereferenced on RHS: 73
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 13
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 69
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 259

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 220
   level: 2, occurrence: 45
   level: 3, occurrence: 12
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 83
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29
XXX average alias set size: 1.25

XXX times a non-volatile is read: 420
XXX times a non-volatile is write: 165
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 121
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 40
   depth: 1, occurrence: 39
   depth: 2, occurrence: 19
   depth: 3, occurrence: 12
   depth: 4, occurrence: 6
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 11.6
XXX percentage an existing variable is used: 88.4
********************* end of statistics **********************/

