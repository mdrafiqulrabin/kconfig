/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3211110728
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 18;
   unsigned f1 : 31;
   unsigned f2 : 5;
};

union U1 {
   signed f0 : 14;
   uint16_t  f1;
   uint16_t  f2;
   uint16_t  f3;
   uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U1  func_31(void);
static int16_t  func_33(uint16_t  p_34, union U1  p_35);
static union U1  func_37(uint32_t  p_38, struct S0  p_39, struct S0  p_40, int16_t  p_41);
inline static int16_t  func_54(uint16_t  p_55, uint32_t  p_56, uint32_t  p_57);
static uint16_t  func_65(uint16_t  p_66);
inline static uint16_t  func_73(union U1  p_74, union U1  p_75, int32_t  p_76, uint16_t  p_77);
static union U1  func_78(uint16_t  p_79, int16_t  p_80, uint32_t  p_81, uint16_t  p_82, uint32_t  p_83);
static int32_t  func_86(struct S0  p_87, int16_t  p_88, int32_t  p_89, int32_t  p_90);
static struct S0  func_91(uint32_t  p_92, struct S0  p_93);
inline static struct S0  func_97(union U1  p_98, uint16_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_31(void)
{ /* block id: 36 */
    int32_t l_36 = 0xE495761B;
    struct S0 l_42 = {381,33814,4};
    struct S0 l_43 = {469,45526,1};
    uint32_t l_58 = 0xA8DAD4F6;
    int32_t l_230 = 0x2973F10C;
    union U1 l_231 = {0xEF385434};
    int32_t l_246 = 1;
    uint32_t l_253 = 0x7C5E2B0F;
    union U1 l_263 = {0x0061F076};
    uint32_t l_299 = 0xE3334AD1;
    uint32_t l_300 = 0x358AB34E;
    int32_t l_301 = 0x2EBCB51D;
    int32_t l_302 = 0x81BD6ACC;
    if ((-(uint16_t)(func_33(l_36, func_37(((l_36 ^ l_36) , l_36), l_42, (l_43 = l_42), ((uint16_t)((uint32_t)((int16_t)((int16_t)(l_42 , ((uint16_t)65535U % (uint16_t)func_54(l_42.f0, l_58, l_58))) << (int16_t)l_42.f2) - (int16_t)1) - (uint32_t)l_42.f1) << (uint16_t)l_42.f2))) , 1U)))
    { /* block id: 124 */
        int16_t l_222 = 2;
        int32_t l_223 = 0xA5FCD0D6;
        int32_t l_224 = 0;
        int32_t l_238 = (-9);
        int16_t l_245 = 0x45D7;
        union U1 l_256 = {0x5E5902A9};
        l_224 = (l_223 = l_222);
        for (l_36 = 0; (l_36 > (-9)); l_36 -= 8)
        { /* block id: 129 */
            uint32_t l_229 = 8U;
            int32_t l_234 = 0x57787EE9;
            int32_t l_237 = 0;
            int32_t l_241 = 1;
            int32_t l_247 = 0;
            l_230 = ((int16_t)l_224 % (int16_t)__builtin_ffsl(l_229));
            l_223 = ((l_231 , (l_231.f0 |= (l_238 ^= ((l_229 & (l_42.f2 > (l_234 ^= (l_229 | (0x9F614CAE || 1))))) != (0U > (((0x8493 & (l_237 = (((int16_t)(4294967295U != l_224) % (int16_t)l_223) == l_229))) && 65535U) > l_229)))))) > 0x1C2EB0A1);
            l_230 = (((uint16_t)(l_237 |= l_224) + (uint16_t)(func_78(l_234, __builtin_ctzl(((l_241 >= (((uint16_t)(-(int32_t)8) >> (uint16_t)13) == func_65(l_245))) , (func_78(l_246, l_246, (l_223 |= (l_247 ^= ((l_229 < 0xAA52) ^ l_241))), l_224, l_58) , 9U))), l_222, l_234, l_234) , l_238)) == 1);
        }
        l_253 &= (((int16_t)0xFDDB * (int16_t)((((-(uint32_t)(((__builtin_clzll(l_245) ^ 0) , l_58) == (1U >= 0x5321BD9B))) & (l_245 || __builtin_ctzll(l_230))) & l_42.f0) >= l_223)) | l_223);
        l_230 = ((int16_t)__builtin_bswap32(((func_97(l_256, l_43.f0) , l_256.f0) >= 0x4755)) % (int16_t)((int16_t)((((int32_t)(((l_224 = ((int16_t)0x1B5F >> (int16_t)func_73((l_231 = func_37(l_256.f0, l_43, l_43, l_256.f0)), l_263, l_43.f0, l_245))) & 0x11FA8A99) && l_256.f0) + (int32_t)l_43.f1) == l_43.f0) < l_238) << (int16_t)6));
    }
    else
    { /* block id: 145 */
        int32_t l_266 = (-1);
        int32_t l_270 = (-1);
        uint16_t l_271 = 0U;
        for (l_263.f3 = 0; (l_263.f3 <= 33); l_263.f3 += 5)
        { /* block id: 148 */
            uint32_t l_269 = 0x4ED68EFF;
            l_231.f0 = __builtin_parityll(l_266);
            l_270 ^= ((uint16_t)__builtin_ctz(l_269) % (uint16_t)l_269);
            if (l_271)
                break;
        }
    }
    l_301 = ((uint16_t)func_65(((int16_t)(l_302 |= (((int16_t)l_231.f0 >> (int16_t)((uint16_t)l_42.f0 * (uint16_t)((int32_t)((((int16_t)l_246 << (int16_t)3) > (((int32_t)(((4294967294U ^ l_42.f0) | ((uint32_t)l_42.f2 + (uint32_t)l_36)) ^ (((((int16_t)(((uint16_t)l_42.f2 * (uint16_t)(l_263.f0 = (l_300 = (-(int16_t)((int16_t)((int16_t)(((((((uint32_t)(l_230 &= ((0xFF0B & 0x3F61) || l_42.f2)) - (uint32_t)1) | l_246) || l_246) ^ 65528U) > 0xC562) & l_299) << (int16_t)l_36) >> (int16_t)15))))) < l_43.f2) - (int16_t)7U) < 4U) || l_300) < l_246)) % (int32_t)l_299) || l_42.f1)) >= l_299) - (int32_t)4294967295U))) | l_301)) >> (int16_t)l_253)) - (uint16_t)0x8891);
    return l_263;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_33(uint16_t  p_34, union U1  p_35)
{ /* block id: 110 */
    uint32_t l_212 = 0x95207075;
    int32_t l_216 = 0x65FA9602;
    uint16_t l_217 = 2U;
    int32_t l_218 = 0x33B8ED1E;
    int32_t l_219 = (-1);
    for (p_35.f4 = 0; (p_35.f4 != 37); p_35.f4 += 1)
    { /* block id: 113 */
        int32_t l_209 = 0x369ADF10;
        struct S0 l_213 = {481,17717,3};
        l_219 = (l_218 = ((((uint16_t)(((l_209 | (((int16_t)__builtin_parity(p_35.f0) >> (int16_t)(l_209 | ((l_212 < l_212) , l_212))) & ((l_216 = (l_213 , ((uint16_t)l_213.f1 - (uint16_t)p_35.f1))) ^ l_217))) | l_209) < 4U) + (uint16_t)p_35.f3) & 0x1FC436A3) > p_35.f4));
        l_218 |= p_35.f4;
    }
    p_35.f0 = l_219;
    l_216 |= (((uint16_t)p_35.f0 * (uint16_t)(p_34 ^= l_218)) ^ l_219);
    l_218 |= ((p_34 ^ p_34) <= ((0xAD3D & 0xBB9B) , (4U <= p_35.f0)));
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_37(uint32_t  p_38, struct S0  p_39, struct S0  p_40, int16_t  p_41)
{ /* block id: 105 */
    int32_t l_197 = 1;
    int32_t l_198 = 0x6AC0F502;
    int32_t l_203 = 0xA571D432;
    union U1 l_204 = {0x1A7DC5F5};
    l_203 = ((((uint32_t)(((l_197 > ((((l_198 = 3) >= ((int32_t)p_40.f2 + (int32_t)l_197)) <= ((uint32_t)(l_197 ^ 0xD573) - (uint32_t)(0x802A ^ l_197))) >= l_197)) != 65529U) < 0x9863) % (uint32_t)l_197) <= 0xB0101A31) != p_39.f1);
    l_203 &= 6;
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_54(uint16_t  p_55, uint32_t  p_56, uint32_t  p_57)
{ /* block id: 38 */
    uint32_t l_64 = 1U;
    struct S0 l_94 = {342,24214,2};
    union U1 l_167 = {0xD1870374};
    int32_t l_177 = 0;
    uint32_t l_186 = 0xC82D1F4F;
    union U1 l_187 = {0};
    int32_t l_194 = 1;
    l_177 &= (~(l_167.f0 = ((uint16_t)(((int16_t)9 + (int16_t)(l_64 != __builtin_ctz(((((func_65((((((uint32_t)p_56 + (uint32_t)(((((uint16_t)((l_64 , l_64) & (0xA600 || ((uint16_t)func_73(func_78(l_64, p_55, ((int32_t)func_86(func_91((p_57 != 0xE1D86E6A), l_94), l_94.f1, l_64, l_94.f1) - (int32_t)l_94.f2), l_94.f0, l_94.f2), l_167, l_94.f0, p_55) * (uint16_t)p_56))) * (uint16_t)p_56) & l_167.f0) != p_56) & 0xDA79)) != (-1)) & l_94.f1) | l_167.f0)) ^ p_57) && l_94.f1) == 0) != 0x0105)))) || (-4)) >> (uint16_t)5)));
    l_177 = ((l_187 = func_78(((((((uint16_t)(l_64 != ((uint16_t)(func_91((((l_167 = l_167) , 65535U) , (l_94.f0 & p_55)), l_94) , ((int32_t)((uint32_t)0x999F76DD + (uint32_t)l_94.f0) - (int32_t)0xF7AEC48A)) - (uint16_t)p_55)) * (uint16_t)l_177) & p_56) && p_56) || 0) || l_177), p_55, l_186, l_94.f0, l_186)) , l_186);
    l_187.f0 = p_55;
    l_94 = func_91(((((uint16_t)((int32_t)p_56 % (int32_t)((l_167.f0 , (p_55 > (l_64 >= l_94.f2))) | ((uint16_t)func_86(l_94, l_194, p_55, p_56) * (uint16_t)l_187.f0))) * (uint16_t)l_194) > 0xEAB9BFD8) , l_186), l_94);
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_65(uint16_t  p_66)
{ /* block id: 93 */
    uint32_t l_174 = 4294967291U;
    struct S0 l_175 = {341,19448,3};
    int32_t l_176 = 1;
    l_176 = (-(int32_t)((p_66 > (((uint16_t)p_66 + (uint16_t)((uint16_t)0x4148 * (uint16_t)(p_66 , (!l_174)))) > (l_174 | (func_86(l_175, l_175.f2, (l_175 , p_66), p_66) < p_66)))) , p_66));
    l_176 &= l_175.f1;
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_73(union U1  p_74, union U1  p_75, int32_t  p_76, uint16_t  p_77)
{ /* block id: 91 */
    return p_75.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_78(uint16_t  p_79, int16_t  p_80, uint32_t  p_81, uint16_t  p_82, uint32_t  p_83)
{ /* block id: 78 */
    int32_t l_151 = (-1);
    int32_t l_158 = 1;
    struct S0 l_163 = {128,3408,1};
    union U1 l_166 = {0xD9F3E276};
    for (p_79 = 8; (p_79 != 57); p_79 += 7)
    { /* block id: 81 */
        uint32_t l_157 = 0x1E6C26E6;
        int32_t l_161 = 1;
        struct S0 l_162 = {303,46210,1};
        l_151 |= 0x73671048;
        l_151 = (~((-6) & (((uint32_t)((uint32_t)p_81 - (uint32_t)(func_86(((((((0xB8F49FF7 <= 0x97804E31) == l_157) | (p_82 = ((-1) == ((l_158 > (((int16_t)p_82 - (int16_t)(l_161 = p_82)) > 0x9999)) || 0)))) ^ p_79) | p_79) , l_162), l_158, p_83, l_158) > 1U)) % (uint32_t)l_157) != l_157)));
        if (p_79)
            continue;
    }
    l_158 = __builtin_popcountl((l_163 , ((int16_t)p_79 + (int16_t)p_80)));
    l_151 ^= p_80;
    return l_166;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_86(struct S0  p_87, int16_t  p_88, int32_t  p_89, int32_t  p_90)
{ /* block id: 47 */
    int16_t l_103 = (-3);
    int32_t l_104 = (-1);
    struct S0 l_105 = {95,16246,3};
    struct S0 l_106 = {200,38713,3};
    uint32_t l_116 = 0xB4F91071;
    union U1 l_141 = {-1};
    l_104 = l_103;
    l_106 = (p_87 = (l_105 = p_87));
    if ((p_87.f2 && ((uint32_t)(((p_89 ^ (-(uint32_t)p_89)) , 0x2E64) & (((int16_t)((int16_t)(((int16_t)l_106.f2 << (int16_t)9) >= l_105.f1) * (int16_t)((((0x38724541 | l_116) > ((int16_t)(((0xCBA4 || 0x7955) == l_105.f0) || p_87.f2) << (int16_t)0)) , p_87.f1) != 0xF13354A9)) >> (int16_t)l_104) , l_106.f1)) + (uint32_t)0xC7D6112D)))
    { /* block id: 52 */
        int16_t l_121 = 0xDFEA;
        int32_t l_133 = 0x18324626;
        if (((p_89 ^ ((((int16_t)(p_90 ^ (l_103 & ((l_105.f1 && l_105.f1) >= __builtin_parityll((l_104 = (l_121 > ((uint16_t)((int16_t)(((uint32_t)(((uint16_t)l_121 >> (uint16_t)p_89) >= (l_121 && l_121)) + (uint32_t)8) ^ p_87.f1) * (int16_t)l_105.f2) * (uint16_t)p_87.f2))))))) >> (int16_t)1) && 0xBB0DECA3) | p_88)) , l_106.f1))
        { /* block id: 54 */
            uint32_t l_130 = 0x822E8431;
            l_130 &= l_105.f0;
            if (l_130)
            { /* block id: 56 */
                for (p_89 = 0; (p_89 > (-21)); p_89 -= 1)
                { /* block id: 59 */
                    p_90 = 6;
                }
            }
            else
            { /* block id: 62 */
                return p_88;
            }
            p_90 = l_105.f2;
        }
        else
        { /* block id: 66 */
            return p_87.f0;
        }
        l_133 = p_89;
    }
    else
    { /* block id: 70 */
        union U1 l_138 = {0x49B816A8};
        struct S0 l_148 = {425,6495,2};
        l_138.f0 = ((int16_t)((int32_t)l_106.f0 + (int32_t)(l_138 , (l_103 > l_138.f0))) + (int16_t)((int16_t)(l_141 , (p_87.f0 && (__builtin_bswap64(l_138.f0) , ((l_105.f0 | 0) <= p_88)))) >> (int16_t)p_87.f0));
        l_138.f0 = (((((uint16_t)((int32_t)(l_141 , ((__builtin_ctzl(p_88) < (l_105.f2 ^ ((int16_t)(l_138.f0 ^ p_88) >> (int16_t)15))) & l_141.f0)) % (int32_t)((l_138 , (l_106 = l_148)) , p_89)) - (uint16_t)0x82FD) <= l_104) > 0) | l_148.f0);
        p_90 = (0 < ((l_105.f0 , p_87.f0) || __builtin_ffsll((l_104 = (-1)))));
    }
    return p_87.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_91(uint32_t  p_92, struct S0  p_93)
{ /* block id: 39 */
    uint32_t l_95 = 0x5039A247;
    int32_t l_96 = 0xC53D1739;
    union U1 l_100 = {5};
    uint16_t l_101 = 65535U;
    l_96 = l_95;
    p_93 = func_97(l_100, (l_96 |= l_101));
    return p_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_97(union U1  p_98, uint16_t  p_99)
{ /* block id: 42 */
    struct S0 l_102 = {208,32512,0};
    l_102 = l_102;
    return l_102;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 72
   depth: 1, occurrence: 11
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 21
XXX full-bitfields structs in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 32
XXX times a single bitfield on LHS: 8
XXX times a single bitfield on RHS: 76

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 6, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 37, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 292
XXX times a non-volatile is write: 73
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 61
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 15
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 23.2
XXX percentage an existing variable is used: 76.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

