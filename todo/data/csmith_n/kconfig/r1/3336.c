/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2546319320
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
   signed f1 : 7;
   signed f2 : 13;
   signed f3 : 5;
   signed : 0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static const int32_t * func_5(int32_t * p_6, uint32_t  p_7);
static int16_t  func_9(int16_t  p_10, uint8_t  p_11, int32_t * p_12, int32_t  p_13, int32_t * p_14);
static int16_t  func_15(int32_t * p_16, uint8_t  p_17, int8_t  p_18, int32_t * p_19, int32_t * p_20);
inline static int32_t * func_21(struct S0  p_22, int8_t  p_23, uint32_t  p_24);
inline static struct S0  func_25(int32_t  p_26, uint32_t  p_27, int32_t * p_28, uint32_t  p_29, uint32_t  p_30);
inline static int32_t * func_31(int32_t  p_32, uint32_t  p_33, uint8_t  p_34, int32_t  p_35);
static int32_t  func_36(uint16_t  p_37);
static int32_t * func_43(int32_t * const  p_44);
inline static int32_t * const  func_45(uint32_t  p_46);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x070ADE21;
    struct S0 *** const *l_1569 = (void*)0;
    int32_t *****l_1570 = (void*)0;
    int32_t l_1573 = 0x5228773F;
    const uint32_t l_1576 = 0xA33A8F43;
    int32_t *l_1579 = &l_1573;
    struct S0 l_1581 = {-888,1,82,2};
    struct S0 *l_1580 = &l_1581;
    struct S0 **l_1582 = (void*)0;
    struct S0 **l_1583 = &l_1580;
    int32_t l_1584 = 0x9701B8A0;
    for (l_2 = (-7); (l_2 == 1); ++l_2)
    { /* block id: 3 */
        int32_t *l_8 = &l_2;
        uint32_t l_1447 = 0x08455B52;
        int32_t *l_1463 = (void*)0;
        int32_t **l_1563 = &l_1463;
        const struct S0 l_1564 = {5440,-7,-20,-2};
        struct S0 l_1566 = {-948,-4,-64,-4};
        struct S0 *l_1565 = &l_1566;
        struct S0 ***l_1568 = (void*)0;
        struct S0 ****l_1567 = &l_1568;
        int32_t ***l_1575 = &l_1563;
        int32_t ****l_1574 = &l_1575;
        (*l_1563) = func_5(l_8, (func_9((func_15(func_21(func_25(l_2, l_2, func_31(l_2, l_2, (*l_8), (*l_8)), l_2, (*l_8)), (*l_8), l_2), l_1447, l_2, &l_2, l_8) < 0), (*l_8), l_8, l_2, l_1463) < 0xD034));
        /* statement id: 686 */
        assert (l_1463 == &l_2);
        (*l_1565) = l_1564;
        l_1573 = (((*l_1463) != (((l_1567 != l_1569) < 0x3A) < (255U ^ ((void*)0 != l_1570)))) && ((*l_8) ^ (safe_mod_func_int32_t_s_s((-1), (*l_1463)))));
        (*l_1565) = func_25(((void*)0 != &l_1567), (l_1574 == (void*)0), (***l_1574), ((((((&l_1569 != (void*)0) | l_1576) ^ (safe_sub_func_int8_t_s_s(l_1576, (*l_8)))) ^ (**l_1563)) & (****l_1574)) | 0U), l_1573);
    }
    (*l_1579) = (l_1576 != (l_1576 || l_1576));
    (*l_1583) = l_1580;
    return l_1584;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_5(int32_t * p_6, uint32_t  p_7)
{ /* block id: 675 */
    uint32_t l_1539 = 0xDBC7D83D;
    int32_t l_1547 = 0;
    int32_t *l_1546 = &l_1547;
    int32_t **l_1545 = &l_1546;
    int32_t *** const l_1544 = &l_1545;
    int32_t *** const * const l_1543 = &l_1544;
    struct S0 l_1552 = {-5836,4,-79,-1};
    uint8_t l_1562 = 0xAA;
    for (p_7 = 7; (p_7 <= 45); ++p_7)
    { /* block id: 678 */
        uint16_t l_1538 = 0x66F5;
        int32_t l_1541 = (-4);
        int32_t *l_1540 = &l_1541;
        int32_t ** const * const *l_1542 = (void*)0;
        l_1552 = func_25(l_1538, l_1539, l_1540, (*l_1540), (((p_7 == (l_1542 != l_1543)) && (safe_rshift_func_int16_t_s_u((1U != (safe_rshift_func_int16_t_s_u(((0x1542 <= 0xC5D6) & 65532U), p_7))), 9))) >= p_7));
    }
    (**l_1544) = func_43((**l_1544));
    /* statement id: 683 */
    assert (l_1546 == 0);
    l_1552.f0 = l_1562;
    return p_6;
    /* statement id: 685 */
    //assert (func_5_rv == &l_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_9(int16_t  p_10, uint8_t  p_11, int32_t * p_12, int32_t  p_13, int32_t * p_14)
{ /* block id: 652 */
    struct S0 l_1468 = {-6412,0,5,-3};
    struct S0 *l_1467 = &l_1468;
    struct S0 **l_1466 = &l_1467;
    struct S0 ***l_1465 = &l_1466;
    struct S0 ****l_1464 = &l_1465;
    uint32_t l_1485 = 0xFDE1F9FB;
    int32_t l_1533 = 0x273DEE2F;
    int32_t *l_1532 = &l_1533;
    struct S0 *l_1534 = &l_1468;
    int32_t **l_1535 = &l_1532;
    if ((0U ^ ((void*)0 == l_1464)))
    { /* block id: 653 */
        struct S0 **l_1469 = &l_1467;
        int32_t l_1486 = 0x1B94DAE5;
        struct S0 *** const *l_1511 = (void*)0;
        struct S0 *** const * const *l_1510 = &l_1511;
        const uint32_t l_1512 = 0xCD00665D;
        int32_t *l_1518 = &l_1486;
        (*l_1465) = l_1469;
        for (p_13 = (-4); (p_13 >= 26); p_13 = safe_add_func_int32_t_s_s(p_13, 9))
        { /* block id: 657 */
            int32_t *l_1478 = (void*)0;
            int32_t **l_1477 = &l_1478;
            int32_t ***l_1476 = &l_1477;
            struct S0 *****l_1509 = &l_1464;
            int32_t *l_1513 = &l_1486;
            if (l_1468.f3)
                break;
            l_1468.f1 = ((safe_rshift_func_int8_t_s_u((safe_lshift_func_uint16_t_u_s((l_1476 != (void*)0), l_1468.f1)), 3)) >= (p_10 <= (safe_add_func_int8_t_s_s((safe_div_func_uint16_t_u_u(((l_1485 <= (6 <= l_1486)) & ((((safe_div_func_uint8_t_u_u((safe_rshift_func_int8_t_s_u((safe_mod_func_uint32_t_u_u((((p_11 < (((safe_mod_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(0x87FC, 0x0571)), p_10)) ^ l_1468.f3) < (-1))) != p_13) & 0U), 1U)), l_1468.f0)), l_1486)) < p_11) != p_10) > 6U)), p_13)), l_1468.f2))));
            (*l_1513) = (p_11 & ((safe_add_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s((0xBC9AFE9F < p_11), 0)), ((safe_sub_func_uint8_t_u_u((p_11 | p_10), ((safe_rshift_func_uint16_t_u_s(((&l_1476 == &l_1476) || (4294967295U > (safe_sub_func_int16_t_s_s(((((l_1509 != l_1510) >= 0x2E) || p_11) || l_1512), 65535U)))), l_1468.f0)) < p_13))) | 1U))) >= p_13));
        }
        (*l_1518) = (safe_sub_func_uint32_t_u_u(l_1485, ((l_1512 == (safe_lshift_func_int8_t_s_u((&l_1469 == (*l_1464)), 7))) > l_1468.f3)));
    }
    else
    { /* block id: 663 */
        int32_t **l_1519 = (void*)0;
        int32_t l_1522 = (-6);
        int32_t *l_1521 = &l_1522;
        int32_t **l_1520 = &l_1521;
        (*l_1520) = &p_13;
        /* statement id: 664 */
        assert (l_1521 == &p_13);
        for (p_11 = (-18); (p_11 < 45); p_11 = safe_add_func_uint16_t_u_u(p_11, 5))
        { /* block id: 667 */
            uint32_t l_1525 = 0xB80CADA1;
            l_1525 = 1;
        }
    }
    (*l_1532) = (safe_sub_func_int32_t_s_s((safe_lshift_func_int16_t_s_s((safe_div_func_int32_t_s_s((l_1468.f1 & l_1468.f3), ((0x0E == ((*l_1465) == (**l_1464))) & 1U))), 9)), l_1485));
    (*l_1466) = l_1534;
    (*l_1535) = &l_1533;
    return p_13;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_15(int32_t * p_16, uint8_t  p_17, int8_t  p_18, int32_t * p_19, int32_t * p_20)
{ /* block id: 637 */
    int32_t l_1450 = 0xDE077413;
    struct S0 **l_1453 = (void*)0;
    struct S0 ***l_1452 = &l_1453;
    struct S0 ****l_1451 = &l_1452;
    int32_t l_1455 = 0;
    int32_t *l_1454 = &l_1455;
    int32_t l_1458 = (-1);
lbl_1462:
    (*l_1454) = (safe_rshift_func_uint16_t_u_s(l_1450, ((void*)0 == l_1451)));
    for (l_1455 = (-4); (l_1455 > 7); l_1455 = safe_add_func_int8_t_s_s(l_1455, 6))
    { /* block id: 641 */
        int32_t *l_1459 = &l_1458;
        l_1458 = 0;
        (*l_1459) = (1 == 0x9F);
        for (p_18 = (-12); (p_18 == 23); p_18 = safe_add_func_int32_t_s_s(p_18, 1))
        { /* block id: 646 */
            if ((*l_1454))
                break;
        }
        if (l_1450)
            goto lbl_1462;
    }
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_21(struct S0  p_22, int8_t  p_23, uint32_t  p_24)
{ /* block id: 634 */
    int32_t l_1434 = 0x0405B391;
    int32_t *l_1433 = &l_1434;
    int32_t ** const l_1432 = &l_1433;
    int32_t ** const *l_1431 = &l_1432;
    int32_t ** const **l_1430 = &l_1431;
    int32_t ** const *** const l_1429 = &l_1430;
    uint32_t l_1437 = 0x4A1E3401;
    struct S0 ***l_1439 = (void*)0;
    struct S0 ****l_1438 = &l_1439;
    int32_t *l_1440 = &l_1434;
    int32_t *l_1441 = &l_1434;
    int32_t *l_1442 = &l_1434;
    int32_t *l_1443 = &l_1434;
    int32_t *l_1444 = &l_1434;
    int32_t *l_1445 = &l_1434;
    int32_t *l_1446 = (void*)0;
    (*****l_1429) = ((((l_1429 == (void*)0) && (****l_1430)) != ((safe_sub_func_uint32_t_u_u(0xC889F35A, (l_1437 <= ((*l_1429) != (void*)0)))) != (l_1438 == &l_1439))) < (***l_1431));
    return l_1446;
    /* statement id: 636 */
    //assert (func_21_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_25(int32_t  p_26, uint32_t  p_27, int32_t * p_28, uint32_t  p_29, uint32_t  p_30)
{ /* block id: 471 */
    int32_t l_1112 = 1;
    int32_t l_1121 = (-10);
    int32_t *l_1126 = &l_1121;
    int32_t **l_1125 = &l_1126;
    int32_t ***l_1124 = &l_1125;
    uint32_t l_1151 = 0xDFFA692B;
    struct S0 l_1229 = {-4680,1,23,-0};
    int8_t l_1230 = 0xEA;
    uint32_t l_1289 = 0x0C56083F;
    int32_t *l_1324 = &l_1121;
    struct S0 **l_1331 = (void*)0;
    struct S0 ***l_1330 = &l_1331;
    struct S0 ****l_1329 = &l_1330;
    struct S0 *****l_1328 = &l_1329;
    struct S0 l_1386 = {-3929,6,-89,4};
    int32_t ****l_1417 = (void*)0;
    int32_t *****l_1416 = &l_1417;
lbl_1129:
    for (p_27 = 29; (p_27 > 31); p_27 = safe_add_func_int16_t_s_s(p_27, 1))
    { /* block id: 474 */
        struct S0 l_1110 = {5405,-1,20,2};
        return l_1110;
    }
    if ((safe_unary_minus_func_uint8_t_u(((l_1112 == p_27) && (safe_lshift_func_uint16_t_u_s(l_1112, (safe_sub_func_int32_t_s_s((p_26 ^ p_30), (safe_add_func_int16_t_s_s(0xBD16, (safe_add_func_int8_t_s_s((l_1121 && (safe_sub_func_int16_t_s_s(l_1112, ((l_1124 != (void*)0) != (*l_1126))))), 0x3A))))))))))))
    { /* block id: 477 */
        int8_t l_1148 = (-9);
        uint32_t l_1154 = 1U;
        uint32_t l_1162 = 4294967295U;
        struct S0 l_1201 = {-7721,0,42,2};
        struct S0 *l_1200 = &l_1201;
        struct S0 **l_1199 = &l_1200;
        int16_t l_1214 = 1;
        int8_t l_1220 = (-3);
        const int32_t *l_1223 = &l_1121;
        const struct S0 ****l_1234 = (void*)0;
        const struct S0 **** const *l_1233 = &l_1234;
        struct S0 l_1276 = {1262,-1,25,-0};
        int32_t *****l_1312 = (void*)0;
        if ((0xF0 < 0x91))
        { /* block id: 478 */
            uint16_t l_1153 = 0x0BF1;
            int32_t **l_1159 = &l_1126;
            for (l_1121 = 0; (l_1121 >= 10); l_1121 = safe_add_func_uint32_t_u_u(l_1121, 1))
            { /* block id: 481 */
                const int16_t l_1152 = 0x1067;
                int32_t l_1156 = 1;
                int32_t *l_1155 = &l_1156;
                const int8_t l_1173 = 0xFE;
                if (l_1121)
                    goto lbl_1129;
            }
            (*l_1125) = &p_26;
            /* statement id: 486 */
            assert (l_1126 == &p_26);
        }
        else
        { /* block id: 487 */
            struct S0 l_1176 = {4353,-10,44,-4};
            for (l_1148 = 16; (l_1148 <= 10); l_1148 = safe_sub_func_uint8_t_u_u(l_1148, 8))
            { /* block id: 490 */
                struct S0 *l_1177 = (void*)0;
                struct S0 *l_1178 = &l_1176;
                (*l_1178) = l_1176;
                for (l_1154 = (-27); (l_1154 == 34); ++l_1154)
                { /* block id: 494 */
                    int32_t * const l_1181 = &l_1121;
                    (*l_1125) = func_43(l_1181);
                    /* statement id: 495 */
                    assert (l_1126 == 0);
                    return l_1176;
                }
            }
        }
        if ((safe_rshift_func_int16_t_s_u(((safe_div_func_uint8_t_u_u((safe_add_func_int16_t_s_s((1 & ((!(safe_lshift_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s(l_1162, ((safe_sub_func_int8_t_s_s(((safe_rshift_func_uint16_t_u_u(0xDDB7, 10)) ^ 0xB8), (p_30 == (0xD781 >= ((l_1199 == (void*)0) >= l_1201.f1))))) && l_1162))) || l_1201.f3), 10))) != l_1154)), l_1201.f2)), 6U)) < p_26), (***l_1124))))
        { /* block id: 500 */
            int8_t l_1213 = (-6);
            struct S0 l_1221 = {-4488,3,-18,3};
            struct S0 **l_1231 = &l_1200;
            int32_t ****l_1255 = &l_1124;
            if ((((((*l_1126) >= ((((safe_lshift_func_int16_t_s_u(((((l_1162 > (~l_1201.f1)) == ((safe_rshift_func_uint8_t_u_s(((p_27 > ((safe_div_func_uint8_t_u_u(((-1) < (safe_rshift_func_int16_t_s_u((0x4A & p_30), (p_30 != (**l_1125))))), l_1213)) >= l_1213)) | p_26), 4)) & l_1214)) & p_26) & (*l_1126)), 7)) ^ l_1154) == l_1213) == p_27)) & l_1201.f0) == l_1201.f1) == 0x67A1C0D4))
            { /* block id: 501 */
                struct S0 *l_1217 = &l_1201;
                (***l_1124) = (0xF888 > ((safe_mod_func_uint8_t_u_u(((void*)0 == l_1217), l_1162)) & (safe_mul_func_int16_t_s_s(((l_1213 ^ l_1213) == (-5)), (p_26 == l_1220)))));
                return l_1221;
            }
            else
            { /* block id: 504 */
                struct S0 *l_1222 = &l_1221;
                int32_t **l_1224 = &l_1126;
                (*l_1126) = ((***l_1124) || l_1213);
                (*l_1199) = l_1222;
                /* statement id: 506 */
                assert (l_1200 == &l_1221);
                (*l_1224) = l_1223;
                /* statement id: 507 */
                assert (l_1126 == &l_1121);
                for (l_1112 = (-8); (l_1112 >= (-5)); l_1112 = safe_add_func_uint16_t_u_u(l_1112, 1))
                { /* block id: 510 */
                    struct S0 ***l_1228 = &l_1199;
                    struct S0 ****l_1227 = &l_1228;
                    int32_t l_1232 = 1;
                    if ((((p_26 > 0x1465) < (*l_1223)) | ((void*)0 == l_1227)))
                    { /* block id: 511 */
                        (*l_1224) = &p_26;
                        /* statement id: 512 */
                        assert (l_1126 == &p_26);
                    }
                    else
                    { /* block id: 513 */
                        return l_1229;
                    }
                    /* facts after branching */
                    assert (l_1126 == &p_26);
                    (****l_1227) = l_1221;
                    if (l_1230)
                    { /* block id: 517 */
                        (***l_1228) = (*l_1222);
                        if (l_1201.f0)
                            goto lbl_1129;
                        l_1232 = ((**l_1227) == l_1231);
                    }
                    else
                    { /* block id: 521 */
                        struct S0 *****l_1235 = &l_1227;
                        int32_t l_1238 = (-1);
                        (**l_1125) = ((p_29 >= ((((((((l_1233 == l_1235) || p_26) && p_30) < (*l_1223)) && (safe_sub_func_uint8_t_u_u(((l_1238 | p_26) < (safe_mod_func_int32_t_s_s((1 > l_1232), (-10)))), p_27))) && 1U) > (**l_1224)) ^ 6)) < l_1221.f0);
                    }
                    for (l_1151 = 15; (l_1151 == 30); l_1151 = safe_add_func_int16_t_s_s(l_1151, 9))
                    { /* block id: 526 */
                        (*l_1126) = (safe_mod_func_int32_t_s_s(l_1221.f0, (safe_add_func_int32_t_s_s((**l_1224), p_26))));
                    }
                }
                /* facts after for loop */
                assert (l_1126 == &p_26 || l_1126 == &l_1121);
            }
            /* facts after branching */
            assert (l_1200 == &l_1221);
            for (l_1151 = 0; (l_1151 > 27); l_1151 = safe_add_func_uint32_t_u_u(l_1151, 2))
            { /* block id: 533 */
                int32_t *l_1254 = &l_1121;
                int32_t l_1280 = (-1);
                struct S0 l_1286 = {-6745,5,-3,4};
                (*l_1125) = &p_26;
                /* statement id: 534 */
                assert (l_1126 == &p_26);
                for (p_29 = 0; (p_29 <= 8); p_29 = safe_add_func_int8_t_s_s(p_29, 5))
                { /* block id: 537 */
                    uint32_t l_1274 = 0x48DE5971;
                    struct S0 *l_1277 = &l_1229;
                    for (p_26 = 13; (p_26 != 0); p_26 = safe_sub_func_uint16_t_u_u(p_26, 1))
                    { /* block id: 540 */
                        int32_t * const l_1253 = &l_1121;
                        struct S0 l_1275 = {5592,3,89,-2};
                        l_1254 = func_43(l_1253);
                        /* statement id: 541 */
                        assert (l_1254 == 0);
                        l_1229.f2 = (0x74 >= ((((&l_1124 == l_1255) || (*l_1253)) == (((((safe_sub_func_uint32_t_u_u(p_30, (((safe_rshift_func_int8_t_s_s(p_30, 4)) || (safe_sub_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(((*l_1253) > ((((((safe_add_func_uint32_t_u_u(4294967293U, (((safe_lshift_func_uint16_t_u_s((safe_mod_func_int16_t_s_s((safe_mod_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u(4294967295U, p_27)) < p_27), 0x96F722AD)), (****l_1255))), 12)) == 1U) != (****l_1255)))) != (*l_1223)) < 65535U) | l_1274) != 0x36) | l_1274)), p_30)), 0x912A))) >= l_1274))) & (*l_1253)) | (****l_1255)) != (****l_1255)) ^ (-2))) <= 0xE20C7A00));
                        l_1276 = l_1275;
                        (*l_1253) = (p_26 <= (l_1277 == (void*)0));
                    }
                    (****l_1255) = ((safe_sub_func_int16_t_s_s((l_1280 <= (((!(0x52 & ((safe_add_func_uint8_t_u_u(((safe_sub_func_int32_t_s_s((((*l_1223) == (5 > p_29)) >= p_26), ((*l_1223) ^ (p_27 <= (&p_28 != (**l_1255)))))) & 0x119F), 1)) | (**l_1125)))) ^ l_1274) != p_27)), l_1274)) >= 65535U);
                }
                /* facts after for loop */
                assert (l_1254 == 0 || l_1254 == &l_1121);
                return l_1286;
            }
            (*l_1200) = (*l_1200);
            (***l_1124) = (((safe_div_func_int32_t_s_s(l_1289, ((-1) && ((safe_add_func_int16_t_s_s((&p_26 != (void*)0), (0xC0 && p_27))) | ((*l_1223) == (p_29 <= (((safe_add_func_int16_t_s_s(p_27, (**l_1125))) ^ 0x902A2E42) == p_27))))))) <= (*l_1223)) && 0x96ED);
        }
        else
        { /* block id: 552 */
            uint32_t l_1296 = 0xFD76AEE9;
            int32_t ***l_1298 = &l_1125;
            struct S0 *l_1304 = &l_1229;
            int32_t ****l_1311 = (void*)0;
            int32_t *****l_1310 = &l_1311;
            (*l_1125) = &p_26;
            /* statement id: 553 */
            assert (l_1126 == &p_26);
            p_28 = (**l_1124);
            /* statement id: 554 */
            assert (p_28 == &p_26);
            if (((*l_1126) | ((l_1296 >= ((safe_unary_minus_func_int32_t_s((((9 > (l_1298 == (void*)0)) > (safe_unary_minus_func_int16_t_s((((safe_div_func_int32_t_s_s(((((((safe_lshift_func_uint16_t_u_u((*l_1223), 13)) < (((((l_1304 == (void*)0) && 0x38) && p_30) || p_30) || 0x9E)) ^ 5) < 1) < 0x9621) & 0x32), 1)) > (*l_1223)) & (***l_1298))))) != (***l_1298)))) && (*l_1223))) || 4)))
            { /* block id: 555 */
                (*p_28) = (safe_rshift_func_uint16_t_u_u(((*p_28) | (safe_lshift_func_uint16_t_u_u(((!p_26) < (*p_28)), 10))), p_27));
                (*l_1124) = &p_28;
                /* statement id: 557 */
                assert (l_1125 == &p_28);
                (*l_1304) = l_1229;
                (***l_1124) = ((*l_1199) != (void*)0);
            }
            else
            { /* block id: 560 */
                l_1312 = l_1310;
                /* statement id: 561 */
                assert (l_1312 == &l_1311);
            }
            /* facts after branching */
            assert (l_1125 == &l_1126 || l_1125 == &p_28);
            assert (l_1312 == &l_1311 || l_1312 == 0);
        }
        /* facts after branching */
        //assert (p_28 == &p_26 || p_28 == 0 || p_28 == &l_1541 || p_28 == &l_2);
        assert (l_1125 == &l_1126 || l_1125 == &p_28);
        //assert (l_1200 == &l_1201 || l_1200 == dangling);
        //assert (l_1312 == dangling || l_1312 == 0);
    }
    else
    { /* block id: 564 */
        int16_t l_1317 = 0xD790;
        int32_t *l_1350 = &l_1121;
        struct S0 ***l_1365 = (void*)0;
        struct S0 l_1382 = {7936,-7,86,2};
lbl_1383:
        if ((safe_sub_func_int8_t_s_s((safe_sub_func_int16_t_s_s((-7), l_1317)), 0x65)))
        { /* block id: 565 */
            uint16_t l_1349 = 0xAEBC;
            int32_t ***l_1351 = &l_1125;
            struct S0 *l_1379 = &l_1229;
            uint8_t l_1381 = 0xBD;
            for (p_29 = 0; (p_29 <= 48); p_29 = safe_add_func_int8_t_s_s(p_29, 1))
            { /* block id: 568 */
                int32_t l_1360 = 0x7E4E7DC2;
                for (l_1112 = 0; (l_1112 < (-29)); l_1112 = safe_sub_func_uint16_t_u_u(l_1112, 5))
                { /* block id: 571 */
                    int32_t ****l_1327 = &l_1124;
                    int32_t *****l_1326 = &l_1327;
                    struct S0 *****l_1332 = (void*)0;
                    for (l_1289 = 0; (l_1289 >= 51); l_1289 = safe_add_func_uint8_t_u_u(l_1289, 1))
                    { /* block id: 574 */
                        int32_t *l_1325 = &l_1121;
                        l_1325 = l_1324;
                        (*l_1124) = &p_28;
                        /* statement id: 576 */
                        assert (l_1125 == &p_28);
                    }
                    (*l_1326) = &l_1124;
                    if (l_1151)
                        goto lbl_1383;
                    if ((l_1328 == l_1332))
                    { /* block id: 579 */
                        (*l_1330) = (*l_1330);
                    }
                    else
                    { /* block id: 581 */
                        (*l_1126) = (((safe_lshift_func_int8_t_s_u((safe_sub_func_uint8_t_u_u((((safe_unary_minus_func_uint16_t_u(((safe_rshift_func_int8_t_s_s(p_30, (((safe_sub_func_int32_t_s_s(6, p_30)) && (safe_rshift_func_int8_t_s_u(p_29, 6))) && (!0x78981334)))) == (l_1317 > l_1317)))) >= (safe_rshift_func_int8_t_s_u((0x4FBAA90B >= (p_27 > l_1349)), p_26))) <= l_1317), l_1349)), 5)) < p_29) >= p_26);
                    }
                }
                if (l_1349)
                    continue;
                (*l_1125) = l_1350;
                (*l_1324) = ((l_1351 != l_1351) != ((((0x5784 <= (safe_lshift_func_int8_t_s_u((((((safe_mod_func_uint16_t_u_u((((safe_sub_func_uint16_t_u_u((p_30 <= ((safe_rshift_func_uint8_t_u_u(l_1360, 1)) <= ((safe_div_func_uint32_t_u_u((0 <= ((((4 != ((l_1365 == (void*)0) == 0xB2F0)) && p_29) ^ (*l_1350)) != p_26)), l_1349)) != p_27))), 65531U)) && p_26) >= (*l_1350)), p_30)) & (*l_1324)) && p_27) < 0x635E9BBE) > 1), p_29))) & (-10)) > 0x09442BE1) > (*l_1350)));
            }
            (**l_1124) = &p_26;
            /* statement id: 589 */
            //assert (p_28 == &p_26 || p_28 == &l_1121 || p_28 == 0 || p_28 == &l_1541 || p_28 == &l_2);
            for (l_1349 = (-27); (l_1349 == 17); l_1349 = safe_add_func_int32_t_s_s(l_1349, 8))
            { /* block id: 592 */
                int16_t l_1368 = 0;
                struct S0 *l_1380 = &l_1229;
            }
            (*l_1324) = p_27;
        }
        else
        { /* block id: 597 */
            return l_1382;
        }
        /* facts after branching */
        //assert (p_28 == &p_26 || p_28 == &l_1121 || p_28 == 0 || p_28 == &l_1541 || p_28 == &l_2);
        for (p_29 = 17; (p_29 < 9); p_29 = safe_sub_func_uint16_t_u_u(p_29, 1))
        { /* block id: 603 */
            uint32_t l_1389 = 0x3BAF578D;
            l_1386 = l_1382;
            for (l_1230 = 0; (l_1230 == (-30)); l_1230 = safe_sub_func_uint32_t_u_u(l_1230, 1))
            { /* block id: 607 */
                int32_t **l_1390 = &l_1324;
                (*l_1390) = func_45(l_1389);
                /* statement id: 608 */
                assert (l_1324 == 0);
                for (l_1121 = (-14); (l_1121 <= (-4)); ++l_1121)
                { /* block id: 611 */
                    p_28 = func_31(p_27, p_29, (p_30 == (safe_unary_minus_func_int8_t_s(p_26))), (*l_1350));
                    /* statement id: 612 */
                    assert (p_28 == 0);
                }
            }
            for (l_1112 = 23; (l_1112 <= (-24)); l_1112 = safe_sub_func_int8_t_s_s(l_1112, 1))
            { /* block id: 617 */
                int32_t **l_1396 = &l_1324;
                uint16_t l_1397 = 0x9730;
                (*l_1396) = func_45(l_1389);
                /* statement id: 618 */
                assert (l_1324 == 0);
                (**l_1124) = &p_26;
                (*l_1125) = (void*)0;
                (**l_1124) = func_31((*l_1350), l_1389, (0xF7 >= ((((p_30 <= ((*l_1350) <= (p_29 || (l_1397 >= l_1389)))) <= 0xEFB6) < l_1389) > 0U)), p_27);
            }
            if (l_1389)
                continue;
        }
        /* facts after for loop */
        assert (l_1126 == 0 || l_1126 == &p_26 || l_1126 == &l_1121);
        assert (l_1324 == 0 || l_1324 == &l_1121);
        (**l_1124) = l_1350;
        (*l_1350) = p_27;
    }
    /* facts after branching */
    //assert (p_28 == &p_26 || p_28 == &l_1121 || p_28 == 0 || p_28 == &l_1541 || p_28 == &l_2);
    assert (l_1126 == 0 || l_1126 == &p_26 || l_1126 == &l_1121);
    assert (l_1125 == &l_1126 || l_1125 == &p_28);
    assert (l_1324 == 0 || l_1324 == &l_1121);
    if ((safe_div_func_uint16_t_u_u(p_30, (safe_lshift_func_int8_t_s_s((-1), p_29)))))
    { /* block id: 628 */
        (*l_1329) = (*l_1329);
    }
    else
    { /* block id: 630 */
        int32_t l_1424 = 0;
        p_26 = (safe_lshift_func_uint8_t_u_u((safe_mod_func_uint8_t_u_u((((((safe_div_func_int32_t_s_s((safe_add_func_int32_t_s_s((p_30 <= (safe_rshift_func_uint16_t_u_s(p_26, p_30))), ((safe_div_func_int16_t_s_s((safe_lshift_func_int8_t_s_s((0xA9ED != ((((l_1416 != (void*)0) ^ ((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_u(((((((safe_rshift_func_uint16_t_u_s(l_1424, (safe_mod_func_uint16_t_u_u(p_29, (safe_sub_func_uint32_t_u_u(0x116525F4, 0x252A33C5)))))) <= p_30) >= p_26) >= l_1424) > p_27) >= p_29), 9)), p_26)) < p_30)) && 0xF687) | l_1424)), p_29)), l_1424)) & p_29))), (-8))) ^ 0x571A797E) >= 0x5B1DE9C2) | 0x81B1C8AA) && 1U), l_1424)), l_1424));
    }
    return l_1229;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_31(int32_t  p_32, uint32_t  p_33, uint8_t  p_34, int32_t  p_35)
{ /* block id: 4 */
    uint32_t l_38 = 4294967290U;
    int32_t l_40 = 0x67A7BF74;
    struct S0 l_855 = {-6225,0,54,-3};
    int32_t **l_866 = (void*)0;
    int32_t ***l_865 = &l_866;
    int32_t *****l_896 = (void*)0;
    struct S0 *l_1039 = &l_855;
    struct S0 **l_1038 = &l_1039;
    struct S0 ***l_1037 = &l_1038;
    struct S0 ****l_1036 = &l_1037;
    struct S0 ***** const l_1035 = &l_1036;
    int32_t *l_1106 = &l_40;
    int32_t **l_1105 = &l_1106;
    int32_t *l_1107 = (void*)0;
    l_40 = func_36(l_38);
    for (l_40 = 0; (l_40 > (-16)); l_40 = safe_sub_func_int8_t_s_s(l_40, 1))
    { /* block id: 10 */
        int32_t *l_854 = &l_40;
        int32_t **l_853 = &l_854;
        struct S0 l_856 = {-515,8,40,0};
        struct S0 *l_862 = &l_856;
        struct S0 **l_861 = &l_862;
        struct S0 ***l_860 = &l_861;
        struct S0 ****l_859 = &l_860;
        int32_t *****l_893 = (void*)0;
        int32_t * const l_957 = &l_40;
        int8_t l_1100 = 1;
        (*l_853) = func_43(func_45(p_35));
        /* statement id: 337 */
        assert (l_854 == 0);
        l_856 = l_855;
    }
    (*****l_1035) = (*l_1039);
    (*l_1105) = (void*)0;
    /* statement id: 469 */
    assert (l_1106 == 0);
    return l_1107;
    /* statement id: 470 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_36(uint16_t  p_37)
{ /* block id: 5 */
    uint32_t l_39 = 0x205300CE;
    return l_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(int32_t * const  p_44)
{ /* block id: 247 */
    struct S0 l_585 = {-5572,3,63,-0};
    struct S0 *l_586 = &l_585;
    uint32_t l_597 = 0xDDFC5413;
    int32_t l_603 = 1;
    int32_t * const l_602 = &l_603;
    struct S0 * const *l_650 = (void*)0;
    struct S0 * const **l_649 = &l_650;
    struct S0 * const ***l_648 = &l_649;
    struct S0 * const ****l_647 = &l_648;
    int32_t l_655 = (-7);
    uint32_t l_669 = 1U;
    int32_t *l_687 = &l_603;
    int32_t **l_686 = &l_687;
    int32_t ***l_685 = &l_686;
    int32_t ****l_684 = &l_685;
    uint32_t l_692 = 0x2496E742;
    struct S0 **l_705 = &l_586;
    struct S0 ***l_704 = &l_705;
    struct S0 ****l_703 = &l_704;
    struct S0 *****l_702 = &l_703;
    int16_t l_717 = 9;
    int16_t l_748 = 1;
    int32_t *l_799 = &l_603;
    int32_t *l_837 = &l_603;
    int32_t *l_844 = (void*)0;
    int32_t **l_845 = &l_799;
    int32_t *l_846 = &l_603;
    int32_t *l_847 = &l_603;
    int32_t *l_848 = &l_603;
    int32_t *l_849 = &l_603;
    int32_t *l_850 = &l_603;
    int32_t *l_851 = &l_603;
    int32_t *l_852 = (void*)0;
    (*l_586) = l_585;
    if ((safe_lshift_func_int16_t_s_s(((l_585.f1 == (l_585.f1 >= 0U)) > ((l_585.f0 <= (safe_lshift_func_int16_t_s_u((&l_585 == (void*)0), 4))) ^ (safe_mod_func_uint16_t_u_u(65534U, (safe_sub_func_uint32_t_u_u(l_585.f2, (safe_rshift_func_int16_t_s_u((((l_585.f0 || l_585.f2) != l_585.f2) >= l_585.f0), l_597)))))))), l_585.f2)))
    { /* block id: 249 */
        int32_t l_600 = 0xC1212F90;
        int32_t *l_599 = &l_600;
        int32_t **l_598 = &l_599;
        struct S0 l_601 = {-1085,8,47,-4};
        uint16_t l_628 = 0xC1FF;
        int8_t l_634 = 1;
        const struct S0 *l_646 = (void*)0;
        const struct S0 **l_645 = &l_646;
        const struct S0 ***l_644 = &l_645;
        const struct S0 **** const l_643 = &l_644;
        const struct S0 **** const *l_642 = &l_643;
        const int32_t *l_694 = (void*)0;
        const int32_t **l_693 = &l_694;
        (*l_598) = p_44;
        /* statement id: 250 */
        //assert (l_599 == 0 || l_599 == &l_40 || l_599 == &p_32 || l_599 == &p_35 || l_599 == &l_1121 || l_599 == &l_1547);
        (*l_586) = l_601;
        if ((l_602 == (void*)0))
        { /* block id: 252 */
            struct S0 * const l_611 = (void*)0;
            int32_t l_616 = (-4);
            uint8_t l_617 = 1U;
            int32_t **l_618 = &l_599;
            (*l_618) = func_45((safe_add_func_int16_t_s_s(((7U < (safe_unary_minus_func_int32_t_s((safe_add_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u((l_611 == &l_601), ((safe_rshift_func_int16_t_s_u((safe_sub_func_uint16_t_u_u(l_616, l_616)), 3)) ^ (*l_602)))) >= ((*l_602) < (l_616 <= (l_616 & 4294967293U)))), l_617))))) || (*l_602)), 0U)));
            /* statement id: 253 */
            assert (l_599 == 0);
            (*l_602) = ((safe_add_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u((!(0xC150 & ((safe_sub_func_uint16_t_u_u(((safe_add_func_uint32_t_u_u((l_616 >= l_628), (l_616 < (((*l_602) == (((*l_602) || 0x6D) > (*l_602))) != (~(safe_sub_func_int16_t_s_s((5U >= (*l_602)), l_617))))))) & (*l_602)), (*l_602))) != 0x77663CFE))), (*l_602))) & (*l_602)), l_634)) | 1U);
        }
        else
        { /* block id: 255 */
            int32_t ***** const l_635 = (void*)0;
            int32_t **l_636 = (void*)0;
            int32_t **l_637 = (void*)0;
            int32_t **l_638 = &l_599;
            int32_t **l_651 = &l_599;
            int32_t l_654 = 0x5B84161E;
            struct S0 **l_658 = &l_586;
            (*l_638) = func_45((l_635 == l_635));
            /* statement id: 256 */
            assert (l_599 == 0);
            (*l_651) = func_45((safe_add_func_int8_t_s_s((~6U), (0xA727 > ((*l_602) ^ (l_642 != l_647))))));
            if (((safe_rshift_func_uint8_t_u_u(l_654, 2)) & (*l_602)))
            { /* block id: 258 */
                l_601.f2 = l_655;
            }
            else
            { /* block id: 260 */
                int32_t ** const l_663 = &l_599;
                uint32_t l_675 = 0xBAFDC189;
                struct S0 *****l_688 = (void*)0;
                uint8_t l_691 = 0x26;
                for (l_634 = 0; (l_634 > (-3)); l_634 = safe_sub_func_uint32_t_u_u(l_634, 2))
                { /* block id: 263 */
                    uint32_t l_668 = 0x18B64A7C;
                    int32_t l_670 = 1;
                    (*l_602) = (((l_658 == (void*)0) | 0xCCD6) == (safe_add_func_int32_t_s_s((((safe_rshift_func_uint8_t_u_s((((&p_44 != l_663) & ((*l_602) <= (safe_rshift_func_uint8_t_u_u(((((safe_lshift_func_uint16_t_u_u(0U, 6)) < l_668) ^ (*l_602)) <= 0x1DBA4E57), 2)))) < l_669), l_670)) <= (*l_602)) || 1U), (*l_602))));
                }
                (*l_602) = (((safe_sub_func_int32_t_s_s((*l_602), (*l_602))) | ((*l_602) ^ ((((((l_634 ^ (l_675 <= ((*l_642) != (void*)0))) >= ((*l_663) != p_44)) || (*l_602)) >= (*l_602)) != 0xA9) > (*l_602)))) >= (*l_602));
                (*l_687) = ((safe_rshift_func_uint16_t_u_u(0x03CE, 9)) || ((safe_lshift_func_uint16_t_u_u(((*l_602) || ((safe_rshift_func_uint8_t_u_u((safe_div_func_uint16_t_u_u((((((((void*)0 != l_684) > (&l_648 == l_688)) < 0xF418) != (**l_686)) == (safe_rshift_func_uint8_t_u_s(((*l_645) != (**l_644)), 6))) < (***l_685)), (*l_602))), l_691)) != (*l_687))), 13)) == l_692));
                (*l_686) = (void*)0;
                /* statement id: 268 */
                assert (l_687 == 0);
            }
            /* facts after branching */
            assert (l_687 == 0 || l_687 == &l_603);
        }
        /* facts after branching */
        assert (l_599 == 0);
        assert (l_687 == 0 || l_687 == &l_603);
        (*l_693) = p_44;
        /* statement id: 271 */
        //assert (l_694 == 0 || l_694 == &l_40 || l_694 == &p_32 || l_694 == &p_35 || l_694 == &l_1121 || l_694 == &l_1547);
    }
    else
    { /* block id: 272 */
        uint8_t l_695 = 0xCF;
        struct S0 **l_699 = &l_586;
        struct S0 ***l_698 = &l_699;
        struct S0 ****l_701 = &l_698;
        struct S0 *****l_700 = &l_701;
        uint32_t l_724 = 1U;
        int32_t l_732 = (-5);
        int32_t *l_736 = (void*)0;
        int32_t ****l_796 = &l_685;
        int32_t *l_838 = (void*)0;
        int32_t *l_843 = &l_603;
        (*l_687) = l_695;
        (***l_685) = (0xEF < (safe_add_func_int16_t_s_s((l_698 != &l_699), ((****l_684) != (l_700 == l_702)))));
    }
    /* facts after branching */
    assert (l_687 == 0 || l_687 == &l_603);
    (***l_684) = p_44;
    /* statement id: 334 */
    //assert (l_687 == 0 || l_687 == &l_40 || l_687 == &p_32 || l_687 == &p_35 || l_687 == &l_1121 || l_687 == &l_1547);
    (*l_845) = p_44;
    /* statement id: 335 */
    //assert (l_799 == 0 || l_799 == &l_40 || l_799 == &p_32 || l_799 == &p_35 || l_799 == &l_1121 || l_799 == &l_1547);
    return l_852;
    /* statement id: 336 */
    //assert (func_43_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_45(uint32_t  p_46)
{ /* block id: 11 */
    struct S0 l_47 = {-6870,-10,60,-4};
    int32_t l_49 = 0;
    int32_t *l_48 = &l_49;
    int32_t * const l_96 = &l_49;
    int32_t *l_104 = &l_49;
    const int32_t *l_119 = (void*)0;
    const int32_t **l_118 = &l_119;
    const int32_t ** const *l_117 = &l_118;
    int32_t ** const l_136 = (void*)0;
    struct S0 *l_179 = &l_47;
    struct S0 **l_178 = &l_179;
    int16_t l_233 = 2;
    uint32_t l_256 = 0U;
    uint32_t l_334 = 7U;
    int32_t l_361 = 0xFAE14E27;
    int32_t * const l_384 = &l_49;
    int32_t * const l_516 = &l_49;
    int32_t * const l_517 = &l_49;
    struct S0 * const *l_540 = &l_179;
    struct S0 * const **l_539 = &l_540;
    struct S0 * const ***l_538 = &l_539;
    uint8_t l_573 = 255U;
    int32_t * const l_577 = &l_49;
    int32_t * const l_578 = &l_49;
    int32_t * const l_579 = &l_49;
    int32_t * const l_580 = &l_49;
    int32_t * const l_581 = &l_49;
    int32_t * const l_582 = &l_49;
    int32_t * const l_583 = &l_49;
    int32_t * const l_584 = (void*)0;
lbl_56:
    l_47 = l_47;
    if ((l_47.f3 >= (l_48 == (void*)0)))
    { /* block id: 13 */
        struct S0 l_57 = {5094,-7,-38,2};
        struct S0 *l_58 = &l_47;
        int32_t * const *l_66 = &l_48;
        int32_t * const **l_65 = &l_66;
        int32_t *l_71 = (void*)0;
        uint16_t l_80 = 65526U;
        for (l_49 = 21; (l_49 != 17); l_49 = safe_sub_func_int8_t_s_s(l_49, 4))
        { /* block id: 16 */
            int32_t **l_52 = &l_48;
            int32_t ***l_53 = (void*)0;
            int32_t * const *l_55 = &l_48;
            int32_t * const **l_54 = &l_55;
            (*l_54) = l_52;
            if (l_49)
                goto lbl_56;
        }
        (*l_58) = l_57;
        if ((p_46 < (safe_rshift_func_uint16_t_u_s((((((*l_48) < (((safe_lshift_func_uint16_t_u_s((((((p_46 <= 5U) >= (safe_sub_func_uint32_t_u_u((l_65 != &l_66), ((((void*)0 != &l_49) & ((safe_add_func_uint32_t_u_u((safe_div_func_uint8_t_u_u(251U, p_46)), 0x588DFEF2)) || p_46)) < p_46)))) <= (*l_48)) == (**l_66)) <= p_46), p_46)) <= 0x8E66) | (-10))) || p_46) < p_46) == (***l_65)), (***l_65)))))
        { /* block id: 21 */
            int32_t l_76 = 0xFB14BE56;
            struct S0 * const l_77 = (void*)0;
            int32_t **l_81 = &l_48;
            l_65 = (void*)0;
            /* statement id: 22 */
            assert (l_65 == 0);
            (**l_66) = (((*l_66) != l_71) & (p_46 && (safe_rshift_func_uint8_t_u_u((0x95BC > (safe_lshift_func_int16_t_s_u((l_76 != (l_77 != &l_47)), 11))), ((safe_rshift_func_int16_t_s_s(0xD3E8, l_80)) != (-2))))));
            (*l_81) = (void*)0;
            /* statement id: 24 */
            assert (l_48 == 0);
        }
        else
        { /* block id: 25 */
            int32_t **l_82 = (void*)0;
            int32_t *l_83 = (void*)0;
            l_83 = (*l_66);
            /* statement id: 26 */
            assert (l_83 == &l_49);
            (*l_48) = (***l_65);
        }
        /* facts after branching */
        assert (l_48 == &l_49 || l_48 == 0);
        assert (l_65 == &l_66 || l_65 == 0);
    }
    else
    { /* block id: 29 */
        const int32_t *l_84 = (void*)0;
        int32_t *l_89 = &l_49;
        const struct S0 * const l_101 = &l_47;
        struct S0 l_175 = {4256,-3,-76,2};
        int32_t *l_287 = &l_49;
        const struct S0 *l_332 = (void*)0;
        const struct S0 **l_331 = &l_332;
        const struct S0 ***l_330 = &l_331;
        int32_t **l_370 = &l_287;
        int32_t ***l_369 = &l_370;
        int32_t ****l_368 = &l_369;
        int32_t * const l_385 = &l_49;
        int32_t * const l_387 = &l_49;
        int32_t * const l_388 = &l_49;
        int32_t * const l_390 = &l_49;
        int32_t * const l_391 = (void*)0;
        int32_t * const l_393 = &l_49;
        int32_t * const l_394 = (void*)0;
        int32_t *l_445 = &l_49;
        const int32_t ***l_482 = &l_118;
        const int32_t ****l_481 = &l_482;
        const int32_t *****l_480 = &l_481;
    }
    /* facts after branching */
    assert (l_48 == &l_49 || l_48 == 0);
    if ((((*l_516) || (1 >= ((void*)0 == (*l_117)))) >= (safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(((**l_538) != (*l_539)), (safe_sub_func_int8_t_s_s(((*l_539) == (void*)0), (!(safe_lshift_func_uint8_t_u_s((*l_96), p_46))))))), 0xDF44))))
    { /* block id: 237 */
        uint16_t l_557 = 0U;
        struct S0 ****l_562 = (void*)0;
        (*l_516) = 0xE9F76C22;
        if (l_47.f1)
            goto lbl_574;
lbl_574:
        (*l_96) = (safe_mod_func_int16_t_s_s(((safe_lshift_func_int8_t_s_u(((safe_rshift_func_uint16_t_u_s(l_557, 14)) & (((safe_rshift_func_uint16_t_u_s(((l_557 || (safe_rshift_func_int16_t_s_s(0xB5BD, 0))) | ((void*)0 != l_562)), (safe_rshift_func_int8_t_s_s(((safe_rshift_func_int8_t_s_u(((safe_lshift_func_int16_t_s_u((safe_sub_func_uint8_t_u_u((*l_384), (l_557 != (((((l_557 >= ((l_557 && p_46) || (-3))) || 0xB04C0E27) && p_46) | l_557) != l_573)))), l_557)) >= 1), 7)) >= p_46), (*l_104))))) >= p_46) >= 0xE0)), l_557)) | 246U), (-3)));
        (**l_540) = (**l_540);
    }
    else
    { /* block id: 242 */
        struct S0 **l_575 = &l_179;
        int32_t * const l_576 = (void*)0;
        (*l_575) = (*l_540);
        return l_576;
        /* statement id: 244 */
        //assert (func_45_rv == 0);
    }
    return l_584;
    /* statement id: 246 */
    //assert (func_45_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 353
   depth: 1, occurrence: 21
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 84
breakdown:
   indirect level: 0, occurrence: 21
   indirect level: 1, occurrence: 19
   indirect level: 2, occurrence: 11
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 14
   indirect level: 5, occurrence: 14
XXX full-bitfields structs in the program: 21
breakdown:
   indirect level: 0, occurrence: 21
XXX times a bitfields struct's address is taken: 32
XXX times a bitfields struct on LHS: 10
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 29

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 191
   depth: 2, occurrence: 39
   depth: 3, occurrence: 11
   depth: 5, occurrence: 2
   depth: 6, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 30, occurrence: 2

XXX total number of pointers: 370

XXX times a variable address is taken: 356
XXX times a pointer is dereferenced on RHS: 366
breakdown:
   depth: 1, occurrence: 221
   depth: 2, occurrence: 62
   depth: 3, occurrence: 32
   depth: 4, occurrence: 35
   depth: 5, occurrence: 16
XXX times a pointer is dereferenced on LHS: 211
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 32
   depth: 3, occurrence: 21
   depth: 4, occurrence: 7
   depth: 5, occurrence: 7
XXX times a pointer is compared with null: 77
XXX times a pointer is compared with address of another variable: 35
XXX times a pointer is compared with another pointer: 24
XXX times a pointer is qualified to be dereferenced: 1851

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1095
   level: 2, occurrence: 268
   level: 3, occurrence: 157
   level: 4, occurrence: 107
   level: 5, occurrence: 49
XXX number of pointers point to pointers: 205
XXX number of pointers point to scalars: 131
XXX number of pointers point to structs: 34
XXX percent of pointers has null in alias set: 28.4
XXX average alias set size: 1.21

XXX times a non-volatile is read: 2052
XXX times a non-volatile is write: 655
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 9

XXX stmts: 174
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 40
   depth: 2, occurrence: 36
   depth: 3, occurrence: 32
   depth: 4, occurrence: 14
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 13.8
XXX percentage an existing variable is used: 86.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

