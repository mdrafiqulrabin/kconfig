/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1091830040
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_30(void);
inline static uint16_t  func_34(struct S0  p_35, int16_t  p_36, uint16_t  p_37, struct S0  p_38, int16_t  p_39);
static struct S0  func_40(struct S0  p_41, uint32_t  p_42, struct S0  p_43, int32_t  p_44);
inline static struct S0  func_45(uint16_t  p_46, int32_t  p_47);
static uint16_t  func_48(uint32_t  p_49, const struct S0  p_50);
static uint32_t  func_51(uint16_t  p_52, struct S0  p_53);
inline static int16_t  func_62(uint16_t * p_63, uint16_t * p_64);
static uint16_t * func_65(struct S0  p_66);
inline static const int32_t * func_68(int32_t * p_69, uint32_t  p_70);
inline static int16_t  func_82(uint16_t * p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(void)
{ /* block id: 36 */
    const int16_t l_31 = (-1);
    uint16_t l_55 = 5U;
    uint16_t *l_54 = &l_55;
    struct S0 l_56 = {0x1477};
    int32_t l_2585 = 1;
    struct S0 l_2586 = {3U};
    int32_t l_2588 = 0x568A3967;
    int32_t *l_2587 = &l_2588;
    uint32_t l_2848 = 0xE4C2C268;
    uint32_t *l_2847 = &l_2848;
    uint32_t *l_2849 = (void*)0;
    uint32_t l_2851 = 1U;
    uint32_t *l_2850 = &l_2851;
    struct S0 l_2852 = {6U};
    int16_t l_2861 = 0x7E84;
    uint16_t *l_2982 = (void*)0;
    uint16_t l_2984 = 0x5AA7;
    uint16_t *l_2983 = &l_2984;
    int32_t l_2986 = 2;
    int32_t *l_2985 = &l_2986;
    int32_t l_2987 = 0x16CB387C;
    (*l_2985) &= (l_31 < ((*l_2983) &= (((uint32_t)l_31 - (uint32_t)(func_34(func_40(((__builtin_popcount(((*l_2850) = ((*l_2847) = (__builtin_ia32_crc32qi((((func_45(func_48(func_51(((*l_54) = l_31), l_56), l_56), ((*l_2587) = func_51((l_56.f0 ^ l_2585), l_2586))) , 0x294DBB46) , (*l_2587)) < 0), l_2585) , (*l_2587))))) < 1) , l_56), l_31, l_2852, l_31), l_2586.f0, l_2586.f0, l_2586, l_2861) != l_2861)) <= l_2585)));
    return l_2987;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_34(struct S0  p_35, int16_t  p_36, uint16_t  p_37, struct S0  p_38, int16_t  p_39)
{ /* block id: 783 */
    struct S0 l_2863 = {65535U};
    struct S0 *l_2862 = &l_2863;
    int32_t l_2866 = 0x0C1C7432;
    int32_t l_2939 = 9;
    (*l_2862) = p_38;
    for (p_37 = (-27); (p_37 != 27); p_37 += 1)
    { /* block id: 787 */
        l_2866 &= p_37;
        if (l_2866)
            break;
    }
    for (p_36 = 7; (p_36 < (-4)); p_36 -= 3)
    { /* block id: 793 */
        int16_t l_2874 = 0;
        int16_t *l_2873 = &l_2874;
        int32_t *l_2875 = &l_2866;
        struct S0 l_2880 = {65535U};
        int32_t l_2966 = 0xBF8828FA;
        (*l_2875) ^= (__builtin_parityll(p_36) > ((int16_t)((*l_2873) = ((int16_t)l_2863.f0 >> (int16_t)7)) >> (int16_t)3));
        for (l_2866 = 28; (l_2866 > (-9)); l_2866 -= 6)
        { /* block id: 798 */
            uint16_t *l_2887 = &l_2880.f0;
            int32_t l_2888 = 0xB899CA39;
            int32_t l_2891 = 0;
            int32_t *l_2913 = (void*)0;
            int32_t *l_2914 = &l_2891;
            struct S0 l_2956 = {0x494F};
            uint16_t ***l_2981 = (void*)0;
            uint16_t ****l_2980 = &l_2981;
            for (p_35.f0 = (-26); (p_35.f0 > 56); p_35.f0 += 5)
            { /* block id: 801 */
                (*l_2862) = l_2880;
            }
            if ((((int16_t)__builtin_ctz(p_37) << (int16_t)8) != ((int32_t)(~(l_2891 |= func_48(((!(((*l_2887) = l_2863.f0) , (0 | ((0U ^ (p_37 , l_2888)) > (((uint16_t)func_51(l_2863.f0, func_40((*l_2862), l_2863.f0, (*l_2862), p_37)) >> (uint16_t)(*l_2875)) < l_2888))))) , p_37), (*l_2862)))) - (int32_t)(-9))))
            { /* block id: 806 */
                const uint32_t l_2894 = 2U;
                int32_t l_2899 = 0x8B25AE9D;
                uint32_t *l_2900 = (void*)0;
                uint32_t l_2902 = 0x68702ACF;
                uint32_t *l_2901 = &l_2902;
                uint16_t *l_2907 = (void*)0;
                uint32_t l_2909 = 0xA644AF8A;
                uint32_t *l_2908 = &l_2909;
                int32_t *l_2910 = &l_2899;
                (*l_2862) = func_45((((((int32_t)0xFEA58C54 - (int32_t)l_2894) , ((int32_t)(((uint16_t)l_2894 - (uint16_t)(l_2899 = 65527U)) <= __builtin_parityl(((*l_2901) = l_2891))) + (int32_t)((int16_t)((uint16_t)__builtin_clzll(func_62(l_2887, func_65((p_35.f0 , func_45(func_82(l_2907), l_2866))))) >> (uint16_t)10) << (int16_t)(*l_2875)))) >= p_35.f0) <= l_2891), l_2894);
                (*l_2910) ^= (((*l_2873) = (0xC648A55E >= ((*l_2908) = (l_2902 || 0)))) < (((void*)0 == l_2875) ^ 0x28322908));
            }
            else
            { /* block id: 813 */
                return p_35.f0;
            }
            (*l_2914) |= (p_38.f0 == ((uint16_t)(p_39 && p_37) >> (uint16_t)9));
            for (l_2880.f0 = (-3); (l_2880.f0 == 59); l_2880.f0 += 1)
            { /* block id: 819 */
                int32_t l_2919 = 0x130FDD86;
                uint32_t l_2921 = 0xE7CA9068;
                uint32_t *l_2920 = &l_2921;
                int32_t l_2940 = 0xBF027C89;
                uint16_t *l_2955 = &l_2863.f0;
                struct S0 **l_2974 = &l_2862;
            }
        }
    }
    return l_2866;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_40(struct S0  p_41, uint32_t  p_42, struct S0  p_43, int32_t  p_44)
{ /* block id: 779 */
    uint16_t l_2854 = 0U;
    uint16_t *l_2853 = &l_2854;
    int32_t l_2855 = 1;
    int32_t *l_2856 = (void*)0;
    int32_t *l_2857 = (void*)0;
    int32_t *l_2858 = (void*)0;
    int32_t l_2859 = 0xE6494FBE;
    struct S0 l_2860 = {0x647B};
    l_2859 |= (((*l_2853) = p_41.f0) > l_2855);
    return l_2860;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_45(uint16_t  p_46, int32_t  p_47)
{ /* block id: 602 */
    const struct S0 l_2591 = {0x56B2};
    uint16_t l_2596 = 0xAB05;
    int32_t l_2598 = 0x5C3086CC;
    int32_t *l_2597 = &l_2598;
    int32_t ****l_2613 = (void*)0;
    uint16_t *l_2639 = &l_2596;
    uint16_t **l_2638 = &l_2639;
    uint16_t ***l_2637 = &l_2638;
    uint16_t ****l_2636 = &l_2637;
    uint16_t *l_2667 = &l_2596;
    int32_t l_2734 = 0xDC2C885D;
    uint32_t l_2748 = 0x42EDABAD;
    uint32_t *l_2747 = &l_2748;
    uint32_t **l_2746 = &l_2747;
    uint32_t ***l_2745 = &l_2746;
    uint32_t ****l_2744 = &l_2745;
    uint32_t *****l_2743 = &l_2744;
    uint32_t l_2779 = 4294967295U;
    struct S0 l_2785 = {65535U};
    uint32_t l_2839 = 0xDE831C05;
    for (p_47 = 0; (p_47 < (-29)); p_47 -= 5)
    { /* block id: 605 */
        struct S0 l_2594 = {0U};
        uint16_t *l_2595 = &l_2594.f0;
        uint16_t l_2602 = 0x7A27;
        int32_t l_2618 = 0xE854E748;
        uint32_t **l_2642 = (void*)0;
        uint32_t ***l_2641 = &l_2642;
        uint16_t ****l_2643 = &l_2637;
        uint32_t l_2650 = 0xE4CEEB95;
        int32_t l_2671 = 0x7397E891;
        uint16_t *****l_2689 = &l_2636;
        struct S0 l_2691 = {0x1D98};
        struct S0 * const * const *l_2717 = (void*)0;
        struct S0 * const * const **l_2716 = &l_2717;
        struct S0 * const * const ***l_2715 = &l_2716;
        struct S0 *l_2741 = &l_2691;
    }
    for (p_46 = (-16); (p_46 > 41); p_46 += 8)
    { /* block id: 744 */
        int32_t l_2804 = 0xC67378BE;
        struct S0 l_2805 = {0xC59F};
        const int32_t * const **l_2814 = (void*)0;
        const struct S0 l_2829 = {0xF1D3};
        const int32_t l_2830 = 0x22FB4727;
        int32_t *l_2846 = &l_2804;
        if (((p_47 >= 0) , ((uint16_t)func_51(l_2804, l_2805) << (uint16_t)3)))
        { /* block id: 745 */
            uint32_t ****l_2806 = &l_2745;
            l_2806 = l_2806;
        }
        else
        { /* block id: 747 */
            for (l_2596 = (-30); (l_2596 == 19); l_2596 += 1)
            { /* block id: 750 */
                struct S0 l_2809 = {0x8316};
                return l_2809;
            }
        }
        for (l_2779 = 0; (l_2779 <= 34); l_2779 += 6)
        { /* block id: 756 */
            struct S0 *l_2813 = &l_2805;
            struct S0 **l_2812 = &l_2813;
            (*l_2812) = &l_2805;
        }
        if ((l_2814 == (((((p_47 | (((int16_t)(((int32_t)((uint16_t)p_47 - (uint16_t)((*l_2667)--)) + (int32_t)((uint16_t)(*l_2597) % (uint16_t)(func_48((p_46 , ((int16_t)((p_46 , p_47) <= (p_46 <= (((int32_t)func_48(p_46, l_2591) + (int32_t)0x56DCBDE1) ^ 6))) >> (int16_t)p_47)), l_2829) ^ p_47))) , p_47) << (int16_t)p_46) | 0xC309)) != p_46) , l_2830) != 1U) , (void*)0)))
        { /* block id: 760 */
            uint32_t l_2837 = 1U;
            uint32_t l_2838 = 0xFF2B47A0;
            if (((uint16_t)((***l_2637) &= 0x9C6A) << (uint16_t)7))
            { /* block id: 762 */
                const int32_t *l_2834 = (void*)0;
                const int32_t **l_2833 = &l_2834;
                int16_t l_2841 = 0x50B1;
                int16_t *l_2840 = &l_2841;
                int16_t *l_2842 = (void*)0;
                int16_t l_2844 = 0xCB85;
                int16_t *l_2843 = &l_2844;
                (*l_2833) = &p_47;
                (*l_2597) = func_51(((*l_2597) , ((p_47 , p_47) < ((*l_2843) = ((int16_t)(-1) + (int16_t)((*l_2840) ^= ((((*l_2834) | ((((((((*l_2597) | ((**l_2746) &= __builtin_ffsl(l_2837))) ^ (l_2838 | (*l_2834))) , (**l_2833)) >= p_47) , 0x85AAF71C) && 0x2592AF00) >= p_46)) > l_2839) & p_46)))))), l_2829);
            }
            else
            { /* block id: 768 */
                return l_2591;
            }
        }
        else
        { /* block id: 771 */
            int32_t *l_2845 = &l_2804;
            l_2845 = (__builtin_popcountll(l_2804) , &p_47);
        }
        l_2846 = &l_2734;
    }
    return l_2591;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(uint32_t  p_49, const struct S0  p_50)
{ /* block id: 591 */
    uint16_t l_2567 = 65532U;
    int32_t l_2568 = 0xF47C6928;
    uint32_t l_2579 = 0x400DFFC6;
    int32_t l_2581 = (-9);
    int32_t *l_2580 = &l_2581;
    int32_t *l_2584 = &l_2568;
    (*l_2580) &= (((((__builtin_clzll(p_49) , (l_2567 ^= 1)) , l_2567) > (((l_2568 < ((uint32_t)__builtin_ffsl(((int16_t)p_50.f0 - (int16_t)((int16_t)((int16_t)(((((int16_t)(5U <= (p_50 , (__builtin_ffs(l_2568) , p_49))) - (int16_t)l_2568) , 0xD4E3) && 0x959D) != 8) >> (int16_t)9) >> (int16_t)p_50.f0))) - (uint32_t)l_2568)) , l_2568) < l_2568)) && 0xF2376796) < l_2579);
    for (l_2579 = 0; (l_2579 < 7); l_2579 += 1)
    { /* block id: 596 */
        return p_50.f0;
    }
    (*l_2584) &= (*l_2580);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(uint16_t  p_52, struct S0  p_53)
{ /* block id: 38 */
    uint32_t l_57 = 0U;
    struct S0 l_67 = {9U};
    uint16_t *l_2555 = &l_67.f0;
    int32_t l_2565 = 0xA90303DA;
    int32_t *l_2564 = &l_2565;
    uint16_t l_2566 = 0x16DF;
    (*l_2564) = (l_57 == ((int32_t)(((uint16_t)(func_62(func_65(l_67), l_2555) | ((uint16_t)1U << (uint16_t)p_52)) >> (uint16_t)__builtin_clz(((-10) & (((uint16_t)0x670D << (uint16_t)l_57) > p_53.f0)))) | l_67.f0) + (int32_t)l_57));
    return l_2566;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_62(uint16_t * p_63, uint16_t * p_64)
{ /* block id: 586 */
    uint32_t l_2556 = 4294967295U;
    int32_t l_2558 = 0x6C65E50C;
    int32_t *l_2557 = &l_2558;
    uint16_t l_2559 = 0x559B;
    (*l_2557) = l_2556;
    return l_2559;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t * func_65(struct S0  p_66)
{ /* block id: 39 */
    int32_t *l_71 = (void*)0;
    int32_t **l_72 = (void*)0;
    int32_t **l_73 = &l_71;
    int32_t **l_74 = (void*)0;
    int32_t l_77 = 0x510A7412;
    int32_t *l_76 = &l_77;
    int32_t **l_75 = &l_76;
    uint16_t *l_84 = (void*)0;
    int32_t *l_2385 = &l_77;
    uint16_t l_2390 = 0x66C4;
    const uint16_t *l_2389 = &l_2390;
    const uint16_t **l_2388 = &l_2389;
    uint16_t **l_2392 = (void*)0;
    uint16_t ***l_2391 = &l_2392;
    uint32_t *l_2393 = (void*)0;
    uint32_t *l_2394 = (void*)0;
    uint32_t l_2396 = 0xD19546F1;
    uint32_t *l_2395 = &l_2396;
    int32_t **l_2553 = &l_76;
    uint16_t *l_2554 = (void*)0;
    (*l_2553) = func_68(((*l_75) = ((*l_73) = l_71)), (((int16_t)((-(int32_t)((*l_2385) = (~(0xE2CC < func_82(l_84))))) , (p_66.f0 & (0 < (((*l_2395) = ((((((int16_t)(p_66.f0 != (&l_84 == ((*l_2391) = l_2388))) >> (int16_t)(*l_2385)) , 0x21D5C619) , p_66.f0) , (*l_2385)) || p_66.f0)) , 0)))) >> (int16_t)p_66.f0) > p_66.f0));
    (*l_2385) |= p_66.f0;
    return l_2554;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_68(int32_t * p_69, uint32_t  p_70)
{ /* block id: 477 */
    uint32_t l_2410 = 0x525F4682;
    uint32_t l_2423 = 0xAF6EA22F;
    struct S0 l_2424 = {1U};
    uint32_t ***l_2430 = (void*)0;
    uint32_t *l_2434 = &l_2423;
    uint32_t **l_2433 = &l_2434;
    uint32_t ***l_2432 = &l_2433;
    const int32_t l_2435 = 0x526B434E;
    uint16_t *l_2436 = &l_2424.f0;
    uint16_t **l_2457 = &l_2436;
    uint16_t ***l_2456 = &l_2457;
    int32_t l_2464 = 0xFD24E597;
    const int32_t *l_2523 = &l_2464;
    for (p_70 = 0; (p_70 == 18); p_70 += 1)
    { /* block id: 480 */
        int16_t l_2399 = (-1);
        int32_t l_2401 = (-5);
        int32_t *l_2400 = &l_2401;
        int32_t *l_2402 = &l_2401;
        int32_t *l_2403 = (void*)0;
        int32_t *l_2404 = &l_2401;
        int32_t *l_2405 = (void*)0;
        int32_t *l_2406 = (void*)0;
        int32_t *l_2407 = &l_2401;
        int32_t *l_2408 = (void*)0;
        int32_t *l_2409 = &l_2401;
        const int32_t l_2413 = 0;
        uint16_t l_2417 = 0xEE74;
        uint16_t *l_2416 = &l_2417;
        const uint32_t l_2420 = 0x613642B7;
        const uint32_t *l_2419 = &l_2420;
        const uint32_t **l_2418 = &l_2419;
        struct S0 *l_2425 = &l_2424;
        l_2410--;
        (*l_2407) ^= (((l_2413 && (p_70 >= (((int16_t)l_2410 % (int16_t)(p_70 , func_82(l_2416))) | (((6 || (((*l_2418) = p_69) != ((((int16_t)l_2410 << (int16_t)l_2410) , l_2423) , (void*)0))) , l_2410) , 0xAE4CEB39)))) > 0x2FC479E0) ^ 0x551010E4);
        (*l_2425) = l_2424;
    }
    for (l_2410 = (-28); (l_2410 != 38); l_2410 += 2)
    { /* block id: 488 */
        uint32_t ****l_2431 = &l_2430;
        uint16_t **l_2437 = &l_2436;
        int32_t l_2439 = (-4);
        int32_t *l_2438 = &l_2439;
        uint16_t ***l_2455 = &l_2437;
        const uint32_t l_2458 = 1U;
        int32_t **l_2470 = &l_2438;
        int32_t ***l_2469 = &l_2470;
        int32_t l_2474 = 0x93BEB7C4;
        struct S0 l_2501 = {0x827E};
        int32_t l_2537 = 0x9D4024FD;
        uint32_t l_2546 = 0xDB4B9B6E;
        (*l_2438) ^= (p_70 , ((int16_t)(((*l_2431) = l_2430) == l_2432) - (int16_t)__builtin_ctzll(func_82(((l_2424 , l_2435) , ((*l_2437) = l_2436))))));
        for (l_2423 = (-30); (l_2423 >= 57); l_2423 += 1)
        { /* block id: 494 */
            uint16_t **l_2446 = (void*)0;
            uint16_t ***l_2447 = &l_2437;
            int32_t l_2475 = (-10);
            int32_t ** const l_2485 = &l_2438;
            int32_t *l_2486 = &l_2475;
            struct S0 l_2500 = {65529U};
        }
    }
    for (l_2424.f0 = (-17); (l_2424.f0 <= 16); l_2424.f0 += 1)
    { /* block id: 578 */
        int32_t *l_2552 = &l_2464;
        (*l_2552) = (*l_2523);
        (*l_2552) ^= p_70;
    }
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_82(uint16_t * p_83)
{ /* block id: 42 */
    uint16_t l_85 = 0x0EB6;
    int32_t *l_102 = (void*)0;
    int32_t l_141 = 0xAF0C8B8A;
    int32_t l_145 = 0xE56B76AF;
    int32_t l_172 = 8;
    int32_t l_186 = 1;
    int32_t l_205 = 6;
    int32_t l_221 = 8;
    int32_t l_228 = 0;
    int32_t l_253 = (-7);
    int32_t l_271 = 7;
    int32_t l_276 = 1;
    int32_t l_285 = (-1);
    int32_t l_288 = 0x1FF0AA6A;
    int32_t l_313 = 0;
    int32_t l_323 = 4;
    int16_t l_353 = 0;
    int16_t *l_352 = &l_353;
    uint16_t *l_429 = &l_85;
    uint16_t **l_428 = &l_429;
    uint16_t ***l_427 = &l_428;
    uint16_t ***l_431 = &l_428;
    uint16_t ****l_430 = &l_431;
    int32_t *l_432 = &l_205;
    uint32_t *l_434 = (void*)0;
    uint32_t **l_433 = &l_434;
    int32_t *l_435 = (void*)0;
    uint32_t *l_436 = (void*)0;
    int32_t l_710 = (-7);
    int32_t l_907 = (-5);
    int32_t l_944 = 0;
    int32_t l_952 = 1;
    int32_t l_953 = 0x18967487;
    int32_t l_957 = 0xBA55D4B4;
    int32_t l_1056 = 1;
    int32_t l_1058 = 0;
    int32_t l_1083 = (-1);
    int32_t l_1116 = 1;
    uint32_t l_1124 = 0x01EF4C16;
    int32_t l_1160 = 1;
    int32_t l_1496 = (-6);
    struct S0 l_1613 = {0U};
    struct S0 * const l_1612 = &l_1613;
    struct S0 * const *l_1611 = &l_1612;
    struct S0 * const **l_1610 = &l_1611;
    uint32_t l_1751 = 0xCD5F81CD;
    int32_t ***l_1809 = (void*)0;
    int32_t ****l_1808 = &l_1809;
    int32_t *l_1887 = &l_186;
    int32_t l_2369 = 0xF7E3BAF5;
    int32_t l_2381 = 4;
    uint32_t l_2384 = 0U;
    return l_2384;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 558
   depth: 1, occurrence: 37
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 1815

XXX times a variable address is taken: 1469
XXX times a pointer is dereferenced on RHS: 211
breakdown:
   depth: 1, occurrence: 176
   depth: 2, occurrence: 17
   depth: 3, occurrence: 7
   depth: 4, occurrence: 9
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 277
breakdown:
   depth: 1, occurrence: 241
   depth: 2, occurrence: 23
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 4054

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 942
   level: 2, occurrence: 109
   level: 3, occurrence: 72
   level: 4, occurrence: 76
   level: 5, occurrence: 15
XXX number of pointers point to pointers: 147
XXX number of pointers point to scalars: 1644
XXX number of pointers point to structs: 24
XXX percent of pointers has null in alias set: 22.6
XXX average alias set size: 1.04

XXX times a non-volatile is read: 1390
XXX times a non-volatile is write: 773
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 4

XXX stmts: 60
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 16
   depth: 2, occurrence: 9
   depth: 3, occurrence: 8

XXX percentage a fresh-made variable is used: 30.8
XXX percentage an existing variable is used: 69.2
********************* end of statistics **********************/

