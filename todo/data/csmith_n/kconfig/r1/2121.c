/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      156541704
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 18;
   const unsigned f1 : 31;
   signed f2 : 5;
   const float  f3;
   unsigned f4 : 14;
   unsigned f5 : 2;
   const unsigned f6 : 27;
};

struct S1 {
   uint32_t  f0;
   struct S0  f1;
   uint32_t  f2;
   uint32_t  f3;
   const uint32_t  f4;
   uint32_t  f5;
   uint16_t  f6;
   signed f7 : 5;
   uint32_t  f8;
};

union U2 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const uint16_t  func_29(void);
static float  func_36(int32_t  p_37, uint32_t  p_38);
static int32_t  func_39(const int32_t  p_40, uint32_t  p_41, union U2  p_42, int32_t  p_43);
static union U2  func_46(uint16_t  p_47, int16_t  p_48);
static int16_t  func_49(const int32_t  p_50);
static int32_t  func_64(uint32_t  p_65, float  p_66);
inline static float  func_73(int16_t  p_74, float  p_75);
inline static int16_t  func_76(int32_t  p_77, union U2  p_78, struct S1  p_79, struct S0  p_80);
inline static int32_t  func_97(const uint32_t  p_98, const int32_t  p_99);
inline static uint32_t  func_103(int32_t  p_104, uint32_t  p_105, const struct S1  p_106, uint16_t  p_107, struct S0  p_108);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_29(void)
{ /* block id: 36 */
    const uint32_t l_44 = 0xB0881DDA;
    int32_t l_45 = (-7);
    float l_539 = 0x2.7CAD94p+26;
    float *l_538 = &l_539;
    int32_t *l_540 = &l_45;
    int32_t **l_541 = &l_540;
    const float l_542 = 0x0.1p-1;
    const int32_t l_543 = 0xFD5BAA61;
    (*l_538) = ((float)0x0.61BE36p-27 + (float)((-0x4.Dp+1) > ((float)((float)func_36(((func_39(l_44, l_45, func_46(((((l_45 <= l_45) >= (0xECDC0F1F && (func_49(((int16_t)0 << (int16_t)(((int32_t)((uint32_t)((l_44 || l_44) == l_45) + (uint32_t)1) % (int32_t)l_44) < l_45))) >= l_44))) || 5) != l_45), l_45), l_45) & l_44) < l_44), l_45) + (float)0x2.F903ECp-31) - (float)0xD.9532C6p+44)));
    (*l_541) = l_540;
    (**l_541) = ((**l_541) & ((0U >= (0 <= (**l_541))) || func_39((*l_540), (*l_540), func_46((**l_541), (**l_541)), (**l_541))));
    (*l_538) = (**l_541);
    return l_543;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_36(int32_t  p_37, uint32_t  p_38)
{ /* block id: 306 */
    struct S0 l_522 = {189,1915,0,0xF.DC0AE3p-34,65,0,9477};
    struct S0 *l_521 = &l_522;
    const struct S1 * const l_523 = (void*)0;
    int32_t l_528 = 0;
    int32_t *l_527 = &l_528;
    if (((int16_t)((void*)0 == l_521) << (int16_t)p_38))
    { /* block id: 307 */
        struct S1 l_526 = {4294967295U,{75,2620,1,0x1.9p-1,57,0,8333},0xA051A8EE,1U,0x41B3BE74,4294967290U,8U,3,0x84CA24EB};
        struct S1 *l_525 = &l_526;
        struct S1 **l_524 = &l_525;
        int32_t **l_529 = (void*)0;
        int32_t **l_530 = &l_527;
        (*l_524) = l_523;
        /* statement id: 308 */
        assert (l_525 == 0);
        (*l_530) = l_527;
lbl_535:
        l_527 = &l_528;
        for (l_526.f0 = 0; (l_526.f0 <= 15); l_526.f0++)
        { /* block id: 313 */
            (*l_524) = (void*)0;
            for (l_526.f3 = 0; (l_526.f3 == 21); l_526.f3 += 4)
            { /* block id: 317 */
                if (p_38)
                    goto lbl_535;
            }
        }
    }
    else
    { /* block id: 321 */
        float l_537 = (-0x1.1p+1);
        float *l_536 = &l_537;
        (*l_536) = ((void*)0 == &l_523);
    }
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_39(const int32_t  p_40, uint32_t  p_41, union U2  p_42, int32_t  p_43)
{ /* block id: 303 */
    union U2 l_518 = {-6};
    union U2 *l_517 = &l_518;
    union U2 **l_516 = &l_517;
    (*l_516) = &p_42;
    /* statement id: 304 */
    assert (l_517 == &p_42);
    return l_518.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_46(uint16_t  p_47, int16_t  p_48)
{ /* block id: 300 */
    union U2 l_514 = {0x21E32FFE};
    union U2 *l_513 = &l_514;
    union U2 l_515 = {0};
    l_513 = l_513;
    return l_515;
    /* statement id: 302 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_49(const int32_t  p_50)
{ /* block id: 37 */
    int16_t l_63 = 5;
    union U2 l_81 = {0xF5756627};
    struct S1 l_82 = {0x39888327,{235,26212,2,0x3.F15F1Dp-13,85,1,3300},0x045039A2,4294967287U,0xA13C53D1,4294967295U,0x36DE,-4,0x9A3A768F};
    int32_t l_495 = (-1);
    union U2 * const *l_505 = (void*)0;
    union U2 * const **l_504 = &l_505;
    struct S0 *l_510 = &l_82.f1;
    struct S0 **l_509 = &l_510;
    struct S0 ** const *l_508 = &l_509;
    struct S0 ** const **l_507 = &l_508;
    struct S0 ** const ***l_506 = &l_507;
    float l_512 = 0x1.EE5409p-13;
    float *l_511 = &l_512;
    l_82.f1.f0 = (p_50 == ((((uint16_t)p_50 >> (uint16_t)9) >= (((uint32_t)((uint16_t)(l_63 || func_64(p_50, ((float)(((float)(((((__builtin_clzll(p_50) > 0x1.5p+1) == (((float)func_73((func_76(l_63, l_81, l_82, l_82.f1) ^ l_63), l_82.f3) + (float)l_495) <= p_50)) >= l_82.f1.f0) <= l_82.f4) <= l_82.f1.f1) - (float)0x9.AF0C2Cp-85) >= p_50) + (float)l_63))) << (uint16_t)6) + (uint32_t)p_50) >= l_82.f7)) < p_50));
    (*l_511) = (((float)(l_504 != &l_505) + (float)((void*)0 == l_506)) == ((void*)0 == &l_81));
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_64(uint32_t  p_65, float  p_66)
{ /* block id: 292 */
    union U2 l_497 = {-1};
    union U2 *l_496 = &l_497;
    union U2 **l_498 = &l_496;
    int32_t *l_499 = &l_497.f0;
    union U2 ****l_501 = (void*)0;
    union U2 *****l_500 = &l_501;
    (*l_498) = l_496;
    l_499 = (void*)0;
    /* statement id: 294 */
    assert (l_499 == 0);
    l_500 = l_500;
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_73(int16_t  p_74, float  p_75)
{ /* block id: 286 */
    union U2 l_488 = {-4};
    union U2 *l_487 = &l_488;
    struct S1 l_490 = {0U,{-303,7603,-3,0x3.Ap+1,49,0,1778},0xB5A7793D,0x51B61C2D,4294967295U,4294967295U,0x3381,-0,4294967295U};
    struct S1 *l_489 = &l_490;
    struct S1 **l_491 = (void*)0;
    int32_t *l_492 = &l_488.f0;
    float l_494 = 0x1.0p-1;
    float *l_493 = &l_494;
    l_487 = l_487;
    l_489 = l_489;
    (*l_492) = l_490.f1.f1;
    (*l_493) = (*l_492);
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_76(int32_t  p_77, union U2  p_78, struct S1  p_79, struct S0  p_80)
{ /* block id: 38 */
    const int32_t l_85 = 5;
    const int32_t *l_84 = &l_85;
    const int32_t **l_83 = &l_84;
    float *l_88 = (void*)0;
    float l_90 = 0x7.19D8D7p+22;
    float *l_89 = &l_90;
    int32_t l_94 = (-2);
    int32_t * const l_93 = &l_94;
    int32_t l_109 = 0xCFDD0FD0;
    struct S0 l_113 = {446,34157,-2,0x1.61BCE7p+89,40,1,9784};
    struct S1 l_267 = {0U,{230,28185,-0,-0x1.Ep+1,108,0,8073},0x0C5F0CBE,0x70EFD0CC,0x756E3194,9U,6U,2,0xA4175336};
    struct S1 * const l_266 = &l_267;
    union U2 l_272 = {0x19D67C5E};
    union U2 *l_271 = &l_272;
    union U2 **l_270 = &l_271;
    struct S0 *l_390 = (void*)0;
    struct S0 **l_389 = &l_390;
    struct S0 ***l_388 = &l_389;
    struct S0 ****l_387 = &l_388;
    struct S0 *****l_386 = &l_387;
    struct S1 l_395 = {0x80D751C8,{417,23917,-0,0x2.808DDDp+23,113,0,11257},7U,0x46631219,0U,0x2AE677EC,0x4D9A,-3,9U};
    struct S1 *l_394 = &l_395;
    float *l_403 = &l_90;
    union U2 *l_422 = &l_272;
    union U2 ****l_474 = (void*)0;
    int32_t l_484 = 0xD2EFFF92;
    struct S0 ***l_486 = (void*)0;
    (*l_83) = (void*)0;
    /* statement id: 39 */
    assert (l_84 == 0);
    (*l_89) = ((float)p_80.f6 - (float)p_79.f6);
    if (((uint16_t)p_80.f0 >> (uint16_t)15))
    { /* block id: 41 */
        int32_t *l_96 = &l_94;
        int32_t **l_95 = &l_96;
        (*l_95) = l_93;
    }
    else
    { /* block id: 43 */
        uint16_t l_111 = 0xB50B;
        const struct S1 l_112 = {0x816D3FBE,{316,18531,3,0x3.9p+1,59,1,8573},4U,0x9230FEFE,0x48C15133,0xA3A0A773,1U,3,0x8C46E721};
        struct S1 l_269 = {0x5CF9645D,{-209,31965,-2,0x3.F4BA2Fp-46,119,1,8863},4294967287U,0x1B637EA3,0xBE08290A,0xDDB5E15B,0x4903,2,0x9DB44EA9};
        struct S1 *l_268 = &l_269;
        const union U2 *l_291 = &l_272;
        const union U2 **l_290 = &l_291;
        float * const l_292 = &l_90;
        struct S0 *l_301 = &l_267.f1;
        const int32_t l_315 = 0x4185503A;
        union U2 ****l_371 = (void*)0;
        union U2 *****l_370 = &l_371;
        struct S1 **l_441 = &l_268;
        struct S1 ***l_440 = &l_441;
        int32_t *l_446 = &l_272.f0;
        int32_t l_485 = (-6);
        (*l_93) = (p_79.f5 > func_97(((int16_t)((!(func_103(l_109, (__builtin_ctzl((~l_111)) < (p_80.f4 & 4U)), l_112, ((l_112.f7 > l_112.f1.f1) == (-3)), l_113) <= 0x342E7D5C)) & 0) - (int16_t)l_112.f1.f2), l_112.f4));
        if ((p_77 >= l_112.f5))
        { /* block id: 125 */
            struct S0 l_253 = {-361,44917,0,0x7.3p+1,33,1,6065};
            int32_t *l_258 = &l_94;
            struct S0 **l_294 = (void*)0;
            uint32_t l_309 = 0xC5248648;
            union U2 **l_356 = (void*)0;
            struct S0 ** const *l_377 = &l_294;
            struct S0 ** const **l_376 = &l_377;
            for (p_79.f0 = 6; (p_79.f0 > 12); p_79.f0 += 9)
            { /* block id: 128 */
                float l_251 = 0xD.358026p+38;
                const struct S1 l_252 = {0xE3F3AD76,{459,24036,-4,0x7.891A74p+12,56,0,6687},4294967287U,4294967295U,0x9D7BC268,1U,8U,-1,0x73F10C45};
                (*l_89) = ((float)func_103(p_80.f0, (-(int16_t)func_103(p_79.f7, p_79.f5, l_252, l_112.f0, l_253)), p_79, l_252.f1.f1, p_80) - (float)l_253.f6);
                if (p_77)
                    break;
            }
lbl_310:
            for (l_111 = 0; (l_111 != 5); ++l_111)
            { /* block id: 134 */
                uint16_t l_261 = 0x2EB0;
                (*l_83) = &p_77;
                /* statement id: 135 */
                assert (l_84 == &p_77);
                for (p_79.f2 = 0; (p_79.f2 == 27); p_79.f2 += 3)
                { /* block id: 138 */
                    struct S0 *l_262 = &l_253;
                    struct S0 **l_282 = &l_262;
                    struct S0 ***l_281 = &l_282;
                    struct S0 ****l_280 = &l_281;
                    const int32_t l_293 = 0;
                    l_258 = &p_77;
                    /* statement id: 139 */
                    assert (l_258 == &p_77);
                    if (((int32_t)l_261 % (int32_t)1U))
                    { /* block id: 140 */
                        struct S0 **l_263 = (void*)0;
                        struct S0 **l_264 = &l_262;
                        (*l_264) = l_262;
                        if ((*l_93))
                            continue;
                        (*l_258) = (!p_80.f0);
                        if ((*l_84))
                            break;
                    }
                    else
                    { /* block id: 145 */
                        const union U2 *l_275 = &l_272;
                        const union U2 **l_274 = &l_275;
                        const union U2 ***l_273 = &l_274;
                        l_268 = l_266;
                        /* statement id: 146 */
                        assert (l_268 == &l_267);
                        (*l_273) = l_270;
                        /* statement id: 147 */
                        assert (l_274 == &l_271);
                        (*l_292) = ((*l_84) <= ((float)((float)p_79.f6 - (float)((((((((void*)0 != l_280) < (0x8.499C85p-69 == ((float)((float)((-(float)(((*l_84) > ((float)(((void*)0 != l_290) != ((void*)0 == l_292)) - (float)p_79.f1.f6)) >= l_261)) == p_79.f4) + (float)0x6.9p-1) - (float)l_293))) != p_79.f6) <= 0x0.4p+1) == (**l_83)) != 0xD.2A55D4p-91) >= 0x2.1ADFF8p+52)) - (float)p_79.f1.f2));
                    }
                    (*l_281) = l_294;
                    /* statement id: 150 */
                    assert (l_282 == 0);
                    (*l_93) = (l_293 & (func_97(p_80.f6, p_79.f4) && ((int32_t)((int16_t)p_80.f1 << (int16_t)5) % (int32_t)1U)));
                }
            }
            if (((l_301 != &p_80) & ((void*)0 == l_258)))
            { /* block id: 154 */
                union U2 **l_322 = (void*)0;
                int32_t l_328 = 0;
                struct S1 **l_334 = &l_268;
                if ((((uint16_t)(p_80.f2 && p_79.f0) << (uint16_t)0) & ((int16_t)(*l_258) + (int16_t)p_79.f5)))
                { /* block id: 155 */
                    int32_t l_306 = 7;
                    (*l_93) = l_306;
                    return p_80.f4;
                }
                else
                { /* block id: 158 */
                    union U2 **l_323 = &l_271;
                    int32_t l_329 = 0;
                    if (__builtin_parityll(((int32_t)l_309 - (int32_t)0xA7B3351E)))
                    { /* block id: 159 */
                        (*l_83) = (void*)0;
                        /* statement id: 160 */
                        assert (l_84 == 0);
                    }
                    else
                    { /* block id: 161 */
                        int32_t l_325 = 0xBA95C358;
                        if (p_79.f0)
                            goto lbl_310;
                        (*l_258) = (l_269.f1.f0 & ((p_80.f5 <= ((uint16_t)((int16_t)(-1) - (int16_t)l_315) + (uint16_t)(((p_78.f0 | (((int32_t)(1U && 0x2D4BDB75) - (int32_t)(~(!p_79.f6))) ^ ((uint16_t)(l_322 == l_323) >> (uint16_t)10))) <= (*l_93)) != (*l_93)))) || p_80.f4));
                        l_329 = (+(l_325 > ((float)l_328 + (float)l_325)));
                        (*l_83) = &p_77;
                        /* statement id: 165 */
                        assert (l_84 == &p_77);
                    }
                    for (p_79.f6 = 0; (p_79.f6 < 26); p_79.f6 += 1)
                    { /* block id: 169 */
                        struct S0 **l_332 = (void*)0;
                        struct S0 **l_333 = &l_301;
                        (*l_333) = &p_80;
                        /* statement id: 170 */
                        assert (l_301 == &p_80);
                    }
                    /* facts after for loop */
                    assert (l_301 == &p_80 || l_301 == &l_267.f1);
                    (*l_258) = 8;
                }
                /* facts after branching */
                assert (l_301 == &p_80 || l_301 == &l_267.f1);
                (*l_334) = &l_112;
                /* statement id: 174 */
                assert (l_268 == &l_112);
            }
            else
            { /* block id: 175 */
                uint32_t l_353 = 0xFEFE262E;
                const struct S1 l_362 = {0x0EC12C81,{-454,44135,-3,0xD.CACCCAp-78,84,1,8716},1U,4294967295U,0xE8C22AD4,0xA4AE4061,0x3A26,-3,0x6D5B2996};
                if (((l_258 != l_292) | ((uint16_t)((p_80.f4 > (((uint32_t)(*l_258) - (uint32_t)l_269.f2) && func_103(l_269.f1.f5, l_269.f8, p_79, l_112.f1.f2, p_80))) != p_79.f3) + (uint16_t)0x32B5)))
                { /* block id: 176 */
                    int16_t l_339 = 1;
                    struct S1 **l_359 = &l_268;
                    union U2 ***l_366 = &l_356;
                    union U2 ****l_365 = &l_366;
                    if (((*l_258) > ((((l_112.f5 && 1U) >= l_339) ^ 0x7135) || ((int16_t)((uint32_t)(l_258 != (void*)0) % (uint32_t)p_80.f4) >> (int16_t)(*l_258)))))
                    { /* block id: 177 */
                        int32_t *l_344 = &l_94;
                        union U2 *l_345 = &l_272;
                        (*l_83) = l_344;
                        /* statement id: 178 */
                        assert (l_84 == &l_94);
                        (*l_258) = ((__builtin_popcountl(((*l_258) == ((l_112.f3 != (l_345 == (void*)0)) < 65527U))) || p_79.f1.f1) || ((int16_t)0xC6D1 << (int16_t)9));
                    }
                    else
                    { /* block id: 180 */
                        float l_352 = 0x6.CB437Dp-36;
                        struct S1 **l_355 = &l_268;
                        struct S1 ***l_354 = &l_355;
                        (*l_83) = l_258;
                        /* statement id: 181 */
                        assert (l_84 == &p_77 || l_84 == &l_94);
                        l_269.f1.f0 = (((**l_83) <= (0x2.0p+1 < p_80.f1)) != (((float)(p_79.f7 > (l_339 >= (((float)l_352 - (float)0xB.382D7Fp+43) != (((((p_79.f8 != 0x1.AB9743p+90) > p_80.f3) < l_339) == p_79.f2) >= l_353)))) - (float)(-0x5.1p+1)) <= 0x1.6p+1));
                        (*l_354) = &l_266;
                        /* statement id: 183 */
                        assert (l_355 == &l_266);
                        (*l_93) = (((*l_258) | p_79.f8) >= __builtin_ia32_crc32qi(p_79.f5, (0x371D < (((*l_93) <= (l_356 == (void*)0)) | ((uint16_t)(l_359 == (*l_354)) << (uint16_t)12)))));
                    }
                    /* facts after branching */
                    assert (l_84 == &p_77 || l_84 == &l_94);
                    (*l_93) = func_103((((uint16_t)func_103((*l_258), l_269.f1.f5, l_362, p_80.f0, p_79.f1) >> (uint16_t)4) | (p_79.f1.f1 & ((uint32_t)p_80.f1 % (uint32_t)(p_80.f1 && 1)))), (*l_93), (*l_268), p_79.f1.f1, l_253);
                    (*l_365) = &l_270;
                    /* statement id: 187 */
                    assert (l_366 == &l_270);
                }
                else
                { /* block id: 188 */
                    int32_t **l_369 = &l_258;
                    int32_t ** const *l_368 = &l_369;
                    int32_t ** const **l_367 = &l_368;
                    struct S0 ***l_384 = &l_294;
                    (*l_367) = (void*)0;
                    /* statement id: 189 */
                    assert (l_368 == 0);
                    l_370 = l_370;
                    for (l_269.f0 = (-21); (l_269.f0 >= 31); l_269.f0++)
                    { /* block id: 193 */
                        p_80.f0 = ((l_269.f1.f4 && ((int32_t)0 - (int32_t)p_80.f6)) != (l_376 == (void*)0));
                        (*l_369) = l_258;
                    }
                    p_79.f1.f0 = ((((((p_79.f0 != ((((int32_t)l_269.f1.f6 - (int32_t)((l_362.f1.f4 <= ((p_79.f8 | 0U) | ((int16_t)(__builtin_parity((((void*)0 == &l_93) | ((uint32_t)((void*)0 == l_384) - (uint32_t)0x48E30274))) != 0xF853) - (int16_t)(**l_369)))) <= p_79.f1.f4)) && p_79.f3) != p_79.f1.f0)) & p_79.f1.f4) ^ 0x228F5384) == 1U) == p_78.f0) <= 0x184F);
                }
                /* facts after branching */
                assert (l_84 == &p_77 || l_84 == 0 || l_84 == &l_94);
            }
            /* facts after branching */
            assert (l_84 == &p_77 || l_84 == 0 || l_84 == &l_94);
            assert (l_268 == &l_267 || l_268 == &l_269 || l_268 == &l_112);
            assert (l_301 == &p_80 || l_301 == &l_267.f1);
        }
        else
        { /* block id: 200 */
            uint32_t l_385 = 4294967287U;
            struct S0 *****l_391 = &l_387;
            float *l_404 = &l_90;
            if ((l_385 < l_269.f1.f2))
            { /* block id: 201 */
                l_391 = l_386;
            }
            else
            { /* block id: 203 */
                struct S1 *l_392 = &l_267;
                struct S1 **l_393 = (void*)0;
                int32_t l_396 = 0;
                (*l_292) = l_385;
                l_394 = l_392;
                /* statement id: 205 */
                assert (l_394 == &l_267);
                if (func_103(l_396, ((uint32_t)((p_79.f1.f4 > l_385) && ((((int16_t)((-2) && ((((l_403 == l_404) == (((int16_t)((((uint32_t)(((int16_t)(l_396 || p_79.f6) % (int16_t)(~((int16_t)p_79.f1.f0 >> (int16_t)(*l_93)))) | p_79.f0) - (uint32_t)p_80.f6) <= p_80.f4) | l_112.f0) % (int16_t)p_79.f1.f1) | l_385)) <= p_80.f5) & l_396)) + (int16_t)l_112.f1.f1) && 0xD07E) <= (-1))) % (uint32_t)l_396), p_79, l_111, p_80))
                { /* block id: 206 */
                    int32_t *l_418 = &l_396;
                    int32_t **l_417 = &l_418;
                    int32_t ***l_416 = &l_417;
                    int32_t ****l_415 = &l_416;
                    int32_t *****l_414 = &l_415;
                    struct S1 **l_419 = &l_268;
                    (*l_414) = (void*)0;
                    /* statement id: 207 */
                    assert (l_415 == 0);
                    (*l_419) = &p_79;
                    /* statement id: 208 */
                    assert (l_268 == &p_79);
                    for (l_109 = (-23); (l_109 <= (-6)); l_109 += 8)
                    { /* block id: 211 */
                        (*l_290) = (void*)0;
                        /* statement id: 212 */
                        assert (l_291 == 0);
                        if (p_79.f8)
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_291 == 0 || l_291 == &l_272);
                }
                else
                { /* block id: 215 */
                    (*l_270) = l_422;
                }
                /* facts after branching */
                assert (l_268 == &l_269 || l_268 == &p_79);
                assert (l_291 == 0 || l_291 == &l_272);
                (*l_93) = (((uint16_t)(l_385 || l_396) + (uint16_t)p_79.f8) < __builtin_ia32_crc32qi(l_269.f4, ((int16_t)0 << (int16_t)13)));
            }
            /* facts after branching */
            assert (l_268 == &l_269 || l_268 == &p_79);
            assert (l_291 == 0 || l_291 == &l_272);
            assert (l_394 == &l_267 || l_394 == &l_395);
            (*l_83) = (*l_83);
            for (l_395.f8 = 0; (l_395.f8 >= 30); l_395.f8 += 7)
            { /* block id: 223 */
                struct S1 **l_429 = &l_394;
                (*l_93) = (-1);
                (**l_388) = &p_80;
                /* statement id: 225 */
                assert (l_390 == &p_80);
                (*l_429) = (void*)0;
                /* statement id: 226 */
                assert (l_394 == 0);
                (*l_292) = ((float)p_79.f1.f4 - (float)(p_80.f3 < (l_112.f1.f4 != (p_79.f8 <= 0x0.8190C9p-52))));
            }
            /* facts after for loop */
            assert (l_390 == &p_80 || l_390 == 0);
            assert (l_394 == 0 || l_394 == &l_267 || l_394 == &l_395);
        }
        /* facts after branching */
        assert (l_84 == &p_77 || l_84 == 0 || l_84 == &l_94);
        assert (l_268 == &l_269 || l_268 == &p_79 || l_268 == &l_267 || l_268 == &l_112);
        assert (l_291 == 0 || l_291 == &l_272);
        assert (l_301 == &p_80 || l_301 == &l_267.f1);
        assert (l_390 == &p_80 || l_390 == 0);
        assert (l_394 == 0 || l_394 == &l_267 || l_394 == &l_395);
        if ((l_112.f3 <= ((uint32_t)(((((p_79.f0 < ((uint16_t)(__builtin_clzl(p_79.f8) & p_80.f1) << (uint16_t)7)) <= (((((uint32_t)(*l_93) % (uint32_t)(*l_93)) == (&l_291 != &l_291)) ^ p_80.f6) >= 4294967289U)) & 4U) == p_79.f3) >= l_112.f1.f4) + (uint32_t)p_79.f1.f6)))
        { /* block id: 230 */
            uint32_t l_442 = 4294967294U;
            const struct S1 l_443 = {0x293E5168,{139,9254,-0,-0x1.Ap+1,119,0,7869},8U,0x20E0FE30,4U,0U,0x81C1,-0,1U};
            (*l_83) = &l_315;
            /* statement id: 231 */
            assert (l_84 == &l_315);
            for (l_395.f0 = 29; (l_395.f0 >= 38); l_395.f0 += 6)
            { /* block id: 234 */
                int32_t l_444 = 0;
                if (((void*)0 == l_440))
                { /* block id: 235 */
                    uint16_t l_445 = 0xA48C;
                    if (l_442)
                        break;
                    p_79.f7 = (0xA97B < __builtin_ctzl((l_269.f7 > (p_79.f0 >= ((__builtin_popcountll(p_79.f4) & ((func_103(p_79.f0, p_80.f0, l_443, ((((*l_440) == (*l_440)) && l_444) != p_79.f6), p_80) <= 0x887ACA5F) || (*l_84))) == l_443.f7)))));
                    (*l_83) = (*l_83);
                    if (l_445)
                        continue;
                }
                else
                { /* block id: 240 */
                    if ((*l_93))
                    { /* block id: 241 */
                        l_446 = &p_77;
                        /* statement id: 242 */
                        assert (l_446 == &p_77);
                    }
                    else
                    { /* block id: 243 */
                        (*l_83) = &p_77;
                        /* statement id: 244 */
                        assert (l_84 == &p_77);
                    }
                    (*l_292) = (p_79.f4 != (*l_84));
                }
                if (l_444)
                    break;
            }
            /* facts after for loop */
            assert (l_84 == &p_77 || l_84 == &l_315);
            assert (l_446 == &l_272.f0 || l_446 == &p_77);
        }
        else
        { /* block id: 250 */
            const int32_t l_451 = (-6);
            uint16_t l_454 = 4U;
            const struct S1 l_471 = {8U,{470,38509,0,-0x1.Bp+1,40,0,881},0x82638C48,0xAF52DA61,0x3FE690E7,4294967288U,0x0EB8,-2,0x67B2A463};
            if (((uint16_t)p_80.f0 << (uint16_t)(0xA7D1F243 < (((uint32_t)((((l_451 && ((((int16_t)(*l_93) << (int16_t)((**l_386) != (*l_387))) < __builtin_bswap32(func_97((l_446 != (void*)0), p_80.f0))) <= 0x2484)) == l_451) < (-1)) > 65527U) - (uint32_t)l_454) <= 1))))
            { /* block id: 251 */
                int32_t l_470 = 1;
                (*l_403) = p_79.f1.f4;
                for (l_269.f6 = 0; (l_269.f6 < 30); l_269.f6++)
                { /* block id: 255 */
                    uint32_t l_461 = 0x3D354823;
                    if (l_451)
                    { /* block id: 256 */
                        int32_t l_472 = 1;
                        uint16_t l_473 = 1U;
                        (*l_83) = &p_77;
                        /* statement id: 257 */
                        assert (l_84 == &p_77);
                        (*l_83) = &p_77;
                        if ((*l_446))
                            break;
                        (*l_446) = (((int32_t)0 % (int32_t)(*l_446)) & ((((void*)0 != &p_79) & ((uint16_t)((l_461 == (*l_446)) > p_79.f1.f2) - (uint16_t)((((uint16_t)((uint16_t)(((int16_t)((uint16_t)((func_103(((p_79.f0 >= l_470) < 0x5E9F), p_80.f0, l_471, (*l_93), l_471.f1) ^ (*l_446)) | p_79.f1.f5) % (uint16_t)0x3BA3) - (int16_t)l_472) <= 1U) << (uint16_t)(*l_446)) >> (uint16_t)13) <= 9U) ^ l_472))) <= l_473));
                    }
                    else
                    { /* block id: 261 */
                        union U2 ***l_476 = &l_270;
                        union U2 ****l_475 = &l_476;
                        p_80.f2 = p_80.f0;
                        l_475 = l_474;
                        /* statement id: 263 */
                        assert (l_475 == 0);
                        (*l_83) = (void*)0;
                        /* statement id: 264 */
                        assert (l_84 == 0);
                        (*l_83) = &p_77;
                        /* statement id: 265 */
                        assert (l_84 == &p_77);
                    }
                    /* facts after branching */
                    assert (l_84 == &p_77);
                    for (l_269.f2 = 0; (l_269.f2 < 3); l_269.f2++)
                    { /* block id: 269 */
                        float l_483 = 0x9.66E137p-16;
                        (*l_446) = l_471.f5;
                        if (l_461)
                            continue;
                        (*l_93) = (0 < ((int16_t)(0x0DC0 <= (((int32_t)func_97(l_470, (0xC220 < (p_80.f4 ^ __builtin_clz(l_484)))) + (int32_t)(__builtin_ctzll((*l_446)) | l_461)) && 7)) + (int16_t)l_485));
                    }
                    (*l_89) = (*l_446);
                    (*l_83) = &p_77;
                }
                (*l_83) = (*l_83);
            }
            else
            { /* block id: 278 */
                (*l_83) = &p_77;
                /* statement id: 279 */
                assert (l_84 == &p_77);
            }
        }
        /* facts after branching */
        assert (l_84 == &p_77 || l_84 == 0 || l_84 == &l_94 || l_84 == &l_315);
        assert (l_446 == &l_272.f0 || l_446 == &p_77);
        (*l_387) = l_486;
        /* statement id: 282 */
        assert (l_388 == 0);
    }
    /* facts after branching */
    //assert (l_84 == &p_77 || l_84 == 0 || l_84 == &l_94 || l_84 == dangling);
    assert (l_390 == &p_80 || l_390 == 0);
    assert (l_388 == 0 || l_388 == &l_389);
    assert (l_394 == 0 || l_394 == &l_267 || l_394 == &l_395);
    (*l_83) = (void*)0;
    /* statement id: 284 */
    assert (l_84 == 0);
    return p_80.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_97(const uint32_t  p_98, const int32_t  p_99)
{ /* block id: 87 */
    uint32_t l_193 = 4294967291U;
    struct S0 l_214 = {-157,45152,-0,0x4.74E044p-2,76,1,9583};
    struct S0 *l_213 = &l_214;
    struct S0 **l_212 = &l_213;
    int32_t l_219 = 0x167A4C18;
    if (l_193)
    { /* block id: 88 */
        int32_t l_197 = 0x62C939D4;
        int32_t * const l_196 = &l_197;
        struct S0 **l_227 = &l_213;
        for (l_193 = 0; (l_193 > 51); l_193++)
        { /* block id: 91 */
            const int32_t **l_198 = (void*)0;
            int32_t *l_200 = &l_197;
            int32_t **l_199 = &l_200;
            (*l_199) = l_196;
            (*l_199) = &l_197;
            (*l_196) = __builtin_ctz((*l_196));
        }
        if ((*l_196))
        { /* block id: 96 */
            int32_t *l_211 = &l_197;
            int32_t **l_210 = &l_211;
            struct S0 * const **l_215 = (void*)0;
            const struct S0 *l_218 = &l_214;
            const struct S0 **l_217 = &l_218;
            const struct S0 ***l_216 = &l_217;
            for (l_197 = 11; (l_197 > 25); l_197 += 3)
            { /* block id: 99 */
                struct S0 **l_204 = (void*)0;
                struct S0 *** const l_203 = &l_204;
                struct S0 ** const **l_205 = (void*)0;
                struct S0 ****l_206 = (void*)0;
                struct S0 ***l_208 = (void*)0;
                struct S0 ****l_207 = &l_208;
                int32_t l_209 = (-1);
                (*l_207) = l_203;
                /* statement id: 100 */
                assert (l_208 == &l_204);
                return l_209;
            }
            (*l_210) = &l_197;
            (*l_216) = l_212;
            /* statement id: 104 */
            assert (l_217 == &l_213);
            (*l_196) = l_219;
        }
        else
        { /* block id: 106 */
            const struct S1 l_222 = {4294967287U,{-286,21203,4,-0x1.3p-1,30,1,8063},1U,1U,4U,1U,8U,1,1U};
            float l_229 = 0xA.A253C7p-69;
            float *l_228 = &l_229;
            (*l_228) = (((float)(func_103(p_98, l_214.f1, l_222, ((uint32_t)((uint16_t)(p_99 && ((void*)0 != l_227)) - (uint16_t)1U) + (uint32_t)((void*)0 != &l_227)), l_222.f1) > 0xF.CB65B9p-54) + (float)(*l_196)) <= l_222.f0);
        }
        return p_98;
    }
    else
    { /* block id: 110 */
        int32_t l_237 = 1;
        int32_t *l_236 = &l_237;
        int32_t **l_235 = &l_236;
        struct S0 *** const l_238 = &l_212;
        for (l_219 = 1; (l_219 >= (-30)); l_219 -= 1)
        { /* block id: 113 */
            int32_t **l_234 = (void*)0;
            if (p_98)
                break;
            for (l_193 = (-10); (l_193 >= 4); l_193++)
            { /* block id: 117 */
                uint16_t l_243 = 0x77FA;
                float l_245 = 0x1.D4CE20p+40;
                float *l_244 = &l_245;
                if (p_98)
                    break;
                (*l_244) = ((l_234 != l_235) > (((((void*)0 == l_238) <= p_98) == 0x2.7F40BFp+56) < (((float)l_214.f5 + (float)((float)(p_99 != (((l_243 != 0xB.49664Fp-59) > (*l_236)) >= 0xC.8FBE2Ep+58)) - (float)0x3.178032p+6)) <= p_99)));
            }
        }
    }
    return l_214.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_103(int32_t  p_104, uint32_t  p_105, const struct S1  p_106, uint16_t  p_107, struct S0  p_108)
{ /* block id: 44 */
    union U2 l_115 = {-6};
    union U2 *l_114 = &l_115;
    int32_t *l_116 = (void*)0;
    int32_t *l_117 = &l_115.f0;
    int32_t *l_118 = &l_115.f0;
    int32_t l_119 = 3;
    struct S0 l_157 = {205,14629,0,-0x1.Dp+1,63,0,2267};
    struct S0 * const l_156 = &l_157;
    uint16_t l_173 = 0x8A96;
    union U2 * const *l_188 = &l_114;
    union U2 * const **l_187 = &l_188;
    union U2 **l_191 = (void*)0;
    union U2 **l_192 = &l_114;
    l_114 = l_114;
    l_119 = l_115.f0;
    for (l_115.f0 = 0; (l_115.f0 > 13); l_115.f0++)
    { /* block id: 49 */
        const float l_125 = 0xF.A8AB26p-42;
        const float *l_124 = &l_125;
        union U2 *l_148 = &l_115;
        int32_t l_163 = 0x1E9D581D;
        int32_t * const *l_181 = &l_117;
        int32_t *l_189 = (void*)0;
        int32_t *l_190 = &l_119;
        if (((int16_t)((l_117 != l_124) <= (&l_119 == (void*)0)) >> (int16_t)6))
        { /* block id: 50 */
            int32_t **l_126 = (void*)0;
            int32_t **l_127 = &l_118;
            const uint32_t l_154 = 0xF6C93ECD;
            union U2 ***l_161 = (void*)0;
            float l_177 = 0x1.378A6Bp-24;
            float *l_176 = &l_177;
            (*l_127) = &l_119;
            /* statement id: 51 */
            assert (l_118 == &l_119);
            if (p_106.f5)
                continue;
            for (p_105 = 23; (p_105 <= 33); ++p_105)
            { /* block id: 55 */
                uint32_t l_132 = 0x7B369A1E;
                int32_t *l_160 = (void*)0;
                float l_168 = 0xC.CFDDCEp+50;
                float *l_167 = &l_168;
            }
            (*l_176) = ((((l_173 == 0x8.FAF8E6p+35) < ((float)(p_106.f1.f0 == l_163) - (float)0x2.ACA7BDp-6)) > (*l_118)) >= (p_108.f5 < (*l_117)));
        }
        else
        { /* block id: 80 */
            int32_t *l_182 = &l_163;
            (*l_182) = ((int32_t)(~(l_181 != &l_118)) - (int32_t)(**l_181));
        }
        (*l_190) = (((__builtin_bswap32(p_106.f3) || ((void*)0 != &p_108)) < ((int16_t)((0xF965 <= (*l_117)) != ((uint32_t)(**l_181) + (uint32_t)(l_187 != (void*)0))) >> (int16_t)11)) || 1);
    }
    /* facts after for loop */
    assert (l_118 == &l_119 || l_118 == &l_115.f0);
    (*l_192) = (**l_187);
    return p_106.f1.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 119
   depth: 1, occurrence: 2
   depth: 2, occurrence: 7
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 21
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 90

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 213
   depth: 2, occurrence: 27
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 21, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 158

XXX times a variable address is taken: 164
XXX times a pointer is dereferenced on RHS: 64
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 14
XXX times a pointer is dereferenced on LHS: 93
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 285

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 165
   level: 2, occurrence: 30
   level: 3, occurrence: 2
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 93
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 25.3
XXX average alias set size: 1.16

XXX times a non-volatile is read: 593
XXX times a non-volatile is write: 232
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 170
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 16
   depth: 2, occurrence: 26
   depth: 3, occurrence: 27
   depth: 4, occurrence: 30
   depth: 5, occurrence: 36

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

