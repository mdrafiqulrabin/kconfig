/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2006917728
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   float  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
inline static int32_t * func_34(int32_t * p_35, int32_t  p_36, int32_t  p_37, struct S0  p_38, int32_t * p_39);
inline static int32_t * func_40(uint32_t  p_41, uint32_t  p_42, const float  p_43, int32_t * p_44);
inline static const struct S0  func_58(int16_t  p_59);
static float  func_62(int32_t * p_63, int32_t  p_64);
static int32_t * func_65(float  p_66, const int32_t * const  p_67, struct S0  p_68, int32_t * p_69);
static const float  func_70(int32_t  p_71, int32_t * p_72, int32_t * p_73, uint32_t  p_74, uint16_t  p_75);
static int32_t * func_79(int32_t * p_80);
inline static int16_t  func_83(int32_t  p_84, int32_t  p_85, float  p_86, int32_t * p_87);
static int32_t  func_88(int32_t * p_89, const uint32_t  p_90, int32_t * p_91, uint32_t  p_92, int32_t * p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    float l_32 = 0xE.83C67Ep-7;
    int32_t l_33 = 0xF3F6085E;
    float l_384 = 0x0.88869Dp+86;
    int32_t l_385 = 0x646FA48E;
    struct S0 l_386 = {4U,0x7.287291p+74,0x52FFEF78};
    int32_t *l_442 = &l_385;
    float *l_449 = (void*)0;
    float **l_448 = &l_449;
    float ***l_447 = &l_448;
    float ****l_446 = &l_447;
    float l_464 = 0x7.D14653p+11;
    uint32_t l_467 = 1U;
    uint32_t l_469 = 5U;
    uint32_t l_470 = 0x3FE9918F;
    int32_t *l_471 = &l_385;
    uint32_t l_472 = 0x2B415666;
    int32_t l_473 = 0xD1182DDD;
    uint32_t l_474 = 1U;
    if (l_33)
    { /* block id: 37 */
        uint32_t l_46 = 0xC3F30B91;
        int32_t *l_409 = &l_385;
        int32_t **l_408 = &l_409;
        (*l_408) = func_34(func_40((+((l_33 || l_46) | ((int16_t)(l_33 != ((uint16_t)((((int32_t)(-(uint32_t)((uint16_t)((((uint32_t)(l_33 || ((((l_33 >= l_33) && l_46) & 0x9690B281) < l_33)) + (uint32_t)l_46) && l_46) ^ 65535U) << (uint16_t)12)) % (int32_t)l_46) == l_33) >= l_46) + (uint16_t)l_46)) << (int16_t)0))), l_46, l_46, &l_33), l_385, l_46, l_386, &l_385);
        /* statement id: 265 */
        assert (l_409 == 0);
    }
    else
    { /* block id: 266 */
        uint32_t l_412 = 0x0B09B5B2;
        int32_t *l_422 = &l_385;
        int32_t **l_424 = (void*)0;
        int32_t **l_425 = &l_422;
        int32_t l_435 = 0x71649D72;
        int32_t *l_441 = &l_33;
        for (l_386.f0 = 0; (l_386.f0 <= 14); l_386.f0 += 1)
        { /* block id: 269 */
            float l_418 = 0x3.0p+1;
            int32_t l_421 = 1;
            int32_t *l_423 = &l_33;
            l_423 = func_40(l_412, l_386.f0, ((!(((float)l_33 + (float)(((__builtin_parityl(((uint16_t)0xAED4 + (uint16_t)l_386.f2)) == l_418) != (((float)l_385 - (float)l_33) < 0x0.Ep+1)) == l_421)) >= l_412)) >= l_386.f2), l_422);
            /* statement id: 270 */
            assert (l_423 == 0 || l_423 == &l_385);
        }
        (*l_425) = l_422;
        for (l_386.f2 = 0; (l_386.f2 < 22); ++l_386.f2)
        { /* block id: 275 */
            int32_t *l_428 = &l_33;
            int32_t ***l_439 = &l_424;
            float *l_440 = &l_384;
            (*l_440) = ((func_88(func_79(l_428), ((uint16_t)(((int32_t)(*l_428) - (int32_t)((uint16_t)(((__builtin_clzl(((*l_428) > ((l_435 >= 0) == ((int16_t)(((-(uint32_t)(((l_439 != (void*)0) & (&l_422 == (*l_439))) != 0x31ED)) || 4294967295U) < (**l_425)) << (int16_t)(*l_428))))) | 0) <= (*l_428)) < l_386.f0) << (uint16_t)6)) || (*l_428)) << (uint16_t)4), l_428, l_385, (*l_425)) < 0x7.59FF1Fp+10) >= l_385);
        }
        (*l_425) = l_441;
        /* statement id: 278 */
        assert (l_422 == &l_33);
    }
    (*l_442) = (0x6B748E91 == (l_385 || l_386.f2));
    (*l_442) = ((__builtin_clz(((int32_t)(!(l_446 != &l_447)) - (int32_t)(((int32_t)1 - (int32_t)func_88(&l_33, ((uint16_t)((*l_442) == (((int32_t)((uint16_t)1U >> (uint16_t)(*l_442)) + (int32_t)((((((((((__builtin_clz((*l_442)) != (*l_442)) == (*l_442)) == 0xEE74D68A) & (*l_442)) >= 0x597471B3) == (*l_442)) != (*l_442)) >= (*l_442)) == (*l_442)) && (*l_442))) & (-1))) >> (uint16_t)(*l_442)), &l_33, (*l_442), &l_385)) ^ (*l_442)))) != 0x3.B7C8B6p-68) >= (*l_442));
    (*l_471) = ((((int32_t)func_88(&l_385, (((int16_t)(*l_442) << (int16_t)(*l_442)) == ((uint16_t)(*l_442) << (uint16_t)((((*l_442) || ((int16_t)(((l_467 < ((0x92D643A8 && (*l_442)) ^ (~((*l_442) && (*l_442))))) > l_469) == (*l_442)) + (int16_t)0x0554)) <= (*l_442)) <= l_470))), l_471, l_472, &l_385) + (int32_t)l_473) != 7) || 0x52DCBE07);
    return l_474;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_34(int32_t * p_35, int32_t  p_36, int32_t  p_37, struct S0  p_38, int32_t * p_39)
{ /* block id: 252 */
    float **l_387 = (void*)0;
    int32_t *l_395 = (void*)0;
    int32_t **l_394 = &l_395;
    int32_t ***l_393 = &l_394;
    int32_t ****l_392 = &l_393;
    int32_t l_398 = 0xE83303B9;
    int32_t *l_405 = &l_398;
    int32_t *l_406 = &l_398;
    int32_t *l_407 = (void*)0;
    (*p_39) = (*p_39);
    if (((p_37 & (l_387 == l_387)) > ((((int16_t)((int32_t)((l_392 != (void*)0) != ((int16_t)((**l_393) == (**l_393)) << (int16_t)13)) + (int32_t)(1U ^ ((((void*)0 != &p_39) ^ 0x0510) & p_38.f0))) - (int16_t)1U) == l_398) < p_36)))
    { /* block id: 254 */
        struct S0 l_400 = {65534U,0xF.F225DDp-89,0};
        struct S0 *l_399 = &l_400;
        (*l_399) = p_38;
        (*p_39) = (*p_39);
    }
    else
    { /* block id: 257 */
        for (p_38.f2 = (-6); (p_38.f2 >= (-24)); p_38.f2 -= 9)
        { /* block id: 260 */
            float l_404 = (-0x7.4p-1);
            float *l_403 = &l_404;
            (*l_403) = ((void*)0 == &l_393);
        }
    }
    return l_407;
    /* statement id: 264 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(uint32_t  p_41, uint32_t  p_42, const float  p_43, int32_t * p_44)
{ /* block id: 38 */
    struct S0 l_298 = {65535U,-0x1.7p-1,0xBF33B006};
    struct S0 *l_297 = &l_298;
    int32_t *l_307 = (void*)0;
    uint16_t l_311 = 0U;
    (*l_297) = func_58(((void*)0 != p_44));
    if (((int16_t)(((uint16_t)0x8AB4 >> (uint16_t)p_42) ^ l_298.f2) >> (int16_t)((uint16_t)0x5B81 % (uint16_t)((((uint32_t)p_41 % (uint32_t)l_298.f0) == p_41) || l_298.f2))))
    { /* block id: 207 */
        int32_t **l_309 = &l_307;
        int32_t l_310 = 0xEFD678DB;
        (*l_309) = l_307;
        (*l_297) = func_58(p_41);
        if (l_310)
        { /* block id: 210 */
            float *l_312 = (void*)0;
            float *l_313 = &l_298.f1;
            (*l_309) = func_65(func_62(p_44, l_311), l_307, (*l_297), l_307);
            (*l_313) = p_42;
            (*p_44) = func_88(l_313, p_41, p_44, p_41, p_44);
        }
        else
        { /* block id: 214 */
            (*p_44) = l_310;
            (*l_309) = func_65(p_41, l_307, (*l_297), p_44);
            /* statement id: 216 */
            //assert (l_307 == &l_33 || l_307 == &l_385);
        }
        /* facts after branching */
        //assert (l_307 == &l_33 || l_307 == 0 || l_307 == &l_385);
    }
    else
    { /* block id: 218 */
        uint32_t l_316 = 0x924ABB9B;
        float *l_367 = &l_298.f1;
        float **l_366 = &l_367;
        float *** const l_365 = &l_366;
        float *** const *l_364 = &l_365;
        int32_t l_368 = 1;
        struct S0 l_369 = {1U,0x0.294B83p+12,0x0D329E78};
        int32_t **l_382 = (void*)0;
        int32_t **l_383 = &l_307;
        if ((*p_44))
        { /* block id: 219 */
            int32_t l_315 = 0x10380823;
            int32_t *l_314 = &l_315;
            return p_44;
            /* statement id: 220 */
            //assert (func_40_rv == &l_33 || func_40_rv == &l_385);
        }
        else
        { /* block id: 221 */
            uint16_t l_318 = 7U;
            int32_t l_328 = 0xE5335BF8;
            int32_t *l_327 = &l_328;
            int32_t **l_370 = &l_307;
            if ((p_42 < (p_42 <= p_41)))
            { /* block id: 222 */
                int32_t l_317 = 2;
                (*p_44) = (((l_316 | l_316) || l_317) ^ (1 || l_318));
            }
            else
            { /* block id: 224 */
                (*p_44) = 0x8A6C8DED;
            }
            for (l_311 = 0; (l_311 >= 24); ++l_311)
            { /* block id: 229 */
                int16_t l_344 = 0x43B3;
                if (((uint16_t)(((uint16_t)4U << (uint16_t)9) || ((p_41 | __builtin_ffsl(p_41)) ^ (*p_44))) - (uint16_t)((uint16_t)p_42 << (uint16_t)11)))
                { /* block id: 230 */
                    return l_307;
                    /* statement id: 231 */
                    //assert (func_40_rv == 0);
                }
                else
                { /* block id: 232 */
                    float l_329 = 0x3.7p-1;
                    int32_t l_336 = 3;
                    float l_357 = 0x7.Bp-1;
                    if (l_298.f0)
                        break;
                    for (l_328 = (-12); (l_328 > (-17)); l_328 -= 7)
                    { /* block id: 236 */
                        uint16_t l_343 = 65535U;
                        int32_t l_355 = 0xACA4354A;
                        int32_t *l_356 = (void*)0;
                        float *l_359 = &l_329;
                        (*p_44) = (((uint16_t)((int32_t)l_336 + (int32_t)(func_83((*l_327), (((uint16_t)(((uint16_t)((uint16_t)((l_343 && l_316) ^ (l_344 || (*p_44))) << (uint16_t)0) >> (uint16_t)((uint32_t)(((int16_t)((int16_t)(((int16_t)__builtin_popcountl((l_316 != ((int16_t)((func_88(p_44, l_343, p_44, l_343, p_44) == p_41) <= 0xE941) << (int16_t)4))) >> (int16_t)7) < p_41) - (int16_t)l_355) >> (int16_t)2) || p_42) % (uint32_t)(*l_327))) >= l_343) - (uint16_t)l_355) | (*l_327)), l_343, l_356) > (*p_44))) >> (uint16_t)l_316) < p_42);
                        (*l_359) = (((-(float)(-0x1.5p+1)) >= (p_42 != (0x6.F0C47Cp+0 == p_41))) != (__builtin_bswap64((p_42 != 1)) < p_41));
                    }
                    l_368 = ((!l_316) < (((*p_44) > p_41) <= (p_42 <= ((uint16_t)(func_83((((0x4248C0B1 != ((*p_44) > ((((*p_44) && (*l_327)) != (!(((void*)0 != l_364) > (*l_327)))) == l_344))) | p_42) == l_316), p_42, l_336, &l_336) > 0x2C29) >> (uint16_t)p_42))));
                    (*l_327) = (0x55A3 && __builtin_popcountl(p_42));
                }
                (*l_297) = (*l_297);
            }
            (*l_370) = func_65(l_316, l_307, l_369, &l_368);
            /* statement id: 245 */
            assert (l_307 == &l_368);
            (****l_364) = (p_42 == ((float)func_70(func_83((func_88(l_307, (((uint16_t)(l_316 & ((__builtin_ctz(((1U & __builtin_ctzll(((*p_44) <= ((*p_44) >= (*l_307))))) || (((int32_t)(!((uint16_t)4U << (uint16_t)(*l_327))) + (int32_t)0x264F0F1C) == 2U))) >= 4294967287U) > l_369.f2)) << (uint16_t)8) == 65535U), p_44, (*l_307), p_44) >= (*l_307)), (*l_327), p_42, p_44), l_307, p_44, (**l_370), p_42) - (float)0x1.3902DAp+58));
        }
        /* facts after branching */
        assert (l_307 == &l_368);
        (*l_383) = p_44;
        /* statement id: 248 */
        //assert (l_307 == &l_33 || l_307 == &l_385);
        l_307 = l_307;
    }
    /* facts after branching */
    //assert (l_307 == &l_33 || l_307 == 0 || l_307 == &l_385);
    return l_307;
    /* statement id: 251 */
    //assert (func_40_rv == &l_33 || func_40_rv == 0 || func_40_rv == &l_385);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S0  func_58(int16_t  p_59)
{ /* block id: 39 */
    float l_76 = 0x7.FCE934p-23;
    int32_t l_78 = (-5);
    int32_t *l_77 = &l_78;
    struct S0 l_229 = {0xB94B,0x7.8FB196p-53,0xA6E04B37};
    float *l_296 = &l_76;
    (*l_296) = ((((0x0.Dp-1 != ((((float)func_62(func_65((func_70(p_59, l_77, func_79(&l_78), (__builtin_ctz((*l_77)) >= (((int16_t)func_83(func_88(&l_78, (*l_77), &l_78, p_59, &l_78), (*l_77), p_59, &l_78) % (int16_t)p_59) < (*l_77))), (*l_77)) <= (*l_77)), &l_78, l_229, &l_78), p_59) - (float)p_59) < 0xD.8EC8C7p+7) >= 0x7.5p-1)) > p_59) >= 0x1.Ep-1) == p_59);
    return l_229;
}


/* ------------------------------------------ */
/* 
 * reads : l_33 l_385
 * writes: l_33 l_385
 */
static float  func_62(int32_t * p_63, int32_t  p_64)
{ /* block id: 147 */
    int32_t l_237 = 1;
    int32_t *l_236 = &l_237;
    struct S0 l_238 = {0xEE31,0xC.068C90p-62,8};
    int32_t **l_239 = (void*)0;
    int32_t **l_240 = &l_236;
    struct S0 *l_248 = &l_238;
    struct S0 ** const l_247 = &l_248;
    (*l_240) = func_65((l_236 != &l_237), &l_237, l_238, &l_237);
    if ((*p_63))
    { /* block id: 149 */
        int32_t *l_246 = &l_237;
        float *l_268 = (void*)0;
        float *l_269 = &l_238.f1;
        (*l_240) = func_79(p_63);
        /* statement id: 150 */
        //assert (l_236 == &l_78 || l_236 == &l_33 || l_236 == &l_385);
        for (p_64 = 12; (p_64 == (-17)); p_64 -= 4)
        { /* block id: 153 */
            int32_t l_249 = (-3);
            (*l_236) = (p_64 != 1U);
            for (l_238.f0 = 6; (l_238.f0 < 26); l_238.f0++)
            { /* block id: 157 */
                int32_t *l_245 = &l_237;
                struct S0 l_258 = {65535U,0x1.0311DDp-83,-1};
                l_246 = l_245;
                if ((((void*)0 == l_247) && (((func_83(l_249, (*l_246), ((float)((float)((float)(p_64 <= p_64) + (float)((float)0x9.5B47ACp-39 - (float)(**l_240))) + (float)0xE.170816p+57) - (float)p_64), p_63) != 0x0B29F1C3) > (*l_246)) ^ 0xC3C31468)))
                { /* block id: 159 */
                    struct S0 l_259 = {0U,-0x9.Bp+1,0x2CE760C5};
                    l_259 = l_258;
                    (*l_245) = func_83(((l_249 >= ((0 != ((int32_t)(*l_246) - (int32_t)((uint16_t)((3 || (((int16_t)0x0B7D % (int16_t)(*l_245)) <= func_83(p_64, p_64, (*l_246), &l_249))) == 0x6D34CFEF) + (uint16_t)7U))) && 1)) && p_64), p_64, p_64, p_63);
                    for (l_258.f2 = 0; (l_258.f2 != (-3)); l_258.f2 -= 1)
                    { /* block id: 164 */
                        return p_64;
                    }
                }
                else
                { /* block id: 167 */
                    if ((*p_63))
                        break;
                    (*l_245) = (__builtin_popcount(p_64) >= (-0x1.9p+1));
                }
            }
        }
        (*l_269) = ((p_64 == p_64) <= __builtin_ctzll(p_64));
        (*l_240) = l_246;
        /* statement id: 174 */
        assert (l_236 == &l_237);
    }
    else
    { /* block id: 175 */
        uint16_t l_270 = 5U;
        int32_t *l_271 = &l_237;
        (*l_271) = func_83(l_270, p_64, ((p_64 > p_64) > p_64), l_271);
lbl_295:
        if ((-(int32_t)(*p_63)))
        { /* block id: 177 */
            int32_t ***l_273 = &l_239;
            int32_t * const **l_275 = (void*)0;
            int32_t * const ***l_274 = &l_275;
            float *l_276 = &l_238.f1;
            (*l_274) = l_273;
            /* statement id: 178 */
            assert (l_275 == &l_239);
            (*l_276) = (*l_271);
            for (p_64 = 0; (p_64 <= 26); ++p_64)
            { /* block id: 182 */
                float * const *l_285 = &l_276;
                float * const **l_284 = &l_285;
                float * const ***l_283 = &l_284;
                if ((*p_63))
                { /* block id: 183 */
                    float **l_280 = &l_276;
                    float ***l_279 = &l_280;
                    (*l_279) = &l_276;
                    (*l_240) = (*l_240);
                    (*l_247) = (*l_247);
                    (*p_63) = (*p_63);
                }
                else
                { /* block id: 188 */
                    float * const **l_282 = (void*)0;
                    float * const ***l_281 = &l_282;
                    l_283 = l_281;
                    /* statement id: 189 */
                    assert (l_283 == &l_282);
                    (*l_248) = (**l_247);
                    p_63 = l_271;
                    /* statement id: 191 */
                    assert (p_63 == &l_237);
                }
                /* facts after branching */
                //assert (l_283 == dangling || l_283 == &l_284);
                (***l_284) = ((*l_284) == &l_276);
            }
            (*l_240) = l_271;
        }
        else
        { /* block id: 196 */
            struct S0 l_286 = {0xDFD0,0xD.E866A5p+31,1};
            float *l_294 = &l_238.f1;
            (*l_248) = l_286;
            (*l_294) = ((float)((+(0x1.5p+1 < (p_64 == (p_64 > ((((p_64 <= ((**l_240) != p_64)) <= (*l_271)) != p_64) != (((float)((float)(((p_64 >= (-0x1.1p-1)) != (**l_240)) > (*l_271)) + (float)(**l_240)) + (float)0x0.7p+1) < l_286.f0)))))) >= (**l_240)) + (float)(-0x1.1p-1));
        }
        p_63 = l_271;
        /* statement id: 200 */
        assert (p_63 == &l_237);
        if (l_237)
            goto lbl_295;
    }
    /* facts after branching */
    //assert (p_63 == &l_237 || p_63 == &l_78 || p_63 == &l_33 || p_63 == &l_385);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_65(float  p_66, const int32_t * const  p_67, struct S0  p_68, int32_t * p_69)
{ /* block id: 140 */
    int32_t l_235 = 0;
    int32_t *l_234 = &l_235;
    for (p_68.f0 = (-22); (p_68.f0 < 17); p_68.f0 += 1)
    { /* block id: 143 */
        int32_t *l_233 = (void*)0;
        int32_t **l_232 = &l_233;
        (*l_232) = p_69;
        /* statement id: 144 */
        //assert (l_233 == &l_78 || l_233 == &l_237 || l_233 == 0 || l_233 == &l_33 || l_233 == &l_368 || l_233 == &l_385);
    }
    return p_69;
    /* statement id: 146 */
    //assert (func_65_rv == &l_78 || func_65_rv == &l_237 || func_65_rv == 0 || func_65_rv == &l_33 || func_65_rv == &l_368 || func_65_rv == &l_385);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_70(int32_t  p_71, int32_t * p_72, int32_t * p_73, uint32_t  p_74, uint16_t  p_75)
{ /* block id: 137 */
    struct S0 l_227 = {65535U,0xD.3E24EAp-67,5};
    struct S0 *l_226 = &l_227;
    struct S0 **l_228 = &l_226;
    (*l_228) = l_226;
    return l_227.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_79(int32_t * p_80)
{ /* block id: 40 */
    return p_80;
    /* statement id: 41 */
    //assert (func_79_rv == &l_78 || func_79_rv == &l_103 || func_79_rv == &l_108 || func_79_rv == 0 || func_79_rv == &l_33 || func_79_rv == &l_298.f1 || func_79_rv == &l_368 || func_79_rv == &l_385);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_83(int32_t  p_84, int32_t  p_85, float  p_86, int32_t * p_87)
{ /* block id: 134 */
    const int32_t l_221 = 0x24557DD3;
    float l_225 = 0x1.8p-1;
    float *l_224 = &l_225;
    (*l_224) = ((float)(+p_84) - (float)((l_221 != ((float)l_221 - (float)(p_84 == l_221))) >= 0x1.D31AF4p-0));
    return l_221;
}


/* ------------------------------------------ */
/* 
 * reads : l_33 l_385
 * writes:
 */
static int32_t  func_88(int32_t * p_89, const uint32_t  p_90, int32_t * p_91, uint32_t  p_92, int32_t * p_93)
{ /* block id: 42 */
    float l_96 = 0x1.Fp-1;
    struct S0 l_99 = {0x4115,0x5.5p+1,0xC4EFF443};
    int32_t l_108 = 1;
    int32_t l_167 = 0x832032B9;
    int32_t *l_172 = &l_167;
    int32_t **l_171 = &l_172;
    int32_t ** const *l_170 = &l_171;
    for (p_92 = (-1); (p_92 >= 24); p_92 += 8)
    { /* block id: 45 */
        struct S0 l_97 = {65530U,0x7.C80BFDp-31,1};
        int32_t *l_159 = (void*)0;
        int32_t *l_160 = &l_108;
        int32_t ***l_202 = &l_171;
        int32_t ****l_201 = &l_202;
        if ((*p_91))
        { /* block id: 46 */
            return p_90;
        }
        else
        { /* block id: 48 */
            uint32_t l_105 = 0x39E6D594;
            const struct S0 l_116 = {0xC6A4,0x6.312257p+29,0x99C2354C};
            int32_t l_123 = 0x92DDE99E;
            float *l_135 = &l_97.f1;
            int32_t *l_151 = (void*)0;
            int32_t **l_150 = &l_151;
            int32_t ***l_149 = &l_150;
            if (__builtin_bswap32(p_92))
            { /* block id: 49 */
                struct S0 *l_98 = &l_97;
                int32_t *l_109 = &l_108;
                (*l_98) = l_97;
                (*l_98) = l_99;
                for (l_99.f2 = 0; (l_99.f2 < 16); l_99.f2 += 9)
                { /* block id: 54 */
                    int32_t l_103 = 0x16A1EA56;
                    int32_t *l_102 = &l_103;
                    int32_t **l_104 = &l_102;
                    (*l_104) = func_79(l_102);
                    (*l_104) = func_79(p_89);
                    /* statement id: 56 */
                    //assert (l_102 == &l_78 || l_102 == &l_298.f1 || l_102 == &l_33 || l_102 == &l_368 || l_102 == &l_385);
                    if (l_105)
                    { /* block id: 57 */
                        l_108 = ((float)0x5.8E5B49p-42 + (float)0x0.6p-1);
                        (*l_104) = l_109;
                        /* statement id: 59 */
                        assert (l_102 == &l_108);
                    }
                    else
                    { /* block id: 60 */
                        int16_t l_114 = 0xB14A;
                        float *l_115 = &l_99.f1;
                        (*l_115) = ((float)0x0.CFCE32p-0 + (float)((float)p_90 - (float)l_114));
                        (*l_98) = l_116;
                        if ((*p_89))
                            break;
                        (*l_109) = ((p_92 < ((__builtin_popcountll(((((-1) < p_90) > (*p_91)) && ((int16_t)((*p_91) || ((int16_t)((uint16_t)1U >> (uint16_t)l_108) - (int16_t)p_92)) >> (int16_t)10))) && (*p_93)) >= l_123)) && (**l_104));
                    }
                    /* facts after branching */
                    //assert (l_102 == &l_78 || l_102 == &l_108 || l_102 == &l_298.f1 || l_102 == &l_33 || l_102 == &l_368 || l_102 == &l_385);
                }
                (*l_98) = l_116;
            }
            else
            { /* block id: 68 */
                float l_126 = 0x2.DE593Fp+71;
                struct S0 *l_130 = (void*)0;
                const int32_t l_140 = 0xA75F9311;
                int32_t *l_141 = &l_108;
                for (l_97.f2 = 5; (l_97.f2 <= (-19)); --l_97.f2)
                { /* block id: 71 */
                    int32_t *l_127 = &l_108;
                    if ((*p_91))
                        break;
                    (*l_127) = ((void*)0 != &p_93);
                }
                if (((uint16_t)((((void*)0 == l_130) == ((uint16_t)(l_108 != p_92) << (uint16_t)p_90)) && ((int32_t)(((((l_97.f2 & (((l_135 == (void*)0) >= ((int16_t)((int16_t)(((l_116.f2 <= 0x16E0) && l_140) || l_116.f2) + (int16_t)p_92) + (int16_t)p_90)) == 0x2238)) || l_97.f2) != 0x22DE) == 0x7CC9) | p_92) + (int32_t)3)) >> (uint16_t)1))
                { /* block id: 75 */
                    struct S0 *l_142 = (void*)0;
                    struct S0 **l_143 = &l_142;
                    l_141 = p_91;
                    /* statement id: 76 */
                    //assert (l_141 == &l_78 || l_141 == &l_33 || l_141 == &l_385);
                    (*l_143) = l_142;
                    for (l_99.f2 = 10; (l_99.f2 >= (-8)); --l_99.f2)
                    { /* block id: 80 */
                        int32_t **l_146 = &l_141;
                        (*l_146) = func_79(p_89);
                        (*l_135) = p_90;
                    }
                    /* facts after for loop */
                    //assert (l_141 == &l_78 || l_141 == &l_298.f1 || l_141 == &l_33 || l_141 == &l_368 || l_141 == &l_385);
                }
                else
                { /* block id: 84 */
                    struct S0 *l_147 = &l_99;
                    int32_t ** const *l_153 = &l_150;
                    if (((void*)0 == l_147))
                    { /* block id: 85 */
                        const struct S0 *l_148 = &l_116;
                        int32_t ****l_152 = &l_149;
                        l_148 = l_148;
                        (*l_152) = l_149;
                        (*l_135) = (((&l_99 == (void*)0) == (l_153 != (void*)0)) == __builtin_clz(l_97.f0));
                    }
                    else
                    { /* block id: 89 */
                        struct S0 *l_154 = (void*)0;
                        struct S0 **l_155 = (void*)0;
                        struct S0 **l_156 = &l_147;
                        (*l_156) = l_154;
                        /* statement id: 90 */
                        assert (l_147 == 0);
                    }
                    /* facts after branching */
                    assert (l_147 == 0 || l_147 == &l_99);
                    if (l_99.f0)
                        break;
                }
                /* facts after branching */
                //assert (l_141 == &l_108 || l_141 == &l_78 || l_141 == &l_298.f1 || l_141 == &l_33 || l_141 == &l_368 || l_141 == &l_385);
            }
        }
        (*l_160) = ((int16_t)l_108 >> (int16_t)l_99.f0);
        l_108 = (((((uint16_t)((*p_93) == ((int32_t)(l_167 < l_99.f0) + (int32_t)__builtin_ctzll((*l_160)))) >> (uint16_t)p_92) ^ (p_92 < l_167)) <= (*p_89)) & p_90);
        if (((uint16_t)0x9CA3 + (uint16_t)((void*)0 != l_170)))
        { /* block id: 98 */
            const int32_t l_173 = 0x8DDD0EBF;
            float *l_174 = &l_97.f1;
            (*l_174) = l_173;
        }
        else
        { /* block id: 100 */
            uint32_t l_177 = 0x5BB3E853;
            const struct S0 * const l_179 = &l_97;
            for (l_99.f2 = 0; (l_99.f2 >= (-24)); l_99.f2--)
            { /* block id: 103 */
                int32_t l_178 = (-5);
                int32_t * const *** const l_182 = (void*)0;
            }
            (***l_170) = ((((((p_90 <= (p_90 ^ (*l_160))) < (((int16_t)((uint16_t)((void*)0 != l_201) + (uint16_t)p_90) + (int16_t)(l_177 == (((uint16_t)p_90 % (uint16_t)p_90) > p_90))) | (***l_170))) ^ 0x1E1C95C5) > l_177) < p_92) == 1);
            (**l_171) = ((uint32_t)((int16_t)((int16_t)0xA774 + (int16_t)(*l_172)) - (int16_t)p_90) + (uint32_t)((p_90 | 1) < ((p_92 & (&l_97 != (void*)0)) ^ ((uint16_t)((0x042A > p_90) <= p_92) % (uint16_t)p_90))));
        }
    }
    for (p_92 = 26; (p_92 == 52); p_92++)
    { /* block id: 128 */
        int32_t ****l_215 = (void*)0;
        int32_t ***l_217 = &l_171;
        int32_t ****l_216 = &l_217;
        (*l_172) = 0xB2AD0072;
        (*l_216) = &l_171;
    }
    (*l_171) = (**l_170);
    return p_92;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 100
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 158
   depth: 2, occurrence: 29
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 4
   depth: 7, occurrence: 2
   depth: 8, occurrence: 3
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 27, occurrence: 2
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 124
XXX times a pointer is dereferenced on RHS: 104
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 79
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 2
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 267

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 637
   level: 2, occurrence: 77
   level: 3, occurrence: 26
   level: 4, occurrence: 5
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 26
XXX average alias set size: 1.56

XXX times a non-volatile is read: 603
XXX times a non-volatile is write: 198
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 139
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 29
   depth: 2, occurrence: 27
   depth: 3, occurrence: 14
   depth: 4, occurrence: 27
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
********************* end of statistics **********************/

