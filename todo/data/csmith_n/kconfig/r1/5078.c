/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3487967591
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 18;
   signed f1 : 1;
   signed : 0;
   signed f2 : 11;
   signed f3 : 16;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
inline static int32_t * func_2(int32_t * p_3, const int32_t * p_4, int32_t * p_5, int32_t  p_6, uint16_t  p_7);
static int32_t * func_8(int32_t * p_9, int32_t  p_10, const int32_t * p_11, int32_t * p_12);
inline static int32_t * func_13(const uint32_t  p_14, int32_t * p_15, int16_t  p_16);
static uint8_t  func_21(int32_t  p_22, uint16_t  p_23, uint8_t  p_24, int32_t * p_25);
static int32_t *** const  func_37(int32_t  p_38, int32_t ** const * p_39);
static int32_t *** func_40(int32_t  p_41, struct S0  p_42, const int32_t * p_43, int32_t *** p_44, int32_t * p_45);
static struct S0  func_46(int32_t * const * const * p_47, int8_t  p_48, struct S0  p_49, int32_t ** const * p_50, uint32_t  p_51);
static int32_t * const * const * func_52(int32_t *** p_53);
static int32_t *** func_54(const int32_t * const  p_55);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_20 = 1;
    uint32_t l_28 = 4294967287U;
    int32_t *l_33 = &l_20;
    uint16_t l_487 = 65531U;
    int16_t l_515 = (-1);
    int32_t l_516 = (-1);
    int32_t **l_552 = &l_33;
    (*l_552) = func_2(func_8(func_13((((safe_div_func_int8_t_s_s((~((0xE6 == 254U) ^ ((l_20 || l_20) ^ (func_21((safe_sub_func_uint16_t_u_u((l_28 && (&l_20 != &l_20)), (safe_div_func_int8_t_s_s(l_28, (safe_add_func_uint16_t_u_u(65531U, l_20)))))), l_20, l_28, l_33) ^ 1)))), (*l_33))) | l_487) || (*l_33)), &l_20, (*l_33)), (*l_33), &l_20, &l_20), &l_20, &l_20, l_515, l_516);
    /* statement id: 211 */
    assert (l_33 == 0);
    return l_515;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_2(int32_t * p_3, const int32_t * p_4, int32_t * p_5, int32_t  p_6, uint16_t  p_7)
{ /* block id: 195 */
    uint32_t l_525 = 0xE5806126;
    int32_t * const * const l_527 = (void*)0;
    int32_t * const * const *l_526 = &l_527;
    int32_t l_543 = (-1);
    int32_t *l_542 = &l_543;
    int32_t *l_545 = &l_543;
    int32_t *l_546 = &l_543;
    int32_t *l_547 = &l_543;
    int32_t *l_548 = &l_543;
    int32_t *l_549 = &l_543;
    int32_t *l_550 = &l_543;
    int32_t *l_551 = (void*)0;
    for (p_6 = 0; (p_6 != 19); ++p_6)
    { /* block id: 198 */
        int32_t **l_530 = (void*)0;
        int32_t ** const *l_529 = &l_530;
        struct S0 *l_540 = (void*)0;
        int32_t *l_544 = (void*)0;
        for (p_7 = 0; (p_7 > 1); p_7 = safe_add_func_int16_t_s_s(p_7, 1))
        { /* block id: 201 */
            int32_t **l_521 = (void*)0;
            int32_t l_524 = 0xDA77ED37;
            int32_t *l_523 = &l_524;
            int32_t **l_522 = &l_523;
            struct S0 l_528 = {79,-0,-44,-117};
            struct S0 *l_541 = &l_528;
            (*l_522) = &p_6;
            /* statement id: 202 */
            assert (l_523 == &p_6);
            (*l_522) = &p_6;
            if (l_525)
                break;
            (*l_541) = func_46(l_526, p_6, l_528, l_529, ((((0x1B || 0xCF) != (safe_div_func_int16_t_s_s(((safe_unary_minus_func_uint16_t_u(((safe_sub_func_int32_t_s_s(((safe_mod_func_int8_t_s_s((safe_div_func_uint16_t_u_u(((void*)0 == l_540), 0xBB3F)), p_6)) > p_6), (*p_3))) | 0U))) && p_7), 0x0849))) < (*l_523)) < p_7));
        }
        return l_544;
        /* statement id: 207 */
        //assert (func_2_rv == 0);
    }
    (*p_3) = (*l_542);
    return l_551;
    /* statement id: 210 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_8(int32_t * p_9, int32_t  p_10, const int32_t * p_11, int32_t * p_12)
{ /* block id: 193 */
    int32_t l_514 = 1;
    int32_t *l_513 = &l_514;
    return p_12;
    /* statement id: 194 */
    //assert (func_8_rv == &l_20);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_13(const uint32_t  p_14, int32_t * p_15, int16_t  p_16)
{ /* block id: 189 */
    int16_t l_492 = 0xE810;
    int32_t l_509 = 9;
    int32_t *l_508 = &l_509;
    int32_t **l_507 = &l_508;
    int32_t ***l_506 = &l_507;
    int32_t ****l_505 = &l_506;
    int32_t *****l_504 = &l_505;
    struct S0 l_511 = {64,0,-9,98};
    struct S0 *l_510 = &l_511;
    uint8_t l_512 = 0x0A;
    (*l_508) = (((safe_lshift_func_int8_t_s_u((0x4533 & (safe_rshift_func_uint8_t_u_u(l_492, ((safe_mod_func_int32_t_s_s(((safe_rshift_func_uint8_t_u_s((safe_lshift_func_int8_t_s_s((!(((safe_rshift_func_uint16_t_u_u((safe_div_func_uint16_t_u_u((((((void*)0 == l_504) == (p_16 ^ (l_510 == (void*)0))) < p_14) & (*****l_504)), 0x5A65)), 0)) || p_16) & (**l_507))), p_14)), (*l_508))) && p_14), 4294967292U)) <= (**l_507))))), p_14)) || l_512) != p_16);
    (**l_504) = (void*)0;
    /* statement id: 191 */
    assert (l_506 == 0);
    return p_15;
    /* statement id: 192 */
    //assert (func_13_rv == &l_20);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_21(int32_t  p_22, uint16_t  p_23, uint8_t  p_24, int32_t * p_25)
{ /* block id: 1 */
    int32_t **l_34 = (void*)0;
    int32_t l_36 = 0x7030FC35;
    int32_t *l_35 = &l_36;
    struct S0 l_326 = {282,0,-11,88};
    const int32_t *l_483 = (void*)0;
    const int32_t * const *l_482 = &l_483;
    const int32_t * const * const *l_481 = &l_482;
    const int32_t * const * const **l_480 = &l_481;
    uint8_t l_486 = 5U;
    l_35 = p_25;
    /* statement id: 2 */
    //assert (l_35 == &l_20);
    (*l_480) = func_37((*l_35), func_40((*p_25), func_46(func_52(func_54(&l_36)), p_23, l_326, func_54(p_25), (*l_35)), p_25, &l_34, p_25));
    /* statement id: 182 */
    assert (l_481 == 0);
    for (p_23 = 0; (p_23 == 15); p_23 = safe_add_func_uint32_t_u_u(p_23, 9))
    { /* block id: 185 */
        if (l_486)
            break;
    }
    return (*l_35);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** const  func_37(int32_t  p_38, int32_t ** const * p_39)
{ /* block id: 121 */
    int32_t l_381 = 0x23E343D0;
    const struct S0 *l_382 = (void*)0;
    int32_t l_389 = 0x8D62EEA7;
    int32_t *l_388 = &l_389;
    int32_t **l_387 = &l_388;
    int32_t l_448 = (-5);
    int32_t *** const l_476 = &l_387;
    int32_t *** const l_477 = &l_387;
    int32_t *** const l_478 = &l_387;
    int32_t *** const l_479 = (void*)0;
    for (p_38 = 0; (p_38 < (-30)); p_38 = safe_sub_func_int8_t_s_s(p_38, 9))
    { /* block id: 124 */
        const int8_t l_379 = (-2);
        int32_t l_380 = (-9);
        l_380 = (safe_add_func_int32_t_s_s((safe_add_func_int8_t_s_s(p_38, (l_379 > p_38))), (p_38 | p_38)));
    }
    if (l_381)
    { /* block id: 127 */
        struct S0 *l_384 = (void*)0;
        struct S0 **l_383 = &l_384;
        int32_t *l_400 = (void*)0;
        const uint8_t l_401 = 0xCD;
        int32_t l_402 = 0x1B177A25;
        (*l_383) = l_382;
        (*l_388) = ((safe_rshift_func_uint8_t_u_s(((*p_39) != l_387), 4)) ^ (safe_sub_func_int8_t_s_s((safe_sub_func_uint32_t_u_u(((((8U && ((**l_387) == (((safe_add_func_uint8_t_u_u((safe_lshift_func_int8_t_s_s((safe_mod_func_uint16_t_u_u(((((void*)0 == (*l_387)) & (((((((l_400 == (*l_387)) ^ (1 == p_38)) >= 4294967287U) >= 0x52) >= 0x32B6) != 0U) & 2)) < (-1)), l_401)), 0)), l_402)) ^ (**l_387)) && (-1)))) == 0x1235) & p_38) || p_38), p_38)), 0x54)));
        (*l_387) = &p_38;
        /* statement id: 130 */
        assert (l_388 == &p_38);
    }
    else
    { /* block id: 131 */
        uint16_t l_416 = 0x6ADC;
        int16_t l_444 = (-2);
        int32_t l_447 = (-1);
        int32_t *** const l_451 = &l_387;
        int32_t *** const l_454 = (void*)0;
        if ((safe_mod_func_int8_t_s_s((((((safe_add_func_int32_t_s_s((!((((*l_388) < (safe_lshift_func_uint16_t_u_u(p_38, (safe_div_func_uint8_t_u_u((((safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((-9), l_416)), ((safe_add_func_uint32_t_u_u(((-6) < (**l_387)), l_416)) | (safe_mod_func_int32_t_s_s((safe_lshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u(((safe_sub_func_int32_t_s_s(l_416, 0x51E9E2BA)) < l_416), 3)), 3)), p_38))))) ^ p_38) ^ (**l_387)), p_38))))) == p_38) >= p_38)), 0x7049D083)) > (*l_388)) < 0) & p_38) <= p_38), 252U)))
        { /* block id: 132 */
            int32_t *** const l_429 = (void*)0;
            for (l_381 = 28; (l_381 < (-21)); l_381 = safe_sub_func_int8_t_s_s(l_381, 1))
            { /* block id: 135 */
                return l_429;
                /* statement id: 136 */
                //assert (func_37_rv == 0);
            }
            (*l_388) = ((safe_div_func_uint8_t_u_u(p_38, (safe_div_func_int16_t_s_s(p_38, (safe_sub_func_int16_t_s_s((255U || (safe_rshift_func_uint16_t_u_u((0xA9C6B7E5 < (safe_add_func_uint16_t_u_u(0x1850, ((void*)0 != &l_382)))), (safe_div_func_int32_t_s_s((safe_lshift_func_uint8_t_u_u(0xD7, (((l_416 | p_38) & l_416) ^ 0x46))), l_444))))), l_444)))))) == p_38);
        }
        else
        { /* block id: 139 */
            int32_t *** const l_452 = &l_387;
            const int32_t **l_458 = (void*)0;
            const int32_t ***l_457 = &l_458;
            const int32_t ****l_456 = &l_457;
            const int32_t *****l_455 = &l_456;
            (*l_388) = ((safe_rshift_func_uint8_t_u_s(l_447, 6)) < l_448);
            (*l_387) = &l_447;
            /* statement id: 141 */
            assert (l_388 == &l_447);
            for (l_448 = 25; (l_448 >= 18); l_448 = safe_sub_func_int16_t_s_s(l_448, 3))
            { /* block id: 144 */
                int32_t *** const l_453 = &l_387;
                return l_454;
                /* statement id: 145 */
                //assert (func_37_rv == 0);
            }
            (*l_455) = &l_452;
            /* statement id: 147 */
            assert (l_456 == &l_452);
        }
        /* facts after branching */
        assert (l_388 == &l_447 || l_388 == &l_389);
        (*l_387) = &p_38;
        /* statement id: 149 */
        assert (l_388 == &p_38);
    }
    /* facts after branching */
    assert (l_388 == &p_38);
    for (l_381 = 0; (l_381 >= (-24)); l_381 = safe_sub_func_int8_t_s_s(l_381, 1))
    { /* block id: 153 */
        int32_t *l_461 = &l_448;
        int32_t *l_463 = &l_448;
        int32_t *** const l_470 = &l_387;
        (*l_387) = l_461;
        /* statement id: 154 */
        assert (l_388 == &l_448);
        if (p_38)
        { /* block id: 155 */
            int32_t *l_462 = &l_389;
            l_462 = l_461;
            /* statement id: 156 */
            assert (l_462 == &l_448);
            (**l_387) = (0xB4D13C09 < 0xBD9622E3);
        }
        else
        { /* block id: 158 */
            uint32_t l_466 = 0xD2F8FD5D;
            int32_t *** const l_469 = &l_387;
            (*l_387) = l_463;
            for (l_448 = 0; (l_448 > 8); l_448 = safe_add_func_uint32_t_u_u(l_448, 9))
            { /* block id: 162 */
                int32_t *** const l_468 = &l_387;
            }
        }
    }
    /* facts after for loop */
    assert (l_388 == &l_448 || l_388 == &p_38);
    return l_479;
    /* statement id: 181 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_40(int32_t  p_41, struct S0  p_42, const int32_t * p_43, int32_t *** p_44, int32_t * p_45)
{ /* block id: 108 */
    struct S0 *l_344 = (void*)0;
    struct S0 l_346 = {-129,0,-9,-145};
    struct S0 *l_345 = &l_346;
    int32_t l_354 = 0x9A3F3E99;
    int32_t *l_353 = &l_354;
    int32_t **l_365 = &l_353;
    int32_t ***l_364 = &l_365;
    int32_t ***l_372 = &l_365;
    (*l_345) = p_42;
    return p_44;
    /* statement id: 120 */
    //assert (func_40_rv == &l_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(int32_t * const * const * p_47, int8_t  p_48, struct S0  p_49, int32_t ** const * p_50, uint32_t  p_51)
{ /* block id: 102 */
    int32_t *l_328 = (void*)0;
    int32_t **l_327 = &l_328;
    int32_t * const **l_329 = (void*)0;
    int32_t ***l_330 = &l_327;
    (*l_327) = (void*)0;
    (*l_327) = (*l_327);
    (*l_330) = &l_328;
    p_49.f3 = (safe_lshift_func_uint8_t_u_u(p_49.f3, (safe_lshift_func_uint16_t_u_s(((p_49.f1 || (safe_sub_func_int16_t_s_s((~0xF45F2ABC), p_49.f3))) & ((p_49.f3 <= p_49.f3) ^ (safe_add_func_uint16_t_u_u(p_51, (safe_div_func_int16_t_s_s(p_49.f2, ((safe_mod_func_int32_t_s_s(((&l_327 == &l_327) && p_49.f3), 0xCD2CC1E2)) || p_48))))))), p_49.f0))));
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const * const * func_52(int32_t *** p_53)
{ /* block id: 11 */
    const int32_t *l_68 = (void*)0;
    int32_t l_69 = 0x0526E61A;
    int8_t l_81 = 0x53;
    int16_t l_94 = 0x62A5;
    uint16_t l_95 = 0x1786;
    int32_t l_195 = 0x1347A973;
    struct S0 l_232 = {395,0,-15,-121};
    int32_t *l_322 = &l_69;
    int32_t * const *l_321 = &l_322;
    int32_t * const * const *l_320 = &l_321;
    int32_t * const * const *l_323 = &l_321;
    int32_t * const * const *l_324 = &l_321;
    int32_t * const * const *l_325 = (void*)0;
    l_68 = l_68;
    for (l_69 = (-22); (l_69 > 7); l_69 = safe_add_func_int8_t_s_s(l_69, 6))
    { /* block id: 15 */
        int32_t *l_72 = (void*)0;
        int32_t l_74 = 0x504247EC;
        int32_t *l_73 = &l_74;
        struct S0 l_96 = {281,0,11,167};
        int32_t l_170 = 1;
        uint32_t l_247 = 0x46A460BA;
        int8_t l_309 = 9;
        struct S0 *l_317 = (void*)0;
        struct S0 **l_316 = &l_317;
        int32_t l_318 = 0;
        struct S0 *l_319 = &l_96;
        (*l_73) = (((void*)0 != &l_69) & l_69);
        if ((0x738D != (((safe_div_func_int32_t_s_s((*l_73), ((&l_73 != &l_68) && (safe_mod_func_uint16_t_u_u((*l_73), (safe_lshift_func_uint8_t_u_s(l_81, (safe_rshift_func_int16_t_s_u(0x2261, 9))))))))) > (!((safe_mod_func_uint8_t_u_u(0xC0, (safe_div_func_int16_t_s_s(((safe_add_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(((~l_81) <= (*l_73)), l_94)), l_94)) < l_95), (*l_73))))) && 0xDE))) & (*l_73))))
        { /* block id: 17 */
            struct S0 *l_97 = &l_96;
            int32_t l_100 = 4;
            int32_t *l_148 = (void*)0;
            (*l_97) = l_96;
            (*l_97) = (*l_97);
            for (l_95 = 10; (l_95 <= 44); l_95 = safe_add_func_uint8_t_u_u(l_95, 1))
            { /* block id: 22 */
                int32_t l_106 = 1;
                struct S0 *l_140 = &l_96;
                int16_t l_193 = 0x0F56;
                struct S0 **l_213 = &l_97;
            }
        }
        else
        { /* block id: 72 */
            int32_t **l_238 = &l_73;
            (*l_238) = &l_69;
            /* statement id: 73 */
            assert (l_73 == &l_69);
            if (((l_238 != (void*)0) <= ((0x9FCF63B4 ^ (-6)) <= (safe_rshift_func_uint16_t_u_u(((safe_rshift_func_int8_t_s_s((((((((*l_73) | ((((**l_238) || ((safe_add_func_uint32_t_u_u(((**l_238) == (safe_sub_func_uint32_t_u_u((0x9802 != ((0x25AC && (**l_238)) >= 1U)), (*l_73)))), (*l_73))) == 0xF98B19A1)) ^ l_232.f1) <= l_232.f1)) <= (*l_73)) >= (**l_238)) || (**l_238)) == 4294967295U) >= 0xFCF0), 4)) >= l_247), (*l_73))))))
            { /* block id: 74 */
                (*l_238) = (*l_238);
            }
            else
            { /* block id: 76 */
                for (l_95 = (-27); (l_95 >= 27); l_95 = safe_add_func_int8_t_s_s(l_95, 1))
                { /* block id: 79 */
                    const int32_t l_252 = 0xCA493033;
                    for (l_81 = 0; (l_81 > (-11)); l_81 = safe_sub_func_int16_t_s_s(l_81, 1))
                    { /* block id: 82 */
                        if ((**l_238))
                            break;
                    }
                    if (l_252)
                        break;
                }
                (*l_238) = &l_69;
            }
            for (l_247 = (-15); (l_247 >= 38); l_247 = safe_add_func_uint8_t_u_u(l_247, 1))
            { /* block id: 91 */
                int8_t l_265 = 0x5F;
                uint8_t l_266 = 247U;
                int32_t *l_267 = &l_74;
                uint32_t l_278 = 0x49ADAAD3;
                int16_t l_296 = 0xBA1E;
                (*l_267) = (safe_div_func_int16_t_s_s(((safe_add_func_uint8_t_u_u(0xE1, (((**l_238) | 0xA5ECF163) > (safe_div_func_uint32_t_u_u(((**l_238) || (safe_lshift_func_uint16_t_u_u((*l_73), ((**l_238) == 0x6C)))), (((safe_rshift_func_int8_t_s_u(l_265, 6)) ^ 65535U) ^ (*l_73))))))) || l_266), (**l_238)));
                (*l_267) = ((safe_lshift_func_uint16_t_u_s((safe_sub_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s((safe_add_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u(((((*l_267) ^ (**l_238)) || l_278) && ((!(safe_mod_func_int32_t_s_s(((safe_mod_func_uint32_t_u_u((*l_267), (safe_rshift_func_int16_t_s_u(((((((safe_add_func_int8_t_s_s(((((safe_rshift_func_uint8_t_u_s((safe_rshift_func_int16_t_s_u((safe_add_func_int16_t_s_s(((((&l_267 == &l_267) < (safe_add_func_int16_t_s_s((**l_238), (l_296 >= (safe_rshift_func_uint16_t_u_s(65531U, 6)))))) > 255U) != (-1)), l_232.f0)), (*l_267))), 5)) && (**l_238)) | 0x948C) & 9), 0)) ^ (*l_73)) & (*l_267)) & (-10)) || 0U) && (**l_238)), (*l_73))))) ^ (*l_73)), 0xB71546BF))) == 0x43139D34)), 0x5F)), (*l_267))), (*l_267))), (*l_73))), (*l_267))) < (**l_238));
                (*l_267) = (((((*l_267) & (6U >= (**l_238))) != 1) || (safe_sub_func_uint16_t_u_u(((l_238 == l_238) != (safe_mod_func_int32_t_s_s(((*l_73) < ((**l_238) | (~((~((((safe_lshift_func_int8_t_s_s((**l_238), l_232.f3)) >= l_309) || l_94) | 252U)) <= (**l_238))))), (*l_267)))), (**l_238)))) && (*l_73));
            }
        }
        /* facts after branching */
        assert (l_73 == &l_69 || l_73 == &l_74);
        l_232.f3 = (safe_sub_func_int32_t_s_s((((*l_73) >= 0x9362) >= ((safe_add_func_uint16_t_u_u(((7 && ((*l_73) & ((*l_73) || (safe_lshift_func_uint8_t_u_u(((*l_73) != (l_316 == (void*)0)), (0xEE & 1U)))))) < (*l_73)), (*l_73))) && l_318)), l_69));
        (*l_319) = l_232;
    }
    l_68 = (void*)0;
    return l_325;
    /* statement id: 101 */
    //assert (func_52_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_54(const int32_t * const  p_55)
{ /* block id: 3 */
    int32_t l_56 = 0x6DB3533B;
    int32_t *l_60 = &l_56;
    int32_t **l_62 = &l_60;
    int32_t ***l_61 = &l_62;
    int32_t ***l_63 = &l_62;
    int32_t ***l_64 = &l_62;
    int32_t ***l_65 = &l_62;
    int32_t ***l_66 = &l_62;
    int32_t ***l_67 = (void*)0;
    for (l_56 = 0; (l_56 < (-5)); l_56--)
    { /* block id: 6 */
        uint8_t l_59 = 0x82;
        if (l_59)
            break;
    }
    (*l_60) = ((((l_56 != (0U | ((void*)0 != &l_56))) == 0U) & (l_56 != 0)) | 0x851CC0D6);
    return l_67;
    /* statement id: 10 */
    //assert (func_54_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 102
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 4
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 26

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 137

XXX times a variable address is taken: 129
XXX times a pointer is dereferenced on RHS: 108
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 31
   depth: 3, occurrence: 0
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 370

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 173
   level: 2, occurrence: 62
   level: 3, occurrence: 22
   level: 4, occurrence: 0
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 33.6
XXX average alias set size: 1.16

XXX times a non-volatile is read: 531
XXX times a non-volatile is write: 159
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 78
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 16
   depth: 2, occurrence: 20
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 9.94
XXX percentage an existing variable is used: 90.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

