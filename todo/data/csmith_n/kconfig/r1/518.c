/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1041197512
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 18;
   unsigned f1 : 31;
   unsigned f2 : 5;
   const int32_t  f3;
   float  f4;
};
#pragma pack(pop)

struct S1 {
   const signed f0 : 26;
   const unsigned f1 : 8;
   unsigned f2 : 6;
   signed f3 : 7;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   unsigned f0 : 17;
   unsigned f1 : 14;
   signed f2 : 30;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const int32_t  func_27(void);
inline static struct S0 * func_31(const struct S1  p_32);
static struct S2  func_37(const uint32_t  p_38, const int64_t  p_39, struct S0 * p_40, uint8_t  p_41, struct S0 * p_42);
static struct S0 * func_43(struct S0 * p_44, const struct S0 * p_45, struct S0 * p_46, uint64_t  p_47, const uint64_t  p_48);
inline static int32_t  func_77(struct S0 * p_78, int64_t  p_79, const uint64_t  p_80, float  p_81, struct S1  p_82);
inline static struct S0 * func_83(int32_t * p_84, uint32_t  p_85, int64_t  p_86, struct S0  p_87);
inline static int32_t * func_110(uint64_t  p_111, float * p_112);
static float * func_113(struct S0  p_114, int32_t * p_115, struct S0  p_116, uint64_t  p_117, float * p_118);
static struct S0  func_119(uint32_t  p_120, uint64_t  p_121, int32_t * p_122);
static int32_t  func_125(uint32_t  p_126, struct S0 * p_127, int32_t  p_128, float * p_129);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_27(void)
{ /* block id: 36 */
    uint64_t l_28 = 0x6373A4C924B54114LL;
    const struct S1 l_33 = {7675,4,0,2};
    int32_t ***l_710 = (void*)0;
    struct S0 l_721 = {65,30251,4,9L,0x6.46A8C8p+60};
    int32_t l_723 = 0x77407307L;
    int32_t *l_722 = &l_723;
    struct S2 l_738 = {315,21,17495};
    struct S2 *l_737 = &l_738;
    struct S0 *l_768 = &l_721;
    struct S0 **l_767 = &l_768;
    struct S0 ***l_766 = &l_767;
    struct S0 *** const *l_765 = &l_766;
    int32_t *l_776 = &l_723;
    int32_t *l_778 = &l_723;
    const uint64_t l_783 = 18446744073709551610UL;
    if (l_28)
    { /* block id: 37 */
        uint32_t l_709 = 18446744073709551614UL;
        int32_t **l_712 = (void*)0;
        int32_t ***l_711 = &l_712;
        float *l_726 = &l_721.f4;
        struct S2 l_736 = {296,56,-28500};
        struct S2 *l_735 = &l_736;
        for (l_28 = (-18); (l_28 <= 20); ++l_28)
        { /* block id: 40 */
            struct S0 l_708 = {178,28885,1,-1L,0xE.5AAEC5p+24};
            struct S0 *l_707 = &l_708;
            struct S0 **l_706 = &l_707;
            float l_713 = 0xA.BFB36Fp-81;
            int32_t *l_714 = (void*)0;
            int64_t l_725 = 1L;
            uint32_t l_734 = 1UL;
            struct S2 *l_754 = &l_738;
            (*l_706) = func_31(l_33);
            /* statement id: 415 */
            assert (l_707 == 0);
            if (l_709)
                continue;
            l_711 = l_710;
            /* statement id: 417 */
            assert (l_711 == 0);
            if ((l_708.f2 > ((void*)0 != l_714)))
            { /* block id: 418 */
                struct S2 l_719 = {163,60,-9124};
                struct S2 *l_718 = &l_719;
                struct S0 l_724 = {268,38821,4,1L,0x0.3p+1};
                int32_t **l_727 = (void*)0;
                const int32_t *l_729 = &l_724.f3;
                const int32_t **l_728 = &l_729;
                for (l_709 = 12; (l_709 > 28); l_709 += 1)
                { /* block id: 421 */
                    const uint64_t l_717 = 0x1CD5288898CA08C6LL;
                    struct S2 **l_720 = &l_718;
                    if (l_717)
                        break;
                    (*l_720) = l_718;
                }
                if (l_719.f0)
                    continue;
                (*l_728) = func_113(l_721, l_722, l_724, l_725, func_110(l_724.f2, l_726));
                /* statement id: 426 */
                assert (l_729 == &l_721.f4 || l_729 == &l_723);
            }
            else
            { /* block id: 427 */
                int32_t * const l_732 = &l_723;
                struct S0 l_740 = {473,38053,1,4L,-0x1.Fp+1};
                int32_t *l_741 = &l_723;
                float l_756 = 0x1.C0EEBCp-10;
                for (l_709 = (-20); (l_709 <= 57); l_709 += 7)
                { /* block id: 430 */
                    int32_t **l_733 = &l_714;
                    float *l_757 = (void*)0;
                    (*l_733) = l_732;
                    /* statement id: 431 */
                    assert (l_714 == &l_723);
                    if ((*l_714))
                        continue;
                    if (l_734)
                    { /* block id: 433 */
                        const int32_t l_739 = 0xD245B6C2L;
                        l_737 = l_735;
                        /* statement id: 434 */
                        assert (l_737 == &l_736);
                        return l_739;
                    }
                    else
                    { /* block id: 436 */
                        uint64_t l_755 = 0UL;
                        (*l_714) = (0x559EE3DA583C436ALL && __builtin_popcountl((**l_733)));
                        (*l_726) = ((*l_714) > (-0x1.3p-1));
                        (*l_706) = &l_721;
                        /* statement id: 439 */
                        assert (l_707 == &l_721);
                        (*l_733) = func_113(l_740, l_741, (*l_707), (((**l_733) < (((int64_t)__builtin_clz((((int16_t)1L >> (int16_t)4) ^ ((int16_t)(((int32_t)((((*l_741) | (*l_732)) || 4294967295UL) != (((uint64_t)((uint16_t)((&l_736 != l_754) | 0x3F6EL) >> (uint16_t)8) - (uint64_t)0xA289FA6E6CBF8781LL) >= l_755)) - (int32_t)(*l_741)) ^ (*l_722)) + (int16_t)(*l_714)))) % (int64_t)(*l_722)) < 1UL)) | (*l_722)), l_757);
                        /* statement id: 440 */
                        assert (l_714 == 0 || l_714 == &l_723);
                    }
                    /* facts after branching */
                    assert (l_707 == &l_721);
                    assert (l_714 == 0 || l_714 == &l_723);
                    (*l_722) = (*l_741);
                }
                /* facts after for loop */
                assert (l_707 == &l_721 || l_707 == 0);
                assert (l_714 == &l_723 || l_714 == 0);
                (*l_754) = (*l_754);
                if ((*l_732))
                    break;
            }
            /* facts after branching */
            assert (l_707 == &l_721 || l_707 == 0);
            assert (l_714 == &l_723 || l_714 == 0);
        }
        /* facts after for loop */
        assert (l_711 == 0 || l_711 == &l_712);
        (*l_722) = (*l_722);
    }
    else
    { /* block id: 449 */
        struct S0 **** const l_769 = &l_766;
        int32_t l_772 = 0x477AFFABL;
        for (l_28 = (-6); (l_28 <= 27); l_28++)
        { /* block id: 452 */
            int32_t ** const l_760 = &l_722;
            float l_775 = 0x4.0AC441p-30;
            uint8_t l_777 = 0x2BL;
            (*l_776) = ((((void*)0 != l_760) | ((int64_t)(((uint16_t)(l_765 != l_769) - (uint16_t)((uint16_t)(l_772 == l_772) / (uint16_t)((uint64_t)(((l_772 > l_772) && ((void*)0 != l_776)) >= (**l_760)) % (uint64_t)18446744073709551610UL))) || 0xD274BE085FA71856LL) % (int64_t)0x84AD1BB957E9151ELL)) || l_777);
            (*l_737) = (*l_737);
        }
    }
    l_722 = l_778;
    for (l_28 = 0; (l_28 > 52); l_28 += 6)
    { /* block id: 460 */
        int32_t *l_781 = &l_723;
        int32_t **l_782 = &l_778;
        (*l_782) = l_781;
    }
    (*l_778) = 0x067BBE02L;
    return l_783;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_31(const struct S1  p_32)
{ /* block id: 41 */
    int32_t l_34 = 1L;
    struct S0 l_50 = {305,8302,3,0L,-0x1.8p+1};
    struct S0 *l_49 = &l_50;
    struct S0 *l_699 = &l_50;
    struct S0 *l_700 = &l_50;
    struct S0 *l_701 = &l_50;
    struct S0 *l_702 = &l_50;
    struct S0 *l_703 = &l_50;
    struct S0 *l_704 = &l_50;
    struct S0 *l_705 = (void*)0;
    for (l_34 = 12; (l_34 > (-18)); l_34 -= 1)
    { /* block id: 44 */
        struct S0 *l_51 = &l_50;
        int32_t l_52 = (-1L);
        struct S2 *l_678 = (void*)0;
        struct S2 l_680 = {220,90,-6801};
        struct S2 *l_679 = &l_680;
        (*l_679) = func_37(l_34, p_32.f0, func_43(l_49, &l_50, l_51, l_52, (l_52 | 1L)), l_52, l_51);
    }
    for (l_34 = 0; (l_34 != 26); l_34 += 1)
    { /* block id: 399 */
        int32_t l_683 = 0xD758278CL;
        for (l_683 = (-20); (l_683 == (-13)); l_683 += 1)
        { /* block id: 402 */
            int32_t l_686 = (-9L);
            int32_t *l_695 = &l_683;
            float *l_697 = &l_50.f4;
            for (l_686 = 0; (l_686 <= (-30)); --l_686)
            { /* block id: 405 */
                int32_t l_689 = 0L;
                const int32_t ***l_693 = (void*)0;
                const int32_t ****l_692 = &l_693;
                struct S0 l_696 = {53,18398,2,-1L,0xF.1C9720p-58};
                for (l_689 = 0; (l_689 <= 2); l_689 += 6)
                { /* block id: 408 */
                    struct S0 l_694 = {389,45964,1,2L,0xC.CE1E44p-17};
                    int32_t **l_698 = &l_695;
                    (*l_698) = func_110(((void*)0 == l_692), func_113(l_694, l_695, l_696, p_32.f0, l_697));
                }
            }
            /* facts after for loop */
            assert (l_695 == &l_50.f4 || l_695 == &l_683);
        }
    }
    return l_705;
    /* statement id: 414 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_37(const uint32_t  p_38, const int64_t  p_39, struct S0 * p_40, uint8_t  p_41, struct S0 * p_42)
{ /* block id: 391 */
    int32_t l_675 = (-7L);
    int32_t *l_674 = &l_675;
    int32_t **l_676 = &l_674;
    struct S2 l_677 = {178,20,-10994};
    (*l_676) = l_674;
    (*l_676) = (*l_676);
    return l_677;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_43(struct S0 * p_44, const struct S0 * p_45, struct S0 * p_46, uint64_t  p_47, const uint64_t  p_48)
{ /* block id: 45 */
    int32_t l_70 = 1L;
    int32_t *l_69 = &l_70;
    struct S0 l_72 = {277,7913,3,-8L,0xB.AC80EAp-84};
    struct S0 *l_71 = &l_72;
    int32_t **l_466 = &l_69;
    struct S2 l_468 = {328,51,-32125};
    struct S2 *l_493 = &l_468;
    struct S0 **l_515 = (void*)0;
    struct S0 ***l_514 = &l_515;
    const struct S0 ** const ** const l_536 = (void*)0;
    const struct S0 ** const ** const *l_535 = &l_536;
    uint32_t l_555 = 18446744073709551615UL;
    struct S0 l_556 = {325,28345,3,0x77BCCCA7L,0xC.FD9418p-34};
    struct S1 l_559 = {-589,3,4,-6};
    int32_t *l_574 = &l_70;
    uint8_t l_590 = 0x87L;
    uint32_t l_599 = 4294967290UL;
    float *l_601 = &l_72.f4;
    struct S0 *l_651 = &l_556;
    float *l_673 = &l_72.f4;
    for (p_47 = 7; (p_47 == 55); p_47 += 1)
    { /* block id: 48 */
        uint8_t l_76 = 255UL;
        struct S0 l_89 = {121,44736,4,0x327BC4A6L,0x5.1p-1};
        struct S1 l_457 = {7500,8,3,-0};
        float *l_459 = &l_72.f4;
        int16_t l_479 = 0x90C9L;
        int32_t *l_492 = (void*)0;
        struct S2 l_518 = {66,20,-17972};
        struct S0 ***l_527 = &l_515;
    }
    if ((__builtin_ctzll((**l_466)) < func_77(func_83((*l_466), l_555, (*l_69), l_556), ((int64_t)__builtin_parityl((**l_466)) % (int64_t)(**l_466)), (**l_466), p_47, l_559)))
    { /* block id: 322 */
        struct S0 *l_560 = &l_72;
        return p_46;
        /* statement id: 323 */
        //assert (func_43_rv == &l_50);
    }
    else
    { /* block id: 324 */
        struct S0 l_573 = {429,6976,3,0x79D22448L,0x9.4F25B4p-98};
        int32_t *l_575 = &l_70;
        int32_t ***l_580 = (void*)0;
        float *l_591 = &l_573.f4;
        struct S1 l_600 = {-3949,1,3,5};
        if (((uint16_t)((uint16_t)((*l_69) >= ((int16_t)(-1L) % (int16_t)((uint64_t)(**l_466) + (uint64_t)p_48))) >> (uint16_t)2) / (uint16_t)p_48))
        { /* block id: 325 */
            int32_t *l_569 = &l_70;
            (*l_466) = l_569;
        }
        else
        { /* block id: 327 */
            const struct S2 *l_570 = &l_468;
            float *l_571 = &l_72.f4;
            struct S0 l_572 = {310,18518,3,0L,-0x1.4p+1};
            (*l_571) = (l_570 != l_570);
            (*l_466) = func_113(l_572, func_113(l_573, l_574, func_119((*l_574), (**l_466), l_575), p_48, l_575), (*p_45), p_48, l_575);
            (*l_69) = ((int16_t)((l_580 != l_580) >= ((((int64_t)((int64_t)(((uint32_t)(**l_466) - (uint32_t)((p_48 > (((((+((int16_t)0xB5EAL << (int16_t)__builtin_parity(p_48))) ^ l_572.f0) > p_47) >= 0x71C8L) == (*l_574))) >= p_47)) && 0x4EFB914CL) % (int64_t)0x5E4292961265EFD2LL) + (int64_t)p_47) & l_590) > (*l_575))) / (int16_t)(*l_575));
        }
        (*l_591) = p_48;
        p_46 = &l_573;
        /* statement id: 333 */
        assert (p_46 == &l_573);
        (*l_466) = func_113(func_119((*l_574), (*l_575), (*l_466)), (*l_466), (*p_45), p_47, l_69);
    }
    /* facts after branching */
    //assert (p_46 == dangling);
    (*l_601) = (-0x7.6p+1);
    for (l_599 = 29; (l_599 != 15); l_599 -= 1)
    { /* block id: 339 */
        int32_t l_639 = 1L;
        float l_640 = 0x0.3DF960p-32;
        int32_t *l_658 = (void*)0;
        struct S0 l_664 = {95,24520,0,1L,0x1.5A788Ep-82};
        for (l_590 = 0; (l_590 < 40); ++l_590)
        { /* block id: 342 */
            uint32_t l_608 = 0xE535241BL;
            int32_t l_619 = 0L;
            int32_t *l_618 = &l_619;
            struct S0 *l_653 = &l_72;
            for (l_70 = (-11); (l_70 < (-23)); l_70 -= 8)
            { /* block id: 345 */
                int32_t l_610 = 0xE84CA24EL;
                int32_t *l_609 = &l_610;
                (*l_609) = l_608;
            }
            for (l_555 = 0; (l_555 >= 47); ++l_555)
            { /* block id: 350 */
                int32_t *l_617 = &l_70;
                struct S0 *l_652 = &l_556;
                struct S2 l_654 = {88,77,3422};
                for (l_70 = (-7); (l_70 >= (-18)); l_70--)
                { /* block id: 353 */
                    for (l_608 = 0; (l_608 != 0); l_608 += 8)
                    { /* block id: 356 */
                        int32_t *l_620 = &l_619;
                        l_618 = l_617;
                        /* statement id: 357 */
                        assert (l_618 == &l_70);
                        (*l_620) = 0L;
                    }
                    /* facts after for loop */
                    assert (l_618 == &l_70 || l_618 == &l_619);
                    return p_44;
                    /* statement id: 360 */
                    //assert (func_43_rv == &l_50);
                }
                if (((int16_t)((int16_t)((void*)0 == &l_466) >> (int16_t)((int16_t)0x8B9DL >> (int16_t)((int32_t)(!((((18446744073709551615UL && p_48) >= ((int32_t)(((~((uint64_t)((uint16_t)((uint32_t)p_47 / (uint32_t)l_639) << (uint16_t)l_639) + (uint64_t)0x280BE149C57AC9F6LL)) <= (-4L)) | p_47) % (int32_t)p_48)) < l_639) <= (*l_618))) % (int32_t)l_639))) / (int16_t)0xC48CL))
                { /* block id: 362 */
                    for (l_70 = 1; (l_70 != 7); ++l_70)
                    { /* block id: 365 */
                        (*l_618) = ((int64_t)(l_574 != l_601) / (int64_t)(p_48 || p_48));
                        return p_44;
                        /* statement id: 367 */
                        //assert (func_43_rv == &l_50);
                    }
                }
                else
                { /* block id: 369 */
                    for (p_47 = 0; (p_47 > 59); p_47++)
                    { /* block id: 372 */
                        struct S2 **l_647 = &l_493;
                        struct S2 ***l_648 = (void*)0;
                        struct S2 ***l_649 = &l_647;
                        struct S0 *l_650 = &l_556;
                        (*l_649) = l_647;
                        return p_44;
                        /* statement id: 374 */
                        //assert (func_43_rv == &l_50);
                    }
                    if (p_48)
                        continue;
                    (*l_493) = l_654;
                }
            }
            (*l_574) = l_639;
        }
        for (l_590 = (-4); (l_590 != 5); l_590 += 9)
        { /* block id: 384 */
            struct S0 l_657 = {462,44216,2,0x80F64D70L,0x8.F3FBCBp-45};
            float *l_662 = &l_657.f4;
            int32_t *l_663 = &l_70;
            (*l_493) = (*l_493);
            l_663 = l_658;
            /* statement id: 386 */
            assert (l_663 == 0);
        }
        (*l_466) = func_113(l_664, (*l_466), func_119(p_47, (((int16_t)(~(*l_69)) / (int16_t)(0x598BFD52L ^ (((int16_t)__builtin_parityl((*l_574)) << (int16_t)12) ^ (*l_574)))) ^ (+((uint64_t)((p_47 || (*l_574)) && p_47) + (uint64_t)(**l_466)))), (*l_466)), l_664.f0, l_673);
    }
    /* facts after for loop */
    assert (l_69 == &l_72.f4 || l_69 == &l_70);
    return p_44;
    /* statement id: 390 */
    //assert (func_43_rv == &l_50);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_77(struct S0 * p_78, int64_t  p_79, const uint64_t  p_80, float  p_81, struct S1  p_82)
{ /* block id: 55 */
    int32_t l_108 = 0x133AA3A0L;
    return l_108;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_83(int32_t * p_84, uint32_t  p_85, int64_t  p_86, struct S0  p_87)
{ /* block id: 52 */
    struct S0 l_91 = {31,12271,3,0x4F31BC46L,0x7.B1AAE8p-32};
    struct S0 *l_90 = &l_91;
    float *l_92 = &l_91.f4;
    struct S0 *l_93 = &l_91;
    struct S0 *l_94 = &l_91;
    struct S0 *l_95 = &l_91;
    struct S0 *l_96 = &l_91;
    struct S0 *l_97 = &l_91;
    struct S0 *l_98 = &l_91;
    struct S0 *l_99 = &l_91;
    struct S0 *l_100 = &l_91;
    struct S0 *l_101 = &l_91;
    struct S0 *l_102 = &l_91;
    struct S0 *l_103 = &l_91;
    struct S0 *l_104 = &l_91;
    struct S0 *l_105 = &l_91;
    struct S0 *l_106 = (void*)0;
    (*l_92) = ((void*)0 == l_90);
    return l_106;
    /* statement id: 54 */
    //assert (func_83_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_110(uint64_t  p_111, float * p_112)
{ /* block id: 110 */
    struct S0 l_233 = {218,45842,2,-3L,0x0.9p-1};
    struct S0 *l_232 = &l_233;
    struct S0 * const *l_231 = &l_232;
    struct S0 * const **l_230 = &l_231;
    struct S0 * const *** const l_229 = &l_230;
    int32_t l_243 = (-10L);
    int32_t *l_242 = &l_243;
    int32_t l_300 = (-3L);
    struct S1 l_311 = {-3511,12,4,1};
    uint64_t l_331 = 0UL;
    int64_t l_361 = (-1L);
    int32_t l_428 = 1L;
    for (p_111 = 0; (p_111 > 28); p_111 += 4)
    { /* block id: 113 */
        uint16_t l_234 = 0xF8AFL;
        int32_t l_235 = 1L;
        struct S0 *l_249 = &l_233;
        float *l_251 = &l_233.f4;
        struct S0 * const *l_267 = &l_232;
        int32_t *l_290 = &l_243;
        struct S1 l_341 = {-7802,7,6,-3};
        int32_t l_350 = 0x1595770AL;
        struct S2 l_376 = {262,43,-1801};
    }
    return p_112;
    /* statement id: 267 */
    //assert (func_110_rv == &l_62 || func_110_rv == &l_89.f4 || func_110_rv == &l_70 || func_110_rv == 0 || func_110_rv == &l_50.f4 || func_110_rv == &l_683 || func_110_rv == &l_721.f4);
}


/* ------------------------------------------ */
/* 
 * reads : l_62 l_89.f4
 * writes:
 */
static float * func_113(struct S0  p_114, int32_t * p_115, struct S0  p_116, uint64_t  p_117, float * p_118)
{ /* block id: 101 */
    int32_t l_213 = (-10L);
    int32_t *l_212 = &l_213;
    int32_t **l_220 = &l_212;
    int32_t ** const *l_219 = &l_220;
    int32_t ** const **l_218 = &l_219;
    struct S2 l_222 = {247,124,-10843};
    if (((uint32_t)1UL % (uint32_t)((uint32_t)((0x26EB52EEBB8701C1LL != (((p_116.f1 < (0UL == (*p_115))) != 65535UL) <= ((int16_t)(((uint16_t)(((uint16_t)((uint16_t)(((int16_t)((int32_t)((p_115 != l_212) & ((int16_t)((int32_t)(*p_115) / (int32_t)(*p_115)) >> (int16_t)(*l_212))) % (int32_t)0x85E4FF75L) << (int16_t)4) && p_114.f2) >> (uint16_t)(*l_212)) << (uint16_t)5) != 0xD4C4B4CCDFE2BB12LL) << (uint16_t)9) || 18446744073709551611UL) >> (int16_t)10))) < 0L) - (uint32_t)(*p_115))))
    { /* block id: 102 */
        return p_115;
        /* statement id: 103 */
        //assert (func_113_rv == &l_62 || func_113_rv == &l_243 || func_113_rv == &l_89.f4 || func_113_rv == &l_315 || func_113_rv == &l_233.f4 || func_113_rv == &l_505 || func_113_rv == &l_70 || func_113_rv == &l_72.f4 || func_113_rv == &l_683 || func_113_rv == &l_50.f4 || func_113_rv == &l_723);
    }
    else
    { /* block id: 104 */
        int32_t ** const **l_221 = &l_219;
        struct S2 *l_223 = &l_222;
        l_221 = l_218;
        (*l_223) = l_222;
        (*l_223) = (*l_223);
    }
    return p_118;
    /* statement id: 109 */
    //assert (func_113_rv == &l_89.f4 || func_113_rv == &l_233.f4 || func_113_rv == &l_62 || func_113_rv == &l_70 || func_113_rv == &l_72.f4 || func_113_rv == &l_50.f4 || func_113_rv == &l_721.f4 || func_113_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_62 l_89.f4
 * writes: l_62 l_89.f4
 */
static struct S0  func_119(uint32_t  p_120, uint64_t  p_121, int32_t * p_122)
{ /* block id: 65 */
    float *l_164 = (void*)0;
    float **l_165 = &l_164;
    int32_t l_177 = 4L;
    int32_t l_179 = 0xD118ECCFL;
    struct S0 ***l_189 = (void*)0;
    struct S0 * const ***l_190 = (void*)0;
    struct S0 ****l_191 = &l_189;
    struct S0 l_192 = {469,33924,3,0x59F51D59L,0x1.0p+1};
    for (p_121 = 0; (p_121 > 11); p_121 += 1)
    { /* block id: 68 */
        struct S0 l_154 = {359,35434,3,-4L,0x1.6p+1};
        float *l_160 = &l_154.f4;
        float **l_159 = &l_160;
        for (p_120 = 0; (p_120 <= 10); p_120 += 1)
        { /* block id: 71 */
            int32_t l_153 = 1L;
            const int32_t *l_152 = &l_153;
            const int32_t * const *l_151 = &l_152;
            const int32_t * const **l_150 = &l_151;
            (*l_150) = &p_122;
            /* statement id: 72 */
            assert (l_151 == &p_122);
            return l_154;
        }
        (*p_122) = ((int64_t)p_120 / (int64_t)p_121);
        for (p_120 = (-14); (p_120 == 24); ++p_120)
        { /* block id: 78 */
            struct S0 *l_163 = &l_154;
            int32_t l_168 = (-5L);
            l_159 = l_159;
            (*l_160) = __builtin_popcountll(l_154.f2);
            (*l_160) = p_121;
            if ((p_121 ^ ((l_165 != &l_160) > ((int16_t)0L / (int16_t)l_168))))
            { /* block id: 82 */
                uint8_t l_178 = 0x3BL;
                struct S0 l_187 = {254,26576,0,0xDA7943A2L,-0x7.Cp+1};
                if (((int16_t)((((uint16_t)p_120 - (uint16_t)(((int16_t)(((int16_t)(l_177 & (-8L)) >> (int16_t)(l_178 ^ l_154.f1)) >= l_177) - (int16_t)(l_168 < l_168)) > (l_179 > (*p_122)))) <= p_121) & 0xD04B031DE9004F71LL) >> (int16_t)l_154.f1))
                { /* block id: 83 */
                    struct S0 *l_180 = (void*)0;
                    struct S0 **l_181 = &l_163;
                    (*l_181) = l_180;
                    /* statement id: 84 */
                    assert (l_163 == 0);
                }
                else
                { /* block id: 85 */
                    uint32_t l_182 = 0UL;
                    if (l_182)
                        break;
                }
                /* facts after branching */
                assert (l_163 == &l_154 || l_163 == 0);
                for (l_177 = 0; (l_177 <= 15); l_177 += 2)
                { /* block id: 90 */
                    int32_t *l_186 = (void*)0;
                    int32_t **l_185 = &l_186;
                    (*l_185) = &l_177;
                    /* statement id: 91 */
                    assert (l_186 == &l_177);
                    return l_187;
                }
            }
            else
            { /* block id: 94 */
                struct S0 l_188 = {167,40965,0,0x048EBA30L,0xA.9891BAp-68};
                return l_188;
            }
            /* facts after branching */
            assert (l_163 == &l_154 || l_163 == 0);
        }
    }
    (*l_191) = l_189;
    return l_192;
}


/* ------------------------------------------ */
/* 
 * reads : l_62 l_89.f4
 * writes: l_62 l_89.f4
 */
static int32_t  func_125(uint32_t  p_126, struct S0 * p_127, int32_t  p_128, float * p_129)
{ /* block id: 60 */
    int32_t l_138 = 0x9F35A7B3L;
    int32_t *l_142 = (void*)0;
    int32_t *l_143 = &l_138;
    struct S2 l_144 = {87,123,-29161};
    (*l_143) = __builtin_popcountll(((uint16_t)p_126 % (uint16_t)(4UL ^ ((int32_t)(l_138 < (((int16_t)((-(int16_t)(-5L)) <= (-5L)) - (int16_t)((((p_127 != (void*)0) && __builtin_bswap64(l_138)) && p_128) <= p_126)) != l_138)) + (int32_t)p_128))));
    (*p_129) = (*p_129);
    l_144 = l_144;
    return p_128;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 192
   depth: 1, occurrence: 41
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 106
breakdown:
   indirect level: 0, occurrence: 41
   indirect level: 1, occurrence: 53
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX times a bitfields struct's address is taken: 72
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 64
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 29

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 120
   depth: 2, occurrence: 31
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 235

XXX times a variable address is taken: 219
XXX times a pointer is dereferenced on RHS: 136
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 18
   depth: 3, occurrence: 2
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 113
breakdown:
   depth: 1, occurrence: 109
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 431

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 506
   level: 2, occurrence: 47
   level: 3, occurrence: 8
   level: 4, occurrence: 10
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 74
XXX number of pointers point to structs: 76
XXX percent of pointers has null in alias set: 23.4
XXX average alias set size: 1.42

XXX times a non-volatile is read: 898
XXX times a non-volatile is write: 288
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 115
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 21
   depth: 2, occurrence: 22
   depth: 3, occurrence: 13
   depth: 4, occurrence: 17
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

