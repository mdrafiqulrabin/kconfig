/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3177016824
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
   const int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_31(void);
inline static float  func_42(uint32_t  p_43, int32_t  p_44, uint16_t  p_45, int32_t  p_46);
static uint16_t  func_49(union U0  p_50, float  p_51, uint32_t  p_52, uint32_t  p_53, uint32_t  p_54);
static union U0  func_55(uint32_t  p_56, float  p_57, int16_t  p_58);
static float  func_59(uint32_t  p_60, int16_t  p_61);
inline static uint16_t  func_63(union U0  p_64);
inline static union U0  func_65(uint32_t  p_66, float  p_67, int16_t  p_68);
inline static float  func_70(uint16_t  p_71, int32_t  p_72, int32_t  p_73, int16_t  p_74, float  p_75);
static const uint16_t  func_82(int32_t  p_83, union U0  p_84, float  p_85);
inline static int16_t  func_89(int32_t  p_90);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_31(void)
{ /* block id: 36 */
    uint32_t l_41 = 3U;
    uint16_t l_443 = 2U;
    uint32_t l_458 = 6U;
    float l_464 = 0x5.05FA5Cp-31;
    float *l_463 = &l_464;
    union U0 l_466 = {0xD4D5};
    union U0 *l_465 = &l_466;
    union U0 **l_467 = &l_465;
    int32_t l_490 = (-1);
    int32_t *l_489 = &l_490;
    int32_t **l_488 = &l_489;
    int32_t ***l_487 = &l_488;
    uint16_t l_521 = 0x2F98;
    uint32_t l_577 = 0U;
    (*l_463) = ((((float)((-(float)((float)0x3.2C41ACp+63 + (float)((float)((float)(((0xD.C3D6C1p-94 != __builtin_popcount(l_41)) > func_42(l_41, ((((uint16_t)func_49(func_55(l_41, (l_41 <= func_59(l_41, l_41)), l_41), l_41, l_443, l_443, l_41) + (uint16_t)l_458) <= 0xB5572DAF) >= 65535U), l_458, l_458)) <= l_443) - (float)l_458) - (float)l_458))) < l_458) - (float)l_443) != l_443) < l_443);
    (*l_467) = l_465;
    for (l_458 = 0; (l_458 < 22); ++l_458)
    { /* block id: 292 */
        int32_t l_471 = 0x95827224;
        int32_t *l_470 = &l_471;
        uint16_t l_472 = 65530U;
        union U0 ***l_478 = &l_467;
        union U0 ****l_477 = &l_478;
        uint16_t l_531 = 0x11B9;
        int32_t l_548 = (-1);
        (*l_470) = 1;
        if (l_472)
            continue;
        (*l_463) = (*l_470);
        for (l_471 = (-1); (l_471 <= 21); l_471 += 9)
        { /* block id: 298 */
            int32_t **l_475 = (void*)0;
            int32_t **l_476 = &l_470;
            union U0 ** const l_495 = &l_465;
            int32_t l_519 = 1;
            int16_t l_563 = 0x31F8;
            (*l_476) = &l_471;
            (*l_463) = (**l_476);
        }
    }
    return l_577;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_42(uint32_t  p_43, int32_t  p_44, uint16_t  p_45, int32_t  p_46)
{ /* block id: 284 */
    uint32_t l_459 = 0x1DFCB4B0;
    int32_t l_461 = (-1);
    int32_t *l_460 = &l_461;
    int32_t **l_462 = &l_460;
    (*l_460) = (0x968E <= ((l_459 >= (&p_44 != &p_46)) & l_459));
    (*l_462) = &l_461;
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_49(union U0  p_50, float  p_51, uint32_t  p_52, uint32_t  p_53, uint32_t  p_54)
{ /* block id: 274 */
    uint32_t l_444 = 0x0BA9720E;
    int32_t *l_447 = (void*)0;
    int32_t **l_448 = (void*)0;
    union U0 l_451 = {9U};
    union U0 *l_450 = &l_451;
    union U0 **l_449 = &l_450;
    union U0 ***l_453 = &l_449;
    union U0 ****l_452 = &l_453;
    union U0 * const *l_457 = &l_450;
    union U0 * const **l_456 = &l_457;
    union U0 * const ***l_455 = &l_456;
    union U0 * const ****l_454 = &l_455;
    if (p_50.f0)
    { /* block id: 275 */
        return l_444;
    }
    else
    { /* block id: 277 */
        const int32_t l_446 = 0x9DB557B0;
        const int32_t *l_445 = &l_446;
        l_445 = l_445;
    }
    l_447 = l_447;
    (*l_449) = (void*)0;
    /* statement id: 281 */
    assert (l_450 == 0);
    (*l_454) = l_452;
    /* statement id: 282 */
    assert (l_455 == &l_453);
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_55(uint32_t  p_56, float  p_57, int16_t  p_58)
{ /* block id: 270 */
    float l_439 = (-0x7.Dp+1);
    float *l_438 = &l_439;
    int32_t l_441 = 0;
    int32_t *l_440 = &l_441;
    union U0 l_442 = {0xDF1C};
    (*l_438) = 0xE.40E5F0p-17;
    l_440 = l_438;
    /* statement id: 272 */
    assert (l_440 == &l_439);
    return l_442;
    /* statement id: 273 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_59(uint32_t  p_60, int16_t  p_61)
{ /* block id: 37 */
    int32_t l_62 = 0xD7F285F4;
    uint32_t l_69 = 0xF997EC53;
    union U0 l_86 = {0xA39B};
    const float l_375 = 0x7.2p-1;
    const float *l_374 = &l_375;
    const float **l_373 = &l_374;
    int32_t *l_395 = &l_62;
    int16_t l_407 = 0x760B;
    float *l_408 = (void*)0;
    float l_410 = 0xD.747B00p-44;
    float *l_409 = &l_410;
    int32_t **l_419 = &l_395;
    int32_t ***l_418 = &l_419;
    int32_t ****l_417 = &l_418;
    float l_434 = 0xB.8A4656p-7;
    if (((((9 == l_62) || (func_63(func_65(((-1) >= (p_60 && l_69)), (func_70(((uint16_t)(65535U ^ ((uint16_t)(l_62 | ((l_69 == ((uint16_t)func_82(p_61, l_86, l_86.f0) - (uint16_t)l_86.f0)) || (-10))) >> (uint16_t)13)) >> (uint16_t)12), l_62, p_60, l_69, p_60) == l_86.f0), p_61)) || p_61)) >= 0xFCB92070) ^ l_86.f0))
    { /* block id: 204 */
        float l_370 = 0x9.A6EA95p-38;
        float *l_369 = &l_370;
        (*l_369) = 0x1.7p-1;
    }
    else
    { /* block id: 206 */
        int32_t *l_371 = &l_62;
        int32_t **l_372 = &l_371;
        float **l_377 = (void*)0;
        float ***l_376 = &l_377;
        (*l_371) = p_61;
        (*l_372) = &l_62;
    }
    for (l_86.f0 = (-23); (l_86.f0 >= 26); l_86.f0 += 4)
    { /* block id: 248 */
        const union U0 *l_406 = (void*)0;
        const union U0 **l_405 = &l_406;
        (*l_405) = &l_86;
        /* statement id: 249 */
        assert (l_406 == &l_86);
    }
    (*l_409) = __builtin_ia32_crc32qi((*l_395), l_407);
    if ((*l_395))
    { /* block id: 252 */
        int32_t l_411 = 0x9E7B897F;
        return l_411;
    }
    else
    { /* block id: 254 */
        uint32_t l_416 = 0x49A6F945;
        float *l_422 = &l_410;
        int32_t *l_437 = &l_62;
        if ((func_89((*l_395)) >= ((int16_t)(((uint16_t)65535U % (uint16_t)p_60) || l_416) - (int16_t)p_61)))
        { /* block id: 255 */
            return p_61;
        }
        else
        { /* block id: 257 */
            int32_t ** const **l_420 = (void*)0;
            float *l_421 = &l_410;
            const uint32_t l_425 = 0x8096DA20;
            float **l_433 = &l_409;
            float ***l_432 = &l_433;
            float ****l_431 = &l_432;
            int32_t l_436 = 0x1866E465;
            (***l_418) = (l_417 != l_420);
            (*l_395) = p_61;
            if ((l_421 == l_422))
            { /* block id: 260 */
                union U0 *l_424 = &l_86;
                union U0 **l_423 = &l_424;
                (*l_423) = &l_86;
                (*l_395) = l_425;
            }
            else
            { /* block id: 263 */
                uint32_t l_428 = 0xA86A9014;
                const int32_t l_435 = 0xAF201FA3;
                (***l_432) = ((float)(((l_428 <= (***l_418)) < 0x5.E528EBp+9) < ((float)(func_70(((p_61 ^ (l_425 | ((*l_395) <= ((void*)0 != l_431)))) > (l_416 < 0x3B7B)), p_60, p_61, p_61, p_60) < l_435) + (float)0xA.27779Fp+50)) + (float)l_436);
            }
            (***l_417) = l_437;
        }
    }
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_63(union U0  p_64)
{ /* block id: 200 */
    const uint32_t l_365 = 0xBC8AC438;
    int32_t l_368 = 5;
    int32_t *l_367 = &l_368;
    int32_t **l_366 = &l_367;
    (*l_367) = ((float)l_365 - (float)((p_64.f0 <= 0x4.341899p+70) > ((p_64.f0 <= (p_64.f0 == p_64.f0)) == (l_366 != &l_367))));
    (**l_366) = __builtin_popcount((**l_366));
    return p_64.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_65(uint32_t  p_66, float  p_67, int16_t  p_68)
{ /* block id: 62 */
    int32_t l_128 = 0xC9FF6DE5;
    const int32_t ****l_156 = (void*)0;
    int32_t l_173 = 1;
    const float l_179 = 0x6.71F1E8p-66;
    int32_t l_189 = 0xA7AFDC65;
    int32_t *l_188 = &l_189;
    union U0 l_208 = {0x85D1};
    float l_217 = 0x0.7p-1;
    float *l_216 = &l_217;
    float **l_215 = &l_216;
    const union U0 l_221 = {0xFD88};
    const union U0 *l_220 = &l_221;
    uint32_t l_361 = 1U;
    union U0 l_362 = {0x57C8};
    if (l_128)
    { /* block id: 63 */
        int32_t l_137 = 0;
        int32_t *l_136 = &l_137;
        union U0 *l_162 = (void*)0;
        int32_t **l_164 = &l_136;
        union U0 **l_178 = (void*)0;
        int32_t ** const **l_224 = (void*)0;
        union U0 **l_232 = &l_162;
        float **l_237 = &l_216;
        if (p_68)
        { /* block id: 64 */
            int32_t l_132 = 0x35E3C92A;
            int32_t *l_131 = &l_132;
            union U0 **l_177 = &l_162;
lbl_209:
            for (p_68 = (-23); (p_68 <= 6); p_68++)
            { /* block id: 67 */
                int32_t **l_133 = &l_131;
                float l_135 = 0x4.E4C4DCp-36;
                float *l_134 = &l_135;
                (*l_133) = l_131;
                (*l_134) = p_66;
                (*l_133) = l_136;
                /* statement id: 70 */
                assert (l_131 == &l_137);
                (**l_133) = (l_128 == (*l_131));
            }
            if (p_66)
            { /* block id: 73 */
                int32_t *l_143 = &l_137;
                int32_t **l_148 = (void*)0;
                int32_t ***l_147 = &l_148;
                union U0 l_152 = {1U};
                int32_t l_200 = 0x843688B2;
                for (l_128 = (-13); (l_128 >= 12); l_128++)
                { /* block id: 76 */
                    int32_t *l_140 = (void*)0;
                    int32_t **l_141 = (void*)0;
                    int32_t **l_142 = &l_131;
                    (*l_142) = l_140;
                    /* statement id: 77 */
                    assert (l_131 == 0);
                }
                /* facts after for loop */
                assert (l_131 == 0 || l_131 == &l_137 || l_131 == &l_132);
                if (((l_143 == (void*)0) | p_68))
                { /* block id: 79 */
                    int32_t **l_144 = &l_131;
                    int32_t ****l_155 = &l_147;
                    union U0 * const l_160 = &l_152;
                    union U0 **l_161 = (void*)0;
                    (*l_144) = &l_132;
                    /* statement id: 80 */
                    assert (l_131 == &l_132);
                    if (((p_66 & ((uint16_t)__builtin_ctzll(p_68) % (uint16_t)p_66)) >= (p_68 >= p_66)))
                    { /* block id: 81 */
                        int32_t ** const *l_150 = (void*)0;
                        int32_t ** const **l_149 = &l_150;
                        (*l_144) = (*l_144);
                        if (p_68)
                            goto lbl_151;
lbl_151:
                        (*l_149) = l_147;
                        /* statement id: 83 */
                        assert (l_150 == &l_148);
                        (*l_144) = (*l_144);
                    }
                    else
                    { /* block id: 86 */
                        return l_152;
                        /* statement id: 87 */
                                            }
                    for (p_66 = 1; (p_66 < 53); p_66 += 4)
                    { /* block id: 91 */
                        uint32_t l_159 = 9U;
                        (**l_144) = (((((0xA705 & (0U & p_68)) && p_68) & (0xBF9D <= (-9))) >= ((l_155 == l_156) || ((int32_t)l_159 % (int32_t)p_68))) && p_66);
                        (*l_144) = &l_132;
                    }
                    l_162 = l_160;
                    /* statement id: 95 */
                    assert (l_162 == &l_152);
                }
                else
                { /* block id: 96 */
                    int32_t **l_163 = &l_136;
                    (*l_163) = &l_137;
                    l_164 = (void*)0;
                    /* statement id: 98 */
                    assert (l_164 == 0);
                    (*l_163) = &l_132;
                    /* statement id: 99 */
                    assert (l_136 == &l_132);
                }
                /* facts after branching */
                assert (l_136 == &l_132 || l_136 == &l_137);
                assert (l_162 == 0 || l_162 == &l_152);
                assert (l_164 == 0 || l_164 == &l_136);
                if (((int16_t)(((p_68 > (__builtin_clzl(((uint32_t)((*l_143) | p_68) % (uint32_t)(0x36E8 && ((int16_t)(0xBF92 < ((uint16_t)((-7) || l_173) >> (uint16_t)__builtin_bswap32(l_132))) << (int16_t)11)))) && (*l_136))) <= 4294967295U) >= 4294967295U) >> (int16_t)p_66))
                { /* block id: 101 */
                    union U0 **l_174 = &l_162;
lbl_190:
                    (*l_174) = l_162;
lbl_191:
                    if (((p_68 > __builtin_parityl(((((p_68 == __builtin_clzll(((uint32_t)__builtin_bswap64((*l_136)) + (uint32_t)((l_177 == l_178) == p_66)))) < ((int16_t)p_66 % (int16_t)p_66)) > p_66) || p_66))) > 0x7F3A6B8F))
                    { /* block id: 103 */
                        const uint32_t l_182 = 0U;
                        float l_187 = 0x7.Ap-1;
                        float *l_186 = &l_187;
                        (*l_186) = (l_182 < (((0x4.C857B7p+88 >= p_66) < (-(float)(((float)((-0x9.2p-1) == (-0x1.Ep-1)) - (float)p_68) > (__builtin_clzl(p_68) <= (__builtin_ctzll(p_68) > l_182))))) > 0x1.686610p-0));
                        l_188 = &l_132;
                        /* statement id: 105 */
                        assert (l_188 == &l_132);
                    }
                    else
                    { /* block id: 106 */
                        if (l_132)
                            goto lbl_190;
                        if (l_137)
                            goto lbl_191;
                    }
                    /* facts after branching */
                    assert (l_188 == &l_189 || l_188 == &l_132);
                    return l_152;
                    /* statement id: 110 */
                                    }
                else
                { /* block id: 111 */
                    (*l_136) = ((uint16_t)65535U << (uint16_t)2);
                }
                (*l_143) = ((uint16_t)__builtin_clzll((*l_143)) % (uint16_t)((uint32_t)(*l_188) - (uint32_t)((p_68 == l_200) < (((uint16_t)(*l_143) - (uint16_t)((int32_t)(+((__builtin_parityl(func_82(((func_82((((uint16_t)p_66 << (uint16_t)15) < p_68), l_208, p_67) && p_68) != 0xBF02E390), l_208, p_67)) >= p_66) || (*l_136))) - (int32_t)p_66)) != (*l_136)))));
            }
            else
            { /* block id: 115 */
                if (l_132)
                    goto lbl_209;
            }
            /* facts after branching */
            assert (l_131 == 0 || l_131 == &l_137 || l_131 == &l_132);
            assert (l_136 == &l_132 || l_136 == &l_137);
            //assert (l_162 == 0 || l_162 == dangling);
            assert (l_164 == 0 || l_164 == &l_136);
        }
        else
        { /* block id: 118 */
            int32_t ** const **l_212 = (void*)0;
            union U0 l_230 = {1U};
            union U0 **l_231 = &l_162;
            for (l_208.f0 = 0; (l_208.f0 > 7); ++l_208.f0)
            { /* block id: 121 */
                float l_214 = (-0x1.0p-1);
                float *l_213 = &l_214;
                float ***l_218 = &l_215;
                const union U0 *l_219 = &l_208;
                int32_t l_229 = 0x2D32AF4C;
                (*l_213) = ((void*)0 == l_212);
                (*l_218) = l_215;
                l_220 = l_219;
                /* statement id: 124 */
                assert (l_220 == &l_208);
                if ((((int16_t)(((**l_164) >= __builtin_ffs(p_68)) && ((p_68 < (((void*)0 == l_224) & (*l_188))) | p_66)) >> (int16_t)7) | ((p_66 ^ 4294967295U) > p_68)))
                { /* block id: 125 */
                    if (p_68)
                        break;
                    (*l_188) = 0xC49FD6B0;
                }
                else
                { /* block id: 128 */
                    l_229 = ((int16_t)((int16_t)(l_162 != (void*)0) << (int16_t)0) << (int16_t)6);
                    (*l_188) = 0xBBBDF832;
                    return l_230;
                    /* statement id: 131 */
                                    }
            }
            /* facts after for loop */
            assert (l_220 == &l_208 || l_220 == &l_221);
            l_232 = l_231;
        }
        /* facts after branching */
        //assert (l_136 == dangling || l_136 == &l_137);
        //assert (l_162 == 0 || l_162 == dangling);
        assert (l_164 == 0 || l_164 == &l_136);
        assert (l_220 == &l_208 || l_220 == &l_221);
        for (p_66 = 0; (p_66 < 20); p_66 += 6)
        { /* block id: 138 */
            const float *l_236 = &l_217;
            const float **l_235 = &l_236;
            int32_t l_238 = 0x485C87E2;
            (*l_188) = ((0U == ((void*)0 == &l_216)) & p_66);
            (*l_188) = p_68;
            (*l_188) = ((l_235 == l_237) || (l_238 || l_238));
            for (l_128 = 9; (l_128 != 3); l_128 -= 6)
            { /* block id: 144 */
                union U0 *l_241 = (void*)0;
                int32_t *l_242 = &l_238;
                (*l_232) = l_241;
                /* statement id: 145 */
                assert (l_162 == 0);
                (*l_232) = l_241;
                l_136 = l_242;
                /* statement id: 147 */
                assert (l_136 == &l_238);
            }
            /* facts after for loop */
            //assert (l_136 == &l_238 || l_136 == dangling || l_136 == &l_137);
        }
        for (l_137 = 0; (l_137 > (-26)); l_137 -= 9)
        { /* block id: 152 */
            union U0 l_245 = {65533U};
            return l_245;
            /* statement id: 153 */
                    }
        if (p_68)
        { /* block id: 155 */
            union U0 l_246 = {0x92F5};
            return l_246;
            /* statement id: 156 */
                    }
        else
        { /* block id: 157 */
            l_188 = &l_189;
        }
    }
    else
    { /* block id: 160 */
        float l_249 = 0x0.7p+1;
        int32_t l_250 = 0xB32E1920;
        int32_t * const *l_281 = &l_188;
        int32_t * const **l_280 = &l_281;
        int32_t * const ***l_279 = &l_280;
        int32_t l_308 = 0xA13BA321;
        float **l_329 = &l_216;
        int32_t l_358 = 0x0D0EAF78;
        if ((((uint16_t)p_66 >> (uint16_t)l_250) > __builtin_ctz((func_89((p_66 == (+(*l_188)))) <= (l_250 <= l_250)))))
        { /* block id: 161 */
            int32_t *l_252 = (void*)0;
            const int32_t *l_254 = &l_189;
            const int32_t **l_253 = &l_254;
            float ***l_261 = &l_215;
            const uint32_t l_278 = 0x723124B1;
            (*l_253) = l_252;
            /* statement id: 162 */
            assert (l_254 == 0);
            if (((int16_t)l_250 - (int16_t)l_250))
            { /* block id: 163 */
                float * const *l_263 = &l_216;
                float * const **l_262 = &l_263;
                int32_t l_271 = 0;
                (**l_215) = p_68;
                (*l_188) = (p_66 > ((int32_t)p_66 + (int32_t)(__builtin_ctzll(((p_68 < (l_261 == l_262)) || ((((-2) || ((uint32_t)(((*l_188) != l_250) > (((uint32_t)(+(((int16_t)(0x137A95C2 > l_250) >> (int16_t)10) && l_271)) + (uint32_t)p_66) == 0x10C314D7)) + (uint32_t)p_66)) & p_68) ^ 0xAFEC))) < l_271)));
                (***l_261) = ((0x2.E5EAE2p-30 == (((float)((float)l_250 - (float)((((((p_66 <= ((float)func_82(l_271, (*l_220), __builtin_ffsll((((__builtin_ffsl(((8 && (l_250 ^ (&l_271 != (void*)0))) >= 0x61DD9B7C)) == l_250) <= l_250) <= l_271))) - (float)l_250)) < l_250) >= 0x6.C1B5C8p-28) == 0x6.A39066p-7) >= l_271) <= p_66)) - (float)(-0x1.5p-1)) == l_278)) > p_68);
                (*l_253) = &l_271;
                /* statement id: 167 */
                assert (l_254 == &l_271);
            }
            else
            { /* block id: 168 */
                int32_t * const ***l_282 = &l_280;
                l_282 = l_279;
                (****l_279) = ((((uint16_t)(((((((uint16_t)p_66 << (uint16_t)((uint16_t)((p_66 ^ (**l_281)) != ((((****l_282) && ((int16_t)(****l_282) >> (int16_t)11)) == (((int16_t)(**l_281) << (int16_t)p_68) > __builtin_popcount((__builtin_popcount(((-1) >= 0xD023)) < p_66)))) >= 0xFD47)) - (uint16_t)0xCD59)) != (**l_281)) | (****l_282)) <= (****l_279)) | (****l_282)) || p_66) + (uint16_t)0x3D69) < 0x8741) & p_68);
            }
            /* facts after branching */
            //assert (l_254 == 0 || l_254 == dangling);
        }
        else
        { /* block id: 172 */
            union U0 *l_298 = (void*)0;
            float ***l_303 = &l_215;
            float ***l_304 = (void*)0;
            int32_t l_309 = 5;
            union U0 l_315 = {0x0ADE};
            (***l_280) = ((~((int16_t)(p_66 && p_68) % (int16_t)((int16_t)(func_89((l_298 == &l_208)) > ((p_68 | 0x387565C9) && (((uint16_t)func_89((l_303 != l_304)) >> (uint16_t)(****l_279)) <= 0x3CA2))) << (int16_t)(**l_281)))) & 0x1140);
            if (((uint16_t)(~__builtin_ffs(__builtin_popcountll(l_308))) << (uint16_t)(l_309 || func_82((p_66 | (((int16_t)((uint16_t)l_309 >> (uint16_t)(!__builtin_popcount(p_66))) % (int16_t)(*l_188)) & p_66)), l_315, p_66))))
            { /* block id: 174 */
                int32_t **l_316 = (void*)0;
                int32_t **l_317 = &l_188;
                (*l_317) = (*l_281);
                if ((((((uint16_t)p_66 >> (uint16_t)4) || ((uint16_t)(((*l_279) != (void*)0) >= 4294967287U) - (uint16_t)0x7C5D)) == 9) ^ p_66))
                { /* block id: 176 */
                    int32_t *l_322 = &l_308;
                    l_322 = (*l_317);
                    /* statement id: 177 */
                    assert (l_322 == &l_189);
                }
                else
                { /* block id: 178 */
                    union U0 l_330 = {65535U};
                    int32_t *l_344 = &l_309;
                    union U0 * const *l_346 = &l_298;
                    union U0 * const **l_345 = &l_346;
                    if ((((uint16_t)__builtin_ffsll(((**l_281) ^ ((int16_t)p_68 >> (int16_t)14))) - (uint16_t)((int16_t)(p_66 | (****l_279)) << (int16_t)(((__builtin_popcountll(p_66) < (4294967292U <= ((__builtin_bswap64((l_329 != (void*)0)) < (****l_279)) > (*l_188)))) <= 0xD75D) < 0x63C9))) && p_68))
                    { /* block id: 179 */
                        (**l_317) = (**l_317);
                    }
                    else
                    { /* block id: 181 */
                        return l_330;
                        /* statement id: 182 */
                                            }
                    (***l_280) = func_89(p_66);
                    if ((((int16_t)l_330.f0 << (int16_t)1) || (((int16_t)l_330.f0 << (int16_t)((int16_t)__builtin_clz((l_309 == (~(*l_188)))) - (int16_t)(((~((((int16_t)(p_66 != ((func_89((4294967289U == l_330.f0)) > p_68) && 0xEAF5)) - (int16_t)8) == p_66) <= p_68)) == 0x2EE99A63) == p_68))) ^ 0x2B098093)))
                    { /* block id: 185 */
                        int32_t *l_343 = &l_308;
                        (*l_216) = __builtin_clzll(((uint16_t)p_66 << (uint16_t)l_315.f0));
                        l_344 = l_343;
                        /* statement id: 187 */
                        assert (l_344 == &l_308);
                    }
                    else
                    { /* block id: 188 */
                        union U0 **l_349 = &l_298;
                        union U0 ***l_348 = &l_349;
                        union U0 ****l_347 = &l_348;
                        (*l_347) = l_345;
                        /* statement id: 189 */
                        assert (l_348 == &l_346);
                    }
                    /* facts after branching */
                    assert (l_344 == &l_309 || l_344 == &l_308);
                }
            }
            else
            { /* block id: 192 */
                int32_t **l_350 = &l_188;
                (**l_281) = p_66;
                (**l_281) = ((*l_280) == l_350);
            }
        }
        (**l_281) = (~(4 == ((((uint32_t)(***l_280) + (uint32_t)p_66) >= __builtin_ctzl(p_68)) < (((uint16_t)((int16_t)(p_66 | ((((l_358 >= (((-1) <= ((int32_t)(p_66 == (**l_281)) - (int32_t)(**l_281))) < 4294967295U)) >= p_66) && p_68) == p_66)) + (int16_t)l_361) >> (uint16_t)p_66) && 0xCFE8))));
    }
    /* facts after branching */
    assert (l_220 == &l_208 || l_220 == &l_221);
    return l_362;
    /* statement id: 199 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_70(uint16_t  p_71, int32_t  p_72, int32_t  p_73, int16_t  p_74, float  p_75)
{ /* block id: 47 */
    union U0 l_112 = {0x738B};
    union U0 *l_111 = &l_112;
    union U0 **l_110 = &l_111;
    float l_116 = (-0x1.Ep+1);
    float *l_115 = &l_116;
    (*l_110) = (void*)0;
    /* statement id: 48 */
    assert (l_111 == 0);
    if ((l_112.f0 < (l_115 != (void*)0)))
    { /* block id: 49 */
        int32_t l_118 = 0;
        int32_t *l_117 = &l_118;
        l_117 = l_117;
    }
    else
    { /* block id: 51 */
        int32_t l_119 = (-3);
        union U0 **l_124 = (void*)0;
lbl_127:
        (*l_115) = l_119;
        for (l_112.f0 = (-16); (l_112.f0 > 36); l_112.f0 += 4)
        { /* block id: 55 */
            float l_125 = (-0x1.9p+1);
            int32_t l_126 = (-1);
            (*l_115) = (((float)(-0x1.6p+1) - (float)(l_119 <= ((void*)0 != l_124))) == (l_125 != (l_126 == l_126)));
        }
        if (l_119)
            goto lbl_127;
        return p_74;
    }
    return l_112.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_82(int32_t  p_83, union U0  p_84, float  p_85)
{ /* block id: 38 */
    int32_t l_94 = 0;
    int32_t *l_93 = &l_94;
    float l_107 = (-0x1.5p-1);
    float *l_106 = &l_107;
    int32_t **l_108 = (void*)0;
    int32_t *l_109 = (void*)0;
    (*l_93) = (((int16_t)(func_89(p_83) >= 0x9548) >> (int16_t)4) || p_83);
    (*l_106) = (p_84.f0 < ((-(float)(-(float)(((p_85 != (*l_93)) < (&l_94 == (void*)0)) > (*l_93)))) == (__builtin_ctz(((int16_t)((-(int32_t)((uint16_t)((0x79B1 & ((uint16_t)(((int16_t)(func_89((*l_93)) ^ (*l_93)) % (int16_t)(*l_93)) && (*l_93)) << (uint16_t)11)) != (*l_93)) >> (uint16_t)3)) & (*l_93)) << (int16_t)9)) <= p_84.f0)));
    (*l_93) = (p_83 < (*l_93));
    l_109 = &l_94;
    /* statement id: 45 */
    assert (l_109 == &l_94);
    return p_84.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_89(int32_t  p_90)
{ /* block id: 39 */
    int32_t l_92 = 0x8934ECA6;
    int32_t *l_91 = &l_92;
    (*l_91) = (p_90 == p_90);
    return p_90;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 150
XXX total union variables: 11

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 180
   depth: 2, occurrence: 22
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 142

XXX times a variable address is taken: 139
XXX times a pointer is dereferenced on RHS: 125
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 34
   depth: 3, occurrence: 9
   depth: 4, occurrence: 10
XXX times a pointer is dereferenced on LHS: 98
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 14
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 329

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 180
   level: 2, occurrence: 69
   level: 3, occurrence: 22
   level: 4, occurrence: 12
XXX number of pointers point to pointers: 84
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.9
XXX average alias set size: 1.18

XXX times a non-volatile is read: 766
XXX times a non-volatile is write: 267
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 23
   depth: 2, occurrence: 23
   depth: 3, occurrence: 29
   depth: 4, occurrence: 21
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 23.5
XXX percentage an existing variable is used: 76.5
********************* end of statistics **********************/

