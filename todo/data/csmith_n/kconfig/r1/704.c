/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3734810144
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 30;
   signed f1 : 27;
   unsigned f2 : 17;
   unsigned f3 : 25;
   int32_t  f4;
   unsigned f5 : 14;
   signed f6 : 23;
   signed f7 : 20;
   unsigned f8 : 21;
};
#pragma pack(pop)

union U1 {
   uint16_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_31(void);
inline static int32_t  func_32(int32_t  p_33);
inline static int32_t  func_34(int32_t  p_35);
static int16_t  func_38(int32_t  p_39, int16_t  p_40, uint16_t  p_41, uint32_t  p_42);
inline static int16_t  func_48(struct S0  p_49, int32_t  p_50);
inline static struct S0  func_51(int32_t  p_52);
static uint32_t  func_63(int32_t  p_64, uint16_t  p_65, int32_t  p_66);
inline static int32_t  func_67(int32_t  p_68, uint16_t  p_69, struct S0  p_70);
static int16_t  func_71(union U1  p_72);
static union U1  func_79(struct S0  p_80, uint32_t  p_81, struct S0  p_82, struct S0  p_83, uint16_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(void)
{ /* block id: 36 */
    uint16_t l_36 = 65535U;
    int32_t l_37 = (-1);
    int32_t l_45 = 0x80A7C6DD;
    int32_t l_258 = 0xE7A1F087;
    int32_t l_259 = 0;
    int32_t l_286 = 0x4999E4DE;
    struct S0 l_287 = {22302,-5372,230,3331,-2,92,1008,453,1273};
    uint16_t l_290 = 65532U;
    l_286 |= func_32(func_34((l_259 = ((l_258 = ((l_37 = l_36) > func_38(l_36, (l_45 &= ((int32_t)l_36 + (int32_t)l_36)), ((uint32_t)l_36 - (uint32_t)(((func_48(func_51(l_36), ((0x7B4517E8 != (l_36 > l_36)) < 0x48C8)) ^ l_36) , l_36) || l_36)), l_36))) != 0x019B))));
    l_287 = func_51(l_286);
    l_259 ^= (l_290 |= ((uint16_t)7U >> (uint16_t)3));
    return l_287;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_32(int32_t  p_33)
{ /* block id: 214 */
    uint32_t l_267 = 0xDDFBCA2A;
    union U1 l_270 = {0xDBA4};
    struct S0 l_278 = {12966,-1006,281,2756,1,2,-1976,345,855};
    int32_t l_279 = (-1);
    uint32_t l_285 = 4294967290U;
    if ((-(int32_t)p_33))
    { /* block id: 215 */
        int16_t l_264 = (-1);
        union U1 l_271 = {0x8F47};
        uint32_t l_274 = 0xA8E17AFC;
        uint32_t l_275 = 0x01FB460B;
        int32_t l_276 = 1;
        struct S0 l_277 = {4620,-333,83,1806,1,39,-1307,668,1386};
        for (p_33 = 0; (p_33 <= 7); p_33 += 1)
        { /* block id: 218 */
            l_264 = p_33;
        }
        l_276 |= (p_33 = ((int16_t)(__builtin_clzl((l_267 & l_264)) , ((l_275 = (l_267 != (__builtin_clz(((uint16_t)((l_271 = (func_51(l_267) , (p_33 , l_270))) , ((uint16_t)1U << (uint16_t)l_270.f0)) << (uint16_t)l_274)) , p_33))) >= (-1))) >> (int16_t)p_33));
        l_278 = l_277;
    }
    else
    { /* block id: 226 */
        uint16_t l_283 = 0x58DF;
        if (l_279)
        { /* block id: 227 */
            uint16_t l_282 = 0x14C4;
            p_33 |= (-1);
            l_282 &= ((uint16_t)p_33 >> (uint16_t)6);
        }
        else
        { /* block id: 230 */
            l_278.f6 ^= (l_283 | p_33);
        }
    }
    l_285 = (-(int16_t)p_33);
    return l_279;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(int32_t  p_35)
{ /* block id: 211 */
    struct S0 l_260 = {25320,-8811,358,5753,-9,31,2545,-572,247};
    l_260 = l_260;
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_38(int32_t  p_39, int16_t  p_40, uint16_t  p_41, uint32_t  p_42)
{ /* block id: 206 */
    int32_t l_256 = 0;
    uint32_t l_257 = 1U;
    l_257 &= l_256;
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_48(struct S0  p_49, int32_t  p_50)
{ /* block id: 203 */
    p_50 = p_49.f7;
    return p_49.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_51(int32_t  p_52)
{ /* block id: 39 */
    int32_t l_55 = 0xF9491450;
    union U1 l_73 = {9U};
    union U1 l_101 = {0x5BAC};
    int16_t l_106 = 0xD65D;
    int32_t l_111 = 0x1C71BA02;
    int32_t l_112 = 1;
    struct S0 l_120 = {7068,-6265,27,3162,1,100,-2621,-248,1202};
    int32_t l_176 = (-6);
    uint32_t l_239 = 0x2CACBC3A;
    for (p_52 = (-29); (p_52 == (-23)); p_52 += 5)
    { /* block id: 42 */
        uint32_t l_56 = 4294967289U;
        union U1 l_74 = {65533U};
        struct S0 l_107 = {22581,3296,91,182,0x7F256DA8,118,-1781,963,50};
        struct S0 l_149 = {8247,1650,154,4718,0x22E85F59,32,-135,-606,363};
        int32_t l_236 = (-1);
        l_56 &= (l_55 = p_52);
        if (((uint32_t)(l_112 ^= (((uint16_t)__builtin_ia32_crc32qi((l_111 ^= (l_55 = ((uint32_t)((func_63((0xCEB2CFB1 <= func_67(((((p_52 && ((p_52 & func_71((l_74 = l_73))) >= (func_71((l_101 = l_73)) | ((int16_t)(((int16_t)(-4) + (int16_t)(p_52 && p_52)) <= l_56) * (int16_t)l_106)))) || 0xAFB16363) || l_73.f0) , p_52), l_55, l_107)), p_52, l_73.f0) , p_52) & 0x241C) % (uint32_t)l_107.f1))), l_107.f2) - (uint16_t)l_106) != l_73.f0)) - (uint32_t)0x3A361754))
        { /* block id: 84 */
            uint16_t l_114 = 0x5509;
            int32_t l_118 = 0;
            struct S0 l_121 = {7172,4916,37,1004,0x42B59B2D,121,-2403,440,441};
            int32_t l_127 = 0xA83C5579;
            if (((!p_52) <= (l_112 = ((((((l_114 |= 0xFA89) <= ((int16_t)((!l_107.f4) != 4294967294U) * (int16_t)(l_55 = (l_107.f7 = (l_118 < (l_107.f1 | l_107.f6)))))) , __builtin_popcountll(l_106)) , 0x3E85) != 0xAFD8) > l_107.f3))))
            { /* block id: 89 */
                int16_t l_119 = 0xAFC3;
                l_119 = p_52;
                l_107 = l_120;
            }
            else
            { /* block id: 92 */
                struct S0 l_124 = {21299,8443,256,4062,0xE310A9C0,7,-348,621,850};
                l_121 = l_107;
                for (l_111 = (-20); (l_111 > 9); l_111 += 1)
                { /* block id: 96 */
                    l_124 = l_107;
                }
            }
            l_120.f6 = ((int32_t)(l_127 , 0x8001A0E2) + (int32_t)l_111);
        }
        else
        { /* block id: 101 */
            struct S0 l_130 = {60,-9685,41,3412,1,70,-646,-826,1445};
            uint32_t l_137 = 0U;
            int32_t l_139 = 0x331CC493;
            uint32_t l_163 = 0xAD9788A3;
            if (p_52)
            { /* block id: 102 */
                uint32_t l_138 = 1U;
                l_130.f7 = (((uint16_t)0x0F15 << (uint16_t)3) > (l_120.f7 &= (func_79(l_130, l_111, l_130, l_107, ((l_139 = (((uint16_t)p_52 - (uint16_t)((uint16_t)((p_52 & p_52) != (((((((int16_t)(((l_137 | l_130.f7) == 0xD6EEDD9E) , l_130.f5) % (int16_t)0xCDC4) , p_52) != 0x01A1) <= 0x2123) == 0x37B6) < l_138)) << (uint16_t)p_52)) & p_52)) >= p_52)) , p_52)));
            }
            else
            { /* block id: 106 */
                struct S0 l_150 = {29262,2723,161,2451,0x24EADEB1,55,-153,-232,969};
                int32_t l_185 = 0x1B478E88;
                uint32_t l_203 = 0x5C6B9971;
                int32_t l_214 = 0x7185AD0F;
                struct S0 l_226 = {15342,-6933,323,5073,0xB8AD097F,43,331,-967,592};
                uint32_t l_234 = 0x40970185;
                if (p_52)
                { /* block id: 107 */
                    uint32_t l_146 = 0x70889BAE;
                    int32_t l_158 = (-9);
                    uint32_t l_169 = 4294967295U;
                    struct S0 l_188 = {14262,3109,54,4045,0xFCEA1EC8,125,51,-759,1139};
                    for (l_120.f4 = 0; (l_120.f4 >= (-25)); l_120.f4 -= 1)
                    { /* block id: 110 */
                        l_158 &= (((uint16_t)((uint32_t)(func_63((((l_120.f3 >= l_107.f4) != ((l_74 , l_146) , (((int16_t)((l_149 , ((l_150 , p_52) , (((((uint16_t)p_52 * (uint16_t)((int16_t)(!((uint16_t)(l_150.f4 < p_52) * (uint16_t)0x1E43)) << (int16_t)p_52)) != l_150.f6) , l_130.f7) | l_120.f7))) >= p_52) * (int16_t)65535U) , p_52))) , l_130.f6), l_137, p_52) , 0xCFEE3166) + (uint32_t)p_52) * (uint16_t)l_150.f6) & p_52);
                    }
                    for (l_106 = (-11); (l_106 <= 5); l_106 += 9)
                    { /* block id: 115 */
                        uint16_t l_170 = 2U;
                        struct S0 l_171 = {30492,-5229,85,1611,4,41,1023,204,813};
                        l_150.f1 &= ((l_120.f1 = ((p_52 >= p_52) , l_150.f8)) && (((int16_t)l_163 + (int16_t)p_52) == func_67((l_150.f7 = ((((~(l_150.f6 &= ((uint16_t)(l_130.f6 = 0xCC67) << (uint16_t)1))) <= p_52) == (l_169 &= ((((int16_t)(p_52 & 0xF762) * (int16_t)0xD038) < l_107.f4) && p_52))) && p_52)), l_170, l_107)));
                        return l_171;
                    }
                    if ((((((l_120.f1 = p_52) || (l_111 |= __builtin_parity(l_107.f7))) | ((int16_t)__builtin_parityll(l_137) + (int16_t)1U)) , ((((int16_t)l_176 >> (int16_t)((uint32_t)((int16_t)(~(~((((l_107.f1 = ((uint32_t)func_67(l_150.f5, p_52, l_150) - (uint32_t)0x9BE378BC)) && l_169) , l_120.f2) >= l_130.f4))) * (int16_t)p_52) + (uint32_t)l_120.f3)) && 0xEB458D05) || l_185)) != l_130.f4))
                    { /* block id: 127 */
                        l_130 = l_120;
                        l_150.f1 ^= (((uint32_t)p_52 - (uint32_t)p_52) & __builtin_clzl(p_52));
                        l_149 = ((l_158 , ((0xBE17463E && p_52) , l_188)) , (l_188 = l_107));
                    }
                    else
                    { /* block id: 132 */
                        l_149.f7 = ((l_73.f0 && ((((int16_t)(l_149.f0 , 0x3AA5) >> (int16_t)1) , ((((0xE17F >= p_52) & ((l_112 = (l_130.f3 || __builtin_ctzll((l_188.f6 || l_188.f8)))) , l_150.f7)) | 1) , p_52)) > p_52)) > l_130.f2);
                    }
                }
                else
                { /* block id: 136 */
                    int32_t l_191 = 1;
                    struct S0 l_202 = {21927,-3554,293,4173,0x8EC8C7DF,42,1280,-475,433};
                    if ((l_191 >= ((p_52 , func_63(((l_120.f1 ^ (((((int16_t)(l_150.f6 = (l_73.f0 ^ (-1))) >> (int16_t)((int16_t)((func_63(((uint16_t)(l_107.f7 ^= ((uint16_t)(l_150.f8 > ((int16_t)p_52 - (int16_t)(((l_150.f4 , (func_67((l_120 , l_130.f2), p_52, l_202) , p_52)) <= l_107.f4) >= l_203))) >> (uint16_t)13)) >> (uint16_t)p_52), l_150.f7, p_52) , l_150.f3) ^ p_52) >> (int16_t)7)) & 0x042488E8) && l_202.f4) | 0xDA90)) >= p_52), p_52, p_52)) < l_202.f6)))
                    { /* block id: 139 */
                        l_130 = l_120;
                    }
                    else
                    { /* block id: 141 */
                        l_202.f7 = p_52;
                        l_202 = l_107;
                    }
                    if (p_52)
                        continue;
                }
                for (l_163 = 0; (l_163 != 10); l_163 += 1)
                { /* block id: 149 */
                    int32_t l_212 = (-1);
                    struct S0 l_213 = {20502,10984,272,3484,0x9B3D71B0,116,409,-415,92};
                    for (l_101.f0 = 0; (l_101.f0 >= 1); l_101.f0 += 1)
                    { /* block id: 152 */
                        int16_t l_215 = 0x13AD;
                        l_150.f1 = (p_52 >= ((l_215 &= (l_139 &= ((uint16_t)((uint16_t)l_212 << (uint16_t)((((p_52 ^ ((l_107 , ((l_214 ^= func_71(func_79(l_150, p_52, l_213, l_150, (l_120 , 0x5BDB)))) == 0)) >= l_56)) ^ l_106) , l_74) , p_52)) << (uint16_t)4))) != 0x75E5F06E));
                        l_150.f1 = ((((int16_t)((((l_150.f7 > (((uint16_t)l_215 - (uint16_t)(__builtin_clz((p_52 && 0)) , l_73.f0)) , (__builtin_parityl(p_52) , 1))) ^ 7) & 1U) , p_52) * (int16_t)l_139) != 2U) && l_149.f4);
                        if (l_149.f5)
                            continue;
                    }
                    if (l_106)
                    { /* block id: 160 */
                        uint32_t l_220 = 0xF82136C5;
                        l_220 = l_213.f0;
                        return l_120;
                    }
                    else
                    { /* block id: 163 */
                        uint16_t l_221 = 0U;
                        l_221 = 0xC6B0DC29;
                        l_107 = l_150;
                        l_120 = l_130;
                    }
                    return l_150;
                }
                l_176 |= p_52;
                for (l_56 = 0; (l_56 != 27); l_56 += 3)
                { /* block id: 173 */
                    uint16_t l_225 = 0x7031;
                    struct S0 l_227 = {26650,-2302,353,4773,0x33C6B0B5,23,790,-321,479};
                    struct S0 l_235 = {13925,-8058,172,4078,0x3F9E5FAA,64,1903,-151,1226};
                    l_130 = l_150;
                    l_150.f6 &= (((~l_130.f3) , p_52) >= l_150.f1);
                    l_150.f6 = ((l_225 , ((8 || (l_150.f1 ^= p_52)) >= func_71(func_79((l_227 = (l_130 = l_226)), func_63(l_107.f2, (l_176 = ((uint16_t)((uint32_t)l_120.f6 - (uint32_t)(l_226 , (((l_139 ^= ((int16_t)(func_79(l_226, l_225, l_107, l_149, l_234) , p_52) << (int16_t)9)) , l_150.f0) && l_120.f0))) % (uint16_t)p_52)), l_137), l_120, l_235, p_52)))) == l_107.f4);
                }
            }
            l_139 = l_236;
            l_120 = l_107;
            l_120.f1 &= (-1);
        }
    }
    p_52 ^= l_120.f1;
    if (((l_101.f0 >= (l_120.f6 < (((l_120.f0 && p_52) == p_52) , p_52))) && (p_52 == (((l_73.f0 || (((uint16_t)l_111 << (uint16_t)13) == l_239)) >= p_52) ^ 0U))))
    { /* block id: 190 */
        uint32_t l_240 = 0xA881E8D3;
        l_240 ^= p_52;
    }
    else
    { /* block id: 192 */
        struct S0 l_241 = {7561,-1075,129,5411,-4,23,-2856,-972,349};
        struct S0 l_242 = {6746,5323,291,27,0xBAE2EA2E,93,-1305,390,950};
        l_241 = l_120;
        l_241 = ((0x0261 & (func_67(((l_241.f3 , ((l_101 = func_79(l_120, (l_241.f6 = l_120.f3), l_242, l_242, (((uint32_t)(!((int16_t)(((uint16_t)(-(uint32_t)p_52) >> (uint16_t)3) <= p_52) - (int16_t)(((uint16_t)(__builtin_clz((l_241.f7 = p_52)) , p_52) << (uint16_t)0) , 0x0F9E))) - (uint32_t)p_52) < l_242.f8))) , p_52)) , l_120.f5), p_52, l_242) && l_120.f5)) , l_242);
        l_241.f7 |= ((((int32_t)p_52 % (int32_t)p_52) != p_52) , l_120.f5);
        l_241.f6 = p_52;
    }
    l_111 &= (~0xE552);
    return l_120;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_63(int32_t  p_64, uint16_t  p_65, int32_t  p_66)
{ /* block id: 78 */
    struct S0 l_110 = {22865,9590,174,285,0xBC2B75F9,23,-274,426,108};
    l_110 = l_110;
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_67(int32_t  p_68, uint16_t  p_69, struct S0  p_70)
{ /* block id: 70 */
    p_70.f1 &= 0xB6A99605;
    for (p_69 = 29; (p_69 == 53); p_69 += 1)
    { /* block id: 74 */
        return p_70.f7;
    }
    return p_70.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_71(union U1  p_72)
{ /* block id: 46 */
    uint32_t l_75 = 0x19C50ED6;
    struct S0 l_86 = {16694,4892,165,3828,1,51,-2800,182,886};
    int32_t l_96 = 7;
    l_75 = (0x237F != 7);
    for (p_72.f1 = (-2); (p_72.f1 <= 22); p_72.f1 += 1)
    { /* block id: 50 */
        int32_t l_85 = 0x338462C7;
        int32_t l_91 = (-1);
        int32_t l_95 = 0x771C7562;
        if ((!p_72.f1))
        { /* block id: 51 */
            struct S0 l_92 = {11189,881,209,4812,0x354C0A20,6,990,-225,941};
            l_92.f7 = ((func_79(((l_85 = 0x7CFF1CC5) , l_86), ((uint16_t)((int32_t)p_72.f0 + (int32_t)l_91) << (uint16_t)12), l_86, l_92, (l_96 = ((l_92.f0 || l_86.f5) | __builtin_popcountl((((((((int16_t)((((l_95 = l_86.f8) , 0x92DDE99E) || 1) != l_92.f2) % (int16_t)l_91) == 0xBB5B) , p_72.f0) || l_95) != 0xF6C6) | 0xC480))))) , p_72.f1) & p_72.f1);
        }
        else
        { /* block id: 60 */
            uint32_t l_100 = 4294967293U;
            l_86.f1 = l_100;
            if (p_72.f1)
                continue;
            if (l_100)
                continue;
            l_95 = (p_72.f1 >= (l_86.f7 = p_72.f0));
        }
    }
    return l_86.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_79(struct S0  p_80, uint32_t  p_81, struct S0  p_82, struct S0  p_83, uint16_t  p_84)
{ /* block id: 55 */
    struct S0 l_97 = {2768,7962,54,4597,0,60,-1017,223,1329};
    struct S0 l_98 = {2384,6150,255,4452,0xB60A5FB0,34,-268,39,940};
    union U1 l_99 = {0xDD16};
    l_97 = l_97;
    l_98 = ((p_80.f8 <= p_80.f4) , (l_97 , p_80));
    return l_99;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 72
   depth: 1, occurrence: 25
XXX total union variables: 6

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 25
breakdown:
   indirect level: 0, occurrence: 25
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 22
XXX times a bitfields struct on RHS: 54
XXX times a single bitfield on LHS: 31
XXX times a single bitfield on RHS: 57

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 15
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 6, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 3
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1
   depth: 34, occurrence: 2

XXX total number of pointers: 0

XXX times a non-volatile is read: 336
XXX times a non-volatile is write: 114
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 13
   depth: 2, occurrence: 15
   depth: 3, occurrence: 9
   depth: 4, occurrence: 12
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 22.4
XXX percentage an existing variable is used: 77.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

