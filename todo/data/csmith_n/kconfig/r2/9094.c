/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1089889208
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
};
#pragma pack(pop)

union U1 {
   int64_t  f0;
};

union U2 {
   int64_t  f0;
   float  f1;
   struct S0  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_33(void);
static const float  func_46(const int16_t  p_47, int32_t  p_48, int64_t  p_49, struct S0  p_50, uint16_t  p_51);
inline static const int16_t  func_52(union U2  p_53, int16_t  p_54, union U2  p_55);
static union U2  func_56(int32_t  p_57, struct S0  p_58, int64_t  p_59);
inline static uint16_t  func_60(uint32_t  p_61, union U2  p_62, uint64_t  p_63, int32_t  p_64, uint32_t  p_65);
inline static union U2  func_66(uint32_t  p_67, uint32_t  p_68, int16_t  p_69, struct S0  p_70);
inline static struct S0  func_79(uint16_t  p_80);
inline static uint16_t  func_92(struct S0 * p_93, int64_t  p_94, int32_t  p_95, int32_t * p_96);
inline static int32_t * const * const  func_99(struct S0 * p_100);
inline static struct S0 ** func_110(int64_t  p_111, struct S0  p_112, int16_t  p_113, const struct S0 * p_114);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_33(void)
{ /* block id: 36 */
    int64_t l_45 = (-1L);
    int16_t l_71 = 1L;
    struct S0 l_72 = {0xA2E255BB5FB49A5CLL};
    union U2 l_390 = {0x0752AFE84FE09BB1LL};
    float *l_421 = &l_390.f1;
    struct S0 *l_422 = &l_390.f2;
    (*l_421) = ((float)((float)((float)(0x6.6A5308p-13 > 0x1.Dp+1) - (float)((float)(!((float)l_45 / (float)l_45)) - (float)func_46(func_52(func_56(((-9L) ^ func_60(l_45, func_66((l_45 || 0xFF74F57B17B4D2C2LL), l_45, l_71, l_72), l_45, l_72.f0, l_72.f0)), l_72, l_72.f0), l_71, l_390), l_390.f0, l_390.f0, l_390.f2, l_390.f0))) - (float)l_45) + (float)l_72.f0);
    /* statement id: 200 */
        (*l_422) = func_79(l_45);
    /* statement id: 201 */
        (*l_421) = l_72.f0;
    /* statement id: 202 */
        l_422 = (void*)0;
    /* statement id: 203 */
    assert (l_422 == 0);
    return l_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_46(const int16_t  p_47, int32_t  p_48, int64_t  p_49, struct S0  p_50, uint16_t  p_51)
{ /* block id: 197 */
    const float *l_420 = (void*)0;
    const float **l_419 = &l_420;
    const float ***l_418 = &l_419;
    l_418 = l_418;
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_52(union U2  p_53, int16_t  p_54, union U2  p_55)
{ /* block id: 186 */
    int32_t l_395 = 0x79F683CEL;
    int32_t *l_394 = &l_395;
    int32_t ** const l_393 = &l_394;
    struct S0 l_400 = {-7L};
    struct S0 *l_399 = &l_400;
    struct S0 **l_398 = &l_399;
    struct S0 *** const l_397 = &l_398;
    struct S0 *** const *l_396 = &l_397;
    int32_t * const *l_413 = &l_394;
    int32_t l_414 = 0x600E6A57L;
    float *l_415 = (void*)0;
    float l_417 = (-0x10.1p+1);
    float *l_416 = &l_417;
    if (((-(uint16_t)((+p_55.f0) < (((l_393 == (void*)0) && ((l_396 != &l_397) && ((*l_393) == (*l_393)))) && (((int16_t)p_53.f2.f0 >> (int16_t)10) ^ ((func_92((*l_398), p_55.f2.f0, (*l_394), (*l_393)) <= (-1L)) > p_55.f0))))) >= p_53.f2.f0))
    { /* block id: 187 */
        union U2 l_404 = {0x023BC67531C0F092LL};
        union U2 *l_403 = &l_404;
        union U2 **l_405 = &l_403;
        int32_t l_410 = 1L;
        (*l_405) = l_403;
        (*l_394) = ((uint64_t)p_53.f0 - (uint64_t)((int16_t)0x60F1L % (int16_t)l_410));
    }
    else
    { /* block id: 190 */
        int32_t * const l_411 = (void*)0;
        int32_t **l_412 = &l_394;
        (*l_393) = (void*)0;
        /* statement id: 191 */
        assert (l_394 == 0);
        (*l_412) = l_411;
        l_413 = &l_411;
        /* statement id: 193 */
        assert (l_413 == &l_411);
    }
    /* facts after branching */
    assert (l_394 == 0 || l_394 == &l_395);
    //assert (l_413 == dangling || l_413 == &l_394);
    (*l_416) = l_414;
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_56(int32_t  p_57, struct S0  p_58, int64_t  p_59)
{ /* block id: 176 */
    union U1 l_364 = {0x6463CA252AE98F46LL};
    union U1 *l_363 = &l_364;
    int32_t *l_365 = (void*)0;
    struct S0 l_383 = {0xF1462849A9B351D3LL};
    struct S0 *l_382 = &l_383;
    uint8_t l_384 = 0xA1L;
    union U2 l_385 = {0xAD67FAE14E27A1FFLL};
    int32_t *l_386 = (void*)0;
    int32_t *l_387 = (void*)0;
    int32_t l_389 = 0x4DAC0EC0L;
    int32_t *l_388 = &l_389;
    if (((void*)0 == l_363))
    { /* block id: 177 */
        union U1 **l_367 = &l_363;
        union U1 *** const l_366 = &l_367;
        float *l_368 = (void*)0;
        float l_370 = 0x0.F39972p-13;
        float *l_369 = &l_370;
        l_365 = l_365;
        (*l_369) = ((p_57 == p_59) != (l_366 == &l_367));
    }
    else
    { /* block id: 180 */
        const int32_t l_373 = 1L;
        const int32_t *l_372 = &l_373;
        const int32_t **l_371 = &l_372;
        int32_t l_375 = 0xE80497F3L;
        int32_t *l_374 = &l_375;
        (*l_371) = &p_57;
        /* statement id: 181 */
        assert (l_372 == &p_57);
        (*l_374) = 1L;
    }
    (*l_388) = func_60(((!(((uint64_t)l_364.f0 - (uint64_t)(p_59 == p_57)) != (0x1473L == (+((int16_t)(func_92(l_382, (&l_365 == &l_365), p_59, l_365) > l_384) % (int16_t)5UL))))) & 0xAD8FED3AB3DB0E18LL), l_385, p_57, p_58.f0, p_59);
    return l_385;
    /* statement id: 185 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_60(uint32_t  p_61, union U2  p_62, uint64_t  p_63, int32_t  p_64, uint32_t  p_65)
{ /* block id: 172 */
    float l_359 = 0x0.22DCEFp-22;
    float *l_358 = &l_359;
    float **l_357 = &l_358;
    float ***l_360 = &l_357;
    int32_t l_362 = 0x1EC6C1B3L;
    int32_t *l_361 = &l_362;
    (*l_360) = l_357;
    l_361 = l_358;
    /* statement id: 174 */
    assert (l_361 == &l_359);
    return p_62.f2.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_66(uint32_t  p_67, uint32_t  p_68, int16_t  p_69, struct S0  p_70)
{ /* block id: 37 */
    const uint32_t l_75 = 0x32DA3BB1L;
    int32_t l_76 = 0L;
    struct S0 l_98 = {0x9A83ADAB8F5B6EF3LL};
    struct S0 *l_97 = &l_98;
    struct S0 **l_191 = &l_97;
    struct S0 *** const l_190 = &l_191;
    int32_t l_206 = 1L;
    float l_238 = 0x0.Fp+1;
    struct S0 ***l_244 = &l_191;
    struct S0 ****l_243 = &l_244;
    const union U1 ***l_252 = (void*)0;
    uint64_t l_318 = 18446744073709551609UL;
    int32_t l_328 = 0x9E64E212L;
    uint32_t l_354 = 0x431C94D6L;
    int32_t *l_355 = &l_206;
    union U2 l_356 = {-2L};
lbl_175:
    l_76 = ((uint16_t)p_70.f0 % (uint16_t)l_75);
    for (l_76 = 0; (l_76 >= (-30)); l_76 -= 2)
    { /* block id: 41 */
        struct S0 l_91 = {0L};
        struct S0 *l_90 = &l_91;
        int32_t *l_148 = &l_76;
        int32_t *l_187 = (void*)0;
        struct S0 * const * const l_247 = &l_90;
        struct S0 * const * const *l_246 = &l_247;
        struct S0 * const * const **l_245 = &l_246;
        union U1 l_256 = {-1L};
        const union U1 *l_255 = &l_256;
        const union U1 **l_254 = &l_255;
        const union U1 ***l_253 = &l_254;
        struct S0 ***l_265 = &l_191;
        union U2 l_341 = {1L};
        (*l_90) = func_79(p_70.f0);
        if ((((func_92(l_97, p_69, p_70.f0, &l_76) && (0x1437717EL == 1UL)) < ((uint16_t)l_91.f0 % (uint16_t)__builtin_ctz((p_67 ^ p_67)))) ^ p_70.f0))
        { /* block id: 77 */
            int32_t **l_149 = &l_148;
            struct S0 *l_176 = &l_98;
            int32_t l_184 = 0x768FFD6EL;
            int32_t *l_183 = &l_184;
            float l_189 = 0x1.AA2CA7p-85;
            float *l_188 = &l_189;
            (*l_149) = l_148;
            for (l_98.f0 = 0; (l_98.f0 < (-5)); l_98.f0--)
            { /* block id: 81 */
                struct S0 *l_173 = (void*)0;
                int32_t *l_174 = &l_76;
                for (p_68 = 0; (p_68 <= 23); p_68++)
                { /* block id: 84 */
                    int32_t *l_172 = &l_76;
                    int32_t *l_178 = &l_76;
                    int32_t l_180 = (-9L);
                    int32_t *l_179 = &l_180;
                    for (p_67 = 1; (p_67 == 21); p_67 += 8)
                    { /* block id: 87 */
                        struct S0 * const l_164 = &l_91;
                        int32_t l_165 = 0xD2484370L;
                        int32_t *l_166 = &l_165;
                        (*l_166) = ((int64_t)((uint32_t)((int16_t)(((((int16_t)((void*)0 == l_164) >> (int16_t)8) | ((&l_98 == &p_70) | l_165)) >= p_68) || 0UL) << (int16_t)__builtin_clz((((void*)0 != &l_90) || l_165))) % (uint32_t)1UL) % (int64_t)0xF4590BACEAEEF4A5LL);
                        (*l_166) = ((__builtin_popcountll(l_76) < (((uint16_t)((int32_t)(!0x808A6355L) - (int32_t)0x6F087C22L) << (uint16_t)7) >= ((((l_75 ^ ((void*)0 != l_172)) & p_70.f0) < p_68) || (*l_172)))) && (*l_174));
                        if ((**l_149))
                            break;
                        if (l_91.f0)
                            goto lbl_175;
                    }
                    (*l_179) = (l_98.f0 != p_70.f0);
                }
                if (p_70.f0)
                    continue;
                for (p_68 = 0; (p_68 == 46); ++p_68)
                { /* block id: 98 */
                    (*l_90) = (*l_90);
                }
            }
            (*l_183) = p_70.f0;
            (*l_188) = ((float)func_92(&l_91, p_67, p_69, l_187) / (float)0x0.1p-1);
        }
        else
        { /* block id: 104 */
            uint64_t l_204 = 1UL;
            int32_t *l_227 = (void*)0;
            struct S0 *l_251 = (void*)0;
            int32_t l_271 = (-9L);
            (*l_97) = p_70;
            if ((((l_190 == &l_191) & ((uint16_t)(+func_92((**l_190), ((int16_t)p_70.f0 + (int16_t)((!((int32_t)(*l_148) - (int32_t)((int16_t)((func_92((**l_190), ((uint16_t)l_204 - (uint16_t)p_68), p_70.f0, &l_76) > l_204) < 0x94EFEA996BB96E4ALL) % (int16_t)0xA6B8L))) == l_76)), p_67, l_187)) << (uint16_t)(*l_148))) && l_75))
            { /* block id: 106 */
                union U1 l_208 = {0x10A321F159A5490CLL};
                union U1 *l_207 = &l_208;
                int16_t l_226 = 0L;
                int32_t l_228 = (-1L);
                if (((p_70.f0 || p_68) != l_204))
                { /* block id: 107 */
                    struct S0 **l_205 = &l_90;
                    struct S0 *l_213 = (void*)0;
                    const int32_t l_225 = (-1L);
                    union U2 l_229 = {0xA779F58EA2508C1DLL};
                    l_206 = (p_68 <= (((void*)0 == l_205) >= (&p_70 == &p_70)));
                    l_207 = (void*)0;
                    /* statement id: 109 */
                    assert (l_207 == 0);
                    for (l_98.f0 = (-6); (l_98.f0 >= 7); l_98.f0 += 1)
                    { /* block id: 112 */
                        float l_212 = 0x9.C7F9DBp+60;
                        float *l_211 = &l_212;
                        struct S0 *l_218 = &l_98;
                        int32_t l_219 = 0x464F8113L;
                        const uint64_t l_224 = 1UL;
                        (*l_211) = p_67;
                        l_228 = l_75;
                        return l_229;
                        /* statement id: 115 */
                                            }
                }
                else
                { /* block id: 117 */
                    struct S0 *l_233 = (void*)0;
                    union U1 *l_236 = &l_208;
                    int32_t l_237 = 0xDA66330FL;
                    int32_t *l_239 = &l_237;
                    union U1 **l_240 = &l_236;
                    struct S0 ***l_242 = &l_191;
                    struct S0 ****l_241 = &l_242;
                    float *l_250 = &l_238;
                    (*l_239) = ((uint16_t)(-(uint32_t)p_67) >> (uint16_t)p_67);
                    (*l_240) = l_236;
                    l_243 = l_241;
                    /* statement id: 120 */
                    assert (l_243 == &l_242);
                    (*l_250) = func_92(&l_91, __builtin_popcountl((l_245 != &l_244)), ((uint64_t)l_208.f0 % (uint64_t)l_206), &l_237);
                }
                /* facts after branching */
                assert (l_207 == &l_208 || l_207 == 0);
                l_251 = (*l_247);
                /* statement id: 123 */
                assert (l_251 == &l_91);
                l_253 = l_252;
                /* statement id: 124 */
                assert (l_253 == 0);
                if (l_228)
                { /* block id: 125 */
                    int32_t **l_257 = (void*)0;
                    int32_t **l_258 = &l_148;
                    (*l_258) = l_227;
                    /* statement id: 126 */
                    assert (l_148 == 0);
                }
                else
                { /* block id: 127 */
                    struct S0 *l_266 = &l_91;
                    int32_t l_270 = 0x866C5702L;
                    float *l_281 = &l_238;
                    if (((int16_t)(l_98.f0 ^ l_208.f0) >> (int16_t)l_75))
                    { /* block id: 128 */
                        uint64_t l_261 = 18446744073709551614UL;
                        l_261 = l_98.f0;
                        if ((*l_148))
                            break;
                    }
                    else
                    { /* block id: 131 */
                        l_206 = (0x6.E05E15p-14 == (0xD.62BB3Bp-16 <= p_67));
                    }
                    for (l_228 = (-23); (l_228 == 20); l_228 += 4)
                    { /* block id: 136 */
                        struct S0 ***l_264 = &l_191;
                        if ((*l_148))
                            break;
                        l_265 = l_264;
                        l_271 = func_92(&p_70, p_67, (p_69 > (func_92(l_266, (0x5A96L ^ (1UL < (~p_70.f0))), l_270, &l_76) >= p_70.f0)), &l_228);
                    }
                    (*l_281) = ((((float)((func_92((**l_244), (*l_148), func_92(l_251, func_92((**l_265), l_226, ((!((uint64_t)(((int16_t)0x08A2L << (int16_t)7) == ((uint64_t)l_76 - (uint64_t)0x0EB1AB0853695344LL)) - (uint64_t)(4294967286UL >= 0x19B35F8EL))) <= 8L), &l_76), p_70.f0, &l_206), &l_270) < p_68) == (*l_148)) - (float)0x0.6p-1) <= p_68) != l_270);
                }
                /* facts after branching */
                assert (l_148 == &l_76 || l_148 == 0);
            }
            else
            { /* block id: 143 */
                const union U1 **l_284 = &l_255;
                int32_t l_305 = 0xD219E0C1L;
                float *l_324 = &l_238;
                struct S0 *l_338 = &l_91;
                if (((uint16_t)((*l_253) != l_284) << (uint16_t)2))
                { /* block id: 144 */
                    const int32_t *l_289 = &l_76;
                    const int32_t **l_288 = &l_289;
                    const int32_t ***l_287 = &l_288;
                    int32_t *l_307 = &l_305;
                    if (l_206)
                    { /* block id: 145 */
                        int32_t l_285 = (-10L);
                        float *l_286 = &l_238;
                        int32_t ****l_290 = (void*)0;
                        int32_t **l_293 = &l_148;
                        int32_t ***l_292 = &l_293;
                        int32_t ****l_291 = &l_292;
                        (**l_253) = (*l_284);
                        (*l_286) = (p_67 >= l_285);
                        (*l_291) = l_287;
                        /* statement id: 148 */
                        assert (l_292 == &l_288);
                    }
                    else
                    { /* block id: 149 */
                        union U1 ***l_302 = (void*)0;
                        int32_t l_306 = 0x6923628DL;
                        float *l_319 = &l_238;
                        (*l_253) = l_284;
                        (*l_319) = ((float)__builtin_ctzl(((int32_t)(((uint32_t)(((int64_t)((void*)0 == l_302) % (int64_t)p_70.f0) < ((uint32_t)l_98.f0 / (uint32_t)(((uint64_t)((uint16_t)((int16_t)(((int16_t)((uint16_t)p_69 + (uint16_t)9L) << (int16_t)3) <= p_69) << (int16_t)p_70.f0) % (uint16_t)0x5A70L) / (uint64_t)p_68) & (*l_148)))) + (uint32_t)p_67) >= 0x7034L) % (int32_t)l_318)) - (float)p_67);
                    }
                }
                else
                { /* block id: 153 */
                    float l_327 = (-0x9.Fp+1);
                    if (((uint32_t)((uint32_t)4294967295UL - (uint32_t)(l_324 == (void*)0)) % (uint32_t)(l_305 && p_70.f0)))
                    { /* block id: 154 */
                        int32_t **l_329 = &l_187;
                        (*l_329) = &l_76;
                        /* statement id: 155 */
                        assert (l_187 == &l_76);
                        (*l_324) = (l_76 > ((float)p_69 / (float)(((float)((((float)p_70.f0 / (float)((float)l_75 + (float)func_92(l_338, p_67, (l_148 != l_324), &l_271))) > l_305) > p_69) + (float)0x8.894A63p-79) != l_76)));
                        p_70 = func_79(p_68);
                    }
                    else
                    { /* block id: 158 */
                        const int32_t *l_340 = &l_76;
                        const int32_t **l_339 = &l_340;
                        (*l_339) = (void*)0;
                        /* statement id: 159 */
                        assert (l_340 == 0);
                    }
                    /* facts after branching */
                    assert (l_187 == 0 || l_187 == &l_76);
                    (*l_324) = p_68;
                    (**l_247) = p_70;
                }
                /* facts after branching */
                assert (l_187 == 0 || l_187 == &l_76);
                return l_341;
                /* statement id: 164 */
                            }
            /* facts after branching */
            assert (l_148 == &l_76 || l_148 == 0);
            assert (l_251 == &l_91);
            assert (l_253 == 0);
            l_206 = l_204;
        }
        /* facts after branching */
        assert (l_148 == &l_76 || l_148 == 0);
        assert (l_253 == 0 || l_253 == &l_254);
        if (l_341.f2.f0)
            goto lbl_175;
    }
    (*l_355) = (__builtin_ffs(p_68) < ((uint64_t)(((int64_t)(-1L) + (int64_t)((func_92((**l_190), l_98.f0, (p_68 < (((uint64_t)((l_76 > p_69) < ((int16_t)(((int16_t)(__builtin_bswap64((((uint32_t)(((void*)0 == &l_191) != l_76) / (uint32_t)l_206) > p_69)) == 0x195C0E04L) << (int16_t)10) && p_67) << (int16_t)7)) - (uint64_t)p_67) < 0xDFE4C1CF038DEA13LL)), &l_206) || p_70.f0) <= l_354)) | 18446744073709551608UL) / (uint64_t)l_206));
    return l_356;
    /* statement id: 171 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_79(uint16_t  p_80)
{ /* block id: 42 */
    float l_81 = (-0x3.5p-1);
    const int64_t l_82 = 1L;
    int32_t l_84 = 0L;
    int32_t *l_83 = &l_84;
    struct S0 l_87 = {0x010F1939EFD9132ELL};
    struct S0 l_89 = {0x8934ECA6696B4954LL};
    (*l_83) = ((l_82 < p_80) == 1UL);
    for (p_80 = 0; (p_80 > 32); p_80 += 1)
    { /* block id: 46 */
        struct S0 *l_88 = &l_87;
        (*l_88) = l_87;
        if (p_80)
            continue;
    }
    return l_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_92(struct S0 * p_93, int64_t  p_94, int32_t  p_95, int32_t * p_96)
{ /* block id: 52 */
    int32_t ***l_141 = (void*)0;
    int32_t l_145 = 0L;
    int32_t *l_144 = &l_145;
    int32_t **l_143 = &l_144;
    int32_t ***l_142 = &l_143;
    (*l_142) = func_99(p_93);
    /* statement id: 74 */
    assert (l_143 == 0);
    l_144 = &l_145;
    return p_95;
}


/* ------------------------------------------ */
/* 
 * reads : l_98 p_70 l_91 l_383 l_400
 * writes: l_98 p_70 l_91 l_383 l_400
 */
inline static int32_t * const * const  func_99(struct S0 * p_100)
{ /* block id: 53 */
    int32_t l_101 = 1L;
    int32_t l_107 = 3L;
    int32_t * const * const l_140 = (void*)0;
    for (l_101 = 0; (l_101 >= (-15)); l_101 -= 6)
    { /* block id: 56 */
        int32_t *l_104 = &l_101;
        const int32_t **l_105 = (void*)0;
        int32_t **l_106 = &l_104;
        uint32_t l_134 = 1UL;
        float *l_137 = (void*)0;
        float l_139 = 0x7.4C4DC4p+90;
        float *l_138 = &l_139;
        (*l_106) = l_104;
        if ((**l_106))
        { /* block id: 58 */
            uint8_t l_108 = 255UL;
            l_107 = __builtin_popcountll((*l_104));
            l_108 = (*l_104);
        }
        else
        { /* block id: 61 */
            int32_t l_109 = 0xB0392260L;
            int32_t *l_117 = &l_101;
            struct S0 ***l_131 = (void*)0;
            struct S0 * const *l_133 = (void*)0;
            struct S0 * const **l_132 = &l_133;
            (*p_100) = func_79(l_109);
            (*l_132) = func_110(((int64_t)l_101 + (int64_t)((**l_106) | l_109)), (*p_100), (l_117 == &l_107), p_100);
            (*l_106) = (*l_106);
            (*p_100) = func_79(l_101);
        }
        l_107 = ((l_107 && l_134) == ((int64_t)(0xEAC2L <= __builtin_clzl(l_107)) % (int64_t)(**l_106)));
        (*l_138) = l_101;
    }
    return l_140;
    /* statement id: 73 */
    //assert (func_99_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 ** func_110(int64_t  p_111, struct S0  p_112, int16_t  p_113, const struct S0 * p_114)
{ /* block id: 63 */
    const float l_120 = 0x2.5FFFC4p+84;
    int32_t l_121 = (-2L);
    int32_t *l_122 = (void*)0;
    int32_t *l_123 = &l_121;
    struct S0 l_126 = {0x797CFCBFA339BCA7LL};
    struct S0 *l_125 = &l_126;
    struct S0 **l_124 = &l_125;
    struct S0 **l_127 = &l_125;
    struct S0 **l_128 = &l_125;
    struct S0 **l_129 = &l_125;
    struct S0 **l_130 = (void*)0;
    (*l_123) = ((uint64_t)(l_121 != 1UL) + (uint64_t)p_112.f0);
    return l_130;
    /* statement id: 65 */
    //assert (func_110_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 105
   depth: 1, occurrence: 3
XXX total union variables: 5

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 21
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 8, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 129

XXX times a variable address is taken: 136
XXX times a pointer is dereferenced on RHS: 34
breakdown:
   depth: 1, occurrence: 24
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 143

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 329
   level: 2, occurrence: 78
XXX number of pointers point to pointers: 59
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.25

XXX times a non-volatile is read: 397
XXX times a non-volatile is write: 131
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 18
   depth: 2, occurrence: 13
   depth: 3, occurrence: 9
   depth: 4, occurrence: 18
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 24.7
XXX percentage an existing variable is used: 75.3
********************* end of statistics **********************/

