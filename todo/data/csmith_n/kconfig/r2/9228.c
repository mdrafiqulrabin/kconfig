/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3112931504
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 6;
};

struct S1 {
   const uint32_t  f0;
   unsigned f1 : 10;
   float  f2;
   unsigned f3 : 1;
   signed f4 : 30;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_30(void);
static int16_t  func_46(uint32_t  p_47, int32_t  p_48, uint64_t  p_49);
inline static uint64_t  func_51(uint16_t  p_52, struct S1  p_53, const int32_t * p_54, const uint32_t  p_55);
inline static struct S1  func_56(int32_t * p_57, uint32_t  p_58, int32_t  p_59, int32_t * p_60, int32_t * p_61);
inline static int32_t * func_62(int32_t * p_63, int32_t * p_64, int32_t  p_65);
static int32_t * func_66(struct S0  p_67, int32_t * p_68);
inline static const float  func_77(float  p_78, struct S1  p_79, int32_t * p_80, int16_t  p_81);
inline static uint16_t  func_88(const float * p_89, float * p_90);
inline static const float * func_91(int32_t * p_92, const int32_t  p_93, const uint32_t  p_94, int32_t  p_95);
inline static int32_t * func_96(int32_t  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_30(void)
{ /* block id: 36 */
    uint32_t l_31 = 0x6B17B722L;
    int32_t l_33 = 4L;
    int32_t *l_32 = &l_33;
    struct S0 ** const l_758 = (void*)0;
    struct S0 ** const *l_757 = &l_758;
    struct S0 ** const **l_756 = &l_757;
    struct S0 ** const ***l_755 = &l_756;
    struct S1 *l_783 = (void*)0;
    int32_t **l_786 = &l_32;
    uint32_t l_787 = 0x3F7A3E2AL;
    (*l_32) = l_31;
    if ((*l_32))
    { /* block id: 38 */
        int32_t *l_70 = &l_33;
        struct S0 l_759 = {3};
        struct S1 l_763 = {18446744073709551609UL,22,0x7.035FF3p+16,0,-31988};
        int32_t l_780 = 0x460425BBL;
        for (l_33 = (-9); (l_33 >= 26); l_33 += 7)
        { /* block id: 41 */
            uint64_t l_618 = 0x211D8B410406FBD9LL;
            int32_t *l_619 = &l_33;
            int32_t l_777 = 0x61080B7EL;
            for (l_31 = 23; (l_31 <= 58); l_31++)
            { /* block id: 44 */
                int16_t l_50 = 0x66C4L;
                struct S0 l_69 = {-0};
                const int32_t l_641 = 0L;
                struct S0 *l_754 = &l_69;
                struct S0 **l_753 = &l_754;
                struct S0 ***l_752 = &l_753;
                struct S0 ****l_751 = &l_752;
                struct S0 *****l_750 = &l_751;
                int32_t *l_765 = &l_33;
                int16_t l_775 = (-1L);
            }
        }
        for (l_33 = 0; (l_33 < 5); l_33 += 2)
        { /* block id: 461 */
            l_780 = (*l_70);
        }
    }
    else
    { /* block id: 464 */
        float l_782 = (-0x1.0p+1);
        float *l_781 = &l_782;
        struct S1 l_785 = {4UL,7,-0x3.7p+1,0,22627};
        struct S1 *l_784 = &l_785;
        (*l_781) = 0x9.6CBD74p+9;
        l_784 = l_783;
        /* statement id: 466 */
        assert (l_784 == 0);
        return l_785.f1;
    }
    (*l_786) = &l_33;
    return l_787;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_46(uint32_t  p_47, int32_t  p_48, uint64_t  p_49)
{ /* block id: 438 */
    uint32_t l_743 = 0xA506325FL;
    struct S1 l_744 = {0x4DED77D4L,2,0x8.Ep+1,0,20667};
    int32_t l_746 = 0x8B3E97F0L;
    const int32_t *l_745 = &l_746;
    int32_t *l_747 = &l_746;
    (*l_747) = ((int64_t)(((((uint16_t)p_47 / (uint16_t)(9L | ((p_47 == p_48) != (0x770A7E6960AF9E2CLL || p_49)))) | (((int32_t)((int64_t)(((-1L) & (0x8BE3853BL || (func_51(l_743, l_744, l_745, (*l_745)) >= p_49))) >= (*l_745)) - (int64_t)(*l_745)) / (int32_t)7UL) != 0L)) != (*l_745)) != (-10L)) + (int64_t)(*l_745));
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_51(uint16_t  p_52, struct S1  p_53, const int32_t * p_54, const uint32_t  p_55)
{ /* block id: 364 */
    struct S0 l_653 = {2};
    struct S0 *l_652 = &l_653;
    int32_t l_660 = 0xA2988A3EL;
    int32_t l_664 = 0xC547EFB9L;
    int32_t * const l_663 = &l_664;
    uint32_t l_684 = 4UL;
    int64_t l_726 = 0x2BCF8AA51B17D30FLL;
    if ((~(((int16_t)p_55 + (int16_t)p_52) < p_55)))
    { /* block id: 365 */
        int64_t l_650 = 1L;
        for (p_52 = 0; (p_52 == 6); p_52 += 1)
        { /* block id: 368 */
            int32_t l_647 = (-1L);
            for (l_647 = (-5); (l_647 == 19); l_647++)
            { /* block id: 371 */
                int32_t l_651 = 1L;
                struct S0 **l_654 = &l_652;
                l_651 = l_650;
                (*l_654) = l_652;
                return p_53.f3;
            }
        }
    }
    else
    { /* block id: 377 */
        int32_t l_662 = 5L;
        int32_t *l_661 = &l_662;
        int32_t **l_725 = &l_661;
        int32_t ***l_724 = &l_725;
        int32_t ****l_723 = &l_724;
        int32_t **l_732 = &l_661;
        if (((int16_t)((*p_54) <= ((*p_54) && l_653.f0)) >> (int16_t)l_653.f0))
        { /* block id: 378 */
            uint16_t l_657 = 6UL;
            const float *l_667 = (void*)0;
            int32_t **l_668 = &l_661;
            if (((__builtin_bswap64(l_657) >= ((int64_t)((p_52 ^ (l_657 | l_660)) != func_88(p_54, l_661)) % (int64_t)l_660)) > 0UL))
            { /* block id: 379 */
                int32_t **l_665 = &l_661;
                (*l_665) = l_663;
                /* statement id: 380 */
                assert (l_661 == &l_664);
            }
            else
            { /* block id: 381 */
                struct S0 *l_666 = &l_653;
                l_652 = l_666;
                return p_55;
            }
            /* facts after branching */
            assert (l_661 == &l_664);
            (*l_668) = func_96(func_88(l_667, func_66((*l_652), &l_664)));
            /* statement id: 385 */
            assert (l_661 == 0);
        }
        else
        { /* block id: 386 */
            return p_53.f0;
        }
        /* facts after branching */
        assert (l_661 == 0);
        for (p_52 = 0; (p_52 > 21); p_52 += 5)
        { /* block id: 391 */
            uint32_t l_675 = 1UL;
            uint32_t l_713 = 1UL;
            int32_t **l_729 = &l_661;
            for (l_662 = 26; (l_662 == (-8)); l_662 -= 4)
            { /* block id: 394 */
                const uint64_t l_676 = 1UL;
                struct S0 *** const *l_700 = (void*)0;
                if (((int64_t)l_675 + (int64_t)l_676))
                { /* block id: 395 */
                    int16_t l_677 = 1L;
                    float l_679 = 0x0.9p-1;
                    float *l_678 = &l_679;
                    int32_t *l_681 = &l_662;
                    struct S1 *l_689 = (void*)0;
                    struct S1 **l_688 = &l_689;
                    int32_t **l_692 = &l_681;
                    (*l_678) = ((l_677 == (&p_54 == &p_54)) > l_676);
                    if ((*p_54))
                    { /* block id: 397 */
                        uint16_t l_680 = 9UL;
                        int32_t **l_687 = &l_681;
                        l_680 = l_675;
                        (*l_687) = func_91(l_681, p_53.f4, (((((uint64_t)l_675 + (uint64_t)((*l_681) <= (*l_663))) || l_684) != l_676) == l_680), ((int64_t)((((void*)0 == p_54) | l_675) | p_53.f3) / (int64_t)(*l_681)));
                    }
                    else
                    { /* block id: 400 */
                        struct S1 ***l_690 = (void*)0;
                        struct S1 ***l_691 = &l_688;
                        (*l_691) = l_688;
                    }
                    (*l_692) = p_54;
                    /* statement id: 403 */
                    //assert (l_681 == &l_33 || l_681 == &l_746);
                }
                else
                { /* block id: 404 */
                    int16_t l_705 = 0xA001L;
                    int32_t **l_722 = (void*)0;
                    int32_t ***l_721 = &l_722;
                    int32_t *** const *l_720 = &l_721;
                    for (l_660 = 0; (l_660 <= (-16)); l_660 -= 1)
                    { /* block id: 407 */
                        int32_t **l_697 = &l_661;
                        int32_t *** const l_696 = &l_697;
                        int32_t *** const *l_695 = &l_696;
                        int32_t ****l_699 = (void*)0;
                        int32_t *****l_698 = &l_699;
                        struct S0 ** const ***l_701 = (void*)0;
                        struct S0 ***l_704 = (void*)0;
                        struct S0 ****l_703 = &l_704;
                        struct S0 *****l_702 = &l_703;
                        (*l_698) = l_695;
                        /* statement id: 408 */
                        assert (l_699 == &l_696);
                        (*l_702) = l_700;
                        /* statement id: 409 */
                        assert (l_703 == 0);
                        l_705 = p_53.f3;
                    }
                    for (l_664 = (-22); (l_664 <= 6); l_664++)
                    { /* block id: 414 */
                        int64_t l_712 = 0xE76D961DEDF9DA8DLL;
                        (***l_723) = func_96((((((uint16_t)(((((uint16_t)l_712 / (uint16_t)p_53.f3) & p_53.f3) != l_713) != ((uint16_t)(((int16_t)((int16_t)p_53.f1 << (int16_t)(l_720 != l_723)) >> (int16_t)1) == ((*l_663) <= (((-8L) >= (*l_663)) <= l_726))) >> (uint16_t)12)) << (uint16_t)l_712) & l_676) < p_53.f4) >= 6UL));
                        /* statement id: 415 */
                        assert (l_661 == 0);
                        return p_55;
                    }
                    if ((*l_663))
                        continue;
                    return l_676;
                }
            }
            for (l_726 = 0; (l_726 > (-27)); l_726 -= 1)
            { /* block id: 424 */
                (*l_725) = (void*)0;
                /* statement id: 425 */
                assert (l_661 == 0);
            }
            (*l_729) = p_54;
            /* statement id: 427 */
            //assert (l_661 == &l_33 || l_661 == &l_746);
            if ((*p_54))
                continue;
        }
        /* facts after for loop */
        //assert (l_661 == &l_33 || l_661 == 0 || l_661 == &l_746);
        for (l_664 = (-20); (l_664 < (-1)); l_664 += 7)
        { /* block id: 432 */
            (**l_724) = func_96((*l_663));
            /* statement id: 433 */
            assert (l_661 == 0);
        }
        (*l_732) = p_54;
        /* statement id: 435 */
        //assert (l_661 == &l_33 || l_661 == &l_746);
    }
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_56(int32_t * p_57, uint32_t  p_58, int32_t  p_59, int32_t * p_60, int32_t * p_61)
{ /* block id: 348 */
    float ****l_628 = (void*)0;
    float **** const *l_627 = &l_628;
    int32_t l_630 = 0x35AECD1CL;
    int32_t *l_639 = &l_630;
    int32_t **l_638 = &l_639;
    struct S1 l_640 = {18446744073709551608UL,2,0xD.9A02F5p-74,0,-24848};
    if (((int16_t)(-1L) >> (int16_t)6))
    { /* block id: 349 */
        int32_t l_624 = 0xA257BD63L;
        int32_t *l_623 = &l_624;
        int32_t **l_622 = &l_623;
        (*l_622) = &p_59;
        /* statement id: 350 */
        assert (l_623 == &p_59);
    }
    else
    { /* block id: 351 */
        float **** const l_626 = (void*)0;
        float **** const *l_625 = &l_626;
        int32_t l_629 = 1L;
        struct S1 l_633 = {1UL,24,0xB.F79899p-69,0,13264};
        struct S1 *l_632 = &l_633;
        struct S1 **l_631 = &l_632;
        l_627 = l_625;
        /* statement id: 352 */
        assert (l_627 == &l_626);
        l_630 = ((((((__builtin_ctzll(l_629) <= p_58) > p_59) < l_630) < (l_629 < ((void*)0 != l_631))) == (&l_626 == (void*)0)) < 0x8.A50617p+75);
        for (l_630 = 0; (l_630 == (-12)); l_630--)
        { /* block id: 356 */
            int32_t *l_637 = &l_630;
            int32_t **l_636 = &l_637;
            (*l_636) = &p_59;
            /* statement id: 357 */
            assert (l_637 == &p_59);
        }
        l_630 = l_629;
    }
    /* facts after branching */
    //assert (l_627 == dangling || l_627 == &l_628);
    (*l_638) = &p_59;
    /* statement id: 361 */
    assert (l_639 == &p_59);
    (*l_639) = (**l_638);
    return l_640;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_62(int32_t * p_63, int32_t * p_64, int32_t  p_65)
{ /* block id: 289 */
    float l_528 = 0xE.846EECp+9;
    int32_t l_529 = 0x4515674DL;
    int32_t *l_530 = &l_529;
    struct S0 ****l_537 = (void*)0;
    int32_t *l_607 = &l_529;
    int32_t **l_615 = &l_607;
    int32_t *l_616 = &l_529;
    int32_t *l_617 = (void*)0;
    (*l_530) = ((uint16_t)l_529 << (uint16_t)10);
    (*l_530) = (-8L);
    for (p_65 = 29; (p_65 < (-20)); p_65 -= 1)
    { /* block id: 294 */
        uint32_t l_533 = 0x52304329L;
        const float *l_534 = &l_528;
        int32_t *l_544 = &l_529;
        const int32_t *l_547 = &l_529;
        int32_t *l_606 = &l_529;
        int32_t *l_608 = (void*)0;
        if ((*p_63))
        { /* block id: 295 */
            uint32_t l_538 = 0xA1FF2559L;
            float *l_562 = &l_528;
            float **l_561 = &l_562;
            float ***l_560 = &l_561;
            float ****l_559 = &l_560;
            uint64_t l_563 = 0xF3FEBD9CC5EBACD0LL;
            struct S0 *l_577 = (void*)0;
            int32_t l_583 = 9L;
            l_533 = __builtin_clzll(p_65);
            if ((*p_64))
                break;
            if ((p_65 == ((func_88(p_64, p_63) > (*p_63)) >= __builtin_ffsll(((uint16_t)((void*)0 == l_537) << (uint16_t)l_538)))))
            { /* block id: 298 */
                int16_t l_550 = 0x69EFL;
                float *l_558 = &l_528;
                float **l_557 = &l_558;
                float ** const *l_556 = &l_557;
                float ** const **l_555 = &l_556;
                for (l_538 = 0; (l_538 < 28); l_538++)
                { /* block id: 301 */
                    int32_t l_543 = 0L;
                    int32_t **l_545 = (void*)0;
                    int32_t **l_546 = (void*)0;
                    int32_t *l_570 = (void*)0;
                    for (l_533 = 0; (l_533 > 12); l_533++)
                    { /* block id: 304 */
                        (*l_530) = ((*l_530) || l_543);
                        if ((*p_63))
                            continue;
                    }
                    l_547 = func_91(l_544, l_543, (*l_544), (*l_544));
                    for (l_529 = 12; (l_529 >= 25); l_529 += 8)
                    { /* block id: 311 */
                        int32_t l_564 = 0x2FD68C84L;
                        int32_t l_566 = 0x305BE12FL;
                        int32_t *l_565 = &l_566;
                        (*l_565) = (((l_550 && (0UL == ((int16_t)((int16_t)(l_555 == l_559) << (int16_t)(*l_530)) >> (int16_t)6))) != ((l_563 && l_564) >= l_550)) <= p_65);
                    }
                    for (l_529 = (-17); (l_529 > 15); l_529++)
                    { /* block id: 316 */
                        int32_t *l_569 = &l_529;
                        return l_570;
                        /* statement id: 317 */
                        //assert (func_62_rv == 0);
                    }
                }
            }
            else
            { /* block id: 320 */
                uint64_t l_582 = 1UL;
                int32_t l_584 = (-9L);
                int32_t **l_585 = &l_530;
                l_583 = ((float)l_563 / (float)((float)(p_65 < __builtin_bswap32(((int64_t)p_65 + (int64_t)((void*)0 != l_577)))) / (float)((float)l_538 / (float)((float)(p_65 == (p_65 > l_582)) / (float)(*l_547)))));
                l_584 = (l_582 <= l_582);
                (*l_585) = &l_583;
                /* statement id: 323 */
                assert (l_530 == &l_583);
                (**l_585) = ((*l_547) & (**l_585));
            }
            /* facts after branching */
            assert (l_530 == &l_583 || l_530 == &l_529);
        }
        else
        { /* block id: 326 */
            float *l_586 = &l_528;
            struct S0 l_590 = {2};
            struct S0 *l_589 = &l_590;
            (*l_586) = p_65;
            for (l_529 = 0; (l_529 <= (-23)); l_529--)
            { /* block id: 330 */
                const struct S0 *l_592 = &l_590;
                const struct S0 **l_591 = &l_592;
                struct S0 * const l_603 = &l_590;
                int32_t l_605 = 3L;
                int32_t *l_604 = &l_605;
                (*l_591) = l_589;
                for (l_533 = 0; (l_533 == 16); ++l_533)
                { /* block id: 334 */
                    int32_t l_595 = 5L;
                    for (l_595 = 0; (l_595 != (-24)); l_595 -= 2)
                    { /* block id: 337 */
                        uint8_t l_598 = 0UL;
                        int32_t **l_599 = (void*)0;
                        int32_t **l_600 = &l_530;
                        (*l_600) = func_96(l_598);
                        /* statement id: 338 */
                        assert (l_530 == 0);
                    }
                }
                (*l_604) = ((uint32_t)(l_603 != &l_590) - (uint32_t)func_88(p_63, p_63));
            }
            /* facts after for loop */
            assert (l_530 == 0 || l_530 == &l_529);
        }
        /* facts after branching */
        //assert (l_530 == 0 || l_530 == &l_529 || l_530 == dangling);
        return l_608;
        /* statement id: 344 */
        //assert (func_62_rv == 0);
    }
    (*l_615) = func_96(((uint16_t)((0xD16FD438B19DBEBBLL < (*l_530)) != ((uint16_t)0x6E6EL / (uint16_t)((uint32_t)p_65 / (uint32_t)7L))) << (uint16_t)((*l_607) || 1UL)));
    /* statement id: 346 */
    assert (l_607 == 0);
    return l_617;
    /* statement id: 347 */
    //assert (func_62_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_66(struct S0  p_67, int32_t * p_68)
{ /* block id: 45 */
    uint64_t l_71 = 18446744073709551608UL;
    int32_t **l_510 = (void*)0;
    int32_t ***l_509 = &l_510;
    int32_t ****l_508 = &l_509;
    int32_t *****l_507 = &l_508;
    if ((l_71 ^ 7UL))
    { /* block id: 46 */
        float *l_72 = (void*)0;
        float l_74 = 0x1.0F6DAEp+25;
        float *l_73 = &l_74;
        int32_t l_200 = (-4L);
        struct S1 l_358 = {0x140DDB9DL,4,-0x6.3p-1,0,23551};
        (*l_73) = (p_67.f0 >= p_67.f0);
        (*l_73) = ((0xC.28C040p+96 == ((float)0x1.3p-1 / (float)func_77((__builtin_popcount(((int64_t)((uint16_t)(((uint64_t)((func_88(func_91(func_96(p_67.f0), l_71, (l_71 == ((((&p_68 == &p_68) > l_71) == l_200) && l_71)), (*p_68)), p_68) & 0x90D4L) <= (*p_68)) / (uint64_t)0x149C64D65D48113CLL) >= 1L) - (uint16_t)0x616BL) % (int64_t)p_67.f0)) >= (-0x1.7p-1)), l_358, p_68, l_358.f0))) == (-0x10.2p-1));
    }
    else
    { /* block id: 271 */
        int32_t l_505 = 0x8B602A20L;
        int32_t *l_504 = &l_505;
        int32_t **l_506 = &l_504;
        int32_t *****l_511 = &l_508;
        (*l_506) = l_504;
        l_511 = l_507;
        for (l_71 = (-3); (l_71 <= 16); l_71 += 8)
        { /* block id: 276 */
            int32_t l_525 = 0x37039E12L;
            (**l_506) = ((uint64_t)(*l_504) / (uint64_t)p_67.f0);
            for (l_505 = 0; (l_505 == (-10)); l_505 -= 8)
            { /* block id: 280 */
                const int32_t *l_519 = &l_505;
                const int32_t **l_520 = &l_519;
                int32_t *l_521 = (void*)0;
                int32_t *l_522 = (void*)0;
                int32_t l_524 = 0x1043741EL;
                int32_t *l_523 = &l_524;
                (*l_520) = l_519;
                (*l_523) = (*p_68);
                if (l_525)
                    continue;
                if ((*p_68))
                    continue;
            }
        }
    }
    return p_68;
    /* statement id: 288 */
    //assert (func_66_rv == &l_33 || func_66_rv == &l_664);
}


/* ------------------------------------------ */
/* 
 * reads : l_33 l_664
 * writes:
 */
inline static const float  func_77(float  p_78, struct S1  p_79, int32_t * p_80, int16_t  p_81)
{ /* block id: 181 */
    const float l_362 = 0xB.8F8155p+6;
    const float *l_361 = &l_362;
    float *l_363 = (void*)0;
    int32_t l_364 = 3L;
    const float *l_365 = (void*)0;
    const float *l_366 = &l_362;
    struct S0 l_447 = {4};
    struct S0 *l_446 = &l_447;
    struct S0 **l_445 = &l_446;
    uint32_t l_469 = 4294967286UL;
    float ****l_473 = (void*)0;
    float **l_476 = &l_363;
    float ***l_475 = &l_476;
    float ****l_474 = &l_475;
    int32_t *****l_479 = (void*)0;
    struct S0 ***l_481 = (void*)0;
    struct S0 *** const *l_480 = &l_481;
    float l_483 = (-0x1.4p-1);
    float *l_482 = &l_483;
    float *l_496 = &l_483;
    const uint16_t l_497 = 3UL;
lbl_503:
    if ((((uint16_t)(l_364 ^ (l_364 > p_79.f0)) % (uint16_t)l_364) >= p_79.f0))
    { /* block id: 182 */
        uint64_t l_384 = 0xB3E65D3785568F75LL;
        int32_t l_391 = 0L;
        int32_t *l_390 = &l_391;
        const int32_t **l_406 = (void*)0;
        const int32_t ***l_405 = &l_406;
        struct S0 **l_424 = (void*)0;
        struct S0 ***l_423 = &l_424;
        struct S0 *** const *l_422 = &l_423;
        struct S0 *** const **l_421 = &l_422;
        for (p_81 = (-10); (p_81 == (-29)); p_81 -= 2)
        { /* block id: 185 */
            float l_372 = 0x1.Bp+1;
            float *l_371 = &l_372;
            (*l_371) = ((float)0x0.2p-1 - (float)0xD.A4A15Ap-68);
        }
        if (p_79.f0)
            goto lbl_420;
lbl_420:
        for (l_364 = 0; (l_364 > 27); l_364++)
        { /* block id: 190 */
            const float *l_385 = (void*)0;
            float l_387 = 0x0.Bp-1;
            float *l_386 = &l_387;
            int32_t l_402 = 0xD04E01BCL;
            int32_t **l_419 = &l_390;
            for (p_81 = 0; (p_81 > 8); p_81 += 4)
            { /* block id: 193 */
                float l_377 = (-0x4.0p-1);
                int32_t l_379 = 0x40A1C30BL;
                int32_t *l_378 = &l_379;
                int32_t ***l_408 = (void*)0;
                int32_t ****l_407 = &l_408;
                (*l_378) = (*p_80);
                for (l_379 = (-29); (l_379 <= (-14)); ++l_379)
                { /* block id: 197 */
                    uint8_t l_388 = 1UL;
                    uint8_t l_401 = 0xF0L;
                    int32_t **l_404 = &l_378;
                    if ((p_81 > ((__builtin_popcount(p_79.f1) == ((l_364 >= (l_384 == (p_81 > l_364))) != ((func_88(l_385, l_386) && (*p_80)) <= (*l_378)))) == 0x448FBCCC2C11AEEALL)))
                    { /* block id: 198 */
                        int32_t *l_389 = &l_364;
                        l_388 = ((0UL & 5UL) | p_81);
                        l_390 = l_389;
                        /* statement id: 200 */
                        assert (l_390 == &l_364);
                    }
                    else
                    { /* block id: 201 */
                        int32_t **l_392 = &l_390;
                        int32_t *l_403 = &l_391;
                        (*l_392) = p_80;
                        /* statement id: 202 */
                        //assert (l_390 == &l_33 || l_390 == &l_664);
                        if ((*p_80))
                            break;
                        (*l_403) = ((uint64_t)((((((**l_392) >= ((uint32_t)(((uint16_t)__builtin_bswap64(p_79.f0) >> (uint16_t)3) >= p_79.f1) + (uint32_t)(*p_80))) || (((((p_81 & ((uint16_t)l_401 << (uint16_t)10)) & l_402) | (0x0875L == p_79.f3)) & (**l_392)) != (*l_378))) >= 1UL) < l_402) & p_79.f3) - (uint64_t)l_402);
                    }
                    /* facts after branching */
                    //assert (l_390 == &l_33 || l_390 == &l_364 || l_390 == &l_664);
                    (*l_404) = p_80;
                    /* statement id: 206 */
                    //assert (l_378 == &l_33 || l_378 == &l_664);
                }
                /* facts after for loop */
                //assert (l_378 == &l_33 || l_378 == &l_379 || l_378 == &l_664);
                (*l_386) = p_81;
                (*l_407) = l_405;
                /* statement id: 209 */
                assert (l_408 == &l_406);
            }
            /* facts after for loop */
            //assert (l_390 == &l_33 || l_390 == &l_364 || l_390 == &l_391 || l_390 == &l_664);
            for (l_391 = 7; (l_391 == 27); ++l_391)
            { /* block id: 213 */
                int32_t *****l_411 = (void*)0;
                const int32_t *****l_412 = (void*)0;
                int32_t **l_416 = &l_390;
                int32_t ***l_415 = &l_416;
                int32_t ****l_414 = &l_415;
                int32_t *****l_413 = &l_414;
                int32_t *l_417 = (void*)0;
                int32_t *l_418 = &l_402;
                (*l_413) = &l_405;
                /* statement id: 214 */
                assert (l_414 == &l_405);
                if (l_402)
                    break;
                (*l_418) = (*p_80);
            }
            (*l_419) = p_80;
            /* statement id: 218 */
            //assert (l_390 == &l_33 || l_390 == &l_664);
        }
        /* facts after for loop */
        //assert (l_390 == &l_33 || l_390 == &l_391 || l_390 == &l_664);
        (*l_421) = (void*)0;
        /* statement id: 221 */
        assert (l_422 == 0);
    }
    else
    { /* block id: 222 */
        const uint32_t l_425 = 0xD61086BCL;
        int32_t l_441 = 1L;
        const float *l_444 = (void*)0;
        int32_t *l_454 = &l_441;
        struct S0 *l_455 = &l_447;
        if (l_425)
        { /* block id: 223 */
            struct S1 l_428 = {0x8A57AAD5L,21,0x0.42A22Dp+31,0,21466};
            struct S1 *l_427 = &l_428;
            struct S1 **l_426 = &l_427;
            float *l_429 = &l_428.f2;
            int32_t *l_431 = (void*)0;
            int32_t **l_430 = &l_431;
            int32_t *l_432 = &l_364;
            (*l_426) = &p_79;
            /* statement id: 224 */
            assert (l_427 == &p_79);
            (*l_429) = __builtin_ctzl(l_428.f1);
            (*l_430) = func_96(p_79.f4);
            (*l_432) = l_425;
        }
        else
        { /* block id: 228 */
            const uint64_t l_440 = 0xCD6ECBC03DAD876DLL;
            for (l_364 = 0; (l_364 == 28); l_364 += 8)
            { /* block id: 231 */
                l_441 = ((p_81 | ((l_364 > ((-(int64_t)p_79.f4) < (l_364 || ((uint16_t)0UL << (uint16_t)l_440)))) == l_425)) & p_79.f1);
            }
            l_441 = 0xE.9BB46Ep-11;
        }
        l_364 = ((uint32_t)(l_441 <= ((void*)0 == l_445)) - (uint32_t)((int32_t)((uint32_t)((int16_t)0L + (int16_t)p_79.f0) / (uint32_t)(*p_80)) + (int32_t)0xC4C84B3AL));
        (*l_454) = (*p_80);
        if ((l_447.f0 & (((((l_455 == (void*)0) > ((uint32_t)(2L >= (p_79.f4 >= (((l_364 < (0UL ^ ((((int64_t)(*l_454) / (int64_t)((int32_t)(-1L) % (int32_t)0xF072E333L)) < p_79.f4) ^ p_79.f1))) != p_79.f1) >= l_364))) + (uint32_t)1UL)) && 0L) & 0x5F72L) && p_79.f0)))
        { /* block id: 238 */
            return p_81;
        }
        else
        { /* block id: 240 */
            for (l_364 = 15; (l_364 >= (-2)); l_364 -= 8)
            { /* block id: 243 */
                int32_t **l_464 = &l_454;
                (*l_464) = (void*)0;
                /* statement id: 244 */
                assert (l_454 == 0);
            }
            /* facts after for loop */
            assert (l_454 == 0 || l_454 == &l_441);
            return p_79.f2;
        }
    }
    if ((p_81 > __builtin_parityll(((uint64_t)0x92C0D943B245BD93LL / (uint64_t)l_364))))
    { /* block id: 249 */
        float **l_467 = (void*)0;
        l_364 = ((0x1.A8A1A8p-52 > (l_467 == l_467)) <= p_79.f1);
    }
    else
    { /* block id: 251 */
        int32_t *l_468 = &l_364;
        float *l_470 = (void*)0;
        float l_472 = 0xF.4E7A1Ap+69;
        float *l_471 = &l_472;
        (*l_468) = 0x2F7F7D65L;
        (*l_471) = l_469;
        l_474 = l_473;
        /* statement id: 254 */
        assert (l_474 == 0);
    }
    (*l_482) = (((float)p_79.f2 / (float)0x0.4p-1) <= (((p_79.f2 == l_447.f0) >= (l_479 != (void*)0)) != (l_480 != &l_481)));
    if (((((uint32_t)(1L && ((int32_t)(-1L) % (int32_t)(~(-(int64_t)(p_79.f0 && p_81))))) % (uint32_t)p_79.f0) != ((uint16_t)((-8L) == ((int16_t)(p_79.f4 && ((int16_t)p_79.f0 - (int16_t)func_88((*l_476), l_496))) << (int16_t)5)) << (uint16_t)4)) ^ l_469))
    { /* block id: 257 */
        return l_497;
    }
    else
    { /* block id: 259 */
        int32_t *l_500 = (void*)0;
        for (p_81 = 0; (p_81 < 22); p_81++)
        { /* block id: 262 */
            int32_t **l_501 = &l_500;
            struct S0 ***l_502 = &l_445;
            (*l_501) = l_500;
            (*l_502) = &l_446;
        }
        if (l_469)
            goto lbl_503;
        p_79.f4 = (*p_80);
        return p_79.f2;
    }
}


/* ------------------------------------------ */
/* 
 * reads : l_33 l_664
 * writes:
 */
inline static uint16_t  func_88(const float * p_89, float * p_90)
{ /* block id: 91 */
    int32_t l_213 = 5L;
    int32_t l_218 = 0x4E944683L;
    float l_227 = (-0x5.Ep-1);
    const float *l_226 = &l_227;
    const float **l_225 = &l_226;
    struct S0 *l_270 = (void*)0;
    struct S0 **l_269 = &l_270;
    uint64_t l_326 = 4UL;
    int32_t **l_338 = (void*)0;
    int32_t *l_340 = (void*)0;
    int32_t **l_339 = &l_340;
    uint16_t l_357 = 0x2CCAL;
    for (l_213 = 6; (l_213 <= 9); l_213 += 4)
    { /* block id: 94 */
        int32_t *l_217 = &l_213;
        int32_t **l_216 = &l_217;
        struct S0 l_275 = {3};
        struct S0 *l_274 = &l_275;
        struct S1 l_278 = {0xD552EA11L,11,0x8.6p+1,0,-9359};
        struct S1 *l_277 = &l_278;
        uint16_t l_282 = 0xC960L;
        (*l_216) = &l_213;
        if (((**l_216) == (l_213 <= ((__builtin_parityl(l_218) | ((int16_t)((+(((&l_217 == (void*)0) & __builtin_ctz((*l_217))) > (((**l_216) > (**l_216)) && l_218))) == l_213) + (int16_t)0L)) != l_218))))
        { /* block id: 96 */
            uint64_t l_224 = 0UL;
            int32_t l_241 = 0x7FC21528L;
            int32_t *l_242 = &l_241;
            if ((((int16_t)6L >> (int16_t)l_224) | (0x57F1L && l_224)))
            { /* block id: 97 */
                int32_t l_228 = 0x4E044EFEL;
                int32_t *l_229 = &l_218;
                l_225 = &p_89;
                /* statement id: 98 */
                assert (l_225 == &p_89);
                (*l_229) = l_228;
                (*l_229) = (__builtin_bswap32(((**l_216) & 0x00962F29F115A300LL)) && ((*l_217) ^ (((int16_t)(*l_229) << (int16_t)((int16_t)((int32_t)(l_224 | ((int16_t)(-3L) << (int16_t)2)) - (int32_t)(((*l_229) < l_218) != 0x42B78B995595372CLL)) / (int16_t)(*l_217))) <= (**l_216))));
            }
            else
            { /* block id: 101 */
                struct S1 l_240 = {18446744073709551607UL,21,-0x1.Ep+1,0,8064};
                struct S1 *l_239 = &l_240;
                struct S1 **l_238 = &l_239;
                (*l_238) = (void*)0;
                /* statement id: 102 */
                assert (l_239 == 0);
                l_241 = 0x741E8B38L;
            }
            (*l_242) = 8L;
            if (l_218)
                break;
            if (((*l_217) < (*l_217)))
            { /* block id: 107 */
                int32_t l_249 = (-4L);
                struct S1 l_252 = {18446744073709551609UL,8,0x0.Ap-1,0,-29094};
                struct S1 *l_251 = &l_252;
                struct S1 **l_250 = &l_251;
                for (l_224 = 5; (l_224 != 40); ++l_224)
                { /* block id: 110 */
                    uint32_t l_245 = 1UL;
                    return l_245;
                }
                for (l_218 = 0; (l_218 > (-18)); --l_218)
                { /* block id: 115 */
                    int32_t l_253 = (-9L);
                    if ((+l_249))
                    { /* block id: 116 */
                        int32_t **l_254 = &l_242;
                        (*l_254) = func_91(p_90, ((void*)0 != l_250), l_218, l_253);
                        /* statement id: 117 */
                        //assert (l_242 == &l_33 || l_242 == &l_387 || l_242 == &l_483 || l_242 == &l_662 || l_242 == &l_664);
                        return l_218;
                    }
                    else
                    { /* block id: 119 */
                        (*l_216) = p_90;
                        /* statement id: 120 */
                        //assert (l_217 == &l_33 || l_217 == &l_387 || l_217 == &l_483 || l_217 == &l_662 || l_217 == &l_664);
                    }
                    /* facts after branching */
                    //assert (l_217 == &l_33 || l_217 == &l_387 || l_217 == &l_483 || l_217 == &l_662 || l_217 == &l_664);
                }
                /* facts after for loop */
                //assert (l_217 == &l_33 || l_217 == &l_213 || l_217 == &l_387 || l_217 == &l_483 || l_217 == &l_662 || l_217 == &l_664);
            }
            else
            { /* block id: 123 */
                struct S0 l_258 = {-4};
                struct S0 *l_257 = &l_258;
                for (l_224 = (-6); (l_224 >= 45); l_224 += 6)
                { /* block id: 126 */
                    const struct S0 *l_260 = (void*)0;
                    const struct S0 **l_259 = &l_260;
                    (*l_259) = l_257;
                    /* statement id: 127 */
                    assert (l_260 == &l_258);
                    (*l_242) = ((int16_t)(1UL ^ ((int16_t)0xD12EL << (int16_t)6)) >> (int16_t)11);
                }
            }
            /* facts after branching */
            //assert (l_217 == &l_33 || l_217 == &l_213 || l_217 == &l_387 || l_217 == &l_483 || l_217 == &l_662 || l_217 == &l_664);
        }
        else
        { /* block id: 131 */
            int32_t * const *l_266 = &l_217;
            int32_t * const **l_265 = &l_266;
            struct S0 ***l_271 = &l_269;
            (*l_265) = &l_217;
            if ((**l_216))
            { /* block id: 133 */
                float *l_267 = &l_227;
                (*l_267) = (**l_216);
                (*l_267) = (-0x5.Ep-1);
            }
            else
            { /* block id: 136 */
                uint32_t l_268 = 0UL;
                l_218 = (**l_216);
                return l_268;
            }
            (*l_271) = l_269;
            l_218 = l_218;
        }
        /* facts after branching */
        //assert (l_217 == &l_33 || l_217 == &l_213 || l_217 == &l_387 || l_217 == &l_483 || l_217 == &l_662 || l_217 == &l_664);
        for (l_218 = 0; (l_218 <= (-27)); --l_218)
        { /* block id: 145 */
            l_274 = (*l_269);
            /* statement id: 146 */
            assert (l_274 == 0);
            if ((*l_217))
                break;
        }
        /* facts after for loop */
        assert (l_274 == 0 || l_274 == &l_275);
        if (l_218)
        { /* block id: 149 */
            int32_t *l_276 = &l_218;
            (*l_216) = l_276;
            /* statement id: 150 */
            assert (l_217 == &l_218);
            if ((*l_217))
                break;
        }
        else
        { /* block id: 152 */
            struct S1 *l_279 = (void*)0;
            int32_t l_285 = 0xC7C29BA3L;
            int32_t *l_290 = (void*)0;
            int32_t *l_291 = &l_218;
            float *l_296 = &l_227;
            l_279 = l_277;
            /* statement id: 153 */
            assert (l_279 == &l_278);
            (*l_291) = (((l_218 == l_282) < ((*l_217) != __builtin_ctzll(((uint32_t)0x42314006L % (uint32_t)l_218)))) < ((l_285 | (0xC2B75BE74CFF9A10LL && ((int16_t)((((int64_t)l_285 + (int64_t)0x72883F161DF2DE5ELL) && l_218) < 0xD558L) << (int16_t)1))) >= l_285));
            (*l_296) = ((float)((float)(*p_90) + (float)((*p_90) > ((*l_291) > l_213))) - (float)(*l_217));
        }
        /* facts after branching */
        //assert (l_217 == &l_33 || l_217 == &l_213 || l_217 == &l_218 || l_217 == &l_387 || l_217 == &l_483 || l_217 == &l_662 || l_217 == &l_664);
    }
    /* facts after for loop */
    assert (l_225 == &l_226 || l_225 == &p_89);
    if (l_218)
    { /* block id: 158 */
        const int32_t *l_298 = &l_213;
        const int32_t **l_297 = &l_298;
        int32_t *l_301 = (void*)0;
        int32_t **l_300 = &l_301;
        int32_t ***l_299 = &l_300;
        (*l_299) = l_297;
        /* statement id: 159 */
        assert (l_300 == &l_298);
        (*l_297) = p_89;
        /* statement id: 160 */
        //assert (l_298 == 0 || l_298 == &l_33 || l_298 == &l_746 || l_298 == &l_762);
    }
    else
    { /* block id: 161 */
        float *l_302 = &l_227;
        int32_t l_305 = 0x6EDA828DL;
        int32_t ***l_323 = (void*)0;
        (*l_302) = 0xD.9765F1p+14;
        (*l_302) = ((&l_225 != &l_225) == ((((*p_90) == (((float)(((0x6.856239p-40 > l_305) < ((float)(-0x10.Bp+1) - (float)(p_89 == (void*)0))) != ((void*)0 != p_89)) / (float)0xD.4B0218p-1) > l_218)) < l_218) <= (-0x1.Bp-1)));
        if ((l_305 < l_218))
        { /* block id: 164 */
            int32_t *l_309 = &l_218;
            int32_t **l_308 = &l_309;
            (*l_308) = p_90;
            /* statement id: 165 */
            //assert (l_309 == &l_33 || l_309 == &l_387 || l_309 == &l_483 || l_309 == &l_662 || l_309 == &l_664);
            for (l_218 = 0; (l_218 != 18); l_218 += 9)
            { /* block id: 168 */
                struct S0 **l_314 = (void*)0;
                int32_t l_327 = 0x94D5BFBDL;
                (*l_308) = p_90;
                (*l_302) = ((((((float)(l_314 == (void*)0) + (float)((float)(*p_90) / (float)(*l_309))) >= ((float)((float)l_213 - (float)l_305) - (float)(((float)(l_323 == l_323) / (float)((float)l_326 + (float)(*p_90))) == l_327))) > l_327) > (*p_90)) != 0x0.0p+1);
                (*l_308) = p_90;
            }
            (*l_302) = ((*p_90) > (l_218 == ((!((float)(*p_90) / (float)(*p_90))) > ((*p_90) != ((float)(*p_90) - (float)((float)((l_213 > ((*l_309) < (-0x7.Fp-1))) == (*p_90)) + (float)l_326))))));
        }
        else
        { /* block id: 174 */
            int32_t **l_335 = (void*)0;
            int32_t *l_337 = &l_218;
            int32_t **l_336 = &l_337;
            (*l_336) = p_89;
            /* statement id: 175 */
            //assert (l_337 == 0 || l_337 == &l_33 || l_337 == &l_746 || l_337 == &l_762);
        }
    }
    (*l_339) = func_96(l_218);
    l_213 = ((uint16_t)((uint64_t)((uint32_t)((void*)0 == &l_269) / (uint32_t)l_213) - (uint64_t)__builtin_ffs(((l_326 == ((uint16_t)((int16_t)0xA59FL << (int16_t)15) >> (uint16_t)11)) == (((int16_t)(((uint16_t)(((*l_269) != (*l_269)) | ((uint64_t)(l_218 > (l_218 & l_213)) / (uint64_t)l_326)) << (uint16_t)5) < l_218) >> (int16_t)5) | l_326)))) + (uint16_t)l_357);
    return l_326;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float * func_91(int32_t * p_92, const int32_t  p_93, const uint32_t  p_94, int32_t  p_95)
{ /* block id: 88 */
    int64_t l_203 = 0xC989E8BE2EB9B0FDLL;
    int32_t l_212 = 2L;
    int32_t *l_211 = &l_212;
    int32_t **l_210 = &l_211;
    (*l_210) = func_96(((0xDDF55BC5L | 0x6F50C62AL) > (((int64_t)l_203 + (int64_t)((-(int64_t)__builtin_ffsl(((int64_t)0xE9FF3C386943B6ACLL + (int64_t)0x5639F120E9FE6B08LL))) > (((int32_t)(-(uint64_t)__builtin_ffsll(p_93)) % (int32_t)l_203) <= l_203))) == l_203)));
    /* statement id: 89 */
    assert (l_211 == 0);
    return p_92;
    /* statement id: 90 */
    //assert (func_91_rv == 0 || func_91_rv == &l_33 || func_91_rv == &l_387 || func_91_rv == &l_483 || func_91_rv == &l_529 || func_91_rv == &l_662 || func_91_rv == &l_664);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_96(int32_t  p_97)
{ /* block id: 48 */
    int32_t l_98 = 0L;
    float l_102 = 0x1.7p+1;
    float *l_101 = &l_102;
    int32_t *l_129 = &l_98;
    int32_t **l_128 = &l_129;
    int32_t *l_190 = &l_98;
    int32_t *l_191 = &l_98;
    int32_t *l_192 = &l_98;
    int32_t *l_193 = &l_98;
    int32_t *l_194 = &l_98;
    int32_t *l_195 = &l_98;
    int32_t *l_196 = &l_98;
    int32_t *l_197 = &l_98;
    int32_t *l_198 = &l_98;
    int32_t *l_199 = (void*)0;
    if (((0x49BAL < ((l_98 ^ ((int16_t)((void*)0 != l_101) >> (int16_t)(~p_97))) ^ ((l_98 == ((int16_t)(l_98 & ((&l_98 != &l_98) ^ l_98)) >> (int16_t)p_97)) >= 0x947DL))) != l_98))
    { /* block id: 49 */
        uint16_t l_106 = 65535UL;
        int32_t *l_134 = &l_98;
        int32_t *l_137 = &l_98;
        int32_t *l_138 = &l_98;
        int32_t *l_157 = &l_98;
        if (l_106)
        { /* block id: 50 */
            int32_t *l_107 = &l_98;
            const int32_t *l_109 = (void*)0;
            const int32_t **l_108 = &l_109;
            int32_t *l_139 = &l_98;
            int32_t *l_140 = &l_98;
            int32_t *l_143 = (void*)0;
            int32_t *l_161 = &l_98;
            (*l_108) = l_107;
            /* statement id: 51 */
            assert (l_109 == &l_98);
            if ((p_97 >= (p_97 < ((uint32_t)(((int64_t)((uint16_t)(__builtin_ffsl((p_97 || l_98)) ^ p_97) >> (uint16_t)12) % (int64_t)0xB31B79E2962DE1B4LL) ^ __builtin_ffsll((+__builtin_popcountl((((((uint32_t)(!((uint16_t)0x5DCAL - (uint16_t)__builtin_ffsl(p_97))) + (uint32_t)p_97) || l_106) ^ 6UL) & p_97))))) - (uint32_t)4294967295UL))))
            { /* block id: 52 */
                int32_t *l_135 = &l_98;
                int32_t *l_136 = &l_98;
                int32_t *l_141 = &l_98;
                int32_t *l_142 = &l_98;
                (**l_128) = ((int64_t)((uint32_t)((l_98 <= __builtin_clzl(p_97)) & (((int32_t)((void*)0 != l_128) % (int32_t)p_97) >= (0x037596CDL || ((uint64_t)(**l_108) % (uint64_t)((uint32_t)(((**l_108) & 0x427CCDDECA68EB2ALL) <= l_106) - (uint32_t)p_97))))) - (uint32_t)0x85E685ACL) / (int64_t)p_97);
                return l_143;
                /* statement id: 54 */
                //assert (func_96_rv == 0);
            }
            else
            { /* block id: 55 */
                int32_t *l_144 = &l_98;
                int32_t *l_159 = &l_98;
                if (((*l_128) == (void*)0))
                { /* block id: 56 */
                    (*l_108) = l_144;
                }
                else
                { /* block id: 58 */
                    int16_t l_151 = 9L;
                    float *l_153 = &l_102;
                    if (p_97)
                    { /* block id: 59 */
                        uint32_t l_152 = 0x6BD8041EL;
                        int32_t **l_156 = &l_143;
                        (**l_128) = (**l_108);
                        (*l_107) = ((int32_t)__builtin_ctz(((uint16_t)p_97 - (uint16_t)0x8A6AL)) / (int32_t)(((void*)0 == l_144) && ((uint16_t)l_151 - (uint16_t)(l_152 < (l_153 != l_138)))));
                        (*l_153) = (p_97 <= ((float)(&l_137 != l_156) + (float)p_97));
                        return l_143;
                        /* statement id: 63 */
                        //assert (func_96_rv == 0);
                    }
                    else
                    { /* block id: 64 */
                        int32_t *l_158 = &l_98;
                        int32_t *l_160 = &l_98;
                        return l_143;
                        /* statement id: 65 */
                        //assert (func_96_rv == 0);
                    }
                }
            }
        }
        else
        { /* block id: 69 */
            int32_t *l_170 = &l_98;
            float ***l_174 = (void*)0;
            float **l_176 = &l_101;
            float ***l_175 = &l_176;
            (*l_137) = ((uint64_t)((uint32_t)((uint16_t)0UL - (uint16_t)((int32_t)(l_170 == l_138) + (int32_t)0x24BB92A5L)) % (uint32_t)(((void*)0 == &l_138) & (0x2DDD9115L > (-(uint32_t)(**l_128))))) % (uint64_t)(((*l_128) == (void*)0) | (-1L)));
            (*l_134) = (((((uint16_t)((*l_170) < ((*l_138) && (((&l_137 != (void*)0) < (((l_170 == (void*)0) | (((*l_170) >= ((6L > ((*l_137) != (*l_129))) & (*l_157))) && (*l_170))) || (*l_170))) >= (*l_138)))) >> (uint16_t)4) < p_97) > 0x4E952D19C51062BFLL) ^ p_97);
            (*l_175) = &l_101;
            (**l_176) = (**l_128);
        }
        (*l_101) = (*l_129);
    }
    else
    { /* block id: 76 */
        int64_t l_181 = 0x1F50D1505295FBE9LL;
        int32_t * const l_182 = &l_98;
        uint32_t l_187 = 9UL;
        (*l_129) = (!((uint16_t)p_97 >> (uint16_t)9));
        if (((**l_128) < p_97))
        { /* block id: 78 */
            float l_180 = 0x7.2148F4p-72;
            int32_t **l_183 = &l_129;
            (*l_128) = (*l_128);
            (*l_101) = __builtin_ctzll((p_97 <= (p_97 < l_181)));
            (*l_183) = l_182;
            (**l_183) = (+(((uint16_t)(**l_183) >> (uint16_t)((*l_182) != l_187)) && 0x040FL));
        }
        else
        { /* block id: 83 */
            float **l_189 = &l_101;
            float ***l_188 = &l_189;
            (*l_188) = (void*)0;
            /* statement id: 84 */
            assert (l_189 == 0);
        }
    }
    return l_199;
    /* statement id: 87 */
    //assert (func_96_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 189
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 29
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 12
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 0
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 18
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 19
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 36

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 271
   depth: 2, occurrence: 57
   depth: 3, occurrence: 2
   depth: 4, occurrence: 9
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 4
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 7
   depth: 18, occurrence: 5
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 277

XXX times a variable address is taken: 240
XXX times a pointer is dereferenced on RHS: 133
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 19
XXX times a pointer is dereferenced on LHS: 108
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 717

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 2566
   level: 2, occurrence: 493
   level: 3, occurrence: 12
   level: 4, occurrence: 2
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 131
XXX number of pointers point to scalars: 124
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 26.7
XXX average alias set size: 1.27

XXX times a non-volatile is read: 822
XXX times a non-volatile is write: 294
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 241
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 52
   depth: 2, occurrence: 64
   depth: 3, occurrence: 47
   depth: 4, occurrence: 20
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

