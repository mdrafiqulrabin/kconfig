/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3325091616
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_33(void);
inline static int32_t * func_34(int32_t  p_35, float  p_36, int32_t * p_37, int32_t  p_38);
static float  func_42(int32_t * p_43, int32_t * p_44, uint32_t  p_45, int32_t * p_46);
inline static int32_t * func_47(int32_t  p_48);
inline static int32_t ** func_52(uint32_t  p_53, int32_t  p_54, int16_t  p_55);
static uint16_t  func_57(int32_t ** p_58, int32_t  p_59, uint32_t  p_60, int32_t * p_61);
static uint16_t  func_67(float  p_68);
static uint32_t  func_78(uint32_t  p_79, int32_t ** p_80, int32_t ** p_81, uint32_t  p_82, int32_t ** p_83);
inline static uint16_t  func_84(int16_t  p_85, int32_t ** p_86, int32_t * p_87);
static int32_t * func_88(int32_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_33(void)
{ /* block id: 36 */
    int32_t *l_39 = (void*)0;
    int32_t l_49 = 0xAE07EA4CL;
    int32_t *l_540 = &l_49;
    int32_t *l_541 = &l_49;
    int32_t l_547 = (-1L);
    int32_t **l_570 = &l_540;
    int16_t l_571 = 2L;
    (*l_570) = func_34((l_39 == l_39), (((float)func_42(func_47(l_49), l_540, (*l_540), l_541) + (float)(((__builtin_parity(l_547) >= 0x0.Dp-1) != (-0x1.5p-1)) <= 0x0.Bp+1)) != l_547), &l_547, l_547);
    return l_571;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_34(int32_t  p_35, float  p_36, int32_t * p_37, int32_t  p_38)
{ /* block id: 343 */
    uint32_t l_560 = 18446744073709551615UL;
    int32_t *l_563 = (void*)0;
    int32_t **l_562 = &l_563;
    int32_t ***l_561 = &l_562;
    float l_566 = 0x0.7p-1;
    float *l_565 = &l_566;
    float **l_564 = &l_565;
    int32_t l_568 = (-3L);
    int32_t *l_567 = &l_568;
    int32_t *l_569 = (void*)0;
    (**l_561) = func_47(((uint32_t)((int16_t)(((*p_37) != (*p_37)) && ((int16_t)__builtin_parity(((int32_t)(*p_37) % (int32_t)((int32_t)(*p_37) + (int32_t)((uint16_t)l_560 % (uint16_t)(__builtin_ffsll(l_560) & (l_561 == &l_562)))))) >> (int16_t)p_38)) + (int16_t)p_35) - (uint32_t)0x3F41C030L));
    l_564 = l_564;
    return l_569;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_42(int32_t * p_43, int32_t * p_44, uint32_t  p_45, int32_t * p_46)
{ /* block id: 340 */
    uint16_t l_544 = 0x2F49L;
    (*p_46) = ((uint16_t)((l_544 == l_544) > p_45) >> (uint16_t)((uint16_t)l_544 >> (uint16_t)11));
    return l_544;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_47(int32_t  p_48)
{ /* block id: 37 */
    int32_t l_64 = 0xFFA898CBL;
    int32_t *l_63 = &l_64;
    int32_t **l_62 = &l_63;
    float **l_537 = (void*)0;
    int32_t *l_539 = (void*)0;
    for (p_48 = (-24); (p_48 != 9); p_48 += 1)
    { /* block id: 40 */
        uint32_t l_56 = 0x31EA0627L;
        int32_t **l_73 = &l_63;
        int32_t ***l_536 = &l_62;
        int32_t *l_538 = &l_64;
    }
    (*l_63) = (*l_63);
    return l_539;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_52(uint32_t  p_53, int32_t  p_54, int16_t  p_55)
{ /* block id: 299 */
    int32_t l_499 = (-1L);
    float l_504 = 0x1.Bp+1;
    float *l_503 = &l_504;
    float **l_502 = &l_503;
    float ***l_501 = &l_502;
    float ****l_500 = &l_501;
    int32_t *l_521 = &l_499;
    int32_t **l_520 = &l_521;
    int32_t **l_525 = &l_521;
    int32_t **l_526 = &l_521;
    int32_t **l_534 = &l_521;
    int32_t **l_535 = (void*)0;
    l_499 = (l_499 < ((&l_499 != (void*)0) < ((__builtin_popcountl((l_499 & l_499)) < l_499) >= l_499)));
    if (((void*)0 != l_500))
    { /* block id: 301 */
        int32_t *l_512 = &l_499;
        int32_t **l_511 = &l_512;
        for (p_54 = 0; (p_54 > 22); p_54 += 1)
        { /* block id: 304 */
            int32_t **l_519 = &l_512;
            for (p_53 = (-17); (p_53 > 30); p_53 += 9)
            { /* block id: 307 */
                float *l_509 = &l_504;
                int32_t l_510 = 0x6F243D8EL;
                int32_t **l_513 = (void*)0;
                (*l_519) = func_88(p_53);
                return l_513;
            }
            if (p_53)
                break;
        }
        (*l_511) = (*l_511);
    }
    else
    { /* block id: 314 */
        int32_t **l_522 = &l_521;
        if (((&l_521 == l_522) & 0x79D2L))
        { /* block id: 315 */
            int32_t ***l_523 = &l_522;
            (*l_521) = (&l_522 == l_523);
            (*l_522) = (**l_523);
        }
        else
        { /* block id: 318 */
            int32_t **l_524 = &l_521;
            int32_t **l_527 = &l_521;
            int32_t **l_528 = (void*)0;
            return l_528;
        }
    }
    (*l_526) = (*l_525);
    for (p_53 = 8; (p_53 != 12); p_53 += 4)
    { /* block id: 325 */
        int32_t *l_533 = &l_499;
        for (p_54 = 0; (p_54 <= 18); p_54 += 1)
        { /* block id: 328 */
            (*l_526) = l_533;
            (*l_525) = (void*)0;
            (*l_520) = l_533;
        }
    }
    return l_535;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_57(int32_t ** p_58, int32_t  p_59, uint32_t  p_60, int32_t * p_61)
{ /* block id: 223 */
    float l_381 = (-0x3.4p+1);
    float *l_380 = &l_381;
    float **l_379 = &l_380;
    int32_t l_385 = 1L;
    float ***l_410 = &l_379;
    float ****l_409 = &l_410;
    float *****l_408 = &l_409;
    int32_t *l_429 = &l_385;
    int32_t **l_428 = &l_429;
    int32_t **l_442 = &l_429;
    int32_t ***l_469 = &l_442;
    int32_t ****l_468 = &l_469;
    for (p_59 = 5; (p_59 > 27); p_59 += 1)
    { /* block id: 226 */
        uint16_t l_370 = 65535UL;
        float *****l_373 = (void*)0;
        int32_t *l_392 = &l_385;
        int32_t **l_391 = &l_392;
        int16_t l_411 = (-1L);
        uint32_t l_433 = 0x9C3A3E59L;
        int32_t ****l_470 = (void*)0;
        float **l_491 = &l_380;
        if ((p_59 < (-(int16_t)((int16_t)l_370 + (int16_t)((uint16_t)((void*)0 != l_373) << (uint16_t)14)))))
        { /* block id: 227 */
            int32_t l_376 = 0L;
            int32_t *l_375 = &l_376;
            int32_t **l_374 = &l_375;
            float l_378 = 0x9.B53ACBp-39;
            float *l_377 = &l_378;
            float ***l_382 = &l_379;
            float ****l_389 = &l_382;
            float *****l_388 = &l_389;
            (*p_61) = 0xE56CC4E7L;
            (*l_377) = ((0x7.3p+1 <= (((l_370 == 0x1.897B1Fp-97) == (((p_60 <= func_78(l_370, l_374, &p_61, p_60, &p_61)) < 0xA.AF14D8p+89) <= (**l_374))) != p_59)) <= p_60);
            (*l_382) = l_379;
            if ((p_59 != (0xA58F5251L > ((((int16_t)(*l_375) >> (int16_t)(l_385 && 0x22EAAC3AL)) < (p_59 == ((int16_t)((**l_374) && p_59) << (int16_t)(**l_391)))) >= 1UL))))
            { /* block id: 231 */
                int32_t *l_422 = &l_385;
                float **l_451 = &l_377;
                (*l_375) = ((int16_t)p_60 + (int16_t)0x142EL);
                if (((((uint16_t)((((uint16_t)p_60 + (uint16_t)((int16_t)((int32_t)5L - (int32_t)(&l_380 == &l_380)) >> (int16_t)func_84((~(**p_58)), &l_375, func_88((!((!((uint16_t)(&l_389 == l_408) << (uint16_t)12)) || (*l_392))))))) > (**l_391)) ^ 1L) << (uint16_t)1) | l_411) && (*p_61)))
                { /* block id: 233 */
                    float l_423 = 0x0.Cp+1;
                    int32_t *l_430 = &l_385;
                    if (l_385)
                        break;
                    (*l_377) = (((void*)0 != (*l_410)) > p_60);
                    if ((((int16_t)((uint16_t)p_60 >> (uint16_t)10) + (int16_t)((((int16_t)((((uint16_t)((uint16_t)(p_60 <= ((void*)0 == l_422)) << (uint16_t)__builtin_ffs((*l_375))) << (uint16_t)3) < (((int32_t)(p_60 != ((uint32_t)l_385 - (uint32_t)(l_428 != &p_61))) + (int32_t)7UL) > p_59)) == (**l_428)) >> (int16_t)9) < 0xF5AB0988L) < (**l_374))) != 0x19C6F292L))
                    { /* block id: 236 */
                        int32_t l_436 = 0x91F2F872L;
                        (*l_391) = l_430;
                        (**p_58) = ((uint32_t)((0x402CL >= (l_433 & ((((func_78(p_60, &l_392, &p_61, ((&p_61 != (void*)0) < ((int16_t)p_60 >> (int16_t)(p_60 <= 0x3D28L))), &l_392) >= p_60) ^ p_59) <= (*l_375)) >= l_436))) > (**p_58)) % (uint32_t)(**p_58));
                        (*l_380) = (((**l_428) > (((p_60 >= p_60) >= p_59) >= (**l_428))) <= p_59);
                        (*p_58) = func_88((**l_428));
                    }
                    else
                    { /* block id: 241 */
                        uint32_t l_443 = 0UL;
                        (**l_391) = l_443;
                        (*l_374) = (*p_58);
                    }
                    if ((*l_375))
                        break;
                }
                else
                { /* block id: 246 */
                    uint16_t l_444 = 0xCA91L;
                    if ((*l_392))
                    { /* block id: 247 */
                        int32_t l_452 = (-3L);
                        l_444 = (*l_422);
                        l_452 = ((2L ^ ((int32_t)(**p_58) - (int32_t)l_444)) | ((int16_t)((int16_t)((((void*)0 == l_451) || p_60) <= (((*l_375) && l_444) > ((0x621EL <= (**l_391)) >= p_59))) >> (int16_t)10) >> (int16_t)6));
                        (*p_58) = func_88(((*p_58) == (*l_428)));
                    }
                    else
                    { /* block id: 251 */
                        (*l_392) = (**l_391);
                    }
                    (**l_391) = ((uint16_t)65529UL >> (uint16_t)(*l_392));
                    (*p_61) = (((uint16_t)(__builtin_bswap64(p_59) < l_444) % (uint16_t)p_60) <= (p_60 == (**l_391)));
                    for (l_433 = 11; (l_433 == 11); l_433 += 9)
                    { /* block id: 258 */
                        uint32_t l_461 = 0x14C6972DL;
                        (*l_428) = func_88((*l_422));
                        (*l_392) = __builtin_clz((((uint16_t)func_84((*l_375), &l_375, func_88(p_60)) - (uint16_t)(l_461 >= (8UL < 5UL))) & (((int32_t)((uint32_t)p_59 + (uint32_t)1UL) % (int32_t)p_60) && 0x61B4L)));
                    }
                }
                return p_59;
            }
            else
            { /* block id: 264 */
                int32_t l_466 = (-2L);
                int32_t l_467 = 1L;
                l_467 = l_466;
                l_467 = (l_468 == l_470);
                (*l_429) = (*l_375);
            }
        }
        else
        { /* block id: 269 */
            float l_471 = 0xB.FFF4A5p+55;
            (***l_468) = func_88(p_60);
            (*l_428) = (*l_391);
        }
        for (p_60 = 8; (p_60 != 1); p_60 -= 1)
        { /* block id: 275 */
            float ****l_476 = &l_410;
            int32_t l_494 = 1L;
        }
    }
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_67(float  p_68)
{ /* block id: 41 */
    int32_t l_75 = 6L;
    int32_t *l_74 = &l_75;
    int32_t l_217 = (-1L);
    uint32_t l_219 = 0xAECDC9E8L;
    uint32_t l_220 = 0x0661D1CEL;
    float ***l_270 = (void*)0;
    int32_t **l_318 = (void*)0;
    int32_t ***l_317 = &l_318;
    int32_t ****l_316 = &l_317;
    int32_t *****l_315 = &l_316;
    float l_349 = 0x0.Ap-1;
    int32_t l_364 = 0x917E552FL;
    if (((__builtin_ia32_crc32qi(((l_74 != (void*)0) == (((uint16_t)(func_78((0x82E7L || func_84((*l_74), &l_74, func_88((*l_74)))), &l_74, &l_74, l_217, &l_74) || (*l_74)) - (uint16_t)l_217) <= l_217)), l_219) ^ l_220) & 0xAC7219EBL))
    { /* block id: 128 */
        float l_222 = 0x6.1p-1;
        float *l_221 = &l_222;
        (*l_221) = p_68;
    }
    else
    { /* block id: 130 */
        int16_t l_225 = 0xCE29L;
        int32_t *l_227 = &l_217;
        for (l_75 = (-18); (l_75 <= (-2)); l_75 += 3)
        { /* block id: 133 */
            int32_t **l_226 = &l_74;
            (*l_226) = func_88(l_225);
            (*l_226) = l_227;
        }
    }
    (*l_74) = (*l_74);
    for (l_219 = (-5); (l_219 >= 34); l_219 += 1)
    { /* block id: 141 */
        uint32_t l_230 = 0UL;
        int32_t **l_263 = &l_74;
        float *l_266 = (void*)0;
        float **l_265 = &l_266;
        float ***l_264 = &l_265;
        int16_t l_275 = 2L;
        float l_360 = 0x1.F8C89Fp+23;
    }
    (*l_74) = (*l_74);
    return l_364;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_64
 */
static uint32_t  func_78(uint32_t  p_79, int32_t ** p_80, int32_t ** p_81, uint32_t  p_82, int32_t ** p_83)
{ /* block id: 125 */
    uint32_t l_218 = 0x9024B7AEL;
    (**p_83) = l_218;
    return l_218;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_84(int16_t  p_85, int32_t ** p_86, int32_t * p_87)
{ /* block id: 119 */
    int32_t *l_206 = (void*)0;
    int32_t l_210 = 1L;
    uint32_t l_211 = 0x1F836BFBL;
    int32_t **l_212 = &l_206;
    p_87 = l_206;
    (**p_86) = ((-(uint16_t)((((uint32_t)l_210 + (uint32_t)l_210) == 0xC73AL) == (l_210 ^ ((8UL < ((p_85 > 0x75B47AC9L) || __builtin_ffsl(l_211))) < 0xC6DFL)))) > 1L);
    (*l_212) = &l_210;
    (**l_212) = (((uint16_t)((**p_86) >= p_85) % (uint16_t)((uint16_t)(65535UL || __builtin_ffsl(__builtin_bswap32((**l_212)))) << (uint16_t)(((0xB80F26FCL ^ ((**l_212) ^ ((**p_86) == p_85))) <= (**p_86)) <= p_85))) != 0x11A0L);
    return p_85;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_88(int32_t  p_89)
{ /* block id: 42 */
    float l_91 = 0x1.7p-1;
    float *l_90 = &l_91;
    int32_t *l_102 = (void*)0;
    int32_t **l_108 = &l_102;
    int32_t ***l_107 = &l_108;
    int16_t l_113 = 0L;
    int32_t ****l_138 = &l_107;
    int32_t *****l_137 = &l_138;
    int32_t l_180 = 0x711EE929L;
    int32_t *l_179 = &l_180;
    int32_t *l_181 = &l_180;
    int32_t *l_183 = &l_180;
    int32_t *l_185 = &l_180;
    int32_t *l_186 = &l_180;
    int32_t *l_189 = &l_180;
    int32_t *l_192 = &l_180;
    int32_t *l_193 = (void*)0;
    int32_t *l_201 = &l_180;
    int32_t *l_203 = &l_180;
    int32_t *l_204 = &l_180;
    int32_t *l_205 = (void*)0;
    (*l_90) = 0xF.7A64A0p-72;
    for (p_89 = 2; (p_89 >= (-21)); p_89 -= 1)
    { /* block id: 46 */
        int32_t l_96 = 1L;
        int32_t *l_95 = &l_96;
        int32_t **l_94 = &l_95;
        (*l_94) = (void*)0;
        if (p_89)
            break;
    }
    for (p_89 = 15; (p_89 > 10); p_89 -= 1)
    { /* block id: 52 */
        int32_t l_99 = 0xA237FF9BL;
        int32_t *l_106 = &l_99;
        int32_t ****l_109 = &l_107;
        uint16_t l_114 = 65527UL;
        float **l_139 = &l_90;
        for (l_99 = 0; (l_99 >= 24); l_99 += 9)
        { /* block id: 55 */
            float *l_103 = &l_91;
            int32_t l_105 = (-1L);
            int32_t *l_104 = &l_105;
            l_102 = &l_99;
            (*l_104) = ((void*)0 != l_103);
        }
    }
    if ((((*l_179) >= p_89) & p_89))
    { /* block id: 112 */
        int32_t *l_182 = &l_180;
        int32_t *l_184 = &l_180;
        int32_t *l_187 = &l_180;
        int32_t *l_188 = &l_180;
        int32_t *l_190 = &l_180;
        int32_t *l_191 = &l_180;
        return l_193;
    }
    else
    { /* block id: 114 */
        float ***l_194 = (void*)0;
        float ***l_195 = (void*)0;
        float **l_197 = (void*)0;
        float ***l_196 = &l_197;
        int32_t *l_198 = &l_180;
        int32_t *l_199 = &l_180;
        int32_t *l_200 = &l_180;
        int32_t *l_202 = &l_180;
        (*l_196) = (void*)0;
        (****l_137) = l_198;
        return l_205;
    }
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 178
XXX total union variables: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 24
   depth: 3, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 165

XXX times a variable address is taken: 169
XXX times a pointer is dereferenced on RHS: 104
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 40
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 89
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 12
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 760

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 183
   level: 2, occurrence: 123
   level: 3, occurrence: 35
   level: 4, occurrence: 30
   level: 5, occurrence: 18
XXX number of pointers point to pointers: 89
XXX number of pointers point to scalars: 76
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.1
XXX average alias set size: 1.16

XXX times a non-volatile is read: 643
XXX times a non-volatile is write: 256
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 15
   depth: 2, occurrence: 18
   depth: 3, occurrence: 8
   depth: 4, occurrence: 8
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 12.4
XXX percentage an existing variable is used: 87.6
********************* end of statistics **********************/

