/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      162294352
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int16_t  f0;
   int16_t  f1;
   int32_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xB13638EC;
static int32_t g_5 = 0x2EAC4530;
static int32_t g_8 = 6;
static int32_t g_12[1][5][5] = {{{1,0xDAFBBD0A,1,1,0xDAFBBD0A},{(-7),0,1,0,1},{0xDAFBBD0A,0xDAFBBD0A,(-1),0xDAFBBD0A,0xDAFBBD0A},{1,0,1,0,(-7)},{0xDAFBBD0A,1,1,0xDAFBBD0A,1}}};
static int32_t g_13 = 0xB722BA7B;
static struct S0 g_42 = {-1,0x58D0,4};
static int32_t *g_95[4] = {&g_12[0][1][0],&g_12[0][1][0],&g_12[0][1][0],&g_12[0][1][0]};
static int32_t **g_94 = &g_95[2];
static const int32_t *g_172 = &g_13;
static struct S0 *g_210[8][4][4] = {{{&g_42,&g_42,&g_42,(void*)0},{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,(void*)0,&g_42},{&g_42,&g_42,&g_42,(void*)0}},{{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42},{(void*)0,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42}},{{&g_42,&g_42,&g_42,(void*)0},{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,(void*)0,(void*)0}},{{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42}},{{&g_42,(void*)0,&g_42,&g_42},{&g_42,&g_42,&g_42,(void*)0},{&g_42,(void*)0,(void*)0,&g_42},{&g_42,&g_42,&g_42,&g_42}},{{&g_42,&g_42,&g_42,&g_42},{&g_42,(void*)0,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42}},{{(void*)0,&g_42,&g_42,&g_42},{&g_42,(void*)0,&g_42,&g_42},{(void*)0,(void*)0,&g_42,&g_42},{(void*)0,&g_42,&g_42,&g_42}},{{&g_42,&g_42,&g_42,&g_42},{&g_42,&g_42,&g_42,&g_42},{&g_42,(void*)0,(void*)0,&g_42},{&g_42,&g_42,&g_42,&g_42}}};
static struct S0 **g_209 = &g_210[1][2][1];
static int32_t ** const *g_269 = &g_94;
static int32_t ** const **g_268 = &g_269;
static struct S0 g_275 = {0x8FA5,0xF229,0x9070625B};
static struct S0 *g_274 = &g_275;
static int16_t g_400 = (-7);
static const int16_t g_470 = (-3);
static const int32_t **g_597[4][3] = {{&g_172,&g_172,&g_172},{&g_172,&g_172,&g_172},{&g_172,&g_172,&g_172},{&g_172,&g_172,&g_172}};
static const int32_t ***g_596[9] = {&g_597[1][2],(void*)0,&g_597[1][2],(void*)0,&g_597[1][2],(void*)0,&g_597[1][2],(void*)0,&g_597[1][2]};
static struct S0 g_663[10] = {{3,-4,-2},{3,-4,-2},{0xFCA1,0xE77C,0x0488DA91},{3,-4,-2},{3,-4,-2},{0xFCA1,0xE77C,0x0488DA91},{3,-4,-2},{3,-4,-2},{0xFCA1,0xE77C,0x0488DA91},{3,-4,-2}};
static struct S0 ***g_828[9][4][7] = {{{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209},{&g_209,(void*)0,&g_209,&g_209,(void*)0,&g_209,&g_209},{&g_209,&g_209,(void*)0,&g_209,&g_209,(void*)0,(void*)0},{(void*)0,&g_209,&g_209,&g_209,(void*)0,&g_209,&g_209}},{{&g_209,(void*)0,&g_209,&g_209,&g_209,&g_209,&g_209},{&g_209,(void*)0,(void*)0,&g_209,(void*)0,(void*)0,&g_209},{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209},{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209}},{{(void*)0,(void*)0,&g_209,&g_209,&g_209,&g_209,(void*)0},{&g_209,(void*)0,&g_209,(void*)0,&g_209,&g_209,&g_209},{&g_209,(void*)0,(void*)0,&g_209,&g_209,&g_209,&g_209},{&g_209,&g_209,&g_209,(void*)0,&g_209,&g_209,&g_209}},{{&g_209,&g_209,(void*)0,&g_209,&g_209,&g_209,(void*)0},{&g_209,&g_209,(void*)0,(void*)0,&g_209,&g_209,&g_209},{&g_209,&g_209,(void*)0,&g_209,&g_209,&g_209,&g_209},{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209}},{{&g_209,(void*)0,(void*)0,&g_209,&g_209,&g_209,&g_209},{(void*)0,&g_209,&g_209,&g_209,&g_209,&g_209,(void*)0},{&g_209,&g_209,&g_209,&g_209,(void*)0,&g_209,&g_209},{&g_209,(void*)0,&g_209,&g_209,&g_209,&g_209,&g_209}},{{&g_209,&g_209,(void*)0,&g_209,&g_209,&g_209,&g_209},{&g_209,&g_209,&g_209,(void*)0,(void*)0,&g_209,(void*)0},{(void*)0,&g_209,&g_209,&g_209,&g_209,(void*)0,&g_209},{&g_209,&g_209,&g_209,(void*)0,&g_209,&g_209,(void*)0}},{{&g_209,&g_209,&g_209,&g_209,(void*)0,&g_209,&g_209},{&g_209,&g_209,&g_209,(void*)0,&g_209,(void*)0,(void*)0},{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209},{&g_209,&g_209,(void*)0,&g_209,&g_209,&g_209,&g_209}},{{&g_209,(void*)0,(void*)0,&g_209,&g_209,(void*)0,&g_209},{&g_209,&g_209,&g_209,(void*)0,&g_209,&g_209,&g_209},{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209},{(void*)0,(void*)0,&g_209,&g_209,&g_209,&g_209,&g_209}},{{&g_209,&g_209,&g_209,&g_209,&g_209,&g_209,&g_209},{(void*)0,&g_209,&g_209,&g_209,&g_209,&g_209,(void*)0},{&g_209,(void*)0,&g_209,&g_209,(void*)0,&g_209,&g_209},{&g_209,&g_209,&g_209,&g_209,&g_209,(void*)0,&g_209}}};
static struct S0 **** const g_827 = &g_828[3][2][5];
static struct S0 ****g_900 = (void*)0;
static struct S0 **** const *g_899 = &g_900;
static int32_t g_1008 = 1;
static const uint32_t g_1025 = 0x6F47B661;
static int32_t *g_1117 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
inline static const int16_t  func_1(void);
static struct S0 * func_14(struct S0 * p_15, struct S0 * const  p_16, int32_t  p_17, uint16_t  p_18, struct S0  p_19);
inline static struct S0 * func_20(struct S0 * p_21, const uint16_t  p_22, struct S0 * p_23, uint16_t  p_24);
inline static struct S0 * func_25(struct S0 * p_26, struct S0  p_27, int16_t  p_28, struct S0  p_29, struct S0 * p_30);
inline static struct S0 * func_31(uint8_t  p_32, uint16_t  p_33, const uint32_t  p_34);
inline static uint8_t  func_35(struct S0 * p_36, const struct S0 * p_37, struct S0 * p_38, int16_t  p_39, struct S0 * p_40);
inline static struct S0 * func_43(uint32_t  p_44);
static uint32_t  func_47(struct S0 * p_48, int32_t  p_49);
static struct S0 * func_50(struct S0  p_51, struct S0 * p_52, uint8_t  p_53);
inline static struct S0  func_54(uint32_t  p_55, struct S0 * p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_268 g_269 g_94 g_95 g_42.f1 g_663.f0
 * writes: g_2 g_5 g_8 g_12 g_13 g_95 g_42.f1
 */
inline static const int16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_11[6][7] = {{8,4,(-1),(-1),4,8,4},{0x05B2906C,8,8,0x05B2906C,4,0x05B2906C,8},{(-1),(-1),8,(-1),8,(-1),(-1)},{(-1),8,(-1),8,(-1),(-1),8},{0x05B2906C,4,0x05B2906C,8,8,0x05B2906C,4},{8,4,(-1),(-1),4,8,4}};
    struct S0 *l_282 = &g_275;
    uint16_t l_893 = 1U;
    const int8_t l_920 = 0x9D;
    int16_t l_921 = (-1);
    int32_t l_945 = 0x10CAE1B0;
    int32_t ***l_958 = &g_94;
    const int32_t l_968 = 0x25D7E897;
    int32_t *l_1013 = &l_11[1][0];
    struct S0 ***l_1056 = &g_209;
    uint8_t l_1094[3];
    int i, j;
    for (i = 0; i < 3; i = i + 1)
        l_1094[i] = 0x82;
    for (g_2 = 0; (g_2 == 3); g_2 = safe_add_func_uint32_t_u_u(g_2, 1))
    { /* block id: 3 */
        int32_t ****l_277[1];
        struct S0 *l_662 = &g_663[0];
        const struct S0 ***l_843 = (void*)0;
        const struct S0 ****l_842[9] = {&l_843,&l_843,&l_843,&l_843,&l_843,&l_843,&l_843,&l_843,&l_843};
        uint32_t l_889 = 4294967295U;
        int32_t l_890 = (-7);
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_277[i] = (void*)0;
        for (g_5 = (-4); (g_5 < (-8)); --g_5)
        { /* block id: 6 */
            int32_t *l_816 = (void*)0;
            uint16_t l_822 = 65531U;
            for (g_8 = 0; (g_8 == 14); ++g_8)
            { /* block id: 9 */
                struct S0 *l_41 = &g_42;
                int32_t l_281 = 0xC7F93EFD;
                struct S0 l_798 = {-5,1,0xE8304A18};
                struct S0 **l_815 = &l_282;
                for (g_12[0][1][0] = 0; g_12[0][1][0] < 6; g_12[0][1][0] += 1)
                {
                    for (g_13 = 0; g_13 < 7; g_13 += 1)
                    {
                        l_11[g_12[0][1][0]][g_13] = (-6);
                    }
                }
            }
            (***g_268) = (***g_268);
            if (l_11[5][0])
                break;
        }
        (***g_268) = (**g_269);
        for (g_13 = 3; (g_13 >= 0); g_13 -= 1)
        { /* block id: 453 */
            const uint32_t l_823 = 0x443E49FE;
            uint32_t l_831 = 4294967289U;
            int16_t l_845 = 1;
            int32_t *l_878 = &g_12[0][2][1];
            int16_t l_897 = (-1);
            (***g_268) = &l_11[2][2];
        }
        (**g_269) = (**g_269);
    }
    /* facts after for loop */
    //assert ((g_95[0] >= &l_11[0][0] && g_95[0] <= &l_11[5][6]) || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]));
    for (g_42.f1 = 0; (g_42.f1 <= 0); g_42.f1 += 1)
    { /* block id: 506 */
        int32_t *l_901[8];
        const int32_t *l_924 = &g_12[0][1][1];
        uint32_t l_927[7] = {0U,0U,0U,0U,0U,0U,0U};
        int32_t *l_949 = (void*)0;
        int32_t l_969 = (-1);
        int32_t l_1009 = 0x0873D2C9;
        struct S0 l_1010[7] = {{0xF64C,1,1},{0xF64C,1,1},{0xF64C,1,1},{0xF64C,1,1},{0xF64C,1,1},{0xF64C,1,1},{0xF64C,1,1}};
        const int32_t l_1027[10][8] = {{0x416CC876,0x4502E30E,(-1),8,(-1),0x4502E30E,0x416CC876,8},{0x416CC876,0x949A19C7,(-1),0x23934D12,(-1),0x949A19C7,0x416CC876,0x23934D12},{0x416CC876,0x4502E30E,(-1),8,(-1),0x4502E30E,0x416CC876,8},{0x416CC876,0x949A19C7,(-1),0x23934D12,(-1),0x949A19C7,0x416CC876,0x23934D12},{0x416CC876,0x4502E30E,(-1),8,(-1),0x4502E30E,0x416CC876,8},{0x416CC876,0x949A19C7,(-1),0x23934D12,(-1),0x949A19C7,0x416CC876,0x23934D12},{0x416CC876,0x4502E30E,(-1),8,(-1),0x4502E30E,0x416CC876,8},{0x416CC876,0x949A19C7,(-1),0x23934D12,(-1),0x949A19C7,0x416CC876,0x23934D12},{0x416CC876,0x4502E30E,(-1),8,(-1),0x4502E30E,0x416CC876,8},{0x416CC876,0x949A19C7,(-1),0x23934D12,(-1),0x949A19C7,0x416CC876,0x23934D12}};
        int32_t l_1112 = 0x587D47C2;
        int i, j;
        for (i = 0; i < 8; i = i + 1)
            l_901[i] = &g_2;
        (**g_269) = l_901[5];
    }
    /* facts after for loop */
    //assert (g_95[0] == &g_2 || (g_95[0] >= &l_11[0][0] && g_95[0] <= &l_11[5][6]) || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]));
    return g_663[0].f0;
    /* statement id: 613 */
    //assert (g_95[0] == &g_2 || g_95[0] == dangling || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f0 g_5 g_42.f1 g_275.f1 g_12 g_275 g_42 g_274
 * writes: g_275
 */
static struct S0 * func_14(struct S0 * p_15, struct S0 * const  p_16, int32_t  p_17, uint16_t  p_18, struct S0  p_19)
{ /* block id: 434 */
    int32_t l_806 = 1;
    int32_t ***l_812 = &g_94;
    for (p_19.f1 = (-29); (p_19.f1 > 22); p_19.f1 = safe_add_func_int32_t_s_s(p_19.f1, 6))
    { /* block id: 437 */
        struct S0 l_801 = {-1,0x8C44,0};
        (*p_16) = l_801;
        p_17 = ((safe_rshift_func_uint16_t_u_u((((safe_mul_func_int16_t_s_s(l_806, (((l_806 && g_42.f0) > (safe_unary_minus_func_uint8_t_u((safe_mul_func_int8_t_s_s(((g_5 | (((safe_div_func_int16_t_s_s((l_812 == (void*)0), g_5)) ^ (safe_lshift_func_int8_t_s_s((1 >= g_42.f1), 4))) | 0xE88A430C)) >= l_801.f1), 1))))) <= l_801.f1))) < g_275.f1) < g_12[0][1][0]), 8)) || p_19.f1);
        (*g_274) = (*p_15);
    }
    return &g_275;
    /* statement id: 442 */
    //assert (func_14_rv == &g_275);
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f1 g_663.f0 g_268 g_269 g_94 g_470 g_13 g_275.f2 g_663 g_42 g_12 g_8 g_5 g_275.f0 g_400 g_2 g_275
 * writes: g_95 g_13 g_42.f1 g_275.f0 g_663 g_12 g_269 g_275 g_42
 */
inline static struct S0 * func_20(struct S0 * p_21, const uint16_t  p_22, struct S0 * p_23, uint16_t  p_24)
{ /* block id: 354 */
    int32_t **l_664[1];
    struct S0 ** const l_671 = (void*)0;
    uint32_t l_756 = 0xBADE8B0E;
    uint32_t l_773[5][8][6] = {{{0x51FBAE2C,4294967290U,4U,4294967294U,4U,4294967290U},{4U,4294967295U,1U,4294967287U,4294967293U,6U},{4U,0xCB4E7816,4294967293U,4294967294U,0xBB762B7A,4294967294U},{0x51FBAE2C,0xCB4E7816,0x51FBAE2C,6U,4294967293U,4294967287U},{0xC096AB46,4294967295U,0x51FBAE2C,4294967290U,4U,4294967294U},{0U,4294967290U,4294967293U,4294967295U,1U,4294967287U},{0x51FBAE2C,6U,4294967293U,4294967287U,1U,4294967295U},{0U,4294967295U,0xBB762B7A,6U,0xBB762B7A,4294967295U}},{{0xBB762B7A,4294967294U,4294967293U,0xCB4E7816,4U,4294967287U},{0xBB762B7A,0xFE6B6432,4U,6U,0xC096AB46,6U},{0U,0xFE6B6432,0U,4294967287U,4U,0xCB4E7816},{0x51FBAE2C,4294967294U,0U,4294967295U,0xBB762B7A,6U},{1U,4294967295U,4U,4294967295U,1U,4294967287U},{0x51FBAE2C,6U,4294967293U,4294967287U,1U,4294967295U},{0U,4294967295U,0xBB762B7A,6U,0xBB762B7A,4294967295U},{0xBB762B7A,4294967294U,4294967293U,0xCB4E7816,4U,4294967287U}},{{0xBB762B7A,0xFE6B6432,4U,6U,0xC096AB46,6U},{0U,0xFE6B6432,0U,4294967287U,4U,0xCB4E7816},{0x51FBAE2C,4294967294U,0U,4294967295U,0xBB762B7A,6U},{1U,4294967295U,4U,4294967295U,1U,4294967287U},{0x51FBAE2C,6U,4294967293U,4294967287U,1U,4294967295U},{0U,4294967295U,0xBB762B7A,6U,0xBB762B7A,4294967295U},{0xBB762B7A,4294967294U,4294967293U,0xCB4E7816,4U,4294967287U},{0xBB762B7A,0xFE6B6432,4U,6U,0xC096AB46,6U}},{{0U,0xFE6B6432,0U,4294967287U,4U,0xCB4E7816},{0x51FBAE2C,4294967294U,0U,4294967295U,0xBB762B7A,6U},{1U,4294967295U,4U,4294967295U,1U,4294967287U},{0x51FBAE2C,6U,4294967293U,4294967287U,1U,4294967295U},{0U,4294967295U,0xBB762B7A,6U,0xBB762B7A,4294967295U},{0xBB762B7A,4294967294U,4294967293U,0xCB4E7816,4U,4294967287U},{0xBB762B7A,0xFE6B6432,4U,6U,0xC096AB46,6U},{0U,0xFE6B6432,0U,4294967287U,4U,0xCB4E7816}},{{0x51FBAE2C,4294967294U,0U,4294967295U,0xBB762B7A,6U},{1U,4294967295U,4U,4294967295U,1U,4294967287U},{0x51FBAE2C,6U,4294967293U,4294967287U,1U,4294967295U},{0U,4294967295U,0xBB762B7A,6U,0xBB762B7A,4294967295U},{0xBB762B7A,4294967294U,4294967293U,0xCB4E7816,4U,4294967287U},{0xBB762B7A,0xFE6B6432,0xBB762B7A,4294967287U,0x51FBAE2C,4294967287U},{1U,4294967290U,1U,0xCB4E7816,0xBB762B7A,0xFE6B6432},{0U,6U,1U,4294967294U,0xC096AB46,4294967287U}}};
    struct S0 *l_795 = &g_663[0];
    int i, j, k;
    for (i = 0; i < 1; i = i + 1)
        l_664[i] = (void*)0;
    if ((l_664[0] == (void*)0))
    { /* block id: 355 */
        int32_t *l_672 = &g_13;
        struct S0 *l_685 = &g_275;
        const struct S0 *l_689 = &g_663[8];
        const struct S0 **l_688 = &l_689;
        int32_t ***l_703[4][6] = {{&g_94,(void*)0,&g_94,(void*)0,&g_94,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&g_94,(void*)0,&g_94,(void*)0,&g_94,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
        int16_t l_764 = 0x76AE;
        int32_t l_784[5][5] = {{0,7,0x45286CE0,0xE36EBCDC,7},{(-1),0x45286CE0,0x45286CE0,(-1),0xE36EBCDC},{(-1),(-1),0x6D096E80,7,7},{0,(-1),0,0xE36EBCDC,(-1)},{7,0x45286CE0,0xE36EBCDC,7,0xE36EBCDC}};
        int8_t l_785 = 0x1E;
        int i, j;
        if (((safe_add_func_int16_t_s_s((safe_div_func_int8_t_s_s(((safe_add_func_uint8_t_u_u((l_671 == (void*)0), g_42.f1)) != (l_672 == (void*)0)), g_663[0].f0)), 8U)) ^ (safe_lshift_func_uint16_t_u_u(p_24, 7))))
        { /* block id: 356 */
            int32_t *l_680 = &g_8;
            uint32_t l_737 = 0x57EACDEB;
            int32_t l_744[3];
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_744[i] = (-1);
lbl_692:
            for (p_24 = 0; (p_24 <= 3); p_24 += 1)
            { /* block id: 359 */
                int32_t *l_675 = &g_13;
                const struct S0 *l_687 = (void*)0;
                const struct S0 **l_686 = &l_687;
                (***g_268) = l_675;
                (*l_672) = (g_470 == (((*l_675) <= (safe_mul_func_uint8_t_u_u((safe_mul_func_int16_t_s_s(p_22, ((void*)0 != (**g_268)))), (l_680 != l_675)))) <= g_275.f2));
                (**g_269) = l_680;
                (**g_269) = l_672;
                for (g_42.f1 = 0; (g_42.f1 >= 0); g_42.f1 -= 1)
                { /* block id: 366 */
                    int i;
                    for (g_275.f0 = 0; (g_275.f0 <= 3); g_275.f0 += 1)
                    { /* block id: 369 */
                        int i, j, k;
                        l_680 = &g_12[g_42.f1][(g_42.f1 + 4)][(g_275.f0 + 1)];
                        /* statement id: 370 */
                        assert ((l_680 >= &g_12[0][0][0] && l_680 <= &g_12[0][4][4]));
                        if (p_22)
                            continue;
                        (*p_23) = (*p_23);
                        if (p_24)
                            goto lbl_692;
                        //assert (l_688 == &l_689 || l_688 == dangling);
                        (*l_675) = (((void*)0 == p_21) & p_22);
                    }
                    if (p_22)
                        break;
                    for (g_275.f0 = 0; (g_275.f0 <= 0); g_275.f0 += 1)
                    { /* block id: 378 */
                        const int32_t **l_684 = &g_172;
                        (*p_23) = func_54((0xB62341F9 & (safe_div_func_uint16_t_u_u((~((*g_269) == l_684)), 0x7777))), l_685);
                        return p_21;
                        /* statement id: 380 */
                        //assert (func_20_rv == &g_275 || func_20_rv == &g_42);
                    }
                    for (g_13 = 0; (g_13 <= 3); g_13 += 1)
                    { /* block id: 384 */
                        int i, j, k;
                        l_688 = l_686;
                        /* statement id: 385 */
                        assert (l_688 == &l_687);
                        l_675 = &g_12[g_42.f1][(g_42.f1 + 3)][(g_13 + 1)];
                        /* statement id: 386 */
                        assert ((l_675 >= &g_12[0][0][0] && l_675 <= &g_12[0][4][4]));
                        (*l_675) = (safe_rshift_func_int8_t_s_u(p_22, 1));
                        (*l_675) = ((void*)0 != &g_596[6]);
                    }
                }
                /* facts after for loop */
                //assert (l_688 == &l_687 || l_688 == &l_689 || l_688 == dangling);
                assert ((l_675 >= &g_12[0][0][0] && l_675 <= &g_12[0][4][4]) || l_675 == &g_13);
            }
            if ((safe_mul_func_uint16_t_u_u(0x6A7D, g_470)))
            { /* block id: 393 */
                int16_t l_699 = (-4);
                int32_t *l_702 = (void*)0;
                (*g_94) = l_680;
                if ((safe_lshift_func_uint8_t_u_u(255U, ((safe_add_func_int32_t_s_s((l_699 && (safe_lshift_func_int8_t_s_u((l_702 != l_672), 2))), (((&g_209 == (void*)0) & p_24) < (l_703[0][5] == l_703[0][5])))) > g_42.f2))))
                { /* block id: 395 */
                    int32_t *l_704 = (void*)0;
                    l_702 = l_704;
                    (**g_269) = l_680;
                }
                else
                { /* block id: 398 */
                    int32_t *l_705 = &g_13;
                    (**g_269) = l_680;
                    l_702 = l_705;
                    /* statement id: 400 */
                    assert (l_702 == &g_13);
                    if ((*l_680))
                    { /* block id: 401 */
                        l_680 = l_680;
                    }
                    else
                    { /* block id: 403 */
                        uint32_t l_710 = 0U;
                        (***g_268) = (void*)0;
                        if (g_42.f1)
                            goto lbl_745;
                        (*l_672) = ((safe_mul_func_int8_t_s_s((safe_mul_func_uint8_t_u_u(p_22, (l_710 <= (4294967295U | (safe_add_func_int32_t_s_s((safe_sub_func_uint8_t_u_u((+((safe_unary_minus_func_uint8_t_u(((safe_lshift_func_int8_t_s_u((~(safe_rshift_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(((p_24 != 0xAC60C215) == (safe_lshift_func_uint8_t_u_u((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_div_func_int32_t_s_s((-5), (safe_unary_minus_func_uint32_t_u(g_42.f2)))), 15)), (l_737 && (safe_add_func_uint16_t_u_u(((safe_mod_func_uint16_t_u_u(((safe_div_func_uint16_t_u_u(g_42.f1, 1U)) || g_5), g_5)) & p_22), 0x14EF))))), g_275.f0))), 15)), p_22)) & 0xB9), 0x43853552)), p_22))), (*l_705))) || p_24))) < 0x20461724)), g_400)), g_42.f1)))))), l_744[2])) && g_42.f0);
lbl_745:
                        (*g_94) = l_702;
                        (*l_702) = p_24;
                    }
                }
                /* facts after branching */
                assert (l_702 == &g_13 || l_702 == 0);
                l_680 = l_680;
                (*l_672) = ((safe_add_func_uint32_t_u_u((0xF0 < ((safe_mod_func_uint8_t_u_u(g_12[0][1][0], (*l_680))) == (((safe_sub_func_uint32_t_u_u(((&g_210[4][1][1] != (void*)0) || 0xFE422706), (((safe_lshift_func_int16_t_s_s((0x2B06 != (((safe_add_func_int8_t_s_s(((g_470 || (p_24 || 0xE1)) < 0U), 0xCF)) == g_12[0][1][0]) != 5U)), 7)) && p_22) != 0x05))) != g_12[0][1][0]) == l_756))), 1)) | g_42.f0);
            }
            else
            { /* block id: 413 */
                int32_t **l_761 = (void*)0;
                (*l_672) = (safe_lshift_func_int8_t_s_u(g_42.f0, 6));
                (*g_268) = (void*)0;
                /* statement id: 415 */
                assert (g_269 == 0);
                (*l_672) = (g_2 & (safe_rshift_func_int8_t_s_s(g_42.f0, ((g_42.f1 & (l_761 == &l_680)) & 0x9E16B8F2))));
            }
            /* facts after branching */
            assert (g_269 == 0 || g_269 == &g_94);
        }
        else
        { /* block id: 418 */
            struct S0 *l_770[10][7][2] = {{{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42},{&g_663[0],&g_663[0]}},{{&g_663[0],&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42}},{{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]}},{{&g_275,&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42}},{{(void*)0,&g_663[0]},{&g_275,&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]}},{{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42}},{{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_663[0],&g_663[0]}},{{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42}},{{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42},{&g_663[0],&g_663[0]}},{{&g_663[0],&g_42},{&g_663[0],&g_663[0]},{&g_663[0],&g_42},{&g_275,&g_663[0]},{(void*)0,&g_42},{(void*)0,&g_663[0]},{&g_275,&g_42}}};
            int i, j, k;
            (*l_672) = p_24;
            (*l_672) = ((safe_sub_func_int32_t_s_s((0x21 & l_764), ((p_24 >= (~(((safe_rshift_func_uint16_t_u_s(p_24, ((safe_add_func_uint16_t_u_u(((0xCD6D != 0x9078) == (((void*)0 == l_770[6][5][0]) > (p_24 > g_275.f0))), g_12[0][2][2])) ^ 0U))) <= (*l_672)) >= g_275.f2))) <= g_13))) <= p_22);
        }
        /* facts after branching */
        assert (g_269 == 0 || g_269 == &g_94);
        //assert (l_688 == dangling || l_688 == &l_689);
        (*l_685) = (*p_21);
        (*l_672) = ((((((safe_mul_func_int16_t_s_s(l_773[0][0][2], g_663[0].f1)) ^ (0x701C0354 >= (g_275.f1 == (safe_sub_func_uint16_t_u_u(g_42.f1, (safe_add_func_int8_t_s_s(p_22, (((safe_div_func_int32_t_s_s(p_24, (safe_add_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(((l_664[0] != l_664[0]) && p_24), g_663[0].f2)), l_784[3][1])))) ^ 2) | p_22)))))))) < 65535U) == l_785) == 0xB6DA48AC) <= p_22);
    }
    else
    { /* block id: 424 */
        uint16_t l_792 = 65527U;
        (*p_23) = func_54((safe_mul_func_int16_t_s_s((p_24 | ((65526U & (-8)) < g_470)), (((-1) || (safe_rshift_func_int8_t_s_s(((0xCFEE && (safe_lshift_func_uint16_t_u_s((l_792 == (safe_sub_func_uint8_t_u_u(g_42.f0, 255U))), g_5))) > 1), g_275.f1))) != 0x115F))), l_795);
    }
    /* facts after branching */
    assert (g_269 == 0 || g_269 == &g_94);
    for (g_275.f0 = 14; (g_275.f0 != (-6)); g_275.f0 = safe_sub_func_uint8_t_u_u(g_275.f0, 4))
    { /* block id: 429 */
        return p_21;
        /* statement id: 430 */
        //assert (func_20_rv == &g_275 || func_20_rv == &g_42);
    }
    (*p_21) = (*l_795);
    return p_21;
    /* statement id: 433 */
    //assert (func_20_rv == &g_275 || func_20_rv == &g_42);
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f2 g_12 g_275.f1 g_268 g_269 g_8 g_94 g_275.f0 g_5 g_13 g_42.f0 g_2 g_275.f2 g_42.f1 g_400 g_42 g_274 g_470 g_275
 * writes: g_42.f2 g_209 g_13 g_275.f0 g_95 g_12 g_172 g_210 g_275 g_400 g_42.f0
 */
inline static struct S0 * func_25(struct S0 * p_26, struct S0  p_27, int16_t  p_28, struct S0  p_29, struct S0 * p_30)
{ /* block id: 123 */
    int32_t **l_297 = &g_95[2];
    int32_t l_298 = 8;
    int32_t l_321 = 0x04213B5F;
    int32_t ***l_366 = &l_297;
    int32_t ****l_365 = &l_366;
    struct S0 *l_403 = &g_42;
    struct S0 l_455 = {0x612D,0x5162,-1};
    int16_t l_493 = 0;
    int32_t *l_499 = &l_298;
    const struct S0 ***l_508 = (void*)0;
    struct S0 l_622 = {0x55A4,0,0x6833D472};
    struct S0 *l_659 = &l_622;
    struct S0 *l_660 = &l_622;
    struct S0 *l_661 = &g_42;
    for (g_42.f2 = (-6); (g_42.f2 <= (-24)); g_42.f2--)
    { /* block id: 126 */
        const uint8_t l_285[4] = {0x0F,0x0F,0x0F,0x0F};
        struct S0 *l_294 = (void*)0;
        struct S0 ***l_299 = &g_209;
        int32_t *l_300 = &g_13;
        int32_t *l_328 = (void*)0;
        int i;
        l_298 = (l_285[2] > (safe_add_func_uint32_t_u_u(g_12[0][0][0], (safe_lshift_func_int16_t_s_u(((&g_269 == (void*)0) <= (safe_add_func_uint16_t_u_u(((safe_add_func_uint32_t_u_u((((void*)0 != l_294) >= (safe_sub_func_uint8_t_u_u(((void*)0 == &g_210[3][1][2]), (l_297 == (void*)0)))), 0xBA30310D)) >= 0x57C2B75B), 0xFF9A))), l_285[2])))));
        (*l_299) = (void*)0;
        /* statement id: 128 */
        assert (g_209 == 0);
        (*l_300) = (0x883F <= (l_298 > g_12[0][1][0]));
        for (g_275.f0 = 23; (g_275.f0 <= (-29)); g_275.f0--)
        { /* block id: 132 */
            int8_t l_314 = 0x8A;
            int32_t *l_322 = &g_12[0][3][3];
            const int32_t **l_325 = &g_172;
            const int32_t ***l_324[7][2] = {{(void*)0,&l_325},{&l_325,&l_325},{(void*)0,&l_325},{(void*)0,(void*)0},{(void*)0,&l_325},{(void*)0,&l_325},{&l_325,&l_325}};
            const int32_t ****l_323 = &l_324[3][1];
            struct S0 **l_357 = &g_274;
            int i, j;
            for (p_27.f2 = 0; (p_27.f2 <= 3); p_27.f2 += 1)
            { /* block id: 135 */
                struct S0 *l_306 = &g_42;
                int32_t *l_329 = (void*)0;
                int32_t *** const l_340 = &g_94;
                int16_t l_341 = 0;
                for (p_28 = 0; (p_28 <= 3); p_28 += 1)
                { /* block id: 138 */
                    int16_t l_313 = 0xFA6E;
                    for (l_298 = 3; (l_298 >= 0); l_298 -= 1)
                    { /* block id: 141 */
                        int32_t *l_303[3];
                        int i;
                        for (i = 0; i < 3; i = i + 1)
                            l_303[i] = &g_13;
                        g_95[l_298] = l_303[0];
                        l_321 = (((safe_add_func_uint16_t_u_u((((((void*)0 != l_306) >= g_275.f1) && (safe_mod_func_uint32_t_u_u(p_29.f1, (safe_div_func_int32_t_s_s((safe_mul_func_int8_t_s_s(l_313, ((void*)0 == (*g_268)))), (l_314 ^ (safe_lshift_func_uint8_t_u_s(((safe_lshift_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(l_314, 0xF249)), g_8)) <= p_27.f2), p_27.f1)))))))) | p_29.f2), 0x0532)) & l_313) != g_275.f1);
                        (**g_269) = l_322;
                    }
                    (*l_322) = ((&g_269 == l_323) || (safe_rshift_func_int8_t_s_s((l_328 != l_329), ((safe_div_func_uint32_t_u_u((safe_add_func_int16_t_s_s((safe_add_func_int8_t_s_s((safe_mul_func_uint16_t_u_u(g_275.f0, (((0x2331 < (255U | ((&l_297 == l_340) >= g_5))) != g_13) <= g_12[0][2][0]))), g_13)), l_341)), g_275.f0)) ^ l_313))));
                }
                (*l_322) = (p_27.f0 > (p_29.f1 == ((safe_add_func_uint32_t_u_u((safe_sub_func_uint16_t_u_u(p_27.f1, ((~((((safe_mul_func_uint8_t_u_u(p_27.f0, ((&g_269 == (void*)0) <= ((void*)0 != &g_209)))) > (safe_mul_func_uint8_t_u_u(g_275.f0, g_42.f0))) == (-5)) & p_27.f0)) ^ g_13))), g_42.f2)) && (-1))));
                for (l_341 = 28; (l_341 < 17); l_341 = safe_sub_func_uint8_t_u_u(l_341, 4))
                { /* block id: 151 */
                    uint32_t l_356 = 9U;
                    int32_t *l_360 = &g_13;
                    for (p_27.f1 = 0; (p_27.f1 != 14); p_27.f1 = safe_add_func_int8_t_s_s(p_27.f1, 1))
                    { /* block id: 154 */
                        int32_t *l_355[10];
                        int i;
                        for (i = 0; i < 10; i = i + 1)
                            l_355[i] = &g_12[0][4][2];
                        (*l_325) = l_355[4];
                        /* statement id: 155 */
                        assert ((g_172 >= &g_12[0][0][0] && g_172 <= &g_12[0][4][4]));
                        (*l_300) = l_356;
                        (*g_94) = &l_321;
                    }
                    for (p_28 = 0; (p_28 <= 3); p_28 += 1)
                    { /* block id: 161 */
                        int i;
                        g_95[p_27.f2] = &g_8;
                        if (p_28)
                            continue;
                        (*l_300) = 5;
                        (*l_322) = (p_27.f2 ^ 9);
                    }
                    l_357 = (void*)0;
                    /* statement id: 167 */
                    assert (l_357 == 0);
                    for (g_13 = 0; (g_13 <= 3); g_13 += 1)
                    { /* block id: 170 */
                        int i;
                        (*l_322) = (g_13 == (safe_rshift_func_uint16_t_u_s(((void*)0 == l_360), ((0x48C0 != (g_42.f0 != g_13)) & (safe_mul_func_uint8_t_u_u(((0x48113C84 || (safe_mul_func_int8_t_s_s(1, ((-1) >= g_5)))) >= 0xD46E), (-10)))))));
                        (*l_322) = ((&l_340 == l_365) && g_2);
                        (*l_322) = p_27.f1;
                    }
                }
            }
            /* facts after for loop */
            assert (l_357 == 0 || l_357 == &g_274);
        }
    }
    /* facts after for loop */
    //assert (g_95[0] == &l_321 || g_95[0] == &g_8 || g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
    assert ((g_172 >= &g_12[0][0][0] && g_172 <= &g_12[0][4][4]) || g_172 == 0 || g_172 == &g_13);
    //assert (g_209 == 0 || g_209 == dangling || (g_209 >= &g_210[0][0][0] && g_209 <= &g_210[7][3][3]));
    if (p_29.f0)
    { /* block id: 179 */
        uint16_t l_375 = 0x5C44;
        int32_t ** const **l_380 = (void*)0;
        const int32_t l_387 = (-1);
        int32_t l_389 = 0x332CBFD5;
        int16_t l_413 = 0xA6DE;
        if ((safe_add_func_uint16_t_u_u((safe_div_func_int8_t_s_s((((safe_add_func_uint16_t_u_u(p_29.f1, (safe_div_func_int16_t_s_s((&g_210[0][0][2] == (void*)0), l_375)))) && l_375) != (safe_div_func_int16_t_s_s(l_375, (safe_add_func_uint8_t_u_u((l_380 != l_380), ((safe_lshift_func_int16_t_s_s((safe_add_func_int32_t_s_s((((safe_add_func_uint32_t_u_u((0xB7 <= g_5), p_29.f1)) != g_275.f0) || g_275.f2), 5U)), g_2)) & l_387)))))), 0x9E)), 65526U)))
        { /* block id: 180 */
            struct S0 **l_388 = &g_210[1][2][1];
            (*l_388) = &p_29;
            /* statement id: 181 */
            //assert (g_210[0][0][0] == &p_29 || g_210[0][0][0] == 0 || g_210[0][0][0] == &g_42);
        }
        else
        { /* block id: 182 */
            l_389 = p_28;
        }
        /* facts after branching */
        //assert (g_210[0][0][0] == &p_29 || g_210[0][0][0] == 0 || g_210[0][0][0] == &g_42);
        l_389 = p_29.f1;
        for (p_29.f1 = 0; (p_29.f1 >= (-15)); p_29.f1 = safe_sub_func_int8_t_s_s(p_29.f1, 1))
        { /* block id: 188 */
            int32_t l_393 = (-5);
            struct S0 *l_401 = &g_275;
            struct S0 *l_402[5][6][5] = {{{&g_275,&g_42,&g_275,&g_275,&g_42},{&g_42,&g_275,&g_42,&g_42,&g_42},{&g_275,&g_42,&g_275,(void*)0,&g_42},{&g_275,(void*)0,&g_42,&g_275,&g_275},{&g_275,&g_275,&g_275,&g_275,&g_42},{&g_42,&g_275,&g_275,&g_42,&g_275}},{{&g_275,&g_275,&g_42,&g_275,&g_42},{&g_42,(void*)0,&g_42,&g_275,&g_275},{(void*)0,&g_275,&g_42,&g_42,&g_275},{(void*)0,&g_42,&g_275,&g_42,&g_42},{&g_42,&g_42,(void*)0,&g_275,&g_275},{&g_42,&g_275,&g_275,&g_42,(void*)0}},{{&g_42,(void*)0,&g_42,&g_42,(void*)0},{&g_42,&g_275,(void*)0,&g_42,&g_42},{(void*)0,&g_275,(void*)0,&g_42,&g_275},{&g_42,&g_275,&g_275,(void*)0,(void*)0},{&g_42,(void*)0,&g_42,&g_42,&g_42},{&g_275,&g_42,&g_275,(void*)0,&g_275}},{{&g_42,&g_275,(void*)0,&g_275,&g_275},{&g_275,&g_42,(void*)0,&g_275,&g_42},{&g_275,&g_275,&g_42,&g_42,&g_42},{(void*)0,&g_42,&g_275,&g_275,&g_42},{&g_275,&g_275,(void*)0,&g_275,&g_42},{(void*)0,(void*)0,&g_275,&g_275,&g_275}},{{&g_42,(void*)0,&g_42,&g_275,&g_42},{&g_275,&g_42,&g_42,&g_42,&g_275},{&g_275,(void*)0,&g_42,&g_275,&g_275},{&g_275,&g_275,&g_275,&g_275,&g_275},{&g_42,(void*)0,&g_275,(void*)0,&g_275},{&g_42,&g_42,&g_42,&g_42,(void*)0}}};
            int32_t * const * const l_412 = &g_95[1];
            int i, j, k;
            (*g_274) = func_54(((((!l_393) ^ (g_5 == g_12[0][1][0])) == (safe_mul_func_int8_t_s_s((p_27.f1 >= (p_27.f1 < (0 >= g_8))), ((g_42.f1 && 1U) || g_400)))) < p_27.f1), l_401);
            if (p_27.f0)
                continue;
            l_403 = l_402[3][3][1];
            if (((safe_rshift_func_int16_t_s_s((safe_lshift_func_uint8_t_u_s((((safe_add_func_int8_t_s_s((((safe_rshift_func_uint8_t_u_s(((*l_366) != l_412), 6)) | ((g_13 <= (4294967287U == l_413)) || ((p_27.f2 == (safe_mod_func_uint16_t_u_u(((255U | ((safe_div_func_int16_t_s_s((((safe_mul_func_int8_t_s_s((safe_div_func_int8_t_s_s((safe_div_func_int8_t_s_s((safe_mod_func_int32_t_s_s(p_29.f2, (safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(((safe_add_func_int32_t_s_s((safe_sub_func_uint16_t_u_u(((!((*l_366) != (**g_268))) | p_27.f0), (-2))), p_29.f1)) >= p_29.f0), g_275.f1)), g_42.f2)))), 0x55)), g_2)), g_275.f2)) >= p_27.f1) | p_29.f0), g_13)) || p_27.f2)) < (-6)), p_28))) || p_29.f2))) < 0x98F0), 0x86)) != 0) & p_29.f0), g_275.f1)), p_29.f0)) > p_29.f0))
            { /* block id: 192 */
                int32_t **l_438 = (void*)0;
                int32_t l_451 = (-10);
                for (g_400 = 3; (g_400 < 9); g_400 = safe_add_func_uint16_t_u_u(g_400, 8))
                { /* block id: 195 */
                    int32_t *l_437 = &l_298;
                    struct S0 l_454 = {0xA756,1,0};
                    (*l_437) = 0x836181A7;
                    (*l_437) = (((l_438 == (void*)0) == (((safe_lshift_func_int16_t_s_s((p_29.f2 == ((void*)0 != l_438)), (safe_lshift_func_uint16_t_u_s((l_437 != (void*)0), 3)))) & ((safe_div_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_u(g_12[0][1][0], (*l_437))), l_451)), (*l_437))) | 1)) <= 0x9A)) == 8);
                    for (l_375 = 0; (l_375 > 54); l_375 = safe_add_func_uint8_t_u_u(l_375, 1))
                    { /* block id: 200 */
                        l_455 = l_454;
                        l_389 = (safe_mod_func_uint16_t_u_u((p_29.f0 | p_27.f0), (safe_sub_func_int32_t_s_s(9, ((~p_28) & ((((!((65527U == (safe_sub_func_uint32_t_u_u((safe_mul_func_int16_t_s_s((((void*)0 != (*g_269)) || ((0x664D >= (safe_mod_func_int16_t_s_s(p_27.f0, 65530U))) <= g_5)), 65535U)), g_275.f1))) > 0x2083)) & (*l_437)) <= 1) == g_12[0][1][0]))))));
                    }
                    if (g_470)
                        continue;
                }
            }
            else
            { /* block id: 206 */
                uint32_t l_471 = 0xE7A1AFC6;
                int32_t l_472 = 0x5A9C8A47;
                struct S0 *l_473 = &g_275;
                l_471 = p_29.f2;
                for (l_393 = 0; (l_393 <= 3); l_393 += 1)
                { /* block id: 210 */
                    l_472 = ((**g_268) == (void*)0);
                    for (l_321 = 3; (l_321 >= 0); l_321 -= 1)
                    { /* block id: 214 */
                        return l_473;
                        /* statement id: 215 */
                        //assert (g_95[0] == &g_8 || g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
                        //assert (g_210[0][0][0] == dangling || g_210[0][0][0] == 0 || g_210[0][0][0] == &g_42);
                        //assert (func_25_rv == &g_275);
                    }
                }
            }
        }
        /* facts after for loop */
        assert (l_403 == &g_275 || l_403 == &g_42 || l_403 == 0);
    }
    else
    { /* block id: 220 */
        int32_t *l_474 = &g_13;
        uint16_t l_481 = 0U;
        int32_t ***l_492 = &l_297;
        struct S0 l_498 = {0x0437,0x1E1E,0x96E3C937};
        struct S0 ***l_529 = &g_209;
        uint8_t l_594 = 252U;
        int32_t l_620 = 0xC1C7E0C3;
        struct S0 l_658 = {-1,0x644D,0x8BFD0AA5};
        for (l_455.f0 = 0; (l_455.f0 <= 0); l_455.f0 += 1)
        { /* block id: 223 */
            int16_t l_475[7];
            int i;
            for (i = 0; i < 7; i = i + 1)
                l_475[i] = 0xC061;
            (**g_269) = l_474;
            (*p_30) = (*p_30);
            if (l_475[0])
                continue;
            for (p_29.f2 = 0; (p_29.f2 >= 0); p_29.f2 -= 1)
            { /* block id: 229 */
                (**g_269) = (void*)0;
                for (g_42.f0 = 0; (g_42.f0 <= 0); g_42.f0 += 1)
                { /* block id: 233 */
                    int32_t *l_480[9];
                    int i, j, k;
                    for (i = 0; i < 9; i = i + 1)
                        l_480[i] = &g_12[0][2][0];
                    (*p_30) = (*g_274);
                    g_12[g_42.f0][(g_42.f0 + 2)][(l_455.f0 + 4)] = ((safe_add_func_uint32_t_u_u(((p_29.f1 == g_8) >= ((((void*)0 != &l_403) && 0x9091) ^ (safe_sub_func_int16_t_s_s(0xE952, ((void*)0 != l_480[8]))))), (p_27.f2 && 0))) < l_481);
                }
            }
        }
    }
    /* facts after branching */
    //assert (g_210[0][0][0] == &p_29 || g_210[0][0][0] == 0 || g_210[0][0][0] == &g_42);
    assert (l_403 == &g_275 || l_403 == &g_42 || l_403 == 0);
    (*l_499) = (((*l_365) == (void*)0) | 0x7F);
    return l_661;
    /* statement id: 353 */
    //assert (g_95[0] == &g_8 || g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
    //assert (g_210[0][0][0] == dangling || g_210[0][0][0] == 0 || g_210[0][0][0] == &g_42);
    //assert (func_25_rv == &g_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_95
 */
inline static struct S0 * func_31(uint8_t  p_32, uint16_t  p_33, const uint32_t  p_34)
{ /* block id: 120 */
    int32_t * const l_278 = &g_8;
    int32_t **l_279 = &g_95[3];
    struct S0 *l_280[3][9] = {{&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42},{(void*)0,&g_42,(void*)0,(void*)0,&g_42,(void*)0,(void*)0,&g_42,(void*)0},{&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42}};
    int i, j;
    (*l_279) = l_278;
    return l_280[1][3];
    /* statement id: 122 */
    //assert (func_31_rv == 0 || func_31_rv == &g_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_35(struct S0 * p_36, const struct S0 * p_37, struct S0 * p_38, int16_t  p_39, struct S0 * p_40)
{ /* block id: 118 */
    int32_t l_276 = 0x72D5D3A5;
    return l_276;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_13 g_12 g_8 g_5 g_94 g_95 g_2 g_209 g_268
 * writes: g_42.f1 g_12 g_42 g_95 g_172 g_209 g_210 g_13
 */
inline static struct S0 * func_43(uint32_t  p_44)
{ /* block id: 11 */
    uint16_t l_63 = 0x6407;
    struct S0 *l_66 = &g_42;
    int32_t *l_67 = &g_13;
    (*l_67) = (safe_add_func_uint32_t_u_u((func_47(func_50(func_54((safe_rshift_func_uint16_t_u_u((safe_mod_func_int8_t_s_s(((safe_lshift_func_uint16_t_u_s(65535U, 7)) > l_63), 0x19)), 13)), &g_42), l_66, (&g_12[0][1][0] == l_67)), (*l_67)) | g_2), 4294967295U));
    /* statement id: 116 */
    //assert (g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
    assert (g_172 == 0 || g_172 == &g_13);
    //assert (g_209 == dangling || (g_209 >= &g_210[0][0][0] && g_209 <= &g_210[7][3][3]));
    return l_66;
    /* statement id: 117 */
    //assert (func_43_rv == &g_42);
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_94 g_2 g_12 g_8 g_95 g_5 g_13 g_209 g_268
 * writes: g_42 g_95 g_12 g_172 g_209 g_210
 */
static uint32_t  func_47(struct S0 * p_48, int32_t  p_49)
{ /* block id: 27 */
    uint32_t l_115[5][8][1] = {{{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U}},{{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U}},{{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U}},{{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U}},{{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U},{4294967293U},{4294967290U}}};
    int32_t *l_162 = (void*)0;
    int32_t l_169[10] = {0x30F596B1,0x30F596B1,7,0xC0673FC9,7,0x30F596B1,0x30F596B1,7,0xC0673FC9,7};
    struct S0 * const l_273 = &g_42;
    int i, j, k;
lbl_173:
    (*p_48) = g_42;
    for (g_42.f0 = 0; (g_42.f0 > (-11)); --g_42.f0)
    { /* block id: 31 */
        int32_t *l_112 = (void*)0;
        int32_t *l_126 = &g_12[0][1][0];
        struct S0 *l_160 = &g_42;
        const int32_t *l_170 = (void*)0;
        (*g_94) = l_112;
        (*l_126) = (!((safe_unary_minus_func_uint32_t_u(((l_115[3][4][0] & (safe_mod_func_uint32_t_u_u((((((safe_add_func_uint32_t_u_u(0x41E781FF, p_49)) ^ (p_49 < p_49)) ^ (p_48 == (void*)0)) ^ p_49) != (safe_mod_func_int8_t_s_s(((safe_mul_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(p_49, g_2)), l_115[3][4][0])) && p_49), (-1)))), l_115[3][4][0]))) >= l_115[4][0][0]))) < p_49));
        if ((safe_lshift_func_uint8_t_u_u(0x0E, (safe_mod_func_int16_t_s_s(p_49, (*l_126))))))
        { /* block id: 34 */
            const uint32_t l_147 = 4294967286U;
            int16_t l_148 = 0xEBEB;
            int32_t *l_155[2];
            int i;
            for (i = 0; i < 2; i = i + 1)
                l_155[i] = &g_13;
            if (((-10) & (safe_sub_func_int8_t_s_s(0x59, ((((safe_div_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((safe_div_func_uint8_t_u_u(((safe_sub_func_int32_t_s_s(p_49, (safe_sub_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((((p_49 > ((p_48 != (void*)0) <= l_147)) == (&g_42 == &g_42)) <= l_147), 0x8B3E)), 7U)))) == l_148), g_2)), 2)), g_8)), g_42.f0)) == 3U) || 0x67F3) < 1)))))
            { /* block id: 35 */
                uint32_t l_168 = 4294967295U;
                uint32_t l_211 = 6U;
                l_126 = (*g_94);
                /* statement id: 36 */
                assert (l_126 == &g_13 || l_126 == 0 || (l_126 >= &g_12[0][0][0] && l_126 <= &g_12[0][4][4]) || (l_126 >= &l_169[0] && l_126 <= &l_169[9]));
                for (g_42.f1 = 0; (g_42.f1 >= 0); g_42.f1 -= 1)
                { /* block id: 39 */
                    const int16_t l_167 = (-1);
                    const int32_t **l_171[6] = {&l_170,&l_170,&l_170,&l_170,&l_170,&l_170};
                    int i;
                    if (((+(p_49 ^ (safe_unary_minus_func_int32_t_s((g_12[0][0][1] == (safe_div_func_uint8_t_u_u(g_42.f2, ((safe_div_func_int16_t_s_s((g_8 || (l_155[0] != (void*)0)), (safe_rshift_func_uint16_t_u_s((0xCFF13109 > ((void*)0 != l_160)), 7)))) ^ g_2)))))))) > g_42.f2))
                    { /* block id: 40 */
                        return p_49;
                        /* statement id: 41 */
                        //assert (g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
                    }
                    else
                    { /* block id: 42 */
                        int8_t l_161 = (-5);
                        l_161 = p_49;
                        (*g_94) = l_162;
                        (*g_94) = l_112;
                    }
                    l_169[5] = (((safe_rshift_func_int16_t_s_u(((g_42.f1 != (g_42.f0 <= p_49)) == (((0x42B0 ^ g_5) & (2 | (((*g_94) == (void*)0) == 0x83))) && p_49)), 5)) ^ l_167) ^ l_168);
                    g_172 = l_170;
                    /* statement id: 48 */
                    assert (g_172 == 0);
                    (*g_94) = &l_169[6];
                    for (l_168 = 0; (l_168 <= 0); l_168 += 1)
                    { /* block id: 52 */
                        if (g_42.f2)
                            goto lbl_173;
                    }
                }
                for (g_42.f2 = (-17); (g_42.f2 != 13); g_42.f2 = safe_add_func_int8_t_s_s(g_42.f2, 5))
                { /* block id: 58 */
                    struct S0 *l_202[7] = {&g_42,&g_42,&g_42,&g_42,&g_42,&g_42,&g_42};
                    int32_t l_204 = 1;
                    int i;
                    for (l_168 = 0; (l_168 > 30); l_168 = safe_add_func_uint32_t_u_u(l_168, 6))
                    { /* block id: 61 */
                        uint16_t l_201[3];
                        int32_t **l_203 = (void*)0;
                        struct S0 ***l_205 = (void*)0;
                        struct S0 ***l_206 = (void*)0;
                        struct S0 **l_208[5];
                        struct S0 ***l_207[3][7] = {{&l_208[4],&l_208[4],&l_208[4],&l_208[4],&l_208[4],&l_208[4],&l_208[4]},{(void*)0,&l_208[4],(void*)0,&l_208[4],(void*)0,&l_208[4],(void*)0},{&l_208[4],&l_208[4],&l_208[4],&l_208[4],&l_208[4],&l_208[4],&l_208[4]}};
                        int i, j;
                        for (i = 0; i < 3; i = i + 1)
                            l_201[i] = 65535U;
                        for (i = 0; i < 5; i = i + 1)
                            l_208[i] = &l_202[0];
                        l_169[5] = (safe_lshift_func_uint16_t_u_s((safe_div_func_int16_t_s_s((6U == (safe_lshift_func_int16_t_s_u(((safe_add_func_int8_t_s_s((safe_sub_func_int32_t_s_s((~((g_13 < (p_49 | p_49)) > (p_48 == p_48))), g_42.f2)), (safe_add_func_uint32_t_u_u(((((safe_lshift_func_uint16_t_u_s(g_13, 2)) || (0x8C2FE74D == p_49)) || (-1)) || p_49), g_12[0][2][2])))) <= 3), 3))), 0xABCA)), g_5));
                        l_204 = (safe_mod_func_uint8_t_u_u(((0x29D4 >= g_12[0][1][0]) <= (safe_div_func_uint32_t_u_u((safe_add_func_int16_t_s_s((0 != (safe_mul_func_int16_t_s_s(((p_49 ^ l_201[0]) | (l_202[2] == &g_42)), ((&l_162 == l_203) && g_12[0][1][3])))), 0U)), 0x4CA82F66))), g_13));
                        g_209 = &p_48;
                        /* statement id: 64 */
                        assert (g_209 == &p_48);
                        return l_211;
                        /* statement id: 65 */
                        //assert (g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
                        //assert (g_209 == dangling);
                    }
                }
                for (l_168 = 0; (l_168 <= 0); l_168 += 1)
                { /* block id: 70 */
                    int32_t ***l_213 = &g_94;
                    int32_t ****l_212 = &l_213;
                    int i;
                    for (p_49 = 0; (p_49 <= 9); p_49 += 1)
                    { /* block id: 73 */
                        int i;
                        return l_169[(l_168 + 8)];
                        /* statement id: 74 */
                        //assert (g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
                    }
                    (*l_212) = &g_94;
                    l_169[(l_168 + 6)] = 0xDF55BC50;
                    for (l_148 = 0; (l_148 <= 0); l_148 += 1)
                    { /* block id: 80 */
                        int i, j, k;
                        (**l_213) = (void*)0;
                        g_12[l_168][(l_148 + 4)][l_168] = (safe_div_func_int8_t_s_s(l_169[(l_148 + 3)], (safe_rshift_func_int16_t_s_u((((g_12[l_168][(l_148 + 4)][(l_148 + 1)] > (safe_mod_func_int8_t_s_s((p_49 == g_42.f0), (safe_mul_func_int32_t_s_s((safe_mul_func_int16_t_s_s(0xFEF3, g_42.f1)), ((void*)0 != (*l_212))))))) ^ 0xFDF3) | p_49), p_49))));
                    }
                }
            }
            else
            { /* block id: 85 */
                uint16_t l_247 = 65531U;
                if ((safe_add_func_int8_t_s_s((safe_mod_func_int8_t_s_s((safe_mul_func_uint8_t_u_u(0x8C, (safe_mul_func_uint8_t_u_u(((safe_rshift_func_uint8_t_u_s((!g_42.f2), 7)) | ((safe_div_func_uint8_t_u_u((((p_49 ^ (safe_add_func_uint16_t_u_u((safe_lshift_func_int8_t_s_s((g_8 | p_49), 7)), ((((safe_lshift_func_int8_t_s_s(p_49, 7)) != (safe_mod_func_int16_t_s_s(((&g_209 == (void*)0) != g_12[0][0][2]), g_42.f2))) > p_49) > 0x77)))) & 0xA7) >= l_247), p_49)) != 0xBD57)), 0xAE)))), 1U)), 1)))
                { /* block id: 86 */
                    if ((safe_lshift_func_int8_t_s_u((0xF947 > p_49), 4)))
                    { /* block id: 87 */
                        (*l_126) = (g_42.f2 > (((0xF5 | l_169[5]) > ((safe_div_func_uint32_t_u_u(l_247, (safe_rshift_func_uint16_t_u_u(g_12[0][1][0], g_13)))) && (g_13 == (g_12[0][1][0] >= p_49)))) | l_247));
                    }
                    else
                    { /* block id: 89 */
                        (*g_94) = l_155[1];
                    }
                    for (g_42.f1 = (-6); (g_42.f1 <= (-24)); g_42.f1--)
                    { /* block id: 94 */
                        struct S0 *l_256 = &g_42;
                        (*g_209) = l_256;
                    }
                    if (p_49)
                        break;
                }
                else
                { /* block id: 98 */
                    const uint16_t l_257[6] = {65526U,65526U,65526U,65526U,65526U,65526U};
                    int32_t ***l_261[2][4];
                    int32_t ****l_260 = &l_261[1][2];
                    int i, j;
                    for (i = 0; i < 2; i = i + 1)
                    {
                        for (j = 0; j < 4; j = j + 1)
                            l_261[i][j] = &g_94;
                    }
                    (*l_126) = (g_2 & (1U == g_12[0][0][3]));
                    if (l_257[4])
                    { /* block id: 100 */
                        (*l_126) = ((p_49 ^ ((g_42.f2 ^ g_2) != p_49)) || ((safe_div_func_uint8_t_u_u((p_49 > (l_260 == (void*)0)), (safe_sub_func_int8_t_s_s(g_2, ((safe_mod_func_int32_t_s_s((&g_95[3] == &l_155[0]), 0x54160E17)) < 0x2F))))) > p_49));
                    }
                    else
                    { /* block id: 102 */
                        if (p_49)
                            break;
                    }
                }
                (*g_94) = l_112;
                if (g_5)
                    goto lbl_173;
            }
            /* facts after branching */
            assert (l_126 == &g_13 || l_126 == 0 || (l_126 >= &g_12[0][0][0] && l_126 <= &g_12[0][4][4]) || (l_126 >= &l_169[0] && l_126 <= &l_169[9]));
            (*g_94) = l_155[1];
        }
        else
        { /* block id: 110 */
            (*l_126) = (0x79 & (((void*)0 != g_268) | ((-5) > (safe_sub_func_uint8_t_u_u((&p_48 == (void*)0), (+0xEAC2))))));
        }
        /* facts after branching */
        assert (l_126 == &g_13 || l_126 == 0 || (l_126 >= &g_12[0][0][0] && l_126 <= &g_12[0][4][4]) || (l_126 >= &l_169[0] && l_126 <= &l_169[9]));
        l_160 = l_273;
    }
    return g_12[0][1][4];
    /* statement id: 115 */
    //assert (g_95[0] == &g_13 || g_95[0] == 0 || (g_95[0] >= &g_12[0][0][0] && g_95[0] <= &g_12[0][4][4]) || g_95[0] == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f1 g_13 g_42.f0 g_12 g_8 g_5 g_94 g_95 g_42.f2
 * writes: g_42.f1 g_12
 */
static struct S0 * func_50(struct S0  p_51, struct S0 * p_52, uint8_t  p_53)
{ /* block id: 15 */
    int32_t *l_79[3][1][1];
    struct S0 *l_100 = &g_42;
    int i, j, k;
    for (i = 0; i < 3; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
        {
            for (k = 0; k < 1; k = k + 1)
                l_79[i][j][k] = &g_8;
        }
    }
    for (g_42.f1 = (-24); (g_42.f1 <= 5); g_42.f1 = safe_add_func_int32_t_s_s(g_42.f1, 1))
    { /* block id: 18 */
        int32_t *l_71 = &g_12[0][4][4];
        int32_t **l_70 = &l_71;
        uint32_t l_78 = 4294967295U;
        (*l_70) = &g_2;
        /* statement id: 19 */
        assert (l_71 == &g_2);
        (*l_70) = (void*)0;
        /* statement id: 20 */
        assert (l_71 == 0);
        g_12[0][1][0] = (safe_mul_func_uint16_t_u_u((safe_add_func_int32_t_s_s((g_13 != (((((safe_mul_func_int16_t_s_s((l_78 < ((void*)0 != l_79[1][0][0])), p_53)) || ((safe_div_func_int8_t_s_s(((safe_div_func_int16_t_s_s((safe_add_func_int16_t_s_s(((safe_lshift_func_int8_t_s_u((safe_div_func_int16_t_s_s(g_42.f0, p_51.f2)), 1)) == (safe_mod_func_int32_t_s_s(0x564F6967, (safe_lshift_func_uint16_t_u_s((p_51.f1 > p_53), 3))))), 0x42BF)), (-1))) ^ g_12[0][1][0]), p_51.f0)) || g_12[0][1][0])) != (-1)) | 0x9351) > 0xD4)), g_8)), g_42.f1));
    }
    (**g_94) = (g_5 & (((&l_79[1][0][0] != g_94) > (safe_mod_func_uint16_t_u_u((p_51.f2 > (safe_div_func_uint8_t_u_u((&p_51 == l_100), (((*g_94) != l_79[2][0][0]) || g_42.f0)))), g_12[0][1][0]))) && p_53));
    (**g_94) = p_53;
    (**g_94) = (safe_div_func_uint8_t_u_u((safe_add_func_int32_t_s_s(p_51.f0, ((safe_mod_func_uint32_t_u_u((0x7B >= (((((&l_79[2][0][0] != (void*)0) && g_42.f2) <= ((~p_51.f2) < (0xC482A8E6 | p_51.f0))) != ((((safe_lshift_func_int16_t_s_u(1, 6)) == p_51.f0) || 9) > 0x29)) == 1)), g_42.f1)) > 0xB2A1))), p_53));
    return l_100;
    /* statement id: 26 */
    //assert (func_50_rv == &g_42);
}


/* ------------------------------------------ */
/* 
 * reads : g_42
 * writes:
 */
inline static struct S0  func_54(uint32_t  p_55, struct S0 * p_56)
{ /* block id: 12 */
    int32_t *l_65 = &g_13;
    int32_t **l_64 = &l_65;
    (*l_64) = &g_8;
    /* statement id: 13 */
    assert (l_65 == &g_8);
    return g_42;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_8, "g_8", print_hash_value);
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 5; j = j + 1)
        {
            for (k = 0; k < 5; k = k + 1)
            {
                transparent_crc(g_12[i][j][k], "g_12[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_13, "g_13", print_hash_value);
    transparent_crc(g_42.f0, "g_42.f0", print_hash_value);
    transparent_crc(g_42.f1, "g_42.f1", print_hash_value);
    transparent_crc(g_42.f2, "g_42.f2", print_hash_value);
    transparent_crc(g_275.f0, "g_275.f0", print_hash_value);
    transparent_crc(g_275.f1, "g_275.f1", print_hash_value);
    transparent_crc(g_275.f2, "g_275.f2", print_hash_value);
    transparent_crc(g_400, "g_400", print_hash_value);
    transparent_crc(g_470, "g_470", print_hash_value);
    for (i = 0; i < 10; i = i + 1)
    {
        transparent_crc(g_663[i].f0, "g_663[i].f0", print_hash_value);
        transparent_crc(g_663[i].f1, "g_663[i].f1", print_hash_value);
        transparent_crc(g_663[i].f2, "g_663[i].f2", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_1008, "g_1008", print_hash_value);
    transparent_crc(g_1025, "g_1025", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 212
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 215
   depth: 2, occurrence: 46
   depth: 3, occurrence: 7
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 4
   depth: 12, occurrence: 2
   depth: 13, occurrence: 4
   depth: 14, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 4
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 28, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 172

XXX times a variable address is taken: 449
XXX times a pointer is dereferenced on RHS: 130
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 18
   depth: 3, occurrence: 19
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 145
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 26
   depth: 3, occurrence: 14
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 61
XXX times a pointer is compared with address of another variable: 22
XXX times a pointer is compared with another pointer: 17
XXX times a pointer is qualified to be dereferenced: 1159

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 397
   level: 2, occurrence: 171
   level: 3, occurrence: 115
   level: 4, occurrence: 55
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 71
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 48
XXX percent of pointers has null in alias set: 31.4
XXX average alias set size: 1.52

XXX times a non-volatile is read: 1121
XXX times a non-volatile is write: 465
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 7

XXX stmts: 194
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 28
   depth: 2, occurrence: 22
   depth: 3, occurrence: 28
   depth: 4, occurrence: 38
   depth: 5, occurrence: 50

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
********************* end of statistics **********************/

