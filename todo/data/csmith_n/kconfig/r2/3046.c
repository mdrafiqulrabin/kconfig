/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      626932792
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 10;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_1(void);
inline static int32_t * func_2(int8_t  p_3);
inline static struct S0  func_5(int32_t * p_6, int32_t * p_7);
static int32_t  func_10(int32_t  p_11, const uint16_t  p_12, int32_t  p_13, int32_t  p_14, uint32_t  p_15);
inline static int32_t  func_26(float  p_27, int32_t * const  p_28, int32_t * p_29);
static float  func_31(int32_t * p_32, int8_t  p_33, uint8_t  p_34);
inline static int32_t * func_35(int16_t  p_36, int32_t * p_37, int32_t * p_38, uint32_t  p_39);
static int32_t * func_41(uint8_t  p_42, int8_t  p_43, uint32_t  p_44, int16_t  p_45);
static int32_t * func_46(uint64_t  p_47, int8_t  p_48, int8_t  p_49, int32_t * p_50, int32_t * p_51);
static int64_t  func_59(int16_t  p_60, int32_t * p_61, int32_t * p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_1(void)
{ /* block id: 0 */
    int16_t l_4 = (-1L);
    int32_t **l_794 = (void*)0;
    int32_t l_797 = 1L;
    int32_t *l_796[4];
    int32_t **l_795 = &l_796[3];
    uint16_t l_798 = 0x1AFFL;
    int i;
    for (i = 0; i < 4; i++)
        l_796[i] = &l_797;
    (*l_795) = func_2(l_4);
    /* statement id: 361 */
    //assert (l_796[0] == 0 || l_796[0] == &l_797);
    return l_798;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_2(int8_t  p_3)
{ /* block id: 1 */
    int32_t l_9 = 2L;
    int32_t *l_8 = &l_9;
    struct S0 l_788[9][8][3] = {{{{0},{-21},{8}},{{3},{17},{22}},{{0},{-2},{-4}},{{-28},{17},{17}},{{-5},{26},{-17}},{{16},{13},{-12}},{{-4},{10},{-18}},{{0},{-21},{11}}},{{{22},{-18},{-6}},{{-15},{27},{26}},{{-12},{18},{-21}},{{-27},{-28},{-28}},{{-6},{-3},{-19}},{{5},{11},{-3}},{{-3},{2},{-8}},{{27},{22},{-11}}},{{{18},{-6},{15}},{{-15},{3},{-4}},{{-8},{14},{17}},{{-15},{5},{-12}},{{-21},{-29},{-4}},{{16},{24},{-11}},{{-16},{-3},{22}},{{-27},{17},{19}}},{{{-29},{27},{-5}},{{19},{-11},{3}},{{10},{10},{6}},{{22},{15},{10}},{{0},{-7},{-2}},{{24},{5},{24}},{{-8},{0},{-2}},{{3},{-24},{10}}},{{{8},{-4},{6}},{{3},{-27},{3}},{{13},{1},{-5}},{{-12},{-28},{19}},{{15},{-9},{22}},{{-21},{13},{-11}},{{16},{-17},{-4}},{{26},{-11},{-12}}},{{{17},{-16},{17}},{{17},{-3},{-4}},{{-4},{2},{15}},{{-28},{-15},{-11}},{{3},{-29},{-18}},{{-28},{10},{18}},{{-4},{22},{-29}},{{17},{-15},{5}}},{{{17},{8},{0}},{{26},{-31},{25}},{{16},{-19},{-12}},{{-21},{25},{3}},{{15},{-8},{-3}},{{-12},{16},{-15}},{{13},{-4},{-4}},{{3},{3},{5}}},{{{8},{-12},{-4}},{{3},{11},{26}},{{-8},{-8},{1}},{{24},{11},{27}},{{0},{-12},{-3}},{{22},{3},{5}},{{10},{-4},{-21}},{{19},{16},{-3}}},{{{-29},{-8},{8}},{{-27},{25},{-6}},{{-16},{-19},{-21}},{{16},{-31},{-21}},{{-21},{8},{14}},{{-15},{-15},{0}},{{-8},{22},{-7}},{{-15},{10},{26}}}};
    struct S0 *l_787 = &l_788[1][6][0];
    int32_t *l_789[7][1] = {{&l_9},{&l_9},{&l_9},{&l_9},{&l_9},{&l_9},{&l_9}};
    int32_t *l_790 = &l_9;
    int32_t *l_791 = &l_9;
    int32_t *l_792 = &l_9;
    int32_t *l_793 = (void*)0;
    int i, j, k;
    (*l_787) = func_5(l_8, &l_9);
    return l_793;
    /* statement id: 360 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_5(int32_t * p_6, int32_t * p_7)
{ /* block id: 2 */
    uint8_t l_25 = 0xB6L;
    uint32_t l_168 = 1UL;
    int32_t *l_669 = (void*)0;
    float * const l_685[3] = {(void*)0,(void*)0,(void*)0};
    float * const *l_684[2];
    const struct S0 l_705 = {-0};
    struct S0 *l_729 = (void*)0;
    struct S0 **l_728 = &l_729;
    struct S0 ***l_727 = &l_728;
    uint32_t l_756 = 0xE7B11EB4L;
    int i;
    for (i = 0; i < 2; i++)
        l_684[i] = &l_685[1];
    if ((*p_7))
    { /* block id: 3 */
        int32_t l_16 = 0L;
        const int32_t *l_30 = (void*)0;
        int32_t *l_40 = (void*)0;
        float l_582 = 0x1.Bp-1;
        float *l_701[5][1] = {{&l_582},{&l_582},{&l_582},{&l_582},{&l_582}};
        float **l_700 = &l_701[2][0];
        float ***l_699 = &l_700;
        struct S0 l_744 = {0};
        struct S0 *l_743 = &l_744;
        int i, j;
        if (func_10(l_16, (safe_div_func_int8_t_s_s((l_16 & (0x6DE0L || ((safe_rshift_func_int8_t_s_u((safe_rshift_func_int8_t_s_u(l_25, 7)), (func_26(((p_7 == l_30) >= func_31(func_35(l_25, l_40, func_41(l_25, l_25, l_25, l_25), l_168), l_168, l_168)), p_7, p_7) <= 1L))) < l_25))), l_168)), l_25, l_168, l_25))
        { /* block id: 293 */
            struct S0 l_657 = {2};
            struct S0 *l_658 = &l_657;
            int32_t **l_659 = &l_40;
            int32_t l_666 = 8L;
            (*l_658) = l_657;
            (*l_659) = p_6;
            /* statement id: 295 */
            //assert (l_40 == &l_9);
            l_669 = func_35((**l_659), func_41(l_25, (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((safe_sub_func_int8_t_s_s(l_666, (l_168 & 1L))), 15)), 1UL)), (((**l_659) & (safe_add_func_int8_t_s_s(((*p_7) > ((void*)0 == l_669)), (**l_659)))) >= (*l_40)), (**l_659)), l_40, (**l_659));
        }
        else
        { /* block id: 297 */
            int32_t l_670 = 0x7D29C3FCL;
            struct S0 ** const **l_671 = (void*)0;
            int32_t **l_672[7] = {&l_669,&l_669,&l_669,&l_669,&l_669,&l_669,&l_669};
            uint16_t l_736 = 0xF82BL;
            struct S0 l_745 = {18};
            struct S0 *l_750 = &l_744;
            int i;
lbl_755:
            l_30 = func_46((p_7 == (void*)0), l_670, l_670, l_669, func_35(l_670, p_6, l_669, ((void*)0 == l_671)));
            (*p_7) = (l_671 == l_671);
            if ((safe_sub_func_int64_t_s_s((0x74DED6C0L <= ((((safe_rshift_func_int8_t_s_s(l_168, 3)) > (safe_sub_func_int64_t_s_s(1L, 0x97FB50E5571A8812LL))) && l_25) && (safe_rshift_func_int16_t_s_u(((safe_unary_minus_func_uint64_t_u((safe_lshift_func_int16_t_s_s(l_25, 7)))) || l_16), 3)))), (l_684[0] == (void*)0))))
            { /* block id: 300 */
                const uint32_t l_688 = 0x61CE6064L;
                struct S0 l_698[4] = {{7},{7},{7},{7}};
                struct S0 *l_697 = &l_698[1];
                struct S0 **l_696 = &l_697;
                struct S0 ***l_695 = &l_696;
                int i;
                (**l_700) = (safe_sub_func_float_f_f((0x1.9p+1 >= (l_688 < 0xC.5998A3p+70)), (safe_add_func_float_f_f(0x1.FD84C8p+74, (((((safe_sub_func_float_f_f((safe_div_func_float_f_f((l_695 != (void*)0), ((void*)0 == l_699))), l_168)) <= (-0x2.Ep+1)) <= l_698[1].f0) > l_688) >= l_688)))));
            }
            else
            { /* block id: 302 */
                int64_t l_714 = 2L;
                struct S0 l_738 = {26};
                struct S0 *l_737 = &l_738;
                uint32_t l_757 = 0xF2F694AFL;
                for (l_168 = 15; (l_168 <= 43); ++l_168)
                { /* block id: 305 */
                    int32_t *l_704 = (void*)0;
                    int32_t l_712[8][10][3] = {{{1L,4L,2L},{(-8L),8L,0x97F7B770L},{0x0187AFE2L,1L,0xF5656533L},{(-2L),8L,0xACB66924L},{0L,1L,0xA0F1B8DFL},{(-2L),8L,0xF600FB38L},{0xE49D3782L,4L,3L},{0xEEC9DEA1L,(-8L),0x4826449BL},{1L,0x869FFA67L,(-1L)},{8L,0xD2F16D19L,8L}},{{1L,(-1L),0xE49D3782L},{0x4D520168L,(-1L),(-1L)},{0x9DCFF2DCL,7L,0x0187AFE2L},{1L,0x357E33C8L,0L},{0x9DCFF2DCL,0xA2468CEDL,(-1L)},{0x4D520168L,(-1L),8L},{1L,0x8DB680B1L,(-1L)},{8L,0xACB66924L,0L},{1L,0x0187AFE2L,0x869FFA67L},{0xEEC9DEA1L,0xEEC9DEA1L,1L}},{{0xE49D3782L,0xA9F45EB3L,1L},{(-2L),0L,9L},{0L,1L,4L},{(-2L),(-2L),9L},{0x0187AFE2L,0xCDD2C072L,1L},{(-8L),(-1L),1L},{1L,0xEC47AA6BL,0x869FFA67L},{9L,(-1L),0L},{1L,(-1L),(-1L)},{0x70ECD12DL,0xB27D3302L,8L}},{{(-1L),3L,(-1L)},{0xACB66924L,(-2L),0L},{1L,2L,0x0187AFE2L},{0x31852832L,(-2L),(-1L)},{7L,3L,0xE49D3782L},{0xF600FB38L,0xB27D3302L,8L},{0x8DB680B1L,(-1L),(-1L)},{0x357E33C8L,(-1L),0x4826449BL},{3L,0xEC47AA6BL,3L},{1L,(-1L),0xF600FB38L}},{{0x69807B1AL,0xCDD2C072L,0xA0F1B8DFL},{1L,(-2L),0xACB66924L},{0x48ECBAB5L,1L,0xF5656533L},{1L,0L,0x97F7B770L},{0x69807B1AL,0xA9F45EB3L,2L},{1L,0xEEC9DEA1L,(-8L)},{3L,0x0187AFE2L,0xA2468CEDL},{0x357E33C8L,0xACB66924L,(-1L)},{0x8DB680B1L,0x8DB680B1L,0x9DCFF2DCL},{0xF600FB38L,(-1L),0x357E33C8L}},{{7L,0xA2468CEDL,1L},{0x31852832L,0x357E33C8L,0xB27D3302L},{1L,7L,1L},{0xACB66924L,(-1L),0x357E33C8L},{(-1L),(-1L),0x9DCFF2DCL},{0x70ECD12DL,0xD2F16D19L,(-1L)},{1L,0x869FFA67L,0xA2468CEDL},{9L,(-8L),(-8L)},{1L,4L,2L},{(-8L),8L,0x97F7B770L}},{{0x0187AFE2L,1L,0xF5656533L},{(-2L),8L,1L},{0xCDD2C072L,0x869FFA67L,4L},{1L,(-1L),0L},{0xF5656533L,3L,0xA9F45EB3L},{0x138B0861L,0x31852832L,1L},{0xE49D3782L,(-1L),1L},{(-1L),0x4826449BL,(-1L)},{0x69807B1AL,(-1L),0xF5656533L},{(-8L),(-2L),0xB27D3302L}},{{1L,0x9DCFF2DCL,0x48ECBAB5L},{0x70ECD12DL,0xF600FB38L,1L},{1L,2L,1L},{(-8L),(-2L),0xEEC9DEA1L},{0x69807B1AL,0x1E7BE736L,0L},{(-1L),1L,8L},{0xE49D3782L,0x48ECBAB5L,(-1L)},{0x138B0861L,0x138B0861L,0x357E33C8L},{0xF5656533L,7L,0xE49D3782L},{1L,8L,0L}}};
                    struct S0 *l_713 = (void*)0;
                    int i, j, k;
                    for (l_16 = 1; (l_16 >= 0); l_16 -= 1)
                    { /* block id: 308 */
                        struct S0 l_707 = {-25};
                        struct S0 *l_706 = &l_707;
                        uint32_t l_719 = 18446744073709551613UL;
                        l_704 = l_669;
                        (*l_706) = l_705;
                        (*p_6) = ((safe_div_func_uint64_t_u_u(((safe_add_func_int64_t_s_s((l_707.f0 < (l_712[0][2][1] & (((l_713 != (void*)0) <= l_714) < l_25))), (safe_lshift_func_uint16_t_u_u(l_707.f0, (safe_rshift_func_int8_t_s_u(0xEEL, 6)))))) ^ 6UL), l_719)) | 0x963AL);
                    }
                    /* facts after for loop */
                    //assert (l_704 == &l_9 || l_704 == 0);
                }
                l_669 = func_35((((void*)0 != l_701[2][0]) <= (*p_6)), p_6, l_701[0][0], (l_168 >= (255UL || l_714)));
                /* statement id: 314 */
                //assert (l_669 == &l_9);
                if ((*p_7))
                { /* block id: 315 */
                    uint32_t l_723 = 4294967295UL;
                    struct S0 ***l_726 = (void*)0;
                    (*l_669) = (safe_unary_minus_func_int32_t_s(((*l_669) != ((safe_add_func_uint64_t_u_u(l_723, (safe_add_func_uint32_t_u_u(((*l_669) | (((l_726 != l_727) || (safe_add_func_uint8_t_u_u((safe_div_func_int16_t_s_s((0UL != (((*p_7) | ((safe_lshift_func_int16_t_s_u(((*l_669) < (*l_669)), (*l_669))) && l_723)) == l_714)), l_714)), 0x86L))) && 0xC978B894L)), (*p_6))))) > l_736))));
                }
                else
                { /* block id: 317 */
                    float l_741 = (-0x2.Dp-1);
                    struct S0 *l_742 = &l_738;
                    int32_t l_749 = 6L;
                    (*l_728) = l_737;
                    /* statement id: 318 */
                    assert (l_729 == &l_738);
                    if (l_16)
                        goto lbl_746;
                    (***l_727) = (*l_729);
                    if (((safe_rshift_func_uint16_t_u_u((*l_669), 11)) && (0x9DE2L < (((*l_669) < (*p_7)) > l_714))))
                    { /* block id: 320 */
                        (*l_669) = (l_742 != (void*)0);
                        (*l_728) = l_743;
                        /* statement id: 322 */
                        assert (l_729 == &l_744);
                        (*l_743) = (***l_727);
                    }
                    else
                    { /* block id: 324 */
                        return l_745;
                    }
                    /* facts after branching */
                    assert (l_729 == &l_744);
                    if ((*p_7))
                    { /* block id: 327 */
lbl_746:
                        (*l_743) = (*l_743);
                        p_7 = func_35(((!(+0x9E44E889L)) <= l_749), p_6, p_6, l_749);
                        (**l_728) = l_745;
                    }
                    else
                    { /* block id: 332 */
                        l_750 = (*l_728);
                    }
                    /* facts after branching */
                    assert (l_729 == &l_738 || l_729 == &l_744);
                }
                /* facts after branching */
                //assert (l_729 == &l_738 || l_729 == &l_744 || l_729 == dangling || l_729 == 0);
                for (l_168 = 3; (l_168 >= 13); ++l_168)
                { /* block id: 338 */
                    float **l_766 = &l_701[1][0];
                    struct S0 ***l_769 = &l_728;
                    if ((*p_7))
                        break;
                    for (l_25 = 0; (l_25 <= 18); l_25 = safe_add_func_uint8_t_u_u(l_25, 2))
                    { /* block id: 342 */
                        if (l_705.f0)
                            goto lbl_755;
                        //assert (l_729 == &l_744 || l_729 == dangling || l_729 == 0);
                        if (l_714)
                            continue;
                        l_756 = (*p_6);
                        (***l_699) = l_757;
                    }
                    if ((*p_6))
                        continue;
                    (*p_6) = (18446744073709551615UL != (safe_rshift_func_int16_t_s_u((safe_lshift_func_int8_t_s_s((safe_div_func_int16_t_s_s(((safe_div_func_int32_t_s_s(((*l_669) | ((-1L) ^ ((&l_685[0] != l_766) && ((*l_669) >= (safe_div_func_int8_t_s_s(((l_769 == (void*)0) <= (0x32866B4AD9BC32F8LL && (-1L))), l_738.f0)))))), l_738.f0)) != l_738.f0), l_757)), l_738.f0)), l_714)));
                }
            }
        }
        /* facts after branching */
        //assert (l_30 == &l_9 || l_30 == 0);
        //assert (l_40 == 0 || l_40 == &l_9);
        //assert (l_669 == &l_9 || l_669 == 0);
        //assert (l_729 == dangling || l_729 == &l_744 || l_729 == 0);
        (*l_743) = (*l_743);
    }
    else
    { /* block id: 354 */
        int32_t l_771 = 0x5FD14493L;
        int32_t *l_770 = &l_771;
        int32_t **l_772 = (void*)0;
        int32_t **l_773 = &l_669;
        float * const **l_777 = &l_684[0];
        float * const ** const *l_776 = &l_777;
        struct S0 ***l_779 = &l_728;
        uint8_t l_786[6][6][7] = {{{1UL,0x89L,8UL,1UL,0x19L,7UL,0xF4L},{255UL,255UL,0x89L,254UL,0xF4L,255UL,255UL},{255UL,0xF4L,1UL,1UL,1UL,0x76L,1UL},{0xAEL,255UL,7UL,1UL,8UL,0xC7L,0x98L},{253UL,0xA0L,254UL,254UL,0xA0L,253UL,255UL},{5UL,1UL,0x36L,1UL,0x37L,1UL,1UL}},{{1UL,255UL,253UL,6UL,8UL,255UL,1UL},{255UL,1UL,0x1FL,8UL,0x44L,255UL,0x89L},{0xAEL,0xA0L,1UL,1UL,1UL,1UL,0x37L},{0xF4L,255UL,254UL,0xA3L,0x19L,0x89L,0x37L},{0xC7L,0xF4L,0x89L,0x23L,0x37L,0x23L,0x89L},{255UL,255UL,0x36L,0xAEL,1UL,0x76L,1UL}},{{0x44L,0x89L,246UL,1UL,255UL,255UL,1UL},{0xC7L,0xA0L,0x23L,8UL,1UL,0xC7L,255UL},{1UL,0x98L,1UL,0xA3L,0x37L,0x36L,0x98L},{5UL,0x89L,253UL,5UL,0x19L,0x23L,1UL},{255UL,0x44L,253UL,254UL,1UL,255UL,255UL},{0x44L,1UL,1UL,1UL,0x44L,0x76L,0xF4L}},{{1UL,255UL,0x23L,0xF4L,8UL,7UL,0x37L},{253UL,0x37L,246UL,0UL,255UL,0x59L,0x76L},{0x1FL,0xC7L,1UL,246UL,255UL,0xA3L,0x23L},{0x89L,0x36L,1UL,255UL,0x59L,0UL,0x89L},{0UL,0x23L,0UL,0x59L,8UL,0UL,1UL},{254UL,255UL,0xA3L,0xC7L,0xC7L,0xA3L,255UL}},{{0x23L,0x76L,1UL,0x19L,0xDBL,0x59L,255UL},{1UL,7UL,0x1EL,3UL,255UL,1UL,1UL},{0x89L,8UL,1UL,0x19L,7UL,0xF4L,253UL},{253UL,1UL,0UL,0xC7L,1UL,0x36L,0xC7L},{1UL,255UL,1UL,0x59L,0xC7L,3UL,0x76L},{0xC7L,255UL,0x37L,255UL,255UL,1UL,255UL}},{{246UL,1UL,1UL,246UL,0xDBL,1UL,7UL},{0UL,8UL,0x59L,0UL,0x23L,0UL,0x36L},{8UL,7UL,0x37L,0xC7L,253UL,0xF4L,7UL},{254UL,0x76L,1UL,0x23L,0x59L,3UL,255UL},{0x1EL,255UL,1UL,0UL,255UL,1UL,0x76L},{246UL,0x23L,1UL,254UL,255UL,0xA3L,0xC7L}}};
        int i, j, k;
        (*l_773) = l_770;
        /* statement id: 355 */
        assert (l_669 == &l_771);
        (*l_770) = (safe_add_func_int32_t_s_s((((((void*)0 == l_776) < (((!(**l_773)) | (l_779 == &l_728)) & (((((void*)0 == &p_6) || 1UL) <= ((safe_lshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((safe_div_func_int8_t_s_s((((-1L) < (**l_773)) > l_786[1][5][0]), 0xD5L)), (*l_669))), 11)) ^ (*l_669))) || (*l_669)))) && (*l_669)) > (*l_770)), (*p_7)));
    }
    /* facts after branching */
    //assert (l_669 == dangling || l_669 == &l_9 || l_669 == 0);
    //assert (l_729 == dangling || l_729 == 0);
    return l_705;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_10(int32_t  p_11, const uint16_t  p_12, int32_t  p_13, int32_t  p_14, uint32_t  p_15)
{ /* block id: 278 */
    const int32_t *l_590 = (void*)0;
    const int32_t ** const l_589 = &l_590;
    int32_t l_614 = 0x256860EBL;
    int32_t l_615 = 0xD0DC4584L;
    struct S0 l_655 = {0};
    struct S0 *l_654 = &l_655;
    struct S0 **l_653 = &l_654;
    struct S0 ***l_652 = &l_653;
    struct S0 ****l_651 = &l_652;
    if ((safe_div_func_uint64_t_u_u((((safe_add_func_uint32_t_u_u((safe_sub_func_int64_t_s_s(((void*)0 == l_589), (safe_rshift_func_uint16_t_u_s((safe_div_func_uint64_t_u_u(3UL, (safe_add_func_uint8_t_u_u(p_14, (safe_sub_func_int64_t_s_s((safe_lshift_func_int8_t_s_s((p_12 | (safe_add_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(((p_14 <= ((((safe_mod_func_int64_t_s_s((p_13 <= (safe_unary_minus_func_int32_t_s((((safe_rshift_func_uint8_t_u_s((0xA96BA776L >= (((safe_lshift_func_int8_t_s_s((safe_rshift_func_int16_t_s_s((-8L), 1)), p_15)) <= (-6L)) == l_614)), p_15)) && p_14) >= p_15)))), p_13)) > p_15) & p_14) < (-8L))) & p_15), 0)) | 0x11FAL), p_15))), 5)), p_15)))))), 7)))), 0x79325D41L)) | 0x2DL) && l_615), 0x3C08E044B3EEE854LL)))
    { /* block id: 279 */
        int32_t l_633 = 0xE4074CCCL;
        int32_t *l_649[8][6] = {{&l_614,&l_614,(void*)0,&l_614,(void*)0,&l_614},{(void*)0,&l_614,&l_614,&l_614,&l_614,(void*)0},{&l_614,(void*)0,&l_614,(void*)0,&l_614,&l_614},{&l_614,(void*)0,(void*)0,&l_614,&l_614,&l_614},{&l_614,&l_614,&l_614,(void*)0,(void*)0,&l_614},{&l_614,&l_614,(void*)0,&l_614,(void*)0,&l_614},{(void*)0,&l_614,&l_614,&l_614,&l_614,(void*)0},{&l_614,(void*)0,&l_614,(void*)0,&l_614,&l_614}};
        int i, j;
        for (p_14 = (-3); (p_14 != (-25)); p_14--)
        { /* block id: 282 */
            int32_t l_618[5];
            int i;
            for (i = 0; i < 5; i++)
                l_618[i] = (-1L);
            (*l_589) = func_41(p_11, l_618[2], p_15, (safe_mod_func_int16_t_s_s(((p_13 & 1L) != 0x8C08L), p_11)));
            /* statement id: 283 */
            assert (l_590 == 0);
            (*l_589) = &l_618[2];
            /* statement id: 284 */
            assert ((l_590 >= &l_618[0] && l_590 <= &l_618[4]));
        }
        /* facts after for loop */
        //assert (l_590 == dangling || l_590 == 0);
    }
    else
    { /* block id: 286 */
        struct S0 **** const l_650 = (void*)0;
        int32_t *l_656 = &l_614;
        (*l_589) = (void*)0;
        l_651 = l_650;
        /* statement id: 288 */
        assert (l_651 == 0);
        (*l_656) = p_13;
        return p_15;
    }
    /* facts after branching */
    //assert (l_590 == dangling || l_590 == 0);
    return p_15;
}


/* ------------------------------------------ */
/* 
 * reads : l_9
 * writes: l_9
 */
inline static int32_t  func_26(float  p_27, int32_t * const  p_28, int32_t * p_29)
{ /* block id: 164 */
    struct S0 l_361 = {-9};
    struct S0 *l_362 = (void*)0;
    struct S0 *l_363 = &l_361;
    int32_t l_364 = (-1L);
    uint8_t l_367[7][10] = {{248UL,2UL,0x7BL,0x7BL,2UL,248UL,2UL,0x64L,0xCEL,0x64L},{0xE2L,0x7BL,0xCEL,0xDAL,0xCEL,0x7BL,0xE2L,2UL,1UL,1UL},{0xE2L,1UL,248UL,1UL,1UL,248UL,1UL,253UL,0x7BL,1UL},{1UL,0xCEL,253UL,0x7BL,1UL,0x7BL,253UL,0xCEL,1UL,2UL},{248UL,0x64L,253UL,1UL,0xCEL,0xCEL,1UL,253UL,0x64L,248UL},{0x64L,0x7BL,1UL,1UL,0xDAL,248UL,0xDAL,1UL,1UL,0x7BL},{2UL,253UL,248UL,0x7BL,0xDAL,0xE2L,0xE2L,0xDAL,0x7BL,248UL}};
    float l_414 = 0x1.5p+1;
    float *l_413 = &l_414;
    int64_t l_417 = 0L;
    struct S0 *l_506 = (void*)0;
    float **l_508 = &l_413;
    float ***l_507 = &l_508;
    struct S0 ** const l_578[6] = {&l_506,&l_506,&l_506,&l_506,&l_506,&l_506};
    struct S0 ** const *l_577 = &l_578[3];
    int i, j;
    (*l_363) = l_361;
lbl_397:
    for (l_364 = 0; (l_364 == 2); ++l_364)
    { /* block id: 168 */
        int32_t l_368 = 0x6ED1DBEBL;
        for (l_368 = 6; (l_368 >= 1); l_368 -= 1)
        { /* block id: 171 */
            const int32_t *l_369 = &l_368;
            const int32_t **l_370 = &l_369;
            (*l_370) = l_369;
        }
    }
    if ((*p_28))
    { /* block id: 175 */
        uint64_t l_379 = 0UL;
        struct S0 *l_415 = &l_361;
        struct S0 **l_431[5];
        struct S0 ***l_430 = &l_431[3];
        struct S0 ***l_485[8] = {&l_431[3],&l_431[3],&l_431[3],&l_431[3],&l_431[3],&l_431[3],&l_431[3],&l_431[3]};
        float **l_540[4] = {&l_413,&l_413,&l_413,&l_413};
        int32_t *l_542 = &l_364;
        int32_t **l_561 = &l_542;
        int i;
        for (i = 0; i < 5; i++)
            l_431[i] = (void*)0;
        for (l_364 = 0; (l_364 <= 20); ++l_364)
        { /* block id: 178 */
            int32_t l_373 = (-3L);
            const struct S0 *l_416 = &l_361;
            struct S0 ** const *l_432 = (void*)0;
            uint32_t l_528 = 7UL;
            float ***l_535 = &l_508;
            for (l_373 = 0; (l_373 < (-21)); --l_373)
            { /* block id: 181 */
                int32_t l_376 = 0L;
                int32_t *l_403 = &l_373;
                int32_t **l_433 = &l_403;
                for (l_376 = (-26); (l_376 < 14); l_376 = safe_add_func_int64_t_s_s(l_376, 2))
                { /* block id: 184 */
                    int64_t l_393 = 0x77126209F7C56E56LL;
                    if ((*p_28))
                    { /* block id: 185 */
                        int8_t l_394[3];
                        int32_t *l_396 = &l_376;
                        int32_t **l_395[4][6][10] = {{{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396}},{{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396}},{{&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0}},{{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0},{(void*)0,(void*)0,&l_396,&l_396,(void*)0,(void*)0,(void*)0,&l_396,&l_396,(void*)0}}};
                        int i, j, k;
                        for (i = 0; i < 3; i++)
                            l_394[i] = 0x0DL;
                        p_29 = &l_364;
                        /* statement id: 186 */
                        assert (p_29 == &l_364);
                        p_29 = p_29;
                        if (l_373)
                            goto lbl_397;
                        p_27 = (0x1.3p+1 < ((safe_sub_func_float_f_f((-l_379), 0x4.04C1C4p+34)) >= l_393));
                    }
                    else
                    { /* block id: 190 */
                        return l_376;
                    }
                    /* facts after branching */
                    assert (p_29 == &l_364);
                }
                for (l_376 = 0; (l_376 >= (-29)); --l_376)
                { /* block id: 196 */
                    int32_t **l_404 = &l_403;
                    for (l_379 = 0; (l_379 <= 6); l_379 += 1)
                    { /* block id: 199 */
                        (*p_28) = (*p_29);
                    }
                    (*l_404) = l_403;
                    (*p_28) = (safe_lshift_func_uint8_t_u_s(((safe_lshift_func_uint8_t_u_s(l_367[2][9], (safe_add_func_int8_t_s_s((safe_sub_func_int16_t_s_s(1L, (l_373 == l_379))), ((*l_403) & ((l_413 == (void*)0) >= (((l_415 != l_416) || l_417) && (**l_404)))))))) > 0xC06B8AFC5FDFF8A2LL), l_379));
                    for (l_379 = 0; (l_379 <= 6); l_379 += 1)
                    { /* block id: 206 */
                        int i, j;
                        (*l_404) = (*l_404);
                        (*l_404) = func_35(l_367[l_379][(l_379 + 1)], p_29, &l_373, (**l_404));
                        /* statement id: 208 */
                        //assert (l_403 == &l_364 || l_403 == &l_9);
                        return (*p_28);
                    }
                }
                (*l_433) = (void*)0;
                /* statement id: 212 */
                assert (l_403 == 0);
                (*l_413) = ((safe_add_func_float_f_f((l_379 <= ((((0x5.DF1091p-6 == (((safe_sub_func_float_f_f(((safe_div_func_float_f_f((safe_sub_func_float_f_f(((safe_add_func_float_f_f((&l_413 == (void*)0), p_27)) >= ((!((p_27 != (safe_sub_func_float_f_f(l_379, (+0x1.2p+1)))) > (((safe_div_func_float_f_f((&l_431[3] != (void*)0), p_27)) > p_27) >= p_27))) > p_27)), p_27)), l_379)) >= p_27), p_27)) <= l_364) >= l_373)) == l_373) > 0x9.0p-1) != l_379)), 0x4.5p-1)) <= p_27);
            }
            if (((0xBDL || (l_379 == ((safe_div_func_uint8_t_u_u(((!(((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_add_func_int8_t_s_s((0x51L > ((safe_sub_func_int16_t_s_s((l_432 == (void*)0), l_417)) == (l_361.f0 && l_373))), (&l_431[3] == l_432))), 14)), 0xCBA9L)) < l_361.f0) ^ 18446744073709551607UL)) & l_373), l_379)) >= (*p_29)))) != 0xBEL))
            { /* block id: 215 */
                uint16_t l_461 = 0x4D54L;
                int32_t *l_473 = &l_364;
                int32_t **l_472 = &l_473;
                const float **l_477 = (void*)0;
                int64_t l_493 = (-1L);
                struct S0 *l_512[8][4] = {{&l_361,(void*)0,&l_361,&l_361},{&l_361,&l_361,&l_361,&l_361},{&l_361,&l_361,&l_361,&l_361},{&l_361,&l_361,&l_361,&l_361},{&l_361,&l_361,(void*)0,&l_361},{&l_361,&l_361,&l_361,&l_361},{&l_361,&l_361,&l_361,&l_361},{&l_361,(void*)0,&l_361,&l_361}};
                int i, j;
                if (l_373)
                    break;
                (*l_472) = func_41(l_379, (l_373 && (l_379 ^ l_461)), l_461, (safe_mul_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(l_364, 4)), ((((safe_mod_func_int16_t_s_s(((l_379 == (((safe_mod_func_int16_t_s_s((((safe_sub_func_uint32_t_u_u(l_461, l_373)) ^ (-1L)) && l_379), l_417)) && 0xFAL) && l_379)) < l_379), l_373)) ^ (-4L)) == l_379) == l_361.f0))));
                /* statement id: 217 */
                assert (l_473 == 0);
                for (l_373 = 4; (l_373 >= 1); l_373 -= 1)
                { /* block id: 220 */
                    struct S0 l_478[2][8][8] = {{{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}}},{{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}},{{-21},{-21},{-3},{-26},{27},{27},{-26},{-3}}}};
                    struct S0 ***l_486 = &l_431[3];
                    int i, j, k;
                    if ((l_367[(l_373 + 2)][(l_373 + 4)] == ((((+((safe_div_func_uint64_t_u_u(l_379, 1UL)) != 0xD358L)) ^ 4294967295UL) >= l_361.f0) < (l_477 != &l_413))))
                    { /* block id: 221 */
                        int i;
                        (*p_28) = (*p_28);
                        (*l_415) = l_478[1][3][2];
                    }
                    else
                    { /* block id: 224 */
                        int32_t l_484 = 0x86A1B6D9L;
                        int i;
                        l_431[l_373] = &l_363;
                        if (l_361.f0)
                            continue;
                        (*p_28) = (safe_sub_func_int32_t_s_s((safe_div_func_int64_t_s_s(((((!2L) <= 0x2AL) > l_484) & (l_485[3] == l_486)), l_484)), (safe_sub_func_uint64_t_u_u((l_484 & (5UL == l_379)), 0x5D4B49C6F01627EDLL))));
                        (*l_472) = (void*)0;
                    }
                    if ((*p_28))
                        break;
                    (*l_413) = l_361.f0;
                }
                for (l_373 = (-26); (l_373 >= 16); l_373 = safe_add_func_uint16_t_u_u(l_373, 9))
                { /* block id: 235 */
                    int8_t l_501 = (-1L);
                    struct S0 *l_513 = (void*)0;
                    if (((safe_add_func_uint8_t_u_u(l_493, (safe_unary_minus_func_int8_t_s((safe_div_func_uint8_t_u_u(((safe_add_func_int16_t_s_s((&l_361 != &l_361), 0x796AL)) != ((safe_sub_func_uint32_t_u_u(((void*)0 == &l_431[3]), ((0x4D88L | ((void*)0 != &l_416)) != 0x3E75L))) | l_501)), l_373)))))) & l_364))
                    { /* block id: 236 */
                        float ****l_509 = &l_507;
                        (*l_413) = (safe_add_func_float_f_f((safe_div_func_float_f_f((l_506 != (void*)0), p_27)), ((void*)0 == &p_29)));
                        (*l_509) = l_507;
                        if (l_361.f0)
                            goto lbl_397;
                        (*l_415) = (*l_415);
                    }
                    else
                    { /* block id: 241 */
                        (*l_363) = (*l_363);
                    }
                    (*l_472) = func_41(l_367[5][3], (((safe_sub_func_int16_t_s_s(((l_512[4][0] != l_513) < l_373), (((safe_mod_func_uint64_t_u_u((safe_mod_func_int8_t_s_s(0xE9L, ((4294967288UL >= (safe_rshift_func_uint16_t_u_s((safe_add_func_uint16_t_u_u(l_501, (((l_501 && (safe_add_func_uint8_t_u_u(((safe_sub_func_uint8_t_u_u((l_373 || 0x27L), l_379)) ^ 0UL), l_373))) || l_528) < l_501))), l_379))) || 0xB9L))), 0xE048BF0802A14680LL)) < 1UL) > 255UL))) >= 4294967295UL) == l_367[4][4]), l_501, l_373);
                    /* statement id: 244 */
                    assert (l_473 == 0);
                    (*l_472) = p_29;
                    /* statement id: 245 */
                    //assert (l_473 == &l_364 || l_473 == &l_9);
                }
                /* facts after for loop */
                //assert (l_473 == &l_364 || l_473 == &l_9 || l_473 == 0);
            }
            else
            { /* block id: 247 */
                int32_t **l_529 = (void*)0;
                float ***l_530 = &l_508;
                int32_t l_541 = 0xF649D557L;
                int32_t l_559 = 2L;
                p_29 = p_28;
                /* statement id: 248 */
                //assert (p_29 == &l_9);
                if (((((void*)0 == l_530) ^ (safe_add_func_uint16_t_u_u((l_379 >= ((l_364 == (safe_sub_func_uint16_t_u_u(((l_535 == l_530) ^ ((safe_sub_func_uint64_t_u_u(((safe_lshift_func_uint8_t_u_u(((*l_535) == l_540[1]), 3)) != 6L), 18446744073709551615UL)) | l_379)), l_541))) != 0L)), l_379))) <= l_373))
                { /* block id: 249 */
                    int32_t **l_543 = &l_542;
                    (*l_543) = p_29;
                    /* statement id: 250 */
                    //assert (l_542 == &l_9);
                    for (l_379 = 0; (l_379 < 45); l_379 = safe_add_func_uint64_t_u_u(l_379, 3))
                    { /* block id: 253 */
                        float ***l_548 = &l_540[1];
                        (*l_542) = ((safe_lshift_func_int8_t_s_u(((l_535 != l_548) && (0xEDL <= (safe_lshift_func_int16_t_s_s((l_373 ^ ((safe_rshift_func_uint16_t_u_u((!l_417), l_373)) <= 9UL)), 4)))), (((~(safe_rshift_func_uint16_t_u_s(0UL, l_528))) <= 0UL) | (**l_543)))) || l_364);
                    }
                    for (l_541 = 16; (l_541 >= 15); l_541--)
                    { /* block id: 258 */
                        if ((*l_542))
                            break;
                        return l_559;
                    }
                }
                else
                { /* block id: 262 */
                    int64_t l_560 = 0x1A73D9831F8AEBA5LL;
                    return l_560;
                }
                /* facts after branching */
                //assert (l_542 == &l_9);
                (***l_507) = l_528;
            }
        }
        /* facts after for loop */
        //assert (l_431[0] == &l_363 || l_431[0] == 0);
        //assert (l_542 == &l_9 || l_542 == &l_364);
        (*l_561) = &l_364;
        /* statement id: 268 */
        assert (l_542 == &l_364);
        return (*p_28);
    }
    else
    { /* block id: 270 */
        float ***l_567 = &l_508;
        int32_t l_570 = 0x11F28703L;
        struct S0 **l_581 = &l_363;
        struct S0 ***l_580 = &l_581;
        struct S0 ****l_579 = &l_580;
        (*l_413) = 0x7.3D8A28p-45;
        (*p_29) = (1L ^ (safe_mod_func_int32_t_s_s(0xE6C489C0L, ((safe_lshift_func_uint16_t_u_u(((safe_unary_minus_func_int32_t_s((l_567 != (void*)0))) & ((l_417 & (safe_div_func_uint64_t_u_u(l_570, (-1L)))) > (safe_lshift_func_uint8_t_u_u(l_361.f0, ((safe_sub_func_uint16_t_u_u((((safe_sub_func_uint32_t_u_u(l_364, (*p_29))) >= l_364) > l_570), l_570)) & l_570))))), 1)) & l_417))));
        l_570 = 0x5.089029p+88;
        (*l_579) = l_577;
        /* statement id: 274 */
        assert ((l_580 >= &l_578[0] && l_580 <= &l_578[5]));
    }
    (*l_363) = (*l_363);
    return l_361.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_31(int32_t * p_32, int8_t  p_33, uint8_t  p_34)
{ /* block id: 144 */
    float l_309 = 0x7.6p+1;
    float *l_308 = &l_309;
    float **l_307 = &l_308;
    uint64_t l_312 = 7UL;
    uint16_t l_342 = 65527UL;
    struct S0 l_352[2] = {{15},{15}};
    struct S0 *l_351[7][1];
    struct S0 **l_354 = &l_351[6][0];
    struct S0 ***l_353 = &l_354;
    uint8_t l_357 = 0x30L;
    int i, j;
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 1; j++)
            l_351[i][j] = &l_352[0];
    }
    if (((l_307 != &l_308) | ((safe_add_func_int64_t_s_s(0xD4BD023BC67531C0LL, p_34)) | (((l_312 >= (p_33 < (l_312 ^ ((safe_lshift_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s((~((+(p_33 | 0x0E6AL)) > l_312)), l_312)) & p_34), 9)) != l_312)))) >= l_312) == l_312))))
    { /* block id: 145 */
        struct S0 l_325 = {6};
        struct S0 *l_324 = &l_325;
        struct S0 **l_323[2][8];
        float *l_337 = &l_309;
        int32_t *l_343 = (void*)0;
        int i, j;
        for (i = 0; i < 2; i++)
        {
            for (j = 0; j < 8; j++)
                l_323[i][j] = &l_324;
        }
        for (p_33 = 0; (p_33 != (-3)); --p_33)
        { /* block id: 148 */
            struct S0 **l_326 = &l_324;
            int32_t l_328 = 0x65715371L;
            int32_t *l_327 = &l_328;
            (*l_327) = (safe_div_func_uint8_t_u_u((l_323[0][2] == l_326), l_325.f0));
            return p_34;
        }
        l_343 = func_41(p_34, l_325.f0, l_325.f0, (safe_div_func_uint32_t_u_u((safe_sub_func_int64_t_s_s((safe_lshift_func_uint8_t_u_u(((safe_div_func_uint64_t_u_u((l_337 == l_337), l_325.f0)) >= l_325.f0), 6)), (((safe_add_func_int32_t_s_s((safe_add_func_uint16_t_u_u(((&l_323[1][3] == &l_323[0][0]) < 0xD0L), l_325.f0)), l_312)) ^ l_342) < l_325.f0))), l_342)));
    }
    else
    { /* block id: 153 */
        return p_33;
    }
    if ((safe_div_func_uint32_t_u_u((safe_unary_minus_func_uint8_t_u(p_34)), ((safe_div_func_uint32_t_u_u((((safe_rshift_func_int8_t_s_s((l_351[6][0] == &l_352[0]), 4)) && (l_353 == &l_354)) || 0x15CC0637L), (safe_sub_func_int32_t_s_s((l_308 == (void*)0), 0xFD3B0A5FL)))) & p_34))))
    { /* block id: 156 */
        return p_34;
    }
    else
    { /* block id: 158 */
        int32_t l_359 = 0x06231FCBL;
        int32_t *l_358 = &l_359;
        int32_t **l_360 = &l_358;
        (**l_307) = l_357;
        (*l_358) = 5L;
        (*l_360) = (void*)0;
        /* statement id: 161 */
        assert (l_358 == 0);
    }
    return l_352[0].f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_35(int16_t  p_36, int32_t * p_37, int32_t * p_38, uint32_t  p_39)
{ /* block id: 70 */
    int32_t l_188[5] = {0xF83237CEL,0xF83237CEL,0xF83237CEL,0xF83237CEL,0xF83237CEL};
    int32_t *l_187[4][5] = {{&l_188[0],&l_188[1],&l_188[1],&l_188[0],&l_188[1]},{&l_188[1],&l_188[1],(void*)0,&l_188[1],&l_188[1]},{&l_188[1],&l_188[0],&l_188[1],&l_188[1],&l_188[0]},{&l_188[1],&l_188[2],&l_188[2],&l_188[1],&l_188[2]}};
    struct S0 *l_239 = (void*)0;
    uint8_t l_240 = 1UL;
    float l_249 = 0x5.64E212p+78;
    float *l_248 = &l_249;
    float **l_247[2][6] = {{&l_248,&l_248,&l_248,&l_248,&l_248,&l_248},{&l_248,&l_248,&l_248,&l_248,&l_248,&l_248}};
    uint64_t l_292 = 0xA1BC2A71DD7EC65ELL;
    int i, j;
lbl_275:
    for (p_36 = (-15); (p_36 == 9); p_36 = safe_add_func_int32_t_s_s(p_36, 5))
    { /* block id: 73 */
        int32_t l_172 = 2L;
        int32_t *l_171 = &l_172;
        int32_t **l_173[5] = {&l_171,&l_171,&l_171,&l_171,&l_171};
        int i;
        p_38 = l_171;
        /* statement id: 74 */
        assert (p_38 == &l_172);
    }
    for (p_39 = 0; (p_39 != 12); p_39++)
    { /* block id: 78 */
        int32_t l_176 = 1L;
        float l_178 = 0x6.6p-1;
        float *l_177 = &l_178;
        int16_t l_179[9] = {(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)};
        struct S0 l_225 = {-31};
        struct S0 *l_224 = &l_225;
        struct S0 ** const l_223[1][3] = {{&l_224,&l_224,&l_224}};
        uint32_t l_244 = 0x7B25FE38L;
        int i, j;
        (*l_177) = l_176;
        if (l_179[7])
        { /* block id: 80 */
            const int32_t l_184 = 1L;
            int32_t *l_186[2];
            const struct S0 l_196 = {13};
            const struct S0 *l_195 = &l_196;
            struct S0 l_204[8] = {{-26},{-26},{-26},{-26},{-26},{-26},{-26},{-26}};
            struct S0 *l_203 = &l_204[7];
            struct S0 **l_202 = &l_203;
            struct S0 ***l_201 = &l_202;
            int i;
            for (i = 0; i < 2; i++)
                l_186[i] = &l_176;
            if (((safe_div_func_int8_t_s_s(l_176, ((-1L) | (0L | 0L)))) == ((safe_add_func_int32_t_s_s(l_184, (l_179[5] >= (((((&l_176 != (void*)0) > (safe_unary_minus_func_uint16_t_u(l_184))) > p_39) && l_184) <= 0xB3BD2D33707CAD87LL)))) | l_184)))
            { /* block id: 81 */
                int32_t *l_189[2];
                int i;
                for (i = 0; i < 2; i++)
                    l_189[i] = &l_188[1];
                return p_37;
                /* statement id: 82 */
                //assert (func_35_rv == 0 || func_35_rv == &l_364 || func_35_rv == &l_9);
            }
            else
            { /* block id: 83 */
                int16_t l_194 = 0x4C0AL;
                int8_t l_207 = 0L;
                int32_t *l_230 = &l_188[3];
                struct S0 ***l_243 = &l_202;
                uint64_t l_246 = 0xAC364A4C9FFC7C3ELL;
                int32_t *l_274 = (void*)0;
                float * const *l_298 = &l_177;
                if (p_39)
                { /* block id: 84 */
                    int32_t *l_208[4][1];
                    int32_t **l_209 = &l_208[1][0];
                    int i, j;
                    for (i = 0; i < 4; i++)
                    {
                        for (j = 0; j < 1; j++)
                            l_208[i][j] = &l_176;
                    }
                    for (p_36 = 0; (p_36 < (-3)); p_36--)
                    { /* block id: 87 */
                        l_194 = (safe_rshift_func_uint8_t_u_s(0xCCL, 0));
                    }
                    (*l_177) = (((void*)0 == l_195) < ((safe_add_func_float_f_f((safe_sub_func_float_f_f(l_179[7], ((void*)0 != l_201))), 0x4.97BF4Dp-39)) >= (safe_sub_func_float_f_f(0x5.2ED70Bp+91, l_207))));
                    if (l_176)
                        break;
                    (*l_209) = l_208[1][0];
                }
                else
                { /* block id: 93 */
                    int8_t l_245 = 0L;
                    int32_t l_255 = 0x62E55FA1L;
                    int32_t *l_261 = (void*)0;
                    for (l_194 = 18; (l_194 < (-2)); l_194--)
                    { /* block id: 96 */
                        struct S0 **l_222 = &l_203;
                        int32_t l_228 = 0xADB4F27BL;
                        int32_t **l_229[10] = {&l_186[1],&l_186[0],&l_186[0],&l_186[1],&l_186[0],&l_186[0],&l_186[1],&l_186[0],&l_186[0],&l_186[1]};
                        int i;
                        l_176 = (((void*)0 == &l_202) > (0x0.Fp-1 > (safe_div_func_float_f_f((safe_sub_func_float_f_f(p_39, ((safe_add_func_float_f_f(p_36, (safe_sub_func_float_f_f((safe_sub_func_float_f_f((l_207 <= (l_222 == l_223[0][0])), (safe_div_func_float_f_f((&p_37 != (void*)0), p_39)))), l_228)))) != l_176))), 0x9.D8F16Dp+39))));
                        if (l_176)
                            break;
                        if (p_39)
                            continue;
                        l_187[3][0] = &l_176;
                    }
                    /* facts after for loop */
                    //assert (l_187[0][0] == &l_176 || (l_187[0][0] >= &l_188[0] && l_187[0][0] <= &l_188[4]) || l_187[0][0] == 0 || l_187[0][0] == dangling);
                    l_245 = ((l_230 != p_37) ^ (((safe_div_func_uint64_t_u_u(((safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u((((safe_add_func_int16_t_s_s(((void*)0 == l_239), 0x4D08L)) && (l_240 && ((safe_rshift_func_uint8_t_u_u((l_243 != &l_202), ((&l_224 != (void*)0) & p_39))) != 3L))) != 0xBCL), p_36)), p_39)) & p_36), p_36)) != 0xCD871682L) <= l_244));
                    if ((l_225.f0 == (-4L)))
                    { /* block id: 103 */
                        (*l_177) = (0x7.34F036p-61 < p_36);
                        (*l_230) = l_246;
                    }
                    else
                    { /* block id: 106 */
                        float ***l_250 = &l_247[1][5];
                        const int32_t l_251 = 1L;
                        int32_t **l_252 = (void*)0;
                        int32_t l_260[9] = {(-4L),(-4L),(-4L),(-4L),(-4L),(-4L),(-4L),(-4L),(-4L)};
                        int i;
                        (*l_250) = l_247[1][3];
                        l_187[3][0] = func_41((l_251 == p_36), p_36, p_39, l_251);
                        l_261 = &l_176;
                        /* statement id: 109 */
                        assert (l_261 == &l_176);
                        (**l_201) = (**l_201);
                    }
                    /* facts after branching */
                    assert (l_261 == &l_176 || l_261 == 0);
                }
                /* facts after branching */
                //assert (l_187[0][0] == &l_176 || (l_187[0][0] >= &l_188[0] && l_187[0][0] <= &l_188[4]) || l_187[0][0] == 0 || l_187[0][0] == dangling);
                l_274 = func_46(l_225.f0, (p_36 >= (safe_div_func_int16_t_s_s(l_179[7], l_176))), p_36, func_41((((**l_201) != (**l_243)) & (safe_mod_func_uint64_t_u_u(((safe_rshift_func_int8_t_s_s(((safe_sub_func_uint8_t_u_u(((safe_rshift_func_uint8_t_u_s(0x65L, ((safe_mod_func_int8_t_s_s((((p_39 <= l_225.f0) | p_36) < (*l_230)), p_39)) >= l_179[7]))) && l_176), (*l_230))) == p_36), 1)) & (-1L)), p_36))), p_39, p_39, p_36), &l_188[1]);
                if (l_244)
                    goto lbl_275;
                //assert ((l_187[0][0] >= &l_188[0] && l_187[0][0] <= &l_188[4]) || l_187[0][0] == 0 || l_187[0][0] == dangling);
                if (p_36)
                { /* block id: 115 */
                    if (l_240)
                        goto lbl_275;
                    //assert ((l_187[0][0] >= &l_188[0] && l_187[0][0] <= &l_188[4]) || l_187[0][0] == 0 || l_187[0][0] == dangling);
                }
                else
                { /* block id: 117 */
                    struct S0 *l_276 = &l_204[7];
                    int32_t l_295 = 0L;
                    (*l_202) = l_276;
                    l_295 = (safe_sub_func_float_f_f(((-(safe_add_func_float_f_f((safe_sub_func_float_f_f(0x1.9p-1, (((safe_sub_func_float_f_f(p_36, (((l_179[7] == (-0x6.8p-1)) == ((p_39 > ((safe_div_func_float_f_f(((safe_add_func_float_f_f(((safe_div_func_float_f_f(p_39, l_292)) < (safe_div_func_float_f_f((((l_276 == l_276) <= p_39) == p_39), p_36))), p_36)) >= p_39), 0xF.D91489p+37)) == p_36)) != p_39)) > (-0x1.5p-1)))) > l_244) >= p_36))), 0x2.7BE196p-46))) != (-0x1.2p+1)), (*l_230)));
                    (***l_201) = (*l_195);
                    p_38 = func_41(p_36, p_36, (safe_sub_func_uint8_t_u_u(4UL, (p_36 >= (&l_177 == l_298)))), (*l_230));
                    /* statement id: 121 */
                    assert (p_38 == 0);
                }
            }
            /* facts after branching */
            //assert (l_187[0][0] == &l_176 || (l_187[0][0] >= &l_188[0] && l_187[0][0] <= &l_188[4]) || l_187[0][0] == 0 || l_187[0][0] == dangling);
            for (l_244 = 0; (l_244 >= 17); l_244 = safe_add_func_int32_t_s_s(l_244, 1))
            { /* block id: 126 */
                for (l_292 = (-14); (l_292 <= 38); ++l_292)
                { /* block id: 129 */
                    int32_t *l_303 = &l_188[1];
                    l_303 = &l_188[1];
                }
            }
            for (l_292 = (-27); (l_292 > 6); ++l_292)
            { /* block id: 135 */
                if (p_39)
                    break;
            }
        }
        else
        { /* block id: 138 */
            int16_t l_306 = 0x9C53L;
            l_225.f0 = l_179[7];
            l_306 = l_179[0];
        }
        /* facts after branching */
        //assert (l_187[0][0] == &l_176 || (l_187[0][0] >= &l_188[0] && l_187[0][0] <= &l_188[4]) || l_187[0][0] == 0 || l_187[0][0] == dangling);
    }
    return p_37;
    /* statement id: 143 */
    //assert (func_35_rv == 0 || func_35_rv == &l_364 || func_35_rv == &l_9);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(uint8_t  p_42, int8_t  p_43, uint32_t  p_44, int16_t  p_45)
{ /* block id: 4 */
    uint32_t l_52[10][7][3] = {{{0x7A2E255BL,0x02BE2FF5L,0xB6454879L},{0x1F997EC5L,0xB6454879L,0x245E3205L},{0x5C1B09C8L,5UL,0x7A2E255BL},{0xB4D2C298L,9UL,0xB4D2C298L},{18446744073709551610UL,9UL,3UL},{3UL,5UL,0x02BE2FF5L},{9UL,0xB6454879L,0xF74F57B1L}},{{0x5C7E4DDBL,0x02BE2FF5L,0x2E7EB665L},{9UL,1UL,18446744073709551615UL},{3UL,0xF74F57B1L,0xF74F57B1L},{1UL,0x1F997EC5L,0xF74F57B1L},{18446744073709551610UL,0UL,0xB6454879L},{0x2E7EB665L,18446744073709551610UL,0x7A2E255BL},{0xF093D7F2L,0x245E3205L,0x1F997EC5L}},{{3UL,18446744073709551610UL,0x5C1B09C8L},{0x5C7E4DDBL,0UL,0xB4D2C298L},{0x1F997EC5L,0x1F997EC5L,18446744073709551610UL},{0x1F997EC5L,0xF74F57B1L,3UL},{0x5C7E4DDBL,18446744073709551615UL,9UL},{3UL,0x5C1B09C8L,0x5C7E4DDBL},{0xF093D7F2L,0x5C7E4DDBL,9UL}},{{0x2E7EB665L,0UL,3UL},{18446744073709551610UL,0x02BE2FF5L,18446744073709551610UL},{1UL,0x02BE2FF5L,0xB4D2C298L},{0xB4D2C298L,0UL,0x5C1B09C8L},{0x02BE2FF5L,0x5C7E4DDBL,0x1F997EC5L},{0UL,0x5C1B09C8L,0x7A2E255BL},{0x02BE2FF5L,18446744073709551615UL,0xB6454879L}},{{0xB4D2C298L,0xF74F57B1L,0xF74F57B1L},{1UL,0x1F997EC5L,0xF74F57B1L},{18446744073709551610UL,0UL,0xB6454879L},{0x2E7EB665L,18446744073709551610UL,0x7A2E255BL},{0xF093D7F2L,0x245E3205L,0x1F997EC5L},{3UL,18446744073709551610UL,0x5C1B09C8L},{0x5C7E4DDBL,0UL,0xB4D2C298L}},{{0x1F997EC5L,0x1F997EC5L,18446744073709551610UL},{0x1F997EC5L,0xF74F57B1L,3UL},{0x5C7E4DDBL,18446744073709551615UL,9UL},{3UL,0x5C1B09C8L,0x5C7E4DDBL},{0xF093D7F2L,0x5C7E4DDBL,9UL},{0x2E7EB665L,0UL,3UL},{18446744073709551610UL,0x02BE2FF5L,18446744073709551610UL}},{{1UL,0x02BE2FF5L,0xB4D2C298L},{0xB4D2C298L,0UL,0x5C1B09C8L},{0x02BE2FF5L,0x5C7E4DDBL,0x1F997EC5L},{0UL,0x5C1B09C8L,0x7A2E255BL},{0x02BE2FF5L,18446744073709551615UL,0xB6454879L},{0xB4D2C298L,0xF74F57B1L,0xF74F57B1L},{1UL,0x1F997EC5L,0xF74F57B1L}},{{18446744073709551610UL,0UL,0xB6454879L},{0x2E7EB665L,18446744073709551610UL,0x7A2E255BL},{0xF093D7F2L,0x245E3205L,0x1F997EC5L},{3UL,18446744073709551610UL,0x5C1B09C8L},{0x5C7E4DDBL,0UL,0xB4D2C298L},{0x1F997EC5L,0x1F997EC5L,18446744073709551610UL},{0x1F997EC5L,0xF74F57B1L,3UL}},{{0x5C7E4DDBL,18446744073709551615UL,9UL},{3UL,0x5C1B09C8L,0x5C7E4DDBL},{0xF093D7F2L,0x5C7E4DDBL,9UL},{0x2E7EB665L,0UL,3UL},{18446744073709551610UL,0x02BE2FF5L,18446744073709551610UL},{1UL,0x02BE2FF5L,0xB4D2C298L},{0xB4D2C298L,0UL,0x5C1B09C8L}},{{0x02BE2FF5L,0x5C7E4DDBL,0x1F997EC5L},{0UL,0x5C1B09C8L,0x7A2E255BL},{0x02BE2FF5L,18446744073709551615UL,0xB6454879L},{0xB4D2C298L,0xF74F57B1L,0xF74F57B1L},{1UL,0x1F997EC5L,0xF74F57B1L},{18446744073709551610UL,0UL,0xB6454879L},{0x2E7EB665L,18446744073709551610UL,0x7A2E255BL}}};
    int32_t l_70 = 0L;
    int32_t *l_69 = &l_70;
    int32_t **l_161 = &l_69;
    int32_t *l_162 = &l_70;
    int32_t *l_163[9];
    int32_t *l_164[2];
    int32_t *l_165[4][10][6] = {{{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,(void*)0,&l_70,&l_70,(void*)0,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70}},{{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,(void*)0,&l_70,&l_70,(void*)0,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70}},{{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,(void*)0,&l_70,&l_70,(void*)0,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70}},{{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,(void*)0,&l_70,&l_70},{&l_70,&l_70,&l_70,(void*)0,&l_70,(void*)0},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,&l_70,(void*)0,&l_70,&l_70},{&l_70,&l_70,&l_70,(void*)0,&l_70,&l_70},{&l_70,&l_70,&l_70,&l_70,&l_70,&l_70},{&l_70,&l_70,(void*)0,(void*)0,&l_70,&l_70}}};
    int32_t *l_166 = &l_70;
    int32_t *l_167 = (void*)0;
    int i, j, k;
    for (i = 0; i < 9; i++)
        l_163[i] = &l_70;
    for (i = 0; i < 2; i++)
        l_164[i] = &l_70;
    (*l_161) = func_46(l_52[1][4][1], ((safe_unary_minus_func_uint16_t_u((((+(safe_add_func_int8_t_s_s((safe_add_func_int64_t_s_s(func_59((safe_mod_func_int8_t_s_s(((safe_sub_func_int8_t_s_s(l_52[1][4][1], ((safe_rshift_func_uint16_t_u_u((((p_43 & ((void*)0 == l_69)) && (*l_69)) < (*l_69)), 5)) | p_43))) < (safe_lshift_func_int16_t_s_u(0x1939L, p_43))), p_44)), &l_70, &l_70), p_44)), 0x51L))) ^ (*l_69)) | p_44))) || p_42), p_42, &l_70, &l_70);
    return l_167;
    /* statement id: 69 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_9
 * writes: l_9
 */
static int32_t * func_46(uint64_t  p_47, int8_t  p_48, int8_t  p_49, int32_t * p_50, int32_t * p_51)
{ /* block id: 13 */
    float l_94 = (-0x1.0p-1);
    float *l_93 = &l_94;
    struct S0 l_108 = {22};
    struct S0 *l_107 = &l_108;
    float l_109 = (-0x5.9p+1);
    uint64_t l_110 = 0UL;
    struct S0 l_130[9][10][2] = {{{{-31},{2}},{{21},{14}},{{-5},{-19}},{{-28},{-25}},{{14},{12}},{{-24},{-9}},{{8},{-1}},{{26},{27}},{{2},{10}},{{-19},{-31}}},{{{-7},{-30}},{{13},{3}},{{-23},{-23}},{{19},{22}},{{-14},{22}},{{-17},{-23}},{{-11},{-17}},{{11},{-5}},{{11},{-17}},{{-11},{-23}}},{{{-17},{22}},{{-14},{22}},{{19},{-23}},{{-23},{3}},{{13},{-30}},{{-7},{-31}},{{-19},{10}},{{2},{27}},{{26},{-1}},{{8},{-9}}},{{{-24},{12}},{{14},{-25}},{{-28},{-19}},{{-5},{14}},{{21},{2}},{{-31},{-31}},{{27},{23}},{{-15},{22}},{{-13},{26}},{{21},{29}}},{{{-18},{7}},{{-9},{13}},{{-1},{-24}},{{26},{31}},{{-9},{20}},{{-20},{-9}},{{-21},{-7}},{{-27},{2}},{{23},{26}},{{-1},{-11}}},{{{3},{21}},{{12},{-13}},{{-5},{-20}},{{0},{7}},{{7},{26}},{{14},{29}},{{7},{-13}},{{0},{-13}},{{7},{29}},{{14},{26}}},{{{7},{7}},{{0},{-20}},{{-5},{-13}},{{12},{21}},{{3},{-11}},{{-1},{26}},{{23},{2}},{{-27},{-7}},{{-21},{-9}},{{-20},{20}}},{{{-9},{31}},{{26},{-24}},{{-1},{13}},{{-9},{7}},{{-18},{29}},{{29},{-9}},{{-28},{7}},{{-14},{-24}},{{8},{27}},{{-26},{-5}}},{{{10},{26}},{{-23},{19}},{{11},{-9}},{{26},{-25}},{{-13},{26}},{{-27},{9}},{{15},{8}},{{23},{1}},{{19},{-26}},{{-12},{-11}}}};
    int32_t l_143 = 0x89730A75L;
    int32_t *l_142 = &l_143;
    int32_t **l_141 = &l_142;
    const int32_t l_152 = 0xEA803138L;
    int i, j, k;
    (*l_93) = p_48;
    if ((safe_rshift_func_int8_t_s_u((safe_rshift_func_uint16_t_u_s((((p_51 != p_51) == (((safe_add_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(p_49, (((safe_add_func_uint64_t_u_u((p_51 != (void*)0), (1UL | ((((253UL > (((l_107 == (void*)0) == 0x1855L) < l_108.f0)) | l_108.f0) == 0xF0L) > l_108.f0)))) & p_49) > l_108.f0))), l_108.f0)) <= l_110) | l_108.f0)) || p_49), p_49)), l_110)))
    { /* block id: 15 */
        int32_t l_113 = 1L;
        int32_t *l_112 = &l_113;
        int32_t **l_111 = &l_112;
        (*l_111) = p_51;
        /* statement id: 16 */
        //assert (l_112 == &l_70 || (l_112 >= &l_188[0] && l_112 <= &l_188[4]) || l_112 == &l_9);
    }
    else
    { /* block id: 17 */
        int32_t l_116 = 7L;
        int32_t l_127 = 0x2C61B7CEL;
        int32_t *l_126 = &l_127;
        int32_t **l_128 = (void*)0;
        int32_t **l_129 = &l_126;
        int32_t *l_154 = &l_127;
        struct S0 *l_160 = &l_130[5][2][1];
        if ((*p_51))
        { /* block id: 18 */
            (*p_51) = (safe_div_func_uint8_t_u_u(l_116, l_110));
            (*p_51) = (1UL <= l_108.f0);
            (*l_107) = (*l_107);
        }
        else
        { /* block id: 22 */
            int32_t **l_119 = (void*)0;
            (*l_93) = ((safe_div_func_float_f_f(((((void*)0 == l_93) != (&p_51 == l_119)) <= (safe_div_func_float_f_f((p_49 != (0x9.4CE6FAp+52 <= p_48)), ((safe_div_func_float_f_f(p_49, (safe_div_func_float_f_f(((0x7.50B76Ap-31 <= l_116) != 0x1.4p+1), 0x2.9BF9ABp-7)))) >= (-0x7.1p+1))))), p_48)) >= p_48);
            p_51 = l_126;
            /* statement id: 24 */
            assert (p_51 == &l_127);
        }
        /* facts after branching */
        //assert (p_51 == &l_127 || p_51 == &l_70 || (p_51 >= &l_188[0] && p_51 <= &l_188[4]) || p_51 == &l_9);
        (*l_129) = &l_127;
        (*l_129) = p_51;
        /* statement id: 27 */
        //assert (l_126 == &l_127 || l_126 == &l_70 || (l_126 >= &l_188[0] && l_126 <= &l_188[4]) || l_126 == &l_9);
        for (p_49 = 0; (p_49 <= 1); p_49 += 1)
        { /* block id: 30 */
            struct S0 l_131[9][6] = {{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}},{{-18},{25},{-18},{18},{-15},{18}}};
            uint64_t l_146 = 0x0D2121A4FECFE75BLL;
            int32_t *l_149[5][6][1] = {{{(void*)0},{&l_143},{&l_143},{&l_143},{&l_143},{&l_143}},{{(void*)0},{&l_143},{&l_143},{&l_143},{&l_143},{&l_143}},{{(void*)0},{&l_143},{&l_143},{&l_143},{&l_143},{&l_143}},{{(void*)0},{&l_143},{&l_143},{&l_143},{&l_143},{&l_143}},{{(void*)0},{&l_143},{&l_143},{&l_143},{&l_143},{&l_143}}};
            struct S0 **l_157 = (void*)0;
            int i, j, k;
            (*l_107) = l_131[5][5];
            for (l_116 = 0; (l_116 <= 1); l_116 += 1)
            { /* block id: 34 */
                struct S0 *l_144[6];
                struct S0 *l_145[6][2] = {{&l_131[0][0],&l_108},{&l_108,&l_131[0][0]},{&l_108,&l_108},{&l_131[0][0],&l_108},{&l_108,&l_131[0][0]},{&l_108,&l_108}};
                int32_t l_147 = 0x6A4DFBEFL;
                int i, j;
                for (i = 0; i < 6; i++)
                    l_144[i] = &l_131[1][5];
            }
        }
    }
    /* facts after branching */
    //assert (p_51 == dangling || p_51 == &l_70 || (p_51 >= &l_188[0] && p_51 <= &l_188[4]) || p_51 == &l_9);
    return p_50;
    /* statement id: 67 */
    //assert (func_46_rv == &l_70 || func_46_rv == 0 || func_46_rv == &l_9);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_59(int16_t  p_60, int32_t * p_61, int32_t * p_62)
{ /* block id: 5 */
    uint16_t l_77[1];
    int i;
    for (i = 0; i < 1; i++)
        l_77[i] = 4UL;
    for (p_60 = 0; (p_60 <= 13); ++p_60)
    { /* block id: 8 */
        float l_88 = 0x7.579AB6p+91;
        int32_t l_89 = 0x00BAF34CL;
        float *l_90 = &l_88;
        struct S0 l_91[4][3] = {{{4},{4},{4}},{{-12},{-12},{-12}},{{4},{4},{4}},{{-12},{-12},{-12}}};
        struct S0 *l_92 = &l_91[0][2];
        int i, j;
        (*l_90) = ((((safe_sub_func_float_f_f((l_77[0] != l_77[0]), ((p_60 == (((+(safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_div_func_float_f_f(0xD.0486D4p+91, (p_60 > ((p_60 != (!(l_88 != ((void*)0 == p_61)))) <= p_60)))), (-0x2.4p-1))), 0x8.8p-1)), (-0x1.2p-1)))) > p_60) == p_60)) <= 0x7.FDEEAFp+29))) != l_89) != p_60) > l_89);
        (*l_92) = l_91[2][0];
    }
    return l_77[0];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 164
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 47
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 18
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 13
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 7
breakdown:
   indirect level: 0, occurrence: 7
XXX times a bitfields struct's address is taken: 42
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 26
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 35

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 223
   depth: 2, occurrence: 36
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 8, occurrence: 4
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 5
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 181

XXX times a variable address is taken: 258
XXX times a pointer is dereferenced on RHS: 84
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 4
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 20
XXX times a pointer is qualified to be dereferenced: 551

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 546
   level: 2, occurrence: 118
   level: 3, occurrence: 33
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 72
XXX number of pointers point to structs: 30
XXX percent of pointers has null in alias set: 29.8
XXX average alias set size: 1.39

XXX times a non-volatile is read: 805
XXX times a non-volatile is write: 243
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 196
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 34
   depth: 2, occurrence: 25
   depth: 3, occurrence: 23
   depth: 4, occurrence: 39
   depth: 5, occurrence: 49

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

