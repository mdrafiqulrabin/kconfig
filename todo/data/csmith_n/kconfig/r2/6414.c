/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2058188336
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
   const int16_t  f1;
   int32_t  f2;
   int32_t  f3;
   int32_t  f4;
   int32_t  f5;
   uint32_t  f6;
   const signed f7 : 28;
   int64_t  f8;
};

union U1 {
   const int32_t  f0;
   int32_t  f1;
   int16_t  f2;
   int64_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_30(void);
static const int32_t * func_34(uint16_t  p_35, float  p_36, uint32_t  p_37, uint32_t  p_38, uint16_t  p_39);
inline static int64_t  func_41(int32_t * p_42);
static int32_t * func_43(float  p_44);
inline static float  func_45(int16_t  p_46, uint64_t  p_47, int32_t * p_48);
inline static uint64_t  func_49(int64_t  p_50);
inline static int32_t * func_51(const int16_t  p_52, uint16_t  p_53, int32_t  p_54, uint8_t  p_55);
static int32_t * const  func_63(int32_t * p_64, uint32_t  p_65);
inline static int32_t * func_66(int32_t * p_67);
inline static int32_t * func_71(int16_t  p_72, int64_t  p_73, const int32_t * p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 0x9BDD7770L;
    int32_t *l_629 = &l_31;
    const int32_t *l_689 = &l_31;
    const int32_t **l_688 = &l_689;
    uint32_t l_701 = 18446744073709551609UL;
    int64_t l_707 = 0x3E97F0320ADF2683LL;
    uint8_t l_708 = 0x6DL;
    for (l_31 = 0; (l_31 > (-29)); l_31--)
    { /* block id: 39 */
        int64_t l_40 = 0xC4779D44F4CC511ELL;
        int32_t l_683 = (-1L);
    }
    return l_708;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_34(uint16_t  p_35, float  p_36, uint32_t  p_37, uint32_t  p_38, uint16_t  p_39)
{ /* block id: 408 */
    int32_t l_673 = 4L;
    int32_t * const l_672 = &l_673;
    int32_t *l_675 = (void*)0;
    int32_t **l_674 = &l_675;
    const int32_t *l_676 = &l_673;
    const int32_t *l_677 = &l_673;
    const int32_t *l_678 = &l_673;
    const int32_t *l_679 = &l_673;
    const int32_t *l_680 = &l_673;
    const int32_t *l_681 = (void*)0;
    (*l_674) = l_672;
    /* statement id: 409 */
    assert (l_675 == &l_673);
    return l_681;
    /* statement id: 410 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_41(int32_t * p_42)
{ /* block id: 399 */
    int32_t *l_656 = (void*)0;
    int32_t **l_655 = &l_656;
    int32_t l_657 = 0x2529E886L;
    union U1 l_661 = {-2L};
    union U1 *l_660 = &l_661;
    (*l_655) = p_42;
    if ((((-4L) != l_657) & (((uint64_t)(l_657 >= l_657) % (uint64_t)(func_49((8UL && (l_660 != &l_661))) && (((int64_t)(((int16_t)1L << (int16_t)5) > l_661.f0) - (int64_t)l_661.f1) > l_657))) ^ l_657)))
    { /* block id: 401 */
        float l_666 = 0x3.09BE0Dp-73;
        int32_t l_667 = 0x1F8B2898L;
        return l_667;
    }
    else
    { /* block id: 403 */
        const int64_t l_668 = (-3L);
        float l_670 = 0x5.4BD615p+45;
        float *l_669 = &l_670;
        (*l_669) = (l_668 != l_668);
        l_657 = l_668;
    }
    return l_661.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(float  p_44)
{ /* block id: 391 */
    union U1 l_636 = {0L};
    union U1 *l_635 = &l_636;
    union U1 **l_634 = &l_635;
    int32_t *l_637 = (void*)0;
    int32_t **l_638 = &l_637;
    int32_t l_642 = 0xDB05A40AL;
    int32_t *l_641 = &l_642;
    int32_t *l_645 = &l_642;
    int32_t *l_648 = &l_642;
    int32_t *l_649 = &l_642;
    int32_t *l_650 = (void*)0;
    int32_t *l_652 = &l_642;
    int32_t *l_653 = &l_642;
    (*l_634) = (void*)0;
    /* statement id: 392 */
    assert (l_635 == 0);
    (*l_638) = l_637;
    if (l_636.f0)
    { /* block id: 394 */
        int32_t l_640 = 0x3A0385E8L;
        int32_t *l_639 = &l_640;
        int32_t *l_643 = &l_640;
        int32_t *l_644 = &l_640;
        int32_t *l_646 = &l_642;
        int32_t *l_647 = &l_642;
        return l_650;
        /* statement id: 395 */
        //assert (func_43_rv == 0);
    }
    else
    { /* block id: 396 */
        int32_t *l_651 = &l_642;
        int32_t *l_654 = (void*)0;
        return l_654;
        /* statement id: 397 */
        //assert (func_43_rv == 0);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_45(int16_t  p_46, uint64_t  p_47, int32_t * p_48)
{ /* block id: 384 */
    uint8_t l_633 = 0x17L;
    for (p_46 = 0; (p_46 == (-22)); p_46 -= 7)
    { /* block id: 387 */
        uint16_t l_632 = 5UL;
        if (l_632)
            break;
    }
    return l_633;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_49(int64_t  p_50)
{ /* block id: 41 */
    uint32_t l_60 = 0x4EDB553AL;
    int32_t **l_507 = (void*)0;
    int32_t l_509 = 0x9EE6ECA7L;
    int32_t *l_508 = &l_509;
    struct S0 l_515 = {248UL,0x6451L,-1L,-7L,5L,1L,0xD7295ACFL,-10432,-9L};
    struct S0 *l_514 = &l_515;
    struct S0 **l_513 = &l_514;
    const struct S0 *l_517 = &l_515;
    const struct S0 **l_516 = &l_517;
    union U1 l_628 = {0xDED783F5L};
    union U1 *l_627 = &l_628;
lbl_578:
    l_508 = func_51(((uint16_t)0UL << (uint16_t)(6L & (((uint16_t)0x71B7L >> (uint16_t)5) >= l_60))), p_50, p_50, p_50);
    /* statement id: 332 */
    assert (l_508 == 0);
    for (l_509 = (-6); (l_509 == 18); ++l_509)
    { /* block id: 335 */
        uint64_t l_512 = 0x18782F0279FFE745LL;
        int32_t *l_518 = &l_515.f5;
        union U1 l_587 = {0xE12E4BF4L};
        union U1 *l_586 = &l_587;
        union U1 **l_585 = &l_586;
        union U1 ***l_584 = &l_585;
        int32_t l_619 = 0x8727A0ACL;
        struct S0 ***l_625 = &l_513;
        struct S0 ****l_624 = &l_625;
        struct S0 *****l_623 = &l_624;
        (*l_518) = __builtin_bswap64(((l_512 | __builtin_ia32_crc32qi(p_50, l_512)) != ((0x96E3L || ((p_50 == 0UL) != 0x57C05AC7L)) | (l_513 == l_516))));
        (*l_518) = 0xC9DEEEC2L;
        for (p_50 = 29; (p_50 <= (-23)); p_50 -= 3)
        { /* block id: 340 */
            union U1 l_529 = {-1L};
            union U1 *l_528 = &l_529;
            struct S0 ***l_622 = (void*)0;
            struct S0 ****l_621 = &l_622;
            struct S0 *****l_620 = &l_621;
            struct S0 *l_626 = (void*)0;
            for (l_515.f3 = 0; (l_515.f3 <= 20); l_515.f3++)
            { /* block id: 343 */
                uint32_t l_527 = 18446744073709551613UL;
                int32_t l_573 = 0xDF73C832L;
                if ((((uint16_t)p_50 - (uint16_t)((((uint16_t)p_50 >> (uint16_t)9) >= l_527) < (l_528 != (void*)0))) > (*l_518)))
                { /* block id: 344 */
                    int64_t l_537 = 0x2F1295B1A4478303LL;
                    if (p_50)
                        break;
                    for (l_60 = (-13); (l_60 <= 45); ++l_60)
                    { /* block id: 348 */
                        float l_535 = (-0x8.6p+1);
                        uint16_t l_536 = 0x06E4L;
                        const int32_t *l_538 = &l_515.f4;
                        const int32_t **l_539 = &l_538;
                        (*l_539) = l_518;
                        /* statement id: 349 */
                        assert (l_538 == &l_515.f5);
                    }
                    (*l_518) = l_527;
                    if (p_50)
                        continue;
                }
                else
                { /* block id: 353 */
                    const uint32_t l_545 = 4294967295UL;
                    union U1 ****l_548 = (void*)0;
                    float l_575 = 0x5.EBCB20p+36;
                    float *l_574 = &l_575;
                    for (l_515.f2 = 7; (l_515.f2 < (-15)); l_515.f2 -= 7)
                    { /* block id: 356 */
                        int32_t **l_544 = &l_508;
                        float l_570 = 0x6.794DB2p-95;
                        float *l_569 = &l_570;
                        (*l_518) = __builtin_ffsll(((uint16_t)(l_544 == &l_518) >> (uint16_t)(l_545 & ((*l_518) && p_50))));
                        (*l_569) = ((float)(l_548 != (void*)0) + (float)(((float)(0x4.C15BA1p+76 <= ((float)(((float)((p_50 == 0x3.6269D9p-34) <= ((float)(+((float)(((float)l_527 - (float)p_50) > ((float)0xF.CCF5BBp+44 / (float)((float)((((float)((((!__builtin_bswap64(p_50)) >= l_527) >= p_50) < 0x1.6792E3p+27) / (float)p_50) == l_545) >= l_545) / (float)p_50))) + (float)(*l_518))) / (float)p_50)) + (float)l_529.f2) > 0x0.Bp+1) + (float)p_50)) + (float)p_50) != l_545));
                        (*l_544) = (void*)0;
                    }
                    if (p_50)
                        break;
                    (*l_574) = ((float)l_545 + (float)(__builtin_ctzll(p_50) >= (l_573 < l_545)));
                }
                for (l_512 = 0; (l_512 >= 6); l_512++)
                { /* block id: 366 */
                    uint32_t l_581 = 18446744073709551615UL;
                    int32_t * const l_600 = (void*)0;
                    if (l_529.f2)
                        goto lbl_578;
                    (*l_518) = ((l_529.f1 | l_529.f2) || ((l_529.f0 > p_50) <= ((uint16_t)__builtin_ctz((((*l_518) & __builtin_ia32_crc32qi(p_50, l_581)) | ((int16_t)(l_584 == &l_585) >> (int16_t)10))) << (uint16_t)l_581)));
                    for (l_587.f2 = (-17); (l_587.f2 == (-2)); l_587.f2 += 4)
                    { /* block id: 371 */
                        const uint32_t l_596 = 0UL;
                        float *l_597 = (void*)0;
                        float l_599 = 0x9.7BD63Fp+17;
                        float *l_598 = &l_599;
                        int32_t **l_601 = &l_508;
                        (*l_598) = ((float)((float)(!p_50) - (float)(-(float)(l_596 < 0x6.E15A50p-40))) / (float)0x0.Dp-1);
                        (*l_601) = l_600;
                        (*l_518) = ((int16_t)l_581 + (int16_t)((int16_t)p_50 + (int16_t)((l_581 > ((((p_50 < ((uint16_t)(((int16_t)p_50 + (int16_t)p_50) && (((int32_t)p_50 % (int32_t)((int16_t)((int64_t)((int16_t)(-(uint32_t)l_596) / (int16_t)l_619) - (int64_t)p_50) >> (int16_t)p_50)) >= (*l_518))) << (uint16_t)l_573)) > 0x1565L) || p_50) <= l_527)) && l_529.f0)));
                    }
                }
                l_623 = l_620;
                /* statement id: 377 */
                assert (l_623 == &l_621);
            }
            /* facts after for loop */
            //assert (l_623 == &l_621 || l_623 == &l_624 || l_623 == dangling);
            l_626 = (**l_625);
            /* statement id: 379 */
            assert (l_626 == &l_515);
        }
        /* facts after for loop */
                //assert (l_623 == dangling || l_623 == &l_624);
        (**l_584) = l_627;
        /* statement id: 381 */
        assert (l_586 == &l_628);
    }
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_51(const int16_t  p_52, uint16_t  p_53, int32_t  p_54, uint8_t  p_55)
{ /* block id: 42 */
    int32_t l_62 = (-1L);
    int32_t *l_61 = &l_62;
    int32_t **l_492 = &l_61;
    int32_t *l_493 = &l_62;
    int32_t *l_494 = &l_62;
    int32_t *l_495 = &l_62;
    int32_t *l_496 = &l_62;
    int32_t *l_497 = &l_62;
    int32_t *l_498 = &l_62;
    int32_t *l_499 = &l_62;
    int32_t *l_500 = &l_62;
    int32_t *l_501 = &l_62;
    int32_t *l_502 = &l_62;
    int32_t *l_503 = &l_62;
    int32_t *l_504 = &l_62;
    int32_t *l_505 = &l_62;
    int32_t *l_506 = (void*)0;
    (*l_61) = 2L;
    (*l_492) = func_63(func_66(&l_62), p_53);
    (*l_492) = (*l_492);
    (*l_492) = func_71((**l_492), (**l_492), func_66((*l_492)));
    /* statement id: 330 */
    assert (l_61 == 0);
    return l_506;
    /* statement id: 331 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_63(int32_t * p_64, uint32_t  p_65)
{ /* block id: 224 */
    uint32_t l_365 = 0x813B3EB5L;
    union U1 l_370 = {0x75605277L};
    union U1 *l_369 = &l_370;
    int32_t l_372 = 5L;
    uint64_t l_395 = 0UL;
    struct S0 l_403 = {0xCEL,1L,-1L,-10L,0L,0xC2C11AEEL,1UL,-5112,0x7C4E963F5E78A202LL};
    struct S0 *l_402 = &l_403;
    int32_t *l_406 = &l_372;
    struct S0 **l_452 = &l_402;
    struct S0 ***l_451 = &l_452;
    int16_t l_475 = 0x100CL;
    float l_491 = (-0x6.2p+1);
    float *l_490 = &l_491;
    if (l_365)
    { /* block id: 225 */
        uint32_t l_366 = 0xCB3B7618L;
        const union U1 *l_371 = &l_370;
        int32_t l_381 = 1L;
        (*p_64) = l_366;
        l_372 = ((uint64_t)((0x59F1F8B01E69F638LL & (4294967295UL < (*p_64))) && (l_369 != l_371)) + (uint64_t)__builtin_parity(l_366));
        if (l_370.f2)
        { /* block id: 228 */
            for (p_65 = 0; (p_65 != 35); p_65 += 7)
            { /* block id: 231 */
                uint32_t l_375 = 0x7EAA5562L;
                const int32_t *l_378 = &l_372;
                int32_t *l_380 = &l_372;
                int32_t **l_379 = &l_380;
                (*p_64) = ((0UL ^ (*p_64)) == __builtin_ia32_crc32qi(l_370.f0, (l_375 != ((int64_t)l_375 - (int64_t)p_65))));
                (*l_379) = l_378;
                (*l_379) = func_66(&l_372);
                if (l_381)
                    break;
            }
            return p_64;
            /* statement id: 237 */
            //assert (func_63_rv == &l_62);
        }
        else
        { /* block id: 238 */
            for (l_365 = 0; (l_365 == 34); l_365 += 1)
            { /* block id: 241 */
                int32_t *l_386 = &l_372;
            }
        }
    }
    else
    { /* block id: 246 */
        struct S0 l_390 = {1UL,-1L,0xBC9E5EE9L,-3L,0xCF346CF6L,0x3B8A31F7L,0x03BE8F81L,-5205,0L};
        struct S0 *l_389 = &l_390;
        struct S0 * const *l_388 = &l_389;
        struct S0 * const ** const l_387 = &l_388;
        const int32_t l_400 = 0xF6D9E332L;
        const int32_t *l_455 = &l_390.f2;
lbl_404:
        if ((l_387 == &l_388))
        { /* block id: 247 */
            return p_64;
            /* statement id: 248 */
            //assert (func_63_rv == &l_62);
        }
        else
        { /* block id: 249 */
            uint64_t l_391 = 18446744073709551606UL;
            (*p_64) = ((*p_64) <= 0xCA6B3445L);
            (*p_64) = __builtin_ffsl(((((l_391 < (l_370.f0 >= ((0x32E7B3C1L >= ((0x4B2B7A41L != l_365) > (+(((l_395 != (((*p_64) > ((uint16_t)((int64_t)(l_400 || p_65) - (int64_t)0xC1BEB3E65D378556LL) << (uint16_t)p_65)) || p_65)) || l_400) < l_365)))) != p_65))) && (-9L)) | l_390.f2) < l_400));
        }
        if ((*p_64))
        { /* block id: 253 */
            struct S0 *l_401 = &l_390;
            int32_t **l_405 = (void*)0;
            const int32_t l_413 = 0xF7E6AA0FL;
            struct S0 *l_428 = &l_390;
            union U1 * const **l_444 = (void*)0;
            l_402 = l_401;
            /* statement id: 254 */
            assert (l_402 == &l_390);
            if (l_370.f0)
                goto lbl_404;
            l_406 = p_64;
            /* statement id: 256 */
            //assert (l_406 == &l_62);
            for (l_395 = (-10); (l_395 == 46); ++l_395)
            { /* block id: 259 */
                uint8_t l_420 = 0x4EL;
                if (((uint32_t)__builtin_popcountll(l_390.f4) / (uint32_t)__builtin_popcountl(((*l_406) | ((__builtin_ffs((*p_64)) != (p_65 > ((((uint16_t)l_413 >> (uint16_t)1) == ((int64_t)p_65 / (int64_t)((uint16_t)(p_65 & p_65) + (uint16_t)0xD9F6L))) < 0x1C7195CBL))) == 1UL)))))
                { /* block id: 260 */
                    uint16_t l_427 = 0xF297L;
                    for (l_390.f2 = (-10); (l_390.f2 > (-18)); l_390.f2--)
                    { /* block id: 263 */
                        (*l_406) = l_420;
                        (*p_64) = ((int16_t)(((int16_t)((int16_t)__builtin_bswap32(l_427) / (int16_t)__builtin_popcount(p_65)) << (int16_t)6) && __builtin_popcountll(l_420)) % (int16_t)__builtin_popcountl(p_65));
                    }
                    if (l_420)
                        break;
                    (*p_64) = (p_65 > l_427);
                }
                else
                { /* block id: 269 */
                    int32_t **l_432 = &l_406;
                    if ((l_428 != l_428))
                    { /* block id: 270 */
                        (*p_64) = (*p_64);
                    }
                    else
                    { /* block id: 272 */
                        union U1 * const l_429 = &l_370;
                        const union U1 *l_431 = &l_370;
                        const union U1 **l_430 = &l_431;
                        (*l_430) = l_429;
                    }
                    (*l_432) = p_64;
                    if ((*p_64))
                        break;
                    for (l_390.f4 = 0; (l_390.f4 != (-17)); --l_390.f4)
                    { /* block id: 279 */
                        int32_t l_441 = 1L;
                        (**l_432) = (0x7F358C7D61086BC3LL <= ((uint16_t)(((uint64_t)p_65 - (uint64_t)((uint16_t)l_441 - (uint16_t)((((__builtin_ffsl(p_65) & ((int16_t)0xC7C9L >> (int16_t)15)) <= (p_65 <= (l_444 != (void*)0))) >= p_65) && l_441))) != (*l_406)) >> (uint16_t)p_65));
                        return p_64;
                        /* statement id: 281 */
                        //assert (func_63_rv == &l_62);
                    }
                }
            }
        }
        else
        { /* block id: 285 */
            int32_t l_450 = 0x6C397C8AL;
            struct S0 ** const **l_453 = (void*)0;
            struct S0 ****l_454 = &l_451;
            (*p_64) = (((*l_387) != &l_402) <= ((-(uint64_t)((__builtin_ctzll((*l_406)) ^ (*l_406)) > p_65)) & ((((((int32_t)((uint16_t)l_450 << (uint16_t)((*l_387) != (*l_387))) - (int32_t)l_390.f0) < (*l_406)) <= 0x296EL) != 1UL) == p_65)));
            (*l_454) = l_451;
            l_455 = &l_400;
            /* statement id: 288 */
            assert (l_455 == &l_400);
            for (l_365 = 19; (l_365 >= 32); l_365 += 6)
            { /* block id: 291 */
                int32_t l_458 = 0x0481DE10L;
                uint32_t l_481 = 18446744073709551615UL;
            }
        }
        /* facts after branching */
        //assert (l_406 == &l_372 || l_406 == &l_62);
        assert (l_455 == &l_400 || l_455 == &l_390.f2);
    }
    /* facts after branching */
    //assert (l_402 == dangling || l_402 == &l_403);
    //assert (l_406 == &l_372 || l_406 == &l_62);
    (*l_490) = ((float)(*l_406) - (float)((float)((float)0x1.Dp+1 + (float)(((((float)(p_65 > p_65) - (float)(*l_406)) > ((void*)0 != p_64)) != (*l_406)) == p_65)) - (float)0x1.7p-1));
    return p_64;
    /* statement id: 327 */
    //assert (func_63_rv == &l_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_66(int32_t * p_67)
{ /* block id: 44 */
    int32_t l_68 = 0L;
    for (l_68 = (-7); (l_68 <= (-1)); l_68 += 1)
    { /* block id: 47 */
        float l_75 = 0x5.88B149p+10;
        int32_t *l_76 = &l_68;
        int32_t **l_364 = &l_76;
        (*l_364) = func_71(l_68, ((void*)0 == l_76), &l_68);
        /* statement id: 221 */
        assert (l_76 == 0);
    }
    return p_67;
    /* statement id: 223 */
    //assert (func_66_rv == &l_62 || func_66_rv == &l_372 || func_66_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_62
 * writes:
 */
inline static int32_t * func_71(int16_t  p_72, int64_t  p_73, const int32_t * p_74)
{ /* block id: 48 */
    int64_t l_77 = 0x83DCDCBD5F5AB95DLL;
    struct S0 l_79 = {1UL,-10L,0xD55A9D45L,-10L,0L,0x86225270L,0x104E0BBEL,12640,1L};
    struct S0 *l_78 = &l_79;
    struct S0 **l_80 = &l_78;
    int32_t *l_128 = (void*)0;
    union U1 l_145 = {-8L};
    union U1 *l_144 = &l_145;
    union U1 **l_183 = (void*)0;
    union U1 ***l_182 = &l_183;
    int32_t *l_235 = &l_79.f2;
    int32_t *l_259 = &l_79.f2;
    struct S0 ***l_337 = (void*)0;
    struct S0 ****l_336 = &l_337;
    l_77 = 0xD.A47399p-55;
lbl_127:
    (*l_80) = l_78;
    if (__builtin_ctzl(p_72))
    { /* block id: 51 */
        int32_t l_83 = (-5L);
        int32_t l_100 = 4L;
        union U1 l_133 = {-6L};
        union U1 *l_132 = &l_133;
        uint32_t l_134 = 4294967295UL;
        struct S0 *l_156 = &l_79;
        int32_t *l_158 = &l_79.f4;
        if ((((uint32_t)((*p_74) || l_83) - (uint32_t)(((int16_t)((((((uint32_t)((uint64_t)(((int16_t)((9UL == ((int16_t)p_72 << (int16_t)10)) == (((int64_t)(((uint16_t)l_83 >> (uint16_t)13) & ((uint64_t)p_73 + (uint64_t)p_72)) / (int64_t)__builtin_popcountl((l_79.f3 || ((p_73 || p_72) ^ l_83)))) || 0x909801C16B31B79ELL)) >> (int16_t)9) <= 0xB453F477L) / (uint64_t)l_77) / (uint32_t)3L) | (*p_74)) & (*p_74)) != l_79.f2) > l_79.f4) << (int16_t)1) != l_100)) | 0UL))
        { /* block id: 52 */
            float l_102 = (-0x9.Bp-1);
            float *l_101 = &l_102;
            (*l_101) = p_72;
            if (l_79.f2)
                goto lbl_153;
        }
        else
        { /* block id: 54 */
            float l_108 = 0x2.326B30p+51;
            float *l_107 = &l_108;
            int32_t *l_110 = &l_79.f4;
            int32_t **l_109 = &l_110;
            int32_t ** const l_126 = &l_110;
            union U1 *l_129 = (void*)0;
            (*l_107) = ((float)(p_73 > (__builtin_ffsl(((uint64_t)l_79.f7 % (uint64_t)p_73)) > p_72)) - (float)p_73);
            (*l_109) = (void*)0;
            /* statement id: 56 */
            assert (l_110 == 0);
            if ((((uint16_t)((uint16_t)(((uint16_t)l_77 + (uint16_t)l_79.f0) && 0xDD171CF63D7CB689LL) << (uint16_t)((uint64_t)(~(l_79.f5 != ((uint16_t)((int16_t)((int16_t)0L >> (int16_t)(l_126 == (void*)0)) << (int16_t)p_73) >> (uint16_t)((l_77 != 0x0B1A556116ABE3F1LL) && 0x5A17L)))) - (uint64_t)p_73)) >> (uint16_t)4) | 0xADD0F33DL))
            { /* block id: 57 */
                if (l_79.f2)
                    goto lbl_127;
                return l_128;
                /* statement id: 59 */
                //assert (func_71_rv == 0);
            }
            else
            { /* block id: 60 */
                (*l_107) = p_73;
                l_129 = l_129;
            }
            l_134 = ((int16_t)(__builtin_ffsl(p_72) >= l_100) - (int16_t)(l_129 == l_132));
        }
lbl_153:
        for (p_72 = 12; (p_72 > (-30)); p_72--)
        { /* block id: 68 */
            uint32_t l_143 = 8UL;
            int32_t *l_152 = &l_79.f4;
            l_79.f2 = (((uint16_t)p_73 << (uint16_t)p_72) != ((int64_t)((((uint64_t)0x4120E74272ABD0CELL - (uint64_t)l_143) == (p_73 ^ (((void*)0 != l_144) != ((int64_t)((int32_t)(l_100 | (((uint32_t)(0xAAA5L || 65532UL) - (uint32_t)p_72) ^ 0UL)) + (int32_t)(*p_74)) - (int64_t)p_73)))) || l_143) % (int64_t)l_143));
            return l_128;
            /* statement id: 70 */
            //assert (func_71_rv == 0);
        }
        (*l_158) = ((((l_133.f1 && p_72) & ((uint64_t)((p_72 & (((void*)0 == &l_133) && l_100)) ^ ((l_156 == (*l_80)) && (~__builtin_bswap64(l_79.f8)))) - (uint64_t)0x6E95652091CAA3E2LL)) < 65534UL) >= l_133.f2);
    }
    else
    { /* block id: 74 */
        int16_t l_161 = 0L;
        struct S0 * const *l_174 = &l_78;
        const int32_t *l_178 = &l_79.f5;
        int32_t *l_184 = &l_79.f2;
        union U1 * const *l_216 = &l_144;
        union U1 * const **l_215 = &l_216;
        int32_t l_240 = 0xB4FEF38AL;
    }
    for (p_72 = 12; (p_72 > 28); ++p_72)
    { /* block id: 215 */
        uint32_t l_354 = 1UL;
        union U1 ****l_358 = &l_182;
        int32_t **l_361 = (void*)0;
        int32_t **l_362 = &l_235;
        int32_t *l_363 = (void*)0;
        (*l_259) = (l_354 != ((int16_t)(-(uint32_t)(l_358 != &l_182)) / (int16_t)((int32_t)((0xD0AE36DBBD370A9BLL > ((((*p_74) & __builtin_clzl(p_73)) ^ 0UL) <= ((((*p_74) != (*l_235)) & 2UL) && (*l_235)))) & (*l_259)) + (int32_t)1UL)));
        (*l_362) = p_74;
        /* statement id: 217 */
        //assert (l_235 == &l_68 || l_235 == &l_62 || l_235 == &l_458 || l_235 == &l_515.f4);
        return l_363;
        /* statement id: 218 */
        //assert (func_71_rv == 0);
    }
    return l_128;
    /* statement id: 220 */
    //assert (func_71_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 181
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 18
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 9
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 4
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 124
   depth: 2, occurrence: 25
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 5
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 196

XXX times a variable address is taken: 186
XXX times a pointer is dereferenced on RHS: 77
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 90
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 673

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 349
   level: 2, occurrence: 39
   level: 3, occurrence: 0
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 91
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 26
XXX average alias set size: 1.21

XXX times a non-volatile is read: 656
XXX times a non-volatile is write: 245
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 22
   depth: 2, occurrence: 24
   depth: 3, occurrence: 12
   depth: 4, occurrence: 17
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 14.6
XXX percentage an existing variable is used: 85.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

