/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2722340952
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static int32_t  func_2(int32_t  p_3);
inline static int32_t * func_7(int16_t  p_8);
static uint8_t  func_17(int32_t * p_18, uint16_t  p_19, const int32_t * p_20, uint32_t  p_21, int32_t * p_22);
static int32_t * func_23(int32_t * p_24, int16_t  p_25, int32_t * p_26, int32_t * p_27, uint16_t  p_28);
inline static int32_t * func_29(const uint8_t  p_30, uint16_t  p_31, int32_t * p_32);
static const int32_t * func_38(int32_t * const  p_39, union U0  p_40);
inline static union U0  func_41(int32_t * p_42, const int16_t  p_43);
static int32_t * func_44(uint32_t  p_45);
static int16_t  func_56(const int32_t  p_57, int32_t  p_58, int32_t * p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_4 = 2U;
    int32_t l_6 = (-1);
    int32_t *l_5 = &l_6;
    int32_t l_12 = 2;
    int32_t **l_540 = &l_5;
    (*l_5) = func_2(l_4);
    (*l_540) = func_7(((*l_5) && ((func_2((&l_6 != &l_6)) && (safe_sub_func_int16_t_s_s((-6), ((~0) >= (func_2(l_12) > 0xD78F))))) >= (-1))));
    /* statement id: 181 */
    assert (l_5 == 0);
    (*l_540) = (void*)0;
    (*l_540) = (void*)0;
    return l_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_2(int32_t  p_3)
{ /* block id: 1 */
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_7(int16_t  p_8)
{ /* block id: 4 */
    int32_t l_14 = (-2);
    int32_t *l_13 = &l_14;
    int32_t l_452 = 0x3BD7D680;
    int32_t l_537 = 1;
    int32_t *l_538 = &l_537;
    int32_t *l_539 = (void*)0;
    (*l_13) = p_8;
    (*l_13) = func_2((safe_lshift_func_uint8_t_u_s(func_17(func_23(func_29((*l_13), (*l_13), &l_14), p_8, l_13, l_13, p_8), l_452, &l_452, p_8, &l_452), 4)));
    (*l_13) = (safe_rshift_func_int16_t_s_s((((safe_lshift_func_int8_t_s_u(((*l_13) <= (safe_div_func_uint32_t_u_u((*l_13), (*l_13)))), 1)) || (0U <= ((p_8 ^ (((*l_13) && (((safe_rshift_func_uint16_t_u_u(((*l_13) | ((safe_sub_func_int8_t_s_s((0x9409 && ((p_8 == (*l_13)) == (*l_13))), (-1))) & 65534U)), (*l_13))) > 1) != p_8)) ^ l_537)) != (*l_13)))) != 0xE48DDDB4), 9));
    return l_539;
    /* statement id: 180 */
    //assert (func_7_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_17(int32_t * p_18, uint16_t  p_19, const int32_t * p_20, uint32_t  p_21, int32_t * p_22)
{ /* block id: 168 */
    union U0 l_458 = {0x920D};
    union U0 *l_457 = &l_458;
    union U0 **l_456 = &l_457;
    union U0 ***l_455 = &l_456;
    union U0 **** const l_454 = &l_455;
    union U0 **** const *l_453 = &l_454;
    int32_t l_479 = 0xF7C56E56;
    int32_t *l_478 = &l_479;
    int8_t l_488 = 0x45;
    int32_t **l_524 = &l_478;
    l_453 = l_453;
    if ((safe_sub_func_int8_t_s_s((255U | ((void*)0 != p_18)), (safe_rshift_func_uint8_t_u_u((safe_unary_minus_func_uint16_t_u(4U)), 2)))))
    { /* block id: 170 */
        union U0 **l_476 = &l_457;
        int32_t l_477 = (-1);
        uint32_t l_501 = 1U;
        p_22 = func_29(((safe_rshift_func_int16_t_s_s((((safe_div_func_int8_t_s_s(l_458.f0, l_458.f0)) ^ (((safe_lshift_func_uint8_t_u_u(p_21, 3)) != (safe_add_func_uint32_t_u_u((safe_add_func_uint32_t_u_u(p_21, ((l_476 == (void*)0) != p_21))), (l_476 != (void*)0)))) < 7)) && p_21), p_19)) > l_477), l_477, l_478);
        /* statement id: 171 */
        assert (p_22 == &l_479);
        l_478 = func_29(((safe_add_func_int32_t_s_s(((*p_20) >= (safe_add_func_int16_t_s_s((safe_lshift_func_int8_t_s_s((safe_lshift_func_int8_t_s_s(l_488, p_21)), 5)), (safe_rshift_func_uint8_t_u_u(p_19, 1))))), (*l_478))) < (safe_div_func_int16_t_s_s((4294967294U != (safe_div_func_uint32_t_u_u((safe_add_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(1U, (safe_rshift_func_uint16_t_u_u((((void*)0 == &l_454) && p_21), l_501)))) <= (*l_478)), 0xC0B1)), (*p_18)))), p_21))), p_21, p_18);
        /* statement id: 172 */
        //assert (l_478 == &l_14);
    }
    else
    { /* block id: 173 */
        int32_t l_518 = 0x553A083E;
        int8_t l_523 = 0x1C;
        (*p_22) = ((safe_sub_func_uint8_t_u_u((safe_rshift_func_int16_t_s_u((0x9F94B34C <= (p_19 > (safe_sub_func_uint16_t_u_u(((safe_rshift_func_uint8_t_u_s(((safe_lshift_func_int8_t_s_u((safe_add_func_uint8_t_u_u((((p_19 && (safe_lshift_func_uint8_t_u_s((l_518 & (safe_div_func_int8_t_s_s(p_21, (safe_div_func_uint8_t_u_u(l_518, l_523))))), p_21))) & 0U) & 5U), (*l_478))), 7)) < (*l_478)), 7)) && l_518), l_518)))), l_523)), p_21)) != l_518);
    }
    /* facts after branching */
    //assert (p_22 == &l_452 || p_22 == &l_479);
    //assert (l_478 == &l_479 || l_478 == &l_14);
    (*l_524) = &l_479;
    /* statement id: 176 */
    assert (l_478 == &l_479);
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_23(int32_t * p_24, int16_t  p_25, int32_t * p_26, int32_t * p_27, uint16_t  p_28)
{ /* block id: 165 */
    int32_t l_450 = 0xB7B0CE8A;
    int32_t *l_449 = &l_450;
    int32_t *l_451 = &l_450;
    l_449 = l_449;
    return p_26;
    /* statement id: 167 */
    //assert (func_23_rv == &l_14);
}


/* ------------------------------------------ */
/* 
 * reads : l_14
 * writes: l_14
 */
inline static int32_t * func_29(const uint8_t  p_30, uint16_t  p_31, int32_t * p_32)
{ /* block id: 6 */
    int32_t l_47 = 2;
    int32_t *l_46 = &l_47;
    union U0 l_411 = {1};
    union U0 *l_410 = &l_411;
    union U0 * const *l_409 = &l_410;
    union U0 * const **l_408 = &l_409;
    union U0 * const ***l_407 = &l_408;
    int32_t * const *l_419 = &l_46;
    int32_t * const **l_418 = &l_419;
    int32_t * const ***l_417 = &l_418;
    union U0 **l_428 = &l_410;
    int32_t **l_429 = &l_46;
    const int32_t * const l_447 = &l_47;
    const int32_t * const * const l_446 = &l_447;
    const int32_t * const * const * const l_445 = &l_446;
    const int32_t * const * const * const *l_444 = &l_445;
    uint32_t l_448 = 0x9757676A;
    for (p_31 = 0; (p_31 >= 12); ++p_31)
    { /* block id: 9 */
        int32_t l_35 = 9;
        const int32_t ***l_396 = (void*)0;
        const int32_t ****l_395 = &l_396;
        const union U0 * const **l_414 = (void*)0;
        const union U0 * const ***l_413 = &l_414;
        const union U0 * const ****l_412 = &l_413;
        for (l_35 = 7; (l_35 > (-26)); l_35 = safe_sub_func_uint8_t_u_u(l_35, 1))
        { /* block id: 12 */
            int32_t *l_48 = &l_35;
            int32_t **l_394 = &l_46;
            int32_t ***l_399 = (void*)0;
            int32_t ****l_398 = &l_399;
            int32_t *****l_397 = &l_398;
            (*l_394) = func_38(p_32, func_41(func_44((l_46 == l_48)), ((p_32 == p_32) < (((((safe_add_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((*l_48), (((*l_48) & (safe_lshift_func_uint16_t_u_u(p_30, (*l_48)))) ^ l_35))), p_31)) > (*l_48)) && l_35) | p_31) == 0xD7BF))));
            /* statement id: 147 */
            assert (l_46 == 0);
            (*l_397) = l_395;
            /* statement id: 148 */
            assert (l_398 == &l_396);
        }
        (*p_32) = (~((safe_mod_func_uint16_t_u_u(0xFF82, l_47)) != (p_31 || (((p_31 || ((65532U & ((0x87 && (((safe_add_func_int8_t_s_s((-1), ((-4) | p_30))) && (*p_32)) ^ l_47)) <= (-2))) ^ 0x04AD9498)) && p_31) <= 0xD0A8))));
        (*l_412) = l_407;
        /* statement id: 151 */
        assert (l_413 == &l_408);
        for (l_47 = (-3); (l_47 == (-18)); l_47 = safe_sub_func_int8_t_s_s(l_47, 3))
        { /* block id: 154 */
            int32_t * const * const *l_422 = (void*)0;
            int32_t * const * const **l_421 = &l_422;
            int32_t * const * const ***l_420 = &l_421;
            int32_t **l_423 = &l_46;
            (*l_420) = l_417;
            /* statement id: 155 */
            assert (l_421 == &l_418);
            (*l_423) = (*l_419);
            (*l_423) = p_32;
            /* statement id: 157 */
            //assert (l_46 == &l_14 || l_46 == &l_479);
            l_46 = func_44(((((**l_420) == (*l_421)) == (safe_lshift_func_int16_t_s_s(0xEE52, 0))) | (0x8443DA25 | (p_31 ^ ((safe_lshift_func_int8_t_s_s(p_31, (((***l_418) > (****l_417)) <= ((***l_418) ^ 0x006B99CC)))) || (*p_32))))));
            /* statement id: 158 */
            assert (l_46 == 0);
        }
    }
    /* facts after for loop */
    assert (l_46 == 0 || l_46 == &l_47);
    (*l_428) = (**l_408);
    (*l_429) = func_38(p_32, (***l_408));
    /* statement id: 162 */
    assert (l_46 == 0);
    (*p_32) = (safe_mod_func_uint32_t_u_u(0xE857C816, ((safe_add_func_uint8_t_u_u((safe_rshift_func_uint8_t_u_u(0U, (safe_mod_func_uint32_t_u_u((safe_div_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(((((*l_407) == (*l_407)) != (safe_lshift_func_uint16_t_u_u(((void*)0 == l_444), (&l_418 != (void*)0)))) >= (l_448 == 0x6E)), p_30)), (****l_444))), p_30)))), p_31)) | p_30)));
    return p_32;
    /* statement id: 164 */
    //assert (func_29_rv == &l_14 || func_29_rv == &l_479);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_38(int32_t * const  p_39, union U0  p_40)
{ /* block id: 145 */
    const int32_t l_391 = 0x057D3ECD;
    const int32_t *l_390 = &l_391;
    const int32_t *l_392 = &l_391;
    const int32_t *l_393 = (void*)0;
    return l_393;
    /* statement id: 146 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_41(int32_t * p_42, const int16_t  p_43)
{ /* block id: 121 */
    int32_t l_334 = 0xD784363F;
    int32_t *l_333 = &l_334;
    uint32_t l_335 = 0U;
    uint32_t l_337 = 0x9F2B8033;
    int32_t ***l_343 = (void*)0;
    int32_t ****l_342 = &l_343;
    union U0 *l_356 = (void*)0;
    uint8_t l_368 = 255U;
    union U0 **l_380 = &l_356;
    union U0 ***l_379 = &l_380;
    union U0 ****l_378 = &l_379;
    union U0 l_389 = {0xDD05};
    if ((((l_333 == &l_334) && (l_335 && (safe_unary_minus_func_int32_t_s(1)))) | ((l_337 > (((&l_334 != &l_334) ^ (*l_333)) & (((safe_mod_func_int16_t_s_s(((safe_rshift_func_int8_t_s_u(p_43, 1)) ^ p_43), 0xFD47)) != p_43) & p_43))) & 0xE7C32A7B)))
    { /* block id: 122 */
        int32_t *l_354 = (void*)0;
        int32_t **l_355 = &l_354;
        (*l_333) = ((void*)0 == l_342);
        p_42 = (void*)0;
        for (l_335 = 0; (l_335 > 32); l_335 = safe_add_func_int16_t_s_s(l_335, 1))
        { /* block id: 127 */
            int8_t l_348 = 3;
            const int32_t *l_353 = &l_334;
            const int32_t **l_352 = &l_353;
            for (l_334 = 0; (l_334 > (-28)); l_334 = safe_sub_func_int8_t_s_s(l_334, 6))
            { /* block id: 130 */
                int32_t l_351 = 0x0EBA9AE2;
                int32_t *l_350 = &l_351;
                l_348 = (p_43 <= (*l_333));
                (*l_350) = (safe_unary_minus_func_int32_t_s(0x513BAED3));
            }
            (*l_352) = (void*)0;
            /* statement id: 134 */
            assert (l_353 == 0);
        }
        (*l_355) = l_354;
    }
    else
    { /* block id: 137 */
        union U0 **l_357 = &l_356;
        int32_t l_362 = 0x1140D0F7;
        int32_t ** const **l_377 = (void*)0;
        (*l_357) = l_356;
        (*l_333) = (l_356 == (*l_357));
        (*l_333) = ((((safe_div_func_uint8_t_u_u((safe_add_func_int32_t_s_s(l_362, (-9))), (safe_sub_func_int8_t_s_s((!(safe_div_func_uint16_t_u_u(l_368, l_362))), (safe_add_func_int32_t_s_s((safe_div_func_int16_t_s_s(((((safe_mod_func_uint32_t_u_u(((void*)0 == &l_343), (safe_lshift_func_uint16_t_u_s((l_362 ^ ((((void*)0 == l_377) == p_43) == 8)), p_43)))) || (*l_333)) != (*l_333)) == 0x75), 0x1473)), 0x65B612D4)))))) || p_43) >= (*l_333)) > p_43);
    }
    (*l_378) = (void*)0;
    /* statement id: 142 */
    assert (l_379 == 0);
    (*l_333) = (((p_43 != p_43) || (((safe_rshift_func_uint8_t_u_s((0 ^ (safe_mod_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u((-1), 1)), p_43))), 7)) <= ((p_43 == 4294967295U) & (p_43 || (safe_mod_func_int32_t_s_s((-1), 0x60F0752A))))) == p_43)) != p_43);
    return l_389;
    /* statement id: 144 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(uint32_t  p_45)
{ /* block id: 13 */
    int8_t l_51 = (-1);
    union U0 l_235 = {0};
    union U0 *l_234 = &l_235;
    int32_t l_293 = 0;
    uint16_t l_300 = 0U;
    int32_t *l_306 = &l_293;
    int32_t * const *l_305 = &l_306;
    int32_t * const **l_304 = &l_305;
    uint16_t l_316 = 0x4F03;
    int32_t *l_318 = &l_293;
    int32_t *l_319 = &l_293;
    int32_t *l_320 = &l_293;
    int32_t *l_321 = &l_293;
    int32_t *l_322 = &l_293;
    int32_t *l_323 = &l_293;
    int32_t *l_324 = (void*)0;
    for (p_45 = 0; (p_45 > 28); ++p_45)
    { /* block id: 16 */
        int32_t l_54 = 0x5BB5FB49;
        int8_t l_55 = 0x53;
        union U0 *l_254 = &l_235;
        int32_t *l_297 = (void*)0;
        int32_t **l_296 = &l_297;
        if (((p_45 || func_2((l_51 ^ 0U))) < (safe_rshift_func_int16_t_s_u(l_54, (l_55 || (func_56((((safe_rshift_func_int16_t_s_s(((((l_51 != (safe_rshift_func_uint16_t_u_s((safe_sub_func_uint16_t_u_u(l_54, (safe_sub_func_uint8_t_u_u(l_51, l_51)))), p_45))) ^ p_45) >= p_45) | 1), 9)) < l_55) == p_45), l_51, &l_54) > 0x8A7A))))))
        { /* block id: 63 */
            int32_t *l_211 = &l_54;
            int32_t **l_212 = &l_211;
            union U0 *l_237 = &l_235;
            if (l_51)
                break;
            (*l_212) = l_211;
            for (l_55 = 0; (l_55 < (-17)); l_55 = safe_sub_func_uint8_t_u_u(l_55, 1))
            { /* block id: 68 */
                int32_t *l_236 = (void*)0;
                int32_t l_242 = 9;
                int8_t l_253 = 0;
                union U0 * const l_287 = (void*)0;
                int32_t l_294 = 0x6D5457A2;
            }
            (*l_211) = (l_300 & p_45);
        }
        else
        { /* block id: 108 */
            int32_t *l_301 = &l_293;
            (*l_296) = l_301;
            /* statement id: 109 */
            assert (l_297 == &l_293);
            (*l_296) = l_301;
            for (l_54 = 18; (l_54 < (-12)); l_54 = safe_sub_func_uint8_t_u_u(l_54, 6))
            { /* block id: 113 */
                int32_t ***l_308 = &l_296;
                int32_t ****l_307 = &l_308;
                (*l_297) = p_45;
                (*l_307) = l_304;
                /* statement id: 115 */
                assert (l_308 == &l_305);
            }
        }
        /* facts after branching */
        assert (l_297 == &l_293 || l_297 == 0);
        (*l_306) = (safe_add_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_s(p_45, ((0U || (safe_sub_func_int32_t_s_s(0, p_45))) == p_45))) < (safe_unary_minus_func_uint8_t_u(((***l_304) | l_316)))), (~(**l_305))));
    }
    return l_324;
    /* statement id: 120 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_56(const int32_t  p_57, int32_t  p_58, int32_t * p_59)
{ /* block id: 17 */
    int32_t l_79 = 0;
    int32_t *l_78 = &l_79;
    int32_t l_91 = 0x3A6950E6;
    uint8_t l_92 = 0x17;
    int16_t l_173 = 0;
    int32_t **l_174 = (void*)0;
    int32_t **l_175 = &l_78;
    int32_t l_203 = 1;
    union U0 l_207 = {0xB3D6};
    union U0 *l_206 = &l_207;
    uint8_t l_210 = 6U;
    for (p_58 = 3; (p_58 > 13); ++p_58)
    { /* block id: 20 */
        uint32_t l_80 = 0x06CBC8CA;
        int32_t *l_153 = &l_79;
        int32_t l_154 = 0x355696F0;
        if (((safe_div_func_uint16_t_u_u((p_58 ^ ((safe_add_func_int16_t_s_s((safe_add_func_int8_t_s_s(((safe_sub_func_int8_t_s_s((l_78 == &l_79), l_80)) | ((safe_sub_func_uint32_t_u_u(l_80, (l_80 > (safe_rshift_func_int8_t_s_s((safe_div_func_int8_t_s_s((safe_div_func_uint16_t_u_u(((safe_add_func_int8_t_s_s(((*l_78) <= p_58), ((void*)0 != &p_57))) <= l_80), p_58)), l_91)), l_80))))) < l_92)), 0U)), (*l_78))) || 0x4C)), p_58)) < l_80))
        { /* block id: 21 */
            int32_t l_105 = (-6);
            int32_t *l_111 = &l_79;
            uint16_t l_135 = 65530U;
            if ((safe_unary_minus_func_uint16_t_u((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint32_t_u_u(((&l_79 == (void*)0) > (safe_rshift_func_int16_t_s_u((65526U != 0), ((((4294967295U && ((&p_58 == &p_57) && ((safe_unary_minus_func_uint32_t_u((((safe_mod_func_uint32_t_u_u((*l_78), (safe_mod_func_uint16_t_u_u(65526U, l_105)))) >= (*l_78)) <= 8))) < l_80))) & 6) && 1U) && 0xBD24A170)))), l_80)), 4)))))
            { /* block id: 22 */
                uint32_t l_110 = 0xA7AF0C8B;
                const int32_t *l_116 = &l_79;
                int32_t l_136 = 0x76C5754D;
                if ((safe_add_func_int8_t_s_s(l_105, (safe_sub_func_uint8_t_u_u(l_110, (l_111 != &l_79))))))
                { /* block id: 23 */
                    return p_58;
                }
                else
                { /* block id: 25 */
                    int32_t *l_134 = &l_79;
                    if ((&l_79 != (void*)0))
                    { /* block id: 26 */
                        return p_58;
                    }
                    else
                    { /* block id: 28 */
                        (*l_111) = (safe_mod_func_int8_t_s_s((safe_add_func_int32_t_s_s(((void*)0 == l_116), l_80)), (safe_div_func_int32_t_s_s((safe_sub_func_int16_t_s_s((p_57 ^ ((safe_unary_minus_func_int32_t_s((safe_lshift_func_int8_t_s_u(p_58, (safe_lshift_func_uint8_t_u_s((safe_mod_func_int32_t_s_s((0x19C35E3C <= p_57), (*p_59))), 0)))))) != (safe_rshift_func_uint16_t_u_s(((*l_111) >= p_57), p_58)))), (-1))), 0xD4F06586))));
                        (*l_134) = (((&p_58 != l_116) <= (((0 < 0x17E41AB8) ^ p_58) && (((void*)0 != &p_57) | (((safe_sub_func_uint32_t_u_u(((&l_79 != l_134) ^ p_57), p_57)) && (*l_78)) >= p_58)))) ^ l_135);
                        p_59 = &l_79;
                        /* statement id: 31 */
                        assert (p_59 == &l_79);
                        l_136 = (*p_59);
                    }
                    /* facts after branching */
                    assert (p_59 == &l_79);
                    (*l_78) = (safe_sub_func_int8_t_s_s((safe_lshift_func_int8_t_s_u(((-5) >= ((safe_lshift_func_int8_t_s_s((-1), 6)) & l_80)), p_57)), 255U));
                    (*p_59) = (safe_sub_func_uint8_t_u_u(p_57, p_58));
                }
                /* facts after branching */
                assert (p_59 == &l_79);
                (*l_78) = (safe_sub_func_uint8_t_u_u(0x37, ((safe_div_func_int8_t_s_s(((((safe_lshift_func_uint16_t_u_u(p_58, (p_57 | 65535U))) < 0xEAEEF4A5) & (0 != (safe_add_func_uint8_t_u_u((*l_116), (l_153 == &l_136))))) && p_57), 255U)) > 0xB1B1)));
            }
            else
            { /* block id: 38 */
                return p_57;
            }
            /* facts after branching */
            assert (p_59 == &l_79);
            return l_154;
        }
        else
        { /* block id: 42 */
            uint32_t l_163 = 0x2DBF0B25;
            (*l_78) = ((safe_add_func_uint8_t_u_u((((safe_div_func_int32_t_s_s((safe_mod_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s((*l_153), ((*p_59) == p_57))) & l_163), (((safe_lshift_func_uint8_t_u_u((safe_sub_func_int16_t_s_s((0x6A2D9A96 < (safe_rshift_func_uint16_t_u_u(l_163, p_58))), ((*p_59) > ((safe_mod_func_uint32_t_u_u((~(l_163 && 0x14)), (*l_153))) >= l_163)))), l_163)) && (*l_78)) || (*l_153)))), 0x35754D72)) & (-1)) > l_173), p_57)) | 0xFD6E9342);
        }
    }
    (*l_175) = &p_57;
    /* statement id: 46 */
    assert (l_78 == &p_57);
    for (p_58 = 0; (p_58 == (-6)); p_58 = safe_sub_func_int8_t_s_s(p_58, 7))
    { /* block id: 49 */
        int16_t l_184 = 0x6A4D;
        const int32_t *l_201 = &l_79;
        union U0 *l_208 = &l_207;
        if ((safe_mod_func_int32_t_s_s((safe_mod_func_uint32_t_u_u(0xE7FF6F2D, (safe_sub_func_uint32_t_u_u(((0x29FA7991 < l_184) >= ((p_58 < ((safe_rshift_func_int16_t_s_s(((safe_add_func_uint8_t_u_u(((((safe_mod_func_int8_t_s_s((safe_div_func_int16_t_s_s(p_57, (safe_lshift_func_uint8_t_u_s((safe_add_func_int16_t_s_s(((safe_lshift_func_int16_t_s_s(((safe_add_func_int8_t_s_s((-7), (&p_57 != l_201))) >= (!((*l_201) != (*p_59)))), p_58)) || p_57), 0x615D)), 1)))), (*l_201))) < (*l_201)) | 0U) == p_58), p_57)) >= p_57), l_203)) & (-8))) && 0x30)), 0xBCE11112)))), 0x208590E4)))
        { /* block id: 50 */
            if ((*l_201))
                break;
        }
        else
        { /* block id: 52 */
            int32_t *l_209 = (void*)0;
            for (l_184 = 0; (l_184 >= (-7)); l_184--)
            { /* block id: 55 */
                l_208 = l_206;
                (*l_175) = l_209;
                /* statement id: 57 */
                assert (l_78 == 0);
            }
            /* facts after for loop */
            assert (l_78 == 0 || l_78 == &p_57);
        }
        /* facts after branching */
        assert (l_78 == 0 || l_78 == &p_57);
        return p_57;
    }
    return l_210;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 89
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 4
   depth: 21, occurrence: 2
   depth: 25, occurrence: 1

XXX total number of pointers: 108

XXX times a variable address is taken: 110
XXX times a pointer is dereferenced on RHS: 70
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 52
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 310

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 169
   level: 2, occurrence: 22
   level: 3, occurrence: 15
   level: 4, occurrence: 20
XXX number of pointers point to pointers: 49
XXX number of pointers point to scalars: 48
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.1
XXX average alias set size: 1.17

XXX times a non-volatile is read: 478
XXX times a non-volatile is write: 133
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 19
   depth: 2, occurrence: 20
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 14.1
XXX percentage an existing variable is used: 85.9
********************* end of statistics **********************/

