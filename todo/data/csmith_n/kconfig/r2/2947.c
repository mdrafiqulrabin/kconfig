/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2490688856
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_1(void);
inline static int32_t  func_2(uint8_t  p_3, const uint16_t  p_4, int64_t  p_5, uint32_t  p_6);
static const uint16_t  func_8(float  p_9, int32_t  p_10);
inline static float  func_17(int32_t  p_18);
inline static const int32_t * func_19(uint32_t  p_20, uint32_t  p_21);
inline static uint32_t  func_23(int32_t * p_24, int32_t * p_25);
inline static int32_t * func_26(int32_t * p_27, float  p_28, int32_t  p_29, int32_t * p_30);
inline static int32_t * func_31(int32_t * p_32, int32_t * p_33);
static int32_t  func_50(int32_t * const  p_51, uint8_t  p_52, uint32_t  p_53, uint64_t  p_54);
inline static uint8_t  func_58(int8_t  p_59, uint8_t  p_60, int32_t * p_61);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_7 = 0x8070ADE2L;
    int32_t l_592[4][9] = {{0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L},{0x0790F937L,0L,0x0790F937L,0L,0x0790F937L,0L,0x0790F937L,0L,0x0790F937L},{0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L,0xB661A679L},{0x0790F937L,0L,0x0790F937L,0L,0x0790F937L,0L,0x0790F937L,0L,0x0790F937L}};
    int32_t *l_591 = &l_592[1][7];
    int32_t l_593 = 0x6411087EL;
    int i, j;
    (*l_591) = func_2(l_7, func_8(((safe_div_func_float_f_f((-0x7.5p-1), (safe_add_func_float_f_f(l_7, (l_7 > ((((safe_div_func_float_f_f((((0x8.14EB4Cp+59 != l_7) != func_17(l_7)) > (safe_mul_func_float_f_f(l_7, l_7))), 0x7.436AAFp+52)) > l_7) == 0x8.Bp-1) != (-0x5.Ap+1))))))) <= (-0x1.Dp-1)), l_7), l_7, l_7);
    return l_593;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_2(uint8_t  p_3, const uint16_t  p_4, int64_t  p_5, uint32_t  p_6)
{ /* block id: 253 */
    uint32_t l_588 = 18446744073709551615UL;
    int32_t l_590[4][9][7] = {{{(-10L),0x210B7187L,(-10L),0x4C04C149L,0x210B7187L,0x10A282EDL,0x10A282EDL},{0x5A9A6146L,1L,0x400376F3L,0x543076A0L,0xDB523160L,0L,(-4L)},{(-10L),0x1A59974BL,4L,(-10L),4L,0x1A59974BL,(-10L)},{0x189666E3L,0L,0x400376F3L,(-6L),(-4L),(-6L),0x400376F3L},{(-10L),(-10L),(-4L),0x10A282EDL,0x4C04C149L,(-4L),0x4C04C149L},{0xDB523160L,0x1213D1ECL,0x400376F3L,7L,0x9ED32115L,(-2L),0xDB523160L},{(-5L),0x4C04C149L,4L,4L,0x4C04C149L,(-5L),0x1A59974BL},{0L,7L,6L,0L,(-4L),0L,0xDB523160L},{0x4C04C149L,0x1A59974BL,(-5L),0x4C04C149L,4L,4L,0x4C04C149L}},{{0x189666E3L,7L,0x189666E3L,(-6L),0xDB523160L,0x1213D1ECL,0x400376F3L},{0x10A282EDL,0x4C04C149L,(-4L),0x4C04C149L,0x10A282EDL,(-4L),(-10L)},{(-4L),0x1213D1ECL,0x9ED32115L,0L,0x9ED32115L,0x1213D1ECL,(-4L)},{(-5L),(-10L),0x1A59974BL,4L,(-10L),4L,0x1A59974BL},{(-4L),0L,6L,7L,0L,0L,0L},{0x10A282EDL,0x1A59974BL,0x1A59974BL,0x10A282EDL,4L,(-5L),0x10A282EDL},{0x189666E3L,0x543076A0L,0x9ED32115L,(-6L),0L,(-2L),0x400376F3L},{0x4C04C149L,0x10A282EDL,(-4L),(-10L),(-10L),(-4L),0x10A282EDL},{0L,0x1213D1ECL,0x189666E3L,0x543076A0L,0x9ED32115L,(-6L),0L}},{{(-5L),0x10A282EDL,(-5L),4L,0x10A282EDL,0x1A59974BL,0x1A59974BL},{0xDB523160L,0x543076A0L,6L,0x543076A0L,0xDB523160L,0L,(-4L)},{(-10L),0x1A59974BL,4L,(-10L),4L,0x1A59974BL,(-10L)},{0x189666E3L,0L,0x400376F3L,(-6L),(-4L),(-6L),0x400376F3L},{(-10L),(-10L),(-4L),0x10A282EDL,0x4C04C149L,(-4L),0x4C04C149L},{0xDB523160L,0x1213D1ECL,0x400376F3L,7L,0x9ED32115L,(-2L),0xDB523160L},{(-5L),0x4C04C149L,4L,4L,0x4C04C149L,(-5L),0x1A59974BL},{0L,7L,6L,0L,(-4L),0L,0xDB523160L},{0x4C04C149L,0x1A59974BL,(-5L),0x4C04C149L,4L,4L,0x4C04C149L}},{{0x189666E3L,7L,0x189666E3L,(-6L),0xDB523160L,0x1213D1ECL,0x400376F3L},{0x10A282EDL,0x4C04C149L,(-4L),0x4C04C149L,0x10A282EDL,(-10L),(-5L)},{0x189666E3L,0L,0x5A9A6146L,(-2L),0x5A9A6146L,0L,0x189666E3L},{1L,(-5L),(-4L),0x210B7187L,(-5L),0x210B7187L,(-4L)},{0x189666E3L,(-2L),(-4L),0x1213D1ECL,0x9ED32115L,0L,0x9ED32115L},{0x1A59974BL,(-4L),(-4L),0x1A59974BL,0x210B7187L,1L,0x1A59974BL},{0xFA983C52L,(-6L),0x5A9A6146L,0x927329ECL,0x9ED32115L,1L,6L},{4L,0x1A59974BL,(-10L),(-5L),(-5L),(-10L),0x1A59974BL},{0x9ED32115L,0L,0xFA983C52L,(-6L),0x5A9A6146L,0x927329ECL,0x9ED32115L}}};
    int32_t *l_589 = &l_590[1][2][3];
    int i, j, k;
    (*l_589) = (!(p_5 > (safe_rshift_func_uint8_t_u_u(l_588, l_588))));
    (*l_589) = (*l_589);
    return p_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_8(float  p_9, int32_t  p_10)
{ /* block id: 236 */
    int32_t l_535 = 0x962F4354L;
    int32_t *l_534 = &l_535;
    int32_t **l_536 = &l_534;
    int16_t l_537 = 9L;
    int32_t ***l_579 = &l_536;
    int32_t ****l_578 = &l_579;
    (*l_536) = l_534;
    (*l_536) = func_26((*l_536), l_537, (**l_536), (*l_536));
    if ((safe_add_func_uint32_t_u_u((safe_div_func_int16_t_s_s((((*l_536) != (void*)0) | (safe_add_func_uint8_t_u_u(1UL, p_10))), p_10)), (((*l_534) || (*l_534)) < 0x13L))))
    { /* block id: 239 */
        int8_t l_556 = 1L;
        int32_t *l_557[5][9] = {{&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535},{&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535},{&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535},{&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535,&l_535},{&l_535,&l_535,&l_535,&l_535,(void*)0,&l_535,&l_535,&l_535,&l_535}};
        float l_560 = 0x7.1152DAp+52;
        float *l_559[1];
        float **l_558 = &l_559[0];
        int32_t ***l_563[1];
        const int32_t ***l_577 = (void*)0;
        const int32_t ****l_576[1][10] = {{&l_577,&l_577,&l_577,&l_577,&l_577,&l_577,&l_577,&l_577,&l_577,&l_577}};
        int i, j;
        for (i = 0; i < 1; i++)
            l_559[i] = &l_560;
        for (i = 0; i < 1; i++)
            l_563[i] = &l_536;
        (*l_536) = func_26((*l_536), (safe_sub_func_float_f_f(((**l_536) == (p_10 == (safe_mul_func_float_f_f(((-0x1.Dp-1) != ((-0x3.Bp-1) <= p_10)), 0xE.F4E67Ap-17)))), (safe_add_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f((*l_534), (**l_536))), (-0x5.9p-1))), (**l_536))), p_9)))), l_556, (*l_536));
        (*l_536) = l_557[2][8];
        /* statement id: 241 */
        assert (l_534 == 0 || l_534 == &l_535);
        l_535 = (((l_558 != &l_559[0]) > (safe_mod_func_uint16_t_u_u((0x3EL & (((void*)0 == l_563[0]) ^ (p_10 || (p_10 == (safe_mod_func_int64_t_s_s(1L, (safe_rshift_func_uint8_t_u_s((safe_sub_func_int8_t_s_s((safe_rshift_func_int8_t_s_u((((safe_sub_func_int8_t_s_s((safe_mod_func_int64_t_s_s((l_576[0][8] != l_578), p_10)), 8L)) < p_10) || p_10), p_10)), 0xB0L)), p_10)))))))), p_10))) != 0x2C4EBE45EE10D031LL);
    }
    else
    { /* block id: 243 */
        int32_t *l_580 = &l_535;
        (****l_578) = (l_580 != (void*)0);
        (***l_578) = (***l_578);
    }
    /* facts after branching */
    assert (l_534 == 0 || l_534 == &l_535);
    for (l_535 = 0; (l_535 < 28); ++l_535)
    { /* block id: 249 */
        uint64_t l_583 = 6UL;
        int32_t **l_584 = &l_534;
        (*l_584) = func_19(p_10, l_583);
        /* statement id: 250 */
        assert (l_534 == 0);
    }
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_17(int32_t  p_18)
{ /* block id: 1 */
    uint16_t l_22 = 8UL;
    int32_t l_35 = 0x56DFC9B9L;
    int32_t *l_34 = &l_35;
    int32_t **l_531 = &l_34;
    (*l_531) = func_19(l_22, func_23(func_26(func_31(l_34, &l_35), p_18, p_18, l_34), l_34));
    /* statement id: 234 */
    assert (l_34 == 0);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_19(uint32_t  p_20, uint32_t  p_21)
{ /* block id: 226 */
    int32_t l_505 = 0x3732F1D0L;
    int32_t *l_504 = &l_505;
    int32_t **l_506 = &l_504;
    uint32_t l_507[7];
    const int32_t *l_510 = &l_505;
    const int32_t *l_513 = &l_505;
    const int32_t *l_514 = &l_505;
    const int32_t *l_517 = &l_505;
    const int32_t *l_518 = &l_505;
    const int32_t *l_519 = &l_505;
    const int32_t *l_520 = (void*)0;
    const int32_t *l_521 = &l_505;
    const int32_t *l_522 = &l_505;
    const int32_t *l_523[5] = {&l_505,&l_505,&l_505,&l_505,&l_505};
    const int32_t *l_524 = &l_505;
    const int32_t *l_525 = &l_505;
    const int32_t *l_526[8][7][4] = {{{&l_505,&l_505,(void*)0,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,(void*)0,(void*)0,&l_505},{(void*)0,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{(void*)0,&l_505,&l_505,&l_505}},{{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,(void*)0,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505}},{{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,(void*)0,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505}},{{&l_505,&l_505,(void*)0,&l_505},{&l_505,&l_505,&l_505,(void*)0},{&l_505,(void*)0,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,(void*)0,&l_505}},{{&l_505,&l_505,(void*)0,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,(void*)0,&l_505,(void*)0},{&l_505,&l_505,(void*)0,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505}},{{&l_505,&l_505,&l_505,(void*)0},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,(void*)0},{&l_505,&l_505,&l_505,(void*)0},{&l_505,(void*)0,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505}},{{&l_505,(void*)0,(void*)0,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,(void*)0,&l_505},{&l_505,&l_505,(void*)0,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505}},{{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,(void*)0,(void*)0,&l_505},{&l_505,&l_505,&l_505,&l_505},{&l_505,(void*)0,&l_505,(void*)0},{&l_505,&l_505,(void*)0,(void*)0}}};
    const int32_t *l_527 = &l_505;
    const int32_t *l_528 = &l_505;
    const int32_t *l_529 = &l_505;
    const int32_t *l_530 = (void*)0;
    int i, j, k;
    for (i = 0; i < 7; i++)
        l_507[i] = 0xC60C0C00L;
    (*l_506) = func_26(func_26(func_26(l_504, p_20, (*l_504), &l_505), p_21, p_20, l_504), p_21, p_21, l_504);
    for (p_20 = 1; (p_20 <= 6); p_20 += 1)
    { /* block id: 230 */
        const int32_t *l_508 = &l_505;
        const int32_t *l_509[4];
        const int32_t *l_511[4][2] = {{&l_505,&l_505},{&l_505,&l_505},{&l_505,&l_505},{&l_505,&l_505}};
        const int32_t *l_512 = &l_505;
        const int32_t *l_515 = &l_505;
        const int32_t *l_516 = &l_505;
        int i, j;
        for (i = 0; i < 4; i++)
            l_509[i] = &l_505;
        return l_520;
        /* statement id: 231 */
        //assert (func_19_rv == 0);
    }
    return l_530;
    /* statement id: 233 */
    //assert (func_19_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_23(int32_t * p_24, int32_t * p_25)
{ /* block id: 223 */
    int32_t l_500 = 8L;
    int32_t *l_499[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int32_t *l_501 = &l_500;
    int32_t **l_502 = (void*)0;
    int32_t l_503[7] = {1L,1L,1L,1L,1L,1L,1L};
    int i;
    l_499[2] = l_501;
    return l_503[5];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_26(int32_t * p_27, float  p_28, int32_t  p_29, int32_t * p_30)
{ /* block id: 205 */
    uint8_t l_479 = 0x21L;
    int32_t l_497 = 1L;
    int32_t *l_496 = &l_497;
    int32_t **l_495 = &l_496;
    int32_t ***l_494 = &l_495;
    int32_t ****l_493 = &l_494;
    int16_t l_498 = 0x322FL;
    for (p_29 = 0; (p_29 == 10); p_29 = safe_add_func_uint64_t_u_u(p_29, 1))
    { /* block id: 208 */
        int32_t l_462 = 0xE920F645L;
        for (l_462 = 0; (l_462 >= (-8)); --l_462)
        { /* block id: 211 */
            int32_t l_465 = (-10L);
            const int32_t *l_470 = &l_462;
            const int32_t **l_469 = &l_470;
            const int32_t ***l_468 = &l_469;
            for (l_465 = 0; (l_465 <= (-26)); --l_465)
            { /* block id: 214 */
                const int32_t *** const *l_492 = &l_468;
                l_468 = l_468;
                (*p_30) = ((safe_mul_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((safe_lshift_func_uint8_t_u_u(((safe_add_func_int8_t_s_s((l_479 && ((safe_rshift_func_uint16_t_u_s((((safe_rshift_func_uint16_t_u_s(p_29, 5)) | (safe_mul_func_uint8_t_u_u((251UL == ((safe_rshift_func_uint8_t_u_u(l_479, 5)) == (***l_468))), ((safe_sub_func_uint8_t_u_u((safe_add_func_uint8_t_u_u((p_29 || p_29), p_29)), (l_492 != l_493))) || (*p_27))))) < (****l_493)), 4)) ^ 1UL)), (****l_492))) || 6UL), 2)), (*p_30))), l_498)) > (*p_27));
            }
            (**l_468) = (**l_468);
            (*l_496) = (****l_493);
        }
    }
    return p_30;
    /* statement id: 222 */
    //assert (func_26_rv == &l_35 || func_26_rv == &l_505 || func_26_rv == &l_535);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_31(int32_t * p_32, int32_t * p_33)
{ /* block id: 2 */
    int32_t l_36 = 0x335C0DE4L;
    int32_t ***l_447 = (void*)0;
    uint32_t l_453 = 1UL;
    int32_t *l_458 = &l_36;
    int32_t **l_457 = &l_458;
    int32_t *l_459 = &l_36;
    for (l_36 = (-10); (l_36 >= 1); l_36 = safe_add_func_uint8_t_u_u(l_36, 1))
    { /* block id: 5 */
        const int32_t *l_40 = &l_36;
        const int32_t **l_39 = &l_40;
        int32_t l_41 = 3L;
        int8_t l_424[4];
        int32_t l_434 = 0x4D3B9400L;
        int32_t l_456 = (-1L);
        int i;
        for (i = 0; i < 4; i++)
            l_424[i] = 0x83L;
        (*l_39) = (void*)0;
        /* statement id: 6 */
        assert (l_40 == 0);
        for (l_41 = 0; (l_41 == 2); ++l_41)
        { /* block id: 9 */
            int32_t l_44[9][7] = {{1L,0x00955205L,1L,(-3L),(-3L),1L,0x00955205L},{(-3L),0x00955205L,7L,7L,0x00955205L,(-3L),0x00955205L},{1L,(-3L),(-3L),1L,0x00955205L,1L,(-3L)},{0x00CE3D97L,0x00CE3D97L,(-3L),7L,1L,(-3L),(-3L)},{(-3L),1L,0x00955205L,1L,(-3L),(-3L),1L},{7L,0x00CE3D97L,7L,1L,1L,7L,0x00CE3D97L},{1L,0x00CE3D97L,0x00955205L,0x00955205L,0x00CE3D97L,1L,0x00CE3D97L},{7L,1L,1L,7L,0x00CE3D97L,7L,1L},{(-3L),(-3L),1L,0x00955205L,1L,(-3L),(-3L)}};
            int32_t l_45 = 0xA4C63829L;
            int i, j;
            l_44[4][0] = l_44[4][0];
            (*l_39) = (void*)0;
            for (l_45 = 0; (l_45 <= 6); l_45 += 1)
            { /* block id: 14 */
                int i, j;
                l_44[(l_45 + 2)][l_45] = (safe_add_func_uint64_t_u_u(l_44[(l_45 + 1)][l_45], l_44[(l_45 + 1)][l_45]));
            }
            if (l_44[4][0])
                break;
        }
        for (l_41 = (-27); (l_41 == (-8)); l_41 = safe_add_func_uint64_t_u_u(l_41, 4))
        { /* block id: 21 */
            uint32_t l_65 = 18446744073709551613UL;
            int32_t l_403[7][10][3] = {{{0xCB167C54L,1L,6L},{0x0593E739L,(-1L),0xBA9720ECL},{0L,(-1L),5L},{0L,(-1L),(-1L)},{0xE8B5572DL,(-1L),0L},{0x81E60A54L,1L,3L},{0L,0L,0x7EAD5093L},{(-3L),(-1L),(-10L)},{0x019D2915L,0L,0L},{(-5L),1L,8L}},{{0x9F7B7DE3L,(-1L),0xB0423C18L},{0x95A60534L,(-1L),0xD8309ED0L},{1L,(-1L),1L},{1L,(-1L),0x0AFCA1F2L},{0x053F47ECL,1L,0xBD83F23BL},{0x557B021DL,0L,(-1L)},{1L,(-1L),2L},{0L,0L,0x3B63C9BBL},{(-1L),1L,(-6L)},{0xBDE48DDDL,(-1L),(-3L)}},{{0x80D540E5L,(-1L),0x6B064C71L},{0x2AF201FAL,(-1L),0L},{(-1L),(-1L),0L},{0L,1L,1L},{0x63A26EFFL,0L,0x3FAE959DL},{0xCCA64AB7L,(-1L),7L},{0x5EC5E385L,0L,5L},{0xCB167C54L,1L,6L},{0x0593E739L,(-1L),0xBA9720ECL},{0L,(-1L),5L}},{{0L,(-1L),(-1L)},{0xE8B5572DL,(-1L),0L},{0x81E60A54L,1L,3L},{0L,0L,0x7EAD5093L},{(-3L),(-1L),(-10L)},{0x019D2915L,0L,0L},{(-5L),1L,8L},{0x9F7B7DE3L,(-1L),0xB0423C18L},{0x95A60534L,(-1L),0xD8309ED0L},{1L,(-1L),1L}},{{1L,(-1L),0x0AFCA1F2L},{0x053F47ECL,1L,0xBD83F23BL},{0x557B021DL,0L,(-1L)},{1L,(-1L),2L},{0L,0L,0x3B63C9BBL},{(-1L),1L,(-6L)},{0xBDE48DDDL,(-1L),(-3L)},{0x80D540E5L,(-1L),0x6B064C71L},{0x2AF201FAL,(-1L),0L},{(-1L),(-1L),0L}},{{0L,1L,1L},{(-1L),4L,0L},{5L,(-1L),0x956E6CDAL},{0xBA9720ECL,4L,0x48C51254L},{0L,1L,0x1CC407AAL},{3L,(-1L),6L},{(-10L),8L,(-3L)},{6L,8L,8L},{0xD8309ED0L,(-1L),0x469A38A4L},{0x0AFCA1F2L,1L,(-1L)}},{{0x7EAD5093L,4L,7L},{0x3B63C9BBL,(-1L),0L},{(-3L),4L,0x31B4A29CL},{1L,1L,0L},{1L,(-1L),0xA1166EDBL},{7L,8L,0x21E32876L},{(-6L),8L,1L},{5L,(-1L),0xD582BE5EL},{0L,1L,1L},{0x3FAE959DL,4L,(-1L)}}};
            float l_433 = 0x0.8p-1;
            float *l_432[4];
            int i, j, k;
            for (i = 0; i < 4; i++)
                l_432[i] = &l_433;
            if ((*p_32))
                break;
            l_403[3][9][1] = func_50(&l_41, (safe_unary_minus_func_int8_t_s(l_36)), (safe_mul_func_uint8_t_u_u(func_58((l_36 == (+0x97ECL)), (((((safe_rshift_func_uint16_t_u_u(l_65, 0)) && l_65) ^ l_65) && 0xA1E2510A74126315LL) || ((+(safe_add_func_int64_t_s_s((((safe_lshift_func_int8_t_s_u(l_65, 1)) | l_36) != 0UL), 6UL))) | 4UL)), p_33), 0x4DL)), l_36);
            l_434 = (safe_sub_func_float_f_f((safe_mul_func_float_f_f(l_36, (safe_div_func_float_f_f(l_36, ((safe_mul_func_float_f_f(l_403[3][9][1], ((safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f(((safe_add_func_float_f_f((safe_add_func_float_f_f(l_403[2][5][0], (((safe_sub_func_float_f_f((0xF.2A1DFCp+13 != l_424[3]), (safe_sub_func_float_f_f(l_36, ((-((-0x1.Ep+1) == ((safe_div_func_float_f_f((((safe_sub_func_float_f_f((l_36 < (-0x10.7p+1)), 0x6.D7E2D9p+73)) == l_36) <= 0x0.Ap-1), l_403[1][1][1])) > l_36))) < 0x7.C79582p+21))))) >= (-0x3.4p-1)) == l_403[4][3][2]))), 0x0.4p-1)) != l_36), l_36)), l_36)), l_36)) == 0x0.8p+1))) <= l_36))))), l_36));
        }
        for (l_41 = 17; (l_41 < (-18)); --l_41)
        { /* block id: 198 */
            float l_444 = 0x8.75A837p-87;
            float *l_443 = &l_444;
            float **l_442 = &l_443;
            const int32_t l_450 = 1L;
            (*p_32) = ((safe_mul_func_int16_t_s_s(0L, (safe_sub_func_uint8_t_u_u((+((void*)0 == l_442)), (safe_mod_func_int16_t_s_s(((((void*)0 == l_447) ^ ((safe_sub_func_uint16_t_u_u(l_450, (safe_rshift_func_uint8_t_u_u(l_453, 1)))) || (safe_mul_func_uint32_t_u_u(l_450, (l_456 == 0L))))) != l_450), l_450)))))) < (*p_32));
            (*l_39) = &l_36;
            /* statement id: 200 */
            assert (l_40 == &l_36);
        }
        /* facts after for loop */
        assert (l_40 == &l_36 || l_40 == 0);
    }
    (*l_457) = &l_36;
    return p_32;
    /* statement id: 204 */
    //assert (func_31_rv == &l_35);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_50(int32_t * const  p_51, uint8_t  p_52, uint32_t  p_53, uint64_t  p_54)
{ /* block id: 57 */
    float *l_127 = (void*)0;
    int32_t l_128 = (-1L);
    int32_t * const l_142 = &l_128;
    int32_t l_186[9];
    const int32_t *l_207 = &l_186[6];
    const int32_t **l_206[3][6][2] = {{{&l_207,&l_207},{&l_207,&l_207},{(void*)0,&l_207},{&l_207,(void*)0},{&l_207,(void*)0},{&l_207,&l_207}},{{(void*)0,&l_207},{&l_207,&l_207},{&l_207,&l_207},{(void*)0,&l_207},{&l_207,&l_207},{&l_207,&l_207}},{{(void*)0,&l_207},{&l_207,&l_207},{&l_207,&l_207},{(void*)0,&l_207},{&l_207,(void*)0},{&l_207,(void*)0}}};
    const int32_t ***l_205 = &l_206[2][1][1];
    uint16_t l_214[4][3][9] = {{{0xD70BL,5UL,0UL,0UL,0UL,5UL,0xD70BL,0x012DL,0x395DL},{65535UL,0x395DL,65530UL,65535UL,0x012DL,1UL,0xD70BL,0x395DL,1UL},{65535UL,1UL,1UL,0x813AL,2UL,0UL,0x8A2DL,0x012DL,1UL}},{{0x8A2DL,2UL,5UL,65531UL,0x395DL,0xD05FL,65535UL,0xD05FL,0x395DL},{65535UL,2UL,2UL,65535UL,9UL,0x395DL,0UL,1UL,0xD05FL},{65535UL,1UL,5UL,65535UL,1UL,1UL,0x813AL,2UL,0UL}},{{0xD70BL,0x395DL,1UL,65531UL,9UL,1UL,2UL,65530UL,1UL},{0x22C2L,5UL,65530UL,0x813AL,0x395DL,0x395DL,0x813AL,65530UL,5UL},{65531UL,65530UL,0UL,65535UL,2UL,0xD05FL,0UL,2UL,1UL}},{{65531UL,8UL,9UL,0UL,0x012DL,0UL,65535UL,1UL,0UL},{0x22C2L,65530UL,9UL,0xD70BL,0UL,1UL,0x8A2DL,0xD05FL,0x85C8L},{8UL,0x97BFL,0x88D9L,65530UL,0x88D9L,0x97BFL,8UL,0UL,3UL}}};
    int8_t l_241 = (-9L);
    int32_t * const *l_271 = (void*)0;
    int32_t *l_342 = &l_128;
    int32_t **l_341[1];
    int32_t ***l_340 = &l_341[0];
    uint64_t l_343 = 0x8443DA255B75E65BLL;
    float l_397[5] = {0xA.F4EC64p-67,0xA.F4EC64p-67,0xA.F4EC64p-67,0xA.F4EC64p-67,0xA.F4EC64p-67};
    float *l_396 = &l_397[3];
    int i, j, k;
    for (i = 0; i < 9; i++)
        l_186[i] = 0xFDBCA6F5L;
    for (i = 0; i < 1; i++)
        l_341[i] = &l_342;
lbl_132:
    l_128 = 0x3.E731B5p+28;
    for (l_128 = (-16); (l_128 > 28); l_128 = safe_add_func_uint16_t_u_u(l_128, 1))
    { /* block id: 61 */
        int8_t l_131[1];
        int32_t *l_149 = &l_128;
        int32_t **l_148 = &l_149;
        float **l_164 = &l_127;
        int32_t ***l_216 = &l_148;
        int32_t ****l_215 = &l_216;
        uint16_t l_256 = 65533UL;
        uint64_t l_304 = 0xF3D4169CB32DCF4CLL;
        int32_t l_309[2][1];
        int32_t **l_363 = (void*)0;
        int32_t **l_364 = &l_342;
        int32_t ***l_373[3];
        uint16_t l_391 = 65535UL;
        uint64_t l_402[8][5] = {{1UL,0xEB5C6D15E0714F08LL,0xD6318096DA207F86LL,0xD6318096DA207F86LL,0xEB5C6D15E0714F08LL},{18446744073709551615UL,0x143E2F93242E5649LL,1UL,1UL,0x143E2F93242E5649LL},{1UL,0xEB5C6D15E0714F08LL,0xD6318096DA207F86LL,0xD6318096DA207F86LL,0xEB5C6D15E0714F08LL},{18446744073709551615UL,0x143E2F93242E5649LL,1UL,1UL,0x143E2F93242E5649LL},{1UL,0xEB5C6D15E0714F08LL,0xD6318096DA207F86LL,0xD6318096DA207F86LL,0xEB5C6D15E0714F08LL},{18446744073709551615UL,0x143E2F93242E5649LL,1UL,1UL,0x143E2F93242E5649LL},{1UL,0xEB5C6D15E0714F08LL,0xD6318096DA207F86LL,0xD6318096DA207F86LL,0xEB5C6D15E0714F08LL},{18446744073709551615UL,0x143E2F93242E5649LL,1UL,1UL,0x143E2F93242E5649LL}};
        int i, j;
        for (i = 0; i < 1; i++)
            l_131[i] = 9L;
        for (i = 0; i < 2; i++)
        {
            for (j = 0; j < 1; j++)
                l_309[i][j] = 1L;
        }
        for (i = 0; i < 3; i++)
            l_373[i] = (void*)0;
        for (p_53 = 0; (p_53 <= 0); p_53 += 1)
        { /* block id: 64 */
            int64_t l_160 = 0xC38B956188C7F9DBLL;
            int32_t * const *l_185 = &l_149;
            int32_t *l_263 = &l_186[1];
            int32_t l_312 = (-7L);
            uint32_t l_323 = 0UL;
            for (p_52 = 0; (p_52 <= 0); p_52 += 1)
            { /* block id: 67 */
                if (p_52)
                    goto lbl_132;
            }
            for (p_54 = 0; (p_54 <= 0); p_54 += 1)
            { /* block id: 72 */
                int32_t *l_139 = &l_128;
                int32_t **l_138 = &l_139;
                int i;
            }
            (***l_215) = (***l_215);
            for (l_323 = 0; (l_323 <= 0); l_323 += 1)
            { /* block id: 141 */
                int64_t l_328 = 1L;
                int32_t l_359 = 1L;
            }
        }
        (*l_364) = p_51;
        /* statement id: 161 */
        //assert (l_342 == &l_41);
    }
    return (*p_51);
}


/* ------------------------------------------ */
/* 
 * reads : l_35
 * writes: l_35
 */
inline static uint8_t  func_58(int8_t  p_59, uint8_t  p_60, int32_t * p_61)
{ /* block id: 23 */
    uint32_t l_71 = 3UL;
    int32_t l_81[10][9][2] = {{{0x70516A45L,0x33063242L},{0x1000BAF3L,0x14BE5697L},{(-10L),0x3979D795L},{0L,0x8AFECA80L},{1L,(-10L)},{0L,0x70516A45L},{0xA3D91D69L,2L},{0xE08A84A0L,2L},{0xA3D91D69L,0x70516A45L}},{{0L,(-10L)},{1L,0x8AFECA80L},{0L,0x3979D795L},{(-10L),0x14BE5697L},{0x1000BAF3L,0x33063242L},{0x70516A45L,1L},{0xF7D061DAL,0x1000BAF3L},{0x4505AF75L,0L},{1L,0x19FDEE13L}},{{(-8L),0xDF5A2915L},{1L,0L},{0x9738BBD8L,0xD6CD47B9L},{0x260F1475L,(-1L)},{0x8AFECA80L,(-8L)},{0x4E0D3BD2L,1L},{4L,(-10L)},{1L,0x0286F3A6L},{1L,8L}},{{0x83ADAB8FL,0x286DF497L},{1L,0xD8E66C79L},{1L,0xBD26DA61L},{0x50E6E27DL,0x2E2EE0BDL},{(-8L),(-1L)},{0L,0L},{8L,0xCA7AF0C8L},{(-7L),0x34CEB039L},{0L,1L}},{{0xD8E66C79L,0L},{1L,0xF7D061DAL},{(-10L),0x6A6ECCD2L},{0xFCBFA339L,0x119E2D4DL},{4L,0x4E0D3BD2L},{0x14BE5697L,1L},{0xD6CD47B9L,0xAF792179L},{0x12B2FE07L,0x12B2FE07L},{0xCD5918CDL,0xB6EF3BB5L}},{{0L,0x3E8228F8L},{(-10L),0x260F1475L},{0x2910E9FBL,(-10L)},{(-10L),1L},{(-10L),(-10L)},{0x2910E9FBL,0x260F1475L},{(-10L),0x3E8228F8L},{0L,0xB6EF3BB5L},{0xCD5918CDL,0x12B2FE07L}},{{0x12B2FE07L,0xAF792179L},{0xD6CD47B9L,1L},{0x14BE5697L,0x4E0D3BD2L},{4L,0x119E2D4DL},{0xFCBFA339L,0x6A6ECCD2L},{(-10L),0xF7D061DAL},{1L,0L},{0xD8E66C79L,1L},{0L,0x34CEB039L}},{{(-7L),0xCA7AF0C8L},{8L,0L},{0L,(-1L)},{(-8L),0x2E2EE0BDL},{0x50E6E27DL,(-5L)},{1L,0L},{1L,8L},{0xFCBFA339L,0xBD26DA61L},{0xACF1929BL,1L}},{{0x3E8228F8L,0xF7D061DAL},{0xE08A84A0L,0x260F1475L},{0xA4BDACABL,0x4505AF75L},{2L,0x12B2FE07L},{(-1L),0x2910E9FBL},{(-7L),0x884E3EEDL},{(-10L),0x34CEB039L},{0x4505AF75L,(-7L)},{0x186F270AL,0x0DD146F1L}},{{0xCD5918CDL,3L},{0x119E2D4DL,0xD6CD47B9L},{1L,0x70516A45L},{3L,0L},{0x83ADAB8FL,(-10L)},{0x8AFECA80L,2L},{0x286DF497L,0xDF5A2915L},{2L,1L},{0L,0x4E0D3BD2L}}};
    int32_t *l_80 = &l_81[1][5][0];
    uint32_t l_82 = 0UL;
    uint16_t l_107 = 0xBAA4L;
    int i, j, k;
lbl_108:
    (*l_80) = ((l_71 & l_71) < ((l_71 | ((p_59 == ((safe_mod_func_int16_t_s_s(p_60, p_59)) == ((0x4264A3A207B8A5F0LL < (safe_add_func_int64_t_s_s((safe_rshift_func_uint16_t_u_s(((safe_sub_func_uint32_t_u_u((((void*)0 != l_80) ^ (*l_80)), (*l_80))) ^ p_60), p_60)), l_82))) ^ p_60))) < p_60)) & (*l_80)));
    for (p_60 = 0; (p_60 <= 1); p_60 += 1)
    { /* block id: 27 */
        uint16_t l_85 = 0x71D4L;
        int32_t *l_114 = &l_81[4][1][1];
        if (((safe_mod_func_int16_t_s_s(((l_85 & (!(safe_div_func_uint64_t_u_u((safe_div_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(p_60, ((-1L) != (((l_85 && 0xEE114377L) > ((safe_sub_func_int8_t_s_s((((((~(safe_div_func_int16_t_s_s(p_60, (((safe_mod_func_uint16_t_u_u(((safe_sub_func_int8_t_s_s((~((~(safe_mod_func_uint64_t_u_u((safe_unary_minus_func_int64_t_s((0x768E4F1A1E6DEAEDLL || (&l_80 == &p_61)))), p_59))) || p_59)), l_85)) || 0UL), l_107)) || 3UL) || 0x1E93L)))) & l_85) < p_60) != p_59) && p_59), p_59)) & p_60)) | (*l_80))))), p_59)), l_85)))) && p_59), l_85)) > (*l_80)))
        { /* block id: 28 */
            if (l_82)
                goto lbl_108;
        }
        else
        { /* block id: 30 */
            const int32_t *l_125 = &l_81[1][5][0];
            for (l_71 = 0; (l_71 <= 1); l_71 += 1)
            { /* block id: 33 */
                uint8_t l_117 = 0xBCL;
                for (l_107 = 0; (l_107 <= 1); l_107 += 1)
                { /* block id: 36 */
                    int32_t *l_109 = &l_81[5][8][0];
                    int i, j, k;
                    l_81[(l_71 + 4)][(l_71 + 6)][l_107] = ((l_109 == &l_81[4][3][1]) < 18446744073709551611UL);
                    return p_59;
                }
                for (p_59 = 0; (p_59 <= 1); p_59 += 1)
                { /* block id: 42 */
                    uint64_t l_122[10][2][2];
                    int i, j, k;
                    for (i = 0; i < 10; i++)
                    {
                        for (j = 0; j < 2; j++)
                        {
                            for (k = 0; k < 2; k++)
                                l_122[i][j][k] = 0x3BE12964217F8679LL;
                        }
                    }
                    if ((safe_lshift_func_int8_t_s_u(p_60, (safe_mod_func_uint64_t_u_u(((p_61 != l_114) && 0xB808A635L), (safe_mod_func_int8_t_s_s((l_117 & ((5L & (safe_rshift_func_uint8_t_u_s(((safe_add_func_int16_t_s_s(0xAAB3L, l_122[5][0][1])) != 0x2485L), 1))) ^ 4294967295UL)), p_60)))))))
                    { /* block id: 43 */
                        int32_t **l_124 = &l_114;
                        int32_t ***l_123 = &l_124;
                        int i, j, k;
                        (*l_123) = &p_61;
                        /* statement id: 44 */
                        assert (l_124 == &p_61);
                        l_81[(p_59 + 6)][(l_71 + 5)][p_60] = ((void*)0 == p_61);
                    }
                    else
                    { /* block id: 46 */
                        int32_t **l_126 = &l_80;
                        (*l_126) = l_125;
                        /* statement id: 47 */
                        assert ((l_80 >= &l_81[0][0][0] && l_80 <= &l_81[9][8][1]));
                        (*l_126) = p_61;
                        /* statement id: 48 */
                        //assert (l_80 == &l_35);
                    }
                    if ((*p_61))
                        break;
                    return p_60;
                }
            }
        }
    }
    return p_59;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 115
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 22
   depth: 3, occurrence: 3
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 122

XXX times a variable address is taken: 236
XXX times a pointer is dereferenced on RHS: 111
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 21
   depth: 3, occurrence: 4
   depth: 4, occurrence: 9
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 906

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 280
   level: 2, occurrence: 80
   level: 3, occurrence: 29
   level: 4, occurrence: 29
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 57
XXX number of pointers point to scalars: 65
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.2
XXX average alias set size: 1.27

XXX times a non-volatile is read: 631
XXX times a non-volatile is write: 158
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 76
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 18
   depth: 3, occurrence: 6
   depth: 4, occurrence: 5
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 11.3
XXX percentage an existing variable is used: 88.7
********************* end of statistics **********************/

