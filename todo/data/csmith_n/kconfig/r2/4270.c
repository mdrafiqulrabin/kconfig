/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3569520296
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int64_t  f0;
   unsigned f1 : 15;
   signed f2 : 7;
   unsigned f3 : 13;
   unsigned f4 : 30;
};

union U1 {
   int64_t  f0;
   const signed f1 : 24;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_26(void);
static int32_t  func_42(int64_t  p_43, uint64_t  p_44, int32_t  p_45);
static const int32_t  func_68(union U1  p_69);
inline static int32_t * func_71(uint32_t  p_72, int32_t ** p_73, uint8_t  p_74, uint32_t  p_75);
static uint32_t  func_76(int32_t * p_77, float * const  p_78, int32_t ** p_79);
static int32_t * func_80(struct S0  p_81, uint64_t  p_82);
static struct S0  func_83(uint16_t  p_84, const int32_t ** p_85, int32_t * p_86);
inline static const int32_t ** func_88(int16_t  p_89, int32_t * p_90, struct S0  p_91, uint64_t  p_92, int16_t  p_93);
inline static int32_t  func_96(int32_t * p_97);
static int32_t * func_98(uint8_t  p_99, uint32_t  p_100, const int32_t * p_101, int32_t  p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_26(void)
{ /* block id: 36 */
    uint16_t l_27 = 0x8ED4L;
    int32_t l_30 = 0x333C7D24L;
    int32_t *l_29 = &l_30;
    union U1 l_70 = {0x018101BC642EE1E3LL};
    const int32_t **l_1110 = (void*)0;
    uint32_t l_1124 = 1UL;
    struct S0 l_1132 = {4L,59,-7,42,27725};
    struct S0 *l_1174 = &l_1132;
    struct S0 **l_1173 = &l_1174;
    struct S0 ***l_1172 = &l_1173;
    uint8_t l_1184 = 4UL;
    float l_1231 = 0x1.Fp-1;
    float *l_1230 = &l_1231;
    float **l_1229 = &l_1230;
    uint32_t l_1234 = 18446744073709551615UL;
    uint64_t l_1269 = 0UL;
    float l_1357 = 0xF.52124Ap+60;
    uint32_t l_1361 = 0x8ED63040L;
    if (l_27)
    { /* block id: 37 */
        int32_t *l_28 = (void*)0;
        int32_t l_33 = 6L;
        const int32_t *l_1113 = &l_30;
        const int32_t **l_1112 = &l_1113;
        int64_t l_1140 = 1L;
        union U1 l_1182 = {0x5D60AB0D8EB90423LL};
        int32_t l_1221 = (-1L);
        int32_t l_1232 = 0xE5F40AF1L;
        int16_t l_1233 = (-4L);
        uint16_t l_1248 = 0x1715L;
        uint8_t l_1257 = 255UL;
        int32_t **l_1311 = &l_29;
        int32_t ***l_1310 = &l_1311;
        int32_t ****l_1309 = &l_1310;
        int32_t *****l_1308 = &l_1309;
        union U1 *l_1316 = &l_1182;
        union U1 ** const l_1315 = &l_1316;
        union U1 ** const *l_1314 = &l_1315;
        float **l_1356 = (void*)0;
        l_28 = l_28;
        if ((((void*)0 == l_29) && (((uint32_t)7UL % (uint32_t)l_33) | 4294967295UL)))
        { /* block id: 39 */
            int32_t *l_34 = (void*)0;
            int32_t **l_35 = &l_28;
            (*l_35) = l_34;
            for (l_27 = (-17); (l_27 > 16); l_27 += 1)
            { /* block id: 43 */
                uint16_t l_46 = 0x1721L;
                int32_t **l_49 = &l_29;
                if (((((int32_t)((int32_t)func_42(l_46, (*l_29), l_46) + (int32_t)((*l_29) > ((void*)0 != l_49))) / (int32_t)l_33) > ((int64_t)0x5533F2A6ADD33D73LL / (int64_t)18446744073709551611UL)) < (*l_29)))
                { /* block id: 47 */
                    uint32_t l_54 = 0x52B3395CL;
                    if ((((uint16_t)(*l_29) / (uint16_t)l_54) > ((int16_t)(**l_49) >> (int16_t)9)))
                    { /* block id: 48 */
                        uint16_t l_59 = 65535UL;
                        float l_65 = (-0x5.8p-1);
                        float *l_64 = &l_65;
                        (*l_64) = ((float)(((l_59 <= (l_54 >= ((float)(**l_49) - (float)l_59))) < ((float)l_59 + (float)((*l_35) == (void*)0))) == (**l_49)) - (float)(*l_29));
                    }
                    else
                    { /* block id: 50 */
                        int16_t l_1095 = 0x1ED6L;
                        (**l_49) = ((int32_t)func_68(l_70) + (int32_t)l_1095);
                        if (l_54)
                            continue;
                    }
                    if ((**l_49))
                        continue;
                }
                else
                { /* block id: 631 */
                    int32_t *l_1096 = &l_30;
                    l_1096 = l_1096;
                }
            }
        }
        else
        { /* block id: 635 */
            int32_t *l_1102 = &l_30;
            struct S0 l_1115 = {0x220D81C371B93074LL,61,-3,41,16257};
            struct S0 *l_1114 = &l_1115;
            for (l_70.f0 = 8; (l_70.f0 != 25); l_70.f0++)
            { /* block id: 638 */
                int32_t *l_1101 = (void*)0;
                int32_t l_1103 = 0x8CBFB14CL;
                float **l_1106 = (void*)0;
                float ***l_1105 = &l_1106;
                float ****l_1104 = &l_1105;
                float *** const *l_1108 = &l_1105;
                float *** const **l_1107 = &l_1108;
                int32_t **l_1109 = &l_29;
                int16_t l_1111 = 0xAD8FL;
                for (l_27 = (-10); (l_27 == 1); ++l_27)
                { /* block id: 641 */
                    l_1102 = l_1101;
                    /* statement id: 642 */
                    assert (l_1102 == 0);
                    if (l_1103)
                        break;
                    return l_33;
                }
                (*l_1107) = l_1104;
                (*l_1109) = &l_33;
                /* statement id: 647 */
                assert (l_29 == &l_33);
                (*l_1114) = func_83((*l_29), l_1110, func_80(func_83(l_1111, l_1112, l_1102), ((*l_1113) >= ((l_1114 == (void*)0) == (*l_29)))));
            }
            /* facts after for loop */
            assert (l_29 == &l_33 || l_29 == &l_30);
            assert (l_1102 == 0 || l_1102 == &l_30);
        }
        /* facts after branching */
        assert (l_29 == &l_33 || l_29 == &l_30);
        if (((int64_t)((int64_t)((uint16_t)((int32_t)(**l_1112) % (int32_t)0xAE2032EAL) >> (uint16_t)14) % (int64_t)l_1124) - (int64_t)(**l_1112)))
        { /* block id: 651 */
            uint8_t l_1134 = 0xC3L;
            float *l_1139 = (void*)0;
            (*l_1112) = (void*)0;
            /* statement id: 652 */
            assert (l_1113 == 0);
            for (l_30 = (-27); (l_30 <= (-13)); l_30 += 8)
            { /* block id: 655 */
                (*l_1112) = (*l_1112);
            }
            if (__builtin_ctzl((*l_29)))
            { /* block id: 658 */
                uint64_t l_1127 = 18446744073709551615UL;
                float l_1129 = 0x5.46A2E5p+71;
                float *l_1128 = &l_1129;
                (*l_1128) = (0xC.21BA6Ap+56 < l_1127);
            }
            else
            { /* block id: 660 */
                const int32_t *l_1133 = (void*)0;
                for (l_30 = 8; (l_30 != (-22)); l_30--)
                { /* block id: 663 */
                    l_1132 = l_1132;
                    (*l_1112) = l_1133;
                    if (l_1134)
                    { /* block id: 666 */
                        uint64_t l_1135 = 18446744073709551615UL;
                        return l_1135;
                    }
                    else
                    { /* block id: 668 */
                        float l_1137 = (-0x4.4p-1);
                        float *l_1136 = &l_1137;
                        int32_t l_1138 = 1L;
                        (*l_1136) = (-0x1.5p+1);
                        if (l_1138)
                            continue;
                        (*l_1112) = (void*)0;
                        (*l_1136) = l_1138;
                    }
                }
            }
            l_1140 = 0x5.94B7BCp+13;
        }
        else
        { /* block id: 677 */
            int32_t **l_1141 = &l_29;
            const int64_t l_1167 = 0x07315C3B5B8C946ALL;
            int16_t l_1195 = 0x0C2FL;
            union U1 l_1198 = {0xE97FC8995C1E773FLL};
            struct S0 l_1203 = {-8L,146,-10,9,14815};
            const int32_t *l_1204 = (void*)0;
            uint8_t l_1212 = 0x84L;
            int64_t l_1238 = 0x4C4DC7263428B1A8LL;
            int64_t l_1246 = 0x6C9A3274F9B6631CLL;
            struct S0 ***l_1250 = &l_1173;
            uint32_t l_1320 = 4294967286UL;
            union U1 **l_1345 = &l_1316;
            union U1 ***l_1344 = &l_1345;
        }
        /* facts after branching */
        assert (l_1113 == &l_30 || l_1113 == 0);
    }
    else
    { /* block id: 804 */
        int32_t l_1360 = (-7L);
        return l_1360;
    }
    /* facts after branching */
    //assert (l_29 == dangling || l_29 == &l_30);
    return l_1361;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_42(int64_t  p_43, uint64_t  p_44, int32_t  p_45)
{ /* block id: 44 */
    int32_t *l_47 = (void*)0;
    int32_t **l_48 = &l_47;
    (*l_48) = l_47;
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_68(union U1  p_69)
{ /* block id: 51 */
    int32_t l_87 = 1L;
    struct S0 l_418 = {0xB35F5E08FB86A834LL,107,-5,37,3225};
    int32_t *l_443 = &l_87;
    int32_t *l_1094 = (void*)0;
    l_1094 = func_71(func_76(func_80(func_83(l_87, func_88(func_42((p_69.f1 | l_87), (((uint32_t)0xB1AAE879L / (uint32_t)func_96(func_98((((uint64_t)(l_87 >= func_42(l_87, (l_87 && (-(int32_t)((uint64_t)0x0090E7AF82577C8ALL / (uint64_t)l_87))), l_87)) + (uint64_t)p_69.f0) == 0x9D8D7774CA6A6683LL), l_87, &l_87, l_87))) < l_87), l_87), &l_87, l_418, l_87, p_69.f1), l_443), p_69.f0), l_443, &l_443), &l_443, (*l_443), p_69.f1);
    /* statement id: 625 */
    assert (l_1094 == &l_87);
    return p_69.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_71(uint32_t  p_72, int32_t ** p_73, uint8_t  p_74, uint32_t  p_75)
{ /* block id: 445 */
    struct S0 l_795 = {0xF2FFB103BD23FD2BLL,23,8,66,18674};
    struct S0 *l_794 = &l_795;
    struct S0 **l_793 = &l_794;
    const int32_t l_805 = (-8L);
    const int32_t *l_804 = &l_805;
    int32_t **l_808 = (void*)0;
    int32_t ***l_807 = &l_808;
    int32_t ****l_806 = &l_807;
    float l_810 = 0x3.16B951p+32;
    float * const l_809 = &l_810;
    union U1 l_821 = {0xB133CA85A1309FC8LL};
    union U1 *l_820 = &l_821;
    union U1 ** const l_819 = &l_820;
    uint8_t l_858 = 0xC6L;
    struct S0 ***l_916 = &l_793;
    struct S0 ****l_915 = &l_916;
    struct S0 *****l_914 = &l_915;
    uint64_t l_970 = 0x27ABC0BA0F4ADF5DLL;
    int32_t l_980 = 0L;
    int32_t *l_979 = &l_980;
    int32_t *l_986 = &l_980;
    int32_t *l_991 = &l_980;
    int32_t *l_997 = &l_980;
    int32_t *l_998 = &l_980;
    int32_t *l_1000 = &l_980;
    int32_t *l_1001 = &l_980;
    float *l_1009 = &l_810;
    float **l_1008 = &l_1009;
    float ***l_1007 = &l_1008;
    uint64_t l_1044 = 0xC2D712958D11E169LL;
    int32_t l_1060 = 0xB4214AEDL;
    (*l_793) = (void*)0;
    /* statement id: 446 */
    assert (l_794 == 0);
    return (*p_73);
    /* statement id: 624 */
    //assert (func_71_rv == &l_87 || func_71_rv == &l_33 || func_71_rv == &l_30 || func_71_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_76(int32_t * p_77, float * const  p_78, int32_t ** p_79)
{ /* block id: 227 */
    int32_t l_467 = 0L;
    struct S0 ** const l_474 = (void*)0;
    struct S0 ** const *l_473 = &l_474;
    struct S0 ** const ** const l_472 = &l_473;
    struct S0 l_477 = {0x3333DDF15BD04D2FLL,81,-10,31,22395};
    float l_538 = 0x6.193381p-53;
    float *l_537 = &l_538;
    union U1 l_617 = {0x200D2AF56BBDED5DLL};
    union U1 *l_616 = &l_617;
    uint32_t l_641 = 0xEB3843AFL;
    const float *l_653 = (void*)0;
    const float **l_652 = &l_653;
    const float ***l_651 = &l_652;
    int32_t **l_672 = (void*)0;
    int32_t ***l_671 = &l_672;
    struct S0 ** const * const *l_714 = (void*)0;
    const int32_t **l_756 = (void*)0;
    uint32_t l_787 = 4294967291UL;
    int16_t l_791 = 0x0BCDL;
    l_467 = ((l_467 <= (((int16_t)__builtin_clzll(((int16_t)(((__builtin_parity(l_467) != 0xE7E330E1B65AA121LL) < l_467) >= 0xC37AL) << (int16_t)4)) - (int16_t)(l_472 == &l_473)) > 18446744073709551607UL)) & l_467);
    return l_791;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_80(struct S0  p_81, uint64_t  p_82)
{ /* block id: 224 */
    int32_t l_451 = 0x16697466L;
    int32_t *l_450 = &l_451;
    int32_t **l_449 = &l_450;
    uint8_t l_454 = 255UL;
    int32_t *l_455 = &l_451;
    int32_t *l_456 = &l_451;
    int32_t *l_457 = &l_451;
    int32_t *l_458 = &l_451;
    int32_t *l_459 = &l_451;
    int32_t *l_460 = &l_451;
    int32_t *l_461 = &l_451;
    int32_t *l_462 = &l_451;
    int32_t *l_463 = &l_451;
    int32_t *l_464 = &l_451;
    int32_t *l_465 = &l_451;
    int32_t *l_466 = (void*)0;
    (*l_450) = ((l_449 == &l_450) || ((0x2EC23F51L || (((((__builtin_parityl((**l_449)) == (*l_450)) == ((int64_t)(__builtin_popcountl(func_96((*l_449))) | (-7L)) / (int64_t)l_454)) > p_81.f1) | (**l_449)) & 5UL)) | (**l_449)));
    return l_466;
    /* statement id: 226 */
    //assert (func_80_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_83(uint16_t  p_84, const int32_t ** p_85, int32_t * p_86)
{ /* block id: 219 */
    struct S0 l_446 = {0x767B892A878CF969LL,171,10,23,16307};
    struct S0 *l_445 = &l_446;
    struct S0 **l_444 = &l_445;
    struct S0 ***l_447 = &l_444;
    struct S0 l_448 = {0x52A8F70EA9CB6A71LL,91,3,36,3526};
    (*l_447) = l_444;
    l_446.f2 = l_446.f3;
    (**l_447) = (*l_444);
    return l_448;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t ** func_88(int16_t  p_89, int32_t * p_90, struct S0  p_91, uint64_t  p_92, int16_t  p_93)
{ /* block id: 213 */
    union U1 l_420 = {0xB1CE934E2D67D461LL};
    union U1 *l_419 = &l_420;
    int32_t l_422 = (-1L);
    const int32_t *l_421 = &l_422;
    int32_t *l_426 = &l_422;
    int32_t **l_425 = &l_426;
    const uint16_t l_430 = 0x0854L;
    int16_t l_431 = 1L;
    int32_t *l_434 = &l_422;
    const int32_t **l_435 = &l_421;
    const int32_t **l_436 = &l_421;
    const int32_t **l_437 = &l_421;
    const int32_t **l_438 = &l_421;
    const int32_t **l_439 = &l_421;
    const int32_t **l_440 = &l_421;
    const int32_t **l_441 = &l_421;
    const int32_t **l_442 = (void*)0;
    l_419 = l_419;
    (*l_425) = func_98(l_420.f0, l_420.f0, l_421, (1L | ((uint32_t)0xCAD145C0L % (uint32_t)__builtin_parity((*l_421)))));
    /* statement id: 215 */
    assert (l_426 == 0);
    (*l_425) = func_98((func_96((*l_425)) || (p_89 == (p_91.f1 > (!((int16_t)(__builtin_ctz((p_93 == (p_89 | (-8L)))) != l_430) / (int16_t)l_431))))), (*l_421), p_90, (*l_421));
    (*l_434) = __builtin_parity(((int64_t)p_91.f3 / (int64_t)(0xDF68B0571D79BB85LL || (2L && p_91.f0))));
    return l_442;
    /* statement id: 218 */
    //assert (func_88_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_96(int32_t * p_97)
{ /* block id: 65 */
    struct S0 l_147 = {0x1577CD1832462667LL,137,2,77,23477};
    struct S0 *l_148 = &l_147;
    int32_t l_183 = 0L;
    int32_t *l_182 = &l_183;
    uint16_t l_215 = 1UL;
    struct S0 * const *l_305 = &l_148;
    struct S0 * const ** const l_304 = &l_305;
    struct S0 * const ** const *l_303 = &l_304;
    uint16_t l_324 = 65535UL;
    int16_t l_343 = (-1L);
    uint16_t l_417 = 65526UL;
    (*l_148) = l_147;
    return l_417;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_98(uint8_t  p_99, uint32_t  p_100, const int32_t * p_101, int32_t  p_102)
{ /* block id: 52 */
    uint8_t l_131 = 0x78L;
    int32_t l_135 = 5L;
    int32_t *l_134 = &l_135;
    struct S0 l_138 = {0xF772B8ADFEA0260ALL,14,4,51,10939};
    int32_t *l_141 = &l_135;
    int32_t *l_142 = &l_135;
    int32_t *l_143 = &l_135;
    int32_t *l_144 = &l_135;
    int32_t *l_145 = &l_135;
    int32_t *l_146 = (void*)0;
    for (p_99 = 27; (p_99 > 30); p_99++)
    { /* block id: 55 */
        uint32_t l_118 = 0xC378916AL;
        int32_t l_133 = 0L;
        int32_t *l_132 = &l_133;
        struct S0 *l_139 = (void*)0;
        struct S0 l_140 = {0L,85,-3,36,6756};
    }
    return l_146;
    /* statement id: 64 */
    //assert (func_98_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 387
   depth: 1, occurrence: 41
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 101
breakdown:
   indirect level: 0, occurrence: 44
   indirect level: 1, occurrence: 19
   indirect level: 2, occurrence: 15
   indirect level: 3, occurrence: 12
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 33
XXX times a bitfields struct on LHS: 13
XXX times a bitfields struct on RHS: 54
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 83

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 347

XXX times a variable address is taken: 317
XXX times a pointer is dereferenced on RHS: 249
breakdown:
   depth: 1, occurrence: 181
   depth: 2, occurrence: 59
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 194
breakdown:
   depth: 1, occurrence: 159
   depth: 2, occurrence: 25
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 48
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 1653

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 532
   level: 2, occurrence: 321
   level: 3, occurrence: 86
   level: 4, occurrence: 71
   level: 5, occurrence: 12
XXX number of pointers point to pointers: 194
XXX number of pointers point to scalars: 119
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 30.3
XXX average alias set size: 1.28

XXX times a non-volatile is read: 1539
XXX times a non-volatile is write: 558
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 17

XXX stmts: 61
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 4
   depth: 2, occurrence: 7
   depth: 3, occurrence: 8
   depth: 4, occurrence: 9
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

