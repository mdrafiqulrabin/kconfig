/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1498913512
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
};

union U1 {
   const uint32_t  f0;
   const uint32_t  f1;
   const uint32_t  f2;
   int16_t  f3;
};

union U2 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
   uint32_t  f3;
   uint16_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const union U0  func_30(void);
static uint16_t  func_39(int32_t * p_40, union U0  p_41, int32_t * p_42, int32_t * p_43, union U1  p_44);
static int32_t * func_46(union U0  p_47, int32_t * p_48, int32_t  p_49);
static int32_t * func_51(float  p_52);
static int32_t * func_70(int32_t * p_71, uint16_t  p_72, union U1  p_73);
static float  func_76(union U1  p_77, int16_t  p_78);
inline static union U1  func_79(int32_t  p_80, union U1  p_81, union U2  p_82);
inline static union U1  func_83(int32_t * p_84);
static int16_t  func_94(union U2  p_95);
static int32_t  func_102(int32_t * p_103, float  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const union U0  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 0;
    int32_t l_278 = (-4);
    union U2 l_291 = {0U};
    union U2 *l_290 = &l_291;
    int32_t l_299 = 0xBA2F377F;
    const union U0 **** const l_311 = (void*)0;
    int32_t *l_332 = &l_299;
    union U0 l_334 = {0x09A4825E};
    union U0 * const l_333 = &l_334;
    const union U0 l_335 = {6U};
    for (l_31 = 5; (l_31 == (-1)); l_31 -= 6)
    { /* block id: 39 */
        int32_t l_34 = (-1);
        union U0 l_45 = {0U};
        union U1 l_255 = {0x3F3AD76B};
        int32_t l_274 = (-5);
        int32_t *****l_275 = (void*)0;
        union U2 l_288 = {0xD7D14D15};
        union U2 *l_287 = &l_288;
        int32_t *l_316 = &l_274;
        float ****l_329 = (void*)0;
        uint32_t l_331 = 0U;
        for (l_34 = 0; (l_34 != 14); l_34 += 1)
        { /* block id: 42 */
            int32_t l_38 = (-5);
            int32_t *l_37 = &l_38;
            union U0 l_50 = {0x2E4A6B2C};
            const int32_t *l_293 = &l_288.f1;
            int32_t l_330 = 0xBCD2E24E;
            (*l_37) = (0x0EBB > l_34);
            if (__builtin_ffsl((func_39(&l_34, l_45, &l_34, func_46(l_50, func_51((&l_31 == &l_34)), l_34), l_255) > l_274)))
            { /* block id: 205 */
                uint32_t l_277 = 0U;
                union U0 *l_286 = &l_50;
                const int32_t *l_292 = (void*)0;
                float l_308 = (-0x2.Cp+1);
                float *l_307 = &l_308;
                float **l_306 = &l_307;
                float ***l_305 = &l_306;
                float ****l_304 = &l_305;
                float *****l_303 = &l_304;
                if ((*l_37))
                { /* block id: 206 */
                    int32_t *****l_276 = (void*)0;
                    l_276 = l_275;
                    l_278 = (l_277 ^ 0x1457);
                    for (l_277 = (-19); (l_277 != 7); l_277++)
                    { /* block id: 211 */
                        uint16_t l_283 = 5U;
                        float l_285 = (-0x1.Ap+1);
                        float *l_284 = &l_285;
                        (*l_284) = ((((float)l_283 - (float)(*l_37)) >= l_283) >= 0x5.E114A6p+67);
                        return l_50;
                        /* statement id: 213 */
                                            }
                    if ((&l_45 != l_286))
                    { /* block id: 215 */
                        union U2 **l_289 = (void*)0;
                        float l_295 = 0x1.Cp+1;
                        float *l_294 = &l_295;
                        l_290 = l_287;
                        /* statement id: 216 */
                        assert (l_290 == &l_288);
                        l_293 = l_292;
                        /* statement id: 217 */
                        assert (l_293 == 0);
                        (*l_37) = (*l_37);
                        (*l_294) = l_291.f0;
                    }
                    else
                    { /* block id: 220 */
                        union U2 **l_296 = &l_290;
                        (*l_296) = (void*)0;
                        /* statement id: 221 */
                        assert (l_290 == 0);
                    }
                    /* facts after branching */
                    assert (l_290 == 0 || l_290 == &l_288);
                    assert (l_293 == &l_288.f1 || l_293 == 0);
                }
                else
                { /* block id: 223 */
                    float *l_300 = (void*)0;
                    float l_302 = 0x9.E15BD4p+13;
                    float *l_301 = &l_302;
                    for (l_291.f1 = 27; (l_291.f1 >= (-28)); --l_291.f1)
                    { /* block id: 226 */
                        return l_50;
                        /* statement id: 227 */
                                            }
                    /* facts after for loop */
                                        (*l_37) = l_299;
                    (*l_301) = 0x0.7p+1;
                    l_303 = (void*)0;
                    /* statement id: 231 */
                    assert (l_303 == 0);
                }
                /* facts after branching */
                assert (l_293 == &l_288.f1 || l_293 == 0);
                assert (l_303 == 0 || l_303 == &l_304);
            }
            else
            { /* block id: 233 */
                int32_t **l_309 = &l_37;
                union U0 *l_315 = &l_50;
                union U0 **l_314 = &l_315;
                (*l_309) = (void*)0;
                /* statement id: 234 */
                assert (l_37 == 0);
                if (l_291.f4)
                { /* block id: 235 */
                    int32_t **l_310 = &l_37;
                    l_291.f1 = (l_310 == (void*)0);
                    /* statement id: 236 */
                                    }
                else
                { /* block id: 237 */
                    union U0 ****l_313 = (void*)0;
                    union U0 *****l_312 = &l_313;
                    (*l_312) = l_311;
                    if (l_291.f4)
                        continue;
                    if (l_288.f2)
                        break;
                }
                /* facts after branching */
                                (*l_314) = &l_50;
            }
            /* facts after branching */
            assert (l_37 == 0 || l_37 == &l_38);
            assert (l_293 == &l_288.f1 || l_293 == 0);
            l_316 = &l_31;
            /* statement id: 244 */
            assert (l_316 == &l_31);
            l_332 = func_70(&l_278, (func_94((*l_287)) | (((uint32_t)((int16_t)l_38 + (int16_t)(((uint16_t)((((uint32_t)(((~__builtin_popcount(((int16_t)(((*l_316) > (*l_316)) & (((-(int32_t)(*l_316)) || ((void*)0 != l_329)) | l_278)) << (int16_t)(*l_316)))) <= 4294967292U) && 0xEFFD) - (uint32_t)l_330) ^ (*l_316)) < l_291.f4) >> (uint16_t)12) & 0x0C1213BD)) - (uint32_t)l_331) | l_330)), l_255);
            /* statement id: 245 */
            assert (l_332 == &l_278);
        }
        /* facts after for loop */
        assert (l_290 == &l_291 || l_290 == 0 || l_290 == &l_288);
        assert (l_316 == &l_31 || l_316 == &l_274);
        assert (l_332 == &l_278 || l_332 == &l_299);
        return l_45;
        /* statement id: 247 */
            }
    (*l_332) = (l_333 == &l_334);
    return l_335;
    /* statement id: 250 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_39(int32_t * p_40, union U0  p_41, int32_t * p_42, int32_t * p_43, union U1  p_44)
{ /* block id: 183 */
    const union U0 ***l_258 = (void*)0;
    int32_t l_267 = 1;
    int32_t *l_266 = &l_267;
    for (p_41.f1 = 7; (p_41.f1 == 1); --p_41.f1)
    { /* block id: 186 */
        const union U0 l_262 = {4294967295U};
        const union U0 *l_261 = &l_262;
        const union U0 **l_260 = &l_261;
        const union U0 ***l_259 = &l_260;
        const int32_t *l_270 = &l_267;
        l_259 = l_258;
        /* statement id: 187 */
        assert (l_259 == 0);
        for (p_44.f3 = 0; (p_44.f3 != (-16)); p_44.f3 -= 8)
        { /* block id: 190 */
            uint32_t l_265 = 0x5434852D;
            if (l_265)
                break;
            (*l_266) = func_102(l_266, p_41.f0);
            for (l_265 = 0; (l_265 <= 14); l_265++)
            { /* block id: 195 */
                const uint16_t l_273 = 0x3173;
                l_270 = (void*)0;
                /* statement id: 196 */
                assert (l_270 == 0);
                if ((*p_42))
                    continue;
                (*l_266) = ((uint16_t)l_265 >> (uint16_t)(l_273 && (*l_266)));
                p_43 = p_42;
                /* statement id: 199 */
                //assert (p_43 == &l_34);
            }
            if (l_265)
                break;
        }
        /* facts after for loop */
        assert (l_270 == 0 || l_270 == &l_267);
    }
    /* facts after for loop */
        //assert (p_43 == &l_34 || p_43 == 0);
        return p_44.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(union U0  p_47, int32_t * p_48, int32_t  p_49)
{ /* block id: 48 */
    int32_t l_65 = 2;
    int32_t *l_64 = &l_65;
    float l_67 = 0x0.3p-1;
    union U2 l_170 = {0x9B685049};
    union U2 *l_169 = &l_170;
    union U1 *l_185 = (void*)0;
    uint32_t l_194 = 4294967295U;
    int32_t *l_218 = &l_65;
    int32_t *l_224 = &l_170.f2;
    float ***l_232 = (void*)0;
    float ****l_231 = &l_232;
    int32_t ***l_237 = (void*)0;
    int32_t ****l_236 = &l_237;
    union U0 l_240 = {2U};
    union U0 *l_239 = &l_240;
    const float *l_250 = (void*)0;
    const float **l_249 = &l_250;
    const float ***l_248 = &l_249;
    int32_t *l_251 = &l_170.f2;
    int32_t *l_252 = &l_170.f1;
    int32_t *l_253 = &l_170.f2;
    int32_t *l_254 = (void*)0;
    if (p_49)
    { /* block id: 49 */
        union U2 l_91 = {2U};
        int32_t *l_150 = (void*)0;
        int32_t ** const l_168 = &l_64;
        float *l_180 = (void*)0;
        float ** const l_179 = &l_180;
        float ** const * const l_178 = &l_179;
        int32_t *l_203 = (void*)0;
        int32_t *l_219 = &l_170.f2;
        int32_t *l_223 = &l_91.f2;
        int32_t *l_227 = &l_91.f2;
        int32_t *l_228 = (void*)0;
        union U2 **l_233 = (void*)0;
        for (p_47.f2 = 0; (p_47.f2 != 1); ++p_47.f2)
        { /* block id: 52 */
            int32_t *l_66 = (void*)0;
            union U2 l_153 = {4294967288U};
            int32_t *l_220 = &l_91.f2;
            int32_t *l_226 = &l_153.f2;
            float ***l_230 = (void*)0;
            float ****l_229 = &l_230;
            for (p_49 = 29; (p_49 < (-27)); p_49--)
            { /* block id: 55 */
                int32_t l_68 = 0x093AF8EF;
                int32_t l_69 = (-3);
                int32_t l_155 = 0x91DCBA93;
                float *l_159 = (void*)0;
                union U1 l_166 = {0xF9C57FF4};
                union U1 *l_165 = &l_166;
                int32_t *l_200 = &l_170.f2;
                int32_t *l_201 = &l_170.f1;
                int32_t *l_202 = &l_91.f2;
                int32_t **l_216 = &l_203;
                int32_t ***l_215 = &l_216;
            }
            (*l_168) = &l_65;
            (*l_168) = (*l_168);
            l_231 = l_229;
            /* statement id: 172 */
            assert (l_231 == &l_230);
        }
        /* facts after for loop */
                //assert (l_231 == dangling || l_231 == &l_232);
        l_169 = &l_91;
        /* statement id: 174 */
        assert (l_169 == &l_91);
    }
    else
    { /* block id: 175 */
        float *l_238 = &l_67;
        union U0 **l_241 = &l_239;
        (*l_238) = ((*l_64) < ((0x3.Fp-1 != ((*l_224) != ((((((float)(&l_169 != (void*)0) + (float)p_47.f1) <= (*l_224)) >= (l_236 != (void*)0)) == 0x1.5p+1) != (*l_218)))) == (-0x6.5p+1)));
        (*l_241) = l_239;
        (*l_238) = (*l_64);
    }
    /* facts after branching */
        //assert (l_169 == &l_170 || l_169 == dangling);
    //assert (l_231 == dangling || l_231 == &l_232);
    (*l_224) = ((float)(*l_224) - (float)(0x9.1F3E89p-5 == (p_49 < ((float)(-0x9.6p+1) + (float)(0x0.602BA4p-29 > p_47.f1)))));
    /* statement id: 180 */
        p_49 = ((int16_t)__builtin_clzl(p_47.f2) - (int16_t)(((void*)0 != l_248) || 4294967292U));
    return l_254;
    /* statement id: 182 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(float  p_52)
{ /* block id: 44 */
    int32_t l_54 = (-3);
    int32_t *l_53 = &l_54;
    int32_t *l_55 = (void*)0;
    l_53 = (void*)0;
    /* statement id: 45 */
    assert (l_53 == 0);
    l_54 = l_54;
    return l_55;
    /* statement id: 47 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_70(int32_t * p_71, uint16_t  p_72, union U1  p_73)
{ /* block id: 117 */
    int32_t l_148 = 0;
    int32_t *l_147 = &l_148;
    int32_t **l_149 = &l_147;
    (*l_149) = func_51((p_71 != l_147));
    /* statement id: 118 */
    assert (l_147 == 0);
    (*l_149) = func_51(p_72);
    (*l_149) = func_51(p_73.f3);
    return p_71;
    /* statement id: 121 */
    //assert (func_70_rv == 0 || func_70_rv == &l_91.f1 || func_70_rv == &l_278);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_76(union U1  p_77, int16_t  p_78)
{ /* block id: 115 */
    int32_t l_145 = 0xCE71E83B;
    return l_145;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_79(int32_t  p_80, union U1  p_81, union U2  p_82)
{ /* block id: 62 */
    int32_t l_93 = 7;
    int32_t *l_92 = &l_93;
    uint32_t l_101 = 0xCEEEC855;
    float l_120 = (-0x3.Ap-1);
    float *l_119 = &l_120;
    float **l_118 = &l_119;
    union U1 l_141 = {0x585B88FC};
lbl_110:
    l_92 = l_92;
    if ((((p_81.f3 & (*l_92)) < func_94(p_82)) != ((p_82.f0 >= (-(int16_t)((uint32_t)((&p_80 == &p_80) == (((((void*)0 != &l_93) ^ (*l_92)) != p_81.f3) >= p_81.f3)) % (uint32_t)l_101))) > p_82.f3)))
    { /* block id: 67 */
        int32_t l_111 = 8;
        if (func_102(&l_93, (*l_92)))
        { /* block id: 71 */
            int32_t l_109 = 0x6835AC29;
            (*l_92) = (__builtin_ctzll(((uint16_t)(7U <= p_82.f2) >> (uint16_t)13)) == l_109);
            if (l_93)
                goto lbl_110;
        }
        else
        { /* block id: 74 */
            int32_t **l_112 = &l_92;
            int32_t *l_113 = &l_93;
            l_111 = p_81.f2;
            (*l_112) = (void*)0;
            /* statement id: 76 */
            assert (l_92 == 0);
            (*l_113) = ((-1) <= p_82.f3);
        }
        /* facts after branching */
        assert (l_92 == 0 || l_92 == &l_93);
    }
    else
    { /* block id: 79 */
        float l_115 = (-0x1.6p-1);
        if ((!(p_81.f2 || ((uint16_t)(*l_92) - (uint16_t)1U))))
        { /* block id: 80 */
            float ***l_121 = &l_118;
            (*l_121) = l_118;
            for (p_82.f1 = (-13); (p_82.f1 >= (-13)); p_82.f1 += 5)
            { /* block id: 84 */
                (*l_92) = __builtin_ffsll(p_82.f4);
            }
            /* facts after for loop */
                    }
        else
        { /* block id: 87 */
            int32_t **l_124 = &l_92;
            (*l_124) = &p_80;
            /* statement id: 88 */
            assert (l_92 == &p_80);
        }
        /* facts after branching */
                assert (l_92 == &p_80 || l_92 == &l_93);
    }
    /* facts after branching */
    assert (l_92 == &p_80 || l_92 == &l_93 || l_92 == 0);
    for (p_82.f1 = 0; (p_82.f1 == 3); p_82.f1 += 4)
    { /* block id: 93 */
        float ***l_127 = &l_118;
        int32_t l_128 = (-1);
        int32_t **l_139 = &l_92;
        l_128 = (0xCBA4 != ((void*)0 != l_127));
        for (l_93 = 0; (l_93 > 27); l_93 += 2)
        { /* block id: 97 */
            int32_t *l_135 = &l_128;
            if (((void*)0 == &l_92))
            { /* block id: 98 */
                const int32_t ***l_131 = (void*)0;
                int32_t ***l_132 = (void*)0;
                int32_t **l_133 = &l_92;
                l_133 = (void*)0;
                /* statement id: 99 */
                assert (l_133 == 0);
            }
            else
            { /* block id: 100 */
                union U1 l_134 = {6U};
                return l_134;
                /* statement id: 101 */
                            }
            (*l_135) = p_82.f3;
            (*l_119) = (-0x4.7p-1);
            for (l_101 = 0; (l_101 > 55); ++l_101)
            { /* block id: 107 */
                int32_t **l_138 = &l_135;
                int32_t ***l_140 = &l_139;
                (*l_138) = &p_80;
                /* statement id: 108 */
                assert (l_135 == &p_80);
                (*l_140) = l_139;
                l_135 = (void*)0;
                /* statement id: 110 */
                assert (l_135 == 0);
            }
            /* facts after for loop */
            assert (l_135 == 0 || l_135 == &l_128);
        }
    }
    /* facts after for loop */
        return l_141;
    /* statement id: 114 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_83(int32_t * p_84)
{ /* block id: 58 */
    int32_t l_86 = 9;
    float l_88 = 0x0.Bp-1;
    float *l_87 = &l_88;
    int32_t *l_89 = &l_86;
    union U1 l_90 = {2U};
    (*l_87) = l_86;
    (*l_89) = 1;
    return l_90;
    /* statement id: 61 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_94(union U2  p_95)
{ /* block id: 64 */
    int32_t l_97 = 0x020C2888;
    int32_t *l_96 = &l_97;
    (*l_96) = 2;
    return p_95.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_102(int32_t * p_103, float  p_104)
{ /* block id: 68 */
    float l_105 = (-0x1.Dp+1);
    float *l_106 = &l_105;
    (*l_106) = l_105;
    return (*p_103);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 112
XXX total union variables: 11

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 23
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 129

XXX times a variable address is taken: 116
XXX times a pointer is dereferenced on RHS: 35
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 52
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 225

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 135
   level: 2, occurrence: 11
   level: 3, occurrence: 3
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 63
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 34.1
XXX average alias set size: 1.25

XXX times a non-volatile is read: 293
XXX times a non-volatile is write: 148
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 99
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 13
   depth: 2, occurrence: 24
   depth: 3, occurrence: 14
   depth: 4, occurrence: 12
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 14.8
XXX percentage an existing variable is used: 85.2
********************* end of statistics **********************/

