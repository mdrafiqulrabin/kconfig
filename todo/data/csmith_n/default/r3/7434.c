/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   (none)
 * Seed:      3155276500
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static volatile int32_t g_2 = 0L;/* VOLATILE GLOBAL g_2 */
static int32_t g_3[5][8][1] = {{{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL}},{{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L}},{{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL}},{{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL}},{{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L},{0x05BAF43BL},{0x05BAF43BL},{0xEEDE0B40L}}};
static int32_t g_12[8][7][4] = {{{0x643747C9L,0x203BD652L,(-10L),0x2DB6377FL},{9L,0xFF74B76FL,0x21046671L,0x68108531L},{0x19BD12F8L,0x7494DFD9L,(-10L),(-1L)},{0xA7967268L,5L,1L,0L},{8L,6L,0xB46FAC5AL,0x52601C8DL},{1L,6L,0x798BE49CL,0x864B91BFL},{0L,1L,0x43D2717FL,(-8L)}},{{1L,0L,0L,0x4132D38CL},{0xD50FA8FAL,(-4L),0x864B91BFL,0xE23A266DL},{0x7EEDF667L,0x4DBB9A2FL,1L,0x43D2717FL},{0x4A3A6D7DL,0x864B91BFL,(-1L),0xF2BA10F4L},{(-10L),7L,0x4DBB9A2FL,1L},{(-8L),9L,0x7494DFD9L,0x798BE49CL},{0x6D77974DL,0xA6AED1D2L,1L,1L}},{{0x0A9B27FAL,0x0A9B27FAL,0xFF74B76FL,(-1L)},{0x4DBB9A2FL,0x4132D38CL,7L,0x1AC28C4FL},{0xC8FF05C8L,0x825D8284L,(-1L),7L},{0x5CF1C946L,0x825D8284L,7L,0x1AC28C4FL},{0x825D8284L,0x4132D38CL,(-10L),(-1L)},{0xD5BEFA1EL,0x0A9B27FAL,0x68266C09L,1L},{0x1731D497L,0xA6AED1D2L,0L,0x798BE49CL}},{{3L,9L,1L,1L},{(-1L),7L,0xEF3B0639L,0xF2BA10F4L},{0xBF68D270L,0x864B91BFL,(-1L),0x43D2717FL},{1L,0x4DBB9A2FL,(-1L),0xE23A266DL},{0xA6AED1D2L,(-4L),0x039EE491L,0x4132D38CL},{0xC5A3D7F1L,0L,1L,(-8L)},{9L,1L,(-2L),0x864B91BFL}},{{(-1L),6L,0xB0BADCABL,0x52601C8DL},{0xE23A266DL,6L,1L,0L},{0x52601C8DL,5L,0x8AAC1E0FL,(-1L)},{9L,0x7494DFD9L,(-6L),0x68108531L},{(-1L),(-4L),0x7EEDF667L,(-10L)},{0x5A51F3E6L,0x8AAC1E0FL,0x35DD253DL,0x7494DFD9L},{4L,0xFF74B76FL,3L,0x30A9BCA7L}},{{0L,0xB46FAC5AL,0x5CF1C946L,0x866193FEL},{0x864B91BFL,0x5CF1C946L,0x68108531L,0x46B4C01FL},{0x30A9BCA7L,1L,6L,(-2L)},{0xFCB06A9BL,(-1L),0x203BD652L,4L},{0xB0BADCABL,0x4549C4B0L,1L,0xFCB06A9BL},{0x46B4C01FL,0xEF3B0639L,0xED1B4B1CL,0xEA6AE202L},{(-3L),1L,(-3L),1L}},{{0x35DD253DL,0x039EE491L,0xBF68D270L,8L},{0xFF74B76FL,0x42BE197EL,0L,0x039EE491L},{0L,0xED1B4B1CL,0L,1L},{0xFF74B76FL,9L,0xBF68D270L,0xC8FF05C8L},{0x35DD253DL,0x19BD12F8L,(-3L),0xD5BEFA1EL},{(-3L),0xD5BEFA1EL,0xED1B4B1CL,(-1L)},{0x46B4C01FL,0x203BD652L,1L,5L}},{{0xB0BADCABL,0x1731D497L,0x8AAC1E0FL,(-4L)},{(-1L),0xD50FA8FAL,0xF2BA10F4L,7L},{0x4549C4B0L,(-1L),(-1L),0x5A51F3E6L},{0x1DD2E91CL,0xBD61C064L,(-3L),0xEA6AE202L},{0xED1B4B1CL,0x6D77974DL,0L,0x2DB6377FL},{0xA6AED1D2L,1L,0x2DB6377FL,0xAB653B1DL},{0x6A4137D6L,0xC8FF05C8L,6L,(-10L)}}};
static uint32_t g_14[1][9] = {{4UL,4UL,4UL,4UL,4UL,4UL,4UL,4UL,4UL}};
static int32_t g_18 = 1L;
static int32_t * const  volatile g_17 = &g_18;/* VOLATILE GLOBAL g_17 */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_14 g_2 g_17
 * writes: g_3 g_14 g_18
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    for (g_3[1][4][0] = (-30); (g_3[1][4][0] > 25); ++g_3[1][4][0])
    { /* block id: 3 */
        uint64_t l_11[10][3];
        uint32_t *l_13 = &g_14[0][6];
        int i, j;
        for (i = 0; i < 10; i++)
        {
            for (j = 0; j < 3; j++)
                l_11[i][j] = 1UL;
        }
        (*g_17) = (safe_sub_func_uint16_t_u_u(g_3[1][4][0], (+(safe_sub_func_uint64_t_u_u(((l_11[0][1] ^ 0L) > l_11[0][1]), (g_3[1][4][0] & (((*l_13)++) == g_2)))))));
    }
    return g_3[2][5][0];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 8; j++)
        {
            for (k = 0; k < 1; k++)
            {
                transparent_crc(g_3[i][j][k], "g_3[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 7; j++)
        {
            for (k = 0; k < 4; k++)
            {
                transparent_crc(g_12[i][j][k], "g_12[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 9; j++)
        {
            transparent_crc(g_14[i][j], "g_14[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_18, "g_18", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 8
breakdown:
   depth: 1, occurrence: 2
   depth: 2, occurrence: 1
   depth: 8, occurrence: 1

XXX total number of pointers: 2

XXX times a variable address is taken: 2
XXX times a pointer is dereferenced on RHS: 0
breakdown:
XXX times a pointer is dereferenced on LHS: 2
breakdown:
   depth: 1, occurrence: 2
XXX times a pointer is compared with null: 0
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 0

XXX max dereference level: 1
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 3
XXX number of pointers point to pointers: 0
XXX number of pointers point to scalars: 2
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 0
XXX average alias set size: 1

XXX times a non-volatile is read: 6
XXX times a non-volatile is write: 4
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 5
XXX percentage of non-volatile access: 83.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 3
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 2
   depth: 1, occurrence: 1

XXX percentage a fresh-made variable is used: 28.6
XXX percentage an existing variable is used: 71.4
********************* end of statistics **********************/

