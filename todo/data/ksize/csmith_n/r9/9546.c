/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2097831669
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 25;
   signed f1 : 12;
   const signed f2 : 31;
   unsigned f3 : 14;
   unsigned f4 : 7;
   signed f5 : 4;
};
#pragma pack(pop)

union U1 {
   uint8_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-5L);
static int32_t g_5 = 0x23AFC371L;
static volatile struct S0 g_65 = {5676,-7,-41700,41,2,1};/* VOLATILE GLOBAL g_65 */
static int32_t *g_70 = &g_5;
static int32_t ** volatile g_69 = &g_70;/* VOLATILE GLOBAL g_69 */
static union U1 g_125 = {0UL};
static float g_127 = 0x0.2p-1;
static int32_t g_132 = (-6L);
static int32_t * volatile g_131 = &g_132;/* VOLATILE GLOBAL g_131 */
static float * volatile *g_133 = (void*)0;
static float * volatile **g_139 = &g_133;
static float * volatile *** const  volatile g_138 = &g_139;/* VOLATILE GLOBAL g_138 */
static int32_t *** volatile g_140 = (void*)0;/* VOLATILE GLOBAL g_140 */
static int32_t * volatile g_157 = &g_132;/* VOLATILE GLOBAL g_157 */
static int32_t **g_208 = &g_70;
static int32_t *** volatile g_207 = &g_208;/* VOLATILE GLOBAL g_207 */
static int32_t * volatile g_235 = &g_132;/* VOLATILE GLOBAL g_235 */
static float *****g_242 = (void*)0;
static struct S0 g_244 = {2423,51,-4120,32,3,0};
static int32_t ** volatile g_247 = &g_70;/* VOLATILE GLOBAL g_247 */
static int32_t ** volatile g_250 = &g_70;/* VOLATILE GLOBAL g_250 */
static int32_t *** volatile *g_256 = (void*)0;
static int32_t *** volatile ** volatile g_255 = &g_256;/* VOLATILE GLOBAL g_255 */
static int32_t * volatile g_346 = &g_132;/* VOLATILE GLOBAL g_346 */
static struct S0 *g_379 = (void*)0;
static int32_t ** volatile g_381 = &g_70;/* VOLATILE GLOBAL g_381 */
static int32_t * volatile g_458 = &g_132;/* VOLATILE GLOBAL g_458 */
static int32_t g_500 = 0x1136A16AL;
static int32_t ** volatile g_507 = &g_70;/* VOLATILE GLOBAL g_507 */
static int32_t g_549 = 0x1D8FB549L;
static const int32_t **** volatile g_553 = (void*)0;/* VOLATILE GLOBAL g_553 */
static union U1 *g_566 = &g_125;
static union U1 ** volatile g_565 = &g_566;/* VOLATILE GLOBAL g_565 */
static struct S0 g_569 = {1194,22,-42314,76,9,-0};


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_1(void);
inline static int32_t * func_9(int32_t * p_10, int32_t * p_11, int32_t * p_12, int32_t * p_13);
static int32_t * func_16(int32_t  p_17, float  p_18, uint32_t  p_19, int32_t * p_20, uint32_t  p_21);
inline static uint8_t  func_24(float  p_25, float  p_26, uint32_t  p_27, int32_t  p_28, int32_t * p_29);
static float  func_30(uint8_t  p_31, uint32_t  p_32, float  p_33, const int8_t  p_34, const int8_t  p_35);
inline static int32_t  func_38(union U1  p_39, uint16_t  p_40, float  p_41, int32_t  p_42);
static uint8_t  func_46(union U1  p_47);
inline static union U1  func_48(int32_t  p_49, int32_t * p_50, int32_t * const  p_51, uint32_t  p_52);
inline static int32_t * func_53(int16_t  p_54, uint32_t  p_55);
static uint16_t  func_58(int16_t  p_59, const uint16_t  p_60, uint32_t  p_61, struct S0  p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_5 g_132 g_157 g_566 g_125
 * writes: g_2 g_5 g_132
 */
inline static union U1  func_1(void)
{ /* block id: 0 */
    int32_t *l_14 = &g_2;
    for (g_2 = (-8); (g_2 > (-10)); g_2 = safe_sub_func_int16_t_s_s(g_2, 8))
    { /* block id: 3 */
        for (g_5 = 20; (g_5 < (-29)); g_5 = safe_sub_func_uint8_t_u_u(g_5, 3))
        { /* block id: 6 */
            uint32_t l_8 = 0UL;
            int32_t *l_15 = &g_5;
            int32_t **l_608 = &l_15;
            if (l_8)
                break;
        }
    }
    for (g_132 = 24; (g_132 <= (-8)); --g_132)
    { /* block id: 186 */
        if ((*g_157))
            break;
    }
    return (*g_566);
    /* statement id: 189 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_2 g_244.f0 g_125.f0 g_5 g_65.f1 g_132 g_65.f3 g_500 g_244.f5 g_244.f4 g_250 g_70 g_127 g_244.f3 g_69 g_507 g_65.f5 g_125 g_235 g_549 g_458 g_157 g_565 g_131 g_65.f2 g_569.f5 g_244.f1
 * writes: g_127 g_70 g_379 g_566
 */
inline static int32_t * func_9(int32_t * p_10, int32_t * p_11, int32_t * p_12, int32_t * p_13)
{ /* block id: 140 */
    int32_t l_465 = 0xD8DC617FL;
    float *l_479 = &g_127;
    float **l_478 = &l_479;
    const float *l_488 = &g_127;
    const float **l_487 = &l_488;
    const float ***l_486 = &l_487;
    const float ****l_485 = &l_486;
    const float *****l_484 = &l_485;
    int32_t l_489 = 0xD695708AL;
    uint16_t l_490 = 65535UL;
    const int32_t ***l_492 = (void*)0;
    int32_t l_505 = 0x3A19E924L;
    struct S0 *l_562 = &g_244;
    int8_t l_591 = 0x19L;
    union U1 **l_598 = &g_566;
    const int8_t l_606 = 1L;
    int32_t l_607 = 1L;
    if ((safe_mod_func_uint32_t_u_u((((((l_465 <= (safe_unary_minus_func_int8_t_s((safe_mul_func_uint8_t_u_u(((l_465 == (0x5AL == g_2)) < l_465), (safe_lshift_func_int8_t_s_s((2L != (((safe_mod_func_int16_t_s_s(((((safe_sub_func_uint8_t_u_u((safe_lshift_func_int16_t_s_s((~((l_478 == &l_479) != ((((safe_rshift_func_int8_t_s_s(((safe_rshift_func_uint8_t_u_u(((l_484 == &l_485) || g_244.f0), l_465)) <= l_489), l_489)) == g_125.f0) > l_489) || (*p_11)))), 7)), 0xCBL)) | 0x4F24L) > 7L) <= l_489), l_465)) != (*p_12)) , g_65.f1)), 5))))))) ^ l_489) == l_490) ^ g_2) | g_132), (-1L))))
    { /* block id: 141 */
        int32_t ***l_491 = &g_208;
        int32_t l_501 = (-1L);
        uint32_t l_529 = 18446744073709551607UL;
        int32_t *l_534 = (void*)0;
        int32_t ****l_552 = &l_491;
        int32_t *****l_551 = &l_552;
        if ((l_491 == l_492))
        { /* block id: 142 */
            int32_t l_493 = (-1L);
            float ****l_502 = (void*)0;
            int32_t l_506 = 0xFE6EC7DCL;
            struct S0 **l_528 = &g_379;
            p_10 = func_16(l_493, ((((safe_div_func_uint32_t_u_u((safe_mul_func_int8_t_s_s((g_65.f3 == (0UL ^ g_125.f0)), (l_492 == &g_208))), l_493)) < ((safe_mul_func_uint8_t_u_u((g_500 >= (l_489 && 0x1F017065L)), 0x8DL)) ^ 0x19F9B688L)) & g_244.f5) , l_493), g_244.f4, p_13, l_501);
            /* statement id: 143 */
            assert (p_10 == &g_127);
            (*g_507) = func_53((((((((*g_250) == p_13) , ((p_11 != (void*)0) , l_502)) != l_502) <= ((((safe_mod_func_uint32_t_u_u(((*p_13) && l_505), (65530UL ^ g_244.f0))) <= 0UL) == g_5) & 1UL)) && g_244.f3) , l_506), g_244.f4);
            if (((safe_mod_func_uint16_t_u_u(((safe_add_func_uint16_t_u_u((g_500 | ((safe_div_func_uint8_t_u_u(251UL, (safe_unary_minus_func_uint16_t_u(((safe_mod_func_uint8_t_u_u((safe_div_func_int32_t_s_s((safe_div_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((safe_rshift_func_int8_t_s_s((+l_506), 4)), (safe_lshift_func_uint8_t_u_u(((g_65.f5 , &g_379) == l_528), 7)))), l_529)), (((safe_mul_func_int16_t_s_s((safe_rshift_func_int8_t_s_s((((void*)0 != l_534) <= g_5), l_506)), g_244.f3)) , 18446744073709551615UL) , (*p_12)))), g_5)) ^ l_506))))) < l_506)), 0x18DCL)) == 0L), l_506)) && g_244.f5))
            { /* block id: 145 */
                uint32_t l_546 = 0xB1F425F7L;
                int32_t *l_550 = &g_500;
                for (l_493 = (-10); (l_493 > 2); l_493 = safe_add_func_int16_t_s_s(l_493, 1))
                { /* block id: 148 */
                    int32_t ****l_539 = (void*)0;
                    (**l_478) = ((g_125 , ((&g_139 != ((!1UL) , &g_139)) > (+l_506))) <= (l_539 == l_539));
                    l_550 = func_16((*g_235), ((safe_sub_func_float_f_f(((0x1.0p+1 > (0x1.Ap+1 > (((((((g_244.f0 || ((safe_add_func_uint8_t_u_u(7UL, l_546)) >= (safe_mul_func_int16_t_s_s((g_244.f0 , ((**l_484) == &g_133)), g_125.f0)))) && 8UL) , 0xFFL) , l_546) > 0xE.823067p+2) < l_546) == 0x8.D5A355p+49))) != g_549), 0x0.9p-1)) < l_493), g_549, p_13, g_244.f4);
                    /* statement id: 150 */
                    assert (l_550 == &g_127);
                    if ((l_551 != &l_539))
                    { /* block id: 151 */
                        const int32_t ****l_554 = &l_492;
                        const float ***l_555 = &l_487;
                        (*l_554) = l_492;
                        if ((*p_13))
                            continue;
                        (*p_13) = ((((g_244.f0 <= ((((**l_484) == l_555) , g_244.f0) , l_506)) ^ (~0x283CL)) , (*p_12)) > (safe_mod_func_uint8_t_u_u(((safe_unary_minus_func_int8_t_s((((safe_mod_func_int8_t_s_s(l_493, g_65.f5)) ^ g_2) && (*g_458)))) | (*l_550)), 0xC8L)));
                        if ((*g_157))
                            continue;
                    }
                    else
                    { /* block id: 156 */
                        union U1 **l_563 = (void*)0;
                        union U1 **l_564 = (void*)0;
                        (*l_550) = (*p_10);
                        (*l_528) = l_562;
                        /* statement id: 158 */
                        assert (g_379 == &g_244);
                        l_550 = (void*)0;
                        /* statement id: 159 */
                        assert (l_550 == 0);
                        (*g_565) = &g_125;
                    }
                    /* facts after branching */
                    assert (l_550 == 0 || l_550 == &g_127);
                    (**l_478) = (l_506 != 0xD.A7D517p-4);
                }
                /* facts after for loop */
                assert (l_550 == 0 || l_550 == &g_127 || l_550 == &g_500);
            }
            else
            { /* block id: 164 */
                return p_10;
                /* statement id: 165 */
                //assert (func_9_rv == &g_127);
            }
        }
        else
        { /* block id: 167 */
            union U1 **l_567 = (void*)0;
            l_567 = l_567;
            return p_10;
            /* statement id: 169 */
            //assert (func_9_rv == &g_2);
        }
        /* facts after branching */
        assert (p_10 == &g_127);
        (*l_479) = (&g_138 == ((*g_131) , &l_485));
        return p_12;
        /* statement id: 172 */
        //assert (func_9_rv == &g_5);
    }
    else
    { /* block id: 173 */
        struct S0 *l_568 = &g_569;
        const int32_t l_570 = 0xFC058D70L;
        float ** const *l_581 = (void*)0;
        uint32_t l_592 = 0xFF2FEEC0L;
        int32_t *l_593 = &g_500;
        l_568 = l_562;
        /* statement id: 174 */
        assert (l_568 == &g_244);
        (**l_478) = (l_570 > 0xF.543D71p-14);
        l_593 = func_16((safe_div_func_uint16_t_u_u((safe_div_func_int32_t_s_s(0xD38FB024L, (safe_add_func_int32_t_s_s(((safe_rshift_func_uint8_t_u_u(((safe_mod_func_uint8_t_u_u(((l_581 != (void*)0) & (safe_sub_func_uint32_t_u_u(((safe_unary_minus_func_uint32_t_u((safe_add_func_uint32_t_u_u((((safe_mul_func_int16_t_s_s((8UL > (safe_mul_func_uint8_t_u_u(((&l_568 == (void*)0) == (g_244.f5 == 0x60F8L)), g_65.f2))), 65535UL)) , (void*)0) != l_562), l_591)))) & l_592), l_570))), 0xC9L)) ^ g_569.f5), 4)) >= (*p_11)), l_570)))), l_570)), l_570, l_591, p_11, l_570);
        /* statement id: 176 */
        assert (l_593 == &g_127);
        (*l_593) = (-6L);
    }
    l_607 = ((safe_div_func_float_f_f((((safe_sub_func_uint8_t_u_u((((l_505 > (0x8F1BL ^ g_125.f0)) , l_598) != (void*)0), g_569.f5)) >= l_591) , (0x6.FF9F13p-74 <= (((((+(safe_sub_func_float_f_f(((safe_div_func_float_f_f((safe_sub_func_float_f_f((-0x7.2p-1), l_505)), (-0x1.Dp-1))) < g_244.f1), 0x5.980474p-49))) != l_606) < 0xD.E18136p-64) < l_591) > (-0x1.Ap-1)))), l_591)) < l_591);
    return p_10;
    /* statement id: 180 */
    //assert (func_9_rv == &g_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_127
 */
static int32_t * func_16(int32_t  p_17, float  p_18, uint32_t  p_19, int32_t * p_20, uint32_t  p_21)
{ /* block id: 136 */
    uint32_t l_461 = 0xE317A01BL;
    float *l_462 = &g_127;
    (*l_462) = (safe_mul_func_float_f_f(p_18, (l_461 < 0x3.46171Cp-61)));
    (*l_462) = p_19;
    return l_462;
    /* statement id: 139 */
    //assert (func_16_rv == &g_127);
}


/* ------------------------------------------ */
/* 
 * reads : g_244.f2 g_65.f3 g_125.f0 g_65.f1 g_244.f4 g_458
 * writes: g_70 g_132
 */
inline static uint8_t  func_24(float  p_25, float  p_26, uint32_t  p_27, int32_t  p_28, int32_t * p_29)
{ /* block id: 126 */
    int32_t **l_446 = &g_70;
    struct S0 **l_451 = &g_379;
    int32_t l_457 = (-1L);
    (*l_446) = (void*)0;
    /* statement id: 127 */
    assert (g_70 == 0);
    for (p_28 = 0; (p_28 > (-1)); p_28 = safe_sub_func_uint32_t_u_u(p_28, 1))
    { /* block id: 130 */
        const uint16_t l_456 = 0x3758L;
        (*l_446) = p_29;
        /* statement id: 131 */
        assert (g_70 == &g_2);
        (*g_458) = (safe_rshift_func_uint8_t_u_u(g_244.f2, (((((((l_451 != (void*)0) < (safe_rshift_func_uint16_t_u_u(p_28, 6))) , g_65.f3) , &g_139) != (void*)0) && ((((safe_mul_func_int16_t_s_s((-10L), (((((p_25 , g_125.f0) >= g_65.f1) , l_456) != g_244.f4) != p_27))) == p_28) == 0L) || l_457)) == 1UL)));
        (*l_446) = (void*)0;
        /* statement id: 133 */
        assert (g_70 == 0);
    }
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_65 g_69 g_5 g_70 g_125 g_131 g_133 g_138 g_132 g_125.f0 g_139 g_157 g_207 g_208 g_235 g_247 g_250 g_244.f1 g_255 g_244.f3 g_244.f5 g_346 g_244.f4 g_381 g_256 g_244.f2
 * writes: g_70 g_127 g_132 g_139 g_208 g_242 g_256 g_125.f0 g_379
 */
static float  func_30(uint8_t  p_31, uint32_t  p_32, float  p_33, const int8_t  p_34, const int8_t  p_35)
{ /* block id: 8 */
    union U1 l_43 = {255UL};
    struct S0 l_66 = {4434,25,-11536,54,10,0};
    int32_t * const l_71 = &g_5;
    int16_t l_274 = 1L;
    int32_t ***l_277 = &g_208;
    int32_t ****l_276 = &l_277;
    int32_t ***** const l_275 = &l_276;
    struct S0 *l_283 = (void*)0;
    struct S0 **l_282 = &l_283;
    float *l_301 = &g_127;
    float * const *l_300 = &l_301;
    float * const **l_299 = &l_300;
    uint32_t l_313 = 0x5C6941ACL;
    int32_t l_400 = (-10L);
    int8_t l_433 = 0x29L;
    if ((((p_31 && func_38(l_43, g_2, (safe_div_func_float_f_f(((func_46(func_48(l_43.f0, func_53((safe_lshift_func_int8_t_s_s((l_43.f0 && func_58(p_35, l_43.f0, (safe_mul_func_uint16_t_u_u(l_43.f0, (g_65 , 0x4FDAL))), l_66)), p_31)), l_66.f4), l_71, (*l_71))) , (-0x5.Dp+1)) < p_32), 0x1.Ap-1)), p_31)) && p_31) == g_244.f1))
    { /* block id: 66 */
        volatile struct S0 *l_254 = &g_65;
        volatile struct S0 **l_253 = &l_254;
        (*l_253) = &g_65;
        (*g_255) = &g_140;
        /* statement id: 68 */
        assert (g_256 == &g_140);
    }
    else
    { /* block id: 69 */
        int8_t l_257 = 0xB8L;
        float l_292 = (-0x5.2p-1);
        int32_t *l_315 = (void*)0;
        int32_t **** const l_349 = &l_277;
        float **l_353 = &l_301;
        float ***l_352 = &l_353;
        float l_376 = 0x2.Cp+1;
        int8_t l_405 = 0L;
        p_33 = (p_35 == (((l_257 > ((safe_mul_func_int16_t_s_s(g_2, (safe_mod_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u(65535UL, (-1L))), (safe_sub_func_int32_t_s_s((*g_157), ((safe_sub_func_int32_t_s_s(0x12EB8F5FL, (safe_div_func_uint32_t_u_u((safe_mod_func_int16_t_s_s((p_35 | (p_31 >= p_34)), p_34)), l_274)))) & l_257))))), 0x14L)))) , 0xA.89B81Ap+30)) >= 0xE.5A4709p-2) >= p_34));
        if (((&g_256 == l_275) || ((safe_mul_func_int8_t_s_s((0UL != ((safe_mul_func_uint16_t_u_u((((l_282 == (((safe_mod_func_uint8_t_u_u(0x83L, (l_43 , ((g_65.f2 && (~(((((~((safe_mul_func_uint16_t_u_u(((safe_lshift_func_uint8_t_u_s(p_32, ((((*g_131) != 0UL) >= p_31) , 1L))) <= (*l_71)), l_257)) <= g_2)) <= g_244.f3) && p_31) >= g_244.f5) , l_257))) | 0x4316L)))) <= p_34) , (void*)0)) <= g_132) & 0x94L), p_35)) & g_244.f1)), 0xADL)) < p_32)))
        { /* block id: 71 */
            int8_t l_314 = 1L;
            int32_t **l_316 = (void*)0;
            int32_t **l_317 = (void*)0;
            int32_t **l_318 = &g_70;
            (*l_318) = l_315;
            /* statement id: 72 */
            assert (g_70 == 0);
        }
        else
        { /* block id: 73 */
            union U1 *l_326 = &g_125;
            union U1 **l_325 = &l_326;
            int32_t l_341 = 0x96026280L;
            int32_t *l_360 = &l_341;
            for (l_43.f0 = 0; (l_43.f0 <= 45); l_43.f0 = safe_add_func_uint8_t_u_u(l_43.f0, 1))
            { /* block id: 76 */
                union U1 *l_322 = &g_125;
                union U1 **l_321 = &l_322;
                int16_t l_328 = 0xBF4EL;
                (*l_321) = &l_43;
                /* statement id: 77 */
                assert (l_322 == &l_43);
                for (p_31 = 0; (p_31 <= 23); p_31 = safe_add_func_int32_t_s_s(p_31, 2))
                { /* block id: 80 */
                    int32_t * const l_327 = (void*)0;
                    int32_t *l_329 = (void*)0;
                    float **l_336 = &l_301;
                    uint16_t l_344 = 0x04F5L;
                    uint32_t l_345 = 1UL;
                    l_329 = ((*l_322) , (void*)0);
                    if ((*g_131))
                        break;
                    (*g_346) = ((safe_add_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u(0xC3L, ((safe_rshift_func_uint16_t_u_s(7UL, p_31)) <= ((void*)0 != l_336)))), (((safe_add_func_int32_t_s_s(((((0x5DL >= (((0x55FC917AL < (((safe_add_func_uint8_t_u_u((l_341 ^ ((safe_add_func_uint8_t_u_u((l_344 , p_34), 0xFCL)) != 0xD0L)), l_345)) <= g_65.f5) | 0L)) != p_34) != 0xEFADBB90L)) != p_34) || p_35) != p_34), p_35)) != 1L) , 1UL))) >= l_328);
                }
            }
            for (g_125.f0 = 6; (g_125.f0 < 50); g_125.f0 = safe_add_func_int16_t_s_s(g_125.f0, 1))
            { /* block id: 88 */
                int32_t **l_356 = &l_315;
                union U1 *l_363 = &g_125;
                (*l_356) = l_360;
                /* statement id: 89 */
                assert (l_315 == &l_341);
                (*l_315) = (safe_lshift_func_int8_t_s_u((((void*)0 != l_363) | ((**l_356) | 7UL)), p_31));
            }
            /* facts after for loop */
            assert (l_315 == &l_341 || l_315 == 0);
            if ((safe_mod_func_uint16_t_u_u(((p_34 || 0x9680E614L) | ((safe_lshift_func_int16_t_s_s(0x50A0L, 6)) > p_34)), ((g_244.f4 > ((void*)0 == (**l_275))) | ((safe_div_func_int32_t_s_s((0L && (((safe_rshift_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((safe_add_func_int16_t_s_s(p_31, p_35)), p_32)), g_65.f4)) > p_31) , 0x04L)), p_34)) , p_32)))))
            { /* block id: 92 */
                uint32_t l_377 = 0xC1B5FC59L;
                int32_t *l_378 = &l_341;
                (*l_360) = p_32;
                l_378 = l_378;
                g_379 = &g_244;
                /* statement id: 95 */
                assert (g_379 == &g_244);
            }
            else
            { /* block id: 96 */
                int32_t *l_380 = &l_341;
                (*g_381) = l_380;
                /* statement id: 97 */
                assert (g_70 == &l_341);
                if ((**g_250))
                { /* block id: 98 */
                    return p_31;
                    /* statement id: 99 */
                    //assert (g_70 == dangling);
                }
                else
                { /* block id: 100 */
                    uint32_t l_387 = 0xC7B18381L;
                    uint32_t l_399 = 4294967288UL;
                    for (g_125.f0 = 0; (g_125.f0 < 16); g_125.f0 = safe_add_func_uint32_t_u_u(g_125.f0, 1))
                    { /* block id: 103 */
                        uint16_t l_386 = 65535UL;
                        (***l_299) = ((safe_div_func_float_f_f(l_386, (l_387 >= p_35))) == (-(p_33 < p_31)));
                        (*l_360) = ((safe_rshift_func_uint8_t_u_s((l_386 >= (*l_360)), 6)) && ((safe_add_func_int16_t_s_s((((1L > ((safe_div_func_uint8_t_u_u(g_244.f3, g_244.f4)) > (((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(((p_32 == g_65.f5) , (l_399 <= (((void*)0 == (*g_250)) , 0x1EL))), 6)), p_34)) , 4294967290UL) != p_31))) && g_65.f3) && p_32), 0x072DL)) & 0xF034B923L));
                        (*l_360) = (l_399 , l_400);
                    }
                    return p_32;
                    /* statement id: 108 */
                    //assert (g_70 == dangling);
                }
            }
            /* facts after branching */
            assert (g_379 == &g_244);
        }
        /* facts after branching */
        //assert (l_315 == dangling || l_315 == 0);
        assert (g_379 == &g_244 || g_379 == 0);
        for (p_32 = 0; (p_32 >= 6); p_32 = safe_add_func_uint32_t_u_u(p_32, 1))
        { /* block id: 114 */
            uint32_t l_414 = 6UL;
            uint8_t l_415 = 0xECL;
            int32_t l_416 = 0x1139FEF3L;
            l_416 = (safe_lshift_func_int8_t_s_s((l_405 | ((((((g_244.f3 | (safe_sub_func_uint32_t_u_u((safe_sub_func_int16_t_s_s((safe_mul_func_uint8_t_u_u((l_349 != (*g_255)), (safe_mod_func_int8_t_s_s((l_414 ^ g_244.f2), 0xC4L)))), (p_35 && l_414))), l_415))) > p_32) || p_34) > p_34) && p_31) , (*g_235))), 0));
            (***l_352) = (p_35 >= ((safe_sub_func_float_f_f(((-0x9.6p-1) >= (safe_add_func_float_f_f((p_35 > (safe_div_func_float_f_f((p_32 <= (safe_sub_func_float_f_f(((void*)0 != (*l_282)), (((safe_div_func_float_f_f((!(((*g_157) < ((((safe_mul_func_int16_t_s_s((&l_283 == ((safe_sub_func_int8_t_s_s((((safe_unary_minus_func_uint32_t_u((g_244.f3 && 0x9AL))) != 0L) ^ l_414), g_132)) , &l_283)), p_32)) || l_433) , 0xA7378F87L) > g_5)) , p_32)), 0x3.EFE563p-0)) != p_35) < 0xF.72FE90p+87)))), p_32))), (*l_71)))), p_32)) <= (-0x10.8p+1)));
            for (l_405 = 5; (l_405 == (-5)); l_405 = safe_sub_func_uint8_t_u_u(l_405, 9))
            { /* block id: 119 */
                union U1 *l_437 = &l_43;
                union U1 **l_436 = &l_437;
                (*l_436) = (void*)0;
                /* statement id: 120 */
                assert (l_437 == 0);
                (***l_299) = ((safe_mod_func_int8_t_s_s(p_34, (((safe_lshift_func_uint8_t_u_s(p_35, (safe_rshift_func_int8_t_s_u(g_65.f4, 2)))) , (safe_mul_func_int16_t_s_s(0x6351L, 1UL))) && g_65.f3))) , 0xF.A93B9Cp-49);
            }
        }
    }
    /* facts after branching */
    //assert (g_70 == &g_5 || g_70 == 0 || g_70 == dangling);
    //assert (g_139 == &g_133 || g_139 == dangling);
    //assert (g_208 == dangling || g_208 == &g_70);
    //assert (g_242 == 0 || g_242 == dangling);
    assert (g_256 == 0 || g_256 == &g_140);
    assert (g_379 == &g_244 || g_379 == 0);
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads : g_131 g_132
 * writes: g_127
 */
inline static int32_t  func_38(union U1  p_39, uint16_t  p_40, float  p_41, int32_t  p_42)
{ /* block id: 63 */
    uint32_t l_251 = 0x2B5A8EEEL;
    float *l_252 = &g_127;
    (*l_252) = l_251;
    return (*g_131);
}


/* ------------------------------------------ */
/* 
 * reads : g_247 g_69 g_70 g_250 g_132
 * writes: g_242 g_70 g_132
 */
static uint8_t  func_46(union U1  p_47)
{ /* block id: 51 */
    float *l_241 = &g_127;
    float **l_240 = &l_241;
    float ***l_239 = &l_240;
    float ****l_238 = &l_239;
    float *****l_237 = &l_238;
    struct S0 *l_243 = &g_244;
    int32_t l_248 = 0xD993EA59L;
    int32_t *l_249 = (void*)0;
    g_242 = l_237;
    /* statement id: 52 */
    assert (g_242 == &l_238);
    l_243 = l_243;
    if ((l_243 == (void*)0))
    { /* block id: 54 */
        uint32_t l_245 = 4294967295UL;
        return l_245;
        /* statement id: 55 */
        //assert (g_242 == dangling);
    }
    else
    { /* block id: 56 */
        int32_t * const l_246 = &g_132;
        (*g_247) = l_246;
        /* statement id: 57 */
        assert (g_70 == &g_132);
        (*l_246) = l_248;
        l_249 = func_53(l_248, p_47.f0);
        /* statement id: 59 */
        assert (l_249 == &g_132);
        (*g_250) = &l_248;
        /* statement id: 60 */
        assert (g_70 == &l_248);
    }
    /* facts after branching */
    assert (g_70 == &l_248);
    assert (l_249 == &g_132);
    return (*l_249);
    /* statement id: 62 */
    //assert (g_70 == dangling);
    //assert (g_242 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_70 g_65.f2 g_2 g_5 g_65 g_125 g_131 g_133 g_138 g_132 g_125.f0 g_139 g_157 g_207 g_208 g_235
 * writes: g_70 g_127 g_132 g_139 g_208
 */
inline static union U1  func_48(int32_t  p_49, int32_t * p_50, int32_t * const  p_51, uint32_t  p_52)
{ /* block id: 14 */
    int32_t **l_72 = &g_70;
    struct S0 l_80 = {1937,42,9627,81,10,-0};
    union U1 l_82 = {3UL};
    float *l_135 = (void*)0;
    float * volatile *l_134 = &l_135;
    int32_t l_156 = 1L;
    int32_t l_204 = 0xF2C1B0FFL;
    float l_205 = 0xE.B3E814p-68;
    int16_t l_206 = 0x51E1L;
    int32_t *l_232 = (void*)0;
    (*l_72) = (*g_69);
    (*l_72) = (void*)0;
    /* statement id: 16 */
    assert (g_70 == 0);
    if (((safe_lshift_func_int8_t_s_s((safe_rshift_func_int16_t_s_s((safe_lshift_func_int8_t_s_u(((g_65.f2 != p_52) >= (!((g_2 <= (&g_70 == (l_80 , (void*)0))) >= (+(l_82 , (safe_sub_func_int16_t_s_s((((((((void*)0 == l_72) , 1UL) , g_5) == (-0x7.Fp+1)) , 3L) != g_5), 0UL))))))), g_5)), g_2)), 7)) == p_52))
    { /* block id: 17 */
        int32_t *l_93 = (void*)0;
        float *l_126 = &g_127;
        (*l_72) = func_53(p_52, (safe_lshift_func_uint16_t_u_u(((safe_div_func_int32_t_s_s((*p_51), (safe_mod_func_int8_t_s_s((safe_add_func_int16_t_s_s((l_93 != (void*)0), (0x657AL && (safe_add_func_int8_t_s_s((1UL | (((1L != (safe_mul_func_int8_t_s_s(((-1L) & p_52), g_2))) || (-9L)) , g_2)), g_65.f2))))), g_2)))) >= 0x99AE1959L), g_5)));
        (*l_72) = (g_65 , ((g_65.f1 , (l_80.f4 > (safe_add_func_float_f_f(g_65.f4, 0x3.E13FEAp-12)))) , func_53((safe_add_func_int8_t_s_s((((((g_65.f1 | ((((safe_div_func_float_f_f(((((safe_add_func_float_f_f((p_49 >= ((-0x4.Ep-1) > (safe_div_func_float_f_f(((safe_mul_func_float_f_f((&g_5 != &g_5), p_49)) , g_5), l_80.f0)))), p_52)) < g_5) == 0x0.Fp+1) != p_49), p_52)) > g_5) , (*p_50)) || g_5)) ^ p_52) | g_2) & p_52) || 0L), g_5)), p_52)));
        (*l_126) = ((g_65.f1 != ((safe_sub_func_float_f_f(((safe_add_func_float_f_f((-(safe_mul_func_float_f_f((((&p_49 == (((((((((*p_51) >= (safe_div_func_uint8_t_u_u((((((p_52 , (safe_sub_func_int32_t_s_s(0xE97C1FB1L, p_49))) > ((safe_mod_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(0x1EF8B30EL, (*p_51))), (g_125 , 0x3FA0L))) > p_49)) , &p_49) != &p_49) < 0x52L), g_5))) <= 0x1CL) , 0xF.B72995p-76) , 248UL) < 9L) , &p_49) != &g_2) , (void*)0)) && 0xDA04L) , 0x6.7F316Bp+68), g_2))), 0x1.Dp-1)) >= (-0x2.1p-1)), g_2)) >= p_52)) > 0x1.E1A547p-45);
        (*l_72) = &p_49;
        /* statement id: 21 */
        assert (g_70 == &p_49);
    }
    else
    { /* block id: 22 */
        uint8_t l_128 = 255UL;
        (*g_131) = (l_128 <= (p_52 || (safe_lshift_func_uint16_t_u_u(0x1771L, 12))));
        l_134 = g_133;
        /* statement id: 24 */
        assert (l_134 == 0);
    }
    /* facts after branching */
    assert (g_70 == 0 || g_70 == &p_49);
    assert (l_134 == 0 || l_134 == &l_135);
    if ((safe_sub_func_int16_t_s_s((l_80.f1 && (250UL ^ 253UL)), 0UL)))
    { /* block id: 26 */
        int32_t ***l_141 = &l_72;
        int8_t l_142 = 0L;
        (*g_138) = &l_134;
        /* statement id: 27 */
        assert (g_139 == &l_134);
        (*l_141) = &g_70;
        if ((*g_131))
        { /* block id: 29 */
            int8_t l_155 = (-1L);
            (*g_157) = ((((p_50 != (void*)0) || 7UL) <= l_142) > (p_49 >= (safe_add_func_uint32_t_u_u((((((g_65.f0 ^ ((safe_mul_func_int8_t_s_s(((safe_lshift_func_int16_t_s_u((((((((safe_mod_func_int16_t_s_s(1L, (safe_add_func_uint32_t_u_u((safe_mod_func_int16_t_s_s(g_125.f0, p_52)), l_155)))) <= 0x2490L) & l_156) , p_52) , (void*)0) != (*g_139)) ^ 0x74F0L), 13)) && l_155), g_5)) < (-1L))) < p_52) == (*p_51)) <= 0x9DFCL) && p_49), l_155))));
        }
        else
        { /* block id: 31 */
            uint8_t l_158 = 1UL;
            l_158 = 0xEB3B5FD3L;
            (*g_139) = &l_135;
            /* statement id: 33 */
            assert (l_134 == &l_135);
        }
    }
    else
    { /* block id: 35 */
        uint32_t l_203 = 0x405526E2L;
        union U1 l_215 = {255UL};
        uint32_t l_234 = 4294967295UL;
        float * const l_236 = &g_127;
        for (g_132 = (-2); (g_132 != 10); g_132 = safe_add_func_int16_t_s_s(g_132, 6))
        { /* block id: 38 */
            float *l_201 = &g_127;
            int32_t l_202 = 0xFC3C19ABL;
            l_206 = (safe_mod_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_s(4UL, 14)), ((safe_mul_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u(p_52, ((((safe_rshift_func_int8_t_s_u((0x1B32B03DL && ((safe_div_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s((&l_72 == (((p_52 <= (safe_unary_minus_func_int8_t_s(((safe_mul_func_uint8_t_u_u((safe_mul_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u(((safe_lshift_func_uint16_t_u_u(p_49, (((((safe_sub_func_int32_t_s_s((safe_add_func_int16_t_s_s(((((p_52 || (safe_lshift_func_int8_t_s_s((+(p_49 ^ ((safe_mul_func_uint16_t_u_u(((safe_rshift_func_int8_t_s_u((safe_sub_func_uint8_t_u_u((l_201 == (void*)0), l_202)), g_132)) == (*g_131)), 1L)) <= 3UL))), 2))) != p_49) >= p_49) | 0xDDL), l_202)), p_49)) ^ p_49) != l_203) && p_52) <= l_203))) & l_202), g_125.f0)), l_202)), l_204)), g_2)) != 0x86L)))) , l_203) , (void*)0)), g_125.f0)), g_132)) < (*p_51))), 2)) , 2UL) & p_52) > g_5))), g_125.f0)) && g_2)));
            (*g_207) = &p_50;
            /* statement id: 40 */
            assert (g_208 == &p_50);
            (*g_208) = (void*)0;
            /* statement id: 41 */
            assert (p_50 == 0);
        }
        /* facts after for loop */
        assert (p_50 == 0 || p_50 == &g_5);
        assert (g_208 == &p_50 || g_208 == &g_70);
        for (l_203 = (-27); (l_203 >= 47); l_203 = safe_add_func_int8_t_s_s(l_203, 1))
        { /* block id: 45 */
            float * const *l_229 = &l_135;
            const int32_t l_233 = 1L;
            (*g_235) = (safe_sub_func_uint8_t_u_u(p_49, (safe_lshift_func_int8_t_s_u((l_215 , ((safe_lshift_func_int8_t_s_u((((safe_unary_minus_func_int8_t_s((((safe_mod_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_s(((safe_add_func_uint16_t_u_u((((safe_div_func_float_f_f(((safe_mul_func_float_f_f(((&l_135 != l_229) >= p_52), ((safe_mul_func_float_f_f(((g_65.f0 , (*l_72)) != (g_5 , l_232)), p_52)) < l_233))) > l_203), p_49)) <= p_52) , 0x8890L), g_2)) , p_49), 11)), p_49)) < l_234) ^ l_215.f0))) != g_125.f0) | p_52), 4)) & p_52)), l_203))));
        }
        (*g_208) = func_53((l_236 == p_50), (1L >= (*g_157)));
        /* statement id: 48 */
        assert (p_50 == 0 || p_50 == &p_49 || p_50 == &g_5);
    }
    /* facts after branching */
    assert (p_50 == 0 || p_50 == &p_49 || p_50 == &g_5);
    assert (g_139 == &g_133 || g_139 == &l_134);
    assert (g_208 == &p_50 || g_208 == &g_70);
    return l_82;
    /* statement id: 50 */
    //assert (g_70 == 0 || g_70 == dangling);
    //assert (g_139 == &g_133 || g_139 == dangling);
    //assert (g_208 == dangling || g_208 == &g_70);
    }


/* ------------------------------------------ */
/* 
 * reads : g_69 g_70
 * writes:
 */
inline static int32_t * func_53(int16_t  p_54, uint32_t  p_55)
{ /* block id: 12 */
    return (*g_69);
    /* statement id: 13 */
    //assert (func_53_rv == &g_5 || func_53_rv == 0 || func_53_rv == &p_49 || func_53_rv == &g_132);
}


/* ------------------------------------------ */
/* 
 * reads : g_69 g_5
 * writes: g_70
 */
static uint16_t  func_58(int16_t  p_59, const uint16_t  p_60, uint32_t  p_61, struct S0  p_62)
{ /* block id: 9 */
    int32_t *l_67 = &g_5;
    int32_t **l_68 = (void*)0;
    (*g_69) = l_67;
    /* statement id: 10 */
    assert (g_70 == &g_5);
    return (*l_67);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_65.f0, "g_65.f0", print_hash_value);
    transparent_crc(g_65.f1, "g_65.f1", print_hash_value);
    transparent_crc(g_65.f2, "g_65.f2", print_hash_value);
    transparent_crc(g_65.f3, "g_65.f3", print_hash_value);
    transparent_crc(g_65.f4, "g_65.f4", print_hash_value);
    transparent_crc(g_65.f5, "g_65.f5", print_hash_value);
    transparent_crc(g_125.f0, "g_125.f0", print_hash_value);
    transparent_crc_bytes (&g_127, sizeof(g_127), "g_127", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_244.f0, "g_244.f0", print_hash_value);
    transparent_crc(g_244.f1, "g_244.f1", print_hash_value);
    transparent_crc(g_244.f2, "g_244.f2", print_hash_value);
    transparent_crc(g_244.f3, "g_244.f3", print_hash_value);
    transparent_crc(g_244.f4, "g_244.f4", print_hash_value);
    transparent_crc(g_244.f5, "g_244.f5", print_hash_value);
    transparent_crc(g_500, "g_500", print_hash_value);
    transparent_crc(g_549, "g_549", print_hash_value);
    transparent_crc(g_569.f0, "g_569.f0", print_hash_value);
    transparent_crc(g_569.f1, "g_569.f1", print_hash_value);
    transparent_crc(g_569.f2, "g_569.f2", print_hash_value);
    transparent_crc(g_569.f3, "g_569.f3", print_hash_value);
    transparent_crc(g_569.f4, "g_569.f4", print_hash_value);
    transparent_crc(g_569.f5, "g_569.f5", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 109
   depth: 1, occurrence: 3
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 10
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 3
breakdown:
   indirect level: 0, occurrence: 3
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 6
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 61

XXX max expression depth: 43
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 4
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 4
   depth: 28, occurrence: 2
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 43, occurrence: 1

XXX total number of pointers: 120

XXX times a variable address is taken: 124
XXX times a pointer is dereferenced on RHS: 56
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 53
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 3
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 409

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 151
   level: 2, occurrence: 53
   level: 3, occurrence: 29
   level: 4, occurrence: 24
   level: 5, occurrence: 13
XXX number of pointers point to pointers: 65
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 6
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.28

XXX times a non-volatile is read: 534
XXX times a non-volatile is write: 132
XXX times a volatile is read: 45
XXX    times read thru a pointer: 0
XXX times a volatile is write: 14
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 178
XXX percentage of non-volatile access: 91.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 116
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 34
   depth: 2, occurrence: 20
   depth: 3, occurrence: 13
   depth: 4, occurrence: 10
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 15
XXX percentage an existing variable is used: 85
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

