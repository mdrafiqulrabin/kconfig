/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1423794231
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const int8_t  f0;
   int32_t  f1;
   uint8_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_32(void);
static int32_t * func_38(float  p_39, struct S0  p_40, int32_t * p_41, int32_t * p_42);
inline static int64_t  func_58(int32_t * p_59, int32_t * p_60, int32_t * p_61, int32_t * p_62, const int32_t * p_63);
static int32_t * func_64(int32_t * p_65, int32_t  p_66, int32_t  p_67, uint16_t  p_68);
inline static int8_t  func_69(int32_t * p_70, uint32_t  p_71, int32_t * p_72, uint32_t  p_73, int32_t * p_74);
static int32_t * func_78(struct S0  p_79, int32_t * p_80, uint32_t  p_81, int32_t * p_82, uint8_t  p_83);
static struct S0  func_84(uint8_t  p_85, int32_t * p_86, int32_t * p_87);
inline static int32_t ** func_89(const struct S0  p_90, int32_t ** p_91);
inline static int32_t ** func_93(int64_t  p_94, int32_t  p_95);
static int32_t * func_102(int32_t ** p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_32(void)
{ /* block id: 36 */
    int64_t l_33 = 2L;
    uint8_t l_697 = 246UL;
    int32_t l_713 = 0x5B0A76F9L;
    int32_t *l_712 = &l_713;
    uint32_t l_714 = 4294967295UL;
    uint8_t l_715 = 3UL;
    if (l_33)
    { /* block id: 37 */
        float l_34 = (-0x2.8p+1);
        int32_t l_35 = 0xB0AE28DEL;
        return l_35;
    }
    else
    { /* block id: 39 */
        int32_t *l_44 = (void*)0;
        int32_t **l_686 = &l_44;
        int32_t ***l_685 = &l_686;
        uint16_t l_689 = 65535UL;
        for (l_33 = 0; (l_33 >= (-6)); l_33 = safe_sub_func_int16_t_s_s(l_33, 3))
        { /* block id: 42 */
            struct S0 l_43 = {8L,-8L,7UL};
            int32_t l_46 = 0xA9413E45L;
            int32_t *l_45 = &l_46;
            const int32_t *l_682 = &l_46;
            const int32_t **l_681 = &l_682;
            (*l_681) = func_38(l_33, l_43, l_44, l_45);
            /* statement id: 366 */
            assert (l_682 == &l_46 || l_682 == 0);
            if ((*l_45))
                break;
        }
        for (l_33 = (-15); (l_33 <= 11); l_33 = safe_add_func_uint16_t_u_u(l_33, 4))
        { /* block id: 371 */
            int32_t l_688 = 0xBA5EFD8AL;
            int32_t *l_687 = &l_688;
            (*l_687) = (l_685 != (void*)0);
            return l_689;
        }
        for (l_689 = 0; (l_689 > 47); l_689 = safe_add_func_int64_t_s_s(l_689, 5))
        { /* block id: 377 */
            int32_t l_693 = 0x9ADDAD16L;
            int32_t * const l_692 = &l_693;
            int32_t **l_694 = &l_44;
            int32_t ** const *l_696 = &l_694;
            int32_t ** const **l_695 = &l_696;
            (*l_694) = l_692;
            /* statement id: 378 */
            assert (l_44 == &l_693);
            if (l_33)
            { /* block id: 379 */
                int32_t *l_698 = &l_693;
                struct S0 l_699 = {1L,0xF367F346L,0x3DL};
                (***l_695) = func_78(((l_33 <= (&l_685 != l_695)) , func_84(l_697, (***l_695), l_698)), l_698, (*l_698), (*l_694), (*l_44));
                if (l_697)
                    continue;
                //assert (l_44 == dangling);
            }
            else
            { /* block id: 382 */
                int32_t *l_703 = &l_693;
                (*l_703) = ((safe_sub_func_uint16_t_u_u((safe_unary_minus_func_int16_t_s((*l_44))), (*l_703))) && (*l_44));
                if (l_697)
                    continue;
                //assert (l_44 == dangling);
                (****l_695) = (**l_694);
                (*l_694) = func_78(func_84((l_33 , (safe_lshift_func_uint8_t_u_s((safe_lshift_func_int8_t_s_s((3L == 1UL), (l_33 == 0x1A133051L))), (+((((((!((((**l_686) , (safe_div_func_uint64_t_u_u((((void*)0 == (*l_685)) || (*l_692)), (***l_696)))) && (*l_703)) > 18446744073709551609UL)) != (*l_44)) ^ 4UL) || 1L) == (**l_686)) ^ (****l_695)))))), (*l_686), l_703), l_712, l_714, (**l_685), (*l_703));
            }
        }
        /* facts after for loop */
        //assert (l_44 == dangling || l_44 == 0);
    }
    return l_715;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_38(float  p_39, struct S0  p_40, int32_t * p_41, int32_t * p_42)
{ /* block id: 43 */
    int32_t l_56 = (-8L);
    int32_t l_76 = 0x7718DA91L;
    int32_t *l_75 = &l_76;
    int32_t *l_544 = &l_76;
    const int32_t l_630 = 0x72727362L;
    const int32_t *l_629 = &l_630;
    int32_t *l_650 = &l_76;
    for (p_40.f1 = (-26); (p_40.f1 <= 20); p_40.f1 = safe_add_func_uint64_t_u_u(p_40.f1, 1))
    { /* block id: 46 */
        uint16_t l_55 = 1UL;
        struct S0 l_57 = {8L,0x6658069DL,0UL};
        int32_t *l_545 = &l_76;
        int32_t **l_680 = &l_544;
        for (p_40.f2 = (-18); (p_40.f2 > 60); p_40.f2 = safe_add_func_int64_t_s_s(p_40.f2, 1))
        { /* block id: 49 */
            uint64_t l_77 = 0xB389E7675DAAFE49LL;
            int32_t *l_88 = &l_76;
            uint32_t l_597 = 0x5DC526ADL;
            if (((((safe_sub_func_uint32_t_u_u((((safe_rshift_func_int16_t_s_u(l_55, 11)) , p_40) , l_56), (((l_57 , p_40.f0) && (func_58(func_64(p_42, (func_69(l_75, l_77, func_78(func_84(l_77, p_42, l_88), l_544, (*l_544), l_545, (*l_88)), p_40.f2, p_42) || p_40.f1), p_40.f0, l_597), p_42, l_88, l_75, l_629) , (*l_545))) , p_40.f0))) >= 0x8768C0D6L) , (*l_88)) || p_40.f2))
            { /* block id: 325 */
                int32_t **l_641 = &l_75;
                float l_656 = 0x1.B5009Fp+64;
                float *l_655 = &l_656;
                for (l_77 = 0; (l_77 > 56); l_77++)
                { /* block id: 328 */
                    struct S0 l_646 = {-2L,0x7818DF06L,255UL};
                    int32_t *l_647 = &l_76;
                    if ((func_69(p_42, (safe_lshift_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u((*l_88), (**l_641))), (**l_641))), &l_76, p_40.f1, p_42) != p_40.f1))
                    { /* block id: 329 */
                        return p_41;
                        /* statement id: 330 */
                        //assert (func_38_rv == 0);
                    }
                    else
                    { /* block id: 331 */
                        (*l_544) = (*l_75);
                        (**l_641) = (*l_88);
                    }
                    (*l_75) = ((p_40.f0 < p_40.f1) , (p_40.f0 & ((((p_40.f0 ^ p_40.f2) , p_41) != l_647) , (*l_629))));
                    for (l_57.f1 = 0; (l_57.f1 > (-7)); l_57.f1 = safe_sub_func_uint64_t_u_u(l_57.f1, 1))
                    { /* block id: 338 */
                        return p_41;
                        /* statement id: 339 */
                        //assert (func_38_rv == 0);
                    }
                }
                if ((*p_42))
                    break;
                (**l_641) = (*l_545);
                (*l_655) = ((((((l_545 == l_545) , p_39) < (*l_545)) != __builtin_parityl((((((__builtin_bswap32(p_40.f2) , (safe_lshift_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(p_40.f0, 6)) <= (((((void*)0 == &p_40) , 0L) == p_40.f2) >= p_40.f1)), (*l_88)))) == p_40.f0) | p_40.f1) && p_40.f2) , p_40.f0))) > p_39) >= (*l_88));
            }
            else
            { /* block id: 345 */
                uint32_t l_663 = 0xCCDF164EL;
                int32_t *l_670 = &l_76;
                struct S0 *l_678 = &l_57;
                struct S0 * const * const l_677 = &l_678;
                struct S0 * const * const *l_676 = &l_677;
                if ((l_663 >= 0L))
                { /* block id: 346 */
                    const uint32_t l_666 = 4294967295UL;
                    float **l_667 = (void*)0;
                    for (l_663 = 20; (l_663 != 52); l_663++)
                    { /* block id: 349 */
                        int32_t *l_671 = (void*)0;
                        float l_673 = 0x5.Fp-1;
                        float *l_672 = &l_673;
                        if (l_666)
                            break;
                        (*l_672) = ((((void*)0 == l_667) , func_69(p_42, ((((safe_sub_func_int64_t_s_s(func_58(&l_76, l_670, l_671, l_671, p_42), 18446744073709551610UL)) != p_40.f0) , (*l_545)) < p_40.f1), p_42, (*l_629), p_42)) >= p_39);
                        (*l_670) = (safe_add_func_int32_t_s_s((*l_670), (*l_88)));
                    }
                    (*l_75) = ((p_40.f2 | ((*p_42) >= ((*l_650) > ((*l_545) , ((void*)0 != l_676))))) <= (*l_670));
                }
                else
                { /* block id: 355 */
                    int32_t *l_679 = &l_76;
                    l_679 = (void*)0;
                    /* statement id: 356 */
                    assert (l_679 == 0);
                }
                return p_42;
                /* statement id: 358 */
                //assert (func_38_rv == &l_46);
            }
            (*l_88) = (-0x1.8p+1);
        }
        (*p_42) = (*l_545);
        (*l_680) = func_78((((*l_75) & ((((func_58(p_42, &l_76, p_42, l_545, &l_76) , (*l_545)) | (0x1941L < p_40.f1)) & 0UL) || (*l_75))) , p_40), p_42, p_40.f1, l_545, (*l_545));
    }
    return p_41;
    /* statement id: 365 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_46
 */
inline static int64_t  func_58(int32_t * p_59, int32_t * p_60, int32_t * p_61, int32_t * p_62, const int32_t * p_63)
{ /* block id: 318 */
    int32_t l_631 = 0x949CF7D4L;
    for (l_631 = 29; (l_631 <= 3); --l_631)
    { /* block id: 321 */
        int64_t l_634 = 0x50329CBFE1E81F09LL;
        (*p_59) = (l_634 && ((l_631 , &p_62) == (void*)0));
    }
    return l_631;
}


/* ------------------------------------------ */
/* 
 * reads : l_46
 * writes: l_46
 */
static int32_t * func_64(int32_t * p_65, int32_t  p_66, int32_t  p_67, uint16_t  p_68)
{ /* block id: 312 */
    uint64_t l_598 = 18446744073709551610UL;
    struct S0 l_601 = {0xF6L,0xFE203E2BL,249UL};
    int32_t l_603 = 7L;
    int32_t *l_602 = &l_603;
    int32_t **l_604 = (void*)0;
    int32_t **l_605 = &l_602;
    float l_608 = 0x3.3F8022p-38;
    float *l_607 = &l_608;
    float **l_606 = &l_607;
    uint64_t l_628 = 0x743CBE74B164CA12LL;
    (*p_65) = (((l_598 | p_66) <= (safe_mod_func_uint32_t_u_u(0x7EE5A397L, l_598))) >= (((p_68 , (func_69(func_78(l_601, p_65, l_598, p_65, p_66), p_68, l_602, (*l_602), p_65) , 0x0CCCE2B55BB157FALL)) , 0xE917L) != (-1L)));
    (*l_605) = func_78(l_601, &l_603, (*l_602), &l_603, p_66);
    (*p_65) = (l_606 != ((__builtin_clzll((*l_602)) > ((((safe_unary_minus_func_int16_t_s((((safe_mod_func_uint8_t_u_u(0x6EL, (**l_605))) , 18446744073709551608UL) && (((__builtin_bswap64((safe_div_func_uint8_t_u_u(p_66, 0x7AL))) , (*p_65)) != 0x88782683L) != 0x166AFCC3L)))) || (**l_605)) != (*l_602)) || p_67)) , (void*)0));
    (*l_607) = ((((safe_sub_func_float_f_f((+0xB.3C5BBEp-97), ((*l_602) >= ((*l_602) == (safe_div_func_float_f_f(((__builtin_clzl(((0xB362L & (((+(((safe_add_func_float_f_f((safe_div_func_float_f_f(0x7.Fp+1, (((void*)0 == &l_605) >= (((**l_605) <= p_68) < (*l_602))))), 0x0.0p+1)) == p_68) , 1UL)) > 0xFBL) && p_68)) || (**l_605))) < (**l_605)) <= (*l_602)), 0xB.E90F7Fp+31)))))) > (*l_602)) != (-0x6.Fp+1)) == 0x0.Fp+1);
    return p_65;
    /* statement id: 317 */
    //assert (func_64_rv == &l_46);
}


/* ------------------------------------------ */
/* 
 * reads : l_46
 * writes: l_46
 */
inline static int8_t  func_69(int32_t * p_70, uint32_t  p_71, int32_t * p_72, uint32_t  p_73, int32_t * p_74)
{ /* block id: 301 */
    int32_t *l_570 = (void*)0;
    int32_t **l_569 = &l_570;
    int32_t l_585 = 0xF37A7C3AL;
    int32_t l_586 = 0x38CC9142L;
    int32_t l_596 = 0xE957CD22L;
    for (p_71 = 17; (p_71 > 11); --p_71)
    { /* block id: 304 */
        int32_t *l_571 = (void*)0;
        float l_573 = 0x0.3p-1;
        float *l_572 = &l_573;
        (*l_569) = func_102(l_569);
        (*l_569) = ((p_73 <= (p_74 == (void*)0)) , l_571);
        (*l_572) = p_73;
    }
    (*p_74) = (safe_add_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((((safe_rshift_func_uint8_t_u_s(__builtin_ctz(((p_71 && ((safe_rshift_func_int16_t_s_s((p_71 , p_73), 3)) || (safe_sub_func_int8_t_s_s((1UL > (+(p_73 != (p_71 >= (((((p_71 , 0xBEDDEFFCEDC222EDLL) > p_73) > l_585) == p_71) & 0L))))), 0xC8L)))) > l_586)), p_71)) && (*p_70)) < p_71), p_73)), p_73));
    (*p_72) = (p_73 <= ((((p_73 ^ p_73) || ((safe_rshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((&p_74 != (p_71 , func_93(__builtin_bswap64((safe_sub_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u((((0x67042AF2L || (~l_596)) && p_73) > (5UL >= p_71)), p_73)), p_71))), (*p_72)))), p_71)), 9)) & p_73)) != 65532UL) || p_73));
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_46
 */
static int32_t * func_78(struct S0  p_79, int32_t * p_80, uint32_t  p_81, int32_t * p_82, uint8_t  p_83)
{ /* block id: 285 */
    uint16_t l_555 = 65532UL;
    int32_t l_566 = 0x34E4B48AL;
    int32_t *l_565 = &l_566;
    for (p_79.f2 = (-17); (p_79.f2 > 41); p_79.f2 = safe_add_func_int16_t_s_s(p_79.f2, 3))
    { /* block id: 288 */
        int32_t l_554 = 0xF9ABA57AL;
        for (p_83 = 0; (p_83 == 29); p_83 = safe_add_func_uint64_t_u_u(p_83, 5))
        { /* block id: 291 */
            int32_t l_558 = 6L;
            float l_560 = 0x0.Cp+1;
            float *l_559 = &l_560;
            (*l_559) = ((safe_sub_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u(((l_554 , (((4294967295UL || l_555) != 1L) || (safe_add_func_int8_t_s_s(l_555, __builtin_ctzl(p_79.f0))))) ^ (-9L)), (l_554 && 0xF5L))) & l_555), l_558)) , p_79.f1);
        }
    }
    if (l_555)
    { /* block id: 295 */
        (*p_82) = (0x62L > 7L);
    }
    else
    { /* block id: 297 */
        int32_t l_562 = 0x6F265DF6L;
        int32_t *l_561 = &l_562;
        int32_t **l_563 = (void*)0;
        int32_t **l_564 = &l_561;
        (*l_564) = l_561;
    }
    return p_82;
    /* statement id: 300 */
    //assert (func_78_rv == &l_76 || func_78_rv == &l_46 || func_78_rv == &l_603 || func_78_rv == &l_693);
}


/* ------------------------------------------ */
/* 
 * reads : l_46 l_693
 * writes:
 */
static struct S0  func_84(uint8_t  p_85, int32_t * p_86, int32_t * p_87)
{ /* block id: 50 */
    const struct S0 l_92 = {0xF8L,1L,0xB6L};
    const uint64_t l_98 = 0UL;
    const int32_t *l_543 = (void*)0;
    const int32_t **l_542 = &l_543;
    const int32_t ***l_541 = &l_542;
    (*l_541) = func_89(l_92, (l_92.f1 , func_93((((safe_lshift_func_uint8_t_u_u(1UL, 0)) <= ((((l_98 & p_85) || p_85) && p_85) <= 0L)) , (-1L)), (*p_86))));
    /* statement id: 283 */
    assert (l_542 == 0);
    return l_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_89(const struct S0  p_90, int32_t ** p_91)
{ /* block id: 200 */
    int16_t l_395 = 0x6B57L;
    float l_401 = 0x0.Dp+1;
    float *l_400 = &l_401;
    float **l_399 = &l_400;
    float ***l_398 = &l_399;
    int32_t l_405 = 0L;
    int32_t *l_404 = &l_405;
    int16_t l_418 = 0xA215L;
    int8_t l_419 = (-1L);
    uint32_t l_420 = 18446744073709551615UL;
    int16_t l_476 = (-9L);
    struct S0 l_485 = {0x0AL,0x083C83D1L,0xAEL};
    int8_t l_486 = (-7L);
    int32_t ***l_514 = (void*)0;
    struct S0 *l_517 = (void*)0;
    struct S0 **l_516 = &l_517;
    struct S0 ***l_515 = &l_516;
    (*l_404) = ((p_90.f0 <= __builtin_popcount(l_395)) <= (((((safe_sub_func_int16_t_s_s((l_398 != &l_399), (safe_sub_func_int64_t_s_s(l_395, 9L)))) , l_400) != l_400) | 0xC5FB2365L) || p_90.f2));
    if ((*l_404))
    { /* block id: 202 */
        float *l_412 = &l_401;
        int32_t l_417 = (-1L);
        const float *l_454 = &l_401;
        const float **l_453 = &l_454;
        const float ***l_452 = &l_453;
        int32_t *l_488 = (void*)0;
        int8_t l_491 = 0x80L;
        int64_t l_499 = 0x5DB5E339E2D13BF1LL;
        if (((safe_mod_func_uint32_t_u_u((*l_404), 9UL)) < (safe_add_func_int32_t_s_s(((safe_mod_func_uint16_t_u_u((l_412 == ((((safe_lshift_func_int8_t_s_u((((safe_add_func_uint8_t_u_u(((*l_404) & ((p_90.f0 , (((((((*l_404) & l_417) ^ (l_412 != ((l_417 || 0x9DL) , l_412))) > (*l_404)) == l_417) > (*l_404)) , p_90.f0)) && (*l_404))), l_418)) > p_90.f1) >= (*l_404)), l_419)) <= (-1L)) == l_420) , (**l_398))), 0xA4D0L)) , (-2L)), p_90.f1))))
        { /* block id: 203 */
            int32_t *l_423 = (void*)0;
            float ***l_455 = &l_399;
            int32_t l_489 = (-6L);
            for (l_418 = (-12); (l_418 < 15); l_418 = safe_add_func_int16_t_s_s(l_418, 6))
            { /* block id: 206 */
                int64_t l_435 = (-1L);
                float *l_436 = &l_401;
                int32_t l_437 = 0xD07CCF3DL;
                int32_t *l_467 = &l_405;
                if (l_417)
                { /* block id: 207 */
                    l_423 = &l_417;
                    /* statement id: 208 */
                    assert (l_423 == &l_417);
                    (**l_399) = 0x1.F29533p+67;
                }
                else
                { /* block id: 210 */
                    int32_t l_426 = 0xFEA44CA1L;
                    int32_t *l_427 = &l_417;
                    float **l_442 = &l_436;
                    for (l_395 = 16; (l_395 != 1); l_395 = safe_sub_func_int8_t_s_s(l_395, 1))
                    { /* block id: 213 */
                        int32_t **l_428 = &l_404;
                        struct S0 l_434 = {1L,0xE85249B6L,255UL};
                        struct S0 *l_433 = &l_434;
                        l_426 = l_417;
                        (*l_428) = l_427;
                        /* statement id: 215 */
                        assert (l_404 == &l_417);
                        l_437 = ((safe_add_func_float_f_f(__builtin_ffsl(p_90.f2), (safe_add_func_float_f_f((l_433 == (void*)0), (l_435 > ((((void*)0 == l_436) < l_417) < 0x2.AA5389p+3)))))) , 0x0.8p-1);
                        (*l_412) = 0x0.5p+1;
                    }
                    (*l_427) = ((l_417 & ((((safe_sub_func_uint8_t_u_u(l_437, (((safe_rshift_func_uint16_t_u_s((l_442 == (void*)0), p_90.f1)) > __builtin_popcountll((*l_404))) <= 0L))) <= 8L) , p_90.f0) , p_90.f2)) , 1L);
                    if ((*l_427))
                        break;
                    if ((*l_427))
                        continue;
                }
                if (((((((((((*l_404) , ((0x2BCA56F5464C12E7LL ^ (0x7F6DA724L | (((((void*)0 != l_436) == ((*l_404) | l_435)) <= p_90.f0) != (safe_lshift_func_uint8_t_u_u(((0x68F6FE38L && l_435) , p_90.f2), l_435))))) <= 0xB1L)) | p_90.f1) , (**l_398)) != (void*)0) && l_417) & 0xEB8B460C7B6CD0E4LL) , (*l_399)) == l_423) > 0UL))
                { /* block id: 223 */
                    int64_t l_447 = 0xA725512561FEC4C3LL;
                    (*l_404) = l_417;
                    if (__builtin_ia32_crc32qi(l_447, (safe_mod_func_uint8_t_u_u(p_90.f1, (safe_mod_func_uint64_t_u_u(l_417, 0x51CD99B518B7EA2CLL))))))
                    { /* block id: 225 */
                        uint32_t l_456 = 0xFB79B9CBL;
                        (*l_404) = __builtin_clzl(p_90.f2);
                        l_417 = __builtin_ctzll(__builtin_ia32_crc32qi((*l_404), (((l_452 != l_455) ^ p_90.f0) & (0UL || ((l_456 , p_90) , p_90.f2)))));
                        (*l_404) = (((__builtin_ia32_crc32qi(p_90.f2, (*l_404)) , __builtin_ctz(p_90.f1)) , l_447) , (((((safe_rshift_func_uint16_t_u_u((65528UL < (((__builtin_ffsl((p_90.f0 != (-1L))) < l_456) >= l_447) && p_90.f2)), 4)) , (void*)0) == p_91) >= (-1L)) ^ p_90.f2));
                    }
                    else
                    { /* block id: 229 */
                        (*l_404) = l_447;
                    }
                    return p_91;
                    /* statement id: 232 */
                    //assert (func_89_rv == 0);
                }
                else
                { /* block id: 233 */
                    int64_t l_461 = 2L;
                    int32_t **l_466 = &l_404;
                    (***l_455) = ((((((p_90.f0 != (l_437 <= l_461)) && (!(0xF58FL != l_461))) ^ (*l_404)) , l_461) >= ((-p_90.f2) == (safe_div_func_float_f_f(((((*l_404) , 6UL) , 0xB.B00099p+74) < (-0x1.Dp+1)), l_461)))) != p_90.f1);
                    if (l_461)
                    { /* block id: 235 */
                        return p_91;
                        /* statement id: 236 */
                        //assert (func_89_rv == 0);
                    }
                    else
                    { /* block id: 237 */
                        (*l_466) = l_467;
                        /* statement id: 238 */
                        assert (l_404 == &l_405);
                    }
                    /* facts after branching */
                    assert (l_404 == &l_405);
                    for (l_395 = 14; (l_395 > (-29)); l_395 = safe_sub_func_int16_t_s_s(l_395, 9))
                    { /* block id: 242 */
                        (**l_466) = (*l_404);
                        return p_91;
                        /* statement id: 244 */
                        //assert (func_89_rv == 0);
                    }
                }
                /* facts after branching */
                assert (l_404 == &l_405);
            }
            /* facts after for loop */
            assert (l_404 == &l_417 || l_404 == &l_405);
            assert (l_423 == 0 || l_423 == &l_417);
            if (((safe_lshift_func_uint8_t_u_u((safe_add_func_uint64_t_u_u(p_90.f1, (safe_sub_func_int8_t_s_s(p_90.f0, l_476)))), (safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s((*l_404), ((1UL || (((*l_404) < ((p_90.f1 == (safe_div_func_uint8_t_u_u(p_90.f1, (safe_add_func_uint64_t_u_u((l_485 , p_90.f0), p_90.f1))))) | p_90.f0)) != (*l_404))) == (-1L)))), 9)))) , l_486))
            { /* block id: 248 */
                int32_t **l_487 = &l_404;
                (*l_487) = &l_417;
                /* statement id: 249 */
                assert (l_404 == &l_417);
                l_488 = &l_405;
                /* statement id: 250 */
                assert (l_488 == &l_405);
            }
            else
            { /* block id: 251 */
                (*l_404) = (4294967295UL == 1L);
                l_489 = (*l_404);
            }
            /* facts after branching */
            assert (l_488 == 0 || l_488 == &l_405);
        }
        else
        { /* block id: 255 */
            int32_t **l_490 = &l_404;
            struct S0 ***l_518 = &l_516;
            (*l_490) = func_102(l_490);
            /* statement id: 256 */
            assert (l_404 == 0 || l_404 == &l_405);
            if (l_491)
            { /* block id: 257 */
                int32_t *l_492 = &l_405;
                (*l_492) = p_90.f1;
                (*l_398) = (*l_398);
                (*l_490) = func_102((((p_90.f0 , (safe_sub_func_uint64_t_u_u((((((((((0x02B3L ^ (__builtin_popcountl((safe_add_func_int32_t_s_s((safe_add_func_int8_t_s_s(__builtin_bswap64(p_90.f2), (l_499 || (p_90.f0 >= p_90.f2)))), 0x609A7D0FL))) < p_90.f0)) | p_90.f0) == l_486) , p_90.f0) >= p_90.f0) , 0x74BF43E6L) , p_90.f0) >= p_90.f1) >= 18446744073709551615UL), p_90.f2))) == p_90.f2) , &l_488));
                /* statement id: 260 */
                assert (l_404 == 0);
                //assert (l_488 == dangling || l_488 == 0);
                for (l_486 = 0; (l_486 == 6); l_486 = safe_add_func_uint8_t_u_u(l_486, 7))
                { /* block id: 263 */
                    return p_91;
                    /* statement id: 264 */
                    //assert (func_89_rv == 0);
                }
            }
            else
            { /* block id: 266 */
                float l_502 = 0x4.7p+1;
                int32_t *l_503 = &l_405;
                (*l_503) = ((l_486 & 6L) & p_90.f2);
                (*l_490) = (*l_490);
                l_518 = ((((0L > ((p_90.f0 > p_90.f1) > p_90.f0)) , 0x3EL) & (safe_rshift_func_uint8_t_u_s(((((((safe_mod_func_uint16_t_u_u((((safe_div_func_uint32_t_u_u(l_499, (safe_add_func_int64_t_s_s((safe_lshift_func_uint8_t_u_u((&l_490 != l_514), 4)), 0xD841ADF634814E29LL)))) | p_90.f2) != p_90.f2), 3UL)) | (-1L)) || (*l_503)) & 0xBBBE7A0DD96F3A13LL) || p_90.f0) || (*l_503)), (*l_503)))) , l_515);
            }
            /* facts after branching */
            //assert (l_488 == dangling || l_488 == 0);
        }
        /* facts after branching */
        assert (l_404 == 0 || l_404 == &l_405 || l_404 == &l_417);
        //assert (l_488 == dangling || l_488 == 0 || l_488 == &l_405);
    }
    else
    { /* block id: 272 */
        uint64_t l_521 = 0x829680E88FAD16AALL;
        int64_t l_534 = 0L;
        int32_t l_538 = (-7L);
        int32_t *l_537 = &l_538;
        for (l_405 = 0; (l_405 == 9); l_405 = safe_add_func_uint8_t_u_u(l_405, 2))
        { /* block id: 275 */
            int8_t l_527 = 5L;
            int32_t l_535 = 0x1873C17FL;
            int32_t *l_536 = &l_535;
            int32_t **l_539 = (void*)0;
            int32_t **l_540 = &l_404;
        }
    }
    /* facts after branching */
    //assert (l_404 == 0 || l_404 == &l_405 || l_404 == dangling);
    return p_91;
    /* statement id: 282 */
    //assert (func_89_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_93(int64_t  p_94, int32_t  p_95)
{ /* block id: 51 */
    int32_t l_100 = 0xA2EEDF21L;
    int32_t *l_99 = &l_100;
    int32_t **l_101 = &l_99;
    struct S0 *l_388 = (void*)0;
    const struct S0 **l_389 = (void*)0;
    const struct S0 l_392 = {0x8DL,0x28478C44L,253UL};
    const struct S0 *l_391 = &l_392;
    const struct S0 **l_390 = &l_391;
    int32_t **l_393 = &l_99;
    int32_t **l_394 = (void*)0;
    l_99 = &p_95;
    /* statement id: 52 */
    assert (l_99 == &p_95);
    (*l_101) = (void*)0;
    /* statement id: 53 */
    assert (l_99 == 0);
    (*l_101) = func_102(&l_99);
    (*l_390) = l_388;
    /* statement id: 198 */
    assert (l_391 == 0);
    return l_394;
    /* statement id: 199 */
    //assert (func_93_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_102(int32_t ** p_103)
{ /* block id: 54 */
    const uint32_t l_104 = 0x3CA56B74L;
    int32_t l_107 = (-4L);
    const int32_t * const l_106 = &l_107;
    const int32_t * const * const l_105 = &l_106;
    int32_t *l_108 = &l_107;
    struct S0 l_114 = {1L,0x1299D621L,0xD8L};
    struct S0 *l_113 = &l_114;
    int8_t l_137 = 2L;
    int32_t *l_156 = &l_107;
    int16_t l_232 = (-2L);
    struct S0 l_256 = {0xB9L,9L,255UL};
    int32_t ****l_298 = (void*)0;
    int32_t *l_370 = &l_107;
    uint8_t l_377 = 0x67L;
    int32_t **l_385 = &l_156;
    int32_t *l_386 = &l_107;
    int32_t *l_387 = (void*)0;
    (*l_108) = ((l_104 , l_105) == (void*)0);
    (*p_103) = (*p_103);
    if (__builtin_bswap32((safe_lshift_func_uint8_t_u_u((safe_rshift_func_uint8_t_u_u((**l_105), 4)), __builtin_clz(((void*)0 == &l_108))))))
    { /* block id: 57 */
        struct S0 **l_115 = &l_113;
        (*l_115) = l_113;
        (*l_108) = 0xAAA0C7D0L;
    }
    else
    { /* block id: 60 */
        uint64_t l_116 = 0x59947D9BA7415234LL;
        int32_t *l_117 = &l_107;
        const struct S0 *l_121 = &l_114;
        const struct S0 **l_120 = &l_121;
        int32_t *l_154 = (void*)0;
        int32_t *l_157 = &l_107;
        uint64_t l_199 = 0xC1246BF972A186CBLL;
        uint32_t l_205 = 0xED00A948L;
        int32_t l_225 = (-9L);
        uint32_t l_230 = 0UL;
        int32_t *l_263 = &l_225;
        int32_t *l_297 = &l_225;
        float ***l_338 = (void*)0;
        if (l_116)
        { /* block id: 61 */
            uint32_t l_122 = 0x87F0BBFFL;
            (*p_103) = l_117;
            /* statement id: 62 */
            //assert (l_99 == &l_107);
            l_122 = (safe_sub_func_float_f_f((l_120 == (void*)0), __builtin_ia32_crc32qi(__builtin_ffsll(((*l_117) & (-2L))), (*l_117))));
        }
        else
        { /* block id: 64 */
            int32_t *l_123 = &l_107;
            return (*p_103);
            /* statement id: 65 */
            //assert (func_102_rv == 0 || func_102_rv == &l_405 || func_102_rv == &l_76);
        }
        /* facts after branching */
        //assert (l_99 == &l_107);
        l_117 = (*p_103);
        for (l_114.f1 = 0; (l_114.f1 == 11); l_114.f1 = safe_add_func_uint64_t_u_u(l_114.f1, 1))
        { /* block id: 70 */
            int32_t **l_126 = &l_117;
            const float l_179 = 0xF.1EEBA0p-56;
            struct S0 *l_213 = (void*)0;
            uint8_t l_229 = 255UL;
            (*l_126) = (*l_105);
        }
        if ((0x0FL & ((*l_117) != __builtin_ctzl((*l_108)))))
        { /* block id: 138 */
            int8_t l_233 = 0xF4L;
            struct S0 l_246 = {0x4AL,0x047A856CL,0x22L};
            int32_t *l_264 = &l_107;
            int32_t *l_265 = &l_107;
            float *l_269 = (void*)0;
            float **l_268 = &l_269;
            int32_t **l_274 = (void*)0;
            int32_t ***l_273 = &l_274;
            int32_t ****l_272 = &l_273;
            struct S0 **l_326 = &l_113;
            int32_t *l_362 = &l_107;
            uint64_t l_376 = 0xF2DE70E6D607DAFELL;
            float l_379 = 0x6.7466EFp-5;
            float *l_378 = &l_379;
            (*l_157) = ((*l_108) ^ l_232);
            if (((**l_105) , (l_233 , (**p_103))))
            { /* block id: 140 */
                int64_t l_247 = 0xCE832F596B8FCFDFLL;
                float l_249 = 0x5.0E336Ep-66;
                float *l_248 = &l_249;
                uint32_t l_260 = 4294967292UL;
                int32_t ***l_307 = &l_274;
                (*l_248) = (safe_div_func_float_f_f(0x0.6p-1, ((safe_div_func_float_f_f((((*l_157) <= 0xE17964D273E08976LL) , (**l_105)), ((*l_117) == (safe_sub_func_float_f_f(l_233, (&l_105 == (void*)0)))))) >= ((safe_add_func_float_f_f((__builtin_clz((safe_lshift_func_uint8_t_u_s(((safe_lshift_func_uint8_t_u_u((((l_246 , (**l_105)) , (**l_105)) <= 0x35DA1870280360E7LL), (*l_108))) , l_247), (*l_106)))) > 0x1.1p-1), (-0x10.2p+1))) != l_246.f0))));
                if ((safe_mod_func_uint64_t_u_u(((safe_mod_func_int8_t_s_s(((*l_108) > l_247), (*l_157))) > ((*l_117) & (l_247 | (((safe_div_func_int32_t_s_s(0L, (**p_103))) & 0x94EFD27CL) ^ (*l_157))))), (*l_106))))
                { /* block id: 142 */
                    int32_t *l_261 = &l_107;
                    if ((l_256 , ((safe_add_func_uint64_t_u_u(((*l_156) && (safe_unary_minus_func_uint64_t_u(l_246.f0))), l_260)) >= ((((*l_117) || (((((((*l_117) , l_261) != (void*)0) , &l_225) != (void*)0) , 0x4E35C125L) < (**p_103))) == (-10L)) || 0x01888FB7L))))
                    { /* block id: 143 */
                        int32_t *l_262 = &l_107;
                        int32_t *l_266 = (void*)0;
                        (*l_117) = (*l_108);
                        return l_266;
                        /* statement id: 145 */
                        //assert (l_99 == dangling);
                        //assert (func_102_rv == 0);
                    }
                    else
                    { /* block id: 146 */
                        uint64_t l_267 = 0x27DFF7E24B3D2473LL;
                        float ***l_270 = &l_268;
                        (*l_248) = (*l_264);
                        (**p_103) = ((l_267 || 1L) <= (*l_264));
                        (*l_270) = l_268;
                    }
                }
                else
                { /* block id: 151 */
                    int32_t ****l_271 = (void*)0;
                    l_272 = l_271;
                    /* statement id: 152 */
                    assert (l_272 == 0);
                }
                /* facts after branching */
                assert (l_272 == 0 || l_272 == &l_273);
                if ((safe_lshift_func_uint16_t_u_s(((-1L) < (safe_lshift_func_uint16_t_u_u(l_260, (*l_157)))), ((safe_rshift_func_uint16_t_u_u((*l_263), (safe_lshift_func_int8_t_s_s(((*l_263) , ((*l_157) != l_260)), (safe_lshift_func_uint16_t_u_u(((void*)0 == (*p_103)), 7)))))) & (*l_264)))))
                { /* block id: 154 */
                    uint8_t l_285 = 0x0FL;
                    struct S0 *l_291 = &l_256;
                    int32_t *l_296 = (void*)0;
                    (*l_248) = l_285;
                    for (l_256.f1 = 0; (l_256.f1 != 0); l_256.f1 = safe_add_func_uint32_t_u_u(l_256.f1, 6))
                    { /* block id: 158 */
                        uint64_t l_288 = 8UL;
                        (*l_248) = ((l_288 > __builtin_parityl((safe_lshift_func_int16_t_s_u(((l_291 == (void*)0) , (safe_mod_func_uint16_t_u_u(((*l_108) != l_285), (((((((**p_103) == (**p_103)) && (((safe_mod_func_uint8_t_u_u((0x1609L >= l_247), 0xC5L)) != l_288) , l_247)) < (**p_103)) , 65535UL) < (*l_265)) & l_260)))), 3)))) >= l_247);
                        return l_296;
                        /* statement id: 160 */
                        //assert (l_99 == dangling);
                        //assert (func_102_rv == 0);
                    }
                    (*p_103) = l_296;
                    /* statement id: 162 */
                    //assert (l_99 == 0);
                    l_296 = l_297;
                    /* statement id: 163 */
                    assert (l_296 == &l_225);
                }
                else
                { /* block id: 164 */
                    uint32_t l_299 = 0UL;
                    uint32_t l_314 = 0x86B6F2C5L;
                    int32_t ** const * const l_319 = &l_274;
                    int32_t ** const * const *l_318 = &l_319;
                    l_299 = ((l_260 < 0x1.Bp-1) == ((void*)0 != l_298));
                    for (l_114.f2 = (-3); (l_114.f2 <= 32); l_114.f2 = safe_add_func_int64_t_s_s(l_114.f2, 8))
                    { /* block id: 168 */
                        uint8_t l_317 = 246UL;
                        int32_t *****l_320 = (void*)0;
                        int32_t *****l_321 = &l_272;
                        (*l_265) = ((*l_108) > (0UL | (~(((safe_div_func_float_f_f((-0x1.4p+1), ((safe_div_func_float_f_f(l_247, ((void*)0 == l_307))) != ((-0x7.Dp-1) != (((safe_add_func_float_f_f((safe_div_func_float_f_f((safe_div_func_float_f_f(l_314, ((safe_div_func_float_f_f(0x6.4CF4C5p+46, (*l_108))) < l_314))), l_317)), (*l_117))) < l_314) == (*l_297)))))) , l_317) , l_314))));
                        (*l_321) = l_318;
                        /* statement id: 170 */
                        assert (l_272 == &l_319);
                    }
                    /* facts after for loop */
                    assert (l_272 == &l_319 || l_272 == 0 || l_272 == &l_273);
                    (*p_103) = (*p_103);
                }
                /* facts after branching */
                //assert (l_99 == &l_107 || l_99 == 0);
                //assert (l_272 == dangling || l_272 == 0 || l_272 == &l_273);
            }
            else
            { /* block id: 174 */
                int32_t l_329 = (-10L);
                const float ** const l_335 = (void*)0;
                struct S0 **l_363 = &l_113;
                if ((safe_mod_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s((l_326 == (((safe_lshift_func_uint8_t_u_u((*l_263), l_329)) | l_329) , &l_113)), 0)), 0x9EL)))
                { /* block id: 175 */
                    int32_t l_336 = 9L;
                    int32_t l_343 = 1L;
                    if ((safe_rshift_func_int16_t_s_u((((((safe_div_func_uint8_t_u_u((safe_unary_minus_func_uint8_t_u((*l_157))), (((*l_297) >= ((*l_297) || ((4294967295UL < (((((*l_265) != ((void*)0 == l_335)) , (**l_105)) & l_336) || l_329)) && 0x9C57274BL))) , (*l_106)))) < (-1L)) , l_329) , &l_268) == (void*)0), l_336)))
                    { /* block id: 176 */
                        float ***l_339 = &l_268;
                        int32_t * const l_342 = (void*)0;
                        int32_t l_350 = 0xE1A9960AL;
                        l_343 = (((((~l_329) , l_338) != l_339) < ((*l_121) , (0x2.101BBEp+13 >= ((safe_div_func_float_f_f(((((*p_103) != l_342) != ((((void*)0 == &l_335) , (void*)0) == (void*)0)) >= 0x0.4D267Ap-3), 0x4.92F417p-55)) == l_329)))) != (*l_106));
                        (*l_263) = ((safe_add_func_int8_t_s_s(0x4BL, (18446744073709551610UL & (safe_add_func_int32_t_s_s(l_343, (safe_lshift_func_uint16_t_u_s(l_350, l_329))))))) <= ((safe_add_func_uint32_t_u_u((((-10L) | ((*l_108) & (((l_336 & ((safe_unary_minus_func_uint8_t_u((safe_mod_func_uint16_t_u_u(__builtin_popcountl((safe_sub_func_uint16_t_u_u((l_336 <= (*l_297)), (-1L)))), (*l_264))))) < 0xB704D01ACA74AEDCLL)) == l_329) < (*l_108)))) , 0x54045763L), 0x5F52A438L)) == l_329));
                        l_343 = (18446744073709551615UL && (((((safe_rshift_func_uint16_t_u_s(((65535UL && (l_343 ^ (((((**p_103) || __builtin_ctzl((*l_263))) | l_343) , (l_329 , (*p_103))) == l_362))) != 250UL), l_329)) , l_336) , 18446744073709551615UL) , l_363) != (void*)0));
                    }
                    else
                    { /* block id: 180 */
                        uint16_t l_364 = 6UL;
                        float l_366 = (-0x10.Ep+1);
                        float *l_365 = &l_366;
                        (*l_362) = (l_329 < l_364);
                        (*l_365) = (*l_157);
                    }
                }
                else
                { /* block id: 184 */
                    float *l_367 = (void*)0;
                    float l_369 = 0x7.7p+1;
                    float *l_368 = &l_369;
                    (*l_368) = (*l_156);
                }
                (*l_265) = (**l_105);
            }
            /* facts after branching */
            //assert (l_99 == &l_107 || l_99 == 0);
            //assert (l_272 == dangling || l_272 == 0 || l_272 == &l_273);
            (*p_103) = l_370;
            /* statement id: 189 */
            //assert (l_99 == &l_107);
            (*l_378) = (((__builtin_parity(((~(safe_lshift_func_uint16_t_u_u((((((((*l_370) >= (safe_add_func_int64_t_s_s((*l_263), (*l_264)))) ^ (l_376 > (*l_108))) == ((((*l_113) , l_106) != (*l_268)) , 0x83C939FFL)) != (**p_103)) & 0UL) & (*l_265)), (*l_156)))) , (*l_370))) >= (*l_370)) != (*l_263)) < l_377);
        }
        else
        { /* block id: 191 */
            float *l_382 = (void*)0;
            float l_384 = 0x6.DCB3F3p+9;
            float *l_383 = &l_384;
            (*l_383) = (safe_add_func_float_f_f((*l_263), 0x6.D92E11p+92));
        }
    }
    /* facts after branching */
    //assert (l_99 == &l_107 || l_99 == 0);
    (*l_385) = (*l_105);
    return l_387;
    /* statement id: 196 */
    //assert (l_99 == dangling || l_99 == 0);
    //assert (func_102_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 181
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 183
   depth: 2, occurrence: 32
   depth: 3, occurrence: 5
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 4
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 175

XXX times a variable address is taken: 155
XXX times a pointer is dereferenced on RHS: 279
breakdown:
   depth: 1, occurrence: 199
   depth: 2, occurrence: 74
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 102
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 759

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 891
   level: 2, occurrence: 201
   level: 3, occurrence: 19
   level: 4, occurrence: 5
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 96
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 28.6
XXX average alias set size: 1.28

XXX times a non-volatile is read: 1184
XXX times a non-volatile is write: 267
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 170
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 22
   depth: 2, occurrence: 22
   depth: 3, occurrence: 30
   depth: 4, occurrence: 30
   depth: 5, occurrence: 33

XXX percentage a fresh-made variable is used: 15.8
XXX percentage an existing variable is used: 84.2
********************* end of statistics **********************/

