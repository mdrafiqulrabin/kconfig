/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2785157115
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   int64_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_29(void);
static int32_t * func_30(uint32_t  p_31);
static int8_t  func_34(int32_t  p_35, int32_t * p_36);
static const int64_t  func_41(int32_t * p_42, int32_t  p_43, int32_t * p_44, uint8_t  p_45, union U0  p_46);
static uint32_t  func_47(const uint16_t  p_48, int64_t  p_49, float  p_50, int32_t * p_51, int32_t  p_52);
inline static float  func_63(uint32_t  p_64, int32_t  p_65);
inline static int32_t  func_86(union U0  p_87, int32_t  p_88, union U0  p_89, int32_t * p_90, uint8_t  p_91);
inline static const int32_t  func_100(float  p_101, uint32_t  p_102, int8_t  p_103, union U0  p_104);
inline static const int16_t  func_115(int32_t  p_116);
inline static union U0 * func_117(int32_t ** p_118, uint8_t  p_119, int32_t  p_120);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_29(void)
{ /* block id: 36 */
    int64_t l_32 = (-1L);
    int32_t l_366 = 0xD8676E75L;
    int32_t *l_365 = &l_366;
    int32_t **l_364 = &l_365;
    (*l_364) = func_30(l_32);
    /* statement id: 194 */
    assert (l_365 == 0);
    return l_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(uint32_t  p_31)
{ /* block id: 37 */
    int32_t l_54 = 1L;
    int32_t *l_53 = &l_54;
    const int32_t l_289 = 0x64156023L;
    uint32_t l_290 = 0x354101DEL;
    union U0 l_291 = {0x85FEB4F4L};
    int32_t **l_298 = &l_53;
    uint8_t l_299 = 246UL;
    int16_t l_300 = 6L;
    union U0 ***l_304 = (void*)0;
    uint32_t l_305 = 5UL;
    int32_t *l_324 = &l_54;
    int32_t *l_361 = &l_54;
    int32_t *l_362 = &l_54;
    int32_t *l_363 = (void*)0;
    (*l_298) = (((+(func_34((safe_lshift_func_int16_t_s_u((safe_mod_func_int64_t_s_s(func_41((((__builtin_ctzl((func_47((l_53 == (void*)0), (safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(((safe_add_func_int64_t_s_s((-2L), (((((safe_add_func_float_f_f((((((void*)0 != &l_54) >= (p_31 , ((p_31 , p_31) > func_63(__builtin_ctzl(((safe_add_func_int8_t_s_s((p_31 <= (*l_53)), p_31)) ^ 0xFCD58F28L)), (*l_53))))) >= p_31) == 0x2.397847p-62), 0x0.0p-1)) != (*l_53)) <= 0x7.90BF56p+75) , (*l_53)) , p_31))) != (*l_53)), 4)), 0xFE08L)), (*l_53), &l_54, p_31) ^ 0x325D17A2L)) > l_289) >= 0xFA38L) , &l_54), p_31, l_53, l_290, l_291), p_31)), p_31)), l_53) || (*l_53))) <= l_290) , &l_54);
    l_299 = (**l_298);
    (*l_53) = (l_300 , (*l_53));
    if (((((((((*l_53) > ((safe_sub_func_int32_t_s_s(((void*)0 == &l_291), (__builtin_ffsll((safe_unary_minus_func_int8_t_s(((void*)0 == l_304)))) , ((p_31 ^ (**l_298)) == 0x446FC6978A9AF8CALL)))) == 0xBDE2L)) <= (*l_53)) == p_31) >= 0xFC8C9FE2L) , p_31) && p_31) || p_31))
    { /* block id: 155 */
        int32_t ***l_307 = &l_298;
        int32_t ****l_306 = &l_307;
        union U0 l_310 = {4294967295UL};
        float l_316 = 0x0.Bp-1;
        const float *l_315 = &l_316;
        const float **l_314 = &l_315;
        const float ***l_313 = &l_314;
        const float ****l_312 = &l_313;
        const float *****l_311 = &l_312;
        (*l_298) = (*l_298);
        (***l_307) = ((((l_306 != &l_307) >= ((***l_307) , func_41((*l_298), p_31, (*l_298), __builtin_popcountll((6L != (safe_rshift_func_uint8_t_u_u(((void*)0 == (*l_306)), 1)))), l_310))) , l_311) != &l_312);
        (*l_298) = (*l_298);
        for (l_300 = 15; (l_300 != 25); l_300 = safe_add_func_int32_t_s_s(l_300, 1))
        { /* block id: 161 */
            int32_t *l_319 = &l_54;
            if ((*l_53))
                break;
            (***l_306) = l_319;
        }
    }
    else
    { /* block id: 165 */
        uint64_t l_320 = 0x0BD6D02A7A2EF323LL;
        int32_t *l_325 = &l_54;
        if ((func_34(((*l_298) != (void*)0), (*l_298)) < 0L))
        { /* block id: 166 */
            int16_t l_328 = 0xDE82L;
            uint32_t l_338 = 4294967295UL;
            if ((__builtin_clz(l_320) ^ (*l_53)))
            { /* block id: 167 */
                int32_t *l_326 = (void*)0;
                for (l_291.f0 = (-2); (l_291.f0 != 55); l_291.f0 = safe_add_func_int16_t_s_s(l_291.f0, 3))
                { /* block id: 170 */
                    int32_t *l_323 = &l_54;
                    return l_326;
                    /* statement id: 171 */
                    //assert (func_30_rv == 0);
                }
                (*l_298) = (*l_298);
                (*l_53) = 0x371AF357L;
                (**l_298) = (**l_298);
            }
            else
            { /* block id: 176 */
                float *l_329 = (void*)0;
                float l_331 = 0x2.D501D7p-35;
                float *l_330 = &l_331;
                int32_t l_339 = 0L;
                union U0 l_340 = {4294967294UL};
                (*l_330) = (!((0x0.8p-1 == ((*l_324) > func_34(l_328, l_325))) == p_31));
                (*l_53) = ((l_328 >= p_31) >= ((safe_sub_func_uint64_t_u_u(p_31, (safe_sub_func_uint8_t_u_u(((0x4EL ^ (&l_304 == (void*)0)) | ((1L <= ((safe_lshift_func_int16_t_s_u(((l_338 , (*l_325)) & p_31), 7)) <= l_339)) & 0x92A9C3C7EA47AE80LL)), (**l_298))))) || l_339));
                (*l_325) = (((l_340 , (func_41(l_325, p_31, (*l_298), p_31, l_340) , (func_34(p_31, l_325) > p_31))) , p_31) != p_31);
            }
            (*l_298) = (p_31 , l_325);
        }
        else
        { /* block id: 182 */
            int32_t l_348 = 0x8480B581L;
            int32_t *l_352 = (void*)0;
            float *l_358 = (void*)0;
            float l_360 = 0x1.8p+1;
            float *l_359 = &l_360;
            (**l_298) = (p_31 >= (safe_mod_func_int64_t_s_s((safe_mod_func_uint8_t_u_u((**l_298), (((p_31 == ((((*l_53) < ((p_31 <= ((-0x6.Ep-1) < ((p_31 >= (safe_sub_func_float_f_f((((-(0x1.6EB0CFp-4 != (*l_325))) >= (*l_325)) != p_31), 0x1.6B6714p-59))) >= 0x1.Fp-1))) <= l_348)) <= (*l_325)) <= (*l_325))) != 0x0.Ep-1) , (*l_325)))), (*l_324))));
            for (l_348 = (-5); (l_348 == (-20)); l_348 = safe_sub_func_int16_t_s_s(l_348, 9))
            { /* block id: 186 */
                int32_t *l_351 = &l_54;
                (*l_298) = l_351;
                return l_352;
                /* statement id: 188 */
                //assert (func_30_rv == 0);
            }
            (*l_359) = (((!((((*l_325) == 0UL) <= (((*l_324) , func_115((safe_sub_func_int8_t_s_s((safe_div_func_uint8_t_u_u(__builtin_parityl((*l_324)), (__builtin_parityl(p_31) | (l_348 ^ (6L & p_31))))), 0x5EL)))) <= (*l_324))) , (*l_53))) >= (*l_53)) == (*l_325));
        }
    }
    return l_363;
    /* statement id: 193 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_34(int32_t  p_35, int32_t * p_36)
{ /* block id: 148 */
    int32_t l_296 = 0xAC4171A6L;
    int32_t *l_295 = &l_296;
    int32_t **l_297 = &l_295;
    (*l_297) = l_295;
    (**l_297) = (__builtin_ia32_crc32qi((*l_295), (**l_297)) > ((1UL && (*l_295)) , ((__builtin_clzll((*l_295)) ^ (**l_297)) , 0xC9CAL)));
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_41(int32_t * p_42, int32_t  p_43, int32_t * p_44, uint8_t  p_45, union U0  p_46)
{ /* block id: 145 */
    union U0 l_294 = {4UL};
    union U0 *l_293 = &l_294;
    union U0 **l_292 = &l_293;
    (*l_292) = &p_46;
    /* statement id: 146 */
    assert (l_293 == &p_46);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_47(const uint16_t  p_48, int64_t  p_49, float  p_50, int32_t * p_51, int32_t  p_52)
{ /* block id: 47 */
    int64_t l_76 = 0L;
    int8_t l_79 = (-1L);
    union U0 l_92 = {4294967290UL};
    int32_t *l_93 = (void*)0;
    union U0 **l_189 = (void*)0;
    union U0 ***l_188 = &l_189;
    int8_t l_202 = 0L;
    int16_t l_228 = 0x375FL;
    int64_t l_247 = 0L;
    int32_t **l_286 = &l_93;
    int32_t ***l_285 = &l_286;
    const int32_t * const ***l_287 = (void*)0;
    int32_t ****l_288 = &l_285;
    if ((((p_49 & l_76) <= l_76) <= (((l_76 , (safe_add_func_float_f_f((__builtin_popcountl((l_79 && ((((safe_add_func_uint64_t_u_u(((safe_sub_func_uint32_t_u_u(((((safe_rshift_func_uint16_t_u_s(p_52, (__builtin_parityl((0x8A82L | (((((func_86(l_92, p_48, l_92, l_93, p_48) , 0x2E7E12F4000348E7LL) <= p_49) , 8L) > 0xE1L) < 0UL))) | l_92.f0))) <= l_79) && p_49) <= l_92.f0), p_49)) , 18446744073709551608UL), p_48)) || 1UL) ^ 0UL) > 255UL))) , p_49), p_52))) >= p_49) , l_92.f0)))
    { /* block id: 51 */
        float *l_114 = (void*)0;
        uint32_t l_168 = 0x13FB221DL;
        int32_t l_222 = (-1L);
        uint64_t l_226 = 1UL;
        union U0 l_227 = {0x60B95517L};
        for (l_92.f1 = 0; (l_92.f1 < 26); l_92.f1++)
        { /* block id: 54 */
            uint8_t l_107 = 0x11L;
            float l_113 = (-0x1.4p+1);
            float *l_112 = &l_113;
            int16_t l_167 = (-1L);
            union U0 ***l_186 = (void*)0;
            int64_t l_203 = 1L;
            float **l_214 = &l_114;
            float ***l_213 = &l_214;
            union U0 l_225 = {0xDE4B5726L};
        }
        /* facts after for loop */
            }
    else
    { /* block id: 109 */
        float l_243 = 0x8.315D34p-65;
        float *l_242 = &l_243;
        union U0 *l_244 = (void*)0;
        union U0 l_249 = {4294967295UL};
        (*l_242) = p_49;
        l_244 = l_244;
        (*p_51) = (*p_51);
        if (((l_247 > (safe_unary_minus_func_uint16_t_u(0UL))) || ((l_249 , 0xB7FAL) & l_249.f0)))
        { /* block id: 113 */
            const float *l_256 = &l_243;
            int32_t l_257 = 0x309FADE2L;
            float *** const l_258 = (void*)0;
            float **l_261 = &l_242;
            float ***l_260 = &l_261;
            float ****l_259 = &l_260;
            (*l_259) = ((__builtin_popcountll(p_52) >= ((safe_add_func_float_f_f(((((-0x1.0p-1) < (((void*)0 == &p_52) != (safe_div_func_float_f_f((safe_sub_func_float_f_f((((((*p_51) || __builtin_ffs((__builtin_ffsl((l_93 == l_256)) , l_249.f0))) == l_249.f0) , p_52) , (-0x1.3p-1)), l_92.f0)), l_257)))) >= 0xB.33F1E1p-14) != l_249.f0), 0x2.Ep-1)) <= p_52)) , l_258);
            /* statement id: 114 */
            assert (l_260 == 0);
            return l_257;
        }
        else
        { /* block id: 116 */
            union U0 l_266 = {0x071AFD06L};
            float **l_276 = &l_242;
            float ** const *l_275 = &l_276;
            for (l_79 = (-12); (l_79 >= 6); l_79 = safe_add_func_int8_t_s_s(l_79, 1))
            { /* block id: 119 */
                uint64_t l_267 = 0x77CBA12CAA50289ELL;
                for (l_228 = (-9); (l_228 != (-10)); l_228 = safe_sub_func_uint16_t_u_u(l_228, 1))
                { /* block id: 122 */
                    int32_t l_269 = 1L;
                    int32_t *l_268 = &l_269;
                    int32_t **l_281 = (void*)0;
                    int32_t **l_282 = &l_93;
                    if ((__builtin_ctzll(func_86((l_249.f0 , l_266), l_267, l_266, l_268, (safe_rshift_func_uint16_t_u_u(__builtin_clzl((((safe_div_func_uint16_t_u_u((((+(p_48 ^ (&l_242 == (void*)0))) , l_275) == (void*)0), p_48)) , 0xE0B499DA406727EBLL) > (*l_268))), 15)))) >= 0UL))
                    { /* block id: 123 */
                        int32_t **l_277 = (void*)0;
                        int32_t **l_278 = &l_268;
                        (*l_278) = &p_52;
                        /* statement id: 124 */
                        assert (l_268 == &p_52);
                        if ((*l_268))
                            continue;
                    }
                    else
                    { /* block id: 126 */
                        (**l_276) = 0xF.30543Fp-1;
                        if ((*p_51))
                            continue;
                        (*l_268) = ((safe_div_func_uint32_t_u_u(p_49, (*l_268))) & l_267);
                        if ((*p_51))
                            break;
                    }
                    /* facts after branching */
                    assert (l_268 == &l_269 || l_268 == &p_52);
                    (*l_282) = &p_52;
                    /* statement id: 132 */
                    assert (l_93 == &p_52);
                    p_50 = l_249.f0;
                    for (l_92.f1 = 0; (l_92.f1 >= 26); l_92.f1 = safe_add_func_uint16_t_u_u(l_92.f1, 1))
                    { /* block id: 136 */
                        return p_49;
                    }
                    /* facts after for loop */
                                    }
            }
            /* facts after for loop */
            assert (l_93 == &p_52 || l_93 == 0);
        }
        /* facts after branching */
        assert (l_93 == &p_52 || l_93 == 0);
    }
    /* facts after branching */
    assert (l_93 == &p_52 || l_93 == 0);
    (*l_288) = l_285;
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_63(uint32_t  p_64, int32_t  p_65)
{ /* block id: 38 */
    float l_69 = 0x1.Ep-1;
    float *l_68 = &l_69;
    int32_t *l_70 = (void*)0;
    int32_t **l_71 = &l_70;
    (*l_68) = p_65;
    (*l_71) = l_70;
    for (p_65 = 0; (p_65 > (-20)); p_65 = safe_sub_func_uint16_t_u_u(p_65, 9))
    { /* block id: 43 */
        int32_t l_75 = 0xF55F5DDAL;
        int32_t *l_74 = &l_75;
        (*l_71) = l_74;
        /* statement id: 44 */
        assert (l_70 == &l_75);
    }
    /* facts after for loop */
    //assert (l_70 == dangling || l_70 == 0);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_86(union U0  p_87, int32_t  p_88, union U0  p_89, int32_t * p_90, uint8_t  p_91)
{ /* block id: 48 */
    int32_t *l_94 = (void*)0;
    int32_t *l_95 = (void*)0;
    int32_t l_97 = 0xDEA28050L;
    int32_t *l_96 = &l_97;
    (*l_96) = (4L | p_88);
    return p_89.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_100(float  p_101, uint32_t  p_102, int8_t  p_103, union U0  p_104)
{ /* block id: 75 */
    union U0 l_169 = {0x1A61B918L};
    int32_t l_171 = (-5L);
    int32_t *l_170 = &l_171;
    uint64_t l_181 = 0x96D85D5641618F1ELL;
    l_170 = (l_169 , l_170);
    p_101 = (safe_div_func_float_f_f((0x7.442E1Ep-72 == (*l_170)), ((*l_170) <= (p_104 , (((*l_170) == ((safe_sub_func_float_f_f((*l_170), ((safe_add_func_float_f_f((!(safe_sub_func_float_f_f((((((p_103 ^ (l_181 < (safe_div_func_uint16_t_u_u(p_104.f1, 0x2489L)))) , 0x8D7B099B75BE8B72LL) || (*l_170)) , p_104.f0) < (-0x3.3p-1)), p_102))), p_104.f1)) >= 0x5.3B753Bp+58))) > (*l_170))) != (*l_170))))));
    return p_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_115(int32_t  p_116)
{ /* block id: 55 */
    int32_t l_123 = 1L;
    int32_t *l_122 = &l_123;
    int32_t **l_121 = &l_122;
    union U0 l_136 = {4294967295UL};
    union U0 *l_135 = &l_136;
    union U0 **l_134 = &l_135;
    union U0 l_139 = {0xBDE2A9FCL};
    union U0 l_140 = {0x740E2D3EL};
    const uint32_t l_161 = 0x324CD905L;
    (*l_134) = func_117(l_121, (*l_122), p_116);
    /* statement id: 59 */
    assert (l_135 == 0);
    (**l_121) = ((*l_122) | ((safe_sub_func_uint8_t_u_u(func_86((func_86(l_139, (p_116 == ((*l_122) >= (p_116 && ((**l_121) , (*l_122))))), (p_116 , ((l_122 != l_122) , l_136)), (*l_121), p_116) , l_139), (*l_122), l_140, (*l_121), p_116), (*l_122))) == 0x4A45BEF7L));
    if ((((p_116 == (safe_div_func_uint64_t_u_u(__builtin_bswap64(p_116), (safe_lshift_func_uint8_t_u_u((l_122 == (((void*)0 != l_122) , l_122)), (p_116 || (l_122 == l_122))))))) | (-1L)) >= 0UL))
    { /* block id: 61 */
        int16_t l_147 = 0x8FF6L;
        union U0 l_150 = {4294967295UL};
        const int16_t l_155 = 0x3442L;
        int32_t l_158 = 0xA1999A73L;
        const union U0 *l_160 = &l_139;
        const union U0 **l_159 = &l_160;
        for (l_139.f0 = 0; (l_139.f0 != 52); l_139.f0 = safe_add_func_uint16_t_u_u(l_139.f0, 2))
        { /* block id: 64 */
            if (p_116)
                break;
            (**l_121) = __builtin_parity(p_116);
            (*l_121) = (*l_121);
        }
        (*l_122) = (l_147 , ((safe_add_func_int16_t_s_s(((l_122 != (l_150 , (void*)0)) , p_116), p_116)) & __builtin_ffsl((((p_116 != ((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_int16_t_s_s((l_155 | (safe_sub_func_uint64_t_u_u(__builtin_bswap64((l_155 , p_116)), l_155))), 6)) != l_158), p_116)) || l_158)) , &l_135) != l_159))));
        l_159 = &l_160;
    }
    else
    { /* block id: 71 */
        (*l_122) = (-2L);
    }
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_117(int32_t ** p_118, uint8_t  p_119, int32_t  p_120)
{ /* block id: 56 */
    union U0 l_125 = {4294967286UL};
    union U0 *l_124 = &l_125;
    union U0 *l_126 = &l_125;
    union U0 *l_127 = &l_125;
    union U0 *l_128 = &l_125;
    union U0 *l_129 = &l_125;
    union U0 *l_130 = &l_125;
    union U0 *l_131 = &l_125;
    union U0 *l_132 = &l_125;
    union U0 *l_133 = (void*)0;
    (*p_118) = (*p_118);
    return l_133;
    /* statement id: 58 */
    //assert (func_117_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 98
XXX total union variables: 12

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 89
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 34, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 100

XXX times a variable address is taken: 89
XXX times a pointer is dereferenced on RHS: 83
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 212

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 136
   level: 2, occurrence: 23
   level: 3, occurrence: 3
XXX number of pointers point to pointers: 46
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30
XXX average alias set size: 1.11

XXX times a non-volatile is read: 466
XXX times a non-volatile is write: 125
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 80
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 15
   depth: 2, occurrence: 13
   depth: 3, occurrence: 10
   depth: 4, occurrence: 5
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 16
XXX percentage an existing variable is used: 84
********************* end of statistics **********************/

