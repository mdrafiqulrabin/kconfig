/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3965835567
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_34(void);
inline static const int32_t * func_35(int8_t  p_36, int32_t * p_37, int16_t  p_38, float  p_39);
inline static int32_t  func_44(int32_t * p_45, uint32_t  p_46, int8_t  p_47);
inline static uint8_t  func_51(int32_t * p_52, int64_t  p_53, int32_t  p_54);
static uint32_t  func_55(int32_t * p_56, int32_t * p_57, int32_t * p_58);
static int32_t * func_64(int32_t * p_65);
inline static int32_t * func_70(int32_t * p_71, int32_t ** p_72, const uint64_t  p_73);
static int16_t  func_85(const int32_t  p_86);
inline static int32_t * func_91(uint8_t  p_92, uint64_t  p_93, int32_t * const * p_94, int8_t  p_95, int32_t ** p_96);
inline static int32_t  func_98(int32_t * p_99, float * p_100, int32_t ** p_101, float * p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_34(void)
{ /* block id: 36 */
    int8_t l_40 = 0xA6L;
    int32_t l_42 = 0x855EEC80L;
    int32_t *l_41 = &l_42;
    int8_t l_43 = 0xFDL;
    uint32_t l_50 = 9UL;
    const int32_t *l_568 = &l_42;
    const int32_t **l_567 = &l_568;
    int32_t l_569 = 0xC9108E29L;
    (*l_567) = func_35(__builtin_bswap32(l_40), l_41, l_43, (func_44(&l_42, (*l_41), (((((safe_rshift_func_int8_t_s_s(((l_50 || (0xC3421AD7L | ((func_51(&l_42, (*l_41), (*l_41)) <= 255UL) , (*l_41)))) > 1UL), (*l_41))) > (*l_41)) || (*l_41)) , (void*)0) != &l_42)) , (*l_41)));
    return l_569;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_35(int8_t  p_36, int32_t * p_37, int16_t  p_38, float  p_39)
{ /* block id: 301 */
    const int32_t l_566 = 0x26C7B5BEL;
    const int32_t *l_565 = &l_566;
    (*p_37) = (safe_div_func_int32_t_s_s((*p_37), __builtin_clzll(p_38)));
    return p_37;
    /* statement id: 303 */
    //assert (func_35_rv == &l_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_44(int32_t * p_45, uint32_t  p_46, int8_t  p_47)
{ /* block id: 181 */
    uint16_t l_335 = 0xA413L;
    int32_t l_373 = 0x5DB4A173L;
    int32_t *l_372 = &l_373;
    int32_t **l_371 = &l_372;
    int32_t ***l_549 = &l_371;
    int32_t ****l_548 = &l_549;
    int32_t l_562 = 0xB97613D9L;
    if (l_335)
    { /* block id: 182 */
        const int32_t l_352 = 0x563AFE0EL;
        int32_t l_370 = 1L;
        int32_t *l_369 = &l_370;
        uint16_t l_396 = 65535UL;
        uint32_t l_465 = 18446744073709551611UL;
        int32_t ** const **l_472 = (void*)0;
        float l_483 = 0xB.59C0E3p+82;
        float *l_482 = &l_483;
        float **l_481 = &l_482;
        float ***l_480 = &l_481;
        for (l_335 = 0; (l_335 == 6); l_335 = safe_add_func_int16_t_s_s(l_335, 1))
        { /* block id: 185 */
            uint32_t l_348 = 18446744073709551615UL;
            int32_t l_350 = 0x6E49E5E3L;
            int32_t *l_349 = &l_350;
            for (p_47 = (-12); (p_47 != (-14)); --p_47)
            { /* block id: 188 */
                const int32_t l_351 = (-10L);
                for (p_46 = 0; (p_46 < 13); p_46 = safe_add_func_uint8_t_u_u(p_46, 1))
                { /* block id: 191 */
                    int32_t l_345 = 0x0132F4C1L;
                    int32_t *l_344 = &l_345;
                    float *l_353 = (void*)0;
                    float l_355 = 0x9.963F9Ep+38;
                    float *l_354 = &l_355;
                    (*l_354) = ((func_85(((safe_mod_func_uint8_t_u_u(((void*)0 == l_344), ((((safe_div_func_uint32_t_u_u((l_348 , __builtin_ctzll(l_335)), ((((l_335 >= p_46) ^ p_47) , (l_349 == &l_350)) , p_47))) , (*l_344)) , l_351) , p_46))) && p_47)) == 1UL) , l_352);
                    if ((p_47 , (*p_45)))
                    { /* block id: 193 */
                        int32_t *l_360 = (void*)0;
                        int32_t l_374 = 1L;
                        (*l_371) = func_91(((((safe_div_func_uint64_t_u_u(((*l_344) & (l_360 != p_45)), l_335)) == func_85(__builtin_clz(((safe_sub_func_int32_t_s_s(l_351, 0UL)) >= (safe_rshift_func_int16_t_s_u((0x6DL <= l_351), (safe_add_func_uint8_t_u_u((((safe_add_func_int8_t_s_s(func_55(&l_345, p_45, l_369), p_46)) > p_46) == p_47), 1UL)))))))) | 0x9552L) < l_335), p_46, &l_344, l_335, l_371);
                        (*l_349) = l_374;
                        if ((*p_45))
                            break;
                    }
                    else
                    { /* block id: 197 */
                        int16_t l_375 = 0x2E9DL;
                        if (l_375)
                            break;
                    }
                }
                (*l_371) = func_64(&l_370);
                /* statement id: 201 */
                assert (l_372 == &l_370);
            }
        }
        /* facts after for loop */
        assert (l_372 == &l_370 || l_372 == &l_373);
        if ((safe_unary_minus_func_int64_t_s((safe_lshift_func_int8_t_s_s((safe_rshift_func_int8_t_s_u((safe_sub_func_uint8_t_u_u((*l_369), ((((**l_371) , (**l_371)) == (p_47 == 0x670C1B3324741356LL)) ^ (safe_add_func_uint32_t_u_u((**l_371), p_46))))), 4)), (!(safe_sub_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(7UL, ((*l_372) & (*l_369)))) , (*l_369)), 9UL))))))))
        { /* block id: 204 */
            uint32_t l_390 = 1UL;
            int32_t *l_391 = &l_370;
            const uint8_t l_397 = 1UL;
            int32_t ***l_442 = (void*)0;
            int16_t l_451 = 0x16E8L;
            int32_t ****l_474 = &l_442;
            int32_t *****l_473 = &l_474;
            if ((l_390 == func_51(func_70(l_391, &l_369, ((safe_sub_func_uint64_t_u_u(((**l_371) | (safe_rshift_func_int8_t_s_s((l_369 == p_45), (l_396 , ((*l_391) || ((((**l_371) , 65535UL) | p_46) == (*l_369))))))), l_397)) && (*l_391))), (*l_369), p_46)))
            { /* block id: 205 */
                uint8_t l_407 = 246UL;
                (*l_371) = func_64((((safe_mod_func_int8_t_s_s(func_55(p_45, (((((-1L) | ((((*l_391) & (((+p_46) < p_47) , ((p_46 , (((*l_391) ^ (*l_391)) ^ (safe_add_func_uint32_t_u_u((safe_sub_func_int32_t_s_s((safe_add_func_uint8_t_u_u(l_407, (*l_391))), (*p_45))), l_407)))) >= p_47))) < (*p_45)) , (**l_371))) | p_46) <= p_46) , (*l_371)), l_391), (*l_372))) || p_46) , (*l_371)));
            }
            else
            { /* block id: 207 */
                int32_t **l_421 = &l_369;
                if ((safe_lshift_func_int16_t_s_u(((safe_mod_func_uint64_t_u_u((safe_add_func_int32_t_s_s((+p_46), (safe_mod_func_uint16_t_u_u(((((safe_add_func_float_f_f(p_47, (0x7.1E8A7Dp-25 < (safe_sub_func_float_f_f((**l_371), p_47))))) >= 0x1.Dp+1) , l_421) == &l_391), (**l_371))))), (-5L))) && (*l_369)), 0)))
                { /* block id: 208 */
                    float l_426 = 0xB.099C41p+70;
                    float *l_425 = &l_426;
                    (*l_421) = p_45;
                    /* statement id: 209 */
                    //assert (l_369 == &l_42);
                    for (l_370 = 5; (l_370 > 23); l_370 = safe_add_func_int8_t_s_s(l_370, 6))
                    { /* block id: 212 */
                        uint32_t l_424 = 0xEF68A5E5L;
                        return l_424;
                    }
                    (*l_425) = 0x8.BED556p+51;
                }
                else
                { /* block id: 216 */
                    uint8_t l_429 = 0x97L;
                    for (l_373 = (-2); (l_373 != 25); l_373 = safe_add_func_uint64_t_u_u(l_373, 3))
                    { /* block id: 219 */
                        return l_429;
                    }
                }
                /* facts after branching */
                //assert (l_369 == &l_370 || l_369 == &l_42);
                if ((*p_45))
                { /* block id: 223 */
                    int32_t *l_430 = (void*)0;
                    l_430 = l_430;
                    if ((func_55(&l_370, func_70(func_70((*l_371), &l_430, ((safe_lshift_func_int8_t_s_s((((*l_369) , (safe_add_func_uint8_t_u_u((__builtin_popcountll((**l_371)) <= p_46), (func_98(p_45, p_45, &l_430, p_45) > p_47)))) != (*p_45)), (*l_372))) == 0x7362L)), &l_391, (**l_421)), (*l_421)) || p_47))
                    { /* block id: 225 */
                        float l_438 = 0x4.9ECA08p+96;
                        float *l_437 = &l_438;
                        int32_t l_441 = 0L;
                        (*l_372) = (safe_add_func_int8_t_s_s((l_437 != ((*l_372) , l_391)), (__builtin_ffsl(l_441) | ((void*)0 == l_442))));
                    }
                    else
                    { /* block id: 227 */
                        float l_446 = 0x1.Fp-1;
                        float *l_445 = &l_446;
                        float **l_444 = &l_445;
                        float ***l_443 = &l_444;
                        (*l_371) = func_91(p_46, p_47, &l_430, p_46, &p_45);
                        /* statement id: 228 */
                        //assert (l_372 == &l_42);
                        (*l_443) = (void*)0;
                        /* statement id: 229 */
                        assert (l_444 == 0);
                        return p_46;
                    }
                    p_45 = ((safe_rshift_func_uint16_t_u_u(p_46, (p_46 & (p_47 , p_46)))) , func_70(p_45, &p_45, (safe_mod_func_uint8_t_u_u((((*l_372) & (p_47 , (**l_371))) , l_451), (*l_391)))));
                }
                else
                { /* block id: 233 */
                    const float l_459 = 0xE.3B4DF4p-94;
                    const float *l_458 = &l_459;
                    const float * const *l_457 = &l_458;
                    int32_t l_464 = 2L;
                    for (l_451 = (-17); (l_451 >= (-18)); l_451 = safe_sub_func_uint32_t_u_u(l_451, 3))
                    { /* block id: 236 */
                        (*l_371) = p_45;
                        /* statement id: 237 */
                        //assert (l_372 == &l_42);
                        if ((*p_45))
                            break;
                        return p_47;
                    }
                    /* facts after for loop */
                    //assert (l_372 == &l_42 || l_372 == &l_370 || l_372 == &l_373);
                    l_465 = (safe_add_func_int64_t_s_s(((0xDA2CL && (safe_unary_minus_func_uint64_t_u(((((((**l_371) == ((0x716EL > (((void*)0 != l_457) , ((*l_391) , ((safe_div_func_int64_t_s_s(p_46, 0x2267C3B2963E0600LL)) > (safe_sub_func_uint8_t_u_u(func_51((*l_371), p_46, p_46), p_47)))))) && (*p_45))) > (**l_371)) ^ 0x0453L) & 1L) != (**l_421))))) , 0xEE8977E2624B2BAFLL), l_464));
                    for (l_370 = (-24); (l_370 > 22); l_370++)
                    { /* block id: 244 */
                        int32_t *l_468 = &l_464;
                        float l_471 = 0xA.269E7Fp+33;
                        float *l_470 = &l_471;
                        (*l_371) = p_45;
                        /* statement id: 245 */
                        //assert (l_372 == &l_42);
                        (*l_371) = l_468;
                        /* statement id: 246 */
                        assert (l_372 == &l_464);
                        (*l_470) = (!(-0x1.0p+1));
                        (*l_421) = p_45;
                        /* statement id: 248 */
                        //assert (l_369 == &l_42);
                    }
                    /* facts after for loop */
                    //assert (l_372 == &l_464 || l_372 == &l_42 || l_372 == &l_370 || l_372 == &l_373);
                    (*l_371) = p_45;
                    /* statement id: 250 */
                    //assert (l_372 == &l_42);
                }
                /* facts after branching */
                //assert (l_372 == &l_42 || l_372 == &l_370 || l_372 == &l_373);
                (*l_371) = (*l_371);
            }
            /* facts after branching */
            //assert (l_369 == &l_370 || l_369 == &l_42);
            //assert (l_372 == &l_42 || l_372 == &l_370 || l_372 == &l_373);
            (*l_473) = l_472;
            /* statement id: 254 */
            assert (l_474 == 0);
        }
        else
        { /* block id: 255 */
            const int32_t l_475 = 0x04EFEECCL;
            float ***l_484 = &l_481;
            uint8_t l_485 = 1UL;
            (*l_371) = func_70(p_45, &p_45, l_475);
            /* statement id: 256 */
            //assert (l_372 == &l_42);
            if (((safe_sub_func_int8_t_s_s((p_46 , (l_480 == (((void*)0 != l_484) , l_484))), (l_485 , l_485))) != ((safe_add_func_uint16_t_u_u(l_475, p_46)) == l_485)))
            { /* block id: 257 */
                (*l_482) = p_47;
            }
            else
            { /* block id: 259 */
                const int32_t *l_490 = &l_475;
                const int32_t **l_489 = &l_490;
                const int32_t ***l_488 = &l_489;
                (*l_488) = &p_45;
                /* statement id: 260 */
                assert (l_489 == &p_45);
                for (p_46 = (-14); (p_46 <= 46); p_46++)
                { /* block id: 263 */
                    return (***l_488);
                }
            }
            (**l_481) = (((void*)0 == &p_45) < p_46);
        }
        /* facts after branching */
        //assert (l_369 == &l_370 || l_369 == &l_42);
        //assert (l_372 == &l_42 || l_372 == &l_370 || l_372 == &l_373);
        (*l_371) = ((*l_372) , p_45);
        /* statement id: 269 */
        //assert (l_372 == &l_42);
        for (l_373 = (-19); (l_373 != (-19)); l_373 = safe_add_func_uint32_t_u_u(l_373, 9))
        { /* block id: 272 */
            return p_46;
        }
    }
    else
    { /* block id: 275 */
        int32_t l_500 = 0xC374DF2FL;
        float *l_524 = (void*)0;
        float **l_523 = &l_524;
        int32_t l_544 = 0xD417F42BL;
        if (((*p_45) & (safe_rshift_func_int16_t_s_u((safe_unary_minus_func_uint32_t_u(p_46)), p_46))))
        { /* block id: 276 */
            (**l_371) = (__builtin_popcountl((safe_rshift_func_uint8_t_u_u(0x58L, (__builtin_clz(l_500) < l_500)))) && l_500);
            (*l_371) = (void*)0;
            /* statement id: 278 */
            assert (l_372 == 0);
            (*l_371) = (void*)0;
        }
        else
        { /* block id: 280 */
            float l_522 = 0x2.654926p+49;
            float *l_521 = &l_522;
            float **l_520 = &l_521;
            int32_t l_525 = 1L;
            for (p_47 = 23; (p_47 > 22); p_47 = safe_sub_func_int8_t_s_s(p_47, 1))
            { /* block id: 283 */
                uint32_t l_545 = 4294967290UL;
                int32_t l_556 = (-4L);
                int32_t *l_559 = (void*)0;
                for (l_500 = 17; (l_500 < (-23)); --l_500)
                { /* block id: 286 */
                    float l_506 = 0x3.7B36C4p-61;
                    float *l_505 = &l_506;
                    (*l_505) = 0x3.791587p-17;
                }
                if ((*p_45))
                { /* block id: 289 */
                    float l_511 = 0x7.03FAEAp+25;
                    const int32_t l_512 = (-2L);
                    (**l_520) = ((safe_rshift_func_int16_t_s_u(((((safe_sub_func_int8_t_s_s((l_512 , p_47), (safe_lshift_func_uint8_t_u_s((**l_371), (safe_add_func_uint16_t_u_u(0x26FDL, p_46)))))) && (safe_add_func_int64_t_s_s((!(l_500 && (((l_520 != l_523) && l_525) , p_47))), 0x790BB88B1FAFBDBALL))) , (*l_371)) != (*l_371)), l_500)) , p_47);
                    (**l_520) = (p_46 <= (safe_sub_func_float_f_f((safe_sub_func_float_f_f((((safe_mod_func_int64_t_s_s((((((safe_div_func_uint8_t_u_u((safe_sub_func_int8_t_s_s((safe_add_func_uint64_t_u_u(l_525, (18446744073709551615UL > ((safe_add_func_uint16_t_u_u(((1L > (l_525 || (safe_add_func_int64_t_s_s(((safe_div_func_int16_t_s_s((p_47 && ((__builtin_parityl(((((*p_45) >= (p_47 , l_525)) == p_47) & 4UL)) & (-1L)) && l_512)), p_46)) || 18446744073709551615UL), l_544)))) & 4294967289UL), l_545)) | p_47)))), p_47)), 0x0FL)) , 0x3.A6CB83p+21) , l_545) , p_46) , 0x98F86669DA2C240BLL), 0xF84215D6DC5235D5LL)) || 4294967295UL) , l_525), l_544)), 0x8.68554Cp-25)));
                    l_556 = ((safe_add_func_float_f_f(func_51(p_45, ((void*)0 == l_548), ((l_525 , l_545) , 6L)), (safe_sub_func_float_f_f(0x0.A2B4C9p-11, (safe_add_func_float_f_f((safe_sub_func_float_f_f(p_47, 0x5.6820D9p-56)), l_512)))))) < p_47);
                }
                else
                { /* block id: 293 */
                    float **l_560 = &l_524;
                    int32_t *l_561 = (void*)0;
                    (*p_45) = (safe_sub_func_int32_t_s_s(((p_46 , 6L) < p_47), l_562));
                }
            }
        }
        /* facts after branching */
        assert (l_372 == &l_373 || l_372 == 0);
        return l_500;
    }
    /* facts after branching */
    //assert (l_372 == &l_42);
    return (***l_549);
}


/* ------------------------------------------ */
/* 
 * reads : l_42
 * writes:
 */
inline static uint8_t  func_51(int32_t * p_52, int64_t  p_53, int32_t  p_54)
{ /* block id: 37 */
    int64_t l_61 = 1L;
    int16_t l_62 = 0xC650L;
    int32_t *l_63 = (void*)0;
    float l_75 = 0x7.D602FFp-76;
    float *l_74 = &l_75;
    uint32_t l_82 = 0x5AC95004L;
    int16_t l_97 = 0xEC62L;
    uint16_t l_105 = 65533UL;
    (*l_74) = (func_55(((safe_lshift_func_int8_t_s_u(l_61, (l_62 && 0x4309L))) , p_52), l_63, p_52) , (func_55(func_70(p_52, &l_63, p_53), l_63, p_52) , p_53));
    (*l_74) = p_54;
    for (p_54 = 10; (p_54 != 10); p_54 = safe_add_func_int32_t_s_s(p_54, 5))
    { /* block id: 49 */
        int32_t l_84 = (-9L);
        int32_t * const l_83 = &l_84;
        int32_t **l_87 = &l_63;
        uint8_t l_90 = 0x26L;
        float l_106 = 0xF.83B7C1p+1;
        (*l_87) = func_70(((((safe_add_func_int64_t_s_s(l_82, (p_54 , ((void*)0 != l_83)))) & (__builtin_bswap64((*l_83)) < p_54)) <= (func_85((*l_83)) | p_53)) , l_74), &l_63, p_54);
        (*l_74) = (safe_div_func_float_f_f((l_83 != l_83), (l_90 >= p_53)));
        l_63 = func_64(func_91(((((l_97 , p_54) , func_98(p_52, func_64(((((safe_add_func_int8_t_s_s(((((p_52 == l_63) , l_83) != p_52) & (l_105 || ((p_54 || p_53) , p_53))), p_53)) >= p_53) , l_105) , (void*)0)), &l_63, p_52)) == p_54) ^ 0x539E2D7B22F36016LL), p_54, &l_83, p_53, &l_63));
        l_63 = (*l_87);
    }
    (*l_74) = (p_53 > ((safe_div_func_float_f_f(func_85(p_54), func_55(l_63, (p_53 , func_91((p_53 >= 0UL), ((safe_lshift_func_int16_t_s_s((~l_82), 14)) <= (safe_div_func_int64_t_s_s((((safe_lshift_func_int8_t_s_u(0L, p_54)) ^ p_54) && 0x78C0FFAA04E7043ELL), 0x6BA76929111879B9LL))), &l_63, p_54, &l_63)), l_63))) > p_54));
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_55(int32_t * p_56, int32_t * p_57, int32_t * p_58)
{ /* block id: 38 */
    int32_t l_67 = (-9L);
    int32_t *l_66 = &l_67;
    int32_t **l_68 = &l_66;
    int32_t l_69 = 0x6BAC609EL;
    (*l_68) = func_64(l_66);
    return l_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_64(int32_t * p_65)
{ /* block id: 39 */
    return p_65;
    /* statement id: 40 */
    //assert (func_64_rv == &l_67 || func_64_rv == 0 || func_64_rv == &l_136 || func_64_rv == &l_370 || func_64_rv == &l_373);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_70(int32_t * p_71, int32_t ** p_72, const uint64_t  p_73)
{ /* block id: 43 */
    return (*p_72);
    /* statement id: 44 */
    //assert (func_70_rv == 0 || func_70_rv == &l_107 || func_70_rv == &l_370 || func_70_rv == &l_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_85(const int32_t  p_86)
{ /* block id: 50 */
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_91(uint8_t  p_92, uint64_t  p_93, int32_t * const * p_94, int8_t  p_95, int32_t ** p_96)
{ /* block id: 162 */
    int32_t l_319 = 1L;
    int32_t * const l_318 = &l_319;
    for (p_93 = 0; (p_93 <= 49); p_93 = safe_add_func_uint16_t_u_u(p_93, 1))
    { /* block id: 165 */
        const int32_t *l_322 = &l_319;
        int32_t *l_325 = &l_319;
        int32_t **l_324 = &l_325;
        for (p_92 = (-25); (p_92 <= 52); p_92 = safe_add_func_uint32_t_u_u(p_92, 6))
        { /* block id: 168 */
            int32_t *l_321 = &l_319;
            int32_t **l_320 = &l_321;
            int32_t **l_323 = &l_321;
            (*l_320) = l_318;
            (*l_320) = &l_319;
            (*l_323) = l_322;
        }
        (*l_324) = (*p_94);
        /* statement id: 173 */
        //assert (l_325 == &l_84 || l_325 == 0 || l_325 == &l_345);
    }
    return (*p_96);
    /* statement id: 175 */
    //assert (func_91_rv == 0 || func_91_rv == &l_373 || func_91_rv == &l_370 || func_91_rv == &l_42);
}


/* ------------------------------------------ */
/* 
 * reads : l_42 l_370 l_373
 * writes:
 */
inline static int32_t  func_98(int32_t * p_99, float * p_100, int32_t ** p_101, float * p_102)
{ /* block id: 54 */
    int32_t l_107 = 0L;
    int32_t *l_151 = (void*)0;
    int16_t l_235 = 0xCDE7L;
    uint64_t l_243 = 18446744073709551615UL;
    int32_t **l_247 = &l_151;
    int32_t ***l_246 = &l_247;
    int32_t l_248 = 0L;
    int32_t *l_258 = &l_107;
    uint8_t l_288 = 0UL;
    int32_t l_311 = (-1L);
    for (l_107 = 0; (l_107 < 19); l_107 = safe_add_func_uint8_t_u_u(l_107, 5))
    { /* block id: 57 */
        const int8_t l_112 = 0xF7L;
        int32_t l_133 = 0L;
        uint32_t l_168 = 0xB013A584L;
        int32_t **l_176 = (void*)0;
        int32_t *l_187 = &l_107;
        const int16_t l_188 = 0xBEC8L;
        int32_t l_230 = 0x7C675B0FL;
        uint32_t l_249 = 8UL;
        int32_t * const *l_275 = &l_151;
        int8_t l_276 = 0x43L;
        int32_t l_280 = 0x19326E76L;
        int32_t *l_279 = &l_280;
    }
    if (((safe_sub_func_int16_t_s_s(((*l_258) , (*l_258)), (safe_mod_func_uint32_t_u_u((((*l_246) != (*l_246)) >= ((safe_div_func_uint32_t_u_u(0xDD56EC37L, func_55(func_64((**l_246)), (*p_101), func_64((*p_101))))) >= (-1L))), 0xEE12775CL)))) < (*l_258)))
    { /* block id: 149 */
        int16_t l_289 = (-1L);
        l_289 = ((*l_258) , (-l_288));
    }
    else
    { /* block id: 151 */
        float l_292 = 0xC.179F8Ap+20;
        int32_t l_293 = 0x9C2108D3L;
        float *l_294 = &l_292;
        (*l_294) = ((*p_102) == ((*l_258) == ((safe_sub_func_float_f_f((l_292 > (0x0.9B30FAp-94 > l_293)), ((void*)0 != p_102))) < l_293)));
    }
    for (l_243 = 24; (l_243 >= 58); l_243++)
    { /* block id: 156 */
        uint8_t l_298 = 0xD1L;
        int32_t l_299 = 0x54D56DC5L;
        int32_t ***l_310 = &l_247;
        float l_313 = 0x1.88BA21p+19;
        float *l_312 = &l_313;
        (*l_247) = func_64((*p_101));
        l_299 = (+((func_85((l_298 , (-4L))) && 255UL) & l_298));
        (*l_312) = ((((safe_mod_func_int16_t_s_s(l_299, ((*l_258) , (safe_rshift_func_uint8_t_u_s((*l_258), 7))))) != 0xCFL) >= l_299) , (safe_add_func_float_f_f(l_298, (safe_add_func_float_f_f(((safe_div_func_float_f_f(((((l_298 , (*p_99)) >= (l_299 ^ 0xFE3D08FB6B238936LL)) , l_310) == (void*)0), l_299)) < l_311), (*p_102))))));
    }
    return (*p_99);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 131
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 22
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 113

XXX times a variable address is taken: 124
XXX times a pointer is dereferenced on RHS: 172
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 21
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 72
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 6
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 470

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 475
   level: 2, occurrence: 78
   level: 3, occurrence: 31
XXX number of pointers point to pointers: 40
XXX number of pointers point to scalars: 73
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.5
XXX average alias set size: 1.5

XXX times a non-volatile is read: 785
XXX times a non-volatile is write: 191
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 17
   depth: 2, occurrence: 14
   depth: 3, occurrence: 11
   depth: 4, occurrence: 19
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 17.1
XXX percentage an existing variable is used: 82.9
********************* end of statistics **********************/

