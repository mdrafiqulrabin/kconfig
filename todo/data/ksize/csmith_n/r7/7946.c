/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3157918797
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   const int32_t  f1;
   int32_t  f2;
};

union U1 {
   const uint32_t  f0;
   uint64_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_34(void);
inline static int32_t * func_35(int32_t * p_36, uint64_t  p_37, int32_t * p_38, uint64_t  p_39, float  p_40);
inline static int32_t * func_41(int32_t * p_42, int32_t * p_43);
static int32_t * func_46(int16_t  p_47, uint32_t  p_48, int32_t * p_49);
static uint32_t  func_50(uint64_t  p_51, int64_t  p_52, int32_t * p_53, float  p_54, int32_t * p_55);
static int16_t  func_60(union U1  p_61, int8_t  p_62, int32_t * p_63, int16_t  p_64);
static int8_t  func_67(int32_t * p_68, union U1  p_69);
inline static int32_t * func_70(const uint32_t  p_71);
inline static union U1 * func_91(uint32_t  p_92, const union U1  p_93, uint32_t  p_94);
static union U1 ** func_101(int16_t  p_102, int64_t  p_103, int16_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_34(void)
{ /* block id: 36 */
    int32_t l_45 = (-1L);
    int32_t *l_44 = &l_45;
    union U1 l_65 = {8UL};
    int64_t l_285 = 0x74D665B7CE1603C5LL;
    float l_619 = 0x5.5B4A8Dp+87;
    uint64_t l_620 = 0xEE5E2D77209384B6LL;
    int32_t **l_771 = (void*)0;
    int32_t **l_772 = &l_44;
    union U0 l_773 = {0x9D8DC52EL};
    (*l_772) = func_35(func_41(l_44, func_46((*l_44), func_50((0UL & 0L), (safe_mod_func_uint64_t_u_u((__builtin_clz((*l_44)) <= (safe_add_func_int16_t_s_s(func_60(l_65, (+(func_67(func_70(((safe_lshift_func_int8_t_s_s((safe_add_func_int8_t_s_s((*l_44), (((void*)0 == &l_45) >= (*l_44)))), 0)) > 0L)), l_65) != (*l_44))), &l_45, (*l_44)), l_285))), (*l_44))), &l_45, (*l_44), &l_45), &l_45)), l_285, l_44, l_285, l_620);
    /* statement id: 424 */
    assert (l_44 == 0 || l_44 == &l_45);
    return l_773;
    /* statement id: 425 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_35(int32_t * p_36, uint64_t  p_37, int32_t * p_38, uint64_t  p_39, float  p_40)
{ /* block id: 332 */
    int32_t * const l_623 = (void*)0;
    union U1 l_644 = {0xB0DDA238L};
    union U1 *l_643 = &l_644;
    union U1 * const *l_642 = &l_643;
    union U1 * const **l_641 = &l_642;
    int32_t *l_693 = (void*)0;
    int32_t **l_717 = (void*)0;
    int32_t ***l_716 = &l_717;
    union U1 *****l_768 = (void*)0;
    float l_770 = 0x1.2p-1;
    float *l_769 = &l_770;
lbl_744:
    (*p_36) = (*p_38);
    if ((*p_38))
    { /* block id: 334 */
        return p_38;
        /* statement id: 335 */
        //assert (func_35_rv == &l_45);
    }
    else
    { /* block id: 336 */
        int32_t *l_625 = (void*)0;
        int32_t l_633 = 0x764C1D55L;
        union U1 l_640 = {0xCA2A10F9L};
        union U1 *l_639 = &l_640;
        union U1 **l_638 = &l_639;
        union U1 ***l_637 = &l_638;
        float l_646 = (-0x1.9p-1);
        float *l_645 = &l_646;
        for (p_39 = 0; (p_39 > 11); p_39 = safe_add_func_int32_t_s_s(p_39, 6))
        { /* block id: 339 */
            int32_t **l_624 = (void*)0;
            float l_635 = 0x5.8389AFp-36;
            float *l_634 = &l_635;
            int32_t *l_636 = &l_633;
            l_625 = l_623;
            (*l_634) = ((!((safe_add_func_float_f_f(p_39, (p_40 < (safe_sub_func_float_f_f(((safe_add_func_float_f_f(l_633, p_39)) <= (__builtin_clz(func_50(p_37, p_37, &l_633, p_40, p_38)) >= p_37)), p_37))))) < 0x0.Ep-1)) <= 0x1.0p+1);
            l_636 = (void*)0;
            /* statement id: 342 */
            assert (l_636 == 0);
        }
        (*l_645) = (l_637 == l_641);
        (*l_645) = (((void*)0 == &l_642) > p_39);
    }
    if ((safe_lshift_func_uint8_t_u_s(((p_37 && 0x10358382L) | p_39), 2)))
    { /* block id: 347 */
        union U0 l_655 = {0x2FF83F7DL};
        union U0 *l_654 = &l_655;
        int32_t *l_667 = &l_655.f2;
        union U1 **l_697 = &l_643;
        union U1 ***l_696 = &l_697;
        union U1 ****l_695 = &l_696;
        union U1 l_725 = {0xC2E0E4AEL};
        int32_t l_726 = 1L;
        for (l_644.f1 = 24; (l_644.f1 >= 28); l_644.f1 = safe_add_func_uint32_t_u_u(l_644.f1, 8))
        { /* block id: 350 */
            int32_t l_651 = 1L;
            union U1 l_668 = {1UL};
            union U1 **l_681 = &l_643;
            int32_t **l_715 = &l_667;
            int32_t ***l_714 = &l_715;
            const float ***l_721 = (void*)0;
            const float ****l_720 = &l_721;
            int32_t l_727 = 0xFA625486L;
            union U1 ****l_752 = &l_696;
            if (l_651)
            { /* block id: 351 */
                for (l_651 = 0; (l_651 < 20); ++l_651)
                { /* block id: 354 */
                    union U0 l_657 = {5L};
                    union U0 *l_656 = &l_657;
                    int32_t *l_658 = (void*)0;
                    l_656 = l_654;
                    /* statement id: 355 */
                    assert (l_656 == &l_655);
                    return l_658;
                    /* statement id: 356 */
                    //assert (func_35_rv == 0);
                }
            }
            else
            { /* block id: 358 */
                int32_t *l_660 = &l_651;
                int32_t **l_659 = &l_660;
                union U1 **l_674 = &l_643;
                union U1 ***l_673 = &l_674;
                int32_t l_692 = 0x91BA20A1L;
                int32_t *l_698 = &l_655.f2;
                (*l_659) = (void*)0;
                /* statement id: 359 */
                assert (l_660 == 0);
                for (l_655.f0 = 10; (l_655.f0 > 25); l_655.f0 = safe_add_func_int8_t_s_s(l_655.f0, 1))
                { /* block id: 362 */
                    int32_t *l_665 = (void*)0;
                    int32_t ***l_670 = (void*)0;
                    int32_t ****l_669 = &l_670;
                    union U1 **l_672 = &l_643;
                    union U1 ***l_671 = &l_672;
                    for (p_37 = 22; (p_37 > 25); p_37 = safe_add_func_int32_t_s_s(p_37, 1))
                    { /* block id: 365 */
                        int32_t *l_666 = &l_651;
                        l_666 = l_665;
                        /* statement id: 366 */
                        assert (l_666 == 0);
                        (*l_659) = l_667;
                        /* statement id: 367 */
                        assert (l_660 == &l_655.f2);
                        p_40 = (-0x4.Bp+1);
                    }
                    (*p_36) = func_60(l_668, p_39, &l_651, ((void*)0 != l_669));
                    if ((*l_667))
                        continue;
                    if ((l_671 != l_673))
                    { /* block id: 372 */
                        int32_t *l_694 = &l_655.f2;
                        float *l_699 = (void*)0;
                        float l_701 = 0xA.E5594Ap+44;
                        float *l_700 = &l_701;
                        (*p_38) = (p_39 & (safe_mod_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(((l_681 != (void*)0) && 0xE761F9B6BC484CA7LL), 3)), (1UL & (safe_add_func_int64_t_s_s(1L, p_37))))), ((safe_div_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(l_668.f0, (safe_rshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_u((l_692 <= l_651), 4)), 7)))), p_37)) ^ p_37))));
                        (*l_659) = func_41(l_693, l_694);
                        /* statement id: 374 */
                        assert (l_660 == 0);
                        (*l_659) = p_38;
                        /* statement id: 375 */
                        //assert (l_660 == &l_45);
                        (*l_700) = p_40;
                    }
                    else
                    { /* block id: 377 */
                        float *l_702 = (void*)0;
                        p_40 = (*l_667);
                        (*l_659) = (*l_659);
                        if ((*p_36))
                            break;
                    }
                }
                /* facts after for loop */
                //assert (l_660 == &l_655.f2 || l_660 == 0 || l_660 == &l_45);
            }
            if ((l_668.f0 ^ (l_668.f0 > (((l_651 == p_37) < (safe_rshift_func_int8_t_s_s((safe_mul_func_int16_t_s_s(p_37, p_37)), 0))) == ((safe_sub_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s((1L != 0x83F40E07BC25F3D8LL), 2)), (~(safe_add_func_uint64_t_u_u((l_714 == l_716), p_39))))) ^ p_39)))))
            { /* block id: 384 */
                int32_t *l_724 = &l_655.f2;
                float l_729 = 0x0.Dp-1;
                float *l_728 = &l_729;
                (*l_728) = ((((((((safe_mul_func_float_f_f(((void*)0 != l_720), (0x4.ADD73Ap+3 == (0x0.9E1469p+34 >= (safe_div_func_float_f_f(0xF.5A3A27p+8, p_39)))))) < func_67(l_724, l_725)) <= (*l_667)) != l_726) == (*l_724)) > 0x7.Ap+1) > l_727) < (***l_714));
            }
            else
            { /* block id: 386 */
                union U1 ** const *l_751 = &l_681;
                union U1 ** const **l_750 = &l_751;
                union U1 ** const ***l_749 = &l_750;
                int32_t l_753 = 0xE9AA3EAAL;
                for (p_37 = 0; (p_37 > 31); p_37 = safe_add_func_int16_t_s_s(p_37, 7))
                { /* block id: 389 */
                    for (l_655.f2 = (-1); (l_655.f2 <= (-8)); l_655.f2 = safe_sub_func_uint16_t_u_u(l_655.f2, 4))
                    { /* block id: 392 */
                        float l_734 = 0x3.199D58p-76;
                        int32_t l_735 = 0x6262D24CL;
                        float *l_736 = &l_734;
                        (*p_36) = l_735;
                        (*l_736) = (p_37 <= p_37);
                    }
                    /* facts after for loop */
                                        for (l_668.f1 = 0; (l_668.f1 > 1); ++l_668.f1)
                    { /* block id: 398 */
                        int32_t l_741 = 0x8B865E87L;
                        p_36 = p_38;
                        (*p_38) = (safe_mul_func_uint16_t_u_u(0xD78EL, 0L));
                        (*l_667) = __builtin_clz(l_741);
                    }
                    /* facts after for loop */
                                    }
                for (l_726 = 0; (l_726 >= (-1)); --l_726)
                { /* block id: 406 */
                    if (l_725.f0)
                        goto lbl_744;
                }
                for (p_39 = 17; (p_39 >= 46); p_39 = safe_add_func_uint16_t_u_u(p_39, 1))
                { /* block id: 411 */
                    int32_t *l_747 = &l_655.f0;
                    float l_755 = 0x9.0p+1;
                    float *l_754 = &l_755;
                    int64_t l_756 = 0L;
                    l_747 = p_38;
                    /* statement id: 412 */
                    //assert (l_747 == &l_45);
                    (*l_754) = (-((__builtin_parity(__builtin_popcountl((0xCABC32EE872010BALL || ((l_749 != &l_750) > 18446744073709551611UL)))) == ((**l_715) < ((((*l_747) != (l_752 != (void*)0)) != l_753) != (-0x7.Bp+1)))) <= p_40));
                    (***l_714) = l_756;
                    /* statement id: 414 */
                                    }
            }
            (*l_715) = l_667;
        }
        /* facts after for loop */
            }
    else
    { /* block id: 419 */
        const int32_t **l_757 = (void*)0;
        int32_t **l_758 = (void*)0;
        int32_t **l_759 = &l_693;
        (*l_759) = (void*)0;
    }
    (*l_769) = (safe_mul_func_float_f_f((safe_sub_func_float_f_f(((p_37 <= p_39) < (safe_sub_func_float_f_f(((safe_add_func_float_f_f(0x1.Bp-1, ((void*)0 == l_768))) > p_40), (&l_716 != &l_716)))), (func_67(func_46(p_37, p_39, p_38), (***l_641)) <= p_37))), p_37));
    return p_38;
    /* statement id: 423 */
    //assert (func_35_rv == &l_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_41(int32_t * p_42, int32_t * p_43)
{ /* block id: 318 */
    int32_t l_604 = 3L;
    int32_t *l_603 = &l_604;
    int32_t **l_605 = &l_603;
    int32_t *l_617 = &l_604;
    int32_t *l_618 = &l_604;
    (*l_605) = l_603;
    for (l_604 = 0; (l_604 != (-15)); l_604 = safe_sub_func_int16_t_s_s(l_604, 5))
    { /* block id: 322 */
        int32_t *l_608 = &l_604;
        int32_t l_609 = (-1L);
        if ((*l_603))
            break;
        (*l_605) = l_608;
        for (l_609 = 0; (l_609 > 12); l_609++)
        { /* block id: 327 */
            float *****l_614 = (void*)0;
            float l_616 = (-0x1.6p-1);
            float *l_615 = &l_616;
            (*l_615) = (safe_sub_func_float_f_f((((-0x1.7p+1) < 0xE.DA5789p+88) > ((void*)0 != l_614)), ((-0x1.4p+1) > 0xE.AEE4F8p-53)));
        }
    }
    return p_42;
    /* statement id: 331 */
    //assert (func_41_rv == &l_45 || func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_45
 * writes: l_45
 */
static int32_t * func_46(int16_t  p_47, uint32_t  p_48, int32_t * p_49)
{ /* block id: 255 */
    union U0 l_476 = {0xAEF4B928L};
    union U0 *l_475 = &l_476;
    union U0 **l_477 = &l_475;
    int32_t *l_489 = &l_476.f0;
    union U1 l_493 = {0xCB3F649DL};
    union U0 l_551 = {0xD4A45373L};
    const union U0 *l_550 = &l_551;
    int32_t **l_555 = &l_489;
    (*p_49) = (*p_49);
    (*l_477) = l_475;
    for (p_48 = 0; (p_48 == 14); ++p_48)
    { /* block id: 260 */
        int32_t *l_486 = &l_476.f2;
        int32_t **l_485 = &l_486;
        int32_t ***l_484 = &l_485;
        int32_t ****l_483 = &l_484;
        union U1 l_490 = {4294967286UL};
        (***l_484) = (safe_div_func_uint8_t_u_u(((((((safe_unary_minus_func_int16_t_s((l_483 == (void*)0))) == (((safe_mul_func_int16_t_s_s(func_67(l_489, l_490), (l_489 != (**l_484)))) >= (p_48 < ((*l_489) && (****l_483)))) && (-10L))) == (**l_485)) == (*l_489)) >= 5UL) > (*l_489)), 0xF8L));
        /* statement id: 261 */
            }
    for (l_476.f2 = 28; (l_476.f2 == 19); --l_476.f2)
    { /* block id: 265 */
        union U1 ***l_495 = (void*)0;
        union U1 ****l_494 = &l_495;
        const int32_t l_496 = (-7L);
        int16_t l_509 = 0x65FDL;
        const union U0 *l_548 = (void*)0;
        int32_t l_558 = 0xC1F91445L;
        union U1 *l_600 = &l_493;
        union U1 **l_599 = &l_600;
        union U0 ***l_602 = &l_477;
    }
    /* facts after for loop */
        return p_49;
    /* statement id: 317 */
    //assert (func_46_rv == &l_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_50(uint64_t  p_51, int64_t  p_52, int32_t * p_53, float  p_54, int32_t * p_55)
{ /* block id: 141 */
    int8_t l_288 = 0xEDL;
    union U1 l_289 = {0x25C5B712L};
    int32_t l_291 = 0xB6D299ECL;
    int32_t *l_290 = &l_291;
    uint16_t l_296 = 65535UL;
    int32_t **l_297 = &l_290;
    union U1 *l_314 = (void*)0;
    union U1 ** const l_313 = &l_314;
    union U1 ** const *l_312 = &l_313;
    union U1 ** const **l_311 = &l_312;
    int64_t l_363 = 0x68425D969002E632LL;
    float **l_409 = (void*)0;
    (*l_297) = func_70(((safe_add_func_int32_t_s_s(l_288, l_288)) ^ (func_60(l_289, p_51, l_290, (*l_290)) && (safe_rshift_func_int16_t_s_s((safe_div_func_int64_t_s_s(p_52, (l_296 | 4294967295UL))), (*l_290))))));
    /* statement id: 142 */
    assert (l_290 == 0);
    for (p_52 = 0; (p_52 >= (-12)); p_52 = safe_sub_func_uint16_t_u_u(p_52, 5))
    { /* block id: 145 */
        int16_t l_304 = 1L;
        int64_t l_315 = 0xDC9B2812D80CD150LL;
        union U1 l_323 = {0UL};
        int32_t * const l_324 = (void*)0;
        int32_t l_330 = 0x89042D63L;
        union U1 **l_346 = &l_314;
        union U1 *** const l_345 = &l_346;
        const int32_t *l_425 = &l_330;
        float l_474 = (-0x10.Cp+1);
        float *l_473 = &l_474;
    }
    (*l_297) = (void*)0;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_60(union U1  p_61, int8_t  p_62, int32_t * p_63, int16_t  p_64)
{ /* block id: 133 */
    float ****l_284 = (void*)0;
    float *****l_283 = &l_284;
    for (p_61.f1 = 29; (p_61.f1 < 22); p_61.f1 = safe_sub_func_int64_t_s_s(p_61.f1, 6))
    { /* block id: 136 */
        int32_t l_282 = (-1L);
        int32_t *l_281 = &l_282;
        int32_t **l_280 = &l_281;
        (*l_280) = p_63;
        /* statement id: 137 */
        //assert (l_281 == &l_45 || l_281 == &l_291 || l_281 == 0 || l_281 == &l_330 || l_281 == &l_322 || l_281 == &l_651);
        l_283 = (void*)0;
        /* statement id: 138 */
        assert (l_283 == 0);
    }
    /* facts after for loop */
        assert (l_283 == 0 || l_283 == &l_284);
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_67(int32_t * p_68, union U1  p_69)
{ /* block id: 39 */
    union U1 l_99 = {9UL};
    union U1 *l_98 = &l_99;
    uint64_t l_111 = 7UL;
    int16_t l_112 = 0xED9CL;
    union U1 **l_117 = &l_98;
    float l_189 = 0x0.4p+1;
    float *l_188 = &l_189;
    float **l_187 = &l_188;
    int32_t l_207 = 0xA9005331L;
    int32_t *l_206 = &l_207;
    int32_t **l_205 = &l_206;
    union U1 ***l_221 = (void*)0;
    union U1 ****l_220 = &l_221;
    union U1 *****l_219 = &l_220;
    float ***l_223 = &l_187;
    float ****l_222 = &l_223;
    for (p_69.f1 = 0; (p_69.f1 > 33); p_69.f1++)
    { /* block id: 42 */
        const int8_t l_88 = (-1L);
        int32_t l_90 = 0x1BF9D45AL;
        int32_t *l_89 = &l_90;
        uint32_t l_100 = 0UL;
        l_89 = func_70(l_88);
        /* statement id: 43 */
        assert (l_89 == 0);
        l_98 = func_91(p_69.f1, p_69, l_90);
        /* statement id: 47 */
        assert (l_98 == 0);
        return l_100;
    }
    /* facts after for loop */
        l_117 = func_101((safe_sub_func_uint32_t_u_u((((safe_add_func_int16_t_s_s((((0L & l_111) <= 1L) || (l_111 >= (p_69.f0 >= ((l_111 >= p_69.f1) == (l_111 ^ 0xD3L))))), p_69.f0)) && 0UL) && l_112), 2UL)), l_111, l_99.f0);
    /* statement id: 52 */
    assert (l_117 == 0);
    return p_69.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_70(const uint32_t  p_71)
{ /* block id: 37 */
    int32_t l_77 = 1L;
    int32_t *l_76 = &l_77;
    int32_t *l_78 = &l_77;
    int32_t *l_79 = &l_77;
    int32_t *l_80 = &l_77;
    int32_t *l_81 = &l_77;
    int32_t *l_82 = &l_77;
    int32_t *l_83 = &l_77;
    int32_t *l_84 = &l_77;
    int32_t *l_85 = (void*)0;
    return l_85;
    /* statement id: 38 */
    //assert (func_70_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_91(uint32_t  p_92, const union U1  p_93, uint32_t  p_94)
{ /* block id: 44 */
    union U1 *l_96 = (void*)0;
    union U1 **l_95 = &l_96;
    union U1 *l_97 = (void*)0;
    (*l_95) = (void*)0;
    return l_97;
    /* statement id: 46 */
    //assert (func_91_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 ** func_101(int16_t  p_102, int64_t  p_103, int16_t  p_104)
{ /* block id: 50 */
    union U1 l_115 = {0x175EF58EL};
    union U1 *l_114 = &l_115;
    union U1 **l_113 = &l_114;
    union U1 **l_116 = (void*)0;
    return l_116;
    /* statement id: 51 */
    //assert (func_101_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 196
XXX total union variables: 14

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 23
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 6, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 34, occurrence: 1

XXX total number of pointers: 213

XXX times a variable address is taken: 199
XXX times a pointer is dereferenced on RHS: 77
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 109
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 31
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 410

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 378
   level: 2, occurrence: 48
   level: 3, occurrence: 18
   level: 4, occurrence: 6
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 111
XXX number of pointers point to scalars: 82
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 31.9
XXX average alias set size: 1.24

XXX times a non-volatile is read: 734
XXX times a non-volatile is write: 290
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 84
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 7
   depth: 3, occurrence: 7
   depth: 4, occurrence: 12
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 20.4
XXX percentage an existing variable is used: 79.6
********************* end of statistics **********************/

