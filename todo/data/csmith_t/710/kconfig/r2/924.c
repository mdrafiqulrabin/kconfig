/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      551519600
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 6;
   signed f1 : 3;
   unsigned f2 : 25;
};

union U1 {
   const uint16_t  f0;
   uint32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint8_t  f4;
};

union U2 {
   int32_t  f0;
   int8_t * f1;
   const int8_t * f2;
   int32_t  f3;
   int8_t * f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_1(void);
static union U1 * func_2(const uint16_t  p_3, int16_t  p_4, uint32_t  p_5, int8_t * p_6);
static const int8_t  func_8(uint8_t  p_9, uint16_t  p_10, uint8_t  p_11);
inline static int32_t  func_15(uint32_t  p_16, union U1 * p_17, int16_t  p_18);
inline static int16_t  func_21(int8_t * p_22, int32_t  p_23, union U1 * p_24, const int8_t * p_25);
inline static int8_t * func_26(struct S0  p_27, int8_t * p_28, uint32_t  p_29, int8_t * p_30);
static int8_t * func_32(union U1 * p_33, union U1 * p_34, const int8_t * p_35, uint32_t  p_36);
inline static int32_t  func_43(int8_t * p_44);
static int8_t * func_45(uint16_t  p_46, union U2  p_47, const int8_t  p_48, uint16_t  p_49, int8_t * p_50);
inline static int32_t ** const  func_57(uint32_t  p_58, union U2  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_1(void)
{ /* block id: 0 */
    uint32_t l_12 = 0x9884CB8F;
    union U1 l_20 = {2U};
    union U1 *l_19 = &l_20;
    struct S0 l_31 = {3,-0,2219};
    int8_t l_38 = 0;
    const int8_t *l_37 = &l_38;
    union U2 l_51 = {0x20104353};
    uint32_t l_52 = 0xBE41B0CE;
    uint32_t l_155 = 4294967292U;
    int32_t l_177 = (-1);
    int8_t l_182 = 0x38;
    int8_t *l_719 = (void*)0;
    uint16_t l_738 = 1U;
    int32_t *l_739 = &l_51.f0;
    union U2 * const l_740 = &l_51;
    union U2 *l_742 = (void*)0;
    union U2 **l_741 = &l_742;
    struct S0 *l_743 = (void*)0;
    struct S0 *l_744 = &l_31;
    union U1 l_745 = {65527U};
    l_19 = func_2((!func_8(l_12, ((safe_div_func_int32_t_s_s(func_15(l_12, l_19, func_21(func_26(l_31, func_32(&l_20, &l_20, l_37, (safe_rshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s(func_43(func_45(l_31.f2, l_51, l_51.f3, l_52, &l_38)), l_155)), l_20.f0))), l_177, &l_38), l_182, &l_20, &l_38)), l_51.f0)) < l_31.f1), l_20.f0)), l_177, l_51.f0, l_719);
    /* statement id: 286 */
    assert (l_19 == 0);
    (*l_739) = (safe_div_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_u((&l_19 != &l_19), (safe_lshift_func_int16_t_s_s(l_51.f3, 8)))) || (safe_mod_func_uint32_t_u_u((((safe_lshift_func_uint16_t_u_s((7 < (((void*)0 == &l_31) && ((&l_20 == &l_20) & l_738))), l_155)) >= l_12) == 0x85), l_31.f1))), (-1)));
    (*l_741) = l_740;
    /* statement id: 288 */
    assert (l_742 == &l_51);
    (*l_744) = l_31;
    return l_745;
    /* statement id: 290 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_2(const uint16_t  p_3, int16_t  p_4, uint32_t  p_5, int8_t * p_6)
{ /* block id: 283 */
    int32_t l_721 = (-1);
    int32_t *l_720 = &l_721;
    int32_t **l_722 = &l_720;
    union U1 l_724 = {1U};
    union U1 *l_723 = &l_724;
    union U1 *l_725 = &l_724;
    union U1 *l_726 = &l_724;
    union U1 *l_727 = (void*)0;
    (*l_722) = l_720;
    return l_727;
    /* statement id: 285 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int8_t  func_8(uint8_t  p_9, uint16_t  p_10, uint8_t  p_11)
{ /* block id: 279 */
    int32_t l_716 = 0xE77CB048;
    int32_t *l_715 = &l_716;
    const int32_t *l_718 = &l_716;
    const int32_t **l_717 = &l_718;
    (*l_717) = l_715;
    (*l_715) = (*l_718);
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_15(uint32_t  p_16, union U1 * p_17, int16_t  p_18)
{ /* block id: 215 */
    const struct S0 l_571 = {2,1,3811};
    struct S0 *l_572 = (void*)0;
    struct S0 l_574 = {2,-1,1996};
    struct S0 *l_573 = &l_574;
    int8_t l_580 = 0xF7;
    int8_t *l_579 = &l_580;
    int32_t * const l_590 = (void*)0;
    uint32_t l_591 = 4294967295U;
    uint8_t l_592 = 0x7C;
    union U1 l_616 = {0x9BFF};
    union U1 *l_615 = &l_616;
    union U1 **l_614 = &l_615;
    uint32_t l_633 = 0x47EFB90B;
    union U1 ***l_646 = (void*)0;
    union U2 l_680 = {0xD0070319};
    union U2 * const l_679 = &l_680;
    union U2 * const *l_678 = &l_679;
    union U2 * const **l_677 = &l_678;
    int32_t l_711 = (-3);
    int8_t **l_713 = &l_579;
    int8_t ***l_712 = &l_713;
    (*l_573) = l_571;
    if ((safe_mod_func_int16_t_s_s((((safe_lshift_func_uint8_t_u_s((l_571.f1 <= ((void*)0 == l_579)), (safe_add_func_uint32_t_u_u(((safe_div_func_uint32_t_u_u(((safe_add_func_uint8_t_u_u(((((((p_16 <= p_16) > (((!(l_590 != l_590)) != p_16) != ((p_16 && p_18) < p_18))) ^ p_16) || p_18) == 0x9F) || p_18), p_16)) == l_591), p_18)) | p_18), p_16)))) && l_592) | p_18), p_18)))
    { /* block id: 217 */
        int8_t * const * const l_593 = (void*)0;
        int8_t **l_595 = &l_579;
        int8_t ***l_594 = &l_595;
        int32_t l_597 = 0xB8E471CA;
        int32_t *l_596 = &l_597;
        int32_t **l_598 = &l_596;
        (*l_594) = l_593;
        /* statement id: 218 */
        assert (l_595 == 0);
        (*l_598) = l_596;
        (*l_596) = p_16;
    }
    else
    { /* block id: 221 */
        union U2 l_622 = {0x63A0385E};
        union U2 *l_621 = &l_622;
        int32_t *l_626 = &l_622.f0;
        uint16_t l_627 = 0xA298;
        union U1 ***l_636 = &l_614;
        struct S0 *l_659 = &l_574;
        int32_t l_710 = 0x8B21EA59;
        for (l_580 = 0; (l_580 == 0); l_580 = safe_add_func_uint32_t_u_u(l_580, 8))
        { /* block id: 224 */
            union U1 ***l_601 = (void*)0;
            union U1 l_605 = {0U};
            union U1 *l_604 = &l_605;
            union U1 **l_603 = &l_604;
            union U1 ***l_602 = &l_603;
            union U2 l_620 = {0x3FD580A7};
            union U2 *l_619 = &l_620;
            int32_t **l_628 = &l_626;
            (*l_602) = &p_17;
            /* statement id: 225 */
            assert (l_603 == &p_17);
            (*l_626) = ((safe_lshift_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s((safe_mod_func_uint8_t_u_u(((l_614 == &p_17) || ((safe_add_func_int8_t_s_s(0xCC, (l_619 != l_621))) || ((safe_unary_minus_func_int32_t_s(l_605.f4)) | ((safe_add_func_uint32_t_u_u(0x6F845BFB, ((l_626 != (void*)0) > 0xAEB4))) ^ 2U)))), 0x09)), 2)), 1U)), 10)) >= l_627);
            (*l_626) = p_18;
            (*l_628) = l_626;
        }
        for (l_627 = 0; (l_627 <= 41); l_627 = safe_add_func_uint32_t_u_u(l_627, 9))
        { /* block id: 232 */
            const union U2 *l_640 = &l_622;
            const int32_t l_645 = 0xABEBC237;
            struct S0 * const l_658 = &l_574;
            int8_t l_661 = 0xC1;
            int32_t **l_674 = &l_626;
            for (l_616.f1 = 0; (l_616.f1 > 15); l_616.f1 = safe_add_func_uint8_t_u_u(l_616.f1, 4))
            { /* block id: 235 */
                uint32_t l_637 = 0xD30F4613;
                union U2 * const *l_676 = (void*)0;
                union U2 * const **l_675 = &l_676;
                union U1 ***l_691 = &l_614;
                int32_t **l_714 = &l_626;
            }
            /* facts after for loop */
                    }
    }
    return p_16;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_21(int8_t * p_22, int32_t  p_23, union U1 * p_24, const int8_t * p_25)
{ /* block id: 67 */
    struct S0 l_183 = {5,0,2096};
    struct S0 *l_184 = &l_183;
    union U1 l_198 = {0xD879};
    union U1 *l_197 = &l_198;
    union U1 **l_196 = &l_197;
    union U1 ***l_195 = &l_196;
    int8_t *l_213 = (void*)0;
    union U2 l_220 = {0x8CE9429D};
    union U2 *l_219 = &l_220;
    uint32_t l_268 = 4294967295U;
    const int32_t l_274 = 0xDFD7D1BF;
    int32_t *l_296 = &l_220.f0;
    union U1 ** const l_311 = &l_197;
    const struct S0 l_407 = {2,0,3030};
    uint32_t l_449 = 1U;
    struct S0 **l_453 = &l_184;
    int32_t **l_457 = (void*)0;
    int32_t ***l_456 = &l_457;
    int16_t l_480 = 0x7C20;
    int32_t l_518 = 0x3D730E39;
    struct S0 l_548 = {7,-1,1668};
    (*l_184) = l_183;
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t * func_26(struct S0  p_27, int8_t * p_28, uint32_t  p_29, int8_t * p_30)
{ /* block id: 64 */
    struct S0 l_178 = {4,0,1165};
    struct S0 *l_179 = &l_178;
    int8_t l_181 = 0;
    int8_t *l_180 = &l_181;
    (*l_179) = l_178;
    return p_28;
    /* statement id: 66 */
    //assert (func_26_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t * func_32(union U1 * p_33, union U1 * p_34, const int8_t * p_35, uint32_t  p_36)
{ /* block id: 61 */
    uint8_t l_158 = 0x05;
    int32_t l_162 = (-1);
    const int32_t *l_161 = &l_162;
    int16_t l_163 = 0x3BB2;
    int32_t *l_170 = &l_162;
    int8_t l_172 = (-8);
    int8_t *l_171 = &l_172;
    int8_t *l_173 = &l_172;
    int8_t *l_174 = &l_172;
    int8_t *l_175 = &l_172;
    int8_t *l_176 = (void*)0;
    (*l_170) = (((safe_mod_func_uint32_t_u_u((((l_158 | (p_36 <= ((void*)0 != l_161))) == l_163) < (((safe_sub_func_uint32_t_u_u(0xEA7E5B63, ((safe_mul_func_int32_t_s_s((p_35 == (void*)0), (!((safe_unary_minus_func_uint8_t_u((p_36 && p_36))) == (*l_161))))) & 6))) && (*l_161)) ^ p_36)), p_36)) ^ (*l_161)) < p_36);
    return l_176;
    /* statement id: 63 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_43(int8_t * p_44)
{ /* block id: 4 */
    int8_t l_60 = (-5);
    union U2 l_61 = {0x4895C4B7};
    int32_t ***l_68 = (void*)0;
    int32_t *l_71 = &l_61.f0;
    int32_t **l_70 = &l_71;
    int32_t ***l_69 = &l_70;
    union U1 l_98 = {0xAE39};
    union U1 *l_97 = &l_98;
    union U1 **l_96 = &l_97;
    union U1 ***l_95 = &l_96;
    int32_t *l_150 = &l_98.f2;
    uint32_t l_154 = 4294967295U;
lbl_77:
    (*l_69) = func_57(l_60, l_61);
    /* statement id: 9 */
    assert (l_70 == 0);
    for (l_60 = 0; (l_60 > (-12)); l_60 = safe_sub_func_uint16_t_u_u(l_60, 6))
    { /* block id: 12 */
        int32_t l_74 = 0;
        int32_t **l_114 = &l_71;
        union U1 *l_115 = &l_98;
        if ((*l_71))
            break;
        for (l_74 = 0; (l_74 < 9); l_74 = safe_add_func_uint32_t_u_u(l_74, 1))
        { /* block id: 16 */
            int32_t l_78 = 0;
            union U1 ***l_99 = &l_96;
            union U2 *l_121 = &l_61;
            union U2 **l_120 = &l_121;
            int32_t l_122 = 0xD90BC214;
            int32_t * const *l_129 = &l_71;
            int32_t * const * const *l_128 = &l_129;
            if (l_61.f0)
                goto lbl_77;
            for (l_78 = 0; (l_78 == 11); l_78 = safe_add_func_uint16_t_u_u(l_78, 1))
            { /* block id: 20 */
                int8_t l_102 = 0xD5;
                union U2 l_116 = {0x1773A67F};
                uint32_t l_148 = 1U;
                (*l_71) = ((safe_rshift_func_uint16_t_u_u((l_74 != ((((l_78 < (((safe_div_func_uint8_t_u_u((l_74 > (*l_71)), ((safe_lshift_func_uint16_t_u_u((0x900DD038 < ((safe_add_func_uint16_t_u_u(((safe_mod_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(l_78, 11)) && (l_95 != l_99)), (safe_div_func_int8_t_s_s(((l_74 | l_102) && l_74), l_74)))) <= 246U), 0x1253)) | 0xC3F4)), l_74)) || 0xA7CF))) || l_78) <= (*p_44))) ^ l_74) && (*p_44)) >= l_78)), l_78)) == l_74);
                if ((&l_60 == (void*)0))
                { /* block id: 22 */
                    uint32_t l_103 = 0xE909801C;
                    (*l_71) = l_103;
                    return l_102;
                }
                else
                { /* block id: 25 */
                    int32_t *l_107 = &l_61.f0;
                    int32_t l_110 = 0;
                    union U2 *l_118 = (void*)0;
                    for (l_98.f1 = 0; (l_98.f1 > 44); ++l_98.f1)
                    { /* block id: 28 */
                        union U1 **l_106 = &l_97;
                        if (l_61.f0)
                            goto lbl_77;
                        if (l_74)
                            goto lbl_77;
                        (*l_99) = l_106;
                        l_107 = (void*)0;
                        /* statement id: 32 */
                        assert (l_107 == 0);
                    }
                    /* facts after for loop */
                                        assert (l_107 == 0 || l_107 == &l_61.f0);
                    if ((((safe_sub_func_int16_t_s_s(l_102, (1 > l_110))) > ((~(0x326B == (safe_add_func_uint8_t_u_u(0xE4, ((void*)0 != &l_110))))) < (l_74 >= (((*l_69) == l_114) > (**l_114))))) || (**l_114)))
                    { /* block id: 34 */
                        int32_t ***l_117 = &l_114;
                        union U2 **l_119 = &l_118;
                        (*l_117) = func_57(((**l_99) != l_115), l_116);
                        /* statement id: 35 */
                        assert (l_114 == 0);
                        (*l_119) = l_118;
                        return l_116.f3;
                    }
                    else
                    { /* block id: 38 */
                        l_122 = ((void*)0 != l_120);
                    }
                    for (l_110 = 0; (l_110 == 5); l_110 = safe_add_func_uint32_t_u_u(l_110, 3))
                    { /* block id: 43 */
                        uint32_t l_127 = 0x67432329;
                        int32_t *l_149 = &l_74;
                        l_148 = ((((**l_114) < (safe_sub_func_uint32_t_u_u((l_127 <= (l_128 != (void*)0)), (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((((safe_unary_minus_func_uint8_t_u((~(((safe_rshift_func_int16_t_s_s(1, ((~(safe_div_func_uint32_t_u_u((safe_mod_func_int16_t_s_s(((safe_add_func_uint32_t_u_u((((-1) < ((~(safe_add_func_int32_t_s_s(l_127, (**l_114)))) || (l_127 & (***l_128)))) >= l_127), 0x5DC67607)) || 0xC662C875), 1)), (**l_114)))) <= l_127))) == l_127) & 1U)))) < l_127) > l_127), 8)), l_127))))) >= l_127) || 0x54E7);
                        (*l_114) = l_149;
                        /* statement id: 45 */
                        assert (l_71 == &l_74);
                    }
                    /* facts after for loop */
                    assert (l_71 == &l_74 || l_71 == &l_61.f0);
                    return l_102;
                }
            }
            (*l_114) = (*l_114);
            l_150 = (**l_128);
            /* statement id: 51 */
            assert (l_150 == &l_61.f0);
        }
        for (l_98.f4 = (-16); (l_98.f4 <= 6); ++l_98.f4)
        { /* block id: 55 */
            int8_t l_153 = (-4);
            if (l_98.f4)
                goto lbl_77;
            return l_153;
        }
    }
    return l_154;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t * func_45(uint16_t  p_46, union U2  p_47, const int8_t  p_48, uint16_t  p_49, int8_t * p_50)
{ /* block id: 1 */
    int32_t *l_53 = (void*)0;
    int32_t **l_54 = &l_53;
    int8_t l_56 = 0xE1;
    int8_t *l_55 = &l_56;
    (*l_54) = l_53;
    return p_50;
    /* statement id: 3 */
    //assert (func_45_rv == &l_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** const  func_57(uint32_t  p_58, union U2  p_59)
{ /* block id: 5 */
    union U1 l_63 = {0xD296};
    union U1 *l_62 = &l_63;
    int32_t *l_64 = &l_63.f2;
    union U1 **l_66 = &l_62;
    union U1 ***l_65 = &l_66;
    int32_t ** const l_67 = (void*)0;
    (*l_64) = (l_62 == &l_63);
    /* statement id: 6 */
        (*l_65) = &l_62;
    return l_67;
    /* statement id: 8 */
    //assert (func_57_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 160
   depth: 1, occurrence: 13
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 25
breakdown:
   indirect level: 0, occurrence: 13
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 6
XXX full-bitfields structs in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 21

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 205

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 78
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 81
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 7
XXX times a pointer is compared with null: 43
XXX times a pointer is compared with address of another variable: 19
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 440

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 208
   level: 2, occurrence: 92
   level: 3, occurrence: 37
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 21.5
XXX average alias set size: 1.1

XXX times a non-volatile is read: 668
XXX times a non-volatile is write: 212
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 8

XXX stmts: 64
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 8
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 6
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 19.4
XXX percentage an existing variable is used: 80.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

