/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3622791344
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   float  f1;
   int32_t  f2;
};
#pragma pack(pop)

union U1 {
   int32_t  f0;
};

union U2 {
   int32_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static float  func_29(void);
static uint16_t  func_34(const struct S0  p_35, int32_t  p_36);
static const struct S0  func_37(int32_t  p_38, float  p_39, uint32_t  p_40, float  p_41);
inline static uint32_t  func_43(union U1  p_44, int16_t  p_45, union U2  p_46, const union U1  p_47, struct S0  p_48);
inline static union U1  func_49(int32_t  p_50, uint16_t  p_51);
static struct S0  func_56(int32_t  p_57, struct S0  p_58);
static struct S0  func_59(union U1  p_60, float  p_61, union U1  p_62, uint16_t  p_63, uint32_t  p_64);
inline static union U1  func_65(int32_t  p_66, float  p_67, uint32_t  p_68, const union U2  p_69, int32_t  p_70);
static uint16_t  func_73(const uint32_t  p_74, float  p_75, uint16_t  p_76, union U1  p_77, float  p_78);
inline static int32_t * func_84(int32_t  p_85, float  p_86, int32_t * p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_29(void)
{ /* block id: 36 */
    float l_32 = (-0x9.Fp-1);
    int32_t l_33 = (-2);
    uint32_t l_52 = 0x72010435;
    float l_55 = 0xA.C1E183p+98;
    union U2 l_173 = {0x3A51B20E};
    const union U1 l_174 = {0x46356B4A};
    struct S0 l_175 = {0x19563820,0x8.4p-1,6};
    int32_t *l_337 = (void*)0;
    int32_t *l_338 = (void*)0;
    int16_t l_339 = 0x74C6;
    l_175.f0 = (0U ^ ((uint16_t)(9 >= 0xAB89) - (uint16_t)(l_33 >= func_34(func_37(l_33, l_33, (+(l_33 | func_43(func_49(l_52, (((int32_t)(l_52 > l_52) - (int32_t)l_33) != 4294967295U)), l_52, l_173, l_174, l_175))), l_173.f1), l_52))));
    return l_339;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_34(const struct S0  p_35, int32_t  p_36)
{ /* block id: 179 */
    float **l_288 = (void*)0;
    const int32_t l_295 = 6;
    union U1 l_296 = {8};
    const union U1 *l_298 = &l_296;
    const union U1 * const *l_297 = &l_298;
    union U2 l_310 = {0x518CAC00};
    struct S0 l_311 = {0x52184DD8,0xB.BA08D8p+41,-1};
    int32_t *l_320 = (void*)0;
    int32_t **l_321 = &l_320;
    uint16_t l_328 = 7U;
    int32_t l_336 = 9;
    l_288 = l_288;
    if (((int16_t)(((uint16_t)func_73(l_295, p_36, __builtin_popcountll(l_295), l_296, p_35.f1) % (uint16_t)0x310D) | ((void*)0 != l_297)) % (int16_t)p_35.f2))
    { /* block id: 181 */
        uint16_t l_309 = 65530U;
        int32_t *l_312 = &l_296.f0;
        union U1 *l_314 = &l_296;
        union U1 **l_313 = &l_314;
        (*l_312) = ((uint16_t)((((uint16_t)((uint16_t)l_295 + (uint16_t)(((int32_t)(p_36 == ((uint16_t)p_35.f2 << (uint16_t)2)) + (int32_t)((0x9F18 >= l_309) < func_43((**l_297), p_36, l_310, (**l_297), l_311))) <= p_35.f2)) << (uint16_t)2) && l_296.f0) | 0x56AE9782) << (uint16_t)p_36);
        (*l_313) = (*l_297);
    }
    else
    { /* block id: 184 */
        int32_t *l_315 = &l_310.f0;
        (*l_315) = p_35.f0;
    }
    (*l_321) = func_84((((p_35.f0 == (__builtin_ffsll(l_310.f1) & p_35.f0)) != l_296.f0) & (func_43(func_65(((int32_t)(&l_288 == (void*)0) % (int32_t)p_35.f2), ((float)(l_288 != l_288) + (float)(-0x5.Cp-1)), l_311.f2, l_310, l_295), l_296.f0, l_310, (*l_298), l_311) && 0x0CDF)), l_310.f1, l_320);
    for (p_36 = 0; (p_36 == 17); p_36 += 5)
    { /* block id: 190 */
        union U1 *l_331 = &l_296;
        union U1 **l_330 = &l_331;
        int32_t l_332 = 1;
        float *l_335 = &l_311.f1;
        (*l_335) = (((float)((float)(l_328 >= (!(p_35.f1 >= (l_330 == &l_331)))) + (float)((l_332 != p_35.f0) <= 0x0.E9098Ep-85)) - (float)l_332) != ((float)__builtin_clzll(p_35.f0) - (float)p_35.f0));
    }
    return l_336;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_37(int32_t  p_38, float  p_39, uint32_t  p_40, float  p_41)
{ /* block id: 140 */
    uint32_t l_239 = 0x5512477A;
    float l_249 = 0x1.2p+1;
    float *l_248 = &l_249;
    float **l_247 = &l_248;
    int32_t l_262 = 0x26D7F8DA;
    int32_t *l_261 = &l_262;
    union U1 l_271 = {0x8943D24E};
    union U2 l_272 = {0x79C46A1A};
    struct S0 l_273 = {0x737E1BAF,0x5.159CCDp+52,0x8BAC6151};
    int32_t l_274 = (-9);
    struct S0 *l_284 = (void*)0;
    uint32_t l_286 = 0x60EE2D55;
    const union U1 l_287 = {1};
    for (p_40 = (-13); (p_40 <= 20); p_40 += 4)
    { /* block id: 143 */
        struct S0 l_206 = {0xFE17F827,-0x1.Dp+1,7};
        struct S0 *l_205 = &l_206;
        struct S0 **l_204 = &l_205;
        int32_t *l_220 = &l_206.f0;
        uint16_t l_221 = 0U;
        float ***l_250 = &l_247;
        if ((l_204 == &l_205))
        { /* block id: 144 */
            struct S0 l_207 = {8,0x0.9p-1,8};
            int32_t *l_214 = (void*)0;
            float *l_243 = &l_206.f1;
            (**l_204) = l_207;
            l_207.f0 = p_39;
            if ((((int16_t)(((int16_t)((int16_t)0 + (int16_t)(l_214 == &p_38)) >> (int16_t)8) == ((uint16_t)l_206.f0 << (uint16_t)((uint16_t)(-(int32_t)((void*)0 == l_220)) << (uint16_t)(l_221 < (&l_220 != (void*)0))))) - (int16_t)p_38) <= (*l_220)))
            { /* block id: 147 */
                int32_t l_222 = 0x8C3BF28D;
                int32_t *l_223 = &l_207.f0;
                l_223 = func_84(p_38, l_222, &p_38);
                /* statement id: 148 */
                assert (l_223 == &p_38);
                (*l_220) = (0x8248 < (((uint32_t)((uint32_t)(!(((*l_220) >= (((uint16_t)((int16_t)p_38 % (int16_t)((int32_t)((uint32_t)(&p_38 != (void*)0) + (uint32_t)(&l_205 != (void*)0)) + (int32_t)((((uint32_t)l_239 + (uint32_t)p_38) && 0xD67C) == (-6)))) << (uint16_t)11) || (*l_220))) <= (*l_223))) % (uint32_t)(*l_220)) % (uint32_t)0x7F1B4AE9) > p_40));
                if (p_40)
                    break;
                if (p_40)
                    continue;
            }
            else
            { /* block id: 152 */
                struct S0 l_240 = {0,-0x10.4p-1,-6};
                int32_t **l_241 = (void*)0;
                int32_t **l_242 = &l_220;
                (**l_204) = l_240;
                (*l_242) = l_214;
                /* statement id: 154 */
                assert (l_220 == 0);
                (**l_204) = (**l_204);
            }
            /* facts after branching */
            assert (l_220 == 0 || l_220 == &l_206.f0);
            (*l_243) = 0x2.EC58B0p+73;
        }
        else
        { /* block id: 158 */
            uint32_t l_244 = 4294967295U;
            int32_t **l_245 = (void*)0;
            int32_t **l_246 = &l_220;
            (*l_246) = func_84((*l_220), (__builtin_ctzll((*l_220)) == l_244), l_220);
        }
        /* facts after branching */
        assert (l_220 == 0 || l_220 == &l_206.f0);
        (*l_250) = l_247;
        if (p_38)
            continue;
        for (l_206.f2 = 25; (l_206.f2 == 27); l_206.f2 += 5)
        { /* block id: 165 */
            int32_t *l_253 = (void*)0;
            int32_t *l_254 = &l_206.f0;
            union U1 l_258 = {0x41E8B384};
            union U1 *l_257 = &l_258;
            const struct S0 l_260 = {0,0x9.82912Ap+44,0x5AC8D5AC};
            (*l_254) = p_40;
            for (l_221 = 0; (l_221 > 33); l_221++)
            { /* block id: 169 */
                union U1 **l_259 = &l_257;
                (*l_259) = l_257;
            }
            return l_260;
        }
    }
    (*l_261) = 0;
    (**l_247) = (((((float)p_41 + (float)((((float)p_38 + (float)(*l_261)) != p_40) < 0x8.DF3651p+87)) < ((float)(((-0x10.Dp+1) != 0x0.Cp-1) <= ((float)func_43(l_271, (*l_261), l_272, l_271, l_273) - (float)(*l_261))) + (float)(-0x8.2p-1))) < 0x1.Bp-1) <= l_274);
    (*l_261) = ((int32_t)(*l_261) + (int32_t)(p_38 <= (((func_43(l_271, (((uint16_t)(((((((+((uint32_t)((int16_t)p_40 >> (int16_t)((void*)0 != l_284)) * (uint32_t)((~(*l_261)) >= l_286))) >= p_40) | (*l_261)) < p_40) && (*l_261)) | (*l_261)) ^ (*l_261)) >> (uint16_t)(*l_261)) && p_38), l_272, l_287, l_273) == p_38) < (*l_261)) == 0U)));
    return l_273;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_43(union U1  p_44, int16_t  p_45, union U2  p_46, const union U1  p_47, struct S0  p_48)
{ /* block id: 120 */
    const int16_t l_178 = (-9);
    int32_t l_181 = 0;
    int32_t *l_180 = &l_181;
    int32_t ** const l_179 = &l_180;
    float l_182 = 0xE.D097A5p+91;
    int16_t l_185 = 0x7040;
    const struct S0 l_190 = {-7,0xC.E3C2ACp-99,9};
    const struct S0 *l_189 = &l_190;
    const struct S0 **l_188 = &l_189;
    int32_t l_193 = 7;
    if (((uint32_t)(p_46.f1 && (func_73(l_178, l_178, (((void*)0 != l_179) != 0), p_44, (l_182 < (((float)(*l_180) + (float)l_185) != 0x3.47E691p+92))) <= 0x95D0)) - (uint32_t)0x79D1BA22))
    { /* block id: 121 */
        struct S0 *l_192 = (void*)0;
        struct S0 **l_191 = &l_192;
lbl_194:
        for (p_44.f0 = (-12); (p_44.f0 < 13); ++p_44.f0)
        { /* block id: 124 */
            return p_46.f0;
        }
        l_193 = (l_188 != l_191);
        if (p_46.f1)
            goto lbl_194;
    }
    else
    { /* block id: 129 */
        int32_t l_195 = (-5);
        int32_t *l_201 = &l_181;
        (*l_179) = func_84(l_195, (**l_179), (*l_179));
        for (l_181 = (-3); (l_181 >= 21); l_181 += 8)
        { /* block id: 133 */
            uint32_t l_198 = 0x5E2D5444;
            struct S0 l_199 = {0x6149A46C,0x7.4F6019p-15,0x6A2F9622};
            struct S0 *l_200 = &l_199;
            (*l_200) = func_56(l_198, l_199);
            (*l_179) = (*l_179);
        }
        (*l_179) = func_84(((*l_179) != l_201), __builtin_bswap32(p_48.f2), l_201);
    }
    return p_48.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_49(int32_t  p_50, uint16_t  p_51)
{ /* block id: 37 */
    uint32_t l_71 = 7U;
    union U1 l_83 = {0};
    const union U2 l_131 = {0xB2FD71B9};
    struct S0 l_172 = {7,0xF.AC0673p-97,0};
    struct S0 *l_171 = &l_172;
    (*l_171) = func_56(p_51, func_59(func_65(p_51, __builtin_ffs(l_71), (0x463A4739 > (0x3DCDCBD5 || (0x4E0C42EF > (__builtin_ffs((+(0x0510 & func_73((((int32_t)(((uint16_t)((0U <= 0x74B1) < l_71) >> (uint16_t)p_51) ^ 0x865E429B) % (int32_t)0x46406CCC) < (-1)), l_71, l_71, l_83, p_51)))) <= 0x68FE)))), l_131, l_131.f1), l_83.f0, l_83, l_131.f0, l_71));
    return l_83;
    /* statement id: 119 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_56(int32_t  p_57, struct S0  p_58)
{ /* block id: 90 */
    int32_t l_154 = 1;
    int32_t l_155 = (-2);
    struct S0 *l_160 = (void*)0;
    struct S0 l_170 = {0xDF4E952D,0xB.C51062p-45,-1};
    for (p_57 = 0; (p_57 <= 24); p_57 += 7)
    { /* block id: 93 */
        uint32_t l_147 = 0xC35E3CEA;
        int32_t *l_167 = &l_155;
        int32_t **l_166 = &l_167;
        float l_169 = 0x0.5p+1;
        float *l_168 = &l_169;
        for (p_58.f2 = 0; (p_58.f2 != 24); ++p_58.f2)
        { /* block id: 96 */
            int32_t l_149 = 1;
            int32_t *l_148 = &l_149;
            int32_t *l_150 = &l_149;
            int32_t **l_151 = &l_150;
            union U1 l_156 = {0};
            (*l_148) = (-(uint32_t)l_147);
            (*l_151) = func_84((*l_148), p_58.f1, l_150);
            for (l_147 = 1; (l_147 <= 34); l_147++)
            { /* block id: 101 */
                uint32_t l_161 = 0xE863DC2C;
                if ((p_58.f0 || 0x07BB3E8C))
                { /* block id: 102 */
                    int32_t l_159 = 0xE7324BB9;
                    union U1 l_162 = {0x7DBBC662};
                    struct S0 l_164 = {0x78DD8142,0x2.Cp+1,1};
                    struct S0 *l_163 = &l_164;
                    l_155 = l_154;
                    (*l_163) = func_59(l_156, func_73(((((int16_t)__builtin_ctz(l_159) - (int16_t)(&p_58 == l_160)) | p_57) != (p_58.f2 < (l_161 && func_73(((l_159 | l_155) == (-1)), l_147, p_57, l_162, l_161)))), p_58.f1, l_161, l_156, p_57), l_162, p_58.f0, p_58.f0);
                    if (p_58.f0)
                        continue;
                    (*l_163) = p_58;
                }
                else
                { /* block id: 107 */
                    struct S0 **l_165 = &l_160;
                    (*l_165) = (void*)0;
                    if (p_58.f0)
                        break;
                    (*l_151) = func_84(p_57, (*l_148), &l_155);
                    /* statement id: 110 */
                    assert (l_150 == &l_155);
                }
            }
            /* facts after for loop */
            assert (l_150 == &l_155 || l_150 == &l_149);
        }
        (*l_166) = &l_155;
        (*l_168) = 0x0.2p-1;
    }
    return l_170;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_59(union U1  p_60, float  p_61, union U1  p_62, uint16_t  p_63, uint32_t  p_64)
{ /* block id: 87 */
    int32_t l_140 = 4;
    struct S0 l_141 = {0x9E22A417,-0x1.Ep+1,0x5ED510FE};
    l_140 = 1;
    return l_141;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_65(int32_t  p_66, float  p_67, uint32_t  p_68, const union U2  p_69, int32_t  p_70)
{ /* block id: 78 */
    const int32_t l_136 = (-1);
    union U1 l_139 = {0x77AE26BD};
    for (p_70 = (-3); (p_70 >= 7); p_70++)
    { /* block id: 81 */
        int32_t *l_135 = (void*)0;
        int32_t **l_134 = &l_135;
        int32_t l_138 = (-3);
        int32_t *l_137 = &l_138;
        (*l_134) = &p_70;
        /* statement id: 82 */
        assert (l_135 == &p_70);
        if (l_136)
            break;
        (*l_137) = (**l_134);
    }
    return l_139;
    /* statement id: 86 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_73(const uint32_t  p_74, float  p_75, uint16_t  p_76, union U1  p_77, float  p_78)
{ /* block id: 38 */
    float l_92 = 0x0.4BC073p-47;
    int32_t l_93 = 0xBD444C67;
    int32_t *l_97 = &l_93;
    int32_t **l_96 = &l_97;
    int16_t l_104 = 0xD925;
    uint32_t l_109 = 4294967286U;
    uint32_t l_123 = 0x46A4E19C;
    struct S0 l_125 = {0,0x0.2p-1,0x6A910B13};
    struct S0 *l_124 = &l_125;
    (*l_96) = func_84((p_74 < p_76), (((float)((((float)p_78 - (float)(-0x1.5p+1)) <= ((l_92 == l_93) == l_93)) == ((p_76 == l_93) > l_93)) + (float)p_77.f0) != p_74), &l_93);
    for (p_77.f0 = (-2); (p_77.f0 > (-20)); p_77.f0--)
    { /* block id: 45 */
        int16_t l_110 = 0x1B0F;
        struct S0 *l_126 = &l_125;
        if ((0xAAC79E06 >= (0x5DCA >= (__builtin_parityl((**l_96)) <= ((((7 == (-1)) || ((int32_t)(__builtin_ffsl((((uint16_t)__builtin_ffsl(l_104) + (uint16_t)((int32_t)((int32_t)((l_109 < l_110) < l_110) + (int32_t)p_76) - (int32_t)0xFE427CCD)) & p_77.f0)) || p_77.f0) - (int32_t)(*l_97))) <= l_110) >= p_76)))))
        { /* block id: 46 */
            float *l_113 = &l_92;
            (*l_113) = ((float)(p_74 < (-0x1.0p-1)) - (float)l_110);
            (*l_96) = func_84(p_77.f0, l_110, (*l_96));
        }
        else
        { /* block id: 49 */
            int16_t l_116 = 0xF132;
            int32_t *l_117 = (void*)0;
            for (l_110 = 0; (l_110 <= 12); ++l_110)
            { /* block id: 52 */
                (*l_96) = func_84(p_77.f0, l_116, l_117);
                /* statement id: 53 */
                assert (l_97 == 0);
                for (l_109 = 0; (l_109 >= 32); l_109++)
                { /* block id: 56 */
                    float *l_120 = &l_92;
                    (*l_120) = (-0x1.9p+1);
                }
            }
            /* facts after for loop */
            assert (l_97 == 0 || l_97 == &l_93);
            (*l_96) = (void*)0;
            /* statement id: 60 */
            assert (l_97 == 0);
            return p_76;
        }
        for (l_110 = (-24); (l_110 == (-12)); l_110 += 1)
        { /* block id: 65 */
            (*l_96) = func_84(p_76, p_75, (*l_96));
            if (p_74)
                continue;
            if (l_110)
            { /* block id: 68 */
                l_123 = 0xC73263BB;
                (*l_96) = (*l_96);
                l_126 = l_124;
            }
            else
            { /* block id: 72 */
                float *l_129 = (void*)0;
                int32_t l_130 = (-10);
                (*l_96) = func_84(((uint16_t)((l_129 == l_129) | 0U) + (uint16_t)p_76), (0x6.040F3Cp+78 > l_130), (*l_96));
            }
        }
    }
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_84(int32_t  p_85, float  p_86, int32_t * p_87)
{ /* block id: 39 */
    int32_t *l_95 = (void*)0;
    int32_t **l_94 = &l_95;
    (*l_94) = p_87;
    /* statement id: 40 */
    //assert (l_95 == &l_93 || l_95 == 0 || l_95 == &l_149 || l_95 == &l_155 || l_95 == &l_181 || l_95 == &p_38 || l_95 == &l_206.f0);
    return p_87;
    /* statement id: 41 */
    //assert (func_84_rv == &l_93 || func_84_rv == 0 || func_84_rv == &l_149 || func_84_rv == &l_155 || func_84_rv == &l_181 || func_84_rv == &p_38 || func_84_rv == &l_206.f0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 80
   depth: 1, occurrence: 9
XXX total union variables: 12

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 7
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 17, occurrence: 3
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 66

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 37
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 43
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 81

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 85
   level: 2, occurrence: 13
XXX number of pointers point to pointers: 22
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 27.3
XXX average alias set size: 1.32

XXX times a non-volatile is read: 345
XXX times a non-volatile is write: 113
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 94
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 22
   depth: 2, occurrence: 22
   depth: 3, occurrence: 15
   depth: 4, occurrence: 8

XXX percentage a fresh-made variable is used: 28.2
XXX percentage an existing variable is used: 71.8
********************* end of statistics **********************/

