/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3093437056
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const int32_t  f0;
   const float  f1;
   uint32_t  f2;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 29;
   const signed f1 : 3;
   signed : 0;
   signed f2 : 12;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   int32_t  f0;
   uint32_t  f1;
   const uint32_t  f2;
};
#pragma pack(pop)

union U3 {
   int32_t  f0;
   float  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_29(void);
inline static int32_t * func_30(struct S2  p_31);
static struct S2  func_32(int32_t  p_33);
inline static int32_t ** const  func_37(const int32_t  p_38, union U3  p_39, uint32_t  p_40);
inline static union U3  func_41(int32_t ** p_42, struct S1  p_43);
inline static struct S1  func_47(struct S2  p_48, int32_t * p_49, int32_t  p_50, int32_t * p_51, const int32_t ** p_52);
static struct S2  func_53(struct S1  p_54, struct S0  p_55, const struct S0  p_56, const int16_t  p_57, int32_t ** p_58);
inline static struct S1  func_59(uint32_t  p_60, int32_t ** p_61, uint32_t  p_62, const union U3  p_63);
static int32_t  func_64(int32_t ** p_65);
static int32_t ** func_66(struct S0  p_67, int32_t * p_68, struct S0  p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_34 = 1U;
    int32_t l_709 = 0x67B505FA;
    int32_t *l_708 = &l_709;
    int32_t **l_707 = &l_708;
    int32_t l_712 = 0x15616ADC;
    const uint32_t l_713 = 6U;
    uint32_t l_714 = 0U;
    (*l_707) = func_30(func_32(l_34));
    /* statement id: 444 */
    assert (l_708 == 0);
    l_714 = ((int16_t)(l_34 | l_34) >> (int16_t)__builtin_popcountl((l_34 || ((l_709 > l_34) || (((__builtin_ffs(l_712) || l_712) | l_712) && l_713)))));
    return l_714;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_30(struct S2  p_31)
{ /* block id: 441 */
    int32_t l_697 = (-10);
    int32_t *l_696 = &l_697;
    int32_t **l_698 = &l_696;
    int32_t *l_699 = &l_697;
    int32_t *l_700 = &l_697;
    int32_t *l_701 = &l_697;
    int32_t *l_702 = &l_697;
    int32_t *l_703 = &l_697;
    int32_t *l_704 = &l_697;
    int32_t *l_705 = &l_697;
    int32_t *l_706 = (void*)0;
    (*l_698) = l_696;
    return l_706;
    /* statement id: 443 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_32(int32_t  p_33)
{ /* block id: 37 */
    int32_t l_46 = 0x7C6DD3ED;
    int32_t *l_45 = &l_46;
    int32_t **l_44 = &l_45;
    struct S0 l_72 = {0x820EAADA,0x3.D98C68p+36,0x86A8E7E6};
    const union U3 l_238 = {0};
    int32_t l_390 = (-1);
    int32_t *l_389 = &l_390;
    struct S2 l_526 = {0x1B374B03,0U,0xA857ABA2};
    struct S2 *l_525 = &l_526;
    const int32_t *l_530 = &l_390;
    struct S2 l_533 = {0x1BF8B169,4294967295U,4294967289U};
    float l_603 = 0x2.BE1705p+80;
    float *l_602 = &l_603;
    struct S1 *****l_609 = (void*)0;
    struct S0 **l_639 = (void*)0;
    struct S2 l_695 = {0xA962D154,0xB91E947A,4294967292U};
    for (p_33 = 0; (p_33 != 27); ++p_33)
    { /* block id: 40 */
        struct S0 l_70 = {0xA458230B,0xD.5435D7p-52,0x1D5762CC};
        int32_t *l_71 = &l_46;
        struct S1 l_236 = {19382,-0,-23};
        struct S1 *l_235 = &l_236;
        struct S1 **l_234 = &l_235;
        int32_t **l_237 = &l_71;
        int32_t *l_391 = &l_390;
        const int32_t *l_393 = &l_390;
        const int32_t **l_392 = &l_393;
        int32_t * const **l_511 = (void*)0;
        int32_t * const *l_513 = &l_45;
        int32_t * const **l_512 = &l_513;
        struct S2 *l_527 = (void*)0;
    }
lbl_623:
    for (l_390 = 0; (l_390 < (-4)); l_390--)
    { /* block id: 314 */
        int32_t l_537 = 0xA345A6B2;
        uint16_t l_552 = 0x6766;
        int32_t l_553 = (-8);
        int32_t l_557 = 0x5409C428;
        int32_t **l_558 = &l_389;
        struct S2 ** const l_561 = &l_525;
        struct S1 l_594 = {14717,1,-19};
        const struct S1 *l_593 = &l_594;
    }
    (*l_602) = p_33;
    if ((&l_72 == (void*)0))
    { /* block id: 373 */
        int32_t *l_604 = (void*)0;
        struct S0 *l_605 = &l_72;
        struct S0 **l_606 = &l_605;
        (*l_44) = l_604;
        /* statement id: 374 */
        assert (l_45 == 0);
        (*l_606) = l_605;
        (*l_602) = ((((float)p_33 + (float)(*l_389)) < ((l_609 != l_609) <= (*l_389))) >= 0x0.8p-1);
    }
    else
    { /* block id: 377 */
        struct S1 *l_611 = (void*)0;
        struct S1 **l_610 = &l_611;
        int32_t * const l_620 = &l_390;
        int32_t **l_626 = &l_45;
        struct S2 **l_661 = &l_525;
        struct S2 ***l_660 = &l_661;
        if ((l_610 == (void*)0))
        { /* block id: 378 */
            const int32_t *l_617 = &l_46;
            struct S0 *l_638 = (void*)0;
            struct S0 **l_637 = &l_638;
            int32_t l_646 = 1;
            if (p_33)
            { /* block id: 379 */
                const int32_t *l_616 = &l_390;
                struct S1 *l_622 = (void*)0;
                (**l_44) = p_33;
                for (p_33 = (-22); (p_33 != 27); p_33++)
                { /* block id: 383 */
                    struct S2 *l_614 = &l_526;
                    struct S1 **l_618 = &l_611;
                    int32_t **l_621 = &l_389;
                    if ((l_614 == &l_526))
                    { /* block id: 384 */
                        struct S2 l_615 = {0,0xE0243832,0x13771A64};
                        (*l_602) = p_33;
                        return l_615;
                    }
                    else
                    { /* block id: 387 */
                        struct S1 ***l_619 = &l_618;
                        l_617 = l_616;
                        /* statement id: 388 */
                        assert (l_617 == &l_390);
                        (*l_619) = l_618;
                    }
                    /* facts after branching */
                    assert (l_617 == &l_390);
                    (*l_621) = l_620;
                    (*l_45) = (*l_389);
                }
                /* facts after for loop */
                assert (l_617 == &l_390 || l_617 == &l_46);
                if (p_33)
                { /* block id: 394 */
                    (*l_602) = (l_617 == (void*)0);
                    (*l_610) = l_622;
                    if (p_33)
                        goto lbl_623;
                }
                else
                { /* block id: 398 */
                    (*l_620) = (func_64(l_626) <= (((int32_t)(+3) + (int32_t)((uint16_t)p_33 << (uint16_t)((int32_t)p_33 + (int32_t)p_33))) > p_33));
                }
                (*l_620) = (*l_530);
            }
            else
            { /* block id: 402 */
                int32_t ***l_634 = &l_626;
                struct S0 l_644 = {0,0x9.B14108p+3,4294967295U};
                uint32_t l_645 = 0U;
                l_634 = l_634;
                (*l_602) = ((float)((*l_389) <= ((((l_637 != l_639) > p_33) > p_33) >= (-0x1.5p-1))) - (float)(((float)((float)func_64(func_66(l_644, (**l_634), l_644)) + (float)(***l_634)) - (float)0x0.0p+1) == l_645));
                l_646 = 0x6.5A5286p-92;
            }
            /* facts after branching */
            assert (l_617 == &l_390 || l_617 == &l_46);
            (*l_602) = p_33;
        }
        else
        { /* block id: 408 */
            struct S1 ***l_667 = &l_610;
            (*l_626) = (void*)0;
            /* statement id: 409 */
            assert (l_45 == 0);
            (*l_602) = p_33;
            for (p_33 = 0; (p_33 < 12); ++p_33)
            { /* block id: 413 */
                int32_t **l_666 = &l_45;
                struct S2 l_678 = {-7,0x54E6C621,4294967288U};
                union U3 l_682 = {0xB917662D};
                union U3 *l_681 = &l_682;
                int32_t ***l_687 = &l_44;
                int32_t *** const *l_686 = &l_687;
                (*l_602) = 0x0.BF6F83p-85;
                for (l_72.f2 = (-7); (l_72.f2 != 25); l_72.f2 += 8)
                { /* block id: 417 */
                    const uint16_t l_657 = 3U;
                    struct S2 *l_665 = &l_526;
                    union U3 *l_694 = &l_682;
                    if ((p_33 && ((int16_t)((int16_t)((uint32_t)l_657 + (uint32_t)((uint16_t)(65535U <= ((void*)0 != l_660)) - (uint16_t)(~(((uint16_t)l_657 >> (uint16_t)((l_665 != (void*)0) ^ (((func_64(l_666) <= 0xE549) | (*l_620)) == 0x889D))) < p_33)))) % (int16_t)4) << (int16_t)(*l_620))))
                    { /* block id: 418 */
                        uint32_t l_676 = 1U;
                        (*l_620) = (((void*)0 == l_667) ^ p_33);
                        (*l_602) = (*l_620);
                        (*l_620) = ((uint16_t)(4294967295U && ((l_665 != l_665) | p_33)) % (uint16_t)((int16_t)__builtin_bswap32(p_33) % (int16_t)((int32_t)((uint16_t)l_676 - (uint16_t)(+p_33)) + (int32_t)0xEDC70967)));
                    }
                    else
                    { /* block id: 422 */
                        return l_678;
                    }
                    (*l_389) = p_33;
                    for (l_526.f1 = (-28); (l_526.f1 <= 60); l_526.f1++)
                    { /* block id: 428 */
                        union U3 **l_683 = &l_681;
                        int32_t ***l_685 = &l_666;
                        int32_t *** const *l_684 = &l_685;
                        (*l_683) = l_681;
                        l_686 = l_684;
                        /* statement id: 430 */
                        assert (l_686 == &l_685);
                        (*l_620) = (p_33 ^ (0x2691 > ((int32_t)l_657 + (int32_t)((*l_389) != ((int16_t)p_33 >> (int16_t)0)))));
                        (*l_44) = (*l_626);
                    }
                    (*l_620) = (4294967288U < (4294967292U < (((1U && 0xA84A4CF5) & (((uint16_t)((&l_678 == (void*)0) < func_64(&l_45)) << (uint16_t)2) <= (l_694 != (void*)0))) <= p_33)));
                }
                /* facts after for loop */
                //assert (l_686 == dangling || l_686 == &l_687);
            }
            (*l_626) = (*l_44);
        }
        /* facts after branching */
        assert (l_45 == 0 || l_45 == &l_46);
    }
    /* facts after branching */
    assert (l_45 == 0 || l_45 == &l_46);
    return l_695;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** const  func_37(const int32_t  p_38, union U3  p_39, uint32_t  p_40)
{ /* block id: 275 */
    int32_t l_460 = 0x2BFCDB38;
    struct S1 **** const *l_461 = (void*)0;
    int32_t *l_477 = (void*)0;
    int32_t **l_476 = &l_477;
    struct S2 **l_486 = (void*)0;
    uint32_t l_492 = 0U;
    struct S0 l_504 = {0xFF1F7D47,0x2.10BDACp+76,0x5A6EB08D};
    int32_t ** const l_510 = (void*)0;
    if (((uint16_t)p_40 % (uint16_t)l_460))
    { /* block id: 276 */
        struct S1 ***l_464 = (void*)0;
        struct S1 ****l_463 = &l_464;
        struct S1 **** const *l_462 = &l_463;
        int32_t l_465 = 0x00DD55F4;
        int32_t *l_466 = &l_460;
        l_462 = l_461;
        /* statement id: 277 */
        assert (l_462 == 0);
        (*l_466) = l_465;
        (*l_466) = ((1 == 0x5E64348B) | func_64(&l_466));
    }
    else
    { /* block id: 280 */
        union U3 l_468 = {-1};
        union U3 *l_467 = &l_468;
        union U3 **l_469 = &l_467;
        int32_t *l_472 = &l_460;
        int32_t * const *l_471 = &l_472;
        int32_t * const **l_470 = &l_471;
        int32_t ****l_473 = (void*)0;
        float *l_479 = &l_468.f1;
        struct S2 *l_491 = (void*)0;
lbl_500:
        (*l_469) = l_467;
        l_470 = l_470;
lbl_501:
        (*l_479) = ((float)(l_460 >= (((-0x1.4p+1) > (func_64(l_476) != (__builtin_clz(p_40) <= (***l_470)))) < (+(0x1.5p+1 != ((**l_471) < p_40))))) - (float)p_38);
        /* statement id: 283 */
                for (p_40 = 3; (p_40 != 53); p_40 += 5)
        { /* block id: 286 */
            struct S2 l_490 = {0,4294967295U,0U};
            struct S2 *l_489 = &l_490;
            struct S0 l_505 = {1,0x7.F6BD6Bp-99,0xE914F0B8};
            for (l_468.f0 = (-1); (l_468.f0 > 5); ++l_468.f0)
            { /* block id: 289 */
                int16_t l_488 = (-1);
                float l_499 = 0x3.29274Ep+23;
                float *l_498 = &l_499;
                for (l_460 = 0; (l_460 == (-24)); --l_460)
                { /* block id: 292 */
                    struct S2 ***l_487 = &l_486;
                    (*l_487) = l_486;
                    p_39.f1 = (*l_472);
                    /* statement id: 294 */
                                        if (l_488)
                        break;
                    l_491 = l_489;
                    /* statement id: 296 */
                    assert (l_491 == &l_490);
                }
                (*l_498) = (((l_492 < ((((l_490.f0 < (*l_472)) > (((-0x10.5p-1) > (((float)((+(((float)l_490.f0 - (float)((0x9.B64202p+9 <= p_38) <= p_39.f1)) == (0xF.D1F99Bp+93 <= 0x6.075F8Ep-41))) < (-0x1.7p-1)) + (float)p_39.f0) == 0x6.Bp+1)) == 0xA.4970F5p+29)) < p_38) > p_40)) != l_490.f1) == l_488);
                if (l_492)
                    goto lbl_500;
                //assert (l_491 == 0 || l_491 == dangling);
            }
            /* facts after for loop */
                        //assert (l_491 == &l_490 || l_491 == 0 || l_491 == dangling);
            if (l_490.f0)
                goto lbl_501;
            //assert (l_491 == 0 || l_491 == dangling);
            (*l_479) = ((float)(0x2.F1C74Dp-50 != (p_39.f0 > (func_64(&l_477) == (l_490.f2 >= (((float)((float)(l_490.f1 <= p_39.f1) - (float)p_39.f0) - (float)p_39.f1) >= 0x7.BE3B21p-32))))) + (float)p_40);
            /* statement id: 302 */
                    }
    }
    (*l_476) = (*l_476);
    return l_510;
    /* statement id: 306 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U3  func_41(int32_t ** p_42, struct S1  p_43)
{ /* block id: 241 */
    int32_t l_404 = 6;
    union U3 l_410 = {0xCDEC75F1};
    union U3 *l_409 = &l_410;
    struct S1 l_415 = {14468,-0,-52};
    struct S1 *l_414 = &l_415;
    struct S1 **l_413 = &l_414;
    int32_t *l_452 = &l_404;
    int32_t **l_451 = &l_452;
    struct S2 *l_455 = (void*)0;
    struct S2 **l_456 = &l_455;
    union U3 l_457 = {0xDBA4F410};
    for (l_404 = 3; (l_404 <= 1); l_404--)
    { /* block id: 244 */
        float l_408 = 0x4.E07FD6p+81;
        float *l_407 = &l_408;
        union U3 **l_411 = &l_409;
        (*l_407) = 0x3.974936p+49;
        (*l_411) = l_409;
    }
    if (l_404)
    { /* block id: 248 */
        int32_t *l_412 = &l_404;
        const struct S1 *l_418 = &l_415;
        const struct S1 **l_417 = &l_418;
        const struct S1 ***l_416 = &l_417;
        (*p_42) = l_412;
        /* statement id: 249 */
        //assert (l_45 == &l_404);
        (*l_416) = l_413;
        /* statement id: 250 */
        assert (l_417 == &l_414);
    }
    else
    { /* block id: 251 */
        union U3 l_427 = {0x8A5F0AE9};
        int32_t l_453 = 0x03B9F7BD;
        float *l_454 = &l_427.f1;
        (*p_42) = (void*)0;
        /* statement id: 252 */
        //assert (l_45 == 0);
        for (l_404 = (-10); (l_404 <= (-24)); l_404--)
        { /* block id: 255 */
            uint32_t l_423 = 0xE936A677;
            struct S0 l_444 = {0xBC32C68F,0x1.65BDC4p-64,0xBAB2BB56};
            struct S0 *l_443 = &l_444;
            struct S1 *** const *l_447 = (void*)0;
            if ((((l_423 > ((void*)0 != &p_43)) ^ (!p_43.f0)) > ((int16_t)1 - (int16_t)p_43.f2)))
            { /* block id: 256 */
                return l_427;
                /* statement id: 257 */
                            }
            else
            { /* block id: 258 */
                int32_t *l_442 = &l_404;
                if (__builtin_ctzll((p_43.f2 & ((int16_t)((uint16_t)l_415.f0 << (uint16_t)((uint16_t)((int32_t)0xFA48EE69 + (int32_t)l_423) << (uint16_t)0)) + (int16_t)((((int16_t)((uint16_t)l_423 << (uint16_t)p_43.f1) << (int16_t)p_43.f0) == l_423) > ((uint16_t)p_43.f1 << (uint16_t)11))))))
                { /* block id: 259 */
                    (*p_42) = l_442;
                    /* statement id: 260 */
                    //assert (l_45 == &l_404);
                }
                else
                { /* block id: 261 */
                    const struct S0 *l_446 = &l_444;
                    const struct S0 **l_445 = &l_446;
                    struct S1 ***l_450 = (void*)0;
                    struct S1 ****l_449 = &l_450;
                    struct S1 *****l_448 = &l_449;
                    (*l_445) = l_443;
                    if ((*l_442))
                        continue;
                    (*l_448) = l_447;
                    /* statement id: 264 */
                    assert (l_449 == 0);
                }
                /* facts after branching */
                //assert (l_45 == 0 || l_45 == &l_404);
                (*p_42) = (*p_42);
                (*p_42) = (*p_42);
            }
            /* facts after branching */
            //assert (l_45 == 0 || l_45 == &l_404);
            return l_427;
            /* statement id: 269 */
            //assert (l_45 == 0 || l_45 == dangling);
                    }
        (*l_454) = (p_43.f1 >= ((p_43.f1 != l_427.f0) == ((l_427.f0 > l_427.f0) == ((func_64(l_451) < ((l_453 <= ((**l_451) >= p_43.f0)) != (*l_452))) <= p_43.f0))));
        /* statement id: 271 */
            }
    /* facts after branching */
    //assert (l_45 == 0 || l_45 == &l_404);
    (*l_456) = l_455;
    return l_457;
    /* statement id: 274 */
    //assert (l_45 == 0 || l_45 == dangling);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_47(struct S2  p_48, int32_t * p_49, int32_t  p_50, int32_t * p_51, const int32_t ** p_52)
{ /* block id: 238 */
    float l_402 = (-0x2.4p-1);
    float *l_401 = &l_402;
    struct S1 l_403 = {22803,-1,-23};
    (*l_401) = ((float)0x6.9B0C5Ap+60 - (float)__builtin_clz((-(uint16_t)((uint32_t)__builtin_popcountll(p_48.f0) + (uint32_t)((uint16_t)65535U << (uint16_t)9)))));
    return l_403;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_53(struct S1  p_54, struct S0  p_55, const struct S0  p_56, const int16_t  p_57, int32_t ** p_58)
{ /* block id: 165 */
    int32_t l_273 = 0x410F041E;
    struct S1 l_275 = {7028,-1,56};
    struct S1 *l_274 = &l_275;
    int32_t *l_292 = (void*)0;
    int32_t **l_291 = &l_292;
    int32_t ***l_290 = &l_291;
    int32_t ****l_289 = &l_290;
    union U3 *l_340 = (void*)0;
    union U3 **l_339 = &l_340;
    union U3 ***l_379 = &l_339;
    struct S2 l_388 = {-2,0x30779B6E,4294967295U};
    if (l_273)
    { /* block id: 166 */
        struct S1 **l_276 = &l_274;
        float l_279 = 0xD.4F7FA5p-45;
        float *l_278 = &l_279;
        (*l_276) = l_274;
        (*l_278) = (+p_56.f0);
    }
    else
    { /* block id: 169 */
        struct S0 l_285 = {9,-0x2.5p-1,0U};
        const struct S0 *l_284 = &l_285;
        const struct S0 **l_283 = &l_284;
        const struct S0 ***l_282 = &l_283;
        const struct S0 ****l_281 = &l_282;
        struct S2 l_294 = {0x261E8159,0U,0x52917B7F};
        union U3 l_385 = {8};
        union U3 *l_384 = &l_385;
        int32_t l_387 = 1;
        int32_t *l_386 = &l_387;
        if (((~((l_281 == (void*)0) != (((int16_t)(-5) >> (int16_t)8) == p_55.f2))) & 0x7F0F52E0))
        { /* block id: 170 */
            int32_t *l_288 = (void*)0;
            int32_t *****l_293 = &l_289;
            (*p_58) = l_288;
            /* statement id: 171 */
            //assert (l_45 == 0);
            (*l_293) = l_289;
            return l_294;
        }
        else
        { /* block id: 174 */
            int32_t l_297 = 0x7A73CAB9;
            float l_326 = 0x5.79E97Ep-63;
            float *l_325 = &l_326;
            for (l_294.f0 = 0; (l_294.f0 <= (-6)); l_294.f0 -= 6)
            { /* block id: 177 */
                if (l_297)
                    break;
            }
            for (l_294.f0 = 0; (l_294.f0 != 8); ++l_294.f0)
            { /* block id: 182 */
                int32_t l_301 = 0xF4A132B8;
                int32_t *l_300 = &l_301;
                int32_t l_320 = 0x42FEDE26;
                (**l_290) = l_300;
                /* statement id: 183 */
                assert (l_292 == &l_301);
                for (l_297 = 26; (l_297 <= (-19)); l_297 -= 4)
                { /* block id: 186 */
                    int32_t l_307 = 0;
                    int32_t *l_306 = &l_307;
                    for (l_301 = 0; (l_301 != 1); l_301++)
                    { /* block id: 189 */
                        int32_t l_314 = (-8);
                        struct S0 *l_319 = &l_285;
                        struct S0 **l_318 = &l_319;
                        struct S0 ***l_317 = &l_318;
                        l_306 = (*p_58);
                        /* statement id: 190 */
                        //assert (l_306 == &l_46);
                        (*l_291) = (*p_58);
                        /* statement id: 191 */
                        //assert (l_292 == &l_46);
                        l_320 = (0x56D6 > ((int32_t)((int16_t)((*l_306) ^ ((uint32_t)l_314 - (uint32_t)__builtin_ctzll((((0xAB481776 < ((int16_t)p_55.f2 << (int16_t)(l_317 != (*l_281)))) == 0x9E1F) | 0x7957)))) >> (int16_t)p_56.f2) + (int32_t)(*l_300)));
                    }
                    /* facts after for loop */
                    //assert (l_306 == &l_46 || l_306 == &l_307);
                }
                /* facts after for loop */
                //assert (l_292 == &l_46 || l_292 == &l_301);
            }
            /* facts after for loop */
            //assert (l_292 == &l_46 || l_292 == dangling || l_292 == 0);
            (*l_325) = ((p_56.f1 < (((p_56.f0 > (p_54.f0 <= (l_297 == (-0x6.Ap+1)))) == ((float)(p_54.f2 == (((float)(0x3.C17A10p+26 > ((p_54.f2 > (p_57 >= 0x2.0E696Ep-83)) != 0x1.905584p-30)) + (float)(-0x6.1p+1)) <= 0x9.6638CAp+50)) - (float)l_297)) != p_57)) != p_57);
        }
        /* facts after branching */
        //assert (l_292 == &l_46 || l_292 == dangling || l_292 == 0);
        (**p_58) = (0x04CFCC2D ^ ((__builtin_bswap64((((func_64(p_58) >= (-10)) | ((-(uint32_t)(l_294.f2 | p_54.f0)) <= ((-1) > 6U))) & 1)) >= p_57) || 0x11B20A92));
        for (l_294.f0 = (-3); (l_294.f0 <= 3); l_294.f0++)
        { /* block id: 201 */
            uint16_t l_338 = 0x5604;
            float *l_341 = (void*)0;
            float l_343 = 0x1.6p-1;
            float *l_342 = &l_343;
            float l_365 = (-0x1.0p+1);
            int32_t **l_375 = (void*)0;
            uint16_t l_378 = 0x302B;
            (*l_342) = (((((*p_58) != (void*)0) == ((float)(0x1.53B091p-41 != (-0x10.6p-1)) + (float)(((float)l_285.f0 - (float)(((float)((float)0x7.E1C321p+26 - (float)l_338) + (float)p_55.f1) == ((void*)0 != l_339))) < 0x1.Ep+1))) != p_54.f1) > p_56.f2);
            if (((int16_t)p_54.f2 + (int16_t)(-1)))
            { /* block id: 203 */
                struct S1 **l_346 = &l_274;
                int32_t l_366 = 0x5133C6B0;
                int32_t **l_374 = &l_292;
                (*l_346) = &p_54;
                /* statement id: 204 */
                assert (l_274 == &p_54);
                for (l_285.f2 = 0; (l_285.f2 >= 6); l_285.f2 += 3)
                { /* block id: 207 */
                    int16_t l_364 = 2;
                    struct S2 *l_369 = &l_294;
                    int32_t *** const *l_371 = &l_290;
                    if ((((int16_t)((((!p_57) <= ((p_56.f2 <= (((uint16_t)((uint16_t)(((int16_t)((uint32_t)((int16_t)((int16_t)(l_364 && (((l_338 ^ l_366) <= (p_56.f2 == p_55.f2)) != ((uint16_t)p_54.f0 - (uint16_t)l_338))) << (int16_t)15) >> (int16_t)6) - (uint32_t)l_338) << (int16_t)p_56.f0) && 1U) << (uint16_t)0) >> (uint16_t)6) == 0x15F6)) >= (-1))) | l_364) >= (-1)) << (int16_t)9) > l_294.f2))
                    { /* block id: 208 */
                        struct S2 **l_370 = &l_369;
                        (*l_370) = l_369;
                    }
                    else
                    { /* block id: 210 */
                        if (l_364)
                            break;
                        (*l_342) = (l_371 == (void*)0);
                    }
                    if (__builtin_ia32_crc32qi(p_55.f2, l_285.f0))
                    { /* block id: 214 */
                        (*l_342) = p_55.f2;
                        return l_294;
                    }
                    else
                    { /* block id: 217 */
                        (*l_342) = p_57;
                        (*l_342) = ((float)func_64(l_374) + (float)(l_294.f2 > func_64(l_375)));
                    }
                }
                (*l_342) = (p_57 >= ((float)l_378 + (float)p_56.f1));
            }
            else
            { /* block id: 223 */
                const union U3 *l_383 = (void*)0;
                const union U3 **l_382 = &l_383;
                l_379 = (void*)0;
                /* statement id: 224 */
                assert (l_379 == 0);
                if (l_285.f2)
                    continue;
                for (l_285.f2 = 0; (l_285.f2 == 58); ++l_285.f2)
                { /* block id: 228 */
                    (**p_58) = (p_54.f1 <= (l_382 != (void*)0));
                    l_384 = l_384;
                }
            }
            (*l_291) = l_386;
            /* statement id: 233 */
            assert (l_292 == &l_387);
        }
        /* facts after for loop */
        assert (l_274 == &l_275 || l_274 == &p_54);
        //assert (l_292 == &l_387 || l_292 == &l_46 || l_292 == dangling || l_292 == 0);
        assert (l_379 == 0 || l_379 == &l_339);
        (*l_291) = (*p_58);
        /* statement id: 235 */
        //assert (l_292 == &l_46);
    }
    /* facts after branching */
    assert (l_274 == &l_275 || l_274 == &p_54);
    //assert (l_292 == &l_46 || l_292 == 0);
    assert (l_379 == 0 || l_379 == &l_339);
    return l_388;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_59(uint32_t  p_60, int32_t ** p_61, uint32_t  p_62, const union U3  p_63)
{ /* block id: 143 */
    struct S0 ***l_239 = (void*)0;
    struct S0 ****l_240 = &l_239;
    int32_t l_250 = (-1);
    int32_t *l_268 = (void*)0;
    int32_t * const *l_271 = &l_268;
    int32_t * const **l_270 = &l_271;
    struct S1 l_272 = {17655,-1,25};
    (*p_61) = (*p_61);
    (*l_240) = l_239;
    for (p_60 = 0; (p_60 == 16); p_60 += 4)
    { /* block id: 148 */
        struct S0 l_245 = {1,0x8.C94198p-30,4294967295U};
        int32_t *l_269 = &l_250;
        if (((int16_t)(p_62 != (func_64(func_66(l_245, (*p_61), l_245)) < ((uint16_t)p_62 + (uint16_t)((uint16_t)l_250 % (uint16_t)((int16_t)p_63.f0 >> (int16_t)13))))) % (int16_t)p_63.f0))
        { /* block id: 149 */
            (**p_61) = ((int16_t)p_60 << (int16_t)12);
        }
        else
        { /* block id: 151 */
            int32_t l_255 = 0x0A848104;
            if (((l_255 >= ((uint32_t)0x89BE62DB - (uint32_t)((5U || l_245.f0) ^ ((**p_61) < (((int16_t)(__builtin_parityll(p_63.f0) != __builtin_clz(p_60)) >> (int16_t)l_245.f2) > 0x1905))))) || l_255))
            { /* block id: 152 */
                int32_t l_262 = 0x8359BE37;
                float l_267 = 0xE.AC7219p-40;
                float *l_266 = &l_267;
                (*l_266) = (((float)l_262 + (float)((float)0x0.Ep+1 + (float)p_63.f0)) != (-(float)0x7.9p-1));
            }
            else
            { /* block id: 154 */
                (**p_61) = (l_268 != (void*)0);
            }
            if (l_255)
                break;
            (*p_61) = &l_250;
            /* statement id: 158 */
            //assert (l_71 == &l_250);
        }
        (*p_61) = l_269;
        /* statement id: 160 */
        //assert (l_71 == &l_250);
        (*l_269) = (*l_269);
    }
    /* facts after for loop */
    //assert (l_71 == &l_250 || l_71 == &l_46);
    (*l_270) = &l_268;
    return l_272;
    /* statement id: 164 */
    //assert (l_71 == dangling || l_71 == &l_46);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_64(int32_t ** p_65)
{ /* block id: 103 */
    const uint32_t l_169 = 4294967294U;
    int32_t **l_179 = (void*)0;
    struct S0 **l_180 = (void*)0;
    int32_t l_181 = 0xF7827581;
    union U3 l_223 = {0x96149393};
    union U3 * const l_222 = &l_223;
    if (((!l_169) > (l_169 > 0x7C61DA59)))
    { /* block id: 104 */
        int32_t l_173 = 0xD58AA24F;
        int32_t *l_172 = &l_173;
        if (((int16_t)l_169 + (int16_t)l_169))
        { /* block id: 105 */
            int32_t **l_174 = &l_172;
            uint32_t l_177 = 4294967291U;
            uint16_t l_178 = 0x545A;
            (*l_174) = l_172;
            for (l_173 = (-1); (l_173 >= 3); l_173++)
            { /* block id: 109 */
                l_178 = (0x9B2D93A8 < (l_177 > 0x91DEB0A8));
                (*l_174) = &l_173;
            }
            (**l_174) = ((&l_172 == l_179) > (65535U && (**l_174)));
        }
        else
        { /* block id: 114 */
            struct S1 l_183 = {9432,1,16};
            struct S1 * const l_182 = &l_183;
            struct S1 *l_185 = &l_183;
            struct S1 **l_184 = &l_185;
            l_181 = (l_180 != l_180);
            (*l_184) = l_182;
        }
        (*l_172) = ((+((void*)0 == l_180)) > __builtin_parity((*l_172)));
    }
    else
    { /* block id: 119 */
        int16_t l_189 = 0x694C;
        float l_194 = (-0x2.Ep-1);
        float *l_193 = &l_194;
        int32_t *l_195 = &l_181;
        (*l_193) = ((float)l_169 + (float)(l_181 <= (l_189 != ((l_189 != (0x1.1C1CC9p+50 == (((+(((float)l_169 - (float)l_189) > l_189)) >= (l_181 >= l_189)) > l_181))) != l_189))));
        (*l_195) = l_189;
        return l_169;
    }
    if (((uint16_t)l_169 >> (uint16_t)6))
    { /* block id: 124 */
        uint32_t l_198 = 9U;
        return l_198;
    }
    else
    { /* block id: 126 */
        int32_t l_201 = 1;
        uint32_t l_204 = 0x3E7769F7;
        const float l_206 = 0x0.Ep+1;
        const float *l_205 = &l_206;
        union U3 l_212 = {0x34D88E7D};
        union U3 *l_211 = &l_212;
        union U3 **l_213 = &l_211;
        l_201 = ((uint32_t)(l_201 & ((uint16_t)((l_181 >= l_201) < (l_204 == l_204)) - (uint16_t)(l_205 != (void*)0))) % (uint32_t)((int32_t)l_201 % (int32_t)(((uint16_t)(l_201 > 0) >> (uint16_t)5) || 0x0889BAE7)));
        (*l_213) = l_211;
        for (l_212.f0 = (-5); (l_212.f0 <= 2); l_212.f0 += 1)
        { /* block id: 131 */
            int16_t l_218 = 1;
            int32_t *l_219 = &l_181;
            const union U3 *l_225 = &l_212;
            const union U3 **l_224 = &l_225;
            (*l_219) = ((uint16_t)__builtin_ctzl(l_201) << (uint16_t)(l_218 ^ (l_169 != l_218)));
            (*l_219) = ((65529U > (__builtin_ctzl((((uint16_t)(&p_65 == (void*)0) >> (uint16_t)__builtin_popcountl((*l_219))) < (*l_219))) != ((*l_219) && (((void*)0 != &l_201) || 1U)))) == (*l_219));
            (*l_224) = l_222;
            /* statement id: 134 */
            assert (l_225 == &l_223);
        }
    }
    for (l_223.f0 = 0; (l_223.f0 > 26); l_223.f0 += 3)
    { /* block id: 139 */
        int16_t l_228 = 5;
        float *l_229 = (void*)0;
        float l_231 = 0x3.1B4F9Ap-42;
        float *l_230 = &l_231;
        (*l_230) = (l_228 <= l_228);
    }
    return l_169;
}


/* ------------------------------------------ */
/* 
 * reads : l_46
 * writes:
 */
static int32_t ** func_66(struct S0  p_67, int32_t * p_68, struct S0  p_69)
{ /* block id: 41 */
    int32_t **l_78 = (void*)0;
    int32_t ***l_79 = &l_78;
    int32_t l_148 = 0x157731B4;
    int32_t *l_147 = &l_148;
    int32_t **l_146 = &l_147;
    int32_t **l_162 = &l_147;
    int32_t **l_163 = &l_147;
    int32_t **l_164 = &l_147;
    int32_t **l_165 = &l_147;
    int32_t **l_166 = &l_147;
    int32_t **l_167 = (void*)0;
    for (p_67.f2 = (-15); (p_67.f2 <= 6); p_67.f2 += 6)
    { /* block id: 44 */
        const int32_t l_77 = 3;
        const int32_t *l_76 = &l_77;
        const int32_t **l_75 = &l_76;
        if ((*p_68))
            break;
        (*l_75) = p_68;
        /* statement id: 46 */
        //assert (l_76 == &l_46 || l_76 == &l_250);
    }
    (*l_79) = l_78;
    if (__builtin_parityl(p_67.f2))
    { /* block id: 49 */
        int32_t l_103 = 0x5B495AE8;
        int32_t *l_102 = &l_103;
        int32_t **l_101 = &l_102;
        int32_t l_116 = 0x3A29C5D0;
        int32_t l_118 = 0xB99CB9CE;
        int32_t **l_149 = (void*)0;
        for (p_69.f2 = 0; (p_69.f2 != 27); ++p_69.f2)
        { /* block id: 52 */
            (*l_79) = &p_68;
            /* statement id: 53 */
            assert (l_78 == &p_68);
        }
        /* facts after for loop */
        assert (l_78 == &p_68 || l_78 == 0);
        if ((+0x942A26B1))
        { /* block id: 55 */
            float l_104 = 0x9.0p+1;
            float l_115 = 0x8.Fp+1;
            int32_t l_117 = (-1);
            int32_t **l_144 = &l_102;
            int32_t **l_145 = &l_102;
            for (p_67.f2 = 28; (p_67.f2 <= 44); p_67.f2 += 2)
            { /* block id: 58 */
                int32_t l_91 = (-6);
                int32_t *l_90 = &l_91;
            }
            (*l_101) = &l_117;
            /* statement id: 86 */
            assert (l_102 == &l_117);
            return l_149;
            /* statement id: 87 */
            //assert (func_66_rv == 0);
        }
        else
        { /* block id: 88 */
            struct S0 l_151 = {-1,0x5.D1F826p-55,0x14D024A4};
            struct S0 *l_150 = &l_151;
            struct S0 **l_152 = &l_150;
            (*l_147) = (*p_68);
            (*l_152) = l_150;
            for (p_67.f2 = 11; (p_67.f2 <= 28); p_67.f2++)
            { /* block id: 93 */
                int32_t **l_155 = (void*)0;
                (*l_101) = (*l_101);
                (*l_79) = &p_68;
                /* statement id: 95 */
                assert (l_78 == &p_68);
                return l_155;
                /* statement id: 96 */
                //assert (func_66_rv == 0);
            }
        }
    }
    else
    { /* block id: 99 */
        int32_t **l_158 = &l_147;
        float *l_159 = (void*)0;
        float l_161 = 0x0.2p+1;
        float *l_160 = &l_161;
        (*l_160) = (((**l_146) < ((float)(0xC.DCA0F1p+32 <= (l_158 != (void*)0)) + (float)0x1.4p+1)) != __builtin_clzl((**l_158)));
    }
    /* facts after branching */
    assert (l_78 == &p_68 || l_78 == 0);
    return l_167;
    /* statement id: 102 */
    //assert (func_66_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 181
   depth: 1, occurrence: 16
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 20

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 228
   depth: 2, occurrence: 40
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 5
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 11, occurrence: 4
   depth: 12, occurrence: 9
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 225

XXX times a variable address is taken: 202
XXX times a pointer is dereferenced on RHS: 82
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 122
breakdown:
   depth: 1, occurrence: 109
   depth: 2, occurrence: 13
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 556

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 481
   level: 2, occurrence: 104
   level: 3, occurrence: 9
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 119
XXX number of pointers point to scalars: 69
XXX number of pointers point to structs: 27
XXX percent of pointers has null in alias set: 21.8
XXX average alias set size: 1.17

XXX times a non-volatile is read: 697
XXX times a non-volatile is write: 311
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 193
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 42
   depth: 2, occurrence: 39
   depth: 3, occurrence: 32
   depth: 4, occurrence: 24
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 19.8
XXX percentage an existing variable is used: 80.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

