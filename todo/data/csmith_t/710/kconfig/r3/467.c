/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1799354544
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
};

struct S1 {
   int16_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   signed f3 : 22;
   unsigned f4 : 31;
   uint32_t  f5;
   int16_t  f6;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 0x45307222;
static int16_t g_5 = 0xB1A9;
static struct S0 g_88 = {0xC16B31B7};
static int32_t g_105 = 0xCCDDECA6;
static int16_t g_117 = 0x63BB;
static int32_t g_140 = 1;
static uint16_t g_145 = 0xCE40;
static int16_t g_147 = 0xB125;
static int16_t g_148 = 0xD46A;
static uint16_t g_165 = 0x1020;
static int16_t g_167 = (-5);
static uint16_t g_168 = 65535U;
static struct S0 g_189 = {-4};
static struct S1 g_253 = {0xE74C,0xF9A101D9,5U,101,26034,4294967288U,-10};
static struct S0 g_379 = {7};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_29(void);
static struct S0  func_32(uint32_t  p_33, struct S1  p_34);
static uint16_t  func_36(int32_t  p_37, int32_t  p_38, int16_t  p_39);
static int16_t  func_42(struct S0  p_43, int32_t  p_44, struct S0  p_45, uint16_t  p_46);
static struct S0  func_47(uint32_t  p_48, struct S0  p_49);
static struct S0  func_52(struct S0  p_53, uint32_t  p_54, int16_t  p_55, uint32_t  p_56, uint16_t  p_57);
static uint16_t  func_63(int32_t  p_64);
static uint16_t  func_84(int32_t  p_85, uint32_t  p_86);
static int16_t  func_91(uint16_t  p_92, uint16_t  p_93, struct S0  p_94, uint16_t  p_95);
static uint32_t  func_99(uint16_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_5 g_88 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_189 g_168 g_253 g_147 g_379
 * writes: g_3 g_88 g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167 g_253.f3 g_145 g_253
 */
static uint16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_62 = 1U;
    struct S1 l_391 = {0,4294967295U,0xE587C2F7,15,6097,0x5FC68337,0x1C1F};
    struct S0 l_395 = {-2};
    for (g_3 = 0; (g_3 <= (-3)); g_3 -= 1)
    { /* block id: 39 */
        uint32_t l_35 = 1U;
        struct S0 l_58 = {-7};
        uint16_t l_61 = 65532U;
        l_395 = func_32(((l_35 >= func_36(((int16_t)func_42(func_47(((int16_t)l_35 << (int16_t)3), func_52(l_58, l_58.f0, ((g_3 <= 8) ^ (((__builtin_ctzl(l_35) == ((uint16_t)((__builtin_clz(l_35) ^ 0x6407) >= l_61) % (uint16_t)l_62)) ^ 0xFD17) ^ 0xA828C040)), g_3, l_58.f0)), g_3, g_379, g_379.f0) + (int16_t)g_379.f0), l_62, g_5)) >= 0x51597113), l_391);
    }
    return g_148;
}


/* ------------------------------------------ */
/* 
 * reads : g_117
 * writes:
 */
static struct S0  func_32(uint32_t  p_33, struct S1  p_34)
{ /* block id: 200 */
    uint32_t l_392 = 0x59E5D14B;
    int32_t l_393 = 9;
    struct S0 l_394 = {0xCF4C9835};
    l_393 = (g_117 <= ((p_34.f6 && (__builtin_clzl(p_34.f0) | p_34.f5)) == l_392));
    return l_394;
}


/* ------------------------------------------ */
/* 
 * reads : g_253.f0
 * writes:
 */
static uint16_t  func_36(int32_t  p_37, int32_t  p_38, int16_t  p_39)
{ /* block id: 197 */
    struct S0 l_390 = {-2};
    l_390 = l_390;
    return g_253.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_253 g_3 g_5 g_88.f0 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_88 g_189 g_168 g_147
 * writes: g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167 g_88 g_253.f3 g_145 g_253
 */
static int16_t  func_42(struct S0  p_43, int32_t  p_44, struct S0  p_45, uint16_t  p_46)
{ /* block id: 186 */
    struct S1 l_380 = {0xD642,1U,3U,-1223,2522,4294967295U,0x1E4A};
    struct S0 l_381 = {0x2A289612};
    uint32_t l_389 = 0xC15FA3F5;
    l_380 = g_253;
    p_44 = g_253.f4;
    if ((func_91(g_253.f4, (p_43.f0 >= g_253.f5), l_381, p_43.f0) > g_253.f1))
    { /* block id: 189 */
        l_381 = g_88;
    }
    else
    { /* block id: 191 */
        int16_t l_382 = 0;
        p_45.f0 = l_382;
        return l_381.f0;
    }
    l_380.f3 = (p_45.f0 > ((uint16_t)((((uint16_t)__builtin_ctzll(p_46) % (uint16_t)(l_380.f5 | (__builtin_bswap64(func_63(p_46)) || ((int16_t)__builtin_ia32_crc32qi(l_389, l_381.f0) << (int16_t)13)))) & g_3) && 0xBD88) << (uint16_t)g_140));
    return g_253.f5;
}


/* ------------------------------------------ */
/* 
 * reads : g_253.f3 g_148 g_3 g_145 g_167 g_5 g_253.f0 g_88.f0 g_168 g_253.f6 g_253
 * writes: g_88.f0 g_168 g_253.f3
 */
static struct S0  func_47(uint32_t  p_48, struct S0  p_49)
{ /* block id: 166 */
    int16_t l_343 = (-2);
    int32_t l_350 = 0x55E3F350;
    uint32_t l_376 = 4294967295U;
    struct S0 l_378 = {0x96EC3B42};
    l_350 = (((((int32_t)(((uint32_t)__builtin_ctz((((uint16_t)(g_253.f3 | p_48) >> (uint16_t)10) < __builtin_clz(((int16_t)((uint32_t)p_49.f0 % (uint32_t)((int16_t)p_48 >> (int16_t)12)) << (int16_t)((l_343 == g_148) > ((uint16_t)0x323A - (uint16_t)(((((uint32_t)(g_3 < (((uint32_t)p_48 - (uint32_t)g_145) ^ g_167)) + (uint32_t)1U) != 2) & p_48) & 1))))))) + (uint32_t)p_49.f0) ^ l_343) + (int32_t)0x6675F6B8) >= 0x1C65) <= 0x0D36) ^ p_49.f0);
    if (g_253.f0)
    { /* block id: 168 */
        uint32_t l_354 = 0xB8B317F3;
        int32_t l_364 = 0x548AB624;
        for (g_88.f0 = 12; (g_88.f0 > 1); g_88.f0 -= 7)
        { /* block id: 171 */
            l_364 = (-(uint32_t)(l_354 | (~((uint16_t)(((uint16_t)0U >> (uint16_t)5) > ((int16_t)(((uint16_t)0xCC58 << (uint16_t)p_49.f0) > p_49.f0) >> (int16_t)10)) << (uint16_t)3))));
        }
    }
    else
    { /* block id: 174 */
        uint32_t l_374 = 1U;
        g_88.f0 = 0x224B2532;
        for (g_168 = 0; (g_168 != 20); g_168 += 5)
        { /* block id: 178 */
            uint32_t l_373 = 1U;
            struct S1 l_377 = {0xF9CA,0x6A1822A1,0x6F8766C3,1353,15164,4294967295U,-1};
            g_253.f3 = (g_253.f6 & ((uint32_t)((uint16_t)(p_49.f0 | (((int16_t)l_373 >> (int16_t)2) >= ((l_374 == g_3) < 6U))) >> (uint16_t)(-(int16_t)p_48)) - (uint32_t)(p_48 ^ p_48)));
            if (l_376)
                continue;
            l_377 = g_253;
            p_49.f0 = l_374;
        }
    }
    return l_378;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_3 g_88 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_189 g_168 g_253 g_147
 * writes: g_88 g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167 g_253.f3 g_145 g_253
 */
static struct S0  func_52(struct S0  p_53, uint32_t  p_54, int16_t  p_55, uint32_t  p_56, uint16_t  p_57)
{ /* block id: 40 */
    int32_t l_69 = 0x55A9D45C;
    struct S0 l_330 = {1};
    p_53.f0 = (((0x5DD6 >= func_63((((int16_t)((((uint16_t)__builtin_bswap32((l_69 <= g_5)) << (uint16_t)((int16_t)((uint32_t)((int32_t)(4294967290U != ((__builtin_ctzll(((uint32_t)p_56 - (uint32_t)((((int16_t)(((__builtin_bswap32(g_3) < (-1)) ^ 0x03AC) > 0U) >> (int16_t)15) || 0) || (-1)))) ^ p_56) < l_69)) % (int32_t)g_3) + (uint32_t)0x53593517) >> (int16_t)p_56)) != l_69) & g_3) >> (int16_t)p_57) > p_55))) | 4294967295U) != g_5);
    return l_330;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_3 g_88 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_189 g_168 g_253 g_147
 * writes: g_88 g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167 g_253.f3 g_145 g_253
 */
static uint16_t  func_63(int32_t  p_64)
{ /* block id: 41 */
    int32_t l_87 = 0x76079686;
    int16_t l_292 = 0x9430;
    struct S0 l_300 = {0xD73544DA};
    g_253.f3 = ((p_64 >= ((uint32_t)__builtin_popcountl(__builtin_ffs(g_5)) - (uint32_t)(((uint16_t)func_84(l_87, p_64) << (uint16_t)(((g_253.f1 == ((uint16_t)__builtin_ffsll(p_64) << (uint16_t)13)) != l_87) == 0x744A534B)) & 0x8E5AF4E9))) != p_64);
    for (g_145 = (-27); (g_145 <= 14); g_145 += 1)
    { /* block id: 132 */
        uint32_t l_285 = 0U;
        int32_t l_298 = 0x79CEF782;
        uint32_t l_314 = 0x387689AE;
        struct S0 l_319 = {0};
        int32_t l_329 = (-9);
        if (func_99(g_189.f0))
        { /* block id: 133 */
            int32_t l_276 = 1;
            if (((int32_t)((int32_t)(((int32_t)l_276 - (int32_t)((int16_t)0x78E6 - (int16_t)g_145)) <= (g_253.f0 < g_165)) - (int32_t)(((((l_276 > (~p_64)) ^ (((uint16_t)(~(((((uint32_t)(((g_253.f1 || g_105) == 1U) >= 0x370A9BE4) - (uint32_t)l_276) && 0U) == (-6)) > 2)) - (uint16_t)0xEBF7) ^ p_64)) ^ 0xA40B) || l_285) & p_64)) % (int32_t)3U))
            { /* block id: 134 */
                int32_t l_297 = 5;
                g_253 = g_253;
                l_298 = (-(uint32_t)((int16_t)((uint16_t)func_84(func_84((__builtin_clzl((l_276 < 1)) > ((p_64 > 0U) == (~func_91(((l_292 < ((uint16_t)((uint16_t)0x9F63 << (uint16_t)(g_253.f2 <= p_64)) - (uint16_t)l_297)) & g_117), g_145, g_189, p_64)))), l_285), g_145) >> (uint16_t)13) >> (int16_t)l_285));
            }
            else
            { /* block id: 137 */
                struct S0 l_299 = {0xE25318A6};
                g_88.f0 = func_99(g_147);
                g_88 = l_299;
                l_276 = ((__builtin_ffsl(l_276) ^ p_64) & g_253.f4);
                l_300 = g_88;
            }
        }
        else
        { /* block id: 143 */
            if ((((int16_t)l_285 >> (int16_t)5) ^ func_99((((uint32_t)(0xC847 | ((func_99(g_88.f0) && l_285) & l_87)) + (uint32_t)(((g_253.f1 || (g_5 == ((p_64 | 1) && g_253.f5))) & g_253.f4) <= 0x46CF)) < 0x3B8A))))
            { /* block id: 144 */
                return g_253.f2;
            }
            else
            { /* block id: 146 */
                if (g_253.f2)
                { /* block id: 147 */
                    if (((uint16_t)((int16_t)((uint16_t)p_64 << (uint16_t)0) - (int16_t)(((((-(int32_t)p_64) && ((int16_t)0xCE5C % (int16_t)(p_64 ^ (8U > l_314)))) >= ((int16_t)g_168 % (int16_t)((int16_t)g_148 >> (int16_t)(0x15ADF492 & l_314)))) == 0xE7B3C1AD) | 0xD2B9)) % (uint16_t)1U))
                    { /* block id: 148 */
                        g_253 = g_253;
                    }
                    else
                    { /* block id: 150 */
                        l_319 = l_300;
                    }
                }
                else
                { /* block id: 153 */
                    struct S1 l_320 = {-10,4294967293U,0x97FFBABD,1686,32450,0x3C0F87B1,0xCB9F};
                    g_88.f0 = 0x1585BA16;
                    if (p_64)
                        break;
                    g_253 = l_320;
                }
            }
        }
        l_319.f0 = ((p_64 > l_87) | ((uint16_t)((((uint32_t)func_84(((((uint16_t)g_3 + (uint16_t)((l_319.f0 != ((p_64 == (g_189.f0 >= 0)) != g_88.f0)) >= l_329)) && p_64) < p_64), g_253.f4) % (uint32_t)4294967295U) < g_253.f4) || p_64) - (uint16_t)1));
        g_253.f3 = 1;
    }
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads : g_88 g_3 g_5 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_189 g_168 g_253
 * writes: g_88 g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167
 */
static uint16_t  func_84(int32_t  p_85, uint32_t  p_86)
{ /* block id: 42 */
    int32_t l_96 = 0x16E5DCA5;
    struct S0 l_254 = {0x5FA7B2E7};
    g_88 = g_88;
    p_85 = (__builtin_popcountl(((int16_t)func_91(l_96, ((((uint32_t)0x84746BA8 + (uint32_t)g_88.f0) == func_99(l_96)) & (p_85 >= l_96)), l_254, (((int16_t)p_85 - (int16_t)g_253.f1) <= 0x99AD)) + (int16_t)g_253.f3)) < g_253.f6);
    return l_254.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_5 g_88.f0 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_88 g_189 g_168 g_253
 * writes: g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167
 */
static int16_t  func_91(uint16_t  p_92, uint16_t  p_93, struct S0  p_94, uint16_t  p_95)
{ /* block id: 123 */
    int16_t l_259 = 0x9765;
    uint16_t l_264 = 65535U;
    int32_t l_265 = 0x6E1E6A54;
    p_94.f0 = p_95;
    l_265 = ((((int32_t)l_259 % (int32_t)__builtin_ffs(p_92)) == func_99(((((func_99((((uint16_t)65531U % (uint16_t)((int16_t)(func_99(l_264) < __builtin_ctzl(g_5)) + (int16_t)(-6))) != p_93)) < p_95) ^ (-1)) || p_95) == (-8)))) > l_264);
    return g_140;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_5 g_88.f0 g_105 g_140 g_145 g_117 g_148 g_167 g_165 g_88 g_189 g_168 g_253
 * writes: g_105 g_117 g_147 g_148 g_165 g_168 g_189 g_167
 */
static uint32_t  func_99(uint16_t  p_100)
{ /* block id: 44 */
    int32_t l_101 = 0x262A889E;
    struct S0 l_102 = {0x4114ABDC};
    uint16_t l_239 = 9U;
    struct S1 l_251 = {0xF4E5,5U,4294967288U,-127,18597,0x14BD8925,-5};
    l_101 = (-4);
    l_102 = l_102;
    if ((l_102.f0 != g_3))
    { /* block id: 47 */
        struct S0 l_104 = {0xBB29A1B0};
        int32_t l_146 = 1;
        if (g_5)
        { /* block id: 48 */
            struct S0 l_103 = {0x596CDD17};
            l_104 = l_103;
            g_105 = l_103.f0;
            l_103.f0 = ((-(uint32_t)(65526U < (((int16_t)((uint16_t)((int32_t)g_88.f0 + (int32_t)((((uint16_t)l_104.f0 - (uint16_t)0x16AB) ^ (0x73F2 && (l_104.f0 & 0xD3A0))) >= (p_100 == (g_88.f0 || p_100)))) + (uint16_t)0x4C08) + (int16_t)g_88.f0) | 0x3F56D1B7))) > l_103.f0);
            g_117 = ((int16_t)l_102.f0 - (int16_t)g_88.f0);
        }
        else
        { /* block id: 53 */
            int32_t l_129 = 2;
            struct S1 l_142 = {0xF4DF,0xC948D72D,0x71054287,-649,34363,0U,-1};
            uint32_t l_177 = 0x1C48D970;
            int16_t l_214 = (-1);
            l_101 = ((l_104.f0 && (-1)) < ((p_100 < g_105) > (g_88.f0 > ((uint16_t)p_100 << (uint16_t)g_88.f0))));
            if (g_5)
            { /* block id: 55 */
                int32_t l_124 = 0x538C74B5;
                int32_t l_126 = (-2);
                struct S1 l_141 = {1,0x87B99205,0x34A3FD71,959,46139,0xA49CFF13,0x093E};
                l_104.f0 = ((((int16_t)(g_3 ^ l_124) >> (int16_t)9) ^ (~0x0BB395F0)) && p_100);
                l_124 = (((l_126 && (((uint16_t)l_129 >> (uint16_t)10) | p_100)) != ((int16_t)l_124 << (int16_t)((((int16_t)((uint16_t)(((p_100 == (((((int16_t)(((((uint32_t)l_126 % (uint32_t)(-5)) ^ g_88.f0) <= 0xDFFB) ^ 0x5E3CEA87) % (int16_t)0x3557) >= p_100) ^ 3U) >= p_100)) == p_100) < l_104.f0) << (uint16_t)7) + (int16_t)l_129) & g_140) > p_100))) & g_5);
                l_142 = l_141;
                for (l_104.f0 = 0; (l_104.f0 > 1); l_104.f0 += 5)
                { /* block id: 61 */
                    l_146 = ((p_100 > (p_100 & ((g_88.f0 && g_5) == (g_145 > p_100)))) | 0x01F99661);
                    g_147 = l_142.f0;
                }
            }
            else
            { /* block id: 65 */
                int16_t l_149 = 0x2775;
                int32_t l_166 = 0xE6F67040;
                g_148 = p_100;
                if (__builtin_ffs(p_100))
                { /* block id: 67 */
                    l_146 = l_149;
                }
                else
                { /* block id: 69 */
                    uint16_t l_162 = 2U;
                    g_165 = ((((int16_t)(((((4294967289U | (g_117 | ((((int32_t)((int32_t)g_140 + (int32_t)(((int16_t)(((uint16_t)((uint16_t)g_117 >> (uint16_t)0) - (uint16_t)g_105) & l_162) << (int16_t)__builtin_clzl(g_3)) != ((int16_t)(-10) << (int16_t)15))) + (int32_t)g_105) & l_162) & l_149))) >= p_100) && 0x3726) & g_148) || p_100) - (int16_t)g_140) > 0x89E7) || g_88.f0);
                    l_142.f3 = (l_166 || (p_100 > (g_167 <= p_100)));
                    return g_145;
                }
                g_168 = l_142.f6;
            }
            if (((uint16_t)g_148 + (uint16_t)((int32_t)__builtin_bswap32(((int32_t)__builtin_ffs(((int32_t)l_177 % (int32_t)g_105)) - (int32_t)(g_88.f0 | (((((p_100 != (p_100 ^ g_5)) == ((int16_t)((uint16_t)(g_5 && 0x6C974F60) - (uint16_t)0) + (int16_t)65535U)) && p_100) ^ 0x4505) >= (-1))))) % (int32_t)0x6844EC94)))
            { /* block id: 76 */
                uint32_t l_185 = 0xEC7EDD3F;
                int32_t l_186 = 0;
                if ((8 > ((int16_t)g_165 >> (int16_t)10)))
                { /* block id: 77 */
                    l_185 = (-(int16_t)0xA9AB);
                }
                else
                { /* block id: 79 */
                    struct S0 l_188 = {1};
                    if (p_100)
                    { /* block id: 80 */
                        struct S1 l_187 = {0xA258,4294967292U,4294967295U,-210,4112,0xE9429D60,0xDB9B};
                        l_186 = (0xFBB944C1 & (1U | p_100));
                        l_142 = l_187;
                        l_188 = g_88;
                        g_189 = l_102;
                    }
                    else
                    { /* block id: 85 */
                        g_189.f0 = l_104.f0;
                        g_189 = g_189;
                    }
                    g_189.f0 = ((!1) && g_3);
                }
                l_101 = (((1U <= ((l_142.f6 ^ ((uint32_t)(p_100 | ((((int16_t)g_3 << (int16_t)g_117) && p_100) > 1U)) % (uint32_t)g_140)) >= (~((uint16_t)p_100 >> (uint16_t)l_146)))) | p_100) > 0x8248);
                for (g_167 = (-19); (g_167 < 29); g_167 += 1)
                { /* block id: 94 */
                    g_189.f0 = ((l_104.f0 != p_100) > ((p_100 && (~l_186)) || (p_100 != 65535U)));
                }
                l_101 = p_100;
            }
            else
            { /* block id: 98 */
                uint16_t l_201 = 0x7537;
                l_201 = 0xE043946F;
                l_146 = ((65535U < __builtin_clzl(p_100)) | (g_88.f0 < ((uint32_t)((int16_t)((l_104.f0 & (g_105 == ((uint32_t)(((uint16_t)((((int16_t)((((l_142.f3 || g_165) || __builtin_clzl(l_102.f0)) | l_201) == 0xD5EC58B0) + (int16_t)0xE135) < g_3) && 65526U) << (uint16_t)9) || p_100) + (uint32_t)g_165))) && p_100) + (int16_t)g_148) + (uint32_t)l_214)));
            }
        }
    }
    else
    { /* block id: 103 */
        int32_t l_225 = 0xAFE77FC2;
        int16_t l_240 = 0x8C96;
        int32_t l_241 = 0xAE68F206;
        int32_t l_249 = (-3);
        struct S1 l_252 = {0x1040,4294967295U,4294967295U,815,31204,0U,-1};
        if (((int16_t)p_100 - (int16_t)((uint16_t)l_101 + (uint16_t)(((int16_t)((int16_t)((((((((g_105 <= l_225) & (0x2A9ED5AC < ((int16_t)p_100 >> (int16_t)15))) != ((int16_t)((uint16_t)((0U ^ 2U) == ((((uint16_t)((int16_t)(((uint16_t)((((((!g_145) > l_102.f0) > g_140) != l_102.f0) == 1) | 0x27A70E27) - (uint16_t)g_189.f0) == l_239) + (int16_t)0x6151) - (uint16_t)1) > g_145) <= g_168)) >> (uint16_t)9) % (int16_t)g_5)) == g_88.f0) && p_100) != p_100) && 0xC2537462) == l_225) << (int16_t)l_240) << (int16_t)13) <= l_241))))
        { /* block id: 104 */
            g_189.f0 = p_100;
        }
        else
        { /* block id: 106 */
            int16_t l_242 = 1;
            uint16_t l_245 = 8U;
            int32_t l_248 = 0x6A667620;
            struct S1 l_250 = {0x7D20,4294967295U,4294967295U,1511,46154,5U,0xA9C1};
            l_242 = 8;
            if (p_100)
            { /* block id: 108 */
                uint32_t l_247 = 0x5DC2C40D;
                l_245 = ((int16_t)p_100 - (int16_t)p_100);
                l_248 = ((~l_247) | ((0x842A > l_247) >= g_117));
                l_249 = g_105;
            }
            else
            { /* block id: 112 */
                l_251 = l_250;
                g_189.f0 = g_105;
                return l_251.f6;
            }
            l_252 = l_251;
        }
        l_252 = g_253;
    }
    l_251 = l_251;
    return g_145;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_88.f0, "g_88.f0", print_hash_value);
    transparent_crc(g_105, "g_105", print_hash_value);
    transparent_crc(g_117, "g_117", print_hash_value);
    transparent_crc(g_140, "g_140", print_hash_value);
    transparent_crc(g_145, "g_145", print_hash_value);
    transparent_crc(g_147, "g_147", print_hash_value);
    transparent_crc(g_148, "g_148", print_hash_value);
    transparent_crc(g_165, "g_165", print_hash_value);
    transparent_crc(g_167, "g_167", print_hash_value);
    transparent_crc(g_168, "g_168", print_hash_value);
    transparent_crc(g_189.f0, "g_189.f0", print_hash_value);
    transparent_crc(g_253.f0, "g_253.f0", print_hash_value);
    transparent_crc(g_253.f1, "g_253.f1", print_hash_value);
    transparent_crc(g_253.f2, "g_253.f2", print_hash_value);
    transparent_crc(g_253.f3, "g_253.f3", print_hash_value);
    transparent_crc(g_253.f4, "g_253.f4", print_hash_value);
    transparent_crc(g_253.f5, "g_253.f5", print_hash_value);
    transparent_crc(g_253.f6, "g_253.f6", print_hash_value);
    transparent_crc(g_379.f0, "g_379.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 67
   depth: 1, occurrence: 29
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 9

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 137
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 21, occurrence: 4
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 31, occurrence: 2

XXX total number of pointers: 0

XXX times a non-volatile is read: 368
XXX times a non-volatile is write: 78
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 13
   depth: 2, occurrence: 18
   depth: 3, occurrence: 27
   depth: 4, occurrence: 14
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 22
XXX percentage an existing variable is used: 78
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

