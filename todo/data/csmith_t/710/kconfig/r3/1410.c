/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2964507352
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
};

struct S1 {
   const signed f0 : 31;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   struct S1  f0;
   int16_t  f1;
   const int32_t  f2;
   int8_t  f3;
   signed f4 : 10;
   int32_t  f5;
   const struct S0  f6;
   int32_t  f7;
   uint32_t  f8;
   int32_t  f9;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_12[8] = {4294967293U,4294967293U,4294967293U,4294967293U,4294967293U,4294967293U,4294967293U,4294967293U};
static int32_t g_29 = (-1);
static uint32_t g_30 = 0xC638299F;
static struct S1 g_31 = {22014};
static int32_t *g_65 = (void*)0;
static struct S0 *g_85 = (void*)0;
static struct S0 g_87 = {588};
static int32_t g_137[4] = {4,4,4,4};
static int32_t * const g_145 = &g_137[1];
static int8_t g_150[1][3][6] = {{{0xE6,0xE6,0xE6,0xE6,0xE6,0xE6},{0xE6,0xE6,0xE6,0xE6,0xE6,0xE6},{0xE6,0xE6,0xE6,0xE6,0xE6,0xE6}}};
static const int8_t g_171 = 1;
static struct S0 **g_183 = &g_85;
static const int32_t *g_189 = (void*)0;
static const int32_t **g_188 = &g_189;
static int32_t g_194 = (-6);
static int16_t g_197 = 2;
static struct S1 *g_313 = (void*)0;
static struct S1 **g_312 = &g_313;
static int32_t g_316 = 0xBC259659;
static int32_t ***g_404 = (void*)0;
static int32_t ****g_403 = &g_404;
static struct S0 ** const *g_407 = &g_183;
static struct S0 ** const **g_406 = &g_407;
static struct S0 ** const ***g_405[9] = {&g_406,&g_406,&g_406,&g_406,&g_406,&g_406,&g_406,&g_406,&g_406};
static struct S2 g_441 = {{-7102},0x9DD4,0x4D3A08B9,1,-11,0,{1262},-8,4U,5};
static struct S2 *g_547 = &g_441;
static struct S2 **g_546 = &g_547;
static struct S0 g_641 = {-3074};
static struct S2 ****g_679 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
static int32_t * func_2(int32_t * p_3, int32_t * p_4, uint16_t  p_5);
inline static int32_t * func_6(int16_t  p_7, struct S1  p_8, struct S1  p_9, int8_t  p_10, uint32_t  p_11);
inline static struct S1  func_13(int32_t * p_14, const int32_t * p_15);
static int32_t * func_16(struct S2  p_17, struct S1  p_18, const struct S0  p_19, struct S0  p_20, uint32_t  p_21);
inline static struct S2  func_22(int32_t * p_23, uint8_t  p_24, int32_t  p_25, struct S1  p_26, uint32_t  p_27);
static uint16_t  func_38(int32_t * p_39);
static int32_t  func_44(int32_t * p_45, const uint8_t  p_46);
inline static int32_t * func_47(int32_t * const  p_48);
inline static int32_t * func_49(struct S0  p_50);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_30 g_29 g_31 g_441 g_137 g_150 g_145 g_188 g_189 g_546 g_194 g_312 g_407 g_183 g_547 g_171 g_87.f0 g_313 g_197 g_641 g_679 g_316
 * writes: g_137 g_87 g_441.f7 g_189 g_441.f8 g_441.f3 g_441.f9 g_29 g_313 g_547 g_194 g_403 g_441.f5 g_85 g_30 g_316 g_197 g_441.f1
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_28 = &g_29;
    struct S1 l_452 = {2807};
    const struct S0 l_453 = {-2502};
    int16_t l_551 = 0x3F31;
    int32_t *** const *l_655 = &g_404;
    uint8_t l_661 = 0x5E;
    int8_t l_680 = 3;
    struct S0 l_683 = {-3674};
lbl_681:
    (*g_188) = func_2(func_6(g_12[5], func_13(func_16(func_22(l_28, g_30, g_29, g_31, (*l_28)), l_452, l_453, l_453, g_137[1]), l_28), l_452, l_551, (*l_28)), l_28, g_641.f0);
    /* statement id: 476 */
    assert (g_189 == &g_29 || g_189 == &g_441.f7);
    assert (g_313 == &g_441.f0);
    if ((safe_rshift_func_int8_t_s_u((safe_mod_func_uint32_t_u_u(4294967292U, (*l_28))), (safe_lshift_func_uint8_t_u_s(((safe_mul_func_uint16_t_u_u((l_655 == (void*)0), (((*g_188) != (void*)0) & ((safe_mul_func_int16_t_s_s((!g_29), ((safe_add_func_int32_t_s_s((**g_188), 4294967287U)) > (*l_28)))) <= l_661)))) || (*l_28)), 3)))))
    { /* block id: 477 */
        int8_t l_662[10] = {2,0x1A,2,2,0x1A,2,2,2,0,0};
        const struct S0 l_682 = {-3724};
        const struct S0 *l_685 = &g_641;
        const struct S0 **l_684 = &l_685;
        int i;
        (*g_188) = func_6((*l_28), (*g_313), (*g_313), l_662[5], g_441.f0.f0);
        /* statement id: 478 */
        assert (g_189 == &g_441.f5 || g_189 == 0 || g_189 == &g_194 || (g_189 >= &g_137[0] && g_189 <= &g_137[3]));
        assert (g_313 == &g_441.f0 || g_313 == 0);
        for (g_197 = 5; (g_197 > 5); ++g_197)
        { /* block id: 481 */
            int32_t ****l_673 = &g_404;
            int8_t l_678[10] = {0xE5,0xE5,0,0xE5,0xE5,0,0xE5,0xE5,0,0xE5};
            int i;
            if (l_662[9])
            { /* block id: 482 */
                int32_t l_674 = 0x252D31A6;
                struct S2 *l_675 = (void*)0;
                for (g_441.f1 = 0; (g_441.f1 >= (-10)); g_441.f1 = safe_sub_func_uint32_t_u_u(g_441.f1, 5))
                { /* block id: 485 */
                    struct S2 ****l_667 = (void*)0;
                    const struct S2 *l_671[1];
                    const struct S2 **l_670 = &l_671[0];
                    const struct S2 ***l_669[3];
                    const struct S2 ****l_668 = &l_669[1];
                    int32_t *****l_672[7] = {(void*)0,&g_403,&g_403,(void*)0,&g_403,&g_403,(void*)0};
                    int i;
                    for (i = 0; i < 1; i = i + 1)
                        l_671[i] = &g_441;
                    for (i = 0; i < 3; i = i + 1)
                        l_669[i] = &l_670;
                    (*l_668) = (void*)0;
                    /* statement id: 486 */
                    //assert (l_669[0] == 0 || l_669[0] == &l_670);
                    l_673 = &g_404;
                    if (l_674)
                        continue;
                }
                (*g_546) = l_675;
                /* statement id: 490 */
                assert (g_547 == 0);
            }
            else
            { /* block id: 491 */
                l_680 = (l_678[4] == (g_679 != g_679));
                if (g_441.f1)
                    goto lbl_681;
            }
            /* facts after branching */
            assert (g_547 == &g_441 || g_547 == 0);
            return l_662[5];
        }
        l_683 = l_682;
        (*l_684) = &l_682;
        /* statement id: 498 */
        assert (l_685 == &l_682);
    }
    else
    { /* block id: 499 */
        struct S0 l_688[9] = {{-6131},{-6131},{-6131},{-6131},{-6131},{-6131},{-6131},{-6131},{-6131}};
        struct S0 *l_689 = (void*)0;
        struct S0 *l_690 = &g_87;
        int i;
        for (g_194 = 0; (g_194 != 0); g_194 = safe_add_func_int16_t_s_s(g_194, 8))
        { /* block id: 502 */
            l_683 = l_453;
        }
        (*l_690) = l_688[5];
    }
    /* facts after branching */
    assert (g_189 == &g_441.f7 || g_189 == &g_29 || g_189 == &g_441.f5 || g_189 == 0 || g_189 == &g_194 || (g_189 >= &g_137[0] && g_189 <= &g_137[3]));
    assert (g_313 == &g_441.f0 || g_313 == 0);
    return g_316;
}


/* ------------------------------------------ */
/* 
 * reads : g_316
 * writes: g_313 g_316
 */
static int32_t * func_2(int32_t * p_3, int32_t * p_4, uint16_t  p_5)
{ /* block id: 468 */
    struct S1 * const l_642[3] = {&g_441.f0,&g_441.f0,&g_441.f0};
    struct S1 **l_643 = &g_313;
    int32_t *l_646 = &g_441.f7;
    int i;
    (*l_643) = l_642[0];
    /* statement id: 469 */
    assert (g_313 == &g_441.f0);
    for (g_316 = 0; (g_316 >= 17); g_316 = safe_add_func_uint16_t_u_u(g_316, 6))
    { /* block id: 472 */
        return l_646;
        /* statement id: 473 */
        //assert (func_2_rv == &g_441.f7);
    }
    return p_4;
    /* statement id: 475 */
    //assert (func_2_rv == &g_29);
}


/* ------------------------------------------ */
/* 
 * reads : g_441.f7 g_137 g_441.f8 g_12 g_29 g_188 g_189 g_441.f9 g_150 g_441.f1 g_194 g_312 g_407 g_183 g_546 g_547 g_145 g_441.f0.f0 g_30 g_171 g_87.f0 g_31.f0 g_313 g_441.f5 g_441.f3 g_197 g_641
 * writes: g_29 g_441.f8 g_441.f9 g_189 g_313 g_547 g_137 g_194 g_403 g_441.f5 g_85 g_30
 */
inline static int32_t * func_6(int16_t  p_7, struct S1  p_8, struct S1  p_9, int8_t  p_10, uint32_t  p_11)
{ /* block id: 399 */
    int32_t ***l_560 = (void*)0;
    int32_t l_563 = 0xF652E9D1;
    struct S0 l_568 = {-4253};
    const int32_t ***l_592 = (void*)0;
    l_563 = (safe_lshift_func_uint8_t_u_u(((((safe_lshift_func_uint8_t_u_s((g_441.f7 || (safe_mod_func_int16_t_s_s(((l_560 == l_560) != (((safe_sub_func_uint16_t_u_u((l_560 != (void*)0), (&g_404 == (void*)0))) || p_7) >= (((0xB2496E74 >= g_137[1]) > g_441.f8) && 0x82FFCF27))), 1))), p_10)) == g_12[5]) | 65532U) != g_29), g_12[6]));
    for (g_29 = 11; (g_29 > 11); g_29 = safe_add_func_uint8_t_u_u(g_29, 2))
    { /* block id: 403 */
        struct S0 l_566 = {4530};
        struct S0 *l_567[3];
        uint8_t l_602 = 9U;
        int32_t *l_636 = &g_441.f7;
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_567[i] = &g_87;
        l_568 = l_566;
        for (p_11 = 0; (p_11 <= 0); p_11 += 1)
        { /* block id: 407 */
            uint32_t l_575 = 0U;
            struct S0 l_604 = {7508};
            int32_t *l_605[4] = {&g_137[1],&g_137[1],&g_137[1],&g_137[1]};
            int i;
            for (g_441.f8 = 0; (g_441.f8 <= 0); g_441.f8 += 1)
            { /* block id: 410 */
                for (g_441.f9 = 0; (g_441.f9 >= 0); g_441.f9 -= 1)
                { /* block id: 413 */
                    struct S0 *l_576 = (void*)0;
                    struct S0 l_579 = {4483};
                    int i, j, k;
                    (*g_188) = (*g_188);
                    if ((safe_lshift_func_int16_t_s_u((safe_mul_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(((g_150[p_11][g_441.f8][(g_441.f9 + 5)] != g_150[p_11][(p_11 + 2)][(g_441.f8 + 4)]) == l_575), 8)) ^ ((l_576 != &l_566) ^ g_441.f1)), (p_8.f0 > (safe_mul_func_int16_t_s_s(p_7, (g_194 < g_150[0][0][5])))))), 4)))
                    { /* block id: 415 */
                        int16_t l_588 = 1;
                        (*g_312) = (void*)0;
                        /* statement id: 416 */
                        assert (g_313 == 0);
                        l_579 = l_568;
                        l_588 = (safe_mul_func_int16_t_s_s((safe_lshift_func_int8_t_s_u((safe_add_func_uint32_t_u_u(4294967295U, ((void*)0 != (*g_407)))), 7)), (safe_mul_func_int16_t_s_s(p_7, g_441.f8))));
                        (*g_546) = (*g_546);
                    }
                    else
                    { /* block id: 420 */
                        (*g_145) = ((+(p_9.f0 & (((l_592 == (void*)0) & g_12[6]) == ((((((l_575 < (safe_div_func_uint8_t_u_u(l_575, l_575))) && ((+(safe_mul_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(p_10, (safe_mod_func_uint32_t_u_u(l_575, p_7)))), l_575))) && (*g_145))) >= 0xE0) && g_441.f1) | l_602) | g_441.f0.f0)))) == g_30);
                    }
                    for (g_194 = 0; (g_194 <= 0); g_194 += 1)
                    { /* block id: 425 */
                        int32_t *****l_603 = &g_403;
                        (*l_603) = (void*)0;
                        /* statement id: 426 */
                        assert (g_403 == 0);
                    }
                    for (p_10 = 0; (p_10 >= 0); p_10 -= 1)
                    { /* block id: 430 */
                        l_604 = l_604;
                        if (l_566.f0)
                            break;
                        if (p_7)
                            break;
                    }
                }
                return l_605[3];
                /* statement id: 436 */
                //assert (func_6_rv == &g_194 || (func_6_rv >= &g_137[0] && func_6_rv <= &g_137[3]));
            }
            (*g_145) = (((safe_div_func_int32_t_s_s(((g_171 == (safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s(l_602, (safe_lshift_func_int8_t_s_s(p_9.f0, 7)))), g_29))) <= ((p_9.f0 ^ (safe_lshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s((safe_add_func_uint32_t_u_u(p_10, (safe_rshift_func_uint16_t_u_u(p_9.f0, 8)))), (0 > ((safe_unary_minus_func_int16_t_s(((0x3945 & g_137[1]) == g_87.f0))) != 0x0A7374C6)))), l_566.f0))) == g_441.f7)), g_31.f0)) <= p_11) != g_441.f1);
            (*g_312) = (*g_312);
            for (g_441.f9 = 0; (g_441.f9 >= 0); g_441.f9 -= 1)
            { /* block id: 442 */
                const int32_t *l_635 = (void*)0;
                (*g_145) = 1;
                (*g_188) = l_605[3];
                /* statement id: 444 */
                assert (g_189 == &g_194 || (g_189 >= &g_137[0] && g_189 <= &g_137[3]));
                for (g_441.f5 = 0; (g_441.f5 <= 0); g_441.f5 += 1)
                { /* block id: 447 */
                    const uint32_t l_625[4] = {0x8FB8F4EE,0x8FB8F4EE,0x8FB8F4EE,0x8FB8F4EE};
                    int32_t *l_640[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
                    int i;
                    if ((safe_mod_func_uint32_t_u_u((l_625[1] ^ (((((safe_add_func_uint16_t_u_u((!(l_566.f0 || g_30)), (0x60 != ((safe_mul_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u(((l_635 == l_636) <= ((safe_sub_func_uint8_t_u_u((1 <= g_441.f3), (g_197 ^ 1U))) & g_441.f5)), p_11)), p_8.f0)) == 0xB0EFBBA0)))) || g_171) == p_11) | g_171) | p_10)), p_7)))
                    { /* block id: 448 */
                        struct S0 l_639 = {-4094};
                        (*g_188) = (*g_188);
                        (*g_188) = func_49(l_639);
                        /* statement id: 450 */
                        assert (g_189 == &g_29);
                    }
                    else
                    { /* block id: 451 */
                        (**g_407) = &l_568;
                        /* statement id: 452 */
                        assert (g_85 == &l_568);
                        (*g_145) = ((&g_404 == &l_560) < 0);
                        return l_640[2];
                        /* statement id: 454 */
                        //assert (g_85 == dangling);
                        //assert (func_6_rv == &g_441.f5 || func_6_rv == 0);
                    }
                    /* facts after branching */
                    assert (g_189 == &g_29);
                    for (g_30 = 0; (g_30 <= 0); g_30 += 1)
                    { /* block id: 458 */
                        l_636 = l_636;
                        (*g_188) = func_49(g_641);
                        (*g_188) = (*g_188);
                    }
                }
                /* facts after for loop */
                assert (g_189 == &g_29 || g_189 == &g_194 || (g_189 >= &g_137[0] && g_189 <= &g_137[3]));
            }
        }
    }
    return &g_194;
    /* statement id: 467 */
    //assert (func_6_rv == &g_194);
}


/* ------------------------------------------ */
/* 
 * reads : g_441.f5 g_150 g_441.f0.f0 g_441.f9 g_29 g_441.f2 g_441.f6.f0 g_30 g_188 g_189 g_441.f8 g_441.f3 g_145 g_12 g_441.f7 g_31.f0 g_546 g_441.f4
 * writes: g_87 g_441.f7 g_189 g_441.f8 g_441.f3 g_137 g_441.f9
 */
inline static struct S1  func_13(int32_t * p_14, const int32_t * p_15)
{ /* block id: 368 */
    uint8_t l_470 = 1U;
    struct S1 l_550[9] = {{1473},{1473},{1473},{1473},{1473},{1473},{1473},{1473},{1473}};
    int i;
    if (l_470)
    { /* block id: 369 */
        struct S0 l_471[10][2][9] = {{{{161},{-5857},{-975},{-6310},{-7632},{-5135},{7016},{3902},{-3947}},{{6859},{1822},{-5101},{-4340},{-6533},{-2306},{-6242},{505},{-2932}}},{{{3006},{1597},{-2883},{-2014},{1097},{-2014},{-2883},{1597},{3006}},{{-8066},{-5716},{505},{-5798},{5608},{-7493},{-4751},{-3708},{-6242}}},{{{1597},{-975},{-3153},{-3947},{7857},{459},{-5857},{-2883},{7473}},{{-8066},{5608},{-4751},{-2932},{-7493},{984},{-8039},{984},{-7493}}},{{{3006},{-4024},{-4024},{3006},{-975},{-3049},{7857},{-4158},{-5135}},{{6859},{6404},{-7493},{-6242},{2241},{-6544},{-6533},{-5798},{-5716}}},{{{161},{459},{1597},{7473},{-975},{-4158},{-400},{-6397},{-2883}},{{-4751},{-5083},{-1617},{-7493},{-7493},{-1617},{-5083},{-4751},{-7673}}},{{{7016},{-4158},{5658},{-5135},{7857},{-4024},{-6974},{-7632},{3902}},{{936},{-4340},{-1529},{-5716},{5608},{-292},{-8066},{-6533},{-7673}}},{{{3902},{5658},{7016},{-2883},{1097},{7473},{7473},{1097},{-2883}},{{-2306},{-5101},{-2306},{-7673},{-6533},{-8066},{-292},{5608},{-5716}}},{{{7473},{161},{3006},{3902},{-7632},{-6974},{-4024},{7857},{-5135}},{{-6533},{-6242},{1822},{-1529},{-292},{-4340},{-7493},{-5280},{-5280}}},{{{-7632},{161},{7857},{-3153},{7857},{161},{-7632},{5658},{-6974}},{{-3624},{-1529},{2241},{-8066},{-6242},{936},{-5083},{6404},{5019}}},{{{1597},{459},{161},{7617},{-7632},{-2014},{1901},{5658},{-4024}},{{5356},{-292},{-5716},{-5280},{-3708},{-6533},{-3708},{-5280},{-5716}}}};
        struct S0 *l_472 = (void*)0;
        struct S0 *l_473 = &g_87;
        const uint8_t l_490 = 255U;
        int i, j, k;
        (*l_473) = l_471[1][0][8];
        (*p_14) = ((((~g_441.f5) && ((((0xF33D6205 & g_150[0][0][0]) >= ((safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u((((safe_rshift_func_int8_t_s_s((!(safe_div_func_uint16_t_u_u(65526U, (safe_add_func_uint16_t_u_u(l_471[1][0][8].f0, ((l_470 < (safe_lshift_func_uint16_t_u_u((l_490 < (safe_mul_func_uint8_t_u_u(((g_441.f0.f0 != (safe_div_func_int16_t_s_s((g_441.f9 | 255U), l_471[1][0][8].f0))) & 0x84E6DCCE), l_470))), l_471[1][0][8].f0))) != 0)))))), 7)) > 0x49C8) <= (*p_15)), g_441.f2)), l_470)) >= 0x64)) | l_470) ^ g_441.f6.f0)) > g_30) < g_30);
    }
    else
    { /* block id: 372 */
        int32_t *l_495 = &g_29;
        (*g_188) = l_495;
        /* statement id: 373 */
        assert (g_189 == &g_29);
    }
    /* facts after branching */
    assert (g_189 == &g_29 || g_189 == 0 || g_189 == &g_441.f5 || g_189 == &g_194 || (g_189 >= &g_137[0] && g_189 <= &g_137[3]));
    (*g_188) = (*g_188);
    for (g_441.f8 = 0; (g_441.f8 <= 35); g_441.f8 = safe_add_func_int8_t_s_s(g_441.f8, 4))
    { /* block id: 378 */
        struct S1 *l_500 = &g_31;
        int32_t l_505 = 0x7EACAC37;
        struct S0 l_535 = {1153};
        struct S2 *l_542[5];
        int i;
        for (i = 0; i < 5; i = i + 1)
            l_542[i] = &g_441;
        for (g_441.f3 = 15; (g_441.f3 == (-7)); g_441.f3 = safe_sub_func_uint8_t_u_u(g_441.f3, 8))
        { /* block id: 381 */
            const uint16_t l_520 = 0x96E4;
            struct S2 * const l_531 = &g_441;
            (*g_188) = p_15;
            /* statement id: 382 */
            assert (g_189 == &g_29);
            l_500 = l_500;
            (*g_145) = 0x0D887441;
            for (g_441.f9 = 5; (g_441.f9 != 13); g_441.f9 = safe_add_func_uint32_t_u_u(g_441.f9, 8))
            { /* block id: 387 */
                uint32_t l_510 = 4294967295U;
                const struct S1 *l_526[9] = {&g_441.f0,&g_31,&g_441.f0,&g_31,&g_441.f0,&g_31,&g_441.f0,&g_31,&g_441.f0};
                int i;
                if ((safe_div_func_uint16_t_u_u(l_505, (safe_add_func_int8_t_s_s(((safe_mod_func_uint32_t_u_u(g_12[5], l_505)) ^ l_510), ((((safe_lshift_func_int8_t_s_u((safe_add_func_int8_t_s_s((~(((**g_188) != (0x8C08B6E8 | (248U <= ((safe_mul_func_int8_t_s_s((safe_add_func_int16_t_s_s((l_510 ^ g_441.f2), l_510)), l_520)) && l_470)))) <= (*p_14))), l_520)), 2)) >= l_505) | g_441.f7) > 2))))))
                { /* block id: 388 */
                    l_500 = l_500;
                }
                else
                { /* block id: 390 */
                    int32_t l_525[8];
                    const struct S1 *l_534 = &g_31;
                    int i;
                    for (i = 0; i < 8; i = i + 1)
                        l_525[i] = 0x58A54B1F;
                    (*g_145) = ((safe_add_func_int8_t_s_s((-5), ((l_525[4] | (l_470 < ((((((void*)0 == l_526[6]) & l_470) && (safe_div_func_uint8_t_u_u(((safe_rshift_func_int8_t_s_u((l_531 == &g_441), 2)) || (safe_rshift_func_uint8_t_u_u((((void*)0 != l_534) | (-10)), l_525[7]))), g_441.f9))) || l_520) < 0xE8849ED3))) | g_31.f0))) || g_441.f8);
                }
                (*g_188) = func_49(l_535);
            }
        }
        (*p_14) = (((safe_lshift_func_int8_t_s_s(0x76, 3)) && ((safe_add_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(((void*)0 == l_542[0]), (~(safe_mul_func_int16_t_s_s(((((g_546 == (void*)0) >= g_441.f0.f0) || ((((-1) != (safe_mul_func_int16_t_s_s((1U | g_441.f2), l_505))) <= l_535.f0) || l_470)) && l_505), l_505))))), g_441.f4)) <= 0xEC5F)) | l_535.f0);
    }
    return l_550[7];
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_150 g_145
 * writes: g_137
 */
static int32_t * func_16(struct S2  p_17, struct S1  p_18, const struct S0  p_19, struct S0  p_20, uint32_t  p_21)
{ /* block id: 365 */
    int32_t l_458 = (-4);
    struct S0 ***l_468 = (void*)0;
    int32_t *l_469[2];
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_469[i] = &g_441.f7;
    (*g_145) = (safe_rshift_func_uint16_t_u_s((safe_mod_func_uint32_t_u_u(((((l_458 >= l_458) >= 0x01EF4C16) > (safe_mod_func_int16_t_s_s((safe_add_func_int8_t_s_s(g_30, ((safe_mul_func_int8_t_s_s((safe_unary_minus_func_int32_t_s(p_17.f7)), 1)) == (safe_mod_func_uint32_t_u_u((p_17.f1 || ((void*)0 == l_468)), g_150[0][0][4]))))), l_458))) <= 2), 0xF15AACC0)), 10));
    return l_469[0];
    /* statement id: 367 */
    //assert (func_16_rv == &g_441.f7);
}


/* ------------------------------------------ */
/* 
 * reads : g_441
 * writes:
 */
inline static struct S2  func_22(int32_t * p_23, uint8_t  p_24, int32_t  p_25, struct S1  p_26, uint32_t  p_27)
{ /* block id: 1 */
    int32_t *l_40 = &g_29;
    struct S0 l_341 = {6322};
    struct S0 *l_361 = &l_341;
    struct S2 l_371[3][10] = {{{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042}},{{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{10443},0,1,1,26,0xC0BA9720,{-734},4,0x5E385F3E,5},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{10443},0,1,1,26,0xC0BA9720,{-734},4,0x5E385F3E,5},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{10443},0,1,1,26,0xC0BA9720,{-734},4,0x5E385F3E,5},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D}},{{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{-11113},1,-9,1,-27,0x2AF201FA,{-2851},0x627779FA,4294967295U,0xEDB2B042},{{10752},0x3D20,0,0x73,-9,0xAA815386,{-2156},0x5DF1CC40,0xAAD6041D,0x7F689F1D}}};
    struct S1 * const l_390 = &l_371[2][4].f0;
    int32_t * const l_425 = &l_371[2][4].f7;
    struct S0 ***l_447 = &g_183;
    struct S0 ****l_446 = &l_447;
    struct S2 *l_451 = &g_441;
    struct S2 **l_450 = &l_451;
    int i, j;
    return (**l_450);
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_30 g_150 g_171 g_194 g_197 g_188
 * writes: g_30 g_197 g_189 g_188
 */
static uint16_t  func_38(int32_t * p_39)
{ /* block id: 2 */
    uint32_t l_41 = 0U;
    struct S0 l_51 = {-3359};
    int32_t * const l_256 = (void*)0;
    if ((l_41 & ((((safe_div_func_int32_t_s_s(func_44(func_47(func_49(l_51)), g_29), ((safe_mul_func_uint8_t_u_u((&g_85 == (void*)0), ((safe_div_func_uint32_t_u_u((safe_add_func_uint8_t_u_u((safe_mod_func_uint16_t_u_u((safe_add_func_int8_t_s_s(((safe_sub_func_int8_t_s_s(l_51.f0, 1)) && g_150[0][2][4]), g_171)), g_150[0][1][2])), 0xCC)), l_41)) || l_41))) & (-2)))) <= 0x99CE) < l_41) != g_194)))
    { /* block id: 195 */
        for (g_197 = (-1); (g_197 != (-16)); g_197--)
        { /* block id: 198 */
            return g_150[0][0][1];
        }
        for (g_30 = 0; (g_30 <= 3); g_30 += 1)
        { /* block id: 203 */
            struct S0 l_257 = {7628};
            int i;
            (*g_188) = &g_137[g_30];
            /* statement id: 204 */
            assert ((g_189 >= &g_137[0] && g_189 <= &g_137[3]));
            (*g_188) = func_47(l_256);
            /* statement id: 205 */
            assert (g_189 == &g_29);
            l_51 = l_257;
            (*g_188) = func_49(l_51);
        }
        /* facts after for loop */
        assert (g_189 == &g_29 || g_189 == 0);
    }
    else
    { /* block id: 209 */
        struct S0 *l_258[2];
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_258[i] = (void*)0;
        l_51 = l_51;
    }
    /* facts after branching */
    assert (g_189 == &g_29 || g_189 == 0);
    g_188 = (void*)0;
    /* statement id: 212 */
    assert (g_188 == 0);
    return l_51.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_29
 * writes: g_30
 */
static int32_t  func_44(int32_t * p_45, const uint8_t  p_46)
{ /* block id: 8 */
    uint8_t l_60 = 1U;
    struct S0 l_68[8] = {{-3026},{-3026},{-3026},{-3026},{-3026},{-3026},{-3026},{-3026}};
    int32_t *l_105[7] = {&g_29,&g_29,&g_29,&g_29,&g_29,&g_29,&g_29};
    uint16_t l_182 = 8U;
    int32_t l_196 = 0x69582D88;
    struct S0 l_231 = {3088};
    int i;
    for (g_30 = 0; (g_30 == 50); ++g_30)
    { /* block id: 11 */
        struct S0 l_66[5][9][5] = {{{{-5082},{7093},{-6174},{-2266},{4975}},{{3271},{-1618},{-3747},{7502},{2063}},{{4484},{4301},{-5905},{7093},{4975}},{{-5588},{7502},{4980},{4980},{7502}},{{4975},{-5979},{-4564},{3934},{-7616}},{{5797},{3271},{4283},{-1480},{-3751}},{{-6019},{7093},{-7616},{7903},{-3405}},{{5797},{-5588},{-1618},{7502},{-1618}},{{4975},{-2361},{-443},{4314},{3898}}},{{{-5588},{5797},{3318},{-5588},{3271}},{{4484},{-2266},{-4564},{-5403},{-6019}},{{3271},{5797},{-2993},{-3751},{-3751}},{{-5082},{-2361},{-5082},{1693},{-1845}},{{7502},{-5588},{-3747},{310},{2640}},{{-7594},{7093},{-7262},{4314},{4975}},{{-1618},{3271},{-3747},{2640},{-1962}},{{4484},{-5979},{-5082},{7093},{-6174}},{{310},{7502},{-2993},{-1480},{7502}}},{{{-6174},{4301},{-4564},{-3938},{-6174}},{{2640},{-5345},{-3702},{-3747},{-7600}},{{-4564},{-5979},{4975},{-5979},{-4564}},{{-3702},{3318},{-5345},{-2993},{2063}},{{-4966},{-3811},{-7262},{1693},{-7766}},{{3318},{2640},{7502},{3318},{2063}},{{-5905},{1693},{-443},{218},{-4564}},{{2063},{-3702},{-5912},{-1618},{-7600}},{{-6019},{530},{-3405},{-3938},{-6174}}},{{{-2993},{3318},{-7600},{4283},{4980}},{{-6019},{8},{-6762},{1693},{-6762}},{{2063},{2063},{3271},{4980},{-5588}},{{-5905},{-2266},{1347},{8},{-4966}},{{3318},{-2993},{-5912},{-3747},{-2993}},{{-4966},{-2266},{-1845},{7495},{-6174}},{{-3702},{2063},{-3702},{-5912},{-1618}},{{-4564},{8},{-7262},{-5979},{3928}},{{2640},{3318},{-1962},{4980},{2063}}},{{{-6762},{530},{-7262},{1023},{-987}},{{3318},{-3702},{-3702},{3318},{-5345}},{{-5082},{1693},{-1845},{-3938},{-4564}},{{-5345},{2640},{-5912},{-7600},{-1618}},{{-6019},{-3811},{1347},{-3938},{-7262}},{{4980},{3318},{3271},{3318},{4980}},{{1347},{-5979},{-6762},{1023},{-4966}},{{2063},{-5345},{-7600},{4980},{-7239}},{{-5082},{-2266},{-3405},{-5979},{-4966}}}};
        int32_t *l_109 = (void*)0;
        struct S1 *l_172 = &g_31;
        const int32_t *l_191[7];
        const int8_t l_220 = (-1);
        int i, j, k;
        for (i = 0; i < 7; i = i + 1)
            l_191[i] = &g_137[3];
    }
    return (*p_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_47(int32_t * const  p_48)
{ /* block id: 6 */
    int32_t *l_55 = &g_29;
    return l_55;
    /* statement id: 7 */
    //assert (func_47_rv == &g_29);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_49(struct S0  p_50)
{ /* block id: 3 */
    int32_t *l_53[2][3] = {{&g_29,&g_29,&g_29},{&g_29,&g_29,&g_29}};
    int32_t **l_52 = &l_53[1][2];
    int32_t **l_54 = &l_53[1][2];
    int i, j;
    l_54 = l_52;
    return &g_29;
    /* statement id: 5 */
    //assert (func_49_rv == &g_29);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    for (i = 0; i < 8; i = i + 1)
    {
        transparent_crc(g_12[i], "g_12[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_29, "g_29", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    transparent_crc(g_31.f0, "g_31.f0", print_hash_value);
    transparent_crc(g_87.f0, "g_87.f0", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        transparent_crc(g_137[i], "g_137[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 3; j = j + 1)
        {
            for (k = 0; k < 6; k = k + 1)
            {
                transparent_crc(g_150[i][j][k], "g_150[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_171, "g_171", print_hash_value);
    transparent_crc(g_194, "g_194", print_hash_value);
    transparent_crc(g_197, "g_197", print_hash_value);
    transparent_crc(g_316, "g_316", print_hash_value);
    transparent_crc(g_441.f0.f0, "g_441.f0.f0", print_hash_value);
    transparent_crc(g_441.f1, "g_441.f1", print_hash_value);
    transparent_crc(g_441.f2, "g_441.f2", print_hash_value);
    transparent_crc(g_441.f3, "g_441.f3", print_hash_value);
    transparent_crc(g_441.f4, "g_441.f4", print_hash_value);
    transparent_crc(g_441.f5, "g_441.f5", print_hash_value);
    transparent_crc(g_441.f6.f0, "g_441.f6.f0", print_hash_value);
    transparent_crc(g_441.f7, "g_441.f7", print_hash_value);
    transparent_crc(g_441.f8, "g_441.f8", print_hash_value);
    transparent_crc(g_441.f9, "g_441.f9", print_hash_value);
    transparent_crc(g_641.f0, "g_641.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 122
   depth: 1, occurrence: 40
   depth: 2, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 78
breakdown:
   indirect level: 0, occurrence: 43
   indirect level: 1, occurrence: 20
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 40
breakdown:
   indirect level: 0, occurrence: 40
XXX times a bitfields struct's address is taken: 45
XXX times a bitfields struct on LHS: 24
XXX times a bitfields struct on RHS: 66
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 51

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 24
   depth: 3, occurrence: 2
   depth: 6, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 4
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 144
XXX times a pointer is dereferenced on RHS: 85
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 89
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 30
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 541

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 339
   level: 2, occurrence: 36
   level: 3, occurrence: 21
   level: 4, occurrence: 28
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 36
XXX percent of pointers has null in alias set: 35.1
XXX average alias set size: 1.37

XXX times a non-volatile is read: 696
XXX times a non-volatile is write: 300
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 17
   depth: 2, occurrence: 16
   depth: 3, occurrence: 11
   depth: 4, occurrence: 11
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 21.9
XXX percentage an existing variable is used: 78.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

