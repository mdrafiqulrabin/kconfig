/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      311270160
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const float  f0;
   signed f1 : 3;
   uint64_t  f2;
   float  f3;
   const signed f4 : 2;
};
#pragma pack(pop)

union U1 {
   int16_t  f0;
   uint64_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_34(void);
static const float ** func_38(float * p_39, float * const  p_40);
inline static float  func_43(int32_t  p_44, float ** p_45, int16_t  p_46, uint64_t  p_47);
inline static int64_t  func_55(float * p_56, float * p_57, float ** p_58, const uint32_t  p_59, float ** p_60);
static float * func_61(uint8_t  p_62, float ** p_63);
static int16_t  func_74(int32_t  p_75, const float ** const  p_76, float ** p_77, int64_t  p_78, float ** const  p_79);
static int32_t  func_89(int32_t  p_90, const struct S0  p_91, float * const * p_92, float * const  p_93, const struct S0  p_94);
inline static const struct S0  func_95(int32_t  p_96, float * p_97, float ** p_98, int32_t  p_99, int32_t  p_100);
inline static uint32_t  func_105(uint16_t  p_106, int32_t  p_107, uint32_t  p_108, float * p_109, float * const * p_110);
inline static int32_t  func_113(int32_t  p_114, const float ** p_115, const uint32_t  p_116);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(void)
{ /* block id: 36 */
    int16_t l_35 = 0L;
    float l_37 = 0x2.F27A41p-93;
    float *l_36 = &l_37;
    float *l_41 = &l_37;
    float * const l_42 = &l_37;
    float **l_697 = &l_36;
    float ***l_696 = &l_697;
    int32_t l_701 = 5L;
    int32_t *l_700 = &l_701;
    int32_t **l_699 = &l_700;
    int32_t ***l_698 = &l_699;
    int32_t ** const *l_703 = &l_699;
    int32_t ** const **l_702 = &l_703;
    int32_t l_704 = 0x1D867E3CL;
    uint32_t l_705 = 0xB54BD615L;
    (*l_36) = l_35;
    (*l_696) = func_38(l_41, l_42);
    /* statement id: 401 */
    assert (l_697 == 0);
    (*l_702) = l_698;
    (*l_41) = l_704;
    return l_705;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float ** func_38(float * p_39, float * const  p_40)
{ /* block id: 38 */
    float l_52 = 0x2.718B96p+22;
    float * const l_51 = &l_52;
    float * const *l_50 = &l_51;
    int32_t l_67 = 0xE183A099L;
    const float *l_83 = &l_52;
    const float ** const l_82 = &l_83;
    float **l_84 = (void*)0;
    float *l_86 = &l_52;
    float ** const l_85 = &l_86;
    union U1 *l_693 = (void*)0;
    union U1 **l_692 = &l_693;
    union U1 ***l_691 = &l_692;
    const float **l_694 = &l_83;
    const float **l_695 = (void*)0;
    (*l_51) = func_43((((int16_t)((void*)0 != l_50) + (int16_t)((int64_t)func_55(func_61(((int16_t)(+0xE7AEBB1BB30B137DLL) + (int16_t)(__builtin_popcount(l_67) <= ((uint16_t)((uint16_t)((int16_t)0x53A8L << (int16_t)15) << (uint16_t)func_74(((((uint16_t)(0xA828C040L ^ (l_67 < (-10L))) % (uint16_t)0xE3C2L) || 0x1700L) | l_67), l_82, l_84, l_67, l_85)) + (uint16_t)l_67))), &l_86), (*l_85), &l_86, l_67, &l_86) % (int64_t)l_67)) != (-8L)), &l_86, l_67, l_67);
    l_691 = l_691;
    return l_695;
    /* statement id: 400 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_43(int32_t  p_44, float ** p_45, int16_t  p_46, uint64_t  p_47)
{ /* block id: 392 */
    uint8_t l_666 = 1UL;
    const float l_669 = 0x5.22984Dp+33;
    const float *l_668 = &l_669;
    const float **l_667 = &l_668;
    int32_t l_672 = 0L;
    int32_t *l_674 = &l_672;
    int32_t **l_673 = &l_674;
    const struct S0 l_688 = {0x1.2p+1,-0,1UL,0x1.4p-1,0};
    float *l_690 = (void*)0;
    float * const *l_689 = &l_690;
    l_672 = ((l_666 > (0x544FL || (p_45 == l_667))) != ((p_46 > ((-3L) ^ p_47)) <= ((uint32_t)l_666 - (uint32_t)0x08C586C5L)));
    (*l_673) = (void*)0;
    /* statement id: 394 */
    assert (l_674 == 0);
    (**p_45) = (((**p_45) > (**p_45)) != 0x1.Ap-1);
    (*l_673) = func_61(p_44, p_45);
    return (**p_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_55(float * p_56, float * p_57, float ** p_58, const uint32_t  p_59, float ** p_60)
{ /* block id: 213 */
    int32_t ***l_371 = (void*)0;
    int32_t *** const *l_370 = &l_371;
    int32_t l_376 = 0x370A9BE4L;
    uint64_t l_379 = 2UL;
    union U1 l_409 = {0L};
    union U1 *l_408 = &l_409;
    union U1 **l_407 = &l_408;
    int32_t l_420 = 0x9C64D65DL;
    float l_428 = 0x6.DDB9D4p+72;
    float *l_427 = &l_428;
    float ** const l_426 = &l_427;
    const float *l_445 = &l_428;
    const float ** const l_444 = &l_445;
    float **l_502 = &l_427;
    float ***l_501 = &l_502;
    float ****l_500 = &l_501;
    const struct S0 l_505 = {0xD.DAD963p-83,1,0xB507F084D59CC582LL,0x1.Bp+1,1};
    float l_518 = 0x1.3D0BC4p-48;
    float l_559 = 0x1.Cp-1;
    int64_t l_597 = (-1L);
    uint8_t l_646 = 253UL;
    uint32_t l_654 = 18446744073709551607UL;
    uint16_t l_665 = 65535UL;
    if ((((int16_t)((((void*)0 != l_370) && p_59) > ((uint16_t)((uint32_t)(&p_58 == (void*)0) - (uint32_t)l_376) >> (uint16_t)((uint64_t)l_379 / (uint64_t)p_59))) << (int16_t)10) & (-(uint32_t)p_59)))
    { /* block id: 214 */
        int16_t l_383 = 0x577DL;
        uint32_t l_386 = 5UL;
        float l_423 = 0x0.8p+1;
        const float *l_422 = &l_423;
        const float ** const l_421 = &l_422;
        float *l_425 = &l_423;
        float **l_424 = &l_425;
        int32_t *l_455 = (void*)0;
        int32_t **l_454 = &l_455;
        float ** const *l_504 = &l_424;
        float ** const **l_503 = &l_504;
        const struct S0 l_506 = {0xA.559AC1p-73,-1,18446744073709551609UL,0x2.53B0A8p+4,0};
        for (l_379 = 0; (l_379 >= 48); l_379 += 8)
        { /* block id: 217 */
            return l_383;
        }
lbl_493:
        if (((uint64_t)l_386 % (uint64_t)p_59))
        { /* block id: 220 */
            int32_t *l_437 = &l_376;
            int32_t **l_436 = &l_437;
            for (l_379 = 0; (l_379 > 26); l_379++)
            { /* block id: 223 */
                int32_t *l_391 = (void*)0;
                union U1 l_406 = {-1L};
                union U1 *l_405 = &l_406;
                union U1 **l_404 = &l_405;
                for (l_386 = 0; (l_386 >= 30); l_386 += 3)
                { /* block id: 226 */
                    const union U1 *l_411 = &l_406;
                    int32_t l_413 = (-7L);
                    if (p_59)
                    { /* block id: 227 */
                        int32_t **l_392 = &l_391;
                        (*l_392) = l_391;
                        return p_59;
                    }
                    else
                    { /* block id: 230 */
                        union U1 *l_410 = (void*)0;
                        int32_t l_412 = 0L;
                        (**p_60) = ((float)(((float)((float)(((0xB.618F1Fp-35 >= (((float)(((float)(!(**p_60)) + (float)__builtin_ctz(p_59)) >= 0x0.638CF9p+11) + (float)(**p_60)) < (l_404 == l_407))) == (l_410 != l_411)) > (**p_58)) / (float)(*p_57)) - (float)(**p_60)) != (*p_57)) + (float)(-0x1.5p+1));
                        if (l_412)
                            break;
                        l_412 = l_413;
                    }
                    if (((int64_t)l_386 / (int64_t)((int16_t)(p_59 & p_59) << (int16_t)p_59)))
                    { /* block id: 235 */
                        l_413 = l_413;
                    }
                    else
                    { /* block id: 237 */
                        int32_t *l_429 = &l_413;
                        (*l_429) = ((int32_t)5L + (int32_t)func_74(l_420, l_421, l_424, p_59, l_426));
                    }
                }
            }
            (*l_436) = func_61(((int16_t)6L << (int16_t)(((int64_t)p_59 % (int64_t)(-1L)) & ((uint32_t)0x623B8A31L % (uint32_t)p_59))), &l_427);
            /* statement id: 242 */
            assert (l_437 == 0);
            (*l_407) = (*l_407);
        }
        else
        { /* block id: 244 */
            uint32_t l_451 = 0x28BA4243L;
            int32_t l_477 = 0x6988AD69L;
            int64_t l_484 = 0xECE72C066E181E8ELL;
            int32_t l_490 = (-1L);
            struct S0 l_492 = {0x4.913ACFp+32,1,3UL,0xB.C9A4B7p-19,-0};
            struct S0 *l_491 = &l_492;
            if (((int32_t)p_59 % (int32_t)l_383))
            { /* block id: 245 */
                int32_t *l_440 = &l_376;
                int32_t **l_441 = &l_440;
                (*l_441) = l_440;
            }
            else
            { /* block id: 247 */
                float **l_446 = &l_427;
                int32_t l_448 = 0L;
                int32_t **l_465 = &l_455;
                union U1 **l_467 = &l_408;
                for (l_386 = (-29); (l_386 < 27); l_386 += 7)
                { /* block id: 250 */
                    int32_t l_447 = (-10L);
                    int32_t *l_453 = &l_376;
                    int32_t **l_452 = &l_453;
                    const uint8_t l_486 = 0xEAL;
                    (*l_452) = func_61((func_74(p_59, l_444, l_446, ((p_59 < l_447) ^ l_448), &l_427) == ((((uint16_t)p_59 >> (uint16_t)l_451) != l_451) != p_59)), l_446);
                    /* statement id: 251 */
                    assert (l_453 == 0);
                    l_454 = (void*)0;
                    /* statement id: 252 */
                    assert (l_454 == 0);
                    if (((p_59 > (((!(l_448 <= (((int16_t)((uint16_t)0x1BEBL + (uint16_t)((uint16_t)(&l_453 == l_465) - (uint16_t)p_59)) % (int16_t)p_59) >= (&l_422 == &p_57)))) > l_451) | 0x3459CE88L)) || 2L))
                    { /* block id: 253 */
                        uint64_t l_466 = 0x78A2021EEE7737C8LL;
                        (*l_465) = func_61(l_466, &p_57);
                        if (p_59)
                            continue;
                    }
                    else
                    { /* block id: 256 */
                        union U1 ***l_468 = &l_407;
                        int32_t *l_487 = &l_376;
                        if (p_59)
                            break;
                        (*l_468) = l_467;
                        (*l_487) = ((int16_t)((int32_t)p_59 % (int32_t)p_59) / (int16_t)((uint32_t)((uint64_t)l_477 + (uint64_t)((((((int16_t)((int16_t)(-9L) << (int16_t)14) << (int16_t)((uint32_t)l_484 % (uint32_t)p_59)) < ((~p_59) && (p_59 || l_486))) == 65535UL) ^ p_59) > 0xC7195CB3L)) % (uint32_t)0x1A385CBBL));
                    }
                }
            }
            for (l_386 = 6; (l_386 >= 54); l_386++)
            { /* block id: 265 */
                l_490 = p_59;
            }
            l_491 = l_491;
            if (l_379)
                goto lbl_493;
        }
        (**p_60) = __builtin_parityll(((uint16_t)((int64_t)((p_59 || p_59) ^ ((uint16_t)2UL - (uint16_t)p_59)) - (int64_t)(l_500 == l_503)) + (uint16_t)(func_89(p_59, l_505, (**l_500), (*p_60), l_506) || p_59)));
    }
    else
    { /* block id: 272 */
        const int32_t *l_508 = &l_376;
        const int32_t **l_507 = &l_508;
        union U1 **l_511 = &l_408;
        uint64_t l_543 = 18446744073709551615UL;
        int32_t l_562 = 1L;
        float * const *l_573 = &l_427;
        float ** const l_582 = &l_427;
        int32_t *l_590 = &l_376;
lbl_534:
        (*l_507) = p_56;
        /* statement id: 273 */
        assert (l_508 == 0);
        if (l_505.f4)
        { /* block id: 274 */
            int64_t l_512 = 0x0332F5C83813D3AFLL;
            float * const *l_519 = &l_427;
            int32_t *l_538 = &l_376;
            float ****l_541 = &l_501;
            l_512 = (((uint16_t)p_59 << (uint16_t)6) ^ (l_511 != (void*)0));
            if (p_59)
            { /* block id: 276 */
                union U1 **l_517 = &l_408;
                const struct S0 l_520 = {0x8.81DE10p-76,-1,0x86206739512A2896LL,-0x1.3p+1,-1};
                int32_t *l_521 = &l_376;
                (*l_521) = ((uint16_t)((uint32_t)p_59 / (uint32_t)p_59) + (uint16_t)((l_511 == l_517) | ((p_59 | 0x977FC4C1L) <= func_89(p_59, l_505, l_519, (*p_58), l_520))));
                (*l_521) = p_59;
            }
            else
            { /* block id: 279 */
                const float **l_522 = (void*)0;
                int32_t l_526 = 0L;
                int32_t *l_530 = &l_526;
                const uint32_t l_531 = 0UL;
                int32_t ****l_537 = (void*)0;
                int32_t *****l_536 = &l_537;
                if ((p_59 < func_113(l_512, l_522, p_59)))
                { /* block id: 280 */
                    struct S0 l_525 = {0xF.C5F551p+33,-0,0x72F857729BDC5D14LL,0x1.C910CAp+92,-0};
                    struct S0 *l_524 = &l_525;
                    struct S0 **l_523 = &l_524;
                    (*l_523) = &l_505;
                    /* statement id: 281 */
                    assert (l_524 == &l_505);
                    return l_526;
                }
                else
                { /* block id: 283 */
                    float **l_529 = &l_427;
                    for (l_376 = (-26); (l_376 < (-27)); --l_376)
                    { /* block id: 286 */
                        l_530 = func_61(p_59, l_529);
                        /* statement id: 287 */
                        assert (l_530 == 0);
                    }
                    /* facts after for loop */
                    assert (l_530 == 0 || l_530 == &l_526);
                    l_526 = (&p_56 != (*l_501));
                }
                /* facts after branching */
                assert (l_530 == 0 || l_530 == &l_526);
                (**p_58) = l_531;
                for (l_376 = (-3); (l_376 >= 9); l_376++)
                { /* block id: 294 */
                    const int32_t l_535 = 0L;
                    if (l_505.f4)
                        goto lbl_534;
                    if (l_535)
                        continue;
                }
                (*l_536) = &l_371;
                /* statement id: 298 */
                assert (l_537 == &l_371);
            }
            (*l_538) = l_512;
            for (l_409.f0 = 2; (l_409.f0 == 19); l_409.f0 += 1)
            { /* block id: 303 */
                float *****l_542 = &l_541;
                (*l_407) = (*l_511);
                (*l_542) = l_541;
                l_543 = p_59;
            }
        }
        else
        { /* block id: 308 */
            uint32_t l_544 = 0x7E35E3FCL;
            int64_t l_560 = 2L;
            float **l_566 = &l_427;
            int32_t *l_589 = &l_562;
            if (l_544)
            { /* block id: 309 */
                return p_59;
            }
            else
            { /* block id: 311 */
                int64_t l_555 = 0x3514E3EE09CF0BD4LL;
                float * const *l_561 = (void*)0;
                const float ** const l_581 = &l_445;
                int32_t *l_587 = &l_376;
lbl_578:
                (**p_58) = (-(float)(**p_60));
lbl_588:
                (*l_507) = p_56;
                /* statement id: 313 */
                assert (l_508 == 0);
                (**l_502) = 0x4.E175A3p-88;
                for (l_376 = (-1); (l_376 != (-9)); l_376--)
                { /* block id: 317 */
                    float *****l_550 = (void*)0;
                    int32_t l_558 = 0x5FA9EE56L;
                    const float **l_563 = &l_445;
                    for (l_409.f1 = 0; (l_409.f1 > 13); l_409.f1++)
                    { /* block id: 320 */
                        union U1 **l_571 = &l_408;
                        int32_t l_572 = 0x9CEDBF01L;
                        int32_t *l_574 = &l_572;
                        l_562 = (p_59 <= (((void*)0 != l_550) > ((int16_t)(((uint64_t)__builtin_ctzll((l_555 || ((int32_t)(p_59 && (((l_558 ^ func_105((0x91B6409FL & p_59), l_560, l_555, (*p_58), l_561)) != 18446744073709551615UL) >= p_59)) - (int32_t)p_59))) % (uint64_t)18446744073709551607UL) <= p_59) >> (int16_t)l_560)));
                        (*l_507) = func_61(func_113(p_59, l_563, ((uint32_t)p_59 / (uint32_t)l_555)), l_566);
                        /* statement id: 322 */
                        assert (l_508 == 0);
                        (*l_574) = ((int32_t)(((uint32_t)(l_571 == &l_408) / (uint32_t)(func_105(l_572, p_59, p_59, (*p_58), l_573) ^ l_558)) >= l_560) - (int32_t)7L);
                        (*l_507) = func_61(l_558, (**l_500));
                    }
                    /* facts after for loop */
                                        for (l_543 = 0; (l_543 < 29); l_543 += 4)
                    { /* block id: 328 */
                        int32_t *l_577 = &l_562;
                        (*l_577) = (__builtin_bswap64(p_59) > l_560);
                        (*l_577) = p_59;
                    }
                    if (l_555)
                    { /* block id: 332 */
                        int64_t l_580 = (-1L);
                        (*l_507) = func_61(l_560, &p_57);
                        /* statement id: 333 */
                        assert (l_508 == 0);
                        if (l_560)
                            break;
                        if (l_505.f4)
                            goto lbl_578;
                        (**l_502) = ((((+(((l_558 != l_580) < ((*p_57) > func_74(p_59, l_581, l_566, p_59, l_582))) != 0x4.F2559Cp-55)) > l_560) > 0x3.F48289p+53) < l_558);
                    }
                    else
                    { /* block id: 337 */
                        float ***l_585 = (void*)0;
                        int32_t *l_586 = &l_562;
                        (*l_586) = ((int16_t)((void*)0 != l_585) >> (int16_t)6);
                        (*l_507) = l_587;
                        /* statement id: 339 */
                        assert (l_508 == &l_376);
                        if (l_505.f1)
                            goto lbl_588;
                    }
                    l_589 = (void*)0;
                    /* statement id: 342 */
                    assert (l_589 == 0);
                }
                /* facts after for loop */
                assert (l_508 == &l_376 || l_508 == 0);
            }
            /* facts after branching */
            assert (l_508 == &l_376 || l_508 == 0);
            assert (l_589 == 0 || l_589 == &l_562);
            return p_59;
        }
        if (l_379)
            goto lbl_534;
        (*l_590) = 2L;
    }
    (*l_500) = (*l_500);
    if ((((int16_t)((0x6CD7L || ((int16_t)((uint32_t)__builtin_ctz((func_74(p_59, &l_445, (**l_500), l_420, (*l_501)) && l_597)) % (uint32_t)(-3L)) - (int16_t)p_59)) > p_59) >> (int16_t)p_59) | p_59))
    { /* block id: 351 */
        uint64_t l_598 = 1UL;
        union U1 ** const *l_599 = &l_407;
        float * const *l_608 = &l_427;
        const struct S0 l_609 = {-0x1.6p+1,-1,0xB22305750D7EFAC0LL,-0x3.Cp+1,0};
        int32_t l_614 = 0x042FC192L;
        const uint16_t l_626 = 8UL;
        int32_t *l_628 = (void*)0;
        if (((l_598 ^ (&l_407 != l_599)) >= ((uint16_t)((l_598 >= (0UL < (((uint64_t)((int16_t)(l_598 & ((int16_t)p_59 / (int16_t)((func_89(p_59, l_505, l_608, (*p_60), l_609) ^ l_598) && 0x14C9L))) >> (int16_t)14) - (uint64_t)l_609.f1) | 0xCD342261DB9A2258LL))) & (-5L)) + (uint16_t)l_609.f1)))
        { /* block id: 352 */
            int32_t **l_610 = (void*)0;
            int32_t **l_611 = (void*)0;
            int32_t *l_613 = (void*)0;
            int32_t **l_612 = &l_613;
            (*l_612) = p_56;
            return p_59;
        }
        else
        { /* block id: 355 */
            const int32_t **l_615 = (void*)0;
            int32_t **l_616 = (void*)0;
            int32_t *l_618 = &l_376;
            int32_t **l_617 = &l_618;
            int32_t l_621 = 0xE4642CE6L;
            uint64_t l_627 = 0UL;
            const float ** const l_629 = &l_445;
            l_614 = 0xA.A5B732p+14;
            (*l_617) = p_56;
            /* statement id: 357 */
            assert (l_618 == 0);
            if ((__builtin_ffsl((p_59 && ((-1L) == p_59))) | (((int16_t)(l_621 | 0x2872L) % (int16_t)((int16_t)(0xACB5062E5400C037LL > (((int32_t)(l_626 ^ p_59) % (int32_t)p_59) && p_59)) - (int16_t)l_609.f2)) == l_627)))
            { /* block id: 358 */
                float **l_630 = (void*)0;
                int32_t l_631 = 0x5FD2A935L;
                int32_t l_638 = 0x76162333L;
                l_628 = (void*)0;
                l_631 = func_74(p_59, l_629, l_630, p_59, (*l_501));
                for (l_631 = (-5); (l_631 != 13); l_631 += 9)
                { /* block id: 363 */
                    (*l_617) = p_56;
                    l_638 = (p_59 & ((uint16_t)((int32_t)p_59 / (int32_t)p_59) >> (uint16_t)p_59));
                }
            }
            else
            { /* block id: 367 */
                uint8_t l_643 = 0xECL;
                int32_t *l_644 = (void*)0;
                if (p_59)
                { /* block id: 368 */
                    uint16_t l_645 = 65528UL;
                    l_376 = ((uint16_t)(p_59 | 3L) >> (uint16_t)6);
                    for (l_409.f1 = 0; (l_409.f1 < 53); l_409.f1 += 1)
                    { /* block id: 372 */
                        if (l_643)
                            break;
                    }
                    /* facts after for loop */
                                        l_644 = l_644;
                    return l_645;
                }
                else
                { /* block id: 377 */
                    return p_59;
                }
            }
        }
    }
    else
    { /* block id: 382 */
        uint8_t l_653 = 0UL;
        uint16_t l_655 = 0x227BL;
        int32_t l_658 = 0xBAA9BFF9L;
        int32_t l_659 = 3L;
        if (p_59)
        { /* block id: 383 */
            int32_t l_656 = 0x4794DED7L;
            float *l_657 = &l_518;
            l_659 = ((2UL && __builtin_ffsll(l_646)) < (p_59 | ((p_59 ^ 0L) != ((int16_t)func_105(__builtin_clz(((int32_t)((int32_t)((&l_371 != &l_371) & ((func_105(l_653, p_59, l_654, (*p_58), (**l_500)) >= l_653) != l_655)) % (int32_t)l_656) + (int32_t)0xF521F7CCL)), p_59, p_59, l_657, (*l_501)) + (int16_t)l_658))));
        }
        else
        { /* block id: 385 */
            int32_t *l_660 = &l_376;
            const int32_t *l_662 = &l_659;
            const int32_t **l_661 = &l_662;
            (*l_661) = l_660;
            /* statement id: 386 */
            assert (l_662 == &l_376);
            (*l_660) = p_59;
        }
    }
    l_376 = ((uint16_t)l_665 >> (uint16_t)11);
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : l_86
 * writes: l_52
 */
static float * func_61(uint8_t  p_62, float ** p_63)
{ /* block id: 209 */
    const uint8_t l_365 = 0x93L;
    int32_t *l_366 = (void*)0;
    int32_t **l_367 = &l_366;
    (**p_63) = l_365;
    (*l_367) = l_366;
    return l_366;
    /* statement id: 212 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_74(int32_t  p_75, const float ** const  p_76, float ** p_77, int64_t  p_78, float ** const  p_79)
{ /* block id: 39 */
    float l_104 = 0xE.51CA2Ap-38;
    const float *l_103 = &l_104;
    int32_t l_112 = 1L;
    const float l_173 = 0x7.041E7Dp+16;
    float l_177 = (-0x1.Dp+1);
    float *l_176 = &l_177;
    float **l_175 = &l_176;
    float l_323 = 0x1.Dp+1;
    int32_t *l_328 = &l_112;
    int32_t **l_327 = &l_328;
    union U1 l_341 = {0xDFD2L};
    union U1 *l_340 = &l_341;
    union U1 **l_342 = &l_340;
    for (p_78 = 0; (p_78 > 7); p_78++)
    { /* block id: 42 */
        uint8_t l_117 = 0x62L;
        const float **l_118 = &l_103;
        float *l_128 = &l_104;
        uint8_t l_174 = 0x46L;
        const struct S0 l_179 = {0x3.091CAAp-94,0,0UL,-0x7.5p-1,1};
        int32_t ****l_335 = (void*)0;
        int32_t ***l_337 = &l_327;
        float ***l_339 = &l_175;
        float ****l_338 = &l_339;
        if (func_89(p_75, func_95(((((((l_103 == (void*)0) || (6UL >= (((((((func_105((!(l_112 >= func_113((((-10L) == p_75) != __builtin_clz(l_117)), l_118, p_78))), p_78, l_112, l_128, p_77) && l_112) <= p_78) < 0x5AECL) || p_75) ^ l_174) && l_112) > l_117))) > p_78) && 0x2A41L) && 0xB3ED55EDL) == l_174), l_128, l_175, l_112, l_174), &l_176, (*l_175), l_179))
        { /* block id: 166 */
            uint32_t l_303 = 0xED5AC8D5L;
            float *l_309 = &l_104;
            int32_t l_324 = (-6L);
            for (p_75 = 0; (p_75 < (-12)); p_75--)
            { /* block id: 169 */
                float l_307 = (-0x1.4p+1);
                int32_t l_308 = 0x77040BD1L;
                int32_t *l_317 = (void*)0;
                int32_t *l_318 = &l_112;
                (**p_79) = ((float)l_303 + (float)(+(((float)(func_89(p_75, func_95((((l_308 || (((l_308 == (p_79 != (void*)0)) != p_78) || (__builtin_clzl((0x8943D24EL >= 0x0141AF60L)) == p_78))) | 0xEE27L) ^ l_308), l_309, &l_176, l_179.f1, l_308), &l_128, (*p_79), l_179) != l_112) - (float)l_303) != l_303)));
                for (l_112 = 0; (l_112 >= (-2)); l_112 -= 7)
                { /* block id: 173 */
                    for (l_117 = 0; (l_117 == 59); l_117++)
                    { /* block id: 176 */
                        int32_t **l_314 = (void*)0;
                        int32_t *l_316 = &l_308;
                        int32_t **l_315 = &l_316;
                        if (l_112)
                            break;
                        (*l_315) = &l_308;
                        (*l_315) = l_128;
                        /* statement id: 179 */
                        assert (l_316 == &l_104);
                    }
                }
                (*l_318) = l_112;
                for (l_117 = 0; (l_117 != 35); l_117++)
                { /* block id: 185 */
                    for (l_174 = (-26); (l_174 < 45); l_174 += 4)
                    { /* block id: 188 */
                        (**p_79) = __builtin_ffsll(l_179.f2);
                        (*l_318) = ((p_75 == p_75) == __builtin_ffsll(p_75));
                    }
                    l_324 = l_179.f1;
                }
            }
            if (l_112)
                break;
            (**l_327) = ((p_78 ^ ((uint16_t)((void*)0 != l_327) << (uint16_t)13)) < (**l_327));
        }
        else
        { /* block id: 197 */
            (*l_328) = p_78;
            (*l_327) = (*l_327);
            (**l_327) = (**l_327);
        }
        (***l_337) = ((p_78 > p_78) | ((uint64_t)(__builtin_popcount(p_75) | (((int16_t)((int32_t)((((((((((void*)0 == l_335) == __builtin_ctz((*l_328))) & (-(uint16_t)(__builtin_ia32_crc32qi((&l_327 == l_337), p_78) >= 1UL))) || 0UL) | 0x5DD1L) <= 4UL) <= (***l_337)) || (***l_337)) ^ (*l_328)) + (int32_t)(***l_337)) << (int16_t)1) != (***l_337))) % (uint64_t)(-1L)));
        (*l_338) = &p_76;
        /* statement id: 203 */
        assert (l_339 == &p_76);
    }
    (*l_176) = (**l_327);
    (*l_342) = l_340;
    (**p_79) = (((float)0x0.3p+1 / (float)__builtin_ia32_crc32qi((**l_327), p_75)) <= ((float)((float)__builtin_parity((((uint64_t)((((uint32_t)(~((uint16_t)((-(uint32_t)((*l_327) != (*l_327))) > (((((int32_t)((**l_327) < ((uint64_t)0x94AB442EEB04213BLL % (uint64_t)((uint32_t)((int64_t)((**l_327) ^ 7L) % (int64_t)(*l_328)) + (uint32_t)(-1L)))) / (int32_t)p_75) ^ 0x0CDF28E5L) & 1UL) < (*l_328))) >> (uint16_t)13)) % (uint32_t)0xB83D353EL) == (*l_328)) && 0x587FE98B080ABBFALL) + (uint64_t)(*l_328)) < 4UL)) + (float)(**p_79)) + (float)0x1.Ap+1));
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads : l_52 l_428
 * writes: l_52 l_428
 */
static int32_t  func_89(int32_t  p_90, const struct S0  p_91, float * const * p_92, float * const  p_93, const struct S0  p_94)
{ /* block id: 79 */
    uint64_t l_180 = 3UL;
    int32_t l_188 = 0x948D72D2L;
    int32_t *l_187 = &l_188;
    int32_t **l_186 = &l_187;
    float *l_195 = (void*)0;
    float **l_194 = &l_195;
    int32_t ****l_227 = (void*)0;
    int32_t l_246 = 0x38398E1DL;
    const float l_254 = 0xB.E8BE2Ep+89;
    const float *l_253 = &l_254;
    const float **l_252 = &l_253;
    (**p_92) = (l_180 >= ((float)((float)0x5.C55A7Bp-86 / (float)((!(l_186 == &l_187)) >= (**l_186))) / (float)(-(float)(**p_92))));
    if (((p_94.f2 != p_90) > 0L))
    { /* block id: 81 */
        int32_t l_193 = 0x3CEE9F7DL;
        float **l_196 = &l_195;
        int32_t *l_202 = &l_188;
        int32_t ****l_228 = (void*)0;
        (*l_186) = p_93;
        /* statement id: 82 */
        //assert (l_187 == &l_177 || l_187 == &l_52 || l_187 == &l_428);
        if (l_188)
            goto lbl_190;
lbl_190:
        (*p_93) = (&p_93 != (void*)0);
        for (l_180 = 0; (l_180 != 50); ++l_180)
        { /* block id: 87 */
            int32_t l_214 = 0xC7DB9AC0L;
            float l_231 = 0x5.4D0DCDp-55;
            const float *l_230 = &l_231;
            const float **l_229 = &l_230;
            uint64_t l_232 = 0xED63EAABCA9CE858LL;
            if (l_193)
                break;
            l_196 = l_194;
            for (l_193 = 0; (l_193 > 3); l_193 += 3)
            { /* block id: 92 */
                float **l_201 = (void*)0;
                int32_t *l_220 = &l_188;
                for (l_188 = (-1); (l_188 > (-22)); l_188--)
                { /* block id: 95 */
                    int32_t * const *l_206 = &l_187;
                    int32_t * const **l_205 = &l_206;
                    int32_t * const *l_233 = (void*)0;
                }
            }
        }
    }
    else
    { /* block id: 116 */
        const float l_250 = 0x0.55BC50p-15;
        int32_t l_251 = 0x6CBEDFB4L;
        int32_t *****l_280 = (void*)0;
        float * const *l_288 = &l_195;
        int32_t *l_293 = &l_246;
        const int32_t **l_297 = (void*)0;
        const int32_t ***l_296 = &l_297;
        const int32_t ****l_295 = &l_296;
        if ((-(int32_t)p_94.f1))
        { /* block id: 117 */
            (**p_92) = func_113(l_251, l_252, p_94.f1);
        }
        else
        { /* block id: 119 */
            float * const *l_263 = &l_195;
            int32_t l_275 = 0x1B1B48E1L;
            float *l_286 = (void*)0;
            for (p_90 = (-12); (p_90 != 29); p_90++)
            { /* block id: 122 */
                float *l_262 = (void*)0;
                int32_t l_274 = 0x514E9446L;
                for (l_188 = 5; (l_188 <= 1); l_188--)
                { /* block id: 125 */
                    if (((uint16_t)0x9F12L >> (uint16_t)p_94.f1))
                    { /* block id: 126 */
                        int32_t **l_261 = &l_187;
                        (*l_261) = p_93;
                        /* statement id: 127 */
                        //assert (l_187 == &l_177 || l_187 == &l_52 || l_187 == &l_428);
                        (**l_261) = p_94.f4;
                        (*l_187) = p_94.f2;
                        if ((**l_261))
                            continue;
                    }
                    else
                    { /* block id: 131 */
                        int32_t **l_264 = &l_187;
                        (*l_264) = p_93;
                        /* statement id: 132 */
                        //assert (l_187 == &l_177 || l_187 == &l_52 || l_187 == &l_428);
                    }
                    /* facts after branching */
                    //assert (l_187 == &l_177 || l_187 == &l_52 || l_187 == &l_428);
                    for (l_251 = 6; (l_251 < (-2)); l_251 -= 4)
                    { /* block id: 136 */
                        int64_t l_273 = (-10L);
                        l_275 = ((int32_t)p_94.f1 % (int32_t)((int16_t)((int16_t)l_273 << (int16_t)l_274) >> (int16_t)3));
                    }
                }
            }
            /* facts after for loop */
            //assert (l_187 == &l_177 || l_187 == &l_188 || l_187 == &l_52 || l_187 == &l_428);
            if ((p_94.f2 != (l_275 || p_91.f1)))
            { /* block id: 141 */
                uint8_t l_283 = 0UL;
                float **l_291 = &l_195;
                int32_t *****l_294 = (void*)0;
                for (l_188 = 0; (l_188 < 23); l_188++)
                { /* block id: 144 */
                    uint32_t l_285 = 4294967295UL;
                    const float ***l_292 = &l_252;
                    for (l_246 = 10; (l_246 == (-25)); l_246--)
                    { /* block id: 147 */
                        int64_t l_284 = 0x2AE1A41AF9FBB45ELL;
                        float *l_287 = (void*)0;
                        int32_t *l_289 = (void*)0;
                        int32_t *l_290 = &l_251;
                        l_280 = l_280;
                        l_275 = (((uint16_t)p_94.f4 - (uint16_t)p_94.f2) <= l_283);
                        (*l_290) = ((l_284 > 0x093934F9L) < l_283);
                    }
                    (*l_292) = l_291;
                    /* statement id: 152 */
                    assert (l_252 == &l_195);
                    l_275 = p_91.f2;
                    (*l_186) = (void*)0;
                    /* statement id: 154 */
                    assert (l_187 == 0);
                }
                /* facts after for loop */
                //assert (l_187 == 0 || l_187 == &l_177 || l_187 == &l_188 || l_187 == &l_52 || l_187 == &l_428);
                assert (l_252 == &l_195 || l_252 == &l_253);
                (*l_186) = l_293;
                /* statement id: 156 */
                assert (l_187 == &l_246);
                l_295 = (void*)0;
                /* statement id: 157 */
                assert (l_295 == 0);
            }
            else
            { /* block id: 158 */
                uint8_t l_298 = 0x96L;
                (*l_187) = l_298;
                (*l_187) = l_275;
            }
            /* facts after branching */
            //assert (l_187 == &l_177 || l_187 == &l_188 || l_187 == &l_246 || l_187 == &l_52 || l_187 == &l_428);
            assert (l_252 == &l_195 || l_252 == &l_253);
            assert (l_295 == &l_296 || l_295 == 0);
        }
        /* facts after branching */
        //assert (l_187 == &l_177 || l_187 == &l_188 || l_187 == &l_246 || l_187 == &l_52 || l_187 == &l_428);
        assert (l_252 == &l_195 || l_252 == &l_253);
        assert (l_295 == &l_296 || l_295 == 0);
        (*l_293) = 0xE2910136L;
    }
    /* facts after branching */
    //assert (l_187 == &l_177 || l_187 == &l_188 || l_187 == &l_246 || l_187 == &l_52 || l_187 == &l_428);
    assert (l_252 == &l_195 || l_252 == &l_253);
    return p_94.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S0  func_95(int32_t  p_96, float * p_97, float ** p_98, int32_t  p_99, int32_t  p_100)
{ /* block id: 77 */
    const struct S0 l_178 = {0x0.7p+1,0,0UL,-0x1.2p+1,0};
    return l_178;
}


/* ------------------------------------------ */
/* 
 * reads : l_52
 * writes: l_52
 */
inline static uint32_t  func_105(uint16_t  p_106, int32_t  p_107, uint32_t  p_108, float * p_109, float * const * p_110)
{ /* block id: 49 */
    uint32_t l_129 = 18446744073709551610UL;
    int32_t l_145 = (-3L);
    int32_t *l_144 = &l_145;
    uint64_t l_148 = 0xA0D674323298C059LL;
    const int64_t l_158 = 0x0F57B567EB876032LL;
    uint32_t l_166 = 1UL;
    if (l_129)
    { /* block id: 50 */
        int32_t l_131 = 9L;
        int32_t *l_130 = &l_131;
        const float **l_138 = (void*)0;
        (*l_130) = p_108;
        p_107 = 0x28903759L;
        for (l_131 = 23; (l_131 >= (-10)); l_131--)
        { /* block id: 55 */
            const uint32_t l_139 = 18446744073709551612UL;
            p_107 = ((int16_t)(func_113(((uint16_t)l_129 - (uint16_t)((p_107 <= p_106) <= 0xE8B8L)), l_138, l_139) >= l_129) << (int16_t)8);
        }
        (*l_130) = ((((uint64_t)(!(~((void*)0 != l_144))) / (uint64_t)((uint64_t)(*l_130) / (uint64_t)(*l_144))) <= l_148) | ((uint32_t)(__builtin_ctzll(((uint32_t)((uint16_t)(p_107 & p_107) + (uint16_t)((*l_130) <= ((int16_t)(+(*l_130)) >> (int16_t)(*l_144)))) - (uint32_t)l_158)) || (-5L)) % (uint32_t)(*l_144)));
    }
    else
    { /* block id: 59 */
        int32_t **l_161 = &l_144;
        (*l_144) = ((int64_t)p_106 % (int64_t)p_107);
        (*l_161) = &p_107;
        /* statement id: 61 */
        assert (l_144 == &p_107);
        (**l_161) = (((uint64_t)__builtin_ctzll(p_106) / (uint64_t)p_107) || ((int16_t)(p_106 && p_108) << (int16_t)2));
    }
    /* facts after branching */
    assert (l_144 == &p_107 || l_144 == &l_145);
    (*l_144) = ((0x0BB395F0L && l_166) ^ 0L);
    for (l_148 = 0; (l_148 >= 57); l_148 += 2)
    { /* block id: 67 */
        for (p_107 = 0; (p_107 != (-28)); p_107 -= 7)
        { /* block id: 70 */
            const int32_t *l_171 = &l_145;
            const int32_t **l_172 = (void*)0;
            l_171 = l_171;
            return p_106;
        }
        (*p_109) = (*p_109);
    }
    return p_107;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_113(int32_t  p_114, const float ** p_115, const uint32_t  p_116)
{ /* block id: 43 */
    float l_119 = 0x3.EA4F54p+4;
    int32_t l_120 = (-1L);
    int32_t *l_122 = &l_120;
    int32_t **l_121 = &l_122;
    uint64_t l_125 = 0x0AFAA93538B87B6FLL;
    l_120 = l_120;
    (*l_121) = &l_120;
    (**l_121) = ((int16_t)l_125 + (int16_t)(*l_122));
    (**l_121) = ((uint16_t)(((void*)0 == (*l_121)) > 0x26B30262L) >> (uint16_t)8);
    return p_114;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 191
   depth: 1, occurrence: 7
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 8
breakdown:
   indirect level: 0, occurrence: 7
   indirect level: 1, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 3
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 14
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 29

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 238
   depth: 2, occurrence: 39
   depth: 3, occurrence: 15
   depth: 4, occurrence: 7
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 3
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 5
   depth: 15, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 3
   depth: 32, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 204

XXX times a variable address is taken: 179
XXX times a pointer is dereferenced on RHS: 77
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 25
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 19
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 458

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 765
   level: 2, occurrence: 312
   level: 3, occurrence: 48
   level: 4, occurrence: 36
XXX number of pointers point to pointers: 125
XXX number of pointers point to scalars: 71
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 29.4
XXX average alias set size: 1.19

XXX times a non-volatile is read: 725
XXX times a non-volatile is write: 280
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 208
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 39
   depth: 1, occurrence: 27
   depth: 2, occurrence: 37
   depth: 3, occurrence: 33
   depth: 4, occurrence: 31
   depth: 5, occurrence: 41

XXX percentage a fresh-made variable is used: 24.9
XXX percentage an existing variable is used: 75.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

