/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2815527016
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int64_t  f0;
   int8_t * f1;
   int8_t * f2;
   unsigned f3 : 17;
   int16_t  f4;
};

union U1 {
   uint8_t  f0;
   int32_t  f1;
   unsigned f2 : 26;
   uint64_t  f3;
};

union U2 {
   unsigned f0 : 16;
   signed f1 : 30;
   int8_t * f2;
   uint32_t  f3;
   uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_33(void);
inline static int32_t  func_40(union U2  p_41, int8_t * p_42, uint16_t  p_43, uint8_t  p_44, int64_t  p_45);
inline static union U2  func_46(union U1  p_47, uint32_t  p_48, uint32_t  p_49);
static union U1  func_50(int8_t * p_51, const uint8_t  p_52);
static int8_t * func_53(int16_t  p_54);
inline static uint32_t  func_65(int32_t * p_66);
inline static int32_t  func_75(const int8_t * p_76, int32_t * p_77, int32_t * p_78, int8_t  p_79, int8_t * p_80);
static const int8_t * func_81(int8_t  p_82);
inline static int32_t * func_93(union U1  p_94, int64_t  p_95, int16_t  p_96);
static union U1  func_97(uint16_t  p_98, int8_t * p_99, const uint32_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_33(void)
{ /* block id: 36 */
    int32_t l_34 = 0x311E2DB8L;
    int8_t l_514 = 0x99L;
    int8_t *l_513 = &l_514;
    int32_t l_548 = 0x6B0D7B6BL;
    uint64_t l_554 = 0xB816584603DDFA52LL;
    union U2 l_620 = {0x11580ADBL};
    union U2 *l_619 = &l_620;
    union U2 **l_618 = &l_619;
    union U2 ***l_617 = &l_618;
    int32_t *l_633 = &l_548;
    int32_t **l_632 = &l_633;
    union U0 **l_892 = (void*)0;
    int32_t *l_893 = &l_34;
    uint8_t l_894 = 1UL;
    for (l_34 = 0; (l_34 >= (-16)); l_34 = safe_sub_func_int8_t_s_s(l_34, 1))
    { /* block id: 39 */
        int32_t l_37 = 0xEC58F553L;
        uint32_t l_529 = 4294967295UL;
        int32_t l_549 = 0xEB3B3921L;
        int32_t *l_550 = &l_549;
        union U0 **l_558 = (void*)0;
        float l_559 = (-0x4.3p+1);
        union U2 l_599 = {0x8ECA0DB1L};
        int8_t *l_600 = &l_514;
        union U2 ** const *l_682 = (void*)0;
        int32_t l_727 = 0xBC54EC6DL;
        float l_733 = 0x0.4p+1;
        int16_t l_778 = 0x5091L;
        union U1 l_799 = {0x00L};
        union U1 *l_798 = &l_799;
        uint32_t l_849 = 0x9E946E8EL;
        int32_t ***l_862 = (void*)0;
        int32_t ****l_861 = &l_862;
        int32_t *****l_860 = &l_861;
        union U1 l_878 = {0x85L};
        int32_t *l_887 = &l_878.f1;
        for (l_37 = 0; (l_37 >= 26); l_37 = safe_add_func_uint8_t_u_u(l_37, 1))
        { /* block id: 42 */
            const float l_471 = 0x1.3p-1;
            int16_t l_477 = 1L;
            int32_t l_479 = 7L;
            uint32_t l_484 = 0x8DD5268CL;
            int32_t l_521 = 0x8F538464L;
            int32_t *l_520 = &l_521;
            int64_t l_532 = 0x350B7AB3F356C055LL;
            (*l_520) &= func_40(func_46(func_50(func_53(l_34), l_34), (((2UL > l_477) & (!((((__builtin_bswap32(((l_34 | (l_479 || (safe_mod_func_int32_t_s_s(__builtin_parity((safe_div_func_uint32_t_u_u(l_479, 0xA266CB6DL))), 0x29963323L)))) > 0xC0ACD78A68BF895BLL)) | 0UL) | l_484) && l_37) <= l_34))) > l_484), l_477), l_513, l_37, l_34, l_34);
            for (l_484 = 15; (l_484 > 44); l_484++)
            { /* block id: 271 */
                uint64_t l_544 = 0xDC86D78697EFC4D0LL;
                for (l_479 = 0; (l_479 != 0); l_479 = safe_add_func_int16_t_s_s(l_479, 9))
                { /* block id: 274 */
                    int32_t l_526 = (-2L);
                    int32_t l_539 = 0x0EE6CEDDL;
                    if (((((l_526 > 0x07L) <= ((safe_mul_func_int8_t_s_s(l_37, __builtin_clzl((l_529 == __builtin_clz((*l_520)))))) ^ (l_526 && (*l_520)))) < (-1L)) && 0xD9ADC42FE442EC23LL))
                    { /* block id: 275 */
                        float l_531 = 0xF.8DBCE7p-70;
                        float *l_530 = &l_531;
                        int32_t *l_533 = &l_521;
                        int32_t *l_534 = &l_521;
                        int32_t *l_535 = &l_526;
                        int32_t l_536 = 0L;
                        int32_t *l_537 = &l_526;
                        int32_t *l_538 = (void*)0;
                        int32_t *l_540 = (void*)0;
                        int32_t *l_541 = &l_539;
                        int32_t *l_542 = &l_526;
                        int32_t *l_543 = &l_536;
                        (*l_530) = l_514;
                        if (l_532)
                            break;
                        if ((*l_520))
                            continue;
                        l_544++;
                    }
                    else
                    { /* block id: 280 */
                        uint64_t l_547 = 0x209DB0E4E1D57944LL;
                        if (l_514)
                            break;
                        if (l_547)
                            continue;
                        (*l_520) |= l_514;
                        (*l_520) = l_34;
                    }
                    l_548 &= __builtin_parityll(l_37);
                }
            }
            if (l_514)
                continue;
            l_549 ^= (l_529 ^ l_37);
        }
        (*l_550) = l_514;
        (*l_550) |= (safe_unary_minus_func_int64_t_s(func_65(&l_37)));
        if ((safe_sub_func_uint32_t_u_u((((*l_550) < ((*l_550) <= l_554)) != (*l_550)), (safe_unary_minus_func_int16_t_s((safe_add_func_uint64_t_u_u((l_34 | (&l_548 != (void*)0)), __builtin_ia32_crc32qi(((((l_558 != l_558) && 0x793A5BBB0BCBC0E3LL) == l_554) ^ (*l_550)), (*l_550)))))))))
        { /* block id: 294 */
            int16_t l_560 = 1L;
            int32_t l_561 = 1L;
            l_561 = (l_560 > l_554);
            (*l_550) = (-1L);
            if ((*l_550))
                continue;
            for (l_548 = 0; (l_548 == 18); l_548 = safe_add_func_int8_t_s_s(l_548, 5))
            { /* block id: 300 */
                int32_t *l_566 = &l_549;
                int8_t *l_567 = &l_514;
                float *l_573 = &l_559;
                if ((safe_sub_func_int16_t_s_s(func_75(&l_514, &l_37, l_566, (*l_566), l_567), (__builtin_clzll(__builtin_bswap64(l_514)) | (*l_550)))))
                { /* block id: 301 */
                    int32_t **l_568 = &l_566;
                    (*l_568) = &l_34;
                    /* statement id: 302 */
                    assert (l_566 == &l_34);
                }
                else
                { /* block id: 303 */
                    float *l_570 = &l_559;
                    (*l_570) = ((!l_34) > l_561);
                    if ((*l_550))
                        break;
                }
                /* facts after branching */
                assert (l_566 == &l_549 || l_566 == &l_34);
                (*l_573) = (safe_mul_func_float_f_f(l_34, l_560));
            }
        }
        else
        { /* block id: 309 */
            int32_t *l_576 = &l_37;
            int32_t l_631 = 0xCA2085ECL;
            union U2 **l_651 = &l_619;
            int8_t *l_670 = &l_514;
            union U1 l_675 = {246UL};
            int8_t l_685 = 1L;
            int32_t l_725 = (-1L);
            int32_t l_762 = 8L;
            union U0 ***l_791 = (void*)0;
            int32_t l_815 = 0x4A8E8B36L;
            int32_t *l_888 = &l_762;
            for (l_37 = 0; (l_37 != 8); l_37 = safe_add_func_int8_t_s_s(l_37, 2))
            { /* block id: 312 */
                int32_t **l_577 = (void*)0;
                int32_t **l_578 = &l_576;
                (*l_578) = l_576;
                (*l_578) = (*l_578);
                (*l_550) = (safe_mul_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u((safe_add_func_uint16_t_u_u(9UL, 3UL)), (safe_add_func_int32_t_s_s(0x40FB0CFAL, (safe_lshift_func_int8_t_s_s(((safe_rshift_func_int16_t_s_u((safe_mod_func_uint16_t_u_u((*l_576), (safe_lshift_func_uint16_t_u_u(((safe_mod_func_int16_t_s_s((safe_mul_func_int16_t_s_s(__builtin_parityll((*l_576)), func_40(l_599, l_600, l_34, l_514, (*l_576)))), (*l_576))) | 0UL), 11)))), 1)) >= (*l_550)), 0)))))), 0x60L));
            }
            for (l_549 = (-24); (l_549 > 23); l_549 = safe_add_func_int8_t_s_s(l_549, 4))
            { /* block id: 319 */
                int32_t *l_608 = &l_548;
                uint8_t l_664 = 0UL;
                const uint64_t l_667 = 0x28CA12C75C99B3F8LL;
                union U0 ** const *l_695 = &l_558;
                int32_t l_704 = (-9L);
                union U1 *l_797 = &l_675;
                union U1 **l_796 = &l_797;
            }
            if ((*l_576))
            { /* block id: 357 */
                union U1 **l_800 = (void*)0;
                union U1 **l_801 = &l_798;
                union U2 ****l_802 = (void*)0;
                int32_t l_820 = 2L;
                (*l_801) = l_798;
                if (((**l_632) & (((void*)0 == l_802) && (*l_550))))
                { /* block id: 359 */
                    int64_t l_807 = 0x9FCB48F1871BF9CCLL;
                    int64_t l_829 = (-1L);
                    float *l_834 = &l_559;
                    union U2 l_852 = {4294967295UL};
                    union U1 *l_875 = &l_675;
                    if ((safe_lshift_func_int16_t_s_u((safe_add_func_uint64_t_u_u(l_807, l_807)), (safe_rshift_func_int8_t_s_u((safe_add_func_int16_t_s_s(1L, ((*l_632) != &l_762))), (safe_unary_minus_func_uint64_t_u((((safe_sub_func_int16_t_s_s(l_815, (safe_mod_func_uint32_t_u_u((safe_mul_func_int8_t_s_s((*l_633), l_820)), func_65(&l_549))))) != l_807) != 0UL))))))))
                    { /* block id: 360 */
                        int32_t l_821 = 1L;
                        int8_t *l_853 = &l_685;
                        (*l_550) &= (l_821 > (safe_sub_func_int64_t_s_s((safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(((!((l_829 != (-5L)) && (((safe_div_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((((18446744073709551614UL < ((void*)0 != l_834)) > (safe_mod_func_int8_t_s_s(((safe_mul_func_uint16_t_u_u((((safe_sub_func_uint64_t_u_u((safe_div_func_uint64_t_u_u(0xFEC69BE24FCBCCFBLL, (safe_mul_func_int16_t_s_s((((safe_lshift_func_int8_t_s_s((safe_mod_func_uint64_t_u_u((l_849 == (safe_lshift_func_int8_t_s_s(func_40(l_852, l_853, l_821, (*l_576), l_820), 4))), l_821)), 5)) <= (**l_632)) != 0x41A81CB0F457C36FLL), l_820)))), 1UL)) ^ (*l_576)) >= 0xCB86D0A3L), l_820)) > (-1L)), (*l_576)))) >= 0x278CD21ED9DA02D8LL) | l_820), 4)), l_820)) ^ 0xE086F864AFC71183LL) != 0x7AC64666F7F3574DLL))) && l_820), l_820)), 0x31C7L)), 0x2451225828548A00LL)));
                        (*l_576) |= (l_821 != (l_821 <= (*l_633)));
                    }
                    else
                    { /* block id: 363 */
                        union U2 *l_854 = (void*)0;
                        union U2 *l_855 = &l_599;
                        int32_t l_873 = 0xB2664156L;
                        uint32_t l_874 = 0xBB401890L;
                        l_855 = l_854;
                        /* statement id: 364 */
                        assert (l_855 == 0);
                        (*l_550) &= ((**l_632) == ((safe_mul_func_int16_t_s_s((0xC7L > (((safe_div_func_uint16_t_u_u((((*l_633) & ((**l_632) >= ((void*)0 == l_860))) | ((safe_mul_func_int8_t_s_s((safe_mul_func_int8_t_s_s((l_820 > (safe_sub_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_u(l_829, (safe_mul_func_int8_t_s_s(((**l_632) <= (*l_633)), 254UL)))) < 0x05681FB2L), 4294967295UL))), 0x6CL)), 5L)) > l_873)), l_874)) ^ (*l_576)) >= 0x0AL)), l_874)) & l_820));
                    }
                    (*l_632) = (*l_632);
                    (*l_801) = l_875;
                    /* statement id: 368 */
                    assert (l_798 == &l_675);
                }
                else
                { /* block id: 369 */
                    int8_t *l_879 = (void*)0;
                    int32_t l_883 = (-1L);
                    int8_t *l_884 = &l_685;
                    for (l_820 = 0; (l_820 == 25); l_820 = safe_add_func_int16_t_s_s(l_820, 8))
                    { /* block id: 372 */
                        union U2 ****l_880 = &l_617;
                        int8_t l_885 = 0x40L;
                        int32_t *l_886 = &l_762;
                        l_886 = func_93(l_878, ((*l_576) ^ l_885), l_820);
                        /* statement id: 373 */
                        assert (l_886 == 0);
                        return l_885;
                    }
                    l_887 = (void*)0;
                    /* statement id: 376 */
                    assert (l_887 == 0);
                }
                /* facts after branching */
                assert (l_798 == &l_799 || l_798 == &l_675);
                assert (l_887 == 0 || l_887 == &l_878.f1);
            }
            else
            { /* block id: 378 */
                int32_t *l_891 = &l_815;
                (*l_550) = func_65(l_888);
                (*l_888) |= __builtin_ffs((safe_sub_func_int8_t_s_s(((l_891 != l_891) >= (*l_576)), (**l_632))));
            }
            /* facts after branching */
            assert (l_798 == &l_799 || l_798 == &l_675);
            assert (l_887 == 0 || l_887 == &l_878.f1);
        }
        /* facts after branching */
        //assert (l_798 == &l_799 || l_798 == dangling);
        assert (l_887 == 0 || l_887 == &l_878.f1);
    }
    (*l_632) = (*l_632);
    (*l_893) &= ((l_892 == l_892) || (**l_632));
    return l_894;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_40(union U2  p_41, int8_t * p_42, uint16_t  p_43, uint8_t  p_44, int64_t  p_45)
{ /* block id: 265 */
    int32_t l_515 = (-1L);
    int32_t l_519 = 0x586226D4L;
    l_519 |= (__builtin_popcount(l_515) <= ((__builtin_ffsl(l_515) | (!(*p_42))) == (safe_mul_func_uint16_t_u_u(p_44, 65535UL))));
    return l_515;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_46(union U1  p_47, uint32_t  p_48, uint32_t  p_49)
{ /* block id: 234 */
    uint8_t l_490 = 0xB3L;
    int32_t l_497 = 0x2231B274L;
    int32_t *l_496 = &l_497;
    union U1 l_510 = {0x85L};
    union U2 l_512 = {4294967293UL};
    for (p_48 = 0; (p_48 >= 15); p_48++)
    { /* block id: 237 */
        int32_t *l_495 = (void*)0;
        int8_t l_501 = 0L;
        int8_t *l_500 = &l_501;
    }
    for (l_490 = 15; (l_490 > 53); l_490 = safe_add_func_uint32_t_u_u(l_490, 7))
    { /* block id: 259 */
        int32_t *l_509 = &l_497;
        int32_t **l_511 = &l_496;
    }
    return l_512;
    /* statement id: 264 */
    //assert (func_46_rv.f2 == dangling);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_50(int8_t * p_51, const uint8_t  p_52)
{ /* block id: 227 */
    int32_t l_472 = 0xF5E08FB8L;
    union U1 l_476 = {3UL};
    for (l_472 = 4; (l_472 != (-18)); l_472 = safe_sub_func_uint16_t_u_u(l_472, 1))
    { /* block id: 230 */
        union U1 l_475 = {7UL};
        return l_475;
        /* statement id: 231 */
            }
    return l_476;
    /* statement id: 233 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t * func_53(int16_t  p_54)
{ /* block id: 43 */
    int64_t l_55 = (-3L);
    int32_t *l_56 = (void*)0;
    int32_t l_58 = 0xF1636717L;
    int32_t *l_57 = &l_58;
    int8_t l_372 = (-1L);
    int8_t *l_371 = &l_372;
    float l_413 = 0x1.5p-1;
    float *l_412 = &l_413;
    int32_t *l_414 = (void*)0;
    int32_t *l_415 = &l_58;
    int32_t *l_416 = &l_58;
    int32_t *l_417 = &l_58;
    int32_t *l_418 = &l_58;
    int32_t *l_419 = (void*)0;
    int32_t *l_420 = &l_58;
    int32_t *l_421 = &l_58;
    int32_t *l_422 = &l_58;
    int32_t *l_423 = &l_58;
    int32_t *l_424 = &l_58;
    int32_t *l_425 = &l_58;
    int32_t *l_426 = &l_58;
    int32_t *l_427 = &l_58;
    int32_t *l_428 = &l_58;
    int32_t *l_429 = &l_58;
    int32_t *l_430 = &l_58;
    int32_t l_431 = 0xED36738FL;
    int32_t *l_432 = &l_58;
    int32_t *l_433 = &l_58;
    int32_t *l_434 = &l_431;
    int32_t *l_435 = &l_58;
    int32_t l_436 = (-9L);
    int32_t *l_437 = (void*)0;
    int32_t *l_438 = &l_431;
    int32_t *l_439 = &l_431;
    int32_t *l_440 = &l_58;
    int32_t l_441 = 2L;
    int32_t *l_442 = &l_441;
    int32_t l_443 = (-8L);
    int32_t *l_444 = &l_436;
    int32_t *l_445 = &l_436;
    int32_t *l_446 = (void*)0;
    int32_t l_447 = (-1L);
    int32_t *l_448 = &l_441;
    int32_t l_449 = 0x760E0F07L;
    int32_t *l_450 = &l_447;
    int32_t *l_451 = &l_449;
    int32_t *l_452 = &l_441;
    int32_t *l_453 = (void*)0;
    int32_t *l_454 = (void*)0;
    int32_t *l_455 = (void*)0;
    int32_t *l_456 = (void*)0;
    int32_t *l_457 = &l_447;
    int32_t *l_458 = &l_436;
    int32_t *l_459 = &l_449;
    int32_t *l_460 = &l_441;
    int32_t *l_461 = (void*)0;
    int32_t *l_462 = &l_58;
    int32_t l_463 = (-1L);
    int32_t l_464 = 0xBB295AFFL;
    uint64_t l_465 = 0x46A55DB8D7A7FA21LL;
    int8_t *l_468 = &l_372;
    int8_t *l_469 = &l_372;
    int8_t *l_470 = (void*)0;
lbl_60:
    (*l_57) = l_55;
    if (__builtin_bswap64((*l_57)))
    { /* block id: 45 */
        int8_t *l_59 = (void*)0;
        return l_59;
        /* statement id: 46 */
        //assert (func_53_rv == 0);
    }
    else
    { /* block id: 47 */
        int32_t *l_67 = &l_58;
        int32_t l_370 = 0x3351E878L;
        union U0 l_379 = {-1L};
        union U0 *l_378 = &l_379;
        if (l_55)
            goto lbl_60;
        for (l_55 = 0; (l_55 < (-1)); l_55 = safe_sub_func_uint8_t_u_u(l_55, 1))
        { /* block id: 51 */
            int8_t l_368 = 0x53L;
            float l_373 = 0x9.F047D9p+34;
            int32_t *l_374 = &l_370;
            float *l_377 = &l_373;
            (*l_374) &= (((safe_lshift_func_int16_t_s_u((((func_65(l_67) ^ (l_368 & __builtin_parityll((&l_57 != &l_67)))) & (safe_unary_minus_func_uint32_t_u(p_54))) ^ p_54), 2)) > l_368) <= p_54);
            (*l_377) = (safe_mul_func_float_f_f((0xC.D83EAFp-18 > 0x4.F17E0Bp+18), (*l_374)));
        }
        l_378 = (void*)0;
        /* statement id: 205 */
        assert (l_378 == 0);
        for (l_370 = (-3); (l_370 > (-21)); l_370 = safe_sub_func_int32_t_s_s(l_370, 1))
        { /* block id: 208 */
            union U0 **l_388 = &l_378;
            int32_t l_389 = 0L;
            union U1 l_407 = {246UL};
            union U1 *l_406 = &l_407;
            union U1 **l_405 = &l_406;
            for (l_58 = (-19); (l_58 != 25); l_58 = safe_add_func_uint16_t_u_u(l_58, 1))
            { /* block id: 211 */
                int32_t l_391 = 0x9BA95C35L;
                for (l_55 = (-4); (l_55 != (-15)); l_55 = safe_sub_func_int64_t_s_s(l_55, 1))
                { /* block id: 214 */
                    int64_t l_390 = 1L;
                    int32_t *l_394 = &l_389;
                    int32_t **l_395 = &l_56;
                    union U1 * const *l_408 = &l_406;
                    (*l_394) = ((safe_lshift_func_int16_t_s_s((((void*)0 == l_388) != l_389), (l_390 && l_391))) | (safe_mul_func_uint16_t_u_u(l_390, p_54)));
                    (*l_395) = &l_370;
                    /* statement id: 216 */
                    assert (l_56 == &l_370);
                    (*l_394) = ((safe_lshift_func_int8_t_s_u(((~p_54) <= (p_54 <= p_54)), l_389)) >= (((safe_add_func_int8_t_s_s(p_54, p_54)) != (safe_div_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((l_405 == l_408), (~(safe_mod_func_int16_t_s_s(l_407.f0, 65535UL))))), p_54))) <= 0x5902L));
                    (*l_394) |= (*l_67);
                }
            }
            (*l_67) |= p_54;
        }
        /* facts after for loop */
        assert (l_56 == &l_370 || l_56 == 0);
    }
    /* facts after branching */
    //assert (l_56 == dangling || l_56 == 0);
    (*l_412) = p_54;
    l_465++;
    return l_470;
    /* statement id: 226 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_65(int32_t * p_66)
{ /* block id: 52 */
    int32_t l_68 = 0xF64DB2A9L;
    union U1 *l_274 = (void*)0;
    int64_t l_282 = 9L;
    int32_t *l_284 = &l_68;
    int32_t **l_283 = &l_284;
    int8_t l_301 = 1L;
    uint32_t l_367 = 5UL;
    for (l_68 = (-7); (l_68 < 22); l_68++)
    { /* block id: 55 */
        float l_73 = (-0x2.Cp-1);
        int32_t l_74 = 2L;
        int8_t *l_268 = (void*)0;
        const int32_t *l_273 = &l_74;
        const int32_t **l_272 = &l_273;
        union U1 l_276 = {0xB0L};
        union U1 *l_275 = &l_276;
        union U2 l_281 = {7UL};
        union U2 *l_280 = &l_281;
        union U2 **l_279 = &l_280;
        int32_t ***l_316 = &l_283;
        int32_t ****l_315 = &l_316;
        int32_t *****l_314 = &l_315;
        union U2 ** const **l_329 = (void*)0;
        int8_t l_335 = 0L;
        int16_t l_363 = 0x955FL;
        if ((safe_lshift_func_uint16_t_u_u(l_74, l_68)))
        { /* block id: 56 */
            uint8_t l_83 = 0xD3L;
            union U1 l_254 = {1UL};
            int8_t l_260 = 0x8FL;
            int8_t *l_259 = &l_260;
            int32_t *l_266 = &l_74;
            int32_t *l_267 = &l_74;
            (*p_66) &= func_75(func_81(l_83), &l_74, func_93(l_254, l_74, (safe_sub_func_int16_t_s_s(0L, __builtin_parityl((safe_sub_func_int32_t_s_s(((void*)0 == &l_254), (0x467C7D0BL == l_254.f0))))))), l_68, l_259);
            (*l_267) = func_75(func_81(l_68), l_266, l_267, l_68, l_268);
        }
        else
        { /* block id: 142 */
            union U2 * const ** const l_271 = (void*)0;
            union U2 * const ** const *l_270 = &l_271;
            union U2 * const ** const **l_269 = &l_270;
            l_269 = l_269;
        }
        (*l_272) = &l_68;
        /* statement id: 145 */
        assert (l_273 == &l_68);
        (*p_66) = ((__builtin_parityl((**l_272)) && ((*l_273) > ((*l_273) | (((void*)0 != l_274) | ((l_275 != l_274) || (0UL != 0x571DL)))))) ^ l_68);
    }
    return l_367;
}


/* ------------------------------------------ */
/* 
 * reads : l_58
 * writes:
 */
inline static int32_t  func_75(const int8_t * p_76, int32_t * p_77, int32_t * p_78, int8_t  p_79, int8_t * p_80)
{ /* block id: 136 */
    uint16_t l_261 = 65534UL;
    int32_t l_262 = 1L;
    union U1 l_263 = {0x44L};
    int32_t *l_265 = &l_262;
    int32_t **l_264 = &l_265;
    l_262 |= (l_261 || p_79);
    (*l_264) = func_93(l_263, l_261, p_79);
    /* statement id: 138 */
    assert (l_265 == 0);
    return (*p_77);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int8_t * func_81(int8_t  p_82)
{ /* block id: 57 */
    uint32_t l_84 = 4UL;
    int32_t l_101 = 0L;
    int8_t l_107 = 6L;
    int8_t *l_106 = &l_107;
    int32_t l_149 = 0x6A08C46EL;
    union U0 l_153 = {0x772B8ADFEA0260ADLL};
    union U0 *l_152 = &l_153;
    union U2 l_181 = {0xF8F1AF8AL};
    union U2 *l_180 = &l_181;
    int32_t *l_195 = (void*)0;
    float l_201 = 0x6.1EF979p+86;
    union U2 ** const l_230 = &l_180;
    union U2 ** const *l_229 = &l_230;
    const int8_t *l_247 = &l_107;
    const int8_t *l_248 = &l_107;
    const int8_t *l_249 = &l_107;
    const int8_t *l_250 = &l_107;
    const int8_t *l_251 = &l_107;
    const int8_t *l_252 = &l_107;
    const int8_t *l_253 = (void*)0;
    if (l_84)
    { /* block id: 58 */
        int32_t l_86 = 0x1B2D863EL;
        int32_t *l_85 = &l_86;
        int32_t l_148 = 0L;
        int32_t *l_155 = (void*)0;
        union U1 l_178 = {8UL};
        union U2 **l_217 = (void*)0;
        union U2 ***l_216 = &l_217;
        uint32_t l_222 = 1UL;
        (*l_85) = ((void*)0 == &p_82);
        if (p_82)
        { /* block id: 60 */
            float l_91 = 0x1.4C62B4p+33;
            int32_t l_105 = 0x48B058B5L;
            union U2 l_151 = {0xAD294528L};
            union U2 *l_150 = &l_151;
            for (l_86 = (-19); (l_86 >= (-17)); l_86 = safe_add_func_int64_t_s_s(l_86, 6))
            { /* block id: 63 */
                union U0 *l_154 = &l_153;
                if ((*l_85))
                { /* block id: 64 */
                    uint32_t l_104 = 7UL;
                    for (l_84 = 5; (l_84 < 2); l_84 = safe_sub_func_int8_t_s_s(l_84, 1))
                    { /* block id: 67 */
                        int8_t l_92 = 0L;
                        int32_t **l_146 = &l_85;
                        if (p_82)
                            break;
                        if (l_92)
                            continue;
                    }
                }
                else
                { /* block id: 82 */
                    float *l_147 = &l_91;
                    (*l_147) = p_82;
                    l_149 ^= l_148;
                    l_150 = l_150;
                    l_154 = l_152;
                }
            }
            (*l_85) ^= __builtin_ctzl(p_82);
            l_85 = l_155;
            /* statement id: 90 */
            assert (l_85 == 0);
            l_149 |= (((safe_sub_func_int16_t_s_s((p_82 == 0x3F460CB50322C85ELL), p_82)) | l_153.f0) & p_82);
        }
        else
        { /* block id: 92 */
            uint32_t l_171 = 0x336AE279L;
            int32_t *l_185 = (void*)0;
            union U2 **l_187 = &l_180;
            union U2 ***l_186 = &l_187;
            if (p_82)
            { /* block id: 93 */
                union U1 l_158 = {0x82L};
                int32_t **l_172 = (void*)0;
                int32_t **l_173 = &l_85;
                int32_t *l_174 = &l_148;
                float l_177 = 0x9.E54492p-32;
                float *l_176 = &l_177;
                (*l_173) = func_93(l_158, (~(safe_mod_func_int16_t_s_s((safe_mul_func_int16_t_s_s((safe_mul_func_uint8_t_u_u(l_158.f0, (p_82 <= (safe_div_func_int8_t_s_s(((safe_add_func_uint64_t_u_u(p_82, (l_158.f0 == (((&l_86 == (void*)0) != ((safe_unary_minus_func_uint16_t_u(p_82)) >= p_82)) != l_171)))) ^ p_82), p_82))))), 8L)), p_82))), p_82);
                /* statement id: 94 */
                assert (l_85 == 0);
                (*l_174) |= p_82;
                (*l_176) = (!p_82);
            }
            else
            { /* block id: 97 */
                float l_179 = 0x0.ECA9F7p-17;
                int32_t **l_182 = &l_155;
                union U1 *l_184 = (void*)0;
                union U1 **l_183 = &l_184;
                union U2 ****l_188 = &l_186;
                (*l_182) = func_93(l_178, p_82, ((void*)0 != l_180));
                (*l_183) = (void*)0;
                (*l_182) = l_185;
                (*l_188) = l_186;
            }
            /* facts after branching */
            assert (l_85 == &l_86 || l_85 == 0);
        }
        /* facts after branching */
        assert (l_85 == &l_86 || l_85 == 0);
        for (l_148 = 14; (l_148 <= 13); l_148 = safe_sub_func_int64_t_s_s(l_148, 4))
        { /* block id: 106 */
            int32_t **l_192 = (void*)0;
            int32_t ***l_191 = &l_192;
            int32_t **l_194 = (void*)0;
            const int64_t l_197 = 7L;
            const int16_t l_200 = 0x02C2L;
            (*l_191) = (void*)0;
            l_195 = func_93(l_178, l_149, (safe_unary_minus_func_uint32_t_u(((void*)0 != &l_148))));
            l_86 = ((p_82 || (p_82 < (((~0x6F77E7A5L) < (&p_82 == &p_82)) ^ l_197))) ^ (p_82 | ((p_82 != (((safe_add_func_uint8_t_u_u(l_200, p_82)) & p_82) >= p_82)) != p_82)));
            if (p_82)
                continue;
        }
        for (l_178.f1 = 0; (l_178.f1 == 1); l_178.f1 = safe_add_func_int16_t_s_s(l_178.f1, 1))
        { /* block id: 114 */
            uint8_t l_204 = 0xEFL;
            union U2 **l_215 = &l_180;
            union U2 ***l_214 = &l_215;
            int32_t l_223 = 0xE989E982L;
            float *l_224 = &l_201;
            int32_t *l_233 = &l_148;
            const int32_t *l_235 = (void*)0;
            const int32_t **l_234 = &l_235;
            if (p_82)
            { /* block id: 115 */
                uint16_t l_205 = 0x5969L;
                l_204 = p_82;
                l_205++;
            }
            else
            { /* block id: 118 */
                l_223 = (p_82 > ((safe_rshift_func_int16_t_s_u((safe_sub_func_uint64_t_u_u((l_214 != l_216), (safe_add_func_uint8_t_u_u((safe_unary_minus_func_uint64_t_u((~l_222))), l_204)))), 3)) >= l_204));
            }
            (*l_224) = 0x8.2DC184p-25;
            (*l_233) = (safe_mul_func_uint16_t_u_u(65535UL, ((safe_sub_func_int64_t_s_s((((void*)0 != l_229) || (p_82 > (safe_add_func_int64_t_s_s(((&l_107 == (void*)0) & 0x7099BD49C445E426LL), ((p_82 < (7UL >= 1L)) & p_82))))), p_82)) >= p_82)));
            (*l_234) = func_93(l_178, __builtin_bswap32(p_82), p_82);
        }
        /* facts after for loop */
            }
    else
    { /* block id: 125 */
        int32_t **l_238 = (void*)0;
        int32_t ***l_237 = &l_238;
        int32_t ****l_236 = &l_237;
        int32_t *** const *l_240 = (void*)0;
        int32_t *** const **l_239 = &l_240;
        int32_t *l_246 = &l_149;
        (*l_239) = l_236;
        /* statement id: 126 */
        assert (l_240 == &l_237);
        for (l_149 = 0; (l_149 != 27); l_149 = safe_add_func_uint32_t_u_u(l_149, 1))
        { /* block id: 129 */
            uint32_t l_245 = 0x0E25250DL;
            l_245 = (safe_mul_func_int8_t_s_s(__builtin_parityl(p_82), p_82));
        }
        (*l_246) ^= 0x4414898BL;
        (*l_246) = p_82;
    }
    return l_253;
    /* statement id: 135 */
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_93(union U1  p_94, int64_t  p_95, int16_t  p_96)
{ /* block id: 74 */
    union U0 l_125 = {1L};
    union U0 *l_124 = &l_125;
    union U0 **l_126 = &l_124;
    union U2 l_129 = {0xD7774CA6L};
    union U2 *l_128 = &l_129;
    union U2 **l_127 = &l_128;
    union U2 ***l_130 = (void*)0;
    union U2 ***l_131 = (void*)0;
    int32_t l_133 = 1L;
    int32_t *l_132 = &l_133;
    int32_t l_139 = 0xBA90DD06L;
    int32_t *l_138 = &l_139;
    int32_t *l_140 = &l_133;
    int32_t *l_141 = &l_139;
    int32_t *l_142 = &l_139;
    int32_t *l_143 = &l_139;
    int32_t *l_144 = &l_133;
    int32_t *l_145 = (void*)0;
    (*l_126) = l_124;
    l_127 = l_127;
    (*l_132) |= (p_95 & l_125.f0);
    (*l_138) |= (safe_div_func_int32_t_s_s(p_96, (safe_mul_func_int16_t_s_s((&l_127 != (void*)0), (*l_132)))));
    return l_145;
    /* statement id: 79 */
    //assert (func_93_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_97(uint16_t  p_98, int8_t * p_99, const uint32_t  p_100)
{ /* block id: 70 */
    int8_t l_112 = 0x83L;
    int32_t l_114 = 6L;
    int32_t *l_113 = &l_114;
    int32_t l_119 = 0x8233887EL;
    int32_t *l_118 = &l_119;
    union U2 l_121 = {0UL};
    union U2 *l_120 = &l_121;
    union U2 **l_122 = &l_120;
    union U1 l_123 = {0xD8L};
    (*l_118) |= (((((safe_rshift_func_int16_t_s_s((safe_sub_func_int16_t_s_s((l_112 < 0xBC4AL), ((void*)0 == l_113))), ((safe_unary_minus_func_int16_t_s(__builtin_clz((0x31L > 0x46L)))) && (safe_mod_func_int8_t_s_s(__builtin_bswap64(p_100), (*l_113)))))) & p_98) ^ 1UL) & (*l_113)) == 65535UL);
    (*l_122) = l_120;
    return l_123;
    /* statement id: 73 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 244
XXX total union variables: 15

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 55
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 15
   indirect level: 2, occurrence: 10
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 20
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 157
   depth: 2, occurrence: 34
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 6
   depth: 7, occurrence: 4
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 26, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 332

XXX times a variable address is taken: 274
XXX times a pointer is dereferenced on RHS: 171
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 19
   depth: 3, occurrence: 13
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 644

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 408
   level: 2, occurrence: 53
   level: 3, occurrence: 30
   level: 4, occurrence: 15
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 80
XXX number of pointers point to scalars: 231
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.5
XXX average alias set size: 1.11

XXX times a non-volatile is read: 857
XXX times a non-volatile is write: 254
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 141
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 21
   depth: 2, occurrence: 32
   depth: 3, occurrence: 22
   depth: 4, occurrence: 19
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 22.4
XXX percentage an existing variable is used: 77.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

