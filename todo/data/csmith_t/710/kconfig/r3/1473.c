/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      4069075712
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 14;
   signed f1 : 11;
   signed f2 : 1;
   unsigned f3 : 9;
   unsigned f4 : 20;
   unsigned f5 : 27;
   unsigned f6 : 13;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
inline static int64_t  func_10(struct S0  p_11, int32_t  p_12);
inline static int32_t  func_14(uint32_t  p_15, struct S0  p_16, uint8_t  p_17, int32_t  p_18, uint8_t  p_19);
static uint8_t  func_32(uint64_t  p_33, struct S0  p_34, int64_t  p_35, uint32_t  p_36);
inline static uint64_t  func_37(uint16_t  p_38, uint64_t  p_39, uint32_t  p_40, uint16_t  p_41);
static const int16_t  func_45(uint8_t  p_46, uint8_t  p_47);
inline static int32_t * func_48(int8_t  p_49);
inline static int64_t  func_57(int8_t  p_58);
static int32_t  func_63(int32_t * p_64, const uint16_t  p_65, uint16_t  p_66, uint32_t  p_67);
inline static const uint16_t  func_69(int32_t * p_70);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_2[7] = {0xFAAAL,0xE90AL,0xFAAAL,0xFAAAL,0xE90AL,0xFAAAL,0xFAAAL};
    int32_t l_3 = 0xE77AB392L;
    struct S0 **l_404 = (void*)0;
    struct S0 ***l_403 = &l_404;
    float l_412 = (-0x9.1p-1);
    float *l_411 = &l_412;
    float **l_410 = &l_411;
    struct S0 *l_429 = (void*)0;
    struct S0 *l_435 = (void*)0;
    int32_t l_437 = (-1L);
    int32_t *l_436 = &l_437;
    struct S0 l_477 = {-66,-30,-0,12,902,6507,44};
    uint32_t l_478 = 0UL;
    int i;
    for (l_3 = 4; (l_3 >= 0); l_3 -= 1)
    { /* block id: 3 */
        struct S0 l_13 = {-35,-17,0,13,169,6139,21};
        struct S0 *l_402[10][3][5] = {{{&l_13,&l_13,(void*)0,&l_13,&l_13},{&l_13,(void*)0,(void*)0,&l_13,&l_13},{(void*)0,&l_13,&l_13,&l_13,&l_13}},{{(void*)0,&l_13,&l_13,(void*)0,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13},{(void*)0,&l_13,&l_13,&l_13,&l_13}},{{(void*)0,&l_13,&l_13,&l_13,&l_13},{&l_13,(void*)0,&l_13,&l_13,&l_13},{(void*)0,&l_13,&l_13,&l_13,&l_13}},{{&l_13,(void*)0,(void*)0,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,(void*)0},{&l_13,(void*)0,&l_13,&l_13,&l_13}},{{&l_13,&l_13,(void*)0,&l_13,(void*)0},{&l_13,(void*)0,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13}},{{(void*)0,&l_13,(void*)0,(void*)0,&l_13},{(void*)0,&l_13,&l_13,&l_13,&l_13},{&l_13,(void*)0,(void*)0,&l_13,&l_13}},{{&l_13,&l_13,(void*)0,&l_13,&l_13},{&l_13,(void*)0,(void*)0,(void*)0,&l_13},{(void*)0,&l_13,&l_13,&l_13,&l_13}},{{(void*)0,(void*)0,(void*)0,(void*)0,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,(void*)0,&l_13,&l_13}},{{&l_13,&l_13,&l_13,&l_13,&l_13},{&l_13,&l_13,&l_13,(void*)0,&l_13},{&l_13,&l_13,&l_13,&l_13,&l_13}},{{&l_13,&l_13,&l_13,(void*)0,&l_13},{(void*)0,&l_13,&l_13,&l_13,(void*)0},{(void*)0,(void*)0,(void*)0,&l_13,&l_13}}};
        struct S0 **l_401[8][7] = {{&l_402[3][0][2],&l_402[3][0][2],&l_402[9][0][4],&l_402[3][0][2],&l_402[3][0][2],&l_402[1][0][0],&l_402[3][0][2]},{&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[4][2][1]},{&l_402[2][2][0],&l_402[3][0][2],&l_402[2][2][0],&l_402[2][2][0],&l_402[3][0][2],&l_402[2][2][0],&l_402[2][2][0]},{&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[4][2][1],&l_402[3][0][2],(void*)0,&l_402[4][2][1]},{&l_402[3][0][2],&l_402[2][2][0],(void*)0,&l_402[3][0][2],(void*)0,&l_402[2][2][0],&l_402[3][0][2]},{&l_402[3][0][2],&l_402[4][2][1],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2]},{&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[1][0][0],&l_402[3][0][2]},{&l_402[3][0][2],&l_402[3][0][2],&l_402[3][0][2],&l_402[4][2][1],&l_402[3][0][2],&l_402[3][0][2],&l_402[4][2][1]}};
        int32_t ** const l_422 = (void*)0;
        int32_t *l_456 = &l_3;
        int i, j, k;
    }
    if (((*l_436) < (safe_add_func_int8_t_s_s(0L, (((void*)0 != &l_436) || ((safe_lshift_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u((*l_436), ((safe_lshift_func_uint16_t_u_u((&l_437 == &l_3), 5)) == (safe_sub_func_int32_t_s_s(0L, ((((((*l_436) ^ 254UL) == (*l_436)) && (*l_436)) > (*l_436)) >= (*l_436))))))), 1)) != (*l_436)))))))
    { /* block id: 217 */
        uint16_t l_471 = 3UL;
        struct S0 l_473 = {-65,24,0,7,303,5103,3};
        struct S0 *l_472 = &l_473;
        for (l_3 = 0; (l_3 < (-13)); l_3 = safe_sub_func_int64_t_s_s(l_3, 7))
        { /* block id: 220 */
            return l_471;
        }
        l_429 = l_472;
        /* statement id: 223 */
        assert (l_429 == &l_473);
    }
    else
    { /* block id: 224 */
        struct S0 l_474 = {98,21,0,10,949,7377,68};
        struct S0 *l_475 = &l_474;
        struct S0 ***l_476[9][9] = {{&l_404,&l_404,(void*)0,&l_404,(void*)0,&l_404,&l_404,&l_404,&l_404},{(void*)0,&l_404,&l_404,&l_404,&l_404,(void*)0,&l_404,(void*)0,&l_404},{&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,(void*)0},{(void*)0,(void*)0,&l_404,&l_404,(void*)0,&l_404,&l_404,(void*)0,(void*)0},{(void*)0,&l_404,&l_404,&l_404,&l_404,&l_404,(void*)0,&l_404,&l_404},{&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,&l_404},{(void*)0,&l_404,(void*)0,&l_404,&l_404,&l_404,(void*)0,&l_404,&l_404},{(void*)0,&l_404,&l_404,&l_404,&l_404,&l_404,&l_404,(void*)0,&l_404},{&l_404,&l_404,(void*)0,&l_404,(void*)0,&l_404,&l_404,&l_404,(void*)0}};
        int i, j;
        (*l_475) = l_474;
        l_476[0][6] = l_476[0][6];
        l_403 = l_476[7][8];
        /* statement id: 227 */
        assert (l_403 == 0 || l_403 == &l_404);
        l_477 = (*l_475);
    }
    /* facts after branching */
    assert (l_403 == 0 || l_403 == &l_404);
    //assert (l_429 == 0 || l_429 == dangling);
    return l_478;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_10(struct S0  p_11, int32_t  p_12)
{ /* block id: 4 */
    int16_t l_42 = (-1L);
    float **l_354 = (void*)0;
    int32_t l_359 = 0x88C05FBDL;
    struct S0 l_366 = {36,-9,-0,19,963,3770,41};
    int8_t l_373 = 0L;
    int32_t *l_386[8] = {&l_359,&l_359,&l_359,&l_359,&l_359,&l_359,&l_359,&l_359};
    int32_t **l_387 = &l_386[3];
    int i;
    p_11.f1 = func_14((safe_add_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s((((safe_lshift_func_int16_t_s_u((safe_mul_func_uint8_t_u_u(((((safe_sub_func_int32_t_s_s((((safe_sub_func_uint32_t_u_u(((func_32(func_37(l_42, ((safe_sub_func_uint64_t_u_u(((func_45(p_11.f5, p_11.f4) ^ l_42) != (((void*)0 == l_354) | (p_11.f4 | (((safe_sub_func_int64_t_s_s((safe_lshift_func_int8_t_s_s(p_11.f4, p_11.f5)), l_42)) || p_11.f3) >= l_42)))), 0x7FD7715F622DDEA7LL)) ^ 0x96F4L), l_42, l_359), l_366, p_11.f0, p_11.f2) >= l_373) != 0xCC073444A4992662LL), p_12)) | p_11.f6) >= p_11.f2), 5UL)) ^ l_366.f5) <= 0x6FFBL) < p_12), 247UL)), 1)) | (-3L)) > p_11.f2), l_42)) | l_366.f2), l_373)), l_366, p_11.f2, l_366.f4, p_11.f0);
    (*l_387) = &l_359;
    return p_11.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_14(uint32_t  p_15, struct S0  p_16, uint8_t  p_17, int32_t  p_18, uint8_t  p_19)
{ /* block id: 138 */
    int32_t l_383 = 0L;
    int32_t *l_382 = &l_383;
    for (p_15 = 0; (p_15 != 42); p_15++)
    { /* block id: 141 */
        int32_t l_381 = (-8L);
        int32_t *l_380 = &l_381;
        int32_t **l_384 = (void*)0;
        int32_t **l_385 = &l_380;
        if (p_16.f1)
        { /* block id: 142 */
            int32_t l_377 = 0L;
            int32_t *l_376 = &l_377;
            (*l_376) = 6L;
        }
        else
        { /* block id: 144 */
            int32_t l_379 = 7L;
            int32_t *l_378[2][10][8] = {{{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,(void*)0,&l_379,(void*)0,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,(void*)0,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{(void*)0,&l_379,&l_379,&l_379,(void*)0,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,(void*)0,(void*)0,&l_379,&l_379,&l_379},{(void*)0,(void*)0,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,(void*)0}},{{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,(void*)0},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{(void*)0,&l_379,&l_379,&l_379,&l_379,&l_379,(void*)0,&l_379},{&l_379,(void*)0,&l_379,&l_379,&l_379,&l_379,(void*)0,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,(void*)0,(void*)0},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,(void*)0,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379,&l_379},{&l_379,&l_379,&l_379,&l_379,&l_379,(void*)0,(void*)0,(void*)0}}};
            int i, j, k;
            l_380 = l_378[0][5][0];
            /* statement id: 145 */
            assert (l_380 == 0 || l_380 == &l_379);
        }
        /* facts after branching */
        //assert (l_380 == 0 || l_380 == dangling || l_380 == &l_381);
        (*l_385) = l_382;
        /* statement id: 147 */
        assert (l_380 == &l_383);
    }
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_32(uint64_t  p_33, struct S0  p_34, int64_t  p_35, uint32_t  p_36)
{ /* block id: 134 */
    struct S0 l_367 = {-44,-23,-0,19,148,998,52};
    struct S0 *l_368 = &l_367;
    int32_t l_370 = 0x846D4142L;
    int32_t *l_369 = &l_370;
    int32_t **l_371[3];
    int32_t *l_372 = &l_370;
    int i;
    for (i = 0; i < 3; i++)
        l_371[i] = &l_369;
    (*l_368) = l_367;
    l_372 = l_369;
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_37(uint16_t  p_38, uint64_t  p_39, uint32_t  p_40, uint16_t  p_41)
{ /* block id: 113 */
    int64_t l_362[4];
    int i;
    for (i = 0; i < 4; i++)
        l_362[i] = 0x48E1D8DCDD864097LL;
    for (p_39 = 0; (p_39 < 1); p_39 = safe_add_func_uint8_t_u_u(p_39, 2))
    { /* block id: 116 */
        for (p_41 = 0; (p_41 <= 3); p_41 += 1)
        { /* block id: 119 */
            int32_t l_363 = 0xB40CF0C4L;
            struct S0 l_364 = {72,25,0,0,174,9362,52};
            int i;
            l_363 = l_362[p_41];
            for (p_40 = 0; (p_40 <= 3); p_40 += 1)
            { /* block id: 123 */
                struct S0 *l_365 = &l_364;
                (*l_365) = l_364;
                for (l_363 = 0; (l_363 <= 3); l_363 += 1)
                { /* block id: 127 */
                    int i;
                    return l_362[p_41];
                }
            }
        }
    }
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_45(uint8_t  p_46, uint8_t  p_47)
{ /* block id: 5 */
    const uint16_t l_52[3] = {0xB265L,0xB265L,0xB265L};
    int32_t l_56 = 0x20EAADAFL;
    int32_t *l_55[2][6][9] = {{{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56}},{{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56}}};
    float l_347 = (-0x1.Cp-1);
    float * const l_346 = &l_347;
    float * const *l_345 = &l_346;
    struct S0 l_353 = {-45,-35,0,16,307,2031,57};
    struct S0 *l_352 = &l_353;
    struct S0 **l_351 = &l_352;
    struct S0 ***l_350 = &l_351;
    int i, j, k;
    l_55[0][2][4] = func_48(((safe_rshift_func_uint16_t_u_u(l_52[2], 0)) != ((safe_div_func_int32_t_s_s((0x8D7E942FAFECEB2CLL <= 0x11589A458230B545LL), (0x5762CC684CA67B11LL ^ (l_55[0][0][1] != (void*)0)))) | ((((func_57(p_46) > (safe_add_func_uint32_t_u_u((safe_unary_minus_func_int64_t_s((255UL <= p_46))), p_46))) ^ p_46) <= 4L) <= 4L))));
    for (p_46 = 17; (p_46 < 48); p_46++)
    { /* block id: 108 */
        uint64_t l_339 = 0UL;
        int32_t l_340 = 4L;
        struct S0 ** const l_349 = (void*)0;
        struct S0 ** const *l_348 = &l_349;
        l_340 = (+(safe_mod_func_uint32_t_u_u(l_339, p_47)));
        (*l_346) = (safe_add_func_float_f_f((safe_div_func_float_f_f((&l_56 != &l_340), ((((-0x1.Bp+1) == (l_345 != &l_346)) >= (((l_348 != l_350) <= 0x1.7EB047p-33) >= p_46)) == 0x5.1p+1))), l_339));
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_48(int8_t  p_49)
{ /* block id: 95 */
    int32_t *l_308 = (void*)0;
    int32_t **l_309 = (void*)0;
    int32_t **l_310 = &l_308;
    int32_t **** const *l_332 = (void*)0;
    int32_t *l_333 = (void*)0;
    (*l_310) = l_308;
    for (p_49 = 0; (p_49 >= 25); p_49 = safe_add_func_uint16_t_u_u(p_49, 2))
    { /* block id: 99 */
        int32_t l_319 = 1L;
        int32_t *l_318 = &l_319;
        const int32_t ***l_327 = (void*)0;
        const int32_t ****l_326 = &l_327;
        (*l_318) = (safe_sub_func_uint16_t_u_u(p_49, (safe_mul_func_uint16_t_u_u((safe_unary_minus_func_uint16_t_u((p_49 == p_49))), p_49))));
        if (p_49)
            break;
        (*l_318) = (((safe_lshift_func_uint16_t_u_s(p_49, (safe_lshift_func_int8_t_s_s((safe_add_func_uint8_t_u_u((*l_318), ((l_326 != &l_327) || ((-6L) || 65527UL)))), (safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(((void*)0 == l_332), ((void*)0 == &l_327))), p_49)))))) >= (*l_318)) | 0x53B09113L);
    }
    return l_333;
    /* statement id: 104 */
    //assert (func_48_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_57(int8_t  p_58)
{ /* block id: 6 */
    int32_t l_60 = 0L;
    int32_t *l_59 = &l_60;
    int32_t **l_119 = &l_59;
    int32_t ***l_118 = &l_119;
    struct S0 l_141 = {-89,-17,0,10,31,11521,45};
    struct S0 *l_140 = &l_141;
    int32_t l_303 = 0x2F3A6FA7L;
    if ((l_59 == &l_60))
    { /* block id: 7 */
        int32_t l_61 = 0xC50ED6CAL;
        return l_61;
    }
    else
    { /* block id: 9 */
        int8_t l_62 = (-9L);
        struct S0 l_146 = {-86,-43,0,18,957,6912,2};
        int32_t *l_151[7];
        const int32_t ***l_170 = (void*)0;
        const int32_t ****l_169 = &l_170;
        const int32_t ***** const l_168 = &l_169;
        float l_219[4];
        float *l_218[4][1][6] = {{{&l_219[1],(void*)0,&l_219[1],&l_219[0],&l_219[0],&l_219[1]}},{{&l_219[0],&l_219[0],&l_219[0],&l_219[1],&l_219[0],&l_219[0]}},{{&l_219[0],(void*)0,&l_219[1],&l_219[1],(void*)0,&l_219[0]}},{{&l_219[0],&l_219[0],&l_219[1],&l_219[0],&l_219[0],&l_219[0]}}};
        float **l_217[9];
        uint64_t l_261[3][9] = {{0xEFF8C8359BE378BCLL,18446744073709551614UL,0xEFF8C8359BE378BCLL,18446744073709551614UL,0xEFF8C8359BE378BCLL,18446744073709551614UL,0xEFF8C8359BE378BCLL,18446744073709551614UL,0xEFF8C8359BE378BCLL},{1UL,1UL,0xAE5F705220B7D190LL,0xAE5F705220B7D190LL,1UL,1UL,0xAE5F705220B7D190LL,0xAE5F705220B7D190LL,1UL},{18446744073709551615UL,18446744073709551614UL,18446744073709551615UL,18446744073709551614UL,18446744073709551615UL,18446744073709551614UL,18446744073709551615UL,18446744073709551614UL,18446744073709551615UL}};
        uint16_t l_284 = 0UL;
        uint32_t l_289 = 0xD7E94F4AL;
        struct S0 **l_302 = &l_140;
        struct S0 ***l_301[4] = {&l_302,&l_302,&l_302,&l_302};
        int32_t l_304 = 0x05CFCB85L;
        int i, j, k;
        for (i = 0; i < 7; i++)
            l_151[i] = &l_60;
        for (i = 0; i < 4; i++)
            l_219[i] = 0x5.5p-1;
        for (i = 0; i < 9; i++)
            l_217[i] = &l_218[0][0][1];
        if (((p_58 & ((l_62 >= 0x4FE37806L) ^ 0xDBD1BD9FL)) || l_62))
        { /* block id: 10 */
            int32_t *l_68 = &l_60;
            struct S0 l_148 = {86,-6,0,5,190,9411,27};
            int32_t l_262 = 0xF69327C0L;
            if (((((func_63(l_68, func_69(l_68), (p_58 <= ((void*)0 != &l_60)), (*l_68)) > (-9L)) > p_58) && 65533UL) > p_58))
            { /* block id: 18 */
                float l_113 = (-0x1.7p-1);
                float *l_112 = &l_113;
                int32_t **l_114 = (void*)0;
                int32_t **l_115 = &l_68;
                (*l_112) = (p_58 < (-0x1.1p-1));
                (*l_115) = &l_60;
                if ((safe_lshift_func_int16_t_s_u(((l_68 == (void*)0) || p_58), 2)))
                { /* block id: 21 */
                    int32_t ****l_120 = (void*)0;
                    int32_t * const *l_123[7];
                    int32_t * const **l_122 = &l_123[6];
                    int32_t * const ***l_121[4][3] = {{&l_122,&l_122,&l_122},{&l_122,&l_122,&l_122},{&l_122,&l_122,&l_122},{&l_122,&l_122,&l_122}};
                    int32_t ****l_124 = &l_118;
                    int i, j;
                    for (i = 0; i < 7; i++)
                        l_123[i] = &l_68;
                    (*l_124) = l_118;
                }
                else
                { /* block id: 23 */
                    int32_t l_135[10];
                    struct S0 l_139 = {76,26,0,5,451,9063,52};
                    struct S0 *l_138 = &l_139;
                    int i;
                    for (i = 0; i < 10; i++)
                        l_135[i] = (-1L);
                    if ((((safe_mul_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_s(((safe_sub_func_int64_t_s_s(((safe_sub_func_int8_t_s_s(l_62, (((safe_mul_func_uint16_t_u_u(l_135[7], (safe_add_func_uint16_t_u_u((l_138 == l_140), p_58)))) & (**l_119)) >= (((p_58 > (safe_sub_func_uint64_t_u_u((safe_mul_func_uint8_t_u_u(((*l_59) >= 0L), 0xE6L)), p_58))) >= p_58) ^ p_58)))) == l_62), 0x82652714D024A44ALL)) <= 0xF20BB848F33B6043LL), p_58)), (**l_115))) ^ l_62) != 0L))
                    { /* block id: 24 */
                        (*l_112) = p_58;
                        (*l_138) = l_146;
                    }
                    else
                    { /* block id: 27 */
                        struct S0 l_147 = {-127,-3,-0,0,704,3567,52};
                        l_148 = l_147;
                    }
                }
                for (p_58 = 0; (p_58 < (-19)); p_58 = safe_sub_func_int8_t_s_s(p_58, 1))
                { /* block id: 33 */
                    (*l_119) = l_151[3];
                }
            }
            else
            { /* block id: 36 */
                int32_t *l_158 = (void*)0;
                int32_t ****l_159[9] = {&l_118,&l_118,&l_118,&l_118,&l_118,&l_118,&l_118,&l_118,&l_118};
                struct S0 l_161 = {-104,25,-0,9,847,9189,2};
                const struct S0 *l_209 = &l_161;
                const struct S0 **l_208 = &l_209;
                const struct S0 ***l_207 = &l_208;
                int32_t *l_216 = &l_60;
                int i;
                if ((safe_lshift_func_int16_t_s_u((**l_119), 8)))
                { /* block id: 37 */
                    struct S0 l_154 = {-125,36,-0,17,74,6169,4};
                    (*l_140) = l_154;
                    (*l_68) = (safe_sub_func_uint16_t_u_u((p_58 ^ p_58), p_58));
                }
                else
                { /* block id: 40 */
                    int32_t ***l_157 = &l_119;
                    if ((l_157 != (void*)0))
                    { /* block id: 41 */
                        int32_t *****l_160 = &l_159[1];
                        (*l_119) = l_158;
                        /* statement id: 42 */
                        assert (l_59 == 0);
                        (*l_140) = l_146;
                        (*l_160) = l_159[0];
                        return p_58;
                    }
                    else
                    { /* block id: 46 */
                        (*l_140) = l_161;
                    }
                    (***l_157) = (safe_mod_func_int64_t_s_s((safe_sub_func_int8_t_s_s(((*l_118) == &l_151[3]), (safe_rshift_func_uint16_t_u_u(((void*)0 == l_168), (safe_sub_func_uint16_t_u_u(((((safe_mod_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(0x8B998A83L, (*l_59))), p_58)) == (safe_add_func_int32_t_s_s((safe_div_func_uint64_t_u_u((((((safe_sub_func_uint32_t_u_u(((+0x6FL) | (***l_157)), p_58)) ^ p_58) || (***l_157)) != (***l_157)) || 0x22342146L), (***l_118))), (***l_157)))) != 0xB4A2L) < p_58), p_58)))))), p_58));
                    if ((((p_58 ^ (((***l_157) <= 0x5A15L) | ((+(safe_rshift_func_int8_t_s_u((5UL < 0L), p_58))) <= ((0x5998L ^ (safe_mod_func_uint8_t_u_u(((safe_sub_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_s((((0xE106L != 0x31E0L) != 0x1CF9FCAAD6EEDD9ELL) <= p_58), p_58)), 0xA001A1B5L)) != (***l_157)), 255UL))) > 1UL)))) | p_58) ^ 0x3FL))
                    { /* block id: 50 */
                        struct S0 **l_198 = &l_140;
                        struct S0 ***l_197 = &l_198;
                        (*l_68) = (***l_157);
                        (*l_197) = (void*)0;
                        /* statement id: 52 */
                        assert (l_198 == 0);
                        (**l_157) = (**l_157);
                    }
                    else
                    { /* block id: 54 */
                        const uint16_t l_201 = 0xB31FL;
                        int32_t l_215 = 6L;
                        float **l_220 = &l_218[0][0][1];
                        l_215 = (((1L < (safe_rshift_func_int8_t_s_u(l_201, (safe_lshift_func_int8_t_s_u(((safe_lshift_func_int8_t_s_s(((*l_59) >= (((safe_unary_minus_func_int16_t_s((***l_157))) && p_58) < ((l_207 != (void*)0) <= (safe_mod_func_uint16_t_u_u(p_58, (safe_rshift_func_int16_t_s_s(((!((p_58 != p_58) | 0xE1L)) ^ 4294967295UL), 14))))))), p_58)) == p_58), p_58))))) && p_58) ^ 4294967295UL);
                        l_68 = l_216;
                        l_220 = l_217[4];
                    }
                }
            }
            for (l_60 = (-8); (l_60 > (-30)); --l_60)
            { /* block id: 63 */
                uint32_t l_238[3][6] = {{0UL,0UL,0x7EFDBF38L,4294967295UL,0xD913FAE4L,0x7EFDBF38L},{4294967295UL,0xD913FAE4L,0x7EFDBF38L,0xD913FAE4L,4294967295UL,0x7EFDBF38L},{0xD913FAE4L,4294967295UL,0x7EFDBF38L,0UL,0UL,0x7EFDBF38L}};
                int32_t *l_248[9] = {&l_60,&l_60,&l_60,&l_60,&l_60,&l_60,&l_60,&l_60,&l_60};
                int i, j;
                for (p_58 = 4; (p_58 != 28); p_58 = safe_add_func_uint64_t_u_u(p_58, 4))
                { /* block id: 66 */
                    const uint64_t l_231 = 1UL;
                    int32_t ***l_251 = &l_119;
                    int32_t l_252 = 0xE760C5D1L;
                    l_252 = (((p_58 >= (+(((safe_sub_func_float_f_f((p_58 <= ((-(safe_mul_func_float_f_f(l_231, (safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_div_func_float_f_f(l_238[2][1], 0x5.DE542Fp+8)), (safe_div_func_float_f_f((safe_div_func_float_f_f(((((-(safe_sub_func_float_f_f(((safe_sub_func_float_f_f((((((l_248[4] != (void*)0) <= ((safe_sub_func_float_f_f(((void*)0 != l_251), p_58)) != p_58)) > (***l_251)) <= (**l_119)) != (*l_59)), p_58)) != 0x0.5p-1), (*l_59)))) >= (***l_251)) < 0x1.941988p+24) >= (*l_68)), 0x3.836BFBp+19)), (***l_118))))), p_58))))) <= (-0x1.Cp+1))), p_58)) > p_58) == 0x1.Cp+1))) >= (***l_251)) > 0x5.1DBFA4p+45);
                    if ((safe_sub_func_int64_t_s_s((safe_add_func_int8_t_s_s(p_58, ((4294967294UL | p_58) && ((void*)0 != &l_248[3])))), ((safe_mod_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(6L, (((***l_251) == (-9L)) > l_261[0][1]))), p_58)) || p_58))))
                    { /* block id: 68 */
                        if (p_58)
                            break;
                        return p_58;
                    }
                    else
                    { /* block id: 71 */
                        int32_t **l_283[6] = {&l_59,&l_59,&l_151[3],&l_59,&l_59,&l_151[3]};
                        int i;
                        l_262 = 0x0.36BE32p-8;
                        l_284 = (-((!(-(safe_sub_func_float_f_f(((safe_div_func_float_f_f(((safe_sub_func_float_f_f(((0xE.4ADBFCp-22 <= 0x0.Dp+1) > 0x1.4p+1), (safe_sub_func_float_f_f((safe_add_func_float_f_f((***l_118), (safe_div_func_float_f_f(((!0x0.0D330Bp-52) < (safe_add_func_float_f_f((safe_sub_func_float_f_f((***l_251), (p_58 > ((l_283[5] != (*l_251)) != 0xF.F2DFD3p-77)))), (***l_251)))), (***l_118))))), 0x0.Fp-1)))) != p_58), (***l_251))) > (-0x8.Ep-1)), 0x3.FEA89Cp-98)))) > (-0x1.9p+1)));
                    }
                }
            }
        }
        else
        { /* block id: 77 */
            int32_t l_285 = (-1L);
            struct S0 *l_286 = &l_141;
            struct S0 **l_300 = (void*)0;
            struct S0 ***l_299 = &l_300;
            (**l_119) = (l_285 && (l_286 == (void*)0));
            for (l_62 = (-16); (l_62 <= (-11)); l_62 = safe_add_func_int64_t_s_s(l_62, 8))
            { /* block id: 81 */
                l_289 = (-0x1.9p+1);
                return l_285;
            }
            for (l_289 = 11; (l_289 != 5); --l_289)
            { /* block id: 87 */
                (***l_118) = (safe_div_func_float_f_f((p_58 >= ((safe_sub_func_float_f_f((+p_58), (safe_add_func_float_f_f((((l_299 != l_301[3]) < ((((p_58 > l_303) != ((l_304 >= ((((-0x9.1p+1) == ((((***l_118) < l_285) != p_58) == 0x1.4p-1)) < (***l_118)) < (***l_118))) == p_58)) != p_58) >= p_58)) > 0x1.5p-1), p_58)))) == 0xE.38342Fp-74)), p_58));
                (*l_140) = (*l_286);
            }
        }
        (**l_302) = (*l_140);
    }
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(int32_t * p_64, const uint16_t  p_65, uint16_t  p_66, uint32_t  p_67)
{ /* block id: 14 */
    struct S0 l_91 = {-81,33,0,1,397,9140,74};
    struct S0 *l_92 = &l_91;
    const int64_t l_109 = 9L;
    float l_111[3];
    float *l_110 = &l_111[2];
    int i;
    for (i = 0; i < 3; i++)
        l_111[i] = (-0x1.4p+1);
    (*l_92) = l_91;
    (*l_110) = ((safe_sub_func_float_f_f(l_91.f3, (safe_add_func_float_f_f(l_91.f0, (p_66 > (safe_div_func_float_f_f((safe_add_func_float_f_f((+((&l_91 != &l_91) > (-p_65))), 0x5.C771C7p-81)), ((safe_add_func_float_f_f((((safe_sub_func_float_f_f(((-0x4.8p+1) >= (safe_add_func_float_f_f(l_91.f3, l_109))), l_91.f0)) <= l_91.f5) == 0x8.3p-1), 0x0.2p-1)) != p_67)))))))) <= 0x9.93F29Fp-77);
    return (*p_64);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_69(int32_t * p_70)
{ /* block id: 11 */
    int8_t l_71 = 0xCCL;
    float *l_88 = (void*)0;
    float l_90 = (-0x4.3p-1);
    float *l_89 = &l_90;
    (*l_89) = (l_71 <= (l_71 == (l_71 != (safe_add_func_float_f_f(((((l_71 == ((safe_add_func_float_f_f(0xE.3F16A1p-57, ((safe_sub_func_float_f_f(l_71, l_71)) == ((l_71 == (safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_sub_func_float_f_f((safe_mul_func_float_f_f(0x5.4F168Ep+90, 0xD.AE89E6p-61)), 0xF.BDB030p+25)), l_71)), l_71)) == l_71), 0x4.E320ECp-60))) > l_71)))) < l_71)) > l_71) == l_71) == l_71), 0xC.A20016p+66)))));
    return l_71;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 86
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 7
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 58
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 29

XXX max expression depth: 43
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 19
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 29, occurrence: 1
   depth: 43, occurrence: 1

XXX total number of pointers: 113

XXX times a variable address is taken: 235
XXX times a pointer is dereferenced on RHS: 56
breakdown:
   depth: 1, occurrence: 28
   depth: 2, occurrence: 6
   depth: 3, occurrence: 22
XXX times a pointer is dereferenced on LHS: 45
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 419

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 85
   level: 2, occurrence: 23
   level: 3, occurrence: 29
   level: 4, occurrence: 3
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 35.4
XXX average alias set size: 1.27

XXX times a non-volatile is read: 477
XXX times a non-volatile is write: 147
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 17
   depth: 2, occurrence: 10
   depth: 3, occurrence: 12
   depth: 4, occurrence: 11
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

