/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1224946376
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 18;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 23;
   uint32_t  f1;
   int32_t  f2;
   signed f3 : 31;
   unsigned f4 : 8;
   unsigned f5 : 31;
   signed f6 : 10;
};
#pragma pack(pop)

union U2 {
   uint16_t  f0;
   signed f1 : 15;
   int32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_29(void);
static struct S0  func_31(int32_t  p_32, int32_t  p_33, int32_t  p_34, uint16_t  p_35);
inline static int16_t  func_38(uint32_t  p_39);
static int32_t  func_42(struct S1  p_43);
static struct S1  func_44(uint32_t  p_45);
static uint16_t  func_46(struct S0  p_47, uint16_t  p_48, uint32_t  p_49, uint16_t  p_50);
static struct S0  func_51(struct S0  p_52, union U2  p_53, int32_t  p_54, int32_t  p_55);
static struct S0  func_56(struct S0  p_57, int32_t  p_58, uint16_t  p_59);
inline static struct S0  func_60(struct S0  p_61);
inline static struct S0  func_62(uint16_t  p_63, int16_t  p_64, uint16_t  p_65);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 2U;
    union U2 l_155 = {0U};
    int32_t l_156 = 0;
    int32_t l_701 = 0xCFFC4C54;
    l_701 &= (l_30 > (func_31(l_30, ((((int16_t)l_30 << (int16_t)func_38(((l_30 | (((uint32_t)1U - (uint32_t)func_42(func_44((((l_30 > l_30) | func_46(func_51(func_56(func_60(func_62(((uint16_t)((uint16_t)__builtin_popcount((((l_30 || l_30) < 0x74F98987) && l_30)) * (uint16_t)l_30) % (uint16_t)l_30), l_30, l_30)), l_30, l_30), l_155, l_156, l_156), l_30, l_30, l_30)) != l_155.f0)))) >= l_155.f0)) && l_155.f0))) , l_155) , l_155.f0), l_156, l_155.f0) , l_155.f0));
    return l_701;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(int32_t  p_32, int32_t  p_33, int32_t  p_34, uint16_t  p_35)
{ /* block id: 308 */
    union U2 l_457 = {0x1425};
    struct S0 l_458 = {-267};
    struct S0 l_461 = {378};
    uint32_t l_484 = 0x2932B401;
    struct S1 l_508 = {-1000,0xB8FE2853,1,24915,7,11769,-20};
    uint32_t l_510 = 0x53BC88BF;
    int32_t l_565 = 0x333A8F2C;
    uint32_t l_629 = 4294967288U;
    int32_t l_698 = 3;
    for (p_32 = 0; (p_32 <= 16); p_32 += 5)
    { /* block id: 311 */
        uint16_t l_454 = 8U;
        int32_t l_456 = 0x871C2EA1;
        struct S0 l_459 = {-119};
        uint16_t l_460 = 0x8ADE;
        int32_t l_478 = 0x92FE50AA;
        struct S1 l_493 = {1745,4294967287U,0x99DA52F6,-34210,2,30024,11};
        for (p_34 = 22; (p_34 <= 19); p_34 -= 1)
        { /* block id: 314 */
            int32_t l_455 = (-6);
            l_454 = p_35;
            if (l_455)
                continue;
            l_456 = l_454;
        }
        l_461 = (l_457 , (l_458 = (l_459 = func_62(l_454, l_454, (func_56((p_35 , l_458), (func_46(l_459, (func_38(l_460) & (((p_34 = p_34) && l_454) <= p_33)), l_459.f0, p_32) ^ 1U), p_33) , p_32)))));
    }
    for (p_32 = (-20); (p_32 <= 13); p_32 += 1)
    { /* block id: 424 */
        int32_t l_605 = 1;
        struct S0 l_609 = {328};
        struct S1 l_700 = {-1965,0xDACCCEF4,-9,37200,11,12836,-9};
        l_508.f6 &= ((int16_t)0x9CE5 >> (int16_t)(((l_508.f3 = func_46((l_458 = (l_510 , l_458)), l_508.f5, l_605, (((~(((int16_t)(l_609 , (((uint32_t)(-(uint32_t)p_34) % (uint32_t)((uint16_t)(p_33 >= 0x4DA5) * (uint16_t)l_605)) ^ l_565)) % (int16_t)l_508.f3) != l_609.f0)) < 1) & p_35))) , p_35) ^ (-1)));
        for (l_605 = 0; (l_605 >= (-30)); l_605 -= 7)
        { /* block id: 430 */
            int32_t l_619 = 1;
            int32_t l_622 = (-9);
            int32_t l_630 = 0xB4373EFF;
            int32_t l_631 = 5;
            int32_t l_632 = 0xC9A2477A;
            uint32_t l_645 = 0U;
            struct S0 l_653 = {-262};
            struct S1 l_699 = {1579,0xE26179FA,5,25979,7,13992,18};
        }
    }
    return l_458;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_38(uint32_t  p_39)
{ /* block id: 226 */
    uint32_t l_344 = 0x0C5FF1E0;
    int32_t l_352 = 0x47FD3BF1;
    struct S0 l_361 = {-186};
    int32_t l_372 = 1;
    uint32_t l_384 = 1U;
    uint32_t l_427 = 4294967295U;
    int32_t l_430 = 0x28938DB9;
    struct S1 l_446 = {-769,0xBA799C57,1,-1056,5,12636,-18};
    for (p_39 = 0; (p_39 == 49); p_39 += 1)
    { /* block id: 229 */
        int16_t l_345 = 0x480D;
        l_345 = l_344;
        for (l_345 = 0; (l_345 >= (-20)); l_345 -= 8)
        { /* block id: 233 */
            return l_345;
        }
    }
    l_352 ^= ((int16_t)1 - (int16_t)((uint16_t)__builtin_ia32_crc32qi(__builtin_bswap64((p_39 <= l_344)), p_39) << (uint16_t)3));
    l_352 |= (p_39 <= p_39);
    for (p_39 = 0; (p_39 >= 37); p_39 += 1)
    { /* block id: 241 */
        int32_t l_355 = 0x921B171C;
        struct S0 l_367 = {-294};
        int32_t l_400 = 1;
        union U2 l_423 = {1U};
        struct S1 l_428 = {-2043,4294967293U,0x0EA1A5F8,-45538,6,25948,-26};
        if ((l_355 < 0xC409))
        { /* block id: 242 */
            struct S0 l_364 = {-317};
            union U2 l_368 = {0x6D4E};
            int32_t l_379 = 0x553CE12B;
            for (l_344 = 0; (l_344 == 46); l_344 += 1)
            { /* block id: 245 */
                struct S0 l_360 = {-319};
                int32_t l_380 = (-1);
                for (l_352 = 0; (l_352 == (-18)); l_352 -= 9)
                { /* block id: 248 */
                    l_361 = l_360;
                    return p_39;
                }
                for (l_352 = 19; (l_352 > 27); l_352 += 9)
                { /* block id: 254 */
                    int32_t l_369 = (-1);
                    struct S0 l_381 = {-201};
                    l_360 = (l_364 = l_361);
                }
                l_372 = (((uint16_t)((~(l_352 = (l_360.f0 = (((((uint16_t)p_39 + (uint16_t)(l_379 = ((int16_t)((~(((p_39 && ((((uint32_t)((0x499D && 5U) && 3) + (uint32_t)2U) >= ((uint16_t)(l_368.f1 = (l_367.f0 = __builtin_ffs(((func_46(l_360, (l_355 = (((p_39 && ((p_39 , l_360.f0) , 1U)) >= p_39) <= 1)), p_39, l_384) > 0x005C) > l_360.f0)))) << (uint16_t)14)) == l_380)) > p_39) , l_352)) & 0xC07887B8) % (int16_t)l_379))) && l_384) , 0x7904) , l_344)))) , 65533U) + (uint16_t)65529U) > l_400);
            }
            l_355 = 1;
        }
        else
        { /* block id: 282 */
            int32_t l_403 = 9;
            int32_t l_406 = (-5);
            struct S0 l_422 = {-24};
            if (((int16_t)(l_372 = p_39) + (int16_t)((l_403 >= ((uint16_t)p_39 >> (uint16_t)14)) & (l_406 = 0x87274B98))))
            { /* block id: 285 */
                int32_t l_407 = 0x20ED5610;
                struct S1 l_429 = {2796,0x418ADAD0,0,44905,14,8476,11};
                if (l_407)
                    break;
                if ((((uint16_t)l_407 % (uint16_t)l_384) , (__builtin_ffs(l_407) , (0 < (p_39 >= (((int32_t)((int16_t)(-1) << (int16_t)7) % (int32_t)p_39) & p_39))))))
                { /* block id: 287 */
                    l_400 &= l_344;
                    if (p_39)
                        break;
                }
                else
                { /* block id: 290 */
                    int32_t l_426 = 0xA8E01941;
                    l_406 = (l_367.f0 = ((uint16_t)(p_39 < 65535U) + (uint16_t)(((int32_t)((l_355 , 0xCF5ADEBA) , ((((uint16_t)(func_51(l_422, l_423, p_39, ((((uint16_t)(l_372 = (((p_39 <= (((0x51B6 && 0x5F22) > p_39) > (-6))) > l_426) | l_361.f0)) % (uint16_t)p_39) == 0x1EB9) || l_427)) , l_384) + (uint16_t)0xF5B0) & 0) & l_422.f0)) - (int32_t)p_39) , p_39)));
                }
                l_429 = l_428;
            }
            else
            { /* block id: 296 */
                int32_t l_445 = 0x037808A2;
                l_445 = ((l_430 == ((int16_t)__builtin_clz((l_403 = (((int16_t)((l_422 = func_62((func_42((l_384 , (l_446 = func_44(((uint16_t)(((((((p_39 || p_39) <= ((uint32_t)(((int32_t)p_39 - (int32_t)((int16_t)(((0xFF2E & func_46(l_361, l_430, (l_428.f6 = ((int16_t)(l_428.f0 , 0xE4D9) % (int16_t)0x76D0)), l_384)) <= l_428.f0) , 0x6671) % (int16_t)1)) >= p_39) % (uint32_t)0x7C3F1183)) | 2U) && p_39) == p_39) <= p_39) > l_445) % (uint16_t)p_39))))) < 7), l_355, p_39)) , (-7)) * (int16_t)(-9)) >= 0))) + (int16_t)65535U)) ^ p_39);
            }
        }
        l_446.f0 &= (4294967295U < ((int16_t)func_42(func_44(func_42(((!(p_39 != l_428.f4)) , func_44((l_372 = 0x0A026383)))))) << (int16_t)9));
    }
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_42(struct S1  p_43)
{ /* block id: 188 */
    int16_t l_307 = 0x46FD;
    int32_t l_308 = 0x7A4B4D11;
    struct S1 l_324 = {944,0x409EA005,0x03ECC52C,16085,3,11928,-0};
    struct S0 l_334 = {325};
    uint32_t l_338 = 4294967295U;
    int32_t l_341 = 0;
    for (p_43.f1 = (-1); (p_43.f1 <= 57); p_43.f1 += 1)
    { /* block id: 191 */
        uint32_t l_305 = 0xF3F15251;
        int32_t l_306 = (-6);
        for (p_43.f2 = 0; (p_43.f2 <= (-3)); p_43.f2 -= 4)
        { /* block id: 194 */
            if (l_305)
                break;
        }
        l_306 = l_305;
        l_308 ^= l_307;
        if (l_307)
            continue;
    }
    for (p_43.f2 = 1; (p_43.f2 != 6); p_43.f2 += 1)
    { /* block id: 203 */
        struct S0 l_315 = {-406};
        struct S0 l_319 = {204};
        for (l_308 = 2; (l_308 > 1); l_308 -= 1)
        { /* block id: 206 */
            struct S0 l_318 = {305};
            uint32_t l_332 = 0xB460943D;
            int32_t l_333 = (-1);
            p_43.f3 = ((uint16_t)((func_46(l_315, (func_44((p_43.f1 = l_315.f0)) , p_43.f0), p_43.f4, ((l_308 <= (((uint32_t)func_46((l_319 = l_318), (((uint32_t)p_43.f3 - (uint32_t)((int16_t)(func_44(__builtin_parityll((l_324 , l_318.f0))) , l_318.f0) + (int16_t)0x2BF8)) < p_43.f5), l_315.f0, l_324.f5) - (uint32_t)1U) >= l_315.f0)) , l_308)) >= 0xDB8D) >= l_315.f0) * (uint16_t)p_43.f3);
            l_315.f0 |= (~((l_324.f0 = ((int16_t)l_324.f4 >> (int16_t)((p_43.f6 != (p_43.f3 |= (p_43.f0 = p_43.f0))) , ((p_43.f0 && __builtin_ctz((p_43.f4 = p_43.f3))) && (l_332 |= ((int32_t)(p_43.f3 && (((l_318.f0 = ((uint16_t)(p_43.f2 != (p_43.f4 == l_318.f0)) << (uint16_t)p_43.f4)) > 0x705C) >= l_319.f0)) - (int32_t)0)))))) > l_333));
            if (p_43.f6)
                break;
        }
        return p_43.f1;
    }
    l_334 = func_56(l_334, (p_43.f6 = ((((0xCCCAD145 & ((int16_t)(!(__builtin_popcount(l_338) < (((__builtin_parityll((l_324.f2 = (((l_324.f0 ^= p_43.f1) > ((int16_t)0x210D >> (int16_t)l_338)) , p_43.f4))) != p_43.f6) || 0xEF6FF9AE) & p_43.f3))) * (int16_t)l_341)) , l_324.f3) < l_334.f0) == p_43.f6)), p_43.f1);
    return l_334.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_44(uint32_t  p_45)
{ /* block id: 108 */
    uint32_t l_193 = 1U;
    int32_t l_194 = 7;
    int32_t l_199 = 0x144B6F7A;
    int32_t l_200 = 0x50E592CA;
    int32_t l_207 = (-6);
    struct S0 l_218 = {296};
    int32_t l_250 = (-10);
    int32_t l_286 = (-8);
    struct S1 l_300 = {-745,1U,0x9ECD0582,-3268,2,32737,-25};
    if (((int16_t)((p_45 || ((l_194 = l_193) <= 0xEF0F)) != (__builtin_ctz(__builtin_popcount(__builtin_ffsll((l_207 = ((uint16_t)((uint32_t)(l_200 = (l_199 = __builtin_bswap64(l_193))) + (uint32_t)((((int32_t)(l_193 != l_193) - (int32_t)(((((int16_t)(4U ^ ((int16_t)1 >> (int16_t)8)) + (int16_t)p_45) != l_193) , l_193) ^ p_45)) > 9) ^ l_193)) - (uint16_t)p_45))))) >= 0U)) >> (int16_t)p_45))
    { /* block id: 113 */
        union U2 l_212 = {0xEAB9};
        struct S0 l_219 = {-124};
        struct S1 l_240 = {-1661,0xA5150234,0x0B65D2F8,22677,1,42040,25};
        struct S0 l_287 = {-370};
        for (l_193 = (-7); (l_193 == 60); l_193 += 5)
        { /* block id: 116 */
            int32_t l_222 = 0xF83DE727;
            uint32_t l_238 = 0x3B8ED1E4;
            union U2 l_239 = {65534U};
            for (l_200 = (-27); (l_200 <= 22); l_200 += 8)
            { /* block id: 119 */
                uint16_t l_215 = 1U;
                struct S0 l_220 = {471};
                uint32_t l_221 = 1U;
                struct S1 l_229 = {460,1U,-2,-15933,2,8069,3};
                l_220.f0 = ((((l_212 , (((uint32_t)l_215 + (uint32_t)((int16_t)(func_46(l_218, ((l_194 = (l_221 = (((__builtin_bswap64(l_199) <= (((l_219 , l_219) , p_45) , func_46(func_56(l_220, p_45, l_215), p_45, l_193, l_194))) , l_199) <= 9))) != l_222), l_219.f0, p_45) , l_220.f0) >> (int16_t)l_193)) == l_200)) | l_222) > p_45) || l_215);
                if (((~p_45) <= 0))
                { /* block id: 123 */
                    uint32_t l_226 = 0x7DC5F5F0;
                    int32_t l_227 = 6;
                    l_207 = p_45;
                    l_227 = l_226;
                    l_199 |= (-1);
                }
                else
                { /* block id: 127 */
                    struct S1 l_228 = {-137,0xB7E2CB60,0x77C65B12,-33640,5,35690,-30};
                    l_229 = l_228;
                }
                l_194 = l_219.f0;
            }
            l_199 &= (((int32_t)l_207 % (int32_t)l_200) && ((int32_t)(l_200 = (l_222 >= (((uint16_t)l_222 >> (uint16_t)14) , ((((int32_t)p_45 + (int32_t)(l_238 = l_193)) != (p_45 > p_45)) || (((((((((((l_239 , l_238) , 0xF27B) <= p_45) & l_238) > 65533U) >= p_45) , l_240) , l_239.f0) ^ l_207) , 0x26AA) >= p_45))))) + (int32_t)p_45));
            if (p_45)
                break;
        }
        l_194 &= (3U && ((l_240 , ((int16_t)p_45 << (int16_t)5)) , (!(((int16_t)(p_45 && ((int16_t)((l_199 = func_46(l_218, ((int16_t)(l_207 = 0x1771) * (int16_t)__builtin_parity((l_240.f3 ^= func_46(l_218, l_240.f6, l_250, l_240.f2)))), l_199, l_219.f0)) ^ p_45) << (int16_t)p_45)) << (int16_t)p_45) <= 4294967295U))));
        for (l_250 = 23; (l_250 <= (-19)); l_250 -= 7)
        { /* block id: 143 */
            uint32_t l_257 = 4294967295U;
            uint32_t l_258 = 0x8901DACA;
            int32_t l_261 = 0xEFD0CC27;
            int32_t l_262 = (-1);
            struct S1 l_264 = {1396,9U,0x77F44A9B,-35541,6,20175,23};
            int32_t l_274 = 1;
            union U2 l_282 = {6U};
            if (((uint16_t)(((int16_t)(((p_45 , (4294967290U ^ (l_212.f1 = ((l_240.f3 | p_45) > (func_46(func_62((l_258 &= (l_257 |= l_250)), (((l_199 = (((uint16_t)func_46(l_219, p_45, p_45, (l_261 &= p_45)) << (uint16_t)6) <= p_45)) & l_262) && l_199), l_262), l_240.f6, p_45, l_240.f6) | l_194))))) == 65535U) != p_45) * (int16_t)p_45) == l_193) % (uint16_t)p_45))
            { /* block id: 149 */
                uint32_t l_263 = 8U;
                l_219.f0 = (((p_45 != l_263) | (0 ^ __builtin_ctz(p_45))) <= __builtin_ctzll(p_45));
            }
            else
            { /* block id: 151 */
                return l_264;
            }
            for (l_258 = 0; (l_258 > 11); l_258 += 6)
            { /* block id: 156 */
                union U2 l_267 = {65535U};
                int32_t l_280 = 0xBC57D954;
                int32_t l_281 = 0;
                int32_t l_285 = 0x6E27D13A;
                l_219 = func_51((l_267 , ((((l_240.f0 >= (((l_267.f1 = p_45) != ((int16_t)((l_281 = (((((uint16_t)((int16_t)l_274 >> (int16_t)0) % (uint16_t)(-(uint32_t)(((int32_t)((uint32_t)(l_280 = l_218.f0) + (uint32_t)((l_219.f0 = (__builtin_ffsl(p_45) & ((func_60(func_60(func_60(func_62(l_250, l_281, l_281)))) , p_45) || 0x29B32BA9))) && p_45)) + (int32_t)0x30061F07) != 0x16B0A57D))) , l_240.f3) & l_240.f0) || 4294967295U)) , p_45) >> (int16_t)p_45)) || 0x7C4C)) | 9U) < p_45) , l_219)), l_282, p_45, p_45);
                l_264.f6 = ((l_264.f3 = (0x34A2 < (((l_267.f1 = p_45) | (((l_199 &= (l_219.f0 = ((p_45 && l_281) && l_281))) != __builtin_popcountll(((int16_t)((l_286 = l_285) || (p_45 != (p_45 > (l_287 , l_281)))) << (int16_t)l_281))) < p_45)) ^ p_45))) ^ p_45);
                l_281 = ((l_240.f0 = l_280) && p_45);
            }
        }
    }
    else
    { /* block id: 172 */
        uint32_t l_288 = 1U;
        int32_t l_293 = 0x1FA9AA87;
        int16_t l_294 = (-5);
        struct S1 l_299 = {-2420,3U,0x0E8798E1,37778,7,24613,1};
        l_288 |= p_45;
        if ((p_45 < ((((int16_t)func_46(l_218, ((65526U & ((l_293 = (l_194 = ((int16_t)p_45 % (int16_t)p_45))) , (l_286 |= 0x4BDB))) >= (l_288 == l_294)), (((uint16_t)((__builtin_popcount(p_45) , l_207) != p_45) * (uint16_t)p_45) >= p_45), l_288) * (int16_t)0x9577) == l_294) ^ (-10))))
        { /* block id: 177 */
            uint32_t l_297 = 4294967295U;
            int32_t l_298 = 0x61B192D8;
            l_298 = l_297;
            l_299 = l_299;
            l_298 = l_194;
            l_298 = l_193;
        }
        else
        { /* block id: 182 */
            return l_299;
        }
        l_299.f6 ^= 0x1C1011CA;
    }
    return l_300;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_46(struct S0  p_47, uint16_t  p_48, uint32_t  p_49, uint16_t  p_50)
{ /* block id: 103 */
    uint32_t l_188 = 7U;
    int16_t l_189 = (-6);
    int32_t l_190 = 0xEB52EEBB;
    p_47.f0 &= l_188;
    l_190 |= (p_47.f0 ^= l_189);
    return l_189;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_51(struct S0  p_52, union U2  p_53, int32_t  p_54, int32_t  p_55)
{ /* block id: 92 */
    int32_t l_157 = (-6);
    int32_t l_177 = 0xC7099BD4;
    int32_t l_178 = (-10);
    int32_t l_179 = 0xEEABB79E;
    int32_t l_180 = 2;
    int32_t l_181 = 0xFD6F7C90;
    int32_t l_182 = 6;
    int32_t l_183 = 0x7D062AD8;
    int32_t l_184 = (-10);
    uint32_t l_185 = 1U;
    int32_t l_186 = 0;
    struct S0 l_187 = {-192};
    l_186 &= (l_157 == ((uint32_t)(((uint16_t)(p_52.f0 ^ (((l_157 == p_55) ^ ((((l_184 = (l_183 = (((l_182 ^= ((p_53 , ((-(uint32_t)l_157) , (p_52.f0 , ((int16_t)p_53.f0 * (int16_t)(l_181 = ((uint16_t)((uint16_t)(l_180 = ((int16_t)(l_179 ^= (((((uint16_t)(l_178 = ((uint16_t)((((int16_t)(l_177 &= (((-1) <= l_157) >= 65535U)) % (int16_t)0x445E) , 65535U) | 0xC0CB) >> (uint16_t)l_157)) % (uint16_t)l_157) <= l_157) > l_157) < l_157)) * (int16_t)p_54)) - (uint16_t)l_157) >> (uint16_t)p_52.f0)))))) || 0x2FA66786)) < l_157) && p_54))) , l_179) , p_55) == p_54)) == 0x00D59F51)) * (uint16_t)l_157) | 8U) % (uint32_t)l_185));
    return l_187;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_56(struct S0  p_57, int32_t  p_58, uint16_t  p_59)
{ /* block id: 47 */
    int32_t l_93 = (-1);
    union U2 l_97 = {0x9556};
    int32_t l_104 = 0;
    struct S1 l_106 = {-1887,0U,0x046699CB,44143,9,29879,-6};
    int32_t l_120 = 0;
    uint32_t l_121 = 0xEB00D6BF;
    uint32_t l_150 = 4294967291U;
    struct S0 l_154 = {161};
    if ((l_93 , ((int16_t)p_59 * (int16_t)p_58)))
    { /* block id: 48 */
        int32_t l_96 = (-7);
        int32_t l_105 = (-1);
        l_96 = (-10);
        p_57.f0 = p_59;
        if (((l_97 , l_93) > (l_105 = ((int32_t)((uint16_t)l_96 << (uint16_t)11) + (int32_t)(l_104 = ((int16_t)l_97.f0 << (int16_t)10))))))
        { /* block id: 53 */
            uint32_t l_107 = 0xDFDFBAD2;
            l_106 = l_106;
            l_105 = l_107;
            p_57.f0 ^= 0x610DA34D;
        }
        else
        { /* block id: 57 */
            struct S1 l_110 = {-1812,0xCFE06C79,-8,40722,6,18114,22};
            for (l_105 = (-23); (l_105 >= 5); l_105 += 1)
            { /* block id: 60 */
                int16_t l_113 = 6;
                p_57 = func_62(p_57.f0, (l_110 , p_58), l_96);
                for (l_93 = 0; (l_93 < 11); l_93 += 1)
                { /* block id: 64 */
                    p_58 = (l_113 , p_58);
                }
                if (p_58)
                    break;
            }
        }
        for (l_97.f3 = 28; (l_97.f3 < 29); l_97.f3 += 1)
        { /* block id: 72 */
            l_106 = l_106;
        }
    }
    else
    { /* block id: 75 */
        uint16_t l_124 = 0xE566;
        p_58 = ((int16_t)((int16_t)(l_120 == l_121) << (int16_t)((uint16_t)7U + (uint16_t)((1U >= p_58) <= l_106.f6))) * (int16_t)l_124);
    }
    if (((uint32_t)(~0xFF75AEE6) - (uint32_t)((int16_t)(p_57.f0 ^ (l_106.f1 > ((uint16_t)65535U >> (uint16_t)((uint16_t)((uint16_t)(p_57 , 1U) * (uint16_t)1) >> (uint16_t)((uint16_t)(l_106.f2 = ((int32_t)l_106.f5 + (int32_t)(l_106.f3 ^ 0xE2A5))) << (uint16_t)5))))) << (int16_t)8)))
    { /* block id: 79 */
        int32_t l_146 = 0x6850493E;
        int32_t l_147 = (-9);
        p_57.f0 = p_58;
        l_104 ^= (((int16_t)((l_106.f0 = (l_106.f2 = ((l_146 = (((int16_t)((p_59 , (l_147 ^= (p_57.f0 || ((l_146 ^ l_146) <= l_146)))) >= 0x46E9) - (int16_t)((int32_t)l_146 - (int32_t)0)) != (p_58 || 0xB985A9A9))) > 65529U))) | p_58) * (int16_t)0xE2C5) != p_57.f0);
        l_106.f2 |= p_58;
    }
    else
    { /* block id: 87 */
        int32_t l_153 = 0x5522D6D4;
        p_57.f0 = (l_106.f0 & l_150);
        l_153 |= ((uint16_t)p_57.f0 >> (uint16_t)4);
    }
    return l_154;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_60(struct S0  p_61)
{ /* block id: 40 */
    uint16_t l_73 = 5U;
    int16_t l_78 = 0x327B;
    uint16_t l_82 = 1U;
    union U2 l_86 = {0x7774};
    int32_t l_90 = 0x2E6445A0;
    int32_t l_91 = 1;
    struct S0 l_92 = {-485};
    l_82 = (l_73 != (l_73 & (((!(((uint16_t)(p_61.f0 < (l_73 , l_73)) % (uint16_t)(l_73 | ((!(l_73 , (((((l_78 , (((uint16_t)(-(uint16_t)l_73) * (uint16_t)p_61.f0) == 0x9C36)) >= 0U) >= l_78) & 0xF5B60AA0) || 0x78C3FCEE))) | 1U))) <= p_61.f0)) < p_61.f0) >= 1)));
    l_91 = (((uint16_t)(0x5AE5 > (!((l_73 && ((l_86 , (l_86.f0 , (((uint16_t)((l_86.f1 = (((p_61.f0 = 1) != (~l_82)) <= ((l_86.f0 <= (l_90 |= __builtin_clz(l_82))) , l_90))) , l_78) - (uint16_t)0x0679) ^ l_78))) < (-9))) >= l_78))) * (uint16_t)l_82) < l_82);
    return l_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_62(uint16_t  p_63, int16_t  p_64, uint16_t  p_65)
{ /* block id: 37 */
    uint32_t l_70 = 0U;
    int32_t l_71 = (-4);
    struct S0 l_72 = {-62};
    l_71 &= l_70;
    return l_72;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 157
   depth: 1, occurrence: 51
XXX total union variables: 11

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 62
breakdown:
   indirect level: 0, occurrence: 62
XXX full-bitfields structs in the program: 32
breakdown:
   indirect level: 0, occurrence: 32
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 33
XXX times a bitfields struct on RHS: 87
XXX times a single bitfield on LHS: 69
XXX times a single bitfield on RHS: 122

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 29
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 37, occurrence: 2
   depth: 40, occurrence: 2
   depth: 41, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 773
XXX times a non-volatile is write: 276
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 114
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 30
   depth: 2, occurrence: 26
   depth: 3, occurrence: 18
   depth: 4, occurrence: 11

XXX percentage a fresh-made variable is used: 20.7
XXX percentage an existing variable is used: 79.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

