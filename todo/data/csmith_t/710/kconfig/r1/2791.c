/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      969924120
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 26;
   int16_t  f1;
   signed f2 : 31;
};

union U1 {
   const uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
};

union U2 {
   uint32_t  f0;
   uint32_t  f1;
   unsigned f2 : 15;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_30(void);
static uint32_t  func_32(int16_t  p_33, const struct S0  p_34, float  p_35, uint32_t  p_36);
inline static uint16_t  func_41(const struct S0  p_42);
inline static struct S0  func_43(int32_t  p_44, float  p_45, uint32_t  p_46, float  p_47);
static uint16_t  func_52(union U1  p_53, struct S0  p_54, struct S0  p_55);
inline static struct S0  func_57(uint32_t  p_58, union U2  p_59, int16_t  p_60);
static uint16_t  func_61(struct S0  p_62, int16_t  p_63, uint32_t  p_64);
static uint32_t  func_83(union U1  p_84, int32_t  p_85, int16_t  p_86);
inline static union U1  func_87(union U1  p_88, union U1  p_89, int32_t * p_90, struct S0  p_91, union U2 * p_92);
inline static union U1  func_93(union U2  p_94, int32_t * p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_30(void)
{ /* block id: 36 */
    uint32_t l_31 = 4294967295U;
    union U1 l_56 = {0U};
    struct S0 l_65 = {7659,0xEC6C,16244};
    union U2 l_73 = {4294967286U};
    int32_t l_585 = (-1);
    const int32_t * const l_584 = &l_585;
    int32_t *l_596 = &l_585;
    union U1 *l_611 = &l_56;
    union U1 **l_610 = &l_611;
    int32_t l_632 = 0x40D96EB0;
    uint16_t l_639 = 0x2AC6;
    union U1 l_645 = {4294967295U};
lbl_636:
    if ((l_31 <= (func_32(((uint16_t)((((uint16_t)func_41(func_43(l_31, l_31, ((((int32_t)(((uint16_t)func_52(l_56, func_57(((func_61(l_65, l_31, ((~(__builtin_bswap64(l_65.f0) <= ((int16_t)(((uint32_t)l_65.f2 + (uint32_t)5U) && l_65.f2) >> (int16_t)13))) && l_56.f1)) >= l_65.f2) & l_65.f1), l_73, l_31), l_65) << (uint16_t)6) && l_65.f1) - (int32_t)0x7338D581) ^ 4) > l_56.f2), l_73.f0)) >> (uint16_t)13) & l_73.f0) >= l_56.f1) + (uint16_t)l_73.f1), l_65, l_65.f1, l_65.f1) > 4294967286U)))
    { /* block id: 427 */
        int32_t l_578 = 0x5ECCFE28;
        const int32_t *l_577 = &l_578;
        int32_t *l_580 = &l_578;
        int32_t **l_579 = &l_580;
        int32_t **l_586 = &l_580;
        (*l_579) = l_577;
        for (l_73.f1 = (-16); (l_73.f1 == 25); l_73.f1 += 1)
        { /* block id: 431 */
            uint32_t l_583 = 2U;
            (**l_579) = (((*l_577) <= l_73.f3) || (((0x6751C904 | (*l_580)) > (l_583 ^ 65535U)) <= __builtin_clzl(l_65.f2)));
        }
        /* facts after for loop */
                (*l_586) = l_584;
        /* statement id: 434 */
        assert (l_580 == &l_585);
    }
    else
    { /* block id: 435 */
        int32_t *l_590 = &l_585;
        int32_t **l_589 = &l_590;
        int32_t ***l_588 = &l_589;
        int32_t ****l_587 = &l_588;
        float l_592 = (-0x1.2p-1);
        float *l_591 = &l_592;
        (*l_591) = ((void*)0 != l_587);
        if (l_56.f2)
            goto lbl_593;
lbl_593:
        (*l_589) = (***l_587);
        for (l_585 = 19; (l_585 > 26); l_585++)
        { /* block id: 441 */
            int32_t l_597 = 0xAEBA5A67;
            (***l_587) = l_596;
            if (l_597)
                break;
        }
        /* facts after for loop */
        assert (l_590 == 0 || l_590 == &l_585);
    }
    /* facts after branching */
        for (l_73.f3 = 20; (l_73.f3 < (-9)); l_73.f3 -= 8)
    { /* block id: 448 */
        float l_603 = 0xA.01509Ap-10;
        int32_t l_604 = 0x5EA165C4;
        uint16_t l_633 = 0x9B0D;
        const float *l_641 = (void*)0;
        const float **l_640 = &l_641;
        for (l_56.f2 = (-27); (l_56.f2 < 21); l_56.f2 += 1)
        { /* block id: 451 */
            int32_t **l_602 = &l_596;
            float l_616 = 0xB.D6205Bp+3;
            int32_t l_627 = (-8);
            const struct S0 *l_642 = &l_65;
            (*l_602) = &l_585;
            /* statement id: 452 */
            assert (l_596 == &l_585);
            if (((l_604 < 0xAE71) == l_604))
            { /* block id: 453 */
                int16_t l_607 = 1;
                int32_t *l_612 = (void*)0;
                int32_t l_617 = 1;
                int32_t l_631 = 0xCBC974CA;
                float *l_637 = (void*)0;
                float *l_638 = &l_603;
                struct S0 *l_643 = (void*)0;
                if ((((int16_t)l_604 + (int16_t)((((l_607 == (func_61(func_57(__builtin_clz(((uint16_t)(l_610 == &l_611) >> (uint16_t)8)), l_73, l_604), l_604, (**l_602)) > (**l_602))) != l_607) || 1) & 4294967290U)) > (**l_602)))
                { /* block id: 454 */
                    if (l_604)
                        break;
                    (**l_602) = ((void*)0 != l_612);
                }
                else
                { /* block id: 457 */
                    const int32_t l_615 = 1;
                    l_596 = (void*)0;
                    /* statement id: 458 */
                    assert (l_596 == 0);
                    if ((((int32_t)l_615 + (int32_t)(l_617 ^ ((uint16_t)((__builtin_popcountll((l_604 <= ((uint16_t)(((int16_t)(*l_584) - (int16_t)((uint32_t)((~func_61(func_43(l_604, l_627, ((((l_615 || (+l_604)) == (((int16_t)((0 < (-3)) >= l_604) >> (int16_t)3) >= l_615)) != (-4)) & (*l_584)), l_631), l_632, l_615)) < l_627) - (uint32_t)l_615)) || l_633) << (uint16_t)l_604))) | l_633) | (*l_584)) - (uint16_t)(*l_584)))) > 4294967295U))
                    { /* block id: 459 */
                        float *l_634 = &l_603;
                        (*l_634) = l_615;
                    }
                    else
                    { /* block id: 461 */
                        int32_t l_635 = (-1);
                        l_604 = l_635;
                    }
                    if (l_585)
                        goto lbl_636;
                }
                /* facts after branching */
                assert (l_596 == 0 || l_596 == &l_585);
                (*l_638) = l_604;
                l_65 = func_43(l_639, (*l_584), l_633, (((-0x1.Ep+1) < l_604) == (((void*)0 != l_640) == (l_642 == (void*)0))));
            }
            else
            { /* block id: 468 */
                float *l_644 = &l_616;
                (*l_644) = 0x2.0D8CFCp-11;
            }
            /* facts after branching */
            assert (l_596 == 0 || l_596 == &l_585);
        }
        /* facts after for loop */
            }
    /* facts after for loop */
        return l_645;
    /* statement id: 473 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(int16_t  p_33, const struct S0  p_34, float  p_35, uint32_t  p_36)
{ /* block id: 420 */
    int32_t l_567 = (-1);
    union U2 l_568 = {4294967295U};
    struct S0 l_569 = {6648,2,33166};
    float l_574 = 0x7.BA0361p+7;
    float *l_573 = &l_574;
    float **l_572 = &l_573;
    int32_t *l_576 = &l_567;
    l_569 = func_57(l_567, l_568, func_61(p_34, __builtin_parity(l_567), p_34.f2));
    if (p_34.f2)
        goto lbl_575;
lbl_575:
    l_567 = __builtin_clzll((((int16_t)p_36 << (int16_t)10) != ((void*)0 != l_572)));
    (*l_576) = p_34.f1;
    p_35 = 0x6.7p-1;
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_41(const struct S0  p_42)
{ /* block id: 49 */
    union U2 l_96 = {0xD119E2D4};
    int32_t *l_97 = (void*)0;
    struct S0 l_520 = {6298,0,-19547};
    int16_t l_541 = (-10);
    const int32_t **l_565 = (void*)0;
    int32_t **l_566 = &l_97;
    if ((func_83(func_87(func_93(l_96, l_97), func_93(l_96, l_97), l_97, l_520, &l_96), l_96.f1, p_42.f1) > 0x2525824C))
    { /* block id: 387 */
        int32_t l_533 = (-3);
        int32_t l_540 = 0;
        const int32_t *l_539 = &l_540;
        const int32_t **l_538 = &l_539;
        for (l_96.f3 = 1; (l_96.f3 > 10); l_96.f3++)
        { /* block id: 390 */
            struct S0 *l_534 = &l_520;
            struct S0 ***l_535 = (void*)0;
            struct S0 **l_537 = (void*)0;
            struct S0 ***l_536 = &l_537;
            (*l_534) = func_43(((int32_t)1 % (int32_t)0xBCCF0C64), l_533, p_42.f0, p_42.f2);
            (*l_536) = &l_534;
            /* statement id: 392 */
            assert (l_537 == &l_534);
            return l_533;
        }
        /* facts after for loop */
                (*l_538) = l_97;
        /* statement id: 395 */
        assert (l_539 == 0);
    }
    else
    { /* block id: 396 */
        union U2 *l_545 = &l_96;
        union U2 **l_544 = &l_545;
        union U2 ***l_543 = &l_544;
        union U2 **** const l_542 = &l_543;
        union U2 ****l_548 = (void*)0;
        int32_t l_549 = (-7);
        int32_t *l_551 = &l_549;
        const union U1 l_560 = {0x6AD1D736};
        const union U1 *l_559 = &l_560;
        if (l_541)
        { /* block id: 397 */
            const union U2 *****l_546 = (void*)0;
            const union U2 *****l_547 = (void*)0;
            int32_t *l_550 = &l_549;
            l_548 = l_542;
            /* statement id: 398 */
            assert (l_548 == &l_543);
            (*l_550) = __builtin_ffsl((l_541 | __builtin_bswap64(l_549)));
            l_551 = &l_549;
            return p_42.f0;
        }
        else
        { /* block id: 402 */
            union U2 ***l_554 = &l_544;
            for (l_549 = 13; (l_549 >= (-16)); l_549--)
            { /* block id: 405 */
                int32_t l_556 = 0x18059FE5;
                int32_t *l_555 = &l_556;
                (*l_555) = (l_554 == (void*)0);
                if (p_42.f2)
                    break;
                for (l_520.f1 = (-17); (l_520.f1 < 26); l_520.f1 += 9)
                { /* block id: 410 */
                    union U1 *l_562 = (void*)0;
                    union U1 **l_561 = &l_562;
                    const int32_t *l_564 = (void*)0;
                    const int32_t **l_563 = &l_564;
                    (*l_561) = l_559;
                    /* statement id: 411 */
                    assert (l_562 == &l_560);
                    (*l_563) = &l_549;
                    /* statement id: 412 */
                    assert (l_564 == &l_549);
                    if (p_42.f1)
                        continue;
                }
            }
        }
    }
    /* facts after branching */
        (*l_566) = l_97;
    return p_42.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_43(int32_t  p_44, float  p_45, uint32_t  p_46, float  p_47)
{ /* block id: 46 */
    float *l_79 = (void*)0;
    float l_81 = 0x0.Ep+1;
    float *l_80 = &l_81;
    struct S0 l_82 = {3591,0x5BCD,-42261};
    (*l_80) = 0xF.DFDEEAp-83;
    return l_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_52(union U1  p_53, struct S0  p_54, struct S0  p_55)
{ /* block id: 43 */
    int32_t l_78 = 0;
    int32_t *l_77 = &l_78;
    (*l_77) = 1;
    return p_53.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_57(uint32_t  p_58, union U2  p_59, int16_t  p_60)
{ /* block id: 40 */
    int32_t *l_74 = (void*)0;
    int32_t l_75 = 0xF39588DF;
    struct S0 l_76 = {5048,0xD335,-24885};
    l_75 = 0;
    return l_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_61(struct S0  p_62, int16_t  p_63, uint32_t  p_64)
{ /* block id: 37 */
    union U2 l_72 = {0x9ED18909};
    union U2 *l_71 = &l_72;
    l_71 = (void*)0;
    /* statement id: 38 */
    assert (l_71 == 0);
    return l_72.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_83(union U1  p_84, int32_t  p_85, int16_t  p_86)
{ /* block id: 384 */
    struct S0 l_527 = {3501,0x0943,-17348};
    struct S0 *l_528 = &l_527;
    (*l_528) = l_527;
    return l_527.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_87(union U1  p_88, union U1  p_89, int32_t * p_90, struct S0  p_91, union U2 * p_92)
{ /* block id: 381 */
    union U2 ****l_521 = (void*)0;
    union U2 *l_526 = (void*)0;
    union U2 **l_525 = &l_526;
    union U2 *** const l_524 = &l_525;
    union U2 *** const *l_523 = &l_524;
    union U2 *** const **l_522 = &l_523;
    (*l_522) = l_521;
    /* statement id: 382 */
    assert (l_523 == 0);
    return p_89;
    /* statement id: 383 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_93(union U2  p_94, int32_t * p_95)
{ /* block id: 50 */
    float l_101 = 0xF.3987EDp-68;
    float *l_100 = &l_101;
    int32_t l_125 = 0x432CFC9A;
    int32_t *l_126 = &l_125;
    union U1 l_129 = {0x2B282FFB};
    struct S0 l_130 = {6674,6,-26068};
    int32_t **l_151 = &l_126;
    int32_t ***l_150 = &l_151;
    int32_t ****l_149 = &l_150;
    struct S0 l_185 = {997,0x9146,18662};
    union U2 l_252 = {0x7983243E};
    union U2 *l_251 = &l_252;
    int16_t l_273 = 0xECD8;
    const int32_t *l_307 = &l_125;
    struct S0 * const l_425 = &l_130;
    struct S0 * const *l_424 = &l_425;
    uint32_t l_426 = 4U;
    uint32_t l_488 = 4294967290U;
    float l_489 = 0x0.DF1FDCp-37;
    union U1 ***l_515 = (void*)0;
    float * const ** const *l_516 = (void*)0;
    for (p_94.f1 = 0; (p_94.f1 > 46); ++p_94.f1)
    { /* block id: 53 */
        int32_t l_108 = 0;
        struct S0 l_113 = {3168,0,-27994};
        int32_t *l_118 = &l_108;
        int32_t **l_117 = &l_118;
        union U2 l_120 = {0x8F9F05BB};
        union U2 *l_119 = &l_120;
        if (((void*)0 == l_100))
        { /* block id: 54 */
            int32_t l_104 = 1;
            int32_t *l_103 = &l_104;
            int32_t **l_102 = &l_103;
            const int32_t *l_107 = &l_104;
            const int32_t **l_106 = &l_107;
            const int32_t ***l_105 = &l_106;
            (*l_105) = l_102;
            /* statement id: 55 */
            assert (l_106 == &l_103);
            (*l_103) = (((0xCA80087D != 4294967295U) ^ l_108) < ((uint32_t)l_108 % (uint32_t)p_94.f0));
            for (l_104 = 0; (l_104 >= 22); ++l_104)
            { /* block id: 59 */
                struct S0 *l_114 = &l_113;
                (**l_105) = p_95;
                /* statement id: 60 */
                assert (l_103 == 0);
                (*l_114) = l_113;
            }
            /* facts after for loop */
            assert (l_103 == 0 || l_103 == &l_104);
        }
        else
        { /* block id: 63 */
            int32_t *l_116 = &l_108;
            int32_t **l_115 = &l_116;
            l_117 = l_115;
            /* statement id: 64 */
            assert (l_117 == &l_116);
        }
        /* facts after branching */
        //assert (l_117 == dangling || l_117 == &l_118);
        l_119 = &p_94;
        /* statement id: 66 */
        assert (l_119 == &p_94);
        (*l_118) = ((int16_t)((p_94.f0 >= l_125) < (((void*)0 == p_95) >= l_125)) - (int16_t)p_94.f1);
        (*l_100) = p_94.f3;
    }
    /* facts after for loop */
        return l_129;
    /* statement id: 380 */
    }




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 163
   depth: 1, occurrence: 23
XXX total union variables: 17

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 55
breakdown:
   indirect level: 0, occurrence: 27
   indirect level: 1, occurrence: 20
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 39
XXX times a bitfields struct on LHS: 8
XXX times a bitfields struct on RHS: 62
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 41

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 29, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 200

XXX times a variable address is taken: 182
XXX times a pointer is dereferenced on RHS: 65
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 12
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 112
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 14
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 310

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 171
   level: 2, occurrence: 61
   level: 3, occurrence: 37
   level: 4, occurrence: 15
XXX number of pointers point to pointers: 106
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 28
XXX average alias set size: 1.21

XXX times a non-volatile is read: 714
XXX times a non-volatile is write: 352
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 4
XXX backward jumps: 5

XXX stmts: 77
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 15
   depth: 2, occurrence: 17
   depth: 3, occurrence: 9
   depth: 4, occurrence: 8
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 25.5
XXX percentage an existing variable is used: 74.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

