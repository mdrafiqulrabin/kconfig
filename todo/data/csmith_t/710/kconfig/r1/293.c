/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3229825104
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   signed f1 : 19;
   uint16_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0U;
static struct S0 g_32 = {0x58331C58,479,0xAB89};
static struct S0 g_94 = {9U,-453,0x9E29};
static struct S0 g_186 = {4294967295U,-16,0xA3BE};
static struct S0 g_213 = {0xAE1A41AF,529,0xB45E};
static uint16_t g_226 = 0U;
static uint16_t g_256 = 1U;
static int16_t g_321 = 4;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_28(void);
static struct S0  func_33(int32_t  p_34, uint32_t  p_35);
static uint16_t  func_36(int16_t  p_37, uint32_t  p_38, struct S0  p_39, uint32_t  p_40, int32_t  p_41);
static int16_t  func_44(uint16_t  p_45);
static struct S0  func_50(uint32_t  p_51);
static uint16_t  func_56(int32_t  p_57, int32_t  p_58);
static uint16_t  func_61(int32_t  p_62);
static struct S0  func_64(int32_t  p_65, uint32_t  p_66, uint32_t  p_67, int32_t  p_68, uint32_t  p_69);
static int16_t  func_70(int32_t  p_71, uint32_t  p_72);
static uint32_t  func_81(uint32_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_32.f2 g_32.f0 g_32.f1 g_94 g_32 g_186.f0 g_186.f2 g_213 g_226 g_186.f1 g_256 g_321
 * writes: g_3 g_32 g_94 g_186 g_213.f1 g_226 g_213
 */
static uint32_t  func_28(void)
{ /* block id: 36 */
    struct S0 l_31 = {0x34B0B4EF,702,0x17B7};
    int16_t l_235 = 0xBF03;
    int32_t l_241 = 0x1BAF4815;
    struct S0 l_245 = {6U,97,0x69F7};
    int16_t l_303 = 0x3025;
    struct S0 l_330 = {9U,590,1U};
    for (g_3 = 0; (g_3 != 49); g_3 += 1)
    { /* block id: 39 */
        if (g_3)
            break;
    }
    g_32 = l_31;
    l_31 = func_33((func_36(((uint16_t)l_31.f1 + (uint16_t)func_44(g_32.f2)), g_32.f2, g_213, (-(uint16_t)__builtin_bswap64((((((int16_t)((uint16_t)l_31.f2 << (uint16_t)2) - (int16_t)0xDE13) <= (0x3CF2 || ((int16_t)l_31.f1 << (int16_t)6))) & g_213.f2) <= 0xE57383A1))), g_213.f1) == g_213.f2), g_32.f2);
    if ((l_235 & (__builtin_ctzll(g_226) & 0xFFDF)))
    { /* block id: 106 */
        int32_t l_238 = 0xE36BA894;
        int32_t l_271 = 0x234616B0;
        struct S0 l_301 = {0x4F8A200C,417,65530U};
        struct S0 l_307 = {4294967295U,659,0U};
        if ((((uint16_t)((l_238 ^ (((int32_t)(g_213.f1 || l_241) % (int32_t)((((-(uint32_t)((l_31.f0 & l_238) >= (0xD12E >= (g_226 < (g_186.f0 & (((uint16_t)l_31.f1 << (uint16_t)g_186.f1) || g_32.f0)))))) >= l_238) == g_226) && l_238)) != g_213.f2)) > g_3) >> (uint16_t)7) & g_94.f2))
        { /* block id: 107 */
            int32_t l_272 = 1;
            int32_t l_273 = (-1);
            struct S0 l_300 = {0x590F9319,-621,0x82F8};
            g_213 = l_245;
            if (((((((int32_t)func_56(l_245.f2, l_238) + (int32_t)((0x0EE2 > 0U) != ((int16_t)((uint32_t)__builtin_parity(((int16_t)g_213.f1 - (int16_t)(g_32.f0 > (g_213.f1 ^ ((uint16_t)(g_94.f0 == l_31.f2) % (uint16_t)65532U))))) + (uint32_t)l_238) << (int16_t)3))) <= 65528U) >= g_256) != l_245.f0) || l_245.f1))
            { /* block id: 109 */
                uint32_t l_259 = 0x1D9BD75C;
                g_186.f1 = ((uint32_t)((l_259 && (__builtin_popcountll(l_238) < (g_186.f2 | l_31.f2))) != ((int16_t)((uint16_t)((int16_t)g_32.f2 << (int16_t)9) + (uint16_t)func_56(func_36(((((((uint16_t)l_259 - (uint16_t)((int16_t)g_256 - (int16_t)(!l_241))) != 0xE99ADD51) <= g_186.f1) ^ l_238) == l_238), l_241, l_245, l_245.f2, g_213.f0), g_3)) + (int16_t)0xDF76)) - (uint32_t)l_271);
            }
            else
            { /* block id: 111 */
                int32_t l_288 = 0;
                int32_t l_289 = 0;
                int32_t l_295 = (-1);
                l_272 = 0x78212C63;
                l_273 = g_94.f0;
                g_213 = func_50(__builtin_parityll(((uint16_t)(((7 <= l_272) || (0U != g_94.f1)) == 0xF09B) >> (uint16_t)(((uint16_t)((int32_t)(((((int16_t)((int16_t)((((int16_t)((l_271 > __builtin_ffsll(g_32.f1)) < ((uint32_t)((g_213.f0 <= 2) >= l_235) - (uint32_t)l_288)) >> (int16_t)3) ^ g_3) | g_3) - (int16_t)l_271) >> (int16_t)9) & l_289) | g_213.f2) <= g_213.f2) % (int32_t)g_32.f1) << (uint16_t)l_289) < 0x6268))));
                if ((((uint16_t)g_186.f2 << (uint16_t)l_272) == ((((int16_t)(-(int16_t)l_289) - (int16_t)1U) <= g_32.f2) > l_271)))
                { /* block id: 115 */
                    l_295 = (__builtin_parityll(l_272) ^ g_256);
                    if (l_273)
                    { /* block id: 117 */
                        g_186.f1 = l_272;
                        g_94.f1 = (-1);
                    }
                    else
                    { /* block id: 120 */
                        g_186 = g_32;
                        g_32.f1 = 0;
                        return g_32.f0;
                    }
                    g_32.f1 = (((int16_t)((uint32_t)4294967293U % (uint32_t)g_32.f2) << (int16_t)2) < g_3);
                }
                else
                { /* block id: 126 */
                    uint32_t l_302 = 0x3EDEECB3;
                    l_245 = func_33(l_241, l_288);
                    l_301 = l_300;
                    l_302 = g_32.f1;
                    l_303 = g_32.f0;
                }
            }
        }
        else
        { /* block id: 133 */
            struct S0 l_304 = {1U,321,0U};
            l_304 = g_32;
        }
        for (g_32.f0 = (-25); (g_32.f0 <= 27); g_32.f0 += 2)
        { /* block id: 138 */
            struct S0 l_308 = {1U,-315,0xD8CB};
            l_308 = l_307;
            if (g_226)
                break;
            for (l_301.f0 = 12; (l_301.f0 <= 35); l_301.f0 += 1)
            { /* block id: 143 */
                for (l_31.f2 = (-24); (l_31.f2 < 58); l_31.f2 += 7)
                { /* block id: 146 */
                    uint32_t l_319 = 0x0537F6AC;
                    g_94 = func_64(g_94.f2, (((int16_t)(l_308.f1 || ((uint32_t)((int16_t)(1 ^ ((((((((0xC66B < l_308.f1) | g_213.f2) | l_238) && l_319) || (~g_321)) | l_271) < 0xBCCF346C) < g_94.f1)) >> (int16_t)g_94.f1) % (uint32_t)g_186.f1)) % (int16_t)g_32.f0) & g_321), l_308.f0, g_186.f1, g_94.f2);
                }
            }
            for (l_235 = 0; (l_235 != (-12)); l_235 -= 6)
            { /* block id: 152 */
                int32_t l_324 = 0xD9FBA2D4;
                return l_324;
            }
        }
        for (l_31.f0 = (-28); (l_31.f0 <= 35); l_31.f0 += 5)
        { /* block id: 158 */
            struct S0 l_329 = {0x88F03440,316,0U};
            g_32 = g_32;
            l_307.f1 = ((int32_t)l_307.f0 % (int32_t)0x462B6A1B);
            g_213 = g_32;
            l_329 = g_32;
        }
        g_213 = l_330;
    }
    else
    { /* block id: 165 */
        g_32.f1 = 0xD2E449F4;
        g_32 = g_32;
        g_32.f1 = ((int16_t)l_330.f0 + (int16_t)g_32.f0);
        g_94.f1 = ((4294967294U | ((uint16_t)l_245.f0 + (uint16_t)((int16_t)0x32CB << (int16_t)13))) ^ l_330.f1);
    }
    return l_330.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_94.f1 g_213.f0 g_3
 * writes:
 */
static struct S0  func_33(int32_t  p_34, uint32_t  p_35)
{ /* block id: 101 */
    int32_t l_233 = 0xF2E49928;
    struct S0 l_234 = {4294967292U,697,0xD7F8};
    l_233 = (((int16_t)((uint16_t)(g_94.f1 <= p_34) + (uint16_t)1) + (int16_t)g_213.f0) > ((uint16_t)__builtin_parityll(__builtin_ctz(p_34)) << (uint16_t)13));
    l_234 = l_234;
    return l_234;
}


/* ------------------------------------------ */
/* 
 * reads : g_213.f2 g_32.f1
 * writes: g_213.f1 g_226
 */
static uint16_t  func_36(int16_t  p_37, uint32_t  p_38, struct S0  p_39, uint32_t  p_40, int32_t  p_41)
{ /* block id: 97 */
    uint32_t l_225 = 7U;
    g_213.f1 = (g_213.f2 == ((int32_t)((int16_t)1 << (int16_t)12) % (int32_t)l_225));
    g_226 = g_32.f1;
    return l_225;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_32.f0 g_32.f2 g_32.f1 g_94 g_32 g_186.f0 g_186.f2
 * writes: g_3 g_32.f0 g_32.f1 g_94 g_186
 */
static int16_t  func_44(uint16_t  p_45)
{ /* block id: 43 */
    int16_t l_63 = 0x3A81;
    int32_t l_201 = 0xE68C3BF2;
    uint32_t l_212 = 0x57F1B4AE;
    for (g_3 = 0; (g_3 <= 40); g_3 += 1)
    { /* block id: 46 */
        uint32_t l_148 = 8U;
        for (g_32.f0 = 20; (g_32.f0 < 45); g_32.f0 += 3)
        { /* block id: 49 */
            uint32_t l_149 = 0x4CFDF4E9;
            g_186 = func_50(((((int32_t)(4294967293U < g_3) - (int32_t)(func_56(((uint32_t)(func_61(l_63) > (0U >= (((g_32.f0 == ((uint32_t)g_3 - (uint32_t)(0xB9F6C78D <= ((int16_t)((((uint16_t)(((p_45 >= g_32.f0) == l_148) < 0x3C5D) + (uint16_t)g_32.f0) | 0x50ABA655) < 1U) >> (int16_t)p_45)))) <= g_32.f0) > p_45))) - (uint32_t)p_45), l_149) > p_45)) != l_149) <= 0U));
            return p_45;
        }
    }
    g_186.f1 = ((uint16_t)(((l_63 >= __builtin_ffsl(((__builtin_clzll(((uint16_t)p_45 >> (uint16_t)14)) & func_81(((int16_t)g_94.f0 << (int16_t)10))) < (((int16_t)((uint16_t)(((uint16_t)((int16_t)(__builtin_ctzll(l_63) | l_63) >> (int16_t)g_186.f0) << (uint16_t)l_63) == 3U) << (uint16_t)4) - (int16_t)65535U) == (-1))))) & p_45) != g_32.f1) << (uint16_t)l_63);
    l_201 = p_45;
    l_212 = (((uint32_t)(g_186.f0 & ((uint32_t)((uint16_t)((((l_201 == 0U) | l_63) || (((__builtin_bswap32(((p_45 <= ((uint16_t)p_45 - (uint16_t)(0x6B1F < p_45))) > ((int16_t)p_45 << (int16_t)14))) & p_45) < 4294967293U) | p_45)) == 0xF251) >> (uint16_t)0) % (uint32_t)p_45)) - (uint32_t)0U) == g_32.f0);
    return g_186.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_94.f0 g_94.f2 g_32.f0 g_32.f2 g_94.f1 g_3 g_32.f1
 * writes: g_94.f2 g_32.f1 g_94.f1
 */
static struct S0  func_50(uint32_t  p_51)
{ /* block id: 85 */
    int16_t l_172 = 2;
    int32_t l_173 = (-1);
    int32_t l_184 = 0x8911B318;
    struct S0 l_185 = {4294967295U,459,0U};
    l_173 = ((-(int32_t)p_51) > l_172);
    g_94.f1 = (g_94.f0 <= ((uint16_t)__builtin_popcount(((int16_t)l_173 + (int16_t)func_56((((int16_t)((l_173 || ((g_94.f2 && ((__builtin_bswap32(g_32.f0) == ((uint16_t)(((int32_t)g_94.f0 + (int32_t)(p_51 ^ ((g_32.f2 < 1U) <= 6))) < 0x4CA82F66) << (uint16_t)g_94.f1)) != l_172)) != g_3)) < l_184) << (int16_t)p_51) & g_32.f1), g_94.f0))) + (uint16_t)g_3));
    return l_185;
}


/* ------------------------------------------ */
/* 
 * reads : g_94.f2
 * writes: g_94.f2 g_32.f1
 */
static uint16_t  func_56(int32_t  p_57, int32_t  p_58)
{ /* block id: 72 */
    uint32_t l_151 = 0x8EBDD084;
    struct S0 l_170 = {0x1350E289,153,65535U};
    if ((-(int32_t)l_151))
    { /* block id: 73 */
        int32_t l_159 = 0x63820F02;
        for (g_94.f2 = 14; (g_94.f2 >= 52); g_94.f2 += 1)
        { /* block id: 76 */
            int32_t l_154 = 0x73FC9157;
            return l_154;
        }
        g_32.f1 = ((uint16_t)p_57 % (uint16_t)((int16_t)(((l_159 & (-(uint16_t)l_151)) == (((int16_t)(0x636B9821 < l_159) + (int16_t)l_151) && ((((((uint16_t)((uint32_t)l_159 + (uint32_t)l_151) - (uint16_t)l_151) | 4294967293U) | 3U) < 0U) == 0x20B4))) > (-5)) % (int16_t)l_151));
    }
    else
    { /* block id: 80 */
        int32_t l_169 = 1;
        return l_169;
    }
    l_170 = l_170;
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_32.f2 g_32.f1 g_32.f0 g_94 g_32
 * writes: g_32.f1 g_94
 */
static uint16_t  func_61(int32_t  p_62)
{ /* block id: 50 */
    uint32_t l_73 = 0xAE88B149;
    struct S0 l_99 = {0U,55,0x96CD};
    int32_t l_131 = 0x6A3D77AE;
    struct S0 l_141 = {0x966E863D,-380,0x33A6};
    g_32.f1 = g_3;
    l_99 = func_64(p_62, (0xA7DA != (g_32.f2 || (func_70(l_73, p_62) < p_62))), g_3, g_32.f0, l_73);
    p_62 = (((int16_t)(-1) << (int16_t)((int16_t)((uint16_t)((uint32_t)(func_81((((uint16_t)__builtin_ctz(__builtin_ffs(g_94.f1)) % (uint16_t)(((g_32.f0 | ((uint32_t)(((((int32_t)((int16_t)((l_73 ^ ((uint16_t)((((int32_t)((((uint32_t)(p_62 == (-(int16_t)(((uint16_t)((uint16_t)((l_99.f1 ^ ((((int16_t)(((p_62 != l_99.f0) | g_94.f1) != 0xF63C109E) >> (int16_t)g_32.f0) <= p_62) > g_32.f0)) ^ l_99.f1) + (uint16_t)65535U) % (uint16_t)g_32.f2) != g_94.f1))) % (uint32_t)l_99.f0) & 65535U) != 0x42F4) + (int32_t)g_94.f0) < 0x296D3241) >= l_131) + (uint16_t)l_99.f0)) > g_32.f1) << (int16_t)7) + (int32_t)l_99.f1) == 0xAA74C462) < p_62) == 0xE22A4178) - (uint32_t)0xD55ED510)) > 0x7273) && g_32.f2)) < p_62)) || g_94.f2) % (uint32_t)p_62) + (uint16_t)p_62) >> (int16_t)1)) && l_99.f2);
    if ((((uint16_t)l_131 << (uint16_t)p_62) | g_94.f0))
    { /* block id: 65 */
        g_94 = g_94;
        return g_94.f1;
    }
    else
    { /* block id: 68 */
        uint32_t l_134 = 0x0AEDAF9C;
        l_141 = func_64(((p_62 <= func_81(l_134)) | g_32.f1), (((int16_t)(((g_32.f2 | ((uint16_t)((int32_t)p_62 + (int32_t)__builtin_ctzll((l_134 | p_62))) << (uint16_t)g_32.f2)) >= g_32.f1) <= 0x72D2) % (int16_t)g_32.f0) && g_32.f1), p_62, l_134, p_62);
    }
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads : g_94 g_32
 * writes:
 */
static struct S0  func_64(int32_t  p_65, uint32_t  p_66, uint32_t  p_67, int32_t  p_68, uint32_t  p_69)
{ /* block id: 59 */
    uint32_t l_97 = 2U;
    struct S0 l_98 = {0x14ABDC48,54,0xE6F9};
    l_97 = 0x26B30262;
    l_98 = g_94;
    return g_32;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_32.f2 g_32.f1 g_32.f0
 * writes: g_94
 */
static int16_t  func_70(int32_t  p_71, uint32_t  p_72)
{ /* block id: 52 */
    int32_t l_78 = 0xEF39980A;
    struct S0 l_95 = {0x0AFAA935,-543,9U};
    uint16_t l_96 = 0x0AC9;
    l_78 = ((((int16_t)((int32_t)((l_78 > (((int16_t)((func_81(__builtin_clz(((uint32_t)(0x5AB8BF51 & (((0x900DD038 || ((int16_t)l_78 >> (int16_t)9)) >= (p_72 && ((((uint32_t)g_3 - (uint32_t)(((g_32.f2 || ((uint32_t)((((uint16_t)p_72 % (uint16_t)p_72) | g_3) == 0x536D) % (uint32_t)4294967295U)) != 0xF08A7CF5) || 5U)) & p_71) ^ 65534U))) != g_3)) + (uint32_t)p_72))) == p_72) <= 1U) >> (int16_t)10) | g_32.f1)) < l_78) % (int32_t)4U) >> (int16_t)12) < p_71) <= g_32.f0);
    l_95 = l_95;
    return l_96;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_94
 */
static uint32_t  func_81(uint32_t  p_82)
{ /* block id: 53 */
    struct S0 l_93 = {0x0754B492,-647,1U};
    g_94 = l_93;
    return l_93.f1;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_32.f0, "g_32.f0", print_hash_value);
    transparent_crc(g_32.f1, "g_32.f1", print_hash_value);
    transparent_crc(g_32.f2, "g_32.f2", print_hash_value);
    transparent_crc(g_94.f0, "g_94.f0", print_hash_value);
    transparent_crc(g_94.f1, "g_94.f1", print_hash_value);
    transparent_crc(g_94.f2, "g_94.f2", print_hash_value);
    transparent_crc(g_186.f0, "g_186.f0", print_hash_value);
    transparent_crc(g_186.f1, "g_186.f1", print_hash_value);
    transparent_crc(g_186.f2, "g_186.f2", print_hash_value);
    transparent_crc(g_213.f0, "g_213.f0", print_hash_value);
    transparent_crc(g_213.f1, "g_213.f1", print_hash_value);
    transparent_crc(g_213.f2, "g_213.f2", print_hash_value);
    transparent_crc(g_226, "g_226", print_hash_value);
    transparent_crc(g_256, "g_256", print_hash_value);
    transparent_crc(g_321, "g_321", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 45
   depth: 1, occurrence: 21
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 21
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 24
XXX times a bitfields struct on RHS: 22
XXX times a single bitfield on LHS: 14
XXX times a single bitfield on RHS: 39

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 2
   depth: 30, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 311
XXX times a non-volatile is write: 60
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 85
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 16
   depth: 2, occurrence: 14
   depth: 3, occurrence: 7
   depth: 4, occurrence: 8
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 18.5
XXX percentage an existing variable is used: 81.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

