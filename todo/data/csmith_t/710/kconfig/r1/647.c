/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1011467120
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_33(void);
inline static int32_t  func_34(uint32_t  p_35);
inline static uint32_t  func_42(uint32_t  p_43, const uint16_t  p_44, uint32_t  p_45);
inline static float  func_53(const int32_t  p_54, uint32_t  p_55, int32_t  p_56, int32_t  p_57);
inline static int32_t  func_59(uint32_t  p_60, float  p_61, int16_t  p_62, int32_t  p_63);
inline static uint32_t  func_72(int32_t  p_73, int32_t  p_74, float  p_75, uint16_t  p_76);
inline static uint32_t  func_80(uint32_t  p_81, uint32_t  p_82, int16_t  p_83);
static uint16_t  func_87(uint16_t  p_88, float  p_89, uint16_t  p_90, uint16_t  p_91);
inline static float  func_94(int32_t  p_95, uint16_t  p_96);
inline static int32_t  func_97(int32_t  p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_33(void)
{ /* block id: 36 */
    int16_t l_36 = 0;
    int32_t l_846 = (-1);
    int32_t *l_845 = &l_846;
    int32_t **l_844 = &l_845;
    int32_t ***l_843 = &l_844;
    uint32_t l_849 = 4294967295U;
    if (func_34(l_36))
    { /* block id: 637 */
        int32_t *l_834 = (void*)0;
        float *l_836 = (void*)0;
        float l_838 = (-0x3.Ap-1);
        float *l_837 = &l_838;
        int32_t l_839 = 0xBCEC7AB9;
        for (l_36 = 6; (l_36 != (-15)); --l_36)
        { /* block id: 640 */
            int32_t **l_835 = &l_834;
            (*l_835) = l_834;
        }
        (*l_837) = 0x7.561F57p-18;
        l_839 = l_36;
        return l_36;
    }
    else
    { /* block id: 646 */
        int32_t *l_842 = (void*)0;
        int32_t **l_841 = &l_842;
        int32_t ***l_840 = &l_841;
        float l_848 = 0x0.30D862p-25;
        float *l_847 = &l_848;
        l_843 = l_840;
        /* statement id: 647 */
        assert (l_843 == &l_841);
        (*l_847) = (*l_845);
    }
    /* facts after branching */
    //assert (l_843 == dangling);
    return l_849;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(uint32_t  p_35)
{ /* block id: 37 */
    int16_t l_37 = (-2);
    int32_t l_821 = 0x499C8A93;
    int32_t *l_829 = (void*)0;
    int32_t **l_828 = &l_829;
    float l_831 = 0x8.EEE596p-67;
    float *l_830 = &l_831;
    if (l_37)
    { /* block id: 38 */
        const uint32_t l_52 = 0U;
        int32_t l_812 = 1;
        int32_t *l_811 = &l_812;
        int32_t **l_824 = (void*)0;
        int32_t **l_825 = &l_811;
        (*l_811) = (((((int16_t)p_35 % (int16_t)((uint32_t)l_37 % (uint32_t)func_42(((int32_t)(((0xE3BF && l_37) > __builtin_ctzl(((uint16_t)p_35 - (uint16_t)((int16_t)1 + (int16_t)0x8AF9)))) & ((p_35 < p_35) && 5U)) - (int32_t)l_37), l_52, p_35))) | 0x146F) <= 65535U) <= l_37);
        for (p_35 = 0; (p_35 == 49); p_35 += 1)
        { /* block id: 608 */
            const int32_t **l_815 = (void*)0;
            int32_t **l_816 = &l_811;
            (*l_816) = &l_812;
            (**l_816) = l_37;
            (*l_811) = (**l_816);
            if (p_35)
            { /* block id: 612 */
                int32_t *l_819 = &l_812;
                float **l_823 = (void*)0;
                float ***l_822 = &l_823;
                if ((0x6A5B > ((p_35 >= (-(uint32_t)p_35)) > 0xB6C8AE22)))
                { /* block id: 613 */
                    int32_t l_818 = 0xF5A4A6A1;
                    return l_818;
                }
                else
                { /* block id: 615 */
                    int32_t *l_820 = &l_812;
                    (*l_811) = (p_35 || (p_35 == 0xDFB355A3));
                    l_820 = l_819;
                    l_821 = (-0x1.9p+1);
                }
                (**l_816) = (p_35 && (l_821 == ((((void*)0 != l_822) >= (((*l_822) != (*l_822)) ^ __builtin_clzl(p_35))) == func_97(p_35))));
            }
            else
            { /* block id: 621 */
                l_811 = &l_812;
                (*l_816) = &l_812;
                (*l_816) = (*l_816);
                (*l_811) = 0x5703AD89;
            }
        }
        l_821 = (*l_811);
        (*l_825) = &l_812;
    }
    else
    { /* block id: 630 */
        int32_t *l_827 = &l_821;
        int32_t **l_826 = &l_827;
        (*l_826) = &l_821;
        (*l_826) = (void*)0;
        /* statement id: 632 */
        assert (l_827 == 0);
    }
    (*l_828) = &l_821;
    /* statement id: 634 */
    assert (l_829 == &l_821);
    (*l_830) = ((*l_829) < ((**l_828) != (**l_828)));
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_42(uint32_t  p_43, const uint16_t  p_44, uint32_t  p_45)
{ /* block id: 39 */
    const uint32_t l_58 = 2U;
    float l_750 = 0xF.9078D1p+85;
    float *l_749 = &l_750;
    int32_t l_752 = 0x005D3B29;
    float *** const *l_765 = (void*)0;
    int32_t *l_807 = &l_752;
    int32_t ** const l_806 = &l_807;
    (*l_749) = ((((func_53(l_58, (((func_59(p_45, l_58, l_58, l_58) >= (l_58 & l_58)) <= ((uint32_t)(-(uint16_t)0x5A53) + (uint32_t)0)) >= p_45), p_45, l_58) >= 0xC.CF99CCp-10) > l_58) < l_58) >= p_44);
    if (l_58)
    { /* block id: 536 */
        float l_751 = 0x0.4p+1;
        int32_t l_753 = 0;
        int32_t *l_786 = &l_752;
        float **l_795 = &l_749;
        float ***l_794 = &l_795;
        int32_t *l_797 = &l_753;
lbl_798:
        if ((__builtin_ctz(((((__builtin_ffs(l_752) == l_753) >= 0x0F128CD0) == (__builtin_ffsll(p_44) & 65532U)) ^ l_752)) <= p_45))
        { /* block id: 537 */
            uint32_t l_757 = 9U;
            float ****l_767 = (void*)0;
            float *****l_766 = &l_767;
            int32_t l_792 = 0;
            for (p_43 = 0; (p_43 < 23); ++p_43)
            { /* block id: 540 */
                int32_t *l_756 = &l_752;
                if (p_43)
                    break;
                (*l_756) = p_44;
            }
            if (l_752)
                goto lbl_760;
            if ((((((p_44 != func_80((func_72(l_58, p_43, l_757, l_753) | ((int16_t)__builtin_ctz(p_44) + (int16_t)l_757)), l_752, l_753)) != l_58) >= l_757) <= 0) || l_752))
            { /* block id: 544 */
lbl_760:
                l_752 = l_753;
                (*l_749) = func_59(l_753, p_43, l_753, p_43);
            }
            else
            { /* block id: 548 */
                int32_t *l_761 = &l_752;
                int32_t **l_762 = &l_761;
                (*l_762) = l_761;
                if (l_753)
                { /* block id: 550 */
                    for (l_757 = (-29); (l_757 > 42); l_757 += 5)
                    { /* block id: 553 */
                        (*l_762) = &l_753;
                        /* statement id: 554 */
                        assert (l_761 == &l_753);
                    }
                    /* facts after for loop */
                    assert (l_761 == &l_753 || l_761 == &l_752);
                }
                else
                { /* block id: 556 */
                    return l_752;
                }
                /* facts after branching */
                assert (l_761 == &l_753 || l_761 == &l_752);
            }
            (*l_766) = l_765;
            if (((int16_t)l_753 * (int16_t)((4294967294U == l_58) == func_80(l_753, ((int32_t)((int32_t)((!7U) || (((p_44 < func_80(p_43, func_59(l_757, p_45, l_753, p_44), p_45)) != l_58) >= p_44)) % (int32_t)p_43) % (int32_t)p_45), l_757))))
            { /* block id: 561 */
                (*l_749) = ((float)p_43 - (float)p_43);
            }
            else
            { /* block id: 563 */
                float *l_791 = &l_751;
                int32_t l_793 = 0xC05A2A09;
                for (p_43 = 0; (p_43 == 23); p_43 += 5)
                { /* block id: 566 */
                    float **l_783 = (void*)0;
                    int32_t l_784 = (-1);
                    int32_t **l_785 = (void*)0;
                    for (p_45 = (-25); (p_45 == 17); ++p_45)
                    { /* block id: 569 */
                        (*l_766) = (*l_766);
                    }
                    l_784 = ((uint32_t)(l_783 != (void*)0) % (uint32_t)l_58);
                    l_786 = &l_784;
                    /* statement id: 573 */
                    assert (l_786 == &l_784);
                }
                l_792 = ((int16_t)(l_757 ^ (0U < func_97(__builtin_ctzll(p_43)))) << (int16_t)__builtin_ffsll(((uint16_t)(l_791 != l_791) + (uint16_t)p_44)));
                l_753 = (l_793 != l_752);
            }
        }
        else
        { /* block id: 578 */
            float ****l_796 = &l_794;
            (*l_796) = l_794;
        }
        (*l_797) = (&l_786 == &l_786);
        if (l_753)
            goto lbl_798;
        return l_58;
    }
    else
    { /* block id: 584 */
        int32_t *l_799 = (void*)0;
        int32_t *l_800 = &l_752;
        int32_t **l_801 = &l_799;
        (*l_800) = ((void*)0 == &l_765);
        (*l_801) = l_800;
        /* statement id: 586 */
        assert (l_799 == &l_752);
        for (p_45 = 15; (p_45 <= 7); p_45--)
        { /* block id: 589 */
            for (l_752 = 21; (l_752 == (-20)); l_752 -= 8)
            { /* block id: 592 */
                return p_43;
            }
        }
        (*l_801) = &l_752;
    }
    (**l_806) = func_80(l_752, __builtin_ffsl(func_59(p_45, ((void*)0 == l_806), p_43, (**l_806))), (**l_806));
    for (l_752 = (-13); (l_752 != (-8)); l_752++)
    { /* block id: 601 */
        int32_t *l_810 = (void*)0;
        (*l_806) = l_810;
        /* statement id: 602 */
        assert (l_807 == 0);
    }
    /* facts after for loop */
    assert (l_807 == 0 || l_807 == &l_752);
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_53(const int32_t  p_54, uint32_t  p_55, int32_t  p_56, int32_t  p_57)
{ /* block id: 401 */
    int32_t l_595 = (-9);
    uint32_t l_596 = 0x8AA51B17;
    int32_t * const *l_600 = (void*)0;
    int32_t * const **l_599 = &l_600;
    int32_t ***l_627 = (void*)0;
    float l_695 = (-0x3.4p-1);
    const float *l_694 = &l_695;
    int32_t ****l_733 = &l_627;
    int32_t *****l_732 = &l_733;
    int32_t l_743 = 0x4CF2802B;
    int32_t *l_742 = &l_743;
    int32_t **l_748 = &l_742;
lbl_705:
    for (p_57 = (-24); (p_57 != 19); ++p_57)
    { /* block id: 404 */
        int32_t l_592 = 4;
        int32_t *l_603 = (void*)0;
        int32_t **l_602 = &l_603;
        int32_t ***l_601 = &l_602;
        int32_t ** const *l_614 = &l_602;
        int32_t ** const **l_613 = &l_614;
        int32_t ** const *** const l_612 = &l_613;
        int16_t l_621 = 0x0F00;
        float l_641 = 0x8.9E8C3Ep-97;
        float ** const ***l_676 = (void*)0;
        int32_t * const ** const l_677 = &l_600;
        if ((((7 || (((func_87(((int16_t)((int16_t)__builtin_bswap64(((uint16_t)((p_56 & l_592) | p_54) - (uint16_t)l_592)) + (int16_t)(p_55 != ((int16_t)(p_54 || p_56) % (int16_t)p_54))) - (int16_t)l_592), p_55, l_595, l_596) & p_54) && p_57) | p_57)) ^ l_592) < 65528U))
        { /* block id: 405 */
            int32_t l_606 = 0x844435A6;
            float l_616 = 0x9.E4AA5Ap+40;
            float *l_615 = &l_616;
            (*l_615) = ((float)((l_599 == l_601) >= (p_54 == ((float)l_606 + (float)((+(p_57 < l_606)) < (l_606 == ((((float)((float)(l_612 == (void*)0) + (float)0x7.C47D87p+86) - (float)0x0.F9E2C3p-86) > p_56) > (-0x9.6p-1))))))) - (float)0x0.B27B7Ep-84);
        }
        else
        { /* block id: 407 */
            float l_617 = (-0x1.Ep-1);
            int32_t l_622 = 0x187401E0;
            float *l_623 = (void*)0;
            float *l_624 = &l_617;
            (*l_624) = (func_72(__builtin_popcount((0U & ((p_57 <= ((uint16_t)65535U >> (uint16_t)((~(3U && (p_57 >= l_621))) == p_56))) & 0xAA8F))), l_622, p_54, l_622) >= 0x6.Fp-1);
            if (p_56)
                continue;
            (***l_613) = &p_56;
            /* statement id: 410 */
            assert (l_603 == &p_56);
            for (l_592 = 9; (l_592 < (-22)); --l_592)
            { /* block id: 413 */
                (*l_602) = &p_56;
            }
        }
        /* facts after branching */
        assert (l_603 == &p_56 || l_603 == 0);
        (****l_612) = (****l_612);
        if (p_56)
        { /* block id: 418 */
            uint16_t l_628 = 65532U;
            float l_630 = 0x8.C9425Cp+53;
            float *l_629 = &l_630;
            (*l_629) = (p_57 <= ((l_627 != &l_600) >= l_628));
            for (l_621 = 0; (l_621 < 23); l_621 += 1)
            { /* block id: 422 */
                uint16_t l_639 = 0x593B;
                (*l_629) = ((((((-0x10.Dp+1) != 0x5.C87E3Bp-95) > func_72(((((uint32_t)((uint16_t)l_628 >> (uint16_t)13) % (uint32_t)p_54) & ((uint16_t)((l_639 <= func_72((l_628 && (__builtin_ffsl(p_54) && (+(5U > 0)))), l_639, l_639, p_55)) > 65535U) << (uint16_t)p_57)) > l_639), p_57, l_639, l_628)) != l_628) < 0xA.EA2E80p+37) < 0xB.E2BB9Ep+33);
                if (l_595)
                    goto lbl_709;
            }
            (*l_602) = &p_56;
            /* statement id: 425 */
            assert (l_603 == &p_56);
            (*l_629) = p_54;
        }
        else
        { /* block id: 427 */
            float l_645 = (-0x4.Dp-1);
            float **l_650 = (void*)0;
            float ***l_649 = &l_650;
            float ****l_648 = &l_649;
            int32_t l_654 = 1;
            int32_t l_660 = (-8);
            int32_t *l_663 = &l_654;
            int32_t ** const *l_666 = &l_602;
            float *l_698 = &l_695;
            uint32_t l_699 = 5U;
            if (p_57)
            { /* block id: 428 */
                float *l_646 = &l_641;
                float **l_647 = &l_646;
                (*l_646) = ((float)p_54 + (float)(-(float)l_645));
                l_647 = &l_646;
                (**l_647) = 0x0.Ap-1;
                if (p_55)
                    continue;
            }
            else
            { /* block id: 433 */
                float ****l_651 = &l_649;
                int32_t l_657 = 0x446FEBEE;
                l_651 = l_648;
                for (p_55 = (-17); (p_55 != (-1)); p_55 += 4)
                { /* block id: 437 */
                    return p_56;
                }
                if (((((func_80(l_654, p_57, p_54) < p_54) >= ((uint32_t)l_657 - (uint32_t)((uint16_t)l_660 - (uint16_t)0x72E6))) < ((int16_t)l_657 >> (int16_t)1)) || p_57))
                { /* block id: 440 */
                    const uint32_t l_667 = 0x1C9458B4;
                    float ***** const l_675 = &l_651;
                    l_663 = &l_654;
                    (**l_614) = &p_56;
                    /* statement id: 442 */
                    assert (l_603 == &p_56);
                    for (l_621 = (-9); (l_621 != (-21)); --l_621)
                    { /* block id: 445 */
                        (**l_601) = &p_56;
                        (**l_612) = l_666;
                        return p_55;
                    }
                    if ((l_667 == p_57))
                    { /* block id: 450 */
                        int16_t l_668 = 7;
                        return l_668;
                    }
                    else
                    { /* block id: 452 */
                        uint32_t l_680 = 9U;
                        l_657 = ((float)l_657 - (float)(**l_602));
                        if (l_596)
                            goto lbl_709;
                        l_680 = (((float)((float)0x0.9p+1 - (float)(l_675 != l_676)) - (float)(l_677 != l_666)) < ((float)(-0x1.5p+1) - (float)p_57));
                        (****l_612) = &p_56;
                        return p_56;
                    }
                }
                else
                { /* block id: 458 */
                    uint32_t l_683 = 0x88534745;
                    (*l_663) = ((uint16_t)l_657 << (uint16_t)p_54);
                    (*l_663) = l_683;
                }
                if (l_592)
                    goto lbl_705;
                (*l_663) = ((uint16_t)p_54 + (uint16_t)p_57);
            }
            for (l_660 = (-29); (l_660 >= 16); ++l_660)
            { /* block id: 466 */
                float *l_688 = &l_641;
                int32_t l_689 = (-1);
                (*l_688) = p_54;
                if (l_689)
                    continue;
                (***l_613) = &p_56;
                /* statement id: 469 */
                assert (l_603 == &p_56);
                if ((((uint16_t)(((uint32_t)func_80(l_689, ((void*)0 != l_694), p_57) - (uint32_t)(((uint16_t)l_689 << (uint16_t)l_689) ^ 0xAC60)) != (l_698 == (void*)0)) << (uint16_t)l_699) <= 4))
                { /* block id: 470 */
                    (**l_614) = &p_56;
                }
                else
                { /* block id: 472 */
                    int32_t *l_702 = &l_689;
                    for (l_592 = 0; (l_592 <= (-25)); l_592--)
                    { /* block id: 475 */
                        (****l_612) = l_702;
                        /* statement id: 476 */
                        assert (l_603 == &l_689);
                        if (p_55)
                            break;
                    }
                    /* facts after for loop */
                    assert (l_603 == &l_689 || l_603 == &p_56);
                    (****l_612) = &p_56;
                    /* statement id: 479 */
                    assert (l_603 == &p_56);
                    for (p_55 = 3; (p_55 > 39); p_55 += 8)
                    { /* block id: 482 */
                        return p_54;
                    }
                    (*l_702) = p_57;
                }
            }
        }
    }
lbl_709:
    for (p_57 = 0; (p_57 <= 23); p_57 += 7)
    { /* block id: 493 */
        int32_t l_708 = (-4);
        return l_708;
    }
    for (p_57 = (-5); (p_57 > 29); p_57 += 7)
    { /* block id: 500 */
        uint32_t l_712 = 8U;
        int32_t *****l_727 = (void*)0;
        int32_t l_740 = (-1);
        int32_t *l_739 = &l_740;
        int32_t **l_744 = &l_739;
        int32_t l_747 = (-1);
        if (l_712)
        { /* block id: 501 */
            int32_t ****l_729 = (void*)0;
            int32_t *****l_728 = &l_729;
            int32_t **l_741 = (void*)0;
            for (l_595 = 0; (l_595 <= (-12)); l_595 -= 1)
            { /* block id: 504 */
                int32_t l_717 = 0xD3EA2A0F;
                int32_t *l_721 = &l_717;
                int32_t **l_720 = &l_721;
                int32_t *** const l_719 = &l_720;
                for (p_56 = 0; (p_56 <= 6); p_56 += 3)
                { /* block id: 507 */
                    int32_t l_718 = 0xFB136066;
                    float *l_738 = &l_695;
                    float **l_737 = &l_738;
                    l_717 = (__builtin_clzll(l_712) | 6U);
                    if (l_718)
                        continue;
                    if (((void*)0 != l_719))
                    { /* block id: 510 */
                        int32_t l_723 = 0xC54849CF;
                        float *l_724 = (void*)0;
                        float *l_725 = (void*)0;
                        float *l_726 = &l_695;
                        (*l_726) = (+l_723);
                        l_728 = l_727;
                        /* statement id: 512 */
                        assert (l_728 == 0);
                    }
                    else
                    { /* block id: 513 */
                        uint16_t l_736 = 0x1313;
                        (**l_719) = (void*)0;
                        /* statement id: 514 */
                        assert (l_721 == 0);
                        l_736 = (p_54 > ((__builtin_popcountl(p_56) & ((int16_t)((p_54 || (8 & ((((l_732 != (void*)0) == ((uint16_t)p_54 % (uint16_t)(-3))) ^ p_56) != p_55))) == p_56) >> (int16_t)3)) & p_54));
                        (*l_738) = ((l_737 != (void*)0) >= l_718);
                    }
                    l_727 = l_727;
                }
                /* facts after for loop */
                assert (l_721 == 0 || l_721 == &l_717);
                if (l_596)
                    goto lbl_709;
                (**l_719) = (**l_719);
            }
            /* facts after for loop */
            assert (l_728 == &l_729 || l_728 == 0);
            l_739 = &p_56;
            /* statement id: 523 */
            assert (l_739 == &p_56);
            l_739 = (void*)0;
            /* statement id: 524 */
            assert (l_739 == 0);
            l_742 = &p_56;
            /* statement id: 525 */
            assert (l_742 == &p_56);
        }
        else
        { /* block id: 526 */
            (*l_739) = p_54;
        }
        /* facts after branching */
        assert (l_739 == &l_740 || l_739 == 0);
        (*l_744) = &p_56;
        /* statement id: 529 */
        assert (l_739 == &p_56);
        l_747 = ((uint32_t)4294967295U - (uint32_t)p_55);
        if (p_57)
            break;
    }
    (*l_748) = &p_56;
    /* statement id: 533 */
    assert (l_742 == &p_56);
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_59(uint32_t  p_60, float  p_61, int16_t  p_62, int32_t  p_63)
{ /* block id: 40 */
    uint32_t l_84 = 0x2EC28784;
    int32_t * const l_536 = (void*)0;
    float l_537 = 0x5.AAECDDp+79;
    float *l_576 = &l_537;
    int32_t l_580 = (-1);
    int32_t *l_579 = &l_580;
    for (p_62 = 0; (p_62 < (-7)); p_62 -= 1)
    { /* block id: 43 */
        float l_66 = (-0x9.6p-1);
        int32_t l_67 = (-6);
        return l_67;
    }
    (*l_576) = (((float)((((((((float)(((((__builtin_ffsl((func_72(((((+(((uint16_t)(func_80(p_63, l_84, p_60) <= __builtin_popcountll(p_60)) << (uint16_t)3) | p_63)) == (l_536 != l_536)) == 0xB0BA) | p_62), p_62, p_63, p_60) & 0xC92CF7FC)) == 0x2.3FC89Ep-12) != l_84) != l_84) > 0x0.0p+1) >= l_84) + (float)p_63) <= 0x1.46A3FAp+8) != (-0x1.Dp+1)) < p_60) == 0x0.Bp-1) != p_63) >= p_61) + (float)(-0x7.8p+1)) > p_63);
    (*l_579) = ((int16_t)(l_84 & 0x26B0) << (int16_t)1);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_72(int32_t  p_73, int32_t  p_74, float  p_75, uint16_t  p_76)
{ /* block id: 363 */
    uint32_t l_544 = 0x6D76F845;
    for (p_76 = 0; (p_76 < 15); p_76 += 9)
    { /* block id: 366 */
        int32_t l_541 = 6;
        int32_t *l_540 = &l_541;
        int32_t **l_542 = &l_540;
        (*l_542) = l_540;
        if ((*l_540))
            break;
        if ((~p_73))
        { /* block id: 369 */
            return l_544;
        }
        else
        { /* block id: 371 */
            int16_t l_546 = 0xA52A;
            float l_575 = 0xE.682529p+51;
            float *l_574 = &l_575;
            (*l_540) = (~(l_546 & ((uint32_t)0x1E390565 - (uint32_t)l_544)));
            if (p_73)
            { /* block id: 373 */
                float ****l_550 = (void*)0;
                float *****l_549 = &l_550;
                int32_t l_559 = 0x1358FC3C;
                uint32_t l_560 = 4294967295U;
                (*l_549) = (void*)0;
                (*l_540) = (((int16_t)l_544 - (int16_t)((int16_t)(l_546 | ((0xC547 < ((uint16_t)(__builtin_ctzll(p_74) > ((int32_t)l_546 - (int32_t)(l_544 < func_87((**l_542), p_74, l_559, l_544)))) >> (uint16_t)p_74)) >= l_560)) >> (int16_t)3)) == (-9));
            }
            else
            { /* block id: 376 */
                float *l_561 = (void*)0;
                float l_563 = 0x8.63A686p-21;
                float *l_562 = &l_563;
                (**l_542) = (*l_540);
                (*l_562) = 0x3.104E27p-26;
                if (p_73)
                { /* block id: 379 */
                    if (p_73)
                        break;
                }
                else
                { /* block id: 381 */
                    for (l_546 = (-22); (l_546 > (-26)); l_546 -= 8)
                    { /* block id: 384 */
                        float **l_568 = &l_561;
                        float ***l_567 = &l_568;
                        float **** const l_566 = &l_567;
                        float ****l_570 = (void*)0;
                        float *****l_569 = &l_570;
                        int32_t *l_571 = &l_541;
                        if (p_74)
                            break;
                        (*l_569) = l_566;
                        /* statement id: 386 */
                        assert (l_570 == &l_567);
                        l_571 = &p_73;
                        /* statement id: 387 */
                        assert (l_571 == &p_73);
                    }
                }
                return l_544;
            }
            (**l_542) = func_87(l_544, l_546, l_544, (((uint32_t)(0xD5AC11CB >= l_546) % (uint32_t)(1U && p_73)) != l_544));
            (*l_574) = 0x0.C5E52Ap-44;
        }
        if (p_76)
            continue;
    }
    return l_544;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_80(uint32_t  p_81, uint32_t  p_82, int16_t  p_83)
{ /* block id: 46 */
    int32_t l_109 = 1;
    int32_t **l_114 = (void*)0;
    int32_t l_116 = 0xF440AFAA;
    int32_t *l_115 = &l_116;
    int32_t *l_125 = &l_116;
    int32_t *l_208 = &l_116;
    uint16_t l_290 = 0xBBFA;
    float *l_341 = (void*)0;
    float **l_340 = &l_341;
    float ***l_351 = &l_340;
    float ****l_350 = &l_351;
    int32_t * const * const **l_430 = (void*)0;
    int32_t * const * const ***l_429 = &l_430;
    int32_t * const *l_519 = &l_115;
    for (p_82 = 0; (p_82 <= 53); ++p_82)
    { /* block id: 49 */
        int32_t l_99 = 0;
        uint32_t l_100 = 0x178915D4;
        uint32_t l_106 = 0xBD03168F;
        int16_t l_113 = 0xEA4F;
        l_113 = (((func_87(p_82, (((-0x1.Cp+1) != (((float)func_94(func_97(l_99), l_100) - (float)((float)0x1.8p+1 - (float)l_106)) != ((float)(-0x6.Bp+1) + (float)l_99))) != p_81), l_106, l_109) <= l_106) < 5U) >= 1);
        if (l_106)
            break;
    }
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_87(uint16_t  p_88, float  p_89, uint16_t  p_90, uint16_t  p_91)
{ /* block id: 55 */
    int16_t l_110 = 0x6867;
    int32_t l_112 = 0x1C16B31B;
    int32_t *l_111 = &l_112;
    (*l_111) = (l_110 == p_88);
    return p_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_94(int32_t  p_95, uint16_t  p_96)
{ /* block id: 52 */
    int32_t l_102 = 0x15B7D07A;
    int32_t *l_101 = &l_102;
    int32_t **l_103 = &l_101;
    (*l_103) = l_101;
    return p_96;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_97(int32_t  p_98)
{ /* block id: 50 */
    return p_98;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 217
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 223
   depth: 2, occurrence: 38
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 2
   depth: 25, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 210

XXX times a variable address is taken: 217
XXX times a pointer is dereferenced on RHS: 115
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 35
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 165
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 30
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 23
XXX times a pointer is qualified to be dereferenced: 636

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 258
   level: 2, occurrence: 87
   level: 3, occurrence: 58
   level: 4, occurrence: 32
   level: 5, occurrence: 17
XXX number of pointers point to pointers: 123
XXX number of pointers point to scalars: 87
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.1
XXX average alias set size: 1.21

XXX times a non-volatile is read: 993
XXX times a non-volatile is write: 457
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 4
XXX backward jumps: 9

XXX stmts: 189
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 36
   depth: 2, occurrence: 33
   depth: 3, occurrence: 42
   depth: 4, occurrence: 27
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 20
XXX percentage an existing variable is used: 80
********************* end of statistics **********************/

