/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      1178727552
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   float  f0;
   uint32_t  f1;
   int8_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int8_t g_2 = 0xBE;
static int32_t g_5 = 0xAAEB9AE7;
static int32_t *g_4 = &g_5;
static struct S0 g_25 = {0x2.4FF545p+1,4294967295U,0xB1};
static struct S0 g_141 = {-0x4.8p-1,5U,-1};
static volatile int32_t ****g_160 = (void*)0;
static int32_t ***g_168 = (void*)0;
static volatile struct S0 g_177 = {0x5.AA6773p+58,1U,1};/* VOLATILE GLOBAL g_177 */
static volatile struct S0 *g_176 = &g_177;
static volatile struct S0 **g_175 = &g_176;
static struct S0 *g_246 = &g_25;
static struct S0 **g_245 = &g_246;
static struct S0 ***g_244 = &g_245;
static float g_254 = 0x4.4p-1;
static int32_t g_310 = 1;
static int32_t ****g_357 = &g_168;
static int32_t *****g_356 = &g_357;
static const int32_t *g_411 = &g_5;
static float *g_459 = &g_25.f0;
static float **g_458 = &g_459;
static float ***g_457 = &g_458;
static float ****g_456 = &g_457;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static uint16_t  func_14(int32_t  p_15, int32_t * p_16, const int32_t ** p_17, uint32_t  p_18, int16_t  p_19);
static uint16_t  func_20(struct S0  p_21, int8_t  p_22, float  p_23, int32_t ** p_24);
inline static struct S0  func_31(const int16_t  p_32, struct S0  p_33, int32_t * p_34);
static struct S0  func_37(const int32_t  p_38);
inline static struct S0  func_43(const int32_t  p_44);
static uint32_t  func_46(struct S0 * p_47, int32_t * p_48, uint32_t  p_49);
inline static struct S0 * func_50(int8_t  p_51, struct S0 * p_52, const float  p_53, struct S0  p_54);
inline static struct S0  func_56(struct S0  p_57, const struct S0  p_58, float  p_59);
static float  func_61(int32_t ** p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_4 g_25 g_245 g_246 g_175 g_176 g_177 g_310
 * writes: g_4 g_5 g_25.f1 g_411
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_3 = 0x4B4E1265;
    int32_t **l_6 = &g_4;
    float l_470 = 0x0.1p-1;
    if (g_2)
    { /* block id: 1 */
        return l_3;
    }
    else
    { /* block id: 3 */
        int8_t l_9 = 0x8A;
        int32_t *l_472 = &g_5;
        g_4 = g_4;
        l_6 = (void*)0;
        /* statement id: 5 */
        assert (l_6 == 0);
        (*l_472) = ((((int32_t)l_9 - (int32_t)((uint32_t)(((int16_t)g_2 * (int16_t)g_2) ^ g_2) - (uint32_t)g_2)) >= (func_14((0x0F4F == func_20(g_25, g_2, ((float)g_25.f2 - (float)l_9), l_6)), &g_310, &g_411, l_9, g_310) < g_2)) ^ 65528U);
        /* statement id: 284 */
        assert (g_4 == &g_310 || g_4 == &g_5);
    }
    /* facts after branching */
    assert (g_4 == &g_310 || g_4 == &g_5);
    assert (l_6 == 0);
    return g_177.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_411
 */
static uint16_t  func_14(int32_t  p_15, int32_t * p_16, const int32_t ** p_17, uint32_t  p_18, int16_t  p_19)
{ /* block id: 281 */
    int32_t *l_471 = &g_5;
    (*p_17) = l_471;
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_25.f1 g_245 g_246 g_25 g_175 g_176 g_177
 * writes: g_5 g_4 g_25.f1
 */
static uint16_t  func_20(struct S0  p_21, int8_t  p_22, float  p_23, int32_t ** p_24)
{ /* block id: 6 */
    int8_t l_28 = 1;
    int32_t **l_29 = &g_4;
    int32_t *l_465 = &g_310;
    struct S0 l_469 = {0xB.5C97A0p-76,4294967295U,-1};
    (*g_4) = (p_21.f1 && 0x7440);
    if (p_21.f1)
        goto lbl_30;
    (*g_4) = (l_28 > l_28);
lbl_30:
    (*l_29) = (void*)0;
    /* statement id: 9 */
    assert (g_4 == 0);
    l_469 = func_31(((uint16_t)65533U << (uint16_t)8), func_37(p_22), l_465);
    /* statement id: 279 */
    assert (g_4 == &g_310 || g_4 == &g_5);
    return p_21.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_175 g_176 g_177
 * writes: g_4
 */
inline static struct S0  func_31(const int16_t  p_32, struct S0  p_33, int32_t * p_34)
{ /* block id: 272 */
    for (p_33.f2 = (-7); (p_33.f2 != 27); ++p_33.f2)
    { /* block id: 275 */
        int32_t **l_468 = &g_4;
        (*l_468) = p_34;
        /* statement id: 276 */
        assert (g_4 == &g_310);
    }
    /* facts after for loop */
    assert (g_4 == &g_310 || g_4 == &g_5);
    return (**g_175);
}


/* ------------------------------------------ */
/* 
 * reads : g_25.f1 g_4 g_245 g_246 g_25
 * writes: g_4 g_25.f1 g_5
 */
static struct S0  func_37(const int32_t  p_38)
{ /* block id: 11 */
    struct S0 l_39 = {-0x8.0p+1,0U,-1};
    struct S0 *l_40 = &l_39;
    int32_t **l_464 = &g_4;
    int32_t ***l_463 = &l_464;
    g_4 = &g_5;
    /* statement id: 12 */
    assert (g_4 == &g_5);
    (*l_40) = l_39;
    for (g_25.f1 = 0; (g_25.f1 >= 2); ++g_25.f1)
    { /* block id: 16 */
        const struct S0 l_462 = {0x1.F2F872p-5,0x0BE3B217,0x93};
    }
    (*g_4) = (l_463 == (void*)0);
    return (**g_245);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_25 g_4 g_5 g_141.f2 g_160 g_177.f2 g_177.f0 g_141.f1 g_175 g_176 g_177 g_246 g_254 g_245 g_310 g_141 g_357 g_168 g_459
 * writes: g_5 g_4 g_141 g_25.f2 g_25.f0 g_177 g_244 g_310 g_356
 */
inline static struct S0  func_43(const int32_t  p_44)
{ /* block id: 17 */
    int16_t l_45 = 0x54C5;
    struct S0 l_60 = {-0x3.Bp+1,0xCA181885,5};
    int32_t *l_309 = &g_310;
    int32_t *l_389 = &g_5;
    const int32_t *l_394 = &g_5;
    int8_t l_398 = 0x37;
    float l_408 = 0x6.3EAC5Fp+26;
    float **l_461 = (void*)0;
    if ((l_45 & (g_2 & p_44)))
    { /* block id: 18 */
        struct S0 *l_55 = &g_25;
        int32_t **l_63 = &g_4;
        int32_t l_364 = 0xF3C2C29D;
        (*l_309) = (((func_46(func_50(l_45, &g_25, (l_55 == (void*)0), func_56(l_60, g_25, func_61(l_63))), l_309, (*l_309)) || (*l_309)) | p_44) || l_364);
        /* statement id: 198 */
        //assert (g_4 == dangling || g_4 == &g_5);
        //assert (g_244 == &g_245 || g_244 == dangling);
    }
    else
    { /* block id: 199 */
        int8_t l_375 = (-8);
        int32_t ****l_393 = &g_168;
        struct S0 ****l_406 = &g_244;
        float *l_447 = &g_25.f0;
        for (l_60.f2 = (-17); (l_60.f2 < (-18)); --l_60.f2)
        { /* block id: 202 */
            int32_t l_367 = 1;
            int32_t ***l_372 = (void*)0;
            (*l_309) = ((g_25.f1 && ((p_44 || 0x309D0D32) && l_367)) > ((uint16_t)((uint16_t)(l_367 ^ ((void*)0 == &g_244)) + (uint16_t)((*g_357) != l_372)) * (uint16_t)65535U));
        }
    }
    /* facts after branching */
    //assert (g_4 == dangling || g_4 == &g_5);
    //assert (g_244 == &g_245 || g_244 == dangling);
    (*g_459) = ((void*)0 != l_461);
    l_394 = &p_44;
    /* statement id: 264 */
    assert (l_394 == &p_44);
    return (*g_246);
}


/* ------------------------------------------ */
/* 
 * reads : g_310 g_177.f1 g_141.f1 g_25.f1 g_25 g_141 g_175 g_176 g_2 g_177.f2
 * writes: g_141.f1 g_310 g_177 g_356
 */
static uint32_t  func_46(struct S0 * p_47, int32_t * p_48, uint32_t  p_49)
{ /* block id: 161 */
    int32_t *l_311 = (void*)0;
    int32_t **l_312 = &l_311;
    int32_t ***l_318 = &l_312;
    const struct S0 l_325 = {0x9.Ap+1,8U,0xC6};
    int16_t l_358 = (-5);
    struct S0 ****l_361 = &g_244;
    struct S0 *l_362 = &g_25;
    int32_t *****l_363 = &g_357;
    (*l_312) = l_311;
    for (p_49 = 23; (p_49 >= 39); p_49 += 5)
    { /* block id: 165 */
        struct S0 ***l_321 = &g_245;
        int32_t l_326 = 1;
        int32_t l_339 = 0x4F5809B3;
        int32_t ****l_355 = (void*)0;
        int32_t *****l_354 = &l_355;
        for (g_141.f1 = 0; (g_141.f1 >= 15); ++g_141.f1)
        { /* block id: 168 */
            int32_t ***l_317 = &l_312;
            struct S0 ***l_322 = &g_245;
            if ((*p_48))
                break;
            if ((((l_317 == l_318) < g_177.f1) ^ (((int16_t)(g_141.f1 && (l_321 == l_322)) >> (int16_t)g_25.f1) & g_310)))
            { /* block id: 170 */
                const struct S0 l_328 = {0x1.Ap+1,4294967295U,0x0C};
                int32_t l_340 = 1;
                for (g_310 = 0; (g_310 >= (-4)); g_310 -= 7)
                { /* block id: 173 */
                    (**g_175) = (*p_47);
                    if ((*p_48))
                    { /* block id: 175 */
                        int32_t *l_327 = &g_310;
                        (*l_312) = l_327;
                        /* statement id: 176 */
                        assert (l_311 == &g_310);
                        (**g_175) = (*p_47);
                        l_340 = (((uint32_t)(((((uint16_t)((int16_t)((((int32_t)((void*)0 == &p_47) - (int32_t)((l_326 && g_177.f1) < ((uint16_t)g_25.f2 << (uint16_t)1))) || (*l_311)) <= ((((((0xDC29E298 >= (((4 ^ (((((g_141.f2 || g_25.f2) > 0xC0549B17) & 0U) && l_326) || l_326)) ^ (*l_327)) != (-5))) & l_328.f1) != p_49) && g_310) == g_25.f1) <= 0xD3AC702A)) - (int16_t)p_49) * (uint16_t)l_339) ^ (*l_327)) && g_141.f2) || 0xFDB65664) % (uint32_t)(-7)) <= (*l_327));
                    }
                    else
                    { /* block id: 179 */
                        (*l_312) = &g_310;
                        /* statement id: 180 */
                        assert (l_311 == &g_310);
                    }
                    /* facts after branching */
                    assert (l_311 == &g_310);
                    if ((*p_48))
                        continue;
                }
                (*p_48) = (((int16_t)p_49 << (int16_t)11) && ((uint16_t)0U >> (uint16_t)((0xB576518F && ((g_2 & ((int16_t)(((uint16_t)g_177.f2 >> (uint16_t)(+((int16_t)((*p_48) && (l_354 != &l_355)) * (int16_t)((&g_175 == &g_175) >= 2U)))) ^ p_49) << (int16_t)10)) > (*p_48))) & 0x5ED5C099)));
                (**l_318) = &g_5;
                /* statement id: 185 */
                assert (l_311 == &g_5);
            }
            else
            { /* block id: 186 */
                if ((*p_48))
                    break;
                g_356 = &l_355;
                /* statement id: 188 */
                assert (g_356 == &l_355);
            }
            if (l_358)
                continue;
        }
        /* facts after for loop */
        assert (l_311 == 0 || l_311 == &g_5 || l_311 == &g_310);
        //assert (g_356 == &l_355 || g_356 == &g_357 || g_356 == dangling);
        (*l_312) = p_48;
        /* statement id: 192 */
        assert (l_311 == &g_310);
        if ((**l_312))
            continue;
        //assert (g_356 == &g_357 || g_356 == dangling);
    }
    /* facts after for loop */
    assert (l_311 == &g_310 || l_311 == 0);
    //assert (g_356 == dangling || g_356 == &g_357);
    (**g_175) = (*p_47);
    g_356 = l_363;
    /* statement id: 196 */
    assert (g_356 == &g_357);
    return g_25.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_5 g_25 g_2 g_141.f2 g_160 g_177.f2 g_177.f0 g_141.f1 g_175 g_176 g_177 g_246 g_254 g_245
 * writes: g_5 g_141 g_25.f2 g_4 g_25.f0 g_177 g_244
 */
inline static struct S0 * func_50(int8_t  p_51, struct S0 * p_52, const float  p_53, struct S0  p_54)
{ /* block id: 83 */
    int32_t l_140 = 0x3A361754;
    int32_t ***l_169 = (void*)0;
    struct S0 *l_195 = (void*)0;
    uint16_t l_223 = 0xCAA0;
    struct S0 **l_232 = &l_195;
    struct S0 ***l_231 = &l_232;
    int32_t l_233 = 0x913FAE4B;
    float *l_234 = &g_141.f0;
    volatile int32_t *****l_249 = &g_160;
    int32_t l_269 = 0x624ADBFC;
    if ((*g_4))
    { /* block id: 84 */
        int32_t l_139 = 0x57241C05;
        int32_t **l_163 = &g_4;
        int32_t ***l_162 = &l_163;
        int32_t ****l_161 = &l_162;
        int32_t l_183 = 0xA14961C1;
        g_141 = func_56(g_25, func_56(func_56(g_25, (*p_52), (((float)g_5 + (float)((l_139 < l_139) < (g_25.f0 <= p_54.f0))) <= ((g_25.f0 >= 0x0.Dp+1) <= p_54.f0))), (*p_52), g_25.f2), l_140);
        (*g_4) = ((uint32_t)(1U < ((uint16_t)p_51 * (uint16_t)(-10))) - (uint32_t)(*g_4));
        (**l_163) = (((uint16_t)(((int16_t)((uint16_t)(((p_54.f1 ^ ((((l_139 & (((int32_t)(-7) + (int32_t)(((int16_t)((*g_4) != (-1)) >> (int16_t)1) != ((l_140 || ((uint16_t)(g_141.f2 >= (g_160 != l_161)) >> (uint16_t)8)) ^ 1U))) != p_54.f1)) || p_51) || (***l_162)) == p_54.f2)) < (***l_162)) & 3U) + (uint16_t)1U) * (int16_t)p_54.f1) && (-1)) * (uint16_t)(-8)) == p_54.f1);
        for (l_140 = 18; (l_140 != (-1)); l_140--)
        { /* block id: 90 */
            int32_t *l_181 = &l_140;
            struct S0 *l_185 = &g_141;
            struct S0 **l_184 = &l_185;
        }
    }
    else
    { /* block id: 117 */
        int8_t l_190 = 0xE4;
        int32_t l_204 = 1;
        struct S0 **l_220 = (void*)0;
        struct S0 ***l_219 = &l_220;
        int32_t *l_226 = &l_204;
        int32_t **l_227 = &g_4;
        for (p_54.f1 = (-7); (p_54.f1 != 36); ++p_54.f1)
        { /* block id: 120 */
            int16_t l_203 = 0x2AD0;
            struct S0 **l_218 = &l_195;
            struct S0 ***l_217 = &l_218;
            l_204 = ((uint16_t)(p_54.f1 & l_190) >> (uint16_t)(((uint16_t)(l_169 == l_169) >> (uint16_t)((((uint16_t)((&p_54 != l_195) != l_190) % (uint16_t)((uint32_t)p_54.f1 + (uint32_t)((uint16_t)((int16_t)(+((((l_190 & l_203) == p_54.f1) && l_190) && g_2)) << (int16_t)5) * (uint16_t)g_177.f2))) >= g_25.f1) || 0x0A0F2B41)) <= p_54.f2));
            for (g_25.f2 = 0; (g_25.f2 >= 7); g_25.f2++)
            { /* block id: 124 */
                uint32_t l_221 = 4294967294U;
                uint32_t l_222 = 1U;
                float *l_224 = &g_25.f0;
                int32_t **l_225 = &g_4;
                g_4 = &l_204;
                /* statement id: 125 */
                assert (g_4 == &l_204);
                (*l_224) = (((((float)0x0.Ep-1 + (float)0x2.5p+1) <= g_141.f2) != (((((float)g_177.f0 + (float)(((float)((float)(-0x1.Fp+1) - (float)(((float)(((l_217 == l_219) == (0x8.67B023p-51 >= l_221)) > l_222) + (float)0x3.A6E04Bp-87) > 0xE.2A7C57p-3)) * (float)p_51) > (-0x10.9p+1))) >= p_54.f1) < (-0x6.7p-1)) >= 0x7.8430C3p-84)) > l_223);
                (*l_225) = l_224;
                /* statement id: 127 */
                assert (g_4 == &g_25.f0);
            }
        }
        /* facts after for loop */
        assert (g_4 == &g_25.f0 || g_4 == &g_5);
        (*l_227) = l_226;
        /* statement id: 130 */
        assert (g_4 == &l_204);
        (*l_234) = ((((!(((float)((l_231 != &l_220) < (**l_227)) - (float)l_233) <= l_223)) > 0xD.61BCC1p+30) > ((0x1.Ep-1 > (l_234 != l_226)) >= (-0x3.Dp-1))) < g_141.f1);
    }
    /* facts after branching */
    //assert (g_4 == dangling || g_4 == &g_5);
    (*g_176) = (**g_175);
    if ((((uint16_t)p_54.f2 * (uint16_t)((void*)0 != l_234)) > (((int16_t)((g_141.f2 && 0x33F7) < ((&p_52 != (*l_231)) == (g_141.f1 | ((int16_t)(p_54.f2 & p_51) * (int16_t)g_25.f2)))) - (int16_t)g_2) & 4294967287U)))
    { /* block id: 134 */
        int32_t ****l_241 = &l_169;
        struct S0 ***l_242 = &l_232;
        int32_t l_306 = 2;
        if ((&g_168 != l_241))
        { /* block id: 135 */
            struct S0 ****l_243 = (void*)0;
            g_244 = l_242;
            /* statement id: 136 */
            assert (g_244 == &l_232);
        }
        else
        { /* block id: 137 */
            for (p_51 = 0; (p_51 == 28); p_51++)
            { /* block id: 140 */
                l_249 = &g_160;
            }
            (*g_176) = (*g_246);
        }
        /* facts after branching */
        assert (g_244 == &g_245 || g_244 == &l_232);
        if ((((((1U || ((((uint32_t)((uint16_t)(l_234 != l_234) * (uint16_t)0xB7D1) + (uint32_t)p_54.f1) | ((uint32_t)g_141.f1 + (uint32_t)((uint16_t)(((int16_t)((p_54.f2 == (((((uint32_t)(((uint32_t)((int32_t)((0x6AF2F86A || ((int16_t)(l_234 != (void*)0) * (int16_t)p_54.f2)) | g_25.f2) - (int32_t)p_51) - (uint32_t)l_269) != p_54.f2) + (uint32_t)0x978347AB) <= g_5) >= g_25.f1) | 0x0309)) == p_51) + (int16_t)p_54.f1) | p_54.f2) << (uint16_t)0))) && p_54.f1)) ^ p_54.f2) >= g_177.f1) & 0x3D034B4D) <= g_25.f1))
        { /* block id: 145 */
            int32_t *l_270 = &l_233;
            int32_t **l_271 = &l_270;
            struct S0 *l_272 = &g_141;
            (*l_271) = l_270;
            return l_272;
            /* statement id: 147 */
            //assert (g_244 == &g_245 || g_244 == dangling);
            //assert (func_50_rv == &g_141);
        }
        else
        { /* block id: 148 */
            struct S0 l_276 = {0x1.4p+1,0x1B67568F,-6};
            int32_t *l_292 = (void*)0;
            uint32_t l_305 = 0U;
            for (p_51 = (-15); (p_51 <= (-7)); ++p_51)
            { /* block id: 151 */
                struct S0 l_275 = {0x2.5F90CAp+20,0U,0};
                int32_t *l_291 = &l_140;
                l_276 = (*p_52);
                (*l_234) = (((float)l_276.f1 * (float)(((((float)((float)0x5.6D6B7Ap-24 + (float)(g_25.f2 >= ((float)0x7.E81591p-37 - (float)(((0x0.Bp-1 <= (((float)((float)(((float)((l_291 != l_292) > (((((float)((float)g_177.f2 - (float)((float)((float)((float)((float)(-0x8.9p-1) * (float)g_25.f1) - (float)0x7.25DDEDp-29) + (float)0xE.77DDB8p-23) * (float)0xA.79E957p-31)) - (float)(-0x1.Dp+1)) == 0x1.18B520p+79) <= 0x7.96D2B0p-93) < 0x0.7p-1)) - (float)l_305) != 0x1.Cp+1) - (float)g_5) - (float)g_141.f1) > l_306)) <= g_254) > g_25.f2)))) - (float)g_141.f2) != g_5) < p_51) > p_51)) <= g_25.f2);
            }
            return (*g_245);
            /* statement id: 155 */
            //assert (g_244 == &g_245 || g_244 == dangling);
            //assert (func_50_rv == &g_25);
        }
    }
    else
    { /* block id: 157 */
        int32_t *l_307 = &l_140;
        struct S0 *l_308 = &g_141;
        (*l_307) = 0xB9E1FED7;
        return l_308;
        /* statement id: 159 */
        //assert (func_50_rv == &g_141);
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_25.f2 g_4 g_5 g_25.f1 g_2
 * writes: g_5
 */
inline static struct S0  func_56(struct S0  p_57, const struct S0  p_58, float  p_59)
{ /* block id: 80 */
    int8_t l_123 = 1;
    struct S0 l_136 = {0x1.BB0F31p-35,1U,0xC2};
    (*g_4) = (~((l_123 || p_58.f1) < (((p_58.f1 != ((~l_123) ^ ((int16_t)(0x1637 >= ((uint32_t)(g_25.f2 < ((int16_t)((uint16_t)((l_123 < 0x043A1FAE) || (-(uint16_t)((int32_t)(*g_4) - (int32_t)0x605DBDBD))) << (uint16_t)g_25.f2) >> (int16_t)g_25.f1)) + (uint32_t)4294967286U)) - (int16_t)0x9F20))) < g_2) == 0xB6043366)));
    return l_136;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_5 g_25.f1 g_25.f2 g_2
 * writes: g_5 g_4
 */
static float  func_61(int32_t ** p_62)
{ /* block id: 19 */
    int32_t l_64 = 0xA37EAD94;
    int32_t **l_65 = &g_4;
    struct S0 l_82 = {0x4.16C3B1p-3,0x1E29AFBA,0};
    if ((*g_4))
    { /* block id: 20 */
        int32_t l_66 = 0xD6DF81F9;
        struct S0 *l_71 = &g_25;
        (**l_65) = ((l_64 || (((l_65 != &g_4) == l_66) & ((int32_t)((((int16_t)(l_71 == l_71) * (int16_t)((((uint32_t)(**l_65) + (uint32_t)g_25.f1) == (((((int16_t)((uint16_t)((int32_t)(**l_65) % (int32_t)l_66) - (uint16_t)0x36B4) - (int16_t)0x3846) > g_5) == g_25.f2) < 0xD594)) | 0x30862622)) != 0xE5B4) ^ (**p_62)) - (int32_t)(**l_65)))) & 0x21BD);
        for (g_5 = 25; (g_5 != 4); g_5 -= 7)
        { /* block id: 24 */
            struct S0 l_83 = {0x4.2p-1,4294967295U,0x99};
            l_83 = l_82;
        }
    }
    else
    { /* block id: 27 */
        float l_93 = 0xE.8392DDp+78;
        const int32_t l_96 = (-1);
        if (((**p_62) < 0xF0774A76))
        { /* block id: 28 */
            struct S0 *l_84 = &l_82;
            (*l_84) = l_82;
        }
        else
        { /* block id: 30 */
            float l_94 = 0xF.BA4D29p-41;
            const int32_t l_95 = 0x0225587B;
            g_4 = &g_5;
            if ((+3))
            { /* block id: 32 */
                (**p_62) = (&g_5 != (void*)0);
                (*p_62) = &g_5;
lbl_118:
                (**p_62) = 0x063A29C5;
            }
            else
            { /* block id: 36 */
                uint32_t l_119 = 4294967294U;
lbl_115:
                (**l_65) = ((uint32_t)((((int16_t)(((((uint16_t)(-(uint16_t)l_95) << (uint16_t)(l_96 || (((+(1U >= ((int16_t)l_95 << (int16_t)14))) || ((int32_t)(**p_62) + (int32_t)(!(&l_82 != &g_25)))) < (g_2 >= g_5)))) ^ 0xF3DEF630) > (**l_65)) && (**l_65)) % (int16_t)g_5) >= l_96) == 0x219839B2) + (uint32_t)g_25.f2);
                for (l_64 = 0; (l_64 < 27); l_64 += 5)
                { /* block id: 40 */
                    int32_t ***l_106 = &l_65;
                    int32_t ****l_105 = &l_106;
                    (*l_105) = &p_62;
                    /* statement id: 41 */
                    assert (l_106 == &p_62);
                }
                for (l_82.f1 = 2; (l_82.f1 < 6); ++l_82.f1)
                { /* block id: 45 */
                    for (l_82.f2 = 0; (l_82.f2 < (-23)); l_82.f2 -= 4)
                    { /* block id: 48 */
                        struct S0 *l_112 = &g_25;
                        struct S0 **l_111 = &l_112;
                        (*p_62) = (*l_65);
                        (*l_111) = &l_82;
                        /* statement id: 50 */
                        assert (l_112 == &l_82);
                        (*l_111) = &g_25;
                        /* statement id: 51 */
                        assert (l_112 == &g_25);
                    }
                    if ((*g_4))
                        continue;
                    for (l_64 = 2; (l_64 > 12); l_64 += 6)
                    { /* block id: 56 */
                        if (l_64)
                            goto lbl_115;
                    }
                }
                for (l_82.f1 = 0; (l_82.f1 <= 49); ++l_82.f1)
                { /* block id: 62 */
                    if (l_96)
                        goto lbl_118;
                    l_119 = l_95;
                    for (l_64 = 0; (l_64 < 20); l_64++)
                    { /* block id: 67 */
                        g_4 = (*l_65);
                        if ((**p_62))
                            continue;
                        if ((**p_62))
                            break;
                    }
                    (*l_65) = &g_5;
                }
            }
        }
        (*l_65) = (*l_65);
        g_4 = (*l_65);
    }
    return (**l_65);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc_bytes (&g_25.f0, sizeof(g_25.f0), "g_25.f0", print_hash_value);
    transparent_crc(g_25.f1, "g_25.f1", print_hash_value);
    transparent_crc(g_25.f2, "g_25.f2", print_hash_value);
    transparent_crc_bytes (&g_141.f0, sizeof(g_141.f0), "g_141.f0", print_hash_value);
    transparent_crc(g_141.f1, "g_141.f1", print_hash_value);
    transparent_crc(g_141.f2, "g_141.f2", print_hash_value);
    transparent_crc_bytes (&g_177.f0, sizeof(g_177.f0), "g_177.f0", print_hash_value);
    transparent_crc(g_177.f1, "g_177.f1", print_hash_value);
    transparent_crc(g_177.f2, "g_177.f2", print_hash_value);
    transparent_crc_bytes (&g_254, sizeof(g_254), "g_254", print_hash_value);
    transparent_crc(g_310, "g_310", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 100
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 25
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2

XXX total number of pointers: 109

XXX times a variable address is taken: 136
XXX times a pointer is dereferenced on RHS: 69
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 17
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 70
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 300

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 168
   level: 2, occurrence: 53
   level: 3, occurrence: 24
   level: 4, occurrence: 17
   level: 5, occurrence: 9
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 31
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 19.3
XXX average alias set size: 1.28

XXX times a non-volatile is read: 475
XXX times a non-volatile is write: 201
XXX times a volatile is read: 10
XXX    times read thru a pointer: 2
XXX times a volatile is write: 7
XXX    times written thru a pointer: 7
XXX times a volatile is available for access: 87
XXX percentage of non-volatile access: 97.5

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 116
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 26
   depth: 2, occurrence: 17
   depth: 3, occurrence: 18
   depth: 4, occurrence: 11
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
********************* end of statistics **********************/

