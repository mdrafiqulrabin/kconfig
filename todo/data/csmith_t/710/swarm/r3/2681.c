/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      4101693832
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 18;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_31(void);
static float  func_38(struct S0  p_39, uint32_t  p_40);
static float  func_46(int16_t  p_47, uint32_t  p_48, uint32_t  p_49, uint32_t  p_50, struct S0  p_51);
static int16_t  func_66(uint64_t  p_67);
static struct S0  func_70(float  p_71, uint64_t  p_72);
static struct S0  func_74(struct S0  p_75, int32_t  p_76, uint16_t  p_77, float  p_78);
static uint64_t  func_79(float  p_80);
static uint64_t  func_81(uint64_t  p_82, struct S0  p_83, uint32_t  p_84, float  p_85);
static int16_t  func_90(int64_t  p_91, int32_t  p_92, int64_t  p_93, uint32_t  p_94, uint32_t  p_95);
static int64_t  func_96(struct S0  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_31(void)
{ /* block id: 36 */
    float l_32 = 0x4.3A4C92p+31;
    int32_t l_33 = 0x14FFD814L;
    uint32_t l_642 = 0xEF0DB528L;
    struct S0 l_645 = {203};
    uint64_t l_659 = 0UL;
    l_33 = l_33;
    for (l_33 = 25; (l_33 >= 19); l_33 -= 5)
    { /* block id: 40 */
        uint64_t l_37 = 0UL;
        int32_t l_41 = 0x9CEE24B2L;
        struct S0 l_42 = {36};
        uint32_t l_640 = 0UL;
        int16_t l_641 = 0L;
        l_642 = (((-(float)l_37) < func_38((l_41 , l_42), l_42.f0)) <= (((float)((((float)((((((float)__builtin_ctzll(l_33) * (float)(l_33 <= ((float)((l_33 || 0xADFFACC9L) , 0x6.A89E05p-21) * (float)(-0x1.Fp-1)))) < l_33) >= l_33) <= l_640) != l_641) - (float)l_37) , l_33) != 0xB.C73AF5p-12) + (float)(-0x1.4p-1)) <= l_640));
    }
    for (l_642 = 26; (l_642 != 44); l_642 += 3)
    { /* block id: 326 */
        uint32_t l_648 = 4294967293UL;
        int32_t l_658 = (-2L);
        l_645 = l_645;
        l_658 = (((l_642 > ((uint64_t)(l_642 < l_648) - (uint64_t)l_645.f0)) , ((l_648 != ((uint16_t)func_79(((float)0x0.515C24p-11 + (float)((float)((float)(0x5.C39A55p+77 < 0xD.394AC3p-74) * (float)(((!l_33) != l_648) == 0x1.Dp-1)) + (float)l_33))) % (uint16_t)l_33)) < l_648)) > l_645.f0);
    }
    return l_659;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_38(struct S0  p_39, uint32_t  p_40)
{ /* block id: 41 */
    int32_t l_45 = 0L;
    l_45 = __builtin_clz((((((-0x1.0p-1) < ((float)l_45 + (float)p_40)) != l_45) < (func_46(p_39.f0, l_45, __builtin_clzl(l_45), l_45, p_39) > l_45)) , l_45));
    return l_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_46(int16_t  p_47, uint32_t  p_48, uint32_t  p_49, uint32_t  p_50, struct S0  p_51)
{ /* block id: 42 */
    uint32_t l_430 = 4294967295UL;
    int32_t l_431 = 1L;
    int32_t l_460 = 0x70FA0D30L;
    uint32_t l_520 = 0xD40C54ADL;
    struct S0 l_522 = {361};
    struct S0 l_569 = {509};
    uint16_t l_630 = 65529UL;
    for (p_50 = 0; (p_50 > 40); p_50 += 9)
    { /* block id: 45 */
        int64_t l_62 = (-10L);
        uint32_t l_63 = 0UL;
        int32_t l_449 = 0xAD316F0BL;
        struct S0 l_503 = {126};
        int64_t l_581 = (-4L);
        if (p_48)
            break;
        l_431 = ((int64_t)((uint64_t)((int32_t)(((int64_t)(p_51 , l_62) + (int64_t)(l_63 && (1UL < ((int16_t)func_66(l_62) + (int16_t)func_96(func_70(p_48, l_62)))))) < 0xD7B6BB72L) % (int32_t)p_48) - (uint64_t)p_48) - (int64_t)l_430);
        for (p_47 = 11; (p_47 < (-15)); p_47 -= 1)
        { /* block id: 233 */
            int64_t l_442 = 1L;
            struct S0 l_455 = {17};
            int32_t l_461 = 0x1217C3E0L;
            for (l_431 = 29; (l_431 != 10); l_431 -= 1)
            { /* block id: 236 */
                struct S0 l_447 = {42};
                uint64_t l_448 = 18446744073709551615UL;
                l_449 = (p_48 == (((uint32_t)(0x4EDC7A96L <= ((uint16_t)((int16_t)l_442 + (int16_t)((uint16_t)(l_63 >= func_81(__builtin_popcount(p_51.f0), (__builtin_ctzll((((int16_t)0xD3CFL << (int16_t)13) , p_50)) , l_447), l_430, l_448)) - (uint16_t)0x0E91L)) * (uint16_t)l_447.f0)) + (uint32_t)p_50) != l_63));
                l_460 = ((uint16_t)l_447.f0 * (uint16_t)(!(((((p_51.f0 < ((float)(p_51.f0 < (func_79(p_50) > func_96(l_455))) * (float)l_448)) != ((float)(((float)(l_430 > p_50) * (float)l_431) == l_430) + (float)l_63)) < l_430) == l_448) , 4294967295UL)));
                l_461 = 0L;
                return p_51.f0;
            }
            l_461 = ((p_48 == 2UL) , p_50);
            l_449 = ((int64_t)((((__builtin_clzll(func_79((p_51.f0 > func_79(((-(float)(!(!((((float)(((float)__builtin_ia32_crc32qi(((0L & l_431) , (((int64_t)(((((float)((l_430 < 4294967295UL) , l_63) * (float)(p_47 > ((float)l_461 + (float)0xC.58A97Bp-25))) > p_51.f0) <= 0x8.A652AFp+5) , p_50) + (int64_t)l_442) <= p_51.f0)), l_63) * (float)p_48) >= l_63) + (float)p_49) != l_460) >= l_461)))) <= l_63))))) & l_63) != p_48) ^ p_47) && l_431) + (int64_t)l_461);
            return l_460;
        }
        if (func_90(l_460, (((func_66(l_430) & (((int16_t)((uint16_t)((int16_t)1L - (int16_t)(((int32_t)0x59AAA8E0L - (int32_t)(((-0x1.5p-1) > (-0x1.0p+1)) , l_449)) | ((p_48 && p_50) < p_50))) << (uint16_t)0) * (int16_t)1L) > 0x82F0DBEEL)) > l_62) , l_62), l_449, l_430, p_48))
        { /* block id: 246 */
            struct S0 l_485 = {356};
            int32_t l_535 = 4L;
            int32_t l_579 = (-1L);
            l_485 = func_70(l_430, p_48);
            if (l_460)
            { /* block id: 248 */
                int16_t l_492 = (-1L);
                if (l_63)
                { /* block id: 249 */
                    int16_t l_497 = 0x881AL;
                    int64_t l_502 = 0x12572D1F8BF4BCD0LL;
                    int32_t l_521 = (-4L);
                    struct S0 l_523 = {101};
                    if (p_50)
                        break;
                    if (l_430)
                    { /* block id: 251 */
                        uint32_t l_491 = 3UL;
                        l_485 = p_51;
                        l_431 = __builtin_ffsl(p_51.f0);
                        l_497 = ((int64_t)((0x31CFL | ((uint16_t)p_50 << (uint16_t)3)) , ((!l_491) , (func_74(func_70(l_492, l_492), __builtin_ffsl((__builtin_parityl(((uint16_t)0UL >> (uint16_t)6)) | ((uint64_t)__builtin_ctz(l_485.f0) - (uint64_t)p_49))), l_485.f0, l_492) , p_48))) % (int64_t)0x34E7CA7AA63157CBLL);
                        l_449 = (-(float)((-(float)((l_63 , (((int16_t)(l_497 != ((p_49 <= (((l_492 > ((((((p_49 > (6L <= __builtin_ffsll(func_90((__builtin_ffsll(p_47) && l_491), l_449, l_431, l_431, p_50)))) > l_497) , 0x595FBE27L) <= p_47) == p_51.f0) , p_47)) , 0UL) && l_431)) && p_47)) * (int16_t)p_48) , 0x2.37808Ap-60)) <= l_430)) > p_49));
                    }
                    else
                    { /* block id: 256 */
                        struct S0 l_504 = {149};
                        l_449 = l_502;
                        l_504 = l_503;
                    }
                    for (p_48 = (-3); (p_48 >= 11); p_48++)
                    { /* block id: 262 */
                        struct S0 l_513 = {444};
                        p_51 = ((__builtin_ffsll(__builtin_parityl(p_48)) , 18446744073709551614UL) , func_70((((((float)(((float)p_51.f0 + (float)(__builtin_ffsll(((0xE30A026383328BE9LL != 0L) >= (((int16_t)p_50 % (int16_t)(l_492 , l_449)) | 9L))) == 0x5.787EC1p-2)) < l_497) * (float)0x0.476A02p+8) != p_50) != l_430) == l_497), p_47));
                        l_513 = p_51;
                        l_513 = func_74(p_51, l_485.f0, (((l_492 ^ (__builtin_ffsl(l_63) , ((p_49 , ((uint32_t)((((int16_t)p_48 >> (int16_t)12) && l_497) ^ ((int32_t)(l_492 | p_50) % (int32_t)8L)) % (uint32_t)4294967290UL)) && 0xAB2CDC51L))) & l_502) , 9UL), p_47);
                        l_521 = ((l_485.f0 != l_520) == l_492);
                    }
                    l_523 = l_522;
                }
                else
                { /* block id: 269 */
                    float l_524 = 0x1.Cp+1;
                    int32_t l_531 = 0x14865928L;
                    struct S0 l_556 = {339};
                    if (p_49)
                    { /* block id: 270 */
                        uint32_t l_530 = 0xF9C2A4E8L;
                        l_531 = (4UL && (!((int16_t)l_530 << (int16_t)__builtin_ffs(p_47))));
                    }
                    else
                    { /* block id: 272 */
                        uint32_t l_534 = 1UL;
                        if (p_50)
                            break;
                        l_449 = 0x4401B90DL;
                        l_535 = func_81((func_74(p_51, (1L == ((0x496D997AL & __builtin_ctzll((((float)0x1.Ap+1 * (float)(((((p_47 >= 65527UL) , func_90((p_47 , func_96(func_74(func_70(l_492, p_48), p_49, l_492, l_531))), l_485.f0, p_51.f0, l_430, l_534)) == p_51.f0) >= 0x7.6CEB19p-77) , 0xE.CF99A9p+80)) , l_534))) >= l_62)), p_49, l_485.f0) , l_534), l_503, l_430, l_534);
                        l_449 = ((float)(-(float)(p_51 , ((((((((int16_t)(((uint16_t)((int16_t)l_535 * (int16_t)((uint16_t)l_492 * (uint16_t)(!l_531))) * (uint16_t)p_48) > l_534) << (int16_t)((int64_t)((uint32_t)p_49 % (uint32_t)p_51.f0) - (int64_t)((((((int64_t)(-6L) % (int64_t)p_50) > p_48) & 0xAF5C121100BC54ECLL) >= l_534) , p_48))) ^ 18446744073709551606UL) <= 0xC160C6E5446FAC34LL) , p_49) & p_48) , p_48) == l_531))) * (float)(-0x1.4p-1));
                    }
                    if ((0xE32FL | ((uint32_t)1UL + (uint32_t)p_50)))
                    { /* block id: 278 */
                        p_51 = func_74(l_556, p_49, p_49, ((((int64_t)((uint16_t)func_96(l_522) * (uint16_t)p_49) % (int64_t)((l_503 , p_51.f0) & (l_522.f0 | l_431))) <= p_49) , p_47));
                        return l_531;
                    }
                    else
                    { /* block id: 281 */
                        float l_577 = 0x5.CD6698p+18;
                        int32_t l_578 = 0x1EE8026FL;
                        l_449 = ((l_492 || ((int16_t)(((uint16_t)((p_51.f0 & ((int16_t)(-6L) >> (int16_t)(((uint16_t)((func_96(l_569) & ((int16_t)(!l_535) + (int16_t)((l_449 != ((0x7.DF3A3Cp+74 != ((float)((float)l_556.f0 - (float)0x0.4p-1) * (float)0x1.8p+1)) , p_47)) < p_50))) , 1UL) * (uint16_t)p_47) >= 1UL))) && p_51.f0) * (uint16_t)1L) && l_556.f0) << (int16_t)l_63)) ^ l_578);
                        l_535 = ((((p_50 <= __builtin_ffsl((p_51.f0 == (__builtin_parityl(p_47) | ((l_492 & ((p_48 , (__builtin_ffsll(l_535) || l_579)) != l_431)) <= p_47))))) < 0x0.Dp+1) <= l_62) , 0L);
                    }
                }
            }
            else
            { /* block id: 286 */
                uint64_t l_580 = 0x901EEE6B0D0AC692LL;
                if ((l_62 > (((p_49 ^ (((4294967295UL && ((func_70(l_449, (p_48 || p_51.f0)) , 0x2853L) | l_580)) && l_503.f0) | 0x81A983F90FF40068LL)) ^ p_49) > l_569.f0)))
                { /* block id: 287 */
                    return l_430;
                }
                else
                { /* block id: 289 */
                    l_581 = func_66(p_48);
                    if (l_503.f0)
                        continue;
                }
                l_535 = func_90((l_485.f0 & ((int32_t)(((((((int16_t)l_579 - (int16_t)l_431) & (func_66(l_579) , l_460)) == ((int32_t)(l_581 == l_503.f0) - (int32_t)0x55A843E8L)) ^ p_50) , 0xB2DCD3B6L) || p_51.f0) - (int32_t)0xE8B36FBCL)), p_48, l_569.f0, p_51.f0, p_50);
                return l_535;
            }
        }
        else
        { /* block id: 296 */
            uint16_t l_590 = 1UL;
            int32_t l_611 = 0L;
            if (((uint64_t)l_590 - (uint64_t)(0xF8F90EE57200D2AFLL > (((int16_t)p_48 - (int16_t)((((int16_t)(!p_49) >> (int16_t)6) && ((uint16_t)p_49 % (uint16_t)l_431)) || (((uint32_t)((int32_t)((int16_t)((uint16_t)((uint16_t)((l_590 , (((int16_t)(-2L) + (int16_t)(!p_50)) <= p_48)) || l_63) + (uint16_t)0x598BL) >> (uint16_t)l_62) >> (int16_t)6) + (int32_t)l_590) + (uint32_t)p_47) ^ l_590))) >= 0x9BE2L))))
            { /* block id: 297 */
                l_611 = 8L;
            }
            else
            { /* block id: 299 */
                p_51 = p_51;
                l_503 = p_51;
            }
        }
    }
    for (l_460 = 0; (l_460 > 19); l_460++)
    { /* block id: 307 */
        uint16_t l_618 = 65535UL;
        int32_t l_629 = 1L;
        if (func_66(((uint32_t)0x6E8EC02EL - (uint32_t)((((uint16_t)(l_618 || (4294967295UL & ((~((((int16_t)l_618 >> (int16_t)__builtin_ffsl(l_618)) || ((func_66((-(uint32_t)p_49)) ^ l_618) & 0xD181A7AE086F864ALL)) >= l_618)) < 65535UL))) * (uint16_t)l_618) != l_618) <= (-3L)))))
        { /* block id: 308 */
            int64_t l_628 = 0L;
            l_431 = (!(l_569.f0 == ((((float)((float)p_51.f0 - (float)p_50) + (float)p_49) > l_628) != p_51.f0)));
            l_629 = (l_569.f0 != p_47);
        }
        else
        { /* block id: 311 */
            uint32_t l_631 = 9UL;
            l_431 = (func_96(p_51) && l_630);
            return l_631;
        }
        l_431 = (-1L);
        if (l_629)
            continue;
    }
    l_431 = (l_430 & (l_430 >= 65535UL));
    return l_630;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_66(uint64_t  p_67)
{ /* block id: 47 */
    int32_t l_73 = 1L;
    for (p_67 = 0; (p_67 == 42); p_67 += 4)
    { /* block id: 50 */
        struct S0 l_429 = {447};
        l_429 = func_70(l_73, l_73);
    }
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_70(float  p_71, uint64_t  p_72)
{ /* block id: 51 */
    struct S0 l_422 = {397};
    l_422 = func_74((func_79(p_71) , l_422), l_422.f0, ((uint16_t)l_422.f0 * (uint16_t)((uint32_t)p_72 + (uint32_t)p_72)), l_422.f0);
    return l_422;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_74(struct S0  p_75, int32_t  p_76, uint16_t  p_77, float  p_78)
{ /* block id: 222 */
    uint32_t l_427 = 0xE4E1D579L;
    struct S0 l_428 = {488};
    l_427 = 0xD1B6FB1FL;
    return l_428;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_79(float  p_80)
{ /* block id: 52 */
    struct S0 l_98 = {12};
    uint16_t l_107 = 0UL;
    int32_t l_384 = (-7L);
    int32_t l_396 = 0xB6D6A342L;
    int64_t l_421 = 0xB3F356C05553CE12LL;
lbl_405:
    l_384 = __builtin_clzll(func_81(((((int16_t)((int16_t)func_90(func_96(l_98), l_98.f0, ((((uint16_t)l_98.f0 << (uint16_t)9) & (((((-(uint64_t)l_98.f0) || l_98.f0) == (((uint32_t)(l_98.f0 ^ (((uint16_t)l_98.f0 % (uint16_t)l_98.f0) <= l_98.f0)) + (uint32_t)l_98.f0) >= 18446744073709551615UL)) ^ 0x5F1D345D19045039LL) < l_98.f0)) , l_98.f0), l_107, l_107) - (int16_t)l_98.f0) >> (int16_t)3) , 18446744073709551606UL) , l_98.f0), l_98, l_107, l_107));
    for (l_384 = (-5); (l_384 < 11); ++l_384)
    { /* block id: 202 */
        uint64_t l_387 = 0xB29BC3DCDBF535D0LL;
        struct S0 l_394 = {276};
        int32_t l_395 = 2L;
        uint32_t l_404 = 4294967290UL;
        if (((l_387 , (((uint16_t)0x1E02L + (uint16_t)(0x1A32L || (((2L < (__builtin_ffsl(l_387) , __builtin_clzl((func_90(((int64_t)func_90(((int16_t)l_98.f0 << (int16_t)l_387), (l_394 , l_384), l_394.f0, l_384, l_394.f0) - (int64_t)l_98.f0), l_394.f0, l_98.f0, l_394.f0, l_387) ^ l_107)))) == l_395) <= 1UL))) <= l_98.f0)) > l_107))
        { /* block id: 203 */
            l_396 = l_98.f0;
            p_80 = (((-0x10.9p-1) < l_98.f0) > l_98.f0);
            l_394 = l_394;
            for (l_395 = 0; (l_395 < 20); l_395 += 5)
            { /* block id: 209 */
                int32_t l_399 = (-1L);
                if (l_399)
                    break;
            }
        }
        else
        { /* block id: 212 */
            struct S0 l_400 = {399};
            int16_t l_403 = 5L;
            l_400 = l_400;
            l_396 = ((float)l_403 * (float)func_96(((4294967288UL <= l_400.f0) , l_394)));
        }
        l_394 = l_394;
        p_80 = l_404;
    }
    if (l_98.f0)
        goto lbl_405;
    l_396 = (((uint32_t)((~(l_396 <= l_98.f0)) && ((l_107 != (((int16_t)((uint16_t)(((int16_t)(((uint32_t)8UL + (uint32_t)((((int16_t)l_396 >> (int16_t)6) != func_90(l_396, l_396, (((uint16_t)l_107 - (uint16_t)0UL) , l_107), l_384, l_107)) > l_396)) > l_396) >> (int16_t)l_421) , l_396) >> (uint16_t)l_396) >> (int16_t)l_396) | l_396)) >= l_421)) - (uint32_t)0xA38CAB49L) ^ l_396);
    return l_98.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_81(uint64_t  p_82, struct S0  p_83, uint32_t  p_84, float  p_85)
{ /* block id: 179 */
    int16_t l_363 = (-7L);
    float l_371 = (-0x8.Dp-1);
    int32_t l_372 = 1L;
    struct S0 l_377 = {502};
    float l_383 = 0x0.23629Ap+11;
    l_363 = (__builtin_ffsll(p_82) & p_82);
    l_372 = (((uint64_t)(((uint16_t)(p_83.f0 , 0xD67DL) >> (uint16_t)6) < ((int16_t)(p_84 , (p_84 <= (-(int16_t)(l_363 || p_84)))) << (int16_t)l_363)) % (uint64_t)p_83.f0) ^ 0x8A3E8C22L);
    l_372 = l_363;
    if ((p_83.f0 >= (-(int32_t)p_83.f0)))
    { /* block id: 183 */
        for (p_84 = 0; (p_84 < 49); p_84 += 7)
        { /* block id: 186 */
            struct S0 l_376 = {104};
            l_377 = l_376;
            p_83 = p_83;
        }
        for (p_82 = (-12); (p_82 > 38); ++p_82)
        { /* block id: 192 */
            uint16_t l_380 = 5UL;
            int32_t l_381 = 1L;
            l_381 = l_380;
        }
    }
    else
    { /* block id: 195 */
        int32_t l_382 = 0L;
        return l_382;
    }
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_90(int64_t  p_91, int32_t  p_92, int64_t  p_93, uint32_t  p_94, uint32_t  p_95)
{ /* block id: 56 */
    int32_t l_120 = 0x0F657D2AL;
    uint32_t l_129 = 9UL;
    struct S0 l_134 = {287};
    int32_t l_302 = 6L;
    struct S0 l_308 = {34};
    uint32_t l_313 = 1UL;
    float l_343 = 0x4.Fp-1;
    struct S0 l_361 = {444};
    int16_t l_362 = 0x8460L;
    for (p_92 = 0; (p_92 != 3); p_92 += 1)
    { /* block id: 59 */
        uint32_t l_114 = 9UL;
        struct S0 l_139 = {25};
        int32_t l_185 = 0x53B8602FL;
        struct S0 l_192 = {231};
        uint64_t l_263 = 0x1DA8FA583B5FAB9ALL;
        l_120 = ((int16_t)(((int16_t)l_114 >> (int16_t)7) , __builtin_clzl((((p_91 & l_114) , p_95) < (((uint16_t)((-(uint64_t)(l_114 ^ (((int16_t)l_120 * (int16_t)(((int16_t)(((((int16_t)(l_114 == (l_114 && ((uint64_t)((uint16_t)(((-3L) || l_114) , l_120) - (uint16_t)p_95) + (uint64_t)l_120))) >> (int16_t)l_120) ^ l_129) , l_114) | l_129) >> (int16_t)3) >= p_91)) == p_93))) != l_114) * (uint16_t)0xD8B2L) != l_114)))) * (int16_t)0L);
        l_120 = ((int16_t)((int32_t)0x38899A86L + (int32_t)(((p_93 & ((func_96(l_134) != p_94) != ((p_95 | ((__builtin_clzll((p_91 == 0x46699CBFF9F6C923LL)) ^ p_91) || p_95)) ^ 0xAA3AL))) != l_114) || 0x80A6L)) * (int16_t)(-2L));
        for (p_93 = 0; (p_93 >= 1); p_93 += 1)
        { /* block id: 64 */
            struct S0 l_138 = {503};
            int32_t l_155 = (-1L);
            if (p_93)
            { /* block id: 65 */
                if ((-(int16_t)0L))
                { /* block id: 66 */
                    l_138 = l_134;
                    l_138 = l_139;
                }
                else
                { /* block id: 69 */
                    int64_t l_144 = 0x0CB50322C85E55DFLL;
                    l_120 = (__builtin_ctzl(((int16_t)(((uint16_t)(l_144 && (((((((uint16_t)l_134.f0 >> (uint16_t)((int64_t)((int16_t)(p_91 || (l_138.f0 ^ (-(uint64_t)__builtin_parityll((l_134.f0 < (0x010A371577CD1832LL == p_94)))))) - (int16_t)(((uint32_t)4294967295UL - (uint32_t)(-2L)) || 0L)) % (int64_t)0xE0D49B816A8AB26FLL)) , 18446744073709551608UL) , p_91) , 65531UL) >= 1UL) && p_95)) + (uint16_t)0x2EBDL) >= p_92) << (int16_t)8)) < p_93);
                    l_120 = (l_138.f0 > l_144);
                }
                return l_138.f0;
            }
            else
            { /* block id: 74 */
                uint32_t l_154 = 4294967295UL;
                struct S0 l_161 = {76};
                if (l_154)
                    break;
                if (l_120)
                { /* block id: 76 */
                    uint64_t l_158 = 0x51AC0D59BB75F8F1LL;
                    l_155 = l_154;
                    for (p_94 = 0; (p_94 != 40); p_94 += 5)
                    { /* block id: 80 */
                        l_158 = l_138.f0;
                    }
                }
                else
                { /* block id: 83 */
                    float l_179 = 0xE.11E331p-38;
                    struct S0 l_180 = {309};
                    int32_t l_183 = 0xB85D1346L;
                    for (p_91 = 0; (p_91 == (-8)); p_91 -= 4)
                    { /* block id: 86 */
                        l_139 = l_161;
                        l_155 = ((p_92 | ((int16_t)(((uint64_t)((((int16_t)(((uint16_t)(p_93 , (func_96(l_139) > ((((int64_t)(func_96(l_138) , (((((int16_t)(-2L) << (int16_t)1) , (!((((int16_t)(l_138.f0 && ((int32_t)__builtin_ctz(p_95) + (int32_t)p_95)) * (int16_t)l_129) == p_95) < 0xECD75B28L))) & p_95) && p_93)) + (int64_t)(-1L)) <= l_129) || 0x8A0C8243L))) - (uint16_t)0xCDB5L) && p_93) * (int16_t)65527UL) && l_120) | 0xA35AL) + (uint64_t)p_95) ^ 0x60EBF8190269B8F4LL) * (int16_t)p_94)) ^ l_120);
                    }
                    l_180 = l_161;
                    if ((l_180.f0 >= (((int16_t)l_138.f0 * (int16_t)p_91) <= 0L)))
                    { /* block id: 91 */
                        l_183 = func_96(l_134);
                        l_155 = (-(int16_t)p_95);
                        l_185 = 0x9DF61D7EL;
                        return l_154;
                    }
                    else
                    { /* block id: 96 */
                        float l_186 = 0x1.8BC0DDp+24;
                        int32_t l_187 = 0xAE02F275L;
                        l_138 = l_134;
                        l_138 = l_134;
                        l_187 = p_95;
                    }
                }
            }
            if (l_155)
                break;
        }
        if (((((int16_t)(p_91 >= ((int32_t)(l_192 , p_93) * (int32_t)((l_185 , (p_92 >= (func_96(((((uint64_t)(((((uint64_t)(l_129 ^ (((uint16_t)((__builtin_ia32_crc32qi(l_129, p_94) <= 0x8E688B2FF17D062ALL) || l_134.f0) >> (uint16_t)p_95) ^ l_134.f0)) - (uint64_t)l_139.f0) >= l_192.f0) == l_139.f0) , 1UL) - (uint64_t)l_185) && l_134.f0) , l_139)) | (-2L)))) < p_93))) - (int16_t)l_139.f0) , p_92) > 1L))
        { /* block id: 105 */
            int64_t l_207 = 0x069B646BD1A66B95LL;
            int16_t l_232 = 0x8CA0L;
            int32_t l_258 = (-1L);
            struct S0 l_259 = {302};
            if (((int16_t)(l_185 > (((uint16_t)(l_139 , (p_92 <= (p_91 > (l_192.f0 < ((((p_94 > ((int16_t)0x6567L >> (int16_t)(p_94 | ((((__builtin_parity(((uint64_t)18446744073709551615UL - (uint64_t)l_134.f0)) || p_95) < l_120) && p_91) || l_207)))) , l_207) || 0xE4FF7534L) <= 0x7D5CL))))) % (uint16_t)p_93) < p_91)) >> (int16_t)p_94))
            { /* block id: 106 */
                uint32_t l_210 = 0UL;
                int32_t l_217 = 0x79365D8EL;
                l_217 = ((float)(__builtin_ffs((l_210 , (p_91 , p_95))) , p_94) + (float)((float)((float)(l_139.f0 > p_93) * (float)((float)(0xE.45A47Ap+65 != l_210) * (float)l_185)) + (float)(-0x1.Ep+1)));
                l_185 = (((int32_t)l_207 - (int32_t)(-1L)) > l_207);
                if ((p_91 < (((((uint16_t)0UL << (uint16_t)9) , (l_207 ^ (((((int16_t)(l_217 < (((int32_t)0xEE4DF8AFL + (int32_t)2UL) & (6L < (((int16_t)((uint32_t)4294967288UL - (uint32_t)func_96(l_192)) >> (int16_t)l_232) > p_95)))) + (int16_t)l_114) && 0x231F37C5CFF5E1EALL) != 0x65F8L) && 4294967288UL))) >= l_185) && 0x28F33289A5802A5FLL)))
                { /* block id: 109 */
                    int64_t l_233 = 0x6AD60D6B5B7701A7LL;
                    struct S0 l_243 = {47};
                    int32_t l_257 = 8L;
                    if ((p_95 < ((p_91 & (l_217 , ((((l_233 < func_96(l_192)) > (func_96(l_192) != ((float)0x0.1p-1 * (float)p_93))) , l_134) , l_207))) >= 8L)))
                    { /* block id: 110 */
                        int32_t l_236 = 0x1A8147CEL;
                        l_236 = (l_210 == p_94);
                        l_217 = (1UL ^ (((int16_t)((int16_t)(p_93 || (((int16_t)((func_96(((0x1151F3E89965A7D2LL != ((func_96(l_243) >= (((float)((p_94 , (((((((int16_t)((uint16_t)((p_92 != ((int32_t)0xA055E4C5L % (int32_t)p_92)) , p_92) + (uint16_t)p_95) >> (int16_t)l_232) >= p_91) >= 0xCC4F0A17803233C0LL) != 18446744073709551615UL) , l_236) > p_91)) < 0x1.0p+1) + (float)l_236) != 0x3.Bp+1)) , (-1L))) , l_134)) , p_93) , l_129) + (int16_t)0x9D89L) > p_94)) >> (int16_t)12) * (int16_t)p_93) & 0xCC7AL));
                    }
                    else
                    { /* block id: 113 */
                        int32_t l_256 = 0xDEA42474L;
                        if (l_210)
                            break;
                        l_257 = (0x58026D626AAE363CLL < ((p_91 >= l_185) , ((uint16_t)(l_134.f0 && ((__builtin_ffsl(p_93) , ((int16_t)(9UL > __builtin_popcountll(l_256)) >> (int16_t)l_129)) == l_256)) + (uint16_t)p_94)));
                        l_258 = l_139.f0;
                    }
                }
                else
                { /* block id: 118 */
                    l_217 = func_96(l_259);
                    for (l_120 = 0; (l_120 <= 12); ++l_120)
                    { /* block id: 122 */
                        l_217 = (0x5D54L | p_95);
                        if (p_95)
                            break;
                    }
                }
            }
            else
            { /* block id: 127 */
                int32_t l_266 = 0x911EA6DDL;
                struct S0 l_267 = {49};
                l_259 = ((((~l_263) & ((uint16_t)(((l_266 , l_232) == p_95) <= (l_120 , 0xFBE9AB393D07945ELL)) % (uint16_t)p_91)) ^ (l_139.f0 ^ p_93)) , l_267);
            }
        }
        else
        { /* block id: 130 */
            uint64_t l_279 = 0x8290AFDDB5E15BD4LL;
            struct S0 l_344 = {448};
            int32_t l_353 = 0xE87B9154L;
            l_185 = ((((p_95 , ((uint16_t)p_95 - (uint16_t)((uint16_t)(p_91 > (l_139.f0 <= p_93)) + (uint16_t)(~p_94)))) | __builtin_popcount(((((p_91 , ((int64_t)(((int16_t)(((((uint16_t)l_192.f0 * (uint16_t)(((p_93 & 0x146DL) , l_192) , 65535UL)) & l_279) ^ l_139.f0) || (-1L)) + (int16_t)l_120) || p_95) - (int64_t)l_185)) || p_95) & 0xCC2CD189L) || 0x0761ED40L))) <= 1UL) , p_91);
            if (((uint16_t)(l_120 , (((p_95 >= ((int16_t)func_96(l_134) >> (int16_t)(-(int16_t)(l_139.f0 ^ p_95)))) != l_185) && l_134.f0)) << (uint16_t)((p_93 & l_192.f0) | l_279)))
            { /* block id: 132 */
                struct S0 l_291 = {380};
                int32_t l_303 = 1L;
                for (l_120 = 9; (l_120 > (-6)); l_120--)
                { /* block id: 135 */
                    uint32_t l_301 = 0xABCBBCD2L;
                    if (p_91)
                    { /* block id: 136 */
                        uint16_t l_296 = 65533UL;
                        l_302 = ((uint16_t)((int16_t)(__builtin_ctzl((func_96(l_291) | ((((int16_t)(((uint64_t)l_291.f0 - (uint64_t)l_296) , p_95) << (int16_t)12) != func_96(l_134)) , ((l_263 & ((((int64_t)((int64_t)0x934A2F955F64ED68LL - (int64_t)l_301) + (int64_t)0UL) || p_94) == p_91)) != p_95)))) ^ p_95) << (int16_t)p_91) << (uint16_t)11);
                    }
                    else
                    { /* block id: 138 */
                        l_303 = p_95;
                        if (p_94)
                            break;
                    }
                    if (p_91)
                    { /* block id: 142 */
                        l_302 = (l_301 != l_129);
                    }
                    else
                    { /* block id: 144 */
                        l_302 = (65533UL != __builtin_ctz((((uint64_t)((p_92 , 1L) ^ (((uint16_t)(p_93 || 0UL) << (uint16_t)0) != (func_96(l_308) , l_303))) - (uint64_t)((uint64_t)((((l_134 , l_291.f0) , l_291.f0) == p_92) , 0xD8558D5EF94F0498LL) - (uint64_t)18446744073709551613UL)) || 0x5CB5FD59L)));
                        l_185 = func_96(l_291);
                    }
                }
            }
            else
            { /* block id: 149 */
                uint32_t l_324 = 0x192D8548L;
                struct S0 l_345 = {235};
                for (l_114 = 0; (l_114 >= 23); l_114++)
                { /* block id: 152 */
                    uint16_t l_314 = 0xF7FAL;
                    l_314 = l_313;
                    for (l_129 = 4; (l_129 > 2); l_129 -= 7)
                    { /* block id: 156 */
                        if (p_92)
                            break;
                    }
                    if (((((((((int16_t)((((int64_t)0L - (int64_t)(!((int16_t)p_92 << (int16_t)5))) || __builtin_parityll((((l_324 < p_95) || ((int16_t)((int32_t)(__builtin_parity(((((l_314 < (p_95 == (((uint32_t)(-(int32_t)l_302) + (uint32_t)p_91) || ((((int16_t)(((((int64_t)(((int16_t)((uint64_t)(-(uint64_t)(((uint16_t)p_92 * (uint16_t)p_93) < l_279)) % (uint64_t)p_95) * (int16_t)0xBF3FL) & l_324) + (int64_t)0x85A1AA575788BF02LL) & l_324) || p_94) , l_302) << (int16_t)l_324) , p_94) ^ p_91)))) != p_92) && p_93) < 0x10878E65L)) < l_279) - (int32_t)p_92) >> (int16_t)0)) > l_279))) != 1UL) * (int16_t)l_314) && 4294967291UL) == 0x6ED3L) ^ l_134.f0) != p_95) > l_314) , p_91))
                    { /* block id: 159 */
                        int32_t l_346 = (-1L);
                        l_345 = l_344;
                        if (l_346)
                            break;
                        l_344 = l_345;
                        l_346 = ((int16_t)p_93 * (int16_t)(((uint16_t)((p_91 ^ p_91) , p_91) << (uint16_t)p_94) ^ (l_192.f0 < p_95)));
                    }
                    else
                    { /* block id: 164 */
                        if (p_92)
                            break;
                    }
                    if ((0x14176D2BC9011C2DLL == func_96(l_134)))
                    { /* block id: 167 */
                        int16_t l_352 = 1L;
                        l_185 = ((!l_352) >= l_344.f0);
                    }
                    else
                    { /* block id: 169 */
                        l_353 = p_95;
                    }
                }
            }
        }
    }
    l_302 = (p_94 != (0x1.Ap-1 != ((float)((float)__builtin_ctzl(p_91) + (float)(-(float)p_91)) - (float)((l_134 , ((float)(l_134 , l_313) * (float)(l_120 < 0x8.B7888Ep-84))) > l_120))));
    l_361 = l_134;
    return l_362;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_96(struct S0  p_97)
{ /* block id: 53 */
    struct S0 l_99 = {39};
    p_97 = l_99;
    return l_99.f0;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 108
   depth: 1, occurrence: 35
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 35
breakdown:
   indirect level: 0, occurrence: 35
XXX full-bitfields structs in the program: 35
breakdown:
   indirect level: 0, occurrence: 35
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 29
XXX times a bitfields struct on RHS: 68
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 114

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 184
   depth: 2, occurrence: 32
   depth: 3, occurrence: 11
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 4
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 26, occurrence: 3
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 34, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 743
XXX times a non-volatile is write: 119
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 177
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 21
   depth: 2, occurrence: 25
   depth: 3, occurrence: 22
   depth: 4, occurrence: 27
   depth: 5, occurrence: 50

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

