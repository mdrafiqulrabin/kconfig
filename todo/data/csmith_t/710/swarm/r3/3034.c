/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2965785132
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 4;
   unsigned f1 : 9;
   unsigned f2 : 7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_29(void);
static int32_t  func_30(int8_t  p_31, uint16_t  p_32, int32_t  p_33, uint32_t  p_34);
static struct S0  func_36(uint16_t  p_37, uint32_t  p_38, struct S0  p_39, uint32_t  p_40, uint32_t  p_41);
static uint16_t  func_42(int32_t  p_43, int16_t  p_44, int32_t  p_45);
static int32_t  func_48(uint32_t  p_49, int8_t  p_50);
static uint16_t  func_65(struct S0  p_66, uint32_t  p_67, int16_t  p_68);
static int16_t  func_75(uint16_t  p_76);
static int32_t  func_77(uint32_t  p_78, uint32_t  p_79, uint32_t  p_80);
static const struct S0  func_85(int8_t  p_86, int32_t  p_87);
static int32_t  func_92(int16_t  p_93, uint32_t  p_94, uint16_t  p_95, uint32_t  p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_29(void)
{ /* block id: 36 */
    int8_t l_35 = 0;
    int32_t l_571 = 0;
    l_571 = func_30(l_35, l_35, (1U | 8U), l_35);
    l_571 = (l_35 == (l_571 != 0x08E1C68E));
    if ((l_571 = ((__builtin_bswap32(l_571) == (((int16_t)(-1) >> (int16_t)l_35) != l_35)) ^ l_35)))
    { /* block id: 381 */
        return l_35;
    }
    else
    { /* block id: 383 */
        return l_35;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_30(int8_t  p_31, uint16_t  p_32, int32_t  p_33, uint32_t  p_34)
{ /* block id: 37 */
    uint32_t l_55 = 0xF30385D0;
    struct S0 l_69 = {-1,16,2};
    uint32_t l_542 = 0xD9B6EDE9;
    uint32_t l_555 = 0x287F9BC2;
    struct S0 l_570 = {1,5,7};
    l_570 = (l_69 = func_36((p_32 = func_42(((((uint32_t)(func_48((((uint16_t)__builtin_ctzll((((uint16_t)l_55 - (uint16_t)((int16_t)l_55 - (int16_t)((int16_t)((-(uint16_t)65535U) > ((int16_t)((uint16_t)0U << (uint16_t)12) << (int16_t)15)) + (int16_t)func_65(l_69, (~((((uint16_t)(p_32 == (((int16_t)0xAA9B >> (int16_t)2) != (func_75(p_31) <= 0))) - (uint16_t)p_34) & 0x9A51) & l_69.f2)), l_69.f2)))) && l_69.f2)) << (uint16_t)1) < p_34), l_69.f2) ^ p_34) % (uint32_t)p_33) ^ l_542) || p_32), p_31, l_55)), l_555, l_69, p_34, l_69.f0));
    l_570.f0 = l_555;
    return l_570.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_36(uint16_t  p_37, uint32_t  p_38, struct S0  p_39, uint32_t  p_40, uint32_t  p_41)
{ /* block id: 370 */
    uint32_t l_562 = 4294967289U;
    int32_t l_568 = 3;
    struct S0 l_569 = {2,5,5};
    l_568 = ((int16_t)1 + (int16_t)(0 >= (((uint16_t)((uint16_t)l_562 >> (uint16_t)(__builtin_clzl((+4294967295U)) || (((uint16_t)((int16_t)(((p_37 = func_77(l_562, (4294967287U != (l_562 != p_38)), l_562)) >= 8) >= 6) >> (int16_t)p_39.f1) % (uint16_t)l_562) <= p_38))) >> (uint16_t)p_41) & l_562)));
    return l_569;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_42(int32_t  p_43, int16_t  p_44, int32_t  p_45)
{ /* block id: 364 */
    int32_t l_545 = 0x2B0D939E;
    const uint16_t l_550 = 0xD707;
    int32_t l_553 = 0;
    int16_t l_554 = 0x8DE2;
    p_43 = 0x3B2298EF;
    l_554 = ((int16_t)l_545 + (int16_t)((((uint32_t)((uint16_t)0x1C1F % (uint16_t)(((l_545 > ((l_553 = ((l_545 | l_550) >= ((int16_t)l_550 << (int16_t)0))) <= p_45)) != l_545) | ((0xFC8A9EF8 & l_550) | l_550))) - (uint32_t)l_545) == l_550) & p_45));
    return l_553;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_48(uint32_t  p_49, int8_t  p_50)
{ /* block id: 86 */
    int32_t l_201 = 0xF22EBF56;
    int32_t l_202 = (-3);
    int32_t l_211 = 0x0D1834DD;
    struct S0 l_220 = {-1,8,3};
    int32_t l_225 = 1;
    struct S0 l_296 = {-0,7,0};
    int8_t l_348 = 0x07;
    uint32_t l_460 = 0xD1883289;
    int16_t l_528 = 0x2CFE;
    int32_t l_534 = 0xCE17E4F5;
    uint16_t l_537 = 0xA7E5;
    if ((0x3052 || ((l_202 = ((((l_201 = (p_49 == (+1))) < (__builtin_popcount(l_202) != ((uint16_t)l_202 >> (uint16_t)((uint16_t)p_50 + (uint16_t)(((-9) | (l_202 || p_49)) == p_50))))) >= 0x234033A2) <= p_50)) != 6)))
    { /* block id: 89 */
        uint16_t l_216 = 65529U;
        int32_t l_217 = 9;
        l_217 = ((l_201 && ((uint16_t)l_202 + (uint16_t)(p_49 && p_50))) > (0 || ((((int16_t)(65535U ^ (l_211 <= (-4))) << (int16_t)((uint16_t)(((uint16_t)l_216 << (uint16_t)l_216) && l_216) - (uint16_t)65530U)) && p_50) ^ p_49)));
    }
    else
    { /* block id: 91 */
        return p_50;
    }
    if ((((int32_t)(__builtin_ctz((l_225 = (l_211 = (0xFB4F4348 > ((p_49 > l_211) && __builtin_parityl(func_65((l_220 = func_85(l_201, l_201)), (((-1) ^ (((uint16_t)((l_202 = (-3)) <= (__builtin_ctz((p_49 = (((int16_t)func_75(l_201) << (int16_t)14) < l_201))) == p_50)) >> (uint16_t)l_201) != p_50)) > p_50), l_201))))))) > p_50) % (int32_t)l_201) <= l_201))
    { /* block id: 99 */
        int32_t l_226 = 6;
        int32_t l_227 = 0x51EFE91F;
        int32_t l_241 = 0x850B4F93;
        struct S0 l_249 = {0,20,6};
        uint32_t l_291 = 4294967295U;
        int16_t l_315 = 0x6F51;
        uint32_t l_365 = 0x21BA7965;
        uint32_t l_406 = 8U;
        struct S0 l_420 = {1,3,7};
        uint32_t l_422 = 0x5E85FD5C;
        uint16_t l_524 = 0U;
        int32_t l_533 = (-9);
        l_226 = (l_226 == (p_49 = (p_49 <= (l_227 = (l_226 || __builtin_parityl(p_50))))));
        if ((((uint16_t)((int32_t)l_201 - (int32_t)l_226) - (uint16_t)((l_226 < (+((uint32_t)(p_50 == p_49) - (uint32_t)((l_227 | (l_241 = ((uint16_t)(l_202 = ((!((int16_t)(!(1U || l_227)) << (int16_t)0)) ^ func_75(p_50))) - (uint16_t)(-8)))) > 3)))) == l_225)) ^ p_50))
        { /* block id: 105 */
            int32_t l_250 = (-5);
            const struct S0 l_251 = {2,4,6};
            int16_t l_280 = 0x6D8D;
            uint16_t l_283 = 1U;
            int32_t l_295 = 0xA8B05D21;
            struct S0 l_318 = {1,20,6};
            int16_t l_391 = 0xD3C3;
            for (l_227 = 4; (l_227 >= (-3)); --l_227)
            { /* block id: 108 */
                struct S0 l_248 = {3,13,7};
                struct S0 l_252 = {-0,13,8};
                if (l_201)
                    break;
                if (p_50)
                { /* block id: 110 */
                    return p_50;
                }
                else
                { /* block id: 112 */
                    int16_t l_271 = (-1);
                    int32_t l_272 = 6;
                    int32_t l_273 = 0x146C4033;
                    if (((uint32_t)p_49 % (uint32_t)((int32_t)p_50 - (int32_t)l_220.f1)))
                    { /* block id: 113 */
                        l_249 = l_248;
                        l_250 = 0;
                        return l_227;
                    }
                    else
                    { /* block id: 117 */
                        l_252 = l_251;
                    }
                    l_273 = ((uint16_t)(-(int16_t)(((uint16_t)(((l_272 = (~func_75((((uint16_t)p_49 << (uint16_t)((int32_t)(((uint32_t)0x65B679A5 + (uint32_t)(((__builtin_popcount((l_220.f0 = func_92(((int16_t)p_49 + (int16_t)(l_252.f0 = 0x790D)), func_92(__builtin_ctz(l_249.f2), (0x40A9 == 0xD2C1), ((-(int32_t)((uint32_t)func_75((((!((((l_250 = 0x319B61A9) == 0xF25558BB) ^ p_49) != l_226)) != l_271) != l_271)) + (uint32_t)1U)) > l_271), p_50), l_271, l_271))) && 0xDFE2) ^ 0x2719CDBA) >= l_249.f1)) || p_49) - (int32_t)p_50)) && l_250)))) >= 0x5B4EDB8E) == l_271) + (uint16_t)(-1)) || l_248.f2)) >> (uint16_t)9);
                    l_249 = func_85(__builtin_ia32_crc32qi(p_50, (p_50 != ((int16_t)0xF0B8 - (int16_t)0xCEFB))), (l_280 = (((uint32_t)(((uint16_t)func_75(l_226) % (uint16_t)p_49) != 5U) - (uint32_t)l_273) && 1U)));
                }
            }
            if (((uint16_t)l_220.f0 >> (uint16_t)l_283))
            { /* block id: 129 */
                int16_t l_286 = 0xCAE2;
                int32_t l_292 = 0x5C35F3DD;
                int32_t l_293 = 0x5BE36780;
                int32_t l_294 = 0;
                l_296 = (l_220 = func_85(l_249.f1, ((((int32_t)l_286 - (int32_t)((l_295 = ((uint16_t)65532U << (uint16_t)((((((((uint16_t)p_49 + (uint16_t)(l_250 = (p_50 == func_77((func_92((l_293 = (4294967295U <= (l_292 = (p_50 && func_92(l_251.f2, l_250, l_291, p_50))))), p_49, l_251.f2, l_294) <= p_49), p_49, p_50)))) >= 65530U) == p_50) > p_50) & p_49) < p_50) > 4294967295U))) | p_49)) == l_202) != p_50)));
            }
            else
            { /* block id: 136 */
                struct S0 l_299 = {-0,10,7};
                struct S0 l_317 = {2,10,5};
                if (p_50)
                { /* block id: 137 */
                    struct S0 l_297 = {1,2,10};
                    struct S0 l_298 = {-3,5,10};
                    l_249 = l_249;
                    l_296.f0 = p_49;
                    l_297 = func_85(p_50, l_249.f1);
                    l_298 = l_296;
                }
                else
                { /* block id: 142 */
                    l_299 = l_251;
                }
                l_211 = ((((uint16_t)(p_50 > (__builtin_ffsll(l_220.f1) <= p_49)) << (uint16_t)12) || (l_241 = l_299.f0)) != p_49);
                for (l_280 = 0; (l_280 >= (-26)); l_280--)
                { /* block id: 149 */
                    int16_t l_306 = (-5);
                    if ((p_50 < ((l_306 = (((int16_t)__builtin_ffsl(p_49) >> (int16_t)15) < l_249.f2)) == l_249.f1)))
                    { /* block id: 151 */
                        struct S0 l_313 = {2,16,4};
                        if (p_50)
                            break;
                        l_227 = l_295;
                        l_313 = func_85(((l_250 = p_50) || ((uint16_t)__builtin_ctzll(((int16_t)(l_226 = ((uint16_t)p_49 << (uint16_t)14)) >> (int16_t)9)) >> (uint16_t)11)), l_306);
                    }
                    else
                    { /* block id: 157 */
                        int8_t l_314 = (-1);
                        l_249.f0 = (l_299.f1 > (l_220.f0 = (l_250 = (l_314 = l_306))));
                    }
                    if (p_50)
                        continue;
                    if (((l_315 && (p_49 && p_50)) | p_50))
                    { /* block id: 164 */
                        l_299 = l_251;
                        l_299.f0 = p_49;
                        l_317 = (l_299 = func_85(l_220.f0, (p_49 <= (!p_49))));
                    }
                    else
                    { /* block id: 169 */
                        l_295 = p_49;
                        l_318 = l_299;
                    }
                }
            }
            if (p_49)
            { /* block id: 175 */
                const int8_t l_319 = 0x5E;
                int32_t l_331 = 0;
                int32_t l_337 = 0;
                int8_t l_338 = 0x48;
                const struct S0 l_414 = {-3,11,10};
                struct S0 l_415 = {0,9,6};
                l_249.f0 = ((l_319 != ((uint16_t)(l_220.f1 | (((((((l_318.f0 = l_241) && (p_50 <= ((+l_319) & (0xB36C267D || ((l_295 = p_50) & (func_77(l_241, p_49, l_202) && l_226)))))) || p_50) & p_49) & l_241) >= p_50) ^ p_50)) - (uint16_t)0xF09F)) & 9U);
                for (l_280 = 0; (l_280 <= 8); l_280 += 7)
                { /* block id: 181 */
                    int32_t l_343 = (-1);
                    int32_t l_344 = 0xDCBFC918;
                    for (l_225 = (-3); (l_225 >= (-10)); --l_225)
                    { /* block id: 184 */
                        int8_t l_327 = 1;
                        struct S0 l_328 = {-3,15,6};
                        l_327 = 0x116017DD;
                        l_249 = l_328;
                    }
                    for (l_295 = (-11); (l_295 < (-25)); --l_295)
                    { /* block id: 190 */
                        uint32_t l_336 = 8U;
                        struct S0 l_345 = {-0,17,7};
                        l_337 = ((l_331 = 1) ^ ((int16_t)0 >> (int16_t)((int16_t)l_336 % (int16_t)p_49)));
                        l_345 = func_85((l_331 = (l_338 >= ((uint16_t)(l_226 = l_251.f0) + (uint16_t)p_50))), ((((p_49 || l_249.f1) && (l_249.f0 = (((int16_t)func_77(p_49, (l_343 = p_50), p_50) << (int16_t)p_49) != l_344))) || p_50) == p_50));
                        l_345 = (l_220 = l_318);
                    }
                    if (p_50)
                    { /* block id: 201 */
                        l_344 = p_49;
                        return l_343;
                    }
                    else
                    { /* block id: 204 */
                        uint32_t l_346 = 1U;
                        int32_t l_347 = (-1);
                        l_241 = __builtin_ia32_crc32qi((l_347 = l_346), l_251.f0);
                    }
                }
                l_295 = ((l_348 != (((uint16_t)(__builtin_ffs(l_249.f0) == (((l_337 = (func_75(func_77(p_49, (((func_77(func_75(l_220.f0), l_296.f0, ((uint16_t)(((uint16_t)((p_50 >= l_249.f1) != l_211) + (uint16_t)l_283) > 0U) % (uint16_t)l_202)) & l_331) == l_331) <= l_225), l_249.f0)) && l_296.f0)) >= (-1)) && l_319)) >> (uint16_t)2) >= 0x7BA11232)) & 8U);
                if (((((int32_t)((uint32_t)((+__builtin_popcountll((0x043C >= 0x2450))) >= l_249.f0) - (uint32_t)l_338) % (int32_t)((uint16_t)(l_250 = (l_227 = 0x9BF1)) % (uint16_t)p_49)) != ((l_331 = ((p_50 >= (-(int32_t)(__builtin_clz((p_49 ^ 0)) & 0U))) ^ p_50)) < l_201)) != 4294967286U))
                { /* block id: 214 */
                    int32_t l_366 = 0xAE8B5083;
                    if ((((int16_t)0 % (int16_t)p_49) > l_365))
                    { /* block id: 215 */
                        return p_49;
                    }
                    else
                    { /* block id: 217 */
                        return l_366;
                    }
                }
                else
                { /* block id: 220 */
                    int16_t l_381 = (-1);
                    struct S0 l_384 = {3,17,6};
                    struct S0 l_408 = {-2,8,7};
                    struct S0 l_413 = {-1,6,7};
                    if ((0x0BF49BC3 & (~l_337)))
                    { /* block id: 221 */
                        uint32_t l_383 = 0xCC45B127;
                        struct S0 l_385 = {-0,9,4};
                        l_227 = ((int16_t)(l_295 = l_365) << (int16_t)((1 <= (((-(int16_t)((int32_t)0xE3FB895A - (int32_t)((uint32_t)((uint32_t)(((uint16_t)__builtin_clz(p_49) << (uint16_t)l_338) != ((int16_t)(l_381 & ((-(uint16_t)(l_318.f0 = l_211)) != (((l_383 = (l_250 = l_381)) | 1U) ^ p_49))) << (int16_t)12)) - (uint32_t)0xFE08873C) + (uint32_t)p_50))) > p_50) >= p_49)) == p_50));
                        l_385 = l_384;
                        l_296.f0 = (-5);
                        l_202 = p_49;
                    }
                    else
                    { /* block id: 230 */
                        uint32_t l_388 = 4U;
                        l_296.f0 = (((uint16_t)(l_388 = l_319) << (uint16_t)(((uint16_t)p_49 << (uint16_t)7) == l_384.f2)) ^ l_391);
                        return l_384.f1;
                    }
                    l_337 = (((int32_t)((p_49 = ((uint32_t)(p_50 < (((l_250 || p_50) | func_65(l_249, l_319, (((int16_t)((uint16_t)((uint16_t)65535U >> (uint16_t)l_251.f0) >> (uint16_t)p_50) >> (int16_t)3) & (-5)))) & 7U)) + (uint32_t)0xADADFC2F)) >= l_319) % (int32_t)0xFF936EE2) <= l_331);
                    l_296.f0 = l_249.f2;
                    if (((uint16_t)p_49 % (uint16_t)p_49))
                    { /* block id: 238 */
                        struct S0 l_407 = {1,8,4};
                        l_384.f0 = (0x1DA4 || ((l_226 = p_50) && (func_75(p_50) & (((((l_220.f1 <= l_296.f0) || (l_249.f0 = ((int16_t)(0x2DF7147C >= l_291) - (int16_t)((p_50 | p_50) != l_319)))) != l_296.f2) ^ l_406) & p_50))));
                        l_408 = l_407;
                        l_337 = l_296.f0;
                        l_408.f0 = p_49;
                    }
                    else
                    { /* block id: 245 */
                        uint32_t l_409 = 1U;
                        struct S0 l_412 = {-1,2,5};
                        l_241 = (l_409 >= ((uint16_t)(0x487D3886 | p_50) << (uint16_t)3));
                        l_413 = l_412;
                        l_415 = l_414;
                    }
                }
            }
            else
            { /* block id: 251 */
                l_226 = (-1);
            }
            for (l_211 = 29; (l_211 <= (-28)); l_211 -= 9)
            { /* block id: 256 */
                return p_49;
            }
        }
        else
        { /* block id: 259 */
            struct S0 l_421 = {0,12,9};
            int8_t l_425 = 0x97;
            int32_t l_519 = 1;
            int32_t l_520 = (-1);
            int32_t l_521 = 0x894A5648;
            for (l_225 = 7; (l_225 == (-20)); l_225--)
            { /* block id: 262 */
                l_421 = l_420;
            }
            l_202 = ((((l_225 = ((p_49 & 0x354E) | ((l_425 = ((l_421.f0 = p_50) != (((l_422 = 0x13EE) == ((uint32_t)(4U & l_296.f2) % (uint32_t)l_226)) >= 0))) <= 0U))) ^ l_227) && p_49) <= l_249.f1);
            if (((uint16_t)__builtin_parityl(((int16_t)((uint32_t)(((uint32_t)(l_241 = (l_421.f1 < ((int16_t)func_92((0x16C9 < (!(l_226 >= (p_50 > func_92((0 == ((uint16_t)((~(4294967295U || (p_49 = p_49))) && (((int16_t)(p_49 < p_50) + (int16_t)l_220.f2) > p_50)) >> (uint16_t)6)), l_348, l_425, l_291))))), l_425, l_225, p_50) << (int16_t)l_348))) - (uint32_t)l_421.f1) && l_421.f1) - (uint32_t)0x9F4AD453) >> (int16_t)10)) >> (uint16_t)p_50))
            { /* block id: 272 */
                int32_t l_456 = (-1);
                for (l_422 = (-8); (l_422 >= 19); l_422 += 2)
                { /* block id: 275 */
                    int16_t l_444 = 4;
                    l_444 = (-1);
                    for (l_202 = 0; (l_202 == 21); l_202 += 4)
                    { /* block id: 279 */
                        int32_t l_455 = (-1);
                        l_211 = ((int16_t)0 >> (int16_t)(l_249.f0 = ((((int16_t)((0U >= p_49) | ((1 <= ((int32_t)(((p_50 == __builtin_clzll(l_444)) || __builtin_ctz((1U < ((int16_t)((0xEAEA2844 <= p_49) > l_421.f2) << (int16_t)l_444)))) < 0xF0B8) - (int32_t)l_421.f1)) || p_49)) << (int16_t)p_49) & 1U) != p_49)));
                        l_225 = ((p_49 = l_455) && ((__builtin_parityl(p_50) == l_444) && (l_220.f1 | l_456)));
                    }
                }
            }
            else
            { /* block id: 286 */
                struct S0 l_457 = {-2,11,3};
                int32_t l_461 = (-1);
                l_421 = l_457;
                if ((p_49 < (l_457.f2 > (((((int16_t)(p_50 >= func_65(l_420, l_296.f2, (l_457.f0 = l_457.f1))) >> (int16_t)(l_461 = (l_296.f0 = ((p_50 == (p_49 == l_460)) ^ p_49)))) && p_49) ^ l_420.f2) | l_421.f2))))
                { /* block id: 291 */
                    int16_t l_480 = 0x3642;
                    int32_t l_481 = 8;
                    for (l_226 = 0; (l_226 >= (-13)); l_226--)
                    { /* block id: 294 */
                        l_202 = ((((uint32_t)((uint16_t)(p_49 && p_50) >> (uint16_t)11) - (uint32_t)(l_211 = p_49)) | l_457.f2) | (func_65(l_421, (((uint16_t)p_49 + (uint16_t)(((int32_t)((uint16_t)((l_480 = ((int32_t)((int16_t)((int16_t)l_420.f0 << (int16_t)6) - (int16_t)((l_457.f0 != __builtin_clzll(l_420.f2)) | 1)) + (int32_t)p_50)) | l_457.f0) >> (uint16_t)4) % (int32_t)p_50) || l_249.f2)) <= 0x2800588C), l_481) > p_50));
                        l_481 = (l_420.f0 = (l_457.f1 ^ p_49));
                    }
                    for (l_481 = 0; (l_481 < 26); l_481 += 1)
                    { /* block id: 303 */
                        uint32_t l_489 = 1U;
                        int32_t l_494 = 0x358BECFD;
                        l_494 = (((uint16_t)l_421.f2 - (uint16_t)(((0xBC36 != (l_296.f0 = (!((int16_t)(((func_65(l_421, l_420.f1, (l_489 = __builtin_clzl(l_211))) >= ((uint32_t)((int16_t)l_220.f0 << (int16_t)l_421.f0) - (uint32_t)1U)) >= l_420.f2) & p_49) >> (int16_t)p_50)))) | l_457.f1) || 0x1324)) || p_50);
                        return p_49;
                    }
                }
                else
                { /* block id: 309 */
                    int32_t l_512 = 1;
                    int32_t l_526 = 8;
                    int32_t l_527 = 1;
                    for (l_460 = (-25); (l_460 != 5); l_460 += 5)
                    { /* block id: 312 */
                        l_296 = l_220;
                    }
                    if (p_49)
                    { /* block id: 315 */
                        uint16_t l_497 = 0x4B3F;
                        l_512 = ((l_460 >= (l_497 < ((uint16_t)((uint32_t)(l_421.f0 = (((int16_t)((func_65(l_220, (l_249.f0 = __builtin_ctzl(__builtin_popcountll(l_457.f0))), __builtin_bswap64(((0U != ((int32_t)(((uint16_t)((int16_t)0xD9BE + (int16_t)((uint16_t)l_497 + (uint16_t)l_421.f2)) + (uint16_t)6) == l_461) % (int32_t)(-1))) && p_49))) & 65530U) <= l_512) >> (int16_t)12) || p_50)) % (uint32_t)l_291) >> (uint16_t)l_461))) | l_457.f1);
                        l_457.f0 = func_65(l_421, l_457.f2, l_457.f1);
                        l_521 = ((uint32_t)4294967295U + (uint32_t)((l_520 = (__builtin_ctz(l_425) < ((l_421.f0 = 0xE1EB) < ((l_519 = (((uint32_t)(p_50 <= (__builtin_ctzll(p_50) != (p_50 || (65533U <= l_348)))) + (uint32_t)l_497) != p_49)) <= 0x471B)))) != l_457.f2));
                    }
                    else
                    { /* block id: 324 */
                        struct S0 l_525 = {3,10,6};
                        l_457.f0 = ((int32_t)p_49 % (int32_t)6U);
                        l_524 = p_49;
                        l_421 = l_525;
                    }
                    l_519 = __builtin_parityll(p_49);
                    l_527 = (l_457.f0 = (l_526 = (4294967295U && (l_512 = p_49))));
                }
                return l_421.f1;
            }
        }
        l_296 = l_249;
        if ((l_422 ^ (((l_528 != l_249.f0) & ((int16_t)((0x7ABB > (((l_296.f0 = ((int32_t)0x78B14E0B % (int32_t)l_202)) || (p_49 == p_50)) && (l_211 = (p_50 != p_49)))) >= 0) >> (int16_t)3)) | l_241)))
        { /* block id: 341 */
            struct S0 l_535 = {0,1,10};
            l_249 = func_85((l_533 && (l_225 = ((p_50 < (((l_220.f0 = (__builtin_parity(p_49) == p_50)) <= (l_241 = p_49)) != (l_202 <= (p_49 & p_50)))) | l_534))), p_49);
            l_535 = l_535;
        }
        else
        { /* block id: 347 */
            struct S0 l_536 = {3,11,3};
            l_536 = func_85(l_220.f1, p_49);
            return l_536.f1;
        }
    }
    else
    { /* block id: 351 */
        int32_t l_538 = (-9);
        l_537 = (-6);
        l_538 = __builtin_parity((l_220.f0 = (l_220.f0 | (p_49 && (l_296.f0 = func_75(func_65(l_220, p_49, l_296.f2)))))));
    }
    for (l_528 = 0; (l_528 != (-6)); l_528 -= 2)
    { /* block id: 359 */
        const uint32_t l_541 = 0xB2D08BC0;
        l_296.f0 = (2U != l_541);
        if (l_220.f0)
            break;
    }
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_65(struct S0  p_66, uint32_t  p_67, int16_t  p_68)
{ /* block id: 83 */
    uint32_t l_198 = 4294967286U;
    int32_t l_199 = 4;
    l_199 = ((uint16_t)l_198 + (uint16_t)p_68);
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_75(uint16_t  p_76)
{ /* block id: 38 */
    uint32_t l_81 = 4294967295U;
    int32_t l_83 = 0x169B2B29;
    struct S0 l_84 = {-0,20,2};
    l_83 = func_77(l_81, l_81, l_81);
    l_84 = l_84;
    l_84 = func_85((__builtin_ctz(((int16_t)func_77((l_84.f0 = ((int32_t)func_92((func_77(((int16_t)p_76 << (int16_t)5), (((uint16_t)(p_76 == (func_77(((uint32_t)func_77(l_84.f1, l_84.f2, ((int16_t)p_76 << (int16_t)3)) % (uint32_t)((int16_t)__builtin_parity(p_76) % (int16_t)l_84.f2)), l_84.f0, l_84.f0) && 4294967295U)) + (uint16_t)p_76) < l_83), l_83) && l_83), l_84.f0, p_76, l_84.f2) % (int32_t)0x7D5F2590)), p_76, p_76) >> (int16_t)8)) != p_76), l_84.f2);
    return l_84.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_77(uint32_t  p_78, uint32_t  p_79, uint32_t  p_80)
{ /* block id: 39 */
    int16_t l_82 = 1;
    return l_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_85(int8_t  p_86, int32_t  p_87)
{ /* block id: 52 */
    int32_t l_131 = 0x85881B6A;
    int32_t l_132 = 0xD91AC48A;
    const uint32_t l_135 = 0xA6105BDF;
    uint32_t l_136 = 0xD9B7196F;
    int32_t l_137 = 0x8C809647;
    int32_t l_138 = 0x27851ED0;
    uint16_t l_192 = 0U;
    int32_t l_193 = 0xF3C1E06D;
    int32_t l_194 = 1;
    const struct S0 l_195 = {2,15,0};
    p_87 = (0 < 0x4DC1);
    if (((uint16_t)((uint16_t)((65532U == p_87) > 0x4CE2787F) - (uint16_t)(l_132 = (l_131 <= l_131))) >> (uint16_t)(l_138 = (((p_87 > ((uint16_t)l_135 >> (uint16_t)(l_137 = l_136))) < l_135) < p_87))))
    { /* block id: 57 */
        int16_t l_142 = 0x249A;
        int32_t l_143 = 0x83892296;
        l_142 = (p_87 = ((int32_t)(-10) - (int32_t)(-(uint16_t)l_131)));
        l_143 = l_135;
    }
    else
    { /* block id: 61 */
        int8_t l_153 = 0;
        for (p_87 = 11; (p_87 <= 15); p_87 += 6)
        { /* block id: 64 */
            int16_t l_150 = 0xC4DD;
            int32_t l_154 = (-1);
            for (l_138 = (-22); (l_138 != (-4)); l_138 += 2)
            { /* block id: 67 */
                l_154 = ((int32_t)l_150 + (int32_t)(((int32_t)(-1) % (int32_t)1U) > l_153));
            }
        }
    }
    l_138 = ((uint32_t)p_86 - (uint32_t)(6 > ((uint16_t)(((l_136 < 4294967295U) != ((int16_t)((((p_87 = l_136) ^ ((int16_t)(0x4C23B8D9 == ((int16_t)p_86 - (int16_t)((int16_t)(+((int16_t)((int16_t)0x857E << (int16_t)(l_137 ^ l_138)) << (int16_t)7)) + (int16_t)l_132))) - (int16_t)l_135)) == l_131) ^ 0x6189) << (int16_t)p_86)) ^ l_136) >> (uint16_t)p_86)));
    l_194 = func_77(((uint16_t)(p_86 | (!((uint32_t)((int16_t)0x531C + (int16_t)p_86) - (uint32_t)(p_87 = (l_131 | ((uint16_t)(((((uint16_t)((l_193 = ((uint16_t)(l_137 = (l_135 & (((uint16_t)(l_132 = (l_138 = (p_86 | ((+((int16_t)p_86 - (int16_t)((uint16_t)(l_138 <= l_137) << (uint16_t)11))) && l_192)))) << (uint16_t)l_136) <= l_135))) >> (uint16_t)13)) || p_86) >> (uint16_t)p_86) >= l_135) && l_137) < p_86) << (uint16_t)l_136)))))) >> (uint16_t)4), p_86, p_86);
    return l_195;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_92(int16_t  p_93, uint32_t  p_94, uint16_t  p_95, uint32_t  p_96)
{ /* block id: 43 */
    uint16_t l_113 = 8U;
    int8_t l_118 = 1;
    int32_t l_119 = (-1);
    int32_t l_120 = 0x6FCAC8A3;
    int32_t l_121 = (-1);
    int32_t l_126 = 0xAA660014;
    l_121 = ((int16_t)((uint16_t)(((uint32_t)(p_96 = func_77(p_95, l_113, func_77(p_94, ((p_96 <= (p_96 || ((((int16_t)((uint16_t)(((func_77(((l_119 = (p_95 ^ l_118)) == (l_113 || (((l_120 = l_113) == 0x3D4B) >= (-8)))), l_113, l_113) != p_96) || p_95) & p_94) >> (uint16_t)15) << (int16_t)14) != 0xD4E4AF0E) && l_120))) <= l_118), p_94))) + (uint32_t)1) > 0xE133A9B9) - (uint16_t)7U) << (int16_t)p_95);
    l_121 = ((l_126 = (((int32_t)((func_77(p_96, func_77(p_94, l_121, (l_118 != ((int16_t)p_96 << (int16_t)12))), l_118) ^ ((func_77(p_95, p_94, p_94) & 1U) && 0xCDCA)) == l_126) - (int32_t)p_93) < p_96)) & p_96);
    return l_118;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 113
   depth: 1, occurrence: 33
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 33
XXX full-bitfields structs in the program: 33
breakdown:
   indirect level: 0, occurrence: 33
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 35
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 35
XXX times a single bitfield on RHS: 90

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 159
   depth: 2, occurrence: 24
   depth: 3, occurrence: 7
   depth: 4, occurrence: 6
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 4
   depth: 17, occurrence: 4
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 3
   depth: 32, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 38, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 595
XXX times a non-volatile is write: 206
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 152
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 15
   depth: 2, occurrence: 12
   depth: 3, occurrence: 18
   depth: 4, occurrence: 28
   depth: 5, occurrence: 49

XXX percentage a fresh-made variable is used: 18.5
XXX percentage an existing variable is used: 81.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

