/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1079043726
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint64_t  f0;
   float  f1;
   uint16_t  f2;
   int32_t  f3;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int32_t  f0;
   int16_t  f1;
   uint64_t  f2;
   uint64_t  f3;
   uint64_t  f4;
   int32_t  f5;
   uint32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_31(void);
static int32_t * func_32(int32_t  p_33);
static uint32_t  func_61(uint64_t * p_62, uint16_t  p_63, int64_t  p_64, int16_t * p_65);
static int32_t  func_82(struct S0  p_83, int64_t  p_84);
static struct S0  func_85(uint32_t  p_86, int32_t  p_87, uint8_t  p_88);
static int16_t  func_91(struct S1  p_92, float  p_93, int32_t ** p_94);
static int32_t ** func_96(uint64_t * p_97, int64_t  p_98, uint32_t  p_99);
static uint64_t * func_100(uint64_t  p_101, int32_t * p_102);
static float  func_103(int16_t * p_104, struct S1  p_105, struct S0  p_106, int16_t  p_107, int16_t  p_108);
static int16_t * func_109(int32_t  p_110, uint8_t  p_111, uint64_t * p_112, int32_t * p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_31(void)
{ /* block id: 36 */
    uint8_t l_34 = 253UL;
    int32_t l_56 = 0xDE082ADEL;
    int32_t *l_55 = &l_56;
    int32_t **l_54 = &l_55;
    uint64_t l_67 = 0x4D083830386B9BDDLL;
    uint64_t *l_66 = &l_67;
    uint64_t **l_68 = (void*)0;
    uint64_t **l_69 = (void*)0;
    uint64_t **l_70 = &l_66;
    float l_73 = 0x5.88F3C2p-34;
    int64_t *l_74 = (void*)0;
    int64_t l_76 = 0xD830BF04B2B3A3C3LL;
    int64_t *l_75 = &l_76;
    int16_t l_81 = 0x0294L;
    int16_t *l_80 = &l_81;
    struct S0 l_801 = {18446744073709551615UL,0xA.8D67F7p-22,5UL,0x2D028522L};
    int64_t l_807 = 0x49BF470DE1BC5116LL;
    struct S1 l_823 = {0x66EECFE3L,0x10D2L,0x74CB91FC3ED77D5DLL,2UL,0x7D94E81F991CD422LL,0x17BF5A3FL,1UL};
    uint8_t *l_829 = (void*)0;
    uint8_t **l_828 = &l_829;
    (*l_54) = func_32(l_34);
    /* statement id: 45 */
    assert (l_55 == 0);
    if (((((uint32_t)(l_56 <= 0xB2C3CC8CL) + (uint32_t)l_56) >= (((l_54 = &l_55) != &l_55) | func_61(((*l_70) = l_66), ((int64_t)((*l_75) = l_56) + (int64_t)(((!65535UL) | ((int32_t)(((l_67 == l_34) < l_56) && l_34) + (int32_t)0xA00AF408L)) | l_67)), l_34, l_80))) > 0L))
    { /* block id: 475 */
        int32_t l_783 = (-10L);
        struct S1 l_786 = {0xB25A617BL,0x92FFL,0x1C92669966DB137CLL,0UL,1UL,0xA257AFDEL,1UL};
        uint32_t l_796 = 9UL;
        l_783 = l_783;
        for (l_76 = 0; (l_76 >= (-26)); l_76 -= 4)
        { /* block id: 479 */
            int16_t *l_789 = &l_786.f1;
            struct S1 l_790 = {0x6B81357AL,0x4DBFL,18446744073709551615UL,0xFC002D30A7CB3A03LL,1UL,7L,0x09039198L};
            struct S0 l_791 = {0xE2B87971FD9DE76CLL,0x7.Cp+1,0x6B98L,-1L};
            uint16_t l_795 = 0x98CDL;
            uint16_t *l_794 = &l_795;
            float *l_797 = (void*)0;
            float *l_798 = &l_73;
            l_783 = 0x4.79F779p-52;
            l_786 = l_786;
            (*l_798) = (((float)func_103(l_789, l_790, l_791, (((*l_789) = l_786.f2) ^ (l_34 || (((uint16_t)l_786.f0 >> (uint16_t)l_796) >= l_786.f0))), l_786.f0) / (float)0x2.DB49C5p+59) <= l_786.f0);
        }
        (*l_54) = &l_783;
        /* statement id: 486 */
        assert (l_55 == &l_783);
    }
    else
    { /* block id: 487 */
        uint32_t l_799 = 0x42F2383BL;
        int32_t *l_800 = &l_56;
        int32_t l_810 = 0x140D3B7BL;
        int32_t *l_809 = &l_810;
        uint32_t *l_812 = &l_799;
        struct S0 *l_813 = &l_801;
        (*l_800) = l_799;
        if ((func_82(l_801, ((uint16_t)((uint16_t)((+(((void*)0 != l_800) | l_807)) >= (*l_800)) >> (uint16_t)3) << (uint16_t)5)) != ((*l_800) & (~((*l_812) = (((*l_809) = (*l_800)) & (+(*l_800))))))))
        { /* block id: 491 */
            struct S0 **l_814 = &l_813;
            (*l_814) = l_813;
        }
        else
        { /* block id: 493 */
            uint32_t l_819 = 4294967295UL;
            float *l_820 = &l_801.f1;
            (*l_820) = ((float)((float)l_819 * (float)(*l_809)) * (float)(*l_809));
            for (l_67 = 0; (l_67 == 32); l_67++)
            { /* block id: 497 */
                if ((*l_800))
                    break;
                if (l_819)
                    continue;
            }
        }
        return l_823;
    }
    /* facts after branching */
    //assert (l_55 == dangling);
    for (l_56 = 2; (l_56 != 2); l_56 += 9)
    { /* block id: 506 */
        float l_826 = 0x5.6B9E78p+15;
        int32_t l_827 = 0x4F517A73L;
        uint8_t ***l_830 = &l_828;
        if (l_827)
            break;
        (*l_830) = l_828;
    }
    return l_823;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_32(int32_t  p_33)
{ /* block id: 37 */
    uint32_t l_41 = 0x07E294B5L;
    int32_t l_42 = 0xE5A82A6FL;
    int16_t l_46 = 3L;
    int16_t *l_45 = &l_46;
    uint64_t *l_47 = (void*)0;
    uint64_t l_49 = 0x9B45C761B8CE2295LL;
    uint64_t *l_48 = &l_49;
    int32_t l_51 = 1L;
    int32_t *l_50 = &l_51;
    int32_t *l_52 = &l_51;
    int32_t *l_53 = (void*)0;
    (*l_50) = ((((int16_t)__builtin_popcount(((uint16_t)p_33 * (uint16_t)((((uint64_t)((l_42 = l_41) <= ((*l_45) = (((uint16_t)0xED14L >> (uint16_t)6) <= l_41))) + (uint64_t)l_41) || (l_42 = __builtin_clzll(((*l_48) = 18446744073709551606UL)))) >= ((*l_50) = p_33)))) >> (int16_t)l_41) <= (-8L)) ^ 0x3883FAA058A13C44LL);
    return l_53;
    /* statement id: 44 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_61(uint64_t * p_62, uint16_t  p_63, int64_t  p_64, int16_t * p_65)
{ /* block id: 49 */
    struct S1 l_95 = {0xC80F86AEL,0xBDD5L,0x9FE4D3D82F88197CLL,0x1C8BDC662BFFD659LL,0xA02B236EDAE8E356LL,1L,0UL};
    uint32_t l_263 = 0UL;
    int32_t *l_777 = &l_95.f5;
    struct S0 l_779 = {1UL,0x1.5p-1,0UL,0x3EFDEC61L};
    struct S0 *l_778 = &l_779;
    struct S0 **l_780 = (void*)0;
    struct S0 **l_781 = (void*)0;
    struct S0 **l_782 = &l_778;
    (*l_777) = ((func_82(func_85(((int16_t)(func_91(l_95, l_95.f6, func_96(func_100((*p_62), func_32(l_95.f5)), (l_95.f5 >= (&p_64 == (void*)0)), p_63)) < l_95.f4) / (int16_t)l_263), l_95.f0, l_95.f2), l_95.f2) == 0x3F3EA73BL) | l_263);
    (*l_782) = l_778;
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_82(struct S0  p_83, int64_t  p_84)
{ /* block id: 290 */
    int16_t l_518 = 0x5FB2L;
    struct S1 l_519 = {9L,0x57F1L,0x3C8516E9539AAE6CLL,0x8A5D5689A9F81F46LL,0x8C9231B19A32693ALL,8L,0xD18B912BL};
    uint64_t *l_527 = &l_519.f2;
    uint64_t **l_526 = &l_527;
    int32_t **l_546 = (void*)0;
    int32_t ***l_545 = &l_546;
    int32_t l_574 = (-1L);
    float l_613 = 0x2.926B2Cp+27;
    float *l_612 = &l_613;
    uint64_t **l_662 = &l_527;
    int16_t l_707 = 0L;
    int32_t l_714 = 0x1A511F7DL;
    float l_758 = 0x4.5p-1;
    float **l_761 = (void*)0;
    float ***l_760 = &l_761;
    float ****l_759 = &l_760;
    int32_t *l_768 = &l_714;
    int32_t **l_767 = &l_768;
    struct S0 *l_775 = (void*)0;
    if (p_83.f2)
    { /* block id: 291 */
        struct S1 *l_520 = &l_519;
        struct S1 l_522 = {0x088D73E6L,1L,0xE5BECB55503377F6LL,0x0C2E72DC9ADC35C4LL,0x650F0EF7A1B80968LL,5L,4294967295UL};
        struct S1 *l_521 = &l_522;
        int32_t l_524 = 0L;
        int32_t *l_523 = &l_524;
        int16_t *l_525 = &l_519.f1;
        uint64_t **l_529 = &l_527;
        struct S0 **l_534 = (void*)0;
        struct S0 ***l_533 = &l_534;
        struct S0 ****l_532 = &l_533;
        uint16_t l_560 = 0x60DEL;
        uint32_t l_587 = 0x6A9AADA1L;
        int16_t *l_624 = &l_518;
        struct S0 l_681 = {18446744073709551615UL,0xC.134C11p+93,65526UL,0L};
        float **l_687 = (void*)0;
        uint16_t *l_756 = (void*)0;
        uint16_t **l_755 = &l_756;
        uint16_t ***l_754 = &l_755;
        if (((uint64_t)((((*l_523) = ((uint16_t)__builtin_ctz(((int16_t)(!(4294967292UL != (((uint16_t)((int16_t)(l_518 > 1UL) >> (int16_t)15) / (uint16_t)p_83.f0) > ((*l_525) = func_91(((*l_521) = ((*l_520) = l_519)), p_83.f3, func_96(func_100(l_518, l_523), l_518, l_518)))))) % (int16_t)l_518)) - (uint16_t)p_83.f2)) || l_519.f0) && (-3L)) % (uint64_t)p_83.f0))
        { /* block id: 296 */
            uint64_t ***l_528 = &l_526;
            int32_t l_531 = (-6L);
            uint32_t l_594 = 0x0FA8E425L;
            struct S0 ****l_648 = (void*)0;
            (*l_523) = (((*l_528) = l_526) != l_529);
            if ((l_531 = (-(int64_t)(p_83.f0 | (-1L)))))
            { /* block id: 300 */
                struct S0 *****l_535 = &l_532;
                uint16_t l_538 = 0x0932L;
                int32_t l_539 = 3L;
                int16_t l_549 = 0xEC75L;
                struct S0 ***l_557 = &l_534;
                struct S0 ****l_556 = &l_557;
                struct S0 ***l_559 = &l_534;
                struct S0 ****l_558 = &l_559;
                (*l_535) = l_532;
                if (((uint64_t)l_538 - (uint64_t)l_539))
                { /* block id: 302 */
                    int32_t **l_541 = &l_523;
                    int32_t ***l_540 = &l_541;
                    int32_t ****l_542 = &l_540;
                    int32_t ***l_544 = &l_541;
                    int32_t ****l_543 = &l_544;
                    (**l_541) = (l_539 = (l_539 || (((*l_543) = ((*l_542) = l_540)) != l_545)));
                    for (l_539 = 0; (l_539 <= 25); l_539 += 6)
                    { /* block id: 309 */
                        float *l_550 = (void*)0;
                        float *l_551 = (void*)0;
                        float l_553 = 0x1.40E2B8p+24;
                        float *l_552 = &l_553;
                        (*l_552) = l_549;
                    }
                }
                else
                { /* block id: 312 */
                    p_83.f1 = (-0x1.Ap-1);
                }
                if ((((((*l_532) == ((*l_558) = ((*l_556) = (**l_535)))) == l_560) ^ (((void*)0 == (**l_535)) >= ((-(int16_t)p_83.f2) <= p_84))) || (l_549 || ((int16_t)((int64_t)(((p_84 <= p_83.f2) & 0xA20FL) > l_549) / (int64_t)l_531) * (int16_t)(-1L)))))
                { /* block id: 317 */
                    for (l_518 = 7; (l_518 >= (-26)); l_518 -= 1)
                    { /* block id: 320 */
                        int32_t **l_568 = (void*)0;
                        int32_t **l_569 = &l_523;
                        (*l_569) = &l_531;
                        /* statement id: 321 */
                        assert (l_523 == &l_531);
                        return p_83.f2;
                    }
                    for (l_524 = 0; (l_524 == (-21)); l_524 -= 9)
                    { /* block id: 326 */
                        int64_t l_572 = (-9L);
                        int32_t *l_573 = &l_522.f5;
                        (*l_573) = l_572;
                        return l_574;
                    }
                }
                else
                { /* block id: 330 */
                    float l_576 = 0x0.99BD33p+24;
                    float *l_575 = &l_576;
                    (*l_575) = (-0x3.3p-1);
                }
            }
            else
            { /* block id: 333 */
                int32_t *l_580 = &l_519.f5;
                uint64_t **l_609 = &l_527;
                struct S1 **l_645 = &l_521;
                uint16_t l_650 = 65533UL;
                if (func_91((*l_520), l_531, (*l_545)))
                { /* block id: 334 */
                    int32_t *l_577 = &l_522.f0;
                    int32_t **l_578 = (void*)0;
                    int32_t **l_579 = &l_577;
                    (*l_579) = (l_523 = l_577);
                    /* statement id: 336 */
                    assert (l_523 == &l_522.f0);
                    (*l_579) = l_580;
                    /* statement id: 337 */
                    assert (l_577 == &l_519.f5);
                }
                else
                { /* block id: 338 */
                    int64_t l_625 = (-10L);
                    uint16_t l_628 = 0UL;
                    int32_t *l_647 = &l_522.f5;
                    uint64_t **l_663 = (void*)0;
                    if (((uint32_t)(p_83.f0 & 0x93536BCEL) - (uint32_t)((int32_t)(((int16_t)__builtin_bswap32(p_84) << (int16_t)p_83.f3) == ((*l_580) = (l_587 == ((int64_t)((int16_t)0x6EA7L >> (int16_t)13) - (int64_t)((uint16_t)l_594 - (uint16_t)((__builtin_ctzl(((int16_t)((uint16_t)((int16_t)0x9B02L >> (int16_t)2) + (uint16_t)(*l_580)) >> (int16_t)p_83.f2)) ^ 0xDFDBE9A7L) < 0L)))))) % (int32_t)p_83.f3)))
                    { /* block id: 340 */
                        struct S1 l_608 = {0L,0xB487L,0UL,0x2A16CD0FC8B0E8EDLL,7UL,0x81DD5B37L,6UL};
                        float l_611 = 0x3.Bp+1;
                        float *l_610 = &l_611;
                        int64_t *l_614 = (void*)0;
                        int64_t l_616 = 0xF9A3E13CB002531CLL;
                        int64_t *l_615 = &l_616;
                        l_523 = func_32(((*l_580) = ((uint16_t)((int16_t)(!((int64_t)p_83.f2 + (int64_t)func_91(l_608, ((*l_610) = (l_609 != l_609)), ((*l_545) = func_96(func_100(p_84, &l_524), ((*l_615) = (l_531 <= (l_612 != (void*)0))), (*l_523)))))) << (int16_t)p_83.f0) >> (uint16_t)p_83.f3)));
                        /* statement id: 345 */
                        assert (l_523 == 0);
                    }
                    else
                    { /* block id: 346 */
                        struct S1 **l_617 = &l_520;
                        int32_t l_621 = 2L;
                        (*l_617) = &l_522;
                        /* statement id: 347 */
                        assert (l_520 == &l_522);
                        (*l_523) = (p_84 <= (-(int32_t)(((uint16_t)(((*l_580) ^ p_84) && l_621) * (uint16_t)l_531) > ((l_625 = (((int16_t)((*l_525) = (-1L)) * (int16_t)p_83.f3) ^ ((void*)0 != l_624))) <= p_83.f0))));
                        p_83.f1 = p_83.f0;
                    }
                    /* facts after branching */
                    assert (l_520 == &l_522 || l_520 == &l_519);
                    assert (l_523 == &l_524 || l_523 == 0);
                    if ((0x8A6BBF6E1E6CCFD9LL && ((((int16_t)l_628 << (int16_t)8) > l_594) & p_83.f2)))
                    { /* block id: 353 */
                        uint32_t *l_639 = &l_522.f6;
                        uint64_t ***l_642 = (void*)0;
                        uint64_t **l_643 = &l_527;
                        int32_t l_644 = 0xD64C9FE9L;
                        uint32_t *l_646 = &l_587;
                        struct S0 *****l_649 = &l_648;
                        uint8_t l_652 = 0xF6L;
                        uint8_t *l_651 = &l_652;
                        struct S0 *l_653 = (void*)0;
                        struct S0 *l_654 = (void*)0;
                        struct S0 l_656 = {1UL,0x1.7E7B2Cp+18,0x9243L,0L};
                        struct S0 *l_655 = &l_656;
                        l_647 = func_32((((((int16_t)((uint64_t)((int16_t)((int64_t)(p_83.f2 == ((*l_639) = ((int64_t)(*l_580) - (int64_t)(-2L)))) % (int64_t)((uint16_t)(((&l_587 != &l_587) != ((*l_528) != (l_643 = (void*)0))) <= (((((*l_646) = (l_644 == (p_84 = (&l_520 != l_645)))) || 4294967292UL) || l_594) & l_644)) >> (uint16_t)12)) >> (int16_t)8) + (uint64_t)(-1L)) * (int16_t)p_83.f3) <= p_83.f3) < p_83.f0) & (-1L)));
                        /* statement id: 358 */
                        assert (l_643 == 0);
                        assert (l_647 == 0);
                        (*l_649) = l_648;
                        (*l_580) = p_83.f0;
                        (*l_655) = func_85(p_83.f2, func_91(l_519, p_83.f1, func_96((**l_528), l_650, ((*l_646) = 8UL))), ((*l_651) = p_84));
                    }
                    else
                    { /* block id: 364 */
                        int32_t l_657 = 0xE7296D86L;
                        uint16_t *l_667 = &l_560;
                        int64_t *l_668 = &l_625;
                        uint16_t *l_669 = &l_628;
                        (*l_580) = (l_657 || (((uint16_t)((*l_669) = ((((uint16_t)p_84 << (uint16_t)(p_84 > (((*l_528) = l_662) == l_663))) & (p_83.f2 ^ (__builtin_clzll((*l_647)) || ((!((*l_668) = (((*l_667) = ((uint16_t)(((l_657 <= p_83.f3) >= p_83.f2) | 0L) << (uint16_t)5)) < p_83.f3))) || p_84)))) & 7L)) >> (uint16_t)p_83.f2) && p_84));
                        (*l_612) = (((float)(func_91(l_519, p_83.f1, &l_523) < p_84) + (float)p_83.f2) == l_594);
                    }
                    /* facts after branching */
                    assert (l_647 == &l_522.f5 || l_647 == 0);
                    l_519.f5 = 0x5E97BEEAL;
                }
                /* facts after branching */
                assert (l_520 == &l_522 || l_520 == &l_519);
                assert (l_523 == &l_524 || l_523 == 0 || l_523 == &l_522.f0);
                return p_83.f0;
            }
        }
        else
        { /* block id: 376 */
            float **l_674 = &l_612;
            float ***l_675 = &l_674;
            float l_677 = 0x1.C50847p-18;
            float *l_676 = &l_677;
            (*l_612) = p_84;
            (*l_676) = ((float)((*l_612) = (*l_523)) / (float)(((*l_675) = l_674) != (void*)0));
            (***l_675) = (*l_523);
            for (l_519.f5 = 0; (l_519.f5 > (-29)); l_519.f5 -= 1)
            { /* block id: 384 */
                int32_t l_680 = 0x61CDA296L;
                (*l_523) = l_680;
                return p_83.f0;
            }
        }
        l_681 = p_83;
        for (l_681.f3 = 0; (l_681.f3 != 13); l_681.f3++)
        { /* block id: 392 */
            int16_t *l_686 = &l_519.f1;
            int32_t l_690 = 0L;
            int32_t **l_691 = &l_523;
            int32_t *l_693 = &l_524;
            int32_t **l_692 = &l_693;
            struct S1 l_700 = {0x37D9C39BL,0x0308L,18446744073709551615UL,7UL,0xB19B3352BB03DB8FLL,-6L,0xE2BF1E73L};
            struct S0 l_723 = {0x6117C123EA1DD0F0LL,0x0.Dp+1,0xFCDBL,0x0937537CL};
            float ***l_753 = &l_687;
            float *****l_762 = (void*)0;
            float *****l_763 = &l_759;
        }
    }
    else
    { /* block id: 453 */
        int32_t *l_764 = &l_519.f5;
        int32_t **l_765 = &l_764;
        int32_t l_766 = (-2L);
        l_764 = l_764;
        (*l_765) = func_32(p_83.f2);
        /* statement id: 455 */
        assert (l_764 == 0);
        (*l_765) = (void*)0;
        l_766 = p_84;
    }
    (*l_767) = (void*)0;
    /* statement id: 459 */
    assert (l_768 == 0);
    for (l_574 = 0; (l_574 > (-4)); l_574 -= 2)
    { /* block id: 462 */
        float l_771 = 0x5.1B38F8p+8;
        int32_t l_772 = 1L;
        if ((l_772 = p_83.f0))
        { /* block id: 464 */
            struct S1 *l_774 = &l_519;
            struct S1 **l_773 = &l_774;
            (*l_773) = &l_519;
        }
        else
        { /* block id: 466 */
            struct S0 **l_776 = &l_775;
            (*l_776) = l_775;
        }
    }
    (*l_767) = func_32(p_84);
    return p_83.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_85(uint32_t  p_86, int32_t  p_87, uint8_t  p_88)
{ /* block id: 128 */
    struct S0 l_265 = {0UL,0x7.3p+1,1UL,0x676FA98CL};
    struct S0 *l_264 = &l_265;
    struct S0 **l_266 = &l_264;
    struct S1 l_267 = {-8L,3L,0UL,0x066F46DC24EEE4FCLL,3UL,0xFF06D840L,0x34515C62L};
    struct S1 *l_268 = &l_267;
    int32_t *l_316 = &l_267.f5;
    int32_t **l_315 = &l_316;
    struct S1 **l_454 = (void*)0;
    uint16_t *l_496 = &l_265.f2;
    struct S0 l_506 = {18446744073709551615UL,0x0.8p-1,0xD119L,0x8866D5E7L};
    (*l_266) = l_264;
    (*l_268) = l_267;
    if ((p_86 == p_88))
    { /* block id: 131 */
        float ***l_271 = (void*)0;
        int32_t l_272 = 0L;
        int32_t l_275 = (-1L);
        float *l_276 = &l_265.f1;
        float l_278 = 0x0.BCDBC6p+78;
        float *l_277 = &l_278;
        int32_t *l_302 = &l_267.f5;
        int32_t **l_301 = &l_302;
        uint64_t *l_310 = (void*)0;
        uint64_t **l_309 = &l_310;
        struct S0 l_364 = {0x37453C66BB1736FFLL,0x1.2p+1,0x308FL,3L};
        (*l_277) = (((float)l_265.f3 + (float)((l_271 == (void*)0) >= l_265.f2)) > ((*l_276) = (l_272 >= ((((float)(l_275 = p_87) + (float)l_272) > p_86) >= l_267.f6))));
        if (l_275)
        { /* block id: 135 */
            int32_t *l_279 = &l_272;
            int32_t **l_280 = &l_279;
            struct S1 *l_281 = (void*)0;
            struct S0 **l_290 = &l_264;
            int32_t *l_295 = &l_267.f0;
            uint16_t l_306 = 65534UL;
            uint64_t **l_312 = &l_310;
            l_272 = l_275;
            (*l_280) = l_279;
            if (p_87)
            { /* block id: 138 */
                l_281 = (void*)0;
            }
            else
            { /* block id: 140 */
                uint64_t l_293 = 18446744073709551615UL;
                int32_t l_294 = 0xE2548D48L;
                (**l_280) = ((float)((((l_267.f5 = ((*l_276) = ((float)p_86 + (float)l_265.f3))) == (((((((float)l_272 + (float)((float)__builtin_bswap32(p_86) - (float)(l_275 = ((l_290 = (void*)0) == (void*)0)))) < ((float)(l_293 = p_88) + (float)(((*l_277) = l_294) == 0x0.8p-1))) != p_86) <= l_294) != 0x0.3p-1) != l_294)) >= 0xC.8A7AC5p+53) > (*l_279)) - (float)(-0x1.2p+1));
                /* statement id: 147 */
                assert (l_290 == 0);
                (*l_280) = l_295;
                /* statement id: 148 */
                assert (l_279 == &l_267.f0);
            }
            /* facts after branching */
            assert (l_279 == &l_267.f0 || l_279 == &l_272);
            assert (l_290 == 0 || l_290 == &l_264);
            if (p_88)
            { /* block id: 150 */
                struct S1 l_300 = {-2L,1L,0xB16B5456AB6247F7LL,18446744073709551611UL,18446744073709551615UL,1L,4294967294UL};
                uint64_t ***l_311 = &l_309;
                int32_t ***l_317 = (void*)0;
                int32_t ***l_318 = &l_301;
                (*l_302) = ((uint16_t)(((uint16_t)func_91(l_300, l_275, l_301) << (uint16_t)12) <= (*l_279)) * (uint16_t)((int64_t)(~p_87) % (int64_t)l_306));
                if ((((int16_t)(((*l_311) = l_309) == l_312) - (int16_t)p_87) != (((uint16_t)(func_91(l_300, (*l_295), (l_280 = ((*l_318) = l_315))) && ((int16_t)p_86 * (int16_t)(**l_280))) + (uint16_t)(*l_302)) <= p_86)))
                { /* block id: 155 */
                    (*l_268) = (*l_268);
                }
                else
                { /* block id: 157 */
                    struct S0 l_329 = {18446744073709551609UL,0x0.Dp+1,0xFCD3L,0xDF71456EL};
                    (*l_295) = ((**l_315) = __builtin_ctzl((((int16_t)(0x82CB2800L >= 0xB0A8462BL) >> (int16_t)(((int16_t)p_86 * (int16_t)__builtin_ctzl(((int16_t)((int16_t)0L >> (int16_t)13) * (int16_t)0x5A64L))) <= (p_87 == (**l_315)))) > ((**l_280) != p_87))));
                    return l_329;
                }
                /* facts after branching */
                assert (l_280 == &l_316);
                assert (l_301 == &l_316);
            }
            else
            { /* block id: 162 */
                uint16_t l_338 = 8UL;
                struct S1 *l_365 = (void*)0;
                struct S1 **l_366 = (void*)0;
                for (l_265.f0 = (-13); (l_265.f0 >= 14); l_265.f0 += 1)
                { /* block id: 165 */
                    struct S1 l_339 = {1L,-9L,0x9ACD65DFEDC4550ELL,18446744073709551610UL,0x1A16B9AC1F8926AFLL,0x089C4C44L,9UL};
                    uint64_t *l_341 = &l_339.f2;
                    int64_t l_363 = 0x3C90750858C5241BLL;
                    for (l_272 = 21; (l_272 == 29); l_272 += 1)
                    { /* block id: 168 */
                        uint64_t ***l_335 = &l_312;
                        uint64_t ****l_334 = &l_335;
                        (*l_334) = &l_312;
                    }
                    for (l_267.f1 = 0; (l_267.f1 == 15); l_267.f1 += 4)
                    { /* block id: 173 */
                        uint32_t l_340 = 18446744073709551615UL;
                        int64_t *l_342 = (void*)0;
                        int64_t l_344 = 0x6FCFB86C917BF7F8LL;
                        int64_t *l_343 = &l_344;
                        int32_t ***l_351 = &l_280;
                    }
                    if (p_88)
                    { /* block id: 180 */
                        int32_t ***l_362 = &l_301;
                        (*l_295) = func_91((*l_268), l_339.f0, func_96(((*l_312) = func_100(((((uint16_t)((((int32_t)0xB59454B6L + (int32_t)(((int16_t)(*l_316) - (int16_t)(p_87 <= ((int16_t)l_339.f0 << (int16_t)((uint32_t)(((*l_362) = &l_316) != &l_295) - (uint32_t)p_87)))) <= p_88)) > 4L) != l_339.f1) * (uint16_t)p_88) != p_87) >= l_363), (*l_315))), l_338, (**l_315)));
                        /* statement id: 183 */
                        assert (l_301 == &l_316);
                    }
                    else
                    { /* block id: 184 */
                        return l_364;
                    }
                    /* facts after branching */
                    assert (l_301 == &l_316);
                }
                /* facts after for loop */
                assert (l_301 == &l_316 || l_301 == &l_302);
                (*l_315) = func_32(p_86);
                /* statement id: 188 */
                assert (l_316 == 0);
                l_268 = l_365;
                /* statement id: 189 */
                assert (l_268 == 0);
            }
            /* facts after branching */
            assert (l_268 == 0 || l_268 == &l_267);
            assert (l_280 == &l_279 || l_280 == &l_316);
            assert (l_301 == &l_316 || l_301 == &l_302);
            assert (l_316 == 0 || l_316 == &l_267.f5);
        }
        else
        { /* block id: 191 */
            (*l_302) = 0x684CF5DCL;
        }
        /* facts after branching */
        assert (l_268 == 0 || l_268 == &l_267);
        assert (l_301 == &l_316 || l_301 == &l_302);
        assert (l_316 == 0 || l_316 == &l_267.f5);
        (*l_302) = 0xA9584E6BL;
    }
    else
    { /* block id: 195 */
        struct S1 l_389 = {0L,0x3D5FL,0x9862D915F21C82D8LL,0xDE25A6B8DBD902C9LL,1UL,0x386B117EL,0x3882DB7AL};
        uint32_t l_414 = 0x48EEB558L;
        struct S1 l_432 = {-9L,1L,0x75478798FFF755FFLL,0x0329CD6936928767LL,0xD077DB204A989218LL,0xE4B0C4D8L,5UL};
        float *l_449 = &l_265.f1;
        uint16_t *l_453 = &l_265.f2;
        uint16_t **l_452 = &l_453;
        for (l_265.f2 = 5; (l_265.f2 < 39); l_265.f2 += 1)
        { /* block id: 198 */
            struct S0 l_371 = {0xE3AF4C397BB7F8BFLL,0x0.27BF97p+6,65535UL,0L};
            int32_t **l_390 = &l_316;
            uint64_t l_400 = 0x8737C3F53BB106D1LL;
            struct S1 l_428 = {0xB8FE764DL,0x80EDL,0xA46B1574CE793188LL,18446744073709551610UL,1UL,0xA15C97F0L,0xF2E9F4E4L};
            struct S0 ***l_429 = (void*)0;
            uint32_t l_441 = 4294967295UL;
            for (l_267.f4 = (-4); (l_267.f4 > 29); l_267.f4 += 1)
            { /* block id: 201 */
                (*l_315) = (void*)0;
                /* statement id: 202 */
                assert (l_316 == 0);
                if (p_88)
                    break;
            }
            /* facts after for loop */
            assert (l_316 == 0 || l_316 == &l_265.f1 || l_316 == &l_267.f5);
            if (p_88)
            { /* block id: 205 */
                struct S0 *l_372 = &l_371;
                int16_t *l_377 = &l_267.f1;
                uint16_t *l_378 = &l_371.f2;
                int64_t l_392 = 1L;
                int64_t *l_391 = &l_392;
                int32_t l_393 = 1L;
                uint64_t *l_403 = &l_389.f3;
                uint64_t l_404 = 18446744073709551615UL;
                int32_t *l_405 = &l_267.f5;
                int32_t *l_406 = &l_267.f0;
                int32_t *l_415 = (void*)0;
                int32_t *l_416 = &l_389.f0;
                (*l_372) = l_371;
                (*l_315) = func_32((p_86 && ((uint64_t)((int16_t)((*l_377) = ((-1L) && 0xAB3874F5L)) >> (int16_t)((*l_378) = __builtin_popcountl(p_87))) - (uint64_t)(p_88 != ((int32_t)((int16_t)((int32_t)((uint64_t)(((int32_t)p_87 + (int32_t)(((*l_391) = __builtin_popcount(func_91(l_389, p_86, l_390))) ^ 0x3470AD2DAEC199B8LL)) <= l_393) - (uint64_t)0x616DD8D7B752946BLL) / (int32_t)p_86) << (int16_t)4) - (int32_t)l_393)))));
                /* statement id: 210 */
                assert (l_316 == 0);
                (*l_406) = ((*l_405) = ((((int16_t)((l_371.f3 > (((uint32_t)((((9L < ((p_86 & (((uint16_t)p_87 * (uint16_t)func_91((*l_268), l_400, &l_316)) <= (((*l_403) = ((int16_t)(l_371.f3 <= p_87) * (int16_t)0x559DL)) >= 1UL))) || l_371.f3)) | l_393) > p_86) > l_389.f4) - (uint32_t)p_88) | l_389.f5)) && 0x1313D4E5EF283404LL) * (int16_t)l_404) != p_86) >= l_392));
                if (((uint16_t)((*l_378) = (*l_405)) * (uint16_t)((uint32_t)((-1L) ^ p_88) - (uint32_t)((((*l_406) == 0x50B9D94CL) || l_389.f5) <= (!(l_371.f3 || ((int32_t)((*l_416) = l_414) + (int32_t)((int16_t)((int64_t)p_87 - (int64_t)18446744073709551615UL) / (int16_t)5UL))))))))
                { /* block id: 216 */
                    for (l_389.f1 = 0; (l_389.f1 <= 21); l_389.f1 += 1)
                    { /* block id: 219 */
                        struct S0 l_423 = {0xE00FFC98CE2EFB70LL,0x1.Bp-1,0x09D4L,0x7D1249C8L};
                        l_423 = l_371;
                    }
                }
                else
                { /* block id: 222 */
                    struct S0 l_424 = {18446744073709551615UL,0x0.Bp-1,0xA357L,0xD88F71A0L};
                    return l_424;
                }
            }
            else
            { /* block id: 225 */
                uint64_t l_426 = 18446744073709551615UL;
                struct S0 ***l_430 = &l_266;
                int32_t l_436 = (-2L);
                if (p_86)
                { /* block id: 226 */
                    float *l_425 = &l_265.f1;
                    (*l_425) = (-0x4.2p+1);
                }
                else
                { /* block id: 228 */
                    uint8_t l_433 = 0xEEL;
                    if (l_426)
                    { /* block id: 229 */
                        struct S0 l_427 = {18446744073709551608UL,-0x1.0p-1,0xA488L,7L};
                        return l_427;
                    }
                    else
                    { /* block id: 231 */
                        int32_t **l_434 = (void*)0;
                        int32_t *l_435 = &l_428.f0;
                        uint16_t *l_442 = &l_371.f2;
                        float *l_444 = &l_265.f1;
                        (*l_268) = l_428;
                        l_430 = l_429;
                        /* statement id: 233 */
                        assert (l_430 == 0);
                        l_436 = (((!(l_389.f0 = p_86)) & func_91(l_432, (l_433 = 0x3.8EF2FAp+84), l_434)) <= __builtin_ffs(((*l_435) = p_86)));
                        (*l_444) = (((float)p_88 - (float)__builtin_clz(((((*l_442) = ((uint64_t)((l_433 || ((*l_435) = p_87)) || __builtin_parityl(p_87)) + (uint64_t)l_441)) | (+p_88)) < (p_86 && ((p_86 >= p_88) == l_436))))) > l_433);
                    }
                    /* facts after branching */
                    assert (l_430 == 0);
                    for (l_389.f5 = 0; (l_389.f5 < (-18)); l_389.f5--)
                    { /* block id: 244 */
                        int32_t *l_450 = (void*)0;
                        int32_t *l_451 = &l_432.f5;
                        (*l_449) = (((float)(l_432.f2 >= p_86) / (float)((void*)0 != l_449)) <= p_87);
                        (*l_451) = ((l_436 > l_433) || p_88);
                    }
                }
                /* facts after branching */
                assert (l_430 == 0 || l_430 == &l_266);
                l_452 = (void*)0;
                /* statement id: 249 */
                assert (l_452 == 0);
            }
            if (p_86)
                break;
            (*l_315) = l_449;
            /* statement id: 252 */
            assert (l_316 == &l_265.f1);
        }
        /* facts after for loop */
        assert (l_316 == 0 || l_316 == &l_265.f1 || l_316 == &l_267.f5);
        assert (l_452 == 0 || l_452 == &l_453);
        (*l_268) = (*l_268);
    }
    /* facts after branching */
    assert (l_268 == 0 || l_268 == &l_267);
    assert (l_316 == 0 || l_316 == &l_265.f1 || l_316 == &l_267.f5);
    if (p_87)
    { /* block id: 256 */
        int32_t *l_455 = &l_267.f5;
        (*l_264) = (*l_264);
        (*l_455) = ((void*)0 == l_454);
        (*l_315) = func_32((*l_455));
        /* statement id: 259 */
        assert (l_316 == 0);
    }
    else
    { /* block id: 260 */
        int64_t l_459 = (-1L);
        int64_t *l_458 = &l_459;
        struct S1 l_466 = {-6L,-5L,0x3065366F19421CC5LL,0x271E485413613865LL,0xDF17AD67D59AD62FLL,0xB4E69716L,4294967295UL};
        float *l_469 = &l_265.f1;
        float **l_470 = &l_469;
        float *l_471 = &l_265.f1;
        int32_t **l_472 = &l_316;
        int16_t l_473 = 0x1278L;
        uint16_t *l_474 = &l_265.f2;
        int16_t *l_475 = &l_473;
        struct S0 l_476 = {0x87E1C1A7BDD8542FLL,0x8.9753B3p+14,65530UL,-2L};
        uint64_t *l_501 = &l_267.f2;
        uint64_t *l_502 = &l_267.f4;
        int32_t *l_505 = &l_466.f5;
        if ((((int16_t)(p_88 & ((*l_458) = __builtin_popcount(p_88))) >> (int16_t)((uint64_t)(p_87 && ((int32_t)(((*l_475) = (1UL == ((*l_474) = (0UL > (((int16_t)(func_91(l_466, ((*l_471) = ((float)(((*l_470) = l_469) == (void*)0) - (float)l_466.f3)), l_472) && l_466.f3) + (int16_t)p_86) != l_473))))) > 9UL) / (int32_t)(-4L))) % (uint64_t)p_88)) >= 0UL))
        { /* block id: 266 */
            return l_476;
        }
        else
        { /* block id: 268 */
            int32_t *l_479 = &l_466.f5;
            (*l_471) = p_88;
            (*l_315) = (*l_315);
            for (p_88 = 0; (p_88 != 17); p_88++)
            { /* block id: 273 */
                uint64_t *l_483 = (void*)0;
                uint64_t **l_482 = &l_483;
                uint64_t ***l_481 = &l_482;
                uint64_t ****l_480 = &l_481;
                l_479 = (void*)0;
                /* statement id: 274 */
                assert (l_479 == 0);
                (*l_480) = (void*)0;
                /* statement id: 275 */
                assert (l_481 == 0);
            }
            /* facts after for loop */
            assert (l_479 == 0 || l_479 == &l_466.f5);
        }
        (*l_315) = (*l_472);
        for (p_87 = 0; (p_87 == 16); p_87 += 3)
        { /* block id: 281 */
            int32_t l_495 = 0xF9CEBAA6L;
            (*l_471) = ((float)((float)((float)(0xF.CC60DBp+21 >= ((float)(-(float)l_495) / (float)p_88)) - (float)((0x5.9p-1 >= (l_495 != 0x7.256CC3p+10)) > ((l_475 != l_496) != p_87))) + (float)p_88) * (float)0xD.6AF30Fp+98);
        }
        (*l_505) = ((((uint16_t)((*l_496) = p_86) - (uint16_t)__builtin_ctzl(p_87)) == ((uint64_t)((*l_501) = p_88) - (uint64_t)((*l_502) = p_86))) ^ ((uint32_t)p_87 + (uint32_t)(&l_476 != (*l_266))));
    }
    return l_506;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_91(struct S1  p_92, float  p_93, int32_t ** p_94)
{ /* block id: 125 */
    struct S1 l_262 = {0x10EF4BC9L,-3L,0UL,18446744073709551615UL,1UL,-5L,0x1929A791L};
    struct S1 *l_261 = &l_262;
    struct S1 **l_260 = &l_261;
    (*l_260) = &p_92;
    /* statement id: 126 */
    assert (l_261 == &p_92);
    return p_92.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_96(uint64_t * p_97, int64_t  p_98, uint32_t  p_99)
{ /* block id: 70 */
    int32_t *l_186 = (void*)0;
    uint32_t l_202 = 4294967295UL;
    struct S1 l_221 = {0L,6L,0xC3CA42F718E4816DLL,0x70B35F69D68153D3LL,18446744073709551615UL,3L,0xD5B360F5L};
    uint64_t *l_230 = &l_221.f4;
    uint64_t **l_229 = &l_230;
    uint64_t ***l_228 = &l_229;
    int32_t **l_259 = (void*)0;
    for (p_98 = 0; (p_98 <= 18); p_98 += 8)
    { /* block id: 73 */
        int32_t l_184 = (-8L);
        int32_t *l_183 = &l_184;
        int32_t **l_185 = (void*)0;
        int32_t l_201 = 0x552C8331L;
        struct S0 *l_215 = (void*)0;
        struct S0 **l_214 = &l_215;
        struct S1 l_222 = {0x27BCE406L,1L,1UL,0xA8836995D41F0D64LL,0UL,0x412CFCA4L,0x7643AB9FL};
        struct S1 *l_227 = &l_221;
        l_186 = func_32(((*l_183) = p_99));
        for (p_99 = 29; (p_99 <= 53); p_99 += 8)
        { /* block id: 78 */
            int32_t l_195 = 0xB16BE7C8L;
            struct S0 l_197 = {0x7B70EE5EE185A6AELL,0x1.EDEDAEp+43,65535UL,-4L};
            struct S0 *l_196 = &l_197;
            struct S1 l_217 = {0x399E06E0L,-6L,0x3EE845A36995B3EALL,0x93CA1DE74A5FEA72LL,9UL,0L,0x9CDAB9F7L};
        }
        (*l_227) = l_221;
    }
    l_228 = l_228;
    if ((!p_99))
    { /* block id: 108 */
        uint64_t l_236 = 0xE3AC004CCE6538CDLL;
        float l_246 = 0x6.5D696Ap-14;
        float *l_245 = &l_246;
        float l_248 = 0x7.D33C81p-4;
        float *l_247 = &l_248;
        (*l_247) = ((float)((float)(p_99 > (l_236 >= p_99)) + (float)(-0x4.Cp-1)) / (float)(((float)l_236 / (float)((float)l_236 * (float)l_236)) != (p_99 != (((float)((*l_245) = ((float)0xE.DDCEFBp+73 / (float)p_99)) - (float)l_236) <= l_236))));
    }
    else
    { /* block id: 111 */
        int32_t *l_249 = &l_221.f0;
        float l_255 = 0x4.AC2A14p+78;
        float *l_254 = &l_255;
        float **l_253 = &l_254;
        float ***l_256 = &l_253;
        float **l_258 = &l_254;
        float ***l_257 = &l_258;
        l_186 = l_249;
        /* statement id: 112 */
        assert (l_186 == &l_221.f0);
        for (l_221.f3 = 0; (l_221.f3 != 7); l_221.f3++)
        { /* block id: 115 */
            int32_t *l_252 = (void*)0;
            l_252 = l_186;
            /* statement id: 116 */
            assert (l_252 == &l_221.f0);
            (*l_186) = (*l_249);
            if ((*l_249))
                break;
        }
        (*l_186) = ((*l_249) || (*l_186));
        (*l_257) = ((*l_256) = l_253);
    }
    /* facts after branching */
    assert (l_186 == &l_221.f0 || l_186 == 0);
    return l_259;
    /* statement id: 124 */
    //assert (func_96_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t * func_100(uint64_t  p_101, int32_t * p_102)
{ /* block id: 50 */
    float l_114 = 0x1.6p-1;
    int32_t l_117 = 0x23B15C07L;
    int32_t l_120 = 0x9658AA49L;
    int32_t l_123 = 0xDB90C34EL;
    int32_t *l_122 = &l_123;
    int16_t *l_126 = (void*)0;
    int16_t l_128 = (-8L);
    int16_t *l_127 = &l_128;
    int64_t *l_129 = (void*)0;
    int64_t l_131 = 0xECB2597785040678LL;
    int64_t *l_130 = &l_131;
    struct S1 l_148 = {-4L,0xE0ADL,0xD112D82128C81A46LL,0xFD11974AA1647F7CLL,0UL,0xF5982E87L,0x1BCA9B0EL};
    struct S0 l_149 = {18446744073709551610UL,0xD.5CA490p+2,0x945AL,1L};
    uint64_t l_150 = 8UL;
    float *l_179 = &l_114;
    uint64_t *l_180 = (void*)0;
    (*l_179) = func_103(func_109(p_101, (((*l_130) = ((uint32_t)((l_117 = (l_117 <= p_101)) == p_101) % (uint32_t)(((p_101 && l_120) & 0xAA1C64ACL) & (((*l_127) = ((+((*l_122) = l_120)) <= ((int32_t)p_101 + (int32_t)0x67ADB25BL))) == 0UL)))) & 0x1ECDBA6A349BDABDLL), l_129, p_102), l_148, l_149, p_101, l_150);
    return l_180;
    /* statement id: 69 */
    //assert (func_100_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_103(int16_t * p_104, struct S1  p_105, struct S0  p_106, int16_t  p_107, int16_t  p_108)
{ /* block id: 63 */
    int32_t l_153 = 0L;
    int32_t *l_152 = &l_153;
    int32_t **l_151 = &l_152;
    int64_t l_171 = (-1L);
    int64_t *l_170 = &l_171;
    int64_t l_178 = 0x84B00287A080E1D1LL;
    (*l_151) = func_32(p_105.f3);
    /* statement id: 64 */
    assert (l_152 == 0);
    l_153 = ((uint16_t)__builtin_ffsl(((int32_t)((uint32_t)((int32_t)(((int64_t)(((uint16_t)((uint16_t)((uint16_t)p_106.f0 << (uint16_t)(4294967293UL ^ p_105.f4)) * (uint16_t)0UL) >> (uint16_t)4) || 0xA313L) + (int64_t)(((*l_170) = 0xDAD02808DCF833B2LL) == ((uint32_t)p_105.f6 - (uint32_t)((p_105.f2 <= (((int16_t)(p_105.f2 >= p_108) >> (int16_t)1) == p_105.f4)) > p_106.f0)))) == l_153) / (int32_t)l_153) / (uint32_t)p_105.f5) % (int32_t)0xDE4361DAL)) * (uint16_t)0x29F3L);
    return l_178;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t * func_109(int32_t  p_110, uint8_t  p_111, uint64_t * p_112, int32_t * p_113)
{ /* block id: 55 */
    int16_t l_134 = 0xB323L;
    int32_t l_136 = 0x387E9A70L;
    int32_t *l_135 = &l_136;
    int16_t *l_141 = &l_134;
    int16_t *l_142 = &l_134;
    int16_t *l_143 = &l_134;
    int16_t *l_144 = &l_134;
    int16_t *l_145 = &l_134;
    int16_t *l_146 = &l_134;
    int16_t *l_147 = (void*)0;
    (*l_135) = ((uint64_t)l_134 + (uint64_t)0x0817FF2A7570BAEALL);
    for (p_111 = 0; (p_111 < 24); p_111 += 3)
    { /* block id: 59 */
        struct S0 l_139 = {0UL,0x1.8325B1p-32,0x2B54L,0x46D15494L};
        struct S0 *l_140 = &l_139;
        (*l_140) = l_139;
    }
    return l_147;
    /* statement id: 62 */
    //assert (func_109_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 158
   depth: 1, occurrence: 34
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 203
   depth: 2, occurrence: 36
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 5
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 4
   depth: 25, occurrence: 1

XXX total number of pointers: 264

XXX times a variable address is taken: 217
XXX times a pointer is dereferenced on RHS: 64
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 178
breakdown:
   depth: 1, occurrence: 172
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 491

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 372
   level: 2, occurrence: 93
   level: 3, occurrence: 26
   level: 4, occurrence: 2
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 107
XXX number of pointers point to scalars: 133
XXX number of pointers point to structs: 24
XXX percent of pointers has null in alias set: 32.6
XXX average alias set size: 1.17

XXX times a non-volatile is read: 699
XXX times a non-volatile is write: 444
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 176
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 37
   depth: 2, occurrence: 31
   depth: 3, occurrence: 27
   depth: 4, occurrence: 22
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 19.3
XXX percentage an existing variable is used: 80.7
********************* end of statistics **********************/

