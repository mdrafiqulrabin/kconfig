/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      869266670
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 5;
   int32_t  f1;
   uint32_t  f2;
   const uint32_t  f3;
   unsigned f4 : 5;
   int32_t  f5;
   unsigned f6 : 15;
   uint32_t  f7;
   const int32_t  f8;
   unsigned f9 : 6;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static float  func_1(void);
inline static const int32_t * func_2(int32_t * p_3, uint32_t  p_4, int32_t * p_5, struct S0  p_6);
inline static int32_t * func_11(int32_t * p_12, const int32_t * p_13);
inline static int32_t  func_20(int32_t ** p_21, int32_t ** p_22, uint16_t  p_23);
inline static int32_t ** func_24(int16_t  p_25, int32_t * p_26, int32_t  p_27, int32_t * p_28, int32_t ** p_29);
static uint32_t  func_36(int32_t  p_37, int32_t * p_38, float  p_39, int32_t  p_40, uint32_t  p_41);
inline static uint16_t  func_50(const uint32_t  p_51, int32_t  p_52);
static float  func_55(int32_t ** p_56, uint16_t  p_57, int32_t  p_58, int16_t  p_59);
static int32_t ** func_60(float  p_61, int32_t ** p_62, int32_t  p_63);
static const int32_t * func_67(float  p_68, int32_t  p_69, const struct S0  p_70, int32_t * p_71);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_1(void)
{ /* block id: 0 */
    int32_t *l_7 = (void*)0;
    int32_t l_8 = (-7);
    int32_t *l_9 = &l_8;
    struct S0 l_10 = {4,-1,4U,4294967295U,0,1,44,0x86B6FEB9,0x9D60A221,5};
    const int32_t *l_19 = &l_8;
    int32_t l_42 = 0x422F8DC7;
    uint32_t l_493 = 0x2203D504;
    uint16_t l_660 = 65535U;
    struct S0 *l_727 = &l_10;
    struct S0 **l_726 = &l_727;
    int32_t l_730 = (-1);
    float l_748 = 0xA.81504Fp+87;
    float *l_747 = &l_748;
    float **l_746 = &l_747;
    float ***l_745 = &l_746;
    const float ***l_750 = (void*)0;
    float l_751 = 0x6.D1698Dp-96;
lbl_737:
    l_19 = func_2(l_7, l_8, l_9, l_10);
    /* statement id: 6 */
    assert (l_19 == 0);
    if (func_20(&l_7, func_24((*l_9), ((((((((int16_t)((int16_t)(((int32_t)(func_36(l_42, &l_8, (*l_9), ((int16_t)((*l_9) , ((uint16_t)(-(uint32_t)((((int16_t)((0xEAA4 ^ func_50((*l_9), ((int16_t)(*l_9) / (int16_t)(*l_9)))) > (*l_9)) >> (int16_t)(*l_9)) < l_493) || (*l_9))) >> (uint16_t)8)) << (int16_t)0), (*l_9)) , (*l_9)) + (int32_t)(*l_9)) == 0) << (int16_t)9) % (int16_t)(*l_9)) < l_660) , (*l_9)) <= (*l_9)) , (*l_9)) ^ (*l_9)) , &l_8), (*l_9), &l_8, &l_7), (*l_9)))
    { /* block id: 191 */
        int16_t l_729 = 0x46A6;
        struct S0 **l_731 = &l_727;
        for (l_10.f5 = 1; (l_10.f5 < 15); l_10.f5 += 1)
        { /* block id: 194 */
            float l_725 = 0x1.1p-1;
            float *l_724 = &l_725;
            float **l_723 = &l_724;
            float ***l_722 = &l_723;
            const int32_t l_728 = 0x53D48BE7;
            struct S0 **l_736 = &l_727;
            (*l_722) = (void*)0;
            /* statement id: 195 */
            assert (l_723 == 0);
            (*l_9) = ((0xDE50F10C >= (((l_726 == (((l_728 >= l_729) == l_730) , l_731)) & ((4 == (((uint16_t)((((l_729 <= ((uint16_t)((l_728 , l_731) != l_736) << (uint16_t)l_729)) | 0x9BF5F2B9) > 0x6656) , (*l_9)) - (uint16_t)0xD2B9) <= (-1))) != l_729)) , l_728)) == l_729);
        }
    }
    else
    { /* block id: 198 */
        uint16_t l_742 = 1U;
        struct S0 l_749 = {3,0,1U,0xF90BD28C,2,-1,103,0x4D6BAD26,7,3};
        if (l_493)
            goto lbl_737;
        (*l_9) = ((uint16_t)((int16_t)l_742 / (int16_t)65535U) % (uint16_t)(l_742 && ((0U < (((4294967295U ^ (l_745 == (l_749 , l_750))) && (((&l_727 == (void*)0) == l_749.f8) | l_749.f1)) <= 0xBB31)) != (*l_9))));
    }
    return l_751;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_2(int32_t * p_3, uint32_t  p_4, int32_t * p_5, struct S0  p_6)
{ /* block id: 1 */
    int32_t *l_14 = (void*)0;
    const int32_t l_17 = 0x8EB5EA28;
    const int32_t *l_16 = &l_17;
    const int32_t **l_15 = &l_16;
    const int32_t *l_18 = (void*)0;
    (*l_15) = func_11(l_14, l_14);
    /* statement id: 4 */
    assert (l_16 == 0);
    return l_18;
    /* statement id: 5 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_11(int32_t * p_12, const int32_t * p_13)
{ /* block id: 2 */
    return p_12;
    /* statement id: 3 */
    //assert (func_11_rv == 0 || func_11_rv == &l_89 || func_11_rv == &l_176 || func_11_rv == &l_438 || func_11_rv == &l_185.f5 || func_11_rv == &p_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_20(int32_t ** p_21, int32_t ** p_22, uint16_t  p_23)
{ /* block id: 181 */
    float **l_691 = (void*)0;
    float ***l_690 = &l_691;
    float ****l_689 = &l_690;
    int32_t l_692 = 0x19BBCC8E;
    const struct S0 l_693 = {0,-1,4294967287U,4294967287U,4,0xF19094DC,174,4294967294U,-1,6};
    const int32_t *l_694 = (void*)0;
    struct S0 l_698 = {1,7,0x9D6A1B42,0x07D8D0AD,3,0x06117C12,144,0xA1DD0F04,-1,4};
    struct S0 *l_697 = &l_698;
    struct S0 **l_696 = &l_697;
    struct S0 ***l_695 = &l_696;
    int32_t *l_701 = &l_698.f1;
    struct S0 l_709 = {1,0xC3745483,0U,4294967295U,1,0x71A107FC,36,0U,0x23A3FC51,4};
    int32_t **l_717 = &l_701;
    int32_t ***l_716 = &l_717;
    l_694 = func_67(((void*)0 == l_689), l_692, l_693, &l_692);
    (*l_701) = (l_695 == (((uint16_t)(p_23 , (p_21 != p_21)) >> (uint16_t)6) , &l_696));
    if ((((int32_t)(((uint16_t)p_23 - (uint16_t)(((-(float)(p_23 > ((float)(l_709 , ((float)((float)(((float)(p_23 > (*l_701)) * (float)(0x1.Fp+1 < ((*l_701) , (l_716 != (((*l_689) == (void*)0) , &p_22))))) == p_23) / (float)(*l_701)) - (float)p_23)) * (float)p_23))) , (*l_695)) == (*l_695))) || p_23) + (int32_t)(***l_716)) , (-3)))
    { /* block id: 184 */
        uint32_t l_718 = 0x472A1047;
        l_718 = (p_23 > p_23);
    }
    else
    { /* block id: 186 */
        int32_t l_719 = (-2);
        (*l_717) = (*p_21);
        /* statement id: 187 */
        assert (l_701 == 0);
        return l_719;
    }
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_24(int16_t  p_25, int32_t * p_26, int32_t  p_27, int32_t * p_28, int32_t ** p_29)
{ /* block id: 176 */
    const int32_t l_661 = (-1);
    int32_t l_670 = 0x8B42619A;
    uint32_t l_678 = 9U;
    float l_680 = 0x7.307D44p-32;
    float *l_679 = &l_680;
    int32_t *l_686 = &l_670;
    int32_t **l_685 = &l_686;
    int32_t **l_687 = &l_686;
    int32_t **l_688 = (void*)0;
    (*p_29) = (void*)0;
    (*l_679) = (((l_661 >= (((float)((float)p_27 / (float)((float)p_27 - (float)((float)(l_670 == 0x0.13C8E0p-7) * (float)((!(0x0.Ep-1 < ((float)((-0x4.3p-1) == (((float)((float)((l_678 , l_678) > p_27) * (float)0x2.76F07Bp+44) * (float)l_678) > 0x6.2p+1)) - (float)p_27))) <= 0xC.E670D3p-25)))) * (float)0x1.0p-1) != l_661)) > l_661) < 0xC.47F1C2p+78);
    l_670 = ((float)l_670 - (float)((float)0x0.Dp-1 * (float)l_661));
    return l_688;
    /* statement id: 180 */
    //assert (func_24_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_36(int32_t  p_37, int32_t * p_38, float  p_39, int32_t  p_40, uint32_t  p_41)
{ /* block id: 133 */
    int16_t l_496 = 0x643C;
    float l_516 = 0x6.93A10Ap-46;
    float *l_515 = &l_516;
    float **l_519 = &l_515;
    float ***l_518 = &l_519;
    float ****l_517 = &l_518;
    int32_t l_520 = (-1);
    int16_t l_528 = 0;
    uint16_t l_535 = 0x0932;
    struct S0 l_537 = {3,0xF28EF21A,0xB9FBCCDF,0xAD8CC73B,0,0xB302C44D,72,4294967290U,0xB08D070C,3};
    struct S0 *l_536 = &l_537;
    const int32_t *l_550 = &l_520;
    const int32_t **l_549 = &l_550;
    const int32_t ***l_548 = &l_549;
    const int32_t ****l_547 = &l_548;
    uint32_t l_563 = 0U;
    int16_t l_566 = 8;
    int32_t l_570 = 9;
    struct S0 **l_573 = &l_536;
    struct S0 ***l_572 = &l_573;
    int32_t *l_574 = &l_537.f5;
    float l_592 = 0x0.525001p+19;
    uint32_t l_658 = 4294967291U;
    if ((((((int32_t)l_496 / (int32_t)l_496) == ((int16_t)((((int16_t)((((uint16_t)(~((uint16_t)((uint32_t)l_496 + (uint32_t)(((uint32_t)((p_41 > ((int16_t)((uint16_t)(0x0DC6 & 3U) * (uint16_t)(0U >= ((((-(int32_t)(*p_38)) , l_496) , l_496) || l_496))) >> (int16_t)p_40)) , p_37) % (uint32_t)l_496) != 0)) >> (uint16_t)l_496)) + (uint16_t)p_37) , l_515) == (void*)0) >> (int16_t)p_37) , l_517) != &l_518) % (int16_t)0x4CC1)) == 0x7E1939BD) , 0xD715F216))
    { /* block id: 134 */
        return l_496;
    }
    else
    { /* block id: 136 */
        l_520 = l_496;
    }
    if ((((int32_t)(((int16_t)(((!l_496) & p_41) > (*p_38)) * (int16_t)((((((int16_t)(((((l_528 && ((((p_41 != ((*p_38) < (((int16_t)(((int16_t)(((((float)(((((-1) & 0x1099E264) > p_37) , p_40) , l_535) * (float)l_528) < p_39) , p_37) , p_40) % (int16_t)l_535) != p_40) + (int16_t)l_535) == l_520))) <= l_535) >= (-5)) , 5U)) ^ (*p_38)) , l_520) | l_496) ^ (*p_38)) << (int16_t)12) & 0xEA038C23) >= l_496) , 4294967294U) > p_37)) || 0x058D) % (int32_t)l_520) ^ 0x86474421))
    { /* block id: 139 */
        l_536 = l_536;
    }
    else
    { /* block id: 141 */
        uint32_t l_544 = 4294967292U;
        int32_t *l_551 = &l_537.f5;
        const struct S0 l_556 = {1,0xBCEFBD8A,0x0E0D5C17,0x79A8BBCC,0,-1,96,0x5F8236F5,1,7};
        const float *l_569 = &l_516;
        const float **l_568 = &l_569;
        const float ***l_567 = &l_568;
        float *****l_571 = (void*)0;
        (***l_518) = ((l_537.f6 < (l_520 >= (p_38 != (((l_537.f7 < (((((uint16_t)(((((uint32_t)((p_37 , ((int16_t)((l_544 , 0x3FDE) || ((uint16_t)p_40 << (uint16_t)p_41)) * (int16_t)p_37)) , 6U) - (uint32_t)p_40) != p_37) || 5) > 0xB0A22976) % (uint16_t)p_40) >= 0x96FA) , (void*)0) == l_547)) , 0x3.7058CFp-52) , l_551)))) < p_41);
        (***l_518) = ((((p_37 >= ((((((int32_t)((p_40 , ((-0x1.Cp-1) == (((((int16_t)(l_556 , ((int16_t)((int16_t)(((int16_t)(0xE8F0 | l_563) % (int16_t)((((((uint16_t)l_566 >> (uint16_t)9) , l_567) == &l_568) <= p_37) | 0xD1CE)) , l_570) << (int16_t)(*l_551)) % (int16_t)0xD312)) >> (int16_t)5) , p_39) < p_40) != (-0x1.Ep+1)))) , (*l_550)) / (int32_t)p_41) , (void*)0) != (void*)0) | 3U) && p_37)) , (void*)0) == l_571) > p_39);
    }
    (*l_574) = (l_572 != &l_573);
    if (((uint16_t)(***l_548) << (uint16_t)8))
    { /* block id: 146 */
        float l_585 = (-0x7.0p-1);
        int32_t l_586 = 0;
        float **l_587 = (void*)0;
        (*l_549) = p_38;
        /* statement id: 147 */
        //assert (l_550 == &l_8);
    }
    else
    { /* block id: 148 */
        int32_t *l_599 = (void*)0;
        int16_t l_612 = 1;
        float ***l_656 = &l_519;
        const int16_t l_659 = 0;
        for (l_566 = (-14); (l_566 == 19); l_566 += 3)
        { /* block id: 151 */
            uint32_t l_603 = 0U;
            int32_t l_615 = (-9);
            float *****l_629 = &l_517;
            int32_t l_640 = 0xE05A20F8;
            for (l_528 = (-17); (l_528 < 25); ++l_528)
            { /* block id: 154 */
                int32_t l_613 = 0xDEBB6675;
                float ****l_614 = (void*)0;
                struct S0 l_630 = {3,0x11F92433,1U,0xDD684CD2,4,3,118,4294967289U,2,0};
                for (p_40 = 0; (p_40 > 3); ++p_40)
                { /* block id: 157 */
                    struct S0 l_600 = {0,-3,0xDCE8454D,1U,1,1,97,4294967291U,0xCDAF639D,4};
                }
                (*l_549) = p_38;
                /* statement id: 162 */
                //assert (l_550 == &l_8);
                (*l_574) = 0xD0E2C794;
                if ((((uint16_t)((!((int16_t)((((uint16_t)0x6CD4 >> (uint16_t)14) <= (((uint32_t)(((int16_t)(l_629 != (l_630 , l_629)) >> (int16_t)(~((int16_t)(((p_40 < (((uint16_t)65529U % (uint16_t)1U) ^ p_41)) < ((uint32_t)((int16_t)(l_603 ^ l_640) << (int16_t)5) + (uint32_t)0xEC838116)) != p_40) << (int16_t)l_615))) && 0U) - (uint32_t)(*p_38)) != 7U)) && 0x387F) << (int16_t)2)) >= p_40) >> (uint16_t)13) == 1U))
                { /* block id: 164 */
                    return p_37;
                }
                else
                { /* block id: 166 */
                    uint16_t l_644 = 0xCF02;
                    float **l_657 = &l_515;
                    (*l_515) = (-0x8.5p-1);
                    (*l_574) = (p_37 , ((uint32_t)((!((((l_644 == (p_37 == ((((*p_38) == (-(int32_t)((((int16_t)0 - (int16_t)(((int16_t)((int16_t)(l_640 > ((uint16_t)((((((int16_t)(((void*)0 == l_656) , ((l_657 == (void*)0) ^ 1)) >> (int16_t)p_41) == l_658) >= l_659) != p_41) , p_41) % (uint16_t)p_37)) % (int16_t)0x298B) << (int16_t)l_630.f5) == l_630.f2)) >= l_644) > l_615))) , l_640) != 4))) || 0x5DBE) <= 0x29A57F10) <= 0x334D19B8)) ^ 65527U) % (uint32_t)l_630.f2));
                }
            }
            if ((****l_547))
                continue;
            (*l_549) = (**l_548);
        }
        /* facts after for loop */
        //assert (l_550 == &l_8 || l_550 == &l_520);
    }
    /* facts after branching */
    //assert (l_550 == &l_8 || l_550 == &l_520);
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_50(const uint32_t  p_51, int32_t  p_52)
{ /* block id: 7 */
    int32_t l_64 = 1;
    int32_t *l_66 = (void*)0;
    int32_t **l_65 = &l_66;
    float *l_175 = (void*)0;
    int32_t l_176 = 0xF29C22F7;
    struct S0 *l_184 = (void*)0;
    struct S0 l_185 = {3,0xEE845A36,4294967287U,1U,2,0x93CA1DE7,64,1U,1,2};
    const int32_t *l_188 = &l_185.f1;
    int32_t *l_189 = (void*)0;
    uint32_t l_251 = 4294967295U;
    int32_t l_413 = (-1);
    float **l_479 = &l_175;
    float ***l_478 = &l_479;
    float ****l_477 = &l_478;
    float l_487 = (-0x10.Ap+1);
lbl_206:
    l_176 = func_55(func_60(l_64, l_65, p_52), l_64, (l_64 > l_64), p_51);
    /* statement id: 42 */
    //assert (l_66 == dangling || l_66 == &p_52 || l_66 == 0);
    if (((uint16_t)((((((uint16_t)(!(((uint16_t)l_64 << (uint16_t)(l_184 != (l_185 , (((l_185.f6 || (((void*)0 == &l_66) ^ (p_52 <= (l_175 != (void*)0)))) , 4294967295U) , &l_185)))) | 1)) * (uint16_t)0xED5F) , l_188) == l_189) , &l_184) == (void*)0) << (uint16_t)1))
    { /* block id: 43 */
        int32_t *l_190 = &l_185.f1;
        float *l_191 = (void*)0;
        float l_193 = 0x1.9F7B9Ep-91;
        float *l_192 = &l_193;
        (*l_190) = p_51;
        (*l_190) = p_51;
        (*l_192) = 0x1.1p-1;
    }
    else
    { /* block id: 47 */
        int32_t **l_196 = (void*)0;
        struct S0 **l_201 = (void*)0;
        uint32_t l_254 = 3U;
        const float l_259 = (-0x9.0p-1);
        int32_t l_287 = 1;
        int32_t *l_329 = &l_176;
        struct S0 l_364 = {4,-10,5U,5U,4,0x58ABC9BC,160,0xBC02E2F5,0x0F209037,5};
        float **l_412 = &l_175;
        float ***l_411 = &l_412;
        float l_486 = 0xF.82CF4Fp+17;
        float *****l_490 = (void*)0;
        if (((((p_52 <= (((float)(&l_188 == l_196) + (float)((float)(*l_188) - (float)((float)(p_52 < p_51) + (float)(((((void*)0 == l_201) , p_52) , p_51) >= 0xC.3AC004p-62)))) , p_52)) == p_51) != p_51) & p_52))
        { /* block id: 48 */
            struct S0 *l_204 = &l_185;
            (*l_65) = &p_52;
            /* statement id: 49 */
            assert (l_66 == &p_52);
            for (l_185.f5 = (-26); (l_185.f5 <= (-14)); l_185.f5 += 4)
            { /* block id: 52 */
                struct S0 **l_205 = &l_184;
                (*l_205) = l_204;
                /* statement id: 53 */
                assert (l_184 == &l_185);
                if (l_185.f0)
                    goto lbl_206;
                (*l_65) = &p_52;
            }
        }
        else
        { /* block id: 57 */
            uint32_t l_223 = 0xD310EF4B;
            int32_t ***l_240 = &l_65;
            float l_265 = 0x2.Ap-1;
            int32_t *l_328 = (void*)0;
            float **l_337 = &l_175;
            float ***l_336 = &l_337;
            uint32_t l_342 = 0x98711725;
            const struct S0 l_346 = {1,9,1U,1U,3,0x6AAD285B,154,0x2F7A7A2C,1,4};
            int16_t l_473 = 1;
            float *****l_475 = (void*)0;
            float *****l_476 = (void*)0;
            if ((((uint16_t)(-(uint16_t)p_51) % (uint16_t)(-3)) >= ((int32_t)0xA6541942 + (int32_t)(p_51 && ((int16_t)(p_51 > ((int32_t)(*l_188) - (int32_t)(((((uint16_t)((int16_t)(-(uint16_t)(0xF477 > p_52)) >> (int16_t)6) - (uint16_t)((uint32_t)l_223 - (uint32_t)l_223)) | 1) > 0x0DD5) == l_223))) - (int16_t)1)))))
            { /* block id: 58 */
                int32_t l_224 = 0;
                return l_224;
            }
            else
            { /* block id: 60 */
                int32_t ***l_231 = &l_65;
                struct S0 **l_236 = &l_184;
                int32_t *l_239 = &l_185.f1;
                float *l_241 = (void*)0;
                float l_243 = 0x7.Cp-1;
                float *l_242 = &l_243;
                float **l_245 = (void*)0;
                float ***l_244 = &l_245;
                (*l_239) = ((uint32_t)((int16_t)((-8) || (p_52 >= ((void*)0 != &p_52))) + (int16_t)(l_231 == &l_65)) + (uint32_t)(((uint16_t)(((int16_t)(((void*)0 != l_236) == ((uint16_t)0xC006 * (uint16_t)(*l_188))) * (int16_t)p_51) | p_52) >> (uint16_t)6) > p_51));
                (*l_242) = ((void*)0 != l_240);
                (*l_244) = &l_175;
                /* statement id: 63 */
                assert (l_245 == &l_175);
            }
lbl_474:
            if (((!((uint32_t)p_51 / (uint32_t)(((int16_t)l_251 * (int16_t)((uint16_t)(p_51 < (l_254 && ((int16_t)((p_52 >= (-9)) > (((int16_t)p_51 >> (int16_t)14) != p_51)) - (int16_t)p_51))) >> (uint16_t)(*l_188))) ^ p_51))) > p_52))
            { /* block id: 65 */
                int32_t l_264 = (-1);
                uint32_t l_269 = 4294967295U;
                struct S0 l_277 = {3,0x5DCFA39C,0x04BBC362,4294967295U,4,0,7,8U,7,1};
                int32_t ****l_279 = &l_240;
                if ((((uint16_t)(p_51 , ((int16_t)l_223 / (int16_t)l_264)) - (uint16_t)((((1U >= 0xCD81) || p_51) ^ p_51) || (1U && 1U))) != p_51))
                { /* block id: 66 */
                    float *l_266 = &l_265;
                    struct S0 ***l_272 = &l_201;
                    int32_t l_284 = 0x91758210;
                    if ((((void*)0 == l_266) >= 0x0AB8))
                    { /* block id: 67 */
                        struct S0 **l_267 = &l_184;
                        (*l_65) = l_266;
                        /* statement id: 68 */
                        assert (l_66 == &l_265);
                        if (l_185.f4)
                            goto lbl_268;
lbl_268:
                        (*l_267) = &l_185;
                        /* statement id: 69 */
                        assert (l_184 == &l_185);
                        (**l_240) = (void*)0;
                        /* statement id: 71 */
                        assert (l_66 == 0);
                        (*l_266) = ((-0x1.9p+1) != l_269);
                    }
                    else
                    { /* block id: 73 */
                        int32_t ***l_270 = &l_65;
                        int32_t ****l_271 = &l_240;
                        (*l_271) = l_270;
                        (**l_270) = &p_52;
                        /* statement id: 75 */
                        assert (l_66 == &p_52);
                        (*l_65) = (**l_270);
                    }
                    /* facts after branching */
                    assert (l_66 == &p_52 || l_66 == 0);
                    (*l_272) = &l_184;
                    /* statement id: 78 */
                    assert (l_201 == &l_184);
                    if ((((int16_t)(((int16_t)((((l_277 , l_277.f7) , (p_52 < (((!(p_51 | p_52)) , l_279) == (void*)0))) , p_52) || 4294967294U) << (int16_t)p_51) == p_52) + (int16_t)l_277.f1) ^ p_51))
                    { /* block id: 79 */
                        return p_52;
                    }
                    else
                    { /* block id: 81 */
                        uint32_t l_302 = 0U;
                        int32_t l_311 = (-1);
                        (***l_279) = l_266;
                        /* statement id: 82 */
                        assert (l_66 == &l_265);
                        l_311 = ((float)(((float)((l_284 >= ((0x0.302874p-58 != (l_266 != l_266)) < (!(!((l_287 < ((uint16_t)((int16_t)((((int16_t)((int16_t)((int16_t)((((int32_t)((int16_t)l_302 >> (int16_t)8) / (int32_t)((uint16_t)((((int16_t)(((int16_t)(p_52 , p_51) + (int16_t)(((uint16_t)p_51 >> (uint16_t)4) && 0x8F84)) != p_51) / (int16_t)p_51) , l_284) , 9U) / (uint16_t)(-10))) < 0xDEBC) , (-1)) >> (int16_t)3) << (int16_t)(***l_240)) + (int16_t)0x78AE) , (**l_272)) == (void*)0) % (int16_t)65535U) / (uint16_t)(****l_279))) , p_51))))) == p_51) + (float)0xE.8FCEAAp+33) != 0x1.8p-1) - (float)0x2.6F4518p+31);
                        if (l_185.f5)
                            goto lbl_474;
                        (****l_279) = (((((int16_t)((uint16_t)((***l_240) < (((uint16_t)(!((void*)0 != l_189)) >> (uint16_t)((uint16_t)p_51 + (uint16_t)((uint16_t)((((((uint32_t)((int16_t)7 + (int16_t)(l_284 < 1)) + (uint32_t)1) | (p_52 & 5)) & p_51) , 65529U) < (*l_66)) << (uint16_t)p_52))) != (-3))) - (uint16_t)8U) % (int16_t)p_52) == (*l_188)) ^ 1U) == 0x7207AB9D);
                    }
                    /* facts after branching */
                    assert (l_66 == &l_265);
                    (***l_279) = (**l_240);
                }
                else
                { /* block id: 87 */
                    struct S0 **l_327 = &l_184;
                    float ***l_338 = &l_337;
                    int32_t l_341 = 0x627B09AB;
                    float *l_343 = (void*)0;
                    float *l_344 = &l_265;
                    (*l_327) = &l_185;
                    /* statement id: 88 */
                    assert (l_184 == &l_185);
                    l_329 = func_11(l_328, &p_52);
                    /* statement id: 89 */
                    assert (l_329 == 0);
                    (*l_344) = ((((float)((float)((float)(((l_336 != l_338) == (0x0.7A895Cp+79 == ((((float)p_52 + (float)l_341) > 0x1.80B7B1p-5) < ((**l_336) != (**l_338))))) != p_52) * (float)p_51) / (float)(-0x1.Fp+1)) * (float)l_341) == p_51) == l_342);
                }
                /* facts after branching */
                assert (l_329 == 0 || l_329 == &l_176);
                return p_52;
            }
            else
            { /* block id: 93 */
                int32_t *l_347 = &l_176;
                struct S0 **l_383 = (void*)0;
                struct S0 *l_402 = (void*)0;
                int32_t **l_419 = &l_328;
                int32_t *l_457 = &l_185.f5;
                if (((*l_329) , (~p_52)))
                { /* block id: 94 */
                    int32_t l_349 = 1;
                    float ***l_380 = &l_337;
                    struct S0 *l_381 = &l_364;
                    if ((l_189 == (void*)0))
                    { /* block id: 95 */
                        int32_t **l_348 = &l_329;
                        (*l_348) = func_67((*l_188), p_51, l_346, func_11(l_347, &p_52));
                        /* statement id: 96 */
                        assert (l_329 == 0);
                        (**l_240) = (void*)0;
                        /* statement id: 97 */
                        assert (l_66 == 0);
                        (*l_347) = (l_349 < (((int16_t)((int32_t)((int16_t)((uint16_t)p_51 << (uint16_t)((int16_t)(-6) << (int16_t)4)) << (int16_t)13) + (int32_t)((((uint32_t)((int16_t)(l_364 , (((((uint32_t)(((l_346 , (-(int16_t)((uint16_t)(0x8DBD902C | ((((float)((float)p_51 + (float)((float)((float)0x0.0p+1 * (float)(-0x1.Fp-1)) * (float)p_51)) + (float)p_52) , 1) == p_51)) >> (uint16_t)p_51))) >= p_51) == l_349) / (uint32_t)0x99B82E74) ^ 0) , (void*)0) != l_380)) + (int16_t)p_51) / (uint32_t)(*l_188)) & p_52) < 0x32D8)) - (int16_t)p_51) == p_52));
                    }
                    else
                    { /* block id: 99 */
                        struct S0 **l_382 = &l_381;
                        (*l_382) = l_381;
                    }
                    /* facts after branching */
                    assert (l_329 == &l_176 || l_329 == 0);
                }
                else
                { /* block id: 102 */
                    int32_t *l_397 = &l_185.f1;
                    struct S0 *l_403 = &l_185;
                    (*l_329) = (((((void*)0 == l_383) >= ((int32_t)p_51 % (int32_t)((uint16_t)p_51 * (uint16_t)65531U))) != (((~(((((uint16_t)2U / (uint16_t)(((int16_t)((*l_347) != ((!(((((uint32_t)(((((~0x3428C04C) & ((((p_52 , (void*)0) == &l_329) , (void*)0) != l_397)) || 1U) , (*l_347)) == p_51) % (uint32_t)0x96438B3E) , 4) , 0xF6D669E6) > (*l_397))) >= 0xE82D)) * (int16_t)9) | p_52)) || p_52) & 0x2639) && p_51)) , (*l_397)) >= 0x94C1EBE1)) > (*l_329));
                    for (l_176 = 0; (l_176 >= 5); l_176 += 5)
                    { /* block id: 106 */
                        int16_t l_410 = 0xAA44;
                        (*l_65) = l_347;
                        /* statement id: 107 */
                        assert (l_66 == &l_176);
                        (*l_65) = ((((float)(((l_402 != l_403) == (((float)((&p_52 != l_397) == ((((int16_t)p_52 * (int16_t)(*l_347)) , (((float)0x3.B88D47p+75 * (float)l_410) , ((((*l_240) != &l_347) || 0x0FEE) , (void*)0))) != l_411)) - (float)0x0.0p+1) == (*l_188))) > (-0x8.1p-1)) * (float)(-0x1.5p-1)) == (**l_65)) , &p_52);
                        /* statement id: 108 */
                        assert (l_66 == &p_52);
                    }
                }
                /* facts after branching */
                assert (l_329 == &l_176 || l_329 == 0);
                l_413 = ((*l_347) | (*l_188));
                for (l_364.f2 = 7; (l_364.f2 == 10); l_364.f2 += 1)
                { /* block id: 114 */
                    struct S0 **l_418 = (void*)0;
                    int32_t l_438 = 0xC4D84C3E;
                }
            }
            /* facts after branching */
            assert (l_329 == &l_176 || l_329 == 0);
            l_477 = &l_411;
            /* statement id: 126 */
            assert (l_477 == &l_411);
            (*l_65) = &p_52;
            /* statement id: 127 */
            assert (l_66 == &p_52);
        }
        /* facts after branching */
        assert (l_66 == &p_52);
        assert (l_201 == &l_184 || l_201 == 0);
        assert (l_329 == &l_176 || l_329 == 0);
        assert (l_477 == &l_411 || l_477 == &l_478);
        (**l_65) = ((uint16_t)p_52 - (uint16_t)((((uint16_t)((**l_65) , ((uint16_t)(((l_486 <= l_487) , ((int16_t)(l_490 != (p_51 , &l_477)) + (int16_t)((int16_t)(-7) << (int16_t)6))) ^ (((p_51 , 0x4125B070) , p_51) >= p_51)) >> (uint16_t)8)) / (uint16_t)(*l_66)) < p_52) > p_52));
    }
    /* facts after branching */
    //assert (l_477 == dangling || l_477 == &l_478);
    (*l_65) = (void*)0;
    /* statement id: 131 */
    assert (l_66 == 0);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_55(int32_t ** p_56, uint16_t  p_57, int32_t  p_58, int16_t  p_59)
{ /* block id: 40 */
    uint32_t l_174 = 0x0604E30F;
    return l_174;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_60(float  p_61, int32_t ** p_62, int32_t  p_63)
{ /* block id: 8 */
    float l_72 = 0xA.6189EFp+19;
    int32_t l_73 = 0x264A05A9;
    const struct S0 l_74 = {3,1,4294967287U,0x1C2B46DF,4,0x1739BB5F,14,0U,0x6E9900F1,5};
    int32_t *l_114 = (void*)0;
    int32_t **l_113 = &l_114;
    float *l_115 = &l_72;
    uint32_t l_129 = 0U;
    int32_t **l_160 = &l_114;
    int32_t **l_161 = &l_114;
    int32_t **l_162 = &l_114;
    int32_t **l_163 = &l_114;
    int32_t **l_164 = &l_114;
    int32_t **l_165 = &l_114;
    int32_t **l_166 = &l_114;
    int32_t **l_167 = &l_114;
    int32_t **l_168 = &l_114;
    int32_t **l_169 = &l_114;
    int32_t **l_170 = &l_114;
    int32_t **l_171 = &l_114;
    int32_t **l_172 = &l_114;
    int32_t **l_173 = (void*)0;
    (*p_62) = func_11((*p_62), func_67(l_72, l_73, l_74, &l_73));
    if ((((p_62 != l_113) < 65530U) ^ (l_115 != (void*)0)))
    { /* block id: 15 */
        int32_t *l_116 = (void*)0;
        (*l_113) = l_116;
        (*l_113) = func_11((*p_62), func_2(l_116, p_63, l_116, l_74));
        /* statement id: 17 */
        //assert (l_114 == 0 || l_114 == &p_52);
    }
    else
    { /* block id: 18 */
        float l_121 = 0xD.58447Ap-76;
        int32_t **l_122 = &l_114;
        int32_t l_130 = 0xC6DFE233;
        int32_t *l_131 = &l_130;
        int32_t **l_132 = &l_131;
        struct S0 l_156 = {2,0,0xA7FF29F3,0x5184A0F1,4,0x884B0028,35,0x080E1D11,0,0};
        struct S0 *l_155 = &l_156;
        (*l_131) = (((uint32_t)(p_63 | (((uint16_t)(((((p_63 , &l_114) == l_122) >= ((uint32_t)(((p_63 , ((uint16_t)65529U * (uint16_t)0U)) < ((-1) > ((uint16_t)p_63 * (uint16_t)p_63))) < p_63) + (uint32_t)p_63)) , l_129) <= p_63) - (uint16_t)p_63) >= p_63)) / (uint32_t)l_130) >= p_63);
        if (p_63)
        { /* block id: 20 */
lbl_159:
            (*l_115) = 0x1.42021Ap+50;
        }
        else
        { /* block id: 22 */
            int32_t ***l_133 = &l_122;
            (*l_133) = l_132;
            /* statement id: 23 */
            assert (l_122 == &l_131);
        }
        /* facts after branching */
        //assert (l_66 == &l_73 || l_66 == 0 || l_66 == &p_52);
        assert (l_122 == &l_131 || l_122 == &l_114);
        for (l_73 = 0; (l_73 > (-14)); l_73 -= 1)
        { /* block id: 27 */
            struct S0 l_154 = {4,0x8D29CDFB,0U,0xBB376373,0,-10,33,4294967286U,0x13543D04,6};
            struct S0 **l_157 = &l_155;
            int32_t *l_158 = &l_73;
            for (l_129 = (-8); (l_129 != 40); l_129 += 6)
            { /* block id: 30 */
                float *l_143 = &l_121;
                struct S0 l_151 = {2,-8,0x58CD6ACD,4294967295U,0,9,9,0U,0x1AB64908,1};
                (**l_132) = (!((uint16_t)((uint16_t)(l_143 != l_143) >> (uint16_t)((uint16_t)65531U << (uint16_t)13)) * (uint16_t)p_63));
                (*l_131) = ((((((0x3C0F <= 0U) && 0xFD28FE82) == (((((-6) & (((int16_t)(-(uint16_t)((uint16_t)p_63 >> (uint16_t)10)) * (int16_t)(p_63 && (l_151 , ((uint32_t)(l_154 , (((65529U & p_63) <= 65530U) <= p_63)) - (uint32_t)l_151.f1)))) > p_63)) > 0x2A91ADE1) | p_63) , (-1))) & 0x75E0) ^ 1) , (**l_132));
            }
            (*l_157) = l_155;
            (*p_62) = l_158;
            /* statement id: 35 */
            //assert (l_66 == &l_73);
        }
        if (l_74.f3)
            goto lbl_159;
    }
    /* facts after branching */
    //assert (l_66 == &l_73 || l_66 == 0 || l_66 == &p_52);
    //assert (l_114 == 0 || l_114 == &p_52);
    return l_173;
    /* statement id: 39 */
    //assert (l_66 == dangling || l_66 == 0 || l_66 == &p_52);
    //assert (func_60_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_67(float  p_68, int32_t  p_69, const struct S0  p_70, int32_t * p_71)
{ /* block id: 9 */
    uint16_t l_77 = 65529U;
    int32_t l_89 = 1;
    int32_t *l_88 = &l_89;
    int32_t **l_87 = &l_88;
    float l_92 = 0x5.7p-1;
    struct S0 l_103 = {3,0x49D53036,0xC05FD73F,0xFB248F24,3,-10,120,0xAF9C35C0,4,2};
    int32_t **l_106 = &l_88;
    float *l_111 = &l_92;
    const int32_t *l_112 = (void*)0;
    (*p_71) = (((uint32_t)p_70.f2 / (uint32_t)l_77) | (((~(((uint16_t)l_77 << (uint16_t)((uint16_t)l_77 >> (uint16_t)(((1 != (((~(l_77 ^ ((~((void*)0 != l_87)) >= ((((uint16_t)p_70.f5 * (uint16_t)0x3925) <= 1) > 0xEA09)))) && 0) != p_70.f7)) <= (**l_87)) && (*l_88)))) | p_70.f0)) ^ p_70.f8) >= (**l_87)));
    (*l_106) = func_2(func_11((*l_87), (*l_87)), ((int16_t)((*l_88) , (((int16_t)((int32_t)((int16_t)(*l_88) % (int16_t)(((((((((float)((**l_87) >= (l_103 , (*l_88))) * (float)((float)((0x0.Bp+1 == (*l_88)) < 0x5.DE22B7p+39) * (float)p_70.f1)) , &p_71) == (void*)0) , 2U) & 0xAA1C) <= 4294967294U) , (*p_71)) & (*p_71))) + (int32_t)(*l_88)) * (int16_t)p_70.f5) , (-1))) >> (int16_t)(*l_88)), (*l_87), p_70);
    /* statement id: 11 */
    assert (l_88 == 0);
    (*l_111) = ((*l_87) == (((uint16_t)((uint16_t)65530U >> (uint16_t)2) >> (uint16_t)9) , &p_69));
    return l_112;
    /* statement id: 13 */
    //assert (func_67_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 154
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 26
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 3

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 17
   depth: 3, occurrence: 4
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 2
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 160

XXX times a variable address is taken: 156
XXX times a pointer is dereferenced on RHS: 107
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 17
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 66
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 5
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 381

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 343
   level: 2, occurrence: 109
   level: 3, occurrence: 30
   level: 4, occurrence: 7
XXX number of pointers point to pointers: 97
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 30
XXX average alias set size: 1.2

XXX times a non-volatile is read: 755
XXX times a non-volatile is write: 172
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 121
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 24
   depth: 2, occurrence: 16
   depth: 3, occurrence: 18
   depth: 4, occurrence: 13
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 15.8
XXX percentage an existing variable is used: 84.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

