/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1526523106
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const unsigned f0 : 31;
   signed f1 : 24;
};
#pragma pack(pop)

union U1 {
   unsigned f0 : 2;
   const unsigned f1 : 31;
   uint32_t  f2;
   uint32_t  f3;
   int16_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static uint16_t  func_11(int32_t * const  p_12, const int16_t  p_13, struct S0  p_14);
static int32_t * func_15(int32_t * p_16, int32_t * p_17, int32_t * p_18, int32_t * p_19);
static int32_t * func_20(int32_t  p_21, int16_t  p_22, int32_t * const  p_23, union U1  p_24, int16_t  p_25);
static int32_t * func_28(int32_t  p_29, int32_t * p_30, int32_t  p_31);
static const float  func_52(uint32_t  p_53, int32_t ** p_54, int32_t ** const  p_55, int32_t * p_56);
static uint32_t  func_57(int32_t ** p_58, const uint32_t  p_59, int32_t * p_60);
static int32_t ** func_61(float * p_62, int32_t * p_63, struct S0  p_64, uint32_t  p_65, int32_t  p_66);
static uint16_t  func_70(int32_t ** p_71, int32_t * p_72);
static int32_t * func_74(float * p_75, int32_t ** p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x52C58FB7;
    struct S0 l_510 = {39992,3963};
    float l_514 = (-0x5.0p-1);
    uint32_t l_515 = 0U;
    uint32_t l_535 = 0U;
    for (l_2 = 0; (l_2 < (-22)); l_2 = safe_sub_func_int32_t_s_s(l_2, 1))
    { /* block id: 3 */
        int32_t l_6 = 0x35A23E86;
        int32_t *l_5 = &l_6;
        union U1 l_40 = {0x8FB6F85A};
        (*l_5) = l_2;
        if ((*l_5))
            continue;
        (*l_5) = ((safe_lshift_func_int16_t_s_u(((safe_lshift_func_uint16_t_u_s((func_11(func_15(func_20((safe_div_func_uint16_t_u_u(l_2, (*l_5))), (*l_5), func_28(((safe_lshift_func_uint16_t_u_s(0x442E, 1)) > ((void*)0 != &l_2)), &l_6, ((&l_6 == (void*)0) & 0x09984333)), l_40, l_2), &l_2, &l_6, &l_2), l_40.f0, l_510) < l_515), l_515)) | 0xEAA68DCC), 10)) == l_515);
        return l_510.f1;
    }
    l_2 = (-(safe_mul_func_float_f_f((safe_sub_func_float_f_f((safe_mul_func_float_f_f((safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_mul_func_float_f_f((-0x1.0p+1), (-0x1.7p+1))), l_515)), ((l_510.f0 == (safe_div_func_float_f_f((((safe_div_func_float_f_f(((-0x1.Dp+1) < ((safe_mul_func_float_f_f(l_510.f1, l_510.f0)) == (((-0x10.Ep-1) <= ((-0x4.Dp+1) > l_2)) >= l_2))), l_515)) != l_2) >= 0x0.1p-1), l_515))) != l_510.f1))), l_510.f0)), l_510.f1)), (-0x9.6p+1))));
    return l_535;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_11(int32_t * const  p_12, const int16_t  p_13, struct S0  p_14)
{ /* block id: 192 */
    int32_t l_512 = 0xBC324865;
    int32_t *l_511 = &l_512;
    int32_t **l_513 = &l_511;
    (*l_513) = l_511;
    return p_14.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_15(int32_t * p_16, int32_t * p_17, int32_t * p_18, int32_t * p_19)
{ /* block id: 117 */
    uint32_t l_293 = 4294967294U;
    struct S0 l_296 = {29328,-3448};
    struct S0 *l_295 = &l_296;
    struct S0 **l_294 = &l_295;
    const uint32_t l_307 = 0xEA3B3628;
    struct S0 ***l_315 = &l_294;
    struct S0 *** const *l_314 = &l_315;
    struct S0 *** const * const *l_313 = &l_314;
    int32_t l_329 = 7;
    int32_t *l_328 = &l_329;
    int32_t **l_327 = &l_328;
    int32_t ***l_326 = &l_327;
    float l_333 = 0xD.C7E725p-1;
    float *l_332 = &l_333;
    float **l_331 = &l_332;
    float ***l_330 = &l_331;
    uint16_t l_334 = 65535U;
    union U1 l_371 = {0xA246DCAA};
    union U1 *l_370 = &l_371;
    union U1 **l_369 = &l_370;
    uint32_t l_383 = 0x9EC8A6BB;
    (*p_18) = (((safe_sub_func_uint32_t_u_u((l_293 < (l_293 & (l_294 != &l_295))), (safe_unary_minus_func_int16_t_s((l_296.f1 < (((l_296.f1 & ((((l_296.f0 > (safe_lshift_func_int16_t_s_u((((~(l_293 | (l_293 != 1U))) || l_296.f0) && 1), l_296.f1))) > l_293) ^ l_296.f0) >= (*p_18))) ^ l_293) > l_293)))))) < l_296.f1) >= 65533U);
    (*p_18) = (safe_mod_func_int16_t_s_s(l_293, ((safe_div_func_uint32_t_u_u(l_307, (safe_lshift_func_int16_t_s_s((((((safe_mul_func_int16_t_s_s((!((void*)0 == l_313)), (&l_314 == &l_314))) > (0x5D28 | (safe_lshift_func_uint16_t_u_u(0xED51, 4)))) <= (safe_mod_func_int16_t_s_s(((void*)0 != (*l_313)), 0xF6D4))) > l_293) && 1U), l_296.f0)))) ^ (*p_19))));
    if ((safe_rshift_func_uint16_t_u_s((l_296.f0 & ((&l_314 == &l_314) ^ (safe_lshift_func_uint16_t_u_u((0xEF6E & ((safe_sub_func_uint32_t_u_u(l_296.f1, (((l_293 || (l_326 == &l_327)) & (((void*)0 != l_330) ^ (***l_326))) && (**l_327)))) && (**l_327))), 10)))), l_334)))
    { /* block id: 120 */
        int32_t *l_335 = &l_329;
        p_18 = l_335;
        /* statement id: 121 */
        assert (p_18 == &l_329);
    }
    else
    { /* block id: 122 */
        int32_t ***l_336 = &l_327;
        struct S0 ****l_339 = (void*)0;
        struct S0 *****l_338 = &l_339;
        union U1 l_356 = {0xF2044AD6};
        union U1 *l_355 = &l_356;
        const float ****l_381 = (void*)0;
        int32_t l_385 = 0x192C8C10;
        int16_t l_478 = 4;
        (**l_326) = p_18;
        /* statement id: 123 */
        //assert (l_328 == &l_6);
        (**l_326) = (**l_326);
        if ((l_336 != &l_327))
        { /* block id: 125 */
            struct S0 *****l_337 = (void*)0;
            int32_t l_342 = 0x4875687A;
            float *l_354 = &l_333;
            union U1 **l_357 = &l_355;
            l_338 = l_337;
            /* statement id: 126 */
            assert (l_338 == 0);
            (**l_331) = (safe_div_func_float_f_f((((l_342 == (safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f(l_342, ((safe_add_func_float_f_f(0x0.9A4F97p+4, (***l_326))) <= ((((safe_sub_func_float_f_f((l_342 != (-l_342)), ((*l_328) <= (l_354 != (void*)0)))) < l_342) != l_342) != (***l_336))))), 0x4.4p-1)), (***l_336)))) > (***l_336)) <= l_342), (*l_328)));
            (*l_357) = l_355;
        }
        else
        { /* block id: 129 */
            union U1 **l_372 = &l_355;
            float ****l_382 = &l_330;
            int32_t l_384 = 0x76D62126;
            struct S0 ***l_393 = &l_294;
            float *l_411 = &l_333;
            int32_t *l_414 = &l_384;
            for (l_356.f2 = 0; (l_356.f2 == 24); ++l_356.f2)
            { /* block id: 132 */
                uint32_t l_368 = 0x2F69E9B9;
                struct S0 **l_391 = &l_295;
                float **l_412 = &l_411;
                int32_t *l_413 = (void*)0;
            }
            /* facts after for loop */
                    }
        /* facts after branching */
        assert (l_338 == &l_339 || l_338 == 0);
        for (l_385 = (-22); (l_385 > 22); l_385++)
        { /* block id: 167 */
            uint32_t l_432 = 0x27C97B53;
            struct S0 ** const *l_440 = &l_294;
            union U1 **l_447 = &l_355;
            float **l_457 = &l_332;
            float **l_506 = &l_332;
            for (l_356.f2 = 0; (l_356.f2 > 54); ++l_356.f2)
            { /* block id: 170 */
                struct S0 **** const l_423 = (void*)0;
                int32_t l_424 = 0x8D6BE13D;
                float ***l_446 = &l_331;
                union U1 ** const l_448 = &l_370;
                int16_t l_450 = 0x9EB0;
                const int16_t l_507 = 0x1844;
                if ((l_423 != (void*)0))
                { /* block id: 171 */
                    const int16_t l_425 = 0xB37F;
                    if (l_424)
                        break;
                    (***l_326) = (l_425 <= (safe_lshift_func_int16_t_s_s((safe_mul_func_int16_t_s_s((((safe_div_func_uint16_t_u_u(((l_432 > (((safe_add_func_uint32_t_u_u((***l_326), 0x428AFD14)) && (***l_336)) > ((safe_unary_minus_func_int32_t_s((safe_add_func_uint16_t_u_u(0x0B57, ((0 >= ((safe_add_func_int16_t_s_s(((void*)0 == l_440), (***l_326))) >= (***l_336))) ^ (*l_328)))))) | l_432))) | 65530U), (*l_328))) != (***l_326)) == l_424), 0xD233)), 13)));
                }
                else
                { /* block id: 174 */
                    float ***l_445 = &l_331;
                    int32_t l_449 = 0x46030F7A;
                    struct S0 *****l_455 = &l_339;
                    if (((*p_17) && ((safe_lshift_func_int16_t_s_s(0x913A, (((safe_add_func_uint32_t_u_u((l_445 == l_446), (l_447 != l_448))) || (4 == ((l_449 >= (l_424 > l_450)) == l_432))) && 0x4564A286))) && l_449)))
                    { /* block id: 175 */
                        uint16_t l_456 = 0x84DC;
                        (*p_18) = (l_432 && (((l_449 | (safe_mul_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((((void*)0 != l_455) == (((l_424 > (l_456 < (((***l_336) == l_456) != 0x5835))) ^ l_449) && l_456)), l_432)), 1))) <= l_456) || 3));
                        (*l_446) = l_457;
                        (*l_332) = (-((0x6.9p-1 >= ((safe_sub_func_float_f_f(((**l_336) != (void*)0), ((((safe_div_func_float_f_f((l_449 == (((*l_440) != (void*)0) != (l_432 >= ((safe_div_func_float_f_f((safe_div_func_float_f_f((!(safe_div_func_float_f_f(((-0xB.0C4CCBp+41) != (***l_336)), 0x6.DD0C4Fp+6))), 0x3.510F08p+92)), l_432)) != 0x4.FE50BEp-66)))), (***l_336))) > 0x1.7p+1) > l_450) > l_449))) == 0x4.DBFB0Ap+0)) < (***l_336)));
                    }
                    else
                    { /* block id: 179 */
                        const int16_t l_477 = 0xFFAD;
                        int32_t **l_479 = &l_328;
                        (***l_326) = (safe_sub_func_int32_t_s_s((safe_sub_func_uint16_t_u_u((((safe_mul_func_uint16_t_u_u(((***l_336) <= (((void*)0 == l_455) & l_424)), (((***l_326) > l_450) == (l_477 > (*l_328))))) != (((65535U >= l_477) <= (*p_17)) | l_432)) && l_432), 0U)), l_478));
                        (**l_336) = func_74(p_19, l_479);
                        (***l_326) = 0x7BDA3A7E;
                    }
                    (***l_336) = (-(safe_sub_func_float_f_f((safe_div_func_float_f_f(((safe_mul_func_float_f_f((l_450 <= (safe_sub_func_float_f_f((safe_add_func_float_f_f((-0x4.4p-1), (safe_add_func_float_f_f(l_424, (safe_div_func_float_f_f((safe_sub_func_float_f_f((0xF.868F2Ep+48 == (safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f(((!(((void*)0 == (*l_445)) > ((safe_div_func_float_f_f((0x0.0D7603p+78 == (**l_327)), ((*l_445) == l_506))) > l_449))) != 0xC.31E0E6p+52), l_449)), 0x0.736599p-86)), 0x7.F01A00p+14))), (**l_327))), (***l_336))))))), (***l_336)))), l_449)) != l_432), l_450)), l_507)));
                    (*p_18) = (safe_rshift_func_int16_t_s_s((0x4CEBC7E2 | 9U), 3));
                    (*l_448) = (*l_447);
                    /* statement id: 186 */
                    assert (l_370 == &l_356);
                }
            }
            /* facts after for loop */
                    }
        /* facts after for loop */
        assert (l_370 == &l_356 || l_370 == &l_371);
    }
    /* facts after branching */
    //assert (p_18 == &l_6 || p_18 == &l_329);
    //assert (l_328 == &l_6 || l_328 == &l_329);
    //assert (l_370 == dangling || l_370 == &l_371);
    return p_19;
    /* statement id: 191 */
    //assert (func_15_rv == &l_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_20(int32_t  p_21, int16_t  p_22, int32_t * const  p_23, union U1  p_24, int16_t  p_25)
{ /* block id: 9 */
    int32_t l_44 = 0xF0B56FE1;
    int32_t *l_43 = &l_44;
    float l_46 = 0x0.6p+1;
    float *l_45 = &l_46;
    int32_t *l_67 = (void*)0;
    struct S0 l_282 = {16262,-2158};
    const float *l_287 = (void*)0;
    const float **l_286 = &l_287;
    const float *** const l_285 = &l_286;
    const float ****l_288 = (void*)0;
    const float ***l_289 = &l_286;
    int32_t *l_290 = (void*)0;
    (*l_45) = (safe_sub_func_float_f_f((p_23 != l_43), 0x0.Ep+1));
    (*l_45) = p_22;
    for (p_21 = 11; (p_21 >= 11); p_21 = safe_sub_func_uint32_t_u_u(p_21, 1))
    { /* block id: 14 */
        int32_t *l_69 = &l_44;
        struct S0 l_231 = {7331,1234};
        int32_t l_280 = (-1);
        for (p_25 = (-16); (p_25 != (-28)); p_25 = safe_sub_func_int32_t_s_s(p_25, 1))
        { /* block id: 17 */
            int32_t **l_73 = (void*)0;
            int32_t l_281 = (-9);
            int32_t * const **l_283 = (void*)0;
            int32_t ***l_284 = &l_73;
        }
    }
    l_289 = l_285;
    return l_290;
    /* statement id: 116 */
    //assert (func_20_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_28(int32_t  p_29, int32_t * p_30, int32_t  p_31)
{ /* block id: 6 */
    int32_t l_38 = 1;
    int32_t *l_37 = &l_38;
    int32_t **l_36 = &l_37;
    int32_t *l_39 = (void*)0;
    (*l_36) = (void*)0;
    /* statement id: 7 */
    assert (l_37 == 0);
    return l_39;
    /* statement id: 8 */
    //assert (func_28_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_52(uint32_t  p_53, int32_t ** p_54, int32_t ** const  p_55, int32_t * p_56)
{ /* block id: 105 */
    int16_t l_246 = (-1);
    float *l_247 = (void*)0;
    float l_249 = 0x0.14AA58p+66;
    float *l_248 = &l_249;
    (*l_248) = l_246;
    (*p_54) = l_248;
    /* statement id: 107 */
    //assert (l_67 == &l_249);
    (*l_248) = ((0x4.14CA56p+8 == (((l_246 < 0xE.509144p+77) >= p_53) > (safe_sub_func_float_f_f((safe_mul_func_float_f_f((safe_sub_func_float_f_f(((((&p_55 != (void*)0) >= (safe_add_func_float_f_f((((safe_div_func_float_f_f(((safe_add_func_float_f_f(l_246, ((safe_mul_func_float_f_f((0xF.19477Fp+58 >= ((safe_sub_func_float_f_f(0x1.6p+1, p_53)) > l_246)), l_246)) > 0x8.18EB07p+80))) < 0x4.208FF1p+98), l_246)) >= p_53) <= p_53), 0x1.Dp-1))) != l_246) != 0x6.1p-1), p_53)), 0x4.28DFF6p-84)), l_246)))) != 0x0.76B1AFp+43);
    return l_246;
    /* statement id: 109 */
    //assert (l_67 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_57(int32_t ** p_58, const uint32_t  p_59, int32_t * p_60)
{ /* block id: 102 */
    int32_t **l_243 = (void*)0;
    int32_t *l_245 = (void*)0;
    int32_t **l_244 = &l_245;
    (*l_244) = (void*)0;
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_61(float * p_62, int32_t * p_63, struct S0  p_64, uint32_t  p_65, int32_t  p_66)
{ /* block id: 98 */
    int32_t l_234 = 0xC0BEA8BF;
    int32_t l_240 = 0x438D6BD4;
    int32_t *l_239 = &l_240;
    int32_t **l_241 = &l_239;
    int32_t **l_242 = (void*)0;
    (*l_239) = (0x7.959A08p+82 < ((safe_mul_func_float_f_f((l_234 != ((safe_sub_func_float_f_f((l_234 == (-0x1.2p-1)), (safe_div_func_float_f_f((l_239 == &l_240), (*l_239))))) <= (((0x4.3E69D1p-35 != (*l_239)) > 0x2.2p+1) <= 0x5.2957CEp+45))), (*l_239))) == (*l_239)));
    p_63 = (void*)0;
    /* statement id: 100 */
    assert (p_63 == 0);
    return l_242;
    /* statement id: 101 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_70(int32_t ** p_71, int32_t * p_72)
{ /* block id: 21 */
    int32_t l_83 = 0x308456A9;
    int32_t *l_103 = &l_83;
    int32_t **l_102 = &l_103;
    float l_108 = 0x3.F2F083p+47;
    struct S0 l_196 = {6777,1663};
    struct S0 *l_195 = &l_196;
    struct S0 **l_194 = &l_195;
    struct S0 ***l_193 = &l_194;
    struct S0 ****l_192 = &l_193;
    int16_t l_230 = 0x3716;
    for (l_83 = 0; (l_83 >= 7); l_83++)
    { /* block id: 24 */
        int32_t l_86 = 0xB5DF1D97;
        int32_t l_107 = 7;
        float *l_130 = &l_108;
        int32_t **l_150 = (void*)0;
        struct S0 *****l_210 = (void*)0;
        int32_t ***l_227 = &l_150;
        for (l_86 = (-27); (l_86 == 18); l_86 = safe_add_func_uint32_t_u_u(l_86, 3))
        { /* block id: 27 */
            int32_t *l_89 = &l_83;
            int32_t l_90 = 0x3460EE42;
            struct S0 l_171 = {40646,1040};
            struct S0 *l_170 = &l_171;
            struct S0 **l_169 = &l_170;
            struct S0 *** const l_168 = &l_169;
            float **l_225 = &l_130;
            l_89 = l_89;
        }
        (*l_227) = l_150;
    }
    for (l_83 = 7; (l_83 <= 1); l_83 = safe_sub_func_uint32_t_u_u(l_83, 1))
    { /* block id: 92 */
    }
    (*l_103) = 0x1.1p+1;
    return l_230;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(float * p_75, int32_t ** p_76)
{ /* block id: 18 */
    struct S0 l_78 = {39478,2459};
    struct S0 * const l_77 = &l_78;
    struct S0 *l_80 = &l_78;
    struct S0 **l_79 = &l_80;
    int32_t l_82 = 1;
    int32_t *l_81 = &l_82;
    (*l_79) = l_77;
    return (*p_76);
    /* statement id: 20 */
    //assert (func_74_rv == &l_44 || func_74_rv == &l_83 || func_74_rv == &l_6);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 106
   depth: 1, occurrence: 3
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 3
breakdown:
   indirect level: 0, occurrence: 3
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 22

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
   depth: 13, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 129

XXX times a variable address is taken: 118
XXX times a pointer is dereferenced on RHS: 108
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 10
   depth: 3, occurrence: 26
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 8
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 310

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 173
   level: 2, occurrence: 33
   level: 3, occurrence: 54
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 71
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 31
XXX average alias set size: 1.28

XXX times a non-volatile is read: 592
XXX times a non-volatile is write: 172
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 62
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 12
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
   depth: 4, occurrence: 6
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

