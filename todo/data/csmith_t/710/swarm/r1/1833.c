/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3874350736
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
   const uint32_t  f1;
};

union U1 {
   int16_t  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   float  f4;
};

union U2 {
   unsigned f0 : 22;
   uint8_t  f1;
   const float  f2;
};

/* --- GLOBAL VARIABLES --- */
static union U1 g_41 = {0x18C8};
static int32_t g_64 = 0x647D02C9;
static int32_t *g_76 = (void*)0;
static int32_t **g_75 = &g_76;
static union U2 g_77 = {0x3AC46406};
static union U0 g_89 = {0x79E2};
static uint32_t g_402 = 8U;
static union U1 *g_460 = &g_41;
static union U1 **g_459 = &g_460;
static union U0 g_477 = {5U};
static union U0 *g_476 = &g_477;
static int32_t ***g_502 = (void*)0;
static int32_t ****g_501 = &g_502;
static int32_t *****g_500 = &g_501;
static const union U2 g_572 = {0x3C11021A};
static const union U2 *g_571 = &g_572;
static int32_t g_616 = 0xECD1C566;
static int32_t g_793 = (-6);
static float g_816 = 0x6.6p-1;
static union U0 **g_973 = &g_476;
static union U0 ***g_972 = &g_973;


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_1(void);
static union U1 * func_2(union U0  p_3);
static union U0  func_4(int32_t  p_5, union U1  p_6);
inline static int16_t  func_9(union U1 * p_10, uint16_t  p_11, union U1 * p_12, union U1 * p_13);
static union U1 * func_14(union U1 * p_15, union U1 * p_16, union U0  p_17);
static union U1 * func_18(union U1 * p_19, uint8_t  p_20);
static union U1 * func_21(union U1 * p_22);
inline static union U1 * func_23(float  p_24, uint16_t  p_25);
static float  func_32(float  p_33, int32_t  p_34);
inline static union U1 * func_36(union U1 * p_37, uint32_t  p_38, union U1 * p_39);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_41 g_41.f0 g_41.f2 g_75 g_77 g_64 g_89.f0 g_41.f1 g_41.f3 g_77.f0 g_89 g_76 g_816 g_459 g_460 g_571 g_572 g_793 g_402 g_616 g_41.f4 g_501 g_502 g_500 g_476 g_477 g_972
 * writes: g_64 g_41.f2 g_41.f4 g_76 g_89.f0 g_41.f3 g_476 g_816 g_501 g_616 g_460
 */
inline static union U1  func_1(void)
{ /* block id: 0 */
    int16_t l_35 = (-1);
    union U1 *l_40 = &g_41;
    uint8_t l_65 = 4U;
    int16_t l_66 = 0x8622;
    union U0 l_826 = {0x58F3};
    const int32_t l_877 = 0x55516C8F;
    union U1 l_878 = {0xF372};
    (*g_459) = func_2(func_4(((int16_t)(((-1) <= func_9(func_14(func_18(func_21(func_23((((((float)((float)(((float)(func_32(((l_35 , func_36(l_40, ((int16_t)(((int16_t)(g_41 , (((int16_t)((int32_t)l_35 + (int32_t)(((uint16_t)l_35 * (uint16_t)(l_40 == l_40)) , (0x7C29 == g_41.f0))) % (int16_t)g_41.f0) ^ g_41.f0)) << (int16_t)11) , l_35) / (int16_t)g_41.f0), l_40)) != (void*)0), l_65) > g_41.f0) * (float)(-0x1.Cp+1)) != g_41.f0) / (float)g_41.f0) + (float)0x0.FEA44Ep-21) >= l_35) >= l_65) == g_41.f0), l_66)), l_66), l_40, l_826), l_826.f0, (*g_459), (*g_459))) > g_793) + (int16_t)l_877), l_878));
    /* statement id: 232 */
        //assert (g_76 == dangling);
    assert (g_476 == &g_89 || g_476 == &g_477);
    return (*g_460);
    /* statement id: 233 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_75 g_76 g_41.f2 g_476 g_89 g_477 g_816 g_41.f1 g_972 g_41.f3 g_460
 * writes: g_64 g_76
 */
static union U1 * func_2(union U0  p_3)
{ /* block id: 227 */
    const union U2 l_949 = {0U};
    int32_t l_950 = (-2);
    union U1 **l_953 = &g_460;
    union U2 *l_955 = &g_77;
    union U2 **l_954 = &l_955;
    (**g_75) = (p_3.f0 == ((+((uint16_t)(((l_949 , &l_949) == &l_949) && l_950) % (uint16_t)((l_953 != &g_460) | (l_954 != (void*)0)))) == p_3.f0));
    (*g_75) = &l_950;
    /* statement id: 229 */
    assert (g_76 == &l_950);
    (**g_75) = ((g_41.f2 ^ (((uint32_t)((((int16_t)(((*g_476) , l_953) == l_953) << (int16_t)(((((float)g_41.f2 + (float)(l_949.f0 , (((((float)l_950 + (float)(((float)((float)(((float)(l_950 , 0x7.295F04p-70) * (float)p_3.f0) > 0x2.B48445p-83) / (float)(-0x6.Cp+1)) * (float)l_950) > g_816)) != p_3.f0) >= g_41.f1) == g_816))) , g_972) != &g_973) <= 0U)) > l_949.f0) <= 0x75F7) % (uint32_t)p_3.f0) < (-7))) || g_41.f3);
    return (*l_953);
    /* statement id: 231 */
    //assert (g_76 == dangling);
    //assert (func_2_rv == &g_41);
}


/* ------------------------------------------ */
/* 
 * reads : g_41.f3 g_41.f2 g_616 g_64 g_89.f0 g_402 g_76 g_75 g_459 g_460 g_41 g_793 g_77.f0 g_41.f4 g_501 g_502 g_571 g_572 g_500
 * writes: g_41.f3 g_476 g_41.f2 g_64 g_816 g_501 g_616
 */
static union U0  func_4(int32_t  p_5, union U1  p_6)
{ /* block id: 202 */
    uint32_t l_902 = 0x0C4C096A;
    union U0 l_906 = {2U};
    uint8_t l_919 = 0xD1;
    union U2 l_921 = {0x81547C4D};
    union U1 **l_938 = &g_460;
    int32_t *l_941 = &g_616;
    for (g_41.f3 = 0; (g_41.f3 != 6); g_41.f3 += 6)
    { /* block id: 205 */
        union U0 **l_881 = &g_476;
        if (p_6.f0)
            break;
        (*l_881) = &g_89;
        /* statement id: 207 */
        assert (g_476 == &g_89);
    }
    /* facts after for loop */
        assert (g_476 == &g_89 || g_476 == &g_477);
    for (g_41.f2 = 2; (g_41.f2 == 25); g_41.f2 += 1)
    { /* block id: 211 */
        int16_t l_884 = 0xB5B2;
        union U2 *l_897 = &g_77;
        union U0 **l_903 = &g_476;
        const float *l_937 = &g_816;
        int32_t l_939 = (-1);
        union U1 ***l_943 = &l_938;
        union U1 ****l_944 = (void*)0;
        union U1 ****l_945 = &l_943;
        if (l_884)
            break;
        if ((((int16_t)(((int16_t)0x9D73 - (int16_t)(((p_6.f0 <= ((int16_t)(((uint16_t)((((uint16_t)g_616 >> (uint16_t)9) >= ((uint16_t)(l_897 != l_897) + (uint16_t)((((float)((p_5 != (((0x4EBA7722 || ((((uint16_t)(g_64 < g_89.f0) >> (uint16_t)3) , &g_77) == &g_77)) & l_902) || 0x8F8B428D)) , l_884) * (float)p_6.f0) , l_902) , 3U))) | l_884) * (uint16_t)g_402) || p_5) - (int16_t)l_884)) , l_903) == (void*)0)) || g_64) << (int16_t)l_884) , (-1)))
        { /* block id: 213 */
            float *l_920 = &g_816;
            (**g_75) = (*g_76);
            (*l_920) = ((float)((l_906 , ((**g_459) , ((float)((float)l_884 - (float)(((float)g_64 - (float)((float)p_5 * (float)((float)(((p_6 , (0x6.428825p-93 >= (p_6.f0 <= (((float)((((p_5 != p_6.f0) | g_793) , 0x0.Ep+1) > p_5) / (float)p_6.f0) == 0x1.Ap+1)))) != p_6.f0) >= l_884) / (float)g_77.f0))) > 0x9.BC9C88p-8)) + (float)g_41.f4))) , l_919) / (float)g_402);
        }
        else
        { /* block id: 216 */
            uint32_t l_922 = 0x8627F563;
            int32_t ****l_940 = &g_502;
            int32_t *l_942 = &l_939;
            (**g_75) = (l_921 , ((void*)0 != (*g_501)));
            l_939 = ((l_922 == 0x0.Fp-1) >= (0x7.D0FB1Bp+5 <= ((-0x1.7p-1) <= (((p_5 <= (-(float)g_793)) , (((int32_t)((p_5 && ((((uint16_t)(((((uint16_t)(-(uint32_t)(((uint16_t)(((((*g_571) , (p_5 & l_884)) || 0) | p_5) >= p_6.f0) - (uint16_t)0x1D05) != g_77.f0)) + (uint16_t)p_6.f0) <= l_922) , (void*)0) != l_937) + (uint16_t)p_6.f0) < g_41.f3) != g_77.f0)) , (*g_76)) / (int32_t)(*g_76)) , l_938)) == &g_460))));
            (*g_500) = l_940;
            l_942 = l_941;
            /* statement id: 220 */
            assert (l_942 == &g_616);
        }
        (*l_945) = l_943;
        (*l_941) = 0x50AE814B;
    }
    /* facts after for loop */
        (*l_941) = p_5;
    return l_906;
    /* statement id: 226 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_793 g_571 g_572 g_402 g_41.f2 g_41.f0 g_76 g_75 g_64
 * writes: g_64
 */
inline static int16_t  func_9(union U1 * p_10, uint16_t  p_11, union U1 * p_12, union U1 * p_13)
{ /* block id: 196 */
    uint8_t l_858 = 0x66;
    int32_t l_859 = 0xFFD9B2D5;
    const union U2 l_860 = {1U};
    int32_t *l_876 = (void*)0;
    l_859 = (-(int32_t)l_858);
    (*g_76) = (l_860 , ((uint16_t)(p_11 , (((((+l_859) | ((g_793 , (((((p_11 > (-3)) != ((*g_571) , ((uint32_t)((+((-(int16_t)(((uint16_t)l_858 >> (uint16_t)((uint32_t)((int16_t)(0x937A > 0x4DFA) % (int16_t)g_402) / (uint32_t)p_11)) , g_402)) || 2)) == 0xFE6182E7) % (uint32_t)p_11))) <= g_41.f2) <= 4U) || 0x7E60)) < l_859)) != l_860.f0) > g_41.f0) > 0xBF8956B9)) << (uint16_t)12));
    (**g_75) = p_11;
    l_876 = (*g_75);
    /* statement id: 200 */
    assert (l_876 == &g_64);
    return g_64;
}


/* ------------------------------------------ */
/* 
 * reads : g_41.f2 g_571 g_572 g_816 g_793 g_41.f1 g_64
 * writes: g_41.f4
 */
static union U1 * func_14(union U1 * p_15, union U1 * p_16, union U0  p_17)
{ /* block id: 190 */
    int32_t l_827 = 0x08119250;
    float l_843 = (-0x1.0p-1);
    float *l_844 = (void*)0;
    float *l_845 = &g_41.f4;
    union U0 **l_854 = &g_476;
    union U0 ***l_853 = &l_854;
    int32_t *l_855 = &g_64;
    union U1 *l_856 = &g_41;
    (*l_845) = ((l_827 != (((int16_t)(1 >= g_41.f2) >> (int16_t)4) , (-0x9.Dp-1))) <= (l_827 != ((float)((float)((l_827 , p_17.f0) > ((float)(((!((float)((float)((float)g_41.f2 * (float)(((*g_571) , 0x0.211B9Dp+4) >= g_816)) - (float)0x7.1CA5D6p+94) / (float)(-0x4.4p+1))) > g_793) >= l_843) - (float)0x9.DC910Cp+7)) * (float)l_827) - (float)0xE.DE68BBp-80)));
    (*l_845) = ((float)((float)0x3.069185p+8 - (float)(((float)0x8.8p+1 + (float)((g_41.f1 , l_827) , (+g_64))) == p_17.f0)) - (float)l_827);
    (*l_853) = (void*)0;
    /* statement id: 193 */
    assert (l_854 == 0);
    l_855 = l_844;
    /* statement id: 194 */
    assert (l_855 == 0);
    return l_856;
    /* statement id: 195 */
    //assert (func_14_rv == &g_41);
}


/* ------------------------------------------ */
/* 
 * reads : g_41.f1 g_816 g_459 g_460
 * writes: g_41.f4
 */
static union U1 * func_18(union U1 * p_19, uint8_t  p_20)
{ /* block id: 151 */
    int32_t *l_619 = (void*)0;
    int32_t l_620 = 0x7C5ABDA8;
    float *l_621 = &g_41.f4;
    union U1 l_639 = {1};
    union U0 *l_642 = &g_89;
    int32_t ****l_643 = &g_502;
    int16_t l_654 = 0xDB0A;
    union U2 l_697 = {0U};
    uint16_t l_732 = 0x4E77;
    union U1 **l_821 = &g_460;
    uint16_t l_824 = 65534U;
    uint8_t l_825 = 1U;
    l_619 = l_619;
    (*l_621) = l_620;
    /* statement id: 153 */
    for (p_20 = 13; (p_20 == 3); p_20 -= 1)
    { /* block id: 156 */
        int32_t l_631 = (-1);
        const int32_t *l_641 = &g_64;
        const int32_t **l_640 = &l_641;
        union U2 *l_735 = &l_697;
        const int16_t l_761 = 0xDC60;
        union U1 *l_797 = &g_41;
        int32_t l_817 = (-1);
    }
    l_825 = (!(((float)p_20 - (float)(0x0.A977D7p-43 <= ((l_821 != l_821) != ((float)p_20 - (float)l_824)))) <= (g_41.f1 , g_816)));
    return (*g_459);
    /* statement id: 189 */
    //assert (func_18_rv == &g_41);
}


/* ------------------------------------------ */
/* 
 * reads : g_41.f0 g_75 g_89.f0 g_64 g_76 g_77.f0
 * writes: g_76 g_89.f0
 */
static union U1 * func_21(union U1 * p_22)
{ /* block id: 27 */
    int32_t *l_134 = &g_64;
    uint16_t l_146 = 0x2CC2;
    const uint32_t l_147 = 4294967295U;
    union U1 *l_178 = &g_41;
    union U0 *l_220 = &g_89;
    union U0 **l_219 = &l_220;
    float l_251 = 0x0.Ap+1;
    union U1 *l_273 = &g_41;
    uint32_t l_298 = 0x01D9BD75;
    union U1 *l_380 = &g_41;
    int32_t l_393 = 0xB81585BA;
    const int32_t *l_499 = (void*)0;
    const int32_t **l_498 = &l_499;
    const int32_t ***l_497 = &l_498;
    const int32_t ****l_496 = &l_497;
    const int32_t *****l_495 = &l_496;
    const uint16_t l_505 = 0x61A3;
    union U2 *l_543 = &g_77;
    union U2 **l_542 = &l_543;
    (*g_75) = (g_41.f0 , l_134);
    /* statement id: 28 */
    assert (g_76 == &g_64);
    (*g_75) = ((g_89.f0 == (((((*l_134) >= (((*l_134) ^ (0U == (~(*g_76)))) != ((uint16_t)g_89.f0 << (uint16_t)((uint16_t)(((((((uint16_t)((int16_t)(((*l_134) > ((((uint16_t)0x8D53 - (uint16_t)0) <= l_146) < (*l_134))) != 0x7BB3E8CB) - (int16_t)l_147) >> (uint16_t)11) && (*l_134)) ^ g_77.f0) , (*l_134)) , (*l_134)) <= 0x6EEC55A7) / (uint16_t)(*l_134))))) && (*l_134)) | (*l_134)) > (*l_134))) , (*g_75));
    for (g_89.f0 = 12; (g_89.f0 != 17); g_89.f0 += 1)
    { /* block id: 32 */
        int32_t *l_150 = &g_64;
        union U0 l_165 = {1U};
        uint16_t l_197 = 0x9FBB;
        int16_t l_204 = (-1);
        uint32_t l_297 = 0x310DE8F5;
        float l_486 = 0x9.Fp+1;
        int32_t ****l_563 = &g_502;
        uint32_t l_592 = 4294967295U;
        l_134 = (void*)0;
        /* statement id: 33 */
        assert (l_134 == 0);
        (*g_75) = l_150;
    }
    /* facts after for loop */
    assert (l_134 == 0 || l_134 == &g_64);
    return p_22;
    /* statement id: 150 */
    //assert (func_21_rv == &g_41 || func_21_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_41.f2 g_75 g_77 g_41.f0 g_64 g_89.f0 g_41.f1 g_41.f3 g_41 g_77.f0 g_89 g_76
 * writes: g_41.f2 g_64 g_41.f4 g_76
 */
inline static union U1 * func_23(float  p_24, uint16_t  p_25)
{ /* block id: 6 */
    const int32_t *l_67 = (void*)0;
    const int32_t **l_68 = &l_67;
    union U0 *l_90 = (void*)0;
    const union U1 *l_132 = (void*)0;
    union U1 *l_133 = (void*)0;
    (*l_68) = l_67;
    if ((p_25 , ((-2) != p_25)))
    { /* block id: 8 */
        for (g_41.f2 = 8; (g_41.f2 == (-25)); g_41.f2 -= 1)
        { /* block id: 11 */
            return &g_41;
            /* statement id: 12 */
            //assert (func_23_rv == &g_41);
        }
        /* facts after for loop */
            }
    else
    { /* block id: 14 */
        union U1 *l_78 = &g_41;
        int32_t l_87 = 0xBD03168F;
        union U0 *l_88 = &g_89;
        if ((((((int16_t)((((int16_t)p_25 * (int16_t)(g_75 == (g_77 , &l_67))) <= (l_78 != &g_41)) < ((int16_t)((int16_t)(((int16_t)(((((g_41.f0 , ((uint16_t)4U >> (uint16_t)l_87)) ^ 5) ^ g_41.f0) , g_41.f0) , 0x0222) % (int16_t)1U) > l_87) << (int16_t)4) - (int16_t)0xDC50)) - (int16_t)p_25) , g_77) , p_25) >= g_41.f0))
        { /* block id: 15 */
            int32_t *l_91 = &g_64;
            l_90 = l_88;
            /* statement id: 16 */
            assert (l_90 == &g_89);
            (*l_91) = l_87;
        }
        else
        { /* block id: 18 */
            union U0 l_94 = {0x80EA};
            float *l_104 = (void*)0;
            float *l_105 = &g_41.f4;
            int32_t *l_111 = &g_64;
            (*l_105) = ((float)0xA.A4F543p+66 / (float)(l_94 , ((l_94 , (((0xA.B7F440p-9 > (l_88 == (void*)0)) == ((float)((((float)((float)(((float)(l_94.f0 > ((!(-0x10.Dp+1)) != 0x1.ADFED4p-78)) / (float)0x0.95D925p+39) != g_41.f0) - (float)g_64) / (float)0x9.2FE0ECp+40) <= g_89.f0) >= l_87) * (float)g_89.f0)) == g_64)) != 0xF.29A1B0p-59)));
            /* statement id: 19 */
                        g_64 = 0xA67FE427;
            (*l_111) = ((uint16_t)((0xAC0FE8B8 & p_25) , (((((uint16_t)g_41.f1 / (uint16_t)((g_41.f3 , l_94.f0) & g_41.f3)) || (p_25 , (+((*l_78) , g_41.f2)))) , (void*)0) == &g_41)) << (uint16_t)p_25);
        }
        /* facts after branching */
        assert (l_90 == 0 || l_90 == &g_89);
        l_87 = ((0x0D67 & ((p_25 == (+p_25)) && ((void*)0 == &l_87))) ^ ((((int16_t)(l_88 == (void*)0) >> (int16_t)((uint16_t)((int32_t)(+g_41.f0) % (int32_t)(0xEB87 ^ g_77.f0)) - (uint16_t)p_25)) > 1) , p_25));
        (*g_75) = (((float)((float)(((void*)0 != l_78) < ((float)((float)((float)((float)(-0x4.7p+1) + (float)0x0.Bp-1) + (float)((*l_68) != (((((g_89 , (l_87 , l_132)) == &g_41) && p_25) , g_77) , (*g_75)))) + (float)l_87) + (float)p_24)) / (float)(-0x1.Dp-1)) / (float)g_41.f0) , (void*)0);
    }
    /* facts after branching */
    assert (l_90 == 0 || l_90 == &g_89);
    return l_133;
    /* statement id: 26 */
    //assert (func_23_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_32(float  p_33, int32_t  p_34)
{ /* block id: 4 */
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_41.f0
 * writes: g_64
 */
inline static union U1 * func_36(union U1 * p_37, uint32_t  p_38, union U1 * p_39)
{ /* block id: 1 */
    int16_t l_54 = 0x18D7;
    int32_t *l_63 = &g_64;
    (*l_63) = (((uint32_t)(((void*)0 != p_39) , ((l_54 , p_38) == ((((int16_t)g_41.f0 % (int16_t)3) | ((int16_t)(((2U && ((p_38 | ((int32_t)((uint16_t)(&g_41 != p_37) >> (uint16_t)11) % (int32_t)l_54)) , g_41.f0)) ^ l_54) , 0x0055) * (int16_t)l_54)) , p_38))) / (uint32_t)g_41.f0) > l_54);
    return p_37;
    /* statement id: 3 */
    //assert (func_36_rv == &g_41);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_41.f0, "g_41.f0", print_hash_value);
    transparent_crc(g_41.f1, "g_41.f1", print_hash_value);
    transparent_crc(g_41.f2, "g_41.f2", print_hash_value);
    transparent_crc(g_41.f3, "g_41.f3", print_hash_value);
    transparent_crc_bytes (&g_41.f4, sizeof(g_41.f4), "g_41.f4", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc(g_77.f0, "g_77.f0", print_hash_value);
    transparent_crc(g_89.f0, "g_89.f0", print_hash_value);
    transparent_crc(g_402, "g_402", print_hash_value);
    transparent_crc(g_477.f0, "g_477.f0", print_hash_value);
    transparent_crc(g_572.f0, "g_572.f0", print_hash_value);
    transparent_crc(g_616, "g_616", print_hash_value);
    transparent_crc(g_793, "g_793", print_hash_value);
    transparent_crc_bytes (&g_816, sizeof(g_816), "g_816", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 168
XXX total union variables: 18

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 18
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 39

XXX max expression depth: 45
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 45, occurrence: 1

XXX total number of pointers: 125

XXX times a variable address is taken: 131
XXX times a pointer is dereferenced on RHS: 185
breakdown:
   depth: 1, occurrence: 143
   depth: 2, occurrence: 37
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 73
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 457

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 227
   level: 2, occurrence: 77
   level: 3, occurrence: 40
   level: 4, occurrence: 36
   level: 5, occurrence: 15
XXX number of pointers point to pointers: 50
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.4
XXX average alias set size: 1.19

XXX times a non-volatile is read: 1096
XXX times a non-volatile is write: 194
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 59
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 12
   depth: 2, occurrence: 12

XXX percentage a fresh-made variable is used: 14.8
XXX percentage an existing variable is used: 85.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

