/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1641762864
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   volatile uint8_t  f0;
   const signed f1 : 3;
   volatile uint32_t  f2;
   volatile int32_t  f3;
};

union U1 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static uint8_t g_6 = 0xC4L;
static int32_t g_34 = 0x331C587CL;
static int32_t *g_93[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static volatile union U0 g_98 = {0x57L};/* VOLATILE GLOBAL g_98 */
static const volatile union U0 *g_97[1] = {&g_98};
static const volatile union U1 g_104[5] = {{0xD02BD444L},{0xD02BD444L},{0xD02BD444L},{0xD02BD444L},{0xD02BD444L}};
static const volatile union U1 *g_103[7] = {(void*)0,&g_104[1],(void*)0,(void*)0,&g_104[1],(void*)0,(void*)0};
static union U1 g_109 = {0xB0CEA4F5L};
static union U1 *g_108 = &g_109;
static union U1 **g_107 = &g_108;
static union U1 ***g_106[8] = {&g_107,&g_107,&g_107,&g_107,&g_107,&g_107,&g_107,&g_107};
static union U0 g_120 = {0x2AL};/* VOLATILE GLOBAL g_120 */
static uint32_t g_238[2][9] = {{0x6BB3E926L,1UL,1UL,18446744073709551606UL,1UL,18446744073709551606UL,1UL,1UL,0x6BB3E926L},{0x6BB3E926L,1UL,1UL,18446744073709551606UL,1UL,18446744073709551606UL,1UL,0x6BB3E926L,0x9C4DB898L}};
static int32_t *g_239 = (void*)0;
static union U0 *g_298 = &g_120;
static union U0 **g_297 = &g_298;
static int32_t ***g_310 = (void*)0;
static uint8_t g_347[8] = {5UL,5UL,5UL,5UL,5UL,5UL,5UL,5UL};
static int32_t *g_381 = &g_34;
static volatile int32_t g_392 = 0x5B072407L;/* VOLATILE GLOBAL g_392 */
static volatile int32_t *g_391[5][1][1] = {{{&g_392}},{{&g_392}},{{&g_392}},{{&g_392}},{{&g_392}}};
static volatile int32_t ** const g_390[4] = {&g_391[3][0][0],&g_391[3][0][0],&g_391[3][0][0],&g_391[3][0][0]};
static volatile int32_t ** const *g_389 = &g_390[0];
static volatile int32_t ** const **g_388 = &g_389;
static volatile int32_t ** const ***g_387 = &g_388;
static union U0 g_425 = {0xCDL};/* VOLATILE GLOBAL g_425 */
static int32_t g_442 = 0x72941B8CL;
static int32_t *g_480[6][4] = {{&g_34,&g_34,&g_34,&g_34},{&g_34,&g_34,&g_34,&g_34},{&g_34,&g_34,&g_34,&g_34},{&g_34,&g_34,&g_34,&g_34},{&g_34,&g_34,&g_34,&g_34},{&g_34,&g_34,&g_34,&g_34}};
static const int32_t *g_606[2][10][2] = {{{(void*)0,&g_34},{(void*)0,&g_34},{(void*)0,&g_34},{&g_34,(void*)0},{&g_34,&g_34},{&g_34,(void*)0},{(void*)0,&g_34},{&g_34,&g_34},{&g_34,&g_34},{&g_34,&g_34}},{{(void*)0,(void*)0},{&g_34,&g_34},{&g_34,(void*)0},{&g_34,&g_34},{(void*)0,&g_34},{(void*)0,&g_34},{(void*)0,&g_34},{(void*)0,&g_34},{&g_34,(void*)0},{&g_34,&g_34}}};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_25(void);
static const int32_t * func_26(int32_t  p_27, int32_t * p_28, int32_t * p_29, int16_t  p_30, int32_t * p_31);
static int32_t * func_35(const int32_t * p_36, int32_t  p_37, uint16_t  p_38, const uint32_t  p_39, uint8_t  p_40);
static int32_t  func_45(int32_t * p_46, const int32_t  p_47, uint32_t  p_48);
static int32_t * func_49(int32_t * const  p_50, uint16_t  p_51);
static int32_t * const  func_52(union U1  p_53, const uint8_t  p_54, int32_t * p_55);
static uint16_t  func_62(int16_t  p_63, uint32_t  p_64, int16_t  p_65, int16_t  p_66);
static int32_t  func_70(int32_t * p_71, int32_t * p_72, int32_t * const  p_73);
static int32_t * func_75(int16_t  p_76, int32_t  p_77, int16_t  p_78);
static int32_t * const  func_80(int32_t * const  p_81, uint8_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_34 g_104.f1
 * writes: g_34 g_606
 */
static uint16_t  func_25(void)
{ /* block id: 36 */
    int16_t l_32[10][2] = {{3L,5L},{3L,5L},{3L,5L},{3L,5L},{3L,5L},{3L,5L},{3L,5L},{3L,5L},{3L,5L},{3L,5L}};
    int32_t *l_33 = &g_34;
    const int32_t *l_605 = &g_34;
    const int32_t **l_604[6][3] = {{&l_605,&l_605,&l_605},{&l_605,&l_605,&l_605},{(void*)0,&l_605,(void*)0},{&l_605,&l_605,&l_605},{&l_605,&l_605,&l_605},{&l_605,&l_605,&l_605}};
    int i, j;
    g_606[0][7][0] = func_26(l_32[4][0], l_33, func_35(&g_34, (&g_34 != (void*)0), g_6, g_6, ((uint16_t)(l_33 == l_33) << (uint16_t)(*l_33))), (*l_33), &g_34);
    return g_104[1].f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_34
 */
static const int32_t * func_26(int32_t  p_27, int32_t * p_28, int32_t * p_29, int16_t  p_30, int32_t * p_31)
{ /* block id: 524 */
    uint8_t l_603 = 0UL;
    (*p_28) = ((int32_t)l_603 + (int32_t)0xD59527B9L);
    return &g_34;
    /* statement id: 526 */
    //assert (func_26_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(const int32_t * p_36, int32_t  p_37, uint16_t  p_38, const uint32_t  p_39, uint8_t  p_40)
{ /* block id: 37 */
    union U1 l_56 = {1UL};
    uint16_t l_67 = 65535UL;
    int32_t *l_74 = (void*)0;
    union U0 **l_563[7][9];
    int32_t l_585[1];
    union U0 ***l_600 = (void*)0;
    union U0 ****l_599 = &l_600;
    int i, j;
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 9; j++)
            l_563[i][j] = &g_298;
    }
    for (i = 0; i < 1; i++)
        l_585[i] = (-2L);
    for (p_38 = 21; (p_38 <= 4); p_38 -= 9)
    { /* block id: 40 */
        uint32_t l_57 = 0x5BF7C295L;
        uint32_t l_79 = 0xDC4D7E3CL;
        union U1 ****l_518 = &g_106[1];
        int32_t **l_555 = &g_480[2][1];
        const union U1 **l_560 = (void*)0;
        const union U1 ***l_559 = &l_560;
        const union U1 *** const *l_558[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        int i;
    }
    (*l_599) = &g_297;
    /* statement id: 522 */
    assert (l_600 == &g_297);
    return l_74;
    /* statement id: 523 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_45(int32_t * p_46, const int32_t  p_47, uint32_t  p_48)
{ /* block id: 453 */
    uint32_t l_481 = 1UL;
    return l_481;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_109.f0 g_238 g_107 g_104.f1 g_106 g_104.f2 g_97 g_103 g_109.f2 g_109.f1 g_98.f0 g_108 g_109 g_120.f0 g_239 g_34 g_104.f0 g_347 g_381 g_387 g_388 g_389 g_390 g_391 g_392 g_480
 * writes: g_93 g_109.f0 g_108 g_97 g_6 g_34 g_103 g_106 g_297 g_239 g_109.f1 g_392
 */
static int32_t * func_49(int32_t * const  p_50, uint16_t  p_51)
{ /* block id: 174 */
    int32_t l_241 = (-1L);
    int32_t l_246 = 0x5B1F0BCFL;
    union U1 **l_311 = &g_108;
    int32_t *l_315 = &l_246;
    uint16_t l_327 = 0UL;
    int32_t l_334 = 1L;
    uint32_t l_371 = 18446744073709551615UL;
    int32_t ****l_372 = &g_310;
    uint8_t l_378 = 249UL;
    uint32_t l_405[8] = {0x3C505BFEL,5UL,0x3C505BFEL,0x3C505BFEL,5UL,0x3C505BFEL,0x3C505BFEL,5UL};
    uint8_t l_412 = 0x3DL;
    const union U1 ****l_417 = (void*)0;
    int i;
    if (((((((l_241 ^ 0L) & (0x60F2L <= g_6)) ^ p_51) & l_246) >= l_241) || p_51))
    { /* block id: 175 */
        int32_t *l_247 = &l_241;
        int32_t **l_248 = (void*)0;
        int32_t **l_249 = (void*)0;
        l_241 = l_246;
        g_93[6] = l_247;
        /* statement id: 177 */
        //assert (g_93[0] == &l_241 || g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
    }
    else
    { /* block id: 178 */
        int32_t *l_268 = &l_246;
        int32_t *l_271 = &l_241;
        int32_t **l_299 = &g_239;
        union U1 *l_309[9] = {&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109};
        int i;
        for (g_109.f0 = 0; (g_109.f0 != 59); g_109.f0++)
        { /* block id: 181 */
            int32_t *l_252 = &l_246;
            int16_t l_280 = 0x8562L;
            union U0 *l_296 = &g_120;
            union U0 **l_295 = &l_296;
            (*l_252) = 0L;
            for (l_246 = 1; (l_246 >= 0); l_246 -= 1)
            { /* block id: 185 */
                int32_t l_253 = 0x42AC9BB6L;
                union U1 l_254 = {0xEC3E9C7FL};
                int32_t * const l_272 = &l_246;
                int i, j;
                l_253 = g_238[l_246][l_246];
                for (l_241 = 1; (l_241 >= 0); l_241 -= 1)
                { /* block id: 189 */
                    int32_t *l_255 = &l_253;
                    int32_t **l_256 = &l_252;
                    volatile union U0 **l_257 = (void*)0;
                    int i, j;
                    (*l_256) = func_52(l_254, g_238[l_246][(l_241 + 7)], l_255);
                    /* statement id: 190 */
                    assert (l_252 == &l_253);
                    g_97[0] = &g_98;
                    for (l_254.f2 = 0; (l_254.f2 <= 0); l_254.f2 += 1)
                    { /* block id: 194 */
                        int i, j;
                        (*l_255) = ((g_238[l_241][(l_241 + 5)] <= (g_104[1].f1 >= ((uint16_t)l_254.f0 + (uint16_t)((void*)0 == g_106[(l_254.f2 + 6)])))) != ((uint16_t)(((int16_t)0xD399L << (int16_t)15) | 1L) << (uint16_t)((uint16_t)(p_51 > ((((int16_t)p_51 >> (int16_t)2) >= p_51) | p_51)) + (uint16_t)g_238[0][8])));
                        (*l_255) = 0x74CFF9A1L;
                    }
                    /* facts after for loop */
                                        return &g_34;
                    /* statement id: 198 */
                    //assert (g_297 == dangling || g_297 == &g_298);
                    //assert (func_49_rv == &g_34);
                }
                for (l_254.f1 = 3; (l_254.f1 <= 8); l_254.f1 += 1)
                { /* block id: 202 */
                    union U1 l_269 = {0xEF6D558AL};
                    int32_t * const l_291 = &l_253;
                    int i;
                    if ((*l_268))
                    { /* block id: 203 */
                        const uint32_t l_270[1] = {0x8915DD1EL};
                        int32_t **l_273[1][1][10] = {{{&g_93[5],&l_252,&g_93[5],&g_93[5],&l_252,&g_93[5],&g_93[5],&l_252,&g_93[5],&g_93[5]}}};
                        int32_t **l_274 = &g_93[1];
                        int i, j, k;
                        (*l_274) = func_52(l_269, l_270[0], func_75(g_104[1].f2, ((((-8L) != func_70(l_271, func_75(l_241, p_51, (*l_252)), l_272)) | (*l_252)) >= l_270[0]), g_238[0][8]));
                    }
                    else
                    { /* block id: 205 */
                        int32_t *l_277 = &l_246;
                        int32_t **l_292[2];
                        int32_t **l_293[6];
                        int32_t **l_294 = &g_93[1];
                        int i;
                        for (i = 0; i < 2; i++)
                            l_292[i] = &l_271;
                        for (i = 0; i < 6; i++)
                            l_293[i] = &l_252;
                        (*l_271) = ((uint16_t)(*l_272) - (uint16_t)(func_70(l_277, &l_253, l_268) > (g_109.f2 == (g_109.f1 & g_98.f0))));
                        (*l_294) = func_52((*g_108), ((uint16_t)l_280 >> (uint16_t)(((int32_t)(*l_272) - (int32_t)((uint16_t)(((int16_t)(((uint32_t)(func_70(l_277, func_75((((uint16_t)((((func_70(&g_34, &l_253, &g_34) > l_269.f0) == 0xE9B1BF55L) || g_6) ^ (*l_252)) >> (uint16_t)p_51) ^ 0xA13BF90DL), l_269.f1, g_120.f0), l_291) != g_238[0][3]) + (uint32_t)0x4C053BF6L) != (*l_272)) << (int16_t)4) >= p_51) << (uint16_t)6)) | 0xE547L)), &l_253);
                    }
                }
                /* facts after for loop */
                //assert (g_93[0] == &l_253 || g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                                g_297 = l_295;
                /* statement id: 210 */
                assert (g_297 == &l_296);
            }
            /* facts after for loop */
            //assert (g_297 == &l_296 || g_297 == dangling || g_297 == &g_298);
        }
        /* facts after for loop */
                (*l_299) = &g_34;
        /* statement id: 213 */
        assert (g_239 == &g_34);
        for (g_6 = 0; (g_6 != 43); ++g_6)
        { /* block id: 216 */
            union U1 l_305 = {0x19A26B15L};
            for (p_51 = 0; (p_51 <= 0); p_51 += 1)
            { /* block id: 219 */
                int32_t *l_302[4];
                int i;
                for (i = 0; i < 4; i++)
                    l_302[i] = &l_246;
                return (*l_299);
                /* statement id: 220 */
                //assert (func_49_rv == &g_34);
            }
            for (l_241 = (-9); (l_241 <= (-11)); l_241 -= 1)
            { /* block id: 224 */
                int32_t *l_306 = &g_34;
                int32_t **l_307[4][5] = {{&l_271,&l_271,&l_271,&l_271,&l_271},{&g_239,&g_239,&g_239,&g_239,&g_239},{&l_271,&l_271,&l_271,&l_271,&l_271},{&g_239,&g_239,&g_239,&g_239,&g_239}};
                int32_t **l_308 = &g_93[7];
                int i, j;
                (*l_308) = func_52(l_305, (*l_271), l_306);
            }
            (*g_107) = l_309[7];
            (*l_299) = &g_34;
        }
    }
    /* facts after branching */
    //assert (g_93[0] == &l_241 || g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
    if ((l_246 && l_241))
    { /* block id: 231 */
        int32_t *l_314 = &l_246;
        return &g_34;
        /* statement id: 232 */
        //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
        //assert (func_49_rv == &g_34);
    }
    else
    { /* block id: 233 */
        int32_t * const l_316 = (void*)0;
        int32_t **l_317[2];
        int32_t **l_318[10];
        int32_t **l_319 = (void*)0;
        int32_t **l_320 = &l_315;
        int i;
        for (i = 0; i < 2; i++)
            l_317[i] = &l_315;
        for (i = 0; i < 10; i++)
            l_318[i] = &l_315;
        (*l_320) = l_316;
        /* statement id: 234 */
        assert (l_315 == 0);
        for (g_109.f1 = 1; (g_109.f1 <= 7); g_109.f1 += 1)
        { /* block id: 237 */
            for (g_6 = 0; (g_6 <= 7); g_6 += 1)
            { /* block id: 240 */
                return &g_34;
                /* statement id: 241 */
                //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                //assert (func_49_rv == &g_34);
            }
        }
        l_246 = p_51;
    }
    /* facts after branching */
    assert (l_315 == 0);
    if ((p_50 != (void*)0))
    { /* block id: 246 */
        int32_t *l_322 = &l_246;
        for (p_51 = 0; (p_51 <= 6); p_51 += 1)
        { /* block id: 249 */
            int32_t *l_321 = &g_34;
            (*l_321) = (&g_34 != l_321);
        }
        return &g_34;
        /* statement id: 252 */
        //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
        //assert (func_49_rv == &g_34);
    }
    else
    { /* block id: 253 */
        union U0 *l_330[6];
        int32_t *l_353 = &g_34;
        union U1 **l_401 = &g_108;
        uint32_t l_413 = 0xC1FDB081L;
        const union U1 *** const *l_416 = (void*)0;
        uint16_t l_449 = 65528UL;
        uint8_t l_457 = 250UL;
        int i;
        for (i = 0; i < 6; i++)
            l_330[i] = &g_120;
        for (g_34 = 1; (g_34 >= 0); g_34 -= 1)
        { /* block id: 256 */
            int32_t *l_326 = (void*)0;
            union U0 * const l_329 = &g_120;
            union U1 ***l_359 = &g_107;
            int32_t l_364 = 0x532C7C98L;
            int16_t l_365[4][8][4] = {{{1L,1L,(-6L),0x3618L},{0x8206L,(-10L),0x4FA1L,0L},{0x6F05L,0x4FA1L,0x3618L,0x4FA1L},{0L,0xD833L,0x8206L,(-6L)},{0xD833L,0x6F05L,0x3618L,0L},{1L,1L,1L,1L},{1L,(-6L),0x3618L,(-10L)},{0xD833L,1L,0x8206L,0x4FA1L}},{{0L,0x5A37L,0L,0x4FA1L},{0x8206L,1L,0xD833L,(-10L)},{0x3618L,(-6L),1L,1L},{1L,1L,1L,0L},{0x3618L,0x6F05L,0xD833L,(-6L)},{0x8206L,0xD833L,0L,0xD833L},{0L,0xD833L,0x8206L,(-6L)},{0xD833L,0x6F05L,0x3618L,0L}},{{1L,1L,1L,1L},{1L,(-6L),0x3618L,(-10L)},{0xD833L,1L,0x8206L,0x4FA1L},{0L,0x5A37L,0L,0x4FA1L},{0x8206L,1L,0xD833L,(-10L)},{0x3618L,(-6L),1L,1L},{1L,1L,1L,0L},{0x3618L,0x6F05L,0xD833L,(-6L)}},{{0x8206L,0xD833L,0L,0xD833L},{0L,0xD833L,0x8206L,(-6L)},{0xD833L,0x6F05L,0x3618L,0L},{1L,1L,1L,1L},{1L,(-6L),0x3618L,(-10L)},{0xD833L,1L,0x8206L,0x4FA1L},{0L,0x5A37L,0L,0x4FA1L},{0x8206L,1L,0xD833L,(-10L)}}};
            int i, j, k;
            for (g_6 = 0; (g_6 <= 1); g_6 += 1)
            { /* block id: 259 */
                int32_t *l_328 = &l_246;
                for (l_241 = 1; (l_241 >= 0); l_241 -= 1)
                { /* block id: 262 */
                    uint16_t l_323 = 0x99EBL;
                    int32_t *l_324 = &l_246;
                    (*l_324) = l_323;
                    for (p_51 = 2; (p_51 <= 7); p_51 += 1)
                    { /* block id: 266 */
                        int16_t l_325[3];
                        int i;
                        for (i = 0; i < 3; i++)
                            l_325[i] = 0xF387L;
                        (*l_324) = 6L;
                        l_325[1] = ((void*)0 != p_50);
                        l_326 = (void*)0;
                    }
                    (*l_324) = l_327;
                }
                (*l_328) = (-8L);
                for (l_246 = 0; (l_246 <= 1); l_246 += 1)
                { /* block id: 276 */
                    return l_326;
                    /* statement id: 277 */
                    //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                    //assert (func_49_rv == 0);
                }
            }
            if ((0x449FL <= g_104[1].f0))
            { /* block id: 280 */
                int32_t l_338 = 0x4D871698L;
                int32_t l_354[10] = {0L,6L,6L,0L,6L,6L,0L,6L,6L,0L};
                int i;
                if (((g_106[(g_34 + 1)] == (void*)0) & g_104[1].f0))
                { /* block id: 281 */
                    uint32_t l_339 = 0x8261AB18L;
                    for (g_109.f0 = 0; (g_109.f0 <= 1); g_109.f0 += 1)
                    { /* block id: 284 */
                        int32_t *l_331 = &l_246;
                        int32_t **l_348 = &l_326;
                        (*l_331) = (l_329 == l_330[3]);
                        (*l_331) = (-1L);
                        (*l_331) = __builtin_parity(((g_109.f0 > ((int16_t)(l_334 > ((-(int32_t)(((((int32_t)(*l_331) + (int32_t)(0xAF79L == ((((*l_331) || ((l_338 != l_339) >= ((uint16_t)((int16_t)((-(int16_t)0x2056L) ^ ((int16_t)g_109.f1 >> (int16_t)g_104[1].f1)) >> (int16_t)0) - (uint16_t)7UL))) && p_51) < g_347[5]))) >= l_338) ^ g_109.f2) & l_338)) ^ 0xB3C5L)) - (int16_t)l_338)) == g_109.f0));
                        (*l_348) = p_50;
                    }
                    /* facts after for loop */
                                        //assert (l_326 == 0 || l_326 == &g_34 || l_326 == &p_37);
                }
                else
                { /* block id: 290 */
                    int32_t *l_351 = &g_34;
                    if ((((uint16_t)0xEC5BL << (uint16_t)g_109.f0) && 0L))
                    { /* block id: 291 */
                        int32_t **l_352 = &g_93[4];
                        (*l_352) = l_351;
                        return l_353;
                        /* statement id: 293 */
                        //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                        //assert (func_49_rv == &g_34);
                    }
                    else
                    { /* block id: 294 */
                        return &g_34;
                        /* statement id: 295 */
                        //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                        //assert (func_49_rv == &g_34);
                    }
                }
                /* facts after branching */
                                //assert (l_326 == 0 || l_326 == &g_34 || l_326 == &p_37);
                for (g_109.f0 = 0; (g_109.f0 <= 1); g_109.f0 += 1)
                { /* block id: 300 */
                    for (l_338 = 0; (l_338 <= 7); l_338 += 1)
                    { /* block id: 303 */
                        int i;
                        l_354[0] = g_347[(g_34 + 2)];
                        if (p_51)
                            continue;
                    }
                }
                if (((__builtin_ctzll(g_104[1].f0) <= ((int16_t)(p_51 != ((uint32_t)(g_106[g_34] != l_359) + (uint32_t)((p_51 > g_238[0][8]) > ((int32_t)((int16_t)__builtin_ffs((p_51 && p_51)) - (int16_t)l_364) + (int32_t)l_365[0][4][3])))) - (int16_t)l_338)) == p_51))
                { /* block id: 308 */
                    l_326 = func_52((*g_108), (*l_353), &l_241);
                    /* statement id: 309 */
                    assert (l_326 == &l_241);
                    (*l_326) = (l_354[4] | (l_338 == (((g_238[0][5] || ((*l_326) | (-7L))) ^ (p_51 > (((uint16_t)(((0UL || __builtin_bswap32(g_104[1].f2)) != p_51) | g_238[0][6]) >> (uint16_t)g_6) != g_109.f0))) <= l_354[0])));
                    for (l_327 = 0; (l_327 <= 1); l_327 += 1)
                    { /* block id: 313 */
                        int32_t **l_370 = &l_315;
                        (*l_370) = func_52((**g_107), p_51, &l_364);
                        /* statement id: 314 */
                        assert (l_315 == &l_364);
                        (*l_315) = (*l_326);
                    }
                    /* facts after for loop */
                    //assert (l_315 == &l_364 || l_315 == &g_34 || l_315 == dangling || l_315 == 0);
                    for (l_246 = 1; (l_246 >= 0); l_246 -= 1)
                    { /* block id: 319 */
                        (*l_326) = ((0L & 0UL) & l_371);
                    }
                }
                else
                { /* block id: 322 */
                    int32_t *****l_373 = &l_372;
                    int32_t *l_374 = &l_334;
                    int32_t **l_375 = &l_315;
                    (*l_373) = l_372;
                    (*l_374) = 0xE7C0EF8DL;
                    for (p_51 = 0; p_51 < 1; p_51 += 1)
                    {
                        g_97[p_51] = &g_98;
                    }
                    (*l_375) = func_52((***l_359), g_238[0][8], l_353);
                    /* statement id: 326 */
                    assert (l_315 == &g_34);
                }
                /* facts after branching */
                //assert (l_315 == &l_364 || l_315 == &g_34 || l_315 == dangling || l_315 == 0);
                //assert (l_326 == 0 || l_326 == &l_241 || l_326 == &g_34 || l_326 == &p_37);
            }
            else
            { /* block id: 328 */
                uint32_t l_376[8][1];
                int32_t l_377[2][8] = {{0x5B3739AFL,8L,0x5B3739AFL,8L,0x5B3739AFL,8L,0x5B3739AFL,8L},{0x5B3739AFL,8L,0x5B3739AFL,8L,0x5B3739AFL,8L,0x5B3739AFL,8L}};
                const int32_t *l_380 = &l_377[0][7];
                int i, j;
                for (i = 0; i < 8; i++)
                {
                    for (j = 0; j < 1; j++)
                        l_376[i][j] = 0xC2083D56L;
                }
                if ((((*l_353) | p_51) > (g_238[0][8] & l_376[4][0])))
                { /* block id: 329 */
                    if (l_376[1][0])
                        break;
                    l_377[0][1] = (*l_353);
                    l_377[1][6] = (g_238[0][8] ^ p_51);
                }
                else
                { /* block id: 333 */
                    l_378 = (-1L);
                    for (l_241 = 0; (l_241 <= 7); l_241 += 1)
                    { /* block id: 337 */
                        const int32_t *l_379[4] = {&l_364,&l_364,&l_364,&l_364};
                        int i;
                        if (g_347[(g_34 + 4)])
                            break;
                        l_380 = l_379[0];
                        /* statement id: 339 */
                        assert (l_380 == &l_364 || l_380 == &l_241);
                        l_315 = g_381;
                        /* statement id: 340 */
                        assert (l_315 == &g_34);
                    }
                    /* facts after for loop */
                    assert (l_380 == &l_364 || l_380 == &l_241 || (l_380 >= &l_377[0][0] && l_380 <= &l_377[1][7]));
                }
                /* facts after branching */
                assert (l_380 == &l_364 || l_380 == &l_241 || (l_380 >= &l_377[0][0] && l_380 <= &l_377[1][7]));
            }
            /* facts after branching */
                        //assert (l_315 == &l_364 || l_315 == &g_34 || l_315 == dangling || l_315 == 0);
            //assert (l_326 == 0 || l_326 == &l_241 || l_326 == &g_34 || l_326 == &p_37);
            for (l_378 = 0; (l_378 <= 0); l_378 += 1)
            { /* block id: 346 */
                int32_t *l_383 = (void*)0;
                for (l_334 = 5; (l_334 >= 1); l_334 -= 1)
                { /* block id: 349 */
                    for (l_246 = 7; (l_246 >= 0); l_246 -= 1)
                    { /* block id: 352 */
                        int32_t l_382 = 0x9FC1B618L;
                        l_382 = 0L;
                        return l_383;
                        /* statement id: 354 */
                        //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                        //assert (func_49_rv == &g_34 || func_49_rv == 0);
                    }
                    for (g_109.f0 = 0; (g_109.f0 <= 7); g_109.f0 += 1)
                    { /* block id: 358 */
                        int32_t **l_384 = &l_383;
                        (*l_384) = &g_34;
                        /* statement id: 359 */
                        assert (l_383 == &g_34);
                    }
                }
                /* facts after for loop */
                assert (l_383 == &g_34 || l_383 == 0);
                for (l_327 = 0; (l_327 <= 1); l_327 += 1)
                { /* block id: 364 */
                    int i, j;
                    if ((-(int16_t)g_238[l_378][(l_327 + 5)]))
                    { /* block id: 365 */
                        int i;
                        if (g_347[(l_327 + 2)])
                            break;
                    }
                    else
                    { /* block id: 367 */
                        int32_t **l_386 = &g_93[1];
                        int i;
                        (*l_386) = func_52((**g_107), g_347[(l_327 + 3)], l_383);
                    }
                    (*****g_387) = (&l_372 != g_387);
                    (*****g_387) = ((void*)0 != l_311);
                    if ((g_238[l_378][(l_327 + 5)] || (((int16_t)g_104[1].f2 + (int16_t)((int16_t)((((((int32_t)((uint16_t)((void*)0 != l_401) << (uint16_t)g_238[0][8]) % (int32_t)((p_51 ^ l_365[0][4][3]) | ((void*)0 != &l_359))) ^ p_51) > g_238[0][0]) && (-9L)) < p_51) << (int16_t)g_109.f0)) != p_51)))
                    { /* block id: 372 */
                        int32_t **l_402 = &g_93[7];
                        const volatile union U0 **l_404 = &g_97[0];
                        const volatile union U0 ***l_403 = &l_404;
                        int i;
                        (*l_402) = func_52((*g_108), g_6, l_383);
                        if (g_238[l_378][(l_327 + 5)])
                            continue;
                        (*l_403) = &g_97[l_378];
                    }
                    else
                    { /* block id: 376 */
                        int16_t l_406 = 0x718DL;
                        (*****g_387) = (-9L);
                        (****g_388) = (((-1L) & l_405[0]) < 0x1D45L);
                        (***g_389) = l_406;
                    }
                }
                if ((***g_389))
                    break;
            }
            (***g_389) = ((int16_t)__builtin_ffsll((&g_388 != (void*)0)) << (int16_t)g_120.f0);
            for (l_371 = 0; (l_371 <= 1); l_371 += 1)
            { /* block id: 387 */
                int32_t *l_409 = &l_246;
                return l_353;
                /* statement id: 388 */
                //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                //assert (func_49_rv == &g_34);
            }
        }
        /* facts after for loop */
        //assert (l_315 == &g_34 || l_315 == dangling || l_315 == 0);
        (***g_389) = ((int16_t)((**g_388) == &p_50) + (int16_t)(g_109.f0 > (((((*g_387) != (*g_387)) < (((((func_70(&l_241, &l_334, func_52((**l_311), p_51, l_353)) || (-8L)) && (*l_353)) & p_51) || (*l_353)) == l_412)) < p_51) <= l_413)));
        (***g_389) = (((int16_t)(l_416 != l_417) >> (int16_t)p_51) && (0xACD0L == p_51));
        for (g_34 = 0; (g_34 <= (-16)); g_34 -= 1)
        { /* block id: 395 */
            union U0 *l_424 = &g_425;
            int32_t l_433 = 0L;
            int32_t *l_445 = &l_246;
            int32_t **l_465[9] = {&l_353,&l_353,&l_353,&l_353,&l_353,&l_353,&l_353,&l_353,&l_353};
            int32_t **l_466[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            int32_t **l_467 = &g_381;
            int i;
        }
    }
    /* facts after branching */
    //assert (l_315 == &g_34 || l_315 == dangling || l_315 == 0);
    return g_480[4][1];
    /* statement id: 452 */
    //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
    //assert (func_49_rv == &g_34 || func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_107
 * writes: g_108
 */
static int32_t * const  func_52(union U1  p_53, const uint8_t  p_54, int32_t * p_55)
{ /* block id: 171 */
    union U1 *l_240 = &g_109;
    (*g_107) = l_240;
    /* statement id: 172 */
    assert (g_108 == &g_109);
    return p_55;
    /* statement id: 173 */
    //assert (func_52_rv == 0 || func_52_rv == &l_253 || func_52_rv == &g_34 || func_52_rv == &l_241 || func_52_rv == &l_364);
}


/* ------------------------------------------ */
/* 
 * reads : g_120.f0 g_6 g_109.f2 g_34 g_109.f1 g_97 g_103 g_106 g_98.f0 g_109.f0 g_107 g_104.f0 g_93 g_104.f2 g_104.f1
 * writes: g_93 g_6 g_34 g_97 g_103 g_106 g_109.f1 g_108
 */
static uint16_t  func_62(int16_t  p_63, uint32_t  p_64, int16_t  p_65, int16_t  p_66)
{ /* block id: 79 */
    union U0 *l_119[5][9][5] = {{{&g_120,&g_120,&g_120,&g_120,(void*)0},{&g_120,&g_120,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,(void*)0,&g_120},{&g_120,(void*)0,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,(void*)0,(void*)0,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120}},{{&g_120,&g_120,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{(void*)0,(void*)0,(void*)0,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120}},{{(void*)0,&g_120,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,(void*)0},{&g_120,&g_120,&g_120,&g_120,(void*)0},{&g_120,&g_120,(void*)0,&g_120,(void*)0},{(void*)0,&g_120,&g_120,(void*)0,&g_120},{&g_120,(void*)0,&g_120,&g_120,&g_120},{&g_120,(void*)0,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120}},{{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,(void*)0,&g_120,&g_120},{&g_120,(void*)0,&g_120,&g_120,(void*)0},{(void*)0,(void*)0,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,(void*)0,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120}},{{(void*)0,&g_120,&g_120,&g_120,(void*)0},{&g_120,&g_120,(void*)0,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,(void*)0},{&g_120,&g_120,(void*)0,&g_120,&g_120},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,(void*)0,&g_120,&g_120,(void*)0},{&g_120,&g_120,&g_120,&g_120,&g_120},{&g_120,&g_120,&g_120,(void*)0,&g_120}}};
    int32_t l_126 = 1L;
    const union U1 **l_144 = (void*)0;
    const union U1 ***l_143[4];
    int32_t *l_159 = &g_34;
    int32_t * const *l_167 = &g_93[7];
    int32_t * const **l_166 = &l_167;
    int16_t l_237 = (-5L);
    int i, j, k;
    for (i = 0; i < 4; i++)
        l_143[i] = &l_144;
    for (p_63 = 9; (p_63 <= 22); p_63 += 2)
    { /* block id: 82 */
        int32_t *l_115 = &g_34;
        union U1 * const *l_121 = &g_108;
        union U1 **l_122 = (void*)0;
        for (p_65 = 0; (p_65 == (-6)); p_65 -= 2)
        { /* block id: 85 */
            int32_t **l_116 = &g_93[1];
            (*l_116) = l_115;
            (*l_116) = l_115;
            if (p_65)
                break;
            (*l_116) = func_75(((int16_t)(l_119[3][4][3] == l_119[0][4][2]) >> (int16_t)p_66), p_66, (((l_121 == l_122) == (-(int16_t)((int16_t)((g_120.f0 | g_6) >= (((p_65 ^ g_109.f2) != p_65) || p_66)) + (int16_t)(*l_115)))) > (*l_115)));
        }
        (*l_115) = (((p_64 < (&l_115 == &g_93[1])) <= 3UL) && ((l_126 ^ ((int16_t)((int16_t)(g_109.f2 && ((int16_t)func_70(&l_126, func_75((*l_115), g_109.f1, g_34), l_115) + (int16_t)1L)) % (int16_t)p_64) >> (int16_t)13)) || p_66));
    }
    /* facts after for loop */
    //assert (g_93[0] == &g_34 || g_93[0] == 0);
    if ((p_64 < (((void*)0 != &g_98) <= (!(&g_106[1] == &g_106[1])))))
    { /* block id: 93 */
        return l_126;
    }
    else
    { /* block id: 95 */
        int32_t **l_141 = &g_93[0];
        union U1 * const *l_218[6] = {&g_108,&g_108,&g_108,&g_108,&g_108,&g_108};
        union U1 * const **l_217[5];
        union U1 * const *** const l_216[1][6] = {{&l_217[2],&l_217[2],&l_217[2],&l_217[2],&l_217[2],&l_217[2]}};
        int32_t l_220 = (-2L);
        int i, j;
        for (i = 0; i < 5; i++)
            l_217[i] = &l_218[5];
        for (p_66 = 0; (p_66 < 12); ++p_66)
        { /* block id: 98 */
            int32_t **l_138 = (void*)0;
            int32_t **l_139[4][2][5] = {{{&g_93[1],&g_93[1],&g_93[1],&g_93[1],&g_93[1]},{&g_93[5],&g_93[5],&g_93[5],&g_93[5],&g_93[5]}},{{&g_93[1],&g_93[1],&g_93[1],&g_93[1],&g_93[1]},{&g_93[5],&g_93[5],&g_93[5],&g_93[5],&g_93[5]}},{{&g_93[1],&g_93[1],&g_93[1],&g_93[1],&g_93[1]},{&g_93[5],&g_93[5],&g_93[5],&g_93[5],&g_93[5]}},{{&g_93[1],&g_93[1],&g_93[1],&g_93[1],&g_93[1]},{&g_93[5],&g_93[5],&g_93[5],&g_93[5],&g_93[5]}}};
            int32_t **l_140 = &g_93[4];
            int i, j, k;
            (*l_140) = func_80(&l_126, ((int16_t)p_66 >> (int16_t)9));
        }
        /* facts after for loop */
        //assert (g_93[0] == &l_126 || g_93[0] == &g_34 || g_93[0] == 0);
        (*l_141) = &g_34;
        if (((-(uint32_t)(l_143[3] != &g_107)) < (p_65 && 4294967295UL)))
        { /* block id: 102 */
            uint8_t l_148 = 0xD3L;
            for (g_109.f1 = 9; (g_109.f1 != 17); g_109.f1 += 4)
            { /* block id: 105 */
                int32_t *l_147[9] = {&l_126,&g_34,&l_126,&l_126,&g_34,&l_126,&l_126,&g_34,&l_126};
                union U1 *l_154 = (void*)0;
                union U1 ***l_162 = &g_107;
                uint16_t l_163 = 0xE3CEL;
                int32_t l_171 = 0L;
                int i;
                l_148 = (p_64 >= p_64);
                if ((((uint16_t)((int16_t)g_98.f0 - (int16_t)(~(func_70(&g_34, &g_34, func_75(((1UL | func_70(&g_34, &g_34, &g_34)) == __builtin_ctzll(((-3L) || g_109.f0))), p_64, g_109.f1)) >= p_66))) >> (uint16_t)p_65) >= 1UL))
                { /* block id: 107 */
                    return p_64;
                    /* statement id: 108 */
                    //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                }
                else
                { /* block id: 109 */
                    int16_t l_157 = (-10L);
                    const int32_t l_165 = 0x3A1CE40CL;
                    (*g_107) = l_154;
                    /* statement id: 110 */
                    assert (g_108 == 0);
                    for (g_34 = 0; (g_34 <= 17); ++g_34)
                    { /* block id: 113 */
                        volatile union U0 **l_158[6];
                        int32_t *l_160 = &l_126;
                        union U1 ****l_161[1];
                        int i;
                        for (i = 0; i < 6; i++)
                            l_158[i] = (void*)0;
                        for (i = 0; i < 1; i++)
                            l_161[i] = (void*)0;
                        l_157 = p_63;
                        g_97[0] = &g_98;
                        l_160 = l_159;
                        /* statement id: 116 */
                        assert (l_160 == &g_34);
                        l_162 = &g_107;
                    }
                    if (((l_163 <= (~l_157)) > ((l_165 || 5UL) <= (-3L))))
                    { /* block id: 119 */
                        int32_t * const ***l_168 = &l_166;
                        (*l_168) = l_166;
                        l_171 = ((uint16_t)((0x0ABA6552L != 0x52A06A2AL) ^ p_66) << (uint16_t)2);
                    }
                    else
                    { /* block id: 122 */
                        union U1 ***l_172 = &g_107;
                        (*l_141) = func_75(l_148, (((void*)0 == l_172) == g_104[1].f0), ((func_70(&l_126, &g_34, &g_34) || ((*l_167) == (void*)0)) | g_109.f0));
                        if (p_64)
                            break;
                        (**l_162) = (void*)0;
                    }
                    (*l_159) = l_148;
                }
                /* facts after branching */
                assert (g_108 == 0);
            }
            /* facts after for loop */
            assert (g_108 == 0 || g_108 == &g_109);
        }
        else
        { /* block id: 130 */
            int32_t l_175 = (-1L);
            int32_t *l_180 = (void*)0;
            l_175 = (p_63 != ((uint16_t)g_104[1].f2 - (uint16_t)g_109.f0));
            for (g_34 = 0; (g_34 <= (-25)); g_34 -= 1)
            { /* block id: 134 */
                if (((int32_t)0xA76E4515L + (int32_t)(g_104[1].f1 >= (p_64 >= p_66))))
                { /* block id: 135 */
                    for (p_63 = 0; p_63 < 8; p_63 += 1)
                    {
                        g_106[p_63] = &g_107;
                    }
                }
                else
                { /* block id: 137 */
                    g_93[1] = l_180;
                }
            }
            for (g_109.f1 = (-27); (g_109.f1 > 51); ++g_109.f1)
            { /* block id: 143 */
                int32_t **l_183 = &l_180;
                uint16_t l_195 = 0xCFD1L;
                (*l_183) = func_80(l_180, g_109.f2);
                /* statement id: 144 */
                assert (l_180 == &g_34);
                if ((p_63 == ((int16_t)((int16_t)__builtin_ffs((*l_180)) >> (int16_t)12) % (int16_t)__builtin_clzl(g_109.f0))))
                { /* block id: 145 */
                    const uint8_t l_192 = 0xF1L;
                    (**l_183) = ((uint16_t)((uint16_t)l_192 >> (uint16_t)14) >> (uint16_t)(0x94419D39L > (*l_159)));
                    if ((~g_109.f0))
                    { /* block id: 147 */
                        int32_t l_194 = (-5L);
                        (*l_141) = func_75(l_194, l_195, (g_104[1].f1 || l_194));
                        (*l_180) = ((uint16_t)__builtin_ctzll(g_120.f0) + (uint16_t)((g_34 != (**l_183)) ^ (((uint16_t)((uint16_t)p_65 >> (uint16_t)(-(uint16_t)(((uint16_t)0xAFBAL << (uint16_t)6) & p_66))) >> (uint16_t)14) < (g_109.f0 != ((((-4L) | 0xDFA8L) > g_34) && g_6)))));
                        (*l_141) = func_75(g_109.f1, g_34, p_65);
                    }
                    else
                    { /* block id: 151 */
                        int32_t **l_205 = &g_93[4];
                        (*l_205) = func_80(&g_34, (((func_70(&g_34, l_180, (*l_183)) == (0x18F9L || g_120.f0)) || (*l_159)) || g_104[1].f2));
                    }
                }
                else
                { /* block id: 154 */
                    union U1 **l_206 = &g_108;
                    union U1 ***l_207 = &l_206;
                    int32_t l_219[9];
                    int16_t l_236 = 0L;
                    int i;
                    for (i = 0; i < 9; i++)
                        l_219[i] = (-1L);
                    (*l_207) = l_206;
                    g_93[1] = (void*)0;
                    if ((0xFF3CL == (0x625639F1L <= ((**l_183) | ((uint16_t)((uint16_t)(((uint16_t)(((uint16_t)g_104[1].f2 - (uint16_t)(g_34 < 0x0422L)) || p_66) << (uint16_t)((void*)0 != l_216[0][1])) >= l_219[1]) << (uint16_t)l_219[6]) << (uint16_t)p_65)))))
                    { /* block id: 157 */
                        (*l_141) = (*l_141);
                        (*l_159) = (((((void*)0 != (*l_141)) != (0L > (((p_63 > l_219[1]) < (__builtin_popcountll(g_104[1].f1) ^ g_109.f1)) > (l_220 <= g_34)))) > (-2L)) ^ p_63);
                        (*l_180) = ((int16_t)1L << (int16_t)5);
                    }
                    else
                    { /* block id: 161 */
                        uint32_t l_231 = 4294967286UL;
                        (**l_183) = ((uint32_t)(!(p_66 >= ((int32_t)((int32_t)(*l_159) % (int32_t)(-(uint32_t)l_231)) + (int32_t)(0x09E6L && (((uint16_t)65535UL << (uint16_t)2) || ((g_109.f1 == ((((int32_t)(0L & (p_65 && l_236)) + (int32_t)p_64) ^ l_231) & g_104[1].f1)) < l_237)))))) % (uint32_t)g_109.f2);
                        return (*l_159);
                        /* statement id: 163 */
                        //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
                    }
                }
            }
            /* facts after for loop */
            assert (l_180 == &g_34 || l_180 == 0);
        }
        /* facts after branching */
        assert (g_108 == 0 || g_108 == &g_109);
        l_220 = p_63;
    }
    /* facts after branching */
    //assert (g_93[0] == &l_126 || g_93[0] == &g_34 || g_93[0] == 0);
    assert (g_108 == 0 || g_108 == &g_109);
    return g_98.f0;
    /* statement id: 170 */
    //assert (g_93[0] == dangling || g_93[0] == &g_34 || g_93[0] == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_97 g_34 g_6 g_103 g_106
 * writes: g_97 g_34 g_93 g_6 g_103 g_106
 */
static int32_t  func_70(int32_t * p_71, int32_t * p_72, int32_t * const  p_73)
{ /* block id: 57 */
    int32_t l_96 = 9L;
    union U1 ****l_110 = &g_106[1];
    if ((l_96 < l_96))
    { /* block id: 58 */
        const volatile union U0 **l_99 = &g_97[0];
        (*l_99) = g_97[0];
        for (g_34 = 0; (g_34 >= 0); g_34 -= 1)
        { /* block id: 62 */
            for (l_96 = 6; (l_96 >= 3); l_96 -= 1)
            { /* block id: 65 */
                int32_t **l_100 = &g_93[1];
                (*l_100) = (void*)0;
            }
        }
    }
    else
    { /* block id: 69 */
        volatile union U0 *l_102 = &g_98;
        volatile union U0 **l_101 = &l_102;
        (*l_101) = &g_98;
    }
    for (g_6 = 1; (g_6 <= 8); g_6 += 1)
    { /* block id: 74 */
        const volatile union U1 **l_105[10][7] = {{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]},{(void*)0,&g_103[6],(void*)0,&g_103[6],&g_103[5],&g_103[5],&g_103[6]}};
        int i, j;
        g_103[3] = g_103[6];
    }
    (*l_110) = g_106[1];
    return l_96;
}


/* ------------------------------------------ */
/* 
 * reads : g_6
 * writes: g_6 g_34 g_93
 */
static int32_t * func_75(int16_t  p_76, int32_t  p_77, int16_t  p_78)
{ /* block id: 41 */
    int32_t * const l_83[3] = {(void*)0,(void*)0,(void*)0};
    int32_t *l_84 = &g_34;
    int i;
    l_84 = func_80(l_83[1], ((g_6 <= (&g_34 == l_84)) | (l_84 != l_83[1])));
    return &g_34;
    /* statement id: 56 */
    //assert (func_75_rv == &g_34);
}


/* ------------------------------------------ */
/* 
 * reads : g_6
 * writes: g_6 g_34 g_93
 */
static int32_t * const  func_80(int32_t * const  p_81, uint8_t  p_82)
{ /* block id: 42 */
    int16_t l_94 = 0L;
    int32_t * const l_95 = &g_34;
    for (g_6 = 0; (g_6 < 54); g_6 += 5)
    { /* block id: 45 */
        if (((void*)0 == p_81))
        { /* block id: 46 */
            const int16_t l_89 = 0xA9FFL;
            int32_t *l_90 = &g_34;
            (*l_90) = ((uint32_t)(0UL != 0x4865E5ABL) + (uint32_t)l_89);
        }
        else
        { /* block id: 48 */
            int32_t *l_92 = &g_34;
            int32_t **l_91 = &l_92;
            (*l_91) = p_81;
            /* statement id: 49 */
            //assert (l_92 == 0 || l_92 == &l_126 || l_92 == &g_34);
            g_93[1] = p_81;
            l_94 = 0x9674B172L;
        }
    }
    return l_95;
    /* statement id: 54 */
    //assert (func_80_rv == &g_34);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_98.f0, "g_98.f0", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        transparent_crc(g_104[i].f0, "g_104[i].f0", print_hash_value);
        transparent_crc(g_104[i].f1, "g_104[i].f1", print_hash_value);
        transparent_crc(g_104[i].f2, "g_104[i].f2", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_109.f0, "g_109.f0", print_hash_value);
    transparent_crc(g_109.f1, "g_109.f1", print_hash_value);
    transparent_crc(g_109.f2, "g_109.f2", print_hash_value);
    transparent_crc(g_120.f0, "g_120.f0", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 9; j++)
        {
            transparent_crc(g_238[i][j], "g_238[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 8; i++)
    {
        transparent_crc(g_347[i], "g_347[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_392, "g_392", print_hash_value);
    transparent_crc(g_425.f0, "g_425.f0", print_hash_value);
    transparent_crc(g_442, "g_442", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 164
XXX total union variables: 6

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 62
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 5
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 198
   depth: 2, occurrence: 55
   depth: 3, occurrence: 7
   depth: 4, occurrence: 15
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 5
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 178

XXX times a variable address is taken: 324
XXX times a pointer is dereferenced on RHS: 71
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 7
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 94
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 3
   depth: 3, occurrence: 11
   depth: 4, occurrence: 7
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 31
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 700

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1891
   level: 2, occurrence: 96
   level: 3, occurrence: 117
   level: 4, occurrence: 44
   level: 5, occurrence: 49
XXX number of pointers point to pointers: 103
XXX number of pointers point to scalars: 61
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.1
XXX average alias set size: 1.46

XXX times a non-volatile is read: 672
XXX times a non-volatile is write: 331
XXX times a volatile is read: 45
XXX    times read thru a pointer: 4
XXX times a volatile is write: 18
XXX    times written thru a pointer: 18
XXX times a volatile is available for access: 599
XXX percentage of non-volatile access: 94.1

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 198
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 27
   depth: 2, occurrence: 27
   depth: 3, occurrence: 24
   depth: 4, occurrence: 43
   depth: 5, occurrence: 52

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

