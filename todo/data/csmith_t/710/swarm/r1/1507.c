/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1840126806
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 25;
   const volatile signed f1 : 10;
   const volatile signed f2 : 4;
   signed : 0;
   signed f3 : 15;
   const unsigned f4 : 10;
};

union U1 {
   int32_t  f0;
   volatile uint32_t  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 0x491E29EA;
static volatile int32_t g_65 = (-1);/* VOLATILE GLOBAL g_65 */
static volatile int32_t * volatile g_64 = &g_65;/* VOLATILE GLOBAL g_64 */
static int32_t g_82 = 0x5DBF6070;
static struct S0 g_111 = {164,3,2,113,31};/* VOLATILE GLOBAL g_111 */
static struct S0 *g_110 = &g_111;
static struct S0 ** volatile g_112 = &g_110;/* VOLATILE GLOBAL g_112 */
static int32_t *g_128 = (void*)0;
static int32_t ** volatile g_127 = &g_128;/* VOLATILE GLOBAL g_127 */
static int32_t ** volatile g_130 = &g_128;/* VOLATILE GLOBAL g_130 */
static volatile union U1 g_135 = {-2};/* VOLATILE GLOBAL g_135 */
static volatile union U1 *g_134 = &g_135;
static volatile union U1 ** volatile g_136 = &g_134;/* VOLATILE GLOBAL g_136 */
static int32_t * volatile g_146 = &g_82;/* VOLATILE GLOBAL g_146 */
static int32_t * volatile g_151 = &g_82;/* VOLATILE GLOBAL g_151 */
static int32_t ** volatile g_169 = &g_128;/* VOLATILE GLOBAL g_169 */
static struct S0 ** volatile g_173 = &g_110;/* VOLATILE GLOBAL g_173 */
static union U1 g_180 = {0x2A55EFA8};/* VOLATILE GLOBAL g_180 */
static int32_t ** volatile g_185 = (void*)0;/* VOLATILE GLOBAL g_185 */
static int32_t ** volatile g_186 = &g_128;/* VOLATILE GLOBAL g_186 */
static int32_t ** volatile g_187 = &g_128;/* VOLATILE GLOBAL g_187 */
static int32_t ** volatile g_189 = (void*)0;/* VOLATILE GLOBAL g_189 */
static int32_t * volatile g_192 = &g_180.f0;/* VOLATILE GLOBAL g_192 */
static struct S0 **g_205 = &g_110;
static struct S0 ***g_204 = &g_205;
static struct S0 **** volatile g_203 = &g_204;/* VOLATILE GLOBAL g_203 */
static int32_t ** volatile g_269 = &g_128;/* VOLATILE GLOBAL g_269 */
static volatile union U1 ** volatile * volatile *g_275 = (void*)0;
static struct S0 g_278 = {1458,-25,2,-82,10};/* VOLATILE GLOBAL g_278 */
static union U1 g_316 = {0xAFF29AA7};/* VOLATILE GLOBAL g_316 */
static uint16_t g_325 = 0xF87E;
static struct S0 g_338 = {472,-23,1,-98,7};/* VOLATILE GLOBAL g_338 */
static struct S0 g_354 = {205,21,-3,-67,4};/* VOLATILE GLOBAL g_354 */
static int32_t ** volatile g_372 = &g_128;/* VOLATILE GLOBAL g_372 */
static union U1 *g_387 = &g_316;
static union U1 **g_386 = &g_387;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_30(void);
inline static const int16_t  func_36(uint32_t  p_37, uint32_t  p_38, uint32_t  p_39);
inline static int16_t  func_44(uint32_t  p_45);
inline static int32_t  func_52(int32_t  p_53, int32_t  p_54, int32_t  p_55, int32_t  p_56);
inline static int16_t  func_59(int32_t  p_60, int32_t  p_61, uint32_t  p_62);
static int32_t  func_66(int32_t  p_67, int32_t  p_68, int32_t ** p_69);
inline static int32_t  func_70(int32_t  p_71, int32_t ** p_72, int32_t  p_73, int32_t  p_74);
inline static int32_t ** func_76(int32_t * p_77, uint16_t  p_78, int32_t ** p_79, uint32_t  p_80);
static const int16_t  func_85(int32_t * p_86, int32_t ** p_87);
inline static int32_t * func_88(uint32_t  p_89, int16_t  p_90, int32_t * p_91, int32_t * p_92, int32_t ** p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_65 g_82 g_110 g_112 g_111.f4 g_111.f0 g_111.f3 g_127 g_130 g_128 g_134 g_136 g_146 g_151 g_111.f1 g_135.f2 g_169 g_173 g_111.f2 g_180.f0 g_186 g_187 g_192 g_203 g_135.f0 g_180.f2 g_269 g_180.f1 g_278.f3 g_275 g_278.f0 g_325 g_278.f4 g_205 g_338.f3 g_338.f0 g_316.f0 g_354.f3 g_372 g_354.f2
 * writes: g_64 g_82 g_110 g_128 g_134 g_180.f0 g_204 g_5 g_180.f2 g_316.f0 g_325 g_386
 */
inline static int32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_35 = 3;
    uint32_t l_207 = 0xC41F1468;
    uint32_t l_249 = 0x5A3F0290;
    int32_t l_388 = 0xE7AD38D5;
    l_388 = ((safe_lshift_func_int16_t_s_s((safe_mod_func_uint32_t_u_u(l_35, (-4))), func_36(((safe_add_func_int32_t_s_s((safe_mul_func_int16_t_s_s(func_44(((safe_mul_func_int16_t_s_s(0x6A08, (safe_sub_func_uint16_t_u_u((~(((((+func_52(g_5, (safe_div_func_int16_t_s_s(func_59(g_5, g_5, g_5), 0x66AC)), g_111.f3, g_111.f0)) <= l_35) <= l_35) >= 2U) == l_207)), 6)))) || l_35)), g_111.f0)), l_249)) && (-7)), l_249, g_111.f4))) || 0x1942);
    return l_35;
}


/* ------------------------------------------ */
/* 
 * reads : g_82 g_180.f2 g_135.f0 g_180.f0 g_5 g_269 g_130 g_128 g_187 g_186 g_180.f1 g_278.f3 g_65 g_275 g_278.f0 g_192 g_325 g_146 g_111.f0 g_111.f4 g_278.f4 g_205 g_110 g_136 g_134 g_338.f3 g_338.f0 g_135.f2 g_316.f0 g_354.f3 g_111.f3 g_169 g_372 g_354.f2
 * writes: g_128 g_180.f0 g_5 g_82 g_180.f2 g_316.f0 g_134 g_325 g_386
 */
inline static const int16_t  func_36(uint32_t  p_37, uint32_t  p_38, uint32_t  p_39)
{ /* block id: 154 */
    struct S0 ***l_263 = &g_205;
    uint32_t l_264 = 0U;
    int32_t *l_265 = &g_180.f0;
    uint32_t l_285 = 0x87D275BA;
    union U1 *l_315 = &g_316;
    union U1 **l_314 = &l_315;
    uint32_t l_368 = 0xDFC9C83B;
    struct S0 *****l_384 = (void*)0;
    (*l_265) = (safe_mod_func_uint16_t_u_u((safe_div_func_int16_t_s_s((safe_unary_minus_func_uint16_t_u((safe_add_func_int16_t_s_s((safe_mod_func_int32_t_s_s((safe_sub_func_uint16_t_u_u(__builtin_parityl(__builtin_ia32_crc32qi(g_82, g_180.f2)), g_135.f0)), (safe_mod_func_int32_t_s_s((l_263 != l_263), l_264)))), func_85(l_265, &l_265))))), (*l_265))), p_39));
    for (g_5 = 21; (g_5 != 33); g_5 = safe_add_func_int32_t_s_s(g_5, 4))
    { /* block id: 158 */
        int32_t *l_268 = &g_82;
        union U1 *l_284 = &g_180;
        union U1 **l_283 = &l_284;
        (*g_269) = l_268;
        (*l_265) = (**g_130);
        for (p_37 = 0; (p_37 < 28); p_37 = safe_add_func_int32_t_s_s(p_37, 8))
        { /* block id: 163 */
            const struct S0 *l_277 = &g_278;
            int32_t **l_280 = &g_128;
            for (g_180.f2 = 0; (g_180.f2 != 14); ++g_180.f2)
            { /* block id: 166 */
                int32_t **l_274 = &l_268;
                l_265 = (*g_187);
                (*l_274) = (*g_186);
            }
        }
    }
    for (g_180.f0 = 0; (g_180.f0 > (-21)); --g_180.f0)
    { /* block id: 188 */
        struct S0 ***l_288 = &g_205;
        int32_t *l_289 = &g_82;
        (*l_289) = (l_288 == l_263);
    }
    if ((safe_rshift_func_uint16_t_u_u(p_38, (((65529U != g_180.f1) && g_180.f2) & g_278.f3))))
    { /* block id: 191 */
        uint32_t l_298 = 4294967295U;
        int16_t l_305 = 3;
        int32_t *l_336 = &g_316.f0;
        struct S0 *l_353 = &g_354;
        int32_t l_357 = 0xCEE0769A;
        union U1 ***l_376 = &l_314;
        for (l_264 = 0; (l_264 <= 4); ++l_264)
        { /* block id: 194 */
            int32_t **l_294 = (void*)0;
            int32_t **l_295 = &g_128;
            const union U1 *l_302 = &g_180;
            const union U1 **l_301 = &l_302;
            struct S0 *l_337 = &g_338;
            (*l_295) = (void*)0;
            (*l_265) = ((((safe_rshift_func_int16_t_s_s(l_298, 4)) >= 65529U) || (safe_rshift_func_uint16_t_u_s((l_301 == &g_134), 8))) ^ ((safe_sub_func_uint16_t_u_u(0x14BD, l_298)) > l_305));
            if (l_298)
            { /* block id: 197 */
                uint32_t l_331 = 4294967287U;
                struct S0 **l_367 = &l_353;
                for (g_180.f0 = 0; (g_180.f0 < (-22)); g_180.f0 = safe_sub_func_uint16_t_u_u(g_180.f0, 2))
                { /* block id: 200 */
                    int32_t l_326 = 0x19C6BE0F;
                    int32_t l_351 = 0x2E28897A;
                    struct S0 *l_352 = (void*)0;
                    if (((safe_rshift_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((__builtin_ia32_crc32qi(g_65, g_278.f3) <= ((void*)0 != g_275)), (safe_add_func_int16_t_s_s((g_5 && (l_314 == &g_134)), (+func_52((p_39 || 8U), p_39, g_278.f0, l_298)))))), 9)) == p_38))
                    { /* block id: 201 */
                        uint16_t l_320 = 0U;
                        l_326 = (__builtin_clz((safe_rshift_func_uint16_t_u_u(((l_320 & (*g_192)) < ((safe_div_func_uint16_t_u_u(0x2B69, g_180.f2)) | ((((p_37 <= g_278.f0) == (safe_lshift_func_int16_t_s_s((p_39 >= 0xCB6989C7), g_325))) < p_39) ^ p_39))), 14))) > p_38);
                    }
                    else
                    { /* block id: 203 */
                        int32_t *l_327 = &g_316.f0;
                        (*l_327) = (*g_146);
                    }
                    if (((~g_111.f0) | (safe_add_func_uint16_t_u_u((l_331 != (safe_sub_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((g_180.f1 <= (l_331 > g_111.f4)), p_38)), (((g_278.f4 <= 0x7CB5A7BD) | 0x8EA8) > (-1))))), l_326))))
                    { /* block id: 206 */
                        if (p_37)
                            break;
                        return p_39;
                    }
                    else
                    { /* block id: 209 */
                        int32_t l_350 = 2;
                        l_337 = (**l_263);
                        l_351 = func_70(func_52((safe_mul_func_int16_t_s_s((safe_div_func_uint32_t_u_u(__builtin_ffsll((safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(8U, ((safe_mul_func_uint16_t_u_u(((((&l_336 != (void*)0) || p_39) ^ (((void*)0 == (*g_136)) <= (p_37 | p_37))) && ((safe_unary_minus_func_int32_t_s(l_350)) && 0xD816DE6D)), g_338.f3)) ^ 0xDB31))), p_37))), 0x1CE282A7)), l_331)), g_278.f0, g_111.f4, l_326), &g_128, p_37, p_39);
                        l_353 = l_352;
                    }
                }
                (*l_265) = (g_338.f0 & (__builtin_clzll((safe_add_func_int32_t_s_s(p_39, (p_37 != ((0x2465 || __builtin_ctz(l_357)) & (~p_37)))))) && (safe_sub_func_int32_t_s_s(((safe_mod_func_int32_t_s_s((__builtin_bswap32(((safe_rshift_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u((func_52((func_70(((void*)0 == g_275), l_294, g_278.f3, g_135.f2) || (*l_336)), g_316.f0, p_38, g_354.f3) <= 0x992C4716), l_331)) ^ 0xD3C1), 10)) == g_5)) | 0xC055), p_38)) || p_39), g_111.f3))));
                if (p_37)
                    continue;
                l_368 = (&g_110 != l_367);
            }
            else
            { /* block id: 218 */
                int32_t *l_369 = &g_316.f0;
                (*l_295) = l_369;
            }
            (*l_295) = (*g_186);
        }
        for (l_264 = 2; (l_264 >= 40); l_264 = safe_add_func_uint32_t_u_u(l_264, 6))
        { /* block id: 225 */
            int16_t l_373 = 0x917E;
            int32_t *l_378 = &g_82;
            if ((*g_146))
                break;
            (*g_372) = (*g_169);
            if (l_373)
                continue;
            for (l_357 = 10; (l_357 >= (-30)); l_357 = safe_sub_func_uint16_t_u_u(l_357, 1))
            { /* block id: 231 */
                union U1 ****l_377 = &l_376;
                int32_t **l_379 = &l_265;
                (*l_377) = l_376;
                (*l_379) = l_378;
            }
        }
        for (g_325 = 0; (g_325 >= 36); g_325 = safe_add_func_uint32_t_u_u(g_325, 1))
        { /* block id: 238 */
            int32_t *l_382 = &g_82;
            int32_t **l_383 = &l_336;
            (*l_383) = l_382;
        }
    }
    else
    { /* block id: 241 */
        union U1 **l_385 = &l_315;
        l_384 = l_384;
        g_386 = l_385;
    }
    return g_354.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_180.f0 g_135.f2 g_135.f0 g_111.f0
 * writes: g_180.f0 g_128
 */
inline static int16_t  func_44(uint32_t  p_45)
{ /* block id: 130 */
    uint32_t l_230 = 4294967293U;
    int32_t *l_246 = &g_180.f0;
    if ((0x5FE2E027 >= ((safe_add_func_int16_t_s_s(g_180.f0, (safe_div_func_int32_t_s_s(2, 0x96A4908D)))) <= (+g_135.f2))))
    { /* block id: 131 */
        int32_t *l_218 = &g_180.f0;
lbl_221:
        (*l_218) = (safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(g_135.f0, 12)), (+__builtin_parityl(g_111.f0))));
        for (p_45 = 0; (p_45 <= 47); ++p_45)
        { /* block id: 135 */
            if (g_180.f0)
                goto lbl_221;
        }
    }
    else
    { /* block id: 138 */
        const int16_t l_231 = 9;
        int32_t **l_248 = &g_128;
        for (p_45 = 0; (p_45 == 18); ++p_45)
        { /* block id: 141 */
            if (p_45)
                break;
        }
        for (g_180.f0 = 29; (g_180.f0 == (-17)); g_180.f0 = safe_sub_func_int16_t_s_s(g_180.f0, 1))
        { /* block id: 146 */
            union U1 *l_229 = &g_180;
            union U1 **l_228 = &l_229;
            union U1 ***l_227 = &l_228;
            union U1 ****l_226 = &l_227;
            int32_t l_238 = (-4);
            int32_t **l_247 = &l_246;
            (*l_226) = (void*)0;
            if (l_230)
                continue;
            (*l_247) = &l_238;
        }
        (*l_248) = (void*)0;
    }
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_52(int32_t  p_53, int32_t  p_54, int32_t  p_55, int32_t  p_56)
{ /* block id: 128 */
    uint32_t l_206 = 0U;
    return l_206;
}


/* ------------------------------------------ */
/* 
 * reads : g_65 g_5 g_82 g_110 g_112 g_111.f4 g_111.f0 g_111.f3 g_127 g_130 g_128 g_134 g_136 g_146 g_151 g_111.f1 g_135.f2 g_169 g_173 g_111.f2 g_180.f0 g_186 g_187 g_192 g_203
 * writes: g_64 g_82 g_110 g_128 g_134 g_180.f0 g_204
 */
inline static int16_t  func_59(int32_t  p_60, int32_t  p_61, uint32_t  p_62)
{ /* block id: 37 */
    int32_t **l_63 = (void*)0;
    struct S0 *l_154 = (void*)0;
    int32_t *l_168 = &g_82;
    g_64 = (void*)0;
    (*g_151) = func_66(((g_65 | __builtin_popcountll(g_5)) > ((void*)0 != &p_61)), g_5, l_63);
    if ((safe_mod_func_uint32_t_u_u(p_62, p_62)))
    { /* block id: 92 */
        l_154 = l_154;
    }
    else
    { /* block id: 94 */
        volatile union U1 **l_155 = &g_134;
        int32_t l_162 = 0xA8B47936;
        int32_t *l_167 = &g_82;
        (*l_155) = (*g_136);
        (*l_155) = (*l_155);
        (*g_169) = func_88((4294967292U | (g_111.f1 || (safe_rshift_func_int16_t_s_u((1 != (safe_mod_func_int16_t_s_s(((0 ^ (&l_154 != (void*)0)) != (safe_mod_func_uint32_t_u_u(l_162, (safe_rshift_func_int16_t_s_s(g_135.f2, 12))))), __builtin_clz((safe_sub_func_int16_t_s_s(((void*)0 != &g_110), 0x2982)))))), 7)))), p_61, l_167, l_168, &l_167);
    }
    for (g_82 = 0; (g_82 > 18); ++g_82)
    { /* block id: 101 */
        int32_t *l_172 = &g_82;
        p_61 = p_61;
        (*g_173) = l_154;
        for (p_62 = (-23); (p_62 >= 16); p_62 = safe_add_func_uint32_t_u_u(p_62, 4))
        { /* block id: 106 */
            int32_t l_176 = 0xFFFD36A2;
            struct S0 **l_202 = &g_110;
            struct S0 ***l_201 = &l_202;
            if (l_176)
            { /* block id: 107 */
                return (*l_168);
            }
            else
            { /* block id: 109 */
                union U1 *l_179 = &g_180;
                int32_t l_184 = 1;
                struct S0 *l_191 = &g_111;
                if ((((safe_div_func_int32_t_s_s(((l_176 > __builtin_ia32_crc32qi(g_111.f2, ((l_179 == (void*)0) > (((((0x407D1D32 != __builtin_popcount(((((p_62 <= g_111.f4) && ((!((safe_sub_func_int16_t_s_s(__builtin_ffsl(g_82), g_111.f0)) | p_62)) ^ 0xF6B3)) < 0x9BF6F6D5) < (*l_168)))) < l_184) < 0x837F) & g_180.f0) ^ (*l_168))))) & g_82), 0x6633CC6E)) < p_61) ^ l_184))
                { /* block id: 110 */
                    int32_t **l_190 = &g_128;
                    if (l_184)
                    { /* block id: 111 */
                        int32_t *l_188 = &g_180.f0;
                        (*g_186) = &l_184;
                        (*g_187) = &p_61;
                        (*g_130) = l_188;
                    }
                    else
                    { /* block id: 115 */
                        l_176 = (l_190 != (void*)0);
                        (*g_192) = (l_191 == (*g_173));
                    }
                }
                else
                { /* block id: 119 */
                    int32_t l_200 = 0xFF31343A;
                    p_61 = ((g_5 < (g_65 != func_85(&l_176, &l_172))) > (safe_add_func_int32_t_s_s(((safe_unary_minus_func_int16_t_s((((1 && 0x3C32) == (safe_lshift_func_int16_t_s_s(((p_60 ^ l_200) ^ 0x0D9D), g_111.f3))) >= l_200))) > 0), (-4))));
                }
                (*g_203) = l_201;
            }
            if (p_60)
                break;
        }
    }
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_82 g_65 g_110 g_112 g_111.f4 g_111.f0 g_111.f3 g_127 g_130 g_128 g_134 g_136 g_146
 * writes: g_82 g_110 g_128 g_134
 */
static int32_t  func_66(int32_t  p_67, int32_t  p_68, int32_t ** p_69)
{ /* block id: 39 */
    int16_t l_75 = 0xFFFF;
    int32_t *l_81 = &g_82;
    (*l_81) = func_70(l_75, func_76(l_81, (safe_div_func_uint32_t_u_u((func_85(func_88(g_5, (0x7C74 && 1U), &g_82, &g_82, p_69), &l_81) & g_111.f3), p_68)), p_69, g_111.f4), p_67, p_67);
    (*l_81) = (((void*)0 == l_81) < (((void*)0 != &l_81) & ((*l_81) <= (safe_rshift_func_uint16_t_u_u(((((+(*l_81)) < __builtin_parityll((&l_81 == (void*)0))) || (*g_146)) || (-10)), p_68)))));
    return (*l_81);
}


/* ------------------------------------------ */
/* 
 * reads : g_136 g_134 g_146
 * writes: g_134 g_82
 */
inline static int32_t  func_70(int32_t  p_71, int32_t ** p_72, int32_t  p_73, int32_t  p_74)
{ /* block id: 84 */
    volatile union U1 **l_145 = &g_134;
    int32_t l_147 = (-5);
    (*l_145) = (*g_136);
    (*g_146) = (p_74 > (((void*)0 == &g_110) > (-9)));
    return l_147;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_82
 */
inline static int32_t ** func_76(int32_t * p_77, uint16_t  p_78, int32_t ** p_79, uint32_t  p_80)
{ /* block id: 80 */
    int16_t l_143 = 0xD11F;
    int32_t **l_144 = &g_128;
    (*p_77) = l_143;
    (*p_77) = ((void*)0 == &g_128);
    return l_144;
}


/* ------------------------------------------ */
/* 
 * reads : g_82 g_180.f0
 * writes: g_128
 */
static const int16_t  func_85(int32_t * p_86, int32_t ** p_87)
{ /* block id: 71 */
    int32_t **l_137 = (void*)0;
    int32_t **l_138 = &g_128;
    int32_t *l_141 = &g_82;
lbl_140:
    (*l_138) = (void*)0;
    if (((-8) <= (!(**p_87))))
    { /* block id: 73 */
        if (g_82)
            goto lbl_140;
        (*l_138) = l_141;
    }
    else
    { /* block id: 76 */
        uint32_t l_142 = 0xF69DBBC9;
        l_142 = (-6);
    }
    return (*l_141);
}


/* ------------------------------------------ */
/* 
 * reads : g_82 g_65 g_5 g_110 g_112 g_111.f4 g_111.f0 g_111.f3 g_127 g_130 g_128 g_134 g_136
 * writes: g_82 g_110 g_128 g_134
 */
inline static int32_t * func_88(uint32_t  p_89, int16_t  p_90, int32_t * p_91, int32_t * p_92, int32_t ** p_93)
{ /* block id: 40 */
    int32_t *l_94 = &g_82;
    if ((65533U > (l_94 != l_94)))
    { /* block id: 41 */
        int32_t *l_95 = (void*)0;
        uint32_t l_106 = 4294967291U;
        int32_t *l_129 = &g_82;
        (*p_92) = (l_94 != l_95);
        if ((safe_add_func_uint32_t_u_u((0x2A6A8E49 | (*p_91)), __builtin_popcountl(((((safe_div_func_uint16_t_u_u((g_65 < ((g_5 > g_5) <= g_5)), g_82)) == ((g_82 < ((safe_mul_func_uint16_t_u_u((safe_div_func_int32_t_s_s((g_82 >= l_106), 0xC08F5283)), p_89)) < (*l_94))) <= g_5)) == (*l_94)) > 0)))))
        { /* block id: 43 */
            int32_t *l_109 = &g_82;
            int32_t **l_126 = (void*)0;
            (*p_91) = (safe_rshift_func_int16_t_s_u((g_65 ^ __builtin_ctzl(g_82)), (l_109 != &g_82)));
            (*g_112) = g_110;
            if ((safe_lshift_func_uint16_t_u_s((0xFF67 ^ g_111.f4), 15)))
            { /* block id: 46 */
                (*p_91) = (safe_mul_func_int16_t_s_s((safe_mul_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(65527U, 1)), (+p_89))), ((*p_92) & (safe_rshift_func_int16_t_s_s((0x25BDF0D7 < g_111.f0), g_111.f0)))));
                return p_91;
            }
            else
            { /* block id: 49 */
                for (p_90 = 0; (p_90 == (-4)); p_90 = safe_sub_func_int32_t_s_s(p_90, 1))
                { /* block id: 52 */
                    if ((*l_109))
                        break;
                }
                (*p_92) = g_111.f3;
            }
            (*g_127) = p_91;
        }
        else
        { /* block id: 58 */
            int32_t l_131 = 0xD0790421;
            (*g_130) = l_129;
            (*l_129) = l_131;
            return (*g_127);
        }
        (**g_130) = ((__builtin_bswap64(g_65) == g_111.f4) >= (*p_91));
    }
    else
    { /* block id: 64 */
        int32_t *l_132 = (void*)0;
        int32_t **l_133 = &g_128;
        (*l_94) = 0xE6A82D78;
        (*l_133) = l_132;
        (*g_130) = (*g_130);
        (*g_136) = g_134;
    }
    return (*g_127);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_65, "g_65", print_hash_value);
    transparent_crc(g_82, "g_82", print_hash_value);
    transparent_crc(g_111.f0, "g_111.f0", print_hash_value);
    transparent_crc(g_111.f1, "g_111.f1", print_hash_value);
    transparent_crc(g_111.f2, "g_111.f2", print_hash_value);
    transparent_crc(g_111.f3, "g_111.f3", print_hash_value);
    transparent_crc(g_111.f4, "g_111.f4", print_hash_value);
    transparent_crc(g_135.f0, "g_135.f0", print_hash_value);
    transparent_crc(g_135.f1, "g_135.f1", print_hash_value);
    transparent_crc(g_135.f2, "g_135.f2", print_hash_value);
    transparent_crc(g_278.f0, "g_278.f0", print_hash_value);
    transparent_crc(g_278.f1, "g_278.f1", print_hash_value);
    transparent_crc(g_278.f2, "g_278.f2", print_hash_value);
    transparent_crc(g_278.f3, "g_278.f3", print_hash_value);
    transparent_crc(g_278.f4, "g_278.f4", print_hash_value);
    transparent_crc(g_316.f0, "g_316.f0", print_hash_value);
    transparent_crc(g_316.f1, "g_316.f1", print_hash_value);
    transparent_crc(g_316.f2, "g_316.f2", print_hash_value);
    transparent_crc(g_325, "g_325", print_hash_value);
    transparent_crc(g_338.f0, "g_338.f0", print_hash_value);
    transparent_crc(g_338.f1, "g_338.f1", print_hash_value);
    transparent_crc(g_338.f2, "g_338.f2", print_hash_value);
    transparent_crc(g_338.f3, "g_338.f3", print_hash_value);
    transparent_crc(g_338.f4, "g_338.f4", print_hash_value);
    transparent_crc(g_354.f0, "g_354.f0", print_hash_value);
    transparent_crc(g_354.f1, "g_354.f1", print_hash_value);
    transparent_crc(g_354.f2, "g_354.f2", print_hash_value);
    transparent_crc(g_354.f3, "g_354.f3", print_hash_value);
    transparent_crc(g_354.f4, "g_354.f4", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 85
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 2
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 0
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 33

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 135
   depth: 2, occurrence: 23
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 101

XXX times a variable address is taken: 105
XXX times a pointer is dereferenced on RHS: 35
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 4
XXX times a pointer is dereferenced on LHS: 54
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 219

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 193
   level: 2, occurrence: 40
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 31
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 25.7
XXX average alias set size: 1.29

XXX times a non-volatile is read: 306
XXX times a non-volatile is write: 122
XXX times a volatile is read: 34
XXX    times read thru a pointer: 0
XXX times a volatile is write: 19
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 170
XXX percentage of non-volatile access: 89

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 117
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 31
   depth: 2, occurrence: 24
   depth: 3, occurrence: 16
   depth: 4, occurrence: 5
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 20.7
XXX percentage an existing variable is used: 79.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

