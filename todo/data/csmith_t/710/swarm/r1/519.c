/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2175645856
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int8_t * f0;
   uint32_t  f1;
};

union U1 {
   uint16_t  f0;
   uint16_t  f1;
   uint32_t  f2;
   const int8_t * const  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static int32_t * func_6(uint32_t  p_7, const int8_t * p_8, int32_t  p_9);
inline static const int8_t * func_11(int32_t  p_12, int8_t * p_13, int32_t  p_14, const int32_t  p_15, int32_t  p_16);
static int8_t * func_17(int32_t * p_18, uint32_t  p_19, int8_t * p_20, int8_t * p_21);
static int16_t  func_28(float  p_29, int32_t  p_30, const int32_t  p_31);
static float  func_32(int32_t  p_33, union U1  p_34, uint32_t  p_35, const int32_t ** p_36);
inline static int32_t  func_37(int8_t * p_38, union U1  p_39, int32_t ** p_40, int8_t  p_41, int32_t ** p_42);
static union U1  func_44(int32_t ** p_45);
inline static int32_t ** func_46(uint32_t  p_47);
static const int32_t  func_54(const int32_t  p_55, uint32_t  p_56, int8_t  p_57);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x5AB3E90A;
    uint16_t l_10 = 0x9E2A;
    int32_t l_25 = (-1);
    int32_t *l_24 = &l_25;
    int32_t *l_748 = &l_25;
    int32_t **l_747 = &l_748;
    const int32_t **l_1008 = (void*)0;
    int8_t *l_1237 = (void*)0;
    int32_t l_1261 = (-1);
    int32_t *l_1327 = &l_25;
    const int32_t l_1351 = (-7);
    int32_t ** const *l_1371 = &l_747;
    int32_t ** const **l_1370 = &l_1371;
    const int16_t l_1372 = 0xCC72;
    int16_t l_1377 = 9;
    float l_1378 = 0x2.FDE142p-25;
    float *l_1379 = &l_1378;
    float l_1381 = (-0x7.6p+1);
    float *l_1380 = &l_1381;
    int16_t l_1382 = 0x4D34;
    union U0 l_1383 = {0};
    uint32_t l_1391 = 0x82E827B9;
    uint32_t *l_1390 = &l_1391;
    uint32_t **l_1389 = &l_1390;
    float l_1393 = 0x0.Dp+1;
    float *l_1392 = &l_1393;
    uint32_t l_1395 = 9U;
    float l_1398 = (-0x1.Cp+1);
    int32_t l_1399 = 0x03148589;
    int16_t l_1400 = 0xA7DC;
    float *l_1401 = &l_1398;
    int16_t l_1402 = (-1);
    int32_t l_1403 = 1;
    float l_1405 = (-0x9.3p+1);
    float *l_1404 = &l_1405;
    int8_t l_1406 = (-3);
    int32_t *l_1414 = &l_1403;
    int32_t ** const l_1413 = &l_1414;
    int32_t ****l_1422 = (void*)0;
    int32_t *****l_1421 = &l_1422;
    uint32_t l_1424 = 0x0986913A;
    int8_t ***l_1429 = (void*)0;
    int8_t ****l_1435 = &l_1429;
    int8_t l_1444 = 1;
    for (l_2 = (-24); (l_2 == (-18)); l_2 = safe_add_func_int16_t_s_s(l_2, 9))
    { /* block id: 3 */
        int8_t l_5 = (-6);
        int32_t *l_23 = &l_2;
        int32_t **l_22 = &l_23;
        int8_t *l_43 = &l_5;
        union U1 l_1007 = {0xF083};
        int32_t l_1235 = 2;
        uint32_t *l_1236 = &l_1007.f2;
        int8_t **l_1301 = &l_1237;
        int32_t l_1302 = 0x06A91CA5;
        int8_t ***l_1330 = &l_1301;
        int8_t ****l_1329 = &l_1330;
        int8_t ***** const l_1328 = &l_1329;
        int32_t l_1331 = 1;
        int32_t *l_1332 = &l_1235;
        int32_t * const *l_1338 = (void*)0;
        int32_t * const **l_1337 = &l_1338;
        int32_t * const ***l_1336 = &l_1337;
        int32_t * const ****l_1335 = &l_1336;
        union U0 *l_1339 = (void*)0;
        int8_t l_1350 = 0x13;
        const int16_t l_1365 = 0xC122;
        const int8_t *l_1367 = &l_5;
        (*l_747) = (l_5 , func_6(l_10, ((*l_1301) = func_11(l_5, func_17((l_24 = ((*l_22) = (void*)0)), ((*l_1236) = (safe_add_func_int16_t_s_s(func_28(func_32(func_37(l_43, func_44(func_46(l_10)), l_22, l_2, l_747), l_1007, l_2, l_1008), l_5, l_1007.f0), l_1235))), l_1237, &l_5), l_2, l_5, l_1261)), l_1302));
        /* statement id: 522 */
        assert (l_24 == 0);
        assert (l_748 == 0);
        assert (l_23 == 0);
                for (l_1302 = 0; (l_1302 == (-13)); l_1302 = safe_sub_func_int16_t_s_s(l_1302, 1))
        { /* block id: 525 */
            int8_t l_1323 = 0;
            float *l_1324 = (void*)0;
            float l_1326 = (-0x4.Ap+1);
            float *l_1325 = &l_1326;
            (*l_1325) = l_1323;
            l_1327 = l_1325;
            /* statement id: 527 */
            assert (l_1327 == &l_1326);
            (*l_1325) = (((void*)0 == l_1328) > ((0x0.0857C0p-30 < ((l_1325 == l_1324) > l_1323)) == l_1323));
        }
        if (((*l_1332) = l_1331))
        { /* block id: 531 */
            uint16_t l_1333 = 0x1489;
            int32_t * const ****l_1334 = (void*)0;
            int8_t l_1346 = 0x34;
            union U0 l_1349 = {0};
            uint32_t *l_1352 = &l_1349.f1;
            int32_t l_1353 = 0;
            l_1335 = (l_1333 , l_1334);
            /* statement id: 532 */
            assert (l_1335 == 0);
            l_1339 = l_1339;
            (*l_747) = (((l_1353 = (((*l_1352) = (l_1333 && (safe_mod_func_int32_t_s_s((l_1333 || ((safe_lshift_func_int16_t_s_u((*l_1332), 14)) , ((safe_lshift_func_uint16_t_u_s(l_1346, (safe_add_func_int16_t_s_s(0x9CF0, (l_1349 , (l_1346 > ((l_1350 & ((0x17BF ^ l_1333) > (*l_1332))) ^ l_1351))))))) && l_1346))), 4294967295U)))) & (*l_1332))) <= 65535U) , (*l_22));
            /* statement id: 536 */
                    }
        else
        { /* block id: 537 */
            uint32_t l_1356 = 0xA37C68D5;
            union U0 l_1360 = {0};
            union U0 *l_1359 = &l_1360;
            union U0 **l_1361 = &l_1339;
            uint32_t l_1362 = 0x3DDECBEA;
            int32_t l_1366 = 0x571E1BD6;
            int32_t ***l_1369 = (void*)0;
            int32_t ****l_1368 = &l_1369;
            float l_1374 = 0x0.8p+1;
            float *l_1373 = &l_1374;
            (*l_22) = func_6(((safe_mul_func_uint32_t_u_u(l_1356, ((-7) > (safe_unary_minus_func_uint16_t_u((((((safe_unary_minus_func_int32_t_s((((*l_1361) = l_1359) == (void*)0))) , ((*l_1359) , ((*l_1236) = l_1362))) , (l_1366 = ((safe_lshift_func_uint16_t_u_s(0xEFDA, l_1365)) ^ ((l_1356 , l_1362) == l_1362)))) || l_1356) , 0x5179)))))) , l_1356), l_1367, l_1356);
            /* statement id: 541 */
            assert (l_1339 == &l_1360);
            assert (l_1360.f0 == 0);
            (*l_1332) = ((-1) < ((func_44(&l_1332) , l_1368) == l_1370));
            if (l_1007.f2)
                goto lbl_1407;
            (*l_1373) = l_1372;
        }
        /* facts after branching */
        assert (l_1335 == &l_1336 || l_1335 == 0);
        //assert (l_1339 == dangling || l_1339 == 0);
    }
    /* facts after for loop */
    assert (l_24 == 0 || l_24 == &l_25);
    assert (l_748 == 0 || l_748 == &l_25);
    //assert (l_1327 == dangling || l_1327 == &l_25);
    l_1382 = ((*l_1380) = (safe_div_func_float_f_f(l_10, ((*l_1379) = ((0 ^ l_1377) , l_1378)))));
lbl_1407:
    l_1406 = (((*l_1404) = (l_1383 , ((safe_mul_func_float_f_f(((((*l_1401) = (0x2.6A0550p-97 != (safe_add_func_float_f_f(((!((*l_1392) = ((l_1383 , ((*l_1380) = (l_1389 != &l_1390))) != ((*l_1379) = l_1391)))) != (((((!l_1395) <= l_1382) >= (safe_add_func_float_f_f((l_1399 , l_1261), l_1395))) > l_25) <= l_1400)), 0x5.1D7749p+42)))) <= l_1402) < l_1403), l_25)) > (-0x2.7p+1)))) >= l_1395);
    for (l_1391 = (-4); (l_1391 > 42); ++l_1391)
    { /* block id: 558 */
        int8_t l_1410 = (-1);
        int32_t *****l_1423 = &l_1422;
        int32_t l_1428 = 0x296CFD68;
        int32_t *l_1430 = &l_1428;
        int16_t *l_1434 = &l_1400;
        union U0 l_1436 = {0};
        uint32_t l_1441 = 1U;
        uint16_t *l_1442 = (void*)0;
        uint16_t *l_1443 = &l_10;
        if (l_1410)
            break;
        (*l_1404) = (((safe_add_func_float_f_f(((void*)0 == l_1413), (l_1410 , ((-0x1.0p+1) == (safe_add_func_float_f_f(((safe_add_func_float_f_f(((((*l_1392) = ((l_1410 < ((*l_1401) = 0x1.F261A8p+75)) > (safe_sub_func_float_f_f((((l_1421 == l_1423) >= l_1410) >= l_1424), 0x6.7p-1)))) > 0x5.8p-1) == l_1410), l_1410)) == 0x8.218F24p+42), (-0x1.Dp-1))))))) >= l_1410) == l_1410);
        (*l_1430) = ((l_1410 | (!((safe_lshift_func_int16_t_s_u((l_1428 < l_1410), l_1410)) == ((void*)0 == l_1429)))) , l_1410);
        (*l_1430) = (((*l_1430) <= ((!((*l_1434) = (*l_1430))) >= (((void*)0 != l_1435) , ((*l_1443) = (((((l_1436 , ((l_1261 = (safe_rshift_func_uint16_t_u_u((((*l_1430) ^ ((*l_1430) , (safe_mod_func_int16_t_s_s((0x3CDD276D >= (l_1383 , (*l_1430))), (*l_1430))))) & l_1441), 12))) , (*l_1430))) != (-0x1.6p+1)) < 0x4.9E51BDp-2) , (*l_1430)) == 0x2C95A241))))) ^ (*l_1430));
        /* statement id: 567 */
        assert (l_1436.f0 == 0);
    }
    return l_1444;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_6(uint32_t  p_7, const int8_t * p_8, int32_t  p_9)
{ /* block id: 510 */
    int32_t l_1309 = 0xF4AA7EF1;
    int32_t *l_1308 = &l_1309;
    int32_t **l_1310 = &l_1308;
    int32_t l_1312 = (-1);
    int32_t *l_1311 = &l_1312;
    int32_t *l_1313 = &l_1309;
    int32_t *l_1314 = &l_1309;
    int32_t *l_1315 = &l_1309;
    int32_t *l_1316 = &l_1309;
    int32_t *l_1317 = &l_1309;
    int32_t *l_1318 = &l_1312;
    int32_t *l_1319 = &l_1312;
    int32_t *l_1320 = (void*)0;
    for (p_9 = 0; (p_9 == (-9)); p_9 = safe_sub_func_uint16_t_u_u(p_9, 7))
    { /* block id: 513 */
        float l_1306 = 0xF.87F399p-18;
        float *l_1305 = &l_1306;
        int32_t l_1307 = 0x8EF6C42C;
        (*l_1305) = p_7;
        l_1307 = ((*l_1305) = p_7);
    }
    (*l_1310) = l_1308;
    (*l_1311) = ((**l_1310) = (*l_1308));
    return l_1320;
    /* statement id: 521 */
    //assert (func_6_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int8_t * func_11(int32_t  p_12, int8_t * p_13, int32_t  p_14, const int32_t  p_15, int32_t  p_16)
{ /* block id: 496 */
    int32_t l_1262 = 0xCFB2283A;
    int32_t l_1283 = 0xCFC5E6A4;
    uint32_t l_1284 = 1U;
    uint32_t *l_1285 = (void*)0;
    uint32_t *l_1286 = &l_1284;
    uint32_t *l_1287 = (void*)0;
    uint32_t *l_1288 = (void*)0;
    uint32_t l_1290 = 4294967293U;
    uint32_t *l_1289 = &l_1290;
    union U1 l_1291 = {65535U};
    float l_1293 = 0x1.Dp+1;
    float *l_1292 = &l_1293;
    l_1262 = ((l_1262 < (-(((&p_14 == &p_16) != ((*l_1292) = ((safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f((((~((safe_mul_func_int16_t_s_s(l_1262, p_16)) , (((((l_1262 | ((((*l_1289) = ((*l_1286) = ((safe_rshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_s((safe_div_func_int32_t_s_s(p_12, (safe_rshift_func_int16_t_s_u((((((safe_rshift_func_int16_t_s_u(0xE514, 13)) , p_14) , 0x92C2) > l_1262) > l_1262), l_1283)))), 12)) | l_1262), l_1283)) != l_1284))) , p_12) ^ p_14)) != l_1262) >= 0x98E1C8D3) , l_1283) != (-1)))) , l_1291) , 0x4.02A020p-53), (-0x6.Dp+1))), p_12)), l_1283)) <= 0x4.7p+1))) == l_1291.f1))) >= l_1291.f0);
    for (p_12 = (-26); (p_12 < (-8)); p_12++)
    { /* block id: 503 */
        int32_t *l_1296 = &l_1262;
        const int32_t **l_1297 = (void*)0;
        int32_t **l_1298 = &l_1296;
        (*l_1298) = l_1296;
        (*l_1292) = (*l_1296);
    }
    (*l_1292) = (safe_mul_func_float_f_f(l_1291.f1, p_12));
    return p_13;
    /* statement id: 508 */
    //assert (func_11_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t * func_17(int32_t * p_18, uint32_t  p_19, int8_t * p_20, int8_t * p_21)
{ /* block id: 490 */
    int32_t l_1240 = 0x7AB12340;
    union U0 l_1244 = {0};
    union U0 *l_1243 = &l_1244;
    union U0 **l_1242 = &l_1243;
    union U0 ***l_1241 = &l_1242;
    int16_t l_1252 = 0;
    int16_t *l_1251 = &l_1252;
    uint16_t l_1254 = 0x5D20;
    uint16_t *l_1253 = &l_1254;
    int16_t l_1256 = 1;
    int16_t *l_1255 = &l_1256;
    float l_1258 = 0x0.8p-1;
    float *l_1257 = &l_1258;
    int8_t l_1260 = (-5);
    int8_t *l_1259 = &l_1260;
    (*l_1257) = (safe_sub_func_float_f_f((l_1240 <= (((((l_1241 != ((((*l_1255) = ((((0 >= ((safe_sub_func_uint32_t_u_u(0U, (safe_lshift_func_uint16_t_u_s(1U, 4)))) > (((safe_add_func_uint16_t_u_u((((*l_1253) = (((*l_1251) = (0x9B83C979 >= 6U)) , (0x682F0C33 == 1U))) | l_1240), l_1240)) , 0x005D) & l_1240))) , 0xE103) || (-1)) || p_19)) || p_19) , &l_1242)) && l_1240) != 0U) , l_1240) <= p_19)), 0x1.Dp-1));
    /* statement id: 494 */
    assert (l_1244.f0 == 0);
    return p_20;
    /* statement id: 495 */
    //assert (func_17_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_28(float  p_29, int32_t  p_30, const int32_t  p_31)
{ /* block id: 482 */
    uint16_t l_1219 = 1U;
    uint16_t *l_1218 = &l_1219;
    uint16_t **l_1217 = &l_1218;
    float l_1232 = 0x3.35EDBEp-40;
    const float *l_1231 = &l_1232;
    const float **l_1230 = &l_1231;
    float *l_1234 = &l_1232;
    float **l_1233 = &l_1234;
    p_30 = ((l_1217 != ((safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s(((**l_1217) = (l_1219 || (l_1219 == ((safe_mod_func_uint32_t_u_u(4294967295U, (safe_rshift_func_uint16_t_u_s(p_31, (safe_add_func_int32_t_s_s(((l_1230 != (l_1233 = l_1233)) && 0x0C865212), 0)))))) && 0xE738)))), p_30)), 1U)) , (void*)0)) == p_31);
    (*l_1234) = (p_29 = (p_30 != (l_1234 == (l_1219 , l_1231))));
    return l_1219;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_32(int32_t  p_33, union U1  p_34, uint32_t  p_35, const int32_t ** p_36)
{ /* block id: 387 */
    int32_t l_1010 = 0x44E14202;
    int32_t *l_1009 = &l_1010;
    int32_t **l_1011 = &l_1009;
    float l_1029 = 0x1.D44F99p-83;
    float *l_1028 = &l_1029;
    float **l_1027 = &l_1028;
    float ***l_1026 = &l_1027;
    int8_t l_1030 = 0x20;
    int32_t l_1031 = 0xACD9180A;
    int8_t l_1037 = 0xAC;
    int16_t *l_1053 = (void*)0;
    int16_t **l_1052 = &l_1053;
    int16_t l_1061 = 0xAEC3;
    int32_t ***l_1103 = (void*)0;
    int32_t ****l_1116 = &l_1103;
    const int32_t *l_1141 = (void*)0;
    union U1 l_1145 = {0x46FD};
    union U1 *l_1157 = &l_1145;
    union U1 **l_1156 = &l_1157;
    int8_t *l_1211 = (void*)0;
    int8_t **l_1210 = &l_1211;
    (*l_1011) = l_1009;
    (*l_1011) = (*l_1011);
    (**l_1011) = (safe_mod_func_int32_t_s_s(((*l_1009) != (safe_div_func_uint16_t_u_u(((((0x7E21 <= ((safe_add_func_uint16_t_u_u(((*l_1009) >= p_34.f0), ((l_1009 != (void*)0) | (l_1031 = (safe_mod_func_uint32_t_u_u(((safe_mul_func_int16_t_s_s(((safe_add_func_uint16_t_u_u(((p_34.f1 & (safe_lshift_func_int16_t_s_s(((void*)0 != l_1026), (**l_1011)))) || 0U), l_1030)) == (**l_1011)), 0xAD48)) == p_34.f1), 0x949E5662)))))) & (**l_1011))) > (*l_1009)) , (**l_1011)) , p_34.f0), 0x1037))), (**l_1011)));
    if (((**l_1011) && 0x71AF))
    { /* block id: 392 */
        union U0 l_1032 = {0};
        p_33 = ((*l_1009) = ((p_35 <= ((p_33 , p_35) | (p_34 , (l_1032 , (p_34.f0 > (safe_mul_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(l_1037, (*l_1009))), 0U))))))) <= (-1)));
        /* statement id: 394 */
        assert (l_1032.f0 == 0);
    }
    else
    { /* block id: 395 */
        float ****l_1038 = &l_1026;
        uint32_t l_1043 = 1U;
        const int32_t *l_1045 = (void*)0;
        const int32_t **l_1044 = &l_1045;
        int16_t *l_1051 = (void*)0;
        int16_t **l_1050 = &l_1051;
        float l_1055 = 0x3.Fp-1;
        float *l_1054 = &l_1055;
        float l_1057 = 0x9.988432p+25;
        float *l_1056 = &l_1057;
        float *l_1058 = (void*)0;
        float l_1060 = 0x1.26D23Dp+81;
        float *l_1059 = &l_1060;
        union U1 l_1098 = {0x3931};
        int32_t ****l_1114 = &l_1103;
        int8_t l_1128 = 0x00;
        int32_t l_1203 = 0x9DF379B2;
        if ((((*l_1059) = (0xE.DCEDC0p+18 >= ((p_34 , ((l_1038 = l_1038) != &l_1026)) == (safe_mul_func_float_f_f((((safe_mul_func_float_f_f((l_1043 < ((l_1044 == p_36) >= ((*l_1056) = (((*l_1054) = (((*l_1028) = (safe_mul_func_float_f_f(((*l_1009) > ((safe_mul_func_float_f_f((l_1050 != l_1052), 0x1.5EA161p+61)) < 0x1.Cp-1)), p_34.f0))) != 0xC.244112p+74)) > (*l_1009))))), (*l_1009))) == p_34.f0) != 0x0.Dp-1), (**l_1011)))))) , (*l_1009)))
        { /* block id: 401 */
            const int8_t l_1066 = 0x6B;
            int32_t ***l_1089 = (void*)0;
            int32_t l_1099 = 0x9DD698DE;
            union U1 *l_1155 = &l_1098;
            union U1 **l_1154 = &l_1155;
            if (((*l_1009) = l_1061))
            { /* block id: 403 */
                int32_t *l_1062 = &l_1031;
                union U1 l_1071 = {0x6F7F};
                union U1 *l_1070 = &l_1071;
                int32_t l_1088 = 0x335ACAC3;
                int32_t *l_1087 = &l_1088;
                int32_t **l_1086 = &l_1087;
                int32_t ***l_1085 = &l_1086;
                int32_t *****l_1115 = &l_1114;
                int16_t *l_1117 = &l_1061;
                uint16_t *l_1126 = &l_1071.f1;
                int16_t *l_1127 = (void*)0;
                int32_t **l_1142 = &l_1062;
lbl_1065:
                (*l_1044) = l_1062;
                /* statement id: 404 */
                assert (l_1045 == &l_1031);
                for (l_1030 = 0; (l_1030 == 15); l_1030++)
                { /* block id: 407 */
                    uint32_t l_1077 = 0U;
                    float l_1082 = 0x0.Ep-1;
                    int16_t *l_1100 = &l_1061;
                    int32_t *l_1102 = &l_1099;
                    if (l_1010)
                        goto lbl_1065;
                    if (l_1066)
                    { /* block id: 409 */
                        union U1 l_1069 = {4U};
                        union U1 *l_1068 = &l_1069;
                        union U1 **l_1067 = &l_1068;
                        l_1070 = ((*l_1067) = &p_34);
                        /* statement id: 411 */
                        assert (l_1070 == &p_34);
                        assert (l_1068 == &p_34);
                        (*l_1011) = (*l_1011);
                    }
                    else
                    { /* block id: 413 */
                        int32_t * const l_1074 = &l_1010;
                        (**l_1011) = (safe_mul_func_float_f_f(p_34.f0, 0x0.1p+1));
                        (*l_1011) = l_1074;
                        /* statement id: 415 */
                        assert (l_1009 == &l_1010);
                    }
                    (*l_1009) = (((safe_rshift_func_int16_t_s_s(((((l_1077 != l_1066) | (((safe_sub_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((l_1077 | (safe_mul_func_int16_t_s_s(((l_1085 == l_1089) > (0x2FDC < (((*l_1045) <= (safe_mul_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((safe_mul_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(l_1066, (**l_1011))) != 0xC5D9), 0xFD77)) , p_33), p_33)), l_1077))) || p_33))), p_33))), 65533U)), p_35)) , 1U) >= (**l_1044))) , 9) ^ (-9)), 8)) , l_1098) , 0x1B9C3DB4);
                    if ((p_35 && ((*l_1100) = (l_1099 = ((-9) >= (65535U == 0xD32B))))))
                    { /* block id: 420 */
                        int32_t *l_1101 = &l_1010;
                        (*l_1011) = l_1101;
                        /* statement id: 421 */
                        assert (l_1009 == &l_1010);
                        (*l_1056) = l_1077;
                        (*l_1011) = l_1102;
                        /* statement id: 423 */
                        assert (l_1009 == &l_1099);
                    }
                    else
                    { /* block id: 424 */
                        (*l_1102) = p_34.f0;
                    }
                }
                p_33 = ((((*l_1062) == (l_1103 != (void*)0)) , (l_1128 = (((((safe_sub_func_int16_t_s_s(((*l_1009) = (safe_mod_func_uint32_t_u_u((((***l_1085) = (safe_div_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u(((p_34.f1 && ((p_33 & p_33) == (safe_mul_func_int16_t_s_s(((*l_1117) = (((*l_1115) = l_1114) != (l_1116 = &l_1089))), (safe_mod_func_uint32_t_u_u((safe_sub_func_int32_t_s_s(((*l_1062) = ((safe_sub_func_uint16_t_u_u(((*l_1126) = (((safe_sub_func_int16_t_s_s((*l_1045), p_35)) && 0x024B) < l_1099)), 65529U)) > 0x7D32)), 1)), l_1088)))))) >= 2U), p_35)), (**l_1011)))) , l_1066), p_35))), l_1066)) ^ 0xCF12) || p_34.f1) | l_1066) > l_1066))) | l_1066);
                /* statement id: 436 */
                                assert (l_1116 == &l_1103 || l_1116 == &l_1089);
                (**l_1027) = (safe_add_func_float_f_f((safe_add_func_float_f_f(((safe_add_func_float_f_f(((safe_mul_func_float_f_f((safe_sub_func_float_f_f((p_33 == p_34.f1), (safe_div_func_float_f_f(0x0.0p+1, (p_33 != (p_33 == (**l_1011))))))), (((l_1141 = (*l_1044)) != ((*l_1142) = &p_33)) <= (safe_mul_func_float_f_f(((*l_1059) = ((0xD.6E1EACp-75 > p_35) >= 0xC.33BA57p-55)), 0x1.4p+1))))) >= p_35), 0x9.Fp-1)) >= 0x5.43D835p-80), (**l_1044))), 0x0.B7A3E0p-37));
                /* statement id: 440 */
                assert (l_1062 == &p_33);
                assert (l_1141 == &l_1031);
            }
            else
            { /* block id: 441 */
                union U1 ***l_1158 = &l_1156;
                int8_t *l_1165 = &l_1030;
                int8_t **l_1164 = &l_1165;
                int8_t ***l_1163 = &l_1164;
                const int8_t ***l_1166 = (void*)0;
                const int8_t ****l_1167 = &l_1166;
                int32_t l_1170 = 3;
                int32_t *l_1171 = &l_1099;
                uint32_t l_1172 = 0x678C76CB;
                l_1170 = (l_1145 , ((p_33 < (safe_div_func_int32_t_s_s(((*l_1171) = (safe_mod_func_int16_t_s_s(((safe_add_func_float_f_f((safe_add_func_float_f_f(((**l_1011) = (l_1154 != ((*l_1158) = l_1156))), (safe_mul_func_float_f_f((safe_add_func_float_f_f(((l_1163 != ((*l_1167) = l_1166)) >= (((safe_sub_func_float_f_f((l_1170 < (p_34.f0 , (-0x9.3p-1))), p_33)) >= p_35) , l_1099)), p_33)), p_34.f1)))), (-0x1.5p-1))) , l_1099), 0xABE9))), l_1172))) <= 7U));
            }
            /* facts after branching */
            assert (l_1009 == &l_1010 || l_1009 == &l_1099);
            assert (l_1045 == 0 || l_1045 == &l_1031);
            assert (l_1116 == &l_1103 || l_1116 == &l_1089);
            assert (l_1141 == 0 || l_1141 == &l_1031);
            (**l_1011) = l_1066;
        }
        else
        { /* block id: 449 */
            float l_1177 = 0x5.59603Dp+46;
            const int32_t l_1178 = 0x5A9F8DF2;
            int8_t **l_1183 = (void*)0;
            int32_t l_1192 = 0xA3BFABFC;
            for (l_1037 = 0; (l_1037 == 10); l_1037 = safe_add_func_uint16_t_u_u(l_1037, 2))
            { /* block id: 452 */
                int8_t l_1188 = 0x70;
                int16_t l_1189 = 0x6D93;
                uint16_t *l_1190 = &l_1098.f1;
                uint16_t *l_1191 = &l_1145.f1;
            }
        }
        /* facts after branching */
        //assert (l_1009 == &l_1010 || l_1009 == dangling);
        assert (l_1045 == 0 || l_1045 == &l_1031);
        //assert (l_1116 == &l_1103 || l_1116 == dangling);
        assert (l_1141 == 0 || l_1141 == &l_1031);
        (*l_1044) = &p_33;
        /* statement id: 479 */
        assert (l_1045 == &p_33);
    }
    /* facts after branching */
    //assert (l_1009 == &l_1010 || l_1009 == dangling);
    //assert (l_1116 == &l_1103 || l_1116 == dangling);
    assert (l_1141 == 0 || l_1141 == &l_1031);
    return p_34.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_37(int8_t * p_38, union U1  p_39, int32_t ** p_40, int8_t  p_41, int32_t ** p_42)
{ /* block id: 299 */
    uint16_t *l_761 = (void*)0;
    int32_t l_785 = 0x7B6C0264;
    int32_t l_794 = 0;
    union U0 l_796 = {0};
    float l_811 = 0x2.6B7DF6p+75;
    float *l_810 = &l_811;
    float **l_809 = &l_810;
    float ***l_823 = &l_809;
    float ****l_822 = &l_823;
    int32_t l_857 = 0x1DAF3160;
    int32_t *l_856 = &l_857;
    int32_t **l_855 = &l_856;
    int32_t *** const l_854 = &l_855;
    const int8_t **l_894 = (void*)0;
    const int8_t ***l_893 = &l_894;
    const int8_t ****l_892 = &l_893;
    const int8_t ***** const l_891 = &l_892;
    int32_t l_904 = (-2);
    int16_t **l_913 = (void*)0;
    int16_t ***l_912 = &l_913;
    union U0 *l_947 = &l_796;
    union U0 **l_946 = &l_947;
    int16_t l_953 = (-1);
    int32_t l_978 = 0;
    int32_t *l_1002 = &l_904;
    int32_t **l_1001 = &l_1002;
    int32_t ***l_1000 = &l_1001;
    int32_t ****l_999 = &l_1000;
    uint32_t l_1003 = 0U;
    int16_t l_1004 = 0;
    float l_1005 = 0x9.Ep+1;
    uint16_t l_1006 = 0x518E;
    for (p_41 = 0; (p_41 <= (-16)); p_41 = safe_sub_func_int32_t_s_s(p_41, 8))
    { /* block id: 302 */
        int16_t l_759 = 1;
        int16_t *l_758 = &l_759;
        int16_t **l_757 = &l_758;
        int32_t l_797 = 0xA3C6F813;
        int32_t l_798 = 0x0AA3E34C;
        int32_t ***l_826 = (void*)0;
    }
    for (l_785 = 11; (l_785 == (-24)); l_785 = safe_sub_func_int16_t_s_s(l_785, 2))
    { /* block id: 330 */
        int32_t ***l_859 = &l_855;
        int32_t ****l_858 = &l_859;
        int32_t l_884 = 0x1409476E;
        const int32_t l_886 = 5;
        int8_t **l_890 = (void*)0;
        int8_t ***l_889 = &l_890;
        int8_t **** const l_888 = &l_889;
        int8_t **** const *l_887 = &l_888;
        int32_t l_963 = 6;
        (*l_858) = l_854;
        if (l_794)
            continue;
        for (l_794 = 0; (l_794 == (-4)); l_794 = safe_sub_func_uint32_t_u_u(l_794, 2))
        { /* block id: 335 */
            (*p_42) = &l_794;
            /* statement id: 336 */
            //assert (l_748 == &l_794);
        }
    }
    /* facts after for loop */
    //assert (l_748 == &l_794 || l_748 == &l_25 || l_748 == 0);
    (*l_810) = ((((l_794 = (l_978 != l_953)) != (safe_mod_func_uint32_t_u_u(((*l_1002) = (7 & ((safe_div_func_int32_t_s_s(((((safe_div_func_float_f_f(((0x1.7p-1 != (safe_div_func_float_f_f(0x1.Ep-1, p_41))) > l_904), (0x2.7C9DF7p+28 > 0x9.010D59p+93))) < l_785) , l_999) != &l_1000), l_1003)) & l_1004))), p_39.f0))) < 1U) , 0x5.CAB81Ep-87);
    return l_1006;
    /* statement id: 386 */
    //assert (l_748 == dangling || l_748 == &l_25 || l_748 == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_44(int32_t ** p_45)
{ /* block id: 103 */
    uint16_t l_268 = 0x24B7;
    int32_t l_278 = 0x61D1CEF0;
    const int32_t *l_277 = &l_278;
    const int32_t **l_276 = &l_277;
    union U1 **l_279 = (void*)0;
    uint16_t l_285 = 0x24AD;
    uint16_t *l_284 = &l_285;
    uint16_t *l_286 = (void*)0;
    uint16_t *l_287 = (void*)0;
    uint16_t l_289 = 0xF041;
    uint16_t *l_288 = &l_289;
    int32_t l_290 = 0x0B072DD7;
    float l_292 = 0x0.5p+1;
    float *l_291 = &l_292;
    int8_t l_294 = 0x3F;
    int8_t *l_293 = &l_294;
    int8_t **l_295 = &l_293;
    int8_t *l_297 = &l_294;
    int8_t **l_296 = &l_297;
    union U0 l_300 = {0};
    union U0 *l_299 = &l_300;
    uint32_t l_317 = 4294967290U;
    int32_t l_323 = 0xE957A56D;
    int32_t l_343 = 0x38342FED;
    int32_t l_345 = 0xE6D59238;
    float l_365 = 0x0.Cp+1;
    int32_t *l_372 = &l_343;
    int32_t *l_391 = &l_345;
    uint16_t l_392 = 65535U;
    const union U1 l_394 = {0x871D};
    const union U1 *l_393 = &l_394;
    int16_t l_396 = 0x048E;
    int16_t *l_395 = &l_396;
    int32_t *l_397 = &l_343;
    uint32_t *l_398 = (void*)0;
    int8_t l_399 = 0;
    float l_400 = 0xD.B53C18p+67;
    union U1 *l_408 = (void*)0;
    union U1 **l_407 = &l_408;
    int32_t **l_438 = (void*)0;
    uint32_t l_472 = 0x8BF441BD;
    union U1 l_675 = {9U};
    int8_t ***l_697 = (void*)0;
    int8_t ****l_696 = &l_697;
    int8_t **** const *l_695 = &l_696;
    const int32_t l_741 = 0x3892F7E3;
    union U1 l_746 = {65526U};
    (*l_291) = (!((l_268 == (safe_add_func_float_f_f(l_268, ((safe_add_func_float_f_f(((-((safe_mul_func_float_f_f((l_276 == ((**l_276) , func_46(((l_278 = ((void*)0 == l_279)) , (safe_add_func_uint16_t_u_u((*l_277), ((*l_288) = ((*l_284) = (((*l_277) > (safe_mul_func_uint16_t_u_u((((**l_276) ^ (**l_276)) || 0x9378), 0x4BE1))) , (**l_276)))))))))), 0x6.E03093p+28)) >= l_290)) != l_268), l_290)) > 0x0.6p-1)))) >= l_268));
    return l_746;
    /* statement id: 298 */
    //assert (func_44_rv.f3 == dangling);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_46(uint32_t  p_47)
{ /* block id: 6 */
    union U1 l_53 = {0xA7C6};
    union U1 *l_52 = &l_53;
    int32_t l_63 = (-1);
    const int32_t *l_62 = &l_63;
    const int32_t **l_61 = &l_62;
    int32_t **l_64 = (void*)0;
    int32_t ***l_65 = &l_64;
    uint32_t l_67 = 0x85A1EC8F;
    int32_t *l_74 = &l_63;
    int16_t l_76 = 3;
    int16_t *l_75 = &l_76;
    uint32_t *l_77 = (void*)0;
    uint32_t l_79 = 0xED6D2303;
    uint32_t *l_78 = &l_79;
    int32_t l_199 = 6;
    union U0 l_218 = {0};
    union U0 *l_217 = &l_218;
    int8_t l_263 = 0xC4;
    int8_t *l_262 = &l_263;
    int32_t **l_264 = &l_74;
    int32_t **l_265 = &l_74;
    int32_t **l_266 = (void*)0;
    for (p_47 = (-26); (p_47 >= 32); ++p_47)
    { /* block id: 9 */
        int32_t l_51 = 0x3B8CFF26;
        int32_t *l_50 = &l_51;
        if (p_47)
            break;
        (*l_50) = 3;
        l_52 = (void*)0;
        /* statement id: 12 */
        assert (l_52 == 0);
    }
    /* facts after for loop */
    assert (l_52 == 0 || l_52 == &l_53);
    if (func_54(l_53.f1, ((*l_78) = (safe_mod_func_uint16_t_u_u((p_47 > 0), ((((((*l_75) = (~((((l_61 != ((*l_65) = l_64)) != (~((l_67 != ((((((safe_sub_func_uint16_t_u_u(((safe_div_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(p_47, (l_74 != (void*)0))), p_47)) && (*l_62)), (*l_62))) <= p_47) ^ 0x45435D7D) ^ (*l_62)) == 1) ^ (*l_62))) & p_47))) < 0x215C) , p_47))) && (**l_61)) <= p_47) ^ (*l_62)) && (*l_74))))), p_47))
    { /* block id: 63 */
        int8_t l_184 = 0x9B;
        int32_t l_200 = (-1);
        int32_t **l_201 = &l_74;
        int16_t l_203 = 0x1496;
        int16_t *l_202 = &l_203;
        uint16_t *l_204 = &l_53.f1;
        (**l_201) = (((-5) && ((*l_204) = (p_47 != (safe_sub_func_int32_t_s_s(l_184, (safe_lshift_func_int16_t_s_u(((*l_202) = (safe_mod_func_uint16_t_u_u((*l_62), (safe_div_func_int16_t_s_s((((safe_sub_func_float_f_f((((l_200 = ((**l_61) >= (((((((((void*)0 == l_75) > (((safe_add_func_uint16_t_u_u(((((safe_add_func_int16_t_s_s(6, ((*l_75) = (safe_lshift_func_uint16_t_u_s((((p_47 >= l_184) , l_78) != (void*)0), l_199))))) > (*l_74)) & 0x98A83C55) > p_47), (**l_61))) , p_47) , 0x6E19BD86)) , (-0x1.5p+1)) >= (-0x1.Fp-1)) != p_47) > 0x5.4A76FCp+84) < p_47) != 0x0.Bp+1))) < p_47) != 0x6.234214p+78), 0x4.DBFB6Bp-94)) , l_201) == (*l_65)), (**l_201)))))), p_47))))))) != 0x47ABECF3);
        /* statement id: 68 */
                for (l_199 = (-10); (l_199 != (-18)); l_199 = safe_sub_func_int32_t_s_s(l_199, 2))
        { /* block id: 71 */
            int32_t **l_209 = &l_74;
            int8_t *l_223 = &l_184;
            float l_226 = (-0x1.2p+1);
            int32_t *l_227 = &l_200;
            for (l_200 = 0; (l_200 < (-29)); l_200 = safe_sub_func_int16_t_s_s(l_200, 1))
            { /* block id: 74 */
                int32_t **l_210 = (void*)0;
                return l_210;
                /* statement id: 75 */
                //assert (func_46_rv == 0);
            }
            (*l_61) = (*l_201);
            (*l_227) = (safe_sub_func_uint32_t_u_u((((safe_mul_func_int16_t_s_s((safe_add_func_uint32_t_u_u(((l_217 != (void*)0) , 0xECA001A1), (p_47 > (safe_lshift_func_int16_t_s_s(0xABCB, (safe_div_func_int16_t_s_s(((void*)0 != l_223), ((*l_202) = ((*l_75) = ((**l_209) = ((safe_mul_func_int16_t_s_s((**l_201), (*l_62))) , (-1)))))))))))), p_47)) , 2) || p_47), p_47));
            /* statement id: 81 */
            assert (l_218.f0 == 0);
            if (p_47)
            { /* block id: 82 */
                (**l_209) = (*l_227);
            }
            else
            { /* block id: 84 */
                const union U0 *l_229 = &l_218;
                const union U0 **l_228 = &l_229;
                float *l_233 = &l_226;
                float **l_232 = &l_233;
                int32_t l_234 = 1;
                (*l_228) = &l_218;
                (**l_201) = (p_47 || (safe_div_func_int16_t_s_s(((((*l_232) = l_77) == (void*)0) >= 0U), l_234)));
                /* statement id: 87 */
                assert (l_233 == &l_226 || l_233 == 0);
            }
        }
        /* facts after for loop */
        assert (l_218.f0 == 0);
        (*l_201) = (*l_201);
    }
    else
    { /* block id: 91 */
        uint16_t *l_245 = &l_53.f1;
        int32_t l_246 = 0x8CB1CE7F;
        int32_t * const l_247 = (void*)0;
        int32_t *l_248 = &l_246;
        union U0 *l_249 = &l_218;
        union U0 **l_250 = &l_217;
        float l_252 = 0x9.1p-1;
        float *l_251 = &l_252;
        (*l_61) = (l_248 = ((((((safe_add_func_uint32_t_u_u((p_47 ^ ((((*l_75) = (((safe_mod_func_int32_t_s_s(((&p_47 == &p_47) , ((*l_62) , (safe_lshift_func_int16_t_s_u(((*l_74) = (safe_rshift_func_uint16_t_u_s((*l_74), 4))), 1)))), (safe_sub_func_uint16_t_u_u((p_47 , (((void*)0 != l_245) & ((l_78 == l_77) , l_246))), p_47)))) , p_47) > 0x1ADA)) , &l_199) == l_247)), l_246)) > 0xAE4BFFE4) && (-8)) && 1U) == 0xD9ACFF28) , (void*)0));
        /* statement id: 95 */
        assert (l_62 == 0);
        assert (l_248 == 0);
        (*l_250) = l_249;
        (*l_251) = p_47;
        (*l_61) = &l_246;
        /* statement id: 98 */
        assert (l_62 == &l_246);
    }
    /* facts after branching */
        //assert (l_62 == dangling || l_62 == &l_63);
    assert (l_218.f0 == 0);
    (*l_61) = &l_63;
    /* statement id: 100 */
    assert (l_62 == &l_63);
    (*l_74) = (safe_rshift_func_int16_t_s_u((-10), (safe_lshift_func_int16_t_s_u((((((((l_53 , (safe_unary_minus_func_int16_t_s((p_47 , ((safe_sub_func_int32_t_s_s(((p_47 == p_47) && (l_262 != &l_263)), ((((p_47 & ((*l_217) , (-9))) == (*l_74)) , p_47) , 1U))) | p_47))))) & p_47) >= p_47) & (*l_74)) & (-1)) && p_47) & 4294967286U), 15))));
    return l_266;
    /* statement id: 102 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_54(const int32_t  p_55, uint32_t  p_56, int8_t  p_57)
{ /* block id: 17 */
    int32_t ***l_93 = (void*)0;
    int16_t l_111 = 0;
    uint32_t l_113 = 0x65C99C23;
    uint32_t *l_112 = &l_113;
    union U1 l_132 = {0xE593};
    union U1 *l_131 = &l_132;
    union U0 l_138 = {0};
    union U0 *l_137 = &l_138;
    for (p_56 = 0; (p_56 == 3); ++p_56)
    { /* block id: 20 */
        uint16_t l_88 = 4U;
        int32_t l_115 = (-4);
        int32_t l_120 = 1;
        union U1 *l_133 = &l_132;
        union U0 l_172 = {0};
        for (p_57 = 0; (p_57 == (-14)); p_57 = safe_sub_func_int16_t_s_s(p_57, 1))
        { /* block id: 23 */
            int16_t l_85 = 0xBDEF;
            uint16_t l_95 = 0xC80B;
            uint16_t *l_94 = &l_95;
            int32_t l_103 = 0xF155D261;
            int32_t *l_102 = &l_103;
            int32_t **l_105 = &l_102;
            int32_t ***l_104 = &l_105;
            union U0 l_110 = {0};
            const uint32_t l_117 = 0xA1293870;
            int8_t l_169 = (-2);
            if (((~l_85) ^ (safe_lshift_func_uint16_t_u_u(((l_88 > (safe_sub_func_uint16_t_u_u(((*l_94) = (safe_add_func_int16_t_s_s(0, ((0xDBD1BD9F == p_57) ^ (l_93 != (p_56 , l_93)))))), (safe_mul_func_uint16_t_u_u((((safe_mod_func_uint32_t_u_u((safe_add_func_uint16_t_u_u((((((*l_102) = l_88) , l_104) != (void*)0) ^ p_56), p_56)), p_57)) == p_56) != p_57), l_88))))) != l_88), 4))))
            { /* block id: 26 */
                float l_107 = (-0x1.Dp+1);
                float *l_106 = &l_107;
                int32_t *l_114 = (void*)0;
                int32_t l_118 = 0xF76CAF44;
                int32_t l_119 = 0x0D248760;
                union U1 **l_134 = &l_133;
                (*l_106) = (-0x10.9p+1);
                l_120 = ((safe_add_func_int32_t_s_s(((*l_102) = (**l_105)), (l_110 , l_111))) ^ (((((l_115 = (l_112 == (void*)0)) , (~p_55)) , ((((p_55 > l_117) ^ (l_118 = p_55)) | p_55) >= l_88)) | l_119) != 65535U));
                /* statement id: 31 */
                assert (l_110.f0 == 0);
                (*l_102) = (safe_sub_func_float_f_f((safe_sub_func_float_f_f((((0x1.1p-1 == 0x6.771C75p+32) < l_88) <= ((safe_sub_func_float_f_f(((safe_div_func_float_f_f(((*l_106) = (p_57 == (-0x2.0p-1))), ((safe_div_func_float_f_f((p_56 > (((**l_105) , l_131) == ((p_55 >= p_57) , (void*)0))), p_57)) > l_88))) == 0x6.B33E74p+10), p_56)) < l_88)), 0xD.C55787p+37)), 0x0.6p-1));
                (*l_134) = l_133;
            }
            else
            { /* block id: 35 */
                int8_t l_154 = 0;
                int32_t l_161 = 1;
                for (l_115 = 0; (l_115 > 13); l_115++)
                { /* block id: 38 */
                    union U0 **l_139 = &l_137;
                    int32_t l_158 = 0xC1E9F9EE;
                    int32_t l_160 = 0xA819422B;
                    (*l_139) = l_137;
                    for (l_85 = 3; (l_85 <= 3); l_85 = safe_add_func_uint16_t_u_u(l_85, 5))
                    { /* block id: 42 */
                        union U0 l_157 = {0};
                        int32_t l_159 = 0xBD6B4620;
                        union U1 l_173 = {0x662F};
                        int32_t *l_175 = &l_103;
                        int32_t **l_174 = &l_175;
                        l_161 = ((safe_sub_func_uint32_t_u_u((safe_div_func_int32_t_s_s(((***l_104) = p_55), ((safe_mul_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u((0x1C03A75F & p_57), 15)) == (l_158 = ((*l_94) = (safe_sub_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((p_56 || (p_56 & l_154)), 9)), (((safe_mod_func_int16_t_s_s((((((*l_137) , (l_115 > (l_157 , l_88))) & 0x63631664) , l_158) | l_88), 65531U)) & p_56) < 0x65B3CABD)))))), 7)) | l_159))), p_57)) & l_160);
                        (*l_174) = (((((safe_div_func_int16_t_s_s((((l_160 != (safe_sub_func_int32_t_s_s(l_115, (l_161 != (((((-(safe_sub_func_float_f_f((l_169 != (safe_add_func_float_f_f((&l_159 != ((*l_105) = &l_159)), 0x3.B2EE2Bp-95))), ((l_172 , (l_173 , 0x3.D5AF53p+65)) == l_160)))) != 0x6.C045D8p+25) , p_57) > 0xA893) <= 7U))))) && p_56) == l_173.f1), 65535U)) ^ l_158) | 0x946C84E0) != 3) , &p_55);
                        /* statement id: 48 */
                        assert (l_102 == &l_159);
                        assert (l_175 == &p_55);
                        return p_56;
                    }
                }
                /* facts after for loop */
                assert (l_138.f0 == 0);
                //assert (l_172.f0 == dangling || l_172.f0 == 0);
                return p_57;
            }
            /* facts after branching */
            assert (l_110.f0 == 0);
            assert (l_138.f0 == 0);
            assert (l_172.f0 == 0);
        }
        /* facts after for loop */
        assert (l_138.f0 == 0);
        assert (l_172.f0 == 0);
        return p_57;
    }
    for (p_56 = 1; (p_56 == 8); ++p_56)
    { /* block id: 59 */
        int32_t l_179 = 0xFDA28E2A;
        int32_t *l_178 = &l_179;
        (*l_178) = (-7);
    }
    return p_57;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 326
XXX total union variables: 28

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 27
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 11, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 4
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 4
   depth: 24, occurrence: 1
   depth: 25, occurrence: 3
   depth: 27, occurrence: 2
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 2
   depth: 37, occurrence: 1

XXX total number of pointers: 413

XXX times a variable address is taken: 355
XXX times a pointer is dereferenced on RHS: 222
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 71
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 260
breakdown:
   depth: 1, occurrence: 224
   depth: 2, occurrence: 28
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 36
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 1292

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 593
   level: 2, occurrence: 235
   level: 3, occurrence: 52
   level: 4, occurrence: 27
XXX number of pointers point to pointers: 181
XXX number of pointers point to scalars: 208
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.9
XXX average alias set size: 1.15

XXX times a non-volatile is read: 1470
XXX times a non-volatile is write: 673
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 30
   depth: 2, occurrence: 19
   depth: 3, occurrence: 15
   depth: 4, occurrence: 6
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 18.4
XXX percentage an existing variable is used: 81.6
********************* end of statistics **********************/

