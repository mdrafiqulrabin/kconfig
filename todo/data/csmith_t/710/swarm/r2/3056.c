/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3491061542
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   float  f0;
   volatile uint32_t  f1;
   uint16_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_9 = 2U;
static float g_27 = 0x1.7p-1;
static int32_t g_32 = 1;
static union U0 g_63 = {0x3.257018p+5};/* VOLATILE GLOBAL g_63 */
static int32_t g_91 = (-8);
static int32_t * volatile g_90 = &g_91;/* VOLATILE GLOBAL g_90 */
static int32_t * volatile g_115 = (void*)0;/* VOLATILE GLOBAL g_115 */
static int32_t g_117 = 0x7CEE7E28;
static int32_t *g_124 = &g_32;
static int32_t **g_123 = &g_124;
static int32_t *** volatile g_122 = &g_123;/* VOLATILE GLOBAL g_122 */
static const union U0 ** volatile g_131 = (void*)0;/* VOLATILE GLOBAL g_131 */
static const union U0 *g_133 = &g_63;
static const union U0 ** volatile g_132 = &g_133;/* VOLATILE GLOBAL g_132 */
static uint16_t g_264 = 0xE049;
static union U0 g_294 = {-0x3.2p-1};/* VOLATILE GLOBAL g_294 */
static union U0 *g_296 = &g_294;
static union U0 ** volatile g_295 = &g_296;/* VOLATILE GLOBAL g_295 */
static float * volatile g_343 = &g_27;/* VOLATILE GLOBAL g_343 */
static int32_t ** volatile g_374 = (void*)0;/* VOLATILE GLOBAL g_374 */
static int32_t g_521 = (-3);
static int32_t ** volatile g_532 = &g_124;/* VOLATILE GLOBAL g_532 */
static int32_t * volatile g_724 = &g_117;/* VOLATILE GLOBAL g_724 */
static int32_t ** volatile g_763 = &g_124;/* VOLATILE GLOBAL g_763 */
static const int32_t *g_792 = &g_117;
static const int32_t ** volatile g_791 = &g_792;/* VOLATILE GLOBAL g_791 */
static float * volatile g_805 = &g_294.f0;/* VOLATILE GLOBAL g_805 */
static const union U0 ** volatile g_808 = &g_133;/* VOLATILE GLOBAL g_808 */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_26(void);
inline static int16_t  func_40(const int32_t * p_41, const int32_t  p_42);
static float  func_46(uint16_t  p_47);
static int32_t ** func_50(int32_t * p_51);
static union U0 * func_57(union U0 * p_58, union U0 * p_59, union U0 * p_60, const uint16_t  p_61);
static union U0 * func_64(float  p_65, uint32_t  p_66, union U0 * p_67, int32_t  p_68);
inline static union U0 * func_69(union U0 * p_70, int16_t  p_71, uint32_t  p_72);
inline static union U0 * func_73(uint32_t  p_74, int32_t  p_75, uint32_t  p_76, float  p_77);
static const int32_t * func_92(int32_t * p_93, float  p_94, int32_t  p_95);
inline static int32_t * func_96(int16_t  p_97, int32_t  p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_32 g_763 g_124 g_117 g_805 g_521 g_132 g_133 g_808
 * writes: g_27 g_9 g_32 g_117 g_294.f0 g_133
 */
inline static int16_t  func_26(void)
{ /* block id: 36 */
    int32_t l_39 = 0x632C5B64;
    const int32_t *l_43 = &g_32;
    int32_t ***l_806 = (void*)0;
    const int32_t l_807 = (-1);
    g_27 = g_9;
    for (g_9 = 0; (g_9 < 12); ++g_9)
    { /* block id: 40 */
        int16_t l_30 = 0xF9C7;
        int32_t *l_31 = &g_32;
        (*l_31) &= l_30;
    }
    (*g_124) = (safe_add_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((safe_mul_func_int16_t_s_s(l_39, func_40(l_43, (*l_43)))), (l_806 != l_806))), l_807));
    (*g_808) = (*g_132);
    return (*l_43);
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_9 g_763 g_124 g_117 g_805 g_521
 * writes: g_9 g_117 g_294.f0
 */
inline static int16_t  func_40(const int32_t * p_41, const int32_t  p_42)
{ /* block id: 43 */
    int32_t l_45 = 1;
    l_45 &= ((0x6E74A6E8 && g_32) && ((!g_32) | 0U));
    (*g_805) = func_46(g_9);
    return g_521;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_763 g_124 g_32 g_117
 * writes: g_9 g_117
 */
static float  func_46(uint16_t  p_47)
{ /* block id: 45 */
    int32_t *l_52 = (void*)0;
    int32_t ***l_804 = (void*)0;
    for (g_9 = 0; (g_9 < 54); ++g_9)
    { /* block id: 48 */
        int32_t ***l_803 = &g_123;
    }
    g_117 |= ((**g_763) != 0U);
    l_804 = l_804;
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : g_27 g_32 g_63.f2 g_63.f1 g_9 g_90 g_91 g_117 g_122 g_124 g_132 g_133 g_295 g_294.f1 g_264 g_294.f2 g_296 g_343 g_521 g_532 g_724 g_763 g_791
 * writes: g_32 g_91 g_63.f2 g_117 g_123 g_133 g_63.f0 g_27 g_264 g_124 g_296 g_294.f0 g_521 g_792
 */
static int32_t ** func_50(int32_t * p_51)
{ /* block id: 49 */
    int32_t *l_53 = (void*)0;
    int32_t *l_54 = (void*)0;
    int32_t *l_55 = (void*)0;
    int32_t *l_56 = &g_32;
    union U0 *l_62 = &g_63;
    uint32_t l_88 = 0x16E8CFB9;
    int32_t l_89 = 0x47FD326D;
    union U0 **l_801 = (void*)0;
    float *l_802 = &g_27;
    (*l_56) = 0x714BA09A;
    l_62 = func_57(l_62, &g_63, func_64(g_27, g_32, func_69(func_73((safe_sub_func_uint32_t_u_u((((*l_56) > (l_56 != (void*)0)) <= (safe_add_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(g_63.f2, (safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((g_63.f1 < g_32), 14)), 65534U)))) >= g_63.f2), l_88))), 0x0C09C4F4)), l_89, g_9, g_32), (*l_56), (*l_56)), g_9), l_88);
    /* statement id: 321 */
    assert (l_62 == 0 || l_62 == &g_294 || l_62 == &g_63);
    //assert (g_124 == &g_521 || g_124 == dangling || g_124 == &g_32);
    //assert (g_123 == dangling);
    assert (g_296 == &g_294 || g_296 == &g_63);
    assert (g_792 == &g_117 || g_792 == &g_91);
    (*l_56) = ((*l_56) > (*l_56));
    (*l_802) = (*g_343);
    return &g_124;
    /* statement id: 324 */
    //assert (func_50_rv == &g_124);
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_117 g_32 g_124 g_63.f2 g_9 g_27 g_90 g_132 g_133 g_295 g_294.f1 g_264 g_294.f2 g_296 g_343 g_521 g_532 g_724 g_763 g_791
 * writes: g_32 g_63.f0 g_91 g_27 g_264 g_124 g_123 g_296 g_63.f2 g_294.f0 g_117 g_521 g_792
 */
static union U0 * func_57(union U0 * p_58, union U0 * p_59, union U0 * p_60, const uint16_t  p_61)
{ /* block id: 79 */
    uint32_t l_145 = 0x7F8006A5;
    int32_t ***l_146 = &g_123;
    int32_t *l_153 = (void*)0;
    int32_t l_165 = (-1);
    uint32_t l_166 = 1U;
    int32_t *l_168 = (void*)0;
    int32_t *l_169 = (void*)0;
    union U0 *l_182 = &g_63;
    int32_t l_227 = 6;
    union U0 **l_299 = &l_182;
    float l_448 = 0x3.9B6EB5p-97;
    int32_t l_471 = (-9);
    int32_t l_494 = 0xC9FB6679;
    int32_t l_523 = 0xF427DD3A;
    float l_538 = (-0x3.6p-1);
    int32_t l_551 = 0x6FDFDF90;
    uint32_t l_623 = 0x3959B1D3;
    int32_t l_635 = (-8);
    int32_t l_699 = 1;
    float *l_717 = &l_538;
    const union U0 **l_729 = &g_133;
    const int32_t *l_777 = &g_32;
    int32_t l_780 = 0x838A2647;
    int32_t l_799 = 0;
    if ((p_61 == (safe_rshift_func_int16_t_s_u((0x5481 | ((((l_145 ^ g_91) >= l_145) <= (l_146 == &g_123)) & (p_61 == p_61))), g_117))))
    { /* block id: 80 */
        int16_t l_162 = 0x5997;
        int32_t l_167 = 0xE09DF947;
        for (g_32 = 0; (g_32 > (-25)); g_32 = safe_sub_func_uint16_t_u_u(g_32, 1))
        { /* block id: 83 */
            if (p_61)
                break;
        }
        l_167 ^= __builtin_popcountl((safe_sub_func_uint32_t_u_u(((safe_lshift_func_uint16_t_u_u((l_153 == (void*)0), (safe_mod_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(((l_162 && 1U) | ((((p_61 | (*g_124)) != p_61) || (safe_add_func_int32_t_s_s((*g_124), (((g_32 ^ 65534U) | g_91) != l_165)))) < g_32)), p_61)) != g_63.f2), l_166)), p_61)), 0x2E09151F)))) && p_61), p_61)));
    }
    else
    { /* block id: 87 */
        int32_t *l_170 = &g_117;
        float *l_181 = &g_63.f0;
        (*g_124) &= p_61;
        l_170 = l_169;
        /* statement id: 89 */
        assert (l_170 == 0);
        (*l_181) = (safe_mul_func_float_f_f((safe_add_func_float_f_f((g_117 != (safe_div_func_float_f_f(__builtin_clzll((safe_add_func_uint32_t_u_u((p_61 == ((void*)0 == &g_133)), p_61))), (safe_mul_func_float_f_f(((__builtin_ffsl(g_9) == 0xE.707E28p+77) <= g_27), p_61))))), g_9)), g_117));
        /* statement id: 90 */
        return l_182;
        /* statement id: 91 */
        //assert (func_57_rv == &g_63);
    }
    if ((*g_90))
    { /* block id: 93 */
        float *l_195 = &g_27;
        int32_t l_196 = 0xD7775BE2;
        union U0 **l_259 = &l_182;
        if ((safe_add_func_uint32_t_u_u((&l_182 != &p_58), (*g_90))))
        { /* block id: 94 */
            int32_t l_189 = 0x3ADAC69A;
            int32_t **l_226 = &l_169;
            (*g_124) = (safe_mul_func_int16_t_s_s((-9), (safe_add_func_uint16_t_u_u(__builtin_ctzl(p_61), (l_189 != (safe_sub_func_uint16_t_u_u((+(safe_sub_func_uint16_t_u_u((((void*)0 != l_195) >= g_32), l_189))), (l_196 || p_61))))))));
            (*g_124) = (safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(p_61, (safe_sub_func_int32_t_s_s((safe_div_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u(g_9, ((void*)0 == &l_196))), p_61)), (safe_mod_func_int32_t_s_s(((!((safe_add_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((l_189 ^ (__builtin_bswap32(p_61) & ((((safe_lshift_func_uint16_t_u_s((safe_mul_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((void*)0 != l_226), 7)), g_32)), g_117)), 2)) < g_9) > p_61) >= p_61))), g_9)), p_61)) || 0U), l_227)) <= l_196), p_61)) && 0U)) || g_9), (*g_90))))))), p_61));
        }
        else
        { /* block id: 97 */
            union U0 *l_232 = &g_63;
            int32_t l_242 = (-7);
            (*g_124) &= p_61;
            for (g_32 = (-5); (g_32 > (-17)); g_32 = safe_sub_func_uint16_t_u_u(g_32, 1))
            { /* block id: 101 */
                (*g_90) &= (safe_add_func_int16_t_s_s((&p_59 != (void*)0), g_117));
                return l_232;
                /* statement id: 103 */
                //assert (func_57_rv == &g_63);
            }
            if (__builtin_ffsll((safe_mul_func_int16_t_s_s(((__builtin_clz(g_9) <= (safe_rshift_func_uint16_t_u_u((~((*g_132) != (void*)0)), (safe_div_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u((__builtin_clzll(l_242) < 0), (safe_sub_func_uint16_t_u_u(l_196, (safe_mod_func_int16_t_s_s((((((safe_unary_minus_func_uint16_t_u(p_61)) | (*g_124)) >= l_196) != l_242) < 0x6157), p_61)))))), 0x49EDFFE6))))) > 0xFE9C0AA0), g_63.f2))))
            { /* block id: 105 */
                return l_232;
                /* statement id: 106 */
                //assert (func_57_rv == &g_63);
            }
            else
            { /* block id: 107 */
                (*l_195) = (safe_mul_func_float_f_f(((safe_sub_func_float_f_f((safe_mul_func_float_f_f(g_91, l_242)), (-(safe_mul_func_float_f_f(0xD.EAD8C2p-64, ((safe_div_func_float_f_f((l_259 == &p_58), p_61)) != (safe_add_func_float_f_f(__builtin_ctzll((1U | (0x0B73 & ((safe_mul_func_int16_t_s_s((g_117 | 0x0AFC), l_196)) & g_91)))), g_117)))))))) > g_32), (-0x1.Ep+1)));
            }
            g_264 = p_61;
        }
    }
    else
    { /* block id: 112 */
        int32_t **l_265 = (void*)0;
        int32_t **l_266 = &g_124;
        union U0 *l_268 = (void*)0;
        uint32_t l_280 = 0x1BE6A337;
        int32_t ****l_303 = &l_146;
        float *l_306 = &g_294.f0;
        (*l_266) = &l_165;
        /* statement id: 113 */
        assert (g_124 == &l_165);
        if ((!0xA65D))
        { /* block id: 114 */
            return l_268;
            /* statement id: 115 */
            //assert (g_124 == dangling);
            //assert (func_57_rv == 0);
        }
        else
        { /* block id: 116 */
            int32_t l_287 = (-1);
            int32_t *l_301 = &l_165;
            int32_t ****l_302 = &l_146;
            for (g_32 = 0; (g_32 >= 29); g_32 = safe_add_func_int32_t_s_s(g_32, 1))
            { /* block id: 119 */
                int32_t l_273 = 0x4CFAA401;
                int32_t **l_281 = &l_153;
                union U0 *l_293 = &g_294;
                for (g_91 = 20; (g_91 < (-10)); g_91 = safe_sub_func_uint32_t_u_u(g_91, 6))
                { /* block id: 122 */
                    l_273 ^= 0x25CBB4F5;
                }
                if (__builtin_ffs((safe_rshift_func_int16_t_s_u((safe_mul_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((**l_266), 8)), __builtin_ctz(l_280))), 8))))
                { /* block id: 125 */
                    uint32_t l_284 = 0x83361991;
                    (*l_146) = l_281;
                    /* statement id: 126 */
                    assert (g_123 == &l_153);
                    for (g_264 = 9; (g_264 <= 55); g_264 = safe_add_func_int32_t_s_s(g_264, 1))
                    { /* block id: 129 */
                        if (p_61)
                            break;
                    }
                    (*g_295) = p_58;
                    /* statement id: 132 */
                    assert (g_296 == &g_63);
                }
                else
                { /* block id: 133 */
                    uint16_t l_300 = 65535U;
                    if ((((*g_124) | (((**l_266) >= (g_294.f1 && (safe_sub_func_int32_t_s_s(((l_299 == (void*)0) > (g_294.f1 & ((*g_124) >= l_300))), (0x8FB5 || p_61))))) >= g_264)) > g_294.f2))
                    { /* block id: 134 */
                        return (*g_295);
                        /* statement id: 135 */
                        //assert (g_124 == dangling);
                        //assert (g_123 == dangling);
                        //assert (func_57_rv == &g_294 || func_57_rv == &g_63);
                    }
                    else
                    { /* block id: 136 */
                        (*l_281) = l_301;
                        /* statement id: 137 */
                        assert (l_153 == &l_165);
                    }
                    /* facts after branching */
                    assert (l_153 == &l_165);
                    l_303 = l_302;
                    for (g_63.f2 = 0; (g_63.f2 <= 42); ++g_63.f2)
                    { /* block id: 142 */
                        (**l_281) |= p_61;
                        (*l_301) = p_61;
                    }
                    (*l_306) = (l_301 != l_306);
                }
                if ((*g_124))
                    break;
            }
            /* facts after for loop */
            //assert (g_123 == dangling || g_123 == &l_153);
            assert (l_153 == &l_165 || l_153 == 0);
            assert (g_296 == &g_294 || g_296 == &g_63);
        }
        /* facts after branching */
        //assert (g_123 == dangling || g_123 == &l_153);
        assert (l_153 == &l_165 || l_153 == 0);
        assert (g_296 == &g_294 || g_296 == &g_63);
    }
    /* facts after branching */
    assert (g_124 == &l_165 || g_124 == &g_32);
    //assert (g_123 == dangling || g_123 == &l_153);
    assert (l_153 == &l_165 || l_153 == 0);
    assert (g_296 == &g_294 || g_296 == &g_63);
    for (g_91 = 25; (g_91 <= 0); g_91 = safe_sub_func_uint32_t_u_u(g_91, 2))
    { /* block id: 154 */
        float l_311 = 0xD.3AF0B7p-6;
        int32_t ***l_326 = &g_123;
        int32_t *l_334 = &l_165;
        int32_t l_341 = 1;
        union U0 **l_364 = &l_182;
        int32_t l_389 = (-9);
        int32_t l_438 = 0x394F0799;
        int32_t l_514 = 0xD179F379;
        for (l_145 = (-27); (l_145 == 35); l_145 = safe_add_func_int32_t_s_s(l_145, 4))
        { /* block id: 157 */
            int32_t **l_312 = &l_168;
            uint16_t l_327 = 0x1826;
            (*l_312) = func_96(g_91, p_61);
            /* statement id: 158 */
            assert (l_168 == &g_91);
            if ((safe_mul_func_uint16_t_u_u(((**l_312) ^ (6U | (safe_lshift_func_int16_t_s_s((((safe_lshift_func_uint16_t_u_s((g_32 < (**l_312)), 5)) & (safe_add_func_uint16_t_u_u((g_117 && (+((safe_rshift_func_int16_t_s_u(((g_63.f2 <= ((l_326 == (void*)0) <= (&g_124 != (void*)0))) != l_327), p_61)) || 0xC18C))), g_264))) > 0U), 9)))), g_264)))
            { /* block id: 159 */
                float l_330 = 0x9.0p+1;
                int32_t *l_331 = &l_227;
                (*l_312) = func_96((safe_add_func_uint32_t_u_u((p_61 < ((l_331 == (void*)0) > ((**l_312) != (safe_add_func_int32_t_s_s(p_61, (((void*)0 == l_334) || (safe_mul_func_int16_t_s_s(((l_169 == l_153) | 0xA6F4), p_61)))))))), p_61)), g_294.f2);
            }
            else
            { /* block id: 161 */
                float l_342 = 0xE.E8E71Ep+27;
                (*g_343) = ((safe_sub_func_float_f_f(0xC.82C05Ep+19, (safe_div_func_float_f_f(p_61, (((void*)0 == &g_123) < (p_61 == l_341)))))) < l_342);
            }
            l_334 = (*l_312);
            /* statement id: 164 */
            assert (l_334 == &g_91);
        }
        /* facts after for loop */
        assert (l_334 == &g_91 || l_334 == &l_165);
        for (l_341 = (-15); (l_341 != 25); l_341 = safe_add_func_uint32_t_u_u(l_341, 2))
        { /* block id: 168 */
            float *l_346 = (void*)0;
            float *l_347 = &l_311;
            int32_t l_360 = (-6);
            int32_t *l_382 = &g_117;
            uint16_t l_529 = 65529U;
            union U0 *l_553 = &g_294;
            (*l_347) = (*g_343);
        }
        l_389 &= ((g_117 != ((p_61 == p_61) | 2)) < (safe_mod_func_int32_t_s_s(p_61, g_91)));
    }
    /* facts after for loop */
    assert (l_168 == &g_91 || l_168 == 0);
    if ((safe_add_func_uint16_t_u_u(g_294.f1, (safe_mod_func_int16_t_s_s(0x85EF, p_61)))))
    { /* block id: 236 */
        uint16_t l_599 = 0xC809;
        int32_t ***l_606 = &g_123;
        union U0 **l_632 = &l_182;
        const int32_t *l_636 = (void*)0;
        uint32_t l_692 = 0xB6E7ABCD;
        int32_t l_708 = 0x091380FC;
        uint16_t l_709 = 0x2023;
        float *l_716 = &g_27;
        uint32_t l_750 = 4294967292U;
        if ((safe_mul_func_int16_t_s_s((g_32 > (safe_div_func_uint32_t_u_u(((l_599 | g_521) && ((*l_299) == (*g_132))), (safe_lshift_func_int16_t_s_u(((p_61 && ((p_61 && (((g_63.f2 < (safe_mul_func_uint16_t_u_u((&g_123 == l_606), 0xC670))) & 7) < g_9)) == (*g_124))) < g_9), g_521))))), g_294.f2)))
        { /* block id: 237 */
            int32_t *l_616 = &l_471;
            int32_t ****l_617 = &l_606;
            if (l_599)
            { /* block id: 238 */
                int32_t ****l_613 = &l_146;
                union U0 *l_625 = &g_294;
                const uint16_t l_630 = 0x8E08;
                if ((0xECC76CC3 > 0x9D307E32))
                { /* block id: 239 */
                    uint32_t l_607 = 0x406CE03B;
                    if (l_607)
                    { /* block id: 240 */
                        float *l_608 = &g_294.f0;
                        (*l_608) = 0x9.5FE1BBp-10;
                    }
                    else
                    { /* block id: 242 */
                        int32_t * volatile *l_610 = &l_168;
                        int32_t * volatile **l_609 = &l_610;
                        (*l_609) = &g_90;
                        /* statement id: 243 */
                        assert (l_610 == &g_90);
                    }
                }
                else
                { /* block id: 245 */
                    const int32_t l_622 = (-6);
                    int32_t **l_624 = &l_153;
                    (*g_124) &= p_61;
                    if ((safe_div_func_int16_t_s_s(((l_613 == &g_122) < (safe_mul_func_uint16_t_u_u((((((p_61 <= ((l_616 == (*g_532)) || ((void*)0 != l_617))) >= __builtin_ctzll(((safe_mul_func_int16_t_s_s((safe_mod_func_int16_t_s_s((0x2C4B | g_9), p_61)), 0U)) != p_61))) > g_91) >= 0x320981EE) > l_622), l_623))), p_61)))
                    { /* block id: 247 */
                        (*g_124) = (l_624 == (void*)0);
                        (*l_624) = (*g_532);
                        /* statement id: 249 */
                        assert (l_153 == &l_165 || l_153 == &g_32);
                    }
                    else
                    { /* block id: 250 */
                        return l_625;
                        /* statement id: 251 */
                        //assert (g_124 == dangling || g_124 == &g_32);
                        //assert (g_123 == dangling);
                        //assert (func_57_rv == &g_294);
                    }
                    /* facts after branching */
                    assert (l_153 == &l_165 || l_153 == &g_32);
                }
                /* facts after branching */
                assert (l_153 == &l_165 || l_153 == &g_32 || l_153 == 0);
                if ((p_61 <= (safe_add_func_int32_t_s_s((p_61 <= (safe_mul_func_int16_t_s_s(__builtin_parityl(g_117), g_91))), ((*l_616) == l_630)))))
                { /* block id: 254 */
                    uint32_t l_631 = 0x26D48073;
                    l_636 = func_92(func_96(p_61, l_631), (p_61 <= ((((l_632 != (void*)0) < (safe_div_func_float_f_f(((__builtin_ffsll(((__builtin_bswap32(p_61) ^ l_635) && 65526U)) > 0x0.7p-1) > (-0x1.1p-1)), p_61))) != (*g_343)) != p_61)), p_61);
                    /* statement id: 255 */
                    assert (l_636 == &g_91);
                }
                else
                { /* block id: 256 */
                    uint16_t l_641 = 8U;
                    int32_t l_651 = 0x6CA26BFC;
                    int32_t l_656 = 0x50732C6F;
                    float *l_665 = &l_538;
                    for (g_117 = 0; (g_117 > 17); ++g_117)
                    { /* block id: 259 */
                        (*l_616) = (safe_lshift_func_uint16_t_u_u(((l_641 > (safe_mul_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((g_294.f1 < ((void*)0 != (*l_299))), 0x4F94)), (safe_mul_func_uint16_t_u_u(p_61, l_641))))) || (safe_add_func_uint16_t_u_u(((!5) == (l_651 > (*g_90))), 0x7BD5))), g_32));
                        l_656 = (safe_mul_func_int16_t_s_s(g_294.f2, (safe_mul_func_uint16_t_u_u((0U != (0x0B2F & (l_617 != l_613))), 0U))));
                    }
                    (*l_665) = ((safe_sub_func_float_f_f(p_61, (safe_div_func_float_f_f(((safe_mul_func_float_f_f(0x0.1p+1, (safe_mul_func_float_f_f((l_656 < (*g_343)), (g_294.f2 > ((-0x7.7p-1) == g_294.f2)))))) >= (g_521 < __builtin_clz(p_61))), g_91)))) <= g_294.f2);
                }
                /* facts after branching */
                assert (l_636 == 0 || l_636 == &g_91);
            }
            else
            { /* block id: 265 */
                uint32_t l_666 = 0x424A25B0;
                (*l_616) &= l_666;
                if ((safe_rshift_func_int16_t_s_u(g_63.f2, 10)))
                { /* block id: 267 */
                    uint32_t l_683 = 1U;
                    float *l_684 = &l_538;
                    (*l_616) |= ((l_666 ^ (((*g_132) == p_58) > (safe_lshift_func_uint16_t_u_s((safe_div_func_uint32_t_u_u(g_32, __builtin_parity(g_63.f2))), 8)))) || (safe_rshift_func_int16_t_s_u((safe_add_func_int32_t_s_s(p_61, ((safe_mul_func_uint16_t_u_u((safe_div_func_int16_t_s_s((l_666 != g_32), 0x7949)), 65530U)) & 0U))), g_63.f2)));
                    (*l_684) = (p_61 < (((safe_div_func_float_f_f((&l_146 != &l_606), (*g_343))) == (-0x1.Ep+1)) < l_683));
                    (*g_124) ^= (safe_add_func_uint16_t_u_u(((-1) && g_91), p_61));
                }
                else
                { /* block id: 271 */
                    uint16_t l_687 = 0xAE6B;
                    l_687--;
                }
                (*g_124) |= 0xCCBC7F95;
            }
            /* facts after branching */
            assert (l_153 == &l_165 || l_153 == &g_32 || l_153 == 0);
            assert (l_636 == 0 || l_636 == &g_91);
            (*l_616) ^= (0x8667795B == (safe_div_func_uint32_t_u_u(g_117, l_692)));
            (*l_616) &= 0x21DDC9AF;
        }
        else
        { /* block id: 278 */
            int32_t *l_693 = &l_523;
            const int32_t **l_694 = &l_636;
            (*g_532) = l_693;
            /* statement id: 279 */
            assert (g_124 == &l_523);
            (*l_694) = l_636;
            (*l_693) &= (safe_lshift_func_int16_t_s_u((safe_div_func_int32_t_s_s(l_699, (safe_rshift_func_uint16_t_u_s((p_61 >= ((safe_rshift_func_int16_t_s_u(p_61, 0)) < g_294.f1)), 9)))), (safe_rshift_func_int16_t_s_u(g_117, p_61))));
        }
        /* facts after branching */
        assert (g_124 == &l_523 || g_124 == &l_165 || g_124 == &g_32);
        assert (l_153 == &l_165 || l_153 == &g_32 || l_153 == 0);
        assert (l_636 == 0 || l_636 == &g_91);
        l_709 &= (l_708 == p_61);
        if ((*g_90))
        { /* block id: 284 */
            int32_t l_720 = 9;
            (*g_724) &= (safe_mod_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u(p_61, ((safe_rshift_func_int16_t_s_s(((l_716 != l_717) ^ ((safe_sub_func_uint32_t_u_u(l_720, ((l_720 | (!(safe_sub_func_uint16_t_u_u((g_521 >= ((void*)0 == l_146)), g_32)))) != 0xC9AD))) ^ g_294.f2)), g_264)) & 0xEB9FCCEE))), 0xFC142766));
        }
        else
        { /* block id: 286 */
            float l_725 = 0x6.EDDA96p+51;
            int32_t l_735 = 0;
            (*g_124) = ((void*)0 != l_716);
            if (p_61)
            { /* block id: 288 */
                union U0 **l_728 = &g_296;
                int32_t l_734 = 0xFE303131;
                uint16_t l_761 = 65535U;
                int32_t l_762 = 1;
                (*g_724) = (g_32 && g_294.f2);
                for (l_227 = 0; (l_227 >= 26); l_227 = safe_add_func_uint16_t_u_u(l_227, 9))
                { /* block id: 292 */
                    int32_t **l_736 = &g_124;
                }
                l_762 &= (safe_add_func_uint16_t_u_u(l_734, ((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint32_t_u_u(((((((1U >= ((((safe_mod_func_uint32_t_u_u((&p_58 == l_632), (safe_unary_minus_func_uint16_t_u((safe_mul_func_int16_t_s_s(p_61, (safe_add_func_uint16_t_u_u(l_750, (safe_rshift_func_uint16_t_u_s((safe_mul_func_int16_t_s_s(((safe_div_func_int32_t_s_s((p_61 == 2), (safe_sub_func_uint32_t_u_u((safe_div_func_int32_t_s_s((l_761 == 0U), (*g_124))), 5U)))) | 0xDCD79D70), p_61)), 1)))))))))) < (**g_532)) || p_61) < l_761)) ^ (*g_124)) <= 1) >= 0xA807) == 0x61EBABCD) ^ 0x7043), (*g_124))), p_61)) ^ (-5))));
                (*g_763) = &l_735;
                /* statement id: 299 */
                assert (g_124 == &l_735);
            }
            else
            { /* block id: 300 */
                float **l_765 = (void*)0;
                float ***l_764 = &l_765;
                int32_t *l_770 = &l_551;
                (*l_717) = 0x0.6p-1;
                (*l_717) = 0x0.3p+1;
                (*l_764) = (void*)0;
                (*l_770) = (safe_div_func_float_f_f(((safe_div_func_float_f_f(((*g_132) != p_59), p_61)) < ((&l_735 != l_770) > (safe_sub_func_float_f_f((safe_mul_func_float_f_f((((void*)0 == &l_716) == 0xC.FADF87p+74), (safe_add_func_float_f_f(g_91, g_117)))), p_61)))), p_61));
            }
            /* facts after branching */
            assert (g_124 == &l_523 || g_124 == &l_165 || g_124 == &g_32 || g_124 == &l_735);
            l_777 = l_636;
            /* statement id: 306 */
            assert (l_777 == 0 || l_777 == &g_91);
            return (*g_295);
            /* statement id: 307 */
            //assert (g_124 == dangling || g_124 == &g_32);
            //assert (g_123 == dangling);
            //assert (func_57_rv == &g_294 || func_57_rv == &g_63);
        }
        return (*g_295);
        /* statement id: 309 */
        //assert (g_124 == dangling || g_124 == &g_32);
        //assert (g_123 == dangling);
        //assert (func_57_rv == &g_294 || func_57_rv == &g_63);
    }
    else
    { /* block id: 310 */
        uint32_t l_790 = 0x4B9FD41C;
        int32_t *l_800 = &g_521;
        if (p_61)
        { /* block id: 311 */
            int32_t *l_781 = &g_521;
            l_780 ^= (safe_lshift_func_uint16_t_u_u(p_61, 2));
            (*g_791) = func_92(l_781, ((safe_sub_func_float_f_f((*l_781), (((safe_mul_func_float_f_f(((*g_343) <= (*l_781)), (safe_div_func_float_f_f(p_61, (safe_div_func_float_f_f(__builtin_bswap64(l_790), ((g_521 >= g_264) != 0x0.0p+1))))))) < g_264) <= 0xC.E98831p+65))) <= p_61), g_521);
            /* statement id: 313 */
            assert (g_792 == &g_91);
        }
        else
        { /* block id: 314 */
            uint16_t l_795 = 0x96B2;
            int32_t l_796 = 0xF2F72836;
            float **l_798 = &l_717;
            float ***l_797 = &l_798;
            l_796 ^= ((safe_rshift_func_int16_t_s_s((p_61 && l_795), 5)) != g_32);
            (*g_124) &= ((((void*)0 == l_797) < l_799) <= g_264);
            (*g_763) = l_800;
            /* statement id: 317 */
            assert (g_124 == &g_521);
        }
        /* facts after branching */
        assert (g_124 == &g_521 || g_124 == &l_165 || g_124 == &g_32);
        assert (g_792 == &g_117 || g_792 == &g_91);
    }
    /* facts after branching */
    assert (g_124 == &g_521 || g_124 == &l_165 || g_124 == &g_32);
    assert (g_792 == &g_117 || g_792 == &g_91);
    return (*g_295);
    /* statement id: 320 */
    //assert (g_124 == &g_521 || g_124 == dangling || g_124 == &g_32);
    //assert (g_123 == dangling);
    //assert (func_57_rv == &g_294 || func_57_rv == &g_63);
}


/* ------------------------------------------ */
/* 
 * reads : g_124 g_132 g_32 g_90 g_91
 * writes: g_32 g_133
 */
static union U0 * func_64(float  p_65, uint32_t  p_66, union U0 * p_67, int32_t  p_68)
{ /* block id: 70 */
    float l_128 = (-0x1.3p+1);
    int32_t l_129 = 0x6C5FA607;
    const union U0 *l_130 = &g_63;
    int32_t ***l_139 = &g_123;
    (*g_124) = (safe_mul_func_int16_t_s_s((-7), l_129));
    (*g_132) = l_130;
    for (g_32 = 0; (g_32 < (-25)); g_32 = safe_sub_func_int32_t_s_s(g_32, 5))
    { /* block id: 75 */
        int32_t l_136 = 0x6E08938C;
        int32_t ***l_140 = &g_123;
        int32_t *l_141 = (void*)0;
        int32_t l_142 = 0x91FCF288;
        l_142 = ((l_136 || (safe_add_func_int32_t_s_s((l_139 == l_140), (*g_90)))) | (-7));
    }
    return &g_63;
    /* statement id: 78 */
    //assert (func_64_rv == &g_63);
}


/* ------------------------------------------ */
/* 
 * reads : g_122
 * writes: g_123
 */
inline static union U0 * func_69(union U0 * p_70, int16_t  p_71, uint32_t  p_72)
{ /* block id: 67 */
    int32_t *l_121 = &g_117;
    int32_t **l_120 = &l_121;
    union U0 *l_125 = (void*)0;
    (*g_122) = l_120;
    /* statement id: 68 */
    assert (g_123 == &l_121);
    return l_125;
    /* statement id: 69 */
    //assert (g_123 == dangling);
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_90 g_91 g_9 g_32 g_63.f1 g_63.f2 g_117
 * writes: g_91 g_63.f2 g_117
 */
inline static union U0 * func_73(uint32_t  p_74, int32_t  p_75, uint32_t  p_76, float  p_77)
{ /* block id: 51 */
    uint32_t l_103 = 0x5CCBD95D;
    union U0 *l_104 = &g_63;
    const int32_t **l_118 = (void*)0;
    const int32_t *l_119 = &g_91;
    (*g_90) &= ((void*)0 != &g_63);
    l_119 = func_92(func_96((g_91 && ((safe_mul_func_uint16_t_u_u(5U, (1U < (g_9 == l_103)))) < ((l_104 == (void*)0) ^ p_74))), g_32), g_63.f1, p_76);
    /* statement id: 65 */
    return l_104;
    /* statement id: 66 */
    //assert (func_73_rv == &g_63);
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_63.f2 g_90 g_117 g_521
 * writes: g_91 g_63.f2 g_117 g_521
 */
static const int32_t * func_92(int32_t * p_93, float  p_94, int32_t  p_95)
{ /* block id: 56 */
    (*p_93) &= (-4);
    for (g_63.f2 = 0; (g_63.f2 > 23); g_63.f2 = safe_add_func_uint16_t_u_u(g_63.f2, 1))
    { /* block id: 60 */
        int32_t *l_116 = &g_117;
        if ((*g_90))
            break;
        (*l_116) |= ((safe_sub_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_s(p_95, g_63.f2)) & (safe_div_func_int32_t_s_s((*p_93), p_95))), (&g_91 != (void*)0))) > 0x387092E0);
    }
    return &g_91;
    /* statement id: 64 */
    //assert (func_92_rv == &g_91);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_96(int16_t  p_97, int32_t  p_98)
{ /* block id: 53 */
    int32_t *l_105 = &g_32;
    int32_t **l_106 = &l_105;
    (*l_106) = l_105;
    return &g_91;
    /* statement id: 55 */
    //assert (func_96_rv == &g_91);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc_bytes (&g_27, sizeof(g_27), "g_27", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    transparent_crc_bytes (&g_63.f0, sizeof(g_63.f0), "g_63.f0", print_hash_value);
    transparent_crc(g_63.f1, "g_63.f1", print_hash_value);
    transparent_crc(g_63.f2, "g_63.f2", print_hash_value);
    transparent_crc(g_91, "g_91", print_hash_value);
    transparent_crc(g_117, "g_117", print_hash_value);
    transparent_crc(g_264, "g_264", print_hash_value);
    transparent_crc_bytes (&g_294.f0, sizeof(g_294.f0), "g_294.f0", print_hash_value);
    transparent_crc(g_294.f1, "g_294.f1", print_hash_value);
    transparent_crc(g_294.f2, "g_294.f2", print_hash_value);
    transparent_crc(g_521, "g_521", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 151
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 151
   depth: 2, occurrence: 28
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 4
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 4
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 4
   depth: 21, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1

XXX total number of pointers: 245

XXX times a variable address is taken: 205
XXX times a pointer is dereferenced on RHS: 76
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 7
XXX times a pointer is dereferenced on LHS: 76
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 791

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 245
   level: 2, occurrence: 61
   level: 3, occurrence: 57
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 50
XXX number of pointers point to scalars: 174
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.5
XXX average alias set size: 1.13

XXX times a non-volatile is read: 564
XXX times a non-volatile is write: 188
XXX times a volatile is read: 43
XXX    times read thru a pointer: 0
XXX times a volatile is write: 17
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 615
XXX percentage of non-volatile access: 92.6

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 138
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 21
   depth: 2, occurrence: 29
   depth: 3, occurrence: 22
   depth: 4, occurrence: 18
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 18.8
XXX percentage an existing variable is used: 81.2
********************* end of statistics **********************/

