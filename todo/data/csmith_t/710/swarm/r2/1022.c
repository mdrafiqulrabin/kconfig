/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      892894682
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 27;
   unsigned f1 : 4;
   const int32_t  f2;
   unsigned f3 : 10;
   const signed f4 : 17;
   unsigned f5 : 4;
   signed f6 : 18;
   const unsigned f7 : 31;
   unsigned f8 : 7;
   signed f9 : 25;
};

union U1 {
   uint32_t  f0;
   const uint16_t  f1;
};

union U2 {
   uint16_t  f0;
};

union U3 {
   int8_t  f0;
   uint16_t  f1;
   uint32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_30(void);
static uint32_t  func_32(union U2  p_33, int32_t  p_34, int32_t  p_35);
static union U2  func_36(int16_t  p_37, int8_t  p_38, uint32_t  p_39, const int8_t  p_40);
static int32_t  func_45(const union U3  p_46, uint16_t  p_47, uint32_t  p_48);
static const union U3  func_49(uint32_t  p_50, int16_t  p_51);
static uint32_t  func_52(uint32_t  p_53);
static uint32_t  func_54(struct S0  p_55);
static struct S0  func_56(uint32_t  p_57, int32_t  p_58, uint16_t  p_59, int16_t  p_60);
static int32_t  func_98(int32_t  p_99, union U3  p_100, union U1  p_101, int8_t  p_102, union U2  p_103);
static uint16_t  func_110(struct S0  p_111, uint32_t  p_112, const struct S0  p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = (-9L);
    int32_t l_68 = 0L;
    const uint32_t l_69 = 0x8A615B38L;
    int32_t l_438 = 0xECA5AEEDL;
    union U3 l_445 = {-6L};
    uint16_t l_447 = 65531UL;
    struct S0 l_469 = {5402,3,0xD3D46050L,7,259,0,-413,24559,2,1307};
    union U2 l_486 = {0xF051L};
    int32_t l_488 = 1L;
    l_31 = l_31;
    if ((l_31 >= (((l_31 > ((func_32(func_36(l_31, ((int16_t)((int32_t)func_45(func_49(func_52(func_54(func_56(((uint16_t)((uint16_t)(l_68 = (0x08A5L >= ((l_31 < (((-(int32_t)(-8L)) < ((int32_t)1L + (int32_t)0xB4BC71F8L)) <= (l_31 < 65535UL))) && l_31))) << (uint16_t)l_31) * (uint16_t)l_69), l_31, l_31, l_31))), l_69), l_69, l_69) - (int32_t)l_69) - (int16_t)1UL), l_31, l_31), l_69, l_31) != l_69) <= l_69)) <= l_69) > l_69)))
    { /* block id: 201 */
        uint32_t l_359 = 0x181665E0L;
        int32_t l_378 = 0x3C713A0FL;
        l_378 = ((uint16_t)l_359 - (uint16_t)((int32_t)((uint16_t)l_68 * (uint16_t)(l_69 <= __builtin_parityll((((+(1L & (l_31 = ((uint16_t)(((uint16_t)((uint16_t)l_359 + (uint16_t)((int16_t)((uint16_t)((!(l_359 > ((uint16_t)(l_359 != (l_359 >= l_359)) + (uint16_t)l_31))) == l_69) * (uint16_t)l_359) >> (int16_t)0)) * (uint16_t)l_359) < 0L) << (uint16_t)l_378)))) < 4294967295UL) != l_69)))) - (int32_t)l_378));
        l_378 = ((l_378 ^ l_378) == l_359);
        for (l_68 = (-20); (l_68 < 10); l_68 += 1)
        { /* block id: 207 */
            int32_t l_381 = 1L;
            uint32_t l_384 = 0UL;
            if (l_381)
            { /* block id: 208 */
                l_31 = 0L;
            }
            else
            { /* block id: 210 */
                int32_t l_382 = 0xCBF97C39L;
                int32_t l_383 = (-4L);
                l_382 = l_382;
                l_383 = (l_382 = l_382);
            }
            if (l_384)
                continue;
        }
    }
    else
    { /* block id: 217 */
        int8_t l_387 = 0x01L;
        int32_t l_390 = 0x168CD2F3L;
        union U3 l_415 = {1L};
        union U1 l_416 = {0UL};
        union U2 l_417 = {65535UL};
        const uint32_t l_418 = 0UL;
        int32_t l_419 = (-1L);
        uint32_t l_439 = 0UL;
        int32_t l_441 = 9L;
        int32_t l_442 = 0x72C3D71FL;
        const struct S0 l_470 = {3405,1,0x7B5ECB83L,7,-19,0,282,35620,6,-632};
        uint16_t l_482 = 0x22E1L;
        struct S0 l_487 = {2315,1,0x6F16D85AL,1,133,3,-129,45794,9,420};
        l_390 = (((0xAE6948D2L < ((int16_t)l_387 << (int16_t)(((int16_t)5L % (int16_t)l_387) | l_69))) || l_387) >= 0xB8B0L);
        if (((uint32_t)(l_419 = ((int16_t)((((uint16_t)((l_68 = ((uint16_t)((int16_t)l_390 << (int16_t)12) * (uint16_t)l_390)) < l_390) >> (uint16_t)l_69) && ((int16_t)((int32_t)l_31 + (int32_t)(((uint32_t)(l_390 = ((uint16_t)0x22E6L >> (uint16_t)((l_31 <= ((0x14F1L >= (((((uint32_t)((uint16_t)((int16_t)(l_68 = func_98(((l_390 >= l_68) != l_387), l_415, l_416, l_68, l_417)) * (int16_t)l_69) + (uint16_t)(-10L)) % (uint32_t)l_418) ^ 4294967295UL) ^ 0x452E5C80L) | l_416.f0)) & l_69)) > l_418))) % (uint32_t)0x441DCBC4L) > l_415.f0)) % (int16_t)l_415.f0)) >= 2L) << (int16_t)l_416.f0)) + (uint32_t)l_418))
        { /* block id: 223 */
            int32_t l_423 = 0x5A36F3D0L;
            uint16_t l_426 = 65535UL;
            int32_t l_437 = 8L;
            int32_t l_440 = 3L;
            int32_t l_443 = 1L;
            union U3 l_444 = {0xEEL};
            union U2 l_446 = {0x83AEL};
            l_447 = (l_416.f0 < ((l_31 = (-1L)) & (~func_98(((uint16_t)((l_68 = (l_423 < func_98((l_443 = (l_442 = ((((l_441 = ((l_440 = ((((l_419 = ((uint16_t)l_68 + (uint16_t)(l_426 | (l_390 = (l_438 = ((l_437 = (!((int16_t)(!((uint32_t)(l_390 ^ ((int16_t)(((int16_t)(0UL >= 0x98B52443L) * (int16_t)(l_415.f0 ^ l_68)) <= 4294967288UL) % (int16_t)l_68)) + (uint32_t)l_426)) << (int16_t)l_423))) > l_68)))))) <= l_439) == l_423) <= l_423)) >= 0x6E20L)) > l_423) || l_426) || l_438))), l_444, l_416, l_68, l_417))) & l_418) * (uint16_t)l_423), l_445, l_416, l_439, l_446))));
            l_419 = l_438;
            l_442 = ((l_69 <= 0xB65DL) ^ (4294967292UL < 0L));
            l_68 = 0xF4BEE0CAL;
        }
        else
        { /* block id: 238 */
            const int32_t l_456 = 0x40CD41C9L;
            int32_t l_461 = (-2L);
            int32_t l_471 = (-1L);
            int32_t l_472 = (-1L);
            struct S0 l_477 = {7880,3,-2L,13,335,2,32,14778,9,-147};
            uint32_t l_483 = 0xAAA3C670L;
            l_472 = ((int16_t)(((uint16_t)(((int16_t)((uint16_t)(l_456 || ((l_471 = (((uint16_t)(l_68 = (l_456 == (__builtin_popcountll((l_442 = ((int16_t)l_31 - (int16_t)(((l_461 = 8L) & __builtin_ctzl((l_438 = ((uint16_t)(l_419 = 0x7DD0L) << (uint16_t)(~l_456))))) > ((int16_t)(((uint16_t)func_110(l_469, l_469.f2, l_470) << (uint16_t)9) ^ l_470.f3) % (int16_t)4L))))) >= l_417.f0))) >> (uint16_t)1) > l_456)) ^ 0x4744C215L)) - (uint16_t)1UL) >> (int16_t)l_445.f0) || 0x0092L) * (uint16_t)l_456) < 8UL) + (int16_t)l_456);
            if (((uint16_t)((uint16_t)(l_441 = 65532UL) >> (uint16_t)(func_54(l_477) == (l_472 = ((uint16_t)((uint32_t)l_69 + (uint32_t)l_470.f2) << (uint16_t)(l_471 & l_469.f2))))) + (uint16_t)0x5752L))
            { /* block id: 248 */
                return l_482;
            }
            else
            { /* block id: 250 */
                return l_483;
            }
        }
        l_469.f6 = ((uint16_t)(4294967288UL && ((((l_470.f1 & (l_470.f5 ^ (l_488 = func_32((l_486 = l_486), l_469.f7, func_110(l_487, l_470.f8, l_469))))) == 0x3DF3510CL) && l_486.f0) && l_438)) - (uint16_t)l_482);
        l_469.f6 = 0L;
    }
    l_469.f9 = (-1L);
    l_488 = l_469.f4;
    return l_469.f7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(union U2  p_33, int32_t  p_34, int32_t  p_35)
{ /* block id: 193 */
    int32_t l_331 = 0xADD2EC19L;
    const union U3 l_354 = {0x36L};
    int32_t l_355 = (-9L);
    int32_t l_356 = 0xD0CA8F3BL;
    p_34 = (l_331 = l_331);
    p_34 = (p_33.f0 < (~(!p_35)));
    p_34 = (((int32_t)((int16_t)__builtin_ffsl((l_331 & (6UL || ((int16_t)((uint16_t)(0x457B24ACL ^ ((uint16_t)l_331 >> (uint16_t)4)) * (uint16_t)(((int16_t)((uint16_t)(p_33.f0 >= ((uint16_t)(l_356 = ((uint32_t)p_33.f0 - (uint32_t)(l_355 = ((uint16_t)func_45(l_354, (l_331 || l_354.f0), p_34) % (uint16_t)p_33.f0)))) << (uint16_t)8)) >> (uint16_t)13) >> (int16_t)5) > l_354.f0)) >> (int16_t)8)))) << (int16_t)l_354.f0) - (int32_t)0L) != l_354.f0);
    return l_356;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_36(int16_t  p_37, int8_t  p_38, uint32_t  p_39, const int8_t  p_40)
{ /* block id: 153 */
    int32_t l_263 = 0x367CD0BFL;
    int32_t l_324 = 0x92DDC86AL;
    union U2 l_330 = {3UL};
    for (p_37 = (-30); (p_37 <= 23); p_37 += 9)
    { /* block id: 156 */
        int32_t l_271 = 9L;
        int32_t l_276 = 0x929E3FC9L;
        uint32_t l_297 = 1UL;
        l_271 = ((int16_t)(((int32_t)l_263 + (int32_t)(((int16_t)((uint16_t)(-(uint16_t)((uint16_t)0UL << (uint16_t)l_271)) << (uint16_t)(l_263 < ((uint16_t)((int16_t)l_271 * (int16_t)p_39) << (uint16_t)(p_40 == __builtin_popcountl((l_276 = p_40)))))) + (int16_t)p_39) || 1UL)) > 0x3C94311DL) << (int16_t)4);
        for (l_271 = (-28); (l_271 < 5); l_271 += 1)
        { /* block id: 161 */
            if (p_38)
                break;
        }
        l_271 = (p_39 >= (l_263 = ((int32_t)(l_276 = (~p_39)) % (int32_t)0x3610A6F7L)));
        for (p_39 = 16; (p_39 < 45); p_39 += 1)
        { /* block id: 169 */
            int16_t l_284 = 0xB2D0L;
            int32_t l_294 = 0x321C0B2DL;
            union U1 l_326 = {1UL};
            int32_t l_328 = (-1L);
            if (l_284)
            { /* block id: 170 */
                int32_t l_300 = 4L;
                l_263 = ((int16_t)l_263 >> (int16_t)14);
                if ((l_263 = ((-(int32_t)(((((int16_t)l_263 + (int16_t)(l_263 < ((uint16_t)((int32_t)(l_294 = p_37) + (int32_t)(((uint16_t)p_40 - (uint16_t)l_297) && ((int16_t)p_39 << (int16_t)l_300))) << (uint16_t)p_37))) || ((int16_t)p_37 << (int16_t)l_300)) < p_38) != l_263)) > 0xD1EDC45BL)))
                { /* block id: 174 */
                    l_276 = ((int32_t)((int16_t)p_37 + (int16_t)p_40) - (int32_t)(l_284 ^ (((int32_t)((int16_t)(func_52(l_294) >= (__builtin_bswap32(l_300) <= (l_271 != ((int32_t)(~(((p_38 != 4L) ^ p_40) || l_294)) % (int32_t)0xB44842A3L)))) * (int16_t)p_39) + (int32_t)l_300) < 0x5A84L)));
                }
                else
                { /* block id: 176 */
                    l_300 = p_37;
                }
            }
            else
            { /* block id: 179 */
                int32_t l_323 = 1L;
                union U3 l_325 = {0xC6L};
                union U2 l_327 = {3UL};
                int32_t l_329 = (-1L);
                if (l_263)
                    break;
                if (p_40)
                    break;
                l_329 = (((l_328 = ((uint16_t)((l_323 = (((+(l_263 > (p_39 < (l_294 = __builtin_ia32_crc32qi(l_263, p_39))))) || ((uint32_t)6UL + (uint32_t)(p_39 & ((__builtin_clzl(func_98(((l_263 = ((int16_t)((((p_39 < l_284) | 0UL) == l_323) & l_276) + (int16_t)p_40)) < l_324), l_325, l_326, l_297, l_327)) | l_271) == l_271)))) < l_324)) != l_284) - (uint16_t)l_271)) != 0xAFFD9555L) == p_38);
            }
            l_328 = (-1L);
            if (p_38)
                continue;
        }
    }
    return l_330;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_45(const union U3  p_46, uint16_t  p_47, uint32_t  p_48)
{ /* block id: 138 */
    int8_t l_202 = 0xA6L;
    int32_t l_213 = (-8L);
    int32_t l_214 = (-1L);
    struct S0 l_225 = {6031,1,0x236E2A3DL,16,337,2,145,8677,10,-1474};
    uint32_t l_228 = 0UL;
    union U2 l_229 = {0x81A3L};
    int32_t l_239 = (-3L);
    if ((+((((l_202 == (__builtin_ffsll(p_47) | ((uint16_t)(1L >= (l_202 & 0L)) - (uint16_t)(1L & ((uint32_t)(((uint16_t)((uint16_t)((l_213 = ((int16_t)l_202 * (int16_t)p_46.f0)) ^ l_202) >> (uint16_t)14) << (uint16_t)12) > p_46.f0) + (uint32_t)l_202))))) ^ p_48) || 0xDAF8L) || l_214)))
    { /* block id: 140 */
        int16_t l_215 = (-2L);
        union U1 l_216 = {7UL};
        int32_t l_230 = 0xB9126752L;
        l_213 = (func_98(l_215, p_46, l_216, ((int16_t)(((p_47 = ((int16_t)0x01FBL >> (int16_t)11)) > ((int16_t)((uint16_t)__builtin_parityll(((func_54(l_225) < (p_46.f0 && ((int16_t)__builtin_parityl(l_228) << (int16_t)11))) ^ (-8L))) << (uint16_t)13) >> (int16_t)6)) != 0xCC336A52L) * (int16_t)p_48), l_229) > l_225.f5);
        l_230 = (p_47 == (-3L));
        return p_46.f0;
    }
    else
    { /* block id: 145 */
        int32_t l_236 = 1L;
        const struct S0 l_245 = {10811,1,-2L,4,201,1,-488,45206,9,2744};
        int32_t l_256 = (-1L);
        l_239 = ((int16_t)((uint32_t)(l_213 = ((p_46.f0 > (__builtin_bswap64((+l_236)) == (((((uint32_t)l_239 + (uint32_t)(((int32_t)((func_110(func_56((l_236 > ((0xAA95L < func_54(func_56(((uint32_t)(4294967286UL | (+(p_48 | l_236))) + (uint32_t)l_236), p_48, l_236, p_46.f0))) && l_236)), l_225.f6, l_236, p_46.f0), p_46.f0, l_245) | p_46.f0) || l_202) % (int32_t)0xBE26192BL) < p_46.f0)) >= 0x1BFD6407L) && l_245.f7) >= p_46.f0))) ^ 0x7FB83B52L)) % (uint32_t)l_245.f8) % (int16_t)0x07EDL);
        l_213 = l_214;
        l_256 = (l_202 ^ (((uint32_t)(((p_47 <= (((uint32_t)((!0x3270L) <= (~l_236)) % (uint32_t)((int32_t)p_47 - (int32_t)(-1L))) >= (p_48 & l_245.f1))) > (((int32_t)p_46.f0 - (int32_t)(-1L)) != p_48)) | p_48) + (uint32_t)0UL) & 0x1364L));
        l_225.f6 = (l_225.f9 || 1UL);
    }
    return l_225.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const union U3  func_49(uint32_t  p_50, int16_t  p_51)
{ /* block id: 93 */
    uint16_t l_154 = 0UL;
    int32_t l_155 = 0xB29B62C0L;
    int8_t l_158 = 0x3EL;
    int32_t l_159 = 0L;
    union U1 l_172 = {0x34A03365L};
    uint32_t l_175 = 4UL;
    int32_t l_180 = 0xF91888F9L;
    const union U3 l_200 = {1L};
    for (p_50 = (-5); (p_50 < 24); p_50 += 5)
    { /* block id: 96 */
        int16_t l_151 = 0xDC64L;
        union U3 l_171 = {0L};
        int32_t l_174 = 0xB1F48843L;
        union U1 l_188 = {4294967290UL};
        l_159 = (l_155 = ((((int16_t)((~(((uint16_t)l_151 << (uint16_t)(l_151 & ((uint16_t)(func_52((l_158 = ((p_51 <= (l_154 = l_151)) < ((l_151 | __builtin_ia32_crc32qi(p_51, l_155)) && ((int16_t)(6L & 5L) % (int16_t)l_151))))) >= 0x63A56911L) >> (uint16_t)l_151))) < 7UL)) ^ l_151) % (int16_t)p_51) & 0xAD9904AAL) != 0x9E8AL));
        for (l_155 = 0; (l_155 >= (-15)); l_155 -= 5)
        { /* block id: 103 */
            union U2 l_173 = {4UL};
            union U2 l_189 = {0xEB84L};
            int32_t l_190 = 8L;
            int32_t l_192 = 0x5B32F8ACL;
            for (l_159 = (-10); (l_159 == (-17)); l_159--)
            { /* block id: 106 */
                int16_t l_183 = 0xE515L;
                for (p_51 = 0; (p_51 <= 9); p_51++)
                { /* block id: 109 */
                    uint32_t l_168 = 18446744073709551613UL;
                    int32_t l_176 = 7L;
                    int32_t l_177 = 0xB91D3D6DL;
                    int32_t l_178 = 0x327B72E6L;
                    int32_t l_187 = 0xB38AE19FL;
                    if ((((uint16_t)((l_168 == 0xFC80EF89L) | (__builtin_ctzll(((l_174 = ((func_52((((uint32_t)func_98(p_51, l_171, l_172, l_172.f1, l_173) + (uint32_t)p_50) > 0x1F78L)) > p_51) == l_168)) <= l_151)) || l_175)) + (uint16_t)p_50) && p_51))
                    { /* block id: 111 */
                        int8_t l_179 = 0xE4L;
                        l_180 = (l_179 = ((l_178 = (l_177 = (l_176 = p_50))) < (__builtin_ctzll(l_151) == p_51)));
                        l_177 = (((uint16_t)l_183 >> (uint16_t)12) && (+((l_172.f1 != ((((int16_t)4L - (int16_t)(l_180 = p_51)) && ((l_174 = (l_187 == 0x018A576EL)) | 0xFA259D05L)) == (l_176 ^ l_176))) & l_171.f0)));
                        l_174 = p_51;
                        l_190 = (l_180 = __builtin_ia32_crc32qi(p_50, func_98(p_51, l_171, l_188, __builtin_parityll(p_50), l_189)));
                    }
                    else
                    { /* block id: 123 */
                        int32_t l_191 = (-5L);
                        l_192 = (l_191 = l_191);
                        l_180 = (((int16_t)(l_190 = l_174) % (int16_t)0x4DE4L) & (-(uint16_t)p_50));
                    }
                }
                l_174 = ((int16_t)(((int16_t)l_171.f0 % (int16_t)p_51) == 0x1672L) >> (int16_t)0);
            }
            l_174 = p_50;
            l_190 = __builtin_popcountl(p_50);
        }
        return l_171;
    }
    return l_200;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_52(uint32_t  p_53)
{ /* block id: 72 */
    int16_t l_130 = 0x670FL;
    uint16_t l_131 = 0x8CBAL;
    struct S0 l_132 = {4720,3,0xE63E716AL,1,75,0,-451,31394,0,2371};
    int32_t l_143 = 6L;
    for (p_53 = (-12); (p_53 != 60); p_53 += 1)
    { /* block id: 75 */
        int32_t l_127 = 0xDFBE8482L;
        for (l_127 = (-23); (l_127 <= 25); l_127 += 1)
        { /* block id: 78 */
            return l_130;
        }
        l_132.f6 = ((1UL || l_131) && ((l_127 = ((0xC6C14278L == p_53) & p_53)) | func_54(l_132)));
        l_132.f9 = (__builtin_ctz(l_132.f9) != (l_127 = (l_132.f6 = l_132.f4)));
        l_132.f6 = ((l_127 = l_127) && l_127);
    }
    l_132.f6 = (1UL == ((uint16_t)(l_132.f9 = ((int16_t)(func_54(l_132) ^ ((l_143 = ((l_132.f0 <= __builtin_parity(p_53)) >= ((uint16_t)((int16_t)((uint16_t)0UL + (uint16_t)func_54(l_132)) - (int16_t)p_53) << (uint16_t)l_132.f4))) >= l_132.f5)) >> (int16_t)1)) % (uint16_t)l_132.f3));
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_54(struct S0  p_55)
{ /* block id: 54 */
    uint16_t l_87 = 65535UL;
    int32_t l_94 = (-2L);
    int32_t l_95 = (-1L);
    uint16_t l_96 = 1UL;
    struct S0 l_114 = {8418,1,7L,14,-303,2,288,41772,8,1736};
    union U3 l_120 = {-7L};
    union U1 l_121 = {0x896690B9L};
    union U2 l_122 = {0x3A7AL};
    int32_t l_124 = 9L;
    p_55.f6 = ((int16_t)((int32_t)((uint16_t)l_87 >> (uint16_t)1) - (int32_t)(((uint16_t)(p_55.f2 <= 4294967289UL) * (uint16_t)l_87) && ((((l_87 ^ (l_87 & (((((uint16_t)(((-2L) && (l_95 = (((int16_t)((0L ^ (l_94 = l_87)) == 0L) - (int16_t)p_55.f2) || l_94))) == p_55.f3) + (uint16_t)0x679CL) | p_55.f4) || l_96) != l_96))) && (-8L)) > p_55.f2) || l_95))) << (int16_t)9);
    p_55.f9 = ((!p_55.f5) | 0xAA41409BL);
    l_124 = func_98((l_114.f9 = ((p_55.f8 < ((1L | (l_114.f6 = ((int16_t)(l_94 = (l_95 = l_94)) >> (int16_t)((((0L >= ((uint32_t)(((uint16_t)func_110(l_114, ((int16_t)((int16_t)l_114.f6 >> (int16_t)7) + (int16_t)__builtin_popcountl(p_55.f7)), p_55) << (uint16_t)14) >= 0x005B5690L) + (uint32_t)l_114.f7)) && p_55.f3) ^ 0x7056L) == l_114.f7)))) < l_114.f4)) || l_95)), l_120, l_121, p_55.f9, l_122);
    return l_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_56(uint32_t  p_57, int32_t  p_58, uint16_t  p_59, int16_t  p_60)
{ /* block id: 39 */
    int16_t l_72 = 0x8BF9L;
    struct S0 l_80 = {5605,3,0xD024BFCCL,16,182,0,382,38572,0,2524};
lbl_75:
    l_72 = ((uint16_t)p_58 >> (uint16_t)0);
    for (p_58 = 1; (p_58 < 8); p_58 += 1)
    { /* block id: 43 */
        uint32_t l_78 = 0x1BE1695EL;
        int32_t l_79 = 0x57B790EBL;
        if (p_58)
            goto lbl_75;
        for (p_59 = 0; (p_59 == 13); p_59 += 1)
        { /* block id: 47 */
            if (p_59)
                break;
        }
        if (l_78)
            break;
        l_79 = l_72;
    }
    return l_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_98(int32_t  p_99, union U3  p_100, union U1  p_101, int8_t  p_102, union U2  p_103)
{ /* block id: 67 */
    int8_t l_123 = 0L;
    l_123 = (p_102 <= p_99);
    return l_123;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_110(struct S0  p_111, uint32_t  p_112, const struct S0  p_113)
{ /* block id: 61 */
    int32_t l_119 = 0x426174F5L;
    l_119 = l_119;
    l_119 = l_119;
    return l_119;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 117
   depth: 1, occurrence: 9
XXX total union variables: 23

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 9
breakdown:
   indirect level: 0, occurrence: 9
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 13
XXX times a single bitfield on LHS: 14
XXX times a single bitfield on RHS: 31

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 23
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 28, occurrence: 1
   depth: 31, occurrence: 2
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 37, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 406
XXX times a non-volatile is write: 133
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 97
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 29
   depth: 2, occurrence: 17
   depth: 3, occurrence: 12
   depth: 4, occurrence: 3
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 24
XXX percentage an existing variable is used: 76
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

