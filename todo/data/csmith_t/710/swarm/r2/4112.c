/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      175972886
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   unsigned f0 : 7;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   int8_t * f4;
};

union U1 {
   uint8_t  f0;
   int32_t  f1;
   uint8_t  f2;
};

union U2 {
   const signed f0 : 29;
   const uint32_t  f1;
   const int32_t  f2;
   unsigned f3 : 1;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 0UL;
static const union U1 g_42 = {255UL};
static const union U1 *g_41 = &g_42;
static int32_t g_53 = 0xC6EB81F9L;
static int32_t *g_52 = &g_53;
static union U1 g_55 = {0x1AL};
static union U1 *g_54 = &g_55;
static int8_t g_80 = 0xA4L;
static int32_t g_97 = 3L;
static const union U0 g_164 = {0x726115DAL};
static union U1 **g_165 = &g_54;
static const union U0 g_233 = {4UL};
static const union U0 *g_232 = &g_233;
static const int32_t *g_249 = &g_53;
static union U2 *g_294 = (void*)0;
static union U2 g_296 = {0x698B2B73L};
static int32_t g_393 = 0L;
static int32_t *g_420 = &g_393;
static const union U0 **g_455 = &g_232;
static union U0 *g_477 = (void*)0;
static union U0 **g_476 = &g_477;
static union U0 ***g_475 = &g_476;
static union U0 *** const *g_474 = &g_475;
static union U2 ***g_513 = (void*)0;
static union U2 ****g_512 = &g_513;
static int8_t g_544 = 0xF8L;
static int8_t *g_543 = &g_544;
static union U1 g_560 = {248UL};
static const union U1 **g_574 = (void*)0;
static const union U1 ***g_573 = &g_574;
static const union U1 ****g_572 = &g_573;
static int32_t g_579 = 0x4D768535L;


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_29(void);
static union U1  func_43(const int32_t * p_44, uint64_t  p_45, union U1 * const  p_46, union U1  p_47, const int8_t * p_48);
static int32_t * func_49(int32_t * p_50, union U1 * p_51);
static int32_t * func_57(uint32_t  p_58, union U2  p_59, union U1  p_60, uint16_t  p_61, uint16_t  p_62);
static int8_t * const  func_65(union U1 * p_66, int8_t * p_67, const int32_t  p_68, int16_t  p_69, const union U1 * p_70);
static int8_t * func_71(uint16_t  p_72, const int32_t  p_73, int8_t  p_74);
static union U2  func_75(int32_t  p_76, uint32_t  p_77, int8_t * p_78);
static int8_t * func_81(union U0  p_82);
static union U0  func_83(union U1 * p_84, union U1  p_85, const int8_t * p_86, int8_t  p_87, uint64_t  p_88);
static union U1  func_91(int8_t * p_92, const union U0  p_93, int32_t * p_94, int8_t * p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_52 g_54 g_97 g_53 g_80 g_55.f2 g_42.f2 g_42.f0 g_164 g_165 g_164.f0 g_232 g_233 g_55.f0 g_296.f0 g_233.f0 g_249 g_420 g_393 g_474 g_475 g_476 g_455 g_512 g_543 g_560 g_55 g_544 g_572 g_579
 * writes: g_41 g_53 g_52 g_54 g_55.f2 g_55.f0 g_6 g_393 g_80 g_97 g_477 g_294 g_249 g_420
 */
static uint64_t  func_29(void)
{ /* block id: 36 */
    int32_t l_38 = (-8L);
    int32_t l_39 = 0x56E623B2L;
    int32_t *l_40 = &l_38;
    union U1 * const l_559 = &g_560;
    union U2 l_569 = {0x408A126EL};
    int32_t l_577 = (-1L);
    (*l_40) = ((uint32_t)__builtin_popcountl(((((uint16_t)((int16_t)g_6 << (int16_t)g_6) + (uint16_t)__builtin_ffsll((((((int32_t)(0xFC2FL | g_6) % (int32_t)__builtin_popcountll(l_38)) != l_38) & ((-1L) & (l_39 == l_39))) == l_39))) , 1UL) & l_38)) - (uint32_t)(-1L));
    g_41 = (void*)0;
    if ((func_43(func_49(g_52, g_54), (__builtin_ctzll(g_42.f2) >= 1UL), l_559, (*l_559), &g_544) , (-1L)))
    { /* block id: 347 */
        union U0 * const *l_563 = &g_477;
        union U0 * const **l_562 = &l_563;
        union U0 * const ***l_561 = &l_562;
        union U0 * const ****l_564 = &l_561;
        int32_t *l_565 = &g_53;
        int32_t **l_566 = &g_52;
        union U1 ***l_576 = &g_165;
        union U1 ****l_575 = &l_576;
        (*l_564) = l_561;
        (*l_566) = l_565;
        (*l_566) = (((uint8_t)g_42.f0 - (uint8_t)g_544) , func_57((*l_40), l_569, func_43(&g_53, (((int16_t)((((((*l_40) | ((*l_40) <= (**l_566))) > __builtin_clzll((0xB030L >= g_97))) , g_572) != l_575) & (-1L)) + (int16_t)0x59B8L) ^ 0x0810L), (*g_165), (**g_165), &g_80), l_577, g_544));
    }
    else
    { /* block id: 351 */
        int32_t **l_578 = &g_420;
        (*l_578) = &g_53;
    }
    return g_579;
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_393 g_165 g_54 g_55 g_53
 * writes: g_393 g_53
 */
static union U1  func_43(const int32_t * p_44, uint64_t  p_45, union U1 * const  p_46, union U1  p_47, const int8_t * p_48)
{ /* block id: 344 */
    (*g_52) = (*g_52);
    return (**g_165);
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_97 g_53 g_80 g_6 g_55.f2 g_42.f2 g_42.f0 g_54 g_164 g_165 g_164.f0 g_232 g_233 g_55.f0 g_296.f0 g_233.f0 g_249 g_420 g_393 g_474 g_475 g_476 g_455 g_512 g_543
 * writes: g_53 g_52 g_54 g_55.f2 g_55.f0 g_6 g_393 g_80 g_97 g_477 g_294 g_249 g_420
 */
static int32_t * func_49(int32_t * p_50, union U1 * p_51)
{ /* block id: 39 */
    uint32_t l_56 = 3UL;
    int8_t *l_79 = &g_80;
    union U1 *l_89 = &g_55;
    int8_t *l_90 = &g_80;
    const union U0 l_96 = {9UL};
    const uint32_t l_536 = 0xFCA02504L;
    int64_t l_545 = 1L;
    union U2 l_546 = {-6L};
    union U1 l_547 = {2UL};
    int32_t **l_558 = &g_420;
    (*g_52) = l_56;
    (*l_558) = func_57(((uint32_t)__builtin_ia32_crc32qi(((l_56 , func_65(p_51, func_71((func_75((((l_79 != (l_56 , func_81(func_83(l_89, ((l_79 != l_90) , func_91(l_90, l_96, p_50, l_90)), &g_80, g_6, l_56)))) == g_233.f0) , (-1L)), l_96.f0, l_90) , g_42.f0), l_536, l_536), g_42.f2, g_296.f0, p_51)) != g_543), g_296.f0) + (uint32_t)l_545), l_546, l_547, l_96.f0, l_56);
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_165 g_232 g_233 g_393 g_53 g_420
 * writes: g_393 g_54 g_53
 */
static int32_t * func_57(uint32_t  p_58, union U2  p_59, union U1  p_60, uint16_t  p_61, uint16_t  p_62)
{ /* block id: 335 */
    union U1 *l_550 = &g_55;
    const int32_t l_556 = 0x3C538AACL;
    int32_t *l_557 = &g_53;
    (*g_52) = (__builtin_popcountl(p_61) > ((int8_t)0xD9L << (int8_t)4));
    if (p_61)
        goto lbl_551;
lbl_551:
    (*g_165) = l_550;
    (*g_420) = ((((int32_t)0xF68319A3L + (int32_t)((*g_232) , ((int32_t)((p_60.f0 , p_62) == p_60.f0) + (int32_t)(*g_52)))) >= l_556) >= g_53);
    (*g_52) = p_60.f2;
    return l_557;
}


/* ------------------------------------------ */
/* 
 * reads : g_420
 * writes: g_249 g_393
 */
static int8_t * const  func_65(union U1 * p_66, int8_t * p_67, const int32_t  p_68, int16_t  p_69, const union U1 * p_70)
{ /* block id: 330 */
    union U2 *****l_540 = &g_512;
    const int32_t **l_541 = &g_249;
    int8_t * const l_542 = &g_80;
    l_540 = l_540;
    (*l_541) = &p_68;
    (*g_420) = p_69;
    return l_542;
}


/* ------------------------------------------ */
/* 
 * reads : g_249 g_53 g_6 g_55.f0 g_52
 * writes: g_393
 */
static int8_t * func_71(uint16_t  p_72, const int32_t  p_73, int8_t  p_74)
{ /* block id: 327 */
    uint32_t l_539 = 18446744073709551612UL;
    (*g_52) = ((((p_74 && (*g_249)) <= (((uint8_t)0UL / (uint8_t)l_539) >= 0x1E93D664719483A7LL)) && g_6) , __builtin_clzll(g_55.f0));
    return &g_80;
}


/* ------------------------------------------ */
/* 
 * reads : g_97 g_393 g_80 g_420
 * writes: g_52 g_393 g_294
 */
static union U2  func_75(int32_t  p_76, uint32_t  p_77, int8_t * p_78)
{ /* block id: 322 */
    union U2 l_527 = {0L};
    const union U0 l_529 = {0xFFF34F5CL};
    int32_t *l_530 = &g_393;
    int32_t **l_531 = (void*)0;
    int32_t **l_532 = (void*)0;
    int32_t **l_533 = &g_52;
    union U2 **l_534 = &g_294;
    union U2 l_535 = {0x5EB92D0DL};
    (*g_420) = ((((uint16_t)(l_527 , ((((!(func_91(&g_80, l_529, l_530, p_78) , (p_77 , (__builtin_ctz(((0xD3L && 1UL) <= 65532UL)) & p_77)))) , 0x3833DB70L) | 0xE02B7456L) | (*l_530))) / (uint16_t)p_76) , 0x74L) < p_77);
    (*l_533) = l_530;
    (*l_534) = &l_527;
    return l_535;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_55.f0 g_53 g_80 g_296.f0 g_42.f0 g_42.f2 g_233.f0 g_249 g_420 g_393 g_97 g_55.f2 g_474 g_475 g_476 g_455 g_232 g_233 g_164.f0 g_512
 * writes: g_6 g_55.f0 g_53 g_393 g_52 g_80 g_97 g_477
 */
static int8_t * func_81(union U0  p_82)
{ /* block id: 218 */
    uint32_t l_370 = 8UL;
    int32_t l_391 = 0x96D8AFBEL;
    union U1 l_461 = {255UL};
    uint64_t l_464 = 18446744073709551613UL;
    union U2 * const *l_467 = (void*)0;
    union U2 * const **l_466 = &l_467;
    int32_t *l_471 = &g_53;
    union U0 **** const l_478 = &g_475;
    int8_t *l_485 = &g_80;
    union U1 * const * const **l_520 = (void*)0;
    if ((l_370 <= p_82.f0))
    { /* block id: 219 */
        int8_t l_378 = 0xF5L;
        int64_t l_395 = (-9L);
        int32_t **l_396 = &g_52;
        for (g_6 = 0; (g_6 != 0); g_6 += 4)
        { /* block id: 222 */
            int8_t l_389 = 0x78L;
            for (g_55.f0 = 0; (g_55.f0 == 8); g_55.f0 += 1)
            { /* block id: 225 */
                union U2 **l_376 = (void*)0;
                union U2 ***l_375 = &l_376;
                int32_t *l_377 = (void*)0;
                const uint8_t l_381 = 255UL;
                (*l_375) = (void*)0;
                l_378 = (-1L);
                for (g_53 = 0; (g_53 == (-19)); g_53 -= 9)
                { /* block id: 230 */
                    int64_t l_390 = 0x05DDFC62B8D94905LL;
                    int32_t *l_392 = &g_393;
                    int8_t *l_394 = (void*)0;
                    (*l_392) = ((((void*)0 == (*l_375)) >= 0x97F9D90B8971933DLL) || __builtin_clz((l_381 && (((int16_t)((uint32_t)g_80 - (uint32_t)(((int32_t)((~(((l_378 ^ p_82.f0) , l_389) >= l_390)) || l_391) / (int32_t)p_82.f0) ^ g_296.f0)) % (int16_t)l_378) || l_381))));
                    (*l_392) = 0x61C27203L;
                    return l_394;
                }
            }
        }
        l_395 = (g_42.f0 < (g_53 < 0x2D67L));
        (*l_396) = &g_53;
    }
    else
    { /* block id: 239 */
        uint8_t l_399 = 0x6BL;
        int32_t *l_413 = &g_393;
        (*l_413) = ((((int8_t)g_42.f2 % (int8_t)__builtin_ctzll(l_399)) == (g_42.f2 >= ((uint64_t)((int8_t)((uint8_t)(g_42.f0 || (g_53 != (((int8_t)g_233.f0 + (int8_t)(((-(int8_t)__builtin_ffsll(p_82.f0)) >= 0xD30E99D1L) > 0L)) & p_82.f0))) << (uint8_t)2) % (int8_t)g_53) + (uint64_t)l_391))) & 250UL);
    }
lbl_465:
    for (g_80 = 6; (g_80 < 23); g_80 += 1)
    { /* block id: 244 */
        union U0 ***l_416 = (void*)0;
        union U0 ****l_417 = &l_416;
        int32_t *l_418 = (void*)0;
        int32_t *l_419 = &g_393;
        int32_t **l_421 = (void*)0;
        int32_t **l_422 = &l_418;
        (*l_417) = l_416;
        (*l_419) = __builtin_ctzl(g_6);
        if ((*g_249))
            continue;
        (*l_422) = g_420;
    }
    for (l_370 = 0; (l_370 >= 47); l_370 += 7)
    { /* block id: 252 */
        union U1 l_437 = {9UL};
        int32_t *l_486 = &g_53;
        union U1 l_504 = {0xDFL};
        union U2 l_505 = {0L};
        union U0 ****l_511 = &g_475;
        int32_t **l_524 = &g_52;
        for (g_97 = (-13); (g_97 > 14); g_97 += 1)
        { /* block id: 255 */
            int32_t l_427 = 0x0E06A7D9L;
            union U1 *l_457 = &g_55;
            int64_t l_472 = 0xE59301DB98BCBDC3LL;
        }
        if (((((int8_t)((((int64_t)g_393 - (int64_t)g_97) , __builtin_clzll(((g_55.f2 >= ((int16_t)(g_55.f0 ^ (l_437.f0 <= ((func_91(l_485, p_82, l_486, &g_80) , (-2L)) != (*l_471)))) << (int16_t)7)) , 5UL))) == (*l_471)) % (int8_t)g_55.f2) < 0x19L) , p_82.f0))
        { /* block id: 301 */
            (*g_420) = (*g_420);
            if ((*l_486))
                continue;
            for (g_80 = 4; (g_80 >= 19); g_80 += 1)
            { /* block id: 306 */
                (***g_474) = &p_82;
            }
        }
        else
        { /* block id: 309 */
            int8_t *l_501 = &g_80;
            int32_t l_506 = 0x8D2A5B00L;
            const union U2 ****l_514 = (void*)0;
            union U2 l_515 = {-1L};
            uint8_t l_518 = 2UL;
            union U1 * const * const ***l_521 = (void*)0;
            union U1 * const * const ***l_522 = (void*)0;
            union U1 * const * const ***l_523 = &l_520;
            if (((((**g_455) , ((uint16_t)((uint32_t)((int16_t)((void*)0 == &p_82) << (int16_t)(((((int16_t)((uint8_t)((int16_t)(func_91(l_501, p_82, l_471, &g_80) , ((uint64_t)(((l_504 , p_82.f0) , l_505) , 2UL) / (uint64_t)l_506)) >> (int16_t)4) - (uint8_t)(*l_486)) % (int16_t)0x3FC7L) , g_164.f0) | (*l_486)) & g_80)) + (uint32_t)(*g_420)) % (uint16_t)l_506)) ^ g_42.f2) ^ (*l_471)))
            { /* block id: 310 */
                (*g_420) = ((int32_t)(((((int64_t)(l_478 != l_511) / (int64_t)0xD1DF44C1674A97AALL) , ((g_512 != l_514) , &p_82)) == (l_515 , (void*)0)) , __builtin_ffsl(((uint16_t)(&g_420 == (void*)0) >> (uint16_t)l_518))) + (int32_t)p_82.f0);
            }
            else
            { /* block id: 312 */
                int8_t *l_519 = (void*)0;
                return l_519;
            }
            if ((*l_486))
                break;
            (*l_523) = l_520;
            l_524 = &l_486;
        }
    }
    if (g_42.f2)
        goto lbl_465;
    return l_485;
}


/* ------------------------------------------ */
/* 
 * reads : g_80 g_53 g_55.f2 g_42.f2 g_52 g_42.f0 g_6 g_97 g_54 g_164 g_165 g_164.f0 g_232 g_233
 * writes: g_52 g_53 g_54 g_55.f2 g_55.f0
 */
static union U0  func_83(union U1 * p_84, union U1  p_85, const int8_t * p_86, int8_t  p_87, uint64_t  p_88)
{ /* block id: 45 */
    int16_t l_107 = 0x1A68L;
    int8_t *l_163 = &g_80;
    uint32_t l_180 = 0x408E3904L;
    int32_t * const l_184 = &g_53;
    int32_t *l_209 = (void*)0;
    union U1 l_210 = {2UL};
    union U0 l_219 = {0x4D01EFD3L};
    union U1 ***l_221 = &g_165;
    union U1 ****l_220 = &l_221;
    const union U1 **l_231 = (void*)0;
    union U2 *l_295 = &g_296;
    int32_t **l_369 = &g_52;
    for (p_88 = (-4); (p_88 == 18); p_88 += 1)
    { /* block id: 48 */
        int32_t **l_106 = &g_52;
        int8_t *l_108 = &g_80;
        const int8_t *l_109 = &g_80;
        const int16_t l_115 = 0L;
        int16_t l_134 = 0x2D78L;
        const uint16_t l_198 = 0x3D9CL;
        int32_t l_211 = 0xCF4DB291L;
        union U1 ****l_275 = &l_221;
        int16_t l_293 = 0x2A48L;
        const union U0 *l_311 = &l_219;
        p_85.f1 = (-3L);
        (*l_106) = ((*p_86) , &g_53);
        if (((g_53 , (g_55.f2 != ((((l_107 <= (l_108 != l_109)) > ((0UL ^ g_42.f2) , ((int16_t)((0x0950L && l_107) == (**l_106)) >> (int16_t)10))) <= p_88) && g_55.f2))) || l_107))
        { /* block id: 51 */
            union U0 l_118 = {4294967291UL};
            int32_t *l_119 = (void*)0;
            uint16_t l_133 = 0xD66CL;
            union U1 ** const l_154 = &g_54;
            uint64_t l_182 = 0xF9BF6F6D5B129247LL;
            if (l_107)
            { /* block id: 52 */
                union U1 **l_114 = &g_54;
                int32_t l_124 = 1L;
                union U0 l_150 = {4UL};
                (*g_52) = ((uint64_t)0xE831782E4D72E8F9LL / (uint64_t)g_42.f0);
                (*l_114) = &p_85;
                if (l_115)
                { /* block id: 55 */
                    (**l_106) = (*g_52);
                }
                else
                { /* block id: 57 */
                    uint8_t l_142 = 5UL;
                    for (g_55.f2 = 1; (g_55.f2 <= 60); g_55.f2 += 1)
                    { /* block id: 60 */
                        return l_118;
                    }
                    if ((((void*)0 != l_119) && ((int32_t)((((((uint8_t)l_107 % (uint8_t)(l_124 && ((uint64_t)(g_42.f2 >= (p_87 , ((int8_t)__builtin_bswap64((((*p_86) && g_6) | ((int32_t)((uint64_t)(p_85.f2 || l_133) % (uint64_t)p_85.f0) + (int32_t)l_107))) << (int8_t)7))) / (uint64_t)l_134))) > 0x2D1E9312L) & g_55.f2) , 0xB7FB1DA9L) , (*g_52)) - (int32_t)0xD80EE50AL)))
                    { /* block id: 63 */
                        (*g_52) = ((int16_t)((int16_t)(!(((l_118 , p_85.f1) != ((uint8_t)l_142 >> (uint8_t)(((void*)0 != &p_85) && ((g_97 && (p_85.f1 & (((int16_t)((*g_54) , g_55.f2) / (int16_t)(**l_106)) || g_6))) || l_107)))) && p_85.f2)) >> (int16_t)3) % (int16_t)l_107);
                    }
                    else
                    { /* block id: 65 */
                        int32_t *l_149 = &g_53;
                        l_149 = (((uint16_t)l_124 >> (uint16_t)((*p_86) < (((int32_t)(&p_85 == &g_55) - (int32_t)((p_85.f0 == (**l_106)) || g_55.f2)) , (((((**l_106) < g_55.f2) == 0xC2309139E91ECAE5LL) , 0xCB7F01E86021B9A7LL) , l_142)))) , l_149);
                        return l_150;
                    }
                }
                (**l_106) = ((((((uint8_t)l_124 % (uint8_t)(-(int32_t)(l_154 == (((-(int8_t)(((int16_t)(**l_106) / (int16_t)(-(uint8_t)((((p_85.f1 ^ g_42.f0) ^ g_53) >= (l_107 , ((g_80 , 0x7FA2L) && g_55.f2))) != 0x6A8FC2E2BE68C9B4LL))) < 0xF9668646L)) || 1UL) , (void*)0)))) < 8UL) | 1UL) & g_80) == 0xDF971429669FAE0DLL);
            }
            else
            { /* block id: 71 */
                uint32_t l_168 = 0xBD639DC6L;
                uint32_t l_183 = 0x51B00836L;
                if (((int64_t)(p_85.f0 && ((func_91(l_163, g_164, &g_53, &g_80) , g_165) == ((*p_86) , &g_41))) / (int64_t)p_88))
                { /* block id: 72 */
                    int32_t l_181 = 0xDE492F91L;
                    if (((uint16_t)(l_168 , (!(p_88 != ((((((l_118 , (p_85.f1 == (((int8_t)(((((uint32_t)(((int32_t)(p_85.f1 > ((uint32_t)__builtin_ia32_crc32qi((p_87 <= l_168), ((4294967295UL <= (((uint8_t)(p_85.f0 , 255UL) / (uint8_t)l_180) != p_85.f2)) != g_42.f0)) - (uint32_t)g_42.f2)) - (int32_t)0x7BA7B796L) != l_118.f0) / (uint32_t)l_181) > l_181) , 0x57AF5BD10381031ELL) , (*p_86)) << (int8_t)l_182) <= g_164.f0))) ^ g_55.f2) & 0x40E7FB8437FCE878LL) , g_6) != 3UL) < l_181)))) << (uint16_t)l_183))
                    { /* block id: 73 */
                        int32_t **l_185 = (void*)0;
                        int32_t **l_186 = &g_52;
                        if (p_88)
                            break;
                        (*l_106) = (*l_106);
                        if (p_85.f0)
                            break;
                        (*l_186) = l_184;
                    }
                    else
                    { /* block id: 78 */
                        p_85.f1 = (((int32_t)g_42.f0 * (int32_t)(p_87 != p_87)) >= g_80);
                        if (p_87)
                            continue;
                        l_119 = (*l_106);
                        (*l_184) = l_181;
                    }
                }
                else
                { /* block id: 84 */
                    (*l_184) = (((int16_t)(0xC607L > (1UL == (*p_86))) >> (int16_t)p_85.f2) > 0L);
                    if (p_85.f2)
                        continue;
                }
                for (g_55.f0 = 0; (g_55.f0 > 28); g_55.f0 += 1)
                { /* block id: 90 */
                    int32_t *l_193 = &g_53;
                    (*l_106) = l_193;
                }
                for (l_168 = 0; (l_168 < 24); l_168 += 1)
                { /* block id: 95 */
                    (*l_106) = (void*)0;
                    if (p_87)
                        break;
                }
            }
            (*l_184) = ((((uint16_t)((-6L) ^ g_42.f0) / (uint16_t)6UL) , l_184) == (*l_106));
            if (l_198)
                break;
        }
        else
        { /* block id: 102 */
            union U1 ****l_199 = (void*)0;
            union U1 ***l_201 = &g_165;
            union U1 ****l_200 = &l_201;
            union U2 l_202 = {0xDF1BF41CL};
            (*g_52) = (*g_52);
            (*l_200) = &g_165;
            (***l_200) = (l_202 , (*g_165));
        }
    }
    (*l_369) = l_209;
    return (*g_232);
}


/* ------------------------------------------ */
/* 
 * reads : g_97 g_53 g_80 g_393
 * writes: g_52
 */
static union U1  func_91(int8_t * p_92, const union U0  p_93, int32_t * p_94, int8_t * p_95)
{ /* block id: 41 */
    union U1 * const l_99 = (void*)0;
    int16_t l_100 = 0x1BDAL;
    int32_t l_101 = 2L;
    int32_t **l_102 = &g_52;
    union U1 l_103 = {0x7EL};
    l_101 = (__builtin_ctzll((g_97 ^ p_93.f0)) ^ (((~(l_99 == ((((*p_94) >= ((l_100 ^ __builtin_ctzll(l_100)) | l_100)) , 0x05992E41L) , l_99))) > l_100) <= g_80));
    (*l_102) = (void*)0;
    return l_103;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_42.f0, "g_42.f0", print_hash_value);
    transparent_crc(g_42.f2, "g_42.f2", print_hash_value);
    transparent_crc(g_53, "g_53", print_hash_value);
    transparent_crc(g_55.f0, "g_55.f0", print_hash_value);
    transparent_crc(g_55.f2, "g_55.f2", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_97, "g_97", print_hash_value);
    transparent_crc(g_164.f0, "g_164.f0", print_hash_value);
    transparent_crc(g_233.f0, "g_233.f0", print_hash_value);
    transparent_crc(g_296.f0, "g_296.f0", print_hash_value);
    transparent_crc(g_393, "g_393", print_hash_value);
    transparent_crc(g_544, "g_544", print_hash_value);
    transparent_crc(g_560.f0, "g_560.f0", print_hash_value);
    transparent_crc(g_560.f2, "g_560.f2", print_hash_value);
    transparent_crc(g_579, "g_579", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 157
XXX total union variables: 23

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 44

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 2
   depth: 29, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 163

XXX times a variable address is taken: 160
XXX times a pointer is dereferenced on RHS: 86
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 15
XXX times a pointer is dereferenced on LHS: 88
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 266

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 359
   level: 2, occurrence: 58
   level: 3, occurrence: 11
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 78
XXX number of pointers point to scalars: 65
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.1
XXX average alias set size: 1.2

XXX times a non-volatile is read: 656
XXX times a non-volatile is write: 233
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 104
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 17
   depth: 2, occurrence: 14
   depth: 3, occurrence: 13
   depth: 4, occurrence: 12
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 23.1
XXX percentage an existing variable is used: 76.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

