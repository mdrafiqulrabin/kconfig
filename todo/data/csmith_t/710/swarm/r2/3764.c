/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3827921918
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
   uint8_t  f1;
   uint64_t  f2;
   uint8_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_28(void);
static int32_t * func_35(int32_t  p_36, uint16_t  p_37, float * p_38);
inline static uint32_t  func_39(int64_t  p_40, int32_t * p_41, uint8_t  p_42, struct S0  p_43, float * p_44);
static float * func_50(uint8_t  p_51, int16_t  p_52, uint16_t  p_53);
inline static int32_t  func_64(int32_t * p_65, int32_t  p_66, struct S0  p_67, uint8_t  p_68);
inline static int32_t * func_69(int32_t  p_70, float * p_71, int32_t * p_72);
static int32_t  func_73(uint16_t  p_74, float * p_75, struct S0  p_76, float * p_77, int32_t  p_78);
static float * func_80(uint16_t  p_81, uint32_t  p_82, int32_t * p_83, int32_t  p_84);
static float  func_87(int32_t * p_88, float * p_89);
static float * func_92(int32_t * p_93, uint16_t  p_94, int16_t  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = 0L;
    int32_t l_34 = 0xFBC9FA8BL;
    int32_t *l_48 = &l_29;
    int32_t l_59 = 5L;
    uint32_t l_432 = 2UL;
    for (l_29 = 0; (l_29 == 7); l_29 += 1)
    { /* block id: 39 */
        float l_33 = (-0x1.5p+1);
        float *l_32 = &l_33;
        int32_t l_47 = 0x30045702L;
        struct S0 l_49 = {255UL,2UL,0xACDD711A53FDE750LL,0xEDL};
        int32_t **l_431 = &l_48;
        (*l_32) = l_29;
        l_34 |= 3L;
    }
    return l_432;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(int32_t  p_36, uint16_t  p_37, float * p_38)
{ /* block id: 240 */
    float l_410 = 0x8.8F6ADEp+50;
    int32_t l_413 = 0xD0948568L;
    int32_t l_417 = 0x49B4F073L;
    uint8_t l_426 = 0UL;
    int32_t *l_430 = &l_413;
    int32_t **l_429 = &l_430;
    (*l_429) = &l_417;
    /* statement id: 241 */
    assert (l_430 == &l_417);
    return p_38;
    /* statement id: 242 */
    //assert (func_35_rv == &l_29);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_39(int64_t  p_40, int32_t * p_41, uint8_t  p_42, struct S0  p_43, float * p_44)
{ /* block id: 223 */
    float *l_360 = (void*)0;
    float **l_362 = &l_360;
    float ***l_361 = &l_362;
    int32_t l_363 = 0L;
    uint8_t l_364 = 0xE0L;
    int32_t *l_365 = &l_363;
    uint32_t l_375 = 0x0E85B722L;
    struct S0 l_380 = {0xC6L,0x28L,18446744073709551615UL,255UL};
    float l_382 = 0x1.0p-1;
    float *l_381 = &l_382;
    (*l_365) = (p_43.f1 ^ ((func_73(p_43.f3, l_360, p_43, l_360, (((p_40 | ((void*)0 == l_361)) <= __builtin_ia32_crc32qi(((p_43.f0 | 0xA417L) , l_363), p_43.f3)) ^ l_364)) || 0L) <= l_364));
    if ((((uint16_t)((((uint16_t)((uint16_t)(((uint16_t)(p_40 && ((((~func_73(((__builtin_ia32_crc32qi(l_375, ((__builtin_ffsll((*l_365)) != (*l_365)) , func_73(((uint16_t)func_64(&l_363, (*l_365), p_43, ((uint16_t)65533UL + (uint16_t)p_40)) >> (uint16_t)7), (**l_361), p_43, p_44, (*l_365)))) & (*l_365)) < p_43.f1), p_41, l_380, l_381, (*l_365))) & (*l_365)) != (*l_365)) > p_43.f1)) * (uint16_t)(*l_365)) || 0x519D7A940A50456ALL) * (uint16_t)(*l_365)) << (uint16_t)5) <= (*p_41)) | (*l_365)) >> (uint16_t)8) > 0x99F6L))
    { /* block id: 225 */
        return p_40;
    }
    else
    { /* block id: 227 */
        int32_t l_385 = (-2L);
        struct S0 l_388 = {5UL,0xE6L,0x4814FC1EB0C2D3A3LL,0x20L};
        int32_t *l_393 = &l_363;
        int32_t **l_409 = &l_393;
        p_41 = func_50(p_43.f0, ((uint16_t)(__builtin_popcountl(l_385) > (p_43.f3 <= (((int16_t)(__builtin_bswap64(((l_388 , &p_41) != &p_41)) >= (~p_43.f2)) + (int16_t)0L) != p_43.f1))) >> (uint16_t)p_43.f1), p_42);
        /* statement id: 228 */
        assert (p_41 == 0);
        for (l_388.f0 = 0; (l_388.f0 == 27); l_388.f0 += 1)
        { /* block id: 231 */
            uint16_t l_392 = 0x4B87L;
            int32_t **l_394 = &l_393;
            (*l_365) &= (p_43.f2 , __builtin_clzl(p_40));
            if (l_392)
                break;
            (*l_394) = (p_40 , l_393);
            (*l_393) = func_73(p_43.f2, func_50(p_43.f0, ((((*l_393) <= __builtin_bswap64((__builtin_ffs(((int16_t)0x9CA4L + (int16_t)(p_43.f0 != p_43.f3))) <= 0L))) , (*l_365)) | (**l_394)), p_43.f1), p_43, p_44, p_43.f0);
        }
        (*l_409) = func_80(((((int16_t)((uint32_t)((int16_t)(*l_365) % (int16_t)0x6EF4L) % (uint32_t)0xB9B9B5C6L) - (int16_t)((int16_t)(*l_365) >> (int16_t)8)) , (*l_365)) & p_43.f1), ((p_40 <= ((int16_t)__builtin_ffs(((*l_393) , (((uint16_t)p_42 >> (uint16_t)15) >= (*l_365)))) + (int16_t)p_43.f1)) && 0x501BL), p_41, (*l_393));
        /* statement id: 237 */
        assert (l_393 == 0);
    }
    /* facts after branching */
    assert (p_41 == 0);
    return p_43.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_50(uint8_t  p_51, int16_t  p_52, uint16_t  p_53)
{ /* block id: 42 */
    int32_t l_79 = 0x7552F0C8L;
    int32_t l_91 = 0x446F9416L;
    int32_t *l_90 = &l_91;
    struct S0 l_253 = {0x52L,1UL,0UL,0xFEL};
    int32_t l_352 = 0xAF38123DL;
    int32_t l_354 = 1L;
    int32_t *l_353 = &l_354;
    float l_356 = 0x0.6p+1;
    float *l_355 = &l_356;
    float *l_357 = (void*)0;
    (*l_353) |= ((((uint16_t)((int32_t)func_64(func_69(func_73(l_79, func_80(l_79, ((((((float)func_87(l_90, func_92(&l_91, (*l_90), ((*l_90) != p_51))) + (float)p_53) , (*l_90)) ^ p_53) == p_51) , p_51), l_90, p_52), l_253, l_90, l_79), l_90, l_90), p_53, l_253, l_253.f2) % (int32_t)p_51) - (uint16_t)p_53) & 0x5BC9L) < l_352);
    return l_357;
    /* statement id: 222 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_64(int32_t * p_65, int32_t  p_66, struct S0  p_67, uint8_t  p_68)
{ /* block id: 166 */
    float l_258 = (-0x5.3p+1);
    float *l_257 = &l_258;
    int32_t l_259 = 0x8F8D087CL;
    struct S0 l_260 = {1UL,250UL,18446744073709551615UL,0x74L};
    int32_t l_261 = 0xE55B5CE6L;
    int32_t *l_262 = (void*)0;
    float **l_315 = &l_257;
    float ***l_314 = &l_315;
    int32_t *l_333 = (void*)0;
    float *****l_350 = (void*)0;
lbl_304:
    l_261 &= (func_73(p_66, l_257, (func_73(p_68, func_80((p_68 > l_259), l_259, &l_259, (l_259 == ((0x36D6L ^ 65535UL) > 7UL))), l_260, p_65, l_260.f3) , l_260), p_65, l_260.f2) > l_259);
    if (l_260.f3)
    { /* block id: 168 */
        l_262 = &p_66;
        /* statement id: 169 */
        assert (l_262 == &p_66);
    }
    else
    { /* block id: 170 */
        uint16_t l_264 = 0x1729L;
        float *l_265 = &l_258;
        struct S0 l_266 = {255UL,0x9DL,0x80B63DD4E207E3EBLL,255UL};
        int32_t l_267 = (-1L);
        float *l_268 = &l_258;
        int32_t **l_269 = &l_262;
        int32_t ****l_306 = (void*)0;
        float ****l_325 = (void*)0;
        int32_t *l_332 = &l_267;
        l_267 ^= (-(uint64_t)func_73(l_264, l_265, l_266, p_65, func_73(l_266.f1, l_265, l_260, p_65, p_68)));
        (*l_269) = func_80(p_67.f0, ((void*)0 == &l_257), func_92(&l_267, p_66, func_73(p_67.f0, l_268, p_67, p_65, p_68)), l_264);
        /* statement id: 172 */
        assert (l_262 == &l_267);
        for (p_67.f2 = 0; (p_67.f2 != 19); p_67.f2 += 1)
        { /* block id: 175 */
            struct S0 *l_272 = &l_266;
            (*l_272) = p_67;
        }
        if ((&l_269 == (p_67.f0 , &l_269)))
        { /* block id: 178 */
            float *l_277 = &l_258;
            int32_t l_287 = 2L;
            (**l_269) |= (-4L);
            if (((uint16_t)p_68 >> (uint16_t)(((**l_269) && 0xB001798DL) , (((uint16_t)(p_65 == l_277) * (uint16_t)((**l_269) && (((int16_t)((-(int32_t)(((uint16_t)65534UL - (uint16_t)((uint16_t)((((*l_262) != ((uint16_t)(*l_262) << (uint16_t)l_287)) , 0x9BB32C21BFEE4DCCLL) | l_287) >> (uint16_t)(**l_269))) >= (*l_262))) && 0L) - (int16_t)p_68) != p_67.f2))) ^ p_67.f0))))
            { /* block id: 180 */
                return p_66;
            }
            else
            { /* block id: 182 */
                int32_t *l_288 = &l_259;
                (*l_269) = l_288;
                /* statement id: 183 */
                assert (l_262 == &l_259);
                (*l_269) = &l_261;
                /* statement id: 184 */
                assert (l_262 == &l_261);
            }
            /* facts after branching */
            assert (l_262 == &l_261);
            for (l_266.f3 = (-24); (l_266.f3 <= 37); l_266.f3 += 2)
            { /* block id: 188 */
                uint32_t l_299 = 18446744073709551606UL;
                int32_t *l_302 = &l_267;
                for (l_260.f0 = 0; (l_260.f0 != 15); l_260.f0 += 5)
                { /* block id: 191 */
                    uint64_t l_303 = 0x59E0D270257DEBD9LL;
                    if ((0x7F3DB0838230FADCLL & ((func_73(l_287, l_277, l_260, p_65, p_67.f2) | 0x93CA6D3CL) != p_67.f3)))
                    { /* block id: 192 */
                        (*l_269) = &p_66;
                        /* statement id: 193 */
                        assert (l_262 == &p_66);
                        return l_303;
                    }
                    else
                    { /* block id: 195 */
                        return p_68;
                    }
                }
                if (p_67.f0)
                    goto lbl_304;
                return p_68;
            }
        }
        else
        { /* block id: 202 */
            int64_t l_309 = 0x62A834D4BEADCF6FLL;
            int32_t *l_336 = &l_261;
            uint32_t l_338 = 4294967290UL;
            int32_t l_351 = 2L;
            (*l_262) = (~((**l_269) == p_67.f0));
            if (__builtin_popcountl((**l_269)))
            { /* block id: 204 */
                int32_t *****l_307 = (void*)0;
                int32_t *****l_308 = &l_306;
                float ****l_324 = &l_314;
                (*l_308) = l_306;
                p_65 = func_92((*l_269), p_66, l_309);
                /* statement id: 206 */
                assert (p_65 == &l_267);
                (*l_269) = func_92(func_92(&l_261, ((uint16_t)p_67.f2 + (uint16_t)0x8D7EL), ((((uint16_t)((0x9F9E24AC8738F66FLL <= p_67.f1) , ((l_314 != (((*l_262) != (((float)((float)((float)((((-0x1.Ap-1) >= p_67.f0) == p_67.f2) >= (*l_262)) + (float)p_66) * (float)p_67.f3) * (float)0x2.1p+1) <= 0x2.FD5E50p-52)) , (void*)0)) , p_66)) >> (uint16_t)9) , (*p_65)) && (**l_269))), p_66, p_66);
                /* statement id: 207 */
                assert (l_262 == &l_261);
                l_333 = func_69(((((int32_t)((*p_65) <= 0xECE4D99EL) % (int32_t)(((l_324 != l_325) , ((*l_262) , ((uint64_t)l_309 + (uint64_t)l_309))) & ((int16_t)6L >> (int16_t)9))) == ((uint32_t)(p_67.f2 & (*l_262)) + (uint32_t)0x610828A7L)) , (*p_65)), (*l_315), l_332);
            }
            else
            { /* block id: 209 */
                struct S0 l_337 = {0x7EL,254UL,0x95D468399CC1797ALL,0x3DL};
                (**l_269) &= ((l_309 && ((int16_t)func_73(p_66, func_80(l_309, p_67.f1, func_92(l_336, p_67.f2, (*l_336)), p_67.f0), l_337, p_65, l_338) << (int16_t)p_66)) ^ l_337.f3);
                for (l_337.f2 = 0; (l_337.f2 >= 49); l_337.f2 += 1)
                { /* block id: 213 */
                    int32_t l_341 = (-3L);
                    return l_341;
                }
            }
            /* facts after branching */
            //assert (p_65 == 0 || p_65 == &l_267 || p_65 == &l_363);
            assert (l_262 == &l_267 || l_262 == &l_261);
            l_351 |= ((int64_t)((int16_t)((*l_332) | p_66) >> (int16_t)3) + (int64_t)func_73((*l_332), l_336, l_266, l_336, (((((((*l_336) , ((*l_262) != ((uint32_t)((uint64_t)0x4D8598E06BF6E393LL % (uint64_t)p_68) % (uint32_t)(*l_336)))) && (*l_336)) >= 4L) , l_350) != (void*)0) || (*l_336))));
        }
        /* facts after branching */
        //assert (p_65 == 0 || p_65 == &l_267 || p_65 == &l_363);
        assert (l_262 == &l_267 || l_262 == &l_261);
    }
    /* facts after branching */
    //assert (p_65 == 0 || p_65 == dangling || p_65 == &l_363);
    //assert (l_262 == dangling || l_262 == &l_261 || l_262 == &p_66);
    return p_67.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_69(int32_t  p_70, float * p_71, int32_t * p_72)
{ /* block id: 163 */
    int32_t *l_256 = (void*)0;
    (*p_71) = (-0x8.Cp-1);
    return l_256;
    /* statement id: 165 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_73(uint16_t  p_74, float * p_75, struct S0  p_76, float * p_77, int32_t  p_78)
{ /* block id: 160 */
    int32_t l_255 = 1L;
    int32_t *l_254 = &l_255;
    l_254 = l_254;
    return p_76.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_80(uint16_t  p_81, uint32_t  p_82, int32_t * p_83, int32_t  p_84)
{ /* block id: 158 */
    return p_83;
    /* statement id: 159 */
    //assert (func_80_rv == &l_91 || func_80_rv == &l_259 || func_80_rv == &l_267 || func_80_rv == &l_261 || func_80_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_87(int32_t * p_88, float * p_89)
{ /* block id: 148 */
    int32_t l_232 = (-1L);
    struct S0 l_242 = {252UL,255UL,0x2AE1B054B7D986BFLL,6UL};
    int32_t **l_243 = (void*)0;
    int32_t l_244 = 0xEB5DC200L;
    float l_250 = 0x0.Dp+1;
    float *l_249 = &l_250;
    float **l_248 = &l_249;
    float ***l_247 = &l_248;
    int32_t l_251 = (-2L);
    struct S0 *l_252 = &l_242;
    for (l_232 = 0; (l_232 >= (-24)); l_232 -= 8)
    { /* block id: 151 */
        int32_t l_237 = 3L;
        (*p_89) = ((float)(l_237 >= ((l_232 < ((*p_89) < (l_232 != (*p_89)))) > (((((int32_t)((uint32_t)(l_237 , (&p_88 == (l_242 , l_243))) % (uint32_t)l_244) % (int32_t)l_237) < 0x785EL) , l_237) , 0x1.Ep+1))) + (float)(*p_89));
    }
    (*p_89) = ((0x8.097126p+36 != (*p_89)) == (*p_89));
    (*p_88) |= 0x14E8DBFCL;
    (*l_252) = (((float)((((*p_89) >= (*p_89)) >= 0x0.9F214Ep+94) != (__builtin_clzl((l_242.f2 >= ((void*)0 != l_247))) == ((void*)0 != p_89))) * (float)l_251) , l_242);
    return (*p_89);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_92(int32_t * p_93, uint16_t  p_94, int16_t  p_95)
{ /* block id: 43 */
    int16_t l_108 = 8L;
    int32_t l_129 = (-8L);
    int32_t *l_128 = &l_129;
    int32_t **l_127 = &l_128;
    float l_140 = 0xA.C104D5p-16;
    float *l_139 = &l_140;
    float **l_138 = &l_139;
    struct S0 l_175 = {1UL,0UL,0UL,0xDAL};
    struct S0 *l_174 = &l_175;
    float ***l_190 = &l_138;
    float ****l_189 = &l_190;
    int32_t ***l_198 = (void*)0;
    int32_t ****l_197 = &l_198;
    int32_t *l_230 = &l_129;
    for (p_94 = 0; (p_94 > 34); p_94 += 1)
    { /* block id: 46 */
        int32_t l_103 = 0L;
        int32_t l_110 = (-1L);
        int32_t *l_109 = &l_110;
        int32_t l_160 = 0x06A380BAL;
        struct S0 l_173 = {0x6FL,0xACL,0xDF8BE3DAACA8A929LL,246UL};
        struct S0 *l_172 = &l_173;
        uint32_t l_204 = 4294967295UL;
    }
    (*l_127) = ((!p_95) , p_93);
    /* statement id: 145 */
    //assert (l_128 == &l_91 || l_128 == &l_267 || l_128 == &l_261);
    (*p_93) ^= 1L;
    return p_93;
    /* statement id: 147 */
    //assert (func_92_rv == &l_91 || func_92_rv == &l_267 || func_92_rv == &l_261);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 97
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 32, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 93

XXX times a variable address is taken: 85
XXX times a pointer is dereferenced on RHS: 105
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 11
   depth: 3, occurrence: 11
XXX times a pointer is dereferenced on LHS: 48
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 214

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 243
   level: 2, occurrence: 38
   level: 3, occurrence: 27
   level: 4, occurrence: 4
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 34
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 30.1
XXX average alias set size: 1.44

XXX times a non-volatile is read: 591
XXX times a non-volatile is write: 134
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 66
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 12
   depth: 2, occurrence: 11
   depth: 3, occurrence: 12
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 19.4
XXX percentage an existing variable is used: 80.6
********************* end of statistics **********************/

