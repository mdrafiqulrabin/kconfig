/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1789185468
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   signed f1 : 25;
   unsigned f2 : 9;
   signed f3 : 7;
   unsigned f4 : 16;
};

struct S1 {
   int32_t  f0;
   int32_t  f1;
   uint64_t  f2;
   uint32_t  f3;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   int64_t  f0;
   uint64_t  f1;
   struct S0  f2;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S3 {
   uint32_t  f0;
   int16_t  f1;
   int64_t  f2;
   int16_t  f3;
   int64_t  f4;
   int64_t  f5;
};
#pragma pack(pop)

struct S4 {
   unsigned f0 : 28;
   signed f1 : 31;
   signed f2 : 11;
   signed f3 : 20;
   unsigned f4 : 19;
   unsigned f5 : 11;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_32(void);
static struct S3  func_33(struct S3  p_34, int64_t  p_35, struct S2  p_36, int32_t  p_37);
static struct S2  func_39(struct S1  p_40, struct S1  p_41, uint32_t  p_42, int32_t  p_43);
static struct S1  func_44(uint32_t  p_45, uint64_t  p_46);
static uint16_t  func_47(struct S2  p_48, uint32_t  p_49, struct S0  p_50, uint64_t  p_51);
static struct S2  func_52(int16_t  p_53, uint32_t  p_54, struct S0  p_55);
static struct S1  func_63(uint64_t  p_64, uint64_t  p_65);
static uint16_t  func_67(int64_t  p_68);
static struct S0  func_69(int32_t  p_70, uint32_t  p_71);
static struct S4  func_85(struct S4  p_86, uint16_t  p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_32(void)
{ /* block id: 36 */
    struct S3 l_38 = {0xB6AC39B3L,-1L,0L,0L,0xA6F32215F8F5063FLL,0x734BD47CDD5376E3LL};
    struct S0 l_151 = {1UL,-3631,0,7,97};
    struct S1 l_152 = {0x12BC1F67L,3L,0UL,0x5AC62AC5L};
    int32_t l_154 = (-7L);
    struct S4 l_176 = {8740,-8340,-37,-531,408,27};
    int32_t l_177 = 0xA3877515L;
    struct S4 l_188 = {7285,-43902,-26,635,516,9};
    struct S2 l_191 = {5L,0x879FE9B06FFBB3F4LL,{0x01ED4495L,5105,21,8,172}};
    uint16_t l_194 = 0xF0CDL;
    uint16_t l_246 = 0xED61L;
    uint16_t l_291 = 6UL;
    l_177 ^= __builtin_bswap64(((func_33(l_38, (l_38.f2 | l_38.f1), func_39(func_44(l_38.f2, l_38.f3), (l_151 , l_152), l_152.f1, l_151.f3), l_154) , l_176) , l_176.f1));
    if (((((uint16_t)(l_176.f1 >= (((uint16_t)__builtin_popcount(((uint32_t)((int64_t)(l_38.f5 ^ l_176.f2) + (int64_t)((int16_t)(l_188 , ((int16_t)l_176.f4 * (int16_t)(func_69(((func_47(l_191, l_176.f1, func_69((func_67((l_152.f2 , ((((uint64_t)0xD4BD7B55C8FD6D36LL - (uint64_t)l_152.f3) != l_176.f1) != l_188.f1))) != l_38.f2), l_152.f0), l_191.f1) ^ l_38.f0) | l_151.f4), l_194) , 1UL))) * (int16_t)l_151.f1)) - (uint32_t)l_151.f0)) >> (uint16_t)0) > 0UL)) - (uint16_t)0xE3C0L) >= l_188.f0) && l_191.f1))
    { /* block id: 102 */
        int32_t l_197 = 0x4D639060L;
        uint32_t l_198 = 18446744073709551608UL;
        l_152.f0 &= (((int64_t)(l_197 ^ l_197) % (int64_t)(func_44(l_197, (l_198 == l_188.f3)) , ((int16_t)(__builtin_clzll(l_198) >= ((uint16_t)l_198 + (uint16_t)l_151.f2)) << (int16_t)l_38.f4))) >= l_197);
    }
    else
    { /* block id: 104 */
        int32_t l_215 = (-1L);
        int32_t l_216 = 1L;
        struct S1 l_217 = {6L,-1L,0UL,1UL};
        struct S0 l_218 = {0xB6841CB1L,-4649,21,3,0};
        for (l_38.f4 = 17; (l_38.f4 != 6); --l_38.f4)
        { /* block id: 107 */
            uint64_t l_207 = 5UL;
            if (l_188.f3)
                break;
            for (l_154 = 0; (l_154 < (-5)); --l_154)
            { /* block id: 111 */
                uint32_t l_210 = 0x86143A58L;
                l_216 |= func_67((((l_207 , ((uint16_t)l_210 + (uint16_t)((uint64_t)((uint64_t)l_215 % (uint64_t)l_152.f0) - (uint64_t)l_177))) , l_215) > l_207));
                return l_215;
            }
        }
        l_217.f1 = (l_216 == ((func_67(l_216) | (((func_47(func_39(l_152, l_217, l_217.f3, l_191.f0), l_176.f4, l_218, l_152.f0) | l_217.f0) > l_218.f4) && l_188.f5)) ^ l_176.f1));
    }
    if ((0x97B3L | (((func_47(func_52((((int16_t)l_191.f2.f2 >> (int16_t)((0x9310L | ((uint16_t)((l_194 ^ ((int16_t)l_191.f0 + (int16_t)(((0xEF5591ADL | (((uint16_t)((((int16_t)func_47(l_191, l_151.f4, l_191.f2, l_176.f3) << (int16_t)4) , l_151.f3) , l_188.f1) >> (uint16_t)l_38.f1) ^ (-1L))) && 0L) >= l_191.f2.f1))) == l_151.f3) * (uint16_t)0xF27EL)) && l_38.f1)) , l_38.f1), l_188.f3, l_151), l_151.f4, l_191.f2, l_191.f2.f1) , 0UL) >= l_151.f4) == (-1L))))
    { /* block id: 118 */
        uint16_t l_231 = 65535UL;
        struct S1 l_243 = {-1L,7L,1UL,0x673B9644L};
        int32_t l_247 = (-1L);
        struct S2 l_249 = {0x0488C37341C2686BLL,18446744073709551615UL,{0x15835E92L,-3163,6,-2,166}};
        for (l_152.f1 = (-12); (l_152.f1 > (-16)); l_152.f1 -= 1)
        { /* block id: 121 */
            return l_231;
        }
        l_243 = (((((__builtin_clzll(((l_176 , ((((uint16_t)((int16_t)((int16_t)l_152.f2 << (int16_t)((uint16_t)l_231 << (uint16_t)(((uint16_t)(0xF4F3L <= l_38.f4) * (uint16_t)(((-(uint32_t)(l_243 , l_188.f2)) && ((uint64_t)(func_39(func_44(l_243.f1, (func_85((l_191 , l_188), l_243.f1) , 0x05A8607322A489C8LL)), l_243, l_231, l_154) , 0UL) + (uint64_t)l_246)) , l_246)) == l_247))) % (int16_t)l_243.f0) >> (uint16_t)14) , l_188.f4) >= l_243.f2)) , 0x68734B30178618A0LL)) && (-10L)) < l_188.f0) != l_151.f0) == l_38.f3) , l_152);
        l_191 = (((-4L) && ((0x6DE5L || __builtin_ffs((l_38.f1 || l_243.f3))) == l_151.f4)) , func_39(((((~(l_38.f2 == (func_47(l_249, l_188.f0, l_249.f2, l_176.f5) , l_243.f0))) ^ 0xD7A9326FL) > l_38.f3) , l_152), l_243, l_176.f0, l_249.f2.f3));
        l_249.f2 = l_249.f2;
    }
    else
    { /* block id: 127 */
        uint64_t l_252 = 1UL;
        int64_t l_258 = 1L;
        struct S2 l_272 = {0xEBF6379C17E8EA87LL,1UL,{0x47910791L,-4067,8,-0,79}};
        struct S1 l_279 = {0xD1204B87L,0x05BAAB0FL,4UL,18446744073709551615UL};
        uint32_t l_290 = 18446744073709551614UL;
        int32_t l_306 = 0x6BE4726AL;
        if (((l_151 , ((((int64_t)(l_252 && func_67(l_252)) % (int64_t)l_152.f3) == 0xE6E4FB6FL) == ((int16_t)(~(((uint16_t)l_258 + (uint16_t)l_252) || 18446744073709551610UL)) + (int16_t)1UL))) & l_194))
        { /* block id: 128 */
            uint32_t l_259 = 0UL;
            struct S2 l_271 = {0L,0xB456FF982DA71379LL,{0xD5AF8A9DL,-4905,20,-7,172}};
            l_191 = func_52(l_152.f3, l_259, l_151);
            l_191.f2.f3 = ((uint32_t)((uint16_t)((uint32_t)((uint32_t)(-(int16_t)((int16_t)((-1L) < l_151.f2) % (int16_t)func_47((l_271 , l_272), ((int16_t)(((((~(l_252 == l_258)) ^ (1L <= (func_47(l_271, l_272.f2.f4, l_151, l_38.f3) | 0x2B11L))) >= l_38.f0) || l_188.f2) < 0x3277F54225877B57LL) >> (int16_t)14), l_272.f2, l_272.f2.f2))) % (uint32_t)l_272.f2.f1) + (uint32_t)l_258) - (uint16_t)l_271.f1) % (uint32_t)l_152.f3);
        }
        else
        { /* block id: 131 */
            int32_t l_278 = 0x620D2C9EL;
            for (l_258 = 0; (l_258 >= 2); l_258 += 1)
            { /* block id: 134 */
                l_272.f2.f3 = __builtin_ctz(l_278);
            }
            l_152.f1 = (((func_39(((l_278 ^ ((-3L) | l_38.f4)) , func_63(l_272.f2.f1, l_278)), l_279, l_278, l_278) , l_272.f2.f1) != l_278) , l_272.f2.f4);
        }
        l_188.f2 |= ((int16_t)l_177 >> (int16_t)4);
        l_279.f1 = (((uint16_t)(((int64_t)l_279.f2 - (int64_t)(((int64_t)(((((((int16_t)func_67(l_290) + (int16_t)(l_291 & l_279.f0)) | 0x7D4CBDD056B5D0F9LL) > l_258) & ((uint32_t)__builtin_parity(((uint16_t)((uint16_t)(((uint64_t)((uint32_t)(((uint16_t)l_188.f0 + (uint16_t)((((int16_t)(__builtin_clz(l_279.f0) , l_258) % (int16_t)l_188.f1) <= l_152.f1) == l_272.f0)) & l_194) + (uint32_t)0x2F56DB81L) % (uint64_t)l_38.f3) != l_177) % (uint16_t)l_176.f1) >> (uint16_t)l_306)) % (uint32_t)4294967292UL)) > l_176.f3) == l_306) + (int64_t)l_152.f1) <= l_272.f2.f3)) < l_272.f0) >> (uint16_t)3) & l_290);
    }
    return l_191.f2.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S3  func_33(struct S3  p_34, int64_t  p_35, struct S2  p_36, int32_t  p_37)
{ /* block id: 97 */
    int32_t l_161 = 0L;
    uint16_t l_164 = 0x4D68L;
    struct S1 l_174 = {0L,0L,0x81DAF6D627CF3F8CLL,0UL};
    struct S3 l_175 = {18446744073709551615UL,0x6B50L,0xFF6AF44C75526357LL,0xA00AL,0x914532080C0C3E40LL,0xC5C06FA9791142BFLL};
    p_36.f2.f3 = ((int32_t)(((((uint16_t)(((int16_t)(l_161 | __builtin_popcount(p_36.f2.f2)) + (int16_t)(p_34.f0 , l_161)) & (((uint16_t)l_161 % (uint16_t)(l_161 && ((l_161 || p_36.f0) >= l_161))) != p_34.f2)) + (uint16_t)l_161) & 0x1D61AFEE84A3AFCELL) & (-6L)) != l_161) - (int32_t)l_164);
    p_36.f2.f1 &= (((uint16_t)((uint16_t)(!((int32_t)p_34.f3 + (int32_t)(((p_36.f2.f0 != (l_161 ^ l_161)) , l_161) == ((uint64_t)l_164 % (uint64_t)((l_164 & (l_164 & (l_174 , l_174.f1))) | p_34.f3))))) + (uint16_t)1L) >> (uint16_t)7) > 0x8037F3D1E7D8B5B9LL);
    return l_175;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_39(struct S1  p_40, struct S1  p_41, uint32_t  p_42, int32_t  p_43)
{ /* block id: 93 */
    struct S2 l_153 = {0x6D075B9A50AF277ELL,0x723FDEEFCC7DE1C9LL,{1UL,4188,2,2,145}};
    p_41.f0 = (-3L);
    l_153.f2.f3 = (l_153 , l_153.f1);
    return l_153;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_44(uint32_t  p_45, uint64_t  p_46)
{ /* block id: 37 */
    uint16_t l_62 = 1UL;
    uint32_t l_66 = 2UL;
    struct S4 l_104 = {9434,-29835,-32,-136,234,32};
    struct S1 l_119 = {0x0A64D15AL,0xFB5E83B3L,0x4D8F4AAFBA0E2E69LL,4UL};
    struct S0 l_120 = {0UL,3894,14,-1,92};
    int32_t l_127 = 0x8BB2A2B2L;
    struct S2 l_130 = {0x15FCE81A1E77F117LL,0x23E6EA00FD19F2AALL,{1UL,728,3,1,28}};
    int32_t l_143 = (-10L);
    struct S0 l_144 = {0xCADDED1BL,-2162,15,10,116};
    struct S1 l_150 = {6L,-1L,1UL,0x9ADF89C9L};
    l_119.f0 = (func_47(func_52(((uint64_t)((int16_t)((int32_t)l_62 % (int32_t)((func_63(((l_66 == (-4L)) & func_67(p_46)), (l_62 | (l_66 == (l_104 , ((uint16_t)l_104.f5 << (uint16_t)p_45))))) , l_119) , l_119.f2)) * (int16_t)l_104.f4) % (uint64_t)0xACD4B1B73CF63262LL), p_45, l_120), l_127, l_120, l_104.f4) <= p_45);
    l_130.f2.f3 = ((~((((func_67((l_104 , (l_130 , ((int64_t)(0xC7B6L && __builtin_clzl(((int16_t)(p_46 >= l_62) * (int16_t)((uint64_t)__builtin_ctzll(l_120.f1) + (uint64_t)p_45)))) % (int64_t)p_45)))) & (-1L)) && 1UL) >= l_119.f0) || 0xCE94049F96D3B482LL)) & p_46);
    l_120.f3 = (((int16_t)(((__builtin_ctzll(p_45) >= ((int16_t)(l_127 >= 0x6972L) + (int16_t)((uint32_t)4294967295UL + (uint32_t)(l_120 , p_46)))) , (func_52(l_143, l_119.f0, l_144) , p_45)) <= p_45) % (int16_t)(-9L)) <= 0UL);
    for (l_119.f1 = 0; (l_119.f1 >= (-9)); --l_119.f1)
    { /* block id: 85 */
        struct S1 l_149 = {0x2EC71B30L,-1L,0x32E42D4C9FC464EALL,4UL};
        for (p_45 = 0; (p_45 > 16); p_45 += 1)
        { /* block id: 88 */
            l_150 = l_149;
        }
    }
    return l_119;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_47(struct S2  p_48, uint32_t  p_49, struct S0  p_50, uint64_t  p_51)
{ /* block id: 77 */
    int32_t l_128 = 0x8C88DF48L;
    p_50.f3 |= l_128;
    return l_128;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_52(int16_t  p_53, uint32_t  p_54, struct S0  p_55)
{ /* block id: 68 */
    struct S4 l_123 = {14308,-11704,35,-171,145,37};
    int32_t l_124 = (-1L);
    struct S1 l_125 = {8L,1L,0x7B1BE5FB79008C5DLL,0UL};
    struct S2 l_126 = {1L,0xB1D141200A2DC193LL,{0xFA8CC7AAL,-5702,9,-3,190}};
    for (p_54 = (-3); (p_54 <= 35); p_54 += 1)
    { /* block id: 71 */
        if (p_55.f1)
            break;
    }
    l_123 = func_85(l_123, l_124);
    l_125 = func_63(l_124, p_55.f0);
    return l_126;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_63(uint64_t  p_64, uint64_t  p_65)
{ /* block id: 53 */
    int16_t l_112 = 1L;
    struct S1 l_118 = {0x995485A9L,9L,1UL,18446744073709551612UL};
    for (p_64 = 0; (p_64 < 32); p_64 += 3)
    { /* block id: 56 */
        int64_t l_109 = 0xA91788BD6C54523DLL;
        int32_t l_111 = 1L;
        struct S3 l_116 = {0xA4CFDDBEL,0x0E35L,1L,0xFDCAL,0x63BEFA01E2AC5FADLL,0x94C902CEC10F2CAELL};
        struct S3 l_117 = {0x28D9ABBAL,0L,-5L,0L,0L,-1L};
        l_109 = p_64;
        l_111 ^= (~(p_65 && (-1L)));
        if (l_112)
            continue;
        for (l_109 = 0; (l_109 > 8); l_109 += 3)
        { /* block id: 62 */
            int32_t l_115 = 8L;
            l_115 = (l_111 >= (l_111 < p_65));
            l_117 = l_116;
        }
    }
    return l_118;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_67(int64_t  p_68)
{ /* block id: 38 */
    uint32_t l_72 = 0UL;
    struct S4 l_88 = {16378,-36703,5,271,687,21};
    l_88.f1 = (func_69((((p_68 <= l_72) , l_72) ^ l_72), (((uint16_t)(((((int16_t)((uint16_t)0xC278L << (uint16_t)15) * (int16_t)((uint16_t)(l_72 == 0x319870F1L) << (uint16_t)5)) < (((int16_t)(((int16_t)(func_85(l_88, (~((((((1UL | l_88.f0) >= p_68) | l_88.f4) != p_68) ^ l_88.f4) , l_88.f1))) , l_88.f3) + (int16_t)l_88.f2) ^ p_68) - (int16_t)p_68) & 0x1EC4L)) == (-7L)) && l_88.f1) * (uint16_t)0xD1FCL) >= (-6L))) , l_72);
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_69(int32_t  p_70, uint32_t  p_71)
{ /* block id: 48 */
    int16_t l_101 = 0x4C55L;
    int32_t l_102 = 0xFC1DD83CL;
    struct S0 l_103 = {0x311281BCL,799,1,2,124};
    l_102 = l_101;
    return l_103;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S4  func_85(struct S4  p_86, uint16_t  p_87)
{ /* block id: 39 */
    uint32_t l_90 = 0xBAB3D6DBL;
    int32_t l_99 = 0x7D808B43L;
    struct S4 l_100 = {1749,-19890,-31,-781,190,9};
    if (l_90)
    { /* block id: 40 */
        uint16_t l_91 = 0UL;
        struct S2 l_92 = {0x32190EF9F67763B3LL,18446744073709551615UL,{0x68BD1E8AL,398,7,-10,124}};
        p_86.f3 = l_91;
        l_92 = l_92;
    }
    else
    { /* block id: 43 */
        uint32_t l_95 = 7UL;
        l_95 = ((int16_t)l_90 >> (int16_t)15);
        l_99 = (-(uint16_t)((uint16_t)((l_90 | 0x13F9L) < __builtin_parity(l_90)) >> (uint16_t)8));
    }
    return l_100;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 50
   depth: 1, occurrence: 25
   depth: 2, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 19
XXX full-bitfields structs in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 64

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 29, occurrence: 2
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 322
XXX times a non-volatile is write: 43
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 62
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 20
   depth: 2, occurrence: 10
   depth: 3, occurrence: 3

XXX percentage a fresh-made variable is used: 23.9
XXX percentage an existing variable is used: 76.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

