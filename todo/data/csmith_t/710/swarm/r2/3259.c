/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3755862320
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   float  f0;
   uint16_t  f1;
   uint16_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 0x13638ECF;
static struct S0 g_39 = {0x0.C3997Bp-5,1U,0U};
static int32_t g_46 = 0xB4D258D0;
static int32_t *g_76 = &g_5;
static int32_t **g_75 = &g_76;
static float **g_101 = (void*)0;
static uint32_t g_109 = 0x78636BC8;
static uint32_t g_123 = 0xB2A14D58;
static uint32_t g_171 = 1U;
static uint32_t g_173 = 0x33A66A3B;
static int16_t g_177 = 0;
static int16_t g_181 = 0xC679;
static struct S0 g_188 = {0x0.1p+1,0x02E8,0xBDD0};
static struct S0 *g_187 = &g_188;
static uint32_t g_214 = 0xA3426969;
static float g_244 = 0x8.C60422p-44;
static struct S0 g_305 = {0x8.637BB3p+90,65535U,0xFA7B};
static uint16_t ***g_309 = (void*)0;
static uint32_t *g_320 = &g_173;
static uint32_t **g_319 = &g_320;
static uint32_t ***g_318 = &g_319;
static uint16_t *g_323 = &g_305.f1;
static uint16_t **g_322 = &g_323;
static uint8_t g_351 = 255U;
static uint8_t g_353 = 0U;
static struct S0 g_354 = {0x3.6p-1,0xBE1C,0x9C19};
static uint64_t g_415 = 0x7F5B296C2EF98C27LL;
static int32_t ****g_442 = (void*)0;
static int32_t *****g_441 = &g_442;


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_25(void);
static int32_t  func_26(struct S0  p_27, int32_t  p_28, uint32_t  p_29, uint8_t  p_30, struct S0  p_31);
static struct S0  func_32(uint8_t  p_33, struct S0  p_34, uint16_t  p_35, uint8_t  p_36);
inline static int32_t * func_40(uint32_t  p_41, int32_t * p_42);
inline static int32_t * func_43(int16_t  p_44);
inline static int16_t  func_58(int32_t  p_59, float * p_60, struct S0  p_61, float * p_62);
inline static struct S0  func_64(int32_t  p_65, int32_t ** p_66);
static float ** func_84(int32_t  p_85, int32_t ** p_86, float * p_87);
inline static struct S0  func_103(uint32_t  p_104, uint8_t  p_105, uint8_t  p_106, int32_t ** p_107);
static uint8_t  func_112(float * p_113, int32_t ** p_114);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_39 g_5 g_46 g_75 g_76 g_101 g_109 g_123 g_187 g_188 g_173 g_177 g_244 g_171 g_214 g_305 g_309 g_318 g_322 g_354 g_323 g_319 g_320 g_415 g_441
 * writes: g_46 g_39.f0 g_5 g_39.f2 g_75 g_109 g_123 g_76 g_171 g_173 g_177 g_181 g_187 g_188 g_214 g_244 g_318 g_305.f0 g_39.f1 g_351 g_353 g_39 g_305.f1 g_309 g_354.f1 g_305 g_415
 */
inline static struct S0  func_25(void)
{ /* block id: 36 */
    float l_37 = (-0x1.Cp+1);
    int32_t l_38 = 2;
    struct S0 *l_304 = &g_188;
    int32_t l_312 = 0xDA774B31;
    int16_t *l_329 = &g_181;
    int32_t ***l_342 = &g_75;
    uint16_t ***l_374 = &g_322;
    int32_t **l_378 = &g_76;
    float *l_379 = &g_305.f0;
    float l_380 = 0x7.B8A31Fp+43;
    uint16_t l_381 = 0x935A;
    int32_t l_385 = (-10);
    uint8_t l_418 = 0xB3;
    uint32_t l_419 = 0x1829D1AC;
    uint32_t l_423 = 4294967290U;
    uint64_t ***l_444 = (void*)0;
    uint64_t *l_447 = &g_415;
    uint64_t **l_446 = &l_447;
    uint64_t ***l_445 = &l_446;
    uint64_t **l_449 = &l_447;
    uint64_t ***l_448 = &l_449;
    struct S0 l_450 = {-0x2.Cp+1,65531U,0x8144};
    if (func_26(((*l_304) = func_32(l_38, g_39, g_39.f2, g_39.f1)), l_38, g_39.f1, l_38, g_305))
    { /* block id: 239 */
        float *l_326 = &g_305.f0;
        int16_t *l_333 = &g_177;
        int32_t *l_355 = &g_46;
        if (l_312)
        { /* block id: 240 */
            int32_t **l_313 = &g_76;
            int32_t *l_315 = &l_38;
            int32_t **l_314 = &l_315;
            (*l_314) = ((*l_313) = &g_46);
            /* statement id: 242 */
            assert (g_76 == &g_46);
            assert (l_315 == &g_46);
        }
        else
        { /* block id: 243 */
            uint16_t ***l_341 = &g_322;
            int32_t l_345 = 0x4BA9F67F;
            int16_t l_348 = 0x54A1;
            for (g_214 = 0; (g_214 < 19); ++g_214)
            { /* block id: 246 */
                uint32_t ****l_321 = &g_318;
                int32_t *l_328 = &g_5;
                (*l_321) = g_318;
                if ((g_322 != (void*)0))
                { /* block id: 248 */
                    int32_t **l_327 = &g_76;
                    l_328 = func_43((safe_div_func_int16_t_s_s(func_112(l_326, l_327), 4U)));
                    /* statement id: 249 */
                    assert (l_328 == &g_46);
                }
                else
                { /* block id: 250 */
                    int16_t **l_330 = &l_329;
                    int16_t *l_332 = &g_181;
                    int16_t **l_331 = &l_332;
                    g_76 = func_43(g_39.f1);
                    /* statement id: 251 */
                    assert (g_76 == &g_46);
                    (*l_326) = (((*l_331) = ((*l_330) = l_329)) == l_333);
                    for (g_39.f1 = 0; (g_39.f1 > 5); g_39.f1 = safe_add_func_uint16_t_u_u(g_39.f1, 1))
                    { /* block id: 257 */
                        int32_t l_336 = 0x5E133C69;
                        if (l_336)
                            break;
                        (*l_304) = (*g_187);
                    }
                }
                /* facts after branching */
                assert (l_328 == &g_5 || l_328 == &g_46);
                for (g_109 = 3; (g_109 != 52); ++g_109)
                { /* block id: 264 */
                    uint32_t l_349 = 1U;
                    for (g_173 = 0; (g_173 == 28); g_173 = safe_add_func_int16_t_s_s(g_173, 4))
                    { /* block id: 267 */
                        int32_t ****l_343 = (void*)0;
                        int32_t ****l_344 = &l_342;
                        uint8_t *l_350 = &g_351;
                        uint8_t *l_352 = &g_353;
                        g_76 = l_326;
                        /* statement id: 268 */
                        assert (g_76 == &g_305.f0);
                        l_355 = func_43(((l_341 == &g_322) > func_26((*g_187), ((((*l_344) = l_342) == &g_75) ^ 1U), l_345, ((*l_352) = ((*l_350) = (((safe_lshift_func_int16_t_s_u(g_173, 8)) & (l_348 , 0xC21EBF77)) <= l_349))), g_354)));
                        /* statement id: 272 */
                        assert (g_76 == &g_5);
                    }
                    for (g_171 = 0; (g_171 == 2); g_171 = safe_add_func_int32_t_s_s(g_171, 8))
                    { /* block id: 276 */
                        (*l_326) = l_349;
                        (*g_187) = (*g_187);
                    }
                    for (l_38 = 0; (l_38 <= 17); ++l_38)
                    { /* block id: 282 */
                        (*l_355) = (*g_76);
                    }
                }
                (*g_187) = (*g_187);
            }
            /* facts after for loop */
            assert (g_76 == &g_5 || g_76 == &g_46);
        }
        /* facts after branching */
        assert (g_76 == &g_5 || g_76 == &g_46);
    }
    else
    { /* block id: 289 */
        struct S0 *l_360 = &g_305;
        struct S0 **l_361 = &l_304;
        int32_t l_370 = (-1);
        uint16_t ***l_375 = (void*)0;
        (*l_361) = l_360;
        /* statement id: 290 */
        assert (l_304 == &g_305);
        if ((*g_76))
        { /* block id: 291 */
            uint16_t **l_364 = &g_323;
            int32_t l_373 = 0xA6B154AB;
            uint16_t ****l_376 = &g_309;
            for (g_305.f1 = (-30); (g_305.f1 < 48); g_305.f1 = safe_add_func_uint16_t_u_u(g_305.f1, 2))
            { /* block id: 294 */
                uint16_t ***l_365 = &l_364;
                (*g_187) = (*g_187);
                (*l_365) = l_364;
                (*g_76) = (safe_div_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(l_370, g_46)), l_370));
            }
            (*g_76) = (((__builtin_popcount((safe_rshift_func_uint16_t_u_u(0x8A65, l_373))) , l_374) == ((*l_376) = l_375)) < (safe_unary_minus_func_int32_t_s((*g_76))));
            g_76 = &l_373;
            /* statement id: 301 */
            assert (g_76 == &l_373);
            l_373 = (g_188.f0 = __builtin_parity(l_370));
        }
        else
        { /* block id: 304 */
            return (*g_187);
        }
        /* facts after branching */
        //assert (g_76 == dangling);
    }
    /* facts after branching */
    //assert (g_76 == dangling || g_76 == &g_5 || g_76 == &g_46);
    assert (g_75 == &g_76 || g_75 == 0);
    assert (g_187 == &g_39 || g_187 == &g_188);
    assert (l_304 == &g_305 || l_304 == &g_188);
    if (((**g_322) == l_381))
    { /* block id: 309 */
        uint32_t l_382 = 0xE9C32DDD;
        float *l_386 = &g_244;
        int32_t l_389 = 0x449F4720;
        struct S0 l_390 = {-0x3.9p-1,0U,9U};
        uint32_t l_391 = 0x0A0DB183;
        if (((l_382 <= (safe_add_func_int16_t_s_s((l_382 ^ ((l_385 , ((g_46 && l_382) , (g_305.f1 , ((func_112(l_386, (((((safe_add_func_int32_t_s_s((l_389 = l_382), (((func_26((g_188.f2 , (*g_187)), g_188.f1, g_214, g_305.f2, l_390) || l_382) == (***g_318)) , (***g_318)))) , l_389) | 0xC929) != l_390.f2) , &g_76)) | l_391) & l_391)))) < 0x4C05448F)), 0xCC2C))) == 0x158747C4))
        { /* block id: 311 */
            (*g_187) = l_390;
            return (*g_187);
        }
        else
        { /* block id: 314 */
            int32_t l_400 = 3;
            int32_t l_404 = 0x634BA4E0;
            uint32_t *l_408 = &g_214;
            struct S0 l_413 = {-0x1.0p+1,0xB761,9U};
            (*g_187) = (*g_187);
            for (g_354.f1 = 0; (g_354.f1 > 42); g_354.f1 = safe_add_func_int16_t_s_s(g_354.f1, 3))
            { /* block id: 318 */
                int16_t l_394 = 0x4C3F;
                uint32_t *l_395 = &l_391;
                uint32_t *l_403 = (void*)0;
                if (l_394)
                    break;
                (*g_76) = (((((((***g_318) = (*g_320)) > ((void*)0 != l_395)) != (l_400 = (((((safe_lshift_func_uint16_t_u_s(((**g_322) | ((((**l_378) <= l_391) & (l_389 = (safe_add_func_int32_t_s_s(((l_400 , g_188.f2) <= (safe_add_func_int16_t_s_s(0x2ADB, 2))), 8)))) >= 65535U)), (**l_378))) , l_394) == 1U) , (*g_76)) > l_382))) & l_404) || (**l_378)) , (*g_76));
                return (*g_187);
            }
            if (((**l_378) <= ((((***g_318) = (***g_318)) || (***g_318)) < ((((**g_322) && (safe_sub_func_int32_t_s_s((*g_76), ((*l_408) = (safe_unary_minus_func_uint16_t_u((((l_390.f2 , &g_187) != &g_187) , (**l_378)))))))) || (**l_378)) > (**g_322)))))
            { /* block id: 328 */
                for (l_312 = 23; (l_312 == (-11)); l_312 = safe_sub_func_int32_t_s_s(l_312, 5))
                { /* block id: 331 */
                    (*l_378) = func_43(g_305.f2);
                    /* statement id: 332 */
                    assert (g_76 == &g_46);
                }
                (*l_378) = &g_5;
                /* statement id: 334 */
                assert (g_76 == &g_5);
                (*l_304) = (*g_187);
            }
            else
            { /* block id: 336 */
                int32_t **l_411 = (void*)0;
                struct S0 l_412 = {0x2.A6224Bp+78,0U,0xC98F};
                uint64_t *l_414 = &g_415;
                (*l_378) = func_40(__builtin_popcountll(((*l_414) = (func_26(((*g_187) = l_412), g_173, __builtin_parityl(l_390.f2), ((((*l_386) = (((*l_379) = 0xA.1F6C4Fp+57) <= l_412.f1)) == 0x2.Dp+1) , 0U), l_413) > (**g_322)))), &g_5);
                /* statement id: 342 */
                assert (g_76 == &g_5);
            }
            /* facts after branching */
            assert (g_76 == &g_5);
        }
        /* facts after branching */
        assert (g_76 == &g_5);
    }
    else
    { /* block id: 345 */
        float l_416 = 0xA.C397C8p+90;
        struct S0 l_417 = {0x0.13D3AFp-56,0x8445,0U};
        uint32_t *l_420 = &g_109;
        int32_t *l_421 = &g_5;
        float l_425 = 0xE.8C7653p-80;
        int32_t *l_443 = &g_46;
        (*l_378) = ((((***g_318) , l_416) <= ((l_417 , g_109) < (((l_418 <= (l_419 < (__builtin_parityl(g_188.f1) , (l_420 == (void*)0)))) <= g_415) >= g_305.f0))) , l_420);
        /* statement id: 346 */
        assert (g_76 == &g_109);
        if (l_417.f1)
        { /* block id: 347 */
            int32_t l_422 = 0x422A0211;
            l_421 = (void*)0;
            /* statement id: 348 */
            assert (l_421 == 0);
            (*l_378) = func_43((((((g_173 != 0x3.6F072Ep+47) , (l_422 == (((*l_329) = l_423) == (*g_323)))) >= 0x1BCADB23) & (**g_319)) || (**l_378)));
            /* statement id: 350 */
            assert (g_76 == &g_46);
            (*l_378) = (void*)0;
            /* statement id: 351 */
            assert (g_76 == 0);
        }
        else
        { /* block id: 352 */
            uint8_t l_424 = 0xD8;
            if (l_424)
            { /* block id: 353 */
                (*l_304) = (*g_187);
            }
            else
            { /* block id: 355 */
                int32_t l_430 = 0x7E1C1F87;
                uint16_t *l_437 = &l_417.f2;
                int32_t **l_438 = &l_421;
                (*l_438) = ((*l_378) = func_40(g_305.f1, func_43((safe_div_func_int32_t_s_s((0xCED9 | (*g_323)), (safe_sub_func_uint16_t_u_u(l_430, ((safe_div_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(0xFC6B86DB, (*g_320))), (safe_add_func_int32_t_s_s((*g_76), (*g_76))))) == ((*l_437) = ((**l_378) & 4294967295U))))))))));
                /* statement id: 358 */
                assert (g_76 == &g_46);
                assert (l_421 == &g_46);
                (*g_76) = (**l_438);
            }
            /* facts after branching */
            assert (g_76 == &g_46 || g_76 == &g_109);
            assert (l_421 == &g_46 || l_421 == &g_5);
            (*l_378) = l_420;
            /* statement id: 361 */
            assert (g_76 == &g_109);
        }
        /* facts after branching */
        assert (g_76 == &g_109 || g_76 == 0);
        assert (l_421 == &g_46 || l_421 == &g_5 || l_421 == 0);
        (*l_378) = l_421;
        /* statement id: 363 */
        assert (g_76 == &g_46 || g_76 == &g_5 || g_76 == 0);
        (*l_443) = ((safe_div_func_int32_t_s_s((g_441 == (((*l_420) = g_305.f2) , &g_442)), (***g_318))) , 2);
    }
    /* facts after branching */
    assert (g_76 == &g_46 || g_76 == &g_5 || g_76 == 0);
    (*l_448) = ((*l_445) = (void*)0);
    /* statement id: 368 */
    assert (l_446 == 0);
    assert (l_449 == 0);
    return l_450;
}


/* ------------------------------------------ */
/* 
 * reads : g_214 g_76 g_5 g_173 g_46 g_309 g_188.f1
 * writes: g_76 g_46
 */
static int32_t  func_26(struct S0  p_27, int32_t  p_28, uint32_t  p_29, uint8_t  p_30, struct S0  p_31)
{ /* block id: 232 */
    int32_t *l_306 = &g_46;
    int32_t **l_307 = (void*)0;
    int32_t **l_308 = &g_76;
    uint16_t **l_311 = (void*)0;
    uint16_t ***l_310 = &l_311;
    l_306 = ((*l_308) = l_306);
    /* statement id: 234 */
    assert (g_76 == &g_46);
    (*l_308) = &g_5;
    /* statement id: 235 */
    assert (g_76 == &g_5);
    (*l_308) = func_40((g_214 != (((**l_308) , (((*l_306) = (g_173 > g_46)) , g_309)) != (g_188.f1 , l_310))), (*l_308));
    return (*l_306);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_39.f1 g_46 g_75 g_76 g_39.f2 g_101 g_109 g_123 g_187 g_188 g_173 g_177 g_244 g_39.f0 g_171 g_214 g_39
 * writes: g_46 g_39.f0 g_5 g_39.f2 g_75 g_109 g_123 g_76 g_171 g_173 g_177 g_181 g_187 g_188 g_214 g_244
 */
static struct S0  func_32(uint8_t  p_33, struct S0  p_34, uint16_t  p_35, uint8_t  p_36)
{ /* block id: 37 */
    int32_t l_51 = 0x21EBC5F9;
    float *l_243 = &g_244;
    int32_t l_301 = 0x77AC5F61;
    if (p_34.f1)
    { /* block id: 38 */
        uint8_t l_45 = 255U;
        int32_t *l_50 = &g_5;
        int32_t **l_49 = &l_50;
        (*l_49) = func_40(g_5, func_43(l_45));
        /* statement id: 45 */
        assert (l_50 == &g_46);
    }
    else
    { /* block id: 46 */
        int16_t l_52 = 0;
        int32_t l_302 = 0x0DE8F57C;
        struct S0 l_303 = {0x7.7p-1,0x83F1,0U};
        if (l_51)
        { /* block id: 47 */
            int32_t *l_57 = (void*)0;
            int32_t **l_56 = &l_57;
            float *l_63 = &g_39.f0;
            uint32_t *l_292 = &g_171;
            uint32_t *l_298 = &g_173;
            int16_t *l_299 = (void*)0;
            int16_t *l_300 = &l_52;
            (*l_56) = func_43((l_52 == ((l_51 = (safe_mod_func_int32_t_s_s(((safe_unary_minus_func_uint16_t_u((((*l_56) = func_40(l_52, &g_46)) != (void*)0))) == ((func_58(g_39.f1, l_63, func_64(((safe_mod_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u(((safe_div_func_int32_t_s_s((-1), (safe_mod_func_int16_t_s_s(l_51, 0xD0AB)))) , 0xCDCBD5F5), 0x5DFEA44E)) ^ 0), p_34.f2)) ^ g_46), g_75), l_243) , g_171) ^ (-1))), 7))) >= p_36)));
            /* statement id: 216 */
            assert (l_57 == &g_46);
            assert (g_76 == &g_5 || g_76 == &g_46 || g_76 == &g_244);
            assert (g_75 == &g_76 || g_75 == 0);
            assert (g_187 == &g_39 || g_187 == &g_188);
            l_302 = ((((*l_57) = l_51) == (g_214 , ((__builtin_clzll(((((*l_292) = g_214) != (0x1E57 < ((*l_300) = (!((safe_rshift_func_int16_t_s_s((0x2DEF7D71 != (safe_lshift_func_uint16_t_u_s(0x9D19, ((((((*l_298) = 1U) && p_34.f1) >= l_51) || 0x9C28862E) ^ g_214)))), 0)) || 0xFB42))))) , g_177)) , p_34.f2) & l_301))) < l_302);
            (*l_56) = ((*g_187) , (void*)0);
            /* statement id: 222 */
            assert (l_57 == 0);
            (*l_243) = ((*l_63) = (l_302 , p_34.f2));
        }
        else
        { /* block id: 225 */
            (*g_75) = &l_302;
            /* statement id: 226 */
            assert (g_76 == &l_302);
            return l_303;
            /* statement id: 227 */
            //assert (g_76 == dangling);
        }
        /* facts after branching */
        assert (g_76 == &g_5 || g_76 == &g_46 || g_76 == &g_244);
        assert (g_75 == &g_76 || g_75 == 0);
        assert (g_187 == &g_39 || g_187 == &g_188);
    }
    /* facts after branching */
    assert (g_76 == &g_5 || g_76 == &g_46 || g_76 == &g_244);
    assert (g_75 == &g_76 || g_75 == 0);
    assert (g_187 == &g_39 || g_187 == &g_188);
    return (*g_187);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(uint32_t  p_41, int32_t * p_42)
{ /* block id: 43 */
    return p_42;
    /* statement id: 44 */
    //assert (func_40_rv == &g_46 || func_40_rv == &g_5 || func_40_rv == &g_244 || func_40_rv == &g_305.f0);
}


/* ------------------------------------------ */
/* 
 * reads : g_39.f1
 * writes: g_46 g_39.f0
 */
inline static int32_t * func_43(int16_t  p_44)
{ /* block id: 39 */
    int32_t l_47 = 5;
    float *l_48 = &g_39.f0;
    g_46 = g_39.f1;
    (*l_48) = l_47;
    return &g_46;
    /* statement id: 42 */
    //assert (func_43_rv == &g_46);
}


/* ------------------------------------------ */
/* 
 * reads : g_173 g_177 g_244 g_39.f1 g_5 g_39.f0 g_46 g_39.f2 g_188.f1 g_188.f2 g_76
 * writes: g_171 g_188.f1 g_39.f0 g_244 g_46 g_76 g_5
 */
inline static int16_t  func_58(int32_t  p_59, float * p_60, struct S0  p_61, float * p_62)
{ /* block id: 166 */
    uint8_t l_257 = 0x1A;
    int32_t l_262 = 8;
    int32_t *l_265 = (void*)0;
    for (p_61.f1 = 1; (p_61.f1 == 1); p_61.f1 = safe_add_func_int16_t_s_s(p_61.f1, 1))
    { /* block id: 169 */
        uint8_t l_252 = 0xE8;
        uint32_t *l_255 = &g_171;
        uint16_t *l_256 = &g_188.f1;
        int32_t ****l_258 = (void*)0;
        int32_t *****l_259 = &l_258;
        (*p_60) = (safe_sub_func_float_f_f(((safe_add_func_float_f_f(((g_173 != (-l_252)) > (-0x9.8p-1)), (safe_add_func_float_f_f((((*l_256) = __builtin_popcount(((0x2.033925p+41 >= (((g_177 >= (l_252 > (p_61.f2 ^ ((*l_255) = l_252)))) ^ (&g_109 != &g_109)) , (*p_62))) , g_39.f1))) , (*p_62)), l_257)))) > (*p_60)), 0x9.93934Fp-96));
        (*l_259) = (__builtin_parityl(l_252) , l_258);
    }
    l_262 = (p_61.f2 , ((*p_62) = ((((*p_62) >= __builtin_clzl(p_61.f1)) != (((*p_60) >= (0x1.F241C9p+20 == 0xE.59F809p+12)) >= (safe_div_func_float_f_f(l_257, l_257)))) >= l_257)));
    for (g_46 = 0; (g_46 != 6); g_46 = safe_add_func_uint16_t_u_u(g_46, 6))
    { /* block id: 179 */
        int32_t l_266 = (-1);
        l_265 = func_40(p_61.f1, p_62);
        /* statement id: 180 */
        assert (l_265 == &g_244);
        if (l_266)
        { /* block id: 181 */
            int32_t *l_269 = &g_46;
            int32_t **l_270 = &g_76;
            for (p_61.f2 = 0; (p_61.f2 <= 33); p_61.f2 = safe_add_func_uint32_t_u_u(p_61.f2, 1))
            { /* block id: 184 */
                (*l_265) = (-9);
                if (p_61.f2)
                    continue;
            }
            (*l_270) = func_40(g_39.f2, l_269);
            /* statement id: 188 */
            assert (g_76 == &g_46);
        }
        else
        { /* block id: 189 */
            uint32_t l_271 = 0U;
            int16_t *l_277 = &g_177;
            int16_t **l_276 = &l_277;
            (*p_60) = ((*p_60) != ((*p_62) = l_271));
            if ((p_59 > ((*l_265) = (((((safe_lshift_func_uint16_t_u_s(__builtin_parityl(g_188.f1), g_173)) > (safe_div_func_int16_t_s_s(p_61.f1, g_39.f2))) < l_266) , ((*l_276) = &g_177)) != &g_181))))
            { /* block id: 194 */
                g_76 = p_62;
                /* statement id: 195 */
                assert (g_76 == &g_244);
            }
            else
            { /* block id: 196 */
                l_266 = g_188.f2;
                for (g_171 = 0; (g_171 >= 19); g_171 = safe_add_func_int32_t_s_s(g_171, 3))
                { /* block id: 200 */
                    (*p_62) = __builtin_popcountll((safe_lshift_func_uint16_t_u_s(g_177, (l_266 < (safe_add_func_uint16_t_u_u((((safe_rshift_func_uint16_t_u_s(g_188.f1, 8)) , (p_61.f2 < ((*l_276) == (void*)0))) >= (safe_div_func_uint32_t_u_u(1U, (((*g_76) > l_271) & 0xC9878C96)))), p_59))))));
                    return p_59;
                }
                if (p_61.f1)
                    continue;
            }
        }
    }
    /* facts after for loop */
    assert (g_76 == &g_5 || g_76 == &g_46 || g_76 == &g_244);
    assert (l_265 == &g_244 || l_265 == 0);
    for (g_5 = (-12); (g_5 > (-20)); g_5 = safe_sub_func_int32_t_s_s(g_5, 1))
    { /* block id: 210 */
        int32_t l_290 = 0xAEDE11C7;
        int32_t **l_291 = &l_265;
        (*l_291) = (((*p_60) <= l_290) , func_43(l_257));
        /* statement id: 211 */
        assert (l_265 == &g_46);
        (*l_291) = (void*)0;
        /* statement id: 212 */
        assert (l_265 == 0);
    }
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_76 g_5 g_46 g_39.f2 g_101 g_39.f1 g_109 g_123 g_187 g_188
 * writes: g_5 g_39.f2 g_75 g_46 g_39.f0 g_109 g_123 g_76 g_171 g_173 g_177 g_181 g_187 g_188 g_214
 */
inline static struct S0  func_64(int32_t  p_65, int32_t ** p_66)
{ /* block id: 49 */
    struct S0 l_77 = {0x6.0E206Fp+26,5U,65527U};
    float l_92 = 0x0.5p-1;
    uint8_t l_126 = 255U;
    int32_t **l_223 = &g_76;
    struct S0 *l_233 = &g_188;
    uint16_t *l_241 = &g_188.f2;
    int32_t *l_242 = &g_5;
    if (((**p_66) = (**p_66)))
    { /* block id: 51 */
        return l_77;
    }
    else
    { /* block id: 53 */
        struct S0 l_97 = {-0x1.0p+1,1U,0x92BB};
        uint16_t l_231 = 0x90C6;
        int32_t l_236 = 0xD7A91C2E;
        for (l_77.f1 = (-7); (l_77.f1 != 53); l_77.f1 = safe_add_func_int16_t_s_s(l_77.f1, 2))
        { /* block id: 56 */
            int32_t *l_127 = &g_46;
            struct S0 l_219 = {0x6.4p-1,0xCA82,0x6642};
            struct S0 **l_232 = &g_187;
            for (l_77.f2 = (-17); (l_77.f2 <= 39); l_77.f2 = safe_add_func_uint16_t_u_u(l_77.f2, 6))
            { /* block id: 59 */
                int32_t l_98 = 0x6B31B79E;
                int32_t l_99 = 0;
                float *l_100 = &g_39.f0;
                float **l_102 = &l_100;
                float *l_228 = &l_219.f0;
                for (g_39.f2 = (-14); (g_39.f2 == 32); g_39.f2 = safe_add_func_int16_t_s_s(g_39.f2, 2))
                { /* block id: 62 */
                    int32_t ***l_94 = &g_75;
                    int32_t **l_96 = &g_76;
                    int32_t ***l_95 = &l_96;
                    uint32_t *l_108 = &g_109;
                    uint32_t *l_121 = (void*)0;
                    uint32_t *l_122 = &g_123;
                    int32_t **l_128 = (void*)0;
                    struct S0 *l_216 = &l_97;
                    l_102 = func_84((l_99 = ((safe_rshift_func_int16_t_s_u(p_65, ((p_65 && p_65) | (((__builtin_ffs((**p_66)) || (safe_sub_func_uint16_t_u_u(g_46, (safe_unary_minus_func_int16_t_s((0xF408375F && (((*l_94) = (void*)0) != ((*l_95) = p_66)))))))) , l_97) , l_98)))) || g_39.f2)), &g_76, l_100);
                    /* statement id: 68 */
                    assert (l_102 == 0);
                }
                /* facts after for loop */
                assert (l_102 == 0 || l_102 == &l_100);
                (*l_100) = ((safe_div_func_float_f_f(func_112(func_43(p_65), l_223), (safe_add_func_float_f_f(p_65, ((safe_sub_func_float_f_f(((((*l_228) = p_65) > (safe_div_func_float_f_f((l_97.f2 >= ((l_231 != (l_97.f1 > g_39.f2)) == l_97.f1)), l_97.f1))) != 0x0.Ep-1), p_65)) >= p_65))))) != l_97.f2);
            }
            /* facts after for loop */
            assert (g_187 == &g_39 || g_187 == &g_188);
            l_233 = ((*l_232) = &g_188);
            /* statement id: 157 */
            assert (g_187 == &g_188);
        }
        /* facts after for loop */
        assert (g_76 == &g_5 || g_76 == &g_46);
        assert (g_75 == &g_76 || g_75 == 0);
        (*g_187) = (*g_187);
        l_236 = (safe_div_func_int16_t_s_s((-4), p_65));
    }
    /* facts after branching */
    assert (g_76 == &g_5 || g_76 == &g_46);
    assert (g_75 == &g_76 || g_75 == 0);
    (*l_233) = (p_65 , (*g_187));
    (*l_242) = ((func_103((0x727779B4 || (**l_223)), p_65, p_65, l_223) , (!((**l_223) , (g_188.f2 && ((*l_241) = (safe_add_func_int32_t_s_s((!g_39.f1), (**p_66)))))))) || (**l_223));
    /* statement id: 164 */
    assert (g_76 == &g_46);
    assert (g_187 == &g_39 || g_187 == &g_188);
    return (*l_233);
}


/* ------------------------------------------ */
/* 
 * reads : g_101
 * writes:
 */
static float ** func_84(int32_t  p_85, int32_t ** p_86, float * p_87)
{ /* block id: 66 */
    return g_101;
    /* statement id: 67 */
    //assert (func_84_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_76 g_46 g_187 g_39 g_188 g_5 g_109 g_123
 * writes: g_76 g_46 g_39.f0 g_188 g_5 g_109 g_123 g_171 g_173 g_177 g_181 g_187 g_214
 */
inline static struct S0  func_103(uint32_t  p_104, uint8_t  p_105, uint8_t  p_106, int32_t ** p_107)
{ /* block id: 122 */
    uint16_t *l_190 = &g_188.f1;
    uint16_t **l_189 = &l_190;
    uint16_t ***l_191 = &l_189;
    int32_t *l_192 = &g_46;
    int32_t **l_193 = (void*)0;
    uint16_t l_194 = 1U;
    struct S0 l_198 = {0xE.CB47B8p-9,65535U,0xF0AF};
    (*l_191) = l_189;
    g_76 = l_192;
    /* statement id: 124 */
    assert (g_76 == &g_46);
    if ((l_194 = ((*g_76) = (*g_76))))
    { /* block id: 127 */
        g_39.f0 = (-0x10.3p-1);
    }
    else
    { /* block id: 129 */
        struct S0 *l_199 = &g_188;
        int32_t *l_200 = (void*)0;
        float **l_210 = (void*)0;
        float **l_211 = (void*)0;
        float *l_213 = &g_39.f0;
        float **l_212 = &l_213;
        int32_t **l_215 = &l_200;
        for (l_194 = 0; (l_194 > 1); l_194 = safe_add_func_uint16_t_u_u(l_194, 1))
        { /* block id: 132 */
            struct S0 l_197 = {0x7.1p-1,0x5295,8U};
            l_197 = (*g_187);
            return l_198;
        }
        (*l_199) = (*g_187);
        l_200 = &g_5;
        /* statement id: 137 */
        assert (l_200 == &g_5);
        (*l_215) = func_43((safe_sub_func_uint16_t_u_u(p_104, (~(safe_mod_func_int32_t_s_s((((safe_sub_func_int16_t_s_s(p_106, ((func_112(((*l_212) = ((safe_mod_func_int32_t_s_s((((*l_192) = (*g_76)) && 9), (*l_200))) , l_192)), p_107) | ((g_214 = 0xEAF5C805) || 0xD58858CD)) , p_106))) & 0x49C7) | p_106), 0x01976A6A))))));
        /* statement id: 141 */
        assert (l_200 == &g_46);
        assert (l_213 == &g_46);
    }
    return l_198;
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_76 g_5 g_39.f1 g_109 g_123 g_39.f2 g_305.f0 g_244
 * writes: g_5 g_109 g_123 g_46 g_76 g_39.f0 g_171 g_173 g_177 g_181 g_187 g_305.f0 g_244
 */
static uint8_t  func_112(float * p_113, int32_t ** p_114)
{ /* block id: 72 */
    uint32_t l_129 = 0xE7E4EBB7;
    int32_t *l_130 = &g_5;
    uint32_t *l_132 = &l_129;
    uint32_t **l_131 = &l_132;
    float *l_149 = &g_39.f0;
    (*l_130) = ((((*l_131) = func_40(l_129, l_130)) != (void*)0) != g_46);
    /* statement id: 74 */
    assert (l_132 == &g_5);
    for (l_129 = 0; (l_129 > 42); l_129 = safe_add_func_uint16_t_u_u(l_129, 1))
    { /* block id: 77 */
        int32_t l_141 = 0;
        int32_t l_152 = 0xB2FD71B9;
        for (g_109 = 0; (g_109 <= 13); g_109 = safe_add_func_int32_t_s_s(g_109, 9))
        { /* block id: 80 */
            float *l_150 = &g_39.f0;
            int32_t l_153 = 1;
            int32_t l_156 = 5;
            for (g_123 = 0; (g_123 < 33); g_123 = safe_add_func_uint16_t_u_u(g_123, 6))
            { /* block id: 83 */
                for (g_46 = 0; (g_46 <= (-22)); g_46 = safe_sub_func_int32_t_s_s(g_46, 1))
                { /* block id: 86 */
                    return l_141;
                }
            }
            for (g_123 = (-9); (g_123 > 7); g_123 = safe_add_func_uint32_t_u_u(g_123, 1))
            { /* block id: 92 */
                uint16_t *l_151 = (void*)0;
                int32_t l_154 = 0x6D442F44;
                uint16_t l_159 = 0x55ED;
                uint32_t l_165 = 4294967295U;
                struct S0 l_185 = {0x7.A65527p+79,1U,0U};
                if ((l_141 >= __builtin_clzll((safe_mod_func_uint16_t_u_u((l_152 = ((((*p_113) >= ((safe_rshift_func_int16_t_s_s((!(__builtin_ffs((*g_76)) < l_141)), 14)) , 0x0.F3C649p+60)) , l_149) != l_150)), (((l_153 , l_154) | 1) || (*l_130)))))))
                { /* block id: 94 */
                    int32_t **l_155 = &g_76;
                    (*p_113) = (l_141 = (*p_113));
                    (*l_155) = func_40(l_141, &g_46);
                    /* statement id: 97 */
                    assert (g_76 == &g_46);
                }
                else
                { /* block id: 98 */
                    uint32_t l_174 = 0xEDED60BA;
                    int32_t l_175 = 0x6355D27D;
                    struct S0 **l_186 = (void*)0;
                    if (l_156)
                        break;
                    if ((safe_div_func_int32_t_s_s(l_159, (*l_130))))
                    { /* block id: 100 */
                        uint32_t *l_170 = &g_171;
                        uint32_t *l_172 = &g_173;
                        int16_t *l_176 = &g_177;
                        int32_t l_178 = (-6);
                        uint16_t *l_179 = &l_159;
                        int16_t *l_180 = &g_181;
                        int32_t *l_182 = &g_46;
                        (*l_149) = ((g_39.f1 < l_152) == (*p_113));
                        (*g_76) = 0xDE520ED3;
                        (*l_182) = (safe_add_func_int16_t_s_s(((*l_180) = ((*l_176) = (~(((*l_130) = (g_5 & (safe_lshift_func_uint16_t_u_s((g_109 != l_165), 12)))) <= __builtin_bswap32(((safe_sub_func_uint32_t_u_u(g_46, (65530U > (safe_rshift_func_int16_t_s_u(g_123, (g_39.f2 , ((*l_179) = (((*l_176) = ((((*l_170) = l_156) | ((((((*l_172) = 0x11546519) != l_174) >= l_175) == l_153) > l_141)) ^ g_123)) <= l_178)))))))) , 4294967291U)))))), 1U));
                        if ((*g_76))
                            continue;
                    }
                    else
                    { /* block id: 112 */
                        struct S0 l_183 = {0xB.9E523Dp+31,0U,0x3C5D};
                        struct S0 *l_184 = (void*)0;
                        (*p_113) = 0x1.8p+1;
                        l_185 = l_183;
                    }
                    g_187 = &g_39;
                    /* statement id: 116 */
                    assert (g_187 == &g_39);
                }
            }
        }
    }
    return (*l_130);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc_bytes (&g_39.f0, sizeof(g_39.f0), "g_39.f0", print_hash_value);
    transparent_crc(g_39.f1, "g_39.f1", print_hash_value);
    transparent_crc(g_39.f2, "g_39.f2", print_hash_value);
    transparent_crc(g_46, "g_46", print_hash_value);
    transparent_crc(g_109, "g_109", print_hash_value);
    transparent_crc(g_123, "g_123", print_hash_value);
    transparent_crc(g_171, "g_171", print_hash_value);
    transparent_crc(g_173, "g_173", print_hash_value);
    transparent_crc(g_177, "g_177", print_hash_value);
    transparent_crc(g_181, "g_181", print_hash_value);
    transparent_crc_bytes (&g_188.f0, sizeof(g_188.f0), "g_188.f0", print_hash_value);
    transparent_crc(g_188.f1, "g_188.f1", print_hash_value);
    transparent_crc(g_188.f2, "g_188.f2", print_hash_value);
    transparent_crc(g_214, "g_214", print_hash_value);
    transparent_crc_bytes (&g_244, sizeof(g_244), "g_244", print_hash_value);
    transparent_crc_bytes (&g_305.f0, sizeof(g_305.f0), "g_305.f0", print_hash_value);
    transparent_crc(g_305.f1, "g_305.f1", print_hash_value);
    transparent_crc(g_305.f2, "g_305.f2", print_hash_value);
    transparent_crc(g_351, "g_351", print_hash_value);
    transparent_crc(g_353, "g_353", print_hash_value);
    transparent_crc_bytes (&g_354.f0, sizeof(g_354.f0), "g_354.f0", print_hash_value);
    transparent_crc(g_354.f1, "g_354.f1", print_hash_value);
    transparent_crc(g_354.f2, "g_354.f2", print_hash_value);
    transparent_crc(g_415, "g_415", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 108
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 154
   depth: 2, occurrence: 37
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 4
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 2
   depth: 29, occurrence: 1

XXX total number of pointers: 138

XXX times a variable address is taken: 131
XXX times a pointer is dereferenced on RHS: 86
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 23
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 118
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 2
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 355

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 487
   level: 2, occurrence: 57
   level: 3, occurrence: 30
   level: 4, occurrence: 0
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 64
XXX number of pointers point to scalars: 67
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 23.2
XXX average alias set size: 1.22

XXX times a non-volatile is read: 529
XXX times a non-volatile is write: 303
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 26
   depth: 2, occurrence: 33
   depth: 3, occurrence: 27
   depth: 4, occurrence: 17
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 22.7
XXX percentage an existing variable is used: 77.3
********************* end of statistics **********************/

