/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3598853080
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
   const volatile signed f1 : 7;
   signed f2 : 13;
   signed f3 : 5;
   unsigned : 0;
   signed f4 : 23;
   const signed f5 : 25;
};

struct S1 {
   volatile unsigned f0 : 18;
   volatile unsigned f1 : 10;
   unsigned f2 : 14;
   unsigned f3 : 20;
   unsigned f4 : 26;
   unsigned f5 : 3;
   unsigned f6 : 5;
   const signed f7 : 9;
   signed : 0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_7 = (-8);
static int32_t g_28 = (-1);
static int32_t g_31 = (-5);
static int32_t g_87 = (-1);
static int32_t *g_133 = (void*)0;
static int32_t **g_132 = &g_133;
static struct S1 g_149 = {205,2,118,678,4126,0,4,15};/* VOLATILE GLOBAL g_149 */
static struct S1 g_175 = {274,17,14,777,6103,1,2,-14};/* VOLATILE GLOBAL g_175 */
static const uint16_t g_183 = 4U;
static struct S1 g_200 = {182,15,12,838,1512,0,0,-16};/* VOLATILE GLOBAL g_200 */
static int32_t g_235 = (-4);
static volatile struct S1 g_246 = {314,10,123,746,3942,0,0,14};/* VOLATILE GLOBAL g_246 */
static volatile struct S1 *g_245 = &g_246;
static volatile struct S1 **g_244 = &g_245;
static volatile struct S0 g_269 = {4562,-2,-10,1,-1859,5288};/* VOLATILE GLOBAL g_269 */
static struct S1 g_293 = {111,2,99,900,4814,1,1,2};/* VOLATILE GLOBAL g_293 */
static struct S0 g_294 = {5058,-4,-81,-0,1961,-1910};/* VOLATILE GLOBAL g_294 */
static volatile int32_t **g_303 = (void*)0;
static volatile int32_t ***g_302 = &g_303;
static volatile int32_t ****g_301 = &g_302;
static int16_t g_311 = (-1);
static struct S0 g_381 = {3456,-0,58,-0,-259,-2922};/* VOLATILE GLOBAL g_381 */
static volatile struct S0 g_405 = {2831,7,-70,-4,1246,1841};/* VOLATILE GLOBAL g_405 */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_25(void);
static struct S1  func_39(int32_t  p_40, int8_t  p_41, int32_t  p_42, int16_t  p_43);
inline static uint16_t  func_58(int16_t  p_59, uint16_t  p_60, uint32_t  p_61, int32_t  p_62);
inline static int16_t  func_66(int32_t  p_67, int32_t  p_68, const int8_t  p_69, const int32_t  p_70, int32_t  p_71);
inline static int32_t  func_92(uint32_t  p_93, int32_t * p_94);
static int8_t  func_98(uint16_t  p_99, uint32_t  p_100, int32_t * p_101);
inline static uint32_t  func_105(uint32_t  p_106, int8_t  p_107);
inline static struct S1  func_113(int32_t ** p_114, int16_t  p_115);
static int32_t ** func_116(int32_t * p_117, int32_t ** p_118, const int32_t ** p_119, uint16_t  p_120, int32_t ** p_121);
inline static int32_t ** func_122(int32_t ** p_123, int32_t ** p_124, const int32_t * p_125, int32_t * p_126);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_28 g_31 g_132 g_133
 * writes: g_7 g_28 g_31 g_133
 */
static uint16_t  func_25(void)
{ /* block id: 36 */
    uint16_t l_63 = 0x05D0;
    int32_t *l_420 = &g_7;
    for (g_7 = 16; (g_7 > (-23)); --g_7)
    { /* block id: 39 */
        uint32_t l_90 = 0x8B12ACF1;
        for (g_28 = 0; (g_28 <= 9); g_28 = safe_add_func_int16_t_s_s(g_28, 2))
        { /* block id: 42 */
            int16_t l_37 = 0x7DDB;
            int32_t l_76 = 0x4086237D;
            int32_t l_418 = 1;
            for (g_31 = 0; (g_31 != (-6)); g_31 = safe_sub_func_int32_t_s_s(g_31, 6))
            { /* block id: 45 */
                uint32_t l_45 = 4U;
                uint32_t l_91 = 0xE07384C7;
                uint32_t l_419 = 0U;
            }
            (*g_132) = (*g_132);
        }
    }
    (*g_132) = l_420;
    /* statement id: 224 */
    assert (g_133 == &g_7);
    return (*l_420);
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_132 g_87 g_31 g_28 g_149 g_133 g_175 g_183 g_200 g_244 g_235 g_245 g_269 g_293 g_294 g_301 g_246.f2 g_311 g_246.f6 g_246.f0 g_246.f3 g_302 g_381 g_405 g_246
 * writes: g_87 g_133 g_235 g_245 g_302
 */
static struct S1  func_39(int32_t  p_40, int8_t  p_41, int32_t  p_42, int16_t  p_43)
{ /* block id: 56 */
    uint32_t l_95 = 0U;
    int32_t *l_102 = &g_31;
    int32_t *l_415 = (void*)0;
    int32_t *l_416 = (void*)0;
    int32_t *l_417 = &g_235;
    (*l_417) = func_92(func_58(l_95, (((((0x5FFF || ((&g_28 == (void*)0) & (l_95 || (1U != ((safe_add_func_uint32_t_u_u((((65528U || ((func_98(l_95, ((l_95 | l_95) || l_95), l_102) , (*l_102)) | 4294967292U)) ^ 0xC0F6DB6A) || p_41), g_31)) , 0U))))) , 1) & 65535U) ^ p_43) ^ 0x9CE0), p_40, (*l_102)), (*g_132));
    /* statement id: 214 */
    //assert (g_133 == dangling || g_133 == 0 || g_133 == &g_7);
    return (*g_245);
}


/* ------------------------------------------ */
/* 
 * reads : g_7
 * writes:
 */
inline static uint16_t  func_58(int16_t  p_59, uint16_t  p_60, uint32_t  p_61, int32_t  p_62)
{ /* block id: 54 */
    return g_7;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_31 g_28
 * writes: g_87
 */
inline static int16_t  func_66(int32_t  p_67, int32_t  p_68, const int8_t  p_69, const int32_t  p_70, int32_t  p_71)
{ /* block id: 46 */
    uint32_t l_80 = 0x8ED3351F;
    int32_t *l_86 = &g_87;
    (*l_86) = (safe_unary_minus_func_uint16_t_u((__builtin_bswap32(p_69) || (0xF24264A3 < ((safe_rshift_func_uint16_t_u_s((l_80 != g_7), l_80)) >= __builtin_bswap64((safe_rshift_func_uint16_t_u_s((+p_69), (p_70 > ((safe_lshift_func_int16_t_s_s((g_7 > g_7), 4)) ^ g_31))))))))));
    for (p_68 = (-4); (p_68 < (-24)); --p_68)
    { /* block id: 50 */
        return g_28;
    }
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_87 g_149.f4 g_149.f0 g_149.f5 g_7 g_28 g_149.f2 g_132 g_133 g_149 g_175 g_183 g_200 g_244 g_235 g_245 g_269 g_293 g_294 g_301 g_246.f2 g_311 g_246.f6 g_246.f0 g_246.f3 g_302 g_381 g_405
 * writes: g_87 g_133 g_235 g_245 g_302
 */
inline static int32_t  func_92(uint32_t  p_93, int32_t * p_94)
{ /* block id: 72 */
    int32_t **l_152 = (void*)0;
    const int32_t **l_153 = (void*)0;
    int8_t l_160 = (-7);
    uint32_t l_161 = 1U;
    uint16_t l_162 = 4U;
    int32_t ***l_163 = (void*)0;
    int8_t l_164 = (-2);
    int32_t *l_171 = &g_87;
    uint32_t l_174 = 1U;
    int16_t l_197 = (-7);
    struct S1 *l_247 = &g_200;
    int32_t l_256 = 0x2C39B06F;
    const int32_t l_312 = 1;
    l_152 = func_116(p_94, l_152, l_153, (((((safe_add_func_int16_t_s_s(((void*)0 != &g_133), g_31)) == ((safe_mod_func_uint32_t_u_u(((((safe_mod_func_int16_t_s_s(((0x7EAAE7FF & g_87) < (l_160 != 0xA6A4DFBE)), p_93)) <= l_161) || g_149.f4) | g_149.f0), l_162)) <= p_93)) > g_149.f4) , (-1)) != g_149.f5), &g_133);
    /* statement id: 73 */
    assert (l_152 == &g_133);
    (*l_171) = ((func_98((l_164 > (3U || (safe_add_func_uint16_t_u_u((((((safe_lshift_func_uint16_t_u_s(p_93, p_93)) && p_93) | ((p_93 , (void*)0) == (void*)0)) , ((safe_sub_func_int32_t_s_s(g_149.f2, p_93)) < p_93)) & g_149.f4), p_93)))), g_149.f4, (*g_132)) <= p_93) ^ g_149.f5);
    if ((p_93 != (p_93 == (safe_lshift_func_int16_t_s_s((l_174 >= ((func_105(p_93, g_149.f0) | (0x9426 == g_149.f3)) | (g_87 ^ g_31))), 3)))))
    { /* block id: 75 */
        int32_t *l_176 = &g_7;
        int32_t ***l_180 = &g_132;
        struct S1 * const l_224 = (void*)0;
        int16_t l_305 = 0x8443;
        int32_t l_310 = 0x19DD2A15;
        int32_t *l_366 = &l_256;
        int8_t l_397 = 0x9A;
        (*l_171) = (((((*g_132) != (g_175 , l_176)) <= (safe_mod_func_int16_t_s_s((!(p_93 , ((&g_132 != l_180) || (((func_58(((safe_rshift_func_int16_t_s_u(((0x5B86 < (__builtin_ffsll(p_93) , p_93)) < 65532U), g_183)) && 4294967295U), (*l_176), g_175.f3, p_93) , g_175.f6) , (void*)0) != &p_94)))), 0x87CD))) , p_93) > p_93);
        if ((safe_sub_func_uint16_t_u_u((*l_171), (__builtin_ffsl((0x7E69CC3E > ((safe_sub_func_uint16_t_u_u((p_93 ^ 8), (safe_unary_minus_func_uint32_t_u(g_149.f0)))) , ((0x7C7DC251 | g_31) || ((((safe_mod_func_uint32_t_u_u((*l_176), 0x944A3940)) == 0xEA41B15C) && (*l_176)) , g_175.f4))))) , 0x262F))))
        { /* block id: 77 */
            uint16_t l_203 = 2U;
            (*l_152) = (*l_152);
            (*l_171) = ((((safe_mod_func_uint32_t_u_u(g_183, (safe_sub_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s(g_175.f2, (l_197 & (safe_lshift_func_int16_t_s_s(0x6381, func_58((g_200 , ((*g_132) == ((g_175.f0 && ((((+(((((func_105((~(((void*)0 == &l_152) >= (-1))), g_149.f7) ^ (*l_171)) != p_93) != (*l_176)) != l_203) , 1)) == p_93) == l_203) & (-8))) , p_94))), p_93, p_93, g_149.f4)))))) && l_203), 0xA69D0D33)))) , (*g_132)) != (void*)0) >= g_175.f4);
        }
        else
        { /* block id: 80 */
            int8_t l_219 = 4;
            int16_t l_220 = 0x596C;
            uint32_t l_222 = 0x0805CE07;
            int32_t * const l_233 = &g_87;
            const uint32_t l_297 = 4294967290U;
            struct S1 *l_298 = &g_293;
            volatile int32_t ****l_304 = &g_302;
            uint16_t l_351 = 0x3B7B;
            int32_t *l_353 = (void*)0;
            for (g_87 = (-15); (g_87 > 1); g_87 = safe_add_func_uint32_t_u_u(g_87, 1))
            { /* block id: 83 */
                int32_t l_206 = 5;
                struct S1 * const l_242 = &g_149;
                const int32_t *l_250 = &g_7;
                int32_t l_257 = 0xC735A513;
                if (l_206)
                { /* block id: 84 */
                    uint32_t l_221 = 1U;
                    uint32_t l_223 = 4294967289U;
                    struct S1 **l_225 = (void*)0;
                    struct S1 **l_226 = (void*)0;
                    struct S1 *l_228 = &g_149;
                    struct S1 **l_227 = &l_228;
                    int32_t *l_234 = &g_235;
                    l_223 = __builtin_clzl(__builtin_ffsll(((((g_200.f1 >= (-1)) >= (*l_171)) , __builtin_parityl((((((0x0886 < (safe_sub_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(0xB289, (safe_add_func_uint16_t_u_u((p_93 , p_93), (safe_sub_func_uint32_t_u_u(((safe_add_func_int32_t_s_s(l_219, l_219)) < l_220), 0x6D56ED21)))))), p_93)), 65534U))) , g_200.f1) || 0) | p_93) && l_221))) ^ l_222)));
                    (*l_227) = l_224;
                    /* statement id: 86 */
                    assert (l_228 == 0);
                    (*l_234) = (safe_lshift_func_uint16_t_u_u((((p_93 & ((safe_lshift_func_uint16_t_u_u(__builtin_clz((l_233 != (**l_180))), p_93)) & (-2))) , 7) > __builtin_ctz(((p_93 | g_200.f4) <= p_93))), p_93));
                    (*l_234) = ((func_58((safe_mod_func_uint16_t_u_u(((g_149.f5 && (safe_mod_func_int16_t_s_s(p_93, 1))) && p_93), 0xB3B6)), (((safe_sub_func_uint32_t_u_u((&g_175 != l_242), ((safe_unary_minus_func_int16_t_s(((void*)0 != g_244))) >= 1U))) , (void*)0) != l_247), g_200.f0, (*l_234)) & (*l_233)) & 0xB1B5);
                }
                else
                { /* block id: 89 */
                    const int32_t **l_251 = &l_250;
                    for (l_197 = 0; (l_197 == 15); l_197++)
                    { /* block id: 92 */
                        return l_206;
                    }
                    (*l_251) = l_250;
                    return p_93;
                }
                for (l_206 = 6; (l_206 == (-8)); --l_206)
                { /* block id: 100 */
                    return g_183;
                }
                for (l_160 = 0; (l_160 < (-5)); l_160--)
                { /* block id: 105 */
                    l_256 = p_93;
                    (*g_132) = (*g_132);
                }
                l_257 = (0x2DA0 == __builtin_parityll(g_149.f4));
            }
            for (p_93 = 15; (p_93 <= 39); p_93 = safe_add_func_uint16_t_u_u(p_93, 4))
            { /* block id: 113 */
                int32_t l_266 = 0x5ADBA935;
                if ((g_200.f3 , (safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((g_200.f1 ^ p_93), 6)), ((safe_rshift_func_int16_t_s_u(__builtin_parityl(g_28), g_149.f4)) >= (p_93 & ((*l_176) > 0xFE4C1CF0)))))))
                { /* block id: 114 */
                    uint32_t l_268 = 0U;
                    const int32_t ***l_270 = &l_153;
                    if (l_266)
                    { /* block id: 115 */
                        l_268 = (+(g_149.f7 <= p_93));
                        (*g_132) = p_94;
                        /* statement id: 117 */
                        //assert (g_133 == 0 || g_133 == &l_418);
                    }
                    else
                    { /* block id: 118 */
                        int32_t l_271 = 6;
                        uint32_t l_272 = 1U;
                        (*g_244) = (*g_244);
                        if (g_175.f7)
                            break;
                        (*l_171) = ((__builtin_bswap32(((g_269 , l_270) != l_180)) & (l_266 , ((l_271 & __builtin_clzll(g_7)) >= ((0x1D59750A | (*l_176)) , (*l_233))))) <= g_200.f5);
                        if (l_272)
                            continue;
                    }
                    for (l_266 = 0; (l_266 > 11); l_266++)
                    { /* block id: 126 */
                        (**l_180) = &l_266;
                        /* statement id: 127 */
                        assert (g_133 == &l_266);
                    }
                    /* facts after for loop */
                    //assert (g_133 == &l_266 || g_133 == dangling || g_133 == 0 || g_133 == &l_418);
                    if (g_200.f2)
                        continue;
                    //assert (g_133 == dangling || g_133 == 0 || g_133 == &l_418);
                    (*l_171) = (__builtin_ctzl((+(safe_sub_func_int32_t_s_s((p_93 | l_266), (safe_rshift_func_uint16_t_u_u(func_98(g_269.f4, g_200.f5, p_94), ((safe_unary_minus_func_uint16_t_u(((safe_lshift_func_uint16_t_u_s((((safe_sub_func_uint32_t_u_u(0x0AF4E1E5, __builtin_parityll(func_58(((p_93 == (l_266 || 0x3DB0)) , (-2)), g_149.f2, p_93, l_266)))) ^ g_175.f7) && p_93), 14)) , g_235))) | l_219))))))) >= p_93);
                }
                else
                { /* block id: 131 */
                    int16_t l_287 = 0x11DB;
                    struct S1 **l_299 = &l_298;
                    for (l_162 = 8; (l_162 <= 53); l_162 = safe_add_func_int32_t_s_s(l_162, 1))
                    { /* block id: 134 */
                        (*l_233) = l_287;
                    }
                    (*l_233) = (safe_rshift_func_uint16_t_u_u(((func_105(g_269.f0, p_93) ^ (safe_lshift_func_int16_t_s_u((((void*)0 == &g_133) & __builtin_ffsll((p_93 > g_87))), 3))) ^ (*l_233)), 10));
                    (*l_233) = ((*l_233) && (g_269.f4 || (+(g_293 , (g_294 , (safe_add_func_int16_t_s_s(((((g_200.f3 , l_297) <= 0x94989942) != g_235) < __builtin_ffs((p_93 , 0))), g_200.f2)))))));
                    (*l_299) = l_298;
                }
                /* facts after branching */
                //assert (g_133 == &l_266 || g_133 == dangling || g_133 == 0 || g_133 == &l_418);
            }
            /* facts after for loop */
            //assert (g_133 == dangling || g_133 == 0 || g_133 == &l_418);
            if ((*l_233))
            { /* block id: 142 */
                int32_t *l_300 = &g_7;
                (*g_132) = l_300;
                /* statement id: 143 */
                assert (g_133 == &g_7);
                l_304 = g_301;
                (*l_233) = (((((((***l_180) > (p_93 , (*l_171))) , (**l_180)) == (**l_180)) > l_305) > g_87) ^ __builtin_parityl(((p_93 > 0x4659088A) > g_293.f1)));
                (*l_233) = (safe_rshift_func_int16_t_s_s(((*l_300) ^ (((((p_93 <= 0x878F6FBE) != (func_58(g_246.f2, (safe_lshift_func_uint16_t_u_u((func_58(l_310, p_93, (func_66((*g_133), __builtin_bswap64(g_311), p_93, p_93, (**g_132)) & 0xDD5305F2), g_294.f4) & 0xC99A), p_93)), (*l_176), g_175.f6) || p_93)) & (**g_132)) <= g_200.f4) || p_93)), 7));
            }
            else
            { /* block id: 147 */
                uint16_t l_315 = 0U;
                uint32_t l_338 = 1U;
                int32_t *l_350 = &g_87;
                if (l_312)
                { /* block id: 148 */
                    int8_t l_326 = 0x6E;
                    for (l_220 = 0; (l_220 == 28); l_220++)
                    { /* block id: 151 */
                        int32_t l_321 = 4;
                        struct S1 *l_334 = (void*)0;
                        int32_t ****l_337 = (void*)0;
                        (*l_233) = l_315;
                        (*l_233) = (func_66((safe_lshift_func_int16_t_s_s(g_294.f0, 4)), l_315, (safe_rshift_func_uint16_t_u_u(((+(func_113(&p_94, (0xCB5ADCCE > (l_321 , ((p_93 < (g_200.f6 > (safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u(2U, ((p_93 != 0x2B60) , g_175.f6))), g_294.f3)))) , (*l_233))))) , g_183)) == 0xAEE4), 14)), l_315, l_326) && l_315);
                        (*l_171) = ((safe_sub_func_int16_t_s_s(func_58(((*l_176) <= (safe_add_func_int32_t_s_s(__builtin_ctzll((((((!((65529U & 1) >= p_93)) ^ (((1 || ((p_93 == ((safe_lshift_func_uint16_t_u_u((l_334 == l_334), 9)) , ((__builtin_parityll((safe_sub_func_uint16_t_u_u((l_337 == (void*)0), l_315))) , l_298) == l_298))) == 0xF4BA)) | (*l_176)) ^ l_315)) >= 0x2C0C) >= 0) & 0U)), l_321))), l_326, p_93, l_338), p_93)) || l_326);
                    }
                }
                else
                { /* block id: 156 */
                    int32_t l_339 = 0xD36B8790;
                    uint32_t l_352 = 4U;
                    (*l_233) = ((p_93 , ((((l_339 > p_93) | (safe_rshift_func_int16_t_s_u((p_93 , func_105(((safe_rshift_func_uint16_t_u_u(g_246.f6, ((1 | (*l_233)) == p_93))) , 4294967294U), l_339)), l_338))) <= l_315) | p_93)) != 0xDC06B8AF);
                    (*l_171) = (0xE4E5 >= (func_98(g_87, (((-9) != (p_93 ^ (safe_lshift_func_uint16_t_u_u((1 < 3), 13)))) , (func_58(g_269.f4, __builtin_popcountll(((((((safe_add_func_int16_t_s_s((-1), __builtin_ctzl((safe_rshift_func_int16_t_s_u(((((l_339 ^ l_315) & (-1)) , 0x76CC) , g_183), p_93))))) , l_350) == l_233) != 0xA8C6) || l_351) | l_352)), g_293.f3, g_294.f3) ^ p_93)), l_353) <= 3));
                    (*g_132) = p_94;
                    /* statement id: 159 */
                    //assert (g_133 == 0 || g_133 == &l_418);
                }
                for (l_256 = 0; (l_256 <= 15); l_256 = safe_add_func_uint16_t_u_u(l_256, 1))
                { /* block id: 163 */
                    int16_t l_356 = 0x1091;
                    (*l_233) = l_356;
                    if (func_105(__builtin_parityl(g_246.f0), (g_293.f7 , g_294.f2)))
                    { /* block id: 165 */
                        return (*l_233);
                    }
                    else
                    { /* block id: 167 */
                        int16_t l_357 = 0;
                        l_357 = ((func_105(p_93, (g_246.f3 , g_149.f0)) , p_93) | g_235);
                        return p_93;
                    }
                }
            }
            /* facts after branching */
            //assert (g_133 == dangling || g_133 == 0 || g_133 == &g_7 || g_133 == &l_418);
            (*l_171) = p_93;
        }
        /* facts after branching */
        //assert (g_133 == dangling || g_133 == 0 || g_133 == &g_7 || g_133 == &l_418);
        if ((safe_add_func_int16_t_s_s(p_93, (safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s(p_93, (((p_93 && (safe_add_func_int32_t_s_s((*l_176), (p_93 >= (((((*l_176) > g_28) , l_366) != (void*)0) ^ 2))))) , g_293.f0) , 0x927304A5))), 4294967295U)))))
        { /* block id: 175 */
            (*l_366) = ((g_235 & (*l_176)) >= (*l_176));
            (**l_180) = p_94;
            /* statement id: 177 */
            //assert (g_133 == 0 || g_133 == &l_418);
            (*l_152) = p_94;
            (*l_171) = (*l_366);
        }
        else
        { /* block id: 180 */
            for (l_160 = 0; (l_160 != 15); l_160++)
            { /* block id: 183 */
                (*l_366) = __builtin_clz((*l_366));
            }
            (*g_301) = (*g_301);
        }
        for (l_164 = 14; (l_164 >= (-26)); l_164 = safe_sub_func_uint16_t_u_u(l_164, 2))
        { /* block id: 190 */
            int8_t l_384 = 0x2B;
            int32_t *l_396 = &l_256;
            (*l_171) = (-7);
            (*l_366) = (((-9) >= __builtin_parity((safe_add_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(p_93, (((safe_rshift_func_uint16_t_u_s((safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(((g_294 , g_381) , ((*l_366) <= ((((((*l_171) > ((*l_247) , ((safe_rshift_func_uint16_t_u_u(((*l_366) > (l_384 , 4294967290U)), 14)) <= l_384))) , l_384) != 0xC6346BD3) <= (*l_366)) , 0x539D021F))), p_93)), 8)), p_93)) | 9) == p_93))), g_200.f7)))) || p_93);
            (*l_396) = (safe_rshift_func_uint16_t_u_s(((((((g_87 ^ (safe_lshift_func_int16_t_s_u(9, 12))) , (p_93 > ((safe_mod_func_uint16_t_u_u((((p_93 & (__builtin_clz(p_93) || (((g_294 , (safe_mod_func_int16_t_s_s((func_98(((~(safe_lshift_func_uint16_t_u_s((*l_366), p_93))) , 0x3E9C), (*l_366), l_396) > (*l_396)), g_381.f3))) ^ (*l_176)) || (*l_396)))) && l_397) , (*l_396)), 0xD70A)) > p_93))) > g_149.f5) , (*l_176)) , 1U) < 0U), (*l_396)));
            for (l_197 = 21; (l_197 < 2); l_197--)
            { /* block id: 196 */
                (*l_171) = __builtin_clz((*l_396));
                (*l_366) = (*l_171);
                if ((*l_366))
                    break;
                (*l_366) = p_93;
            }
        }
    }
    else
    { /* block id: 203 */
        const uint32_t l_413 = 0x7B9D86AE;
        for (l_164 = (-19); (l_164 >= 6); l_164 = safe_add_func_uint32_t_u_u(l_164, 1))
        { /* block id: 206 */
            int8_t l_410 = (-4);
            int32_t l_414 = 0x990B5BDC;
            l_414 = (!(safe_lshift_func_int16_t_s_u(func_66(p_93, (g_405 , (safe_add_func_uint32_t_u_u(func_58((safe_lshift_func_int16_t_s_u(1, 8)), g_405.f2, l_410, func_105((g_175.f6 <= (g_149.f3 != l_410)), ((safe_lshift_func_int16_t_s_u((p_93 , g_294.f2), 1)) , 9))), 0U))), l_413, l_413, p_93), g_175.f3)));
            return l_414;
        }
        (*l_152) = p_94;
    }
    /* facts after branching */
    //assert (g_133 == dangling || g_133 == 0 || g_133 == &g_7 || g_133 == &l_418);
    (*l_171) = 2;
    return p_93;
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_132 g_87 g_31 g_28 g_149
 * writes: g_87
 */
static int8_t  func_98(uint16_t  p_99, uint32_t  p_100, int32_t * p_101)
{ /* block id: 57 */
    uint32_t l_108 = 0xBB7EAB32;
    int32_t *l_128 = &g_31;
    int32_t **l_127 = &l_128;
    int32_t *l_129 = (void*)0;
    const int32_t *l_135 = &g_31;
    const int32_t **l_134 = &l_135;
    int32_t *l_150 = (void*)0;
    int32_t *l_151 = &g_87;
    (*l_151) = ((safe_add_func_uint32_t_u_u(func_105(l_108, l_108), __builtin_ctz(g_7))) || ((l_108 < (safe_rshift_func_uint16_t_u_u(func_105((func_113(func_116(p_101, (p_100 , func_122(&p_101, l_127, p_101, l_129)), l_134, p_100, &g_133), p_100) , 9U), g_7), 13))) | 0xBE129642));
    return g_7;
}


/* ------------------------------------------ */
/* 
 * reads : g_7
 * writes:
 */
inline static uint32_t  func_105(uint32_t  p_106, int8_t  p_107)
{ /* block id: 58 */
    int32_t *l_109 = &g_7;
    int32_t **l_110 = &l_109;
    (*l_110) = l_109;
    return (**l_110);
}


/* ------------------------------------------ */
/* 
 * reads : g_87 g_149
 * writes: g_87
 */
inline static struct S1  func_113(int32_t ** p_114, int16_t  p_115)
{ /* block id: 66 */
    int8_t l_147 = 0;
    int32_t *l_148 = &g_87;
    (*l_148) = l_147;
    (*l_148) = (*l_148);
    return g_149;
}


/* ------------------------------------------ */
/* 
 * reads : g_87 g_7 g_31 g_28
 * writes:
 */
static int32_t ** func_116(int32_t * p_117, int32_t ** p_118, const int32_t ** p_119, uint16_t  p_120, int32_t ** p_121)
{ /* block id: 63 */
    uint32_t l_141 = 0xA40D6DD5;
    int32_t l_146 = 0xE2023AE7;
    l_146 = ((safe_sub_func_uint16_t_u_u(g_87, (~(safe_lshift_func_int16_t_s_s((l_141 || (func_105(l_141, g_87) && g_31)), (l_141 & (((safe_mod_func_int32_t_s_s(0x4FF7D934, ((((safe_lshift_func_int16_t_s_u((g_87 ^ p_120), 14)) & 0x4A51DBEE) , l_141) || l_141))) == g_28) && p_120))))))) != p_120);
    return &g_133;
    /* statement id: 65 */
    //assert (func_116_rv == &g_133);
}


/* ------------------------------------------ */
/* 
 * reads : g_132
 * writes:
 */
inline static int32_t ** func_122(int32_t ** p_123, int32_t ** p_124, const int32_t * p_125, int32_t * p_126)
{ /* block id: 61 */
    int32_t *l_131 = &g_7;
    int32_t **l_130 = &l_131;
    return g_132;
    /* statement id: 62 */
    //assert (func_122_rv == &g_133);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_28, "g_28", print_hash_value);
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc(g_87, "g_87", print_hash_value);
    transparent_crc(g_149.f0, "g_149.f0", print_hash_value);
    transparent_crc(g_149.f1, "g_149.f1", print_hash_value);
    transparent_crc(g_149.f2, "g_149.f2", print_hash_value);
    transparent_crc(g_149.f3, "g_149.f3", print_hash_value);
    transparent_crc(g_149.f4, "g_149.f4", print_hash_value);
    transparent_crc(g_149.f5, "g_149.f5", print_hash_value);
    transparent_crc(g_149.f6, "g_149.f6", print_hash_value);
    transparent_crc(g_149.f7, "g_149.f7", print_hash_value);
    transparent_crc(g_175.f0, "g_175.f0", print_hash_value);
    transparent_crc(g_175.f1, "g_175.f1", print_hash_value);
    transparent_crc(g_175.f2, "g_175.f2", print_hash_value);
    transparent_crc(g_175.f3, "g_175.f3", print_hash_value);
    transparent_crc(g_175.f4, "g_175.f4", print_hash_value);
    transparent_crc(g_175.f5, "g_175.f5", print_hash_value);
    transparent_crc(g_175.f6, "g_175.f6", print_hash_value);
    transparent_crc(g_175.f7, "g_175.f7", print_hash_value);
    transparent_crc(g_183, "g_183", print_hash_value);
    transparent_crc(g_200.f0, "g_200.f0", print_hash_value);
    transparent_crc(g_200.f1, "g_200.f1", print_hash_value);
    transparent_crc(g_200.f2, "g_200.f2", print_hash_value);
    transparent_crc(g_200.f3, "g_200.f3", print_hash_value);
    transparent_crc(g_200.f4, "g_200.f4", print_hash_value);
    transparent_crc(g_200.f5, "g_200.f5", print_hash_value);
    transparent_crc(g_200.f6, "g_200.f6", print_hash_value);
    transparent_crc(g_200.f7, "g_200.f7", print_hash_value);
    transparent_crc(g_235, "g_235", print_hash_value);
    transparent_crc(g_246.f0, "g_246.f0", print_hash_value);
    transparent_crc(g_246.f1, "g_246.f1", print_hash_value);
    transparent_crc(g_246.f2, "g_246.f2", print_hash_value);
    transparent_crc(g_246.f3, "g_246.f3", print_hash_value);
    transparent_crc(g_246.f4, "g_246.f4", print_hash_value);
    transparent_crc(g_246.f5, "g_246.f5", print_hash_value);
    transparent_crc(g_246.f6, "g_246.f6", print_hash_value);
    transparent_crc(g_246.f7, "g_246.f7", print_hash_value);
    transparent_crc(g_269.f0, "g_269.f0", print_hash_value);
    transparent_crc(g_269.f1, "g_269.f1", print_hash_value);
    transparent_crc(g_269.f2, "g_269.f2", print_hash_value);
    transparent_crc(g_269.f3, "g_269.f3", print_hash_value);
    transparent_crc(g_269.f4, "g_269.f4", print_hash_value);
    transparent_crc(g_269.f5, "g_269.f5", print_hash_value);
    transparent_crc(g_293.f0, "g_293.f0", print_hash_value);
    transparent_crc(g_293.f1, "g_293.f1", print_hash_value);
    transparent_crc(g_293.f2, "g_293.f2", print_hash_value);
    transparent_crc(g_293.f3, "g_293.f3", print_hash_value);
    transparent_crc(g_293.f4, "g_293.f4", print_hash_value);
    transparent_crc(g_293.f5, "g_293.f5", print_hash_value);
    transparent_crc(g_293.f6, "g_293.f6", print_hash_value);
    transparent_crc(g_293.f7, "g_293.f7", print_hash_value);
    transparent_crc(g_294.f0, "g_294.f0", print_hash_value);
    transparent_crc(g_294.f1, "g_294.f1", print_hash_value);
    transparent_crc(g_294.f2, "g_294.f2", print_hash_value);
    transparent_crc(g_294.f3, "g_294.f3", print_hash_value);
    transparent_crc(g_294.f4, "g_294.f4", print_hash_value);
    transparent_crc(g_294.f5, "g_294.f5", print_hash_value);
    transparent_crc(g_311, "g_311", print_hash_value);
    transparent_crc(g_381.f0, "g_381.f0", print_hash_value);
    transparent_crc(g_381.f1, "g_381.f1", print_hash_value);
    transparent_crc(g_381.f2, "g_381.f2", print_hash_value);
    transparent_crc(g_381.f3, "g_381.f3", print_hash_value);
    transparent_crc(g_381.f4, "g_381.f4", print_hash_value);
    transparent_crc(g_381.f5, "g_381.f5", print_hash_value);
    transparent_crc(g_405.f0, "g_405.f0", print_hash_value);
    transparent_crc(g_405.f1, "g_405.f1", print_hash_value);
    transparent_crc(g_405.f2, "g_405.f2", print_hash_value);
    transparent_crc(g_405.f3, "g_405.f3", print_hash_value);
    transparent_crc(g_405.f4, "g_405.f4", print_hash_value);
    transparent_crc(g_405.f5, "g_405.f5", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 88
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 16
XXX zero bitfields defined in structs: 2
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 3
XXX structs with bitfields in the program: 14
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 8
breakdown:
   indirect level: 0, occurrence: 8
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 67

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 20
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2
   depth: 30, occurrence: 1

XXX total number of pointers: 60

XXX times a variable address is taken: 52
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 53
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 455

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 336
   level: 2, occurrence: 119
   level: 3, occurrence: 41
   level: 4, occurrence: 18
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 27
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 35
XXX average alias set size: 1.27

XXX times a non-volatile is read: 526
XXX times a non-volatile is write: 135
XXX times a volatile is read: 23
XXX    times read thru a pointer: 1
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 299
XXX percentage of non-volatile access: 96.6

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 107
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 8
   depth: 2, occurrence: 20
   depth: 3, occurrence: 16
   depth: 4, occurrence: 24
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 13.5
XXX percentage an existing variable is used: 86.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

