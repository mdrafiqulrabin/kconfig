/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3774906530
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 31;
   const volatile int64_t  f1;
   uint16_t  f2;
   volatile int32_t  f3;
   volatile uint64_t  f4;
   uint16_t  f5;
};

struct S1 {
   signed f0 : 20;
   volatile signed f1 : 29;
   const unsigned f2 : 26;
   signed f3 : 26;
   signed f4 : 1;
   unsigned f5 : 24;
   signed f6 : 16;
};

/* --- GLOBAL VARIABLES --- */
static struct S0 g_11 = {32058,0xBACDE9E843631E19LL,3UL,2L,5UL,0xFADFL};/* VOLATILE GLOBAL g_11 */
static struct S0 *g_10 = &g_11;
static struct S0 g_14 = {16362,0x9A20B28787D6364DLL,0UL,1L,18446744073709551615UL,65534UL};/* VOLATILE GLOBAL g_14 */
static float g_22 = 0x9.3CCC09p-96;
static int32_t *g_59 = (void*)0;
static int32_t g_63 = 0x7FBA349AL;
static struct S0 **g_80 = &g_10;
static struct S0 ***g_79 = &g_80;
static struct S0 ****g_78 = &g_79;
static const struct S1 g_194 = {623,-9744,783,-6173,0,1649,-202};/* VOLATILE GLOBAL g_194 */
static float *g_201 = &g_22;
static float **g_200 = &g_201;
static float ***g_199 = &g_200;
static struct S1 g_205 = {373,11958,7035,-1989,0,3090,231};/* VOLATILE GLOBAL g_205 */
static uint32_t g_215 = 0xD9994814L;
static volatile struct S1 g_226 = {47,17167,4164,-4448,0,1159,-142};/* VOLATILE GLOBAL g_226 */
static volatile struct S1 *g_225 = &g_226;
static volatile struct S1 **g_224 = &g_225;
static struct S0 g_230 = {1688,0x3E02F516F70F242ELL,0xF4D9L,0L,0x08C7FE27165453F0LL,0xEBA8L};/* VOLATILE GLOBAL g_230 */
static struct S1 g_236 = {-845,14290,2655,5593,-0,917,-187};/* VOLATILE GLOBAL g_236 */
static struct S1 g_342 = {-832,8474,3027,6404,0,3507,-188};/* VOLATILE GLOBAL g_342 */
static struct S1 *g_341 = &g_342;
static struct S1 **g_340 = &g_341;
static struct S1 ***g_339 = &g_340;
static float g_346 = 0x0.1p+1;
static uint16_t g_358 = 65535UL;
static struct S0 g_434 = {4455,0x7E0E67F560DB045FLL,0x9F2AL,9L,7UL,0UL};/* VOLATILE GLOBAL g_434 */
static struct S0 g_436 = {40391,1L,65535UL,-1L,0UL,6UL};/* VOLATILE GLOBAL g_436 */
static struct S0 g_479 = {38273,0L,0x71BDL,0x0221FA44L,3UL,2UL};/* VOLATILE GLOBAL g_479 */
static struct S0 *g_478 = &g_479;
static int32_t g_484 = 0x28FC71B9L;
static struct S0 g_512 = {7015,0xA1F3812432F8949ALL,0x1FAFL,0xF3B15DECL,0x937DA5C83AC0BDFBLL,0x691CL};/* VOLATILE GLOBAL g_512 */
static volatile uint16_t g_546 = 0UL;/* VOLATILE GLOBAL g_546 */
static uint64_t g_569 = 9UL;
static int32_t *g_591 = &g_63;
static struct S0 g_603 = {37550,0x79AC501F64214D05LL,0x2561L,0x0AA0C3C4L,0x43DC13B5F980AC64LL,0xE51CL};/* VOLATILE GLOBAL g_603 */
static const struct S0 *g_602 = &g_603;
static const struct S0 **g_601 = &g_602;
static const struct S0 ***g_600 = &g_601;
static volatile float *g_632 = (void*)0;
static volatile float **g_631 = &g_632;
static volatile float ***g_630 = &g_631;
static volatile float ****g_629 = &g_630;
static volatile float *****g_628 = &g_629;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t  func_2(const uint32_t  p_3, int16_t  p_4, uint64_t  p_5, int32_t  p_6);
static struct S0 * func_8(struct S0 * p_9);
static struct S0 ** func_15(struct S0 ** p_16, struct S0 * p_17);
static struct S0 * func_18(uint16_t  p_19);
static int32_t * func_26(int64_t  p_27, struct S0 *** p_28, struct S0 **** p_29, int16_t  p_30, const struct S0 *** p_31);
static struct S0 *** func_32(float * p_33, int16_t  p_34, uint16_t  p_35, struct S0 * p_36);
static float * func_37(uint16_t  p_38, int32_t  p_39, int16_t  p_40, uint32_t  p_41, uint16_t  p_42);
static int32_t  func_46(int16_t  p_47, uint64_t  p_48, int16_t  p_49, int32_t  p_50, int16_t  p_51);
static uint64_t  func_52(int32_t * p_53, int32_t  p_54, int32_t  p_55, struct S0 *** p_56, int32_t * p_57);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_11.f0 g_11.f4 g_11.f2 g_11.f5 g_14.f5 g_59 g_63 g_78 g_14.f0 g_22 g_14.f2 g_79 g_80 g_199 g_200 g_201 g_205.f2 g_194.f6 g_205.f3 g_215 g_224 g_225 g_236.f2 g_194.f2 g_236.f6 g_194.f3 g_358 g_342.f5 g_236.f3 g_205.f6 g_230.f5 g_236.f5 g_205.f0 g_342.f6 g_194.f4 g_342.f2 g_230.f2 g_478 g_484 g_342.f0 g_342.f3 g_11.f1 g_479.f3 g_546 g_230.f4 g_569 g_436.f4 g_340 g_434.f2 g_591 g_600 g_512.f1 g_628 g_436.f2 g_205.f5 g_603.f4 g_479.f5 g_194.f1
 * writes: g_22 g_63 g_59 g_10 g_339 g_346 g_14.f2 g_215 g_79 g_484 g_341 g_14.f5 g_230.f5 g_479.f5 g_80
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    const int32_t l_7 = 0x86F8C7B5L;
    if (func_2(l_7, l_7, l_7, l_7))
    { /* block id: 260 */
        (*g_591) = 0x7D272D4CL;
        return g_194.f1;
    }
    else
    { /* block id: 263 */
        return g_484;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_11.f0 g_11.f4 g_11.f2 g_11.f5 g_14.f5 g_59 g_63 g_78 g_14.f0 g_22 g_14.f2 g_79 g_80 g_199 g_200 g_201 g_205.f2 g_194.f6 g_205.f3 g_215 g_224 g_225 g_236.f2 g_194.f2 g_236.f6 g_194.f3 g_358 g_342.f5 g_236.f3 g_205.f6 g_230.f5 g_236.f5 g_205.f0 g_342.f6 g_194.f4 g_342.f2 g_230.f2 g_478 g_484 g_342.f0 g_342.f3 g_11.f1 g_479.f3 g_546 g_230.f4 g_569 g_436.f4 g_340 g_434.f2 g_591 g_600 g_512.f1 g_628 g_436.f2 g_205.f5 g_603.f4 g_479.f5
 * writes: g_22 g_63 g_59 g_10 g_339 g_346 g_14.f2 g_215 g_79 g_484 g_341 g_14.f5 g_230.f5 g_479.f5 g_80
 */
static int32_t  func_2(const uint32_t  p_3, int16_t  p_4, uint64_t  p_5, int32_t  p_6)
{ /* block id: 1 */
    struct S0 *l_13 = &g_14;
    struct S0 ***l_650 = &g_80;
    int32_t l_651 = 1L;
    l_13 = func_8(g_10);
    /* statement id: 4 */
    assert (l_13 == &g_11);
    (*l_650) = func_15(&g_10, func_18(g_11.f0));
    /* statement id: 258 */
    assert (g_10 == 0 || g_10 == &g_11);
    assert (g_59 == &g_484);
    //assert (g_339 == &g_340 || g_339 == dangling);
    return l_651;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_8(struct S0 * p_9)
{ /* block id: 2 */
    struct S0 *l_12 = &g_11;
    return l_12;
    /* statement id: 3 */
    //assert (func_8_rv == &g_11);
}


/* ------------------------------------------ */
/* 
 * reads : g_603.f4 g_10 g_205.f3 g_591 g_63 g_59 g_479.f5 g_484 g_79 g_80
 * writes: g_484 g_479.f5
 */
static struct S0 ** func_15(struct S0 ** p_16, struct S0 * p_17)
{ /* block id: 250 */
    float l_644 = 0x4.1E1E88p-40;
    int32_t l_645 = (-1L);
    (*g_59) = (!((g_603.f4 && ((0x0767L | (!l_645)) > (65532UL < ((uint16_t)((*p_16) == (void*)0) + (uint16_t)((g_205.f3 != 65531UL) || 1UL))))) | (*g_591)));
    for (g_479.f5 = 27; (g_479.f5 != 1); g_479.f5--)
    { /* block id: 254 */
        if ((*g_59))
            break;
    }
    return (*g_79);
    /* statement id: 257 */
    //assert (func_15_rv == &g_10);
}


/* ------------------------------------------ */
/* 
 * reads : g_11.f0 g_11.f4 g_11.f2 g_11.f5 g_14.f5 g_59 g_63 g_78 g_14.f0 g_22 g_14.f2 g_79 g_80 g_10 g_199 g_200 g_201 g_205.f2 g_194.f6 g_205.f3 g_215 g_224 g_225 g_236.f2 g_194.f2 g_236.f6 g_194.f3 g_358 g_342.f5 g_236.f3 g_205.f6 g_230.f5 g_236.f5 g_205.f0 g_342.f6 g_194.f4 g_342.f2 g_230.f2 g_478 g_484 g_342.f0 g_342.f3 g_11.f1 g_479.f3 g_546 g_230.f4 g_569 g_436.f4 g_340 g_434.f2 g_591 g_600 g_512.f1 g_628 g_436.f2 g_205.f5
 * writes: g_22 g_63 g_59 g_10 g_339 g_346 g_14.f2 g_215 g_79 g_484 g_341 g_14.f5 g_230.f5
 */
static struct S0 * func_18(uint16_t  p_19)
{ /* block id: 5 */
    uint32_t l_20 = 0x12C51978L;
    float *l_21 = &g_22;
    struct S0 **l_24 = &g_10;
    struct S0 ***l_23 = &l_24;
    struct S0 ****l_25 = &l_23;
    int32_t *l_58 = (void*)0;
    uint16_t l_233 = 0xED15L;
    int32_t **l_637 = &g_59;
    (*l_21) = l_20;
    (*l_25) = l_23;
    (*l_637) = func_26(p_19, func_32(func_37((p_19 & g_11.f0), g_11.f4, g_11.f2, (((g_11.f5 & (!((int32_t)(func_46(g_11.f2, (func_52(l_58, ((((0x020B2DE47E5F8F0BLL | (-1L)) == g_11.f5) < g_14.f5) != p_19), p_19, (*l_25), g_59) || g_14.f2), l_233, p_19, l_20) || 0x4211670AL) % (int32_t)p_19))) < g_11.f0) | 0x828BL), g_230.f2), l_233, g_230.f2, g_478), &l_23, p_19, g_600);
    /* statement id: 248 */
    assert (g_10 == 0 || g_10 == &g_11);
    assert (g_59 == &g_484);
    //assert (g_339 == &g_340 || g_339 == dangling);
    return (**l_23);
    /* statement id: 249 */
    //assert (func_18_rv == 0 || func_18_rv == &g_11);
}


/* ------------------------------------------ */
/* 
 * reads : g_199 g_200 g_201 g_230.f5 g_358 g_512.f1 g_628 g_236.f6 g_11.f2 g_436.f2 g_194.f4 g_205.f5 g_59
 * writes: g_22 g_230.f5 g_59 g_63
 */
static int32_t * func_26(int64_t  p_27, struct S0 *** p_28, struct S0 **** p_29, int16_t  p_30, const struct S0 *** p_31)
{ /* block id: 238 */
    const float *l_606 = &g_346;
    const float **l_605 = &l_606;
    const float ***l_604 = &l_605;
    int32_t l_612 = (-1L);
    struct S0 **l_619 = (void*)0;
    const int16_t l_624 = 0x3FEEL;
    float *****l_633 = (void*)0;
    uint16_t l_634 = 0UL;
    int16_t l_635 = 0x52A4L;
    int32_t *l_636 = &g_63;
    (***g_199) = ((void*)0 != l_604);
    for (g_230.f5 = 0; (g_230.f5 != 10); ++g_230.f5)
    { /* block id: 242 */
        const int32_t **l_609 = (void*)0;
        const int32_t *l_611 = &g_63;
        const int32_t **l_610 = &l_611;
        (*l_610) = l_606;
        /* statement id: 243 */
        assert (l_611 == &g_346);
        if (l_612)
            break;
    }
    l_636 = func_37(g_358, (((((int16_t)l_612 << (int16_t)3) > (p_30 ^ ((((uint16_t)((uint16_t)((l_619 != (void*)0) & ((uint64_t)(((int64_t)l_624 / (int64_t)((~((-4L) ^ (g_512.f1 && (g_628 != l_633)))) && g_236.f6)) > 0UL) - (uint64_t)l_612)) << (uint16_t)g_11.f2) >> (uint16_t)l_634) >= g_436.f2) > p_30))) || g_194.f4) && g_205.f5), l_635, l_634, l_624);
    /* statement id: 246 */
    assert (g_59 == &g_63);
    assert (l_636 == &g_22);
    return &g_484;
    /* statement id: 247 */
    //assert (func_26_rv == &g_484);
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_484 g_342.f0 g_215 g_59 g_14.f0 g_342.f3 g_11.f5 g_11.f1 g_205.f3 g_479.f3 g_200 g_201 g_78 g_79 g_546 g_230.f4 g_22 g_569 g_436.f4 g_80 g_340 g_199 g_434.f2 g_11.f2 g_14.f5 g_591
 * writes: g_63 g_484 g_59 g_22 g_341 g_14.f5
 */
static struct S0 *** func_32(float * p_33, int16_t  p_34, uint16_t  p_35, struct S0 * p_36)
{ /* block id: 199 */
    int32_t l_482 = 0x54138627L;
    int16_t l_487 = 0xB764L;
    struct S1 ***l_488 = (void*)0;
    int64_t l_508 = 7L;
    int32_t l_509 = 0xB99193B4L;
    struct S0 *l_511 = &g_512;
    const struct S0 *l_524 = (void*)0;
    const struct S0 **l_523 = &l_524;
    const struct S0 ***l_522 = &l_523;
    const struct S0 ****l_521 = &l_522;
    const float *l_540 = &g_22;
    uint64_t l_573 = 18446744073709551612UL;
    int32_t *l_584 = (void*)0;
    int16_t l_594 = 0xA51FL;
    struct S0 ***l_599 = &g_80;
    for (g_63 = 22; (g_63 != 21); g_63--)
    { /* block id: 202 */
        int32_t *l_483 = &g_484;
        int64_t l_507 = 0xAD549B605C481B2CLL;
        struct S0 *l_510 = &g_14;
        (*l_483) = l_482;
        if ((((uint64_t)l_482 + (uint64_t)0x22ADA30994F28E4CLL) ^ ((l_487 >= (p_36 != (void*)0)) || (*l_483))))
        { /* block id: 204 */
            uint32_t l_505 = 1UL;
            int32_t l_506 = 0x2461E19BL;
            l_509 = (((((*l_483) != (&g_224 == l_488)) != ((uint16_t)((uint16_t)((int16_t)(((uint16_t)(0x4C75L ^ (((uint16_t)(g_342.f0 > (p_35 ^ ((uint32_t)((*l_483) && ((((int16_t)(((g_215 > ((((uint32_t)(l_505 & p_35) % (uint32_t)0x71379540L) <= l_506) > l_506)) >= (*g_59)) != 0xE68AL) >> (int16_t)p_34) <= g_14.f0) < g_342.f3)) % (uint32_t)l_507))) % (uint16_t)g_11.f5) && g_11.f1)) << (uint16_t)10) == p_35) << (int16_t)l_506) % (uint16_t)p_35) << (uint16_t)l_508)) >= 0xFEA3L) && 4294967295UL);
            (*l_483) = (*g_59);
            if ((*g_59))
                break;
            l_511 = l_510;
            /* statement id: 208 */
            assert (l_511 == &g_14);
        }
        else
        { /* block id: 209 */
            int32_t *l_513 = &l_509;
            l_513 = &g_63;
            /* statement id: 210 */
            assert (l_513 == &g_63);
            if ((*l_513))
                break;
        }
    }
    /* facts after for loop */
    assert (l_511 == &g_512 || l_511 == &g_14);
    if ((((uint32_t)((-(uint64_t)((*g_59) ^ ((*g_59) <= (g_205.f3 & ((*g_59) > ((void*)0 != &p_36)))))) | ((int16_t)p_34 - (int16_t)((5UL | (l_521 != &l_522)) == 0x732188C2L))) - (uint32_t)p_35) != 0x782BF184L))
    { /* block id: 214 */
        int32_t l_537 = 0xB88BF53CL;
        int32_t **l_547 = &g_59;
        (*g_59) = ((uint32_t)((uint64_t)((int32_t)(*g_59) / (int32_t)((uint16_t)(p_33 == (void*)0) + (uint16_t)((uint64_t)((uint64_t)l_537 + (uint64_t)g_479.f3) % (uint64_t)l_482))) / (uint64_t)((uint16_t)l_537 >> (uint16_t)0)) / (uint32_t)0xE34D3533L);
        (*l_547) = func_37(p_35, ((-5L) == 65535UL), ((*g_200) == l_540), (-(uint16_t)(((uint16_t)((int16_t)((*l_521) != (*g_78)) << (int16_t)l_482) >> (uint16_t)8) || ((g_546 & (-1L)) && p_35))), p_34);
        /* statement id: 216 */
        assert (g_59 == &g_22);
        (*g_59) = ((((uint16_t)l_509 << (uint16_t)(p_35 || l_509)) || l_509) == (&g_200 == (void*)0));
        (*g_59) = ((int16_t)(((uint16_t)65531UL >> (uint16_t)(((void*)0 != &p_36) <= ((-6L) || g_230.f4))) && ((uint64_t)((((uint16_t)(1L != ((((int32_t)(~(((uint16_t)((uint16_t)((((int16_t)(**l_547) % (int16_t)p_34) >= ((int16_t)g_569 << (int16_t)14)) || p_34) << (uint16_t)p_35) << (uint16_t)l_508) < p_35)) + (int32_t)0x2FB95DA0L) > 9L) ^ g_436.f4)) >> (uint16_t)(**l_547)) == 0x81CB12F6L) > l_508) % (uint64_t)0x4223FD998B90FE05LL)) >> (int16_t)15);
    }
    else
    { /* block id: 219 */
        int64_t l_570 = 0L;
        struct S1 *l_571 = &g_342;
        int32_t **l_581 = &g_59;
        if ((p_34 >= ((1UL < ((*g_79) == &p_36)) ^ l_570)))
        { /* block id: 220 */
            (*g_340) = l_571;
        }
        else
        { /* block id: 222 */
            int32_t **l_572 = &g_59;
            (*l_572) = (void*)0;
            /* statement id: 223 */
            assert (g_59 == 0);
            (***g_199) = 0xB.26D909p+85;
            (*l_572) = func_37(l_573, p_34, (((!0x691062FABED10270LL) | ((int16_t)(-1L) / (int16_t)65535UL)) == (((uint16_t)0UL >> (uint16_t)10) == ((uint16_t)((g_342.f0 >= ((void*)0 == l_581)) > g_434.f2) >> (uint16_t)9))), p_34, g_11.f2);
            /* statement id: 225 */
            assert (g_59 == &g_22);
            for (g_14.f5 = 0; (g_14.f5 > 51); ++g_14.f5)
            { /* block id: 228 */
                (**l_581) = (&g_340 != &g_224);
            }
        }
        /* facts after branching */
        assert (g_59 == &g_22 || g_59 == &g_63);
        (**g_200) = (*p_33);
        l_584 = (*l_581);
        /* statement id: 233 */
        assert (l_584 == &g_22 || l_584 == &g_63);
    }
    /* facts after branching */
    assert (g_59 == &g_22 || g_59 == &g_63);
    assert (l_584 == &g_22 || l_584 == &g_63 || l_584 == 0);
    (*g_59) = (*g_59);
    (**g_200) = (0x6.D86116p-44 < ((((float)(((float)(-0x1.3p+1) + (float)((float)((((void*)0 != g_591) != (((((float)l_594 / (float)((float)(*g_201) - (float)(***g_199))) <= ((float)(&g_59 != &g_59) - (float)0xC.913EEDp-58)) < (**g_200)) <= 0x5.B40B70p+56)) == (***g_199)) - (float)0x0.F16103p+29)) <= (**g_200)) + (float)(**g_200)) != l_594) != 0xD.335F50p+96));
    return l_599;
    /* statement id: 237 */
    //assert (func_32_rv == &g_80);
}


/* ------------------------------------------ */
/* 
 * reads : g_59
 * writes: g_59 g_63
 */
static float * func_37(uint16_t  p_38, int32_t  p_39, int16_t  p_40, uint32_t  p_41, uint16_t  p_42)
{ /* block id: 195 */
    int32_t **l_475 = (void*)0;
    struct S1 **l_476 = (void*)0;
    float *l_477 = &g_22;
    g_59 = &g_63;
    /* statement id: 196 */
    assert (g_59 == &g_63);
    (*g_59) = (l_476 == (void*)0);
    return l_477;
    /* statement id: 198 */
    //assert (func_37_rv == &g_22);
}


/* ------------------------------------------ */
/* 
 * reads : g_224 g_225 g_200 g_201 g_22 g_199 g_59 g_63 g_78 g_79 g_80 g_14.f5 g_236.f2 g_10 g_194.f2 g_236.f6 g_194.f3 g_14.f0 g_11.f0 g_194.f6 g_215 g_11.f2 g_358 g_342.f5 g_236.f3 g_205.f6 g_230.f5 g_236.f5 g_205.f0 g_342.f6 g_11.f5 g_14.f2 g_194.f4 g_342.f2 g_205.f3
 * writes: g_59 g_22 g_63 g_10 g_339 g_346 g_14.f2 g_215 g_79
 */
static int32_t  func_46(int16_t  p_47, uint64_t  p_48, int16_t  p_49, int32_t  p_50, int16_t  p_51)
{ /* block id: 81 */
    int32_t **l_234 = &g_59;
    struct S1 *l_235 = &g_236;
    struct S0 *l_245 = (void*)0;
    int32_t l_246 = 0x9B7E66DBL;
    struct S0 ***l_247 = (void*)0;
    int32_t *l_252 = &g_63;
    uint16_t l_337 = 0x71C0L;
    float *****l_359 = (void*)0;
    float *l_374 = &g_346;
    const uint32_t l_395 = 18446744073709551609UL;
    (*l_234) = &g_63;
    /* statement id: 82 */
    assert (g_59 == &g_63);
    (**g_200) = (((*g_224) != l_235) > ((**g_200) == ((float)(((float)(-0x4.Fp+1) / (float)((float)((((float)(*g_201) - (float)(0xD.48DE73p+38 <= ((*g_201) < ((((p_49 <= (l_245 != (void*)0)) > (***g_199)) <= l_246) != p_51)))) <= (**g_200)) >= p_50) - (float)(**l_234))) >= (**l_234)) - (float)(**l_234))));
    if (((*g_78) == l_247))
    { /* block id: 84 */
        int32_t **l_270 = &l_252;
        struct S0 ****l_288 = &l_247;
        struct S1 **l_309 = (void*)0;
        const float *l_353 = &g_22;
        const float **l_352 = &l_353;
        const float ***l_351 = &l_352;
        const float ****l_350 = &l_351;
        uint32_t l_432 = 4UL;
        for (p_51 = 0; (p_51 >= (-11)); p_51 -= 7)
        { /* block id: 87 */
            int32_t **l_269 = (void*)0;
            int32_t *l_299 = &g_63;
            struct S1 **l_308 = &l_235;
            uint16_t l_367 = 0x2CCCL;
            for (p_49 = 7; (p_49 > (-25)); p_49--)
            { /* block id: 90 */
                (*l_234) = l_252;
            }
            (*g_59) = (((uint16_t)((void*)0 != (**g_78)) >> (uint16_t)10) != (((uint16_t)p_51 / (uint16_t)((uint32_t)((uint16_t)(((-(uint16_t)((int64_t)(!((uint16_t)(18446744073709551615UL && (*l_252)) + (uint16_t)((uint16_t)p_50 << (uint16_t)6))) + (int64_t)(l_269 != l_270))) ^ (((int16_t)((uint64_t)(((int16_t)((int64_t)6L / (int64_t)g_14.f5) << (int16_t)p_50) >= p_51) % (uint64_t)p_47) / (int16_t)g_236.f2) < 8UL)) != (**l_270)) << (uint16_t)p_51) - (uint32_t)(*g_59))) < (**l_234)));
            for (p_47 = 0; (p_47 < (-21)); p_47 -= 1)
            { /* block id: 96 */
                float l_281 = 0xB.2888F7p+75;
                int32_t l_298 = 0x012F7A82L;
                uint64_t l_326 = 8UL;
                float ****l_349 = &g_199;
                if ((*g_59))
                    break;
                if (((p_48 < p_51) < p_51))
                { /* block id: 98 */
                    float l_297 = 0xD.C7E725p-5;
                    for (p_50 = 0; (p_50 >= 12); p_50++)
                    { /* block id: 101 */
                        (**g_79) = func_8(func_8((*g_80)));
                        /* statement id: 102 */
                        assert (g_10 == &g_11);
                        (**g_200) = p_47;
                    }
                    (**l_270) = ((int32_t)((uint32_t)(l_288 == (void*)0) + (uint32_t)((((int16_t)1L + (int16_t)((((void*)0 != &g_59) ^ ((int64_t)(((int16_t)(0x28254A3DL && ((((void*)0 != (*g_78)) | ((uint64_t)(4UL ^ g_194.f2) % (uint64_t)p_50)) < g_236.f6)) >> (int16_t)7) <= (*g_59)) % (int64_t)0xC11684F62FEAE699LL)) && p_50)) == (*g_59)) ^ l_298)) % (int32_t)p_50);
                    (*l_270) = &g_63;
                    (*l_270) = &g_63;
                }
                else
                { /* block id: 108 */
                    (**g_200) = l_298;
                    if ((**l_270))
                        continue;
                    l_299 = (*l_270);
                }
                if ((**l_270))
                { /* block id: 113 */
                    uint32_t l_325 = 18446744073709551611UL;
                    if ((((~((0x2DB857E70C58C611LL ^ ((!(((uint16_t)((int32_t)1L + (int32_t)((int16_t)((l_308 != l_309) <= ((p_51 <= (((int32_t)((((((uint64_t)(*l_252) % (uint64_t)g_194.f3) == ((!((uint64_t)((uint32_t)p_51 + (uint32_t)(((((int32_t)((int64_t)(((((int16_t)((18446744073709551615UL && 1UL) && p_50) % (int16_t)p_48) && 0x8B5BL) & g_14.f0) ^ p_48) / (int64_t)0x089FC940DAB33172LL) + (int32_t)p_48) < 4294967291UL) <= (**l_234)) >= (**l_270))) - (uint64_t)p_49)) & g_11.f0)) <= 18446744073709551615UL) > l_298) < g_194.f6) % (int32_t)p_51) | l_325)) | l_326)) + (int16_t)0x14FAL)) >> (uint16_t)l_325) > 0L)) | g_215)) < 0xB8C33217L)) <= g_11.f2) ^ g_14.f0))
                    { /* block id: 114 */
                        uint32_t l_336 = 18446744073709551607UL;
                        struct S1 ***l_338 = &l_309;
                        (*g_59) = (((((((int16_t)p_47 >> (int16_t)(((uint64_t)0x998A2E6060EF3B87LL + (uint64_t)18446744073709551608UL) && (l_298 == (!p_51)))) >= 18446744073709551608UL) > (p_50 < (((int64_t)(l_336 < ((p_49 ^ l_325) <= 4294967289UL)) + (int64_t)l_337) <= 0xE142C4EDL))) && 0x4DBA9E8C40D4951ALL) <= 1UL) > p_49);
                        g_339 = l_338;
                        /* statement id: 116 */
                        assert (g_339 == &l_309);
                    }
                    else
                    { /* block id: 117 */
                        int32_t l_343 = (-2L);
                        (**l_234) = (*g_59);
                        return l_343;
                        /* statement id: 119 */
                        //assert (g_339 == &g_340 || g_339 == dangling);
                    }
                    /* facts after branching */
                    assert (g_339 == &l_309);
                    for (l_246 = 5; (l_246 == 16); l_246 += 1)
                    { /* block id: 123 */
                        g_346 = (**l_234);
                        (*g_59) = (&g_79 == (void*)0);
                        if (p_49)
                            continue;
                    }
                }
                else
                { /* block id: 128 */
                    uint32_t l_360 = 18446744073709551613UL;
                    float *****l_365 = (void*)0;
                    for (l_326 = (-28); (l_326 < 45); l_326++)
                    { /* block id: 131 */
                        (**g_200) = ((((l_349 == l_350) > 0x0.Fp+1) <= 0x5.96565Bp+19) != (0xD.5D5419p-12 == (0xC.236062p+16 == ((float)p_51 - (float)((float)((g_358 != (*g_201)) >= p_51) + (float)p_49)))));
                        l_359 = l_359;
                        if (l_360)
                            continue;
                        (**g_200) = (0x5.Cp+1 == p_47);
                    }
                    (*g_201) = 0x8.D05AA6p+55;
                    (*g_59) = ((int16_t)g_63 >> (int16_t)9);
                    for (g_14.f2 = 0; (g_14.f2 >= 51); g_14.f2++)
                    { /* block id: 141 */
                        float *****l_366 = &l_349;
                        g_59 = (*l_234);
                        (**g_200) = (l_365 == l_366);
                        return l_367;
                        /* statement id: 144 */
                        //assert (g_339 == &g_340 || g_339 == dangling);
                    }
                }
            }
        }
        /* facts after for loop */
        assert (g_339 == &g_340 || g_339 == &l_309);
        if (((uint32_t)(((uint64_t)((((uint64_t)((void*)0 == l_374) + (uint64_t)0xC7F448DE3217AAFALL) == (((int64_t)((~((p_47 == ((void*)0 != &g_59)) ^ (**l_270))) > 0L) % (int64_t)(-(uint16_t)0x13A2L)) & g_342.f5)) ^ p_47) + (uint64_t)9UL) < (**l_234)) + (uint32_t)0x31C68CD3L))
        { /* block id: 149 */
            uint32_t l_387 = 4294967292UL;
            struct S0 ***l_398 = &g_80;
            (*l_252) = (((((int64_t)(p_47 < ((((l_309 != (void*)0) > ((uint64_t)(((0xEEDBL == ((((0x6F80L && p_51) != (~((int16_t)(-(uint16_t)((&g_79 != &g_79) && (**l_270))) << (int16_t)(**l_270)))) < (**l_270)) == p_47)) || l_387) | (**l_270)) / (uint64_t)p_48)) | p_47) == (*g_59))) % (int64_t)(**l_234)) & 0x294AL) <= 0xE324L) || p_48);
            (*l_252) = ((uint32_t)((uint32_t)((-(int32_t)(-1L)) & ((uint32_t)((((((*g_78) == (void*)0) & (((2UL < l_395) > (g_236.f3 && ((int16_t)((l_398 == l_398) >= (-1L)) / (int16_t)(-1L)))) ^ g_194.f3)) ^ p_50) != l_387) >= 0x3D3E0E9DL) + (uint32_t)0UL)) / (uint32_t)0x0633B5ACL) / (uint32_t)p_50);
            (*l_234) = &g_63;
        }
        else
        { /* block id: 153 */
            uint32_t l_416 = 1UL;
            struct S0 *l_433 = &g_434;
            int32_t *l_467 = &g_63;
            for (l_337 = 0; (l_337 != 50); l_337 += 1)
            { /* block id: 156 */
                int32_t l_415 = 0x8C9D5AEEL;
                (**l_270) = ((uint16_t)((uint16_t)(((4294967295UL || ((int64_t)((int16_t)((int16_t)(((**l_270) | 1UL) <= 65531UL) % (int16_t)(1L || (((p_50 < ((**g_79) != (void*)0)) != ((int16_t)(((int32_t)(**l_270) / (int32_t)0xC9CADE45L) < 4294967292UL) / (int16_t)0xD1F5L)) != 0xEA80D7BFL))) << (int16_t)2) - (int64_t)p_51)) <= p_51) & l_415) >> (uint16_t)9) >> (uint16_t)13);
                (**l_234) = ((*l_252) <= l_416);
                for (p_51 = 21; (p_51 >= 9); p_51 -= 1)
                { /* block id: 161 */
                    (*l_234) = (*l_234);
                    (*l_234) = (*l_270);
                    (***g_78) = (**g_79);
                }
            }
            if ((((int64_t)(((((uint16_t)(g_205.f6 >= (0xDEB38E52DD0C4F64LL > (0x30096BF941106FE5LL > ((int64_t)(-(int64_t)(*l_252)) + (int64_t)((uint32_t)(((((int16_t)((((((void*)0 == &g_340) || ((int16_t)g_230.f5 >> (int16_t)3)) != g_236.f5) > g_205.f0) || 0xB4A0L) / (int16_t)3UL) != 0xE4F28C9FL) & l_432) & 0xF95636F13C25BEEELL) / (uint32_t)g_342.f6))))) << (uint16_t)14) & p_51) >= g_342.f5) < 0x3FE81FB4L) / (int64_t)0x6AFF3CF337403DDDLL) != 0x615FL))
            { /* block id: 167 */
                struct S0 *l_435 = &g_436;
                l_435 = l_433;
                /* statement id: 168 */
                assert (l_435 == &g_434);
            }
            else
            { /* block id: 169 */
                uint32_t l_447 = 4294967287UL;
                const float ***l_450 = &l_352;
                (*g_59) = ((uint16_t)((int16_t)p_47 << (int16_t)9) % (uint16_t)((uint64_t)((p_51 < (((int16_t)((g_11.f5 != 65533UL) || ((uint64_t)l_447 - (uint64_t)((uint64_t)g_236.f3 - (uint64_t)(0xCDB6E9C6L < ((0UL <= (((*l_350) != l_450) & 0x34D7L)) ^ g_14.f2))))) + (int16_t)0xF61AL) == g_230.f5)) <= p_51) - (uint64_t)18446744073709551608UL));
                if ((*g_59))
                { /* block id: 171 */
                    int32_t l_453 = (-2L);
                    (*g_59) = ((int64_t)(((0xAEED038FL <= l_453) != (g_194.f4 > ((uint16_t)(((int32_t)((int32_t)(g_342.f2 >= (((uint16_t)((int32_t)(-6L) / (int32_t)(**l_234)) >> (uint16_t)1) >= ((((uint64_t)((void*)0 != (*g_80)) + (uint64_t)l_447) & p_49) | l_453))) + (int32_t)0x469C46D6L) % (int32_t)(**l_270)) & g_205.f3) << (uint16_t)g_236.f3))) == l_447) + (int64_t)g_11.f0);
                    (*l_270) = &g_63;
                    return p_50;
                    /* statement id: 174 */
                    //assert (g_339 == &g_340 || g_339 == dangling);
                }
                else
                { /* block id: 175 */
                    int16_t l_466 = 0x0076L;
                    (*l_252) = (-1L);
                    (*g_201) = l_466;
                }
                (*g_201) = ((**l_270) >= (l_247 != (void*)0));
            }
            (*l_234) = l_467;
            (***g_199) = ((0xA.6AD5E1p+5 <= ((-(float)(((0x3.4B6736p+82 != p_50) < 0x2.443F57p+37) != p_51)) == ((-0x1.Fp-1) < ((*g_201) == ((float)((**l_234) > (**g_200)) / (float)(*g_201)))))) <= p_50);
        }
        (*l_252) = (-(uint16_t)65535UL);
        for (g_215 = 0; (g_215 != 5); g_215++)
        { /* block id: 187 */
            (*g_80) = (**g_79);
        }
    }
    else
    { /* block id: 190 */
        struct S0 ***l_474 = &g_80;
        (**g_200) = (-0x1.3p+1);
        (*g_78) = l_474;
    }
    /* facts after branching */
    //assert (g_339 == &g_340 || g_339 == dangling);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_14.f5 g_63 g_78 g_11.f0 g_14.f0 g_11.f2 g_22 g_11.f5 g_14.f2 g_79 g_80 g_10 g_59 g_199 g_200 g_201 g_205.f2 g_194.f6 g_205.f3 g_215 g_224
 * writes: g_63 g_22 g_59 g_10
 */
static uint64_t  func_52(int32_t * p_53, int32_t  p_54, int32_t  p_55, struct S0 *** p_56, int32_t * p_57)
{ /* block id: 8 */
    const int64_t l_71 = 0x9DB5DF1D979388B3LL;
    struct S0 ***l_94 = &g_80;
    int32_t l_99 = (-1L);
    float *l_114 = &g_22;
    int16_t l_116 = 0xA816L;
    float l_163 = 0x0.5p+1;
    int32_t *l_181 = &l_99;
    struct S1 *l_204 = &g_205;
    struct S1 **l_203 = &l_204;
    float ***l_231 = (void*)0;
    float ****l_232 = &l_231;
    if (g_14.f5)
    { /* block id: 9 */
        int32_t *l_62 = &g_63;
        for (p_55 = 0; (p_55 != (-7)); p_55 -= 1)
        { /* block id: 12 */
            int32_t *l_64 = (void*)0;
            l_64 = l_62;
            /* statement id: 13 */
            assert (l_64 == &g_63);
            if ((((uint16_t)((((0x4357240EL <= p_54) < ((0xDEDCL || ((uint16_t)(((0x9E5FL < (l_71 >= ((int64_t)(((uint16_t)p_54 << (uint16_t)8) < ((((uint16_t)((*l_64) >= ((g_78 != (void*)0) || g_11.f0)) >> (uint16_t)g_63) < (*l_64)) > 0xFB7192EEL)) / (int64_t)g_14.f0))) || (*l_64)) && 4UL) << (uint16_t)p_55)) >= 0x3AD2D1E5L)) < (*l_64)) && 0x36F7EBA052C4540ELL) - (uint16_t)65535UL) == p_55))
            { /* block id: 14 */
                (*l_62) = ((int16_t)((uint64_t)((((uint16_t)(((uint16_t)((1L >= (0UL ^ (((uint32_t)(((-7L) || ((int64_t)p_55 - (int64_t)(5UL ^ (2L && (-(int64_t)(p_55 > ((void*)0 != l_94))))))) | 0x96224A10L) / (uint32_t)g_14.f0) | g_11.f0))) ^ l_71) / (uint16_t)g_11.f0) == p_54) << (uint16_t)10) | 0UL) > 0x71B3L) % (uint64_t)1UL) / (int16_t)0x0E34L);
                return p_55;
            }
            else
            { /* block id: 17 */
                float l_97 = 0x0.Ep-1;
                const int32_t l_98 = 7L;
                l_99 = ((((float)0x2.9E9DC6p-5 - (float)(0x7.D413EDp+18 >= ((p_55 <= l_71) < ((*l_62) >= (g_11.f0 < ((-0x1.Cp-1) <= ((-0x10.4p+1) == (l_97 == 0x5.4FC7A5p-81)))))))) < 0x1.C8B7CFp+66) >= l_98);
                return p_54;
            }
        }
        (*l_62) = 0x064EC4FEL;
    }
    else
    { /* block id: 23 */
        int32_t l_109 = (-8L);
        float l_115 = 0x1.4p+1;
        l_99 = ((float)((float)(-(float)(((((float)l_99 / (float)((float)(0x9.7DC757p-44 >= (((l_109 == ((float)(((((float)0xD.81A3A0p+90 - (float)(l_114 != p_57)) >= ((0x1.Bp-1 >= (l_115 < ((((((0x1.0B78A1p+85 != g_11.f0) < l_99) == g_14.f5) != l_71) <= g_11.f2) == g_14.f5))) >= (-0x1.Fp-1))) != 0x6.1D701Dp+58) != p_54) - (float)p_54)) < l_116) >= 0x1.4p-1)) + (float)g_11.f2)) < l_116) > g_22) > p_55)) - (float)l_109) - (float)p_55);
        (*l_114) = g_11.f5;
    }
    if ((1UL & g_63))
    { /* block id: 27 */
        int32_t **l_117 = &g_59;
        (*l_117) = &l_99;
        /* statement id: 28 */
        assert (g_59 == &l_99);
    }
    else
    { /* block id: 29 */
        int32_t l_125 = 0xE2CA422CL;
        uint16_t l_162 = 65529UL;
        int32_t *l_183 = &l_125;
        struct S0 *l_229 = &g_230;
        if ((((uint16_t)65535UL << (uint16_t)8) || ((uint32_t)(((uint16_t)((0xE311AEEC80A0586BLL < g_14.f2) != (l_114 == p_53)) << (uint16_t)6) <= (p_55 | (-(int64_t)l_125))) - (uint32_t)g_14.f5)))
        { /* block id: 30 */
            int32_t **l_126 = &g_59;
            (*l_126) = &g_63;
            /* statement id: 31 */
            assert (g_59 == &g_63);
        }
        else
        { /* block id: 32 */
            float l_139 = 0x2.7EF061p+28;
            uint16_t l_141 = 0x47ACL;
            float l_170 = 0x0.6p+1;
            uint32_t l_178 = 1UL;
            int32_t l_206 = (-1L);
            if (((int16_t)(l_125 || ((uint16_t)((int32_t)((*g_79) != (void*)0) + (int32_t)0UL) >> (uint16_t)15)) + (int16_t)(p_54 > (((int16_t)(((p_53 == p_53) >= ((int32_t)l_125 - (int32_t)(-(uint32_t)((1UL != 0xB4A57D0CF7338C8BLL) && 1L)))) > l_116) >> (int16_t)5) == l_141))))
            { /* block id: 33 */
                l_125 = (!(~0xCB8EL));
            }
            else
            { /* block id: 35 */
                float **l_145 = &l_114;
                float ***l_144 = &l_145;
                int32_t l_190 = 0x1A25AED9L;
                const struct S1 *l_193 = &g_194;
                (*l_144) = &l_114;
                (***l_144) = ((float)(g_14.f2 != (-0x1.5p+1)) / (float)(g_11.f2 >= ((((float)((((float)(0x1.8p-1 <= 0x6.218FE4p+90) - (float)((float)(((void*)0 != l_114) < (((float)((float)((float)(0x5.F0C6F3p+98 > ((float)(l_162 != p_55) - (float)l_141)) + (float)p_55) - (float)p_54) / (float)l_163) <= g_14.f0)) / (float)g_14.f0)) > p_54) != (-0x1.3p+1)) / (float)0x1.Bp+1) == 0x2.EEC976p-30) > p_54)));
                g_59 = &g_63;
                /* statement id: 38 */
                assert (g_59 == &g_63);
                if (((int64_t)3L + (int64_t)((((uint16_t)65527UL >> (uint16_t)(((((**p_56) != (***g_78)) <= ((uint16_t)((*g_59) != ((-(uint64_t)1UL) & (((uint64_t)((int32_t)l_125 / (int32_t)((int64_t)g_14.f5 / (int64_t)g_14.f5)) + (uint64_t)0UL) >= g_14.f5))) - (uint16_t)l_178)) < 4294967295UL) != l_162)) <= g_14.f2) < g_11.f5)))
                { /* block id: 39 */
                    for (g_63 = (-25); (g_63 == (-28)); g_63 -= 5)
                    { /* block id: 42 */
                        int32_t *l_182 = &l_125;
                        l_181 = &g_63;
                        /* statement id: 43 */
                        assert (l_181 == &g_63);
                        l_183 = l_182;
                        (**l_145) = ((float)((*l_183) < ((*l_182) > ((((0x6.Ep-1 == (*l_183)) == 0x0.56E8D1p-65) > (p_55 < (((float)(((float)(&p_56 != &g_79) + (float)0x9.53BCE1p+8) <= 0x8.F538CCp-19) + (float)l_190) > 0x1.2p+1))) <= 0x1.Bp+1))) / (float)p_55);
                    }
                    /* facts after for loop */
                    assert (l_181 == &g_63 || l_181 == &l_99);
                    for (l_162 = 15; (l_162 != 45); l_162 += 3)
                    { /* block id: 49 */
                        const struct S1 **l_195 = &l_193;
                        int32_t **l_196 = &l_183;
                        (**g_79) = (**p_56);
                        (*l_195) = l_193;
                        (*l_196) = &g_63;
                        /* statement id: 52 */
                        assert (l_183 == &g_63);
                    }
                    /* facts after for loop */
                    assert (l_183 == &g_63 || l_183 == &l_125);
                    g_59 = &g_63;
                }
                else
                { /* block id: 55 */
                    l_206 = ((((float)((((p_54 < ((void*)0 != g_199)) > (-(float)((void*)0 != l_203))) < (**g_200)) == (*l_183)) + (float)((void*)0 == &g_79)) != (**g_200)) < 0x5.4p+1);
                    return l_190;
                }
                /* facts after branching */
                assert (l_181 == &g_63 || l_181 == &l_99);
                assert (l_183 == &g_63 || l_183 == &l_125);
            }
            /* facts after branching */
            assert (g_59 == &g_63 || g_59 == 0);
            assert (l_181 == &g_63 || l_181 == &l_99);
            assert (l_183 == &g_63 || l_183 == &l_125);
            (**l_94) = (void*)0;
            /* statement id: 60 */
            assert (g_10 == 0);
            for (l_125 = (-8); (l_125 > (-4)); l_125 += 6)
            { /* block id: 63 */
                float l_209 = 0x0.6p+1;
                (*l_203) = (void*)0;
                /* statement id: 64 */
                assert (l_204 == 0);
                if (l_178)
                    break;
                if (g_205.f2)
                    break;
                (*l_181) = ((g_14.f2 > (g_194.f6 < g_205.f3)) <= ((0x504BL || ((p_55 == ((*l_181) <= 0x89021812L)) > ((((uint32_t)(g_14.f5 | (((uint16_t)(-(uint32_t)1UL) % (uint16_t)g_215) >= p_55)) % (uint32_t)p_54) != (*l_183)) >= 0x1F00L))) != p_55));
            }
            /* facts after for loop */
            assert (l_204 == 0 || l_204 == &g_205);
            for (p_55 = 0; (p_55 != (-25)); p_55 -= 1)
            { /* block id: 71 */
                (*l_114) = (0x0.6p+1 != (*g_201));
                p_57 = &l_99;
                /* statement id: 73 */
                assert (p_57 == &l_99);
            }
            /* facts after for loop */
            assert (p_57 == &l_99 || p_57 == 0);
        }
        /* facts after branching */
        assert (g_10 == 0 || g_10 == &g_11);
        assert (g_59 == &g_63 || g_59 == 0);
        assert (p_57 == &l_99 || p_57 == 0);
        assert (l_181 == &g_63 || l_181 == &l_99);
        assert (l_183 == &g_63 || l_183 == &l_125);
        assert (l_204 == 0 || l_204 == &g_205);
        (*g_201) = ((float)(((float)(((*l_183) >= ((***g_199) > ((float)0x9.600016p+80 + (float)((void*)0 == g_224)))) > ((float)(((p_55 != (0xC.AF0680p+49 > (**g_200))) >= ((*l_183) > (**g_200))) <= (*l_183)) + (float)(*g_201))) + (float)(*l_181)) == p_54) - (float)(*l_183));
        l_229 = l_229;
    }
    /* facts after branching */
    assert (g_10 == 0 || g_10 == &g_11);
    assert (g_59 == &g_63 || g_59 == 0 || g_59 == &l_99);
    assert (p_57 == &l_99 || p_57 == 0);
    assert (l_181 == &g_63 || l_181 == &l_99);
    assert (l_204 == 0 || l_204 == &g_205);
    (*l_232) = l_231;
    return p_55;
    /* statement id: 80 */
    //assert (g_59 == &g_63 || g_59 == 0 || g_59 == dangling);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_11.f0, "g_11.f0", print_hash_value);
    transparent_crc(g_11.f1, "g_11.f1", print_hash_value);
    transparent_crc(g_11.f2, "g_11.f2", print_hash_value);
    transparent_crc(g_11.f3, "g_11.f3", print_hash_value);
    transparent_crc(g_11.f4, "g_11.f4", print_hash_value);
    transparent_crc(g_11.f5, "g_11.f5", print_hash_value);
    transparent_crc(g_14.f0, "g_14.f0", print_hash_value);
    transparent_crc(g_14.f1, "g_14.f1", print_hash_value);
    transparent_crc(g_14.f2, "g_14.f2", print_hash_value);
    transparent_crc(g_14.f3, "g_14.f3", print_hash_value);
    transparent_crc(g_14.f4, "g_14.f4", print_hash_value);
    transparent_crc(g_14.f5, "g_14.f5", print_hash_value);
    transparent_crc_bytes (&g_22, sizeof(g_22), "g_22", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_194.f0, "g_194.f0", print_hash_value);
    transparent_crc(g_194.f1, "g_194.f1", print_hash_value);
    transparent_crc(g_194.f2, "g_194.f2", print_hash_value);
    transparent_crc(g_194.f3, "g_194.f3", print_hash_value);
    transparent_crc(g_194.f4, "g_194.f4", print_hash_value);
    transparent_crc(g_194.f5, "g_194.f5", print_hash_value);
    transparent_crc(g_194.f6, "g_194.f6", print_hash_value);
    transparent_crc(g_205.f0, "g_205.f0", print_hash_value);
    transparent_crc(g_205.f1, "g_205.f1", print_hash_value);
    transparent_crc(g_205.f2, "g_205.f2", print_hash_value);
    transparent_crc(g_205.f3, "g_205.f3", print_hash_value);
    transparent_crc(g_205.f4, "g_205.f4", print_hash_value);
    transparent_crc(g_205.f5, "g_205.f5", print_hash_value);
    transparent_crc(g_205.f6, "g_205.f6", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    transparent_crc(g_226.f0, "g_226.f0", print_hash_value);
    transparent_crc(g_226.f1, "g_226.f1", print_hash_value);
    transparent_crc(g_226.f2, "g_226.f2", print_hash_value);
    transparent_crc(g_226.f3, "g_226.f3", print_hash_value);
    transparent_crc(g_226.f4, "g_226.f4", print_hash_value);
    transparent_crc(g_226.f5, "g_226.f5", print_hash_value);
    transparent_crc(g_226.f6, "g_226.f6", print_hash_value);
    transparent_crc(g_230.f0, "g_230.f0", print_hash_value);
    transparent_crc(g_230.f1, "g_230.f1", print_hash_value);
    transparent_crc(g_230.f2, "g_230.f2", print_hash_value);
    transparent_crc(g_230.f3, "g_230.f3", print_hash_value);
    transparent_crc(g_230.f4, "g_230.f4", print_hash_value);
    transparent_crc(g_230.f5, "g_230.f5", print_hash_value);
    transparent_crc(g_236.f0, "g_236.f0", print_hash_value);
    transparent_crc(g_236.f1, "g_236.f1", print_hash_value);
    transparent_crc(g_236.f2, "g_236.f2", print_hash_value);
    transparent_crc(g_236.f3, "g_236.f3", print_hash_value);
    transparent_crc(g_236.f4, "g_236.f4", print_hash_value);
    transparent_crc(g_236.f5, "g_236.f5", print_hash_value);
    transparent_crc(g_236.f6, "g_236.f6", print_hash_value);
    transparent_crc(g_342.f0, "g_342.f0", print_hash_value);
    transparent_crc(g_342.f1, "g_342.f1", print_hash_value);
    transparent_crc(g_342.f2, "g_342.f2", print_hash_value);
    transparent_crc(g_342.f3, "g_342.f3", print_hash_value);
    transparent_crc(g_342.f4, "g_342.f4", print_hash_value);
    transparent_crc(g_342.f5, "g_342.f5", print_hash_value);
    transparent_crc(g_342.f6, "g_342.f6", print_hash_value);
    transparent_crc_bytes (&g_346, sizeof(g_346), "g_346", print_hash_value);
    transparent_crc(g_358, "g_358", print_hash_value);
    transparent_crc(g_434.f0, "g_434.f0", print_hash_value);
    transparent_crc(g_434.f1, "g_434.f1", print_hash_value);
    transparent_crc(g_434.f2, "g_434.f2", print_hash_value);
    transparent_crc(g_434.f3, "g_434.f3", print_hash_value);
    transparent_crc(g_434.f4, "g_434.f4", print_hash_value);
    transparent_crc(g_434.f5, "g_434.f5", print_hash_value);
    transparent_crc(g_436.f0, "g_436.f0", print_hash_value);
    transparent_crc(g_436.f1, "g_436.f1", print_hash_value);
    transparent_crc(g_436.f2, "g_436.f2", print_hash_value);
    transparent_crc(g_436.f3, "g_436.f3", print_hash_value);
    transparent_crc(g_436.f4, "g_436.f4", print_hash_value);
    transparent_crc(g_436.f5, "g_436.f5", print_hash_value);
    transparent_crc(g_479.f0, "g_479.f0", print_hash_value);
    transparent_crc(g_479.f1, "g_479.f1", print_hash_value);
    transparent_crc(g_479.f2, "g_479.f2", print_hash_value);
    transparent_crc(g_479.f3, "g_479.f3", print_hash_value);
    transparent_crc(g_479.f4, "g_479.f4", print_hash_value);
    transparent_crc(g_479.f5, "g_479.f5", print_hash_value);
    transparent_crc(g_484, "g_484", print_hash_value);
    transparent_crc(g_512.f0, "g_512.f0", print_hash_value);
    transparent_crc(g_512.f1, "g_512.f1", print_hash_value);
    transparent_crc(g_512.f2, "g_512.f2", print_hash_value);
    transparent_crc(g_512.f3, "g_512.f3", print_hash_value);
    transparent_crc(g_512.f4, "g_512.f4", print_hash_value);
    transparent_crc(g_512.f5, "g_512.f5", print_hash_value);
    transparent_crc(g_546, "g_546", print_hash_value);
    transparent_crc(g_569, "g_569", print_hash_value);
    transparent_crc(g_603.f0, "g_603.f0", print_hash_value);
    transparent_crc(g_603.f1, "g_603.f1", print_hash_value);
    transparent_crc(g_603.f2, "g_603.f2", print_hash_value);
    transparent_crc(g_603.f3, "g_603.f3", print_hash_value);
    transparent_crc(g_603.f4, "g_603.f4", print_hash_value);
    transparent_crc(g_603.f5, "g_603.f5", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 126
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 47

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 192
   depth: 2, occurrence: 31
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 35, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 121

XXX times a variable address is taken: 124
XXX times a pointer is dereferenced on RHS: 118
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 42
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 78
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
XXX times a pointer is compared with null: 33
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 254

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 164
   level: 2, occurrence: 78
   level: 3, occurrence: 14
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 19.8
XXX average alias set size: 1.15

XXX times a non-volatile is read: 685
XXX times a non-volatile is write: 227
XXX times a volatile is read: 9
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 68
XXX percentage of non-volatile access: 99

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 165
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 29
   depth: 2, occurrence: 29
   depth: 3, occurrence: 27
   depth: 4, occurrence: 26
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 21
XXX percentage an existing variable is used: 79
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

