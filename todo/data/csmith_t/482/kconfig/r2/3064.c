/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3364212831
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_33(void);
inline static int32_t * func_34(const uint8_t  p_35, int32_t  p_36, uint32_t  p_37, int16_t  p_38, int64_t  p_39);
inline static int32_t  func_48(int32_t  p_49, int16_t  p_50, int32_t  p_51);
static int16_t  func_52(int32_t * p_53, int32_t * p_54, const int64_t  p_55, uint8_t  p_56, uint16_t  p_57);
static int16_t  func_58(uint32_t  p_59);
static const int32_t * func_71(int32_t ** p_72, uint8_t  p_73, int64_t  p_74, int32_t ** p_75, int32_t * p_76);
static int32_t ** func_77(uint32_t  p_78);
static uint32_t  func_79(int32_t **** p_80);
static int32_t * func_85(uint32_t  p_86, const uint32_t  p_87);
static int16_t  func_92(int64_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_33(void)
{ /* block id: 36 */
    int16_t l_40 = 0xF4E2L;
    int32_t l_578 = 0x364DB44FL;
    int32_t *l_577 = &l_578;
    int32_t **l_576 = &l_577;
    (*l_576) = func_34((l_40 == l_40), l_40, l_40, l_40, l_40);
    /* statement id: 411 */
    assert (l_577 == 0);
    return l_578;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_34(const uint8_t  p_35, int32_t  p_36, uint32_t  p_37, int16_t  p_38, int64_t  p_39)
{ /* block id: 37 */
    int32_t l_47 = (-9L);
    int32_t *l_574 = &l_47;
    int32_t *l_575 = (void*)0;
    if (((((uint16_t)((uint32_t)((int64_t)0x46773196E86FF18ELL - (int64_t)l_47) % (uint32_t)func_48(l_47, (func_52(&l_47, &l_47, (func_58(p_37) > (8UL < func_92(((__builtin_popcount(p_37) == p_39) || l_47)))), l_47, p_36) < l_47), l_47)) % (uint16_t)p_35) <= l_47) & p_36))
    { /* block id: 405 */
        uint64_t l_566 = 0x85A87557A66DFB4BLL;
        int32_t *l_570 = (void*)0;
        int32_t **l_569 = &l_570;
        (*l_569) = func_85(l_566, ((int16_t)(l_47 || 4294967295UL) << (int16_t)p_39));
    }
    else
    { /* block id: 407 */
        float *l_571 = (void*)0;
        float l_573 = (-0x1.Dp-1);
        float *l_572 = &l_573;
        (*l_572) = l_47;
    }
    return l_575;
    /* statement id: 410 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_48(int32_t  p_49, int16_t  p_50, int32_t  p_51)
{ /* block id: 401 */
    int32_t * const l_559 = (void*)0;
    int32_t l_562 = 0x44C14198L;
    int32_t *l_561 = &l_562;
    int32_t **l_560 = &l_561;
    int32_t ***l_565 = &l_560;
    int32_t ****l_564 = &l_565;
    int32_t *****l_563 = &l_564;
    (*l_560) = l_559;
    /* statement id: 402 */
    assert (l_561 == 0);
    l_563 = l_563;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_52(int32_t * p_53, int32_t * p_54, const int64_t  p_55, uint8_t  p_56, uint16_t  p_57)
{ /* block id: 356 */
    uint32_t l_493 = 0UL;
    int32_t *l_494 = (void*)0;
    int32_t *l_495 = (void*)0;
    int32_t l_497 = 0xD7738B13L;
    int32_t *l_496 = &l_497;
    int32_t **l_498 = &l_494;
    int32_t *** const **l_501 = (void*)0;
    float l_556 = 0x0.1p+1;
    float *l_555 = &l_556;
    float **l_554 = &l_555;
    (*l_496) = l_493;
    (*l_498) = func_85(p_55, p_56);
    (*l_498) = p_53;
    /* statement id: 359 */
    //assert (l_494 == &l_47);
    if (((uint32_t)(*l_496) / (uint32_t)func_92((l_501 == l_501))))
    { /* block id: 360 */
        uint32_t l_504 = 18446744073709551606UL;
        float l_508 = 0x1.4p-1;
        float *l_507 = &l_508;
        l_504 = ((uint64_t)0xB155530BCC405343LL + (uint64_t)p_57);
        (*l_507) = ((float)p_57 / (float)p_56);
        (*l_496) = 0x525B2511L;
        (*l_496) = (p_55 ^ (0x4737L & ((**l_498) || __builtin_parityl(p_55))));
    }
    else
    { /* block id: 365 */
        int16_t l_517 = 0x8DA8L;
        uint64_t l_544 = 0x11B8F87EE88716B3LL;
        int32_t *l_547 = &l_497;
        int32_t ***l_552 = &l_498;
        int32_t ****l_551 = &l_552;
        int32_t *****l_550 = &l_551;
        if ((*p_54))
        { /* block id: 366 */
            int64_t l_522 = 0x85BA2E1E8E701A6FLL;
            float l_542 = 0xA.12C4D5p-17;
            float *l_541 = &l_542;
            int32_t **l_548 = (void*)0;
            int32_t **l_549 = &l_496;
            int32_t *****l_553 = &l_551;
            for (l_493 = 0; (l_493 == 35); ++l_493)
            { /* block id: 369 */
                int32_t l_539 = (-1L);
                if ((!0xC70C7156L))
                { /* block id: 370 */
                    uint8_t l_512 = 0x0BL;
                    l_512 = 0x5929073EL;
                    if (func_58(p_55))
                    { /* block id: 372 */
                        float **l_516 = (void*)0;
                        float ***l_515 = &l_516;
                        float ****l_514 = &l_515;
                        float *****l_513 = &l_514;
                        (*l_513) = (void*)0;
                        /* statement id: 373 */
                        assert (l_514 == 0);
                    }
                    else
                    { /* block id: 374 */
                        (*l_498) = func_85(l_517, p_55);
                        /* statement id: 375 */
                        assert (l_494 == 0);
                        (*l_498) = (void*)0;
                        return p_57;
                    }
                    return p_57;
                }
                else
                { /* block id: 380 */
                    uint16_t l_520 = 0xA506L;
                    float l_524 = 0x4.9p-1;
                    float *l_523 = &l_524;
                    (*l_523) = __builtin_clz((((uint16_t)l_520 - (uint16_t)(-(uint64_t)l_522)) == 1UL));
                    (*l_498) = p_54;
                    for (p_57 = (-17); (p_57 != 32); ++p_57)
                    { /* block id: 385 */
                        float l_531 = (-0x1.Bp-1);
                        int32_t ***l_533 = &l_498;
                        int32_t ****l_532 = &l_533;
                        int32_t l_540 = 0x2A3C418BL;
                        (*l_523) = ((((float)((float)(-0x2.6p-1) + (float)p_57) - (float)func_92(((p_56 && (((p_55 ^ func_79(l_532)) && (p_57 && (((int16_t)(((int16_t)((-(int16_t)p_56) && (__builtin_popcountl((0x92C3CA4DEB1430C3LL & p_57)) && p_57)) % (int16_t)p_55) < (-1L)) >> (int16_t)2) <= p_57))) ^ l_539)) <= l_540))) == l_520) >= l_539);
                        /* statement id: 386 */
                        //assert (l_494 == &l_47 || l_494 == 0);
                        return l_522;
                    }
                }
            }
            (*l_541) = l_522;
            (*l_549) = func_71(func_77((+p_57)), l_544, ((uint16_t)0xC467L >> (uint16_t)15), func_77((l_522 != (p_53 == (void*)0))), l_547);
            /* statement id: 392 */
            assert (l_496 == 0 || l_496 == &l_497);
            l_553 = l_550;
        }
        else
        { /* block id: 394 */
            float ***l_557 = (void*)0;
            float **l_558 = &l_555;
            l_558 = l_554;
        }
        /* facts after branching */
        assert (l_496 == 0 || l_496 == &l_497);
        (*l_547) = (p_55 != p_57);
        return p_56;
    }
    return (**l_498);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_58(uint32_t  p_59)
{ /* block id: 38 */
    int32_t l_62 = 0x6FC75DFCL;
    int32_t *l_61 = &l_62;
    int32_t ** const l_60 = &l_61;
    int32_t * const *l_64 = &l_61;
    int32_t * const **l_63 = &l_64;
    float l_492 = 0x8.65C1BDp-18;
    (*l_63) = l_60;
    for (l_62 = 0; (l_62 != (-28)); --l_62)
    { /* block id: 42 */
        uint64_t l_450 = 0UL;
    }
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_71(int32_t ** p_72, uint8_t  p_73, int64_t  p_74, int32_t ** p_75, int32_t * p_76)
{ /* block id: 322 */
    int32_t **l_453 = (void*)0;
    int32_t **l_454 = (void*)0;
    int32_t l_456 = 0x91B52A4FL;
    int32_t *l_455 = &l_456;
    l_455 = (void*)0;
    /* statement id: 323 */
    assert (l_455 == 0);
    for (p_73 = (-26); (p_73 != 39); p_73 += 5)
    { /* block id: 326 */
        uint16_t l_472 = 65534UL;
        int32_t ***l_474 = &l_454;
        int32_t ****l_473 = &l_474;
        int32_t *l_490 = &l_456;
        for (p_74 = 3; (p_74 < (-7)); --p_74)
        { /* block id: 329 */
            int32_t l_465 = 0x610D7CE3L;
            int32_t *****l_489 = &l_473;
            for (l_456 = (-5); (l_456 <= (-24)); l_456 -= 4)
            { /* block id: 332 */
                const int32_t *l_464 = (void*)0;
                const int32_t **l_463 = &l_464;
                (*l_463) = (void*)0;
                (*l_463) = func_85(l_465, (((uint64_t)__builtin_parity(l_465) + (uint64_t)p_74) > 0xB396DBAAEF4B3A1ELL));
            }
            if ((((uint16_t)1UL - (uint16_t)((int16_t)l_465 >> (int16_t)((0xE739L == l_472) & 0x601FL))) ^ (l_472 || ((p_74 || p_74) | p_74))))
            { /* block id: 336 */
                int32_t **l_475 = &l_455;
                (*l_475) = &l_465;
                /* statement id: 337 */
                assert (l_455 == &l_465);
            }
            else
            { /* block id: 338 */
                float l_483 = 0x4.243F2Cp-8;
                float *l_482 = &l_483;
                float **l_481 = &l_482;
                float ***l_480 = &l_481;
                int32_t **l_484 = (void*)0;
                int32_t **l_485 = (void*)0;
                int32_t **l_486 = (void*)0;
                p_76 = func_85(((int64_t)((uint16_t)__builtin_bswap32(p_73) + (uint16_t)(p_73 ^ (l_480 == &l_481))) / (int64_t)(6UL & 0xA76BD4EDL)), p_73);
                /* statement id: 339 */
                assert (p_76 == 0);
                l_456 = ((uint32_t)(l_489 == (void*)0) / (uint32_t)(__builtin_popcountl(p_74) ^ 4294967295UL));
                if (p_73)
                    continue;
                if (l_465)
                    continue;
            }
            /* facts after branching */
            //assert (l_455 == 0 || l_455 == dangling || l_455 == &l_465);
        }
        if (l_472)
            break;
        (*l_490) = (&l_454 == (void*)0);
    }
    /* facts after for loop */
    //assert (l_455 == 0 || l_455 == dangling);
    return p_76;
    /* statement id: 348 */
    //assert (func_71_rv == 0 || func_71_rv == &l_497);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_77(uint32_t  p_78)
{ /* block id: 246 */
    float l_371 = 0x0.1p+1;
    int32_t *l_373 = (void*)0;
    int32_t **l_372 = &l_373;
    int32_t l_374 = 0x30915EE7L;
    const uint32_t l_375 = 0xD6DC492EL;
    int32_t **l_382 = &l_373;
    int32_t ***l_400 = (void*)0;
    int32_t ****l_399 = &l_400;
    int32_t **l_446 = &l_373;
    int32_t **l_447 = &l_373;
    int32_t **l_448 = &l_373;
    int32_t **l_449 = (void*)0;
    if (((p_78 & (l_372 != &l_373)) <= l_374))
    { /* block id: 247 */
        int32_t *l_377 = &l_374;
        int32_t **l_384 = (void*)0;
        float *l_401 = &l_371;
        uint32_t l_408 = 0xE06D0921L;
        if ((p_78 <= 0xA94AL))
        { /* block id: 248 */
            int32_t **l_378 = &l_373;
            int32_t **l_379 = &l_377;
            int32_t **l_381 = &l_377;
            if (l_375)
            { /* block id: 249 */
                int32_t *l_376 = (void*)0;
                (*l_372) = l_376;
                (*l_372) = l_377;
                /* statement id: 251 */
                assert (l_373 == &l_374);
                (*l_372) = l_377;
            }
            else
            { /* block id: 253 */
                int32_t **l_380 = &l_377;
                int32_t **l_383 = &l_373;
                return l_384;
                /* statement id: 254 */
                //assert (func_77_rv == 0);
            }
            /* facts after branching */
            assert (l_373 == &l_374);
            (*l_372) = (*l_372);
        }
        else
        { /* block id: 257 */
            int32_t ***l_396 = &l_384;
            int32_t ****l_395 = &l_396;
            (*l_377) = (p_78 == ((int16_t)p_78 + (int16_t)((int16_t)0x608FL >> (int16_t)2)));
            for (l_374 = 0; (l_374 != (-17)); l_374--)
            { /* block id: 261 */
                const int16_t l_397 = 0xFD6FL;
                for (p_78 = 0; (p_78 < 29); ++p_78)
                { /* block id: 264 */
                    float *l_398 = &l_371;
                    (*l_398) = ((float)0x9.8p+1 / (float)l_397);
                }
            }
        }
        /* facts after branching */
        assert (l_373 == 0 || l_373 == &l_374);
lbl_432:
        (*l_401) = (p_78 < p_78);
        if (p_78)
        { /* block id: 270 */
            int32_t *l_402 = (void*)0;
            (*l_372) = l_402;
            /* statement id: 271 */
            assert (l_373 == 0);
            (*l_372) = func_85((*l_377), (((void*)0 != &l_377) < (l_402 != (void*)0)));
            (*l_377) = (p_78 > (&l_402 != (void*)0));
            (*l_401) = p_78;
        }
        else
        { /* block id: 275 */
            float **l_404 = &l_401;
            float ***l_403 = &l_404;
            int32_t **l_414 = &l_373;
            int32_t l_416 = (-2L);
            (*l_372) = func_85(p_78, p_78);
            /* statement id: 276 */
            assert (l_373 == 0);
            (*l_403) = (void*)0;
            /* statement id: 277 */
            assert (l_404 == 0);
            if (p_78)
            { /* block id: 278 */
                uint32_t l_407 = 18446744073709551609UL;
                int32_t ****l_415 = &l_400;
                for (l_374 = (-4); (l_374 == 7); ++l_374)
                { /* block id: 281 */
                    uint16_t l_409 = 0xDAF9L;
                    (*l_382) = func_85(((__builtin_clzll(p_78) > l_407) ^ (l_408 <= (l_409 & ((uint32_t)((int64_t)((l_414 == (void*)0) > (p_78 != 0x717FFE84L)) / (int64_t)l_409) % (uint32_t)l_409)))), p_78);
                    (*l_414) = (*l_372);
                }
                l_416 = p_78;
                for (l_408 = 11; (l_408 == 23); ++l_408)
                { /* block id: 288 */
                    uint8_t l_428 = 0x92L;
                    (*l_414) = (*l_372);
                    (*l_401) = (+(((float)((float)p_78 + (float)p_78) - (float)((float)((float)p_78 / (float)(l_377 == (void*)0)) - (float)(p_78 <= ((p_78 >= p_78) >= l_428)))) >= l_428));
                }
            }
            else
            { /* block id: 292 */
                int16_t l_431 = 0L;
                for (l_374 = (-8); (l_374 >= (-13)); l_374--)
                { /* block id: 295 */
                    l_431 = 0x3365DDE0L;
                    if (l_408)
                        goto lbl_432;
                }
                (*l_372) = (*l_414);
            }
        }
        /* facts after branching */
        assert (l_373 == 0);
    }
    else
    { /* block id: 302 */
        uint32_t l_435 = 0x594629C2L;
        int32_t ****l_439 = &l_400;
        int32_t l_440 = 1L;
        for (p_78 = 4; (p_78 != 4); p_78 += 1)
        { /* block id: 305 */
            float *l_436 = (void*)0;
            float *l_437 = (void*)0;
            float *l_438 = &l_371;
            float * const *l_442 = &l_436;
            float * const **l_441 = &l_442;
            l_435 = p_78;
            (*l_438) = 0xD.6E3102p-47;
            if (p_78)
            { /* block id: 308 */
                (*l_372) = l_437;
            }
            else
            { /* block id: 310 */
                l_440 = (-1L);
            }
            (*l_441) = (void*)0;
            /* statement id: 313 */
            assert (l_442 == 0);
        }
    }
    for (l_374 = 7; (l_374 < (-25)); --l_374)
    { /* block id: 318 */
        int32_t **l_445 = (void*)0;
        return l_445;
        /* statement id: 319 */
        //assert (func_77_rv == 0);
    }
    return l_449;
    /* statement id: 321 */
    //assert (func_77_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_47
 * writes:
 */
static uint32_t  func_79(int32_t **** p_80)
{ /* block id: 50 */
    int32_t l_84 = 6L;
    int32_t *l_114 = &l_84;
    int32_t **l_216 = &l_114;
    int32_t ***l_215 = &l_216;
    int32_t ****l_214 = &l_215;
    int32_t *****l_213 = &l_214;
    int32_t *l_222 = &l_84;
    uint64_t l_285 = 18446744073709551613UL;
    uint32_t l_287 = 0x410983F1L;
    uint8_t l_334 = 0x78L;
    uint8_t l_369 = 253UL;
    uint16_t l_370 = 65531UL;
    if (l_84)
    { /* block id: 51 */
        int16_t l_98 = 0x29A0L;
        int32_t **l_99 = (void*)0;
        uint32_t l_146 = 0UL;
        uint32_t l_180 = 0x0D8FF0D0L;
        int32_t ***l_204 = &l_99;
        int32_t *** const *l_203 = &l_204;
        l_114 = func_85(((0xA77FL != ((uint64_t)(4UL <= 0L) - (uint64_t)l_84)) & ((void*)0 != (***p_80))), (func_92(((uint16_t)(l_84 || ((((((int64_t)l_98 - (int64_t)((**p_80) != l_99)) == (-7L)) & l_84) != l_84) == l_84)) % (uint16_t)65535UL)) >= (-10L)));
        /* statement id: 62 */
        assert (l_114 == 0);
        for (l_98 = (-17); (l_98 < 21); l_98 += 5)
        { /* block id: 65 */
            float l_123 = 0x4.BC85F6p-6;
            int32_t l_124 = 0x0150F896L;
            uint8_t l_145 = 4UL;
            uint32_t l_193 = 0x037E6CEEL;
            int32_t *l_211 = &l_84;
        }
    }
    else
    { /* block id: 120 */
        int32_t *l_219 = &l_84;
        int32_t l_221 = 0xEAD6AADDL;
        (***l_214) = (***p_80);
        /* statement id: 121 */
        //assert (l_114 == &l_62 || l_114 == &l_47);
        if (l_84)
            goto lbl_220;
lbl_220:
        (****l_213) = l_219;
        /* statement id: 122 */
        assert (l_114 == &l_84);
        return l_221;
    }
    /* facts after branching */
    assert (l_114 == 0);
    (*l_222) = (****p_80);
    for (l_84 = 0; (l_84 <= 6); l_84 += 6)
    { /* block id: 129 */
        uint8_t l_225 = 0xBAL;
        int32_t l_234 = 0xFBF4EFD3L;
        int32_t *l_233 = &l_234;
        const int64_t l_276 = 0xE0DADD7E3C66B9BCLL;
        float l_282 = 0x5.Cp+1;
    }
    if (((uint16_t)l_285 >> (uint16_t)3))
    { /* block id: 181 */
        int32_t l_286 = 1L;
        int32_t *l_294 = &l_286;
        float l_297 = 0xB.552267p-59;
        l_286 = (****p_80);
        if (l_287)
        { /* block id: 183 */
            int32_t l_288 = 0x2445B51BL;
            return l_288;
        }
        else
        { /* block id: 185 */
            (*l_222) = l_286;
        }
        for (l_287 = 22; (l_287 != 43); l_287 += 1)
        { /* block id: 190 */
            uint16_t l_291 = 1UL;
            l_291 = l_286;
            l_294 = func_85(((uint16_t)0x6A99L / (uint16_t)__builtin_popcountll(l_291)), ((void*)0 == (***p_80)));
            /* statement id: 192 */
            assert (l_294 == 0);
            (*l_222) = (((int16_t)((void*)0 == (*p_80)) - (int16_t)l_286) <= 0xBE60L);
        }
        /* facts after for loop */
        assert (l_294 == 0 || l_294 == &l_286);
        (***p_80) = (***l_214);
        /* statement id: 195 */
        //assert (l_61 == 0);
    }
    else
    { /* block id: 196 */
        int32_t l_306 = (-5L);
        uint32_t l_311 = 4294967290UL;
        int32_t * const l_312 = (void*)0;
        int32_t **l_313 = &l_222;
        int32_t l_324 = 0x8D2A354EL;
        uint8_t l_339 = 0UL;
        uint16_t l_354 = 0x8FFAL;
    }
    /* facts after branching */
    //assert (l_61 == &l_62 || l_61 == 0);
    return l_370;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_85(uint32_t  p_86, const uint32_t  p_87)
{ /* block id: 54 */
    const int32_t **l_102 = (void*)0;
    int32_t l_104 = 1L;
    int32_t *l_103 = &l_104;
    int32_t *l_105 = &l_104;
    int32_t *l_106 = &l_104;
    int32_t *l_107 = &l_104;
    int32_t *l_108 = &l_104;
    int32_t *l_109 = &l_104;
    int32_t *l_110 = &l_104;
    int32_t *l_111 = &l_104;
    int32_t *l_112 = &l_104;
    int32_t *l_113 = (void*)0;
    for (p_86 = 3; (p_86 >= 17); p_86 += 4)
    { /* block id: 57 */
        if (p_87)
            break;
    }
    l_103 = (void*)0;
    /* statement id: 60 */
    assert (l_103 == 0);
    return l_113;
    /* statement id: 61 */
    //assert (func_85_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_92(int64_t  p_93)
{ /* block id: 52 */
    return p_93;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 170
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 26
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 158

XXX times a variable address is taken: 138
XXX times a pointer is dereferenced on RHS: 55
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 7
   depth: 3, occurrence: 9
   depth: 4, occurrence: 12
XXX times a pointer is dereferenced on LHS: 93
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 3
   depth: 3, occurrence: 12
   depth: 4, occurrence: 5
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 658

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 139
   level: 2, occurrence: 106
   level: 3, occurrence: 69
   level: 4, occurrence: 89
   level: 5, occurrence: 18
XXX number of pointers point to pointers: 88
XXX number of pointers point to scalars: 70
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 35.4
XXX average alias set size: 1.16

XXX times a non-volatile is read: 595
XXX times a non-volatile is write: 288
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 124
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 28
   depth: 2, occurrence: 27
   depth: 3, occurrence: 20
   depth: 4, occurrence: 13
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 14.1
XXX percentage an existing variable is used: 85.9
********************* end of statistics **********************/

