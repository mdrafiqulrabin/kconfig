/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1915952261
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const uint16_t  f0;
   int64_t  f1;
   uint8_t  f2;
   int16_t  f3;
   uint32_t  f4;
   uint8_t  f5;
   uint8_t  f6;
   const uint16_t  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_28(void);
inline static const int32_t * const  func_32(int32_t * p_33, const uint32_t  p_34, int32_t  p_35, int32_t * const  p_36);
static int32_t  func_37(uint32_t  p_38);
inline static int16_t  func_39(int32_t * p_40, const struct S0  p_41);
inline static int32_t * func_42(int32_t * p_43, int32_t * p_44, struct S0  p_45, uint32_t  p_46, uint32_t  p_47);
static int32_t * func_48(struct S0  p_49, int32_t * p_50, uint8_t  p_51, struct S0  p_52);
inline static int32_t * func_54(uint16_t  p_55);
inline static uint16_t  func_62(uint32_t  p_63, struct S0  p_64, int32_t * p_65, uint16_t  p_66, uint8_t  p_67);
static uint32_t  func_72(uint16_t  p_73, int32_t * p_74, uint32_t  p_75, int32_t  p_76);
static int32_t  func_77(int32_t * p_78, int32_t  p_79, struct S0  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = 0x41637C1DL;
    struct S0 l_249 = {65529UL,0x6E787A2B99ADBD7DLL,0x9CL,0L,0x90A01309L,0x21L,254UL,1UL};
    struct S0 *l_376 = (void*)0;
    struct S0 **l_375 = &l_376;
    const uint64_t l_383 = 0x4B1A716BBA2241ECLL;
    int32_t *l_384 = &l_29;
    int16_t l_385 = 0x9BAAL;
    for (l_29 = 25; (l_29 <= (-15)); l_29 -= 1)
    { /* block id: 39 */
        struct S0 l_53 = {65535UL,1L,0x71L,-1L,0UL,1UL,252UL,0x5879L};
        uint32_t l_56 = 0x31364F2CL;
        int32_t * const l_309 = &l_29;
        int32_t *l_358 = &l_29;
        int32_t **l_357 = &l_358;
        (*l_357) = func_32(&l_29, l_29, func_37(((((void*)0 != &l_29) > ((func_39(func_42(func_48(l_53, func_54(l_56), l_53.f6, l_53), &l_29, l_249, l_249.f5, l_249.f2), l_53) != l_29) || l_249.f6)) <= 0x08C4L)), l_309);
        /* statement id: 261 */
        assert (l_358 == 0);
    }
    for (l_249.f6 = 28; (l_249.f6 >= 8); l_249.f6--)
    { /* block id: 265 */
        int16_t l_361 = 0x8E68L;
        float l_381 = 0x4.CBC77Cp-98;
        if (l_361)
        { /* block id: 266 */
            uint16_t l_364 = 0xFDCEL;
            float l_374 = 0x4.180B2Dp+67;
            float *l_373 = &l_374;
            (*l_373) = ((__builtin_ctzl(l_249.f0) > ((((float)l_364 - (float)((((float)(l_361 == ((float)(((float)(((float)((l_249.f6 <= __builtin_popcountll(l_249.f6)) < (0xE.0449A5p+60 <= l_364)) - (float)l_361) >= 0x8.0D89AAp+35) / (float)l_364) >= l_249.f7) + (float)l_29)) - (float)l_364) < 0xD.034F45p-43) == l_361)) <= l_249.f4) == l_361)) <= l_361);
        }
        else
        { /* block id: 268 */
            int32_t *l_382 = &l_29;
            (*l_382) = __builtin_popcount((func_72(l_249.f4, &l_29, ((void*)0 != l_375), l_361) | ((uint32_t)l_249.f5 + (uint32_t)((-9L) | ((uint64_t)(l_361 == l_249.f0) % (uint64_t)l_249.f5)))));
        }
        if (l_383)
            continue;
    }
    (*l_384) = l_249.f3;
    return l_385;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * const  func_32(int32_t * p_33, const uint32_t  p_34, int32_t  p_35, int32_t * const  p_36)
{ /* block id: 223 */
    int32_t l_323 = 0L;
    struct S0 l_337 = {0x65E9L,0x7CA1D27605DA0835LL,0xA4L,0x3D74L,3UL,9UL,1UL,9UL};
    struct S0 * const l_336 = &l_337;
    int32_t l_351 = 1L;
    int32_t *l_350 = &l_351;
    const int32_t * const l_354 = &l_351;
    const int32_t * const l_355 = &l_351;
    const int32_t * const l_356 = (void*)0;
    for (p_35 = 0; (p_35 != 0); p_35 += 1)
    { /* block id: 226 */
        int32_t l_314 = 0xB37BC6C6L;
        const int32_t *l_313 = &l_314;
        const int32_t **l_312 = &l_313;
        (*l_312) = func_54(p_34);
        /* statement id: 227 */
        assert (l_313 == 0);
        if ((*p_36))
            continue;
        for (l_314 = 0; (l_314 != (-4)); --l_314)
        { /* block id: 231 */
            uint8_t l_317 = 253UL;
            float l_319 = 0x0.6p-1;
            float *l_318 = &l_319;
            int32_t l_322 = 1L;
            int32_t *l_321 = &l_322;
            int32_t l_348 = (-7L);
            struct S0 l_352 = {0x1496L,0xEDC055292B819E5FLL,0xFCL,0xC9A3L,18446744073709551613UL,0x1CL,0xFAL,0x4A8FL};
            (*l_318) = l_317;
            (*l_321) = ((-(uint64_t)l_317) == p_35);
            if (((l_313 != (void*)0) != l_323))
            { /* block id: 234 */
                int32_t *l_329 = &l_322;
                (*l_312) = &l_322;
                /* statement id: 235 */
                assert (l_313 == &l_322);
                for (l_322 = 0; (l_322 <= (-24)); l_322 -= 3)
                { /* block id: 238 */
                    int32_t *l_326 = &l_322;
                    (*l_318) = (l_326 == &l_322);
                    if (((uint64_t)(&l_322 != l_329) / (uint64_t)((int16_t)p_35 / (int16_t)(-(int32_t)((!(*p_33)) < 0x76AC7A48D56101C7LL)))))
                    { /* block id: 240 */
                        int32_t l_335 = 0x238209FDL;
                        int32_t *l_334 = &l_335;
                        (*l_318) = (*l_321);
                        if ((*p_36))
                            break;
                        (*l_334) = (**l_312);
                    }
                    else
                    { /* block id: 244 */
                        struct S0 **l_338 = (void*)0;
                        struct S0 *l_340 = &l_337;
                        struct S0 **l_339 = &l_340;
                        int32_t l_341 = (-1L);
                        uint32_t l_344 = 9UL;
                        (*l_339) = l_336;
                        (*l_318) = (func_72(l_341, &l_314, (0x2D12L <= ((__builtin_clzl((((int16_t)(l_344 & p_34) + (int16_t)(((uint64_t)(~p_35) / (uint64_t)p_34) >= ((void*)0 == &p_35))) >= (*p_36))) <= p_34) && 1L)), (*p_36)) <= p_35);
                        l_348 = (p_35 <= l_341);
                    }
                }
                (*l_312) = (void*)0;
                /* statement id: 250 */
                assert (l_313 == 0);
                (*l_318) = p_35;
            }
            else
            { /* block id: 252 */
                int32_t *l_349 = &l_348;
                const int32_t * const l_353 = (void*)0;
                p_33 = func_48((*l_336), func_42(l_349, l_350, l_352, p_34, p_34), p_35, l_352);
                /* statement id: 253 */
                assert (p_33 == &l_348);
                (*l_312) = (*l_312);
                (*l_312) = &p_35;
                /* statement id: 255 */
                assert (l_313 == &p_35);
                return l_353;
                /* statement id: 256 */
                //assert (func_32_rv == 0);
            }
        }
    }
    return l_356;
    /* statement id: 260 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_37(uint32_t  p_38)
{ /* block id: 208 */
    int32_t l_297 = 0L;
    int32_t *l_296 = &l_297;
    if ((l_296 != &l_297))
    { /* block id: 209 */
        int32_t *l_298 = &l_297;
        int32_t **l_299 = &l_298;
        (*l_299) = l_298;
        (*l_298) = (*l_296);
        for (p_38 = (-10); (p_38 == 48); ++p_38)
        { /* block id: 214 */
            float l_303 = 0x2.4BAB36p-76;
            float *l_302 = &l_303;
            int32_t l_304 = 0xE831240EL;
            (*l_302) = (**l_299);
            (**l_299) = (5UL != (p_38 & l_304));
            (*l_296) = __builtin_ctzll((*l_296));
        }
    }
    else
    { /* block id: 219 */
        const struct S0 l_305 = {0UL,7L,0UL,0x22C5L,0xECB97538L,0UL,0x12L,0x0079L};
        float l_308 = 0x6.0p+1;
        float *l_307 = &l_308;
        (*l_307) = (__builtin_ia32_crc32qi(func_39(&l_297, l_305), (*l_296)) <= (!((func_39(&l_297, l_305) > p_38) > l_305.f0)));
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_39(int32_t * p_40, const struct S0  p_41)
{ /* block id: 203 */
    int32_t l_294 = 1L;
    int32_t *l_293 = &l_294;
    int32_t *l_295 = &l_294;
    (*l_293) = p_41.f4;
    l_295 = p_40;
    /* statement id: 205 */
    //assert (l_295 == 0 || l_295 == &l_297);
    l_295 = func_54(p_41.f0);
    /* statement id: 206 */
    assert (l_295 == 0);
    return p_41.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_42(int32_t * p_43, int32_t * p_44, struct S0  p_45, uint32_t  p_46, uint32_t  p_47)
{ /* block id: 173 */
    const int32_t l_250 = 1L;
    struct S0 l_251 = {0x55A8L,0x41CA8B2C8D88053DLL,1UL,0x1349L,0UL,0x29L,0x98L,0x76B8L};
    int32_t l_254 = 0x01AB67E0L;
    int32_t *l_253 = &l_254;
    int32_t **l_252 = &l_253;
    float l_256 = 0x3.71272Ep-87;
    float *l_255 = &l_256;
    const int32_t *l_260 = &l_254;
    int32_t l_264 = 0xFB57AB89L;
    const int32_t ****l_273 = (void*)0;
    (*l_252) = func_48(p_45, p_43, (p_45.f2 & l_250), l_251);
    /* statement id: 174 */
    //assert (l_253 == 0 || l_253 == &l_348);
    (*l_255) = p_47;
    for (l_251.f2 = 8; (l_251.f2 < 56); l_251.f2 += 1)
    { /* block id: 178 */
        const int32_t *l_259 = &l_254;
        struct S0 l_265 = {0xD8F9L,0x57E4DE94C89D1CEELL,0UL,0L,0x2BE84D80L,9UL,0x1CL,0UL};
        const float * const l_268 = &l_256;
        const float * const *l_267 = &l_268;
        l_260 = l_259;
        for (l_254 = (-10); (l_254 != (-16)); l_254--)
        { /* block id: 182 */
            float **l_279 = &l_255;
            float ***l_278 = &l_279;
            int32_t l_287 = 0L;
            if ((~(p_45.f3 < l_264)))
            { /* block id: 183 */
                int32_t *l_266 = &l_264;
                float * const *l_269 = &l_255;
                const int32_t **l_272 = &l_260;
                const int32_t ***l_271 = &l_272;
                const int32_t ****l_270 = &l_271;
                if ((*p_44))
                    break;
                (*l_252) = func_48(p_45, func_48(l_265, func_48(p_45, l_266, (l_267 != l_269), l_265), p_45.f3, p_45), p_47, p_45);
                /* statement id: 185 */
                assert (l_253 == &l_264);
                l_273 = l_270;
                /* statement id: 186 */
                assert (l_273 == &l_271);
            }
            else
            { /* block id: 187 */
                (*l_255) = 0x0.Bp-1;
            }
            if ((*l_259))
                continue;
            for (l_265.f6 = (-12); (l_265.f6 < 12); l_265.f6 += 8)
            { /* block id: 193 */
                int32_t l_286 = 0x4FC2E018L;
                l_287 = ((int16_t)p_45.f2 - (int16_t)((uint16_t)((uint16_t)(((int32_t)func_72(p_45.f3, (*l_252), (l_286 | (p_45.f6 && l_286)), (*l_260)) + (int32_t)(*p_44)) == (*l_259)) % (uint16_t)7L) << (uint16_t)0));
                l_278 = &l_279;
            }
            if ((*p_44))
                continue;
        }
        /* facts after for loop */
        //assert (l_253 == 0 || l_253 == &l_264 || l_253 == &l_348);
        (*l_255) = ((((float)(((+((float)(((__builtin_ctz((p_46 > __builtin_ia32_crc32qi(((*l_260) != (*l_259)), (*l_259)))) != ((*l_259) != (&l_259 != &p_44))) > 0xD.060827p-58) > p_45.f2) / (float)p_45.f5)) != (*l_259)) >= p_45.f2) / (float)(-0x7.8p+1)) != p_45.f5) <= p_45.f0);
        (*l_252) = p_43;
        /* statement id: 200 */
        //assert (l_253 == 0 || l_253 == &l_348);
    }
    /* facts after for loop */
    //assert (l_273 == 0 || l_273 == dangling);
    return p_43;
    /* statement id: 202 */
    //assert (func_42_rv == 0 || func_42_rv == &l_348);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_48(struct S0  p_49, int32_t * p_50, uint8_t  p_51, struct S0  p_52)
{ /* block id: 166 */
    uint8_t l_245 = 1UL;
    for (p_52.f6 = 0; (p_52.f6 < 42); p_52.f6 += 7)
    { /* block id: 169 */
        uint16_t l_242 = 0x5647L;
        int32_t *l_246 = (void*)0;
        int32_t l_248 = 1L;
        int32_t *l_247 = &l_248;
        (*l_247) = ((int32_t)l_242 / (int32_t)((p_52.f5 && (0x3CC3L == p_52.f7)) | (p_49.f6 > __builtin_ffsll(__builtin_bswap32(l_245)))));
    }
    return p_50;
    /* statement id: 172 */
    //assert (func_48_rv == 0 || func_48_rv == &l_264 || func_48_rv == &l_348);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_54(uint16_t  p_55)
{ /* block id: 40 */
    uint32_t l_57 = 0xA83CD0CDL;
    struct S0 l_69 = {65533UL,0L,0x65L,0x505FL,3UL,7UL,0xD6L,0x6066L};
    int32_t l_71 = (-1L);
    int32_t *l_70 = &l_71;
    struct S0 l_81 = {0xE619L,1L,250UL,0x219EL,0x0604811EL,246UL,0xF7L,0xAABFL};
    uint16_t l_190 = 0x3A87L;
    int16_t l_209 = 0x9388L;
    float l_231 = 0x7.8p-1;
    const int32_t *l_236 = &l_71;
    const int32_t **l_235 = &l_236;
    int32_t *l_237 = (void*)0;
    if (l_57)
    { /* block id: 41 */
        uint8_t l_68 = 7UL;
        int32_t *l_189 = (void*)0;
        if (((0xE85DL >= 2L) == ((((int16_t)(p_55 > ((func_62(l_68, l_69, l_70, p_55, (func_72((p_55 >= func_77(&l_71, l_68, l_81)), l_189, l_81.f0, l_190) || p_55)) < l_209) < p_55)) >> (int16_t)9) | p_55) < p_55)))
        { /* block id: 152 */
            int32_t *l_210 = &l_71;
            const int32_t *l_212 = &l_71;
            const int32_t **l_211 = &l_212;
            (*l_211) = l_210;
            (*l_211) = &l_71;
        }
        else
        { /* block id: 155 */
            int32_t *l_213 = &l_71;
            int32_t **l_214 = &l_213;
            float **l_224 = (void*)0;
            float *** const l_223 = &l_224;
            uint32_t l_230 = 0x23E5249EL;
            float *l_232 = &l_231;
            (*l_214) = l_213;
            (*l_232) = (((float)((float)(((float)((*l_213) <= __builtin_ctzll(((((uint16_t)p_55 >> (uint16_t)6) | ((**l_214) > ((void*)0 == l_223))) ^ (~((int16_t)(-1L) >> (int16_t)(**l_214)))))) + (float)((__builtin_popcountll(((p_55 ^ 0L) != l_230)) >= 0xC.DD45D5p-92) != 0x1.3ECCD7p+0)) < l_231) / (float)p_55) + (float)0x6.9208D7p-0) <= p_55);
            if (l_69.f2)
                goto lbl_234;
        }
    }
    else
    { /* block id: 159 */
        uint16_t l_233 = 0x7A4EL;
        l_233 = p_55;
    }
lbl_234:
    (*l_70) = p_55;
    (*l_235) = &l_71;
    return l_237;
    /* statement id: 165 */
    //assert (func_54_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_62(uint32_t  p_63, struct S0  p_64, int32_t * p_65, uint16_t  p_66, uint8_t  p_67)
{ /* block id: 149 */
    int32_t l_208 = 0x0182948BL;
    int32_t *l_207 = &l_208;
    int32_t **l_206 = &l_207;
    (*l_206) = p_65;
    /* statement id: 150 */
    //assert (l_207 == &l_71);
    return p_64.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_72(uint16_t  p_73, int32_t * p_74, uint32_t  p_75, int32_t  p_76)
{ /* block id: 132 */
    int16_t l_193 = (-1L);
    int32_t l_200 = 1L;
    for (p_75 = 0; (p_75 >= 28); p_75 += 4)
    { /* block id: 135 */
        int32_t l_195 = 0x9A4C43A8L;
        int32_t *l_194 = &l_195;
        (*l_194) = (p_76 & l_193);
        l_200 = ((p_75 || ((*l_194) > p_73)) <= ((*l_194) && ((__builtin_ctzl(((*l_194) & ((int32_t)0xF0C57F21L - (int32_t)(*l_194)))) && ((int64_t)p_75 % (int64_t)p_75)) != p_76)));
        for (l_200 = 0; (l_200 < (-1)); l_200 -= 9)
        { /* block id: 140 */
            for (l_195 = 0; (l_195 == 0); l_195 += 6)
            { /* block id: 143 */
                uint64_t l_205 = 0xC60E83F7990D5904LL;
                return l_205;
            }
        }
    }
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_77(int32_t * p_78, int32_t  p_79, struct S0  p_80)
{ /* block id: 42 */
    struct S0 l_90 = {65534UL,0xC085588CB35B2DFFLL,0x41L,-3L,0UL,0xAAL,0xCEL,7UL};
    struct S0 *l_89 = &l_90;
    int32_t l_99 = 0L;
    int32_t *l_98 = &l_99;
    int32_t **l_97 = &l_98;
    int32_t ***l_100 = &l_97;
    int32_t l_187 = 0x80768EFDL;
    for (p_80.f5 = (-8); (p_80.f5 < 2); ++p_80.f5)
    { /* block id: 45 */
        uint16_t l_84 = 0x9737L;
        float l_86 = 0x8.7p-1;
        float *l_85 = &l_86;
        (*l_85) = (p_80.f7 == l_84);
        for (p_80.f1 = 0; (p_80.f1 < 7); ++p_80.f1)
        { /* block id: 49 */
            int32_t l_91 = 0L;
            l_89 = &p_80;
            /* statement id: 50 */
            assert (l_89 == &p_80);
            if (l_91)
                break;
            p_78 = p_78;
            return (*p_78);
        }
        if (l_90.f6)
            continue;
        (*p_78) = (-(uint64_t)(((p_80.f4 <= ((int64_t)((-7L) && p_79) + (int64_t)l_90.f6)) != (l_84 != ((*p_78) | l_84))) >= ((&l_90 == &l_90) < 1UL)));
    }
    /* facts after for loop */
    assert (l_89 == &p_80 || l_89 == &l_90);
    (*l_100) = l_97;
    if ((**l_97))
    { /* block id: 59 */
        uint8_t l_103 = 247UL;
        const float l_116 = 0x5.1A1E5Fp+6;
        const float *l_115 = &l_116;
        int32_t ** const *l_127 = (void*)0;
        for (p_80.f5 = 0; (p_80.f5 == 24); ++p_80.f5)
        { /* block id: 62 */
            const int16_t l_106 = 0x8955L;
            uint32_t l_119 = 1UL;
            uint16_t l_143 = 0UL;
            const int32_t *l_151 = &l_99;
            const int32_t **l_150 = &l_151;
            const int32_t ***l_149 = &l_150;
            const uint16_t l_155 = 65535UL;
            int32_t *l_179 = &l_99;
            if (l_103)
                break;
        }
        return l_187;
    }
    else
    { /* block id: 121 */
        int32_t *l_188 = &l_99;
        if ((***l_100))
        { /* block id: 122 */
            (**l_100) = l_188;
            (***l_100) = (*l_98);
        }
        else
        { /* block id: 125 */
            p_78 = p_78;
        }
        (*l_188) = (l_98 == l_188);
    }
    (**l_97) = 5L;
    return (*p_78);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 89
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 122
   depth: 2, occurrence: 27
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 2

XXX total number of pointers: 102

XXX times a variable address is taken: 107
XXX times a pointer is dereferenced on RHS: 48
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 63
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 4
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 181

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 176
   level: 2, occurrence: 15
   level: 3, occurrence: 8
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 66
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 24.5
XXX average alias set size: 1.27

XXX times a non-volatile is read: 428
XXX times a non-volatile is write: 172
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 108
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 28
   depth: 2, occurrence: 26
   depth: 3, occurrence: 15
   depth: 4, occurrence: 2
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
********************* end of statistics **********************/

