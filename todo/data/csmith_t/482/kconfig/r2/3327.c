/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3875189376
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int32_t  f0;
   int32_t  f1;
   float  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_35(void);
static float  func_39(struct S0  p_40, struct S0  p_41);
inline static struct S0  func_43(int16_t  p_44, int16_t  p_45, uint32_t  p_46, int32_t  p_47);
inline static int32_t  func_52(struct S0  p_53, int32_t  p_54);
static struct S0  func_55(int32_t  p_56, int16_t  p_57, uint32_t  p_58);
static const uint16_t  func_61(struct S0  p_62, const int32_t  p_63, float  p_64);
static struct S0  func_65(uint32_t  p_66, int16_t  p_67, float  p_68, struct S0  p_69);
static float  func_74(int32_t  p_75, uint32_t  p_76);
static int16_t  func_77(int32_t  p_78);
inline static int16_t  func_79(uint32_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_35(void)
{ /* block id: 36 */
    int32_t l_38 = (-1);
    struct S0 l_42 = {-2,-9,-0x1.7p+1};
    int32_t l_305 = 0x5A28AB48;
    const float l_314 = 0xB.9A4EBCp-90;
    const uint32_t l_398 = 0x61197493;
    float l_399 = 0xF.0DDE07p+35;
    float *l_400 = &l_42.f2;
    uint16_t l_409 = 0xA677;
    uint32_t l_410 = 0xC50F9E10;
    const struct S0 *l_423 = &l_42;
    const struct S0 **l_422 = &l_423;
    (*l_400) = (0x3.3p+1 >= ((float)l_38 + (float)((__builtin_ctzll(l_38) > (func_39(l_42, func_43(((((uint32_t)((uint16_t)((l_42.f1 & func_52(func_55(l_38, ((uint16_t)l_38 - (uint16_t)func_61(func_65(((uint32_t)((((uint32_t)l_42.f1 + (uint32_t)0x58230B54) & 0x5D7D231D) & 0xA67B1108) - (uint32_t)l_42.f0), l_42.f1, l_42.f1, l_42), l_42.f1, l_42.f1)), l_42.f0), l_305)) && (-2)) << (uint16_t)l_305) + (uint32_t)l_42.f0) | l_42.f0) && l_38), l_305, l_42.f1, l_38)) <= l_398)) < l_399)));
    if (((+1U) <= ((int16_t)__builtin_parity((+(l_42.f1 & ((int32_t)((l_42.f1 && 4294967289U) || ((0xD993827F >= ((uint32_t)(l_305 & l_409) + (uint32_t)0xC1874894)) <= l_42.f1)) + (int32_t)l_398)))) << (int16_t)l_410)))
    { /* block id: 215 */
        int16_t l_413 = 0x6B5C;
        for (l_305 = 0; (l_305 >= (-11)); l_305 -= 8)
        { /* block id: 218 */
            uint32_t l_418 = 0x22872917;
            if ((0x35EE | l_413))
            { /* block id: 219 */
                const int32_t *l_415 = &l_42.f0;
                const int32_t **l_414 = &l_415;
                int32_t *l_416 = (void*)0;
                int32_t *l_417 = &l_42.f1;
                (*l_414) = l_400;
                /* statement id: 220 */
                assert (l_415 == &l_42.f2);
                (*l_417) = 0x018CBE64;
            }
            else
            { /* block id: 222 */
                return l_418;
            }
        }
    }
    else
    { /* block id: 226 */
        int32_t *l_420 = &l_42.f1;
        int32_t **l_419 = &l_420;
        int32_t l_421 = 0xB0D43386;
        (*l_419) = (void*)0;
        /* statement id: 227 */
        assert (l_420 == 0);
        l_421 = ((l_420 == l_420) & 0xB74991E2);
        (*l_419) = l_400;
        /* statement id: 229 */
        assert (l_420 == &l_42.f2);
    }
    (*l_422) = &l_42;
    l_42.f1 = func_79(l_410);
    return l_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_39(struct S0  p_40, struct S0  p_41)
{ /* block id: 206 */
    uint32_t l_394 = 4294967295U;
    int16_t l_397 = (-8);
    for (p_41.f1 = 0; (p_41.f1 < (-10)); --p_41.f1)
    { /* block id: 209 */
        int32_t *l_392 = (void*)0;
        int32_t **l_393 = &l_392;
        float l_396 = (-0x4.9p+1);
        float *l_395 = &l_396;
        (*l_393) = l_392;
        (*l_395) = l_394;
    }
    return l_397;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_43(int16_t  p_44, int16_t  p_45, uint32_t  p_46, int32_t  p_47)
{ /* block id: 167 */
    struct S0 l_324 = {0x96E2DC38,0x90558414,0x0.CCA17Bp+71};
    int32_t *l_332 = &l_324.f1;
    float *l_346 = &l_324.f2;
    float **l_345 = &l_346;
    float ***l_344 = &l_345;
    float **** const l_343 = &l_344;
    float **** const *l_342 = &l_343;
    if (((int32_t)(p_44 < p_46) % (int32_t)((int32_t)(p_47 & (-(int32_t)p_47)) + (int32_t)((uint16_t)p_44 + (uint16_t)((int32_t)p_47 - (int32_t)func_52(l_324, (((uint32_t)(((+(__builtin_ffs(((uint16_t)((uint16_t)(1U != (__builtin_ctz(l_324.f0) == l_324.f0)) >> (uint16_t)1) << (uint16_t)l_324.f0)) <= 6U)) >= 4294967287U) | l_324.f1) - (uint32_t)p_45) && 0xF06E)))))))
    { /* block id: 168 */
        int32_t **l_333 = (void*)0;
        int32_t **l_334 = &l_332;
        struct S0 *l_335 = &l_324;
        float *l_339 = &l_324.f2;
        (*l_334) = l_332;
        if ((p_44 >= ((void*)0 != l_335)))
        { /* block id: 170 */
            struct S0 **l_336 = (void*)0;
            const struct S0 **l_337 = (void*)0;
            struct S0 **l_338 = &l_335;
            (*l_338) = l_335;
        }
        else
        { /* block id: 172 */
            (*l_334) = (void*)0;
            /* statement id: 173 */
            assert (l_332 == 0);
        }
        /* facts after branching */
        assert (l_332 == 0 || l_332 == &l_324.f1);
        (*l_339) = p_46;
        return l_324;
    }
    else
    { /* block id: 177 */
        float *l_372 = &l_324.f2;
        int32_t l_377 = 0xF9E5FAA0;
        struct S0 l_389 = {0x32CACBC3,0x3F2C9B0C,0xF.6CC17Cp+10};
        for (p_45 = (-8); (p_45 <= (-27)); p_45--)
        { /* block id: 180 */
            int32_t l_347 = 0x57FDA3C6;
            int32_t l_362 = 0x069DA9D1;
            int32_t *l_388 = (void*)0;
            l_342 = (void*)0;
            /* statement id: 181 */
            assert (l_342 == 0);
            if (p_45)
            { /* block id: 182 */
                uint32_t l_354 = 0x50BC0549;
                float *l_371 = &l_324.f2;
                if (l_347)
                { /* block id: 183 */
                    const int16_t l_357 = 0;
                    int32_t *l_358 = &l_324.f1;
                    int32_t **l_359 = &l_358;
                    (****l_343) = ((float)((((float)func_79((((uint16_t)(__builtin_ffsll(l_354) && p_47) % (uint16_t)((uint16_t)((__builtin_ffsl(p_46) && l_357) && (((p_45 >= ((void*)0 == l_358)) && 3) <= 0)) - (uint16_t)1)) == (-1))) + (float)p_44) != l_354) < p_47) - (float)0x5.8p+1);
                    (*l_359) = (void*)0;
                    /* statement id: 185 */
                    assert (l_358 == 0);
                    l_362 = ((float)0x1.2E5FB8p+25 - (float)__builtin_ctz(l_347));
                    (*l_332) = ((uint32_t)((int16_t)1 << (int16_t)(func_77((p_46 & (p_46 > ((__builtin_ia32_crc32qi(((uint16_t)((int32_t)p_44 + (int32_t)(l_371 == l_372)) << (uint16_t)9), p_44) & (p_44 < p_45)) != p_44)))) | p_46)) + (uint32_t)0);
                }
                else
                { /* block id: 188 */
                    return l_324;
                }
                for (p_47 = (-25); (p_47 >= 11); ++p_47)
                { /* block id: 193 */
                    int32_t **l_375 = (void*)0;
                    int32_t **l_376 = &l_332;
                    (*l_376) = &p_47;
                    /* statement id: 194 */
                    assert (l_332 == &p_47);
                    if (l_377)
                        break;
                }
                /* facts after for loop */
                assert (l_332 == &p_47 || l_332 == &l_324.f1);
                (*l_332) = ((void*)0 == &l_372);
                return l_324;
            }
            else
            { /* block id: 199 */
                int32_t l_379 = 0xF08B3607;
                float **l_380 = &l_372;
                int32_t l_387 = 0xA50624BA;
                l_387 = (~((p_46 && l_379) && ((((__builtin_ffs(((l_380 != (void*)0) && ((int16_t)func_61(l_324, (~p_44), ((((float)0xF.3727B0p-63 - (float)l_347) >= (!(-0x1.1p-1))) >= (*l_332))) << (int16_t)8))) != p_47) == 0x79B6) && p_46) > p_45)));
                l_388 = l_332;
                /* statement id: 201 */
                assert (l_388 == &l_324.f1);
            }
            /* facts after branching */
            assert (l_388 == &l_324.f1);
        }
        /* facts after for loop */
        assert (l_342 == 0 || l_342 == &l_343);
        return l_389;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_52(struct S0  p_53, int32_t  p_54)
{ /* block id: 163 */
    uint16_t l_306 = 0x8E89;
    int32_t l_308 = 0;
    int32_t *l_307 = &l_308;
    float * const *l_310 = (void*)0;
    float * const **l_309 = &l_310;
    float ** const *l_312 = (void*)0;
    float ** const **l_311 = &l_312;
    int16_t l_313 = 0x2178;
    (*l_307) = l_306;
    (*l_311) = l_309;
    /* statement id: 165 */
    assert (l_312 == &l_310);
    return l_313;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_55(int32_t  p_56, int16_t  p_57, uint32_t  p_58)
{ /* block id: 153 */
    float l_296 = 0x1.0C4DA9p+28;
    int32_t l_297 = 0xDED77BE7;
    int32_t *l_303 = &l_297;
    int32_t * const *l_302 = &l_303;
    int32_t * const **l_301 = &l_302;
    int32_t * const ***l_300 = &l_301;
    struct S0 l_304 = {0x6EBF33B0,0x657D72F3,0xE.FA7AC4p+54};
    for (p_57 = 7; (p_57 > 23); p_57++)
    { /* block id: 156 */
        const int32_t l_293 = (-1);
        float l_295 = (-0x1.1p+1);
        float *l_294 = &l_295;
        int32_t * const **l_299 = (void*)0;
        int32_t * const ***l_298 = &l_299;
        (*l_294) = (-(float)l_293);
        (*l_294) = __builtin_popcountll(l_297);
        l_300 = l_298;
        /* statement id: 159 */
        assert (l_300 == &l_299);
        (***l_301) = 0x318B5201;
    }
    /* facts after for loop */
    //assert (l_300 == dangling || l_300 == &l_301);
    return l_304;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_61(struct S0  p_62, const int32_t  p_63, float  p_64)
{ /* block id: 71 */
    int32_t l_155 = 0;
    int32_t *l_154 = &l_155;
    float l_166 = 0xE.E32CE8p+6;
    float *l_165 = &l_166;
    float **l_164 = &l_165;
    int16_t l_268 = 0x1445;
    const struct S0 l_282 = {0xDDA62993,1,-0x1.7p+1};
    const struct S0 *l_281 = &l_282;
    struct S0 **l_283 = (void*)0;
    struct S0 l_286 = {0x7F45CD96,0,-0x8.Bp-1};
    struct S0 *l_285 = &l_286;
    struct S0 **l_284 = &l_285;
    int32_t **l_287 = (void*)0;
    int32_t **l_288 = &l_154;
    const float l_289 = 0xA.88E312p+36;
    for (p_62.f1 = (-20); (p_62.f1 <= (-14)); ++p_62.f1)
    { /* block id: 74 */
        int32_t *l_156 = &l_155;
        float **l_168 = &l_165;
        int32_t l_232 = 0xAD9C61CC;
        int32_t **l_242 = &l_154;
        int32_t *** const l_241 = &l_242;
        int32_t *** const *l_240 = &l_241;
        uint32_t l_265 = 0x57BED906;
    }
    (*l_284) = l_281;
    /* statement id: 150 */
    assert (l_285 == &l_282);
    (*l_288) = &l_155;
    return p_62.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_65(uint32_t  p_66, int16_t  p_67, float  p_68, struct S0  p_69)
{ /* block id: 37 */
    int16_t l_81 = 0x5EFB;
    uint32_t l_112 = 4294967291U;
    float l_149 = 0x8.F691D6p-76;
    float *l_148 = &l_149;
    int32_t l_151 = 0xFE39EBDD;
    int32_t *l_150 = &l_151;
    (*l_148) = func_74((func_77((func_79(l_81) != l_112)) > ((uint32_t)p_69.f1 + (uint32_t)func_77(p_66))), p_69.f0);
    l_150 = l_148;
    /* statement id: 68 */
    assert (l_150 == &l_149);
    l_150 = &l_151;
    /* statement id: 69 */
    assert (l_150 == &l_151);
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_74(int32_t  p_75, uint32_t  p_76)
{ /* block id: 62 */
    int32_t l_145 = 0xAA2C9F03;
    int32_t *l_144 = &l_145;
    int32_t **l_143 = &l_144;
    int32_t ***l_142 = &l_143;
    int32_t ****l_146 = &l_142;
    (*l_146) = l_142;
    (***l_142) = (p_75 | (+0x3FC1E9F9));
    (***l_146) = (*l_143);
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_77(int32_t  p_78)
{ /* block id: 41 */
    float l_113 = 0x1.2p+1;
    float *l_114 = (void*)0;
    float *l_115 = &l_113;
    int32_t l_117 = 0x768641A0;
    int32_t *l_116 = &l_117;
    float l_137 = 0x1.1p+1;
    int32_t **l_138 = (void*)0;
    int32_t **l_139 = &l_116;
    (*l_115) = l_113;
    (*l_116) = p_78;
    for (p_78 = 13; (p_78 <= (-17)); p_78 -= 8)
    { /* block id: 46 */
        int32_t **l_122 = &l_116;
        for (l_117 = 0; (l_117 != 0); l_117 += 8)
        { /* block id: 49 */
            return p_78;
        }
        (*l_122) = &l_117;
        if ((6 < (p_78 == ((int16_t)(((uint16_t)(p_78 >= (((uint16_t)(**l_122) - (uint16_t)((uint16_t)p_78 << (uint16_t)((((int32_t)(**l_122) + (int32_t)(l_122 != &l_116)) < (**l_122)) && 0x048D))) || (**l_122))) + (uint16_t)0xF6C6) ^ p_78) >> (int16_t)(*l_116)))))
        { /* block id: 53 */
            int32_t **l_136 = &l_116;
            (*l_116) = (__builtin_popcountll((((**l_122) != (((!((((uint32_t)func_79((((0x8190 ^ (p_78 | ((((*l_116) == func_79(p_78)) < ((l_136 != &l_116) <= (**l_136))) <= (**l_122)))) ^ (**l_122)) & 0x9816E076)) + (uint32_t)(*l_116)) < (-1)) >= 6U)) < 0x4FE02E22) ^ 1)) ^ 3)) && (-1));
        }
        else
        { /* block id: 55 */
            if (p_78)
                break;
        }
        if ((*l_116))
            continue;
    }
    (*l_139) = &l_117;
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_79(uint32_t  p_80)
{ /* block id: 38 */
    int32_t l_106 = (-1);
    float l_111 = 0x0.8AEA20p+71;
    float *l_110 = &l_111;
    (*l_110) = __builtin_ctzl((((uint32_t)((uint32_t)((((uint16_t)((int16_t)(!(((-1) > ((int16_t)((uint16_t)((uint16_t)65529U >> (uint16_t)(((uint32_t)((((int16_t)(((+((uint16_t)((uint16_t)l_106 - (uint16_t)(0U == (__builtin_clzl(p_80) > ((int16_t)p_80 >> (int16_t)(+(p_80 || l_106)))))) << (uint16_t)14)) >= 0x93330862) && p_80) - (int16_t)1U) >= 0U) | l_106) % (uint32_t)l_106) > l_106)) << (uint16_t)15) << (int16_t)14)) || (-1))) >> (int16_t)3) << (uint16_t)0) >= 0xEC44) && 4) - (uint32_t)p_80) - (uint32_t)l_106) >= l_106));
    return l_106;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 88
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 13
   depth: 3, occurrence: 3
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 28, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 96

XXX times a variable address is taken: 92
XXX times a pointer is dereferenced on RHS: 46
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 57
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 4
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 155

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 88
   level: 2, occurrence: 26
   level: 3, occurrence: 14
   level: 4, occurrence: 16
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 24
XXX average alias set size: 1.15

XXX times a non-volatile is read: 413
XXX times a non-volatile is write: 161
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 76
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 20
   depth: 2, occurrence: 8
   depth: 3, occurrence: 9
   depth: 4, occurrence: 7

XXX percentage a fresh-made variable is used: 26.5
XXX percentage an existing variable is used: 73.5
********************* end of statistics **********************/

