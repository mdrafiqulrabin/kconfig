/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      965953544
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const unsigned f0 : 18;
   uint64_t  f1;
   signed f2 : 23;
   const signed f3 : 29;
   signed f4 : 14;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_33(void);
static int32_t  func_34(float  p_35, int32_t  p_36, uint64_t  p_37);
static float  func_42(struct S0  p_43, uint16_t  p_44);
inline static int16_t  func_52(uint64_t  p_53, float  p_54, struct S0  p_55, uint32_t  p_56, uint8_t  p_57);
inline static uint64_t  func_58(float  p_59, uint8_t  p_60, uint64_t  p_61, uint16_t  p_62);
static float  func_69(int64_t  p_70);
static const int32_t * func_73(int32_t * p_74, const int32_t * p_75, uint16_t  p_76);
static int32_t * func_79(int32_t * p_80, int32_t * p_81);
inline static int32_t * func_82(int64_t  p_83);
inline static int32_t * func_84(const uint32_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_33(void)
{ /* block id: 36 */
    struct S0 l_45 = {18,0x0335900B0881DDA8LL,-653,-19764,-84};
    uint32_t l_193 = 18446744073709551615UL;
    uint16_t l_194 = 0UL;
    int32_t l_257 = 7L;
    int32_t *l_256 = &l_257;
    float * const *l_258 = (void*)0;
    int32_t *l_265 = &l_257;
    int32_t ****l_278 = (void*)0;
    int32_t *****l_277 = &l_278;
    uint16_t l_284 = 0x13E4L;
    int32_t l_285 = 0x08290AFDL;
    int32_t **l_287 = &l_256;
    uint32_t l_288 = 0x0761ED40L;
    (*l_256) = func_34(((((float)((float)func_42(l_45, ((int16_t)(((int16_t)((uint16_t)l_45.f0 - (uint16_t)func_52((((0x4938L == ((0x0451L && __builtin_popcountll(func_58(((float)(((float)((float)((0x9.7p+1 != (-0x6.Ep+1)) <= (l_45.f1 <= func_69((0xFF6AL == __builtin_bswap32(((uint16_t)l_45.f4 / (uint16_t)l_45.f2)))))) + (float)l_45.f0) - (float)l_45.f2) == l_193) - (float)l_45.f2), l_45.f2, l_193, l_194))) && l_45.f0)) & l_193) & l_194), l_45.f2, l_45, l_193, l_193)) << (int16_t)2) && l_45.f1) / (int16_t)l_193)) / (float)l_45.f4) / (float)l_45.f3) >= l_45.f3) > l_45.f0), l_45.f2, l_194);
    if (l_45.f1)
        goto lbl_286;
    if (((void*)0 != l_258))
    { /* block id: 134 */
        int32_t *l_259 = &l_257;
        int32_t **l_260 = &l_256;
        (*l_260) = func_79(func_79(&l_257, l_259), l_256);
        (**l_260) = ((uint16_t)0x80C9L << (uint16_t)14);
    }
    else
    { /* block id: 137 */
        const int64_t l_268 = 0x0658D7BDA1314572LL;
        (*l_265) = ((0x2B18L || ((int32_t)(l_265 != &l_257) + (int32_t)(((uint16_t)l_268 + (uint16_t)__builtin_popcountll((((uint16_t)((uint64_t)l_268 % (uint64_t)l_268) - (uint16_t)l_268) || (l_268 <= 0x896D5BFBL)))) <= 0x1DACA569L))) > (*l_265));
        (*l_256) = ((uint16_t)((int16_t)1L + (int16_t)l_268) << (uint16_t)8);
    }
lbl_286:
    (*l_265) = (((void*)0 == l_277) != (((uint16_t)((((-(uint32_t)__builtin_clzl(func_34(((float)0x5.Bp-1 - (float)(-0x7.1p-1)), l_284, (*l_265)))) < 0xE9A1L) && 0x858AB291146D75CFLL) == (-1L)) << (uint16_t)(*l_256)) ^ l_285));
    (*l_287) = &l_285;
    /* statement id: 143 */
    assert (l_256 == &l_285);
    return l_288;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(float  p_35, int32_t  p_36, uint64_t  p_37)
{ /* block id: 129 */
    float l_252 = 0x4.F38543p-22;
    float *l_251 = &l_252;
    int32_t l_253 = (-9L);
    int32_t *l_255 = &l_253;
    int32_t **l_254 = &l_255;
    (*l_251) = (-0x1.0p+1);
    (*l_254) = func_82(l_253);
    /* statement id: 131 */
    assert (l_255 == 0);
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_42(struct S0  p_43, uint16_t  p_44)
{ /* block id: 120 */
    int32_t l_245 = (-8L);
    int32_t *l_244 = &l_245;
    int32_t **l_246 = &l_244;
    int64_t l_250 = 0x891A747682D1DD9BLL;
    (*l_246) = l_244;
    (*l_246) = (*l_246);
    for (p_43.f1 = 0; (p_43.f1 > 44); p_43.f1 += 1)
    { /* block id: 125 */
        int32_t l_249 = 0xAE3F3AD7L;
        return l_249;
    }
    return l_250;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_52(uint64_t  p_53, float  p_54, struct S0  p_55, uint32_t  p_56, uint8_t  p_57)
{ /* block id: 118 */
    int32_t l_243 = (-5L);
    return l_243;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_58(float  p_59, uint8_t  p_60, uint64_t  p_61, uint16_t  p_62)
{ /* block id: 93 */
    float l_197 = (-0x1.5p+1);
    float *l_196 = &l_197;
    float **l_195 = &l_196;
    float ***l_198 = &l_195;
    int32_t l_199 = 1L;
    int32_t * const * const *l_208 = (void*)0;
    int32_t *l_242 = &l_199;
    int32_t **l_241 = &l_242;
    (*l_198) = l_195;
    if (l_199)
    { /* block id: 95 */
        float l_204 = 0xE.12F5BDp+78;
        for (p_62 = 23; (p_62 <= 39); p_62 += 9)
        { /* block id: 98 */
            for (l_199 = (-4); (l_199 != (-11)); l_199 -= 7)
            { /* block id: 101 */
                return l_199;
            }
            return p_61;
        }
    }
    else
    { /* block id: 106 */
        int32_t *l_207 = (void*)0;
        int32_t **l_206 = &l_207;
        int32_t *** const l_205 = &l_206;
        int32_t ***l_213 = &l_206;
        const int32_t *l_227 = &l_199;
        const int32_t ** const l_226 = &l_227;
        int32_t *l_228 = &l_199;
        (**l_195) = func_69((((l_199 > (((p_61 | (l_205 != l_208)) == (__builtin_parityll((p_60 & (((uint64_t)((int16_t)p_60 - (int16_t)(l_208 != l_213)) % (uint64_t)((uint16_t)(((p_62 < 0xCFF5E1EA3A65F83DLL) & 0x27DBL) | p_60) << (uint16_t)8)) ^ p_60))) < p_61)) != p_62)) && p_60) && p_62));
        (*l_228) = (((int32_t)((p_60 <= ((uint16_t)p_60 + (uint16_t)(p_61 && ((uint16_t)((int16_t)0xB7E2L << (int16_t)p_62) / (uint16_t)((uint16_t)p_62 % (uint16_t)(((0L && p_61) == ((*l_205) != l_226)) ^ 0L)))))) | p_62) - (int32_t)p_62) == p_61);
        if (p_60)
        { /* block id: 109 */
            int32_t *** const *l_230 = (void*)0;
            int32_t *** const **l_229 = &l_230;
            (*l_229) = &l_213;
            /* statement id: 110 */
            assert (l_230 == &l_213);
        }
        else
        { /* block id: 111 */
            (*l_206) = (void*)0;
        }
        (**l_213) = (**l_213);
    }
    (*l_241) = func_82(((uint16_t)l_199 >> (uint16_t)(((int16_t)((uint64_t)p_61 % (uint64_t)0x8ED1E4CC4E5DE65ALL) + (int16_t)(p_61 & 0x2E1ABEA0L)) <= ((uint16_t)l_199 + (uint16_t)((int16_t)l_199 / (int16_t)p_61)))));
    /* statement id: 116 */
    assert (l_242 == 0);
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_69(int64_t  p_70)
{ /* block id: 37 */
    int32_t l_78 = (-10L);
    int32_t *l_77 = &l_78;
    int32_t l_139 = 7L;
    int32_t **l_142 = &l_77;
    (*l_142) = func_73(l_77, func_79(func_82((*l_77)), &l_78), l_139);
    if (((**l_142) && (**l_142)))
    { /* block id: 61 */
        float *l_144 = (void*)0;
        float l_146 = 0x4.6C26E6p+86;
        float *l_145 = &l_146;
lbl_147:
        (*l_77) = (p_70 > ((!p_70) & p_70));
        (*l_145) = (p_70 >= (*l_77));
        (**l_142) = (-1L);
        if (l_139)
            goto lbl_147;
    }
    else
    { /* block id: 66 */
        int64_t l_148 = (-9L);
        int32_t *l_168 = (void*)0;
        int32_t l_184 = 7L;
        uint32_t l_191 = 0xD5C82D1FL;
        if (l_148)
        { /* block id: 67 */
            int64_t l_151 = 0x19CEE68397568C23LL;
            uint32_t l_154 = 7UL;
            int32_t *l_171 = &l_78;
            if (((uint32_t)(l_151 && 0x85D1L) - (uint32_t)((((uint32_t)l_154 + (uint32_t)__builtin_bswap64(((int32_t)(1UL | (p_70 != ((int16_t)((uint16_t)((uint16_t)(!((((int16_t)((int16_t)l_148 - (int16_t)l_154) >> (int16_t)9) | ((((*l_77) ^ __builtin_clzll(l_154)) || p_70) == p_70)) <= 0xBC6B9C53L)) + (uint16_t)p_70) + (uint16_t)3L) >> (int16_t)9))) + (int32_t)l_148))) || 0x3A2BL) ^ l_148)))
            { /* block id: 68 */
                l_168 = l_168;
            }
            else
            { /* block id: 70 */
                const uint16_t l_180 = 3UL;
                int32_t *l_187 = &l_139;
                float l_189 = 0x7.9p+1;
                float *l_188 = &l_189;
                for (p_70 = 11; (p_70 <= 7); p_70 -= 4)
                { /* block id: 73 */
                    int32_t l_177 = 0xA41A2CE7L;
                    int32_t ***l_183 = (void*)0;
                    (*l_142) = l_171;
                    for (l_148 = 0; (l_148 <= 27); ++l_148)
                    { /* block id: 77 */
                        int32_t l_176 = 0xF51D59E5L;
                        float l_186 = 0x9.FA83A9p+63;
                        float *l_185 = &l_186;
                        (*l_142) = (*l_142);
                        (*l_185) = ((((float)(((p_70 <= (l_176 != ((l_177 != l_177) < ((float)l_180 + (float)(((float)(-0x1.6p+1) / (float)0x5.30B2CDp-17) != (l_183 != l_183)))))) != p_70) != p_70) + (float)(-0x1.Ep-1)) == 0x8.DF4010p-92) != l_184);
                    }
                    return p_70;
                }
                (**l_142) = (p_70 >= (*l_77));
                (*l_142) = l_187;
                /* statement id: 84 */
                assert (l_77 == &l_139);
                (*l_188) = p_70;
            }
            /* facts after branching */
            assert (l_77 == &l_139 || l_77 == &l_78);
            (*l_171) = (*l_171);
        }
        else
        { /* block id: 88 */
            int32_t *l_190 = &l_139;
            int32_t **l_192 = &l_77;
            (*l_192) = func_73(l_190, &l_184, ((p_70 & (&l_184 != l_190)) == l_191));
            /* statement id: 89 */
            assert (l_77 == &l_139);
        }
        /* facts after branching */
        assert (l_77 == &l_139 || l_77 == &l_78);
    }
    /* facts after branching */
    assert (l_77 == &l_139 || l_77 == &l_78);
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_73(int32_t * p_74, const int32_t * p_75, uint16_t  p_76)
{ /* block id: 56 */
    int32_t *l_141 = (void*)0;
    int32_t **l_140 = &l_141;
    (*l_140) = p_74;
    /* statement id: 57 */
    //assert (l_141 == &l_78 || l_141 == &l_139);
    (*l_141) = (**l_140);
    return p_74;
    /* statement id: 59 */
    //assert (func_73_rv == &l_78 || func_73_rv == &l_139);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_79(int32_t * p_80, int32_t * p_81)
{ /* block id: 46 */
    int32_t **l_114 = (void*)0;
    int32_t **l_115 = (void*)0;
    int32_t l_118 = 5L;
    int32_t *l_117 = &l_118;
    int32_t **l_116 = &l_117;
    int32_t l_121 = 2L;
    int64_t l_126 = 0x1577CD1832462667LL;
    float l_128 = (-0x1.2p+1);
    float *l_127 = &l_128;
    uint32_t l_131 = 0x0D347FA9L;
    int64_t l_138 = 0L;
    (*l_116) = p_80;
    /* statement id: 47 */
    //assert (l_117 == 0 || l_117 == &l_257);
    if ((l_118 != l_118))
    { /* block id: 48 */
        int32_t l_124 = (-1L);
        (*p_81) = ((0xC961L == ((int64_t)l_121 - (int64_t)((uint32_t)(l_124 && l_124) / (uint32_t)l_124))) < 0UL);
    }
    else
    { /* block id: 50 */
        int32_t ***l_125 = &l_116;
        (*l_125) = &p_80;
        /* statement id: 51 */
        assert (l_116 == &p_80);
    }
    /* facts after branching */
    assert (l_116 == &p_80 || l_116 == &l_117);
    (*l_127) = l_126;
    (*p_81) = ((((int16_t)(((l_126 >= (l_131 <= ((uint64_t)(((int32_t)((int16_t)((p_80 != (void*)0) < 1L) >> (int16_t)l_121) + (int32_t)(__builtin_clz(((((l_126 ^ (__builtin_parityll(l_118) != 0xF43755EC10F06FB9LL)) | l_126) < l_138) >= l_121)) & 0x9E3DC10EL)) >= (*p_81)) - (uint64_t)l_126))) <= l_121) && 0UL) << (int16_t)l_126) ^ 0UL) || l_118);
    return p_80;
    /* statement id: 55 */
    //assert (func_79_rv == 0 || func_79_rv == &l_257);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_82(int64_t  p_83)
{ /* block id: 38 */
    int32_t l_87 = (-4L);
    int32_t *l_86 = &l_87;
    uint32_t l_97 = 1UL;
    int32_t *l_109 = &l_87;
    int32_t *l_110 = &l_87;
    int32_t *l_111 = &l_87;
    int32_t *l_112 = &l_87;
    int32_t *l_113 = (void*)0;
    l_86 = func_84(((((l_86 != &l_87) <= ((uint16_t)((((*l_86) ^ (~((uint64_t)__builtin_ctz((&l_87 != &l_87)) * (uint64_t)((0x020C2888A0E7B2E1LL | (((int16_t)p_83 + (int16_t)((uint16_t)p_83 >> (uint16_t)13)) != p_83)) >= 1UL)))) || l_97) > 0x1F29L) << (uint16_t)(*l_86))) == 4294967288UL) < p_83));
    /* statement id: 44 */
    assert (l_86 == 0);
    return l_113;
    /* statement id: 45 */
    //assert (func_82_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_84(const uint32_t  p_85)
{ /* block id: 39 */
    int32_t *l_98 = (void*)0;
    int32_t l_100 = 0x3887E981L;
    int32_t *l_99 = &l_100;
    int32_t l_101 = 0x916A5C54L;
    int32_t *l_102 = &l_100;
    int32_t *l_103 = &l_100;
    int32_t *l_104 = &l_100;
    int32_t *l_105 = &l_100;
    int32_t *l_106 = &l_100;
    int32_t *l_107 = &l_100;
    int32_t *l_108 = (void*)0;
    (*l_99) = ((void*)0 != l_98);
    (*l_99) = p_85;
    (*l_99) = l_101;
    return l_108;
    /* statement id: 43 */
    //assert (func_84_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 71
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 2
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 14

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 71

XXX times a variable address is taken: 60
XXX times a pointer is dereferenced on RHS: 20
breakdown:
   depth: 1, occurrence: 14
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 40
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 165

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 60
   level: 2, occurrence: 28
   level: 3, occurrence: 5
   level: 4, occurrence: 2
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.6
XXX average alias set size: 1.18

XXX times a non-volatile is read: 251
XXX times a non-volatile is write: 92
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 70
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 17
   depth: 2, occurrence: 7
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 13.1
XXX percentage an existing variable is used: 86.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

