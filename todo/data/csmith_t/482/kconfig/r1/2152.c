/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3794019628
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_26(void);
static uint32_t  func_30(uint32_t  p_31);
static uint64_t  func_35(uint32_t  p_36, int32_t * p_37, int32_t  p_38);
static int64_t  func_45(int16_t  p_46, int32_t * p_47);
static int32_t * func_51(uint64_t  p_52, uint16_t  p_53, int32_t  p_54);
static int16_t  func_67(int32_t * p_68);
static int32_t * func_69(int32_t * p_70, int32_t * p_71, int32_t * p_72, int64_t  p_73, int32_t  p_74);
static int32_t * func_75(int32_t * p_76, int16_t  p_77, uint16_t  p_78, int32_t * p_79, uint64_t  p_80);
static uint16_t  func_82(uint32_t  p_83, uint16_t  p_84);
static int32_t * func_91(uint32_t  p_92, uint16_t  p_93, int32_t * p_94, int16_t  p_95, uint16_t  p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_26(void)
{ /* block id: 36 */
    int32_t l_27 = 8L;
    int32_t l_148 = 0xB3E4958FL;
    int32_t **l_185 = (void*)0;
    int16_t l_192 = 0xFB1EL;
    uint32_t l_207 = 0xDDAB54D3L;
    int64_t l_213 = 0L;
    int64_t l_238 = 0x7B7046C61679470CLL;
    int32_t l_240 = 0xEBDFE288L;
    int64_t l_242 = (-1L);
    int64_t l_247 = 0x9D31CD22D570F6F3LL;
    int32_t l_270 = 0x5EB18E8DL;
    uint16_t l_303 = 65534UL;
    int32_t l_314 = 0xBCFC9B87L;
    uint64_t l_315 = 1UL;
    int16_t l_316 = 4L;
    int32_t *l_319 = (void*)0;
    int32_t **l_318 = &l_319;
    if (((((((((l_27 >= (__builtin_parityll((((((int64_t)(func_30(l_27) > l_27) % (int64_t)((func_35(l_27, &l_27, l_27) , (((l_27 == l_27) != l_27) & l_27)) ^ 0x87A4L)) & l_27) , l_27) <= l_148)) < (-8L))) , 0x7970BCD7L) <= l_148) & 4294967295UL) & 7UL) , 0xB911L) , l_27) != 0xE0904B38L))
    { /* block id: 81 */
        uint16_t l_154 = 65527UL;
        int32_t *l_163 = &l_27;
        int32_t **l_162 = &l_163;
        int32_t **l_164 = &l_163;
        int32_t ***l_214 = &l_162;
        uint32_t l_225 = 0x0749740BL;
        int32_t l_231 = (-7L);
        int32_t l_255 = 0xA9038FE2L;
        uint64_t l_256 = 0xBE92DA7043D3039ALL;
        uint32_t l_284 = 0x7767CE19L;
        int32_t l_289 = 9L;
        for (l_148 = (-6); (l_148 > 20); l_148 += 1)
        { /* block id: 84 */
            int32_t *l_151 = &l_27;
            uint32_t l_157 = 1UL;
            int32_t ***l_197 = (void*)0;
            uint32_t l_226 = 0UL;
            int16_t l_239 = 0xA108L;
            uint16_t l_241 = 0x8E72L;
            uint16_t l_254 = 65532UL;
        }
        for (l_240 = 0; (l_240 != 22); l_240 += 1)
        { /* block id: 108 */
            int32_t *l_263 = &l_255;
            uint32_t l_271 = 0xAFA11A28L;
            int32_t ***l_293 = &l_185;
            uint16_t l_307 = 0x3FBFL;
            if (((uint32_t)((int32_t)(-1L) - (int32_t)(l_263 == (**l_214))) % (uint32_t)1L))
            { /* block id: 109 */
                int32_t l_277 = 0xB50ECB85L;
                for (l_225 = 0; (l_225 <= 49); l_225 += 1)
                { /* block id: 112 */
                    int32_t *l_268 = (void*)0;
                    int32_t l_269 = 0L;
                }
                (*l_263) = ((l_277 , l_293) != l_293);
                (**l_164) = (*l_263);
            }
            else
            { /* block id: 129 */
                int32_t *l_306 = &l_27;
                if (((int16_t)((int16_t)((((((uint16_t)((uint64_t)(**l_162) + (uint64_t)(((-(int64_t)l_303) | ((0xBF6FL >= ((int32_t)(((*l_162) != l_306) && ((**l_162) == (*l_163))) % (int32_t)__builtin_ffsll(l_247))) == (*l_306))) , (*l_263))) << (uint16_t)15) , 0x9EF8C94D68D3CEB0LL) | l_307) >= (*l_163)) && 0x5E09L) >> (int16_t)5) - (int16_t)0xA1ABL))
                { /* block id: 130 */
                    int16_t l_308 = 0L;
                    (*l_163) = __builtin_popcount(l_308);
                }
                else
                { /* block id: 132 */
                    (***l_214) = ((*l_214) != ((*l_306) , l_185));
                }
            }
        }
    }
    else
    { /* block id: 137 */
        int32_t *l_309 = &l_27;
        uint32_t l_317 = 1UL;
        (*l_309) = l_242;
        l_317 = (l_303 , ((((((int64_t)((int64_t)((*l_309) && l_314) % (int64_t)((((void*)0 != l_309) <= __builtin_ctz(l_238)) || l_315)) - (int64_t)((*l_309) ^ l_316)) >= 0xC47171A2D92CA548LL) , 1L) , &l_309) != l_185));
    }
    (*l_318) = (void*)0;
    return l_314;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_30(uint32_t  p_31)
{ /* block id: 37 */
    uint32_t l_32 = 0x18BD8502L;
    int32_t l_33 = (-1L);
    int32_t *l_34 = &l_33;
    l_33 = l_32;
    (*l_34) = 0x5AA05D76L;
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_35(uint32_t  p_36, int32_t * p_37, int32_t  p_38)
{ /* block id: 41 */
    uint64_t l_39 = 0x5A260DF39281C1D9LL;
    int32_t l_41 = 4L;
    int32_t *l_40 = &l_41;
    int16_t l_50 = 1L;
    l_39 = 0L;
    (*l_40) = (l_40 == (((uint16_t)(*l_40) - (uint16_t)(-(uint16_t)(func_45(((int16_t)((((*l_40) & p_38) , &l_41) != (void*)0) + (int16_t)((l_50 , ((void*)0 == &l_41)) , (*l_40))), p_37) == (*l_40)))) , &l_41));
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_45(int16_t  p_46, int32_t * p_47)
{ /* block id: 43 */
    uint16_t l_55 = 1UL;
    int32_t l_147 = 0L;
    int32_t *l_146 = &l_147;
    int32_t **l_145 = &l_146;
    (*l_145) = func_51(l_55, l_55, ((0xE76DCB0C7B249E3CLL | l_55) < ((uint16_t)((int16_t)l_55 >> (int16_t)9) << (uint16_t)7)));
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(uint64_t  p_52, uint16_t  p_53, int32_t  p_54)
{ /* block id: 44 */
    int32_t l_64 = 0xB30732BAL;
    int32_t *l_65 = (void*)0;
    int32_t l_140 = 0x6358B857L;
    int32_t **l_141 = (void*)0;
    int32_t **l_142 = &l_65;
    int32_t *l_143 = &l_140;
    int32_t *l_144 = (void*)0;
    l_140 = ((((int64_t)(((((int64_t)(((0x169B2B29335309F3LL > ((l_64 ^ ((void*)0 != l_65)) != ((!func_67(func_69(func_75(l_65, p_52, (((-(uint16_t)func_82((((int32_t)(((uint16_t)65529UL >> (uint16_t)2) , ((((uint16_t)p_54 + (uint16_t)p_54) | p_53) && p_54)) + (int32_t)l_64) , 0x3ED870B1L), p_54)) == p_53) != 0xF720L), l_65, l_64), l_65, l_65, l_64, p_52))) , (-3L)))) & p_52) & l_64) % (int64_t)0x585002FA5D717EF1LL) , p_52) , l_65) == l_65) - (int64_t)p_54) , l_65) != l_65);
    (*l_142) = &l_140;
    return l_144;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_67(int32_t * p_68)
{ /* block id: 68 */
    int32_t l_127 = 5L;
    int32_t *l_126 = &l_127;
    int32_t *l_130 = &l_127;
    int32_t **l_136 = &l_130;
    int32_t ***l_135 = &l_136;
    int32_t l_139 = 0x4CD19B67L;
    (*l_126) = 0x7436F42BL;
    (*l_130) = ((*l_126) >= (((*l_126) , (((uint16_t)((((*l_126) , &l_127) == l_130) != ((0x596026DFL || (*l_126)) == ((*l_126) > ((__builtin_popcount((*l_130)) | 0x3AC5CED9L) , (*l_126))))) << (uint16_t)5) , 18446744073709551611UL)) || (*l_130)));
    (***l_135) = (((*l_130) <= ((((((*l_130) && ((void*)0 == p_68)) , func_75((((int32_t)__builtin_parity(((((uint16_t)func_30(((*l_130) != (*l_130))) >> (uint16_t)10) < (((l_135 == ((((uint16_t)(***l_135) - (uint16_t)(-7L)) , 18446744073709551615UL) , &l_136)) , &l_136) == &l_136)) || (*l_126))) + (int32_t)(**l_136)) , (void*)0), (*l_130), (***l_135), (*l_136), (*l_130))) == (void*)0) && 0xD41FL) & (*l_130))) == 0x47B4B0677A089C8FLL);
    (**l_135) = p_68;
    return l_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int32_t * p_70, int32_t * p_71, int32_t * p_72, int64_t  p_73, int32_t  p_74)
{ /* block id: 65 */
    int32_t l_125 = 0x4B153CB7L;
    l_125 = l_125;
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_75(int32_t * p_76, int16_t  p_77, uint16_t  p_78, int32_t * p_79, uint64_t  p_80)
{ /* block id: 54 */
    int32_t l_115 = 0xD4E4AF0EL;
    int32_t *l_114 = &l_115;
    int32_t **l_113 = &l_114;
    int32_t *l_120 = &l_115;
    (*l_113) = p_79;
    for (p_80 = 0; (p_80 <= 26); p_80 += 1)
    { /* block id: 58 */
        uint32_t l_118 = 4294967295UL;
        int32_t *l_119 = &l_115;
        l_115 = ((p_77 || (p_80 | __builtin_parityll(p_77))) || l_118);
        p_76 = l_119;
    }
    (*l_120) = p_78;
    (*l_120) = (p_78 && ((int16_t)((uint16_t)p_80 - (uint16_t)p_77) << (int16_t)p_78));
    return p_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_82(uint32_t  p_83, uint16_t  p_84)
{ /* block id: 45 */
    uint16_t l_103 = 3UL;
    int32_t l_107 = 0x4312F30CL;
    int32_t *l_106 = &l_107;
    int32_t **l_112 = &l_106;
    (*l_112) = func_91((((uint16_t)((int16_t)((int16_t)l_103 << (int16_t)4) >> (int16_t)4) >> (uint16_t)p_84) || l_103), p_84, (l_103 , (p_84 , (((int16_t)((p_83 & 0xADB2L) <= l_103) >> (int16_t)p_84) , l_106))), (*l_106), p_83);
    (*l_112) = (*l_112);
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_91(uint32_t  p_92, uint16_t  p_93, int32_t * p_94, int16_t  p_95, uint16_t  p_96)
{ /* block id: 46 */
    int32_t l_111 = 0xC906C22AL;
    int32_t *l_110 = &l_111;
    int32_t **l_109 = &l_110;
    int32_t ***l_108 = &l_109;
    (*p_94) = (*p_94);
    (*l_108) = &p_94;
    (*l_109) = p_94;
    return p_94;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 79
XXX total union variables: 0

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 53

XXX times a variable address is taken: 46
XXX times a pointer is dereferenced on RHS: 92
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 19
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 35
breakdown:
   depth: 1, occurrence: 26
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 222

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 112
   level: 2, occurrence: 42
   level: 3, occurrence: 17
XXX number of pointers point to pointers: 18
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 41.5
XXX average alias set size: 1.28

XXX times a non-volatile is read: 430
XXX times a non-volatile is write: 95
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 46
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 6
   depth: 2, occurrence: 1
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 17.1
XXX percentage an existing variable is used: 82.9
********************* end of statistics **********************/

