/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3442498903
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 10;
   signed f1 : 25;
   unsigned f2 : 24;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_9 = 0xF6DD8D13;
static uint16_t g_131 = 0x2731;
static int32_t g_137 = 0x18E40900;
static struct S0 g_139 = {2,-688,2811};
static int16_t g_266 = 1;
static int32_t g_402 = 0x3C59B481;
static uint32_t g_463 = 0x3FF71A98;
static uint32_t g_520 = 0xF81A32D9;
static uint32_t g_583 = 4294967292U;
static struct S0 g_633 = {10,1651,2375};
static uint16_t g_636 = 5U;
static uint32_t g_692 = 0xB54DABF6;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_25(void);
static uint16_t  func_32(uint32_t  p_33);
static struct S0  func_42(uint32_t  p_43);
static int32_t  func_45(int16_t  p_46);
static int16_t  func_51(uint16_t  p_52, uint16_t  p_53, struct S0  p_54);
static uint16_t  func_56(int32_t  p_57, uint16_t  p_58, uint16_t  p_59);
static int32_t  func_64(uint16_t  p_65, uint32_t  p_66);
static int32_t  func_67(int16_t  p_68);
static struct S0  func_76(int32_t  p_77, uint32_t  p_78);
static struct S0  func_79(uint32_t  p_80, uint16_t  p_81, int32_t  p_82, uint32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_131 g_139 g_137 g_266 g_402 g_463 g_520 g_583 g_636 g_633.f0 g_633.f1 g_633
 * writes: g_9 g_131 g_137 g_139 g_402 g_266 g_633 g_463 g_692 g_636
 */
static int16_t  func_25(void)
{ /* block id: 36 */
    int32_t l_34 = 0x5B0E82CA;
    int32_t l_725 = 0x32F2392F;
    if (((int16_t)((int16_t)((int16_t)1 >> (int16_t)func_32(l_34)) << (int16_t)9) << (int16_t)l_34))
    { /* block id: 414 */
        return g_636;
    }
    else
    { /* block id: 416 */
        uint16_t l_719 = 65535U;
        g_633.f1 = __builtin_popcountll(func_56((((int16_t)((uint32_t)0xAFD3E386 % (uint32_t)((int16_t)g_633.f0 >> (int16_t)14)) - (int16_t)g_402) || (l_719 > (l_719 | g_9))), g_633.f0, (!4U)));
    }
    l_34 = (~(-(uint32_t)((((int32_t)l_34 + (int32_t)g_633.f1) < g_9) != g_9)));
    l_34 = g_636;
    if ((((func_45(l_34) ^ l_34) > (0xCB69 != (g_633.f0 >= (g_139.f2 > (l_34 || l_725))))) != (((l_725 | g_583) > g_583) < l_725)))
    { /* block id: 421 */
        struct S0 l_726 = {5,-1873,4009};
        l_726 = func_76(g_139.f1, l_725);
        g_137 = (!(g_139.f0 >= ((int16_t)__builtin_popcountl(g_139.f2) + (int16_t)((int32_t)l_34 + (int32_t)g_633.f0))));
    }
    else
    { /* block id: 424 */
        int16_t l_735 = 4;
        for (l_725 = 0; (l_725 <= 15); l_725 += 4)
        { /* block id: 427 */
            uint32_t l_734 = 0x95640545;
            g_139.f1 = g_137;
            if (l_34)
            { /* block id: 429 */
                return l_734;
            }
            else
            { /* block id: 431 */
                int32_t l_738 = 0x0E620C47;
                int16_t l_749 = 0x67B1;
                if (g_139.f1)
                { /* block id: 432 */
                    l_735 = 0;
                    g_402 = g_520;
                    if (g_402)
                        break;
                    if (g_633.f2)
                        break;
                }
                else
                { /* block id: 437 */
                    uint16_t l_741 = 0xC0BD;
                    uint16_t l_750 = 0xC1CA;
                    struct S0 l_751 = {3,496,1167};
                    if (((((int16_t)0xD2FD >> (int16_t)(l_735 == l_738)) | (((int16_t)0x9BF8 + (int16_t)l_741) < (-(int32_t)__builtin_popcountl(func_32(func_64(g_139.f0, ((int16_t)(func_64(l_725, ((uint16_t)((((int16_t)((((l_749 <= 0x4931) <= g_9) > 0x220B3BE1) ^ 0) << (int16_t)3) | 0x941A) || l_750) % (uint16_t)g_139.f2)) & l_749) << (int16_t)g_463))))))) && l_738))
                    { /* block id: 438 */
                        g_139 = l_751;
                    }
                    else
                    { /* block id: 440 */
                        if (g_131)
                            break;
                    }
                }
            }
        }
    }
    return g_520;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_131 g_139 g_137 g_266 g_402 g_463 g_520 g_583 g_636 g_633.f0 g_633.f1 g_633
 * writes: g_9 g_131 g_137 g_139 g_402 g_266 g_633 g_463 g_692 g_636
 */
static uint16_t  func_32(uint32_t  p_33)
{ /* block id: 37 */
    uint16_t l_35 = 5U;
    struct S0 l_504 = {25,-4885,2262};
    uint32_t l_695 = 6U;
    if (l_35)
    { /* block id: 38 */
        int16_t l_41 = 0xC3FC;
        struct S0 l_519 = {15,2331,2064};
        for (l_35 = (-18); (l_35 < 14); l_35 += 7)
        { /* block id: 41 */
            uint16_t l_40 = 0x0C43;
            int32_t l_521 = 5;
            for (p_33 = 0; (p_33 >= 60); p_33 += 1)
            { /* block id: 44 */
                uint32_t l_507 = 0xAA61C218;
                struct S0 l_511 = {9,-3402,2037};
                l_41 = l_40;
                l_504 = func_42((-(uint32_t)p_33));
                for (l_40 = (-20); (l_40 >= 37); l_40 += 7)
                { /* block id: 286 */
                    if (__builtin_parity((l_507 >= (p_33 ^ l_35))))
                    { /* block id: 287 */
                        uint32_t l_508 = 0U;
                        struct S0 l_512 = {13,-4132,77};
                        g_402 = (func_64(l_508, ((int32_t)g_463 + (int32_t)g_139.f0)) <= 1U);
                        l_512 = l_511;
                    }
                    else
                    { /* block id: 290 */
                        g_139 = l_511;
                    }
                    l_511 = l_504;
                    if ((((int16_t)__builtin_popcountl(p_33) >> (int16_t)((((uint16_t)func_56(func_67(func_67((g_139.f0 != (l_511.f1 != ((((((-1) & p_33) && __builtin_ffsll(((((int16_t)l_41 + (int16_t)l_41) != 0) | g_266))) && g_9) != 65532U) > l_511.f2))))), p_33, g_463) << (uint16_t)13) & p_33) > g_463)) > l_41))
                    { /* block id: 294 */
                        g_139 = l_519;
                    }
                    else
                    { /* block id: 296 */
                        l_521 = g_520;
                        l_511 = func_42(g_520);
                    }
                }
                l_519.f1 = g_137;
            }
            if (p_33)
                continue;
            l_519 = func_76((((uint32_t)((g_9 || __builtin_ctzl((((uint32_t)p_33 - (uint32_t)(-(int16_t)(3U ^ ((int16_t)(((uint16_t)l_519.f2 >> (uint16_t)8) < func_56(g_463, l_519.f1, p_33)) >> (int16_t)3)))) | ((int16_t)((((func_51(l_519.f0, g_520, l_519) & g_520) < p_33) && g_463) < 65528U) + (int16_t)65534U)))) && l_504.f0) + (uint32_t)p_33) == l_521), l_519.f0);
            for (l_521 = 0; (l_521 <= 24); l_521 += 1)
            { /* block id: 307 */
                uint32_t l_535 = 0xBDF9D0D4;
                l_535 = (p_33 == 0x6B51);
            }
        }
    }
    else
    { /* block id: 311 */
        int16_t l_536 = (-1);
        int32_t l_545 = 2;
        int32_t l_559 = 0xC6E26E95;
        struct S0 l_609 = {4,5543,824};
        if (l_536)
        { /* block id: 312 */
            struct S0 l_546 = {12,-4960,176};
            int32_t l_608 = 0x7A3C156B;
            g_137 = 0x1BCCB8C6;
            if ((g_139.f0 | p_33))
            { /* block id: 314 */
                int32_t l_547 = (-3);
                int32_t l_548 = (-7);
                if ((p_33 | __builtin_ctz((((int32_t)((int16_t)((~1U) && g_402) - (int16_t)__builtin_popcountl(p_33)) - (int32_t)((int32_t)((g_9 == (~((l_536 || 1) == ((p_33 & g_266) <= g_463)))) >= p_33) - (int32_t)9)) != l_545))))
                { /* block id: 315 */
                    l_546 = l_546;
                }
                else
                { /* block id: 317 */
                    uint16_t l_564 = 0U;
                    l_548 = (0x80C3 || ((p_33 || g_137) ^ __builtin_popcountll(l_547)));
                    if (((uint16_t)(-(uint16_t)(!(g_520 && ((uint16_t)(((uint16_t)(((int16_t)l_547 - (int16_t)(l_559 <= (0xC534 ^ (((int32_t)l_547 + (int32_t)(((uint32_t)5U + (uint32_t)g_139.f1) < l_564)) == g_402)))) >= l_547) << (uint16_t)13) > g_131) >> (uint16_t)g_9)))) + (uint16_t)p_33))
                    { /* block id: 319 */
                        g_402 = (((int32_t)((uint32_t)(__builtin_parityll(p_33) ^ ((4294967295U < (-10)) == ((!((uint16_t)0U << (uint16_t)p_33)) < ((p_33 != __builtin_popcount(p_33)) >= g_463)))) - (uint32_t)0x1EE1C4D0) % (int32_t)p_33) || 0xA712);
                        l_504.f1 = g_139.f1;
                    }
                    else
                    { /* block id: 322 */
                        uint16_t l_578 = 0x2C73;
                        l_504.f1 = (((((((int32_t)((((6U || g_139.f1) < 1) & p_33) > (p_33 < (l_545 > __builtin_clzl(g_139.f1)))) % (int32_t)((int16_t)((uint16_t)l_578 + (uint16_t)0xEFD2) << (int16_t)g_139.f0)) ^ g_9) <= p_33) >= l_578) >= 1) >= g_463);
                    }
                }
            }
            else
            { /* block id: 326 */
                int32_t l_607 = (-7);
                for (l_545 = 26; (l_545 <= 26); l_545 += 1)
                { /* block id: 329 */
                    uint16_t l_584 = 65527U;
                    struct S0 l_587 = {6,-5736,3611};
                    if (g_139.f1)
                    { /* block id: 330 */
                        g_402 = p_33;
                    }
                    else
                    { /* block id: 332 */
                        return l_536;
                    }
                    l_546.f1 = (((g_463 >= ((g_139.f2 || ((p_33 > ((uint32_t)(4U != ((l_545 <= g_139.f2) || ((0x8966 | 0x4750) == ((p_33 <= 1) & p_33)))) - (uint32_t)(-1))) || g_137)) && 0x5B45)) != g_583) == l_584);
                    for (l_559 = 0; (l_559 >= (-29)); l_559 -= 1)
                    { /* block id: 338 */
                        l_504.f1 = p_33;
                        l_587 = l_504;
                        l_587.f1 = __builtin_ia32_crc32qi(((int16_t)((int16_t)(((int16_t)(l_559 > (p_33 && g_463)) >> (int16_t)(0x1570 >= (((int32_t)(((int16_t)(((int32_t)((uint32_t)((int32_t)(func_56((p_33 >= l_587.f0), (0xDF625032 == ((~((uint16_t)p_33 >> (uint16_t)__builtin_clz(l_546.f0))) > g_131)), l_559) > 7) % (int32_t)l_504.f0) - (uint32_t)l_607) - (int32_t)l_546.f1) != 2) >> (int16_t)10) | (-8)) - (int32_t)0) > l_607))) & 0x9AFE) + (int16_t)0) << (int16_t)l_608), p_33);
                        l_609 = l_504;
                    }
                    g_137 = g_520;
                }
            }
        }
        else
        { /* block id: 347 */
            l_609.f1 = 0x269C28DA;
        }
        l_609.f1 = p_33;
    }
    for (g_131 = (-25); (g_131 == 40); g_131 += 6)
    { /* block id: 354 */
        int32_t l_622 = 0x45787043;
        struct S0 l_632 = {18,-1707,1407};
        int16_t l_712 = 0x3F4E;
        if (g_139.f1)
        { /* block id: 355 */
            uint16_t l_617 = 65535U;
            g_402 = g_402;
            for (g_9 = 0; (g_9 != 54); g_9 += 9)
            { /* block id: 359 */
                int32_t l_616 = 0x7A04CEC2;
                l_504.f1 = ((p_33 == ((uint16_t)((g_139.f2 <= g_520) == l_616) - (uint16_t)l_617)) > ((uint32_t)__builtin_ctzl((((uint16_t)((l_622 != (func_51(((((uint16_t)g_402 << (uint16_t)13) <= (~((uint16_t)p_33 % (uint16_t)((uint16_t)((g_402 && 0U) >= g_139.f1) >> (uint16_t)l_622)))) > g_463), p_33, l_504) > 6U)) != p_33) >> (uint16_t)g_520) && (-1))) - (uint32_t)l_622));
                l_504.f1 = (g_131 & (((int32_t)p_33 % (int32_t)4294967288U) & g_463));
            }
            g_633 = l_632;
        }
        else
        { /* block id: 364 */
            int32_t l_653 = 0xB9094F61;
            uint32_t l_673 = 9U;
            struct S0 l_697 = {1,-2846,4020};
            struct S0 l_699 = {11,-5639,1415};
            if (((func_64(l_622, p_33) >= func_64(p_33, ((uint32_t)l_632.f0 % (uint32_t)g_266))) == g_636))
            { /* block id: 365 */
                int16_t l_670 = 0x7CC6;
                int32_t l_696 = (-2);
                struct S0 l_698 = {9,-4684,3697};
                g_139 = g_139;
                if (g_9)
                { /* block id: 367 */
                    g_633.f1 = func_64(p_33, l_504.f1);
                    return g_131;
                }
                else
                { /* block id: 370 */
                    int32_t l_642 = 0;
                    int32_t l_672 = 0xE77E9106;
                    for (g_463 = 0; (g_463 >= 57); g_463 += 1)
                    { /* block id: 373 */
                        g_633.f1 = g_131;
                        return g_633.f0;
                    }
                    if ((func_51(((uint16_t)((l_632.f1 ^ 0xD1BB) > (!l_642)) << (uint16_t)(((int16_t)2 - (int16_t)((int32_t)(l_504.f1 > ((uint16_t)(0 <= (-1)) + (uint16_t)g_633.f1)) - (int32_t)4294967295U)) & p_33)), l_35, l_504) == g_520))
                    { /* block id: 377 */
                        uint32_t l_671 = 5U;
                        l_653 = (((((int16_t)((int16_t)g_9 % (int16_t)((l_653 < ((func_64((p_33 > ((uint16_t)((uint16_t)(((uint16_t)((int16_t)((int16_t)((int16_t)(2 != ((uint32_t)((p_33 >= (__builtin_ffsl(p_33) ^ ((g_636 && ((uint16_t)(p_33 && g_636) - (uint16_t)p_33)) ^ 0x247B))) & l_670) - (uint32_t)0x7A293B2F)) >> (int16_t)3) << (int16_t)l_632.f0) >> (int16_t)p_33) + (uint16_t)g_139.f1) == l_671) - (uint16_t)g_139.f0) << (uint16_t)p_33)), g_583) != p_33) > l_653)) || 1)) >> (int16_t)l_642) <= 3) <= p_33) ^ p_33);
                        l_672 = (g_463 | g_137);
                        l_653 = l_673;
                    }
                    else
                    { /* block id: 381 */
                        int32_t l_680 = 0;
                        int32_t l_681 = 0x5732C6AA;
                        g_137 = (((int16_t)l_653 >> (int16_t)((0x4DAC24CF != ((((int16_t)(-6) - (int16_t)g_520) < 0xF53E) ^ ((int32_t)func_51((func_64(l_680, l_632.f0) || 0x49022FF4), g_131, g_633) - (int32_t)l_681))) < l_642)) != g_633.f0);
                        l_681 = (((uint32_t)((int16_t)g_583 - (int16_t)(g_131 != (l_670 && (((((uint32_t)l_632.f0 - (uint32_t)(((p_33 != ((0 | ((g_137 | (p_33 ^ (((int16_t)(l_35 < g_636) >> (int16_t)1) & p_33))) & 0)) <= g_131)) & g_137) | 0)) <= g_139.f0) | g_139.f1) == p_33)))) % (uint32_t)g_520) == l_632.f1);
                        if (p_33)
                            continue;
                    }
                    l_653 = p_33;
                    if (g_463)
                    { /* block id: 387 */
                        g_692 = ((((g_139.f0 >= g_520) & ((uint16_t)(l_642 ^ (g_520 >= func_64(((l_670 <= 0x07AB5E51) != (p_33 <= 65535U)), l_672))) - (uint16_t)p_33)) < l_670) != 0xFC9C);
                        if (g_583)
                            break;
                        l_696 = ((uint16_t)l_695 << (uint16_t)11);
                        if (g_633.f2)
                            continue;
                    }
                    else
                    { /* block id: 392 */
                        g_137 = p_33;
                        l_632.f1 = (0 >= g_139.f1);
                        l_672 = func_64(g_633.f2, g_520);
                        l_698 = l_697;
                    }
                }
                l_699 = l_504;
            }
            else
            { /* block id: 400 */
                int32_t l_702 = 1;
                l_504.f1 = (__builtin_bswap32(p_33) <= ((uint32_t)l_702 - (uint32_t)0x180BFA50));
                l_699 = l_632;
                if (l_632.f0)
                    break;
            }
            for (g_636 = (-2); (g_636 == 48); g_636 += 3)
            { /* block id: 407 */
                int32_t l_709 = (-1);
                l_697.f1 = (((((0x9FA8 ^ 0xDE03) || ((~(((((~p_33) == l_673) && g_131) == 0x4B65) >= g_520)) != 1U)) == (((uint16_t)__builtin_ffs(l_709) % (uint16_t)l_504.f0) == p_33)) == 0) == 0xBB5B);
            }
            l_712 = ((int32_t)(__builtin_popcountl(g_402) <= g_266) + (int32_t)g_9);
        }
    }
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_131 g_139 g_137 g_266 g_402 g_463
 * writes: g_9 g_131 g_137 g_139 g_402 g_266
 */
static struct S0  func_42(uint32_t  p_43)
{ /* block id: 46 */
    uint32_t l_55 = 0xE1665806;
    struct S0 l_461 = {18,2420,2635};
    int32_t l_503 = 0x814E295E;
    l_461.f1 = func_45(((~(-(uint16_t)((uint32_t)((__builtin_bswap32(p_43) || (func_51(l_55, func_56(p_43, (((uint16_t)g_9 >> (uint16_t)8) >= (func_64(l_55, p_43) != (-1))), l_55), l_461) && g_139.f1)) && p_43) % (uint32_t)p_43))) <= g_463));
    l_503 = ((int16_t)l_55 + (int16_t)l_55);
    return l_461;
}


/* ------------------------------------------ */
/* 
 * reads : g_266 g_402 g_463 g_131 g_9 g_139
 * writes: g_266 g_9 g_131 g_137 g_139.f1
 */
static int32_t  func_45(int16_t  p_46)
{ /* block id: 250 */
    int32_t l_468 = 0xC8CDFC55;
    int32_t l_483 = (-6);
    struct S0 l_486 = {22,-4704,713};
    uint32_t l_500 = 0xA571DF16;
    for (g_266 = 28; (g_266 != 19); g_266 -= 1)
    { /* block id: 253 */
        int32_t l_469 = 7;
        struct S0 l_479 = {28,-1699,442};
        uint32_t l_480 = 0x5E339E2D;
        if ((65529U & (((p_46 != __builtin_parityll(p_46)) ^ (0xA1083C83 != ((uint16_t)((g_402 == 0xF463) ^ p_46) >> (uint16_t)4))) <= (((__builtin_ia32_crc32qi(((g_463 == g_402) < l_468), l_468) && l_469) ^ l_468) | l_469))))
        { /* block id: 254 */
            return l_468;
        }
        else
        { /* block id: 256 */
            uint32_t l_470 = 0xA25797B1;
            l_479 = func_79(l_469, l_470, (((uint16_t)(l_469 | 1U) - (uint16_t)(__builtin_parityll(((uint16_t)l_470 >> (uint16_t)0)) && (~(((uint16_t)((~__builtin_ffsll(g_131)) & l_469) >> (uint16_t)g_463) == 0x003C)))) & 4294967290U), g_131);
            l_480 = (-1);
            for (l_468 = (-3); (l_468 > 3); l_468 += 4)
            { /* block id: 261 */
                l_483 = (-1);
            }
        }
        for (g_131 = 0; (g_131 > 5); g_131 += 1)
        { /* block id: 267 */
            l_486 = g_139;
        }
        for (l_468 = 26; (l_468 >= 5); l_468 -= 1)
        { /* block id: 272 */
            int32_t l_495 = 9;
            g_137 = (((uint16_t)(l_486.f0 >= func_51(p_46, (((__builtin_popcountl(g_139.f2) || ((int32_t)((int32_t)((l_495 >= (!func_64(((((uint16_t)(!0x7E93CE05) - (uint16_t)l_495) < (-1)) == g_402), l_500))) < l_469) + (int32_t)9) + (int32_t)l_480)) > p_46) || l_469), g_139)) << (uint16_t)6) && 0x26169576);
            if (g_463)
                continue;
        }
        g_139.f1 = g_139.f0;
    }
    l_486 = l_486;
    return g_463;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_51(uint16_t  p_52, uint16_t  p_53, struct S0  p_54)
{ /* block id: 247 */
    struct S0 l_462 = {14,2484,3053};
    l_462 = l_462;
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_131 g_139 g_137 g_266 g_402
 * writes: g_9 g_131 g_137 g_139 g_402 g_266
 */
static uint16_t  func_56(int32_t  p_57, uint16_t  p_58, uint16_t  p_59)
{ /* block id: 49 */
    int32_t l_69 = 0xC2457718;
    int32_t l_269 = 0x8F856281;
    int32_t l_270 = 0x26275C86;
    uint32_t l_296 = 0U;
    int32_t l_310 = 0xC31731C5;
    int16_t l_371 = 0;
    struct S0 l_374 = {7,640,1479};
    int32_t l_419 = (-10);
    uint16_t l_458 = 65535U;
    if ((func_67(l_69) < (((((p_58 == (__builtin_popcountll(g_266) == 9U)) < ((int16_t)((l_69 && (6 <= (((l_69 == 0) ^ p_58) ^ l_69))) <= p_59) << (int16_t)p_58)) | p_59) & l_269) && p_57)))
    { /* block id: 142 */
        uint16_t l_271 = 0x97FD;
        int16_t l_275 = 0xCEFE;
        int32_t l_282 = 0x78A36696;
        g_137 = (l_270 <= p_59);
        g_137 = ((l_271 ^ (((uint16_t)65535U << (uint16_t)(~(l_269 >= (((l_275 > (-9)) != (((int16_t)p_57 >> (int16_t)13) != (g_139.f0 >= (g_139.f0 > ((int32_t)l_275 % (int32_t)(-1)))))) >= g_139.f0)))) != 0xB9D29409)) | 0x8FED6AD9);
        l_282 = (((int32_t)((((0x19A2 != __builtin_popcountll(p_57)) >= func_64(l_269, ((-5) < __builtin_ctzl(l_269)))) || g_131) < 0) - (int32_t)8U) != g_9);
        g_139.f1 = g_137;
    }
    else
    { /* block id: 147 */
        uint32_t l_285 = 9U;
        int32_t l_311 = 0x327729D6;
        struct S0 l_324 = {21,-3219,1324};
        uint32_t l_459 = 0x7DFA9CBD;
        l_270 = (((p_59 & ((((int16_t)(65534U < l_285) >> (int16_t)((uint16_t)1U << (uint16_t)9)) < __builtin_ctzll(g_131)) > l_69)) < (((int16_t)p_57 + (int16_t)(0 == g_137)) >= l_285)) >= g_139.f2);
        p_57 = __builtin_bswap32(func_64(g_137, (((((int16_t)g_131 << (int16_t)l_270) == 0x700E5FE5) != 0U) ^ (l_69 ^ __builtin_parityll(((uint16_t)(p_58 & ((((l_285 <= 9U) <= 5) == l_269) ^ p_57)) >> (uint16_t)5))))));
        l_311 = ((int16_t)l_296 << (int16_t)((uint32_t)p_58 % (uint32_t)func_64(((l_285 != p_58) && ((uint32_t)((p_59 < g_139.f2) | (((~(((uint32_t)(((int16_t)((int16_t)(-1) + (int16_t)(((int16_t)(-1) - (int16_t)0x1F5C) & l_285)) >> (int16_t)g_137) || 1U) - (uint32_t)(-7)) >= p_58)) ^ p_57) || p_59)) + (uint32_t)l_310)), p_58)));
        if (p_58)
        { /* block id: 151 */
            int32_t l_317 = 0x81792F41;
            struct S0 l_416 = {31,-1324,1867};
            for (l_69 = 0; (l_69 <= (-28)); l_69 -= 5)
            { /* block id: 154 */
                uint16_t l_327 = 65535U;
                int32_t l_347 = 0xC5D1AA36;
                int32_t l_351 = 0x4F58DC4A;
                uint32_t l_364 = 0x4F2DE70E;
                struct S0 l_367 = {4,-886,3275};
                if (func_64(func_64(g_139.f2, p_59), l_69))
                { /* block id: 155 */
                    uint16_t l_314 = 65535U;
                    struct S0 l_323 = {6,405,328};
                    p_57 = l_285;
                    p_57 = (((p_57 && p_59) & l_314) == ((int32_t)(__builtin_ffsll((__builtin_bswap32(l_317) <= 4U)) > 0U) % (int32_t)0xB58F672B));
                    for (l_296 = 0; (l_296 != 3); l_296 += 1)
                    { /* block id: 160 */
                        int32_t l_322 = 0;
                        struct S0 l_333 = {4,-1443,3972};
                        p_57 = ((int16_t)((4 != func_64(p_59, l_322)) && (0xA996 > p_59)) - (int16_t)(-10));
                        l_324 = l_323;
                        l_333 = func_79((((int16_t)l_327 >> (int16_t)p_58) <= p_58), (!l_269), p_59, ((int16_t)0xF00A + (int16_t)((uint16_t)(((p_57 || l_69) || (p_57 <= 7U)) < g_139.f2) - (uint16_t)g_137)));
                    }
                    if (l_269)
                        break;
                }
                else
                { /* block id: 166 */
                    int32_t l_350 = 0xD89D66DD;
                    p_57 = __builtin_ffsll(((int32_t)0x298B309F + (int32_t)((int16_t)p_58 % (int16_t)((int16_t)g_139.f2 >> (int16_t)((uint16_t)((int16_t)g_131 << (int16_t)((0x7E32 >= (((uint16_t)p_58 - (uint16_t)(func_64(l_317, (!__builtin_parity((l_347 > ((uint16_t)((g_137 > p_59) ^ 0x453EFB3B) << (uint16_t)p_57))))) | l_317)) > l_350)) == g_266)) >> (uint16_t)l_351)))));
                    l_367 = func_79((__builtin_ctzl((-(uint16_t)((((uint16_t)((uint16_t)((int16_t)(!(((((uint16_t)l_311 - (uint16_t)__builtin_ffs(l_350)) == ((uint16_t)p_58 >> (uint16_t)4)) | l_364) != l_327)) % (int16_t)((uint16_t)(l_317 != (p_59 > (p_59 != l_317))) >> (uint16_t)p_59)) >> (uint16_t)l_350) + (uint16_t)g_137) == 0x579A) == l_350))) > g_9), l_317, l_317, l_317);
                }
                l_347 = g_9;
                g_139.f1 = ((p_57 <= __builtin_popcountll(p_58)) ^ ((uint16_t)(-(int32_t)l_371) << (uint16_t)4));
                if (p_57)
                { /* block id: 172 */
                    struct S0 l_387 = {19,5026,1712};
                    uint32_t l_393 = 1U;
                    for (l_327 = (-15); (l_327 != 33); l_327 += 1)
                    { /* block id: 175 */
                        l_270 = (0x2EF7 | (1U & 1));
                        l_374 = l_367;
                        p_57 = func_67(((int16_t)((int16_t)((uint16_t)((uint16_t)p_58 << (uint16_t)0) % (uint16_t)((int16_t)4 + (int16_t)(g_9 || func_64(((uint32_t)0x2EBC6879 % (uint32_t)l_317), g_131)))) >> (int16_t)2) - (int16_t)(0xB306EFA4 && ((p_57 | 1) | l_367.f2))));
                    }
                    l_387 = l_367;
                    if (g_139.f0)
                    { /* block id: 181 */
                        int16_t l_388 = 0xDE90;
                        if (l_388)
                            break;
                    }
                    else
                    { /* block id: 183 */
                        return g_139.f2;
                    }
                    for (l_371 = 0; (l_371 <= (-22)); l_371 -= 1)
                    { /* block id: 188 */
                        p_57 = p_58;
                        l_324 = g_139;
                        l_387.f1 = (((((uint32_t)p_57 - (uint32_t)(-1)) ^ 0x522C845D) || 0xC9EC6936) & ((l_393 == 0x7C31) < ((0x04F95B03 || g_266) ^ p_59)));
                        if (g_137)
                            continue;
                    }
                }
                else
                { /* block id: 194 */
                    return g_139.f2;
                }
            }
            for (l_270 = 24; (l_270 <= (-17)); l_270 -= 1)
            { /* block id: 200 */
                g_137 = ((int32_t)((func_64(((p_58 & p_58) != l_270), p_59) == (((int16_t)p_58 >> (int16_t)((uint16_t)((p_59 | ((((p_59 != __builtin_popcountl((g_139.f1 >= (-9)))) != p_58) >= l_324.f2) > g_139.f2)) ^ 0x20CF4C9D) << (uint16_t)1)) < g_402)) >= l_317) + (int32_t)4294967295U);
            }
            for (g_9 = 0; (g_9 > 48); g_9 += 1)
            { /* block id: 205 */
                g_402 = ((int16_t)0x91E0 + (int16_t)((int16_t)0x4036 + (int16_t)l_317));
                if ((((int16_t)0 + (int16_t)g_402) | func_64(p_57, p_59)))
                { /* block id: 207 */
                    uint32_t l_412 = 0xA9AE8524;
                    g_139.f1 = (((!0x508AB537) ^ l_412) <= ((int16_t)(p_59 > l_374.f2) + (int16_t)(!g_266)));
                    g_139.f1 = g_131;
                }
                else
                { /* block id: 210 */
                    l_416 = g_139;
                    g_402 = ((uint32_t)g_139.f2 + (uint32_t)__builtin_parityl(__builtin_ffsll(l_416.f1)));
                }
                l_317 = (l_317 | l_419);
            }
        }
        else
        { /* block id: 216 */
            uint32_t l_429 = 0xDA724A44;
            struct S0 l_447 = {14,-3374,2666};
            for (g_266 = (-30); (g_266 == 25); g_266 += 4)
            { /* block id: 219 */
                int16_t l_424 = 1;
                struct S0 l_451 = {13,-4895,236};
                if (((g_139.f0 > ((((uint16_t)p_57 - (uint16_t)p_58) < (func_64(l_285, l_424) ^ ((((7 | (((((int16_t)g_131 % (int16_t)((int16_t)func_64(g_139.f0, p_57) << (int16_t)p_58)) || 0x2A7E) != 0) ^ g_139.f0)) || 0xC12E) || p_57) || l_429))) && 0xB1C4)) <= 65534U))
                { /* block id: 220 */
                    uint16_t l_432 = 0xE5A6;
                    struct S0 l_434 = {29,942,3627};
                    for (g_131 = 11; (g_131 >= 11); g_131 += 9)
                    { /* block id: 223 */
                        struct S0 l_433 = {20,4556,290};
                        p_57 = l_432;
                        l_434 = l_433;
                        p_57 = ((g_139.f2 & ((uint32_t)g_402 % (uint32_t)p_57)) <= (((((int16_t)(g_139.f1 <= g_402) + (int16_t)(((uint16_t)l_424 >> (uint16_t)12) && (((int16_t)l_424 << (int16_t)10) <= p_57))) ^ ((int32_t)func_64(((uint16_t)(g_266 <= g_266) >> (uint16_t)l_432), l_269) + (int32_t)0xE3097564)) < p_59) <= l_434.f2));
                        if (p_59)
                            break;
                    }
                }
                else
                { /* block id: 229 */
                    struct S0 l_448 = {8,-2834,108};
                    l_448 = l_447;
                    for (g_9 = 14; (g_9 >= 50); g_9 += 4)
                    { /* block id: 233 */
                        p_57 = __builtin_ffsl(l_429);
                        l_374 = l_447;
                        if (p_57)
                            continue;
                        l_447 = l_451;
                    }
                }
                g_139 = func_79(l_269, p_57, ((!g_137) && ((__builtin_popcountl((func_64(((uint32_t)(((int32_t)(~((((l_458 != 9) | l_459) != (g_139.f0 | (~(-1)))) ^ l_451.f0)) % (int32_t)p_58) == l_447.f0) + (uint32_t)p_57), p_57) ^ g_402)) >= p_57) <= 0)), p_57);
            }
            l_374.f1 = 0xADECD473;
            p_57 = (g_131 & 65526U);
        }
    }
    return g_131;
}


/* ------------------------------------------ */
/* 
 * reads : g_9
 * writes:
 */
static int32_t  func_64(uint16_t  p_65, uint32_t  p_66)
{ /* block id: 47 */
    return g_9;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_131 g_139 g_137
 * writes: g_9 g_131 g_137 g_139
 */
static int32_t  func_67(int16_t  p_68)
{ /* block id: 50 */
    uint32_t l_149 = 0xB9DCA820;
    int32_t l_167 = 5;
    struct S0 l_215 = {11,5393,1426};
    uint32_t l_223 = 3U;
    if (p_68)
    { /* block id: 51 */
        int16_t l_73 = 0xB430;
        uint32_t l_74 = 0xE0D94485;
        struct S0 l_155 = {31,4754,2132};
        if (((((-(int32_t)0x1A4633BE) ^ ((uint16_t)g_9 >> (uint16_t)(__builtin_ffs(p_68) == (0xCD4EE3B9 >= l_73)))) | func_64(l_74, l_74)) | 6))
        { /* block id: 52 */
            return p_68;
        }
        else
        { /* block id: 54 */
            uint32_t l_75 = 0xFE0C2DF1;
            uint32_t l_153 = 1U;
            int32_t l_154 = 6;
            l_75 = p_68;
            g_139 = func_76(g_9, p_68);
            l_154 = (__builtin_popcountll(l_74) != ((uint32_t)((-(uint16_t)((uint16_t)(((func_64(l_74, (g_139.f2 & (((uint32_t)l_149 % (uint32_t)l_74) ^ ((l_73 >= (((uint32_t)(~func_64(g_137, p_68)) - (uint32_t)g_139.f0) ^ g_139.f0)) <= 0U)))) || 0x723E4D7B) > l_153) > 0U) + (uint16_t)g_9)) <= p_68) - (uint32_t)g_139.f2));
        }
        l_155 = func_76(g_131, (l_74 == (-10)));
        if (((uint32_t)0x33990FFC % (uint32_t)(-1)))
        { /* block id: 92 */
            uint32_t l_162 = 4294967287U;
            l_155 = g_139;
            l_167 = ((uint16_t)((p_68 <= p_68) == (((p_68 < func_64(p_68, ((uint16_t)(l_162 >= (((int16_t)((g_139.f2 && (((int16_t)g_139.f2 >> (int16_t)p_68) <= __builtin_parityl(__builtin_bswap64(l_155.f2)))) <= g_137) + (int16_t)g_131) < p_68)) << (uint16_t)15))) != l_74) > 1)) + (uint16_t)p_68);
        }
        else
        { /* block id: 95 */
            struct S0 l_170 = {3,-1009,2477};
            uint32_t l_210 = 0x449593A4;
            for (g_131 = 0; (g_131 != 45); g_131 += 9)
            { /* block id: 98 */
                int32_t l_178 = 0xC15F2E48;
                int32_t l_179 = (-1);
                g_139.f1 = p_68;
                l_170 = l_170;
                if (((1 ^ (-(int32_t)(l_170.f2 < (((uint16_t)((uint16_t)p_68 % (uint16_t)p_68) + (uint16_t)(-1)) <= ((int16_t)p_68 % (int16_t)(__builtin_ctzl(func_64(l_149, l_178)) | l_170.f2)))))) && 0x12C82440))
                { /* block id: 101 */
                    struct S0 l_186 = {18,2334,1500};
                    int32_t l_198 = 0x5F78ABD9;
                    l_179 = g_131;
                    if (((int16_t)((__builtin_popcountll(g_9) != g_139.f2) < (__builtin_ffsl(__builtin_clzll(g_139.f2)) >= ((int16_t)(!l_170.f2) << (int16_t)15))) << (int16_t)l_179))
                    { /* block id: 103 */
                        struct S0 l_185 = {15,-1171,674};
                        l_185 = g_139;
                        g_139 = g_139;
                        l_155 = l_186;
                        if (l_170.f1)
                            break;
                    }
                    else
                    { /* block id: 108 */
                        int32_t l_187 = 0x74C2865F;
                        g_137 = l_170.f0;
                        g_139.f1 = ((p_68 >= 0xBA89) ^ (l_187 && p_68));
                        g_139.f1 = (((int16_t)l_155.f1 % (int16_t)(l_186.f2 & ((0x50C1 <= ((int16_t)(((int32_t)(g_9 && (((p_68 == (((uint16_t)((int16_t)(((__builtin_parityl(p_68) & (-8)) || g_139.f0) <= 4294967295U) - (int16_t)l_73) >> (uint16_t)15) < l_187)) ^ g_9) < p_68)) + (int32_t)g_139.f0) | l_178) >> (int16_t)g_139.f0)) | (-1)))) <= l_198);
                    }
                    l_167 = (p_68 != ((((g_139.f1 == p_68) == func_64(((int16_t)((0U ^ __builtin_popcountl((p_68 < (65535U < (p_68 & (0x98316328 <= (((int16_t)((~(((0xA3C54BD2 ^ 0x3D0C7CD9) >= p_68) & 7U)) & 0xD469F3BF) - (int16_t)0U) ^ (-1)))))))) >= (-5)) << (int16_t)g_139.f1), g_139.f1)) & g_137) && l_74));
                }
                else
                { /* block id: 114 */
                    if ((0x75C4 < (p_68 == ((int32_t)(__builtin_clz((((int32_t)(-6) + (int32_t)((l_210 & ((0x3B223AF5 != ((uint16_t)((func_64((1U == ((((int16_t)(0x0B5E >= l_149) % (int16_t)1) > 0xAB57) && p_68)), p_68) | p_68) <= g_9) >> (uint16_t)g_139.f0)) > p_68)) | p_68)) >= 3U)) & l_170.f2) - (int32_t)l_155.f1))))
                    { /* block id: 115 */
                        return p_68;
                    }
                    else
                    { /* block id: 117 */
                        return p_68;
                    }
                }
            }
            l_155.f1 = (0xDCDEADA2 > 4294967288U);
        }
    }
    else
    { /* block id: 124 */
        struct S0 l_216 = {13,-2875,3255};
        l_167 = (p_68 != (-4));
        l_216 = l_215;
    }
    if (((int16_t)((int32_t)0xE9BF4C0A - (int32_t)(~l_215.f2)) << (int16_t)15))
    { /* block id: 128 */
        uint16_t l_222 = 0x32CA;
        uint32_t l_224 = 1U;
        struct S0 l_237 = {22,1877,2671};
        l_222 = g_9;
        l_224 = ((g_139.f0 > l_223) >= g_9);
        for (l_223 = (-5); (l_223 < 18); l_223 += 6)
        { /* block id: 133 */
            int16_t l_238 = (-7);
            int32_t l_239 = 0xFC3F6F0A;
            l_237 = func_76(g_139.f2, ((uint32_t)g_139.f0 + (uint32_t)(l_215.f1 && ((~(l_224 <= ((int16_t)((int16_t)p_68 >> (int16_t)2) - (int16_t)(!(((l_222 & ((uint32_t)l_215.f0 % (uint32_t)(0x96B8FCFD & (p_68 > g_139.f0)))) ^ 4294967288U) | 65535U))))) | p_68))));
            l_239 = l_238;
            l_237.f1 = ((uint16_t)g_139.f0 + (uint16_t)((uint16_t)(g_139.f1 == 0x81EB) + (uint16_t)(((int16_t)((int16_t)p_68 % (int16_t)0x9EB2) << (int16_t)13) && (0 ^ func_64(g_139.f1, ((int16_t)((uint16_t)(g_137 && ((uint16_t)((((0xE0F4 ^ l_223) == l_238) | g_9) | p_68) >> (uint16_t)g_131)) >> (uint16_t)15) % (int16_t)g_139.f0))))));
        }
    }
    else
    { /* block id: 138 */
        uint32_t l_254 = 4294967293U;
        struct S0 l_265 = {18,-2756,4067};
        l_265 = func_79(p_68, l_254, g_139.f1, (((int16_t)(g_139.f0 && g_137) << (int16_t)((uint16_t)((int16_t)(((g_139.f0 ^ ((((int16_t)((int16_t)g_139.f0 + (int16_t)((((l_254 < ((7 & p_68) == p_68)) || l_254) <= g_139.f1) & 0U)) >> (int16_t)l_215.f2) & g_137) > 0)) ^ p_68) || g_9) << (int16_t)3) % (uint16_t)0x7A27)) && (-1)));
    }
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_131 g_139
 * writes: g_9 g_131 g_137
 */
static struct S0  func_76(int32_t  p_77, uint32_t  p_78)
{ /* block id: 56 */
    int32_t l_84 = 0x3CE99C24;
    struct S0 l_138 = {23,-5713,2014};
    l_138 = func_79(l_84, l_84, (p_77 > g_9), (((func_64((l_84 > p_78), p_77) || (p_77 == l_84)) || 0xB53ABF6A) > p_78));
    return g_139;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_131
 * writes: g_9 g_131 g_137
 */
static struct S0  func_79(uint32_t  p_80, uint16_t  p_81, int32_t  p_82, uint32_t  p_83)
{ /* block id: 57 */
    int32_t l_85 = (-1);
    struct S0 l_86 = {27,-5303,3472};
    int32_t l_89 = 0xECD44262;
    uint32_t l_100 = 1U;
    int16_t l_122 = 0xDEF1;
    struct S0 l_135 = {7,-4094,679};
    l_85 = g_9;
    l_86 = l_86;
    l_86.f1 = ((uint32_t)func_64((l_89 == ((int16_t)l_89 - (int16_t)(((~((g_9 & l_85) | (g_9 & (g_9 > ((int32_t)(-(int16_t)(~0x34D5)) - (int32_t)(!((int32_t)(func_64((l_89 || l_86.f0), l_100) <= (-1)) - (int32_t)0U))))))) != 0x874B34BC) >= p_83))), p_82) % (uint32_t)p_80);
    for (p_82 = 14; (p_82 != 2); p_82 -= 4)
    { /* block id: 63 */
        int16_t l_121 = 0x9941;
        struct S0 l_134 = {19,1175,397};
        if ((((uint16_t)((int16_t)(l_85 == (((int32_t)0x0062155B - (int32_t)((((int16_t)((int16_t)__builtin_clzl(g_9) % (int16_t)p_80) + (int16_t)((uint16_t)((uint16_t)(func_64(func_64(g_9, (((uint32_t)4294967286U - (uint32_t)(g_9 >= ((int16_t)l_121 >> (int16_t)g_9))) && 3U)), l_86.f2) == g_9) >> (uint16_t)0) << (uint16_t)13)) <= 0xE6A8) > 0xA482)) > 0xDD55)) << (int16_t)l_122) - (uint16_t)0x901D) ^ p_82))
        { /* block id: 64 */
            l_85 = g_9;
        }
        else
        { /* block id: 66 */
            struct S0 l_127 = {0,-3956,1243};
            for (g_9 = 6; (g_9 != 39); g_9 += 3)
            { /* block id: 69 */
                struct S0 l_128 = {6,-1788,2533};
                for (l_89 = (-8); (l_89 >= (-20)); l_89 -= 1)
                { /* block id: 72 */
                    l_128 = l_127;
                }
                g_131 = ((uint16_t)0xBD68 >> (uint16_t)p_82);
            }
        }
        for (p_81 = 0; (p_81 > 26); p_81 += 1)
        { /* block id: 80 */
            l_135 = l_134;
            g_137 = (-(uint16_t)g_131);
        }
    }
    return l_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc(g_131, "g_131", print_hash_value);
    transparent_crc(g_137, "g_137", print_hash_value);
    transparent_crc(g_139.f0, "g_139.f0", print_hash_value);
    transparent_crc(g_139.f1, "g_139.f1", print_hash_value);
    transparent_crc(g_139.f2, "g_139.f2", print_hash_value);
    transparent_crc(g_266, "g_266", print_hash_value);
    transparent_crc(g_402, "g_402", print_hash_value);
    transparent_crc(g_463, "g_463", print_hash_value);
    transparent_crc(g_520, "g_520", print_hash_value);
    transparent_crc(g_583, "g_583", print_hash_value);
    transparent_crc(g_633.f0, "g_633.f0", print_hash_value);
    transparent_crc(g_633.f1, "g_633.f1", print_hash_value);
    transparent_crc(g_633.f2, "g_633.f2", print_hash_value);
    transparent_crc(g_636, "g_636", print_hash_value);
    transparent_crc(g_692, "g_692", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 118
   depth: 1, occurrence: 45
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 45
breakdown:
   indirect level: 0, occurrence: 45
XXX full-bitfields structs in the program: 45
breakdown:
   indirect level: 0, occurrence: 45
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 47
XXX times a bitfields struct on RHS: 43
XXX times a single bitfield on LHS: 31
XXX times a single bitfield on RHS: 134

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 264
   depth: 2, occurrence: 46
   depth: 3, occurrence: 8
   depth: 4, occurrence: 8
   depth: 5, occurrence: 8
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 5
   depth: 14, occurrence: 5
   depth: 15, occurrence: 4
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 5
   depth: 20, occurrence: 5
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 23, occurrence: 5
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 815
XXX times a non-volatile is write: 174
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 244
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 32
   depth: 2, occurrence: 43
   depth: 3, occurrence: 34
   depth: 4, occurrence: 44
   depth: 5, occurrence: 62

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

