/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1955293779
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 8;
   unsigned f1 : 31;
   signed f2 : 6;
   uint16_t  f3;
   uint16_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_31(void);
inline static int32_t  func_32(int32_t  p_33, int8_t  p_34, uint32_t  p_35, int32_t  p_36, int32_t  p_37);
static uint16_t  func_39(uint32_t  p_40, uint32_t  p_41);
inline static int16_t  func_42(int8_t  p_43, uint16_t  p_44, uint32_t  p_45);
inline static int8_t  func_46(struct S0  p_47, int32_t  p_48, uint32_t  p_49, int32_t  p_50, int8_t  p_51);
static struct S0  func_62(uint16_t  p_63, struct S0  p_64);
static int16_t  func_65(uint16_t  p_66);
inline static uint32_t  func_71(uint16_t  p_72);
inline static struct S0  func_81(int16_t  p_82, struct S0  p_83, int32_t  p_84, int32_t  p_85);
inline static struct S0  func_87(int32_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_31(void)
{ /* block id: 36 */
    struct S0 l_38 = {4,16854,-7,0x06AA,1U};
    int32_t l_54 = 0x312EF314;
    int32_t l_59 = 0x442F2AA7;
    int32_t l_60 = (-7);
    int8_t l_61 = 0xFC;
    int32_t l_216 = 0x0A612E5C;
    int16_t l_249 = 0xF3D0;
    int32_t l_484 = 0;
    uint16_t l_487 = 0x4B28;
    uint32_t l_499 = 1U;
    l_484 = ((func_32((0x2DE4 ^ ((l_38 = l_38) , func_39(l_38.f0, ((l_216 |= func_42(func_46(l_38, l_38.f3, ((int16_t)(l_60 = ((l_54 = l_38.f0) < (((((l_59 = (((int32_t)l_38.f2 % (int32_t)((uint16_t)(l_38.f2 , (l_38.f4 >= (-1))) << (uint16_t)9)) > l_38.f4)) & l_38.f4) == 0) && l_38.f1) >= l_38.f1))) >> (int16_t)11), l_38.f3, l_61), l_38.f3, l_38.f4)) == (-2))))), l_61, l_61, l_61, l_249) & l_249) <= 0xAF3776FB);
    for (l_54 = 0; (l_54 > 20); l_54 += 1)
    { /* block id: 294 */
        uint16_t l_488 = 9U;
        int32_t l_489 = 0;
        int8_t l_498 = 0x2F;
        struct S0 l_500 = {-6,45074,-2,0x0A0B,65535U};
        l_489 = (l_487 <= l_488);
        l_59 = l_489;
        l_500 = func_81(l_38.f3, l_38, (l_489 = (((l_488 || (l_498 = ((int16_t)(((0 >= ((((int16_t)func_39((((uint32_t)1U + (uint32_t)(((int16_t)l_38.f4 >> (int16_t)11) != l_484)) != 0x783D), __builtin_bswap64(l_488)) % (int16_t)l_61) < l_488) > l_489)) ^ l_489) || l_61) + (int16_t)l_249))) , 65534U) <= l_499)), l_60);
    }
    l_54 = 0x3FC80BBA;
    return l_249;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_32(int32_t  p_33, int8_t  p_34, uint32_t  p_35, int32_t  p_36, int32_t  p_37)
{ /* block id: 173 */
    uint32_t l_250 = 0x23DD3832;
    struct S0 l_264 = {15,4086,6,0x7BDE,1U};
    int32_t l_272 = 0xD38B32CD;
    uint16_t l_360 = 1U;
    int32_t l_375 = 0;
    int8_t l_433 = 0;
    int16_t l_479 = 9;
    l_250 |= (0x1398 ^ p_37);
    for (p_33 = (-20); (p_33 == (-29)); p_33 -= 1)
    { /* block id: 177 */
        int16_t l_255 = 0x6CA5;
        struct S0 l_265 = {-7,24497,-6,1U,0x072E};
        struct S0 l_266 = {-4,38905,-3,1U,0U};
        int32_t l_271 = 0xD2D85002;
        int16_t l_296 = (-9);
        int32_t l_333 = (-2);
        if ((((uint32_t)l_255 + (uint32_t)((uint32_t)((int16_t)0 << (int16_t)(((int16_t)((p_34 = ((int32_t)func_46((l_266 = (__builtin_ffsll(p_34) , (l_265 = l_264))), (l_272 ^= ((((int16_t)(l_271 = l_255) % (int16_t)l_255) == ((func_71(p_36) == 0x8485) > l_255)) , 0xE73B7B60)), l_255, p_34, p_36) + (int32_t)l_255)) , l_250) >> (int16_t)0) >= 0x7EEA)) % (uint32_t)p_36)) < l_264.f1))
        { /* block id: 183 */
            int32_t l_273 = 0x842C5C37;
            int32_t l_274 = 0;
            int32_t l_287 = 3;
            l_274 |= l_273;
            if ((l_274 ^ 3))
            { /* block id: 185 */
                l_271 &= p_36;
            }
            else
            { /* block id: 187 */
                uint32_t l_285 = 0x5D65EFD6;
                int32_t l_286 = 0x562E677A;
                l_265 = func_62(p_34, (((uint16_t)(l_265.f2 ^= p_36) >> (uint16_t)5) , (p_37 , func_62(__builtin_bswap64(((0x7187948F < l_265.f2) , ((int16_t)(l_287 = (l_286 ^= ((l_274 = (((int16_t)(((int16_t)(p_35 & (p_34 && ((uint16_t)p_37 + (uint16_t)l_285))) - (int16_t)p_34) == p_36) % (int16_t)l_265.f4) >= p_35)) , p_35))) << (int16_t)12))), l_264))));
            }
            l_264.f2 = ((((l_287 ^ p_33) >= ((uint16_t)(((int16_t)((0 | l_274) <= ((uint16_t)(l_264.f0 <= ((int16_t)0x8F45 >> (int16_t)l_264.f4)) * (uint16_t)(__builtin_parityll(l_296) == l_274))) >> (int16_t)1) != l_273) << (uint16_t)6)) == l_264.f3) , p_35);
            l_264.f0 = p_33;
        }
        else
        { /* block id: 196 */
            int32_t l_312 = 0x55957BA3;
            int32_t l_313 = (-1);
            int8_t l_314 = (-7);
            int32_t l_335 = 0x32A31CB7;
            int32_t l_336 = (-1);
            uint16_t l_362 = 0U;
            uint32_t l_378 = 0x1543CFDC;
            struct S0 l_383 = {10,25829,-4,0xDA9F,0x442B};
            int16_t l_413 = 0x2C48;
            if (__builtin_popcountll(((int32_t)p_36 % (int32_t)(__builtin_clz(l_264.f0) | ((l_272 = ((((int16_t)((int16_t)p_33 % (int16_t)((int16_t)p_37 * (int16_t)((uint16_t)((((uint16_t)(l_266.f2 ^ p_36) - (uint16_t)((uint16_t)0x01B7 + (uint16_t)(((((!((l_313 = (((l_312 != l_312) , l_312) < l_265.f0)) , 0x2A7C)) <= p_36) < 0U) | p_35) > l_265.f3))) | 1) != l_255) % (uint16_t)p_37))) - (int16_t)1U) == l_264.f0) != 0)) , l_313)))))
            { /* block id: 199 */
                if (l_314)
                    break;
                return l_264.f4;
            }
            else
            { /* block id: 202 */
                int32_t l_322 = (-7);
                int32_t l_334 = 0;
                int32_t l_350 = 0xEE6B636F;
                int8_t l_361 = 0x09;
                int16_t l_437 = 1;
                for (l_313 = 0; (l_313 != (-2)); l_313 -= 1)
                { /* block id: 205 */
                    struct S0 l_319 = {9,1652,-0,0x2529,0x2947};
                    int32_t l_328 = 3;
                    for (p_35 = 0; (p_35 == 18); p_35 += 1)
                    { /* block id: 208 */
                        l_319 = l_264;
                    }
                    l_336 |= ((uint16_t)((l_264.f3 , 8) , l_322) * (uint16_t)((int16_t)__builtin_popcount(p_36) + (int16_t)((int16_t)(!((l_328 > ((((((p_37 , ((uint16_t)(l_335 = (l_265.f2 ^= ((((l_334 &= ((int16_t)(l_322 | (l_333 || l_264.f4)) + (int16_t)p_37)) && p_37) <= l_266.f0) || p_34))) % (uint16_t)l_319.f4)) & 1U) ^ p_36) , l_319.f0) || l_334) ^ l_328)) < l_322)) * (int16_t)0x20C3)));
                    l_335 = (l_336 |= (func_87((0x0296 >= (~((uint32_t)(l_350 &= (((((l_319.f0 = (((uint16_t)l_333 << (uint16_t)p_34) || (l_322 & ((l_333 | ((uint16_t)p_34 >> (uint16_t)l_319.f1)) , (((int16_t)(l_334 = ((uint16_t)((((int16_t)0 * (int16_t)(l_296 || l_272)) < p_37) < 65527U) * (uint16_t)l_264.f1)) << (int16_t)7) & l_314))))) != 0x4D11) ^ (-10)) >= p_37) ^ l_319.f3)) % (uint32_t)l_250)))) , p_37));
                    l_319.f2 = ((int16_t)__builtin_popcountl((p_35 |= (((uint32_t)4294967289U + (uint32_t)((uint32_t)((((~l_265.f2) | (l_319.f4 && 0xF564)) > (((p_36 > p_37) == (l_335 = 3U)) > ((((int32_t)p_37 % (int32_t)0x90142E07) | (-1)) != l_266.f0))) != l_264.f1) - (uint32_t)p_33)) <= l_360))) % (int16_t)l_312);
                }
                if (l_312)
                { /* block id: 224 */
                    int16_t l_374 = (-4);
                    int32_t l_376 = 0;
                    if (l_361)
                    { /* block id: 225 */
                        struct S0 l_371 = {-0,6422,-2,0xF41F,0x9E01};
                        int32_t l_377 = (-1);
                        l_334 = l_362;
                        l_378 ^= func_71((func_39((l_313 = p_35), ((((uint16_t)(l_265.f2 = func_39(((int16_t)p_33 << (int16_t)7), ((int32_t)(((((l_377 &= ((int32_t)p_34 + (int32_t)(func_46(l_371, p_35, (l_350 ^= __builtin_clzl(((uint16_t)65527U << (uint16_t)2))), (l_375 |= (((l_374 = p_34) != ((l_336 ^= 0x7E0134C8) != 3U)) ^ p_36)), l_376) >= p_34))) >= 0x24D5) >= p_37) == p_37) || 9) + (int32_t)l_250))) << (uint16_t)l_314) <= p_35) , p_37)) != l_265.f1));
                        l_377 = (p_33 <= ((uint16_t)p_37 - (uint16_t)((2U & (((uint16_t)p_36 << (uint16_t)(p_33 , (((l_371.f0 = (l_376 = (l_334 , (l_371.f3 | __builtin_bswap64((l_383 , ((uint32_t)p_34 % (uint32_t)0xB442703D))))))) != p_36) | 65535U))) <= l_350)) || l_371.f3)));
                        l_376 &= ((l_265.f1 , ((uint16_t)((int16_t)(0x0D44 | ((uint16_t)(p_37 ^ p_34) * (uint16_t)((l_265.f2 > (l_264.f2 = p_35)) | 65534U))) * (int16_t)(p_37 <= p_33)) * (uint16_t)0x784E)) ^ 0xE8AB695C);
                    }
                    else
                    { /* block id: 240 */
                        l_376 = p_35;
                        return p_37;
                    }
                    l_376 = (0xF585 ^ (1 > (l_375 = l_376)));
                }
                else
                { /* block id: 246 */
                    struct S0 l_392 = {5,39833,-3,0xEAE9,0U};
                    l_264 = (l_392 = l_392);
                }
                for (l_336 = 0; (l_336 <= (-21)); l_336 -= 1)
                { /* block id: 252 */
                    uint32_t l_403 = 4294967291U;
                    int32_t l_408 = (-6);
                    l_335 = ((int16_t)((int16_t)(((int16_t)((int16_t)(l_403 & ((((int16_t)((int32_t)p_36 + (int32_t)(-9)) >> (int16_t)2) , ((l_408 &= 1U) && (l_383.f0 &= (((((uint32_t)(((((int32_t)(l_350 = l_413) + (int32_t)((uint16_t)((int16_t)l_271 + (int16_t)((((int16_t)((uint16_t)(((((uint16_t)65535U + (uint16_t)(l_265.f2 |= ((uint16_t)(func_65(p_35) , l_334) << (uint16_t)p_34))) , 0) & l_334) | l_403) + (uint16_t)l_408) % (int16_t)l_403) != 0xCDB2) || l_255)) * (uint16_t)65535U)) , p_35) & l_361) && l_334) - (uint32_t)0xD7494F00) != l_361) || l_350) ^ p_34)))) , 0x5189DBF9)) + (int16_t)p_34) * (int16_t)p_36) != l_403) >> (int16_t)1) % (int16_t)l_362);
                    if (l_375)
                        break;
                    l_266.f0 |= 0xCA978928;
                    l_266.f2 = (l_403 , 0x83098027);
                }
                for (l_383.f4 = 0; (l_383.f4 < 25); l_383.f4 += 1)
                { /* block id: 264 */
                    int16_t l_428 = 0x4AA3;
                    if (p_37)
                    { /* block id: 265 */
                        l_383.f0 |= (l_336 = ((p_36 > p_37) & l_361));
                    }
                    else
                    { /* block id: 268 */
                        int32_t l_438 = 0x75AB5A5E;
                        l_350 &= l_428;
                        l_438 = (p_35 == (__builtin_ctz((((int16_t)(l_264.f0 < ((l_437 = ((uint32_t)(__builtin_parity(l_433) && (~__builtin_ia32_crc32qi((((((l_264.f0 , (l_271 ^= ((uint16_t)65535U << (uint16_t)((func_71(p_33) , p_35) || 0xBF76927B)))) > 0xB1CB31A4) >= (-10)) != l_375) ^ l_428), p_33))) + (uint32_t)4294967295U)) > 0x1A48)) % (int16_t)p_36) == p_34)) , p_35));
                        l_265.f0 = (l_313 ^= func_42(p_36, l_296, (((uint32_t)l_334 % (uint32_t)((int16_t)((int32_t)((int32_t)((int16_t)func_42(p_35, p_37, (((uint16_t)65530U * (uint16_t)__builtin_clz(p_35)) && ((((uint16_t)func_39(((l_438 != l_264.f1) == 0x40496E67), p_37) % (uint16_t)6U) && 0x05D1) == p_37))) - (int16_t)l_265.f1) + (int32_t)p_37) + (int32_t)p_36) >> (int16_t)10)) ^ p_35)));
                    }
                }
            }
        }
        l_333 |= (l_266.f0 = (p_34 , (0xE66A == ((int32_t)((int16_t)((((int32_t)(l_272 ^= ((uint16_t)((uint16_t)((((((uint16_t)(((((int16_t)(p_37 || ((((int16_t)(-1) << (int16_t)8) <= __builtin_popcountll(p_34)) , ((-(uint32_t)((p_35 && (l_264.f2 = ((uint16_t)p_36 * (uint16_t)func_65((l_266.f2 = (((((l_433 , 0U) || p_35) == 1) < l_266.f0) >= p_37)))))) == p_36)) <= l_433))) * (int16_t)8U) > p_33) | p_36) , p_33) << (uint16_t)13) < l_250) <= p_36) > p_35) && l_266.f4) >> (uint16_t)9) >> (uint16_t)p_36)) + (int32_t)p_36) | p_34) || l_265.f0) + (int16_t)65535U) + (int32_t)l_264.f3))));
        if (l_264.f0)
            break;
        l_266 = l_266;
    }
    l_264.f0 ^= (((int16_t)(l_375 = __builtin_ffsl(((l_250 >= ((p_34 <= ((uint16_t)65535U * (uint16_t)(~1U))) , (l_479 < (0xFCF0 && ((int16_t)((((uint32_t)p_33 + (uint32_t)l_272) != 8U) & 0x427456AC) * (int16_t)p_35))))) , l_375))) >> (int16_t)12) > p_37);
    l_264.f2 &= p_36;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_39(uint32_t  p_40, uint32_t  p_41)
{ /* block id: 147 */
    int8_t l_223 = 0;
    int8_t l_225 = 7;
    int32_t l_230 = 0;
    for (p_40 = 0; (p_40 >= 21); p_40 += 4)
    { /* block id: 150 */
        int8_t l_224 = 7;
        uint32_t l_226 = 4U;
        int32_t l_227 = 2;
        int32_t l_238 = 0xE9157D21;
        int16_t l_248 = (-1);
        if (((int32_t)(__builtin_bswap64(((int32_t)(l_223 = p_41) - (int32_t)l_224)) >= l_225) % (int32_t)(l_227 &= (func_71(l_226) >= l_226))))
        { /* block id: 153 */
            for (l_223 = 0; (l_223 < (-6)); l_223 -= 1)
            { /* block id: 156 */
                l_230 = l_226;
            }
        }
        else
        { /* block id: 159 */
            uint32_t l_237 = 0x02CE18DB;
            int32_t l_241 = 0;
            l_238 &= ((((0x177C5EBF > 0x56198509) || ((int16_t)((int16_t)0x2183 - (int16_t)65535U) << (int16_t)3)) ^ ((l_227 = ((__builtin_popcountll(((uint16_t)p_40 >> (uint16_t)14)) == (func_87((((func_65(p_40) <= l_237) ^ p_40) , l_224)) , 0x38D2D037)) && l_230)) | l_225)) | l_237);
            for (l_223 = 0; (l_223 < (-8)); l_223 -= 2)
            { /* block id: 164 */
                uint32_t l_242 = 0x0D96C9C7;
                struct S0 l_247 = {-8,29248,-5,1U,0xE46F};
                l_241 = l_237;
                l_247 = func_81(l_242, func_87((((((l_241 &= 0U) ^ l_242) , ((p_40 && ((p_40 < (((uint16_t)p_41 >> (uint16_t)(((l_241 ^ p_40) , (((int32_t)(p_41 ^ l_238) % (int32_t)p_41) > p_40)) , p_41)) || l_241)) > 0xB4AA)) | 0x14DE5F10)) >= p_41) >= l_224)), l_227, p_41);
            }
        }
        return l_248;
    }
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_42(int8_t  p_43, uint16_t  p_44, uint32_t  p_45)
{ /* block id: 119 */
    int8_t l_181 = 0;
    uint32_t l_185 = 4294967291U;
    struct S0 l_188 = {11,25625,-0,0x5DA9,0x1904};
    int32_t l_215 = 0x2C08DF40;
    for (p_44 = 22; (p_44 > 3); p_44 -= 2)
    { /* block id: 122 */
        uint32_t l_182 = 0U;
        l_182 ^= __builtin_clz(l_181);
    }
    if ((__builtin_ctzl((0x6E1C0719 || ((int32_t)l_185 % (int32_t)__builtin_popcount(p_44)))) , p_44))
    { /* block id: 125 */
        int8_t l_186 = 0xFC;
        l_186 = p_45;
    }
    else
    { /* block id: 127 */
        uint16_t l_187 = 0U;
        l_188 = func_62(l_187, l_188);
        l_188.f0 |= ((int16_t)((uint16_t)((int16_t)((uint16_t)p_44 * (uint16_t)p_44) >> (int16_t)(__builtin_clz(l_187) || (((-10) & l_185) <= (((l_188.f2 = p_44) && p_45) & ((uint16_t)(~l_187) + (uint16_t)p_44))))) >> (uint16_t)p_45) << (int16_t)1);
        l_188.f2 = (l_188.f2 , ((((uint32_t)((uint16_t)((int16_t)((func_81(l_188.f1, func_62(l_188.f1, func_81((l_181 || (0U > p_44)), l_188, p_43, ((uint16_t)((uint16_t)__builtin_parity(l_187) >> (uint16_t)p_44) % (uint16_t)0xCF07))), p_43, l_181) , l_187) >= 1) * (int16_t)0xB233) * (uint16_t)p_45) + (uint32_t)p_43) == 0xEA57) || p_45));
        for (l_188.f4 = 12; (l_188.f4 <= 38); l_188.f4 += 2)
        { /* block id: 134 */
            int8_t l_214 = (-6);
            l_188.f2 &= p_45;
            for (p_44 = 10; (p_44 <= 28); p_44 += 1)
            { /* block id: 138 */
                if (l_187)
                    break;
                if (p_44)
                    break;
                l_214 = p_45;
            }
        }
    }
    return l_215;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_46(struct S0  p_47, int32_t  p_48, uint32_t  p_49, int32_t  p_50, int8_t  p_51)
{ /* block id: 41 */
    int16_t l_75 = 0x7C63;
    int32_t l_80 = 0x186EC4F4;
    int32_t l_153 = 0xEDD5446B;
    struct S0 l_154 = {3,5707,-3,65529U,0x8608};
    l_154 = func_62(((func_65((p_47.f4 = (l_153 = (((((int16_t)((int32_t)p_48 - (int32_t)func_71(((uint16_t)(__builtin_parityl((p_47 , (((l_80 = ((p_47.f3 = (__builtin_parity(((0U <= (l_75 <= p_51)) && (((int16_t)0x28B0 % (int16_t)((uint16_t)((p_47.f1 |= (0x20713981 || 0x8A068CF1)) < 0x13DB3B8C) + (uint16_t)p_47.f3)) , p_51))) , l_75)) & l_75)) <= p_49) && p_49))) , 65533U) + (uint16_t)(-8)))) << (int16_t)p_50) > l_75) <= 2U) | l_75)))) != l_75) , l_153), l_154);
    l_154.f0 = l_154.f4;
    return l_153;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_62(uint16_t  p_63, struct S0  p_64)
{ /* block id: 109 */
    uint32_t l_157 = 4294967295U;
    struct S0 l_172 = {-3,23054,2,0xC7E3,4U};
    int32_t l_177 = (-2);
    int32_t l_178 = 0xAD296291;
    l_178 &= (((((((int16_t)l_157 * (int16_t)l_157) & (((int16_t)(((0x763B1FBB >= l_157) && (func_65(((int16_t)p_64.f0 << (int16_t)(((uint16_t)(p_64.f4 = (((uint16_t)((uint16_t)((int32_t)(__builtin_ctzl((((uint32_t)0x50DFDFF9 + (uint32_t)(l_177 ^= ((l_172 = l_172) , ((int16_t)((uint32_t)(1U & (p_64.f3 = l_172.f3)) % (uint32_t)1) << (int16_t)13)))) < l_157)) | 4294967292U) % (int32_t)p_64.f0) * (uint16_t)l_157) * (uint16_t)0xDD9F) != p_64.f4)) % (uint16_t)l_157) && p_64.f2))) && p_64.f2)) | (-4)) * (int16_t)p_64.f2) | p_64.f2)) ^ l_157) <= l_157) , p_64.f3) , 5);
    return l_172;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_65(uint16_t  p_66)
{ /* block id: 107 */
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_71(uint16_t  p_72)
{ /* block id: 45 */
    int32_t l_86 = (-1);
    int32_t l_93 = (-10);
    int8_t l_105 = 1;
    int32_t l_106 = 0x441043A4;
    int16_t l_109 = (-1);
    struct S0 l_144 = {-6,11478,3,0U,65535U};
    l_144 = func_81(l_86, func_87((0x3419 > ((uint32_t)((l_106 = (((int32_t)(l_93 = l_86) - (int32_t)((uint32_t)((l_86 && ((uint16_t)(l_86 >= ((((uint16_t)p_72 * (uint16_t)((uint16_t)1U << (uint16_t)(-(int16_t)p_72))) , (((uint16_t)p_72 * (uint16_t)l_86) & l_86)) , l_105)) * (uint16_t)0xC9D3)) , l_105) % (uint32_t)1)) , p_72)) | l_105) + (uint32_t)p_72))), p_72, l_109);
    l_144.f2 = l_144.f3;
    if (((int16_t)p_72 << (int16_t)14))
    { /* block id: 97 */
        uint16_t l_151 = 0x4CA3;
        int32_t l_152 = 1;
        l_106 = ((((uint32_t)__builtin_ctzl((l_151 = ((int16_t)p_72 - (int16_t)l_144.f2))) - (uint32_t)l_152) || l_109) && p_72);
        l_144 = func_87(p_72);
    }
    else
    { /* block id: 101 */
        return p_72;
    }
    return l_109;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_81(int16_t  p_82, struct S0  p_83, int32_t  p_84, int32_t  p_85)
{ /* block id: 54 */
    int32_t l_114 = 0xA497058F;
    struct S0 l_115 = {-14,45017,4,0x5873,0x46C4};
    for (p_83.f3 = 0; (p_83.f3 > 55); p_83.f3 += 3)
    { /* block id: 57 */
        struct S0 l_119 = {-10,21132,7,0xD945,0x313D};
        uint32_t l_120 = 2U;
        uint32_t l_128 = 0xE8FA5C3D;
        int8_t l_129 = 0;
        for (p_84 = (-6); (p_84 < (-4)); p_84 += 7)
        { /* block id: 60 */
            struct S0 l_116 = {-1,8022,-3,0x571C,0x78AC};
            l_114 ^= p_82;
            if (p_84)
                continue;
            l_116 = l_115;
        }
        l_115.f2 = 0x4216A80D;
        for (p_82 = 0; (p_82 != 28); p_82 += 1)
        { /* block id: 68 */
            l_115 = (l_119 , func_87(l_115.f0));
        }
        if (l_120)
        { /* block id: 71 */
            if (l_119.f3)
                break;
            l_115.f0 = (l_120 < l_115.f0);
        }
        else
        { /* block id: 74 */
            struct S0 l_121 = {4,40207,-0,0U,65529U};
            l_115.f0 = ((p_83.f2 = ((p_83.f4 == ((l_121 , (l_115.f2 = (((int32_t)p_83.f2 + (int32_t)(__builtin_parity(((int16_t)((uint32_t)(((l_115.f0 == l_115.f4) || p_83.f0) , l_128) - (uint32_t)__builtin_popcount(l_121.f1)) << (int16_t)12)) , 4294967287U)) == 0xD21B))) <= p_83.f4)) && l_121.f4)) < 1U);
            if (l_121.f1)
            { /* block id: 78 */
                int8_t l_138 = 1;
                p_83.f2 = ((l_129 , l_129) , p_85);
                l_119 = l_115;
                l_119.f0 &= (p_83.f2 = ((uint16_t)(((int32_t)(((int16_t)((int16_t)l_138 - (int16_t)7U) << (int16_t)p_83.f0) > l_121.f2) % (int32_t)((int16_t)l_119.f2 << (int16_t)6)) , ((uint16_t)6U << (uint16_t)l_119.f3)) >> (uint16_t)10));
            }
            else
            { /* block id: 83 */
                int32_t l_143 = 0x379FE089;
                if (l_121.f1)
                    break;
                l_143 = (p_83.f0 = (l_115.f0 = (p_83.f2 = l_128)));
            }
            if (l_119.f0)
                continue;
            l_115.f2 = p_83.f1;
        }
    }
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_87(int32_t  p_88)
{ /* block id: 48 */
    struct S0 l_107 = {-13,28467,5,0x4107,0x49E8};
    struct S0 l_108 = {7,26737,7,9U,65535U};
    l_107 = l_107;
    l_108 = (l_107 = l_107);
    l_107.f2 = p_88;
    return l_107;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 96
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 21
XXX times a bitfields struct on RHS: 24
XXX times a single bitfield on LHS: 40
XXX times a single bitfield on RHS: 53

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 25
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 6
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 37, occurrence: 2
   depth: 38, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 481
XXX times a non-volatile is write: 156
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 114
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 22
   depth: 2, occurrence: 20
   depth: 3, occurrence: 19
   depth: 4, occurrence: 12
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 18.8
XXX percentage an existing variable is used: 81.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

