/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2773009743
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   unsigned f1 : 11;
   int16_t  f2;
   float  f3;
   int32_t  f4;
   int32_t  f5;
   int32_t  f6;
};

struct S1 {
   struct S0  f0;
   uint32_t  f1;
   uint32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_30(void);
static int32_t * func_37(int32_t * p_38, struct S0  p_39, int32_t * p_40);
inline static struct S0  func_41(int32_t * const  p_42, uint32_t  p_43, int32_t * p_44);
static int32_t * func_46(int16_t  p_47, uint32_t  p_48, struct S1  p_49, uint32_t  p_50, int32_t * p_51);
inline static struct S1  func_52(int32_t  p_53, int32_t * p_54);
inline static int32_t * func_55(int32_t * p_56, int32_t * p_57, int32_t * const  p_58);
static int32_t * func_59(struct S1  p_60, int32_t * p_61);
static struct S1  func_62(int16_t  p_63, int32_t * p_64, int32_t * p_65, struct S0  p_66, int32_t * p_67);
static int32_t * func_69(uint16_t  p_70, int32_t * p_71, int32_t  p_72);
static int32_t  func_73(struct S1  p_74, const int32_t * p_75, int32_t * p_76, struct S0  p_77, struct S1  p_78);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 0x9DF9481F;
    struct S1 l_552 = {{4294967289U,30,6,0x2.Dp+1,-1,0xE990B4D4,0x33C200DE},8U,0x4A71E5F9};
    const struct S1 *l_551 = &l_552;
    const struct S1 **l_550 = &l_551;
    uint32_t l_555 = 9U;
    struct S0 *l_558 = (void*)0;
    struct S1 l_588 = {{0x54C996F7,42,0x8FCF,0x0.3p-1,9,0xC1E57B87,0x29CBE507},0U,0U};
    uint16_t l_659 = 0xCF90;
    int32_t l_681 = 1;
    uint32_t l_685 = 1U;
    float **l_689 = (void*)0;
    int32_t *l_723 = &l_681;
    int32_t **l_722 = &l_723;
    int32_t l_760 = (-1);
    int16_t l_773 = (-10);
    int32_t l_774 = 0xF1183BDA;
    for (l_31 = 0; (l_31 == (-30)); --l_31)
    { /* block id: 39 */
        int32_t l_34 = 0x29855EEC;
        float *l_580 = &l_552.f0.f3;
        float **l_579 = &l_580;
        int32_t l_586 = 0xC65A2B81;
        struct S0 l_587 = {0x8BAC897F,1,0,0x6.7CD6EAp-53,0xD4A5A1BB,-10,0xA88A25F0};
        int32_t * const l_595 = (void*)0;
        int32_t l_597 = (-1);
        struct S0 l_602 = {0x95555435,10,3,0x0.E779B3p-71,-10,0xCA2EC803,1};
        struct S1 l_629 = {{0U,9,0xCA76,0x0.7p-1,-1,-1,0xC0C845C0},0x3EFE8C11,0xA19B79DD};
        int32_t *l_663 = &l_597;
        int32_t *l_693 = &l_31;
        int16_t l_705 = 0;
        int32_t **l_709 = &l_663;
        int32_t ***l_708 = &l_709;
        int32_t ****l_707 = &l_708;
    }
    (*l_722) = (*l_722);
    return l_774;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(int32_t * p_38, struct S0  p_39, int32_t * p_40)
{ /* block id: 444 */
    int32_t l_530 = 1;
    int32_t *l_529 = &l_530;
    int32_t **l_531 = &l_529;
    int32_t ***l_533 = &l_531;
    int32_t ****l_532 = &l_533;
    (*l_531) = l_529;
    l_532 = l_532;
    for (p_39.f2 = 23; (p_39.f2 != (-28)); p_39.f2 -= 1)
    { /* block id: 449 */
        float l_541 = 0xB.05CEEBp+67;
        float *l_540 = &l_541;
        float ** const l_539 = &l_540;
        float **l_543 = &l_540;
        float ***l_542 = &l_543;
        if ((*p_38))
            break;
        for (l_530 = (-15); (l_530 < 19); l_530 += 1)
        { /* block id: 453 */
            int32_t *l_538 = &l_530;
            (**l_533) = l_538;
        }
        (*l_542) = l_539;
        for (l_530 = 0; (l_530 != 3); l_530 += 3)
        { /* block id: 459 */
            return p_40;
            /* statement id: 460 */
            //assert (func_37_rv == &l_34 || func_37_rv == &l_560 || func_37_rv == 0 || func_37_rv == &l_31 || func_37_rv == &l_628.f0.f5);
        }
    }
    return p_40;
    /* statement id: 463 */
    //assert (func_37_rv == &l_34 || func_37_rv == &l_560 || func_37_rv == 0 || func_37_rv == &l_31 || func_37_rv == &l_628.f0.f5);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_41(int32_t * const  p_42, uint32_t  p_43, int32_t * p_44)
{ /* block id: 336 */
    int32_t l_387 = 0x69A8903F;
    int32_t *l_386 = &l_387;
    int32_t **l_388 = &l_386;
    struct S1 l_392 = {{0xFF3FBB3D,23,-1,0xF.2EDF9Cp+70,0xC27E4DEB,6,0x1542B8D8},4294967293U,0x0BB88B1F};
    struct S1 *l_391 = &l_392;
    uint32_t l_463 = 1U;
    struct S0 *l_508 = &l_392.f0;
    struct S0 l_527 = {0x41DE1C84,1,0xAC11,0xC.E49716p+23,0x156B48A9,0x43095699,-5};
    (*l_388) = p_44;
    /* statement id: 337 */
    //assert (l_386 == &l_31 || l_386 == &l_681);
    (*l_388) = func_46(((p_43 & 4294967295U) & p_43), ((uint16_t)(l_391 != (void*)0) << (uint16_t)p_43), func_52(p_43, func_46(__builtin_ffs((((*l_388) == (void*)0) == (*l_386))), (*l_386), (*l_391), p_43, p_44)), p_43, p_44);
    l_392.f0 = l_392.f0;
    for (l_392.f0.f4 = 0; (l_392.f0.f4 != 7); l_392.f0.f4++)
    { /* block id: 342 */
        int32_t l_402 = 0x2C240B1C;
        struct S0 l_410 = {0xD57B6DC8,21,9,0xC.5F8AC1p+18,-6,0x31A7FE26,0x3B97613D};
        struct S1 l_420 = {{3U,37,0,0x1.Ep+1,-9,0,0},1U,0x0D215954};
        int32_t ***l_430 = &l_388;
        int32_t ****l_429 = &l_430;
        struct S0 *l_436 = &l_420.f0;
        struct S0 ** const l_435 = &l_436;
        uint32_t l_449 = 0U;
        uint32_t l_452 = 0x92B0F0AC;
        uint16_t l_522 = 0xC66E;
        l_391 = &l_392;
    }
    return l_527;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(int16_t  p_47, uint32_t  p_48, struct S1  p_49, uint32_t  p_50, int32_t * p_51)
{ /* block id: 332 */
    int32_t l_383 = 4;
    int32_t *l_382 = &l_383;
    int32_t **l_381 = &l_382;
    int32_t ***l_380 = &l_381;
    int32_t **** const l_379 = &l_380;
    float l_385 = 0x7.121AF7p+14;
    float *l_384 = &l_385;
    (*l_384) = (l_379 == (void*)0);
    (*l_381) = p_51;
    /* statement id: 334 */
    //assert (l_382 == &l_31 || l_382 == &l_402 || l_382 == &l_392.f0.f5 || l_382 == &l_628.f0.f5 || l_382 == &l_34 || l_382 == &l_681);
    return p_51;
    /* statement id: 335 */
    //assert (func_46_rv == &l_31 || func_46_rv == &l_402 || func_46_rv == &l_392.f0.f5 || func_46_rv == &l_628.f0.f5 || func_46_rv == &l_34 || func_46_rv == &l_681);
}


/* ------------------------------------------ */
/* 
 * reads : l_31 l_681
 * writes:
 */
inline static struct S1  func_52(int32_t  p_53, int32_t * p_54)
{ /* block id: 43 */
    int32_t l_68 = (-1);
    struct S1 l_79 = {{0x797A3554,19,0,0xC.6CF92Ap+47,-1,2,-2},0xB4391DAA,0xE977603C};
    int32_t * const l_344 = (void*)0;
    int32_t *l_357 = &l_79.f0.f5;
    l_357 = func_55(func_59(func_62(l_68, p_54, func_69(l_68, &l_68, func_73(l_79, &l_68, &l_68, l_79.f0, l_79)), l_79.f0, &l_68), &l_68), p_54, l_344);
    /* statement id: 316 */
    assert (l_357 == 0 || l_357 == &l_68);
    for (l_79.f0.f0 = (-16); (l_79.f0.f0 < 44); l_79.f0.f0 += 6)
    { /* block id: 319 */
        uint16_t l_360 = 0x1620;
        struct S1 l_369 = {{4294967291U,25,0x8CAB,0x5.B8BB73p-64,0x87091586,0x1AA66F7E,0x018A8351},1U,0xC88B69E5};
        int32_t *l_375 = &l_79.f0.f5;
        l_360 = p_53;
        if (((int16_t)p_53 << (int16_t)((*p_54) & 0xFB677E2F)))
        { /* block id: 321 */
            struct S1 l_363 = {{0x6F0E8CA4,39,0x91FD,-0x1.Ep+1,0x4BCE167E,-1,0x2A74702C},4294967293U,0x89CA0291};
            struct S1 *l_364 = &l_363;
            int32_t **l_365 = &l_357;
            struct S0 *l_374 = &l_369.f0;
            struct S0 **l_373 = &l_374;
            struct S0 ***l_372 = &l_373;
            (*l_364) = l_363;
            (*l_365) = &l_68;
            /* statement id: 323 */
            assert (l_357 == &l_68);
            (*l_375) = (((+(p_53 && (((int32_t)(p_53 < (__builtin_parityl(p_53) <= (p_53 & (*l_357)))) + (int32_t)p_53) && 0x80C358FE))) == (**l_365)) | (*p_54));
        }
        else
        { /* block id: 325 */
            int32_t l_376 = 0xDF2F93B7;
            float *l_377 = &l_369.f0.f3;
            int32_t **l_378 = &l_357;
            (*l_377) = l_376;
            (*l_378) = &l_68;
            /* statement id: 327 */
            assert (l_357 == &l_68);
        }
        /* facts after branching */
        assert (l_357 == &l_68);
        return l_369;
    }
    return l_79;
}


/* ------------------------------------------ */
/* 
 * reads : l_34 l_31 l_586 l_681
 * writes:
 */
inline static int32_t * func_55(int32_t * p_56, int32_t * p_57, int32_t * const  p_58)
{ /* block id: 306 */
    struct S0 l_347 = {0xCBAD7814,33,0x7CF5,-0x4.Ap+1,-1,0xB1C4671F,1};
    struct S0 *l_346 = &l_347;
    struct S0 **l_345 = &l_346;
    struct S1 l_352 = {{4294967295U,3,-1,0xE.1ECBC2p+19,0x6D43038D,0x4331F7D0,2},5U,1U};
    int32_t *l_353 = (void*)0;
    if ((l_345 == (void*)0))
    { /* block id: 307 */
        struct S0 *l_348 = &l_347;
        int32_t *l_351 = (void*)0;
        struct S0 l_354 = {4U,5,-1,0x1.3p+1,0,-5,0x06A95220};
        struct S1 *l_355 = &l_352;
        (*l_345) = l_348;
        (*p_56) = __builtin_clz((func_73(func_62(((int16_t)l_347.f2 >> (int16_t)15), p_57, p_57, (**l_345), l_351), p_57, l_351, l_354, l_352) < 0x145C));
        (*l_355) = func_62(l_354.f5, l_353, p_56, (*l_348), p_57);
    }
    else
    { /* block id: 311 */
        int32_t *l_356 = (void*)0;
        return l_356;
        /* statement id: 312 */
        //assert (func_55_rv == 0);
    }
    (**l_345) = (*l_346);
    return p_56;
    /* statement id: 315 */
    //assert (func_55_rv == &l_68 || func_55_rv == &l_387 || func_55_rv == &l_598.f5 || func_55_rv == &l_586 || func_55_rv == &l_628.f0.f5 || func_55_rv == &l_681);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_59(struct S1  p_60, int32_t * p_61)
{ /* block id: 249 */
    int32_t l_288 = 9;
    int32_t *l_287 = &l_288;
    int32_t **l_286 = &l_287;
    int32_t ***l_285 = &l_286;
    int32_t ****l_289 = &l_285;
    const struct S1 l_339 = {{0U,40,-1,0x0.D20614p-25,0x5F602925,0xBF1A1C19,7},0xC78A53E4,0xF68A5E5B};
    const struct S1 *l_338 = &l_339;
    struct S1 l_342 = {{0xED1CEA14,23,4,0xA.3E6B98p-84,0,0,0xBC5D1855},0xCB4CD074,0U};
    struct S1 *l_341 = &l_342;
    struct S1 **l_340 = &l_341;
    int32_t *l_343 = &l_342.f0.f5;
    (*l_289) = l_285;
    for (p_60.f0.f2 = 0; (p_60.f0.f2 == 13); ++p_60.f0.f2)
    { /* block id: 253 */
        (***l_289) = func_69(p_60.f0.f2, p_61, (*p_61));
        /* statement id: 254 */
        assert (l_287 == 0);
    }
    /* facts after for loop */
    assert (l_287 == 0 || l_287 == &l_288);
    for (p_60.f0.f0 = (-26); (p_60.f0.f0 == 42); p_60.f0.f0++)
    { /* block id: 258 */
        uint16_t l_294 = 0U;
        int32_t *l_297 = &l_288;
        struct S0 *l_334 = (void*)0;
        if ((l_294 || (((((((uint16_t)(p_60.f0.f2 || 65535U) >> (uint16_t)14) | 65526U) != (1U ^ 1U)) ^ (*p_61)) | p_60.f0.f5) > (*p_61))))
        { /* block id: 259 */
            int32_t *l_299 = &l_288;
            struct S0 **l_307 = (void*)0;
            struct S0 ***l_306 = &l_307;
            if (l_294)
            { /* block id: 260 */
                int32_t *l_298 = &l_288;
                (***l_289) = l_297;
                /* statement id: 261 */
                assert (l_287 == &l_288);
                return p_61;
                /* statement id: 262 */
                //assert (func_59_rv == &l_68 || func_59_rv == &l_587.f5 || func_59_rv == &l_681);
            }
            else
            { /* block id: 263 */
                const int32_t *l_310 = &l_288;
                uint32_t l_317 = 0x97772F32;
                for (p_60.f0.f6 = 0; (p_60.f0.f6 == 4); ++p_60.f0.f6)
                { /* block id: 266 */
                    struct S0 l_303 = {3U,7,0,0x0.Ap-1,0x82F17672,-1,0x4E5A0B54};
                    struct S0 *l_302 = &l_303;
                    struct S0 **l_305 = &l_302;
                    struct S0 ***l_304 = &l_305;
                    (**l_285) = func_69(p_60.f2, func_69((*l_299), func_69(p_60.f0.f2, (**l_285), (*l_299)), (*p_61)), __builtin_bswap64(p_60.f0.f4));
                    /* statement id: 267 */
                    assert (l_287 == 0);
                    (*l_302) = p_60.f0;
                    l_306 = l_304;
                    /* statement id: 269 */
                    assert (l_306 == &l_305);
                }
                /* facts after for loop */
                //assert (l_306 == dangling || l_306 == &l_307);
                (***l_289) = func_69(p_60.f0.f5, func_69(p_60.f2, func_69(((uint16_t)func_73(p_60, l_310, func_69((((*l_310) > (p_60.f0.f5 > (p_61 != (void*)0))) <= (((int16_t)((uint32_t)p_60.f1 - (uint32_t)(*p_61)) - (int16_t)(*l_297)) | (*l_297))), l_299, (*p_61)), p_60.f0, p_60) % (uint16_t)0x0270), (*l_286), (*l_299)), (*p_61)), (*l_310));
                /* statement id: 271 */
                assert (l_287 == 0);
                for (p_60.f2 = 0; (p_60.f2 <= 3); p_60.f2 += 5)
                { /* block id: 274 */
                    struct S1 l_320 = {{0xF70BE9A3,36,0x292C,0x0.Bp-1,-1,6,-6},0xE8078A07,0x11D19BCE};
                    struct S1 *l_319 = &l_320;
                    struct S1 **l_318 = &l_319;
                    (***l_289) = func_69(l_317, p_61, (*l_310));
                    (*l_318) = &p_60;
                    /* statement id: 276 */
                    assert (l_319 == &p_60);
                }
                for (p_60.f1 = (-24); (p_60.f1 != 53); p_60.f1++)
                { /* block id: 280 */
                    if ((l_297 != p_61))
                    { /* block id: 281 */
                        struct S1 l_323 = {{4294967288U,32,1,0xE.078CE7p-46,0x0B652159,0,0xF2FC5D0F},0x5C3F43AB,7U};
                        struct S1 *l_324 = &l_323;
                        struct S0 *l_325 = &l_323.f0;
                        (*l_324) = l_323;
                        (*l_325) = p_60.f0;
                    }
                    else
                    { /* block id: 284 */
                        struct S0 l_327 = {0x226B48D1,26,6,0x8.6p+1,0xA7824352,0xB4A1F68E,1};
                        struct S0 *l_326 = &l_327;
                        (*l_326) = p_60.f0;
                    }
                    if ((*p_61))
                        break;
                    if (((uint16_t)p_60.f1 - (uint16_t)(-6)))
                    { /* block id: 288 */
                        float l_331 = 0x0.1p-1;
                        float *l_330 = &l_331;
                        if ((*p_61))
                            break;
                        (*l_330) = (p_60.f0.f2 == (&p_60 != &p_60));
                    }
                    else
                    { /* block id: 291 */
                        struct S0 l_333 = {0xB260C81B,28,0xF219,0x1.3p+1,0xE0DAAF10,0xA50AA0B6,0xB365FFFE};
                        struct S0 *l_332 = &l_333;
                        (*l_332) = p_60.f0;
                        return p_61;
                        /* statement id: 293 */
                        //assert (func_59_rv == &l_68 || func_59_rv == &l_587.f5 || func_59_rv == &l_681);
                    }
                }
            }
            /* facts after branching */
            assert (l_287 == 0);
            //assert (l_306 == dangling || l_306 == &l_307);
        }
        else
        { /* block id: 297 */
            struct S0 **l_335 = &l_334;
            (*l_335) = l_334;
            (*p_61) = ((int16_t)(*l_297) % (int16_t)3);
            (*l_286) = (***l_289);
            l_334 = l_334;
        }
    }
    (*l_340) = l_338;
    /* statement id: 304 */
    assert (l_341 == &l_339);
    return p_61;
    /* statement id: 305 */
    //assert (func_59_rv == &l_68 || func_59_rv == &l_587.f5 || func_59_rv == &l_681);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_62(int16_t  p_63, int32_t * p_64, int32_t * p_65, struct S0  p_66, int32_t * p_67)
{ /* block id: 245 */
    struct S0 l_280 = {4294967291U,9,0,0x8.26A344p+24,0x4827AF0C,-1,0x8FD3FD81};
    struct S0 *l_281 = (void*)0;
    struct S0 l_282 = {4U,42,0xCD77,-0x9.Fp+1,0,0x87A5E890,0x50B1FDF6};
    float *l_283 = &l_282.f3;
    struct S1 l_284 = {{0xE7372DDE,0,-1,0x0.2p-1,-1,0xD35EB0D3,0},4294967294U,0x35714B23};
    l_282 = l_280;
    (*l_283) = l_282.f2;
    return l_284;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(uint16_t  p_70, int32_t * p_71, int32_t  p_72)
{ /* block id: 242 */
    struct S1 l_276 = {{4294967295U,32,0xFC52,0xC.27F5A8p-29,0xE68B0B81,1,1},0x745B5AC6,4294967291U};
    int32_t *l_277 = &l_276.f0.f5;
    float *l_278 = &l_276.f0.f3;
    int32_t *l_279 = (void*)0;
    (*l_278) = ((float)func_73(l_276, &p_72, l_277, l_276.f0, l_276) - (float)((*l_277) == p_72));
    return l_279;
    /* statement id: 244 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_34 l_31 l_597 l_598.f5 l_586 l_681
 * writes:
 */
static int32_t  func_73(struct S1  p_74, const int32_t * p_75, int32_t * p_76, struct S0  p_77, struct S1  p_78)
{ /* block id: 44 */
    int32_t l_83 = (-6);
    int32_t *l_84 = (void*)0;
    struct S1 l_91 = {{0x69D9FC0A,5,-5,0x9.1F7F3Ep+17,0x84259BBF,0xB79F9BF1,0x3AA3328D},6U,4294967286U};
    struct S1 *l_90 = &l_91;
    struct S1 *l_142 = &l_91;
    const struct S0 *l_159 = &l_91.f0;
    const struct S0 **l_158 = &l_159;
    uint32_t l_198 = 0xB08C67EB;
    float *l_270 = &l_91.f0.f3;
    return (*p_75);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 198
   depth: 1, occurrence: 16
   depth: 2, occurrence: 31
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 80
breakdown:
   indirect level: 0, occurrence: 47
   indirect level: 1, occurrence: 20
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 62
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 120
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 9

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 14, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 263

XXX times a variable address is taken: 282
XXX times a pointer is dereferenced on RHS: 184
breakdown:
   depth: 1, occurrence: 147
   depth: 2, occurrence: 26
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 158
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 15
   depth: 3, occurrence: 11
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 522

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1135
   level: 2, occurrence: 161
   level: 3, occurrence: 69
   level: 4, occurrence: 15
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 102
XXX number of pointers point to scalars: 107
XXX number of pointers point to structs: 54
XXX percent of pointers has null in alias set: 21.7
XXX average alias set size: 1.54

XXX times a non-volatile is read: 1071
XXX times a non-volatile is write: 455
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 79
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 14
   depth: 2, occurrence: 12
   depth: 3, occurrence: 6
   depth: 4, occurrence: 8
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 23.8
XXX percentage an existing variable is used: 76.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

