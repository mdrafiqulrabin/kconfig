/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3512700459
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_30(void);
static int16_t  func_40(uint32_t  p_41, uint32_t  p_42);
static uint16_t  func_44(uint32_t  p_45, uint16_t  p_46);
inline static int32_t * func_48(int32_t  p_49, int32_t  p_50);
static int32_t  func_51(uint32_t  p_52, uint32_t  p_53, uint32_t  p_54, uint32_t  p_55, int32_t * p_56);
static int32_t * func_59(int32_t * p_60);
inline static int32_t  func_64(int32_t * p_65, int32_t * p_66);
inline static int32_t * func_67(int32_t * p_68);
static int32_t * func_69(int32_t  p_70);
inline static int32_t  func_71(float  p_72);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 4L;
    float l_200 = 0x1.8p+1;
    float *l_199 = &l_200;
    float **l_198 = &l_199;
    float ***l_197 = &l_198;
    int16_t l_202 = (-4L);
    int32_t **l_203 = (void*)0;
    float l_209 = 0x1.6p+1;
    for (l_31 = 0; (l_31 == (-25)); l_31 -= 2)
    { /* block id: 39 */
        uint16_t l_47 = 0xCD95L;
        float l_181 = 0x9.AEBFCCp-99;
        float l_191 = (-0x8.6p+1);
        int32_t *l_192 = &l_31;
        uint32_t l_194 = 0xDC83D636L;
        int32_t l_196 = (-9L);
        int32_t *l_195 = &l_196;
        float ***l_201 = &l_198;
        int32_t l_204 = (-1L);
        if (((uint32_t)(((uint32_t)0UL - (uint32_t)((int16_t)(0x753FL & l_31) + (int16_t)func_40(((((!func_44(l_31, l_47)) < l_47) != 3L) <= (l_47 || l_47)), l_47))) != l_47) % (uint32_t)l_31))
        { /* block id: 119 */
            for (l_47 = 0; (l_47 < 48); l_47 += 2)
            { /* block id: 122 */
                return l_31;
            }
        }
        else
        { /* block id: 125 */
            l_191 = l_47;
            if (l_47)
                break;
        }
        (*l_195) = (l_31 ^ ((((l_47 && l_31) && (3UL == 65535UL)) | l_194) == (*l_192)));
        (*l_195) = func_51(__builtin_clzl(((((l_197 == l_201) | l_202) > l_202) == ((l_203 != (void*)0) <= (*l_192)))), (__builtin_ia32_crc32qi(((((0L == (*l_195)) <= (*l_195)) <= (*l_195)) <= (*l_195)), l_204) && 0xBFD7L), l_31, l_31, &l_31);
        (*l_195) = (*l_192);
    }
    (*l_199) = (((float)l_31 + (float)(((float)(l_209 == (l_202 <= l_202)) - (float)l_31) >= (((&l_31 == &l_31) < func_71((func_64(func_69(l_202), &l_31) == l_202))) >= 0x0.7159EDp+21))) != 0x4.9B22F9p-11);
    return l_202;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_40(uint32_t  p_41, uint32_t  p_42)
{ /* block id: 115 */
    float l_184 = 0x5.D8A099p+5;
    float *l_183 = &l_184;
    float **l_182 = &l_183;
    float ***l_185 = &l_182;
    int32_t l_188 = (-8L);
    int32_t *l_187 = &l_188;
    int32_t **l_186 = &l_187;
    (*l_185) = l_182;
    (*l_186) = l_183;
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_44(uint32_t  p_45, uint16_t  p_46)
{ /* block id: 40 */
    int32_t l_58 = (-3L);
    int32_t *l_57 = &l_58;
    int32_t **l_173 = (void*)0;
    int32_t **l_174 = (void*)0;
    int32_t **l_175 = &l_57;
    float l_177 = 0xE.7B83AFp-90;
    float *l_176 = &l_177;
    float **l_179 = &l_176;
    float ***l_178 = &l_179;
    int32_t l_180 = 0x36AFDF52L;
    (*l_175) = func_48(func_51(p_46, ((void*)0 == l_57), p_45, (*l_57), func_59(&l_58)), (((((0x5C82L && 0x62ECL) && p_45) != p_45) < (*l_57)) || 4294967293UL));
    (*l_175) = (*l_175);
    (*l_176) = 0xB.4825C2p+25;
    l_178 = l_178;
    return l_180;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_48(int32_t  p_49, int32_t  p_50)
{ /* block id: 107 */
    int32_t l_165 = 0x74BA5FEAL;
    int32_t *l_164 = &l_165;
    int32_t **l_166 = &l_164;
    int32_t *l_167 = &l_165;
    int32_t *l_168 = &l_165;
    int32_t *l_169 = &l_165;
    int32_t *l_170 = &l_165;
    int32_t *l_171 = &l_165;
    int32_t *l_172 = (void*)0;
    (*l_166) = l_164;
    return l_172;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_51(uint32_t  p_52, uint32_t  p_53, uint32_t  p_54, uint32_t  p_55, int32_t * p_56)
{ /* block id: 104 */
    int32_t **l_158 = (void*)0;
    int32_t **l_159 = (void*)0;
    int32_t **l_160 = (void*)0;
    int32_t l_163 = 0x10B79F68L;
    int32_t *l_162 = &l_163;
    int32_t **l_161 = &l_162;
    (*l_161) = p_56;
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_59(int32_t * p_60)
{ /* block id: 41 */
    int32_t l_61 = 1L;
    float l_147 = 0x0.4p-1;
    float *l_146 = &l_147;
    int32_t *l_149 = (void*)0;
    uint32_t l_156 = 0x2574F060L;
    int32_t *l_157 = &l_61;
    for (l_61 = 24; (l_61 != (-5)); l_61 -= 1)
    { /* block id: 44 */
        if (func_64(func_67(func_69(l_61)), p_60))
        { /* block id: 93 */
            int32_t *l_143 = (void*)0;
            int32_t l_145 = (-1L);
            int32_t *l_144 = &l_145;
            int32_t **l_148 = &l_143;
            (*l_144) = 0x3224D420L;
            (*l_148) = func_69((l_146 != p_60));
            return l_149;
        }
        else
        { /* block id: 97 */
            return p_60;
        }
    }
    (*l_146) = l_61;
    (*l_157) = __builtin_ctz(((int16_t)((~(~(l_61 && 1L))) <= ((((int32_t)l_156 % (int32_t)0xAE64750AL) && 0UL) <= l_156)) >> (int16_t)8));
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads : l_58 l_196
 * writes:
 */
inline static int32_t  func_64(int32_t * p_65, int32_t * p_66)
{ /* block id: 82 */
    uint16_t l_130 = 0UL;
    int32_t **l_133 = (void*)0;
    float **l_134 = (void*)0;
    float l_136 = (-0x1.Cp-1);
    float *l_135 = &l_136;
    int32_t l_137 = 0xD79668BEL;
    float l_139 = (-0x1.1p+1);
    int32_t *l_141 = &l_137;
    (*l_135) = ((float)l_130 + (float)(((((float)l_130 - (float)l_130) >= (((void*)0 != l_133) > (l_134 != l_134))) != 0x7.Fp+1) < ((func_71(l_130) <= l_130) <= l_130)));
    (*l_135) = ((l_130 <= 0xC.18547Ep+80) <= (&l_134 != (void*)0));
    l_137 = 0L;
    if ((-(int16_t)func_71(__builtin_bswap64((l_130 & __builtin_ffs((*p_66)))))))
    { /* block id: 86 */
        int32_t l_140 = 0L;
        l_140 = func_71(l_139);
    }
    else
    { /* block id: 88 */
        int32_t *l_142 = (void*)0;
        p_65 = l_141;
        l_142 = l_142;
    }
    return (*p_66);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_67(int32_t * p_68)
{ /* block id: 79 */
    int16_t l_125 = 0x8C50L;
    float l_127 = 0xA.DC513Bp+88;
    float *l_126 = &l_127;
    (*l_126) = func_71(l_125);
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int32_t  p_70)
{ /* block id: 45 */
    uint32_t l_105 = 1UL;
    float l_114 = 0x1.9p+1;
    int32_t l_115 = 0x49BCD996L;
    float **l_117 = (void*)0;
    int32_t *l_119 = &l_115;
    int32_t *l_120 = &l_115;
    int32_t *l_121 = &l_115;
    int32_t *l_122 = &l_115;
    int32_t *l_123 = &l_115;
    int32_t *l_124 = (void*)0;
    l_105 = func_71(p_70);
    if ((((((p_70 != ((((int16_t)(((uint16_t)0x1CA5L + (uint16_t)0x8241L) || p_70) - (int16_t)(l_105 ^ (((uint16_t)0x9072L >> (uint16_t)func_71((p_70 > ((float)((0x3.EFD82Bp+76 < 0x0.1p+1) != 0x8.5C681Ep+69) - (float)(-0x3.Dp-1))))) | p_70))) ^ (-1L)) | p_70)) != l_115) && p_70) || 0x95734345L) > 0x6BD2L))
    { /* block id: 72 */
        int32_t l_116 = 0x736DE7CAL;
        l_115 = (l_116 == 0x8.1p-1);
    }
    else
    { /* block id: 74 */
        float ***l_118 = &l_117;
        (*l_118) = l_117;
    }
    l_119 = &l_115;
    return l_124;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_71(float  p_72)
{ /* block id: 46 */
    int32_t l_79 = 0x71837DEFL;
    float l_80 = 0x0.3p-1;
    float *l_81 = &l_80;
    float l_91 = 0x1.C44807p+66;
    (*l_81) = ((p_72 == ((-0x6.5p-1) == p_72)) == (((float)p_72 - (float)(((p_72 <= (((p_72 == (p_72 > (p_72 == ((float)((float)((p_72 < l_79) < (-0x8.Ep+1)) + (float)(-0x4.Ap+1)) - (float)l_80)))) != p_72) != 0x3.926A09p-10)) != l_79) != 0x7.AB59A6p+48)) != 0x9.C71DA8p-45));
    if (l_79)
    { /* block id: 48 */
        int32_t l_83 = (-2L);
        int32_t *l_82 = &l_83;
        float **l_97 = &l_81;
        int32_t **l_101 = &l_82;
        (*l_82) = l_79;
        for (l_83 = (-3); (l_83 == (-18)); l_83 -= 1)
        { /* block id: 52 */
            int16_t l_86 = 0xD282L;
            int32_t l_94 = 1L;
            int32_t *l_93 = &l_94;
            int32_t **l_99 = (void*)0;
            int32_t **l_100 = &l_93;
            if ((((l_86 || __builtin_ctzll((l_86 > (((int16_t)__builtin_ffs((((uint16_t)l_86 >> (uint16_t)(*l_82)) || l_79)) - (int16_t)(((*l_82) >= (((l_79 && 1UL) & (*l_82)) > (*l_82))) > 0x67C8CEAAL)) <= l_86)))) ^ (*l_82)) > 0x09DE24E5L))
            { /* block id: 53 */
                int32_t *l_92 = &l_83;
                float **l_96 = &l_81;
                float ***l_95 = &l_96;
                l_93 = l_92;
                (*l_95) = (void*)0;
                (*l_95) = l_97;
            }
            else
            { /* block id: 57 */
                int32_t **l_98 = &l_93;
                (**l_97) = p_72;
                (*l_98) = &l_94;
                (**l_98) = (*l_93);
                if ((*l_93))
                    break;
            }
            (*l_100) = &l_83;
        }
        (*l_101) = &l_83;
    }
    else
    { /* block id: 66 */
        int32_t l_103 = 2L;
        int32_t *l_102 = &l_103;
        int32_t **l_104 = &l_102;
        (*l_104) = l_102;
        (*l_104) = l_81;
    }
    return l_79;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 63
XXX total union variables: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 74

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 20
breakdown:
   depth: 1, occurrence: 20
XXX times a pointer is dereferenced on LHS: 30
breakdown:
   depth: 1, occurrence: 28
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 227

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 71
   level: 2, occurrence: 2
XXX number of pointers point to pointers: 30
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.8
XXX average alias set size: 1.19

XXX times a non-volatile is read: 197
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 65
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 15
   depth: 2, occurrence: 9
   depth: 3, occurrence: 8

XXX percentage a fresh-made variable is used: 15
XXX percentage an existing variable is used: 85
********************* end of statistics **********************/

