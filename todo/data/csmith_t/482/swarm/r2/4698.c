/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2586951472
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_30(void);
static int32_t * func_31(int32_t * p_32, uint32_t  p_33, uint32_t  p_34, int32_t  p_35, int32_t  p_36);
static int32_t  func_43(uint32_t  p_44, float  p_45, int32_t * p_46);
static float  func_49(const uint16_t  p_50);
static int32_t  func_53(int32_t * p_54, uint16_t  p_55, uint32_t  p_56, uint32_t  p_57, int32_t  p_58);
static int32_t  func_59(int32_t * p_60, int32_t * p_61, int32_t  p_62, int32_t * p_63, uint32_t  p_64);
static int32_t * func_65(uint16_t  p_66, int16_t  p_67);
static int32_t * func_77(float  p_78, int32_t * p_79, int16_t  p_80, int32_t * p_81, int32_t  p_82);
static int32_t * func_84(uint32_t  p_85, uint32_t  p_86, uint16_t  p_87);
static int32_t  func_106(float  p_107, int32_t * p_108);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_38 = 8;
    int32_t *l_37 = &l_38;
    int32_t **l_699 = &l_37;
    float l_709 = 0x3.Bp+1;
    const float *l_708 = &l_709;
    const float **l_707 = &l_708;
    const float ***l_706 = &l_707;
    const float ****l_705 = &l_706;
    uint32_t l_710 = 4294967295U;
    int32_t *l_711 = &l_38;
    uint16_t l_718 = 65535U;
    uint32_t l_719 = 4294967295U;
    int32_t **l_723 = &l_37;
    int32_t l_823 = 2;
    float *l_840 = (void*)0;
    float **l_839 = &l_840;
    float ***l_838 = &l_839;
    int16_t l_854 = 0x8304;
    int32_t ****l_867 = (void*)0;
    int32_t *****l_866 = &l_867;
    int16_t l_886 = 0x1709;
    int16_t l_891 = 0xF1F9;
    int32_t l_896 = 1;
    l_37 = func_31(l_37, (*l_37), (safe_mod_func_int32_t_s_s((__builtin_popcountll((*l_37)) ^ (*l_37)), (+(*l_37)))), (*l_37), (*l_37));
    /* statement id: 330 */
    assert (l_37 == 0);
    (*l_711) = ((1U >= (((__builtin_popcountll(l_38) < ((safe_mod_func_uint16_t_u_u((((((void*)0 == l_699) || __builtin_popcountll((!((l_37 != ((safe_lshift_func_int16_t_s_s(l_38, 8)) , l_37)) <= (safe_sub_func_int32_t_s_s((l_705 == &l_706), 0)))))) == 0) > l_38), l_710)) != l_38)) >= l_710) || 3U)) <= l_38);
    (*l_711) = (((((((*l_711) > (*l_711)) && ((*l_711) & ((*l_711) > (*l_711)))) != (((-3) && ((((!0xB1E1) && (+(((safe_sub_func_uint32_t_u_u(((((*l_711) , (((safe_lshift_func_uint16_t_u_u((*l_711), (*l_711))) > (-8)) ^ (*l_711))) ^ (*l_711)) & (*l_711)), (*l_711))) || (*l_711)) | (*l_711)))) == (*l_711)) > l_718)) > l_719)) >= 0) , 0x0.Bp+1) >= (-0x10.0p+1));
    for (l_710 = 25; (l_710 != 20); --l_710)
    { /* block id: 335 */
        int32_t l_722 = 0;
        float l_724 = (-0x1.Bp+1);
        uint16_t l_754 = 0x7316;
        int32_t l_793 = 0x780B3F4A;
        int32_t *l_792 = &l_793;
        const int32_t ***l_851 = (void*)0;
        int32_t *l_883 = &l_793;
        int32_t l_894 = 0xC3D2C620;
        const float **l_895 = &l_708;
    }
    return l_896;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_31(int32_t * p_32, uint32_t  p_33, uint32_t  p_34, int32_t  p_35, int32_t  p_36)
{ /* block id: 37 */
    int16_t l_42 = (-4);
    int32_t l_601 = 1;
    int32_t *l_600 = &l_601;
    float **l_605 = (void*)0;
    int32_t **l_612 = &l_600;
    int32_t ***l_611 = &l_612;
    int32_t ****l_610 = &l_611;
    int32_t *l_673 = &l_601;
    int32_t *l_674 = (void*)0;
    uint16_t l_675 = 0x5484;
    int32_t l_676 = 0xBC958F3F;
    int32_t *l_693 = &l_601;
    int32_t *l_694 = &l_676;
    int32_t *l_695 = &l_601;
    int32_t *l_696 = (void*)0;
    if (l_42)
    { /* block id: 38 */
        int32_t l_47 = 2;
        int32_t l_48 = 0x79D44F4C;
        if ((func_43(l_42, ((p_33 , (l_47 || p_35)) , (p_36 > ((l_48 == (func_49(((l_42 & (*p_32)) | 0x82F4E55B)) != p_34)) != l_47))), &l_48) && p_33))
        { /* block id: 268 */
            int32_t l_590 = 0x52D4B2F8;
            float l_595 = 0x1.Dp-1;
            float *l_594 = &l_595;
            float **l_593 = &l_594;
            uint32_t l_599 = 0xB3E97F03;
            const int32_t *l_603 = (void*)0;
            const int32_t **l_602 = &l_603;
            p_32 = func_77(((((safe_sub_func_float_f_f(l_590, ((safe_div_func_float_f_f((((void*)0 != l_593) > l_590), l_590)) <= (safe_div_func_float_f_f((-((((p_33 , p_34) , p_33) , p_36) == l_599)), 0xE.F003FEp-8))))) <= l_42) >= l_47) < 0xC.1E0DF8p+48), l_600, (*l_600), &l_590, (*p_32));
            /* statement id: 269 */
            assert (p_32 == 0);
            (*l_602) = &p_36;
            /* statement id: 270 */
            assert (l_603 == &p_36);
        }
        else
        { /* block id: 271 */
            int32_t **l_604 = &l_600;
            (*l_604) = &l_601;
            (*l_604) = (void*)0;
            /* statement id: 273 */
            assert (l_600 == 0);
        }
        /* facts after branching */
        //assert (p_32 == &l_38 || p_32 == 0);
        assert (l_600 == 0 || l_600 == &l_601);
    }
    else
    { /* block id: 275 */
        int32_t **l_609 = &l_600;
        int32_t ****l_613 = (void*)0;
        int32_t *l_672 = &l_601;
        p_32 = (void*)0;
        /* statement id: 276 */
        assert (p_32 == 0);
        if ((p_34 , (*l_600)))
        { /* block id: 277 */
            float ***l_606 = &l_605;
            int32_t *l_618 = &l_601;
            uint16_t l_636 = 0x728D;
            (*l_606) = l_605;
            if ((*l_600))
            { /* block id: 279 */
                int32_t *l_607 = &l_601;
                int32_t **l_608 = &l_600;
                float l_615 = 0xF.15935Fp+28;
                float *l_614 = &l_615;
                uint32_t l_637 = 0U;
                float l_641 = 0x4.8p+1;
                (*l_608) = l_607;
                (*l_614) = (((&p_32 != l_609) , l_610) != l_613);
                if ((**l_609))
                { /* block id: 282 */
                    int16_t l_619 = (-10);
                    (*l_614) = p_36;
                    (**l_609) = (p_34 > ((*l_607) , (((((*l_607) ^ (((((p_34 | p_36) , (safe_div_func_uint16_t_u_u(((p_35 != 0x6EB4506C) , 1U), 0xF6B2))) == p_33) , p_32) == p_32)) || 1U) | p_34) , (*l_600))));
                }
                else
                { /* block id: 285 */
                    int16_t l_627 = (-10);
                    for (p_34 = 12; (p_34 != 6); p_34 = safe_sub_func_uint16_t_u_u(p_34, 6))
                    { /* block id: 288 */
                        float ***l_622 = &l_605;
                        const float ***l_624 = (void*)0;
                        const float ****l_623 = &l_624;
                        (*l_623) = l_622;
                        /* statement id: 289 */
                        assert (l_624 == &l_605);
                    }
                    (*l_608) = &p_36;
                    /* statement id: 291 */
                    assert (l_600 == &p_36);
                    (*l_612) = func_65(((((safe_rshift_func_int16_t_s_s((0U || (*l_618)), ((l_627 , (**l_612)) < 0x6BAE))) < (safe_add_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_s((~0x309A), 0)) || (((p_36 > func_106(((__builtin_parity((+((((-1) >= (((0x292DE6B7 == l_627) , p_35) , p_35)) || l_636) & 0U))) || (**l_608)) , p_35), (***l_610))) , 0xE869EB95) > p_35)), p_33))) || (-3)) , l_637), (***l_611));
                    /* statement id: 292 */
                    assert (l_600 == 0);
                }
                /* facts after branching */
                assert (l_600 == 0 || l_600 == &l_601);
                (*l_609) = func_65((0xCCCD > func_43((p_34 | (+(safe_rshift_func_int16_t_s_u(((-7) != __builtin_parity((*l_607))), 1)))), l_641, &p_36)), (safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(p_33, 6)), (*l_607))));
                /* statement id: 294 */
                assert (l_600 == 0);
            }
            else
            { /* block id: 295 */
                int16_t l_652 = 0x1125;
                for (p_33 = 0; (p_33 == 11); p_33 = safe_add_func_int32_t_s_s(p_33, 4))
                { /* block id: 298 */
                    const int32_t *l_655 = (void*)0;
                    const int32_t **l_654 = &l_655;
                    const int32_t ***l_653 = &l_654;
                    for (l_42 = 11; (l_42 >= (-9)); l_42 = safe_sub_func_int16_t_s_s(l_42, 3))
                    { /* block id: 301 */
                        uint32_t l_662 = 0x16900822;
                    }
                }
                (*l_612) = (void*)0;
                /* statement id: 305 */
                assert (l_600 == 0);
                (***l_610) = &p_36;
                /* statement id: 306 */
                assert (l_600 == &p_36);
                (***l_610) = func_65(p_36, ((safe_sub_func_int16_t_s_s(p_33, 0U)) , ((0U != p_35) != ((((p_35 & l_652) , (***l_611)) & ((safe_lshift_func_uint16_t_u_u(((*l_618) && 0x445D), p_33)) != (-1))) < (****l_610)))));
                /* statement id: 307 */
                assert (l_600 == 0);
            }
            /* facts after branching */
            assert (l_600 == 0);
            (*l_618) = ((*l_618) == ((safe_sub_func_float_f_f((*l_618), p_33)) < ((*l_618) >= p_34)));
        }
        else
        { /* block id: 310 */
            int32_t *l_671 = &l_601;
            return l_674;
            /* statement id: 311 */
            //assert (func_31_rv == 0);
        }
        /* facts after branching */
        assert (l_600 == 0);
    }
    /* facts after branching */
    //assert (p_32 == &l_38 || p_32 == 0);
    assert (l_600 == 0 || l_600 == &l_601);
    (*l_612) = (*l_612);
    if ((((((__builtin_ffsll(l_675) , (*l_673)) < 0) != p_33) >= 0x6719) > (*l_673)))
    { /* block id: 315 */
        float ***l_677 = &l_605;
        const int32_t l_678 = 0xC4610211;
        float l_680 = 0x7.1CA5D6p-46;
        float *l_679 = &l_680;
        int32_t l_684 = 0xA1CA8C20;
        (*l_679) = (p_35 , (((void*)0 != l_677) == l_678));
        l_684 = (safe_sub_func_int32_t_s_s(l_678, (+l_678)));
    }
    else
    { /* block id: 318 */
        float ****l_685 = (void*)0;
        const float ****l_687 = (void*)0;
        const float *****l_686 = &l_687;
        (*l_686) = l_685;
    }
    for (p_33 = 0; (p_33 >= 36); p_33++)
    { /* block id: 323 */
        float l_690 = 0x7.Fp-1;
        int32_t *l_691 = &l_601;
        int32_t *l_692 = &l_676;
        if (p_35)
            break;
        (*l_612) = l_691;
        /* statement id: 325 */
        assert (l_600 == &l_601);
        (**l_612) = 0x8B07EF5F;
        p_32 = l_692;
        /* statement id: 327 */
        assert (p_32 == &l_676);
    }
    /* facts after for loop */
    //assert (p_32 == &l_676 || p_32 == &l_38 || p_32 == 0);
    return l_696;
    /* statement id: 329 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_43(uint32_t  p_44, float  p_45, int32_t * p_46)
{ /* block id: 266 */
    float l_586 = 0x7.C47D87p+34;
    int32_t l_587 = 0x960AF9E2;
    return l_587;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_49(const uint16_t  p_50)
{ /* block id: 39 */
    uint32_t l_68 = 0x7C584EDB;
    int32_t l_72 = 0x0DE2FD17;
    int32_t *l_71 = &l_72;
    int16_t l_347 = 2;
    float l_403 = 0xC.D35162p+86;
    int32_t **l_418 = &l_71;
    int32_t ***l_417 = &l_418;
    uint32_t l_422 = 4294967293U;
    int32_t l_436 = (-9);
    uint32_t l_470 = 0x5750D7EF;
    const int32_t *l_490 = &l_72;
    float *l_561 = &l_403;
    float **l_560 = &l_561;
    int32_t *l_583 = &l_436;
    (*l_71) = (safe_add_func_uint32_t_u_u((func_53((func_59(func_65(((l_68 ^ (((((l_68 || (safe_rshift_func_uint16_t_u_s(((void*)0 != l_71), 10))) != (*l_71)) , (p_50 < (p_50 , (safe_mod_func_uint32_t_u_u(((*l_71) | p_50), p_50))))) , (*l_71)) < (*l_71))) >= (*l_71)), (*l_71)), &l_72, (*l_71), &l_72, p_50) , &l_72), p_50, l_68, l_68, l_68) || p_50), l_68));
    (*l_71) = ((*l_71) == (((-9) & ((*l_71) , (p_50 <= l_347))) , (safe_sub_func_int16_t_s_s(((safe_add_func_float_f_f(p_50, p_50)) , __builtin_popcountl(__builtin_clz((*l_71)))), 6))));
    for (l_347 = 18; (l_347 != 22); l_347 = safe_add_func_uint16_t_u_u(l_347, 1))
    { /* block id: 146 */
        uint32_t l_354 = 0xD4865413;
        float l_398 = 0x5.8AA756p+95;
        int32_t *l_408 = &l_72;
        const int32_t *l_425 = &l_72;
        int32_t *l_533 = (void*)0;
        uint32_t l_582 = 0xC6BAD358;
        (*l_71) = (*l_71);
        if (__builtin_ctz(l_354))
        { /* block id: 148 */
            int32_t l_384 = 1;
            int32_t l_427 = (-4);
            int32_t *l_426 = &l_427;
            int32_t l_437 = 0x0959EE6E;
            uint32_t l_443 = 4294967286U;
            for (l_72 = 14; (l_72 < (-12)); l_72 = safe_sub_func_uint16_t_u_u(l_72, 6))
            { /* block id: 151 */
                int16_t l_364 = (-1);
                int32_t *l_366 = &l_72;
                for (l_68 = 0; (l_68 > 60); l_68 = safe_add_func_int16_t_s_s(l_68, 1))
                { /* block id: 154 */
                    float *l_361 = (void*)0;
                    float l_363 = (-0x1.7p-1);
                    float *l_362 = &l_363;
                    int32_t l_365 = 0x65409335;
                    int32_t **l_367 = &l_366;
                    (*l_362) = (safe_add_func_float_f_f(((*l_71) , ((void*)0 == l_361)), l_354));
                }
            }
            for (l_72 = 13; (l_72 < (-24)); --l_72)
            { /* block id: 168 */
                float l_387 = 0x6.7F5B29p-97;
                const float *l_386 = &l_387;
                int32_t l_388 = 0;
                const float **l_389 = &l_386;
                int32_t l_406 = 1;
                int32_t **l_442 = (void*)0;
                int16_t l_452 = 0xA555;
                int32_t *l_453 = &l_388;
            }
            (***l_417) = (*l_425);
        }
        else
        { /* block id: 195 */
            float l_461 = (-0x1.Dp+1);
            int32_t l_462 = 0;
            float *l_463 = &l_403;
            int32_t *l_529 = &l_72;
            int32_t ****l_574 = &l_417;
            int32_t l_581 = (-2);
            for (l_436 = 8; (l_436 <= (-7)); --l_436)
            { /* block id: 198 */
                if (p_50)
                { /* block id: 199 */
                    int32_t *l_456 = (void*)0;
                    uint16_t l_457 = 1U;
                    (**l_417) = l_456;
                    /* statement id: 200 */
                    assert (l_71 == 0);
                    (*l_408) = l_457;
                    (*l_463) = (((safe_rshift_func_uint16_t_u_s(((+p_50) <= (((p_50 & (l_456 == ((p_50 != (p_50 == l_462)) , l_463))) , ((l_462 != (l_462 , (*l_425))) > 65535U)) , p_50)), l_462)) , 0x1.Bp+1) != 0x6.Ep-1);
                    (*l_418) = l_456;
                }
                else
                { /* block id: 204 */
                    int32_t **l_464 = (void*)0;
                    int32_t **l_465 = &l_408;
                    (*l_465) = l_425;
                }
                /* facts after branching */
                assert (l_71 == &l_72 || l_71 == 0);
                (**l_417) = (**l_417);
                return p_50;
            }
            if ((p_50 , ((safe_mod_func_uint16_t_u_u((p_50 > (safe_lshift_func_uint16_t_u_s(((*l_425) , p_50), 7))), l_470)) > (safe_sub_func_int32_t_s_s((p_50 < (safe_unary_minus_func_int16_t_s(((safe_lshift_func_int16_t_s_u(p_50, 15)) <= ((l_462 > ((65529U < l_462) , (**l_418))) ^ (**l_418)))))), (***l_417))))))
            { /* block id: 210 */
                int32_t *l_478 = &l_72;
                uint32_t l_519 = 4294967290U;
                (**l_418) = 0x6011E23A;
                for (l_436 = 0; (l_436 < 23); l_436++)
                { /* block id: 214 */
                    uint16_t l_485 = 0x365C;
                    int32_t l_486 = 1;
                    (*l_418) = l_478;
                    (**l_418) = p_50;
                    l_486 = ((safe_add_func_uint16_t_u_u(p_50, (safe_div_func_int32_t_s_s((*l_478), (safe_sub_func_int32_t_s_s((p_50 , (l_485 <= ((***l_417) , p_50))), (0xD7DD27D1 ^ (((l_485 ^ p_50) | 4294967294U) < (*l_408))))))))) , p_50);
                }
                for (l_436 = (-2); (l_436 >= 29); l_436 = safe_add_func_int32_t_s_s(l_436, 3))
                { /* block id: 221 */
                    uint32_t l_491 = 0x75FB842A;
                    int32_t *l_528 = &l_462;
                }
            }
            else
            { /* block id: 238 */
                int32_t l_543 = (-9);
                const int32_t *l_547 = &l_436;
                int32_t *l_584 = &l_462;
                for (l_68 = 0; (l_68 < 10); l_68++)
                { /* block id: 241 */
                    int16_t l_542 = 0x0FA7;
                    int32_t **l_546 = &l_71;
                    uint32_t l_553 = 0xE693AD60;
                    const int32_t **l_585 = (void*)0;
                    l_425 = ((1 < (*l_408)) , func_77((!(*l_529)), l_533, (safe_lshift_func_uint16_t_u_u(((((-10) | (safe_rshift_func_int16_t_s_s((safe_div_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_s(func_53(&l_462, (__builtin_clz((l_542 , l_543)) >= (-1)), l_542, p_50, p_50), p_50)) || p_50) , p_50), p_50)), l_542))) < l_542) != p_50), 8)), l_408, (***l_417)));
                    /* statement id: 242 */
                    assert (l_425 == 0);
                    for (l_543 = 28; (l_543 == (-5)); l_543 = safe_sub_func_int32_t_s_s(l_543, 9))
                    { /* block id: 245 */
                        int32_t **l_548 = (void*)0;
                        const int32_t **l_549 = (void*)0;
                        int32_t **l_550 = &l_533;
                        const float *l_564 = &l_398;
                        const float **l_563 = &l_564;
                        const float ***l_562 = &l_563;
                        l_546 = &l_408;
                        /* statement id: 246 */
                        assert (l_546 == &l_408);
                        l_425 = l_547;
                        /* statement id: 247 */
                        assert (l_425 == &l_436);
                        (*l_550) = l_547;
                        /* statement id: 248 */
                        assert (l_533 == &l_436);
                        (*l_562) = (((safe_mod_func_uint16_t_u_u(l_553, ((safe_rshift_func_int16_t_s_u(((p_50 , (void*)0) != (void*)0), 4)) , p_50))) && (safe_sub_func_uint16_t_u_u((((__builtin_ctzll(p_50) , ((((~0x55A4685B) != ((__builtin_ctzll(((+((((*l_529) , (*l_71)) || p_50) , 0x8D09)) , p_50)) , 7U) && (*l_490))) ^ 65535U) , (-1))) , p_50) , (**l_546)), 0))) , l_560);
                        /* statement id: 249 */
                        assert (l_563 == &l_561);
                    }
                    /* facts after for loop */
                    assert (l_425 == &l_436 || l_425 == 0);
                    assert (l_546 == &l_408 || l_546 == &l_71);
                    if (((safe_div_func_float_f_f((safe_div_func_float_f_f((p_50 > (*l_584)), 0x5.B84443p+91)), p_50)) , (*l_583)))
                    { /* block id: 251 */
                        (***l_574) = (***l_574);
                    }
                    else
                    { /* block id: 253 */
                        l_585 = &l_425;
                        /* statement id: 254 */
                        assert (l_585 == &l_425);
                        if (p_50)
                            break;
                    }
                    /* facts after branching */
                    assert (l_585 == &l_425 || l_585 == 0);
                }
                /* facts after for loop */
                assert (l_425 == &l_436 || l_425 == 0 || l_425 == &l_72);
                assert (l_533 == &l_436 || l_533 == 0);
                l_533 = l_408;
                /* statement id: 258 */
                assert (l_533 == &l_72);
                return p_50;
            }
            if (p_50)
                continue;
            (****l_574) = 0xB3189EFC;
        }
    }
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_53(int32_t * p_54, uint16_t  p_55, uint32_t  p_56, uint32_t  p_57, int32_t  p_58)
{ /* block id: 126 */
    uint32_t l_325 = 0x41384D2E;
    uint16_t l_334 = 9U;
    uint16_t l_335 = 65535U;
    int32_t l_338 = 0x021EEE77;
    int32_t *l_337 = &l_338;
    int32_t **l_345 = &l_337;
    int32_t ***l_344 = &l_345;
    for (p_58 = 0; (p_58 >= (-26)); p_58 = safe_sub_func_uint32_t_u_u(p_58, 1))
    { /* block id: 129 */
        uint32_t l_333 = 9U;
        (*p_54) = ((p_58 >= (((safe_sub_func_uint16_t_u_u(0x0A15, p_56)) || (l_325 < (safe_mod_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((((safe_unary_minus_func_int16_t_s(0xE6D1)) > (((((p_58 == ((safe_div_func_int32_t_s_s(((void*)0 == &p_54), l_333)) ^ l_325)) ^ l_325) < l_333) & l_333) && l_325)) || p_57), p_56)), l_333)))) != l_334)) > 0x459C);
    }
    (*p_54) = (-10);
    if (l_335)
    { /* block id: 133 */
        int32_t *l_336 = (void*)0;
        float *l_339 = (void*)0;
        float *l_340 = (void*)0;
        float l_342 = (-0x1.4p-1);
        float *l_341 = &l_342;
        uint32_t l_343 = 0x2EFF3B49;
        l_337 = l_336;
        /* statement id: 134 */
        assert (l_337 == 0);
        (*l_341) = (p_54 == p_54);
        (*p_54) = __builtin_ia32_crc32qi(l_343, ((void*)0 == &p_54));
    }
    else
    { /* block id: 137 */
        int32_t ****l_346 = &l_344;
        (*l_346) = l_344;
    }
    /* facts after branching */
    assert (l_337 == &l_338 || l_337 == 0);
    (*p_54) = (*p_54);
    return (*p_54);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_59(int32_t * p_60, int32_t * p_61, int32_t  p_62, int32_t * p_63, uint32_t  p_64)
{ /* block id: 120 */
    float **l_308 = (void*)0;
    int32_t l_309 = (-8);
    int32_t *l_315 = &l_309;
    int32_t **l_314 = &l_315;
    uint32_t l_316 = 0xC9E5EE9B;
    (*p_63) = (*p_63);
    (*l_314) = func_77(((void*)0 == l_308), p_60, ((((((l_309 , &l_309) == p_60) && ((safe_add_func_uint32_t_u_u((safe_sub_func_uint16_t_u_u(((((l_309 & 1U) & 65526U) != 0xCCD5) , 0xEC81), p_64)), (-1))) ^ l_309)) == 0x64D65D48) || (-10)) | l_309), p_61, l_309);
    /* statement id: 122 */
    assert (l_315 == 0);
    (*p_61) = (*p_63);
    (*p_61) = (((((((l_316 , p_62) , 0x346C) >= p_64) , p_60) == l_315) || (safe_mod_func_uint16_t_u_u(__builtin_ctzl(p_64), (safe_add_func_uint16_t_u_u((l_316 & 0), l_309))))) , (*p_61));
    return l_309;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_65(uint16_t  p_66, int16_t  p_67)
{ /* block id: 40 */
    int32_t l_89 = 0x5E5AB8BF;
    int32_t *l_88 = &l_89;
    int32_t **l_224 = (void*)0;
    int32_t ***l_223 = &l_224;
    const int32_t l_257 = (-1);
    int32_t *l_289 = &l_89;
    float l_300 = 0x5.AB83D3p+66;
    int32_t *l_306 = &l_89;
    int32_t *l_307 = (void*)0;
    for (p_67 = 0; (p_67 < 9); p_67 = safe_add_func_int32_t_s_s(p_67, 1))
    { /* block id: 43 */
        const int16_t l_90 = 0x73C0;
        int32_t l_99 = 0xB4BC0730;
        int32_t **l_143 = (void*)0;
        int32_t *l_144 = &l_89;
        float l_146 = (-0x4.Cp+1);
        float *l_145 = &l_146;
        int32_t l_174 = (-1);
        int32_t *l_193 = &l_99;
    }
    (*l_223) = &l_88;
    /* statement id: 89 */
    assert (l_224 == &l_88);
    for (l_89 = 21; (l_89 == 24); l_89 = safe_add_func_uint16_t_u_u(l_89, 3))
    { /* block id: 92 */
        int32_t l_234 = (-1);
        uint16_t l_249 = 0x63CD;
        float l_251 = 0x1.Dp+1;
        float *l_250 = &l_251;
        int16_t l_270 = 1;
        float **l_278 = &l_250;
        int32_t **l_284 = &l_88;
        uint32_t l_299 = 0x678C4744;
        uint32_t l_301 = 0xE99181E8;
    }
    return l_307;
    /* statement id: 119 */
    //assert (func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_77(float  p_78, int32_t * p_79, int16_t  p_80, int32_t * p_81, int32_t  p_82)
{ /* block id: 58 */
    int32_t l_135 = 0x79EBF7AD;
    int32_t *l_134 = &l_135;
    uint32_t l_137 = 0U;
    float *l_139 = (void*)0;
    float **l_138 = &l_139;
    float l_141 = 0x4.920543p+13;
    float *l_140 = &l_141;
    int32_t *l_142 = (void*)0;
    (*l_134) = ((safe_div_func_uint32_t_u_u((&p_82 != ((p_82 ^ ((void*)0 != &p_79)) , l_134)), p_80)) >= (+((((l_137 == (-0x1.5p+1)) >= (0x7.6p-1 <= 0x1.AA3E21p-48)) >= p_78) , (*l_134))));
    l_138 = l_138;
    (*l_140) = 0xE.3E8CBBp-27;
    return l_142;
    /* statement id: 62 */
    //assert (func_77_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_84(uint32_t  p_85, uint32_t  p_86, uint16_t  p_87)
{ /* block id: 44 */
    int32_t l_103 = 0xE1B453F4;
    int32_t *l_102 = &l_103;
    float l_105 = 0x1.3p+1;
    float *l_104 = &l_105;
    int32_t *l_131 = (void*)0;
    (*l_104) = (safe_sub_func_float_f_f((l_102 != &l_103), 0x6.42BE3Cp+81));
    (*l_102) = 7;
    if ((func_106(((safe_div_func_float_f_f(p_87, (((safe_sub_func_float_f_f((p_87 <= (((*l_102) < p_87) <= (((0x9E4E2CD5 & ((p_86 <= p_86) > p_86)) ^ (*l_102)) , (*l_102)))), 0x0.Fp+1)) >= 0x0.3p-1) == 0xC.CDD171p+90))) <= 0x8.7CB689p+17), &l_103) || 4294967290U))
    { /* block id: 50 */
        (*l_102) = 2;
    }
    else
    { /* block id: 52 */
        int32_t **l_130 = &l_102;
        (*l_130) = &l_103;
        (*l_104) = (func_106(p_86, (*l_130)) > (0x8.2C8753p-70 >= ((void*)0 == (*l_130))));
        (*l_104) = (0x1.Cp-1 == ((__builtin_clz((**l_130)) != p_85) <= ((&l_103 == (*l_130)) > ((*l_102) != (((void*)0 != &l_102) != p_87)))));
    }
    return l_131;
    /* statement id: 57 */
    //assert (func_84_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_106(float  p_107, int32_t * p_108)
{ /* block id: 47 */
    uint16_t l_113 = 0xDDEC;
    float l_124 = 0xC.323298p+16;
    float *l_127 = (void*)0;
    float *l_128 = (void*)0;
    float *l_129 = &l_124;
    (*l_129) = (((l_113 == (l_113 , ((l_113 <= 0xDCBD99A0) > (safe_sub_func_int16_t_s_s((((safe_div_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((l_113 || (l_113 || (safe_mod_func_uint32_t_u_u(((((*p_108) == (l_113 , l_113)) , l_113) > 0U), l_113)))) || l_113), l_113)), 0x9FCC)), l_113)) < l_113), l_113)) <= 1) & l_113), l_113))))) , p_107) , p_107);
    return l_113;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 232
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 21
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 4
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 188

XXX times a variable address is taken: 201
XXX times a pointer is dereferenced on RHS: 243
breakdown:
   depth: 1, occurrence: 196
   depth: 2, occurrence: 28
   depth: 3, occurrence: 17
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 117
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 15
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 765

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 403
   level: 2, occurrence: 103
   level: 3, occurrence: 43
   level: 4, occurrence: 10
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 80
XXX number of pointers point to scalars: 108
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 35.6
XXX average alias set size: 1.31

XXX times a non-volatile is read: 1305
XXX times a non-volatile is write: 324
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 119
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 39
   depth: 1, occurrence: 21
   depth: 2, occurrence: 15
   depth: 3, occurrence: 18
   depth: 4, occurrence: 18
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 16.1
XXX percentage an existing variable is used: 83.9
********************* end of statistics **********************/

