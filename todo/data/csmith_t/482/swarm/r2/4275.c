/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1990463084
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_36(void);
static uint16_t  func_45(int16_t  p_46, int16_t  p_47, float  p_48, uint32_t  p_49, float  p_50);
static int16_t  func_51(int32_t  p_52, uint32_t  p_53);
static int16_t  func_58(uint16_t  p_59, const int32_t  p_60);
static int16_t  func_74(int32_t  p_75, const float  p_76, const int32_t  p_77, struct S0  p_78, uint32_t  p_79);
static const int32_t  func_86(float  p_87, struct S0  p_88, int32_t  p_89, uint32_t  p_90, struct S0  p_91);
static struct S0  func_92(uint32_t  p_93, struct S0  p_94, const struct S0  p_95, uint32_t  p_96, uint32_t  p_97);
static int16_t  func_101(uint16_t  p_102);
static uint16_t  func_110(uint16_t  p_111, uint16_t  p_112);
static int16_t  func_115(struct S0  p_116, int32_t  p_117, int16_t  p_118, const int32_t  p_119);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_36(void)
{ /* block id: 36 */
    int32_t l_61 = 0x0509B955;
    struct S0 l_80 = {4U};
    uint32_t l_477 = 0x7FCAB4B8;
    uint32_t l_518 = 1U;
    uint16_t l_536 = 0x85A4;
    int16_t l_538 = (-1);
    struct S0 l_539 = {0x68B3};
    float l_553 = 0x2.F05BC6p-72;
    int32_t l_587 = 0x13DF532C;
    int16_t l_589 = 0xA7E4;
    uint32_t l_590 = 0x14835B88;
    if (((int16_t)((uint16_t)(((int16_t)((((uint16_t)(func_45(func_51((((uint16_t)((((uint16_t)(func_58(l_61, l_61) >= ((3U & 0xF953) == (((int16_t)l_61 >> (int16_t)(((uint16_t)((uint16_t)l_61 >> (uint16_t)((int32_t)((int32_t)l_61 / (int32_t)func_58((+func_74(l_61, l_61, l_61, l_80, l_80.f0)), l_80.f0)) % (int32_t)(-8))) >> (uint16_t)l_80.f0) || (-4))) & l_61))) >> (uint16_t)15) & l_80.f0) > l_80.f0) + (uint16_t)l_61) | l_477), l_477), l_477, l_61, l_477, l_61) != l_518) >> (uint16_t)15) & l_518) | l_61) - (int16_t)l_518) | l_477) / (uint16_t)0x9EF4) >> (int16_t)l_518))
    { /* block id: 217 */
        int16_t l_519 = (-1);
        struct S0 l_521 = {0x5DF7};
        int32_t l_541 = (-6);
        if (l_519)
        { /* block id: 218 */
            uint32_t l_520 = 0x78C5174A;
            const struct S0 l_522 = {0xFE29};
            int32_t l_525 = 0xF734D981;
            struct S0 l_537 = {65535U};
            l_520 = (l_519 <= l_477);
            l_539 = func_92(l_520, l_521, l_522, __builtin_clzll(((int16_t)((l_519 || (l_525 == ((l_521.f0 < (((int32_t)(((int16_t)((l_80.f0 >= l_522.f0) == ((uint16_t)func_74((((int32_t)((int32_t)l_536 / (int32_t)l_61) % (int32_t)l_80.f0) ^ l_518), l_521.f0, l_477, l_537, l_538) << (uint16_t)5)) >> (int16_t)l_538) >= 0xFEDE) / (int32_t)l_537.f0) < 0x98FD)) || l_536))) >= l_519) % (int16_t)l_477)), l_521.f0);
        }
        else
        { /* block id: 221 */
            struct S0 l_540 = {0x6586};
            l_540 = l_80;
            l_541 = (l_518 >= l_540.f0);
            l_521 = l_540;
            l_61 = l_540.f0;
        }
    }
    else
    { /* block id: 227 */
        int32_t l_542 = 0xBE5EF2AA;
        const struct S0 l_554 = {0x3850};
        uint16_t l_575 = 0x9D18;
        uint32_t l_588 = 0x59E28820;
        l_80 = func_92(l_518, func_92((l_542 < ((uint16_t)(((4294967295U < ((int16_t)l_538 >> (int16_t)5)) & (l_80.f0 != ((int16_t)((((uint32_t)l_518 - (uint32_t)1) <= l_538) & (((((uint32_t)__builtin_clz(l_538) - (uint32_t)1) | l_538) && l_477) || 0)) / (int16_t)0x8943))) > 0xD373) + (uint16_t)0U)), l_539, l_539, l_542, l_536), l_554, l_80.f0, l_61);
        l_61 = (l_554.f0 < ((int32_t)(1 || (((0x1CB9BC56 > (0x867B ^ ((int32_t)l_542 / (int32_t)((int16_t)(0x3863 | ((int32_t)((int16_t)((uint32_t)l_554.f0 + (uint32_t)((__builtin_clzl(l_536) || 0) >= l_536)) / (int16_t)l_538) % (int32_t)l_518)) >> (int16_t)9)))) > l_61) < l_554.f0)) / (int32_t)l_554.f0));
        l_61 = (((((float)((float)l_542 - (float)((float)((float)(l_61 >= l_542) + (float)l_575) + (float)(+(((0x8.95F239p-85 < l_539.f0) > ((float)(-0x6.8p+1) - (float)l_554.f0)) < ((l_575 <= l_518) >= l_575))))) - (float)l_542) <= 0x0.B7BDB3p+4) == l_536) == 0xF.FF71FBp+35);
        l_542 = (+func_45(l_518, l_542, (+((float)func_51(((int32_t)l_61 + (int32_t)l_542), (((l_554.f0 ^ ((uint16_t)l_536 << (uint16_t)func_110(l_587, l_588))) > l_477) && l_518)) - (float)l_542)), l_575, l_61));
    }
    l_590++;
    return l_536;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(int16_t  p_46, int16_t  p_47, float  p_48, uint32_t  p_49, float  p_50)
{ /* block id: 205 */
    const struct S0 l_478 = {0x3748};
    struct S0 l_479 = {0x4A68};
    uint32_t l_485 = 0xFBD01539;
    int32_t l_490 = 1;
    l_479 = l_478;
    l_490 = (0U && (func_101(((0 >= ((p_49 ^ ((int32_t)(((((!func_51(func_101(l_485), p_47)) >= ((((uint16_t)l_485 << (uint16_t)((uint32_t)l_478.f0 / (uint32_t)p_46)) || p_49) < p_49)) >= 65535U) == 65527U) & 0xDA4BF65B) % (int32_t)l_478.f0)) < l_478.f0)) == l_485)) == 0));
    l_490 = l_479.f0;
    for (l_485 = 0; (l_485 < 46); l_485++)
    { /* block id: 211 */
        uint16_t l_516 = 0x296D;
        struct S0 l_517 = {1U};
        l_490 = ((float)l_479.f0 + (float)(!(l_490 != (-(float)((float)(0x0.Dp+1 >= (+((0xF.210143p+95 < func_74(((~p_49) | 0xB2BA6EB3), ((float)((float)(((float)((0x9.Ap-1 > ((float)(((float)((((float)(-(float)((float)0x0.F3CD4Cp-63 + (float)((__builtin_parityl(p_47) >= 0x9.Dp+1) < (-0x7.Fp-1)))) - (float)p_46) >= 0x5.9p+1) <= 0x8.7487D3p-3) - (float)p_46) == p_48) / (float)0x6.7p+1)) == l_516) + (float)p_50) > l_490) + (float)p_47) - (float)l_478.f0), p_46, l_517, p_46)) >= p_46))) - (float)p_46)))));
        l_479 = l_478;
        l_490 ^= 0x39A14275;
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_51(int32_t  p_52, uint32_t  p_53)
{ /* block id: 202 */
    p_52 &= (-1);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_58(uint16_t  p_59, const int32_t  p_60)
{ /* block id: 37 */
    uint32_t l_62 = 0x0105807C;
    l_62 &= (-8);
    return l_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_74(int32_t  p_75, const float  p_76, const int32_t  p_77, struct S0  p_78, uint32_t  p_79)
{ /* block id: 40 */
    uint16_t l_85 = 1U;
    struct S0 l_423 = {0xFA46};
    struct S0 l_462 = {0xC0AB};
    l_85 |= ((int16_t)0x56EB + (int16_t)((int16_t)(p_77 && 0x02708CDB) + (int16_t)p_78.f0));
    if (func_86(p_79, func_92(l_85, p_78, p_78, ((uint32_t)(+((func_101(l_85) & ((int32_t)func_115(l_423, p_79, l_423.f0, l_85) + (int32_t)l_85)) ^ 7U)) - (uint32_t)7U), l_85), l_85, l_423.f0, l_423))
    { /* block id: 189 */
        uint32_t l_453 = 4294967286U;
        struct S0 l_460 = {65535U};
        int32_t l_461 = (-4);
        l_461 |= (((int32_t)p_79 / (int32_t)(+(0 <= ((int32_t)__builtin_popcountl(l_423.f0) / (int32_t)(__builtin_popcountll(l_453) | (((uint16_t)(((int16_t)((int16_t)l_423.f0 << (int16_t)func_115(l_460, (l_85 == p_78.f0), l_423.f0, l_85)) + (int16_t)l_460.f0) <= 0U) << (uint16_t)l_460.f0) < 65535U)))))) && p_77);
        l_462 = func_92(l_453, p_78, l_423, l_461, p_79);
    }
    else
    { /* block id: 192 */
        float l_474 = (-0x7.5p+1);
        const int32_t l_475 = 0;
        for (l_85 = (-10); (l_85 != 44); l_85 += 9)
        { /* block id: 195 */
            const uint16_t l_473 = 0xCDE5;
            int32_t l_476 = 8;
            l_476 = ((int16_t)((((uint32_t)(func_101(p_75) | (((int32_t)(0xBB352B36 >= (p_75 | ((((int16_t)((((0x9F91 >= (4294967295U >= 0xFF55728C)) | l_473) ^ p_79) <= l_462.f0) / (int16_t)(-2)) | 0xE1EF) == p_75))) / (int32_t)p_77) == l_475)) - (uint32_t)l_473) | (-7)) ^ 0U) % (int16_t)l_423.f0);
            return l_473;
        }
    }
    p_78 = p_78;
    return l_85;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_86(float  p_87, struct S0  p_88, int32_t  p_89, uint32_t  p_90, struct S0  p_91)
{ /* block id: 184 */
    int32_t l_444 = 0x83C97DC5;
    int32_t l_445 = 1;
    uint32_t l_446 = 0x52F9BF1B;
lbl_447:
    l_445 ^= (l_444 >= __builtin_ctz(p_89));
    l_446 = p_89;
    if (l_444)
        goto lbl_447;
    return l_446;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_92(uint32_t  p_93, struct S0  p_94, const struct S0  p_95, uint32_t  p_96, uint32_t  p_97)
{ /* block id: 172 */
    struct S0 l_424 = {0x88FB};
    int32_t l_425 = 1;
    int32_t l_438 = 0x4CC767CE;
lbl_426:
    l_424 = p_94;
    l_425 = p_97;
    if (p_97)
        goto lbl_426;
    for (p_97 = 0; (p_97 < 24); p_97++)
    { /* block id: 178 */
        uint16_t l_429 = 0x12FE;
        int32_t l_442 = 0x9D2F77C8;
        struct S0 l_443 = {5U};
        l_429++;
        l_442 = ((uint16_t)((uint32_t)(l_429 | (((func_115(p_94, (((int16_t)l_425 >> (int16_t)p_93) < (p_97 > l_429)), func_110(l_438, ((+p_97) != ((int16_t)(-1) << (int16_t)p_96))), p_94.f0) ^ 8) <= p_94.f0) || p_95.f0)) - (uint32_t)0xD3CF2577) - (uint16_t)l_429);
        l_424 = l_443;
    }
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_101(uint16_t  p_102)
{ /* block id: 42 */
    int16_t l_105 = 0;
    uint16_t l_125 = 0U;
    int32_t l_402 = (-1);
    int32_t l_420 = 0x731839F9;
    for (p_102 = (-21); (p_102 <= 4); p_102 += 1)
    { /* block id: 45 */
        struct S0 l_120 = {65535U};
        uint16_t l_411 = 0xBA3B;
        l_105 = (-1);
        l_402 = ((uint16_t)1U >> (uint16_t)((uint16_t)func_110(func_58(l_105, (p_102 & (p_102 < (((int16_t)func_115(l_120, ((-5) < func_58(((p_102 || ((uint16_t)l_105 >> (uint16_t)((int16_t)((65527U < l_105) || p_102) + (int16_t)l_125))) < p_102), l_120.f0)), l_120.f0, p_102) << (int16_t)7) > (-1))))), p_102) + (uint16_t)l_120.f0));
        l_402 = (((((int32_t)((uint16_t)(p_102 >= (0 | ((-9) <= ((((uint32_t)l_411 - (uint32_t)((int32_t)((int16_t)p_102 << (int16_t)0) - (int32_t)(4294967287U || l_120.f0))) & ((uint16_t)(p_102 & ((int16_t)0x1C11 >> (int16_t)l_411)) << (uint16_t)11)) < l_125)))) % (uint16_t)p_102) / (int32_t)5U) ^ l_420) && p_102) ^ p_102);
        if (p_102)
            break;
    }
    return l_125;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_110(uint16_t  p_111, uint16_t  p_112)
{ /* block id: 50 */
    const int32_t l_133 = (-1);
    const uint32_t l_153 = 4294967286U;
    int32_t l_154 = 0x9CD2C718;
    struct S0 l_207 = {65526U};
    int32_t l_224 = 0x940662CF;
    int32_t l_226 = 0xFBC085BF;
    int32_t l_227 = 0x89AF0E19;
    int32_t l_230 = 0x37666566;
    int32_t l_233 = 0x4536AC00;
    int32_t l_240 = 0x82483C1F;
    int32_t l_246 = 0x9F213F65;
    int32_t l_260 = 0x93B81CEE;
    int32_t l_272 = (-1);
    int32_t l_297 = 0xF4834D8C;
    int16_t l_337 = 6;
    int32_t l_350 = 0x852471F1;
    struct S0 l_374 = {0xE7CC};
    float l_380 = (-0x1.Cp+1);
    if (((int32_t)((int32_t)(((int32_t)((l_133 | p_111) == __builtin_popcount(__builtin_ctzll(l_133))) + (int32_t)l_133) < (-(uint32_t)(l_133 < l_133))) % (int32_t)(+(((int32_t)(-1) / (int32_t)p_111) < p_112))) / (int32_t)l_133))
    { /* block id: 51 */
        struct S0 l_146 = {0x7283};
        int16_t l_223 = 0x187F;
        int32_t l_229 = 1;
        int32_t l_231 = 0xDB4FB469;
        int32_t l_232 = 0x3482B3DB;
        int32_t l_235 = (-5);
        int32_t l_247 = 6;
        int32_t l_253 = 0x3EEACEA0;
        int32_t l_254 = (-5);
        int32_t l_259 = (-5);
        int32_t l_273 = 0xBCD35E6B;
        uint32_t l_274 = 0U;
        const int16_t l_317 = 0xDB8E;
        if (p_111)
        { /* block id: 52 */
            const float l_138 = (-0x1.Dp+1);
            int32_t l_139 = 5;
            int32_t l_140 = 0x3A9B92FD;
            struct S0 l_141 = {0x8C64};
            int16_t l_149 = 1;
            if ((l_139 ^ (0xF6B9 > l_140)))
            { /* block id: 53 */
                const uint32_t l_150 = 0x9415F902;
                l_141 = l_141;
                l_154 ^= func_58((((int16_t)0x70E0 >> (int16_t)14) || ((uint16_t)func_115(l_146, ((uint16_t)l_141.f0 << (uint16_t)4), l_149, l_150) << (uint16_t)(p_111 > ((((((int16_t)0x153C >> (int16_t)7) <= l_133) <= 0) > l_153) > (-1))))), p_112);
            }
            else
            { /* block id: 56 */
                l_146 = l_146;
            }
        }
        else
        { /* block id: 59 */
            int32_t l_159 = 1;
            const uint16_t l_168 = 65530U;
            uint32_t l_200 = 0x6E786C87;
            int32_t l_203 = (-10);
            struct S0 l_208 = {65535U};
            int32_t l_234 = 0xFEDF4294;
            float l_241 = 0x1.1p+1;
            int32_t l_248 = 0x50EBD88D;
            int32_t l_258 = (-8);
            int32_t l_261 = (-1);
            int32_t l_266 = 3;
            int32_t l_269 = 0x92A7B370;
            if (((uint16_t)func_115(l_146, ((int16_t)(((l_159 == ((uint16_t)l_154 - (uint16_t)(p_111 ^ func_115(l_146, ((int16_t)(((uint16_t)__builtin_clzll((((((__builtin_ctzll((((((uint16_t)(((l_159 > 0x3662) | l_153) | l_159) + (uint16_t)0x49AA) ^ p_112) != p_111) | l_153)) >= 3U) == p_111) > l_146.f0) && l_154) && l_159)) << (uint16_t)l_146.f0) > 4294967295U) >> (int16_t)5), p_112, l_153)))) == 1U) ^ p_112) >> (int16_t)p_112), l_153, l_168) << (uint16_t)l_146.f0))
            { /* block id: 60 */
                uint32_t l_171 = 0xB7DE0C38;
                struct S0 l_174 = {0x8500};
                uint32_t l_191 = 0xC1B4120C;
                l_159 = ((p_111 & 1U) != 0x1B3D);
                if (l_153)
                { /* block id: 62 */
                    int32_t l_173 = 0xCD19B671;
                    l_154 = ((float)__builtin_popcountl(l_171) - (float)(((-(float)(l_173 != l_168)) < (func_115(l_174, (((uint16_t)l_146.f0 + (uint16_t)l_159) >= ((0 && l_174.f0) == l_153)), l_168, l_146.f0) > p_111)) < 0x8.Dp+1));
                }
                else
                { /* block id: 64 */
                    int32_t l_177 = (-10);
                    int32_t l_178 = 0x924C0CEF;
                    l_178 = (l_154 > ((0x3C346906 < l_177) != l_168));
                    l_178 &= ((+((uint16_t)(func_58((l_146.f0 != (((((-(uint32_t)((int16_t)((((uint16_t)p_111 << (uint16_t)((0x1DC0D213 || ((int32_t)l_133 / (int32_t)1U)) < (p_112 & 0x5DE8CEC1))) >= func_58(p_111, ((uint32_t)p_111 - (uint32_t)p_111))) | p_112) / (int16_t)p_112)) ^ l_146.f0) ^ l_146.f0) & p_111) < p_111)), l_146.f0) ^ l_168) + (uint16_t)8)) || l_191);
                }
            }
            else
            { /* block id: 68 */
                l_159 = p_112;
            }
            l_154 = ((int16_t)1 / (int16_t)((int32_t)func_115(l_146, (l_168 != l_133), p_112, l_159) + (int32_t)l_168));
            if (((((((uint32_t)(l_146.f0 ^ 0x455E) - (uint32_t)l_133) || ((uint16_t)l_200 >> (uint16_t)1)) && 4294967286U) < p_111) && (l_200 > (0x936D73F1 <= ((uint16_t)p_111 - (uint16_t)l_146.f0)))))
            { /* block id: 72 */
                return l_159;
            }
            else
            { /* block id: 74 */
                struct S0 l_209 = {1U};
                int32_t l_217 = 9;
                int32_t l_225 = 0xC39F9920;
                int32_t l_228 = 0x9776ACFB;
                int32_t l_236 = 0x7461C8C1;
                int32_t l_238 = 0x935077A8;
                int32_t l_239 = 0xCFD5121E;
                int32_t l_244 = (-1);
                int32_t l_250 = (-7);
                int32_t l_252 = (-1);
                int32_t l_257 = 1;
                int32_t l_265 = 0;
                int32_t l_268 = 1;
                int32_t l_271 = 0;
                uint16_t l_304 = 1U;
                int32_t l_307 = 0x24737F3D;
                l_203 = (-0x1.7p+1);
                for (l_200 = 0; (l_200 == 31); l_200 += 8)
                { /* block id: 78 */
                    struct S0 l_206 = {0U};
                    l_207 = l_206;
                    l_159 ^= 0xBDC872F4;
                }
                if (p_112)
                { /* block id: 82 */
                    uint32_t l_210 = 4294967295U;
                    uint16_t l_216 = 1U;
                    int32_t l_219 = 0x62887591;
                    int32_t l_220 = 1;
                    int32_t l_221 = 0xD5D329C1;
                    int32_t l_237 = 0xC0A783F8;
                    int32_t l_242 = 1;
                    int32_t l_251 = 0xA6E62E55;
                    int32_t l_255 = 0xF4295DAE;
                    int32_t l_262 = 0x6276A10C;
                    int32_t l_263 = 0;
                    l_209 = l_208;
                    if (l_210)
                    { /* block id: 84 */
                        int32_t l_215 = (-10);
                        l_216 = ((p_112 > (((l_208.f0 | (func_58(p_111, l_133) != l_209.f0)) | ((int32_t)l_215 % (int32_t)__builtin_ffsll(l_133))) && p_112)) | 0);
                    }
                    else
                    { /* block id: 86 */
                        int32_t l_218 = 1;
                        int32_t l_222 = (-4);
                        int32_t l_243 = 3;
                        int32_t l_245 = 9;
                        int32_t l_249 = (-8);
                        int32_t l_256 = 0xF4FEEF6E;
                        int32_t l_264 = 0x54D3951E;
                        int32_t l_267 = 0x53771584;
                        int32_t l_270 = 0;
                        l_274--;
                    }
                }
                else
                { /* block id: 89 */
                    float l_283 = 0x7.F6EFABp-59;
                    int32_t l_286 = 0xE61B32DC;
                    l_286 = ((4294967295U || (p_111 >= ((uint32_t)(p_112 == (l_260 & (((int16_t)((0x960850B4 ^ ((uint16_t)__builtin_ffsll(p_111) - (uint16_t)p_111)) && ((uint16_t)(0x75F21B87 == (-6)) % (uint16_t)p_112)) - (int16_t)l_200) ^ l_232))) + (uint32_t)l_227))) ^ p_111);
                    if (l_260)
                        goto lbl_311;
                    l_286 = l_227;
lbl_311:
                    if ((((uint32_t)((uint16_t)(((int32_t)(((int16_t)1 / (int16_t)l_258) == p_111) + (int32_t)l_286) == ((uint32_t)l_297 / (uint32_t)__builtin_ctzll(p_111))) << (uint16_t)11) + (uint32_t)(func_58(l_253, ((uint16_t)(0x31AA < l_229) << (uint16_t)10)) == 65535U)) <= l_253))
                    { /* block id: 92 */
                        l_258 &= ((int32_t)__builtin_clzl(p_112) + (int32_t)l_259);
                        l_266 ^= ((1U >= ((int32_t)func_58(p_111, p_112) + (int32_t)(l_304 | __builtin_parityll(p_112)))) ^ ((uint16_t)(l_307 ^ ((int16_t)(1U <= p_111) << (int16_t)l_261)) >> (uint16_t)p_112));
                    }
                    else
                    { /* block id: 95 */
                        int32_t l_310 = 0xAF47B704;
                        return l_310;
                    }
                    l_203 = ((uint16_t)0x7B76 << (uint16_t)6);
                }
                l_159 = p_112;
            }
        }
        for (l_254 = 0; (l_254 != (-19)); l_254 -= 1)
        { /* block id: 106 */
            uint32_t l_316 = 0x1593233A;
            int32_t l_318 = 0x7CEFB775;
            l_207 = l_207;
            l_316 = p_112;
            l_318 = (p_111 != (((((func_115(l_207, p_112, (p_112 <= l_232), l_317) <= ((func_115(l_146, __builtin_bswap32(l_316), l_247, p_112) >= p_112) == p_111)) <= l_317) != p_112) != p_112) >= p_111));
        }
    }
    else
    { /* block id: 111 */
        uint16_t l_319 = 0xBC13;
        struct S0 l_324 = {65531U};
        uint32_t l_327 = 4294967295U;
        l_246 |= (l_319 > ((uint16_t)((int16_t)(__builtin_ctzll(((func_115(l_207, l_319, p_112, p_111) < l_319) & l_224)) > l_153) >> (int16_t)p_112) << (uint16_t)2));
        l_324 = l_324;
        l_233 &= (0x71BD32C4 && ((-1) <= __builtin_popcountll((((int16_t)((l_327 & 0x3B7CB896) != ((int16_t)(-3) << (int16_t)(+((int32_t)l_319 % (int32_t)__builtin_popcountll((((int16_t)p_112 >> (int16_t)((0x67A9038F < p_112) || p_111)) & l_260)))))) / (int16_t)p_111) <= 0x039A))));
        l_154 &= l_319;
    }
    l_240 ^= ((0x4B40CF5E >= l_297) ^ p_111);
    if ((65530U >= p_112))
    { /* block id: 118 */
        int32_t l_340 = 0x0D671F37;
        int32_t l_341 = 0x8E8DE44F;
        struct S0 l_345 = {0x1135};
        uint32_t l_360 = 0x2832AB46;
        for (p_112 = 13; (p_112 >= 30); p_112++)
        { /* block id: 121 */
            uint32_t l_342 = 0xFA11A287;
            l_272 = l_337;
            if (p_111)
            { /* block id: 123 */
                int16_t l_348 = 0x7AC4;
                for (l_233 = 14; (l_233 == (-23)); l_233 -= 1)
                { /* block id: 126 */
                    l_154 = l_340;
                }
                l_342--;
                l_207 = l_345;
                l_348 = ((int16_t)7 << (int16_t)13);
            }
            else
            { /* block id: 132 */
                int32_t l_351 = 0x88169B93;
                l_350 = (-(int16_t)p_111);
                if (l_351)
                    continue;
            }
            l_246 = p_112;
            if (l_342)
                goto lbl_361;
        }
        l_224 = p_111;
lbl_361:
        l_360 &= (p_112 & ((l_345.f0 || (((uint16_t)((int16_t)__builtin_clzl(((p_111 < (p_112 && (((uint16_t)(((uint16_t)(l_341 | 0) / (uint16_t)__builtin_ffsll(p_111)) < p_111) >> (uint16_t)p_112) & p_112))) != l_341)) << (int16_t)13) << (uint16_t)11) & 6)) >= 0x8338CC7A));
        if ((-(uint32_t)p_112))
        { /* block id: 141 */
            int32_t l_363 = 0x40F6EF4E;
            l_363 = (l_363 && ((int16_t)(((int32_t)p_111 + (int32_t)l_227) > ((uint16_t)(((p_111 == ((l_363 | l_240) | (l_341 >= (((int32_t)((int16_t)__builtin_popcountl(l_207.f0) - (int16_t)65533U) - (int32_t)l_341) | l_345.f0)))) ^ 0xC2999D47) == p_112) / (uint16_t)p_111)) + (int16_t)p_112));
        }
        else
        { /* block id: 143 */
            l_374 = l_207;
            for (l_224 = (-21); (l_224 < (-27)); l_224 -= 1)
            { /* block id: 147 */
                return l_340;
            }
        }
    }
    else
    { /* block id: 151 */
        uint32_t l_377 = 4294967295U;
        int32_t l_378 = 0x1E13D4BF;
        struct S0 l_379 = {0xA1AB};
        l_377 = (1 & p_112);
        l_378 |= p_112;
        l_379 = l_379;
        if (l_378)
        { /* block id: 155 */
            int32_t l_385 = (-1);
            for (l_230 = (-15); (l_230 < 5); l_230 += 1)
            { /* block id: 158 */
                uint32_t l_395 = 0xCDF09FE0;
                uint16_t l_401 = 65535U;
                l_378 ^= (((0xABD784E6 & (l_153 > l_385)) >= (((~((int16_t)((uint16_t)l_385 >> (uint16_t)((uint16_t)__builtin_parityll((((int32_t)l_226 % (int32_t)l_395) | ((((((((uint32_t)(0xA9B5 >= p_112) % (uint32_t)((int16_t)(~l_385) >> (int16_t)l_401)) && l_401) == 0x00326E57) ^ 1U) && l_401) && p_111) >= p_112))) % (uint16_t)3U)) << (int16_t)p_111)) | l_133) || 1)) || 0x0F11);
            }
            return l_374.f0;
        }
        else
        { /* block id: 162 */
            return l_379.f0;
        }
    }
    return l_207.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_115(struct S0  p_116, int32_t  p_117, int16_t  p_118, const int32_t  p_119)
{ /* block id: 47 */
    uint32_t l_126 = 0xF2ABA01C;
    l_126 = 0x0F48B4F1;
    return p_119;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_36();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 160
   depth: 1, occurrence: 27
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 151
   depth: 2, occurrence: 16
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 15, occurrence: 5
   depth: 16, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 496
XXX times a non-volatile is write: 89
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 127
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 32
   depth: 2, occurrence: 25
   depth: 3, occurrence: 19
   depth: 4, occurrence: 13
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 29.3
XXX percentage an existing variable is used: 70.7
********************* end of statistics **********************/

