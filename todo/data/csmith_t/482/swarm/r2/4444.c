/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2463285008
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   volatile signed f0 : 22;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static volatile int32_t g_2 = (-4L);/* VOLATILE GLOBAL g_2 */
static int32_t g_3 = (-1L);
static int32_t *g_57 = &g_3;
static float g_68 = 0x0.4p+1;
static int32_t g_71 = 6L;
static uint32_t g_83 = 0x7D07A125L;
static volatile struct S0 *g_124 = (void*)0;
static int16_t g_161 = 0x702EL;
static struct S0 g_168 = {1239};/* VOLATILE GLOBAL g_168 */
static float g_203 = 0x9.AD1233p+37;
static int32_t *g_255 = &g_3;
static int32_t **g_254 = &g_255;
static struct S0 g_301 = {-1869};/* VOLATILE GLOBAL g_301 */
static volatile struct S0 g_333 = {-1081};/* VOLATILE GLOBAL g_333 */
static volatile struct S0 g_334 = {778};/* VOLATILE GLOBAL g_334 */
static volatile struct S0 g_405 = {-413};/* VOLATILE GLOBAL g_405 */
static struct S0 g_408 = {856};/* VOLATILE GLOBAL g_408 */
static struct S0 g_409 = {1469};/* VOLATILE GLOBAL g_409 */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static int32_t * func_6(int32_t * p_7, int32_t * p_8, uint16_t  p_9, int32_t * p_10, uint32_t  p_11);
static int32_t * func_12(int32_t * p_13, float  p_14, int32_t * p_15, int32_t * p_16);
static int32_t * func_17(uint32_t  p_18, int32_t * p_19, float  p_20, uint16_t  p_21);
static uint16_t  func_22(int32_t * p_23, uint8_t  p_24);
static uint32_t  func_33(int32_t * p_34, int32_t * p_35);
static int32_t * func_36(uint32_t  p_37);
static int16_t  func_42(int32_t * p_43, uint32_t  p_44);
static uint32_t  func_48(int32_t  p_49);
static int16_t  func_55(int16_t  p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_2 g_57 g_83 g_71 g_68 g_124 g_161 g_203 g_254 g_255 g_168 g_301.f0 g_333 g_334.f0 g_405 g_408
 * writes: g_3 g_68 g_71 g_124 g_57 g_161 g_83 g_255 g_168 g_203 g_334 g_409
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int16_t l_38 = (-5L);
    int32_t *l_330 = &g_3;
    for (g_3 = 10; (g_3 >= (-11)); g_3 -= 8)
    { /* block id: 3 */
        uint16_t l_257 = 0x925AL;
        int32_t *l_329 = &g_3;
        (*g_254) = func_6(func_12(func_17((func_22((((int16_t)g_2 - (int16_t)(2UL || ((~g_3) & ((int16_t)g_3 % (int16_t)((int16_t)(~func_33(&g_3, func_36(l_38))) - (int16_t)(((g_3 >= 0xF4E5L) , 4294967295UL) && l_257)))))) , (*g_254)), g_3) , 0x234616B0L), &g_3, g_3, l_38), g_3, l_329, l_330), l_330, (*l_329), l_329, g_3);
        g_409 = g_408;
    }
    return (*l_330);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_254 g_255 g_3 g_161 g_334.f0 g_405
 * writes: g_71 g_255
 */
static int32_t * func_6(int32_t * p_7, int32_t * p_8, uint16_t  p_9, int32_t * p_10, uint32_t  p_11)
{ /* block id: 129 */
    uint8_t l_384 = 0x0DL;
    for (g_71 = 0; (g_71 <= 25); g_71 += 8)
    { /* block id: 132 */
        volatile struct S0 **l_381 = &g_124;
        volatile struct S0 ***l_380 = &l_381;
        float *l_394 = (void*)0;
        float **l_393 = &l_394;
        float ***l_392 = &l_393;
        float ****l_391 = &l_392;
        int32_t l_395 = 1L;
        int32_t *l_407 = &l_395;
        (*l_380) = &g_124;
        (*g_254) = (*g_254);
        for (p_11 = 7; (p_11 != 23); p_11 += 8)
        { /* block id: 137 */
            int16_t l_404 = 5L;
            struct S0 *l_406 = &g_168;
            if (l_384)
                break;
            for (p_9 = 17; (p_9 > 34); p_9 += 1)
            { /* block id: 141 */
                int32_t ***l_388 = (void*)0;
                int32_t ****l_387 = &l_388;
                int32_t *l_396 = (void*)0;
                int32_t *l_397 = &l_395;
                (*l_387) = &g_254;
                /* statement id: 142 */
                assert (l_388 == &g_254);
                if ((*p_10))
                    break;
                (*l_397) = (((((-6L) | ((void*)0 != l_391)) , ((l_395 | 0x07DAD963L) && ((-10L) > 0xD59CL))) ^ g_161) ^ (0xA5377460L && 1UL));
            }
            (*g_254) = func_36((((((uint16_t)p_11 - (uint16_t)((((((p_9 == ((uint16_t)l_384 % (uint16_t)0x5DD7L)) == p_11) , (((int16_t)(l_404 > g_334.f0) + (int16_t)p_11) , g_405)) , l_406) != l_406) ^ 0x46EEL)) || l_384) , p_9) , p_9));
            (*g_254) = p_10;
        }
        (*l_407) = (g_405.f0 , (**g_254));
    }
    return (*g_254);
    /* statement id: 151 */
    //assert (func_6_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_161 g_333 g_301.f0 g_71 g_3 g_334.f0 g_254 g_255
 * writes: g_161 g_334
 */
static int32_t * func_12(int32_t * p_13, float  p_14, int32_t * p_15, int32_t * p_16)
{ /* block id: 119 */
    uint8_t l_343 = 1UL;
    uint32_t l_362 = 1UL;
    float *l_365 = &g_68;
    float **l_364 = &l_365;
    float ***l_363 = &l_364;
    for (g_161 = 0; (g_161 < (-28)); g_161 -= 7)
    { /* block id: 122 */
        float *l_338 = &g_203;
        float **l_337 = &l_338;
        float ***l_336 = &l_337;
        float ****l_335 = &l_336;
        struct S0 *l_358 = (void*)0;
        struct S0 **l_357 = &l_358;
        struct S0 ***l_356 = &l_357;
        int32_t l_361 = (-2L);
        int32_t *l_366 = &l_361;
        g_334 = g_333;
        (*l_335) = (void*)0;
        /* statement id: 124 */
        assert (l_336 == 0);
        (*l_366) = ((((int16_t)g_301.f0 - (int16_t)0x3E62L) , (((uint16_t)l_343 - (uint16_t)((((float)((!((float)((float)((((float)(p_14 < (((((((l_343 > (((!((float)(l_356 == (void*)0) - (float)((float)(((p_14 >= (0xC.875EC3p-83 <= 0xD.44564Fp+74)) == p_14) >= 0x0.E3640Ap+57) - (float)l_361))) != p_14) >= l_362)) >= g_301.f0) < g_71) > p_14) >= 0xF.C4E963p+63) > g_71) <= 0xA.7737C8p-50)) + (float)l_362) < l_361) == l_361) + (float)p_14) - (float)p_14)) < 0xA.24C3FCp+37) + (float)l_361) , (void*)0) == l_363)) != l_362)) , (*p_13));
        (*l_366) = ((((int16_t)(*l_366) >> (int16_t)(0L == ((((int16_t)(+(*p_15)) % (int16_t)l_343) && ((int16_t)((int32_t)(*p_15) % (int32_t)(((int16_t)((((*l_363) != (void*)0) ^ ((((0x3C5CL | (l_343 | 0x385CBB0EL)) < l_343) <= g_334.f0) & 0x54C98D32L)) , 0x3DE2L) >> (int16_t)12) & g_71)) + (int16_t)0x56B1L)) && (*l_366)))) <= 1UL) == g_161);
    }
    return (*g_254);
    /* statement id: 128 */
    //assert (func_12_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_3 g_161 g_71 g_83 g_168.f0 g_203 g_168 g_301.f0
 * writes: g_71 g_203 g_168
 */
static int32_t * func_17(uint32_t  p_18, int32_t * p_19, float  p_20, uint16_t  p_21)
{ /* block id: 103 */
    uint8_t l_282 = 0x5EL;
    float *l_289 = &g_203;
    int16_t l_302 = (-5L);
    int32_t l_311 = 0x7618F1FBL;
    int32_t *l_314 = &g_71;
    struct S0 *l_318 = &g_168;
    struct S0 **l_324 = &l_318;
    struct S0 ***l_323 = &l_324;
    for (p_18 = 0; (p_18 == 8); p_18 += 1)
    { /* block id: 106 */
        int32_t *l_269 = &g_3;
        int32_t *l_283 = (void*)0;
        int32_t *l_284 = &g_71;
        struct S0 **l_285 = (void*)0;
        struct S0 ***l_286 = &l_285;
        (*l_284) = ((((l_269 == (((int16_t)p_18 + (int16_t)((uint16_t)((int16_t)(((uint32_t)g_2 - (uint32_t)(((uint32_t)((*l_269) <= 1L) % (uint32_t)g_161) , 0x29F3894AL)) < ((int32_t)(g_71 , l_282) + (int32_t)0xF3F161F6L)) % (int16_t)g_161) + (uint16_t)(*l_269))) , p_19)) >= g_3) == 0x8E5AL) & 1L);
        (*l_286) = l_285;
    }
    for (p_18 = 0; (p_18 > 36); p_18 += 8)
    { /* block id: 112 */
        uint16_t l_292 = 0xD5BFL;
        struct S0 *l_300 = &g_301;
        float **l_316 = &l_289;
        float ***l_315 = &l_316;
        g_203 = (((((void*)0 == l_289) <= ((((uint16_t)(((-1L) > (g_161 == l_292)) && (((uint16_t)(-(int16_t)(g_2 | (((uint16_t)((int16_t)(((void*)0 == l_300) , (l_292 < l_282)) << (int16_t)g_71) << (uint16_t)g_161) > (-1L)))) >> (uint16_t)11) , g_83)) << (uint16_t)12) , g_83) <= 0xA.854A16p+31)) >= g_3) >= l_302);
        (*l_289) = (0x0.7p-1 == ((float)(g_2 , ((float)(((((l_302 < p_18) <= ((l_302 <= ((float)(((float)((((((((l_311 || ((uint16_t)((0xB01EL && 65535UL) || 0xCF90L) % (uint16_t)g_168.f0)) , p_18) >= g_161) , l_314) != (void*)0) >= p_21) > 0x1.2p+1) != 0xF.4E383Dp+59) + (float)0xE.D8CBC5p-11) <= g_203) - (float)(*l_314))) < p_18)) == (-0x1.2p+1)) <= p_18) == p_20) - (float)l_292)) - (float)l_292));
        (*l_315) = &l_289;
    }
    (***l_323) = ((!((l_318 != l_318) || ((int16_t)(((((uint16_t)(((*l_318) , p_21) <= ((((*l_314) < g_71) , l_323) == (void*)0)) >> (uint16_t)((uint16_t)((int16_t)(((*l_324) != (*l_324)) != g_161) % (int16_t)4L) - (uint16_t)(-9L))) != 1L) && g_301.f0) > (*p_19)) + (int16_t)(*l_314)))) , (*l_318));
    return p_19;
    /* statement id: 118 */
    //assert (func_17_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_3 g_254 g_255 g_83 g_168
 * writes: g_255 g_168
 */
static uint16_t  func_22(int32_t * p_23, uint8_t  p_24)
{ /* block id: 99 */
    int32_t l_258 = 0x8862E0C1L;
    float *l_265 = &g_203;
    struct S0 *l_266 = &g_168;
    (*g_254) = (((((((l_258 < ((0xA275D891L ^ (-(uint16_t)g_2)) == (((!l_258) != ((g_3 , (((((int16_t)(p_24 | (((((int16_t)g_3 >> (int16_t)((*g_254) == ((l_265 == l_265) , (void*)0))) == (*g_255)) & l_258) > l_258)) % (int16_t)l_258) & 1UL) >= 0UL) <= 0x9ADDL)) > g_83)) ^ g_3))) == 0xCD3094BAL) & 1L) | (*g_255)) < 0xA08DL) >= 0xCF49L) , (*g_254));
    (*l_266) = g_168;
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_57 g_83 g_71 g_68 g_124 g_161 g_203 g_254
 * writes: g_68 g_71 g_124 g_57 g_161 g_83
 */
static uint32_t  func_33(int32_t * p_34, int32_t * p_35)
{ /* block id: 6 */
    int32_t *l_45 = &g_3;
    int32_t *l_256 = &g_71;
    (*l_256) = (0xA720L || (((int16_t)func_42(l_45, (*l_45)) - (int16_t)((((g_3 == ((uint32_t)g_3 + (uint32_t)(g_254 == &l_45))) >= (*l_45)) != (*l_45)) == 0L)) , 2UL));
    return g_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(uint32_t  p_37)
{ /* block id: 4 */
    int32_t *l_39 = &g_3;
    return l_39;
    /* statement id: 5 */
    //assert (func_36_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_57 g_83 g_71 g_68 g_124 g_161 g_203
 * writes: g_68 g_71 g_124 g_57 g_161 g_83
 */
static int16_t  func_42(int32_t * p_43, uint32_t  p_44)
{ /* block id: 7 */
    int32_t *l_47 = &g_3;
    int32_t **l_46 = &l_47;
    uint32_t l_143 = 4294967295UL;
    struct S0 *l_167 = &g_168;
    float l_200 = (-0x9.3p+1);
    struct S0 *l_216 = (void*)0;
    int32_t *l_251 = &g_71;
    l_46 = l_46;
    (*l_46) = &g_3;
    if ((p_44 , ((*p_43) & p_44)))
    { /* block id: 10 */
        uint8_t l_52 = 0x72L;
        int16_t l_62 = 0xDA82L;
        (*l_46) = func_36(func_48((((int16_t)((&l_47 != &l_47) , l_52) - (int16_t)g_3) && ((int16_t)func_55((((**l_46) > (*l_47)) == ((((((void*)0 == g_57) , ((((((((uint16_t)((((float)l_52 - (float)p_44) <= l_62) , 0x040CL) >> (uint16_t)14) == p_44) <= (*l_47)) == (**l_46)) , &g_3) == (void*)0) ^ (*g_57))) , &g_57) != &g_57) || l_62))) << (int16_t)g_3))));
    }
    else
    { /* block id: 44 */
        int32_t *l_138 = &g_3;
        int16_t l_144 = 0x24BBL;
        int16_t l_160 = 0x69DAL;
        int32_t *l_208 = &g_3;
        int32_t l_246 = 0L;
        for (g_71 = 0; (g_71 > 2); g_71 += 1)
        { /* block id: 47 */
            p_43 = (*l_46);
        }
        for (g_71 = 0; (g_71 >= (-27)); g_71 -= 6)
        { /* block id: 52 */
            int32_t l_156 = 0xCE40C687L;
            float *l_157 = &g_68;
            uint32_t l_202 = 0x7C989E8BL;
            int32_t l_220 = 0x1009C59FL;
            p_43 = l_138;
            for (p_44 = 0; (p_44 < 12); p_44 += 1)
            { /* block id: 56 */
                int32_t l_151 = 9L;
                uint32_t l_152 = 4UL;
                float *l_153 = &g_68;
                (*l_153) = (((float)l_143 - (float)(l_144 < 0xF.5F0EF6p-30)) < (g_68 == (g_3 <= (((float)(g_3 >= ((float)((g_71 >= ((float)(l_138 == (l_151 , p_43)) + (float)l_152)) == g_71) + (float)p_44)) - (float)g_68) > (-0x7.Cp-1)))));
            }
            g_161 = ((((uint16_t)(l_156 && (l_157 == ((0x25E7L < l_156) , func_36(l_156)))) >> (uint16_t)(((((g_71 >= (l_47 == (void*)0)) < l_160) ^ g_71) , p_43) != (void*)0)) , (void*)0) != (void*)0);
            for (g_161 = 3; (g_161 > 23); g_161 += 2)
            { /* block id: 62 */
                int32_t l_175 = 9L;
                uint32_t l_211 = 5UL;
                struct S0 *l_217 = (void*)0;
                int32_t *l_223 = &l_175;
                for (l_160 = 28; (l_160 != 22); l_160 -= 1)
                { /* block id: 65 */
                    int32_t *l_169 = &l_156;
                    struct S0 *l_172 = (void*)0;
                    if ((65531UL > (+(g_124 != l_167))))
                    { /* block id: 66 */
                        int32_t *l_176 = (void*)0;
                        l_176 = ((((((((void*)0 == l_169) != (((&p_43 != ((&p_43 != (((((float)(l_156 , ((l_167 == l_172) <= ((((p_44 < ((((float)(l_156 != (-0x3.6p+1)) - (float)0x9.2447E6p-67) >= (*l_47)) > 0x8.D01DBDp-85)) < 0x1.Ap-1) <= (-0x10.2p+1)) < (-0x1.0p+1)))) - (float)p_44) >= g_161) > 0xD.E858CEp+4) , &g_57)) , (void*)0)) && p_44) < 0xA6E1C48DL)) , l_175) <= (*l_169)) > (*l_169)) , l_156) , &g_71);
                        /* statement id: 67 */
                        assert (l_176 == &g_71);
                        (*l_169) = (~((((int32_t)((((uint16_t)((((*l_169) , (((int16_t)((uint16_t)p_44 >> (uint16_t)((int16_t)((uint32_t)p_44 + (uint32_t)(4294967287UL ^ (*l_169))) >> (int16_t)((uint32_t)((int32_t)(((((int16_t)((int32_t)((int16_t)g_83 << (int16_t)(((*l_176) == (((((*p_43) ^ (!65528UL)) < (*l_169)) , g_124) != (void*)0)) < 0x2B19L)) + (int32_t)l_156) + (int16_t)p_44) == p_44) ^ (*l_169)) <= 0x08F80013L) % (int32_t)(*p_43)) + (uint32_t)g_83))) >> (int16_t)14) & (*l_169))) && g_161) < 0UL) >> (uint16_t)p_44) <= 8L) & 6L) + (int32_t)0x18F96CBEL) && l_202) & (**l_46)));
                        (*l_46) = &g_71;
                        /* statement id: 69 */
                        assert (l_47 == &g_71);
                    }
                    else
                    { /* block id: 70 */
                        struct S0 *l_204 = (void*)0;
                        int32_t l_207 = (-6L);
                        (*l_157) = (((((((g_71 != (l_204 == (void*)0)) >= p_44) > (*l_169)) , ((((uint16_t)p_44 << (uint16_t)3) , l_167) == g_124)) == l_207) > l_156) > l_202);
                        (*l_169) = (*g_57);
                        g_57 = func_36((l_207 <= (0x13CE37CCL != 0x2B96CBFFL)));
                        (*l_46) = p_43;
                        /* statement id: 74 */
                        assert (l_47 == &g_3);
                    }
                    (*l_169) = (l_208 != ((&p_43 != (void*)0) , func_36((((int16_t)(((((l_211 || 0x6C37L) > (((uint16_t)((int32_t)((((g_71 ^ (((l_216 != l_217) && ((uint32_t)((p_44 , &l_138) != &g_57) % (uint32_t)(**l_46))) == 0xF5600962L)) || 3L) , p_43) != p_43) % (int32_t)(-1L)) >> (uint16_t)10) | l_175)) | p_44) >= (-4L)) || 0x54FE0FA9L) + (int16_t)l_220) & g_71))));
                }
                (*l_223) = ((uint16_t)(**l_46) >> (uint16_t)1);
            }
        }
        /* facts after for loop */
        assert (l_47 == &g_3 || l_47 == &g_71);
        for (g_83 = 26; (g_83 < 5); g_83 -= 7)
        { /* block id: 83 */
            int32_t l_245 = 0L;
            float *l_247 = &l_200;
            l_245 = ((g_3 == (g_161 != ((((((((uint16_t)1UL << (uint16_t)14) ^ ((int16_t)(((uint16_t)(((int32_t)((((p_44 < ((~g_3) | ((int32_t)(((uint16_t)g_83 + (uint16_t)(**l_46)) != ((uint16_t)((((float)p_44 + (float)((float)((void*)0 != l_216) + (float)g_203)) > 0x0.Fp-1) , g_161) >> (uint16_t)(*l_208))) % (int32_t)l_245))) , l_245) && p_44) , 0x0E2737E1L) - (int32_t)g_161) != 0x9CCD5EB8L) + (uint16_t)0x511DL) & 0xD1BF06ACL) >> (int16_t)6)) <= (*l_47)) & l_245) != 0x7462L) < p_44) || g_161))) || 0L);
            (*l_247) = l_246;
        }
        for (g_71 = 0; (g_71 <= (-28)); g_71 -= 1)
        { /* block id: 89 */
            uint8_t l_250 = 0xD7L;
            (*l_46) = (void*)0;
            /* statement id: 90 */
            assert (l_47 == 0);
            if ((*p_43))
                continue;
            l_250 = (g_161 < g_83);
        }
        /* facts after for loop */
        assert (l_47 == 0 || l_47 == &g_3 || l_47 == &g_71);
    }
    /* facts after branching */
    assert (l_47 == 0 || l_47 == &g_3 || l_47 == &g_71);
    (*l_251) = (*p_43);
    return (*l_251);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_83 g_71 g_68 g_57 g_124
 * writes: g_68 g_71 g_124 g_57
 */
static uint32_t  func_48(int32_t  p_49)
{ /* block id: 19 */
    float *l_67 = &g_68;
    int32_t *l_69 = (void*)0;
    int32_t *l_70 = &g_71;
    float *l_88 = &g_68;
    (*l_67) = p_49;
    (*l_70) = 5L;
    if ((l_67 == (void*)0))
    { /* block id: 22 */
        uint32_t l_75 = 4294967288UL;
        float *l_80 = &g_68;
        int32_t l_86 = 0x07968679L;
        float *l_87 = &g_68;
        float *l_95 = (void*)0;
        int32_t **l_122 = &l_69;
        int32_t **l_123 = (void*)0;
        l_86 = (((+((uint16_t)(l_75 && l_75) % (uint16_t)((uint16_t)(0x94A2L ^ (((uint16_t)((l_80 != (void*)0) == 2UL) << (uint16_t)12) > ((((g_3 > ((uint16_t)(((g_83 == ((uint32_t)(l_75 <= p_49) + (uint32_t)4294967295UL)) != 0xA4EEL) && 1L) >> (uint16_t)g_83)) >= l_75) < p_49) != 1UL))) % (uint16_t)65535UL))) == 1L) | (*l_70));
        (*l_70) = (((p_49 , ((l_87 == l_88) , ((((l_88 != l_70) != ((-(float)(((float)((((!g_3) < (((float)(((g_83 >= (l_95 != l_95)) < p_49) >= g_68) + (float)(*l_70)) <= 0x6.Ap-1)) == p_49) >= p_49) + (float)0xD.2507BCp+77) == p_49)) <= 0x0.FFC2FEp-36)) <= g_68) != p_49))) , p_49) < p_49);
        (*l_70) = ((&l_69 == (((((uint16_t)65529UL << (uint16_t)((((int16_t)((((((int16_t)(-(int32_t)(-(uint16_t)(((int16_t)l_86 << (int16_t)2) != 0x748AADD0L))) + (int16_t)((l_75 <= (((int16_t)((uint32_t)(((((float)(((float)((p_49 != ((float)(((((uint16_t)((uint32_t)(0UL <= (&g_3 == (((int16_t)g_83 << (int16_t)0) , (void*)0))) + (uint32_t)p_49) >> (uint16_t)15) , l_75) < 0x4.4120E7p+39) > g_3) + (float)g_83)) >= g_71) - (float)(*l_70)) >= 0xF.59E040p-61) - (float)g_68) , 0x73401CF6L) , l_122) != l_123) + (uint32_t)4294967294UL) << (int16_t)g_3) || 0L)) , (-1L))) >= p_49) | (*g_57)) ^ p_49) && (*l_70)) + (int16_t)g_3) ^ (*l_70)) ^ 0xB6C63C42L)) && g_3) != g_3) , (void*)0)) || 0UL);
        g_124 = g_124;
    }
    else
    { /* block id: 27 */
        int32_t l_127 = 1L;
        uint32_t l_128 = 1UL;
        (*l_70) = ((uint32_t)g_71 - (uint32_t)p_49);
        if ((0x7166L >= l_127))
        { /* block id: 29 */
            (*l_70) = (*g_57);
            return l_128;
        }
        else
        { /* block id: 32 */
            float l_133 = 0xA.2091CAp-13;
            for (p_49 = (-29); (p_49 < (-9)); p_49++)
            { /* block id: 35 */
                int32_t **l_132 = &g_57;
                (*l_132) = func_36((-(uint16_t)g_71));
                if ((*g_57))
                    break;
                if (l_127)
                    break;
            }
        }
    }
    return (*l_70);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_55(int16_t  p_56)
{ /* block id: 11 */
    int32_t *l_65 = (void*)0;
    for (p_56 = (-9); (p_56 == 4); p_56++)
    { /* block id: 14 */
        int32_t **l_66 = &l_65;
        (*l_66) = l_65;
        (*l_66) = &g_3;
        /* statement id: 16 */
        assert (l_65 == &g_3);
    }
    /* facts after for loop */
    assert (l_65 == &g_3 || l_65 == 0);
    return p_56;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc_bytes (&g_68, sizeof(g_68), "g_68", print_hash_value);
    transparent_crc(g_71, "g_71", print_hash_value);
    transparent_crc(g_83, "g_83", print_hash_value);
    transparent_crc(g_161, "g_161", print_hash_value);
    transparent_crc(g_168.f0, "g_168.f0", print_hash_value);
    transparent_crc_bytes (&g_203, sizeof(g_203), "g_203", print_hash_value);
    transparent_crc(g_301.f0, "g_301.f0", print_hash_value);
    transparent_crc(g_333.f0, "g_333.f0", print_hash_value);
    transparent_crc(g_334.f0, "g_334.f0", print_hash_value);
    transparent_crc(g_405.f0, "g_405.f0", print_hash_value);
    transparent_crc(g_408.f0, "g_408.f0", print_hash_value);
    transparent_crc(g_409.f0, "g_409.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 75
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 5
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 4
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 7

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 23
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 3
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 32, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 89

XXX times a variable address is taken: 82
XXX times a pointer is dereferenced on RHS: 69
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 7
XXX times a pointer is dereferenced on LHS: 41
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 0
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 201

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 179
   level: 2, occurrence: 22
   level: 3, occurrence: 2
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 52
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 18
XXX average alias set size: 1.04

XXX times a non-volatile is read: 452
XXX times a non-volatile is write: 112
XXX times a volatile is read: 14
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 78
XXX percentage of non-volatile access: 97.4

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 90
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 28
   depth: 2, occurrence: 17
   depth: 3, occurrence: 9
   depth: 4, occurrence: 2
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

