/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      717876034
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 15;
   const unsigned f1 : 8;
   float  f2;
   unsigned f3 : 18;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static uint16_t  func_13(uint16_t  p_14, int16_t  p_15, uint32_t  p_16, int32_t  p_17, uint32_t  p_18);
static uint32_t  func_20(int32_t  p_21, uint8_t  p_22, uint16_t  p_23);
static const struct S0  func_27(uint32_t  p_28, uint16_t  p_29, int16_t  p_30, struct S0  p_31, float  p_32);
static int16_t  func_37(uint32_t  p_38);
static struct S0  func_46(int32_t  p_47, float  p_48, uint16_t  p_49, int16_t  p_50, const uint8_t  p_51);
static const struct S0 * func_55(int32_t  p_56);
static const int32_t * func_82(uint16_t * p_83, uint32_t  p_84, uint32_t  p_85, int32_t  p_86, float * p_87);
static uint16_t * func_88(uint8_t  p_89);
static float * func_98(float  p_99, struct S0  p_100, const int32_t  p_101, const int32_t  p_102, uint32_t * p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_4 = 65535UL;
    uint8_t l_749 = 0UL;
    uint8_t *l_748 = &l_749;
    int32_t l_751 = 0L;
    int32_t *l_750 = &l_751;
    int32_t l_753 = (-1L);
    int32_t *l_752 = &l_753;
    int32_t *l_754 = (void*)0;
    int32_t l_755 = 0x41D450EBL;
    int32_t l_757 = 0x6EBC6A1FL;
    int32_t *l_756 = &l_757;
    uint16_t l_758 = 65530UL;
    (*l_756) = (l_755 = ((*l_752) = ((*l_750) = ((uint32_t)(4294967293UL & l_4) % (uint32_t)(+((((int16_t)((uint16_t)65535UL << (uint16_t)14) >> (int16_t)l_4) & ((l_4 , ((*l_748) = ((+((uint16_t)func_13(l_4, ((((0xCD43L < 0L) > 1L) | 0x8AB9C279L) , l_4), l_4, l_4, l_4) - (uint16_t)1UL)) || 0xA69CDAC9L))) , 0x9C13L)) & 0x6B14L))))));
    return l_758;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_13(uint16_t  p_14, int16_t  p_15, uint32_t  p_16, int32_t  p_17, uint32_t  p_18)
{ /* block id: 1 */
    float l_24 = (-0x10.5p-1);
    int32_t l_36 = (-1L);
    float l_52 = 0xD.B93DCEp+90;
    struct S0 l_697 = {69,9,-0x5.Dp-1,125};
    int16_t l_703 = (-1L);
    float *l_728 = (void*)0;
    float *l_729 = &l_697.f2;
    float *l_730 = &l_52;
    uint16_t l_736 = 9UL;
    uint16_t *l_735 = &l_736;
    const int32_t l_741 = 0x9D6C3C25L;
    const int32_t *l_740 = &l_741;
    int32_t *l_743 = &l_36;
    int32_t **l_742 = &l_743;
    float **l_745 = (void*)0;
    float ***l_744 = &l_745;
    float *l_746 = (void*)0;
    int32_t **l_747 = &l_743;
    (*l_730) = ((*l_729) = (((!((p_15 != 0x03B15A8DL) == func_20(p_17, (((uint16_t)((l_703 = ((func_27((+(0xDF2DL || ((((int32_t)(l_36 != (func_37(l_36) , ((int32_t)l_36 % (int32_t)((uint16_t)(((int16_t)func_37((func_46(l_36, l_36, l_36, l_36, p_15) , p_15)) >> (int16_t)15) == 0x12C7353FL) % (uint16_t)l_36)))) - (int32_t)1UL) || 0x203B963CL) | p_16))), p_15, p_18, l_697, p_17) , l_697.f3) && p_18)) >= l_697.f3) >> (uint16_t)4) < p_17), p_18))) <= 4294967287UL) , p_16));
    for (p_17 = (-11); (p_17 == (-12)); p_17 -= 1)
    { /* block id: 288 */
        int32_t *l_734 = (void*)0;
        int32_t **l_733 = &l_734;
        (*l_733) = &l_36;
        if ((**l_733))
            continue;
    }
    (*l_747) = func_82(l_735, (l_697.f0 > ((~((uint16_t)(((l_740 = (void*)0) == ((*l_742) = &l_36)) >= p_17) << (uint16_t)11)) >= ((void*)0 != l_744))), ((p_15 || (-9L)) && 0x6647L), l_736, l_746);
    (*l_742) = (*l_742);
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_20(int32_t  p_21, uint8_t  p_22, uint16_t  p_23)
{ /* block id: 278 */
    uint32_t l_704 = 0xCD167BEFL;
    int32_t l_712 = 0x79F30BDEL;
    int32_t *l_711 = &l_712;
    uint8_t l_713 = 0x56L;
    uint16_t l_724 = 0x136BL;
    uint16_t *l_723 = &l_724;
    int16_t l_725 = 1L;
    float l_727 = 0x0.6p+1;
    float *l_726 = &l_727;
    (*l_711) = ((l_704 ^ (p_22 != (((uint16_t)(((int16_t)(func_46(((int32_t)(-1L) - (int32_t)(((((*l_711) = 2L) != (l_713 | ((uint16_t)((uint32_t)((-(uint32_t)(((uint16_t)(((uint16_t)0x8DFEL >> (uint16_t)p_21) | ((*l_723) = (p_22 == 0xE90DL))) >> (uint16_t)15) >= p_23)) && l_724) + (uint32_t)0x8E234716L) / (uint16_t)p_23))) > (-3L)) , p_22)), l_704, p_23, p_23, l_713) , p_22) - (int16_t)1UL) <= l_713) % (uint16_t)p_22) <= p_22))) <= l_725);
    (*l_726) = (*l_711);
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_27(uint32_t  p_28, uint16_t  p_29, int16_t  p_30, struct S0  p_31, float  p_32)
{ /* block id: 273 */
    int32_t l_699 = 0x5DAF3C90L;
    int32_t *l_698 = &l_699;
    const int32_t *l_701 = &l_699;
    const int32_t **l_700 = &l_701;
    const struct S0 l_702 = {173,10,0x0.Ap-1,304};
    (*l_700) = l_698;
    (*l_698) = (**l_700);
    return l_702;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_37(uint32_t  p_38)
{ /* block id: 2 */
    uint16_t l_39 = 0x72CBL;
    return l_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_46(int32_t  p_47, float  p_48, uint16_t  p_49, int16_t  p_50, const uint8_t  p_51)
{ /* block id: 4 */
    int32_t l_57 = 5L;
    uint32_t ***l_523 = (void*)0;
    int32_t l_561 = 0x4335F50DL;
    uint32_t l_564 = 0x4214D055L;
    uint32_t *l_563 = &l_564;
    uint32_t **l_562 = &l_563;
    uint32_t ***l_575 = (void*)0;
    struct S0 *l_576 = (void*)0;
    int32_t *l_577 = &l_57;
    uint16_t l_587 = 65531UL;
    uint16_t *l_586 = &l_587;
    uint16_t **l_585 = &l_586;
    uint16_t ***l_584 = &l_585;
    uint32_t *l_670 = &l_564;
    struct S0 **l_693 = &l_576;
    struct S0 *l_695 = (void*)0;
    struct S0 **l_694 = &l_695;
    struct S0 l_696 = {68,1,0x0.8p-1,287};
    for (p_49 = 1; (p_49 >= 11); p_49 += 1)
    { /* block id: 7 */
        struct S0 l_520 = {76,1,0x1.EFB8BFp-50,405};
        const struct S0 *l_519 = &l_520;
        uint32_t ****l_524 = (void*)0;
        uint32_t ***l_525 = (void*)0;
        uint32_t l_530 = 0x3975D1D1L;
        int32_t l_544 = (-7L);
        int16_t l_559 = (-9L);
        int32_t l_560 = 0xB75088A4L;
        const int16_t *l_567 = &l_559;
        const int16_t **l_566 = &l_567;
        uint32_t *l_574 = (void*)0;
        uint32_t **l_573 = &l_574;
        uint32_t ***l_572 = &l_573;
        int16_t ***l_581 = (void*)0;
        float *l_682 = &l_520.f2;
        float l_684 = 0x1.Cp+1;
        float *l_683 = &l_684;
        int32_t l_690 = 0x8741D60DL;
        uint32_t l_691 = 0x91246385L;
        int32_t **l_692 = &l_577;
        l_519 = func_55(l_57);
        if (((((((l_520.f1 == l_57) & (p_50 == 5L)) , l_520.f3) != ((int32_t)(l_523 == (l_525 = l_523)) - (int32_t)((uint16_t)0x466EL - (uint16_t)((int16_t)l_520.f3 + (int16_t)l_530)))) & 0UL) , p_50))
        { /* block id: 205 */
            uint8_t l_531 = 0x34L;
            uint16_t l_535 = 0x0D57L;
            uint16_t *l_534 = &l_535;
            uint16_t l_537 = 0x92E3L;
            uint16_t *l_536 = &l_537;
            int16_t l_543 = 0x9F86L;
            int16_t *l_542 = &l_543;
            int32_t *l_558 = &l_544;
            int32_t *l_565 = &l_561;
            int32_t *l_570 = (void*)0;
            int32_t *l_571 = &l_57;
            struct S0 l_604 = {141,0,0x1.7p+1,501};
            uint32_t ***l_618 = &l_573;
            int16_t l_624 = 8L;
            int16_t ****l_643 = &l_581;
            int32_t **l_671 = &l_571;
            p_47 = ((*l_565) = ((3L != ((l_531 = 0x70BE5B72L) > (((p_50 != ((p_50 <= ((*l_536) = ((*l_534) = p_49))) >= ((((uint16_t)((int16_t)((((*l_542) = p_47) | (l_544 = 65532UL)) && ((int16_t)((*l_542) = ((((uint16_t)((int16_t)((l_560 = ((int16_t)(((~((int16_t)(l_543 & (((*l_558) = ((int32_t)(l_520.f3 && l_544) - (int32_t)0x2B90EBF4L)) > l_559)) / (int16_t)l_520.f0)) ^ 1L) || (-1L)) >> (int16_t)l_520.f1)) || l_561) << (int16_t)0) + (uint16_t)9L) , (void*)0) == l_562)) % (int16_t)65535UL)) + (int16_t)l_564) << (uint16_t)11) < l_520.f0) < 0L))) && p_49) , p_49))) ^ p_51));
            if ((((*l_565) = (p_47 > ((void*)0 == l_566))) & (l_544 < (l_57 , ((((int16_t)((((*l_571) = 0xB2BD7356L) >= ((((((((((((-1L) >= (l_572 == l_575)) || l_564) && p_51) , (void*)0) == l_576) , p_50) & p_50) & p_51) == l_559) | p_50) ^ 0x1EECL)) ^ p_49) >> (int16_t)8) , l_57) == l_530)))))
            { /* block id: 218 */
                int16_t **l_579 = &l_542;
                int16_t ***l_578 = &l_579;
                int16_t ****l_580 = (void*)0;
                l_577 = &p_47;
                l_581 = l_578;
            }
            else
            { /* block id: 221 */
                uint32_t l_598 = 0x4C250CD5L;
                if (p_47)
                    break;
                for (l_531 = (-24); (l_531 >= 46); ++l_531)
                { /* block id: 225 */
                    uint16_t ****l_588 = (void*)0;
                    uint16_t ****l_589 = &l_584;
                    int32_t l_601 = 0x69F22C0DL;
                    const uint32_t **l_621 = (void*)0;
                    const uint32_t ***l_620 = &l_621;
                    const uint32_t ****l_619 = &l_620;
                    struct S0 l_622 = {159,12,0x0.5p+1,48};
                    uint32_t ***l_623 = &l_573;
                    (*l_589) = l_584;
                    p_47 = (!((int32_t)p_50 + (int32_t)(-(int32_t)(((((uint32_t)((l_520.f1 != p_49) ^ ((p_49 >= ((((int16_t)p_51 % (int16_t)((l_598 < (((uint16_t)l_601 + (uint16_t)((***l_584) = ((int32_t)(l_604 , p_50) + (int32_t)p_49))) < p_50)) , p_47)) && 0x06514982L) ^ 0L)) | 1UL)) + (uint32_t)p_50) < 0xD160L) , 0L) >= (-6L)))));
                    if (((uint16_t)((((int32_t)((*l_565) = ((*l_577) = ((uint16_t)(((uint16_t)(p_47 != (((uint16_t)(*l_571) / (uint16_t)(l_598 || ((((int16_t)1L / (int16_t)l_601) | (-(uint16_t)(p_51 ^ ((((*l_619) = l_618) != ((l_598 , l_622) , l_623)) >= p_51)))) , (*l_577)))) <= l_624)) + (uint16_t)0x5547L) > l_598) << (uint16_t)9))) - (int32_t)2L) != 0x0DC7L) == l_622.f3) >> (uint16_t)l_520.f3))
                    { /* block id: 232 */
                        if (l_598)
                            break;
                    }
                    else
                    { /* block id: 234 */
                        uint16_t l_641 = 0UL;
                        float *l_642 = &l_622.f2;
                        uint32_t l_648 = 0x1C3FE31FL;
                        int32_t *l_649 = &l_561;
                        (*l_642) = (((float)(((l_598 == ((float)l_622.f1 / (float)0x9.EB82C0p+7)) >= (-0x1.8p+1)) == ((~((int16_t)(((int16_t)((((*l_565) = 0L) < (((int16_t)(-(uint16_t)((l_544 = ((*l_542) = ((((*l_571) = ((((0UL ^ ((uint32_t)p_51 + (uint32_t)((((((*l_534) = 0x89DCL) >= ((int16_t)l_641 + (int16_t)p_50)) || (*l_577)) != 0xD8BC06ADL) > 1UL))) >= l_641) > 0x1E63L) | l_641)) != p_50) < 0x9DF9C07CL))) > 0x2F91L)) - (int16_t)l_598) && 0xB235L)) < l_641) / (int16_t)p_50) <= 0x6C029604L) % (int16_t)l_598)) , p_50)) / (float)0x4.3CD10Ep+88) <= l_520.f1);
                        l_649 = func_98(l_520.f0, (((void*)0 == l_643) , l_604), ((int16_t)(0x8CF0L || (l_520.f0 || ((*l_577) < ((p_49 , ((int32_t)l_648 / (int32_t)p_47)) >= l_559)))) % (int16_t)p_49), l_648, (*l_562));
                    }
                }
                for (l_530 = (-27); (l_530 == 19); l_530 += 1)
                { /* block id: 246 */
                    int16_t l_662 = 0xB85EL;
                    float *l_663 = &l_604.f2;
                    float *l_664 = &l_520.f2;
                    int32_t **l_667 = (void*)0;
                    int32_t **l_668 = (void*)0;
                    int32_t **l_669 = &l_571;
                    (*l_558) = p_50;
                    (*l_664) = ((float)((*l_663) = (((p_49 == ((int16_t)((*l_542) = p_51) >> (int16_t)((int16_t)((int16_t)p_49 << (int16_t)(0L < 1L)) % (int16_t)((int16_t)((p_47 | 0xD109EB59L) & (l_662 && (p_47 == p_47))) << (int16_t)p_47)))) == 0x3AF7C65DL) , (*l_577))) + (float)(*l_577));
                    (*l_664) = ((float)(-0x7.Fp+1) / (float)((*l_663) = (l_560 = (0x6.40F91Fp-74 <= (*l_571)))));
                    (*l_669) = &p_47;
                }
            }
            (*l_671) = func_98(p_48, l_604, l_520.f1, l_544, l_670);
        }
        else
        { /* block id: 258 */
            struct S0 l_672 = {1,2,0x0.Ep+1,308};
            return l_672;
        }
        (*l_692) = (((float)(l_520.f3 < ((*l_577) == ((float)((((((float)((float)(-(float)((((((((*l_682) = 0xF.BD5C51p-31) < (l_544 = ((*l_683) = p_48))) <= (((+(l_691 = ((float)(l_690 = ((((((float)p_51 / (float)((l_560 = (l_530 < (*l_577))) <= (p_50 == ((l_520.f3 >= p_48) == p_50)))) < (*l_577)) , (void*)0) == (*l_572)) > 0xA.E3D7CFp-77)) + (float)p_51))) , p_49) != (*l_577))) < 0x7.B07859p+99) <= p_50) != p_51) <= 0x0.2p-1)) - (float)(*l_577)) + (float)(-0x6.9p+1)) <= (-0x1.7p+1)) == (-0x1.Dp-1)) != p_50) >= l_520.f3) + (float)(*l_577)))) + (float)0xB.ED9EEBp+65) , &l_57);
    }
    (*l_694) = ((*l_693) = l_576);
    (*l_577) = ((*l_577) || (*l_577));
    return l_696;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0 * func_55(int32_t  p_56)
{ /* block id: 8 */
    float l_65 = 0x0.3p+1;
    float *l_64 = &l_65;
    uint16_t l_69 = 0x0555L;
    uint16_t *l_68 = &l_69;
    int32_t l_70 = 0xDC29BFBDL;
    uint32_t l_72 = 3UL;
    uint32_t *l_71 = &l_72;
    int32_t l_77 = 0xD979388BL;
    int32_t l_78 = 0xF33464EBL;
    int32_t *l_79 = &l_70;
    float l_81 = 0x0.Ap-1;
    float *l_80 = &l_81;
    float *l_250 = &l_81;
    int32_t **l_261 = (void*)0;
    int32_t **l_262 = (void*)0;
    int32_t **l_263 = (void*)0;
    int32_t **l_264 = &l_79;
    const uint32_t l_267 = 18446744073709551615UL;
    uint16_t l_282 = 1UL;
    struct S0 l_322 = {148,6,0xC.6902E5p+61,461};
    const struct S0 *l_321 = &l_322;
    uint32_t **l_325 = &l_71;
    uint32_t ***l_324 = &l_325;
    float l_326 = 0xC.E6405Bp+66;
    int32_t l_357 = 0x95A8140EL;
    const int16_t l_422 = (-2L);
    const struct S0 *l_508 = &l_322;
    int32_t ***l_515 = &l_263;
    int32_t ****l_514 = &l_515;
    const struct S0 *l_516 = &l_322;
    const struct S0 *l_517 = &l_322;
    const struct S0 *l_518 = (void*)0;
    (*l_80) = (p_56 > ((float)((float)p_56 + (float)((float)(((*l_64) = 0x3.49A2DDp+43) >= 0x7.7E410Fp-37) - (float)p_56)) / (float)(((*l_79) = ((uint32_t)(((*l_68) = p_56) == (((*l_71) = l_70) ^ (l_78 = ((int32_t)p_56 + (int32_t)(l_77 = (((int32_t)p_56 / (int32_t)l_70) && 65527UL)))))) / (uint32_t)p_56)) , (*l_79))));
    return l_518;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_82(uint16_t * p_83, uint32_t  p_84, uint32_t  p_85, int32_t  p_86, float * p_87)
{ /* block id: 95 */
    int32_t *l_252 = (void*)0;
    int32_t **l_251 = &l_252;
    const int32_t l_254 = 0L;
    const int32_t *l_253 = &l_254;
    const int32_t *l_255 = &l_254;
    const int32_t *l_256 = &l_254;
    const int32_t *l_257 = &l_254;
    const int32_t *l_258 = &l_254;
    const int32_t *l_259 = &l_254;
    const int32_t *l_260 = (void*)0;
    (*l_251) = &p_86;
    return l_260;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t * func_88(uint8_t  p_89)
{ /* block id: 17 */
    int32_t l_93 = 0x192EEDB0L;
    int32_t *l_92 = &l_93;
    uint32_t l_95 = 1UL;
    uint32_t *l_94 = &l_95;
    const uint16_t l_97 = 0xBB1EL;
    const uint16_t *l_96 = &l_97;
    struct S0 l_104 = {35,10,0x8.9F3DF3p-65,294};
    uint32_t *l_116 = (void*)0;
    uint32_t l_118 = 0xC9E84290L;
    uint32_t *l_117 = &l_118;
    uint32_t l_120 = 9UL;
    uint32_t *l_119 = &l_120;
    uint32_t l_122 = 0x41CECC2FL;
    uint32_t *l_121 = &l_122;
    int32_t *l_123 = (void*)0;
    int32_t l_125 = (-8L);
    int32_t *l_124 = &l_125;
    uint32_t l_127 = 0UL;
    uint32_t *l_126 = &l_127;
    int32_t l_132 = (-1L);
    struct S0 *l_137 = (void*)0;
    uint32_t *l_151 = &l_127;
    const uint32_t l_166 = 18446744073709551614UL;
    uint16_t l_192 = 1UL;
    uint16_t *l_191 = &l_192;
    int16_t l_237 = 0x0E20L;
    int16_t *l_236 = &l_237;
    uint32_t l_238 = 0xA250B377L;
    const int32_t l_239 = 7L;
    int16_t l_241 = 4L;
    int16_t *l_240 = &l_241;
    uint16_t *l_242 = &l_192;
    uint16_t *l_243 = (void*)0;
    return l_243;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_98(float  p_99, struct S0  p_100, const int32_t  p_101, const int32_t  p_102, uint32_t * p_103)
{ /* block id: 20 */
    int32_t l_105 = 0x94B961ACL;
    const int32_t *l_108 = (void*)0;
    float l_110 = 0xF.1B313Cp-67;
    float *l_109 = &l_110;
    float *l_111 = &l_110;
    float *l_112 = &l_110;
    float *l_113 = &l_110;
    float *l_114 = &l_110;
    float *l_115 = (void*)0;
    for (l_105 = 0; (l_105 > (-7)); --l_105)
    { /* block id: 23 */
        l_108 = &p_102;
    }
    return l_115;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 160
   depth: 1, occurrence: 14
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 33
breakdown:
   indirect level: 0, occurrence: 14
   indirect level: 1, occurrence: 19
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 19
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 56

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 8
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1
   depth: 37, occurrence: 1
   depth: 38, occurrence: 2

XXX total number of pointers: 225

XXX times a variable address is taken: 201
XXX times a pointer is dereferenced on RHS: 49
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 9
XXX times a pointer is dereferenced on LHS: 133
breakdown:
   depth: 1, occurrence: 126
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 559

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 261
   level: 2, occurrence: 56
   level: 3, occurrence: 2
XXX number of pointers point to pointers: 86
XXX number of pointers point to scalars: 118
XXX number of pointers point to structs: 21
XXX percent of pointers has null in alias set: 27.6
XXX average alias set size: 1.13

XXX times a non-volatile is read: 700
XXX times a non-volatile is write: 335
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 50
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 6
   depth: 2, occurrence: 4
   depth: 3, occurrence: 5
   depth: 4, occurrence: 7
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 11
XXX percentage an existing variable is used: 89
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

