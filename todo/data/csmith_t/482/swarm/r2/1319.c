/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1317420
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 4;
   signed f1 : 9;
   uint32_t  f2;
   unsigned f3 : 23;
   unsigned f4 : 10;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const int16_t  func_33(void);
static struct S0 * func_34(const struct S0 * p_35, struct S0  p_36);
static struct S0 * func_37(struct S0 * p_38, int32_t  p_39, struct S0 * p_40, struct S0 * p_41);
static struct S0 * func_42(int16_t  p_43);
static const struct S0  func_52(int32_t  p_53);
static int32_t  func_54(float * p_55);
static int32_t  func_68(float * const  p_69, struct S0 * p_70);
static int16_t  func_78(float  p_79);
static float  func_82(int32_t  p_83, int16_t  p_84, int16_t  p_85, const struct S0 * p_86);
static int16_t  func_87(int32_t  p_88, float * p_89, int16_t  p_90, const int16_t  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_33(void)
{ /* block id: 36 */
    float l_44 = 0xE.DB6084p-21;
    int32_t l_45 = 0xDEC995F7;
    struct S0 l_520 = {-0,-17,0x38C4A002,684,15};
    struct S0 *l_519 = &l_520;
    const int32_t **l_541 = (void*)0;
    int32_t **l_542 = (void*)0;
    int32_t *l_544 = &l_45;
    int32_t **l_543 = &l_544;
    const int16_t l_545 = 0xDB58;
    l_519 = func_34(func_37(func_42(l_45), l_45, l_519, &l_520), func_52((safe_add_func_int16_t_s_s(l_520.f1, l_520.f3))));
    /* statement id: 318 */
    assert (l_519 == 0);
    l_520 = l_520;
    (*l_543) = &l_45;
    return l_545;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_34(const struct S0 * p_35, struct S0  p_36)
{ /* block id: 315 */
    struct S0 l_527 = {0,11,0xD9BE2302,2806,30};
    struct S0 *l_528 = &l_527;
    struct S0 *l_529 = &l_527;
    struct S0 *l_530 = &l_527;
    struct S0 *l_531 = &l_527;
    struct S0 *l_532 = &l_527;
    struct S0 *l_533 = &l_527;
    struct S0 *l_534 = &l_527;
    struct S0 *l_535 = &l_527;
    struct S0 *l_536 = &l_527;
    struct S0 *l_537 = &l_527;
    struct S0 *l_538 = &l_527;
    struct S0 *l_539 = &l_527;
    struct S0 *l_540 = (void*)0;
    l_527 = func_52(p_36.f1);
    return l_540;
    /* statement id: 317 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_37(struct S0 * p_38, int32_t  p_39, struct S0 * p_40, struct S0 * p_41)
{ /* block id: 312 */
    const struct S0 **l_521 = (void*)0;
    struct S0 l_524 = {-3,14,0x45A5F23C,1219,5};
    struct S0 *l_523 = &l_524;
    struct S0 **l_522 = &l_523;
    (*l_522) = p_38;
    /* statement id: 313 */
    assert (l_523 == 0);
    return p_40;
    /* statement id: 314 */
    //assert (func_37_rv == &l_520);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_42(int16_t  p_43)
{ /* block id: 37 */
    struct S0 l_49 = {-0,20,3U,564,11};
    struct S0 *l_48 = &l_49;
    float l_51 = 0xD.07C1ABp+36;
    float *l_50 = &l_51;
    float *l_56 = (void*)0;
    float l_396 = (-0x3.6p-1);
    struct S0 **l_456 = &l_48;
    struct S0 ***l_455 = &l_456;
    struct S0 *l_513 = &l_49;
    struct S0 *l_514 = &l_49;
    struct S0 *l_515 = &l_49;
    struct S0 *l_516 = &l_49;
    struct S0 *l_517 = &l_49;
    struct S0 *l_518 = (void*)0;
    (*l_50) = ((safe_mul_func_float_f_f((p_43 <= __builtin_ffs(p_43)), 0xC.F39281p+13)) != (l_48 == (l_49.f1 , (void*)0)));
    (*l_48) = (p_43 , func_52(func_54(l_56)));
    if ((p_43 && (((65535U < l_49.f4) , p_43) | 65531U)))
    { /* block id: 229 */
        int32_t l_391 = 6;
        int32_t *l_390 = &l_391;
        int32_t **l_392 = &l_390;
        (*l_392) = l_390;
    }
    else
    { /* block id: 231 */
        int32_t l_395 = 1;
        float *l_399 = &l_51;
        const uint32_t l_400 = 0xCFFACD87;
        struct S0 *l_402 = &l_49;
        int32_t l_406 = 0x151541BC;
        struct S0 **l_424 = &l_402;
        struct S0 ***l_423 = &l_424;
        int32_t *l_442 = &l_395;
        uint16_t l_493 = 6U;
        int32_t *l_512 = &l_406;
        if ((((func_87(((safe_mul_func_int16_t_s_s((((l_50 == l_50) , __builtin_clzll(__builtin_popcountl(p_43))) & l_395), (p_43 > (((safe_lshift_func_uint16_t_u_u(l_49.f2, 15)) < (7U || 0x5AC691DC)) != l_395)))) ^ p_43), l_399, l_395, l_400) | l_49.f3) || l_49.f0) || l_49.f3))
        { /* block id: 232 */
            int32_t l_401 = 0xD4290D7A;
            (*l_48) = func_52(func_78(l_401));
        }
        else
        { /* block id: 234 */
            struct S0 **l_403 = &l_48;
            (*l_48) = func_52(p_43);
            (*l_399) = (-0x1.3p+1);
            (*l_403) = l_402;
        }
        if ((safe_rshift_func_uint16_t_u_s(((l_406 , (safe_add_func_int32_t_s_s((safe_mul_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((((((*l_402) , l_49.f1) , l_49.f0) , p_43) ^ 0x6D4BF3CD), 12)), p_43)), p_43))) & (safe_mul_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((safe_mul_func_int16_t_s_s(l_395, l_406)), p_43)), l_400))), p_43)))
        { /* block id: 239 */
            int16_t l_437 = 0x5E85;
            int32_t *l_441 = &l_406;
            struct S0 *l_447 = (void*)0;
            struct S0 *l_469 = (void*)0;
            for (l_406 = 0; (l_406 == (-15)); --l_406)
            { /* block id: 242 */
                int32_t *l_422 = (void*)0;
                int32_t **l_421 = &l_422;
                struct S0 ****l_425 = (void*)0;
                struct S0 ****l_426 = &l_423;
                (*l_421) = l_50;
                /* statement id: 243 */
                assert (l_422 == &l_51);
                (*l_426) = l_423;
            }
            if (p_43)
            { /* block id: 246 */
                uint32_t l_433 = 0x21E9CE88;
                int32_t l_440 = (-5);
                int32_t **l_444 = &l_441;
                int32_t ***l_443 = &l_444;
                int32_t ****l_445 = &l_443;
                (**l_424) = (*l_48);
                (*l_50) = (safe_add_func_float_f_f((0x4.8358FCp+38 <= p_43), p_43));
                if (((l_49.f2 == (((safe_add_func_uint32_t_u_u((safe_mul_func_int16_t_s_s((p_43 , __builtin_bswap64(l_433)), p_43)), l_49.f2)) != (((l_49.f3 | p_43) , (safe_mod_func_int32_t_s_s(((((p_43 > p_43) == l_406) , p_43) , 0), 0xCED354EF))) >= 2)) , (-1))) > p_43))
                { /* block id: 249 */
                    int32_t *l_439 = (void*)0;
                    int32_t **l_438 = &l_439;
                    if (p_43)
                    { /* block id: 250 */
                        struct S0 *l_436 = (void*)0;
                        (**l_423) = l_436;
                        /* statement id: 251 */
                        assert (l_402 == 0);
                        return l_436;
                        /* statement id: 252 */
                        //assert (func_42_rv == 0);
                    }
                    else
                    { /* block id: 253 */
                        (*l_50) = l_437;
                    }
                    (*l_438) = l_56;
                }
                else
                { /* block id: 257 */
                    l_440 = l_400;
                    l_442 = l_441;
                    /* statement id: 259 */
                    assert (l_442 == &l_406);
                }
                /* facts after branching */
                assert (l_442 == &l_406 || l_442 == &l_395);
                (*l_445) = l_443;
            }
            else
            { /* block id: 262 */
                struct S0 *l_446 = &l_49;
                return l_447;
                /* statement id: 263 */
                //assert (func_42_rv == 0);
            }
            /* facts after branching */
            assert (l_442 == &l_406 || l_442 == &l_395);
            for (l_437 = 7; (l_437 > 24); l_437 = safe_add_func_int32_t_s_s(l_437, 9))
            { /* block id: 267 */
                uint32_t l_452 = 0x67F1F358;
                int32_t *l_457 = &l_395;
                struct S0 l_464 = {1,-4,4294967290U,748,16};
                struct S0 *l_468 = &l_49;
                if ((((safe_mul_func_float_f_f(((((*l_48) , (-0x1.1p+1)) > l_452) < (safe_mul_func_float_f_f(((void*)0 == l_455), l_452))), l_452)) , &l_406) != l_457))
                { /* block id: 268 */
                    const int32_t *l_459 = (void*)0;
                    const int32_t **l_458 = &l_459;
                    const struct S0 *l_462 = &l_49;
                    (*l_458) = l_457;
                    /* statement id: 269 */
                    assert (l_459 == &l_395);
                    for (l_395 = 14; (l_395 < 29); l_395 = safe_add_func_int16_t_s_s(l_395, 1))
                    { /* block id: 272 */
                        struct S0 **l_463 = &l_447;
                        (*l_463) = l_462;
                        /* statement id: 273 */
                        assert (l_447 == &l_49);
                    }
                    if (p_43)
                        break;
                    (*l_402) = l_464;
                }
                else
                { /* block id: 277 */
                    (*l_399) = p_43;
                }
                for (l_452 = 0; (l_452 != 51); l_452 = safe_add_func_uint32_t_u_u(l_452, 1))
                { /* block id: 282 */
                    struct S0 *l_467 = &l_49;
                    if ((*l_441))
                        break;
                    return l_469;
                    /* statement id: 284 */
                    //assert (func_42_rv == 0);
                }
            }
            /* facts after for loop */
            assert (l_447 == &l_49 || l_447 == 0);
        }
        else
        { /* block id: 287 */
            struct S0 l_470 = {1,16,0U,629,11};
            (***l_423) = l_470;
            for (l_49.f2 = 0; (l_49.f2 < 31); l_49.f2 = safe_add_func_uint16_t_u_u(l_49.f2, 3))
            { /* block id: 291 */
                int32_t **l_473 = (void*)0;
                int32_t **l_474 = &l_442;
                float *l_486 = &l_396;
                struct S0 ****l_492 = &l_455;
                struct S0 *****l_491 = &l_492;
                (*l_474) = l_56;
                /* statement id: 292 */
                assert (l_442 == 0);
                for (p_43 = 0; (p_43 != 3); p_43 = safe_add_func_int32_t_s_s(p_43, 3))
                { /* block id: 295 */
                    struct S0 *l_478 = &l_470;
                    struct S0 ***l_481 = &l_456;
                    int32_t l_482 = 0;
                    (*l_399) = (-0x6.8F05BCp+45);
                    l_478 = (*l_456);
                    /* statement id: 297 */
                    assert (l_478 == &l_49);
                    for (l_470.f2 = 0; (l_470.f2 != 6); l_470.f2 = safe_add_func_uint32_t_u_u(l_470.f2, 1))
                    { /* block id: 300 */
                        struct S0 ***l_483 = &l_424;
                        (*l_486) = ((((void*)0 == l_481) , func_78((l_482 == (((l_483 == ((safe_sub_func_int16_t_s_s(p_43, ((p_43 && l_49.f2) <= 0x39F880B6))) , (**l_491))) , (-0x6.Dp-1)) <= 0x8.C701A7p+0)))) , p_43);
                        if (l_493)
                            break;
                        (*l_486) = p_43;
                    }
                }
                l_470.f0 = l_49.f4;
            }
            /* facts after for loop */
            assert (l_442 == 0 || l_442 == &l_395);
        }
        /* facts after branching */
        assert (l_442 == 0 || l_442 == &l_395 || l_442 == &l_406);
        (*l_512) = (func_54(l_399) && __builtin_ffs((p_43 , (safe_unary_minus_func_uint16_t_u((safe_mul_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(0x4F68, __builtin_clzll((safe_add_func_uint32_t_u_u(l_49.f4, (((safe_add_func_uint16_t_u_u(func_78((p_43 <= (safe_mul_func_float_f_f((!(safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_add_func_float_f_f((((p_43 == (&l_423 == &l_423)) <= 0xB.2961FFp+75) != p_43), p_43)), p_43)), 0x2.1p+1))), (-0x4.Cp-1))))), 1U)) && p_43) <= p_43)))))) & p_43), p_43)))))));
    }
    return l_518;
    /* statement id: 311 */
    //assert (func_42_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_52(int32_t  p_53)
{ /* block id: 180 */
    int32_t *****l_287 = (void*)0;
    int32_t l_292 = 0x567D7ABB;
    int32_t *l_291 = &l_292;
    int32_t * const *l_290 = &l_291;
    int32_t * const **l_289 = &l_290;
    int32_t * const ***l_288 = &l_289;
    float l_294 = 0x5.B55F37p+80;
    float *l_293 = &l_294;
    float l_299 = 0x8.4F099Cp-42;
    uint32_t l_305 = 0xF59FAD49;
    struct S0 l_322 = {1,-14,0xF7D0461C,2693,15};
    struct S0 *l_321 = &l_322;
    struct S0 **l_320 = &l_321;
    struct S0 ***l_319 = &l_320;
    struct S0 *** const *l_318 = &l_319;
    const struct S0 l_389 = {-0,4,0U,2347,25};
    (*l_293) = (safe_sub_func_float_f_f(((p_53 , l_287) == l_287), (p_53 > func_78((l_288 != (void*)0)))));
    if ((((safe_mul_func_uint16_t_u_u((1U ^ ((p_53 > (safe_mod_func_int32_t_s_s((-1), 1))) , (****l_288))), __builtin_bswap64((***l_289)))) <= __builtin_parityll((((**l_288) != (*l_289)) , (**l_290)))) && (*l_291)))
    { /* block id: 182 */
        float *l_302 = (void*)0;
        int32_t l_303 = 1;
        int32_t *l_308 = (void*)0;
        int32_t **l_309 = &l_291;
        struct S0 l_310 = {0,-13,4294967295U,1275,16};
        struct S0 *l_311 = &l_310;
        (*l_293) = (0x0.BC850Ep-55 > (p_53 == ((func_87((safe_sub_func_int16_t_s_s(0x3A71, p_53)), l_302, (9U == l_303), (((func_78(((-(-0x5.Bp-1)) == p_53)) , l_303) | l_303) > l_303)) , l_305) < 0x7.A160B6p-43)));
        (*l_293) = (safe_sub_func_float_f_f(p_53, p_53));
        (*l_309) = l_308;
        /* statement id: 185 */
        assert (l_291 == 0);
        (*l_311) = l_310;
    }
    else
    { /* block id: 187 */
        struct S0 l_313 = {-0,-16,0xC05E57BF,2132,5};
        struct S0 *l_317 = &l_313;
        struct S0 **l_316 = &l_317;
        struct S0 ***l_315 = &l_316;
        struct S0 ****l_314 = &l_315;
        float *l_327 = &l_294;
        int16_t l_338 = (-1);
        float *l_340 = (void*)0;
        int32_t *l_360 = &l_292;
        if ((*l_291))
        { /* block id: 188 */
            float l_312 = 0x0.0p-1;
            (**l_290) = 0x39FE8C37;
            (*l_291) = ((l_313 , 1) == ((l_313.f4 , l_314) != l_318));
        }
        else
        { /* block id: 191 */
            float *l_328 = &l_294;
            struct S0 *****l_329 = &l_314;
            int32_t l_353 = 0x90647940;
            const int32_t **l_387 = (void*)0;
            if (((safe_mul_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(func_87((p_53 , func_54(l_327)), l_328, ((p_53 || (-1)) > 65535U), (p_53 >= (&l_318 != l_329))), 0x26E5)), 0x788F)) ^ p_53))
            { /* block id: 192 */
                int32_t l_335 = 1;
                float *l_359 = &l_294;
                int32_t l_376 = 5;
                int32_t **l_379 = &l_291;
                for (l_305 = (-6); (l_305 >= 55); l_305 = safe_add_func_int32_t_s_s(l_305, 6))
                { /* block id: 195 */
                    float *l_339 = &l_299;
                    int32_t l_351 = (-10);
                    struct S0 l_352 = {3,9,7U,2567,25};
                    (**l_329) = (**l_329);
                    if (__builtin_clzl((~(((((***l_329) != (***l_329)) , 0x1448ED9A) == 1U) && (func_54(l_328) != (safe_mul_func_uint16_t_u_u(65527U, (((*l_291) & l_335) ^ 65535U))))))))
                    { /* block id: 197 */
                        struct S0 ****l_354 = &l_315;
                        (***l_289) = (safe_lshift_func_int16_t_s_u(((p_53 | l_338) && (((((l_313.f1 == ((((-0x1.Cp+1) != ((l_339 == l_340) == (safe_add_func_float_f_f((safe_mul_func_float_f_f((**l_290), (safe_mul_func_float_f_f(((safe_sub_func_float_f_f((((safe_mod_func_int16_t_s_s(__builtin_ia32_crc32qi(l_351, (l_352 , l_353)), p_53)) , &l_353) != (void*)0), l_352.f3)) > 0x2.7DD560p+67), l_353)))), 0x6.7p+1)))) > p_53) > (*l_291))) , 4) , l_354) != (void*)0) ^ p_53)), 3));
                        (*l_293) = ((p_53 , (safe_mul_func_float_f_f((safe_sub_func_float_f_f(l_335, (0xC.4CC767p+14 >= p_53))), (0x7.80E587p-48 > __builtin_parityl(l_313.f4))))) < func_54(l_359));
                        (*l_317) = (****l_354);
                        (***l_289) = l_353;
                    }
                    else
                    { /* block id: 202 */
                        (*l_320) = (void*)0;
                        /* statement id: 203 */
                        assert (l_321 == 0);
                        l_360 = &l_351;
                        /* statement id: 204 */
                        assert (l_360 == &l_351);
                    }
                    /* facts after branching */
                    //assert (l_360 == &l_351 || l_360 == dangling || l_360 == &l_292);
                }
                /* facts after for loop */
                assert (l_321 == 0 || l_321 == &l_322);
                //assert (l_360 == dangling || l_360 == &l_292);
                (*l_379) = &l_376;
                /* statement id: 213 */
                assert (l_291 == &l_376);
            }
            else
            { /* block id: 214 */
                uint32_t l_380 = 4294967287U;
                (**l_316) = (****l_318);
                (*l_360) = l_380;
            }
            /* facts after branching */
            //assert (l_291 == &l_292 || l_291 == dangling);
            assert (l_321 == 0 || l_321 == &l_322);
            //assert (l_360 == dangling || l_360 == &l_292);
            for (l_338 = (-17); (l_338 <= (-20)); l_338 = safe_sub_func_uint16_t_u_u(l_338, 1))
            { /* block id: 220 */
                int32_t *l_388 = &l_353;
                if (p_53)
                    break;
                (*l_388) = (0xE9B0BE5C == (p_53 == ((safe_lshift_func_int16_t_s_u(l_353, (safe_rshift_func_int16_t_s_u((((-3) > p_53) , l_313.f2), 14)))) <= (((void*)0 == l_387) , (0x7CC21128 && p_53)))));
            }
        }
        /* facts after branching */
        //assert (l_291 == &l_292 || l_291 == dangling);
        assert (l_321 == 0 || l_321 == &l_322);
        //assert (l_360 == dangling || l_360 == &l_292);
    }
    /* facts after branching */
    //assert (l_291 == &l_292 || l_291 == dangling || l_291 == 0);
    assert (l_321 == 0 || l_321 == &l_322);
    l_322.f1 = p_53;
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_54(float * p_55)
{ /* block id: 39 */
    float l_62 = 0xA.01153Ap-46;
    int32_t l_65 = 0x1F73E702;
    struct S0 l_72 = {2,18,0x0DEBF624,606,17};
    struct S0 *l_71 = &l_72;
    int16_t l_282 = 0x0F99;
    int32_t *l_283 = &l_65;
    uint16_t l_284 = 9U;
    (*l_283) = (safe_mod_func_uint32_t_u_u(((~(safe_mul_func_int16_t_s_s((l_62 , (((safe_sub_func_uint32_t_u_u((1U | 9U), ((l_65 || (safe_add_func_int32_t_s_s(__builtin_clzll(((func_68(p_55, l_71) ^ ((safe_sub_func_uint32_t_u_u((safe_mod_func_int16_t_s_s((l_72.f1 == 0x5AAB), (-4))), l_72.f4)) & l_72.f2)) , l_72.f2)), 7U))) >= 0x2D2A8B1A))) && l_72.f3) | l_72.f2)), 9))) <= l_72.f1), l_282));
    (*l_71) = (*l_71);
    return l_284;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_68(float * const  p_69, struct S0 * p_70)
{ /* block id: 40 */
    uint16_t l_73 = 0x9758;
    const int32_t l_94 = 0x152D5F2A;
    float *l_95 = (void*)0;
    struct S0 l_240 = {3,-7,0U,2714,26};
    const struct S0 *l_239 = &l_240;
    if ((0x4207 || ((((l_73 ^ 0xDD571B4D) >= ((((((((((safe_lshift_func_int16_t_s_u((l_73 && ((__builtin_parityl((l_73 , (l_73 < (safe_rshift_func_int16_t_s_s((func_78((safe_sub_func_float_f_f((func_82(l_73, l_73, func_87(((safe_mul_func_uint16_t_u_u(l_73, l_73)) <= l_94), l_95, l_73, l_94), l_239) <= l_94), l_94))) <= 0x46FB), l_73))))) > l_94) , l_94)), l_73)) > 1) > l_240.f1) && l_240.f0) , 4294967292U) == l_240.f3) < l_240.f0) & l_94) < (-3)) != 1U)) <= 0x49294EA2) > l_240.f0)))
    { /* block id: 169 */
        float l_274 = 0xE.F38C47p-74;
        float *l_273 = &l_274;
        (*l_273) = func_78(l_240.f2);
        (*l_273) = (((*p_70) , (l_94 == 0x2.0EBDD8p-58)) <= 0x2.E9F7C0p+67);
        return l_240.f2;
    }
    else
    { /* block id: 173 */
        struct S0 ***l_277 = (void*)0;
        struct S0 *** const *l_276 = &l_277;
        struct S0 *** const **l_275 = &l_276;
        l_275 = (l_73 , (void*)0);
        /* statement id: 174 */
        assert (l_275 == 0);
        return l_73;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_78(float  p_79)
{ /* block id: 156 */
    int32_t l_245 = 0x41C906F2;
    float l_259 = 0x4.E7146Cp+15;
    float * const l_258 = &l_259;
    struct S0 l_261 = {-2,-11,3U,99,4};
    struct S0 ***l_262 = (void*)0;
    int32_t *l_269 = &l_245;
    int32_t **l_268 = &l_269;
    uint16_t l_272 = 1U;
    if (((l_245 , (((safe_add_func_uint16_t_u_u((((((((-0x8.Bp-1) == l_245) == 0xD.4737F3p+78) , l_245) , (((safe_sub_func_float_f_f(l_245, ((((l_245 != ((l_245 >= l_245) <= 0x6.0CC650p-95)) , l_245) == p_79) > l_245))) == 0x4.7B7656p+4) , (void*)0)) != &l_245) && l_245), l_245)) , 0x58BB) , l_245)) || l_245))
    { /* block id: 157 */
        struct S0 *l_250 = (void*)0;
        struct S0 **l_251 = (void*)0;
        struct S0 **l_252 = &l_250;
        int32_t l_260 = (-1);
        float l_263 = 0x7.885BBEp-83;
        int32_t *l_264 = (void*)0;
        int32_t **l_265 = &l_264;
        (*l_252) = l_250;
        l_245 = ((0xC4FDDAEB | (safe_add_func_uint16_t_u_u(((safe_unary_minus_func_int32_t_s((((safe_sub_func_uint16_t_u_u((((void*)0 != l_258) == __builtin_ctzll(l_260)), (l_245 , (&l_252 == (((l_261 , l_261.f0) > l_260) , l_262))))) , 0x67926D8D) | l_260))) || l_260), 0x6B9F))) , l_260);
        (*l_252) = (*l_252);
        (*l_265) = &l_260;
        /* statement id: 161 */
        assert (l_264 == &l_260);
    }
    else
    { /* block id: 162 */
        struct S0 ****l_266 = &l_262;
        struct S0 *****l_267 = &l_266;
        (*l_267) = l_266;
    }
    (*l_268) = &l_245;
    (*l_258) = (__builtin_popcountll(((**l_268) , ((**l_268) && (**l_268)))) < ((safe_add_func_float_f_f(0xB.9F7DF0p+72, (**l_268))) < p_79));
    (*l_258) = (*l_269);
    return l_272;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_82(int32_t  p_83, int16_t  p_84, int16_t  p_85, const struct S0 * p_86)
{ /* block id: 148 */
    float l_242 = 0x1.Bp-1;
    float *l_241 = &l_242;
    (*l_241) = 0x3.Cp+1;
    for (p_83 = 0; (p_83 >= 22); p_83 = safe_add_func_int32_t_s_s(p_83, 1))
    { /* block id: 152 */
        if (p_84)
            break;
    }
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_87(int32_t  p_88, float * p_89, int16_t  p_90, const int16_t  p_91)
{ /* block id: 41 */
    uint32_t l_98 = 7U;
    int32_t *l_109 = (void*)0;
    float l_115 = 0xF.CD67D5p+59;
    float *l_114 = &l_115;
    struct S0 l_152 = {1,3,4294967295U,2234,4};
    uint32_t l_232 = 2U;
    struct S0 *l_237 = &l_152;
    int32_t **l_238 = &l_109;
    for (p_88 = 0; (p_88 <= (-27)); --p_88)
    { /* block id: 44 */
        int32_t l_99 = (-5);
        int32_t *l_107 = (void*)0;
        int32_t *l_108 = &l_99;
        int32_t **l_110 = (void*)0;
        int32_t **l_111 = &l_108;
        (*l_108) = (((l_98 != ((l_99 , ((safe_mul_func_uint16_t_u_u((__builtin_ffsl(l_99) == ((((((l_99 < __builtin_ffs(__builtin_ia32_crc32qi(p_91, (__builtin_popcountll((safe_unary_minus_func_int16_t_s(((safe_lshift_func_int16_t_s_u((safe_mod_func_int16_t_s_s((l_99 , l_98), l_98)), l_98)) == p_90)))) && p_91)))) > l_98) , l_98) < p_91) , l_98) < p_91)), p_90)) && p_91)) && 1)) > p_90) && 0x13769207);
        (*l_111) = l_109;
        /* statement id: 46 */
        assert (l_108 == 0);
    }
    if (((l_109 == l_109) ^ p_91))
    { /* block id: 48 */
        float l_113 = 0x1.Cp+1;
        float *l_112 = &l_113;
        int32_t l_132 = (-1);
        struct S0 l_195 = {-1,13,1U,413,19};
        int32_t **l_208 = &l_109;
        if (((l_112 == l_114) || 0x0C119CD2))
        { /* block id: 49 */
            int32_t **l_116 = (void*)0;
            int32_t **l_117 = &l_109;
            (*l_117) = p_89;
            /* statement id: 50 */
            //assert (l_109 == 0 || l_109 == &l_294 || l_109 == &l_51);
        }
        else
        { /* block id: 51 */
            int32_t l_122 = 0xA48933AC;
            struct S0 l_136 = {-2,-21,0x89C8F7CE,1419,11};
            int32_t *l_165 = &l_132;
            if (((p_89 == (((safe_mul_func_uint16_t_u_u((__builtin_ctz((((safe_sub_func_uint32_t_u_u(l_122, ((((safe_add_func_uint16_t_u_u(p_91, (l_122 , (safe_sub_func_int32_t_s_s(l_122, l_122))))) , 0xD4C97A61) || (1 > (safe_sub_func_int16_t_s_s(((__builtin_popcountl((safe_mod_func_int16_t_s_s((~__builtin_parityll((0xF431 <= p_88))), p_88))) , 0x840C) , l_132), p_88)))) > 0x9AA0F805))) >= l_98) != l_132)) , 0x75E9), p_90)) != 0x74949FC4) , p_89)) > l_132))
            { /* block id: 52 */
                const int32_t l_133 = (-1);
                (*l_114) = ((l_133 , l_133) == (0xB.34EAFFp+79 >= l_122));
                for (p_90 = 6; (p_90 > 22); p_90 = safe_add_func_int32_t_s_s(p_90, 4))
                { /* block id: 56 */
                    const int32_t *l_138 = &l_132;
                    const int32_t **l_137 = &l_138;
                    l_136 = l_136;
                    (*l_137) = p_89;
                    /* statement id: 58 */
                    //assert (l_138 == 0 || l_138 == &l_294 || l_138 == &l_51);
                    if ((l_133 >= (safe_mod_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((-1), 11)), (~(p_89 == (void*)0)))) , (__builtin_parityll(((safe_rshift_func_uint16_t_u_u(p_91, (safe_lshift_func_uint16_t_u_s(p_91, 0)))) < (l_136.f4 == (4294967293U || ((l_132 & p_88) , 4294967289U))))) || p_90)), p_91))))
                    { /* block id: 59 */
                        struct S0 *l_151 = &l_136;
                        struct S0 **l_150 = &l_151;
                        struct S0 *l_153 = &l_152;
                        int32_t l_154 = 0x74381393;
                        (*l_150) = (void*)0;
                        /* statement id: 60 */
                        assert (l_151 == 0);
                        (*l_153) = l_152;
                        (*l_112) = l_154;
                    }
                    else
                    { /* block id: 63 */
                        (*l_137) = (void*)0;
                        /* statement id: 64 */
                        assert (l_138 == 0);
                    }
                }
            }
            else
            { /* block id: 67 */
                struct S0 l_155 = {-0,16,1U,545,13};
                int32_t **l_164 = &l_109;
                (*l_164) = ((p_88 , ((l_155 , (safe_mod_func_int32_t_s_s(p_90, (safe_sub_func_int16_t_s_s(__builtin_bswap64((safe_mul_func_int16_t_s_s(p_88, l_136.f3))), p_90))))) , (safe_sub_func_int16_t_s_s((p_88 <= l_132), 0xF106)))) , p_89);
                /* statement id: 68 */
                //assert (l_109 == 0 || l_109 == &l_294 || l_109 == &l_51);
                return p_90;
            }
            (*l_165) = p_88;
            return p_90;
        }
        /* facts after branching */
        //assert (l_109 == 0 || l_109 == &l_294 || l_109 == &l_51);
        if (p_91)
        { /* block id: 74 */
            struct S0 **l_178 = (void*)0;
            struct S0 ***l_177 = &l_178;
            int32_t *l_180 = &l_132;
            for (l_152.f2 = 13; (l_152.f2 <= 16); l_152.f2 = safe_add_func_uint32_t_u_u(l_152.f2, 1))
            { /* block id: 77 */
                int32_t *l_168 = &l_132;
                struct S0 ***l_179 = (void*)0;
                struct S0 l_181 = {0,6,0xFCC9BDC8,2807,2};
                struct S0 *l_200 = &l_181;
                (*l_168) = (-1);
                for (l_98 = 0; (l_98 <= 37); l_98 = safe_add_func_int32_t_s_s(l_98, 2))
                { /* block id: 81 */
                    int32_t *l_175 = &l_132;
                    for (p_88 = 23; (p_88 >= (-15)); p_88 = safe_sub_func_uint32_t_u_u(p_88, 2))
                    { /* block id: 84 */
                        struct S0 *l_173 = &l_152;
                        struct S0 **l_174 = &l_173;
                        int32_t **l_176 = &l_109;
                        (*l_174) = l_173;
                        (*l_176) = l_175;
                        /* statement id: 86 */
                        assert (l_109 == &l_132);
                        l_179 = l_177;
                        /* statement id: 87 */
                        assert (l_179 == &l_178);
                        l_180 = p_89;
                        /* statement id: 88 */
                        //assert (l_180 == 0 || l_180 == &l_294 || l_180 == &l_51);
                    }
                    (*l_175) = ((*l_177) != (void*)0);
                }
                /* facts after for loop */
                assert (l_179 == &l_178 || l_179 == 0);
                if (__builtin_parity(((((l_132 , p_90) != ((void*)0 == l_179)) , l_152) , p_90)))
                { /* block id: 92 */
                    int32_t *l_183 = &l_132;
                    const int32_t *l_190 = &l_132;
                    const int32_t **l_189 = &l_190;
                    const int32_t *** const l_188 = &l_189;
                    const int32_t *** const *l_187 = &l_188;
                    if ((__builtin_popcountl(p_90) < l_132))
                    { /* block id: 93 */
                        struct S0 l_182 = {3,-19,1U,1246,6};
                        int32_t **l_184 = &l_168;
                        l_182 = l_181;
                        (*l_184) = l_183;
                    }
                    else
                    { /* block id: 96 */
                        int32_t **l_186 = &l_180;
                        int32_t ***l_185 = &l_186;
                        int32_t ****l_192 = &l_185;
                        int32_t *****l_191 = &l_192;
                        (*l_185) = &l_109;
                        /* statement id: 97 */
                        assert (l_186 == &l_109);
                        (**l_185) = l_114;
                        /* statement id: 98 */
                        assert (l_109 == &l_115);
                        (*l_191) = l_187;
                        /* statement id: 99 */
                        assert (l_192 == &l_188);
                    }
                    for (p_90 = (-18); (p_90 > 19); p_90 = safe_add_func_int32_t_s_s(p_90, 4))
                    { /* block id: 103 */
                        struct S0 *l_196 = (void*)0;
                        struct S0 *l_197 = &l_181;
                        (*l_197) = l_195;
                        (*l_197) = (*l_197);
                        (*l_183) = l_195.f2;
                    }
                    l_132 = (***l_188);
                }
                else
                { /* block id: 109 */
                    (*l_168) = (p_89 == ((*l_168) , p_89));
                    (*l_168) = (p_90 && (safe_mod_func_int32_t_s_s((4294967295U & (__builtin_bswap32(p_91) ^ p_91)), 0xB3C0A783)));
                    return p_88;
                }
                (*l_200) = l_195;
            }
            /* facts after for loop */
            //assert (l_109 == &l_115 || l_109 == &l_132 || l_109 == 0 || l_109 == &l_294 || l_109 == &l_51);
            //assert (l_180 == 0 || l_180 == &l_132 || l_180 == &l_294 || l_180 == &l_51);
            if ((safe_rshift_func_uint16_t_u_s((p_91 <= l_195.f1), 13)))
            { /* block id: 116 */
                return l_195.f2;
            }
            else
            { /* block id: 118 */
                return p_90;
            }
        }
        else
        { /* block id: 121 */
            int32_t **l_203 = (void*)0;
            const int32_t *l_205 = &l_132;
            const int32_t **l_204 = &l_205;
            int32_t ***l_207 = &l_203;
            int32_t ****l_206 = &l_207;
            (*l_204) = p_89;
            /* statement id: 122 */
            //assert (l_205 == 0 || l_205 == &l_294 || l_205 == &l_51);
            (*l_206) = (l_195.f1 , &l_203);
        }
        (*l_208) = &l_132;
        /* statement id: 125 */
        assert (l_109 == &l_132);
    }
    else
    { /* block id: 126 */
        float l_209 = 0x7.5p+1;
        struct S0 *l_217 = &l_152;
        int32_t l_218 = 1;
        if (((p_91 , p_90) , p_91))
        { /* block id: 127 */
            uint16_t l_214 = 65531U;
            struct S0 *l_220 = (void*)0;
            int32_t *l_233 = &l_218;
            l_218 = ((safe_mul_func_float_f_f(p_90, ((((p_88 != ((safe_add_func_uint32_t_u_u(l_214, (-1))) && 1)) != (safe_lshift_func_int16_t_s_u((((void*)0 == p_89) >= ((l_217 != (void*)0) | p_90)), 6))) , p_90) , l_214))) >= l_218);
            if ((~(__builtin_ffsl(p_90) , 0)))
            { /* block id: 129 */
                l_220 = (void*)0;
            }
            else
            { /* block id: 131 */
                int32_t **l_221 = &l_109;
                (*l_221) = (void*)0;
            }
            (*l_233) = ((safe_rshift_func_uint16_t_u_s(p_91, (l_218 != l_214))) > (safe_lshift_func_uint16_t_u_u((l_214 != (safe_lshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s(((((((p_88 & (0x9FA4E0B6 | __builtin_parityl(p_90))) , (safe_mul_func_uint16_t_u_u(l_214, l_232))) , l_214) | 0xCA30) , l_218) , l_218), l_218)), p_90))), 15)));
        }
        else
        { /* block id: 135 */
            l_109 = p_89;
            /* statement id: 136 */
            //assert (l_109 == 0 || l_109 == &l_294 || l_109 == &l_51);
        }
        /* facts after branching */
        //assert (l_109 == 0 || l_109 == &l_294 || l_109 == &l_51);
        if ((safe_mod_func_int32_t_s_s(p_88, 1)))
        { /* block id: 138 */
            l_217 = (p_91 , l_217);
        }
        else
        { /* block id: 140 */
            int32_t **l_236 = &l_109;
            (*l_236) = (void*)0;
            /* statement id: 141 */
            assert (l_109 == 0);
            (*l_236) = (void*)0;
        }
    }
    /* facts after branching */
    //assert (l_109 == 0 || l_109 == dangling || l_109 == &l_294 || l_109 == &l_51);
    (*l_237) = l_152;
    (*l_238) = l_114;
    /* statement id: 146 */
    assert (l_109 == &l_115);
    return p_91;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 136
   depth: 1, occurrence: 14
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 64
breakdown:
   indirect level: 0, occurrence: 14
   indirect level: 1, occurrence: 36
   indirect level: 2, occurrence: 0
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 39
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 23
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 32

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 216
   depth: 2, occurrence: 25
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 4
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 3
   depth: 37, occurrence: 1

XXX total number of pointers: 182

XXX times a variable address is taken: 156
XXX times a pointer is dereferenced on RHS: 36
breakdown:
   depth: 1, occurrence: 20
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 383

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 386
   level: 2, occurrence: 39
   level: 3, occurrence: 31
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 80
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 53
XXX percent of pointers has null in alias set: 27.5
XXX average alias set size: 1.19

XXX times a non-volatile is read: 579
XXX times a non-volatile is write: 235
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 174
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 27
   depth: 2, occurrence: 28
   depth: 3, occurrence: 30
   depth: 4, occurrence: 27
   depth: 5, occurrence: 29

XXX percentage a fresh-made variable is used: 13.8
XXX percentage an existing variable is used: 86.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

