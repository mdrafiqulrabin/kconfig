/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3020404432
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   int64_t  f2;
   int64_t  f3;
   uint32_t  f4;
   int32_t  f5;
   signed f6 : 6;
   int16_t  f7;
   uint32_t  f8;
};

struct S1 {
   unsigned f0 : 3;
   unsigned f1 : 2;
   unsigned f2 : 5;
   int64_t  f3;
   uint64_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_28(void);
static int32_t * func_29(uint32_t  p_30, int32_t  p_31, int32_t * p_32, int32_t  p_33);
static uint64_t  func_39(int32_t  p_40);
static uint64_t  func_41(int32_t  p_42, int32_t * p_43, struct S1  p_44, int32_t * p_45, struct S1  p_46);
static uint64_t ** func_58(int32_t * p_59);
static int32_t  func_73(int32_t * p_74, float  p_75, uint64_t ** p_76, uint64_t  p_77);
static int32_t * func_78(uint64_t  p_79, float * p_80);
static int16_t  func_85(float * p_86, int32_t  p_87, uint64_t ** p_88, uint64_t ** p_89, float  p_90);
static uint64_t ** func_91(float * p_92, int64_t  p_93, struct S0  p_94, uint64_t  p_95);
static float * func_96(int32_t * p_97, struct S1  p_98, float * p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_34 = 0xA4129B85L;
    int32_t l_48 = 0x52772010L;
    int32_t *l_47 = &l_48;
    uint64_t l_54 = 0xAFEC1E183A099773LL;
    uint64_t *l_53 = &l_54;
    struct S1 l_57 = {0,1,2,0x53A81F6ED734895CLL,1UL};
    int32_t l_466 = 0xEDB85EC9L;
    int32_t *l_465 = &l_466;
    int32_t **l_482 = &l_47;
    (*l_482) = func_29(l_34, ((*l_465) = (safe_rshift_func_uint16_t_u_u((safe_add_func_uint64_t_u_u(l_34, l_34)), (1UL == (func_39((l_34 < func_41(l_34, l_47, (((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_u((((*l_53)--) == 18446744073709551615UL), 7)), 11)) ^ (*l_47)) , l_57), &l_48, l_57))) <= 0x632061BE2EFF3B49LL))))), l_465, l_57.f4);
    return l_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_29(uint32_t  p_30, int32_t  p_31, int32_t * p_32, int32_t  p_33)
{ /* block id: 154 */
    uint64_t *l_469 = (void*)0;
    uint64_t **l_468 = &l_469;
    uint64_t ***l_467 = &l_468;
    uint64_t ****l_470 = &l_467;
    int32_t l_472 = (-10L);
    int32_t *l_471 = &l_472;
    int32_t *l_473 = &l_472;
    int32_t *l_474 = &l_472;
    int32_t *l_475 = &l_472;
    int32_t *l_476 = &l_472;
    int32_t *l_477 = &l_472;
    int32_t *l_478 = &l_472;
    int32_t *l_479 = &l_472;
    int32_t *l_480 = &l_472;
    int32_t *l_481 = (void*)0;
    (*l_470) = l_467;
    return l_481;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_39(int32_t  p_40)
{ /* block id: 150 */
    uint32_t l_463 = 18446744073709551615UL;
    int32_t l_464 = 0x78794BD4L;
    l_464 &= l_463;
    return l_463;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_41(int32_t  p_42, int32_t * p_43, struct S1  p_44, int32_t * p_45, struct S1  p_46)
{ /* block id: 38 */
    int32_t l_61 = 0xB3F54C3DL;
    int32_t *l_60 = &l_61;
    uint64_t l_70 = 0x5AB95DFEA44E0C42LL;
    uint64_t *l_69 = &l_70;
    uint64_t **l_68 = &l_69;
    uint64_t ***l_67 = &l_68;
    float l_72 = (-0x1.4p+1);
    float *l_71 = &l_72;
    float *l_100 = &l_72;
    int16_t l_115 = 0x3C1DL;
    int16_t *l_114 = &l_115;
    struct S0 l_116 = {-8L,0xAA93538BL,-3L,5L,0x78636BC8L,-1L,6,0x864CL,1UL};
    uint64_t **l_409 = (void*)0;
    int32_t **l_443 = &l_60;
    (*l_67) = func_58(l_60);
    (*l_71) = p_44.f1;
    (*p_43) = func_73(((*l_443) = func_78((safe_mod_func_uint16_t_u_u((__builtin_ffs((*p_45)) && ((safe_mul_func_int16_t_s_s(func_85(p_45, (*l_60), ((*l_67) = func_91(func_96(&l_61, p_46, l_100), (safe_rshift_func_int16_t_s_s(((*l_114) &= ((*l_60) < (*l_60))), p_44.f2)), l_116, (*l_60))), l_409, p_44.f2), 0x348BL)) == (*l_60))), (*l_60))), l_100)), p_44.f3, &l_69, l_116.f1);
    return p_44.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t ** func_58(int32_t * p_59)
{ /* block id: 39 */
    uint64_t l_62 = 0x833AED5EBAE88B14LL;
    uint64_t *l_64 = &l_62;
    uint64_t **l_63 = &l_64;
    uint64_t **l_65 = &l_64;
    uint64_t **l_66 = (void*)0;
    (*p_59) = l_62;
    return l_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_73(int32_t * p_74, float  p_75, uint64_t ** p_76, uint64_t  p_77)
{ /* block id: 142 */
    float l_445 = 0x1.9p+1;
    float *l_444 = &l_445;
    float l_448 = 0x2.Ap+1;
    int32_t l_449 = 0x32DDD9FBL;
    uint64_t l_452 = 0x7C32685E0CE5C9CALL;
    uint64_t *l_451 = &l_452;
    uint64_t **l_450 = &l_451;
    int32_t l_459 = 1L;
    int32_t *l_458 = &l_459;
    float l_461 = (-0x1.Ep+1);
    int32_t l_462 = 0x737C8A46L;
    (*p_74) &= ((void*)0 == (*p_76));
lbl_460:
    (*l_458) &= func_85(l_444, ((safe_add_func_int32_t_s_s(__builtin_ffs(l_449), __builtin_ctzll((**p_76)))) == l_449), l_450, &l_451, ((__builtin_clzll(((safe_mod_func_int32_t_s_s(((+(safe_lshift_func_int16_t_s_s((((l_451 != (void*)0) != (*p_74)) >= 0x8BA42434L), p_77))) < l_449), p_77)) | 5L)) != 4294967295UL) , (-0x5.5p-1)));
    p_74 = &l_449;
    if (l_449)
        goto lbl_460;
    return l_462;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_78(uint64_t  p_79, float * p_80)
{ /* block id: 136 */
    struct S1 l_427 = {1,1,3,0xD2E82F85C9947E1CLL,0x2E30379E35B24F8ALL};
    struct S1 *l_426 = &l_427;
    struct S1 **l_428 = &l_426;
    struct S0 l_440 = {0x4E643068L,0xE9F75FF9L,0x7EAA5562F0F951E7LL,-10L,0UL,0L,0,0L,4294967289UL};
    struct S0 *l_441 = &l_440;
    uint64_t **l_442 = (void*)0;
    (*l_428) = l_426;
    (*p_80) = (safe_sub_func_float_f_f((((safe_sub_func_uint16_t_u_u(p_79, (safe_mod_func_uint16_t_u_u(4UL, p_79)))) ^ (l_427.f3 , ((safe_mod_func_int64_t_s_s(l_427.f3, (safe_add_func_uint16_t_u_u((((!0L) ^ ((p_79 ^ (((((func_85((((*l_441) = l_440) , p_80), l_427.f1, l_442, l_442, l_427.f1) && p_79) != p_79) , l_440.f7) < l_427.f3) && 0xE8BEF140DDB9D46ELL)) <= l_427.f1)) > l_427.f2), (-1L))))) , p_79))) , (*p_80)), (-0x1.0p-1)));
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_48 l_72
 */
static int16_t  func_85(float * p_86, int32_t  p_87, uint64_t ** p_88, uint64_t ** p_89, float  p_90)
{ /* block id: 123 */
    uint16_t l_410 = 0x345EL;
    int32_t l_412 = 0x3E547229L;
    int32_t *l_411 = &l_412;
    uint64_t **l_415 = (void*)0;
    int32_t l_420 = 0L;
    struct S1 l_421 = {1,0,1,1L,0xD52E694BA9F67F97LL};
    int32_t **l_422 = &l_411;
    float l_424 = 0x8.Ap+1;
    float *l_423 = &l_424;
    float *l_425 = &l_424;
    (*l_411) |= (p_87 & l_410);
    for (l_412 = 0; (l_412 <= 17); l_412 = safe_add_func_int32_t_s_s(l_412, 6))
    { /* block id: 127 */
        uint16_t *l_418 = &l_410;
        int32_t l_419 = 0x5DB38199L;
        (*p_86) = ((l_415 = p_88) != p_89);
        l_420 = ((safe_lshift_func_int16_t_s_u(((l_418 != &l_410) , l_419), p_87)) >= (*l_411));
    }
    (*l_422) = func_96(((*l_422) = func_96(p_86, l_421, func_96(((*l_422) = &l_420), l_421, l_423))), l_421, l_425);
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t ** func_91(float * p_92, int64_t  p_93, struct S0  p_94, uint64_t  p_95)
{ /* block id: 52 */
    uint64_t l_119 = 0x2FE0EC9289037596LL;
    int32_t *l_124 = (void*)0;
    int64_t l_125 = 0x3A67FE427CCDDECALL;
    int32_t l_127 = 5L;
    int32_t *l_126 = &l_127;
    uint32_t l_128 = 0xAC0FE8B8L;
    uint64_t *l_130 = (void*)0;
    uint64_t **l_129 = &l_130;
    int32_t l_302 = 0x3A2588FAL;
    int32_t l_303 = (-1L);
    int32_t l_305 = 0x4ADFA8AFL;
    struct S1 l_342 = {0,1,1,-5L,0x1B48E1355ABE805CLL};
    uint64_t **l_344 = &l_130;
    uint64_t **l_351 = &l_130;
    uint64_t **l_404 = &l_130;
    uint64_t **l_405 = &l_130;
    uint64_t **l_406 = &l_130;
    uint64_t **l_407 = &l_130;
    uint64_t **l_408 = (void*)0;
    (*l_126) ^= (l_125 = (safe_sub_func_uint32_t_u_u(l_119, (safe_sub_func_uint32_t_u_u(4294967286UL, (safe_add_func_int64_t_s_s(p_94.f0, p_94.f8)))))));
    if (l_128)
    { /* block id: 55 */
        uint64_t **l_131 = &l_130;
        uint64_t **l_132 = (void*)0;
        return l_132;
    }
    else
    { /* block id: 57 */
        int32_t **l_133 = &l_126;
        int32_t **l_136 = &l_126;
        int32_t ***l_137 = &l_133;
        uint64_t **l_141 = &l_130;
        int32_t l_180 = 4L;
        int32_t l_205 = 0x5D46ADFCL;
        int32_t l_246 = 0xB47B8E48L;
        int32_t l_254 = 0xE2895D01L;
        int32_t l_263 = 0x3C2ACCF6L;
        struct S1 l_356 = {1,1,0,1L,0x2912A9ED5AC8D5ACLL};
        int16_t l_375 = 0xBBCBL;
        int16_t *l_374 = &l_375;
        (*l_133) = &l_127;
        if ((safe_add_func_uint64_t_u_u(p_94.f2, (l_136 != ((*l_137) = &l_124)))))
        { /* block id: 60 */
            uint64_t **l_142 = (void*)0;
            struct S0 l_143 = {0L,4294967295UL,0xCC30D4DDF0F57B56LL,0xEB8760324A0BD6DALL,0x9A6A910BL,0x3A75C332L,0,6L,0x18DDDCD3L};
            struct S0 *l_144 = &l_143;
            int32_t *l_145 = &l_127;
            for (p_94.f5 = (-10); (p_94.f5 == (-2)); p_94.f5 = safe_add_func_int64_t_s_s(p_94.f5, 6))
            { /* block id: 63 */
                uint64_t **l_140 = &l_130;
                (*l_136) = p_92;
                return l_142;
            }
            (*l_144) = ((p_94 , (*l_126)) , l_143);
            (*l_126) = (l_145 == &l_127);
        }
        else
        { /* block id: 69 */
            int64_t l_148 = 3L;
            int64_t *l_158 = &l_125;
            p_94.f6 |= (safe_sub_func_uint64_t_u_u(l_148, __builtin_ffsl((*l_126))));
            (*l_133) = p_92;
            (*l_124) ^= ((safe_mul_func_int16_t_s_s(l_148, (safe_mod_func_uint64_t_u_u(l_148, (p_94.f7 | (safe_sub_func_uint64_t_u_u(0x7AE26BD8041E7D7DLL, ((*l_126) == 4294967295UL)))))))) != ((+l_148) || __builtin_clzl(((**l_136) || (((*l_158) &= ((((safe_mul_func_int16_t_s_s((0xED3BL != 0x7BC7L), p_94.f6)) ^ 0L) != p_93) != l_148)) && 6UL)))));
        }
        for (p_94.f5 = (-12); (p_94.f5 <= 4); p_94.f5++)
        { /* block id: 77 */
            int32_t *l_165 = &l_127;
            int32_t l_167 = 6L;
            int32_t l_239 = 0L;
            int16_t l_245 = 0xBA76L;
            int32_t l_258 = 1L;
            int32_t l_259 = 0x5331A3B0L;
            int32_t l_274 = 0xE85E602BL;
            int32_t l_281 = 1L;
            int32_t l_282 = (-1L);
            int32_t l_287 = 0xEC947174L;
            int32_t l_299 = 0x7FFFD43EL;
            int32_t l_309 = 0L;
            int32_t l_315 = 0xE5EACDDFL;
            int64_t l_334 = 1L;
            uint64_t **l_348 = &l_130;
            uint64_t **l_352 = &l_130;
            uint64_t **l_353 = &l_130;
            uint32_t l_358 = 0x26454160L;
            struct S1 l_382 = {0,0,1,3L,0x2EA11B6DA610F450LL};
            (*p_92) = (*p_92);
            for (p_94.f1 = (-11); (p_94.f1 == 21); p_94.f1++)
            { /* block id: 81 */
                int16_t l_164 = 0xEE73L;
                int16_t *l_163 = &l_164;
                int32_t l_191 = (-1L);
                int32_t l_208 = 3L;
                int32_t l_241 = 0x08194481L;
                int32_t l_251 = (-7L);
                float l_256 = (-0x1.Dp-1);
                int32_t l_267 = 4L;
                int32_t **l_341 = &l_165;
                uint64_t **l_346 = &l_130;
                uint64_t **l_354 = &l_130;
                uint32_t l_369 = 1UL;
                struct S0 l_387 = {1L,0x0C104093L,0L,5L,1UL,-1L,0,0x9A27L,6UL};
                struct S1 l_397 = {0,1,4,0L,6UL};
            }
            if ((*l_165))
                continue;
        }
    }
    return l_408;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_96(int32_t * p_97, struct S1  p_98, float * p_99)
{ /* block id: 44 */
    uint64_t l_106 = 18446744073709551607UL;
    uint64_t *l_105 = &l_106;
    uint64_t **l_104 = &l_105;
    uint64_t ***l_103 = &l_104;
    float l_111 = (-0x1.3p+1);
    float *l_110 = &l_111;
    for (p_98.f3 = 0; (p_98.f3 != (-19)); --p_98.f3)
    { /* block id: 47 */
        uint64_t ***l_107 = (void*)0;
        int32_t l_109 = (-7L);
        int32_t *l_108 = &l_109;
        (*l_108) = (1UL || (l_103 != l_107));
    }
    return p_99;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 18
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 9

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 12, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 240

XXX times a variable address is taken: 196
XXX times a pointer is dereferenced on RHS: 29
breakdown:
   depth: 1, occurrence: 24
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 48
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 515

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 134
   level: 2, occurrence: 33
   level: 3, occurrence: 6
XXX number of pointers point to pointers: 49
XXX number of pointers point to scalars: 181
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 18.8
XXX average alias set size: 1.08

XXX times a non-volatile is read: 250
XXX times a non-volatile is write: 113
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 47
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 7
   depth: 2, occurrence: 9
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 14.6
XXX percentage an existing variable is used: 85.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

