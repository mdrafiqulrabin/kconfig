/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1308544320
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 0xCA63L;
static struct S0 g_40 = {-1L};
static int32_t g_93 = 0L;
static int32_t *g_95 = &g_93;
static struct S0 g_129 = {8L};
static int32_t g_149 = 0xD65D9876L;
static int32_t **g_156 = &g_95;
static int32_t ***g_155 = &g_156;
static struct S0 g_191 = {-3L};
static int32_t *****g_223 = (void*)0;
static int32_t g_233 = 0x74A9DA08L;
static uint32_t g_346 = 0x3A99ED4DL;
static struct S0 **g_381 = (void*)0;
static uint16_t g_382 = 0x482EL;
static struct S0 *g_502 = &g_191;
static int16_t g_585 = 0x48B2L;
static uint16_t g_646 = 2UL;
static int32_t g_682 = (-9L);
static int32_t g_701 = (-1L);


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_26(void);
static uint16_t  func_34(struct S0  p_35, int32_t  p_36, int32_t  p_37, int32_t  p_38, uint32_t  p_39);
inline static int32_t  func_42(int32_t  p_43, uint32_t  p_44, struct S0  p_45, int16_t  p_46, uint32_t  p_47);
inline static struct S0 * func_53(struct S0  p_54);
inline static struct S0  func_55(struct S0 * p_56, struct S0 * p_57);
static struct S0 * func_58(uint32_t  p_59, uint16_t  p_60, uint32_t  p_61, uint16_t  p_62);
inline static struct S0  func_65(int16_t  p_66, struct S0 * p_67, int16_t  p_68);
inline static struct S0 * func_69(int32_t  p_70, struct S0  p_71, uint16_t  p_72, struct S0 * p_73, struct S0 * p_74);
inline static int32_t  func_75(uint32_t  p_76, uint32_t  p_77, uint32_t  p_78);
inline static int16_t  func_85(struct S0 * p_86, int32_t  p_87, int32_t  p_88, uint16_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_233
 * writes:
 */
inline static uint32_t  func_26(void)
{ /* block id: 36 */
    int16_t l_27 = 0x0977L;
    uint32_t l_48 = 1UL;
    uint32_t l_649 = 9UL;
    int32_t *l_665 = &g_233;
    uint32_t l_667 = 0x038F67D7L;
    int32_t l_698 = (-6L);
    int32_t l_699 = 0x96FA536AL;
    struct S0 **l_703 = &g_502;
    l_27 |= (0x3358L >= 0x80C3L);
    for (l_27 = 0; (l_27 <= (-22)); l_27 -= 8)
    { /* block id: 40 */
        int32_t l_33 = 0x412894FFL;
        uint16_t l_51 = 0UL;
        struct S0 l_52 = {0x97E65FBCL};
    }
    return g_233;
}


/* ------------------------------------------ */
/* 
 * reads : g_129.f0
 * writes: g_502
 */
static uint16_t  func_34(struct S0  p_35, int32_t  p_36, int32_t  p_37, int32_t  p_38, uint32_t  p_39)
{ /* block id: 471 */
    struct S0 **l_647 = (void*)0;
    struct S0 **l_648 = &g_502;
    (*l_648) = &p_35;
    return g_129.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f0 g_3 g_95 g_93 g_40 g_149 g_155 g_129.f0 g_156 g_191.f0 g_191 g_223 g_233 g_129 g_346 g_381 g_382 g_502 g_585
 * writes: g_95 g_3 g_93 g_129 g_149 g_155 g_191 g_233 g_156 g_382 g_502
 */
inline static int32_t  func_42(int32_t  p_43, uint32_t  p_44, struct S0  p_45, int16_t  p_46, uint32_t  p_47)
{ /* block id: 42 */
    uint32_t l_63 = 1UL;
    int32_t l_64 = (-10L);
    struct S0 **l_516 = &g_502;
    int32_t l_519 = (-6L);
    int32_t **l_528 = &g_95;
    int32_t ****l_554 = (void*)0;
    uint16_t l_568 = 0x902AL;
    int32_t l_615 = 0xC58EDD33L;
    struct S0 l_645 = {1L};
    (*l_516) = func_53(func_55(func_58(l_63, g_40.f0, l_64, p_45.f0), &g_40));
    if ((+g_129.f0))
    { /* block id: 386 */
        struct S0 *l_518 = &g_191;
        (*l_518) = p_45;
    }
    else
    { /* block id: 388 */
        int32_t **l_527 = &g_95;
        uint16_t l_545 = 1UL;
        int32_t l_565 = 1L;
        struct S0 *l_584 = (void*)0;
        struct S0 l_606 = {0xCD29130FL};
        l_519 ^= l_63;
        for (p_43 = 0; (p_43 > (-1)); p_43 -= 1)
        { /* block id: 392 */
            return l_64;
        }
        if (p_45.f0)
        { /* block id: 395 */
            int32_t *l_529 = &g_233;
            int32_t ****l_532 = &g_155;
            (*l_529) = (+(((uint16_t)(func_75(p_44, l_63, ((uint16_t)p_45.f0 << (uint16_t)7)) > g_346) << (uint16_t)(((l_527 != l_528) | g_149) | g_233)) <= g_233));
            if ((g_346 == ((uint32_t)g_149 + (uint32_t)((((void*)0 == l_532) ^ ((int16_t)(((uint32_t)(((int16_t)((uint16_t)((l_516 != (void*)0) >= (-(uint16_t)((uint16_t)((+0xB209L) <= func_75(l_545, p_46, g_233)) >> (uint16_t)4))) >> (uint16_t)2) + (int16_t)9L) & g_382) - (uint32_t)l_64) != 0x537EL) >> (int16_t)8)) > g_233))))
            { /* block id: 397 */
                uint32_t l_557 = 0xDA2B867EL;
                int32_t l_579 = 0xD77567B5L;
                if ((((int32_t)((int16_t)g_346 >> (int16_t)4) % (int32_t)((int16_t)((int16_t)p_44 - (int16_t)((void*)0 != l_554)) << (int16_t)g_191.f0)) < (func_75(g_3, p_43, ((((int32_t)0x82716A4BL % (int32_t)p_46) || 0xAD87L) ^ l_557)) > 0x2D21L)))
                { /* block id: 398 */
                    int16_t l_558 = 0x036BL;
                    struct S0 **l_563 = &g_502;
                    int32_t l_574 = 1L;
                    int32_t l_578 = 1L;
                    if (l_558)
                    { /* block id: 399 */
                        (*l_527) = (void*)0;
                    }
                    else
                    { /* block id: 401 */
                        int32_t *****l_564 = &l_554;
                        l_565 &= (((int32_t)((uint16_t)(&g_502 == l_563) + (uint16_t)g_149) - (int32_t)(l_564 == &l_532)) ^ g_129.f0);
                        l_568 |= ((uint16_t)0x43FEL << (uint16_t)1);
                        l_519 = (0x2A4A8CEAL == (+((p_43 > ((void*)0 != (*g_155))) > g_233)));
                        l_574 |= ((int32_t)__builtin_bswap64(((uint16_t)6UL << (uint16_t)p_43)) - (int32_t)p_47);
                    }
                    l_574 = p_46;
                    for (g_382 = 4; (g_382 < 50); g_382 += 1)
                    { /* block id: 410 */
                        int32_t l_577 = 0L;
                        l_577 |= p_45.f0;
                        l_579 &= l_578;
                        if (p_43)
                            break;
                    }
                }
                else
                { /* block id: 415 */
                    (*l_529) ^= (g_149 && ((int16_t)(-6L) + (int16_t)((int16_t)0xDA00L + (int16_t)g_40.f0)));
                }
                (*l_528) = l_529;
            }
            else
            { /* block id: 419 */
                (*l_516) = func_53(func_55(&g_191, l_584));
                return g_585;
            }
            (*l_527) = (**g_155);
        }
        else
        { /* block id: 424 */
            struct S0 l_594 = {-1L};
            for (l_565 = 0; (l_565 < 14); l_565 += 1)
            { /* block id: 427 */
                int32_t l_588 = 0x616ADC4BL;
                int32_t *l_589 = &g_149;
                uint32_t l_590 = 0x8C1FAC4FL;
                int32_t ***l_614 = &l_528;
                struct S0 **l_616 = &l_584;
                (*l_589) &= l_588;
            }
            return p_45.f0;
        }
    }
    return l_519;
}


/* ------------------------------------------ */
/* 
 * reads : g_129.f0 g_93 g_155 g_156 g_95 g_149 g_3 g_191.f0 g_346 g_233 g_40 g_129 g_223 g_381 g_382 g_191 g_502
 * writes: g_93 g_95 g_129 g_149 g_191.f0 g_3 g_155 g_191 g_233 g_156 g_382
 */
inline static struct S0 * func_53(struct S0  p_54)
{ /* block id: 249 */
    int32_t **l_326 = &g_95;
    int32_t l_351 = 1L;
    int16_t l_367 = (-1L);
    int32_t ****l_396 = &g_155;
    int16_t l_513 = 0x69FCL;
    struct S0 **l_515 = &g_502;
    if ((-(uint16_t)__builtin_popcount(p_54.f0)))
    { /* block id: 250 */
        struct S0 *l_324 = &g_129;
        struct S0 **l_323 = &l_324;
        int32_t l_327 = (-1L);
        int32_t l_333 = 0x5C898A0DL;
        int32_t ****l_369 = &g_155;
        int32_t *****l_368 = &l_369;
        int32_t l_408 = 0x10CE6646L;
        uint32_t l_462 = 1UL;
        int32_t l_492 = 0L;
        uint16_t l_510 = 0xB6BFL;
        if (((uint16_t)((void*)0 != l_323) << (uint16_t)7))
        { /* block id: 251 */
            uint32_t l_325 = 4UL;
            int32_t l_343 = 0x74991E24L;
            int32_t ***l_357 = &g_156;
            uint32_t l_372 = 1UL;
            struct S0 *l_409 = &g_191;
            if (l_325)
            { /* block id: 252 */
                int32_t *l_330 = (void*)0;
                struct S0 l_335 = {0x0411F770L};
                l_327 |= ((void*)0 == l_326);
                if (l_325)
                { /* block id: 254 */
                    int32_t *l_328 = (void*)0;
                    int32_t *l_329 = &g_93;
                    (*l_329) &= (g_129.f0 ^ 9UL);
                    (*l_326) = (**g_155);
                    (**g_155) = l_330;
                }
                else
                { /* block id: 258 */
                    uint16_t l_336 = 0x678AL;
                    (*l_324) = p_54;
                    for (l_327 = (-4); (l_327 <= 28); l_327 += 1)
                    { /* block id: 262 */
                        int32_t *l_334 = &g_149;
                        l_333 = __builtin_popcount(l_325);
                        (*l_334) ^= l_325;
                        (*l_324) = l_335;
                        (*l_334) |= p_54.f0;
                    }
                    l_336 = (g_3 != 0x4566L);
                }
                for (g_191.f0 = 16; (g_191.f0 < 26); g_191.f0 += 2)
                { /* block id: 272 */
                    int32_t l_349 = (-6L);
                    int32_t *l_354 = &g_93;
                    for (p_54.f0 = (-4); (p_54.f0 == 8); p_54.f0 += 4)
                    { /* block id: 275 */
                        l_330 = (*g_156);
                        l_343 ^= ((int32_t)p_54.f0 + (int32_t)(&g_155 == (void*)0));
                    }
                    l_351 ^= func_85(&g_129, (func_75(p_54.f0, __builtin_ctzll(((((((uint32_t)g_346 + (uint32_t)((uint16_t)(((void*)0 == &p_54) >= l_349) << (uint16_t)(l_343 < 2L))) < ((!p_54.f0) >= g_233)) >= l_349) >= g_149) ^ l_343)), p_54.f0) || p_54.f0), l_349, p_54.f0);
                    (*l_326) = &l_343;
                    for (g_149 = (-3); (g_149 > 19); g_149 += 6)
                    { /* block id: 283 */
                        int32_t l_361 = 0xBFCDB382L;
                        int32_t l_362 = 0xBCCF2732L;
                        (*g_156) = l_354;
                        (***g_155) = ((((((int32_t)p_54.f0 + (int32_t)p_54.f0) <= ((l_357 != (void*)0) == (-(int32_t)(***l_357)))) == ((int16_t)l_361 << (int16_t)(l_326 == l_326))) && func_75(p_54.f0, p_54.f0, (**l_326))) > 0x737AE78DL);
                        if (l_362)
                            break;
                        (**l_326) = 0x8B5250FEL;
                    }
                }
                (*l_324) = l_335;
            }
            else
            { /* block id: 291 */
                l_351 = ((&g_129 == (void*)0) | l_327);
            }
            if (((((uint16_t)(0xB4A6L | p_54.f0) << (uint16_t)g_346) && func_75(((int16_t)l_367 >> (int16_t)(((g_223 == (void*)0) <= p_54.f0) == (l_368 != g_223))), p_54.f0, p_54.f0)) <= 0x2FDEL))
            { /* block id: 294 */
                uint32_t l_380 = 0xEC597CA0L;
                int32_t l_398 = (-7L);
                uint32_t l_401 = 0x7B2373D0L;
                int32_t ****l_430 = &g_155;
                struct S0 l_432 = {0x9A1D392CL};
                if (((((p_54.f0 != (p_54.f0 <= (((int16_t)(func_75(g_346, p_54.f0, (((((p_54.f0 & l_372) <= (((uint16_t)((int16_t)((!((uint16_t)l_380 + (uint16_t)0L)) != ((void*)0 != &g_40)) - (int16_t)0xCD35L) >> (uint16_t)11) == p_54.f0)) > g_40.f0) < 0xEDB6L) || p_54.f0)) | p_54.f0) << (int16_t)14) ^ l_380))) < p_54.f0) | 0xE6D0F4A7L) || 0xF5ED74E0L))
                { /* block id: 295 */
                    int16_t l_383 = (-1L);
                    int32_t l_394 = 0x7219A0BEL;
                    l_383 = (g_346 & ((g_381 == (void*)0) < g_382));
                    if (p_54.f0)
                    { /* block id: 297 */
                        uint32_t l_386 = 0x43F3F6BDL;
                        l_386 |= ((g_3 > ((int16_t)(0L == 0x3D5AL) >> (int16_t)14)) < l_380);
                    }
                    else
                    { /* block id: 299 */
                        uint16_t l_391 = 0x2869L;
                        l_391 = ((int16_t)((uint16_t)65535UL >> (uint16_t)6) << (int16_t)7);
                        (****l_368) = (**l_357);
                        l_394 &= ((int16_t)g_40.f0 << (int16_t)8);
                    }
                    if ((&l_357 != (void*)0))
                    { /* block id: 304 */
                        uint32_t l_395 = 0UL;
                        (**l_323) = func_55(func_69(p_54.f0, p_54, l_395, (*l_323), &g_129), &p_54);
                    }
                    else
                    { /* block id: 306 */
                        uint32_t l_397 = 0x7BC6D4CEL;
                        (*l_326) = (**g_155);
                        l_398 = ((0xC8913531L >= ((((0UL == l_380) <= ((((g_233 && (l_396 == (*l_368))) < ((**g_155) == (*g_156))) == l_397) == l_394)) ^ l_380) != 0UL)) >= g_40.f0);
                        l_401 = ((int16_t)(p_54.f0 == (l_397 < l_383)) >> (int16_t)15);
                    }
                    if (((uint32_t)((uint16_t)p_54.f0 >> (uint16_t)g_40.f0) % (uint32_t)(-7L)))
                    { /* block id: 311 */
                        (**l_357) = (**g_155);
                    }
                    else
                    { /* block id: 313 */
                        (****l_368) = (void*)0;
                    }
                }
                else
                { /* block id: 316 */
                    for (g_382 = (-5); (g_382 != 9); g_382 += 7)
                    { /* block id: 319 */
                        uint32_t l_414 = 0x9A2F1BEEL;
                        if (l_408)
                            break;
                    }
                }
                for (l_372 = 4; (l_372 >= 58); l_372 += 1)
                { /* block id: 327 */
                    int16_t l_431 = 0xE167L;
                    struct S0 *l_433 = &g_40;
                    int32_t *l_436 = &l_327;
                    for (g_129.f0 = 0; (g_129.f0 >= 25); g_129.f0 += 5)
                    { /* block id: 330 */
                        (**g_155) = (****l_368);
                    }
                    if ((g_40.f0 ^ 0L))
                    { /* block id: 333 */
                        uint16_t l_423 = 6UL;
                        (***l_396) = (****l_368);
                        l_398 = ((uint32_t)((int16_t)g_129.f0 >> (int16_t)11) - (uint32_t)(l_423 != (((int16_t)(((uint16_t)((uint16_t)func_75(((void*)0 == l_430), p_54.f0, (p_54.f0 > l_423)) << (uint16_t)p_54.f0) - (uint16_t)l_431) < p_54.f0) + (int16_t)0xDBE0L) > p_54.f0)));
                        l_432 = func_55(&g_191, &g_129);
                    }
                    else
                    { /* block id: 337 */
                        return l_433;
                    }
                    if (p_54.f0)
                        break;
                    for (l_408 = (-10); (l_408 <= 6); l_408 += 1)
                    { /* block id: 343 */
                        (**g_155) = l_436;
                        (*l_323) = &g_40;
                    }
                }
            }
            else
            { /* block id: 348 */
                uint16_t l_437 = 5UL;
                int32_t l_450 = 0xC417655FL;
                l_450 ^= (l_437 && ((uint16_t)((int16_t)(((0UL && 0xA2E8L) || ((uint32_t)(((uint16_t)(((((uint16_t)g_129.f0 << (uint16_t)p_54.f0) > p_54.f0) ^ ((**l_368) != (void*)0)) >= ((int16_t)(0xF9F1L & (-1L)) >> (int16_t)10)) << (uint16_t)g_149) | 4294967295UL) % (uint32_t)p_54.f0)) != 0x3558134DL) - (int16_t)g_129.f0) - (uint16_t)0xDB47L));
            }
        }
        else
        { /* block id: 351 */
            int32_t *l_466 = &l_351;
            int32_t ***l_481 = &g_156;
            int32_t l_498 = 3L;
            int32_t *l_514 = &g_233;
            for (l_351 = (-26); (l_351 <= (-17)); l_351 += 2)
            { /* block id: 354 */
                int32_t l_455 = (-5L);
                struct S0 *l_465 = &g_129;
                if ((((((((((int16_t)(((l_455 & ((void*)0 == (*g_156))) ^ 0x11AFC6CEL) == func_75(g_149, ((uint32_t)((uint16_t)((int16_t)(-5L) >> (int16_t)((g_191.f0 > g_191.f0) >= func_75(g_40.f0, g_3, g_3))) << (uint16_t)g_149) % (uint32_t)p_54.f0), g_382)) >> (int16_t)6) && g_233) < l_462) == p_54.f0) || g_149) == 0x3378L) >= 0x7AB9L) == p_54.f0))
                { /* block id: 355 */
                    for (g_93 = 0; (g_93 <= 16); g_93 += 1)
                    { /* block id: 358 */
                        (****l_368) = (*g_156);
                        return &g_40;
                    }
                    return l_465;
                }
                else
                { /* block id: 363 */
                    int32_t l_480 = 0xF35EB71DL;
                    int16_t l_501 = 0x20DEL;
                    (*l_326) = l_466;
                    if (((int16_t)(!((uint16_t)((int16_t)(0x8E73L <= p_54.f0) << (int16_t)(((uint16_t)((int16_t)((uint16_t)p_54.f0 + (uint16_t)func_75(p_54.f0, g_3, l_480)) << (int16_t)p_54.f0) - (uint16_t)((**g_156) >= (*l_466))) == 0x3805A0B9L)) >> (uint16_t)12)) << (int16_t)g_40.f0))
                    { /* block id: 365 */
                        uint32_t l_491 = 0xDAAF38A7L;
                        int32_t l_493 = 1L;
                        int32_t *l_494 = &g_93;
                        (*l_369) = l_481;
                        l_493 = (0xE4BD2645L && func_75(((func_85(func_58(g_129.f0, (g_40.f0 && func_75(((((int32_t)__builtin_popcountl(((uint16_t)(((uint16_t)65533UL >> (uint16_t)13) > (((0x81ACL < (((**g_156) & (p_54.f0 || (+(__builtin_parityll(__builtin_bswap32(g_93)) | 7L)))) >= p_54.f0)) != l_455) | 0UL)) - (uint16_t)g_93)) + (int32_t)l_491) && 0x1FBB9AE5L) & l_455), (****l_369), p_54.f0)), (*****l_368), g_129.f0), (*l_466), p_54.f0, g_382) == l_492) ^ p_54.f0), (*l_466), p_54.f0));
                        (*l_494) |= l_491;
                        return &g_40;
                    }
                    else
                    { /* block id: 370 */
                        (**l_481) = (***l_369);
                    }
                    l_501 = ((((uint16_t)(+(func_75(l_498, g_93, ((void*)0 == g_381)) <= ((l_465 != (*l_323)) >= 0UL))) >> (uint16_t)8) ^ ((uint32_t)(g_233 > p_54.f0) + (uint32_t)0x68BBA003L)) && p_54.f0);
                }
                (*l_323) = g_502;
                (**l_481) = (***l_369);
            }
            (*l_514) |= func_85(func_58(((uint32_t)((uint32_t)(!((int32_t)0x9FA05B87L - (int32_t)((((l_510 | ((void*)0 != &g_129)) || 4294967289UL) && p_54.f0) && ((int16_t)(__builtin_ia32_crc32qi(((((((2L <= p_54.f0) & p_54.f0) >= l_513) | 0xA52866C1L) > 0x0D7F7A30L) & 0x2CA4L), g_149) > 0x56B59CE9L) - (int16_t)p_54.f0)))) - (uint32_t)(*l_466)) - (uint32_t)4294967295UL), p_54.f0, (*l_466), (*l_466)), p_54.f0, p_54.f0, g_382);
        }
    }
    else
    { /* block id: 380 */
        (***l_396) = (***l_396);
    }
    l_351 = (g_382 | (l_515 != l_515));
    return (*l_515);
}


/* ------------------------------------------ */
/* 
 * reads : g_155 g_156 g_129.f0 g_3 g_40.f0 g_149 g_93 g_95 g_223 g_233 g_40 g_191 g_129
 * writes: g_95 g_93 g_233 g_3 g_129 g_149 g_155 g_191 g_156
 */
inline static struct S0  func_55(struct S0 * p_56, struct S0 * p_57)
{ /* block id: 170 */
    int32_t *l_206 = (void*)0;
    uint32_t l_211 = 4294967289UL;
    uint16_t l_216 = 65527UL;
    int32_t *****l_221 = (void*)0;
    int32_t *l_226 = &g_93;
    struct S0 *l_316 = &g_129;
    (**g_155) = l_206;
    if (((int16_t)((((int32_t)(l_211 == ((int16_t)((void*)0 != l_206) << (int16_t)14)) % (int32_t)((uint32_t)func_75((__builtin_ctzl(g_129.f0) <= l_216), g_3, g_40.f0) - (uint32_t)1L)) != g_149) <= l_211) % (int16_t)l_216))
    { /* block id: 172 */
        uint16_t l_217 = 65534UL;
        int32_t *****l_220 = (void*)0;
        int32_t ***l_222 = (void*)0;
        int32_t **l_238 = &g_95;
        int32_t l_248 = 0xDFB01F2DL;
        struct S0 *l_289 = &g_129;
        if (((g_93 == (l_217 & ((l_217 < ((((int16_t)(l_220 != l_221) % (int16_t)g_149) == (l_222 == (void*)0)) != 9UL)) > 0x397D913FL))) != 4294967295UL))
        { /* block id: 173 */
            int32_t *l_224 = &g_93;
            int32_t *l_225 = &g_93;
            (*g_156) = (*g_156);
            (**g_155) = (*g_156);
            (*l_224) = ((void*)0 != g_223);
            (*g_156) = l_225;
        }
        else
        { /* block id: 178 */
            int32_t *l_227 = &g_149;
            int32_t *l_232 = &g_233;
            l_227 = l_226;
            (*l_232) &= (((*g_156) == (*g_156)) & ((*l_227) >= __builtin_ia32_crc32qi(g_40.f0, ((5L & ((int16_t)(((int32_t)(-10L) - (int32_t)7L) == (((0x5003L ^ __builtin_bswap32(g_40.f0)) == (*l_227)) & (*l_227))) << (int16_t)10)) < g_149))));
        }
        if (((int32_t)(*l_226) % (int32_t)(*l_226)))
        { /* block id: 182 */
            uint16_t l_237 = 0x34CFL;
            int32_t ****l_240 = &l_222;
            int32_t *****l_239 = &l_240;
            int32_t l_250 = 8L;
            int32_t l_269 = 0x50413280L;
            int16_t l_290 = 0x0B61L;
            uint32_t l_291 = 18446744073709551613UL;
            (*l_226) = (func_85(&g_191, (!0x0522L), ((l_237 == ((void*)0 != l_220)) == (l_238 == (*g_155))), (65535UL != (((void*)0 == l_220) >= 0L))) && g_3);
            if ((l_239 != (void*)0))
            { /* block id: 184 */
                uint32_t l_243 = 0xABF410F0L;
                int32_t *l_253 = &g_93;
                int32_t *l_254 = &l_248;
                for (g_149 = 0; (g_149 == 20); g_149 += 4)
                { /* block id: 187 */
                    (*l_226) |= (__builtin_ctzll(l_243) < l_243);
                }
                for (g_233 = (-23); (g_233 >= (-16)); g_233 += 5)
                { /* block id: 192 */
                    int32_t *l_252 = &g_149;
                    if ((g_93 > (((int16_t)0x65FDL >> (int16_t)l_248) | l_243)))
                    { /* block id: 193 */
                        int32_t *l_249 = &g_149;
                        (*g_156) = l_249;
                    }
                    else
                    { /* block id: 195 */
                        uint16_t l_251 = 65535UL;
                        l_250 = (0UL ^ g_129.f0);
                        if (l_251)
                            continue;
                    }
                    (*l_238) = l_252;
                    l_253 = l_252;
                }
                (*l_238) = (void*)0;
                (*l_254) &= (*l_226);
            }
            else
            { /* block id: 204 */
                int32_t *l_255 = &l_250;
                (*g_156) = l_255;
                (*l_226) ^= (*l_255);
                (**g_156) = (~(*l_226));
            }
            for (l_248 = 0; (l_248 >= (-26)); l_248 -= 1)
            { /* block id: 211 */
                int32_t ****l_271 = &l_222;
                int32_t l_274 = (-1L);
                if ((((int16_t)0x8951L + (int16_t)1L) && g_149))
                { /* block id: 212 */
                    (*p_56) = g_129;
                }
                else
                { /* block id: 214 */
                    int32_t ****l_270 = &g_155;
                    uint32_t l_282 = 18446744073709551606UL;
                    struct S0 *l_285 = &g_129;
                    int32_t *l_310 = &g_93;
                    if (((int16_t)(g_191.f0 || (((g_3 >= (g_3 <= ((uint16_t)((uint32_t)((g_3 > ((uint16_t)(0x0424L > (l_269 && (l_270 == l_271))) >> (uint16_t)(((uint16_t)(((*l_226) != 1L) < g_233) >> (uint16_t)(*l_226)) != (-4L)))) || (*l_226)) % (uint32_t)l_274) >> (uint16_t)3))) == (*l_226)) > 0x2781L)) << (int16_t)g_40.f0))
                    { /* block id: 215 */
                        uint16_t l_275 = 6UL;
                        int32_t *l_280 = &l_269;
                        int32_t *****l_281 = &l_240;
                        int32_t *l_292 = &l_250;
                        (*p_56) = func_65(((l_275 != ((int16_t)((((uint32_t)(l_280 == (***l_270)) - (uint32_t)((g_40.f0 > g_40.f0) & ((-9L) | (*l_280)))) > (&l_240 == l_281)) >= 0x0960L) >> (int16_t)(*l_280))) && l_282), &g_191, g_129.f0);
                        (*l_280) &= (((g_223 != l_220) ^ 0xE0A9L) != ((g_40.f0 <= (g_40.f0 < 0x3D53L)) >= ((*l_239) != (*l_239))));
                        (*l_292) ^= (((uint32_t)(func_85(l_285, (((((-(int16_t)(0x7FF1L <= (((**g_155) != (**g_155)) < ((uint16_t)(&g_129 == l_289) >> (uint16_t)1)))) < (((__builtin_popcountl(g_233) > (((p_57 == (void*)0) == g_93) ^ g_93)) > 0x797314FEL) & g_149)) && g_149) | g_3) | 0x2D17L), g_93, l_290) & 0x5FB8L) + (uint32_t)(*l_280)) | l_291);
                    }
                    else
                    { /* block id: 219 */
                        uint32_t l_306 = 0xA603679CL;
                        int32_t *l_309 = &l_274;
                        (*l_309) ^= ((((int32_t)l_282 % (int32_t)(~(((((int16_t)(((uint16_t)0x4C04L >> (uint16_t)14) <= ((int32_t)((int16_t)((65535UL & ((int32_t)func_85(p_56, l_306, l_306, g_129.f0) % (int32_t)((int32_t)l_306 % (int32_t)0x1AB90A9BL))) == 0x53C1L) + (int16_t)0xBF7EL) + (int32_t)l_306)) % (int16_t)(-2L)) > l_282) < g_40.f0) >= g_40.f0))) > l_306) <= l_306);
                    }
                    (**g_155) = l_310;
                }
            }
        }
        else
        { /* block id: 225 */
            (*g_155) = (*g_155);
            for (l_211 = (-14); (l_211 >= 7); l_211 += 5)
            { /* block id: 229 */
                int32_t *l_313 = &g_233;
                l_313 = (void*)0;
            }
        }
        (*g_156) = l_206;
    }
    else
    { /* block id: 234 */
        for (l_211 = 0; (l_211 <= 49); l_211 += 4)
        { /* block id: 237 */
            struct S0 **l_317 = &l_316;
            (*l_317) = l_316;
        }
        (*l_226) &= 0xD655A31AL;
        p_56 = p_56;
        for (g_233 = 0; (g_233 > 18); g_233 += 1)
        { /* block id: 244 */
            return g_129;
        }
    }
    return g_191;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f0 g_3 g_95 g_93 g_40 g_149 g_155 g_129.f0 g_156 g_191.f0 g_191
 * writes: g_95 g_3 g_93 g_129 g_149 g_155 g_191
 */
static struct S0 * func_58(uint32_t  p_59, uint16_t  p_60, uint32_t  p_61, uint16_t  p_62)
{ /* block id: 43 */
    struct S0 *l_90 = &g_40;
    int32_t l_91 = (-1L);
    struct S0 *l_205 = &g_191;
    (*l_205) = func_65(p_61, func_69(func_75((((uint32_t)g_40.f0 - (uint32_t)((int32_t)((int16_t)9L >> (int16_t)func_85(l_90, ((&g_40 == (void*)0) > g_40.f0), g_40.f0, l_91)) + (int32_t)1L)) || 0xD736L), g_40.f0, g_40.f0), g_40, g_40.f0, l_90, l_90), g_40.f0);
    (**g_155) = (void*)0;
    return l_205;
}


/* ------------------------------------------ */
/* 
 * reads : g_156 g_155 g_149 g_191
 * writes: g_95 g_149
 */
inline static struct S0  func_65(int16_t  p_66, struct S0 * p_67, int16_t  p_68)
{ /* block id: 162 */
    int32_t *l_203 = (void*)0;
    int32_t *l_204 = &g_149;
    (*g_156) = l_203;
    (**g_155) = l_203;
    (*l_204) ^= 0x39184E9DL;
    return (*p_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f0 g_149 g_129.f0 g_40 g_191.f0 g_93 g_129
 * writes: g_149 g_129.f0 g_191 g_93
 */
inline static struct S0 * func_69(int32_t  p_70, struct S0  p_71, uint16_t  p_72, struct S0 * p_73, struct S0 * p_74)
{ /* block id: 139 */
    int32_t l_184 = (-8L);
    int32_t *l_185 = &g_149;
    struct S0 *l_192 = &g_191;
    (*l_185) |= (l_184 || (g_40.f0 && (-9L)));
    if (((int32_t)(*l_185) + (int32_t)(-1L)))
    { /* block id: 141 */
        for (g_129.f0 = 0; (g_129.f0 != 28); g_129.f0 += 1)
        { /* block id: 144 */
            struct S0 *l_190 = &g_191;
            (*l_190) = g_40;
            (*l_190) = (*p_74);
        }
        return l_192;
    }
    else
    { /* block id: 149 */
        int32_t ****l_193 = &g_155;
        (*l_185) ^= (l_193 == &g_155);
        for (p_72 = 0; (p_72 >= 15); p_72 += 1)
        { /* block id: 153 */
            int32_t *l_196 = &g_93;
            int32_t *****l_197 = &l_193;
            (*l_185) = ((l_196 == (void*)0) || (*l_185));
            (*l_197) = l_193;
            if (p_72)
                break;
        }
        (*l_185) = p_71.f0;
    }
    g_93 &= ((((g_149 < (*l_185)) != g_191.f0) < (((uint16_t)0xB521L >> (uint16_t)3) || (~p_72))) || ((p_71.f0 ^ (p_71.f0 ^ g_129.f0)) < func_75(((int32_t)g_191.f0 - (int32_t)p_70), g_40.f0, (*l_185))));
    return l_192;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_75(uint32_t  p_76, uint32_t  p_77, uint32_t  p_78)
{ /* block id: 136 */
    struct S0 l_182 = {0xCD9D43CFL};
    uint32_t l_183 = 0xF2D68B99L;
    l_182 = l_182;
    return l_183;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_95 g_93 g_40 g_149 g_155 g_129.f0 g_156 g_191 g_129
 * writes: g_95 g_3 g_93 g_129 g_149 g_155
 */
inline static int16_t  func_85(struct S0 * p_86, int32_t  p_87, int32_t  p_88, uint16_t  p_89)
{ /* block id: 44 */
    int32_t *l_92 = &g_93;
    int32_t **l_94 = (void*)0;
    struct S0 l_140 = {0xCA7CC927L};
    g_95 = l_92;
    for (g_3 = (-24); (g_3 >= 10); g_3 += 4)
    { /* block id: 48 */
        int32_t *l_117 = &g_93;
        int32_t *l_124 = &g_93;
        int16_t l_141 = 0x574DL;
        int32_t ****l_157 = (void*)0;
        int32_t ****l_158 = (void*)0;
        int32_t ***l_159 = &g_156;
        if ((*g_95))
        { /* block id: 49 */
            uint32_t l_99 = 0UL;
            int32_t *l_100 = &g_93;
            int32_t l_109 = 0x3CDB7CFFL;
            if ((0x80627DBDL ^ ((0UL && (-(int16_t)l_99)) ^ g_3)))
            { /* block id: 50 */
                int32_t l_120 = (-2L);
                (*g_95) &= 0x7C80BFD7L;
                l_100 = &g_93;
                for (p_88 = 15; (p_88 < 13); p_88 -= 1)
                { /* block id: 55 */
                    uint32_t l_116 = 4294967291UL;
                    if (((uint16_t)(0x3FE8L ^ 0xE0EFL) >> (uint16_t)((uint16_t)((uint16_t)l_109 << (uint16_t)p_87) % (uint16_t)0x36B4L)))
                    { /* block id: 56 */
                        int16_t l_115 = 0x8AEAL;
                        int32_t **l_118 = (void*)0;
                        int32_t **l_119 = &l_117;
                        (*l_92) = ((int16_t)(65530UL ^ (((((-(uint16_t)__builtin_ffs(((((uint16_t)(*l_100) + (uint16_t)(p_88 < l_115)) < 0x016C6A45L) && p_87))) == ((&g_40 != p_86) & 0xF0774A76L)) & p_89) | l_116) & p_89)) + (int16_t)g_93);
                        (*l_119) = l_117;
                        (*l_92) |= __builtin_popcount(l_120);
                    }
                    else
                    { /* block id: 60 */
                        return p_87;
                    }
                }
            }
            else
            { /* block id: 64 */
                int16_t l_123 = (-1L);
                g_95 = &p_87;
                (*l_100) |= ((int16_t)(&p_88 == (void*)0) << (int16_t)7);
                if (l_123)
                { /* block id: 67 */
                    int32_t **l_125 = &l_117;
                    if (p_89)
                        break;
                    (*l_125) = l_124;
                }
                else
                { /* block id: 70 */
                    uint32_t l_133 = 0UL;
                    for (p_89 = 4; (p_89 >= 15); p_89 += 1)
                    { /* block id: 73 */
                        struct S0 *l_128 = (void*)0;
                        int32_t **l_130 = &l_124;
                        g_129 = g_40;
                        (*l_124) ^= __builtin_parityl(__builtin_ctzl(p_87));
                        (*l_92) = (*g_95);
                        (*l_130) = &p_88;
                    }
                    if ((*g_95))
                        continue;
                    (*l_117) &= (g_40.f0 || ((int16_t)((l_133 & (p_86 == p_86)) | 0UL) - (int16_t)(0xEE84L > (p_89 >= p_87))));
                    (*g_95) &= (((int16_t)(g_3 != (~((int32_t)(*l_100) + (int32_t)(g_93 >= g_40.f0)))) << (int16_t)(-(int32_t)(p_89 | p_89))) <= (g_93 > g_40.f0));
                }
            }
            l_140 = (*p_86);
            if (p_87)
                break;
            if (l_141)
                break;
        }
        else
        { /* block id: 87 */
            uint32_t l_153 = 0xD1F82652L;
            int32_t *l_154 = &g_149;
            for (g_93 = 0; (g_93 > 25); g_93 += 7)
            { /* block id: 90 */
                int32_t l_150 = 1L;
                for (g_129.f0 = 0; (g_129.f0 <= (-23)); g_129.f0 -= 1)
                { /* block id: 93 */
                    for (l_141 = 26; (l_141 < (-20)); l_141 -= 1)
                    { /* block id: 96 */
                        int32_t *l_148 = &g_149;
                        l_148 = &g_93;
                        l_150 ^= p_87;
                        p_88 |= 1L;
                        g_149 &= ((&p_88 != (void*)0) < p_89);
                    }
                    return (*l_92);
                }
            }
            (*l_154) &= ((int32_t)(g_93 | l_153) - (int32_t)(*l_124));
            if ((*l_124))
                break;
        }
        if ((*g_95))
            continue;
        l_159 = g_155;
    }
    if ((65532UL == ((int16_t)((*l_92) || (((+((((&g_155 == (void*)0) <= g_40.f0) | ((uint32_t)((uint16_t)(+((*l_92) == (__builtin_ia32_crc32qi((*l_92), (((int16_t)((-(int16_t)(((int16_t)g_129.f0 >> (int16_t)14) <= (*l_92))) > 1L) % (int16_t)g_40.f0) || g_40.f0)) | (*l_92)))) % (uint16_t)p_88) % (uint32_t)p_88)) == g_129.f0)) != 0x39AD6F16L) ^ p_88)) >> (int16_t)10)))
    { /* block id: 111 */
        int32_t l_173 = 0L;
        (**g_156) = (l_173 || l_173);
        (**g_155) = (void*)0;
        (*l_92) &= p_89;
        g_149 &= ((*l_92) || l_173);
    }
    else
    { /* block id: 116 */
        uint32_t l_174 = 18446744073709551615UL;
        int32_t ***l_176 = &g_156;
        if (l_174)
        { /* block id: 117 */
            uint16_t l_175 = 0x59B2L;
            (*g_95) &= ((l_174 > l_174) && 0x4C9D4284L);
            return l_175;
        }
        else
        { /* block id: 120 */
            int32_t ****l_177 = &g_155;
            (*l_177) = l_176;
            (**g_155) = (*g_156);
        }
    }
    for (g_149 = (-20); (g_149 <= (-12)); g_149 += 1)
    { /* block id: 127 */
        for (g_3 = 26; (g_3 < 34); g_3 += 4)
        { /* block id: 130 */
            (*l_92) ^= (p_87 != (g_40.f0 >= 1L));
        }
        if (p_88)
            break;
    }
    return g_149;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_40.f0, "g_40.f0", print_hash_value);
    transparent_crc(g_93, "g_93", print_hash_value);
    transparent_crc(g_129.f0, "g_129.f0", print_hash_value);
    transparent_crc(g_149, "g_149", print_hash_value);
    transparent_crc(g_191.f0, "g_191.f0", print_hash_value);
    transparent_crc(g_233, "g_233", print_hash_value);
    transparent_crc(g_346, "g_346", print_hash_value);
    transparent_crc(g_382, "g_382", print_hash_value);
    transparent_crc(g_585, "g_585", print_hash_value);
    transparent_crc(g_646, "g_646", print_hash_value);
    transparent_crc(g_682, "g_682", print_hash_value);
    transparent_crc(g_701, "g_701", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 184
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 271
   depth: 2, occurrence: 49
   depth: 3, occurrence: 17
   depth: 4, occurrence: 7
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 5
   depth: 11, occurrence: 2
   depth: 13, occurrence: 6
   depth: 14, occurrence: 5
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 125

XXX times a variable address is taken: 144
XXX times a pointer is dereferenced on RHS: 103
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 19
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 119
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 20
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 36
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 827

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 4405
   level: 2, occurrence: 461
   level: 3, occurrence: 134
   level: 4, occurrence: 91
   level: 5, occurrence: 37
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 45
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 16
XXX average alias set size: 1.26

XXX times a non-volatile is read: 866
XXX times a non-volatile is write: 367
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 238
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 28
   depth: 2, occurrence: 40
   depth: 3, occurrence: 32
   depth: 4, occurrence: 44
   depth: 5, occurrence: 62

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
********************* end of statistics **********************/

