/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1633843410
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t  func_2(uint16_t  p_3);
static int32_t  func_11(uint8_t  p_12, int32_t  p_13, int32_t  p_14);
static int32_t * func_22(int32_t * p_23, uint32_t  p_24, int32_t * p_25, uint32_t  p_26);
static int32_t * func_27(int32_t * p_28, const int32_t * p_29, uint8_t  p_30, int32_t  p_31);
static uint8_t  func_39(int32_t  p_40, int32_t * p_41, int32_t  p_42);
static int32_t  func_43(uint32_t  p_44, uint32_t  p_45);
static int16_t  func_48(int32_t * p_49, const int32_t * p_50, uint32_t  p_51, int32_t  p_52);
static int16_t  func_57(int16_t  p_58, uint32_t  p_59);
static const uint16_t  func_62(int32_t  p_63, uint16_t  p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_10 = 0x3FL;
    int32_t l_21 = 0L;
    int32_t *l_673 = &l_21;
    uint32_t l_674 = 0x53D1A51DL;
    (*l_673) = func_2((safe_rshift_func_int16_t_s_u((safe_mod_func_int16_t_s_s((safe_mod_func_int32_t_s_s((l_10 < (l_10 | (l_10 >= l_10))), ((l_10 , (func_11((((-1L) && 0x69161D59L) ^ l_10), ((safe_add_func_uint32_t_u_u((safe_div_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((l_10 <= l_10), 14)), 0x6C84L)), l_21)) == l_10), l_21) , l_21)) || l_10))), l_10)), l_10)));
    return l_674;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_2(uint16_t  p_3)
{ /* block id: 194 */
    uint32_t l_660 = 1UL;
    int32_t l_671 = 0x613C0B62L;
    int32_t *l_670 = &l_671;
    int32_t *l_672 = &l_671;
    for (p_3 = 0; (p_3 <= 10); p_3 = safe_add_func_int32_t_s_s(p_3, 3))
    { /* block id: 197 */
        int32_t l_656 = 5L;
        int32_t *l_655 = &l_656;
        int32_t * const **l_659 = (void*)0;
        int32_t * const ***l_658 = &l_659;
        int32_t * const ****l_657 = &l_658;
        int32_t ***** const l_669 = (void*)0;
        (*l_655) = (((0x0DCBL ^ ((((((((((((((l_655 != &l_656) & ((l_657 != ((l_660 , p_3) , &l_658)) || ((safe_add_func_int32_t_s_s((safe_mod_func_uint16_t_u_u(p_3, (safe_mod_func_int16_t_s_s((((safe_div_func_uint32_t_u_u((p_3 & p_3), (-2L))) , (*l_655)) <= l_660), p_3)))), 0x69665335L)) && 0x7B65L))) || p_3) , 0x8F0CL) < (-7L)) , l_669) != (void*)0) > p_3) || 8L) && 0x4A12E70FL) > 0x9955L) , 0x5809L) == 0x3F00L) ^ 0x5C8AC8BCL)) > 0xDE85L) & l_660);
    }
    l_672 = l_670;
    return p_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_11(uint8_t  p_12, int32_t  p_13, int32_t  p_14)
{ /* block id: 1 */
    int32_t l_33 = 0x79DC8669L;
    int32_t *l_32 = &l_33;
    int32_t l_360 = 0x3DFF51BFL;
    int32_t l_617 = 6L;
    uint32_t l_618 = 0x8BCC4756L;
    int32_t **l_642 = (void*)0;
    int32_t **l_643 = &l_32;
    uint8_t l_651 = 0x64L;
    uint32_t l_652 = 3UL;
    l_32 = func_22(func_27(l_32, &l_33, p_13, (*l_32)), p_12, &l_360, p_13);
    /* statement id: 190 */
    assert (l_32 == 0);
    (*l_643) = &l_360;
    /* statement id: 191 */
    assert (l_32 == &l_360);
    (**l_643) = (((!((((p_13 | ((p_12 | (safe_mod_func_int16_t_s_s((((0xBBA4L >= (((1L & p_12) , ((safe_add_func_uint16_t_u_u(((((~(((*l_32) == (((0x0B8EL && (safe_unary_minus_func_uint16_t_u(((p_12 <= p_14) == p_14)))) , 9UL) , l_651)) | p_13)) , (**l_643)) != 0xEF226132L) < (**l_643)), (*l_32))) , (-3L))) > 0L)) , (*l_643)) != (void*)0), (**l_643)))) && 0xE00D3385L)) , &l_32) == (void*)0) , (**l_643))) , (-8L)) >= p_14);
    return l_652;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_22(int32_t * p_23, uint32_t  p_24, int32_t * p_25, uint32_t  p_26)
{ /* block id: 186 */
    int32_t l_631 = (-7L);
    const int16_t l_639 = 1L;
    int32_t *** const *l_641 = (void*)0;
    int32_t *** const **l_640 = &l_641;
    (*p_25) = ((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s(((safe_add_func_int32_t_s_s(((((~((safe_add_func_int16_t_s_s(1L, (safe_add_func_int16_t_s_s(((((((~l_631) <= (~(safe_sub_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u(p_26, l_631)), (p_26 , (p_26 && (((0xF782L && (safe_rshift_func_uint16_t_u_s(p_26, (l_639 , l_631)))) || p_24) == 0xDA89L))))))) != 0xF280L) | 0x89B8L) == p_26) , p_24), l_631)))) <= p_24)) , &l_631) == p_23) , l_631), 0x9672B6EEL)) & l_631), l_631)) ^ l_639), l_639)) ^ p_26);
    l_640 = (void*)0;
    /* statement id: 188 */
    assert (l_640 == 0);
    return p_23;
    /* statement id: 189 */
    //assert (func_22_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_27(int32_t * p_28, const int32_t * p_29, uint8_t  p_30, int32_t  p_31)
{ /* block id: 2 */
    uint16_t l_34 = 65535UL;
    int32_t l_35 = 0xC254E7F1L;
    int32_t *l_36 = &l_35;
    int32_t *l_37 = &l_35;
    int32_t *l_38 = (void*)0;
    (*p_28) = l_34;
    l_35 = l_34;
    return l_38;
    /* statement id: 5 */
    //assert (func_27_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_39(int32_t  p_40, int32_t * p_41, int32_t  p_42)
{ /* block id: 96 */
    int32_t **l_363 = (void*)0;
    int32_t ***l_362 = &l_363;
    int32_t ****l_361 = &l_362;
    int32_t l_366 = 0x44CAA32AL;
    int32_t **l_367 = (void*)0;
    int32_t *l_368 = (void*)0;
    int16_t l_369 = (-2L);
    uint8_t l_380 = 0xAAL;
    int32_t ***l_394 = (void*)0;
    int32_t l_456 = 0x890D855FL;
    uint32_t l_457 = 0xCE5E2CB4L;
    int32_t l_487 = 0xAD85B41FL;
    uint8_t l_488 = 0xABL;
    int32_t l_489 = 0x7E91F3F9L;
    uint8_t l_522 = 255UL;
    const int32_t *l_538 = (void*)0;
    const int32_t *l_539 = &l_489;
    int16_t l_577 = 0x1DD0L;
    int16_t l_598 = (-5L);
    uint16_t l_614 = 0xD1ADL;
    uint16_t l_615 = 65530UL;
    int32_t *l_616 = &l_489;
    l_369 = ((l_361 == (void*)0) >= (safe_div_func_uint16_t_u_u((((((p_42 , p_40) , (((p_41 == p_41) != ((l_366 >= ((void*)0 == l_367)) && 0x8C9DC0F5L)) , p_41)) == p_41) == 0x8615L) , l_366), p_42)));
    if (p_40)
    { /* block id: 98 */
        int32_t *l_370 = &l_366;
        int32_t l_371 = 0x7DE085DBL;
        int32_t ****l_372 = &l_362;
        int32_t l_379 = 0xEB5C6CAAL;
        (*l_370) = (&p_41 == &p_41);
        (*l_370) = ((*l_370) && (((((((((l_371 & ((((*l_370) , (&l_362 == l_372)) < 0x74275F44L) >= (((safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s(((*l_370) , (*l_370)), ((safe_div_func_int16_t_s_s((*l_370), l_379)) , (*l_370)))), 1UL)) < 0x792CE18CL) >= (*l_370)))) == 3L) && p_42) >= l_380) | 1L) & p_42) && 0xB7C80019L) < p_42) ^ p_40));
    }
    else
    { /* block id: 101 */
        uint16_t l_381 = 0x1850L;
        int32_t l_382 = 0x6CBB30CCL;
        int32_t ***** const l_433 = &l_361;
        uint32_t l_434 = 0x2F686EF7L;
        uint8_t l_558 = 255UL;
        uint16_t l_565 = 0xEEB8L;
lbl_411:
        l_382 = l_381;
        for (p_40 = 0; (p_40 == 27); p_40 = safe_add_func_uint16_t_u_u(p_40, 3))
        { /* block id: 105 */
            const int32_t l_385 = 0xF5A1C232L;
            int32_t l_386 = 0xE53A0D33L;
            int32_t ***l_429 = &l_363;
            uint8_t l_432 = 7UL;
            l_386 = l_385;
            if ((((safe_add_func_int32_t_s_s((-1L), ((65535UL < ((p_40 && 7L) >= p_42)) ^ (l_385 != 0x7DFFL)))) == (safe_rshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s((((*l_361) != ((~(l_394 != (*l_361))) , (*l_361))) < p_40), 0xB6993E92L)), 15))) , l_385))
            { /* block id: 107 */
                const int32_t * const l_412 = &l_382;
                for (l_380 = 0; (l_380 > 27); l_380 = safe_add_func_int16_t_s_s(l_380, 8))
                { /* block id: 110 */
                    int32_t l_397 = 0L;
                    int32_t l_409 = 0x06B6CE06L;
                    l_386 = ((l_381 ^ (p_42 & p_40)) || (p_40 , 0xA0EC81A7L));
                    if (l_397)
                    { /* block id: 112 */
                        int16_t l_398 = (-10L);
                        int32_t l_399 = 4L;
                        l_399 = l_398;
                        l_382 = 0x8735869CL;
                        return p_42;
                    }
                    else
                    { /* block id: 116 */
                        const int32_t *l_403 = &l_385;
                        const int32_t **l_402 = &l_403;
                        const int32_t ***l_401 = &l_402;
                        const int32_t *** const *l_400 = &l_401;
                        const int32_t * const *l_407 = &l_403;
                        const int32_t * const **l_406 = &l_407;
                        const int32_t * const ***l_405 = &l_406;
                        const int32_t * const ****l_404 = &l_405;
                        int32_t l_408 = (-5L);
                        (*l_404) = l_400;
                        /* statement id: 117 */
                        assert (l_405 == &l_401);
                        (**l_401) = (***l_400);
                        l_408 = p_42;
                        l_409 = l_382;
                    }
                    if ((7UL ^ l_397))
                    { /* block id: 122 */
                        int32_t **l_410 = &l_368;
                        (*l_410) = p_41;
                        /* statement id: 123 */
                        //assert (l_368 == &l_33);
                    }
                    else
                    { /* block id: 124 */
                        int32_t **l_413 = &l_368;
                        if (l_382)
                            goto lbl_411;
                        (*l_413) = l_412;
                        /* statement id: 126 */
                        assert (l_368 == &l_382);
                        (*l_368) = ((safe_sub_func_uint16_t_u_u(65533UL, (p_42 , ((*l_368) != (!0x0539L))))) | 1L);
                    }
                    /* facts after branching */
                    //assert (l_368 == &l_382 || l_368 == &l_33);
                }
                if (p_40)
                    continue;
            }
            else
            { /* block id: 131 */
                return p_42;
            }
            l_366 = (safe_mod_func_uint32_t_u_u(((safe_add_func_int16_t_s_s(p_42, p_40)) || l_385), ((1L && p_42) | (((safe_add_func_int32_t_s_s(((safe_add_func_uint32_t_u_u((((safe_mod_func_uint32_t_u_u((((((safe_sub_func_uint32_t_u_u((l_381 >= ((l_429 == (void*)0) > (safe_lshift_func_int16_t_s_s(((0x666B9C21L <= l_432) != l_382), 15)))), p_40)) && 1L) < 0xB47BL) , &l_361) == l_433), l_434)) == 1L) == p_42), 1UL)) , p_40), 0x45471E00L)) && 0xB52C3858L) , 0x0E07L))));
        }
        if (((((safe_add_func_uint16_t_u_u(p_40, p_40)) == (safe_sub_func_uint32_t_u_u((p_42 || ((safe_div_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(((((safe_mod_func_uint16_t_u_u(((safe_mod_func_int32_t_s_s((safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u((0x05023016L == (safe_lshift_func_uint16_t_u_u(((safe_unary_minus_func_int32_t_s((((p_40 >= 0x3E78L) , l_433) != l_433))) < ((p_42 <= 0UL) >= p_40)), 6))), (-5L))) , 0UL), 8)), p_42)), 0xCD12A0E9L)) < 1L), 65535UL)) & p_40) != l_456) & 1UL), 14)), p_42)) || 65535UL)), l_434))) != l_457) || l_382))
        { /* block id: 136 */
            uint32_t l_458 = 0x6F35DE22L;
            l_458 = 0L;
        }
        else
        { /* block id: 138 */
            const int32_t *l_462 = &l_382;
            const int32_t **l_461 = &l_462;
            const int32_t ***l_460 = &l_461;
            int16_t l_523 = 0x451BL;
            int32_t l_535 = (-2L);
            if (((!p_40) || ((((l_460 != (p_40 , (*l_361))) && p_40) >= p_40) >= (1UL ^ 0xD4F1L))))
            { /* block id: 139 */
                int32_t l_472 = 0L;
                int32_t *l_490 = &l_489;
                (**l_460) = l_490;
                /* statement id: 140 */
                assert (l_462 == &l_489);
                for (l_381 = 0; (l_381 <= 52); l_381 = safe_add_func_uint16_t_u_u(l_381, 1))
                { /* block id: 143 */
                    uint32_t l_508 = 0UL;
                    const int32_t ****l_526 = &l_460;
                }
            }
            else
            { /* block id: 149 */
                uint32_t l_545 = 0xBF13F1C3L;
                int32_t ** const *l_548 = &l_367;
                int32_t ** const **l_547 = &l_548;
                int32_t ** const ***l_546 = &l_547;
                int32_t *l_555 = &l_489;
                (**l_460) = p_41;
                /* statement id: 150 */
                //assert (l_462 == &l_33);
                (**l_361) = (*l_362);
                for (l_535 = 0; (l_535 >= 14); ++l_535)
                { /* block id: 154 */
                    int32_t l_540 = (-5L);
                    l_538 = (**l_460);
                    /* statement id: 155 */
                    //assert (l_538 == &l_489 || l_538 == &l_33);
                    (**l_460) = l_539;
                    /* statement id: 156 */
                    assert (l_462 == &l_489);
                    l_540 = 1L;
                }
                /* facts after for loop */
                //assert (l_462 == &l_489 || l_462 == &l_33);
                //assert (l_538 == &l_489 || l_538 == &l_33 || l_538 == 0);
                (*l_555) = (safe_rshift_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u(((l_545 ^ ((l_546 != ((safe_mod_func_uint32_t_u_u(4294967295UL, ((((safe_sub_func_int32_t_s_s(((void*)0 == &p_41), p_40)) <= (safe_div_func_int16_t_s_s(p_42, (*l_539)))) & (&p_41 == &p_41)) ^ (-1L)))) , (void*)0)) > p_42)) <= p_42), 7L)), p_40));
            }
            /* facts after branching */
            //assert (l_462 == &l_489 || l_462 == &l_33);
            //assert (l_538 == &l_489 || l_538 == &l_33 || l_538 == 0);
            for (l_369 = 27; (l_369 == (-24)); --l_369)
            { /* block id: 163 */
                if (l_558)
                    break;
                if (p_40)
                    continue;
            }
            if ((((safe_mul_func_int32_t_s_s(p_42, ((safe_lshift_func_uint16_t_u_s(((safe_add_func_uint32_t_u_u(l_565, (((safe_div_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(0x86771EE5L, ((safe_div_func_uint32_t_u_u(p_42, ((1L ^ (((safe_mod_func_uint32_t_u_u(((((p_42 || (safe_add_func_int32_t_s_s(((*l_361) == (void*)0), (p_42 >= p_42)))) >= p_42) <= 0xDD2CEE67L) | p_40), p_40)) , p_42) != 0L)) , p_42))) ^ (*l_539)))), p_40)) <= 0UL) > 65535UL))) , 1UL), p_42)) >= p_40))) > p_40) , p_40))
            { /* block id: 167 */
                const int32_t *l_576 = &l_366;
                int16_t l_589 = 0x469AL;
                p_41 = func_27(&l_535, &l_382, p_42, p_42);
                /* statement id: 168 */
                assert (p_41 == 0);
                l_535 = (*l_576);
                (**l_433) = (**l_433);
            }
            else
            { /* block id: 171 */
                int32_t *** const *l_590 = &l_362;
                int32_t * const *l_593 = (void*)0;
                int32_t * const **l_592 = &l_593;
                int32_t * const ***l_591 = &l_592;
                uint16_t l_601 = 65533UL;
                int32_t *l_602 = &l_366;
                l_535 = ((((void*)0 != l_590) > (l_591 == ((safe_sub_func_uint32_t_u_u(((((((((((p_40 , ((safe_add_func_int32_t_s_s((0xA86C76ADL & p_42), (p_40 , ((l_598 > (safe_mod_func_uint16_t_u_u(p_40, p_42))) | p_42)))) | 1L)) & 0x6819L) , p_42) | p_42) >= 0xE48CL) >= 0x4BF5F5D1L) != 0UL) || p_40) > 0UL) , (*l_539)), p_40)) , (void*)0))) & p_42);
                (*l_602) = l_601;
            }
            /* facts after branching */
            //assert (p_41 == &l_33 || p_41 == 0);
        }
        /* facts after branching */
        //assert (p_41 == &l_33 || p_41 == 0);
        //assert (l_538 == &l_489 || l_538 == &l_33 || l_538 == 0);
        for (l_489 = 14; (l_489 > (-20)); --l_489)
        { /* block id: 178 */
            int32_t **l_605 = &l_368;
            int32_t *l_606 = &l_366;
            (*l_605) = p_41;
            /* statement id: 179 */
            //assert (l_368 == &l_33 || l_368 == 0);
            (*l_606) = ((void*)0 == (*l_361));
        }
    }
    /* facts after branching */
    //assert (p_41 == &l_33 || p_41 == 0);
    //assert (l_368 == dangling || l_368 == &l_33 || l_368 == 0);
    //assert (l_538 == &l_489 || l_538 == &l_33 || l_538 == 0);
    l_361 = (void*)0;
    /* statement id: 183 */
    assert (l_361 == 0);
    (*l_616) = (((((((((*l_539) >= (safe_lshift_func_uint16_t_u_u((&p_41 == (*l_362)), 0))) , 6UL) , ((((((((((void*)0 == &p_41) , 0xE80BL) <= (((((((~p_42) || (safe_lshift_func_uint16_t_u_s((((safe_lshift_func_int16_t_s_u(((((p_42 , &p_41) != &p_41) , (*l_539)) && p_42), (*l_539))) | l_614) != p_40), 7))) != 4294967290UL) , (void*)0) != p_41) ^ (*l_539)) & 7L)) & l_615) != p_42) , 1UL) > p_42) , &l_363) != &l_367)) > 65535UL) , p_40) ^ 0x340EL) || p_42) <= 0x6EAD3630L);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_43(uint32_t  p_44, uint32_t  p_45)
{ /* block id: 6 */
    int32_t l_54 = 2L;
    int32_t *l_53 = &l_54;
    (*l_53) = (safe_mod_func_int16_t_s_s(func_48(l_53, &l_54, (((*l_53) | ((((safe_mod_func_int16_t_s_s(func_57((safe_mod_func_uint16_t_u_u(func_62((*l_53), (safe_unary_minus_func_int16_t_s(p_45))), ((*l_53) & ((((0UL || p_44) , (*l_53)) , 0xBBCEECF2L) ^ p_44)))), (*l_53)), 0xE998L)) , 2UL) , 5UL) >= (*l_53))) , 1UL), (*l_53)), 0x389EL));
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_48(int32_t * p_49, const int32_t * p_50, uint32_t  p_51, int32_t  p_52)
{ /* block id: 91 */
    int32_t l_357 = (-6L);
    int32_t * const l_356 = &l_357;
    int32_t *l_359 = &l_357;
    int32_t **l_358 = &l_359;
    (*l_358) = l_356;
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_57(int16_t  p_58, uint32_t  p_59)
{ /* block id: 79 */
    uint32_t l_333 = 18446744073709551615UL;
    int32_t l_354 = 0x5C20B6E1L;
    int32_t *l_353 = &l_354;
    uint16_t l_355 = 1UL;
    if (l_333)
    { /* block id: 80 */
        int32_t l_349 = (-2L);
        int32_t *l_348 = &l_349;
        int32_t **l_347 = &l_348;
        int32_t ***l_346 = &l_347;
        int32_t ****l_351 = (void*)0;
        int32_t *****l_350 = &l_351;
        int32_t l_352 = (-6L);
        for (p_58 = (-23); (p_58 >= 4); p_58 = safe_add_func_uint32_t_u_u(p_58, 4))
        { /* block id: 83 */
            int32_t l_345 = 0x75C1F3D9L;
            int32_t *l_344 = &l_345;
            int32_t **l_343 = &l_344;
            int32_t ***l_342 = &l_343;
            (**l_342) = ((((p_59 == p_59) , (((((safe_mod_func_uint32_t_u_u((((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s((((((l_342 != l_346) & 9L) >= 0xF420L) > (**l_343)) < (l_350 == (void*)0)), 1)), p_59)) , p_58) | l_352), p_59)) == 0xF07718F6L) > l_333) , p_58) , l_333)) & l_333) , l_353);
            /* statement id: 84 */
            assert (l_344 == &l_354);
            if (p_59)
                continue;
        }
    }
    else
    { /* block id: 87 */
        return p_58;
    }
    return l_355;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_62(int32_t  p_63, uint16_t  p_64)
{ /* block id: 7 */
    int32_t l_76 = 0x5545654AL;
    int32_t *l_75 = &l_76;
    const int16_t l_87 = 0x3BCEL;
    int16_t l_91 = (-1L);
    uint32_t l_108 = 0UL;
    int32_t **l_117 = (void*)0;
    int32_t ***l_116 = &l_117;
    int32_t l_137 = 0x6D738FFAL;
    int32_t l_265 = 1L;
    uint32_t l_292 = 0x12DD5A0DL;
    int16_t l_327 = 0xA488L;
    (*l_75) = (safe_lshift_func_uint16_t_u_u((((safe_mod_func_uint16_t_u_u((((safe_mod_func_int32_t_s_s((safe_div_func_uint16_t_u_u(((~(&p_63 == &p_63)) , (((0x1002A956L == (((l_75 == (void*)0) != (safe_rshift_func_uint16_t_u_u((safe_div_func_int32_t_s_s(0L, (safe_mod_func_int16_t_s_s((safe_sub_func_int16_t_s_s((safe_sub_func_int16_t_s_s((((void*)0 == &p_63) == (*l_75)), p_63)), (-8L))), (*l_75))))), l_87))) , p_63)) >= (*l_75)) <= (*l_75))), (*l_75))), (-1L))) ^ (*l_75)) | (*l_75)), (-1L))) , &p_63) == &l_76), 5));
    if (((safe_lshift_func_int16_t_s_s((((((~l_91) == ((safe_sub_func_uint16_t_u_u((((safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((((void*)0 != &p_63) == 0x67BE229AL), 12)), (safe_div_func_int16_t_s_s((&p_63 == &p_63), (safe_add_func_int32_t_s_s(((*l_75) , ((((safe_div_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(4294967288UL, (safe_sub_func_int32_t_s_s(l_108, 0x7F3D9679L)))), 65527UL)) & p_63) >= 4294967295UL) && p_64)), (*l_75))))))) > p_64) >= 1L), 0xEAACL)) | 0xB4A0L)) == (*l_75)) >= p_63) > 4UL), 13)) | 0x4AE9L))
    { /* block id: 9 */
        int32_t **l_109 = &l_75;
        int32_t ***l_110 = &l_109;
        (*l_110) = l_109;
    }
    else
    { /* block id: 11 */
        const int32_t l_125 = 6L;
        int32_t **l_126 = &l_75;
        uint16_t l_161 = 0x62B7L;
        int16_t l_219 = 1L;
        int32_t ****l_280 = &l_116;
        int32_t *****l_281 = &l_280;
        uint8_t l_302 = 255UL;
        for (p_64 = 8; (p_64 >= 51); p_64 = safe_add_func_uint16_t_u_u(p_64, 6))
        { /* block id: 14 */
            int32_t **l_113 = &l_75;
            const uint16_t l_231 = 0x8623L;
            (*l_113) = &l_76;
            for (l_76 = 15; (l_76 >= (-5)); --l_76)
            { /* block id: 18 */
                int32_t *l_127 = &l_76;
                int32_t l_136 = 0x4487636FL;
                uint32_t l_160 = 0x2824790DL;
                int32_t ** const *l_236 = &l_126;
                if ((((**l_113) <= (p_63 ^ (**l_113))) < (((((void*)0 != l_116) & ((safe_unary_minus_func_int32_t_s(0x03F479F8L)) , (((((p_64 , (safe_div_func_uint32_t_u_u(((safe_lshift_func_uint16_t_u_u(0UL, 9)) <= (safe_sub_func_int16_t_s_s(l_125, p_63))), 1UL))) <= (**l_113)) & p_64) , p_64) == (**l_113)))) == l_125) ^ l_125)))
                { /* block id: 19 */
                    int32_t **l_128 = &l_127;
                    if ((l_126 != l_126))
                    { /* block id: 20 */
                        (*l_126) = l_127;
                        p_63 = (((0x0D3FL > ((void*)0 != (*l_113))) , l_126) != l_128);
                    }
                    else
                    { /* block id: 23 */
                        if ((**l_113))
                            break;
                    }
                    (*l_116) = l_128;
                    /* statement id: 26 */
                    assert (l_117 == &l_127);
                    l_137 = ((((void*)0 != &l_117) && ((safe_sub_func_int16_t_s_s(((p_64 ^ ((((**l_117) < (safe_lshift_func_uint16_t_u_u((*l_75), ((~((l_126 != &l_127) > ((safe_add_func_int32_t_s_s(((void*)0 == (*l_113)), (-1L))) > p_64))) , l_136)))) || 0xE04930E3L) , 0x18BAL)) <= (*l_75)), 0xD0E3L)) < (**l_117))) == 4294967295UL);
                }
                else
                { /* block id: 28 */
                    int32_t l_159 = 0x460C9FB3L;
                    int32_t l_162 = (-1L);
                    l_162 = (!(((*l_127) | (safe_sub_func_int16_t_s_s(p_63, ((safe_add_func_int32_t_s_s(((((safe_rshift_func_int16_t_s_s(((((safe_div_func_uint16_t_u_u((+(((safe_mod_func_uint32_t_u_u(1UL, (safe_lshift_func_int16_t_s_s((-1L), p_63)))) < (~p_64)) && (((safe_add_func_int32_t_s_s((safe_add_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u(9UL, p_63)), l_159)), p_64)) , (**l_126)) & 0x3AC0L))), l_160)) && (**l_113)) & p_63) > 0x0243L), (*l_127))) >= l_161) , (*l_75)) <= 1L), 0x76CEBAF4L)) >= 1L)))) ^ 0UL));
                    l_162 = ((-6L) | (safe_div_func_int16_t_s_s((l_113 != ((4294967288UL != (p_64 || ((safe_add_func_int16_t_s_s(((safe_div_func_int32_t_s_s((~(safe_lshift_func_int16_t_s_s((0xD66935DDL || (safe_add_func_int32_t_s_s((~((safe_div_func_int32_t_s_s(((((((((safe_rshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(((*l_113) == (void*)0), (safe_mod_func_uint16_t_u_u(((safe_add_func_int16_t_s_s(p_63, ((l_162 < (**l_126)) == l_159))) && p_64), 0x8C9FL)))), 10)) >= 5UL) <= p_64) <= p_64) | p_64) != 0x5279L) < (**l_126)) , p_63), (*l_127))) | (*l_75))), 0L))), 2))), 0x2228373BL)) && 0xB09ED61EL), (**l_126))) > (**l_113)))) , l_126)), p_63)));
                    if ((*l_75))
                    { /* block id: 31 */
                        const uint16_t l_185 = 0UL;
                        return l_185;
                    }
                    else
                    { /* block id: 33 */
                        int32_t l_218 = 0x0433D11FL;
                        int32_t *l_232 = &l_218;
                        p_63 = ((safe_rshift_func_uint16_t_u_s(((safe_add_func_uint32_t_u_u((((((p_64 , ((safe_sub_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((((safe_sub_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_s((safe_div_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s(((safe_add_func_uint32_t_u_u((*l_127), (((((safe_mod_func_int16_t_s_s((-9L), (safe_lshift_func_int16_t_s_u(((p_64 || (safe_mod_func_int16_t_s_s(((**l_126) | ((safe_sub_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u(l_159, 0x0832L)) , (((safe_lshift_func_uint16_t_u_u((l_218 != l_218), 10)) , 0xEC0DL) , p_63)), 0L)) >= (*l_127))), p_64))) , 0x0D7FL), l_218)))) , (*l_75)) == 0L) >= (**l_126)) && 0xC151L))) <= p_63), l_219)) < (**l_113)), 0x5B37L)), (**l_113))) | 1L), (*l_127))) < p_63) | p_64), 5)), p_64)) , l_159)) <= p_63) | 0xBAA7L) || 0L) || p_64), (**l_113))) | p_63), (*l_127))) & 0x6863D7E0L);
                        (*l_232) = (safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((((&l_126 == &l_126) && ((safe_div_func_int32_t_s_s(((*l_127) > (((**l_113) | ((&p_63 == (((**l_113) | (safe_unary_minus_func_uint16_t_u((**l_113)))) , &l_136)) , (l_218 < (*l_127)))) < p_64)), p_63)) | l_231)) != 0x9ADD7983L), p_63)), 1L)), 6)), (*l_127)));
                    }
                }
                /* facts after branching */
                //assert (l_117 == 0 || l_117 == dangling || l_117 == &l_127);
                p_63 = (!((*l_127) || (l_236 != &l_113)));
                (*l_126) = (*l_126);
            }
        }
        /* facts after for loop */
        //assert (l_117 == 0 || l_117 == dangling);
        (*l_75) = (0x5489L | (((((safe_lshift_func_int16_t_s_u((*l_75), ((((p_63 , l_126) != l_126) , 1L) <= ((safe_rshift_func_int16_t_s_u(((((safe_mod_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u(p_64, (p_64 || 0UL))) ^ p_63), p_63)) < l_265) , p_63) >= (**l_126)), (**l_126))) , 6UL)))) , 0x334CCFE4L) , p_63) , l_126) == l_126));
    }
    /* facts after branching */
    //assert (l_117 == 0 || l_117 == dangling);
    return p_63;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 124
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 14
   depth: 3, occurrence: 1
   depth: 5, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 102

XXX times a variable address is taken: 128
XXX times a pointer is dereferenced on RHS: 149
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 48
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 40
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 8
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 697

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 286
   level: 2, occurrence: 143
   level: 3, occurrence: 68
   level: 4, occurrence: 51
   level: 5, occurrence: 33
XXX number of pointers point to pointers: 60
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.5
XXX average alias set size: 1.2

XXX times a non-volatile is read: 835
XXX times a non-volatile is write: 135
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 102
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 12
   depth: 2, occurrence: 13
   depth: 3, occurrence: 19
   depth: 4, occurrence: 12
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 12.5
XXX percentage an existing variable is used: 87.5
********************* end of statistics **********************/

