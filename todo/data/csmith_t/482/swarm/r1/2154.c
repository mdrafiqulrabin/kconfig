/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      1901233694
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 29;
   unsigned f1 : 30;
   signed f2 : 8;
   signed f3 : 20;
   unsigned f4 : 19;
   signed f5 : 30;
   unsigned f6 : 4;
   unsigned f7 : 9;
   signed f8 : 9;
   unsigned f9 : 19;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
inline static int32_t * func_2(float  p_3, int32_t * p_4, struct S0  p_5, int32_t * p_6);
inline static float  func_9(const int32_t * p_10, int32_t * p_11, int32_t * p_12, float  p_13, int8_t  p_14);
inline static int32_t * func_17(int8_t  p_18, int8_t  p_19, int32_t  p_20, int32_t * p_21);
static int8_t  func_22(int32_t * p_23, int16_t  p_24);
inline static uint32_t  func_25(int8_t  p_26);
inline static uint32_t  func_29(int32_t * p_30, int32_t * p_31, int16_t  p_32, int32_t * p_33, int8_t  p_34);
inline static int32_t * func_35(int32_t * p_36);
static const struct S0  func_37(uint16_t  p_38, int32_t * p_39, uint32_t  p_40);
inline static uint16_t  func_41(const int32_t * p_42, int16_t  p_43);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_16 = 0x2AA9DADE;
    const int32_t *l_15 = &l_16;
    struct S0 ***l_702 = (void*)0;
    struct S0 ****l_701 = &l_702;
    int32_t l_851 = 0;
    int32_t *l_850 = &l_851;
    uint32_t l_852 = 4294967295U;
    struct S0 l_863 = {3416,5800,2,-720,412,18163,2,9,-16,512};
    int32_t **l_893 = &l_850;
    int32_t ***l_910 = &l_893;
    int32_t ****l_909 = &l_910;
    struct S0 *l_911 = &l_863;
    int32_t l_930 = 0x8730783C;
    int32_t l_939 = 0x8A39D417;
    struct S0 *****l_1035 = &l_701;
    int8_t l_1089 = 0x8D;
    int8_t l_1106 = 0x95;
    const int32_t l_1129 = 0x591FFEE1;
    uint16_t l_1201 = 65535U;
    int16_t l_1275 = (-1);
    uint32_t l_1300 = 1U;
    int16_t l_1346 = 1;
    int16_t l_1423 = 0xB44B;
    int8_t l_1492 = 0;
    int32_t *l_1494 = &l_851;
    int8_t l_1495 = (-1);
lbl_1347:
    (*l_893) = func_2((safe_sub_func_float_f_f(func_9(l_15, func_17(func_22(((func_25((*l_15)) && (l_701 != &l_702)) , (void*)0), (*l_15)), ((((safe_add_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s(1, 0)) != (*l_15)), (*l_15))) , (*l_15)) == 0x245BF1F7) , (*l_15)), (*l_15), &l_16), l_850, l_852, (*l_850)), (*l_850))), &l_851, l_863, &l_851);
lbl_1493:
    if ((((safe_mod_func_uint32_t_u_u(((((**l_893) , (safe_mod_func_int16_t_s_s(((safe_lshift_func_int16_t_s_u((((((**l_893) | (((((*l_850) < 8U) < (safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((safe_add_func_int16_t_s_s((*l_15), ((((+((l_863 , (l_909 != &l_910)) , (l_911 == &l_863))) , (****l_909)) || 0x9E6E) >= (*l_15)))), (*l_850))), 11)), 0xDE67))) || 0x471DFB28) & 1)) , (***l_910)) , 0xBB39) | (*l_850)), 7)) != (*l_850)), 8))) , (***l_910)) < (***l_910)), (-4))) > (*l_15)) , (****l_909)))
    { /* block id: 359 */
        uint32_t l_912 = 0x90236DDB;
        int32_t ***l_927 = &l_893;
        int32_t l_928 = 0x77811C3F;
        uint32_t l_929 = 0U;
        int32_t *****l_938 = &l_909;
        struct S0 **l_953 = &l_911;
        struct S0 ***l_952 = &l_953;
        uint32_t l_995 = 0x1EDF8B9F;
        float l_1003 = 0x0.Fp-1;
        float *l_1002 = &l_1003;
        uint32_t l_1078 = 0x198C03C2;
        uint16_t l_1081 = 0x66FC;
        uint16_t l_1105 = 65534U;
        const struct S0 **l_1166 = (void*)0;
        const struct S0 ***l_1165 = &l_1166;
        const struct S0 ****l_1164 = &l_1165;
        const struct S0 *****l_1163 = &l_1164;
        (*l_911) = func_37(l_912, (*l_893), ((****l_909) | (((((((l_912 , l_912) && l_912) && (*l_15)) & (safe_lshift_func_int16_t_s_u(l_912, (+(****l_909))))) != 65535U) && (**l_893)) < 0x29856D81)));
        if (((safe_add_func_uint16_t_u_u(l_912, (((6U <= (safe_lshift_func_uint16_t_u_s(((l_912 == ((safe_mul_func_int16_t_s_s(l_912, (*l_15))) , (+l_912))) <= (l_912 != ((safe_sub_func_int32_t_s_s((((((safe_sub_func_uint32_t_u_u((((((l_927 == (l_928 , (*l_909))) <= l_929) != 4294967295U) >= (**l_893)) >= 0U), l_930)) >= 65533U) > 5) != 1U) & (*l_15)), (*l_15))) , (***l_927)))), (***l_910)))) <= (****l_909)) ^ (****l_909)))) | 0x07A8))
        { /* block id: 361 */
            int32_t *l_931 = &l_851;
            struct S0 l_932 = {22888,962,-10,508,12,21837,0,6,7,115};
            (***l_909) = l_931;
            (*l_911) = (*l_911);
            (**l_910) = (**l_927);
            (*l_911) = func_37((***l_927), func_2((***l_910), (**l_927), l_932, (**l_927)), (safe_sub_func_uint16_t_u_u(((void*)0 != &l_910), (***l_910))));
        }
        else
        { /* block id: 366 */
            int16_t l_935 = 0;
            l_935 = (***l_927);
        }
        if ((+(((((***l_927) , (safe_unary_minus_func_uint32_t_u(((void*)0 != l_927)))) == (l_938 == ((((**l_893) | l_939) > (***l_927)) , &l_909))) == ((((safe_mod_func_uint16_t_u_u(((safe_add_func_int32_t_s_s(0xA1BD9E7B, (***l_927))) == (****l_909)), (*l_15))) <= (***l_910)) || 0x43915765) ^ (*****l_938))) , (***l_927))))
        { /* block id: 369 */
            struct S0 *l_944 = &l_863;
            struct S0 **l_945 = &l_911;
            int32_t l_962 = (-3);
            float l_964 = 0x1.ED29AAp-17;
            float *l_963 = &l_964;
            (*l_945) = l_944;
            (*l_963) = ((((*****l_938) <= ((safe_lshift_func_uint16_t_u_u((*l_15), (safe_lshift_func_int16_t_s_u((((***l_927) | (((***l_910) , (safe_rshift_func_uint16_t_u_s(((void*)0 == l_952), (safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((((((safe_add_func_uint16_t_u_u(0x16F8, ((***l_927) | (safe_lshift_func_uint16_t_u_s((((((***l_910) , 0xF183EA3C) >= 0x58B78F34) <= (*l_850)) <= 0xEED4), 7))))) && 0x8453) & (**l_893)) & 2U) ^ (-1)), l_962)), (***l_927)))))) && (****l_909))) || (***l_910)), 14)))) , 0x1.Bp-1)) < (*l_850)) > (*****l_938));
            (*l_893) = (***l_909);
            if (l_929)
                goto lbl_1493;
        }
        else
        { /* block id: 373 */
            struct S0 *****l_965 = &l_701;
            int32_t l_969 = (-3);
            const int8_t l_996 = 0xEA;
            float l_998 = 0x1.E1889Ap+98;
            float *l_997 = &l_998;
            int32_t *****l_1030 = &l_909;
            int32_t l_1037 = 0x2902234D;
            (*l_965) = ((***l_927) , &l_952);
            /* statement id: 374 */
            assert (l_701 == &l_952);
            if (l_863.f9)
                goto lbl_968;
lbl_968:
            (*l_850) = (safe_mod_func_uint32_t_u_u(4294967293U, 4294967295U));
            if (l_969)
            { /* block id: 377 */
                struct S0 ****l_974 = &l_952;
                int32_t l_979 = 0x17205F5D;
                int32_t *****l_986 = &l_909;
                (*****l_986) = (safe_sub_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_s((l_974 == &l_952), ((safe_add_func_uint16_t_u_u(((*l_850) == ((safe_mul_func_int16_t_s_s((l_979 <= (safe_mod_func_int16_t_s_s((((***l_910) && (safe_mul_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((l_986 == ((safe_add_func_uint16_t_u_u(((safe_add_func_uint32_t_u_u(((safe_lshift_func_uint16_t_u_s(((-5) <= (safe_mul_func_int16_t_s_s((*****l_986), (1 | 0xFCBE4D2C)))), 15)) >= (*****l_938)), (*****l_938))) < 65535U), (****l_909))) , l_938)), (***l_910))), (*****l_938)))) <= (*****l_938)), l_995))), (***l_927))) == l_969)), (*****l_986))) <= 0x3A4B))) ^ l_996), 0x31CA));
            }
            else
            { /* block id: 379 */
                float *l_1001 = &l_998;
                int32_t l_1012 = (-3);
                struct S0 **l_1013 = &l_911;
                int32_t l_1036 = (-1);
                const uint32_t l_1079 = 0U;
                struct S0 ****l_1098 = &l_952;
                int32_t l_1107 = 0;
                const int32_t **l_1138 = &l_15;
                const int32_t ***l_1137 = &l_1138;
                const int32_t ****l_1136 = &l_1137;
                uint16_t l_1152 = 65535U;
                int32_t l_1157 = (-3);
                int8_t l_1162 = 0xA9;
                (***l_909) = func_17(((((void*)0 == l_997) && 0x2D41D0C7) && ((((safe_mod_func_uint32_t_u_u(((l_1001 == l_1002) != ((safe_lshift_func_int16_t_s_s((~((safe_add_func_uint16_t_u_u((***l_927), (~((safe_sub_func_int32_t_s_s(l_1012, ((**l_965) == (void*)0))) < l_1012)))) & l_1012)), 2)) > 0x13E69424)), (*****l_938))) || (***l_910)) , l_1013) == (*l_952))), l_1012, l_1012, (**l_910));
                /* statement id: 380 */
                assert (l_850 == &l_851 || l_850 == 0);
                (*l_893) = &l_1012;
                /* statement id: 381 */
                assert (l_850 == &l_1012);
                (**l_893) = (0 && (safe_sub_func_uint16_t_u_u(((safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_add_func_float_f_f((safe_sub_func_float_f_f((((safe_add_func_float_f_f((safe_add_func_float_f_f((safe_sub_func_float_f_f(((2 < (**l_893)) , (((((l_1030 == ((safe_lshift_func_uint16_t_u_s((func_37(((***l_927) > ((***l_927) <= ((safe_mul_func_uint16_t_u_u(65533U, ((((l_1035 == (void*)0) || l_1012) , (*l_911)) , (*****l_1030)))) ^ (*****l_938)))), &l_1012, (*l_15)) , l_1012), l_1036)) , (void*)0)) , (***l_927)) && l_1036) <= l_1036) , (***l_910))), l_1036)), l_1036)), l_1037)) >= (*l_15)) <= 0x7.9p-1), l_1036)), l_1036)), l_1036)), (-0x8.7p+1))) , 65528U), l_1036)));
                for (l_939 = 0; (l_939 != 28); l_939 = safe_add_func_int16_t_s_s(l_939, 2))
                { /* block id: 385 */
                    int32_t l_1041 = 1;
                    int32_t **l_1052 = &l_850;
                    uint32_t l_1073 = 1U;
                    int32_t l_1103 = 0x1391714F;
                    int32_t l_1104 = 0x5796C886;
                    int32_t ****l_1139 = &l_927;
                    uint16_t l_1168 = 65533U;
                    float l_1169 = 0xF.03F189p-29;
                }
            }
            /* facts after branching */
            //assert (l_850 == dangling || l_850 == &l_851);
        }
        /* facts after branching */
        assert (l_701 == &l_952 || l_701 == &l_702);
        //assert (l_850 == dangling || l_850 == &l_851);
    }
    else
    { /* block id: 407 */
        int32_t l_1174 = 0x86A72C68;
        int16_t l_1223 = 0x17FF;
        uint32_t l_1230 = 4294967286U;
        struct S0 *****l_1243 = &l_701;
        struct S0 *l_1260 = &l_863;
        int32_t **l_1278 = (void*)0;
        float *l_1328 = (void*)0;
        int32_t l_1348 = 9;
        int32_t *****l_1369 = &l_909;
        int32_t l_1450 = 0xDB26003C;
        uint16_t l_1488 = 65535U;
        if (((safe_add_func_int16_t_s_s(((*l_850) <= (****l_909)), l_1174)) || l_1174))
        { /* block id: 408 */
            const int32_t *l_1175 = &l_851;
            struct S0 l_1188 = {8641,9173,-6,-746,299,7014,0,2,-15,239};
            float l_1200 = 0x7.6p+1;
            uint32_t l_1205 = 4294967294U;
            int32_t *l_1206 = &l_851;
            struct S0 *****l_1225 = &l_701;
            int32_t l_1248 = 5;
            int8_t l_1255 = 0x34;
            uint32_t l_1261 = 5U;
            struct S0 *l_1277 = &l_1188;
            uint16_t l_1298 = 0x17A6;
            const int32_t **l_1336 = (void*)0;
            const int32_t ***l_1335 = &l_1336;
            int8_t l_1377 = 0x83;
            float l_1413 = 0xB.6F5E1Dp-56;
            float l_1428 = 0x8.9A642Ep+92;
            l_1175 = (void*)0;
            /* statement id: 409 */
            assert (l_1175 == 0);
            if (((safe_mod_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(1U, (((((safe_sub_func_int32_t_s_s((safe_add_func_int16_t_s_s((****l_909), ((***l_910) != (*l_850)))), (((safe_mod_func_int16_t_s_s(((safe_mul_func_int16_t_s_s(((((((l_1188 , (((((((((((safe_mul_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((safe_mul_func_uint16_t_u_u(0x8164, ((safe_sub_func_int32_t_s_s((+(0x3235 < (*l_15))), l_1174)) | l_1174))), (***l_910))), 15)) || 0x43E0), 0x5F18)) ^ 2U) <= l_1174) != (*l_850)) > l_1174) | (*l_850)) <= l_1174) , 4294967294U) == (*l_15)) & l_1174) == 0x9118)) || l_1174) ^ (***l_910)) | (*l_850)) < (*l_15)) >= l_1174), (*l_850))) || 0xD674F0B2), 8U)) && 3U) & (*l_15)))) && 0xFCE7) >= (*l_15)) ^ l_1188.f0) ^ 65535U))), l_1174)) > 0x03EF265A))
            { /* block id: 410 */
                uint32_t l_1209 = 0xA76B66C2;
                int32_t l_1224 = 0;
                uint32_t l_1249 = 0x36235B5B;
                struct S0 *l_1251 = &l_863;
                if (((((l_1201 == 0x7E4D) , (*l_893)) == (void*)0) , 0x09F567E0))
                { /* block id: 411 */
                    struct S0 l_1207 = {11079,27395,10,-372,298,19272,1,21,-17,221};
                    int32_t *l_1208 = &l_851;
                    for (l_851 = 27; (l_851 <= 27); l_851++)
                    { /* block id: 414 */
                        int32_t *l_1204 = &l_851;
                        (*l_893) = l_1204;
                        if (l_1174)
                            break;
                    }
                    l_1208 = func_35(func_2(l_1205, l_1206, l_1207, (*l_893)));
                    /* statement id: 418 */
                    assert (l_1208 == &l_851 || l_1208 == 0);
                }
                else
                { /* block id: 419 */
                    float l_1217 = 0x1.2p+1;
                    int32_t **l_1222 = &l_850;
                    struct S0 *l_1276 = &l_863;
                    (*l_850) = l_1209;
                    l_1224 = (l_1174 >= ((safe_mul_func_int16_t_s_s(((((safe_lshift_func_int16_t_s_s((((func_37(l_1174, (*l_893), (+(safe_mul_func_int16_t_s_s((((0x1.5725E9p+11 > l_1217) < ((((((((***l_910) , (safe_mul_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_s(((((0x8AD1 & 0xBCCC) < (*l_1206)) ^ (****l_909)) || 0U), 11)) < 4294967295U), (****l_909)))) & l_1174) & 1) , 0xA.A20266p+66) < (*l_1206)) > l_1209) != 0x5.B0C4ACp-25)) , (-9)), l_1209)))) , &l_1206) != l_1222) , (*l_1206)), 0)) , (void*)0) == &l_1222) != 0xF0D1), l_1223)) , 0x3.A57A95p-13));
                    if ((l_1223 > ((l_1225 == ((**l_1222) , l_1225)) || (((l_1175 != (void*)0) , l_1223) <= (((safe_mul_func_uint16_t_u_u(8U, (safe_mul_func_int16_t_s_s(((l_1230 , (void*)0) != (void*)0), l_1209)))) | l_1223) || l_1230)))))
                    { /* block id: 422 */
                        int32_t l_1244 = 0x868745D8;
                        int32_t *l_1250 = &l_1174;
                        (*l_911) = func_37((!((-6) == ((****l_909) || (!(safe_mod_func_int16_t_s_s(((safe_sub_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint16_t_u_u(l_1230, ((safe_rshift_func_int16_t_s_u(((void*)0 == l_1243), 11)) ^ l_1244))), (safe_unary_minus_func_int32_t_s(l_1244)))), ((safe_mod_func_uint32_t_u_u(((l_1209 & (l_1248 , l_1244)) || l_1244), l_1209)) && (*l_15)))) == l_1249), (*l_1206))))))), l_1250, (*l_1250));
                    }
                    else
                    { /* block id: 424 */
                        struct S0 **l_1252 = &l_911;
                        (*l_1252) = l_1251;
                    }
                    for (l_1230 = 0; (l_1230 <= 8); l_1230 = safe_add_func_uint32_t_u_u(l_1230, 5))
                    { /* block id: 429 */
                        int32_t l_1274 = 0;
                        l_1277 = ((((((((*l_1206) , l_1255) < 0x480E) && (safe_mul_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((l_1260 == (void*)0), (l_1261 , (safe_add_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_s((((((safe_rshift_func_uint16_t_u_u(l_1249, 14)) , (safe_lshift_func_int16_t_s_u((*l_850), ((((safe_lshift_func_uint16_t_u_u((((safe_add_func_int32_t_s_s(l_1274, l_1249)) ^ l_1230) != (**l_893)), (****l_909))) , l_1274) , 5U) & l_1274)))) == l_1209) == 1U) ^ l_1224), 9)) | l_1209), l_1249))))), (*l_15)))) > (**l_1222)) ^ (*l_1206)) ^ l_1275) , l_1276);
                        /* statement id: 430 */
                        assert (l_1277 == &l_863);
                    }
                    /* facts after for loop */
                    assert (l_1277 == &l_863 || l_1277 == &l_1188);
                }
                /* facts after branching */
                assert (l_1277 == &l_863 || l_1277 == &l_1188);
                if (((**l_909) != l_1278))
                { /* block id: 433 */
                    int8_t l_1279 = 0x4C;
                    int32_t l_1295 = 0xC3AF57F8;
                    int32_t l_1317 = 0;
                    if (l_1279)
                    { /* block id: 434 */
                        int32_t *****l_1280 = &l_909;
                        (*l_1280) = (void*)0;
                        /* statement id: 435 */
                        assert (l_909 == 0);
                    }
                    else
                    { /* block id: 436 */
                        uint16_t l_1283 = 0U;
                        float *l_1299 = (void*)0;
                        l_1224 = ((safe_mul_func_float_f_f(l_1283, (safe_add_func_float_f_f(((safe_add_func_float_f_f(((safe_add_func_float_f_f(((0x9.9BC4BDp-26 != (l_1279 != (l_1283 >= ((safe_add_func_float_f_f(((safe_lshift_func_uint16_t_u_s((l_1249 == ((((((safe_unary_minus_func_uint32_t_u(l_1295)) >= (-1)) , ((((safe_sub_func_float_f_f((((void*)0 == &l_909) , (**l_893)), (***l_910))) == 0x0.440AFCp-46) < l_1295) != l_1209)) > (*l_850)) , (*l_1260)) , l_1283)), l_1283)) , 0x2.7A540Ep+82), l_1279)) <= l_1224)))) <= l_1283), l_1279)) < l_1295), (***l_910))) >= l_1224), l_1298)))) <= 0x9.DC3476p-52);
                    }
                    /* facts after branching */
                    assert (l_909 == &l_910 || l_909 == 0);
                    (*l_1251) = func_37((*l_850), func_2((***l_910), &l_1224, (*l_911), func_17(l_1230, (l_1260 == l_1251), l_1300, &l_1295)), (***l_910));
                    for (l_1089 = (-27); (l_1089 == 22); l_1089 = safe_add_func_uint32_t_u_u(l_1089, 1))
                    { /* block id: 442 */
                        int16_t l_1307 = 0xD651;
                        (**l_910) = (void*)0;
                        /* statement id: 443 */
                        assert (l_850 == 0);
                        (*l_1206) = (0x881B & (safe_lshift_func_uint16_t_u_u((l_1174 >= ((*l_1206) >= (((*l_1277) , (safe_add_func_int16_t_s_s((l_1307 | ((void*)0 != &l_1175)), (l_1307 && ((safe_sub_func_float_f_f((((safe_add_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u(l_1307, 1U)), 0xF0F8)) > l_1279) , 0x0.9p-1), 0x1.4p+1)) , 65535U))))) , l_1307))), 3)));
                    }
                    /* facts after for loop */
                    assert (l_850 == 0 || l_850 == &l_851);
                    for (l_1223 = 0; (l_1223 != 4); l_1223 = safe_add_func_uint32_t_u_u(l_1223, 2))
                    { /* block id: 448 */
                        float *l_1318 = &l_1200;
                        int32_t l_1321 = 0xF29819FC;
                        (*l_1318) = (+l_1317);
                        (*l_1206) = ((safe_sub_func_int16_t_s_s(l_1321, l_1223)) , (safe_sub_func_int16_t_s_s(0, 0x7386)));
                        (*l_893) = &l_1321;
                        /* statement id: 451 */
                        assert (l_850 == &l_1321);
                    }
                    /* facts after for loop */
                    //assert (l_850 == dangling || l_850 == 0 || l_850 == &l_851);
                }
                else
                { /* block id: 453 */
                    (**l_910) = func_2(l_1209, &l_1248, (*l_1277), (**l_910));
                    /* statement id: 454 */
                    assert (l_850 == &l_1248);
                }
                /* facts after branching */
                //assert (l_850 == &l_1248 || l_850 == dangling || l_850 == 0 || l_850 == &l_851);
                assert (l_909 == &l_910 || l_909 == 0);
                (*l_1251) = (*l_1260);
                return l_1209;
            }
            else
            { /* block id: 458 */
                float *l_1329 = &l_1200;
                int32_t l_1332 = 0x5BBF06AB;
                const int32_t ***l_1337 = &l_1336;
                uint32_t l_1375 = 0U;
                struct S0 **l_1383 = &l_1260;
                struct S0 *****l_1420 = &l_701;
                int16_t l_1421 = 0xED15;
                (*l_1329) = (safe_mul_func_float_f_f(((safe_sub_func_float_f_f((&l_1277 != &l_1260), (***l_910))) > ((void*)0 == l_1328)), (***l_910)));
                if (((void*)0 != (*l_1035)))
                { /* block id: 460 */
                    int32_t *l_1344 = &l_1248;
                    const float l_1345 = (-0x9.5p+1);
                    int32_t ***l_1374 = &l_893;
                    struct S0 **l_1384 = (void*)0;
                    struct S0 *****l_1387 = (void*)0;
                    if ((((((***l_910) ^ 0) < l_1332) <= (((((((safe_mul_func_uint16_t_u_u((l_1335 != l_1337), (safe_rshift_func_int16_t_s_s(((**l_893) != ((safe_rshift_func_int16_t_s_u(((((safe_mod_func_uint16_t_u_u(((void*)0 == l_1344), (****l_909))) || (*l_15)) , (**l_893)) , l_1332), 4)) || 65532U)), (*l_1344))))) | 0x0185) , 1) == l_1346) > (*l_15)) ^ (*l_15)) , 0x6EB1)) , (*l_15)))
                    { /* block id: 461 */
                        int32_t l_1349 = 0xEDDDF890;
                        const uint32_t l_1354 = 0x4C2AFD82;
                        struct S0 l_1358 = {14224,23515,4,-568,704,5327,1,1,-21,407};
                        uint16_t l_1376 = 65526U;
                        int32_t ****l_1378 = &l_1374;
                        if (l_1346)
                            goto lbl_1347;
                        (*l_850) = ((*l_1344) | ((l_1348 , l_1349) >= (((safe_unary_minus_func_uint32_t_u(((((*l_1344) , (safe_unary_minus_func_int32_t_s(0xEAE702AD))) ^ (((*l_1344) , (((safe_sub_func_uint32_t_u_u(((*l_1344) & (*l_1344)), (3U <= 0xE0A6B120))) , &l_1349) == l_1344)) , l_1354)) , 4294967295U))) || (*l_1344)) ^ 0xC57B6B01)));
                        (*l_1329) = (((((*l_1344) ^ ((safe_unary_minus_func_int32_t_s(((safe_mod_func_int32_t_s_s((****l_909), ((l_1358 , (safe_sub_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((safe_mul_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(l_1332, (safe_add_func_uint32_t_u_u((l_1369 != l_1369), (safe_sub_func_int32_t_s_s((-10), (((l_1358.f9 , ((((safe_add_func_int32_t_s_s((l_1374 != (void*)0), l_1375)) , (**l_1374)) != (void*)0) < 1U)) && l_1376) == 1U))))))), (*****l_1369))), (*l_1344))), (****l_909)))) , l_1377))) || (*l_1344)))) , (-1))) , 0x311F) , 0xC.4AC53Bp-61) <= l_1358.f4);
                        (*l_1378) = l_1337;
                        /* statement id: 465 */
                        assert (l_1374 == &l_1336);
                    }
                    else
                    { /* block id: 466 */
                        uint32_t l_1381 = 4U;
                        int32_t **l_1385 = &l_1344;
                        struct S0 *****l_1386 = &l_701;
                        (***l_909) = ((((safe_rshift_func_int16_t_s_s(l_1381, ((9 & (~(l_1383 != l_1384))) || (l_1385 != (*l_1337))))) || (((l_1386 == l_1387) , (safe_mul_func_float_f_f((((**l_1385) == 0x0.5p-1) < 0x8.11CE89p-50), 0x3.C7B97Ap+9))) , (***l_1374))) != (***l_910)) , (void*)0);
                        /* statement id: 467 */
                        assert (l_850 == 0);
                        return l_1332;
                    }
                    /* facts after branching */
                    assert (l_1374 == &l_1336);
                }
                else
                { /* block id: 470 */
                    int32_t *l_1392 = &l_1174;
                    float l_1422 = 0xB.C0DC31p+53;
                    (*l_1329) = (*l_15);
                    for (l_1230 = 0; (l_1230 < 52); l_1230++)
                    { /* block id: 474 */
                        uint32_t l_1395 = 4294967290U;
                        float l_1403 = 0x0.0p-1;
                        int32_t *l_1404 = &l_851;
                        int32_t l_1419 = 0xBF8753F4;
                        (*l_1260) = (*l_911);
                        (**l_910) = l_1392;
                        /* statement id: 476 */
                        assert (l_850 == &l_1174);
                        l_1404 = (((safe_add_func_uint32_t_u_u((0x75097744 | l_1395), (safe_mul_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((*l_1392), (((*l_1392) || (*****l_1369)) ^ ((**l_893) >= (safe_unary_minus_func_uint16_t_u(((*****l_1369) & (safe_sub_func_int32_t_s_s((*l_850), (l_1395 & 0x523C)))))))))), 0x2A89)))) & l_1395) , (****l_1369));
                        /* statement id: 477 */
                        assert (l_1404 == &l_1174);
                        (*l_1277) = func_37(((safe_lshift_func_int16_t_s_u(((*l_1277) , ((safe_rshift_func_int16_t_s_u(((safe_rshift_func_uint16_t_u_u(0x7B6B, ((safe_add_func_uint32_t_u_u(((((((((*l_1404) != ((0x10E73125 == (~(*****l_1369))) < ((safe_mul_func_uint16_t_u_u(((4294967294U & (((*l_1392) >= (*l_15)) == (safe_mod_func_int32_t_s_s((((l_1332 , (*****l_1369)) == l_1419) && (*l_15)), (*l_1392))))) != 0U), 1U)) , 0x2AE0))) , (-1)) , (*l_1392)) != 0x0.3B6477p+21) <= (-0x1.Bp-1)) , (void*)0) != l_1420), l_1421)) , (*l_1404)))) ^ (*l_15)), (*l_1206))) , (*l_1404))), 11)) > 0x1D4A), &l_1419, (*****l_1369));
                    }
                    /* facts after for loop */
                    assert (l_850 == &l_1174 || l_850 == &l_851);
                    return l_1423;
                }
                (***l_909) = (****l_1369);
                (*l_1260) = func_37((***l_910), (**l_910), (safe_mod_func_uint32_t_u_u(((((((((safe_add_func_int32_t_s_s(((((l_1328 == (void*)0) >= (0xF.7E4044p+56 == ((*****l_1369) , (0x7.0p-1 >= 0x4.E9DE6Bp+83)))) , func_2((*****l_1369), &l_1248, (**l_1383), &l_1248)) != (****l_1369)), l_1375)) != (*l_1206)) != l_1332) >= l_1332) == (*l_1206)) ^ (*l_1206)) <= 0U) <= 6U), (*****l_1369))));
            }
        }
        else
        { /* block id: 485 */
            float l_1432 = 0x7.0D36F5p+6;
            float *l_1431 = &l_1432;
            int32_t *****l_1449 = (void*)0;
            int32_t l_1453 = 0x11346C9B;
            int32_t l_1468 = 0x1E45C723;
            struct S0 *****l_1470 = &l_701;
lbl_1435:
            (*l_1431) = (safe_sub_func_float_f_f((****l_909), (*****l_1369)));
            for (l_1089 = 0; (l_1089 >= 23); l_1089 = safe_add_func_uint32_t_u_u(l_1089, 3))
            { /* block id: 489 */
                const uint32_t l_1440 = 4294967287U;
                int32_t *****l_1443 = &l_909;
                uint32_t l_1451 = 0xE725F898;
                int32_t l_1452 = 1;
                struct S0 **l_1460 = &l_1260;
                float l_1466 = 0x3.Fp+1;
                if (l_852)
                    goto lbl_1435;
            }
            return l_1492;
        }
    }
    /* facts after branching */
    //assert (l_701 == dangling || l_701 == &l_702);
    //assert (l_850 == dangling || l_850 == &l_851);
    (*l_1494) = (0x77DB == 0x00B5);
    return l_1495;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_2(float  p_3, int32_t * p_4, struct S0  p_5, int32_t * p_6)
{ /* block id: 353 */
    struct S0 l_868 = {22670,24226,9,1006,386,-32623,2,5,-11,217};
    struct S0 *l_867 = &l_868;
    struct S0 **l_866 = &l_867;
    struct S0 ***l_865 = &l_866;
    struct S0 ****l_864 = &l_865;
    int32_t l_870 = 5;
    int32_t *l_869 = &l_870;
    int32_t **l_883 = &l_869;
    int32_t ***l_882 = &l_883;
    int32_t ****l_881 = &l_882;
    int32_t *****l_880 = &l_881;
    int32_t *****l_892 = &l_881;
    l_868.f8 = (l_864 == (void*)0);
    l_869 = l_869;
    (*****l_892) = ((safe_mod_func_int32_t_s_s((((safe_unary_minus_func_int16_t_s(p_5.f1)) , (*l_869)) != (*l_869)), (safe_lshift_func_int16_t_s_s(((safe_sub_func_uint32_t_u_u(p_5.f2, (((safe_mul_func_int16_t_s_s((l_880 != ((**l_883) , ((safe_rshift_func_uint16_t_u_u(((safe_add_func_int32_t_s_s((((safe_mod_func_int32_t_s_s((safe_add_func_int16_t_s_s((((**l_883) == ((((*l_864) != ((l_892 != &l_881) , (*l_864))) && p_5.f7) <= 0x3C96)) || p_5.f6), (****l_881))), 0xDA13CC10)) < 0x9A45B51C) == p_5.f6), p_5.f7)) || (*****l_892)), (***l_882))) , &l_881))), p_5.f0)) | 0x6B214615) | 1U))) < p_5.f3), (**l_883))))) <= 1U);
    return p_4;
    /* statement id: 357 */
    //assert (func_2_rv == &l_851 || func_2_rv == &l_1224 || func_2_rv == &l_1248);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_9(const int32_t * p_10, int32_t * p_11, int32_t * p_12, float  p_13, int8_t  p_14)
{ /* block id: 345 */
    uint32_t l_853 = 4294967293U;
    float *l_854 = (void*)0;
    float *l_855 = (void*)0;
    float l_857 = 0x3.Cp+1;
    float *l_856 = &l_857;
    (*l_856) = (l_853 <= (-0x1.Ep+1));
    for (p_14 = 0; (p_14 > (-13)); --p_14)
    { /* block id: 349 */
        int32_t l_862 = 4;
        int32_t *l_861 = &l_862;
        int32_t **l_860 = &l_861;
        (*l_860) = l_854;
        /* statement id: 350 */
        assert (l_861 == 0);
    }
    return l_853;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_17(int8_t  p_18, int8_t  p_19, int32_t  p_20, int32_t * p_21)
{ /* block id: 294 */
    struct S0 l_747 = {11788,26231,-14,13,678,-10223,1,8,4,150};
    int32_t *l_758 = (void*)0;
    int32_t **l_757 = &l_758;
    int32_t l_762 = 0x5D146464;
    int32_t l_767 = 0x8AAF3E70;
    int32_t *l_766 = &l_767;
    int32_t ***l_821 = &l_757;
    int32_t ****l_820 = &l_821;
    for (p_19 = 0; (p_19 >= 0); p_19 = safe_sub_func_uint32_t_u_u(p_19, 1))
    { /* block id: 297 */
        struct S0 l_746 = {13240,29903,-4,-127,486,28454,3,7,-1,215};
        int32_t **l_759 = &l_758;
        struct S0 l_775 = {3793,30095,14,-726,24,-25949,1,13,5,518};
        float l_816 = 0x5.F66282p-34;
        float *l_815 = &l_816;
        l_747 = l_746;
        for (p_20 = 0; (p_20 <= (-14)); p_20 = safe_sub_func_int32_t_s_s(p_20, 5))
        { /* block id: 301 */
            uint32_t l_752 = 0x4117F34B;
            int16_t l_761 = 0x11BE;
            uint16_t l_769 = 65535U;
            int32_t l_774 = 0x9A96B0FF;
            int32_t ***l_806 = &l_757;
            struct S0 *l_810 = &l_747;
            struct S0 **l_809 = &l_810;
            for (p_18 = 26; (p_18 == 23); p_18 = safe_sub_func_int16_t_s_s(p_18, 9))
            { /* block id: 304 */
                int32_t **l_760 = &l_758;
                float l_805 = 0x0.7p+1;
                if (((l_752 >= ((safe_mul_func_int16_t_s_s(l_752, ((safe_add_func_uint32_t_u_u((((l_747 , l_757) != l_759) > ((((&p_21 == l_760) > l_761) , ((l_762 <= l_752) != 0)) > 1U)), (*p_21))) < p_19))) , p_19)) , l_761))
                { /* block id: 305 */
                    if (l_752)
                        break;
                }
                else
                { /* block id: 307 */
                    int32_t *l_763 = (void*)0;
                    return l_763;
                    /* statement id: 308 */
                    //assert (func_17_rv == 0);
                }
                for (l_761 = 7; (l_761 >= (-18)); l_761 = safe_sub_func_uint16_t_u_u(l_761, 2))
                { /* block id: 312 */
                    float l_788 = (-0x8.9p+1);
                    int32_t l_791 = 1;
                    struct S0 *l_807 = (void*)0;
                    float *l_808 = &l_805;
                    l_775 = l_746;
                    (*l_808) = (safe_mul_func_float_f_f(((((((safe_mod_func_uint32_t_u_u(((((safe_mul_func_int16_t_s_s((((((safe_mod_func_int32_t_s_s((safe_mul_func_uint16_t_u_u((((((((safe_mod_func_uint16_t_u_u(((*p_21) != (safe_sub_func_int16_t_s_s((l_791 < (0x4CFC == ((((~((safe_sub_func_int16_t_s_s((-1), ((((l_774 != (-1)) & (*p_21)) & (safe_sub_func_int32_t_s_s((safe_sub_func_int16_t_s_s((((((safe_mul_func_uint16_t_u_u(p_19, (safe_sub_func_uint32_t_u_u((safe_mod_func_int32_t_s_s((*p_21), p_20)), (*l_766))))) & p_18) , p_20) , l_769) && 1U), p_18)), (*p_21)))) != (*l_766)))) && p_19)) > 65535U) , l_806) != (void*)0))), p_19))), l_775.f0)) > 65535U) , 5U) < p_18) < p_19) | p_18) , p_19), (-1))), (*p_21))) >= 0) != p_18) < 0U) , l_791), p_18)) | p_20) && (*p_21)) , p_18), l_791)) && p_20) <= p_19) , &l_747) == l_807) != p_19), 0x5.Cp-1));
                }
            }
            (*l_809) = &l_746;
            /* statement id: 317 */
            assert (l_810 == &l_746);
            for (l_774 = 0; (l_774 > 3); l_774 = safe_add_func_int32_t_s_s(l_774, 1))
            { /* block id: 320 */
                (*l_757) = p_21;
                /* statement id: 321 */
                //assert (l_758 == &l_16 || l_758 == &l_851 || l_758 == &l_1036 || l_758 == &l_1295);
                if ((*l_766))
                    break;
            }
            for (l_752 = 6; (l_752 > 32); l_752 = safe_add_func_uint16_t_u_u(l_752, 1))
            { /* block id: 326 */
                return p_21;
                /* statement id: 327 */
                //assert (func_17_rv == &l_16 || func_17_rv == &l_851 || func_17_rv == &l_1036 || func_17_rv == &l_1295);
            }
        }
        (*l_815) = p_20;
    }
    /* facts after for loop */
    //assert (l_758 == &l_16 || l_758 == 0 || l_758 == &l_851 || l_758 == &l_1036 || l_758 == &l_1295);
    if ((~(safe_rshift_func_int16_t_s_s(((l_820 != (l_747 , &l_821)) , (((safe_add_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(((*p_21) | ((p_18 && ((safe_add_func_uint16_t_u_u(0U, 1U)) & (((safe_mod_func_int16_t_s_s((safe_add_func_int16_t_s_s(p_19, (((safe_rshift_func_uint16_t_u_u(((((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint32_t_u_u((p_21 != p_21), 0U)), 12)) > p_20) & p_18) < (*p_21)), p_19)) == p_19) < 0))), p_18)) , (-1)) | 0xA5294696))) < 0)), 14)), p_18)) < (-1)), 0xCB98)) || 0xBC81C5D5) & p_20)), 6))))
    { /* block id: 332 */
        int32_t *l_843 = &l_767;
        for (p_18 = 0; (p_18 > (-19)); p_18 = safe_sub_func_uint32_t_u_u(p_18, 7))
        { /* block id: 335 */
            int32_t *l_842 = &l_767;
            return p_21;
            /* statement id: 336 */
            //assert (func_17_rv == &l_16 || func_17_rv == &l_851 || func_17_rv == &l_1036 || func_17_rv == &l_1295);
        }
    }
    else
    { /* block id: 338 */
        float l_845 = 0x2.Ap+1;
        float *l_844 = &l_845;
        int32_t l_847 = 0;
        (*l_844) = 0xE.DA49A1p-57;
        if (l_747.f6)
            goto lbl_846;
lbl_846:
        (*l_766) = (*p_21);
        (*p_21) = (((l_847 , l_847) && (safe_mul_func_int16_t_s_s(p_18, (p_18 | ((*p_21) ^ l_847))))) & (((p_19 , 1) & ((((p_18 >= l_847) , (-1)) != l_847) < p_18)) > 65535U));
    }
    return p_21;
    /* statement id: 344 */
    //assert (func_17_rv == &l_16 || func_17_rv == &l_851 || func_17_rv == &l_1036 || func_17_rv == &l_1295);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_22(int32_t * p_23, int16_t  p_24)
{ /* block id: 289 */
    int32_t l_705 = 0x451F843F;
    int32_t *l_704 = &l_705;
    int32_t **l_703 = &l_704;
    const struct S0 l_708 = {17148,3334,-3,941,577,22146,0,10,17,617};
    int16_t l_723 = 0;
    int32_t l_724 = 6;
    int32_t *l_725 = &l_724;
    (*l_703) = p_23;
    /* statement id: 290 */
    assert (l_704 == 0);
    (*l_725) = (safe_mul_func_int16_t_s_s(((p_24 <= ((l_708 , (((safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u(((p_24 == ((safe_lshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((safe_unary_minus_func_int32_t_s((safe_unary_minus_func_uint32_t_u((((safe_add_func_uint32_t_u_u(((safe_add_func_int16_t_s_s(((0x9EB5586E || ((l_723 >= (l_704 == (void*)0)) ^ 0xB267)) == p_24), 0x6132)) > 0x6789), p_24)) < 0x55CDE38C) != p_24))))), l_724)), p_24)) <= l_723)) ^ 65535U), 10)), p_24)) , 0xAA2ACB7E) | p_24)) && p_24)) < p_24), 0xD5C2));
    (*l_725) = ((safe_mul_func_int16_t_s_s((*l_725), (~(p_24 | ((safe_add_func_uint16_t_u_u(p_24, ((safe_mod_func_int16_t_s_s(p_24, (*l_725))) <= (0x099123DD < (safe_mod_func_int32_t_s_s((safe_add_func_int32_t_s_s(((0x9AE39BA1 >= (safe_add_func_uint16_t_u_u((*l_725), ((safe_unary_minus_func_uint16_t_u(1U)) <= p_24)))) | (*l_725)), p_24)), p_24)))))) ^ 0U))))) ^ p_24);
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_25(int8_t  p_26)
{ /* block id: 1 */
    int32_t l_28 = (-1);
    int32_t *l_27 = &l_28;
    int32_t l_368 = 0xB1447242;
    struct S0 l_407 = {2352,29913,-6,537,222,-27101,0,15,-21,691};
    struct S0 *l_406 = &l_407;
    int32_t ****l_411 = (void*)0;
    int32_t *****l_410 = &l_411;
    int8_t l_425 = 6;
    struct S0 **l_485 = (void*)0;
    struct S0 ***l_484 = &l_485;
    struct S0 ****l_483 = &l_484;
    int32_t l_511 = 0x32907074;
    struct S0 *l_564 = (void*)0;
    int8_t l_664 = 0;
    int32_t l_674 = 0x1F61F6BC;
    if ((((((void*)0 == l_27) & func_29(func_35(&l_28), l_27, (((p_26 , ((((((l_368 & 2U) <= p_26) >= (-4)) | 0U) && p_26) , 0xCB463609)) >= 1U) , p_26), &l_368, p_26)) , (*l_27)) > p_26))
    { /* block id: 153 */
        int8_t l_418 = 0x86;
        struct S0 **l_424 = &l_406;
        int32_t *l_426 = &l_368;
        l_426 = ((l_406 != ((*l_27) , (((safe_mul_func_uint16_t_u_u((l_410 != (void*)0), (*l_27))) < (safe_add_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s((((*l_27) && (((((safe_sub_func_int32_t_s_s(l_418, (~p_26))) , (((((((safe_mul_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(((p_26 > 0x8C7EBE50) , 4294967294U), (-10))), p_26)) , (void*)0) == l_424) || p_26) || p_26) == 0xC435) , (void*)0)) == (void*)0) & l_425) < l_418)) ^ p_26), p_26)) < l_418), 0x24342D21))) , (*l_424)))) , (void*)0);
        /* statement id: 154 */
        assert (l_426 == 0);
    }
    else
    { /* block id: 155 */
        uint16_t l_427 = 65535U;
        int32_t *l_435 = &l_368;
        struct S0 l_514 = {7116,25275,1,-400,683,11492,2,11,20,345};
        struct S0 ***l_552 = &l_485;
        int32_t l_555 = 0x436F2B06;
        int32_t *****l_566 = &l_411;
        int32_t *l_675 = &l_368;
        int32_t l_700 = 1;
        if (p_26)
        { /* block id: 156 */
            float l_429 = 0x8.B2A3E3p+30;
            float *l_428 = &l_429;
            int32_t l_441 = 0x1B2982E5;
            int16_t l_465 = 3;
            struct S0 *l_466 = &l_407;
            int32_t ****l_486 = (void*)0;
            int32_t *l_488 = &l_28;
            (*l_428) = l_427;
            for (l_427 = (-5); (l_427 > 25); l_427 = safe_add_func_uint16_t_u_u(l_427, 1))
            { /* block id: 160 */
                struct S0 l_434 = {1757,23208,13,159,645,-5588,0,20,-5,667};
                if (p_26)
                    break;
                for (l_425 = 0; (l_425 < 28); l_425++)
                { /* block id: 164 */
                    int32_t **l_436 = &l_435;
                    (*l_406) = l_434;
                    (*l_436) = l_435;
                }
            }
        }
        else
        { /* block id: 197 */
            return p_26;
        }
        if (p_26)
        { /* block id: 200 */
            for (l_425 = 0; (l_425 != (-28)); l_425 = safe_sub_func_int32_t_s_s(l_425, 1))
            { /* block id: 203 */
                int32_t *l_525 = &l_368;
                const int32_t *l_527 = &l_368;
                const int32_t **l_526 = &l_527;
                for (p_26 = (-8); (p_26 == 27); p_26 = safe_add_func_int16_t_s_s(p_26, 1))
                { /* block id: 206 */
                    int16_t l_524 = (-7);
                    return l_524;
                }
                (*l_526) = l_525;
                (*l_526) = (void*)0;
                /* statement id: 210 */
                assert (l_527 == 0);
            }
        }
        else
        { /* block id: 212 */
            float *l_532 = (void*)0;
            int32_t *l_533 = &l_368;
            int32_t **l_562 = &l_435;
            int32_t ***l_561 = &l_562;
            int32_t ****l_560 = &l_561;
            int32_t l_572 = 0xB4C6E319;
            struct S0 l_608 = {4091,23689,4,14,514,-14233,2,3,11,191};
            l_533 = ((safe_mod_func_int32_t_s_s((-2), (safe_add_func_uint16_t_u_u(1U, ((void*)0 == l_532))))) , (void*)0);
            /* statement id: 213 */
            assert (l_533 == 0);
            for (l_425 = (-30); (l_425 > (-5)); l_425++)
            { /* block id: 216 */
                uint16_t l_540 = 7U;
                float *l_557 = (void*)0;
                struct S0 *l_563 = (void*)0;
                int32_t l_565 = (-1);
                int32_t *l_666 = &l_28;
            }
            for (l_425 = 0; (l_425 >= (-5)); l_425 = safe_sub_func_int16_t_s_s(l_425, 1))
            { /* block id: 274 */
                (**l_562) = (****l_560);
                for (l_674 = 0; (l_674 == 29); l_674 = safe_add_func_int32_t_s_s(l_674, 1))
                { /* block id: 278 */
                    int32_t *l_681 = &l_555;
                    (**l_561) = l_681;
                    /* statement id: 279 */
                    assert (l_435 == &l_555);
                }
                (***l_560) = (*l_562);
            }
            /* facts after for loop */
            assert (l_435 == &l_555 || l_435 == &l_368);
            (*l_435) = ((safe_add_func_uint32_t_u_u(((***l_561) >= (safe_rshift_func_int16_t_s_u(((safe_sub_func_int32_t_s_s(((p_26 | (l_514 , (safe_sub_func_int32_t_s_s(((l_608 , &l_514) != (void*)0), (safe_sub_func_uint16_t_u_u(p_26, p_26)))))) | 2), 1)) > (*l_675)), 0))), p_26)) > p_26);
        }
        /* facts after branching */
        assert (l_435 == &l_555 || l_435 == &l_368);
        (**l_483) = (**l_483);
        l_700 = ((((safe_mul_func_uint16_t_u_u(p_26, (0U && (safe_rshift_func_int16_t_s_u(((((((&l_555 != (void*)0) && (safe_add_func_uint16_t_u_u(p_26, ((((safe_lshift_func_uint16_t_u_s((1 | p_26), (*l_675))) , l_514) , 4294967290U) ^ (*l_435))))) <= p_26) | (*l_435)) != p_26) <= (*l_27)), 13))))) <= 0x023BC7E0) != (-1)) & p_26);
    }
    return p_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(int32_t * p_30, int32_t * p_31, int16_t  p_32, int32_t * p_33, int8_t  p_34)
{ /* block id: 136 */
    struct S0 l_372 = {8337,18911,-13,1007,415,-22897,3,11,5,497};
    struct S0 *l_371 = &l_372;
    struct S0 **l_370 = &l_371;
    struct S0 ***l_369 = &l_370;
    struct S0 ****l_373 = &l_369;
    int32_t **l_379 = (void*)0;
    int32_t ***l_378 = &l_379;
    uint32_t l_382 = 0xC2580E91;
    uint16_t l_383 = 65532U;
    int32_t l_405 = 0xF3550DCA;
    (*l_373) = l_369;
    if (((safe_sub_func_uint32_t_u_u(((void*)0 == (**l_369)), (safe_sub_func_int32_t_s_s((((l_378 != &l_379) && l_372.f1) == (p_34 , ((((safe_rshift_func_int16_t_s_s(p_32, 15)) && ((p_32 == p_34) || l_382)) || p_34) >= 0xF727))), 0xBF75F060)))) == 0x3288))
    { /* block id: 138 */
        uint32_t l_392 = 0xC10346A9;
        int32_t ****l_395 = &l_378;
        int32_t *****l_394 = &l_395;
        int16_t l_396 = 0xD352;
        int32_t l_401 = 0;
        int32_t *l_400 = &l_401;
        struct S0 l_402 = {14678,16836,13,-922,581,-14806,0,1,-6,247};
        (*p_33) = ((l_383 > ((((safe_mul_func_int16_t_s_s(p_34, (safe_mul_func_uint16_t_u_u(0xA29D, ((safe_rshift_func_uint16_t_u_u(0xAFD6, 9)) > ((((p_32 , (p_34 ^ ((safe_sub_func_uint32_t_u_u(((l_392 || (+(l_394 != &l_395))) >= p_32), p_34)) & l_396))) < l_372.f0) < p_32) >= p_32)))))) , 1U) < p_34) && l_396)) <= p_34);
lbl_399:
        for (l_396 = 0; (l_396 == 7); l_396 = safe_add_func_uint32_t_u_u(l_396, 2))
        { /* block id: 142 */
            (*l_370) = (*l_370);
            if (l_372.f1)
                goto lbl_399;
        }
        p_30 = func_35(l_400);
        /* statement id: 146 */
        assert (p_30 == &l_401 || p_30 == 0);
        (***l_369) = l_402;
    }
    else
    { /* block id: 148 */
        struct S0 l_404 = {10980,6337,11,268,232,-14869,1,4,-8,41};
        (*p_33) = (+(p_34 > ((0x64C0B98C > (*p_31)) != 0xC4CD)));
        (*l_371) = l_404;
    }
    /* facts after branching */
    //assert (p_30 == &l_28 || p_30 == 0 || p_30 == dangling);
    return l_405;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_35(int32_t * p_36)
{ /* block id: 2 */
    int32_t l_44 = 5;
    int8_t l_45 = 0x8B;
    struct S0 *l_345 = (void*)0;
    struct S0 *l_346 = (void*)0;
    struct S0 *l_347 = (void*)0;
    struct S0 l_348 = {8097,19686,14,964,701,-10799,3,19,-18,65};
    struct S0 **l_349 = &l_345;
    int32_t *l_362 = (void*)0;
    l_348 = func_37(func_41(p_36, l_44), p_36, l_45);
    (*l_349) = &l_348;
    /* statement id: 126 */
    assert (l_345 == &l_348);
    if ((*p_36))
    { /* block id: 127 */
        int32_t l_352 = 0x65337C06;
        int32_t *l_351 = &l_352;
        int32_t **l_350 = &l_351;
        const struct S0 *l_361 = &l_348;
        float l_366 = (-0x5.2p+1);
        float *l_365 = &l_366;
        (*l_350) = p_36;
        /* statement id: 128 */
        //assert (l_351 == &l_28 || l_351 == &l_401 || l_351 == &l_368 || l_351 == &l_441 || l_351 == &l_555 || l_351 == &l_565 || l_351 == &l_633 || l_351 == &l_767 || l_351 == &l_851 || l_351 == &l_1432 || l_351 == &l_1454);
        (*l_350) = ((((0x179949B4 < ((safe_lshift_func_int16_t_s_u((((((safe_add_func_float_f_f(((*l_351) < ((safe_mul_func_float_f_f(0x6.41046Ap+35, ((void*)0 != (*l_350)))) == ((((safe_mul_func_float_f_f(0xB.3005CFp+51, ((void*)0 == l_361))) > (((l_348.f5 , (**l_350)) < l_348.f8) < l_348.f6)) < l_44) , (*l_351)))), 0xA.8D6F8Ap+81)) <= (*l_351)) , (**l_350)) & l_348.f8) >= l_45), l_348.f4)) >= 0xB35A70BD)) && (**l_350)) == l_348.f3) , l_362);
        /* statement id: 129 */
        assert (l_351 == 0);
        (*l_350) = p_36;
        /* statement id: 130 */
        //assert (l_351 == &l_28 || l_351 == &l_401 || l_351 == &l_368 || l_351 == &l_441 || l_351 == &l_555 || l_351 == &l_565 || l_351 == &l_633 || l_351 == &l_767 || l_351 == &l_851 || l_351 == &l_1432 || l_351 == &l_1454);
        (*l_365) = (safe_sub_func_float_f_f((**l_350), (*l_351)));
    }
    else
    { /* block id: 132 */
        int32_t **l_367 = &l_362;
        (*l_367) = p_36;
        /* statement id: 133 */
        //assert (l_362 == &l_28 || l_362 == &l_401 || l_362 == &l_368 || l_362 == &l_441 || l_362 == &l_555 || l_362 == &l_565 || l_362 == &l_633 || l_362 == &l_767 || l_362 == &l_851 || l_362 == &l_1432 || l_362 == &l_1454);
    }
    /* facts after branching */
    //assert (l_362 == &l_28 || l_362 == 0 || l_362 == &l_401 || l_362 == &l_368 || l_362 == &l_441 || l_362 == &l_555 || l_362 == &l_565 || l_362 == &l_633 || l_362 == &l_767 || l_362 == &l_851 || l_362 == &l_1432 || l_362 == &l_1454);
    return l_362;
    /* statement id: 135 */
    //assert (func_35_rv == &l_28 || func_35_rv == 0 || func_35_rv == &l_401 || func_35_rv == &l_368 || func_35_rv == &l_441 || func_35_rv == &l_555 || func_35_rv == &l_565 || func_35_rv == &l_633 || func_35_rv == &l_767 || func_35_rv == &l_851 || func_35_rv == &l_1432 || func_35_rv == &l_1454);
}


/* ------------------------------------------ */
/* 
 * reads : l_28 l_401 l_368 l_441 l_555 l_565 l_633 l_767 l_851 l_1432 l_1454
 * writes: l_28 l_401 l_368 l_441 l_555 l_565 l_633 l_767 l_851 l_1432 l_1454
 */
static const struct S0  func_37(uint16_t  p_38, int32_t * p_39, uint32_t  p_40)
{ /* block id: 5 */
    uint16_t l_48 = 0x61D0;
    int16_t l_56 = (-1);
    int32_t l_57 = (-1);
    int32_t l_58 = 0x3A3B2B4B;
    float l_59 = 0xD.8FCBD0p+16;
    struct S0 l_62 = {8187,1841,9,-908,420,-26841,1,0,-14,509};
    const int32_t l_147 = 0x5695F44C;
    int8_t l_193 = 1;
    int32_t **l_226 = (void*)0;
    int32_t ***l_225 = &l_226;
    struct S0 *l_252 = &l_62;
    struct S0 **l_251 = &l_252;
    int32_t ****l_275 = &l_225;
    int32_t *****l_274 = &l_275;
    int32_t l_296 = 0x7F70EE47;
    const int32_t ****l_341 = (void*)0;
    const struct S0 l_344 = {19296,1486,-15,-310,135,-31385,1,13,5,46};
    (*p_39) = (-10);
    (*p_39) = (p_40 <= (safe_mul_func_int16_t_s_s((l_48 != 9), (((p_38 || l_48) | (0x5D447567 == ((((((safe_mod_func_uint32_t_u_u(((4294967293U != ((safe_mul_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((((((((+p_38) & (((l_48 ^ l_48) <= 0x580B) , l_48)) , l_56) == l_57) , p_39) == (void*)0) , l_57), 0xBE33BD0D)), p_38)) || l_57)) < l_56), l_57)) & l_58) > 0xF959) , p_40) <= l_58) , l_57))) ^ l_48))));
    for (l_57 = 0; (l_57 == (-30)); l_57 = safe_sub_func_uint16_t_u_u(l_57, 1))
    { /* block id: 10 */
        struct S0 *l_63 = &l_62;
        int32_t l_79 = 0;
        float *l_133 = &l_59;
        int32_t *l_152 = &l_79;
        int8_t l_219 = 0;
        float *l_220 = &l_59;
        int32_t ****l_248 = &l_225;
        int32_t ****l_276 = (void*)0;
    }
    for (p_38 = (-9); (p_38 == 49); p_38 = safe_add_func_uint32_t_u_u(p_38, 3))
    { /* block id: 121 */
        (*p_39) = (*p_39);
    }
    return l_344;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_41(const int32_t * p_42, int16_t  p_43)
{ /* block id: 3 */
    return p_43;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 301
   depth: 1, occurrence: 36
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 76
breakdown:
   indirect level: 0, occurrence: 36
   indirect level: 1, occurrence: 14
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 36
breakdown:
   indirect level: 0, occurrence: 36
XXX times a bitfields struct's address is taken: 23
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 55
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 48

XXX max expression depth: 47
breakdown:
   depth: 1, occurrence: 179
   depth: 2, occurrence: 35
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 10, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 3
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 5
   depth: 29, occurrence: 2
   depth: 32, occurrence: 2
   depth: 34, occurrence: 1
   depth: 40, occurrence: 1
   depth: 47, occurrence: 1

XXX total number of pointers: 235

XXX times a variable address is taken: 267
XXX times a pointer is dereferenced on RHS: 429
breakdown:
   depth: 1, occurrence: 236
   depth: 2, occurrence: 68
   depth: 3, occurrence: 65
   depth: 4, occurrence: 31
   depth: 5, occurrence: 29
XXX times a pointer is dereferenced on LHS: 151
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 14
   depth: 3, occurrence: 14
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 47
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 20
XXX times a pointer is qualified to be dereferenced: 1336

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 865
   level: 2, occurrence: 239
   level: 3, occurrence: 184
   level: 4, occurrence: 122
   level: 5, occurrence: 135
XXX number of pointers point to pointers: 122
XXX number of pointers point to scalars: 91
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 24.3
XXX average alias set size: 1.52

XXX times a non-volatile is read: 2305
XXX times a non-volatile is write: 434
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 4
XXX backward jumps: 5

XXX stmts: 168
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 30
   depth: 2, occurrence: 33
   depth: 3, occurrence: 27
   depth: 4, occurrence: 23
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 16.2
XXX percentage an existing variable is used: 83.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

