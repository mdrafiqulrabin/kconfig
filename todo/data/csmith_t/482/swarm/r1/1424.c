/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      170482284
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int16_t  f0;
   uint32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 65535U;
static union U0 g_24 = {2};
static int32_t g_42 = 0xE9F48648;
static int32_t **g_52 = (void*)0;
static int32_t g_80 = 0x5E2E4BCB;
static union U0 g_84 = {0x8767};
static int32_t g_106 = 0x8BF40F85;
static const int32_t *g_108 = &g_80;
static const int32_t **g_107 = &g_108;
static const float *g_126 = (void*)0;
static float g_128 = (-0x1.Dp+1);
static uint16_t g_381 = 0x19B4;
static uint16_t g_382 = 0x2245;
static int32_t g_437 = 0xCC21128C;
static uint32_t g_441 = 0x790F11AC;
static int32_t ***g_446 = &g_52;
static int32_t ****g_445 = &g_446;
static union U0 g_465 = {0xCC1E};
static union U0 *g_464 = &g_465;
static int16_t g_540 = 0x54D7;
static const uint32_t g_578 = 4294967295U;
static int16_t g_585 = (-1);
static union U0 **g_657 = (void*)0;
static union U0 ***g_656 = &g_657;
static int32_t g_709 = 0x719C0ED0;
static uint32_t g_726 = 4294967294U;
static int16_t g_781 = 0;
static int32_t g_1023 = 3;


/* --- FORWARD DECLARATIONS --- */
inline static float  func_1(void);
static float  func_18(int16_t  p_19, union U0  p_20, int32_t  p_21, uint16_t  p_22);
static int32_t  func_25(union U0  p_26, int32_t  p_27);
static union U0  func_28(const uint16_t  p_29, const uint32_t  p_30, uint32_t  p_31, uint16_t  p_32, uint16_t  p_33);
inline static uint16_t  func_34(int16_t  p_35, uint32_t  p_36, int16_t  p_37, int32_t  p_38, const uint32_t  p_39);
static uint16_t  func_47(int32_t ** p_48, int32_t * p_49, uint32_t  p_50, int16_t  p_51);
inline static const float  func_55(uint16_t  p_56, uint32_t  p_57);
static const int32_t  func_58(uint16_t  p_59, int32_t ** p_60, const int32_t ** p_61, int32_t * p_62);
inline static const int32_t ** func_63(int32_t * p_64, int32_t  p_65, uint32_t  p_66);
static int32_t  func_73(uint32_t  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_24 g_24.f0 g_52 g_42 g_80 g_84.f0 g_106 g_107 g_126 g_108 g_84.f1 g_465.f0 g_437 g_578 g_441 g_382 g_381 g_446 g_656 g_540 g_726 g_585 g_445 g_781 g_709 g_465.f1 g_1023
 * writes: g_80 g_106 g_84.f1 g_108 g_128 g_381 g_42 g_540 g_726 g_437 g_585 g_709 g_656 g_52 g_465.f1 g_1023
 */
inline static float  func_1(void)
{ /* block id: 0 */
    float l_2 = 0xF.C3099Cp+92;
    int32_t l_23 = 1;
    int16_t l_40 = 0x260D;
    uint32_t l_777 = 1U;
    int32_t *l_1022 = &g_1023;
    (*l_1022) &= ((g_3 > ((uint16_t)(((uint32_t)(((uint16_t)((int16_t)((uint16_t)((int32_t)((-7) ^ (((float)((0x1.1p-1 < (g_3 < (-0x9.0p-1))) > ((func_18((l_23 , 0x718B), g_24, func_25(func_28(func_34((g_24.f0 , g_3), g_24.f0, l_23, l_40, g_24.f0), l_23, l_40, l_40, l_23), l_777), l_40) >= l_40) , l_40)) + (float)l_40) , 65531U)) + (int32_t)l_23) >> (uint16_t)g_382) + (int16_t)g_382) + (uint16_t)1U) | l_777) - (uint32_t)l_777) > g_382) << (uint16_t)l_777)) >= g_3);
    /* statement id: 351 */
    //assert (g_108 == &g_709 || g_108 == 0 || g_108 == &g_106 || g_108 == &g_437 || g_108 == dangling || g_108 == &g_80);
    assert (g_656 == 0 || g_656 == &g_657);
    return (*l_1022);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_18(int16_t  p_19, union U0  p_20, int32_t  p_21, uint16_t  p_22)
{ /* block id: 348 */
    float l_1019 = 0x4.5F1D2Cp-46;
    float *l_1020 = &l_1019;
    int32_t l_1021 = 0xBC7FE7DE;
    (*l_1020) = l_1019;
    return l_1021;
}


/* ------------------------------------------ */
/* 
 * reads : g_781 g_709 g_84.f0 g_726 g_585 g_107 g_437 g_381 g_106 g_445 g_446 g_52 g_3 g_108 g_80 g_84.f1 g_578 g_441 g_42 g_24.f0 g_540 g_382 g_656 g_465.f1
 * writes: g_585 g_84.f1 g_108 g_437 g_106 g_381 g_709 g_128 g_656 g_42 g_52 g_540 g_80 g_465.f1
 */
static int32_t  func_25(union U0  p_26, int32_t  p_27)
{ /* block id: 237 */
    int32_t l_782 = 1;
    uint16_t l_826 = 65528U;
    float *l_827 = &g_128;
    int32_t *l_830 = &g_709;
    int32_t **l_829 = &l_830;
    const union U0 l_853 = {-1};
    uint16_t l_866 = 0x8C4E;
    union U0 ****l_927 = &g_656;
    const uint32_t l_956 = 0x9E072109;
    union U0 ****l_975 = &g_656;
    const int32_t ***l_1003 = (void*)0;
    const int32_t ****l_1002 = &l_1003;
    if (((((-(float)(((float)(g_781 <= p_27) + (float)((l_782 < p_27) < l_782)) >= ((float)p_27 + (float)(((((int32_t)((int32_t)((((uint16_t)((uint16_t)0x1C7A / (uint16_t)((((uint16_t)(p_27 == (l_782 <= g_709)) + (uint16_t)65529U) > p_27) , 0xC426)) >> (uint16_t)g_84.f0) == 4294967294U) < l_782) % (int32_t)l_782) - (int32_t)l_782) || p_26.f0) , 0x6.C6EDAEp-25) == 0x1.5p-1)))) , g_726) , 0xE89694E8) <= l_782))
    { /* block id: 238 */
        uint32_t l_803 = 5U;
        int32_t **l_808 = (void*)0;
        for (g_585 = 0; (g_585 <= (-30)); g_585 -= 2)
        { /* block id: 241 */
            int32_t *l_799 = (void*)0;
            for (g_84.f1 = (-22); (g_84.f1 <= 45); g_84.f1 += 1)
            { /* block id: 244 */
                int32_t *l_801 = (void*)0;
                int32_t *l_802 = &g_437;
                const int32_t ***l_805 = &g_107;
                const int32_t ****l_804 = &l_805;
                (*g_107) = l_799;
                /* statement id: 245 */
                assert (g_108 == 0);
                (*l_802) |= (!0x936D);
                (*l_802) ^= (l_803 != (p_26.f0 || ((&g_446 != l_804) & (((uint16_t)(((void*)0 != l_808) == (((-1) && ((uint32_t)((int32_t)0xC9FF2C28 / (int32_t)((((int16_t)(p_26.f0 , g_381) - (int16_t)0x9143) ^ l_782) & p_27)) + (uint32_t)p_27)) <= p_26.f0)) / (uint16_t)g_726) == 3))));
                if (p_27)
                    continue;
            }
        }
        /* facts after for loop */
        //assert (g_108 == 0 || g_108 == &g_437 || g_108 == dangling || g_108 == &g_80);
    }
    else
    { /* block id: 251 */
        int32_t *l_815 = &g_106;
        union U0 *l_909 = &g_24;
        (*g_107) = l_815;
        /* statement id: 252 */
        assert (g_108 == &g_106);
        for (g_437 = (-1); (g_437 >= 4); g_437 += 8)
        { /* block id: 255 */
            int32_t *l_818 = (void*)0;
            (*g_107) = l_818;
            /* statement id: 256 */
            assert (g_108 == 0);
        }
        /* facts after for loop */
        assert (g_108 == 0 || g_108 == &g_106);
        if ((((!(((int16_t)(((uint32_t)((uint16_t)((0xA935297C < ((((l_826 >= l_826) , l_827) == l_827) , (((p_27 & (*l_815)) && (!(p_27 && (l_829 != (**g_445))))) , 0x36AAA67C))) ^ p_27) << (uint16_t)g_3) / (uint32_t)p_27) && 1) << (int16_t)4) & (*l_815))) == 4294967288U) ^ p_26.f0))
        { /* block id: 258 */
            int16_t l_850 = 1;
            int32_t ****l_871 = &g_446;
            union U0 ****l_915 = &g_656;
            (*l_815) &= ((int16_t)(-2) - (int16_t)(*l_830));
            for (l_782 = 11; (l_782 >= (-22)); l_782 -= 1)
            { /* block id: 262 */
                int16_t l_849 = 0;
                for (l_826 = 0; (l_826 != 5); l_826 += 5)
                { /* block id: 265 */
                    int32_t *l_846 = &g_709;
                    union U0 **l_864 = &g_464;
                    for (g_381 = 15; (g_381 != 33); g_381 += 9)
                    { /* block id: 268 */
                        int32_t l_865 = 0x5284B9BD;
                        (*l_830) = ((uint16_t)((int32_t)((*l_815) != ((uint16_t)(~(((*g_107) != l_846) <= ((int32_t)((void*)0 == (*g_445)) - (int32_t)((l_849 != l_850) ^ (((uint32_t)((l_853 , ((uint32_t)(**l_829) / (uint32_t)p_26.f0)) > 0x86DC961A) - (uint32_t)(*l_830)) > (*l_815)))))) << (uint16_t)3)) % (int32_t)p_26.f0) - (uint16_t)g_84.f0);
                        (*l_827) = (*l_815);
                        l_866 ^= ((8U && ((((int16_t)((((-1) || 65531U) >= ((((p_27 , ((((uint16_t)p_27 - (uint16_t)((((8 ^ (-(int16_t)((int16_t)g_80 % (int16_t)(((~(**l_829)) && (((l_864 == l_864) && 4294967287U) & (*l_830))) , 0xE8F4)))) && (*l_815)) <= g_106) < (*l_846))) < g_106) , 0xADD3)) == l_849) == l_849) || 0x8D8B)) | l_865) % (int16_t)g_381) & (-2)) && 0xDC591364)) == 0x8CCC);
                    }
                    if (((int32_t)(p_26.f0 == ((void*)0 != l_871)) + (int32_t)(((int16_t)(-1) % (int16_t)(((*l_815) || 8U) | ((uint16_t)(l_853 , p_27) << (uint16_t)3))) && (((int32_t)(*l_846) % (int32_t)p_26.f0) ^ (*l_815)))))
                    { /* block id: 273 */
                        return l_849;
                    }
                    else
                    { /* block id: 275 */
                        union U0 ****l_878 = &g_656;
                        (*l_878) = (void*)0;
                        /* statement id: 276 */
                        assert (g_656 == 0);
                        return p_27;
                    }
                }
                if (((uint16_t)g_726 >> (uint16_t)((((float)((-0x7.Ap-1) >= ((((p_26.f0 | ((uint16_t)(((~(!((((-(int16_t)((uint32_t)(((int32_t)((uint16_t)((uint32_t)((p_26.f0 , g_381) | (g_84.f0 < ((int32_t)p_26.f0 - (int32_t)((*l_815) > ((~((uint16_t)(*l_815) + (uint16_t)7U)) > (*l_815)))))) / (uint32_t)p_26.f0) / (uint16_t)1U) % (int32_t)4294967295U) || 0xF056) - (uint32_t)p_27)) , p_26.f0) , g_80) > (*l_815)))) > p_26.f0) == 0xD0A7) - (uint16_t)g_84.f1)) , (*l_815)) , (*l_815)) <= g_578)) - (float)p_26.f0) , 1) ^ 0xDE4A)))
                { /* block id: 280 */
                    (*l_827) = ((((p_26.f0 >= 0xB16778F5) > ((((uint32_t)(p_27 < 0xF7D1A135) / (uint32_t)((uint16_t)(*l_830) << (uint16_t)((int16_t)((uint16_t)(g_441 >= (p_26.f0 <= 0x594C)) >> (uint16_t)15) / (int16_t)(((*l_815) < g_84.f0) & g_578)))) , (void*)0) != &g_446)) , l_909) == (void*)0);
                    return l_849;
                }
                else
                { /* block id: 283 */
                    uint32_t l_926 = 4294967295U;
                    if ((*l_830))
                        break;
                    for (g_42 = 16; (g_42 < 10); g_42 -= 2)
                    { /* block id: 287 */
                        (*l_827) = p_27;
                        (*g_107) = (*g_107);
                    }
                    for (g_585 = (-8); (g_585 >= 26); g_585 += 9)
                    { /* block id: 293 */
                        const uint16_t l_914 = 0x252E;
                        (*l_815) = ((func_28(l_914, (*l_830), ((g_441 , ((l_915 == (g_3 , &g_656)) < (((((((((uint32_t)((int16_t)g_84.f0 - (int16_t)(((uint16_t)(((((((float)((g_84.f1 > ((float)g_585 - (float)0x0.Cp+1)) == 0x1.2p-1) + (float)p_26.f0) != p_26.f0) , (-1)) , g_24.f0) & g_437) , 0x6FE7) - (uint16_t)(-8)) || (*l_830))) % (uint32_t)0x99EA393D) < l_926) , l_927) != l_927) >= (-1)) >= p_26.f0) <= l_926) | l_926))) & 0x3357051D), g_726, p_27) , 0x51F31AC1) ^ (**l_829));
                        return l_850;
                    }
                }
                (*g_107) = (void*)0;
                /* statement id: 298 */
                assert (g_108 == 0);
            }
        }
        else
        { /* block id: 300 */
            int32_t l_929 = 0x6579361D;
            int32_t *l_930 = &g_709;
            l_929 = (!g_84.f1);
            (**g_445) = (void*)0;
            l_930 = (*l_829);
            (*g_107) = (*l_829);
            /* statement id: 304 */
            assert (g_108 == &g_709);
        }
        /* facts after branching */
        assert (g_108 == &g_709 || g_108 == 0 || g_108 == &g_106);
        for (g_585 = (-16); (g_585 <= 10); g_585 += 4)
        { /* block id: 308 */
            for (g_540 = 0; (g_540 == 1); g_540 += 1)
            { /* block id: 311 */
                float *l_935 = &g_128;
                (*l_830) = ((4294967295U | ((void*)0 != l_935)) == p_26.f0);
            }
        }
    }
    /* facts after branching */
    //assert (g_108 == &g_709 || g_108 == 0 || g_108 == &g_106 || g_108 == &g_437 || g_108 == dangling || g_108 == &g_80);
    for (g_84.f1 = 15; (g_84.f1 >= 50); g_84.f1 += 1)
    { /* block id: 318 */
        int32_t l_941 = 0x7A5DD097;
        const int32_t ***l_946 = &g_107;
        int32_t l_949 = 0x8839C7F7;
        union U0 **l_961 = &g_464;
        float *l_966 = (void*)0;
        uint32_t l_967 = 0x06E5E727;
        (*l_827) = (((**g_445) == (void*)0) >= (!(0x1.616FAFp-8 < 0x1.Ep-1)));
        for (g_42 = (-18); (g_42 == (-20)); g_42 -= 1)
        { /* block id: 322 */
            return l_941;
        }
        l_949 = ((int16_t)(g_84.f0 , ((0x945254E8 && ((((int32_t)((l_941 , (p_27 , l_946)) != (*g_445)) * (int32_t)(((int32_t)1 - (int32_t)0x62A3BC41) != 0xE6B5)) & p_26.f0) > 0xB129EF44)) | g_84.f0)) << (int16_t)p_26.f0);
        (*l_827) = ((float)(((float)(((float)(l_956 < (((g_84.f1 , ((float)(((float)(((void*)0 != l_961) , ((float)((((&g_656 != &g_656) <= ((float)(*l_830) + (float)(((*l_830) , l_830) == l_966))) <= (-0x3.Cp+1)) > l_967) + (float)p_26.f0)) / (float)(**l_829)) < 0x7.3C967Dp+44) - (float)p_27)) < 0xD.A75744p-39) >= 0x0.3p+1)) / (float)(-0x8.3p-1)) > (*l_830)) - (float)(*l_830)) >= 0xA.891930p+84) - (float)p_26.f0);
    }
    (*l_829) = (*l_829);
    for (g_80 = 0; (g_80 <= (-28)); g_80 -= 4)
    { /* block id: 331 */
        union U0 ***l_984 = &g_657;
        int32_t ***l_987 = &g_52;
        float l_996 = 0x0.0p+1;
        const int16_t l_1007 = 0x2A88;
        (*l_827) = (((&g_656 == (void*)0) <= g_540) != (((void*)0 != &g_446) >= ((float)(!((((0xE0E80FC6 == (((int16_t)p_26.f0 - (int16_t)(((((void*)0 == l_975) > 0x0.4p+1) , 0xE79F) && g_382)) == g_709)) , &l_830) != (void*)0) , p_26.f0)) - (float)0x4.B64FF9p+72)));
        if (((((uint32_t)((uint16_t)((int32_t)(((int32_t)(l_984 == (((((((**l_829) | ((*l_829) == (void*)0)) && ((**l_829) | ((uint32_t)((void*)0 == l_987) + (uint32_t)(((void*)0 == (*l_975)) == (*l_830))))) >= p_26.f0) , 0xA9BD) >= 9U) , (void*)0)) - (int32_t)4294967291U) != 1) + (int32_t)p_26.f0) - (uint16_t)65535U) + (uint32_t)p_27) < 0x2759) >= 0xE669))
        { /* block id: 333 */
            if ((*l_830))
                break;
            return p_26.f0;
        }
        else
        { /* block id: 336 */
            int32_t l_990 = 0x8CC19C0A;
            int32_t ****l_1004 = &g_446;
            int32_t l_1018 = 0x3818E1B6;
            (*l_829) = (*l_829);
            for (g_465.f1 = 0; (g_465.f1 <= 50); ++g_465.f1)
            { /* block id: 340 */
                uint32_t l_993 = 0x2C30C919;
                (**l_829) &= (l_990 != ((uint16_t)g_106 % (uint16_t)l_993));
            }
            /* facts after for loop */
            (*l_830) = (((uint32_t)p_27 - (uint32_t)p_26.f0) ^ (((uint16_t)p_27 >> (uint16_t)((int16_t)g_781 + (int16_t)((0 >= (p_27 == (p_26.f0 ^ (~((((((l_1002 != l_1004) > (*l_830)) < p_27) >= p_26.f0) <= 0x77E7) <= p_27))))) == g_80))) | p_27));
            (**l_829) &= (((g_24.f0 , ((uint32_t)p_27 - (uint32_t)((p_26.f0 > (((l_1007 && ((int16_t)g_382 >> (int16_t)5)) == (((uint16_t)p_26.f0 >> (uint16_t)((int16_t)(((((float)0x9.FDD3C2p+10 + (float)((float)(p_26.f0 , g_578) - (float)g_726)) > 0x2.808F35p-74) , 0xCEDF25D9) == p_26.f0) << (int16_t)0)) & g_381)) <= p_26.f0)) || 1))) > 0x337A) || l_1018);
        }
        /* facts after branching */
    }
    return p_27;
}


/* ------------------------------------------ */
/* 
 * reads : g_441
 * writes:
 */
static union U0  func_28(const uint16_t  p_29, const uint32_t  p_30, uint32_t  p_31, uint16_t  p_32, uint16_t  p_33)
{ /* block id: 234 */
    uint16_t l_766 = 0x5CB1;
    int32_t l_775 = 0;
    union U0 l_776 = {0x9D09};
    l_775 = (((-1) & l_766) ^ ((int32_t)((uint16_t)(l_766 , g_441) / (uint16_t)1U) / (int32_t)((int32_t)(((uint16_t)p_29 << (uint16_t)0) || (((void*)0 != &g_84) <= (0xA67200DE == 0x5AEC5E84))) + (int32_t)l_766)));
    return l_776;
    /* statement id: 236 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_52 g_42 g_3 g_24.f0 g_80 g_84.f0 g_106 g_107 g_126 g_108 g_84.f1 g_465.f0 g_437 g_578 g_441 g_382 g_381 g_446 g_656 g_540 g_726 g_585 g_445
 * writes: g_80 g_106 g_84.f1 g_108 g_128 g_381 g_42 g_540 g_726 g_437
 */
inline static uint16_t  func_34(int16_t  p_35, uint32_t  p_36, int16_t  p_37, int32_t  p_38, const uint32_t  p_39)
{ /* block id: 1 */
    int32_t *l_41 = &g_42;
    int32_t **l_43 = (void*)0;
    int32_t **l_44 = &l_41;
    int32_t *l_109 = &g_42;
    uint16_t l_626 = 65535U;
    int32_t ****l_630 = &g_446;
    float l_633 = 0x1.DA595Bp+89;
    union U0 l_636 = {6};
    uint32_t l_651 = 0xE32D842D;
    int32_t l_688 = 0x35F985DE;
    const float *l_751 = &g_128;
    float *l_752 = &g_128;
    float l_763 = 0xA.86D9A1p+64;
    (*l_44) = l_41;
    (*l_44) = &g_42;
    if ((((uint16_t)func_47(g_52, (*l_44), (((float)(*l_41) / (float)(func_55(g_42, (func_58(g_3, &l_41, func_63((*l_44), g_24.f0, ((int16_t)g_3 >> (int16_t)7)), l_109) , 0x13F5BBDA)) <= p_35)) , g_382), (*l_109)) % (uint16_t)(*l_109)) && 6U))
    { /* block id: 190 */
        int32_t ****l_627 = &g_446;
        int16_t l_631 = (-1);
        union U0 *l_632 = &g_465;
        g_128 = (((float)(((float)((l_626 , &g_446) != l_627) / (float)((((float)(((void*)0 != l_630) == ((((*l_41) , 1U) , (l_631 == (l_632 != &g_24))) != g_80)) + (float)0x0.Dp+1) == p_39) > 0x9.2B0D93p-54)) == l_633) + (float)p_36) >= (**l_44));
        for (g_381 = (-29); (g_381 != (-5)); g_381 += 8)
        { /* block id: 194 */
            const int32_t *l_637 = &g_437;
            (*l_109) |= (l_636 , (((*g_446) == (void*)0) != p_37));
            (*g_107) = l_637;
            /* statement id: 196 */
            assert (g_108 == &g_437);
            for (g_106 = 0; (g_106 < (-16)); g_106 -= 9)
            { /* block id: 199 */
                (*l_109) &= p_37;
            }
        }
        /* facts after for loop */
        //assert (g_108 == &g_437 || g_108 == dangling || g_108 == &g_80);
    }
    else
    { /* block id: 203 */
        float *l_645 = &l_633;
        float *l_646 = &g_128;
        int32_t l_649 = 0x47DD618E;
        int32_t ****l_650 = &g_446;
        int32_t l_652 = 0xED4B8BE8;
        union U0 ***l_658 = &g_657;
        float l_678 = (-0x1.8p-1);
        float l_679 = 0x1.62146Bp-24;
        int32_t l_750 = 0x7717D998;
        int32_t *l_764 = (void*)0;
        int32_t *l_765 = &g_80;
        if ((p_36 < ((uint16_t)g_465.f0 << (uint16_t)(((int16_t)((-(uint16_t)p_39) == (((((l_645 != l_646) , ((uint16_t)1U - (uint16_t)(g_578 < (((l_649 , &g_446) != l_650) && p_36)))) || (-1)) | l_651) <= 1U)) + (int16_t)l_652) != 65535U))))
        { /* block id: 204 */
            uint32_t l_655 = 0x86C118D9;
            for (p_38 = (-19); (p_38 < 17); p_38 += 1)
            { /* block id: 207 */
                (*l_41) |= p_39;
            }
            (*l_109) |= l_655;
            l_658 = g_656;
        }
        else
        { /* block id: 212 */
            float l_664 = 0x8.C68E80p+29;
            int32_t l_677 = 0;
            int32_t *l_680 = (void*)0;
            int32_t l_681 = (-2);
            uint16_t l_749 = 65535U;
            l_681 &= ((uint32_t)(p_35 <= ((((((uint32_t)g_437 - (uint32_t)p_38) , (-(int32_t)(((l_652 , (((float)((float)(((int32_t)(((uint16_t)g_80 - (uint16_t)(*l_109)) > 0xFACAF62C) + (int32_t)p_39) , ((float)((float)((((((((*l_109) , p_38) < g_106) || p_36) < p_38) , l_677) , p_37) < l_652) + (float)g_441) / (float)(**l_44))) - (float)p_39) - (float)p_35) == l_678)) , 8U) != p_37))) ^ p_35) == g_84.f1) || g_24.f0)) - (uint32_t)(-9));
            for (l_651 = 0; (l_651 < 5); l_651 += 1)
            { /* block id: 216 */
                int32_t l_692 = 0xC975D2CA;
                int32_t l_697 = 0xDF42935A;
                int32_t l_708 = 0xCC9D7237;
                int32_t l_715 = (-10);
                for (g_540 = 0; (g_540 == (-24)); g_540 -= 2)
                { /* block id: 219 */
                    int32_t *l_686 = &g_80;
                    int32_t *l_687 = (void*)0;
                    int32_t *l_689 = (void*)0;
                    int32_t *l_690 = &g_80;
                    int32_t *l_691 = &g_80;
                    int32_t *l_693 = &l_677;
                    int32_t *l_694 = &l_692;
                    int32_t *l_695 = &g_42;
                    int32_t *l_696 = &g_80;
                    int32_t *l_698 = &l_677;
                    int32_t *l_699 = &l_677;
                    int32_t *l_700 = &g_437;
                    int32_t *l_701 = &g_42;
                    int32_t *l_702 = &l_688;
                    int32_t *l_703 = &l_697;
                    int32_t *l_704 = (void*)0;
                    int32_t *l_705 = &g_106;
                    int32_t *l_706 = &g_437;
                    int32_t *l_707 = &l_649;
                    int32_t *l_710 = &g_709;
                    int32_t *l_711 = &g_709;
                    int32_t *l_712 = &l_697;
                    int32_t *l_713 = &g_42;
                    int32_t *l_714 = &l_677;
                    int32_t *l_716 = &l_652;
                    int32_t *l_717 = &l_649;
                    int32_t *l_718 = &g_709;
                    int32_t *l_719 = &g_42;
                    int32_t *l_720 = &g_106;
                    int32_t l_721 = 0x653CF7F9;
                    int32_t *l_722 = &l_681;
                    int32_t *l_723 = &l_697;
                    int32_t *l_724 = (void*)0;
                    int32_t *l_725 = &l_692;
                    ++g_726;
                    (*g_107) = &l_721;
                    /* statement id: 221 */
                    assert (g_108 == &l_721);
                    for (g_381 = 0; (g_381 != 45); g_381 += 3)
                    { /* block id: 224 */
                        int32_t ***l_735 = &g_52;
                        (*l_700) |= ((int16_t)((int16_t)((((l_735 == (void*)0) || (((uint32_t)(0xE452 > g_42) - (uint32_t)((&l_636 == &l_636) || (*g_108))) , ((uint16_t)((((!(((uint16_t)((int32_t)(((0xFD2DB94D || (((((((int16_t)((((**l_44) < (*l_41)) , l_749) > l_697) >> (int16_t)12) >= (*l_41)) <= l_750) <= (-8)) ^ p_37) == p_36)) <= 0xD0ECDA60) != p_38) / (int32_t)g_585) % (uint16_t)g_578) & g_382)) > p_38) , 0) , p_39) >> (uint16_t)0))) || (**g_107)) > 4294967293U) / (int16_t)p_37) >> (int16_t)p_36);
                        (*g_107) = &l_692;
                        /* statement id: 226 */
                        assert (g_108 == &l_692);
                    }
                    /* facts after for loop */
                    assert (g_108 == &l_692 || g_108 == &l_721);
                }
                /* facts after for loop */
                //assert (g_108 == &l_692 || g_108 == dangling || g_108 == &g_80);
            }
        }
        (*l_765) ^= ((l_751 == l_752) != (((*l_650) != ((((uint32_t)l_649 / (uint32_t)((int32_t)((uint16_t)(((uint16_t)p_36 / (uint16_t)((int16_t)p_35 >> (int16_t)((*l_41) && (((*g_445) != (*l_650)) | 65535U)))) > 1) - (uint16_t)p_38) - (int32_t)0xCB59850D)) ^ g_84.f0) , (*g_445))) >= p_38));
    }
    /* facts after branching */
    //assert (g_108 == &g_437 || g_108 == dangling || g_108 == &g_80);
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_106
 * writes:
 */
static uint16_t  func_47(int32_t ** p_48, int32_t * p_49, uint32_t  p_50, int16_t  p_51)
{ /* block id: 187 */
    int16_t l_621 = (-1);
    l_621 = (*p_49);
    return g_106;
}


/* ------------------------------------------ */
/* 
 * reads : g_84.f1 g_106 g_465.f0 g_437 g_578 g_42 g_3 g_441 g_80
 * writes: g_84.f1 g_128 g_106
 */
inline static const float  func_55(uint16_t  p_56, uint32_t  p_57)
{ /* block id: 58 */
    int32_t l_183 = 3;
    float *l_225 = (void*)0;
    union U0 l_226 = {-1};
    float l_234 = 0x1.Ap+1;
    int32_t *l_260 = &g_80;
    int32_t **l_259 = &l_260;
    uint32_t l_300 = 4294967292U;
    float *l_304 = &g_128;
    const uint16_t l_308 = 65530U;
    float l_350 = 0x0.Ep+1;
    int32_t *l_462 = &g_42;
    union U0 **l_480 = &g_464;
    float l_539 = 0x8.3F2840p-69;
    uint16_t l_541 = 0xF76D;
    int32_t ****l_595 = (void*)0;
    uint16_t l_619 = 0U;
    float l_620 = 0x0.Fp-1;
    for (g_84.f1 = 0; (g_84.f1 > 31); g_84.f1 += 5)
    { /* block id: 61 */
        const int32_t l_182 = 0xCCA37329;
        float *l_184 = &g_128;
        uint16_t l_191 = 0xB2BB;
        union U0 *l_258 = &l_226;
        (*l_184) = (l_182 != (l_183 < 0xE.E9F7E8p-36));
    }
    /* facts after for loop */
    for (g_106 = 0; (g_106 != (-4)); g_106 -= 1)
    { /* block id: 99 */
        float *l_335 = (void*)0;
        int32_t l_339 = (-10);
        int32_t ***l_389 = &l_259;
        int32_t l_401 = 0xD652D0F0;
        int32_t l_433 = 4;
        int32_t *l_444 = &l_183;
        int32_t ****l_461 = &g_446;
        union U0 *l_463 = (void*)0;
        int16_t l_517 = (-2);
        float *l_518 = &l_350;
    }
    (*l_304) = (-(float)((((float)(((g_465.f0 , &g_446) != l_595) , ((((float)((g_437 < (((uint16_t)g_578 >> (uint16_t)2) | (*l_462))) , ((float)((float)p_56 + (float)((float)((float)(!((((uint16_t)((int32_t)(((uint16_t)((int16_t)0x780B >> (int16_t)((int16_t)((0x65396BA6 ^ 0xD4506FB5) != 0U) / (int16_t)g_3)) >> (uint16_t)l_619) || g_441) % (int32_t)0xEC1ED4A7) % (uint16_t)(-1)) , 0x0.Dp+1) <= p_57)) + (float)0x4.96C7BEp+32) - (float)p_57)) + (float)l_620)) + (float)(*l_462)) != (*l_260)) < (**l_259))) + (float)0x1.Fp-1) >= p_56) >= 0xA.DF9B02p+34));
    return (**l_259);
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_80 g_24.f0 g_84.f0 g_3 g_126 g_108 g_106 g_84.f1
 * writes: g_80 g_106 g_84.f1 g_108
 */
static const int32_t  func_58(uint16_t  p_59, int32_t ** p_60, const int32_t ** p_61, int32_t * p_62)
{ /* block id: 30 */
    union U0 *l_110 = &g_84;
    int32_t l_111 = 0xD3F42B3F;
    float *l_127 = &g_128;
    uint32_t l_138 = 0xD91AC48A;
    int32_t l_168 = 0x12C47553;
    int32_t l_179 = (-4);
    g_80 &= (**p_60);
    l_111 = (p_59 ^ ((void*)0 != l_110));
    if ((((int16_t)g_42 - (int16_t)(((uint32_t)8U - (uint32_t)p_59) == ((((int32_t)((g_80 & (((uint32_t)g_24.f0 - (uint32_t)((((int16_t)(((((uint32_t)((g_84.f0 >= ((uint16_t)g_3 % (uint16_t)l_111)) , ((g_126 != l_127) != l_111)) + (uint32_t)0x153CB79D) > l_111) == l_111) , g_42) << (int16_t)7) < (*g_108)) <= (*p_62))) && g_84.f0)) && 6) % (int32_t)l_111) & p_59) < 0xE323B5E5))) , (*p_62)))
    { /* block id: 33 */
        int32_t *l_131 = &g_42;
        int32_t **l_130 = &l_131;
        int32_t ***l_129 = &l_130;
        (*l_129) = (void*)0;
        /* statement id: 34 */
        assert (l_130 == 0);
        for (g_106 = (-9); (g_106 <= (-3)); g_106 += 5)
        { /* block id: 37 */
            int16_t l_134 = 3;
            int32_t *l_135 = &g_80;
            (*l_135) = l_134;
            l_138 |= ((int16_t)g_80 >> (int16_t)13);
            for (g_84.f1 = (-25); (g_84.f1 > 31); g_84.f1 += 1)
            { /* block id: 42 */
                (*p_61) = (*p_61);
            }
            /* facts after for loop */
            (*l_135) = 1;
        }
    }
    else
    { /* block id: 47 */
        return g_80;
    }
    for (l_111 = 0; (l_111 != 16); l_111 += 1)
    { /* block id: 52 */
        int32_t l_147 = 0x0C2C5401;
        uint16_t l_166 = 0U;
        float *l_167 = &g_128;
        g_106 = (((int16_t)(((int16_t)((l_147 | (&g_107 != &g_52)) , (((2U || (((uint32_t)((((-1) & ((((((int16_t)0xF34E / (int16_t)((-(uint16_t)l_138) , ((uint32_t)(-(uint16_t)(((uint32_t)((((int16_t)(((int32_t)((uint16_t)((uint32_t)((((l_166 , ((g_24.f0 , g_3) != g_84.f0)) , g_80) , 1U) , g_84.f0) / (uint32_t)l_166) >> (uint16_t)g_24.f0) / (int32_t)4U) | 4294967295U) << (int16_t)10) , l_167) == (void*)0) + (uint32_t)(**p_61)) > l_147)) + (uint32_t)g_24.f0))) | g_84.f0) | 0xC3C34690) >= p_59) == l_147)) < 1U) > 9U) / (uint32_t)l_166) || l_111)) > g_106) != l_168)) % (int16_t)p_59) >= p_59) + (int16_t)p_59) && l_147);
        (*p_61) = &l_168;
        /* statement id: 54 */
        assert (g_108 == &l_168);
        l_147 &= ((((l_166 , ((0xA051 != ((((((((-2) >= (&p_62 == &p_62)) != (((-(uint16_t)(((int16_t)((uint16_t)p_59 - (uint16_t)((uint16_t)((*g_108) , ((int16_t)l_166 - (int16_t)((~(**p_61)) | g_3))) >> (uint16_t)0)) >> (int16_t)g_3) != g_3)) , 0x07F55A02) >= g_106)) == g_106) | g_84.f0) , &g_84) != &g_24) != 0xB8B2)) < 65529U)) > 0x5EAF73BA) & l_179) > (-1));
    }
    /* facts after for loop */
    assert (g_108 == &l_168 || g_108 == &g_80);
    return g_3;
    /* statement id: 57 */
    //assert (g_108 == dangling || g_108 == &g_80);
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_3 g_80 g_84.f0 g_24.f0 g_106 g_107
 * writes: g_80 g_106
 */
inline static const int32_t ** func_63(int32_t * p_64, int32_t  p_65, uint32_t  p_66)
{ /* block id: 4 */
    float l_78 = (-0x6.4p-1);
    int32_t l_102 = (-4);
    for (p_65 = 0; (p_65 >= 28); ++p_65)
    { /* block id: 7 */
        uint32_t l_77 = 5U;
        int32_t *l_79 = &g_80;
        (*l_79) &= (((((*p_64) == ((func_73((0 >= g_3)) , l_77) < (((void*)0 == p_64) > 0xBBB3))) >= (p_65 != p_65)) != 0xDEBF624E) || p_66);
    }
    for (g_80 = 0; (g_80 <= (-21)); g_80 -= 3)
    { /* block id: 15 */
        union U0 *l_83 = &g_84;
        l_83 = &g_24;
        /* statement id: 16 */
        assert (l_83 == &g_24);
    }
    for (p_66 = 0; (p_66 < 48); p_66 += 2)
    { /* block id: 20 */
        if ((*p_64))
            break;
    }
    for (g_80 = 19; (g_80 != 19); g_80 += 9)
    { /* block id: 25 */
        float *l_89 = &l_78;
        int32_t l_103 = 0;
        int32_t *l_104 = (void*)0;
        int32_t *l_105 = &g_106;
        (*l_89) = (&g_84 != (g_84.f0 , &g_24));
        (*l_105) ^= (((((int16_t)((((uint16_t)((((((-(int32_t)((int16_t)p_65 % (int16_t)((int32_t)(0xB9758AC4 ^ (*p_64)) + (int32_t)(((uint16_t)(0x298B & p_65) - (uint16_t)(!(8 | ((((void*)0 == &g_84) && (l_102 < g_84.f0)) > l_103)))) ^ (*p_64))))) , l_102) < g_24.f0) == 0xCE74) && l_103) , p_65) << (uint16_t)l_102) ^ l_103) & g_3) + (int16_t)g_80) | p_66) < p_65) & 4294967295U);
    }
    return g_107;
    /* statement id: 29 */
    //assert (func_63_rv == &g_108);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_73(uint32_t  p_74)
{ /* block id: 8 */
    int32_t *l_75 = &g_42;
    int32_t **l_76 = &l_75;
    (*l_76) = l_75;
    return p_74;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_24.f0, "g_24.f0", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_84.f0, "g_84.f0", print_hash_value);
    transparent_crc(g_84.f1, "g_84.f1", print_hash_value);
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc_bytes (&g_128, sizeof(g_128), "g_128", print_hash_value);
    transparent_crc(g_381, "g_381", print_hash_value);
    transparent_crc(g_382, "g_382", print_hash_value);
    transparent_crc(g_437, "g_437", print_hash_value);
    transparent_crc(g_441, "g_441", print_hash_value);
    transparent_crc(g_465.f0, "g_465.f0", print_hash_value);
    transparent_crc(g_540, "g_540", print_hash_value);
    transparent_crc(g_578, "g_578", print_hash_value);
    transparent_crc(g_585, "g_585", print_hash_value);
    transparent_crc(g_709, "g_709", print_hash_value);
    transparent_crc(g_726, "g_726", print_hash_value);
    transparent_crc(g_781, "g_781", print_hash_value);
    transparent_crc(g_1023, "g_1023", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 192
XXX total union variables: 9

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 31
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 16, occurrence: 5
   depth: 17, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 4
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 37, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 183

XXX times a variable address is taken: 196
XXX times a pointer is dereferenced on RHS: 140
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 32
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 87
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 799

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 268
   level: 2, occurrence: 112
   level: 3, occurrence: 98
   level: 4, occurrence: 70
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 122
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.9
XXX average alias set size: 1.1

XXX times a non-volatile is read: 1035
XXX times a non-volatile is write: 249
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 123
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 27
   depth: 2, occurrence: 28
   depth: 3, occurrence: 13
   depth: 4, occurrence: 10
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 15.2
XXX percentage an existing variable is used: 84.8
********************* end of statistics **********************/

