/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --comma-operators --compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      1251908538
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int8_t * f0;
};

/* --- GLOBAL VARIABLES --- */
static volatile int8_t g_14 = 0x3AL;/* VOLATILE GLOBAL g_14 */
static int8_t g_16 = 0x68L;
static int32_t g_20 = (-6L);
static int32_t g_68 = 1L;
static int32_t g_72 = (-1L);
static volatile int32_t * const **g_140 = (void*)0;
static volatile int32_t g_149 = 1L;/* VOLATILE GLOBAL g_149 */
static volatile int32_t * const g_148 = &g_149;
static volatile int32_t * const *g_147[5] = {&g_148,&g_148,&g_148,&g_148,&g_148};
static uint16_t g_187 = 0x08DDL;
static volatile union U0 g_189[1] = {{0}};
static volatile union U0 *g_188 = &g_189[0];
static union U0 g_192 = {0};
static float g_200 = 0xB.BCCD91p+97;
static int64_t g_203 = 0x8DDFECA67439DE11LL;
static int32_t g_243[2][9] = {{9L,9L,9L,9L,9L,9L,9L,9L,9L},{0x410FCCD6L,0xDB36F912L,0x410FCCD6L,0xDB36F912L,0x410FCCD6L,0xDB36F912L,0x410FCCD6L,0xDB36F912L,0x410FCCD6L}};
static int32_t *g_468 = &g_243[1][7];
static volatile int32_t *****g_572 = (void*)0;
static const int32_t g_579 = 0xA5A1103EL;
static uint8_t g_649[3] = {0x05L,0x05L,0x05L};
static int8_t **g_735 = (void*)0;
static volatile int8_t *g_943[5] = {&g_14,&g_14,&g_14,&g_14,&g_14};
static volatile int8_t **g_942 = &g_943[3];
static int32_t g_1074 = 1L;


/* --- FORWARD DECLARATIONS --- */
static const int32_t  func_1(void);
inline static const int64_t  func_5(union U0  p_6, int8_t * p_7, int8_t * p_8, float  p_9);
inline static union U0  func_10(uint32_t  p_11);
inline static uint32_t  func_21(uint8_t  p_22, uint8_t  p_23, uint8_t  p_24, int32_t  p_25, int16_t  p_26);
static const int32_t  func_36(const int32_t  p_37, union U0  p_38, int32_t * p_39, int8_t * p_40);
inline static uint64_t  func_41(int32_t * p_42, int32_t * const  p_43, uint16_t  p_44, uint16_t  p_45);
inline static int32_t * func_46(int8_t * p_47, uint8_t  p_48);
inline static int8_t * func_49(int8_t  p_50, int8_t  p_51, uint64_t  p_52, int8_t * p_53);
inline static const uint16_t  func_58(union U0  p_59, int16_t  p_60);
static int16_t  func_62(const int32_t  p_63, int64_t  p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_20 g_188 g_189 g_72 g_649 g_68 g_16 g_140 g_147 g_187 g_192 g_203 g_243 g_148 g_149 g_1074
 * writes: g_20 g_72 g_68 g_140 g_187 g_188 g_200 g_243 g_16 g_468 g_149 g_1074
 */
static const int32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_2[5] = {3UL,3UL,3UL,3UL,3UL};
    int8_t *l_15 = &g_16;
    int32_t *l_1072 = (void*)0;
    int32_t *l_1073 = &g_1074;
    int i;
    (*l_1073) ^= ((l_2[1] != ((int64_t)0xF7FD1E814B733C63LL / (int64_t)func_5(func_10((((uint8_t)g_14 - (uint8_t)((void*)0 == l_15)) | l_2[2])), l_15, &g_16, g_72))) , l_2[1]);
    /* statement id: 408 */
    assert ((g_468 >= &g_243[0][0] && g_468 <= &g_243[1][8]) || g_468 == &g_20 || g_468 == &g_68 || g_468 == &g_72 || g_468 == 0);
    return (*l_1073);
}


/* ------------------------------------------ */
/* 
 * reads : g_649 g_68 g_20 g_16 g_72 g_140 g_147 g_187 g_188 g_192 g_203 g_243 g_148 g_149
 * writes: g_72 g_68 g_140 g_187 g_188 g_200 g_243 g_16 g_468 g_149
 */
inline static const int64_t  func_5(union U0  p_6, int8_t * p_7, int8_t * p_8, float  p_9)
{ /* block id: 401 */
    float l_1047 = 0x9.5B8FFFp-82;
    int32_t l_1048 = 0x68967263L;
    int64_t l_1056[2];
    int i;
    for (i = 0; i < 2; i++)
        l_1056[i] = 1L;
    if ((((-3L) && l_1048) , l_1048))
    { /* block id: 402 */
        const int16_t l_1060 = 9L;
        int32_t **l_1061 = &g_468;
        (*l_1061) = func_46(&g_16, (((float)(+((float)((float)l_1056[0] + (float)(-0x1.2p-1)) / (float)(((float)(-(float)(-0x4.Fp-1)) - (float)(&p_6 != (void*)0)) == l_1056[0]))) / (float)(((0x8.6p+1 > g_649[2]) <= l_1060) == 0xE.79E235p+75)) , 0x3CL));
        /* statement id: 403 */
        assert (g_468 == &g_20 || g_468 == &g_68 || g_468 == &g_72 || g_468 == 0);
    }
    else
    { /* block id: 404 */
        float *l_1064 = (void*)0;
        int32_t l_1071 = (-9L);
        (*g_148) |= ((((int8_t)((((void*)0 == l_1064) != l_1048) , 0x26L) >> (int8_t)3) != (((uint16_t)(((void*)0 != l_1064) > (((((int64_t)g_649[1] + (int64_t)((uint16_t)g_187 % (uint16_t)g_68)) <= l_1056[0]) , l_1056[0]) || l_1071)) - (uint16_t)l_1071) ^ l_1056[0])) | 0x6A110E84CF40EFFALL);
    }
    /* facts after branching */
    assert ((g_468 >= &g_243[0][0] && g_468 <= &g_243[1][8]) || g_468 == &g_20 || g_468 == &g_68 || g_468 == &g_72 || g_468 == 0);
    return l_1056[1];
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_188 g_189
 * writes: g_20
 */
inline static union U0  func_10(uint32_t  p_11)
{ /* block id: 1 */
    const int64_t l_29 = 0xFF609D70CADD6352LL;
    int32_t *l_349 = &g_243[1][0];
    int32_t **l_348 = &l_349;
    int32_t ***l_347 = &l_348;
    union U0 l_477 = {0};
    uint8_t l_510 = 255UL;
    volatile union U0 *l_512 = &g_189[0];
    int8_t *l_688 = &g_16;
    uint32_t l_701 = 3UL;
    int32_t l_820 = 0x2EECE4E6L;
    uint8_t l_910 = 253UL;
    for (p_11 = 0; (p_11 != 6); p_11 += 6)
    { /* block id: 4 */
        int32_t *l_19 = &g_20;
        int8_t *l_54 = &g_16;
        union U0 l_346 = {0};
        int32_t l_436 = 0x1CB93A08L;
        union U0 l_514[8] = {{0},{0},{0},{0},{0},{0},{0},{0}};
        union U0 **l_526 = (void*)0;
        int32_t l_553 = 0x8A87C7A6L;
        int32_t l_559 = 5L;
        int32_t l_560 = 9L;
        int8_t l_652 = 0x12L;
        const uint64_t l_696[5][6] = {{8UL,0x113D3C45A414D3C2LL,0UL,8UL,8UL,0UL},{0x6F4B2CBB07DC2752LL,0x6F4B2CBB07DC2752LL,8UL,5UL,0x0AB74F63483B9526LL,5UL},{0x113D3C45A414D3C2LL,0x6F4B2CBB07DC2752LL,0x113D3C45A414D3C2LL,0UL,8UL,8UL},{18446744073709551610UL,0x113D3C45A414D3C2LL,0x113D3C45A414D3C2LL,18446744073709551610UL,0x6F4B2CBB07DC2752LL,5UL},{5UL,18446744073709551610UL,8UL,18446744073709551610UL,5UL,0UL}};
        int32_t l_734 = 0x782D46FBL;
        uint8_t l_863 = 0x58L;
        int32_t l_900 = 0xD209EFCEL;
        uint32_t l_901 = 4UL;
        int64_t l_922 = 0xCBEFCCC60D012CF6LL;
        int32_t l_1011 = 0x29694CCFL;
        int i, j;
        (*l_19) &= p_11;
    }
    /* facts after for loop */
    assert (l_477.f0 == 0);
    return (*g_188);
    /* statement id: 400 */
    //assert (func_10_rv.f0 == 0);
    }


/* ------------------------------------------ */
/* 
 * reads : g_16
 * writes:
 */
inline static uint32_t  func_21(uint8_t  p_22, uint8_t  p_23, uint8_t  p_24, int32_t  p_25, int16_t  p_26)
{ /* block id: 121 */
    return g_16;
}


/* ------------------------------------------ */
/* 
 * reads : g_203 g_16 g_68 g_72 g_243 g_187 g_20
 * writes: g_203 g_16 g_72
 */
static const int32_t  func_36(const int32_t  p_37, union U0  p_38, int32_t * p_39, int8_t * p_40)
{ /* block id: 106 */
    int32_t l_295 = 0x29866E21L;
    int32_t l_310 = (-3L);
    int32_t l_311 = 0x2CABF743L;
    int32_t l_312 = 0x868B9053L;
    int32_t l_313 = 5L;
    int32_t l_314 = 0x5452BFE0L;
    uint32_t l_315 = 0xB5C3AA3BL;
    int8_t l_336[2][2] = {{8L,8L},{8L,8L}};
    int32_t *l_337[3];
    uint64_t l_338 = 0xEFFC97FB931D9322LL;
    int i, j;
    for (i = 0; i < 3; i++)
        l_337[i] = &l_311;
    for (g_203 = (-12); (g_203 > 4); g_203 += 5)
    { /* block id: 109 */
        l_295 &= (p_37 , (-1L));
    }
    for (g_16 = 0; (g_16 == 16); g_16 += 6)
    { /* block id: 114 */
        int32_t *l_298 = &g_72;
        int32_t *l_299 = (void*)0;
        int32_t *l_300 = &g_72;
        int32_t *l_301 = (void*)0;
        int32_t l_302[2];
        int32_t *l_303 = &g_68;
        int32_t *l_304 = &g_243[1][0];
        int32_t *l_305 = &l_295;
        int32_t *l_306 = &g_72;
        int32_t *l_307 = &g_243[0][5];
        int32_t *l_308 = (void*)0;
        int32_t *l_309[4] = {&g_243[0][5],&g_243[0][5],&g_243[0][5],&g_243[0][5]};
        int32_t **l_318 = &l_300;
        int i;
        for (i = 0; i < 2; i++)
            l_302[i] = 5L;
        l_315++;
        (*l_318) = &l_302[0];
        /* statement id: 116 */
        assert ((l_300 >= &l_302[0] && l_300 <= &l_302[1]));
        (*l_298) = (g_68 & (((~(+(*p_40))) <= (((uint16_t)(+((int32_t)(0x8613L != ((int16_t)(*l_303) >> (int16_t)((((((((((uint16_t)(g_72 , 9UL) + (uint16_t)(((((((int16_t)((uint16_t)((void*)0 == &g_16) << (uint16_t)((int32_t)(((&g_188 == &g_188) != 18446744073709551608UL) ^ g_243[1][0]) / (int32_t)g_187)) << (int16_t)3) ^ (*l_300)) && 7L) & g_243[0][0]) ^ 0L) > g_16)) > 1UL) && l_295) , p_37) > (-1L)) == 3UL) , g_16) < l_310) , (-5L)))) / (int32_t)0x662457B2L)) << (uint16_t)10) & l_312)) >= l_336[0][1]));
    }
    --l_338;
    return g_20;
}


/* ------------------------------------------ */
/* 
 * reads : g_203
 * writes:
 */
inline static uint64_t  func_41(int32_t * p_42, int32_t * const  p_43, uint16_t  p_44, uint16_t  p_45)
{ /* block id: 103 */
    int32_t *l_291 = &g_68;
    int32_t *l_292 = &g_243[0][2];
    l_292 = l_291;
    /* statement id: 104 */
    assert (l_292 == &g_68);
    return g_203;
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_68 g_20 g_16 g_140 g_147 g_187 g_188 g_192 g_203 g_243
 * writes: g_72 g_68 g_140 g_187 g_188 g_200 g_243 g_16
 */
inline static int32_t * func_46(int8_t * p_47, uint8_t  p_48)
{ /* block id: 25 */
    uint8_t l_75[7][8] = {{0x3CL,255UL,0x0CL,255UL,0x3CL,0UL,0UL,0x3CL},{255UL,247UL,247UL,255UL,0x27L,0x3CL,0x27L,255UL},{247UL,0x27L,247UL,0UL,0x0CL,0x0CL,0UL,247UL},{0x27L,0x27L,0x0CL,0x3CL,0xC1L,0x3CL,0x0CL,0x27L},{0x27L,247UL,0UL,0x0CL,0x0CL,0UL,247UL,0x27L},{247UL,255UL,0x27L,0x3CL,0x27L,255UL,247UL,247UL},{255UL,0x3CL,0UL,0UL,0x3CL,255UL,0x0CL,255UL}};
    uint8_t l_136[3][10][6] = {{{0x82L,0xA2L,8UL,255UL,0xF2L,8UL},{255UL,255UL,7UL,250UL,0x82L,8UL},{250UL,0x82L,8UL,0x82L,250UL,7UL},{0xBBL,255UL,8UL,0xF2L,255UL,8UL},{255UL,255UL,7UL,255UL,255UL,8UL},{255UL,255UL,8UL,0xBBL,0xA2L,7UL},{255UL,250UL,8UL,255UL,255UL,8UL},{0xF2L,0xF2L,7UL,0xA2L,0xBBL,8UL},{0xA2L,0xBBL,8UL,255UL,255UL,7UL},{0x82L,0xA2L,8UL,255UL,0xF2L,8UL}},{{255UL,255UL,7UL,250UL,0x82L,8UL},{250UL,0x82L,8UL,0x82L,250UL,7UL},{0xBBL,255UL,8UL,0xF2L,255UL,8UL},{255UL,255UL,7UL,255UL,255UL,8UL},{255UL,255UL,8UL,0xBBL,0xA2L,7UL},{255UL,250UL,8UL,255UL,255UL,8UL},{0xF2L,0xF2L,255UL,0x92L,0UL,255UL},{0x92L,0UL,255UL,0xB4L,5UL,255UL},{1UL,0x92L,255UL,5UL,0x92L,255UL},{1UL,5UL,255UL,248UL,1UL,255UL}},{{248UL,1UL,255UL,1UL,248UL,255UL},{0UL,5UL,255UL,0x92L,5UL,255UL},{5UL,1UL,255UL,5UL,0xB4L,255UL},{5UL,0xB4L,255UL,0UL,0x92L,255UL},{0xB4L,248UL,255UL,1UL,1UL,255UL},{0x92L,0x92L,255UL,0x92L,0UL,255UL},{0x92L,0UL,255UL,0xB4L,5UL,255UL},{1UL,0x92L,255UL,5UL,0x92L,255UL},{1UL,5UL,255UL,248UL,1UL,255UL},{248UL,1UL,255UL,1UL,248UL,255UL}}};
    const int32_t *l_176 = &g_68;
    int8_t *l_191 = (void*)0;
    int8_t l_242[6][9][4] = {{{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)}},{{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)}},{{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)}},{{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)}},{{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)}},{{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)},{1L,(-2L),1L,(-2L)}}};
    union U0 *l_274 = &g_192;
    int32_t *l_290 = (void*)0;
    int i, j, k;
    for (p_48 = 0; (p_48 <= 6); p_48 += 1)
    { /* block id: 28 */
        const uint64_t l_80 = 18446744073709551606UL;
        int32_t *l_142[1][9][10] = {{{&g_68,(void*)0,&g_68,(void*)0,&g_68,&g_72,&g_68,&g_68,&g_72,&g_72},{(void*)0,&g_72,&g_68,&g_72,&g_20,&g_68,&g_68,&g_68,&g_68,&g_72},{&g_72,&g_72,&g_72,&g_20,&g_68,&g_72,&g_68,&g_72,&g_72,&g_20},{&g_20,(void*)0,&g_68,&g_68,&g_72,&g_20,(void*)0,(void*)0,&g_20,&g_72},{&g_72,&g_68,&g_68,&g_72,&g_68,&g_20,&g_68,&g_72,&g_72,&g_68},{&g_68,&g_68,&g_68,&g_72,&g_72,&g_72,&g_68,&g_68,&g_72,(void*)0},{&g_68,&g_72,&g_72,&g_72,&g_20,(void*)0,&g_72,(void*)0,&g_20,&g_68},{(void*)0,&g_20,&g_72,&g_68,&g_72,(void*)0,&g_20,(void*)0,&g_72,&g_68},{&g_68,&g_68,&g_68,&g_72,&g_68,(void*)0,&g_68,&g_72,&g_20,&g_68}}};
        int32_t *l_179 = &g_20;
        union U0 l_226 = {0};
        int i, j, k;
        for (g_72 = 0; (g_72 <= 6); g_72 += 1)
        { /* block id: 31 */
            uint32_t l_81 = 0x0CA2CDF2L;
            const int32_t *l_178 = (void*)0;
            int32_t **l_195 = &l_179;
            int32_t ***l_194 = &l_195;
            int32_t ****l_193 = &l_194;
            int32_t l_252 = 0x77E7D222L;
            union U0 *l_275 = &g_192;
            if (((0x74D4L >= (0x30A264F7L == (((((void*)0 != p_47) >= ((((uint16_t)(((uint16_t)l_80 << (uint16_t)(((((l_81 , (((g_68 && p_48) && (((uint8_t)((((uint16_t)((int64_t)(((int16_t)((int16_t)(-(uint8_t)((int8_t)((g_20 <= (*p_47)) | l_80) >> (int8_t)6)) / (int16_t)p_48) << (int16_t)6) , g_72) % (int64_t)1L) / (uint16_t)p_48) || (-3L)) | 0x14L) / (uint8_t)l_81) || 0UL)) | 0xCA9823142ACE07D3LL)) < l_81) , p_48) | p_48) ^ p_48)) , 65535UL) >> (uint16_t)g_16) & g_16) < g_20)) , 0xE9L) , p_48))) ^ g_72))
            { /* block id: 32 */
                int8_t * const l_104 = &g_16;
                int32_t l_105 = 1L;
                union U0 l_146 = {0};
                int32_t **l_160 = &l_142[0][1][6];
                float *l_223 = &g_200;
                if (((l_80 >= (((int8_t)((uint32_t)(((((uint8_t)p_48 << (uint8_t)7) , ((uint64_t)((((~((0x7DABF261L & p_48) , ((p_48 <= (g_16 , 0x1B43L)) && (l_104 == &g_16)))) & g_72) < g_20) , l_105) % (uint64_t)(-2L))) != 0xC725EA9BL) >= 0x15L) + (uint32_t)l_105) % (int8_t)(-6L)) , l_81)) , 0x9CC96ABBL))
                { /* block id: 33 */
                    uint64_t l_135[8] = {18446744073709551615UL,7UL,18446744073709551615UL,7UL,18446744073709551615UL,7UL,18446744073709551615UL,7UL};
                    int i;
                    for (g_68 = 6; (g_68 >= 1); g_68 -= 1)
                    { /* block id: 36 */
                        uint8_t l_134 = 0xF7L;
                        int32_t *l_137 = &l_105;
                        (*l_137) = ((int16_t)((((uint32_t)((uint8_t)((uint16_t)(((uint16_t)(((g_72 <= p_48) ^ ((int8_t)((-1L) > (p_48 >= ((uint16_t)((~(((+((int32_t)l_81 - (int32_t)((int32_t)((uint32_t)((uint8_t)(p_48 , ((0xAFL < ((uint32_t)((uint8_t)(((((((0x1A385A40E5C4FF8CLL == ((((l_81 && p_48) <= g_20) ^ p_48) | l_134)) <= 0x8A8B4E140BD20A5ALL) <= l_75[0][2]) <= l_80) > 2UL) && 0L) || 0xE36264D6F6C97C2BLL) + (uint8_t)g_16) / (uint32_t)l_135[4])) ^ 0L)) % (uint8_t)g_72) / (uint32_t)g_16) + (int32_t)g_16))) || p_48) & 255UL)) > g_68) >> (uint16_t)11))) + (int8_t)p_48)) && g_20) << (uint16_t)12) < (*p_47)) >> (uint16_t)14) << (uint8_t)6) + (uint32_t)g_72) , 1UL) != l_136[2][0][1]) % (int16_t)5L);
                        (*l_137) |= p_48;
                        if (p_48)
                            break;
                    }
                }
                else
                { /* block id: 41 */
                    int32_t *l_138 = (void*)0;
                    if (g_16)
                        break;
                    if (p_48)
                    { /* block id: 43 */
                        int32_t **l_139 = &l_138;
                        volatile int32_t * const ***l_141 = &g_140;
                        (*l_139) = l_138;
                        if (g_68)
                            break;
                        (*l_141) = g_140;
                    }
                    else
                    { /* block id: 47 */
                        return l_142[0][1][6];
                        /* statement id: 48 */
                        //assert (func_46_rv == &g_20 || func_46_rv == &g_68 || func_46_rv == &g_72 || func_46_rv == 0);
                    }
                    if (g_20)
                        continue;
                    g_68 = (((int8_t)(~((((((&l_138 == (l_146 , g_147[2])) , l_138) != (void*)0) >= ((((int8_t)((uint16_t)(((int8_t)(-3L) << (int8_t)((((float)((float)0x8.5526D7p+5 - (float)(l_160 == (p_48 , (void*)0))) / (float)0x6.6p+1) , 0x9BL) && g_68)) < g_20) << (uint16_t)p_48) >> (int8_t)2) | 0L) , g_72)) ^ 0xB642L) > p_48)) << (int8_t)3) || 0UL);
                }
                for (l_81 = 0; (l_81 <= 4); l_81 += 1)
                { /* block id: 55 */
                    const float l_246 = 0x0.1p+1;
                    int i, j;
                    if ((!((uint16_t)0x45B2L << (uint16_t)(((((uint16_t)((uint16_t)(l_75[p_48][(g_72 + 1)] | (((uint16_t)p_48 % (uint16_t)(1L ^ (((((uint64_t)(((((l_75[p_48][(g_72 + 1)] >= (l_146 , (((0x62L >= 1UL) & ((uint64_t)((((int16_t)((l_75[p_48][(g_72 + 1)] > g_68) <= p_48) + (int16_t)p_48) ^ l_81) >= 0x52AAL) - (uint64_t)g_16)) >= (-1L)))) , p_48) , 1UL) > g_72) != (*p_47)) + (uint64_t)0xD96BD77A3CA1CF38LL) <= g_20) > (-7L)) ^ (-7L)))) || p_48)) + (uint16_t)p_48) % (uint16_t)g_16) != 0x8999B4F4D21A526CLL) , 0UL) | l_75[2][3]))))
                    { /* block id: 56 */
                        const int32_t **l_177 = (void*)0;
                        l_178 = l_176;
                        /* statement id: 57 */
                        assert (l_178 == &g_68);
                        g_68 = ((0x9DC3AFFDL >= ((g_20 >= (&g_147[l_81] == &g_147[2])) != (*p_47))) != 7UL);
                        (*l_160) = l_179;
                    }
                    else
                    { /* block id: 60 */
                        g_187 ^= (((g_68 | ((int32_t)(g_72 == (g_72 | ((g_72 | ((int16_t)(((((p_48 < ((((-(uint16_t)((int64_t)((void*)0 == &g_140) / (int64_t)((((g_68 | ((g_20 < 0x8C84E1C3L) ^ 0L)) , g_72) | p_48) && g_20))) >= 1UL) , 0xE393E820L) | 0x71F0EE3BL)) == g_72) >= g_16) , l_75[p_48][(g_72 + 1)]) , (-1L)) + (int16_t)p_48)) , p_48))) + (int32_t)g_72)) , g_20) > p_48);
                    }
                    if (p_48)
                    { /* block id: 63 */
                        volatile union U0 **l_190 = &g_188;
                        (*l_190) = g_188;
                    }
                    else
                    { /* block id: 65 */
                        int64_t l_198 = 0x00D91C5D00A86ED1LL;
                        float *l_199 = &g_200;
                        (*l_199) = (((void*)0 != l_191) > ((((g_16 , g_192) , 0xC.34597Dp+87) == (&g_16 != &g_16)) != (l_193 == (((uint8_t)((g_16 > 1UL) || 1UL) - (uint8_t)l_198) , (void*)0))));
                        (*l_199) = (((((p_48 < g_72) , p_48) > (((float)g_203 - (float)(-0x1.3p+1)) > ((g_20 == ((float)(((int32_t)((int8_t)((***l_194) <= ((((uint16_t)65535UL + (uint16_t)(((int32_t)((int8_t)g_20 << (int8_t)g_203) + (int32_t)p_48) | 0UL)) ^ (*l_176)) != 0x0E49BB20L)) - (int8_t)6UL) + (int32_t)p_48) , p_48) - (float)p_48)) == g_187))) < p_48) > g_20);
                        g_68 = ((int8_t)(((~((g_72 , g_20) <= ((p_47 == (void*)0) || ((int16_t)(((void*)0 == l_223) | ((uint16_t)(((((((-1L) > (l_226 , ((((uint32_t)((int8_t)((uint32_t)4294967289UL - (uint32_t)l_198) << (int8_t)l_75[p_48][(g_72 + 1)]) + (uint32_t)p_48) ^ p_48) ^ p_48))) & (*l_176)) == (****l_193)) & (*l_176)) , l_75[p_48][(g_72 + 1)]) && g_68) >> (uint16_t)10)) >> (int16_t)g_16)))) || (-1L)) >= 0x22L) / (int8_t)l_198);
                        g_243[1][0] |= ((int16_t)l_75[p_48][(g_72 + 1)] >> (int16_t)(((uint16_t)(((void*)0 != l_178) > (((int32_t)5L + (int32_t)(g_20 != (-(int16_t)(((uint8_t)(p_48 | ((void*)0 == (*l_195))) - (uint8_t)(1L != (*l_176))) < l_105)))) , l_242[4][2][0])) << (uint16_t)11) ^ 1UL));
                    }
                    for (g_68 = 4; (g_68 >= 1); g_68 -= 1)
                    { /* block id: 73 */
                        g_243[1][0] |= p_48;
                        return &g_20;
                        /* statement id: 75 */
                        //assert (func_46_rv == &g_20);
                    }
                    for (l_105 = 0; (l_105 <= 6); l_105 += 1)
                    { /* block id: 79 */
                        uint64_t l_247[7] = {0xFB2A6EC452CB20ACLL,1UL,0xFB2A6EC452CB20ACLL,0xFB2A6EC452CB20ACLL,1UL,0xFB2A6EC452CB20ACLL,0xFB2A6EC452CB20ACLL};
                        float *l_248 = &g_200;
                        int i;
                        l_252 = ((uint16_t)(((g_20 , l_247[5]) < 0x139D5ECBL) , (l_248 != l_223)) % (uint16_t)(((uint32_t)(~((0x07ED48E4L && 0x2FD023D6L) | (*p_47))) / (uint32_t)(((g_72 & 5UL) & l_75[p_48][(g_72 + 1)]) || g_187)) | g_187));
                        (*l_248) = g_72;
                    }
                }
                /* facts after for loop */
                assert (l_178 == 0 || l_178 == &g_68);
            }
            else
            { /* block id: 84 */
                int32_t l_253 = 0x06B0FEA9L;
                float *l_285 = &g_200;
                if (l_253)
                    break;
                g_68 = (((uint32_t)(((uint64_t)(0xD56119E41943C493LL <= (p_48 , (((uint16_t)(0x0FL == ((uint8_t)(65528UL <= 0L) / (uint8_t)l_253)) >> (uint16_t)0) >= (((void*)0 == &g_147[2]) , (((int16_t)((((void*)0 != p_47) , g_16) > 0x2A87EBE3L) << (int16_t)g_68) || 3L))))) % (uint64_t)(***l_194)) && l_253) % (uint32_t)0xF88B38F8L) , 1L);
                (*l_285) = (((int32_t)(***l_194) + (int32_t)((((uint32_t)((uint16_t)(((uint64_t)(l_274 == l_275) + (uint64_t)(((+((((((uint64_t)(l_253 != (p_48 != (((void*)0 != l_142[0][1][6]) > (((uint8_t)g_243[0][3] - (uint8_t)(((uint8_t)(*l_179) / (uint8_t)(*p_47)) > l_253)) >= (***l_194))))) - (uint64_t)p_48) >= 0UL) , 0xB53C1BFE7BB2D01FLL) || 0x851BE001E57495F7LL) >= (-8L))) >= g_68) , 0xDE3C59E35A505CC4LL)) > g_68) / (uint16_t)0xE829L) - (uint32_t)0x60D0BD52L) <= p_48) ^ g_68)) , g_203);
            }
            /* facts after branching */
            assert (l_178 == 0 || l_178 == &g_68);
        }
        /* facts after for loop */
        for (g_72 = 0; (g_72 <= 6); g_72 += 1)
        { /* block id: 92 */
            int32_t l_286[6];
            int i;
            for (i = 0; i < 6; i++)
                l_286[i] = (-1L);
            if (g_20)
                break;
            if (l_286[1])
                continue;
        }
    }
    /* facts after for loop */
    for (g_16 = 14; (g_16 != 26); g_16 += 6)
    { /* block id: 99 */
        int32_t *l_289 = &g_243[1][0];
        (*l_289) |= (p_48 != (*l_176));
    }
    return l_290;
    /* statement id: 102 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_16 g_72
 * writes: g_68 g_72
 */
inline static int8_t * func_49(int8_t  p_50, int8_t  p_51, uint64_t  p_52, int8_t * p_53)
{ /* block id: 6 */
    const uint16_t l_57 = 1UL;
    union U0 l_61 = {0};
    int32_t *l_71 = &g_72;
    for (p_51 = 0; (p_51 >= 26); p_51++)
    { /* block id: 9 */
        if (l_57)
            break;
    }
    (*l_71) ^= (func_58(l_61, func_62(g_20, p_51)) | l_57);
    /* statement id: 18 */
    assert (l_61.f0 == 0);
    for (p_50 = 0; (p_50 >= 7); p_50 += 1)
    { /* block id: 21 */
        if (p_50)
            break;
    }
    return &g_16;
    /* statement id: 24 */
    //assert (func_49_rv == &g_16);
}


/* ------------------------------------------ */
/* 
 * reads : g_20
 * writes: g_68
 */
inline static const uint16_t  func_58(union U0  p_59, int16_t  p_60)
{ /* block id: 15 */
    int32_t l_69 = (-1L);
    int32_t *l_70 = &g_68;
    (*l_70) = l_69;
    return g_20;
}


/* ------------------------------------------ */
/* 
 * reads : g_16
 * writes: g_68
 */
static int16_t  func_62(const int32_t  p_63, int64_t  p_64)
{ /* block id: 12 */
    int32_t *l_65 = &g_20;
    int32_t *l_66 = (void*)0;
    int32_t *l_67 = &g_68;
    (*l_67) = ((void*)0 == l_65);
    return g_16;
}




/* ---------------------------------------- */
int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_14, "g_14", print_hash_value);
    transparent_crc(g_16, "g_16", print_hash_value);
    transparent_crc(g_20, "g_20", print_hash_value);
    transparent_crc(g_68, "g_68", print_hash_value);
    transparent_crc(g_72, "g_72", print_hash_value);
    transparent_crc(g_149, "g_149", print_hash_value);
    transparent_crc(g_187, "g_187", print_hash_value);
    transparent_crc_bytes (&g_200, sizeof(g_200), "g_200", print_hash_value);
    transparent_crc(g_203, "g_203", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 9; j++)
        {
            transparent_crc(g_243[i][j], "g_243[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_579, "g_579", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        transparent_crc(g_649[i], "g_649[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_1074, "g_1074", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 201
XXX total union variables: 16

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
   depth: 6, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 167

XXX times a variable address is taken: 311
XXX times a pointer is dereferenced on RHS: 104
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 13
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 75
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 1
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 44
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 1191

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 386
   level: 2, occurrence: 78
   level: 3, occurrence: 52
   level: 4, occurrence: 9
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 43
XXX number of pointers point to scalars: 114
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 37.1
XXX average alias set size: 1.31

XXX times a non-volatile is read: 1068
XXX times a non-volatile is write: 219
XXX times a volatile is read: 44
XXX    times read thru a pointer: 17
XXX times a volatile is write: 11
XXX    times written thru a pointer: 11
XXX times a volatile is available for access: 274
XXX percentage of non-volatile access: 95.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 73
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 12
   depth: 2, occurrence: 3
   depth: 3, occurrence: 5
   depth: 4, occurrence: 9
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 14.2
XXX percentage an existing variable is used: 85.8
********************* end of statistics **********************/

