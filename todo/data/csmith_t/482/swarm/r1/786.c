/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      144038256
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint64_t  f0;
   uint32_t  f1;
   int16_t  f2;
};

union U1 {
   unsigned f0 : 1;
   int32_t  f1;
   uint64_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_1(void);
inline static uint16_t  func_3(int32_t  p_4);
static int32_t  func_5(uint32_t  p_6, uint16_t  p_7);
static int64_t  func_11(int64_t  p_12);
inline static int16_t  func_15(union U0  p_16);
inline static union U0  func_17(int16_t  p_18);
static int32_t  func_35(union U0  p_36, int16_t  p_37);
static int32_t  func_38(int64_t  p_39, uint32_t  p_40, int32_t * p_41, int32_t * p_42, int32_t *** p_43);
static int64_t  func_52(int32_t * p_53);
inline static int32_t *** func_57(uint32_t  p_58, uint16_t  p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0L;
    uint16_t l_551 = 65535UL;
    union U0 l_555 = {0x43F426D7295ACF06LL};
    union U0 *l_554 = &l_555;
    int32_t *l_670 = &l_2;
    union U1 l_671 = {0xAAECDD51L};
    (*l_670) = (l_2 > func_3(func_5(((+((int64_t)func_11(l_2) - (int64_t)l_551)) == ((int16_t)((void*)0 != l_554) >> (int16_t)1)), ((uint32_t)l_551 % (uint32_t)((int64_t)(l_555.f2 == (((uint16_t)l_2 >> (uint16_t)14) != l_555.f2)) + (int64_t)l_555.f0)))));
    return l_671;
    /* statement id: 286 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_3(int32_t  p_4)
{ /* block id: 270 */
    int32_t l_655 = (-10L);
    int32_t *l_654 = &l_655;
    int32_t **l_653 = &l_654;
    union U0 l_668 = {0xFD9E34060D448F31LL};
    union U0 *l_667 = &l_668;
    union U0 **l_666 = &l_667;
    union U0 ***l_665 = &l_666;
    (*l_653) = &p_4;
    /* statement id: 271 */
    assert (l_654 == &p_4);
    (*l_653) = &p_4;
    for (p_4 = 0; (p_4 >= (-17)); p_4 -= 6)
    { /* block id: 275 */
        union U1 l_663 = {0x24D97331L};
        union U1 *l_662 = &l_663;
        union U1 **l_664 = &l_662;
        union U0 ****l_669 = &l_665;
        for (l_655 = 0; (l_655 < (-24)); l_655 -= 1)
        { /* block id: 278 */
            int32_t l_661 = 0x3294EEDCL;
            int32_t *l_660 = &l_661;
            (*l_660) = p_4;
        }
        (*l_664) = l_662;
        (*l_669) = l_665;
    }
    return p_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_5(uint32_t  p_6, uint16_t  p_7)
{ /* block id: 230 */
    uint32_t l_566 = 0x3A9FBFA3L;
    union U0 *l_599 = (void*)0;
    union U0 **l_598 = &l_599;
    int32_t l_619 = (-3L);
    int32_t *l_618 = &l_619;
    union U1 l_634 = {0xE50422A7L};
    union U1 *l_633 = &l_634;
    union U1 **l_632 = &l_633;
    int64_t l_635 = 0L;
    uint32_t l_636 = 0UL;
lbl_652:
    for (p_6 = 0; (p_6 <= 28); p_6++)
    { /* block id: 233 */
        int32_t l_568 = 0x45D851CDL;
        int32_t *l_567 = &l_568;
        (*l_567) = l_566;
        (*l_567) = ((int16_t)((int16_t)(1L && ((int16_t)2L * (int16_t)p_7)) >> (int16_t)(((uint16_t)(((uint16_t)(!(((0x6B442E5E93C6BA4ELL > (((int16_t)(-4L) << (int16_t)7) > ((uint64_t)(*l_567) % (uint64_t)(~0xC76F50C885CE1E14LL)))) || (((int16_t)0xB3F1L >> (int16_t)l_566) >= p_7)) >= p_6)) << (uint16_t)14) || 0x5368L) >> (uint16_t)8) <= l_566)) << (int16_t)7);
    }
    for (p_6 = 0; (p_6 >= 54); p_6++)
    { /* block id: 239 */
        uint64_t l_591 = 0x1EB192F1295B1A44LL;
        union U1 **l_631 = (void*)0;
        if (((uint16_t)l_591 << (uint16_t)(l_566 && ((uint16_t)((((int16_t)(l_591 < ((((((uint32_t)0x92FD68C8L + (uint32_t)(p_7 ^ l_591)) <= (l_598 != &l_599)) >= ((p_7 <= l_591) ^ 1L)) < p_6) != l_566)) >> (int16_t)p_6) == p_7) & p_7) >> (uint16_t)l_591))))
        { /* block id: 240 */
            int16_t l_610 = 0x77A6L;
            int32_t l_617 = (-9L);
            int32_t **l_624 = (void*)0;
            int32_t ***l_623 = &l_624;
            int32_t *l_643 = &l_619;
            union U0 l_648 = {0x3CFA8DEDEB5C68F9LL};
            union U0 *l_647 = &l_648;
            for (l_566 = 20; (l_566 < 20); l_566++)
            { /* block id: 243 */
                int32_t l_609 = 0x9BC50419L;
                if (((int16_t)((((((((int32_t)0x07355C71L - (int32_t)(p_7 & (~(((int16_t)(l_609 & 7L) >> (int16_t)(0xF014C9FEDD757BACLL && ((((l_610 != ((int16_t)((4294967287UL | ((int64_t)(0x961EA5B7L != ((uint16_t)(l_609 > l_610) << (uint16_t)l_610)) / (int64_t)l_591)) || p_7) + (int16_t)0x4E46L)) ^ l_609) || l_610) != 0UL))) ^ p_7)))) < l_610) ^ p_7) ^ l_609) && 6L) | 0xD1F8L) && l_617) - (int16_t)0xB561L))
                { /* block id: 244 */
                    int32_t **l_620 = &l_618;
                    (*l_620) = l_618;
                    for (p_7 = 0; (p_7 <= 25); p_7++)
                    { /* block id: 248 */
                        return p_6;
                    }
                    (*l_618) = 6L;
                }
                else
                { /* block id: 252 */
                    union U1 ****l_640 = (void*)0;
                    union U1 ***l_642 = &l_631;
                    union U1 ****l_641 = &l_642;
                    (*l_618) = ((l_623 == (void*)0) == (18446744073709551607UL & ((int16_t)((uint16_t)((int64_t)((l_631 == l_632) & (*l_618)) - (int64_t)(l_635 < l_636)) - (uint16_t)(-(int64_t)(((((((uint64_t)(*l_618) - (uint64_t)l_609) > p_6) != p_7) || 0xB46A7616L) != p_7) & l_591))) * (int16_t)p_6)));
                    (*l_641) = &l_632;
                    /* statement id: 254 */
                    assert (l_642 == &l_632);
                }
                (*l_618) = 0x0461D223L;
            }
            (*l_618) = (((l_643 != (void*)0) == (-10L)) <= (~((int16_t)l_591 - (int16_t)(l_647 == (*l_598)))));
            for (l_617 = 0; (l_617 >= 28); l_617 += 8)
            { /* block id: 261 */
                union U1 *l_651 = &l_634;
                (*l_632) = l_651;
                /* statement id: 262 */
                assert (l_633 == &l_634);
            }
        }
        else
        { /* block id: 264 */
            (*l_632) = (void*)0;
            /* statement id: 265 */
            assert (l_633 == 0);
            if (l_591)
                goto lbl_652;
        }
    }
    return p_6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_11(int64_t  p_12)
{ /* block id: 1 */
    uint16_t l_19 = 0xF6C2L;
    int32_t l_541 = 0x403EBEA6L;
    int32_t *l_540 = &l_541;
    int32_t **l_539 = &l_540;
    int32_t ***l_538 = &l_539;
    uint32_t l_550 = 0x96E3C937L;
    (*l_540) = (((int16_t)func_15(func_17(l_19)) * (int16_t)((((uint32_t)(~((!(-(uint32_t)(((-1L) == l_19) >= (((+((((l_538 != &l_539) | (**l_539)) && ((uint16_t)(((int16_t)((uint32_t)((int16_t)p_12 - (int16_t)0L) % (uint32_t)p_12) >> (int16_t)p_12) < p_12) % (uint16_t)(***l_538))) > p_12)) != p_12) < (**l_539))))) || p_12)) + (uint32_t)3UL) & p_12) == p_12)) & l_550);
    (**l_539) = p_12;
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_15(union U0  p_16)
{ /* block id: 21 */
    int32_t *l_504 = (void*)0;
    int32_t l_506 = (-1L);
    int32_t *l_505 = &l_506;
    int16_t l_531 = 0L;
lbl_530:
    (*l_505) = func_35(p_16, p_16.f1);
    (*l_505) = ((uint16_t)p_16.f2 / (uint16_t)((int64_t)0xD9B8707CB7B7E35ELL - (int64_t)((int16_t)(((uint16_t)((int16_t)p_16.f1 << (int16_t)p_16.f0) << (uint16_t)14) | (*l_505)) % (int16_t)((uint16_t)p_16.f0 % (uint16_t)(~(1UL >= ((int16_t)(((int32_t)((int16_t)((0xC19D5F81L == ((((int64_t)(((int64_t)(&l_506 == &l_506) + (int64_t)(*l_505)) != (*l_505)) + (int64_t)p_16.f1) > p_16.f1) <= p_16.f1)) && 0xD40DL) >> (int16_t)1) / (int32_t)0x3284EC7DL) || (*l_505)) << (int16_t)4)))))));
    if (p_16.f0)
        goto lbl_530;
    return l_531;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_17(int16_t  p_18)
{ /* block id: 2 */
    int32_t l_21 = 0L;
    int32_t *l_20 = &l_21;
    union U0 l_34 = {1UL};
    (*l_20) = p_18;
    for (l_21 = 0; (l_21 == (-20)); l_21 -= 1)
    { /* block id: 6 */
        int32_t ***l_31 = (void*)0;
        int32_t **l_33 = &l_20;
        int32_t ***l_32 = &l_33;
        for (p_18 = 0; (p_18 > 19); p_18 += 7)
        { /* block id: 9 */
            int32_t l_26 = 0x9BDD7770L;
            for (l_26 = (-25); (l_26 == (-8)); l_26 += 7)
            { /* block id: 12 */
                int32_t *l_29 = &l_26;
                int32_t **l_30 = &l_29;
                (*l_30) = l_29;
                if (p_18)
                    continue;
                if (p_18)
                    continue;
            }
        }
        l_32 = l_31;
        /* statement id: 18 */
        assert (l_32 == 0);
    }
    return l_34;
    /* statement id: 20 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(union U0  p_36, int16_t  p_37)
{ /* block id: 22 */
    int64_t l_46 = 0xB4D258D0336D0658LL;
    int32_t l_48 = 0x104353EAL;
    int32_t *l_47 = &l_48;
    int32_t **l_365 = &l_47;
    int32_t ***l_364 = &l_365;
    int32_t ****l_363 = &l_364;
    int32_t *****l_362 = &l_363;
    int16_t l_366 = 0x4C23L;
    int32_t l_368 = (-1L);
    int32_t *l_367 = &l_368;
    return p_36.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_38(int64_t  p_39, uint32_t  p_40, int32_t * p_41, int32_t * p_42, int32_t *** p_43)
{ /* block id: 146 */
    int32_t l_379 = (-1L);
    union U1 l_393 = {0x3C1AD0A1L};
    union U1 *l_392 = &l_393;
    union U0 *l_413 = (void*)0;
    for (p_39 = 0; (p_39 != 6); p_39 += 1)
    { /* block id: 149 */
        int32_t *l_374 = (void*)0;
        int32_t **l_373 = &l_374;
        int32_t l_390 = 0L;
        uint64_t l_391 = 2UL;
        uint32_t l_434 = 18446744073709551615UL;
        (*p_41) = (((int32_t)((void*)0 != l_373) - (int32_t)(*p_41)) | (0UL <= ((int32_t)((uint16_t)l_379 + (uint16_t)((((void*)0 != &l_379) & ((((int16_t)((int16_t)p_39 * (int16_t)((uint16_t)((((uint16_t)(p_40 >= p_40) << (uint16_t)6) < 0UL) && l_379) + (uint16_t)65528UL)) * (int16_t)l_379) ^ l_390) ^ p_40)) != l_379)) - (int32_t)l_379)));
        if ((l_391 == (l_392 != &l_393)))
        { /* block id: 151 */
            (*p_42) = (***p_43);
        }
        else
        { /* block id: 153 */
            int32_t **l_396 = &l_374;
            int32_t ****l_404 = (void*)0;
            int32_t *****l_403 = &l_404;
            if (((***p_43) || (((uint32_t)((void*)0 == l_396) - (uint32_t)l_379) >= p_40)))
            { /* block id: 154 */
                int32_t *****l_405 = &l_404;
                int32_t l_412 = 0xF3B490FCL;
                union U0 **l_414 = &l_413;
                for (l_391 = 15; (l_391 > 18); l_391 += 6)
                { /* block id: 157 */
                    union U0 l_410 = {1UL};
                    union U0 *l_409 = &l_410;
                    union U0 **l_408 = &l_409;
                    union U0 ***l_411 = &l_408;
                    (*p_41) = ((((int64_t)p_40 + (int64_t)p_40) >= p_40) != (p_39 <= ((int32_t)(l_403 != l_405) - (int32_t)((uint16_t)(((void*)0 == (**p_43)) && (***p_43)) << (uint16_t)p_39))));
                    (*l_411) = l_408;
                    (***p_43) = (0xB511B0AF793924C3LL > 8UL);
                    l_412 = 0x0102855BL;
                }
                (*l_414) = l_413;
            }
            else
            { /* block id: 164 */
                uint32_t l_415 = 18446744073709551614UL;
                return l_415;
                /* statement id: 165 */
                //assert (l_47 == dangling || l_47 == &l_48);
            }
            for (l_393.f1 = 0; (l_393.f1 == 7); l_393.f1 += 1)
            { /* block id: 169 */
                uint64_t l_433 = 0x675F6B8C41C65E76LL;
                for (p_40 = (-21); (p_40 != 44); p_40 += 1)
                { /* block id: 172 */
                    int32_t **l_427 = &l_374;
                    (*p_41) = (1UL >= ((((uint16_t)p_40 >> (uint16_t)4) & ((void*)0 == &l_392)) > (((((uint64_t)((((int16_t)((l_393.f0 | (-(uint16_t)(l_427 == (*p_43)))) < (((((+(((uint16_t)((int32_t)((***p_43) == (l_379 || p_40)) - (int32_t)p_40) >> (uint16_t)p_40) | p_40)) || 2UL) < l_433) > 65535UL) & l_433)) >> (int16_t)l_379) || p_40) || (***p_43)) / (uint64_t)l_390) | l_434) != (*p_42)) < 0x60BB8B31L)));
                    (*l_396) = (**p_43);
                    /* statement id: 174 */
                    //assert (l_374 == &l_379 || l_374 == &l_48);
                }
                (**p_43) = (**p_43);
                if (l_379)
                    continue;
                (*p_42) = ((uint32_t)((uint16_t)((0xD65FL < ((l_433 || 0x2A537746L) <= p_39)) != ((int64_t)((int16_t)((int64_t)(((((int16_t)p_39 * (int16_t)p_39) ^ (l_433 != ((uint16_t)(((int16_t)((*p_42) || ((int16_t)((int64_t)l_433 / (int64_t)0xF0562B50104BB761LL) * (int16_t)0xF344L)) - (int16_t)p_40) & (-9L)) + (uint16_t)l_433))) < 18446744073709551607UL) ^ p_40) / (int64_t)p_39) * (int16_t)l_433) % (int64_t)p_40)) + (uint16_t)0x971AL) + (uint32_t)l_433);
            }
            /* facts after for loop */
                        //assert (l_374 == &l_379 || l_374 == &l_48 || l_374 == 0);
            (**p_43) = &l_379;
            /* statement id: 180 */
            //assert (l_47 == &l_379);
        }
        /* facts after branching */
        //assert (l_374 == &l_379 || l_374 == &l_48 || l_374 == 0);
    }
    /* facts after for loop */
    //assert (l_47 == &l_379 || l_47 == &l_48);
    return (*p_42);
    /* statement id: 183 */
    //assert (l_47 == dangling || l_47 == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_52(int32_t * p_53)
{ /* block id: 23 */
    union U1 l_55 = {0x1771B705L};
    union U1 *l_54 = &l_55;
    union U1 **l_56 = &l_54;
    int32_t l_69 = 0xC3DC4D7EL;
    int32_t *l_68 = &l_69;
    int32_t **l_67 = &l_68;
    int32_t ***l_66 = &l_67;
    union U0 *l_96 = (void*)0;
    uint64_t l_100 = 0x477944D42BE3C69BLL;
    int32_t ****l_123 = &l_66;
    int64_t l_341 = (-1L);
    uint16_t l_355 = 0xC977L;
    uint64_t l_361 = 1UL;
    (*l_56) = l_54;
    if ((*p_53))
    { /* block id: 25 */
        return l_55.f0;
    }
    else
    { /* block id: 27 */
        int32_t l_65 = (-1L);
        int32_t *l_64 = &l_65;
        int32_t **l_63 = &l_64;
        int32_t ***l_62 = &l_63;
        union U1 *l_70 = &l_55;
        int32_t ****l_93 = &l_66;
        (*l_93) = func_57((((int16_t)(l_62 == l_66) << (int16_t)(((void*)0 != (*l_56)) > ((*l_66) != (*l_66)))) && ((***l_62) & (**l_67))), ((void*)0 != l_70));
        /* statement id: 46 */
        assert (l_66 == 0);
    }
    /* facts after branching */
    assert (l_66 == 0);
    if (((void*)0 != (*l_56)))
    { /* block id: 48 */
        union U0 l_95 = {0UL};
        union U0 *l_94 = &l_95;
        l_96 = l_94;
        /* statement id: 49 */
        assert (l_96 == &l_95);
        (*l_68) = ((uint32_t)(((&l_95 == (void*)0) || (((-(uint16_t)l_95.f1) <= (l_100 || (*p_53))) & (l_95.f0 < l_95.f1))) != (((int16_t)((uint16_t)((int16_t)(**l_67) * (int16_t)(&l_95 == (void*)0)) - (uint16_t)0x8B87L) + (int16_t)l_95.f1) >= (**l_67))) / (uint32_t)0x46BA864CL);
    }
    else
    { /* block id: 51 */
        union U0 l_108 = {0UL};
        union U0 *l_107 = &l_108;
        union U0 **l_109 = &l_96;
        uint32_t l_126 = 0x80980311L;
        int32_t ***l_135 = &l_67;
        uint32_t l_274 = 0x518EE959L;
        uint32_t l_319 = 0xF24C6D4EL;
        int16_t l_354 = (-7L);
        (*l_109) = l_107;
        /* statement id: 52 */
        assert (l_96 == &l_108);
        (*p_53) = (((int16_t)((int32_t)(*l_68) + (int32_t)((uint16_t)((int16_t)((uint64_t)((uint16_t)(-(int64_t)((l_123 != (void*)0) < (&l_96 == &l_96))) * (uint16_t)((uint32_t)6UL % (uint32_t)0x2A14D58FL)) / (uint64_t)l_108.f0) / (int16_t)0x685AL) << (uint16_t)(*l_68))) << (int16_t)l_126) <= 4L);
        if ((((int16_t)((uint16_t)((uint16_t)(((uint32_t)((l_126 && ((0UL && (((l_135 != (*l_123)) != (-(int16_t)((***l_135) & 0UL))) ^ 0UL)) | (**l_67))) | (*l_68)) % (uint32_t)(***l_135)) == (***l_135)) + (uint16_t)0xB567L) >> (uint16_t)11) >> (int16_t)7) != (*p_53)))
        { /* block id: 54 */
            uint32_t l_139 = 0xDDDCD3E8L;
            union U1 *l_177 = (void*)0;
            int32_t *l_186 = (void*)0;
            int32_t ***l_208 = &l_67;
            if ((((uint16_t)l_139 >> (uint16_t)13) || (+((((uint16_t)0x7FF4L % (uint16_t)((!(!(***l_135))) & ((&l_54 == (void*)0) != (((l_139 & (0xEE3948B2L < (-1L))) && ((uint16_t)(((uint32_t)(l_139 <= 8UL) - (uint32_t)4294967295UL) && (-9L)) - (uint16_t)l_139)) > l_139)))) == 2UL) || 1L))))
            { /* block id: 55 */
                int64_t l_154 = 1L;
                union U0 *l_158 = &l_108;
                if ((-(uint64_t)8UL))
                { /* block id: 56 */
                    (*l_68) = 1L;
                    (*l_56) = (*l_56);
                    (*p_53) = ((((int16_t)((int32_t)(l_139 ^ (**l_67)) / (int32_t)l_154) + (int16_t)1UL) || 0xC2988D6DCB749617LL) <= (*p_53));
                    for (l_108.f0 = 0; (l_108.f0 > 22); l_108.f0 += 1)
                    { /* block id: 62 */
                        int32_t *l_157 = &l_69;
                        if ((***l_135))
                            break;
                        l_157 = p_53;
                        /* statement id: 64 */
                        //assert (l_157 == &l_48);
                    }
                    if (l_69)
                        goto lbl_159;
                }
                else
                { /* block id: 66 */
                    (*l_56) = (void*)0;
                    /* statement id: 67 */
                    assert (l_54 == 0);
                    if (l_69)
                        goto lbl_174;
                }
                /* facts after branching */
                assert (l_54 == 0 || l_54 == &l_55);
lbl_159:
                (*l_109) = l_158;
                (**l_67) = l_154;
                (*p_53) = ((int16_t)0x8D53L >> (int16_t)((uint32_t)0xF9C58AC2L - (uint32_t)((((uint16_t)(((0UL ^ ((uint16_t)((int64_t)((uint16_t)0x53FCL >> (uint16_t)3) - (int64_t)l_154) >> (uint16_t)2)) != (!l_139)) ^ (!((((void*)0 == &l_66) & l_139) != (***l_135)))) * (uint16_t)l_139) <= (***l_135)) != (***l_135))));
            }
            else
            { /* block id: 73 */
                (**l_67) = (*p_53);
                (***l_135) = (l_139 != 0xDC9EDED60BA8BA31LL);
            }
            /* facts after branching */
            assert (l_54 == 0 || l_54 == &l_55);
lbl_174:
            (*l_68) = (*p_53);
            (**l_135) = (**l_135);
            for (l_126 = 18; (l_126 != 21); l_126 += 1)
            { /* block id: 82 */
                int32_t *l_178 = &l_69;
                int32_t ****l_228 = &l_66;
                (*l_56) = l_177;
                /* statement id: 83 */
                assert (l_54 == 0);
            }
        }
        else
        { /* block id: 109 */
            uint32_t l_229 = 4294967289UL;
            union U1 *l_237 = &l_55;
            uint64_t l_286 = 18446744073709551607UL;
            union U0 *l_289 = &l_108;
            int32_t ***l_329 = &l_67;
            int32_t l_358 = 0xEB5E6DA3L;
            (*l_135) = (void*)0;
            /* statement id: 110 */
            assert (l_67 == 0);
            if ((l_229 < (l_229 ^ ((uint64_t)0xBF00CB84BFDF1D08LL + (uint64_t)(((uint32_t)(-(uint64_t)((int16_t)(*l_68) >> (int16_t)((l_237 == l_237) ^ (l_229 <= (l_108.f0 <= l_229))))) - (uint32_t)0x7B090339L) != l_108.f1)))))
            { /* block id: 111 */
                uint32_t l_254 = 5UL;
                uint32_t l_260 = 0x6EA53087L;
                int32_t *l_301 = &l_69;
                union U1 *l_328 = &l_55;
                if (((((int32_t)(((int16_t)((uint32_t)(0x7C41F251F002BF45LL | ((int16_t)(-7L) << (int16_t)((l_229 && (((uint16_t)((int64_t)((uint16_t)((int16_t)(0xA4FBL & (*l_68)) << (int16_t)15) >> (uint16_t)l_254) + (int64_t)l_254) + (uint16_t)((int16_t)(l_126 & (((&l_237 == (void*)0) && l_229) && l_254)) - (int16_t)l_254)) ^ l_229)) < l_229))) + (uint32_t)l_229) % (int16_t)l_254) && 0x4D14C442L) / (int32_t)l_254) > 18446744073709551615UL) || 7L))
                { /* block id: 112 */
                    int32_t **l_257 = &l_68;
                    (*l_257) = p_53;
                    /* statement id: 113 */
                    //assert (l_68 == &l_48);
                    (*l_257) = p_53;
                }
                else
                { /* block id: 115 */
                    int32_t l_261 = 0L;
                    union U0 *l_290 = &l_108;
                    if (((uint16_t)((l_260 && l_261) != ((*l_68) != ((int32_t)((int16_t)(l_229 & (((uint16_t)(((((int32_t)((uint64_t)((int16_t)5L >> (int16_t)7) / (uint64_t)(*l_68)) - (int32_t)(0x418026454160E171LL | l_274)) > (~3L)) >= 0xCD05L) != l_261) * (uint16_t)l_261) <= l_260)) % (int16_t)8L) % (int32_t)(*p_53)))) >> (uint16_t)9))
                    { /* block id: 116 */
                        uint32_t l_291 = 2UL;
                        (*l_68) = ((((((uint16_t)((uint16_t)(l_261 == ((((uint16_t)l_286 % (uint16_t)(((*l_68) > ((int16_t)(l_289 == l_290) << (int16_t)0)) ^ (l_291 | (l_254 & 0x5A20AEDE11C7F72DLL)))) | ((((int64_t)((int64_t)((int16_t)(((int64_t)0x19841E669F7C8D71LL % (int64_t)0x586A66762014B1BBLL) | 0UL) << (int16_t)14) - (int64_t)2UL) / (int64_t)l_286) != l_229) < 4UL)) == 0x1E57L)) * (uint16_t)0L) * (uint16_t)l_229) <= (-3L)) & 6L) || 0x5062F4E5E3F2DEF7LL) >= l_254);
                    }
                    else
                    { /* block id: 118 */
                        int32_t **l_300 = &l_68;
                        (*l_300) = p_53;
                        /* statement id: 119 */
                        //assert (l_68 == &l_48);
                        (**l_300) = l_254;
                    }
                    /* facts after branching */
                    //assert (l_68 == &l_48 || l_68 == &l_69);
                }
                /* facts after branching */
                //assert (l_68 == &l_48 || l_68 == &l_69);
                l_301 = p_53;
                /* statement id: 123 */
                //assert (l_301 == &l_48);
                for (l_69 = (-8); (l_69 <= 26); l_69 += 1)
                { /* block id: 126 */
                    int32_t l_304 = (-6L);
                    if (l_304)
                    { /* block id: 127 */
                        int32_t *l_309 = &l_69;
                        (*l_301) = ((uint16_t)((uint32_t)(*l_301) + (uint32_t)((l_229 >= (((((l_309 == &l_304) ^ (((uint16_t)((!((-(int16_t)((int32_t)0L + (int32_t)(~((int16_t)l_304 - (int16_t)((l_319 <= (*l_301)) ^ ((int16_t)((int16_t)(+((int16_t)(l_304 | 0xD309L) >> (int16_t)11)) << (int16_t)(*l_309)) << (int16_t)(*l_309))))))) >= 0xF1DF76A9L)) < (-2L)) << (uint16_t)(*l_301)) && l_286)) < (*l_309)) ^ 0x68CCL) >= 4294967295UL)) >= (*l_301))) << (uint16_t)l_304);
                    }
                    else
                    { /* block id: 129 */
                        union U1 *l_327 = &l_55;
                        uint16_t l_330 = 0x9CB3L;
                        l_327 = l_237;
                        (*p_53) = (((l_328 == l_237) >= (*l_301)) || (l_329 != (*l_123)));
                        (*p_53) = (l_330 || (l_330 && l_304));
                    }
                    (*l_301) = (*p_53);
                }
            }
            else
            { /* block id: 136 */
                uint64_t l_337 = 18446744073709551615UL;
                int32_t ***l_340 = &l_67;
                (*l_68) = (((l_126 <= 65535UL) || ((((uint64_t)(l_329 == l_135) + (uint64_t)((int16_t)((((((int16_t)l_337 * (int16_t)l_319) <= l_337) != ((1UL || (l_340 != (void*)0)) == l_286)) < l_341) == (-5L)) >> (int16_t)2)) < l_274) < l_337)) & l_286);
                return l_286;
            }
            /* facts after branching */
            //assert (l_68 == &l_48 || l_68 == &l_69);
            (*p_53) = ((void*)0 == &l_123);
            (*l_68) = (((uint16_t)(0xAD0AE36DBBD370A9LL || (+l_108.f0)) << (uint16_t)7) < ((int16_t)(((0xCBC3L >= (((int16_t)((int16_t)1L * (int16_t)(((0x39FAL > ((-(uint16_t)((int16_t)(l_354 < l_355) * (int16_t)((int16_t)l_358 - (int16_t)(((int32_t)(*p_53) - (int32_t)l_108.f1) && l_286)))) >= l_108.f0)) | (*l_68)) <= l_108.f2)) << (int16_t)3) ^ l_108.f1)) <= (*l_68)) <= l_358) % (int16_t)(*l_68)));
        }
        /* facts after branching */
        assert (l_54 == 0 || l_54 == &l_55);
        //assert (l_68 == &l_48 || l_68 == &l_69);
        assert (l_67 == 0 || l_67 == &l_68);
        (*l_56) = (*l_56);
    }
    /* facts after branching */
    assert (l_54 == 0 || l_54 == &l_55);
    //assert (l_68 == &l_48 || l_68 == &l_69);
    assert (l_67 == 0 || l_67 == &l_68);
    //assert (l_96 == dangling);
    return l_361;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t *** func_57(uint32_t  p_58, uint16_t  p_59)
{ /* block id: 28 */
    int32_t l_80 = 0x05104E0BL;
    int32_t *l_79 = &l_80;
    int32_t **l_78 = &l_79;
    int32_t ***l_77 = &l_78;
    int32_t ***l_81 = &l_78;
    int32_t ***l_90 = &l_78;
    int32_t ***l_91 = &l_78;
    int32_t ***l_92 = (void*)0;
    for (p_59 = (-4); (p_59 < 16); p_59++)
    { /* block id: 31 */
        int64_t l_73 = 0x44E0C42EF39980A6LL;
        int32_t *l_76 = (void*)0;
        int32_t **l_75 = &l_76;
        int32_t ***l_74 = &l_75;
        int32_t ***l_82 = (void*)0;
        if (l_73)
            break;
        return l_82;
        /* statement id: 33 */
        //assert (func_57_rv == 0);
    }
    for (l_80 = 0; (l_80 != (-28)); l_80 -= 4)
    { /* block id: 37 */
        int32_t *l_85 = (void*)0;
        int32_t l_87 = 0x6723FF49L;
        int32_t *l_86 = &l_87;
        (*l_86) = 1L;
    }
    for (l_80 = 14; (l_80 != 0); l_80 -= 1)
    { /* block id: 42 */
        if (p_58)
            break;
    }
    return l_92;
    /* statement id: 45 */
    //assert (func_57_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 119
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 2

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 24
   depth: 3, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 5
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2

XXX total number of pointers: 125

XXX times a variable address is taken: 132
XXX times a pointer is dereferenced on RHS: 97
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 15
   depth: 3, occurrence: 18
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 10
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 458

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 178
   level: 2, occurrence: 58
   level: 3, occurrence: 102
   level: 4, occurrence: 29
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 68
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20
XXX average alias set size: 1.16

XXX times a non-volatile is read: 657
XXX times a non-volatile is write: 246
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 3

XXX stmts: 129
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 22
   depth: 2, occurrence: 19
   depth: 3, occurrence: 25
   depth: 4, occurrence: 23
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

