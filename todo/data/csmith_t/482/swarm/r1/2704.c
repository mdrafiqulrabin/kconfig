/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1199220414
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int8_t  f1;
   const int16_t  f2;
   uint32_t  f3;
};
#pragma pack(pop)

struct S1 {
   const unsigned f0 : 3;
   signed f1 : 14;
   const signed f2 : 20;
   unsigned f3 : 25;
   signed f4 : 25;
   const signed f5 : 3;
   int32_t  f6;
};

struct S2 {
   int32_t  f0;
   struct S1  f1;
   uint32_t  f2;
   int16_t  f3;
   int16_t  f4;
   uint16_t  f5;
};

struct S3 {
   uint32_t  f0;
   const int32_t  f1;
   struct S2  f2;
   const struct S2  f3;
   struct S0  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static struct S1  func_40(int32_t * p_41, uint32_t  p_42);
static int32_t * func_43(int32_t  p_44, int32_t * p_45);
static int32_t  func_54(struct S1  p_55, int32_t * p_56);
static int32_t * func_58(struct S1  p_59, struct S0  p_60, int32_t * p_61, int32_t  p_62);
static struct S1  func_63(uint32_t  p_64, int16_t  p_65, int16_t  p_66, int32_t * p_67);
static uint32_t  func_69(int32_t * p_70);
static int32_t  func_71(int16_t  p_72);
static int16_t  func_77(struct S2  p_78, int32_t  p_79, struct S2  p_80);
static struct S2  func_86(int32_t ** p_87, int32_t ** p_88, int32_t  p_89, int32_t * p_90);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_30 = (-2L);
    const int16_t l_452 = 1L;
    struct S0 l_461 = {0x39B3A519L,0x22L,0xA3F6L,0xAE6E3A79L};
    struct S3 l_463 = {9UL,0x65B7602CL,{5L,{0,-15,-127,1953,-4181,1,6L},18446744073709551606UL,0L,-1L,0UL},{0x85511FB9L,{1,63,-798,5476,-1257,-0,8L},0xD80CF90BL,0x37D9L,1L,1UL},{0x91C5C265L,0L,-6L,0x57C5B49FL}};
    struct S3 *l_462 = &l_463;
    uint32_t l_464 = 4294967290UL;
    int32_t *l_465 = &l_463.f2.f1.f6;
    int32_t l_466 = 0L;
    for (l_30 = 0; (l_30 <= 16); l_30 = safe_add_func_uint32_t_u_u(l_30, 8))
    { /* block id: 39 */
        int32_t *l_34 = &l_30;
        int32_t **l_33 = &l_34;
        int32_t l_39 = 0x04F77722L;
        int32_t *l_38 = &l_39;
        struct S1 l_57 = {0,-72,42,3557,1014,1,-1L};
        struct S3 l_190 = {0x5B379E67L,0L,{0x51C80D2BL,{0,-21,490,2070,-680,0,0L},0xB7FCCDD1L,3L,0x3DCDL,5UL},{0xACF7F055L,{0,20,-926,3634,2760,0,0x9589B93CL},1UL,1L,-1L,0x4899L},{0L,3L,1L,1UL}};
        (*l_33) = (void*)0;
        /* statement id: 40 */
        assert (l_34 == 0);
        (*l_38) = (safe_rshift_func_uint16_t_u_s((~0x062A4B15L), 3));
        (*l_38) = ((func_40(func_43((safe_sub_func_uint32_t_u_u((l_30 , 2UL), (&l_30 != (l_30 , ((safe_sub_func_uint32_t_u_u((0x46AAL & (safe_add_func_uint32_t_u_u((safe_add_func_int32_t_s_s((((func_54(l_57, (*l_33)) , (((l_30 , l_190) , l_30) , (void*)0)) != &l_30) >= l_30), (*l_38))), l_30))), l_30)) , (void*)0))))), &l_30), (*l_38)) , l_452) ^ 0x5B796357L);
        for (l_190.f4.f3 = 0; (l_190.f4.f3 <= 29); l_190.f4.f3++)
        { /* block id: 273 */
            for (l_190.f2.f5 = 0; (l_190.f2.f5 != 42); l_190.f2.f5 = safe_add_func_uint32_t_u_u(l_190.f2.f5, 6))
            { /* block id: 276 */
                (*l_33) = (void*)0;
                /* statement id: 277 */
                assert (l_34 == 0);
            }
            (*l_33) = &l_30;
            /* statement id: 279 */
            assert (l_34 == &l_30);
        }
        /* facts after for loop */
        assert (l_34 == &l_30 || l_34 == 0);
    }
    (*l_465) = ((((safe_sub_func_int16_t_s_s(((l_30 & (safe_sub_func_int16_t_s_s(l_30, l_452))) > (0x16E4L == (l_461 , (((((l_461.f2 != l_30) || (9UL & ((void*)0 != l_462))) != l_463.f4.f3) & l_463.f2.f1.f5) > 0UL)))), l_464)) && l_461.f1) == 1UL) < 9UL);
    return l_466;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_40(int32_t * p_41, uint32_t  p_42)
{ /* block id: 114 */
    uint32_t l_200 = 18446744073709551606UL;
    struct S2 l_209 = {0x5D468399L,{0,-12,-503,4503,-666,-1,-1L},18446744073709551610UL,1L,0x5136L,0x1705L};
    struct S2 *l_208 = &l_209;
    struct S2 **l_207 = &l_208;
    int32_t *l_226 = &l_209.f1.f6;
    struct S1 *l_275 = &l_209.f1;
    struct S1 **l_274 = &l_275;
    struct S0 l_287 = {0xB021E3EDL,0x6AL,0x4ED8L,0x5958A52BL};
    struct S0 *l_286 = &l_287;
    struct S3 l_350 = {18446744073709551607UL,1L,{-3L,{1,-77,-759,266,2619,0,0L},0xDB1226E4L,-4L,0x5DE0L,0x2170L},{0x7CEE041AL,{1,89,441,2898,1227,0,-1L},4UL,0x9031L,-7L,1UL},{1L,0x35L,0x5324L,1UL}};
    struct S3 *l_349 = &l_350;
    struct S3 **l_348 = &l_349;
    struct S3 ***l_347 = &l_348;
    struct S0 l_392 = {0x8FAB63B0L,0x47L,0x680EL,0UL};
    struct S1 l_451 = {1,116,927,4110,-4869,-0,0x3BEF1C31L};
    if ((p_42 > (safe_add_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_s(__builtin_ctzl(p_42), (safe_sub_func_uint16_t_u_u(65535UL, (((func_69(p_41) && (l_200 > (*p_41))) , p_42) < 1UL))))) , 65535UL) != l_200), l_200))))
    { /* block id: 115 */
        struct S1 **l_201 = (void*)0;
        int32_t l_203 = 0x39074622L;
        int32_t *l_202 = &l_203;
        int32_t **l_204 = &l_202;
        (*l_202) = (((l_200 < ((-10L) < __builtin_bswap32((l_201 == (void*)0)))) , (void*)0) != p_41);
        (*l_204) = p_41;
        /* statement id: 117 */
        //assert (l_202 == &l_30);
        l_203 = ((func_69((*l_204)) < l_200) , (safe_add_func_uint16_t_u_u((((0xC728F5A6L ^ ((l_207 != &l_208) || ((0x3AFFB2B9L <= (safe_add_func_uint16_t_u_u(func_71(((*l_202) == ((*p_41) == 0x0ED1BE1EL))), l_200))) & 65535UL))) & (*l_202)) != p_42), 0xE34DL)));
    }
    else
    { /* block id: 119 */
        uint32_t l_221 = 0UL;
        struct S2 **l_227 = &l_208;
        const int32_t **l_234 = (void*)0;
        const struct S0 l_235 = {0x9B98514CL,0xE5L,0xECC0L,0x75EA0E85L};
        struct S1 *l_264 = &l_209.f1;
        int32_t **l_291 = (void*)0;
        int32_t *l_304 = (void*)0;
        int32_t *l_305 = (void*)0;
        int32_t *l_306 = &l_209.f1.f6;
        struct S1 l_316 = {0,-42,452,917,2598,-0,0xC225484FL};
        const struct S3 **l_352 = (void*)0;
        const struct S3 ***l_351 = &l_352;
        struct S0 **l_420 = &l_286;
        struct S0 ***l_419 = &l_420;
        struct S1 ***l_450 = (void*)0;
        if ((*p_41))
        { /* block id: 120 */
            int32_t **l_215 = (void*)0;
            int32_t ***l_214 = &l_215;
            struct S1 *l_231 = &l_209.f1;
            for (l_209.f0 = 19; (l_209.f0 == 12); l_209.f0 = safe_sub_func_uint16_t_u_u(l_209.f0, 1))
            { /* block id: 123 */
                int32_t *l_216 = (void*)0;
                int32_t *l_217 = &l_209.f1.f6;
                struct S2 ***l_228 = &l_227;
                (*l_217) = (l_214 == &l_215);
                for (l_209.f4 = 27; (l_209.f4 <= 10); l_209.f4 = safe_sub_func_uint32_t_u_u(l_209.f4, 9))
                { /* block id: 127 */
                    int32_t l_220 = 0x123D7D08L;
                    (*l_217) = ((l_220 | l_221) || (safe_mod_func_uint32_t_u_u(p_42, (*p_41))));
                }
                (*l_217) = __builtin_clz(((func_63(p_42, (p_42 , p_42), ((((safe_rshift_func_uint16_t_u_s((p_42 > 6L), (p_42 != (*p_41)))) || p_42) && ((*l_217) , (-3L))) ^ l_209.f1.f5), l_226) , (-6L)) & (*p_41)));
                (*l_228) = l_227;
            }
            for (l_209.f2 = 0; (l_209.f2 < 34); l_209.f2 = safe_add_func_uint16_t_u_u(l_209.f2, 1))
            { /* block id: 135 */
                struct S1 **l_232 = &l_231;
                (*l_232) = l_231;
                (*l_226) = __builtin_ffs(l_221);
            }
        }
        else
        { /* block id: 139 */
            int32_t l_233 = 0xB27C4B1FL;
            uint32_t l_240 = 0x2C7DCD8CL;
            int32_t *l_243 = &l_209.f1.f6;
            int32_t ***l_279 = (void*)0;
            int32_t **l_295 = &l_243;
            struct S2 l_298 = {0xFC3AFE4FL,{1,-3,-684,4570,-1007,-0,1L},0x28ACF740L,0xBC78L,-1L,0xD775L};
            struct S2 ****l_301 = (void*)0;
            if ((((((l_221 >= l_233) > 0UL) < (-7L)) ^ (l_234 != (void*)0)) , ((l_235 , (((*l_226) > (4L || p_42)) && p_42)) & p_42)))
            { /* block id: 140 */
                const struct S2 l_241 = {0x819E399DL,{1,-101,527,2709,2412,1,0x36D9B1EDL},0UL,0xD4FCL,0xB5D7L,0x10EAL};
                int32_t *l_242 = &l_209.f1.f6;
                l_243 = func_43(((safe_add_func_int32_t_s_s((*p_41), l_240)) || (p_41 != p_41)), func_43((*l_226), (l_241 , func_43(l_241.f1.f5, func_43((l_233 != p_42), l_242)))));
            }
            else
            { /* block id: 142 */
                uint16_t l_246 = 0xA3C2L;
                struct S1 l_249 = {0,70,130,1460,-4059,0,0xBB2E1187L};
                struct S2 ***l_262 = &l_227;
                int32_t ***l_272 = (void*)0;
                int32_t ****l_271 = &l_272;
                int32_t ***l_294 = &l_291;
                for (l_221 = (-21); (l_221 >= 36); l_221 = safe_add_func_int32_t_s_s(l_221, 9))
                { /* block id: 145 */
                    (*l_243) = l_246;
                    for (l_209.f3 = (-8); (l_209.f3 < (-27)); l_209.f3 = safe_sub_func_uint32_t_u_u(l_209.f3, 1))
                    { /* block id: 149 */
                        return l_249;
                    }
                }
                if ((*p_41))
                { /* block id: 153 */
                    uint32_t l_261 = 0UL;
                    uint16_t l_268 = 0x501BL;
                    struct S0 l_285 = {4L,-1L,-1L,0x4639052BL};
                    struct S0 *l_284 = &l_285;
                    struct S2 **l_290 = (void*)0;
                    int8_t l_292 = 9L;
                    if ((safe_mod_func_uint32_t_u_u((safe_sub_func_int16_t_s_s((!(0xCAAFL < (safe_sub_func_int32_t_s_s((safe_sub_func_int16_t_s_s(((safe_add_func_uint32_t_u_u(((p_41 != (void*)0) & l_261), ((l_262 == (void*)0) <= ((l_235.f0 && ((((-3L) & 0x096EL) > (*p_41)) < 0xB5C6L)) > (*p_41))))) , p_42), p_42)), l_249.f5)))), p_42)), (*p_41))))
                    { /* block id: 154 */
                        struct S2 *l_263 = &l_209;
                        const struct S1 *l_265 = &l_249;
                        (*l_207) = l_263;
                        (*l_243) = (l_264 != l_265);
                        (*l_243) = (safe_sub_func_uint16_t_u_u((l_268 == (*l_243)), ((*p_41) ^ l_249.f4)));
                    }
                    else
                    { /* block id: 158 */
                        struct S2 ****l_269 = (void*)0;
                        struct S2 ****l_270 = &l_262;
                        int32_t *****l_273 = &l_271;
                        struct S1 **l_276 = (void*)0;
                        (*l_270) = &l_207;
                        /* statement id: 159 */
                        assert (l_262 == &l_207);
                        (*l_243) = 8L;
                        (*l_273) = l_271;
                        l_276 = l_274;
                        /* statement id: 162 */
                        assert (l_276 == &l_275);
                    }
                    /* facts after branching */
                    assert (l_262 == &l_207 || l_262 == &l_227);
                    if (((p_42 , 1UL) | (*l_226)))
                    { /* block id: 164 */
                        (*l_243) = (-1L);
                        (*l_226) = (safe_mod_func_uint16_t_u_u((*l_226), 0x7207L));
                    }
                    else
                    { /* block id: 167 */
                        struct S1 ***l_280 = &l_274;
                        int32_t *l_281 = (void*)0;
                        int32_t **l_282 = (void*)0;
                        int32_t **l_283 = &l_226;
                        (*l_271) = l_279;
                        (*l_280) = (void*)0;
                        /* statement id: 169 */
                        assert (l_274 == 0);
                        l_264 = &l_249;
                        /* statement id: 170 */
                        assert (l_264 == &l_249);
                        (*l_283) = l_281;
                        /* statement id: 171 */
                        assert (l_226 == 0);
                    }
                    /* facts after branching */
                    assert (l_226 == 0 || l_226 == &l_209.f1.f6);
                    assert (l_264 == &l_249 || l_264 == &l_209.f1);
                    assert (l_274 == 0 || l_274 == &l_275);
                    l_286 = l_284;
                    /* statement id: 173 */
                    assert (l_286 == &l_285);
                    (*l_243) = (safe_mod_func_int16_t_s_s((((((((0L ^ (p_42 , p_42)) , ((*p_41) == ((((*p_41) , l_290) == l_227) ^ ((**l_207) , p_42)))) , (*p_41)) > (*p_41)) , l_285.f0) < p_42) <= p_42), l_292));
                }
                else
                { /* block id: 175 */
                    struct S1 l_293 = {0,85,1020,2139,4134,0,0x0AE462C7L};
                    (*l_243) = (*p_41);
                    (*l_243) = __builtin_ia32_crc32qi(p_42, p_42);
                    return l_293;
                }
                /* facts after branching */
                assert (l_226 == 0 || l_226 == &l_209.f1.f6);
                assert (l_262 == &l_207 || l_262 == &l_227);
                assert (l_264 == &l_249 || l_264 == &l_209.f1);
                assert (l_274 == 0 || l_274 == &l_275);
                //assert (l_286 == dangling);
                (*l_294) = &p_41;
                /* statement id: 180 */
                assert (l_291 == &p_41);
            }
            /* facts after branching */
            assert (l_226 == 0 || l_226 == &l_209.f1.f6);
            //assert (l_264 == dangling || l_264 == &l_209.f1);
            assert (l_274 == 0 || l_274 == &l_275);
            //assert (l_286 == dangling || l_286 == &l_287);
            assert (l_291 == &p_41 || l_291 == 0);
            (*l_295) = (void*)0;
            /* statement id: 182 */
            assert (l_243 == 0);
            (*l_295) = func_43(((((*p_41) | (((safe_rshift_func_int16_t_s_u(((p_42 & (*p_41)) & (((*p_41) != (&l_295 == &l_295)) , (((((l_298 , p_42) <= ((safe_rshift_func_uint16_t_u_s(5UL, p_42)) <= 4L)) == p_42) <= (*p_41)) | 0x1C739BD0L))), 1)) , l_301) == (void*)0)) , 0xFC568336L) <= l_209.f2), p_41);
            /* statement id: 183 */
            //assert (l_243 == &l_30);
            for (l_209.f3 = (-21); (l_209.f3 != (-21)); l_209.f3 = safe_add_func_uint32_t_u_u(l_209.f3, 1))
            { /* block id: 186 */
                (*l_295) = p_41;
            }
        }
        /* facts after branching */
        assert (l_226 == 0 || l_226 == &l_209.f1.f6);
        //assert (l_264 == dangling || l_264 == &l_209.f1);
        assert (l_274 == 0 || l_274 == &l_275);
        //assert (l_286 == dangling || l_286 == &l_287);
        assert (l_291 == &p_41 || l_291 == 0);
        (*l_306) = (*p_41);
        for (l_287.f3 = 4; (l_287.f3 >= 19); l_287.f3 = safe_add_func_int16_t_s_s(l_287.f3, 5))
        { /* block id: 193 */
            struct S2 **l_314 = (void*)0;
            struct S2 ***l_315 = &l_207;
            int32_t l_317 = 0xC50531CEL;
            struct S1 l_441 = {1,-96,-874,3124,-3279,0,0xB64F1506L};
        }
        (*l_306) = ((((*p_41) < ((*l_275) , (safe_mod_func_int32_t_s_s(func_71(p_42), (p_42 & 4UL))))) && ((!p_42) , (safe_sub_func_int32_t_s_s(((l_450 == (void*)0) | p_42), p_42)))) && p_42);
    }
    /* facts after branching */
    assert (l_226 == 0 || l_226 == &l_209.f1.f6);
    assert (l_274 == 0 || l_274 == &l_275);
    //assert (l_286 == dangling || l_286 == &l_287);
    return l_451;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(int32_t  p_44, int32_t * p_45)
{ /* block id: 110 */
    int32_t l_193 = 8L;
    int32_t *l_192 = &l_193;
    int32_t **l_191 = &l_192;
    (*l_191) = p_45;
    /* statement id: 111 */
    //assert (l_192 == &l_30 || l_192 == &l_209.f1.f6);
    l_193 = func_69((*l_191));
    return p_45;
    /* statement id: 113 */
    //assert (func_43_rv == &l_30 || func_43_rv == &l_209.f1.f6);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_54(struct S1  p_55, int32_t * p_56)
{ /* block id: 42 */
    struct S3 l_68 = {18446744073709551606UL,0L,{0x6F941663L,{1,99,-128,3720,243,-0,0L},0x2B4B20F9L,5L,1L,65535UL},{-8L,{1,-114,294,481,3926,-0,2L},0x2166A3C8L,0xCBD0L,-9L,9UL},{0xE577E9FBL,0x33L,1L,0x5F1E6118L}};
    int32_t *l_171 = (void*)0;
    uint32_t l_172 = 18446744073709551615UL;
    int16_t l_173 = 0x207EL;
    int32_t **l_186 = &l_171;
    const int32_t *l_189 = &l_68.f2.f1.f6;
    const int32_t **l_188 = &l_189;
    const int32_t ***l_187 = &l_188;
    (*l_186) = func_58(func_63((l_68 , func_69((func_71((l_68.f3.f1.f1 == 0x3DCCD505L)) , (void*)0))), (p_55.f5 && (l_68.f3.f1.f1 , (safe_add_func_int32_t_s_s((!((safe_sub_func_uint32_t_u_u(((((p_56 == l_171) > 3L) , l_68.f2) , p_55.f5), l_172)) && l_173)), 0xFD58D487L)))), p_55.f2, l_171), l_68.f4, l_171, l_68.f3.f4);
    (*l_187) = &p_56;
    /* statement id: 108 */
    assert (l_188 == &p_56);
    return p_55.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_58(struct S1  p_59, struct S0  p_60, int32_t * p_61, int32_t  p_62)
{ /* block id: 104 */
    struct S2 l_184 = {0L,{0,27,672,5027,-4280,0,0L},0x96FAD9A2L,0L,-5L,65530UL};
    struct S2 *l_183 = &l_184;
    struct S2 **l_182 = &l_183;
    int32_t *l_185 = (void*)0;
    (*l_182) = (void*)0;
    /* statement id: 105 */
    assert (l_183 == 0);
    return l_185;
    /* statement id: 106 */
    //assert (func_58_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_63(uint32_t  p_64, int16_t  p_65, int16_t  p_66, int32_t * p_67)
{ /* block id: 90 */
    int32_t l_175 = 0L;
    int32_t *l_174 = &l_175;
    int32_t **l_176 = &l_174;
    struct S2 l_178 = {-9L,{0,107,738,208,993,-0,-4L},0x35910C01L,0x1C0EL,0x8998L,0xE7CBL};
    (*l_176) = l_174;
    (*l_174) = p_66;
    if ((p_65 <= (~(((((p_64 > 0x45721076L) > __builtin_ffsl((**l_176))) != (*l_174)) , l_178) , ((0x6DEEBD24L ^ p_64) <= p_64)))))
    { /* block id: 93 */
        int32_t *l_179 = &l_175;
        (*l_176) = ((p_64 < 0xA3D8E1EFL) , l_179);
    }
    else
    { /* block id: 95 */
        p_67 = p_67;
    }
    for (p_66 = (-4); (p_66 < 26); p_66 = safe_add_func_int16_t_s_s(p_66, 3))
    { /* block id: 100 */
        (**l_176) = __builtin_popcountl((*l_174));
    }
    return l_178.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_69(int32_t * p_70)
{ /* block id: 87 */
    int32_t l_165 = (-5L);
    int32_t *l_164 = &l_165;
    int32_t **l_163 = &l_164;
    (*l_163) = (void*)0;
    /* statement id: 88 */
    assert (l_164 == 0);
    return l_165;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_71(int16_t  p_72)
{ /* block id: 43 */
    uint32_t l_75 = 0xB5A03F75L;
    uint32_t l_76 = 1UL;
    int32_t *l_81 = (void*)0;
    int8_t l_82 = 0xF5L;
    struct S2 l_83 = {5L,{0,-77,-1004,2417,-3904,0,0x746A0FEEL},1UL,0L,-5L,0xADD7L};
    int32_t *l_100 = &l_83.f1.f6;
    int32_t **l_101 = &l_81;
    struct S3 l_109 = {1UL,0x50A9A040L,{-1L,{0,-18,1013,1177,-2465,-0,0x9ECF7F40L},1UL,0xD10AL,0x0FE9L,0UL},{0L,{0,104,-349,54,1931,0,7L},0x3375A076L,0xA15EL,0xF53DL,0x9439L},{0L,0x7AL,5L,4294967290UL}};
    uint32_t l_118 = 0xFD0DEDD1L;
    uint32_t l_138 = 0x7AC055B4L;
    uint32_t l_162 = 8UL;
    (*l_100) = ((safe_add_func_uint16_t_u_u(l_75, (((l_76 ^ func_77(((__builtin_clz((l_81 != (void*)0)) == (p_72 ^ (l_82 > ((void*)0 != l_81)))) , l_83), p_72, l_83)) < p_72) , p_72))) >= l_83.f1.f6);
    (*l_101) = (l_83 , l_81);
    if ((safe_lshift_func_uint16_t_u_s(((0xE74AL & 1L) != __builtin_ctz((~(*l_100)))), p_72)))
    { /* block id: 58 */
        const int16_t l_117 = 0x674BL;
        for (l_83.f0 = (-26); (l_83.f0 >= 22); l_83.f0 = safe_add_func_int16_t_s_s(l_83.f0, 1))
        { /* block id: 61 */
            struct S1 *l_110 = &l_109.f2.f1;
            int32_t l_112 = 5L;
            for (l_83.f2 = 11; (l_83.f2 >= 50); l_83.f2 = safe_add_func_int16_t_s_s(l_83.f2, 1))
            { /* block id: 64 */
                struct S1 **l_111 = &l_110;
                (*l_111) = (l_109 , l_110);
            }
            (*l_100) = ((*l_110) , (l_112 != (safe_mod_func_int32_t_s_s(p_72, (l_112 , (__builtin_ctz((((*l_110) , (l_112 & (*l_100))) , ((safe_sub_func_int16_t_s_s((((*l_101) == &l_112) && l_112), 0x8086L)) | l_112))) , l_117))))));
            if (l_118)
                continue;
            if (p_72)
                break;
        }
    }
    else
    { /* block id: 71 */
        int16_t l_128 = 0x679DL;
        int32_t **l_131 = &l_81;
        struct S0 l_137 = {-2L,0x6BL,0x7B52L,0xBB995997L};
        struct S2 l_139 = {0xDC695E73L,{1,23,-114,4986,-3710,-0,1L},0xA39E7607L,0x70E1L,-1L,65535UL};
        int8_t l_150 = 0x69L;
        uint32_t l_155 = 1UL;
        int32_t l_161 = 0xF6BC7391L;
        for (l_109.f0 = 13; (l_109.f0 >= 33); l_109.f0 = safe_add_func_int16_t_s_s(l_109.f0, 3))
        { /* block id: 74 */
            struct S2 l_123 = {0xA095ECA5L,{1,-40,-568,1464,-1143,-1,0x082CCC80L},18446744073709551615UL,0x3A16L,-4L,65535UL};
            int32_t **l_140 = &l_81;
            int32_t *l_154 = &l_123.f1.f6;
            (*l_100) = ((safe_rshift_func_uint16_t_u_u(p_72, 7)) , ((l_123 , (safe_sub_func_int32_t_s_s(((safe_add_func_uint16_t_u_u(p_72, l_128)) , 1L), (((((p_72 != p_72) != ((safe_rshift_func_uint16_t_u_s(l_128, (l_131 != &l_81))) ^ p_72)) ^ 0x8C0AL) && 0x48E9L) > 0x1EA1L)))) , p_72));
            (*l_100) = l_128;
        }
        (*l_100) = (((l_155 > (l_131 != (((safe_unary_minus_func_uint16_t_u((((p_72 <= (safe_mod_func_int32_t_s_s(__builtin_clz(p_72), p_72))) < (p_72 & (safe_add_func_int16_t_s_s((p_72 && (l_161 != p_72)), l_162)))) , l_150))) != 4294967295UL) , &l_100))) != p_72) || p_72);
    }
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_77(struct S2  p_78, int32_t  p_79, struct S2  p_80)
{ /* block id: 44 */
    int32_t l_93 = 1L;
    int32_t *l_92 = &l_93;
    int32_t **l_91 = &l_92;
    int32_t *l_99 = &l_93;
    (*l_99) = (safe_rshift_func_uint16_t_u_s((((65535UL && (func_86(l_91, &l_92, (**l_91), (*l_91)) , 0x02FDL)) && __builtin_ctz(p_78.f1.f5)) <= p_80.f3), p_80.f0));
    /* statement id: 54 */
    assert (l_92 == 0 || l_92 == &l_93);
    return p_80.f1.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_86(int32_t ** p_87, int32_t ** p_88, int32_t  p_89, int32_t * p_90)
{ /* block id: 45 */
    uint32_t l_97 = 4294967294UL;
    struct S2 l_98 = {0xF25865EEL,{0,17,-489,2876,-645,1,-1L},0xD8BEEF89L,0L,0xD2E6L,8UL};
    for (p_89 = 0; (p_89 > 9); p_89 = safe_add_func_int16_t_s_s(p_89, 8))
    { /* block id: 48 */
        int32_t *l_96 = (void*)0;
        (*p_88) = l_96;
        /* statement id: 49 */
        //assert (l_92 == 0);
        (*p_87) = (*p_87);
        if (l_97)
            break;
    }
    /* facts after for loop */
    //assert (l_92 == 0 || l_92 == &l_93);
    return l_98;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 3
breakdown:
   depth: 0, occurrence: 97
   depth: 1, occurrence: 13
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 43
breakdown:
   indirect level: 0, occurrence: 19
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 31
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 16

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 24
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 5
   depth: 17, occurrence: 2
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 121

XXX times a variable address is taken: 113
XXX times a pointer is dereferenced on RHS: 66
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 76
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 306

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 212
   level: 2, occurrence: 45
   level: 3, occurrence: 8
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 68
XXX number of pointers point to scalars: 38
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 37.2
XXX average alias set size: 1.36

XXX times a non-volatile is read: 531
XXX times a non-volatile is write: 192
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 99
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 20
   depth: 2, occurrence: 14
   depth: 3, occurrence: 13
   depth: 4, occurrence: 10
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

