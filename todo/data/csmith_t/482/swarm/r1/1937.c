/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3846989462
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint16_t  f0;
   int8_t  f1;
   unsigned f2 : 4;
   uint32_t  f3;
};

struct S1 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
   int8_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static struct S1  func_7(struct S0  p_8, uint32_t  p_9);
static struct S0  func_10(uint16_t  p_11, int8_t  p_12);
static uint16_t  func_16(int32_t  p_17);
static uint16_t  func_20(int32_t  p_21, int32_t  p_22, uint16_t  p_23, int8_t  p_24, uint32_t  p_25);
static int32_t  func_26(int32_t  p_27, struct S0  p_28, uint32_t  p_29, uint16_t  p_30);
static struct S0  func_31(uint32_t  p_32, int32_t  p_33);
static uint16_t  func_37(struct S0  p_38);
static struct S0  func_39(uint32_t  p_40, struct S0  p_41, struct S0  p_42);
static int32_t  func_43(uint16_t  p_44, int16_t  p_45, int32_t  p_46);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 6;
    uint32_t l_100 = 0x99A04901;
    int32_t l_265 = 0x85B5AE06;
    int32_t l_266 = 0;
    struct S0 l_273 = {0x58E5,-1,3,1U};
    struct S1 l_276 = {0x8A0955A1,0x78C3C85A,0x76B3CF8E,-1};
    int32_t l_306 = 0xAF094154;
    int32_t *l_312 = &l_266;
    int32_t l_353 = 9;
    int8_t l_363 = 6;
    struct S1 *l_364 = &l_276;
    struct S1 **l_365 = &l_364;
    int32_t **l_366 = &l_312;
    uint32_t l_367 = 0U;
    for (l_2 = 25; (l_2 != 4); l_2--)
    { /* block id: 3 */
        uint32_t l_13 = 1U;
        struct S0 l_48 = {0x5EB5,-2,2,2U};
        uint32_t l_101 = 0x46A6819D;
        int32_t *l_309 = &l_266;
        int32_t **l_308 = &l_309;
        struct S1 l_321 = {4294967290U,0xC4E18AC2,7,-5};
        struct S0 *l_351 = &l_273;
        struct S0 **l_350 = &l_351;
        struct S0 ***l_349 = &l_350;
        struct S0 ****l_348 = &l_349;
        l_266 = (((uint16_t)0x012E - (uint16_t)(func_7(func_10(l_13, (l_2 || ((l_2 != (((uint16_t)65535U * (uint16_t)func_16((((uint16_t)func_20(func_26(l_2, func_31((!((uint16_t)func_37(func_39((((l_2 != l_2) <= (func_43(l_13, l_13, l_2) , l_2)) == l_13), l_48, l_48)) + (uint16_t)l_13)), l_48.f2), l_100, l_101), l_100, l_13, l_2, l_100) << (uint16_t)14) , l_100))) || l_2)) == l_2))), l_2) , l_265)) | l_48.f1);
        if (l_100)
        { /* block id: 96 */
            int32_t l_271 = 0x816DE6D4;
            int32_t *l_272 = &l_266;
            for (l_265 = (-6); (l_265 != 28); l_265 += 1)
            { /* block id: 99 */
                struct S0 l_269 = {0xC14A,-1,0,0x0F6C4407};
                struct S0 *l_270 = &l_48;
                (*l_270) = l_269;
            }
            (*l_272) = ((l_271 ^ l_271) || l_265);
        }
        else
        { /* block id: 103 */
            struct S0 *l_277 = &l_273;
            int32_t l_278 = (-3);
            uint16_t l_297 = 0U;
            struct S1 l_307 = {1U,0x23968A6B,-1,0xFA};
            struct S0 **l_328 = &l_277;
            struct S0 ***l_327 = &l_328;
            struct S0 ****l_326 = &l_327;
            if ((((func_39(l_265, l_273, func_39((l_2 && ((uint16_t)((&l_48 == (l_276 , l_277)) , l_48.f2) + (uint16_t)((((l_278 == (((uint16_t)0x1D89 >> (uint16_t)l_276.f1) <= l_278)) & l_278) == l_48.f1) , l_48.f0))), l_48, (*l_277))) , l_276.f2) <= l_278) > 0x895C))
            { /* block id: 104 */
                int32_t l_281 = 0x97DFDE01;
                int32_t *l_287 = &l_276.f1;
                int32_t ***l_316 = &l_308;
                if (l_281)
                { /* block id: 105 */
                    int32_t **l_282 = (void*)0;
                    int32_t *l_284 = &l_281;
                    int32_t **l_283 = &l_284;
                    int32_t ***l_286 = (void*)0;
                    int32_t ****l_285 = &l_286;
                    (*l_283) = &l_266;
                    /* statement id: 106 */
                    assert (l_284 == &l_266);
                    (*l_285) = (void*)0;
                    (*l_284) = l_281;
                }
                else
                { /* block id: 109 */
                    int32_t **l_288 = &l_287;
                    struct S1 l_310 = {0U,1,0x3E3AF337,-1};
                    struct S1 *l_311 = &l_307;
                    (*l_288) = l_287;
                    for (l_48.f3 = (-15); (l_48.f3 < 40); l_48.f3 += 6)
                    { /* block id: 113 */
                        struct S0 l_305 = {0xFD1A,7,0,4294967287U};
                        (*l_287) = (((uint16_t)65527U % (uint16_t)((uint16_t)((int32_t)(l_297 < (((int16_t)l_273.f3 - (int16_t)(-(int16_t)(((int16_t)((l_297 & (((((l_305 , (l_276.f2 <= l_306)) || (l_307 , (&l_276 == &l_307))) , &l_287) == l_308) > (**l_308))) && (-2)) * (int16_t)l_278) & l_307.f3))) <= l_266)) % (int32_t)(*l_287)) << (uint16_t)l_276.f1)) > 9);
                    }
                    (*l_311) = l_310;
                }
                l_312 = &l_266;
                (*l_312) = ((int32_t)l_307.f3 - (int32_t)(!(l_297 || ((*l_287) ^ ((*l_309) != (((void*)0 == l_316) != 65529U))))));
            }
            else
            { /* block id: 120 */
                uint32_t l_331 = 9U;
                uint16_t l_352 = 1U;
                for (l_273.f3 = 21; (l_273.f3 > 19); l_273.f3 -= 3)
                { /* block id: 123 */
                    int32_t *l_322 = (void*)0;
                    int32_t l_332 = 3;
                    if ((*l_312))
                    { /* block id: 124 */
                        uint32_t l_323 = 0xD11C4BEF;
                        (*l_312) = ((((int16_t)((*l_308) == (l_321 , l_322)) << (int16_t)12) != l_323) < ((uint32_t)((void*)0 != l_326) - (uint32_t)((int32_t)l_331 + (int32_t)l_332)));
                        if (l_307.f1)
                            break;
                    }
                    else
                    { /* block id: 127 */
                        return l_307.f2;
                    }
                }
                (*l_312) = (4294967287U >= ((int16_t)1 + (int16_t)((int16_t)(*l_309) * (int16_t)(((int32_t)(((((7U != ((uint32_t)((int16_t)(((((-(uint32_t)(l_48 , ((uint16_t)((((((uint16_t)(*l_312) + (uint16_t)((l_348 != (void*)0) | ((void*)0 == &l_308))) > l_307.f1) == (*l_312)) || l_331) >= l_278) << (uint16_t)7))) == 0x2CE4) >= l_278) >= l_331) ^ l_352) - (int16_t)l_307.f3) - (uint32_t)(*l_309))) , 0x29D7283E) & l_353) ^ 0x0743) >= 1U) % (int32_t)0x700EDE03) < (*l_312)))));
                for (l_297 = 4; (l_297 <= 35); ++l_297)
                { /* block id: 134 */
                    int32_t *l_362 = &l_276.f1;
                    for (l_352 = 0; (l_352 == 31); ++l_352)
                    { /* block id: 137 */
                        uint16_t l_360 = 65535U;
                        int32_t *l_361 = &l_307.f1;
                        l_362 = (((uint16_t)l_360 % (uint16_t)(**l_308)) , l_361);
                        /* statement id: 138 */
                        assert (l_362 == &l_307.f1);
                    }
                    /* facts after for loop */
                    assert (l_362 == &l_307.f1 || l_362 == &l_276.f1);
                    return l_363;
                }
            }
        }
    }
    (*l_364) = l_276;
    (*l_365) = &l_276;
    (*l_366) = &l_266;
    return l_367;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_7(struct S0  p_8, uint32_t  p_9)
{ /* block id: 84 */
    int32_t l_252 = 0x39E86592;
    int32_t *l_251 = &l_252;
    struct S1 l_258 = {0x8102D8EA,0xAD00C468,-1,0x3B};
    if (p_8.f2)
    { /* block id: 85 */
        int32_t **l_253 = (void*)0;
        int32_t **l_254 = &l_251;
        struct S0 l_256 = {0xD0B4,0,0,4294967295U};
        struct S0 *l_255 = &l_256;
        struct S0 **l_257 = &l_255;
        struct S1 *l_259 = &l_258;
        (*l_254) = l_251;
        (*l_257) = l_255;
        (*l_259) = l_258;
        (**l_254) = p_8.f2;
    }
    else
    { /* block id: 90 */
        int32_t *l_260 = &l_258.f1;
        struct S0 l_263 = {0U,-1,0,0x76AF418E};
        struct S0 *l_262 = &l_263;
        struct S0 **l_261 = &l_262;
        struct S0 ***l_264 = &l_261;
        l_260 = l_260;
        (*l_264) = l_261;
    }
    return l_258;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_10(uint16_t  p_11, int8_t  p_12)
{ /* block id: 35 */
    struct S1 l_128 = {0xD1D32CE0,0xB3D22234,0x8E39048C,-1};
    uint32_t l_146 = 0xDE7F7125;
    struct S0 l_147 = {0x1DC8,1,1,0x6F0B9C9A};
    struct S0 *l_148 = (void*)0;
    struct S0 *l_149 = &l_147;
    int32_t *l_150 = &l_128.f1;
    int16_t l_221 = 0;
    uint16_t l_246 = 0xBEF0;
    int16_t l_247 = 5;
    struct S0 l_250 = {0U,1,3,0x8899DCF5};
    (*l_149) = func_39((l_128 , p_12), ((((uint16_t)(((uint16_t)(((int16_t)(1 | (p_12 >= ((uint16_t)(l_128 , (-(uint32_t)(0xB8437FCE || ((int16_t)((int16_t)((int32_t)0x5E1251B0 % (int32_t)p_12) * (int16_t)((uint16_t)(0 | l_128.f0) % (uint16_t)l_128.f1)) + (int16_t)65526U)))) * (uint16_t)p_12))) * (int16_t)p_12) & l_128.f1) << (uint16_t)l_128.f0) & 4U) % (uint16_t)l_146) < l_146) , l_147), l_147);
    (*l_150) = p_12;
    for (l_146 = 0; (l_146 > 48); l_146 += 4)
    { /* block id: 40 */
        if (p_11)
            break;
        (*l_150) = ((*l_150) && ((-7) < 4294967287U));
    }
    if ((p_11 ^ (*l_150)))
    { /* block id: 44 */
        int32_t l_169 = 6;
        int32_t *l_168 = &l_169;
        struct S1 l_170 = {1U,0xF1468EAF,-1,0x7D};
        int32_t l_195 = 0x1787847B;
        struct S1 *l_216 = &l_170;
        struct S1 **l_215 = &l_216;
        struct S0 **l_242 = (void*)0;
        struct S0 ***l_241 = &l_242;
        struct S0 ****l_240 = &l_241;
        int32_t l_245 = 0xF3D060ED;
        for (l_147.f1 = 0; (l_147.f1 > (-5)); l_147.f1 -= 7)
        { /* block id: 47 */
            struct S1 l_155 = {2U,-1,-8,0xA5};
            struct S1 *l_156 = &l_155;
            struct S0 **l_160 = &l_148;
            struct S0 ***l_159 = &l_160;
            struct S0 ****l_158 = &l_159;
            struct S0 l_178 = {7U,4,0,4294967288U};
            int32_t **l_194 = &l_168;
            (*l_156) = l_155;
            if (((~65531U) ^ (l_155.f3 == ((void*)0 == l_158))))
            { /* block id: 49 */
                int32_t *l_164 = &l_155.f1;
                struct S0 l_209 = {65526U,-1,1,4294967291U};
                for (l_128.f1 = 12; (l_128.f1 < 3); l_128.f1--)
                { /* block id: 52 */
                    int32_t *l_163 = &l_128.f1;
                    struct S1 l_196 = {4294967291U,0x2FE5E662,-1,0};
                    uint32_t l_220 = 1U;
                    l_164 = l_163;
                    /* statement id: 53 */
                    assert (l_164 == &l_128.f1);
                    for (l_155.f0 = (-14); (l_155.f0 == 3); l_155.f0 += 1)
                    { /* block id: 56 */
                        int32_t **l_167 = (void*)0;
                        struct S1 *l_171 = (void*)0;
                        int32_t l_185 = 0x06392A37;
                        int32_t *l_186 = &l_185;
                        l_168 = l_163;
                        /* statement id: 57 */
                        assert (l_168 == &l_128.f1);
                        l_170 = (l_170 , (*l_156));
                        (*l_186) = (((*l_163) , ((int16_t)(((int16_t)9 >> (int16_t)(*l_150)) && 0) % (int16_t)((uint16_t)((0U & ((l_178 , ((((uint32_t)(((int16_t)((((*l_150) , 0x769E) , ((((int32_t)p_12 + (int32_t)p_11) && 1U) & 1)) | (*l_168)) + (int16_t)0x8E93) | p_12) - (uint32_t)p_12) >= p_12) | 0xBFF233E6)) <= l_185)) , (*l_164)) % (uint16_t)p_12))) >= 0xE024);
                    }
                    if ((*l_163))
                        break;
                }
                /* facts after for loop */
                assert (l_164 == &l_128.f1 || l_164 == &l_155.f1);
                (**l_215) = l_128;
                (*l_164) = p_12;
            }
            else
            { /* block id: 73 */
                (**l_215) = (**l_215);
                (*l_194) = (*l_194);
            }
        }
        /* facts after for loop */
        assert (l_168 == &l_128.f1 || l_168 == &l_169);
        (*l_150) = ((((((l_221 | ((uint32_t)4294967295U % (uint32_t)0x8CDDD8CA)) && (-(uint32_t)(((uint16_t)((int32_t)(((((((((uint16_t)(((uint16_t)((uint16_t)((uint16_t)((~((0x4ADAB247 == ((uint16_t)(*l_150) * (uint16_t)((((void*)0 != l_240) > (-8)) >= (((uint16_t)(*l_150) >> (uint16_t)(*l_168)) >= (*l_168))))) || 1U)) ^ (*l_150)) - (uint16_t)(*l_168)) << (uint16_t)(*l_150)) * (uint16_t)l_245) == (*l_168)) << (uint16_t)13) >= p_12) , 0x48A8) || l_246) < (*l_168)) ^ (*l_150)) ^ p_11) , 0x3BF97C4F) % (int32_t)(*l_168)) >> (uint16_t)11) > p_11))) , (*l_168)) || l_247) , l_128) , (-1));
    }
    else
    { /* block id: 79 */
        int32_t **l_248 = (void*)0;
        int32_t **l_249 = &l_150;
        l_150 = l_150;
        (*l_249) = l_150;
    }
    return l_250;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_16(int32_t  p_17)
{ /* block id: 31 */
    struct S0 l_124 = {1U,0x43,1,7U};
    struct S0 *l_123 = &l_124;
    struct S0 **l_125 = &l_123;
    struct S0 ***l_127 = &l_125;
    struct S0 ****l_126 = &l_127;
    (*l_125) = l_123;
    (*l_126) = &l_125;
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_20(int32_t  p_21, int32_t  p_22, uint16_t  p_23, int8_t  p_24, uint32_t  p_25)
{ /* block id: 28 */
    int32_t l_121 = 0xBA90E8D4;
    int32_t *l_120 = &l_121;
    int32_t **l_122 = &l_120;
    (*l_122) = l_120;
    return p_25;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_26(int32_t  p_27, struct S0  p_28, uint32_t  p_29, uint16_t  p_30)
{ /* block id: 17 */
    int32_t l_103 = 0x1421AA4D;
    int32_t *l_102 = &l_103;
    struct S1 *l_104 = (void*)0;
    l_102 = l_102;
    if ((l_104 != l_104))
    { /* block id: 19 */
        struct S1 **l_105 = &l_104;
        struct S1 l_106 = {1U,0x3408E224,-4,-8};
        struct S1 *l_107 = &l_106;
        int32_t **l_108 = &l_102;
        (*l_105) = l_104;
        (*l_107) = l_106;
        (*l_108) = &l_103;
        (*l_102) = ((*l_105) != (void*)0);
    }
    else
    { /* block id: 24 */
        int32_t l_116 = 0x936CBA86;
        struct S1 **l_117 = (void*)0;
        uint16_t l_119 = 1U;
        (*l_102) = ((int16_t)((((-1) < (((((0x9B8C56EC & (!((int16_t)(((int16_t)(65532U ^ (l_116 ^ p_29)) - (int16_t)(l_117 == ((p_27 , l_116) , ((-(uint32_t)((p_28.f1 == l_116) >= (*l_102))) , l_117)))) ^ p_30) >> (int16_t)3))) || (*l_102)) , p_29) & 1) || (*l_102))) | l_119) , p_28.f2) << (int16_t)2);
    }
    return p_28.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(uint32_t  p_32, int32_t  p_33)
{ /* block id: 13 */
    struct S0 l_81 = {0xC643,1,0,0xBED38BC6};
    struct S0 *l_80 = &l_81;
    struct S1 *l_82 = (void*)0;
    uint16_t l_86 = 0U;
    int32_t l_88 = 0xE2D1E931;
    int32_t *l_87 = &l_88;
    struct S1 l_95 = {1U,0xD8DD5847,0x06124FAE,0xB8};
    struct S0 l_98 = {8U,0xB9,3,0xFE2E886B};
    struct S0 l_99 = {0x4E17,0,2,0x09139E91};
    (*l_87) = (((l_80 != (void*)0) == ((l_82 != (void*)0) != l_81.f3)) ^ ((uint16_t)(((((-(uint32_t)(((&l_82 != &l_82) ^ p_33) != p_32)) > l_81.f1) || l_86) | 0xF5904BE6) || 0x785A) + (uint16_t)l_81.f3));
    (*l_87) = (((int16_t)((((((int16_t)(func_39((((uint16_t)(l_95 , 1U) * (uint16_t)p_33) & (*l_87)), (((int16_t)((l_95 , (void*)0) == (void*)0) % (int16_t)p_33) , func_39(p_32, (*l_80), l_98)), (*l_80)) , 4) % (int16_t)p_32) & (*l_87)) >= 0x64C2) < (*l_87)) <= p_32) * (int16_t)6U) > (*l_87));
    return l_99;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_37(struct S0  p_38)
{ /* block id: 9 */
    uint32_t l_53 = 4294967295U;
    uint32_t l_58 = 0x0E3A113D;
    struct S1 l_59 = {0x37069E5F,0xC6A002B5,0xD22F7F1C,1};
    int8_t l_62 = 0xDD;
    struct S1 *l_64 = &l_59;
    struct S1 **l_63 = &l_64;
    struct S1 *l_74 = (void*)0;
    struct S0 *l_75 = (void*)0;
    struct S0 l_77 = {0xAD5E,0xB1,1,0x57B09319};
    struct S0 *l_76 = &l_77;
    (*l_63) = ((((uint16_t)(((uint32_t)0x036C8609 - (uint32_t)(-1)) < l_53) << (uint16_t)0) <= ((int16_t)(((int16_t)(((l_58 ^ ((l_59 , (((int32_t)((l_58 , 0x6F84B879) != ((65535U || p_38.f1) | p_38.f2)) + (int32_t)0U) , l_53)) , l_59.f0)) && l_62) , l_53) - (int16_t)2) != 0x84C83B0F) % (int16_t)l_62)) , (void*)0);
    /* statement id: 10 */
    assert (l_64 == 0);
    (*l_76) = (((&l_64 == (void*)0) , ((uint32_t)((((uint16_t)0U * (uint16_t)l_59.f3) != ((int16_t)((~((&l_64 == &l_64) || (((&l_64 == &l_64) & ((((uint16_t)(l_74 == (*l_63)) * (uint16_t)0x3CC5) & 0x0CF1) == 0xF331)) == p_38.f0))) | p_38.f2) << (int16_t)p_38.f1)) >= 0xFF67D69B) - (uint32_t)p_38.f2)) , p_38);
    return l_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_39(uint32_t  p_40, struct S0  p_41, struct S0  p_42)
{ /* block id: 7 */
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_43(uint16_t  p_44, int16_t  p_45, int32_t  p_46)
{ /* block id: 4 */
    uint32_t l_47 = 0xFD7F7FFF;
    l_47 = 0;
    return l_47;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 65
   depth: 1, occurrence: 22
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 0
   indirect level: 4, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 22
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 8

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 14, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 3
   depth: 27, occurrence: 1
   depth: 32, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 82

XXX times a variable address is taken: 90
XXX times a pointer is dereferenced on RHS: 62
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 4
XXX times a pointer is dereferenced on LHS: 44
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 135

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 146
   level: 2, occurrence: 12
XXX number of pointers point to pointers: 40
XXX number of pointers point to scalars: 19
XXX number of pointers point to structs: 23
XXX percent of pointers has null in alias set: 19.5
XXX average alias set size: 1.06

XXX times a non-volatile is read: 393
XXX times a non-volatile is write: 113
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 85
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 19
   depth: 2, occurrence: 5
   depth: 3, occurrence: 12
   depth: 4, occurrence: 12
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 23.8
XXX percentage an existing variable is used: 76.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

