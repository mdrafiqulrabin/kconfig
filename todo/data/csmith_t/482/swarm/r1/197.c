/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1625751822
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   unsigned f1 : 18;
   unsigned f2 : 30;
   signed f3 : 8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_29(void);
static uint16_t  func_34(int16_t  p_35);
static int32_t  func_36(struct S0  p_37);
static struct S0  func_38(const int32_t  p_39, struct S0  p_40);
static int16_t  func_45(int16_t  p_46, const uint16_t  p_47, int16_t  p_48, uint16_t  p_49, uint16_t  p_50);
static uint32_t  func_51(int32_t  p_52, int8_t  p_53, int16_t  p_54, int8_t  p_55);
static int32_t  func_56(uint32_t  p_57);
static uint32_t  func_68(uint32_t  p_69, uint32_t  p_70, int16_t  p_71);
static int16_t  func_74(int16_t  p_75);
static struct S0  func_101(uint32_t  p_102, uint32_t  p_103, uint32_t  p_104, struct S0  p_105, int32_t  p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_29(void)
{ /* block id: 36 */
    const int8_t l_41 = 0x56L;
    struct S0 l_42 = {0x5816L,355,21456,9};
    int32_t l_608 = 0x36794B96L;
    int32_t l_609 = 0xF0830DE5L;
    int32_t l_610 = 0x9D1EA6E4L;
    l_610 = (((uint16_t)((l_609 = (((1UL != (((uint16_t)func_34((l_42.f3 = (func_36(func_38(l_41, l_42)) & 4294967291UL))) + (uint16_t)((0UL != (l_608 = 0xCE71L)) ^ 1UL)) & l_42.f2)) | 0x7C589CC4L) || l_608)) & l_42.f1) % (uint16_t)0x3204L) <= (-7L));
    l_610 = l_42.f2;
    return l_42.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_34(int16_t  p_35)
{ /* block id: 177 */
    uint32_t l_291 = 0UL;
    int32_t l_292 = 0xE7F85673L;
    int32_t l_301 = 0xAC240FB0L;
    struct S0 l_309 = {0xE445L,227,4806,-11};
    int32_t l_345 = 0x9F491A40L;
    struct S0 l_399 = {0x5DAFL,177,3807,-6};
    uint32_t l_546 = 0UL;
    const int16_t l_591 = 0x90A0L;
    for (p_35 = 0; (p_35 > (-13)); p_35 -= 1)
    { /* block id: 180 */
        int16_t l_280 = 0x598BL;
        int32_t l_303 = 0xF8D06288L;
        uint32_t l_304 = 0x6FD450B8L;
        l_292 = (0x94085A30L >= (l_280 <= (((int16_t)(p_35 | (((uint32_t)l_280 + (uint32_t)((int16_t)0x0600L % (int16_t)p_35)) >= ((!l_280) && (~(l_280 ^ l_291))))) << (int16_t)p_35) & l_291)));
        if (p_35)
            break;
        if (((int16_t)(l_291 & l_292) >> (int16_t)5))
        { /* block id: 183 */
            int32_t l_295 = 3L;
            int32_t l_302 = (-8L);
            int32_t l_305 = 0L;
            l_295 = (l_280 ^ l_280);
            l_305 &= ((uint32_t)((l_292 = 0UL) < l_280) + (uint32_t)(l_304 = func_45(p_35, (l_280 | ((l_295 = (l_303 |= __builtin_ctzl(((uint16_t)(l_280 || (l_301 |= (-(int32_t)l_295))) - (uint16_t)__builtin_clzll((l_295 > ((l_302 = l_291) >= p_35))))))) ^ l_291)), l_280, p_35, l_291)));
            if (l_292)
                continue;
        }
        else
        { /* block id: 193 */
            int32_t l_308 = 1L;
            l_301 = (func_56(l_292) != ((int16_t)(((func_36(func_101((l_308 || l_291), p_35, p_35, l_309, p_35)) != 0x6D4348F8L) && l_304) > p_35) % (int16_t)l_304));
        }
    }
    if ((~(l_292 |= p_35)))
    { /* block id: 198 */
        uint32_t l_317 = 0x980A02F6L;
        struct S0 l_318 = {6L,413,29302,5};
        l_309.f3 = ((int16_t)l_291 >> (int16_t)(func_68((l_292 ^= ((int32_t)(((int16_t)p_35 >> (int16_t)15) != p_35) + (int32_t)p_35)), (l_309.f3 && (l_317 <= (p_35 & func_36(l_318)))), p_35) == l_309.f3));
    }
    else
    { /* block id: 201 */
        int32_t l_324 = 7L;
        for (l_291 = (-9); (l_291 >= 39); l_291 += 1)
        { /* block id: 204 */
            uint16_t l_323 = 65535UL;
            l_292 &= ((int16_t)l_323 * (int16_t)0xA0CEL);
            l_324 = l_291;
            if (l_324)
                continue;
        }
    }
    if ((l_301 = (p_35 >= l_309.f1)))
    { /* block id: 211 */
        uint16_t l_344 = 3UL;
        int32_t l_366 = (-4L);
        int32_t l_367 = 0x7545660DL;
        int16_t l_370 = 0L;
        struct S0 l_395 = {2L,286,14254,3};
        for (l_291 = 24; (l_291 == 57); l_291 += 5)
        { /* block id: 214 */
            int16_t l_327 = 0xF7F7L;
            int32_t l_361 = 1L;
            int32_t l_362 = (-10L);
            struct S0 l_368 = {-7L,45,2822,2};
            int32_t l_402 = 3L;
            int16_t l_421 = 1L;
            if ((p_35 && l_327))
            { /* block id: 215 */
                int32_t l_328 = 5L;
                if (l_328)
                    break;
                if (l_327)
                    continue;
            }
            else
            { /* block id: 218 */
                uint16_t l_356 = 1UL;
                int32_t l_363 = (-2L);
                int32_t l_364 = 1L;
                struct S0 l_396 = {0xC374L,27,4633,-7};
                if (p_35)
                { /* block id: 219 */
                    int16_t l_335 = 0x664DL;
                    int32_t l_341 = 1L;
                    int32_t l_365 = 0L;
                    uint32_t l_376 = 0xBD902C90L;
                    int32_t l_394 = 0xC98B7927L;
                    if (((uint16_t)p_35 * (uint16_t)(((uint16_t)p_35 - (uint16_t)((uint32_t)(p_35 | func_51(l_335, ((p_35 ^ p_35) > ((~((int16_t)((uint16_t)p_35 >> (uint16_t)(func_51(((l_341 = 0xC6FA8E48L) < ((uint16_t)p_35 << (uint16_t)11)), p_35, p_35, l_335) && l_327)) * (int16_t)p_35)) && l_335)), l_327, p_35)) + (uint32_t)l_327)) & l_344)))
                    { /* block id: 221 */
                        int8_t l_348 = 1L;
                        int32_t l_355 = 1L;
                        l_367 = func_51((l_345 &= p_35), ((l_341 = __builtin_ffsl((p_35 < ((int16_t)l_309.f0 << (int16_t)4)))) > l_348), ((uint16_t)(l_366 = ((int32_t)(l_365 = (l_364 = func_51((l_363 = ((int16_t)(l_355 = p_35) << (int16_t)func_68((__builtin_ctzll(l_356) || (((uint16_t)((l_361 = ((int16_t)p_35 + (int16_t)0xD6ADL)) > 0xC0CEF86DL) >> (uint16_t)l_362) ^ (-5L))), p_35, p_35))), l_327, p_35, p_35))) - (int32_t)4294967292UL)) >> (uint16_t)4), l_344);
                    }
                    else
                    { /* block id: 231 */
                        l_345 = p_35;
                        l_367 |= p_35;
                        l_368 = l_368;
                    }
                    l_370 = (!l_362);
                    for (l_364 = 0; (l_364 >= 28); l_364 += 1)
                    { /* block id: 239 */
                        l_341 = ((~6UL) == (p_35 = __builtin_ctz(p_35)));
                        l_292 = p_35;
                        l_361 = p_35;
                        l_345 = ((((uint16_t)(l_363 <= 7UL) * (uint16_t)(__builtin_ffsl(l_376) < (((uint16_t)65530UL >> (uint16_t)0) <= p_35))) >= l_368.f0) > ((((int16_t)__builtin_ia32_crc32qi(l_341, ((uint16_t)__builtin_parity(((int16_t)0xC199L >> (int16_t)l_292)) << (uint16_t)4)) % (int16_t)l_356) | 0xB752L) >= 0L));
                    }
                    l_396 = func_101(((int32_t)(l_345 = (-7L)) - (int32_t)p_35), (((~((l_292 = ((uint16_t)(l_301 &= ((((uint16_t)l_356 << (uint16_t)12) ^ l_292) >= ((int16_t)__builtin_parity(p_35) << (int16_t)14))) * (uint16_t)p_35)) | l_394)) <= l_365) | 0xF8737C3FL), l_309.f2, l_395, p_35);
                }
                else
                { /* block id: 250 */
                    for (l_356 = 0; (l_356 < 8); l_356 += 7)
                    { /* block id: 253 */
                        l_399 = l_395;
                        l_395 = l_395;
                    }
                    l_396.f3 = ((uint16_t)(l_399.f3 |= p_35) << (uint16_t)p_35);
                }
                l_364 = p_35;
                l_402 ^= ((p_35 | 0L) || 1UL);
                l_309.f3 &= 0x67C957AFL;
            }
            l_292 = (((uint16_t)(p_35 || (p_35 < (l_402 = (l_361 ^= l_344)))) - (uint16_t)p_35) | ((int16_t)(!(((l_367 = ((uint16_t)65535UL + (uint16_t)((((int16_t)l_368.f3 % (int16_t)p_35) ^ p_35) ^ ((l_370 || 0x38F8L) != l_395.f1)))) != l_395.f3) | l_395.f1)) + (int16_t)l_362));
            l_345 = (l_362 ^ func_68(p_35, (((p_35 & ((uint16_t)((func_36(l_395) >= ((int32_t)(-(uint16_t)((int16_t)(p_35 >= l_367) >> (int16_t)6)) + (int32_t)4294967287UL)) >= ((uint16_t)p_35 % (uint16_t)l_421)) * (uint16_t)0L)) >= p_35) < l_327), l_291));
        }
        l_399.f3 ^= ((uint32_t)(p_35 < ((((int16_t)func_56(((((int16_t)(l_395.f3 = l_309.f1) >> (int16_t)6) ^ ((uint16_t)((((((((uint16_t)func_74(((uint32_t)func_74(((int16_t)((uint32_t)func_56(p_35) % (uint32_t)(((int16_t)(-9L) >> (int16_t)((l_301 = __builtin_ffsl(l_399.f1)) != (((l_344 ^ (l_292 = p_35)) || l_345) < 0x4804EB2AL))) && 0x8EF2L)) << (int16_t)10)) % (uint32_t)p_35)) >> (uint16_t)9) | p_35) <= l_367) | 1UL) >= p_35) ^ l_367) && l_309.f2) - (uint16_t)1UL)) || p_35)) % (int16_t)3UL) >= p_35) != p_35)) + (uint32_t)l_367);
    }
    else
    { /* block id: 274 */
        uint32_t l_444 = 0x6EF52D37L;
        const struct S0 l_460 = {-8L,412,4359,13};
        int32_t l_464 = 0x4DC5228AL;
        int32_t l_473 = 0xAADC0C72L;
        int32_t l_479 = 0L;
        l_301 ^= 0x7D8110DAL;
        if (p_35)
        { /* block id: 276 */
            int32_t l_456 = 0xDF06D251L;
            struct S0 l_461 = {0xBC9AL,290,9604,9};
            if (((l_399.f1 & (l_292 = ((int16_t)((uint16_t)65535UL * (uint16_t)((l_444 || p_35) < ((uint16_t)1UL >> (uint16_t)11))) + (int16_t)p_35))) && ((int32_t)((int32_t)((p_35 == ((int16_t)(!(0L && ((((((int16_t)__builtin_parityl(p_35) << (int16_t)l_444) <= p_35) > l_456) || p_35) == p_35))) >> (int16_t)2)) & 0x8498BCE2L) + (int32_t)2L) % (int32_t)l_456)))
            { /* block id: 278 */
                int8_t l_459 = (-8L);
                l_459 = ((int16_t)p_35 << (int16_t)5);
                l_461 = l_460;
                for (p_35 = 0; (p_35 > (-29)); p_35 -= 1)
                { /* block id: 283 */
                    int32_t l_465 = 5L;
                    l_456 = l_460.f1;
                    l_464 = (l_459 | 0x818DL);
                    if (l_460.f3)
                        break;
                    if (l_465)
                        continue;
                }
            }
            else
            { /* block id: 289 */
                uint16_t l_472 = 0x3C03L;
                uint32_t l_474 = 9UL;
                l_473 = (((int16_t)((l_464 = ((int16_t)l_309.f1 * (int16_t)p_35)) == ((uint16_t)0xD67DL + (uint16_t)0xAD62L)) << (int16_t)(func_51(p_35, l_461.f0, (l_472 &= 1L), l_399.f2) || p_35)) == p_35);
                l_461.f3 ^= 0xAF4DD614L;
                l_456 = l_474;
            }
        }
        else
        { /* block id: 296 */
            int16_t l_486 = 0xA1E5L;
            int32_t l_490 = 0xA0E6AF30L;
            uint32_t l_493 = 0x92203D50L;
            if ((l_291 | ((p_35 = p_35) && (l_473 < (0x32C6F75FL ^ p_35)))))
            { /* block id: 298 */
                uint16_t l_484 = 0x86F8L;
                int32_t l_485 = (-1L);
                l_485 &= ((((0L > 0xDD8542FDL) & ((uint32_t)l_399.f1 - (uint32_t)__builtin_popcount((((int32_t)(l_479 = (p_35 >= (0x5B70L && (1UL >= 0x228EL)))) % (int32_t)p_35) ^ ((uint16_t)(((int16_t)(p_35 || l_484) << (int16_t)l_484) == p_35) << (uint16_t)p_35))))) ^ 0UL) == p_35);
            }
            else
            { /* block id: 301 */
                struct S0 l_487 = {-1L,345,30621,-13};
                if ((0x0BB2L && l_399.f2))
                { /* block id: 302 */
                    return l_486;
                }
                else
                { /* block id: 304 */
                    l_487 = l_487;
                }
                l_490 = ((uint32_t)l_301 - (uint32_t)l_460.f0);
                l_490 = (((int16_t)func_68(p_35, (p_35 | (l_464 ^= p_35)), l_479) % (int16_t)p_35) == l_493);
                l_464 |= p_35;
            }
            return l_399.f1;
        }
        for (l_345 = 0; (l_345 != 0); l_345 += 9)
        { /* block id: 316 */
            int32_t l_508 = 0x57F123C8L;
            int32_t l_513 = 1L;
            uint32_t l_516 = 0x8096836FL;
            struct S0 l_552 = {-1L,235,28025,-8};
            for (l_301 = 0; (l_301 == (-28)); l_301 -= 1)
            { /* block id: 319 */
                uint32_t l_502 = 0UL;
                int32_t l_503 = (-10L);
                struct S0 l_517 = {0x1D64L,106,10344,-10};
                int32_t l_530 = 0xD57C4305L;
                uint16_t l_581 = 0UL;
                if ((l_503 &= (1L < ((p_35 <= (p_35 <= p_35)) < ((int32_t)((int16_t)l_502 >> (int16_t)5) + (int32_t)l_309.f3)))))
                { /* block id: 321 */
                    int8_t l_514 = 0x37L;
                    int32_t l_515 = 0L;
                    l_517 = func_38((((uint16_t)((l_460.f2 || (((uint16_t)(l_464 ^= (func_56(func_56((l_503 = ((p_35 = p_35) && (1UL && (l_508 = p_35)))))) <= ((uint32_t)((func_36(func_101(l_502, ((uint16_t)(((l_514 = (l_513 & (l_502 > 0x4A4CC17CL))) >= l_502) | 1L) * (uint16_t)0xD715L), l_515, l_309, l_473)) && l_309.f3) != l_479) - (uint32_t)l_502))) % (uint16_t)65535UL) & l_516)) > 4294967295UL) >> (uint16_t)7) > l_515), l_460);
                }
                else
                { /* block id: 328 */
                    uint16_t l_522 = 0xC655L;
                    uint32_t l_529 = 0xF544D161L;
                    int32_t l_551 = 0x9A81A796L;
                    if ((((int16_t)(((int32_t)(l_473 |= l_522) - (int32_t)((((int16_t)p_35 - (int16_t)((((p_35 >= (0xF5DE1099L ^ (l_530 = func_45((l_503 = ((uint16_t)((int16_t)p_35 * (int16_t)p_35) << (uint16_t)(l_517.f3 = p_35))), l_517.f0, l_460.f2, l_529, p_35)))) <= p_35) > p_35) >= p_35)) < 65533UL) == p_35)) >= 0xDC3EL) >> (int16_t)p_35) > p_35))
                    { /* block id: 333 */
                        int32_t l_540 = 0x559BD97DL;
                        int16_t l_545 = 3L;
                        struct S0 l_553 = {0x4DBBL,217,17269,-0};
                        l_517 = func_101(((int16_t)(l_529 && ((uint16_t)(((int16_t)(((l_513 | (l_399.f0 && 3L)) & ((int32_t)l_473 % (int32_t)(~l_540))) < ((__builtin_popcountll((((int16_t)l_540 + (int16_t)((int16_t)0x0226L << (int16_t)((l_530 = p_35) && 0xEC99L))) == 0UL)) > l_517.f0) != p_35)) % (int16_t)l_529) < p_35) << (uint16_t)3)) << (int16_t)l_508), l_545, p_35, l_309, p_35);
                        l_473 = l_546;
                        l_517 = func_38((((uint16_t)p_35 >> (uint16_t)(l_508 > l_529)) == (((int16_t)p_35 << (int16_t)(l_551 |= l_522)) & p_35)), l_552);
                        l_552 = l_553;
                    }
                    else
                    { /* block id: 340 */
                        uint16_t l_560 = 9UL;
                        int32_t l_561 = 0x79B02E24L;
                        int8_t l_562 = 1L;
                        l_292 &= ((int16_t)l_529 << (int16_t)3);
                        l_530 = func_45(((((l_399.f3 = p_35) != (l_561 = (((((int32_t)l_460.f1 + (int32_t)p_35) == (l_464 = ((func_68((l_301 ^ (l_562 ^= ((int16_t)((l_517.f3 &= ((func_36(l_460) <= func_56(l_460.f2)) >= l_560)) != 0L) + (int16_t)l_561))), p_35, l_560) <= p_35) & p_35))) || l_503) != 1L))) > p_35) ^ p_35), l_444, l_460.f0, l_444, p_35);
                        l_513 &= ((int16_t)((int32_t)((uint32_t)p_35 + (uint32_t)((int16_t)l_479 << (int16_t)4)) + (int32_t)(((p_35 >= (0x7C5DAA34L ^ p_35)) > ((int16_t)(l_464 = (((uint16_t)l_444 * (uint16_t)(((int16_t)((int32_t)((int16_t)(((l_551 = ((l_552.f3 = (l_292 = (p_35 == 0x002531C2L))) ^ l_309.f0)) > 4294967295UL) & l_560) << (int16_t)1) % (int32_t)l_560) >> (int16_t)l_552.f2) >= l_309.f3)) ^ p_35)) + (int16_t)p_35)) >= p_35)) >> (int16_t)0);
                    }
                }
                l_581 ^= (l_530 = (l_309.f3 = (0UL & 0x37709C69L)));
            }
            for (l_508 = 0; (l_508 != (-24)); l_508 -= 1)
            { /* block id: 361 */
                int32_t l_586 = 0x1595E78FL;
                l_464 &= (l_586 = (((int32_t)p_35 + (int32_t)l_552.f2) | 65535UL));
                if (l_292)
                    continue;
                if (p_35)
                    continue;
                if (p_35)
                    break;
            }
        }
    }
    if (((int32_t)(l_309.f3 = (__builtin_parityll(l_399.f3) == l_292)) - (int32_t)(__builtin_ctzll(((__builtin_parityl(p_35) ^ (l_292 <= l_301)) > (l_345 = l_546))) ^ p_35)))
    { /* block id: 372 */
        uint16_t l_592 = 1UL;
        int32_t l_599 = 0xA481F0FDL;
        l_292 = (((((int32_t)(l_591 > l_592) % (int32_t)((uint16_t)((uint16_t)((uint16_t)((l_399.f3 = ((l_599 = (0xF792L >= l_592)) > ((uint16_t)((func_51(l_592, ((int16_t)func_51(l_301, l_592, ((int16_t)(-(int16_t)(p_35 = l_309.f3)) << (int16_t)1), (l_309.f1 && l_399.f0)) << (int16_t)5), l_592, l_592) == 65535UL) > 0x27B5CDC7L) << (uint16_t)l_546))) == 1UL) + (uint16_t)l_592) >> (uint16_t)l_592) * (uint16_t)l_592)) >= l_292) ^ 0x94F150EEL) && 0xFCB3A589L);
    }
    else
    { /* block id: 377 */
        struct S0 l_607 = {0xB6CDL,340,22934,-14};
        l_309 = func_38(l_309.f2, func_38((p_35 & l_399.f2), func_101(func_36(l_607), (l_345 <= p_35), (((0x33FFL >= __builtin_ia32_crc32qi(p_35, l_292)) ^ p_35) ^ 0L), l_607, l_292)));
        return l_546;
    }
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_36(struct S0  p_37)
{ /* block id: 174 */
    uint32_t l_277 = 0UL;
    return l_277;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_38(const int32_t  p_39, struct S0  p_40)
{ /* block id: 37 */
    int32_t l_59 = 0xA13C444CL;
    int32_t l_275 = 0xF6F8DD8EL;
    struct S0 l_276 = {1L,92,13141,12};
    l_275 = ((((int16_t)func_45(p_40.f3, (func_51(func_56(p_40.f2), l_59, ((uint16_t)(l_59 < (~p_40.f0)) * (uint16_t)(!((int16_t)((uint32_t)p_40.f2 % (uint32_t)(p_40.f1 = func_68(((int16_t)p_40.f0 << (int16_t)(func_74(p_40.f3) < 0xB259L)), p_40.f0, l_59))) << (int16_t)l_59))), l_59) == 4294967291UL), p_40.f2, l_59, l_59) % (int16_t)l_59) < (-2L)) >= l_59);
    return l_276;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_45(int16_t  p_46, const uint16_t  p_47, int16_t  p_48, uint16_t  p_49, uint16_t  p_50)
{ /* block id: 122 */
    int32_t l_210 = 0x38DC3F51L;
    int32_t l_211 = 1L;
    int32_t l_212 = (-1L);
    struct S0 l_226 = {0x0374L,187,24040,-0};
    int8_t l_264 = 1L;
    l_212 ^= ((l_210 = 0x02CC8EEDL) <= (l_211 |= 0UL));
    if ((!((uint16_t)l_211 + (uint16_t)((uint32_t)p_48 % (uint32_t)((-5L) | (l_212 = ((uint16_t)l_211 % (uint16_t)65534UL)))))))
    { /* block id: 127 */
        int16_t l_220 = 0x7826L;
        int32_t l_227 = 0xF9EEAFE7L;
        struct S0 l_261 = {6L,93,16299,-12};
        uint32_t l_269 = 4294967294UL;
        int32_t l_274 = 0x44F79F7BL;
        l_212 |= l_220;
        for (p_48 = 0; (p_48 > (-16)); p_48 -= 1)
        { /* block id: 131 */
            struct S0 l_225 = {6L,448,26813,-15};
            struct S0 l_235 = {0x2A14L,500,8367,9};
            if (((uint16_t)p_49 % (uint16_t)p_49))
            { /* block id: 132 */
                l_226 = l_225;
                l_227 = l_212;
                if (p_47)
                    continue;
            }
            else
            { /* block id: 136 */
                uint32_t l_234 = 4294967293UL;
                int32_t l_238 = 0x4EF56502L;
                l_226 = func_101(l_226.f0, ((((p_46 = p_49) >= p_48) != (((((((uint32_t)p_50 % (uint32_t)((65535UL || __builtin_popcount(__builtin_clzll(p_47))) || ((int16_t)((int32_t)(l_225.f3 &= (-1L)) - (int32_t)0x9BAA4C83L) * (int16_t)(-5L)))) || (-9L)) <= l_234) && p_47) ^ l_220) == p_50)) <= 0x034DL), l_225.f2, l_235, p_47);
                l_238 &= ((l_226.f3 &= (((l_225.f3 |= (l_227 = ((int16_t)p_46 - (int16_t)l_225.f1))) <= 0x25E7L) | l_211)) || (0UL == p_48));
                if (p_50)
                    continue;
                for (l_226.f0 = 0; (l_226.f0 != (-18)); l_226.f0 -= 3)
                { /* block id: 147 */
                    uint32_t l_243 = 4294967295UL;
                    int32_t l_248 = 0x540C6107L;
                    int32_t l_260 = 0L;
                    for (l_220 = 0; (l_220 > (-11)); l_220 -= 2)
                    { /* block id: 150 */
                        return l_243;
                    }
                    l_260 |= ((((uint32_t)(l_227 < p_46) + (uint32_t)((int32_t)l_226.f2 + (int32_t)(l_248 &= p_46))) && ((int16_t)((uint16_t)(l_235.f2 <= ((uint16_t)((uint16_t)l_225.f2 - (uint16_t)(p_47 || (!((uint16_t)l_226.f0 - (uint16_t)((((p_48 & p_48) & p_49) != p_50) >= l_225.f1))))) * (uint16_t)l_238)) * (uint16_t)l_235.f2) * (int16_t)0x6F43L)) > l_243);
                }
            }
            if (l_226.f1)
            { /* block id: 157 */
                l_210 = (p_47 ^ l_226.f1);
            }
            else
            { /* block id: 159 */
                return l_212;
            }
        }
        l_226 = l_261;
        l_274 &= (__builtin_ctz(((int16_t)l_264 - (int16_t)(((uint16_t)((uint32_t)0UL - (uint32_t)(l_269 || ((((((int16_t)((l_227 = p_47) && l_220) + (int16_t)p_50) >= __builtin_parityl((l_226.f3 = ((uint16_t)1UL * (uint16_t)(l_261.f3 &= 1UL))))) == p_47) == p_48) || p_48))) << (uint16_t)12) != p_50))) <= p_48);
    }
    else
    { /* block id: 168 */
        return p_47;
    }
    return l_212;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(int32_t  p_52, int8_t  p_53, int16_t  p_54, int8_t  p_55)
{ /* block id: 65 */
    int16_t l_148 = 8L;
    int32_t l_151 = 2L;
    int32_t l_152 = 5L;
    int32_t l_153 = 0xD979A8B5L;
    struct S0 l_154 = {0x5853L,98,11877,7};
    int32_t l_173 = 0L;
    int8_t l_208 = 0x68L;
    p_52 = l_148;
    for (p_53 = (-18); (p_53 != (-5)); p_53 += 1)
    { /* block id: 69 */
        return p_55;
    }
    if (((p_53 | (l_153 = (l_148 & (1L == ((__builtin_parityl(l_148) < (l_152 = (((0x2264B8EAL == ((__builtin_parityl(l_151) != ((p_54 > 0x99B53D0EL) > p_53)) != l_148)) ^ l_151) && 0x8654D647L))) <= p_55))))) > 4294967287UL))
    { /* block id: 74 */
        struct S0 l_155 = {8L,90,26865,-6};
        l_155 = l_154;
        p_52 &= (l_155.f3 && func_74(p_53));
    }
    else
    { /* block id: 77 */
        const int32_t l_158 = 0xBB48C356L;
        int32_t l_165 = 0xCFDAD028L;
        uint32_t l_166 = 4294967287UL;
        for (l_154.f0 = 3; (l_154.f0 <= (-20)); l_154.f0 -= 1)
        { /* block id: 80 */
            if (l_158)
                break;
        }
        p_52 = ((int16_t)p_53 % (int16_t)func_56((p_54 <= ((0xD2558CD6L | ((l_166 = ((uint32_t)(__builtin_ffsl((l_154.f3 |= ((l_165 = (0x8FBBL | (((uint16_t)0xE8ACL + (uint16_t)l_158) >= (((0x3763L == (7L & (l_158 ^ l_158))) < 0xDA641284L) ^ 0x3136B179L)))) <= l_158))) | p_53) - (uint32_t)l_158)) | l_158)) != p_54))));
    }
    for (l_148 = 0; (l_148 < 9); l_148 += 1)
    { /* block id: 90 */
        int32_t l_172 = 0xA0F19388L;
        int32_t l_194 = 0x280DD1ACL;
        int32_t l_199 = (-4L);
        l_152 = l_154.f3;
        p_52 = (~(((((int16_t)1L % (int16_t)p_52) != (l_172 <= l_148)) || l_172) && l_173));
        for (l_153 = 0; (l_153 <= (-7)); l_153 -= 9)
        { /* block id: 95 */
            uint32_t l_195 = 0x96341BAEL;
            int32_t l_209 = 0xA5DD5B36L;
            for (l_172 = 0; (l_172 < (-8)); l_172 -= 1)
            { /* block id: 98 */
                const int32_t l_182 = 0L;
                int32_t l_192 = (-6L);
                for (l_152 = 0; (l_152 <= (-16)); l_152 -= 1)
                { /* block id: 101 */
                    uint32_t l_191 = 1UL;
                    int32_t l_193 = 0xD024A6B5L;
                    if (func_56(((uint32_t)(p_54 == 0x9179A281L) % (uint32_t)l_172)))
                    { /* block id: 102 */
                        int16_t l_187 = 0x6458L;
                        p_52 = l_182;
                        l_195 = func_74((l_194 |= (!(l_193 ^= (__builtin_popcountll(l_154.f0) != ((((__builtin_ia32_crc32qi(l_182, l_182) == func_68(((uint16_t)(l_192 = (((-(int16_t)((l_187 > ((p_55 & (!(p_52 = 0xF37F1D82L))) == p_54)) ^ l_191)) != l_154.f3) < 2L)) >> (uint16_t)p_54), l_182, l_172)) >= p_55) && l_172) && p_55))))));
                        p_52 = p_55;
                    }
                    else
                    { /* block id: 110 */
                        p_52 ^= (~l_192);
                    }
                }
                l_199 &= func_68((l_194 = (l_154.f0 ^ (l_172 <= ((uint16_t)l_195 - (uint16_t)((-8L) <= 4294967294UL))))), l_152, p_55);
                l_154.f3 = p_52;
            }
            l_209 ^= (((((((uint16_t)__builtin_clz(p_53) + (uint16_t)((int16_t)0xB16FL * (int16_t)0UL)) >= l_172) != ((((l_173 != ((uint16_t)(l_195 ^ (((uint16_t)p_52 - (uint16_t)(l_195 & p_54)) | p_52)) >> (uint16_t)13)) != l_172) && p_55) | (-2L))) <= 0x8E4816DBL) > l_208) <= l_172);
        }
    }
    return l_154.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_56(uint32_t  p_57)
{ /* block id: 38 */
    int32_t l_58 = 1L;
    return l_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_68(uint32_t  p_69, uint32_t  p_70, int16_t  p_71)
{ /* block id: 60 */
    uint16_t l_136 = 0UL;
    const int32_t l_142 = 0x9450AD34L;
    int32_t l_147 = 0x7AD0ED66L;
    l_147 ^= (((int32_t)((uint16_t)(~1UL) - (uint16_t)((int32_t)((int16_t)(p_69 <= (l_136 = p_69)) + (int16_t)(p_69 == ((int32_t)p_69 - (int32_t)((!((int16_t)((l_142 <= (l_142 < l_142)) > ((int16_t)((uint16_t)3UL % (uint16_t)l_142) - (int16_t)p_70)) << (int16_t)p_69)) >= l_142)))) - (int32_t)p_71)) - (int32_t)l_142) != 0x4E3A6584L);
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_74(int16_t  p_75)
{ /* block id: 40 */
    int8_t l_78 = (-3L);
    int32_t l_96 = (-7L);
    int32_t l_97 = (-7L);
    int32_t l_98 = 4L;
    int32_t l_99 = 0x8E2BB11FL;
    int32_t l_100 = 1L;
    int8_t l_111 = 0xE7L;
    struct S0 l_112 = {0x8261L,508,22785,12};
    struct S0 l_126 = {0x2C2DL,254,640,11};
    l_100 = (0UL != (func_56((l_99 = ((int16_t)l_78 - (int16_t)((l_98 = (((l_78 >= ((((((-(uint32_t)((uint16_t)((uint16_t)(func_56(l_78) != p_75) >> (uint16_t)9) * (uint16_t)(l_96 = ((uint16_t)((int16_t)l_78 - (int16_t)((((uint16_t)((int16_t)((int32_t)((uint16_t)(p_75 & p_75) >> (uint16_t)l_78) - (int32_t)0x15DBE4B2L) * (int16_t)l_78) % (uint16_t)65535UL) | 0xB667L) ^ p_75)) * (uint16_t)p_75)))) || 0xE03EB41EL) || 0x53E45BD2L) != l_97) ^ p_75) == p_75)) < l_97) != p_75)) & l_97)))) && 8L));
    l_126 = (l_112 = func_101(l_98, ((int16_t)((l_97 | l_99) < 0xE384L) * (int16_t)l_99), ((uint16_t)(l_96 &= p_75) * (uint16_t)(l_111 = l_97)), l_112, (p_75 < p_75)));
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_101(uint32_t  p_102, uint32_t  p_103, uint32_t  p_104, struct S0  p_105, int32_t  p_106)
{ /* block id: 47 */
    int16_t l_114 = 0x248FL;
    int32_t l_115 = 0x00BAF9C3L;
    int32_t l_122 = 6L;
    int32_t l_123 = 4L;
    uint32_t l_124 = 18446744073709551610UL;
    struct S0 l_125 = {-1L,188,13586,7};
    p_105.f3 = __builtin_parityll((l_124 = (l_123 = ((l_115 ^= (~l_114)) >= (p_105.f1 = ((int16_t)((6UL ^ l_114) || p_104) * (int16_t)((l_114 < (__builtin_clzl(func_56(((int16_t)((int16_t)(l_122 = (p_105.f0 = l_114)) * (int16_t)l_114) + (int16_t)l_114))) <= p_105.f3)) && 0UL)))))));
    l_125 = p_105;
    return l_125;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 134
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 24
breakdown:
   indirect level: 0, occurrence: 24
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 18
XXX times a bitfields struct on RHS: 26
XXX times a single bitfield on LHS: 25
XXX times a single bitfield on RHS: 56

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 29
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
   depth: 6, occurrence: 3
   depth: 8, occurrence: 2
   depth: 9, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 4
   depth: 18, occurrence: 4
   depth: 19, occurrence: 4
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 4
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 33, occurrence: 2
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 593
XXX times a non-volatile is write: 203
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 148
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 26
   depth: 2, occurrence: 20
   depth: 3, occurrence: 35
   depth: 4, occurrence: 17
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 20.2
XXX percentage an existing variable is used: 79.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

