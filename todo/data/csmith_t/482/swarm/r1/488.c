/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      804496286
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   int16_t  f1;
   int32_t  f2;
   uint32_t  f3;
   int32_t  f4;
   int32_t  f5;
   uint16_t  f6;
   uint16_t  f7;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int16_t  f0;
   uint16_t  f1;
   struct S0  f2;
   struct S0  f3;
   int32_t  f4;
   uint32_t  f5;
   uint16_t  f6;
   const int32_t  f7;
   uint32_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_29(void);
inline static float  func_35(uint32_t  p_36, struct S1  p_37);
static struct S1  func_42(int32_t  p_43);
static struct S0  func_45(float  p_46, struct S0  p_47);
static float  func_48(struct S0  p_49, struct S1  p_50, int32_t  p_51, uint32_t  p_52);
inline static struct S1  func_54(struct S0  p_55, struct S1  p_56, uint32_t  p_57);
inline static float  func_74(int32_t  p_75, float  p_76, struct S1  p_77, const uint16_t  p_78);
inline static int16_t  func_86(int16_t  p_87);
inline static uint32_t  func_88(struct S0  p_89, uint16_t  p_90, struct S0  p_91, struct S0  p_92);
inline static uint32_t  func_97(int16_t  p_98, struct S1  p_99, const int16_t  p_100, int32_t  p_101, float  p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_29(void)
{ /* block id: 36 */
    int16_t l_41 = 0;
    float l_518 = 0xD.6BD174p+81;
    float *l_517 = &l_518;
    struct S0 l_519 = {2U,0xC7B7,0x965E3F51,3U,0x9B78BF33,0x8A9E001D,65535U,0x6296};
    uint32_t l_526 = 0x56CB96AD;
    struct S0 *****l_534 = (void*)0;
    int32_t *l_569 = &l_519.f2;
    float l_580 = 0xC.F17FF1p+8;
    int16_t l_620 = (-8);
    struct S1 l_665 = {0x5FB6,65529U,{0x75E10AEC,0xE8DD,0xF3D6EA21,4294967295U,1,0x8CAA5D00,9U,0x1339},{0U,0,0x9DE0FE63,6U,0,0x5CBAC296,0xF3D4,0x5557},0x4475C577,0x0AB5495E,1U,0x9279E647,0x0AA1D685};
    struct S1 *l_664 = &l_665;
    int16_t l_682 = (-8);
    struct S0 *l_690 = &l_665.f3;
    struct S0 l_705 = {0U,0x6D98,1,0x11C4EC54,0xEAEA945B,0x64328CC4,0x82CA,0xA6CE};
    uint16_t l_712 = 0U;
    uint32_t l_717 = 1U;
    struct S0 l_721 = {4294967295U,0x91F0,-7,0U,0x84FCF67C,0xE2951B9C,0x1B15,0U};
    struct S0 l_751 = {4294967295U,8,0x5CCC3F5A,1U,0xEBA082E9,0x2C462A32,0x58A1,0x04E0};
    const uint32_t l_768 = 0x8C1C245F;
    uint32_t l_774 = 0xD2EA65B0;
    struct S0 ****l_786 = (void*)0;
    const struct S0 l_803 = {0xD071ABC3,0,0x7FF41631,1U,0,0xEFCB6B9C,65530U,65535U};
    int32_t l_809 = 0xC778AF80;
    uint32_t l_812 = 0xA5A833FF;
    uint32_t l_813 = 0x30CA9FDE;
    (*l_517) = (safe_add_func_float_f_f((!(safe_sub_func_float_f_f(0xC.167C28p-54, func_35((safe_rshift_func_uint16_t_u_s((!__builtin_bswap32(l_41)), 11)), func_42(l_41))))), (0x1.Ap+1 <= l_41)));
    if (l_41)
    { /* block id: 361 */
        struct S0 *l_520 = &l_519;
        int32_t *l_521 = (void*)0;
        int32_t **l_522 = (void*)0;
        int32_t **l_523 = &l_521;
        float *l_549 = &l_518;
        float l_565 = 0x0.4p+1;
        int32_t l_609 = 0x0B3BAEAD;
        (*l_520) = l_519;
        (*l_523) = l_521;
        l_519 = l_519;
        for (l_519.f5 = 28; (l_519.f5 > (-20)); l_519.f5 = safe_sub_func_uint32_t_u_u(l_519.f5, 8))
        { /* block id: 367 */
            uint32_t l_529 = 0xE293CA48;
            float *l_548 = &l_518;
            struct S1 l_556 = {-1,0x1670,{0xEFF9E391,0x9824,-4,0xE7960DF3,0x84352E30,9,0U,0xE2FB},{4294967295U,0xC0E0,0xF3CAAF55,4294967290U,0x98416EB6,0xE9F1E18D,0x2BDD,0x7A6F},1,0x6E034033,0xA31C,0xDF713FBC,4294967295U};
            if (((l_519.f2 ^ l_526) && (safe_rshift_func_int16_t_s_u(l_529, 5))))
            { /* block id: 368 */
                struct S0 **l_533 = &l_520;
                struct S0 ***l_532 = &l_533;
                struct S0 ****l_531 = &l_532;
                struct S0 *****l_530 = &l_531;
                l_534 = l_530;
                /* statement id: 369 */
                assert (l_534 == &l_531);
            }
            else
            { /* block id: 370 */
                float l_539 = 0x1.5CBACCp-72;
                int32_t l_540 = 0x8BB0D9AF;
                float l_544 = 0x0.4p-1;
                struct S0 l_564 = {0x25AEC113,-7,-5,0x73F3C82E,6,1,0x35AF,0x2BE4};
                const uint32_t l_574 = 4294967287U;
                int32_t *****l_595 = (void*)0;
                const struct S0 *l_601 = (void*)0;
                const struct S0 **l_600 = &l_601;
                const struct S0 ***l_599 = &l_600;
                const struct S0 ****l_598 = &l_599;
                int32_t *l_626 = (void*)0;
                uint32_t l_629 = 4294967292U;
                if ((safe_sub_func_int32_t_s_s(3, (safe_mod_func_int16_t_s_s(l_540, ((l_529 >= (!65535U)) ^ ((safe_lshift_func_uint16_t_u_u(l_540, l_540)) ^ ((safe_rshift_func_int16_t_s_u(l_529, l_540)) ^ (safe_unary_minus_func_uint16_t_u((l_548 == l_549)))))))))))
                { /* block id: 371 */
                    uint32_t l_555 = 9U;
                    struct S0 l_563 = {9U,0x43A1,0xD9B18EC9,0x7C94A8C7,0x708A86E5,5,0xED95,1U};
                    for (l_526 = (-27); (l_526 > 11); l_526 = safe_add_func_int16_t_s_s(l_526, 1))
                    { /* block id: 374 */
                        int32_t *l_552 = &l_519.f2;
                        struct S0 l_554 = {4294967290U,2,-1,9U,-8,1,0x6881,0x7EBC};
                        struct S0 *l_553 = &l_554;
                        (*l_552) = l_540;
                        (*l_553) = l_519;
                        (*l_523) = (*l_523);
                        return l_540;
                    }
                    if (l_555)
                    { /* block id: 380 */
                        uint32_t l_557 = 0U;
                        l_556.f4 = func_97(__builtin_popcountl(l_529), l_556, l_556.f3.f5, l_556.f8, l_557);
                        if (l_557)
                            break;
                        (*l_549) = (safe_div_func_float_f_f(0x2.350340p-64, ((0x1.1p-1 <= l_557) < (safe_div_func_float_f_f(0x4.4p-1, l_555)))));
                    }
                    else
                    { /* block id: 384 */
                        float l_562 = 0x8.0C6CBEp-26;
                        int32_t *l_566 = &l_564.f5;
                        l_540 = func_88((*l_520), l_556.f2.f0, func_45(l_540, l_563), l_564);
                        (*l_566) = l_564.f2;
                    }
                    for (l_556.f3.f4 = 26; (l_556.f3.f4 != (-1)); l_556.f3.f4 = safe_sub_func_uint32_t_u_u(l_556.f3.f4, 1))
                    { /* block id: 390 */
                        uint16_t l_570 = 0x7C0E;
                        l_569 = (void*)0;
                        /* statement id: 391 */
                        assert (l_569 == 0);
                        (*l_523) = (void*)0;
                        /* statement id: 392 */
                        assert (l_521 == 0);
                        return l_570;
                    }
                }
                else
                { /* block id: 395 */
                    struct S0 **l_573 = &l_520;
                    struct S0 ***l_572 = &l_573;
                    struct S0 ****l_571 = &l_572;
                    int32_t l_579 = 0x589C2640;
                    if (l_564.f3)
                    { /* block id: 396 */
                        (*l_548) = ((l_556.f3.f4 >= (l_571 != (void*)0)) < (l_574 < ((*l_569) >= ((safe_sub_func_float_f_f(((safe_sub_func_float_f_f(l_579, (*l_569))) > l_580), (((*l_569) > l_564.f1) < 0x0.9p-1))) == l_556.f2.f5))));
                        return l_556.f5;
                    }
                    else
                    { /* block id: 399 */
                        int32_t *l_581 = &l_564.f2;
                        (*l_523) = l_581;
                        /* statement id: 400 */
                        assert (l_521 == &l_564.f2);
                        return l_564.f3;
                    }
                }
                (*l_569) = (l_564.f6 < (l_564.f0 & (safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(0x3FB3, 1)), l_564.f2))));
                if ((l_556.f3.f6 & (safe_add_func_int32_t_s_s((!(0 >= (safe_add_func_uint32_t_u_u(((safe_mod_func_uint16_t_u_u(__builtin_ia32_crc32qi((*l_569), ((l_564.f7 <= (*l_569)) == (*l_569))), l_556.f2.f0)) >= (safe_sub_func_int16_t_s_s(((l_595 == l_595) && l_556.f5), 1U))), (*l_569))))), (*l_569)))))
                { /* block id: 405 */
                    (*l_523) = l_548;
                    /* statement id: 406 */
                    assert (l_521 == &l_518);
                    if ((safe_rshift_func_uint16_t_u_s(__builtin_bswap32((*l_569)), 4)))
                    { /* block id: 407 */
                        struct S0 ****l_603 = (void*)0;
                        struct S0 *****l_602 = &l_603;
                        (*l_602) = l_598;
                        /* statement id: 408 */
                        assert (l_603 == &l_599);
                        if ((*l_521))
                            break;
                    }
                    else
                    { /* block id: 410 */
                        const struct S1 **l_604 = (void*)0;
                        struct S1 *l_606 = (void*)0;
                        struct S1 **l_605 = &l_606;
                        int32_t *l_607 = (void*)0;
                        struct S0 *l_608 = &l_556.f3;
                        (*l_605) = &l_556;
                        /* statement id: 411 */
                        assert (l_606 == &l_556);
                        l_607 = l_548;
                        /* statement id: 412 */
                        assert (l_607 == &l_518);
                        (*l_608) = l_519;
                        if (l_609)
                            continue;
                    }
                    (*l_523) = l_548;
                    for (l_564.f5 = 0; (l_564.f5 > (-4)); l_564.f5 = safe_sub_func_int16_t_s_s(l_564.f5, 1))
                    { /* block id: 419 */
                        const int32_t *l_612 = &l_519.f2;
                        int32_t **l_613 = &l_521;
                        (*l_613) = l_612;
                        /* statement id: 420 */
                        assert (l_521 == &l_519.f2);
                        (*l_613) = (*l_613);
                        (*l_523) = (*l_613);
                    }
                    /* facts after for loop */
                    assert (l_521 == &l_519.f2 || l_521 == &l_518);
                }
                else
                { /* block id: 424 */
                    struct S0 ***l_614 = (void*)0;
                    struct S0 ****l_615 = &l_614;
                    const int32_t *l_616 = &l_564.f2;
                    int32_t **l_617 = &l_521;
                    (*l_615) = l_614;
                    (*l_617) = l_616;
                    /* statement id: 426 */
                    assert (l_521 == &l_564.f2);
                }
                /* facts after branching */
                assert (l_521 == &l_564.f2 || l_521 == &l_519.f2 || l_521 == &l_518);
                if ((*l_569))
                { /* block id: 428 */
                    uint16_t l_623 = 65526U;
                    struct S0 ***l_630 = (void*)0;
                    for (l_556.f2.f7 = (-22); (l_556.f2.f7 <= 38); ++l_556.f2.f7)
                    { /* block id: 431 */
                        struct S0 *l_624 = (void*)0;
                        struct S0 *l_625 = &l_556.f3;
                        (*l_625) = func_45((l_620 >= ((0x0.0EBFF9p-2 != 0x3.Dp+1) >= (safe_sub_func_float_f_f(l_623, 0x2.7C3976p-88)))), l_556.f3);
                        (*l_523) = l_548;
                        /* statement id: 433 */
                        assert (l_521 == &l_518);
                        (*l_523) = l_626;
                        /* statement id: 434 */
                        assert (l_521 == 0);
                    }
                    /* facts after for loop */
                    assert (l_521 == 0 || l_521 == &l_564.f2 || l_521 == &l_519.f2 || l_521 == &l_518);
                    (*l_569) = (safe_div_func_int16_t_s_s(((l_556.f3.f3 | 4294967295U) <= (((*l_569) >= l_629) != (l_630 == (*l_598)))), l_623));
                    return l_564.f5;
                }
                else
                { /* block id: 438 */
                    (*l_523) = l_569;
                    /* statement id: 439 */
                    assert (l_521 == &l_519.f2);
                }
                /* facts after branching */
                assert (l_521 == &l_519.f2);
            }
            /* facts after branching */
            assert (l_521 == &l_519.f2 || l_521 == &l_518 || l_521 == 0);
            //assert (l_534 == 0 || l_534 == dangling);
            return l_556.f3.f1;
        }
        /* facts after for loop */
        assert (l_521 == &l_518 || l_521 == 0);
    }
    else
    { /* block id: 444 */
        int32_t l_631 = (-1);
        struct S0 *l_655 = &l_519;
        int32_t *l_662 = &l_519.f2;
        int32_t l_691 = 0;
        uint32_t l_706 = 8U;
        (*l_569) = ((l_631 < l_631) ^ (((l_631 | l_631) > 0xED7E58EB) != (__builtin_ffsll((*l_569)) != l_631)));
        if ((safe_unary_minus_func_uint32_t_u(0x369EEDF2)))
        { /* block id: 446 */
            uint16_t l_645 = 65535U;
            int32_t ***l_650 = (void*)0;
            int32_t ****l_649 = &l_650;
            struct S0 *****l_654 = (void*)0;
            struct S1 l_698 = {0,0U,{1U,0x27FC,0,2U,0xACE615C6,0xBB7E86EB,0xEB83,7U},{0x159AE8C5,7,9,0xC66F8F3F,0x6257DEB8,0x27173528,0xCA9A,1U},0xB328D89F,4U,0U,1,0xC686DF6D};
            for (l_519.f0 = 0; (l_519.f0 >= 19); ++l_519.f0)
            { /* block id: 449 */
                (*l_569) = l_631;
            }
            if ((safe_rshift_func_int16_t_s_s((l_631 < ((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s(((*l_569) == (~(safe_lshift_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u(l_645)), 13)))), 1)), 0)) && 0x2EB337CD)), 11)))
            { /* block id: 452 */
                (*l_517) = (*l_569);
            }
            else
            { /* block id: 454 */
                int32_t ****l_648 = (void*)0;
                struct S0 *l_659 = (void*)0;
                struct S1 l_685 = {1,0xABC7,{4294967287U,-1,0xCEF482F4,0U,-9,0x4C1C43ED,0x9BF2,0xC34A},{0x3FA584CA,0xED48,0xE4F80C50,0xE746CE92,0xE03A8FD3,0x70A81D2B,1U,0x9D81},1,0x7974A775,0xEC9D,1,4294967293U};
                struct S0 ***l_697 = (void*)0;
                struct S0 ****l_696 = &l_697;
                struct S0 *****l_695 = &l_696;
                if ((((safe_sub_func_uint32_t_u_u((l_648 == l_649), (!((safe_lshift_func_uint16_t_u_s((l_654 == (void*)0), 5)) || (*l_569))))) == (*l_569)) > 0xD39F))
                { /* block id: 455 */
                    struct S0 *l_656 = &l_519;
                    int32_t **l_657 = &l_569;
                    l_656 = l_655;
                    (*l_657) = (void*)0;
                    /* statement id: 457 */
                    assert (l_569 == 0);
                    return l_645;
                }
                else
                { /* block id: 459 */
                    uint16_t l_658 = 0xDA48;
                    struct S1 l_667 = {0x5EF8,0x184B,{0xA50376E8,0x2756,5,4294967291U,0xD5DC5EC1,5,65535U,65535U},{0x7CFF1D20,-10,1,4294967291U,0xAAF3E70F,-9,0x1720,0x43A2},6,0x82B98851,1U,0xC113D872,0U};
                    struct S1 *l_666 = &l_667;
                    struct S0 *l_681 = &l_519;
                    if ((func_86(l_631) > (0U < l_658)))
                    { /* block id: 460 */
                        return l_631;
                    }
                    else
                    { /* block id: 462 */
                        struct S0 **l_660 = (void*)0;
                        struct S0 **l_661 = &l_659;
                        int32_t **l_663 = &l_662;
                        (*l_661) = l_659;
                        l_662 = l_517;
                        /* statement id: 464 */
                        assert (l_662 == &l_518);
                        (*l_661) = l_659;
                        (*l_663) = &l_631;
                        /* statement id: 466 */
                        assert (l_662 == &l_631);
                    }
                    /* facts after branching */
                    assert (l_662 == &l_631);
                    l_666 = l_664;
                    /* statement id: 468 */
                    assert (l_666 == &l_665);
                    if ((safe_sub_func_int32_t_s_s((safe_unary_minus_func_int16_t_s(((safe_rshift_func_int16_t_s_u((safe_add_func_uint32_t_u_u((*l_662), (safe_div_func_uint16_t_u_u((*l_662), l_667.f4)))), (func_86((*l_662)) != (((((safe_rshift_func_int16_t_s_u((*l_569), ((safe_sub_func_uint32_t_u_u(((void*)0 == l_681), (l_667.f3.f5 == (*l_569)))) == l_682))) <= 6) >= l_645) >= 0U) >= 8U)))) != (*l_662)))), (*l_662))))
                    { /* block id: 469 */
                        int32_t *l_683 = (void*)0;
                        l_683 = &l_631;
                        /* statement id: 470 */
                        assert (l_683 == &l_631);
                    }
                    else
                    { /* block id: 471 */
                        uint16_t l_684 = 0x7A6B;
                        int32_t *l_692 = &l_665.f4;
                        const int32_t *l_694 = &l_519.f5;
                        const int32_t **l_693 = &l_694;
                        l_667.f2.f2 = (((-1) < (0x1E7B >= l_684)) != __builtin_clzll(func_97((*l_569), l_685, (0x9F048060 > (~(safe_mod_func_int32_t_s_s((safe_unary_minus_func_int16_t_s(l_667.f3.f3)), ((((void*)0 != l_690) == 0) | (*l_662)))))), l_691, (*l_569))));
                        (*l_693) = l_692;
                        /* statement id: 473 */
                        assert (l_694 == &l_665.f4);
                    }
                    (*l_655) = (*l_681);
                }
                /* facts after branching */
                assert (l_662 == &l_631);
                (*l_517) = ((((*l_662) < (*l_569)) <= func_97((*l_662), (*l_664), func_97(func_97(((&l_665 == (void*)0) | (l_695 != (void*)0)), l_698, (*l_662), (*l_569), (*l_662)), l_698, (*l_662), (*l_569), (*l_662)), l_698.f2.f7, (*l_569))) <= (*l_662));
            }
            /* facts after branching */
            assert (l_662 == &l_631 || l_662 == &l_519.f2);
            (*l_662) = 5;
            if (((0xF1A5 <= ((0x4473 & 2U) > (safe_div_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s((safe_div_func_int16_t_s_s(func_88((*l_655), ((void*)0 != (*l_649)), (*l_655), func_45((*l_662), l_705)), l_706)), 0)), (*l_569))))) < (*l_662)))
            { /* block id: 480 */
                int32_t **l_707 = &l_662;
                struct S0 **l_708 = (void*)0;
                struct S0 **l_709 = &l_655;
                (*l_707) = l_569;
                /* statement id: 481 */
                assert (l_662 == &l_519.f2);
                (*l_709) = l_655;
                (*l_569) = ((safe_div_func_float_f_f((__builtin_clzll(l_712) < ((func_35((*l_662), func_42(((*l_662) ^ (~(*l_569))))) > (**l_707)) == (safe_add_func_float_f_f(l_645, (*l_569))))), (*l_569))) >= (**l_707));
                return l_698.f3.f2;
            }
            else
            { /* block id: 485 */
                int32_t **l_716 = &l_569;
                (*l_716) = &l_631;
                /* statement id: 486 */
                assert (l_569 == &l_631);
                return l_717;
            }
        }
        else
        { /* block id: 489 */
            int32_t l_718 = 0;
            return l_718;
        }
    }
    for (l_665.f0 = 0; (l_665.f0 != (-23)); --l_665.f0)
    { /* block id: 495 */
        struct S0 *l_734 = (void*)0;
        int32_t l_738 = (-8);
        int32_t **l_793 = &l_569;
        int32_t ***l_792 = &l_793;
        int32_t ****l_791 = &l_792;
        int32_t *****l_790 = &l_791;
        float **l_800 = &l_517;
        struct S0 l_804 = {1U,0xDFE2,0xBA838C3A,4294967286U,-1,6,1U,0x78F3};
        (*l_690) = l_721;
    }
    (*l_569) = func_97(((*l_569) & (((((*l_569) > (((*l_569) ^ (safe_sub_func_int32_t_s_s((*l_569), (*l_569)))) ^ (*l_569))) <= (safe_rshift_func_uint16_t_u_u((l_809 ^ ((safe_sub_func_uint32_t_u_u(0x95082ACF, 0xD25CD283)) == l_812)), (*l_569)))) && (*l_569)) != 0xF5B08BEF)), (*l_664), (*l_569), (*l_569), (*l_569));
    return l_813;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_35(uint32_t  p_36, struct S1  p_37)
{ /* block id: 357 */
    uint32_t l_516 = 0x5823A4E5;
    l_516 = 0xD.082741p+60;
    return p_37.f2.f7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_42(int32_t  p_43)
{ /* block id: 37 */
    struct S0 l_58 = {0x40B48CF4,0xDB98,0x6F533643,0xD1FF0D8C,0xEF010E39,-9,0x2E2B,65529U};
    float l_356 = 0x0.9BD0C1p-7;
    int32_t *l_399 = (void*)0;
    uint16_t l_411 = 65531U;
    struct S1 l_424 = {0,1U,{4294967292U,0x8710,0xFC94C86A,0U,-9,0xA067A929,65529U,0x4457},{1U,0,0xB30D3B8A,4294967295U,0x15082380,-7,9U,0x671B},9,0xF5BB7B7C,0xD884,0x14807CDD,0x351F5493};
    int32_t l_476 = 4;
    int16_t l_478 = (-10);
    struct S0 *l_495 = (void*)0;
    if ((6 == 0x7552))
    { /* block id: 38 */
        uint16_t l_44 = 0x8B0E;
        struct S0 l_376 = {4294967295U,0xB0ED,0x579F25EF,1U,0x5EA743C6,0x1F9E3980,65530U,0x67F2};
        struct S0 **l_390 = (void*)0;
        struct S0 ***l_389 = &l_390;
        struct S0 ****l_388 = &l_389;
        struct S1 l_396 = {-4,0U,{0x8FC2743B,0x8FD9,0x90654CEB,1U,6,0xBC69C0E0,0U,0xC6BD},{0x988AC1D1,4,-2,4294967288U,0x812D2855,0,0x76A1,0x8DAF},-2,0U,65529U,1,4294967291U};
        int32_t *l_431 = &l_396.f4;
        int32_t *****l_475 = (void*)0;
        if (l_44)
        { /* block id: 39 */
            struct S0 l_53 = {0xEB906A33,0x9760,0,4294967294U,0x940870E2,-1,1U,1U};
            struct S1 l_59 = {-1,0xCAF2,{4294967295U,1,0xF612F8B8,0xD3E15E87,0x612420E0,1,0U,0U},{4294967286U,-7,0x0BAD3991,0U,-2,0,0xDC1C,7U},-1,1U,0x3EDA,2,1U};
            struct S0 *l_349 = &l_59.f3;
            int32_t *l_350 = (void*)0;
            int32_t *l_351 = &l_58.f5;
            struct S1 *l_427 = &l_59;
            struct S1 **l_426 = &l_427;
            int32_t **l_432 = (void*)0;
            int32_t **l_433 = &l_431;
            (*l_349) = func_45(((0x0.6p-1 < 0x0.8p-1) >= func_48(l_53, func_54(l_58, l_59, p_43), p_43, ((safe_sub_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((l_59.f1 && 1U) || 0xAAEF2588), p_43)), p_43)) <= p_43))), l_59.f2);
            (*l_351) = p_43;
            for (l_59.f3.f1 = (-14); (l_59.f3.f1 >= 4); l_59.f3.f1 = safe_add_func_uint32_t_u_u(l_59.f3.f1, 2))
            { /* block id: 239 */
                uint32_t l_367 = 5U;
                struct S0 l_379 = {0x4CDE09AD,0x4547,5,9U,0xC50531CE,6,0xC3FD,65535U};
                struct S1 l_387 = {0x3F0D,4U,{0x06FA5281,7,2,0xED909E15,-1,0x17AF3AFF,7U,0xF3AE},{5U,0,8,4294967286U,0x47C771FB,0,0xB0E7,0x246F},0x89A40DE4,4294967294U,7U,0,0x23A8BB8F};
                int32_t *l_421 = &l_376.f5;
                uint32_t l_423 = 4U;
                struct S1 **l_428 = &l_427;
                for (l_58.f2 = 3; (l_58.f2 <= 27); l_58.f2 = safe_add_func_uint32_t_u_u(l_58.f2, 4))
                { /* block id: 242 */
                    uint32_t l_375 = 4294967287U;
                    if ((p_43 || (safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_u(l_367, 5)), (safe_div_func_int32_t_s_s((__builtin_ctzll(l_367) & (4294967295U & p_43)), (safe_lshift_func_uint16_t_u_u((!(safe_mod_func_uint16_t_u_u(1U, ((((l_367 | 0x54DAA023) == 0x3B4D32A0) <= p_43) | l_375)))), l_375)))))), p_43)), 8)), l_58.f1))))
                    { /* block id: 243 */
                        struct S0 *l_377 = &l_376;
                        (*l_377) = func_45(p_43, l_376);
                    }
                    else
                    { /* block id: 245 */
                        int32_t **l_378 = &l_350;
                        struct S0 *l_380 = &l_59.f2;
                        (*l_351) = __builtin_ctz(p_43);
                        (*l_378) = l_350;
                        (*l_380) = l_379;
                        (*l_380) = func_45(p_43, l_58);
                    }
                }
                if ((safe_lshift_func_int16_t_s_u(l_367, func_86(p_43))))
                { /* block id: 252 */
                    struct S0 *l_383 = (void*)0;
                    struct S0 *l_384 = &l_59.f2;
                    (*l_384) = (*l_349);
                    for (l_379.f6 = 28; (l_379.f6 > 46); l_379.f6 = safe_add_func_uint16_t_u_u(l_379.f6, 7))
                    { /* block id: 256 */
                        return l_387;
                    }
                    if (l_58.f6)
                        break;
                }
                else
                { /* block id: 260 */
                    struct S0 *****l_391 = &l_388;
                    float *l_393 = &l_356;
                    (*l_391) = l_388;
                    (*l_393) = (-p_43);
                    if ((!0xE4E9))
                    { /* block id: 263 */
                        int32_t **l_395 = &l_351;
                        (*l_395) = l_351;
                        if ((**l_395))
                            break;
                    }
                    else
                    { /* block id: 266 */
                        return l_396;
                    }
                }
                if (l_387.f3.f6)
                    continue;
                if (p_43)
                { /* block id: 271 */
                    struct S0 l_417 = {0x644768A7,8,0,0x6AEC9CB5,1,0xB8D36B13,1U,0x3F81};
                    float *l_418 = (void*)0;
                    float *l_419 = (void*)0;
                    float *l_420 = &l_356;
                    for (l_387.f2.f6 = 0; (l_387.f2.f6 == 58); l_387.f2.f6 = safe_add_func_int16_t_s_s(l_387.f2.f6, 1))
                    { /* block id: 274 */
                        int32_t **l_400 = (void*)0;
                        int32_t **l_401 = &l_350;
                        (*l_401) = l_399;
                    }
                    for (l_396.f8 = 0; (l_396.f8 != 1); l_396.f8 = safe_add_func_int32_t_s_s(l_396.f8, 1))
                    { /* block id: 279 */
                        float *l_404 = &l_356;
                        (*l_404) = p_43;
                    }
                    (*l_420) = (safe_add_func_float_f_f((safe_div_func_float_f_f(0x6.Bp-1, (((safe_div_func_float_f_f(l_411, (p_43 < func_88(func_45((!(!(p_43 != (-(p_43 > (safe_div_func_float_f_f((l_387.f8 >= l_367), p_43))))))), l_387.f2), p_43, l_387.f3, l_417)))) != 0x4.38F79Cp+11) > 0x3.Dp-1))), 0x3.1p-1));
                }
                else
                { /* block id: 283 */
                    int32_t **l_422 = &l_421;
                    struct S0 l_425 = {1U,0,7,2U,-7,0x3101D57B,0U,0x12F0};
                    float *l_430 = &l_356;
                    (*l_422) = l_421;
                    if (func_88((*l_349), l_423, (*l_349), l_58))
                    { /* block id: 285 */
                        return l_424;
                    }
                    else
                    { /* block id: 287 */
                        struct S0 *l_429 = &l_424.f2;
                        l_425 = l_424.f3;
                        l_428 = l_426;
                        (*l_429) = (*l_349);
                    }
                    (*l_430) = 0x1.5p+1;
                    l_431 = l_421;
                    /* statement id: 293 */
                    assert (l_431 == &l_376.f5);
                }
            }
            /* facts after for loop */
            assert (l_431 == &l_376.f5 || l_431 == &l_396.f4);
            (*l_433) = l_431;
        }
        else
        { /* block id: 297 */
            int32_t **l_434 = (void*)0;
            int32_t **l_435 = &l_399;
            (*l_435) = l_431;
            /* statement id: 298 */
            assert (l_399 == &l_396.f4);
        }
        /* facts after branching */
        assert (l_399 == &l_396.f4 || l_399 == 0);
        assert (l_431 == &l_376.f5 || l_431 == &l_396.f4);
        for (l_58.f6 = 25; (l_58.f6 >= 27); l_58.f6 = safe_add_func_uint16_t_u_u(l_58.f6, 1))
        { /* block id: 302 */
            uint32_t l_443 = 1U;
            struct S0 l_444 = {0x2716E575,0x612F,0xD4EFF098,7U,-6,0x9B5946CD,0x42EA,0xEFF7};
            (*l_431) = ((safe_add_func_int32_t_s_s(func_88(l_424.f3, p_43, l_376, l_396.f3), (~(safe_lshift_func_int16_t_s_u((func_88(func_45(l_443, func_45((*l_431), l_444)), (*l_431), l_444, l_424.f2) <= p_43), 4))))) ^ p_43);
            if (p_43)
                break;
            for (l_376.f0 = 18; (l_376.f0 <= 42); l_376.f0 = safe_add_func_uint32_t_u_u(l_376.f0, 9))
            { /* block id: 307 */
                struct S1 l_451 = {7,65527U,{0x5F415CF0,-2,0x3D26581A,4294967295U,7,0,0x4B10,0xE8A3},{4294967295U,7,0,0x6DF4C2B6,0x213FEFA5,8,0xE01C,9U},-1,0xA4A1E1C0,1U,0x4ED3264F,0x5712B69B};
                struct S0 *l_452 = &l_396.f3;
                const struct S0 *l_454 = &l_424.f2;
                const struct S0 **l_453 = &l_454;
                int32_t *l_455 = (void*)0;
                int32_t **l_456 = &l_455;
                for (l_424.f3.f3 = (-10); (l_424.f3.f3 > 10); l_424.f3.f3 = safe_add_func_uint16_t_u_u(l_424.f3.f3, 1))
                { /* block id: 310 */
                    int32_t *l_449 = (void*)0;
                    if (p_43)
                    { /* block id: 311 */
                        int32_t **l_450 = &l_399;
                        (*l_450) = l_449;
                        /* statement id: 312 */
                        assert (l_399 == 0);
                    }
                    else
                    { /* block id: 313 */
                        return l_451;
                    }
                    /* facts after branching */
                    assert (l_399 == 0);
                    return l_424;
                }
                (*l_453) = l_452;
                /* statement id: 318 */
                assert (l_454 == &l_396.f3);
                if (l_444.f3)
                    continue;
                (*l_456) = l_455;
            }
        }
        (*l_431) = 3;
        for (l_424.f6 = 0; (l_424.f6 <= 26); l_424.f6 = safe_add_func_uint16_t_u_u(l_424.f6, 8))
        { /* block id: 326 */
            int32_t l_474 = (-7);
            struct S0 l_477 = {0xCD9679E9,0xFD71,7,0x9AF3D454,0xA5633EEF,0xE23A1A34,0x220F,0xC064};
            struct S1 **l_489 = (void*)0;
            for (l_424.f2.f7 = 0; (l_424.f2.f7 == 42); ++l_424.f2.f7)
            { /* block id: 329 */
                const int32_t l_479 = 0xCE6DC7AB;
                struct S1 l_496 = {0x4CA6,0xF462,{1U,0xE39B,0,0x90229A3F,-8,0,1U,0x080C},{0x45BFA676,-6,0,0x34478A63,-6,0x981903FA,0xC956,0x871B},0x6F6FBDC2,0U,3U,1,0x1F3662B9};
                uint32_t l_497 = 1U;
                int32_t **l_498 = &l_399;
            }
        }
    }
    else
    { /* block id: 350 */
        struct S1 *l_504 = &l_424;
        struct S1 **l_503 = &l_504;
        int32_t *l_505 = (void*)0;
        int32_t *l_506 = &l_58.f2;
        int32_t **l_507 = &l_505;
        struct S0 l_508 = {0x8C3E8DC0,0xAAD5,0x0F9FA8FC,0xCB0CD7BF,0x7F1B7FD7,1,0x29D8,0U};
        struct S0 *l_509 = &l_508;
        float *l_515 = &l_356;
        (*l_506) = (((safe_sub_func_int32_t_s_s(p_43, ((safe_lshift_func_uint16_t_u_u(p_43, (l_399 != l_399))) ^ (p_43 > p_43)))) & ((void*)0 != l_503)) ^ p_43);
        (*l_507) = l_399;
        (*l_509) = func_45(p_43, l_508);
        (*l_515) = (p_43 >= ((p_43 > ((safe_sub_func_float_f_f(p_43, (((p_43 == (((!p_43) == p_43) == (-0x1.Ep-1))) >= (p_43 <= ((safe_add_func_float_f_f((0x1.9p-1 < p_43), p_43)) == 0x7.8261ACp+66))) < 0x0.4p+1))) > p_43)) > p_43));
    }
    /* facts after branching */
    //assert (l_399 == dangling || l_399 == 0);
    return l_424;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_45(float  p_46, struct S0  p_47)
{ /* block id: 231 */
    int32_t l_347 = 0x9FFA29DB;
    int32_t *l_346 = &l_347;
    int32_t **l_348 = &l_346;
    (*l_348) = l_346;
    (*l_348) = (*l_348);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_48(struct S0  p_49, struct S1  p_50, int32_t  p_51, uint32_t  p_52)
{ /* block id: 222 */
    struct S0 l_339 = {1U,0xA12F,0x1405FE5E,0x5823CA98,-1,0xD8ACD933,0x80CA,1U};
    struct S0 *l_338 = &l_339;
    struct S0 **l_342 = &l_338;
    struct S0 ***l_341 = &l_342;
    struct S0 ****l_340 = &l_341;
    struct S0 *****l_343 = &l_340;
    int32_t *l_344 = &l_339.f5;
    (*l_338) = p_49;
    (*l_343) = l_340;
    if (((void*)0 != l_344))
    { /* block id: 225 */
        int32_t *l_345 = &l_339.f5;
        l_345 = (void*)0;
        /* statement id: 226 */
        assert (l_345 == 0);
    }
    else
    { /* block id: 227 */
        return p_50.f2.f0;
    }
    return p_50.f2.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_54(struct S0  p_55, struct S1  p_56, uint32_t  p_57)
{ /* block id: 40 */
    uint32_t l_65 = 0x1F3D14E5;
    struct S1 l_79 = {1,1U,{1U,9,8,4294967292U,-1,-5,0xFE33,0x04BD},{0x658E48FE,0x42C1,4,0U,-6,0x8979A2FC,3U,0x8EFA},0,4294967295U,0x46B7,0,3U};
    int32_t l_331 = 0x2B700E47;
    float l_333 = 0xB.067A72p-72;
    float *l_332 = &l_333;
    (*l_332) = ((safe_div_func_float_f_f((safe_div_func_float_f_f(((!(__builtin_ffsl(l_65) >= 0x1.Bp-1)) >= (safe_sub_func_float_f_f((safe_div_func_float_f_f(l_65, (safe_add_func_float_f_f(p_56.f3.f2, l_65)))), p_56.f4))), (safe_add_func_float_f_f(l_65, func_74(l_65, l_65, l_79, l_79.f3.f3))))), l_331)) == p_56.f3.f4);
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_74(int32_t  p_75, float  p_76, struct S1  p_77, const uint16_t  p_78)
{ /* block id: 41 */
    int32_t l_103 = (-8);
    struct S1 l_104 = {0xA9BA,65526U,{4294967290U,0x39E3,0xF4042E0B,1U,5,0,0xAE0F,1U},{4294967295U,7,1,0x26836565,-1,0xA631AE8C,0U,2U},0x95C3721E,0x19B7F543,1U,0x358AC2E3,4294967295U};
    int32_t *l_265 = &l_104.f3.f5;
    int32_t **l_272 = &l_265;
    int32_t ***l_271 = &l_272;
    int32_t ****l_270 = &l_271;
    struct S0 *l_284 = &l_104.f2;
    struct S0 **l_283 = &l_284;
    struct S0 ***l_282 = &l_283;
    struct S0 ****l_281 = &l_282;
    (*l_265) = (safe_lshift_func_int16_t_s_s((safe_div_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(func_86((func_88(p_77.f3, (safe_sub_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u(0U, func_97(l_103, l_104, l_104.f7, (safe_mod_func_uint32_t_u_u(l_104.f3.f3, p_78)), (p_77.f2.f0 != p_77.f4)))), l_104.f8)), p_77.f2, l_104.f3) || p_77.f2.f1)), l_104.f8)), l_104.f5)), 0));
    for (l_104.f5 = 0; (l_104.f5 != 10); l_104.f5 = safe_add_func_int16_t_s_s(l_104.f5, 5))
    { /* block id: 182 */
        int32_t ****l_273 = &l_271;
        uint16_t l_303 = 1U;
        const int32_t l_307 = (-1);
        struct S0 **l_308 = &l_284;
        const int32_t *l_311 = &l_104.f3.f5;
        if ((safe_lshift_func_int16_t_s_s((l_270 == l_273), 9)))
        { /* block id: 183 */
            struct S0 l_294 = {0x1AFA0B42,0x693B,0x0FBF4B7D,0x3398E590,0x066BD959,0xFA45CCDE,65535U,65532U};
            for (l_104.f3.f5 = 10; (l_104.f3.f5 != 22); l_104.f3.f5 = safe_add_func_int16_t_s_s(l_104.f3.f5, 2))
            { /* block id: 186 */
                int32_t l_280 = 0x1EB0C2D3;
                if (((safe_lshift_func_int16_t_s_u(p_77.f1, 9)) > (***l_271)))
                { /* block id: 187 */
                    if (p_77.f3.f7)
                        break;
                }
                else
                { /* block id: 189 */
                    float l_278 = (-0x1.1p-1);
                    float *l_285 = &l_278;
                    struct S0 l_304 = {4294967295U,0xD750,0,0xF115D831,0x1C496369,-4,65529U,0xDFE8};
                    if (p_77.f3.f5)
                        break;
                    (*l_285) = (func_97((~__builtin_popcountll(__builtin_ctzl(l_280))), p_77, (func_88(p_77.f2, (p_77.f4 != ((void*)0 == l_281)), p_77.f3, p_77.f2) & p_77.f3.f6), p_77.f3.f4, p_77.f2.f3) != p_77.f7);
                    (*l_285) = ((safe_add_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f(0x0.5p+1, ((safe_div_func_float_f_f((func_88(l_294, (0xA5CE > (((safe_rshift_func_int16_t_s_s((p_77.f3.f4 != (safe_lshift_func_uint16_t_u_s((safe_div_func_int32_t_s_s(__builtin_ffsll(l_280), 0x27CEEB1F)), 5))), (((p_77.f4 ^ (0x7E5EE16E > (****l_270))) != l_303) >= 0U))) == (****l_273)) & l_280)), l_304, p_77.f2) != 0x1.0p+1), 0x0.949B4Fp-97)) <= l_280))), p_77.f0)), l_304.f7)) < l_294.f1);
                    if (((****l_273) > (p_77.f3.f1 && (*l_265))))
                    { /* block id: 193 */
                        struct S1 *l_305 = &l_104;
                        struct S1 **l_306 = &l_305;
                        if (p_77.f2.f7)
                            break;
                        (*l_285) = (****l_273);
                        (***l_273) = &p_75;
                        /* statement id: 196 */
                        assert (l_265 == &p_75);
                        (*l_306) = l_305;
                    }
                    else
                    { /* block id: 198 */
                        p_77.f3.f5 = l_307;
                        if ((****l_273))
                            continue;
                    }
                }
                l_308 = l_308;
                p_77.f2.f5 = (l_280 == ((safe_rshift_func_int16_t_s_s(p_77.f2.f2, 5)) >= func_86(p_77.f3.f4)));
            }
        }
        else
        { /* block id: 206 */
            const int32_t *l_312 = &l_104.f2.f5;
            p_77.f3 = p_77.f2;
            l_312 = l_311;
            /* statement id: 208 */
            assert (l_312 == &l_104.f3.f5);
            (*l_272) = (***l_273);
        }
    }
    /* facts after for loop */
    assert (l_265 == &l_104.f3.f5 || l_265 == &p_75);
    if ((safe_mod_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_u((safe_add_func_int32_t_s_s(((***l_271) <= 0x2CE3), 2)), 6)) > (9 < (safe_mod_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_u(((-3) < ((*l_270) == (*l_270))), (***l_271))), func_86(((((safe_rshift_func_int16_t_s_s((((*l_265) || p_77.f3.f4) | 1U), 5)) > 0U) & p_77.f4) <= p_77.f2.f0)))))), p_77.f3.f2)))
    { /* block id: 212 */
        int32_t l_327 = (-8);
        (***l_270) = (void*)0;
        /* statement id: 213 */
        assert (l_265 == 0);
        return l_327;
    }
    else
    { /* block id: 215 */
        uint32_t l_328 = 0x8C2101A9;
        float l_330 = (-0x2.Cp+1);
        float *l_329 = &l_330;
        (*l_329) = __builtin_ctz(l_328);
        (***l_281) = (***l_281);
    }
    return p_77.f2.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_86(int16_t  p_87)
{ /* block id: 176 */
    struct S0 l_264 = {4294967290U,0xB348,0x6A7DB87A,0x18BF5C90,0x43986B91,0xD2C7DCD8,65528U,0x77C6};
    l_264 = l_264;
    return l_264.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_88(struct S0  p_89, uint16_t  p_90, struct S0  p_91, struct S0  p_92)
{ /* block id: 173 */
    struct S0 l_263 = {4294967295U,0x7D9B,3,4294967295U,-1,0xF539B985,65526U,3U};
    struct S0 *l_262 = &l_263;
    (*l_262) = p_91;
    return p_89.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_97(int16_t  p_98, struct S1  p_99, const int16_t  p_100, int32_t  p_101, float  p_102)
{ /* block id: 42 */
    int32_t l_119 = 0x764965E8;
    uint32_t l_153 = 0xD880B63D;
    uint32_t l_158 = 0U;
    struct S0 l_189 = {0U,-1,0,0x36551C80,0x2B85DA36,0xD0BCE42B,0U,0xDD10};
    const int32_t *l_192 = &l_189.f2;
    int32_t ****l_238 = (void*)0;
    int32_t *****l_237 = &l_238;
    int16_t l_255 = 0xBD36;
    float l_261 = 0x2.F02C76p-25;
    float *l_260 = &l_261;
    for (p_99.f6 = 2; (p_99.f6 == 36); p_99.f6 = safe_add_func_uint32_t_u_u(p_99.f6, 2))
    { /* block id: 45 */
        struct S0 l_130 = {0xFD4B7166,0x76FC,0xB737966B,0x488C446E,-10,6,0x2C5D,0x37E4};
        struct S0 *l_129 = &l_130;
        int32_t *l_173 = &l_119;
        int32_t **l_172 = &l_173;
        for (p_99.f2.f4 = 0; (p_99.f2.f4 < (-23)); p_99.f2.f4 = safe_sub_func_int32_t_s_s(p_99.f2.f4, 1))
        { /* block id: 48 */
            int32_t *l_113 = (void*)0;
            struct S0 l_117 = {0x26FF3246,1,1,0x037A74CF,2,0x310F39FE,0U,0xB42C};
            struct S0 l_126 = {4294967289U,0xCB23,0,0x169F9908,0x0AE38097,0x268E8976,0x197A,0x7A6A};
            for (p_99.f4 = 0; (p_99.f4 < 13); p_99.f4 = safe_add_func_uint16_t_u_u(p_99.f4, 2))
            { /* block id: 51 */
                const int32_t l_116 = 0xF79D74A7;
                const int32_t *l_115 = &l_116;
                const int32_t **l_114 = &l_115;
                struct S0 *l_118 = &l_117;
                (*l_114) = l_113;
                /* statement id: 52 */
                assert (l_115 == 0);
                (*l_118) = l_117;
                if (l_119)
                { /* block id: 54 */
                    const struct S0 *l_124 = (void*)0;
                    int32_t l_125 = 0;
                    for (p_99.f3.f2 = (-8); (p_99.f3.f2 != 8); p_99.f3.f2 = safe_add_func_int16_t_s_s(p_99.f3.f2, 1))
                    { /* block id: 57 */
                        p_99.f3.f5 = (safe_sub_func_uint16_t_u_u(((void*)0 != l_124), l_125));
                        return p_99.f2.f2;
                    }
                    (*l_114) = &p_101;
                    /* statement id: 61 */
                    assert (l_115 == &p_101);
                    if (l_119)
                        break;
                }
                else
                { /* block id: 63 */
                    (*l_114) = l_113;
                    (*l_118) = l_126;
                    p_99.f3.f5 = (((safe_lshift_func_int16_t_s_s(p_99.f2.f0, 6)) || ((void*)0 == l_129)) < 1);
                    return p_99.f3.f1;
                }
                /* facts after branching */
                assert (l_115 == &p_101);
            }
            for (p_99.f2.f2 = 0; (p_99.f2.f2 <= 2); p_99.f2.f2 = safe_add_func_uint16_t_u_u(p_99.f2.f2, 1))
            { /* block id: 72 */
                int32_t *l_140 = &l_117.f5;
                (*l_140) = ((l_119 & (65535U > (p_99.f3.f0 != (safe_div_func_int32_t_s_s(l_119, __builtin_ffsl((((!4294967295U) && l_126.f1) & (((safe_sub_func_int32_t_s_s(0xCC71544C, (safe_sub_func_uint16_t_u_u(l_130.f6, p_99.f6)))) < l_119) > 1U)))))))) && p_99.f8);
                (*l_129) = p_99.f3;
                for (l_117.f0 = 0; (l_117.f0 <= 22); l_117.f0 = safe_add_func_int32_t_s_s(l_117.f0, 1))
                { /* block id: 77 */
                    uint32_t l_143 = 4294967295U;
                    return l_143;
                }
            }
        }
        for (l_130.f1 = (-4); (l_130.f1 < (-5)); l_130.f1 = safe_sub_func_uint32_t_u_u(l_130.f1, 7))
        { /* block id: 84 */
            float l_154 = 0x7.3p-1;
            int32_t l_157 = 0x666C7403;
            int32_t *l_171 = (void*)0;
            int32_t **l_170 = &l_171;
            struct S0 l_198 = {0x92B98E86,0x8CED,-1,0U,1,0xE4655062,0x834D,65528U};
            const int32_t ****l_226 = (void*)0;
            struct S0 ***l_229 = (void*)0;
            struct S0 ****l_228 = &l_229;
            if ((safe_add_func_uint16_t_u_u(__builtin_parityl((p_99.f3.f3 <= (safe_add_func_uint16_t_u_u(((((l_119 ^ (safe_sub_func_uint16_t_u_u((!(l_153 && 0xE207E3EB)), ((void*)0 != &l_130)))) >= p_99.f3.f3) || (safe_add_func_int32_t_s_s(0x154488EE, l_157))) <= 0x78E50C8B), l_153)))), l_158)))
            { /* block id: 85 */
                float l_169 = 0x4.E549EAp-2;
                int32_t l_174 = 6;
                int32_t ***l_181 = &l_172;
                struct S0 *l_182 = &l_130;
                struct S0 **l_183 = (void*)0;
                struct S0 **l_184 = &l_129;
                if ((safe_lshift_func_int16_t_s_s((safe_sub_func_int32_t_s_s(p_99.f2.f5, (safe_rshift_func_int16_t_s_u(((safe_add_func_int32_t_s_s(p_99.f3.f4, ((safe_mod_func_int32_t_s_s(l_158, 0x535910C0)) < (0 < p_99.f2.f3)))) == ((l_170 == l_172) ^ l_174)), 8)))), p_99.f3.f7)))
                { /* block id: 86 */
                    (*l_172) = &p_101;
                    /* statement id: 87 */
                    assert (l_173 == &p_101);
                    (*l_172) = (*l_172);
                }
                else
                { /* block id: 89 */
                    int32_t *l_177 = &l_130.f2;
                    for (p_99.f3.f1 = 0; (p_99.f3.f1 != 24); p_99.f3.f1 = safe_add_func_uint16_t_u_u(p_99.f3.f1, 8))
                    { /* block id: 92 */
                        (*l_172) = l_177;
                        /* statement id: 93 */
                        assert (l_173 == &l_130.f2);
                        return l_153;
                    }
                    if (((safe_add_func_uint16_t_u_u((__builtin_bswap32((l_153 && p_101)) != p_99.f2.f4), (&l_119 == &p_101))) ^ p_99.f2.f0))
                    { /* block id: 96 */
                        (*l_172) = &p_101;
                        /* statement id: 97 */
                        assert (l_173 == &p_101);
                        (*l_172) = &p_101;
                    }
                    else
                    { /* block id: 99 */
                        int32_t ****l_180 = (void*)0;
                        (*l_170) = &p_101;
                        /* statement id: 100 */
                        assert (l_171 == &p_101);
                        l_181 = &l_172;
                    }
                    /* facts after branching */
                    assert (l_171 == &p_101 || l_171 == 0);
                }
                /* facts after branching */
                assert (l_171 == &p_101 || l_171 == 0);
                (*l_184) = l_182;
                for (l_130.f2 = 0; (l_130.f2 <= (-29)); l_130.f2 = safe_sub_func_int16_t_s_s(l_130.f2, 8))
                { /* block id: 107 */
                    int32_t l_190 = 1;
                    int32_t **l_193 = &l_171;
                    (*l_170) = &p_101;
                    /* statement id: 108 */
                    assert (l_171 == &p_101);
                    p_99.f2 = (*l_129);
                    if ((***l_181))
                    { /* block id: 110 */
                        struct S0 ***l_187 = &l_184;
                        struct S0 ****l_188 = &l_187;
                        (*l_188) = l_187;
                        l_189 = (*l_129);
                        (*l_173) = p_99.f2.f7;
                        if (l_190)
                            continue;
                    }
                    else
                    { /* block id: 115 */
                        int32_t l_191 = 9;
                        (*l_173) = (l_191 < 65529U);
                    }
                    (*l_193) = l_192;
                    /* statement id: 118 */
                    assert (l_171 == &p_101 || l_171 == &l_189.f2);
                }
                /* facts after for loop */
                assert (l_171 == &l_189.f2 || l_171 == &p_101 || l_171 == 0);
            }
            else
            { /* block id: 120 */
                int32_t **l_194 = &l_171;
                int32_t ***l_195 = (void*)0;
                int32_t ***l_196 = (void*)0;
                int32_t ***l_197 = &l_194;
                struct S0 l_212 = {0U,6,0xDBE3E01D,1U,0x69FC2604,0x929319AF,2U,0xCCEC};
                (*l_197) = l_194;
                p_99.f2 = l_198;
                if ((safe_rshift_func_uint16_t_u_u(0x6180, 8)))
                { /* block id: 123 */
                    int32_t l_205 = 4;
                    struct S0 **l_217 = &l_129;
                    struct S0 ***l_216 = &l_217;
                    if ((safe_rshift_func_int16_t_s_u((safe_add_func_int16_t_s_s((p_98 <= (((((**l_172) < p_99.f2.f5) ^ 0xA000A43A) || p_99.f6) || (((l_205 | (safe_lshift_func_uint16_t_u_s(p_99.f3.f5, (safe_lshift_func_uint16_t_u_s(p_99.f3.f0, 15))))) > p_99.f3.f4) <= (-5)))), (*l_173))), 14)))
                    { /* block id: 124 */
                        float *l_210 = (void*)0;
                        int32_t l_211 = (-7);
                        struct S0 *l_213 = &l_198;
                        struct S0 ***l_218 = &l_217;
                        float l_223 = 0x0.60F239p-33;
                        int16_t l_224 = 0x0661;
                        int32_t ****l_225 = &l_197;
                        float *l_227 = &l_223;
                        l_211 = 0x2.77D41Cp-93;
                        (*l_213) = l_212;
                        (*l_227) = (safe_sub_func_float_f_f(((l_216 != l_218) == (safe_add_func_float_f_f((safe_div_func_float_f_f((__builtin_popcountl(l_224) > p_99.f8), p_99.f2.f4)), (l_225 == l_226)))), 0x1.01AE27p-31));
                        (*l_227) = ((void*)0 == l_228);
                    }
                    else
                    { /* block id: 129 */
                        l_192 = &p_101;
                        /* statement id: 130 */
                        assert (l_192 == &p_101);
                    }
                }
                else
                { /* block id: 132 */
                    return p_99.f2.f5;
                }
            }
            /* facts after branching */
            assert (l_171 == &l_189.f2 || l_171 == &p_101 || l_171 == 0);
            for (p_99.f4 = 0; (p_99.f4 > (-25)); p_99.f4 = safe_sub_func_int32_t_s_s(p_99.f4, 7))
            { /* block id: 138 */
                struct S0 l_239 = {0x211F6D28,-1,-2,4294967295U,-1,0,0x15EE,1U};
                struct S0 **l_259 = &l_129;
            }
        }
        /* facts after for loop */
        assert (l_173 == &l_119 || l_173 == &p_101);
    }
    /* facts after for loop */
    assert (l_192 == &p_101 || l_192 == &l_189.f2);
    (*l_260) = p_100;
    return p_99.f2.f7;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 181
   depth: 1, occurrence: 29
   depth: 2, occurrence: 11
XXX total union variables: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 308
   depth: 2, occurrence: 36
   depth: 3, occurrence: 9
   depth: 4, occurrence: 2
   depth: 5, occurrence: 5
   depth: 7, occurrence: 5
   depth: 8, occurrence: 3
   depth: 9, occurrence: 3
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 5
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 225

XXX times a variable address is taken: 194
XXX times a pointer is dereferenced on RHS: 128
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 5
   depth: 3, occurrence: 6
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 141
breakdown:
   depth: 1, occurrence: 133
   depth: 2, occurrence: 2
   depth: 3, occurrence: 4
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 507

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 338
   level: 2, occurrence: 31
   level: 3, occurrence: 33
   level: 4, occurrence: 36
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 128
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 39
XXX percent of pointers has null in alias set: 25.3
XXX average alias set size: 1.16

XXX times a non-volatile is read: 881
XXX times a non-volatile is write: 380
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 252
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 24
   depth: 2, occurrence: 24
   depth: 3, occurrence: 38
   depth: 4, occurrence: 60
   depth: 5, occurrence: 77

XXX percentage a fresh-made variable is used: 24.9
XXX percentage an existing variable is used: 75.1
********************* end of statistics **********************/

