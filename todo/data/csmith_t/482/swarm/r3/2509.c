/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1977705420
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const uint32_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = 0x3AA9AC70;
static const int32_t g_38 = 1;
static const int32_t *g_37 = &g_38;
static int32_t g_50 = 0x995F7626;
static struct S0 g_60 = {0x0509B955};
static float g_111 = 0x1.F2ABA0p-17;
static int32_t *g_114 = (void*)0;
static int32_t ***g_117 = (void*)0;
static int32_t g_134 = 0xF70E0EEE;
static int32_t g_215 = 0x5094A51A;
static float *g_280 = &g_111;
static float **g_279 = &g_280;
static float g_306 = 0x7.B97F85p-38;
static float ***g_332 = &g_279;
static float ****g_331 = &g_332;
static float *****g_330 = &g_331;
static struct S0 g_372 = {4294967294U};
static uint32_t g_456 = 0xBA3EB5A4;
static struct S0 **g_473 = (void*)0;
static float ***g_490 = &g_279;
static uint32_t g_575 = 0xCCA17D6D;
static int32_t *g_719 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_26(void);
static const int32_t * func_29(int32_t  p_30);
static struct S0  func_31(const int32_t * p_32, float  p_33, int32_t  p_34, uint32_t  p_35, int32_t * p_36);
static float  func_44(int32_t * p_45, int32_t * p_46, int32_t * p_47, struct S0  p_48);
static int32_t * func_52(float  p_53);
static float  func_54(int16_t  p_55, int32_t * p_56, uint32_t  p_57);
static struct S0  func_71(int32_t * p_72, int32_t * p_73, int32_t * p_74, int32_t  p_75, int32_t * p_76);
static int32_t * func_77(int16_t  p_78, int16_t  p_79);
static uint32_t  func_80(uint32_t  p_81);
static int16_t  func_82(const uint32_t  p_83, int32_t * p_84, uint32_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_50 g_38 g_37 g_215 g_60.f0 g_372.f0 g_456 g_280 g_111 g_332 g_279
 * writes: g_8 g_111 g_50 g_719
 */
static struct S0  func_26(void)
{ /* block id: 36 */
    int32_t l_41 = 9;
    int32_t *l_49 = &g_50;
    float l_61 = 0x9.8491F1p+25;
    float ****l_411 = &g_332;
    float l_413 = 0x2.3p-1;
    float l_425 = 0x8.Dp-1;
    int32_t l_450 = 0x9F912CC4;
    const struct S0 l_538 = {0U};
    uint32_t l_596 = 0U;
    float l_598 = (-0x1.1p+1);
    float l_689 = 0xB.DA5228p-31;
    uint32_t l_725 = 0x9D5CAE73;
    uint32_t l_728 = 7U;
    int32_t l_729 = 0xADEE50C0;
    struct S0 ***l_739 = (void*)0;
    for (g_8 = 0; (g_8 == (-30)); g_8 -= 1)
    { /* block id: 39 */
        int32_t *l_51 = &g_50;
        struct S0 l_314 = {9U};
        int16_t l_373 = 0xCC21;
        const int32_t **l_402 = &g_37;
        int16_t l_426 = (-1);
        uint32_t l_429 = 1U;
        int16_t l_458 = 0;
        struct S0 ***l_486 = &g_473;
        uint32_t l_495 = 0x8AD68520;
        int32_t l_496 = 0x24322C28;
        int32_t **l_528 = (void*)0;
        int32_t l_577 = 0;
        int32_t l_582 = 6;
        float l_583 = 0x4.336E16p-70;
        int16_t l_599 = 2;
        uint16_t l_645 = 0x92DE;
        uint32_t l_667 = 6U;
        struct S0 l_695 = {0xCB9DB35F};
        float l_714 = 0x0.4p-1;
        int32_t l_720 = 0xFD2DB94D;
    }
    if (func_80((((uint16_t)g_8 + (uint16_t)(*l_49)) , (l_725 != (((int16_t)(*l_49) >> (int16_t)(0 < (l_728 != g_38))) >= l_729)))))
    { /* block id: 289 */
        float l_730 = 0x0.3D3078p-7;
        struct S0 ***l_740 = &g_473;
        int32_t l_741 = 1;
        if ((*g_37))
        { /* block id: 290 */
            struct S0 l_731 = {4294967295U};
            return l_731;
        }
        else
        { /* block id: 292 */
            (*l_49) = (*l_49);
        }
        for (l_41 = 0; (l_41 <= (-21)); l_41 -= 1)
        { /* block id: 297 */
            int32_t *l_734 = &g_50;
            int32_t **l_735 = (void*)0;
            int32_t **l_736 = (void*)0;
            g_719 = l_734;
        }
        (*l_49) = (g_215 , ((((((*g_37) && (((uint16_t)0xA9F9 >> (uint16_t)15) && ((((g_60.f0 , (g_8 , ((0xDB38DEF3 != 0x7CF76BF0) & g_372.f0))) ^ ((l_739 != l_740) , l_741)) | g_456) >= l_741))) , (-1)) , g_8) , (*l_49)) < 0x93468359));
    }
    else
    { /* block id: 301 */
        (***g_332) = (*g_280);
    }
    return l_538;
}


/* ------------------------------------------ */
/* 
 * reads : g_114
 * writes: g_50 g_114
 */
static const int32_t * func_29(int32_t  p_30)
{ /* block id: 174 */
    int32_t *l_400 = &g_50;
    int32_t **l_401 = &g_114;
    (*l_400) = (p_30 ^ p_30);
    (*l_401) = func_52(p_30);
    return (*l_401);
}


/* ------------------------------------------ */
/* 
 * reads : g_134 g_280 g_111 g_215 g_37 g_38
 * writes: g_134 g_111 g_114
 */
static struct S0  func_31(const int32_t * p_32, float  p_33, int32_t  p_34, uint32_t  p_35, int32_t * p_36)
{ /* block id: 157 */
    float l_383 = 0x2.Fp+1;
    int32_t l_389 = 0x21015027;
    struct S0 l_399 = {3U};
    for (g_134 = 7; (g_134 >= (-5)); g_134 -= 5)
    { /* block id: 160 */
        int32_t l_378 = 0;
        struct S0 *l_379 = &g_60;
        struct S0 **l_380 = &l_379;
        (*g_280) = ((float)(*g_280) - (float)(((l_378 != 0x6.5F7930p+75) > 0xF.AA1A88p-23) >= 0xC.2E1F7Fp-58));
        (*l_380) = l_379;
        (*g_280) = (*g_280);
        (*g_280) = 0x7.8p-1;
    }
    for (p_35 = 0; (p_35 >= 13); p_35 += 5)
    { /* block id: 168 */
        const uint16_t l_384 = 0xC6F8;
        struct S0 *l_388 = &g_60;
        struct S0 **l_387 = &l_388;
        int32_t *l_396 = (void*)0;
        uint16_t l_397 = 0x2F1C;
        int32_t **l_398 = &g_114;
        (*p_36) = l_384;
        (*l_398) = func_77(g_215, ((uint16_t)p_35 * (uint16_t)((l_387 != ((l_389 >= ((((uint32_t)l_384 % (uint32_t)((int16_t)((g_215 & ((uint16_t)l_384 >> (uint16_t)l_384)) | (func_71(p_36, p_36, p_36, l_384, l_396) , l_397)) * (int16_t)1U)) , 0xE3B4EDD3) <= (*g_37))) , (void*)0)) < 0U)));
        if ((*p_36))
            continue;
    }
    return l_399;
}


/* ------------------------------------------ */
/* 
 * reads : g_38 g_134 g_114 g_50 g_330 g_8 g_215 g_60.f0 g_280 g_111
 * writes: g_279 g_134 g_114 g_50 g_111
 */
static float  func_44(int32_t * p_45, int32_t * p_46, int32_t * p_47, struct S0  p_48)
{ /* block id: 130 */
    float ***l_315 = &g_279;
    int32_t *l_322 = &g_50;
    (*l_315) = (void*)0;
    if ((g_38 > 0U))
    { /* block id: 132 */
        int32_t **l_320 = &g_114;
        uint32_t l_340 = 1U;
        struct S0 l_346 = {0xFC0C68FD};
        uint16_t l_351 = 1U;
        for (g_134 = 0; (g_134 < 21); g_134 += 4)
        { /* block id: 135 */
            int32_t *l_333 = (void*)0;
            if (((&p_47 != (p_48.f0 , l_320)) & (**l_320)))
            { /* block id: 136 */
                const uint32_t l_321 = 0xA174F5C3;
                (*l_320) = (func_71((l_321 , (*l_320)), &g_134, l_322, ((uint16_t)((int32_t)(((((*p_46) , ((-(int16_t)(p_48.f0 , 1)) | ((((int16_t)0x14D7 >> (int16_t)((void*)0 != g_330)) ^ g_134) && (*p_45)))) <= (**l_320)) , g_50) , (*g_114)) + (int32_t)0x4F4403A9) * (uint16_t)l_321), p_45) , l_333);
                return p_48.f0;
            }
            else
            { /* block id: 139 */
                (*l_320) = (*l_320);
            }
        }
        (*l_322) = __builtin_popcount((**l_320));
        p_47 = func_77((*l_322), ((int16_t)((int16_t)(((int16_t)(l_340 == (*l_322)) << (int16_t)9) , ((~((uint16_t)(((*g_114) < (((**l_320) || (g_134 , func_80((*l_322)))) < ((int16_t)((((l_346 , 1U) == p_48.f0) , g_50) , (**l_320)) + (int16_t)g_215))) , (*l_322)) << (uint16_t)5)) | (**l_320))) >> (int16_t)3) / (int16_t)(**l_320)));
        (**l_320) = ((int16_t)((int16_t)(__builtin_popcount((*l_322)) ^ func_80((**l_320))) + (int16_t)((**l_320) <= (((1U < 3U) > ((**l_320) >= p_48.f0)) ^ g_50))) << (int16_t)l_351);
    }
    else
    { /* block id: 146 */
        float l_366 = (-0x1.Ap+1);
        int32_t l_367 = 0;
        struct S0 **l_369 = (void*)0;
        struct S0 **l_370 = (void*)0;
        struct S0 *l_371 = &g_372;
        for (g_50 = 26; (g_50 == (-4)); g_50 -= 1)
        { /* block id: 149 */
            int32_t l_365 = 0x3D4BFED7;
            int32_t **l_368 = (void*)0;
            l_322 = func_52(((p_48.f0 < ((p_48.f0 , ((float)(((float)(((__builtin_ctzll((((~(((g_60.f0 & func_80(((((uint16_t)0x4765 >> (uint16_t)5) , g_50) | ((1 && (((uint16_t)p_48.f0 % (uint16_t)0xDFEE) , ((((((int16_t)p_48.f0 << (int16_t)g_60.f0) , l_365) , l_365) != g_60.f0) <= p_48.f0))) != (*g_114))))) ^ p_48.f0) | (-6))) | g_8) | 0x3A83041F)) != l_367) >= l_365) , l_365) - (float)(-0x10.0p+1)) >= l_367) - (float)p_48.f0)) == (-0x3.Ap-1))) >= p_48.f0));
            if ((*p_45))
                continue;
        }
        l_371 = (void*)0;
        return (*g_280);
    }
    return p_48.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_114
 * writes: g_114
 */
static int32_t * func_52(float  p_53)
{ /* block id: 127 */
    int32_t l_311 = (-1);
    uint32_t l_312 = 0xCB4272C5;
    int32_t **l_313 = &g_114;
    (*l_313) = func_77(l_311, (l_312 <= 5U));
    return (*l_313);
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_37 g_38 g_60 g_8 g_114 g_117 g_134 g_111 g_215 g_279 g_280 g_306
 * writes: g_50 g_111 g_114 g_117 g_134
 */
static float  func_54(int16_t  p_55, int32_t * p_56, uint32_t  p_57)
{ /* block id: 40 */
    uint32_t l_86 = 0xB5CF6354;
    float l_141 = 0x0.2p+1;
    int32_t l_165 = (-1);
    int32_t **l_168 = (void*)0;
    int32_t ***l_167 = &l_168;
    uint32_t l_214 = 1U;
    int32_t l_220 = 0xCE77D404;
    int16_t l_245 = 0;
    struct S0 *l_297 = &g_60;
    float l_307 = 0x6.1p-1;
    for (p_57 = 19; (p_57 > 54); p_57 += 6)
    { /* block id: 43 */
        uint32_t l_113 = 4294967288U;
        const int32_t *l_120 = &g_50;
        const int32_t **l_127 = (void*)0;
        const int32_t ***l_126 = &l_127;
        int32_t *l_191 = &g_50;
        if ((((uint16_t)3U % (uint16_t)((int32_t)(p_57 >= ((int32_t)0xAA9D707D - (int32_t)p_57)) + (int32_t)(~(func_71(func_77(p_57, (p_55 == func_80((func_82((l_86 , l_86), &g_50, l_86) , l_86)))), p_56, p_56, l_113, g_114) , p_57)))) == 0xE514))
        { /* block id: 56 */
            int32_t ****l_118 = (void*)0;
            int32_t ****l_119 = &g_117;
            const int32_t **l_121 = &l_120;
            (*l_119) = g_117;
            (*l_121) = l_120;
        }
        else
        { /* block id: 59 */
            uint32_t l_142 = 0xE53D9B4D;
            const int32_t ***l_188 = &l_127;
            int32_t *l_192 = &g_50;
            int16_t l_193 = 0x38B7;
            (*p_56) = ((int32_t)((65532U ^ ((int32_t)(l_126 != &l_127) % (int32_t)((uint32_t)4294967295U - (uint32_t)func_80(g_38)))) > (p_57 | (g_8 <= p_55))) % (int32_t)l_86);
            for (g_50 = 0; (g_50 >= 26); g_50 += 1)
            { /* block id: 63 */
                int32_t *l_132 = (void*)0;
                int32_t *l_133 = &g_134;
                struct S0 l_166 = {0U};
                float *l_174 = &l_141;
                float **l_173 = &l_174;
                (*l_133) = l_86;
                if (__builtin_popcountll(((((((float)(func_71(func_77(g_60.f0, p_55), l_133, func_77((((int16_t)((p_57 , (__builtin_ffsl(g_50) != p_57)) ^ ((int16_t)g_38 % (int16_t)p_57)) / (int16_t)0x79D8) , g_134), g_38), p_57, l_132) , (*l_120)) + (float)g_50) , g_134) >= l_142) , 0U) < 1)))
                { /* block id: 65 */
                    int32_t **l_149 = &g_114;
                    (*l_149) = ((((uint16_t)((0x87FF9E38 == ((*l_120) >= (((l_86 <= (((uint32_t)g_134 + (uint32_t)4) & ((uint16_t)((*p_56) , 0x5926) * (uint16_t)g_60.f0))) == ((*g_114) & (-5))) , (*p_56)))) ^ (*l_120)) << (uint16_t)g_134) , (*p_56)) , p_56);
                }
                else
                { /* block id: 67 */
                    uint32_t l_158 = 2U;
                    float ***l_175 = &l_173;
                    if (((uint16_t)65528U % (uint16_t)((uint16_t)((l_142 > g_50) ^ (((uint16_t)p_57 << (uint16_t)4) && ((uint32_t)l_158 / (uint32_t)((int16_t)((((g_50 == g_38) == (((l_86 , ((((int16_t)((uint16_t)p_55 - (uint16_t)0x677A) << (int16_t)8) >= l_86) , (void*)0)) != p_56) || l_158)) || (*g_37)) <= g_60.f0) / (int16_t)0x8075)))) * (uint16_t)l_165)))
                    { /* block id: 68 */
                        float *l_171 = (void*)0;
                        float *l_172 = &g_111;
                        (*l_172) = (((g_117 != (l_166 , l_167)) ^ ((uint16_t)p_55 << (uint16_t)10)) , (*l_120));
                    }
                    else
                    { /* block id: 70 */
                        p_56 = func_77((*l_133), __builtin_clzll((g_60.f0 , g_8)));
                    }
                    (*l_175) = (g_60 , l_173);
                }
                (*l_174) = ((float)g_60.f0 + (float)((float)((float)(((float)((float)(g_50 < (0xC.BBE412p+66 >= ((float)(g_38 <= g_111) - (float)((void*)0 == l_188)))) - (float)((((((int16_t)g_38 << (int16_t)7) , (func_71(l_191, l_192, l_192, g_134, p_56) , p_55)) == 0x8.0904B3p+62) == 0x8.640006p+56) <= (-0x1.2p-1))) + (float)g_38) <= l_193) - (float)g_50) + (float)0x1.3p+1));
            }
        }
    }
    if ((p_57 > g_60.f0))
    { /* block id: 79 */
        int32_t l_194 = 0x013F98BF;
        float *l_196 = &l_141;
        float **l_195 = &l_196;
        int32_t *l_201 = &g_50;
        l_201 = func_77(((0xC227 | func_80(l_194)) || __builtin_ffsll(g_60.f0)), ((((((g_60 , ((void*)0 == l_195)) , (((int16_t)(((int16_t)(p_57 , p_57) >> (int16_t)g_38) ^ (*p_56)) << (int16_t)0) == l_194)) , p_55) == (-1)) != l_194) || p_57));
    }
    else
    { /* block id: 81 */
        int32_t **l_202 = &g_114;
        float *l_216 = (void*)0;
        float *l_217 = &g_111;
        float **l_274 = &l_217;
        float ***l_273 = &l_274;
        float ****l_272 = &l_273;
        (*l_202) = (void*)0;
        (*l_217) = ((float)((float)(__builtin_parityl(p_57) , ((((uint16_t)(p_57 == __builtin_parityll((g_50 , p_55))) >> (uint16_t)0) , 0x3.1p+1) , ((0x3.A072CEp+9 <= ((float)((float)(-(float)((p_55 != g_38) >= l_214)) + (float)g_215) - (float)g_134)) == (-0x1.0p-1)))) * (float)0xC.01A0C7p-33) + (float)p_57);
        if (((((int16_t)l_220 >> (int16_t)0) , func_71(p_56, p_56, &g_50, ((uint32_t)(((uint32_t)p_55 - (uint32_t)g_8) && (__builtin_ffsll((((float)(((float)(p_55 == ((float)(!(-0x9.0p-1)) / (float)(g_60.f0 == g_111))) / (float)p_57) == p_57) - (float)0x8.1187F9p+23) , g_38)) | g_50)) + (uint32_t)p_55), (*l_202))) , (*g_37)))
        { /* block id: 84 */
            uint16_t l_232 = 9U;
            return l_232;
        }
        else
        { /* block id: 86 */
            int16_t l_246 = 1;
            struct S0 *l_263 = &g_60;
            struct S0 **l_262 = &l_263;
            int32_t l_281 = (-9);
            int32_t *l_282 = &g_134;
            uint32_t l_283 = 1U;
            int32_t ****l_310 = &g_117;
            (*p_56) = (func_71(func_77(((uint16_t)func_80((**l_202)) * (uint16_t)(g_50 ^ (((**l_202) , g_50) != ((int32_t)((uint32_t)(((g_60.f0 | (((uint32_t)p_57 - (uint32_t)l_245) <= 0x35077A8C)) != l_246) > 0U) - (uint32_t)l_246) - (int32_t)1)))), p_57), p_56, &g_134, (**l_202), p_56) , 0xFAD2F183);
            p_56 = p_56;
            (*l_217) = func_82(p_55, &g_134, p_57);
            for (l_220 = 0; (l_220 != (-17)); --l_220)
            { /* block id: 92 */
                uint32_t l_261 = 4294967291U;
                struct S0 *l_271 = &g_60;
                float **l_278 = &l_217;
                uint16_t l_286 = 65535U;
                int32_t ****l_309 = &g_117;
                if (l_246)
                { /* block id: 93 */
                    float **l_252 = (void*)0;
                    float ***l_251 = &l_252;
                    float ****l_250 = &l_251;
                    float *****l_249 = &l_250;
                    struct S0 *l_253 = &g_60;
                    struct S0 **l_254 = (void*)0;
                    struct S0 **l_255 = (void*)0;
                    struct S0 **l_256 = &l_253;
                    (*l_249) = (void*)0;
                    (*l_256) = l_253;
                    if ((*p_56))
                        continue;
                }
                else
                { /* block id: 97 */
                    struct S0 **l_260 = (void*)0;
                    struct S0 ***l_259 = &l_260;
                    int32_t l_270 = 0xF2D24EA2;
                    float ****l_275 = &l_273;
                    (*p_56) = ((int16_t)__builtin_ffsl(g_38) << (int16_t)(g_50 && p_55));
                    (*l_259) = (void*)0;
                    g_111 = ((((((l_261 <= (((void*)0 != l_262) , (**l_202))) > (((float)((float)((float)((((**l_202) == p_57) , 0x1.5p-1) , 0x1.8p+1) + (float)0x1.Dp-1) + (float)l_270) / (float)p_55) == 0xB.B8A8D5p-19)) != 0xA.10CE58p-41) , l_271) != &g_60) > 0xE.0BBC23p-80);
                    l_270 = ((p_57 , g_38) , (l_272 == l_275));
                }
                (*p_56) = (*p_56);
                if (((((int16_t)((l_278 == g_279) > p_55) % (int16_t)1) , 0U) | l_281))
                { /* block id: 104 */
                    if (l_246)
                    { /* block id: 105 */
                        (*p_56) = (*p_56);
                    }
                    else
                    { /* block id: 107 */
                        l_282 = p_56;
                    }
                }
                else
                { /* block id: 110 */
                    float l_291 = 0x5.B91696p-30;
                    int32_t l_296 = 9;
                    if (((((void*)0 == &l_167) , ((__builtin_clzl(l_283) != func_80(((uint16_t)(g_8 , 65531U) >> (uint16_t)10))) || (((-2) & g_60.f0) | 0))) != l_286))
                    { /* block id: 111 */
                        float l_287 = 0x2.1C906Fp-80;
                        l_291 = (((l_287 != (-(float)(((&g_117 == (void*)0) >= ((float)(*g_280) - (float)((**g_279) > (**g_279)))) <= ((((**g_279) , 0xA.6F61C0p-2) < 0x0.4p+1) <= 0x1.1p-1)))) >= 0x4.7E5EAFp+50) != (-0x1.Cp+1));
                        (*l_282) = ((g_50 & ((int16_t)((((int16_t)g_60.f0 / (int16_t)((l_296 && ((__builtin_popcountl(g_134) , l_297) != (*l_262))) , p_57)) && (g_50 <= (**l_202))) | 4294967295U) >> (int16_t)p_57)) , 0xDD6DB04E);
                        (****l_272) = (__builtin_bswap32((0 >= g_134)) > (((((float)(*g_280) + (float)(((float)(**g_279) - (float)(p_57 >= ((float)((float)p_57 / (float)(**g_279)) - (float)(**g_279)))) == g_306)) <= (-0x1.Fp-1)) < l_307) <= l_296));
                    }
                    else
                    { /* block id: 115 */
                        int16_t l_308 = 3;
                        return l_308;
                    }
                    l_310 = l_309;
                    return (**g_279);
                }
            }
        }
    }
    (*p_56) = __builtin_bswap64(g_50);
    p_56 = func_77(g_215, p_55);
    return (**g_279);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_114
 */
static struct S0  func_71(int32_t * p_72, int32_t * p_73, int32_t * p_74, int32_t  p_75, int32_t * p_76)
{ /* block id: 53 */
    int32_t **l_115 = &g_114;
    struct S0 l_116 = {0x4433A031};
    (*l_115) = p_73;
    return l_116;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_77(int16_t  p_78, int16_t  p_79)
{ /* block id: 51 */
    return &g_50;
}


/* ------------------------------------------ */
/* 
 * reads : g_38
 * writes: g_111
 */
static uint32_t  func_80(uint32_t  p_81)
{ /* block id: 48 */
    const int32_t *l_103 = &g_38;
    int32_t l_106 = (-1);
    float *l_110 = &g_111;
    uint32_t l_112 = 0xA48ADB29;
    (*l_110) = (((void*)0 != l_103) < (((float)((*l_103) , l_106) + (float)(p_81 > 0xD.65F4E4p-68)) != (!((float)0x0.179D74p-81 + (float)__builtin_popcountll(p_81)))));
    return l_112;
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_37 g_38 g_60 g_8 g_134
 * writes: g_50 g_134
 */
static int16_t  func_82(const uint32_t  p_83, int32_t * p_84, uint32_t  p_85)
{ /* block id: 44 */
    int32_t l_89 = 5;
    float l_99 = 0x4.880E1Bp+46;
    uint32_t l_100 = 4294967287U;
    float l_101 = 0x4.6F2DB4p+78;
    float *l_102 = &l_99;
    (*p_84) = ((int16_t)(((p_84 != &g_50) , l_89) && ((g_50 , (~__builtin_parityll((((int32_t)(p_85 , ((int16_t)((int16_t)((uint16_t)(((*g_37) & (g_60 , 0x81DD571B)) & __builtin_ffs(((&l_89 == (void*)0) || l_89))) + (uint16_t)l_89) - (int16_t)p_83) >> (int16_t)l_100)) + (int32_t)(*p_84)) || (*p_84))))) == p_83)) * (int16_t)l_100);
    (*l_102) = (g_8 < 0xE.0A9DAEp+37);
    return g_8;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_38, "g_38", print_hash_value);
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_60.f0, "g_60.f0", print_hash_value);
    transparent_crc_bytes (&g_111, sizeof(g_111), "g_111", print_hash_value);
    transparent_crc(g_134, "g_134", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    transparent_crc_bytes (&g_306, sizeof(g_306), "g_306", print_hash_value);
    transparent_crc(g_372.f0, "g_372.f0", print_hash_value);
    transparent_crc(g_456, "g_456", print_hash_value);
    transparent_crc(g_575, "g_575", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 168
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 17
   depth: 3, occurrence: 1
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 21, occurrence: 5
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 119

XXX times a variable address is taken: 106
XXX times a pointer is dereferenced on RHS: 198
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 52
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 517

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 356
   level: 2, occurrence: 85
   level: 3, occurrence: 39
   level: 4, occurrence: 23
   level: 5, occurrence: 16
XXX number of pointers point to pointers: 61
XXX number of pointers point to scalars: 50
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 24.4
XXX average alias set size: 1.2

XXX times a non-volatile is read: 974
XXX times a non-volatile is write: 208
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 23
   depth: 2, occurrence: 15
   depth: 3, occurrence: 9
   depth: 4, occurrence: 14
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
********************* end of statistics **********************/

