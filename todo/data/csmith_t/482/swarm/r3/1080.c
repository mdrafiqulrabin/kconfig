/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1012767926
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int8_t  f0;
   uint64_t  f1;
   unsigned f2 : 1;
   signed f3 : 1;
   int16_t  f4;
   int8_t  f5;
   int32_t  f6;
   float  f7;
   int8_t  f8;
   uint16_t  f9;
};

/* --- GLOBAL VARIABLES --- */
static int8_t g_4 = 0x3FL;
static int32_t g_35 = (-1L);
static int32_t g_40 = 6L;
static struct S0 *g_91 = (void*)0;
static struct S0 **g_108 = &g_91;
static struct S0 ***g_107 = &g_108;
static int32_t *g_130 = &g_40;
static int16_t g_249 = 6L;
static uint32_t g_260 = 0xA62810AEL;
static struct S0 ****g_266 = &g_107;
static struct S0 *****g_265 = &g_266;
static int32_t g_276 = 0xC22193E6L;
static int32_t *g_275 = &g_276;
static int32_t g_341 = 0xB5E051ACL;
static uint32_t g_345 = 0x8DB606F9L;
static struct S0 g_395 = {-3L,1UL,0,0,0L,1L,0x588D3536L,0x1.0p-1,0x2CL,0x7163L};


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_32(void);
static uint32_t  func_50(uint32_t  p_51, int32_t * p_52);
static int32_t * func_54(int64_t  p_55, int32_t * p_56, int64_t  p_57, uint32_t  p_58, int32_t * p_59);
static int8_t  func_62(uint16_t  p_63, int32_t * p_64, struct S0  p_65);
static int32_t * func_66(int32_t * p_67, int32_t * p_68);
static int32_t * func_69(int32_t * p_70, int64_t  p_71, float  p_72, uint64_t  p_73, uint16_t  p_74);
static struct S0 * func_76(int32_t * p_77, uint32_t  p_78, int64_t  p_79);
static int32_t * func_80(struct S0 * p_81, struct S0 * p_82, int32_t  p_83, int32_t  p_84, int16_t  p_85);
static struct S0 * func_86(int32_t  p_87, struct S0  p_88);
static uint64_t  func_92(int32_t  p_93, int8_t  p_94, int32_t * p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_35 g_40 g_91 g_107 g_108 g_130 g_260 g_265 g_266 g_275 g_249 g_276 g_345 g_341 g_395
 * writes: g_4 g_35 g_40 g_91 g_130 g_260 g_276 g_345 g_275 g_108 g_341
 */
static uint64_t  func_32(void)
{ /* block id: 36 */
    uint32_t l_42 = 18446744073709551614UL;
    int32_t *l_355 = &g_341;
    int16_t l_390 = 1L;
    struct S0 *l_396 = &g_395;
    int8_t l_397 = 0L;
    int32_t **l_398 = &l_355;
    for (g_4 = 0; (g_4 == 25); g_4++)
    { /* block id: 39 */
        int16_t l_38 = (-1L);
        int32_t *l_41 = &g_40;
        for (g_35 = (-11); (g_35 == (-6)); ++g_35)
        { /* block id: 42 */
            int32_t *l_39 = &g_40;
            (*l_39) = l_38;
            if (g_40)
                continue;
            return g_40;
        }
        (*l_41) ^= (l_41 != &g_35);
    }
    if (l_42)
    { /* block id: 49 */
        int32_t *l_43 = (void*)0;
        int32_t *l_44 = &g_40;
        (*l_44) = (g_4 >= 0x79E56E62L);
    }
    else
    { /* block id: 51 */
        int32_t *l_45 = &g_35;
        int32_t l_46 = 1L;
        struct S0 l_353 = {0x9DL,0x7DC5E76BDE149198LL,0,-0,0x5312L,-1L,1L,0x1.23FF21p+38,0x4CL,0xE741L};
        (*l_45) = 1L;
        (*l_45) = l_46;
        if ((safe_unary_minus_func_int16_t_s((safe_rshift_func_int8_t_s_u((l_42 , 0xF4L), 7)))))
        { /* block id: 54 */
            uint8_t l_53 = 255UL;
            int32_t *l_75 = (void*)0;
            float *l_364 = &l_353.f7;
            (*l_364) = (l_42 > ((func_50(l_53, func_54((g_4 , ((safe_sub_func_int16_t_s_s((((((*l_45) && ((func_62(l_42, func_66(func_69(&g_35, (*l_45), (g_35 == (((void*)0 == l_75) , g_4)), g_40, g_35), g_275), l_353) != 0xE0L) , 0L)) && g_35) , l_42) , 0x7EB1L), g_341)) , g_35)), &g_341, g_341, g_341, l_355)) & l_353.f9) , 0x1.320A02p-50));
            for (l_353.f0 = 19; (l_353.f0 >= (-2)); --l_353.f0)
            { /* block id: 184 */
                uint8_t l_367 = 255UL;
                int32_t **l_368 = &l_355;
                (*l_364) = (((g_35 > ((l_367 , &g_130) != l_368)) , (((safe_add_func_float_f_f(0x2.43F4B2p-40, (g_35 <= (safe_add_func_float_f_f((-0x9.3p-1), ((**l_368) <= ((0x0.A6CCC6p-20 == 0x1.Ep-1) <= 0x0.8p+1))))))) == (*l_355)) <= (*l_45))) == (*l_45));
                for (l_353.f1 = (-6); (l_353.f1 >= 55); l_353.f1 = safe_add_func_uint8_t_u_u(l_353.f1, 5))
                { /* block id: 188 */
                    if ((*l_45))
                        break;
                }
            }
            (*g_275) = (*g_130);
        }
        else
        { /* block id: 193 */
            uint32_t l_381 = 4294967289UL;
            float *l_382 = &l_353.f7;
            struct S0 l_394 = {0xE2L,8UL,0,-0,0x3832L,0x0FL,0x8FB8EA65L,0x2.1D896Cp-48,0x58L,0x1362L};
            (*l_355) = ((safe_add_func_uint8_t_u_u(func_92((((safe_rshift_func_uint8_t_u_s((safe_rshift_func_uint8_t_u_u(((l_381 , l_382) != l_382), 2)), func_62((safe_mod_func_uint8_t_u_u(0x5EL, (safe_unary_minus_func_int64_t_s((safe_rshift_func_int8_t_s_u((safe_sub_func_uint8_t_u_u((l_390 != (~g_4)), ((safe_rshift_func_uint16_t_u_u((*l_45), 14)) >= g_260))), 6)))))), l_355, l_394))) != 9UL) >= g_345), g_345, &g_341), 254UL)) < 0xE053CD6AL);
        }
    }
    (*l_398) = func_69(func_80((((void*)0 == (**g_107)) , func_86((*g_275), g_395)), l_396, ((-5L) && g_260), ((((void*)0 == l_396) == 65535UL) , (*l_355)), (*l_355)), l_397, (*l_355), (*l_355), g_260);
    return g_395.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_40 g_266 g_107 g_108 g_265
 * writes: g_40 g_345 g_130 g_108
 */
static uint32_t  func_50(uint32_t  p_51, int32_t * p_52)
{ /* block id: 168 */
    int32_t *l_361 = &g_341;
    int32_t *l_363 = &g_341;
    for (g_40 = 0; (g_40 >= 13); g_40++)
    { /* block id: 171 */
        int32_t **l_362 = (void*)0;
        for (g_345 = 0; (g_345 >= 43); ++g_345)
        { /* block id: 174 */
            int32_t **l_360 = &g_130;
            (*l_360) = p_52;
        }
        l_363 = l_361;
        (***g_265) = (**g_266);
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_54(int64_t  p_55, int32_t * p_56, int64_t  p_57, uint32_t  p_58, int32_t * p_59)
{ /* block id: 166 */
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_62(uint16_t  p_63, int32_t * p_64, struct S0  p_65)
{ /* block id: 164 */
    int32_t l_354 = 1L;
    return l_354;
}


/* ------------------------------------------ */
/* 
 * reads : g_249 g_275 g_276 g_40 g_260 g_4 g_130 g_35 g_345 g_108 g_91 g_266 g_107
 * writes: g_276 g_40 g_345 g_91 g_4 g_275
 */
static int32_t * func_66(int32_t * p_67, int32_t * p_68)
{ /* block id: 144 */
    int32_t l_281 = 1L;
    struct S0 l_294 = {-1L,18446744073709551607UL,0,0,0x4ACAL,0xCAL,-1L,0x0.1p-1,0x39L,1UL};
    int32_t l_337 = 1L;
    struct S0 *****l_351 = &g_266;
    int32_t **l_352 = &g_275;
lbl_295:
    (*g_275) |= ((safe_rshift_func_uint16_t_u_u((safe_mod_func_int64_t_s_s(1L, l_281)), (0x0284A6CAL == __builtin_popcountl(g_249)))) >= l_281);
    if ((((safe_add_func_int32_t_s_s((*p_67), (safe_lshift_func_uint16_t_u_u(g_249, 4)))) & ((((0x7B899A1CL == (g_40 < (((((g_260 || g_260) <= ((g_260 == (l_281 , ((l_281 >= g_276) & g_276))) && 0x5227E044L)) <= (*p_67)) > l_281) >= 2UL))) == g_40) <= l_281) >= 7UL)) , (*g_275)))
    { /* block id: 146 */
        uint8_t l_292 = 0x29L;
        (*g_130) = (((safe_add_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_u((safe_sub_func_int64_t_s_s(l_292, 0xDAEAB5801B7B750CLL)), 5)), ((((__builtin_ia32_crc32qi(l_292, l_292) == (*p_68)) , ((0UL != l_292) & l_292)) >= l_292) , l_292))) != (-1L)) & g_4);
    }
    else
    { /* block id: 148 */
        struct S0 l_293 = {0xBAL,1UL,0,-0,0L,-1L,0L,0x7.B68FCAp+7,0xDBL,65531UL};
        l_294 = ((__builtin_bswap32(g_35) >= (g_40 , g_249)) , l_293);
        if ((*g_130))
        { /* block id: 150 */
            int32_t *l_296 = &l_293.f6;
            int32_t *l_297 = &g_35;
            int32_t *l_298 = (void*)0;
            int32_t *l_299 = &g_276;
            int32_t *l_300 = (void*)0;
            int32_t *l_301 = &g_276;
            int32_t *l_302 = &g_40;
            int32_t *l_303 = &g_35;
            int32_t *l_304 = &l_293.f6;
            int32_t *l_305 = &g_40;
            int32_t *l_306 = &l_294.f6;
            int32_t *l_307 = &g_40;
            int32_t *l_308 = &g_40;
            int32_t *l_309 = (void*)0;
            int32_t *l_310 = &l_294.f6;
            int32_t *l_311 = &l_294.f6;
            int32_t *l_312 = &g_35;
            int32_t *l_313 = &l_293.f6;
            int32_t *l_314 = &l_294.f6;
            int32_t *l_315 = &g_276;
            int32_t *l_316 = &g_35;
            int32_t *l_317 = &l_294.f6;
            int32_t l_318 = 0x9E05B609L;
            int32_t *l_319 = &l_318;
            int32_t *l_320 = &g_40;
            int32_t *l_321 = (void*)0;
            int32_t l_322 = 0x21F15DC8L;
            int32_t *l_323 = &g_276;
            int32_t *l_324 = (void*)0;
            int32_t *l_325 = (void*)0;
            int32_t *l_326 = &l_322;
            int32_t *l_327 = &g_276;
            int32_t *l_328 = &l_294.f6;
            int32_t *l_329 = &l_293.f6;
            int32_t *l_330 = &l_294.f6;
            int32_t *l_331 = &l_293.f6;
            int32_t *l_332 = &g_35;
            int32_t *l_333 = (void*)0;
            int32_t *l_334 = &l_294.f6;
            int32_t *l_335 = (void*)0;
            int32_t *l_336 = &g_276;
            int32_t *l_338 = &l_337;
            int32_t *l_339 = &l_322;
            int32_t *l_340 = &g_276;
            int32_t l_342 = 0xC4C534E0L;
            int32_t *l_343 = &l_337;
            int32_t *l_344 = (void*)0;
            if (g_4)
                goto lbl_295;
            ++g_345;
        }
        else
        { /* block id: 153 */
            (*g_108) = (*g_108);
        }
        for (l_294.f5 = 6; (l_294.f5 < 16); l_294.f5++)
        { /* block id: 158 */
            struct S0 l_350 = {0x8EL,0UL,0,-0,0L,6L,0x41C1BC39L,-0x6.0p+1,0x1CL,65535UL};
            l_350 = l_293;
        }
    }
    (*l_352) = (((void*)0 == l_351) , func_80((l_294 , (****l_351)), (****l_351), l_294.f8, __builtin_parityl(((****l_351) == (****l_351))), g_260));
    return &g_276;
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_4 g_91 g_40 g_107 g_108 g_130 g_260 g_265 g_266 g_341
 * writes: g_35 g_91 g_4 g_130 g_40 g_260 g_341
 */
static int32_t * func_69(int32_t * p_70, int64_t  p_71, float  p_72, uint64_t  p_73, uint16_t  p_74)
{ /* block id: 55 */
    struct S0 l_102 = {4L,0x82C65315FA727FAALL,0,0,0xBBC0L,0xF5L,-1L,0xE.75AE7Bp+43,0xB8L,65534UL};
    (***g_266) = func_76(func_80(func_86(((__builtin_ffs((*p_70)) == (safe_mod_func_int16_t_s_s(g_4, 0x8E49L))) , __builtin_ia32_crc32qi(((g_91 != (void*)0) <= p_71), (func_92(g_35, g_4, &g_35) , g_40))), l_102), &l_102, p_71, p_74, l_102.f8), p_73, l_102.f9);
    return &g_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_4 g_40 g_130 g_108 g_91 g_260 g_265 g_107 g_341
 * writes: g_35 g_4 g_130 g_40 g_260 g_341
 */
static struct S0 * func_76(int32_t * p_77, uint32_t  p_78, int64_t  p_79)
{ /* block id: 95 */
    int32_t l_163 = 0x2677FA26L;
    struct S0 l_178 = {0x6EL,18446744073709551614UL,0,-0,0xAB6FL,0x26L,0x1F0273B9L,0x0.31699Cp-92,1L,0xD719L};
    struct S0 **l_189 = &g_91;
    int32_t l_248 = 0L;
    for (p_79 = 15; (p_79 <= 7); --p_79)
    { /* block id: 98 */
        int64_t l_177 = 0x1F9A50F5FFFD36A2LL;
        int8_t l_219 = 8L;
        int32_t l_233 = 0x62504A51L;
        int32_t *l_274 = &l_163;
        for (g_35 = 1; (g_35 <= 22); ++g_35)
        { /* block id: 101 */
            float l_141 = 0xD.FEAE78p+81;
            int32_t l_143 = (-5L);
            int32_t *l_194 = &g_40;
            int32_t *l_195 = &g_40;
            int32_t *l_196 = (void*)0;
            int32_t *l_197 = &l_178.f6;
            int32_t *l_198 = &g_40;
            int32_t *l_199 = &l_178.f6;
            int32_t *l_200 = (void*)0;
            int32_t *l_201 = &l_178.f6;
            int32_t *l_202 = &l_178.f6;
            int32_t *l_203 = &l_163;
            int32_t *l_204 = &l_143;
            int32_t *l_205 = &l_178.f6;
            int32_t *l_206 = &l_163;
            int32_t *l_207 = &l_143;
            int32_t *l_208 = &g_40;
            int32_t *l_209 = &l_178.f6;
            int32_t *l_210 = &l_163;
            int32_t *l_211 = &l_163;
            int32_t *l_212 = &g_40;
            int32_t *l_213 = &l_163;
            int32_t *l_214 = &l_143;
            int32_t *l_215 = &g_40;
            int32_t *l_216 = (void*)0;
            int32_t *l_217 = &l_143;
            int32_t *l_218 = &g_40;
            int32_t *l_220 = &l_178.f6;
            int32_t *l_221 = &l_178.f6;
            int32_t *l_222 = &l_143;
            int32_t *l_223 = &l_163;
            int32_t *l_224 = &g_40;
            int32_t *l_225 = &l_143;
            int32_t *l_226 = &g_40;
            int32_t *l_227 = (void*)0;
            int32_t *l_228 = &l_163;
            int32_t *l_229 = &g_40;
            int32_t *l_230 = &g_40;
            int32_t *l_231 = &l_178.f6;
            int32_t *l_232 = &l_178.f6;
            int32_t *l_234 = &g_40;
            int32_t *l_235 = &l_178.f6;
            int32_t *l_236 = &l_143;
            int32_t *l_237 = &g_40;
            int32_t *l_238 = (void*)0;
            int32_t *l_239 = &l_143;
            int32_t *l_240 = &l_233;
            int32_t *l_241 = &l_143;
            int32_t *l_242 = &l_143;
            int32_t *l_243 = &l_143;
            int32_t *l_244 = &l_163;
            int32_t *l_245 = (void*)0;
            int32_t *l_246 = (void*)0;
            int32_t *l_247 = (void*)0;
            int32_t *l_250 = &l_233;
            int32_t *l_251 = (void*)0;
            int32_t *l_252 = &l_143;
            int32_t *l_253 = &g_40;
            int32_t l_254 = (-1L);
            int32_t *l_255 = &l_163;
            int32_t *l_256 = &l_248;
            int32_t *l_257 = &l_233;
            int32_t *l_258 = &l_254;
            int32_t *l_259 = &l_143;
            for (g_4 = 17; (g_4 == (-12)); --g_4)
            { /* block id: 104 */
                int32_t l_139 = 0L;
                int8_t l_142 = 0x07L;
                int32_t **l_164 = &g_130;
                g_130 = &g_40;
                for (p_78 = (-26); (p_78 >= 48); p_78++)
                { /* block id: 108 */
                    uint32_t l_144 = 0x36EB9B4FL;
                    if ((safe_add_func_uint32_t_u_u(g_35, ((g_40 ^ (safe_sub_func_uint32_t_u_u((g_35 > ((void*)0 != &g_108)), ((g_4 | p_78) < p_78)))) , (-8L)))))
                    { /* block id: 109 */
                        struct S0 ***l_140 = (void*)0;
                        (*g_130) = 0x7FB1DA9CL;
                        (*g_130) |= (-1L);
                        l_143 = (((__builtin_bswap32((safe_rshift_func_uint16_t_u_s((p_79 && ((l_139 != (p_79 <= ((p_79 , (*g_108)) == (void*)0))) , (l_140 != (void*)0))), g_4))) <= l_142) >= g_4) > p_78);
                    }
                    else
                    { /* block id: 113 */
                        float *l_158 = &l_141;
                        (*l_158) = func_92(l_144, (safe_mod_func_uint32_t_u_u(0x2277CB2DL, ((((0x02L || (safe_lshift_func_uint8_t_u_u(((safe_add_func_int8_t_s_s(0xA1L, (safe_add_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(g_35, 9)), (safe_add_func_uint32_t_u_u((((__builtin_ffsll((((p_79 | (safe_unary_minus_func_int16_t_s(p_79))) | (((((-9L) || 0x1AL) & p_78) , l_143) & (*p_77))) , 0L)) , p_78) >= l_143) ^ 1UL), 9UL)))))) || l_143), g_35))) , l_139) && p_79) , l_143))), p_77);
                        (*p_77) ^= (p_77 == (void*)0);
                    }
                }
                if (((p_79 <= p_79) | (safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(func_92(l_163, (l_143 , (&g_130 != l_164)), (p_79 , (void*)0)), p_78)), 6))))
                { /* block id: 118 */
                    struct S0 *l_179 = &l_178;
                    (*l_179) = ((safe_mod_func_int32_t_s_s(0x38AAB9ACL, ((~func_92(l_163, (+(((**l_164) , ((safe_rshift_func_int16_t_s_u((((safe_mod_func_int16_t_s_s(__builtin_clzll(p_79), (safe_lshift_func_int16_t_s_s(0xDA6AL, 2)))) , p_78) <= (safe_sub_func_int64_t_s_s(((p_78 > (((__builtin_clzll((&l_143 != (void*)0)) > 0x2.424E93p+23) , 1L) < (**l_164))) ^ l_177), (**l_164)))), 4)) , l_163)) == p_79)), &g_40)) , 1UL))) , l_178);
                }
                else
                { /* block id: 120 */
                    uint8_t l_180 = 1UL;
                    struct S0 ****l_181 = &g_107;
                    float *l_193 = &l_178.f7;
                    l_180 ^= (*g_130);
                    (**l_164) = (l_177 , l_180);
                    if ((*g_130))
                    { /* block id: 123 */
                        struct S0 *****l_182 = &l_181;
                        (*p_77) = (-2L);
                        (*l_164) = (*l_164);
                        (*l_182) = l_181;
                    }
                    else
                    { /* block id: 127 */
                        int64_t l_190 = (-8L);
                        float *l_191 = &l_178.f7;
                        (*l_191) = (p_78 != (safe_sub_func_float_f_f(p_78, (((safe_add_func_float_f_f(((l_177 , g_40) <= (((safe_lshift_func_uint8_t_u_s(0x40L, ((-1L) & 18446744073709551615UL))) , l_189) != l_189)), 0x0.1251B0p-6)) > l_190) == l_178.f2))));
                        (*l_191) = ((l_190 == p_79) != (((0x3.95C8E4p-34 >= (g_40 , ((+(g_40 == 0x5.E7F712p-21)) <= p_79))) != 0xC.CAD11Dp+80) != (g_4 <= 0x1.Dp+1)));
                        if ((*g_130))
                            break;
                    }
                    (*l_193) = p_78;
                }
                (*l_164) = (g_4 , p_77);
            }
            ++g_260;
        }
        (*g_130) |= ((p_79 != l_178.f6) != p_79);
        (*l_274) &= (safe_sub_func_uint32_t_u_u((((&g_108 == &l_189) ^ ((void*)0 == g_265)) >= (65529UL != ((*g_130) ^ (*g_130)))), ((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u(((((safe_lshift_func_uint8_t_u_u((~(l_219 == (((void*)0 == (**g_107)) | p_79))), g_40)) != l_219) || l_178.f3) | (*g_130)), 10)), 11)) | p_78)));
    }
    return (*l_189);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_108 g_91 g_107
 * writes: g_91 g_4
 */
static int32_t * func_80(struct S0 * p_81, struct S0 * p_82, int32_t  p_83, int32_t  p_84, int16_t  p_85)
{ /* block id: 79 */
    int64_t l_116 = 0L;
    int32_t l_117 = (-1L);
    l_117 &= (safe_mod_func_uint32_t_u_u((g_4 | p_85), l_116));
    (**g_107) = (l_116 , (*g_108));
    for (g_4 = 19; (g_4 == (-8)); g_4 = safe_sub_func_int16_t_s_s(g_4, 8))
    { /* block id: 84 */
        int32_t *l_122 = (void*)0;
        int32_t *l_123 = &l_117;
        for (p_85 = 0; (p_85 >= (-25)); p_85 = safe_sub_func_uint8_t_u_u(p_85, 1))
        { /* block id: 87 */
            if (p_84)
                break;
        }
        (*l_123) = p_83;
        l_117 &= g_4;
        if (p_84)
            continue;
    }
    return &g_40;
}


/* ------------------------------------------ */
/* 
 * reads : g_35 g_107 g_108 g_91
 * writes: g_35
 */
static struct S0 * func_86(int32_t  p_87, struct S0  p_88)
{ /* block id: 65 */
    for (g_35 = 0; (g_35 == (-26)); g_35 = safe_sub_func_int64_t_s_s(g_35, 4))
    { /* block id: 68 */
        float l_105 = 0x3.26FF55p+32;
        int32_t l_106 = 1L;
        int32_t *l_109 = &l_106;
        float *l_113 = &l_105;
        if (l_106)
            break;
        (*l_109) |= ((void*)0 == g_107);
        for (p_88.f5 = 0; (p_88.f5 == (-26)); --p_88.f5)
        { /* block id: 73 */
            struct S0 *l_112 = (void*)0;
            return l_112;
        }
        (*l_113) = ((*l_109) , p_87);
    }
    return (**g_107);
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes:
 */
static uint64_t  func_92(int32_t  p_93, int8_t  p_94, int32_t * p_95)
{ /* block id: 56 */
    int32_t *l_97 = &g_35;
    int32_t **l_96 = &l_97;
    (*l_96) = &g_35;
    (*l_96) = (*l_96);
    for (p_94 = 0; (p_94 > 13); p_94++)
    { /* block id: 61 */
        struct S0 **l_100 = &g_91;
        struct S0 ***l_101 = &l_100;
        (*l_101) = l_100;
    }
    return g_4;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_32();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_35, "g_35", print_hash_value);
    transparent_crc(g_40, "g_40", print_hash_value);
    transparent_crc(g_249, "g_249", print_hash_value);
    transparent_crc(g_260, "g_260", print_hash_value);
    transparent_crc(g_276, "g_276", print_hash_value);
    transparent_crc(g_341, "g_341", print_hash_value);
    transparent_crc(g_345, "g_345", print_hash_value);
    transparent_crc(g_395.f0, "g_395.f0", print_hash_value);
    transparent_crc(g_395.f1, "g_395.f1", print_hash_value);
    transparent_crc(g_395.f2, "g_395.f2", print_hash_value);
    transparent_crc(g_395.f3, "g_395.f3", print_hash_value);
    transparent_crc(g_395.f4, "g_395.f4", print_hash_value);
    transparent_crc(g_395.f5, "g_395.f5", print_hash_value);
    transparent_crc(g_395.f6, "g_395.f6", print_hash_value);
    transparent_crc_bytes (&g_395.f7, sizeof(g_395.f7), "g_395.f7", print_hash_value);
    transparent_crc(g_395.f8, "g_395.f8", print_hash_value);
    transparent_crc(g_395.f9, "g_395.f9", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 68
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 18
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 3
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 9
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 2

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 24
   depth: 3, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 162

XXX times a variable address is taken: 142
XXX times a pointer is dereferenced on RHS: 45
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 8
   depth: 3, occurrence: 0
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 39
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 313

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 158
   level: 2, occurrence: 21
   level: 3, occurrence: 6
   level: 4, occurrence: 6
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 18
XXX number of pointers point to scalars: 137
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 17.9
XXX average alias set size: 1.06

XXX times a non-volatile is read: 331
XXX times a non-volatile is write: 110
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 91
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 25
   depth: 2, occurrence: 16
   depth: 3, occurrence: 6
   depth: 4, occurrence: 7
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 24.2
XXX percentage an existing variable is used: 75.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

