/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      443172582
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const uint32_t  f0;
   const int8_t  f1;
   const int8_t  f2;
   const int32_t  f3;
};
#pragma pack(pop)

struct S1 {
   int32_t  f0;
   int32_t  f1;
   struct S0  f2;
   int32_t  f3;
   uint16_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_32(void);
static int32_t * func_33(int8_t  p_34, uint32_t  p_35, uint32_t  p_36, int32_t * p_37);
static int16_t  func_43(uint32_t  p_44);
static struct S0  func_45(const uint16_t  p_46, struct S0  p_47, int32_t * p_48);
static int16_t  func_57(int8_t  p_58, float  p_59, uint32_t  p_60);
static uint16_t  func_75(int32_t  p_76, int32_t * p_77, int32_t  p_78, int32_t * p_79);
static struct S0  func_83(int16_t  p_84);
static int32_t  func_95(int32_t * p_96);
static int32_t  func_101(struct S1  p_102, struct S1  p_103);
static struct S1  func_104(float  p_105, const float  p_106, const uint16_t * p_107);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_32(void)
{ /* block id: 36 */
    int32_t l_38 = 2;
    int32_t l_70 = 0x85869896;
    int32_t *l_69 = &l_70;
    struct S0 l_253 = {0xC34E27C4,0xB5,1,7};
    int32_t l_261 = 0x2D828728;
    uint32_t l_283 = 0x66E90E1A;
    uint32_t *l_282 = &l_283;
    int32_t *l_309 = (void*)0;
    struct S0 *l_321 = &l_253;
    struct S0 **l_320 = &l_321;
    uint32_t l_324 = 0xE1B70F6B;
    l_309 = func_33(l_38, ((*l_282) = (safe_div_func_int16_t_s_s((safe_mod_func_int16_t_s_s(func_43((func_45((safe_div_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((l_38 , (l_38 & 0x5E97)), 1)), __builtin_ia32_crc32qi(l_38, (safe_rshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u(l_38, 14)), func_57((((((safe_add_func_int32_t_s_s(((*l_69) = (safe_mod_func_uint16_t_u_u((l_38 && (safe_add_func_uint32_t_u_u((safe_sub_func_int32_t_s_s(((__builtin_ffsll(l_38) , l_38) , l_38), l_38)), 5U))), 65527U))), 0xBF094577)) | 0x4F2D) , (*l_69)) , 0xABC1) > 1U), l_38, l_38)))))), l_253, &l_38) , l_261)), l_253.f1)), l_261))), l_38, &l_38);
    /* statement id: 159 */
    assert (l_309 == &l_38);
    for (l_283 = 20; (l_283 >= 4); l_283 = safe_sub_func_int16_t_s_s(l_283, 5))
    { /* block id: 162 */
        int32_t *l_312 = &l_261;
        int32_t **l_313 = &l_69;
        int32_t **l_314 = &l_312;
        struct S0 **l_323 = (void*)0;
        struct S0 ***l_322 = &l_323;
        (*l_314) = ((*l_313) = l_312);
        /* statement id: 164 */
        assert (l_69 == &l_261);
        for (l_261 = (-24); (l_261 >= (-2)); l_261 = safe_add_func_int32_t_s_s(l_261, 7))
        { /* block id: 167 */
            uint32_t *l_318 = (void*)0;
            uint32_t **l_317 = &l_318;
            uint32_t ***l_319 = &l_317;
            (*l_319) = l_317;
        }
        (*l_322) = (l_320 = l_320);
        /* statement id: 171 */
        assert (l_323 == &l_321);
    }
    /* facts after for loop */
    assert (l_69 == &l_261 || l_69 == &l_70);
    return l_324;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_33(int8_t  p_34, uint32_t  p_35, uint32_t  p_36, int32_t * p_37)
{ /* block id: 151 */
    float l_286 = (-0x1.2p+1);
    const struct S0 l_289 = {0U,0,1,1};
    int16_t l_293 = 0x471F;
    int16_t *l_292 = &l_293;
    int16_t **l_294 = (void*)0;
    int16_t *l_295 = &l_293;
    uint16_t l_296 = 0xC715;
    const uint16_t *l_298 = &l_296;
    const uint16_t **l_297 = &l_298;
    uint32_t l_300 = 6U;
    uint32_t *l_299 = &l_300;
    int32_t l_306 = 1;
    int32_t *l_307 = (void*)0;
    int32_t l_308 = 1;
    (*p_37) = ((safe_lshift_func_int16_t_s_u(p_36, (((safe_mod_func_uint32_t_u_u((l_289 , l_289.f0), p_36)) < (((*l_299) = ((safe_add_func_uint32_t_u_u((0xCACC > (l_292 == (l_295 = &l_293))), (l_296 , ((((l_289.f0 <= 0x0.Dp-1) , l_297) == (void*)0) || (-1))))) && p_35)) != 0x550421CD)) ^ l_289.f1))) <= (-1));
    l_308 = (safe_add_func_int32_t_s_s((l_289.f0 , (safe_lshift_func_int16_t_s_s(0x80C6, 11))), (p_34 & (l_306 = ((*p_37) = (safe_unary_minus_func_int16_t_s((l_293 ^ l_289.f3))))))));
    return p_37;
    /* statement id: 158 */
    //assert (func_33_rv == &l_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_43(uint32_t  p_44)
{ /* block id: 142 */
    int32_t l_266 = 0xBDAAF68C;
    int32_t l_268 = (-8);
    int32_t *l_267 = &l_268;
    int16_t l_274 = 0x0893;
    int16_t *l_273 = &l_274;
    int32_t l_276 = 0xB485FB8F;
    int32_t *l_275 = &l_276;
    int32_t l_278 = 0x750AFB25;
    int32_t *l_277 = &l_278;
    int32_t l_280 = 0;
    int32_t *l_279 = &l_280;
    (*l_279) = (safe_sub_func_uint16_t_u_u((safe_div_func_uint32_t_u_u(l_266, ((*l_277) = ((((*l_267) = 1) == ((0 ^ ((safe_add_func_int32_t_s_s(p_44, ((*l_275) = (safe_sub_func_int16_t_s_s(((*l_273) = 0x32A1), func_57(l_266, l_266, p_44)))))) == 0x926210D5)) | (-10))) && (*l_275))))), p_44));
    (*l_277) = ((safe_unary_minus_func_int32_t_s((0x80F5 <= (p_44 <= ((*l_277) <= (*l_275)))))) , ((void*)0 == &l_275));
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_45(const uint16_t  p_46, struct S0  p_47, int32_t * p_48)
{ /* block id: 138 */
    int32_t l_255 = 0;
    int32_t *l_254 = &l_255;
    float *l_258 = (void*)0;
    float l_260 = 0x6.C518A7p+95;
    float *l_259 = &l_260;
    l_254 = l_254;
    (*l_259) = (safe_div_func_float_f_f(((void*)0 != &p_48), 0x2.Ep+1));
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_57(int8_t  p_58, float  p_59, uint32_t  p_60)
{ /* block id: 38 */
    int32_t l_82 = 0x0538FD23;
    uint16_t *l_91 = (void*)0;
    int32_t l_92 = 0xE288A3D8;
    int32_t l_246 = 0xEBA8DA92;
    int32_t *l_245 = &l_246;
    uint16_t l_248 = 0x7050;
    uint16_t *l_247 = &l_248;
    const int32_t l_250 = (-1);
    const int32_t *l_249 = &l_250;
    int32_t **l_251 = (void*)0;
    int32_t **l_252 = &l_245;
    (*l_245) = (safe_mul_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((*l_247) = func_75((l_82 = ((safe_mod_func_uint16_t_u_u(p_58, l_82)) | ((func_83((p_60 || (safe_div_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_s((safe_sub_func_uint16_t_u_u((l_92 = 1U), (safe_sub_func_uint32_t_u_u(((func_95(&l_82) || (!(safe_add_func_uint32_t_u_u((l_82 | ((l_91 != (((l_82 != l_82) , p_58) , (void*)0)) == 7)), l_82)))) || p_58), 0xE5052DE1)))), p_60)) & l_82) > 1U), 0x0D19)))) , p_58) , 0x6168A2A3))), l_245, (*l_245), &l_246)), 5)), p_60));
    (*l_245) = ((-2) == p_58);
    (*l_252) = (l_249 = &l_246);
    /* statement id: 136 */
    assert (l_249 == &l_246);
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_75(int32_t  p_76, int32_t * p_77, int32_t  p_78, int32_t * p_79)
{ /* block id: 130 */
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_83(int16_t  p_84)
{ /* block id: 42 */
    uint32_t l_100 = 8U;
    int32_t l_113 = 0x41872AF4;
    int32_t *l_112 = &l_113;
    float *l_121 = (void*)0;
    float l_123 = (-0x1.4p-1);
    float *l_122 = &l_123;
    const uint32_t l_124 = 4294967295U;
    uint16_t l_126 = 65535U;
    const uint16_t *l_125 = &l_126;
    struct S1 l_154 = {0xF947B41C,0x223CDC64,{4294967288U,-3,0x6E,0xDE629050},0,1U};
    int32_t **l_242 = &l_112;
    int32_t ***l_244 = &l_242;
    int32_t ****l_243 = &l_244;
    l_100 = 0xE.FA00A4p+73;
    (*l_112) = ((p_84 && func_101(func_104(((*l_122) = (safe_sub_func_float_f_f(l_100, (safe_sub_func_float_f_f((((void*)0 == l_112) , ((!(safe_sub_func_uint16_t_u_u((func_95(&l_113) || ((safe_add_func_int16_t_s_s(8, (*l_112))) && 0)), p_84))) , p_84)), (*l_112)))))), l_124, l_125), l_154)) & p_84);
    (*l_242) = &l_113;
    (*l_243) = &l_242;
    return l_154.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_95(int32_t * p_96)
{ /* block id: 40 */
    return (*p_96);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_101(struct S1  p_102, struct S1  p_103)
{ /* block id: 52 */
    int32_t l_156 = 0x148970CE;
    int32_t *l_155 = &l_156;
    int32_t **l_157 = &l_155;
    struct S1 l_203 = {0x302985B2,1,{0x32FC06C7,-7,7,0x5D89A0F2},-1,0x63BB};
    int16_t l_241 = (-1);
    (*l_157) = l_155;
    if ((**l_157))
    { /* block id: 54 */
        for (l_156 = 19; (l_156 != (-11)); l_156 = safe_sub_func_int32_t_s_s(l_156, 5))
        { /* block id: 57 */
            int16_t l_160 = 0x6D1E;
            return l_160;
        }
    }
    else
    { /* block id: 60 */
        int32_t *l_161 = &l_156;
        uint16_t l_198 = 65533U;
        uint16_t *l_197 = &l_198;
        uint16_t **l_196 = &l_197;
        (*l_157) = (l_161 = (*l_157));
        for (p_102.f1 = 0; (p_102.f1 == (-12)); p_102.f1 = safe_sub_func_uint32_t_u_u(p_102.f1, 1))
        { /* block id: 65 */
            int8_t l_190 = 0;
            float l_192 = 0x1.56C1A7p-11;
            float *l_191 = &l_192;
            uint32_t l_218 = 1U;
        }
        (**l_157) = p_103.f3;
    }
    return l_241;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_104(float  p_105, const float  p_106, const uint16_t * p_107)
{ /* block id: 45 */
    float l_127 = (-0x1.3p+1);
    float *l_128 = &l_127;
    int32_t l_131 = (-4);
    int32_t l_143 = (-7);
    int32_t *l_142 = &l_143;
    int32_t *l_147 = &l_131;
    float *l_152 = &l_127;
    struct S1 l_153 = {0xAB819B16,-8,{0x26D5D5E4,0xF7,0x96,0xE8A9312F},-1,0x123F};
    (*l_128) = l_127;
    (*l_128) = ((((safe_mod_func_int32_t_s_s(l_131, ((safe_div_func_float_f_f(l_131, (func_95(((safe_add_func_uint16_t_u_u((l_131 , (((((0xCF7F < ((safe_mod_func_uint16_t_u_u(l_131, (((*l_142) = (safe_mul_func_uint16_t_u_u((*p_107), (((safe_rshift_func_uint16_t_u_u((*p_107), 1)) <= func_95(&l_131)) > (*p_107))))) | l_131))) || (*l_142))) , (*l_142)) , 0x895055D0) > l_131) , 65535U)), (*p_107))) , &l_131)) , (*l_142)))) , (*l_142)))) , (*l_142)) < p_106) != 0x9.26F057p+2);
    (*l_147) = (safe_lshift_func_int16_t_s_s(((((safe_unary_minus_func_int32_t_s(func_95(l_147))) && (0x43A563CF != (safe_sub_func_int32_t_s_s(((*l_142) = (safe_rshift_func_uint16_t_u_s((*p_107), (*l_142)))), ((void*)0 != l_152))))) , (*p_107)) < func_95(&l_131)), 4));
    return l_153;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 59
   depth: 1, occurrence: 2
   depth: 2, occurrence: 3
XXX total union variables: 0

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 26, occurrence: 1
   depth: 32, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 72

XXX times a variable address is taken: 67
XXX times a pointer is dereferenced on RHS: 36
breakdown:
   depth: 1, occurrence: 34
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 54
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 163

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 114
   level: 2, occurrence: 7
XXX number of pointers point to pointers: 21
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 23.6
XXX average alias set size: 1.15

XXX times a non-volatile is read: 276
XXX times a non-volatile is write: 136
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 39
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 7
   depth: 2, occurrence: 2

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
********************* end of statistics **********************/

