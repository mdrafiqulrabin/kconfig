/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      4238518312
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static float g_4 = 0xC.F0EA75p+51;
static uint32_t g_16 = 4294967295U;
static float * volatile g_34 = &g_4;/* VOLATILE GLOBAL g_34 */
static int32_t g_36 = 0;
static int32_t *g_39 = (void*)0;
static int32_t ** volatile g_38 = &g_39;/* VOLATILE GLOBAL g_38 */
static float * volatile g_41 = &g_4;/* VOLATILE GLOBAL g_41 */
static float g_101 = (-0x8.Ap-1);
static int32_t g_106 = 0xF8C0E5C5;
static const int32_t * const *g_207 = (void*)0;
static int32_t *g_208 = &g_106;
static volatile float * volatile *g_222 = (void*)0;
static int32_t g_244 = 0xB6F7AEC4;
static int32_t *g_243 = &g_244;
static int32_t **g_242 = &g_243;
static float * volatile g_259 = &g_101;/* VOLATILE GLOBAL g_259 */
static const float * volatile *g_281 = (void*)0;
static const float * volatile **g_280 = &g_281;
static const float * volatile ** volatile * volatile g_279 = &g_280;/* VOLATILE GLOBAL g_279 */
static const float * volatile ** volatile * volatile * volatile g_282 = &g_279;/* VOLATILE GLOBAL g_282 */
static const float *** volatile *g_284 = (void*)0;
static const float *** volatile * volatile *g_283 = &g_284;
static uint32_t g_322 = 0x393D0794;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static int32_t * func_30(float  p_31, uint32_t  p_32);
static int32_t  func_46(int32_t ** p_47, float  p_48, int32_t  p_49);
static int32_t ** func_50(float * p_51, uint8_t  p_52, float * p_53, int32_t ** p_54, int32_t  p_55);
static float * func_56(uint32_t  p_57, int32_t * p_58, int32_t * p_59);
static int32_t * func_60(int32_t ** p_61, int32_t * p_62, float * p_63, const int32_t * const * p_64, float  p_65);
static int32_t ** func_66(int32_t * p_67, int32_t  p_68, uint8_t  p_69, int32_t  p_70);
static int16_t  func_76(float * p_77, uint8_t  p_78, int32_t  p_79);
static float * func_80(int16_t  p_81, int32_t ** p_82, uint32_t  p_83, int32_t  p_84, int16_t  p_85);
static uint16_t  func_86(const float * p_87, int16_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_34 g_38 g_39 g_36 g_41 g_242 g_259 g_243 g_106 g_279 g_282 g_283 g_16 g_244 g_322 g_208 g_101 g_222
 * writes: g_4 g_39 g_243 g_101 g_106 g_279 g_36 g_244 g_282 g_16 g_208
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    uint16_t l_33 = 1U;
    int32_t **l_37 = (void*)0;
    int32_t *l_42 = &g_36;
    float *l_273 = &g_101;
    float **l_272 = &l_273;
    float ** const *l_271 = &l_272;
    (*g_38) = func_30(g_4, l_33);
    if ((*g_39))
    { /* block id: 41 */
        int32_t l_40 = 0;
        float *l_43 = &g_4;
        (*g_41) = l_40;
        l_42 = func_30((*g_34), g_36);
        (*l_43) = (-0x1.3p+1);
        for (l_40 = 25; (l_40 < 23); --l_40)
        { /* block id: 47 */
            int16_t l_75 = 0;
            uint8_t l_253 = 0xBA;
        }
    }
    else
    { /* block id: 185 */
        uint8_t l_258 = 0U;
        uint32_t l_260 = 1U;
        int32_t l_261 = (-5);
        (*g_242) = (void*)0;
        (*g_259) = l_258;
        (*g_242) = (*g_242);
        l_261 = l_260;
    }
    if ((*l_42))
    { /* block id: 191 */
        for (g_106 = 0; (g_106 <= (-29)); --g_106)
        { /* block id: 194 */
            int32_t l_264 = 0xD7D704AD;
            return l_264;
        }
    }
    else
    { /* block id: 197 */
        const int32_t l_278 = 0;
        int32_t l_285 = (-2);
        int32_t **l_324 = &g_243;
        const uint32_t l_354 = 4294967290U;
        if ((0x2275AA4A <= ((*l_42) || ((int16_t)((uint16_t)((uint16_t)(l_271 == &l_272) << (uint16_t)g_106) - (uint16_t)((uint16_t)(((uint16_t)65535U - (uint16_t)(9U >= ((*l_42) > (0xDC5F | l_278)))) && l_278) % (uint16_t)l_278)) << (int16_t)0))))
        { /* block id: 198 */
            int32_t * const l_313 = &g_36;
            uint32_t l_321 = 1U;
            int32_t *l_329 = &l_285;
            float ***l_341 = (void*)0;
            float ****l_340 = &l_341;
            float **** const *l_339 = &l_340;
            uint32_t l_369 = 4294967292U;
            (*g_282) = g_279;
            (**l_272) = ((*g_34) <= (0x0.Ep-1 != (g_283 != &g_284)));
            if (l_285)
            { /* block id: 201 */
                const float *l_293 = &g_101;
                const float **l_292 = &l_293;
                const float ***l_291 = &l_292;
                const float **** const l_290 = &l_291;
                int32_t *l_314 = (void*)0;
                int32_t l_323 = (-1);
                float ***l_338 = &l_272;
                float **** const l_337 = &l_338;
                float **** const *l_336 = &l_337;
                if ((~(((((uint16_t)(+g_36) - (uint16_t)g_106) ^ 0x965A7D26) ^ ((void*)0 != l_290)) == ((int16_t)(2U <= (((int32_t)0xA33B8ED1 % (int32_t)((uint16_t)g_36 + (uint16_t)g_36)) <= l_278)) % (int16_t)g_16))))
                { /* block id: 202 */
                    (*g_242) = (*g_38);
                    for (g_36 = 0; (g_36 <= (-8)); g_36 -= 8)
                    { /* block id: 206 */
                        (***l_271) = (-0x2.6p-1);
                    }
                }
                else
                { /* block id: 209 */
                    const uint32_t l_306 = 1U;
                    float ***l_311 = &l_272;
                    uint32_t l_312 = 0x515C3C2E;
                    float *l_332 = &g_101;
                    l_314 = l_313;
                    if ((g_16 != ((g_36 | ((((((func_46(&l_42, (*l_313), l_306) | ((uint16_t)((int16_t)(l_306 >= (g_106 && ((uint16_t)(l_321 | l_306) - (uint16_t)g_322))) >> (int16_t)14) << (uint16_t)(*l_313))) <= g_106) || (*l_313)) < 0x2F92BE11) >= l_323) >= g_106)) > (*g_208))))
                    { /* block id: 211 */
                        l_329 = func_80(g_322, l_324, (&g_208 == &l_42), ((int32_t)((int16_t)g_16 - (int16_t)l_312) % (int32_t)((&g_39 == &g_208) && g_106)), g_106);
                    }
                    else
                    { /* block id: 213 */
                        uint16_t l_333 = 0x30FC;
                        (*l_42) = __builtin_parity(((int16_t)0x46D7 >> (int16_t)12));
                        (*g_41) = (l_332 != (void*)0);
                        l_333 = (*g_41);
                        (*g_38) = (void*)0;
                    }
                    (*l_324) = (*g_38);
                }
                for (g_244 = 0; (g_244 < 20); g_244 += 6)
                { /* block id: 223 */
                    l_339 = l_336;
                }
                (*****l_336) = (*g_259);
            }
            else
            { /* block id: 227 */
                int32_t l_375 = (-1);
                g_282 = (void*)0;
                for (g_16 = (-19); (g_16 <= 43); g_16 += 8)
                { /* block id: 231 */
                    int32_t **l_345 = &g_208;
                    int16_t l_346 = 4;
                }
            }
        }
        else
        { /* block id: 241 */
            const uint16_t l_380 = 0xF100;
            float *l_394 = &g_101;
            for (g_244 = 0; (g_244 != 9); g_244 += 9)
            { /* block id: 244 */
                (*g_242) = (*g_38);
                return g_16;
            }
            (*g_242) = func_80((((**g_38) >= (7U == (&l_271 == &g_280))) <= (((0 & ((l_285 < l_380) == l_380)) > ((uint16_t)((uint32_t)g_16 + (uint32_t)4294967295U) >> (uint16_t)0)) | 0xECD05820)), &g_208, l_380, l_380, (*l_42));
            (*l_324) = func_56((((int32_t)((int32_t)((int16_t)((+0xBF3F1525) && ((uint32_t)func_76(l_394, l_380, l_380) / (uint32_t)6)) - (int16_t)g_322) - (int32_t)(((*l_42) > g_36) >= g_36)) / (int32_t)g_244) | l_380), l_394, (*g_38));
        }
        return g_36;
    }
    (*l_42) = (*l_42);
    return g_16;
}


/* ------------------------------------------ */
/* 
 * reads : g_34
 * writes: g_4
 */
static int32_t * func_30(float  p_31, uint32_t  p_32)
{ /* block id: 37 */
    int32_t *l_35 = &g_36;
    (*g_34) = p_32;
    return l_35;
}


/* ------------------------------------------ */
/* 
 * reads : g_208 g_242 g_39 g_36 g_244 g_106
 * writes: g_243 g_39
 */
static int32_t  func_46(int32_t ** p_47, float  p_48, int32_t  p_49)
{ /* block id: 173 */
    int32_t **l_245 = &g_39;
    (*g_242) = (*p_47);
    (*l_245) = func_80((__builtin_clzll(p_49) <= __builtin_clzll(p_49)), l_245, (**l_245), (*g_39), g_244);
    return (**p_47);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_50(float * p_51, uint8_t  p_52, float * p_53, int32_t ** p_54, int32_t  p_55)
{ /* block id: 171 */
    return &g_208;
}


/* ------------------------------------------ */
/* 
 * reads : g_106 g_36 g_16 g_222 g_39 g_101
 * writes: g_106 g_36 g_39 g_101 g_208
 */
static float * func_56(uint32_t  p_57, int32_t * p_58, int32_t * p_59)
{ /* block id: 157 */
    float *l_236 = &g_101;
    const int32_t * const l_238 = &g_36;
    const int32_t * const *l_237 = &l_238;
    int32_t **l_241 = &g_208;
    for (g_106 = 20; (g_106 <= 9); g_106 -= 1)
    { /* block id: 160 */
        const int32_t l_234 = 7;
        float *l_235 = &g_101;
        for (g_36 = (-14); (g_36 != 6); g_36 += 2)
        { /* block id: 163 */
            int32_t **l_231 = &g_39;
            (*l_231) = (void*)0;
            (*l_231) = p_58;
        }
        (*l_235) = ((float)l_234 - (float)(g_16 == (__builtin_bswap32(p_57) != g_106)));
    }
    (*l_241) = func_60(&g_39, &g_36, l_236, l_237, ((((g_16 != (**l_237)) > g_36) != p_57) >= ((float)0x3.2p-1 + (float)0xA.FA72BBp-8)));
    return l_236;
}


/* ------------------------------------------ */
/* 
 * reads : g_106 g_16 g_222 g_36 g_39 g_101
 * writes: g_208
 */
static int32_t * func_60(int32_t ** p_61, int32_t * p_62, float * p_63, const int32_t * const * p_64, float  p_65)
{ /* block id: 153 */
    int16_t l_215 = 0xC445;
    int32_t **l_226 = &g_208;
    g_208 = (void*)0;
    (*l_226) = func_80(((uint32_t)(0x3E27 >= ((int16_t)(((uint16_t)g_106 >> (uint16_t)l_215) <= ((((uint16_t)g_16 + (uint16_t)((uint16_t)g_16 + (uint16_t)(__builtin_bswap32((((uint16_t)((void*)0 == g_222) >> (uint16_t)(-(int16_t)((int16_t)g_16 << (int16_t)l_215))) && g_16)) == l_215))) && 0xD2AF93AE) > g_106)) << (int16_t)l_215)) - (uint32_t)0), &g_208, g_36, (*g_39), l_215);
    return &g_36;
}


/* ------------------------------------------ */
/* 
 * reads : g_39 g_36 g_16 g_106 g_101
 * writes: g_16 g_106 g_101
 */
static int32_t ** func_66(int32_t * p_67, int32_t  p_68, uint8_t  p_69, int32_t  p_70)
{ /* block id: 48 */
    uint32_t l_89 = 7U;
    int32_t **l_185 = &g_39;
    float *l_195 = &g_101;
    int32_t **l_204 = (void*)0;
    int32_t *l_206 = &g_36;
    int32_t **l_205 = &l_206;
    p_68 = ((*g_39) == (func_76(func_80(p_69, &g_39, p_68, (func_86(p_67, (l_89 & ((uint16_t)(&g_39 != &p_67) >> (uint16_t)((p_68 == 0xC1B2) > l_89)))) >= l_89), p_70), g_36, p_69) < 0x3E9E));
    if (((0U | (l_89 != ((void*)0 != l_185))) <= ((((0x2C573671 | ((**l_185) ^ __builtin_parity(g_16))) || p_69) | (**l_185)) || (*g_39))))
    { /* block id: 140 */
        int32_t *l_187 = (void*)0;
        int32_t **l_186 = &l_187;
        (*l_186) = &g_36;
        p_67 = (*l_185);
    }
    else
    { /* block id: 143 */
        for (p_68 = 0; (p_68 <= 21); p_68 += 1)
        { /* block id: 146 */
            int32_t *l_190 = &g_106;
            uint8_t l_196 = 252U;
            int32_t l_201 = 2;
            (*l_190) = (*g_39);
            (*l_195) = (__builtin_popcountll(((int16_t)((int16_t)func_76(l_195, l_196, __builtin_bswap32(((uint32_t)((!(__builtin_ctz(((65535U && g_36) > __builtin_clz(g_106))) == (~(*l_190)))) > g_36) + (uint32_t)(**l_185)))) - (int16_t)0xEDA8) << (int16_t)l_201)) >= g_36);
        }
    }
    (*l_205) = func_80(__builtin_ctzll((**l_185)), &g_39, (4294967291U | ((((int16_t)g_106 << (int16_t)1) || g_106) <= g_106)), (*g_39), p_68);
    return &g_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_106 g_16 g_36 g_39 g_101
 * writes: g_101 g_16 g_106
 */
static int16_t  func_76(float * p_77, uint8_t  p_78, int32_t  p_79)
{ /* block id: 81 */
    int32_t *l_134 = (void*)0;
    float *l_135 = &g_101;
    int32_t l_136 = 0xB8EBACA8;
    uint32_t l_184 = 7U;
    (*l_135) = (&p_79 != l_134);
    if (l_136)
    { /* block id: 83 */
        int32_t **l_137 = &l_134;
        uint8_t l_139 = 0x68;
        int32_t *l_155 = &g_36;
        (*l_137) = &g_36;
        if ((p_78 == (((((-(int16_t)l_139) & p_78) != __builtin_ffsl(g_106)) ^ ((void*)0 == l_137)) | ((int16_t)(((uint16_t)(((uint16_t)(((-1) ^ 0x3FBE) || 0x046699CB) + (uint16_t)g_36) <= p_79) / (uint16_t)p_78) & p_79) % (int16_t)p_79))))
        { /* block id: 85 */
            int32_t *l_146 = &g_36;
            (*l_137) = l_146;
            if ((*g_39))
            { /* block id: 87 */
                const int16_t l_152 = (-1);
                (*l_137) = (void*)0;
                l_136 = (((int16_t)(((uint16_t)0xA026 / (uint16_t)(-(uint16_t)((l_152 ^ ((p_79 | ((int16_t)((void*)0 != l_155) >> (int16_t)g_16)) != (*g_39))) > (!p_78)))) > 0xCE71E83B) - (int16_t)p_78) <= (-7));
            }
            else
            { /* block id: 90 */
                uint16_t l_157 = 0x0711;
                p_79 = (*l_146);
                return l_157;
            }
            for (l_139 = 0; (l_139 > 49); l_139 += 1)
            { /* block id: 96 */
                return g_16;
            }
            for (l_136 = 25; (l_136 != 5); l_136 -= 5)
            { /* block id: 101 */
                (*l_135) = g_106;
            }
        }
        else
        { /* block id: 104 */
            (*l_135) = 0x8.577CD1p-29;
        }
    }
    else
    { /* block id: 107 */
        return l_136;
    }
    for (p_79 = 0; (p_79 < 21); p_79 += 1)
    { /* block id: 112 */
        int32_t **l_170 = &g_39;
        const int32_t *l_182 = &g_106;
        l_136 = 3;
        if (((*g_39) ^ g_36))
        { /* block id: 114 */
            uint32_t l_166 = 4294967286U;
            int32_t l_169 = (-1);
            int32_t **l_174 = &g_39;
            if (p_78)
                break;
            for (l_136 = 0; (l_136 > 22); l_136 += 1)
            { /* block id: 118 */
                const int32_t *l_168 = &g_36;
                const int32_t **l_167 = &l_168;
                if (l_166)
                    break;
                if (l_166)
                    break;
                (*l_167) = (void*)0;
                l_169 = (g_106 > g_101);
            }
            if ((*g_39))
                continue;
            if ((&l_134 == l_170))
            { /* block id: 125 */
                int16_t l_173 = 1;
                const float *l_177 = &g_101;
                int32_t *l_178 = &l_169;
                (*l_178) = ((**l_170) && ((uint16_t)func_86(func_80(__builtin_bswap32(l_173), l_174, ((-8) > (**l_174)), (**l_170), ((uint32_t)4U + (uint32_t)(func_86(l_177, (**l_174)) && p_79))), p_79) << (uint16_t)p_78));
                return g_36;
            }
            else
            { /* block id: 128 */
                int32_t **l_179 = (void*)0;
                int32_t **l_180 = &l_134;
                (*l_180) = &g_106;
            }
        }
        else
        { /* block id: 131 */
            int32_t **l_181 = &l_134;
            const int32_t **l_183 = &l_182;
            (*l_181) = &g_36;
            (*l_183) = l_182;
            return (*l_182);
        }
        l_134 = (*l_170);
    }
    return l_184;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_80(int16_t  p_81, int32_t ** p_82, uint32_t  p_83, int32_t  p_84, int16_t  p_85)
{ /* block id: 79 */
    float *l_133 = (void*)0;
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_36
 * writes: g_16 g_106 g_101
 */
static uint16_t  func_86(const float * p_87, int16_t  p_88)
{ /* block id: 49 */
    const int32_t *l_92 = &g_36;
    const int32_t **l_93 = &l_92;
    int32_t *l_121 = &g_106;
    float *l_124 = &g_101;
    float **l_123 = &l_124;
    float ***l_122 = &l_123;
    int16_t l_132 = 0x372B;
    (*l_93) = l_92;
    for (g_16 = 0; (g_16 < 58); g_16 += 6)
    { /* block id: 53 */
        float l_114 = 0xD.A13C53p-77;
        uint32_t l_115 = 0x4BD9F5B6;
        const float ***l_117 = (void*)0;
        const float *l_120 = &g_101;
        const float **l_119 = &l_120;
        const float ***l_118 = &l_119;
        for (p_88 = (-28); (p_88 > 24); p_88 += 1)
        { /* block id: 56 */
            const float *l_100 = &g_101;
            const int32_t *l_109 = (void*)0;
            int32_t *l_116 = &g_106;
        }
        (*l_118) = &p_87;
    }
    (*l_121) = (1 == 0x3524);
    (*l_124) = (((0xF.9AD701p+78 <= 0x7.50090Ep+67) >= (l_122 == &l_123)) >= ((float)((float)((((float)(+l_132) - (float)((void*)0 == (*l_93))) >= g_16) < (**l_93)) - (float)(-0x1.Ap-1)) / (float)(*l_92)));
    return p_88;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc_bytes (&g_4, sizeof(g_4), "g_4", print_hash_value);
    transparent_crc(g_16, "g_16", print_hash_value);
    transparent_crc(g_36, "g_36", print_hash_value);
    transparent_crc_bytes (&g_101, sizeof(g_101), "g_101", print_hash_value);
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc(g_244, "g_244", print_hash_value);
    transparent_crc(g_322, "g_322", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 87
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 21
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 7
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1

XXX total number of pointers: 103

XXX times a variable address is taken: 107
XXX times a pointer is dereferenced on RHS: 74
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 19
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 294

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 234
   level: 2, occurrence: 59
   level: 3, occurrence: 2
   level: 4, occurrence: 1
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 53
XXX number of pointers point to scalars: 50
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.3
XXX average alias set size: 1.26

XXX times a non-volatile is read: 425
XXX times a non-volatile is write: 148
XXX times a volatile is read: 15
XXX    times read thru a pointer: 0
XXX times a volatile is write: 9
XXX    times written thru a pointer: 1
XXX times a volatile is available for access: 49
XXX percentage of non-volatile access: 96

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 24
   depth: 2, occurrence: 23
   depth: 3, occurrence: 20
   depth: 4, occurrence: 6
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 20.1
XXX percentage an existing variable is used: 79.9
********************* end of statistics **********************/

