/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      212305364
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 24;
   unsigned f1 : 13;
   signed f2 : 27;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int16_t g_12 = 0xF8F0;
static int32_t g_47 = 0x39E6A413;
static uint32_t g_91 = 1U;
static struct S0 g_114 = {1377,86,5698};
static struct S0 *g_113 = &g_114;
static struct S0 **g_226 = &g_113;
static struct S0 ***g_225 = &g_226;
static struct S0 ****g_224 = &g_225;
static struct S0 *****g_223 = &g_224;
static int32_t *g_235 = (void*)0;
static struct S0 g_268 = {1646,17,-10942};
static uint32_t g_308 = 4294967295U;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_27(void);
static uint16_t  func_30(const uint32_t  p_31, uint32_t  p_32, int32_t  p_33);
static int16_t  func_38(const uint32_t  p_39, uint16_t  p_40);
static uint16_t  func_43(uint32_t  p_44, uint16_t  p_45);
static struct S0  func_52(int32_t * p_53, uint16_t  p_54, uint32_t  p_55, int32_t * p_56, int32_t  p_57);
static int32_t * func_58(struct S0  p_59, int32_t * p_60, int32_t  p_61, int32_t  p_62);
static int32_t * func_64(int32_t * p_65, struct S0  p_66, int32_t * p_67, int32_t * p_68);
static int32_t * func_69(uint16_t  p_70, const int32_t * p_71, int32_t  p_72);
static int16_t  func_77(uint32_t  p_78, int32_t * p_79);
static uint32_t  func_80(uint32_t  p_81, uint32_t  p_82, int32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_47 g_223 g_224 g_225 g_226 g_113 g_268.f1 g_308 g_91 g_114 g_268 g_235
 * writes: g_47 g_114 g_308 g_223 g_113 g_91 g_235 g_268 g_225
 */
static uint32_t  func_27(void)
{ /* block id: 36 */
    int32_t l_34 = 0x8108531D;
    uint32_t l_35 = 0xBEFA1E1C;
    int32_t *l_546 = &l_34;
    int32_t *l_547 = &g_47;
    int32_t **l_548 = (void*)0;
    int32_t **l_549 = &l_547;
    struct S0 *l_551 = &g_268;
    (*l_546) = ((uint16_t)func_30(g_12, l_34, ((l_35 != g_12) != ((((uint16_t)65535U << (uint16_t)(g_12 ^ func_38((((uint16_t)func_43(g_12, l_35) << (uint16_t)g_12) >= g_12), g_12))) | l_35) && 0x41E3E0AC))) >> (uint16_t)l_34);
    (*l_549) = l_547;
    (*l_551) = func_52(&g_47, g_268.f0, (+((*g_223) != (*g_223))), &g_47, (*l_546));
    return (*l_547);
}


/* ------------------------------------------ */
/* 
 * reads : g_225 g_226 g_114.f1 g_235 g_47 g_114.f0
 * writes: g_235 g_113 g_91
 */
static uint16_t  func_30(const uint32_t  p_31, uint32_t  p_32, int32_t  p_33)
{ /* block id: 343 */
    struct S0 l_532 = {3943,12,-5420};
    int32_t **l_533 = (void*)0;
    int32_t **l_534 = &g_235;
    int32_t l_545 = 0x6A14611E;
    l_532 = l_532;
    (*l_534) = &g_47;
    (**g_225) = (void*)0;
    l_532 = (((uint16_t)__builtin_popcountll(((((int16_t)g_114.f1 % (int16_t)((int32_t)((__builtin_clz(((int16_t)(**l_534) << (int16_t)func_80((((uint32_t)l_545 + (uint32_t)0U) || ((-7) & (((**l_534) || p_31) , 0U))), g_47, (**l_534)))) == g_114.f0) == 1U) + (int32_t)p_32)) || p_32) || (*g_235))) % (uint16_t)p_31) , l_532);
    return (**l_534);
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_114.f2 g_12 g_235
 * writes: g_235
 */
static int16_t  func_38(const uint32_t  p_39, uint16_t  p_40)
{ /* block id: 339 */
    uint32_t l_522 = 0xACB5187E;
    struct S0 l_523 = {1324,32,-10670};
    int32_t *l_524 = &g_47;
    uint32_t l_529 = 0x2EAA72FD;
    struct S0 ****l_530 = &g_225;
    int32_t *l_531 = &g_47;
    l_522 = (-4);
    l_531 = (l_523 , func_64(l_524, l_523, l_524, func_69((*l_524), l_524, (((uint16_t)((int32_t)l_529 - (int32_t)((void*)0 == l_530)) << (uint16_t)g_114.f2) == g_12))));
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_223 g_224 g_225 g_226 g_113 g_268.f1 g_308 g_12 g_91 g_114 g_268 g_235
 * writes: g_47 g_114 g_308 g_223 g_113 g_91 g_235 g_268 g_225
 */
static uint16_t  func_43(uint32_t  p_44, uint16_t  p_45)
{ /* block id: 37 */
    int32_t *l_46 = &g_47;
    struct S0 l_63 = {2704,36,-10507};
    struct S0 l_434 = {3865,50,-5647};
    struct S0 ***l_476 = (void*)0;
    struct S0 **l_477 = &g_113;
    int32_t l_478 = 0xEABC6239;
    struct S0 l_507 = {1096,76,7336};
    int32_t *l_519 = &g_47;
    (*l_46) = 0x6193FE69;
    for (p_45 = 26; (p_45 <= 42); p_45 += 3)
    { /* block id: 41 */
        uint16_t l_85 = 3U;
        int32_t *l_436 = &g_47;
        struct S0 l_469 = {3274,57,-7533};
        for (g_47 = 0; (g_47 < (-4)); g_47--)
        { /* block id: 44 */
            uint32_t l_92 = 4294967295U;
            int32_t *l_435 = &g_47;
            struct S0 l_468 = {2676,88,8115};
        }
        (*****g_223) = l_469;
    }
    if ((((int32_t)(((((int32_t)__builtin_popcountll((*l_46)) + (int32_t)((((void*)0 == &l_434) , (((p_44 && (-4)) ^ __builtin_bswap32((((int32_t)(l_476 != ((((void*)0 == l_477) || p_44) , (void*)0)) - (int32_t)p_45) , 4294967295U))) ^ p_44)) || l_478)) | p_44) > 0x8FA77A25) | g_268.f1) - (int32_t)0x8F73E7C0) && 1))
    { /* block id: 297 */
        uint16_t l_497 = 0x97C8;
        int32_t **l_505 = &g_235;
        struct S0 *l_506 = (void*)0;
        struct S0 l_508 = {2125,27,-6795};
        for (l_478 = (-8); (l_478 != (-8)); l_478 += 8)
        { /* block id: 300 */
            int32_t l_488 = 3;
            struct S0 l_490 = {1719,10,-3063};
            for (p_45 = 15; (p_45 >= 40); ++p_45)
            { /* block id: 303 */
                const int16_t l_504 = 0xD97D;
                for (g_308 = 0; (g_308 != 27); g_308 += 1)
                { /* block id: 306 */
                    const int16_t l_485 = 0xA8AF;
                    int16_t l_489 = 0x8787;
                    int32_t *l_503 = &g_47;
                    (*l_46) = (0U & l_485);
                    if ((*l_46))
                    { /* block id: 308 */
                        const int32_t *l_487 = &g_47;
                        const int32_t **l_486 = &l_487;
                        g_223 = &g_224;
                        (*l_486) = (void*)0;
                        (****g_223) = (***g_224);
                        if (p_45)
                            continue;
                    }
                    else
                    { /* block id: 313 */
                        int16_t l_502 = 0;
                        l_489 = l_488;
                        (*g_113) = l_490;
                        if (l_490.f1)
                            continue;
                        (*l_46) = (__builtin_parityl(((int16_t)((uint32_t)((uint32_t)(l_497 , (((int16_t)func_77(((uint16_t)__builtin_ffsl(l_502) >> (uint16_t)((l_489 & 0U) & (l_490.f2 , 65535U))), l_503) >> (int16_t)p_44) >= g_308)) + (uint32_t)l_504) - (uint32_t)1) << (int16_t)g_12)) || (*l_46));
                    }
                    return l_488;
                }
            }
        }
        (*l_505) = &g_47;
        (*g_226) = l_506;
        l_508 = l_507;
    }
    else
    { /* block id: 326 */
        int32_t **l_520 = (void*)0;
        int32_t **l_521 = &l_46;
        (*l_46) = ((int32_t)(__builtin_ctz((p_44 < (*l_46))) < (p_45 && ((p_44 != p_45) >= (((uint32_t)(*l_46) % (uint32_t)0x8EC43938) == (__builtin_clz(p_44) == p_44))))) + (int32_t)(*l_46));
        for (p_44 = 0; (p_44 != 4); p_44 += 4)
        { /* block id: 330 */
            int32_t *l_515 = &g_47;
            struct S0 *l_518 = &g_268;
            (*l_515) = (func_77(p_45, l_515) > g_47);
            g_235 = ((g_114.f2 && (*l_515)) , l_515);
            (*g_235) = ((*l_46) < (((*l_515) || p_44) >= func_80((*l_515), p_44, ((*l_46) <= (l_518 == (g_114.f1 , l_518))))));
        }
        (*l_521) = l_519;
        return p_45;
    }
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_226 g_268.f1 g_91 g_12 g_268.f0 g_114.f0 g_308
 * writes: g_113 g_91
 */
static struct S0  func_52(int32_t * p_53, uint16_t  p_54, uint32_t  p_55, int32_t * p_56, int32_t  p_57)
{ /* block id: 278 */
    struct S0 l_445 = {368,9,6190};
    int32_t l_465 = 3;
    int32_t *l_467 = &l_465;
    for (p_55 = 0; (p_55 <= 26); p_55 += 8)
    { /* block id: 281 */
        int32_t l_442 = 4;
        int32_t *l_446 = &l_442;
        struct S0 *l_449 = &l_445;
        int32_t l_466 = 0;
        (*l_446) = ((l_442 > ((*p_53) | ((int16_t)p_55 - (int16_t)g_47))) || ((l_445 , (-1)) != (p_55 == __builtin_clzl(p_54))));
        for (p_57 = 6; (p_57 > 15); p_57 += 9)
        { /* block id: 285 */
            int32_t **l_450 = &l_446;
            p_56 = func_58(l_445, func_58(l_445, &p_57, (*l_446), ((void*)0 == l_449)), g_268.f1, g_268.f1);
            (*l_449) = l_445;
            (*l_450) = &g_47;
        }
        l_467 = func_58((*l_449), &l_442, ((uint16_t)(func_80((((uint32_t)((((uint16_t)(((int16_t)((int16_t)(*l_446) >> (int16_t)((((int16_t)((g_91 ^ l_445.f0) > (((((((l_445.f2 != (*l_446)) & 0U) , (((int16_t)(__builtin_ffsll(((void*)0 != &l_445)) | (*l_446)) >> (int16_t)1) && g_12)) > g_12) < (*l_446)) ^ g_268.f0) ^ g_114.f0)) + (int16_t)l_445.f1) | (*l_446)) & p_54)) % (int16_t)p_55) < l_465) << (uint16_t)11) >= (*l_446)) <= p_54) - (uint32_t)l_445.f2) || 0x49CC), (*l_446), g_308) && l_466) << (uint16_t)g_12), (*p_53));
    }
    return l_445;
}


/* ------------------------------------------ */
/* 
 * reads : g_226
 * writes: g_113
 */
static int32_t * func_58(struct S0  p_59, int32_t * p_60, int32_t  p_61, int32_t  p_62)
{ /* block id: 273 */
    int32_t l_438 = 1;
lbl_439:
    p_59 = p_59;
    (*g_226) = (l_438 , &p_59);
    if (p_59.f0)
        goto lbl_439;
    return &g_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_64(int32_t * p_65, struct S0  p_66, int32_t * p_67, int32_t * p_68)
{ /* block id: 271 */
    int32_t *l_437 = &g_47;
    return l_437;
}


/* ------------------------------------------ */
/* 
 * reads : g_235 g_47
 * writes: g_235
 */
static int32_t * func_69(uint16_t  p_70, const int32_t * p_71, int32_t  p_72)
{ /* block id: 262 */
    int32_t *l_433 = &g_47;
    for (p_70 = (-9); (p_70 >= 10); p_70 += 4)
    { /* block id: 265 */
        int32_t *l_431 = &g_47;
        int32_t **l_432 = &g_235;
        (*l_432) = l_431;
        if ((*g_235))
            break;
        return (*l_432);
    }
    return l_433;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_12 g_91 g_113 g_114 g_223 g_225 g_226 g_224 g_268 g_308 g_235
 * writes: g_91 g_114 g_235 g_268 g_113 g_223 g_225
 */
static int16_t  func_77(uint32_t  p_78, int32_t * p_79)
{ /* block id: 53 */
    uint32_t l_96 = 1U;
    int32_t l_103 = 0x656345D1;
    int32_t l_110 = 0x7E475996;
    struct S0 *l_115 = &g_114;
    struct S0 **l_137 = &g_113;
    struct S0 ***l_136 = &l_137;
    struct S0 ****l_135 = &l_136;
    struct S0 *****l_134 = &l_135;
    struct S0 l_172 = {648,87,-9694};
    uint32_t l_198 = 3U;
    uint32_t l_209 = 7U;
    uint32_t l_220 = 0xF4B8DB84;
    int32_t *l_257 = (void*)0;
    if ((*p_79))
    { /* block id: 54 */
        struct S0 l_93 = {1096,19,9270};
        struct S0 *l_94 = &l_93;
        int32_t l_122 = 1;
        struct S0 *****l_141 = &l_135;
        (*l_94) = l_93;
        l_103 = (!((((((__builtin_bswap32(l_96) ^ (((int16_t)p_78 >> (int16_t)g_12) , g_91)) && l_96) , (+((int16_t)((__builtin_ctz(((-(int16_t)((l_93.f1 , (((-1) & __builtin_ffsll(((g_12 >= 0x1E22) , p_78))) , (*l_94))) , g_12)) , 0x21BFDB9C)) , p_78) | p_78) - (int16_t)65535U))) , g_47) || 0x6EE091E6) , (*p_79)));
        for (l_96 = 0; (l_96 > 32); l_96 += 1)
        { /* block id: 59 */
            const uint32_t l_118 = 0x19EC1828;
            int16_t l_121 = 7;
            struct S0 **l_124 = &l_94;
            struct S0 ***l_123 = &l_124;
            struct S0 *****l_125 = (void*)0;
            struct S0 ****l_127 = &l_123;
            struct S0 *****l_126 = &l_127;
            int32_t l_189 = 0x83662F39;
            if (g_47)
                break;
            (*l_123) = (((((((int16_t)func_80(g_91, ((uint16_t)l_110 << (uint16_t)((int16_t)(g_113 != l_115) >> (int16_t)0)), p_78) << (int16_t)12) != (((l_115 != (((uint16_t)l_118 << (uint16_t)((uint32_t)l_121 % (uint32_t)(-8))) , l_115)) || l_122) , 0x319DC099)) ^ l_93.f0) ^ 0x06C0A8DC) < 0x67721BC9) , &l_94);
            (*l_126) = &l_123;
            for (l_103 = 0; (l_103 == 24); ++l_103)
            { /* block id: 65 */
                const struct S0 ****l_133 = (void*)0;
                const struct S0 *****l_132 = &l_133;
                int32_t l_145 = 0x971DF810;
                int32_t *l_173 = (void*)0;
                int32_t *l_174 = &l_145;
                for (l_122 = 0; (l_122 > (-12)); l_122--)
                { /* block id: 68 */
                    int32_t l_142 = (-1);
                    uint32_t l_147 = 0xAB882180;
                    uint32_t l_159 = 0x5DD30C44;
                    if ((l_132 != l_134))
                    { /* block id: 69 */
                        int32_t **l_138 = (void*)0;
                        int32_t *l_140 = &g_47;
                        int32_t **l_139 = &l_140;
                        (*l_139) = (void*)0;
                        (*l_139) = (void*)0;
                    }
                    else
                    { /* block id: 72 */
                        int32_t *l_146 = &l_145;
                        l_134 = l_141;
                        (*g_113) = (*g_113);
                        (*l_146) = ((l_142 ^ ((uint16_t)__builtin_clzll(l_145) << (uint16_t)__builtin_ctzl(p_78))) , func_80(p_78, ((0xAB5B | (g_12 | __builtin_parityl(p_78))) < g_91), l_93.f2));
                    }
                    if (((((((2 != g_91) & p_78) >= p_78) != g_47) >= (l_147 | ((+0xB398) , (((int32_t)((uint16_t)p_78 + (uint16_t)((uint16_t)((int16_t)((int16_t)l_93.f0 << (int16_t)l_147) << (int16_t)1) % (uint16_t)g_91)) + (int32_t)0x6B01F1F5) || 0xEE8C)))) < l_159))
                    { /* block id: 77 */
                        int32_t **l_160 = (void*)0;
                        int32_t *l_162 = &l_110;
                        int32_t **l_161 = &l_162;
                        int32_t *l_171 = &l_110;
                        (*l_161) = &l_122;
                        p_79 = p_79;
                        (*l_171) = (((void*)0 == (**l_126)) , (((g_47 >= (((p_78 == ((int16_t)((((uint16_t)(((uint16_t)((uint16_t)((((void*)0 != (**l_136)) > (((__builtin_clzl(g_91) , func_80((p_78 || l_118), g_47, p_78)) | g_47) >= l_103)) , g_47) + (uint16_t)l_159) >> (uint16_t)12) < 0xF7BB3F60) - (uint16_t)p_78) != 0x057ECED5) >= p_78) - (int16_t)0xD545)) & 0x7E30) < 1)) != g_12) , 0x08C10FD0));
                    }
                    else
                    { /* block id: 81 */
                        (**l_124) = l_172;
                        return p_78;
                    }
                }
                (*l_174) = (*p_79);
                (*l_174) = ((void*)0 != (****l_141));
                if (((((g_114.f0 || ((((int16_t)((+(((((((int16_t)((void*)0 == (**l_134)) - (int16_t)(((((uint32_t)(0x354A < (l_118 | ((g_114.f1 == (__builtin_ia32_crc32qi(((int16_t)g_114.f0 << (int16_t)14), __builtin_parityll(((int16_t)p_78 >> (int16_t)p_78))) || (-9))) <= 0xF1EA))) % (uint32_t)1) == g_114.f0) , 0x0246D126) | g_114.f0)) != 0xE7B76DE9) != g_91) < 0x41723947) > (*p_79)) || l_93.f2)) & g_114.f2) << (int16_t)p_78) & 0xB5F2) ^ g_114.f1)) , l_121) && 0x7A1B735C) < p_78))
                { /* block id: 88 */
                    int32_t **l_186 = &l_173;
                    (*l_186) = (void*)0;
                }
                else
                { /* block id: 90 */
                    int32_t **l_187 = &l_174;
                    struct S0 l_197 = {685,82,-11576};
                    int32_t *l_213 = &l_110;
                    (***l_141) = &g_113;
                    (*l_187) = (void*)0;
                    if (g_91)
                    { /* block id: 93 */
                        uint16_t l_188 = 0x8D5F;
                        int32_t *l_196 = &l_145;
                        if (l_172.f2)
                            break;
                        l_189 = l_188;
                        (*l_196) = (0x0CB6 ^ (p_78 == ((((uint16_t)__builtin_parityl(g_91) << (uint16_t)0) > ((int16_t)((uint32_t)(((void*)0 == (*l_132)) == ((void*)0 == &g_113)) + (uint32_t)(*p_79)) << (int16_t)g_12)) > g_91)));
                        (*l_196) = ((6 || ((l_197 , ((g_114.f0 , 0x8918) && l_93.f1)) >= ((****l_135) , func_80(p_78, ((0xD3DD64F9 || 0xC93F04C9) && 0), l_198)))) & 0U);
                    }
                    else
                    { /* block id: 98 */
                        uint32_t l_208 = 0x7AEBA481;
                        int32_t *l_211 = &l_110;
                        g_114.f2 = ((uint32_t)(g_114.f2 != ((int16_t)func_80((((((~(&g_47 == (((func_80((((g_114.f1 | ((uint16_t)(((((uint16_t)l_208 % (uint16_t)(l_93.f2 & __builtin_parityll(p_78))) && func_80((func_80(((g_114.f1 == (p_78 != l_208)) , p_78), g_91, l_93.f0) , 0xE02E4CAB), g_114.f1, l_209)) , 0xE2AD) || g_114.f2) << (uint16_t)2)) | p_78) , p_78), p_78, l_172.f1) > 0) != 0xEA83) , (void*)0))) , (*g_113)) , 4294967290U) , (*l_187)) != (void*)0), p_78, p_78) - (int16_t)l_208)) % (uint32_t)2U);
                        g_114.f2 = ((p_78 < (~__builtin_clzll(l_121))) | p_78);
                        (*l_211) = ((*g_113) , l_122);
                    }
                    (*l_213) = ((!1U) >= p_78);
                }
            }
        }
    }
    else
    { /* block id: 107 */
        struct S0 l_214 = {3170,63,2392};
        (*g_113) = l_214;
    }
    if ((p_78 , ((g_12 < ((int16_t)((~((l_209 ^ (0x29C31756 ^ (((uint16_t)(func_80(p_78, (0xD3E824FA && 4294967291U), g_114.f2) == l_220) << (uint16_t)2) & (*p_79)))) != 0x10E7)) | g_114.f0) << (int16_t)13)) != g_12)))
    { /* block id: 110 */
        const int16_t l_231 = 0x24E1;
        int32_t **l_232 = (void*)0;
        int32_t *l_234 = (void*)0;
        int32_t **l_233 = &l_234;
        l_110 = (((((((int16_t)l_220 >> (int16_t)(p_78 == ((g_223 != &g_224) , ((((int32_t)(*p_79) % (int32_t)0xA4ED1C8C) || ((int16_t)p_78 >> (int16_t)p_78)) | 0xE25F)))) , p_78) && p_78) ^ g_91) <= 0xC19F9507) < l_231);
        (*l_233) = p_79;
        g_235 = (void*)0;
    }
    else
    { /* block id: 114 */
        int32_t *l_236 = (void*)0;
        int32_t *l_237 = &l_103;
        uint16_t l_238 = 0x68B7;
        struct S0 l_260 = {790,20,-7124};
        struct S0 ***l_301 = &g_226;
        int16_t l_322 = 0;
        struct S0 l_341 = {3588,81,-419};
        uint16_t l_392 = 0xB993;
        const struct S0 *****l_393 = (void*)0;
        int16_t l_409 = (-10);
        int32_t l_424 = 0xC0DC3151;
        (*l_237) = g_91;
lbl_405:
        (*l_237) = ((*l_237) >= (l_238 || p_78));
        if (((uint16_t)65535U >> (uint16_t)((int32_t)((int16_t)(__builtin_clzl((1U <= g_114.f0)) < g_114.f1) % (int16_t)((int16_t)__builtin_ia32_crc32qi(p_78, (((int16_t)((((uint16_t)(func_80(((int16_t)(*l_237) << (int16_t)func_80(__builtin_ctz(p_78), g_114.f1, g_47)), l_220, g_114.f1) > 0U) << (uint16_t)12) > 0x8C2B) & 0xB0658B69) << (int16_t)11) == l_172.f1)) << (int16_t)p_78)) % (int32_t)(*p_79))))
        { /* block id: 117 */
            struct S0 **l_262 = &l_115;
            const int32_t l_267 = 0x3267F2E3;
            int16_t l_296 = (-1);
            for (l_209 = 0; (l_209 == 33); l_209 += 1)
            { /* block id: 120 */
                uint32_t l_265 = 0x979C1DC0;
                int32_t l_271 = 0;
                const struct S0 l_279 = {869,12,3635};
                int32_t l_282 = 0x5D6F0B5D;
                l_172.f2 = ((int16_t)l_172.f0 - (int16_t)(l_257 != (void*)0));
                for (g_91 = 13; (g_91 <= 24); g_91 += 7)
                { /* block id: 124 */
                    struct S0 l_261 = {3795,39,-6296};
                    if (g_91)
                    { /* block id: 125 */
                        uint16_t l_266 = 65532U;
                        (*l_237) = (&g_47 == (void*)0);
                        (*****l_134) = l_260;
                        g_114.f2 = ((l_261 , (l_262 == (**g_224))) ^ ((p_78 == ((6 > ((0x5BA57C2B & ((uint16_t)l_265 - (uint16_t)(((0xFE9E != l_266) || p_78) , 0xF77B))) == l_261.f0)) >= 1U)) & l_267));
                    }
                    else
                    { /* block id: 129 */
                        int32_t **l_272 = (void*)0;
                        (***g_225) = g_268;
                        g_114.f2 = ((uint16_t)((**l_262) , l_267) + (uint16_t)(((g_114.f1 ^ l_271) ^ ((void*)0 == l_272)) <= g_114.f2));
                        if ((*p_79))
                            continue;
                    }
                    for (l_103 = 0; (l_103 < (-30)); l_103--)
                    { /* block id: 136 */
                        int32_t **l_275 = &l_236;
                        int32_t *l_276 = &l_110;
                        (*l_275) = p_79;
                        (*l_276) = (((&g_47 != (void*)0) , (*g_225)) != (*g_225));
                        (**l_262) = (*g_113);
                        if ((*l_276))
                            break;
                    }
                }
                l_282 = ((uint16_t)(p_78 >= 1) + (uint16_t)((l_279 , ((int16_t)g_268.f0 << (int16_t)5)) != 0x003B));
                for (p_78 = 26; (p_78 <= 15); p_78 -= 5)
                { /* block id: 146 */
                    int32_t **l_285 = &l_236;
                    uint16_t l_288 = 0U;
                    int32_t l_310 = 4;
                    struct S0 l_311 = {1595,23,-5633};
                    (*l_285) = p_79;
                    (*****g_223) = l_279;
                    if (((uint16_t)(func_80(l_267, g_268.f1, l_288) | (*l_236)) + (uint16_t)(g_114.f0 , (g_114.f0 == l_267))))
                    { /* block id: 149 */
                        uint32_t l_289 = 0xFFA6FDFF;
                        if ((*p_79))
                            break;
                        if (l_289)
                            continue;
                        (*l_237) = 0;
                    }
                    else
                    { /* block id: 153 */
                        int32_t l_297 = 0xF45F9F58;
                        (*l_237) = ((*l_236) , (0x10F9 & ((((l_279.f1 < g_12) & (((uint16_t)(((*l_136) == (***g_223)) , __builtin_bswap32(((((__builtin_popcount(((uint16_t)((uint16_t)((-1) | (g_12 == g_12)) >> (uint16_t)l_271) << (uint16_t)1)) && g_114.f1) >= g_12) ^ l_296) != l_297))) % (uint16_t)g_268.f2) < 0x939D)) <= g_114.f2) < p_78)));
                    }
                    if ((*p_79))
                    { /* block id: 156 */
                        int32_t l_309 = (-1);
                        l_310 = (((int16_t)(((((+0xAC17) != ((l_301 != (**g_223)) ^ ((((func_80(((uint32_t)0U % (uint32_t)(*l_236)), (g_268.f2 <= (((int16_t)(p_78 != (p_78 < (((((int32_t)((g_47 | 0xAB3DE261) && p_78) - (int32_t)g_114.f2) <= 0x8A5093E2) | 0x76006572) || g_91))) - (int16_t)p_78) ^ 1U)), l_267) && 0x7DEB) | p_78) , g_268.f2) & 0x15FB))) & 0x30F08B5B) , g_308) > 9U) >> (int16_t)p_78) && l_309);
                        (***g_225) = l_311;
                        if (l_309)
                            break;
                    }
                    else
                    { /* block id: 160 */
                        uint32_t l_321 = 2U;
                        (*l_237) = (!(((int16_t)(-6) >> (int16_t)((int16_t)(((((uint32_t)((-4) & __builtin_parity(((uint16_t)(p_78 , (&g_235 == &p_79)) % (uint16_t)65535U))) - (uint32_t)(*p_79)) , (-6)) > l_296) , l_321) + (int16_t)g_114.f0)) < 0x5267486E));
                        (*l_285) = &g_47;
                        if ((**l_285))
                            continue;
                        (*l_285) = (*l_285);
                    }
                }
            }
            (*l_134) = (*g_223);
        }
        else
        { /* block id: 169 */
            return l_322;
        }
        for (l_220 = 0; (l_220 >= 12); ++l_220)
        { /* block id: 174 */
            int32_t l_336 = 0xC3F39495;
            struct S0 *l_340 = &g_268;
            struct S0 ***l_417 = &g_226;
            for (l_209 = 0; (l_209 < 26); l_209 += 1)
            { /* block id: 177 */
                uint32_t l_327 = 1U;
                (*g_113) = (***l_301);
                g_114.f2 = ((__builtin_ffsll(l_327) ^ ((uint16_t)((p_78 || p_78) & 9) << (uint16_t)5)) == g_308);
            }
            if (((int32_t)0x7DBADD14 - (int32_t)((g_268.f1 != 0x9D6E6463) , (((int16_t)p_78 << (int16_t)((uint16_t)4U - (uint16_t)l_336)) , p_78))))
            { /* block id: 181 */
                const struct S0 l_339 = {1480,71,9391};
                for (l_209 = 0; (l_209 <= 54); l_209 += 6)
                { /* block id: 184 */
                    (**l_301) = (l_339 , l_340);
                    (*l_237) = (l_341 , (*p_79));
                }
                return l_339.f0;
            }
            else
            { /* block id: 189 */
                const int32_t *l_343 = &g_47;
                const int32_t **l_342 = &l_343;
                struct S0 *l_351 = &g_114;
                struct S0 *****l_352 = &g_224;
                int32_t l_408 = 3;
                uint32_t l_427 = 5U;
                (*l_342) = (void*)0;
                if ((*p_79))
                { /* block id: 191 */
                    int16_t l_347 = 0xB109;
                    if (((int16_t)((**g_224) != (***g_223)) >> (int16_t)14))
                    { /* block id: 192 */
                        (*l_342) = &g_47;
                        (*l_342) = p_79;
                        (*g_113) = (*l_115);
                    }
                    else
                    { /* block id: 196 */
                        (***g_224) = l_340;
                        (*l_342) = (p_78 , &g_47);
                    }
                    g_223 = &g_224;
                    (*l_342) = p_79;
                    if ((g_268.f2 , ((!0x8D65CE0A) | (&l_103 == (void*)0))))
                    { /* block id: 202 */
                        (*l_342) = (*l_342);
                        if (l_347)
                            break;
                    }
                    else
                    { /* block id: 205 */
                        (*l_237) = (-(uint16_t)((((9 && g_268.f1) , ((*p_79) , (g_114.f1 && p_78))) | p_78) , ((((uint16_t)__builtin_ia32_crc32qi(l_336, g_268.f2) >> (uint16_t)(*l_237)) , (*l_343)) ^ 0x0D1D7AFC)));
                    }
                }
                else
                { /* block id: 208 */
                    l_351 = (void*)0;
                }
                if ((1 >= ((g_268.f2 , &g_224) != l_352)))
                { /* block id: 211 */
                    int16_t l_370 = 0x6AED;
                    struct S0 *****l_399 = &l_135;
                    for (l_336 = 16; (l_336 == (-12)); l_336 -= 8)
                    { /* block id: 214 */
                        uint32_t l_365 = 4294967295U;
                        (*l_237) = ((((int16_t)(((0x7D4696B2 >= (((int16_t)(((&g_235 == &g_235) , (((int16_t)(p_78 && p_78) << (int16_t)7) || (((((int32_t)__builtin_popcountll(((l_336 , ((((((((uint32_t)(l_365 , (((***l_301) , ((uint16_t)((uint32_t)(__builtin_ctzl(((g_114.f0 && l_370) >= (*p_79))) != l_336) - (uint32_t)g_308) << (uint16_t)14)) , g_91)) + (uint32_t)p_78) >= g_268.f0) == 0x35BF) , (*l_237)) == 0x1666) || p_78) > 1U)) == g_91)) % (int32_t)(*p_79)) ^ l_370) && l_336) < (-3)))) >= 9) >> (int16_t)g_91) >= g_114.f0)) >= p_78) & l_365) >> (int16_t)13) >= 0xCA63B39A) >= 0x8960);
                        (*l_237) = (*p_79);
                    }
                    (**g_223) = (**g_223);
                    if (func_80(func_80(p_78, ((int32_t)(*p_79) % (int32_t)(*p_79)), (*l_237)), g_268.f2, g_268.f1))
                    { /* block id: 219 */
                        uint32_t l_385 = 4294967292U;
                        const struct S0 *l_404 = &l_260;
                        const struct S0 **l_403 = &l_404;
                        const struct S0 ***l_402 = &l_403;
                        const struct S0 ****l_401 = &l_402;
                        const struct S0 *****l_400 = &l_401;
                        (*l_237) = ((uint16_t)(((int16_t)(((int16_t)(((int32_t)(((int32_t)(((p_78 || ((((int16_t)g_268.f1 << (int16_t)l_385) < (g_268.f2 , (((int32_t)0xAEFC5B07 - (int32_t)((l_385 < ((int32_t)0x27A03E26 - (int32_t)(((uint16_t)__builtin_bswap64(g_91) - (uint16_t)p_78) < l_392))) > g_114.f1)) > (*p_79)))) || 65533U)) , l_370) , l_385) % (int32_t)p_78) >= 4294967293U) % (int32_t)g_308) , g_268.f2) >> (int16_t)g_308) & p_78) << (int16_t)5) <= 4294967295U) >> (uint16_t)p_78);
                        (*l_237) = ((l_393 == (void*)0) < (((((((__builtin_ctzll(p_78) <= ((((((*p_79) , ((*g_223) != (void*)0)) >= g_91) , ((!((uint16_t)(g_308 , p_78) >> (uint16_t)13)) , 65529U)) >= 0x25FE) && 0U)) ^ p_78) , (*g_225)) != (void*)0) , l_399) == l_400) & 65535U));
                    }
                    else
                    { /* block id: 222 */
                        g_235 = p_79;
                        if ((*g_235))
                            continue;
                        if (g_268.f2)
                            goto lbl_405;
                    }
                }
                else
                { /* block id: 227 */
                    int32_t *l_410 = &l_103;
                    (*l_342) = &g_47;
                    l_408 = ((uint16_t)((**l_352) != (**l_134)) << (uint16_t)12);
                    if (l_409)
                        break;
                    (*l_342) = l_410;
                }
                if (((int16_t)(l_336 < p_78) << (int16_t)((int32_t)(-9) - (int32_t)(*l_237))))
                { /* block id: 233 */
                    if (((l_336 >= __builtin_ffsll(g_268.f1)) && __builtin_popcountl((((g_268.f0 | (p_78 <= ((int16_t)l_198 << (int16_t)4))) , (*g_224)) != l_417))))
                    { /* block id: 234 */
                        struct S0 ***l_423 = &l_137;
                        (*l_342) = (func_80(__builtin_ffs((*p_79)), (((int32_t)(~g_114.f2) + (int32_t)(((uint16_t)(func_80(p_78, g_308, g_268.f1) == ((**g_223) != l_423)) + (uint16_t)g_268.f2) , l_424)) , 0x8064E77A), g_114.f1) , p_79);
                    }
                    else
                    { /* block id: 236 */
                        (**l_352) = (**g_223);
                        (*l_115) = (***l_301);
                        (*l_237) = g_268.f2;
                        (*l_342) = &g_47;
                    }
                }
                else
                { /* block id: 242 */
                    uint32_t l_426 = 4294967295U;
                    if ((~0U))
                    { /* block id: 243 */
                        if (l_426)
                            break;
                    }
                    else
                    { /* block id: 245 */
                        (*l_237) = 0xA5F404EC;
                    }
                    (*l_237) = g_308;
                    if ((*p_79))
                    { /* block id: 249 */
                        (*l_342) = (void*)0;
                        return l_427;
                    }
                    else
                    { /* block id: 252 */
                        uint32_t l_428 = 0xCD38E189;
                        return l_428;
                    }
                }
            }
            (**l_134) = l_417;
            (*l_237) = ((p_78 , (**l_417)) == (****l_134));
        }
    }
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads : g_47
 * writes: g_91
 */
static uint32_t  func_80(uint32_t  p_81, uint32_t  p_82, int32_t  p_83)
{ /* block id: 45 */
    int32_t l_90 = 0x89AFFF74;
    for (p_83 = 15; (p_83 == (-6)); p_83 -= 1)
    { /* block id: 48 */
        int16_t l_88 = 0x7797;
        return l_88;
    }
    g_91 = (!__builtin_popcount(l_90));
    return g_47;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_47, "g_47", print_hash_value);
    transparent_crc(g_91, "g_91", print_hash_value);
    transparent_crc(g_114.f0, "g_114.f0", print_hash_value);
    transparent_crc(g_114.f1, "g_114.f1", print_hash_value);
    transparent_crc(g_114.f2, "g_114.f2", print_hash_value);
    transparent_crc(g_268.f0, "g_268.f0", print_hash_value);
    transparent_crc(g_268.f1, "g_268.f1", print_hash_value);
    transparent_crc(g_268.f2, "g_268.f2", print_hash_value);
    transparent_crc(g_308, "g_308", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 111
   depth: 1, occurrence: 21
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 43
breakdown:
   indirect level: 0, occurrence: 21
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 21
breakdown:
   indirect level: 0, occurrence: 21
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 86

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 236
   depth: 2, occurrence: 32
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 6, occurrence: 1
   depth: 7, occurrence: 4
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 4
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 35, occurrence: 1
   depth: 38, occurrence: 2

XXX total number of pointers: 102

XXX times a variable address is taken: 113
XXX times a pointer is dereferenced on RHS: 113
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 18
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 90
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 7
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 343

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 447
   level: 2, occurrence: 71
   level: 3, occurrence: 29
   level: 4, occurrence: 9
   level: 5, occurrence: 15
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 22.5
XXX average alias set size: 1.17

XXX times a non-volatile is read: 764
XXX times a non-volatile is write: 262
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 199
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 28
   depth: 2, occurrence: 18
   depth: 3, occurrence: 17
   depth: 4, occurrence: 34
   depth: 5, occurrence: 71

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

