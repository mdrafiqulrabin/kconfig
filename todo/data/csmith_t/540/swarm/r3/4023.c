/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1575257146
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint8_t g_7 = 0xAA;
static int32_t g_44 = 0xFBD10CAA;
static volatile int32_t g_90[8][7] = {{(-1),0x8B108A66,0x8B108A66,(-1),1,1,1},{(-1),0x8B108A66,0x8B108A66,(-1),1,1,1},{(-1),0x8B108A66,0x8B108A66,(-1),1,1,1},{(-1),0x8B108A66,0x8B108A66,(-1),1,1,1},{(-1),0x8B108A66,0x8B108A66,(-1),1,1,1},{(-1),0x8B108A66,0x8B108A66,(-1),1,1,1},{(-1),0x8B108A66,0x8B108A66,(-1),0x2174D4A5,(-1),0x2174D4A5},{0x8B108A66,1,1,0x8B108A66,0x2174D4A5,(-1),0x2174D4A5}};
static volatile int32_t g_91 = 0x0230A264;/* VOLATILE GLOBAL g_91 */
static int32_t g_92 = (-1);
static volatile int32_t g_95[7] = {1,1,1,1,1,1,1};
static volatile int32_t g_96 = 0;/* VOLATILE GLOBAL g_96 */
static volatile int32_t g_97 = 0x056E99FD;/* VOLATILE GLOBAL g_97 */
static volatile int32_t g_98 = 0xD77138BF;/* VOLATILE GLOBAL g_98 */
static volatile int32_t g_99 = (-7);/* VOLATILE GLOBAL g_99 */
static int32_t g_100 = 0xCB3DF1C9;
static volatile int32_t g_126 = 0xBF266DE4;/* VOLATILE GLOBAL g_126 */
static volatile int32_t *g_125[7] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static volatile int32_t **g_124 = &g_125[3];
static int32_t *g_143 = &g_44;
static int32_t **g_144 = (void*)0;
static int32_t g_145 = 0x0EC7D236;
static int32_t g_148[9][9][3] = {{{0,0,7},{0xBDBB176A,0x8C892F93,0},{1,0x72618A8B,0x4C91E547},{0,(-5),0xBE94C56F},{0x24D9C5E1,(-5),0},{4,(-1),0x1BC37421},{0x8C892F93,0,0x8C892F93},{(-2),0x5E36264D,0},{0xA524B17E,0,0x104B6A6B}},{{0x87AC20A8,0x94E89909,0x7F426174},{0x8EFB8CC5,0x64D233DB,0x5C4FF8C8},{0x87AC20A8,0,0x00EF88CB},{0xA524B17E,(-1),0x33599DBF},{(-2),1,0},{0x8C892F93,0xF2BE0B92,1},{4,(-1),(-1)},{0x24D9C5E1,0xE140BD20,5},{0,0,0x23F9BE95}},{{1,0,0x87AC20A8},{0xBDBB176A,0,0x194A10B7},{0,2,0xD7A73C59},{9,0,0xFDD5005B},{0xF2BE0B92,0x8B4D8398,0xE140BD20},{0x23F9BE95,0xD7A73C59,0xE140BD20},{(-5),0xEC896690,0xFDD5005B},{0,1,0xD7A73C59},{(-1),1,0x194A10B7}},{{(-5),0x84738BD3,0x87AC20A8},{0,0x56167B9C,0x23F9BE95},{0xBE94C56F,4,5},{0x7F426174,0x33599DBF,(-1)},{0xB608A7AA,0x87AC20A8,1},{0x2B0D1CDF,0,0},{(-4),1,0x33599DBF},{5,1,0x00EF88CB},{0x194A10B7,0x4BC4670F,0x5C4FF8C8}},{{0xE848233F,(-4),0x7F426174},{1,0x4BC4670F,0x104B6A6B},{0x94E89909,1,0},{0xC02A0D86,1,0x8C892F93},{1,0,0x1BC37421},{7,0x87AC20A8,0},{1,0x33599DBF,0xBE94C56F},{0xFDD5005B,4,0x4C91E547},{0x1BC37421,0x56167B9C,0}},{{0x56167B9C,0x84738BD3,7},{0xA02C35B4,1,1},{0x72618A8B,1,0},{(-1),0xEC896690,(-1)},{0x64D233DB,0xD7A73C59,0xC02A0D86},{0x64D233DB,0x8B4D8398,0x72618A8B},{(-1),0,4},{0x72618A8B,2,0xF6C97C2B},{0xA02C35B4,0,9}},{{0x56167B9C,0,4},{0x1BC37421,0,(-1)},{2,0x194A10B7,(-2)},{(-2),0x00EF88CB,0x786D11A3},{4,0x786D11A3,(-1)},{0,0,0xF6C97C2B},{0,0x23F9BE95,0x4BC4670F},{0x4C91E547,0xE140BD20,1},{0,0xA02C35B4,(-5)}},{{0x4BC4670F,0x4C91E547,1},{0x7F426174,0xF6C97C2B,0x4BC4670F},{0xBABE52BD,0x5884173B,0xF6C97C2B},{0,(-1),(-1)},{(-1),0x87AC20A8,0x786D11A3},{0x5C4FF8C8,1,(-2)},{(-9),0x1BC37421,(-1)},{0x84738BD3,(-5),(-1)},{0x64D233DB,0,(-1)}},{{1,0x64D233DB,0x94E89909},{1,0x8B4D8398,(-1)},{0x8EFB8CC5,0x2B0D1CDF,(-5)},{0x1BC37421,0,0},{5,0,0x23F9BE95},{0x786D11A3,0x2B0D1CDF,0x56167B9C},{(-1),0x8B4D8398,0},{0x104B6A6B,0x64D233DB,4},{0x8B4D8398,0,0xE140BD20}}};
static const int32_t *g_147[2][5] = {{&g_148[6][1][1],&g_148[6][1][1],&g_148[6][1][1],&g_148[6][1][1],&g_148[6][1][1]},{&g_148[0][7][0],&g_148[0][7][0],&g_148[0][7][0],&g_148[0][7][0],&g_148[0][7][0]}};
static uint32_t g_164 = 0x39C8B3FF;
static volatile int32_t *****g_168[3] = {(void*)0,(void*)0,(void*)0};
static uint16_t g_185 = 65535U;
static int32_t g_213 = 0x3FA259D0;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_25(void);
static int32_t  func_26(int32_t  p_27, uint8_t  p_28, int32_t  p_29, uint32_t  p_30, uint8_t  p_31);
static int16_t  func_33(int16_t  p_34, int32_t  p_35, int16_t  p_36, uint32_t  p_37, const uint16_t  p_38);
inline static int32_t  func_45(int32_t ** p_46, const int32_t * p_47);
static int32_t ** func_48(uint32_t  p_49, int32_t ** p_50, int32_t ** p_51, uint32_t  p_52, int32_t  p_53);
static int32_t ** func_54(int32_t ** p_55, int32_t ** p_56);
inline static int32_t ** func_57(int32_t * p_58, int16_t  p_59, int32_t  p_60, uint32_t  p_61, int32_t * p_62);
inline static uint32_t  func_67(uint32_t  p_68, uint16_t  p_69, int32_t  p_70);
static uint16_t  func_75(const int32_t ** p_76, uint16_t  p_77, uint32_t  p_78);
inline static int32_t * func_87(int32_t ** p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_44 g_92 g_100 g_95 g_143 g_144 g_145 g_147 g_91 g_148 g_164 g_124 g_125 g_168 g_185 g_90 g_98
 * writes: g_44 g_92 g_100 g_99 g_97 g_143 g_164 g_125 g_168 g_148
 */
static uint32_t  func_25(void)
{ /* block id: 36 */
    uint8_t l_32 = 0xF2;
    uint32_t l_41[5];
    int32_t l_365 = 0x5786D4CB;
    int i;
    for (i = 0; i < 5; i++)
        l_41[i] = 0U;
    l_365 = ((func_26(g_7, l_32, l_32, (g_7 > 0x2E41), ((func_33(((uint32_t)l_32 + (uint32_t)(g_7 <= ((l_32 == l_32) >= 0x5290))), g_7, l_41[2], l_41[4], g_7) && l_41[0]) | l_32)) >= l_41[2]) || l_32);
    /* statement id: 272 */
    assert (g_143 == &g_100 || g_143 == &g_44 || (g_143 >= &g_148[0][0][0] && g_143 <= &g_148[8][8][2]));
    (*g_143) = l_41[0];
    (*g_143) = (-1);
    return g_95[6];
}


/* ------------------------------------------ */
/* 
 * reads : g_98 g_185 g_95 g_143
 * writes: g_100 g_44 g_148
 */
static int32_t  func_26(int32_t  p_27, uint8_t  p_28, int32_t  p_29, uint32_t  p_30, uint8_t  p_31)
{ /* block id: 268 */
    int32_t ***l_360 = &g_144;
    int32_t ****l_359 = &l_360;
    int32_t *****l_358 = &l_359;
    const int32_t **l_361[4] = {&g_147[1][4],&g_147[1][4],&g_147[1][4],&g_147[1][4]};
    uint32_t l_362 = 1U;
    int i;
    l_358 = l_358;
    (*g_143) = (p_27 ^ ((p_30 | ((int16_t)(g_98 != g_185) << (int16_t)14)) || g_95[5]));
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_92 g_100 g_95 g_7 g_143 g_144 g_145 g_147 g_91 g_148 g_164 g_124 g_125 g_168 g_185 g_90
 * writes: g_44 g_92 g_100 g_99 g_97 g_143 g_164 g_125 g_168
 */
static int16_t  func_33(int16_t  p_34, int32_t  p_35, int16_t  p_36, uint32_t  p_37, const uint16_t  p_38)
{ /* block id: 37 */
    int32_t **l_42 = (void*)0;
    int32_t *l_43 = &g_44;
    int32_t *l_63 = &g_44;
    int32_t l_64 = 0x4D464468;
    const int32_t *l_80 = &g_44;
    const int32_t **l_79 = &l_80;
    int16_t l_120 = (-9);
    int32_t l_170 = 0x92C9DD34;
    int32_t ***l_221[3];
    int32_t ****l_220 = &l_221[0];
    int32_t ****l_321 = &l_221[1];
    uint16_t l_350 = 0U;
    int i;
    for (i = 0; i < 3; i++)
        l_221[i] = (void*)0;
    l_43 = (void*)0;
    /* statement id: 38 */
    assert (l_43 == 0);
    if (func_45(func_48(p_34, func_54(func_57(l_63, l_64, ((uint16_t)__builtin_parityl(func_67(((int16_t)__builtin_clzl((((uint16_t)func_75(l_79, g_44, (((int16_t)(*l_63) * (int16_t)(*l_80)) | 65535U)) >> (uint16_t)2) >= 0x0E27A8D2)) + (int16_t)1U), g_7, g_7)) - (uint16_t)0x142A), l_120, &l_64), &l_43), g_144, p_37, g_145), g_147[0][2]))
    { /* block id: 113 */
        uint8_t l_169 = 1U;
        int32_t *l_175 = &g_100;
        const uint32_t l_180 = 0x1B29B62C;
        l_170 = (p_34 != l_169);
        for (l_120 = 0; (l_120 <= 18); l_120 += 8)
        { /* block id: 117 */
            uint32_t l_173 = 1U;
            int32_t *l_174[9];
            uint32_t l_204 = 0x60BB3370;
            int i;
            for (i = 0; i < 9; i++)
                l_174[i] = &g_148[0][7][0];
            l_173 = 0x814A766F;
            l_175 = l_174[6];
            /* statement id: 119 */
            assert ((l_175 >= &g_148[0][0][0] && l_175 <= &g_148[8][8][2]));
            if ((**l_79))
            { /* block id: 120 */
                for (p_37 = 2; (p_37 < 19); p_37 += 1)
                { /* block id: 123 */
                    return p_37;
                }
            }
            else
            { /* block id: 126 */
                (*l_79) = &p_35;
                /* statement id: 127 */
                assert (l_80 == &p_35);
                for (g_92 = 0; (g_92 != 15); g_92++)
                { /* block id: 130 */
                    int16_t l_186 = 0;
                    int32_t **l_203 = &l_174[7];
                    if (l_180)
                    { /* block id: 131 */
                        (*l_79) = &p_35;
                    }
                    else
                    { /* block id: 133 */
                        const int16_t l_193 = (-5);
                        (*l_63) = ((uint16_t)((p_34 || (((((int32_t)g_185 + (int32_t)((l_186 >= ((uint16_t)((((uint32_t)(*l_175) + (uint32_t)(((int16_t)(l_193 && 0x1E6A) >> (int16_t)6) <= ((uint16_t)(((!((((int16_t)0x5103 % (int16_t)((int32_t)((uint16_t)(((p_38 >= 0x441F) & p_38) ^ p_36) >> (uint16_t)1) % (int32_t)0x385FFE76)) && 1U) ^ (**l_203))) & p_38) == (**l_203)) * (uint16_t)p_35))) != p_37) != 1U) * (uint16_t)l_204)) == (*l_175))) != l_193) < (-3)) > g_90[2][4])) < p_36) % (uint16_t)l_193);
                    }
                    if (p_37)
                        break;
                }
            }
            for (l_204 = 4; (l_204 < 44); l_204++)
            { /* block id: 141 */
                int32_t l_207 = (-1);
                (*l_63) = p_34;
                if (l_207)
                    break;
            }
        }
        /* facts after for loop */
        assert (l_80 == &p_35 || l_80 == &g_92 || l_80 == &g_44);
        assert ((l_175 >= &g_148[0][0][0] && l_175 <= &g_148[8][8][2]) || l_175 == &g_100);
        (*l_63) = (*l_175);
    }
    else
    { /* block id: 147 */
        int32_t **l_212 = &g_143;
        uint16_t l_306[10][10][2] = {{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}},{{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U},{0xB8C2,0xB8C2},{0xB8C2,65530U}}};
        uint32_t l_322[8][3] = {{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259},{0U,0xA4969259,0xA4969259}};
        const int32_t ****l_327 = (void*)0;
        int32_t *****l_332 = &l_220;
        volatile int32_t *l_345[10][7][3] = {{{(void*)0,&g_95[6],&g_91},{&g_98,&g_90[2][4],&g_97},{&g_90[2][4],&g_98,&g_126},{&g_91,&g_96,&g_91},{&g_95[6],&g_95[6],&g_98},{&g_91,&g_90[4][0],(void*)0},{&g_99,&g_126,&g_97}},{{&g_95[6],&g_99,&g_95[6]},{&g_99,(void*)0,&g_98},{&g_91,&g_96,&g_90[1][6]},{&g_95[6],&g_91,&g_97},{&g_91,&g_98,&g_96},{&g_90[2][4],&g_99,&g_99},{&g_98,&g_99,(void*)0}},{{(void*)0,&g_97,(void*)0},{&g_95[2],&g_90[2][4],&g_126},{(void*)0,&g_126,&g_90[2][4]},{(void*)0,&g_98,&g_95[6]},{&g_98,(void*)0,&g_91},{&g_90[0][6],&g_95[3],&g_126},{&g_97,&g_99,&g_126}},{{(void*)0,&g_97,(void*)0},{&g_98,&g_97,&g_99},{&g_98,&g_96,&g_99},{(void*)0,&g_99,&g_98},{&g_126,&g_96,&g_97},{&g_96,&g_98,(void*)0},{&g_98,&g_97,&g_98}},{{&g_126,&g_91,&g_96},{&g_98,&g_99,(void*)0},{&g_95[6],&g_126,&g_98},{&g_95[6],&g_91,&g_91},{&g_90[2][4],(void*)0,&g_99},{&g_95[6],&g_96,&g_95[6]},{&g_95[6],&g_98,&g_98}},{{&g_95[6],&g_98,&g_90[2][4]},{&g_126,&g_98,&g_91},{(void*)0,&g_96,(void*)0},{(void*)0,(void*)0,&g_126},{&g_90[2][4],&g_91,&g_99},{&g_126,&g_126,&g_90[2][4]},{&g_99,&g_99,(void*)0}},{{&g_91,&g_91,&g_99},{&g_96,&g_97,&g_95[6]},{&g_97,&g_98,&g_98},{&g_126,&g_96,&g_98},{&g_126,&g_99,&g_99},{&g_97,&g_96,&g_97},{&g_95[6],&g_97,&g_90[2][4]}},{{&g_91,&g_97,&g_99},{&g_91,&g_96,&g_97},{&g_95[6],&g_98,(void*)0},{&g_97,&g_90[2][4],&g_95[6]},{&g_126,&g_90[4][0],&g_98},{&g_126,(void*)0,(void*)0},{&g_97,(void*)0,(void*)0}},{{&g_96,&g_91,&g_91},{&g_91,&g_96,&g_95[6]},{&g_99,&g_90[0][6],&g_96},{&g_126,(void*)0,&g_99},{&g_90[2][4],&g_90[2][4],(void*)0},{(void*)0,&g_98,&g_91},{(void*)0,&g_91,&g_97}},{{&g_126,&g_90[0][6],&g_126},{&g_95[6],(void*)0,&g_97},{&g_95[6],&g_97,&g_91},{&g_95[6],&g_97,(void*)0},{&g_90[2][4],&g_96,&g_99},{&g_95[6],&g_90[4][0],&g_96},{&g_95[6],&g_99,&g_95[6]}}};
        int i, j, k;
        p_35 = 2;
    }
    /* facts after branching */
    assert (l_43 == 0 || l_43 == &g_92);
    assert (l_80 == &p_35 || l_80 == &g_92 || l_80 == &g_44);
    assert (g_143 == &g_100 || g_143 == &g_44 || (g_143 >= &g_148[0][0][0] && g_143 <= &g_148[8][8][2]));
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads : g_91 g_95 g_148 g_164 g_143 g_100 g_44 g_124 g_125 g_168
 * writes: g_100 g_164 g_143 g_125 g_168
 */
inline static int32_t  func_45(int32_t ** p_46, const int32_t * p_47)
{ /* block id: 102 */
    int16_t l_163 = 0x075E;
    int32_t *l_167[9] = {&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2],&g_148[3][4][2]};
    int i;
    (**p_46) = ((int32_t)(((__builtin_popcount(((uint32_t)(g_91 || (((uint32_t)(((uint32_t)((uint32_t)g_95[6] % (uint32_t)g_148[5][1][1]) - (uint32_t)(&g_147[0][2] == &g_147[1][4])) != ((int32_t)0xA4C5B4E2 + (int32_t)((int16_t)g_148[0][7][0] << (int16_t)l_163))) - (uint32_t)((l_163 > l_163) ^ 0x2EE972AE)) < g_164)) - (uint32_t)(**p_46))) || 0U) < l_163) > 0x183D) % (int32_t)g_164);
    for (g_164 = 0; (g_164 == 53); g_164 += 6)
    { /* block id: 106 */
        (*p_46) = l_167[3];
        if ((*g_143))
            continue;
        (*g_124) = (*g_124);
    }
    /* facts after for loop */
    assert (g_143 == &g_100 || g_143 == &g_44 || (g_143 >= &g_148[0][0][0] && g_143 <= &g_148[8][8][2]));
    g_168[1] = g_168[1];
    return (*g_143);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_143
 */
static int32_t ** func_48(uint32_t  p_49, int32_t ** p_50, int32_t ** p_51, uint32_t  p_52, int32_t  p_53)
{ /* block id: 99 */
    int32_t *l_146 = &g_100;
    g_143 = l_146;
    /* statement id: 100 */
    assert (g_143 == &g_100);
    return &g_143;
    /* statement id: 101 */
    //assert (func_48_rv == &g_143);
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_100 g_143
 * writes: g_92 g_100 g_143
 */
static int32_t ** func_54(int32_t ** p_55, int32_t ** p_56)
{ /* block id: 83 */
    int32_t *l_138 = &g_92;
    for (g_92 = 0; (g_92 < 8); g_92 += 1)
    { /* block id: 86 */
        int32_t *l_137 = &g_100;
        int32_t **l_136 = &l_137;
        return p_56;
        /* statement id: 87 */
        //assert (func_54_rv == &l_43);
    }
    (*p_56) = l_138;
    /* statement id: 89 */
    //assert (l_43 == &g_92);
    for (g_100 = 0; (g_100 >= (-5)); g_100 -= 5)
    { /* block id: 92 */
        int32_t ***l_141 = (void*)0;
        int32_t ****l_142 = &l_141;
        (*l_138) = (**p_56);
        (*l_142) = l_141;
        g_143 = l_138;
        /* statement id: 95 */
        assert (g_143 == &g_92);
        (*g_143) = 0xB48400EC;
    }
    /* facts after for loop */
    assert (g_143 == &g_92 || g_143 == &g_44);
    return &g_143;
    /* statement id: 98 */
    //assert (func_54_rv == &g_143);
}


/* ------------------------------------------ */
/* 
 * reads : g_95 g_44
 * writes: g_92 g_100 g_99 g_97 g_44
 */
inline static int32_t ** func_57(int32_t * p_58, int16_t  p_59, int32_t  p_60, uint32_t  p_61, int32_t * p_62)
{ /* block id: 79 */
    int32_t **l_121 = (void*)0;
    const int32_t *l_123 = (void*)0;
    const int32_t **l_122 = &l_123;
    p_62 = func_87(l_121);
    /* statement id: 80 */
    assert (p_62 == &g_92 || p_62 == 0);
    (*p_58) = (*p_58);
    return l_121;
    /* statement id: 82 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_95 g_92
 * writes: g_92 g_100 g_99 g_97
 */
inline static uint32_t  func_67(uint32_t  p_68, uint16_t  p_69, int32_t  p_70)
{ /* block id: 76 */
    int32_t *l_119 = &g_100;
    int32_t **l_118 = &l_119;
    (*l_118) = func_87(l_118);
    /* statement id: 77 */
    assert (l_119 == &g_92 || l_119 == 0);
    return g_92;
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_100 g_95 g_44
 * writes: g_44 g_92 g_100 g_99 g_97
 */
static uint16_t  func_75(const int32_t ** p_76, uint16_t  p_77, uint32_t  p_78)
{ /* block id: 39 */
    int32_t l_117 = 0x266ADDA1;
    for (p_77 = 9; (p_77 != 14); ++p_77)
    { /* block id: 42 */
        for (g_44 = 3; (g_44 == 15); g_44++)
        { /* block id: 45 */
            int32_t **l_89 = (void*)0;
            (*p_76) = func_87(l_89);
            /* statement id: 66 */
            //assert (l_80 == &g_92 || l_80 == 0);
            (*p_76) = &g_92;
            /* statement id: 67 */
            //assert (l_80 == &g_92);
        }
        for (g_100 = (-16); (g_100 == 2); g_100++)
        { /* block id: 71 */
            if ((**p_76))
                break;
        }
    }
    /* facts after for loop */
    //assert (l_80 == &g_92 || l_80 == &g_44);
    return l_117;
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_100 g_95
 * writes: g_92 g_100 g_99 g_97
 */
inline static int32_t * func_87(int32_t ** p_88)
{ /* block id: 46 */
    uint32_t l_110 = 1U;
    int32_t *l_114 = &g_92;
    for (g_92 = 0; (g_92 != (-25)); g_92 -= 5)
    { /* block id: 49 */
        int32_t l_109 = 1;
        volatile int32_t **l_111 = (void*)0;
        volatile int32_t *l_113 = &g_98;
        volatile int32_t **l_112 = &l_113;
        for (g_100 = 0; (g_100 != (-9)); g_100 -= 9)
        { /* block id: 52 */
            volatile int32_t *l_103 = &g_99;
            int32_t *l_104 = (void*)0;
            (*l_103) = g_95[6];
            return l_104;
            /* statement id: 54 */
            //assert (func_87_rv == 0);
        }
        for (g_100 = (-9); (g_100 <= 4); ++g_100)
        { /* block id: 58 */
            volatile int32_t *l_108 = &g_90[4][6];
            volatile int32_t **l_107 = &l_108;
            (*l_107) = &g_90[2][4];
            g_97 = l_109;
            if (l_110)
                continue;
        }
        (*l_112) = &g_90[4][0];
        /* statement id: 63 */
        assert ((l_113 >= &g_90[0][0] && l_113 <= &g_90[7][6]));
    }
    return l_114;
    /* statement id: 65 */
    //assert (func_87_rv == &g_92);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 7; j++)
        {
            transparent_crc(g_90[i][j], "g_90[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_91, "g_91", print_hash_value);
    transparent_crc(g_92, "g_92", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_95[i], "g_95[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_96, "g_96", print_hash_value);
    transparent_crc(g_97, "g_97", print_hash_value);
    transparent_crc(g_98, "g_98", print_hash_value);
    transparent_crc(g_99, "g_99", print_hash_value);
    transparent_crc(g_100, "g_100", print_hash_value);
    transparent_crc(g_126, "g_126", print_hash_value);
    transparent_crc(g_145, "g_145", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        for (j = 0; j < 9; j++)
        {
            for (k = 0; k < 3; k++)
            {
                transparent_crc(g_148[i][j][k], "g_148[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_164, "g_164", print_hash_value);
    transparent_crc(g_185, "g_185", print_hash_value);
    transparent_crc(g_213, "g_213", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 87
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 17
   depth: 6, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 73

XXX times a variable address is taken: 155
XXX times a pointer is dereferenced on RHS: 32
breakdown:
   depth: 1, occurrence: 22
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 480

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 160
   level: 2, occurrence: 70
   level: 3, occurrence: 4
   level: 4, occurrence: 21
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 44
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 42.5
XXX average alias set size: 1.59

XXX times a non-volatile is read: 339
XXX times a non-volatile is write: 158
XXX times a volatile is read: 21
XXX    times read thru a pointer: 0
XXX times a volatile is write: 3
XXX    times written thru a pointer: 1
XXX times a volatile is available for access: 208
XXX percentage of non-volatile access: 95.4

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 68
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 17
   depth: 2, occurrence: 12
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
********************* end of statistics **********************/

