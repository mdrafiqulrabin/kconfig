/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2360527458
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   volatile float  f0;
   float  f1;
   uint16_t  f2;
   const int32_t  f3;
   uint32_t  f4;
   const uint8_t  f5;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_2 = 0x3152;
static int32_t g_11 = 0xA796D402;
static int32_t * volatile g_10 = &g_11;/* VOLATILE GLOBAL g_10 */
static int32_t g_20 = 0x60D743CC;
static int32_t * volatile g_19 = &g_20;/* VOLATILE GLOBAL g_19 */
static int32_t g_110 = (-1);
static const int32_t *g_111 = &g_110;
static int32_t *g_113 = &g_20;
static int32_t ** volatile g_112 = &g_113;/* VOLATILE GLOBAL g_112 */
static float g_124 = 0xB.39CC85p-56;
static float * volatile g_123 = &g_124;/* VOLATILE GLOBAL g_123 */
static int32_t g_135 = (-2);
static struct S0 g_146 = {0x0.EEC80Ap-94,0xC.BC1F71p-66,0xAB42,0,4294967294U,0x60};/* VOLATILE GLOBAL g_146 */
static struct S0 ** volatile g_147 = (void*)0;/* VOLATILE GLOBAL g_147 */
static struct S0 *g_149 = &g_146;
static struct S0 ** volatile g_148 = &g_149;/* VOLATILE GLOBAL g_148 */
static float * volatile g_150 = (void*)0;/* VOLATILE GLOBAL g_150 */
static float * volatile g_151 = (void*)0;/* VOLATILE GLOBAL g_151 */
static float * volatile g_153 = (void*)0;/* VOLATILE GLOBAL g_153 */
static float * volatile g_155 = &g_124;/* VOLATILE GLOBAL g_155 */
static float * volatile g_161 = (void*)0;/* VOLATILE GLOBAL g_161 */
static volatile int8_t g_220 = 0;/* VOLATILE GLOBAL g_220 */
static float ***g_231 = (void*)0;
static float ****g_230 = &g_231;
static float ***** volatile g_229 = &g_230;/* VOLATILE GLOBAL g_229 */
static struct S0 **g_323 = &g_149;
static struct S0 ***g_322 = &g_323;
static struct S0 ****g_321 = &g_322;
static volatile float *g_344 = &g_146.f0;
static volatile float **g_343 = &g_344;
static int32_t * volatile g_402 = &g_135;/* VOLATILE GLOBAL g_402 */
static int32_t * volatile g_405 = (void*)0;/* VOLATILE GLOBAL g_405 */
static int32_t * volatile g_406 = &g_110;/* VOLATILE GLOBAL g_406 */
static int32_t ** volatile g_434 = &g_113;/* VOLATILE GLOBAL g_434 */
static struct S0 g_452 = {0x2.0D7BFBp-0,0x1.Ep+1,0x8E3E,-1,1U,0x9D};/* VOLATILE GLOBAL g_452 */
static int32_t ** volatile g_478 = (void*)0;/* VOLATILE GLOBAL g_478 */
static int32_t ** volatile g_502 = &g_113;/* VOLATILE GLOBAL g_502 */
static int32_t ** volatile *g_526 = &g_434;
static int32_t ** volatile ** volatile g_525 = &g_526;/* VOLATILE GLOBAL g_525 */
static struct S0 g_632 = {-0x1.0p-1,0xC.2A60F1p-7,1U,0,0x069FD067,0xCA};/* VOLATILE GLOBAL g_632 */
static int32_t * volatile g_656 = (void*)0;/* VOLATILE GLOBAL g_656 */
static int32_t * volatile g_657 = &g_110;/* VOLATILE GLOBAL g_657 */
static int8_t g_678 = (-1);
static struct S0 ***** volatile g_696 = &g_321;/* VOLATILE GLOBAL g_696 */
static const volatile uint8_t g_725 = 0x1A;/* VOLATILE GLOBAL g_725 */
static volatile uint32_t g_763 = 6U;/* VOLATILE GLOBAL g_763 */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static int32_t * func_12(int8_t  p_13, int32_t * p_14);
static int32_t * func_15(int32_t * p_16, int32_t  p_17);
static int32_t  func_22(int32_t  p_23);
inline static uint8_t  func_26(uint16_t  p_27, int16_t  p_28, int32_t  p_29, int32_t  p_30, uint16_t  p_31);
static int32_t  func_40(uint8_t  p_41, int32_t * p_42, int32_t * p_43, uint8_t  p_44, int16_t  p_45);
inline static float  func_56(uint32_t  p_57, int32_t  p_58, int32_t * p_59);
static int32_t * func_60(float  p_61, int32_t * p_62, int16_t  p_63, uint16_t  p_64);
inline static float  func_65(int16_t  p_66, int32_t * p_67, int16_t  p_68);
static int16_t  func_75(uint8_t  p_76, const int32_t * p_77, const uint32_t  p_78, int32_t * p_79, int32_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_10 g_11 g_19 g_123 g_124 g_230 g_231 g_112 g_113 g_502 g_526 g_434 g_632.f2
 * writes: g_11 g_20 g_124 g_113
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_5 = 0xD19C9214;
    int32_t *l_18 = &g_11;
    (*g_10) = (g_2 > (g_2 == (5 & ((int32_t)(g_2 > g_2) / (int32_t)(((l_5 | (-4)) && ((int32_t)((l_5 <= (((uint8_t)(((g_2 <= l_5) == g_2) >= g_2) + (uint8_t)0xA2) < l_5)) == g_2) % (int32_t)g_2)) && 0x4D)))));
    (**g_526) = func_12(g_11, func_15(l_18, (*l_18)));
    return g_632.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_123 g_124 g_230 g_231 g_112 g_113 g_502
 * writes: g_20 g_124 g_113 g_11
 */
inline static int32_t * func_12(int8_t  p_13, int32_t * p_14)
{ /* block id: 5 */
    uint32_t l_509 = 0xAEED038F;
    struct S0 **l_514 = &g_149;
    const float *l_518 = &g_124;
    const float **l_517 = &l_518;
    float *****l_577 = &g_230;
    uint32_t l_639 = 4294967294U;
    int32_t *l_644 = &g_135;
    const uint8_t l_720 = 0xF2;
    uint32_t l_738 = 0xF91B9F54;
    float l_739 = 0x1.8p-1;
    int8_t l_762 = 0xD4;
    (*p_14) = func_22(g_2);
    return p_14;
}


/* ------------------------------------------ */
/* 
 * reads : g_19
 * writes: g_20
 */
static int32_t * func_15(int32_t * p_16, int32_t  p_17)
{ /* block id: 2 */
    int32_t *l_21 = &g_11;
    (*g_19) = ((void*)0 != &g_11);
    return l_21;
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_123 g_124 g_230 g_231 g_2 g_112 g_113 g_502
 * writes: g_20 g_124 g_113
 */
static int32_t  func_22(int32_t  p_23)
{ /* block id: 6 */
    uint32_t l_33 = 0x18BD2E84;
    int32_t *l_50 = (void*)0;
    float ***l_498 = (void*)0;
    uint8_t l_501 = 0xC7;
    for (g_20 = 0; (g_20 >= (-30)); g_20 -= 3)
    { /* block id: 9 */
        uint32_t l_51 = 4294967295U;
        int32_t *l_52 = &g_11;
        uint8_t l_475 = 0x1F;
        int32_t l_476 = 1;
        int32_t **l_485 = &l_52;
    }
    (*g_502) = func_60(((float)((float)(((float)(*g_123) - (float)(p_23 > ((((float)p_23 - (float)0x1.9p+1) != ((float)((float)l_33 / (float)((*g_230) == l_498)) / (float)((float)l_501 / (float)(((p_23 > 0x0.5AF01Ap+71) != l_33) < p_23)))) == p_23))) >= 0x9.0p-1) / (float)0x4.4D3184p-54) / (float)0xA.95D230p+62), &g_11, p_23, g_2);
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_146.f2 g_123 g_124 g_344 g_110
 * writes: g_146.f2 g_146.f0
 */
inline static uint8_t  func_26(uint16_t  p_27, int16_t  p_28, int32_t  p_29, int32_t  p_30, uint16_t  p_31)
{ /* block id: 215 */
    int32_t *l_477 = &g_20;
    int32_t **l_479 = &l_477;
    (*l_479) = l_477;
    for (g_146.f2 = (-3); (g_146.f2 > 10); g_146.f2 += 1)
    { /* block id: 219 */
        int32_t *l_482 = &g_20;
        (*l_479) = (void*)0;
        (*l_479) = l_482;
        (*g_344) = (*g_123);
    }
    return g_110;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_11 g_19 g_20 g_112 g_113 g_123 g_110 g_124 g_148 g_155 g_146.f1 g_10 g_146.f4 g_220 g_229 g_146.f2 g_135 g_402
 * writes: g_2 g_110 g_111 g_113 g_124 g_149 g_146.f1 g_135 g_230
 */
static int32_t  func_40(uint8_t  p_41, int32_t * p_42, int32_t * p_43, uint8_t  p_44, int16_t  p_45)
{ /* block id: 10 */
    const uint32_t l_55 = 0U;
    float *l_186 = &g_146.f1;
    float **l_185 = &l_186;
    int32_t *l_193 = &g_110;
    struct S0 *l_196 = &g_146;
    uint16_t l_224 = 65532U;
    float ***l_228 = &l_185;
    float ****l_227 = &l_228;
    int32_t l_232 = 1;
    int32_t l_264 = (-1);
    const struct S0 **l_374 = (void*)0;
    const struct S0 ***l_373 = &l_374;
    const struct S0 ****l_372 = &l_373;
    uint32_t l_391 = 1U;
    const int8_t l_430 = 0;
    float l_474 = 0x9.921591p+66;
    for (g_2 = 0; (g_2 <= (-2)); --g_2)
    { /* block id: 13 */
        uint32_t l_192 = 0xA743E715;
        float *l_217 = &g_146.f1;
        if ((l_55 == p_44))
        { /* block id: 14 */
            float *l_163 = &g_124;
            int32_t l_166 = 1;
            struct S0 *l_233 = &g_146;
            (*l_163) = func_56(g_2, p_41, &g_11);
            if ((p_45 ^ ((uint32_t)p_41 - (uint32_t)l_166)))
            { /* block id: 76 */
                float **l_169 = &l_163;
                int32_t l_182 = 1;
                int32_t *l_194 = &l_182;
                for (p_44 = 0; (p_44 >= 27); p_44 += 3)
                { /* block id: 79 */
                    int32_t **l_170 = &g_113;
                    int32_t *l_171 = &g_135;
                    (**l_169) = ((l_169 != l_169) < ((void*)0 != p_43));
                    (*l_170) = (*g_112);
                    (*l_171) = 0;
                    if ((*p_43))
                        continue;
                }
                (**l_185) = ((*g_155) > ((p_44 >= ((float)((float)((((float)(((float)((float)l_182 + (float)((float)(l_182 <= (l_185 != (void*)0)) + (float)l_166)) / (float)(((p_44 <= ((((((float)(-(float)((float)(&l_163 != (void*)0) + (float)p_44)) - (float)l_166) < 0xA.9B8081p+85) <= l_192) == l_192) < g_110)) >= l_182) <= 0x0.F6DFA6p-81)) != g_146.f1) / (float)p_44) > p_41) > 0xB.45B50Dp+95) - (float)0x5.A7E9ADp-22) - (float)l_166)) <= l_166));
                l_193 = (*g_112);
                (*l_194) = ((*g_10) ^ l_166);
            }
            else
            { /* block id: 88 */
                struct S0 *l_195 = &g_146;
                int32_t l_210 = (-1);
                (*l_186) = (l_195 == l_196);
                (*l_193) = ((int32_t)((g_110 || ((uint32_t)p_44 - (uint32_t)(((uint8_t)((uint16_t)((uint16_t)g_110 + (uint16_t)((((-(int16_t)((int8_t)g_110 >> (int8_t)4)) == (l_210 == g_146.f4)) ^ p_45) & (p_43 != (*l_185)))) % (uint16_t)(-1)) << (uint8_t)5) > p_41))) <= 65535U) + (int32_t)l_192);
            }
            if (l_166)
            { /* block id: 92 */
                float ***l_223 = &l_185;
                if (((int16_t)((uint16_t)l_166 << (uint16_t)(p_41 && (((uint16_t)0x11E9 - (uint16_t)(l_217 != p_42)) && (((int8_t)((g_220 || ((uint8_t)((l_223 != &l_185) | 1) << (uint8_t)l_192)) > 4294967291U) << (int8_t)3) == l_224)))) / (int16_t)p_45))
                { /* block id: 93 */
                    int32_t **l_225 = &l_193;
                    (*l_225) = (void*)0;
                }
                else
                { /* block id: 95 */
                    int32_t **l_226 = &g_113;
                    (*l_226) = (void*)0;
                }
                return (*p_43);
            }
            else
            { /* block id: 99 */
                int32_t *l_235 = (void*)0;
                int32_t *l_236 = &l_232;
                (*g_229) = l_227;
                l_232 = 0x27FBC6E3;
                (*l_236) = (((void*)0 != l_233) != (!g_110));
                if ((*p_43))
                    break;
            }
        }
        else
        { /* block id: 105 */
            const int32_t l_252 = 0xBF89ECF1;
            int32_t **l_253 = (void*)0;
            int32_t **l_254 = (void*)0;
            int32_t **l_255 = &g_113;
            (*l_193) = (-(uint8_t)((int16_t)(p_43 != l_217) + (int16_t)((int8_t)((uint16_t)((uint8_t)((g_20 | (((int8_t)1 + (int8_t)((*l_193) != ((int16_t)((((uint16_t)(0x53B8 & g_20) / (uint16_t)(p_45 & (*l_193))) >= l_252) || g_220) << (int16_t)12))) != l_252)) >= g_20) % (uint8_t)0x14) % (uint16_t)g_146.f2) - (int8_t)1)));
            (*l_255) = (void*)0;
        }
        return (*g_19);
    }
    for (p_44 = 0; (p_44 != 23); p_44 += 1)
    { /* block id: 113 */
        uint32_t l_260 = 6U;
        uint16_t l_261 = 65535U;
        int16_t l_263 = 0xF068;
        int32_t *l_269 = (void*)0;
        int32_t *l_270 = &g_135;
        (*l_186) = (((((p_44 == (((float)l_260 - (float)(l_55 != l_261)) < (p_41 != (p_45 <= (p_41 > ((+p_44) >= (((0xE.52DAF4p+80 == (-0x1.0p-1)) < l_263) > p_44))))))) == l_260) != (-0x1.Bp+1)) > 0x9.Ap+1) <= l_264);
        (*l_270) = (-(uint32_t)((+(((uint16_t)((void*)0 != (**l_227)) >> (uint16_t)((*g_112) != &g_20)) && 0xBF)) ^ l_261));
        if ((*l_270))
            break;
        p_43 = p_42;
    }
    for (p_45 = 0; (p_45 >= (-21)); --p_45)
    { /* block id: 121 */
        int16_t l_273 = (-2);
        struct S0 **l_276 = &g_149;
        const struct S0 *l_278 = &g_146;
        const struct S0 **l_277 = &l_278;
        const float ****l_290 = (void*)0;
        struct S0 ***l_320 = &l_276;
        struct S0 ****l_319 = &l_320;
        l_193 = func_60(l_273, &l_264, p_45, ((int8_t)(p_41 ^ (l_276 != l_277)) << (int8_t)6));
        (*g_112) = &l_264;
        for (p_44 = 0; (p_44 < 23); p_44 += 3)
        { /* block id: 126 */
            struct S0 ** volatile *l_282 = &g_148;
            struct S0 ** volatile **l_281 = &l_282;
            int32_t l_285 = 0x61C7848F;
            float *l_293 = &g_146.f1;
            int32_t l_314 = 0xEED22239;
            int16_t l_422 = 0xCD3A;
            const int32_t **l_435 = &g_111;
            (*l_281) = &g_148;
        }
    }
    (*g_402) = ((-9) != g_11);
    return (*g_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_2 g_19 g_20 g_112 g_113 g_123 g_124 g_148 g_155 g_110
 * writes: g_110 g_111 g_113 g_124 g_149 g_146.f1
 */
inline static float  func_56(uint32_t  p_57, int32_t  p_58, int32_t * p_59)
{ /* block id: 15 */
    uint8_t l_85 = 0x2D;
    int32_t *l_122 = (void*)0;
    int32_t *l_134 = &g_135;
    int32_t l_138 = (-3);
    int32_t *l_160 = &g_11;
    float *l_162 = &g_146.f1;
lbl_159:
    if ((&g_20 != p_59))
    { /* block id: 16 */
        const int32_t l_116 = 0x90833C0C;
        int32_t **l_125 = &g_113;
        (*l_125) = func_60(((-0x3.0p-1) == ((((0x5.0555F2p-36 >= p_57) <= func_65(((+(~(((uint16_t)((uint16_t)(func_75(p_58, &g_20, (((((int16_t)((int32_t)(((((void*)0 == &g_11) ^ g_11) & ((((-1) & g_11) >= p_58) != g_2)) <= g_11) % (int32_t)(-5)) - (int16_t)p_57) && g_2) <= l_85) <= (*g_19)), p_59, l_85) && g_20) << (uint16_t)6) << (uint16_t)1) < g_20))) >= l_116), &g_20, g_20)) < 0x1.6p+1) == l_85)), l_122, g_20, g_20);
        if (p_57)
            goto lbl_159;
    }
    else
    { /* block id: 43 */
        int32_t *l_131 = (void*)0;
        struct S0 *l_145 = &g_146;
        for (g_110 = 0; (g_110 < 26); g_110 += 8)
        { /* block id: 46 */
            const int32_t *l_133 = &g_11;
            float *l_152 = (void*)0;
            float *l_154 = (void*)0;
            for (l_85 = 0; (l_85 > 41); l_85 += 1)
            { /* block id: 49 */
                float *l_130 = &g_124;
                (*l_130) = (*g_123);
            }
            if (((void*)0 == l_131))
            { /* block id: 52 */
                int32_t *l_132 = &g_110;
                int32_t *l_136 = (void*)0;
                int32_t *l_137 = (void*)0;
                l_134 = func_60(((l_132 == (*g_112)) != g_11), l_131, p_58, ((((void*)0 != &g_113) | (l_131 != l_133)) & 0x1B));
                l_138 = 0x415013F2;
                for (p_57 = 0; (p_57 >= 14); p_57 += 1)
                { /* block id: 57 */
                    float * volatile *l_142 = &g_123;
                    float * volatile **l_141 = &l_142;
                    (*l_141) = &g_123;
                }
            }
            else
            { /* block id: 60 */
                float * volatile *l_144 = &g_123;
                float * volatile **l_143 = &l_144;
                (*l_143) = &g_123;
            }
            (*g_148) = l_145;
            (*g_155) = (*g_123);
        }
        for (g_110 = 13; (g_110 == 14); g_110 += 8)
        { /* block id: 68 */
            float *l_158 = &g_124;
            (*l_158) = (-0x1.3p-1);
        }
    }
    (*l_162) = ((void*)0 == l_160);
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads : g_123 g_112 g_113
 * writes: g_124
 */
static int32_t * func_60(float  p_61, int32_t * p_62, int16_t  p_63, uint16_t  p_64)
{ /* block id: 39 */
    (*g_123) = p_63;
    return (*g_112);
}


/* ------------------------------------------ */
/* 
 * reads : g_112 g_113
 * writes: g_113 g_110
 */
inline static float  func_65(int16_t  p_66, int32_t * p_67, int16_t  p_68)
{ /* block id: 29 */
    int32_t **l_117 = &g_113;
    uint32_t l_121 = 0xD8E54FB1;
    (*l_117) = (void*)0;
    p_67 = (*g_112);
    (*g_112) = (*l_117);
    for (p_66 = 0; (p_66 == (-5)); --p_66)
    { /* block id: 35 */
        int32_t *l_120 = &g_110;
        (*l_120) = (-6);
    }
    return l_121;
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_19 g_11 g_112
 * writes: g_110 g_111 g_113
 */
static int16_t  func_75(uint8_t  p_76, const int32_t * p_77, const uint32_t  p_78, int32_t * p_79, int32_t  p_80)
{ /* block id: 17 */
    float l_99 = 0x0.9p+1;
    const int32_t l_108 = 1;
    int32_t **l_114 = (void*)0;
    int32_t **l_115 = &g_113;
    for (p_76 = (-11); (p_76 >= 3); p_76 += 1)
    { /* block id: 20 */
        int32_t l_98 = 0xE6FF2F08;
        int32_t *l_109 = &g_110;
        (*l_109) = ((uint32_t)(((uint8_t)((0U >= ((int16_t)((int8_t)((((255U == p_80) <= (((int8_t)l_98 - (int8_t)((g_20 >= (((uint32_t)(0 & (((0x96224A10 == (((uint8_t)(((uint8_t)((uint16_t)((-1) >= ((*p_77) <= 0x27B92311)) % (uint16_t)(-1)) / (uint8_t)l_108) < p_78) >> (uint8_t)1) != l_98)) ^ (*g_19)) ^ (-4))) + (uint32_t)(-1)) ^ 0x7628)) || p_80)) ^ 0)) < g_11) | g_11) >> (int8_t)g_11) - (int16_t)p_80)) < 0) % (uint8_t)l_108) >= l_98) / (uint32_t)(-1));
        (*l_109) = (*p_79);
        if ((*g_19))
            break;
    }
    g_111 = &l_108;
    (*g_112) = &g_110;
    (*l_115) = (void*)0;
    return p_80;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_11, "g_11", print_hash_value);
    transparent_crc(g_20, "g_20", print_hash_value);
    transparent_crc(g_110, "g_110", print_hash_value);
    transparent_crc_bytes (&g_124, sizeof(g_124), "g_124", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc_bytes (&g_146.f0, sizeof(g_146.f0), "g_146.f0", print_hash_value);
    transparent_crc_bytes (&g_146.f1, sizeof(g_146.f1), "g_146.f1", print_hash_value);
    transparent_crc(g_146.f2, "g_146.f2", print_hash_value);
    transparent_crc(g_146.f3, "g_146.f3", print_hash_value);
    transparent_crc(g_146.f4, "g_146.f4", print_hash_value);
    transparent_crc(g_146.f5, "g_146.f5", print_hash_value);
    transparent_crc(g_220, "g_220", print_hash_value);
    transparent_crc_bytes (&g_452.f0, sizeof(g_452.f0), "g_452.f0", print_hash_value);
    transparent_crc_bytes (&g_452.f1, sizeof(g_452.f1), "g_452.f1", print_hash_value);
    transparent_crc(g_452.f2, "g_452.f2", print_hash_value);
    transparent_crc(g_452.f3, "g_452.f3", print_hash_value);
    transparent_crc(g_452.f4, "g_452.f4", print_hash_value);
    transparent_crc(g_452.f5, "g_452.f5", print_hash_value);
    transparent_crc_bytes (&g_632.f0, sizeof(g_632.f0), "g_632.f0", print_hash_value);
    transparent_crc_bytes (&g_632.f1, sizeof(g_632.f1), "g_632.f1", print_hash_value);
    transparent_crc(g_632.f2, "g_632.f2", print_hash_value);
    transparent_crc(g_632.f3, "g_632.f3", print_hash_value);
    transparent_crc(g_632.f4, "g_632.f4", print_hash_value);
    transparent_crc(g_632.f5, "g_632.f5", print_hash_value);
    transparent_crc(g_678, "g_678", print_hash_value);
    transparent_crc(g_725, "g_725", print_hash_value);
    transparent_crc(g_763, "g_763", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 135
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 22
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 159

XXX times a variable address is taken: 156
XXX times a pointer is dereferenced on RHS: 122
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 11
   depth: 3, occurrence: 9
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 105
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 19
XXX times a pointer is qualified to be dereferenced: 480

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 369
   level: 2, occurrence: 76
   level: 3, occurrence: 31
   level: 4, occurrence: 18
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 77
XXX number of pointers point to scalars: 73
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 26.4
XXX average alias set size: 1.23

XXX times a non-volatile is read: 776
XXX times a non-volatile is write: 258
XXX times a volatile is read: 61
XXX    times read thru a pointer: 7
XXX times a volatile is write: 38
XXX    times written thru a pointer: 16
XXX times a volatile is available for access: 302
XXX percentage of non-volatile access: 91.3

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 88
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 20
   depth: 2, occurrence: 11
   depth: 3, occurrence: 17
   depth: 4, occurrence: 7

XXX percentage a fresh-made variable is used: 15.4
XXX percentage an existing variable is used: 84.6
********************* end of statistics **********************/

