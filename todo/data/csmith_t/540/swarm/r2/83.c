/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3242010806
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 9;
   unsigned f1 : 26;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = 0x1C08901F;
static int32_t g_106 = 0x171C63CC;
static float g_124 = 0xF.699391p+88;
static struct S0 g_136 = {21,3202};
static struct S0 *g_135 = &g_136;
static struct S0 **g_134 = &g_135;
static struct S0 g_141 = {12,1139};
static int32_t g_145 = 0xE3F2B594;
static int32_t *g_144 = &g_145;
static struct S0 ***g_155 = &g_134;
static int32_t **g_257 = &g_144;
static int32_t ***g_256 = &g_257;
static int32_t ****g_255 = &g_256;
static float *g_279 = &g_124;
static float **g_278 = &g_279;
static float ***g_356 = &g_278;
static float ****g_355 = &g_356;
static int16_t g_361 = (-1);
static float g_522 = 0x2.08FB90p-8;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_25(void);
static struct S0  func_26(struct S0  p_27, uint32_t  p_28, uint16_t  p_29, uint16_t  p_30, int16_t  p_31);
static struct S0  func_32(uint8_t  p_33, uint8_t  p_34);
inline static struct S0  func_39(int16_t  p_40, uint32_t  p_41, int32_t  p_42, uint32_t  p_43, struct S0  p_44);
inline static int32_t  func_45(uint16_t  p_46);
inline static int16_t  func_57(struct S0  p_58, int32_t  p_59, int32_t  p_60);
static struct S0  func_61(int16_t  p_62, struct S0  p_63);
inline static struct S0  func_64(int32_t  p_65, int32_t  p_66, uint8_t  p_67, uint8_t  p_68, uint32_t  p_69);
inline static struct S0  func_84(uint32_t  p_85, uint16_t  p_86);
inline static uint32_t  func_87(uint16_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_141.f0 g_361 g_136.f1 g_256 g_257 g_255 g_144 g_145 g_136.f0 g_134 g_135 g_136 g_141.f1 g_106 g_155 g_355 g_356
 * writes: g_3 g_144 g_106 g_145 g_278 g_361 g_255 g_136
 */
inline static int32_t  func_25(void)
{ /* block id: 36 */
    uint16_t l_35 = 65535U;
    struct S0 l_484 = {18,8133};
    (***g_155) = func_26(func_32(l_35, ((int32_t)(4294967295U >= (((!g_3) || (func_39((func_45(l_35) != (((int16_t)((uint32_t)(l_35 <= ((int16_t)func_57(l_484, (__builtin_bswap32(((uint16_t)g_141.f0 % (uint16_t)__builtin_popcount((l_484.f1 > 0xAD7A)))) , g_361), g_136.f1) << (int16_t)1)) / (uint32_t)l_35) >> (int16_t)l_484.f1) , 0xC8072DA9)), g_136.f0, l_484.f0, l_484.f1, (**g_134)) , g_141.f0)) < l_484.f1)) / (int32_t)l_484.f1)), g_141.f1, l_35, l_484.f0, g_136.f1);
    /* statement id: 358 */
    assert (g_144 == 0 || g_144 == &g_106);
    return g_136.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_255 g_256 g_257 g_144 g_145 g_355 g_356 g_141.f0 g_361 g_134 g_135 g_136 g_155 g_141.f1 g_106 g_3
 * writes: g_144 g_145 g_278 g_361 g_255 g_136 g_3 g_106
 */
static struct S0  func_26(struct S0  p_27, uint32_t  p_28, uint16_t  p_29, uint16_t  p_30, int16_t  p_31)
{ /* block id: 325 */
    float l_494 = 0xA.DB3E37p-6;
    int32_t l_495 = 6;
    struct S0 ***l_521 = &g_134;
    (***g_255) = (***g_255);
    if ((p_29 == l_495))
    { /* block id: 327 */
        int32_t *****l_498 = &g_255;
        float **l_499 = &g_279;
        int32_t l_509 = 0x79C8DCF0;
        for (g_145 = (-8); (g_145 < (-10)); g_145 -= 9)
        { /* block id: 330 */
            l_498 = &g_255;
        }
        (**g_355) = l_499;
        for (p_31 = (-4); (p_31 > 22); p_31++)
        { /* block id: 336 */
            int32_t l_506 = 9;
            int32_t *l_510 = &l_506;
            uint32_t l_513 = 4294967295U;
            (*g_257) = (****l_498);
            if (((((p_31 > (l_495 , (p_29 != ((uint16_t)((int16_t)g_145 - (int16_t)l_506) << (uint16_t)((int16_t)0 + (int16_t)g_141.f0))))) , 1U) , l_495) && l_509))
            { /* block id: 338 */
                l_510 = &l_506;
                for (g_361 = 0; (g_361 <= (-10)); g_361 -= 4)
                { /* block id: 342 */
                    int32_t *l_514 = (void*)0;
                    l_513 = (-9);
                    (**g_256) = l_514;
                }
                return (**g_134);
            }
            else
            { /* block id: 347 */
                (*l_498) = (*l_498);
            }
            (***g_255) = (****l_498);
        }
    }
    else
    { /* block id: 352 */
        return (***g_155);
    }
    (*g_135) = func_32((((((int32_t)__builtin_parity(__builtin_popcountll(((p_28 != (((uint16_t)(g_136.f0 , ((int16_t)p_29 - (int16_t)((((((((l_495 , l_521) == &g_134) <= (g_136.f0 == g_141.f1)) , (*g_134)) == (void*)0) && p_27.f1) | p_28) , g_106))) >> (uint16_t)10) , g_141.f0)) < 0x59B5))) / (int32_t)l_495) , 0x8CFD0680) | 0xAC569D01) ^ g_361), l_495);
    l_495 = ((1 < (0xDD3DAC44 != func_57(p_27, (-(uint16_t)((int16_t)p_30 % (int16_t)func_45((__builtin_ctzll(l_495) || g_361)))), p_27.f0))) && (*g_144));
    /* statement id: 356 */
    assert (g_144 == &g_106);
    return (***l_521);
}


/* ------------------------------------------ */
/* 
 * reads : g_255 g_256 g_257 g_155 g_134 g_135 g_136
 * writes: g_144
 */
static struct S0  func_32(uint8_t  p_33, uint8_t  p_34)
{ /* block id: 321 */
    int32_t *l_492 = (void*)0;
    struct S0 *l_493 = &g_136;
    (***g_255) = l_492;
    /* statement id: 322 */
    assert (g_144 == 0);
    l_493 = (**g_155);
    return (*l_493);
}


/* ------------------------------------------ */
/* 
 * reads : g_141.f1 g_106 g_256 g_257 g_144 g_135 g_136
 * writes: g_106
 */
inline static struct S0  func_39(int16_t  p_40, uint32_t  p_41, int32_t  p_42, uint32_t  p_43, struct S0  p_44)
{ /* block id: 317 */
    uint16_t l_487 = 4U;
    l_487 = p_44.f0;
    (***g_256) = (((uint32_t)0x6C9223B5 / (uint32_t)g_141.f1) , ((l_487 < (g_106 == ((int32_t)l_487 % (int32_t)l_487))) && (***g_256)));
    return (*g_135);
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes: g_3
 */
inline static int32_t  func_45(uint16_t  p_46)
{ /* block id: 37 */
    int16_t l_460 = 0;
    struct S0 ****l_472 = (void*)0;
    for (p_46 = 0; (p_46 == 34); p_46 += 1)
    { /* block id: 40 */
        int32_t l_82 = 5;
        int16_t l_83 = 0x69E5;
        float l_459 = 0x2.0D3EC3p-12;
        for (g_3 = 0; (g_3 <= (-30)); g_3 -= 3)
        { /* block id: 43 */
            uint8_t l_81 = 0x60;
            int32_t l_447 = (-3);
            int32_t *l_448 = &g_145;
            struct S0 l_467 = {4,2522};
            struct S0 ****l_471 = &g_155;
        }
    }
    return l_460;
}


/* ------------------------------------------ */
/* 
 * reads : g_256 g_257 g_255 g_144 g_145
 * writes: g_144 g_106
 */
inline static int16_t  func_57(struct S0  p_58, int32_t  p_59, int32_t  p_60)
{ /* block id: 292 */
    struct S0 l_445 = {11,7132};
    int32_t *l_446 = &g_106;
    (**g_256) = (l_445 , l_446);
    /* statement id: 293 */
    assert (g_144 == &g_106);
    (****g_255) = 1;
    return g_145;
}


/* ------------------------------------------ */
/* 
 * reads : g_279 g_124 g_278 g_144 g_145
 * writes: g_124 g_106 g_145
 */
static struct S0  func_61(int16_t  p_62, struct S0  p_63)
{ /* block id: 247 */
    float l_379 = 0x0.6p+1;
    struct S0 **l_382 = &g_135;
    int32_t l_385 = 0x61162396;
    for (p_62 = 0; (p_62 < 21); p_62 += 1)
    { /* block id: 250 */
        float l_390 = 0xB.28CA09p-72;
        struct S0 ***l_391 = &g_134;
        int32_t l_401 = 0x85F6979F;
        int32_t l_402 = 0x6FFC55F3;
        uint32_t l_424 = 4U;
        (**g_278) = ((float)(l_379 < 0xC.D1AA81p+47) - (float)((float)(p_63.f1 > ((void*)0 != l_382)) + (float)((float)(l_385 < ((float)((float)l_390 + (float)(((&g_134 != l_391) != (*g_279)) >= l_385)) / (float)p_62)) + (float)(-0x1.Bp-1))));
        (*g_144) = l_385;
        for (g_145 = (-24); (g_145 != 16); g_145 += 4)
        { /* block id: 255 */
            uint16_t l_405 = 0x6857;
            int32_t l_406 = 1;
            float *l_418 = &l_379;
        }
    }
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_106 g_134 g_141 g_135 g_145 g_136.f0 g_136 g_124 g_255 g_256 g_257 g_278 g_279 g_144
 * writes: g_106 g_124 g_134 g_136 g_144 g_155 g_145 g_141 g_278
 */
inline static struct S0  func_64(int32_t  p_65, int32_t  p_66, uint8_t  p_67, uint8_t  p_68, uint32_t  p_69)
{ /* block id: 44 */
    struct S0 l_91 = {1,2867};
    int32_t *l_306 = &g_106;
    float l_311 = 0x0.5p-1;
    int32_t l_330 = (-10);
    struct S0 l_373 = {3,361};
    (*g_135) = func_84(func_87((((int16_t)0xA6A8 << (int16_t)4) , (((l_91 , ((int16_t)(((((((float)g_3 * (float)((float)l_91.f0 - (float)(p_66 != ((float)(((((float)((float)(l_91.f1 < p_67) - (float)(((-0x8.8p+1) <= 0x1.Ap-1) != g_3)) - (float)l_91.f0) <= p_67) > g_3) >= p_65) * (float)0x1.Fp+1)))) < g_3) >= g_3) > (-0x1.Dp-1)) != g_3) , 0) >> (int16_t)3)) < g_3) <= 0U))), l_91.f1);
    /* statement id: 190 */
    assert (g_144 == &g_106 || g_144 == 0 || g_144 == &g_145);
    assert (g_155 == &g_134 || g_155 == 0);
    (*g_257) = l_306;
    /* statement id: 191 */
    assert (g_144 == &g_106);
    (**g_278) = (((float)((((uint16_t)(*l_306) % (uint16_t)((int16_t)(((uint16_t)(*l_306) >> (uint16_t)(*l_306)) >= (((uint16_t)((p_65 > ((int16_t)((int32_t)(((((int16_t)((int16_t)__builtin_popcount((*l_306)) * (int16_t)0x3FF2) + (int16_t)((uint16_t)((((*l_306) & ((uint32_t)g_141.f0 % (uint32_t)p_69)) , (****g_255)) & g_136.f0) * (uint16_t)l_330)) != (****g_255)) != p_65) && p_67) - (int32_t)p_69) * (int16_t)g_136.f0)) || 0xD0B48FF0) / (uint16_t)(*l_306)) <= 0)) * (int16_t)(-5))) , (void*)0) != &l_91) * (float)(**g_278)) <= (*l_306));
    for (p_69 = 0; (p_69 > 19); p_69 += 1)
    { /* block id: 195 */
        int32_t l_349 = 0x816DE6D4;
        struct S0 l_354 = {13,3344};
        uint8_t l_366 = 250U;
    }
    return (*g_135);
}


/* ------------------------------------------ */
/* 
 * reads : g_278 g_279 g_124
 * writes: g_124 g_278
 */
inline static struct S0  func_84(uint32_t  p_85, uint16_t  p_86)
{ /* block id: 181 */
    float ***l_304 = &g_278;
    struct S0 l_305 = {3,3256};
    if (p_86)
    { /* block id: 182 */
        uint32_t l_299 = 4294967295U;
        (**g_278) = (**g_278);
        l_299 = p_85;
    }
    else
    { /* block id: 185 */
        uint32_t l_300 = 0xAC87C860;
        int32_t l_303 = 0x3AEC1CF4;
        l_303 = (l_300 | (1 || (0xDAB2 < p_86)));
    }
    (*l_304) = &g_279;
    return l_305;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_106 g_134 g_141 g_135 g_145 g_136.f0 g_136 g_124 g_255 g_256 g_257 g_278
 * writes: g_106 g_124 g_134 g_136 g_144 g_155 g_145 g_141
 */
inline static uint32_t  func_87(uint16_t  p_88)
{ /* block id: 45 */
    uint32_t l_109 = 4294967295U;
    int32_t *l_127 = (void*)0;
    struct S0 l_132 = {19,6310};
    struct S0 ***l_156 = (void*)0;
    int16_t l_236 = 0x44B7;
    int32_t ****l_261 = &g_256;
    float *l_265 = (void*)0;
    for (p_88 = (-13); (p_88 > 37); p_88 += 7)
    { /* block id: 48 */
        int32_t l_115 = 0xFE055878;
        int32_t *l_139 = (void*)0;
        uint16_t l_151 = 1U;
        struct S0 *l_157 = &g_141;
        for (g_106 = 0; (g_106 != 15); g_106 += 3)
        { /* block id: 51 */
            uint32_t l_114 = 4294967287U;
            if ((0xE2C279A1 == ((__builtin_clzl(g_3) ^ p_88) & ((((l_109 < l_109) >= ((0xC819A802 > 0x67125BDF) && ((int16_t)((((((((float)p_88 + (float)0x9.5p-1) , 3) <= l_114) ^ g_3) || g_3) && p_88) != g_3) - (int16_t)0x0790))) != g_3) ^ g_3))))
            { /* block id: 52 */
                int32_t *l_117 = &g_106;
                int32_t **l_116 = &l_117;
                uint16_t l_138 = 0x4C76;
                if (l_115)
                    break;
                (*l_116) = &g_106;
                for (l_115 = 12; (l_115 < (-22)); l_115--)
                { /* block id: 57 */
                    struct S0 ***l_137 = &g_134;
                    for (l_114 = 21; (l_114 >= 54); l_114++)
                    { /* block id: 60 */
                        return g_106;
                    }
                    if ((0x1E931266 && (__builtin_parityll(p_88) >= g_106)))
                    { /* block id: 63 */
                        if (l_109)
                            break;
                    }
                    else
                    { /* block id: 65 */
                        float *l_122 = (void*)0;
                        float *l_123 = &g_124;
                        int32_t l_131 = 1;
                        struct S0 *l_133 = &l_132;
                        (*l_123) = 0xF.9381DCp+36;
                        (*l_133) = (((int32_t)(&g_106 != l_127) - (int32_t)(((!p_88) > g_3) , (((uint16_t)((p_88 < 0xAF5201FE) && (__builtin_ffs(l_131) >= l_115)) >> (uint16_t)l_131) || g_106))) , l_132);
                        if (g_3)
                            break;
                    }
                    (*l_137) = g_134;
                    g_124 = l_138;
                }
            }
            else
            { /* block id: 73 */
                int32_t **l_140 = &l_127;
                l_127 = &g_106;
                /* statement id: 74 */
                assert (l_127 == &g_106);
                (*l_140) = l_139;
                /* statement id: 75 */
                assert (l_127 == 0);
            }
            (**g_134) = g_141;
            for (l_115 = 16; (l_115 <= 7); l_115 -= 1)
            { /* block id: 80 */
                int32_t **l_146 = &g_144;
                g_144 = (l_114 , &g_106);
                /* statement id: 81 */
                assert (g_144 == &g_106);
                (*l_146) = l_139;
                /* statement id: 82 */
                assert (g_144 == 0);
            }
        }
        if ((__builtin_popcountl((((int16_t)g_145 >> (int16_t)((((uint16_t)((g_145 , 1U) & l_132.f0) >> (uint16_t)(p_88 == 0x8EC7F2D8)) ^ l_151) > p_88)) >= (((-(int16_t)1) , &g_144) == (void*)0))) , 0x0A132677))
        { /* block id: 85 */
            struct S0 ***l_153 = (void*)0;
            struct S0 ****l_154 = (void*)0;
            int32_t l_206 = 0x90D9D044;
            float *l_211 = &g_124;
            float **l_210 = &l_211;
            int32_t l_221 = 0x8C1170D4;
            g_155 = l_153;
            /* statement id: 86 */
            assert (g_155 == 0);
            if ((p_88 < ((&g_134 == l_156) < (g_141.f0 <= ((*g_134) != l_157)))))
            { /* block id: 87 */
                int32_t *l_158 = &g_145;
                int32_t l_166 = (-1);
                float *l_167 = (void*)0;
                float *l_186 = &g_124;
                (*l_158) = p_88;
                if (g_106)
                { /* block id: 89 */
                    int32_t **l_159 = &l_139;
                    (*l_159) = l_158;
                    /* statement id: 90 */
                    assert (l_139 == &g_145);
                    for (l_151 = 14; (l_151 > 35); l_151 += 4)
                    { /* block id: 93 */
                        float *l_170 = &g_124;
                        g_144 = &g_106;
                        /* statement id: 94 */
                        assert (g_144 == &g_106);
                        (*l_170) = (((g_141.f0 , ((float)((0x1.0p+1 < g_136.f0) >= ((float)p_88 - (float)l_166)) + (float)(g_3 == ((l_167 != (void*)0) >= ((float)(p_88 , g_145) * (float)g_145))))) > (-0x1.4p+1)) <= g_141.f1);
                    }
                    (*l_159) = &g_145;
                }
                else
                { /* block id: 98 */
                    (*l_158) = p_88;
                    if (p_88)
                    { /* block id: 100 */
                        float *l_171 = (void*)0;
                        float *l_172 = &g_124;
                        if (g_141.f1)
                            break;
                        (*l_172) = 0x0.5p-1;
                        if (p_88)
                            break;
                        (*l_158) = 0x3997128C;
                    }
                    else
                    { /* block id: 105 */
                        (**g_134) = (*g_135);
                    }
                }
                /* facts after branching */
                assert (l_139 == 0 || l_139 == &g_145);
                (*l_186) = ((float)(((((int32_t)((int16_t)(((int16_t)g_141.f0 << (int16_t)g_145) , (-5)) >> (int16_t)(((int16_t)(!g_136.f0) / (int16_t)0x77F6) < __builtin_ctz(((*g_135) , (g_124 , ((uint16_t)((g_145 , __builtin_ffs(p_88)) & p_88) << (uint16_t)g_136.f0)))))) - (int32_t)1) , 0x0.E1251Bp-85) == (*l_158)) < (-0x1.Ap+1)) * (float)(*l_158));
                l_158 = &g_106;
                /* statement id: 110 */
                assert (l_158 == &g_106);
            }
            else
            { /* block id: 111 */
                struct S0 l_208 = {12,2150};
                for (l_109 = 22; (l_109 != 30); l_109 += 1)
                { /* block id: 114 */
                    int32_t **l_222 = &l_139;
                    if (((int32_t)0xC8E435D7 + (int32_t)((uint16_t)__builtin_popcountl(p_88) >> (uint16_t)p_88)))
                    { /* block id: 115 */
                        uint32_t l_205 = 0U;
                        int32_t *l_207 = &g_145;
                        struct S0 l_209 = {7,7601};
                        float ***l_212 = &l_210;
                        (*l_207) = (((uint32_t)((int16_t)__builtin_bswap64(p_88) / (int16_t)((((((float)(((p_88 ^ ((int16_t)p_88 - (int16_t)g_141.f1)) , p_88) <= ((float)0xD.5083F6p+44 * (float)((((float)(((__builtin_popcount(p_88) , (void*)0) != (void*)0) > (-0x9.7p+1)) - (float)0x9.A53846p-67) != g_136.f1) < l_205))) - (float)g_124) , g_136.f1) , (void*)0) == l_139) , l_206)) + (uint32_t)l_205) & g_136.f0);
                        (*g_135) = l_208;
                        (**g_134) = l_209;
                        (*l_212) = l_210;
                    }
                    else
                    { /* block id: 120 */
                        g_106 = ((int16_t)((int16_t)(((l_208 , (l_208.f1 , p_88)) <= 1U) & ((uint16_t)l_206 >> (uint16_t)((uint16_t)p_88 >> (uint16_t)8))) << (int16_t)3) * (int16_t)__builtin_ffsll(p_88));
                    }
                    (*l_222) = ((((void*)0 == &l_157) || ((((g_3 , g_141.f1) & (p_88 , l_221)) , p_88) , g_141.f0)) , &g_106);
                    /* statement id: 123 */
                    assert (l_139 == &g_106);
                    l_208 = l_208;
                }
                /* facts after for loop */
                assert (l_139 == &g_106 || l_139 == 0);
            }
            /* facts after branching */
            assert (l_139 == &g_106 || l_139 == 0 || l_139 == &g_145);
            if ((((uint16_t)(((uint32_t)((uint32_t)g_141.f0 - (uint32_t)((uint16_t)((int32_t)p_88 + (int32_t)(g_106 , (p_88 ^ p_88))) * (uint16_t)__builtin_popcountll(((int32_t)(-(int16_t)(l_221 >= l_236)) + (int32_t)(p_88 && (~l_132.f1)))))) + (uint32_t)g_141.f0) > 0x08B9188F) << (uint16_t)p_88) , g_141.f0))
            { /* block id: 127 */
                for (g_106 = 0; (g_106 == (-21)); g_106--)
                { /* block id: 130 */
                    int32_t **l_241 = (void*)0;
                    int32_t ***l_240 = &l_241;
                    (*l_240) = &g_144;
                    /* statement id: 131 */
                    assert (l_241 == &g_144);
                }
            }
            else
            { /* block id: 133 */
                return p_88;
            }
            for (l_236 = 0; (l_236 >= (-26)); l_236 -= 1)
            { /* block id: 138 */
                (*l_157) = (*g_135);
            }
        }
        else
        { /* block id: 141 */
            int32_t **l_244 = (void*)0;
            int32_t **l_245 = &l_127;
            struct S0 *l_251 = &g_141;
            (*l_245) = &g_106;
            /* statement id: 142 */
            assert (l_127 == &g_106);
            if ((!((*l_127) > ((g_141.f1 , (*l_127)) == (__builtin_parityll(((uint32_t)((*l_127) != (g_136.f1 | ((void*)0 != l_139))) / (uint32_t)((int16_t)((void*)0 != l_251) % (int16_t)0x4A45))) , g_141.f0)))))
            { /* block id: 143 */
                uint8_t l_252 = 0xE1;
                l_252 = ((**l_245) && 0xC081);
                (*l_245) = l_139;
                /* statement id: 145 */
                assert (l_127 == 0);
            }
            else
            { /* block id: 146 */
                (*l_127) = (g_136.f1 ^ p_88);
                for (g_106 = 0; (g_106 >= (-15)); g_106 -= 3)
                { /* block id: 150 */
                    int32_t ****l_258 = &g_256;
                    l_258 = g_255;
                    g_124 = ((float)0x7.3F3522p-63 / (float)p_88);
                    if (l_132.f1)
                        goto lbl_262;
                    (***g_255) = l_139;
                    /* statement id: 153 */
                    assert (g_144 == 0);
                }
            }
            /* facts after branching */
            assert (l_127 == &g_106 || l_127 == 0);
        }
        /* facts after branching */
        assert (l_139 == &g_106 || l_139 == 0 || l_139 == &g_145);
    }
    /* facts after for loop */
    assert (l_127 == &g_106 || l_127 == 0);
lbl_262:
    l_261 = ((g_136.f0 && __builtin_clzll(g_141.f1)) , &g_256);
    if (((uint32_t)((((*g_134) == (void*)0) , (void*)0) != (g_106 , l_265)) / (uint32_t)(l_132.f0 && 65535U)))
    { /* block id: 160 */
        (*g_135) = (*g_135);
    }
    else
    { /* block id: 162 */
        uint32_t l_272 = 0x7D275BA9;
        uint16_t l_297 = 0xCD8E;
        struct S0 l_298 = {18,6096};
        for (g_106 = 15; (g_106 != 11); g_106 -= 1)
        { /* block id: 165 */
            uint32_t l_273 = 0x38F0D61F;
            int32_t *l_280 = &g_145;
            (**g_134) = (**g_134);
            (*l_280) = ((uint16_t)(((int32_t)p_88 - (int32_t)l_272) <= ((g_141.f1 , 0xFCA7) && (g_136.f0 > l_273))) * (uint16_t)(((int16_t)p_88 - (int16_t)g_141.f1) , (((uint16_t)((void*)0 != g_278) << (uint16_t)10) > p_88)));
            for (l_109 = 28; (l_109 <= 4); l_109 -= 1)
            { /* block id: 170 */
                float l_283 = (-0x9.1p+1);
                int32_t l_294 = (-9);
                if (l_272)
                    break;
                if (l_272)
                    break;
                if (p_88)
                    break;
                (*l_280) = ((l_109 , ((int16_t)((int32_t)(g_141.f0 == ((uint32_t)((**g_134) , p_88) % (uint32_t)(g_141.f1 || ((-1) <= ((uint16_t)(l_294 , p_88) / (uint16_t)(((uint32_t)p_88 - (uint32_t)l_297) | 0x15DC)))))) + (int32_t)p_88) - (int16_t)6)) >= p_88);
            }
        }
        (*g_135) = l_298;
        (*g_135) = l_298;
    }
    return g_136.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_106, "g_106", print_hash_value);
    transparent_crc_bytes (&g_124, sizeof(g_124), "g_124", print_hash_value);
    transparent_crc(g_136.f0, "g_136.f0", print_hash_value);
    transparent_crc(g_136.f1, "g_136.f1", print_hash_value);
    transparent_crc(g_141.f0, "g_141.f0", print_hash_value);
    transparent_crc(g_141.f1, "g_141.f1", print_hash_value);
    transparent_crc(g_145, "g_145", print_hash_value);
    transparent_crc(g_361, "g_361", print_hash_value);
    transparent_crc_bytes (&g_522, sizeof(g_522), "g_522", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 99
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 24
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 5
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 12
breakdown:
   indirect level: 0, occurrence: 12
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 89

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 26
   depth: 4, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 69

XXX times a variable address is taken: 80
XXX times a pointer is dereferenced on RHS: 70
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 13
   depth: 3, occurrence: 8
   depth: 4, occurrence: 9
XXX times a pointer is dereferenced on LHS: 83
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 17
   depth: 3, occurrence: 12
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 227

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 228
   level: 2, occurrence: 77
   level: 3, occurrence: 39
   level: 4, occurrence: 32
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 35
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 26.1
XXX average alias set size: 1.22

XXX times a non-volatile is read: 622
XXX times a non-volatile is write: 265
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 128
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 17
   depth: 2, occurrence: 16
   depth: 3, occurrence: 27
   depth: 4, occurrence: 19
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

