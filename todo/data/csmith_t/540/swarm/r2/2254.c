/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2397800476
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const uint16_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_9 = 0xA39ED080L;
static uint64_t g_45 = 1UL;
static volatile int32_t g_73 = (-1L);/* VOLATILE GLOBAL g_73 */
static volatile int32_t *g_72 = &g_73;
static int32_t g_80 = (-2L);
static int32_t *g_79 = &g_80;
static int32_t g_102 = 3L;
static float g_104 = (-0x1.9p-1);
static int32_t ***g_140 = (void*)0;
static int32_t ****g_139 = &g_140;
static volatile struct S0 g_145 = {0xCBE7L};/* VOLATILE GLOBAL g_145 */
static struct S0 g_193 = {0xE49BL};
static int32_t *g_234 = &g_80;
static volatile struct S0 *g_291 = &g_145;
static volatile struct S0 **g_290 = &g_291;
static volatile uint32_t g_299 = 0x627CF3F8L;/* VOLATILE GLOBAL g_299 */
static struct S0 *g_325 = &g_193;
static volatile float g_491 = 0xA.456D4Cp-79;/* VOLATILE GLOBAL g_491 */
static int32_t g_652 = 0xEA073421L;
static uint32_t g_653 = 0xC4E6A35BL;
static volatile uint16_t g_686 = 0x1289L;/* VOLATILE GLOBAL g_686 */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static struct S0  func_4(int64_t  p_5, uint32_t  p_6, int64_t  p_7, const struct S0  p_8);
static int32_t  func_15(const int32_t  p_16, int32_t  p_17);
static uint64_t  func_22(struct S0  p_23, uint64_t  p_24);
static uint32_t  func_25(int32_t  p_26, uint32_t  p_27);
static uint16_t  func_29(int16_t  p_30, const int64_t  p_31, int16_t  p_32, int32_t  p_33);
static int16_t  func_36(uint32_t  p_37, const uint32_t  p_38, int64_t  p_39, int32_t  p_40, float  p_41);
static int32_t * func_46(uint64_t  p_47, uint32_t  p_48, float  p_49);
static int64_t  func_54(int32_t * p_55, int32_t * p_56);
static int32_t * func_57(const int32_t  p_58, uint32_t  p_59, uint32_t  p_60, int32_t * p_61);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_45 g_72 g_79 g_80 g_73 g_102 g_139 g_140 g_145 g_193 g_104 g_234 g_290 g_299 g_325 g_291 g_653 g_652 g_686
 * writes: g_102 g_80 g_104 g_79 g_73 g_45 g_9 g_140 g_653 g_686
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_10 = 0x509978F3L;
    const struct S0 l_374 = {65535UL};
    float *l_631 = &g_104;
    int16_t l_665 = 0x7AA0L;
    (*l_631) = ((float)(func_4(g_9, l_10, ((int32_t)((int16_t)(((0x87642760L == func_15(((int32_t)((int32_t)((func_22((func_25((~g_9), (g_9 , ((l_10 > func_29(g_9, g_9, ((int16_t)func_36(g_9, g_9, l_10, g_9, g_9) * (int16_t)g_9), g_9)) <= g_9))) , g_145), l_10) , (*g_79)) <= l_10) / (int32_t)0x2F1F12ECL) % (int32_t)l_10), l_10)) && g_9) , g_102) << (int16_t)l_10) % (int32_t)l_10), l_374) , 0xC.651155p+78) - (float)l_10);
    if ((g_9 && (-2L)))
    { /* block id: 178 */
        int32_t l_634 = 0xBD16A00AL;
        const float *l_639 = &g_104;
        if ((((int16_t)((0L || (g_45 == (0x7DBAL > l_634))) <= (((int16_t)l_634 * (int16_t)g_193.f0) == ((~(l_631 == (void*)0)) && 0x9C0BL))) >> (int16_t)l_374.f0) , 0xBE9AF626L))
        { /* block id: 179 */
            float *l_638 = &g_104;
            (*g_79) = (l_638 != l_639);
        }
        else
        { /* block id: 181 */
            for (g_80 = (-20); (g_80 > (-24)); g_80 -= 1)
            { /* block id: 184 */
                int32_t *l_642 = &g_102;
                int32_t *l_643 = (void*)0;
                int32_t *l_644 = &g_102;
                int32_t *l_645 = &g_102;
                int32_t *l_646 = &g_102;
                int32_t *l_647 = &g_102;
                int32_t *l_648 = &g_102;
                int32_t *l_649 = &g_102;
                int32_t *l_650 = &g_102;
                int32_t *l_651 = &g_102;
                struct S0 **l_664 = &g_325;
                int32_t l_666 = 0x07FCD2D7L;
                g_653++;
                (*l_649) &= (((((void*)0 != &g_290) || (((uint16_t)(&g_140 != ((((((~g_45) | g_45) < (((void*)0 == &l_374) || (((int16_t)(~g_299) << (int16_t)12) <= (l_664 == (void*)0)))) , g_9) < g_652) , &g_140)) % (uint16_t)0x8722L) > l_665)) ^ l_374.f0) != 7UL);
                if (l_666)
                    continue;
                (*l_647) ^= (*g_72);
            }
        }
        for (l_634 = 0; (l_634 >= (-15)); l_634 -= 1)
        { /* block id: 193 */
            int32_t *l_669 = &g_652;
            int32_t *l_670 = &g_102;
            int32_t l_671 = 0xD80C2B33L;
            int32_t l_672 = (-1L);
            int32_t *l_673 = &g_80;
            int32_t *l_674 = &l_671;
            int32_t *l_675 = (void*)0;
            int32_t *l_676 = &g_652;
            int32_t *l_677 = &g_652;
            int32_t *l_678 = &g_102;
            int32_t *l_679 = &l_671;
            int32_t *l_680 = &g_652;
            int32_t *l_681 = (void*)0;
            int32_t *l_682 = &g_102;
            int32_t *l_683 = &l_671;
            int32_t *l_684 = &l_672;
            int32_t *l_685 = &l_671;
            ++g_686;
        }
        return l_10;
    }
    else
    { /* block id: 197 */
        return g_652;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_234 g_80 g_145.f0 g_193.f0 g_102 g_299 g_104 g_72 g_73 g_79 g_45 g_290 g_291 g_145 g_325 g_193 g_139 g_140
 * writes: g_9 g_45 g_80 g_102 g_104 g_73 g_140
 */
static struct S0  func_4(int64_t  p_5, uint32_t  p_6, int64_t  p_7, const struct S0  p_8)
{ /* block id: 113 */
    uint32_t l_379 = 18446744073709551607UL;
    float *l_388 = &g_104;
    struct S0 **l_503 = (void*)0;
    uint32_t l_505 = 0xBDB37D4CL;
    int32_t l_531 = (-9L);
    int32_t l_554 = 0x0DF44371L;
    uint16_t l_559 = 6UL;
    int32_t *l_630 = &l_531;
    for (p_6 = 0; (p_6 > 8); p_6++)
    { /* block id: 116 */
        int32_t *l_377 = &g_102;
        int32_t *l_378 = &g_80;
        struct S0 *l_421 = &g_193;
        int32_t l_463 = (-3L);
        int32_t l_544 = 0x13304496L;
        int32_t l_547 = 3L;
        int32_t * const * const l_622 = (void*)0;
        int32_t * const * const *l_621 = &l_622;
        int32_t * const * const **l_620 = &l_621;
        l_377 = l_377;
        l_379++;
        for (g_9 = 0; (g_9 != (-28)); g_9 -= 1)
        { /* block id: 121 */
            struct S0 l_386 = {0xF0C6L};
            float * const l_387 = (void*)0;
            float l_415 = 0xA.0FB83Dp+18;
            int32_t l_416 = 0x0A1A989DL;
            int32_t l_574 = 0L;
            for (g_45 = 0; (g_45 != 24); g_45 += 8)
            { /* block id: 124 */
                return l_386;
            }
            if ((l_387 == l_388))
            { /* block id: 127 */
                uint64_t l_411 = 0xA697F749FDA80F47LL;
                struct S0 l_441 = {1UL};
                struct S0 **l_476 = &l_421;
                const int16_t l_490 = 0L;
                const int32_t *l_600 = &g_80;
                if ((*g_234))
                { /* block id: 128 */
                    struct S0 l_389 = {0xF56FL};
                    return l_389;
                }
                else
                { /* block id: 130 */
                    int64_t l_414 = 0L;
                    int32_t *l_448 = &g_80;
                    l_416 &= (((0xE22DACE2L == ((uint16_t)((p_5 , 65532UL) == (((uint16_t)(p_6 && (-(int32_t)((uint16_t)(((float)(((float)((float)(0x9.7434CFp+46 < (0x8.DC099Ep-34 == (-0x4.Ep+1))) + (float)((((-(float)((float)(-(float)((float)((float)l_411 / (float)((((float)(g_145.f0 == l_414) * (float)(-0x10.3p+1)) <= g_9) > 0x3.5A8607p-76)) + (float)0x0.9p+1)) / (float)g_193.f0)) != p_5) >= (-0x1.9p-1)) > l_386.f0)) - (float)p_7) < p_7) - (float)g_80) , l_414) - (uint16_t)l_386.f0))) - (uint16_t)g_193.f0) && p_8.f0)) >> (uint16_t)l_386.f0)) | p_5) & g_193.f0);
                    for (g_80 = (-9); (g_80 == (-12)); g_80 -= 8)
                    { /* block id: 134 */
                        int16_t l_422 = 0x0295L;
                        (*l_377) ^= ((0xA9E1673EL <= (p_8.f0 > 0x47BB7FCCL)) == ((uint16_t)p_8.f0 >> (uint16_t)(((void*)0 == l_421) & l_422)));
                    }
                    if ((((int16_t)(8UL && (((float)l_414 - (float)((float)(g_299 != ((0x1840488C37341C26LL < p_8.f0) , ((float)g_104 - (float)(g_80 >= ((float)(g_80 != g_80) + (float)l_379))))) + (float)(-0x8.5p-1))) , (-2L))) >> (int16_t)p_5) > 0x8F4CL))
                    { /* block id: 137 */
                        (*l_388) = ((((float)g_145.f0 / (float)((float)((float)g_104 / (float)(-0x8.Dp+1)) / (float)((float)l_416 + (float)(l_441 , ((((float)0x7.B16BC2p-72 + (float)0xA.F55DE8p-75) == ((float)(((float)(l_414 != g_9) / (float)(*l_378)) == (-0x3.Ep+1)) - (float)(-0x3.9p+1))) == 0x1.2p+1))))) , l_448) != &l_416);
                    }
                    else
                    { /* block id: 139 */
                        (*g_79) |= (((int16_t)((uint16_t)p_8.f0 + (uint16_t)g_80) >> (int16_t)8) >= (*g_72));
                    }
                }
                (*g_79) &= p_5;
                if ((((uint16_t)(l_441.f0 < p_7) << (uint16_t)2) | (((uint64_t)((int16_t)(((uint64_t)g_193.f0 + (uint64_t)((l_388 != (void*)0) , ((int16_t)((l_379 & 0L) , (0UL < ((*l_378) ^ p_6))) * (int16_t)g_45))) > p_6) << (int16_t)l_411) - (uint64_t)l_463) == (-1L))))
                { /* block id: 144 */
                    int32_t **l_464 = &l_377;
                    int16_t l_473 = (-1L);
                    struct S0 **l_502 = &l_421;
                    int32_t l_537 = 0x5F25AB8FL;
                    float *l_588 = &l_415;
                    (*l_464) = &l_463;
                    if (((int16_t)((int16_t)0x5B34L - (int16_t)p_6) >> (int16_t)(((~(((*l_378) == ((uint16_t)(!p_6) * (uint16_t)g_299)) != l_473)) == ((int16_t)((l_476 == l_476) , (g_102 <= l_416)) << (int16_t)13)) && l_379)))
                    { /* block id: 146 */
                        uint64_t l_489 = 18446744073709551609UL;
                        (*g_79) |= (g_73 , (((0x2354L <= ((int16_t)p_6 * (int16_t)((uint16_t)l_386.f0 + (uint16_t)((int32_t)((uint16_t)g_80 << (uint16_t)7) % (int32_t)((((((uint16_t)0x2587L / (uint16_t)(((uint64_t)(((*l_378) ^ ((((0xD859L == 1UL) != (**l_464)) , l_489) & g_45)) > p_5) % (uint64_t)p_6) | p_7)) , (*g_290)) == (void*)0) ^ l_490) || 0x9AF5786877DDFA04LL))))) | p_6) > 18446744073709551612UL));
                        (*g_79) = 0x9671310DL;
                        (*l_464) = (*l_464);
                    }
                    else
                    { /* block id: 150 */
                        float l_504 = 0xE.0DA7D1p-19;
                        int32_t *l_506 = &g_80;
                        int32_t *l_507 = &g_80;
                        int32_t *l_508 = &l_416;
                        int32_t *l_509 = &g_102;
                        int32_t *l_510 = &g_80;
                        int32_t *l_511 = &g_80;
                        int32_t *l_512 = &l_416;
                        int32_t *l_513 = &l_416;
                        int32_t *l_514 = &g_80;
                        int32_t *l_515 = &g_80;
                        int32_t *l_516 = (void*)0;
                        int32_t *l_517 = &l_416;
                        int32_t *l_518 = &g_80;
                        int32_t *l_519 = &g_80;
                        int32_t *l_520 = &g_102;
                        int32_t *l_521 = &l_463;
                        int32_t *l_522 = &l_416;
                        int32_t *l_523 = &g_102;
                        int32_t *l_524 = &l_416;
                        int32_t *l_525 = &g_80;
                        int32_t *l_526 = &g_102;
                        int32_t *l_527 = &l_416;
                        int32_t *l_528 = &l_416;
                        int32_t *l_529 = (void*)0;
                        int32_t *l_530 = (void*)0;
                        int32_t *l_532 = &g_102;
                        int32_t *l_533 = &g_80;
                        int32_t *l_534 = &l_416;
                        int32_t *l_535 = &l_416;
                        int32_t *l_536 = &l_463;
                        int32_t *l_538 = &g_102;
                        int32_t *l_539 = (void*)0;
                        int32_t *l_540 = (void*)0;
                        int32_t *l_541 = &g_80;
                        int32_t l_542 = 3L;
                        int32_t *l_543 = &l_531;
                        int32_t *l_545 = &l_537;
                        int32_t *l_546 = (void*)0;
                        int32_t *l_548 = &g_80;
                        int32_t *l_549 = &l_547;
                        int32_t *l_550 = &l_416;
                        int32_t *l_551 = (void*)0;
                        int32_t *l_552 = &l_531;
                        int32_t *l_553 = &g_102;
                        int32_t *l_555 = &l_463;
                        int32_t *l_556 = &l_547;
                        int32_t *l_557 = &l_463;
                        int32_t *l_558 = &l_463;
                        l_505 &= ((0xC6C0L & (-1L)) != ((int16_t)((uint16_t)((((uint16_t)(((g_299 != 0xAA7F7423C30839E8LL) | g_193.f0) | ((((uint16_t)(g_45 || p_5) << (uint16_t)((int16_t)((l_502 == l_503) != p_7) - (int16_t)l_411)) , g_9) < g_9)) << (uint16_t)13) <= p_6) , p_5) >> (uint16_t)g_102) * (int16_t)p_8.f0));
                        l_559++;
                        if (p_6)
                            continue;
                        (*l_527) ^= p_5;
                    }
                    if (((uint16_t)(0x67FCL && (((*g_234) ^ ((int64_t)0x3F10CF3876A514F4LL / (int64_t)((int16_t)((uint16_t)(((p_8 , g_102) >= 0x2D6932EEL) & g_193.f0) - (uint16_t)((*g_234) | (((int32_t)((int16_t)(**l_464) / (int16_t)0xFD24L) - (int32_t)l_574) , l_411))) << (int16_t)2))) == g_80)) >> (uint16_t)g_73))
                    { /* block id: 156 */
                        (*g_79) = (((((uint16_t)((int16_t)(p_6 , ((int16_t)(g_45 & ((uint32_t)(((((uint64_t)((*l_378) && (~((((p_5 < ((**g_290) , (((uint16_t)l_574 * (uint16_t)((*l_378) < ((l_588 == (void*)0) , p_6))) & p_6))) , l_531) && 0x4206CAF5L) || p_8.f0))) % (uint64_t)g_45) , g_9) != p_8.f0) >= 7UL) - (uint32_t)g_45)) * (int16_t)g_80)) << (int16_t)(*l_378)) >> (uint16_t)11) != 0x3C447E2CC4A44EA5LL) , 0x3C5AB58AL) <= 0UL);
                        (*g_79) ^= (p_7 != ((int16_t)g_73 << (int16_t)8));
                        (*g_72) ^= 0xEB95CEC5L;
                    }
                    else
                    { /* block id: 160 */
                        return (*g_325);
                    }
                }
                else
                { /* block id: 163 */
                    (*g_139) = (*g_139);
                    (*l_377) &= 0x763B2EF7L;
                    (*l_378) &= ((uint16_t)(((int32_t)((((((&g_290 == (void*)0) | (((l_505 , ((uint64_t)(((g_45 < ((void*)0 == l_421)) , l_600) != l_600) - (uint64_t)g_145.f0)) == 0xE32CL) <= 0xBE0AD6E44AAF0699LL)) , p_5) & 1UL) | p_8.f0) && p_6) / (int32_t)p_6) >= l_416) + (uint16_t)0x7A13L);
                }
                (*l_377) = ((uint16_t)65535UL % (uint16_t)((((0x72286EEC79FE2DECLL | ((p_6 , l_377) == (l_379 , l_377))) > (l_386 , 0x182B63C7L)) >= ((uint64_t)g_80 + (uint64_t)(*l_600))) ^ 0L));
            }
            else
            { /* block id: 169 */
                float l_629 = (-0x1.3p+1);
                if ((*g_234))
                    break;
                l_531 &= (((uint64_t)(l_386 , (((uint32_t)((int32_t)(((((((-(int16_t)0xD690L) | ((uint16_t)((uint64_t)((uint16_t)(((uint16_t)(l_620 != &l_621) * (uint16_t)((0xD9222CCBL || 0L) || ((uint16_t)(((((int64_t)(-9L) + (int64_t)((((18446744073709551610UL >= ((uint16_t)((g_102 > p_8.f0) < 0L) / (uint16_t)0xDCAAL)) || l_574) ^ p_6) > (-2L))) < p_7) == g_73) == p_7) << (uint16_t)5))) | g_193.f0) << (uint16_t)g_45) / (uint64_t)g_102) >> (uint16_t)15)) > p_7) | g_9) ^ p_6) < g_193.f0) | g_45) + (int32_t)1UL) + (uint32_t)l_559) ^ g_80)) % (uint64_t)p_8.f0) , (*g_79));
                l_630 = &l_531;
            }
        }
    }
    return p_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_102 g_145.f0 g_193.f0 g_72 g_45 g_80 g_73 g_290 g_299 g_234 g_325 g_291
 * writes: g_73 g_45 g_104 g_102 g_80
 */
static int32_t  func_15(const int32_t  p_16, int32_t  p_17)
{ /* block id: 60 */
    int32_t *l_263 = &g_80;
    int32_t ****l_264 = &g_140;
    const struct S0 *l_295 = (void*)0;
    volatile struct S0 ***l_300 = (void*)0;
    int16_t l_305 = 8L;
    int32_t l_306 = 0L;
    int32_t l_308 = 2L;
    uint32_t l_369 = 0x3094950BL;
    const uint64_t l_370 = 1UL;
    int64_t l_371 = 0xEF5591ADE6E3D103LL;
    const int32_t *l_373 = &g_102;
    const int32_t **l_372 = &l_373;
    if ((&p_16 == l_263))
    { /* block id: 61 */
        return (*g_79);
    }
    else
    { /* block id: 63 */
        int32_t **l_266 = &l_263;
        float l_268 = 0x5.AC62ACp+21;
        int32_t ****l_287 = (void*)0;
        int64_t l_288 = 1L;
        const uint32_t l_289 = 0UL;
        struct S0 *l_294 = &g_193;
        struct S0 * const *l_336 = &l_294;
        struct S0 * const **l_335 = &l_336;
        uint16_t l_346 = 0x7BF6L;
        if (((((l_264 != l_264) | (~g_145.f0)) >= (0UL > (l_266 == l_266))) == (~(0xA847L ^ (g_193.f0 & ((-1L) ^ g_193.f0))))))
        { /* block id: 64 */
            (*g_72) = p_16;
        }
        else
        { /* block id: 66 */
            float *l_269 = (void*)0;
            float *l_270 = &l_268;
            (*l_266) = (void*)0;
            (*l_270) = ((void*)0 == &p_16);
            return p_16;
        }
        for (g_45 = 0; (g_45 != 59); g_45 += 1)
        { /* block id: 73 */
            float *l_273 = &g_104;
            (*l_266) = &p_17;
            (*l_273) = (**l_266);
        }
        if ((((uint16_t)(*l_263) >> (uint16_t)13) <= (((!(*l_263)) || 0x3EEC5992523FAAA2LL) || (p_17 != (((g_102 >= (((**l_266) , (((uint16_t)(((((((uint16_t)((int32_t)(((uint16_t)(((((int64_t)(l_287 == l_287) % (int64_t)l_288) ^ g_73) , g_45) != (-1L)) >> (uint16_t)g_80) ^ 0xFE82150CL) % (int32_t)(*g_79)) >> (uint16_t)p_17) != 9L) , g_45) , 0xEE84A3AFL) != 0xFDF005D3L) , l_289) * (uint16_t)(**l_266)) , p_17)) , (**l_266))) && p_17) < p_16)))))
        { /* block id: 77 */
            (*g_79) |= (((void*)0 != g_290) < ((uint16_t)1UL + (uint16_t)((p_16 , l_294) != l_295)));
            for (l_288 = 0; (l_288 < (-13)); l_288 -= 1)
            { /* block id: 81 */
                float *l_298 = &g_104;
                (*l_298) = 0xA.D2C0F4p-57;
                if (g_299)
                    break;
                p_17 &= (*g_234);
            }
        }
        else
        { /* block id: 86 */
            l_300 = &g_290;
        }
        if (((void*)0 != l_264))
        { /* block id: 89 */
            int32_t **l_329 = &l_263;
            for (l_288 = 0; (l_288 <= (-20)); l_288 -= 1)
            { /* block id: 92 */
                uint64_t l_318 = 0x5E538C652072F1D7LL;
                for (p_17 = 23; (p_17 >= 15); p_17 -= 5)
                { /* block id: 95 */
                    int32_t *l_307 = (void*)0;
                    int32_t *l_309 = (void*)0;
                    int32_t *l_310 = &l_308;
                    int32_t *l_311 = &g_80;
                    int32_t *l_312 = &l_306;
                    int32_t *l_313 = &g_80;
                    int32_t *l_314 = &g_102;
                    int32_t *l_315 = &l_306;
                    int32_t *l_316 = (void*)0;
                    int32_t *l_317 = &g_102;
                    ++l_318;
                }
            }
            for (g_102 = 25; (g_102 == 23); g_102 -= 1)
            { /* block id: 101 */
                float *l_326 = (void*)0;
                int32_t **l_330 = &g_79;
                (**l_329) = ((0L < (p_16 <= 5UL)) , ((uint16_t)((g_325 != (*g_290)) , (l_326 == (((uint16_t)((p_16 , (l_329 == l_330)) <= 0x0F901617L) << (uint16_t)p_16) , l_326))) >> (uint16_t)7));
            }
            (*g_234) = ((void*)0 == &p_17);
            (*g_72) = (**l_329);
        }
        else
        { /* block id: 106 */
            int64_t l_337 = (-8L);
            (*g_72) = (((int16_t)(((void*)0 != l_335) & ((((0x5.32417Fp+44 <= l_337) <= 0x9.5p-1) , ((((int16_t)(((uint64_t)(**l_266) - (uint64_t)((uint64_t)((uint64_t)p_17 / (uint64_t)0x7D4BD7B55C8FD6D3LL) + (uint64_t)((((((0x81EF0CDA17076B1BLL != 9UL) || 0x4CF6L) > p_17) & p_17) || 0x7C9CL) > (*l_263)))) >= 0x06863550A750F617LL) >> (int16_t)4) <= l_346) > 0xD34D6390L)) != (**l_266))) << (int16_t)p_17) < l_337);
        }
    }
    (*g_234) = ((0xC49628F9L != (((uint16_t)((((((((*g_290) != (*g_290)) >= ((~((uint64_t)(0xD47E966681958A2ELL == ((((int16_t)(((int16_t)((((~((uint16_t)((((int16_t)(((int64_t)(((int16_t)0L / (int16_t)((uint16_t)(((*l_263) ^ (p_16 | (((int16_t)l_369 << (int16_t)0) != ((&p_16 == &p_17) <= (*l_263))))) >= p_17) << (uint16_t)(*l_263))) , p_17) % (int64_t)(*l_263)) || p_16) / (int16_t)p_17) > p_17) >= 1UL) << (uint16_t)g_45)) ^ 7UL) > 0xC094F27FA7781369LL) , l_370) * (int16_t)0x9FFBL) ^ 4294967295UL) * (int16_t)p_17) <= 0x258C9E95FC9310ADLL) != g_145.f0)) - (uint64_t)p_17)) && p_17)) == 0xE769L) ^ 0xC13443893D39C3C4LL) && 65527UL) == p_16) , g_102) + (uint16_t)l_371) , (*g_72))) < (*l_263));
    (*l_372) = &p_16;
    return p_16;
}


/* ------------------------------------------ */
/* 
 * reads : g_193.f0 g_79 g_102 g_45 g_234 g_80 g_72 g_73
 * writes: g_73 g_102 g_80
 */
static uint64_t  func_22(struct S0  p_23, uint64_t  p_24)
{ /* block id: 55 */
    uint32_t l_260 = 0xF0B7091FL;
    float *l_261 = &g_104;
    int32_t l_262 = (-1L);
    (*g_72) = ((((int32_t)((uint16_t)0xD53CL + (uint16_t)((uint64_t)((((0xB7657CA1L <= ((uint32_t)((int64_t)((uint16_t)l_260 + (uint16_t)(18446744073709551615UL == ((((-1L) != (g_193.f0 , (0x85D5F9ADL > (*g_79)))) <= ((l_261 != (void*)0) != 1UL)) | g_45))) + (int64_t)p_24) - (uint32_t)1L)) != l_260) > l_260) <= (*g_234)) + (uint64_t)0x6EA6DD21D6E29E21LL)) - (int32_t)(*g_72)) ^ l_260) , l_260);
    (*g_79) ^= l_262;
    (*g_234) |= (*g_72);
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads : g_102 g_9 g_79 g_45 g_139 g_80 g_140 g_72 g_145 g_73 g_193 g_104 g_234
 * writes: g_73 g_104 g_45 g_102
 */
static uint32_t  func_25(int32_t  p_26, uint32_t  p_27)
{ /* block id: 29 */
    int32_t l_106 = (-9L);
    float *l_111 = &g_104;
    int32_t ****l_141 = &g_140;
    int32_t **l_176 = (void*)0;
    uint32_t l_178 = 4294967290UL;
    const uint32_t l_191 = 0x2EBD030DL;
    uint32_t l_233 = 5UL;
    int32_t *l_235 = &g_80;
    const int32_t ****l_240 = (void*)0;
    uint32_t l_243 = 0x6EA00FD1L;
    struct S0 *l_247 = &g_193;
    struct S0 **l_246 = &l_247;
    if ((l_106 & (((int16_t)(((uint16_t)(((void*)0 == l_111) < (0L >= ((((-(int32_t)p_27) > ((!(l_106 < ((float)(((~((int16_t)g_102 % (int16_t)((int16_t)((uint16_t)(l_111 == l_111) * (uint16_t)(-1L)) - (int16_t)g_9))) , (void*)0) == &g_102) * (float)l_106))) , p_27)) , 0L) == p_27))) - (uint16_t)p_26) > (*g_79)) % (int16_t)g_45) != g_102)))
    { /* block id: 30 */
        float *l_130 = &g_104;
        int32_t **l_142 = (void*)0;
        uint32_t l_152 = 0UL;
        (*g_72) = (((((((float)(-0x10.0p-1) / (float)(0x5.B9F80Bp-59 <= (!((float)0xB.64457Bp+56 + (float)((void*)0 != l_130))))) , ((uint16_t)(((int16_t)((uint64_t)(((int16_t)(&g_72 != (((l_106 , g_139) == (p_26 , l_141)) , l_142)) / (int16_t)p_26) , 2UL) / (uint64_t)0x93D5F64BAD57AD3CLL) >> (int16_t)g_102) || g_80) * (uint16_t)0x1C9DL)) || g_102) == 0x5A60L) , (*l_141)) == &l_142);
        (*l_111) = ((((float)((p_26 < (((g_145 , (void*)0) == l_111) == ((*l_141) != (void*)0))) > ((float)(g_102 != ((float)((float)(g_80 > (g_45 == g_9)) * (float)0x8.693438p+96) - (float)p_27)) * (float)p_27)) * (float)g_102) >= p_26) < l_152);
    }
    else
    { /* block id: 33 */
        int32_t *l_153 = &g_80;
        const struct S0 l_162 = {0UL};
        int32_t ****l_175 = &g_140;
        if ((((void*)0 != l_153) >= 4294967290UL))
        { /* block id: 34 */
            uint64_t l_164 = 0x3F91E7325C604081LL;
            int16_t l_177 = (-10L);
            float l_188 = 0x0.CC4AB3p-21;
            for (g_45 = (-16); (g_45 < 52); g_45++)
            { /* block id: 37 */
                float *l_163 = &g_104;
                int32_t l_165 = (-1L);
                l_165 |= ((uint32_t)((int16_t)p_26 >> (int16_t)((int32_t)(((l_162 , l_163) == (void*)0) , p_26) - (int32_t)0xD3579F7DL)) + (uint32_t)l_164);
                if (l_165)
                    break;
                if ((*g_72))
                    continue;
            }
            l_178 |= ((((float)((float)(0x8.84A4DCp+87 > l_164) + (float)(((g_73 == p_26) , (((uint16_t)g_102 >> (uint16_t)0) , ((-(float)((float)(((void*)0 == l_175) , (g_145 , (l_176 != l_176))) * (float)l_177)) >= 0x5.281BCFp-25))) > g_9)) / (float)l_177) , 0xBC9AL) , (*g_79));
            (*g_72) = ((p_26 == 0UL) & (((((*l_141) != (*l_141)) | (!(((uint16_t)((uint32_t)g_45 + (uint32_t)(p_27 <= p_27)) / (uint16_t)1UL) ^ (((int32_t)(*g_72) / (int32_t)p_27) , l_191)))) , 7UL) , p_27));
        }
        else
        { /* block id: 44 */
            struct S0 *l_192 = &g_193;
            struct S0 **l_194 = &l_192;
            int32_t **l_195 = &l_153;
            int32_t l_204 = 0xE1AEB3B6L;
            (*l_194) = l_192;
            (*l_195) = &p_26;
            (*g_72) = (g_193 , (((int32_t)((((uint32_t)((int16_t)(((uint16_t)(0xC10F2CAEL != (l_204 == (*l_153))) * (uint16_t)0xB3E1L) || ((~p_27) , (!(0x963199CE3922E0D3LL | ((int64_t)0x5B00EC888E099548LL + (int64_t)(((uint16_t)p_26 % (uint16_t)p_27) == (*l_153))))))) / (int16_t)65527UL) + (uint32_t)g_102) | (**l_195)) > p_27) + (int32_t)p_26) || (*l_153)));
        }
        (*l_111) = (((float)((0x0.4AAFBAp+27 < ((g_80 <= ((float)((float)g_102 / (float)((float)(p_27 >= 0x8.8E5E82p+98) - (float)(0x2.Bp+1 > (((((uint16_t)(g_145.f0 , 0x652DL) >> (uint16_t)p_27) , g_45) == 0xA.2EEFF2p+25) < p_27)))) + (float)g_104)) == 0x9.5p+1)) > p_26) / (float)p_27) , 0xD.958418p+63);
    }
    (*g_79) = p_26;
    l_235 = func_57(((((uint16_t)65535UL * (uint16_t)0xC562L) <= (((int16_t)(((((1UL || g_145.f0) && ((int16_t)(g_193.f0 >= (1UL == (((uint16_t)p_27 * (uint16_t)0x0C6CL) == 0x7441L))) * (int16_t)p_26)) <= l_233) <= g_193.f0) && 0xDBAEL) * (int16_t)0UL) != g_193.f0)) > g_45), g_102, g_45, g_234);
    (*l_111) = ((*l_235) == ((((int16_t)(((((l_240 != l_240) >= (g_45 , ((l_243 != (((int16_t)0x5BA1L - (int16_t)(l_246 == (void*)0)) <= g_45)) >= p_26))) , g_145.f0) && g_80) || 0x83D060D7L) >> (int16_t)4) && (*g_72)) , g_145.f0));
    return g_193.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_72 g_9 g_79 g_80 g_73 g_102
 * writes: g_102 g_80 g_104 g_79
 */
static uint16_t  func_29(int16_t  p_30, const int64_t  p_31, int16_t  p_32, int32_t  p_33)
{ /* block id: 9 */
    int16_t l_50 = 0x309AL;
    int32_t **l_105 = &g_79;
    (*l_105) = func_46(g_45, l_50, l_50);
    (*g_79) &= 0x5EEC0DB1L;
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_45
 * writes:
 */
static int16_t  func_36(uint32_t  p_37, const uint32_t  p_38, int64_t  p_39, int32_t  p_40, float  p_41)
{ /* block id: 1 */
    int32_t l_44 = 0L;
    for (p_40 = (-27); (p_40 == (-3)); p_40 += 6)
    { /* block id: 4 */
        if (l_44)
            break;
        return p_39;
    }
    return g_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_9 g_79 g_80 g_73 g_45 g_102
 * writes: g_102 g_80 g_104
 */
static int32_t * func_46(uint64_t  p_47, uint32_t  p_48, float  p_49)
{ /* block id: 10 */
    int16_t l_51 = (-1L);
    float *l_103 = &g_104;
    if (l_51)
    { /* block id: 11 */
        const int32_t l_62 = (-1L);
        uint32_t l_78 = 0UL;
        int32_t l_99 = 1L;
        int32_t *l_100 = (void*)0;
        int32_t *l_101 = &g_102;
        (*l_101) |= func_36(((int64_t)func_54(func_57(l_62, ((uint16_t)65535UL * (uint16_t)((int64_t)l_62 % (int64_t)((uint16_t)(-(int32_t)(0L < ((((int16_t)((void*)0 != g_72) << (int16_t)((uint16_t)((uint32_t)(l_62 , 0xF3AC16B4L) - (uint32_t)0xB7518DB0L) << (uint16_t)8)) != 0L) > g_9))) + (uint16_t)g_9))), l_78, g_79), &g_80) - (int64_t)g_45), p_47, g_80, l_99, l_62);
    }
    else
    { /* block id: 20 */
        (*g_79) ^= (*g_72);
    }
    (*l_103) = l_51;
    (*g_79) = (*g_79);
    return &g_102;
}


/* ------------------------------------------ */
/* 
 * reads : g_73
 * writes:
 */
static int64_t  func_54(int32_t * p_55, int32_t * p_56)
{ /* block id: 16 */
    int32_t ****l_95 = (void*)0;
    int32_t * const *l_98 = &g_79;
    int32_t * const **l_97 = &l_98;
    int32_t * const ***l_96 = &l_97;
    (*l_96) = (void*)0;
    return g_73;
}


/* ------------------------------------------ */
/* 
 * reads : g_79 g_80 g_73 g_102
 * writes:
 */
static int32_t * func_57(const int32_t  p_58, uint32_t  p_59, uint32_t  p_60, int32_t * p_61)
{ /* block id: 12 */
    uint16_t l_87 = 0xA498L;
    int32_t *l_90 = &g_80;
    int32_t l_93 = 8L;
    int32_t **l_94 = &l_90;
    l_93 &= (((int16_t)((int16_t)((int16_t)l_87 - (int16_t)((uint32_t)((void*)0 != l_90) / (uint32_t)(*g_79))) % (int16_t)(((*l_90) || (((uint32_t)g_80 + (uint32_t)(g_73 != g_80)) || (*l_90))) & (*l_90))) * (int16_t)0xCDCCL) == 0UL);
    l_94 = &l_90;
    return p_61;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc(g_45, "g_45", print_hash_value);
    transparent_crc(g_73, "g_73", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_102, "g_102", print_hash_value);
    transparent_crc_bytes (&g_104, sizeof(g_104), "g_104", print_hash_value);
    transparent_crc(g_145.f0, "g_145.f0", print_hash_value);
    transparent_crc(g_193.f0, "g_193.f0", print_hash_value);
    transparent_crc(g_299, "g_299", print_hash_value);
    transparent_crc_bytes (&g_491, sizeof(g_491), "g_491", print_hash_value);
    transparent_crc(g_652, "g_652", print_hash_value);
    transparent_crc(g_653, "g_653", print_hash_value);
    transparent_crc(g_686, "g_686", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 114
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 131
   depth: 2, occurrence: 20
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 33, occurrence: 1
   depth: 36, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 159

XXX times a variable address is taken: 151
XXX times a pointer is dereferenced on RHS: 70
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 11
XXX times a pointer is dereferenced on LHS: 52
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 466

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 178
   level: 2, occurrence: 18
   level: 3, occurrence: 20
   level: 4, occurrence: 29
XXX number of pointers point to pointers: 34
XXX number of pointers point to scalars: 118
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 18.2
XXX average alias set size: 1.06

XXX times a non-volatile is read: 547
XXX times a non-volatile is write: 126
XXX times a volatile is read: 35
XXX    times read thru a pointer: 10
XXX times a volatile is write: 9
XXX    times written thru a pointer: 8
XXX times a volatile is available for access: 158
XXX percentage of non-volatile access: 93.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 121
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 25
   depth: 3, occurrence: 20
   depth: 4, occurrence: 11
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 18.9
XXX percentage an existing variable is used: 81.1
********************* end of statistics **********************/

