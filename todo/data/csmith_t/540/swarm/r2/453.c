/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      800919376
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_14(int32_t * p_15, uint32_t  p_16, uint32_t  p_17, int32_t * p_18);
static int32_t * func_19(uint16_t  p_20, int32_t  p_21);
static int32_t ** func_24(int32_t  p_25);
static int32_t * func_52(int32_t * p_53, uint32_t  p_54, int32_t *** p_55);
static int32_t * func_56(int32_t * p_57, int32_t * p_58);
static int32_t * func_60(uint32_t  p_61, int32_t * p_62, uint16_t  p_63);
static uint16_t  func_66(float  p_67, int32_t **** p_68, int16_t  p_69, int32_t ** p_70);
static int32_t **** func_72(const int16_t  p_73, int32_t ** p_74);
static int32_t ** func_75(float * p_76, int32_t * p_77, int32_t **** p_78, uint32_t  p_79, uint8_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_2 = 1UL;
    int32_t l_3 = 2L;
    int32_t l_11 = (-4L);
    int32_t *l_10 = &l_11;
    uint32_t l_51 = 0xEBAC3F40L;
    int16_t l_221 = (-2L);
    int16_t l_270 = (-1L);
    int32_t **l_312 = (void*)0;
    int32_t ***l_311 = &l_312;
    uint16_t l_326 = 0xAAF0L;
    int32_t ****l_328 = &l_311;
    int32_t *****l_327 = &l_328;
    uint8_t l_329 = 1UL;
    uint32_t l_330 = 5UL;
    int32_t **l_331 = &l_10;
    uint8_t l_332 = 3UL;
lbl_241:
    l_3 = l_2;
    if (((uint32_t)0xED23B618L % (uint32_t)((((int16_t)l_2 / (int16_t)l_3) > ((*l_10) = ((int32_t)l_2 - (int32_t)0UL))) || (*l_10))))
    { /* block id: 3 */
        uint16_t l_23 = 65530UL;
        int32_t *l_82 = (void*)0;
        int16_t l_98 = 1L;
        int32_t *l_222 = &l_3;
        int32_t *l_223 = &l_11;
        uint16_t l_237 = 0xAD84L;
        int32_t l_238 = 0x824888C0L;
        int32_t **l_263 = (void*)0;
        int32_t **l_264 = &l_222;
        for (l_3 = 0; (l_3 < 16); l_3 += 1)
        { /* block id: 6 */
            int16_t l_22 = 0xB722L;
            int32_t *l_59 = &l_3;
            uint16_t l_71 = 65535UL;
            float *l_81 = (void*)0;
            int32_t **l_85 = &l_10;
            int32_t ***l_84 = &l_85;
            int32_t ****l_83 = &l_84;
            int32_t **l_211 = (void*)0;
            int32_t **l_212 = &l_59;
            float *l_217 = (void*)0;
            float *l_218 = (void*)0;
            float l_220 = 0x8.911B31p+12;
            float *l_219 = &l_220;
            uint16_t *l_260 = &l_23;
            uint16_t **l_259 = &l_260;
            l_82 = ((*l_212) = func_14(func_19(l_22, l_23), l_23, l_51, func_52(func_56(l_59, func_60((((**l_83) = func_24(((uint16_t)func_66(l_71, func_72((*l_10), func_75(l_81, l_82, l_83, l_23, (*l_10))), (**l_85), (**l_83)) >> (uint16_t)1))) != (void*)0), l_82, l_98)), (*l_10), (*l_83))));
            /* statement id: 69 */
            assert (l_59 == 0);
            assert (l_85 == 0);
            l_221 = ((float)((float)0x4.2p+1 * (float)(*l_10)) * (float)((*l_219) = (*l_10)));
            l_223 = l_222;
            /* statement id: 72 */
            assert (l_223 == &l_3);
            for (l_221 = 0; (l_221 != 28); l_221 += 1)
            { /* block id: 75 */
                int32_t *l_226 = &l_3;
                const int16_t *l_231 = &l_22;
                const int16_t **l_230 = &l_231;
                const int16_t ***l_229 = &l_230;
                int16_t **l_233 = (void*)0;
                int16_t ***l_232 = &l_233;
                int16_t *l_236 = &l_22;
                int32_t l_243 = 4L;
                float l_262 = 0x4.5D964Bp-65;
                float *l_261 = &l_262;
                (*l_212) = l_226;
                /* statement id: 76 */
                assert (l_59 == &l_3);
                if ((l_238 = ((*l_10) = (((*l_59) || ((*l_222) | ((uint16_t)(*l_10) - (uint16_t)(l_229 != l_232)))) != ((*l_10) <= ((((void*)0 == l_10) <= (((*l_236) = (((uint32_t)((*l_10) >= (*l_222)) / (uint32_t)(*l_59)) >= 0x39F1L)) <= (*l_226))) || l_237))))))
                { /* block id: 80 */
                    int32_t *l_242 = &l_3;
                    for (l_51 = (-3); (l_51 < 17); l_51 += 1)
                    { /* block id: 83 */
                        (*l_212) = &l_11;
                        /* statement id: 84 */
                        assert (l_59 == &l_11);
                    }
                    /* facts after for loop */
                    assert (l_59 == &l_11 || l_59 == &l_3);
                    (*l_212) = (*l_212);
                    if (l_23)
                        goto lbl_241;
                    (*l_212) = (l_226 = l_242);
                    /* statement id: 89 */
                    assert (l_59 == &l_3);
                }
                else
                { /* block id: 90 */
                    (*l_10) = l_243;
                    (*l_212) = &l_3;
                }
                if ((*l_226))
                    continue;
                (*l_261) = ((float)(((*l_223) <= ((((float)((*l_219) = (((float)(((*l_10) < ((float)((float)(-(float)(*l_10)) + (float)((float)(((*l_223) != (((float)(*l_226) - (float)(*l_10)) > ((void*)0 != l_259))) == (*l_226)) / (float)(*l_10))) + (float)(*l_59))) < (-0x2.Ap-1)) - (float)0x0.0p-1) > (**l_212))) / (float)(*l_59)) >= (*l_226)) != 0x2.9FD3CFp+46)) > (*l_10)) + (float)0x7.809E69p-31);
            }
            /* facts after for loop */
            assert (l_59 == &l_3 || l_59 == 0);
        }
        /* facts after for loop */
        assert (l_223 == &l_3 || l_223 == &l_11);
        (*l_223) = 6L;
        (*l_264) = &l_3;
        (*l_10) = (*l_10);
    }
    else
    { /* block id: 102 */
        uint32_t l_267 = 0x50A76282L;
        int16_t l_286 = 5L;
        int32_t **l_292 = &l_10;
        int32_t ***l_291 = &l_292;
        int32_t ****l_290 = &l_291;
        if (((uint16_t)(*l_10) >> (uint16_t)l_267))
        { /* block id: 103 */
            uint16_t l_272 = 65527UL;
            uint16_t l_281 = 1UL;
            int32_t **l_289 = &l_10;
            int32_t ***l_288 = &l_289;
            int32_t ****l_287 = &l_288;
            uint32_t l_297 = 4294967286UL;
            for (l_3 = 0; (l_3 > (-22)); l_3 -= 7)
            { /* block id: 106 */
                int32_t ***l_280 = (void*)0;
                float l_293 = 0x0.Cp-1;
                int32_t l_294 = 0xCB22D995L;
                int32_t *l_301 = &l_294;
            }
        }
        else
        { /* block id: 122 */
            int32_t **l_310 = &l_10;
            int32_t ***l_313 = &l_312;
            float l_315 = 0x1.Ap-1;
            float *l_314 = &l_315;
            float l_317 = 0x6.5F1DF7p-14;
            float *l_316 = &l_317;
            (*l_316) = (((((float)((*l_314) = (((**l_292) > ((float)((float)(((((float)(-0x1.Ep+1) / (float)((void*)0 == l_310)) == 0x0.Fp+1) == (*l_10)) < (((****l_290) <= (((l_311 != (l_313 = &l_312)) > 0x4.3p+1) > (**l_310))) == (*l_10))) * (float)(*l_10)) / (float)(****l_290))) <= (***l_291))) - (float)0x4.5CD309p-25) == (**l_310)) != (***l_291)) == (****l_290));
        }
        (*l_292) = (***l_290);
    }
    (*l_331) = func_14(((*l_331) = func_14(&l_3, (((int16_t)((int32_t)(*l_10) - (int32_t)((int16_t)((*l_10) <= 4294967292UL) << (int16_t)(*l_10))) >> (int16_t)(*l_10)) > (l_329 = (l_326 != (((l_327 = l_327) == &l_328) | (*l_10))))), l_330, &l_3)), l_11, l_51, &l_3);
    /* statement id: 132 */
    assert (l_10 == &l_3);
    return l_332;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_14(int32_t * p_15, uint32_t  p_16, uint32_t  p_17, int32_t * p_18)
{ /* block id: 65 */
    int16_t *l_208 = (void*)0;
    int16_t **l_207 = &l_208;
    const int16_t **l_210 = (void*)0;
    const int16_t ***l_209 = &l_210;
    (*l_209) = l_207;
    /* statement id: 66 */
    assert (l_210 == &l_208);
    return p_15;
    /* statement id: 67 */
    //assert (func_14_rv == 0 || func_14_rv == &l_3);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_19(uint16_t  p_20, int32_t  p_21)
{ /* block id: 7 */
    int32_t l_45 = (-1L);
    int32_t *l_44 = &l_45;
    int32_t **l_43 = &l_44;
    int32_t ***l_42 = &l_43;
    int32_t *l_46 = &l_45;
    int32_t *l_47 = &l_45;
    int32_t *l_48 = &l_45;
    int32_t *l_49 = &l_45;
    int32_t *l_50 = (void*)0;
    (*l_42) = func_24(p_20);
    /* statement id: 12 */
    assert (l_43 == 0);
    return l_50;
    /* statement id: 13 */
    //assert (func_19_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_24(int32_t  p_25)
{ /* block id: 8 */
    int32_t *l_29 = (void*)0;
    int32_t **l_28 = &l_29;
    int32_t ***l_27 = &l_28;
    int32_t ****l_26 = &l_27;
    float l_31 = (-0x1.Ap+1);
    float *l_30 = &l_31;
    int32_t **l_32 = &l_29;
    int32_t **l_33 = &l_29;
    int32_t **l_34 = &l_29;
    int32_t **l_35 = &l_29;
    int32_t **l_36 = &l_29;
    int32_t **l_37 = &l_29;
    int32_t **l_38 = &l_29;
    int32_t **l_39 = &l_29;
    int32_t **l_40 = &l_29;
    int32_t **l_41 = (void*)0;
    (*l_26) = (void*)0;
    /* statement id: 9 */
    assert (l_27 == 0);
    (*l_30) = p_25;
    return l_41;
    /* statement id: 11 */
    //assert (func_24_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_52(int32_t * p_53, uint32_t  p_54, int32_t *** p_55)
{ /* block id: 62 */
    int32_t l_205 = 0x941D4D58L;
    int32_t *l_204 = &l_205;
    int32_t *l_206 = &l_205;
    l_204 = l_204;
    return p_53;
    /* statement id: 64 */
    //assert (func_52_rv == 0 || func_52_rv == &l_3);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(int32_t * p_57, int32_t * p_58)
{ /* block id: 52 */
    int32_t l_179 = (-9L);
    int16_t l_195 = 0x48C2L;
    for (l_179 = 0; (l_179 > (-1)); l_179 -= 9)
    { /* block id: 55 */
        uint16_t l_188 = 0UL;
        uint16_t *l_187 = &l_188;
        uint16_t *l_190 = (void*)0;
        uint16_t **l_189 = &l_190;
        float l_200 = (-0x1.6p+1);
        float *l_199 = &l_200;
        float *l_202 = &l_200;
        float **l_201 = &l_202;
        int32_t l_203 = 0xF23647BCL;
        l_203 = (((uint32_t)(-(uint16_t)(((int32_t)(l_187 != ((*l_189) = &l_188)) + (int32_t)((uint16_t)l_188 << (uint16_t)14)) == l_188)) % (uint32_t)((int16_t)(l_195 > (l_188 <= (!(((int32_t)(*p_57) + (int32_t)(l_199 == ((*l_201) = func_19(l_179, l_195)))) == l_188)))) / (int16_t)l_179)) & l_188);
        /* statement id: 58 */
        assert (l_190 == &l_188);
        assert (l_202 == 0);
        return p_58;
        /* statement id: 59 */
        //assert (func_56_rv == 0 || func_56_rv == &l_294);
    }
    return p_57;
    /* statement id: 61 */
    //assert (func_56_rv == &l_3 || func_56_rv == &l_11);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_60(uint32_t  p_61, int32_t * p_62, uint16_t  p_63)
{ /* block id: 27 */
    uint32_t l_99 = 0xA94120B1L;
    float l_101 = 0x3.2C5A17p-39;
    float *l_100 = &l_101;
    float l_103 = (-0x1.Fp-1);
    float *l_102 = &l_103;
    int32_t l_105 = 1L;
    int32_t *l_104 = &l_105;
    uint32_t l_150 = 0x31763EEAL;
    (*l_102) = (l_99 > ((*l_100) = p_63));
    l_104 = l_100;
    /* statement id: 30 */
    assert (l_104 == &l_101);
    if (((*l_104) < (*l_104)))
    { /* block id: 31 */
        int32_t l_139 = (-1L);
        int32_t *l_140 = &l_105;
        int32_t l_142 = 1L;
        int32_t *l_141 = &l_142;
        float l_143 = 0x0.CFF131p-29;
        int16_t l_145 = 4L;
        int16_t *l_144 = &l_145;
        int16_t l_147 = 0x4F93L;
        int16_t *l_146 = &l_147;
        uint16_t l_149 = 65535UL;
        uint16_t *l_148 = &l_149;
        int32_t l_152 = (-1L);
        int32_t *l_151 = &l_152;
        (*l_151) = ((((p_63 == ((uint16_t)((((int32_t)((uint16_t)((*l_148) = ((int16_t)((((*l_146) = ((uint16_t)((uint16_t)(((int16_t)((*l_144) = (((*l_104) && (0xF02BL ^ ((((int32_t)((*l_141) = (((int16_t)((int16_t)((((int16_t)((uint16_t)(((int16_t)((((uint32_t)((uint16_t)(1UL & p_61) * (uint16_t)((8L && 3UL) | ((1UL <= ((-(uint32_t)((((*l_140) = (l_139 = ((*l_104) = (0L != 0L)))) != 4294967291UL) | p_61)) < p_63)) > 0x0419L))) + (uint32_t)p_63) < p_61) < l_99) - (int16_t)p_61) | 0x91CAL) * (uint16_t)p_63) >> (int16_t)14) & p_63) == p_63) >> (int16_t)5) * (int16_t)p_61) > l_99)) % (int32_t)7UL) > p_63) >= (-1L)))) != 0x32EC2C21L)) % (int16_t)65530UL) || (*l_104)) << (uint16_t)p_61) * (uint16_t)0x72D2L)) <= 0x9115L) ^ p_61) << (int16_t)14)) << (uint16_t)l_99) % (int32_t)l_150) ^ 0x6355D27DL) || p_61) * (uint16_t)0x548CL)) ^ 0xE9F7L) && (*l_140)) <= l_150);
    }
    else
    { /* block id: 40 */
        int32_t **l_153 = &l_104;
        (*l_153) = p_62;
        /* statement id: 41 */
        assert (l_104 == 0);
        return p_62;
        /* statement id: 42 */
        //assert (func_60_rv == 0);
    }
    for (p_61 = 0; (p_61 < 42); p_61 += 1)
    { /* block id: 46 */
        float l_164 = 0x0.8p+1;
        const int32_t l_165 = 0x4B569DADL;
        float *l_168 = &l_164;
        int32_t ****l_175 = (void*)0;
        int32_t **l_177 = (void*)0;
        int32_t ***l_176 = &l_177;
        int32_t *****l_178 = &l_175;
        (*l_104) = ((int32_t)((uint16_t)0UL << (uint16_t)(((int16_t)0x4827L << (int16_t)((int16_t)l_165 % (int16_t)((uint16_t)(l_168 == p_62) * (uint16_t)((int16_t)0xB175L << (int16_t)((int16_t)p_61 >> (int16_t)0))))) > (0x8ADDL ^ ((((int16_t)(((*l_176) = &l_104) == &l_104) - (int16_t)3L) && 1UL) | (*l_104))))) - (int32_t)(*l_104));
        /* statement id: 48 */
        assert (l_177 == &l_104);
        l_178 = &l_175;
    }
    return p_62;
    /* statement id: 51 */
    //assert (func_60_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_66(float  p_67, int32_t **** p_68, int16_t  p_69, int32_t ** p_70)
{ /* block id: 23 */
    int32_t l_97 = (-1L);
    p_70 = func_24(l_97);
    /* statement id: 24 */
    assert (p_70 == 0);
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t **** func_72(const int16_t  p_73, int32_t ** p_74)
{ /* block id: 21 */
    int32_t **l_93 = (void*)0;
    int32_t ***l_92 = &l_93;
    int32_t ****l_91 = &l_92;
    int32_t ****l_94 = &l_92;
    int32_t ****l_95 = &l_92;
    int32_t ****l_96 = (void*)0;
    return l_96;
    /* statement id: 22 */
    //assert (func_72_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_75(float * p_76, int32_t * p_77, int32_t **** p_78, uint32_t  p_79, uint8_t  p_80)
{ /* block id: 14 */
    int32_t l_87 = (-6L);
    int32_t *l_86 = &l_87;
    int32_t **l_89 = &l_86;
    l_86 = l_86;
    if ((****p_78))
    { /* block id: 16 */
        int32_t **l_88 = &l_86;
        return (**p_78);
        /* statement id: 17 */
        //assert (func_75_rv == &l_10);
    }
    else
    { /* block id: 18 */
        int32_t **l_90 = (void*)0;
        return l_90;
        /* statement id: 19 */
        //assert (func_75_rv == 0);
    }
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 84
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 52
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 31, occurrence: 1
   depth: 52, occurrence: 1

XXX total number of pointers: 123

XXX times a variable address is taken: 103
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 651

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 148
   level: 2, occurrence: 40
   level: 3, occurrence: 32
   level: 4, occurrence: 24
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 60
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.3
XXX average alias set size: 1.18

XXX times a non-volatile is read: 312
XXX times a non-volatile is write: 124
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 57
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 15
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
   depth: 4, occurrence: 6
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 11.4
XXX percentage an existing variable is used: 88.6
********************* end of statistics **********************/

