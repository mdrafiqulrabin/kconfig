/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      430711938
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int16_t  f0;
   const int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
static int32_t * func_31(int32_t * p_32, int32_t * p_33, int32_t * p_34, int32_t * p_35, int32_t * p_36);
inline static int32_t * func_40(uint32_t  p_41, int32_t  p_42, uint32_t  p_43, int32_t * p_44);
static uint32_t  func_45(int32_t * p_46);
static int32_t * func_50(uint32_t  p_51, int32_t * p_52, int16_t  p_53, int32_t  p_54);
static int32_t * func_55(int32_t * p_56, int32_t * p_57, int32_t * p_58, int32_t * p_59);
static int32_t * func_60(int32_t * p_61, int32_t * p_62, uint16_t  p_63, int32_t * p_64, const int32_t  p_65);
static int32_t * func_66(int32_t * p_67, uint16_t  p_68, const uint32_t  p_69, int32_t * p_70, const union U0  p_71);
static int32_t  func_76(uint32_t  p_77);
inline static uint16_t  func_93(int32_t ** p_94, union U0  p_95, uint16_t  p_96, uint32_t  p_97, uint16_t  p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_38 = 4;
    int32_t *l_37 = &l_38;
    int32_t *l_39 = &l_38;
    int32_t l_380 = 0x4224FE82;
    int16_t l_381 = 0x7871;
    uint32_t l_382 = 1U;
    int32_t **l_616 = &l_37;
    const uint32_t l_619 = 1U;
    union U0 l_627 = {-7};
    union U0 *l_626 = &l_627;
    int16_t l_628 = 0xD76E;
    (*l_616) = func_31(l_37, &l_38, l_39, &l_38, func_40(func_45(&l_38), ((l_380 & l_381) >= ((65535U || l_382) < l_382)), l_381, &l_380));
    (**l_616) = __builtin_ffs((*l_39));
    (*l_37) = (__builtin_ffsl((**l_616)) < (((uint16_t)l_619 % (uint16_t)((uint16_t)(((uint32_t)(((int32_t)(*l_39) + (int32_t)(*l_37)) & (*l_37)) + (uint32_t)((**l_616) ^ __builtin_parity((*l_39)))) && (**l_616)) % (uint16_t)(*l_37))) < (*l_37)));
    l_626 = (void*)0;
    /* statement id: 351 */
    assert (l_626 == 0);
    return l_628;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_31(int32_t * p_32, int32_t * p_33, int32_t * p_34, int32_t * p_35, int32_t * p_36)
{ /* block id: 225 */
    uint32_t l_435 = 0xE314A90D;
    int32_t l_441 = 0xE0E67F56;
    int32_t *l_440 = &l_441;
    int32_t *****l_442 = (void*)0;
    uint32_t l_443 = 4294967294U;
    union U0 l_499 = {0xF311};
    union U0 *l_498 = &l_499;
    union U0 **l_497 = &l_498;
    const int32_t *l_505 = (void*)0;
    const int32_t **l_504 = &l_505;
    int32_t l_512 = 0x967A7D36;
    const int32_t ***l_526 = &l_504;
    const int32_t ****l_525 = &l_526;
    uint16_t l_558 = 0xB9D7;
    int32_t l_577 = 0;
    if ((__builtin_ctzl(l_435) ^ (((((int32_t)(*p_33) / (int32_t)l_435) && (((func_45(l_440) && ((void*)0 != l_442)) == l_435) == l_435)) != l_435) != l_443)))
    { /* block id: 226 */
        int32_t **l_444 = &l_440;
        union U0 l_445 = {-1};
        int32_t ****l_468 = (void*)0;
        (*l_440) = func_93(l_444, l_445, ((int16_t)(*l_440) << (int16_t)(**l_444)), ((int16_t)((uint16_t)(((int16_t)(((uint16_t)(*l_440) % (uint16_t)(**l_444)) || ((int16_t)__builtin_bswap32(((int16_t)(((0x0784 >= (*l_440)) && ((!(-(int16_t)(-6))) < (**l_444))) & 4294967294U) >> (int16_t)(**l_444))) / (int16_t)0x230A)) << (int16_t)14) | (*l_440)) >> (uint16_t)(**l_444)) >> (int16_t)(**l_444)), (**l_444));
        (*l_444) = (*l_444);
        (*p_33) = ((uint32_t)(**l_444) - (uint32_t)((uint16_t)((((uint16_t)(((void*)0 != l_468) | (0x8113AED4 < (*p_32))) << (uint16_t)10) & (*l_440)) >= (*l_440)) + (uint16_t)(((**l_444) & 0) < (-7))));
    }
    else
    { /* block id: 230 */
        uint32_t l_469 = 0xC56C3AD2;
        int32_t *l_470 = &l_441;
        const int32_t *l_503 = &l_441;
        const int32_t **l_502 = &l_503;
        (*p_35) = (*p_35);
        if ((l_469 == 0x7A4E7BD5))
        { /* block id: 232 */
            int32_t *l_471 = &l_441;
            return p_33;
            /* statement id: 233 */
            //assert (func_31_rv == &l_38);
        }
        else
        { /* block id: 234 */
            int32_t **l_476 = &l_470;
            union U0 l_491 = {-2};
            union U0 *l_490 = &l_491;
            for (l_469 = 0; (l_469 <= 45); l_469 += 2)
            { /* block id: 237 */
                for (l_435 = 0; (l_435 > 48); l_435++)
                { /* block id: 240 */
                    int32_t ***l_477 = &l_476;
                    (*l_477) = l_476;
                    (**l_477) = p_35;
                    /* statement id: 242 */
                    //assert (l_470 == &l_38);
                }
            }
            /* facts after for loop */
            //assert (l_470 == &l_38 || l_470 == &l_441);
            (*l_440) = ((uint16_t)(((uint16_t)((uint16_t)((uint32_t)((((int16_t)((int16_t)(((*l_440) <= (*l_470)) >= (*p_33)) << (int16_t)8) << (int16_t)0) ^ (*l_440)) | ((**l_476) > (*l_440))) % (uint32_t)func_76(((*p_32) >= (l_490 == &l_491)))) >> (uint16_t)(**l_476)) - (uint16_t)(**l_476)) ^ 4294967286U) + (uint16_t)0x9E66);
            (*l_440) = (l_470 != (void*)0);
        }
        /* facts after branching */
        //assert (l_470 == &l_38 || l_470 == &l_441);
        (*l_440) = ((*l_470) | ((l_442 == l_442) <= (((uint16_t)(0xA378D6CC != ((uint32_t)(*l_440) + (uint32_t)(-(int16_t)(l_497 == &l_498)))) << (uint16_t)4) && ((uint16_t)65535U << (uint16_t)((*l_470) & (*l_470))))));
        (*l_502) = p_32;
        /* statement id: 249 */
        //assert (l_503 == &l_38);
    }
    (*l_504) = p_36;
    for (l_499.f0 = 0; (l_499.f0 > (-24)); l_499.f0 -= 1)
    { /* block id: 254 */
        uint32_t l_515 = 4294967293U;
        uint32_t l_516 = 0x0147CAB0;
        const int32_t *l_517 = (void*)0;
        (*l_504) = func_55(p_34, func_40(l_515, ((l_516 >= (*l_440)) > l_515), (*l_440), p_33), p_32, p_35);
        l_517 = (*l_504);
    }
    for (l_499.f0 = 0; (l_499.f0 > (-1)); l_499.f0 -= 7)
    { /* block id: 260 */
        int32_t **l_524 = &l_440;
        int32_t ***l_523 = &l_524;
        int32_t ****l_522 = &l_523;
        int32_t *****l_578 = &l_522;
        union U0 ***l_615 = (void*)0;
        for (l_435 = 13; (l_435 < 43); ++l_435)
        { /* block id: 263 */
            l_522 = l_522;
        }
    }
    return p_34;
    /* statement id: 347 */
    //assert (func_31_rv == &l_38);
}


/* ------------------------------------------ */
/* 
 * reads : l_38
 * writes: l_38
 */
inline static int32_t * func_40(uint32_t  p_41, int32_t  p_42, uint32_t  p_43, int32_t * p_44)
{ /* block id: 202 */
    union U0 **l_383 = (void*)0;
    int32_t l_386 = (-10);
    int32_t *l_431 = (void*)0;
    int32_t *l_433 = &l_386;
    int32_t *l_434 = (void*)0;
lbl_410:
    (*p_44) = (((void*)0 != l_383) < (((int16_t)l_386 + (int16_t)((int32_t)(*p_44) + (int32_t)0xA4D6B5EC)) || ((int16_t)l_386 >> (int16_t)4)));
    if (l_386)
    { /* block id: 204 */
        int32_t *l_393 = (void*)0;
        union U0 *l_397 = (void*)0;
        union U0 **l_396 = &l_397;
        uint16_t l_409 = 5U;
        for (l_386 = (-10); (l_386 != (-16)); l_386 -= 1)
        { /* block id: 207 */
            return l_393;
            /* statement id: 208 */
            //assert (func_40_rv == 0);
        }
        (*p_44) = ((int16_t)(__builtin_bswap32((l_396 == &l_397)) >= ((*p_44) ^ (((((-1) && (((uint16_t)((*p_44) != ((uint16_t)(0xC893 > ((~l_386) <= ((uint32_t)p_43 - (uint32_t)l_386))) >> (uint16_t)l_386)) + (uint16_t)l_386) && 0x9F43)) < 0xC003) > (-1)) > l_386))) / (int16_t)0x564A);
        (*p_44) = ((int16_t)p_41 >> (int16_t)((int16_t)l_409 >> (int16_t)p_42));
        if (p_43)
            goto lbl_410;
    }
    else
    { /* block id: 213 */
        int32_t **l_417 = (void*)0;
        int32_t ***l_416 = &l_417;
        int32_t ****l_415 = &l_416;
        int32_t *l_428 = &l_386;
        int32_t *l_429 = &l_386;
        int32_t *l_430 = &l_386;
        if ((*p_44))
        { /* block id: 214 */
            int32_t *l_411 = (void*)0;
            return l_411;
            /* statement id: 215 */
            //assert (func_40_rv == 0);
        }
        else
        { /* block id: 216 */
            int32_t *l_421 = &l_386;
            int32_t **l_420 = &l_421;
            union U0 l_422 = {0x5DB2};
            int16_t l_427 = 1;
            (**l_420) = ((int16_t)0 / (int16_t)(((!(l_415 != (void*)0)) > ((int32_t)(func_93(l_420, l_422, ((uint16_t)(((int32_t)(((**l_415) != &p_44) != 7) + (int32_t)l_427) <= 0xCFE83901) + (uint16_t)(**l_420)), p_41, p_42) ^ 1) % (int32_t)(*l_421))) && l_386));
            (*p_44) = (-1);
        }
        (*l_415) = (void*)0;
        /* statement id: 220 */
        assert (l_416 == 0);
        return l_431;
        /* statement id: 221 */
        //assert (func_40_rv == 0);
    }
    (*p_44) = ((l_383 == (void*)0) | ((~l_386) && p_43));
    return l_434;
    /* statement id: 224 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_38
 * writes: l_38
 */
static uint32_t  func_45(int32_t * p_46)
{ /* block id: 37 */
    int32_t l_47 = 8;
    int32_t **l_99 = (void*)0;
    union U0 l_100 = {0xB1D3};
    const int32_t l_138 = 0x96F1EF3A;
    int32_t *l_144 = &l_47;
    int32_t **l_374 = &l_144;
    for (l_47 = 0; (l_47 > 7); l_47 += 4)
    { /* block id: 40 */
        return l_47;
    }
    (*p_46) = l_47;
    (*l_374) = func_50(l_47, func_55(&l_47, func_60(func_66(&l_47, (((uint16_t)((int32_t)func_76(l_47) - (int32_t)((0x0615A034 == ((int16_t)((1 >= (l_47 == func_93(l_99, l_100, l_47, l_47, l_100.f0))) || (*p_46)) % (int16_t)l_100.f0)) | 0x82D0)) % (uint16_t)0x4F58) | l_47), l_47, &l_47, l_100), p_46, l_100.f0, p_46, l_138), l_144, p_46), (*l_144), (*l_144));
    /* statement id: 199 */
    assert (l_144 == 0);
    (*p_46) = ((uint32_t)(-(int16_t)l_100.f0) % (uint32_t)0xBE6784F5);
    return l_100.f0;
}


/* ------------------------------------------ */
/* 
 * reads : l_38 l_441
 * writes: l_38 l_441
 */
static int32_t * func_50(uint32_t  p_51, int32_t * p_52, int16_t  p_53, int32_t  p_54)
{ /* block id: 75 */
    int32_t l_174 = (-1);
    int32_t *l_173 = &l_174;
    int32_t **l_172 = &l_173;
    int32_t ***l_171 = &l_172;
    union U0 l_203 = {0x2E97};
    union U0 *l_202 = &l_203;
    int32_t ****l_245 = &l_171;
    int32_t *l_255 = &l_174;
    int32_t *l_256 = &l_174;
    int32_t *l_257 = &l_174;
    int32_t *l_259 = &l_174;
    int32_t l_279 = 0x8FC63146;
    union U0 **l_280 = &l_202;
    uint32_t l_308 = 0x30DB2345;
    int32_t l_309 = 0x170D8755;
    uint16_t l_310 = 0xD8F7;
    uint16_t l_315 = 2U;
    int32_t *l_372 = &l_279;
    int32_t *l_373 = (void*)0;
    for (p_51 = (-28); (p_51 == 60); p_51 += 4)
    { /* block id: 78 */
        int32_t l_159 = 0;
        union U0 l_164 = {0xC216};
        int32_t **l_177 = &l_173;
        int32_t *l_246 = &l_174;
        int32_t *l_253 = &l_174;
        int32_t *l_262 = &l_174;
        int32_t *l_263 = &l_159;
        int32_t *l_264 = &l_159;
    }
    (*l_280) = &l_203;
    (**l_171) = func_55(func_60((**l_171), func_55((***l_245), (***l_245), (*l_172), &p_54), (*l_257), (***l_245), p_53), p_52, p_52, p_52);
    /* statement id: 150 */
    //assert (l_173 == &l_38 || l_173 == &l_441);
    if ((((*l_259) == ((int32_t)((uint16_t)p_53 << (uint16_t)9) - (int32_t)0x5D285D87)) | ((uint16_t)(*l_257) % (uint16_t)((int32_t)(*p_52) - (int32_t)((int32_t)(-1) - (int32_t)((**l_172) | ((int16_t)((uint16_t)p_51 + (uint16_t)((func_76(p_54) && 65530U) || 0x02E813D5)) << (int16_t)p_51)))))))
    { /* block id: 151 */
        union U0 l_298 = {0x14F3};
        int32_t l_307 = 2;
        int32_t ***l_312 = &l_172;
        uint16_t l_340 = 65530U;
        uint32_t l_363 = 0x2EF82457;
        int32_t ****l_371 = &l_312;
        for (p_51 = 0; (p_51 != 45); p_51 += 9)
        { /* block id: 154 */
            int32_t **l_297 = &l_256;
            (**l_172) = func_93(l_297, l_298, ((*p_52) < (p_51 | ((uint32_t)p_53 + (uint32_t)((int16_t)((&l_297 == (void*)0) ^ p_54) << (int16_t)2)))), ((int16_t)(((uint32_t)0xA823A494 - (uint32_t)l_307) >= l_308) >> (int16_t)l_309), l_310);
            (*l_255) = (&l_298 != (void*)0);
        }
        (**l_171) = func_55(func_55(&l_307, (**l_171), func_60(func_66(&l_307, p_54, ((((*p_52) | (~(*p_52))) && (*p_52)) < ((&p_52 == (*l_171)) || 0x29B8D93B)), (***l_245), (**l_280)), (**l_171), p_53, (*l_172), p_51), (***l_245)), (*l_172), (**l_171), &l_307);
        if (l_307)
        { /* block id: 159 */
            (*l_245) = l_312;
        }
        else
        { /* block id: 161 */
            const uint16_t l_316 = 0xEAE1;
            int32_t *l_323 = &l_307;
            union U0 l_327 = {0x0E00};
            uint16_t l_332 = 3U;
            int32_t ***l_346 = &l_172;
            int16_t l_366 = (-10);
            (**l_312) = (**l_312);
            for (l_308 = 0; (l_308 <= 5); ++l_308)
            { /* block id: 165 */
                int32_t *l_317 = &l_279;
                int32_t *****l_351 = &l_245;
                (*l_257) = l_315;
            }
            l_371 = &l_346;
            /* statement id: 191 */
            assert (l_371 == &l_346);
        }
        /* facts after branching */
        //assert (l_371 == dangling || l_371 == &l_312);
    }
    else
    { /* block id: 193 */
        (*l_172) = &p_54;
        /* statement id: 194 */
        assert (l_173 == &p_54);
        (**l_172) = 0xCDE3A13B;
        (*l_280) = (*l_280);
    }
    /* facts after branching */
    //assert (l_173 == &p_54 || l_173 == &l_38 || l_173 == &l_441);
    return l_373;
    /* statement id: 198 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_38 l_441
 * writes: l_38 l_441
 */
static int32_t * func_55(int32_t * p_56, int32_t * p_57, int32_t * p_58, int32_t * p_59)
{ /* block id: 70 */
    int16_t l_149 = 0x7A6A;
    const uint16_t l_150 = 5U;
    int32_t l_152 = (-2);
    int32_t *l_151 = &l_152;
    const union U0 l_153 = {-4};
    int32_t **l_154 = (void*)0;
    int32_t **l_155 = &l_151;
    uint32_t l_156 = 0xBCCD07CA;
    (*l_155) = func_66(p_59, ((uint16_t)((int16_t)(l_149 >= l_149) % (int16_t)l_149) / (uint16_t)l_149), l_150, l_151, l_153);
    (*l_155) = func_60(func_60((*l_155), func_60((*l_155), p_59, l_156, (*l_155), (**l_155)), (*l_151), (*l_155), (*l_151)), p_59, (**l_155), p_59, (*l_151));
    /* statement id: 72 */
    //assert (l_151 == &l_38 || l_151 == &p_54 || l_151 == &l_307 || l_151 == &l_441);
    (*l_151) = ((-2) || (*l_151));
    return p_57;
    /* statement id: 74 */
    //assert (func_55_rv == &l_38 || func_55_rv == &l_174 || func_55_rv == &p_54 || func_55_rv == &l_441 || func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_38 p_54 l_307 l_441
 */
static int32_t * func_60(int32_t * p_61, int32_t * p_62, uint16_t  p_63, int32_t * p_64, const int32_t  p_65)
{ /* block id: 66 */
    int32_t l_140 = (-10);
    int32_t *l_139 = &l_140;
    int32_t **l_141 = &l_139;
    (*l_141) = l_139;
    (*p_62) = ((int16_t)p_63 >> (int16_t)4);
    return p_62;
    /* statement id: 69 */
    //assert (func_60_rv == &l_38 || func_60_rv == &p_54 || func_60_rv == &l_174 || func_60_rv == &l_307 || func_60_rv == &l_441);
}


/* ------------------------------------------ */
/* 
 * reads : l_38 l_441
 * writes:
 */
static int32_t * func_66(int32_t * p_67, uint16_t  p_68, const uint32_t  p_69, int32_t * p_70, const union U0  p_71)
{ /* block id: 63 */
    int32_t l_131 = 0x320B692E;
    int32_t *l_137 = &l_131;
    (*l_137) = ((((int32_t)(*p_70) / (int32_t)((int32_t)(__builtin_clz(p_69) <= func_76((((int16_t)((uint16_t)(((int16_t)0x785D << (int16_t)4) || p_68) % (uint16_t)((uint32_t)((-(int32_t)((l_131 != ((((l_131 | (((!((uint32_t)(4294967295U & __builtin_ia32_crc32qi((((((((*p_70) ^ (*p_70)) < p_68) < p_69) & l_131) && p_68) < 0xCA57), p_71.f0)) / (uint32_t)l_131)) != p_71.f0) >= 0U)) <= p_71.f0) & 0) > 0xC4CB)) && p_68)) <= 0U) - (uint32_t)p_68)) << (int16_t)p_71.f0) || l_131))) / (int32_t)l_131)) != p_68) == 5);
    return p_70;
    /* statement id: 65 */
    //assert (func_66_rv == &l_47 || func_66_rv == &l_152 || func_66_rv == &l_38 || func_66_rv == &l_174 || func_66_rv == &l_307 || func_66_rv == &l_441);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_76(uint32_t  p_77)
{ /* block id: 44 */
    int32_t l_88 = 0x2B5D06DE;
    int32_t *l_87 = &l_88;
    for (p_77 = 0; (p_77 >= 10); p_77 += 4)
    { /* block id: 47 */
        int32_t l_80 = 1;
        int32_t **l_89 = (void*)0;
        int32_t **l_90 = &l_87;
        for (l_80 = 0; (l_80 == (-23)); l_80 -= 1)
        { /* block id: 50 */
            int32_t *l_84 = &l_80;
            int32_t **l_83 = &l_84;
            int32_t ***l_85 = (void*)0;
            int32_t ***l_86 = &l_83;
            (*l_86) = l_83;
            if (p_77)
                break;
        }
        (*l_90) = l_87;
        (**l_90) = p_77;
    }
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_93(int32_t ** p_94, union U0  p_95, uint16_t  p_96, uint32_t  p_97, uint16_t  p_98)
{ /* block id: 58 */
    int32_t l_102 = 0;
    int32_t *l_101 = &l_102;
    int32_t **l_103 = (void*)0;
    l_101 = l_101;
    (*l_101) = (p_95.f0 > ((-1) & (((int16_t)(p_97 >= ((uint16_t)((uint32_t)((&l_102 != &l_102) & ((uint32_t)(((uint16_t)(0xE42AC96A < p_98) + (uint16_t)(&l_101 != p_94)) | (*l_101)) / (uint32_t)p_97)) + (uint32_t)(*l_101)) << (uint16_t)12)) >> (int16_t)p_98) | p_98)));
    (*l_101) = (*l_101);
    return p_98;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 160
XXX total union variables: 9

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 20, occurrence: 1
   depth: 24, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 154

XXX times a variable address is taken: 148
XXX times a pointer is dereferenced on RHS: 222
breakdown:
   depth: 1, occurrence: 139
   depth: 2, occurrence: 48
   depth: 3, occurrence: 20
   depth: 4, occurrence: 14
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 101
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 21
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 675

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 832
   level: 2, occurrence: 169
   level: 3, occurrence: 51
   level: 4, occurrence: 33
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 75
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.6
XXX average alias set size: 1.64

XXX times a non-volatile is read: 960
XXX times a non-volatile is write: 285
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 87
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 39
   depth: 1, occurrence: 27
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 12.7
XXX percentage an existing variable is used: 87.3
********************* end of statistics **********************/

