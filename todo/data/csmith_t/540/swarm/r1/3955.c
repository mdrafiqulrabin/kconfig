/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3923820904
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 2;
   const uint16_t  f1;
   int32_t  f2;
   int16_t  f3;
   int32_t  f4;
   int16_t  f5;
   int8_t  f6;
   const uint16_t  f7;
   float  f8;
};
#pragma pack(pop)

struct S1 {
   int16_t  f0;
   uint32_t  f1;
   const signed f2 : 3;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   const signed f0 : 11;
   signed f1 : 13;
   const unsigned f2 : 17;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S3 {
   int8_t  f0;
   uint16_t  f1;
   float  f2;
   uint32_t  f3;
   int32_t  f4;
   float  f5;
   float  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t  func_5(int8_t  p_6);
static struct S3  func_14(struct S0  p_15, struct S0  p_16, uint32_t  p_17);
static struct S0  func_18(struct S3  p_19, const struct S3  p_20, struct S3  p_21);
static int16_t  func_23(struct S0  p_24, uint32_t  p_25, struct S0  p_26, uint32_t  p_27);
static struct S3  func_37(int16_t  p_38, int32_t  p_39, int16_t  p_40, uint32_t  p_41);
static int8_t  func_60(struct S1  p_61, struct S2  p_62);
static struct S1  func_63(struct S1  p_64);
static uint16_t  func_68(struct S0  p_69, uint32_t  p_70);
static struct S0  func_71(uint32_t  p_72, float  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x5CE96B77;
    uint32_t l_12 = 0x3C7D24B5;
    struct S3 l_22 = {0xC0,0x84A4,0x9.FB108Fp+63,0x93AF8EF5,1,0x1.4p+1,0xA.A91A76p+94};
    struct S0 l_758 = {0,8U,1,0xE998,0,0x40CA,0x23,65532U,0x0.4DB04Dp+42};
    uint32_t l_760 = 0xFA4ADDCB;
    for (l_2 = 0; (l_2 > (-18)); --l_2)
    { /* block id: 3 */
        uint32_t l_8 = 6U;
        l_8 &= func_5(l_2);
        if (l_2)
            break;
    }
    l_2 = ((-(float)((float)l_12 + (float)(-(float)func_5(l_2)))) == l_12);
    l_22 = func_14(func_18(l_22, l_22, l_22), l_758, l_758.f3);
    return l_760;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_5(int8_t  p_6)
{ /* block id: 4 */
    int32_t l_7 = 0x0AB227D3;
    l_7 = 0x0.4p+1;
    return l_7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S3  func_14(struct S0  p_15, struct S0  p_16, uint32_t  p_17)
{ /* block id: 154 */
    struct S3 l_759 = {0xEF,0x802D,0x7.Dp-1,0x9CC1B78A,0x36D86192,0xE.0737E0p-51,-0x4.4p+1};
    return l_759;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_18(struct S3  p_19, const struct S3  p_20, struct S3  p_21)
{ /* block id: 11 */
    struct S0 l_28 = {1,0x506E,0x4F120B25,0x307D,8,0xB33D,0x12,5U,-0x2.5p-1};
    int32_t l_751 = 0x65369205;
    l_751 &= ((p_20.f1 | ((func_23(l_28, ((int32_t)(l_28.f5 >= p_19.f1) - (int32_t)((int32_t)((int16_t)(-1) - (int16_t)((uint16_t)((l_28.f6 <= func_5(p_21.f3)) | func_5(p_20.f4)) >> (uint16_t)p_21.f0)) - (int32_t)0x078C3FCE)), l_28, l_28.f1) || p_20.f0) <= l_28.f7)) <= (-4));
    l_28.f2 = (0x4.75030Cp+17 >= (((float)((float)0x4.7BE039p-89 / (float)(l_28.f1 > l_28.f4)) + (float)0x1.2p+1) > ((float)0xD.878BC4p+36 - (float)0x4.CD9834p-49)));
    return l_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_23(struct S0  p_24, uint32_t  p_25, struct S0  p_26, uint32_t  p_27)
{ /* block id: 12 */
    int16_t l_42 = 1;
    const int16_t l_56 = (-5);
    struct S3 l_750 = {0,65535U,0x3.9B4191p+50,7U,-3,0xF.36B687p-30,-0x4.Dp-1};
    l_750 = func_37(l_42, (((int16_t)((uint32_t)(((int32_t)((uint32_t)((uint32_t)(p_24.f6 & ((((l_42 != (l_42 || (0xFCE2E644 <= 0U))) | ((int16_t)p_26.f7 << (int16_t)(~(p_26.f5 && (func_5((0x85E45CF3 <= 1U)) | l_56))))) & 0x4177E56D) < p_26.f7)) + (uint32_t)0x178D33F6) % (uint32_t)0xBA0E3889) % (int32_t)p_24.f6) > l_56) - (uint32_t)l_56) + (int16_t)1) ^ p_24.f3), p_24.f7, p_25);
    return p_26.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S3  func_37(int16_t  p_38, int32_t  p_39, int16_t  p_40, uint32_t  p_41)
{ /* block id: 13 */
    uint32_t l_59 = 0U;
    struct S1 l_65 = {0x21FB,3U,-1};
    struct S2 l_194 = {28,77,157};
    struct S3 l_216 = {5,0x5434,-0x4.Dp+1,0U,-2,0x7.7p-1,0x2.A24BECp+30};
    int32_t l_323 = 1;
    int32_t l_325 = (-1);
    int32_t l_337 = 0xA4408C10;
    int32_t l_341 = 0xF3846020;
    int32_t l_345 = 0xE41174D2;
    int32_t l_349 = (-1);
    int32_t l_357 = (-6);
    int32_t l_358 = 0x2AD4DA4A;
    int32_t l_360 = 7;
    int32_t l_392 = (-1);
    int32_t l_409 = 0xEA9CB6A7;
    int32_t l_418 = 0x7EC04D9A;
    int32_t l_421 = 0;
    uint32_t l_646 = 0U;
    int32_t l_742 = 0x4E16CC60;
    int32_t l_743 = (-10);
    int32_t l_744 = 0;
    if (((l_59 > l_59) < (func_5(func_60(func_63(l_65), l_194)) == (p_41 ^ ((int32_t)(p_40 ^ p_40) + (int32_t)p_38)))))
    { /* block id: 38 */
        int16_t l_228 = 0xB9AC;
        int32_t l_233 = 1;
        int32_t l_234 = 5;
        int8_t l_328 = 0x6A;
        int32_t l_335 = 0xF20C6C97;
        float l_353 = (-0x1.5p-1);
        int32_t l_361 = 0x323BC560;
        int32_t l_365 = 0x7F818FFB;
        int32_t l_366 = 0x8C0C089D;
        int32_t l_382 = 1;
        int32_t l_383 = (-1);
        int32_t l_386 = 0x854BC38B;
        int32_t l_402 = 1;
        int32_t l_417 = 0x3121926E;
        float l_425 = (-0x1.Dp+1);
        int32_t l_426 = (-8);
        struct S3 l_432 = {0xB1,1U,0x1.1B3EB4p+70,0U,0x9819D070,-0x5.Cp+1,0x5.8p-1};
        int32_t l_466 = 0;
        int32_t l_469 = 0xF472CE6E;
        int32_t l_470 = 0x6A039872;
        int32_t l_471 = 0x5EABFD20;
        int32_t l_473 = 0xDDF15BD0;
        int32_t l_477 = 0x510D6375;
        int32_t l_478 = 0x1EDD1ABF;
        int32_t l_479 = 0xC4D434EB;
        int32_t l_481 = 0xA97BCDC0;
        int32_t l_484 = 1;
        uint16_t l_488 = 1U;
        int16_t l_546 = 0x1376;
        int32_t l_619 = 0x4654585D;
        float l_733 = 0xC.D245B6p+58;
lbl_282:
        l_216 = l_216;
        for (p_39 = 23; (p_39 <= 10); --p_39)
        { /* block id: 42 */
            uint32_t l_232 = 0xB01C2EB0;
            int32_t l_235 = (-1);
            int32_t l_305 = 0xDB45C908;
            int32_t l_331 = 7;
            int32_t l_333 = 0x359FE1FD;
            int32_t l_342 = 0x536371DD;
            int32_t l_346 = (-8);
            int32_t l_350 = 0x3D254469;
            uint32_t l_367 = 0xCA904210;
            int32_t l_396 = 0xB767B892;
            int32_t l_400 = 0x74D75770;
            int32_t l_401 = 0x853D6C6D;
            int32_t l_407 = 3;
            int32_t l_411 = 0x2AD76D7F;
            int32_t l_412 = 0xE2189C13;
            int32_t l_415 = (-1);
            int32_t l_416 = 0xDD281216;
            int32_t l_424 = 9;
            int32_t l_483 = 1;
            uint32_t l_516 = 0x034FCF98;
            int16_t l_545 = 0;
            const struct S3 l_547 = {0xEF,65532U,0xB.55CBC5p+77,0x03182638,0x486AF52D,0x9.173FE6p-70,0x0.6p+1};
            uint32_t l_657 = 0x153BC88B;
            int16_t l_738 = 0xEE46;
            if (p_38)
            { /* block id: 43 */
                int32_t l_231 = 5;
                l_233 = (((float)(+((float)p_41 / (float)p_39)) / (float)0x5.80C9BEp-2) > ((float)p_38 - (float)((float)(((((0xF.D07D77p-12 > (l_228 < ((float)l_231 - (float)0x1.8D7BDAp+69))) != 0x9.72CAAEp-81) != l_232) != l_232) <= p_40) + (float)l_231)));
                l_234 = (-0x1.9p+1);
                l_235 ^= l_228;
            }
            else
            { /* block id: 47 */
                int32_t l_253 = 1;
                struct S3 l_257 = {0xA5,0U,0x4.82F0F2p-46,0x67B80CB6,-1,0x1.7p-1,0x0.Bp+1};
                int32_t l_324 = 9;
                int32_t l_329 = 0x7A7FA219;
                int32_t l_332 = 0xF85E5C20;
                int32_t l_338 = 0x8E8DD6AA;
                int32_t l_348 = (-1);
                int32_t l_351 = 0x934E2D67;
                int32_t l_354 = 0x909D75B0;
                int32_t l_362 = (-1);
                int16_t l_377 = 1;
                int32_t l_387 = 0;
                int32_t l_388 = 0x8D6C9D16;
                int32_t l_389 = 0xEC25BE30;
                int32_t l_390 = 4;
                int32_t l_393 = 0x994FFB7B;
                int32_t l_395 = (-1);
                int32_t l_398 = (-3);
                int32_t l_405 = 0xEB184F4D;
                int32_t l_414 = 0x9C780D75;
                int32_t l_428 = 0;
                uint32_t l_429 = 0xEE653A38;
                int16_t l_442 = 6;
                for (l_235 = 28; (l_235 < (-19)); l_235 -= 1)
                { /* block id: 50 */
                    struct S3 l_258 = {0,1U,0x4.E05BE5p+23,4U,1,0x1.6p-1,0x7.57D954p+68};
                    int32_t l_279 = 0xC5350917;
                    uint32_t l_281 = 4294967293U;
                    int32_t l_283 = (-1);
                    struct S3 l_306 = {0x21,0x04DD,-0x10.0p+1,0x08B0A408,0x92D2716D,-0x9.3p-1,0x9.7ABD0Cp+20};
                    if (p_38)
                    { /* block id: 51 */
                        int16_t l_256 = 0x5BCB;
                        l_256 = (~((int32_t)0 - (int32_t)((+((uint32_t)((uint16_t)0U << (uint16_t)((((int16_t)(((p_38 | ((int16_t)(((((uint32_t)((p_38 >= ((!l_253) && p_39)) ^ p_38) / (uint32_t)l_216.f3) | ((uint16_t)(((p_39 >= 0x030F) > p_39) < p_40) << (uint16_t)14)) >= 1) || p_39) + (int16_t)0xCC2C)) >= p_40) < 0x40994857) >> (int16_t)12) || 0x478B0562) < p_41)) % (uint32_t)p_40)) != p_40)));
                        if (p_38)
                            continue;
                        if (p_38)
                            continue;
                    }
                    else
                    { /* block id: 55 */
                        int32_t l_280 = 0x250765B2;
                        l_258 = l_257;
                        l_194.f1 &= ((int16_t)((uint32_t)((int16_t)(((((((((int32_t)((uint16_t)((((((uint32_t)(((int16_t)(l_257.f0 == (-(int32_t)p_41)) << (int16_t)(((uint16_t)l_234 << (uint16_t)p_39) || ((!(((l_253 != l_279) == 0x9CEA0C12) & (((9 > l_194.f0) ^ l_258.f1) ^ l_279))) <= 0x7D13))) != l_258.f4) % (uint32_t)l_280) ^ 4294967295U) > l_281) == l_258.f4) & l_258.f3) << (uint16_t)9) + (int32_t)l_234) && l_235) ^ p_39) > l_216.f1) != 4294967292U) >= l_257.f1) >= l_280) || p_41) + (int16_t)p_38) % (uint32_t)p_40) % (int16_t)l_216.f0);
                        if (l_65.f1)
                            goto lbl_282;
                    }
                    if (p_39)
                        goto lbl_282;
                    if (l_283)
                        continue;
                    for (l_258.f3 = 0; (l_258.f3 >= 20); ++l_258.f3)
                    { /* block id: 64 */
                        int16_t l_304 = 0xE804;
                        l_253 &= 0xA4EB4185;
                        l_305 |= (p_39 >= ((((uint16_t)((-4) && (!((int32_t)((int32_t)(((((int16_t)(!((uint16_t)p_39 + (uint16_t)((uint16_t)(((((p_40 || 0x595770AF) >= ((int16_t)((int32_t)(0xFB56 == 0x192D) % (int32_t)0x48BBD532) / (int16_t)((p_39 <= l_234) && p_41))) <= 8U) ^ l_234) < 0xB593A661) + (uint16_t)0xB51D))) << (int16_t)3) & l_258.f4) ^ 65526U) | p_39) + (int32_t)p_38) / (int32_t)l_232))) % (uint16_t)l_258.f0) ^ l_304) == l_235));
                        l_306 = l_258;
                        l_253 &= l_304;
                    }
                }
                if ((p_39 < ((uint16_t)((uint32_t)((uint32_t)((l_257.f4 == ((2U <= ((uint16_t)l_235 % (uint16_t)((uint32_t)(((int16_t)(l_233 > l_253) % (int16_t)0x241A) || ((p_40 < ((!((l_257.f1 ^ l_216.f3) && 0xE31144BC)) ^ 0x0CC574BB)) && p_40)) + (uint32_t)p_38))) | 0x69B0)) == p_38) + (uint32_t)0xA37F8D69) - (uint32_t)l_233) << (uint16_t)l_194.f1)))
                { /* block id: 71 */
                    int8_t l_320 = 8;
                    int32_t l_321 = 0xC6D8FC74;
                    int32_t l_326 = 0x7D6875B3;
                    int32_t l_330 = 1;
                    int32_t l_343 = 0xF5E08FB8;
                    int32_t l_344 = 6;
                    int32_t l_352 = 0x5B3C0CD3;
                    int32_t l_356 = 0xCACCCAD1;
                    int32_t l_359 = (-4);
                    int32_t l_363 = 0;
                    int8_t l_370 = 1;
                    int32_t l_399 = (-5);
                    int32_t l_403 = 0xD12B4322;
                    int32_t l_410 = 0xDEC18580;
                    int32_t l_413 = 0xDA063D4E;
                    int32_t l_419 = 0;
                    int32_t l_420 = 0x51DE6E45;
                    int32_t l_423 = 0x0B7AB3F3;
                    if (l_216.f4)
                    { /* block id: 72 */
                        int8_t l_322 = (-1);
                        int32_t l_327 = 0xB295AFFE;
                        int32_t l_334 = 0;
                        int32_t l_336 = 1;
                        int32_t l_339 = 2;
                        int32_t l_340 = 0x1A346ECE;
                        int32_t l_347 = 0x5CB8CD81;
                        int32_t l_355 = (-8);
                        int32_t l_364 = 0xB2C4312D;
                        uint32_t l_371 = 0x60737BC0;
                        l_320 = l_257.f4;
                        ++l_367;
                        --l_371;
                    }
                    else
                    { /* block id: 76 */
                        int32_t l_374 = (-3);
                        int32_t l_375 = (-8);
                        int32_t l_376 = 1;
                        int32_t l_378 = (-6);
                        int32_t l_379 = 1;
                        int32_t l_380 = 0;
                        int32_t l_381 = 0xFD3BF148;
                        int32_t l_384 = 3;
                        int32_t l_385 = 0x104672E0;
                        int32_t l_391 = 0x453F8A4F;
                        int32_t l_394 = 0;
                        int32_t l_397 = 0;
                        int32_t l_404 = 0x64F591B0;
                        int32_t l_406 = 0xFA400113;
                        int32_t l_408 = (-1);
                        int32_t l_422 = 0x7F4204E5;
                        int32_t l_427 = 0x25A27A89;
                        ++l_429;
                        l_393 = (-1);
                    }
                    return l_432;
                }
                else
                { /* block id: 81 */
                    uint16_t l_437 = 2U;
                    int32_t l_439 = 0x297AA096;
                    int32_t l_440 = 1;
                    int32_t l_448 = 1;
                    int32_t l_450 = (-1);
                    int32_t l_452 = 5;
                    float l_453 = 0x1.B2F08Ap+47;
                    int32_t l_456 = 7;
                    int32_t l_460 = 0x8A3ACC0A;
                    int32_t l_465 = (-1);
                    int32_t l_468 = 0x6B522DBA;
                    int32_t l_472 = 0xD5610DBB;
                    int32_t l_474 = (-10);
                    int32_t l_476 = 2;
                    int32_t l_482 = 0x5F3CF5AD;
                    int32_t l_485 = 1;
                    int32_t l_486 = 0x02AA8A24;
                    l_341 = (((int16_t)0x29C4 << (int16_t)3) && ((uint16_t)0xD6B0 % (uint16_t)p_41));
                    if (p_39)
                    { /* block id: 83 */
                        int32_t l_438 = 0x17F3F56B;
                        int32_t l_441 = 1;
                        int32_t l_443 = 3;
                        int32_t l_444 = 1;
                        int32_t l_445 = 0xB0854F1E;
                        int8_t l_446 = 0x2F;
                        int32_t l_447 = 7;
                        int32_t l_449 = 0x387373AF;
                        int32_t l_451 = 0x0BCBC0E3;
                        int32_t l_454 = 0x3CB65DE4;
                        int32_t l_455 = 0xB8D72D4D;
                        int32_t l_457 = (-9);
                        int32_t l_458 = 0x3215F6A5;
                        int32_t l_459 = 0xFADAF887;
                        int32_t l_461 = 7;
                        int32_t l_462 = 6;
                        int32_t l_463 = 0x7548190C;
                        int32_t l_464 = (-10);
                        int32_t l_467 = 0xE0C37AA4;
                        int32_t l_475 = 0x15AA2A86;
                        int32_t l_480 = 0;
                        int32_t l_487 = (-1);
                        l_333 = ((l_366 < p_39) ^ l_437);
                        l_488++;
                    }
                    else
                    { /* block id: 86 */
                        const uint32_t l_511 = 4294967295U;
                        l_235 = (((((p_40 | (p_39 && (-1))) | ((uint16_t)(((uint16_t)((int16_t)((int32_t)4 / (int32_t)((uint32_t)(((((uint16_t)((-(int32_t)0x610F24B6) > l_414) + (uint16_t)p_38) > ((+((int16_t)((int16_t)p_40 % (int16_t)l_511) >> (int16_t)7)) == p_39)) ^ 0x2E06) > l_257.f1) - (uint32_t)l_338)) << (int16_t)15) >> (uint16_t)2) && 1U) << (uint16_t)1)) ^ p_38) < p_38) && p_38);
                        l_456 |= ((int16_t)l_346 - (int16_t)((int16_t)p_38 - (int16_t)0x8ADA));
                        l_233 = (-1);
                    }
                    if (l_474)
                        continue;
                }
            }
            ++l_516;
            if (((int16_t)((int16_t)((uint32_t)((int32_t)(((int32_t)((((l_194.f1 == ((uint32_t)0x40EA7109 + (uint32_t)((uint32_t)(((int32_t)(p_39 < l_357) % (int32_t)((uint32_t)(l_305 < p_39) % (uint32_t)p_41)) > (((((uint32_t)((int16_t)((((int16_t)((l_400 | (l_545 > l_466)) && 0x3F11) << (int16_t)l_400) != 0x131C) >= p_40) >> (int16_t)12) - (uint32_t)1) & 0xCE08) < l_65.f1) | l_411)) + (uint32_t)l_516))) && (-5)) >= l_432.f3) & p_41) + (int32_t)l_546) > 4) - (int32_t)(-5)) - (uint32_t)l_545) >> (int16_t)l_325) % (int16_t)p_40))
            { /* block id: 95 */
                int32_t l_560 = 9;
                float l_561 = 0x1.C9665Ap-59;
                int32_t l_580 = 0xB5A7793D;
                l_216 = l_547;
                if ((((int32_t)(((0 & 0x99B3F84F) || ((((int16_t)(((uint16_t)((uint32_t)l_194.f1 / (uint32_t)1) - (uint16_t)((p_38 <= l_194.f1) && (65535U != l_470))) > ((((uint16_t)(((uint16_t)p_40 - (uint16_t)l_400) < p_41) % (uint16_t)0x096D) | l_560) < 0U)) >> (int16_t)12) == l_325) ^ l_416)) && p_38) - (int32_t)l_481) ^ 4294967295U))
                { /* block id: 97 */
                    int32_t l_562 = 0;
                    l_562 = 0x9.FBDEDDp-50;
                    l_580 |= ((((uint16_t)((uint32_t)((int16_t)l_562 << (int16_t)3) - (uint32_t)p_39) + (uint16_t)l_560) != l_560) == ((((uint16_t)((int32_t)(l_560 || ((((int16_t)p_41 >> (int16_t)15) | (0x02D9EEF6 < (+(!l_323)))) & (((!(((uint16_t)l_401 + (uint16_t)0x5455) & p_38)) || 0xD224) ^ l_396))) + (int32_t)1) - (uint16_t)0x97A0) | p_40) >= l_382));
                }
                else
                { /* block id: 100 */
                    if (l_481)
                        goto lbl_282;
                }
                return l_216;
            }
            else
            { /* block id: 104 */
                uint16_t l_598 = 65535U;
                int32_t l_633 = 0x0452E68B;
                uint16_t l_656 = 65532U;
                struct S3 l_701 = {0x80,65535U,-0x3.Cp+1,0x3B27E887,0xB0AC0643,0x1.6p-1,0x1.5p+1};
                int32_t l_721 = 0xF6B908DB;
                int32_t l_722 = 3;
                int32_t l_723 = 0xE846C920;
                int32_t l_724 = 0x3441F030;
                int32_t l_725 = 0;
                int32_t l_726 = 0x70A3C57D;
                int32_t l_727 = 5;
                int32_t l_728 = 0xAC4ACEC4;
                int32_t l_729 = (-1);
                int16_t l_730 = 0x8459;
                int32_t l_731 = 0x6C858815;
                int32_t l_732 = 0;
                int32_t l_734 = 1;
                int32_t l_735 = 0x83C436A6;
                int32_t l_736 = 0x82C8ED13;
                int32_t l_737 = 1;
                int32_t l_739 = (-1);
                int32_t l_740 = 0x13A689A7;
                int32_t l_741 = (-2);
                uint32_t l_745 = 0xB9560BAC;
                if (p_39)
                { /* block id: 105 */
                    int32_t l_591 = 0;
                    uint32_t l_620 = 1U;
                    if (((((int16_t)(((((((uint32_t)(l_432.f0 && ((uint32_t)((((-1) || ((((uint32_t)l_194.f2 + (uint32_t)((p_40 > (((int16_t)((l_545 || (1U <= ((l_591 == p_40) <= ((uint16_t)((uint32_t)((uint16_t)0xC635 >> (uint16_t)4) % (uint32_t)p_39) / (uint16_t)p_39)))) == l_416) % (int16_t)l_598) == 0U)) <= 0xC877)) || p_41) | p_40)) & p_38) <= 0x270E) % (uint32_t)p_40)) % (uint32_t)0x74FC61E6) <= p_39) <= p_38) | (-6)) > l_516) != (-1)) << (int16_t)6) <= 0U) >= p_39))
                    { /* block id: 106 */
                        uint16_t l_616 = 0xCC99;
                        l_194.f1 |= ((uint16_t)((int32_t)((-1) <= (((int16_t)(-(uint16_t)((uint32_t)(p_38 || (((uint16_t)((int16_t)((l_216.f3 < ((int32_t)((uint16_t)l_598 * (uint16_t)((((l_598 || l_616) | (((int32_t)(p_41 < p_39) + (int32_t)0xD5C99DA5) & p_40)) != l_616) >= l_216.f0)) % (int32_t)p_38)) < 0x8CC3B666) >> (int16_t)l_598) << (uint16_t)p_40) != l_619)) - (uint32_t)(-1))) << (int16_t)8) & 0x9E96)) % (int32_t)l_620) >> (uint16_t)l_616);
                        l_633 = (((float)(((float)0x1.7p+1 - (float)((float)(l_484 <= ((l_598 <= ((float)p_40 - (float)((float)(((float)0x4.Cp+1 / (float)((l_620 >= (0x1.5p+1 < ((-0x1.Fp+1) != l_616))) != p_41)) <= p_41) + (float)0x1.3p+1))) > p_39)) / (float)0x1.9p+1)) != 0x1.6p-1) / (float)0x0.2p-1) <= (-0x8.Dp+1));
                        if (p_40)
                            continue;
                    }
                    else
                    { /* block id: 110 */
                        if (l_598)
                            break;
                    }
                    for (l_479 = (-24); (l_479 == (-26)); l_479 -= 2)
                    { /* block id: 115 */
                        l_396 &= ((0x41724FF9 != (3U <= 0U)) | (~p_39));
                        l_412 &= (-1);
                        return l_547;
                    }
                    for (l_402 = 0; (l_402 == (-14)); l_402 -= 1)
                    { /* block id: 122 */
                        uint32_t l_639 = 0x3E161F15;
                        l_639 = 0xFDCADB47;
                        l_484 = ((float)((float)(((float)l_646 - (float)((-(float)((float)((((float)0x8.Dp+1 - (float)((float)(0x0.4p+1 == p_39) - (float)0x8.9p-1)) >= (-0x1.8p+1)) >= ((float)0x1.3p+1 - (float)p_41)) + (float)l_656)) > p_38)) >= 0x5.C69299p+46) - (float)l_415) - (float)0x9.Fp+1);
                        if (l_656)
                            break;
                        l_657 &= 0x27210B4D;
                    }
                    l_409 = (l_598 & 0xA164C13C);
                }
                else
                { /* block id: 129 */
                    uint16_t l_668 = 0x77AF;
                    int32_t l_719 = 0x8D57513B;
                    struct S3 l_720 = {0x9C,65526U,0xA.CCE658p+11,0U,-1,0xA.BFA046p+79,0x6.6F4010p-52};
                    if (((int16_t)(0x3EE92EF1 < (((((int16_t)(p_39 > (((uint32_t)(l_235 > (((uint32_t)(0x2DCD || 0x6AD5) / (uint32_t)(l_396 || 0x5A14B740)) & ((int32_t)l_488 - (int32_t)p_38))) / (uint32_t)p_38) < p_39)) % (int16_t)l_668) > l_668) >= p_39) >= 0xBDED5D88)) >> (int16_t)p_39))
                    { /* block id: 130 */
                        float l_686 = 0x8.4p-1;
                        int32_t l_699 = 0xBF9493EB;
                        uint32_t l_700 = 1U;
                        l_633 = (((uint16_t)(p_38 | ((((p_40 & p_41) <= p_40) & ((int32_t)(p_41 >= ((uint16_t)((uint16_t)((uint32_t)l_668 / (uint32_t)0x67E09A93) - (uint16_t)l_668) / (uint16_t)p_38)) + (int32_t)p_39)) || l_598)) << (uint16_t)0) != 1);
                        l_360 |= ((((((int16_t)(((int32_t)((((p_38 <= ((((((int16_t)(+l_234) + (int16_t)(0U & ((int32_t)(((((int16_t)(((int32_t)(p_40 != p_39) + (int32_t)l_418) && l_409) << (int16_t)((uint16_t)(0x64AFC711 | ((uint32_t)((uint32_t)(l_234 & l_699) / (uint32_t)0x71901623) + (uint32_t)0xB9245122)) / (uint16_t)p_38)) == l_216.f0) & 2U) >= (-1)) % (int32_t)l_668))) ^ l_598) != 1U) | 65530U) < p_39)) ^ l_598) == p_41) < l_473) - (int32_t)l_700) ^ (-3)) >> (int16_t)p_39) < p_41) > l_350) || 0xDC97) < 0x9A5A);
                    }
                    else
                    { /* block id: 133 */
                        int32_t l_718 = 0xB5287930;
                        l_701 = l_216;
                        l_719 |= ((int16_t)((uint32_t)p_39 + (uint32_t)0xA6EA4C66) + (int16_t)((int32_t)((l_194.f2 < (((((((uint16_t)(((((int16_t)((uint16_t)(p_38 && (l_668 != 0xC4C73AF5)) / (uint16_t)((int16_t)((int16_t)((l_718 & ((((((((((p_41 == (0x3EA2BF3F < p_38)) == 0x154F1D85) || l_718) && l_718) & (-8)) < l_232) == l_194.f2) & 0x32EABEF2) <= l_345) == p_39)) ^ 0x6394AC3D) >> (int16_t)9) % (int16_t)p_38)) / (int16_t)l_668) > 0xC41D8366) || p_41) || p_41) % (uint16_t)0x4E3D) >= l_718) != 3) >= 6U) ^ p_38) >= 65535U)) < l_466) + (int32_t)l_337));
                        l_432 = l_701;
                        l_432 = l_720;
                    }
                }
                ++l_745;
            }
        }
        l_469 |= l_546;
    }
    else
    { /* block id: 144 */
        const int16_t l_748 = 0x41F1;
        struct S3 l_749 = {0,65532U,-0x6.Ep-1,0x3C6BA643,-4,0x5.C6E5A2p-62,0x3.4EC02Dp-82};
        l_392 = l_748;
        return l_749;
    }
    return l_216;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_60(struct S1  p_61, struct S2  p_62)
{ /* block id: 35 */
    int16_t l_198 = 0xA5E2;
    p_62.f1 = (-(int32_t)(((uint16_t)l_198 >> (uint16_t)3) >= ((uint16_t)((int16_t)(+((int16_t)(5 >= (~l_198)) >> (int16_t)0)) << (int16_t)(p_62.f2 < (((int32_t)(((p_62.f0 | (l_198 == (((uint16_t)(-(int16_t)(-1)) >> (uint16_t)14) && ((int16_t)0x6AAE >> (int16_t)6)))) & p_61.f0) != l_198) / (int32_t)p_62.f1) >= l_198))) + (uint16_t)p_62.f1)));
    return p_61.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_63(struct S1  p_64)
{ /* block id: 14 */
    int32_t l_86 = 1;
    int32_t l_167 = (-1);
    int32_t l_190 = (-1);
    struct S1 l_193 = {-6,1U,0};
    l_167 = ((int16_t)(((-7) >= func_68(func_71(p_64.f1, ((((+(((float)(((float)p_64.f1 - (float)(-(float)((((float)((((((float)(((((float)l_86 - (float)l_86) != ((float)(((float)((l_86 <= 0x7.BDDE1Ep+42) < ((float)p_64.f2 + (float)0x3.AEE60Dp+93)) - (float)p_64.f0) < p_64.f0) + (float)l_86)) <= (-0x1.Ap-1)) >= p_64.f2) + (float)0x3.492987p-56) < p_64.f1) == 0x0.3p-1) <= 0x9.9A1ECAp+6) > l_86) / (float)0x1.8p+1) > l_86) > 0x1.B75F8Fp+79))) > l_86) / (float)(-0x1.8p+1)) >= l_86)) == (-0x1.Ep-1)) < l_86) <= 0x6.53C6A9p+89)), p_64.f0)) || l_86) << (int16_t)12);
    for (p_64.f1 = (-29); (p_64.f1 > 20); p_64.f1 += 1)
    { /* block id: 29 */
        uint32_t l_170 = 0xE727DB1D;
        int32_t l_192 = 0x32E4EC8C;
        ++l_170;
        l_190 ^= (((int16_t)((uint32_t)((((p_64.f2 >= (p_64.f1 | ((int32_t)((uint16_t)((int16_t)(~((((uint16_t)(((int32_t)0x77C65B12 / (int32_t)(p_64.f1 && (0x773B == (((p_64.f0 && (l_167 ^ (3U == (l_170 ^ l_86)))) & 1) | p_64.f2)))) && 1) - (uint16_t)l_170) <= 5U) < 4294967295U)) + (int16_t)p_64.f0) - (uint16_t)l_170) % (int32_t)p_64.f1))) < p_64.f0) <= l_86) > 0x5A7D) + (uint32_t)l_170) + (int16_t)l_170) != p_64.f0);
        l_192 = (+p_64.f2);
    }
    return l_193;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_68(struct S0  p_69, uint32_t  p_70)
{ /* block id: 19 */
    int32_t l_138 = 0x309C9891;
    int32_t l_164 = (-1);
    struct S3 l_166 = {0xE4,0xF8AF,-0x6.4p-1,0x75287BB0,-3,0x4.15525Cp+99,0x0.4p-1};
    p_69.f2 &= ((int16_t)(((int16_t)((((int32_t)(65528U & (((int16_t)(l_138 & ((((uint32_t)((int32_t)l_138 + (int32_t)(p_69.f7 < ((0x4953 < ((uint32_t)p_69.f4 % (uint32_t)((+l_138) ^ 0xD59F51D5))) > ((((((p_69.f0 || l_138) | 0x4898B9DD) <= l_138) != 0x1000) ^ 4294967294U) == 0xD0560285)))) % (uint32_t)p_69.f1) <= 0x626E) != (-8))) >> (int16_t)11) > l_138)) + (int32_t)l_138) < l_138) || l_138) % (int16_t)0x8503) <= p_69.f7) - (int16_t)l_138);
    if (p_69.f4)
        goto lbl_165;
    l_164 = (7U <= (((int32_t)((uint16_t)p_69.f5 >> (uint16_t)(!p_69.f7)) % (int32_t)(((int16_t)(((((((uint32_t)p_69.f1 + (uint32_t)((int16_t)p_69.f3 + (int16_t)(((uint16_t)(((p_69.f3 ^ (((((!p_69.f7) > ((uint16_t)(((((uint32_t)(((p_70 || l_138) ^ l_138) != l_138) / (uint32_t)l_138) & 0U) == 0x8EA33B35) | l_138) % (uint16_t)p_69.f6)) | l_138) < l_138) < p_69.f0)) >= p_69.f2) || p_69.f0) + (uint16_t)(-1)) || 0x0BAB))) & 0x67C7D0B8) == 0x9BFD8F9D) == 0U) ^ 1U) == (-9)) << (int16_t)l_138) & p_69.f6)) != 0xB798DF4D));
lbl_165:
    l_164 = p_69.f0;
    l_166 = l_166;
    return p_69.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_71(uint32_t  p_72, float  p_73)
{ /* block id: 15 */
    int8_t l_95 = 0x2A;
    uint16_t l_107 = 0U;
    int32_t l_110 = 0x94F6C93E;
    const float l_126 = 0xB.68C23Fp+77;
    struct S0 l_127 = {0,0x2F27,-8,0x04B0,-9,2,0x4F,1U,0x5.938C4Dp+29};
    l_110 = ((uint32_t)((((p_72 >= ((l_95 <= p_72) >= p_72)) | (~(((uint16_t)(p_72 ^ ((uint16_t)(l_95 == ((int16_t)((int32_t)(((int32_t)l_95 / (int32_t)l_107) == (((int32_t)l_107 / (int32_t)l_95) == p_72)) - (int32_t)p_72) >> (int16_t)2)) % (uint16_t)l_107)) >> (uint16_t)3) && p_72))) > 5U) & l_107) % (uint32_t)p_72);
    l_110 = ((float)((!((p_72 < ((((p_73 > p_73) > (((((float)((float)(p_73 < ((((l_110 <= (((float)((float)((0x2.259696p+1 == (((float)((float)(p_73 != 0x0.Ap+1) / (float)p_73) / (float)p_72) == p_73)) != 0x1.1p-1) + (float)l_126) - (float)l_110) >= p_73)) < (-0x6.8p+1)) == 0x0.Fp-1) == l_95)) / (float)0x3.0p-1) / (float)p_72) >= 0x5.706A3Bp+14) == l_107) <= l_107)) != l_107) == (-0x3.Ap+1))) == l_110)) != l_107) / (float)l_107);
    return l_127;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 242
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX full-bitfields structs in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 21

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 9
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 7, occurrence: 2
   depth: 11, occurrence: 1
   depth: 13, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 31, occurrence: 2
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 458
XXX times a non-volatile is write: 68
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 105
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 10
   depth: 2, occurrence: 3
   depth: 3, occurrence: 10
   depth: 4, occurrence: 17
   depth: 5, occurrence: 37

XXX percentage a fresh-made variable is used: 29.7
XXX percentage an existing variable is used: 70.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

