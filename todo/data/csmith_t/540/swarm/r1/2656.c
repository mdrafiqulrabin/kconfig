/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1281705430
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 25;
   int32_t  f1;
   float  f2;
   float  f3;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3[7] = {0UL,0UL,0UL,0UL,0UL,0UL,0UL};
static int32_t g_96[3] = {0xFB0F81A6L,0xFB0F81A6L,0xFB0F81A6L};
static const struct S0 g_107 = {-4653,0x38C1355BL,0x7.Dp-1,0x3.8FA0D6p+92};
static struct S0 g_109 = {-1702,0L,0x3.5644FEp-47,0xE.904212p+19};
static int32_t *g_171[4][3] = {{&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1]}};
static const int32_t *g_197 = &g_96[1];
static uint32_t g_251[8] = {0xAC9E3CE1L,0xAC9E3CE1L,4294967291UL,0xAC9E3CE1L,0xAC9E3CE1L,4294967291UL,0xAC9E3CE1L,0xAC9E3CE1L};
static struct S0 *g_263 = &g_109;
static struct S0 **g_262 = &g_263;
static int32_t *****g_350 = (void*)0;
static struct S0 g_356 = {4587,0x021357D8L,0x1.1p-1,0x8.Ap+1};
static int32_t g_388 = 0x176CA79FL;
static int32_t *g_387 = &g_388;
static int32_t ****g_394 = (void*)0;
static uint32_t g_556 = 0UL;
static int32_t ***g_709 = (void*)0;
static uint16_t g_717[3][1] = {{65535UL},{65535UL},{65535UL}};
static float **g_855 = (void*)0;
static volatile uint32_t g_931 = 5UL;/* VOLATILE GLOBAL g_931 */
static float g_943 = 0x0.Ap-1;
static const float g_950 = 0x2.3E7D2Ep-70;


/* --- FORWARD DECLARATIONS --- */
static float  func_25(void);
static int8_t  func_36(int32_t  p_37, int32_t  p_38, int8_t  p_39, int16_t  p_40, int32_t  p_41);
static int32_t  func_42(uint32_t  p_43, const float  p_44, int16_t  p_45, float  p_46);
static float  func_49(struct S0  p_50, int32_t  p_51, uint16_t  p_52, uint32_t  p_53, const uint32_t  p_54);
static struct S0  func_55(uint8_t  p_56, int32_t  p_57, int32_t  p_58, struct S0  p_59);
static int32_t  func_60(const float  p_61, float  p_62, uint32_t  p_63, uint32_t  p_64);
static int16_t  func_75(struct S0  p_76);
static int32_t * func_80(struct S0  p_81, int32_t  p_82);
static struct S0  func_83(int32_t  p_84, int32_t * p_85, int32_t * p_86);
static int32_t  func_87(struct S0  p_88, const int8_t  p_89, uint8_t  p_90, const int32_t * p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_96 g_107 g_109 g_171 g_197 g_262 g_263 g_251 g_387 g_356.f1 g_394 g_356.f0 g_356.f2 g_388 g_556 g_717 g_855
 * writes: g_109 g_96 g_171 g_197 g_356.f1 g_356.f2 g_388 g_263 g_717 g_556 g_394 g_387 g_356 g_855
 */
static float  func_25(void)
{ /* block id: 36 */
    const int8_t l_31 = 1L;
    int32_t l_65 = 0xAEABA4A2L;
    struct S0 l_474 = {912,7L,-0x1.Cp+1,0x3.0p-1};
    uint16_t l_716 = 1UL;
    float *l_724 = &l_474.f2;
    uint16_t l_725 = 0xB5F1L;
    uint8_t l_754 = 1UL;
    int32_t ***l_819[4];
    uint32_t l_857 = 0UL;
    float l_885[7];
    int i;
    for (i = 0; i < 4; i++)
        l_819[i] = (void*)0;
    for (i = 0; i < 7; i++)
        l_885[i] = 0x7.920C57p+60;
    (*l_724) = ((float)(!g_3[5]) + (float)(((((float)l_31 + (float)(-0x1.6p+1)) != __builtin_clzll((g_3[1] & ((int16_t)((int8_t)func_36(func_42(__builtin_ctz(g_3[3]), ((float)(func_49(func_55(g_3[6], l_31, func_60(l_31, l_65, g_3[3], l_65), l_474), g_3[5], l_474.f0, g_556, l_474.f1) == g_107.f2) + (float)l_716), l_474.f0, g_107.f0), l_474.f1, g_556, l_65, l_474.f1) >> (int8_t)2) * (int16_t)g_107.f1)))) <= l_474.f1) < l_31));
    /* statement id: 743 */
    //assert (g_171[0][0] == 0 || (g_171[0][0] >= &g_96[0] && g_171[0][0] <= &g_96[2]) || g_171[0][0] == &g_388);
    //assert (g_197 == dangling || (g_197 >= &g_96[0] && g_197 <= &g_96[2]));
    if (((l_474.f0 > l_474.f0) <= l_474.f0))
    { /* block id: 744 */
        float l_726 = (-0x1.Dp+1);
        int32_t l_727 = 0L;
        struct S0 l_728 = {1512,0xF2FE7F8AL,-0x1.9p+1,0xC.C73810p-91};
        l_474 = func_55(l_725, g_356.f0, l_727, func_55(g_251[3], g_96[1], func_75(l_728), func_83(((uint8_t)(func_42(g_109.f0, l_727, l_727, g_3[3]) >= 4UL) >> (uint8_t)l_474.f0), &l_727, &l_727)));
        return l_728.f0;
    }
    else
    { /* block id: 747 */
        struct S0 l_731 = {3,0x2037C66DL,0xB.419C9Bp+54,-0x3.7p-1};
        const struct S0 *l_741 = &g_356;
        int32_t *l_762 = &l_65;
        (*g_387) = func_75(l_731);
        for (g_388 = 8; (g_388 < (-3)); g_388 -= 9)
        { /* block id: 751 */
            const struct S0 *l_738 = &g_107;
            int32_t l_764[4];
            int i;
            for (i = 0; i < 4; i++)
                l_764[i] = 0x2937227DL;
            for (l_716 = (-22); (l_716 < 12); l_716 += 4)
            { /* block id: 754 */
                for (g_556 = 0; (g_556 < 34); g_556 += 5)
                { /* block id: 757 */
                    const struct S0 **l_739 = (void*)0;
                    const struct S0 **l_740 = (void*)0;
                    l_741 = l_738;
                    /* statement id: 758 */
                    assert (l_741 == &g_107);
                }
            }
            for (l_725 = 25; (l_725 <= 25); l_725 += 4)
            { /* block id: 763 */
                int32_t *l_763 = &l_65;
                struct S0 l_766 = {1917,0xDB481F68L,0x4.0A8C99p+39,0x5.67CFEBp-72};
                int32_t **l_767 = &l_763;
                for (l_716 = 17; (l_716 < 45); ++l_716)
                { /* block id: 766 */
                    float l_750 = 0x2.A44E31p+38;
                    int32_t *l_755 = &l_65;
                    struct S0 *l_758 = &l_474;
                }
                if ((*g_387))
                    continue;
                (*l_767) = func_80(l_766, (*l_762));
                /* statement id: 780 */
                assert (l_763 == 0 || (l_763 >= &g_96[0] && l_763 <= &g_96[2]) || l_763 == &g_388);
            }
        }
        /* facts after for loop */
        assert (l_741 == &g_107 || l_741 == &g_356);
        if ((*l_762))
        { /* block id: 783 */
            int32_t *l_768 = (void*)0;
            int32_t **l_769 = &l_762;
            (*l_769) = l_768;
            /* statement id: 784 */
            assert (l_762 == 0);
            for (l_65 = (-19); (l_65 < (-13)); ++l_65)
            { /* block id: 787 */
                const int32_t l_781 = (-1L);
                const int32_t *l_782 = &g_96[1];
                int32_t *l_784[8] = {&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]};
                int i;
                (*g_387) = ((~(g_556 <= (((g_3[3] <= (g_388 | ((void*)0 == &l_741))) < (((uint8_t)(((uint16_t)(((int16_t)(-5L) % (int16_t)g_388) >= ((((uint16_t)__builtin_ctzll((((0x55L | func_87((**g_262), l_781, g_3[5], l_782)) < 0xD8L) || (*l_782))) + (uint16_t)g_356.f1) > 0xBFL) <= 0x14L)) * (uint16_t)g_356.f1) & l_474.f1) >> (uint8_t)l_781) && g_356.f0)) >= g_356.f1))) > g_251[0]);
                if ((*g_387))
                { /* block id: 789 */
                    return l_31;
                }
                else
                { /* block id: 791 */
                    int32_t *****l_783 = &g_394;
                    (*l_783) = (void*)0;
                    (*g_263) = func_83(g_717[0][0], l_784[6], &g_96[1]);
                    for (l_474.f1 = (-28); (l_474.f1 != 16); l_474.f1 += 4)
                    { /* block id: 796 */
                        if (l_474.f0)
                            break;
                    }
                }
                (*l_769) = (*l_769);
                (*l_724) = (l_474.f0 >= (((float)g_356.f0 - (float)(!(((float)g_109.f0 + (float)0x0.5p-1) <= __builtin_clzl((((uint8_t)(((g_3[5] > g_556) <= g_107.f0) || (((((uint8_t)g_251[1] * (uint8_t)0x8DL) & 254UL) & g_388) > g_96[1])) + (uint8_t)g_556) > l_474.f1))))) < g_109.f2));
            }
        }
        else
        { /* block id: 803 */
            int32_t **l_796 = (void*)0;
            int32_t **l_797 = &g_387;
            (*l_797) = l_762;
            /* statement id: 804 */
            assert (g_387 == &l_65);
        }
        /* facts after branching */
        assert (g_387 == &l_65 || g_387 == &g_388);
        assert (l_762 == &l_65 || l_762 == 0);
        for (l_65 = (-1); (l_65 >= 23); ++l_65)
        { /* block id: 808 */
            l_762 = (void*)0;
            /* statement id: 809 */
            assert (l_762 == 0);
        }
    }
    /* facts after branching */
    assert (g_387 == &l_65 || g_387 == &g_388);
    for (g_109.f1 = 0; (g_109.f1 == (-28)); g_109.f1 -= 1)
    { /* block id: 814 */
        int32_t l_812 = (-1L);
        int32_t *l_813 = &g_96[1];
        int32_t *l_838 = (void*)0;
        float ***l_856 = &g_855;
        if ((g_107.f1 <= ((void*)0 == &g_262)))
        { /* block id: 815 */
            int32_t *l_804[1];
            uint8_t l_822 = 249UL;
            uint16_t l_827 = 65531UL;
            int8_t l_830[1];
            int i;
            for (i = 0; i < 1; i++)
                l_804[i] = (void*)0;
            for (i = 0; i < 1; i++)
                l_830[i] = 0xE0L;
            for (l_474.f1 = 0; (l_474.f1 != (-15)); l_474.f1 -= 3)
            { /* block id: 818 */
                int32_t **l_805 = &l_804[0];
                const struct S0 *l_811[3][7][5] = {{{&g_109,&l_474,&l_474,&g_109,&l_474},{&l_474,&l_474,&g_109,&l_474,&l_474},{&g_107,&l_474,&g_107,&g_107,&l_474},{&l_474,&g_107,&g_107,&l_474,&g_107},{&l_474,&l_474,&g_109,&l_474,&l_474},{&g_107,&l_474,&g_107,&g_107,&l_474},{&l_474,&g_107,&g_107,&l_474,&g_107}},{{&l_474,&l_474,&g_109,&l_474,&l_474},{&g_107,&l_474,&g_107,&g_107,&l_474},{&l_474,&g_107,&g_107,&l_474,&g_107},{&l_474,&l_474,&g_109,&l_474,&l_474},{&g_107,&l_474,&g_107,&g_107,&l_474},{&l_474,&g_107,&g_107,&l_474,&g_107},{&l_474,&l_474,&g_109,&l_474,&l_474}},{{&g_107,&l_474,&g_107,&g_107,&l_474},{&l_474,&g_107,&g_107,&l_474,&g_107},{&l_474,&l_474,&g_109,&l_474,&l_474},{&g_107,&l_474,&g_107,&g_107,&l_474},{&l_474,&g_107,&g_107,&l_474,&g_107},{&l_474,&l_474,&g_109,&l_474,&l_474},{&g_107,&l_474,&g_107,&g_107,&l_474}}};
                int i, j, k;
                (*l_805) = l_804[0];
                for (l_725 = 0; (l_725 <= 2); l_725 += 1)
                { /* block id: 822 */
                    struct S0 * const l_806 = &l_474;
                    for (g_388 = 2; (g_388 >= 0); g_388 -= 1)
                    { /* block id: 825 */
                        struct S0 **l_807 = &g_263;
                        (*l_807) = l_806;
                        /* statement id: 826 */
                        assert (g_263 == &l_474);
                    }
                    for (l_65 = 2; (l_65 >= 0); l_65 -= 1)
                    { /* block id: 830 */
                        int i;
                        (*l_805) = &g_96[l_65];
                        g_96[l_65] = g_96[l_65];
                    }
                    (*g_387) = (-(uint16_t)((uint32_t)(l_811[2][3][0] == (void*)0) % (uint32_t)l_812));
                    l_813 = (void*)0;
                    /* statement id: 835 */
                    assert (l_813 == 0);
                }
            }
            /* facts after for loop */
            //assert ((l_804[0] >= &g_96[0] && l_804[0] <= &g_96[2]) || l_804[0] == 0);
            assert (l_813 == 0 || (l_813 >= &g_96[0] && l_813 <= &g_96[2]));
            if ((&g_394 != (void*)0))
            { /* block id: 838 */
                if ((*g_387))
                    break;
            }
            else
            { /* block id: 840 */
                int32_t *l_814 = &l_65;
                int32_t **l_831 = &g_387;
                int8_t l_834 = 9L;
                struct S0 *l_836 = &g_356;
                for (g_556 = 0; (g_556 <= 2); g_556 += 1)
                { /* block id: 843 */
                    struct S0 l_815[8][5] = {{{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64}},{{-3373,1L,0x4.5p+1,0x2.7B9DB8p-83},{4468,0xB87C0876L,0x9.62FF19p-71,0xD.0A54F1p+31},{2735,0x7BD61532L,0xB.2FA2F7p+91,0x0.7p-1},{4468,0xB87C0876L,0x9.62FF19p-71,0xD.0A54F1p+31},{-3373,1L,0x4.5p+1,0x2.7B9DB8p-83}},{{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93}},{{-3373,1L,0x4.5p+1,0x2.7B9DB8p-83},{315,0x8D440549L,0x1.142140p-24,0xB.C4728Ap-60},{5665,-1L,0x0.1p-1,-0x8.1p+1},{4468,0xB87C0876L,0x9.62FF19p-71,0xD.0A54F1p+31},{5665,-1L,0x0.1p-1,-0x8.1p+1}},{{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{3836,0xA6674BB7L,-0x1.Fp-1,0xC.E97D14p+30},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93}},{{5665,-1L,0x0.1p-1,-0x8.1p+1},{4468,0xB87C0876L,0x9.62FF19p-71,0xD.0A54F1p+31},{5665,-1L,0x0.1p-1,-0x8.1p+1},{315,0x8D440549L,0x1.142140p-24,0xB.C4728Ap-60},{-3373,1L,0x4.5p+1,0x2.7B9DB8p-83}},{{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64},{-214,-1L,-0x9.5p+1,0xD.54B55Bp+93},{4192,-1L,-0x1.Dp+1,0xD.2E7E46p-64}},{{-3373,1L,0x4.5p+1,0x2.7B9DB8p-83},{4468,0xB87C0876L,0x9.62FF19p-71,0xD.0A54F1p+31},{2735,0x7BD61532L,0xB.2FA2F7p+91,0x0.7p-1},{4468,0xB87C0876L,0x9.62FF19p-71,0xD.0A54F1p+31},{-3373,1L,0x4.5p+1,0x2.7B9DB8p-83}}};
                    int i, j;
                    g_171[g_556][g_556] = g_171[(g_556 + 1)][g_556];
                    l_814 = l_813;
                    /* statement id: 845 */
                    assert (l_814 == 0 || (l_814 >= &g_96[0] && l_814 <= &g_96[2]));
                    if (func_75(l_815[0][2]))
                    { /* block id: 846 */
                        int i;
                        (*g_387) = func_36(g_251[(g_556 + 5)], ((int16_t)(-(uint16_t)(l_819[3] != (void*)0)) << (int16_t)(((uint32_t)g_251[1] % (uint32_t)g_96[1]) <= ((l_822 && 0x17EDL) & (((int16_t)g_109.f1 - (int16_t)((((uint16_t)g_556 << (uint16_t)4) != g_251[(g_556 + 5)]) | 0x890FD4B5L)) != 1L)))), g_96[1], g_251[2], l_827);
                        (*g_387) = ((void*)0 != &g_394);
                        l_804[0] = &g_96[2];
                        l_834 = ((uint8_t)l_830[0] << (uint8_t)((((void*)0 == l_831) == (((uint16_t)g_388 * (uint16_t)0x89A9L) & 65535UL)) & 0UL));
                    }
                    else
                    { /* block id: 851 */
                        struct S0 *l_835 = &l_815[0][2];
                        (*l_835) = func_83((&l_819[3] != (void*)0), l_804[0], g_171[(g_556 + 1)][g_556]);
                    }
                    return g_96[1];
                    /* statement id: 854 */
                    //assert (g_263 == dangling || g_263 == &g_109);
                    //assert (g_387 == dangling || g_387 == &g_388);
                }
                (*l_836) = (**g_262);
            }
        }
        else
        { /* block id: 858 */
            int32_t *l_837[9][8] = {{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]},{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]}};
            struct S0 *l_839 = &l_474;
            int i, j;
            (*l_839) = func_83(g_251[1], l_837[2][3], l_838);
            for (l_716 = 21; (l_716 <= 54); l_716 += 3)
            { /* block id: 862 */
                for (l_65 = 0; (l_65 == 4); l_65 += 7)
                { /* block id: 865 */
                    int32_t *l_850[7] = {&g_388,&g_388,&g_388,&g_388,&g_388,&g_388,&g_388};
                    int i;
                    for (l_812 = 0; (l_812 > 6); l_812++)
                    { /* block id: 868 */
                        return g_107.f2;
                        /* statement id: 869 */
                        //assert (g_263 == dangling || g_263 == &g_109);
                        //assert (g_387 == &g_388 || (g_387 >= &g_96[0] && g_387 <= &g_96[2]) || g_387 == dangling);
                    }
                    for (l_474.f1 = (-25); (l_474.f1 < (-20)); l_474.f1 += 5)
                    { /* block id: 873 */
                        int16_t l_849 = 0x3C77L;
                        (*l_813) = (~l_849);
                        g_171[1][1] = l_850[0];
                        g_171[3][0] = l_850[0];
                        g_387 = l_837[2][3];
                        /* statement id: 877 */
                        assert (g_387 == &g_388 || (g_387 >= &g_96[0] && g_387 <= &g_96[2]));
                    }
                    (*l_813) = (*g_387);
                }
            }
            /* facts after for loop */
            assert (g_387 == &g_388 || (g_387 >= &g_96[0] && g_387 <= &g_96[2]) || g_387 == &l_65);
            return g_251[0];
            /* statement id: 882 */
            //assert (g_263 == dangling || g_263 == &g_109);
            //assert (g_387 == &g_388 || (g_387 >= &g_96[0] && g_387 <= &g_96[2]) || g_387 == dangling);
        }
        /* facts after branching */
        assert (l_813 == 0 || (l_813 >= &g_96[0] && l_813 <= &g_96[2]));
        for (g_556 = 0; (g_556 <= 26); g_556 += 9)
        { /* block id: 886 */
            struct S0 ***l_854 = &g_262;
            struct S0 ****l_853 = &l_854;
            (*l_853) = &g_262;
        }
        (*l_856) = g_855;
    }
    /* facts after for loop */
    assert (g_263 == &l_474 || g_263 == &g_109);
    if (l_857)
    { /* block id: 891 */
        for (l_725 = 27; (l_725 <= 31); l_725 += 6)
        { /* block id: 894 */
            float *l_866 = &g_109.f2;
            int32_t l_867 = 0xFE4146D6L;
            (*g_387) = ((uint16_t)((uint8_t)((uint16_t)g_356.f0 + (uint16_t)g_96[0]) % (uint8_t)func_75(l_474)) << (uint16_t)((g_387 == l_866) != (g_855 != (void*)0)));
            return l_867;
            /* statement id: 896 */
            //assert (g_263 == dangling || g_263 == &g_109);
            //assert (g_387 == dangling || g_387 == &g_388);
        }
        for (l_474.f1 = 3; (l_474.f1 >= 0); l_474.f1 -= 1)
        { /* block id: 900 */
            int32_t l_868 = 0x7CF275E0L;
            return l_868;
            /* statement id: 901 */
            //assert (g_263 == dangling || g_263 == &g_109);
            //assert (g_387 == dangling || g_387 == &g_388);
        }
    }
    else
    { /* block id: 903 */
        int32_t *l_872 = &l_65;
        int32_t **l_909 = &l_872;
        for (g_109.f1 = 0; (g_109.f1 == 24); g_109.f1 += 5)
        { /* block id: 906 */
            int32_t *l_871 = &l_65;
            g_387 = (void*)0;
            /* statement id: 907 */
            assert (g_387 == 0);
            l_872 = l_871;
            g_171[3][0] = l_871;
        }
        /* facts after for loop */
        //assert (g_171[0][0] == &l_65 || g_171[0][0] == 0 || (g_171[0][0] >= &g_96[0] && g_171[0][0] <= &g_96[2]) || g_171[0][0] == &g_388);
        assert (g_387 == 0 || g_387 == &l_65 || g_387 == &g_388);
        (*l_872) = (*l_872);
        for (l_725 = (-6); (l_725 < 4); l_725 += 5)
        { /* block id: 914 */
            uint8_t l_887 = 0x78L;
            const int8_t l_910 = 0x4AL;
            int32_t *l_935 = (void*)0;
            int8_t l_944 = 0xCBL;
            for (g_388 = 0; (g_388 > 3); ++g_388)
            { /* block id: 917 */
                uint32_t l_888 = 0x10723F35L;
                struct S0 **l_900 = &g_263;
                int32_t *l_901[7] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                uint8_t l_911 = 0x37L;
                const uint8_t l_924[5][1] = {{1UL},{1UL},{1UL},{1UL},{1UL}};
                int i, j;
            }
            if ((**l_909))
                continue;
        }
    }
    /* facts after branching */
    //assert (g_171[0][0] == &l_65 || g_171[0][0] == 0 || (g_171[0][0] >= &g_96[0] && g_171[0][0] <= &g_96[2]) || g_171[0][0] == &g_388);
    assert (g_387 == 0 || g_387 == &l_65 || g_387 == &g_388);
    return g_556;
    /* statement id: 972 */
    //assert (g_171[0][0] == dangling || g_171[0][0] == 0 || (g_171[0][0] >= &g_96[0] && g_171[0][0] <= &g_96[2]) || g_171[0][0] == &g_388);
    //assert (g_263 == dangling || g_263 == &g_109);
    //assert (g_387 == 0 || g_387 == dangling || g_387 == &g_388);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_96 g_251
 * writes: g_717 g_356.f2
 */
static int8_t  func_36(int32_t  p_37, int32_t  p_38, int8_t  p_39, int16_t  p_40, int32_t  p_41)
{ /* block id: 739 */
    float *l_723 = &g_356.f2;
    g_717[0][0] = p_38;
    (*l_723) = (((float)g_3[4] * (float)func_42(p_40, g_96[1], p_41, g_251[1])) != (-(float)((float)g_251[1] - (float)0x7.8p-1)));
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_42(uint32_t  p_43, const float  p_44, int16_t  p_45, float  p_46)
{ /* block id: 737 */
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_251 g_263
 * writes: g_109
 */
static float  func_49(struct S0  p_50, int32_t  p_51, uint16_t  p_52, uint32_t  p_53, const uint32_t  p_54)
{ /* block id: 591 */
    int32_t *l_570[4] = {&g_96[1],&g_96[1],&g_96[1],&g_96[1]};
    uint8_t l_585 = 0x74L;
    uint32_t l_609 = 4UL;
    int32_t **l_715 = (void*)0;
    int i;
    for (p_50.f1 = 5; (p_50.f1 >= 0); p_50.f1 -= 1)
    { /* block id: 594 */
        int i;
        return g_251[(p_50.f1 + 2)];
    }
    for (p_53 = 0; (p_53 <= 2); p_53 += 1)
    { /* block id: 599 */
        int32_t *****l_566 = &g_394;
        uint32_t l_630 = 0UL;
        uint8_t l_634 = 0x8FL;
        int32_t l_681[3][5][6] = {{{3L,0x623AB801L,1L,0x9453B17CL,(-4L),(-4L)},{(-1L),1L,1L,(-1L),0x623AB801L,1L},{0xBE668C6BL,(-8L),(-4L),(-1L),1L,0x50E64067L},{(-1L),1L,0x50E64067L,0x9453B17CL,1L,(-8L)},{3L,(-8L),0x623AB801L,0xBE668C6BL,0x623AB801L,(-8L)}},{{(-1L),1L,0x50E64067L,1L,(-4L),0x50E64067L},{(-1L),0x623AB801L,(-4L),0xBE668C6BL,0xB770FFAFL,1L},{3L,0x623AB801L,1L,0x9453B17CL,(-4L),(-4L)},{(-1L),1L,1L,(-1L),0x623AB801L,1L},{0xBE668C6BL,(-8L),(-4L),(-1L),1L,0x50E64067L}},{{(-1L),1L,0x50E64067L,0x9453B17CL,1L,(-8L)},{3L,(-8L),0x623AB801L,0xBE668C6BL,0x623AB801L,(-8L)},{(-1L),1L,0x50E64067L,1L,(-4L),0x50E64067L},{(-1L),0x623AB801L,(-4L),0xBE668C6BL,0xB770FFAFL,1L},{3L,0x623AB801L,1L,0x9453B17CL,(-4L),(-4L)}}};
        int16_t l_690 = (-10L);
        int i, j, k;
        (*g_263) = p_50;
    }
    return p_50.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_109.f1 g_3 g_96 g_107 g_109 g_171 g_197 g_262 g_263 g_251 g_387 g_388 g_356.f1 g_356.f0 g_394
 * writes: g_109.f1 g_109 g_96 g_171 g_197 g_388 g_356.f1 g_263
 */
static struct S0  func_55(uint8_t  p_56, int32_t  p_57, int32_t  p_58, struct S0  p_59)
{ /* block id: 513 */
    int32_t *l_514 = &g_388;
    struct S0 l_554 = {-3735,-1L,0xC.EA28EFp-46,0x6.0E249Ep-82};
    for (g_109.f1 = 13; (g_109.f1 > (-16)); g_109.f1 -= 6)
    { /* block id: 516 */
        int8_t l_477 = 5L;
        int32_t *l_478 = &g_388;
        int16_t l_502 = 1L;
        if (l_477)
            break;
    }
lbl_533:
    l_514 = (void*)0;
    /* statement id: 552 */
    assert (l_514 == 0);
    for (p_59.f1 = 0; (p_59.f1 == 8); p_59.f1 += 4)
    { /* block id: 555 */
        const int8_t l_524[7] = {6L,6L,6L,6L,6L,6L,6L};
        int32_t l_528 = 0xA7302AAAL;
        int32_t **l_555 = &g_171[3][0];
        int i;
        for (p_56 = 13; (p_56 == 6); p_56 -= 6)
        { /* block id: 558 */
            struct S0 l_523 = {3408,5L,0x1.Ep+1,0x0.2509B7p-14};
            for (p_58 = 22; (p_58 > 21); p_58 -= 1)
            { /* block id: 561 */
                const int32_t *l_525 = &g_96[1];
                int32_t **l_530 = &g_171[3][0];
                int32_t ***l_529 = &l_530;
                l_528 = (((int8_t)g_3[3] % (int8_t)func_87(l_523, l_524[6], p_59.f0, l_525)) >= ((int32_t)0xC8259984L + (int32_t)p_56));
                (*l_529) = &l_514;
                /* statement id: 563 */
                assert (l_530 == &l_514);
                if (l_524[1])
                    continue;
                for (g_388 = 0; g_388 < 3; g_388 += 1)
                {
                    g_96[g_388] = 0x2E7EE68AL;
                }
            }
            for (g_109.f1 = 0; (g_109.f1 > (-8)); g_109.f1 -= 1)
            { /* block id: 569 */
                return (*g_263);
            }
        }
        if ((*g_387))
        { /* block id: 573 */
            return (**g_262);
        }
        else
        { /* block id: 575 */
            int32_t l_548 = 0x5783A193L;
            if (g_109.f0)
                goto lbl_533;
            (**g_262) = p_59;
            for (p_58 = (-3); (p_58 == 9); p_58 += 4)
            { /* block id: 580 */
                struct S0 l_536 = {1322,-1L,-0x1.1p+1,0x0.3781D6p+53};
                const int8_t l_543 = 0xF0L;
                const float *l_549 = &g_109.f3;
                float *l_550 = (void*)0;
                float *l_551 = (void*)0;
                float *l_552 = (void*)0;
                float *l_553 = &l_536.f2;
                l_536 = (*g_263);
                (*g_387) = p_56;
                g_109.f3 = ((float)l_528 - (float)(((float)(((0x5.F89523p+57 < (p_59.f1 == l_536.f1)) == (((float)g_356.f1 - (float)(g_251[1] != 0x1.Cp+1)) > ((((((l_543 <= ((((float)__builtin_clz(((((((((int16_t)l_548 - (int16_t)g_96[1]) >= p_56) && 0x1F9BL) ^ (*g_387)) && 1L) != g_388) < l_524[6])) * (float)0x7.8B39C4p-88) < 0xA.D61BDEp-15) != 0xB.4130F2p+47)) < g_251[1]) >= g_3[3]) <= 0x8.6F7ABDp+58) < p_59.f1) <= (-0x6.2p-1)))) <= p_57) + (float)p_59.f1) > g_356.f0));
                (*l_553) = (l_549 == (void*)0);
            }
        }
        (*l_555) = func_80(l_554, func_75((**g_262)));
        (*g_262) = (*g_262);
    }
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_96 g_107 g_109 g_171 g_197 g_262 g_263 g_251 g_387 g_356.f1 g_394 g_356.f0 g_356.f2 g_388
 * writes: g_109 g_96 g_171 g_197 g_356.f1 g_356.f2 g_388
 */
static int32_t  func_60(const float  p_61, float  p_62, uint32_t  p_63, uint32_t  p_64)
{ /* block id: 37 */
    struct S0 l_77 = {2180,0xCF8610F1L,0x0.Dp+1,-0x9.Fp-1};
    int32_t * const l_95 = &g_96[1];
    int32_t *l_389 = (void*)0;
    float l_401[5][9] = {{0x0.Fp-1,0xD.D01036p-5,0x0.159B5Bp+76,0x0.159B5Bp+76,0xD.D01036p-5,0x0.Fp-1,0x3.0p-1,0x3.0p-1,0x0.Fp-1},{0x0.4p-1,0x6.A3B938p-96,0x0.Bp+1,0x6.A3B938p-96,0x0.4p-1,0x6.A3B938p-96,0x0.Bp+1,0x6.A3B938p-96,0x0.4p-1},{0xD.D01036p-5,0x0.159B5Bp+76,0x0.159B5Bp+76,0xD.D01036p-5,0x0.Fp-1,0x3.0p-1,0x3.0p-1,0x0.Fp-1,0xD.D01036p-5},{(-0x1.8p+1),0x6.A3B938p-96,(-0x1.8p+1),0xC.A26208p-15,(-0x1.8p+1),0x6.A3B938p-96,(-0x1.8p+1),0xC.A26208p-15,(-0x1.8p+1)},{0xD.D01036p-5,0xD.D01036p-5,0x3.0p-1,0x0.159B5Bp+76,0x0.Fp-1,0x0.Fp-1,0x0.159B5Bp+76,0x3.0p-1,0xD.D01036p-5}};
    int32_t **l_442[2][5][7] = {{{&g_171[3][0],&g_387,&g_387,(void*)0,(void*)0,&g_387,&g_171[0][2]},{(void*)0,&g_171[0][2],&g_387,&g_387,&g_171[0][2],(void*)0,&g_387},{&g_171[3][0],&g_387,&g_171[3][0],&g_387,&g_171[0][1],(void*)0,(void*)0},{&g_171[3][0],&g_171[0][1],&l_389,&g_171[0][1],&g_171[3][0],&g_387,&g_171[3][0]},{(void*)0,&g_387,(void*)0,&g_171[0][0],&g_171[3][0],&g_171[3][0],&g_171[3][0]}},{{&l_389,&g_171[0][2],&g_171[0][2],&l_389,&g_171[0][1],&g_171[0][0],(void*)0},{(void*)0,&g_171[0][0],&g_171[0][1],&l_389,&g_171[0][2],&g_171[0][2],&l_389},{&g_171[3][0],&g_171[3][0],&g_171[3][0],&g_171[0][0],(void*)0,&g_387,(void*)0},{&g_171[3][0],&g_387,&g_171[3][0],&g_171[0][1],&l_389,&g_171[0][1],&g_171[3][0]},{(void*)0,(void*)0,&g_171[0][1],&g_387,&g_171[3][0],&g_387,&g_171[3][0]}}};
    int32_t ***l_441 = &l_442[0][1][2];
    int32_t *** const *l_440 = &l_441;
    uint16_t l_470 = 65527UL;
    int i, j, k;
    if (((int8_t)((((uint8_t)(__builtin_bswap32(p_63) & (((p_63 || ((uint8_t)g_3[3] + (uint8_t)1L)) & (0x50L & (~((0x2EE8L > p_63) & ((int16_t)func_75(l_77) + (int16_t)l_77.f0))))) <= l_77.f1)) % (uint8_t)0x15L) >= 0xAEL) && 0x1EL) << (int8_t)l_77.f0))
    { /* block id: 40 */
        int8_t l_402[5][2][3] = {{{0x6BL,0x1AL,0xCBL},{0xF1L,3L,0x45L}},{{0x6BL,0x6BL,0x45L},{3L,0xF1L,0xCBL}},{{0x1AL,0x6BL,0x1AL},{0x1AL,3L,0x6BL}},{{3L,0x1AL,0x1AL},{0x6BL,0x1AL,0xCBL}},{{0xF1L,3L,0x45L},{0x6BL,0x6BL,0x45L}}};
        int32_t *l_427[4];
        uint32_t l_467 = 1UL;
        int i, j, k;
        for (i = 0; i < 4; i++)
            l_427[i] = &g_388;
        if ((!g_3[3]))
        { /* block id: 41 */
            struct S0 l_92[3] = {{-3887,0xA273DD60L,0x1.Ep+1,0xB.384C83p+90},{-3887,0xA273DD60L,0x1.Ep+1,0xB.384C83p+90},{-3887,0xA273DD60L,0x1.Ep+1,0xB.384C83p+90}};
            const int32_t *l_99 = &g_96[1];
            int32_t **l_396 = (void*)0;
            int32_t **l_397 = (void*)0;
            int32_t **l_398[4][2] = {{(void*)0,(void*)0},{&g_171[3][0],(void*)0},{(void*)0,&g_171[3][0]},{(void*)0,(void*)0}};
            struct S0 l_411 = {-4811,1L,0x2.Ap-1,0x6.02B745p-66};
            int i, j;
            g_171[0][1] = func_80(func_83(func_87(l_92[0], ((uint16_t)((p_64 && ((l_95 != (void*)0) != (((uint8_t)0xA1L + (uint8_t)g_3[3]) ^ (p_63 | p_63)))) != 0x50C4L) * (uint16_t)4UL), p_64, l_99), g_387, l_389), g_3[3]);
            if ((((uint8_t)p_64 * (uint8_t)(__builtin_popcountl(l_402[0][1][2]) >= 247UL)) >= ((uint8_t)(((uint8_t)((l_402[0][1][2] && (0x4DACD824L || ((int16_t)((int32_t)(((*l_99) & func_75(l_411)) >= 0x63D0L) % (int32_t)(-10L)) % (int16_t)0x941BL))) & p_64) << (uint8_t)0) <= p_63) >> (uint8_t)p_63)))
            { /* block id: 428 */
                int8_t l_418 = (-1L);
                for (p_63 = 23; (p_63 < 20); p_63 -= 1)
                { /* block id: 431 */
                    struct S0 *l_422 = &g_356;
                    int32_t *l_426 = &g_96[1];
                    for (l_411.f1 = 0; (l_411.f1 < (-16)); l_411.f1 -= 3)
                    { /* block id: 434 */
                        float *l_419 = &g_356.f2;
                        struct S0 *l_423 = &l_92[0];
                        (*l_419) = ((float)(0x1.1p-1 < g_109.f2) * (float)l_418);
                        (*l_95) = ((uint16_t)(l_422 != l_423) >> (uint16_t)(p_63 >= (((int32_t)0x9300B2A7L % (int32_t)func_75(func_83(g_3[5], func_80(l_92[0], g_109.f1), l_419))) || l_418)));
                        l_426 = l_419;
                        /* statement id: 437 */
                        assert (l_426 == &g_356.f2);
                    }
                    /* facts after for loop */
                    assert (l_426 == &g_356.f2 || (l_426 >= &g_96[0] && l_426 <= &g_96[2]));
                    l_427[3] = func_80(l_77, l_402[0][1][2]);
                    for (g_356.f1 = (-19); (g_356.f1 <= (-25)); g_356.f1 -= 1)
                    { /* block id: 442 */
                        float *l_437 = &l_77.f3;
                        int32_t ***l_439 = &l_397;
                        int32_t *** const *l_438 = &l_439;
                        (*l_95) = (*l_95);
                        (*l_437) = ((float)p_62 + (float)__builtin_ffs(((uint8_t)((!(-10L)) < g_96[1]) + (uint8_t)((uint8_t)(0L > __builtin_parityll(__builtin_parity(g_356.f1))) << (uint8_t)((g_109.f1 > (g_251[1] != 0x538AL)) < (*l_426))))));
                        l_440 = l_438;
                        /* statement id: 445 */
                        assert (l_440 == &l_439);
                    }
                }
                /* facts after for loop */
                //assert (l_427[0] == 0 || (l_427[0] >= &g_96[0] && l_427[0] <= &g_96[2]) || l_427[0] == &g_388);
                //assert (l_440 == dangling || l_440 == &l_441);
            }
            else
            { /* block id: 448 */
                for (g_356.f1 = 0; (g_356.f1 < (-25)); g_356.f1 -= 5)
                { /* block id: 451 */
                    float *l_445 = (void*)0;
                    float *l_446 = &l_411.f3;
                    if ((*l_99))
                        break;
                    (*l_446) = g_107.f2;
                    for (g_109.f1 = (-16); (g_109.f1 > (-16)); ++g_109.f1)
                    { /* block id: 456 */
                        return p_64;
                    }
                    for (p_64 = 0; (p_64 <= 23); ++p_64)
                    { /* block id: 461 */
                        int32_t *l_451 = &g_96[1];
                        l_451 = l_451;
                    }
                }
            }
            /* facts after branching */
            //assert (l_427[0] == 0 || (l_427[0] >= &g_96[0] && l_427[0] <= &g_96[2]) || l_427[0] == &g_388);
            //assert (l_440 == dangling || l_440 == &l_441);
            for (p_64 = 0; (p_64 < 26); p_64 += 1)
            { /* block id: 468 */
                int32_t *l_454 = &g_388;
                struct S0 l_461 = {-5456,0x478EE4C5L,-0x3.Bp-1,0x1.290A70p+79};
            }
        }
        else
        { /* block id: 484 */
            struct S0 ***l_462 = (void*)0;
            l_462 = (void*)0;
            for (p_63 = 1; (p_63 >= 11); ++p_63)
            { /* block id: 488 */
                (*l_441) = (**l_440);
            }
        }
        /* facts after branching */
        //assert (l_427[0] == 0 || (l_427[0] >= &g_96[0] && l_427[0] <= &g_96[2]) || l_427[0] == &g_388);
        //assert (l_440 == dangling || l_440 == &l_441);
lbl_473:
        for (p_63 = 0; (p_63 > 39); p_63 += 3)
        { /* block id: 494 */
            const int32_t l_471 = 0L;
            (*g_387) = (l_467 || (__builtin_clzll(g_96[1]) && (p_64 == (((uint8_t)l_470 + (uint8_t)(g_109.f1 | l_471)) && (p_64 < p_63)))));
        }
        if (p_63)
        { /* block id: 497 */
            struct S0 l_472 = {-1877,0x087A01B4L,0x0.6F28B3p+53,0x5.336A76p-29};
            g_171[3][0] = l_427[2];
            l_472 = l_77;
            return p_64;
        }
        else
        { /* block id: 501 */
            if (g_356.f0)
                goto lbl_473;
        }
        l_427[0] = l_427[1];
    }
    else
    { /* block id: 505 */
        for (g_356.f1 = 2; (g_356.f1 >= 0); g_356.f1 -= 1)
        { /* block id: 508 */
            int i;
            return g_96[g_356.f1];
        }
    }
    /* facts after branching */
    //assert (l_440 == dangling || l_440 == &l_441);
    return (*g_387);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_75(struct S0  p_76)
{ /* block id: 38 */
    uint16_t l_78 = 0x11EBL;
    return l_78;
}


/* ------------------------------------------ */
/* 
 * reads : g_356.f1 g_96 g_394 g_109.f1 g_171 g_356.f0 g_263 g_109
 * writes: g_171 g_356.f1 g_109.f1 g_109
 */
static int32_t * func_80(struct S0  p_81, int32_t  p_82)
{ /* block id: 412 */
    int32_t *l_392 = &g_96[1];
    int32_t **l_393 = &g_171[2][1];
    (*l_393) = l_392;
    for (g_356.f1 = 2; (g_356.f1 >= 0); g_356.f1 -= 1)
    { /* block id: 416 */
        int32_t ****l_395 = (void*)0;
        int i;
        if (g_96[g_356.f1])
            break;
        l_395 = g_394;
        for (g_109.f1 = 0; (g_109.f1 <= 2); g_109.f1 += 1)
        { /* block id: 421 */
            int i, j;
            return g_171[(g_356.f1 + 1)][g_356.f1];
            /* statement id: 422 */
            //assert (func_80_rv == 0 || (func_80_rv >= &g_96[0] && func_80_rv <= &g_96[2]) || func_80_rv == &g_388 || func_80_rv == &l_65);
        }
    }
    (*g_263) = func_83(g_356.f0, (*l_393), (*l_393));
    return (*l_393);
    /* statement id: 426 */
    //assert (func_80_rv == 0 || (func_80_rv >= &g_96[0] && func_80_rv <= &g_96[2]) || func_80_rv == &g_388 || func_80_rv == &l_65);
}


/* ------------------------------------------ */
/* 
 * reads : g_263 g_109 l_474
 * writes:
 */
static struct S0  func_83(int32_t  p_84, int32_t * p_85, int32_t * p_86)
{ /* block id: 409 */
    int32_t *l_390 = &g_96[1];
    int32_t **l_391 = &l_390;
    (*l_391) = l_390;
    return (*g_263);
}


/* ------------------------------------------ */
/* 
 * reads : g_96 g_107 g_109 g_3 g_171 g_197 g_262 g_263 g_251 g_388 g_356.f2
 * writes: g_109 g_96 g_171 g_197
 */
static int32_t  func_87(struct S0  p_88, const int8_t  p_89, uint8_t  p_90, const int32_t * p_91)
{ /* block id: 42 */
    struct S0 l_148 = {979,0x59B8C56EL,0xA.38AAB9p+13,0x1.ADDF97p-18};
    float *l_155 = &l_148.f3;
    int32_t *l_170 = (void*)0;
    int32_t l_183 = 0xD44B8B31L;
    struct S0 *l_210 = &g_109;
    struct S0 **l_209[6] = {&l_210,&l_210,&l_210,&l_210,&l_210,&l_210};
    int32_t **l_220 = (void*)0;
    int32_t ***l_219[4] = {&l_220,&l_220,&l_220,&l_220};
    const int32_t **l_231 = &g_197;
    const int32_t ***l_230 = &l_231;
    uint32_t l_302 = 0xF4DEF939L;
    uint16_t l_305 = 1UL;
    struct S0 *l_355 = (void*)0;
    int i;
    if ((g_96[1] >= (&g_96[1] != &g_96[1])))
    { /* block id: 43 */
        uint32_t l_106[10][4] = {{0x267125BDL,0x267125BDL,1UL,3UL},{0x0BC0716CL,0UL,0x0BC0716CL,1UL},{0x0BC0716CL,1UL,1UL,0x0BC0716CL},{0x267125BDL,1UL,3UL,1UL},{1UL,0UL,3UL,3UL},{0x267125BDL,0x267125BDL,1UL,3UL},{0x0BC0716CL,0UL,0x0BC0716CL,1UL},{0x0BC0716CL,1UL,1UL,0x0BC0716CL},{0x267125BDL,1UL,3UL,1UL},{1UL,0UL,3UL,3UL}};
        int32_t l_154 = (-1L);
        const struct S0 l_156 = {5477,1L,0xD.55EFA8p-14,0xC.45573Ap-1};
        uint16_t l_166 = 0xA51EL;
        struct S0 **l_180 = (void*)0;
        int i, j;
        for (p_90 = 0; (p_90 > 22); ++p_90)
        { /* block id: 46 */
            const int32_t *l_103 = &g_96[2];
            const int32_t **l_102 = &l_103;
            int32_t l_149[6][3] = {{0L,(-1L),(-1L)},{0xBD639DC6L,0x1215561CL,0xBD639DC6L},{0L,0L,(-1L)},{0xE3155DB8L,0x1215561CL,0xE3155DB8L},{0L,(-1L),(-1L)},{0xBD639DC6L,0x1215561CL,0xBD639DC6L}};
            struct S0 *l_162 = &g_109;
            struct S0 **l_161[6][2][6] = {{{&l_162,&l_162,&l_162,&l_162,&l_162,&l_162},{&l_162,&l_162,&l_162,(void*)0,&l_162,(void*)0}},{{&l_162,&l_162,&l_162,&l_162,&l_162,&l_162},{&l_162,&l_162,&l_162,&l_162,&l_162,&l_162}},{{&l_162,&l_162,(void*)0,&l_162,&l_162,(void*)0},{&l_162,&l_162,(void*)0,(void*)0,&l_162,&l_162}},{{&l_162,&l_162,&l_162,&l_162,&l_162,(void*)0},{&l_162,&l_162,&l_162,&l_162,&l_162,&l_162}},{{&l_162,&l_162,(void*)0,&l_162,&l_162,(void*)0},{&l_162,&l_162,(void*)0,&l_162,&l_162,&l_162}},{{&l_162,&l_162,&l_162,&l_162,&l_162,&l_162},{&l_162,&l_162,&l_162,&l_162,&l_162,&l_162}}};
            int i, j, k;
            (*l_102) = p_91;
            /* statement id: 47 */
            assert ((l_103 >= &g_96[0] && l_103 <= &g_96[2]) || l_103 == &g_388 || l_103 == &g_356.f2);
            for (p_88.f1 = (-5); (p_88.f1 > 9); p_88.f1 += 2)
            { /* block id: 50 */
                return l_106[8][1];
            }
            if ((*p_91))
                break;
            if (l_106[8][3])
            { /* block id: 54 */
                struct S0 *l_108 = &g_109;
                int32_t l_119 = (-1L);
                float l_126 = 0x0.0p+1;
                (*l_108) = g_107;
                for (p_88.f1 = 0; (p_88.f1 <= (-2)); p_88.f1 -= 1)
                { /* block id: 58 */
                    int32_t l_118 = (-1L);
                    int32_t *l_120[6];
                    int i;
                    for (i = 0; i < 6; i++)
                        l_120[i] = &g_96[0];
                    p_88.f0 = (((int8_t)((int16_t)(((int32_t)((**l_102) ^ func_75(g_109)) + (int32_t)l_118) >= (g_96[1] & l_119)) * (int16_t)0x6CBAL) << (int8_t)5) & g_96[0]);
                    for (g_109.f1 = 0; (g_109.f1 < (-15)); g_109.f1 -= 1)
                    { /* block id: 62 */
                        return g_96[1];
                    }
                    g_109.f0 = (-7L);
                }
                for (p_88.f1 = 22; (p_88.f1 <= 7); p_88.f1 -= 1)
                { /* block id: 69 */
                    struct S0 l_125 = {424,0L,-0x2.2p+1,0x9.FF20F6p-81};
                    (*l_108) = l_125;
                    if (g_107.f1)
                        continue;
                    if (g_96[0])
                    { /* block id: 72 */
                        (*l_108) = g_107;
                        l_125.f0 = 0x4.36EB9Bp-95;
                    }
                    else
                    { /* block id: 75 */
                        (*l_108) = g_107;
                    }
                    p_91 = p_91;
                }
            }
            else
            { /* block id: 80 */
                const uint16_t l_131 = 0xF55DL;
                struct S0 l_151 = {1329,0x32C6D1ADL,0x9.9p-1,0x3.F5FFFDp+4};
                for (p_88.f1 = 6; (p_88.f1 <= (-3)); p_88.f1 -= 1)
                { /* block id: 83 */
                    if (((uint8_t)l_131 + (uint8_t)g_109.f1))
                    { /* block id: 84 */
                        (*l_102) = &g_96[1];
                        /* statement id: 85 */
                        assert ((l_103 >= &g_96[0] && l_103 <= &g_96[2]));
                        return p_90;
                    }
                    else
                    { /* block id: 87 */
                        int16_t l_132 = (-2L);
                        p_88.f3 = (((void*)0 == &p_91) <= __builtin_ffsl(p_90));
                        return l_132;
                    }
                }
                for (g_109.f1 = 27; (g_109.f1 >= 5); g_109.f1 -= 1)
                { /* block id: 94 */
                    uint32_t l_135 = 4294967295UL;
                    int32_t *l_158[1][5] = {{&g_96[1],&g_96[1],&g_96[1],&g_96[1],&g_96[1]}};
                    int i, j;
                    if (l_135)
                    { /* block id: 95 */
                        struct S0 *l_138[10][6][1] = {{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}},{{&g_109},{&g_109},{&g_109},{&g_109},{&g_109},{&g_109}}};
                        float *l_139 = &g_109.f2;
                        int32_t *l_140 = &g_96[1];
                        int i, j, k;
                        (*l_139) = ((float)(&p_88 == l_138[8][3][0]) * (float)p_88.f2);
                        (*l_140) = (-6L);
                        (*l_140) = (((uint8_t)g_107.f0 * (uint8_t)func_75(p_88)) > ((uint16_t)(((func_75(g_109) != (p_88.f0 >= ((!p_88.f0) < (p_89 ^ (__builtin_bswap32((func_75(l_148) ^ g_96[2])) < g_3[3]))))) > (*l_103)) == g_3[4]) * (uint16_t)p_90));
                    }
                    else
                    { /* block id: 99 */
                        struct S0 *l_150 = &l_148;
                        int32_t *l_152 = (void*)0;
                        int32_t *l_153[8] = {&g_96[1],&g_96[1],(void*)0,&g_96[1],&g_96[1],(void*)0,&g_96[1],&g_96[1]};
                        int i;
                        (*l_102) = &g_96[1];
                        /* statement id: 100 */
                        assert ((l_103 >= &g_96[0] && l_103 <= &g_96[2]));
                        l_149[4][1] = 0x1.8p+1;
                        (*l_150) = l_148;
                        l_154 = func_75(l_151);
                    }
                    if ((l_155 != p_91))
                    { /* block id: 105 */
                        struct S0 *l_157 = &l_151;
                        (*l_157) = l_156;
                    }
                    else
                    { /* block id: 107 */
                        struct S0 **l_160 = (void*)0;
                        struct S0 ***l_159[10] = {&l_160,(void*)0,(void*)0,&l_160,&l_160,&l_160,(void*)0,(void*)0,&l_160,&l_160};
                        int i;
                        (*l_102) = l_158[0][1];
                        /* statement id: 108 */
                        assert ((l_103 >= &g_96[0] && l_103 <= &g_96[2]));
                        (*l_155) = l_151.f1;
                        l_161[2][1][4] = (void*)0;
                    }
                }
                return p_88.f1;
            }
        }
lbl_174:
        for (l_148.f1 = 0; l_148.f1 < 10; l_148.f1 += 1)
        {
            for (l_154 = 0; l_154 < 4; l_154 += 1)
            {
                l_106[l_148.f1][l_154] = 6UL;
            }
        }
        for (g_109.f1 = 0; (g_109.f1 <= 3); g_109.f1 += 1)
        { /* block id: 119 */
            uint32_t l_167 = 0x0DA6F0B9L;
            struct S0 l_172 = {-5782,-1L,0xF.344FC8p-76,0x9.8p+1};
            p_91 = l_155;
            /* statement id: 120 */
            assert (p_91 == &l_148.f3);
            (*l_155) = __builtin_parity(((((((uint16_t)(g_96[1] <= 1L) + (uint16_t)(~l_166)) >= l_156.f0) >= (func_75(g_107) == (l_106[1][1] <= (g_109.f1 <= 1L)))) <= l_106[3][0]) == l_167));
            for (p_90 = 0; (p_90 <= 2); p_90 += 1)
            { /* block id: 124 */
                int32_t *l_169 = &g_96[1];
                int32_t **l_168[6][1] = {{&l_169},{&l_169},{&l_169},{&l_169},{&l_169},{&l_169}};
                struct S0 *l_173 = &l_148;
                int i, j;
                l_170 = &g_96[p_90];
                /* statement id: 125 */
                assert ((l_170 >= &g_96[0] && l_170 <= &g_96[2]));
                for (l_154 = 0; (l_154 <= 3); l_154 += 1)
                { /* block id: 128 */
                    int i, j;
                    return l_106[(g_109.f1 + 2)][g_109.f1];
                }
                g_171[3][0] = &g_96[p_90];
                (*l_173) = l_172;
            }
            for (l_172.f1 = 0; (l_172.f1 <= 3); l_172.f1 += 1)
            { /* block id: 136 */
                int i, j;
                for (p_88.f1 = 2; (p_88.f1 >= 0); p_88.f1 -= 1)
                { /* block id: 139 */
                    int i, j;
                    return l_106[(p_88.f1 + 1)][l_172.f1];
                }
                if (l_148.f1)
                    goto lbl_174;
                if (((~l_106[(g_109.f1 + 5)][g_109.f1]) || __builtin_clzll(((uint8_t)(((l_172.f1 != (g_171[3][0] != g_171[0][0])) != (((uint16_t)((void*)0 == l_180) << (uint16_t)((uint16_t)__builtin_popcountll(g_3[3]) % (uint16_t)g_107.f1)) < l_172.f0)) ^ 0x960CL) - (uint8_t)l_183))))
                { /* block id: 143 */
                    for (l_148.f1 = 0; (l_148.f1 <= 2); l_148.f1 += 1)
                    { /* block id: 146 */
                        int i;
                        if (g_96[l_148.f1])
                            break;
                        g_96[l_148.f1] = 0x4A482743L;
                        if ((*p_91))
                            break;
                        if (l_106[8][1])
                            continue;
                    }
                    for (l_183 = 2; (l_183 >= 0); l_183 -= 1)
                    { /* block id: 154 */
                        int i, j;
                        if (g_96[l_183])
                            break;
                        g_171[l_172.f1][l_183] = &g_96[l_183];
                        return g_3[3];
                    }
                }
                else
                { /* block id: 159 */
                    for (l_148.f1 = 2; (l_148.f1 >= 0); l_148.f1 -= 1)
                    { /* block id: 162 */
                        int i, j;
                        g_171[l_148.f1][l_148.f1] = &g_96[l_148.f1];
                    }
                    if (l_156.f1)
                    { /* block id: 165 */
                        (*l_155) = p_89;
                    }
                    else
                    { /* block id: 167 */
                        int32_t **l_184 = &g_171[3][0];
                        (*l_184) = &g_96[1];
                        if (l_167)
                            break;
                        (*l_184) = &g_96[1];
                    }
                }
            }
        }
    }
    else
    { /* block id: 175 */
        struct S0 *l_189 = (void*)0;
        const int32_t l_190 = 9L;
        uint8_t l_224 = 0x13L;
        const uint8_t l_227[7][7][5] = {{{0x31L,0x31L,0xFBL,0x9EL,0x46L},{255UL,0x9EL,8UL,0x71L,0UL},{251UL,0UL,0x30L,249UL,0x90L},{0xF2L,0x9EL,0xE6L,0UL,249UL},{1UL,0x31L,0x71L,0xB2L,248UL},{6UL,255UL,0xB2L,0x07L,255UL},{0UL,249UL,255UL,0UL,0xF2L}},{{1UL,0UL,0x8AL,0x68L,0x07L},{0x46L,0x06L,0xA6L,0UL,1UL},{0x46L,0xF9L,0UL,0x1DL,0x30L},{0xCAL,0xB2L,251UL,0x6CL,0x68L},{254UL,0x14L,251UL,1UL,0xA9L},{255UL,0xF8L,0UL,8UL,0x90L},{0x14L,255UL,250UL,0x59L,0x06L}},{{255UL,0xFBL,0x82L,0xF8L,1UL},{0x71L,1UL,0x31L,0x90L,254UL},{1UL,254UL,253UL,3UL,0x68L},{1UL,0x0CL,0x0CL,1UL,1UL},{0xA6L,1UL,7UL,0x71L,0x44L},{0xE6L,0x44L,0x14L,7UL,1UL},{1UL,1UL,246UL,0x71L,0x14L}},{{254UL,0xF8L,6UL,1UL,0xABL},{0UL,1UL,255UL,3UL,1UL},{0xF9L,254UL,0UL,0x90L,0x24L},{254UL,0xF9L,0x4AL,0xF8L,8UL},{3UL,254UL,0x24L,0x59L,1UL},{0x06L,255UL,7UL,8UL,0x3AL},{0xA6L,0x89L,0x32L,1UL,0UL}},{{0x82L,0xABL,255UL,0x6CL,0UL},{0x90L,1UL,0xE6L,0x1DL,0x3AL},{0x71L,0x1DL,249UL,254UL,1UL},{1UL,0UL,0x14L,0x24L,8UL},{1UL,0x17L,0xA9L,0x68L,0x24L},{255UL,0x90L,248UL,1UL,1UL},{0xA9L,0xABL,253UL,253UL,0xABL}},{{1UL,0x24L,249UL,0x68L,0x14L},{0x44L,0UL,0UL,0x89L,1UL},{0x3AL,254UL,250UL,0x0CL,0x44L},{0x44L,0UL,0x6CL,0x1DL,1UL},{1UL,0xB2L,0xA3L,0xA6L,0x68L},{0xA9L,1UL,251UL,0x14L,254UL},{255UL,0x13L,0x6CL,8UL,1UL}},{{1UL,255UL,0UL,1UL,0x06L},{1UL,0x44L,0x82L,0x13L,0x90L},{0x71L,0x59L,249UL,0x90L,0xA9L},{0x90L,254UL,0x54L,1UL,0x68L},{0x82L,254UL,0x0CL,0x82L,0x30L},{0xA6L,0x59L,0UL,0x0CL,6UL},{0xA9L,0xE6L,1UL,0x82L,0x4FL}}};
        int32_t *** const l_232 = &l_220;
        int32_t l_266 = (-9L);
        int32_t l_288 = 9L;
        float *l_349[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        int32_t ****l_379 = &l_219[0];
        int i, j, k;
lbl_267:
        if ((p_89 < (9UL > g_107.f1)))
        { /* block id: 176 */
            int16_t l_194 = 0x3B5CL;
            int32_t *l_208[10];
            uint8_t l_211[6] = {0xF6L,0xF6L,0xF6L,0xF6L,0xF6L,0xF6L};
            int i;
            for (i = 0; i < 10; i++)
                l_208[i] = &g_96[1];
            for (l_148.f1 = (-24); (l_148.f1 <= (-4)); l_148.f1++)
            { /* block id: 179 */
                int16_t l_188 = 0x3E6BL;
                int32_t l_214 = 0xB36CBBA2L;
                if (((-(int16_t)l_188) != (&g_109 == l_189)))
                { /* block id: 180 */
                    int32_t **l_191 = &g_171[3][0];
                    (*l_155) = l_190;
                    (*l_191) = &g_96[1];
                    for (p_90 = 0; (p_90 <= 6); p_90 += 2)
                    { /* block id: 185 */
                        if (l_194)
                            break;
                        (*l_155) = 0xA.B4F793p-55;
                    }
                }
                else
                { /* block id: 189 */
                    for (l_183 = 0; (l_183 >= 1); l_183 += 5)
                    { /* block id: 192 */
                        return g_96[1];
                        /* statement id: 193 */
                        //assert (g_197 == dangling || (g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
                    }
                    if (((2L && 0x2052L) != g_3[3]))
                    { /* block id: 195 */
                        return g_109.f0;
                        /* statement id: 196 */
                        //assert (g_197 == dangling || (g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
                    }
                    else
                    { /* block id: 197 */
                        g_197 = p_91;
                        /* statement id: 198 */
                        assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
                        if (l_194)
                            break;
                        if ((*p_91))
                            continue;
                    }
                    /* facts after branching */
                    assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
                    p_88.f2 = ((float)(((float)p_89 - (float)(&g_96[2] == (void*)0)) < (&g_96[1] != (void*)0)) + (float)0x1.3p+1);
                }
                for (p_90 = (-23); (p_90 != 17); p_90 += 2)
                { /* block id: 206 */
                    for (l_194 = 0; l_194 < 4; l_194 += 1)
                    {
                        for (p_88.f1 = 0; p_88.f1 < 3; p_88.f1 += 1)
                        {
                            g_171[l_194][p_88.f1] = (void*)0;
                        }
                    }
                }
                for (p_90 = 0; (p_90 <= 48); p_90 += 4)
                { /* block id: 211 */
                    int32_t **l_207 = &g_171[0][0];
                    int32_t ***l_206 = &l_207;
                    g_197 = &l_183;
                    /* statement id: 212 */
                    assert (g_197 == &l_183);
                    (*l_206) = &g_171[0][1];
                    (*l_207) = l_208[6];
                    if ((*p_91))
                        continue;
                }
                for (l_194 = 0; (l_194 <= 2); l_194 += 1)
                { /* block id: 219 */
                    l_211[5] = (((l_209[3] != &l_189) < p_88.f0) == __builtin_clzll(p_88.f1));
                    l_214 = ((float)0x8.089B94p+80 - (float)p_88.f1);
                    return p_89;
                    /* statement id: 222 */
                    //assert (g_197 == dangling || (g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
                }
            }
            /* facts after for loop */
            //assert (g_197 == &l_183 || (g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == dangling || g_197 == &g_356.f2);
            for (p_88.f1 = 0; (p_88.f1 != (-6)); p_88.f1 -= 6)
            { /* block id: 227 */
                for (l_183 = 17; (l_183 > 21); l_183 += 5)
                { /* block id: 230 */
                    p_88.f0 = (l_219[0] != (void*)0);
                }
                if ((*p_91))
                    break;
            }
        }
        else
        { /* block id: 235 */
            struct S0 l_221 = {3537,0xBFBAFD82L,-0x8.Dp-1,0x1.Bp+1};
            p_88.f3 = (0x0.9p+1 < g_96[2]);
            g_109 = l_221;
            return p_90;
        }
        /* facts after branching */
        //assert (g_197 == &l_183 || (g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == dangling || g_197 == &g_356.f2);
        g_197 = &g_96[0];
        /* statement id: 240 */
        assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]));
        if ((*g_197))
        { /* block id: 241 */
            return l_190;
        }
        else
        { /* block id: 243 */
            int16_t l_233 = 0x9AA7L;
            int32_t **l_242 = &l_170;
            p_88.f0 = ((int8_t)l_224 + (int8_t)((int8_t)(0x928FL < (l_227[3][4][1] > 0x13EDL)) << (int8_t)p_88.f0));
            for (l_224 = 0; (l_224 != 53); l_224++)
            { /* block id: 247 */
                uint8_t l_241 = 0x08L;
                p_88 = p_88;
                l_233 = ((l_230 != l_232) < (g_107.f0 == p_88.f0));
                for (p_88.f1 = 0; (p_88.f1 != 29); p_88.f1++)
                { /* block id: 252 */
                    int32_t l_240 = (-1L);
                    for (p_90 = (-18); (p_90 != 13); p_90++)
                    { /* block id: 255 */
                        g_109 = g_107;
                        if ((*p_91))
                            continue;
                        (*l_155) = (((float)l_240 + (float)(__builtin_ctzl(g_107.f1) > g_107.f2)) >= ((0xA.8ED7BAp+74 > p_89) != (0x0.C39E94p+99 > l_241)));
                    }
                    p_91 = &g_96[1];
                    /* statement id: 260 */
                    assert ((p_91 >= &g_96[0] && p_91 <= &g_96[2]));
                    g_197 = p_91;
                    (*l_232) = l_242;
                    /* statement id: 262 */
                    assert (l_220 == &l_170);
                }
            }
            for (l_233 = 0; (l_233 == (-19)); l_233 -= 1)
            { /* block id: 267 */
                for (l_224 = 0; (l_224 <= 48); ++l_224)
                { /* block id: 270 */
                    (*l_231) = (*l_242);
                    for (g_109.f1 = 0; (g_109.f1 <= 3); g_109.f1 += 1)
                    { /* block id: 274 */
                        int i;
                        (*l_231) = &g_96[1];
                        /* statement id: 275 */
                        assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]));
                        (*l_242) = &g_96[0];
                        /* statement id: 276 */
                        assert ((l_170 >= &g_96[0] && l_170 <= &g_96[2]));
                        if ((*p_91))
                            break;
                    }
                }
                g_109 = g_109;
            }
            /* facts after for loop */
            assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == 0);
            (**l_230) = p_91;
            /* statement id: 282 */
            assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
        }
        /* facts after branching */
        assert ((g_197 >= &g_96[0] && g_197 <= &g_96[2]) || g_197 == &g_388 || g_197 == &g_356.f2);
        if (((((uint16_t)((uint16_t)g_107.f0 % (uint16_t)g_109.f1) >> (uint16_t)10) > (0UL ^ g_109.f1)) ^ 8UL))
        { /* block id: 284 */
            uint32_t l_257 = 1UL;
            const struct S0 *l_265 = &g_109;
            const struct S0 **l_264 = &l_265;
            for (p_90 = 0; (p_90 <= 2); p_90 += 1)
            { /* block id: 287 */
                const struct S0 l_254 = {-1864,0xDAD00C46L,0xE.59E3B7p-19,0xB.CE3E1Bp-29};
                struct S0 *l_287 = &g_109;
                for (l_183 = 2; (l_183 >= 0); l_183 -= 1)
                { /* block id: 290 */
                    const struct S0 *l_256[5] = {&l_148,&l_148,&l_148,&l_148,&l_148};
                    int i;
                }
                for (l_266 = 11; (l_266 < (-5)); l_266 -= 1)
                { /* block id: 313 */
                    int32_t **l_274 = &g_171[3][0];
                    for (l_224 = (-23); (l_224 > 20); l_224++)
                    { /* block id: 316 */
                        int32_t l_286[7];
                        int i;
                        for (i = 0; i < 7; i++)
                            l_286[i] = 0x3D4CD080L;
                        p_88.f0 = ((uint8_t)((((void*)0 == l_274) || __builtin_ffs((*g_197))) != ((uint8_t)0x8DL + (uint8_t)(g_107.f0 && ((-9L) != (!((int32_t)((uint32_t)((((int16_t)p_88.f0 * (int16_t)(4294967287UL == g_107.f0)) ^ l_286[1]) & 0xC25883E4L) % (uint32_t)l_257) - (int32_t)p_88.f0)))))) - (uint8_t)g_96[2]);
                        if ((*p_91))
                            break;
                        if ((*g_197))
                            break;
                        (**g_262) = p_88;
                    }
                    for (l_148.f1 = 0; (l_148.f1 <= 3); l_148.f1 += 1)
                    { /* block id: 324 */
                        if (p_90)
                            goto lbl_267;
                        l_287 = &p_88;
                        /* statement id: 326 */
                        assert (l_287 == &p_88);
                    }
                    for (l_148.f1 = 5; (l_148.f1 >= 1); l_148.f1 -= 1)
                    { /* block id: 330 */
                        return l_288;
                    }
                }
                /* facts after for loop */
                assert (l_287 == &p_88 || l_287 == &g_109);
            }
            (*l_264) = (*l_264);
            g_171[2][0] = &g_96[2];
        }
        else
        { /* block id: 337 */
            uint32_t l_297 = 1UL;
            int32_t l_336 = 0xAA28781AL;
            struct S0 l_343[6] = {{5440,0x05B41BC4L,0x4.Ap+1,0x0.7p+1},{5440,0x05B41BC4L,0x4.Ap+1,0x0.7p+1},{5440,0x05B41BC4L,0x4.Ap+1,0x0.7p+1},{5440,0x05B41BC4L,0x4.Ap+1,0x0.7p+1},{5440,0x05B41BC4L,0x4.Ap+1,0x0.7p+1},{5440,0x05B41BC4L,0x4.Ap+1,0x0.7p+1}};
            int i;
            (**l_230) = p_91;
            (*l_155) = g_3[2];
            if ((((uint8_t)p_90 >> (uint8_t)(0x1CA9D7ADL == ((int8_t)(((uint32_t)g_109.f0 + (uint32_t)(-2L)) || ((uint16_t)(l_297 & ((uint8_t)((uint8_t)((*l_230) == &g_171[3][0]) << (uint8_t)(0x09AC6F9DL > ((0x904EE0D9L | p_90) || 0x17L))) >> (uint8_t)l_302)) % (uint16_t)p_90)) + (int8_t)p_88.f0))) == (*p_91)))
            { /* block id: 340 */
                float l_306 = 0xF.8970AAp-79;
                (**l_230) = p_91;
                p_88.f0 = __builtin_ffsll(((p_91 != (*l_231)) <= (((uint16_t)l_305 + (uint16_t)((*p_91) && l_297)) && (p_88.f1 && ((uint8_t)(((uint8_t)(((uint8_t)g_251[6] >> (uint8_t)((uint8_t)l_297 >> (uint8_t)((uint32_t)(-(int32_t)(g_96[0] & p_88.f0)) + (uint32_t)0x2AF049FAL))) == p_90) % (uint8_t)p_88.f1) >= 0xFA7850B5L) << (uint8_t)p_90)))));
            }
            else
            { /* block id: 343 */
                int8_t l_319 = (-4L);
                struct S0 *l_340 = &g_109;
                (*l_155) = (-(float)l_319);
                for (p_90 = 0; (p_90 <= 2); p_90 += 1)
                { /* block id: 347 */
                    const int32_t l_333 = 0L;
                    struct S0 l_335[2][8][7] = {{{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}},{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}},{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}},{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}}},{{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}},{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}},{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}},{{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1},{-4199,0x1E7836A3L,0x1.Bp+1,0x5.4A1272p+83},{5525,0xFC62B8D9L,0xA.05E8A5p-29,0x3.Bp+1}},{{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1},{1916,0x1D460D4BL,0xB.7CAF55p+33,-0x1.Cp-1}}}};
                    int i, j, k;
                    for (l_297 = 0; (l_297 <= 2); l_297 += 1)
                    { /* block id: 350 */
                        int i;
                        return g_96[p_90];
                    }
                    l_336 = ((((((uint16_t)((uint32_t)(__builtin_popcount((func_75(p_88) && (((((int16_t)(((uint8_t)(-(int16_t)g_251[1]) + (uint8_t)((int8_t)(((uint8_t)l_333 * (uint8_t)g_107.f1) && (((-1L) == (-(int16_t)p_88.f1)) & (((p_89 >= func_75(l_335[1][1][2])) == (-1L)) || p_88.f0))) + (int8_t)p_88.f0)) < l_319) % (int16_t)g_96[1]) == g_96[0]) <= p_88.f1) < p_88.f0))) ^ (*p_91)) + (uint32_t)(*p_91)) * (uint16_t)0x9D24L) < 0xBCB9L) ^ 65529UL) ^ g_107.f1) ^ 0UL);
                }
            }
            for (g_109.f1 = 0; (g_109.f1 != (-25)); g_109.f1 -= 5)
            { /* block id: 367 */
                int32_t l_346 = 0x6B21FF38L;
                int32_t l_359 = 5L;
                int32_t **l_377 = &g_171[1][1];
            }
        }
    }
    /* facts after branching */
    assert (p_91 == &l_148.f3 || (p_91 >= &g_96[0] && p_91 <= &g_96[2]) || p_91 == &g_388 || p_91 == &g_356.f2);
    assert ((l_170 >= &g_96[0] && l_170 <= &g_96[2]) || l_170 == 0);
    assert (l_220 == &l_170 || l_220 == 0);
    return p_90;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_3[i], "g_3[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 3; i++)
    {
        transparent_crc(g_96[i], "g_96[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_107.f0, "g_107.f0", print_hash_value);
    transparent_crc(g_107.f1, "g_107.f1", print_hash_value);
    transparent_crc_bytes (&g_107.f2, sizeof(g_107.f2), "g_107.f2", print_hash_value);
    transparent_crc_bytes (&g_107.f3, sizeof(g_107.f3), "g_107.f3", print_hash_value);
    transparent_crc(g_109.f0, "g_109.f0", print_hash_value);
    transparent_crc(g_109.f1, "g_109.f1", print_hash_value);
    transparent_crc_bytes (&g_109.f2, sizeof(g_109.f2), "g_109.f2", print_hash_value);
    transparent_crc_bytes (&g_109.f3, sizeof(g_109.f3), "g_109.f3", print_hash_value);
    for (i = 0; i < 8; i++)
    {
        transparent_crc(g_251[i], "g_251[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_356.f0, "g_356.f0", print_hash_value);
    transparent_crc(g_356.f1, "g_356.f1", print_hash_value);
    transparent_crc_bytes (&g_356.f2, sizeof(g_356.f2), "g_356.f2", print_hash_value);
    transparent_crc_bytes (&g_356.f3, sizeof(g_356.f3), "g_356.f3", print_hash_value);
    transparent_crc(g_388, "g_388", print_hash_value);
    transparent_crc(g_556, "g_556", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 1; j++)
        {
            transparent_crc(g_717[i][j], "g_717[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_931, "g_931", print_hash_value);
    transparent_crc_bytes (&g_943, sizeof(g_943), "g_943", print_hash_value);
    transparent_crc_bytes (&g_950, sizeof(g_950), "g_950", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 212
   depth: 1, occurrence: 30
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 56
breakdown:
   indirect level: 0, occurrence: 30
   indirect level: 1, occurrence: 14
   indirect level: 2, occurrence: 10
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 60
XXX times a bitfields struct on LHS: 13
XXX times a bitfields struct on RHS: 59
XXX times a single bitfield on LHS: 17
XXX times a single bitfield on RHS: 75

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 326
   depth: 2, occurrence: 93
   depth: 3, occurrence: 11
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 4
   depth: 9, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 5
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 197

XXX times a variable address is taken: 309
XXX times a pointer is dereferenced on RHS: 99
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 17
XXX times a pointer is dereferenced on LHS: 134
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 11
XXX times a pointer is compared with null: 34
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 861

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1491
   level: 2, occurrence: 138
   level: 3, occurrence: 21
   level: 4, occurrence: 24
   level: 5, occurrence: 17
XXX number of pointers point to pointers: 90
XXX number of pointers point to scalars: 76
XXX number of pointers point to structs: 31
XXX percent of pointers has null in alias set: 37.1
XXX average alias set size: 1.48

XXX times a non-volatile is read: 1053
XXX times a non-volatile is write: 494
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 28
XXX percentage of non-volatile access: 99.9

XXX forward jumps: 0
XXX backward jumps: 12

XXX stmts: 322
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 36
   depth: 2, occurrence: 63
   depth: 3, occurrence: 57
   depth: 4, occurrence: 65
   depth: 5, occurrence: 74

XXX percentage a fresh-made variable is used: 18.8
XXX percentage an existing variable is used: 81.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

