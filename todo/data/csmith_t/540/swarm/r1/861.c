/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2845572694
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   float  f2;
   float  f3;
   int16_t  f4;
   uint16_t  f5;
   int32_t  f6;
   int32_t  f7;
   int16_t  f8;
   uint16_t  f9;
};

struct S1 {
   uint32_t  f0;
   struct S0  f1;
   int32_t  f2;
   float  f3;
   float  f4;
   int32_t  f5;
   struct S0  f6;
   int16_t  f7;
   float  f8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_31(void);
static int32_t  func_48(uint16_t  p_49, uint32_t  p_50);
static struct S1  func_51(int16_t  p_52);
inline static int32_t  func_74(uint16_t  p_75, struct S0  p_76, struct S1  p_77, uint32_t  p_78);
static uint16_t  func_79(uint16_t  p_80, int16_t  p_81, int16_t  p_82);
static uint32_t  func_83(uint32_t  p_84, uint16_t  p_85, float  p_86, uint32_t  p_87, int32_t  p_88);
static struct S1  func_95(uint32_t  p_96, struct S1  p_97, uint16_t  p_98);
inline static float  func_106(uint32_t  p_107, int16_t  p_108);
inline static int16_t  func_109(float  p_110, uint16_t  p_111, uint16_t  p_112, struct S1  p_113, int16_t  p_114);
inline static uint32_t  func_115(float  p_116, uint16_t  p_117, float  p_118);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0xC93CC254;
    int32_t l_221 = 1;
    if (l_32)
    { /* block id: 37 */
        uint16_t l_33 = 0U;
        return l_33;
    }
    else
    { /* block id: 39 */
        uint16_t l_40 = 65535U;
        for (l_32 = 0; (l_32 != (-6)); --l_32)
        { /* block id: 42 */
            int32_t l_45 = (-1);
            int32_t l_223 = (-1);
            int32_t l_224 = 0;
            l_221 = ((((uint16_t)((int32_t)(l_32 == l_40) % (int32_t)l_32) << (uint16_t)12) & ((uint16_t)(((int16_t)(-5) >> (int16_t)l_45) & ((uint32_t)l_45 % (uint32_t)func_48(l_32, (func_51(((int16_t)((int16_t)l_40 - (int16_t)(1 >= l_32)) >> (int16_t)6)) , l_40)))) << (uint16_t)13)) , (-10));
            l_223 &= (~l_45);
            l_223 = l_224;
        }
    }
    return l_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_48(uint16_t  p_49, uint32_t  p_50)
{ /* block id: 112 */
    int16_t l_219 = 4;
    int32_t l_220 = 1;
    l_220 = l_219;
    return l_220;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_51(int16_t  p_52)
{ /* block id: 43 */
    int32_t l_60 = 0;
    int32_t l_62 = 9;
    int32_t l_63 = 0;
    int32_t l_64 = 1;
    int32_t l_65 = 0x113D7AFF;
    uint16_t l_66 = 65535U;
    int16_t l_183 = 0x3555;
    struct S1 l_204 = {4294967290U,{0xE99DC055,4294967295U,0xF.CDA303p-96,0x3.D5BF3Bp-56,0,2U,1,-3,3,0x637C},0x973B3B5C,0x0.7p-1,0x4.13302Fp-99,1,{2U,0x138F8FDF,0x2.C83B8Cp+85,0x5.6BB7E7p+91,-1,65535U,0x64D8A8CE,9,0x9E4B,1U},0x4C7D,0x8.4p-1};
    for (p_52 = 0; (p_52 == (-6)); p_52 -= 4)
    { /* block id: 46 */
        int16_t l_59 = 0xBC84;
        int32_t l_61 = 3;
        struct S0 l_203 = {0U,2U,0x0.Dp-1,0x8.3D4CD0p+74,0x8E2F,5U,0xC25883E4,0,0x75AC,65533U};
        --l_66;
        l_204.f1.f7 = (((~(((-(float)((l_60 != (((uint32_t)(((-(int16_t)((65532U <= (func_74(func_79(__builtin_clzl(func_83(l_64, ((uint16_t)p_52 << (uint16_t)11), l_59, l_65, p_52)), p_52, l_183), l_203, l_204, l_203.f9) >= 0xCC7A630B)) && 0x845D)) == l_203.f6) < 0xD034) - (uint32_t)p_52) , (-0x1.3p+1))) == p_52)) , p_52) < p_52)) >= 0xE161) != l_203.f5);
    }
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_74(uint16_t  p_75, struct S0  p_76, struct S1  p_77, uint32_t  p_78)
{ /* block id: 95 */
    float l_205 = 0x0.0818E7p+45;
    int32_t l_206 = 0xD4B94C9C;
    struct S0 l_218 = {0x3828E415,0x54F50ACF,0x2.D64FC4p-17,-0x1.Bp+1,0x774D,0xAF55,0xF17BF180,0xC7F2957D,0x97F9,65534U};
    if ((p_77.f6.f5 < p_77.f1.f9))
    { /* block id: 96 */
        return l_206;
    }
    else
    { /* block id: 98 */
        struct S0 l_207 = {4294967295U,0U,-0x1.Cp+1,0x3.1C5278p-86,0xB544,65530U,-1,-3,0x56E7,0U};
        if (((((func_109(p_77.f6.f3, p_76.f4, l_206, (l_207 , p_77), (+4294967295U)) == ((uint16_t)(p_76.f0 >= ((uint32_t)((uint16_t)(p_77.f2 | l_206) >> (uint16_t)8) + (uint32_t)l_206)) * (uint16_t)l_206)) , p_77.f6.f6) && p_77.f2) , p_77.f7))
        { /* block id: 99 */
            return p_77.f6.f1;
        }
        else
        { /* block id: 101 */
            uint32_t l_217 = 0xAA2BB1F5;
            l_217 = ((uint16_t)l_207.f1 / (uint16_t)65535U);
        }
    }
    p_77.f6.f7 &= (-6);
    l_206 = (((p_76.f1 <= l_206) != func_115(p_76.f6, l_206, (p_77.f6.f7 , ((0xD.39CEF0p-96 == (l_206 != l_206)) >= 0x5.D47B18p+12)))) < 0);
    l_218 = l_218;
    return l_218.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_79(uint16_t  p_80, int16_t  p_81, int16_t  p_82)
{ /* block id: 83 */
    float l_188 = 0x1.4p+1;
    int32_t l_189 = (-1);
    struct S1 l_190 = {1U,{0x44A0E0B1,7U,-0x7.Bp-1,0xC.8545C8p-84,0x26E5,0x6A48,0xB577FE8E,1,0xA098,0xE549},0x1C1BC39E,0x0.4p-1,0xF.AC7ECDp-60,-1,{0x01C52B69,0U,0x0.6F3D06p-74,0x0.1p+1,4,0xB750,1,-4,-2,65526U},9,-0x4.Fp-1};
    float l_200 = 0x8.244003p-35;
    int32_t l_201 = 0xDE01A913;
    int32_t l_202 = (-6);
    for (p_81 = (-23); (p_81 < 9); p_81 += 1)
    { /* block id: 86 */
        struct S1 l_191 = {1U,{0x3E7D0B48,1U,0x8.Bp+1,0xA.6E7CB5p-56,0xDD12,0x358E,1,1,-9,0xB741},0,0x2.A22810p+99,0x0.Dp+1,1,{4294967292U,0x759E3B7E,0xB.DCE3E1p+63,-0x9.7p-1,0x5E75,0xA42A,0x8A9B1481,0x2320A021,0xC2E6,0xF090},0,0x6.B2B731p+28};
        l_189 ^= ((uint16_t)0xE026 * (uint16_t)p_80);
        l_191 = func_95(p_82, l_190, p_80);
        return l_190.f0;
    }
    l_190.f6.f7 = p_80;
    l_190.f6.f7 = p_82;
    l_201 |= ((int16_t)func_83((((((uint32_t)(p_80 == (((int32_t)(__builtin_clzl(p_81) & p_81) + (int32_t)((int16_t)func_115(func_109(p_80, l_189, p_80, l_190, ((p_82 , p_82) , 0xC246)), p_82, p_80) << (int16_t)14)) && l_190.f6.f9)) / (uint32_t)p_82) , 1U) != 0) | l_190.f1.f1), p_81, l_190.f6.f4, p_81, l_190.f7) >> (int16_t)15);
    return l_202;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_83(uint32_t  p_84, uint16_t  p_85, float  p_86, uint32_t  p_87, int32_t  p_88)
{ /* block id: 48 */
    uint32_t l_99 = 4294967288U;
    struct S1 l_100 = {0x234E6C56,{3U,4294967294U,-0x1.0p+1,-0x1.Ap+1,0,65532U,0xC885B340,0xE2242FA0,-3,0x9BE1},0x4DE48EC7,0x7.8p-1,0x0.Cp-1,0,{6U,0x15219C01,0xE.46CE4Cp+56,0x1.5p-1,1,5U,0,-2,0x1326,0x7FA2},0x21F7,0xF.5966A8p-78};
    int32_t l_182 = (-1);
    l_182 |= (!(p_87 || (((+(p_87 < __builtin_ctz(((((int32_t)((func_95(l_99, l_100, l_100.f5) , (((p_88 , (func_115(((float)((float)p_88 * (float)(+(__builtin_ffsll(l_100.f6.f8) == 0x0.8p+1))) + (float)p_85), p_85, l_100.f1.f5) < p_87)) == p_85) == 0xA105)) , l_100.f6.f4) + (int32_t)p_88) > (-1)) || p_88)))) > p_84) >= p_87)));
    l_182 = 0x2.8p-1;
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_95(uint32_t  p_96, struct S1  p_97, uint16_t  p_98)
{ /* block id: 49 */
    uint16_t l_103 = 0xA214;
    struct S1 l_127 = {8U,{4U,0x0D5BDE6C,0xB.A86194p+93,-0x1.Cp+1,-6,0xE888,1,1,-9,0x9B2A},0x55E833F8,-0x4.1p+1,0x0.7p+1,-4,{4294967295U,0xD5CD4344,0x1.Fp+1,0x5.8p+1,0x4C03,0x0D54,0x37B03C32,0x4B497D78,0xBA53,0U},0x1195,0x2.559AEFp-68};
    for (p_97.f1.f9 = 0; (p_97.f1.f9 >= 18); p_97.f1.f9 += 1)
    { /* block id: 52 */
        --l_103;
    }
    l_127.f6.f7 = (func_106(p_97.f6.f9, (__builtin_ia32_crc32qi(p_97.f1.f9, ((func_109(l_103, (__builtin_clzl(((p_97.f1.f6 > 0xF.E4F8FBp-36) , func_115(p_97.f8, p_97.f1.f8, (-(float)l_103)))) , p_97.f5), l_103, l_127, l_127.f6.f8) != l_127.f1.f5) , l_127.f6.f1)) > p_97.f6.f0)) != l_127.f1.f1);
    return l_127;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_106(uint32_t  p_107, int16_t  p_108)
{ /* block id: 67 */
    struct S1 l_170 = {0x8B36CBBA,{1U,4294967289U,0xF.511023p-86,0x0.Fp-1,0,0U,0x291ADAEA,0x5801B7B7,2,0xD09C},0,0x8.C5B0B8p-32,0x1.2p+1,2,{0U,0x0730238B,0x0.Ep-1,0x8.5D862Fp+44,4,0x80C7,1,0,0x9FAA,65535U},0xFBAF,-0x1.7p+1};
    uint16_t l_173 = 0x791F;
    if (((((p_107 == (l_170 , __builtin_ia32_crc32qi(l_170.f6.f8, p_108))) == l_170.f1.f1) | ((uint32_t)l_173 / (uint32_t)p_108)) == l_170.f1.f4))
    { /* block id: 68 */
        for (l_170.f6.f9 = 0; (l_170.f6.f9 == 60); l_170.f6.f9 += 1)
        { /* block id: 71 */
            if (p_107)
                break;
        }
    }
    else
    { /* block id: 74 */
        uint32_t l_176 = 0x1C847789;
        l_170.f1.f7 |= l_176;
    }
    return l_170.f1.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_109(float  p_110, uint16_t  p_111, uint16_t  p_112, struct S1  p_113, int16_t  p_114)
{ /* block id: 58 */
    int32_t l_130 = 0x8C1170D4;
    int32_t l_131 = 0;
    int32_t l_169 = 0x5BED0AC6;
    if ((((int32_t)(0U | l_130) % (int32_t)l_131) , p_113.f6.f0))
    { /* block id: 59 */
        uint32_t l_135 = 4U;
        uint16_t l_168 = 0x2E11;
        p_113.f2 = ((uint16_t)((!(l_135 & ((uint16_t)(((((int16_t)((int16_t)((int32_t)(__builtin_bswap64(((((uint32_t)p_113.f7 - (uint32_t)l_135) , ((65535U >= (((int32_t)l_135 % (int32_t)p_113.f1.f4) > func_115(((float)((float)l_130 - (float)l_135) - (float)func_115(l_135, l_131, l_131)), l_135, p_113.f6.f3))) == l_135)) >= l_130)) >= l_130) / (int32_t)l_135) << (int16_t)0) >> (int16_t)10) , l_135) != (-5)) ^ (-3)) >> (uint16_t)p_111))) >= l_130) * (uint16_t)l_130);
        l_130 = (l_135 <= ((float)(((float)(p_113.f1.f7 <= ((float)p_113.f5 * (float)(p_113.f2 , (((float)(((float)(0x8.56030Ep+28 != ((float)((float)((float)((-0x4.2p+1) != (p_113.f6.f3 != 0x0.3626FDp+93)) + (float)0xC.B899A1p+43) / (float)l_168) / (float)(-0x3.Ep-1))) - (float)l_169) > p_113.f4) + (float)l_130) <= l_130)))) / (float)p_113.f1.f2) < l_131) / (float)0x7.3p-1));
    }
    else
    { /* block id: 62 */
        return p_113.f6.f6;
    }
    l_130 = (0U <= l_130);
    return l_130;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_115(float  p_116, uint16_t  p_117, float  p_118)
{ /* block id: 55 */
    int32_t l_122 = 0;
    uint32_t l_125 = 0x9C3978F7;
    int32_t l_126 = 0;
    l_126 = (((int16_t)(0x2307 != l_122) % (int16_t)((int16_t)l_125 << (int16_t)0)) , l_122);
    return p_117;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 50
   depth: 1, occurrence: 3
   depth: 2, occurrence: 6
XXX total union variables: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 9
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2

XXX total number of pointers: 0

XXX times a non-volatile is read: 198
XXX times a non-volatile is write: 29
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 50
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 15
   depth: 2, occurrence: 6

XXX percentage a fresh-made variable is used: 25.7
XXX percentage an existing variable is used: 74.3
********************* end of statistics **********************/

