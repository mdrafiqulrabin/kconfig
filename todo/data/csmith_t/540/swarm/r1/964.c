/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3066226922
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 3;
   uint16_t  f1;
   uint32_t  f2;
   uint8_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_29(void);
static int32_t * func_30(int32_t * p_31, uint8_t  p_32, int32_t  p_33);
inline static int32_t * func_34(const uint32_t  p_35, int32_t * p_36);
inline static uint8_t  func_45(int8_t  p_46, uint8_t  p_47, int32_t * const  p_48, int32_t * const  p_49, int16_t  p_50);
static int32_t * const  func_53(int16_t  p_54, int8_t  p_55);
static int32_t * func_56(uint32_t  p_57);
static uint16_t  func_59(int32_t * p_60, int32_t * p_61, uint16_t  p_62);
inline static int32_t * func_63(int32_t  p_64, int32_t * p_65, int32_t  p_66);
inline static int32_t * func_67(uint32_t  p_68, uint16_t  p_69, struct S0  p_70, uint8_t  p_71, int32_t * p_72);
inline static struct S0  func_76(struct S0  p_77, uint8_t  p_78, uint16_t  p_79, uint32_t  p_80, uint32_t  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_29(void)
{ /* block id: 36 */
    const uint16_t l_37 = 65532U;
    int32_t l_39 = (-1);
    int32_t *l_38 = &l_39;
    int32_t **l_466 = &l_38;
    int8_t l_499 = (-2);
    uint8_t l_500 = 255U;
    uint16_t l_527 = 65535U;
    uint32_t l_531 = 0U;
    struct S0 l_533 = {-1,65528U,0x4B4BCC05,0xBC};
    struct S0 **l_539 = (void*)0;
    uint32_t l_540 = 0xB9F8CB36;
    struct S0 *l_541 = &l_533;
    const int16_t l_544 = 0x67B3;
    int32_t l_548 = 0x841020F4;
    int32_t *l_551 = (void*)0;
    uint32_t l_568 = 4294967286U;
    int16_t l_575 = 0x5433;
    struct S0 l_577 = {-0,5U,0U,0xDB};
    int8_t l_584 = 0xEE;
    uint32_t l_593 = 1U;
    (*l_466) = func_30(func_34(l_37, l_38), l_37, l_37);
    if (l_39)
    { /* block id: 223 */
        int32_t *l_475 = &l_39;
        int32_t l_483 = 0x9397BDFB;
        struct S0 l_503 = {0,1U,0xA435054B,255U};
        struct S0 *l_502 = &l_503;
        struct S0 **l_504 = &l_502;
        const int32_t *l_510 = &l_39;
        const int32_t **l_509 = &l_510;
        for (l_39 = 0; (l_39 <= 27); l_39++)
        { /* block id: 226 */
            int32_t l_470 = 0xD1AC72E4;
            int32_t *l_469 = &l_470;
            struct S0 l_476 = {-1,0U,1U,0x12};
            uint32_t l_495 = 0xF9EB941F;
            (*l_469) = 0xAED37A76;
            for (l_470 = (-10); (l_470 >= 17); l_470 += 1)
            { /* block id: 230 */
                int16_t l_473 = 5;
                int32_t *l_474 = &l_39;
                int32_t *l_489 = &l_39;
                (*l_466) = func_56((l_473 != func_59(&l_470, l_474, (*l_469))));
                if (func_59(l_475, (*l_466), (*l_474)))
                { /* block id: 232 */
                    struct S0 l_484 = {0,65535U,0x03AF83A9,0U};
                    int32_t ***l_485 = (void*)0;
                    const int32_t ***l_486 = (void*)0;
                    int32_t * const **l_487 = (void*)0;
                    int32_t ***l_488 = &l_466;
                    l_484 = l_476;
                    (*l_488) = &l_38;
                }
                else
                { /* block id: 235 */
                    int16_t l_494 = 0x886B;
                    struct S0 **l_498 = (void*)0;
                    struct S0 ***l_497 = &l_498;
                    struct S0 ****l_496 = &l_497;
                    int32_t l_501 = 0x77C2C50F;
                    (*l_466) = l_489;
                    l_501 = (((__builtin_bswap32((*l_489)) || ((((uint8_t)(((uint32_t)(__builtin_ffsl(((__builtin_clzll(l_494) < (*l_469)) >= (l_495 && ((void*)0 != l_496)))) < (*l_38)) - (uint32_t)(*l_469)) >= (*l_489)) - (uint8_t)(*l_474)) > (*l_469)) == l_499)) & l_500) <= (**l_466));
                    (*l_466) = func_53((*l_475), l_494);
                }
            }
        }
        (*l_504) = l_502;
        (*l_509) = func_53((*l_475), __builtin_popcountll(((uint8_t)(func_45(((int16_t)0xAA23 % (int16_t)(*l_475)), (9U < ((((*l_475) > (*l_475)) != (0x6B4F != 0U)) > (*l_475))), (*l_466), (*l_466), (*l_475)) == (*l_475)) << (uint8_t)(*l_475))));
    }
    else
    { /* block id: 244 */
        struct S0 l_511 = {-1,0xCC62,4294967292U,255U};
        struct S0 *l_512 = &l_511;
        int32_t ***l_519 = (void*)0;
        int32_t ****l_526 = (void*)0;
        int32_t *l_532 = &l_39;
        (*l_512) = l_511;
        for (l_39 = (-7); (l_39 <= (-14)); l_39 -= 8)
        { /* block id: 248 */
            int32_t *l_520 = &l_39;
            struct S0 ** const *l_522 = (void*)0;
            struct S0 ** const **l_521 = &l_522;
            if (((int8_t)((int16_t)(&l_466 == l_519) << (int16_t)(func_59(l_520, l_520, (l_521 == &l_522)) & 1U)) + (int8_t)(*l_520)))
            { /* block id: 249 */
                int32_t ****l_525 = &l_519;
                for (l_511.f3 = 0; (l_511.f3 <= 56); l_511.f3 += 7)
                { /* block id: 252 */
                    l_526 = l_525;
                }
                (*l_521) = (*l_521);
            }
            else
            { /* block id: 256 */
                int8_t l_528 = 0x89;
                int32_t l_530 = 0xBE87E4E3;
                int32_t *l_529 = &l_530;
                (*l_529) = (l_527 >= l_528);
            }
            (*l_466) = (*l_466);
        }
        (*l_532) = l_531;
    }
    (*l_541) = func_76(l_533, l_499, (((uint16_t)0x99DF % (uint16_t)(~func_59((*l_466), (*l_466), ((uint8_t)l_500 * (uint8_t)(l_539 != l_539))))) >= l_540), l_533.f3, l_533.f1);
    if (((uint16_t)l_544 % (uint16_t)((int16_t)func_59((*l_466), func_56(((l_544 != func_45(l_533.f3, l_533.f1, (*l_466), (*l_466), l_548)) & l_533.f1)), l_548) + (int16_t)l_533.f2)))
    { /* block id: 264 */
        int32_t **l_549 = &l_38;
        int32_t *l_550 = &l_39;
        int32_t ***l_554 = &l_549;
        int32_t ****l_553 = &l_554;
        int32_t ***** const l_552 = &l_553;
        int32_t *****l_555 = &l_553;
        int32_t l_576 = 1;
        uint32_t l_578 = 0x1CDDD9A3;
        (*l_550) = ((void*)0 != l_549);
        (*l_550) = (*l_550);
        if (l_540)
        { /* block id: 267 */
            int16_t l_556 = 2;
            int16_t l_562 = 0x6C90;
            struct S0 l_563 = {-1,0U,0x1ABF02F0,1U};
            (*l_549) = l_551;
            l_555 = l_552;
            (*l_550) = ((l_556 < ((l_556 > ((l_556 <= func_45((((int32_t)l_556 - (int32_t)(-(int16_t)(l_556 & 0xA8E3))) | ((int32_t)((func_45((((void*)0 != (***l_553)) || l_556), l_562, (*l_466), (*l_466), l_556) <= l_562) == l_562) - (int32_t)l_562)), l_556, (***l_553), (**l_554), l_562)) | (*l_550))) || l_562)) & 65535U);
            (*l_541) = func_76(l_563, l_562, (*l_550), ((l_556 ^ l_563.f2) || (~l_563.f2)), (*l_550));
        }
        else
        { /* block id: 272 */
            int32_t *l_565 = &l_39;
            (*l_466) = l_565;
            for (l_533.f2 = 0; (l_533.f2 <= 26); l_533.f2 += 1)
            { /* block id: 276 */
                (***l_554) = (*l_565);
            }
        }
        (*l_550) = func_45(l_533.f1, l_568, (*l_466), (*l_466), ((int8_t)(-1) + (int8_t)((uint16_t)(func_59((**l_554), (****l_555), l_578) || l_577.f0) - (uint16_t)0xBAD5)));
    }
    else
    { /* block id: 281 */
        int8_t l_581 = 0x04;
        int32_t ***l_589 = &l_466;
        if (((((uint32_t)__builtin_parityll(l_581) % (uint32_t)0x1EF74E5C) && l_581) >= ((0xD13D04B0 || l_581) ^ ((uint32_t)(((__builtin_popcountl(l_581) || l_581) && l_581) | 0x08) - (uint32_t)l_584))))
        { /* block id: 282 */
            int8_t l_587 = 0x3D;
            int32_t *l_588 = &l_39;
            int32_t **l_590 = (void*)0;
            int32_t **l_591 = &l_551;
            for (l_533.f1 = 0; (l_533.f1 != 50); l_533.f1 += 1)
            { /* block id: 285 */
                if (l_587)
                    break;
            }
            (*l_466) = l_588;
            (*l_591) = func_53(((void*)0 != l_589), (0xDD07D604 == (0x15CE8A77 && 1)));
        }
        else
        { /* block id: 290 */
            int16_t l_592 = (-1);
            (**l_589) = (**l_589);
            return l_592;
        }
    }
    return l_593;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(int32_t * p_31, uint8_t  p_32, int32_t  p_33)
{ /* block id: 217 */
    uint32_t l_455 = 0x6EE13624;
    struct S0 l_457 = {-1,0x78D3,0x7270AFDD,0U};
    struct S0 *l_456 = &l_457;
    int32_t * const l_458 = (void*)0;
    struct S0 ***l_460 = (void*)0;
    struct S0 ****l_459 = &l_460;
    int32_t l_462 = (-1);
    int32_t *l_461 = &l_462;
    int32_t *l_463 = &l_462;
    int32_t *l_464 = &l_462;
    int32_t *l_465 = (void*)0;
    (*p_31) = (-2);
    (*p_31) = (func_45(p_32, (l_455 != ((l_456 != (void*)0) == l_457.f3)), l_458, l_458, ((((l_459 != &l_460) >= 1U) | p_32) && 0)) && (*p_31));
    (*p_31) = l_457.f0;
    return l_465;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_34(const uint32_t  p_35, int32_t * p_36)
{ /* block id: 37 */
    int32_t l_42 = 0xE77E815F;
    int32_t l_52 = (-4);
    int32_t * const l_51 = &l_52;
    struct S0 *** const l_446 = (void*)0;
    (*l_51) = (p_35 & (((int16_t)l_42 + (int16_t)(((uint8_t)func_45(l_42, l_42, l_51, func_53(((((p_35 > 0xBEAC) & (p_36 != (void*)0)) == (*l_51)) <= (*l_51)), p_35), (*l_51)) + (uint8_t)(*l_51)) >= p_35)) ^ (-1)));
    for (l_52 = 0; (l_52 == 6); l_52 += 1)
    { /* block id: 192 */
        struct S0 l_424 = {-0,0xAB23,0x0E81A899,0xB9};
        struct S0 *l_423 = &l_424;
        struct S0 **l_431 = &l_423;
        struct S0 ***l_430 = &l_431;
        l_423 = l_423;
        (*p_36) = 1;
        if ((*l_51))
        { /* block id: 195 */
            int32_t l_425 = (-10);
            int32_t ***l_435 = (void*)0;
            int32_t *l_438 = &l_425;
            int32_t **l_437 = &l_438;
            int32_t ***l_436 = &l_437;
            (*p_36) = l_425;
            for (l_424.f1 = 0; (l_424.f1 >= 24); l_424.f1++)
            { /* block id: 199 */
                uint32_t l_432 = 4294967295U;
                int32_t *l_434 = &l_425;
                int32_t **l_433 = &l_434;
                l_432 = (((int32_t)0x1E74DD83 + (int32_t)p_35) < ((void*)0 != l_430));
                (*l_433) = (void*)0;
            }
            (*l_436) = &p_36;
            return p_36;
        }
        else
        { /* block id: 205 */
            int32_t l_441 = 0x32C3A902;
            int32_t *l_452 = &l_52;
            int32_t **l_451 = &l_452;
            (*l_451) = func_63((((uint32_t)l_441 - (uint32_t)(((int32_t)((int16_t)(p_35 ^ (l_446 != l_446)) >> (int16_t)9) + (int32_t)(*l_51)) | ((uint8_t)(&l_431 == &l_431) - (uint8_t)((int8_t)p_35 - (int8_t)((((*l_51) == p_35) <= l_424.f0) <= p_35))))) && 6U), &l_441, l_424.f3);
            return p_36;
        }
    }
    for (l_42 = 0; (l_42 <= (-29)); --l_42)
    { /* block id: 212 */
        (*p_36) = (p_35 || 0U);
        if ((*l_51))
            break;
    }
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_45(int8_t  p_46, uint8_t  p_47, int32_t * const  p_48, int32_t * const  p_49, int16_t  p_50)
{ /* block id: 185 */
    uint16_t l_413 = 1U;
    int32_t l_418 = 0x0BFF102D;
    int32_t *l_417 = &l_418;
    int32_t **l_416 = &l_417;
    int32_t ***l_415 = &l_416;
    int32_t ****l_414 = &l_415;
    (****l_414) = (((~0U) ^ l_413) > ((((p_46 <= ((void*)0 == l_414)) >= ((((-7) <= 6) != ((uint8_t)(func_59((***l_414), func_63((*l_417), (*l_416), (*l_417)), p_47) <= 0xAB7BF93C) % (uint8_t)p_46)) < 65526U)) | 6) > p_47));
    (****l_414) = (**l_416);
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_53(int16_t  p_54, int8_t  p_55)
{ /* block id: 38 */
    uint8_t l_58 = 0xE4;
    int32_t l_403 = 3;
    int32_t *l_402 = &l_403;
    int32_t **l_401 = &l_402;
    int32_t *l_404 = &l_403;
    int32_t * const l_405 = &l_403;
    int32_t * const l_406 = &l_403;
    int32_t * const l_407 = &l_403;
    int32_t * const l_408 = &l_403;
    int32_t * const l_409 = &l_403;
    int32_t * const l_410 = &l_403;
    int32_t * const l_411 = (void*)0;
    (*l_401) = func_56((l_58 | p_55));
    (*l_404) = l_58;
    return l_411;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(uint32_t  p_57)
{ /* block id: 39 */
    int32_t l_73 = 0x236F914A;
    struct S0 l_82 = {-1,0x3980,0U,0xA7};
    int32_t l_361 = 0x717E3722;
    int32_t *l_360 = &l_361;
    int32_t *l_379 = &l_73;
    int32_t *l_380 = &l_361;
    struct S0 **l_383 = (void*)0;
    struct S0 *** const l_382 = &l_383;
    int32_t l_389 = 0x0800FF41;
    int32_t *l_392 = &l_73;
    int32_t *l_393 = &l_73;
    int32_t *l_394 = &l_73;
    int32_t *l_395 = &l_73;
    int32_t *l_396 = &l_361;
    int32_t *l_397 = &l_361;
    int32_t *l_398 = &l_361;
    int32_t *l_399 = &l_361;
    int32_t *l_400 = (void*)0;
    if (((func_59(func_63(p_57, func_67(l_73, ((uint16_t)(8 | (0x17 <= (l_73 > 7))) >> (uint16_t)10), func_76(l_82, ((uint16_t)((int32_t)0x3B05E262 + (int32_t)l_82.f3) - (uint16_t)0x61E4), p_57, p_57, l_82.f0), l_82.f1, &l_73), l_82.f2), l_360, (*l_360)) & 1) != p_57))
    { /* block id: 170 */
        int32_t *l_374 = &l_73;
        int32_t *l_375 = &l_73;
        int32_t *l_377 = &l_73;
        int32_t *l_378 = &l_361;
        struct S0 ***l_385 = &l_383;
        struct S0 ****l_384 = &l_385;
        for (l_361 = 14; (l_361 >= (-12)); --l_361)
        { /* block id: 173 */
            int32_t *l_376 = &l_73;
            int32_t *l_381 = (void*)0;
            return l_381;
        }
        (*l_384) = l_382;
    }
    else
    { /* block id: 177 */
        int32_t *l_386 = (void*)0;
        struct S0 l_390 = {1,65533U,0U,0x28};
        int32_t **l_391 = &l_386;
        l_386 = &l_73;
        (*l_391) = func_63(p_57, func_67((((int8_t)func_59(&l_361, func_63(((*l_379) < (*l_379)), l_386, p_57), p_57) << (int8_t)2) != p_57), p_57, l_390, (*l_380), &l_361), p_57);
    }
    return l_400;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_59(int32_t * p_60, int32_t * p_61, uint16_t  p_62)
{ /* block id: 167 */
    uint8_t l_366 = 0xAC;
    int16_t l_367 = 6;
    int32_t l_369 = 0;
    int32_t *l_368 = &l_369;
    int32_t **l_370 = &l_368;
    uint32_t l_371 = 1U;
    (*l_370) = func_63(((int16_t)((int16_t)l_366 << (int16_t)l_367) << (int16_t)8), l_368, (p_62 <= (*l_368)));
    return l_371;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_63(int32_t  p_64, int32_t * p_65, int32_t  p_66)
{ /* block id: 59 */
    struct S0 l_103 = {1,0x53FB,0xD6221F42,0x1D};
    int32_t ***l_185 = (void*)0;
    int32_t ****l_184 = &l_185;
    struct S0 *l_240 = &l_103;
    struct S0 **l_239 = &l_240;
    struct S0 l_242 = {1,0x3500,0xD5182C66,0U};
    int32_t l_309 = 2;
    int32_t *l_308 = &l_309;
    int32_t *l_313 = &l_309;
    int32_t *l_323 = &l_309;
    int32_t *l_327 = &l_309;
    int32_t *l_332 = (void*)0;
    int16_t l_345 = 0xDBE1;
    int32_t *l_353 = &l_309;
    int32_t *l_354 = &l_309;
    int32_t *l_355 = &l_309;
    int32_t *l_356 = &l_309;
    int32_t *l_357 = &l_309;
    int32_t *l_358 = &l_309;
    int32_t *l_359 = (void*)0;
    if ((*p_65))
    { /* block id: 60 */
        uint8_t l_104 = 246U;
        struct S0 *l_109 = &l_103;
        int32_t l_118 = 0x8C533BF9;
        const int32_t *l_117 = &l_118;
        const int32_t **l_116 = &l_117;
        const int32_t ***l_115 = &l_116;
        const int32_t ****l_114 = &l_115;
        (*l_109) = func_76(l_103, p_64, l_104, (((uint8_t)((int32_t)((p_66 < p_64) || l_104) % (int32_t)l_104) - (uint8_t)l_103.f3) == (p_66 >= 0x3B)), l_103.f2);
        (*p_65) = ((int32_t)(*p_65) % (int32_t)((uint32_t)l_103.f1 - (uint32_t)(&p_65 == (void*)0)));
        (*l_114) = (void*)0;
    }
    else
    { /* block id: 64 */
        int32_t l_128 = 0x0CF2F289;
        int32_t *l_127 = &l_128;
        int32_t **l_126 = &l_127;
        int32_t ***l_125 = &l_126;
        struct S0 l_172 = {1,0x63E3,4294967289U,0x4F};
        struct S0 l_268 = {-0,65528U,4U,0U};
        int32_t *l_311 = &l_128;
        int32_t *l_315 = &l_309;
        struct S0 *l_333 = &l_103;
        if ((0 ^ p_64))
        { /* block id: 65 */
            uint8_t l_121 = 0xE2;
            const int32_t *l_131 = &l_128;
            const int32_t **l_130 = &l_131;
            const int32_t *** const l_129 = &l_130;
            uint8_t l_144 = 0xA7;
            struct S0 l_145 = {-0,0xC835,4294967295U,0x26};
            struct S0 **l_238 = (void*)0;
            const int32_t ***l_247 = &l_130;
            const int32_t ****l_246 = &l_247;
            if (((uint16_t)(l_121 == (!((uint16_t)(l_125 == l_129) - (uint16_t)(((uint32_t)(__builtin_ctz(((**l_126) < p_66)) || ((uint8_t)(((uint8_t)p_64 << (uint8_t)0) < (p_66 == (((((uint16_t)3U % (uint16_t)p_64) || 0) != 0x30BE999A) || 0x0CFB))) >> (uint8_t)l_103.f1)) % (uint32_t)p_66) || p_66)))) >> (uint16_t)l_103.f0))
            { /* block id: 66 */
                int32_t l_146 = 0xAEC5E7E4;
                for (l_103.f1 = 0; (l_103.f1 > 39); l_103.f1++)
                { /* block id: 69 */
                    int32_t l_165 = (-2);
                    (*l_126) = func_67(p_64, __builtin_ctzll(p_66), l_103, (p_66 | ((*l_127) ^ (*l_127))), p_65);
                    if ((*l_127))
                        break;
                    (*l_126) = func_67(l_144, p_64, l_145, l_146, p_65);
                    for (p_64 = 18; (p_64 <= (-14)); p_64 -= 5)
                    { /* block id: 75 */
                        uint16_t l_155 = 65529U;
                        p_65 = p_65;
                        (**l_125) = func_67((l_103.f2 & ((-1) && p_64)), p_64, func_76(func_76(l_145, (((uint8_t)2U % (uint8_t)(-1)) && ((int8_t)(-(int32_t)(*p_65)) >> (int8_t)(-(int32_t)0x43FB2F25))), p_64, p_64, l_155), p_66, p_64, p_66, l_146), (*l_131), p_65);
                        (*l_127) = __builtin_ia32_crc32qi(((((int16_t)(~p_64) - (int16_t)0x7B1A) >= p_66) || ((0x70AB7136 | ((uint8_t)(l_146 || (p_66 < ((*p_65) ^ (((uint8_t)((int8_t)(((p_64 == (p_64 == (*l_131))) != l_146) <= 3U) % (int8_t)0x75) % (uint8_t)l_155) > l_103.f3)))) % (uint8_t)p_66)) || l_165)), (***l_125));
                    }
                }
            }
            else
            { /* block id: 81 */
                int32_t l_168 = (-1);
                int32_t ***l_169 = &l_126;
                struct S0 l_174 = {1,0x9A6D,0x1B0195B8,0U};
                (*l_127) = ((uint16_t)p_64 + (uint16_t)(*l_131));
                if ((*p_65))
                { /* block id: 83 */
                    struct S0 *l_173 = &l_103;
                    (**l_169) = func_67((l_168 || (&l_130 == l_169)), (***l_169), l_145, (0U == __builtin_ia32_crc32qi(p_66, ((int32_t)0xFA26FBF5 + (int32_t)l_103.f1))), p_65);
                    (*l_173) = l_172;
                    (**l_126) = 0x5F053F68;
                    (*l_173) = l_174;
                }
                else
                { /* block id: 88 */
                    int32_t *l_175 = &l_128;
                    (*l_169) = &p_65;
                    (**l_129) = l_175;
                }
                if (((int32_t)(__builtin_popcountll(p_66) <= ((int16_t)(((uint16_t)p_66 << (uint16_t)14) || (*l_131)) << (int16_t)9)) + (int32_t)(((uint32_t)((***l_169) && (*p_65)) + (uint32_t)(p_64 < (l_184 != (void*)0))) >= p_64)))
                { /* block id: 92 */
                    int8_t l_188 = (-2);
                    struct S0 *l_190 = &l_174;
                    int16_t l_215 = 0x6EFE;
                    (*p_65) = 1;
                    if (((int8_t)(l_188 > (~(l_190 == (void*)0))) >> (int8_t)(**l_130)))
                    { /* block id: 94 */
                        struct S0 l_216 = {1,0U,0x9D71703F,0x35};
                        (**l_169) = func_67(((int32_t)((int16_t)0x9985 >> (int16_t)14) - (int32_t)((uint8_t)((p_66 == p_64) > (**l_130)) - (uint8_t)0x15)), ((uint16_t)((void*)0 == &p_65) << (uint16_t)(__builtin_ctz((__builtin_bswap64(((int8_t)p_66 >> (int8_t)((uint16_t)(((uint8_t)p_64 << (uint8_t)p_66) || l_188) % (uint16_t)0x96E2))) <= p_64)) <= 0x40)), l_145, p_66, (**l_169));
                        (**l_125) = p_65;
                        (**l_169) = func_67(((((int8_t)(((0x2775 & (!0xBB)) ^ (*l_131)) >= (((uint32_t)__builtin_parityll(((**l_126) | (((uint16_t)0x6FE5 >> (uint16_t)6) > (((uint16_t)(**l_130) >> (uint16_t)5) <= l_188)))) % (uint32_t)(-(int8_t)((void*)0 == (*l_169)))) & (***l_125))) % (int8_t)p_66) && 0) >= p_66), l_215, l_216, l_188, p_65);
                    }
                    else
                    { /* block id: 98 */
                        int32_t l_237 = (-8);
                        (**l_129) = p_65;
                        l_145.f0 = ((((uint8_t)((int8_t)((uint32_t)((*p_65) <= ((int16_t)(((p_66 <= p_66) <= ((uint16_t)((***l_169) && (-(uint32_t)((int16_t)((uint8_t)((int8_t)(((int16_t)p_64 % (int16_t)(-(int16_t)(0xEE14 > p_66))) <= l_237) + (int8_t)(((0x50E43E29 > (-10)) != (-1)) ^ 255U)) << (uint8_t)(*l_127)) - (int16_t)p_64))) << (uint16_t)7)) ^ 1U) << (int16_t)l_237)) % (uint32_t)p_66) + (int8_t)(**l_126)) + (uint8_t)p_64) ^ (*p_65)) <= 1);
                    }
                    l_239 = l_238;
                }
                else
                { /* block id: 103 */
                    const struct S0 l_243 = {0,0xFCB1,4294967295U,251U};
                    (**l_169) = func_67(__builtin_ctzl((***l_129)), (***l_169), l_172, (!p_66), p_65);
                    (**l_239) = l_242;
                    (**l_239) = l_243;
                }
            }
            for (l_103.f3 = 0; (l_103.f3 == 49); l_103.f3 += 1)
            { /* block id: 111 */
                int32_t *l_248 = &l_128;
                if ((***l_125))
                { /* block id: 112 */
                    (*l_127) = ((void*)0 == l_246);
                }
                else
                { /* block id: 114 */
                    int32_t *l_249 = (void*)0;
                    return l_249;
                }
            }
        }
        else
        { /* block id: 118 */
            struct S0 l_250 = {-1,0x961E,8U,0x51};
            int32_t *l_253 = &l_128;
            (*l_126) = func_67(p_64, p_66, func_76(l_250, p_66, p_64, p_64, ((((void*)0 == (*l_184)) || ((uint8_t)p_64 % (uint8_t)p_66)) != 9U)), p_64, l_253);
            (*l_126) = p_65;
            (**l_239) = (**l_239);
        }
        if (((-1) <= ((uint8_t)(p_66 ^ (((uint32_t)((((int16_t)(0x62 & ((int8_t)((uint16_t)p_66 << (uint16_t)11) << (int8_t)4)) << (int16_t)7) & p_64) & (*l_127)) + (uint32_t)((uint16_t)0x29F8 >> (uint16_t)((uint16_t)p_66 << (uint16_t)(**l_126)))) != 0xCBB092B1)) >> (uint8_t)4)))
        { /* block id: 123 */
            uint32_t l_269 = 0xC3AFF28C;
            int32_t ***l_273 = &l_126;
            (*l_240) = func_76(func_76(l_268, (*l_127), (l_269 != ((int16_t)(((0x8D != (**l_126)) == (l_269 & 0x1AB1)) > (p_64 | (!((__builtin_bswap64(p_66) < 0x6C10) == 0x8783DA1C)))) << (int16_t)3)), p_64, p_66), (*l_127), p_66, p_66, p_64);
            (***l_273) = (l_273 != (*l_184));
        }
        else
        { /* block id: 126 */
            uint16_t l_278 = 0x411A;
            struct S0 *l_279 = &l_268;
            struct S0 *l_282 = (void*)0;
            int8_t l_285 = (-1);
            int32_t *l_297 = &l_128;
            int32_t *l_307 = &l_128;
            int32_t *l_310 = &l_128;
            int32_t *l_321 = &l_309;
            int32_t *l_322 = &l_128;
            int32_t *l_326 = &l_309;
            int32_t *l_331 = &l_309;
            (*l_126) = func_67((((uint8_t)(***l_125) - (uint8_t)((int8_t)l_278 + (int8_t)(l_279 == (void*)0))) >= (p_64 <= (((((int8_t)(***l_125) % (int8_t)(-1)) | (p_66 ^ (***l_125))) || (*p_65)) < 6))), p_66, (*l_240), l_278, (**l_125));
            (*l_240) = func_76(func_76((*l_240), (***l_125), (((void*)0 == l_282) == (((int32_t)(-10) + (int32_t)p_64) == 5U)), (p_64 <= (l_285 != (*l_127))), p_64), p_64, p_66, (**l_126), (**l_126));
            if (((__builtin_ffsll((~l_285)) || p_66) != ((*p_65) <= ((p_66 == ((*l_125) != (void*)0)) | ((l_285 <= __builtin_ffsll((**l_126))) <= 255U)))))
            { /* block id: 129 */
                struct S0 *l_291 = &l_103;
                int32_t l_292 = 0x6536C698;
                int32_t *l_314 = &l_309;
                int32_t *l_325 = &l_309;
                int32_t *l_329 = &l_128;
                if ((((int32_t)(l_279 != l_291) - (int32_t)0xF636BEBD) & l_292))
                { /* block id: 130 */
                    int8_t l_301 = 0x74;
                    int32_t *l_306 = &l_292;
                    int32_t *l_312 = &l_292;
                    int32_t *l_316 = (void*)0;
                    for (l_242.f3 = 0; (l_242.f3 < 3); l_242.f3 += 8)
                    { /* block id: 133 */
                        int32_t *l_298 = &l_292;
                        (**l_125) = func_67(((int8_t)((p_64 <= 1U) > ((l_297 == l_298) && ((uint16_t)(l_292 || (0x8D8232C7 && l_301)) - (uint16_t)5U))) % (int8_t)(((65535U < 0xF266) || (*p_65)) | 0U)), p_64, (*l_291), p_66, p_65);
                    }
                    (*p_65) = ((uint8_t)0xE3 % (uint8_t)(l_301 | ((uint32_t)4U + (uint32_t)(p_64 & ((void*)0 != (*l_184))))));
                    return l_316;
                }
                else
                { /* block id: 138 */
                    int32_t l_317 = 4;
                    struct S0 l_318 = {0,0x2F55,0xAFC07765,0U};
                    int32_t *l_324 = &l_317;
                    int32_t *l_328 = &l_317;
                    int32_t *l_330 = &l_128;
                    (**l_125) = (void*)0;
                    p_65 = func_67((*l_297), l_317, func_76(func_76(l_318, ((uint8_t)((*l_310) != p_64) << (uint8_t)4), p_64, p_66, (*l_307)), p_66, p_66, p_66, p_64), (*l_310), &l_292);
                    return l_332;
                }
            }
            else
            { /* block id: 143 */
                struct S0 **l_334 = (void*)0;
                struct S0 **l_335 = &l_333;
                (*l_335) = l_333;
                for (l_242.f3 = 0; (l_242.f3 == 60); l_242.f3 += 3)
                { /* block id: 147 */
                    (**l_125) = l_321;
                }
            }
            (*l_323) = 6;
        }
    }
    for (p_64 = (-30); (p_64 > 13); p_64++)
    { /* block id: 156 */
        int16_t l_340 = 0x0086;
        int32_t *l_341 = &l_309;
        struct S0 l_342 = {-1,0x3111,0x8A623C68,0xB7};
        int32_t *l_346 = &l_309;
        int32_t **l_347 = &l_346;
        (*l_347) = func_67(l_340, ((l_340 && 0xC9) & ((l_341 != (void*)0) | (-1))), func_76(l_342, p_64, __builtin_ffsl(((int8_t)l_345 % (int8_t)p_64)), p_64, (*l_341)), (*l_341), l_346);
        (*l_347) = (void*)0;
        for (l_103.f1 = 0; (l_103.f1 != 42); l_103.f1++)
        { /* block id: 161 */
            int32_t * const l_350 = &l_309;
            int32_t **l_351 = (void*)0;
            int32_t **l_352 = &l_346;
            (*l_352) = l_350;
            (*l_308) = (*l_327);
        }
    }
    return l_359;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_73 l_369 l_361 l_418 l_441
 */
inline static int32_t * func_67(uint32_t  p_68, uint16_t  p_69, struct S0  p_70, uint8_t  p_71, int32_t * p_72)
{ /* block id: 45 */
    int32_t *l_99 = (void*)0;
    int32_t **l_98 = &l_99;
    struct S0 l_100 = {0,0x461D,1U,1U};
    for (p_70.f2 = 0; (p_70.f2 != 15); p_70.f2 += 1)
    { /* block id: 48 */
        int32_t **l_94 = (void*)0;
        int32_t l_97 = 0x3E35F201;
        int32_t *l_96 = &l_97;
        int32_t **l_95 = &l_96;
        (*l_95) = (void*)0;
        return p_72;
    }
    if (((void*)0 == l_98))
    { /* block id: 52 */
        struct S0 *l_101 = &l_100;
        (*l_101) = l_100;
    }
    else
    { /* block id: 54 */
        int32_t l_102 = 1;
        (*p_72) = l_102;
        (*l_98) = (void*)0;
    }
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_76(struct S0  p_77, uint8_t  p_78, uint16_t  p_79, uint32_t  p_80, uint32_t  p_81)
{ /* block id: 40 */
    int32_t l_90 = 1;
    int32_t *l_89 = &l_90;
    int32_t **l_91 = &l_89;
    (*l_89) = ((int16_t)(0x8543 ^ p_77.f3) - (int16_t)p_79);
    (*l_91) = &l_90;
    (**l_91) = p_79;
    return p_77;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 176
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 37
breakdown:
   indirect level: 0, occurrence: 20
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 30
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 5

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 183
   depth: 2, occurrence: 26
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
   depth: 6, occurrence: 5
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 5
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 6
   depth: 18, occurrence: 4
   depth: 19, occurrence: 2
   depth: 21, occurrence: 4
   depth: 22, occurrence: 1
   depth: 25, occurrence: 2

XXX total number of pointers: 189

XXX times a variable address is taken: 170
XXX times a pointer is dereferenced on RHS: 144
breakdown:
   depth: 1, occurrence: 108
   depth: 2, occurrence: 20
   depth: 3, occurrence: 15
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 89
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 801

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1307
   level: 2, occurrence: 417
   level: 3, occurrence: 181
   level: 4, occurrence: 21
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 68
XXX number of pointers point to scalars: 107
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 25.9
XXX average alias set size: 1.29

XXX times a non-volatile is read: 791
XXX times a non-volatile is write: 234
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 158
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 33
   depth: 2, occurrence: 35
   depth: 3, occurrence: 17
   depth: 4, occurrence: 31
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 11
XXX percentage an existing variable is used: 89
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

