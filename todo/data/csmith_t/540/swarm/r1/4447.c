/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2602604766
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_31(void);
static int32_t  func_38(int32_t  p_39, int16_t  p_40, uint32_t  p_41, int32_t  p_42);
static int32_t  func_55(uint32_t  p_56, const uint32_t  p_57, uint32_t  p_58);
inline static int16_t  func_72(int32_t  p_73, int32_t *** p_74, int32_t * p_75);
static int32_t * func_95(uint32_t  p_96, float  p_97, int32_t * p_98, const float  p_99, int8_t  p_100);
static float  func_106(const uint32_t  p_107, int8_t  p_108, const int32_t * p_109);
inline static const uint32_t  func_125(int32_t * p_126);
inline static int32_t * func_127(uint32_t  p_128, int32_t *** p_129, const uint16_t  p_130, uint32_t  p_131);
static int32_t  func_143(uint32_t  p_144);
static int32_t  func_146(uint16_t  p_147, int8_t  p_148, uint16_t  p_149);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_37 = 0x167C28CAL;
    int32_t l_462 = 0x3AFE4F73L;
    int32_t *l_461 = &l_462;
    const int8_t l_463 = 0x94L;
    (*l_461) = (0x1B583DC0L > (~((uint32_t)((int16_t)(l_37 && ((((func_38((l_37 < (l_37 && (-1L))), l_37, l_37, l_37) <= l_37) & l_37) != l_37) & l_37)) >> (int16_t)l_37) + (uint32_t)l_37)));
    (*l_461) = ((*l_461) < (*l_461));
    (*l_461) = (*l_461);
    return l_463;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_38(int32_t  p_39, int16_t  p_40, uint32_t  p_41, int32_t  p_42)
{ /* block id: 37 */
    uint32_t l_43 = 0x7BA3F300L;
    int32_t l_87 = (-4L);
    int32_t *l_86 = &l_87;
    int32_t **l_85 = &l_86;
    int32_t ***l_84 = &l_85;
    const int8_t l_110 = 0x3FL;
    const float l_429 = 0x7.1046A6p-20;
    uint16_t l_454 = 0x0006L;
    int32_t l_460 = 0L;
    if (l_43)
    { /* block id: 38 */
        uint32_t l_50 = 0UL;
        int32_t l_63 = 1L;
        int32_t *l_62 = &l_63;
        (*l_62) = ((0L < ((((float)(((float)(((int16_t)((__builtin_popcount((l_50 || ((int16_t)l_43 * (int16_t)l_50))) <= 0L) && p_41) << (int16_t)14) , ((-(float)(-(float)p_40)) < (func_55((((p_41 , l_43) ^ p_39) != p_40), p_39, l_43) , l_50))) + (float)0x4.22CFB6p-78) >= 0xB.F9E84Ep-58) + (float)l_50) , 0L) , l_43)) | l_43);
    }
    else
    { /* block id: 48 */
        int32_t **l_64 = (void*)0;
        int32_t ***l_65 = &l_64;
        int32_t l_449 = 6L;
        const int32_t l_459 = 0L;
        (*l_65) = l_64;
        if (((((uint32_t)((uint16_t)p_41 - (uint16_t)(-1L)) - (uint32_t)((int16_t)func_72(((int32_t)func_55(l_43, ((0UL <= (((uint16_t)((int16_t)(0L && (((p_40 >= (p_41 < (((uint16_t)((void*)0 == &p_42) * (uint16_t)p_41) <= 65527UL))) >= p_39) , 0x8E8BF325L)) - (int16_t)p_41) << (uint16_t)p_41) , p_39)) > (-1L)), l_43) + (int32_t)0L), l_84, (*l_85)) * (int16_t)0xF04CL)) && p_42) == 0x2BF2L))
        { /* block id: 53 */
            int8_t l_93 = 0xA0L;
            int32_t l_94 = 1L;
            int8_t l_424 = 0xD0L;
            l_94 = (!((0x8C81L != ((*l_86) , l_93)) , (-0x5.Dp-1)));
            (*l_85) = func_95(l_94, ((float)(-(float)p_39) - (float)0x1.9p+1), (((uint16_t)(func_106(l_110, p_42, (**l_84)) , l_424) >> (uint16_t)((int16_t)(((float)(l_429 < 0xE.05815Cp+55) + (float)0x1.0p+1) , p_42) << (int16_t)p_42)) , (void*)0), (**l_85), (*l_86));
            /* statement id: 225 */
            assert (l_86 == 0);
        }
        else
        { /* block id: 226 */
            int32_t ****l_434 = &l_65;
            int32_t l_448 = (-1L);
            (*l_86) = (l_434 == (((uint32_t)p_40 - (uint32_t)((**l_85) < ((((float)(-0x1.7p+1) * (float)(p_39 <= p_41)) , (!4294967295UL)) >= ((((int16_t)((p_39 <= (((float)((float)(((int16_t)p_40 * (int16_t)0x0594L) , (*l_86)) - (float)p_40) - (float)(-0x1.Dp+1)) , p_39)) && l_448) >> (int16_t)l_449) , p_42) != p_39)))) , &l_84));
            for (p_39 = 19; (p_39 != 19); p_39 += 3)
            { /* block id: 230 */
                int8_t l_452 = 0x8BL;
                float l_458 = 0x8.722CBCp+28;
                float *l_457 = &l_458;
                (*l_457) = (p_39 , (l_452 < (((((__builtin_popcountl(p_42) , &l_85) == &l_85) <= p_39) > (-(float)((l_454 != ((float)((((0x3E42L != (-1L)) & p_40) & 4L) , 0x6.9p-1) - (float)0x8.EF2588p-78)) <= p_39))) == p_42)));
                if (p_42)
                    break;
            }
            l_460 = l_459;
        }
        /* facts after branching */
        assert (l_86 == &l_87 || l_86 == 0);
        (*l_85) = &p_42;
        /* statement id: 236 */
        assert (l_86 == &p_42);
        return p_39;
    }
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_55(uint32_t  p_56, const uint32_t  p_57, uint32_t  p_58)
{ /* block id: 39 */
    uint16_t l_59 = 65530UL;
    l_59 = 0xCC7BC501L;
    for (p_58 = 0; (p_58 != 15); p_58++)
    { /* block id: 43 */
        if (l_59)
            break;
    }
    return l_59;
}


/* ------------------------------------------ */
/* 
 * reads : l_139 l_140
 * writes:
 */
inline static int16_t  func_72(int32_t  p_73, int32_t *** p_74, int32_t * p_75)
{ /* block id: 50 */
    const int32_t l_90 = 2L;
    (***p_74) = ((uint16_t)l_90 * (uint16_t)(-(int16_t)0xEB6BL));
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_95(uint32_t  p_96, float  p_97, int32_t * p_98, const float  p_99, int8_t  p_100)
{ /* block id: 222 */
    int32_t l_432 = (-7L);
    int32_t *l_431 = &l_432;
    int32_t **l_430 = &l_431;
    int32_t *l_433 = &l_432;
    (*l_430) = p_98;
    /* statement id: 223 */
    assert (l_431 == 0);
    return p_98;
    /* statement id: 224 */
    //assert (func_95_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_106(const uint32_t  p_107, int8_t  p_108, const int32_t * p_109)
{ /* block id: 55 */
    int16_t l_113 = 3L;
    uint16_t l_137 = 0UL;
    int32_t l_141 = 0x022C1C42L;
    int32_t *l_140 = &l_141;
    int32_t **l_139 = &l_140;
    int32_t ***l_138 = &l_139;
    int32_t *l_405 = &l_141;
    const uint32_t l_423 = 0UL;
    (*l_405) = (((((uint16_t)l_113 * (uint16_t)(func_55(l_113, p_107, ((&p_109 == (void*)0) , ((int16_t)((int32_t)(((int32_t)(~(((uint16_t)(p_107 , ((int32_t)(*p_109) + (int32_t)func_125(func_127(((uint16_t)((int16_t)(((-(int32_t)((void*)0 != p_109)) ^ l_113) != 0x5AD8L) * (int16_t)l_137) >> (uint16_t)l_137), l_138, (**l_139), (*l_140))))) + (uint16_t)p_107) & 0xD9598FA4L)) % (int32_t)4294967288UL) == 0xCA4ECB62L) + (int32_t)p_108) >> (int16_t)p_108))) , p_108)) < p_108) >= 65527UL) < (*p_109));
    /* statement id: 212 */
    //assert (l_140 == &l_141 || l_140 == dangling);
    for (l_141 = 0; (l_141 > 21); l_141 += 4)
    { /* block id: 215 */
        float l_409 = 0x1.2p+1;
        uint32_t l_410 = 0x6D67A0BCL;
        float *l_411 = (void*)0;
        float *l_412 = &l_409;
        int32_t **l_417 = &l_405;
        int32_t **l_418 = &l_140;
        (*l_412) = (-(float)__builtin_ffsl(l_410));
        (*l_418) = p_109;
        /* statement id: 217 */
        //assert (l_140 == &l_87);
        (*l_412) = ((float)(((float)func_125((*l_139)) * (float)l_423) > (**l_417)) - (float)p_108);
        (*l_418) = (*l_417);
        /* statement id: 219 */
        assert (l_140 == &l_141);
    }
    return p_107;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_125(int32_t * p_126)
{ /* block id: 204 */
    int32_t l_386 = 5L;
    int32_t l_391 = 0x1D8D492CL;
    float l_399 = 0xA.58BB86p+23;
    int32_t *l_403 = &l_386;
    int32_t * const *l_402 = &l_403;
    int32_t **l_404 = &l_403;
    for (l_386 = 0; (l_386 > 14); ++l_386)
    { /* block id: 207 */
        float l_389 = 0xF.9B9C6Cp+98;
        int32_t l_390 = 0x52649113L;
        l_391 = l_390;
    }
    (*l_404) = p_126;
    /* statement id: 210 */
    //assert (l_403 == 0 || l_403 == &l_87);
    return l_391;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_127(uint32_t  p_128, int32_t *** p_129, const uint16_t  p_130, uint32_t  p_131)
{ /* block id: 56 */
    int8_t l_142 = (-5L);
    int32_t l_165 = 0xDBC6B2EDL;
    int32_t *l_164 = &l_165;
    int32_t **l_163 = &l_164;
    int8_t l_172 = 0x76L;
    uint32_t l_235 = 0UL;
    int32_t ***l_241 = &l_163;
    int32_t ****l_240 = &l_241;
    uint32_t l_263 = 18446744073709551615UL;
    int32_t *l_273 = (void*)0;
    int32_t *l_322 = &l_165;
    int32_t *l_325 = (void*)0;
    int32_t *l_378 = &l_165;
    int32_t *l_379 = &l_165;
    int32_t *l_380 = &l_165;
    int32_t *l_381 = &l_165;
    int32_t *l_382 = &l_165;
    int32_t *l_383 = &l_165;
    int32_t *l_384 = &l_165;
    int32_t *l_385 = (void*)0;
    if ((((l_142 ^ (func_143(l_142) < (__builtin_popcountl(func_55(l_142, ((int16_t)l_142 << (int16_t)5), (((int16_t)(((l_163 != (*p_129)) , (*l_164)) >= (((int16_t)((((((uint16_t)((uint16_t)((((((*l_164) <= (***p_129)) , p_130) | (**l_163)) >= 0x5D0453C8L) != (***p_129)) >> (uint16_t)(**l_163)) % (uint16_t)l_172) || p_131) , 0xBE29DAAEL) , (**l_163)) >= 8L) << (int16_t)p_128) & (-1L))) << (int16_t)(**l_163)) > (**l_163)))) | 0L))) , p_130) & (***p_129)))
    { /* block id: 70 */
        int32_t *l_173 = &l_165;
        (**p_129) = l_173;
        /* statement id: 71 */
        //assert (l_140 == &l_165);
        (*l_163) = (**p_129);
        if ((***p_129))
        { /* block id: 73 */
            const uint32_t l_174 = 18446744073709551615UL;
            float l_176 = 0x0.Bp+1;
            float *l_175 = &l_176;
            (*l_164) = l_174;
            (*l_175) = p_128;
        }
        else
        { /* block id: 76 */
            int32_t *l_182 = &l_165;
            if ((p_128 , ((((-5L) && ((uint16_t)p_128 * (uint16_t)(!1UL))) , (((int16_t)p_130 << (int16_t)15) , 0xF1A7L)) != p_130)))
            { /* block id: 77 */
                int32_t *l_183 = (void*)0;
                float l_185 = 0x0.2p-1;
                float *l_184 = &l_185;
                (*l_163) = l_173;
                (*l_184) = (func_72(p_128, p_129, l_182) < ((**p_129) == ((p_128 , p_130) , l_183)));
                for (p_131 = 0; (p_131 < 27); p_131 += 1)
                { /* block id: 82 */
                    int32_t l_192 = (-5L);
                    (*l_182) = (***p_129);
                    for (l_165 = 0; (l_165 <= (-4)); l_165 -= 1)
                    { /* block id: 86 */
                        int32_t l_191 = 1L;
                        int32_t *l_190 = &l_191;
                        (*l_190) = ((void*)0 != (**p_129));
                        (**p_129) = (((void*)0 != (*p_129)) , (**p_129));
                        (*l_184) = l_192;
                    }
                    if ((***p_129))
                        break;
                }
            }
            else
            { /* block id: 93 */
                uint16_t l_198 = 0x52ECL;
                int32_t ***l_199 = &l_163;
                uint32_t l_212 = 4294967286UL;
                int32_t l_214 = 4L;
                for (l_165 = (-29); (l_165 != 3); l_165++)
                { /* block id: 96 */
                    int32_t l_197 = 0x9BDCB58CL;
                    float l_201 = 0x0.5p-1;
                    float *l_200 = &l_201;
                    (**p_129) = l_182;
                    (*l_200) = ((float)(p_131 > p_128) * (float)0x1.4p-1);
                    if (((uint32_t)((((*l_173) , ((uint16_t)((int32_t)(((void*)0 != p_129) ^ (((uint16_t)(0x9456L || ((***p_129) || ((!((!p_130) != ((p_128 , l_197) <= ((void*)0 != l_199)))) , l_212))) % (uint16_t)0x63D9L) < (***p_129))) + (int32_t)(*l_182)) * (uint16_t)0x463FL)) & 0L) && 0x5ECA5D8FL) % (uint32_t)0x70F34082L))
                    { /* block id: 99 */
                        int32_t *l_213 = (void*)0;
                        l_214 = 0x4C73A16DL;
                    }
                    else
                    { /* block id: 101 */
                        int8_t l_220 = 7L;
                        l_220 = ((float)((!func_146(((uint32_t)p_130 + (uint32_t)(***l_199)), (*l_164), (*l_173))) == (__builtin_ctz((*l_173)) >= l_197)) + (float)(***l_199));
                        (*l_200) = (**l_163);
                    }
                }
            }
        }
    }
    else
    { /* block id: 108 */
        uint16_t l_227 = 65535UL;
        int32_t *l_231 = &l_165;
        int32_t ***l_232 = &l_163;
        (*l_231) = ((int16_t)(**l_163) - (int16_t)((int16_t)(((uint16_t)(*l_164) + (uint16_t)(l_227 , (((uint16_t)(((((!((void*)0 == p_129)) | ((((func_143(l_227) ^ (***l_232)) && 0x25DAL) | (-2L)) > (***l_232))) , p_128) == 4294967288UL) , p_131) >> (uint16_t)9) != 6UL))) && p_130) * (int16_t)(*l_231)));
    }
    /* facts after branching */
    //assert (l_140 == &l_141 || l_140 == &l_165);
    if ((p_130 || (**l_163)))
    { /* block id: 111 */
        int32_t *l_238 = &l_165;
        int32_t *l_272 = &l_165;
        int32_t ***l_293 = &l_163;
        for (l_142 = (-4); (l_142 > 22); ++l_142)
        { /* block id: 114 */
            float l_237 = 0x9.49A4E4p+17;
            int32_t *l_239 = &l_165;
            int32_t *l_269 = &l_165;
            const uint32_t l_284 = 4294967289UL;
        }
        (*l_238) = (((((((int16_t)((int16_t)((((int32_t)func_143(p_131) + (int32_t)4294967295UL) & ((int32_t)__builtin_parityll((*l_238)) - (int32_t)p_128)) ^ ((*l_238) || (l_238 == (void*)0))) + (int16_t)p_130) * (int16_t)p_130) , (*l_240)) == l_293) && p_130) , (***p_129)) , 1L);
        (**p_129) = (**l_241);
        /* statement id: 147 */
        //assert (l_140 == &l_165);
    }
    else
    { /* block id: 148 */
        uint32_t l_296 = 1UL;
        int32_t l_304 = 0x88B2F59EL;
        int32_t * const * const **l_305 = (void*)0;
        for (p_128 = 0; (p_128 <= 10); p_128++)
        { /* block id: 151 */
            int8_t l_303 = (-1L);
            int32_t *l_319 = &l_165;
            int32_t * const *l_360 = &l_164;
            int32_t * const **l_359 = &l_360;
            int32_t * const ***l_358 = &l_359;
            int32_t * const ****l_357 = &l_358;
        }
        for (p_131 = 28; (p_131 >= 31); p_131 += 6)
        { /* block id: 196 */
            if ((***p_129))
                break;
            (*l_163) = (**p_129);
        }
        /* facts after for loop */
        //assert (l_164 == &l_141 || l_164 == &l_165);
    }
    /* facts after branching */
    //assert (l_164 == &l_141 || l_164 == &l_165);
    (*l_322) = (*l_322);
    (**p_129) = (*l_163);
    return l_385;
    /* statement id: 203 */
    //assert (l_140 == &l_141 || l_140 == dangling);
    //assert (func_127_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_143(uint32_t  p_144)
{ /* block id: 57 */
    int32_t l_145 = (-1L);
    int32_t **l_155 = (void*)0;
    float l_158 = 0x0.1p+1;
    if ((__builtin_parityl((1UL && l_145)) , (func_146((p_144 >= (p_144 , p_144)), l_145, l_145) & l_145)))
    { /* block id: 64 */
        int32_t ***l_156 = &l_155;
        (*l_156) = l_155;
    }
    else
    { /* block id: 66 */
        int8_t l_157 = 0x5AL;
        return l_157;
    }
    return p_144;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_146(uint16_t  p_147, int8_t  p_148, uint16_t  p_149)
{ /* block id: 58 */
    int32_t l_151 = 0x11E40316L;
    int32_t *l_150 = &l_151;
    int32_t **l_152 = &l_150;
    int32_t *l_153 = &l_151;
    int16_t l_154 = 0x81D3L;
    (*l_152) = l_150;
    (**l_152) = 0x8.3BAB64p-58;
    (*l_152) = l_153;
    (*l_152) = (*l_152);
    return l_154;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 116
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 15
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 89

XXX times a variable address is taken: 84
XXX times a pointer is dereferenced on RHS: 126
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 32
   depth: 3, occurrence: 30
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 65
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 13
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 531

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 129
   level: 2, occurrence: 59
   level: 3, occurrence: 58
   level: 4, occurrence: 9
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 58
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.5
XXX average alias set size: 1.16

XXX times a non-volatile is read: 686
XXX times a non-volatile is write: 182
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 81
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 22
   depth: 2, occurrence: 10
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 13.6
XXX percentage an existing variable is used: 86.4
********************* end of statistics **********************/

