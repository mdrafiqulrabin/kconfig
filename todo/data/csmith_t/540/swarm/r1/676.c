/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1251493600
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   const int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   const uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static float g_13 = (-0x2.4p+1);
static int16_t g_18 = 0xE2A8;
static union U0 g_85 = {0x48CA1818};
static float g_122 = 0x0.8p+1;
static int32_t *g_123 = &g_85.f3;
static float **g_157 = (void*)0;
static float ***g_156 = &g_157;
static uint32_t g_189 = 4294967294U;
static int32_t g_197 = (-1);
static uint16_t g_210 = 0xC585;
static uint32_t g_372 = 1U;
static int32_t g_395 = 0x8E95D116;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_30(void);
inline static uint16_t  func_47(uint16_t  p_48);
inline static int32_t  func_51(float  p_52, int32_t  p_53);
inline static uint16_t  func_54(uint32_t  p_55, union U0  p_56, uint32_t  p_57);
static union U0  func_61(const union U0  p_62);
inline static union U0  func_63(int16_t  p_64, int32_t  p_65, union U0  p_66, const uint32_t  p_67, int32_t  p_68);
static int32_t  func_69(float  p_70, int32_t  p_71, const uint16_t  p_72, int32_t  p_73);
static uint16_t  func_75(uint32_t  p_76, union U0  p_77, uint32_t  p_78, float  p_79);
inline static int16_t  func_91(uint32_t  p_92, int32_t  p_93, float  p_94, uint32_t  p_95);
static const int16_t  func_101(uint16_t  p_102, uint32_t  p_103, int32_t  p_104, union U0  p_105, const int16_t  p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_13 g_18 g_85 g_85.f0 g_85.f1 g_85.f4 g_85.f2 g_85.f3 g_123 g_210 g_189 g_197 g_372 g_395
 * writes: g_122 g_156 g_85.f3 g_85.f0 g_123 g_189 g_85.f2 g_13 g_197
 */
inline static int32_t  func_30(void)
{ /* block id: 36 */
    float l_37 = 0x3.040C3Fp-9;
    int32_t l_38 = (-1);
    union U0 l_58 = {0U};
    int32_t *l_396 = (void*)0;
    int32_t *l_397 = (void*)0;
    int32_t *l_398 = &g_197;
    int16_t l_410 = (-7);
    int32_t l_419 = 0x69D018CB;
    (*l_398) = (((1 > 0x4D0F) <= (((((((int16_t)((uint16_t)(((int16_t)(0xAE07 > l_38) + (int16_t)(-2)) , 0U) + (uint16_t)__builtin_parity(((uint32_t)0xBF3B8CFF / (uint32_t)((int16_t)((uint16_t)((int32_t)((((func_47(((((uint32_t)(func_51(g_13, ((func_54(__builtin_bswap64(g_18), l_58, g_18) || 65535U) || g_18)) , l_58.f1) % (uint32_t)l_38) == (-2)) <= (-1))) >= g_372) , g_395) == 6) > g_18) / (int32_t)g_395) >> (uint16_t)3) << (int16_t)g_18)))) >> (int16_t)g_210) != g_395) >= (-8)) | l_38) , g_85.f4) & l_58.f3)) || l_58.f1);
    /* statement id: 214 */
        //assert (g_123 == dangling || g_123 == &g_197 || g_123 == 0 || g_123 == &g_85.f3);
    assert (g_156 == 0);
    for (l_58.f3 = 0; (l_58.f3 <= 21); l_58.f3 += 1)
    { /* block id: 217 */
        int32_t **l_401 = (void*)0;
        int32_t **l_402 = (void*)0;
        int32_t **l_403 = &l_397;
        (*l_403) = &g_197;
        /* statement id: 218 */
        assert (l_397 == &g_197);
    }
    /* facts after for loop */
        assert (l_397 == &g_197 || l_397 == 0);
    if ((*l_398))
    { /* block id: 220 */
        float *l_405 = &g_13;
        float **l_404 = &l_405;
        if (((void*)0 == l_404))
        { /* block id: 221 */
            return g_85.f4;
        }
        else
        { /* block id: 223 */
            g_156 = &g_157;
            /* statement id: 224 */
            assert (g_156 == &g_157);
        }
        /* facts after branching */
        assert (g_156 == &g_157);
    }
    else
    { /* block id: 226 */
        int32_t *l_406 = &g_197;
        int32_t **l_407 = &l_396;
        float *l_420 = &l_37;
        (*l_407) = l_406;
        /* statement id: 227 */
        assert (l_396 == &g_197);
        (*l_420) = ((float)(((((g_189 > (l_410 >= ((float)(((float)((&g_157 != (void*)0) , (*l_406)) + (float)((float)((-0x5.8p-1) != (*l_398)) + (float)(*l_398))) != ((float)l_419 / (float)(*l_398))) + (float)(-0x1.Ap+1)))) > (**l_407)) >= (-0x1.Fp+1)) > (-0x1.2p+1)) < (**l_407)) + (float)0x0.8p+1);
        (**l_407) = (((-0x1.Cp+1) <= ((float)((l_406 == l_406) != func_51(((*l_406) , ((float)((float)(&g_123 == &g_123) - (float)__builtin_bswap64(g_85.f4)) - (float)(*l_406))), g_395)) - (float)(**l_407))) != g_85.f1);
        (*l_420) = (-0x1.Dp+1);
    }
    /* facts after branching */
    assert (g_156 == 0 || g_156 == &g_157);
    assert (l_396 == &g_197 || l_396 == 0);
    return g_85.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f1 g_18 g_85.f0 g_85.f3 g_189 g_210 g_13 g_85.f2 g_85.f4 g_123 g_197 g_372
 * writes: g_85.f2 g_13 g_85.f3 g_123 g_197
 */
inline static uint16_t  func_47(uint16_t  p_48)
{ /* block id: 142 */
    float l_256 = 0x7.8814D1p+5;
    float l_257 = 0x1.Fp+1;
    int32_t l_259 = (-9);
    int32_t l_278 = 0x245C51EA;
    int32_t *l_279 = &g_85.f2;
    float *l_281 = &l_256;
    float **l_280 = &l_281;
    int16_t l_321 = 0;
    (*l_279) = (((g_85.f1 >= (~l_259)) || ((uint16_t)(((int16_t)((uint16_t)((uint16_t)l_259 << (uint16_t)((int16_t)(((uint16_t)((int16_t)l_259 % (int16_t)(p_48 || (-10))) >> (uint16_t)((uint32_t)(((l_259 < 0x6.C7BE27p-92) , ((uint32_t)__builtin_parityl(l_278) / (uint32_t)l_259)) && g_85.f0) + (uint32_t)(-1))) || g_85.f3) - (int16_t)p_48)) % (uint16_t)l_259) / (int16_t)1U) ^ g_85.f3) / (uint16_t)0xD190)) , l_278);
    /* statement id: 143 */
    l_280 = l_280;
    if (p_48)
    { /* block id: 145 */
        const union U0 l_282 = {4294967287U};
        const float *l_286 = &l_256;
        const float **l_285 = &l_286;
        const float ***l_284 = &l_285;
        const float ****l_283 = &l_284;
        const int32_t *l_301 = &l_259;
        const int32_t **l_300 = &l_301;
        (*l_300) = ((((func_61(func_61(l_282)) , l_283) == (((uint16_t)((int32_t)((p_48 != (g_210 ^ p_48)) && (!(func_51(((((uint16_t)(((int32_t)(((((uint16_t)l_282.f2 + (uint16_t)p_48) | p_48) ^ p_48) & 0x0B07) / (int32_t)5U) , 0xD18F) << (uint16_t)14) , l_282.f2) <= 0x2.B4D2A8p-40), l_282.f2) ^ p_48))) % (int32_t)(*l_279)) - (uint16_t)1U) , &l_284)) || p_48) , l_286);
        /* statement id: 146 */
        assert (l_301 == &l_256);
    }
    else
    { /* block id: 147 */
        uint32_t l_310 = 7U;
        int32_t *l_317 = &l_259;
        union U0 l_365 = {4294967286U};
        float ***l_390 = (void*)0;
        (*l_279) = ((int16_t)g_85.f2 - (int16_t)((uint16_t)p_48 + (uint16_t)(((uint16_t)func_51(((((((__builtin_clzl(((int16_t)(p_48 == (l_310 , 0x3E86)) >> (int16_t)10)) != 4294967295U) && ((void*)0 == &g_197)) , 0x7C6D6B7A) <= p_48) , p_48) > (-0x7.5p-1)), p_48) + (uint16_t)g_85.f3) , p_48)));
        (*l_281) = (&l_259 != &g_197);
        for (g_85.f3 = 2; (g_85.f3 < 28); g_85.f3++)
        { /* block id: 152 */
            const uint32_t l_322 = 0x9D5596D2;
            int32_t l_350 = (-1);
            for (l_278 = 0; (l_278 > (-21)); l_278 -= 1)
            { /* block id: 155 */
                uint32_t l_320 = 0U;
                int32_t *l_324 = &g_197;
            }
            if ((((&l_280 == &g_157) && g_18) && (p_48 , (*l_279))))
            { /* block id: 179 */
                int32_t **l_340 = (void*)0;
                for (l_321 = 10; (l_321 != 3); l_321 -= 7)
                { /* block id: 182 */
                    const union U0 l_346 = {1U};
                    for (p_48 = 4; (p_48 >= 15); p_48 += 2)
                    { /* block id: 185 */
                        uint32_t l_343 = 1U;
                        (*l_317) = ((uint16_t)p_48 - (uint16_t)(((void*)0 == l_340) , (0xC328457A < (((int32_t)p_48 / (int32_t)l_343) >= __builtin_popcount(((uint32_t)0U / (uint32_t)((((5U >= g_85.f2) , l_346) , g_85.f0) & g_85.f4)))))));
                        return l_343;
                    }
                    return p_48;
                }
                return p_48;
            }
            else
            { /* block id: 192 */
                int32_t *l_347 = &g_85.f3;
                int32_t **l_348 = &g_123;
                (*l_348) = l_347;
                /* statement id: 193 */
                assert (g_123 == &g_85.f3);
                l_350 = (!(*g_123));
            }
            /* facts after branching */
            assert (g_123 == &g_85.f3);
            (*l_317) = (((g_197 <= ((int16_t)(&g_123 == (void*)0) / (int16_t)(*l_279))) , p_48) ^ (-3));
        }
        /* facts after for loop */
        for (p_48 = 17; (p_48 < 55); p_48 += 1)
        { /* block id: 200 */
            int32_t **l_355 = (void*)0;
            float ****l_361 = &g_156;
            int32_t l_393 = 0x32CACBC3;
            l_317 = &g_197;
            /* statement id: 201 */
            assert (l_317 == &g_197);
            if (((*l_279) > ((!((int16_t)((int16_t)(((*l_317) , l_361) == (((g_189 != ((int16_t)(~(p_48 != ((*l_279) | 0xFA6B))) % (int16_t)8)) ^ p_48) , (void*)0)) / (int16_t)1U) << (int16_t)p_48)) , p_48)))
            { /* block id: 202 */
                if (p_48)
                    break;
                (**l_280) = p_48;
            }
            else
            { /* block id: 205 */
                uint32_t l_379 = 1U;
                int32_t **l_394 = &g_123;
                (*l_317) = (((((uint16_t)(((((int16_t)((uint16_t)0x72CE - (uint16_t)(__builtin_ffs(g_197) & g_372)) / (int16_t)((int16_t)(g_85.f2 && (-10)) - (int16_t)(p_48 == p_48))) ^ ((uint16_t)(((((uint16_t)((p_48 <= 0) , g_210) >> (uint16_t)l_379) || (*l_317)) > g_85.f1) && g_85.f0) - (uint16_t)(*l_279))) || p_48) && l_379) / (uint16_t)p_48) , p_48) , p_48) > p_48);
                (*l_281) = (((float)((((float)((__builtin_popcount(((~(((uint16_t)g_85.f3 % (uint16_t)p_48) < 1)) , ((int16_t)((g_85.f0 , l_390) == (void*)0) << (int16_t)g_189))) , 0x8.BAE0D6p-56) > p_48) - (float)0xC.BCCD2Fp+19) == 0x1.4p+1) == l_379) / (float)0x2.BD1F37p+39) <= (-0x8.0p+1));
                (*l_317) = (((p_48 ^ (-4)) <= g_372) < (((float)0x1.Bp-1 - (float)l_393) , (g_372 == (-1))));
                (*l_394) = &l_259;
                /* statement id: 209 */
                assert (g_123 == &l_259);
            }
        }
        /* facts after for loop */
        assert (g_123 == &l_259 || g_123 == &g_197 || g_123 == 0 || g_123 == &g_85.f3);
        assert (l_317 == &g_197 || l_317 == &l_259);
    }
    /* facts after branching */
    assert (g_123 == &l_259 || g_123 == &g_197 || g_123 == 0 || g_123 == &g_85.f3);
    return g_85.f4;
    /* statement id: 213 */
    //assert (g_123 == dangling || g_123 == &g_197 || g_123 == 0 || g_123 == &g_85.f3);
}


/* ------------------------------------------ */
/* 
 * reads : g_13
 * writes: g_13
 */
inline static int32_t  func_51(float  p_52, int32_t  p_53)
{ /* block id: 138 */
    float * const l_253 = &g_13;
    int16_t l_254 = 1;
    int32_t *l_255 = &g_85.f3;
    (*l_253) = ((p_53 < ((-(uint16_t)p_53) >= (__builtin_clzl(p_53) == (p_53 & ((void*)0 == l_253))))) , l_254);
    l_255 = l_253;
    /* statement id: 140 */
    assert (l_255 == &g_13);
    return (*l_255);
}


/* ------------------------------------------ */
/* 
 * reads : g_18 g_13 g_85 g_85.f0 g_85.f1 g_85.f4 g_85.f2 g_85.f3 g_123 g_210 g_189
 * writes: g_122 g_156 g_85.f3 g_85.f0 g_123 g_189 g_85.f2
 */
inline static uint16_t  func_54(uint32_t  p_55, union U0  p_56, uint32_t  p_57)
{ /* block id: 37 */
    int32_t l_74 = 9;
    union U0 l_227 = {0x75CB63E7};
    float *l_249 = &g_122;
    (*l_249) = ((0x7.9515EDp+53 >= ((float)p_56.f1 - (float)__builtin_ctzll((func_61(func_63(g_18, p_56.f4, (func_69(g_13, (((l_74 && 0xEB2C) >= func_75(((int16_t)((uint16_t)__builtin_ctzl((l_74 > (__builtin_bswap32((__builtin_clz(((~5) , 0x0ED6D230)) , g_18)) < g_18))) + (uint16_t)p_55) << (int16_t)g_18), g_85, l_74, g_85.f0)) > p_56.f1), p_56.f2, l_74) , l_227), p_55, g_210)) , 0x1ADA6F621B4F9A3ELL)))) <= g_18);
    /* statement id: 136 */
        assert (g_123 == &g_197 || g_123 == 0 || g_123 == &g_85.f3);
    assert (g_156 == 0);
    return l_227.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f0 g_189
 * writes:
 */
static union U0  func_61(const union U0  p_62)
{ /* block id: 132 */
    int32_t l_233 = 0xF59071E4;
    uint32_t l_240 = 4294967287U;
    float l_241 = (-0x1.7p-1);
    int32_t *l_245 = (void*)0;
    int32_t *l_246 = (void*)0;
    float *l_247 = &l_241;
    union U0 l_248 = {5U};
    l_233 = ((__builtin_popcount((-(uint32_t)g_85.f0)) < l_240) > l_240);
    (*l_247) = g_189;
    return l_248;
    /* statement id: 135 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_210 g_85
 * writes: g_156
 */
inline static union U0  func_63(int16_t  p_64, int32_t  p_65, union U0  p_66, const uint32_t  p_67, int32_t  p_68)
{ /* block id: 127 */
    float ****l_228 = &g_156;
    int32_t *l_229 = (void*)0;
    int32_t **l_230 = (void*)0;
    int32_t **l_231 = &l_229;
    (*l_228) = (((g_210 & p_66.f3) <= 0x13BC2572) , (void*)0);
    /* statement id: 128 */
    assert (g_156 == 0);
    (*l_231) = l_229;
    (*l_231) = &g_197;
    /* statement id: 130 */
    assert (l_229 == &g_197);
    return g_85;
    /* statement id: 131 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_85.f0 g_85.f2 g_123
 * writes: g_85.f0 g_123 g_85.f3 g_189 g_122 g_85.f2
 */
static int32_t  func_69(float  p_70, int32_t  p_71, const uint16_t  p_72, int32_t  p_73)
{ /* block id: 83 */
    int16_t l_212 = 0;
    for (p_71 = (-8); (p_71 >= (-20)); p_71 -= 1)
    { /* block id: 86 */
        uint32_t l_198 = 0xD40478C9;
        int16_t l_221 = 0x8D72;
        if ((g_85.f0 , 0xEE9290BC))
        { /* block id: 87 */
            uint32_t l_182 = 0xE2574B05;
            for (g_85.f0 = 0; (g_85.f0 < 9); g_85.f0 += 1)
            { /* block id: 90 */
                int32_t **l_181 = &g_123;
                (*l_181) = (void*)0;
                /* statement id: 91 */
                assert (g_123 == 0);
                if (l_182)
                    continue;
            }
            /* facts after for loop */
        }
        else
        { /* block id: 94 */
            uint32_t l_211 = 4294967286U;
            int32_t **l_220 = &g_123;
            int32_t *l_226 = &g_85.f2;
            for (g_85.f3 = 0; (g_85.f3 <= (-30)); g_85.f3 -= 1)
            { /* block id: 97 */
                int32_t *l_192 = &g_85.f3;
                union U0 l_202 = {1U};
                float *l_218 = (void*)0;
                float *l_219 = &g_122;
                for (p_73 = 0; (p_73 >= 5); p_73 += 1)
                { /* block id: 100 */
                    int32_t *l_195 = (void*)0;
                    union U0 l_213 = {2U};
                    g_189 = ((int16_t)(p_71 < (-1)) / (int16_t)g_85.f2);
                }
                (*l_219) = (+p_71);
                if (p_71)
                    continue;
            }
            (*l_220) = &p_71;
            /* statement id: 121 */
            assert (g_123 == &p_71);
            (*l_226) = ((l_221 & ((((uint32_t)__builtin_ctzl((**l_220)) + (uint32_t)(*g_123)) , ((l_212 == p_71) > ((float)p_70 + (float)(p_73 <= (**l_220))))) , 65528U)) | p_73);
            /* statement id: 122 */
            (*l_220) = &g_197;
            /* statement id: 123 */
            assert (g_123 == &g_197);
        }
        /* facts after branching */
    }
    /* facts after for loop */
    assert (g_123 == &g_197 || g_123 == 0 || g_123 == &g_85.f3);
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f0 g_85.f1 g_18 g_85.f4 g_85 g_85.f2 g_85.f3 g_123
 * writes: g_122 g_156 g_85.f3
 */
static uint16_t  func_75(uint32_t  p_76, union U0  p_77, uint32_t  p_78, float  p_79)
{ /* block id: 38 */
    uint32_t l_88 = 0xD6CA138D;
    uint32_t l_175 = 0x045D86B4;
    float *l_176 = &g_122;
    (*g_123) = ((int16_t)(((__builtin_ffs(l_88) , ((int16_t)(func_91((g_85.f0 < (g_85.f1 <= ((uint16_t)(~(4294967295U > g_85.f1)) % (uint16_t)l_88))), ((int16_t)(0xA435 ^ func_101(((uint16_t)(((int16_t)(((l_88 | l_88) ^ l_88) == 0) % (int16_t)g_18) > p_77.f1) << (uint16_t)g_18), g_85.f4, l_88, g_85, g_85.f2)) >> (int16_t)l_88), l_88, l_88) , 0xF6D3) << (int16_t)11)) | g_18) >= l_88) + (int16_t)l_175);
    /* statement id: 80 */
        //assert (g_156 == dangling || g_156 == &g_157);
    (*l_176) = p_76;
    return l_88;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f4 g_85.f2 g_123 g_85.f3
 * writes: g_85.f3
 */
inline static int16_t  func_91(uint32_t  p_92, int32_t  p_93, float  p_94, uint32_t  p_95)
{ /* block id: 77 */
    union U0 l_168 = {0x14D024A4};
    float *l_170 = (void*)0;
    float ** const l_169 = &l_170;
    (*g_123) = (((uint32_t)((int16_t)(-1) / (int16_t)(((uint16_t)((((l_168 , (void*)0) != l_169) , ((p_92 >= (((uint16_t)g_85.f4 % (uint16_t)l_168.f2) == g_85.f2)) != (((int16_t)((l_168.f3 != 0xF98DCA0F) < p_93) << (int16_t)p_93) != 0xDCED91EE))) , p_93) << (uint16_t)5) , 65532U)) % (uint32_t)0x3A361754) ^ 0x032B);
    /* statement id: 78 */
    return g_85.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_85.f2 g_85.f3 g_123 g_85 g_18 g_85.f4 g_85.f0
 * writes: g_122 g_156
 */
static const int16_t  func_101(uint16_t  p_102, uint32_t  p_103, int32_t  p_104, union U0  p_105, const int16_t  p_106)
{ /* block id: 39 */
    uint32_t l_124 = 0x4559F947;
    int32_t l_145 = (-7);
    float *l_155 = &g_122;
    float **l_154 = &l_155;
    float ***l_153 = &l_154;
    int32_t l_161 = 0xDA865B3C;
    for (p_105.f3 = (-11); (p_105.f3 < (-27)); p_105.f3 -= 1)
    { /* block id: 42 */
        int16_t l_129 = 0x9CEB;
        int32_t *l_133 = &g_85.f3;
        int32_t *l_158 = &l_145;
        for (p_103 = 19; (p_103 == 43); p_103 += 3)
        { /* block id: 45 */
            int32_t **l_115 = (void*)0;
            int32_t *l_117 = (void*)0;
            int32_t **l_116 = &l_117;
            (*l_116) = (void*)0;
            for (p_102 = 0; (p_102 == 16); p_102 += 1)
            { /* block id: 49 */
                float *l_121 = &g_122;
                (*l_121) = ((p_103 == 0x1.AEA200p-88) >= ((!(g_85.f2 , 0x0.4p+1)) == g_85.f3));
                (*l_116) = g_123;
                /* statement id: 51 */
                assert (l_117 == &g_85.f3);
                (*l_121) = l_124;
            }
            /* facts after for loop */
            assert (l_117 == &g_85.f3 || l_117 == 0);
            if ((((g_85 , (((int32_t)(((uint16_t)0U % (uint16_t)0x8760) < ((*g_123) , (l_129 == ((p_104 , ((int16_t)g_18 << (int16_t)12)) , (+((__builtin_clz((p_105.f3 , g_18)) == p_105.f3) > g_85.f4)))))) / (int32_t)0x5EFCBABA) && g_85.f0)) <= 0xFF66) & g_85.f0))
            { /* block id: 54 */
                (*l_116) = l_133;
                /* statement id: 55 */
                assert (l_117 == &g_85.f3);
            }
            else
            { /* block id: 56 */
                uint16_t l_144 = 0x68C8;
                for (p_104 = 0; (p_104 < (-3)); p_104 -= 8)
                { /* block id: 59 */
                    uint32_t l_141 = 0x71CFEE84;
                    l_145 = (((((int16_t)g_85.f3 % (int16_t)(g_18 && ((65527U == ((!(g_85.f4 > l_141)) > g_85.f2)) != (((((uint32_t)(g_85.f3 , ((*g_123) > p_102)) / (uint32_t)l_144) <= 0xB1D7879C) , l_117) != (void*)0)))) , l_124) != p_103) >= (*l_133));
                    (*l_116) = &l_145;
                    /* statement id: 61 */
                    assert (l_117 == &l_145);
                }
                /* facts after for loop */
                assert (l_117 == &l_145 || l_117 == &g_85.f3 || l_117 == 0);
                for (l_145 = 0; (l_145 == 25); l_145 += 7)
                { /* block id: 65 */
                    const float ***l_148 = (void*)0;
                    float ***l_149 = (void*)0;
                    float *l_152 = &g_13;
                    float **l_151 = &l_152;
                    float ***l_150 = &l_151;
                    (*l_150) = (void*)0;
                    /* statement id: 66 */
                    assert (l_151 == 0);
                    g_156 = l_153;
                    /* statement id: 67 */
                    assert (g_156 == &l_154);
                    return g_85.f3;
                    /* statement id: 68 */
                    //assert (g_156 == dangling);
                }
            }
            /* facts after branching */
            assert (l_117 == &l_145 || l_117 == &g_85.f3 || l_117 == 0);
            (*l_116) = g_123;
            /* statement id: 71 */
            assert (l_117 == &g_85.f3);
        }
        (*l_158) = (*g_123);
    }
    /* facts after for loop */
        l_161 = (((1 == ((*g_123) ^ 8U)) , ((int16_t)l_124 + (int16_t)g_85.f4)) , p_104);
    return l_124;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc_bytes (&g_13, sizeof(g_13), "g_13", print_hash_value);
    transparent_crc(g_18, "g_18", print_hash_value);
    transparent_crc(g_85.f0, "g_85.f0", print_hash_value);
    transparent_crc(g_85.f1, "g_85.f1", print_hash_value);
    transparent_crc(g_85.f2, "g_85.f2", print_hash_value);
    transparent_crc(g_85.f3, "g_85.f3", print_hash_value);
    transparent_crc(g_85.f4, "g_85.f4", print_hash_value);
    transparent_crc_bytes (&g_122, sizeof(g_122), "g_122", print_hash_value);
    transparent_crc(g_189, "g_189", print_hash_value);
    transparent_crc(g_197, "g_197", print_hash_value);
    transparent_crc(g_210, "g_210", print_hash_value);
    transparent_crc(g_372, "g_372", print_hash_value);
    transparent_crc(g_395, "g_395", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 82
XXX total union variables: 11

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 77

XXX times a variable address is taken: 78
XXX times a pointer is dereferenced on RHS: 37
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 5
XXX times a pointer is dereferenced on LHS: 55
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 130

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 159
   level: 2, occurrence: 13
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 38
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 37.7
XXX average alias set size: 1.23

XXX times a non-volatile is read: 426
XXX times a non-volatile is write: 143
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 91
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 14
   depth: 2, occurrence: 16
   depth: 3, occurrence: 21
   depth: 4, occurrence: 8
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

