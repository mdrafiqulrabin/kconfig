/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2998963622
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const uint32_t  f0;
   const int16_t  f1;
};

union U1 {
   uint32_t  f0;
   int16_t  f1;
   int32_t  f2;
   const float  f3;
   int32_t  f4;
};

union U2 {
   float  f0;
   uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static float g_5 = 0x1.Ap+1;
static uint16_t g_12 = 0x0289;
static int32_t g_40 = (-1);
static uint16_t g_44 = 1U;
static union U1 g_47 = {0xBB1A88AF};
static union U1 *g_46 = &g_47;
static union U1 **g_45 = &g_46;
static union U1 *g_55 = &g_47;
static union U1 ** const g_54 = &g_55;
static int16_t g_86 = (-8);
static int32_t g_92 = 0x206C165A;
static uint32_t g_104 = 1U;
static int32_t *g_116 = &g_92;
static union U2 g_122 = {-0x2.4p+1};
static union U2 *g_121 = &g_122;
static union U0 g_148 = {4294967291U};
static uint64_t g_187 = 0xC56C064F7A502195LL;
static uint32_t g_190 = 3U;
static uint32_t g_208 = 0U;
static uint32_t g_222 = 0x4B88B552;
static float ** const g_230 = (void*)0;
static float ** const *g_229 = &g_230;
static uint16_t g_241 = 0x69AD;
static uint32_t *g_277 = &g_190;
static uint32_t **g_276 = &g_277;
static union U0 *g_284 = &g_148;
static union U0 **g_283 = &g_284;
static union U0 ***g_282 = &g_283;
static const union U1 g_299 = {4294967295U};
static uint32_t g_327 = 4294967293U;


/* --- FORWARD DECLARATIONS --- */
inline static float  func_29(void);
static union U1 * func_30(uint32_t  p_31, uint16_t  p_32, int32_t  p_33);
static union U1 * func_41(uint32_t  p_42);
static union U0 * func_57(int32_t  p_58, uint32_t  p_59, uint32_t  p_60, uint32_t  p_61, const uint32_t  p_62);
inline static const int16_t  func_73(union U0 * p_74);
static union U0 * func_75(union U1 ** p_76);
static union U1 ** func_77(int16_t  p_78);
static union U2 * func_93(union U1 **** p_94);
inline static int32_t * func_96(uint32_t  p_97, uint32_t  p_98, int16_t  p_99, int32_t ** p_100, int32_t  p_101);
static int32_t ** func_105(int16_t  p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_45 g_47.f1 g_46 g_54 g_47.f2 g_47.f4 g_47.f0 g_40 g_104 g_121 g_116 g_92 g_148.f1 g_190 g_276 g_282 g_277 g_86 g_283 g_284 g_299.f3 g_327 g_187
 * writes: g_40 g_44 g_45 g_5 g_46 g_55 g_47.f1 g_47.f4 g_86 g_92 g_104 g_116 g_121 g_122.f0 g_190 g_241 g_12 g_282 g_284
 */
inline static float  func_29(void)
{ /* block id: 36 */
    int32_t l_34 = 0x064BAE0F;
    int32_t *l_39 = &g_40;
    union U1 **l_51 = &g_46;
    float *l_63 = (void*)0;
    int32_t l_64 = 0;
    int16_t *l_79 = &g_47.f1;
    union U0 *l_313 = &g_148;
    union U0 **l_312 = &l_313;
    union U2 ***l_317 = (void*)0;
    int16_t l_328 = 0x7BDA;
    (*g_54) = func_30(l_34, __builtin_ctzll(((int32_t)((l_34 == (((*l_39) = g_12) <= (((*l_51) = func_41((g_44 = (!(g_12 > 0xE483BBB6))))) != (void*)0))) != ((uint16_t)((g_54 != (void*)0) & 0xA1BC) - (uint16_t)g_47.f2)) % (int32_t)g_47.f4)), g_47.f0);
    /* statement id: 48 */
    assert (g_55 == 0);
    (*l_312) = ((*g_283) = func_57((*l_39), g_12, (l_64 = (l_63 != l_39)), ((int16_t)((int16_t)g_12 << (int16_t)(((uint32_t)g_12 % (uint32_t)((int16_t)func_73(func_75(func_77(((*l_79) = (*l_39))))) << (int16_t)9)) == 1)) * (int16_t)g_148.f1), (*l_39)));
    /* statement id: 201 */
    assert (g_55 == &g_47);
    //assert (g_116 == dangling || g_116 == &g_40 || g_116 == &g_92);
    for (g_47.f1 = 0; (g_47.f1 < 9); g_47.f1 += 9)
    { /* block id: 204 */
        int32_t **l_316 = &l_39;
        int16_t *l_335 = &g_86;
        int32_t l_336 = 0x897EA332;
        int32_t *l_337 = &l_336;
        (*l_316) = &g_92;
        /* statement id: 205 */
        assert (l_39 == &g_92);
        if ((**l_316))
        { /* block id: 206 */
            (*l_316) = &g_92;
        }
        else
        { /* block id: 208 */
            union U2 ****l_318 = &l_317;
            int32_t l_319 = 0x34E27C4D;
            float *l_329 = (void*)0;
            float *l_330 = &g_5;
            (*l_318) = l_317;
            l_319 = (-0x6.Fp-1);
            (*l_330) = (0xE.5DBEDBp-98 >= ((((float)((float)l_319 + (float)__builtin_ffs((**l_316))) + (float)((float)(!g_299.f3) * (float)g_327)) > l_319) <= (0x1.9p+1 >= ((l_79 == (void*)0) == l_328))));
        }
        (*l_337) = ((*l_39) = (((**g_276) | (**l_316)) != ((int16_t)((int16_t)((*l_335) = func_73((*g_283))) * (int16_t)g_187) * (int16_t)l_336)));
    }
    /* facts after for loop */
    assert (l_39 == &g_92 || l_39 == &g_40);
    return (*l_39);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_30(uint32_t  p_31, uint16_t  p_32, int32_t  p_33)
{ /* block id: 46 */
    union U1 *l_56 = (void*)0;
    return l_56;
    /* statement id: 47 */
    //assert (func_30_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_47.f1 g_46
 * writes: g_45 g_5
 */
static union U1 * func_41(uint32_t  p_42)
{ /* block id: 39 */
    union U1 ***l_48 = &g_45;
    float *l_49 = &g_5;
    int32_t l_50 = 1;
    (*l_48) = g_45;
    (*l_49) = p_42;
    (*l_49) = l_50;
    l_50 = g_47.f1;
    return (*g_45);
    /* statement id: 44 */
    //assert (func_41_rv == &g_47);
}


/* ------------------------------------------ */
/* 
 * reads : g_116 g_40 g_92 g_47.f1 g_190 g_148.f1 g_12 g_104 g_276 g_282 g_277 g_86 g_283 g_284
 * writes: g_40 g_92 g_121 g_55 g_122.f0 g_190 g_241 g_12 g_47.f4 g_282 g_5 g_86 g_47.f1 g_116
 */
static union U0 * func_57(int32_t  p_58, uint32_t  p_59, uint32_t  p_60, uint32_t  p_61, const uint32_t  p_62)
{ /* block id: 101 */
    union U1 ***l_157 = &g_45;
    uint32_t *l_189 = &g_190;
    uint32_t **l_188 = &l_189;
    int32_t l_197 = 0x271EE0EC;
    int32_t l_256 = 0x5D45CBCC;
    union U2 **l_274 = &g_121;
    const uint64_t *l_287 = &g_187;
    union U0 *l_290 = &g_148;
    float *l_291 = &g_5;
    int16_t l_304 = 0;
    if (((uint16_t)((*g_116) <= (&g_45 != l_157)) - (uint16_t)1))
    { /* block id: 102 */
        union U0 *l_168 = (void*)0;
        int32_t l_171 = 3;
        uint16_t l_242 = 0x85B2;
        for (p_60 = 0; (p_60 >= 13); p_60 += 1)
        { /* block id: 105 */
            float l_167 = 0x3.6A600Ep+67;
            const int32_t l_221 = 0x7205C45C;
            uint16_t *l_243 = &g_44;
            int32_t l_244 = 0xBBE5BF61;
            int32_t l_245 = 0xBD5F4407;
        }
        (*g_116) = p_61;
    }
    else
    { /* block id: 163 */
        union U2 **l_246 = &g_121;
        (*g_116) = 0x6F7F9ADA;
        (*l_246) = &g_122;
    }
    for (p_58 = 0; (p_58 < 11); p_58 += 1)
    { /* block id: 169 */
        uint32_t * const l_254 = &g_190;
        int32_t l_255 = 6;
        float *l_257 = &g_122.f0;
        union U2 * const *l_275 = (void*)0;
        uint32_t **l_278 = &l_189;
        l_256 = (g_47.f1 >= ((float)g_190 - (float)(-(float)((*l_257) = ((float)(((func_73(&g_148) >= (l_255 = (l_254 != (void*)0))) == l_256) >= l_256) / (float)0x8.B03AC4p-35)))));
        for (g_40 = (-9); (g_40 > (-19)); g_40 -= 9)
        { /* block id: 175 */
            int32_t l_280 = 5;
            for (g_190 = 14; (g_190 != 6); g_190 -= 8)
            { /* block id: 178 */
                float l_266 = 0x2.0p-1;
                uint16_t *l_267 = &g_241;
                uint16_t *l_268 = &g_12;
                uint32_t ***l_279 = &l_188;
                int32_t *l_281 = &g_47.f4;
                (*l_281) = (l_255 == ((uint16_t)((((*l_268) = ((*l_267) = ((int16_t)g_12 * (int16_t)p_60))) && ((int16_t)(((int16_t)(((!g_104) != p_58) ^ (p_59 = (l_274 == l_275))) << (int16_t)2) < (g_276 != ((*l_279) = l_278))) - (int16_t)l_280)) ^ 0x08D450DD) + (uint16_t)p_58));
            }
            g_282 = g_282;
        }
    }
    (*l_291) = (((float)__builtin_clz(__builtin_bswap32((**g_276))) / (float)((void*)0 != l_287)) < (l_197 = ((float)(func_73(l_290) != 0x4.8p-1) * (float)__builtin_ctzl(l_256))));
    for (g_86 = 0; (g_86 != 16); g_86 += 1)
    { /* block id: 192 */
        const union U1 *l_298 = &g_299;
        const union U1 **l_297 = &l_298;
        int16_t *l_300 = (void*)0;
        int16_t *l_301 = &g_47.f1;
        int32_t l_309 = (-1);
        uint16_t *l_310 = &g_241;
        uint16_t l_311 = 65535U;
        (*g_116) = (((int16_t)(((!(((*l_301) = (((*l_297) = (void*)0) != (void*)0)) || 1)) > (((uint16_t)l_304 * (uint16_t)(__builtin_parityl(((int16_t)func_73((*g_283)) * (int16_t)((int16_t)l_309 >> (int16_t)((*l_310) = p_58)))) && p_62)) ^ (-1))) < l_304) * (int16_t)l_197) <= l_311);
        /* statement id: 196 */
        assert (l_298 == 0);
        g_116 = &l_197;
        /* statement id: 197 */
        assert (g_116 == &l_197);
    }
    /* facts after for loop */
    assert (g_116 == &l_197 || g_116 == &g_40 || g_116 == &g_92);
    return l_290;
    /* statement id: 199 */
    //assert (g_116 == dangling || g_116 == &g_40 || g_116 == &g_92);
    //assert (func_57_rv == &g_148);
}


/* ------------------------------------------ */
/* 
 * reads : g_148.f1
 * writes: g_55
 */
inline static const int16_t  func_73(union U0 * p_74)
{ /* block id: 98 */
    union U1 * const l_153 = &g_47;
    union U1 **l_154 = &g_55;
    (*l_154) = l_153;
    /* statement id: 99 */
    assert (g_55 == &g_47);
    return g_148.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_47.f2 g_116 g_40 g_92
 * writes: g_47.f4
 */
static union U0 * func_75(union U1 ** p_76)
{ /* block id: 92 */
    int16_t l_142 = (-10);
    union U2 *l_143 = &g_122;
    int32_t l_146 = 1;
    union U0 *l_147 = &g_148;
    union U0 **l_149 = (void*)0;
    union U0 **l_150 = (void*)0;
    int32_t *l_151 = &g_47.f4;
    union U0 *l_152 = &g_148;
    l_146 = (((int16_t)l_142 * (int16_t)(l_143 != &g_122)) & (__builtin_popcountl((__builtin_popcountl(l_142) > ((l_142 <= ((uint32_t)g_47.f2 % (uint32_t)(*g_116))) > l_142))) == l_142));
    l_147 = l_147;
    (*l_151) = (l_146 = (0x1B9A & 0x7311));
    return l_152;
    /* statement id: 97 */
    //assert (func_75_rv == &g_148);
}


/* ------------------------------------------ */
/* 
 * reads : g_47.f4 g_47.f0 g_47.f1 g_47.f2 g_40 g_45 g_46 g_54 g_104 g_121 g_116 g_92
 * writes: g_47.f4 g_86 g_92 g_104 g_116 g_45 g_5 g_55 g_44 g_121 g_46
 */
static union U1 ** func_77(int16_t  p_78)
{ /* block id: 51 */
    int32_t *l_80 = &g_40;
    int32_t **l_81 = (void*)0;
    union U2 *l_138 = (void*)0;
    union U1 **l_139 = &g_46;
    l_80 = l_80;
    for (g_47.f4 = 0; (g_47.f4 > 22); g_47.f4 += 2)
    { /* block id: 55 */
        int16_t *l_85 = &g_86;
        union U1 ***l_88 = (void*)0;
        union U1 ****l_87 = &l_88;
        int32_t l_89 = (-8);
        int32_t *l_90 = (void*)0;
        int32_t *l_91 = &g_92;
        union U1 ****l_95 = &l_88;
        (*l_91) = (l_89 = (1 && ((p_78 <= ((*l_85) = (~__builtin_bswap32(((g_47.f0 && p_78) && 0U))))) != (((*l_87) = &g_45) != (void*)0))));
        /* statement id: 59 */
        assert (l_88 == 0 || l_88 == &g_45);
        l_138 = func_93(l_95);
        /* statement id: 89 */
        assert (g_116 == &g_40);
        assert (l_138 == &g_122);
    }
    /* facts after for loop */
    assert (g_55 == 0 || g_55 == &g_47);
    assert (g_116 == &g_40 || g_116 == &g_92);
    assert (l_138 == &g_122 || l_138 == 0);
    return l_139;
    /* statement id: 91 */
    //assert (func_77_rv == &g_46);
}


/* ------------------------------------------ */
/* 
 * reads : g_47.f4 g_47.f1 g_47.f2 g_40 g_45 g_46 g_54 g_104 g_121 g_116 g_92
 * writes: g_104 g_116 g_45 g_5 g_55 g_44 g_121 g_86 g_92 g_46
 */
static union U2 * func_93(union U1 **** p_94)
{ /* block id: 60 */
    float l_102 = (-0x3.0p-1);
    uint32_t *l_103 = &g_104;
    int32_t l_107 = 0x56F60D19;
    int32_t l_112 = 0x361030FA;
    int32_t **l_135 = &g_116;
    int32_t *l_137 = &g_92;
    int32_t **l_136 = &l_137;
    (*l_136) = ((*l_135) = func_96(g_47.f4, ((*l_103) = g_47.f1), g_47.f2, func_105((((l_107 = g_47.f1) < ((uint16_t)65535U >> (uint16_t)15)) == (((uint16_t)l_112 >> (uint16_t)15) || g_40))), l_112));
    /* statement id: 86 */
    assert (g_116 == &g_40);
    assert (l_137 == &g_40);
    l_107 = (*g_116);
    return &g_122;
    /* statement id: 88 */
    //assert (func_93_rv == &g_122);
}


/* ------------------------------------------ */
/* 
 * reads : g_104 g_121 g_116 g_92 g_47.f2 g_54
 * writes: g_104 g_44 g_121 g_86 g_92 g_46 g_55
 */
inline static int32_t * func_96(uint32_t  p_97, uint32_t  p_98, int16_t  p_99, int32_t ** p_100, int32_t  p_101)
{ /* block id: 68 */
    union U1 * const l_133 = &g_47;
    for (g_104 = 0; (g_104 >= 4); g_104 += 7)
    { /* block id: 71 */
        for (g_44 = 0; (g_44 == 12); g_44 += 4)
        { /* block id: 74 */
            union U2 **l_123 = (void*)0;
            union U2 **l_124 = (void*)0;
            union U2 **l_125 = &g_121;
            const union U1 **l_127 = (void*)0;
            const union U1 ***l_126 = &l_127;
            int16_t *l_128 = (void*)0;
            int16_t *l_129 = (void*)0;
            int16_t *l_130 = (void*)0;
            int16_t *l_131 = &g_86;
            int32_t l_132 = 6;
            union U1 **l_134 = &g_46;
            (*l_125) = g_121;
            (*l_126) = (void*)0;
            (*g_116) = ((l_132 = (((*g_116) & (**p_100)) == ((*l_131) = g_47.f2))) == 0U);
            (*l_134) = l_133;
        }
        (*g_54) = (void*)0;
        /* statement id: 82 */
        assert (g_55 == 0);
    }
    /* facts after for loop */
    assert (g_55 == 0 || g_55 == &g_47);
    return &g_40;
    /* statement id: 84 */
    //assert (func_96_rv == &g_40);
}


/* ------------------------------------------ */
/* 
 * reads : g_47.f2 g_45 g_47.f1 g_46 g_54
 * writes: g_116 g_45 g_5 g_55
 */
static int32_t ** func_105(int16_t  p_106)
{ /* block id: 63 */
    int32_t *l_113 = &g_92;
    int32_t **l_114 = (void*)0;
    int32_t **l_115 = &l_113;
    g_116 = ((*l_115) = l_113);
    /* statement id: 65 */
    assert (g_116 == &g_92);
    (*g_54) = func_41(g_47.f2);
    /* statement id: 66 */
    assert (g_55 == &g_47);
    return &g_116;
    /* statement id: 67 */
    //assert (func_105_rv == &g_116);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc_bytes (&g_5, sizeof(g_5), "g_5", print_hash_value);
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_40, "g_40", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    transparent_crc(g_47.f1, "g_47.f1", print_hash_value);
    transparent_crc(g_86, "g_86", print_hash_value);
    transparent_crc(g_92, "g_92", print_hash_value);
    transparent_crc(g_104, "g_104", print_hash_value);
    transparent_crc_bytes (&g_122.f0, sizeof(g_122.f0), "g_122.f0", print_hash_value);
    transparent_crc(g_122.f1, "g_122.f1", print_hash_value);
    transparent_crc(g_148.f0, "g_148.f0", print_hash_value);
    transparent_crc(g_148.f1, "g_148.f1", print_hash_value);
    transparent_crc(g_187, "g_187", print_hash_value);
    transparent_crc(g_190, "g_190", print_hash_value);
    transparent_crc(g_208, "g_208", print_hash_value);
    transparent_crc(g_222, "g_222", print_hash_value);
    transparent_crc(g_241, "g_241", print_hash_value);
    transparent_crc(g_299.f0, "g_299.f0", print_hash_value);
    transparent_crc(g_299.f1, "g_299.f1", print_hash_value);
    transparent_crc(g_299.f2, "g_299.f2", print_hash_value);
    transparent_crc_bytes (&g_299.f3, sizeof(g_299.f3), "g_299.f3", print_hash_value);
    transparent_crc(g_299.f4, "g_299.f4", print_hash_value);
    transparent_crc(g_327, "g_327", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 82
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 18
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 5
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2

XXX total number of pointers: 126

XXX times a variable address is taken: 102
XXX times a pointer is dereferenced on RHS: 22
breakdown:
   depth: 1, occurrence: 16
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 60
breakdown:
   depth: 1, occurrence: 60
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 157

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 147
   level: 2, occurrence: 10
   level: 3, occurrence: 11
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.4
XXX average alias set size: 1.11

XXX times a non-volatile is read: 227
XXX times a non-volatile is write: 162
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 58
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 15
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 33.6
XXX percentage an existing variable is used: 66.4
********************* end of statistics **********************/

