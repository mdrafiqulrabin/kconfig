/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      3647222363
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 12;
   const unsigned f1 : 19;
   int32_t  f2;
   unsigned f3 : 27;
   signed f4 : 22;
   const unsigned f5 : 12;
   const signed f6 : 31;
   int32_t  f7;
   unsigned f8 : 24;
};

union U1 {
   signed f0 : 28;
   signed f1 : 25;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_4 = 0x735E4B78;
static int32_t g_9[2] = {0x51D52AA0,0x51D52AA0};
static int32_t g_13[6] = {8,8,8,8,8,8};
static union U1 g_21 = {-6};
static union U1 *g_20 = &g_21;
static uint16_t g_44 = 0x2C9D;
static const union U1 *g_52[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static const union U1 **g_51[2][8][5] = {{{&g_52[2],&g_52[0],&g_52[0],&g_52[2],&g_52[0]},{&g_52[0],&g_52[2],&g_52[2],&g_52[3],&g_52[0]},{&g_52[2],(void*)0,&g_52[0],&g_52[0],(void*)0},{&g_52[0],&g_52[5],&g_52[2],&g_52[4],&g_52[5]},{&g_52[2],(void*)0,&g_52[2],(void*)0,&g_52[2]},{&g_52[2],&g_52[2],&g_52[5],&g_52[2],&g_52[0]},{&g_52[2],&g_52[0],&g_52[2],&g_52[0],&g_52[2]},{&g_52[5],&g_52[5],&g_52[0],&g_52[2],&g_52[2]}},{{(void*)0,&g_52[0],(void*)0,&g_52[2],&g_52[0]},{&g_52[2],&g_52[2],&g_52[2],&g_52[2],&g_52[2]},{&g_52[2],&g_52[2],&g_52[2],&g_52[0],&g_52[0]},{&g_52[2],&g_52[2],&g_52[2],&g_52[3],&g_52[5]},{&g_52[0],&g_52[2],(void*)0,&g_52[0],&g_52[2]},{&g_52[5],&g_52[2],&g_52[0],&g_52[2],&g_52[5]},{(void*)0,&g_52[2],&g_52[2],&g_52[2],&g_52[2]},{&g_52[5],&g_52[2],&g_52[2],&g_52[5],&g_52[2]}}};
static int32_t * const g_76 = &g_13[0];
static int32_t * const *g_75 = &g_76;
static uint16_t g_78 = 65533U;
static uint16_t g_80 = 65535U;
static union U1 *g_86[2][9] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
static int16_t g_97 = 0x94BA;
static int32_t **g_100 = (void*)0;
static uint32_t g_124[1] = {4294967290U};
static struct S0 g_132[8][4] = {{{-55,33,0x0A8C2178,7266,-184,36,28468,0xCEA890DC,2271},{31,506,0xF70CD436,2479,1564,49,5741,0xEE03666D,1991},{-2,11,0x6DCD3F6C,804,1364,6,38709,0,202},{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533}},{{-2,11,0x6DCD3F6C,804,1364,6,38709,0,202},{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533},{-4,294,0xFC98A5CB,6532,-1214,4,19278,4,2575},{-2,11,0x6DCD3F6C,804,1364,6,38709,0,202}},{{48,27,0xCC1C6A88,4171,-968,40,-31192,0xF120AA44,3288},{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533},{-6,507,0x339D8DFC,2132,-720,37,-35920,0x65C77323,4039},{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533}},{{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533},{31,506,0xF70CD436,2479,1564,49,5741,0xEE03666D,1991},{28,702,0x65745E92,3596,673,62,12402,0xFAFF4B71,1222},{51,191,0xB726758D,1841,786,3,33638,0x71E3CB3F,2898}},{{37,561,0x7B5993E3,1592,-1570,59,17567,-2,517},{48,27,0xCC1C6A88,4171,-968,40,-31192,0xF120AA44,3288},{-4,294,0xFC98A5CB,6532,-1214,4,19278,4,2575},{28,702,0x65745E92,3596,673,62,12402,0xFAFF4B71,1222}},{{-55,33,0x0A8C2178,7266,-184,36,28468,0xCEA890DC,2271},{44,82,0xC981C0E1,7079,-795,47,-27492,4,3937},{49,370,0x05CC3D6C,1600,357,32,42390,0,870},{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533}},{{-55,33,0x0A8C2178,7266,-184,36,28468,0xCEA890DC,2271},{-4,294,0xFC98A5CB,6532,-1214,4,19278,4,2575},{-4,294,0xFC98A5CB,6532,-1214,4,19278,4,2575},{-55,33,0x0A8C2178,7266,-184,36,28468,0xCEA890DC,2271}},{{37,561,0x7B5993E3,1592,-1570,59,17567,-2,517},{-56,439,0x535C36BF,5030,1328,4,38996,-1,3533},{28,702,0x65745E92,3596,673,62,12402,0xFAFF4B71,1222},{-4,294,0xFC98A5CB,6532,-1214,4,19278,4,2575}}};
static int32_t g_239 = 3;
static int32_t *g_238 = &g_239;
static int32_t ** const g_237 = &g_238;
static const int32_t *g_281 = &g_21.f2;
static uint32_t *g_298 = &g_124[0];
static uint32_t **g_297 = &g_298;
static int32_t g_408 = 0x8AB21667;
static struct S0 g_425 = {-63,324,-1,2532,-892,43,41705,-8,1069};
static struct S0 *g_424 = &g_425;
static int16_t g_464 = (-3);
static uint32_t g_476 = 0x3A4E73B8;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_5(int32_t ** p_6);
inline static int32_t * const * const  func_14(const uint32_t  p_15, uint32_t  p_16, uint16_t  p_17);
inline static uint32_t  func_18(int32_t  p_19);
static int16_t  func_45(const union U1 ** p_46, int32_t * p_47, uint16_t * p_48, int16_t  p_49, const int32_t * p_50);
static uint16_t * func_53(union U1  p_54, int32_t ** p_55, union U1 * const  p_56);
static int32_t ** func_57(int32_t ** p_58, uint32_t  p_59, union U1  p_60, int16_t  p_61);
inline static int8_t  func_64(int32_t  p_65, union U1 * p_66, uint32_t  p_67);
inline static int16_t  func_81(union U1 * p_82, int32_t ** p_83, uint16_t  p_84, uint32_t  p_85);
static int32_t ** func_87(int32_t  p_88, int32_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_9 g_20 g_13 g_51 g_21 g_21.f1 g_75 g_80 g_76 g_78 g_100 g_21.f2 g_132.f8 g_132.f4 g_132.f0 g_132.f7 g_124 g_132.f6 g_132.f1 g_298 g_425.f0 g_239 g_408 g_425.f8 g_424 g_425
 * writes: g_4 g_9 g_13 g_20 g_21.f2 g_44 g_78 g_80 g_86 g_97 g_124 g_132.f2 g_281 g_464 g_297 g_476 g_425.f4 g_75
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_3[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int32_t **l_2 = &l_3[1];
    union U1 **l_501 = &g_86[0][5];
    union U1 ***l_502 = &l_501;
    int i;
    (*l_2) = (void*)0;
    (*l_2) = func_5(&l_3[1]);
    /* statement id: 285 */
    //assert ((l_3[0] >= &g_13[0] && l_3[0] <= &g_13[5]) || l_3[0] == 0 || l_3[0] == &g_4);
    assert ((g_281 >= &g_13[0] && g_281 <= &g_13[5]) || g_281 == &g_21.f2);
    assert (g_297 == 0 || g_297 == &g_298);
    (*l_502) = l_501;
    return g_13[3];
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_9 g_20 g_13 g_51 g_21 g_21.f1 g_75 g_80 g_76 g_78 g_100 g_21.f2 g_132.f8 g_132.f4 g_132.f0 g_132.f7 g_124 g_132.f6 g_132.f1 g_298 g_425.f0 g_239 g_408 g_425.f8 g_424 g_425
 * writes: g_4 g_9 g_13 g_20 g_21.f2 g_44 g_78 g_80 g_86 g_97 g_124 g_132.f2 g_281 g_464 g_297 g_476 g_425.f4 g_75
 */
static int32_t * func_5(int32_t ** p_6)
{ /* block id: 2 */
    int8_t l_469 = 9;
    int32_t l_470[8][8] = {{0x4C084251,0,0x4C084251,0x4C084251,0,0x4C084251,0x4C084251,0},{0,0x4C084251,0x4C084251,0,0x4C084251,0x4C084251,0,0x4C084251},{0,0,0x3BCF1EEA,0,0,0x3BCF1EEA,0,0},{0x4C084251,0,0x4C084251,0x4C084251,0,0x4C084251,0x4C084251,0},{0,0x4C084251,0x4C084251,0,0x4C084251,0x4C084251,0,0x4C084251},{0,0,0x3BCF1EEA,0,0,0x3BCF1EEA,0,0},{0x4C084251,0,0x4C084251,0x4C084251,0,0x4C084251,0x4C084251,0},{0,0x4C084251,0x4C084251,0,0x4C084251,0x4C084251,0,0x4C084251}};
    const union U1 l_471 = {0x3A2CDA22};
    uint32_t **l_475 = (void*)0;
    int i, j;
    for (g_4 = 0; (g_4 < (-5)); g_4 -= 7)
    { /* block id: 5 */
        const uint16_t l_462 = 0xA869;
        union U1 l_473 = {0};
        for (g_9[0] = (-30); (g_9[0] <= 17); g_9[0] += 1)
        { /* block id: 8 */
            int32_t *l_12 = &g_13[3];
            int16_t *l_463[3][6] = {{&g_464,&g_464,&g_464,&g_464,&g_464,&g_464},{&g_464,&g_464,&g_464,&g_464,&g_464,&g_464},{&g_464,&g_464,&g_464,&g_464,&g_464,&g_464}};
            union U1 *l_474 = &l_473;
            int32_t l_477[9] = {0x1A25314A,0x1A25314A,0x1A25314A,0x1A25314A,0x1A25314A,0x1A25314A,0x1A25314A,0x1A25314A,0x1A25314A};
            int32_t * const **l_497 = &g_75;
            int i, j;
            (*l_12) = g_4;
            (*l_497) = func_14(((*l_12) = func_18(g_4)), ((((uint16_t)(l_462 ^ (((g_464 = 0) > ((int32_t)((int32_t)(l_470[3][4] = l_469) + (int32_t)l_469) + (int32_t)((l_471 , ((!((((*l_474) = l_473) , ((g_476 = ((((g_297 = l_475) == &g_298) ^ 3) > l_473.f0)) || l_469)) , l_469)) , g_408)) < l_462))) | g_425.f8)) << (uint16_t)15) & l_462) ^ l_469), l_477[1]);
            /* statement id: 274 */
                        assert ((g_281 >= &g_13[0] && g_281 <= &g_13[5]));
            assert (g_297 == 0);
            if ((**g_75))
                continue;
        }
        /* facts after for loop */
        assert ((g_281 >= &g_13[0] && g_281 <= &g_13[5]) || g_281 == &g_21.f2);
        assert (g_297 == 0 || g_297 == &g_298);
        return &g_13[4];
        /* statement id: 277 */
        //assert ((func_5_rv >= &g_13[0] && func_5_rv <= &g_13[5]));
    }
    for (g_78 = 0; (g_78 < 35); g_78 += 1)
    { /* block id: 281 */
        int32_t *l_500[2][7] = {{&l_470[2][5],&g_4,&g_425.f2,&l_470[3][4],&l_470[3][4],&g_425.f2,&g_4},{&l_470[2][5],&g_4,&g_425.f2,&l_470[3][4],&l_470[3][4],&g_425.f2,&g_4}};
        int i, j;
        return (*p_6);
        /* statement id: 282 */
        //assert (func_5_rv == 0 || func_5_rv == &g_4);
    }
    return (*p_6);
    /* statement id: 284 */
    //assert (func_5_rv == 0 || func_5_rv == &g_4);
}


/* ------------------------------------------ */
/* 
 * reads : g_424 g_425 g_298 g_124 g_239 g_75 g_76
 * writes: g_281 g_124 g_80 g_13 g_425.f4
 */
inline static int32_t * const * const  func_14(const uint32_t  p_15, uint32_t  p_16, uint16_t  p_17)
{ /* block id: 266 */
    int32_t *l_478[6];
    int32_t **l_479[7][4][1];
    union U1 l_480 = {0x5B5918B0};
    int16_t l_487 = 0xAC73;
    uint16_t *l_493 = (void*)0;
    uint16_t *l_494 = &g_80;
    struct S0 *l_495 = &g_132[4][3];
    struct S0 **l_496 = &l_495;
    int i, j, k;
    for (i = 0; i < 6; i++)
        l_478[i] = &g_13[3];
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 4; j++)
        {
            for (k = 0; k < 1; k++)
                l_479[i][j][k] = (void*)0;
        }
    }
    g_281 = l_478[5];
    /* statement id: 267 */
    assert ((g_281 >= &g_13[0] && g_281 <= &g_13[5]));
    g_425.f4 = ((l_480 , (*g_424)) , ((uint16_t)((-8) | (0x6D48661F > (((*g_298) = p_17) , (((((int32_t)((int16_t)7 - (int16_t)(((**g_75) = (l_487 ^ (((!((uint16_t)g_124[0] << (uint16_t)((uint16_t)((*l_494) = g_239) >> (uint16_t)4))) , 0x7D3F6F4D) & (-1)))) ^ (*g_298))) % (int32_t)0xFD441199) || p_16) > p_17) | p_17)))) - (uint16_t)0xD6CB));
    (*l_496) = l_495;
    return &g_76;
    /* statement id: 273 */
    //assert (func_14_rv == &g_76);
}


/* ------------------------------------------ */
/* 
 * reads : g_20 g_21.f2 g_13 g_4 g_51 g_21 g_9 g_21.f1 g_75 g_80 g_76 g_78 g_100 g_132.f8 g_44 g_132.f4 g_132.f0 g_132.f7 g_124 g_132.f6 g_132.f1 g_298 g_425.f0 g_239
 * writes: g_20 g_21.f2 g_13 g_44 g_78 g_80 g_86 g_97 g_124 g_132.f2 g_281
 */
inline static uint32_t  func_18(int32_t  p_19)
{ /* block id: 10 */
    union U1 **l_22 = (void*)0;
    int32_t l_42 = 0;
    uint16_t *l_43 = &g_44;
    int32_t **l_62 = (void*)0;
    union U1 *l_63[3][6][2] = {{{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21}},{{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21}},{{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21},{&g_21,&g_21}}};
    union U1 l_69 = {2};
    int32_t l_158 = (-4);
    int16_t *l_159[10][2] = {{&g_97,(void*)0},{&g_97,(void*)0},{(void*)0,(void*)0},{&g_97,(void*)0},{&g_97,&g_97},{&g_97,(void*)0},{&g_97,(void*)0},{(void*)0,(void*)0},{&g_97,(void*)0},{&g_97,&g_97}};
    uint16_t l_192 = 65529U;
    uint32_t l_207[10][2][4] = {{{0x81F6309F,0x27A1DAC0,0xFC2CE5BB,0x9B01001B},{4294967295U,0xFC2CE5BB,0xFC2CE5BB,4294967295U}},{{0x81F6309F,0x2CD0738B,4294967291U,0xD73AB9B9},{0x33C9A5DC,0x88B51EEA,0xD73AB9B9,0x2DB36039}},{{0xD73AB9B9,0x2DB36039,4294967295U,0x2DB36039},{0xFC2CE5BB,0x88B51EEA,0x27A1DAC0,0xD73AB9B9}},{{2U,0x2CD0738B,0x2DB36039,4294967295U},{0x27A1DAC0,0xFC2CE5BB,0x9B01001B,0x9B01001B}},{{0x27A1DAC0,0x27A1DAC0,0x2DB36039,0x81F6309F},{2U,0x9B01001B,0x27A1DAC0,0x2CD0738B}},{{0xFC2CE5BB,0x33C9A5DC,4294967295U,0x27A1DAC0},{0xD73AB9B9,0x33C9A5DC,0xD73AB9B9,0x2CD0738B}},{{0x33C9A5DC,0x9B01001B,4294967291U,0x81F6309F},{0x81F6309F,0x27A1DAC0,0xFC2CE5BB,0x9B01001B}},{{4294967295U,0xFC2CE5BB,0xFC2CE5BB,4294967295U},{0x81F6309F,0x2CD0738B,4294967291U,0xD73AB9B9}},{{0x33C9A5DC,0x88B51EEA,0xD73AB9B9,0x2DB36039},{0xD73AB9B9,0x2DB36039,4294967295U,0x2DB36039}},{{0xFC2CE5BB,0x88B51EEA,0x27A1DAC0,0xD73AB9B9},{2U,0x2CD0738B,0x2DB36039,4294967295U}}};
    int32_t *l_231 = &g_4;
    int32_t **l_230 = &l_231;
    uint16_t l_285 = 6U;
    uint32_t *l_296 = &g_124[0];
    uint32_t **l_295[10][9][2] = {{{&l_296,&l_296},{&l_296,&l_296},{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,(void*)0}},{{&l_296,(void*)0},{&l_296,(void*)0},{&l_296,&l_296},{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296}},{{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296}},{{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296}},{{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296}},{{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296}},{{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,(void*)0}},{{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296}},{{&l_296,&l_296},{&l_296,&l_296},{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{(void*)0,&l_296}},{{&l_296,&l_296},{&l_296,(void*)0},{&l_296,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{(void*)0,&l_296},{&l_296,&l_296},{&l_296,&l_296}}};
    int32_t l_371 = 0x7D4B94EF;
    int32_t *l_449 = &g_13[2];
    int32_t **l_455 = &g_238;
    int32_t *** const l_454 = &l_455;
    int32_t *l_459 = &l_42;
    int i, j, k;
    g_20 = g_20;
    for (g_21.f2 = 0; (g_21.f2 != 24); g_21.f2 += 6)
    { /* block id: 14 */
        const union U1 ** const l_27 = (void*)0;
        const int32_t l_28 = 1;
        int32_t l_31 = 8;
        for (p_19 = 0; (p_19 == 8); p_19++)
        { /* block id: 17 */
            int32_t *l_29 = (void*)0;
            int32_t *l_30 = &g_13[1];
            l_31 = ((*l_30) = (((l_27 == l_22) == g_13[4]) > (l_28 , p_19)));
        }
        for (p_19 = 0; (p_19 < (-15)); p_19 -= 1)
        { /* block id: 23 */
            return g_4;
        }
    }
    /* facts after for loop */
        if ((((uint16_t)(((int16_t)(l_69.f0 = ((int32_t)((int32_t)((l_42 && (((*l_43) = p_19) & func_45(g_51[1][5][0], &l_42, func_53((*g_20), func_57(l_62, (((void*)0 != l_63[2][3][0]) ^ (((func_64(p_19, &g_21, g_9[0]) , 1U) , p_19) > p_19)), l_69, g_21.f1), &g_21), g_132[4][3].f8, &g_4))) & 0x1E01) - (int32_t)l_158) + (int32_t)0xCD4106AF)) << (int16_t)13) == p_19) - (uint16_t)g_4) || 0x4C161D2A))
    { /* block id: 68 */
        int16_t l_162[10][1][7] = {{{1,0x5190,0xD7A6,0x8FFA,(-10),0xB4E8,0xB4E8}},{{1,3,0xEB4E,3,1,0xE275,0xF30B}},{{1,0x1313,8,6,1,0x4A38,(-4)}},{{2,0,0xFB55,0x6249,0x6249,0xFB55,0}},{{1,6,0x1313,1,0x5190,0xD7A6,0x8FFA}},{{1,0xDC0A,0xFF8C,0xEB4E,8,0x6249,8}},{{1,0x0EE2,0x0EE2,1,0xB4E8,8,6}},{{0xEB4E,0xFF8C,0xDC0A,1,0xFB55,(-1),0xE275}},{{6,0xB4E8,8,1,8,0xB4E8,6}},{{8,0xF30B,0x8F1A,0xE275,0xEB4E,(-1),0xFF8C}}};
        int32_t l_187 = (-6);
        int32_t l_191 = 0xD69DC89B;
        int32_t l_209[1][4] = {{0xA533CBFB,0xA533CBFB,0xA533CBFB,0xA533CBFB}};
        int32_t *l_217 = &l_42;
        union U1 l_260 = {0};
        const int8_t l_303 = (-9);
        int32_t l_319[6] = {0xEF71A364,0xEF71A364,0xEF71A364,0xEF71A364,0xEF71A364,0xEF71A364};
        uint16_t l_353 = 65529U;
        const uint32_t l_363 = 0xFDD5CE23;
        struct S0 *l_365 = &g_132[4][3];
        struct S0 **l_364 = &l_365;
        uint32_t * const *l_401 = (void*)0;
        uint32_t * const **l_400[1];
        const int32_t **l_432 = &g_281;
        const int32_t ***l_431 = &l_432;
        int32_t **l_438 = &g_238;
        int32_t ***l_437 = &l_438;
        int i, j, k;
        for (i = 0; i < 1; i++)
            l_400[i] = &l_401;
        for (g_44 = (-3); (g_44 < 6); g_44 += 1)
        { /* block id: 71 */
            uint32_t l_163 = 0x1AC7F9B7;
            int32_t l_186 = 0xDBDBAA6C;
            int32_t *l_194[2];
            struct S0 l_213 = {24,476,1,9647,-902,46,29755,0xD59B1659,3992};
            int32_t *l_264 = &l_42;
            int32_t ** const l_329 = &g_238;
            uint32_t ** const l_352 = &l_296;
            union U1 l_369 = {0x744D508F};
            int i;
            for (i = 0; i < 2; i++)
                l_194[i] = &g_132[4][3].f2;
            if (((l_163 = (l_162[5][0][2] != ((**g_75) = p_19))) , p_19))
            { /* block id: 74 */
                int32_t *l_164 = &g_132[4][3].f2;
                uint16_t *l_188 = &g_80;
                uint16_t *l_189 = (void*)0;
                uint16_t *l_190 = &g_78;
                int32_t *l_193 = &l_42;
                p_19 = ((*l_164) = ((&g_97 == &g_97) && ((0xBBD1 == l_162[8][0][3]) | ((**g_75) = (*g_76)))));
                if (((*l_193) = ((!(g_132[4][3].f8 && ((uint32_t)(p_19 == (((uint32_t)((int16_t)g_9[0] << (int16_t)(((*l_164) = (-1)) != (l_192 = ((int16_t)(((**g_75) = (((int16_t)((int16_t)(g_97 = ((int32_t)2 + (int32_t)(((((((((uint16_t)((uint16_t)0xD48A >> (uint16_t)0) - (uint16_t)((uint16_t)(l_187 = (l_186 = p_19)) << (uint16_t)((*l_190) = ((*l_188) = 0xA315)))) != (g_132[4][3].f4 && 0x5B8D)) & 0xBFDF) && p_19) >= g_132[4][3].f0) , g_132[4][3].f7) == l_191) , p_19))) - (int16_t)l_191) << (int16_t)p_19) >= 0xD74F)) != p_19) % (int16_t)g_21.f1)))) + (uint32_t)p_19) , p_19)) - (uint32_t)l_162[5][0][2]))) || 0x97607B9B)))
                { /* block id: 87 */
                    l_194[0] = (*g_75);
                    /* statement id: 88 */
                    //assert ((l_194[0] >= &g_13[0] && l_194[0] <= &g_13[5]) || (l_194[0] >= &g_132[0][0].f2 && l_194[0] <= &g_132[7][3].f2));
                }
                else
                { /* block id: 89 */
                    int32_t **l_195 = &l_194[1];
                    (*l_195) = &p_19;
                    /* statement id: 90 */
                    //assert (l_194[0] == &p_19 || (l_194[0] >= &g_132[0][0].f2 && l_194[0] <= &g_132[7][3].f2));
                }
                /* facts after branching */
                //assert (l_194[0] == &p_19 || (l_194[0] >= &g_132[0][0].f2 && l_194[0] <= &g_132[7][3].f2) || (l_194[0] >= &g_13[0] && l_194[0] <= &g_13[5]));
            }
            else
            { /* block id: 92 */
                uint32_t l_199 = 5U;
                int32_t ** const l_205 = &l_194[0];
                for (l_42 = 0; (l_42 >= 0); l_42 -= 1)
                { /* block id: 95 */
                    uint16_t *l_198 = &g_80;
                    int8_t l_200 = 0x3C;
                    uint32_t *l_206[7] = {&g_124[0],&g_124[0],&g_124[0],&g_124[0],&g_124[0],&g_124[0],&g_124[0]};
                    int32_t l_216[8] = {0,0,0,0,0,0,0,0};
                    int i;
                    if (((g_13[(l_42 + 4)] , (g_13[(l_42 + 4)] = ((l_191 > (((*l_198) = ((uint16_t)0U + (uint16_t)g_132[4][3].f4)) != ((l_199 , g_124[0]) != (l_200 , ((~(l_187 = ((-(int16_t)(((((uint16_t)((l_205 != &l_194[1]) & l_200) << (uint16_t)l_200) | 1U) == 0x49F5) != p_19)) && 6))) > g_132[4][3].f6))))) < l_207[9][0][1]))) >= 4294967292U))
                    { /* block id: 99 */
                        int32_t *l_208 = &g_13[0];
                        int i;
                        (*l_205) = l_208;
                        if (p_19)
                            continue;
                        g_13[(l_42 + 2)] = l_209[0][2];
                        return g_132[4][3].f1;
                    }
                    else
                    { /* block id: 104 */
                        if (p_19)
                            break;
                    }
                    if (p_19)
                        continue;
                    for (l_200 = 0; (l_200 >= 0); l_200 -= 1)
                    { /* block id: 110 */
                        int32_t l_210 = 0x810FC398;
                        int32_t **l_218 = &l_194[0];
                        int32_t ***l_219 = &g_100;
                        int i, j, k;
                    }
                }
                /* facts after for loop */
                //assert ((l_194[0] >= &g_13[0] && l_194[0] <= &g_13[5]) || (l_194[0] >= &g_132[0][0].f2 && l_194[0] <= &g_132[7][3].f2));
            }
            /* facts after branching */
            //assert (l_194[0] == &p_19 || (l_194[0] >= &g_132[0][0].f2 && l_194[0] <= &g_132[7][3].f2) || (l_194[0] >= &g_13[0] && l_194[0] <= &g_13[5]));
            for (g_21.f2 = 0; (g_21.f2 <= 11); g_21.f2 += 6)
            { /* block id: 123 */
                uint16_t *l_224 = &g_80;
                union U1 l_227 = {0x21EE263D};
                int32_t **l_228 = &l_194[0];
                int32_t ***l_229[2];
                struct S0 *l_233[10][4] = {{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]},{(void*)0,(void*)0,&g_132[4][3],&g_132[4][3]}};
                struct S0 **l_232 = &l_233[5][3];
                int32_t *l_234 = &l_158;
                int i, j;
                for (i = 0; i < 2; i++)
                    l_229[i] = &g_100;
                (*g_76) = 0;
                (*g_76) = (((*l_234) = (((*l_224) = g_9[0]) == ((g_9[0] >= ((int16_t)1 + (int16_t)((l_230 = (l_227 , l_228)) != (void*)0))) != (((*l_232) = &g_132[6][3]) == &g_132[4][3])))) , (((uint16_t)(((((*l_224) = 65528U) && 4) > 0x38E7) < p_19) << (uint16_t)3) > p_19));
                /* statement id: 130 */
                assert ((l_230 >= &l_194[0] && l_230 <= &l_194[1]));
                if ((*g_76))
                    continue;
            }
            /* facts after for loop */
            //assert ((l_230 >= &l_194[0] && l_230 <= &l_194[1]) || l_230 == dangling || l_230 == &l_231);
        }
        /* facts after for loop */
        //assert (l_230 == dangling || l_230 == &l_231);
        (**l_431) = l_449;
        /* statement id: 252 */
        assert ((g_281 >= &g_13[0] && g_281 <= &g_13[5]));
    }
    else
    { /* block id: 253 */
        (*l_230) = (*l_230);
    }
    /* facts after branching */
    //assert (l_230 == dangling || l_230 == &l_231);
    p_19 = (((int32_t)(((*l_459) = (((uint16_t)((*g_298) & (((l_454 == (void*)0) , (65527U == (~(((((p_19 < (((*l_449) = ((int16_t)((void*)0 != &g_100) * (int16_t)(((*g_20) , 1) == 0x9E21))) <= 0xA86B89AE)) <= (*l_231)) , &p_19) != &p_19) >= g_425.f0)))) && g_239)) << (uint16_t)g_124[0]) | 0x74A89FFA)) && (*l_459)) + (int32_t)0x20089DC0) , p_19);
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads : g_21.f1
 * writes:
 */
static int16_t  func_45(const union U1 ** p_46, int32_t * p_47, uint16_t * p_48, int16_t  p_49, const int32_t * p_50)
{ /* block id: 62 */
    const int32_t * const l_155 = &g_21.f2;
    const int32_t *l_157 = &g_9[0];
    const int32_t **l_156 = &l_157;
    (*l_156) = l_155;
    /* statement id: 63 */
    assert (l_157 == &g_21.f2);
    (*l_156) = (void*)0;
    /* statement id: 64 */
    assert (l_157 == 0);
    (*l_156) = (void*)0;
    return g_21.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_76 g_13 g_21.f2 g_132.f8
 * writes: g_124 g_13
 */
static uint16_t * func_53(union U1  p_54, int32_t ** p_55, union U1 * const  p_56)
{ /* block id: 56 */
    struct S0 *l_131 = &g_132[4][3];
    struct S0 **l_130 = &l_131;
    int32_t l_141 = 0;
    int32_t l_152 = (-1);
    uint32_t *l_153 = &g_124[0];
    uint16_t *l_154 = (void*)0;
    (*l_130) = (void*)0;
    /* statement id: 57 */
    assert (l_131 == 0);
    (*g_76) = (((int16_t)((uint32_t)((uint32_t)((*l_153) = ((g_9[0] ^ ((uint16_t)(((l_141 ^ l_141) <= ((l_152 = ((int16_t)p_54.f2 * (int16_t)((int16_t)(p_54.f0 , ((uint16_t)(l_141 & ((&g_51[1][7][1] != (((uint16_t)65532U % (uint16_t)(((uint16_t)((*g_76) || p_54.f1) - (uint16_t)l_141) ^ l_141)) , &g_51[1][5][0])) || p_54.f2)) % (uint16_t)l_141)) + (int16_t)g_13[3]))) & 0xD18442E1)) ^ (-1)) + (uint16_t)g_21.f2)) != (-6))) + (uint32_t)0x376E86CC) % (uint32_t)g_21.f2) >> (int16_t)g_132[4][3].f8) != 65535U);
    return l_154;
    /* statement id: 61 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_80 g_4 g_21.f1 g_76 g_78 g_100 g_13 g_21.f2
 * writes: g_78 g_80 g_86 g_97 g_13 g_124
 */
static int32_t ** func_57(int32_t ** p_58, uint32_t  p_59, union U1  p_60, int16_t  p_61)
{ /* block id: 30 */
    uint16_t l_72 = 0x56AC;
    uint16_t *l_77 = &g_78;
    uint16_t *l_79 = &g_80;
    int16_t *l_96 = &g_97;
    (**g_75) = ((p_59 > ((((((uint16_t)l_72 * (uint16_t)((*l_79) = ((int16_t)((void*)0 != g_75) >> (int16_t)((*l_77) = 0x6E1A)))) , func_81((g_86[0][7] = (void*)0), func_87(((((*g_76) = ((uint16_t)l_72 >> (uint16_t)((uint16_t)g_80 >> (uint16_t)(((int16_t)((*l_96) = g_4) << (int16_t)p_59) , g_21.f1)))) , l_72) <= g_78), l_72), g_21.f1, l_72)) ^ l_72) , g_21.f2) != l_72)) & l_72);
    return g_100;
    /* statement id: 55 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_64(int32_t  p_65, union U1 * p_66, uint32_t  p_67)
{ /* block id: 28 */
    int32_t l_68 = 1;
    return l_68;
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_75 g_76 g_78
 * writes: g_124 g_13 g_78
 */
inline static int16_t  func_81(union U1 * p_82, int32_t ** p_83, uint16_t  p_84, uint32_t  p_85)
{ /* block id: 39 */
    int16_t *l_106 = &g_97;
    int32_t l_107[6] = {(-1),(-1),(-1),(-1),(-1),(-1)};
    const union U1 **l_109 = &g_52[2];
    const union U1 ***l_108 = &l_109;
    uint32_t *l_123 = &g_124[0];
    int32_t l_125 = 0x61DB4512;
    int32_t *l_128 = &l_107[3];
    int32_t **l_129 = &l_128;
    int i;
    (**g_75) = (-(uint32_t)((uint16_t)((uint16_t)(l_107[2] = (l_106 != (void*)0)) * (uint16_t)(((*l_108) = &g_52[2]) != (void*)0)) >> (uint16_t)((uint16_t)(~(((((int16_t)(((int16_t)g_13[3] % (int16_t)((int32_t)(0xA0D2 > (((((int16_t)((uint32_t)((*l_123) = 0x448041AE) + (uint32_t)(p_84 == 6)) >> (int16_t)l_125) && 0x32BF) , (-1)) != l_125)) + (int32_t)0xAAEF5864)) >= l_125) >> (int16_t)l_125) || l_125) > 6U) && 0xC5F5551A)) << (uint16_t)l_125)));
    for (g_78 = 0; (g_78 <= 5); g_78 += 1)
    { /* block id: 46 */
        int32_t *l_127 = (void*)0;
        int32_t **l_126[6] = {&l_127,&l_127,&l_127,&l_127,&l_127,&l_127};
        int i;
        if (g_13[g_78])
            break;
        l_128 = &g_13[g_78];
        /* statement id: 48 */
        assert ((l_128 >= &g_13[0] && l_128 <= &g_13[5]));
        g_13[g_78] = (*l_128);
        return (*l_128);
    }
    (*l_129) = &l_107[1];
    return p_85;
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_76 g_100
 * writes:
 */
static int32_t ** func_87(int32_t  p_88, int32_t  p_89)
{ /* block id: 36 */
    int32_t *l_99[1];
    int32_t **l_98 = &l_99[0];
    int i;
    for (i = 0; i < 1; i++)
        l_99[i] = (void*)0;
    (*l_98) = (*g_75);
    /* statement id: 37 */
    //assert ((l_99[0] >= &g_13[0] && l_99[0] <= &g_13[5]) || l_99[0] == 0);
    return g_100;
    /* statement id: 38 */
    //assert (func_87_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    for (i = 0; i < 2; i++)
    {
        transparent_crc(g_9[i], "g_9[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 6; i++)
    {
        transparent_crc(g_13[i], "g_13[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_21.f0, "g_21.f0", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    transparent_crc(g_78, "g_78", print_hash_value);
    transparent_crc(g_80, "g_80", print_hash_value);
    transparent_crc(g_97, "g_97", print_hash_value);
    for (i = 0; i < 1; i++)
    {
        transparent_crc(g_124[i], "g_124[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 4; j++)
        {
            transparent_crc(g_132[i][j].f0, "g_132[i][j].f0", print_hash_value);
            transparent_crc(g_132[i][j].f1, "g_132[i][j].f1", print_hash_value);
            transparent_crc(g_132[i][j].f2, "g_132[i][j].f2", print_hash_value);
            transparent_crc(g_132[i][j].f3, "g_132[i][j].f3", print_hash_value);
            transparent_crc(g_132[i][j].f4, "g_132[i][j].f4", print_hash_value);
            transparent_crc(g_132[i][j].f5, "g_132[i][j].f5", print_hash_value);
            transparent_crc(g_132[i][j].f6, "g_132[i][j].f6", print_hash_value);
            transparent_crc(g_132[i][j].f7, "g_132[i][j].f7", print_hash_value);
            transparent_crc(g_132[i][j].f8, "g_132[i][j].f8", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_239, "g_239", print_hash_value);
    transparent_crc(g_408, "g_408", print_hash_value);
    transparent_crc(g_425.f0, "g_425.f0", print_hash_value);
    transparent_crc(g_425.f1, "g_425.f1", print_hash_value);
    transparent_crc(g_425.f2, "g_425.f2", print_hash_value);
    transparent_crc(g_425.f3, "g_425.f3", print_hash_value);
    transparent_crc(g_425.f4, "g_425.f4", print_hash_value);
    transparent_crc(g_425.f5, "g_425.f5", print_hash_value);
    transparent_crc(g_425.f6, "g_425.f6", print_hash_value);
    transparent_crc(g_425.f7, "g_425.f7", print_hash_value);
    transparent_crc(g_425.f8, "g_425.f8", print_hash_value);
    transparent_crc(g_464, "g_464", print_hash_value);
    transparent_crc(g_476, "g_476", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 102
   depth: 1, occurrence: 4
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 4
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 28
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 17
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 30

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 12
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 144

XXX times a variable address is taken: 289
XXX times a pointer is dereferenced on RHS: 50
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 14
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 526

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 324
   level: 2, occurrence: 74
   level: 3, occurrence: 1
XXX number of pointers point to pointers: 68
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 31.2
XXX average alias set size: 1.35

XXX times a non-volatile is read: 432
XXX times a non-volatile is write: 274
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 67
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 12
   depth: 2, occurrence: 7
   depth: 3, occurrence: 6
   depth: 4, occurrence: 5
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

