/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1884097199
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_27(void);
static uint32_t  func_39(int64_t  p_40, uint32_t  p_41, uint32_t  p_42, uint16_t  p_43, int64_t  p_44);
static uint64_t  func_58(uint8_t  p_59, uint8_t  p_60, float  p_61, int16_t  p_62);
inline static uint16_t  func_66(uint32_t  p_67, int32_t  p_68, float  p_69, int64_t  p_70, int64_t  p_71);
static int32_t  func_76(uint32_t  p_77, uint8_t  p_78, uint16_t  p_79);
static uint32_t  func_80(int16_t  p_81, float  p_82);
inline static float  func_84(int64_t  p_85, uint16_t  p_86, int32_t  p_87, uint32_t  p_88);
static const int16_t  func_98(const int32_t  p_99, float  p_100, const uint16_t  p_101, uint16_t  p_102);
inline static uint64_t  func_103(uint8_t  p_104);
static uint8_t  func_105(int32_t  p_106, int64_t  p_107, int32_t  p_108, uint32_t  p_109, float  p_110);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28 = (-8L);
    int32_t * const **l_594 = (void*)0;
    int32_t l_610 = 0x87168DBBL;
    float l_611 = 0xB.66918Ap-42;
    float *l_614 = &l_611;
    const int32_t *l_617 = (void*)0;
    const int32_t ** const l_616 = &l_617;
    const uint16_t l_620 = 0x3BAAL;
    float ****l_622 = (void*)0;
    float **l_627 = &l_614;
    float ***l_626 = &l_627;
    for (l_28 = 0; (l_28 <= 29); l_28++)
    { /* block id: 39 */
        int32_t l_31 = 0x695998ABL;
        int32_t *l_598 = &l_28;
        int32_t ** const l_597 = &l_598;
        int32_t ** const *l_596 = &l_597;
        int32_t ** const ** const l_595 = &l_596;
        uint32_t l_599 = 0x7C63EB3CL;
        for (l_31 = (-6); (l_31 <= 23); l_31 += 4)
        { /* block id: 42 */
            uint64_t l_34 = 0x7C6AE49A2F3817D1LL;
            int32_t l_525 = (-1L);
            if (((l_34 != ((-1L) && (((uint32_t)(((uint32_t)func_39(((((uint32_t)l_34 % (uint32_t)((~((uint32_t)((uint64_t)18446744073709551615UL + (uint64_t)(l_34 && l_34)) + (uint32_t)((int64_t)((int32_t)(((int16_t)l_34 >> (int16_t)__builtin_bswap64((l_34 > func_58(l_28, l_31, l_31, l_28)))) ^ l_34) - (int32_t)0x80C358FEL) % (int64_t)l_31))) & l_34)) | l_31) ^ l_31), l_28, l_34, l_28, l_525) % (uint32_t)l_31) >= l_28) - (uint32_t)l_31) > l_525))) && 0x399931F43052055CLL))
            { /* block id: 324 */
                int32_t *l_555 = (void*)0;
                int32_t **l_554 = &l_555;
                int32_t l_557 = 0x89B81121L;
                int32_t *l_556 = &l_557;
                (*l_554) = &l_31;
                /* statement id: 325 */
                assert (l_555 == &l_31);
                (*l_556) = l_34;
            }
            else
            { /* block id: 327 */
                const uint8_t l_565 = 0UL;
                uint16_t l_568 = 0xD27EL;
                int32_t *l_586 = &l_31;
                int32_t * const **l_593 = (void*)0;
                float l_601 = 0x0.C49C91p+8;
                float *l_600 = &l_601;
                if ((~((int64_t)l_28 * (int64_t)(((uint64_t)l_28 - (uint64_t)l_31) < __builtin_ffsl((((int16_t)__builtin_popcountll(func_98(l_28, ((l_565 == (((-0x1.9p-1) > l_565) >= ((float)l_565 - (float)l_565))) <= l_565), l_31, l_565)) >> (int16_t)11) && l_31))))))
                { /* block id: 328 */
                    const uint32_t l_573 = 0UL;
                    l_568 = 0x8.83ECCFp-1;
                    if (l_28)
                        goto lbl_615;
                    for (l_525 = 0; (l_525 == (-17)); l_525 -= 1)
                    { /* block id: 332 */
                        int32_t *l_572 = &l_28;
                        int32_t **l_571 = &l_572;
                        (*l_571) = (void*)0;
                        /* statement id: 333 */
                        assert (l_572 == 0);
                    }
                    if (l_573)
                        continue;
                }
                else
                { /* block id: 336 */
                    int16_t l_579 = 0x4BD6L;
                    int32_t l_588 = (-1L);
                    int32_t *l_587 = &l_588;
                    float l_590 = 0x6.3070F6p+1;
                    float *l_589 = &l_590;
                    for (l_568 = 23; (l_568 <= 58); l_568 += 9)
                    { /* block id: 339 */
                        const int32_t **l_583 = (void*)0;
                        const int32_t ***l_582 = &l_583;
                        int32_t l_585 = 0xC6820D95L;
                        int32_t *l_584 = &l_585;
                        (*l_584) = (((uint16_t)(~l_579) % (uint16_t)((uint64_t)l_31 + (uint64_t)l_34)) != __builtin_clz(((l_582 == (void*)0) > l_568)));
                        l_587 = l_586;
                        /* statement id: 341 */
                        assert (l_587 == &l_31);
                    }
                    /* facts after for loop */
                    assert (l_587 == &l_31 || l_587 == &l_588);
                    (*l_589) = 0x5.Fp-1;
                }
                (*l_600) = (((*l_586) < (l_31 >= l_525)) < ((((float)(l_593 != l_594) + (float)l_31) > (((l_28 < (((((void*)0 == l_595) == l_525) >= l_34) == (*l_586))) >= 0x4.25A87Ap-7) != 0xD.FAFED6p-29)) <= l_599));
                (*l_600) = ((float)((0x1.4p-1 < (*l_586)) <= (***l_596)) / (float)(*l_586));
            }
        }
    }
lbl_615:
    (*l_614) = ((float)0xB.F6DFB7p+67 - (float)((((((float)(l_594 == l_594) + (float)l_28) >= ((float)l_610 + (float)(((func_76(l_610, ((int16_t)l_610 - (int16_t)l_610), l_28) <= l_610) == 0x0.4p+1) >= l_28))) > l_28) > 0x7.D77E03p-41) != l_610));
    if (((l_616 != (void*)0) > ((uint64_t)l_620 + (uint64_t)(~(((0UL && l_620) & (((l_620 != (l_622 != l_622)) ^ (-3L)) != l_610)) | 0x6C19286BL)))))
    { /* block id: 352 */
        float l_623 = 0x0.Fp+1;
        int32_t l_624 = 1L;
        int32_t l_625 = (-1L);
        const float ****l_628 = (void*)0;
        float ****l_629 = &l_626;
        int32_t *l_636 = &l_624;
        int32_t **l_635 = &l_636;
        int32_t ***l_634 = &l_635;
        int32_t ****l_633 = &l_634;
        int32_t *****l_632 = &l_633;
        (*l_614) = (__builtin_popcount(l_624) != __builtin_ctzll(l_625));
        (*l_629) = l_626;
        (*l_636) = ((uint32_t)(l_632 == &l_633) / (uint32_t)(***l_634));
        l_632 = &l_633;
    }
    else
    { /* block id: 357 */
        uint64_t l_639 = 0x4E886D127626F0A0LL;
        int32_t *l_646 = &l_610;
        float **l_647 = &l_614;
        (*l_646) = ((uint16_t)(l_639 < ((uint16_t)l_639 + (uint16_t)(((((int16_t)l_639 / (int16_t)(l_639 | l_639)) ^ l_610) > ((int64_t)((void*)0 != &l_626) + (int64_t)((l_639 != (-1L)) != (-8L)))) ^ 3L))) % (uint16_t)0xD788L);
        (**l_627) = (*l_646);
        (*l_626) = l_647;
    }
    return l_620;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_39(int64_t  p_40, uint32_t  p_41, uint32_t  p_42, uint16_t  p_43, int64_t  p_44)
{ /* block id: 305 */
    float l_529 = 0x7.39B658p+80;
    float *l_528 = &l_529;
    float **l_527 = &l_528;
    float *** const l_526 = &l_527;
    float * const *l_532 = &l_528;
    float * const **l_531 = &l_532;
    float * const ***l_530 = &l_531;
    int32_t l_542 = 0xD3AD992BL;
    int32_t *l_553 = &l_542;
    (*l_530) = l_526;
    /* statement id: 306 */
    assert (l_531 == &l_527);
    for (p_44 = 0; (p_44 > (-20)); p_44 -= 2)
    { /* block id: 309 */
        uint8_t l_535 = 5UL;
        const float *l_544 = &l_529;
        const float **l_543 = &l_544;
        const int32_t *l_552 = (void*)0;
        const int32_t **l_551 = &l_552;
        (***l_526) = 0x5.A7CCC5p-74;
        (***l_531) = 0x0.4p+1;
        if ((((__builtin_clzll(l_535) != ((int64_t)p_41 / (int64_t)((int16_t)0xDB83L - (int16_t)(0L ^ p_43)))) && p_42) != (18446744073709551609UL != (((int64_t)l_542 + (int64_t)l_535) | l_535))))
        { /* block id: 312 */
            return p_44;
        }
        else
        { /* block id: 314 */
            float * const **l_545 = &l_532;
            float *****l_546 = (void*)0;
            float * const ****l_547 = &l_530;
            int32_t *l_549 = (void*)0;
            int32_t **l_548 = &l_549;
            int32_t **l_550 = &l_549;
            (*l_545) = l_543;
            /* statement id: 315 */
            assert (l_532 == &l_544);
            (*l_547) = &l_545;
            /* statement id: 316 */
            assert (l_530 == &l_545);
            (*l_548) = &l_542;
            /* statement id: 317 */
            assert (l_549 == &l_542);
            (*l_550) = l_544;
            /* statement id: 318 */
            assert (l_549 == &l_529);
        }
        /* facts after branching */
        assert (l_532 == &l_544);
        //assert (l_530 == dangling);
        (*l_551) = l_544;
        /* statement id: 320 */
        assert (l_552 == &l_529);
    }
    /* facts after for loop */
    //assert (l_532 == dangling || l_532 == &l_528);
    //assert (l_530 == dangling || l_530 == &l_531);
    (*l_553) = l_542;
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_58(uint8_t  p_59, uint8_t  p_60, float  p_61, int16_t  p_62)
{ /* block id: 43 */
    uint32_t l_63 = 0x7BC41BBBL;
    float l_521 = (-0x1.1p-1);
    float *l_520 = &l_521;
    int32_t l_524 = 0L;
    int32_t *l_523 = &l_524;
    int32_t **l_522 = &l_523;
    (*l_520) = ((((((((l_63 < __builtin_ia32_crc32qi(p_59, (((l_63 < __builtin_clzl(p_60)) != ((uint32_t)(l_63 ^ ((func_66(l_63, l_63, ((float)0x9.Dp+1 + (float)0xC.321248p+99), p_60, p_60) < p_62) == p_62)) - (uint32_t)p_62)) || 0UL))) <= l_63) <= p_59) != p_60) != 0x7.78A6BCp+44) >= (-0x10.6p-1)) >= 0x8.18A35Bp+30) > (-0x1.1p+1));
    (*l_522) = l_520;
    /* statement id: 302 */
    assert (l_523 == &l_521);
    (*l_522) = (*l_522);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_66(uint32_t  p_67, int32_t  p_68, float  p_69, int64_t  p_70, int64_t  p_71)
{ /* block id: 44 */
    uint8_t l_83 = 1UL;
    int32_t l_447 = 0xC15D356DL;
    int32_t *l_446 = &l_447;
    int32_t **l_445 = &l_446;
    int32_t ***l_444 = &l_445;
    int32_t ****l_443 = &l_444;
    float l_466 = 0x9.283E6Bp+94;
    float *l_465 = &l_466;
    float ** const l_464 = &l_465;
    int32_t *l_519 = (void*)0;
    for (p_71 = (-13); (p_71 <= 23); p_71 += 5)
    { /* block id: 47 */
        int16_t l_91 = 9L;
        int32_t ***l_450 = &l_445;
        int32_t l_463 = 6L;
        float *l_489 = &l_466;
    }
    (**l_464) = (&l_465 != (void*)0);
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_76(uint32_t  p_77, uint8_t  p_78, uint16_t  p_79)
{ /* block id: 220 */
    int32_t l_408 = 0x6F96F315L;
    int32_t *l_409 = (void*)0;
    int32_t l_411 = 9L;
    int32_t *l_410 = &l_411;
    (*l_410) = ((5UL == ((int16_t)(l_408 < l_408) / (int16_t)p_77)) | 0x6071DF99L);
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_80(int16_t  p_81, float  p_82)
{ /* block id: 217 */
    float l_395 = 0xF.3499C1p+89;
    int32_t ** const **l_397 = (void*)0;
    int32_t ** const ***l_396 = &l_397;
    int32_t l_400 = 1L;
    float *l_405 = &l_395;
    (*l_405) = ((0x0.0p-1 >= ((((float)(l_395 > (((void*)0 == l_396) > ((float)((0x2.6p-1 < p_81) > (p_81 == l_400)) / (float)(((float)(((float)((-0x1.Ep-1) == p_82) / (float)p_82) > p_82) + (float)p_81) == p_82)))) - (float)l_400) > p_82) < p_82)) < 0x4.D022B8p-80);
    return p_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_84(int64_t  p_85, uint16_t  p_86, int32_t  p_87, uint32_t  p_88)
{ /* block id: 200 */
    float l_359 = (-0x2.0p-1);
    int32_t l_360 = 1L;
    uint32_t l_365 = 0x9ECAB78EL;
    int32_t *l_366 = &l_360;
    int32_t **l_367 = &l_366;
    uint32_t l_376 = 0x76BA7692L;
    (*l_366) = (0x238936EF0B126F15LL & func_98((((((0x02B0B88BL ^ l_360) || ((int32_t)(0x539E2D7B22F36016LL >= ((int16_t)p_86 >> (int16_t)((p_88 < (((p_88 ^ p_88) != (__builtin_ctz(func_98(l_360, l_360, p_86, p_85)) <= p_88)) && l_360)) | 0x3DFE33E5L))) + (int32_t)3UL)) < p_86) && l_360) ^ 0UL), l_365, l_365, p_86));
    l_366 = &l_360;
    (*l_367) = &p_87;
    /* statement id: 203 */
    assert (l_366 == &p_87);
    if (p_87)
    { /* block id: 204 */
        uint64_t l_379 = 0xF01F714449521B49LL;
        int32_t l_381 = (-1L);
        for (p_87 = (-18); (p_87 >= 7); ++p_87)
        { /* block id: 207 */
            uint8_t l_380 = 255UL;
            float *l_382 = (void*)0;
            float *l_383 = &l_359;
            (*l_383) = (((float)func_105(p_87, ((uint32_t)(&l_367 == (void*)0) / (uint32_t)func_98(p_87, func_103((((-1L) | ((uint16_t)8UL >> (uint16_t)((l_376 && ((uint16_t)__builtin_ffsl(p_86) >> (uint16_t)l_379)) && (**l_367)))) | 9L)), p_88, p_85)), p_88, l_380, l_379) / (float)l_381) == 0x3.C65A41p-32);
            if (p_87)
                goto lbl_384;
        }
lbl_384:
        (*l_367) = (*l_367);
        return p_85;
    }
    else
    { /* block id: 213 */
        const int32_t l_387 = 0xF9AE73C0L;
        (**l_367) = ((uint16_t)6UL >> (uint16_t)func_98(l_387, (((*l_366) <= ((-0x9.9p-1) >= ((float)((float)p_87 - (float)((!0xF.744170p+52) < (-0x2.2p-1))) / (float)(l_387 == (0x2.Dp-1 == p_87))))) == (**l_367)), p_86, p_85));
    }
    return p_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_98(const int32_t  p_99, float  p_100, const uint16_t  p_101, uint16_t  p_102)
{ /* block id: 114 */
    uint32_t l_198 = 5UL;
    int32_t l_210 = 0x0568E968L;
    int32_t *l_209 = &l_210;
    int32_t **l_244 = &l_209;
    int32_t ***l_243 = &l_244;
    int32_t ****l_242 = &l_243;
    float l_346 = 0xF.7BF9E3p-34;
    float *l_345 = &l_346;
    float **l_344 = &l_345;
    if ((0x79523B59L != p_101))
    { /* block id: 115 */
        int32_t l_204 = 0x303744F0L;
        int32_t **** const *l_233 = (void*)0;
        float l_271 = 0x5.293DCFp+69;
        float *l_270 = &l_271;
        if (l_198)
        { /* block id: 116 */
            int32_t * const * const l_223 = &l_209;
            int32_t * const * const *l_222 = &l_223;
            int64_t l_250 = 0x7B1A39021D3DD3D9LL;
            for (p_102 = 0; (p_102 >= 27); ++p_102)
            { /* block id: 119 */
                int16_t l_201 = 0xD17DL;
                int32_t **l_249 = (void*)0;
                if (l_201)
                { /* block id: 120 */
                    uint64_t l_219 = 0x1912E77BBAC150E4LL;
                    int32_t ****l_224 = (void*)0;
                    if (((uint16_t)l_204 - (uint16_t)((int16_t)(((void*)0 != l_209) && (l_209 == l_209)) >> (int16_t)((int16_t)func_103(((uint16_t)((uint16_t)(p_102 ^ ((int32_t)l_219 + (int32_t)1UL)) / (uint16_t)((int16_t)(((void*)0 == l_222) < p_101) << (int16_t)(*l_209))) - (uint16_t)l_219)) / (int16_t)p_102))))
                    { /* block id: 121 */
                        int32_t * const *l_228 = &l_209;
                        int32_t * const ** const l_227 = &l_228;
                        int32_t * const ** const *l_226 = &l_227;
                        int32_t * const ** const **l_225 = &l_226;
                        (*l_225) = l_224;
                        /* statement id: 122 */
                        assert (l_226 == 0);
                        (**l_223) = ((*l_223) != (*l_223));
                    }
                    else
                    { /* block id: 124 */
                        float l_230 = (-0x1.Bp+1);
                        float *l_229 = &l_230;
                        (*l_229) = func_103((***l_222));
                    }
                    (**l_223) = (-1L);
                }
                else
                { /* block id: 128 */
                    int64_t l_237 = 6L;
                    int32_t ** const **l_245 = (void*)0;
                    l_237 = ((2UL >= (((int16_t)p_99 >> (int16_t)(((__builtin_ctz(((l_233 == (void*)0) ^ (p_99 > (***l_222)))) > (((uint16_t)(+1UL) / (uint16_t)__builtin_parity((p_101 | (**l_223)))) & p_102)) >= p_101) ^ l_201)) > 0x62CD2BE794583706LL)) ^ l_201);
                    l_250 = (((float)(**l_223) / (float)(0x5.265664p+17 > ((float)(l_242 != l_245) - (float)((float)(!((void*)0 == (*l_243))) / (float)(l_249 != (*l_243)))))) == 0x5.963902p+29);
                    (*l_209) = func_103(((((p_101 ^ (((uint32_t)(0L < 0xFEDFDEECL) - (uint32_t)p_99) & (!(*l_209)))) >= ((**l_223) ^ __builtin_ctzll(p_101))) & (***l_222)) || 1UL));
                    for (l_204 = (-20); (l_204 > 4); l_204 += 6)
                    { /* block id: 134 */
                        int32_t * const l_256 = (void*)0;
                        int32_t **l_257 = &l_209;
                        (*l_257) = l_256;
                        /* statement id: 135 */
                        assert (l_209 == 0);
                        return p_102;
                    }
                }
                (*l_244) = &l_204;
                /* statement id: 139 */
                assert (l_209 == &l_204);
                (****l_242) = l_204;
            }
            /* facts after for loop */
            assert (l_209 == &l_204 || l_209 == &l_210);
        }
        else
        { /* block id: 142 */
            const int64_t l_266 = 0x53064252A57B08C6LL;
            for (l_198 = 0; (l_198 > 5); l_198++)
            { /* block id: 145 */
                float l_262 = 0x6.9C36F5p-85;
                int32_t l_263 = (-1L);
                float *l_269 = &l_262;
            }
            (**l_243) = (*l_244);
        }
        /* facts after branching */
        assert (l_209 == &l_204 || l_209 == &l_210);
        (*l_270) = func_105(p_101, (*l_209), (***l_243), p_99, (*l_209));
    }
    else
    { /* block id: 154 */
        int32_t **l_272 = &l_209;
        int32_t *l_285 = &l_210;
        int32_t **** const l_318 = &l_243;
        float *l_343 = (void*)0;
        float **l_342 = &l_343;
        l_272 = (**l_242);
        if (((func_103(__builtin_ffs(p_99)) ^ ((int16_t)p_101 >> (int16_t)8)) < p_101))
        { /* block id: 156 */
            const int32_t *l_281 = &l_210;
            const int32_t **l_280 = &l_281;
            const int32_t ***l_279 = &l_280;
            float *l_302 = (void*)0;
            float *l_303 = (void*)0;
            float *l_304 = (void*)0;
            float l_306 = 0xE.4D1DA3p+7;
            float *l_305 = &l_306;
            if ((p_101 > (**l_272)))
            { /* block id: 157 */
                int32_t ***l_282 = (void*)0;
                if (((uint32_t)__builtin_popcount(p_99) + (uint32_t)(((int32_t)(l_279 != l_282) % (int32_t)((uint16_t)(l_285 == (*l_280)) >> (uint16_t)4)) <= (((uint16_t)((p_99 != 1L) <= (*l_285)) / (uint16_t)65535UL) == (**l_244)))))
                { /* block id: 158 */
                    (*l_209) = (func_105((+(*l_285)), (***l_279), (**l_244), (***l_243), p_102) && (*l_285));
                }
                else
                { /* block id: 160 */
                    (**l_279) = (*l_280);
                }
            }
            else
            { /* block id: 163 */
                int64_t l_295 = 0x9A8096413723CBD7LL;
                float l_297 = 0x1.Ap+1;
                float *l_296 = &l_297;
                (*l_296) = ((float)(((float)p_102 - (float)((void*)0 == (*l_272))) == ((((-0x2.2p+1) > p_99) == ((float)(****l_242) / (float)p_100)) <= ((*l_272) != (***l_242)))) - (float)l_295);
            }
            (*l_305) = ((float)p_101 - (float)((float)(**l_272) - (float)(0x6.ACF918p-55 <= (0x1.Dp+1 >= 0xB.5255F6p-96))));
            (*l_305) = (l_209 == (void*)0);
            (*l_280) = (*l_280);
        }
        else
        { /* block id: 169 */
            uint32_t l_314 = 0x89DC9810L;
            float **l_358 = &l_345;
            if (func_103(p_99))
            { /* block id: 170 */
                float l_310 = (-0x6.Dp+1);
                float *l_309 = &l_310;
                (*l_309) = ((float)0x1.4F20DAp-88 - (float)p_101);
            }
            else
            { /* block id: 172 */
                uint32_t l_315 = 0xDCBC17C5L;
                int32_t *** const *l_319 = (void*)0;
                float l_321 = 0xC.2E4D6Ap-77;
                float *l_320 = &l_321;
                int32_t l_328 = 0x7101A332L;
                (**l_272) = ((~(((int16_t)p_102 % (int16_t)l_314) == ((**l_272) == ((((p_101 || l_315) == ((int16_t)(l_318 != l_319) >> (int16_t)(****l_242))) <= (p_99 != p_101)) > p_99)))) > 0x01ABF97DL);
                (*l_320) = __builtin_parityl(((void*)0 != (*l_244)));
                if ((0x468E3BE8019E2E31LL | ((~(-(uint32_t)p_102)) || (((uint16_t)((uint64_t)(p_102 <= __builtin_ctzll(p_101)) % (uint64_t)(***l_243)) >> (uint16_t)13) | __builtin_popcountl(l_314)))))
                { /* block id: 175 */
                    if ((*l_209))
                    { /* block id: 176 */
                        l_328 = 8L;
                    }
                    else
                    { /* block id: 178 */
                        int32_t l_337 = 1L;
                        (***l_318) = (*l_272);
                        (*l_209) = (7L != ((int16_t)((uint16_t)((uint16_t)((-(uint32_t)5UL) & 0xE76953BFL) << (uint16_t)(~l_337)) + (uint16_t)p_101) << (int16_t)((int64_t)(&l_319 != (void*)0) / (int64_t)p_99)));
                        p_100 = ((float)((&l_318 == (void*)0) < p_101) - (float)0x5.419D22p-67);
                        l_344 = l_342;
                        /* statement id: 182 */
                        assert (l_344 == &l_343);
                    }
                    /* facts after branching */
                    assert (l_344 == &l_343 || l_344 == &l_345);
                    for (l_315 = 0; (l_315 < 5); l_315++)
                    { /* block id: 186 */
                        return p_102;
                    }
                }
                else
                { /* block id: 189 */
                    (****l_318) = p_102;
                    (**l_344) = (p_99 > ((float)0x0.Cp-1 - (float)0xB.E14E52p-40));
                }
                /* facts after branching */
                assert (l_344 == &l_343 || l_344 == &l_345);
                (*l_345) = ((**l_318) != (void*)0);
            }
            /* facts after branching */
            assert (l_344 == &l_343 || l_344 == &l_345);
            (****l_318) = ((((-(uint64_t)(****l_318)) == (((int64_t)1L + (int64_t)(*l_285)) & ((func_103((****l_318)) < ((int32_t)(((int16_t)((&l_243 == (void*)0) == ((l_358 != (void*)0) == (****l_318))) >> (int16_t)4) && l_314) / (int32_t)(*l_209))) ^ 0x247DC22DL))) <= p_102) | (****l_318));
        }
        /* facts after branching */
        assert (l_344 == &l_343 || l_344 == &l_345);
        (**l_243) = (void*)0;
        /* statement id: 197 */
        assert (l_209 == 0);
    }
    /* facts after branching */
    //assert (l_209 == 0 || l_209 == dangling || l_209 == &l_210);
    //assert (l_344 == dangling || l_344 == &l_345);
    return p_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_103(uint8_t  p_104)
{ /* block id: 68 */
    int16_t l_155 = 1L;
    float l_162 = 0x4.EE097Ep-54;
    float *l_161 = &l_162;
    int32_t l_178 = 0x78BB94ACL;
    int32_t *l_177 = &l_178;
    int32_t **l_176 = &l_177;
    (*l_161) = (!(((float)func_105(l_155, (p_104 != 0x8C9807A6E463D775LL), (l_155 || ((int64_t)((int16_t)((9UL < p_104) != ((l_155 <= ((((((~p_104) | 0x6915L) > l_155) <= l_155) != p_104) & 0UL)) && p_104)) << (int16_t)l_155) / (int64_t)p_104)), l_155, p_104) / (float)0xF.4CE628p-46) != l_155));
    for (p_104 = 18; (p_104 != 42); p_104 += 8)
    { /* block id: 72 */
        int32_t **l_165 = (void*)0;
        int32_t **l_166 = (void*)0;
        int32_t l_168 = 0xD1CD03ADL;
        int32_t *l_167 = &l_168;
        l_167 = l_161;
        /* statement id: 73 */
        assert (l_167 == &l_162);
    }
    if (((func_105((-(int16_t)((void*)0 != l_161)), l_155, (l_155 < (((int16_t)(-1L) << (int16_t)((-1L) && ((int16_t)p_104 >> (int16_t)l_155))) ^ (((uint16_t)(l_155 >= l_155) << (uint16_t)11) ^ l_155))), p_104, l_155) >= 0x2C95206BL) >= p_104))
    { /* block id: 75 */
        uint32_t l_181 = 4294967295UL;
        int16_t l_192 = 1L;
        if ((((void*)0 == l_176) == 18446744073709551615UL))
        { /* block id: 76 */
            uint64_t l_183 = 0x159D6D56307DCF4CLL;
            int32_t ** const *l_190 = &l_176;
            if (((uint32_t)__builtin_ffsll(p_104) % (uint32_t)(((l_181 ^ (~p_104)) && 1UL) ^ (l_181 > (func_105((**l_176), p_104, l_183, p_104, p_104) < 0xC2794937L)))))
            { /* block id: 77 */
                (**l_176) = __builtin_parityl(p_104);
            }
            else
            { /* block id: 79 */
                int32_t *l_186 = &l_178;
                int32_t ** const *l_191 = &l_176;
                for (l_155 = 0; (l_155 >= (-9)); l_155--)
                { /* block id: 82 */
                    int32_t *l_187 = &l_178;
                    l_187 = l_186;
                    if (p_104)
                        continue;
                    for (l_178 = 5; (l_178 == 11); ++l_178)
                    { /* block id: 87 */
                        (*l_161) = 0xA.00D8DAp+33;
                        if (l_181)
                            goto lbl_195;
                        if (p_104)
                            continue;
                        l_191 = l_190;
                        (*l_161) = p_104;
                    }
                }
                return p_104;
            }
            (*l_177) = __builtin_clzll(l_192);
        }
        else
        { /* block id: 97 */
            return p_104;
        }
lbl_195:
        for (l_181 = 0; (l_181 != 52); l_181 += 1)
        { /* block id: 102 */
            (*l_176) = (*l_176);
        }
        (*l_161) = func_105(p_104, (**l_176), l_192, p_104, l_192);
        (*l_176) = (void*)0;
        /* statement id: 107 */
        assert (l_177 == 0);
    }
    else
    { /* block id: 108 */
        int32_t * const l_196 = &l_178;
        int32_t *l_197 = &l_178;
        (*l_176) = (*l_176);
        (*l_177) = __builtin_parityll((*l_177));
        l_197 = l_196;
    }
    /* facts after branching */
    assert (l_177 == &l_178 || l_177 == 0);
    return p_104;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_105(int32_t  p_106, int64_t  p_107, int32_t  p_108, uint32_t  p_109, float  p_110)
{ /* block id: 48 */
    int32_t l_112 = 0xAFF67138L;
    const int32_t *l_111 = &l_112;
    int32_t *l_114 = &l_112;
    int32_t **l_113 = &l_114;
    uint64_t l_115 = 0x57033C9969097B38LL;
    int32_t **l_126 = &l_114;
lbl_148:
    (*l_113) = l_111;
    if (p_108)
    { /* block id: 50 */
        int32_t *l_116 = &l_112;
        (**l_113) = l_115;
        l_116 = (*l_113);
        (*l_114) = (p_106 || (**l_113));
    }
    else
    { /* block id: 54 */
        float l_118 = 0x5.DB2440p+32;
        float *l_117 = &l_118;
        int32_t ***l_127 = &l_126;
        (*l_117) = p_108;
        (**l_113) = ((-1L) >= __builtin_clzll((((int64_t)(-1L) + (int64_t)((int64_t)(*l_111) - (int64_t)__builtin_ffsl((((uint32_t)p_109 - (uint32_t)(~((l_126 == (void*)0) & ((**l_126) < p_107)))) < (**l_113))))) == (**l_126))));
        (*l_127) = &l_114;
        (*l_117) = 0x1.4p-1;
    }
    if (((uint16_t)(((int16_t)1L + (int16_t)((uint16_t)p_108 + (uint16_t)__builtin_ctz((*l_114)))) || (((uint32_t)((int32_t)p_108 + (int32_t)(0x7B4C6B90ED9ABD1ALL && ((*l_111) | (!p_106)))) - (uint32_t)(((uint64_t)((int16_t)((int32_t)((!(p_108 <= (**l_126))) != (*l_111)) + (int32_t)p_109) << (int16_t)(**l_126)) % (uint64_t)(**l_113)) != (*l_111))) <= 0x5B57L)) + (uint16_t)0xF243L))
    { /* block id: 60 */
        int32_t *l_149 = &l_112;
        int32_t ***l_150 = &l_113;
        if (l_112)
            goto lbl_148;
        (*l_126) = l_149;
        (*l_150) = &l_149;
        /* statement id: 63 */
        assert (l_113 == &l_149);
    }
    else
    { /* block id: 64 */
        int32_t *l_151 = (void*)0;
        l_151 = (void*)0;
    }
    /* facts after branching */
    //assert (l_113 == &l_114 || l_113 == dangling);
    return p_107;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 121
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 179
   depth: 2, occurrence: 28
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 2
   depth: 30, occurrence: 1

XXX total number of pointers: 144

XXX times a variable address is taken: 133
XXX times a pointer is dereferenced on RHS: 110
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 25
   depth: 3, occurrence: 22
   depth: 4, occurrence: 8
XXX times a pointer is dereferenced on LHS: 102
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 21
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 298

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 152
   level: 2, occurrence: 62
   level: 3, occurrence: 32
   level: 4, occurrence: 11
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 65
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.3
XXX average alias set size: 1.16

XXX times a non-volatile is read: 833
XXX times a non-volatile is write: 287
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 1

XXX stmts: 153
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 40
   depth: 2, occurrence: 21
   depth: 3, occurrence: 18
   depth: 4, occurrence: 21
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
********************* end of statistics **********************/

