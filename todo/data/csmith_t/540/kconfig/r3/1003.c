/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3216957200
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 22;
   unsigned f1 : 19;
   unsigned f2 : 9;
   unsigned f3 : 17;
   int32_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0xCF54C3C6;
static int16_t g_34 = 0x9B85;
static struct S0 g_56 = {-600,262,10,345,0x705104E0};
static uint16_t g_94 = 65526U;
static struct S0 g_109 = {188,213,12,128,-5};
static uint16_t g_211 = 0xD84F;
static uint16_t g_259 = 0xDA77;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_26(void);
static int16_t  func_27(int16_t  p_28, int32_t  p_29, int32_t  p_30, int16_t  p_31);
static uint16_t  func_36(uint32_t  p_37, int32_t  p_38, uint16_t  p_39);
static struct S0  func_52(uint32_t  p_53, int32_t  p_54);
static int32_t  func_59(uint32_t  p_60, uint32_t  p_61, uint32_t  p_62);
static int32_t  func_63(uint32_t  p_64);
static uint32_t  func_65(struct S0  p_66);
static uint32_t  func_69(uint32_t  p_70, uint32_t  p_71);
static int32_t  func_72(struct S0  p_73);
static uint16_t  func_75(int32_t  p_76, struct S0  p_77, uint32_t  p_78, uint32_t  p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_34 g_3 g_56.f0 g_56.f1 g_56.f4 g_56.f2 g_94 g_109.f4 g_109.f1 g_109.f0 g_109.f3 g_56.f3 g_109.f2 g_211 g_109 g_259 g_56
 * writes: g_56 g_94 g_34 g_109 g_3
 */
static int32_t  func_26(void)
{ /* block id: 36 */
    int16_t l_35 = 0x8C9A;
    uint16_t l_188 = 0x6CBF;
    uint32_t l_241 = 4294967295U;
    int32_t l_242 = (-5);
    int16_t l_286 = 0x8F1F;
    uint16_t l_337 = 65529U;
    int16_t l_361 = 0x6AC0;
    uint32_t l_371 = 2U;
    struct S0 l_402 = {1240,249,6,66,-7};
    int16_t l_403 = 1;
    if (((func_27(((((((((uint16_t)g_34 >> (uint16_t)__builtin_popcount(l_35)) && l_35) & (__builtin_ctzl((func_36((g_3 < (((g_34 & l_35) && l_35) >= (1 || g_3))), g_3, l_35) | g_34)) == g_34)) && g_3) > l_35) & g_3) <= g_3), g_3, g_3, l_35) != l_35) < 1U))
    { /* block id: 101 */
        uint32_t l_159 = 4294967295U;
        int32_t l_195 = (-9);
        struct S0 l_219 = {-1388,65,13,212,0x8BAC6151};
        g_56 = func_52(l_35, (-(uint16_t)(l_35 && (((((int16_t)((int16_t)(((uint16_t)(0U <= g_109.f0) >> (uint16_t)l_159) & (l_159 != (((uint16_t)((uint16_t)g_34 % (uint16_t)g_34) << (uint16_t)g_94) ^ l_159))) - (int16_t)0x44C1) + (int16_t)0xBAD6) ^ g_56.f0) & (-6)) < g_109.f0))));
        if (g_94)
        { /* block id: 103 */
            int32_t l_176 = 0xFCBD7A91;
            uint32_t l_179 = 0x4FEF38AB;
            struct S0 l_196 = {478,514,10,249,0xF9FBB45E};
            int16_t l_206 = (-1);
            uint32_t l_253 = 0x50922346;
            if ((1 < ((uint32_t)__builtin_popcount(g_94) + (uint32_t)(((-1) < ((int16_t)g_109.f1 + (int16_t)(l_159 ^ (((int32_t)(((uint16_t)g_109.f4 << (uint16_t)g_56.f1) ^ ((int32_t)((int16_t)l_159 >> (int16_t)g_109.f1) % (int32_t)5U)) % (int32_t)g_109.f0) & l_176)))) == 4294967295U))))
            { /* block id: 104 */
                uint32_t l_194 = 5U;
                l_195 = (((uint16_t)g_3 + (uint16_t)(l_179 == ((((int16_t)(((uint16_t)g_56.f3 - (uint16_t)g_56.f2) ^ (((int32_t)((g_56.f3 <= l_188) <= ((0xE251 || ((uint32_t)(((uint16_t)((!(l_194 != 5)) >= l_159) + (uint16_t)g_56.f1) == l_179) + (uint32_t)3)) == l_194)) - (int32_t)0x776CDE9C) >= 0U)) - (int16_t)g_109.f4) || l_194) == 4294967289U))) && 0xF002BF45);
                l_196 = func_52(l_195, g_94);
                g_109.f0 = 1;
            }
            else
            { /* block id: 108 */
                int32_t l_216 = 0xDF36518E;
                uint32_t l_260 = 4294967288U;
                for (g_109.f4 = (-3); (g_109.f4 < 25); g_109.f4 += 1)
                { /* block id: 111 */
                    uint32_t l_203 = 0x5D964B4B;
                    l_196.f0 = ((((int32_t)g_56.f3 % (int32_t)((0xC91009C5 >= (((int32_t)func_63(l_203) - (int32_t)((uint32_t)l_206 - (uint32_t)(l_203 < ((int32_t)((uint16_t)((__builtin_ctzll(l_196.f1) >= (g_211 || g_94)) > g_34) + (uint16_t)g_3) + (int32_t)0x41E8B384)))) >= 0xAFE7)) ^ g_56.f4)) ^ 0x0082912A) == g_109.f4);
                    g_56 = func_52((__builtin_bswap64((__builtin_parityl(g_109.f2) || ((int16_t)l_196.f1 >> (int16_t)l_196.f0))) <= ((l_196.f0 > ((uint16_t)__builtin_bswap32(l_216) << (uint16_t)((((uint16_t)(g_109.f3 < 0) % (uint16_t)l_203) > 0x79C4) < l_196.f3))) || g_109.f1)), l_195);
                    l_219 = l_219;
                }
                for (l_188 = 28; (l_188 > 53); l_188 += 1)
                { /* block id: 118 */
                    int32_t l_222 = 0xC9878C96;
                    int32_t l_245 = 0x1B903DA8;
                    if (l_222)
                        break;
                    for (g_109.f4 = 8; (g_109.f4 < (-24)); g_109.f4 -= 6)
                    { /* block id: 122 */
                        l_219 = g_109;
                        g_56.f0 = ((int32_t)g_56.f3 - (int32_t)l_195);
                        g_109.f0 = g_109.f0;
                    }
                    l_242 = (l_222 != (((g_211 > l_196.f1) | (((int16_t)((uint16_t)l_216 >> (uint16_t)6) - (int16_t)((uint32_t)(-(int16_t)g_94) % (uint32_t)((-(uint16_t)l_222) && ((int32_t)((((((((uint16_t)l_216 % (uint16_t)1) <= (((int16_t)(((l_241 < g_56.f3) == 0x862E0C10) > 0x340F) << (int16_t)15) == g_211)) & (-1)) | 0x91B15815) <= g_56.f1) | 0xC5F6) || 1) % (int32_t)3U)))) > 1U)) >= l_188));
                    l_245 = (__builtin_ia32_crc32qi(((uint16_t)l_216 + (uint16_t)g_56.f1), g_211) < (g_3 < (g_56.f1 && __builtin_popcountll(g_56.f4))));
                }
                g_56.f0 = ((uint16_t)65532U << (uint16_t)((~(((int16_t)((int16_t)(((l_188 ^ l_219.f2) < g_56.f2) >= g_34) << (int16_t)15) >> (int16_t)9) | ((l_253 ^ ((int32_t)((uint16_t)0x6343 << (uint16_t)(!(((g_259 || g_56.f0) && (-2)) | l_260))) + (int32_t)g_3)) ^ l_260))) & l_179));
                return l_195;
            }
        }
        else
        { /* block id: 133 */
            l_219.f0 = 5;
            for (g_109.f4 = (-12); (g_109.f4 > 1); g_109.f4 += 1)
            { /* block id: 137 */
                l_219 = g_109;
                g_109.f0 = g_94;
            }
        }
        g_56.f0 = (__builtin_ffsll((0xF6DF >= 0xFED9)) >= l_241);
        if (((int16_t)l_188 << (int16_t)15))
        { /* block id: 143 */
            g_109.f0 = ((int16_t)(((int16_t)l_219.f3 - (int16_t)((uint16_t)l_241 << (uint16_t)(((0x5979 | g_109.f2) <= g_109.f0) >= l_219.f2))) != (__builtin_parity(l_188) > ((int16_t)0x6821 << (int16_t)2))) % (int16_t)0x9098);
        }
        else
        { /* block id: 145 */
            int32_t l_277 = (-4);
            struct S0 l_287 = {-2019,655,1,114,0x02581F73};
            uint32_t l_310 = 0x22876F92;
            int32_t l_346 = (-6);
            l_277 = (((g_94 > g_3) != (65528U ^ ((uint16_t)(((uint32_t)0x4C6D2363 - (uint32_t)(0 < 65535U)) || (l_277 && g_94)) % (uint16_t)g_109.f3))) >= g_56.f0);
            l_195 = ((uint16_t)g_109.f0 << (uint16_t)3);
            if (((uint16_t)__builtin_ctzl(((1 != func_75(g_56.f0, func_52((-(uint16_t)g_259), g_211), g_109.f1, l_277)) && 0x3D83)) >> (uint16_t)l_188))
            { /* block id: 148 */
                uint32_t l_314 = 0xF387689A;
                int32_t l_323 = 0;
                for (g_56.f4 = (-23); (g_56.f4 < (-23)); g_56.f4 += 1)
                { /* block id: 151 */
                    int32_t l_285 = 0x0813B3EB;
                    l_285 = ((l_195 == ((-6) <= g_56.f2)) || l_219.f1);
                    l_287 = func_52(g_259, l_286);
                    for (g_3 = 0; (g_3 <= 21); g_3 += 1)
                    { /* block id: 156 */
                        struct S0 l_311 = {-79,414,6,303,0x9C32DDD9};
                        g_109.f0 = ((uint16_t)(0x5277 >= __builtin_ctzl(((uint16_t)((int16_t)(((uint16_t)((uint16_t)(((uint16_t)g_109.f1 << (uint16_t)6) <= ((uint16_t)((uint16_t)l_286 << (uint16_t)6) >> (uint16_t)15)) - (uint16_t)((uint16_t)((int16_t)((g_109.f3 || (g_109.f1 == (((__builtin_bswap64(l_287.f0) >= ((65529U | ((l_310 != g_34) <= l_241)) != 0xF6AC)) && 1) & 9U))) < g_259) - (int16_t)l_195) << (uint16_t)g_94)) + (uint16_t)g_56.f1) && g_56.f2) >> (int16_t)l_159) << (uint16_t)l_287.f4))) - (uint16_t)1);
                        l_311 = g_109;
                        g_56.f0 = ((((uint16_t)l_188 + (uint16_t)l_188) <= l_314) <= ((uint32_t)((uint16_t)g_109.f0 >> (uint16_t)4) + (uint32_t)__builtin_parityl(l_195)));
                    }
                }
                l_219 = g_56;
                g_56.f0 = g_34;
                l_323 = __builtin_bswap64(((uint16_t)g_34 - (uint16_t)func_63((~(-(int16_t)g_109.f0)))));
            }
            else
            { /* block id: 165 */
                uint32_t l_330 = 0xF3C0F87B;
                struct S0 l_347 = {1142,579,12,352,1};
                uint32_t l_362 = 0x413634BA;
                l_219.f0 = ((int32_t)l_219.f3 % (int32_t)(((int16_t)((uint16_t)l_330 << (uint16_t)10) % (int16_t)((uint16_t)l_330 << (uint16_t)l_219.f1)) & l_287.f0));
                for (l_35 = 0; (l_35 >= 24); l_35 += 1)
                { /* block id: 169 */
                    for (l_286 = (-17); (l_286 < (-13)); l_286 += 7)
                    { /* block id: 172 */
                        l_337 = g_109.f0;
                        return g_3;
                    }
                    l_347 = func_52(((4294967287U | 0xB725F034) & func_27(__builtin_ffsll(g_109.f0), ((int16_t)l_287.f3 + (int16_t)((int16_t)((int32_t)0x21EEE773 + (int32_t)1U) << (int16_t)((int32_t)g_109.f1 - (int32_t)l_219.f3))), l_346, g_56.f3)), g_259);
                }
                for (l_337 = (-22); (l_337 > 18); l_337 += 1)
                { /* block id: 180 */
                    uint32_t l_350 = 7U;
                    if ((l_350 ^ ((int16_t)(((uint16_t)9U << (uint16_t)((uint16_t)(((uint16_t)g_259 - (uint16_t)(!(g_109.f0 ^ (((-(uint32_t)g_56.f3) > __builtin_ctzll(func_59(l_195, l_350, g_3))) != l_287.f1)))) != l_361) % (uint16_t)g_56.f3)) || l_362) % (int16_t)g_56.f4)))
                    { /* block id: 181 */
                        return l_330;
                    }
                    else
                    { /* block id: 183 */
                        l_195 = l_195;
                    }
                    g_56.f0 = g_259;
                }
            }
            g_56.f0 = (((-(int16_t)(g_56.f0 == ((g_56.f0 == (g_56.f2 > (0U ^ 2U))) != l_188))) < l_195) || (l_287.f2 != g_56.f4));
        }
    }
    else
    { /* block id: 191 */
        uint32_t l_367 = 0xC35C1B07;
        int32_t l_368 = 0x80014CE8;
        for (l_241 = (-30); (l_241 != 50); l_241 += 1)
        { /* block id: 194 */
            uint16_t l_366 = 0x860B;
            g_109.f0 = l_366;
            l_368 = l_367;
        }
        for (l_188 = 0; (l_188 <= 26); l_188 += 2)
        { /* block id: 200 */
            uint16_t l_378 = 0x2069;
            uint16_t l_397 = 0x12D3;
            if (func_69(g_109.f4, l_371))
            { /* block id: 201 */
                int32_t l_372 = (-1);
                g_56.f0 = __builtin_ctzll(l_372);
                for (l_367 = 0; (l_367 != 11); l_367 += 1)
                { /* block id: 205 */
                    int32_t l_377 = 0x03037CC9;
                    g_109.f0 = ((int16_t)l_377 >> (int16_t)g_94);
                    g_56 = func_52(l_378, l_367);
                    l_242 = (~0x7178);
                }
            }
            else
            { /* block id: 210 */
                int32_t l_398 = 0x58C2794F;
                int32_t l_399 = 0x6BECDB6F;
                g_109.f0 = ((int16_t)((int32_t)((~((uint32_t)(((g_56.f2 | 0) <= __builtin_parity((~((uint16_t)9U * (uint16_t)((((uint32_t)((((((int16_t)(((~g_109.f0) & 0xEA1205C9) == ((2 & (((uint32_t)((g_94 == __builtin_parityl((l_378 ^ ((func_59((l_378 && 9U), l_397, l_378) || l_398) != g_34)))) ^ 0x4999) - (uint32_t)0x6F460212) | 4294967295U)) || l_399)) << (int16_t)7) == g_109.f3) <= 0x2A97) >= g_56.f0) > 0x02113A69) % (uint32_t)g_109.f0) < g_56.f2) == 0))))) ^ g_109.f2) - (uint32_t)g_109.f3)) <= l_397) + (int32_t)g_56.f0) - (int16_t)l_367);
            }
            g_109.f0 = 0xA3F53466;
            g_109.f0 = ((int16_t)l_397 << (int16_t)2);
        }
        g_109.f0 = l_35;
        l_402 = g_109;
    }
    return l_403;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f0 g_56.f1 g_56.f4 g_3 g_34 g_56.f2 g_94 g_109.f4 g_109.f1 g_109.f0 g_109.f3 g_56.f3 g_109.f2
 * writes: g_94 g_34 g_109 g_56
 */
static int16_t  func_27(int16_t  p_28, int32_t  p_29, int32_t  p_30, int16_t  p_31)
{ /* block id: 44 */
    int16_t l_133 = 0x2775;
    int32_t l_150 = 8;
    struct S0 l_151 = {-2027,557,2,94,9};
    for (p_31 = 28; (p_31 > 28); p_31 += 1)
    { /* block id: 47 */
        uint32_t l_148 = 0xA2D5331A;
        l_150 = (0xD865 ^ (0U > func_59((0x6B35 & func_36(g_56.f0, func_63(func_65(func_52((p_28 | ((uint16_t)0U << (uint16_t)(((-10) && __builtin_ctz(func_69(g_56.f1, (0x76079686 ^ p_29)))) | l_133))), p_30))), l_148)), g_3, g_3)));
        l_151 = func_52(g_56.f3, l_148);
        if (l_151.f3)
            break;
    }
    return l_151.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_34
 * writes: g_56
 */
static uint16_t  func_36(uint32_t  p_37, int32_t  p_38, uint16_t  p_39)
{ /* block id: 37 */
    uint16_t l_40 = 0xA3A7;
    int32_t l_49 = (-6);
    l_49 = ((__builtin_ctzl((l_40 || (g_3 > ((int32_t)((1U | (-(uint32_t)4294967295U)) == g_3) % (int32_t)9U)))) > (g_34 & ((uint16_t)((((int16_t)(!0x9D65) % (int16_t)g_34) | p_37) || p_39) + (uint16_t)l_40))) && g_3);
    l_49 = ((1U && 0U) != 0x4D7E3C23);
    g_56 = func_52(g_3, p_37);
    return l_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_52(uint32_t  p_53, int32_t  p_54)
{ /* block id: 40 */
    struct S0 l_55 = {-1484,652,5,63,0xF5AB95DF};
    return l_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_59(uint32_t  p_60, uint32_t  p_61, uint32_t  p_62)
{ /* block id: 93 */
    int32_t l_149 = 0x8CEDA537;
    l_149 = p_61;
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(uint32_t  p_64)
{ /* block id: 90 */
    struct S0 l_147 = {448,650,4,331,0};
    l_147 = l_147;
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f3 g_109.f4 g_109.f1 g_56.f2 g_109.f2
 * writes: g_109.f0
 */
static uint32_t  func_65(struct S0  p_66)
{ /* block id: 85 */
    uint16_t l_136 = 65527U;
    int16_t l_139 = (-5);
    int32_t l_146 = (-10);
    l_146 = ((0xE952 ^ (((uint32_t)(l_136 == ((int16_t)p_66.f3 >> (int16_t)0)) - (uint32_t)0x3FC91578) && l_139)) != (((((g_56.f3 & (((uint32_t)(__builtin_clzl(p_66.f2) <= ((uint16_t)((uint16_t)(l_139 & 6) >> (uint16_t)g_109.f4) >> (uint16_t)g_109.f1)) % (uint32_t)l_139) & 1U)) <= g_56.f2) <= 0xBA76E451) & 0x8E489E7F) & 0xE0311020));
    p_66.f0 = g_109.f2;
    g_109.f0 = l_139;
    return g_109.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f4 g_3 g_56.f0 g_34 g_56.f2 g_56.f1 g_94 g_109.f4 g_109.f1 g_109.f0 g_109.f3
 * writes: g_94 g_34 g_109
 */
static uint32_t  func_69(uint32_t  p_70, uint32_t  p_71)
{ /* block id: 48 */
    struct S0 l_74 = {1108,121,0,271,-3};
    l_74.f0 = func_72(l_74);
    g_109.f0 = (~p_70);
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f4 g_3 g_56.f0 g_34 g_56.f2 g_56.f1 g_94 g_109.f4 g_109.f1 g_109.f0 g_109.f3
 * writes: g_94 g_34 g_109
 */
static int32_t  func_72(struct S0  p_73)
{ /* block id: 49 */
    int32_t l_83 = 2;
    struct S0 l_131 = {-609,173,21,46,-4};
    p_73.f0 = (g_56.f4 > func_75(((((int32_t)p_73.f1 - (int32_t)(g_3 <= p_73.f4)) == 7) >= ((~((g_56.f0 || l_83) <= 0x8985BB29)) > 0xB0F8)), p_73, l_83, g_34));
    p_73 = l_131;
    return l_131.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f4 g_56.f2 g_56.f1 g_34 g_3 g_94 g_109.f4 g_109.f1 g_109.f0 g_109.f3
 * writes: g_94 g_34 g_109
 */
static uint16_t  func_75(int32_t  p_76, struct S0  p_77, uint32_t  p_78, uint32_t  p_79)
{ /* block id: 50 */
    uint16_t l_88 = 0U;
    int32_t l_120 = 0xE453FC63;
    int16_t l_130 = 5;
    g_94 = ((int32_t)((int16_t)l_88 >> (int16_t)6) + (int32_t)(((int16_t)((((g_56.f4 & (g_56.f2 == (65527U <= 0U))) == 0x0374) != (l_88 == (((int32_t)(!((((l_88 <= (p_77.f0 ^ 4U)) >= g_56.f1) | (-1)) || p_77.f1)) + (int32_t)0xB567EB87) > g_34))) || g_3) + (int16_t)p_77.f0) < 2));
    for (g_34 = 11; (g_34 != 7); g_34 -= 1)
    { /* block id: 54 */
        int32_t l_102 = 0x87538C74;
        uint32_t l_103 = 4294967295U;
        int32_t l_121 = (-4);
        if ((~(((uint32_t)((int32_t)((l_102 ^ (l_103 <= ((__builtin_popcount(g_56.f2) || ((g_56.f4 == g_94) >= 0U)) | ((int16_t)(g_56.f4 != (__builtin_ctzl(l_88) > l_103)) % (int16_t)1)))) || 0xD804) % (int32_t)1) + (uint32_t)l_88) ^ p_77.f1)))
        { /* block id: 55 */
            int16_t l_110 = (-1);
            int32_t l_119 = 0x5434A3FD;
            for (p_77.f4 = (-11); (p_77.f4 < 6); p_77.f4 += 8)
            { /* block id: 58 */
                uint32_t l_108 = 4294967293U;
                g_109 = func_52(p_77.f4, (p_78 == __builtin_parityl(l_108)));
                if (g_109.f4)
                { /* block id: 60 */
                    g_109.f0 = p_78;
                    g_109 = p_77;
                    p_77.f0 = l_108;
                }
                else
                { /* block id: 64 */
                    return l_88;
                }
                g_109 = func_52(l_110, ((uint32_t)p_77.f3 + (uint32_t)g_109.f1));
            }
            l_119 = ((uint16_t)65535U + (uint16_t)((int32_t)l_102 + (int32_t)((uint16_t)g_109.f0 >> (uint16_t)7)));
            p_77.f0 = 0xA49CFF13;
        }
        else
        { /* block id: 71 */
            l_120 = g_56.f4;
            l_121 = (-8);
        }
    }
    g_109 = func_52(((__builtin_popcount(p_76) ^ 1) <= ((uint16_t)((uint16_t)((int16_t)0xC33A >> (int16_t)p_79) - (uint16_t)((__builtin_clz((((uint16_t)l_88 << (uint16_t)12) == l_130)) == l_120) && 0x1B9F6C78)) % (uint16_t)l_88)), g_109.f4);
    l_120 = g_109.f3;
    return g_109.f4;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_56.f0, "g_56.f0", print_hash_value);
    transparent_crc(g_56.f1, "g_56.f1", print_hash_value);
    transparent_crc(g_56.f2, "g_56.f2", print_hash_value);
    transparent_crc(g_56.f3, "g_56.f3", print_hash_value);
    transparent_crc(g_56.f4, "g_56.f4", print_hash_value);
    transparent_crc(g_94, "g_94", print_hash_value);
    transparent_crc(g_109.f0, "g_109.f0", print_hash_value);
    transparent_crc(g_109.f1, "g_109.f1", print_hash_value);
    transparent_crc(g_109.f2, "g_109.f2", print_hash_value);
    transparent_crc(g_109.f3, "g_109.f3", print_hash_value);
    transparent_crc(g_109.f4, "g_109.f4", print_hash_value);
    transparent_crc(g_211, "g_211", print_hash_value);
    transparent_crc(g_259, "g_259", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 68
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 20
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 30
XXX times a single bitfield on RHS: 101

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 22
   depth: 3, occurrence: 7
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 4
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 2
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 368
XXX times a non-volatile is write: 86
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 111
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 12
   depth: 2, occurrence: 18
   depth: 3, occurrence: 22
   depth: 4, occurrence: 21
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

