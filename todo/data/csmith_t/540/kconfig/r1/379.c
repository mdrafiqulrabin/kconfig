/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      681139926
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   float  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_31(void);
static union U0 * func_36(union U0  p_37, int32_t  p_38, float  p_39);
inline static union U0  func_40(uint16_t  p_41, union U0  p_42, int16_t  p_43, union U0 * p_44);
inline static int32_t  func_48(union U0 * p_49, float  p_50, const union U0 * p_51);
inline static union U0 * func_52(union U0 * p_53);
inline static const int32_t * func_56(uint16_t  p_57, int32_t  p_58, uint32_t  p_59);
inline static const uint32_t  func_67(uint16_t  p_68, uint32_t  p_69, union U0  p_70, int32_t * p_71);
static uint64_t  func_72(uint16_t  p_73);
inline static int32_t * func_75(int32_t  p_76, int32_t * p_77, int32_t * p_78, uint32_t  p_79, uint16_t  p_80);
static int32_t * func_81(int32_t * p_82, int16_t  p_83, uint32_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0;
    union U0 l_45 = {4294967290U};
    float *l_370 = &l_45.f1;
    int32_t l_405 = 0xF1477426;
    const union U0 **l_414 = (void*)0;
    int32_t l_443 = (-7);
    float l_462 = (-0x1.Ep+1);
    int16_t l_463 = (-8);
    union U0 *l_469 = (void*)0;
    int32_t *l_477 = &l_32;
    int32_t **l_476 = &l_477;
    int32_t ***l_475 = &l_476;
    uint32_t l_478 = 9U;
    for (l_32 = (-25); (l_32 > 28); l_32 += 4)
    { /* block id: 39 */
        int16_t l_46 = 9;
        const float *l_371 = &l_45.f1;
        union U0 *l_402 = (void*)0;
        int32_t l_450 = 0xE150EA9A;
        uint32_t l_456 = 1U;
        int32_t *l_470 = (void*)0;
        int32_t *l_473 = &l_32;
        if ((l_32 ^ l_32))
        { /* block id: 40 */
            uint16_t l_35 = 1U;
            union U0 *l_388 = &l_45;
            const int32_t *l_400 = &l_32;
            union U0 **l_401 = &l_388;
            if (l_35)
            { /* block id: 41 */
                union U0 *l_47 = &l_45;
                union U0 **l_380 = &l_47;
                int32_t *l_382 = &l_32;
                int32_t **l_381 = &l_382;
                int32_t l_384 = 1;
                int32_t *l_383 = &l_384;
                (*l_380) = func_36(func_40(l_32, l_45, l_46, l_47), (l_370 != l_371), l_45.f2);
                /* statement id: 207 */
                assert (l_47 == 0);
                if (l_32)
                    break;
                (*l_381) = &l_32;
                (*l_383) = l_45.f0;
            }
            else
            { /* block id: 211 */
                float l_387 = 0xF.BFFB3Cp+49;
                int32_t l_391 = 0x7541D088;
                union U0 *l_392 = &l_45;
                (*l_370) = (l_370 == (void*)0);
                /* statement id: 212 */
                                (*l_370) = (__builtin_ia32_crc32qi(((int16_t)l_32 << (int16_t)l_32), func_48(l_388, ((float)l_35 - (float)l_391), l_388)) == (func_48(l_392, l_46, l_392) < 0xC.338B1Bp-20));
                if (l_46)
                    continue;
            }
            (*l_370) = ((((((float)l_45.f0 - (float)l_45.f2) != (l_45.f2 <= ((+(l_46 >= ((float)(l_35 != l_35) - (float)(l_46 >= (-(float)l_45.f0))))) > (-(float)(l_371 != l_400))))) >= l_32) > l_46) <= 0x1.1p-1);
            /* statement id: 216 */
                        (*l_401) = func_52(&l_45);
            (*l_401) = &l_45;
        }
        else
        { /* block id: 219 */
            int16_t l_406 = 0x9782;
            union U0 *l_415 = &l_45;
            int32_t *l_440 = &l_405;
            int32_t **l_439 = &l_440;
            int32_t ***l_438 = &l_439;
            int32_t ****l_437 = &l_438;
            int32_t *****l_436 = &l_437;
            if ((__builtin_parityll((0x836A < (func_48(l_402, l_45.f0, l_402) | 0x205DDFC6))) & ((((int16_t)l_45.f2 >> (int16_t)13) < (((func_72(l_45.f0) == l_45.f0) & l_405) || 0x39D242D6)) | l_406)))
            { /* block id: 220 */
                for (l_406 = 0; (l_406 != (-12)); l_406 -= 4)
                { /* block id: 223 */
                    int32_t l_409 = 5;
                    int32_t *l_410 = &l_405;
                    int32_t **l_411 = (void*)0;
                    int32_t **l_412 = &l_410;
                    (*l_410) = (l_409 & l_405);
                    (*l_410) = 0;
                    (*l_412) = l_410;
                }
                if ((~(l_45.f0 != (l_414 != (void*)0))))
                { /* block id: 228 */
                    union U0 **l_416 = (void*)0;
                    union U0 **l_417 = (void*)0;
                    union U0 **l_418 = (void*)0;
                    const union U0 *l_420 = &l_45;
                    const union U0 **l_419 = &l_420;
                    int32_t **l_421 = (void*)0;
                    int32_t *l_423 = &l_32;
                    int32_t **l_422 = &l_423;
                    (*l_419) = l_415;
                    (*l_422) = (void*)0;
                    /* statement id: 230 */
                    assert (l_423 == 0);
                    (*l_422) = &l_405;
                    /* statement id: 231 */
                    assert (l_423 == &l_405);
                    if (l_406)
                        break;
                }
                else
                { /* block id: 233 */
                    int32_t *l_424 = &l_405;
                    (*l_424) = 0xA940064E;
                    for (l_45.f2 = 0; (l_45.f2 >= 10); l_45.f2 += 3)
                    { /* block id: 237 */
                        (*l_424) = 7;
                        return l_46;
                    }
                    /* facts after for loop */
                                    }
            }
            else
            { /* block id: 242 */
                int32_t l_431 = 1;
                int32_t *** const *l_442 = (void*)0;
                int32_t *** const **l_441 = &l_442;
                (*****l_436) = ((int16_t)__builtin_parityll(__builtin_clzll(__builtin_parityll(((uint16_t)(l_431 >= (((0x8052 >= (((uint16_t)((uint16_t)((((l_436 != l_441) < (**l_439)) <= (-6)) > (((65530U || l_46) != ((void*)0 != l_371)) ^ l_443)) >> (uint16_t)13) >> (uint16_t)15) != 1U)) <= 0x95F45498) & l_46)) >> (uint16_t)(*****l_436))))) >> (int16_t)11);
            }
            (*****l_436) = l_443;
            (****l_437) = ((int16_t)(l_440 == l_371) - (int16_t)(((int16_t)(l_45.f2 & 65532U) << (int16_t)12) || ((uint32_t)l_450 - (uint32_t)((uint16_t)l_32 >> (uint16_t)((uint16_t)(!l_456) + (uint16_t)65535U)))));
        }
        /* facts after branching */
                for (l_45.f0 = (-7); (l_45.f0 > 48); ++l_45.f0)
        { /* block id: 250 */
            int32_t *l_460 = &l_32;
            int32_t **l_459 = &l_460;
            uint32_t l_474 = 7U;
            (*l_459) = l_371;
            /* statement id: 251 */
            assert (l_460 == &l_45.f1);
            if (l_456)
            { /* block id: 252 */
                int32_t **l_461 = &l_460;
                (*l_461) = l_371;
            }
            else
            { /* block id: 254 */
                uint16_t l_464 = 0U;
                (*l_459) = func_81(func_81((*l_459), (*l_460), l_463), (**l_459), l_464);
            }
            (*l_459) = (*l_459);
            if ((**l_459))
                break;
        }
        /* facts after for loop */
                (*l_370) = (l_475 != &l_476);
        /* statement id: 260 */
            }
    (**l_475) = (*l_476);
    return l_478;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_36(union U0  p_37, int32_t  p_38, float  p_39)
{ /* block id: 204 */
    int32_t l_373 = 0xB94C9C09;
    int32_t *l_372 = &l_373;
    int32_t **l_374 = &l_372;
    union U0 l_376 = {7U};
    union U0 *l_375 = &l_376;
    union U0 *l_377 = &l_376;
    union U0 *l_378 = &l_376;
    union U0 *l_379 = (void*)0;
    (*l_374) = l_372;
    return l_379;
    /* statement id: 206 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_40(uint16_t  p_41, union U0  p_42, int16_t  p_43, union U0 * p_44)
{ /* block id: 42 */
    union U0 l_55 = {0x279E56E6};
    union U0 *l_54 = &l_55;
    int32_t l_364 = (-1);
    int32_t *l_363 = &l_364;
    float *l_369 = &l_55.f1;
    float **l_368 = &l_369;
    if (func_48(func_52(l_54), (0x5.9EA8A3p+38 != l_55.f2), func_52(&p_42)))
    { /* block id: 190 */
        union U0 *l_343 = &l_55;
        l_343 = &p_42;
        /* statement id: 191 */
        assert (l_343 == &p_42);
    }
    else
    { /* block id: 192 */
        float *l_344 = &l_55.f1;
        int32_t l_347 = 0xE99DC055;
        int32_t *l_346 = &l_347;
        int32_t **l_345 = &l_346;
        (*l_345) = func_56(p_43, l_55.f0, (l_344 != l_344));
        /* statement id: 193 */
        assert (l_346 == 0);
    }
    for (p_42.f2 = (-2); (p_42.f2 == (-6)); p_42.f2 -= 2)
    { /* block id: 197 */
        int16_t l_350 = (-4);
        int32_t l_352 = 5;
        int32_t *l_351 = &l_352;
        int32_t **l_365 = &l_351;
        (*l_351) = l_350;
        (*l_351) = ((uint32_t)((*l_351) >= ((int16_t)(p_42.f2 < (6 | ((((uint32_t)(0x7ADA85AC <= p_41) - (uint32_t)0x46ECEB4F) ^ ((uint32_t)((uint16_t)p_43 >> (uint16_t)(((*l_351) != ((p_41 & 5U) >= 4294967295U)) >= (*l_351))) - (uint32_t)l_55.f0)) || l_55.f2))) << (int16_t)l_55.f0)) + (uint32_t)(*l_351));
        (*l_365) = l_363;
        /* statement id: 200 */
        assert (l_351 == &l_364);
    }
    /* facts after for loop */
        (*l_363) = ((int16_t)(l_368 == &l_369) << (int16_t)(*l_363));
    return (*p_44);
    /* statement id: 203 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_48(union U0 * p_49, float  p_50, const union U0 * p_51)
{ /* block id: 186 */
    uint16_t l_329 = 65530U;
    int32_t l_335 = 0x61763957;
    int32_t *l_334 = &l_335;
    float l_340 = 0x2.7637BCp+6;
    float l_341 = 0x8.CD0808p+44;
    uint32_t l_342 = 4294967288U;
    (*l_334) = (4294967290U & (((0xF301 <= l_329) < ((int16_t)l_329 << (int16_t)3)) == ((l_329 && (((int16_t)l_329 + (int16_t)(l_329 ^ (l_329 <= l_329))) <= l_329)) || l_329)));
    (*l_334) = ((int16_t)0 >> (int16_t)(((int32_t)(*l_334) + (int32_t)(*l_334)) != (*l_334)));
    return l_342;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0 * func_52(union U0 * p_53)
{ /* block id: 43 */
    uint32_t l_60 = 9U;
    const int32_t l_320 = (-1);
    const int32_t *l_319 = &l_320;
    int32_t *l_321 = (void*)0;
    int32_t *l_322 = (void*)0;
    int32_t l_324 = 0;
    int32_t *l_323 = &l_324;
    float l_326 = 0x1.Cp-1;
    float *l_325 = &l_326;
    union U0 l_328 = {4294967295U};
    union U0 *l_327 = &l_328;
    l_319 = func_56(l_60, l_60, l_60);
    /* statement id: 182 */
    assert (l_319 == 0);
    (*l_323) = l_320;
    (*l_325) = (*l_323);
    return p_53;
    /* statement id: 185 */
    //assert (func_52_rv == &l_55 || func_52_rv == &p_42 || func_52_rv == &l_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_56(uint16_t  p_57, int32_t  p_58, uint32_t  p_59)
{ /* block id: 44 */
    int32_t l_64 = 1;
    int32_t *l_63 = &l_64;
    union U0 l_191 = {0x1BD50128};
    const int32_t *l_318 = (void*)0;
    (*l_63) = ((uint16_t)((void*)0 != l_63) >> (uint16_t)(((uint16_t)p_58 << (uint16_t)(func_67((((((1 <= (__builtin_bswap64(func_72(p_58)) & ((p_58 < __builtin_ffs((p_58 >= p_59))) > (-10)))) | p_59) > (*l_63)) == 0x0D3AC039) ^ (*l_63)), (*l_63), l_191, &l_64) || 0x3973B462)) <= p_57));
    return l_318;
    /* statement id: 181 */
    //assert (func_56_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_67(uint16_t  p_68, uint32_t  p_69, union U0  p_70, int32_t * p_71)
{ /* block id: 108 */
    float l_196 = (-0x7.0p-1);
    union U0 *l_197 = (void*)0;
    union U0 l_204 = {4294967295U};
    union U0 * const l_203 = &l_204;
    uint16_t l_226 = 0U;
    int32_t *l_280 = (void*)0;
    int32_t **l_279 = &l_280;
    int32_t ***l_278 = &l_279;
    int32_t *** const *l_277 = &l_278;
    uint32_t l_282 = 4U;
    const uint32_t l_287 = 4294967289U;
    uint32_t l_288 = 1U;
    float *l_294 = &l_196;
    float **l_293 = &l_294;
    int32_t l_316 = (-1);
    const int32_t l_317 = 3;
lbl_212:
    (*p_71) = 0x95C8E435;
    if (((int32_t)(&p_71 != (void*)0) % (int32_t)((uint16_t)p_68 + (uint16_t)(l_197 != l_197))))
    { /* block id: 110 */
        const int16_t l_202 = 0x33F8;
        if (((int16_t)(((int16_t)((0x84C5083F | l_202) | p_70.f0) >> (int16_t)15) > l_202) + (int16_t)(((l_197 == l_203) == (p_71 != p_71)) >= l_202)))
        { /* block id: 111 */
            float *l_205 = (void*)0;
            float *l_206 = &l_204.f1;
            int32_t l_209 = 0x9DF1BF41;
            int32_t *l_208 = &l_209;
            int32_t **l_207 = &l_208;
            (*l_206) = p_68;
            /* statement id: 112 */
                        (*p_71) = 0x3590D9D0;
            (*l_207) = p_71;
            /* statement id: 114 */
            //assert (l_208 == &l_64);
        }
        else
        { /* block id: 115 */
            p_70.f1 = (0x8.614822p+95 != l_202);
            /* statement id: 116 */
                    }
        /* facts after branching */
                (*p_71) = 0xAC7FC37B;
    }
    else
    { /* block id: 119 */
        uint32_t l_217 = 0U;
        uint32_t l_248 = 0xF35227E0;
        int32_t *** const *l_281 = &l_278;
        union U0 **l_286 = &l_197;
        if (((int32_t)(l_204.f0 | (l_204.f2 == ((*p_71) <= l_204.f2))) - (int32_t)8))
        { /* block id: 120 */
            if (l_204.f2)
                goto lbl_212;
            return p_68;
        }
        else
        { /* block id: 123 */
            uint32_t l_220 = 4294967292U;
            int32_t l_240 = (-2);
            int32_t *l_239 = &l_240;
            int32_t **l_271 = &l_239;
            int32_t ***l_270 = &l_271;
            if (((((&p_71 == &p_71) ^ ((uint32_t)p_68 - (uint32_t)(0U | l_204.f2))) < (func_72(p_70.f0) > l_217)) < ((uint16_t)l_220 << (uint16_t)9)))
            { /* block id: 124 */
                uint32_t l_221 = 1U;
                int32_t ** const *l_227 = (void*)0;
                int32_t **l_241 = &l_239;
                (*p_71) = l_221;
                (*p_71) = ((uint16_t)((((uint32_t)(__builtin_clzl(func_72(p_68)) || l_226) - (uint32_t)(func_72(p_70.f2) >= (l_220 | (p_68 & l_204.f2)))) | p_68) <= 0U) << (uint16_t)l_221);
                if (l_221)
                { /* block id: 127 */
                    int32_t l_232 = 0xBFF233E6;
                    int32_t *l_231 = &l_232;
                    int32_t **l_230 = &l_231;
                    int32_t ***l_229 = &l_230;
                    int32_t ****l_228 = &l_229;
                    (*l_228) = l_227;
                    /* statement id: 128 */
                    assert (l_229 == 0);
                }
                else
                { /* block id: 129 */
                    int32_t l_234 = 0xE2BBFE02;
                    int32_t *l_233 = &l_234;
                    p_71 = func_81(func_81(func_81(l_233, (p_68 < (-2)), l_220), (((int16_t)((((int16_t)l_204.f2 >> (int16_t)10) < l_226) == p_69) >> (int16_t)l_220) ^ 0x83AE), p_69), (*l_233), l_220);
                    /* statement id: 130 */
                    assert (p_71 == &l_234);
                }
                /* facts after branching */
                //assert (p_71 == dangling || p_71 == &l_64);
                (*l_241) = l_239;
            }
            else
            { /* block id: 133 */
                float l_247 = 0x9.0A0FA0p+77;
                int32_t l_255 = 9;
                int32_t ****l_272 = &l_270;
                float *l_283 = (void*)0;
                float *l_284 = &l_204.f1;
                if (__builtin_bswap64(l_204.f0))
                { /* block id: 134 */
                    int32_t l_244 = 0x856030E8;
                    int32_t *l_265 = &l_240;
                    int32_t **l_267 = &l_265;
                    int32_t ***l_266 = &l_267;
                    l_247 = (((((float)(p_70.f2 >= l_244) - (float)(((float)(func_72(l_204.f0) != ((((p_70.f2 <= ((-0x1.1p+1) < l_204.f2)) != (func_72(p_70.f2) == (-0x4.1p-1))) != (*l_239)) <= p_68)) + (float)(-0x7.8p-1)) <= 0xB.B8FC4Ep+27)) != p_69) != (*l_239)) == p_70.f0);
                    if (l_220)
                        goto lbl_262;
lbl_262:
                    if (((l_248 && 4294967295U) <= ((p_70.f2 > (((uint16_t)p_70.f0 + (uint16_t)((uint16_t)((int16_t)l_204.f0 % (int16_t)((*l_239) | (((l_217 == func_72(l_255)) == p_68) ^ 4294967290U))) + (uint16_t)(*l_239))) == 0x8990)) | p_70.f2)))
                    { /* block id: 136 */
                        uint32_t l_258 = 1U;
                        int32_t **l_261 = &l_239;
                        (*l_261) = p_71;
                        /* statement id: 137 */
                        //assert (l_239 == &l_64);
                    }
                    else
                    { /* block id: 138 */
                        return l_204.f0;
                    }
                    /* facts after branching */
                    //assert (l_239 == &l_64);
                    for (l_240 = 0; (l_240 != 20); l_240 += 4)
                    { /* block id: 144 */
                        int32_t *l_268 = &l_255;
                        (**l_266) = p_71;
                        /* statement id: 145 */
                        //assert (l_265 == &l_64);
                        l_268 = &l_255;
                        (*l_267) = (void*)0;
                        /* statement id: 147 */
                        assert (l_265 == 0);
                    }
                    /* facts after for loop */
                    assert (l_265 == 0 || l_265 == &l_240);
                }
                else
                { /* block id: 149 */
                    int32_t **l_269 = &l_239;
                    (*l_269) = p_71;
                    /* statement id: 150 */
                    //assert (l_239 == &l_64);
                    return p_69;
                }
                /* facts after branching */
                //assert (l_239 == &l_64);
                (*l_272) = l_270;
                (*l_284) = ((float)((__builtin_parity(((int32_t)(l_277 == l_281) % (int32_t)(****l_272))) <= p_69) != (-0x2.Fp+1)) - (float)l_282);
                /* statement id: 154 */
                            }
            /* facts after branching */
            //assert (p_71 == dangling || p_71 == &l_64);
            //assert (l_239 == &l_64 || l_239 == &l_240);
            (*l_239) = (func_72((+0x15DC8CDD)) >= p_68);
        }
        /* facts after branching */
        //assert (p_71 == dangling || p_71 == &l_64);
        (*l_286) = &p_70;
        /* statement id: 158 */
        assert (l_197 == &p_70);
    }
    /* facts after branching */
    //assert (p_71 == dangling || p_71 == &l_64);
    assert (l_197 == &p_70 || l_197 == 0);
        if (((p_68 <= (((((-1) && l_204.f0) != l_287) < func_72(l_288)) & (p_68 ^ ((int16_t)__builtin_ffsl((p_68 < ((int16_t)l_204.f2 % (int16_t)0x0B15))) % (int16_t)p_68)))) <= 0xC1426E52))
    { /* block id: 160 */
        float ***l_295 = &l_293;
        int32_t l_296 = 0xDE611EDE;
        (*l_295) = l_293;
        (*l_294) = (__builtin_ctzl(p_69) >= p_69);
        (***l_295) = l_296;
    }
    else
    { /* block id: 164 */
        int32_t *** const **l_297 = &l_277;
        int32_t *l_299 = (void*)0;
        const float *l_307 = &l_196;
        const float **l_306 = &l_307;
        const float l_312 = 0xB.7BDD12p+2;
        int32_t *l_314 = (void*)0;
        if (p_68)
        { /* block id: 165 */
            l_297 = &l_277;
        }
        else
        { /* block id: 167 */
            int32_t l_298 = 0x77487F06;
            (*l_279) = l_299;
        }
lbl_315:
        for (l_204.f0 = 14; (l_204.f0 > 26); l_204.f0 += 9)
        { /* block id: 172 */
            int32_t l_311 = (-9);
            int32_t *l_313 = &l_311;
            (*l_279) = &l_311;
            /* statement id: 173 */
            assert (l_280 == &l_311);
        }
        /* facts after for loop */
                //assert (l_280 == dangling || l_280 == 0);
        (**l_278) = l_314;
        /* statement id: 175 */
        assert (l_280 == 0);
        if (p_70.f2)
            goto lbl_315;
    }
    l_316 = 0x4A42A48A;
    return l_317;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_72(uint16_t  p_73)
{ /* block id: 45 */
    uint32_t l_74 = 0xA5019003;
    int32_t l_86 = 0;
    int32_t *l_85 = &l_86;
    uint32_t l_90 = 4294967295U;
    int32_t l_176 = 0x82478149;
    int32_t **l_187 = &l_85;
    float *l_188 = (void*)0;
    float l_190 = 0x2.58F72Bp-39;
    float *l_189 = &l_190;
    if (l_74)
    { /* block id: 46 */
        uint32_t l_89 = 1U;
        int32_t l_91 = (-4);
        int32_t **l_148 = &l_85;
        uint32_t l_157 = 0xF3C947AA;
        (*l_148) = func_75(p_73, func_81(l_85, (((uint32_t)l_89 + (uint32_t)((*l_85) & ((*l_85) ^ (((l_89 <= (*l_85)) >= (&l_86 == &l_86)) >= (*l_85))))) != l_90), l_91), &l_86, p_73, (*l_85));
        /* statement id: 80 */
        assert (l_85 == 0);
        for (l_89 = 19; (l_89 <= 27); ++l_89)
        { /* block id: 83 */
            int32_t l_151 = 0x6EB9B4FE;
            float l_153 = 0xC.B2DE0Ep+91;
            float *l_152 = &l_153;
            int32_t l_158 = 0xE6C56EA1;
            if (((9U >= l_151) ^ ((l_152 != (void*)0) && l_151)))
            { /* block id: 84 */
                (*l_152) = (((void*)0 != (*l_148)) < (0x3.D8379Ap-16 > (p_73 > p_73)));
                l_158 = (p_73 | ((~((void*)0 != l_148)) == (0x4901 > (p_73 == (((int16_t)l_157 << (int16_t)4) || p_73)))));
            }
            else
            { /* block id: 87 */
                int32_t *l_171 = (void*)0;
                for (p_73 = 5; (p_73 < 18); p_73++)
                { /* block id: 90 */
                    if ((((int16_t)0x99BE - (int16_t)((uint32_t)p_73 + (uint32_t)l_151)) != p_73))
                    { /* block id: 91 */
                        int32_t *l_165 = &l_158;
                        (*l_165) = p_73;
                    }
                    else
                    { /* block id: 93 */
                        int32_t *l_170 = &l_86;
                        (*l_170) = (((uint16_t)p_73 << (uint16_t)l_151) || ((int16_t)p_73 >> (int16_t)p_73));
                    }
                    (*l_148) = l_171;
                    (*l_148) = l_171;
                }
            }
        }
    }
    else
    { /* block id: 101 */
        const int16_t l_172 = 0x1A8B;
        (*l_85) = ((((-5) | l_172) ^ (0x939548CC & (~((int16_t)l_176 >> (int16_t)((((((int16_t)(l_172 < (*l_85)) - (int16_t)((__builtin_ffsl(l_172) >= (*l_85)) & l_172)) | (-3)) <= (*l_85)) > l_172) && 0xF8C079A2))))) | 1);
    }
    /* facts after branching */
    assert (l_85 == &l_86 || l_85 == 0);
    (*l_187) = func_81(&l_86, (!(((int16_t)(((p_73 <= ((l_74 & ((int32_t)((int32_t)(!p_73) - (int32_t)0x1D32CE05) + (int32_t)(((p_73 > 0xA7B7) || l_74) & p_73))) & 0xA679)) | 65535U) || p_73) % (int16_t)p_73) ^ l_176)), p_73);
    /* statement id: 104 */
    assert (l_85 == &l_86);
    (*l_189) = (p_73 <= p_73);
    (*l_85) = (*l_85);
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads : l_64
 * writes: l_64
 */
inline static int32_t * func_75(int32_t  p_76, int32_t * p_77, int32_t * p_78, uint32_t  p_79, uint16_t  p_80)
{ /* block id: 60 */
    float l_112 = 0x0.Dp+1;
    float *l_111 = &l_112;
    int32_t l_113 = 1;
    int32_t *l_119 = (void*)0;
    int32_t **l_118 = &l_119;
    union U0 l_121 = {2U};
    union U0 *l_120 = &l_121;
    int32_t *l_125 = (void*)0;
    int32_t *l_142 = &l_113;
    int32_t *l_143 = &l_113;
    int32_t *l_144 = &l_113;
    int32_t *l_145 = &l_113;
    int32_t *l_146 = &l_113;
    int32_t *l_147 = (void*)0;
    (*l_111) = 0xC.DA1A75p+27;
    (*p_78) = 0x43CAE23F;
    if (((l_113 == ((uint16_t)(0xFF67 && ((uint16_t)l_113 << (uint16_t)2)) >> (uint16_t)8)) && __builtin_ffs((l_118 == &l_119))))
    { /* block id: 63 */
        int32_t *l_122 = &l_113;
        int32_t *l_123 = &l_113;
        int32_t *l_124 = &l_113;
        l_120 = l_120;
        return l_125;
        /* statement id: 65 */
        //assert (func_75_rv == 0);
    }
    else
    { /* block id: 66 */
        uint16_t l_132 = 0xE26E;
        int32_t *l_134 = (void*)0;
        for (p_76 = 0; (p_76 < (-15)); p_76 -= 9)
        { /* block id: 69 */
            int32_t *l_133 = &l_113;
            for (l_121.f2 = 0; (l_121.f2 <= 14); ++l_121.f2)
            { /* block id: 72 */
                (*p_77) = ((int16_t)p_79 % (int16_t)l_132);
                return l_134;
                /* statement id: 74 */
                //assert (func_75_rv == 0);
            }
            /* facts after for loop */
                        (*p_77) = ((!0x094EEE57) & (((uint16_t)__builtin_ffsl(p_76) << (uint16_t)14) > (((uint16_t)p_79 << (uint16_t)((&l_121 == &l_121) < (*p_77))) <= ((uint32_t)0x52390699 % (uint32_t)(*p_78)))));
        }
    }
    return l_147;
    /* statement id: 79 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_64
 * writes:
 */
static int32_t * func_81(int32_t * p_82, int16_t  p_83, uint32_t  p_84)
{ /* block id: 47 */
    int32_t l_93 = 0;
    int32_t *l_92 = &l_93;
    int16_t l_97 = 0x506F;
    if ((*p_82))
    { /* block id: 48 */
        return p_82;
        /* statement id: 49 */
        //assert (func_81_rv == &l_86 || func_81_rv == &l_234 || func_81_rv == &l_64 || func_81_rv == &l_45.f1);
    }
    else
    { /* block id: 50 */
        int32_t **l_94 = (void*)0;
        int32_t l_98 = 0xB1BDA2DD;
        uint32_t l_99 = 0x05992E41;
        p_82 = p_82;
        (*l_92) = ((((*l_92) == ((((float)l_97 + (float)p_84) >= l_98) < l_99)) == ((float)((((float)(((*l_92) != p_83) != (((float)p_84 + (float)((float)(*l_92) - (float)(-0x8.7p+1))) != 0x1.Fp+1)) + (float)p_84) < p_83) > p_84) - (float)0x1.27FAABp+75)) < p_84);
        for (p_84 = 26; (p_84 >= 60); p_84 += 7)
        { /* block id: 55 */
            int32_t l_110 = 0x1A6866C5;
            l_110 = (0x4.F16C48p-93 == p_84);
        }
    }
    return p_82;
    /* statement id: 59 */
    //assert (func_81_rv == &l_86 || func_81_rv == &l_234 || func_81_rv == &l_64 || func_81_rv == &l_45.f1);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 134
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 167
   depth: 2, occurrence: 22
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 9, occurrence: 2
   depth: 10, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 4
   depth: 17, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 147

XXX times a variable address is taken: 133
XXX times a pointer is dereferenced on RHS: 56
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 4
   depth: 3, occurrence: 0
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 74
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 274

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 166
   level: 2, occurrence: 20
   level: 3, occurrence: 6
   level: 4, occurrence: 11
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 72
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.2
XXX average alias set size: 1.2

XXX times a non-volatile is read: 522
XXX times a non-volatile is write: 188
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 142
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 29
   depth: 2, occurrence: 26
   depth: 3, occurrence: 24
   depth: 4, occurrence: 20
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
********************* end of statistics **********************/

