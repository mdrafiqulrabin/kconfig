/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      839025047
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_30(void);
static const int32_t * const  func_31(const uint32_t  p_32);
static uint32_t  func_53(int16_t  p_54, int32_t * p_55, const int32_t  p_56);
static uint16_t  func_59(int32_t  p_60, uint16_t  p_61);
inline static float  func_62(int32_t * p_63, uint32_t  p_64);
inline static int32_t * func_65(int32_t * p_66, int32_t * p_67, int32_t * p_68, int32_t  p_69, int16_t  p_70);
inline static int32_t * func_71(int32_t * p_72, int32_t  p_73);
inline static int32_t  func_80(int32_t * p_81, int32_t * p_82);
inline static int32_t * func_83(uint16_t  p_84, float  p_85, uint32_t  p_86);
inline static const float  func_95(float  p_96, int32_t * p_97, int32_t * p_98, int16_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_30(void)
{ /* block id: 36 */
    int32_t l_34 = (-7L);
    int32_t *l_33 = &l_34;
    int32_t **l_734 = (void*)0;
    const int32_t *l_735 = &l_34;
    int64_t l_736 = 1L;
    l_735 = func_31((((void*)0 != l_33) <= (&l_34 == (void*)0)));
    /* statement id: 447 */
    assert (l_735 == 0);
    return l_736;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * const  func_31(const uint32_t  p_32)
{ /* block id: 37 */
    uint8_t l_37 = 4UL;
    int32_t *l_46 = (void*)0;
    int32_t l_48 = 0xF085FFFFL;
    int32_t *l_47 = &l_48;
    const int32_t * const l_730 = &l_48;
    const int32_t * const l_731 = &l_48;
    const int32_t * const l_732 = &l_48;
    const int32_t * const l_733 = (void*)0;
    (*l_47) = ((p_32 | (((int16_t)p_32 % (int16_t)l_37) >= (~(l_37 ^ ((((int16_t)(p_32 > p_32) << (int16_t)10) ^ (((uint16_t)((!(((int16_t)p_32 << (int16_t)8) | ((l_46 == l_46) >= 0x16658069D1FE9056LL))) <= p_32) << (uint16_t)1) ^ 0L)) || 0x0A94FE874D4A788ALL))))) == p_32);
    (*l_47) = (((int16_t)(((int32_t)(*l_47) + (int32_t)(((1L ^ (p_32 != func_53(((p_32 >= (((uint16_t)(*l_47) % (uint16_t)func_59(p_32, (*l_47))) < ((((int32_t)func_59(p_32, (*l_47)) / (int32_t)(*l_47)) >= (*l_47)) > (*l_47)))) >= 4UL), &l_48, (*l_47)))) == p_32) || p_32)) <= 7UL) - (int16_t)p_32) >= p_32);
    return l_733;
    /* statement id: 446 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(int16_t  p_54, int32_t * p_55, const int32_t  p_56)
{ /* block id: 435 */
    int32_t **l_722 = (void*)0;
    const int32_t *l_723 = (void*)0;
    uint8_t l_727 = 1UL;
    int32_t l_729 = 0xB7A0F989L;
    int32_t *l_728 = &l_729;
    l_723 = &p_56;
    /* statement id: 436 */
    assert (l_723 == &p_56);
    for (p_54 = 0; (p_54 != (-16)); --p_54)
    { /* block id: 439 */
        const int32_t *l_726 = (void*)0;
        l_723 = l_726;
        /* statement id: 440 */
        assert (l_723 == 0);
        if ((*p_55))
            break;
    }
    /* facts after for loop */
    assert (l_723 == 0 || l_723 == &p_56);
    (*l_728) = l_727;
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_59(int32_t  p_60, uint16_t  p_61)
{ /* block id: 39 */
    int32_t l_75 = 0L;
    int32_t *l_74 = &l_75;
    int32_t l_87 = (-8L);
    float l_718 = 0x2.573CCAp-69;
    float *l_717 = &l_718;
    int32_t **l_719 = &l_74;
    (*l_717) = func_62(func_65(func_71(l_74, (p_61 | ((uint16_t)((uint64_t)(4294967286UL ^ ((((p_60 && 0xABDDA6A1E05BF5EFLL) <= (*l_74)) > (*l_74)) & ((p_60 > func_80(func_83(l_87, p_61, p_61), &l_75)) <= 0xA621L))) % (uint64_t)(*l_74)) + (uint16_t)p_61))), &l_75, &l_75, (*l_74), p_60), p_61);
    (*l_719) = &l_75;
    (*l_74) = (**l_719);
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_62(int32_t * p_63, uint32_t  p_64)
{ /* block id: 429 */
    uint32_t l_716 = 4294967295UL;
    return l_716;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(int32_t * p_66, int32_t * p_67, int32_t * p_68, int32_t  p_69, int16_t  p_70)
{ /* block id: 399 */
    int32_t l_661 = (-1L);
    int32_t *l_660 = &l_661;
    int32_t * const ****l_709 = (void*)0;
    uint32_t l_710 = 4294967294UL;
    float *l_711 = (void*)0;
    float l_713 = 0x0.5p+1;
    float *l_712 = &l_713;
    if ((*p_67))
    { /* block id: 400 */
        const int32_t *l_663 = &l_661;
        const int32_t **l_662 = &l_663;
        (*l_662) = p_68;
        /* statement id: 401 */
        //assert (l_663 == &l_75);
        p_66 = p_66;
        (*l_660) = (*p_66);
    }
    else
    { /* block id: 404 */
        uint32_t l_666 = 0x06DD5FB5L;
        int32_t *l_695 = &l_661;
        for (p_70 = (-3); (p_70 <= 12); p_70 += 1)
        { /* block id: 407 */
            int32_t *l_670 = &l_661;
            float l_672 = 0x0.7p-1;
            float *l_671 = &l_672;
            int32_t **l_673 = &l_660;
        }
    }
    (*l_660) = ((int16_t)((int32_t)((int16_t)(p_70 | 0x95FDL) - (int16_t)func_80(func_83((&l_660 == (void*)0), ((float)(*l_660) - (float)(l_709 == l_709)), p_70), &l_661)) - (int32_t)0xC65F7A29L) >> (int16_t)l_710);
    (*l_712) = p_70;
    for (p_69 = 4; (p_69 < 20); p_69 += 9)
    { /* block id: 423 */
        (*l_660) = (-7L);
        if ((*p_67))
            continue;
        (*p_66) = (*p_67);
    }
    return p_68;
    /* statement id: 428 */
    //assert (func_65_rv == &l_75);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_71(int32_t * p_72, int32_t  p_73)
{ /* block id: 278 */
    int32_t l_493 = 0x53E3F1FEL;
    const int32_t *l_492 = &l_493;
    const int32_t **l_491 = &l_492;
    const int32_t ***l_490 = &l_491;
    int32_t *l_497 = (void*)0;
    int32_t **l_496 = &l_497;
    int32_t ***l_495 = &l_496;
    int32_t ****l_494 = &l_495;
    uint8_t l_508 = 0xB8L;
    int16_t l_509 = 0x386FL;
    int32_t l_560 = 0xCF5295B9L;
    const int32_t l_561 = 0x05D6CAF3L;
    uint32_t l_614 = 0xD26F87D0L;
    int32_t *l_620 = &l_493;
    (*l_494) = l_490;
    /* statement id: 279 */
    assert (l_495 == &l_491);
    (***l_494) = (void*)0;
    /* statement id: 280 */
    assert (l_492 == 0);
    return p_72;
    /* statement id: 398 */
    //assert (func_71_rv == &l_75);
}


/* ------------------------------------------ */
/* 
 * reads : l_75
 * writes:
 */
inline static int32_t  func_80(int32_t * p_81, int32_t * p_82)
{ /* block id: 191 */
    int16_t l_328 = 0xF9DEL;
    int32_t *l_371 = (void*)0;
    int16_t l_417 = 0x5129L;
    int64_t l_438 = 0L;
    uint64_t l_463 = 0x5CE79FC57478550BLL;
    if (l_328)
    { /* block id: 192 */
        int32_t l_329 = 0x189E2EE1L;
        return l_329;
    }
    else
    { /* block id: 194 */
        int32_t l_333 = 0x1C5F3EB5L;
        int32_t *l_332 = &l_333;
        int16_t l_353 = (-2L);
        uint32_t l_454 = 9UL;
        uint32_t l_489 = 0x373FF71AL;
        if ((*p_82))
        { /* block id: 195 */
            uint8_t l_344 = 0x10L;
            int32_t *l_367 = &l_333;
            const int32_t ****l_394 = (void*)0;
            for (l_328 = (-15); (l_328 >= (-26)); l_328 -= 7)
            { /* block id: 198 */
                int32_t **l_334 = &l_332;
                int32_t l_370 = 0x15903892L;
                int32_t ***l_396 = (void*)0;
                int32_t **** const l_395 = &l_396;
                if ((*p_82))
                    break;
                (*l_334) = l_332;
            }
            for (l_328 = 19; (l_328 > 21); l_328 += 3)
            { /* block id: 229 */
                uint64_t l_401 = 18446744073709551615UL;
                int32_t **l_418 = &l_367;
            }
        }
        else
        { /* block id: 235 */
            uint64_t l_419 = 0UL;
            int32_t **l_422 = &l_371;
            if (__builtin_ctzll(((l_419 != ((int64_t)0xBC589DB039A92ECBLL % (int64_t)(((0x5249B644L >= l_419) > 0x7356L) | 0x26268EC3L))) > 0xB27B9A7BD52007E8LL)))
            { /* block id: 236 */
                int64_t l_423 = 0x942059156C5D7C6ELL;
                float l_425 = 0x1.5p+1;
                float *l_424 = &l_425;
                (*l_424) = (((0xA.EAFA43p-65 == (l_422 == &l_371)) == l_423) != (p_81 != p_82));
            }
            else
            { /* block id: 238 */
                return l_419;
            }
            if (((int16_t)(((((int16_t)(((int32_t)((uint16_t)((*l_332) > ((int16_t)(*l_332) % (int16_t)(*l_332))) / (uint16_t)l_417) % (int32_t)__builtin_clz(l_438)) >= ((*l_332) < ((l_438 ^ (~(((*l_332) | (*l_332)) > (*l_332)))) || 0UL))) << (int16_t)7) && 0xDA72L) >= (*l_332)) && 0UL) + (int16_t)6UL))
            { /* block id: 241 */
                const int32_t *l_444 = &l_333;
                const int32_t **l_443 = &l_444;
                const int32_t *** const l_442 = &l_443;
                if (((((uint32_t)(l_442 != &l_422) + (uint32_t)((void*)0 != &p_81)) >= (***l_442)) != l_417))
                { /* block id: 242 */
                    uint32_t l_445 = 1UL;
                    (*l_332) = (((((*l_332) < (l_445 ^ (l_419 > ((uint16_t)(((uint16_t)(*l_444) - (uint16_t)((uint32_t)(((int16_t)(*l_332) - (int16_t)((*l_444) || (***l_442))) > ((*p_82) == ((***l_442) | 8L))) % (uint32_t)l_445)) & 4294967295UL) << (uint16_t)9)))) || (*p_82)) == l_454) | (***l_442));
                }
                else
                { /* block id: 244 */
                    uint32_t l_464 = 0x9522852FL;
                    float l_466 = 0xD.386218p+78;
                    float *l_465 = &l_466;
                    uint64_t l_470 = 18446744073709551615UL;
                    int32_t l_479 = 0x1D432DFEL;
                    for (l_417 = 3; (l_417 >= 8); l_417++)
                    { /* block id: 247 */
                        float *l_457 = (void*)0;
                        float l_459 = 0xC.3B2545p+26;
                        float *l_458 = &l_459;
                        int32_t l_460 = (-1L);
                        (*l_458) = 0x7.CFCFFBp-69;
                    }
                    (*l_465) = l_464;
                    for (l_463 = 15; (l_463 >= 19); l_463 += 6)
                    { /* block id: 255 */
                        int16_t l_469 = 0L;
                        (*l_332) = (*p_82);
                        (*l_422) = (void*)0;
                        (*l_422) = func_83(l_464, (l_469 == (l_470 > ((float)0x0.58F848p+95 / (float)((float)0xD.DFA9CBp+19 / (float)0x0.5p-1)))), (*l_332));
                    }
                    l_479 = ((((float)(p_82 == (void*)0) / (float)l_470) > (*l_332)) <= ((float)l_470 + (float)l_464));
                }
                (*l_332) = ((int16_t)l_463 << (int16_t)7);
            }
            else
            { /* block id: 263 */
                for (l_333 = (-2); (l_333 == (-27)); l_333 -= 1)
                { /* block id: 266 */
                    float l_484 = 0x4.0A2E9Cp+75;
                    float *l_485 = &l_484;
                    (*l_485) = l_484;
                }
                for (l_419 = (-25); (l_419 == 11); l_419 += 5)
                { /* block id: 271 */
                    int32_t *l_488 = (void*)0;
                    (*l_422) = l_488;
                }
            }
        }
        return l_489;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_83(uint16_t  p_84, float  p_85, uint32_t  p_86)
{ /* block id: 40 */
    float l_90 = (-0x1.Dp+1);
    int32_t l_102 = 1L;
    int32_t *l_138 = &l_102;
    int32_t l_240 = (-1L);
    int32_t * const ** const l_245 = (void*)0;
    int32_t *l_261 = &l_102;
    int32_t *l_262 = &l_102;
    int32_t *l_264 = &l_102;
    float l_321 = 0xF.661FE9p-72;
    int32_t *l_327 = (void*)0;
lbl_135:
    l_102 = (((float)l_90 - (float)0x0.0p+1) >= ((float)((float)((0x9.631148p-47 != (-0x2.4p+1)) < func_95(((float)p_85 / (float)l_102), &l_102, &l_102, l_102)) + (float)l_102) - (float)0xB.A0C7D0p-10));
    if ((-(int32_t)p_86))
    { /* block id: 45 */
        int32_t *l_106 = (void*)0;
        int32_t **l_107 = &l_106;
        const uint64_t l_134 = 0x8DAF57E05BCBD5E9LL;
        int32_t *l_139 = (void*)0;
        int32_t *l_269 = (void*)0;
        int32_t *l_323 = &l_240;
        int32_t *l_325 = (void*)0;
        (*l_107) = l_106;
        if (((l_102 || 0xA07EB839L) != ((-7L) && p_86)))
        { /* block id: 47 */
            uint32_t l_108 = 4294967295UL;
            int32_t *l_112 = (void*)0;
            int32_t l_113 = 1L;
            uint64_t l_166 = 0x4D215D55B7793343LL;
            int32_t *l_194 = (void*)0;
            int32_t *l_204 = (void*)0;
            l_113 = ((l_108 > (l_108 <= (&l_106 != (void*)0))) >= (((uint64_t)(!l_102) / (uint64_t)(-1L)) || p_86));
            if (((int16_t)1L << (int16_t)(p_86 == (3L ^ p_86))))
            { /* block id: 49 */
                int32_t l_119 = 0L;
                float l_129 = 0x9.04E807p-23;
                l_119 = (((uint16_t)((((~l_119) & ((int32_t)__builtin_popcountll(((l_102 ^ 0x41B8L) == l_113)) % (int32_t)p_84)) == ((void*)0 == (*l_107))) ^ l_108) << (uint16_t)8) & p_86);
                if (((p_86 >= ((uint16_t)(((0L || ((uint64_t)l_119 % (uint64_t)p_84)) >= ((uint64_t)p_86 / (uint64_t)((l_119 <= (+(p_84 || p_84))) | p_86))) || l_102) << (uint16_t)p_84)) & 0xB6C30C227312B8DCLL))
                { /* block id: 51 */
                    int32_t *l_130 = (void*)0;
                    int32_t *l_131 = &l_102;
                    (*l_131) = l_102;
                }
                else
                { /* block id: 53 */
                    int32_t **l_136 = &l_112;
                    (*l_107) = &l_113;
                    /* statement id: 54 */
                    assert (l_106 == &l_113);
                    for (p_86 = 7; (p_86 < 53); p_86 += 4)
                    { /* block id: 57 */
                        float *l_137 = &l_90;
                        if (l_134)
                            break;
                        if (l_119)
                            goto lbl_135;
                        (*l_137) = ((void*)0 == l_136);
                    }
                }
                /* facts after branching */
                assert (l_106 == &l_113 || l_106 == 0);
                return l_139;
                /* statement id: 63 */
                //assert (func_83_rv == 0);
            }
            else
            { /* block id: 64 */
                int16_t l_142 = 0x0F84L;
                int32_t *l_151 = (void*)0;
                for (p_86 = 0; (p_86 >= 20); p_86 += 5)
                { /* block id: 67 */
                    uint8_t l_162 = 0UL;
                    float l_188 = (-0x3.Cp-1);
                    if (l_142)
                    { /* block id: 68 */
                        int32_t l_145 = 7L;
                        float *l_146 = &l_90;
                        (*l_138) = ((int64_t)__builtin_parity(p_86) / (int64_t)p_84);
                        (*l_146) = l_145;
                        (*l_107) = (*l_107);
                    }
                    else
                    { /* block id: 72 */
                        uint16_t l_154 = 0x2AB3L;
                        int32_t **l_161 = &l_139;
                        float *l_163 = &l_90;
                        (*l_163) = ((float)((float)(((void*)0 == l_151) <= (((float)(func_95(l_154, &l_102, l_151, (((((l_154 && ((uint16_t)(((uint32_t)((((uint64_t)(&l_112 != l_161) + (uint64_t)(p_84 <= p_86)) || p_86) >= p_84) - (uint32_t)l_162) <= 0xD48EL) - (uint16_t)p_86)) & (-10L)) == 0x441C1EEBL) || 4294967293UL) >= p_86)) == l_162) / (float)0x1.2p-1) > 0x1.6p+1)) - (float)p_86) + (float)p_86);
                        if (p_86)
                            continue;
                    }
                    for (l_162 = (-10); (l_162 == 13); l_162 += 4)
                    { /* block id: 78 */
                        int32_t l_173 = 1L;
                        float *l_181 = &l_90;
                        (*l_138) = (l_166 & ((uint16_t)p_84 - (uint16_t)(((int16_t)(0xB4AFCFEDL == ((uint32_t)l_173 % (uint32_t)((-(uint32_t)((int16_t)(p_86 ^ ((((int16_t)((((p_84 || (__builtin_clzll(p_86) < p_86)) ^ 0x8DE2FC49AC2DAC23LL) > p_84) < (*l_138)) >> (int16_t)12) >= l_173) == p_86)) / (int16_t)p_84)) || 0L))) >> (int16_t)p_84) != l_173)));
                        (*l_138) = ((p_86 == (((uint64_t)l_108 * (uint64_t)(l_181 == l_106)) > ((uint64_t)l_173 - (uint64_t)((int16_t)p_86 - (int16_t)(&l_112 == (void*)0))))) & ((int32_t)p_86 / (int32_t)p_84));
                    }
                    for (l_142 = (-19); (l_142 <= 25); l_142++)
                    { /* block id: 84 */
                        uint16_t l_191 = 0x733FL;
                        int32_t * const l_192 = &l_113;
                        int32_t **l_193 = &l_112;
                        l_191 = p_84;
                        (*l_193) = l_192;
                        /* statement id: 86 */
                        assert (l_112 == &l_113);
                        return l_194;
                        /* statement id: 87 */
                        //assert (func_83_rv == 0);
                    }
                }
                (*l_138) = (4294967290UL <= ((0UL <= ((void*)0 == l_151)) != ((int16_t)(__builtin_clz(p_86) && p_86) % (int16_t)p_84)));
            }
            for (l_108 = 7; (l_108 >= 32); l_108++)
            { /* block id: 94 */
                int32_t l_209 = 0x6A9AA895L;
                int32_t l_219 = 0xA435B6E9L;
                int32_t ***l_231 = (void*)0;
                float *l_251 = (void*)0;
                int32_t *l_260 = &l_219;
                int32_t *l_263 = (void*)0;
                for (l_102 = 10; (l_102 == 9); l_102--)
                { /* block id: 97 */
                    int32_t *l_203 = &l_113;
                    (*l_107) = (*l_107);
                    (*l_203) = ((uint16_t)1UL + (uint16_t)p_84);
                    return l_204;
                    /* statement id: 100 */
                    //assert (func_83_rv == 0);
                }
                for (p_86 = 4; (p_86 == 47); p_86 += 4)
                { /* block id: 104 */
                    int32_t ***l_207 = &l_107;
                    uint8_t l_220 = 0xCFL;
                    int32_t l_237 = 0x3C0FEA0DL;
                    (*l_207) = &l_106;
                    if (p_84)
                    { /* block id: 106 */
                        uint8_t l_208 = 0x17L;
                        int32_t l_210 = 0L;
                        l_209 = l_208;
                        l_210 = p_84;
                        l_220 = ((int64_t)p_84 + (int64_t)(p_84 && (p_86 >= ((((p_86 | p_84) < ((int64_t)p_84 - (int64_t)p_86)) & (((int16_t)p_86 >> (int16_t)1) <= __builtin_parityll(p_84))) <= l_219))));
                    }
                    else
                    { /* block id: 110 */
                        int16_t l_221 = (-4L);
                        (*l_107) = (*l_107);
                        (*l_138) = l_221;
                    }
                    l_209 = ((int64_t)((uint16_t)(*l_138) / (uint16_t)p_86) - (int64_t)p_84);
                    for (l_102 = 0; (l_102 >= 11); l_102 += 9)
                    { /* block id: 117 */
                        float *l_234 = &l_90;
                        int32_t *l_235 = &l_219;
                        uint8_t l_236 = 0xBAL;
                        (*l_234) = (+((float)(l_231 != &l_107) / (float)((p_85 >= ((*l_138) > ((float)p_85 / (float)__builtin_ffsll(p_84)))) == p_86)));
                        l_235 = (*l_107);
                        /* statement id: 119 */
                        assert (l_235 == &l_102 || l_235 == 0);
                        l_237 = l_236;
                    }
                }
                if (((p_86 ^ 0x66ADL) || (p_84 || __builtin_ia32_crc32qi((p_86 | (((uint16_t)p_84 >> (uint16_t)7) == l_240)), __builtin_clz(((((uint16_t)p_84 << (uint16_t)7) > p_84) | (((uint64_t)l_209 + (uint64_t)p_84) != 65532UL)))))))
                { /* block id: 123 */
                    int32_t ****l_246 = &l_231;
                    int32_t *l_250 = (void*)0;
                    (*l_246) = l_245;
                    for (l_166 = 0; (l_166 <= 24); l_166 += 2)
                    { /* block id: 127 */
                        int32_t *l_249 = (void*)0;
                        return l_249;
                        /* statement id: 128 */
                        //assert (func_83_rv == 0);
                    }
                    (*l_138) = p_86;
                    return l_250;
                    /* statement id: 131 */
                    //assert (func_83_rv == 0);
                }
                else
                { /* block id: 132 */
                    int32_t l_254 = 0L;
                    const int32_t *l_258 = &l_113;
                    const int32_t **l_257 = &l_258;
                    if ((((void*)0 != l_251) & ((int16_t)l_254 / (int16_t)l_219)))
                    { /* block id: 133 */
                        (*l_107) = &l_102;
                        /* statement id: 134 */
                        assert (l_106 == &l_102);
                        if ((*l_138))
                            continue;
                        if (p_86)
                            break;
                        (**l_107) = ((p_84 ^ l_254) && ((uint64_t)((*l_138) & ((((void*)0 != l_257) < (p_84 != p_86)) ^ (l_231 != l_231))) - (uint64_t)p_84));
                    }
                    else
                    { /* block id: 138 */
                        int32_t *l_259 = &l_254;
                        (*l_107) = (*l_107);
                        return l_263;
                        /* statement id: 140 */
                        //assert (func_83_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_106 == &l_102);
                }
                /* facts after branching */
                assert (l_106 == &l_102);
            }
            /* facts after for loop */
            assert (l_106 == &l_102 || l_106 == 0);
        }
        else
        { /* block id: 144 */
            int32_t *l_265 = &l_240;
            int32_t l_298 = (-1L);
            uint64_t l_308 = 18446744073709551615UL;
            int32_t *l_324 = &l_298;
            l_265 = l_264;
            /* statement id: 145 */
            assert (l_265 == &l_102);
            (*l_107) = (void*)0;
            for (l_240 = 15; (l_240 <= (-1)); --l_240)
            { /* block id: 149 */
                int32_t *l_268 = &l_102;
                return l_269;
                /* statement id: 150 */
                //assert (func_83_rv == 0);
            }
            if (((int16_t)(0x388FL & 65535UL) - (int16_t)((uint32_t)(+(!((&l_106 != (void*)0) == ((p_84 || (*l_265)) == ((65535UL ^ p_86) > ((void*)0 != (*l_107))))))) / (uint32_t)p_86)))
            { /* block id: 152 */
                int64_t l_278 = 0x77810F05B0942148LL;
                int32_t * const l_300 = &l_102;
                int32_t *l_301 = (void*)0;
                if (l_278)
                { /* block id: 153 */
                    int16_t l_283 = (-6L);
                    int32_t * const l_292 = &l_240;
                    int32_t **l_299 = &l_138;
                    for (l_102 = (-17); (l_102 != (-17)); l_102 += 7)
                    { /* block id: 156 */
                        int64_t l_286 = (-1L);
                        int32_t *l_291 = &l_102;
                        if (p_86)
                            break;
                        l_298 = ((uint16_t)l_283 << (uint16_t)((uint64_t)l_286 % (uint64_t)((uint16_t)(0xEE2376F68FCF27A2LL ^ ((uint16_t)(l_291 == l_292) << (uint16_t)6)) << (uint16_t)(+((l_278 ^ p_84) || ((uint16_t)p_86 << (uint16_t)((uint16_t)(*l_265) >> (uint16_t)p_84)))))));
                        (*l_292) = p_84;
                    }
                    (*l_299) = l_292;
                    /* statement id: 161 */
                    assert (l_138 == &l_240);
                    l_301 = l_300;
                    /* statement id: 162 */
                    assert (l_301 == &l_102);
                    (*l_265) = ((void*)0 != l_292);
                }
                else
                { /* block id: 164 */
                    float *l_302 = &l_90;
                    int32_t ***l_305 = &l_107;
                    int32_t ****l_304 = &l_305;
                    int32_t *****l_303 = &l_304;
                    (*l_302) = p_84;
                    (*l_303) = (void*)0;
                    /* statement id: 166 */
                    assert (l_304 == 0);
                    (**l_305) = (void*)0;
                    (*l_300) = (*l_300);
                }
                /* facts after branching */
                assert (l_138 == &l_102 || l_138 == &l_240);
                assert (l_301 == 0 || l_301 == &l_102);
                for (p_84 = 17; (p_84 <= 47); p_84++)
                { /* block id: 172 */
                    if (l_308)
                    { /* block id: 173 */
                        const int32_t *l_311 = &l_102;
                        const int32_t **l_310 = &l_311;
                        const int32_t ***l_309 = &l_310;
                        (*l_309) = &l_139;
                        /* statement id: 174 */
                        assert (l_310 == &l_139);
                    }
                    else
                    { /* block id: 175 */
                        float *l_312 = (void*)0;
                        float *l_313 = &l_90;
                        uint16_t l_314 = 0x127EL;
                        (*l_313) = __builtin_clz((*l_265));
                        (*l_262) = (0x3D273D35L > (((p_86 != ((((*l_261) & (((((*l_300) == p_86) && __builtin_ctz(p_86)) < (((l_312 != l_313) > 0L) || (*l_261))) ^ 0UL)) == l_314) ^ (*l_261))) || p_84) > p_86));
                        p_85 = __builtin_ctzll(((uint64_t)p_84 / (uint64_t)(*l_265)));
                    }
                }
            }
            else
            { /* block id: 181 */
                float *l_322 = &l_321;
                (*l_107) = &l_298;
                /* statement id: 182 */
                assert (l_106 == &l_298);
                (*l_322) = __builtin_parityl(((int16_t)p_84 + (int16_t)((p_86 < ((int64_t)(*l_138) % (int64_t)p_86)) < __builtin_ctzll(p_84))));
                return l_325;
                /* statement id: 184 */
                //assert (func_83_rv == 0);
            }
            /* facts after branching */
            assert (l_138 == &l_102 || l_138 == &l_240);
        }
        /* facts after branching */
        assert (l_106 == &l_102 || l_106 == 0);
        assert (l_138 == &l_102 || l_138 == &l_240);
    }
    else
    { /* block id: 187 */
        int32_t *l_326 = (void*)0;
        return l_326;
        /* statement id: 188 */
        //assert (func_83_rv == 0);
    }
    /* facts after branching */
    assert (l_138 == &l_102 || l_138 == &l_240);
    return l_327;
    /* statement id: 190 */
    //assert (func_83_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_95(float  p_96, int32_t * p_97, int32_t * p_98, int16_t  p_99)
{ /* block id: 41 */
    int32_t l_103 = 0L;
    int32_t l_104 = 5L;
    l_104 = __builtin_ffsl(l_103);
    return l_104;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 182
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 169
   depth: 2, occurrence: 27
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 8, occurrence: 4
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 2

XXX total number of pointers: 156

XXX times a variable address is taken: 145
XXX times a pointer is dereferenced on RHS: 155
breakdown:
   depth: 1, occurrence: 131
   depth: 2, occurrence: 16
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 117
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 612

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 396
   level: 2, occurrence: 82
   level: 3, occurrence: 58
   level: 4, occurrence: 20
   level: 5, occurrence: 12
XXX number of pointers point to pointers: 51
XXX number of pointers point to scalars: 105
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 32.7
XXX average alias set size: 1.19

XXX times a non-volatile is read: 908
XXX times a non-volatile is write: 323
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 3

XXX stmts: 149
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 11
   depth: 3, occurrence: 22
   depth: 4, occurrence: 34
   depth: 5, occurrence: 39

XXX percentage a fresh-made variable is used: 12.9
XXX percentage an existing variable is used: 87.1
********************* end of statistics **********************/

