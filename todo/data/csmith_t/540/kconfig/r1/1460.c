/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3702118679
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
inline static uint32_t  func_6(uint16_t  p_7, int8_t  p_8, int8_t  p_9, uint16_t  p_10, uint16_t  p_11);
inline static int8_t  func_12(int32_t  p_13, int8_t  p_14, int32_t  p_15);
inline static uint8_t  func_25(int16_t  p_26, uint32_t  p_27, int16_t  p_28, const int32_t  p_29, uint16_t  p_30);
static uint16_t  func_37(uint8_t  p_38, uint8_t  p_39);
static uint16_t  func_59(uint8_t  p_60, uint32_t  p_61, int32_t  p_62);
inline static int32_t * func_69(int16_t  p_70, int8_t  p_71);
static int32_t * func_74(const uint8_t  p_75, uint32_t  p_76, const uint8_t  p_77, int32_t * p_78, int32_t * p_79);
static int32_t * func_82(uint16_t  p_83, int8_t  p_84, int8_t  p_85, uint16_t  p_86, int32_t * p_87);
inline static int32_t * func_91(int32_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_5 = 1;
    const uint32_t l_310 = 4294967292U;
    const int8_t l_311 = 0x38;
    int32_t l_315 = 5;
    uint32_t l_531 = 0xC5D7C6E1;
    uint16_t l_533 = 65535U;
    l_533 = (safe_unary_minus_func_int16_t_s(((l_5 | ((func_6(l_5, (func_12(l_5, (((~(safe_div_func_uint8_t_u_u(((l_5 != ((safe_sub_func_uint8_t_u_u(0x45, 0xE8)) < (safe_mod_func_int32_t_s_s((func_25((safe_div_func_uint32_t_u_u((safe_div_func_uint8_t_u_u(l_5, (safe_lshift_func_uint16_t_u_u(func_37(l_5, (((safe_add_func_uint16_t_u_u((1U & 0), l_5)) < l_5) && l_5)), 11)))), l_310)), l_5, l_310, l_311, l_310) ^ l_310), l_311)))) & l_311), l_311))) < 0x01E7905C) <= l_311), l_315) < l_310), l_531, l_311, l_311) | 4294967295U) <= 1U)) > l_5)));
    return l_531;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_6(uint16_t  p_7, int8_t  p_8, int8_t  p_9, uint16_t  p_10, uint16_t  p_11)
{ /* block id: 248 */
    uint16_t l_532 = 2U;
    return l_532;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_12(int32_t  p_13, int8_t  p_14, int32_t  p_15)
{ /* block id: 156 */
    int32_t * const *l_322 = (void*)0;
    uint32_t l_323 = 0x78151E72;
    const uint16_t l_326 = 0U;
    uint32_t l_332 = 4294967291U;
    int32_t l_349 = 0x9DD1D02C;
    int32_t *l_348 = &l_349;
    uint8_t l_417 = 1U;
    uint32_t l_507 = 0x1BD6C52F;
    int32_t l_526 = (-8);
    if ((((safe_lshift_func_int8_t_s_u(((safe_lshift_func_uint8_t_u_s(0x5C, 6)) <= ((l_322 == l_322) == (l_323 > (p_15 == 0x8951)))), 5)) && ((safe_sub_func_int8_t_s_s((&l_322 == &l_322), (l_326 & 1U))) != l_326)) ^ p_13))
    { /* block id: 157 */
        int32_t l_329 = 0x71CD10DC;
        int32_t *l_345 = &l_329;
        int32_t **l_344 = &l_345;
        int32_t ***l_343 = &l_344;
        int16_t l_421 = (-4);
        const int32_t *l_422 = (void*)0;
        int32_t **l_423 = &l_348;
        for (l_323 = 0; (l_323 == 43); l_323 = safe_add_func_uint8_t_u_u(l_323, 5))
        { /* block id: 160 */
            uint16_t l_346 = 0x6275;
            uint32_t l_347 = 4294967295U;
            int32_t *l_394 = &l_329;
        }
        l_348 = func_69(p_13, (0xF69B3A08 == ((**l_343) == &p_15)));
        /* statement id: 182 */
        assert (l_348 == 0);
        (**l_343) = func_91((*l_345));
        /* statement id: 183 */
        assert (l_345 == 0);
        (*l_423) = l_422;
    }
    else
    { /* block id: 185 */
        uint8_t l_428 = 0xE6;
        int32_t **l_442 = (void*)0;
        int32_t ****l_462 = (void*)0;
        int32_t * const **l_511 = (void*)0;
        int32_t **l_530 = &l_348;
    }
    /* facts after branching */
    assert (l_348 == &l_349 || l_348 == 0);
    return p_13;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_25(int16_t  p_26, uint32_t  p_27, int16_t  p_28, const int32_t  p_29, uint16_t  p_30)
{ /* block id: 153 */
    int32_t l_313 = 0x40E6E93F;
    int32_t *l_312 = &l_313;
    int32_t **l_314 = &l_312;
    (*l_314) = l_312;
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_37(uint8_t  p_38, uint8_t  p_39)
{ /* block id: 1 */
    uint32_t l_63 = 0xDBB389E7;
    int32_t l_280 = 0xDD07A39A;
    int32_t *l_279 = &l_280;
    for (p_38 = 15; (p_38 != 21); p_38 = safe_add_func_uint16_t_u_u(p_38, 1))
    { /* block id: 4 */
        int32_t l_56 = 0x1CC49297;
        int32_t **l_289 = (void*)0;
        int32_t l_290 = (-8);
        if ((safe_rshift_func_int8_t_s_u(p_38, (((0x8D10 <= ((safe_sub_func_int16_t_s_s((p_38 > (safe_lshift_func_uint16_t_u_u(((((!(safe_unary_minus_func_int8_t_s((1 <= (safe_div_func_int8_t_s_s(((safe_div_func_int8_t_s_s((p_38 ^ l_56), p_39)) ^ (safe_div_func_uint32_t_u_u((func_59(l_63, ((safe_mod_func_int16_t_s_s(p_39, 0x4633)) != l_63), p_39) < l_63), l_56))), l_63)))))) | 0xF369) || l_63) <= l_56), 3))), l_56)) == 1U)) | p_38) < 0xD814))))
        { /* block id: 119 */
            int32_t *l_265 = &l_56;
            int32_t **l_264 = &l_265;
            (*l_264) = &l_56;
        }
        else
        { /* block id: 121 */
            int32_t l_273 = (-1);
            const int32_t *l_282 = &l_273;
            const int16_t l_295 = 0xF6E7;
            for (l_56 = 5; (l_56 > (-27)); l_56 = safe_sub_func_int16_t_s_s(l_56, 1))
            { /* block id: 124 */
                const int32_t *l_270 = &l_56;
                int32_t **l_298 = (void*)0;
                int32_t **l_299 = &l_279;
            }
            if (p_39)
                continue;
        }
        for (p_39 = 0; (p_39 > 42); p_39 = safe_add_func_uint32_t_u_u(p_39, 1))
        { /* block id: 147 */
            (*l_279) = p_38;
        }
        (*l_279) = ((*l_279) | ((((((safe_div_func_uint32_t_u_u((&l_280 != (void*)0), p_39)) != ((safe_sub_func_int32_t_s_s(p_38, (safe_rshift_func_uint16_t_u_s(65526U, ((*l_279) ^ ((((0x9627 > (safe_sub_func_uint32_t_u_u((*l_279), (*l_279)))) != (*l_279)) & p_39) >= p_39)))))) <= p_39)) > (*l_279)) <= p_39) && p_39) ^ 0U));
    }
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_59(uint8_t  p_60, uint32_t  p_61, int32_t  p_62)
{ /* block id: 5 */
    int8_t l_68 = 0xC0;
    int32_t l_248 = (-3);
    int32_t *l_247 = &l_248;
    int32_t l_249 = (-1);
    int32_t *l_250 = &l_248;
    uint16_t l_259 = 0xBFDC;
    for (p_61 = (-27); (p_61 <= 29); p_61 = safe_add_func_uint16_t_u_u(p_61, 9))
    { /* block id: 8 */
        return l_68;
    }
    l_247 = func_69(l_68, p_61);
    /* statement id: 115 */
    assert (l_247 == 0);
    (*l_250) = l_249;
    (*l_250) = (safe_rshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s((&l_247 == (void*)0), (safe_lshift_func_int16_t_s_u((safe_add_func_int16_t_s_s(((l_259 | 1U) < p_61), (*l_250))), 1)))), (p_60 >= (safe_rshift_func_uint16_t_u_u((safe_rshift_func_int8_t_s_u(p_60, 5)), 5)))));
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_69(int16_t  p_70, int8_t  p_71)
{ /* block id: 11 */
    int32_t l_81 = 0x20AF47DF;
    int32_t *l_246 = (void*)0;
    for (p_70 = 0; (p_70 > 14); ++p_70)
    { /* block id: 14 */
        const int32_t l_80 = 0xF0B62E56;
        int32_t *l_88 = (void*)0;
        int32_t **l_245 = &l_88;
        (*l_245) = func_74(l_80, l_81, p_71, &l_81, func_82(l_80, p_70, p_71, (l_88 != (void*)0), &l_81));
        /* statement id: 112 */
        assert (l_88 == &l_81);
    }
    return l_246;
    /* statement id: 114 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(const uint8_t  p_75, uint32_t  p_76, const uint8_t  p_77, int32_t * p_78, int32_t * p_79)
{ /* block id: 74 */
    int8_t l_203 = 1;
    int32_t l_239 = (-7);
    const int32_t *l_238 = &l_239;
    const int32_t **l_237 = &l_238;
    const int32_t *** const l_236 = &l_237;
    for (p_76 = (-17); (p_76 <= 10); p_76 = safe_add_func_uint32_t_u_u(p_76, 1))
    { /* block id: 77 */
        int32_t l_193 = 1;
        const int32_t *l_192 = &l_193;
        const int32_t **l_191 = &l_192;
        int32_t l_224 = 9;
        (*l_191) = p_78;
        /* statement id: 78 */
        //assert (l_192 == &l_81 || l_192 == 0 || l_192 == &l_349);
        for (l_193 = 0; (l_193 >= 13); ++l_193)
        { /* block id: 81 */
            int8_t l_198 = 0x07;
            int32_t *l_223 = (void*)0;
            int32_t **l_222 = &l_223;
            int32_t ***l_221 = &l_222;
        }
    }
    if (l_203)
    { /* block id: 100 */
        int32_t l_227 = 0xA9E36F56;
        int32_t * const l_235 = &l_227;
        int32_t * const *l_234 = &l_235;
        int32_t * const **l_233 = &l_234;
        uint8_t l_242 = 254U;
        for (l_203 = 0; (l_203 != 10); ++l_203)
        { /* block id: 103 */
            uint32_t l_232 = 0xCD7AFF63;
            int32_t l_243 = (-1);
            (*l_235) = (l_227 < (safe_sub_func_uint8_t_u_u(((safe_div_func_uint16_t_u_u((l_232 | ((0xC6 ^ p_76) <= (l_233 == l_236))), ((p_77 <= (((*l_238) && ((safe_div_func_int8_t_s_s((*l_235), 0x5E)) < l_242)) ^ 5)) ^ 0U))) == (**l_237)), l_243)));
        }
    }
    else
    { /* block id: 106 */
        int32_t *l_244 = &l_239;
        return p_79;
        /* statement id: 107 */
        //assert (func_74_rv == &l_81 || func_74_rv == &l_273 || func_74_rv == &l_349);
    }
    (**l_236) = (*l_237);
    (*l_237) = p_79;
    /* statement id: 110 */
    //assert (l_238 == &l_81 || l_238 == &l_273 || l_238 == &l_349);
    return p_78;
    /* statement id: 111 */
    //assert (func_74_rv == &l_81 || func_74_rv == 0 || func_74_rv == &l_349);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_82(uint16_t  p_83, int8_t  p_84, int8_t  p_85, uint16_t  p_86, int32_t * p_87)
{ /* block id: 15 */
    int32_t l_94 = 4;
    int32_t *l_122 = (void*)0;
    for (p_85 = 23; (p_85 != (-19)); p_85 = safe_sub_func_int32_t_s_s(p_85, 6))
    { /* block id: 18 */
        uint8_t l_97 = 0x15;
        int32_t **l_125 = &l_122;
        int32_t *l_134 = (void*)0;
        int32_t l_135 = 0x8FD2EAD1;
        l_122 = func_91((~(l_94 | (safe_add_func_int16_t_s_s((-6), l_97)))));
        l_135 = ((safe_lshift_func_uint8_t_u_s((l_125 == (void*)0), 6)) && (safe_sub_func_int16_t_s_s((safe_mod_func_int16_t_s_s(p_86, (safe_sub_func_uint16_t_u_u(0U, (safe_lshift_func_uint8_t_u_u((0x2A == p_84), 3)))))), (((p_87 == (*l_125)) && (((*l_125) != (*l_125)) <= p_85)) && l_94))));
        return p_87;
        /* statement id: 30 */
        //assert (func_82_rv == &l_81);
    }
    for (p_85 = 1; (p_85 > 11); p_85 = safe_add_func_int8_t_s_s(p_85, 1))
    { /* block id: 34 */
        uint16_t l_167 = 0xABA0;
        int32_t **l_170 = &l_122;
        for (l_94 = 0; (l_94 > (-11)); l_94--)
        { /* block id: 37 */
            int8_t l_144 = 1;
            int32_t **l_145 = &l_122;
            int32_t *l_186 = &l_94;
            (*l_145) = func_91((safe_div_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_s(l_144, (p_84 >= p_85))), (-1))));
        }
        if (l_167)
            continue;
        for (p_86 = 24; (p_86 > 29); p_86 = safe_add_func_int16_t_s_s(p_86, 1))
        { /* block id: 69 */
            return p_87;
            /* statement id: 70 */
            //assert (func_82_rv == &l_81);
        }
    }
    return p_87;
    /* statement id: 73 */
    //assert (func_82_rv == &l_81);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_91(int32_t  p_92)
{ /* block id: 19 */
    int32_t l_98 = 0x1B3E233D;
    int32_t l_106 = 0x1B10CD78;
    int32_t *l_105 = &l_106;
    int32_t **l_108 = &l_105;
    int32_t *l_112 = &l_106;
    int32_t *l_113 = &l_106;
    int32_t *l_114 = &l_106;
    int32_t *l_115 = &l_106;
    int32_t *l_116 = &l_106;
    int32_t *l_117 = &l_106;
    int32_t *l_118 = &l_106;
    int32_t *l_119 = &l_106;
    int32_t *l_120 = &l_106;
    int32_t *l_121 = (void*)0;
    p_92 = (l_98 && ((&p_92 != (void*)0) >= (safe_add_func_uint32_t_u_u((safe_mod_func_uint8_t_u_u(((safe_add_func_int8_t_s_s((((l_105 == (void*)0) != (*l_105)) ^ (*l_105)), (~p_92))) || (&l_106 != &l_106)), (*l_105))), (*l_105)))));
    (*l_108) = &l_106;
    for (l_106 = (-11); (l_106 == (-27)); l_106 = safe_sub_func_int16_t_s_s(l_106, 1))
    { /* block id: 24 */
        int32_t **l_111 = (void*)0;
        l_111 = &l_105;
        /* statement id: 25 */
        assert (l_111 == &l_105);
    }
    return l_121;
    /* statement id: 27 */
    //assert (func_91_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 102
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 24, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 101

XXX times a variable address is taken: 111
XXX times a pointer is dereferenced on RHS: 55
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 7
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 334

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 123
   level: 2, occurrence: 40
   level: 3, occurrence: 15
   level: 4, occurrence: 0
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 51
XXX number of pointers point to scalars: 50
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 36.6
XXX average alias set size: 1.32

XXX times a non-volatile is read: 477
XXX times a non-volatile is write: 155
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 55
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 20
   depth: 2, occurrence: 7

XXX percentage a fresh-made variable is used: 13.8
XXX percentage an existing variable is used: 86.2
********************* end of statistics **********************/

