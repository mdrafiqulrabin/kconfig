/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      966237336
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_1(void);
inline static const int32_t  func_18(uint16_t  p_19, uint16_t  p_20, int32_t * p_21);
inline static uint16_t  func_22(uint32_t  p_23, uint8_t  p_24, int32_t ** p_25, int32_t * p_26, uint32_t  p_27);
static int16_t  func_30(int32_t ** p_31);
static int32_t ** func_32(uint16_t  p_33, uint16_t  p_34, int32_t * const  p_35);
inline static int8_t  func_38(int8_t  p_39, int32_t * const  p_40, uint16_t  p_41, uint32_t  p_42);
inline static int32_t * func_50(uint32_t  p_51, int32_t * p_52, int32_t * p_53, uint32_t  p_54, uint16_t  p_55);
static int32_t * func_58(int32_t ** p_59, int8_t  p_60);
static int8_t  func_62(int16_t  p_63, int16_t  p_64, uint8_t  p_65, int32_t ** p_66);
inline static const int32_t  func_67(int32_t  p_68);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x862FD41E;
    int32_t *l_15 = &l_2;
    int16_t l_251 = 0x0659;
    int32_t **l_252 = &l_15;
    int16_t l_262 = (-5);
    for (l_2 = 0; (l_2 >= 7); l_2 = safe_add_func_uint8_t_u_u(l_2, 9))
    { /* block id: 3 */
        uint32_t l_36 = 0x5DAA08BB;
        int32_t *l_198 = &l_2;
        uint16_t l_243 = 1U;
        if (l_2)
        { /* block id: 4 */
            int32_t l_5 = 0;
            int32_t *l_13 = &l_5;
            for (l_5 = (-20); (l_5 <= 25); l_5 = safe_add_func_int16_t_s_s(l_5, 9))
            { /* block id: 7 */
                int32_t l_8 = 0x6A756A33;
                int32_t **l_14 = &l_13;
                int32_t l_224 = 0x7D783D8B;
                for (l_8 = (-27); (l_8 >= (-7)); l_8 = safe_add_func_int8_t_s_s(l_8, 5))
                { /* block id: 10 */
                    int32_t *l_11 = &l_5;
                    int32_t **l_12 = &l_11;
                    (*l_12) = l_11;
                }
                (*l_14) = l_13;
                (*l_14) = l_15;
                /* statement id: 14 */
                assert (l_13 == &l_2);
                for (l_8 = 0; (l_8 != (-16)); l_8 = safe_sub_func_int32_t_s_s(l_8, 1))
                { /* block id: 17 */
                    int16_t l_197 = 0x7FE5;
                    if (func_18(func_22((safe_add_func_uint8_t_u_u(((l_14 == &l_13) > (1U > func_30(func_32((*l_15), l_36, &l_5)))), (safe_div_func_int8_t_s_s((l_197 != 0xE69CC3E7), (**l_14))))), (*l_13), &l_15, l_198, l_197), l_197, (*l_14)))
                    { /* block id: 68 */
                        (*l_14) = l_198;
                        (*l_14) = l_198;
                        l_224 = (*l_15);
                    }
                    else
                    { /* block id: 72 */
                        uint32_t l_248 = 4294967295U;
                        int32_t *l_249 = &l_224;
                        (*l_249) = (((0xE83F || (safe_div_func_int8_t_s_s((safe_sub_func_int8_t_s_s((safe_div_func_int16_t_s_s((!1), (safe_sub_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_u((*l_15), (((safe_mod_func_int8_t_s_s((((void*)0 == &l_198) == (safe_sub_func_uint8_t_u_u((~(l_243 | (*l_198))), 7U))), (safe_rshift_func_int16_t_s_u((safe_div_func_uint32_t_u_u((*l_15), 0x18B289E9)), 10)))) ^ l_248) || l_248))), 13)) | 0x29), (*l_13))))), (*l_13))), 249U))) >= l_197) != l_197);
                    }
                }
            }
            /* facts after for loop */
            assert (l_13 == &l_2 || l_13 == &l_5);
        }
        else
        { /* block id: 77 */
            int16_t l_250 = 9;
            return l_250;
        }
        if (l_251)
            continue;
        if ((*l_15))
            break;
    }
    (*l_252) = &l_2;
    for (l_251 = 0; (l_251 < 8); l_251 = safe_add_func_uint32_t_u_u(l_251, 1))
    { /* block id: 86 */
        uint16_t l_255 = 65531U;
        (**l_252) = (((l_255 != (safe_sub_func_int32_t_s_s((safe_rshift_func_int16_t_s_u((((**l_252) ^ (4 <= l_255)) > (safe_rshift_func_int16_t_s_u((**l_252), 12))), 2)), (255U < (((**l_252) & ((l_255 && (&l_15 == (void*)0)) ^ l_255)) | (*l_15)))))) < 0xB426B7B2) > 0x38C59D00);
    }
    return l_262;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_18(uint16_t  p_19, uint16_t  p_20, int32_t * p_21)
{ /* block id: 64 */
    int32_t l_220 = 0x7E2E2487;
    int32_t l_222 = 0x7BF4D477;
    int32_t *l_221 = &l_222;
    const uint32_t l_223 = 1U;
    (*l_221) = (l_220 & l_220);
    p_21 = &l_222;
    /* statement id: 66 */
    assert (p_21 == &l_222);
    return l_223;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_22(uint32_t  p_23, uint8_t  p_24, int32_t ** p_25, int32_t * p_26, uint32_t  p_27)
{ /* block id: 59 */
    int32_t l_201 = (-1);
    int32_t *l_200 = &l_201;
    int32_t **l_199 = &l_200;
    (**l_199) = ((void*)0 != l_199);
    (*l_200) = ((safe_add_func_int32_t_s_s((safe_sub_func_int16_t_s_s(((*p_26) || (**l_199)), ((*l_199) == (void*)0))), (((((safe_sub_func_int32_t_s_s(((((*l_200) | (safe_mod_func_uint16_t_u_u((((safe_sub_func_int16_t_s_s((safe_rshift_func_int8_t_s_s(((safe_rshift_func_int8_t_s_u((**l_199), (((safe_lshift_func_uint16_t_u_s((safe_mod_func_uint32_t_u_u(0x07F36C1B, (*l_200))), ((*l_200) >= p_27))) <= 0x043B) > p_27))) ^ (**l_199)), (**l_199))), 0x866C)) && 4294967292U) > (*l_200)), (**l_199)))) == (**l_199)) || 0x44FD), p_24)) && (*l_200)) <= 1) > (**l_199)) & 65535U))) >= (*l_200));
    (*l_199) = (*p_25);
    /* statement id: 62 */
    //assert (l_200 == &l_2);
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_30(int32_t ** p_31)
{ /* block id: 45 */
    uint16_t l_154 = 0xD3A0;
    uint32_t l_163 = 4294967295U;
    int32_t *l_164 = (void*)0;
    int32_t **l_165 = &l_164;
    uint32_t l_175 = 4294967290U;
    const int16_t l_180 = (-2);
    int32_t l_191 = 0x49C4B2C9;
    (*l_165) = l_164;
    if ((safe_mod_func_int8_t_s_s((safe_rshift_func_int16_t_s_u(((safe_sub_func_uint8_t_u_u(((((!(safe_sub_func_int8_t_s_s(l_163, (((l_154 || ((l_154 | (((*l_165) == (void*)0) || (l_175 >= (safe_lshift_func_uint8_t_u_u((safe_lshift_func_int8_t_s_s(l_180, 0)), l_163))))) & (l_154 ^ l_175))) < l_163) > l_154)))) & l_175) | l_180) <= l_154), l_154)) == 0x1CB2), l_154)), l_163)))
    { /* block id: 47 */
        uint8_t l_183 = 6U;
        int32_t l_184 = 1;
        l_184 = (safe_lshift_func_uint8_t_u_u((((*l_165) != (*l_165)) == l_183), 2));
        if (((safe_lshift_func_int8_t_s_u((((safe_sub_func_uint32_t_u_u((&l_184 != (void*)0), (safe_div_func_int32_t_s_s(l_191, 0x46F7BBE7)))) != ((l_184 >= ((void*)0 == p_31)) ^ 7)) & ((0xDBAEAE63 && l_191) > 4294967292U)), 4)) >= l_183))
        { /* block id: 49 */
            return l_183;
        }
        else
        { /* block id: 51 */
            int32_t *l_192 = &l_184;
            (*l_192) = l_183;
            return l_184;
        }
    }
    else
    { /* block id: 55 */
        int32_t *l_193 = &l_191;
        int32_t l_194 = 1;
        (*l_165) = l_193;
        /* statement id: 56 */
        assert (l_164 == &l_191);
        return l_194;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_32(uint16_t  p_33, uint16_t  p_34, int32_t * const  p_35)
{ /* block id: 18 */
    int8_t l_43 = 0x47;
    int32_t l_45 = 0x9EBEF9F3;
    int32_t * const l_44 = &l_45;
    int32_t *l_144 = &l_45;
    int32_t **l_143 = &l_144;
    int32_t **l_145 = &l_144;
    int32_t **l_146 = &l_144;
    int32_t **l_147 = &l_144;
    int32_t **l_148 = &l_144;
    int32_t **l_149 = &l_144;
    int32_t **l_150 = &l_144;
    int32_t **l_151 = &l_144;
    int32_t **l_152 = &l_144;
    int32_t **l_153 = (void*)0;
    (*l_44) = ((~(4 != func_38(l_43, l_44, (*l_44), (safe_mod_func_int32_t_s_s((*l_44), (safe_sub_func_int32_t_s_s((-5), ((*p_35) == p_33)))))))) != 1U);
    return l_153;
    /* statement id: 44 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_38(int8_t  p_39, int32_t * const  p_40, uint16_t  p_41, uint32_t  p_42)
{ /* block id: 19 */
    int32_t l_57 = 0xBB5FB49A;
    int32_t *l_56 = &l_57;
    int32_t l_136 = 0x60B33856;
    int32_t **l_139 = &l_56;
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_50(uint32_t  p_51, int32_t * p_52, int32_t * p_53, uint32_t  p_54, uint16_t  p_55)
{ /* block id: 32 */
    int32_t l_138 = 0x0AA60CB9;
    int32_t *l_137 = &l_138;
    (*p_52) = ((void*)0 != p_53);
    return p_53;
    /* statement id: 34 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_58(int32_t ** p_59, int8_t  p_60)
{ /* block id: 22 */
    uint32_t l_77 = 7U;
    const int32_t l_84 = (-10);
    const int32_t *l_83 = &l_84;
    const int32_t **l_82 = &l_83;
    uint16_t l_134 = 0xB907;
    int32_t *l_135 = (void*)0;
    (**p_59) = (func_67(((safe_div_func_uint16_t_u_u(0U, p_60)) || (((safe_add_func_int32_t_s_s((safe_mod_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u((l_77 && (((safe_lshift_func_uint16_t_u_u(0x14EF, 7)) < (p_59 == (void*)0)) != ((safe_lshift_func_int16_t_s_u((l_82 != &l_83), 2)) != p_60))), (*l_83))), p_60)), 2U)) & p_60) == 65535U))) || (**l_82));
    (*l_82) = (*l_82);
    (**p_59) = ((65527U >= (safe_lshift_func_uint16_t_u_u(7U, 0))) != ((&l_83 == &l_83) && (((safe_mod_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((*l_83), (safe_mod_func_int8_t_s_s(((**p_59) < (*l_83)), l_134)))), ((**l_82) && (**l_82)))) || (-1)) | (*l_83))));
    return l_135;
    /* statement id: 31 */
    //assert (func_58_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_62(int16_t  p_63, int16_t  p_64, uint8_t  p_65, int32_t ** p_66)
{ /* block id: 20 */
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_67(int32_t  p_68)
{ /* block id: 23 */
    uint16_t l_87 = 0U;
    uint32_t l_100 = 1U;
    const int8_t l_101 = 0xDC;
    int32_t l_103 = 0xFBD26DA6;
    int32_t *l_102 = &l_103;
    (*l_102) = ((safe_rshift_func_uint16_t_u_s((((l_87 & (safe_mod_func_int32_t_s_s(l_87, (safe_sub_func_uint16_t_u_u((((p_68 > (-4)) | ((safe_mod_func_uint32_t_u_u((safe_mod_func_int32_t_s_s(((l_87 | ((safe_sub_func_int16_t_s_s(l_87, (safe_div_func_int16_t_s_s(((l_87 | p_68) != ((l_87 ^ l_87) ^ 0xB0392260)), p_68)))) != 0x35)) == 0xF8F04B74), p_68)), l_87)) <= l_87)) >= l_87), l_100))))) >= l_100) <= (-2)), 11)) || l_101);
    (*l_102) = (p_68 && (safe_mul_func_uint8_t_u_u((~(255U < ((safe_div_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u((p_68 && ((void*)0 == &p_68)), (*l_102))), 15)), p_68)) && 0x33))), ((4294967286U || (*l_102)) != p_68))));
    (*l_102) = (safe_unary_minus_func_int32_t_s((((safe_rshift_func_int16_t_s_s(p_68, 14)) != ((&p_68 != &p_68) | (&l_102 == &l_102))) | (p_68 | (((((((safe_lshift_func_uint16_t_u_s(p_68, ((safe_sub_func_uint8_t_u_u(p_68, (((((((~(safe_unary_minus_func_int32_t_s(((safe_lshift_func_int16_t_s_u((*l_102), 2)) != p_68)))) < (*l_102)) < p_68) < 0U) < p_68) && 0x35) != p_68))) > p_68))) & 7U) == p_68) || p_68) == p_68) == p_68) == (*l_102))))));
    return p_68;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 48
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 8
   depth: 4, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 46

XXX times a variable address is taken: 49
XXX times a pointer is dereferenced on RHS: 54
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 15
XXX times a pointer is dereferenced on LHS: 24
breakdown:
   depth: 1, occurrence: 20
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 216

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 73
   level: 2, occurrence: 43
XXX number of pointers point to pointers: 21
XXX number of pointers point to scalars: 25
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 19.6
XXX average alias set size: 1.11

XXX times a non-volatile is read: 267
XXX times a non-volatile is write: 61
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 50
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 8
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 8.38
XXX percentage an existing variable is used: 91.6
********************* end of statistics **********************/

