/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3587171868
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_34(void);
static int32_t  func_35(int32_t  p_36, int16_t  p_37, int32_t  p_38, uint32_t  p_39, int16_t  p_40);
static int16_t  func_50(uint32_t  p_51, float  p_52, uint32_t  p_53, float  p_54, int16_t  p_55);
inline static int32_t * func_61(int32_t * p_62, uint32_t  p_63);
inline static int16_t  func_66(uint32_t  p_67);
inline static uint16_t  func_71(int32_t * p_72, int16_t  p_73);
inline static int32_t * func_74(uint32_t  p_75, uint16_t  p_76, float  p_77, int32_t * p_78, float  p_79);
inline static float  func_80(uint32_t  p_81, int32_t * p_82);
inline static float  func_86(int32_t *** p_87, int32_t * p_88);
static int32_t *** func_89(int32_t  p_90, uint32_t  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_34(void)
{ /* block id: 36 */
    uint32_t l_43 = 1UL;
    int32_t l_57 = 0x05243B9CL;
    uint32_t l_58 = 0x4898D08FL;
    int32_t l_497 = (-4L);
    int32_t *l_496 = &l_497;
    int16_t l_498 = (-6L);
    (*l_496) = func_35(((int16_t)(l_43 && ((int32_t)((uint16_t)((((int16_t)func_50(l_43, __builtin_ffs(l_43), __builtin_ffsll(l_43), l_43, l_43) % (int16_t)l_43) <= l_43) | l_57) % (uint16_t)l_43) % (int32_t)1UL)) >> (int16_t)l_57), l_57, l_43, l_58, l_43);
    return l_498;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(int32_t  p_36, int16_t  p_37, int32_t  p_38, uint32_t  p_39, int16_t  p_40)
{ /* block id: 39 */
    int32_t l_65 = 0L;
    int32_t *l_64 = &l_65;
    int32_t **l_284 = &l_64;
    int16_t l_298 = 0xEC67L;
    uint16_t l_343 = 0UL;
    int32_t l_369 = 0xC44FEF46L;
    int32_t *****l_398 = (void*)0;
    uint32_t l_414 = 0xAE211044L;
    int32_t ***l_448 = &l_284;
    int32_t ****l_447 = &l_448;
    uint32_t l_451 = 0xA2FEFF61L;
    uint32_t l_454 = 0x96146000L;
    uint32_t l_473 = 1UL;
    uint32_t l_492 = 0x97A130FDL;
    for (p_40 = 16; (p_40 != 12); p_40 -= 4)
    { /* block id: 42 */
        int32_t **l_257 = &l_64;
        int32_t ***l_277 = &l_257;
        int32_t ****l_276 = &l_277;
        (*l_257) = func_61(l_64, (((*l_64) | p_36) | func_66((__builtin_ctzll(((void*)0 != &p_38)) < 0x5376E30FL))));
        if ((((int16_t)(((uint16_t)func_66((__builtin_bswap64(p_36) > 0UL)) % (uint16_t)p_37) == p_38) << (int16_t)14) >= ((func_50((((int16_t)0xEE40L << (int16_t)15) || (*l_64)), p_38, (**l_257), (*l_64), (**l_257)) == 0L) == 0UL)))
        { /* block id: 173 */
            return p_37;
        }
        else
        { /* block id: 175 */
            float *l_264 = (void*)0;
            float l_266 = 0x8.0p+1;
            float *l_265 = &l_266;
            int32_t l_267 = 6L;
            int32_t ***l_268 = &l_257;
            (*l_265) = __builtin_ffsll(p_38);
            l_267 = p_37;
            (*l_268) = l_257;
            for (l_267 = (-15); (l_267 < (-27)); l_267 -= 1)
            { /* block id: 181 */
                int32_t l_280 = 0xC005DB32L;
                int32_t ***l_282 = &l_257;
                for (p_38 = 0; (p_38 > 25); p_38 += 1)
                { /* block id: 184 */
                    int16_t l_273 = 0x6F9CL;
                    int32_t *l_283 = &l_267;
                    int32_t *l_286 = &l_65;
                }
                (***l_268) = ((**l_282) == (**l_282));
                for (p_38 = 0; (p_38 <= 12); p_38 += 3)
                { /* block id: 198 */
                    (***l_276) = (void*)0;
                    (***l_276) = &p_38;
                    if (p_40)
                        break;
                }
                if (((p_39 <= (**l_284)) & p_38))
                { /* block id: 203 */
                    return p_39;
                }
                else
                { /* block id: 205 */
                    uint32_t l_289 = 0xF081A474L;
                    (****l_276) = l_289;
                    for (l_289 = 0; (l_289 > 30); l_289 += 1)
                    { /* block id: 209 */
                        return l_289;
                    }
                }
            }
        }
    }
    if ((p_36 | p_38))
    { /* block id: 216 */
        uint16_t l_294 = 0x9C5FL;
        int32_t *****l_296 = (void*)0;
        for (p_40 = 0; (p_40 >= (-1)); p_40 -= 1)
        { /* block id: 219 */
            int32_t l_295 = 0x9628F99BL;
            int32_t l_297 = (-1L);
            float l_310 = 0x3.344389p-61;
            float *l_309 = &l_310;
            if ((l_294 < 0UL))
            { /* block id: 220 */
                if (p_40)
                { /* block id: 221 */
                    return p_37;
                }
                else
                { /* block id: 223 */
                    return p_39;
                }
            }
            else
            { /* block id: 226 */
                float *l_299 = (void*)0;
                float l_301 = 0x9.EA3133p+83;
                float *l_300 = &l_301;
                int32_t **l_306 = &l_64;
                uint32_t l_308 = 18446744073709551615UL;
                (*l_300) = (((((void*)0 == (*l_284)) > (((func_71(func_74(func_50(l_295, p_36, (1L && (func_50(((0x86A3L & 0x6430L) && (((-9L) != (l_296 != (void*)0)) == p_39)), p_39, p_39, l_297, (**l_284)) <= (**l_284))), (*l_64), p_38), p_39, p_37, (*l_284), p_38), p_39) < l_295) < l_298) != 0x1.Fp+1)) >= p_40) <= (-0x1.2p-1));
                (*l_300) = (((((__builtin_clz(((uint16_t)((int32_t)0L - (int32_t)p_38) + (uint16_t)((**l_284) == (((-1L) >= (p_39 || (0xC628EA8FL || ((void*)0 != l_306)))) <= ((-(uint32_t)(**l_306)) && 3L))))) != p_38) != (**l_306)) < l_308) <= p_38) == 0x1.7p+1);
            }
            (*l_284) = &p_38;
            (*l_309) = ((&p_38 != (void*)0) >= l_297);
        }
    }
    else
    { /* block id: 233 */
        int32_t ***l_312 = &l_284;
        int32_t ****l_311 = &l_312;
        int32_t *****l_313 = &l_311;
        int32_t l_364 = (-6L);
        int16_t l_415 = 9L;
        int32_t *****l_466 = &l_311;
        float l_488 = 0x8.9p-1;
        float *l_487 = &l_488;
        int32_t l_495 = 1L;
        (*l_313) = l_311;
        for (p_38 = 0; (p_38 <= (-20)); p_38 -= 1)
        { /* block id: 237 */
            float l_316 = 0x0.9p-1;
            int32_t l_323 = 1L;
            int32_t *l_368 = &l_323;
            float *l_386 = &l_316;
        }
        if ((p_39 < (****l_311)))
        { /* block id: 270 */
            int32_t l_394 = 0xB3B70A78L;
            int32_t **l_433 = &l_64;
            int32_t *****l_440 = (void*)0;
            int32_t *l_452 = (void*)0;
            uint16_t l_453 = 1UL;
            if ((~(****l_311)))
            { /* block id: 271 */
                int16_t l_405 = 3L;
                int32_t *****l_441 = &l_311;
                if (((int16_t)__builtin_popcountll(p_36) << (int16_t)__builtin_ia32_crc32qi(((int16_t)(&l_284 != &l_284) >> (int16_t)((void*)0 != (*l_313))), (l_394 >= 0x7301L))))
                { /* block id: 272 */
                    float l_396 = 0x5.7p-1;
                    float *l_395 = &l_396;
                    int32_t *****l_397 = (void*)0;
                    (*l_395) = 0x4.8p+1;
                    l_398 = l_397;
                }
                else
                { /* block id: 275 */
                    float l_426 = 0x6.83CDA4p+50;
                    float *l_425 = &l_426;
                    int32_t l_442 = 1L;
                    for (p_40 = (-21); (p_40 <= 4); p_40 += 4)
                    { /* block id: 278 */
                        uint32_t l_422 = 1UL;
                        float l_424 = 0x9.02F5E8p+84;
                        float *l_423 = &l_424;
                        (***l_312) = (((int16_t)((p_38 ^ (((uint32_t)(l_405 && ((int32_t)0x0FB456D4L % (int32_t)((int16_t)(p_38 != ((int16_t)((((int32_t)(-6L) % (int32_t)l_394) | l_405) < __builtin_clzl(l_414)) << (int16_t)1)) << (int16_t)(*l_64)))) % (uint32_t)l_394) & l_415)) ^ (*l_64)) << (int16_t)7) != p_37);
                        (*l_423) = (!((float)((float)p_38 - (float)(-(float)((((void*)0 == &l_284) < p_37) >= p_36))) - (float)l_422));
                        return p_39;
                    }
                    (*l_425) = 0x1.2594DDp+83;
                    if (p_36)
                    { /* block id: 284 */
                        int32_t l_439 = 0x29982B93L;
                        (*l_64) = ((int16_t)((p_40 != p_39) && func_71(func_61(&l_394, ((uint16_t)(****l_311) + (uint16_t)((uint16_t)(l_433 == l_433) << (uint16_t)(((uint16_t)(((!l_439) < (l_440 == l_441)) == 0x0555534BL) >> (uint16_t)2) <= l_439)))), p_39)) << (int16_t)6);
                        (*****l_441) = l_442;
                        (***l_311) = &p_38;
                        (***l_311) = (void*)0;
                    }
                    else
                    { /* block id: 289 */
                        uint32_t l_443 = 0UL;
                        (**l_284) = p_37;
                        l_443 = __builtin_bswap32((((*****l_441) | (((p_39 ^ p_39) | p_38) && (**l_284))) < (*****l_313)));
                    }
                    for (l_369 = 0; (l_369 <= (-27)); l_369 -= 1)
                    { /* block id: 295 */
                        int32_t l_446 = 0xC93415A6L;
                        l_446 = l_446;
                        (*l_284) = func_61(&l_446, (p_37 || ((void*)0 != &p_38)));
                    }
                }
            }
            else
            { /* block id: 300 */
                float l_450 = 0x1.7p-1;
                float *l_449 = &l_450;
                (*l_449) = (l_447 != (*l_313));
            }
            (**l_448) = func_61(func_61(&p_38, p_37), p_36);
            (**l_448) = func_61(func_74(p_36, l_454, func_50((p_38 >= __builtin_popcount((p_40 > p_39))), ((void*)0 != &l_311), (0x93FDL && 0xC176L), (****l_311), p_40), (*l_433), p_40), p_36);
        }
        else
        { /* block id: 305 */
            uint32_t l_457 = 0x54E7B07FL;
            float l_465 = 0x7.284358p-97;
            float *l_464 = &l_465;
            (*l_464) = (((float)(l_457 == ((float)((((float)p_36 + (float)(0x9.1D6F62p+95 >= func_50(func_66(l_457), ((float)(-0x1.Bp-1) + (float)(*l_64)), p_36, p_38, p_40))) <= 0xC.02FE9Bp-19) < (*****l_313)) + (float)p_40)) + (float)p_38) > 0x7.5C44A3p+66);
            (*l_464) = ((void*)0 != l_466);
        }
        for (l_364 = (-24); (l_364 != (-10)); l_364 += 1)
        { /* block id: 311 */
            float *l_489 = &l_488;
            int32_t l_493 = 0L;
        }
    }
    (***l_448) = (((*l_64) == p_39) >= (**l_284));
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_50(uint32_t  p_51, float  p_52, uint32_t  p_53, float  p_54, int16_t  p_55)
{ /* block id: 37 */
    int16_t l_56 = 0x0949L;
    return l_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_61(int32_t * p_62, uint32_t  p_63)
{ /* block id: 46 */
    int32_t l_70 = 1L;
    int32_t l_119 = 0L;
    (*p_62) = (l_70 < func_71(func_74(l_70, l_70, (func_80(p_63, &l_70) <= p_63), p_62, (func_50(l_119, l_70, p_63, l_70, l_119) <= 0x6.807939p+77)), l_119));
    for (l_119 = (-14); (l_119 <= (-19)); l_119 -= 3)
    { /* block id: 162 */
        for (p_63 = (-22); (p_63 > 16); p_63 += 4)
        { /* block id: 165 */
            int32_t *l_255 = &l_119;
            int32_t **l_256 = &l_255;
            (*l_256) = l_255;
            if (l_119)
                continue;
        }
        return p_62;
    }
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_66(uint32_t  p_67)
{ /* block id: 43 */
    int32_t l_69 = 0x16B405B7L;
    int32_t *l_68 = &l_69;
    l_68 = l_68;
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads : l_65 p_38 l_323 l_394 l_446
 * writes: l_65 p_38 l_323 l_394 l_446
 */
inline static uint16_t  func_71(int32_t * p_72, int16_t  p_73)
{ /* block id: 122 */
    uint32_t l_191 = 0x66546BCCL;
    int32_t **l_223 = (void*)0;
    int32_t ***l_222 = &l_223;
    int32_t l_229 = 0x7FB89E63L;
    int32_t *l_228 = &l_229;
    int32_t ****l_248 = (void*)0;
    int32_t *****l_247 = &l_248;
    int32_t ****l_249 = &l_222;
    int32_t l_250 = 0xC9418E7AL;
    if (((l_191 || (l_191 == ((uint16_t)l_191 << (uint16_t)__builtin_bswap64(func_66(((uint32_t)p_73 + (uint32_t)p_73)))))) | (!((int16_t)l_191 + (int16_t)p_73))))
    { /* block id: 123 */
        int32_t ***l_201 = (void*)0;
        int32_t l_204 = 0L;
        int32_t l_220 = 0xD3D7B662L;
        uint32_t l_226 = 0xA5AC62ACL;
        if ((((int16_t)p_73 >> (int16_t)((0xA068DC4AL >= (*p_72)) & (l_201 != l_201))) < (((int16_t)(l_191 & 0UL) + (int16_t)p_73) | (l_204 ^ l_191))))
        { /* block id: 124 */
            uint32_t l_207 = 0xC01FFE24L;
            int32_t l_221 = 0xA1D526E1L;
            (*p_72) = ((((int16_t)__builtin_parityll(l_207) % (int16_t)p_73) != ((l_207 > ((uint16_t)((int32_t)(p_73 >= ((((((((int16_t)((uint16_t)__builtin_ctzl(((uint16_t)p_73 << (uint16_t)((uint16_t)(__builtin_ctzl(p_73) != 0x4D96L) << (uint16_t)p_73))) % (uint16_t)(-1L)) >> (int16_t)p_73) != 0xED1FL) > 0xDA18CC62L) > 0xDCADDED1L) <= l_191) && (-7L)) & 0x82E6L)) % (int32_t)(-1L)) + (uint16_t)l_220)) <= (*p_72))) | l_221);
            (*p_72) = (*p_72);
            (*p_72) = (func_50(p_73, p_73, (((l_204 < ((void*)0 == l_222)) != p_73) && (0xF9D0L != (((*p_72) >= (*p_72)) ^ p_73))), p_73, p_73) || 0x601DA3A3L);
        }
        else
        { /* block id: 128 */
            p_72 = p_72;
            for (p_73 = (-18); (p_73 <= 18); p_73 += 1)
            { /* block id: 132 */
                (*p_72) = l_226;
                if ((*p_72))
                    break;
                (*p_72) = (-(uint32_t)1UL);
                if ((*p_72))
                    break;
            }
            p_72 = l_228;
        }
        (*l_228) = ((p_73 == ((uint16_t)p_73 - (uint16_t)((int16_t)p_73 >> (int16_t)12))) | ((l_226 <= (l_220 && ((*p_72) ^ l_226))) && (65529UL >= 0x93BAL)));
        for (l_191 = 0; (l_191 == 22); l_191 += 1)
        { /* block id: 143 */
            return p_73;
        }
    }
    else
    { /* block id: 146 */
        int32_t l_238 = (-10L);
        int32_t *l_246 = &l_229;
        for (l_191 = 26; (l_191 > 15); l_191 -= 6)
        { /* block id: 149 */
            int32_t *l_243 = &l_229;
            int32_t **l_244 = &l_243;
            int32_t ****l_245 = &l_222;
            (*l_244) = func_74(p_73, l_238, ((float)((float)l_238 + (float)p_73) + (float)0x1.7p-1), l_243, (&p_72 != (void*)0));
            (*l_245) = (void*)0;
        }
        (*l_228) = ((void*)0 != l_246);
        l_247 = l_247;
    }
    (*l_228) = (*p_72);
    (*l_249) = &l_223;
    return l_250;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_65 p_38 l_323 l_394 l_446
 */
inline static int32_t * func_74(uint32_t  p_75, uint16_t  p_76, float  p_77, int32_t * p_78, float  p_79)
{ /* block id: 61 */
    int32_t *l_120 = (void*)0;
    int32_t **l_121 = &l_120;
    int32_t l_125 = 0xD205C6C2L;
    int32_t ***l_126 = &l_121;
    uint32_t l_128 = 0x4C8AB293L;
    uint32_t l_139 = 0x13C549E5L;
    (*l_121) = l_120;
    (*p_78) = (__builtin_popcountll((0x4116L | p_75)) & (((~((int32_t)(l_125 >= (p_76 || ((((void*)0 != l_126) ^ (-(uint32_t)func_50(p_75, l_128, p_75, p_76, p_75))) <= p_76))) % (int32_t)0x4BAD57ADL)) <= p_75) || 0x03B47FC8L));
    for (l_128 = 0; (l_128 <= 42); l_128 += 8)
    { /* block id: 66 */
        int32_t l_135 = 4L;
        int32_t l_181 = 1L;
        int32_t ****l_183 = &l_126;
        int32_t *l_190 = &l_181;
    }
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_80(uint32_t  p_81, int32_t * p_82)
{ /* block id: 47 */
    int32_t *l_85 = (void*)0;
    int32_t **l_84 = &l_85;
    int32_t ***l_83 = &l_84;
    float l_118 = (-0x1.7p+1);
    float *l_117 = &l_118;
    (*l_83) = &p_82;
    (*l_117) = func_86(func_89(func_50(p_81, p_81, ((uint16_t)0x04A8L - (uint16_t)p_81), p_81, ((***l_83) == ((func_66((**l_84)) >= (((int16_t)((int32_t)(p_81 ^ p_81) % (int32_t)(***l_83)) >> (int16_t)2) || (*p_82))) < (**l_84)))), p_81), (*l_84));
    return p_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_86(int32_t *** p_87, int32_t * p_88)
{ /* block id: 52 */
    int32_t l_111 = (-1L);
    for (l_111 = 0; (l_111 != 20); l_111 += 1)
    { /* block id: 55 */
        int16_t l_114 = 0x03C7L;
        float l_116 = 0x4.289412p-59;
        float *l_115 = &l_116;
        (*l_115) = ((l_111 >= l_114) == l_114);
    }
    return l_111;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_89(int32_t  p_90, uint32_t  p_91)
{ /* block id: 49 */
    float l_99 = 0x7.00C971p+48;
    float *l_98 = &l_99;
    int32_t l_103 = 0xB2A25C95L;
    int32_t *l_102 = &l_103;
    int32_t **l_101 = &l_102;
    int32_t ***l_100 = &l_101;
    int32_t ***l_104 = &l_101;
    int32_t ***l_105 = &l_101;
    int32_t ***l_106 = &l_101;
    int32_t ***l_107 = &l_101;
    int32_t ***l_108 = &l_101;
    int32_t ***l_109 = &l_101;
    int32_t ***l_110 = (void*)0;
    (*l_98) = p_90;
    return l_110;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 124
XXX total union variables: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 25
   depth: 3, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 4
   depth: 10, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 92

XXX times a variable address is taken: 104
XXX times a pointer is dereferenced on RHS: 121
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 40
   depth: 3, occurrence: 14
   depth: 4, occurrence: 8
   depth: 5, occurrence: 7
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 18
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 327

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 319
   level: 2, occurrence: 109
   level: 3, occurrence: 58
   level: 4, occurrence: 17
   level: 5, occurrence: 15
XXX number of pointers point to pointers: 48
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20.7
XXX average alias set size: 1.52

XXX times a non-volatile is read: 778
XXX times a non-volatile is write: 275
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 106
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 16
   depth: 2, occurrence: 24
   depth: 3, occurrence: 13
   depth: 4, occurrence: 14
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
********************* end of statistics **********************/

