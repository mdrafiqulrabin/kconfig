/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3036757677
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_29(void);
static int32_t  func_34(uint32_t  p_35);
inline static int32_t * func_40(int16_t  p_41, int32_t * p_42);
inline static int32_t * func_43(int16_t  p_44, uint32_t  p_45, uint16_t  p_46, int32_t * p_47, int16_t  p_48);
inline static int32_t  func_53(float  p_54, int32_t * p_55, int16_t  p_56, uint32_t  p_57);
static float  func_63(float  p_64);
inline static int32_t * func_68(uint32_t  p_69, uint16_t  p_70);
inline static int16_t  func_76(int16_t  p_77, int32_t * p_78, int16_t  p_79);
inline static int32_t * func_98(int32_t ** p_99);
inline static int32_t * func_100(int16_t  p_101, int32_t * p_102, float  p_103, int32_t ** p_104, int32_t * p_105);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 1UL;
    int32_t l_33 = 1L;
    int32_t l_247 = 0x48F5DB1FL;
    int32_t *l_246 = &l_247;
    uint32_t l_248 = 0UL;
    uint32_t l_280 = 1UL;
    (*l_246) = (l_30 || ((((((uint16_t)0x57F6L - (uint16_t)l_33) && (func_34(l_30) < (l_33 < l_30))) | (((l_33 & func_76(l_33, l_246, (*l_246))) != l_33) ^ 0x9CE9L)) < l_33) & l_33));
    if (__builtin_ctzll((*l_246)))
    { /* block id: 158 */
        return l_248;
    }
    else
    { /* block id: 160 */
        float l_250 = 0xA.318DEAp-60;
        float *l_249 = &l_250;
        (*l_249) = ((l_249 == l_246) == (*l_246));
    }
    for (l_30 = 0; (l_30 >= 8); l_30 += 5)
    { /* block id: 165 */
        int16_t l_262 = 0x6C6EL;
        int32_t *l_279 = (void*)0;
        (*l_246) = (*l_246);
        for (l_248 = 0; (l_248 > 46); l_248 += 6)
        { /* block id: 169 */
            int32_t l_263 = 0xC497E377L;
            int32_t **l_275 = &l_246;
            if ((*l_246))
            { /* block id: 170 */
                int16_t l_261 = 6L;
                int32_t *l_270 = &l_247;
                uint32_t l_271 = 0x213202DEL;
                int16_t l_274 = (-9L);
                if (func_34((((int32_t)(!(((*l_246) == ((uint16_t)((0x704A2BC2L | (-(uint32_t)(l_261 | (l_262 && l_263)))) < ((uint32_t)__builtin_clz((((uint16_t)0xE63CL << (uint16_t)(((l_263 | l_263) != (*l_246)) >= 1UL)) < l_271)) % (uint32_t)l_263)) + (uint16_t)(*l_270))) & (*l_270))) - (int32_t)(*l_270)) <= 0xC25EL)))
                { /* block id: 171 */
                    float l_273 = 0x6.D17CDEp+19;
                    float *l_272 = &l_273;
                    (*l_272) = l_262;
                }
                else
                { /* block id: 173 */
                    return l_274;
                }
                (*l_275) = func_98(l_275);
            }
            else
            { /* block id: 177 */
                int32_t ***l_277 = &l_275;
                int32_t ****l_276 = &l_277;
                int32_t *****l_278 = &l_276;
                (*l_278) = l_276;
                (**l_277) = func_98(l_275);
            }
        }
        (*l_246) = (((*l_246) > (*l_246)) >= (*l_246));
    }
    return l_280;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(uint32_t  p_35)
{ /* block id: 37 */
    uint32_t l_39 = 2UL;
    float l_181 = 0xD.661093p+29;
    float *l_180 = &l_181;
    float *l_182 = &l_181;
    int32_t l_185 = 0xA177F500L;
    int32_t *l_184 = &l_185;
    int32_t **l_183 = &l_184;
    float l_200 = 0x1.Fp-1;
    int16_t l_201 = (-4L);
    for (p_35 = 0; (p_35 != 8); p_35 += 8)
    { /* block id: 40 */
        int32_t *l_38 = (void*)0;
        l_39 = p_35;
    }
    (*l_183) = func_40(p_35, func_43((((int16_t)((int32_t)func_53((-(float)((float)((((float)l_39 - (float)(func_63(l_39) < l_39)) != ((l_180 != l_182) <= ((0xC.2FC082p-94 != func_63((l_183 != &l_184))) <= 0x1.0p-1))) >= p_35) - (float)(-0x7.Cp+1))), (*l_183), p_35, p_35) + (int32_t)0xE14A8CDCL) + (int16_t)l_39) | l_201), l_201, p_35, (*l_183), l_39));
    (*l_183) = (*l_183);
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(int16_t  p_41, int32_t * p_42)
{ /* block id: 151 */
    float l_245 = (-0x1.9p-1);
    float *l_244 = &l_245;
    (*l_244) = ((void*)0 != p_42);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_43(int16_t  p_44, uint32_t  p_45, uint16_t  p_46, int32_t * p_47, int16_t  p_48)
{ /* block id: 130 */
    int32_t l_202 = (-1L);
    int32_t **l_203 = (void*)0;
    int32_t *l_205 = &l_202;
    int32_t **l_204 = &l_205;
    uint32_t l_208 = 0xA42C73BDL;
    (*l_204) = p_47;
    (**l_204) = ((int32_t)(*p_47) - (int32_t)l_208);
    for (p_44 = (-16); (p_44 != (-5)); p_44 += 1)
    { /* block id: 135 */
        float l_220 = (-0x6.Cp-1);
        float *l_219 = &l_220;
        int32_t l_221 = 0xD75997CBL;
        float l_229 = 0x3.904C20p-49;
        int32_t **l_241 = &l_205;
        (*p_47) = (((int32_t)(*p_47) % (int32_t)((p_45 != 0x9F6BL) && ((uint16_t)((uint32_t)p_45 + (uint32_t)((uint16_t)(((((1UL & (p_44 <= (((void*)0 == l_219) != func_76(p_45, l_219, p_44)))) > p_45) && (*p_47)) && p_45) ^ 0x3D1604EEL) + (uint16_t)l_221)) >> (uint16_t)15))) < p_46);
        if (((uint16_t)func_53(p_45, func_100(((uint16_t)(l_221 < (l_221 < (l_221 >= (l_221 != 4294967295UL)))) >> (uint16_t)0), p_47, ((float)(-(float)l_221) - (float)func_53(p_46, (*l_204), p_44, p_45)), &l_205, p_47), p_44, p_46) >> (uint16_t)p_45))
        { /* block id: 137 */
            (*l_204) = func_98(&l_205);
            (*l_205) = ((uint16_t)((int16_t)p_44 << (int16_t)12) % (uint16_t)p_44);
            (*l_204) = (*l_204);
        }
        else
        { /* block id: 141 */
            for (p_48 = 23; (p_48 >= (-14)); p_48 -= 5)
            { /* block id: 144 */
                uint32_t l_240 = 0x54A2B7FDL;
                (*p_47) = ((int16_t)(((int16_t)(**l_204) >> (int16_t)2) | 0xA74B1B2CL) + (int16_t)(l_240 != (l_241 != (void*)0)));
                (*l_205) = (((((uint32_t)0xC17BC80EL - (uint32_t)p_44) > ((*l_204) != (void*)0)) < (-1L)) & p_46);
            }
        }
    }
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : l_185
 * writes: l_185
 */
inline static int32_t  func_53(float  p_54, int32_t * p_55, int16_t  p_56, uint32_t  p_57)
{ /* block id: 121 */
    int16_t l_190 = 0L;
    int16_t l_195 = (-10L);
    int32_t l_197 = (-1L);
    int32_t *l_199 = &l_197;
    int32_t **l_198 = &l_199;
    if (((int32_t)((((p_57 & p_57) | (((uint16_t)((void*)0 != p_55) + (uint16_t)l_190) >= __builtin_parity(p_56))) | l_190) && (*p_55)) + (int32_t)l_190))
    { /* block id: 122 */
        int32_t l_193 = 0x2834275CL;
        float *l_196 = (void*)0;
        l_193 = ((float)((l_193 >= ((l_193 > (p_57 != p_57)) < l_193)) != ((!((p_54 > (p_54 == 0x1.Ep-1)) == l_195)) >= l_195)) + (float)p_56);
        l_197 = p_54;
    }
    else
    { /* block id: 125 */
        (*l_198) = func_98(l_198);
    }
    (*p_55) = (&p_55 != &l_199);
    return (*p_55);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_63(float  p_64)
{ /* block id: 43 */
    int32_t l_65 = 0x9909D073L;
    float l_167 = 0x8.011622p+32;
    float *l_166 = &l_167;
    int32_t *l_171 = (void*)0;
    int32_t **l_170 = &l_171;
    int32_t ***l_169 = &l_170;
    int32_t ****l_168 = &l_169;
    for (l_65 = 0; (l_65 == 10); l_65 += 4)
    { /* block id: 46 */
        float l_71 = 0x3.6p+1;
        int32_t l_72 = 0x879096A9L;
        int32_t *l_163 = &l_72;
        int32_t **l_162 = &l_163;
        (*l_162) = func_68(l_72, l_72);
    }
    if (((int16_t)((void*)0 != l_166) + (int16_t)(65535UL | __builtin_parityll(func_76(l_65, &l_65, ((void*)0 == l_168))))))
    { /* block id: 109 */
        return p_64;
    }
    else
    { /* block id: 111 */
        uint32_t l_172 = 0xA009C7E4L;
        float *l_174 = &l_167;
        int32_t **l_178 = &l_171;
        int32_t l_179 = 0xC42993B2L;
        if (l_172)
        { /* block id: 112 */
            return l_172;
        }
        else
        { /* block id: 114 */
            int32_t *l_173 = &l_65;
            (**l_169) = l_173;
        }
        (***l_169) = (l_174 != l_174);
        (**l_170) = (!(0x44F39351L != ((int16_t)(**l_170) << (int16_t)((l_178 != (**l_168)) > l_179))));
    }
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_68(uint32_t  p_69, uint16_t  p_70)
{ /* block id: 47 */
    int16_t l_75 = (-1L);
    int32_t l_91 = 0x80A99235L;
    int32_t *l_90 = &l_91;
    int32_t **l_154 = &l_90;
    int32_t ***l_153 = &l_154;
    int32_t *l_156 = &l_91;
    int32_t *l_157 = &l_91;
    int32_t *l_158 = &l_91;
    int32_t *l_159 = &l_91;
    int32_t *l_160 = &l_91;
    int32_t *l_161 = (void*)0;
    for (p_70 = 26; (p_70 > 11); p_70 -= 1)
    { /* block id: 50 */
        float l_88 = 0x9.2E6BA9p-43;
        int32_t l_89 = 0x0E131A3AL;
        int32_t *l_128 = (void*)0;
        float l_129 = 0x0.550393p+54;
        int32_t *l_131 = &l_91;
        uint32_t l_148 = 0x4304B69DL;
        if ((((l_75 && func_76((((uint16_t)((uint16_t)1UL << (uint16_t)5) + (uint16_t)0xB2D4L) <= (0xC7DFFC5AL || (l_75 && ((((int32_t)((uint16_t)0UL << (uint16_t)((0x5C2AL | 0xA798L) == l_75)) - (int32_t)p_70) || l_89) && 1UL)))), l_90, l_89)) <= l_89) ^ p_69))
        { /* block id: 70 */
            int32_t **l_127 = &l_90;
            (*l_127) = &l_91;
        }
        else
        { /* block id: 72 */
            int32_t *l_130 = &l_91;
            int32_t **l_147 = (void*)0;
            int32_t ***l_146 = &l_147;
            l_128 = func_98(&l_90);
            if (((*l_128) & p_70))
            { /* block id: 74 */
                int32_t *l_132 = (void*)0;
                return l_132;
            }
            else
            { /* block id: 76 */
                int32_t **l_133 = &l_90;
                (*l_133) = l_130;
                for (l_75 = 0; (l_75 == (-20)); l_75 -= 1)
                { /* block id: 80 */
                    int16_t l_138 = 0x2A73L;
                    if (p_70)
                        break;
                    (*l_133) = func_98(l_133);
                    for (l_89 = 0; (l_89 <= 17); l_89 += 1)
                    { /* block id: 85 */
                        int32_t *l_139 = &l_89;
                        float *l_140 = (void*)0;
                        float *l_141 = &l_129;
                        (*l_133) = func_100((**l_133), (*l_133), ((((p_70 == p_69) == l_138) < p_70) <= l_138), &l_131, l_139);
                        (*l_141) = p_69;
                        (*l_130) = ((*l_90) ^ ((int32_t)((int16_t)(((((*l_139) == __builtin_popcount(p_70)) & (**l_133)) | ((*l_139) <= l_138)) != 5L) % (int16_t)p_70) - (int32_t)1UL));
                    }
                }
                (*l_128) = (*l_90);
            }
            (*l_146) = &l_90;
        }
        (*l_90) = func_76((&l_91 != (void*)0), &l_89, func_76((((((p_69 != (*l_90)) || (-3L)) > (((l_148 >= (*l_131)) == p_70) <= p_69)) == (*l_131)) != 0x6103D800L), &l_89, (*l_90)));
    }
    for (p_70 = 0; (p_70 == 41); p_70 += 1)
    { /* block id: 99 */
        int32_t *l_151 = &l_91;
        int32_t **l_152 = &l_90;
        int32_t ****l_155 = &l_153;
        (*l_152) = l_151;
        (*l_151) = 0x895320EBL;
        (*l_155) = l_153;
        if ((****l_155))
            break;
    }
    (*l_154) = (**l_153);
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_76(int16_t  p_77, int32_t * p_78, int16_t  p_79)
{ /* block id: 51 */
    uint16_t l_116 = 0x86B4L;
    uint32_t l_119 = 3UL;
    int16_t l_126 = 1L;
    for (p_77 = (-29); (p_77 > 11); p_77 += 1)
    { /* block id: 54 */
        int32_t l_97 = (-1L);
        int32_t *l_96 = &l_97;
        int32_t **l_95 = &l_96;
        int32_t ***l_94 = &l_95;
        (*l_94) = &p_78;
        (*l_95) = func_98((*l_94));
        if ((***l_94))
            break;
    }
    (*p_78) = ((uint16_t)(__builtin_popcountll(l_116) && p_77) - (uint16_t)(((((0x39852136L ^ l_116) < l_116) & ((uint32_t)l_119 + (uint32_t)5L)) > (((uint16_t)(__builtin_clz((((((int16_t)(((int16_t)l_119 + (int16_t)0x596EL) > p_79) + (int16_t)l_126) > 0x6F46L) == p_79) >= 0x9CDEL)) < 4L) - (uint16_t)p_79) == p_77)) < (*p_78)));
    return l_119;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_98(int32_t ** p_99)
{ /* block id: 56 */
    uint16_t l_106 = 0xDDF9L;
    int32_t l_108 = (-5L);
    int32_t *l_107 = &l_108;
    uint32_t l_111 = 4294967292UL;
    float l_113 = (-0x1.Dp-1);
    float *l_112 = &l_113;
    (*p_99) = (*p_99);
    (*p_99) = func_100(l_106, l_107, (*l_107), p_99, &l_108);
    (*l_107) = l_111;
    (*l_112) = (-0x10.5p-1);
    return (*p_99);
}


/* ------------------------------------------ */
/* 
 * reads : p_78 l_90 l_199 p_47 l_205 l_246
 * writes: p_78 l_90 l_199 p_47 l_205 l_246
 */
inline static int32_t * func_100(int16_t  p_101, int32_t * p_102, float  p_103, int32_t ** p_104, int32_t * p_105)
{ /* block id: 58 */
    int32_t l_110 = 0xF3AA798DL;
    int32_t *l_109 = &l_110;
    (*p_104) = (*p_104);
    return (*p_104);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 79
XXX total union variables: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 24
   depth: 3, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 74

XXX times a variable address is taken: 70
XXX times a pointer is dereferenced on RHS: 55
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 46
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 243

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 241
   level: 2, occurrence: 15
   level: 3, occurrence: 7
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 48
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 14.9
XXX average alias set size: 1.5

XXX times a non-volatile is read: 346
XXX times a non-volatile is write: 113
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 88
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 25
   depth: 2, occurrence: 11
   depth: 3, occurrence: 10
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 17.6
XXX percentage an existing variable is used: 82.4
********************* end of statistics **********************/

