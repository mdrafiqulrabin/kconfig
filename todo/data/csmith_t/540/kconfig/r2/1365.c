/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3824490359
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
   signed f1 : 9;
   unsigned f2 : 8;
   unsigned f3 : 19;
   unsigned f4 : 24;
   signed f5 : 17;
   unsigned f6 : 12;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint32_t  f0;
   uint32_t  f1;
   int16_t  f2;
   uint16_t  f3;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_9 = 0x5CBCEF05;
static int32_t g_63 = 0x257B06F8;
static struct S0 g_64 = {-5254,5,12,723,1598,142,18};
static struct S1 g_212 = {4294967295U,0xEC598316,2,1U};
static struct S0 g_218 = {-5964,-2,2,604,1081,-4,31};
static struct S0 g_459 = {-1073,-8,12,167,3519,192,32};
static struct S1 g_493 = {0xF3A13FBF,1U,0x1643,0x1362};


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_29(void);
static int32_t  func_32(int16_t  p_33);
static int16_t  func_38(int32_t  p_39);
static uint64_t  func_53(uint32_t  p_54, struct S0  p_55, uint32_t  p_56, uint32_t  p_57, uint32_t  p_58);
static struct S0  func_59(uint32_t  p_60, int32_t  p_61, int32_t  p_62);
static int16_t  func_81(int16_t  p_82, int32_t  p_83);
static uint32_t  func_95(int32_t  p_96, uint16_t  p_97, struct S1  p_98, int32_t  p_99, struct S1  p_100);
static struct S1  func_102(struct S0  p_103, uint32_t  p_104, uint32_t  p_105, uint32_t  p_106, uint16_t  p_107);
static int32_t  func_116(int32_t  p_117, int16_t  p_118);
static int16_t  func_131(int16_t  p_132);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_9 g_64 g_63 g_212.f1 g_218.f6 g_218.f5 g_218.f2 g_218.f1 g_218.f3 g_212.f3 g_218 g_212.f2 g_212 g_459 g_493
 * writes: g_9 g_63 g_64.f1 g_64.f0 g_212 g_218 g_64 g_493 g_459
 */
static struct S1  func_29(void)
{ /* block id: 36 */
    uint32_t l_50 = 2U;
    int32_t l_574 = 0xE81F09FA;
    struct S0 l_575 = {4262,7,2,29,3867,304,41};
    struct S1 l_576 = {4294967295U,0x79E24B96,0,0U};
    for (g_9 = (-26); (g_9 != (-28)); g_9 -= 1)
    { /* block id: 39 */
        uint32_t l_40 = 1U;
        int32_t l_568 = 1;
        int32_t l_573 = 0;
        if (func_32((((uint32_t)g_9 - (uint32_t)((int16_t)func_38(l_40) - (int16_t)((int16_t)(~((__builtin_bswap32(l_50) != (65535U == ((((uint32_t)0x1CC49297 % (uint32_t)__builtin_parityll(func_53(l_50, func_59(g_9, l_40, g_9), l_50, g_64.f5, l_40))) | 0x8341D723) > l_40))) & 5)) << (int16_t)14))) | g_9)))
        { /* block id: 362 */
            int32_t l_571 = 1;
            struct S1 l_572 = {4294967290U,0xE6EF8BE9,1,0xBCB7};
            g_459.f1 = (g_459.f5 != 7);
            l_573 = (~((0x7A9CB780 != l_568) != (((int16_t)l_571 % (int16_t)(g_212.f3 && ((l_568 == func_95(g_459.f2, __builtin_bswap64(g_64.f3), l_572, l_50, g_493)) <= 0U))) >= l_568)));
            g_459 = g_64;
        }
        else
        { /* block id: 366 */
            l_574 = ((l_40 == g_63) > (7U == __builtin_ffs(l_573)));
            g_63 = (((0xA879F887 != 0xC0D64797) | (g_493.f3 < 0x260DEB74)) || __builtin_ia32_crc32qi(l_568, g_9));
            if (g_212.f3)
                break;
        }
        l_575 = g_459;
    }
    return l_576;
}


/* ------------------------------------------ */
/* 
 * reads : g_218.f6 g_9 g_218.f0 g_212.f0 g_64.f1 g_212.f3 g_218.f4 g_212 g_218 g_64.f0 g_64.f4 g_64.f2 g_63 g_64 g_459 g_493
 * writes: g_64.f0 g_212.f2 g_218 g_64.f1 g_63 g_64.f5 g_212.f3 g_493 g_459 g_212
 */
static int32_t  func_32(int16_t  p_33)
{ /* block id: 288 */
    uint32_t l_433 = 0x2464B9D0;
    int32_t l_477 = 0x3C6370D1;
    struct S1 l_488 = {0xA12E6155,0xDAAFC821,4,4U};
    struct S0 l_541 = {-4738,-11,11,571,3057,-153,15};
    if (__builtin_ia32_crc32qi(g_218.f6, (func_38(l_433) >= ((((int16_t)1 - (int16_t)(p_33 == ((p_33 <= 4294967289U) >= 0xE2386218))) != g_218.f0) ^ g_212.f0))))
    { /* block id: 289 */
        uint32_t l_457 = 4294967287U;
        uint16_t l_458 = 1U;
        struct S0 l_460 = {1511,3,7,469,3891,214,20};
        g_64.f5 = (!(((int32_t)(((__builtin_ctzl(((int32_t)((uint16_t)func_95(p_33, ((uint16_t)(((int16_t)((((l_433 && l_433) | ((((uint16_t)p_33 - (uint16_t)func_116(((((int16_t)p_33 % (int16_t)((int16_t)((int16_t)1 % (int16_t)0xE770) - (int16_t)((int32_t)p_33 % (int32_t)p_33))) <= 0U) != 4294967295U), l_433)) == 0U) <= 1U)) && g_64.f1) ^ g_212.f3) + (int16_t)g_218.f4) >= 0) + (uint16_t)l_457), g_212, l_433, g_212) + (uint16_t)l_458) - (int32_t)(-5))) & 0) ^ 0x69C53CE2) | p_33) + (int32_t)l_457) | g_212.f3));
        l_460 = g_459;
        l_460.f0 = l_433;
    }
    else
    { /* block id: 293 */
        uint32_t l_487 = 0x326A87FD;
        struct S1 l_489 = {1U,0x321A14BD,0x06D1,0xCF1B};
        int32_t l_490 = (-1);
        struct S1 l_506 = {8U,4294967295U,4,0U};
        uint16_t l_513 = 0xA5C7;
        l_477 = ((int16_t)(-1) - (int16_t)(((int16_t)((int16_t)(((int32_t)((((int16_t)l_433 + (int16_t)((__builtin_parityl((1 >= ((int16_t)((uint16_t)(g_63 != p_33) << (uint16_t)14) + (int16_t)((((int16_t)0x02B3 + (int16_t)(g_218.f2 < p_33)) || (p_33 <= g_9)) == l_433)))) < p_33) || 0x67919B5D)) | g_212.f0) >= p_33) + (int32_t)p_33) | 65535U) + (int16_t)g_459.f0) - (int16_t)g_9) || (-3)));
        l_477 = ((~func_95((0x80D47D5A < __builtin_ffsll(l_477)), (g_459.f1 < (((0x5AF0 != ((int32_t)p_33 % (int32_t)g_218.f2)) | ((0x8284 >= (((int16_t)((((int16_t)((int16_t)__builtin_bswap64(g_212.f0) % (int16_t)g_64.f2) << (int16_t)1) ^ g_64.f1) & g_459.f6) << (int16_t)l_487) != (-5))) && 0x6E1E992D)) > 65535U)), l_488, g_63, l_489)) & g_64.f3);
        l_490 = (g_64.f2 < 1);
        for (g_212.f3 = (-29); (g_212.f3 >= 42); g_212.f3 += 1)
        { /* block id: 299 */
            int16_t l_499 = 1;
            uint16_t l_500 = 0U;
            struct S1 l_535 = {0x2DE5D620,0U,0x1620,65529U};
            g_493 = l_489;
            if (((p_33 > (func_95(g_64.f5, (8 && (g_218.f4 < ((((((uint16_t)(((9 != ((uint16_t)(((!p_33) || l_489.f1) && g_212.f2) << (uint16_t)12)) < __builtin_clzll(l_499)) | l_500) % (uint16_t)l_489.f0) != 1U) && l_433) != p_33) != l_489.f0))), g_493, l_488.f1, l_489) >= p_33)) ^ (-10)))
            { /* block id: 301 */
                uint32_t l_503 = 0xFE76A35E;
                uint16_t l_512 = 65535U;
                int32_t l_514 = (-8);
                int16_t l_515 = 0x5741;
                uint32_t l_517 = 0U;
                if ((1U || ((int16_t)func_95(((1U || (((p_33 < l_503) == func_38(((uint16_t)0x1F33 << (uint16_t)9))) ^ ((l_500 ^ l_503) > (g_493.f0 > p_33)))) != p_33), p_33, g_212, l_503, l_506) >> (int16_t)g_459.f5)))
                { /* block id: 302 */
                    int32_t l_507 = 1;
                    g_64.f1 = l_488.f0;
                    l_507 = ((l_507 || ((((int16_t)(((p_33 > (p_33 > 4294967290U)) && 0xC43B7B01) < ((0 != (((int16_t)l_477 << (int16_t)3) & l_512)) <= (0x082C <= p_33))) >> (int16_t)6) >= 0) >= p_33)) <= l_507);
                    if (l_506.f0)
                    { /* block id: 305 */
                        l_490 = p_33;
                    }
                    else
                    { /* block id: 307 */
                        l_513 = (g_64.f1 != 0x5FC9);
                    }
                }
                else
                { /* block id: 310 */
                    uint16_t l_516 = 0xF53F;
                    if ((l_499 != 4294967290U))
                    { /* block id: 311 */
                        l_514 = g_64.f5;
                    }
                    else
                    { /* block id: 313 */
                        l_477 = p_33;
                        g_459 = g_218;
                        g_459.f1 = 1;
                        g_459.f0 = ((l_515 > p_33) == l_516);
                    }
                }
                l_517 = g_64.f6;
                for (l_513 = 0; (l_513 >= 53); l_513 += 6)
                { /* block id: 323 */
                    int32_t l_526 = 0xA7C3AB26;
                    g_64.f0 = (((int16_t)((__builtin_ia32_crc32qi(l_488.f1, (p_33 > ((((uint16_t)l_500 << (uint16_t)func_131(l_433)) != 0x2ED12D54) == ((int32_t)l_526 + (int32_t)(((((uint32_t)(p_33 != ((uint32_t)0xF8838F35 + (uint32_t)p_33)) - (uint32_t)4294967295U) | g_218.f0) < g_493.f3) & g_459.f1))))) <= 0) | g_493.f0) - (int16_t)p_33) & g_212.f0);
                    for (l_506.f2 = 0; (l_506.f2 > 26); l_506.f2 += 5)
                    { /* block id: 327 */
                        l_514 = ((int32_t)((p_33 >= func_95(p_33, __builtin_parity(p_33), g_493, p_33, l_535)) > (g_459.f4 == g_64.f5)) - (int32_t)9);
                        l_488 = g_493;
                        g_459.f1 = (__builtin_ia32_crc32qi(g_63, g_212.f1) && ((l_503 < func_95(p_33, g_459.f3, g_493, g_64.f5, l_535)) < l_499));
                        if (p_33)
                            break;
                    }
                    if (p_33)
                        break;
                    return l_477;
                }
                g_218.f0 = g_493.f0;
            }
            else
            { /* block id: 337 */
                l_490 = p_33;
            }
            l_477 = g_218.f6;
            g_493 = l_489;
        }
    }
    if (((int32_t)(1U == __builtin_clzl(l_488.f2)) + (int32_t)((int16_t)l_488.f0 >> (int16_t)3)))
    { /* block id: 344 */
        struct S0 l_540 = {6046,-18,14,26,2699,-269,19};
        l_541 = l_540;
        g_459.f0 = ((uint32_t)(g_64.f5 != ((uint16_t)(~l_540.f2) - (uint16_t)g_459.f2)) + (uint32_t)g_212.f0);
    }
    else
    { /* block id: 347 */
        uint32_t l_551 = 0xE87625FB;
        int32_t l_553 = 0xEFD26F87;
        l_551 = ((int32_t)((uint16_t)g_64.f1 >> (uint16_t)10) % (int32_t)g_64.f5);
        l_553 = ((~(-2)) > p_33);
        l_488 = func_102(l_541, (p_33 | p_33), g_493.f2, (((~g_64.f3) == (((uint32_t)(((((int16_t)l_553 >> (int16_t)12) | p_33) | g_218.f1) < ((int16_t)((int16_t)(p_33 ^ 0x656C0A4B) % (int16_t)l_541.f3) % (int16_t)p_33)) % (uint32_t)p_33) | 0xBE2E)) > l_541.f4), p_33);
    }
    g_218.f5 = 6;
    for (g_212.f1 = 0; (g_212.f1 > 42); g_212.f1 += 5)
    { /* block id: 355 */
        int16_t l_566 = 0xF17E;
        g_218 = l_541;
        l_541.f5 = (!(l_566 < g_218.f1));
        if (g_212.f3)
            break;
        l_541.f5 = 0x58C74F1F;
    }
    return l_541.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_9
 * writes:
 */
static int16_t  func_38(int32_t  p_39)
{ /* block id: 40 */
    int32_t l_43 = 0xB275CF8B;
    int32_t l_44 = 1;
    struct S0 l_45 = {-3409,21,13,170,3082,230,58};
    uint32_t l_46 = 0xF3E2E166;
    for (p_39 = 23; (p_39 >= 26); p_39 += 1)
    { /* block id: 43 */
        return l_43;
    }
    l_44 = g_9;
    l_45 = l_45;
    return l_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_64.f3 g_64.f6 g_64.f4 g_9 g_64.f5 g_64.f1 g_64.f2 g_63 g_212.f1 g_218.f6 g_218.f5 g_218.f2 g_218.f1 g_218.f3 g_212.f3 g_218 g_64 g_212.f2 g_212
 * writes: g_63 g_64.f1 g_64.f0 g_212 g_218 g_64
 */
static uint64_t  func_53(uint32_t  p_54, struct S0  p_55, uint32_t  p_56, uint32_t  p_57, uint32_t  p_58)
{ /* block id: 52 */
    uint16_t l_69 = 1U;
    int32_t l_74 = 2;
    int32_t l_90 = (-7);
    l_69 = ((uint16_t)(g_64.f3 | 0U) << (uint16_t)2);
    l_74 = (0x5EF7 < ((((p_58 >= 0U) & ((int16_t)(l_69 > (((uint16_t)__builtin_clzll(g_64.f6) >> (uint16_t)p_57) == ((func_38(g_64.f4) != 4294967293U) != 0xB488))) >> (int16_t)g_64.f4)) < (-10)) || 3U));
    p_55.f1 = ((uint16_t)((int16_t)(0xBF2C > ((int16_t)((func_81(p_55.f1, (((((int16_t)(((uint16_t)((uint16_t)0xA629 << (uint16_t)14) % (uint16_t)l_69) == l_69) << (int16_t)9) <= (0xDBF7CD62 < p_55.f6)) | func_38((__builtin_popcountll(l_74) || 0xCD01))) >= l_90)) || g_218.f0) == 0U) >> (int16_t)12)) << (int16_t)11) >> (uint16_t)12);
    return p_56;
}


/* ------------------------------------------ */
/* 
 * reads : g_64
 * writes: g_63
 */
static struct S0  func_59(uint32_t  p_60, int32_t  p_61, int32_t  p_62)
{ /* block id: 49 */
    g_63 = p_61;
    return g_64;
}


/* ------------------------------------------ */
/* 
 * reads : g_9 g_64.f5 g_64.f1 g_64.f2 g_63 g_64.f3 g_64.f4 g_64.f6 g_212.f1 g_218.f6 g_218.f5 g_218.f2 g_218.f1 g_218.f3 g_212.f3 g_218 g_64 g_212.f2 g_212
 * writes: g_63 g_64.f1 g_64.f0 g_212 g_218 g_64
 */
static int16_t  func_81(int16_t  p_82, int32_t  p_83)
{ /* block id: 55 */
    int32_t l_101 = 0x07D9F9AE;
    struct S0 l_108 = {1712,-12,12,564,1932,43,12};
    struct S1 l_268 = {0U,0xB11EE237,0xF68F,65535U};
    int16_t l_323 = 6;
    if ((((int16_t)((0x387B ^ (((((uint32_t)func_38(p_82) - (uint32_t)func_95(g_64.f5, l_101, func_102(l_108, (p_82 >= g_64.f5), func_38(p_83), g_64.f1, g_64.f2), l_108.f2, l_268)) == 0x3713) && 0x9D68AA1A) ^ 4294967288U)) != p_82) >> (int16_t)l_268.f1) && g_64.f2))
    { /* block id: 196 */
        uint16_t l_326 = 5U;
        struct S1 l_349 = {4294967295U,0xE40C635B,-1,0xCB58};
        for (l_101 = 0; (l_101 == (-12)); l_101 -= 6)
        { /* block id: 199 */
            l_268 = g_212;
            g_218.f5 = g_64.f2;
            p_83 = p_83;
            l_326 = (l_323 <= (func_95(g_218.f6, p_83, g_212, g_212.f2, g_212) <= ((uint16_t)p_83 << (uint16_t)p_83)));
        }
        for (l_101 = (-12); (l_101 < 29); l_101 += 8)
        { /* block id: 207 */
            return l_326;
        }
        for (l_268.f1 = (-2); (l_268.f1 <= 38); l_268.f1 += 4)
        { /* block id: 212 */
            struct S1 l_350 = {1U,4294967295U,0,0x369B};
            g_64.f1 = 1;
            if (__builtin_parityll(p_82))
            { /* block id: 214 */
                int32_t l_344 = 0x81B5AB52;
                l_108.f0 = ((((0x53B5888D ^ l_326) != (((-(int32_t)((uint16_t)(((int16_t)(((uint16_t)((~(-(int32_t)(p_83 < (0x0A3D == g_212.f2)))) >= 0U) << (uint16_t)l_268.f3) == (((uint16_t)((((uint32_t)(l_268.f1 <= (p_83 <= g_212.f3)) % (uint32_t)p_83) ^ l_344) | g_218.f0) << (uint16_t)10) | g_218.f6)) >> (int16_t)l_344) <= 65535U) % (uint16_t)g_212.f3)) & p_82) && l_101)) ^ 0) != 0x5CC5);
            }
            else
            { /* block id: 216 */
                struct S1 l_351 = {0U,1U,-1,1U};
                for (g_63 = 5; (g_63 < 26); g_63 += 7)
                { /* block id: 219 */
                    struct S0 l_355 = {-2360,13,6,226,3351,-311,56};
                    for (p_83 = 0; (p_83 >= 16); p_83 += 1)
                    { /* block id: 222 */
                        uint32_t l_352 = 4294967295U;
                        l_350 = l_349;
                        g_212 = l_351;
                        l_352 = l_350.f2;
                    }
                    for (g_212.f2 = 21; (g_212.f2 > (-2)); g_212.f2 -= 1)
                    { /* block id: 229 */
                        l_355 = g_218;
                        l_350 = l_349;
                    }
                }
            }
            g_212 = g_212;
        }
    }
    else
    { /* block id: 237 */
        uint16_t l_372 = 0xB3E6;
        int32_t l_406 = 5;
        struct S1 l_407 = {4294967295U,4294967288U,-3,65534U};
        g_212 = l_268;
        for (l_101 = 0; (l_101 <= (-2)); l_101 -= 1)
        { /* block id: 241 */
            int32_t l_364 = (-1);
            struct S1 l_382 = {1U,0U,-1,0xF7E1};
            struct S0 l_432 = {2634,-20,11,318,2387,-90,7};
            l_364 = ((uint16_t)((((65530U || ((int16_t)g_218.f0 + (int16_t)g_218.f0)) == __builtin_ia32_crc32qi(p_82, p_82)) <= func_116(((int16_t)0xAB40 << (int16_t)l_364), p_83)) && 0) << (uint16_t)g_64.f1);
            if ((!(g_64.f6 && l_364)))
            { /* block id: 243 */
                uint32_t l_379 = 0xA14DD71B;
                int32_t l_383 = 0xEFAFDF87;
                struct S0 l_384 = {5948,-6,6,125,2931,20,39};
                p_83 = ((uint16_t)((uint16_t)l_108.f1 % (uint16_t)(((g_212.f1 > (((uint16_t)0x3F36 >> (uint16_t)0) < ((((l_268.f3 | (l_372 || g_212.f1)) > ((int16_t)func_116(((int32_t)((((0x1284C5BB & (p_82 < __builtin_ctzll(__builtin_popcount(((uint16_t)p_82 + (uint16_t)g_218.f3))))) < p_82) & 0x74AA) < g_64.f6) + (int32_t)g_212.f1), g_212.f3) - (int16_t)0xDA2E)) & 0xEFA4) | 0xEFF896B5))) > g_212.f3) | l_379)) >> (uint16_t)p_82);
                if ((l_364 ^ (((int16_t)func_95(p_83, l_379, l_382, l_379, g_212) % (int16_t)func_38(g_64.f6)) != 0xEE4FADF7)))
                { /* block id: 245 */
                    int16_t l_390 = 0x23AC;
                    l_383 = p_83;
                    g_64 = l_384;
                    for (l_323 = 0; (l_323 >= 1); l_323 += 4)
                    { /* block id: 250 */
                        g_64.f1 = (((~p_83) >= 1) & g_218.f5);
                        g_64.f5 = ((int16_t)__builtin_ia32_crc32qi(p_82, l_390) - (int16_t)((-5) ^ g_64.f4));
                        p_83 = ((-(int32_t)l_383) != (func_38((g_64.f5 < ((int16_t)((((0xCDF0915C && (g_218.f3 > p_82)) || 3) != g_64.f2) <= ((int32_t)g_64.f6 + (int32_t)((uint16_t)(1U != p_83) << (uint16_t)1))) >> (int16_t)l_372))) > 0));
                    }
                }
                else
                { /* block id: 255 */
                    uint32_t l_405 = 0U;
                    struct S1 l_417 = {0xFD0DE7C1,4294967291U,0x9A4A,0xD966};
                    uint32_t l_420 = 0x22BCA56F;
                    if ((!((-(int16_t)p_82) || func_131(__builtin_popcount(p_83)))))
                    { /* block id: 256 */
                        g_212 = l_268;
                        l_406 = ((uint16_t)p_83 % (uint16_t)(0xB528 || (((uint16_t)p_82 >> (uint16_t)(~__builtin_clzll(p_82))) || l_405)));
                    }
                    else
                    { /* block id: 259 */
                        uint16_t l_410 = 65535U;
                        l_407 = l_382;
                        l_417 = func_102(g_64, l_405, ((((int32_t)(l_410 <= ((uint16_t)65532U % (uint16_t)((((g_64.f5 & ((((int32_t)p_83 + (int32_t)l_384.f4) || ((int32_t)(0x35993273 ^ l_384.f5) % (int32_t)0xAB275723)) ^ g_218.f0)) == 65530U) == g_212.f3) ^ g_64.f1))) + (int32_t)1U) ^ g_64.f4) != l_406), g_64.f3, l_384.f6);
                    }
                    if (p_82)
                    { /* block id: 263 */
                        struct S1 l_427 = {0xD2B3EF37,1U,0xEFF7,0U};
                        g_218.f5 = ((uint16_t)p_82 + (uint16_t)p_82);
                        if (l_420)
                            continue;
                        p_83 = func_95((func_38(p_82) != ((((uint16_t)g_218.f6 >> (uint16_t)15) > ((p_83 > (((p_83 || ((int32_t)(-1) - (int32_t)((int16_t)p_82 << (int16_t)p_83))) < 1U) != 0xC88F025A)) & p_82)) != 0)), l_382.f3, g_212, p_82, l_427);
                    }
                    else
                    { /* block id: 267 */
                        return l_101;
                    }
                    if (g_9)
                        break;
                }
                l_108 = g_218;
                p_83 = ((uint16_t)p_82 << (uint16_t)4);
            }
            else
            { /* block id: 274 */
                for (l_268.f2 = 0; (l_268.f2 < 22); l_268.f2 += 1)
                { /* block id: 277 */
                    g_218.f0 = g_218.f5;
                    l_382 = g_212;
                }
                l_268 = func_102(l_432, g_218.f4, g_218.f3, p_83, l_372);
            }
        }
    }
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads : g_212.f1 g_9 g_212.f2 g_218 g_64.f0 g_64.f4 g_64.f2 g_63 g_64
 * writes: g_212.f2 g_218 g_64.f0 g_64.f1 g_63
 */
static uint32_t  func_95(int32_t  p_96, uint16_t  p_97, struct S1  p_98, int32_t  p_99, struct S1  p_100)
{ /* block id: 156 */
    int32_t l_287 = 0;
    uint32_t l_315 = 6U;
    for (p_96 = 0; (p_96 > (-8)); p_96 -= 6)
    { /* block id: 159 */
        uint32_t l_271 = 1U;
        l_271 = g_212.f1;
        if (g_9)
            break;
        for (g_212.f2 = 0; (g_212.f2 == (-19)); g_212.f2 -= 6)
        { /* block id: 164 */
            uint32_t l_288 = 1U;
            g_218 = g_218;
            l_288 = __builtin_parityl((!((uint16_t)(0xB1C12867 | ((int32_t)(l_271 && (p_98.f2 & (((uint16_t)func_116(p_99, (0x90D1 && ((((uint16_t)((uint16_t)0xA2BA + (uint16_t)p_100.f0) << (uint16_t)3) | ((uint16_t)((g_64.f0 || 0xA1BE) || 0xB7D2) << (uint16_t)3)) >= l_287))) + (uint16_t)g_212.f1) < g_64.f4))) + (int32_t)p_100.f2)) >> (uint16_t)p_96)));
            p_100 = p_100;
        }
    }
    g_64.f1 = 0xC5181D75;
    for (p_100.f2 = (-4); (p_100.f2 > 3); p_100.f2 += 1)
    { /* block id: 173 */
        struct S0 l_298 = {-2409,20,14,283,3324,-162,39};
        for (p_100.f3 = 18; (p_100.f3 <= 18); p_100.f3 += 1)
        { /* block id: 176 */
            int32_t l_293 = 1;
            l_298 = func_59(((l_293 > (((int16_t)(-1) >> (int16_t)((0x8885BD3C || 0xF37C1261) >= 0U)) && (-3))) && ((int32_t)((l_293 <= g_218.f5) != (65527U >= g_64.f2)) - (int32_t)g_63)), g_64.f4, p_98.f1);
            p_96 = (p_98.f1 == ((uint16_t)((int16_t)((int32_t)func_38(g_64.f0) + (int32_t)p_97) + (int16_t)g_212.f2) << (uint16_t)5));
            g_218.f1 = p_100.f1;
        }
        if (l_298.f5)
        { /* block id: 181 */
            int32_t l_305 = 0x776AB288;
            g_218 = func_59(p_97, p_100.f2, (__builtin_parity(func_131(g_64.f2)) < l_305));
        }
        else
        { /* block id: 183 */
            int16_t l_316 = 0x5CCE;
            l_316 = (((uint16_t)((int32_t)(func_38((((int16_t)((~(g_64.f1 != 8U)) == (g_64.f0 < g_218.f3)) >> (int16_t)(p_98.f2 || ((uint32_t)(p_98.f1 <= 0xFE65520F) % (uint32_t)p_100.f0))) == ((g_64.f4 != p_100.f0) | 1U))) > l_298.f2) + (int32_t)l_315) % (uint16_t)65535U) >= 0xB9F9);
        }
        for (p_99 = 0; (p_99 == 12); p_99 += 1)
        { /* block id: 188 */
            l_298.f0 = g_212.f2;
            l_298 = g_64;
            return p_99;
        }
        g_218.f1 = g_218.f0;
    }
    return p_100.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_9 g_64.f3 g_64.f2 g_64.f4 g_64.f5 g_64.f6 g_212.f1 g_64.f1 g_218.f6 g_218.f5 g_218.f2 g_218.f1 g_218.f3 g_212.f3 g_218 g_64
 * writes: g_63 g_64.f1 g_64.f0 g_212 g_218
 */
static struct S1  func_102(struct S0  p_103, uint32_t  p_104, uint32_t  p_105, uint32_t  p_106, uint16_t  p_107)
{ /* block id: 56 */
    int16_t l_115 = 0x48DF;
    uint32_t l_168 = 0x76A28C7C;
    uint32_t l_171 = 0x436BBB4A;
    int32_t l_177 = 0;
    uint32_t l_262 = 0x27578CAA;
    struct S1 l_267 = {0U,0x038BCB9B,0x5BCE,0xFD3D};
    for (g_63 = 0; (g_63 != (-12)); g_63 -= 6)
    { /* block id: 59 */
        uint16_t l_186 = 0U;
        int32_t l_205 = (-1);
        int16_t l_219 = 0x8E25;
        struct S1 l_251 = {0x79EB29D5,0x22973494,0,65526U};
        struct S0 l_253 = {5781,11,7,188,2259,252,22};
        if (((uint16_t)((int16_t)__builtin_clzl(func_38(l_115)) + (int16_t)(func_116((((uint32_t)l_115 - (uint32_t)((int16_t)((int16_t)((int32_t)func_38(((int16_t)(!(0xEE77 ^ (((~func_131(l_115)) <= ((int16_t)p_106 - (int16_t)((l_168 == p_103.f1) >= p_103.f5))) && p_103.f2))) << (int16_t)g_64.f6)) - (int32_t)g_64.f3) + (int16_t)p_103.f5) << (int16_t)p_103.f5)) > g_64.f4), g_64.f4) <= l_171)) >> (uint16_t)12))
        { /* block id: 74 */
            int16_t l_190 = 3;
            int32_t l_192 = 0xF9D14FDF;
            for (l_168 = 0; (l_168 < 37); l_168 += 6)
            { /* block id: 77 */
                int16_t l_174 = (-1);
                if (l_174)
                { /* block id: 78 */
                    if (p_103.f1)
                        break;
                    l_177 = ((int16_t)p_105 << (int16_t)1);
                    for (l_174 = 0; (l_174 <= 24); l_174 += 1)
                    { /* block id: 83 */
                        p_103.f0 = ((int16_t)((int16_t)(g_64.f5 ^ func_131(p_103.f3)) << (int16_t)(__builtin_popcount(l_174) != __builtin_parityll(l_168))) + (int16_t)((((int16_t)p_107 + (int16_t)p_103.f3) <= l_186) ^ 0xA186CBB3));
                        p_103.f5 = p_106;
                    }
                }
                else
                { /* block id: 87 */
                    int32_t l_189 = 0x1C85B538;
                    int16_t l_191 = 0xF185;
                    l_190 = (((uint32_t)(((l_189 > 0xD00A9482) <= p_103.f2) != g_63) % (uint32_t)1) < l_174);
                    l_192 = l_191;
                }
            }
            l_205 = (((-8) && ((int32_t)((uint16_t)l_177 - (uint16_t)((int16_t)(((-9) & 1U) != ((uint16_t)l_190 >> (uint16_t)((l_192 == ((uint16_t)p_103.f1 % (uint16_t)((int16_t)__builtin_clzl(p_103.f2) >> (int16_t)p_103.f6))) || p_103.f1))) % (int16_t)g_64.f3)) - (int32_t)p_103.f5)) <= (-5));
            l_177 = p_103.f3;
            if (g_63)
                continue;
        }
        else
        { /* block id: 95 */
            struct S1 l_211 = {1U,4294967295U,1,0x8EC0};
            uint32_t l_248 = 0U;
            int32_t l_259 = 2;
            g_64.f1 = ((l_205 || g_9) ^ 0U);
            if (((p_103.f5 != ((int16_t)g_64.f5 + (int16_t)(!g_64.f5))) > (4294967292U && ((int16_t)p_103.f0 >> (int16_t)12))))
            { /* block id: 97 */
                g_212 = l_211;
                return l_211;
            }
            else
            { /* block id: 100 */
                struct S0 l_217 = {1649,15,12,707,3468,347,47};
                if (g_63)
                    break;
                for (l_186 = 29; (l_186 > 19); l_186 -= 8)
                { /* block id: 104 */
                    uint16_t l_231 = 1U;
                    for (l_211.f2 = 29; (l_211.f2 >= (-18)); l_211.f2 -= 6)
                    { /* block id: 107 */
                        g_218 = l_217;
                        g_218.f0 = ((__builtin_parityll(l_211.f0) < ((((g_212.f1 == g_64.f5) < l_211.f3) != 0xDDCD) | l_219)) < p_103.f0);
                        p_103.f1 = (p_103.f5 & p_107);
                    }
                    if (g_64.f3)
                    { /* block id: 112 */
                        p_103.f1 = (!__builtin_bswap32(__builtin_popcountll(l_217.f0)));
                        g_64.f0 = p_103.f1;
                    }
                    else
                    { /* block id: 115 */
                        p_103.f1 = func_131(g_64.f1);
                        l_177 = l_115;
                        g_218.f1 = func_116((((int32_t)((int32_t)func_116((l_205 < (((uint16_t)((int32_t)((uint32_t)(l_211.f1 >= l_231) + (uint32_t)g_218.f6) % (int32_t)l_217.f5) >> (uint16_t)__builtin_ia32_crc32qi(((int16_t)(((((__builtin_parityll(g_64.f4) > ((g_218.f5 < l_231) == g_218.f5)) & g_64.f5) != 0x9767DC16) >= l_168) >= p_106) << (int16_t)13), p_103.f3)) != 0x1EF0519A)), g_218.f2) + (int32_t)p_104) + (int32_t)g_64.f2) ^ 0), g_218.f5);
                        g_218 = p_103;
                    }
                    l_205 = ((int16_t)l_231 >> (int16_t)(!((uint32_t)((g_218.f1 & (((int16_t)((~0x8702) != g_218.f3) >> (int16_t)func_38(__builtin_ctzll(((uint16_t)((((int32_t)g_64.f3 - (int32_t)func_116(l_231, l_115)) | p_103.f1) >= p_105) << (uint16_t)3)))) > 0xE5AD5354)) == p_103.f5) - (uint32_t)0)));
                }
                if (g_64.f4)
                    break;
                l_177 = func_38(((int16_t)g_218.f2 >> (int16_t)l_171));
            }
            if (l_248)
            { /* block id: 126 */
                struct S0 l_252 = {1371,-8,7,132,377,318,39};
                for (g_212.f3 = 0; (g_212.f3 > 2); g_212.f3 += 1)
                { /* block id: 129 */
                    return l_251;
                }
                l_253 = l_252;
            }
            else
            { /* block id: 133 */
                for (l_251.f1 = (-20); (l_251.f1 != 40); l_251.f1 += 6)
                { /* block id: 136 */
                    int16_t l_258 = 1;
                    l_259 = ((uint16_t)l_258 >> (uint16_t)p_103.f2);
                    p_103 = g_218;
                    p_103.f1 = l_168;
                }
            }
            for (p_104 = 15; (p_104 > 5); p_104 -= 5)
            { /* block id: 144 */
                return l_251;
            }
        }
    }
    if (l_168)
    { /* block id: 149 */
        uint32_t l_263 = 0xA95721FC;
        struct S0 l_266 = {6433,9,4,634,1777,-63,43};
        l_266 = func_59(l_262, l_263, (0U && (0x89515C57 > (((func_38(p_103.f3) ^ ((((int16_t)(g_64.f5 < (l_263 < (p_104 & l_177))) >> (int16_t)p_103.f1) > g_64.f6) && p_103.f1)) || p_103.f2) < g_218.f3))));
        p_103.f0 = l_266.f2;
    }
    else
    { /* block id: 152 */
        return l_267;
    }
    return l_267;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_64.f0
 */
static int32_t  func_116(int32_t  p_117, int16_t  p_118)
{ /* block id: 70 */
    int16_t l_169 = 0x15D5;
    int32_t l_170 = 0x32F20CC1;
    l_170 = (l_169 & 0x7793);
    g_64.f0 = p_118;
    return p_118;
}


/* ------------------------------------------ */
/* 
 * reads : g_64.f3 g_64.f2 g_9 g_64.f4 g_63 g_64.f5 g_64.f6
 * writes: g_64.f1
 */
static int16_t  func_131(int16_t  p_132)
{ /* block id: 60 */
    uint32_t l_141 = 4294967295U;
    int32_t l_157 = 8;
    for (p_132 = 0; (p_132 >= (-5)); p_132 -= 1)
    { /* block id: 63 */
        int32_t l_148 = 0;
        uint16_t l_149 = 0x7657;
        int32_t l_150 = 0x7F14100A;
        l_150 = (((uint16_t)(-(int32_t)func_38(((uint32_t)g_64.f3 % (uint32_t)func_38((!(l_141 != g_64.f2)))))) + (uint16_t)(l_141 < (-5))) | ((g_64.f4 || ((int16_t)(func_38((((int16_t)((((int16_t)(l_148 <= l_149) >> (int16_t)g_63) >= l_141) > p_132) >> (int16_t)5) & 0xB784)) & g_64.f5) - (int16_t)l_141)) == l_149));
    }
    l_157 = ((int16_t)1 >> (int16_t)(((((g_64.f5 < p_132) < (0x727EF2E4 >= l_141)) | ((uint32_t)p_132 + (uint32_t)g_64.f3)) < ((uint16_t)((func_38(g_9) == 0x77F70597) >= p_132) << (uint16_t)l_141)) & g_64.f6));
    g_64.f1 = ((uint16_t)(0xEBDF65D5 >= 4294967295U) << (uint16_t)4);
    g_64.f1 = (((uint16_t)0x9DA2 >> (uint16_t)l_157) <= func_38(((uint16_t)p_132 + (uint16_t)((int16_t)func_38(g_64.f5) - (int16_t)(func_38((l_157 != (((-1) == (g_9 | l_157)) && 0x638A31BD))) >= 3)))));
    return g_64.f5;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_9, "g_9", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_64.f0, "g_64.f0", print_hash_value);
    transparent_crc(g_64.f1, "g_64.f1", print_hash_value);
    transparent_crc(g_64.f2, "g_64.f2", print_hash_value);
    transparent_crc(g_64.f3, "g_64.f3", print_hash_value);
    transparent_crc(g_64.f4, "g_64.f4", print_hash_value);
    transparent_crc(g_64.f5, "g_64.f5", print_hash_value);
    transparent_crc(g_64.f6, "g_64.f6", print_hash_value);
    transparent_crc(g_212.f0, "g_212.f0", print_hash_value);
    transparent_crc(g_212.f1, "g_212.f1", print_hash_value);
    transparent_crc(g_212.f2, "g_212.f2", print_hash_value);
    transparent_crc(g_212.f3, "g_212.f3", print_hash_value);
    transparent_crc(g_218.f0, "g_218.f0", print_hash_value);
    transparent_crc(g_218.f1, "g_218.f1", print_hash_value);
    transparent_crc(g_218.f2, "g_218.f2", print_hash_value);
    transparent_crc(g_218.f3, "g_218.f3", print_hash_value);
    transparent_crc(g_218.f4, "g_218.f4", print_hash_value);
    transparent_crc(g_218.f5, "g_218.f5", print_hash_value);
    transparent_crc(g_218.f6, "g_218.f6", print_hash_value);
    transparent_crc(g_459.f0, "g_459.f0", print_hash_value);
    transparent_crc(g_459.f1, "g_459.f1", print_hash_value);
    transparent_crc(g_459.f2, "g_459.f2", print_hash_value);
    transparent_crc(g_459.f3, "g_459.f3", print_hash_value);
    transparent_crc(g_459.f4, "g_459.f4", print_hash_value);
    transparent_crc(g_459.f5, "g_459.f5", print_hash_value);
    transparent_crc(g_459.f6, "g_459.f6", print_hash_value);
    transparent_crc(g_493.f0, "g_493.f0", print_hash_value);
    transparent_crc(g_493.f1, "g_493.f1", print_hash_value);
    transparent_crc(g_493.f2, "g_493.f2", print_hash_value);
    transparent_crc(g_493.f3, "g_493.f3", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 88
   depth: 1, occurrence: 36
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 17
XXX full-bitfields structs in the program: 17
breakdown:
   indirect level: 0, occurrence: 17
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 19
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 39
XXX times a single bitfield on RHS: 165

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 222
   depth: 2, occurrence: 44
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 5
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 4
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 5
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 22, occurrence: 4
   depth: 23, occurrence: 3
   depth: 25, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 613
XXX times a non-volatile is write: 151
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 201
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 36
   depth: 2, occurrence: 39
   depth: 3, occurrence: 24
   depth: 4, occurrence: 30
   depth: 5, occurrence: 38

XXX percentage a fresh-made variable is used: 17.4
XXX percentage an existing variable is used: 82.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

