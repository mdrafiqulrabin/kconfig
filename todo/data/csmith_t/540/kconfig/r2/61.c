/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1117227677
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 13;
   unsigned f1 : 16;
   signed f2 : 19;
   unsigned f3 : 18;
   signed f4 : 27;
   signed f5 : 8;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 6;
   signed f1 : 29;
   signed f2 : 15;
   unsigned : 0;
   signed f3 : 26;
   signed f4 : 12;
};

union U2 {
   int16_t  f0;
   unsigned f1 : 12;
   int32_t  f2;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_28(void);
static int32_t  func_32(struct S1  p_33, union U2  p_34, struct S1  p_35, uint32_t  p_36);
static union U2  func_38(int8_t  p_39, struct S0  p_40, uint32_t  p_41);
inline static struct S0  func_43(uint32_t  p_44);
static int16_t  func_47(union U2  p_48, int8_t  p_49);
inline static union U2  func_50(struct S1  p_51);
static struct S1  func_53(union U2  p_54, int16_t  p_55, int32_t  p_56, struct S1  p_57, union U2  p_58);
static union U2  func_59(int16_t  p_60, int16_t  p_61, int16_t  p_62);
inline static uint32_t  func_64(int8_t  p_65, uint16_t  p_66, struct S1  p_67, int8_t  p_68, uint32_t  p_69);
static union U2  func_70(struct S0  p_71, uint32_t  p_72);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_28(void)
{ /* block id: 36 */
    uint16_t l_29 = 0xDE9A;
    int32_t l_30 = 0xE5849968;
    int32_t l_31 = 1;
    struct S1 l_37 = {6,-22467,-40,1399,-13};
    uint32_t l_42 = 9U;
    struct S0 l_514 = {30,65,-125,273,941,-6};
    int32_t l_515 = 1;
    int32_t l_516 = 6;
    union U2 l_518 = {0x6F6D};
    l_29 |= 1;
    l_30 = l_29;
    l_31 |= l_30;
    l_37.f2 = func_32(l_37, (l_518 = func_38(l_42, func_43(l_30), (func_70(l_514, (l_516 = ((((__builtin_popcountl(l_37.f3) != 0x1205CD75) || (l_515 &= (l_31 = (l_37.f2 && 0x2EDA)))) > l_37.f0) < 7))) , l_37.f3))), l_37, l_37.f4);
    return l_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_32(struct S1  p_33, union U2  p_34, struct S1  p_35, uint32_t  p_36)
{ /* block id: 346 */
    int32_t l_519 = 0xCE33D972;
    union U2 l_521 = {0x0532};
    int32_t l_524 = 0x36C0C680;
    struct S1 l_526 = {4,16681,-163,3461,-56};
    struct S0 l_535 = {24,186,-576,347,7644,12};
    if (__builtin_ctzll(l_519))
    { /* block id: 347 */
        p_33 = p_35;
    }
    else
    { /* block id: 349 */
        uint16_t l_520 = 65528U;
        return l_520;
    }
    p_33 = func_53(l_521, ((((p_34.f0 |= ((uint16_t)p_33.f3 >> (uint16_t)l_519)) ^ p_35.f3) | p_33.f4) ^ (__builtin_popcountl(l_521.f0) & (l_524 = __builtin_popcountll((func_47(l_521, l_521.f0) && p_33.f4))))), p_33.f1, p_35, l_521);
    if (l_519)
    { /* block id: 355 */
        struct S1 l_525 = {6,-14197,100,5848,63};
        l_526 = (p_35 = l_525);
        l_525.f4 = ((uint16_t)((int32_t)((((uint16_t)((int16_t)(l_535 , (func_43(((((uint32_t)((((l_526.f0 | ((((l_525.f0 < ((((uint16_t)(p_34 , ((func_43(func_47(l_521, l_535.f4)) , l_525.f3) , l_525.f0)) * (uint16_t)l_525.f2) != l_521.f0) | 0x6DDBEAAD)) | l_525.f1) && l_525.f3) ^ l_535.f2)) == p_33.f3) , 0xA34CA32C) <= 4294967287U) + (uint32_t)l_524) | 0) | p_33.f4)) , l_525.f0)) >> (int16_t)p_33.f4) >> (uint16_t)l_525.f2) || p_35.f0) , l_525.f1) + (int32_t)0xE857C9BE) - (uint16_t)l_525.f1);
    }
    else
    { /* block id: 359 */
        int32_t l_540 = 0x67429A30;
        int32_t l_545 = 4;
        int32_t l_549 = 0xD7D98B94;
        l_540 = (65535U >= l_535.f2);
        for (p_36 = 0; (p_36 == 23); p_36 += 1)
        { /* block id: 363 */
            int32_t l_546 = 0x917245B7;
            uint32_t l_565 = 0U;
            l_549 = (((((uint16_t)(l_545 = (func_43(l_540) , 0x41B7)) << (uint16_t)(l_546 = p_35.f4)) >= (l_524 != ((p_35.f4 && p_35.f1) ^ 0xCC65))) || (p_34.f0 = (((uint16_t)9U - (uint16_t)0) ^ 0U))) == p_33.f0);
            l_546 ^= 0x8D6871F8;
            p_35.f3 |= 0xF1E28275;
            l_565 |= ((int16_t)((uint16_t)((((int16_t)p_33.f2 % (int16_t)p_35.f0) == p_33.f4) == (3U && (p_35.f3 |= ((l_546 &= (l_535.f5 || __builtin_clzl(p_33.f4))) , (((uint16_t)((int16_t)p_33.f1 + (int16_t)((uint16_t)((uint16_t)__builtin_clzl((!(((l_545 != l_540) < l_546) , l_521.f0))) % (uint16_t)1) >> (uint16_t)l_545)) >> (uint16_t)l_535.f2) & 7))))) * (uint16_t)l_545) + (int16_t)0xEBFD);
        }
        return p_35.f1;
    }
    return l_535.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_38(int8_t  p_39, struct S0  p_40, uint32_t  p_41)
{ /* block id: 342 */
    union U2 l_517 = {0x97F7};
    p_40.f4 = p_40.f4;
    return l_517;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_43(uint32_t  p_44)
{ /* block id: 40 */
    struct S1 l_52 = {1,17866,0,7663,54};
    int32_t l_244 = 0;
    struct S0 l_375 = {-48,48,592,11,3915,6};
    union U2 l_387 = {0x9B4C};
    struct S1 l_482 = {1,11255,23,1178,42};
    uint32_t l_503 = 0xFC32FE14;
    if (((int16_t)(__builtin_ia32_crc32qi(((((func_47((p_44 , func_50(l_52)), (l_244 &= __builtin_ia32_crc32qi(__builtin_clzll(l_52.f0), l_52.f2))) ^ ((uint32_t)(((l_52.f0 || p_44) == 65533U) <= 1U) + (uint32_t)p_44)) , 0x8FE6) , l_375) , l_52.f0), p_44) != l_52.f0) << (int16_t)l_375.f1))
    { /* block id: 230 */
        uint16_t l_380 = 65534U;
        int32_t l_390 = 0xD20A629C;
        struct S1 l_398 = {1,20301,-91,-3347,12};
        struct S0 l_416 = {-38,199,195,269,-1858,-13};
        struct S0 l_462 = {23,66,96,95,-6089,14};
        struct S1 l_473 = {0,11407,-59,-1339,62};
        union U2 l_483 = {-4};
        for (l_244 = (-11); (l_244 == 15); l_244 += 1)
        { /* block id: 233 */
            struct S1 l_383 = {6,9632,-161,3598,14};
            struct S0 l_391 = {34,235,535,481,9985,-10};
            union U2 l_393 = {-1};
            uint16_t l_427 = 0x2727;
            for (p_44 = (-3); (p_44 > 43); p_44 += 1)
            { /* block id: 236 */
                struct S1 l_384 = {5,-11505,-4,5804,-30};
                struct S0 l_417 = {-72,185,112,343,-5268,-14};
                if (l_380)
                { /* block id: 237 */
                    int32_t l_409 = 9;
                    struct S1 l_410 = {4,13173,-155,-6603,-16};
                    for (l_380 = 0; (l_380 > 59); l_380 += 5)
                    { /* block id: 240 */
                        int32_t l_392 = 0;
                        struct S1 l_402 = {4,3467,-178,1433,-55};
                        uint16_t l_411 = 0x8CBA;
                        l_384 = l_383;
                        l_392 ^= ((uint32_t)((((__builtin_clzl((l_387 , (0x9BC6 != ((int16_t)(l_383.f3 = (l_390 = (p_44 == (2 <= p_44)))) >> (int16_t)(l_384.f4 = (l_391 , p_44)))))) | ((-3) >= p_44)) | p_44) , 4294967287U) > 4294967295U) + (uint32_t)l_375.f3);
                        l_398 = func_53((l_393 = l_387), __builtin_ffsl(l_383.f0), (((int32_t)(-2) % (int32_t)0xB0B1A630) <= (((int16_t)l_384.f2 - (int16_t)(((((p_44 || ((p_44 , (l_387.f0 , 1)) != l_384.f1)) >= l_52.f0) ^ 0x02AD) , l_384.f4) == p_44)) || 0x9199FA52)), l_384, l_387);
                        l_410.f4 = ((((((uint32_t)((!(func_64(l_391.f1, l_384.f3, l_402, (l_402.f3 < (((l_410.f3 = func_64(((((uint32_t)p_44 - (uint32_t)((((int32_t)p_44 % (int32_t)l_384.f0) && p_44) >= ((uint16_t)(l_409 ^= (l_52 , l_52.f0)) * (uint16_t)l_402.f3))) <= p_44) , l_393.f0), l_402.f4, l_410, p_44, p_44)) == p_44) | p_44)), l_410.f0) < p_44)) && p_44) % (uint32_t)p_44) , l_393.f0) || 0x287AF55E) && 65533U) ^ l_411);
                    }
                }
                else
                { /* block id: 252 */
                    uint32_t l_414 = 0xC70E43D8;
                    for (l_390 = (-10); (l_390 >= (-1)); l_390 += 1)
                    { /* block id: 255 */
                        struct S0 l_415 = {-67,222,-557,195,-11239,-1};
                        l_414 |= p_44;
                        l_391 = l_415;
                    }
                }
                l_375 = l_416;
                l_375.f0 = ((func_47(func_50((l_384 = l_398)), p_44) , (((l_391.f4 = p_44) && __builtin_ia32_crc32qi((l_417 , (l_417.f0 = p_44)), p_44)) == 2U)) <= p_44);
                for (l_393.f2 = 0; (l_393.f2 >= (-4)); l_393.f2 -= 2)
                { /* block id: 267 */
                    int8_t l_430 = 0x2A;
                    for (l_387.f0 = (-3); (l_387.f0 != (-13)); l_387.f0 -= 1)
                    { /* block id: 270 */
                        int32_t l_426 = 0x1AA025E1;
                        int32_t l_431 = (-1);
                        int32_t l_432 = 0x81518E46;
                        l_416.f0 = __builtin_parity(((uint16_t)(0x3D61B8DE || ((int16_t)0xCBE1 + (int16_t)(l_426 = l_426))) >> (uint16_t)(p_44 | l_427)));
                        l_432 |= (p_44 , ((func_64((l_426 = p_44), l_391.f4, l_52, (9U != ((0x367013C0 != (((uint32_t)(l_384.f0 == (l_430 ^= (p_44 , l_375.f0))) + (uint32_t)0U) ^ (-2))) & 0x6F0093FF)), l_416.f3) , 0x1F96) >= l_431));
                        l_384.f4 = ((int16_t)l_384.f0 >> (int16_t)1);
                    }
                    l_375.f2 = l_52.f0;
                    l_417 = l_391;
                    for (l_387.f3 = 0; (l_387.f3 != (-27)); l_387.f3 -= 1)
                    { /* block id: 282 */
                        uint32_t l_441 = 0xEBB9CAFF;
                        uint32_t l_442 = 4294967287U;
                        l_52.f4 &= (((p_44 || __builtin_clzll(l_52.f1)) <= (func_64((((int16_t)p_44 + (int16_t)((int32_t)(p_44 || (0x41CF != (((l_398 , 0x47336322) <= (p_44 != l_430)) < 4294967295U))) % (int32_t)l_391.f1)) >= l_384.f3), l_441, l_398, l_393.f1, l_442) >= 0U)) || p_44);
                        l_398.f3 ^= p_44;
                        if (p_44)
                            break;
                    }
                }
            }
        }
        if ((__builtin_ctzll(p_44) <= (65527U != (((((l_416 , p_44) >= 0U) && (l_52.f1 = ((uint16_t)(__builtin_clzl(p_44) , p_44) * (uint16_t)l_52.f4))) == p_44) >= (-4)))))
        { /* block id: 291 */
            int32_t l_451 = 0x0E73BAE4;
            int32_t l_452 = 0xD67758D9;
            int32_t l_455 = (-1);
            l_375.f4 = (((l_375.f2 ^ ((int16_t)((int32_t)((uint16_t)0xE025 >> (uint16_t)10) % (int32_t)__builtin_parityl(l_451)) >> (int16_t)6)) < (l_452 = l_52.f1)) & ((l_455 = ((int16_t)p_44 % (int16_t)(l_398.f4 ^ ((0xA63E & l_416.f5) != p_44)))) , p_44));
            l_416.f4 &= p_44;
        }
        else
        { /* block id: 296 */
            uint32_t l_460 = 4294967295U;
            int32_t l_461 = (-10);
            struct S0 l_484 = {32,172,266,473,10058,5};
            if (p_44)
            { /* block id: 297 */
                uint16_t l_458 = 0x8B78;
                int32_t l_463 = 0x593B0E37;
                l_463 &= (l_398.f4 = ((uint16_t)(p_44 != (l_52.f3 = (((((l_458 || (-(uint16_t)(l_461 = l_460))) , (l_462 , l_398)) , p_44) < (__builtin_parity(p_44) , l_52.f3)) <= 0x20B056F5))) << (uint16_t)l_458));
            }
            else
            { /* block id: 302 */
                return l_462;
            }
            for (l_461 = (-25); (l_461 <= 27); l_461 += 1)
            { /* block id: 307 */
                int16_t l_466 = 0xA78E;
                struct S1 l_474 = {1,21727,-172,-3895,18};
                int32_t l_475 = 0x5DA0D2B2;
                l_462.f2 = ((l_466 ^= p_44) > ((uint16_t)(((int16_t)(func_70((((uint16_t)func_47(func_50(func_53(func_50((l_52 = (l_474 = l_473))), p_44, ((l_475 > ((uint16_t)(((p_44 , p_44) & ((int16_t)(l_462.f5 = (((l_375.f5 >= ((int16_t)(p_44 > p_44) * (int16_t)p_44)) == 0x698E5614) > p_44)) << (int16_t)10)) ^ p_44) - (uint16_t)p_44)) , 1), l_482, l_483)), p_44) * (uint16_t)0x4A6C) , l_484), l_483.f0) , l_462.f0) % (int16_t)l_416.f5) != l_398.f1) + (uint16_t)l_473.f0));
            }
        }
        return l_416;
    }
    else
    { /* block id: 316 */
        uint32_t l_495 = 0U;
        int32_t l_510 = (-1);
        for (l_244 = 0; (l_244 == 24); l_244 += 1)
        { /* block id: 319 */
            union U2 l_493 = {4};
            struct S1 l_494 = {4,-12310,46,7185,6};
            l_495 = ((int16_t)(((uint16_t)p_44 >> (uint16_t)3) ^ ((((int16_t)func_64(func_47(l_493, p_44), l_493.f0, (l_494 = l_494), l_493.f0, p_44) << (int16_t)3) & l_52.f1) < 0x5E94B3B9)) >> (int16_t)l_493.f0);
            l_494.f4 = (((6U && ((l_494.f1 = 0x88373F0D) >= l_495)) == (~(!(p_44 || ((((l_494.f3 = ((int16_t)(p_44 , p_44) * (int16_t)((int16_t)(!((l_503 < ((((int32_t)((l_494.f2 = ((p_44 , ((uint16_t)__builtin_popcountll(((l_495 | l_482.f1) | 0x97587C3D)) * (uint16_t)p_44)) ^ p_44)) & p_44) - (int32_t)p_44) | l_495) | l_495)) > 65534U)) * (int16_t)l_52.f4))) > 0xAB18) || p_44) <= p_44))))) >= p_44);
        }
        l_510 = (p_44 >= ((uint16_t)(8 != l_52.f4) * (uint16_t)l_495));
        l_510 ^= p_44;
        l_510 |= ((-6) != p_44);
    }
    for (l_387.f0 = (-4); (l_387.f0 < (-19)); l_387.f0 -= 5)
    { /* block id: 333 */
        struct S0 l_513 = {-69,42,-378,165,-162,15};
        l_482.f3 = __builtin_bswap32(p_44);
        if (p_44)
            continue;
        return l_513;
    }
    return l_375;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_47(union U2  p_48, int8_t  p_49)
{ /* block id: 163 */
    int8_t l_249 = 0x98;
    int32_t l_256 = (-3);
    int8_t l_280 = (-1);
    struct S0 l_294 = {46,91,-59,355,-6903,-15};
    int32_t l_310 = (-3);
    struct S1 l_323 = {3,11132,37,-6040,-39};
    int32_t l_369 = 0x4897DE86;
    struct S1 l_370 = {0,19771,153,1452,-23};
    uint32_t l_371 = 4U;
    uint16_t l_372 = 0x219D;
    for (p_49 = (-9); (p_49 == 25); p_49 += 1)
    { /* block id: 166 */
        uint32_t l_254 = 0x2900B308;
        uint32_t l_255 = 0x6B03F70A;
        struct S0 l_293 = {71,146,109,421,-4177,8};
        uint32_t l_346 = 0xD23FB492;
        if ((((uint16_t)l_249 + (uint16_t)((((l_256 = ((((l_249 < (((__builtin_parityl(l_249) , (p_49 >= l_249)) > (l_254 = ((((((((int16_t)p_48.f0 >> (int16_t)(((uint16_t)(0xB6349930 & 0xBEBA5108) % (uint16_t)0x71A6) == p_49)) > 0x19DA) && p_49) != 2) > 0x4B7C4800) >= 0x23462454) >= 65532U))) , 9)) || l_249) || p_49) && l_255)) == 0xAE0A) >= (-1)) != l_255)) == 1U))
        { /* block id: 169 */
            int8_t l_265 = (-1);
            int32_t l_277 = (-2);
            int16_t l_278 = 1;
            int32_t l_279 = (-5);
            struct S0 l_281 = {21,45,-448,51,5374,-15};
            struct S1 l_306 = {6,-5343,-54,-1218,-41};
            for (l_254 = 0; (l_254 >= 42); l_254 += 4)
            { /* block id: 172 */
                uint16_t l_273 = 1U;
                int32_t l_291 = 0xA95B2BAB;
                int32_t l_292 = (-1);
            }
            l_294 = l_293;
            if (p_49)
            { /* block id: 185 */
                int32_t l_299 = 1;
                for (p_48.f2 = 0; (p_48.f2 != (-26)); p_48.f2 -= 1)
                { /* block id: 188 */
                    uint32_t l_297 = 0x88B8C5FC;
                    int32_t l_298 = 0x65EFAE0A;
                    struct S1 l_309 = {0,1395,-130,432,52};
                    int32_t l_313 = 0x05DAA7FC;
                    l_293 = l_294;
                    if (l_281.f1)
                    { /* block id: 190 */
                        l_298 = (l_297 == 0x831B);
                    }
                    else
                    { /* block id: 192 */
                        uint32_t l_311 = 0x9A8FEE83;
                        struct S1 l_312 = {4,653,-110,3486,38};
                        l_281.f2 = (func_64(((l_293.f5 &= (((func_64(l_299, ((int16_t)l_278 * (int16_t)(__builtin_parity(((int32_t)func_64(p_48.f0, ((((((uint16_t)(((p_48.f2 | __builtin_popcountl(func_64(__builtin_ctz(l_298), l_256, l_306, ((uint16_t)((l_281.f5 = (p_48.f3 || 0x3D5287A0)) , l_256) >> (uint16_t)9), l_299))) >= p_48.f2) , l_256) % (uint16_t)1) < p_48.f3) <= 3U) != l_281.f0) && p_48.f2), l_309, l_310, l_311) + (int32_t)p_49)) != l_306.f2)), l_312, p_48.f3, p_48.f0) | 0xCA78) & l_299) || l_313)) , 0xF9), l_299, l_306, l_313, p_48.f1) , (-1));
                    }
                    l_294.f2 &= __builtin_bswap64(__builtin_ffs(l_309.f3));
                }
                p_48.f2 = 0x27B9E7D2;
            }
            else
            { /* block id: 200 */
                l_294.f5 = p_48.f0;
            }
            l_294.f2 = ((l_294.f0 | l_306.f4) ^ (l_310 &= 4));
        }
        else
        { /* block id: 205 */
            int32_t l_314 = 0x7BCC0BFC;
            l_314 &= 2;
            for (l_310 = 0; (l_310 != (-22)); l_310 -= 1)
            { /* block id: 209 */
                int32_t l_321 = 0x9ED4AB84;
                uint16_t l_322 = 1U;
                uint16_t l_354 = 0x7C31;
                p_48.f2 = ((int16_t)(((uint16_t)p_49 >> (uint16_t)(l_294.f4 = ((l_293.f5 = l_294.f1) < p_48.f0))) | l_321) % (int16_t)func_64((l_322 && l_293.f3), l_314, l_323, ((~((((uint16_t)((int16_t)(((uint32_t)p_48.f0 + (uint32_t)l_294.f5) || 3) * (int16_t)0xD7F4) * (uint16_t)l_321) , l_293.f4) < l_294.f1)) ^ 0xEE0D), p_48.f0));
                l_293.f4 = (p_48.f2 = ((int32_t)((uint32_t)((uint16_t)0x554C >> (uint16_t)(((uint16_t)(~((int16_t)(l_293.f5 && 0x4880) >> (int16_t)2)) >> (uint16_t)13) , (p_49 & (((l_294.f0 = ((uint16_t)(0U | ((((int32_t)((l_346 = l_294.f4) ^ (!((uint16_t)(l_293.f4 ^ ((int16_t)p_48.f2 % (int16_t)((int32_t)__builtin_clzl(p_48.f3) - (int32_t)l_314))) >> (uint16_t)l_314))) + (int32_t)(-1)) , 0x7A5A) ^ 3U)) * (uint16_t)1U)) | p_49) == p_49)))) + (uint32_t)8) - (int32_t)l_314));
                if (p_49)
                    break;
                return l_354;
            }
        }
        l_294.f4 |= (0x31A4B75B & l_255);
    }
    l_372 = (p_48.f2 = (l_323.f4 &= ((l_294.f0 = ((-9) && ((uint16_t)p_48.f0 - (uint16_t)((uint32_t)l_294.f3 - (uint32_t)((((func_64(l_294.f4, (l_294 , ((((((!((int32_t)((int16_t)(l_310 = (l_323.f3 = (p_48.f0 >= (l_294 , ((__builtin_ctzl((l_310 <= ((uint32_t)((~((uint32_t)__builtin_clzl(((l_323.f3 & 0xD21AC2F2) & l_294.f0)) % (uint32_t)1U)) , 0xBAF0D8E3) - (uint32_t)l_294.f2))) == l_294.f3) || p_48.f0))))) * (int16_t)l_369) - (int32_t)(-1))) <= p_48.f0) , 0x41FE) ^ p_49) && 4) && 0)), l_370, p_48.f0, p_48.f0) , l_256) < 0x54E46A14) , l_370.f2) , l_371))))) || p_49)));
    return l_294.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_50(struct S1  p_51)
{ /* block id: 41 */
    int8_t l_63 = 0xBD;
    struct S0 l_73 = {-37,229,211,229,10184,14};
    int32_t l_88 = (-1);
    struct S1 l_122 = {1,-20858,45,-6666,21};
    union U2 l_123 = {0x0CE2};
    p_51.f3 = p_51.f3;
    p_51 = func_53(func_59(l_63, (l_88 |= ((l_63 >= (func_64((func_70(l_73, p_51.f1) , p_51.f2), ((int16_t)(0 >= l_73.f4) >> (int16_t)(((((((uint16_t)__builtin_clz(p_51.f2) * (uint16_t)l_73.f1) < l_73.f4) == l_73.f4) & 0xF566) ^ p_51.f1) , p_51.f4)), p_51, p_51.f3, l_73.f1) , p_51.f0)) , l_73.f1)), p_51.f0), p_51.f0, p_51.f4, l_122, l_123);
    return l_123;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_53(union U2  p_54, int16_t  p_55, int32_t  p_56, struct S1  p_57, union U2  p_58)
{ /* block id: 73 */
    int16_t l_124 = (-3);
    struct S1 l_127 = {0,-5058,-144,-1528,-4};
    struct S0 l_184 = {40,191,610,305,3307,1};
    int16_t l_203 = (-8);
    l_124 = p_55;
    for (p_54.f2 = 0; (p_54.f2 != 0); p_54.f2 += 8)
    { /* block id: 77 */
        int8_t l_128 = (-1);
        struct S1 l_129 = {2,528,-71,-456,-56};
        int32_t l_134 = 1;
        int32_t l_135 = 0x32090DF5;
        int32_t l_136 = 0;
        p_57.f1 = l_124;
        p_57 = l_127;
        l_136 |= func_64(l_127.f4, l_128, l_129, (((l_129.f4 != (l_135 = ((l_134 = (((int16_t)p_54.f2 >> (int16_t)5) ^ ((int16_t)0x4571 << (int16_t)p_57.f1))) >= l_128))) , (p_57.f4 | p_57.f1)) , 0), l_127.f2);
        if (l_124)
            break;
    }
    if (l_127.f2)
    { /* block id: 85 */
        int16_t l_148 = 1;
        int32_t l_149 = 0xC530126A;
        p_57.f1 = 2;
        l_149 = ((int16_t)((-(int16_t)((uint16_t)(0xA038 || (p_57.f4 & __builtin_bswap32((l_148 = ((int16_t)((uint32_t)(p_54 , ((l_127.f3 <= ((((int16_t)0xA8D9 % (int16_t)(l_127 , 0x9CF3)) == __builtin_ctzl(p_57.f1)) >= l_127.f3)) < p_54.f1)) - (uint32_t)0xAE34B661) % (int16_t)l_127.f2))))) >> (uint16_t)9)) != p_56) << (int16_t)6);
    }
    else
    { /* block id: 89 */
        uint32_t l_162 = 0x49F989F9;
        int32_t l_172 = (-1);
        struct S0 l_173 = {85,172,-335,46,-5092,0};
        struct S1 l_206 = {5,-2742,-121,-7973,-12};
        int8_t l_210 = 3;
        for (p_54.f3 = 0; (p_54.f3 != 17); p_54.f3 += 1)
        { /* block id: 92 */
            uint32_t l_152 = 0x159BD2BB;
            uint32_t l_157 = 0x5EE981B5;
            int32_t l_163 = (-1);
            uint32_t l_170 = 0x42755BC8;
            if ((l_127.f3 &= l_152))
            { /* block id: 94 */
                return l_127;
            }
            else
            { /* block id: 96 */
                uint16_t l_158 = 0x2FA9;
                struct S0 l_174 = {-20,132,-418,38,2335,-2};
                if ((((uint16_t)p_54.f1 * (uint16_t)p_55) , (p_57.f4 ^= 0x3ACBD10C)))
                { /* block id: 98 */
                    l_157 = ((int16_t)(-3) >> (int16_t)l_127.f0);
                }
                else
                { /* block id: 100 */
                    int32_t l_171 = 0xF1B690FF;
                    p_57.f3 ^= p_57.f1;
                    p_57.f3 = (l_158 &= ((p_57.f0 = p_54.f1) , p_54.f1));
                    if (p_56)
                        break;
                    if ((p_57.f2 = ((uint16_t)__builtin_popcountl(p_58.f0) << (uint16_t)((-(int32_t)(l_162 >= l_163)) & ((p_55 = ((uint16_t)((int32_t)(p_54.f1 ^ ((uint16_t)l_152 - (uint16_t)l_170)) + (int32_t)l_171) - (uint16_t)((p_54.f2 <= p_54.f0) >= l_158))) || l_170)))))
                    { /* block id: 108 */
                        return p_57;
                    }
                    else
                    { /* block id: 110 */
                        l_171 |= 0xA0BCAFD4;
                        l_172 = l_162;
                        l_172 = __builtin_parity(p_57.f4);
                        p_57.f4 &= 0x0A75A90C;
                    }
                }
                l_174 = l_173;
            }
        }
        if (l_124)
        { /* block id: 120 */
            int8_t l_179 = (-8);
            struct S1 l_185 = {6,-494,80,2313,-37};
            struct S0 l_186 = {-41,245,-63,297,5830,-3};
            p_57.f1 &= ((int16_t)((uint16_t)(p_56 ^ (l_179 = l_173.f4)) - (uint16_t)(((uint32_t)((uint16_t)p_57.f0 << (uint16_t)9) - (uint32_t)(__builtin_bswap32((p_54.f1 |= (l_127.f1 &= (l_184 , (l_185 , l_185.f3))))) , __builtin_ffs((l_185.f3 = (l_186 , (p_58.f0 | 0x4D4EBD06)))))) && 0x24DB)) * (int16_t)l_184.f1);
        }
        else
        { /* block id: 126 */
            uint32_t l_204 = 0U;
            p_57.f4 |= ((((int32_t)(p_57.f2 ^= 0x3C0B3C35) % (int32_t)(((((uint16_t)(0x8FA2 || ((func_70(l_184, p_54.f3) , (~(p_58.f0 = (((int16_t)((int16_t)((uint16_t)0U >> (uint16_t)2) >> (int16_t)9) >> (int16_t)func_64((((-(int16_t)((uint16_t)__builtin_bswap32(((int16_t)p_58.f0 % (int16_t)l_124)) * (uint16_t)0xEF52)) & l_127.f0) ^ l_203), l_162, l_127, p_55, l_204)) , 1)))) >= l_204)) * (uint16_t)l_204) < p_54.f2) , 65535U) || 0xA454)) <= 1U) || l_184.f5);
        }
        if (p_54.f1)
        { /* block id: 131 */
            uint32_t l_205 = 0x1BCF4990;
            l_127.f2 |= func_64(p_58.f0, l_205, l_206, __builtin_ffsl((l_184.f0 = p_57.f0)), p_57.f3);
        }
        else
        { /* block id: 134 */
            uint32_t l_209 = 0xFC393A48;
            int32_t l_213 = 0xFC5EED3F;
            int32_t l_231 = 0x8F03CA48;
            uint16_t l_236 = 2U;
            struct S0 l_237 = {6,154,590,208,-4378,8};
            struct S1 l_243 = {4,-18168,-144,-2137,-10};
            p_57.f3 ^= ((int16_t)__builtin_ffsl(l_209) * (int16_t)l_210);
            if (l_206.f2)
            { /* block id: 136 */
                int32_t l_214 = 3;
                uint32_t l_217 = 1U;
                l_217 |= (((int16_t)(((l_213 &= 0x010A) != (l_214 ^= p_57.f0)) && (l_184.f2 &= l_213)) * (int16_t)0x4D48) || (l_184.f4 != ((int16_t)l_213 * (int16_t)l_213)));
                l_173 = (l_127 , l_184);
                p_57.f1 |= (-(uint32_t)(p_57.f0 = (p_57.f4 || ((p_57.f0 | l_206.f2) <= p_58.f0))));
                l_231 = ((uint16_t)(l_213 , ((((uint16_t)(l_236 = ((uint16_t)((int32_t)l_206.f1 + (int32_t)0xDE3EAF4D) % (uint16_t)(l_213 = (((uint16_t)((uint16_t)(p_54.f1 , 65532U) >> (uint16_t)(0x475FA8B9 >= l_231)) << (uint16_t)((uint16_t)((l_127.f4 || (((int16_t)p_56 * (int16_t)p_57.f0) ^ p_57.f2)) < 65535U) - (uint16_t)l_173.f3)) & 0x58A1BA6F)))) * (uint16_t)l_231) || p_55) ^ 65531U)) * (uint16_t)0xC901);
            }
            else
            { /* block id: 147 */
                struct S1 l_240 = {7,4579,142,2411,27};
                p_54.f2 = __builtin_ffsll(l_206.f2);
                l_237 = l_237;
                for (l_124 = 16; (l_124 >= (-24)); l_124 -= 2)
                { /* block id: 152 */
                    p_57 = l_240;
                }
                l_127.f3 = func_64(p_55, ((int16_t)7 * (int16_t)p_57.f1), l_243, __builtin_ctzll(l_237.f5), l_162);
            }
        }
    }
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_59(int16_t  p_60, int16_t  p_61, int16_t  p_62)
{ /* block id: 57 */
    int32_t l_94 = (-9);
    int32_t l_106 = 0xEAC3B263;
    uint16_t l_115 = 65535U;
    int32_t l_119 = 0xA5B4E36C;
    struct S1 l_120 = {7,15026,-42,-2345,30};
    union U2 l_121 = {-1};
    for (p_62 = 23; (p_62 != 27); p_62 += 4)
    { /* block id: 60 */
        uint16_t l_91 = 1U;
        int32_t l_107 = 0x69F5ED80;
        int32_t l_108 = 0xF7E61D9E;
        l_91 |= p_61;
        l_108 = ((uint16_t)(l_107 &= (l_106 = (l_94 , (p_61 >= ((uint16_t)0x6AD3 * (uint16_t)(l_94 = (((p_60 ^= 0x239E) <= l_94) & ((uint32_t)((uint16_t)l_91 % (uint16_t)(((-(uint16_t)((p_62 | ((uint16_t)(((uint16_t)65535U * (uint16_t)(p_62 , p_62)) ^ l_94) % (uint16_t)p_62)) && 0x16FBB8A9)) >= 0U) & 1)) - (uint32_t)0U)))))))) * (uint16_t)p_62);
    }
    l_120.f1 = func_64(((int32_t)func_64(((uint32_t)((int16_t)((p_61 ^ ((l_94 = (-1)) , ((__builtin_ctzl(l_94) & (l_106 = l_115)) > (-(int32_t)((uint32_t)l_94 - (uint32_t)((l_119 = __builtin_bswap32(l_94)) < l_94)))))) || l_94) * (int16_t)1) - (uint32_t)0U), p_61, l_120, l_120.f0, l_120.f3) + (int32_t)l_120.f1), p_61, l_120, p_61, p_60);
    return l_121;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_64(int8_t  p_65, uint16_t  p_66, struct S1  p_67, int8_t  p_68, uint32_t  p_69)
{ /* block id: 46 */
    int8_t l_81 = 0x2C;
    int32_t l_82 = 0x8CD4FCE6;
    int32_t l_83 = 0xE25D9D01;
    uint32_t l_84 = 0x7AB62727;
    int32_t l_87 = 0x7548BA02;
    for (p_68 = 0; (p_68 == (-12)); p_68 -= 1)
    { /* block id: 49 */
        l_83 &= (l_82 = l_81);
        l_84 |= p_67.f0;
    }
    l_82 |= ((uint16_t)(p_68 | 0x32E7CE9F) * (uint16_t)p_67.f2);
    return l_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_70(struct S0  p_71, uint32_t  p_72)
{ /* block id: 43 */
    union U2 l_74 = {-7};
    p_71.f5 = p_71.f0;
    return l_74;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 124
   depth: 1, occurrence: 45
XXX total union variables: 10

XXX non-zero bitfields defined in structs: 13
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 55
breakdown:
   indirect level: 0, occurrence: 55
XXX full-bitfields structs in the program: 45
breakdown:
   indirect level: 0, occurrence: 45
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 23
XXX times a bitfields struct on RHS: 84
XXX times a single bitfield on LHS: 70
XXX times a single bitfield on RHS: 177

XXX max expression depth: 45
breakdown:
   depth: 1, occurrence: 155
   depth: 2, occurrence: 34
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 4
   depth: 20, occurrence: 4
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 31, occurrence: 1
   depth: 35, occurrence: 1
   depth: 39, occurrence: 1
   depth: 45, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 596
XXX times a non-volatile is write: 200
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 146
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 32
   depth: 2, occurrence: 23
   depth: 3, occurrence: 25
   depth: 4, occurrence: 15
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 22.1
XXX percentage an existing variable is used: 77.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

