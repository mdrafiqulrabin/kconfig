/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      433789298
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   unsigned f0 : 7;
   int16_t  f1;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_1(void);
inline static uint16_t  func_5(const union U0  p_6, uint32_t  p_7, union U0  p_8, uint32_t  p_9, uint32_t  p_10);
inline static const union U0  func_11(int16_t  p_12, const uint8_t  p_13, int16_t  p_14, int32_t  p_15, int16_t  p_16);
inline static uint16_t  func_19(int32_t  p_20, int32_t  p_21);
static int32_t  func_22(int8_t  p_23, int8_t  p_24, uint32_t  p_25, uint32_t  p_26, int8_t  p_27);
inline static int32_t * func_47(uint32_t  p_48, int32_t * p_49, union U0  p_50);
inline static int32_t * func_51(int16_t  p_52, int32_t * p_53, int8_t  p_54, uint32_t  p_55, uint32_t  p_56);
static int32_t * func_58(int32_t * p_59, int32_t * p_60, int32_t * p_61, int16_t  p_62, union U0  p_63);
static int32_t * func_64(int32_t * p_65);
inline static int32_t ** func_68(int32_t  p_69, int32_t * const * p_70, int32_t * p_71);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_4 = 1U;
    union U0 l_814 = {0xADFD5236};
    int32_t l_820 = 0xC59F06D6;
    int32_t *l_819 = &l_820;
    int32_t **l_818 = &l_819;
    uint8_t l_835 = 0x12;
    int32_t ***l_849 = &l_818;
    int32_t ****l_848 = &l_849;
    union U0 *l_866 = &l_814;
    union U0 **l_865 = &l_866;
    uint32_t l_978 = 4294967291U;
    const int32_t *** const *l_1018 = (void*)0;
    const int32_t *** const **l_1017 = &l_1018;
    uint32_t l_1042 = 0x6E9FEF91;
    int32_t *l_1064 = (void*)0;
    uint8_t l_1070 = 0x60;
    uint16_t l_1082 = 0x11E3;
    int32_t *l_1083 = &l_814.f2;
    uint32_t l_1084 = 0xCAA6BA56;
    if ((safe_add_func_uint16_t_u_u(l_4, func_5(func_11((((((0U && ((safe_sub_func_uint16_t_u_u(func_19(l_4, l_4), l_4)) && (((safe_add_func_uint8_t_u_u(0x5F, (l_4 == (safe_div_func_uint32_t_u_u(0x4ED5EFBB, l_4))))) & l_4) || 1))) < l_4) | l_4) & l_4) != l_4), l_4, l_4, l_4, l_4), l_4, l_814, l_814.f0, l_814.f0))))
    { /* block id: 295 */
        const int32_t *l_822 = &l_820;
        const int32_t **l_821 = &l_822;
        union U0 *l_828 = &l_814;
        int32_t l_842 = (-9);
        union U0 ***l_872 = (void*)0;
        int32_t *****l_889 = &l_848;
        uint8_t l_902 = 255U;
        union U0 *****l_930 = (void*)0;
        if (((l_818 == l_821) > ((safe_sub_func_int16_t_s_s((safe_add_func_uint32_t_u_u((!(&l_814 != l_828)), (safe_sub_func_int16_t_s_s(((safe_add_func_int8_t_s_s((**l_821), (**l_821))) ^ ((safe_div_func_int32_t_s_s(((*l_819) >= l_835), (0x55 | (*l_819)))) | (*l_822))), (**l_818))))), (*l_819))) <= 0xC8AC8BC6)))
        { /* block id: 296 */
            for (l_814.f2 = 3; (l_814.f2 <= 10); l_814.f2 = safe_add_func_uint16_t_u_u(l_814.f2, 2))
            { /* block id: 299 */
                union U0 **l_838 = &l_828;
                union U0 ***l_839 = &l_838;
                int32_t *l_840 = &l_820;
                (*l_839) = l_838;
                (*l_821) = l_840;
            }
            /* facts after for loop */
            lbl_841:
            (*l_821) = (*l_821);
        }
        else
        { /* block id: 304 */
            int8_t l_845 = 8;
            int32_t l_869 = (-10);
            int32_t **l_880 = &l_819;
            union U0 *l_896 = (void*)0;
            if (l_814.f0)
                goto lbl_841;
            if (((((**l_818) >= l_842) & (safe_rshift_func_int16_t_s_u(l_845, (((safe_div_func_uint16_t_u_u((l_848 != (void*)0), (*l_822))) | ((safe_mod_func_int8_t_s_s(0x39, (safe_add_func_int32_t_s_s((safe_add_func_uint32_t_u_u(l_845, ((7 <= (***l_849)) == (**l_821)))), l_845)))) > 3)) && (*l_819))))) && l_845))
            { /* block id: 306 */
                union U0 *l_856 = &l_814;
                const int32_t l_862 = 2;
                uint32_t l_867 = 9U;
                int32_t ****l_890 = &l_849;
                (***l_849) = (l_828 == l_856);
                if (l_845)
                { /* block id: 308 */
                    int32_t *l_857 = (void*)0;
                    int32_t l_868 = 0xD6E38703;
                    union U0 ***l_873 = (void*)0;
                    int32_t *l_874 = &l_868;
                    (**l_849) = l_857;
                    /* statement id: 309 */
                    assert (l_819 == 0);
                    l_869 = (safe_lshift_func_int8_t_s_s((((safe_sub_func_int32_t_s_s(((l_845 <= l_862) == l_862), 4)) | (((safe_sub_func_int8_t_s_s(((((void*)0 != l_865) ^ l_867) != (&l_828 != &l_828)), l_867)) != l_868) | l_845)) >= 1), 7));
                    (*l_874) = (((0x4BA47BDA & 9U) != (l_868 & (l_869 == (safe_lshift_func_int16_t_s_s(1, 12))))) | (l_872 != l_873));
                    if ((((**l_821) != 0xE6) != ((((**l_821) && (((~(safe_div_func_int16_t_s_s((((safe_sub_func_int32_t_s_s((&l_822 == l_880), ((((void*)0 == &l_880) & ((*l_865) != (*l_865))) > 0x00))) > (*l_874)) || 1), (*l_874)))) && (**l_821)) > (*l_874))) ^ (*l_874)) || l_862)))
                    { /* block id: 312 */
                        (*l_874) = l_867;
                        return l_862;
                    }
                    else
                    { /* block id: 315 */
                        int16_t l_885 = 0;
                        return l_885;
                    }
                }
                else
                { /* block id: 318 */
                    int8_t l_891 = (-2);
                    for (l_835 = 11; (l_835 == 34); ++l_835)
                    { /* block id: 321 */
                        int32_t *****l_888 = &l_848;
                    }
                    (*l_889) = l_890;
                    return l_891;
                }
            }
            else
            { /* block id: 329 */
                int32_t l_897 = 0xA2626DDB;
                if (((void*)0 != l_880))
                { /* block id: 330 */
                    for (l_842 = 24; (l_842 > (-16)); l_842 = safe_sub_func_int32_t_s_s(l_842, 8))
                    { /* block id: 333 */
                        union U0 ****l_894 = &l_872;
                        union U0 *****l_895 = &l_894;
                        (*l_895) = l_894;
                        if ((***l_849))
                            break;
                    }
                    (*l_865) = l_896;
                    /* statement id: 337 */
                    assert (l_866 == 0);
                }
                else
                { /* block id: 338 */
                    return l_897;
                }
                /* facts after branching */
                assert (l_866 == 0);
                (**l_880) = 0x2ED956DC;
                (*****l_889) = (safe_mod_func_int16_t_s_s((***l_849), ((safe_add_func_int16_t_s_s((0xB0923F2E >= l_902), ((*l_819) >= (safe_add_func_int32_t_s_s((!(l_897 && (safe_sub_func_uint8_t_u_u((safe_add_func_int16_t_s_s(((safe_lshift_func_int16_t_s_u((((safe_lshift_func_int8_t_s_s(((safe_div_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(((void*)0 == (*l_889)), (**l_880))), (**l_818))) || (*l_819)), 4)) > (**l_880)) ^ (*****l_889)), (*****l_889))) <= (**l_821)), (***l_849))), (**l_880))))), 7))))) | (**l_880))));
                (****l_848) = (-2);
            }
            /* facts after branching */
            assert (l_866 == 0);
        }
        /* facts after branching */
        assert (l_866 == 0 || l_866 == &l_814);
        if ((((safe_rshift_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u((*****l_889), 0x4C41)) || (***l_849)), 2)) == ((safe_div_func_uint8_t_u_u((safe_mod_func_int32_t_s_s(0xBAD42CE4, (*****l_889))), ((*l_819) || (**l_821)))) == ((0xFF613E14 < (**l_821)) <= 0x31))) | 0U))
        { /* block id: 346 */
            union U0 ****l_929 = &l_872;
            union U0 *****l_928 = &l_929;
            int32_t l_949 = 0;
            l_930 = l_928;
            /* statement id: 347 */
            assert (l_930 == &l_929);
            for (l_902 = 0; (l_902 != 43); l_902 = safe_add_func_int16_t_s_s(l_902, 1))
            { /* block id: 350 */
                uint32_t l_941 = 0xDDCA573D;
                uint8_t l_944 = 0U;
                int32_t *l_950 = &l_820;
                uint8_t l_951 = 2U;
                (*****l_889) = (safe_lshift_func_uint8_t_u_s((safe_unary_minus_func_int8_t_s(0x8F)), (safe_sub_func_uint16_t_u_u(((**l_818) != 0xD418), (l_930 != (void*)0)))));
                (**l_849) = func_51(((&l_865 != (void*)0) >= (safe_lshift_func_int16_t_s_s(((!(l_941 > (safe_sub_func_uint32_t_u_u(l_944, ((*l_822) || ((0U > 0x860F) == 0x54)))))) || (safe_sub_func_uint16_t_u_u(((*****l_889) > l_949), 0x39F3))), (***l_849)))), l_950, l_951, (*l_950), (*l_950));
            }
            return l_949;
        }
        else
        { /* block id: 355 */
            uint32_t l_952 = 0xAC6E9351;
            return l_952;
        }
    }
    else
    { /* block id: 358 */
        int8_t l_957 = (-9);
        int32_t * const *l_965 = &l_819;
        int32_t * const **l_964 = &l_965;
        union U0 ** const *l_976 = (void*)0;
        uint32_t l_977 = 4U;
        int32_t *l_996 = (void*)0;
        const union U0 **l_1031 = (void*)0;
        if ((((((safe_lshift_func_uint16_t_u_s(65529U, 9)) == (safe_rshift_func_int16_t_s_u((l_957 || (((**l_818) >= (safe_add_func_uint16_t_u_u(((safe_mod_func_int16_t_s_s(((safe_add_func_int16_t_s_s((l_964 != (*l_848)), ((((safe_add_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u(((0x04F5 >= (1U == (safe_lshift_func_uint8_t_u_s((safe_mod_func_int8_t_s_s(((**l_818) <= ((((safe_mod_func_int8_t_s_s((((((void*)0 != l_976) ^ (***l_964)) == (**l_965)) & 1), (**l_818))) != 65535U) && (****l_848)) & 0x0B)), 0x30)), (***l_849))))) >= l_977), l_978)), (***l_964))) < (*l_819)) || (***l_964)) <= (**l_965)))) == (**l_965)), (**l_965))) < 65528U), (**l_818)))) <= (**l_965))), (**l_965)))) != (****l_848)) ^ (**l_818)) && (***l_849)))
        { /* block id: 359 */
            for (l_978 = 0; (l_978 >= 34); ++l_978)
            { /* block id: 362 */
                union U0 ***l_983 = (void*)0;
                (***l_964) = (0xE3BF38E6 == ((safe_lshift_func_uint16_t_u_u((l_983 == (void*)0), 14)) && (****l_848)));
            }
        }
        else
        { /* block id: 365 */
            int32_t *l_984 = &l_814.f2;
            l_984 = func_64((**l_849));
            /* statement id: 366 */
            assert (l_984 == &l_820);
        }
        if ((((***l_964) | 1) || (safe_lshift_func_int8_t_s_s((((void*)0 != &l_964) >= ((safe_mod_func_uint32_t_u_u(1U, (0x08 & (safe_div_func_int16_t_s_s((safe_sub_func_int32_t_s_s((***l_964), (((!((((**l_818) || (safe_add_func_uint32_t_u_u(((***l_964) < (***l_964)), (**l_965)))) | (*l_819)) < (**l_965))) == 0xBF8B) | 0xA092BADA))), (**l_965)))))) | 65530U)), 0))))
        { /* block id: 368 */
            int32_t *l_997 = &l_820;
            l_997 = (*l_965);
        }
        else
        { /* block id: 370 */
            const uint16_t l_1000 = 65531U;
            uint8_t l_1020 = 9U;
            int32_t l_1060 = 0x399D93A9;
            uint32_t l_1061 = 0xDC3A5EB5;
            int32_t l_1062 = 0x38EE22BB;
            union U0 l_1073 = {6U};
            int32_t l_1081 = 0xF0160E8B;
            for (l_814.f2 = (-17); (l_814.f2 == 29); ++l_814.f2)
            { /* block id: 373 */
                int32_t *l_1004 = &l_814.f2;
                union U0 l_1063 = {0xDDE7981E};
            }
            /* facts after for loop */
                        (***l_848) = (void*)0;
            /* statement id: 405 */
            assert (l_819 == 0);
        }
        /* facts after branching */
        assert (l_819 == 0 || l_819 == &l_820);
        (***l_848) = (void*)0;
        /* statement id: 407 */
        assert (l_819 == 0);
        (*l_865) = (*l_865);
    }
    /* facts after branching */
    assert (l_819 == 0);
    (*l_1017) = (*l_1017);
    (***l_848) = (***l_848);
    (*l_1083) = l_1082;
    /* statement id: 412 */
        return l_1084;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_5(const union U0  p_6, uint32_t  p_7, union U0  p_8, uint32_t  p_9, uint32_t  p_10)
{ /* block id: 292 */
    int32_t l_816 = 0;
    int32_t *l_815 = &l_816;
    int32_t **l_817 = &l_815;
    (*l_817) = l_815;
    return p_8.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U0  func_11(int16_t  p_12, const uint8_t  p_13, int16_t  p_14, int32_t  p_15, int16_t  p_16)
{ /* block id: 285 */
    const uint16_t l_812 = 0xFF36;
    const union U0 l_813 = {9U};
    for (p_14 = (-12); (p_14 < 27); p_14 = safe_add_func_uint8_t_u_u(p_14, 9))
    { /* block id: 288 */
        if (l_812)
            break;
    }
    return l_813;
    /* statement id: 291 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_19(int32_t  p_20, int32_t  p_21)
{ /* block id: 1 */
    int8_t l_30 = 0;
    int32_t l_39 = 5;
    uint32_t l_40 = 4294967293U;
    int32_t l_745 = 0xF0BACA92;
    int32_t *l_744 = &l_745;
    union U0 l_749 = {0x71F2B993};
    int32_t **l_753 = (void*)0;
    const int32_t **l_754 = (void*)0;
    int32_t **l_755 = &l_744;
    uint32_t l_756 = 4294967295U;
    union U0 *l_805 = &l_749;
    union U0 **l_804 = &l_805;
lbl_757:
    if (func_22((p_21 == ((0x3A0F0F5E < (((safe_sub_func_int16_t_s_s(l_30, p_20)) > (safe_rshift_func_uint16_t_u_s((((safe_sub_func_int8_t_s_s((safe_rshift_func_int16_t_s_s(l_30, p_21)), 0x1D)) && l_30) != (safe_div_func_uint8_t_u_u(0x85, l_39))), p_20))) < 6)) < l_40)), p_21, p_21, l_39, l_39))
    { /* block id: 252 */
        const uint32_t l_746 = 4294967295U;
        int32_t *l_748 = &l_745;
        int32_t **l_750 = &l_744;
        (*l_750) = func_58(l_744, func_51(((l_746 | (~(*l_744))) != 0xE2), l_748, p_20, p_20, (*l_744)), l_748, p_21, l_749);
        /* statement id: 253 */
        assert (l_744 == &l_745);
        (*l_750) = (void*)0;
        /* statement id: 254 */
        assert (l_744 == 0);
    }
    else
    { /* block id: 255 */
        int32_t * const *l_752 = &l_744;
        int32_t * const **l_751 = &l_752;
        (*l_751) = &l_744;
        (**l_752) = 0xEF346340;
        return p_20;
    }
    /* facts after branching */
    assert (l_744 == 0);
lbl_758:
    (*l_755) = &p_20;
    /* statement id: 260 */
    assert (l_744 == &p_20);
    if ((l_756 <= p_21))
    { /* block id: 261 */
        if (l_749.f0)
            goto lbl_757;
        if (p_21)
            goto lbl_758;
    }
    else
    { /* block id: 264 */
        int32_t *l_759 = &l_749.f2;
        union U0 *l_791 = (void*)0;
        const int32_t ****l_798 = (void*)0;
        int32_t ***l_803 = &l_753;
        int32_t ****l_802 = &l_803;
        int32_t *****l_801 = &l_802;
        l_759 = (void*)0;
        /* statement id: 265 */
        assert (l_759 == 0);
        for (l_39 = 0; (l_39 == (-15)); l_39--)
        { /* block id: 268 */
            int32_t l_787 = 0;
            int32_t *l_790 = (void*)0;
        }
        (**l_755) = (0x6472 != ((((p_21 >= (safe_rshift_func_uint8_t_u_u(p_21, (safe_lshift_func_uint8_t_u_u(0xB5, 1))))) | (((0U || (((safe_add_func_uint32_t_u_u((((void*)0 == l_798) <= (safe_mod_func_int32_t_s_s(0x608BE7CC, p_20))), p_21)) >= 0) | 65535U)) & p_21) | 8)) & p_20) >= 0x8D));
        (*l_801) = l_798;
        /* statement id: 281 */
        assert (l_802 == 0);
    }
    (*l_804) = &l_749;
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_22(int8_t  p_23, int8_t  p_24, uint32_t  p_25, uint32_t  p_26, int8_t  p_27)
{ /* block id: 2 */
    int32_t l_97 = 0x13BCE866;
    int32_t *l_96 = &l_97;
    int32_t **l_641 = &l_96;
    int32_t ** const l_646 = &l_96;
    union U0 l_733 = {0x898E8FEF};
    for (p_26 = 0; (p_26 == 21); ++p_26)
    { /* block id: 5 */
        int32_t l_67 = 0x6A96DAD8;
        int32_t *l_66 = &l_67;
        union U0 l_153 = {1U};
        int32_t **l_640 = &l_96;
        for (p_24 = (-12); (p_24 != 18); p_24 = safe_add_func_uint8_t_u_u(p_24, 6))
        { /* block id: 8 */
            int32_t * const l_98 = (void*)0;
            union U0 l_99 = {0xB4FD0891};
            for (p_27 = 0; (p_27 == (-2)); p_27--)
            { /* block id: 11 */
                uint16_t l_57 = 65529U;
                int32_t l_95 = (-1);
                int32_t *l_94 = &l_95;
                int32_t **l_638 = (void*)0;
                int32_t **l_639 = &l_66;
            }
            (*l_66) = (p_26 || p_23);
        }
        (*l_640) = &l_97;
        if (p_24)
            continue;
    }
    (*l_641) = func_64(&l_97);
    (**l_641) = (((void*)0 == (*l_641)) != ((safe_lshift_func_int16_t_s_u(0, 3)) == p_23));
    for (p_23 = 25; (p_23 <= (-10)); p_23 = safe_sub_func_int32_t_s_s(p_23, 1))
    { /* block id: 212 */
        int32_t **l_647 = &l_96;
        union U0 l_651 = {0x9770B23B};
        union U0 *l_650 = &l_651;
        int32_t **l_677 = (void*)0;
        int32_t ***l_716 = &l_641;
        int32_t ****l_715 = &l_716;
        int8_t l_729 = 1;
        (**l_641) = (((l_646 != l_647) & (safe_lshift_func_int16_t_s_s(((**l_641) != (l_650 != &l_651)), 5))) <= p_23);
        (**l_647) = (safe_div_func_int8_t_s_s((((safe_sub_func_int32_t_s_s((safe_add_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s(65535U, p_24)), (safe_add_func_int16_t_s_s((((void*)0 == &l_96) | p_24), ((!(p_27 != (safe_rshift_func_int16_t_s_u((**l_647), ((-1) ^ 0xAA))))) <= p_27))))), 0x7A2E8794)) || 0x2F) ^ p_27), p_24));
        if (((((&l_96 == l_647) == ((safe_sub_func_int32_t_s_s(((**l_647) < ((((safe_add_func_uint16_t_u_u((safe_div_func_int16_t_s_s(((safe_sub_func_int16_t_s_s((safe_mod_func_int32_t_s_s(p_25, (*l_96))), (((safe_add_func_uint8_t_u_u(p_24, 0xC4)) == (((void*)0 == l_677) ^ p_26)) == (**l_647)))) | (**l_646)), 0xB975)), p_23)) > 0) ^ (**l_646)) > p_25)), 4294967295U)) ^ p_26)) <= (**l_647)) != (**l_641)))
        { /* block id: 215 */
            int32_t *l_680 = &l_97;
            (**l_646) = (**l_647);
            for (p_27 = 0; (p_27 >= (-21)); p_27 = safe_sub_func_int16_t_s_s(p_27, 8))
            { /* block id: 219 */
                if (p_27)
                    break;
                (*l_646) = l_680;
                (*l_641) = l_680;
                return p_24;
            }
        }
        else
        { /* block id: 225 */
            uint8_t l_703 = 0x47;
            union U0 l_721 = {0xD1FF4C36};
            int32_t *l_722 = &l_97;
            int32_t ***l_732 = &l_677;
            for (p_25 = 0; (p_25 != 30); ++p_25)
            { /* block id: 228 */
                int32_t ***l_686 = &l_677;
                int32_t ****l_685 = &l_686;
                uint32_t l_693 = 0x1219B665;
                uint16_t l_700 = 0U;
                (*l_96) = (safe_add_func_int8_t_s_s((l_685 == (void*)0), p_23));
                (**l_641) = (safe_sub_func_int16_t_s_s(p_25, ((safe_add_func_uint32_t_u_u((((0x3186 && (safe_mod_func_uint16_t_u_u(l_693, p_23))) ^ p_27) == (((void*)0 == &l_650) ^ p_24)), ((safe_lshift_func_int8_t_s_s((((safe_sub_func_uint16_t_u_u((safe_rshift_func_int8_t_s_u((**l_646), 5)), (**l_647))) > p_27) == p_27), p_25)) <= (**l_646)))) || l_700)));
            }
            if ((safe_div_func_uint8_t_u_u(((((l_703 & 1U) > p_26) < (safe_lshift_func_uint16_t_u_u(0x8DD1, 1))) & (~(safe_rshift_func_uint8_t_u_s((0x0C66 || ((((((safe_sub_func_uint32_t_u_u(4294967295U, p_25)) && (-2)) >= (safe_mod_func_uint16_t_u_u(p_24, (*l_96)))) >= p_26) & 0x57) | p_24)), (*l_96))))), (-1))))
            { /* block id: 232 */
                int32_t ****l_717 = &l_716;
                for (l_97 = 0; (l_97 != 0); l_97 = safe_add_func_int32_t_s_s(l_97, 1))
                { /* block id: 235 */
                    return p_27;
                }
                (**l_641) = (l_715 == l_717);
                for (p_26 = (-1); (p_26 == 13); p_26 = safe_add_func_int8_t_s_s(p_26, 7))
                { /* block id: 241 */
                    (*l_646) = (**l_716);
                }
            }
            else
            { /* block id: 244 */
                int32_t *l_720 = &l_97;
                (***l_715) = func_58(l_720, l_720, l_720, ((*l_720) <= p_27), l_721);
            }
            (*l_641) = func_58((*l_646), func_51((**l_646), l_722, (*l_722), p_27, (safe_div_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u(p_24, (safe_add_func_uint8_t_u_u((l_729 > 0U), ((safe_add_func_int32_t_s_s((l_732 == l_732), 1U)) > (*l_96)))))), 1))), (*l_641), (*l_96), l_733);
        }
        (*l_96) = ((((((((((**l_641) & (safe_unary_minus_func_int16_t_s(0))) >= 0xEDB5A356) || (((!p_24) > (((0x5C4AD845 < (safe_div_func_uint16_t_u_u((****l_715), p_26))) < ((safe_mod_func_uint8_t_u_u((safe_mod_func_uint8_t_u_u(0xE9, (safe_sub_func_int8_t_s_s(p_25, 7)))), p_26)) & p_25)) <= p_23)) & (**l_646))) ^ (**l_646)) == 0xE6CE024D) & 1U) & p_27) < p_26) | (*l_96));
    }
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_47(uint32_t  p_48, int32_t * p_49, union U0  p_50)
{ /* block id: 40 */
    uint16_t l_184 = 9U;
    int32_t l_236 = 3;
    int32_t *l_258 = (void*)0;
    int32_t **l_257 = &l_258;
    union U0 l_310 = {4294967295U};
    union U0 *l_309 = &l_310;
    int32_t ***l_375 = &l_257;
    int32_t ****l_374 = &l_375;
    int16_t l_400 = 0;
    const int32_t l_402 = 0x9D36743C;
    int32_t *****l_406 = &l_374;
    uint16_t l_470 = 0xC81A;
    union U0 *l_516 = &l_310;
    union U0 * const l_524 = &l_310;
    int16_t l_538 = 0xE14C;
    for (p_50.f1 = (-14); (p_50.f1 == (-9)); p_50.f1 = safe_add_func_int8_t_s_s(p_50.f1, 1))
    { /* block id: 43 */
        int16_t l_166 = 0x40D3;
        int32_t *l_175 = (void*)0;
        int32_t **l_212 = &l_175;
        if ((*p_49))
        { /* block id: 44 */
            uint8_t l_185 = 255U;
            int32_t **l_209 = &l_175;
            for (p_48 = 0; (p_48 != 5); p_48 = safe_add_func_int32_t_s_s(p_48, 5))
            { /* block id: 47 */
                int32_t l_158 = 6;
                const int32_t l_186 = (-1);
                for (l_158 = 18; (l_158 == (-11)); l_158 = safe_sub_func_uint32_t_u_u(l_158, 1))
                { /* block id: 50 */
                    int32_t l_161 = 0x1E07D3A0;
                    for (l_161 = 0; (l_161 >= 19); l_161 = safe_add_func_int32_t_s_s(l_161, 1))
                    { /* block id: 53 */
                        int16_t l_178 = (-3);
                        (*p_49) = ((p_50.f1 != 0xD78F) != (safe_lshift_func_int8_t_s_s(l_166, 7)));
                        (*p_49) = (safe_mod_func_uint32_t_u_u((3 ^ (!((safe_unary_minus_func_int8_t_s(((safe_add_func_int8_t_s_s(((0x4AA8 < (((safe_lshift_func_int16_t_s_s(((void*)0 != l_175), 7)) >= ((safe_div_func_int8_t_s_s((l_158 ^ (l_178 & (safe_unary_minus_func_uint16_t_u((l_158 || (((safe_rshift_func_int16_t_s_s(((*p_49) | (safe_lshift_func_uint16_t_u_u(p_50.f1, p_48))), 11)) > p_48) | p_48)))))), l_184)) <= p_50.f1)) != l_185)) & (*p_49)), 0xE3)) <= p_50.f1))) && 65535U))), l_186));
                        (*p_49) = ((safe_mod_func_uint8_t_u_u(l_184, l_161)) < ((l_161 & 1U) > (((safe_rshift_func_uint16_t_u_s(0x0DF4, 6)) != ((((safe_rshift_func_int16_t_s_u((-1), (((safe_lshift_func_int8_t_s_u(l_161, 0)) ^ (safe_lshift_func_int16_t_s_s(((void*)0 == p_49), 1))) == p_50.f1))) | p_50.f1) || l_161) ^ 0x6A3F)) | 0x3C)));
                        (*p_49) = (p_48 >= (safe_add_func_int32_t_s_s((l_184 ^ (5U != l_161)), (safe_mod_func_int16_t_s_s((l_161 ^ (safe_sub_func_uint16_t_u_u(0U, ((safe_mod_func_int32_t_s_s((l_158 && (safe_sub_func_uint8_t_u_u(0x02, (p_50.f1 != (-1))))), p_48)) || l_178)))), 1)))));
                    }
                    (*p_49) = (safe_rshift_func_uint16_t_u_u(1U, 11));
                }
                (*p_49) = (&p_49 != l_209);
                return p_49;
                /* statement id: 62 */
                //assert (func_47_rv == &l_95);
            }
        }
        else
        { /* block id: 64 */
            for (p_48 = (-29); (p_48 >= 56); p_48 = safe_add_func_uint8_t_u_u(p_48, 1))
            { /* block id: 67 */
                return p_49;
                /* statement id: 68 */
                //assert (func_47_rv == &l_95);
            }
        }
        (*p_49) = l_184;
        (*l_212) = (void*)0;
    }
    /* facts after for loop */
        return p_49;
    /* statement id: 200 */
    //assert (func_47_rv == &l_95);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_51(int16_t  p_52, int32_t * p_53, int8_t  p_54, uint32_t  p_55, uint32_t  p_56)
{ /* block id: 37 */
    const int16_t l_146 = (-6);
    int32_t l_149 = 0xA63A6774;
    int32_t *l_148 = &l_149;
    int32_t **l_147 = &l_148;
    int32_t *l_152 = &l_149;
    (*l_148) = (((safe_add_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((l_146 >= (&p_53 != l_147)), (*l_148))), (p_53 == (*l_147)))), (0xDD & (0xF8 < (safe_lshift_func_int16_t_s_s((**l_147), (*l_148))))))), (*l_148))) & 0x967B) | (**l_147));
    return p_53;
    /* statement id: 39 */
    //assert (func_51_rv == &l_95 || func_51_rv == &l_560 || func_51_rv == &l_97 || func_51_rv == &l_745 || func_51_rv == &l_820);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_58(int32_t * p_59, int32_t * p_60, int32_t * p_61, int16_t  p_62, union U0  p_63)
{ /* block id: 33 */
    uint16_t l_100 = 0xD865;
    (*p_61) = l_100;
    (*p_60) = (((safe_lshift_func_uint16_t_u_u(p_62, (safe_add_func_int16_t_s_s((safe_add_func_uint8_t_u_u(p_63.f0, 0x0A)), 0xDE38)))) && (((safe_div_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u(l_100, (safe_div_func_int16_t_s_s((safe_lshift_func_int16_t_s_u((safe_lshift_func_uint8_t_u_s((safe_mod_func_uint16_t_u_u((safe_add_func_int8_t_s_s((safe_mod_func_int32_t_s_s(((((safe_rshift_func_uint8_t_u_u((safe_div_func_uint8_t_u_u(((safe_mod_func_uint8_t_u_u((safe_unary_minus_func_uint8_t_u((safe_div_func_uint16_t_u_u((p_62 == (p_63.f0 >= ((safe_lshift_func_int8_t_s_s(0x77, (safe_rshift_func_uint16_t_u_s(l_100, p_63.f0)))) && l_100))), l_100)))), l_100)) != 0xFE58), l_100)), 6)) ^ (*p_59)) | (-1)) == 3), l_100)), l_100)), l_100)), l_100)), 12)), 0x2403)))), (*p_61))) < p_63.f0) | 0x1240)) <= p_62);
    return p_60;
    /* statement id: 36 */
    //assert (func_58_rv == &l_95 || func_58_rv == &l_97 || func_58_rv == &l_745 || func_58_rv == &l_820);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_64(int32_t * p_65)
{ /* block id: 12 */
    int32_t l_87 = 0x6C987F9B;
    int32_t *l_86 = &l_87;
    int32_t **l_85 = &l_86;
    int32_t **l_88 = &l_86;
    l_85 = func_68((*p_65), &p_65, p_65);
    /* statement id: 27 */
    assert (l_85 == 0);
    (*l_86) = (*l_86);
    if (l_87)
        goto lbl_89;
lbl_89:
    (*l_88) = p_65;
    /* statement id: 29 */
    //assert (l_86 == &l_67 || l_86 == &l_97 || l_86 == &l_820);
    (**l_88) = ((&l_86 == (void*)0) == ((!(safe_add_func_int8_t_s_s((safe_unary_minus_func_int32_t_s((*p_65))), ((*p_65) | ((void*)0 != &p_65))))) <= (**l_88)));
    return p_65;
    /* statement id: 32 */
    //assert (func_64_rv == &l_67 || func_64_rv == &l_97 || func_64_rv == &l_820);
}


/* ------------------------------------------ */
/* 
 * reads : l_67 l_97 l_820
 * writes: l_67 l_97 l_820
 */
inline static int32_t ** func_68(int32_t  p_69, int32_t * const * p_70, int32_t * p_71)
{ /* block id: 13 */
    int32_t l_82 = 0x915F7446;
    int32_t *l_81 = &l_82;
    int32_t **l_84 = (void*)0;
    for (p_69 = 2; (p_69 == 12); p_69 = safe_add_func_int32_t_s_s(p_69, 9))
    { /* block id: 16 */
        int32_t l_74 = (-5);
        int32_t **l_83 = (void*)0;
        for (l_74 = 16; (l_74 < (-9)); l_74 = safe_sub_func_int16_t_s_s(l_74, 2))
        { /* block id: 19 */
            (*l_81) = (safe_mod_func_int32_t_s_s((p_69 ^ (p_69 && (safe_sub_func_int16_t_s_s(p_69, ((void*)0 == l_81))))), l_74));
            return l_83;
            /* statement id: 21 */
            //assert (func_68_rv == 0);
        }
        (**p_70) = 0;
        (*l_81) = (**p_70);
    }
    return l_84;
    /* statement id: 26 */
    //assert (func_68_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 195
XXX total union variables: 9

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 36
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 25
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 14

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 32
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 4
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 163

XXX times a variable address is taken: 171
XXX times a pointer is dereferenced on RHS: 248
breakdown:
   depth: 1, occurrence: 155
   depth: 2, occurrence: 59
   depth: 3, occurrence: 19
   depth: 4, occurrence: 8
   depth: 5, occurrence: 7
XXX times a pointer is dereferenced on LHS: 116
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 16
   depth: 3, occurrence: 8
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 52
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 21
XXX times a pointer is qualified to be dereferenced: 701

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 433
   level: 2, occurrence: 141
   level: 3, occurrence: 69
   level: 4, occurrence: 50
   level: 5, occurrence: 30
XXX number of pointers point to pointers: 88
XXX number of pointers point to scalars: 61
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.33

XXX times a non-volatile is read: 1309
XXX times a non-volatile is write: 339
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 137
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 31
   depth: 2, occurrence: 24
   depth: 3, occurrence: 25
   depth: 4, occurrence: 14
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 16.4
XXX percentage an existing variable is used: 83.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

