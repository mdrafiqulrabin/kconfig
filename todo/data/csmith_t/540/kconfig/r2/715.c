/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --comma-operators --compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1671429838
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
};

union U1 {
   int16_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 4294967295U;
static int32_t * volatile g_39 = (void*)0;/* VOLATILE GLOBAL g_39 */
static int32_t g_41 = 0x89A9B8FA;
static int32_t g_53 = (-1);
static int32_t g_61 = 0xB8CE2295;
static const union U0 g_63 = {4294967295U};
static uint16_t g_86 = 0x3585;
static int16_t *g_87 = (void*)0;
static int16_t g_94[1] = {0xF992};
static int16_t *g_93 = &g_94[0];
static int16_t **g_92 = &g_93;
static int32_t ** volatile g_98 = (void*)0;/* VOLATILE GLOBAL g_98 */
static int32_t *g_100 = &g_61;
static int32_t ** const  volatile g_99 = &g_100;/* VOLATILE GLOBAL g_99 */
static volatile uint16_t g_130 = 0U;/* VOLATILE GLOBAL g_130 */
static union U1 g_137 = {0xAC22};
static int32_t g_140[8][8][2] = {{{8,3},{(-10),8},{0,0},{0,8},{(-10),3},{8,(-1)},{0x570BAEA4,(-10)},{(-1),0x2C2DE0B6}},{{0x2C2DE0B6,1},{0x1ECDBA6A,0x03095B69},{(-4),0x570BAEA4},{0x5310EE7D,0xE02B323E},{(-1),0xE02B323E},{0x5310EE7D,0x570BAEA4},{(-4),0x03095B69},{0x1ECDBA6A,1}},{{0x2C2DE0B6,0x2C2DE0B6},{(-1),(-10)},{0x570BAEA4,(-1)},{8,3},{(-10),8},{0,0},{0,(-1)},{0xE02B323E,(-8)}},{{(-1),1},{(-1),0xE02B323E},{3,0},{0,0x2C2DE0B6},{0x570BAEA4,0},{0x25B5FE41,(-1)},{0x1ECDBA6A,(-4)},{1,(-4)}},{{0x1ECDBA6A,(-1)},{0x25B5FE41,0},{0x570BAEA4,0x2C2DE0B6},{0,0},{3,0xE02B323E},{(-1),1},{(-1),(-8)},{0xE02B323E,(-1)}},{{0x96C8B9E1,0},{0x96C8B9E1,(-1)},{0xE02B323E,(-8)},{(-1),1},{(-1),0xE02B323E},{3,0},{0,0x2C2DE0B6},{0x570BAEA4,0}},{{0x25B5FE41,(-1)},{0x1ECDBA6A,(-4)},{1,(-4)},{0x1ECDBA6A,(-1)},{0x25B5FE41,0},{0x570BAEA4,0x2C2DE0B6},{0,0},{3,0xE02B323E}},{{(-1),1},{(-1),(-8)},{0xE02B323E,(-1)},{0x96C8B9E1,0},{0x96C8B9E1,(-1)},{0xE02B323E,(-8)},{(-1),1},{(-1),0xE02B323E}}};
static volatile uint16_t g_194 = 0xCA42;/* VOLATILE GLOBAL g_194 */
static int32_t g_210 = 0x86FAEEAD;
static int32_t g_215 = 0;
static int16_t g_224[7] = {0x4B7D,(-1),0x4B7D,0x4B7D,(-1),0x4B7D,0x4B7D};
static int32_t g_257 = 0xBC25FB43;
static union U1 *g_274 = &g_137;
static union U1 ** volatile g_273[3][10] = {{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274,&g_274}};
static volatile int32_t g_309 = 0;/* VOLATILE GLOBAL g_309 */
static volatile int32_t *g_308 = &g_309;
static volatile int32_t * volatile *g_307 = &g_308;
static volatile int32_t * volatile **g_306 = &g_307;
static volatile int32_t * volatile ** volatile *g_305 = &g_306;
static volatile int32_t * volatile ** volatile ** volatile g_310 = (void*)0;/* VOLATILE GLOBAL g_310 */
static union U1 ** volatile g_313 = &g_274;/* VOLATILE GLOBAL g_313 */
static volatile uint32_t g_323 = 0xACF57F94;/* VOLATILE GLOBAL g_323 */
static union U0 g_337 = {4294967295U};
static uint32_t g_342 = 0x01054E44;
static const int64_t g_364 = (-8);
static int32_t ** const  volatile g_380[4][7] = {{&g_100,(void*)0,(void*)0,&g_100,&g_100,(void*)0,(void*)0},{&g_100,&g_100,(void*)0,&g_100,(void*)0,(void*)0,&g_100},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&g_100,&g_100},{(void*)0,&g_100,(void*)0,&g_100,(void*)0,(void*)0,&g_100}};
static int32_t ** const  volatile g_381 = &g_100;/* VOLATILE GLOBAL g_381 */
static uint32_t g_393 = 1U;
static const int32_t *g_405 = (void*)0;
static const int32_t ** volatile g_404 = &g_405;/* VOLATILE GLOBAL g_404 */
static const int32_t **g_447 = &g_405;
static const int32_t ***g_446 = &g_447;
static const int32_t ****g_445 = &g_446;
static const int32_t **** const *g_444 = &g_445;
static int64_t g_463 = 0x3389F063BEE14C13LL;
static union U1 g_497 = {0x1352};
static volatile uint32_t g_536 = 0x6415F41C;/* VOLATILE GLOBAL g_536 */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_27(void);
inline static const int32_t * func_29(int32_t * p_30, int32_t  p_31, const int32_t * p_32, int32_t * p_33, int32_t * p_34);
static int32_t * func_35(uint32_t  p_36);
inline static uint32_t  func_44(union U0  p_45, const int16_t  p_46, uint16_t  p_47);
static union U0  func_48(uint16_t  p_49, uint32_t  p_50, int32_t * p_51, uint32_t  p_52);
inline static uint32_t  func_54(int32_t * const  p_55, const int32_t * p_56, const union U0  p_57, int32_t  p_58, int32_t * const  p_59);
static int32_t * func_64(int16_t  p_65, uint32_t  p_66, union U0  p_67, int32_t  p_68, int32_t * p_69);
static int16_t  func_73(uint16_t  p_74, uint16_t  p_75, union U1  p_76, const uint32_t  p_77);
static uint16_t  func_78(const uint32_t  p_79, int32_t * const  p_80, const uint32_t  p_81, union U1  p_82, int32_t * const  p_83);
inline static int32_t * func_89(uint32_t  p_90, int16_t ** p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_210
 * writes: g_5
 */
inline static int32_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28[2];
    int32_t * const l_60 = &g_61;
    const int32_t *l_62 = (void*)0;
    int32_t l_70 = 0x7B2C3CC8;
    int32_t *l_378 = (void*)0;
    int32_t l_412 = 0;
    int32_t l_414 = (-8);
    int32_t *l_426 = &l_412;
    int32_t l_441 = 0;
    int64_t *l_462 = &g_463;
    int32_t ****l_484 = (void*)0;
    union U1 *l_493 = &g_137;
    union U1 *l_496 = &g_497;
    uint32_t l_505[3];
    volatile int32_t * volatile ** volatile **l_526 = &g_305;
    int32_t l_535 = 0x52D19F02;
    int i;
    for (i = 0; i < 2; i++)
        l_28[i] = 0x3F23E93D;
    for (i = 0; i < 3; i++)
        l_505[i] = 6U;
    for (g_5 = 0; (g_5 <= 1); g_5 += 1)
    { /* block id: 39 */
        int32_t **l_377 = (void*)0;
        int16_t *l_382 = &g_224[1];
        int32_t l_409 = 0x583FD019;
        int32_t l_410 = 0x4210F982;
        int32_t l_411 = 0xCDFFAD8C;
        int32_t l_413 = 0xCB792CD1;
        uint16_t l_415 = 0U;
        union U0 *l_420[3];
        union U1 l_421 = {-9};
        uint16_t *l_422 = (void*)0;
        uint16_t *l_423 = &l_415;
        uint32_t *l_424 = &g_337.f0;
        const int32_t *l_425 = &l_413;
        const int32_t **l_427 = &l_62;
        uint32_t l_468 = 1U;
        int32_t *l_470 = &l_410;
        uint32_t l_480 = 7U;
        union U1 **l_483[2][9][6] = {{{&g_274,(void*)0,&g_274,&g_274,(void*)0,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,(void*)0},{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,(void*)0},{&g_274,&g_274,&g_274,&g_274,(void*)0,&g_274},{&g_274,(void*)0,&g_274,&g_274,(void*)0,&g_274},{(void*)0,&g_274,&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,(void*)0},{(void*)0,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,(void*)0},{&g_274,&g_274,&g_274,&g_274,(void*)0,&g_274},{&g_274,(void*)0,&g_274,&g_274,(void*)0,&g_274},{(void*)0,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274,&g_274,(void*)0}}};
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_420[i] = &g_337;
    }
    return g_210;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_29(int32_t * p_30, int32_t  p_31, const int32_t * p_32, int32_t * p_33, int32_t * p_34)
{ /* block id: 323 */
    const int32_t *l_403 = &g_140[7][3][1];
    return l_403;
    /* statement id: 324 */
    //assert ((func_29_rv >= &g_140[0][0][0] && func_29_rv <= &g_140[7][7][1]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_41
 */
static int32_t * func_35(uint32_t  p_36)
{ /* block id: 40 */
    for (p_36 = 0; (p_36 < 45); p_36 += 4)
    { /* block id: 43 */
        int32_t *l_40 = &g_41;
        (*l_40) = p_36;
        (*l_40) = (((int16_t)(0U | ((void*)0 != &g_41)) << (int16_t)1) , __builtin_popcountl(p_36));
    }
    return &g_41;
    /* statement id: 47 */
    //assert (func_35_rv == &g_41);
}


/* ------------------------------------------ */
/* 
 * reads : g_86 g_337.f1 g_393 g_94 g_100 g_140 g_92 g_63.f0 g_313 g_274 g_137 g_224 g_5 g_63.f1
 * writes: g_86 g_393 g_140 g_93
 */
inline static uint32_t  func_44(union U0  p_45, const int16_t  p_46, uint16_t  p_47)
{ /* block id: 312 */
    int16_t * const ** const l_389 = (void*)0;
    uint16_t *l_390 = &g_86;
    int32_t l_391 = 0x9905270D;
    uint32_t *l_392 = &g_393;
    union U1 l_396 = {0};
    int64_t *l_397 = (void*)0;
    int16_t *l_398 = &g_94[0];
    int32_t l_399 = 0;
    int16_t *l_400[4][10] = {{&g_224[0],&g_94[0],(void*)0,&g_224[0],(void*)0,&g_94[0],&g_224[0],&g_137.f0,&g_137.f0,&g_224[0]},{&g_137.f0,&l_396.f0,(void*)0,(void*)0,&l_396.f0,&g_137.f0,&g_94[0],&l_396.f0,&g_94[0],&g_137.f0},{&l_396.f0,&l_396.f0,&g_224[5],&l_396.f0,&l_396.f0,&g_224[5],&g_224[0],&g_224[0],&g_224[5],&l_396.f0},{&l_396.f0,&g_94[0],&g_94[0],&l_396.f0,(void*)0,&g_137.f0,&l_396.f0,&g_137.f0,(void*)0,&l_396.f0}};
    int i, j;
    l_391 = ((((((*l_390) &= (l_389 != &g_92)) & p_45.f2) || ((g_337.f1 & func_73(l_391, ((((*l_392)--) == g_94[0]) > g_86), l_396, ((l_397 == l_397) && p_45.f1))) & p_45.f2)) , l_390) != (void*)0);
    (*g_100) |= ((l_399 = __builtin_bswap32(((((*l_390) = (((*l_392) |= (((*g_92) = l_390) == (l_398 = &g_224[6]))) > g_63.f0)) != (8 && ((**g_313) , l_399))) != g_224[6]))) && ((int16_t)l_396.f0 % (int16_t)0x9D5D));
    /* statement id: 321 */
    assert (g_93 == &g_86);
    assert ((l_398 >= &g_224[0] && l_398 <= &g_224[6]));
    return g_63.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_381 g_100 g_140 g_61 g_306 g_307 g_308 g_337
 * writes: g_309
 */
static union U0  func_48(uint16_t  p_49, uint32_t  p_50, int32_t * p_51, uint32_t  p_52)
{ /* block id: 308 */
    union U1 l_387 = {0x0492};
    union U1 l_388 = {0x1190};
    (***g_306) = (((int32_t)((int16_t)(p_50 != ((l_388 = l_387) , l_388.f0)) << (int16_t)7) + (int32_t)(**g_381)) && g_61);
    return g_337;
    /* statement id: 311 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_381 g_140
 * writes: g_100
 */
inline static uint32_t  func_54(int32_t * const  p_55, const int32_t * p_56, const union U0  p_57, int32_t  p_58, int32_t * const  p_59)
{ /* block id: 303 */
    int32_t *l_379 = &g_140[1][2][0];
    (*g_381) = l_379;
    /* statement id: 304 */
    assert ((g_100 >= &g_140[0][0][0] && g_100 <= &g_140[7][7][1]));
    return (*l_379);
}


/* ------------------------------------------ */
/* 
 * reads : g_63.f2 g_87 g_92 g_61 g_99 g_5 g_94 g_86 g_100 g_130 g_137 g_137.f0 g_140
 * writes: g_61 g_86 g_87 g_100 g_130 g_140
 */
static int32_t * func_64(int16_t  p_65, uint32_t  p_66, union U0  p_67, int32_t  p_68, int32_t * p_69)
{ /* block id: 49 */
    uint32_t l_84[4][5][2] = {{{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B}},{{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U}},{{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B}},{{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U},{0x1C9EEB3B,0x1C9EEB3B},{0x1C9EEB3B,1U}}};
    int16_t *l_85[4];
    int16_t **l_88 = &g_87;
    union U1 l_104 = {5};
    uint32_t l_136 = 0x8AA494CA;
    int32_t *l_139[9] = {&g_140[6][1][0],&g_140[6][1][0],&g_140[7][5][0],&g_140[6][1][0],&g_140[6][1][0],&g_140[7][5][0],&g_140[6][1][0],&g_140[6][1][0],&g_140[7][5][0]};
    int32_t l_188 = 5;
    int16_t l_241 = 1;
    uint32_t l_334 = 4294967295U;
    int32_t l_372 = (-1);
    int16_t l_373[4][7][4] = {{{0x894E,6,(-1),0x87AF},{8,0xFD69,1,0xF620},{0,(-7),0,0},{0,0,0,(-10)},{0xD9B7,(-1),(-10),(-4)},{0x4FF9,0,0x9075,1},{(-9),(-1),(-1),(-9)}},{{0xF620,(-1),4,0x2CBB},{0x3827,0x894E,8,0},{0x2CBB,(-1),0x1A7B,1},{0xF0B1,0x4FF9,0x3827,0xDE80},{0,0x87AF,0xF620,(-1)},{0x2775,0x9075,(-9),0},{0,(-1),0x4FF9,8}},{{(-9),0xF620,0xD9B7,(-7)},{0x87AF,(-10),0,(-10)},{4,(-9),0,0x894E},{1,0xF0B1,8,0xD9B7},{0xD9B7,0x21E0,0x894E,0xD327},{0xD9B7,(-4),8,0x228E},{1,0xD327,0,0x9F27}},{{4,0xDE80,0,0xFD69},{0x87AF,(-1),0xD9B7,0},{(-9),0,0x4FF9,6},{0,0x3827,(-9),(-9)},{0x2775,0x2775,0xF620,0x21E0},{0,0x228E,0x3827,0x87AF},{0xF0B1,0,0x1A7B,0x3827}}};
    uint16_t l_374 = 4U;
    int i, j, k;
    for (i = 0; i < 4; i++)
        l_85[i] = (void*)0;
    g_61 = (p_69 == &g_61);
    g_140[1][4][1] ^= ((int16_t)func_73((g_63.f2 , func_78(((g_86 = l_84[3][3][0]) , (&p_65 != ((*l_88) = g_87))), func_89(l_84[0][4][0], g_92), (((uint16_t)l_84[2][1][0] % (uint16_t)(__builtin_popcount((~(g_5 >= 0x3E03EB41))) ^ 0)) > g_94[0]), l_104, p_69)), l_136, g_137, g_137.f0) << (int16_t)9);
    for (l_136 = 25; (l_136 >= 33); l_136 += 8)
    { /* block id: 86 */
        uint32_t l_145[7][10][1] = {{{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U}},{{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27}},{{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U}},{{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U}},{{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27}},{{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U}},{{0xBF850366},{0x16C98A27},{0xBF850366},{0U},{6U},{0U},{0xBF850366},{0x16C98A27},{0xBF850366},{0U}}};
        union U1 l_166 = {-8};
        int32_t l_169 = (-1);
        int16_t ***l_175 = &l_88;
        int32_t l_192 = 0x08CD4FB8;
        int32_t **l_204 = &l_139[1];
        int32_t ***l_203[9] = {(void*)0,&l_204,(void*)0,(void*)0,&l_204,(void*)0,(void*)0,&l_204,(void*)0};
        uint32_t l_324 = 0U;
        union U1 **l_349[8][7][4] = {{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}},{{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274},{&g_274,&g_274,&g_274,&g_274}}};
        int i, j, k;
        for (p_67.f0 = 3; (p_67.f0 <= 8); p_67.f0 += 1)
        { /* block id: 89 */
            int i;
            (*p_69) = ((uint16_t)(((0x59534E3A & (*p_69)) , l_145[3][6][0]) == 0x0EB6C92F) * (uint16_t)p_67.f1);
            return (*g_99);
            /* statement id: 91 */
            //assert (func_64_rv == &g_61);
        }
    }
    l_374--;
    return l_139[0];
    /* statement id: 301 */
    //assert ((func_64_rv >= &g_140[0][0][0] && func_64_rv <= &g_140[7][7][1]));
}


/* ------------------------------------------ */
/* 
 * reads : g_100 g_61 g_140
 * writes: g_61 g_140
 */
static int16_t  func_73(uint16_t  p_74, uint16_t  p_75, union U1  p_76, const uint32_t  p_77)
{ /* block id: 80 */
    int32_t l_138 = 1;
    (*g_100) |= p_74;
    return l_138;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_86 g_100 g_130 g_5 g_99 g_140
 * writes: g_86 g_61 g_130 g_100 g_140
 */
static uint16_t  func_78(const uint32_t  p_79, int32_t * const  p_80, const uint32_t  p_81, union U1  p_82, int32_t * const  p_83)
{ /* block id: 60 */
    int16_t l_121 = (-1);
    int32_t l_124 = 0xC0820F61;
    int32_t l_127 = 0x09F7ADB2;
    int16_t **l_134 = &g_93;
    if ((*p_83))
    { /* block id: 61 */
        for (g_86 = 0; (g_86 > 20); g_86 += 1)
        { /* block id: 64 */
            (*g_100) = 0xFE8BE9C2;
        }
    }
    else
    { /* block id: 67 */
        int16_t l_118 = 0xFD53;
        int32_t l_126 = (-7);
        int32_t l_128 = 0x3FCFB248;
        int32_t l_129 = 0x2A06A03D;
        int16_t **l_133 = &g_93;
        int32_t **l_135 = &g_100;
        for (g_86 = 0; (g_86 > 8); g_86++)
        { /* block id: 70 */
            int32_t l_113 = 0x6D6BBB23;
            int32_t l_125 = (-1);
            for (p_82.f0 = (-14); (p_82.f0 != 2); p_82.f0 += 8)
            { /* block id: 73 */
                int32_t *l_111 = &g_61;
                int32_t *l_112 = &g_61;
                int32_t *l_114 = &g_61;
                int32_t l_115 = 0xD34EA093;
                int32_t *l_116 = (void*)0;
                int32_t *l_117 = &g_61;
                int32_t *l_119 = &g_61;
                int32_t *l_120 = &l_115;
                int32_t *l_122 = (void*)0;
                int32_t *l_123[6];
                int i;
                for (i = 0; i < 6; i++)
                    l_123[i] = &g_61;
                g_130++;
            }
        }
        (*l_135) = func_89((((void*)0 != l_133) | __builtin_bswap32(l_121)), l_134);
        /* statement id: 77 */
        assert (g_100 == &g_61);
    }
    return l_121;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_99
 * writes: g_61 g_100
 */
inline static int32_t * func_89(uint32_t  p_90, int16_t ** p_91)
{ /* block id: 53 */
    int32_t *l_97 = &g_61;
    for (g_61 = 0; (g_61 == 22); g_61 += 8)
    { /* block id: 56 */
        (*g_99) = l_97;
        /* statement id: 57 */
        assert (g_100 == &g_61);
    }
    return l_97;
    /* statement id: 59 */
    //assert (func_89_rv == &g_61);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_41, "g_41", print_hash_value);
    transparent_crc(g_53, "g_53", print_hash_value);
    transparent_crc(g_61, "g_61", print_hash_value);
    transparent_crc(g_63.f0, "g_63.f0", print_hash_value);
    transparent_crc(g_63.f1, "g_63.f1", print_hash_value);
    transparent_crc(g_63.f2, "g_63.f2", print_hash_value);
    transparent_crc(g_86, "g_86", print_hash_value);
    for (i = 0; i < 1; i++)
    {
        transparent_crc(g_94[i], "g_94[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_130, "g_130", print_hash_value);
    transparent_crc(g_137.f0, "g_137.f0", print_hash_value);
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j++)
        {
            for (k = 0; k < 2; k++)
            {
                transparent_crc(g_140[i][j][k], "g_140[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_194, "g_194", print_hash_value);
    transparent_crc(g_210, "g_210", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        transparent_crc(g_224[i], "g_224[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_257, "g_257", print_hash_value);
    transparent_crc(g_309, "g_309", print_hash_value);
    transparent_crc(g_323, "g_323", print_hash_value);
    transparent_crc(g_337.f0, "g_337.f0", print_hash_value);
    transparent_crc(g_337.f1, "g_337.f1", print_hash_value);
    transparent_crc(g_337.f2, "g_337.f2", print_hash_value);
    transparent_crc(g_342, "g_342", print_hash_value);
    transparent_crc(g_364, "g_364", print_hash_value);
    transparent_crc(g_393, "g_393", print_hash_value);
    transparent_crc(g_463, "g_463", print_hash_value);
    transparent_crc(g_497.f0, "g_497.f0", print_hash_value);
    transparent_crc(g_536, "g_536", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 159
XXX total union variables: 15

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 34
   depth: 2, occurrence: 9
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 132

XXX times a variable address is taken: 345
XXX times a pointer is dereferenced on RHS: 99
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 28
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 89
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 12
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 1449

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 346
   level: 2, occurrence: 96
   level: 3, occurrence: 25
   level: 4, occurrence: 10
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 47
XXX number of pointers point to scalars: 78
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 31.8
XXX average alias set size: 1.65

XXX times a non-volatile is read: 532
XXX times a non-volatile is write: 289
XXX times a volatile is read: 27
XXX    times read thru a pointer: 3
XXX times a volatile is write: 21
XXX    times written thru a pointer: 14
XXX times a volatile is available for access: 289
XXX percentage of non-volatile access: 94.5

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 35
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 23
   depth: 1, occurrence: 7
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 20.4
XXX percentage an existing variable is used: 79.6
********************* end of statistics **********************/

