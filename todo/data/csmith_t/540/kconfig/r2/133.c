/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3963497852
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const int16_t  f0;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 4;
   int32_t  f1;
   const signed : 0;
   const signed f2 : 23;
   unsigned f3 : 28;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const struct S1  func_1(void);
inline static int8_t  func_5(uint8_t  p_6, int16_t  p_7, int32_t  p_8, struct S0  p_9, int32_t  p_10);
static const uint32_t  func_13(uint64_t  p_14, uint64_t  p_15);
inline static uint16_t  func_16(struct S1  p_17, uint32_t  p_18, uint16_t  p_19, int8_t  p_20);
static uint16_t  func_30(uint8_t  p_31, float  p_32, int8_t  p_33);
static const int32_t * func_53(uint16_t  p_54, int64_t  p_55, int16_t  p_56);
static const float  func_59(int32_t  p_60, uint32_t  p_61);
inline static int32_t * func_63(int8_t  p_64, int16_t  p_65, uint64_t  p_66);
static uint16_t  func_80(int32_t * p_81, int64_t  p_82, int16_t  p_83, struct S0  p_84);
inline static int32_t * func_85(int32_t * p_86, int64_t  p_87, int8_t  p_88, int32_t * p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S1  func_1(void)
{ /* block id: 0 */
    float l_3[7] = {0x4.AFA9B6p-93,(-0x1.2p-1),0x4.AFA9B6p-93,0x4.AFA9B6p-93,(-0x1.2p-1),0x4.AFA9B6p-93,0x4.AFA9B6p-93};
    int32_t l_4 = 0L;
    struct S1 l_21[3][9] = {{{0,-9L,-773,4721},{3,0L,-1178,4359},{1,-3L,1294,563},{3,0L,-1178,4359},{0,-9L,-773,4721},{1,0xA237F4A7L,-1389,6682},{0,-9L,-773,4721},{3,0L,-1178,4359},{1,-3L,1294,563}},{{3,1L,1084,13973},{3,1L,1084,13973},{2,0xD50C8576L,-1569,9772},{3,1L,1084,13973},{3,1L,1084,13973},{2,0xD50C8576L,-1569,9772},{3,1L,1084,13973},{3,1L,1084,13973},{2,0xD50C8576L,-1569,9772}},{{0,-9L,-773,4721},{3,0L,-1178,4359},{1,-3L,1294,563},{3,0L,-1178,4359},{0,-9L,-773,4721},{1,0xA237F4A7L,-1389,6682},{0,-9L,-773,4721},{3,0L,-1178,4359},{1,-3L,1294,563}}};
    const uint16_t l_34 = 0x0CE6L;
    int8_t l_35 = (-1L);
    struct S0 l_655[6][9][4] = {{{{0x2896L},{0xC132L},{0L},{0xC132L}},{{1L},{1L},{0xE2ABL},{-8L}},{{0L},{0L},{1L},{0L}},{{0x5D37L},{1L},{9L},{0xE2ABL}},{{0x5D37L},{1L},{-6L},{0x0274L}},{{7L},{0xE2ABL},{0L},{0L}},{{-1L},{-1L},{1L},{0xE2ABL}},{{0xE2ABL},{7L},{-6L},{1L}},{{1L},{0x5D37L},{0L},{-6L}}},{{{1L},{0x5D37L},{0x2896L},{1L}},{{0x5D37L},{7L},{1L},{0xE2ABL}},{{-6L},{-1L},{-6L},{0L}},{{1L},{0xE2ABL},{-8L},{0x0274L}},{{-1L},{1L},{-6L},{0xE2ABL}},{{1L},{1L},{-6L},{7L}},{{-1L},{0x5D37L},{-8L},{-2L}},{{1L},{-6L},{-6L},{1L}},{{-6L},{1L},{1L},{1L}}},{{{0x5D37L},{-1L},{0x2896L},{0x0274L}},{{1L},{1L},{0L},{0x0274L}},{{1L},{-1L},{-6L},{1L}},{{0xE2ABL},{1L},{1L},{1L}},{{-1L},{-6L},{0L},{-2L}},{{7L},{0x5D37L},{-6L},{7L}},{{0x5D37L},{1L},{9L},{0xE2ABL}},{{0x5D37L},{1L},{-6L},{0x0274L}},{{7L},{0xE2ABL},{0L},{0L}}},{{{-1L},{-1L},{1L},{0xE2ABL}},{{0xE2ABL},{7L},{-6L},{1L}},{{1L},{0x5D37L},{0L},{-6L}},{{1L},{0x5D37L},{0x2896L},{1L}},{{0x5D37L},{7L},{1L},{0xE2ABL}},{{-6L},{-1L},{-6L},{0L}},{{1L},{0xE2ABL},{-8L},{0x0274L}},{{-1L},{1L},{-6L},{0xE2ABL}},{{1L},{1L},{-6L},{7L}}},{{{-1L},{0x5D37L},{-8L},{-2L}},{{1L},{-6L},{-6L},{1L}},{{-6L},{1L},{1L},{1L}},{{0x5D37L},{-1L},{0x2896L},{0x0274L}},{{1L},{1L},{0L},{0x0274L}},{{1L},{-1L},{-6L},{1L}},{{0xE2ABL},{1L},{1L},{1L}},{{-1L},{-6L},{0L},{-2L}},{{7L},{0x5D37L},{-6L},{7L}}},{{{0x5D37L},{1L},{9L},{0xE2ABL}},{{0x5D37L},{1L},{-6L},{0x0274L}},{{7L},{0xE2ABL},{0L},{0L}},{{-1L},{-1L},{1L},{0xE2ABL}},{{0xE2ABL},{7L},{-6L},{1L}},{{1L},{0x5D37L},{0L},{9L}},{{-6L},{1L},{0xE2ABL},{-6L}},{{1L},{0x2896L},{0xC132L},{0L}},{{0L},{0xF385L},{0L},{1L}}}};
    uint32_t l_661 = 0x50A4F5C8L;
    int16_t l_662 = 1L;
    int i, j, k;
    l_662 = ((((safe_unary_minus_func_uint16_t_u(((l_4 < ((l_4 && func_5(l_4, l_4, (safe_div_func_uint32_t_u_u(func_13(l_4, (func_16(l_21[1][7], (safe_mod_func_uint64_t_u_u(((((0xCFEBL ^ (safe_add_func_int16_t_s_s(((((safe_lshift_func_int8_t_s_u((safe_add_func_int16_t_s_s(l_21[1][7].f3, func_30(l_21[1][7].f0, l_21[1][7].f0, l_21[1][7].f2))), l_21[1][7].f3)) >= l_4) <= l_21[1][7].f2) != 4L), l_34))) > l_21[1][7].f2) & l_34) ^ l_21[1][7].f0), l_21[1][7].f1)), l_35, l_21[1][7].f1) >= l_21[1][7].f2)), 0x4AC66E3EL)), l_655[2][6][0], l_4)) != l_21[1][7].f2)) & l_661))) ^ l_21[1][7].f3) >= 7UL) != l_21[1][7].f3);
    return l_21[0][4];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_5(uint8_t  p_6, int16_t  p_7, int32_t  p_8, struct S0  p_9, int32_t  p_10)
{ /* block id: 288 */
    int32_t l_657 = 0x1E05C9D0L;
    int32_t *l_656 = &l_657;
    int32_t **l_660 = &l_656;
    (*l_660) = func_85(l_656, (safe_mul_func_int16_t_s_s((*l_656), (*l_656))), p_8, &l_657);
    /* statement id: 289 */
    assert (l_656 == 0);
    return p_9.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_13(uint64_t  p_14, uint64_t  p_15)
{ /* block id: 285 */
    int32_t l_654 = 0x76455CEDL;
    int32_t *l_653 = &l_654;
    l_653 = l_653;
    return p_14;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_16(struct S1  p_17, uint32_t  p_18, uint16_t  p_19, int8_t  p_20)
{ /* block id: 3 */
    uint32_t l_38 = 0xF668CDE3L;
    int32_t *l_651 = (void*)0;
    int32_t **l_650 = &l_651;
    for (p_20 = (-26); (p_20 != (-4)); p_20++)
    { /* block id: 6 */
        int32_t l_49[9];
        int32_t *l_52 = &l_49[3];
        int i;
        for (i = 0; i < 9; i++)
            l_49[i] = 0x962DA72DL;
        (*l_52) = (func_30(p_17.f2, l_38, (safe_div_func_uint64_t_u_u((p_17.f0 >= p_18), (safe_rshift_func_uint16_t_u_s((safe_add_func_uint16_t_u_u(((((safe_unary_minus_func_int64_t_s(0L)) & func_30(p_17.f0, (safe_add_func_float_f_f(((+l_49[3]) >= (l_38 <= func_30((safe_mod_func_int16_t_s_s((l_49[6] ^ p_17.f3), p_17.f0)), p_17.f2, p_19))), p_17.f3)), p_20)) != 0x4837A000L) > l_49[3]), l_49[3])), 4))))) > l_49[3]);
        if (p_20)
            goto lbl_652;
        return p_17.f2;
    }
lbl_652:
    (*l_650) = func_53(l_38, l_38, p_17.f3);
    (*l_650) = (*l_650);
    (*l_650) = (*l_650);
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(uint8_t  p_31, float  p_32, int8_t  p_33)
{ /* block id: 1 */
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_53(uint16_t  p_54, int64_t  p_55, int16_t  p_56)
{ /* block id: 10 */
    uint8_t l_62 = 255UL;
    float l_286 = 0x4.A17552p-32;
    float *l_285 = &l_286;
    float **l_292 = &l_285;
    int32_t l_310 = 8L;
    const int32_t *l_309 = &l_310;
    const int32_t **l_308 = &l_309;
    const int32_t ***l_307 = &l_308;
    const int32_t ****l_306 = &l_307;
    int32_t *l_385 = &l_310;
    int32_t **l_384 = &l_385;
    int32_t ***l_383 = &l_384;
    uint8_t l_399[3][5][2] = {{{249UL,0x62L},{249UL,1UL},{0UL,0UL},{1UL,249UL},{0x62L,249UL}},{{1UL,0UL},{0UL,1UL},{249UL,0x62L},{249UL,1UL},{0UL,0UL}},{{1UL,249UL},{0x62L,249UL},{1UL,0UL},{0UL,1UL},{249UL,0x62L}}};
    float ** const *l_412 = &l_292;
    float ** const **l_411 = &l_412;
    const int32_t *l_455[8][9] = {{&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,(void*)0,&l_310,&l_310},{&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310},{&l_310,&l_310,(void*)0,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310},{&l_310,&l_310,(void*)0,&l_310,&l_310,&l_310,(void*)0,&l_310,&l_310},{&l_310,(void*)0,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310},{&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310},{&l_310,&l_310,&l_310,(void*)0,&l_310,&l_310,(void*)0,&l_310,&l_310},{&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310}};
    struct S1 *l_457 = (void*)0;
    int32_t ****l_461 = &l_383;
    float * const *l_507 = &l_285;
    float * const **l_506 = &l_507;
    float * const ***l_505[6][8] = {{&l_506,&l_506,(void*)0,&l_506,&l_506,&l_506,(void*)0,&l_506},{&l_506,&l_506,&l_506,(void*)0,(void*)0,&l_506,&l_506,&l_506},{&l_506,&l_506,&l_506,&l_506,&l_506,&l_506,&l_506,&l_506},{&l_506,&l_506,&l_506,&l_506,&l_506,&l_506,(void*)0,&l_506},{&l_506,&l_506,(void*)0,&l_506,&l_506,&l_506,&l_506,&l_506},{&l_506,&l_506,&l_506,&l_506,&l_506,&l_506,&l_506,&l_506}};
    struct S1 *l_516[2];
    const int32_t *l_589 = (void*)0;
    int8_t l_632 = 0x63L;
    const int32_t *l_637 = (void*)0;
    struct S0 l_646 = {0x7A5AL};
    const struct S0 *l_645[8][2][3] = {{{&l_646,&l_646,&l_646},{&l_646,(void*)0,&l_646}},{{&l_646,&l_646,&l_646},{(void*)0,&l_646,&l_646}},{{&l_646,&l_646,&l_646},{&l_646,&l_646,&l_646}},{{&l_646,&l_646,(void*)0},{&l_646,&l_646,&l_646}},{{(void*)0,(void*)0,&l_646},{(void*)0,&l_646,&l_646}},{{&l_646,&l_646,&l_646},{&l_646,&l_646,&l_646}},{{&l_646,&l_646,&l_646},{&l_646,&l_646,&l_646}},{{(void*)0,&l_646,&l_646},{&l_646,&l_646,(void*)0}}};
    struct S0 *l_648[8][9] = {{&l_646,(void*)0,&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,(void*)0},{&l_646,(void*)0,&l_646,&l_646,(void*)0,(void*)0,&l_646,&l_646,(void*)0},{&l_646,&l_646,&l_646,&l_646,(void*)0,&l_646,&l_646,&l_646,(void*)0},{&l_646,&l_646,(void*)0,(void*)0,&l_646,&l_646,&l_646,(void*)0,&l_646},{&l_646,&l_646,&l_646,(void*)0,&l_646,&l_646,(void*)0,(void*)0,&l_646},{&l_646,(void*)0,&l_646,(void*)0,&l_646,&l_646,&l_646,&l_646,&l_646},{&l_646,(void*)0,&l_646,(void*)0,(void*)0,&l_646,&l_646,&l_646,&l_646},{&l_646,&l_646,&l_646,&l_646,&l_646,&l_646,(void*)0,&l_646,&l_646}};
    struct S0 **l_647 = &l_648[6][7];
    const int32_t *l_649 = (void*)0;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_516[i] = (void*)0;
    (*l_285) = (safe_sub_func_float_f_f(func_59(l_62, p_54), (safe_mul_func_float_f_f(p_56, (((((p_54 <= p_56) != p_54) == ((p_54 == l_62) == 0x6.Dp+1)) != l_62) == 0x8.Cp-1)))));
    for (p_55 = 0; (p_55 == 15); p_55++)
    { /* block id: 108 */
        int32_t l_290 = 0xC655BC20L;
        int32_t *l_289 = &l_290;
        float **l_291 = &l_285;
        uint32_t l_303 = 4UL;
        int32_t **l_333 = &l_289;
        int32_t ** const *l_332 = &l_333;
        (*l_289) = (p_54 | p_54);
        l_292 = l_291;
        for (l_62 = 0; (l_62 > 50); ++l_62)
        { /* block id: 113 */
            int32_t l_321 = (-4L);
            int32_t *l_352 = &l_321;
            for (l_290 = (-19); (l_290 >= (-19)); l_290 = safe_add_func_int16_t_s_s(l_290, 5))
            { /* block id: 116 */
                int8_t l_297[3][9][7] = {{{0x60L,0L,4L,0xEFL,0xA5L,0xA5L,0xEFL},{0xA5L,1L,0xA5L,1L,0xDBL,(-4L),0x1FL},{0L,2L,0xCFL,0xE8L,4L,0x60L,(-4L)},{0L,0xEFL,1L,0xC8L,0xE8L,(-4L),0xA9L},{(-3L),0x48L,(-10L),0x4CL,(-1L),0xA5L,(-2L)},{0L,0x1FL,0xE8L,(-1L),1L,0xC8L,0L},{0xA2L,0x60L,0L,2L,8L,1L,0xCFL},{0x1FL,4L,(-10L),2L,(-6L),0L,0x4CL},{1L,(-5L),1L,(-1L),0x60L,1L,8L}},{{0x3BL,0x6DL,0x4CL,0x4CL,0x6DL,0x3BL,1L},{0x00L,0xB0L,0xF0L,0xC8L,0xCFL,(-1L),0xDBL},{1L,0xF0L,0xB1L,0xE8L,(-1L),0xACL,0L},{0x4CL,0xB0L,(-5L),1L,0L,0xBFL,0x00L},{0x96L,0x6DL,0x55L,0xEFL,1L,0x4CL,0xB1L},{1L,0xA2L,0x00L,(-1L),1L,0L,0xE8L},{(-1L),(-1L),6L,0x55L,0x48L,0x4CL,0xE8L},{0xA9L,0x1FL,0L,0xEFL,0xE8L,(-1L),0xCFL},{2L,0xACL,(-6L),0x60L,0x00L,0x60L,(-6L)}},{{0xB0L,0xB0L,0x1FL,0xACL,0xC8L,0x96L,1L},{1L,4L,(-4L),0L,0xB1L,(-1L),0L},{(-1L),0xB1L,0x5DL,1L,0xC8L,0L,3L},{(-5L),1L,0L,0xBFL,0x00L,0L,0x60L},{(-1L),8L,0xDAL,0x00L,0xE8L,(-2L),0L},{0xCFL,0x00L,0L,(-4L),0x48L,0xEFL,(-1L)},{0L,0L,0L,0xCFL,1L,(-6L),8L},{0x4CL,(-1L),0xDAL,(-10L),(-4L),0xC8L,0xC8L},{(-2L),0xF0L,0L,0xF0L,(-2L),2L,0x96L}}};
                float ***l_298 = &l_292;
                struct S0 l_320 = {0x521EL};
                struct S0 *l_319 = &l_320;
                struct S0 **l_318 = &l_319;
                int32_t l_322 = (-1L);
                int16_t l_350 = 3L;
                int i, j, k;
                (*l_285) = l_297[0][0][6];
                (*l_298) = &l_285;
            }
        }
        (*l_289) = ((***l_332) || ((*l_309) >= (((((*l_289) ^ (safe_sub_func_uint32_t_u_u((safe_mod_func_int32_t_s_s(p_56, p_55)), ((safe_add_func_int8_t_s_s((**l_333), (1UL == (0x8607F98CL == ((*l_309) >= (**l_308)))))) > 0xABB7212277E28792LL)))) | (**l_308)) & p_56) >= 0x89DB1A4CL)));
    }
    if ((safe_rshift_func_int16_t_s_s((safe_add_func_uint8_t_u_u((safe_rshift_func_int16_t_s_u(((0x3C43EEADL || (safe_add_func_uint32_t_u_u((3UL != ((**l_308) == 3UL)), (****l_306)))) < ((2L & (safe_mul_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((p_54 ^ (safe_add_func_int16_t_s_s((*l_309), ((l_383 == (void*)0) == (**l_308))))), (**l_308))), (**l_384)))) >= 0x8FL)), 8)), (*l_385))), (***l_307))))
    { /* block id: 153 */
        float ***l_390 = &l_292;
        int32_t l_398 = (-1L);
        int32_t **l_404 = &l_385;
        const int32_t *l_449 = &l_398;
        const int32_t *l_450 = &l_398;
        int32_t ****l_460 = (void*)0;
        struct S0 l_492 = {0x3F23L};
        const struct S0 *l_491 = &l_492;
        struct S1 l_514 = {1,0x8965A8C6L,163,9249};
        struct S1 *l_513 = &l_514;
        const int32_t *l_599 = &l_310;
        const int32_t *l_602 = &l_398;
        const int32_t *l_605[8] = {&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310,&l_310};
        int i;
        (*l_285) = ((safe_div_func_float_f_f((safe_mul_func_float_f_f((((l_390 != l_390) == (0x4.D9DC93p-29 != (-0x1.7p-1))) >= ((safe_div_func_float_f_f((safe_mul_func_float_f_f((!(0xA.525E5Ep+33 < ((p_55 <= ((safe_sub_func_float_f_f((***l_307), (p_54 == p_54))) >= l_398)) < l_398))), 0xE.6D0770p+77)), 0x6.Fp+1)) == p_56)), l_398)), 0xF.B00E2Fp-73)) == (*l_385));
        (**l_383) = &l_398;
        /* statement id: 155 */
        assert (l_385 == &l_398);
        for (p_56 = 0; (p_56 <= 1); p_56 += 1)
        { /* block id: 158 */
            float ****l_413 = &l_390;
            int32_t l_414 = 0xC1EE8A46L;
            uint32_t l_431 = 0x5C99ABEBL;
            int32_t * const *l_462 = &l_385;
            const int16_t l_493 = 0x7668L;
        }
        for (l_62 = 1; (l_62 <= 5); l_62 += 1)
        { /* block id: 243 */
            struct S1 **l_515[1][3];
            int32_t l_536[7] = {0xBC2087D7L,(-3L),0xBC2087D7L,0xBC2087D7L,(-3L),0xBC2087D7L,0xBC2087D7L};
            float *l_555[2];
            uint32_t l_598 = 0x20BA6A2CL;
            const int32_t *l_600[7];
            const int32_t *l_601 = &l_398;
            const int32_t *l_603 = &l_536[5];
            const int32_t *l_606 = (void*)0;
            int i, j;
            for (i = 0; i < 1; i++)
            {
                for (j = 0; j < 3; j++)
                    l_515[i][j] = &l_513;
            }
            for (i = 0; i < 2; i++)
                l_555[i] = &l_286;
            for (i = 0; i < 7; i++)
                l_600[i] = &l_536[1];
            l_516[0] = l_513;
            l_513 = (void*)0;
            /* statement id: 245 */
            assert (l_513 == 0);
            for (p_56 = 5; (p_56 >= 1); p_56 -= 1)
            { /* block id: 248 */
                const int32_t l_527 = 0xCF93ED21L;
                struct S1 *l_547 = (void*)0;
                const int32_t *l_604 = &l_527;
                int i, j;
            }
        }
        /* facts after for loop */
        assert (l_513 == 0 || l_513 == &l_514);
        //assert (l_516[0] == &l_514 || l_516[0] == 0);
    }
    else
    { /* block id: 266 */
        int32_t l_627 = (-7L);
        int32_t l_633 = 0x30E68A2BL;
        uint8_t l_634[4][5][2] = {{{0xE7L,253UL},{0x5AL,1UL},{0UL,1UL},{0x5AL,253UL},{0xE7L,0x66L}},{{0xF7L,0x75L},{0x4DL,0x4DL},{0x1BL,0x8AL},{253UL,0UL},{0x59L,2UL}},{{0x8AL,0x59L},{0x96L,0xBFL},{0x96L,0x59L},{0x8AL,2UL},{0x59L,0UL}},{{253UL,0x8AL},{0x1BL,0x4DL},{0x4DL,0x75L},{0xF7L,0x66L},{0xE7L,253UL}}};
        float * const ** const l_643[7][4] = {{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0}};
        int i, j, k;
        for (p_55 = 26; (p_55 < 0); p_55--)
        { /* block id: 269 */
            int16_t l_631 = (-7L);
            const int32_t *l_635 = &l_633;
            if (((safe_div_func_uint16_t_u_u(p_56, (p_56 & ((safe_div_func_uint16_t_u_u((safe_add_func_int64_t_s_s(p_55, (safe_sub_func_int8_t_s_s((safe_add_func_uint16_t_u_u(((!(((~(safe_div_func_int8_t_s_s((safe_sub_func_uint32_t_u_u(p_54, 0x26FBAD27L)), (safe_sub_func_int16_t_s_s(l_627, ((p_54 == p_56) & ((safe_add_func_int32_t_s_s(((~((((((l_631 < 8UL) > 0x688DL) <= l_627) != l_632) && (*l_309)) >= 0x15L)) < p_55), l_627)) >= l_633))))))) == 0L) < l_633)) & l_631), (****l_461))), l_634[3][0][0])))), (-1L))) & l_631)))) != l_627))
            { /* block id: 270 */
                const int32_t *l_636 = &l_310;
                return l_637;
                /* statement id: 271 */
                //assert (func_53_rv == 0);
            }
            else
            { /* block id: 272 */
                float ***l_642 = &l_292;
                const int32_t l_644 = (-5L);
                (*l_285) = ((p_55 > (safe_sub_func_float_f_f(((((safe_mul_func_float_f_f(p_54, (l_642 == l_643[1][0]))) >= ((void*)0 == l_642)) > ((void*)0 == &l_643[1][0])) < l_644), 0x0.20E009p+42))) >= 0xE.062805p+14);
            }
            if (p_56)
                continue;
        }
    }
    /* facts after branching */
    //assert (l_385 == &l_310 || l_385 == dangling);
    //assert (l_516[0] == dangling || l_516[0] == 0);
    (*l_647) = l_645[5][1][2];
    return l_649;
    /* statement id: 279 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_59(int32_t  p_60, uint32_t  p_61)
{ /* block id: 11 */
    int32_t l_68[10];
    int32_t *l_67 = &l_68[0];
    int32_t **l_280[5][5][3] = {{{(void*)0,&l_67,(void*)0},{&l_67,&l_67,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,&l_67,&l_67},{(void*)0,&l_67,(void*)0}},{{&l_67,&l_67,(void*)0},{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0}},{{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67}},{{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0}},{{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67},{(void*)0,&l_67,(void*)0},{&l_67,(void*)0,&l_67}}};
    int32_t *l_281[2];
    const float l_282 = 0x2.9p+1;
    int i, j, k;
    for (i = 0; i < 10; i++)
        l_68[i] = (-2L);
    for (i = 0; i < 2; i++)
        l_281[i] = &l_68[5];
    l_281[1] = func_63(p_60, func_30(((l_67 != &p_60) == 0x330CL), (((-0x1.Cp+1) >= (+(safe_div_func_float_f_f((-((void*)0 != &p_60)), (&l_68[9] != &p_60))))) > (-0x2.4p+1)), (*l_67)), (*l_67));
    /* statement id: 103 */
    //assert (l_281[0] == 0 || (l_281[0] >= &l_68[0] && l_281[0] <= &l_68[9]));
    return l_282;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_63(int8_t  p_64, int16_t  p_65, uint64_t  p_66)
{ /* block id: 12 */
    int32_t *l_75 = (void*)0;
    int32_t l_90 = (-4L);
    int32_t l_91 = 3L;
    struct S0 l_101 = {1L};
    struct S0 *l_100 = &l_101;
    struct S0 **l_99 = &l_100;
    int32_t l_134 = (-3L);
    int32_t **l_138 = (void*)0;
    int32_t ***l_137 = &l_138;
    int32_t ****l_136 = &l_137;
    int32_t *****l_135 = &l_136;
    int32_t *l_190 = &l_90;
    int32_t l_216 = 1L;
    float l_228 = 0x1.Ep+1;
    float *l_227 = &l_228;
    float **l_226 = &l_227;
    int32_t **l_269[3][5][1] = {{{&l_75},{&l_75},{(void*)0},{&l_75},{(void*)0}},{{&l_75},{&l_75},{(void*)0},{&l_75},{(void*)0}},{{&l_75},{&l_75},{(void*)0},{&l_75},{(void*)0}}};
    int32_t *l_270 = (void*)0;
    int32_t *l_271 = &l_216;
    int32_t *l_272[4][9] = {{&l_216,&l_216,&l_216,&l_216,&l_216,&l_216,&l_216,&l_216,&l_216},{(void*)0,&l_90,&l_134,&l_90,(void*)0,(void*)0,&l_90,&l_134,&l_90},{&l_216,&l_216,&l_134,&l_134,&l_216,&l_216,&l_216,&l_134,&l_134},{(void*)0,(void*)0,&l_90,&l_134,&l_90,(void*)0,(void*)0,&l_90,&l_134}};
    int32_t *l_273[2];
    int32_t *l_274 = &l_134;
    int32_t *l_275 = &l_90;
    int32_t *l_276 = &l_134;
    int32_t *l_277 = &l_216;
    int32_t *l_278[9][9][3] = {{{&l_134,&l_134,&l_134},{&l_134,&l_134,&l_216},{&l_216,&l_134,&l_90},{&l_90,&l_90,&l_216},{&l_216,(void*)0,&l_90},{&l_90,&l_134,&l_90},{&l_216,&l_216,&l_90},{&l_134,&l_216,&l_90},{&l_134,&l_90,(void*)0}},{{&l_134,&l_134,&l_90},{&l_90,&l_216,&l_216},{&l_90,&l_134,&l_134},{&l_134,&l_134,&l_216},{&l_134,&l_134,&l_216},{&l_90,&l_134,&l_216},{&l_216,&l_134,&l_90},{&l_216,&l_90,&l_216},{&l_216,&l_134,&l_216}},{{&l_90,&l_90,&l_216},{&l_134,&l_134,&l_134},{&l_216,&l_134,&l_216},{&l_134,&l_134,&l_90},{&l_134,&l_216,(void*)0},{&l_134,&l_90,&l_90},{(void*)0,&l_216,&l_90},{(void*)0,&l_134,&l_90},{&l_134,(void*)0,&l_90}},{{(void*)0,&l_216,&l_90},{&l_134,&l_216,&l_90},{(void*)0,&l_134,&l_90},{&l_216,(void*)0,&l_134},{&l_216,(void*)0,&l_216},{&l_216,&l_90,&l_90},{(void*)0,&l_134,&l_90},{&l_134,&l_216,(void*)0},{&l_216,&l_134,&l_216}},{{&l_216,&l_134,&l_90},{&l_90,&l_134,(void*)0},{&l_216,&l_90,&l_90},{(void*)0,&l_134,&l_134},{&l_216,&l_216,(void*)0},{&l_90,(void*)0,&l_216},{&l_216,&l_134,&l_90},{&l_216,&l_216,&l_134},{&l_134,(void*)0,&l_134}},{{(void*)0,&l_90,&l_134},{&l_216,&l_134,&l_134},{&l_216,&l_216,&l_90},{&l_216,&l_216,&l_90},{(void*)0,&l_134,&l_216},{&l_134,&l_134,&l_216},{&l_90,(void*)0,&l_216},{&l_134,&l_216,&l_90},{&l_134,&l_216,&l_90}},{{&l_216,&l_216,&l_134},{&l_90,&l_216,&l_134},{&l_216,&l_216,&l_134},{&l_134,&l_90,&l_134},{&l_216,&l_90,&l_90},{&l_134,&l_90,&l_216},{&l_90,&l_134,(void*)0},{&l_216,&l_134,&l_134},{&l_90,&l_216,&l_90}},{{&l_216,&l_134,(void*)0},{&l_90,&l_134,&l_90},{&l_90,&l_90,&l_216},{&l_134,&l_90,(void*)0},{&l_216,&l_90,&l_90},{&l_216,&l_216,&l_90},{&l_216,&l_216,&l_216},{&l_134,&l_216,&l_134},{&l_134,&l_216,&l_90}},{{&l_90,&l_216,&l_90},{(void*)0,(void*)0,&l_90},{&l_216,&l_134,&l_134},{(void*)0,&l_134,&l_216},{&l_90,&l_216,(void*)0},{&l_134,&l_216,(void*)0},{&l_134,&l_134,&l_216},{&l_216,&l_90,&l_216},{&l_216,(void*)0,&l_90}}};
    int32_t *l_279 = (void*)0;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_273[i] = &l_216;
    if (((0x6858L >= (safe_sub_func_int32_t_s_s((l_75 != (void*)0), (safe_sub_func_int64_t_s_s((safe_lshift_func_uint8_t_u_u((func_80(func_85(l_75, l_90, l_91, &l_90), (safe_mod_func_uint16_t_u_u(((void*)0 == l_99), 0x2937L)), p_64, (**l_99)) | p_65), 6)), p_66))))) != p_64))
    { /* block id: 18 */
        int32_t *l_103[9];
        int64_t l_115 = 0x9E5CE90A86934388LL;
        int i;
        for (i = 0; i < 9; i++)
            l_103[i] = &l_90;
        l_75 = l_103[7];
        /* statement id: 19 */
        assert (l_75 == &l_90);
        (*l_75) = (p_65 == (((p_64 > (~((safe_lshift_func_uint16_t_u_u(((safe_mod_func_int8_t_s_s((safe_mul_func_uint16_t_u_u(p_64, p_66)), (*l_75))) < ((safe_sub_func_int32_t_s_s((p_65 | ((&l_90 == (void*)0) == (l_115 | p_64))), (*l_75))) && 0L)), p_65)) && 0x63B3A314L))) | 0xBD1E8AE5L) <= p_65));
    }
    else
    { /* block id: 21 */
        uint8_t l_116 = 255UL;
        int32_t *l_117 = (void*)0;
        int32_t **l_118[9][3][9] = {{{&l_117,(void*)0,&l_117,&l_75,&l_117,(void*)0,&l_117,&l_75,&l_117},{&l_75,&l_117,&l_117,&l_117,&l_117,&l_75,(void*)0,&l_117,&l_117},{(void*)0,&l_117,&l_117,&l_117,(void*)0,&l_75,&l_117,&l_75,(void*)0}},{{(void*)0,&l_117,&l_117,(void*)0,&l_117,&l_117,(void*)0,&l_75,&l_117},{&l_117,&l_75,&l_117,(void*)0,&l_117,&l_75,&l_117,(void*)0,&l_117},{&l_117,&l_117,&l_117,&l_117,&l_117,&l_75,&l_117,(void*)0,(void*)0}},{{(void*)0,(void*)0,&l_117,(void*)0,(void*)0,(void*)0,&l_117,(void*)0,(void*)0},{&l_117,&l_117,&l_117,(void*)0,&l_117,(void*)0,&l_117,&l_75,&l_75},{&l_117,(void*)0,&l_117,&l_117,&l_117,(void*)0,&l_117,&l_117,&l_117}},{{&l_117,&l_117,&l_117,&l_117,(void*)0,&l_75,&l_117,&l_117,&l_75},{(void*)0,&l_75,&l_117,&l_75,(void*)0,&l_117,&l_117,&l_117,(void*)0},{&l_117,&l_117,&l_117,(void*)0,&l_75,&l_117,&l_117,&l_75,(void*)0}},{{&l_117,&l_117,&l_117,(void*)0,&l_117,&l_117,&l_117,(void*)0,&l_117},{(void*)0,&l_117,(void*)0,&l_117,&l_75,&l_75,&l_117,(void*)0,&l_117},{(void*)0,(void*)0,&l_117,(void*)0,(void*)0,(void*)0,&l_117,(void*)0,(void*)0}},{{&l_75,&l_117,(void*)0,(void*)0,(void*)0,(void*)0,&l_117,&l_75,&l_117},{&l_117,(void*)0,&l_117,&l_75,&l_117,(void*)0,&l_117,&l_75,&l_117},{&l_75,&l_117,&l_117,&l_117,&l_117,&l_75,(void*)0,&l_117,&l_117}},{{(void*)0,&l_117,&l_117,&l_117,(void*)0,&l_75,&l_117,&l_75,(void*)0},{(void*)0,&l_117,&l_117,(void*)0,&l_117,&l_117,(void*)0,&l_75,&l_117},{&l_117,&l_75,&l_117,(void*)0,&l_117,&l_75,&l_117,(void*)0,&l_117}},{{&l_117,&l_117,&l_117,&l_117,&l_117,&l_75,&l_117,(void*)0,(void*)0},{(void*)0,(void*)0,&l_117,(void*)0,(void*)0,(void*)0,&l_117,(void*)0,(void*)0},{&l_117,&l_117,&l_117,(void*)0,&l_117,(void*)0,&l_117,&l_75,&l_75}},{{&l_117,(void*)0,&l_117,&l_117,&l_117,(void*)0,&l_117,&l_117,&l_117},{&l_117,&l_117,&l_117,&l_117,(void*)0,&l_75,&l_117,&l_117,&l_75},{(void*)0,&l_75,&l_117,&l_75,(void*)0,&l_117,&l_117,&l_117,(void*)0}}};
        int32_t *l_119 = &l_90;
        int32_t *****l_139 = (void*)0;
        struct S0 **l_162 = &l_100;
        int32_t *l_191 = &l_134;
        int32_t *l_192 = &l_90;
        float l_225 = 0x8.5954F1p-72;
        float *l_224 = &l_225;
        float ** const l_223 = &l_224;
        int32_t *l_236 = &l_216;
        int i, j, k;
        l_119 = func_85(&l_90, l_116, p_66, l_117);
        /* statement id: 22 */
        assert (l_119 == 0);
        for (p_64 = 2; (p_64 >= 0); p_64 -= 1)
        { /* block id: 25 */
            int32_t l_120 = 2L;
            int32_t *l_141 = &l_134;
            int32_t *l_142 = &l_90;
            for (p_65 = 0; p_65 < 9; p_65 += 1)
            {
                for (l_116 = 0; l_116 < 3; l_116 += 1)
                {
                    for (l_91 = 0; l_91 < 9; l_91 += 1)
                    {
                        l_118[p_65][l_116][l_91] = &l_119;
                    }
                }
            }
            for (l_90 = 0; (l_90 <= 2); l_90 += 1)
            { /* block id: 29 */
                uint32_t l_121 = 0x88AFD611L;
                int32_t l_122 = 0L;
                int32_t **l_125 = (void*)0;
                int32_t ***l_129[7][7] = {{&l_118[3][1][5],&l_118[3][1][5],&l_118[7][2][1],&l_118[6][2][7],&l_118[7][2][1],&l_118[3][1][5],&l_118[3][1][5]},{(void*)0,&l_125,&l_118[3][1][5],&l_125,(void*)0,(void*)0,&l_125},{(void*)0,&l_118[8][2][4],(void*)0,&l_118[7][2][1],&l_118[7][2][1],(void*)0,&l_118[8][2][4]},{&l_125,&l_125,&l_118[3][1][5],&l_118[3][1][5],&l_125,&l_125,&l_125},{(void*)0,&l_118[7][2][1],&l_118[7][2][1],(void*)0,&l_118[8][2][4],(void*)0,&l_118[7][2][1]},{(void*)0,(void*)0,&l_125,&l_118[3][1][5],&l_125,(void*)0,(void*)0},{&l_118[3][1][5],&l_118[7][2][1],&l_118[6][2][7],&l_118[7][2][1],&l_118[3][1][5],&l_118[3][1][5],&l_118[7][2][1]}};
                const struct S0 ** const l_133 = (void*)0;
                int i, j;
                if (p_65)
                { /* block id: 30 */
                    l_122 = (l_120 > l_121);
                    l_122 = p_64;
                }
                else
                { /* block id: 33 */
                    int32_t l_126[5][2][1];
                    int32_t *l_132 = &l_90;
                    int i, j, k;
                    for (i = 0; i < 5; i++)
                    {
                        for (j = 0; j < 2; j++)
                        {
                            for (k = 0; k < 1; k++)
                                l_126[i][j][k] = (-1L);
                        }
                    }
                    l_126[4][0][0] = (safe_rshift_func_int8_t_s_u((l_125 == l_125), 1));
                    if (p_64)
                        continue;
                    for (l_91 = 0; (l_91 <= 2); l_91 += 1)
                    { /* block id: 38 */
                        int32_t ***l_128[3];
                        int32_t ****l_127[8][2] = {{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]},{&l_128[2],&l_128[2]}};
                        int i, j, k;
                        for (i = 0; i < 3; i++)
                            l_128[i] = &l_118[(l_90 + 4)][l_90][(l_90 + 3)];
                        l_75 = &l_122;
                        /* statement id: 39 */
                        assert (l_75 == &l_122);
                        l_129[0][0] = &l_118[l_91][l_90][(l_91 + 4)];
                    }
                    /* facts after for loop */
                    //assert (l_75 == &l_122 || l_75 == dangling || l_75 == 0);
                    l_134 = (((0x10E3L <= (safe_div_func_int16_t_s_s(p_64, 1L))) && (((l_132 == l_132) & (*l_132)) > (l_91 > p_65))) ^ ((void*)0 != l_133));
                }
                /* facts after branching */
                //assert (l_75 == &l_122 || l_75 == dangling || l_75 == 0);
                for (l_121 = 0; (l_121 <= 2); l_121 += 1)
                { /* block id: 46 */
                    int32_t *l_140[1];
                    int i;
                    for (i = 0; i < 1; i++)
                        l_140[i] = (void*)0;
                    l_135 = (void*)0;
                    /* statement id: 47 */
                    assert (l_135 == 0);
                    for (l_116 = 0; (l_116 <= 6); l_116 += 1)
                    { /* block id: 50 */
                        l_139 = &l_136;
                        /* statement id: 51 */
                        assert (l_139 == &l_136);
                        return l_140[0];
                        /* statement id: 52 */
                        //assert (func_63_rv == 0);
                    }
                }
                if (p_64)
                { /* block id: 55 */
                    int32_t *l_143 = (void*)0;
                    return l_143;
                    /* statement id: 56 */
                    //assert (func_63_rv == 0);
                }
                else
                { /* block id: 57 */
                    int32_t *l_144 = &l_134;
                    l_144 = l_142;
                    /* statement id: 58 */
                    assert (l_144 == &l_90);
                    l_141 = l_144;
                    /* statement id: 59 */
                    assert (l_141 == &l_90);
                    if ((*l_144))
                        continue;
                    //assert (l_75 == dangling || l_75 == 0);
                }
                /* facts after branching */
                assert (l_141 == &l_90);
                for (p_66 = 0; (p_66 <= 2); p_66 += 1)
                { /* block id: 64 */
                    uint64_t l_151 = 2UL;
                    int16_t l_161 = 0xE1D9L;
                    int32_t *l_187 = &l_90;
                    int32_t *l_189 = &l_134;
                    for (l_121 = 0; (l_121 <= 2); l_121 += 1)
                    { /* block id: 67 */
                        const float l_158[6][4] = {{0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44},{0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44},{0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44},{0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44},{0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44},{0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44,0xF.9284F4p+44}};
                        float l_160[2];
                        float *l_159 = &l_160[0];
                        int32_t l_182 = 0x67EAC4BFL;
                        int32_t *l_188[10] = {&l_182,&l_90,&l_182,&l_90,&l_182,&l_90,&l_182,&l_90,&l_182,&l_90};
                        int32_t *l_193[6];
                        int i, j;
                        for (i = 0; i < 2; i++)
                            l_160[i] = 0x8.0p-1;
                        for (i = 0; i < 6; i++)
                            l_193[i] = (void*)0;
                        (*l_159) = ((safe_add_func_float_f_f(((p_65 <= ((*l_142) != p_65)) == (0x1.Fp-1 != (safe_mul_func_float_f_f((safe_div_func_float_f_f((((-0x1.9p-1) < (l_151 >= l_151)) >= (safe_sub_func_float_f_f((((safe_mul_func_float_f_f(((safe_sub_func_float_f_f(l_151, ((p_64 != l_158[1][3]) >= 0x5.E3EA3Ap+62))) <= 0x2.ABC8BBp-2), 0xF.FAD472p-50)) <= p_65) > 0xC.6FF5C8p-64), 0x3.05D29Ap+92))), p_64)), p_64)))), 0x7.BCC4B3p-4)) == p_66);
                        (*l_159) = (l_161 > (0x1.FCE81Ap+5 >= ((l_162 != l_162) >= 0x1.5p+1)));
                        (*l_159) = (-(((safe_sub_func_float_f_f((safe_div_func_float_f_f((safe_add_func_float_f_f(0xE.D011C8p+6, (safe_mul_func_float_f_f((safe_mul_func_float_f_f((((p_64 < (safe_sub_func_float_f_f((safe_mul_func_float_f_f((safe_div_func_float_f_f(((safe_mul_func_float_f_f(l_182, (safe_add_func_float_f_f(p_64, (safe_sub_func_float_f_f(p_64, (((void*)0 == &l_182) < ((l_182 <= 0xD.7CA1C3p+9) <= p_66)))))))) < 0x1.6p+1), 0x0.0p-1)), p_64)), p_64))) > p_65) == p_64), p_65)), l_161)))), p_64)), p_66)) != p_66) < p_66));
                        return l_193[4];
                        /* statement id: 71 */
                        //assert (func_63_rv == 0);
                    }
                    (*l_189) = (65533UL < (p_65 < (p_66 != ((l_189 == l_141) <= ((p_65 >= (safe_mul_func_uint16_t_u_u((safe_div_func_uint64_t_u_u((safe_add_func_uint32_t_u_u(0xDEEFCC7DL, ((safe_sub_func_uint32_t_u_u((p_65 && (((safe_sub_func_int32_t_s_s(p_65, p_65)) != p_65) < 0x1D02B38FL)), 0UL)) > (*l_142)))), (*l_190))), 1UL))) < (*l_192))))));
                }
            }
            /* facts after for loop */
            assert (l_141 == &l_90 || l_141 == &l_134);
        }
        /* facts after for loop */
        //assert (l_75 == dangling || l_75 == 0);
        //assert (l_118[0][0][0] == &l_119 || l_118[0][0][0] == &l_75 || l_118[0][0][0] == 0 || l_118[0][0][0] == &l_117);
        assert (l_135 == 0 || l_135 == &l_136);
        if (((safe_mod_func_int32_t_s_s((1UL <= (*l_192)), (safe_mod_func_int32_t_s_s((*l_190), (safe_div_func_int8_t_s_s((safe_sub_func_int8_t_s_s(((safe_rshift_func_int8_t_s_u(((*l_191) & ((l_139 == (void*)0) & (safe_sub_func_uint32_t_u_u(l_216, (safe_mul_func_uint8_t_u_u((p_64 != (safe_div_func_uint16_t_u_u(0x5626L, p_65))), (*l_191))))))), p_65)) || 0xA4D68258L), (*l_190))), (*l_190))))))) ^ p_65))
        { /* block id: 77 */
            int32_t *l_221 = &l_90;
            int32_t *l_222 = &l_90;
            l_222 = l_221;
            l_226 = l_223;
            /* statement id: 79 */
            assert (l_226 == &l_224);
            l_190 = l_222;
        }
        else
        { /* block id: 81 */
            int64_t l_249 = 0x30CF4673FFDFA387LL;
            for (p_65 = (-5); (p_65 <= (-22)); p_65 = safe_sub_func_uint8_t_u_u(p_65, 2))
            { /* block id: 84 */
                float ***l_233 = (void*)0;
                int32_t l_235 = (-1L);
                int32_t *l_237[2];
                int i;
                for (i = 0; i < 2; i++)
                    l_237[i] = (void*)0;
                for (l_116 = 0; (l_116 > 45); l_116++)
                { /* block id: 87 */
                    float ****l_234 = &l_233;
                    (*l_234) = l_233;
                }
                (*l_190) = ((((void*)0 != (**l_136)) <= p_66) == l_235);
                l_237[0] = l_236;
                /* statement id: 91 */
                //assert (l_237[0] == &l_216 || l_237[0] == 0);
                if (p_64)
                    break;
            }
            for (p_66 = 0; (p_66 != 12); p_66++)
            { /* block id: 96 */
                uint16_t l_244 = 65535UL;
                float **l_248 = &l_227;
                uint16_t l_268 = 1UL;
                (*l_190) = (safe_mul_func_int8_t_s_s((safe_lshift_func_uint16_t_u_u((((((void*)0 == l_162) == l_244) == (safe_sub_func_int16_t_s_s(((~p_64) >= (&l_227 == l_248)), l_249))) ^ (safe_div_func_uint64_t_u_u((safe_mul_func_uint8_t_u_u((safe_div_func_uint8_t_u_u((safe_add_func_int16_t_s_s((safe_add_func_uint16_t_u_u((((safe_lshift_func_int8_t_s_u((safe_mod_func_int32_t_s_s((safe_rshift_func_int8_t_s_s((p_65 || ((safe_div_func_uint32_t_u_u(p_64, 4294967295UL)) <= 0xBDCF2520F901617ELL)), 4)), 1UL)), p_64)) < 0x87E7BF935BA4CF42LL) || 1L), 0x0BB3L)), 1L)), (*l_192))), l_249)), p_65))), 14)), l_268));
            }
        }
        /* facts after branching */
        assert (l_226 == &l_227 || l_226 == &l_224);
    }
    /* facts after branching */
    //assert (l_75 == dangling || l_75 == 0 || l_75 == &l_90);
    assert (l_135 == 0 || l_135 == &l_136);
    //assert (l_226 == &l_227 || l_226 == dangling);
    l_270 = &l_134;
    /* statement id: 101 */
    assert (l_270 == &l_134);
    return l_279;
    /* statement id: 102 */
    //assert (func_63_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_80(int32_t * p_81, int64_t  p_82, int16_t  p_83, struct S0  p_84)
{ /* block id: 16 */
    uint64_t l_102 = 8UL;
    return l_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_85(int32_t * p_86, int64_t  p_87, int8_t  p_88, int32_t * p_89)
{ /* block id: 13 */
    struct S0 *l_92 = (void*)0;
    const struct S0 l_95 = {0x569BL};
    const struct S0 *l_94 = &l_95;
    const struct S0 **l_93 = &l_94;
    int32_t *l_96 = (void*)0;
    (*l_93) = l_92;
    /* statement id: 14 */
    assert (l_94 == 0);
    return l_96;
    /* statement id: 15 */
    //assert (func_85_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 169
   depth: 1, occurrence: 2
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 7
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 2
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 3
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 21

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 20
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 155

XXX times a variable address is taken: 353
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 13
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 48
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 1008

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 134
   level: 2, occurrence: 53
   level: 3, occurrence: 31
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 80
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 38.1
XXX average alias set size: 1.45

XXX times a non-volatile is read: 620
XXX times a non-volatile is write: 177
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 91
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 17
   depth: 2, occurrence: 13
   depth: 3, occurrence: 13
   depth: 4, occurrence: 15
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 10.9
XXX percentage an existing variable is used: 89.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

