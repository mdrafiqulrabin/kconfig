/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1542122223
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 22;
   unsigned f1 : 21;
   unsigned f2 : 4;
   signed f3 : 31;
   signed f4 : 20;
   uint32_t  f5;
   unsigned f6 : 8;
   unsigned f7 : 27;
   signed f8 : 18;
};

union U1 {
   uint32_t  f0;
};

union U2 {
   int16_t  f0;
   int32_t  f1;
   int16_t  f2;
};

union U3 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_3 = 3;
static struct S0 g_40 = {203,1396,0,-12793,59,0U,15,5417,-354};
static uint32_t g_52 = 0U;
static union U3 g_72 = {0x70C68704};
static union U1 g_88 = {0x9ABD1A96};
static int32_t g_141 = (-1);
static union U2 g_189 = {1};
static struct S0 g_203 = {1157,1307,1,-20039,754,8U,4,3181,-451};
static int32_t g_255 = 0;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_27(void);
static struct S0  func_34(uint32_t  p_35, struct S0  p_36, int16_t  p_37, int16_t  p_38, int16_t  p_39);
static int16_t  func_42(int16_t  p_43);
static uint32_t  func_44(int32_t  p_45, int16_t  p_46, uint32_t  p_47, uint32_t  p_48, uint32_t  p_49);
static int32_t  func_65(union U2  p_66, uint32_t  p_67, uint32_t  p_68, union U3  p_69);
static int32_t  func_80(int32_t  p_81, struct S0  p_82, uint32_t  p_83);
static uint32_t  func_85(union U1  p_86, int32_t  p_87);
static union U2  func_89(union U2  p_90, int32_t  p_91, int32_t  p_92);
static union U2  func_93(union U1  p_94, uint16_t  p_95);
static int32_t  func_100(struct S0  p_101, union U1  p_102, struct S0  p_103, uint32_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_40 g_72 g_72.f0 g_88 g_52 g_141 g_88.f0 g_189 g_189.f0 g_203.f8 g_203.f3 g_203.f0 g_203.f1 g_203.f4 g_189.f2 g_203.f6 g_203.f2 g_255 g_203.f5 g_203
 * writes: g_52 g_72.f0 g_141 g_189.f0 g_203 g_88.f0 g_189.f1 g_255 g_40.f3 g_40
 */
static struct S0  func_27(void)
{ /* block id: 36 */
    uint32_t l_28 = 0xDF29855E;
    int32_t l_32 = 1;
    struct S0 l_33 = {1106,1142,3,163,313,0xB9C6FEC1,11,2525,-454};
    if (l_28)
    { /* block id: 37 */
        uint32_t l_31 = 5U;
        l_32 = ((int32_t)l_31 - (int32_t)g_3);
        return l_33;
    }
    else
    { /* block id: 40 */
        int32_t l_41 = 9;
        struct S0 l_311 = {334,1163,3,38828,53,0x08AB6B9B,4,804,-194};
        g_40 = func_34(g_3, g_40, g_40.f0, g_40.f1, ((((-1) <= (l_41 && func_42(l_41))) & ((uint32_t)l_41 % (uint32_t)l_33.f0)) <= (-2)));
        l_41 = (3 | ((0 == g_189.f0) == (((uint16_t)0x0C15 >> (uint16_t)(0x0AFB29A5 && (0 >= g_203.f8))) || l_41)));
        g_72.f0 = ((int16_t)__builtin_parity(((int16_t)(func_80(l_41, l_311, l_33.f1) != (func_44(__builtin_clzll(g_40.f0), (g_255 & l_33.f1), l_32, l_311.f6, l_311.f6) <= l_311.f8)) << (int16_t)g_40.f7)) << (int16_t)l_33.f7);
    }
    g_40 = g_203;
    return l_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_203.f1 g_203
 * writes: g_40.f3
 */
static struct S0  func_34(uint32_t  p_35, struct S0  p_36, int16_t  p_37, int16_t  p_38, int16_t  p_39)
{ /* block id: 195 */
    struct S0 l_304 = {847,1182,1,-8514,-784,1U,5,5189,-46};
    for (p_35 = 0; (p_35 == 14); p_35 += 1)
    { /* block id: 198 */
        p_36 = l_304;
    }
    g_40.f3 = g_203.f1;
    p_36 = g_203;
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f6 g_40.f3 g_40.f0 g_40.f2 g_40.f1 g_40.f7 g_72 g_72.f0 g_88 g_40 g_3 g_52 g_141 g_88.f0 g_189 g_189.f0 g_203.f8 g_203.f3 g_203.f0 g_203.f1 g_203.f4 g_189.f2 g_203.f6 g_203.f2 g_255 g_203.f5 g_203
 * writes: g_52 g_72.f0 g_141 g_189.f0 g_203 g_88.f0 g_189.f1 g_255
 */
static int16_t  func_42(int16_t  p_43)
{ /* block id: 41 */
    int32_t l_50 = 9;
    union U2 l_70 = {-1};
    struct S0 l_84 = {1139,191,1,34801,21,0U,3,6344,-133};
    union U1 l_259 = {4294967295U};
    int16_t l_289 = 1;
    if (((func_44(p_43, g_40.f6, l_50, g_40.f3, g_40.f0) >= ((uint32_t)(0x70207789 || (((int16_t)((int16_t)((uint16_t)l_50 % (uint16_t)((int32_t)((int32_t)(g_40.f1 & 0xA9BE) + (int32_t)g_40.f7) - (int32_t)0xEF9EED16)) << (int16_t)l_50) + (int16_t)g_40.f2) != l_50)) % (uint32_t)g_40.f2)) > g_40.f2))
    { /* block id: 46 */
        uint32_t l_71 = 0U;
        struct S0 l_78 = {1193,1332,1,14550,727,8U,0,8586,-355};
        union U1 l_96 = {0x46B6D1E2};
        struct S0 l_258 = {224,1098,0,-11929,549,0x3E30775B,5,6374,-394};
        l_70.f1 = func_65(l_70, g_40.f1, l_71, g_72);
        for (g_72.f0 = 0; (g_72.f0 <= (-20)); g_72.f0 -= 9)
        { /* block id: 53 */
            uint32_t l_77 = 0x6A56D104;
            struct S0 l_79 = {644,3,1,21857,650,0U,7,621,-38};
            union U3 l_215 = {0x6513EDB8};
            l_77 = 8;
            l_79 = l_78;
            if (p_43)
                break;
            l_78.f3 = func_80(p_43, l_84, func_85(g_88, (6 ^ (func_65(func_89(func_93(l_96, p_43), g_40.f1, g_40.f5), g_40.f1, p_43, l_215) < p_43))));
        }
        g_203 = l_258;
        l_258 = l_258;
    }
    else
    { /* block id: 156 */
        union U2 l_262 = {-2};
        int16_t l_263 = 0;
        union U3 l_264 = {1};
        struct S0 l_286 = {555,1171,2,-38303,170,0xE8A0454B,4,5355,435};
        uint32_t l_290 = 0U;
        l_70.f1 = func_100(l_84, l_259, l_84, l_70.f0);
        l_262.f1 = ((l_84.f4 || (__builtin_popcountl((((-10) || (((int16_t)g_203.f5 - (int16_t)func_65(l_262, l_263, g_203.f0, l_264)) < p_43)) && 0x6CD4D35E)) != g_40.f0)) >= p_43);
        if (g_203.f8)
        { /* block id: 159 */
            struct S0 l_268 = {1927,1195,2,42233,-815,0U,0,1470,374};
            union U1 l_282 = {0x25903AD1};
            for (l_262.f0 = 0; (l_262.f0 == 13); l_262.f0 += 6)
            { /* block id: 162 */
                struct S0 l_267 = {1265,1024,3,-44491,-726,0xB936B78C,0,3008,-31};
                l_268 = l_267;
                g_203.f4 = (((g_203.f0 <= ((((uint32_t)__builtin_popcountl(p_43) + (uint32_t)(((((uint16_t)((uint32_t)(func_44(p_43, p_43, p_43, ((((uint16_t)(!(((int32_t)l_264.f0 - (int32_t)(((int32_t)p_43 - (int32_t)p_43) || (-10))) <= (-10))) % (uint16_t)g_3) != l_84.f8) <= g_3), p_43) >= g_203.f2) + (uint32_t)l_268.f7) % (uint16_t)g_203.f5) <= l_268.f8) || g_255) == 1U)) <= l_70.f2) ^ 7U)) < 0x10D4) > l_268.f5);
                g_189.f1 = ((func_85(l_282, p_43) & l_84.f3) | l_268.f8);
            }
        }
        else
        { /* block id: 167 */
            struct S0 l_285 = {780,508,0,14517,793,0U,2,5739,441};
            for (g_141 = 0; (g_141 <= 29); g_141 += 1)
            { /* block id: 170 */
                uint32_t l_299 = 1U;
                l_286 = l_285;
                for (l_70.f0 = 25; (l_70.f0 >= (-9)); l_70.f0 -= 1)
                { /* block id: 174 */
                    uint32_t l_291 = 9U;
                    int32_t l_292 = 1;
                    if (p_43)
                    { /* block id: 175 */
                        g_203 = l_84;
                        g_203 = g_203;
                        if (p_43)
                            continue;
                        return p_43;
                    }
                    else
                    { /* block id: 180 */
                        g_255 = l_289;
                        if (g_52)
                            break;
                        l_290 = g_40.f4;
                    }
                    g_203.f3 = 0xC0104E8E;
                    g_189.f1 = l_289;
                    l_292 = l_291;
                }
                l_285.f8 = (g_189.f2 < ((uint16_t)(((((uint16_t)(g_40.f0 <= ((uint16_t)((l_84.f1 <= 0) && l_299) - (uint16_t)(p_43 && l_285.f6))) << (uint16_t)15) && g_203.f8) ^ p_43) != l_286.f6) % (uint16_t)g_141));
            }
        }
        g_203 = g_40;
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f2
 * writes: g_52
 */
static uint32_t  func_44(int32_t  p_45, int16_t  p_46, uint32_t  p_47, uint32_t  p_48, uint32_t  p_49)
{ /* block id: 42 */
    uint16_t l_51 = 65535U;
    l_51 = (0U > 0U);
    g_52 = g_40.f2;
    return l_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_65(union U2  p_66, uint32_t  p_67, uint32_t  p_68, union U3  p_69)
{ /* block id: 47 */
    struct S0 l_73 = {72,1276,0,32508,-288,0x96A2A5EA,8,4,432};
    struct S0 l_74 = {1685,281,2,33182,569,0x868B20CE,9,1859,-379};
    l_74 = l_73;
    return l_74.f7;
}


/* ------------------------------------------ */
/* 
 * reads : g_141 g_189.f2 g_203.f6 g_40.f1 g_40.f2 g_203.f2 g_40.f6 g_40.f4 g_203.f4 g_255 g_3
 * writes: g_141 g_189.f1
 */
static int32_t  func_80(int32_t  p_81, struct S0  p_82, uint32_t  p_83)
{ /* block id: 142 */
    uint32_t l_244 = 9U;
    int32_t l_256 = (-1);
    uint32_t l_257 = 0x2D7B22F3;
    for (g_141 = 10; (g_141 <= (-29)); g_141 -= 9)
    { /* block id: 145 */
        uint16_t l_228 = 0xB650;
        uint16_t l_241 = 0x46F2;
        int32_t l_245 = 1;
        p_81 = ((int32_t)l_228 - (int32_t)(g_189.f2 ^ (__builtin_popcountll(((((((((((4294967295U <= (g_203.f6 >= (((g_189.f2 < ((int16_t)((uint16_t)l_228 >> (uint16_t)(((uint16_t)((int16_t)(((~(((~(p_82.f4 && l_241)) | ((uint32_t)p_82.f6 + (uint32_t)p_82.f7)) | p_81)) > 0x2B62957E) || l_244) >> (int16_t)2) >> (uint16_t)0) ^ g_40.f1)) >> (int16_t)1)) | 0xF8ACBF38) > l_241))) == g_40.f2) <= g_203.f2) ^ 4) & l_244) & p_82.f1) < 1) == p_82.f6) | g_40.f6) | 9)) != (-7))));
        l_245 = (-1);
        g_189.f1 = (((uint16_t)(p_82.f0 | 3) >> (uint16_t)g_40.f1) ^ ((g_40.f4 | (((uint16_t)(~g_40.f1) >> (uint16_t)6) & ((l_244 >= (0x2DA18387 && (((int16_t)(p_82.f0 <= __builtin_ffsll(((uint16_t)((__builtin_ffsl(p_82.f5) > p_82.f2) > 0) << (uint16_t)g_203.f4))) << (int16_t)6) & g_255))) | 0x80E3))) || 0xB88BA211));
    }
    l_256 = (__builtin_clzll(g_203.f2) & 8);
    return l_257;
}


/* ------------------------------------------ */
/* 
 * reads : g_88.f0 g_40 g_203.f1 g_203.f4
 * writes: g_88.f0 g_203.f3
 */
static uint32_t  func_85(union U1  p_86, int32_t  p_87)
{ /* block id: 128 */
    struct S0 l_218 = {1884,451,0,-23724,664,0xE3D15342,9,7310,-113};
    struct S0 l_222 = {1673,190,1,3603,798,0x1D2C571B,15,3763,-101};
    for (g_88.f0 = 0; (g_88.f0 >= 33); g_88.f0 += 7)
    { /* block id: 131 */
        struct S0 l_223 = {266,802,2,-29991,-690,1U,8,2091,-286};
        l_218 = l_218;
        for (l_218.f5 = (-20); (l_218.f5 <= 11); l_218.f5 += 1)
        { /* block id: 135 */
            struct S0 l_221 = {1876,812,1,2090,812,0xD93C69FD,8,4872,-176};
            l_222 = l_221;
            l_223 = g_40;
        }
    }
    g_203.f3 = g_203.f1;
    return g_203.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_203.f8 g_3 g_189.f0 g_203.f3 g_203.f0 g_40.f1
 * writes:
 */
static union U2  func_89(union U2  p_90, int32_t  p_91, int32_t  p_92)
{ /* block id: 114 */
    uint16_t l_205 = 0xB477;
    struct S0 l_206 = {64,601,3,-17597,-71,1U,6,11314,94};
    uint16_t l_209 = 0xDEB3;
    p_91 = l_205;
    if (l_205)
    { /* block id: 116 */
        l_206 = l_206;
        p_92 = (l_206.f1 == ((7U > (l_206.f8 ^ (-1))) & (__builtin_parityll(g_203.f8) != ((int32_t)(__builtin_ctzll(g_189.f0) <= (l_206.f7 | l_209)) - (int32_t)0x814105F5))));
    }
    else
    { /* block id: 119 */
        union U2 l_212 = {0xF413};
        struct S0 l_213 = {1332,1071,0,-1204,396,0xBF210CA2,10,2690,-447};
        struct S0 l_214 = {832,737,2,-5400,-83,4294967294U,11,1140,295};
        if ((g_203.f3 == ((((uint16_t)g_203.f0 + (uint16_t)p_92) && (0 | __builtin_ffsll((l_206.f5 | __builtin_ctzl(g_40.f1))))) == ((p_90.f0 & (-1)) > 5))))
        { /* block id: 120 */
            return l_212;
        }
        else
        { /* block id: 122 */
            l_214 = l_213;
            l_213 = l_206;
        }
    }
    return p_90;
}


/* ------------------------------------------ */
/* 
 * reads : g_40 g_3 g_72 g_52 g_141 g_88.f0 g_189 g_189.f0 g_72.f0
 * writes: g_52 g_141 g_189.f0 g_203
 */
static union U2  func_93(union U1  p_94, uint16_t  p_95)
{ /* block id: 57 */
    int32_t l_99 = 0;
    int32_t l_170 = 0x9961058A;
    struct S0 l_201 = {310,1191,1,3870,-220,4294967295U,2,3243,-174};
    struct S0 l_202 = {1677,180,1,32410,-605,4294967288U,14,10908,510};
    union U2 l_204 = {0x3835};
    for (p_95 = 2; (p_95 != 5); p_95 += 1)
    { /* block id: 60 */
        struct S0 l_105 = {1591,369,1,-562,883,0x2BDD4A0C,5,4001,204};
        if (l_99)
        { /* block id: 61 */
            int16_t l_171 = 0x0D52;
            if (p_94.f0)
                break;
            l_105.f3 = func_44(func_100(g_40, p_94, l_105, (g_3 <= ((uint32_t)((int16_t)l_99 << (int16_t)l_99) + (uint32_t)__builtin_ffsl(l_105.f0)))), l_170, l_99, l_171, p_94.f0);
        }
        else
        { /* block id: 91 */
            uint32_t l_190 = 0xA2A8B54C;
            g_141 = (((int16_t)l_99 >> (int16_t)2) && ((((-5) & 0U) <= p_95) != func_44(g_52, l_99, p_94.f0, p_94.f0, l_99)));
            for (g_52 = (-16); (g_52 != 40); g_52 += 1)
            { /* block id: 95 */
                union U3 l_191 = {-3};
                for (g_141 = 0; (g_141 > (-21)); g_141 -= 1)
                { /* block id: 98 */
                    l_170 = g_40.f7;
                    l_191.f0 = ((uint16_t)g_40.f7 << (uint16_t)((int32_t)(((p_95 <= p_95) && ((int16_t)((int32_t)(-9) % (int32_t)((int32_t)l_99 % (int32_t)g_3)) << (int16_t)7)) | (((-(uint32_t)((((func_65(g_189, p_94.f0, (l_190 | p_94.f0), l_191) & 0xBF25) == 0x55B7) >= p_94.f0) > g_40.f5)) != 4294967286U) && p_94.f0)) + (int32_t)1));
                }
                g_141 = l_190;
            }
            for (g_189.f0 = 1; (g_189.f0 < 24); g_189.f0 += 1)
            { /* block id: 106 */
                uint32_t l_198 = 0xAA19CEE7;
                g_141 = (((int32_t)(__builtin_ctz(g_40.f3) < 0xFD3F) % (int32_t)g_40.f3) > ((g_72.f0 > (((int16_t)l_198 - (int16_t)0xB067) == ((uint16_t)__builtin_parityll(g_40.f6) >> (uint16_t)0))) & p_94.f0));
            }
        }
    }
    l_201 = l_201;
    g_203 = l_202;
    return l_204;
}


/* ------------------------------------------ */
/* 
 * reads : g_72 g_40.f0 g_40.f8 g_40.f2 g_40.f6 g_40.f3 g_52 g_3 g_40.f4 g_40 g_141 g_88.f0
 * writes: g_52 g_141
 */
static int32_t  func_100(struct S0  p_101, union U1  p_102, struct S0  p_103, uint32_t  p_104)
{ /* block id: 63 */
    struct S0 l_110 = {1007,1342,1,7304,-294,1U,3,1826,-160};
    uint32_t l_134 = 4294967294U;
    uint16_t l_135 = 0x937C;
    l_110 = p_101;
    for (l_110.f5 = 0; (l_110.f5 >= 53); l_110.f5 += 1)
    { /* block id: 67 */
        uint16_t l_113 = 0x78CE;
        uint16_t l_115 = 0x9873;
        union U2 l_118 = {1};
        uint32_t l_127 = 5U;
        p_101.f4 = (l_113 & ((-(int16_t)l_115) ^ ((int32_t)((p_104 == p_103.f3) >= func_65(l_118, (p_103.f6 > ((uint16_t)l_110.f4 - (uint16_t)(((int16_t)0x91ED << (int16_t)3) & ((uint16_t)((uint32_t)(3 == 0x879D) - (uint32_t)0x13A5848C) << (uint16_t)6)))), l_127, g_72)) % (int32_t)p_103.f8)));
        if (((l_110.f8 != ((l_110.f7 < (p_101.f4 || 0x195FD4EE)) || ((int16_t)__builtin_ctzll(((g_40.f0 > ((!((uint16_t)func_44((-(int16_t)(-8)), (l_134 & l_135), l_127, g_40.f8, l_118.f2) >> (uint16_t)11)) | 0x9A07)) <= g_40.f6)) - (int16_t)1U))) | 0x9BD9))
        { /* block id: 69 */
            int32_t l_154 = 0x523B59FD;
            for (l_115 = 0; (l_115 < 34); l_115 += 1)
            { /* block id: 72 */
                for (l_127 = 0; (l_127 == 51); l_127 += 1)
                { /* block id: 75 */
                    uint32_t l_140 = 0x77858FB2;
                    g_141 = (l_140 && g_40.f3);
                }
            }
            if (p_103.f3)
                break;
            g_141 = (((int16_t)(((int32_t)((int16_t)g_52 >> (int16_t)(((int16_t)l_118.f0 >> (int16_t)4) == (!((int16_t)(g_40.f0 >= l_110.f7) << (int16_t)3)))) % (int32_t)(-(int32_t)l_110.f5)) != (__builtin_parityll(l_154) & ((g_40.f4 | l_127) & 0x5A20))) << (int16_t)l_110.f0) > l_110.f8);
        }
        else
        { /* block id: 81 */
            struct S0 l_155 = {768,747,3,40536,399,4294967291U,11,7268,224};
            l_155 = g_40;
            l_110.f3 = (5 == ((int16_t)((uint32_t)(((0xC90B || ((uint16_t)((int16_t)g_40.f4 + (int16_t)func_44(((((uint32_t)((int16_t)g_40.f2 % (int16_t)g_40.f7) - (uint32_t)((g_141 <= ((((int16_t)__builtin_ia32_crc32qi(p_103.f4, (l_118.f0 != (0xB41D ^ 0x7F66))) << (int16_t)p_103.f4) ^ 8U) ^ p_102.f0)) | 0)) >= l_155.f3) != p_103.f3), p_101.f5, p_101.f0, p_103.f2, p_103.f3)) % (uint16_t)0x2C03)) ^ p_103.f1) && g_88.f0) % (uint32_t)l_135) >> (int16_t)l_115));
            g_141 = g_40.f2;
            p_101.f4 = 0xBB2FC288;
        }
    }
    p_103.f3 = g_40.f0;
    return p_101.f5;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_40.f0, "g_40.f0", print_hash_value);
    transparent_crc(g_40.f1, "g_40.f1", print_hash_value);
    transparent_crc(g_40.f2, "g_40.f2", print_hash_value);
    transparent_crc(g_40.f3, "g_40.f3", print_hash_value);
    transparent_crc(g_40.f4, "g_40.f4", print_hash_value);
    transparent_crc(g_40.f5, "g_40.f5", print_hash_value);
    transparent_crc(g_40.f6, "g_40.f6", print_hash_value);
    transparent_crc(g_40.f7, "g_40.f7", print_hash_value);
    transparent_crc(g_40.f8, "g_40.f8", print_hash_value);
    transparent_crc(g_52, "g_52", print_hash_value);
    transparent_crc(g_72.f0, "g_72.f0", print_hash_value);
    transparent_crc(g_88.f0, "g_88.f0", print_hash_value);
    transparent_crc(g_141, "g_141", print_hash_value);
    transparent_crc(g_189.f0, "g_189.f0", print_hash_value);
    transparent_crc(g_189.f2, "g_189.f2", print_hash_value);
    transparent_crc(g_203.f0, "g_203.f0", print_hash_value);
    transparent_crc(g_203.f1, "g_203.f1", print_hash_value);
    transparent_crc(g_203.f2, "g_203.f2", print_hash_value);
    transparent_crc(g_203.f3, "g_203.f3", print_hash_value);
    transparent_crc(g_203.f4, "g_203.f4", print_hash_value);
    transparent_crc(g_203.f5, "g_203.f5", print_hash_value);
    transparent_crc(g_203.f6, "g_203.f6", print_hash_value);
    transparent_crc(g_203.f7, "g_203.f7", print_hash_value);
    transparent_crc(g_203.f8, "g_203.f8", print_hash_value);
    transparent_crc(g_255, "g_255", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 58
   depth: 1, occurrence: 27
XXX total union variables: 14

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 27
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 23
XXX times a bitfields struct on RHS: 32
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 106

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 5, occurrence: 3
   depth: 8, occurrence: 1
   depth: 11, occurrence: 4
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 318
XXX times a non-volatile is write: 77
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 103
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 25
   depth: 2, occurrence: 23
   depth: 3, occurrence: 10
   depth: 4, occurrence: 7
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 23.2
XXX percentage an existing variable is used: 76.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

