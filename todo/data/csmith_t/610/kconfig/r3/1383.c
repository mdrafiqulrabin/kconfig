/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3040710536
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 18;
   signed f1 : 31;
   int32_t  f2;
   signed f3 : 29;
   uint8_t  f4;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 26;
   unsigned f1 : 8;
   signed f2 : 6;
   signed f3 : 7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static struct S0  func_2(int32_t  p_3, int16_t  p_4, struct S1  p_5, uint32_t  p_6, uint8_t  p_7);
static struct S1  func_13(int32_t  p_14, int32_t  p_15, uint32_t  p_16);
static int32_t  func_17(int32_t  p_18);
static int32_t  func_20(uint32_t  p_21, int16_t  p_22, uint32_t  p_23);
static uint32_t  func_31(uint16_t  p_32);
static int16_t  func_35(uint16_t  p_36, int32_t  p_37, int32_t  p_38);
static int32_t  func_40(uint8_t  p_41, uint16_t  p_42);
static int32_t  func_49(int32_t  p_50);
static uint32_t  func_55(int16_t  p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_8 = 0x0785;
    struct S0 l_351 = {362,26050,1,-10962,0U};
    l_351 = func_2(l_8, ((int16_t)l_8 % (int16_t)(l_8 & ((-1) != l_8))), func_13(func_17(l_8), l_8, (l_8 != l_8)), l_8, l_8);
    return l_351.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_2(int32_t  p_3, int16_t  p_4, struct S1  p_5, uint32_t  p_6, uint8_t  p_7)
{ /* block id: 76 */
    struct S1 l_266 = {2714,5,-2,-1};
    int16_t l_279 = 0x30FC;
    uint8_t l_282 = 1U;
    struct S0 l_291 = {495,-12991,0x5F48D630,2346,251U};
    l_266 = p_5;
    for (p_3 = (-9); (p_3 <= (-4)); p_3 += 9)
    { /* block id: 80 */
        int32_t l_287 = 0x48867B80;
        struct S0 l_309 = {314,-46254,0xF131FA9A,13488,0xF7};
        if (p_5.f3)
        { /* block id: 81 */
            int32_t l_280 = 1;
            p_5.f3 = l_266.f2;
            p_5.f2 = ((((((int16_t)((((int16_t)(((((0x8AA5 == ((int32_t)((int16_t)((((p_4 | (p_4 < ((((uint16_t)(((l_279 | p_7) > l_280) < (-(uint32_t)(l_282 >= ((l_280 == ((uint16_t)(((uint16_t)5U << (uint16_t)p_7) > l_266.f2) - (uint16_t)0xF02D)) || l_280)))) << (uint16_t)2) & l_280) <= l_280))) == l_287) | l_266.f0) ^ 1U) - (int16_t)p_3) + (int32_t)p_5.f0)) > p_3) <= p_5.f2) ^ 0x7FDC) & p_5.f3) << (int16_t)2) && l_266.f3) ^ 4U) + (int16_t)l_280) | p_5.f2) != 0x4755) || l_287) >= 4);
            if (l_266.f1)
            { /* block id: 84 */
                int32_t l_290 = 0xC8587F00;
                p_5.f2 = ((uint32_t)(l_280 || l_290) - (uint32_t)1U);
            }
            else
            { /* block id: 86 */
                int32_t l_294 = 0x608C1F7B;
                l_291 = l_291;
                p_5.f3 = (0x4A16 ^ (((int16_t)((l_280 | (l_294 || (((p_6 != ((p_6 == (((int16_t)((uint32_t)(0x4ED3E9A5 ^ ((uint16_t)((uint16_t)(((((int16_t)(l_294 || ((int32_t)((((uint16_t)(0x691EA250 <= (((((p_6 == p_4) & (-3)) | p_5.f3) > 0x26DC) >= p_3)) << (uint16_t)4) || 0xDA7B3351) > 0x60C7) % (int32_t)0x1339926B)) + (int16_t)l_287) >= p_7) > p_6) && l_266.f3) - (uint16_t)l_287) + (uint16_t)65526U)) + (uint32_t)0xF5B64537) >> (int16_t)p_7) || 0)) <= l_279)) >= p_5.f0) == 0x5AF1))) || l_280) % (int16_t)l_294) > p_4));
                if (p_5.f1)
                    break;
            }
        }
        else
        { /* block id: 91 */
            int32_t l_341 = 1;
            l_309 = l_309;
            if (p_7)
            { /* block id: 93 */
                uint32_t l_321 = 4294967295U;
                l_291.f2 = (((-1) <= ((int16_t)(!((uint32_t)0x2C1E3334 + (uint32_t)((p_4 > (0xB948781A && ((((int16_t)((int16_t)((int16_t)1 >> (int16_t)l_291.f4) << (int16_t)2) >> (int16_t)l_309.f0) <= l_321) ^ ((int16_t)7 - (int16_t)p_7)))) != p_4))) >> (int16_t)l_282)) && 4294967291U);
                if (p_6)
                { /* block id: 95 */
                    uint32_t l_329 = 0xF9DBF970;
                    p_5.f2 = (((uint16_t)(-(int16_t)((((((uint32_t)((((l_329 <= (((((uint16_t)((uint32_t)((int32_t)0xB34CF7A4 + (int32_t)l_279) - (uint32_t)((~((int32_t)(((uint16_t)((3U > l_341) > 1U) % (uint16_t)((int32_t)(l_329 & 0x7F00) - (int32_t)0x306CED18)) < p_5.f2) % (int32_t)p_5.f1)) <= 0x1537)) + (uint16_t)1) == l_266.f0) | p_5.f1) >= 3U)) < l_266.f3) < p_5.f0) < p_5.f0) % (uint32_t)0x2EC37060) <= p_4) && l_321) == 1U) == p_5.f1)) >> (uint16_t)p_4) & (-1));
                    if (p_5.f2)
                        break;
                }
                else
                { /* block id: 98 */
                    struct S0 l_346 = {129,-4391,-1,22130,0U};
                    for (l_341 = 14; (l_341 > 5); l_341 -= 1)
                    { /* block id: 101 */
                        struct S0 l_347 = {369,20513,0xD9155A29,19315,252U};
                        l_347 = l_346;
                    }
                }
                l_266.f2 = ((9U ^ 0x19F3) == ((int16_t)l_341 >> (int16_t)11));
                l_266 = p_5;
            }
            else
            { /* block id: 107 */
                struct S0 l_350 = {94,-22461,-4,-5125,0x62};
                l_309 = l_350;
                if (l_266.f0)
                    break;
                if (l_266.f2)
                    continue;
            }
        }
        l_291.f2 = (-8);
        l_291 = l_309;
    }
    return l_291;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_13(int32_t  p_14, int32_t  p_15, uint32_t  p_16)
{ /* block id: 62 */
    uint32_t l_244 = 1U;
    int32_t l_248 = (-7);
    struct S1 l_265 = {1888,6,5,-1};
    for (p_14 = 0; (p_14 > 18); p_14 += 4)
    { /* block id: 65 */
        int32_t l_228 = 0xCEE369AD;
        int32_t l_246 = 1;
        int32_t l_247 = 0x58026D62;
        l_248 = ((((uint16_t)(0xE5BDD16F < ((int32_t)l_228 - (int32_t)4294967295U)) - (uint16_t)((uint16_t)p_15 % (uint16_t)((((uint16_t)(0x9E51 >= p_14) << (uint16_t)(((int16_t)((uint16_t)(((((int16_t)((int32_t)(!((((((uint16_t)l_244 + (uint16_t)(~(((((p_15 | ((l_228 && 1U) > p_16)) & l_246) & 0xFBE2) != l_228) == l_244))) && l_244) || p_15) != 9U) ^ 0xCE2010D2)) + (int32_t)0x3D6EBB9B) + (int16_t)p_15) || l_228) != p_16) >= l_228) + (uint16_t)l_228) >> (int16_t)10) ^ (-1))) > l_246) && l_244))) || p_14) > l_247);
        for (p_16 = 0; (p_16 >= 48); p_16 += 1)
        { /* block id: 69 */
            l_248 = 1;
        }
        l_248 = (~((l_247 <= ((int32_t)l_248 - (int32_t)(((uint16_t)(l_244 < ((0 != (~(0x3C2E || (((((int16_t)((int32_t)(0x1317 > p_15) - (int32_t)((uint16_t)((int16_t)l_248 - (int16_t)0x8493) + (uint16_t)0U)) << (int16_t)11) >= p_15) || p_14) ^ p_15)))) >= l_248)) << (uint16_t)7) <= p_15))) != p_15));
        l_248 = 0xEC935B34;
    }
    return l_265;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_17(int32_t  p_18)
{ /* block id: 1 */
    struct S0 l_19 = {475,32253,0x56CD8339,19212,0U};
    uint32_t l_39 = 1U;
    l_19 = l_19;
    if (l_19.f4)
    { /* block id: 3 */
        uint16_t l_30 = 0x9F3C;
        p_18 = func_20((((int32_t)(((((((uint16_t)((int16_t)p_18 << (int16_t)((l_30 && 0x4A10) && (p_18 && (func_31(((((int16_t)0x0735 >> (int16_t)((func_35(l_39, func_40(((int16_t)(((((uint16_t)(((0xD863 | ((uint16_t)(p_18 || p_18) >> (uint16_t)9)) || l_30) | (-1)) >> (uint16_t)1) || p_18) > 0x0AC8) <= l_19.f4) >> (int16_t)l_19.f4), p_18), p_18) && l_19.f0) ^ 1U)) > p_18) < l_30)) >= 1U)))) >> (uint16_t)l_30) >= l_30) != 0xEC7099BD) >= l_30) | l_19.f4) != p_18) % (int32_t)l_19.f3) != 0xA25DF1CA), l_30, p_18);
    }
    else
    { /* block id: 58 */
        struct S0 l_221 = {161,-22496,-1,17799,0x97};
        l_221 = l_19;
    }
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_20(uint32_t  p_21, int16_t  p_22, uint32_t  p_23)
{ /* block id: 47 */
    struct S0 l_173 = {483,-29564,0,-18843,4U};
    struct S1 l_174 = {534,8,0,1};
    int32_t l_191 = (-1);
    int32_t l_211 = 0x07BCC874;
    for (p_22 = 0; (p_22 < (-13)); p_22 -= 1)
    { /* block id: 50 */
        uint16_t l_175 = 1U;
        int32_t l_196 = 0xFF75342E;
        int16_t l_201 = 0x1CC2;
        uint32_t l_220 = 8U;
        l_173 = l_173;
        l_174 = l_174;
        l_196 = ((l_175 == (((uint16_t)((int16_t)(1 >= ((uint16_t)0x0105 % (uint16_t)((uint32_t)((int32_t)(p_22 ^ l_173.f4) - (int32_t)((!l_175) > (((uint16_t)(l_191 > (l_173.f1 < ((((((((uint16_t)p_23 - (uint16_t)p_23) != p_21) == l_173.f4) ^ 1) ^ l_173.f4) || (-8)) > 0U))) % (uint16_t)65535U) && 0U))) - (uint32_t)p_22))) - (int16_t)p_21) >> (uint16_t)11) > p_21)) == p_21);
        l_174.f2 = (p_23 >= ((int16_t)(~((!(l_201 != ((((~((uint16_t)((((((((0x5BA27C46 && ((((int16_t)0x9405 - (int16_t)0xAB9B) != (l_196 > ((uint32_t)((uint16_t)((l_211 != (((int16_t)((uint32_t)((int16_t)l_175 >> (int16_t)5) - (uint32_t)(((int32_t)l_211 - (int32_t)p_23) < l_173.f4)) >> (int16_t)l_174.f0) > p_22)) && 0xC18C) + (uint16_t)p_23) + (uint32_t)l_174.f1))) < (-5))) <= 4U) == p_22) < l_175) | l_220) > l_173.f2) >= l_220) < p_23) << (uint16_t)l_201)) & p_23) && l_196) & p_22))) && l_201)) >> (int16_t)1));
    }
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(uint16_t  p_32)
{ /* block id: 38 */
    uint8_t l_156 = 0xB0;
    int16_t l_168 = 0;
    int32_t l_169 = 0xF7153193;
    struct S0 l_170 = {28,-37129,-3,-10827,0xA4};
    for (p_32 = (-12); (p_32 >= 42); p_32 += 1)
    { /* block id: 41 */
        int32_t l_157 = 0x1DC2E7BD;
        l_169 = (((uint16_t)((((1U || (l_156 > l_157)) > (l_157 != ((uint16_t)(((uint16_t)p_32 + (uint16_t)(!p_32)) ^ (!(((int16_t)(l_157 && l_157) << (int16_t)((uint16_t)((p_32 | l_168) & l_156) + (uint16_t)0x0DD1)) | p_32))) - (uint16_t)l_168))) != p_32) != p_32) - (uint16_t)p_32) == l_157);
        return l_169;
    }
    l_170 = l_170;
    return l_170.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_35(uint16_t  p_36, int32_t  p_37, int32_t  p_38)
{ /* block id: 19 */
    int32_t l_133 = (-1);
    int16_t l_151 = 0xB552;
    for (p_37 = 0; (p_37 <= (-9)); p_37 -= 1)
    { /* block id: 22 */
        int32_t l_127 = 1;
        int16_t l_138 = 0xA4B2;
        uint32_t l_139 = 0xFB82FD53;
        int32_t l_145 = 0x77822E2C;
        l_127 = ((int16_t)((((((int16_t)l_127 - (int16_t)(p_36 != ((uint16_t)(0 & ((~p_36) == (((((int16_t)((p_36 > l_133) > p_38) >> (int16_t)3) != (((uint16_t)((uint16_t)65531U >> (uint16_t)15) - (uint16_t)p_38) & l_127)) & l_138) != l_139))) + (uint16_t)0xA8E8))) | 0x7A3F) > p_38) | l_138) && 1) % (int16_t)p_38);
        l_127 = (0x46E9 != p_36);
        for (l_127 = 0; (l_127 != (-17)); l_127 -= 1)
        { /* block id: 27 */
            uint32_t l_144 = 0x63A172F1;
            for (p_38 = 0; (p_38 >= (-11)); p_38 -= 1)
            { /* block id: 30 */
                return l_133;
            }
            l_145 = l_144;
            p_38 = (p_37 < (0x6C93 == (-(int16_t)((int16_t)(p_38 < ((uint32_t)l_144 + (uint32_t)0)) - (int16_t)l_144))));
        }
    }
    return l_151;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_40(uint8_t  p_41, uint16_t  p_42)
{ /* block id: 4 */
    uint16_t l_57 = 0xBBD9;
    uint16_t l_78 = 0x10F6;
    int32_t l_120 = 0x94C0DA39;
    l_120 = ((func_49(((uint16_t)((int32_t)(-8) % (int32_t)func_55(l_57)) - (uint16_t)(((((uint16_t)l_57 >> (uint16_t)14) & ((((int32_t)(((uint16_t)0x6E6A - (uint16_t)p_42) != ((uint16_t)((int32_t)((((uint16_t)(((((int16_t)p_41 << (int16_t)(((uint16_t)(-(int32_t)1) >> (uint16_t)(0 <= p_42)) > l_57)) & 1) > 1U) && l_57) % (uint16_t)l_57) ^ p_42) < l_57) - (int32_t)p_42) >> (uint16_t)5)) - (int32_t)l_57) <= l_78) < p_41)) < l_78) & p_41))) > l_57) <= l_78);
    l_120 = l_78;
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_49(int32_t  p_50)
{ /* block id: 7 */
    int16_t l_81 = 0x0302;
    int32_t l_85 = 0xD3D8B2F9;
    uint32_t l_108 = 0x88FC9099;
    uint32_t l_117 = 0xBD03F0CD;
    l_85 = (((((uint16_t)l_81 << (uint16_t)6) > (-10)) && l_81) ^ ((p_50 >= ((l_81 != (l_81 < l_81)) <= ((int16_t)(((~l_81) >= 0x534BB8EB) <= 4294967290U) >> (int16_t)14))) < p_50));
    l_85 = (((int16_t)(((uint16_t)l_81 >> (uint16_t)4) && l_81) % (int16_t)l_85) | ((int16_t)0x4168 % (int16_t)l_81));
    if (((((uint16_t)(((((int16_t)0 >> (int16_t)l_81) ^ ((p_50 & (((uint16_t)(((((int32_t)((p_50 < ((int16_t)p_50 << (int16_t)6)) == l_85) - (int32_t)(((int16_t)(((int16_t)l_81 >> (int16_t)l_108) | ((uint16_t)(((uint16_t)((int32_t)(((uint16_t)l_81 << (uint16_t)4) == p_50) + (int32_t)0x3F460CB5) >> (uint16_t)l_85) | l_108) << (uint16_t)14)) >> (int16_t)1) != l_108)) != l_81) >= 0) > p_50) + (uint16_t)l_85) >= 0x377822E8)) & 0xF4830711)) >= l_85) ^ l_117) << (uint16_t)l_81) != l_85) < l_117))
    { /* block id: 10 */
        uint32_t l_118 = 4294967289U;
        return l_118;
    }
    else
    { /* block id: 12 */
        struct S1 l_119 = {401,8,3,-4};
        l_119 = l_119;
    }
    return l_117;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_55(int16_t  p_56)
{ /* block id: 5 */
    uint32_t l_58 = 0xC0E5C5CC;
    return l_58;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 43
   depth: 1, occurrence: 14
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 14
breakdown:
   indirect level: 0, occurrence: 14
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 14
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 7
XXX times a single bitfield on RHS: 33

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 2
   depth: 33, occurrence: 2
   depth: 38, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 302
XXX times a non-volatile is write: 47
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 70
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 20
   depth: 2, occurrence: 9
   depth: 3, occurrence: 12
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

