/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      861722641
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static const uint8_t  func_18(int32_t * p_19);
static int32_t * func_20(int16_t  p_21, uint32_t  p_22, const int32_t ** p_23, int32_t ** p_24);
static uint8_t  func_27(uint32_t  p_28, uint32_t  p_29);
inline static int32_t * func_47(int32_t *** p_48);
inline static int32_t * func_50(int16_t  p_51, int32_t * const * const * p_52, int32_t **** const  p_53, uint16_t  p_54, int32_t  p_55);
inline static int32_t * const  func_64(int32_t * p_65, uint32_t  p_66, int32_t  p_67, int32_t **** p_68);
inline static int32_t * func_69(int32_t ** const * p_70);
static uint32_t  func_77(uint32_t  p_78, int32_t  p_79, int8_t  p_80);
static uint32_t  func_81(int32_t ** p_82, int32_t  p_83, uint16_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0xAC204E2D;
    int32_t *l_16 = (void*)0;
    int32_t **l_15 = &l_16;
    int32_t ***l_14 = &l_15;
    uint32_t l_393 = 4294967295U;
    const int32_t *l_417 = &l_2;
    const int32_t **l_416 = &l_417;
    const int32_t *** const l_415 = &l_416;
    int32_t *****l_465 = (void*)0;
    int32_t l_500 = 0x43B7C93A;
    int32_t l_511 = (-1);
    const int8_t l_527 = 0xF2;
    const uint16_t l_528 = 4U;
    int32_t *l_529 = &l_500;
    int32_t ** const *l_532 = &l_15;
    int32_t ** const **l_531 = &l_532;
    int32_t ** const ***l_530 = &l_531;
    int32_t l_533 = 0x52AD83A8;
    for (l_2 = 0; (l_2 == (-17)); l_2 = safe_sub_func_uint32_t_u_u(l_2, 1))
    { /* block id: 3 */
        int32_t *l_12 = &l_2;
        int32_t *l_420 = &l_2;
        int32_t ****l_427 = (void*)0;
        int32_t **l_448 = &l_16;
        int16_t l_458 = (-7);
        uint16_t l_494 = 0x01C8;
        const int32_t *l_504 = (void*)0;
    }
    if ((*l_417))
    { /* block id: 189 */
        int32_t ***l_505 = &l_15;
        int32_t l_506 = (-3);
        int32_t *l_507 = (void*)0;
        int32_t *l_508 = (void*)0;
        int32_t *l_509 = &l_2;
        l_500 = (l_505 == &l_15);
        (*l_509) = l_506;
        (**l_415) = func_47(&l_15);
        /* statement id: 192 */
        assert (l_417 == 0);
    }
    else
    { /* block id: 193 */
        int32_t l_510 = 8;
        int32_t ***l_515 = &l_15;
        l_511 = l_510;
        for (l_511 = 0; (l_511 >= (-27)); l_511 = safe_sub_func_uint32_t_u_u(l_511, 8))
        { /* block id: 197 */
            int32_t *l_514 = &l_2;
            (*l_514) = 0x69803BF5;
            (*l_514) = l_510;
        }
        (**l_14) = (**l_14);
        (**l_14) = func_47(l_515);
    }
    /* facts after branching */
    assert (l_417 == &l_2 || l_417 == 0);
    (*l_529) = (((void*)0 != &l_14) || ((safe_div_func_int8_t_s_s(l_393, (safe_div_func_int32_t_s_s(0xB7D92049, (safe_sub_func_int32_t_s_s((((safe_lshift_func_uint8_t_u_s((~(safe_lshift_func_int16_t_s_s((0x8ABD43E7 | l_527), ((0xAB <= ((((l_393 ^ 0U) >= 248U) == 1) < l_528)) || (-5))))), 2)) > 0x8D190FCD) != l_511), 0xEE686AA9)))))) && 0xA7));
    (*l_530) = &l_415;
    /* statement id: 205 */
    assert (l_531 == &l_415);
    return l_533;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint8_t  func_18(int32_t * p_19)
{ /* block id: 137 */
    int16_t l_371 = 0x2D0F;
    uint8_t l_381 = 0x77;
    uint32_t l_388 = 0x21802581;
    int32_t *l_389 = (void*)0;
    int32_t l_391 = 0xE61DC435;
    int32_t *l_390 = &l_391;
    const uint32_t l_392 = 0x9223293A;
    (*l_390) = ((safe_add_func_int16_t_s_s(l_371, ((safe_unary_minus_func_uint16_t_u((65533U < l_371))) ^ (safe_rshift_func_uint8_t_u_u((((((((safe_add_func_uint8_t_u_u((safe_add_func_int16_t_s_s(0x9814, (safe_sub_func_uint8_t_u_u(l_381, (safe_add_func_int8_t_s_s(0xB0, ((l_381 || (l_371 != (0xA82341EF != l_381))) != l_381))))))), l_381)) ^ l_371) | 0x447648BD) ^ l_381) >= l_371) < l_388) >= (-1)), 2))))) || l_371);
    return l_392;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_20(int16_t  p_21, uint32_t  p_22, const int32_t ** p_23, int32_t ** p_24)
{ /* block id: 14 */
    int16_t l_36 = (-8);
    int32_t l_45 = (-1);
    const int32_t *l_44 = &l_45;
    const int32_t **l_43 = &l_44;
    const int32_t ***l_42 = &l_43;
    const int32_t *** const * const l_41 = &l_42;
    int32_t *l_46 = &l_45;
    int32_t ***l_49 = (void*)0;
    (*l_46) = (l_36 <= (((safe_mod_func_uint32_t_u_u((safe_div_func_uint32_t_u_u((l_41 == (void*)0), (-2))), p_22)) | ((***l_41) != (*l_43))) | (func_27((****l_41), p_22) != 8)));
    (**l_42) = func_47(l_49);
    /* statement id: 135 */
    assert (l_44 == 0);
    return (*p_24);
    /* statement id: 136 */
    //assert (func_20_rv == 0 || func_20_rv == &l_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_27(uint32_t  p_28, uint32_t  p_29)
{ /* block id: 11 */
    int32_t l_33 = 0;
    int32_t *l_32 = &l_33;
    (*l_32) = 0;
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_47(int32_t *** p_48)
{ /* block id: 16 */
    uint32_t l_56 = 4U;
    int32_t * const *l_58 = (void*)0;
    int32_t * const * const *l_57 = &l_58;
    int32_t l_63 = 0x12B6A360;
    int32_t *l_62 = &l_63;
    int32_t **l_61 = &l_62;
    int32_t ***l_60 = &l_61;
    int32_t **** const l_59 = &l_60;
    int32_t l_350 = 7;
    uint32_t l_361 = 0U;
    int32_t *l_362 = (void*)0;
    int32_t *l_363 = &l_63;
    int32_t *l_364 = &l_63;
    int32_t *l_365 = &l_63;
    int32_t *l_366 = &l_63;
    int32_t *l_367 = &l_63;
    int32_t *l_368 = (void*)0;
    (*l_61) = func_50((1 ^ l_56), l_57, l_59, (*l_62), (***l_60));
    /* statement id: 132 */
    assert (l_62 == 0);
    l_63 = ((safe_lshift_func_int16_t_s_s(l_350, 5)) || ((safe_mod_func_int32_t_s_s((safe_div_func_uint8_t_u_u(((*l_59) == (void*)0), (safe_sub_func_uint32_t_u_u(l_350, ((*l_60) == (*l_60)))))), l_350)) >= (safe_add_func_uint8_t_u_u(l_63, ((safe_add_func_int8_t_s_s((l_56 > l_361), 0x8E)) | l_350)))));
    return l_368;
    /* statement id: 134 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_50(int16_t  p_51, int32_t * const * const * p_52, int32_t **** const  p_53, uint16_t  p_54, int32_t  p_55)
{ /* block id: 17 */
    int32_t ** const *l_71 = (void*)0;
    int32_t l_305 = 0x9A0984C2;
    int32_t * const *l_309 = (void*)0;
    int32_t * const **l_308 = &l_309;
    int32_t * const ***l_307 = &l_308;
    int32_t * const **** const l_306 = &l_307;
    int32_t ****l_310 = (void*)0;
    int32_t *l_341 = &l_305;
    int32_t **l_340 = &l_341;
    int32_t *l_347 = &l_305;
    (*l_340) = func_64(func_69(l_71), l_305, ((&p_53 != l_306) < ((void*)0 != (*l_308))), l_310);
    /* statement id: 121 */
    assert (l_341 == 0);
    (***p_53) = (void*)0;
    /* statement id: 122 */
    //assert (l_62 == 0);
    for (p_54 = 0; (p_54 != 7); p_54 = safe_add_func_int8_t_s_s(p_54, 1))
    { /* block id: 125 */
        int32_t l_344 = 0;
        p_52 = (**l_306);
        /* statement id: 126 */
        assert (p_52 == &l_309);
        if (l_344)
            continue;
        return (***p_53);
        /* statement id: 128 */
        //assert (func_50_rv == 0);
    }
    /* facts after for loop */
    //assert (p_52 == &l_309 || p_52 == &l_58);
    (*l_347) = (safe_rshift_func_uint16_t_u_s(((&p_53 != &l_310) || p_54), (0x7EB9 < ((**p_53) == (void*)0))));
    return (***p_53);
    /* statement id: 131 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_64(int32_t * p_65, uint32_t  p_66, int32_t  p_67, int32_t **** p_68)
{ /* block id: 119 */
    int32_t l_312 = 0x42437FBE;
    int32_t * const l_311 = &l_312;
    int32_t * const l_313 = &l_312;
    int32_t * const l_314 = &l_312;
    int32_t * const l_315 = &l_312;
    int32_t * const l_316 = &l_312;
    int32_t * const l_317 = &l_312;
    int32_t * const l_318 = &l_312;
    int32_t * const l_319 = &l_312;
    int32_t * const l_320 = &l_312;
    int32_t * const l_321 = &l_312;
    int32_t * const l_322 = &l_312;
    int32_t * const l_323 = &l_312;
    int32_t * const l_324 = &l_312;
    int32_t * const l_325 = &l_312;
    int32_t * const l_326 = &l_312;
    int32_t * const l_327 = &l_312;
    int32_t * const l_328 = &l_312;
    int32_t * const l_329 = &l_312;
    int32_t * const l_330 = &l_312;
    int32_t * const l_331 = &l_312;
    int32_t * const l_332 = &l_312;
    int32_t * const l_333 = &l_312;
    int32_t * const l_334 = &l_312;
    int32_t * const l_335 = &l_312;
    int32_t * const l_336 = &l_312;
    int32_t * const l_337 = &l_312;
    int32_t * const l_338 = &l_312;
    int32_t * const l_339 = (void*)0;
    return l_339;
    /* statement id: 120 */
    //assert (func_64_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_69(int32_t ** const * p_70)
{ /* block id: 18 */
    int32_t l_72 = 0xC59458D8;
    int32_t *l_74 = &l_72;
    int32_t **l_73 = &l_74;
    int32_t ** const ***l_257 = (void*)0;
    int32_t *l_297 = &l_72;
    int32_t *l_299 = &l_72;
    uint32_t l_301 = 0x1B5795B1;
    int32_t *l_302 = &l_72;
    int32_t *l_303 = &l_72;
    int32_t *l_304 = (void*)0;
    l_72 = l_72;
    if ((((l_73 != &l_74) | (func_27((*l_74), (safe_sub_func_uint32_t_u_u((**l_73), func_77((*l_74), (0x1D584D75 || func_81(&l_74, (**l_73), (~((*l_74) < (*l_74))))), (**l_73))))) < (*l_74))) <= 0x0B4FC89C))
    { /* block id: 91 */
        int32_t * const l_253 = (void*)0;
        int32_t **l_254 = &l_74;
        (*l_73) = (*l_73);
        (*l_254) = l_253;
        /* statement id: 93 */
        assert (l_74 == 0);
    }
    else
    { /* block id: 94 */
        int32_t l_263 = (-1);
        int32_t **l_264 = &l_74;
        int32_t l_278 = 0x67F1609E;
        (*l_73) = (*l_73);
        for (l_72 = 27; (l_72 <= 4); l_72 = safe_sub_func_int32_t_s_s(l_72, 1))
        { /* block id: 98 */
            int32_t ** const *l_260 = &l_73;
            int32_t ** const **l_259 = &l_260;
            int32_t ** const ***l_258 = &l_259;
            int32_t *l_298 = (void*)0;
            l_258 = l_257;
            /* statement id: 99 */
            assert (l_258 == 0);
            if (((safe_lshift_func_int8_t_s_s(0xDB, 0)) >= (((**l_73) >= (((l_263 < (l_264 == l_264)) ^ ((safe_rshift_func_uint16_t_u_u(((***l_260) | 0U), 5)) & ((safe_rshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u(((safe_add_func_int8_t_s_s(1, (0x8A68 >= (**l_264)))) >= 4294967295U), 13)), 1)) ^ (**l_264)))) < (***l_260))) ^ (**l_73))))
            { /* block id: 100 */
                int8_t l_273 = 0xCF;
                if ((l_273 & (safe_add_func_int8_t_s_s((((((*l_74) & l_273) > (safe_mod_func_int8_t_s_s(((***l_260) || (0xEF >= (0x0E | ((65534U >= 0x9B8E) <= ((****l_259) >= 0U))))), (**l_73)))) >= 0xCE) <= (**l_264)), 0))))
                { /* block id: 101 */
                    (**l_260) = (***l_259);
                    l_278 = ((***l_260) >= l_273);
                }
                else
                { /* block id: 104 */
                    uint16_t l_294 = 0x5E9D;
                    int32_t *l_295 = &l_278;
                    if (l_273)
                        break;
                    l_294 = (safe_sub_func_int32_t_s_s((0x02 != (safe_rshift_func_int16_t_s_s((p_70 == &l_264), 12))), (safe_rshift_func_uint8_t_u_s((0U == (**l_264)), (safe_sub_func_uint32_t_u_u((((safe_lshift_func_uint16_t_u_s((safe_div_func_uint8_t_u_u(((-10) >= (safe_sub_func_int32_t_s_s(((safe_unary_minus_func_int32_t_s((-4))) ^ (**l_73)), (**l_264)))), (**l_73))), (****l_259))) || 5) >= (****l_259)), (*l_74)))))));
                    l_295 = (*l_264);
                    /* statement id: 107 */
                    assert (l_295 == &l_72);
                }
            }
            else
            { /* block id: 109 */
                int32_t *l_296 = (void*)0;
                return l_296;
                /* statement id: 110 */
                //assert (func_69_rv == 0);
            }
            (*l_73) = l_297;
            return l_298;
            /* statement id: 113 */
            //assert (func_69_rv == 0);
        }
    }
    /* facts after branching */
    assert (l_74 == &l_72 || l_74 == 0);
    (*l_73) = l_299;
    /* statement id: 116 */
    assert (l_74 == &l_72);
    (*l_297) = (safe_unary_minus_func_int16_t_s(l_301));
    return l_304;
    /* statement id: 118 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_77(uint32_t  p_78, int32_t  p_79, int8_t  p_80)
{ /* block id: 26 */
    int32_t *l_113 = (void*)0;
    int32_t l_115 = 0x1BC4ECDC;
    int32_t *l_114 = &l_115;
    uint32_t l_129 = 1U;
    int32_t **l_162 = &l_114;
    int32_t ***l_161 = &l_162;
    uint32_t l_240 = 0xC45E7516;
    int16_t l_241 = 0x3EF0;
    (*l_114) = (safe_unary_minus_func_int16_t_s(4));
    (*l_114) = (*l_114);
    if ((safe_unary_minus_func_int8_t_s((safe_sub_func_uint32_t_u_u(((p_80 >= (*l_114)) || (*l_114)), (((safe_sub_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_s(p_78, 12)), 0)) != ((safe_mod_func_int8_t_s_s((safe_div_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_s(l_129, 7)), p_78)), (safe_sub_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((*l_114), (safe_sub_func_uint16_t_u_u((*l_114), (*l_114))))), p_80)))) ^ 0xBC)) > (*l_114)))))))
    { /* block id: 29 */
        uint8_t l_136 = 250U;
        return l_136;
    }
    else
    { /* block id: 31 */
        int32_t l_150 = (-3);
        const int32_t **l_232 = (void*)0;
        const int32_t ***l_231 = &l_232;
        int32_t ***** const l_250 = (void*)0;
    }
    (**l_162) = p_80;
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_81(int32_t ** p_82, int32_t  p_83, uint16_t  p_84)
{ /* block id: 20 */
    int16_t l_90 = 0;
    int16_t l_92 = 1;
    int32_t l_105 = 0x71E1D77F;
    int32_t *l_104 = &l_105;
    int32_t **l_103 = &l_104;
    int32_t *** const l_102 = &l_103;
    int32_t *** const *l_101 = &l_102;
    int32_t *l_111 = &l_105;
    (***l_102) = (safe_div_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(l_90, (((**p_82) | (~l_90)) || l_92))), (((safe_rshift_func_uint8_t_u_s(l_90, 1)) <= (safe_rshift_func_int16_t_s_u(((safe_div_func_uint8_t_u_u((safe_sub_func_uint32_t_u_u(l_92, (l_101 != (void*)0))), p_84)) > (**l_103)), p_83))) ^ 0xB0)));
    (***l_102) = 0xE484183A;
    (**l_102) = (*p_82);
    /* statement id: 23 */
    //assert (l_104 == &l_72);
    (*l_111) = (p_83 != ((p_84 > (!(safe_mod_func_int8_t_s_s((((safe_rshift_func_int16_t_s_u(((&l_102 != (void*)0) > (((*l_102) == (void*)0) || ((**l_103) & ((&l_102 != &l_102) | (**l_103))))), 9)) == 0xB6) & (***l_102)), p_84)))) <= (**l_103)));
    return (*l_104);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 136
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 9
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1

XXX total number of pointers: 125

XXX times a variable address is taken: 134
XXX times a pointer is dereferenced on RHS: 115
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 30
   depth: 3, occurrence: 14
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 11
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 650

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 214
   level: 2, occurrence: 152
   level: 3, occurrence: 104
   level: 4, occurrence: 38
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 68
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 36
XXX average alias set size: 1.17

XXX times a non-volatile is read: 541
XXX times a non-volatile is write: 164
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 64
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 15
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
   depth: 4, occurrence: 5

XXX percentage a fresh-made variable is used: 10.5
XXX percentage an existing variable is used: 89.5
********************* end of statistics **********************/

