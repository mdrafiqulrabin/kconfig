/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3795993530
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 11;
   signed f1 : 20;
   signed f2 : 6;
   signed f3 : 26;
};
#pragma pack(pop)

union U1 {
   int32_t  f0;
};

union U2 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const int32_t  func_33(void);
static int32_t * func_34(int32_t * p_35, int32_t * p_36);
static int32_t * func_37(int32_t * p_38);
inline static int32_t * func_39(const union U1  p_40, union U2  p_41, const struct S0  p_42, int32_t * const  p_43);
inline static union U2  func_45(uint32_t  p_46, int32_t * p_47, uint32_t  p_48, union U2  p_49, union U2  p_50);
static uint32_t  func_51(uint32_t  p_52, struct S0  p_53, union U1  p_54, int32_t * p_55, int32_t  p_56);
static struct S0  func_57(const int32_t * p_58, union U1  p_59, float  p_60, int32_t * p_61, uint32_t  p_62);
static int32_t * func_63(const int32_t * p_64, int32_t * p_65, int32_t  p_66);
inline static int32_t * func_70(uint32_t  p_71);
inline static union U1 * func_73(int32_t * p_74, struct S0  p_75, union U1 * p_76, union U1 * p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_33(void)
{ /* block id: 36 */
    const union U1 l_44 = {0xFBB9CF7D};
    const int32_t *l_67 = &l_44.f0;
    int32_t l_69 = 0;
    int32_t *l_68 = &l_69;
    int32_t l_103 = 1;
    int32_t *l_102 = &l_103;
    int32_t l_287 = 0x29E3FC97;
    int32_t l_288 = 0xA7D3C943;
    union U2 l_289 = {3};
    union U2 l_290 = {-1};
    const struct S0 l_300 = {6,90,-1,1465};
    int32_t **l_338 = &l_68;
    float l_340 = (-0x8.Dp-1);
    float *l_339 = &l_340;
    const uint32_t l_341 = 4294967289U;
    (*l_338) = func_34(func_37(func_39(l_44, func_45((func_51(l_44.f0, func_57(func_63(l_67, l_68, (*l_67)), l_44, (!((*l_67) <= (*l_67))), l_102, (*l_102)), l_44, l_102, (*l_67)) != l_287), l_102, l_288, l_289, l_290), l_300, l_68)), l_68);
    /* statement id: 242 */
    assert (l_68 == 0);
    (*l_339) = (*l_102);
    return l_341;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(int32_t * p_35, int32_t * p_36)
{ /* block id: 239 */
    struct S0 l_334 = {24,895,3,-3721};
    struct S0 *l_335 = (void*)0;
    int32_t l_337 = 0;
    int32_t *l_336 = &l_337;
    l_334 = l_334;
    return p_35;
    /* statement id: 241 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(int32_t * p_38)
{ /* block id: 229 */
    int32_t l_314 = 9;
    struct S0 l_319 = {36,470,6,976};
    struct S0 *l_318 = &l_319;
    struct S0 * const *l_317 = &l_318;
    int32_t *l_331 = (void*)0;
    int32_t *l_332 = &l_314;
    union U1 l_333 = {-3};
    for (l_314 = (-30); (l_314 > (-4)); l_314++)
    { /* block id: 232 */
        int32_t *l_320 = (void*)0;
        int32_t l_322 = 0xEC73FAEB;
        int32_t *l_321 = &l_322;
        (*l_321) = (l_317 != &l_318);
    }
    (*l_332) = ((uint32_t)((uint32_t)((int32_t)l_314 + (int32_t)((*l_317) == (*l_317))) % (uint32_t)0xC1720F16) + (uint32_t)(((int16_t)l_319.f1 >> (int16_t)9) | 0x311B5572));
    l_331 = p_38;
    (*l_318) = func_57(&l_314, l_333, (*l_332), &l_314, (*l_332));
    return p_38;
    /* statement id: 238 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_39(const union U1  p_40, union U2  p_41, const struct S0  p_42, int32_t * const  p_43)
{ /* block id: 220 */
    float ***l_302 = (void*)0;
    float ****l_301 = &l_302;
    float *****l_303 = &l_301;
    int32_t l_312 = 1;
    int32_t *l_311 = &l_312;
    int32_t *l_313 = (void*)0;
    (*l_303) = l_301;
    for (p_41.f0 = 0; (p_41.f0 >= 19); ++p_41.f0)
    { /* block id: 224 */
        struct S0 l_306 = {-28,-998,-4,4938};
        struct S0 *l_307 = (void*)0;
        int32_t l_309 = 1;
        int32_t *l_308 = &l_309;
        int32_t **l_310 = &l_308;
        l_306 = l_306;
        (*l_310) = l_308;
    }
    return l_313;
    /* statement id: 228 */
    //assert (func_39_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_45(uint32_t  p_46, int32_t * p_47, uint32_t  p_48, union U2  p_49, union U2  p_50)
{ /* block id: 207 */
    struct S0 l_295 = {11,-305,-3,3527};
    struct S0 *l_294 = &l_295;
    struct S0 **l_296 = &l_294;
    union U2 l_299 = {0x53C1BFE7};
    for (p_50.f0 = (-17); (p_50.f0 > 2); p_50.f0 += 2)
    { /* block id: 210 */
        union U2 l_293 = {0x97413A3C};
        return l_293;
        /* statement id: 211 */
            }
    (*l_296) = l_294;
    for (p_46 = (-3); (p_46 <= 41); p_46 += 6)
    { /* block id: 216 */
        return l_299;
        /* statement id: 217 */
            }
    return l_299;
    /* statement id: 219 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(uint32_t  p_52, struct S0  p_53, union U1  p_54, int32_t * p_55, int32_t  p_56)
{ /* block id: 203 */
    int32_t l_276 = 0x5F7FD561;
    struct S0 l_279 = {9,573,-0,-4251};
    struct S0 *l_278 = &l_279;
    struct S0 **l_277 = &l_278;
    int32_t l_281 = (-6);
    float *l_282 = (void*)0;
    float l_284 = 0x3.9p+1;
    float *l_283 = &l_284;
    float **l_286 = &l_283;
    float ***l_285 = &l_286;
    (*l_283) = ((((float)((l_276 < (((((((((void*)0 != l_277) > l_279.f0) == p_53.f1) != (-(float)0xC.A8F1D4p+60)) <= ((p_52 != __builtin_parityll(l_279.f1)) == 0x8.CD0BF8p+71)) == l_281) != 0xC.25BC62p+15) >= 0x5.869ADCp+38)) >= 0xD.7BDB8Dp-50) - (float)p_56) != l_279.f0) == 0x0.B1EE1Ep-81);
    (*l_285) = &l_283;
    return l_276;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_57(const int32_t * p_58, union U1  p_59, float  p_60, int32_t * p_61, uint32_t  p_62)
{ /* block id: 65 */
    union U1 l_112 = {0x48280EFF};
    union U1 *l_111 = &l_112;
    union U1 **l_110 = &l_111;
    float l_120 = 0x1.FD71AFp-76;
    float *l_119 = &l_120;
    struct S0 l_121 = {43,105,2,4592};
    int32_t *l_122 = &l_112.f0;
    union U2 l_240 = {0x276F7CF7};
    union U2 *l_239 = &l_240;
    float l_244 = 0x7.5C2981p+96;
    int32_t l_249 = 0xD05821FD;
    float l_267 = 0x4.324065p+19;
    for (p_62 = (-28); (p_62 > 9); ++p_62)
    { /* block id: 68 */
        const int32_t l_107 = 7;
        const int32_t *l_106 = &l_107;
        float l_114 = 0xC.C01D5Bp-88;
        float * const l_113 = &l_114;
        l_106 = func_63(l_106, p_61, ((uint32_t)((void*)0 == l_110) - (uint32_t)(p_62 ^ (((4294967288U && p_62) ^ (((void*)0 != l_113) ^ 0x0E89)) >= (*l_106)))));
        /* statement id: 69 */
        //assert (l_106 == &l_103 || l_106 == &l_314);
        (*l_113) = (__builtin_parityll((*l_106)) > (((float)(__builtin_clz((((*p_61) && __builtin_ffs(((uint16_t)(((void*)0 == l_119) | l_112.f0) >> (uint16_t)10))) | 1)) == 0x5.DCF8E4p-34) + (float)0x0.847A7Ap+2) <= l_112.f0));
        (*p_61) = (p_59.f0 >= p_59.f0);
        return l_121;
    }
    (*p_61) = 0x35BD15A5;
    l_122 = p_61;
    /* statement id: 75 */
    //assert (l_122 == &l_103 || l_122 == &l_314);
    for (l_112.f0 = 0; (l_112.f0 >= 12); l_112.f0 += 6)
    { /* block id: 78 */
        const struct S0 *l_159 = &l_121;
        const struct S0 **l_158 = &l_159;
        int32_t l_181 = 0xB44B642E;
        union U2 l_238 = {0xDB04045A};
        union U2 *l_237 = &l_238;
        const struct S0 l_272 = {-23,327,2,1860};
        struct S0 *l_273 = &l_121;
        for (p_62 = 0; (p_62 < 22); p_62++)
        { /* block id: 81 */
            uint32_t l_131 = 0x7AA087AC;
            int32_t *l_138 = &l_112.f0;
            struct S0 l_152 = {37,-267,-1,-7415};
            union U2 l_166 = {0xE8D33E78};
            union U2 *l_165 = &l_166;
            int32_t *l_197 = &l_166.f0;
            union U1 *l_222 = &l_112;
            int32_t **l_241 = &l_122;
        }
        (*l_273) = l_272;
    }
    return l_121;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_103 l_314
 */
static int32_t * func_63(const int32_t * p_64, int32_t * p_65, int32_t  p_66)
{ /* block id: 37 */
    int32_t l_72 = 0x11E69D08;
    int16_t l_94 = 1;
    struct S0 l_96 = {39,756,-7,-6878};
    struct S0 *l_95 = &l_96;
    p_64 = func_70(l_72);
    /* statement id: 52 */
    assert (p_64 == 0);
    if (l_94)
    { /* block id: 53 */
        l_72 = 0x1.Ep+1;
    }
    else
    { /* block id: 55 */
        (*p_65) = 0x1B6BD7A8;
    }
    l_95 = l_95;
    for (l_72 = 0; (l_72 < (-16)); l_72 -= 1)
    { /* block id: 61 */
        const int32_t *l_100 = &l_72;
        const int32_t **l_99 = &l_100;
        (*l_99) = p_65;
        /* statement id: 62 */
        //assert (l_100 == &l_69 || l_100 == &l_103 || l_100 == &l_238.f0 || l_100 == &l_314);
    }
    return p_65;
    /* statement id: 64 */
    //assert (func_63_rv == &l_69 || func_63_rv == &l_103 || func_63_rv == &l_238.f0 || func_63_rv == &l_314);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_70(uint32_t  p_71)
{ /* block id: 38 */
    int32_t *l_78 = (void*)0;
    struct S0 l_79 = {22,732,5,3114};
    union U1 *l_80 = (void*)0;
    union U1 **l_87 = &l_80;
    (*l_87) = func_73(l_78, l_79, l_80, l_80);
    for (p_71 = 0; (p_71 >= 36); p_71 += 1)
    { /* block id: 47 */
        float l_92 = 0x1.DF1C91p-19;
        float *l_91 = &l_92;
        struct S0 l_93 = {-7,-752,1,1326};
        (*l_91) = (-(float)(-0x1.9p-1));
        l_93 = l_79;
    }
    return l_78;
    /* statement id: 51 */
    //assert (func_70_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_73(int32_t * p_74, struct S0  p_75, union U1 * p_76, union U1 * p_77)
{ /* block id: 39 */
    float l_81 = 0x6.Bp-1;
    float *l_82 = &l_81;
    int32_t l_83 = 0x4D4A52D8;
    int32_t *l_84 = &l_83;
    union U1 l_86 = {0x5B38D6AE};
    union U1 *l_85 = &l_86;
    (*l_82) = l_81;
    (*l_84) = l_83;
    p_75 = p_75;
    return p_77;
    /* statement id: 43 */
    //assert (func_73_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 76
   depth: 1, occurrence: 13
XXX total union variables: 6

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 18
breakdown:
   indirect level: 0, occurrence: 13
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 29
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 6

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 12
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 17, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 103

XXX times a variable address is taken: 80
XXX times a pointer is dereferenced on RHS: 48
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 59
breakdown:
   depth: 1, occurrence: 59
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 148

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 125
   level: 2, occurrence: 8
XXX number of pointers point to pointers: 28
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 26.2
XXX average alias set size: 1.25

XXX times a non-volatile is read: 339
XXX times a non-volatile is write: 148
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 53
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 16

XXX percentage a fresh-made variable is used: 27.1
XXX percentage an existing variable is used: 72.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

