/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      689589361
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int64_t  func_34(void);
static int32_t  func_46(const int32_t * p_47, int32_t * p_48);
static int32_t * func_49(uint16_t  p_50);
inline static int32_t  func_51(int64_t  p_52);
static uint64_t  func_56(uint32_t  p_57);
static int32_t ** func_65(uint8_t  p_66, int32_t ** p_67);
inline static int64_t  func_69(float  p_70, const int32_t  p_71, int32_t  p_72, const int32_t * p_73, int32_t * p_74);
static int32_t * func_82(uint16_t  p_83, int32_t  p_84, int32_t ** p_85, int32_t * p_86, int64_t  p_87);
static const int32_t * func_100(int32_t  p_101, int32_t ** p_102, int32_t * p_103, int32_t ** const  p_104, const int32_t  p_105);
inline static int32_t ** func_106(int64_t  p_107, int16_t  p_108, int16_t  p_109, uint32_t  p_110, uint16_t  p_111);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_34(void)
{ /* block id: 36 */
    float l_35 = 0xE.105FA2p-69;
    int32_t l_36 = 0L;
    int32_t l_37 = 0xB0A6D081L;
    uint32_t l_44 = 18446744073709551615UL;
    int32_t l_500 = (-1L);
    const int32_t *l_499 = &l_500;
    uint32_t l_501 = 0UL;
    int32_t *l_530 = &l_500;
    int32_t **l_529 = &l_530;
    float ***l_552 = (void*)0;
    float ****l_551 = &l_552;
    uint32_t l_556 = 0UL;
    int32_t *** const *l_572 = (void*)0;
    int32_t *** const **l_571 = &l_572;
    float l_633 = 0x5.0p+1;
    uint32_t l_634 = 0xF9503BDCL;
    if ((__builtin_parity(l_36) ^ (l_37 || ((l_37 || (__builtin_bswap32(l_36) ^ (-7L))) & ((uint64_t)l_36 % (uint64_t)(((uint64_t)(((uint16_t)__builtin_ia32_crc32qi(l_36, l_37) / (uint16_t)l_37) == l_37) - (uint64_t)l_37) & 4294967289UL))))))
    { /* block id: 37 */
        int32_t *l_45 = &l_36;
        int32_t * const l_485 = &l_36;
        uint8_t l_488 = 0x43L;
        int64_t l_506 = 0xEF5B7D92049911BFLL;
        uint8_t l_533 = 0x43L;
        float * const **l_550 = (void*)0;
        float * const ***l_549 = &l_550;
        int32_t l_605 = (-1L);
        int32_t *** const l_621 = &l_529;
        int32_t *** const *l_620 = &l_621;
        (*l_45) = l_44;
        if (func_46(&l_36, func_49(l_37)))
        { /* block id: 253 */
            int32_t **l_486 = (void*)0;
            int32_t **l_487 = &l_45;
            const uint32_t l_497 = 0UL;
            int32_t *l_498 = &l_36;
            int16_t l_525 = 0x8CECL;
            int32_t ***l_543 = &l_487;
            int32_t ****l_542 = &l_543;
            uint8_t l_573 = 0xE1L;
            int32_t *** const *l_622 = &l_543;
            (*l_487) = l_485;
            l_488 = l_37;
            (**l_487) = 0xF41EE8F7L;
            if ((((l_487 != (void*)0) | ((int16_t)l_44 >> (int16_t)11)) >= (((uint16_t)(l_37 && ((l_44 ^ (((uint64_t)18446744073709551613UL / (uint64_t)((*l_45) || (*l_45))) && func_69(func_69(l_37, l_497, (**l_487), &l_36, l_498), l_44, l_488, l_499, &l_500))) == l_44)) << (uint16_t)15) != l_501)))
            { /* block id: 257 */
                int16_t l_502 = 0xBC28L;
                int32_t l_513 = 0xB23BA3EBL;
                int32_t *l_531 = (void*)0;
                int32_t **l_554 = &l_498;
                float *l_557 = &l_35;
                int32_t ****l_559 = &l_543;
                int32_t **l_581 = &l_45;
                const int32_t *l_584 = &l_500;
                if (l_502)
                { /* block id: 258 */
                    int32_t l_507 = 5L;
                    int32_t *l_535 = &l_500;
                    if ((*l_499))
                    { /* block id: 259 */
                        return l_502;
                    }
                    else
                    { /* block id: 261 */
                        int32_t l_512 = (-1L);
                        (*l_485) = l_502;
                        (*l_498) = ((*l_485) == ((((int64_t)((!l_506) >= (-8L)) / (int64_t)((l_507 | ((((0xCA1C97F0D410D51BLL & (func_51(((int64_t)(l_507 >= (((*l_45) > ((uint64_t)(l_512 && l_512) + (uint64_t)l_513)) == 0x24FDA9CD144D20F8LL)) - (int64_t)(*l_499))) & l_507)) <= 0x2512EE13CED05DD1LL) > (**l_487)) == l_513)) ^ 4L)) > 0xA94C0A7CL) & l_512));
                    }
                    if (((uint16_t)((__builtin_bswap64((**l_487)) < l_507) & ((int32_t)((((-1L) | 0x9D06C8AAL) < ((int16_t)((int16_t)0x64A7L >> (int16_t)(*l_499)) >> (int16_t)(func_46(&l_36, func_49((((~((int32_t)(*l_45) / (int32_t)(*l_45))) > (-1L)) ^ (*l_498)))) | l_502))) < 1UL) + (int32_t)(*l_499))) / (uint16_t)(*l_499)))
                    { /* block id: 265 */
                        (*l_487) = (*l_487);
                    }
                    else
                    { /* block id: 267 */
                        uint16_t l_528 = 0xB562L;
                        (*l_487) = func_82(l_525, l_502, func_65(((((int64_t)0xCB523D4D1E4F2EB8LL - (int64_t)(l_507 <= (*l_45))) > __builtin_bswap32((*l_499))) && (__builtin_parity(l_528) > (*l_45))), l_529), l_531, l_528);
                        /* statement id: 268 */
                        assert (l_45 == &l_500);
                    }
                    /* facts after branching */
                    assert (l_45 == &l_500 || l_45 == &l_36);
                    if (l_507)
                    { /* block id: 270 */
                        int64_t l_532 = 0L;
                        l_533 = l_532;
                        (*l_529) = l_531;
                        /* statement id: 272 */
                        assert (l_530 == 0);
                    }
                    else
                    { /* block id: 273 */
                        int16_t l_534 = (-7L);
                        return l_534;
                    }
                    /* facts after branching */
                    assert (l_530 == 0);
                    (*l_487) = l_535;
                    /* statement id: 276 */
                    assert (l_45 == &l_500);
                }
                else
                { /* block id: 277 */
                    const int32_t *l_546 = (void*)0;
                    int32_t l_553 = 1L;
                    float l_555 = (-0x4.3p+1);
                    (****l_542) = ((int64_t)((int32_t)(((*l_485) == ((int16_t)6L << (int16_t)((void*)0 == l_542))) <= (((uint16_t)(func_46(l_546, func_82((((((uint64_t)(*l_45) / (uint64_t)func_56((l_549 != l_551))) || 0x6509L) && l_553) < 0x30DFDF1AB05D3E41LL), (*l_499), l_554, (*l_529), (*l_45))) > (****l_542)) >> (uint16_t)(*l_485)) <= l_556)) + (int32_t)0xDF3F4CF7L) / (int64_t)(**l_554));
                }
                /* facts after branching */
                assert (l_45 == &l_36 || l_45 == &l_500);
                assert (l_530 == &l_500 || l_530 == 0);
                if (l_506)
                    goto lbl_558;
                (*l_529) = l_45;
                /* statement id: 280 */
                assert (l_530 == &l_36 || l_530 == &l_500);
lbl_558:
                (*l_557) = __builtin_ffsll((*l_485));
                if (__builtin_ctzl(((((l_559 != l_559) != (&l_559 == &l_542)) | ((int16_t)(***l_543) >> (int16_t)2)) == (1UL && (0xBBD44ACBC9FF676ELL ^ ((0xED0EE9BEE710E45BLL != (****l_559)) == 0L))))))
                { /* block id: 283 */
                    uint32_t l_564 = 1UL;
                    int32_t **l_583 = &l_531;
                    (*l_554) = func_49((((uint16_t)0xEC77L + (uint16_t)((****l_542) != l_564)) == (l_564 && ((uint32_t)(((int32_t)(**l_554) + (int32_t)func_51((*l_499))) | ((uint64_t)((&l_559 == l_571) || l_573) % (uint64_t)(*l_45))) - (uint32_t)0x78684ADAL))));
                    /* statement id: 284 */
                    assert (l_498 == 0);
                    if (((uint16_t)(*l_485) << (uint16_t)(+__builtin_ffsll(l_564))))
                    { /* block id: 285 */
                        const int32_t *l_582 = (void*)0;
                        int32_t l_599 = 0xEB39617AL;
                        (*l_45) = ((uint16_t)0x7957L % (uint16_t)__builtin_ctz(((int16_t)(*l_485) >> (int16_t)13)));
                        l_584 = func_100((((*l_543) == l_581) | func_46(l_582, l_45)), l_583, func_49((*l_45)), l_583, (***l_543));
                        /* statement id: 287 */
                        assert (l_584 == 0);
                        (*l_549) = (*l_549);
                        (**l_581) = (((int16_t)(((uint16_t)((0x3A72A4CAL || (***l_543)) & 4UL) >> (uint16_t)((int16_t)((int64_t)((uint64_t)(***l_543) + (uint64_t)((***l_543) >= 0x52B89B73L)) / (int64_t)((int32_t)(*l_499) * (int32_t)(((((int16_t)(*l_499) >> (int16_t)(((-9L) < l_599) ^ 0x692DL)) ^ (****l_559)) ^ (*l_45)) == (*l_485)))) << (int16_t)0)) || (*l_485)) >> (int16_t)(*l_485)) > (*l_499));
                    }
                    else
                    { /* block id: 290 */
                        int64_t l_602 = 1L;
                        (*l_487) = (void*)0;
                        /* statement id: 291 */
                        assert (l_45 == 0);
                        (*l_485) = ((uint16_t)(l_602 | ((int16_t)((*l_584) ^ (l_564 && (l_602 < l_602))) + (int16_t)__builtin_popcountll((*l_485)))) % (uint16_t)(func_51((*l_485)) | (*l_485)));
                        return l_605;
                    }
                    /* facts after branching */
                    assert (l_584 == 0);
                }
                else
                { /* block id: 295 */
                    const int32_t *l_608 = &l_36;
                    int32_t *l_619 = &l_500;
                    for (l_36 = 0; (l_36 <= (-14)); --l_36)
                    { /* block id: 298 */
                        int32_t *l_609 = &l_500;
                        const uint8_t l_618 = 0x72L;
                        (*l_619) = (((func_46(l_608, l_609) | ((uint64_t)((((*l_498) >= func_51(func_69(((***l_543) > (((float)(((float)func_46((**l_543), l_45) - (float)((((float)(0x0.4D19CBp+83 < (*l_609)) / (float)(**l_487)) > (*l_485)) <= (*l_584))) >= 0xB.67C041p-51) / (float)(-0x1.5p-1)) > (**l_581))), l_618, (*l_609), (***l_559), l_619))) > 1UL) | 0xEB2FL) + (uint64_t)0UL)) || (*l_485)) == (*l_485));
                        (*l_559) = (*l_559);
                    }
                    l_622 = l_620;
                    /* statement id: 302 */
                    assert (l_622 == &l_621);
                }
                /* facts after branching */
                assert (l_498 == &l_36 || l_498 == 0);
                assert (l_584 == &l_500 || l_584 == 0);
                assert (l_622 == &l_621 || l_622 == &l_543);
            }
            else
            { /* block id: 304 */
                const float *l_623 = &l_35;
                float *l_624 = &l_35;
                (*l_624) = (l_623 != (void*)0);
                (*l_549) = (void*)0;
                (**l_529) = func_46(l_624, func_49(((int16_t)(*l_485) + (int16_t)(l_624 != (void*)0))));
            }
            /* facts after branching */
            assert (l_45 == &l_36 || l_45 == &l_500);
            assert (l_498 == &l_36 || l_498 == 0);
            assert (l_530 == &l_500 || l_530 == 0 || l_530 == &l_36);
            assert (l_622 == &l_621 || l_622 == &l_543);
        }
        else
        { /* block id: 309 */
            for (l_37 = (-14); (l_37 < (-1)); l_37++)
            { /* block id: 312 */
                const int64_t l_631 = 0xB02CC89C15BFE9B3LL;
                (****l_620) = (0UL != (1L != l_631));
                (*l_45) = l_631;
                (**l_621) = (**l_621);
            }
        }
        /* facts after branching */
        assert (l_45 == &l_36 || l_45 == &l_500);
        assert (l_530 == &l_500 || l_530 == 0 || l_530 == &l_36);
    }
    else
    { /* block id: 318 */
        int32_t *l_632 = (void*)0;
        (*l_529) = l_632;
        /* statement id: 319 */
        assert (l_530 == 0);
    }
    /* facts after branching */
    assert (l_530 == &l_500 || l_530 == 0 || l_530 == &l_36);
    (*l_571) = (*l_571);
    (*l_529) = (*l_529);
    l_633 = __builtin_bswap32((*l_499));
    return l_634;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_46(const int32_t * p_47, int32_t * p_48)
{ /* block id: 249 */
    float l_480 = 0x1.Fp+1;
    float *l_481 = &l_480;
    float ****l_483 = (void*)0;
    float *****l_482 = &l_483;
    int32_t l_484 = (-8L);
    (*l_481) = (l_480 >= 0xD.1B2D6Cp-36);
    l_482 = (void*)0;
    /* statement id: 251 */
    assert (l_482 == 0);
    return l_484;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(uint16_t  p_50)
{ /* block id: 39 */
    uint16_t l_53 = 0x9FA1L;
    int32_t l_435 = 0x709E21C6L;
    int32_t *l_434 = &l_435;
    int32_t **l_433 = &l_434;
    int32_t l_454 = 0x8B0E59E1L;
    float *l_455 = (void*)0;
    float *l_456 = (void*)0;
    float *l_457 = (void*)0;
    float l_459 = 0x3.9174A0p-50;
    float *l_458 = &l_459;
    int32_t *l_464 = &l_435;
    int32_t *l_465 = &l_435;
    int32_t *l_469 = (void*)0;
    int32_t *l_474 = &l_435;
    int32_t *l_477 = &l_435;
    int32_t *l_478 = &l_435;
    int32_t *l_479 = (void*)0;
lbl_446:
    if (func_51((l_53 <= ((uint64_t)func_56((1L >= l_53)) / (uint64_t)((uint16_t)((!l_53) == p_50) >> (uint16_t)12)))))
    { /* block id: 229 */
        int32_t l_432 = (-7L);
        int32_t *l_431 = &l_432;
        (*l_431) = p_50;
        if (l_53)
            goto lbl_446;
    }
    else
    { /* block id: 231 */
        int32_t *l_436 = &l_435;
        int32_t *** const *l_444 = (void*)0;
        int32_t *** const ** const l_443 = &l_444;
        int32_t *** const **l_445 = (void*)0;
        (*l_433) = l_436;
        (*l_433) = func_82((*l_436), (*l_434), &l_436, l_436, ((int16_t)0L - (int16_t)(((p_50 != ((l_443 != l_445) >= (p_50 != p_50))) < (**l_433)) <= 0xF9A5C36CL)));
    }
    (*l_458) = func_69(func_69(p_50, p_50, ((((+p_50) || ((int16_t)(p_50 != __builtin_parity((*l_434))) - (int16_t)((uint16_t)((uint16_t)(**l_433) >> (uint16_t)__builtin_ctzll(((p_50 || p_50) | (**l_433)))) - (uint16_t)p_50))) != p_50) || 0L), (*l_433), (*l_433)), p_50, p_50, (*l_433), (*l_433));
    if ((0xE81E2D41L < (~((*l_434) || (&l_455 != (void*)0)))))
    { /* block id: 237 */
        int32_t *l_463 = &l_435;
        int32_t *l_466 = &l_435;
        int32_t *l_467 = &l_435;
        int32_t *l_468 = &l_435;
        return l_469;
        /* statement id: 238 */
        //assert (func_49_rv == 0);
    }
    else
    { /* block id: 239 */
        int32_t *l_470 = &l_435;
        int32_t *l_472 = &l_435;
        int32_t *l_475 = (void*)0;
        if (p_50)
        { /* block id: 240 */
            int32_t *l_471 = &l_435;
            int32_t *l_473 = &l_435;
            return l_475;
            /* statement id: 241 */
            //assert (func_49_rv == 0);
        }
        else
        { /* block id: 242 */
            int32_t *l_476 = &l_435;
            (*l_458) = p_50;
            (*l_433) = l_476;
        }
        (*l_458) = 0x6.BFACAAp-81;
    }
    return l_479;
    /* statement id: 248 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_51(int64_t  p_52)
{ /* block id: 227 */
    uint64_t l_430 = 18446744073709551614UL;
    return l_430;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_56(uint32_t  p_57)
{ /* block id: 40 */
    uint64_t l_60 = 1UL;
    int32_t l_64 = 0L;
    int32_t *l_63 = &l_64;
    int32_t *l_231 = &l_64;
    int32_t ** const l_234 = &l_63;
    int32_t ** const *l_233 = &l_234;
    int32_t ** const **l_232 = &l_233;
    const int32_t *l_244 = (void*)0;
    float l_338 = 0x1.Ep-1;
    float **l_356 = (void*)0;
    float ***l_355 = &l_356;
    float *** const *l_354 = &l_355;
    const uint16_t l_366 = 7UL;
    float *l_420 = &l_338;
    float l_422 = 0x0.6p+1;
    const int32_t l_425 = 0xA51E5D32L;
    int32_t **l_426 = &l_231;
    for (p_57 = (-23); (p_57 > 36); ++p_57)
    { /* block id: 43 */
        return l_60;
    }
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_65(uint8_t  p_66, int32_t ** p_67)
{ /* block id: 47 */
    int16_t l_75 = 0x3FA0L;
    const int32_t l_81 = 0L;
    const int32_t *l_80 = &l_81;
    int32_t l_99 = 1L;
    int32_t *l_98 = &l_99;
    int32_t **l_97 = &l_98;
    uint8_t l_138 = 0x5EL;
    const int32_t **l_166 = &l_80;
    const int32_t ***l_165 = &l_166;
    const int32_t ****l_164 = &l_165;
    if (((((func_69(l_75, p_66, ((int16_t)((uint16_t)0x224BL % (uint16_t)0xD7AEL) % (int16_t)2UL), l_80, func_82(((uint16_t)((int64_t)((**p_67) <= __builtin_bswap64((p_66 | (((uint32_t)(((~((int64_t)(*l_80) + (int64_t)(*l_80))) & p_66) || (*l_80)) % (uint32_t)(*l_80)) ^ p_66)))) + (int64_t)(*l_80)) >> (uint16_t)0), (*l_80), l_97, (*l_97), (*l_98))) | (*l_80)) || p_66) ^ (**p_67)) != l_138))
    { /* block id: 61 */
        const int32_t *l_143 = &l_99;
        float l_145 = (-0x1.7p+1);
        float *l_144 = &l_145;
        int32_t l_148 = (-1L);
        uint32_t l_150 = 2UL;
        (*l_144) = (p_66 > ((__builtin_popcount(func_69(((float)p_66 + (float)p_66), (p_66 && (*l_80)), ((*l_98) ^ ((int16_t)__builtin_clz(p_66) >> (int16_t)4)), l_143, (*p_67))) <= 0x1.1p-1) <= 0x2.Cp-1));
        for (l_138 = 0; (l_138 == 59); l_138 += 1)
        { /* block id: 65 */
            int32_t l_149 = 0xE80F8EF8L;
            int32_t ***l_151 = &l_97;
        }
    }
    else
    { /* block id: 68 */
        int32_t ** const *l_152 = &l_97;
        int32_t *l_183 = &l_99;
lbl_200:
        (**l_97) = func_69(p_66, (p_66 < func_69((*l_98), (l_152 == (void*)0), (p_66 & (*l_98)), (*l_97), (*p_67))), p_66, (**l_152), (**l_152));
        if ((***l_152))
        { /* block id: 70 */
            int32_t ***l_156 = &l_97;
            int32_t ****l_155 = &l_156;
            int32_t ****l_163 = (void*)0;
            float l_168 = 0x8.CAAAA3p-49;
            float *l_167 = &l_168;
            for (l_75 = 0; (l_75 > 0); l_75++)
            { /* block id: 73 */
                const int32_t ** const **l_158 = (void*)0;
                const int32_t ** const ***l_157 = &l_158;
                float l_162 = 0x7.8p+1;
                float *l_161 = &l_162;
                (*l_157) = l_155;
                /* statement id: 74 */
                assert (l_158 == &l_156);
                (*l_161) = ((float)0x1.6p+1 - (float)p_66);
            }
            (**p_67) = ((&p_67 != (void*)0) < (p_66 > p_66));
            (*l_167) = ((***l_152) > (l_163 == l_164));
            if ((**p_67))
            { /* block id: 79 */
                float **l_171 = (void*)0;
                int32_t l_178 = 2L;
                int32_t ***l_181 = &l_97;
                int32_t * const *l_197 = &l_183;
                int32_t * const **l_196 = &l_197;
                if ((**p_67))
                { /* block id: 80 */
                    const int16_t l_174 = 0xDC82L;
                    for (l_138 = 0; (l_138 != 37); l_138++)
                    { /* block id: 83 */
                        float * const *l_173 = &l_167;
                        float * const **l_172 = &l_173;
                        (*l_172) = l_171;
                        /* statement id: 84 */
                        assert (l_173 == 0);
                        (****l_155) = l_174;
                        (*l_167) = (!0x1.F40A76p+79);
                        (***l_164) = (*p_67);
                        /* statement id: 87 */
                        //assert (l_80 == &l_64 || l_80 == &l_500);
                    }
                    /* facts after for loop */
                    //assert (l_80 == &l_64 || l_80 == &l_81 || l_80 == &l_99 || l_80 == &l_500);
                    if (((__builtin_parityl(p_66) <= ((p_66 & ((uint32_t)0x304CA522L / (uint32_t)(**l_97))) < p_66)) && l_178))
                    { /* block id: 89 */
                        (***l_164) = func_100(((int16_t)__builtin_clzl(p_66) << (int16_t)2), (*l_156), func_82(l_174, (***l_152), p_67, (*p_67), p_66), (*l_152), (**l_97));
                        /* statement id: 90 */
                        assert (l_80 == &l_99);
                    }
                    else
                    { /* block id: 91 */
                        int32_t ***l_182 = &l_97;
                        l_182 = l_181;
                        return p_67;
                        /* statement id: 93 */
                        //assert (func_65_rv == &l_63 || func_65_rv == &l_360 || func_65_rv == &l_530);
                    }
                    /* facts after branching */
                    assert (l_80 == &l_99);
                }
                else
                { /* block id: 95 */
                    int64_t l_187 = 1L;
                    (**l_181) = l_183;
                    (*p_67) = (*p_67);
                    for (l_99 = 17; (l_99 > 4); l_99 -= 1)
                    { /* block id: 100 */
                        uint16_t l_186 = 8UL;
                        if (l_186)
                            break;
                        if ((**p_67))
                            continue;
                        (**p_67) = 0xBD7B545DL;
                        (*l_167) = (__builtin_bswap64(l_187) == ((float)((***l_181) == ((float)(***l_165) / (float)((float)(-0x1.3p-1) / (float)p_66))) + (float)(&l_163 != &l_155)));
                    }
                }
                (**l_197) = (((uint32_t)(&p_67 == l_196) + (uint32_t)(**p_67)) == ((int16_t)p_66 >> (int16_t)((*p_67) == (*p_67))));
                if (l_75)
                    goto lbl_200;
            }
            else
            { /* block id: 109 */
                int32_t l_201 = (-1L);
                (**l_165) = func_100(l_201, p_67, (**l_152), p_67, l_201);
                /* statement id: 110 */
                //assert (l_80 == &l_64 || l_80 == &l_500);
            }
            /* facts after branching */
            //assert (l_80 == &l_64 || l_80 == &l_81 || l_80 == &l_99 || l_80 == &l_500);
        }
        else
        { /* block id: 112 */
            float l_203 = (-0x1.1p-1);
            float *l_202 = &l_203;
            const int32_t l_206 = 8L;
            const int32_t *l_207 = (void*)0;
            int32_t **l_208 = &l_183;
            (*l_202) = (-0x3.6p+1);
            (**p_67) = ((int16_t)(*l_183) / (int16_t)1UL);
        }
        /* facts after branching */
        //assert (l_80 == &l_64 || l_80 == &l_81 || l_80 == &l_99 || l_80 == &l_500);
    }
    /* facts after branching */
    //assert (l_80 == &l_64 || l_80 == &l_81 || l_80 == &l_99 || l_80 == &l_500);
    return p_67;
    /* statement id: 117 */
    //assert (func_65_rv == &l_63 || func_65_rv == &l_360 || func_65_rv == &l_530);
}


/* ------------------------------------------ */
/* 
 * reads : l_64
 * writes: l_64 l_500
 */
inline static int64_t  func_69(float  p_70, const int32_t  p_71, int32_t  p_72, const int32_t * p_73, int32_t * p_74)
{ /* block id: 57 */
    uint64_t l_137 = 0x463C3EAA4BB8C655LL;
    (*p_74) = ((uint16_t)l_137 << (uint16_t)0);
    (*p_74) = (*p_73);
    return l_137;
}


/* ------------------------------------------ */
/* 
 * reads : l_63 l_64 l_360 l_530 l_500
 * writes:
 */
static int32_t * func_82(uint16_t  p_83, int32_t  p_84, int32_t ** p_85, int32_t * p_86, int64_t  p_87)
{ /* block id: 48 */
    uint8_t l_114 = 0x10L;
    int32_t l_121 = (-1L);
    int32_t *l_120 = &l_121;
    int32_t ** const l_119 = &l_120;
    int32_t **l_124 = &l_120;
    int32_t **l_134 = &l_120;
    (*l_124) = func_100((**p_85), func_106(((l_114 == (p_87 || (+(l_114 | ((*p_85) != (*p_85)))))) < (l_114 <= p_87)), __builtin_clz(l_114), p_87, p_84, p_83), (*p_85), l_119, (*l_120));
    (*l_134) = func_100(((**p_85) >= ((((uint32_t)(((**p_85) && ((**p_85) == (((uint16_t)(&l_120 != &p_86) << (uint16_t)(**l_119)) & ((int64_t)((uint16_t)(*l_120) << (uint16_t)10) + (int64_t)(((**l_119) == ((-(uint64_t)(p_87 != 1L)) | 0xB020L)) >= (**p_85)))))) & (*l_120)) + (uint32_t)0xF981355DL) != 0x1C1E79BFF94FF55BLL) | (*l_120))), &l_120, (*p_85), &l_120, (**l_124));
    return (*p_85);
    /* statement id: 56 */
    //assert (func_82_rv == &l_99 || func_82_rv == &l_64 || func_82_rv == &l_435 || func_82_rv == &l_500 || func_82_rv == &l_36);
}


/* ------------------------------------------ */
/* 
 * reads : l_63 l_360 l_530
 * writes:
 */
static const int32_t * func_100(int32_t  p_101, int32_t ** p_102, int32_t * p_103, int32_t ** const  p_104, const int32_t  p_105)
{ /* block id: 52 */
    int32_t l_123 = 3L;
    const int32_t *l_122 = &l_123;
    return (*p_104);
    /* statement id: 53 */
    //assert (func_100_rv == &l_121 || func_100_rv == &l_99 || func_100_rv == &l_64 || func_100_rv == &l_500 || func_100_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_106(int64_t  p_107, int16_t  p_108, int16_t  p_109, uint32_t  p_110, uint16_t  p_111)
{ /* block id: 49 */
    int32_t l_117 = (-6L);
    int32_t *l_116 = &l_117;
    int32_t **l_118 = (void*)0;
    (*l_116) = 0L;
    return l_118;
    /* statement id: 51 */
    //assert (func_106_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 186
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 135
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 4
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 18, occurrence: 3
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 2
   depth: 27, occurrence: 2

XXX total number of pointers: 154

XXX times a variable address is taken: 158
XXX times a pointer is dereferenced on RHS: 205
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 45
   depth: 3, occurrence: 21
   depth: 4, occurrence: 11
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 17
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 650

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 605
   level: 2, occurrence: 277
   level: 3, occurrence: 85
   level: 4, occurrence: 41
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 79
XXX number of pointers point to scalars: 75
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.9
XXX average alias set size: 1.43

XXX times a non-volatile is read: 983
XXX times a non-volatile is write: 256
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 114
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 15
   depth: 2, occurrence: 14
   depth: 3, occurrence: 17
   depth: 4, occurrence: 14
   depth: 5, occurrence: 28

XXX percentage a fresh-made variable is used: 17.3
XXX percentage an existing variable is used: 82.7
********************* end of statistics **********************/

