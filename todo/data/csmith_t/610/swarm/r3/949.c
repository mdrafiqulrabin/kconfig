/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2619323940
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint8_t g_3 = 1U;
static int32_t g_67 = 0x7EA82BC9;
static int32_t *g_66[3] = {&g_67,&g_67,&g_67};
static int32_t g_106[9][4] = {{2,9,(-1),9},{2,0x4440DB5B,(-1),0x4440DB5B},{2,9,(-1),9},{2,0x4440DB5B,(-1),0x4440DB5B},{2,9,(-1),9},{2,0x4440DB5B,(-1),0x4440DB5B},{2,9,(-1),9},{2,0x4440DB5B,(-1),0x4440DB5B},{2,9,(-1),9}};
static int32_t g_131 = 0xF8B30C50;
static int32_t *g_194 = &g_67;
static int32_t **g_193 = &g_194;
static int32_t ***g_262 = &g_193;
static int32_t g_345 = 1;
static uint32_t g_355 = 0x9AB7FDA8;
static int32_t ****g_382 = &g_262;
static int32_t *****g_381 = &g_382;
static int32_t *g_401 = &g_106[0][1];
static int32_t g_519 = 0x5CFA0B70;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_28(void);
inline static uint32_t  func_31(uint8_t  p_32, uint32_t  p_33);
static int16_t  func_43(uint16_t  p_44, uint8_t  p_45, uint8_t  p_46, int32_t  p_47);
inline static int32_t  func_58(int32_t  p_59, uint32_t  p_60, int32_t  p_61, uint32_t  p_62);
inline static int32_t * func_69(int32_t ** p_70);
inline static int32_t * func_72(int32_t  p_73, int32_t ** p_74, int32_t * p_75, int32_t  p_76, int32_t ** p_77);
static int32_t ** func_78(uint16_t  p_79, int32_t * p_80, int32_t ** p_81, uint32_t  p_82, int32_t  p_83);
static int16_t  func_92(int32_t * p_93, uint16_t  p_94, int32_t * p_95);
static int8_t  func_112(int16_t  p_113, int32_t  p_114, int32_t ** p_115, uint16_t  p_116, uint16_t  p_117);
inline static int16_t  func_123(uint32_t  p_124, int32_t * p_125);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_67 g_262 g_193 g_194 g_106 g_131 g_66 g_345 g_355 g_381 g_382 g_401 g_519
 * writes: g_66 g_3 g_106 g_194 g_131 g_67 g_355 g_345 g_519 g_382
 */
static uint16_t  func_28(void)
{ /* block id: 36 */
    uint8_t l_34 = 0x98;
    uint32_t l_440 = 0xEB3B8670;
    int32_t *l_461[2];
    uint32_t l_480[8][6] = {{1U,0x3579D285,1U,4294967288U,0U,4294967288U},{1U,4294967288U,0x902092CF,1U,1U,1U},{0x902092CF,4294967288U,0x902092CF,1U,1U,1U},{0x902092CF,4294967288U,0x902092CF,1U,1U,1U},{0x902092CF,4294967288U,0x902092CF,1U,1U,1U},{0x902092CF,4294967288U,0x902092CF,1U,1U,1U},{0x902092CF,4294967288U,0x902092CF,1U,1U,1U},{0x902092CF,4294967288U,0x902092CF,1U,1U,1U}};
    int32_t *****l_490 = (void*)0;
    int32_t l_506[6];
    uint16_t l_522 = 65535U;
    int32_t l_538 = 1;
    int i, j;
    for (i = 0; i < 2; i++)
        l_461[i] = (void*)0;
    for (i = 0; i < 6; i++)
        l_506[i] = 0;
    if (((uint32_t)func_31(l_34, l_34) - (uint32_t)((((((uint16_t)(l_34 < l_34) % (uint16_t)((int16_t)g_345 >> (int16_t)((uint16_t)__builtin_popcount((((((g_355 >= ((uint8_t)((int8_t)((1U | l_34) < g_345) * (int8_t)0xA7) / (uint8_t)l_34)) >= g_355) & g_345) ^ l_34) > g_355)) >> (uint16_t)g_355))) || l_440) ^ l_34) == 1) < (-1))))
    { /* block id: 301 */
        for (g_67 = 3; (g_67 >= 0); g_67 -= 1)
        { /* block id: 304 */
            (*g_193) = (****g_381);
            for (g_355 = 0; (g_355 <= 3); g_355 += 1)
            { /* block id: 308 */
                int i, j;
                if (g_106[(g_355 + 1)][g_67])
                    break;
                if (g_106[(g_355 + 3)][g_67])
                    continue;
                g_106[g_355][g_355] = g_106[(g_67 + 3)][g_67];
            }
            (*g_401) = __builtin_ffsl(((void*)0 != (*g_381)));
            for (g_345 = 0; (g_345 <= 3); g_345 += 1)
            { /* block id: 316 */
                int i, j;
                (*g_193) = &g_106[(g_345 + 2)][g_345];
                /* statement id: 317 */
                assert ((g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]));
            }
        }
    }
    else
    { /* block id: 320 */
        uint32_t l_443 = 0x66BB26CB;
        int32_t **l_446 = &g_194;
        int32_t l_462 = 0;
        uint16_t l_469 = 0xBB47;
        int16_t l_526[7][9][1] = {{{0},{0x1142},{(-3)},{0xC842},{(-3)},{0x1142},{0},{0x747A},{(-10)}},{{1},{1},{1},{(-10)},{0x747A},{0},{0x1142},{(-3)},{0xC842}},{{(-3)},{0x1142},{0},{0x747A},{(-10)},{1},{1},{1},{(-10)}},{{0x747A},{0},{0x1142},{(-3)},{0xC842},{(-3)},{0x1142},{0},{0x747A}},{{(-10)},{1},{1},{1},{(-10)},{0x747A},{0},{0x1142},{(-3)}},{{0xC842},{(-3)},{0x1142},{0},{0x747A},{(-10)},{1},{1},{1}},{{(-10)},{0x747A},{0},{0x1142},{(-3)},{0xC842},{(-3)},{0x1142},{0}}};
        int i, j, k;
        for (g_355 = 0; (g_355 <= 2); g_355 += 1)
        { /* block id: 323 */
            uint16_t l_449 = 65535U;
            int32_t **l_452 = &g_401;
            uint8_t l_460 = 248U;
        }
        for (g_345 = 0; (g_345 >= (-20)); g_345 -= 7)
        { /* block id: 397 */
            int32_t *l_539[1];
            int i;
            for (i = 0; i < 1; i++)
                l_539[i] = (void*)0;
            for (g_3 = 17; (g_3 >= 53); g_3++)
            { /* block id: 400 */
                uint16_t l_540[8];
                int i;
                for (i = 0; i < 8; i++)
                    l_540[i] = 0x161B;
                for (g_519 = 0; (g_519 <= 3); g_519 += 1)
                { /* block id: 403 */
                    int i, j;
                    for (l_469 = 0; (l_469 <= 5); l_469 += 1)
                    { /* block id: 406 */
                        int i, j;
                        if (g_106[(l_469 + 3)][g_519])
                            break;
                        return l_506[g_519];
                    }
                    g_106[g_519][g_519] = ((uint8_t)g_106[(g_519 + 1)][g_519] / (uint8_t)g_106[(g_519 + 3)][g_519]);
                }
                (****g_381) = l_539[0];
                /* statement id: 412 */
                assert (g_194 == 0);
                (*g_381) = (*g_381);
                (*g_401) = l_540[7];
            }
        }
        (*g_381) = (*g_381);
    }
    /* facts after branching */
    //assert ((g_66[0] >= &g_106[0][0] && g_66[0] <= &g_106[8][3]) || g_66[0] == 0 || g_66[0] == &g_67);
    assert ((g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]) || g_194 == 0 || g_194 == &g_67);
    for (g_67 = 0; (g_67 == (-28)); g_67 -= 1)
    { /* block id: 421 */
        int32_t *l_545 = &l_506[2];
        int32_t *****l_558 = &g_382;
        uint32_t l_563 = 0x61204A06;
        for (l_34 = 25; (l_34 != 22); l_34 -= 1)
        { /* block id: 424 */
            (*g_193) = l_545;
            /* statement id: 425 */
            assert ((g_194 >= &l_506[0] && g_194 <= &l_506[5]));
            return g_106[2][1];
            /* statement id: 426 */
            //assert (g_194 == dangling);
        }
        (*l_545) = (*l_545);
        (****g_381) = l_545;
        /* statement id: 429 */
        assert ((g_194 >= &l_506[0] && g_194 <= &l_506[5]));
        if (((uint16_t)g_3 >> (uint16_t)((((uint8_t)((((int32_t)(g_355 <= (*l_545)) / (int32_t)((uint32_t)((uint8_t)((uint32_t)((void*)0 == l_558) - (uint32_t)(***g_262)) / (uint8_t)((int16_t)(g_106[4][2] || ((uint32_t)(*l_545) - (uint32_t)((*****l_558) >= g_519))) * (int16_t)g_131)) + (uint32_t)4294967290U)) & g_131) != (*****l_558)) % (uint8_t)g_519) == g_106[7][0]) == 8U)))
        { /* block id: 430 */
            if (l_563)
                break;
            (****l_558) = (**g_262);
        }
        else
        { /* block id: 433 */
            uint8_t l_566 = 248U;
            for (l_538 = (-9); (l_538 != (-3)); l_538 += 3)
            { /* block id: 436 */
                (****g_381) = (****g_381);
            }
            if ((*****l_558))
                continue;
            (****g_382) = __builtin_ctzll(g_345);
            (**g_193) = func_123(l_566, (***g_382));
        }
    }
    /* facts after for loop */
    assert ((g_194 >= &l_506[0] && g_194 <= &l_506[5]) || (g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]) || g_194 == 0 || g_194 == &g_67);
    return g_106[1][3];
    /* statement id: 444 */
    //assert (g_194 == dangling || (g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]) || g_194 == 0 || g_194 == &g_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_67 g_262 g_193 g_194 g_106 g_131 g_66 g_345 g_355 g_381
 * writes: g_66 g_3 g_106 g_194 g_131 g_67
 */
inline static uint32_t  func_31(uint8_t  p_32, uint32_t  p_33)
{ /* block id: 37 */
    uint32_t l_48 = 0U;
    uint32_t l_356 = 0x31EC438B;
    int32_t l_369 = 0x751AF70A;
    int8_t l_405 = (-5);
    int32_t **l_421 = &g_66[0];
    if (((int8_t)((int16_t)(-1) << (int16_t)((uint16_t)((((((uint16_t)(65533U == func_43((l_48 >= ((uint16_t)(-(uint32_t)(((uint16_t)((int32_t)((int32_t)l_48 % (int32_t)func_58(l_48, g_3, l_48, (((uint32_t)4294967287U - (uint32_t)(0 > g_3)) >= g_3))) - (int32_t)p_33) % (uint16_t)g_355) > g_355)) + (uint16_t)l_356)), l_356, l_356, l_356)) - (uint16_t)l_356) | 0x7A8B) ^ p_33) >= l_48) & 0x1DA39915) >> (uint16_t)p_32)) >> (int8_t)5))
    { /* block id: 249 */
        int32_t *l_368 = (void*)0;
        int32_t l_372 = 0xC5C848CC;
        l_369 = __builtin_popcountll(g_3);
        l_369 = (((uint8_t)(l_372 < ((int8_t)((int16_t)g_355 * (int16_t)((uint32_t)__builtin_ffs(p_32) - (uint32_t)l_356)) * (int8_t)(g_106[7][0] >= ((int16_t)((void*)0 != g_381) + (int16_t)0xB1C1)))) - (uint8_t)g_345) ^ g_131);
    }
    else
    { /* block id: 252 */
        int32_t *l_383 = &g_67;
        int8_t l_390 = 0;
        (*l_383) = p_33;
        for (g_131 = 0; (g_131 < 12); ++g_131)
        { /* block id: 256 */
            int32_t **l_406 = &l_383;
            int16_t l_407 = 0x2F3A;
            (*l_383) = p_33;
        }
    }
    /* facts after branching */
    //assert ((g_66[0] >= &g_106[0][0] && g_66[0] <= &g_106[8][3]) || g_66[0] == 0 || g_66[0] == &g_67);
    assert ((g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]) || g_194 == 0 || g_194 == &g_67);
    return l_356;
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_345
 * writes: g_67
 */
static int16_t  func_43(uint16_t  p_44, uint8_t  p_45, uint8_t  p_46, int32_t  p_47)
{ /* block id: 241 */
    int32_t *l_359 = &g_67;
    int32_t ****l_366 = (void*)0;
    int32_t *****l_365 = &l_366;
    if ((((uint32_t)(l_359 == &p_47) - (uint32_t)0xE8CD0CBD) ^ ((uint16_t)(p_47 || ((uint8_t)(__builtin_popcountll((*l_359)) & (+g_345)) >> (uint8_t)4)) << (uint16_t)15)))
    { /* block id: 242 */
        int32_t *****l_367 = &l_366;
        l_367 = l_365;
    }
    else
    { /* block id: 244 */
        (*l_359) = 0xE4E5EDCD;
        (*l_359) = 0x02FD1AE8;
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_3 g_262 g_193 g_194 g_106 g_131 g_66 g_345 g_355
 * writes: g_66 g_3 g_106 g_194 g_131 g_67
 */
inline static int32_t  func_58(int32_t  p_59, uint32_t  p_60, int32_t  p_61, uint32_t  p_62)
{ /* block id: 38 */
    int32_t **l_65[3];
    uint32_t l_68 = 4294967289U;
    int i;
    for (i = 0; i < 3; i++)
        l_65[i] = (void*)0;
    g_66[2] = (void*)0;
    l_68 = p_62;
    (*g_193) = func_69(l_65[1]);
    p_61 = 0;
    return g_355;
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_3 g_262 g_193 g_194 g_106 g_131 g_66 g_345
 * writes: g_66 g_3 g_106 g_194 g_131 g_67
 */
inline static int32_t * func_69(int32_t ** p_70)
{ /* block id: 41 */
    int32_t **l_71 = &g_66[2];
    int32_t l_86 = 0xE9DB3FA3;
    int16_t l_89[10] = {(-7),(-7),(-7),(-7),(-7),(-7),(-7),(-7),(-7),(-7)};
    int i;
    (*l_71) = &g_67;
    (*l_71) = func_72(g_67, func_78(((uint8_t)(l_86 | ((l_86 > (0x481DB3AA <= l_89[6])) < ((uint16_t)__builtin_ctz((func_92(&g_67, l_89[2], &g_67) != g_67)) % (uint16_t)g_67))) >> (uint8_t)4), &l_86, l_71, g_67, l_86), &g_67, l_89[6], (*g_262));
    /* statement id: 231 */
    assert (g_194 == 0);
    for (l_86 = 2; (l_86 >= 0); l_86 -= 1)
    { /* block id: 234 */
        int i;
        return g_66[l_86];
        /* statement id: 235 */
        //assert ((func_69_rv >= &g_106[0][0] && func_69_rv <= &g_106[8][3]) || func_69_rv == 0 || func_69_rv == &g_67);
    }
    return (*l_71);
    /* statement id: 237 */
    //assert ((func_69_rv >= &g_106[0][0] && func_69_rv <= &g_106[8][3]) || func_69_rv == 0 || func_69_rv == &g_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_194 g_3 g_106 g_345 g_67
 * writes: g_67 g_194 g_66 g_106
 */
inline static int32_t * func_72(int32_t  p_73, int32_t ** p_74, int32_t * p_75, int32_t  p_76, int32_t ** p_77)
{ /* block id: 221 */
    int32_t *l_332 = &g_106[8][0];
    uint32_t l_336[2];
    int i;
    for (i = 0; i < 2; i++)
        l_336[i] = 0xB12DA388;
    l_332 = (*p_74);
    /* statement id: 222 */
    assert (l_332 == 0 || l_332 == &g_67 || (l_332 >= &g_106[0][0] && l_332 <= &g_106[8][3]));
    for (p_76 = 0; (p_76 != 3); p_76++)
    { /* block id: 225 */
        int32_t **l_335 = &g_66[2];
        l_336[1] = (l_335 != &p_75);
        (*p_75) = ((uint32_t)(__builtin_bswap32(g_3) ^ (((int8_t)(-4) >> (int8_t)(((uint16_t)((uint8_t)g_106[2][1] << (uint8_t)g_345) * (uint16_t)g_67) > ((uint16_t)(((uint8_t)255U << (uint8_t)7) <= (~((int32_t)((int16_t)((g_345 && p_76) || l_336[1]) << (int16_t)5) % (int32_t)(*p_75)))) % (uint16_t)g_3))) & 0U)) + (uint32_t)(*p_75));
    }
    (*p_77) = (void*)0;
    return l_332;
    /* statement id: 230 */
    //assert (func_72_rv == 0 || func_72_rv == &g_67 || (func_72_rv >= &g_106[0][0] && func_72_rv <= &g_106[8][3]));
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_3 g_106 g_262 g_193
 * writes:
 */
static int32_t ** func_78(uint16_t  p_79, int32_t * p_80, int32_t ** p_81, uint32_t  p_82, int32_t  p_83)
{ /* block id: 217 */
    int8_t l_315 = 0x88;
    int32_t ****l_330 = &g_262;
    int32_t ***l_331 = &g_193;
    l_315 = ((uint16_t)__builtin_bswap64(((int16_t)0x47D6 >> (int16_t)12)) - (uint16_t)(p_79 <= ((uint32_t)((uint16_t)(g_67 || 1) + (uint16_t)0x18B2) - (uint32_t)1U)));
    (*p_80) = ((((((uint16_t)((((int32_t)((uint16_t)0x8C82 << (uint16_t)__builtin_bswap64(p_82)) - (int32_t)(((int32_t)(*p_80) - (int32_t)(*p_80)) ^ g_3)) <= g_106[6][2]) ^ 0x3DB9) << (uint16_t)2) >= (*p_80)) == p_83) < g_3) && 1);
    return (**l_330);
    /* statement id: 220 */
    //assert (func_78_rv == &g_194);
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_3 g_262 g_193 g_194 g_106 g_131 g_66
 * writes: g_3 g_106 g_66 g_194 g_131
 */
static int16_t  func_92(int32_t * p_93, uint16_t  p_94, int32_t * p_95)
{ /* block id: 43 */
    int8_t l_118 = 0x68;
    uint32_t l_245 = 4294967290U;
    int32_t l_272 = 1;
    int32_t l_294 = 0xA8C351D0;
    int32_t *l_299 = &g_106[7][0];
    for (p_94 = 6; (p_94 > 56); p_94 += 1)
    { /* block id: 46 */
        uint32_t l_104 = 0x786CB52F;
        int32_t *l_107 = &g_106[7][0];
        for (g_3 = 0; (g_3 != 7); g_3++)
        { /* block id: 49 */
            int32_t *l_105 = &g_106[7][0];
            (*l_105) = ((uint16_t)((int16_t)g_67 * (int16_t)(-9)) + (uint16_t)__builtin_ctzll(l_104));
        }
        g_66[1] = &g_106[4][3];
        (*l_107) = 0;
    }
    for (g_3 = 0; (g_3 > 9); g_3++)
    { /* block id: 57 */
        int8_t l_128 = 6;
        int32_t l_218[8] = {0x8C634FB4,0x8C634FB4,0x8C634FB4,0x8C634FB4,0x8C634FB4,0x8C634FB4,0x8C634FB4,0x8C634FB4};
        int i;
    }
    for (l_272 = 3; (l_272 >= 0); l_272 -= 1)
    { /* block id: 173 */
        uint32_t l_275 = 0x56744AC8;
        int32_t *l_295 = &g_106[2][0];
        (**g_262) = &l_272;
        /* statement id: 174 */
        assert (g_194 == &l_272);
        l_294 = (((int8_t)l_275 + (int8_t)((uint16_t)p_94 >> (uint16_t)((***g_262) <= __builtin_clzll(((uint16_t)p_94 - (uint16_t)((uint32_t)((int8_t)((((uint8_t)((int8_t)((uint16_t)((int8_t)(((int8_t)__builtin_ffs(l_275) >> (int8_t)(__builtin_bswap32(((l_275 | l_275) == 0x6F204968)) != 1)) < l_275) + (int8_t)0x65) % (uint16_t)l_245) >> (int8_t)p_94) % (uint8_t)p_94) != 8) ^ p_94) << (int8_t)l_275) + (uint32_t)g_106[2][3])))))) == 5U);
        (*l_295) = (*p_93);
        for (l_118 = 3; (l_118 >= 0); l_118 -= 1)
        { /* block id: 179 */
            int16_t l_300 = 6;
            int32_t *l_305 = &g_106[(l_272 + 2)][l_118];
            int i, j;
            if (((uint16_t)((func_112(__builtin_clzll(g_106[(l_272 + 1)][l_118]), g_106[(l_272 + 1)][l_118], (*g_262), g_106[(l_272 + 2)][l_118], p_94) | (g_3 && ((~g_67) != p_94))) && 1U) / (uint16_t)g_67))
            { /* block id: 180 */
                int i, j;
                (**g_262) = l_299;
                /* statement id: 181 */
                assert ((g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]));
                g_106[(l_272 + 4)][l_272] = ((g_67 >= g_67) > 1);
            }
            else
            { /* block id: 183 */
                if (func_112(g_67, g_106[5][1], (*g_262), p_94, g_106[(l_272 + 1)][l_118]))
                { /* block id: 184 */
                    int32_t *l_301 = (void*)0;
                    if (l_300)
                        break;
                    (**g_262) = l_301;
                    for (l_300 = 0; (l_300 <= 2); l_300 += 1)
                    { /* block id: 189 */
                        uint32_t l_304 = 0xB18F1BF9;
                        int i;
                        g_66[l_300] = g_66[l_300];
                        g_106[(l_272 + 1)][l_118] = ((uint16_t)p_94 >> (uint16_t)l_304);
                        g_66[l_300] = p_93;
                        (*l_299) = (p_94 != p_94);
                    }
                }
                else
                { /* block id: 195 */
                    int32_t l_306[2];
                    int i;
                    for (i = 0; i < 2; i++)
                        l_306[i] = (-1);
                    for (l_275 = 0; (l_275 <= 3); l_275 += 1)
                    { /* block id: 198 */
                        int i, j;
                        g_106[l_118][l_272] = (-8);
                        if ((*l_295))
                            break;
                        l_305 = &l_272;
                        /* statement id: 201 */
                        assert (l_305 == &l_272);
                        (**g_262) = p_93;
                        /* statement id: 202 */
                        assert (g_194 == &g_67);
                    }
                    /* facts after for loop */
                    assert (g_194 == &g_67 || g_194 == 0);
                    assert (l_305 == &l_272 || (l_305 >= &g_106[0][0] && l_305 <= &g_106[8][3]));
                    (*l_299) = l_306[1];
                }
                /* facts after branching */
                assert (g_194 == &g_67 || g_194 == 0);
                assert (l_305 == &l_272 || (l_305 >= &g_106[0][0] && l_305 <= &g_106[8][3]));
            }
            /* facts after branching */
            assert (g_194 == &g_67 || g_194 == 0 || (g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]));
            assert (l_305 == &l_272 || (l_305 >= &g_106[0][0] && l_305 <= &g_106[8][3]));
            (*g_193) = (void*)0;
            /* statement id: 207 */
            assert (g_194 == 0);
        }
        /* facts after for loop */
        assert (g_194 == 0 || g_194 == &l_272);
        for (l_275 = 0; (l_275 <= 2); l_275 += 1)
        { /* block id: 211 */
            int i, j;
            g_106[l_275][(l_275 + 1)] = g_106[(l_272 + 1)][l_275];
        }
    }
    /* facts after for loop */
    assert (g_194 == 0 || g_194 == &l_272 || g_194 == &g_67 || (g_194 >= &g_106[0][0] && g_194 <= &g_106[8][3]));
    (**g_262) = (void*)0;
    /* statement id: 215 */
    assert (g_194 == 0);
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads : g_193 g_131 g_194 g_106 g_67 g_3 g_66
 * writes: g_194 g_131 g_66 g_106
 */
static int8_t  func_112(int16_t  p_113, int32_t  p_114, int32_t ** p_115, uint16_t  p_116, uint16_t  p_117)
{ /* block id: 96 */
    int32_t *l_195 = (void*)0;
    int32_t l_196[2];
    int32_t *l_212 = &g_131;
    int32_t l_213 = 0xBCAD55B1;
    uint16_t l_214[7] = {0xDADB,0xDADB,0xDADB,0xDADB,0xDADB,0xDADB,0xDADB};
    int i;
    for (i = 0; i < 2; i++)
        l_196[i] = 0x7A0CA377;
    (*g_193) = l_195;
    /* statement id: 97 */
    assert (g_194 == 0 || g_194 == &g_67);
    if (l_196[1])
    { /* block id: 98 */
        int32_t *l_197 = (void*)0;
        int32_t l_198 = 0xCFF5D345;
        (*g_193) = l_197;
        l_198 = l_198;
        return p_116;
    }
    else
    { /* block id: 102 */
        int32_t *l_204 = &g_67;
        for (g_131 = 0; (g_131 <= 3); g_131 += 1)
        { /* block id: 105 */
            int32_t l_203 = 0x138C4916;
            (*p_115) = (*p_115);
            for (p_113 = 0; (p_113 <= 2); p_113 += 1)
            { /* block id: 109 */
                int16_t l_207 = 0xBA67;
                for (p_114 = 0; (p_114 <= 3); p_114 += 1)
                { /* block id: 112 */
                    int i, j;
                    g_66[p_113] = &g_106[(g_131 + 3)][g_131];
                    g_106[(p_113 + 2)][p_113] = ((uint8_t)(g_106[(p_113 + 6)][g_131] < 1) << (uint8_t)(0x3AEF != ((uint16_t)(g_106[(g_131 + 4)][g_131] < l_203) * (uint16_t)(((void*)0 == l_204) ^ ((uint8_t)g_106[7][0] + (uint8_t)(p_113 ^ p_113))))));
                    l_207 = (*l_204);
                }
            }
        }
    }
    (*l_212) = (p_114 ^ (p_113 ^ ((int8_t)func_123(((int16_t)g_67 / (int16_t)p_113), &l_196[0]) - (int8_t)l_213)));
    return l_214[0];
}


/* ------------------------------------------ */
/* 
 * reads : g_131 g_106 g_3 g_67
 * writes: g_106 g_131 g_66
 */
inline static int16_t  func_123(uint32_t  p_124, int32_t * p_125)
{ /* block id: 58 */
    int8_t l_130 = 0;
    int32_t **l_184[4] = {&g_66[0],&g_66[0],&g_66[0],&g_66[0]};
    int i;
    for (p_124 = 0; (p_124 <= 3); p_124 += 1)
    { /* block id: 61 */
        uint32_t l_129 = 0xAAAB22D3;
        int32_t l_154 = 1;
        (*p_125) = ((l_129 & l_130) <= l_130);
        for (l_129 = 0; (l_129 <= 2); l_129 += 1)
        { /* block id: 65 */
            int32_t l_167 = 0x9D5723DD;
            for (l_130 = 3; (l_130 >= 0); l_130 -= 1)
            { /* block id: 68 */
                uint32_t l_145 = 0xCDF46991;
                uint32_t l_183 = 0x5DD027D6;
                for (g_131 = 0; (g_131 <= 2); g_131 += 1)
                { /* block id: 71 */
                    int i, j;
                    if (((int16_t)(-(int32_t)((uint8_t)(((uint16_t)((int8_t)(((&g_66[g_131] != &g_66[g_131]) != g_106[(p_124 + 5)][(l_129 + 1)]) && (&g_66[2] == (void*)0)) * (int8_t)((uint16_t)(((g_3 < ((p_124 | g_106[2][3]) < (p_124 && 7U))) == 5) == l_145) << (uint16_t)3)) % (uint16_t)0x4144) ^ p_124) << (uint8_t)p_124)) >> (int16_t)l_129))
                    { /* block id: 72 */
                        int i, j;
                        g_106[(l_130 + 5)][l_129] = (&g_66[2] == (void*)0);
                        (*p_125) = g_106[(l_130 + 5)][l_129];
                        (*p_125) = (*p_125);
                    }
                    else
                    { /* block id: 76 */
                        int32_t *l_146 = &g_106[7][3];
                        int i;
                        g_66[l_129] = l_146;
                        return l_129;
                    }
                    return l_130;
                }
                for (g_131 = 2; (g_131 >= 0); g_131 -= 1)
                { /* block id: 84 */
                    int32_t l_181[7];
                    int32_t l_182 = 0x5F725835;
                    int i;
                    for (i = 0; i < 7; i++)
                        l_181[i] = 5;
                    if ((*p_125))
                        break;
                    (*p_125) = ((int8_t)((uint16_t)p_124 >> (uint16_t)((+((uint16_t)l_154 << (uint16_t)1)) <= g_106[7][0])) - (int8_t)l_145);
                    (*p_125) = (p_124 | ((int8_t)(p_124 >= (p_124 > (((int16_t)g_67 % (int16_t)g_106[8][1]) < p_124))) * (int8_t)(0xC5F0 || ((int8_t)((uint16_t)l_154 << (uint16_t)(((uint16_t)((((int16_t)g_106[7][0] - (int16_t)0xEFA4) ^ 1) <= (-1)) / (uint16_t)g_67) < l_167)) << (int8_t)g_106[0][3]))));
                    l_181[0] = ((g_131 & g_106[1][0]) ^ (((uint16_t)__builtin_ctz(g_3) + (uint16_t)(9U < ((((uint8_t)((((int8_t)(+((int16_t)((int8_t)l_130 - (int8_t)l_167) + (int16_t)((l_130 >= ((((((int16_t)g_131 - (int16_t)l_130) > 0x093E1FD8) ^ l_181[0]) == 0x1DA3) && 246U)) >= 0x32))) >> (int8_t)6) ^ l_182) > g_106[8][0]) + (uint8_t)g_106[7][0]) || l_183) <= l_181[6]))) > 0x07));
                }
                (*p_125) = ((((*p_125) <= ((void*)0 != l_184[3])) | (g_3 && 0x2C)) || p_124);
            }
        }
    }
    (*p_125) = (((((uint32_t)0xDFB547BD % (uint32_t)((uint16_t)((5U ^ p_124) || 0x29) * (uint16_t)(0U != ((int32_t)(*p_125) - (int32_t)((int8_t)((*p_125) & (p_124 < (0x6EAB1F27 && (*p_125)))) >> (int8_t)7))))) != (*p_125)) == 0x85C1) ^ g_106[4][2]);
    return g_3;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_67, "g_67", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        for (j = 0; j < 4; j++)
        {
            transparent_crc(g_106[i][j], "g_106[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_131, "g_131", print_hash_value);
    transparent_crc(g_345, "g_345", print_hash_value);
    transparent_crc(g_355, "g_355", print_hash_value);
    transparent_crc(g_519, "g_519", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 122
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 38
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 22, occurrence: 4
   depth: 27, occurrence: 1

XXX total number of pointers: 72

XXX times a variable address is taken: 75
XXX times a pointer is dereferenced on RHS: 96
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 26
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 86
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 4, occurrence: 5
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 521

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 396
   level: 2, occurrence: 132
   level: 3, occurrence: 43
   level: 4, occurrence: 17
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 34
XXX number of pointers point to scalars: 38
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.6
XXX average alias set size: 1.4

XXX times a non-volatile is read: 725
XXX times a non-volatile is write: 292
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 135
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 32
   depth: 2, occurrence: 21
   depth: 3, occurrence: 16
   depth: 4, occurrence: 16
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
********************* end of statistics **********************/

