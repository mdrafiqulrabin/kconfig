/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1105862918
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_30(void);
inline static uint8_t  func_48(int32_t * p_49, uint32_t  p_50);
static float  func_54(int32_t ** p_55, int32_t * p_56);
inline static const uint32_t  func_67(int32_t ** p_68, int32_t  p_69, int32_t ** p_70, uint32_t  p_71, int32_t * p_72);
static int32_t ** func_73(int32_t * p_74, int16_t  p_75, const int32_t  p_76);
inline static int32_t * func_77(int32_t  p_78, float  p_79);
inline static const int32_t * func_84(int32_t ** p_85, int16_t  p_86, int32_t  p_87, uint32_t  p_88);
inline static int32_t ** func_90(int32_t ** p_91, int32_t ** p_92);
static int32_t ** func_93(int32_t * p_94, int32_t ** p_95, uint16_t  p_96);
static int32_t * func_122(int32_t * p_123, int16_t  p_124, float * p_125);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_30(void)
{ /* block id: 36 */
    float l_33 = 0x7.C71042p-9;
    int32_t l_34 = 8;
    int32_t l_257 = 5;
    uint32_t l_258 = 0x8CC242C4;
    int32_t *l_259 = &l_34;
    int8_t l_260 = 0xB5;
    l_259 = (((1U > ((int8_t)l_34 - (int8_t)((void*)0 == &l_34))) , (((int8_t)((uint8_t)((uint8_t)((int16_t)((uint8_t)((uint16_t)(((((+(0x1A ^ func_48(&l_34, l_34))) < l_257) , l_257) && l_257) > 0x6E) - (uint16_t)l_257) % (uint8_t)l_257) >> (int16_t)8) >> (uint8_t)l_258) * (uint8_t)l_258) * (int8_t)l_257) <= l_257)) , &l_257);
    return l_260;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_48(int32_t * p_49, uint32_t  p_50)
{ /* block id: 37 */
    int32_t l_53 = 7;
    int32_t *l_52 = &l_53;
    int32_t **l_51 = &l_52;
    float *l_227 = (void*)0;
    const uint32_t l_229 = 0xA8DA92CE;
    int8_t l_243 = 0x32;
    int32_t ***l_256 = &l_51;
    int32_t ****l_255 = &l_256;
    (*l_51) = (void*)0;
lbl_254:
    if (((void*)0 != p_49))
    { /* block id: 39 */
        float l_222 = 0x4.64CFAAp+47;
        float *l_221 = &l_222;
        (*l_221) = func_54(&l_52, p_49);
    }
    else
    { /* block id: 108 */
        int8_t l_228 = (-4);
        (*l_51) = func_122(p_49, ((int8_t)((0x75 >= p_50) | (l_52 != l_227)) << (int8_t)1), p_49);
        (*l_52) = l_228;
    }
    if (((((l_53 == (((__builtin_popcount((p_50 , (p_49 != p_49))) >= l_229) >= ((uint32_t)(((((p_49 == (((uint16_t)((((uint8_t)p_50 - (uint8_t)(-1)) , p_50) && (-1)) % (uint16_t)p_50) , p_49)) && (-8)) , p_50) > 8U) <= p_50) % (uint32_t)0xBEDBEAE7)) , p_50)) > 2U) || (-1)) < 1U))
    { /* block id: 112 */
        int32_t **l_238 = &l_52;
        int32_t l_239 = (-1);
        int32_t *l_242 = &l_53;
        (*l_238) = p_49;
        (*l_52) = ((-1) ^ (__builtin_clzll((**l_238)) , (((int16_t)(__builtin_clzl((**l_238)) <= (((uint8_t)((int8_t)0xD6 << (int8_t)3) >> (uint8_t)7) , (*l_242))) + (int16_t)(**l_51)) || ((uint32_t)((uint16_t)p_50 - (uint16_t)0x3214) % (uint32_t)(**l_238)))));
        return (**l_238);
    }
    else
    { /* block id: 116 */
        if (p_50)
            goto lbl_254;
    }
    l_255 = (void*)0;
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads : l_34
 * writes: l_34
 */
static float  func_54(int32_t ** p_55, int32_t * p_56)
{ /* block id: 40 */
    int32_t l_63 = 0;
    int32_t *l_62 = &l_63;
    int32_t **l_61 = &l_62;
    uint32_t l_64 = 4U;
    const int32_t l_219 = 0x99F85C49;
    uint32_t l_220 = 0xA65D3118;
    if ((((int8_t)((0x11E9A9D0 | ((int16_t)(l_61 == (void*)0) >> (int16_t)7)) >= (((*p_55) != (void*)0) == l_64)) << (int8_t)0) , ((*l_62) , (**l_61))))
    { /* block id: 41 */
        int32_t l_80 = 0x6A5D0C9A;
        int32_t **l_198 = &l_62;
        (**l_61) = ((int8_t)__builtin_clzll((func_67(func_73(func_77((*l_62), l_80), l_80, (**l_61)), (*l_62), l_198, ((uint16_t)((__builtin_ctz((((*l_62) | (**l_198)) == 0xE4D920E9)) , (*p_55)) == (*p_55)) << (uint16_t)12), (*l_61)) < (**l_198))) << (int8_t)(**l_61));
    }
    else
    { /* block id: 100 */
        uint16_t l_204 = 6U;
        (*p_56) = (((l_204 , l_204) || ((void*)0 == p_56)) ^ (((void*)0 != p_56) != l_204));
        (*p_55) = (*p_55);
    }
    (*l_61) = (*p_55);
    (*p_55) = (((uint8_t)((func_67(func_73((*p_55), ((uint32_t)(!(((int8_t)((uint16_t)(!__builtin_ia32_crc32qi(l_63, l_64)) - (uint16_t)((uint8_t)(((int32_t)0 - (int32_t)((-2) && l_64)) && ((*p_56) && ((((l_64 & (*p_56)) , 0x7B0691E2) && (*p_56)) < 5U))) - (uint8_t)l_64)) - (int8_t)l_64) , 0x47)) + (uint32_t)0), l_219), l_64, &l_62, l_220, (*p_55)) , l_64) && 0xB265) - (uint8_t)l_219) , (*p_55));
    return l_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_67(int32_t ** p_68, int32_t  p_69, int32_t ** p_70, uint32_t  p_71, int32_t * p_72)
{ /* block id: 92 */
    for (p_69 = 0; (p_69 != 17); p_69 += 1)
    { /* block id: 95 */
        const uint32_t l_203 = 0U;
        return l_203;
    }
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_73(int32_t * p_74, int16_t  p_75, const int32_t  p_76)
{ /* block id: 88 */
    uint32_t l_185 = 5U;
    float l_187 = 0x7.3BC08Cp+82;
    float *l_186 = &l_187;
    int32_t l_195 = 0x36C4CAD9;
    int32_t *l_194 = &l_195;
    int32_t **l_193 = &l_194;
    int32_t **l_196 = &l_194;
    int32_t **l_197 = (void*)0;
    (*l_186) = (l_185 >= (l_185 > l_185));
    (*l_193) = &p_76;
    return l_197;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_77(int32_t  p_78, float  p_79)
{ /* block id: 42 */
    int32_t *l_81 = (void*)0;
    uint32_t l_108 = 3U;
    uint16_t l_119 = 0U;
    int32_t l_171 = (-1);
    int32_t *l_170 = &l_171;
    uint16_t l_176 = 1U;
    int32_t *l_181 = &l_171;
    int32_t *l_182 = &l_171;
    int32_t *l_183 = &l_171;
    int32_t *l_184 = (void*)0;
    if (((void*)0 != l_81))
    { /* block id: 43 */
        int32_t **l_99 = &l_81;
        for (p_78 = (-24); (p_78 < (-21)); p_78 += 1)
        { /* block id: 46 */
            uint32_t l_89 = 4294967290U;
            int32_t l_98 = (-3);
            int32_t *l_97 = &l_98;
            int32_t **l_167 = &l_97;
        }
        (*l_99) = &l_171;
    }
    else
    { /* block id: 81 */
        const int32_t *l_172 = &l_171;
        int32_t **l_173 = &l_170;
        float l_175 = 0x0.2p-1;
        float *l_174 = &l_175;
        (*l_173) = l_172;
        (*l_174) = (*l_170);
        (*l_170) = l_176;
    }
    (*l_170) = ((uint8_t)((uint8_t)(p_78 , (*l_170)) * (uint8_t)p_78) * (uint8_t)(*l_170));
    return l_184;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_84(int32_t ** p_85, int16_t  p_86, int32_t  p_87, uint32_t  p_88)
{ /* block id: 70 */
    const int32_t l_160 = 0;
    const int32_t *l_159 = &l_160;
    const int32_t *l_161 = &l_160;
    const int32_t *l_162 = &l_160;
    const int32_t *l_163 = &l_160;
    const int32_t *l_164 = &l_160;
    const int32_t *l_165 = &l_160;
    const int32_t *l_166 = (void*)0;
    return l_166;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_90(int32_t ** p_91, int32_t ** p_92)
{ /* block id: 61 */
    float l_145 = (-0x1.Fp+1);
    int32_t l_146 = 2;
    int32_t l_147 = 0xCB01B095;
    int32_t *l_150 = (void*)0;
    int32_t **l_149 = &l_150;
    const int32_t l_157 = 0x819B1619;
    uint8_t l_158 = 0xE4;
    if (l_146)
    { /* block id: 62 */
        int32_t *l_148 = &l_147;
        (*l_148) = l_147;
        return p_92;
    }
    else
    { /* block id: 65 */
        int32_t *l_151 = &l_146;
        (*p_92) = l_151;
    }
    (*p_92) = ((((uint8_t)(l_146 && (l_147 != (((((((l_146 <= ((int16_t)(((void*)0 != (*l_149)) , (l_146 < ((&l_149 == &l_149) || ((!0x6E) < (-8))))) + (int16_t)l_147)) , (-1)) <= l_147) ^ l_157) , l_158) , (**p_92)) ^ (**p_92)))) * (uint8_t)l_158) != 1U) , (*p_92));
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_93(int32_t * p_94, int32_t ** p_95, uint16_t  p_96)
{ /* block id: 47 */
    float l_121 = 0x0.0p-1;
    float *l_120 = &l_121;
    int32_t **l_126 = (void*)0;
    int32_t l_127 = (-7);
    int16_t l_134 = 0x3B95;
    (*l_120) = 0x8.DC7473p+65;
    (*p_95) = func_122((((&p_94 == l_126) ^ l_127) , &l_127), ((p_96 , ((uint16_t)((uint32_t)l_127 + (uint32_t)0x0B9F0A6C) - (uint16_t)0U)) , ((((((float)(((l_134 || 0xDA) >= 0x0912) , p_96) + (float)l_134) , p_96) , p_96) , p_96) , (-1))), p_94);
    return l_126;
}


/* ------------------------------------------ */
/* 
 * reads : l_98 l_34
 * writes: l_98 l_34
 */
static int32_t * func_122(int32_t * p_123, int16_t  p_124, float * p_125)
{ /* block id: 49 */
    int32_t l_137 = (-1);
    int32_t *l_136 = &l_137;
    int32_t **l_135 = &l_136;
    int32_t ***l_138 = &l_135;
    (*l_138) = l_135;
    (*l_135) = (**l_138);
    for (p_124 = 0; (p_124 < (-20)); p_124 -= 1)
    { /* block id: 54 */
        uint32_t l_144 = 0U;
        (*p_125) = (((float)(((+((*p_125) , p_124)) , l_144) >= (p_123 != ((l_144 > (*p_125)) , p_123))) - (float)((*l_138) != (void*)0)) <= (*p_125));
        (*p_125) = ((*p_125) >= (*p_125));
    }
    return p_123;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 67
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 57

XXX times a variable address is taken: 54
XXX times a pointer is dereferenced on RHS: 53
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 13
XXX times a pointer is dereferenced on LHS: 30
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 267

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 115
   level: 2, occurrence: 69
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 32
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.3
XXX average alias set size: 1.3

XXX times a non-volatile is read: 305
XXX times a non-volatile is write: 67
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 51
XXX max block depth: 1
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 21

XXX percentage a fresh-made variable is used: 9.45
XXX percentage an existing variable is used: 90.6
********************* end of statistics **********************/

