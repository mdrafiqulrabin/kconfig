/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3519875598
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 21;
   unsigned f1 : 22;
   unsigned : 0;
   signed f2 : 12;
};
#pragma pack(pop)

struct S1 {
   float  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   uint32_t  f6;
   int32_t  f7;
   int32_t  f8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static struct S0  func_2(float  p_3);
static float  func_6(float  p_7, int16_t  p_8, uint32_t  p_9, int16_t  p_10, int16_t  p_11);
static struct S0  func_13(int32_t  p_14, uint16_t  p_15);
static int32_t  func_20(struct S0  p_21, struct S1  p_22, struct S0  p_23);
static struct S0  func_24(uint16_t  p_25, uint32_t  p_26, int32_t  p_27, uint16_t  p_28, uint32_t  p_29);
static struct S1  func_33(int16_t  p_34);
static int32_t  func_38(struct S1  p_39, int32_t  p_40);
static struct S1  func_41(int32_t  p_42, int16_t  p_43, uint32_t  p_44, int32_t  p_45);
static int32_t  func_50(int16_t  p_51, int32_t  p_52, int32_t  p_53, uint16_t  p_54);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_12 = 0x3D0B5486;
    struct S1 l_31 = {0x1.0p-1,0x9B45C761,-2,0,0x55D48264,9,6U,0,0x4BB9CEC0};
    struct S0 l_32 = {292,792,-31};
    struct S0 *l_596 = &l_32;
    int32_t *l_651 = &l_31.f7;
    uint32_t l_665 = 4294967295U;
    int32_t l_704 = 0x0C0CB393;
    int32_t l_768 = 0;
    uint16_t l_770 = 0xD964;
    int32_t l_775 = 1;
    (*l_596) = func_2((0xE.4F545Ep+59 < ((float)func_6(l_12, (l_12 | 65535U), (func_13((((int32_t)(((int16_t)l_12 >> (int16_t)(l_12 & l_12)) || (func_20(func_24(l_12, l_12, l_12, l_12, l_12), l_31, l_32) && l_32.f1)) + (int32_t)0xEDF34D92) < 0xC8437A68), l_31.f3) , l_31.f2), l_32.f0, l_31.f7) - (float)l_32.f2)));
    for (l_31.f8 = (-8); (l_31.f8 == (-25)); l_31.f8 -= 5)
    { /* block id: 262 */
        float l_628 = 0x3.AFC953p-28;
        struct S1 *l_631 = &l_31;
        int32_t l_639 = 0;
        struct S0 l_640 = {1364,1628,-49};
        struct S1 **l_643 = &l_631;
        struct S1 ***l_642 = &l_643;
        struct S1 ****l_650 = &l_642;
        struct S1 *****l_649 = &l_650;
        int32_t *l_661 = &l_31.f7;
        float *l_727 = &l_31.f0;
        float **l_726 = &l_727;
        float l_769 = 0xE.1AE0E9p+1;
        int32_t l_771 = 1;
        for (l_31.f5 = 0; (l_31.f5 != (-9)); l_31.f5--)
        { /* block id: 265 */
            struct S0 l_603 = {65,256,-29};
            float *l_614 = &l_31.f0;
            for (l_31.f4 = 0; (l_31.f4 > 33); l_31.f4 += 1)
            { /* block id: 268 */
                float *l_615 = &l_31.f0;
                int32_t l_622 = 0x0062A4D2;
                int32_t l_623 = 0xC39B5030;
                uint32_t l_624 = 6U;
                (*l_596) = l_603;
                for (l_31.f3 = 0; (l_31.f3 < 2); l_31.f3++)
                { /* block id: 272 */
                    struct S0 **l_606 = &l_596;
                    int32_t l_625 = 0;
                    struct S1 *l_633 = (void*)0;
                    struct S1 ***l_641 = (void*)0;
                    (*l_606) = &l_32;
                    if (((((((~l_603.f2) < (((1U > (((uint16_t)(((int16_t)l_12 % (int16_t)1U) > ((int16_t)((l_614 == l_615) && (((uint32_t)0x45F4A5F8 / (uint32_t)((int32_t)((uint32_t)1U / (uint32_t)l_622) - (int32_t)0x12C1C057)) == l_603.f2)) % (int16_t)l_12)) / (uint16_t)l_623) , l_624)) , l_31.f2) >= 0x3CE4)) && l_603.f2) , 0U) > l_31.f6) > l_625))
                    { /* block id: 274 */
                        struct S0 **l_626 = &l_596;
                        int32_t l_627 = 0xF1C2CC19;
                        int32_t *l_629 = &l_625;
                        int32_t **l_630 = &l_629;
                        struct S1 **l_632 = &l_631;
                        l_623 = ((l_626 == (l_627 , l_606)) == (l_625 > l_628));
                        (*l_629) = 1;
                        (*l_630) = &l_625;
                        (*l_632) = l_631;
                    }
                    else
                    { /* block id: 279 */
                        struct S1 **l_634 = &l_631;
                        (*l_634) = l_633;
                    }
                    if ((l_32.f2 , (((int16_t)((int32_t)l_639 + (int32_t)((l_31.f2 , (l_640 , &l_622)) == l_614)) % (int16_t)l_640.f0) , (((l_623 < ((l_32.f1 , l_641) != l_642)) ^ l_603.f2) && (-6)))))
                    { /* block id: 282 */
                        int32_t *l_644 = &l_31.f7;
                        int32_t **l_645 = &l_644;
                        (*l_645) = l_644;
                        if (l_31.f6)
                            continue;
                    }
                    else
                    { /* block id: 285 */
                        int16_t l_646 = (-1);
                        (*l_615) = (-0x1.0p+1);
                        return l_646;
                    }
                }
            }
        }
        if (((int16_t)(((void*)0 == l_649) && ((void*)0 == &l_650)) << (int16_t)7))
        { /* block id: 292 */
            int32_t l_666 = 1;
            int32_t **l_703 = &l_661;
            int32_t ***l_702 = &l_703;
            int32_t ****l_701 = &l_702;
            l_651 = l_651;
            for (l_31.f5 = (-12); (l_31.f5 == 16); l_31.f5 += 1)
            { /* block id: 296 */
                int32_t l_668 = (-1);
                struct S0 **l_678 = &l_596;
                struct S0 ***l_677 = &l_678;
                struct S0 ****l_676 = &l_677;
                struct S0 *****l_675 = &l_676;
                uint32_t l_695 = 0xB9AD6656;
                struct S1 l_705 = {0x9.2D072Fp+86,1,0xC972BED4,0x6BAD2649,0xBECF6A51,0xB7B40A61,0x01CE1BD2,0xBA36C1B3,1};
            }
            (***l_702) = ((uint16_t)(*l_661) >> (uint16_t)9);
        }
        else
        { /* block id: 319 */
            uint32_t l_744 = 4294967294U;
            if ((*l_661))
                break;
            if ((*l_661))
                break;
            for (l_31.f6 = 21; (l_31.f6 == 50); l_31.f6 += 5)
            { /* block id: 324 */
                struct S1 *l_733 = (void*)0;
                (*l_596) = l_640;
                (**l_642) = l_733;
                l_651 = l_727;
            }
            for (l_31.f3 = 0; (l_31.f3 >= 20); l_31.f3 += 1)
            { /* block id: 331 */
                uint32_t l_767 = 0xE8637718;
                struct S1 *l_772 = (void*)0;
                struct S1 l_774 = {0x3.2B8CA5p+99,0xBEFF98C2,-10,0x1E56AA47,6U,0xEE096FB6,0x164F8701,0x9B29851E,0};
                struct S1 *l_773 = &l_774;
                (*l_773) = func_41((*l_651), ((int16_t)((uint32_t)(((uint16_t)(((uint16_t)65534U % (uint16_t)l_744) , ((int16_t)((1 && (((int32_t)(*l_651) + (int32_t)((uint32_t)(((int16_t)(0x74B8 || ((~((int16_t)0xE8DE / (int16_t)((uint16_t)((!(~(!l_744))) != (((((uint16_t)(((((int16_t)((((((uint32_t)((*l_651) != 0x6827) - (uint32_t)0x23B50BFF) >= l_744) | l_767) , (*l_661)) != (*l_661)) + (int16_t)(*l_651)) | l_767) > (-2)) & l_767) - (uint16_t)(-4)) & l_768) >= (*l_651)) != l_770)) / (uint16_t)65526U))) || (*l_661))) << (int16_t)11) , 0U) % (uint32_t)(*l_661))) ^ l_771)) ^ (*l_661)) << (int16_t)14)) / (uint16_t)8) == (*l_651)) % (uint32_t)(*l_661)) / (int16_t)(*l_661)), (*l_661), (*l_661));
            }
        }
    }
    return l_775;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_2(float  p_3)
{ /* block id: 256 */
    int32_t l_593 = 1;
    int32_t *l_592 = &l_593;
    int32_t **l_594 = &l_592;
    struct S0 l_595 = {337,1947,63};
    (*l_594) = l_592;
    return l_595;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_6(float  p_7, int16_t  p_8, uint32_t  p_9, int16_t  p_10, int16_t  p_11)
{ /* block id: 252 */
    int32_t *l_588 = (void*)0;
    int32_t **l_589 = &l_588;
    int32_t l_591 = (-1);
    int32_t *l_590 = &l_591;
    (*l_589) = l_588;
    (*l_590) = 0xC174661C;
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_13(int32_t  p_14, uint16_t  p_15)
{ /* block id: 237 */
    uint16_t l_556 = 0x7D64;
    struct S0 l_568 = {508,1159,41};
    struct S0 *l_567 = &l_568;
    struct S0 **l_566 = &l_567;
    struct S0 ***l_565 = &l_566;
    struct S1 ****l_571 = (void*)0;
    struct S1 *****l_570 = &l_571;
    int32_t ****l_580 = (void*)0;
    struct S0 l_587 = {936,809,-19};
    if (l_556)
    { /* block id: 238 */
        int32_t l_559 = 0x1FD64D53;
        int32_t *l_558 = &l_559;
        int32_t **l_557 = &l_558;
        int32_t ***l_560 = &l_557;
        (*l_560) = l_557;
    }
    else
    { /* block id: 240 */
        struct S0 ***l_569 = &l_566;
        struct S1 *****l_572 = &l_571;
        int32_t l_579 = 0x1CE716D6;
        int32_t *l_578 = &l_579;
        int32_t **l_577 = &l_578;
        int32_t ***l_576 = &l_577;
        int32_t ****l_575 = &l_576;
        struct S1 *l_581 = (void*)0;
        struct S1 l_583 = {0x1.6p+1,0xA8454A53,-1,-1,0xE87CEA28,0x86B13B2D,0x18AA12B7,-1,0xE6B2F180};
        struct S1 *l_582 = &l_583;
        float *l_586 = &l_583.f0;
        (*l_582) = (p_14 , func_41(((((((uint16_t)((int16_t)((l_565 != l_569) <= (((p_15 != 1U) ^ (func_24((l_570 == l_572), ((p_15 <= (((((((float)((l_575 != l_580) == 0x2.Cp-1) / (float)l_568.f0) , 2U) >= p_14) <= (*l_578)) > 65535U) && 1)) > 0xF923), (***l_576), p_14, (**l_577)) , (-8))) <= l_568.f1)) + (int16_t)p_14) >> (uint16_t)15) == (****l_575)) != p_14) && 0x7CC1) == 0x6C39), (***l_576), p_14, (***l_576)));
        for (p_15 = 0; (p_15 >= 30); p_15 += 1)
        { /* block id: 244 */
            (*l_577) = &p_14;
            if ((***l_576))
                break;
        }
        (*l_586) = (****l_575);
        (****l_575) = p_15;
    }
    return l_587;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_20(struct S0  p_21, struct S1  p_22, struct S0  p_23)
{ /* block id: 3 */
    struct S1 l_522 = {0x9.43B23Dp+39,-1,0xBDB756D7,0x9D478F68,4294967295U,0,8U,-1,-1};
    struct S1 *l_521 = &l_522;
    struct S1 *****l_529 = (void*)0;
    uint32_t l_542 = 7U;
    struct S1 **l_545 = &l_521;
    struct S1 ***l_544 = &l_545;
    struct S1 ****l_543 = &l_544;
    float *l_546 = &l_522.f0;
    struct S0 ***l_555 = (void*)0;
    struct S0 ****l_554 = &l_555;
    struct S0 *****l_553 = &l_554;
    (*l_521) = func_33((~0x5996));
    (*l_546) = (((float)(((-1) <= (((((uint16_t)((int32_t)(((l_529 != l_529) <= ((int16_t)((uint32_t)l_522.f8 - (uint32_t)((int32_t)(((&p_21 != &p_23) && ((((((((int16_t)((((int16_t)((uint16_t)(&l_521 == &l_521) / (uint16_t)p_22.f5) - (int16_t)0x1C57) & l_522.f4) > l_522.f5) + (int16_t)0x54D5) , l_542) > p_22.f3) ^ 0xA4E8) , l_543) == &l_544) || p_22.f7)) , p_22.f3) + (int32_t)p_23.f1)) >> (int16_t)6)) || l_522.f3) / (int32_t)p_23.f1) / (uint16_t)p_22.f2) <= p_21.f0) , 0x67D8) & p_22.f6)) , 0xE.3AA246p+6) / (float)l_522.f1) < 0x0.0p-1);
    for (p_22.f1 = 20; (p_22.f1 != 26); p_22.f1 += 3)
    { /* block id: 233 */
        struct S0 **l_552 = (void*)0;
        struct S0 ***l_551 = &l_552;
        struct S0 ****l_550 = &l_551;
        struct S0 *****l_549 = &l_550;
        l_553 = l_549;
    }
    return l_522.f7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_24(uint16_t  p_25, uint32_t  p_26, int32_t  p_27, uint16_t  p_28, uint32_t  p_29)
{ /* block id: 1 */
    struct S0 l_30 = {1174,119,-7};
    return l_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_33(int16_t  p_34)
{ /* block id: 4 */
    int32_t l_69 = (-1);
    struct S0 l_74 = {619,982,6};
    uint32_t l_80 = 0x8BE9C2C5;
    int32_t *l_519 = &l_69;
    struct S1 l_520 = {0x1.05EC4Bp+45,0x5C2A52FE,0x01E9E20C,0xB487A13F,7U,1,0xFC8B0E8E,0xFF9381DD,-1};
    (*l_519) = (((int32_t)(((p_34 , func_38(func_41((0U == ((uint16_t)((int32_t)func_50((((int32_t)(((int16_t)((uint32_t)(((uint16_t)((((uint16_t)((int32_t)((int32_t)l_69 + (int32_t)((uint16_t)((int32_t)(l_74 , ((~l_74.f2) , l_74.f1)) % (int32_t)((int16_t)(((uint16_t)(1 || 0x0EB0) % (uint16_t)(-8)) == l_74.f2) >> (int16_t)7)) << (uint16_t)p_34)) / (int32_t)l_80) % (uint16_t)p_34) , l_80) < 3U) << (uint16_t)2) != 3) + (uint32_t)p_34) / (int16_t)l_74.f0) | p_34) + (int32_t)l_74.f0) & p_34), l_80, p_34, l_74.f2) + (int32_t)4294967287U) % (uint16_t)p_34)), l_74.f0, l_74.f0, l_80), l_80)) , 65535U) >= l_74.f0) % (int32_t)0x9677F73A) == l_74.f0);
    return l_520;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_38(struct S1  p_39, int32_t  p_40)
{ /* block id: 166 */
    struct S0 l_398 = {1017,1991,-13};
    struct S0 *l_397 = &l_398;
    struct S0 **l_396 = &l_397;
    int32_t **l_408 = (void*)0;
    int32_t ***l_407 = &l_408;
    struct S1 **l_415 = (void*)0;
    uint32_t l_429 = 0x1E50D7E0;
    struct S1 l_462 = {0x6.463DE3p-28,0xC404A4CC,1,-1,4294967287U,0x7E1939BD,0U,-9,-9};
    struct S1 ***l_482 = &l_415;
    struct S1 ****l_481 = &l_482;
    float *l_490 = &l_462.f0;
    float **l_493 = &l_490;
    float ***l_492 = &l_493;
    if (((void*)0 == l_396))
    { /* block id: 167 */
        uint16_t l_403 = 65535U;
        int32_t **l_406 = (void*)0;
        int32_t ***l_405 = &l_406;
        struct S0 *l_419 = &l_398;
        for (p_39.f2 = 0; (p_39.f2 < 16); p_39.f2 += 4)
        { /* block id: 170 */
            uint32_t l_404 = 0xDEC7DB3D;
            int32_t ****l_410 = &l_405;
            struct S0 **l_430 = &l_419;
            if (p_40)
            { /* block id: 171 */
                uint32_t l_409 = 0x1D6342A7;
                struct S1 l_418 = {0x1.2p+1,0xFDAF4DD6,-4,0x652F08D1,4294967287U,-2,0x887CB6E2,0xC4831048,6};
                struct S1 *l_417 = &l_418;
                struct S1 **l_416 = &l_417;
                int32_t *l_433 = &l_418.f5;
                int32_t **l_456 = &l_433;
                if (p_39.f3)
                { /* block id: 172 */
                    uint32_t l_411 = 0x66F19421;
                    int32_t *l_428 = &l_418.f8;
                    float *l_446 = (void*)0;
                    float **l_445 = &l_446;
                    if ((l_398.f2 ^ ((uint16_t)l_403 + (uint16_t)(((((l_404 || l_403) >= (((((l_405 != l_407) >= l_409) ^ (l_410 == (void*)0)) <= 0xB20D) > 0x9547)) > l_409) & 0x9B00) < l_411))))
                    { /* block id: 173 */
                        float l_422 = (-0x1.6p-1);
                        int32_t l_423 = 0xD327BD9B;
                        (*l_397) = func_24((-(uint16_t)((int16_t)(((((((l_415 == l_416) == (1 & l_418.f6)) , ((p_39.f5 , l_419) == (void*)0)) > (l_404 , ((int16_t)(p_39.f2 , 0x87AF) - (int16_t)l_411))) != l_411) ^ p_39.f8) && 1U) - (int16_t)l_423)), l_423, p_40, p_39.f3, p_39.f5);
                    }
                    else
                    { /* block id: 175 */
                        p_39.f8 = l_418.f7;
                    }
                    (*l_428) = ((uint32_t)p_39.f4 / (uint32_t)((uint32_t)l_418.f8 + (uint32_t)l_409));
                    if (((func_24(l_418.f8, l_418.f8, l_404, l_429, (p_39.f7 , (((l_430 == ((((int16_t)p_40 >> (int16_t)1) >= p_39.f7) , l_430)) | p_39.f2) | l_404))) , l_418.f2) <= p_39.f4))
                    { /* block id: 179 */
                        int32_t **l_434 = &l_428;
                        (*l_434) = l_433;
                        return p_39.f2;
                    }
                    else
                    { /* block id: 182 */
                        float **l_447 = &l_446;
                        (*l_428) = ((int16_t)((uint32_t)((int16_t)(-1) + (int16_t)(((uint16_t)((int32_t)(l_445 == (((void*)0 != &p_39) , l_447)) + (int32_t)(1U ^ p_39.f3)) >> (uint16_t)((uint16_t)((uint16_t)0U >> (uint16_t)6) - (uint16_t)(*l_428))) && p_40)) + (uint32_t)p_40) << (int16_t)(*l_433));
                        if (l_404)
                            break;
                    }
                }
                else
                { /* block id: 186 */
                    int32_t *l_454 = &l_418.f5;
                    for (l_418.f6 = 14; (l_418.f6 != 14); l_418.f6 += 6)
                    { /* block id: 189 */
                        int32_t **l_455 = &l_433;
                        (*l_455) = l_454;
                    }
                }
                (*l_456) = (void*)0;
            }
            else
            { /* block id: 194 */
                struct S0 ***l_457 = &l_396;
                struct S0 ****l_458 = &l_457;
                (*l_419) = (**l_430);
                (*l_458) = l_457;
            }
            if (p_40)
                break;
        }
    }
    else
    { /* block id: 200 */
        struct S1 ***l_460 = (void*)0;
        struct S1 ****l_459 = &l_460;
        struct S1 *****l_461 = &l_459;
        struct S1 *l_463 = (void*)0;
        struct S1 *l_464 = &l_462;
        struct S0 l_467 = {113,669,38};
        int32_t *l_472 = &l_462.f3;
        float ***l_494 = &l_493;
        (*l_461) = l_459;
        (*l_464) = l_462;
        for (l_429 = (-14); (l_429 < 4); l_429 += 8)
        { /* block id: 205 */
            int32_t l_468 = 0x565110DE;
            int32_t *l_471 = &l_462.f3;
            (*l_397) = l_467;
            if ((0xE390 >= (l_468 <= ((((-4) & (p_39.f6 < ((int16_t)(l_471 == l_472) << (int16_t)12))) <= ((uint16_t)(!p_39.f6) << (uint16_t)(p_39.f6 < ((int16_t)((int16_t)p_40 / (int16_t)0x3241) - (int16_t)(*l_472))))) && p_39.f4))))
            { /* block id: 207 */
                struct S1 l_480 = {0xB.161D73p-33,1,-1,0xE4D57C43,4294967287U,0x33868341,7U,0,1};
                struct S0 **l_483 = &l_397;
                float *l_487 = &l_462.f0;
                float **l_486 = &l_487;
                float ***l_485 = &l_486;
                (*l_471) = (-8);
                (*l_464) = l_480;
                if (((void*)0 == l_481))
                { /* block id: 210 */
                    uint32_t l_484 = 0U;
                    float **l_491 = &l_490;
                    (*l_472) = (((l_483 != (void*)0) , 0x4.5B302Cp-40) < ((l_480.f1 < l_484) < 0x5.3F3F4Fp-59));
                    (*l_471) = (((l_485 == (void*)0) == (((int16_t)l_484 << (int16_t)0) != (l_490 != (void*)0))) , ((*l_485) == l_491));
                }
                else
                { /* block id: 213 */
                    uint32_t l_517 = 4294967289U;
                    int32_t **l_518 = &l_471;
                    (*l_471) = (((p_40 , (*l_471)) >= 0U) ^ (*l_471));
                    (***l_485) = ((((((((l_492 != l_494) > ((int32_t)((int32_t)(((int32_t)((int16_t)((uint32_t)(&l_472 == ((((uint32_t)(*l_471) / (uint32_t)(0xF105 ^ l_480.f8)) >= (((uint32_t)((uint32_t)0U / (uint32_t)(*l_471)) % (uint32_t)((int16_t)(((((((uint16_t)((uint16_t)(l_517 > p_39.f6) + (uint16_t)1U) % (uint16_t)1U) & 6) >= p_39.f8) , l_517) | p_39.f3) || 0xDE08) << (int16_t)10)) , l_480.f6)) , (void*)0)) / (uint32_t)2U) << (int16_t)p_39.f7) / (int32_t)8U) , (-2)) / (int32_t)0xD1CF75D6) - (int32_t)(-1))) > l_517) , p_39.f3) > p_39.f1) >= l_480.f4) > 0x6.3p-1) < 0xA.717F3Ep-95);
                    (*l_518) = l_471;
                }
                if (p_40)
                    break;
            }
            else
            { /* block id: 219 */
                l_467 = (*l_397);
                l_472 = l_472;
            }
            (*l_396) = &l_467;
        }
    }
    return p_39.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_41(int32_t  p_42, int16_t  p_43, uint32_t  p_44, int32_t  p_45)
{ /* block id: 163 */
    int32_t l_394 = 0x847E4AD0;
    int32_t *l_393 = &l_394;
    int32_t **l_392 = &l_393;
    struct S1 l_395 = {0xE.894FF6p-24,0,0xF2BE97FA,0x36EF52D3,0U,1,0x8200BA00,0x5ED174B2,0x6C7FB340};
    (*l_392) = (void*)0;
    return l_395;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_50(int16_t  p_51, int32_t  p_52, int32_t  p_53, uint16_t  p_54)
{ /* block id: 5 */
    uint16_t l_81 = 0xD669;
    struct S1 l_96 = {0x1.Bp+1,7,0x11712D94,-1,0x6C92F0D9,7,0x7ADB2349,0x53036CC0,0xFD73FCFB};
    struct S0 l_97 = {194,305,-60};
    int32_t **l_127 = (void*)0;
    int32_t *l_129 = &l_96.f3;
    int32_t **l_128 = &l_129;
    int32_t l_215 = 6;
    struct S1 *l_241 = &l_96;
    struct S1 **l_240 = &l_241;
    float **l_284 = (void*)0;
    float ***l_283 = &l_284;
    int32_t *l_317 = &l_96.f3;
    l_97 = func_24((l_81 || (func_24(((uint16_t)((l_81 , l_81) && ((int16_t)p_52 + (int16_t)((uint32_t)p_51 % (uint32_t)((int32_t)((uint16_t)0xBC93 << (uint16_t)3) + (int32_t)l_81)))) - (uint16_t)((int16_t)p_53 >> (int16_t)((uint32_t)((((l_96 , p_51) , l_96.f7) <= 0x3A23B15C) > 0xA264E934) % (uint32_t)l_96.f2))), l_96.f5, p_51, p_53, l_96.f8) , p_54)), l_96.f3, p_54, p_52, l_96.f6);
    for (l_96.f5 = 0; (l_96.f5 <= (-30)); l_96.f5--)
    { /* block id: 9 */
        float *l_108 = &l_96.f0;
        uint32_t l_112 = 0x4446D154;
        uint32_t l_125 = 4294967292U;
        struct S0 l_126 = {857,1109,20};
        (*l_108) = (((uint16_t)(((int32_t)p_51 / (int32_t)((((uint16_t)(4294967295U == p_53) << (uint16_t)13) ^ (p_52 < (0x25977850 ^ p_53))) && ((uint16_t)(p_52 ^ 4294967293U) >> (uint16_t)((65528U ^ p_52) & p_54)))) , l_96.f4) << (uint16_t)7) , p_53);
        l_97.f2 = ((~0x703095B6) < ((((uint32_t)(l_112 != ((((-(int32_t)((((-(int16_t)((int16_t)((int16_t)p_53 >> (int16_t)14) + (int16_t)65528U)) & 0x1C15) , ((((((((int16_t)p_53 - (int16_t)((int16_t)((((((((((l_97.f1 >= (l_96.f5 >= (((int16_t)p_51 >> (int16_t)13) || 0xCBD1ED58))) , l_96) , p_51) <= l_125) == p_54) != l_96.f6) != 0x52264B8E) <= 0U) , p_51) , (-1)) << (int16_t)2)) != l_125) <= p_53) , (void*)0) == l_108) & p_51) == (-1))) <= p_54)) , l_126) , l_96) , 0x48848039)) + (uint32_t)0U) || p_52) & 4294967295U));
    }
    (*l_128) = &p_53;
    for (l_81 = 0; (l_81 > 43); l_81 += 9)
    { /* block id: 16 */
        int32_t *l_141 = (void*)0;
        struct S1 *l_204 = &l_96;
        struct S1 **l_203 = &l_204;
        struct S0 *l_216 = &l_97;
        uint32_t l_225 = 4294967295U;
        uint32_t l_242 = 0xADDF4B60;
        float *l_266 = &l_96.f0;
        float **l_265 = &l_266;
        int32_t **l_267 = &l_141;
        int32_t ****l_386 = (void*)0;
    }
    return p_53;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 152
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 0
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 15
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 24
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 31

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 20, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 38, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 178

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 104
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 99
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 369

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 239
   level: 2, occurrence: 62
   level: 3, occurrence: 35
   level: 4, occurrence: 16
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 106
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 28
XXX percent of pointers has null in alias set: 23
XXX average alias set size: 1.13

XXX times a non-volatile is read: 842
XXX times a non-volatile is write: 261
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 99
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 14
   depth: 2, occurrence: 15
   depth: 3, occurrence: 16
   depth: 4, occurrence: 12
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 22.9
XXX percentage an existing variable is used: 77.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

