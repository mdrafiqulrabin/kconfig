/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3429868822
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_7 = 0x901F2C29L;
static int32_t g_30 = 0xC312FBB6L;
static int32_t g_54 = (-10L);
static int32_t *g_112 = (void*)0;
static int32_t **g_111 = &g_112;
static int32_t g_120 = (-1L);
static float g_165 = 0x0.Ap+1;
static int8_t g_173 = 0xCFL;
static int64_t g_196 = (-1L);
static int8_t g_198 = (-3L);
static uint16_t g_213 = 4UL;
static uint64_t g_378 = 0x94154AC27B2AF5F6LL;
static float *g_382 = &g_165;
static float **g_381 = &g_382;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_27(void);
static int16_t  func_39(int16_t  p_40, int64_t  p_41, uint32_t  p_42, int32_t * p_43);
inline static int16_t  func_44(uint64_t  p_45, int8_t  p_46, int32_t * p_47, uint32_t  p_48, uint16_t  p_49);
static uint64_t  func_50(uint64_t  p_51, uint16_t  p_52, int32_t * p_53);
static int32_t * func_55(int16_t  p_56, int64_t  p_57, int8_t  p_58, int64_t  p_59, int32_t * p_60);
inline static int16_t  func_72(uint32_t  p_73, int32_t  p_74, int32_t * p_75, int32_t * p_76, uint32_t  p_77);
inline static int8_t  func_80(int8_t  p_81, uint16_t  p_82, uint16_t  p_83);
inline static int32_t * func_86(int32_t ** p_87, int32_t * p_88, int64_t  p_89);
static int32_t  func_101(int8_t  p_102, float  p_103);
inline static float  func_106(int32_t ** p_107, int16_t  p_108, uint16_t  p_109, int32_t * p_110);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_30 g_7 g_381 g_173
 * writes: g_30 g_7 g_381
 */
static uint32_t  func_27(void)
{ /* block id: 36 */
    int32_t *l_28 = (void*)0;
    int32_t *l_29 = &g_30;
    (*l_29) &= (-7L);
    for (g_7 = 8; (g_7 <= 22); g_7++)
    { /* block id: 40 */
        int64_t l_35 = 0x65969A22DB785B64LL;
        int32_t l_371 = 0xBEFD1AA8L;
        for (g_30 = 1; (g_30 > 5); g_30++)
        { /* block id: 43 */
            uint64_t l_63 = 0xD8F9C328129EC6EALL;
        }
    }
    g_381 = g_381;
    return g_173;
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_198 g_173 g_7 g_213 g_111 g_120 g_112 g_30 g_196
 * writes: g_112 g_120 g_165 g_213 g_198
 */
static int16_t  func_39(int16_t  p_40, int64_t  p_41, uint32_t  p_42, int32_t * p_43)
{ /* block id: 95 */
    uint32_t l_239 = 8UL;
    float *l_244 = &g_165;
    int32_t l_255 = 0x315883FBL;
    int32_t l_296 = 4L;
    int32_t l_335 = 1L;
    int32_t ***l_360 = &g_111;
    float *l_363 = &g_165;
    int32_t *l_364 = (void*)0;
    int32_t *l_365 = &l_296;
    if ((g_54 , ((uint32_t)l_239 - (uint32_t)((uint16_t)0x44D4L << (uint16_t)((((uint16_t)(l_244 == (((uint64_t)(((uint16_t)0x5C9EL >> (uint16_t)((uint16_t)g_198 % (uint16_t)l_239)) > g_173) + (uint64_t)(((int16_t)p_40 * (int16_t)p_41) , (-10L))) , (void*)0)) << (uint16_t)g_7) > l_239) > g_213)))))
    { /* block id: 96 */
        int32_t l_265 = 0x4A243EC4L;
        float l_266 = 0x1.Bp-1;
        int32_t *l_290 = &g_120;
        int32_t ***l_294 = &g_111;
        for (p_41 = 0; (p_41 == 16); p_41++)
        { /* block id: 99 */
            int32_t *l_256 = &g_120;
            int32_t l_268 = (-7L);
            if (l_255)
            { /* block id: 100 */
                int8_t l_280 = 7L;
                int32_t ***l_281 = &g_111;
                (*g_111) = l_256;
                /* statement id: 101 */
                assert (g_112 == &g_120);
                if ((0xC4FA8936D0663B70LL > p_40))
                { /* block id: 102 */
                    for (g_120 = (-12); (g_120 <= 19); g_120 += 8)
                    { /* block id: 105 */
                        float l_267 = (-0x8.0p-1);
                        l_268 &= ((int32_t)(p_41 , ((((uint16_t)p_40 - (uint16_t)((((int64_t)0L + (int64_t)(-7L)) && (*l_256)) | l_265)) | ((((((g_54 , ((__builtin_ctzl((*l_256)) < p_40) >= 0xF36308B9188FDCBFLL)) < 0x501070E8L) , 1L) < p_42) ^ p_40) < 1UL)) != 8UL)) % (int32_t)g_120);
                    }
                }
                else
                { /* block id: 108 */
                    float l_279 = 0x5.1C22BAp+95;
                    (*l_256) = (((((((uint64_t)(((uint16_t)(((p_40 || __builtin_clzll(((-1L) < ((((int16_t)g_213 << (int16_t)p_40) , (((g_120 < ((uint16_t)(((((p_43 != (void*)0) , (p_40 , ((uint32_t)g_213 % (uint32_t)0xFC4EB74DL))) || l_255) || g_120) , (*l_256)) * (uint16_t)p_42)) | g_120) == 0x8073F352L)) < 0UL)))) < g_54) || p_41) * (uint16_t)0x8190L) > l_280) % (uint64_t)l_265) | 0x4539L) , (void*)0) == l_281) != p_42) , (*g_112));
                    if ((**g_111))
                        break;
                    for (g_120 = (-16); (g_120 <= (-19)); g_120 -= 5)
                    { /* block id: 113 */
                        return (*l_256);
                    }
                }
                (*l_244) = g_54;
            }
            else
            { /* block id: 118 */
                int32_t ***l_295 = &g_111;
                float *l_341 = (void*)0;
                (*l_256) &= l_265;
                if (l_255)
                { /* block id: 120 */
                    int32_t l_293 = 0x2719FA18L;
                    l_296 |= (((((((0xEE80L < (((((int16_t)((uint16_t)(((((p_42 ^ ((int16_t)p_40 >> (int16_t)((*g_111) == l_290))) , (p_41 , &l_268)) == l_244) > g_54) , p_41) * (uint16_t)p_41) >> (int16_t)g_120) , (-7L)) == 4UL) > p_40)) , 0x1D3E571FBC6ABA3ELL) , l_294) == l_295) < g_30) , g_54) , 7L);
                }
                else
                { /* block id: 122 */
                    int64_t l_306 = 0x87112B941AA105A6LL;
                    int16_t l_328 = 7L;
                    int32_t *l_342 = &g_30;
                    if ((((uint32_t)((((((uint16_t)((int16_t)(&g_112 != (l_296 , &g_112)) - (int16_t)((-(uint32_t)g_198) != l_255)) >> (uint16_t)15) , p_43) != (((int16_t)0x5DC8L * (int16_t)g_196) , (void*)0)) < g_54) <= l_306) - (uint32_t)9L) < p_40))
                    { /* block id: 123 */
                        uint32_t l_307 = 4UL;
                        (*l_290) = ((p_43 == (l_307 , p_43)) != (*l_290));
                    }
                    else
                    { /* block id: 125 */
                        uint64_t l_327 = 0x29F82947E045539ELL;
                        l_328 &= ((-(uint64_t)(g_173 & (((int32_t)l_296 + (int32_t)(((g_198 < ((int64_t)(((int32_t)((int16_t)((int16_t)(((float)((float)(g_213 < p_40) - (float)(((uint32_t)(p_42 | (&p_43 == &g_112)) % (uint32_t)(((void*)0 == l_295) & l_239)) , (-0x1.7p-1))) + (float)p_42) , p_41) << (int16_t)7) << (int16_t)p_41) - (int32_t)l_306) | g_54) + (int64_t)18446744073709551612UL)) , (void*)0) != &g_111)) | p_42))) , l_327);
                        (*l_256) &= (l_328 , ((int16_t)((int16_t)((uint16_t)p_42 << (uint16_t)p_41) >> (int16_t)14) >> (int16_t)10));
                        (*l_290) = func_44((0x3B7EL || l_335), ((int64_t)((uint32_t)((p_43 == p_43) , g_213) + (uint32_t)(~g_30)) + (int64_t)(l_244 == l_341)), (p_41 , l_342), p_41, p_41);
                    }
                }
                for (g_198 = 0; (g_198 > (-6)); g_198--)
                { /* block id: 133 */
                    uint16_t l_345 = 4UL;
                    uint32_t l_350 = 0xDE6D4011L;
                    int32_t *l_355 = &l_268;
                    (**l_294) = ((0x4DD5B9C6L ^ l_345) , (((float)(((((((1L <= 8L) && p_42) , ((uint32_t)l_350 % (uint32_t)p_42)) || (0xC7B8DB31L ^ (((uint16_t)(p_41 < g_173) >> (uint16_t)l_345) == g_7))) , g_120) , p_43) != (void*)0) + (float)0x2.D92533p+12) , (void*)0));
                    /* statement id: 134 */
                    assert (g_112 == 0);
                    (*l_256) |= ((*g_111) == (void*)0);
                    (*l_355) &= ((uint64_t)p_40 - (uint64_t)(*l_290));
                }
                (*l_256) |= p_41;
            }
        }
        /* facts after for loop */
        assert (g_112 == 0 || g_112 == &g_30 || g_112 == &g_120);
    }
    else
    { /* block id: 141 */
        int32_t *l_358 = &l_296;
        if (((uint64_t)l_296 - (uint64_t)18446744073709551606UL))
        { /* block id: 142 */
            (*g_111) = l_358;
            /* statement id: 143 */
            assert (g_112 == &l_296);
        }
        else
        { /* block id: 144 */
            int32_t l_359 = 0x58D1362EL;
            l_335 ^= l_359;
            return g_173;
        }
        /* facts after branching */
        assert (g_112 == &l_296);
    }
    /* facts after branching */
    assert (g_112 == &l_296 || g_112 == 0 || g_112 == &g_30 || g_112 == &g_120);
    g_120 &= (l_360 != ((__builtin_ffsll(((void*)0 == &g_111)) == (((((uint16_t)(((l_360 == l_360) == (p_43 != l_363)) & (65528UL < p_40)) >> (uint16_t)13) , (void*)0) != p_43) != 0x5.E99DC0p+92)) , (void*)0));
    (*l_365) = (__builtin_popcount(g_120) == (g_120 <= __builtin_bswap32(g_213)));
    return p_41;
    /* statement id: 151 */
    //assert (g_112 == dangling || g_112 == 0 || g_112 == &g_30 || g_112 == &g_120);
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_120 g_213 g_196 g_54 g_173 g_198 g_111 g_112 g_30
 * writes: g_165 g_120 g_213 g_112
 */
inline static int16_t  func_44(uint64_t  p_45, int8_t  p_46, int32_t * p_47, uint32_t  p_48, uint16_t  p_49)
{ /* block id: 80 */
    float *l_164 = &g_165;
    int32_t l_168 = 0xB3CA981AL;
    int32_t l_210 = 0xFA8D4CD4L;
    (*l_164) = g_7;
    for (g_120 = (-15); (g_120 == 27); ++g_120)
    { /* block id: 84 */
        int32_t *l_169 = &l_168;
        int32_t *l_170 = &l_168;
        int32_t *l_171 = (void*)0;
        int32_t *l_172 = (void*)0;
        int32_t *l_174 = &l_168;
        int32_t *l_175 = &l_168;
        int32_t *l_176 = &l_168;
        int32_t *l_177 = &l_168;
        int32_t *l_178 = (void*)0;
        int32_t *l_179 = &l_168;
        int32_t *l_180 = (void*)0;
        int32_t *l_181 = (void*)0;
        int32_t *l_182 = &l_168;
        int32_t *l_183 = &l_168;
        int32_t *l_184 = &l_168;
        int32_t *l_185 = &l_168;
        int32_t *l_186 = &l_168;
        int32_t *l_187 = &l_168;
        int32_t *l_188 = &l_168;
        int32_t *l_189 = &l_168;
        int32_t *l_190 = &l_168;
        int32_t *l_191 = &l_168;
        int32_t *l_192 = &l_168;
        int32_t *l_193 = &l_168;
        int32_t *l_194 = (void*)0;
        int32_t *l_195 = &l_168;
        int32_t *l_197 = &l_168;
        int32_t *l_199 = &l_168;
        int32_t *l_200 = &l_168;
        int32_t *l_201 = &l_168;
        int32_t *l_202 = &l_168;
        int32_t *l_203 = &l_168;
        int32_t *l_204 = &l_168;
        int32_t *l_205 = &l_168;
        int32_t *l_206 = (void*)0;
        int32_t *l_207 = &l_168;
        int32_t *l_208 = &l_168;
        int32_t *l_209 = &l_168;
        int32_t *l_211 = &l_168;
        int32_t *l_212 = &l_168;
        ++g_213;
        (*l_197) = ((uint64_t)((int16_t)(*l_191) << (int16_t)((int16_t)p_48 * (int16_t)(((((~(g_196 >= ((*l_211) && ((p_49 <= ((-1L) > p_48)) >= ((uint16_t)((int64_t)(((g_54 | g_54) , (-1L)) != 0L) % (int64_t)g_173) * (uint16_t)l_210))))) , (*l_199)) , l_210) , (void*)0) != (void*)0))) + (uint64_t)(*l_211));
    }
    l_210 = __builtin_ffsl(g_7);
    for (l_168 = 18; (l_168 <= 29); l_168++)
    { /* block id: 91 */
        uint64_t l_231 = 1UL;
        int8_t l_235 = 1L;
        int32_t *l_236 = &g_120;
        (*l_236) = ((uint16_t)g_198 - (uint16_t)(l_231 , (__builtin_bswap32((((((-1L) >= ((func_101((((l_231 < (l_231 < ((((int16_t)(-(int64_t)g_213) << (int16_t)l_168) < 0x4C5083F6D29B2AF5LL) == p_45))) ^ l_235) | 1L), g_120) || 0x8F34L) & l_210)) , g_196) > g_198) || (*g_112))) , p_45)));
        /* statement id: 92 */
        assert (g_112 == &g_30);
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_120 g_30 g_111 g_54
 * writes: g_120 g_112
 */
static uint64_t  func_50(uint64_t  p_51, uint16_t  p_52, int32_t * p_53)
{ /* block id: 68 */
    int32_t *l_156 = &g_120;
    if (((uint16_t)((uint16_t)p_51 << (uint16_t)6) << (uint16_t)((void*)0 != l_156)))
    { /* block id: 69 */
        int32_t **l_157 = &l_156;
        int32_t ***l_158 = &l_157;
        (*l_158) = l_157;
    }
    else
    { /* block id: 71 */
        (*l_156) &= (8L || p_52);
    }
    for (g_120 = 0; (g_120 <= 10); g_120 += 8)
    { /* block id: 76 */
        int32_t l_161 = 0xCEB9145EL;
        (*g_111) = ((((void*)0 != &p_53) ^ ((__builtin_bswap32(g_30) , ((l_161 , (l_161 , ((uint16_t)0x677FL << (uint16_t)2))) > (0x6A8FL | (((*l_156) , 18446744073709551609UL) , 65533UL)))) , (*l_156))) , (void*)0);
        /* statement id: 77 */
        assert (g_112 == 0);
    }
    /* facts after for loop */
    assert (g_112 == 0 || g_112 == &g_30);
    return g_54;
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_7 g_111 g_112 g_120 g_54
 * writes: g_112 g_120
 */
static int32_t * func_55(int16_t  p_56, int64_t  p_57, int8_t  p_58, int64_t  p_59, int32_t * p_60)
{ /* block id: 44 */
    uint16_t l_66 = 65529UL;
    int32_t l_139 = (-8L);
    uint32_t l_144 = 0x2E886BE4L;
    int32_t *l_150 = &g_120;
    int32_t *l_151 = &g_30;
    l_139 |= ((int16_t)(p_60 == (void*)0) * (int16_t)(((l_66 >= 0x266DL) , ((p_56 , (((((__builtin_ffsl(((uint16_t)g_30 << (uint16_t)10)) >= (~((int16_t)func_72(l_66, l_66, &g_30, p_60, p_57) >> (int16_t)g_30))) >= l_66) >= g_30) , l_66) <= l_66)) < (*p_60))) <= 0L));
    /* statement id: 65 */
    assert (g_112 == 0 || g_112 == &g_30);
    (*l_150) = ((((int16_t)(l_66 , ((int64_t)l_144 + (int64_t)((0x74D9FAD1L == ((int16_t)1L * (int16_t)(((int16_t)(-(uint32_t)__builtin_clzl(l_66)) * (int16_t)(func_101(g_7, p_58) , 3L)) , l_144))) , p_59))) * (int16_t)g_54) && g_7) > l_66);
    /* statement id: 66 */
    assert (g_112 == &g_30);
    return l_151;
    /* statement id: 67 */
    //assert (func_55_rv == &g_30);
}


/* ------------------------------------------ */
/* 
 * reads : g_7 g_30 g_111 g_112 g_120 g_54
 * writes: g_112 g_120
 */
inline static int16_t  func_72(uint32_t  p_73, int32_t  p_74, int32_t * p_75, int32_t * p_76, uint32_t  p_77)
{ /* block id: 45 */
    int32_t *l_79 = &g_30;
    int32_t **l_78 = &l_79;
    int32_t *l_137 = (void*)0;
    int32_t *l_138 = &g_120;
    (*l_78) = &g_30;
    (*l_138) = (g_7 > ((((*l_79) || (func_80((**l_78), (**l_78), ((((65535UL == ((uint64_t)((void*)0 != p_75) - (uint64_t)p_73)) , (((*l_79) ^ 1UL) | 3UL)) != g_7) > g_30)) , p_74)) && g_30) | g_7));
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_7 g_111 g_112 g_120 g_54
 * writes: g_112 g_120
 */
inline static int8_t  func_80(int8_t  p_81, uint16_t  p_82, uint16_t  p_83)
{ /* block id: 47 */
    int32_t *l_91 = &g_30;
    int32_t **l_90 = &l_91;
    int32_t *l_92 = &g_30;
    int8_t l_121 = 7L;
    (*g_111) = func_86(l_90, l_92, (((int16_t)((uint16_t)((((**l_90) == (-(int32_t)(!(*l_92)))) , p_83) , ((uint32_t)((__builtin_ctzl(g_7) , (func_101(p_81, ((float)func_106(g_111, (*l_91), (*l_91), (*g_111)) * (float)(*l_91))) == g_7)) || l_121) - (uint32_t)g_54)) << (uint16_t)(*l_92)) << (int16_t)(**l_90)) , 0x16CFB31DF95200CCLL));
    /* statement id: 61 */
    assert (g_112 == &g_30);
    return p_81;
}


/* ------------------------------------------ */
/* 
 * reads : g_54 g_111 g_120 g_112 g_30 g_7
 * writes: g_112 g_120
 */
inline static int32_t * func_86(int32_t ** p_87, int32_t * p_88, int64_t  p_89)
{ /* block id: 57 */
    float l_124 = (-0x1.6p-1);
    int16_t l_129 = 0L;
    int32_t l_132 = 0x026CBAADL;
    int32_t *l_133 = (void*)0;
    uint16_t l_134 = 65529UL;
    l_132 |= ((uint16_t)__builtin_clzll((((((func_101(g_54, l_124) ^ p_89) || (__builtin_ctzll(((((((uint64_t)((uint16_t)l_129 * (uint16_t)((uint32_t)((**p_87) || l_129) % (uint32_t)g_120)) - (uint64_t)((0x66C2L < g_120) , p_89)) >= p_89) <= p_89) > 0x088E2D1E931266FBLL) , 0UL)) <= 18446744073709551615UL)) ^ l_129) <= 0xE0669094L) > p_89)) * (uint16_t)l_129);
    l_134++;
    return (*p_87);
    /* statement id: 60 */
    //assert (func_86_rv == &g_30);
}


/* ------------------------------------------ */
/* 
 * reads : g_111 g_120 g_112 g_30
 * writes: g_112 g_120
 */
static int32_t  func_101(int8_t  p_102, float  p_103)
{ /* block id: 51 */
    int32_t *l_118 = &g_30;
    int32_t *l_119 = &g_120;
    (*g_111) = l_118;
    /* statement id: 52 */
    assert (g_112 == &g_30);
    (*l_119) &= p_102;
    (*g_111) = l_118;
    (*l_119) |= (-1L);
    return (**g_111);
}


/* ------------------------------------------ */
/* 
 * reads : g_7
 * writes:
 */
inline static float  func_106(int32_t ** p_107, int16_t  p_108, uint16_t  p_109, int32_t * p_110)
{ /* block id: 48 */
    uint32_t l_117 = 4UL;
    l_117 ^= __builtin_ffsl(((int16_t)0L * (int16_t)(((uint64_t)((void*)0 == &g_112) - (uint64_t)(9L < 1L)) && p_109)));
    return g_7;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_7, "g_7", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    transparent_crc(g_54, "g_54", print_hash_value);
    transparent_crc(g_120, "g_120", print_hash_value);
    transparent_crc_bytes (&g_165, sizeof(g_165), "g_165", print_hash_value);
    transparent_crc(g_173, "g_173", print_hash_value);
    transparent_crc(g_196, "g_196", print_hash_value);
    transparent_crc(g_198, "g_198", print_hash_value);
    transparent_crc(g_213, "g_213", print_hash_value);
    transparent_crc(g_378, "g_378", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 67
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 15
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 100

XXX times a variable address is taken: 87
XXX times a pointer is dereferenced on RHS: 40
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 7
XXX times a pointer is dereferenced on LHS: 28
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 280

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 147
   level: 2, occurrence: 43
   level: 3, occurrence: 14
XXX number of pointers point to pointers: 12
XXX number of pointers point to scalars: 88
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 18
XXX average alias set size: 1.07

XXX times a non-volatile is read: 373
XXX times a non-volatile is write: 79
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 69
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 9
   depth: 2, occurrence: 4
   depth: 3, occurrence: 7
   depth: 4, occurrence: 9
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
********************* end of statistics **********************/

