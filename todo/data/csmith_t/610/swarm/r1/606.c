/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1658607248
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   int16_t  f2;
   uint32_t  f3;
   int32_t  f4;
   uint32_t  f5;
   int32_t  f6;
};

struct S1 {
   signed f0 : 12;
   int16_t  f1;
   unsigned f2 : 11;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_1(void);
static uint64_t  func_8(const int32_t * p_9);
static const int32_t  func_10(int32_t * p_11, int32_t * p_12, const uint32_t  p_13, int32_t * const  p_14, int32_t * p_15);
static struct S1  func_35(uint32_t  p_36);
static int64_t  func_37(int32_t * p_38, const int32_t * const  p_39, struct S0  p_40, uint32_t  p_41, struct S1  p_42);
inline static int64_t  func_43(uint32_t * p_44, const uint32_t * p_45, int64_t  p_46, int64_t  p_47);
inline static uint32_t * func_49(int32_t * p_50);
static uint32_t  func_53(int32_t * p_54, int32_t  p_55);
static int32_t * func_56(int32_t * p_57, uint32_t  p_58);
static int32_t * func_59(struct S0  p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_2 = (void*)0;
    int32_t l_3 = 0x08CCCDDDL;
    const struct S0 l_589 = {8L,0x5CF26CFFL,1L,0x56753B81L,0x3B8FED2DL,18446744073709551608UL,-10L};
    int32_t l_594 = 0xA8E30B55L;
    int32_t ** const l_595 = &l_2;
    uint64_t l_596 = 18446744073709551614UL;
    uint16_t l_597 = 3UL;
    int64_t l_598 = 0L;
    uint16_t **l_599 = (void*)0;
    int32_t *l_600 = &l_3;
    struct S1 l_609 = {6,0x32FDL,16};
    struct S1 *l_608 = &l_609;
    struct S1 **l_607 = &l_608;
    struct S1 ***l_606 = &l_607;
    int32_t l_610 = 0L;
    l_3 = 0x72226312L;
    (*l_600) = (safe_rshift_func_int16_t_s_s(((((safe_rshift_func_uint16_t_u_s((&l_3 != &l_3), (func_8(&l_3) <= (((safe_mod_func_uint32_t_u_u((l_589 , (((func_35((safe_add_func_int64_t_s_s(((l_2 != (void*)0) | (((((safe_mod_func_int32_t_s_s((((((((((0x5C5EL & l_594) < l_589.f2) | l_589.f4) , l_595) != (void*)0) , l_589.f2) && 0xFD6895669C6C98CELL) , 0x025288064B3E79E4LL) ^ 0x0FC65DEC8682CF4ELL), 0x4AA95250L)) | l_589.f2) < 65533UL) & l_596) , 0xA26973638035FF37LL)), l_597))) , l_589.f3) , l_598) <= l_598)), l_589.f6)) , l_599) == (void*)0)))) , (*l_595)) != (void*)0) & l_597), 13));
    for (l_596 = 0; (l_596 == 35); l_596++)
    { /* block id: 288 */
        int32_t l_605 = 0x9E133E00L;
        for (l_598 = 0; (l_598 == (-25)); l_598 = safe_sub_func_uint32_t_u_u(l_598, 1))
        { /* block id: 291 */
            if (l_605)
                break;
            if ((*l_600))
                continue;
            (*l_595) = (*l_595);
        }
        l_606 = l_606;
        (*l_600) = ((l_605 < 0x9461080BL) <= (l_605 | (*l_600)));
    }
    return l_610;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_8(const int32_t * p_9)
{ /* block id: 2 */
    int32_t l_17 = 0x7770B168L;
    int32_t *l_16 = &l_17;
    int32_t l_31 = (-3L);
    int32_t *l_30 = &l_31;
    uint32_t l_33 = 1UL;
    uint32_t *l_32 = &l_33;
    struct S0 l_34 = {-1L,2UL,0xE8E5L,0x8E01AFECL,0xE183A099L,18446744073709551613UL,0L};
    int32_t *l_584 = &l_31;
    struct S0 *l_585 = &l_34;
    uint32_t l_586 = 1UL;
    (*l_16) = func_10(l_16, ((((safe_rshift_func_uint16_t_u_s(65534UL, (((*l_32) = ((*l_16) <= (safe_mod_func_uint64_t_u_u(((safe_mod_func_int32_t_s_s((safe_sub_func_int64_t_s_s(((*l_16) , ((void*)0 != p_9)), (safe_sub_func_int64_t_s_s((safe_lshift_func_uint16_t_u_u((&l_17 != (((*l_30) = (((*p_9) & (*l_16)) != (*l_16))) , (void*)0)), 0)), (*l_16))))), (*p_9))) >= (*l_16)), (*l_16))))) & (*p_9)))) , l_34) , (*l_30)) , &l_31), (*l_16), &l_17, &l_17);
    l_30 = l_584;
    (*l_585) = l_34;
    return l_586;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_10(int32_t * p_11, int32_t * p_12, const uint32_t  p_13, int32_t * const  p_14, int32_t * p_15)
{ /* block id: 5 */
    struct S1 l_48 = {48,0xF85DL,39};
    struct S0 l_61 = {0x14D865E4L,0x9B053640L,0xAC46L,0x06CCCE42L,0L,0x51CA2AE3L,3L};
    int64_t ***l_178 = (void*)0;
    const uint32_t *l_204 = &l_61.f1;
    uint32_t *l_368 = &l_61.f1;
    struct S1 *l_525 = &l_48;
    struct S0 **l_534 = (void*)0;
    uint64_t *l_535 = (void*)0;
    uint64_t l_537 = 18446744073709551615UL;
    uint64_t *l_536 = &l_537;
    uint16_t l_538 = 1UL;
    int32_t *l_583 = &l_61.f4;
    int32_t **l_582 = &l_583;
    (*l_525) = func_35(((*l_368) = ((func_37(p_11, (func_43((l_48 , func_49(((*p_11) , ((safe_add_func_uint64_t_u_u((func_53(func_56(func_59((l_48.f1 , l_61)), ((safe_sub_func_int16_t_s_s(0x62A8L, (((safe_rshift_func_int16_t_s_s((((((((~((~0xFFFDL) || ((void*)0 == l_178))) < l_48.f0) >= l_61.f0) <= l_61.f5) , 0UL) <= 65535UL) | p_13), l_48.f2)) < 8UL) || 0x258287A3L))) < p_13)), l_61.f2) || l_61.f2), p_13)) , (void*)0)))), l_204, l_48.f0, l_61.f5) , (void*)0), l_61, p_13, l_48) >= l_61.f4) & l_48.f2)));
    if ((safe_lshift_func_int16_t_s_s(0x2CA7L, (safe_sub_func_uint64_t_u_u((((((((*l_368) = (safe_mod_func_uint64_t_u_u((safe_sub_func_int64_t_s_s(((((void*)0 == l_534) & p_13) >= (p_13 , ((l_61 , ((p_13 <= (((((*l_536) = (((0x2F88E174L ^ (*p_14)) >= p_13) > 5L)) ^ p_13) > 1UL) > l_48.f2)) && p_13)) & l_48.f2))), 0L)), (-2L)))) | 1UL) <= p_13) ^ 0L) & l_61.f4) & l_538), 8L)))))
    { /* block id: 251 */
        const struct S0 l_541 = {0x7E0C3FC8L,0xE2B7C948L,-4L,0x93AD60E8L,0xA7A01AADL,6UL,0xD18EFFA9L};
        uint16_t *l_542 = &l_538;
        uint32_t **l_546 = &l_368;
        uint32_t ***l_545 = &l_546;
        uint32_t ****l_544 = &l_545;
        uint32_t ***** const l_543 = &l_544;
        int64_t l_552 = 0x1FD21F01897BB54BLL;
        uint32_t *****l_556 = &l_544;
        if (((safe_mod_func_int16_t_s_s(((l_541 , (((&l_538 == l_542) < (l_543 == &l_544)) >= (safe_mod_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((!(p_13 == 0xAE8310E1F8B28981LL)), p_13)), (l_552 ^ (-6L)))))) < p_13), (-6L))) | p_13))
        { /* block id: 252 */
            struct S0 *l_558 = &l_61;
            for (l_48.f1 = (-23); (l_48.f1 == (-18)); l_48.f1++)
            { /* block id: 255 */
                uint32_t *****l_555 = &l_544;
                int32_t l_557 = 0xC9732376L;
                l_556 = l_555;
                if (l_557)
                    continue;
            }
            (*p_11) = (l_558 != &l_541);
        }
        else
        { /* block id: 260 */
            uint32_t l_568 = 0x8AA51B17L;
            int32_t l_573 = (-1L);
            (*p_11) = l_48.f1;
            l_573 = (l_48.f0 = ((safe_mod_func_int64_t_s_s((safe_mod_func_uint16_t_u_u((+(((*p_12) = ((safe_add_func_int16_t_s_s(((p_13 <= (safe_rshift_func_int16_t_s_s(l_568, p_13))) < 0L), l_568)) >= ((safe_sub_func_int32_t_s_s(0xD783F69CL, (((((safe_sub_func_uint16_t_u_u(((1UL <= ((*p_14) = (*p_15))) > 1UL), l_61.f3)) && l_568) == 4294967293UL) | p_13) > l_61.f6))) > l_568))) > 7L)), 6L)), 0x0F55A41C67D5A098LL)) <= l_541.f3));
        }
        for (l_61.f1 = 0; (l_61.f1 <= 39); l_61.f1++)
        { /* block id: 269 */
            const int32_t *l_577 = &l_541.f4;
            const int32_t **l_576 = &l_577;
            (*l_576) = p_15;
            /* statement id: 270 */
            //assert (l_577 == &l_17);
        }
    }
    else
    { /* block id: 272 */
        for (l_61.f1 = (-6); (l_61.f1 <= 60); l_61.f1 = safe_add_func_int32_t_s_s(l_61.f1, 9))
        { /* block id: 275 */
            int32_t *l_581 = &l_61.f4;
            int32_t **l_580 = &l_581;
            (*l_580) = l_368;
            /* statement id: 276 */
            assert (l_581 == &l_61.f1);
        }
    }
    (*l_582) = l_368;
    /* statement id: 279 */
    assert (l_583 == &l_61.f1);
    return (*p_11);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_35(uint32_t  p_36)
{ /* block id: 179 */
    int64_t l_371 = 0x557342A22D07DAD9LL;
    int32_t l_376 = 0L;
    int32_t *l_380 = (void*)0;
    int32_t **l_379 = &l_380;
    int32_t l_382 = 1L;
    int32_t *l_381 = &l_382;
    int32_t l_383 = 0xF5C83813L;
    struct S0 l_400 = {0x2C610D86L,4294967295UL,0x0A6CL,0x210BEDAFL,5L,1UL,0xFC5A9C8AL};
    struct S1 l_415 = {-33,0L,38};
    struct S0 l_423 = {2L,0x0E41F59CL,-7L,0x01043741L,4L,0UL,2L};
    uint64_t l_463 = 0x5BE12F43C11021ADLL;
    uint64_t *l_462 = &l_463;
    uint32_t * const *l_466 = (void*)0;
    uint32_t * const **l_465 = &l_466;
    uint32_t * const ***l_464 = &l_465;
    uint32_t l_470 = 0x2305750DL;
    uint16_t *** const l_518 = (void*)0;
    int32_t *l_519 = (void*)0;
    int32_t *l_520 = &l_376;
    uint64_t l_521 = 18446744073709551610UL;
    int64_t l_522 = (-10L);
    int32_t *l_523 = &l_383;
    int32_t *l_524 = &l_423.f4;
    if ((((safe_mod_func_uint16_t_u_u(l_371, 0xD65FL)) && p_36) != ((((l_383 = ((*l_381) = ((safe_rshift_func_int16_t_s_s(p_36, ((((p_36 ^ (safe_sub_func_int16_t_s_s((((l_376 = 0x0A82069F27435C91LL) == (((((safe_sub_func_uint64_t_u_u(p_36, l_371)) , l_379) != &l_380) & p_36) ^ 0xFCD6L)) || l_376), 0UL))) > p_36) & p_36) != 0x53C971A0A197F9CALL))) , p_36))) ^ 0L) < p_36) > p_36)))
    { /* block id: 183 */
        struct S0 l_385 = {0L,6UL,0xC84BL,4UL,0x1BA1B34EL,0xD64265CDL,1L};
        struct S0 *l_384 = &l_385;
        struct S1 l_386 = {-53,0xDB8AL,7};
        l_384 = l_384;
        return l_386;
    }
    else
    { /* block id: 186 */
        int64_t *l_387 = &l_371;
        uint64_t l_390 = 18446744073709551615UL;
        uint32_t *l_392 = (void*)0;
        uint32_t l_394 = 0UL;
        uint32_t *l_393 = &l_394;
        struct S0 ***l_395 = (void*)0;
        struct S1 l_396 = {-18,0L,20};
        uint32_t l_397 = 0xD98FD706L;
        struct S0 *l_408 = &l_400;
        struct S0 **l_407 = &l_408;
        uint16_t l_499 = 1UL;
        uint16_t *l_498 = &l_499;
        uint16_t **l_497 = &l_498;
        uint16_t ***l_496 = &l_497;
        uint16_t ***l_501 = &l_497;
        (*l_381) = (((p_36 <= ((((((*l_387) = 0x379A0499970256F4LL) > (((safe_add_func_uint64_t_u_u((((l_390 | (safe_unary_minus_func_uint32_t_u(((*l_393) = p_36)))) , (((void*)0 == l_395) && ((void*)0 == l_392))) > ((p_36 >= p_36) , 1L)), 0x2519BD880C36692CLL)) , l_396) , p_36)) < l_390) & l_397) && p_36)) || 1UL) , p_36);
        for (l_396.f1 = 0; (l_396.f1 == (-19)); l_396.f1--)
        { /* block id: 192 */
            (*l_381) = 0xB965B373L;
        }
        if (p_36)
        { /* block id: 195 */
            struct S0 *l_401 = &l_400;
            int32_t l_419 = 0x1FED1FCFL;
            (*l_401) = l_400;
            (*l_381) = p_36;
            (*l_379) = (*l_379);
            for (l_400.f2 = 8; (l_400.f2 >= 17); l_400.f2 = safe_add_func_uint64_t_u_u(l_400.f2, 9))
            { /* block id: 201 */
                struct S0 **l_406 = &l_401;
                int32_t l_418 = (-2L);
                int32_t l_420 = 1L;
                (*l_381) = (safe_add_func_int64_t_s_s(((((((((((l_407 = l_406) != &l_408) && ((l_418 = (l_396.f0 , ((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(((((safe_add_func_int64_t_s_s(p_36, 0L)) , (((p_36 < (l_415 , ((safe_sub_func_uint16_t_u_u((((((l_415 , (0x1B64L <= l_418)) || 0x5E02L) , l_419) , l_418) || p_36), l_419)) <= 1UL))) ^ l_418) < p_36)) ^ p_36) == (-1L)), (*l_381))), p_36)) , (-7L)))) >= p_36)) | l_420) ^ 0x843F403EBEA63802LL) , l_418) & 65535UL) < l_419) ^ 0L) && l_420), 9UL));
                /* statement id: 204 */
                assert (l_407 == &l_401);
            }
            /* facts after for loop */
            assert (l_407 == &l_401 || l_407 == &l_408);
        }
        else
        { /* block id: 206 */
            int16_t l_435 = 0L;
            struct S1 l_436 = {-4,0x851CL,11};
            uint32_t ***l_468 = (void*)0;
            uint32_t ****l_467 = &l_468;
            int32_t * const l_486 = &l_382;
            uint16_t ***l_500 = &l_497;
            for (l_400.f1 = 0; (l_400.f1 == 40); l_400.f1 = safe_add_func_uint64_t_u_u(l_400.f1, 1))
            { /* block id: 209 */
                (*l_379) = func_59(l_423);
            }
            for (l_397 = 0; (l_397 > 39); l_397 = safe_add_func_uint32_t_u_u(l_397, 2))
            { /* block id: 214 */
                int32_t l_426 = (-5L);
                uint16_t l_471 = 0x024CL;
                const uint32_t *l_483 = &l_423.f1;
                const uint32_t **l_482 = &l_483;
                const uint32_t ***l_481 = &l_482;
                const uint32_t ****l_480 = &l_481;
                const uint32_t *****l_479 = &l_480;
                int32_t *l_502 = &l_423.f4;
                struct S0 *l_504 = (void*)0;
                if ((((p_36 || (0x6D7295ACF06F11A5LL || 0xB201B67642432746LL)) <= l_426) , (safe_mod_func_int32_t_s_s(l_390, (safe_rshift_func_int16_t_s_s(0x730EL, ((((safe_mod_func_int64_t_s_s(9L, (p_36 ^ l_435))) , l_436) , (-4L)) < 0L)))))))
                { /* block id: 215 */
                    int16_t *l_439 = &l_435;
                    struct S0 l_440 = {0L,0xCBE0E93FL,1L,0x2624A315L,0xD1CFE56BL,0x42E5E93CL,1L};
                    uint64_t l_442 = 0xF00E64C920B3F138LL;
                    uint64_t *l_441 = &l_442;
                    int32_t l_469 = 0xFCD28662L;
                    int32_t *l_487 = &l_376;
                    if ((safe_mod_func_uint32_t_u_u((((*l_439) = l_397) < ((l_440 , ((*l_381) = (l_390 == ((*l_441) = l_436.f1)))) > (safe_rshift_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_u(0L, 7)) && ((((safe_lshift_func_int16_t_s_s(((safe_add_func_int32_t_s_s((l_396 , p_36), (l_469 = ((safe_unary_minus_func_int32_t_s(((safe_mod_func_uint16_t_u_u((safe_sub_func_int64_t_s_s((p_36 || (((safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_u((&l_390 != l_462), 10)), l_396.f1)) , l_464) == l_467)), 0x1D47B47D4C15BA14LL)), p_36)) < 1UL))) && p_36)))) || 1UL), l_426)) >= l_470) && (-6L)) && l_471)), l_436.f1)) < 0xE569B6153CF38F01LL), p_36)))), l_440.f4)))
                    { /* block id: 220 */
                        struct S0 l_472 = {-1L,0x92E31E6CL,0L,0x9A3492D3L,0xB66011E2L,0xA6EA5990L,-5L};
                        struct S1 *l_474 = &l_415;
                        struct S1 **l_473 = &l_474;
                        (*l_379) = func_56(func_59(l_472), l_436.f2);
                        /* statement id: 221 */
                        assert (l_380 == 0);
                        (*l_381) = l_440.f2;
                        (*l_473) = &l_415;
                        (*l_381) = (safe_mod_func_int64_t_s_s(((4294967292UL ^ (0x0B90DDF7L || 1UL)) | (((0x39D9L || (safe_add_func_int32_t_s_s((&l_467 == l_479), ((safe_sub_func_int64_t_s_s(((0UL == (((*l_439) = l_472.f5) == 0xBBF0L)) == p_36), 18446744073709551606UL)) != 0x571F5CE4DA1F375FLL)))) == 1UL) > p_36)), l_396.f1));
                    }
                    else
                    { /* block id: 226 */
                        (*l_379) = &l_426;
                        /* statement id: 227 */
                        assert (l_380 == &l_426);
                    }
                    /* facts after branching */
                    assert (l_380 == &l_426 || l_380 == 0);
                    l_487 = l_486;
                    /* statement id: 229 */
                    assert (l_487 == &l_382);
                    l_502 = func_56(&l_469, (((safe_lshift_func_uint16_t_u_s((p_36 && 0xCE2155AAL), 2)) > (65535UL >= (!0x0664L))) && ((~(safe_sub_func_int16_t_s_s(0xCAA2L, (l_396.f2 >= (safe_mod_func_int32_t_s_s((((*l_486) = (((l_496 = l_496) == (l_501 = l_500)) | 0x0458CA9D6C35AECDLL)) == p_36), l_471)))))) , 0x6A3DB87AL)));
                    /* statement id: 233 */
                    assert (l_502 == &l_469);
                    (*l_381) = (*l_502);
                }
                else
                { /* block id: 235 */
                    int32_t **l_503 = &l_380;
                    (*l_503) = l_486;
                    /* statement id: 236 */
                    assert (l_380 == &l_382);
                }
                /* facts after branching */
                assert (l_380 == &l_382 || l_380 == &l_426 || l_380 == 0);
                //assert (l_502 == &l_423.f4 || l_502 == dangling);
                (*l_381) = (&l_423 == l_504);
            }
            /* facts after for loop */
            //assert (l_380 == &l_382 || l_380 == dangling || l_380 == 0);
        }
        /* facts after branching */
        //assert (l_380 == &l_382 || l_380 == dangling || l_380 == 0);
        //assert (l_407 == dangling || l_407 == &l_408);
    }
    /* facts after branching */
    //assert (l_380 == &l_382 || l_380 == dangling || l_380 == 0);
    (*l_524) = (l_400.f4 = (safe_lshift_func_uint16_t_u_s(0x5D77L, (((((*l_381) = ((*l_381) != p_36)) ^ (safe_mod_func_int64_t_s_s((!(+(((*l_523) = (safe_rshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s(((((safe_rshift_func_uint16_t_u_u((~l_423.f0), ((((((*l_520) = ((void*)0 == l_518)) == (0xB7B50C5AL & (((((l_400 , (l_400 , p_36)) <= 65535UL) || l_521) & p_36) >= p_36))) | l_415.f1) ^ p_36) > p_36))) != 0x52AECC87DAEB41E3LL) && l_522) && p_36), p_36)), p_36))) >= 0xFE033288L))), p_36))) == p_36) ^ p_36))));
    return l_415;
}


/* ------------------------------------------ */
/* 
 * reads : l_17
 * writes: l_17
 */
static int64_t  func_37(int32_t * p_38, const int32_t * const  p_39, struct S0  p_40, uint32_t  p_41, struct S1  p_42)
{ /* block id: 134 */
    int64_t l_311 = 0x334F888573A59F1FLL;
    uint32_t l_317 = 4294967295UL;
    uint32_t * const l_316 = &l_317;
    uint16_t l_324 = 0x99EBL;
    uint16_t *l_323 = &l_324;
    struct S0 l_345 = {1L,0x5CEDB85EL,0x9B8CL,18446744073709551613UL,0xF8A4D871L,18446744073709551610UL,0xAD69F502L};
    uint16_t ***l_364 = (void*)0;
    struct S1 l_365 = {-1,1L,11};
    const struct S0 **l_367 = (void*)0;
    const struct S0 ***l_366 = &l_367;
    for (p_40.f0 = 0; (p_40.f0 > (-29)); p_40.f0--)
    { /* block id: 137 */
        uint32_t * const ***l_295 = (void*)0;
        uint32_t * const ****l_294 = &l_295;
        uint32_t * const ****l_296 = &l_295;
        int32_t l_297 = 0x44DE8C69L;
        int16_t l_306 = (-1L);
        uint32_t **l_350 = (void*)0;
        uint32_t *l_353 = (void*)0;
        uint32_t **l_352 = &l_353;
        if ((*p_38))
        { /* block id: 138 */
            l_296 = (l_294 = l_294);
            if ((*p_38))
                continue;
            if (l_297)
                break;
        }
        else
        { /* block id: 143 */
            struct S0 l_299 = {0x70A9BE4DL,4294967295UL,0xD6DFL,0x52B4E385L,0xA16A1009L,0UL,0x8C21EBF7L};
            struct S0 *l_298 = &l_299;
            struct S0 **l_300 = &l_298;
            int64_t l_301 = 1L;
            int64_t *l_307 = (void*)0;
            int64_t l_309 = 0xDA35753EDEECB3B7LL;
            int64_t *l_308 = &l_309;
            uint16_t *l_326 = &l_324;
            uint32_t **l_342 = (void*)0;
            uint32_t ***l_351 = &l_350;
            const uint32_t **l_355 = (void*)0;
            const uint32_t ***l_354 = &l_355;
            uint32_t l_356 = 18446744073709551615UL;
            (*l_300) = l_298;
            if ((((l_301 == ((safe_rshift_func_uint16_t_u_s(l_297, (((*l_308) = (safe_mod_func_uint16_t_u_u(l_306, p_40.f3))) | ((~p_40.f4) | l_311)))) || l_306)) | ((safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(((((((((((((((((p_42 , 0UL) & l_297) , l_297) < l_299.f2) , p_40.f3) && p_42.f1) ^ 0xE9F75FF9L) >= 18446744073709551615UL) , p_40.f5) && 0xE00048D73544DA8ELL) && p_40.f3) , p_42.f2) , 0x2C48L) ^ l_311) , p_39) != l_316), 8)), 0L)) | l_297)) != 0x4C1D616BL))
            { /* block id: 146 */
                int32_t l_322 = 1L;
                uint32_t *l_339 = &l_317;
                uint32_t **l_338 = &l_339;
                for (l_299.f2 = (-5); (l_299.f2 >= (-1)); l_299.f2 = safe_add_func_int16_t_s_s(l_299.f2, 8))
                { /* block id: 149 */
                    uint16_t **l_325 = &l_323;
                    struct S1 l_330 = {33,8L,23};
                    struct S1 *l_329 = &l_330;
                    const uint32_t **l_341 = (void*)0;
                    const uint32_t ***l_340 = &l_341;
                    int16_t *l_343 = &l_306;
                    (*p_38) = (p_42 , (((((p_42.f0 <= p_40.f3) == (&p_40 == (((*l_316) = 4294967295UL) , (*l_300)))) < ((1L && (((safe_lshift_func_uint16_t_u_s(l_322, 11)) , ((*l_325) = l_323)) == l_326)) , 1L)) == l_299.f4) & l_297));
                    if (((l_299.f6 , ((*p_38) = ((((((p_42 , (((void*)0 == l_329) == ((((*l_343) = (safe_add_func_int32_t_s_s(((p_40.f5 & l_309) > ((safe_add_func_uint64_t_u_u(((l_324 < (safe_unary_minus_func_int32_t_s((safe_sub_func_int32_t_s_s((((*l_340) = l_338) == l_342), 4294967295UL))))) >= l_299.f3), (-1L))) < l_317)), l_322))) , l_330.f1) == 0x64FD79D3L))) ^ p_42.f1) | l_311) != (*p_38)) | 0L) & l_299.f0))) != p_40.f6))
                    { /* block id: 156 */
                        if (l_299.f2)
                            break;
                    }
                    else
                    { /* block id: 158 */
                        (*p_38) = l_306;
                        return p_40.f4;
                    }
                    /* facts after branching */
                    assert (l_341 == &l_339);
                }
                return l_322;
            }
            else
            { /* block id: 164 */
                struct S0 l_344 = {4L,0x21EEE773L,0xC8A4L,0x4E92A9D9L,0xA7B511B0L,0xF793924CL,1L};
                l_345 = l_344;
            }
            p_40.f4 = (((safe_mod_func_uint32_t_u_u((safe_sub_func_uint64_t_u_u((((*l_354) = (l_352 = (p_40.f3 , ((*l_351) = l_350)))) != &l_316), l_356)), (l_301 | l_297))) && (safe_rshift_func_uint16_t_u_s(6UL, ((((*l_316) = (!(safe_add_func_int32_t_s_s(((*p_38) = (((safe_lshift_func_uint16_t_u_s(l_299.f3, 15)) | 0UL) < 0x1165L)), l_299.f4)))) & l_345.f2) & 1UL)))) ^ l_306);
            /* statement id: 172 */
            assert (l_352 == 0);
        }
        /* facts after branching */
        assert (l_352 == 0 || l_352 == &l_353);
        l_345.f4 = ((void*)0 == l_364);
    }
    (*l_366) = ((l_365 , p_42.f0) , (void*)0);
    return l_324;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_43(uint32_t * p_44, const uint32_t * p_45, int64_t  p_46, int64_t  p_47)
{ /* block id: 85 */
    uint16_t l_207 = 0x59F8L;
    uint32_t l_231 = 0x7040BD13L;
    const uint32_t *l_230 = &l_231;
    const uint32_t ** const l_229 = &l_230;
    const uint32_t ** const *l_228 = &l_229;
    int32_t l_241 = (-3L);
    uint32_t *l_286 = &l_231;
    uint32_t **l_285 = &l_286;
    uint32_t ***l_284 = &l_285;
    struct S0 l_289 = {0xC1A74C5EL,0UL,0x4F3FL,0UL,0x6DF76FEDL,0x1531C667L,0xC4744A53L};
    for (p_47 = 21; (p_47 == (-16)); p_47--)
    { /* block id: 88 */
        return l_207;
    }
    for (l_207 = 0; (l_207 >= 27); ++l_207)
    { /* block id: 93 */
        uint16_t l_214 = 0x4C44L;
        struct S1 l_215 = {-34,0xDA9EL,41};
        uint32_t l_223 = 0x082912A9L;
        uint32_t *l_222 = &l_223;
        uint32_t * const ***l_232 = (void*)0;
        uint32_t **l_235 = (void*)0;
        uint32_t ***l_234 = &l_235;
        uint32_t ****l_233 = &l_234;
        uint32_t ****l_236 = (void*)0;
        uint32_t ***l_238 = (void*)0;
        uint32_t ****l_237 = &l_238;
        int64_t l_240 = 0x2737E1BAF48159CCLL;
        int64_t *l_239 = &l_240;
        int32_t **l_247 = (void*)0;
        int32_t l_251 = 0x589B60EEL;
        if ((safe_mod_func_uint16_t_u_u(((l_241 = ((safe_add_func_int32_t_s_s(l_214, (l_215 , (safe_add_func_int32_t_s_s((safe_add_func_uint16_t_u_u(((p_46 <= 0xCBD84F3EL) <= (((safe_mod_func_int32_t_s_s(((((*l_222) = 4294967288UL) , ((l_215.f0 == ((safe_rshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((((((*l_237) = ((*l_233) = l_228)) == &l_229) | ((*l_239) = ((l_231 ^ p_46) < l_207))) , 0L), 10)), 6)) <= l_215.f0)) & p_47)) || l_240), p_46)) , l_231) != 7UL)), l_207)), l_215.f2))))) && p_46)) ^ p_47), l_215.f2)))
        { /* block id: 99 */
            (*l_233) = (void*)0;
            /* statement id: 100 */
            assert (l_234 == 0);
        }
        else
        { /* block id: 101 */
            uint32_t l_246 = 0x1C7F72D5L;
            int32_t *l_249 = &l_241;
            int32_t **l_248 = &l_249;
            const int16_t l_254 = 0xF7D7L;
            int32_t l_270 = 0xB903DA89L;
            uint32_t * const *l_288 = (void*)0;
            uint32_t * const **l_287 = &l_288;
            struct S0 l_290 = {7L,7UL,1L,0x9FD6D78EL,-9L,18446744073709551609UL,0x821AC233L};
            struct S0 *l_291 = &l_290;
            for (p_46 = 0; (p_46 != (-14)); --p_46)
            { /* block id: 104 */
                uint32_t l_250 = 2UL;
                uint64_t l_253 = 0x1B6DA610F45062F4LL;
                uint64_t *l_252 = &l_253;
                int32_t *l_255 = &l_251;
                (*l_255) = ((*l_249) = (safe_rshift_func_int16_t_s_s(((((((*l_222) = l_246) , ((****l_237) = ((((l_247 != l_248) ^ (((0x6762014BL <= l_250) && l_250) != ((3UL == 9L) | ((*l_252) = l_251)))) >= l_254) || p_47))) , (*l_237)) == (void*)0) != p_46), 10)));
                for (l_214 = (-28); (l_214 <= 20); l_214++)
                { /* block id: 112 */
                    uint16_t l_272 = 0x637BL;
                    uint16_t *l_271 = &l_272;
                    const struct S1 l_273 = {4,0xD4E3L,32};
                    uint16_t l_275 = 0x9765L;
                    uint16_t *l_274 = &l_275;
                    (*l_248) = &l_241;
                    for (l_253 = 16; (l_253 > 47); l_253 = safe_add_func_uint64_t_u_u(l_253, 8))
                    { /* block id: 116 */
                        return p_46;
                    }
                    (*l_255) = ((p_46 > (safe_sub_func_uint16_t_u_u(((*l_274) = (safe_add_func_int64_t_s_s((safe_sub_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s(0x74CFL, p_47)) , (l_215 , ((((*l_239) = p_47) , (((safe_sub_func_uint32_t_u_u((((*l_271) = ((l_270 = 0UL) && l_231)) ^ 0x88EDL), ((*l_222) = (l_273 , l_273.f1)))) == (**l_248)) == (*l_255))) || 0x8C9BL))), p_46)), (-9L)))), l_273.f1))) ^ p_46);
                }
                (*l_248) = func_56((*l_248), (*p_45));
            }
            (**l_248) = ((((safe_mod_func_int64_t_s_s(p_47, p_47)) > (safe_mod_func_int16_t_s_s((p_47 ^ ((safe_sub_func_uint64_t_u_u((p_46 >= (safe_add_func_uint16_t_u_u(((((l_284 = l_284) != l_287) ^ (&l_214 != (l_289 , &l_207))) || p_47), 4UL))), (*l_249))) < 0xA4C0L)), 0x81E8L))) || p_47) > (*l_249));
            (*l_291) = l_290;
        }
        /* facts after branching */
        assert (l_234 == &l_229 || l_234 == 0);
        assert (l_238 == &l_229);
    }
    return l_231;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t * func_49(int32_t * p_50)
{ /* block id: 79 */
    uint64_t l_190 = 0xD7A2F4DF6C7F8FBDLL;
    uint64_t *l_191 = (void*)0;
    int32_t l_192 = 0x888C0F74L;
    uint64_t *l_197 = (void*)0;
    uint64_t l_199 = 0x6DCA7D67C41F251FLL;
    uint64_t *l_198 = &l_199;
    int32_t l_200 = (-6L);
    uint64_t l_201 = 18446744073709551612UL;
    int32_t l_203 = 3L;
    int32_t *l_202 = &l_203;
    (*l_202) = (safe_sub_func_int64_t_s_s((safe_add_func_int64_t_s_s((((l_200 = (((l_192 = (safe_rshift_func_int16_t_s_u(0xC1BAL, (0x31C3D107391EF432LL & l_190)))) >= (l_190 <= (((l_190 , (l_190 & (((6L || (((*l_198) = ((safe_lshift_func_int16_t_s_s(2L, 5)) > ((((((void*)0 == p_50) && l_190) < 0L) || l_190) || 0x76CDE9C4L))) < l_190)) | l_190) || l_190))) , l_199) <= 1L))) != 0x93934F9474E044EFLL)) >= l_190) & 0xA775L), l_190)), l_201));
    return p_50;
    /* statement id: 84 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(int32_t * p_54, int32_t  p_55)
{ /* block id: 77 */
    int64_t l_183 = (-1L);
    return l_183;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(int32_t * p_57, uint32_t  p_58)
{ /* block id: 74 */
    struct S0 l_179 = {-1L,0UL,0x98E1L,0x098C6651L,0x08F80013L,0x6FF569DEL,0x3E9DE1E5L};
    int32_t *l_181 = &l_179.f4;
    int32_t **l_180 = &l_181;
    int32_t *l_182 = &l_179.f4;
    (*l_180) = func_59(l_179);
    /* statement id: 75 */
    assert (l_181 == 0);
    return p_57;
    /* statement id: 76 */
    //assert (func_56_rv == 0 || func_56_rv == &l_241 || func_56_rv == &l_469);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_59(struct S0  p_60)
{ /* block id: 6 */
    int32_t l_63 = 0xB7D07A12L;
    int32_t *l_62 = &l_63;
    int16_t l_69 = 0xCCB2L;
    int16_t *l_68 = &l_69;
    uint64_t l_71 = 9UL;
    uint64_t *l_70 = &l_71;
    struct S1 l_72 = {-26,0x0980L,30};
    int32_t l_80 = 1L;
    int32_t *l_79 = &l_80;
    uint16_t l_82 = 0xE6F9L;
    uint16_t *l_81 = &l_82;
    int32_t **l_83 = &l_79;
    uint32_t l_141 = 4294967295UL;
    uint32_t *l_140 = &l_141;
    uint32_t **l_139 = &l_140;
    uint32_t ***l_138 = &l_139;
    int32_t *l_162 = &l_63;
    int32_t *l_163 = &l_63;
    int32_t *l_164 = &l_63;
    int32_t *l_165 = &l_80;
    int32_t *l_166 = &l_80;
    int32_t *l_167 = &l_63;
    int32_t *l_168 = &l_63;
    int32_t *l_169 = &l_63;
    int32_t *l_170 = &l_63;
    int32_t *l_171 = (void*)0;
    (*l_62) = p_60.f3;
    (*l_83) = ((((safe_mod_func_int64_t_s_s(((((*l_70) = (safe_lshift_func_int16_t_s_u(((*l_68) = p_60.f5), 12))) , l_62) == (l_72 , l_62)), 1UL)) | (((*l_81) = (safe_lshift_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((((((*l_62) , (2L & ((*l_79) = ((*l_62) = (((safe_rshift_func_uint16_t_u_u(0x636BL, 8)) ^ (*l_62)) || (-1L)))))) || 0xD96A1273L) , 8UL) != 0x9E4E2CD5B9AADFEDLL), p_60.f5)), 10))) , 0UL)) , (*l_79)) , (void*)0);
    /* statement id: 13 */
    assert (l_79 == 0);
    for (l_72.f1 = 0; (l_72.f1 != (-21)); --l_72.f1)
    { /* block id: 16 */
        int32_t l_86 = 0x85BB29A1L;
        int32_t *l_94 = (void*)0;
        if (l_86)
            break;
        for (p_60.f4 = 0; (p_60.f4 >= 18); p_60.f4 = safe_add_func_uint64_t_u_u(p_60.f4, 9))
        { /* block id: 20 */
            int32_t *l_93 = &l_63;
            int32_t *l_95 = &l_80;
            int32_t *l_96 = &l_63;
            for (p_60.f5 = (-15); (p_60.f5 < 27); ++p_60.f5)
            { /* block id: 23 */
                uint16_t **l_91 = &l_81;
                uint16_t ***l_92 = &l_91;
                (*l_92) = l_91;
                return l_94;
                /* statement id: 25 */
                //assert (func_59_rv == 0);
            }
            return l_94;
            /* statement id: 27 */
            //assert (func_59_rv == 0);
        }
        (*l_62) = (((*l_83) = l_94) == (void*)0);
    }
    for (p_60.f0 = 0; (p_60.f0 != (-8)); p_60.f0 = safe_sub_func_int64_t_s_s(p_60.f0, 8))
    { /* block id: 34 */
        uint32_t l_105 = 4294967291UL;
        uint32_t *l_104 = &l_105;
        uint32_t **l_103 = &l_104;
        int32_t *l_143 = &l_80;
        int32_t *l_144 = &l_80;
        int32_t *l_146 = &l_80;
        int32_t *l_147 = (void*)0;
        int64_t l_150 = (-8L);
        int64_t *l_149 = &l_150;
        int64_t * const *l_148 = &l_149;
        struct S0 l_161 = {0x2F3C5D46L,0xDFC38D33L,1L,0xBC482750L,0xBA655277L,0x2A06A2A8L,0x3BF6274BL};
        (*l_62) = ((safe_rshift_func_uint16_t_u_s(0x0D67L, 3)) < (l_79 == ((*l_103) = l_62)));
        /* statement id: 36 */
        assert (l_104 == &l_63);
        if (p_60.f6)
        { /* block id: 37 */
            uint64_t l_112 = 0x4A0BD6DA29A6A910LL;
            int16_t *l_117 = &l_69;
            struct S1 l_134 = {32,-1L,36};
            int32_t *l_145 = &l_63;
            struct S1 *l_152 = &l_134;
            for (l_63 = 14; (l_63 < (-13)); --l_63)
            { /* block id: 40 */
                int32_t *l_119 = &l_80;
                uint64_t *l_122 = &l_71;
                int64_t * const **l_151 = &l_148;
                for (l_80 = 0; (l_80 == 24); ++l_80)
                { /* block id: 43 */
                    int32_t *l_118 = &l_80;
                    uint16_t l_124 = 0UL;
                    uint16_t *l_123 = &l_124;
                    int64_t l_126 = (-3L);
                    int64_t *l_125 = &l_126;
                    int64_t *l_127 = (void*)0;
                    int64_t l_129 = 0x6C63C429AA74C462LL;
                    int64_t *l_128 = &l_129;
                    uint16_t l_131 = 1UL;
                    uint16_t *l_130 = &l_131;
                    int32_t l_133 = 1L;
                    int32_t *l_132 = &l_133;
                    uint32_t l_137 = 0x6355718CL;
                    uint32_t *l_136 = &l_137;
                    (*l_132) = (safe_sub_func_int64_t_s_s((((*l_81) = (l_112 | 0x3A75C332L)) != (-2L)), (safe_sub_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((*l_130) = ((((&l_69 != l_117) , l_118) != ((*l_83) = l_119)) & ((l_112 | (((*l_128) = (((safe_sub_func_int64_t_s_s(((*l_125) = (((*l_123) = (l_122 == (void*)0)) == (*l_119))), 1UL)) , l_112) || l_112)) | (-7L))) & 0x8EE533B9E22A4178LL))), 7)), (*l_62)))));
                    /* statement id: 50 */
                    assert (l_79 == &l_80);
                    l_134 = l_134;
                    if ((!(((*l_68) = (((*l_136) = 1UL) , (&l_118 == &l_119))) <= 65535UL)))
                    { /* block id: 54 */
                        l_138 = (void*)0;
                        /* statement id: 55 */
                        assert (l_138 == 0);
                        (*l_83) = l_104;
                        /* statement id: 56 */
                        assert (l_79 == &l_63);
                    }
                    else
                    { /* block id: 57 */
                        int32_t *l_142 = &l_63;
                        return l_147;
                        /* statement id: 58 */
                        //assert (func_59_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_79 == &l_63);
                    assert (l_138 == 0);
                }
                (*l_151) = l_148;
            }
            (*l_152) = (p_60.f3 , (l_72 = l_72));
        }
        else
        { /* block id: 65 */
            struct S1 *l_153 = &l_72;
            int64_t **l_155 = &l_149;
            int64_t ***l_154 = &l_155;
            int32_t l_160 = (-8L);
            (*l_153) = l_72;
            (*l_153) = (((p_60 , (1UL ^ (65533UL || (4294967295UL || (((((*l_68) = (l_154 == (void*)0)) || (safe_rshift_func_uint16_t_u_s(((safe_add_func_int16_t_s_s((p_60.f6 >= l_160), (l_161 , p_60.f1))) < (*l_144)), 9))) || 1UL) == 3UL))))) , p_60.f1) , l_72);
            if (p_60.f6)
                break;
        }
        (*l_146) = (((void*)0 == l_104) < 65532UL);
    }
    /* facts after for loop */
    assert (l_79 == &l_63 || l_79 == 0);
    assert (l_138 == 0 || l_138 == &l_139);
    return l_171;
    /* statement id: 73 */
    //assert (func_59_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 12
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 1
   indirect level: 2, occurrence: 0
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 24
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 16

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 129
   depth: 2, occurrence: 28
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 2
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2
   depth: 32, occurrence: 1
   depth: 34, occurrence: 2
   depth: 40, occurrence: 1

XXX total number of pointers: 198

XXX times a variable address is taken: 178
XXX times a pointer is dereferenced on RHS: 41
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 109
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 1
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 609

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 218
   level: 2, occurrence: 38
   level: 3, occurrence: 4
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 78
XXX number of pointers point to scalars: 106
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 22.7
XXX average alias set size: 1.1

XXX times a non-volatile is read: 559
XXX times a non-volatile is write: 275
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 126
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 21
   depth: 2, occurrence: 33
   depth: 3, occurrence: 16
   depth: 4, occurrence: 13
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 16.9
XXX percentage an existing variable is used: 83.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

