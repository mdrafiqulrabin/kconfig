/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3729304188
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
inline static uint32_t  func_9(uint32_t  p_10, uint64_t  p_11, int32_t  p_12, uint32_t  p_13);
inline static const uint16_t  func_16(float  p_17, float  p_18, int16_t  p_19);
inline static int16_t  func_28(uint64_t  p_29);
static int32_t * func_30(const int32_t * p_31, int32_t * p_32, uint16_t  p_33, uint32_t  p_34, int32_t * p_35);
static int32_t * func_36(float  p_37, uint32_t  p_38);
static int32_t * func_44(int32_t  p_45);
static int32_t  func_57(int32_t ** p_58, int32_t * p_59);
static int32_t  func_60(int32_t * p_61);
inline static uint32_t  func_71(int32_t ** p_72, uint16_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int64_t l_6 = 0xCC25BFC88EB98764LL;
    int32_t l_918 = 0L;
    float **l_934 = (void*)0;
    float ***l_933 = &l_934;
    float ****l_932 = &l_933;
    uint16_t l_948 = 0x321BL;
    int32_t *l_984 = &l_918;
    int32_t **l_983 = &l_984;
    uint16_t l_1028 = 0x1183L;
    int32_t *****l_1042 = (void*)0;
    int64_t l_1060 = 8L;
    uint64_t l_1074 = 1UL;
    uint64_t l_1115 = 0x68AD2A7891452AEALL;
    uint8_t l_1118 = 0UL;
    float *****l_1127 = (void*)0;
    uint16_t l_1134 = 0xFFC7L;
    int32_t l_1149 = (-9L);
    uint32_t l_1197 = 0x1F4C8AFCL;
    int16_t l_1198 = (-3L);
    int64_t l_1221 = 1L;
    int32_t *l_1229 = &l_918;
    uint64_t l_1230 = 18446744073709551615UL;
    if ((((int64_t)(((uint16_t)0xF84BL * (uint16_t)((((((l_6 == ((int16_t)(func_9((l_6 || (((int16_t)((l_6 | func_16(l_6, l_6, l_6)) ^ ((uint32_t)(18446744073709551612UL < l_6) / (uint32_t)l_6)) >> (int16_t)l_6) == l_6)), l_6, l_6, l_6) ^ l_918) - (int16_t)0xCA34L)) >= 18446744073709551615UL) & 0xE1AB5888L) | l_918) ^ l_918) == l_6)) || 0x5CCFE0451072120BLL) % (int64_t)0x93BCEDA14FC925C5LL) < l_6))
    { /* block id: 359 */
        int16_t l_943 = 0x903CL;
        float l_969 = (-0x1.6p-1);
        const float *l_968 = &l_969;
        const float **l_967 = &l_968;
        const float ***l_966 = &l_967;
        int32_t *l_982 = &l_918;
        int32_t **l_981 = &l_982;
        float l_985 = (-0x5.3p-1);
        int32_t ***l_1031 = (void*)0;
        int32_t ***l_1032 = &l_983;
        for (l_918 = 0; (l_918 == 14); l_918++)
        { /* block id: 362 */
            float l_931 = 0x0.3p-1;
            float *l_930 = &l_931;
            float **l_929 = &l_930;
            float ***l_928 = &l_929;
            float ****l_927 = &l_928;
            int32_t l_946 = 1L;
            float l_947 = 0x1.528757p+60;
            int32_t l_965 = 0xAB9E0868L;
            int32_t l_996 = 0xCEBBEE18L;
            int32_t l_1014 = 0xDED09E91L;
            uint16_t l_1015 = 0UL;
            (*l_930) = (((float)(0x3.8p-1 < ((float)(((float)(-0x10.Cp+1) * (float)((l_927 != l_932) != ((-0x5.Ap+1) != ((float)((float)(((float)((((((float)(l_943 <= l_943) / (float)((float)l_943 / (float)0xE.146134p-36)) != 0x6.6E29DBp+53) <= 0x0.Dp-1) == l_946) != l_946) / (float)l_918) > l_947) - (float)l_948) / (float)0x2.F4F6C6p+9)))) >= (-0x2.7p+1)) * (float)l_6)) / (float)l_943) >= l_946);
            (*l_930) = ((float)((l_946 > 0x0.4p+1) <= ((float)(l_946 < ((float)((float)((((float)0xA.8A5461p+88 - (float)(((float)((float)l_948 * (float)l_946) / (float)(0xD.4CA2EEp-23 < ((float)((0x2.A0EBC6p-1 != (l_6 < l_946)) < 0xD.E7AB37p+71) * (float)l_6))) <= l_6)) < l_948) > l_943) + (float)l_965) - (float)l_946)) + (float)l_918)) * (float)l_943);
        }
        (*l_1032) = &l_984;
        (*l_983) = (*l_983);
    }
    else
    { /* block id: 401 */
        uint64_t l_1035 = 0x4EAFABF8F57F5929LL;
        int32_t *l_1036 = &l_918;
        int16_t l_1039 = 0x6030L;
        int32_t ***l_1045 = &l_983;
        int32_t ****l_1044 = &l_1045;
        int32_t *****l_1043 = &l_1044;
        for (l_918 = (-6); (l_918 >= 21); ++l_918)
        { /* block id: 404 */
            if (l_1035)
                break;
        }
        (*l_983) = l_1036;
        for (l_6 = 5; (l_6 == 20); ++l_6)
        { /* block id: 410 */
            return l_1039;
        }
        for (l_918 = 0; (l_918 < (-10)); l_918--)
        { /* block id: 415 */
            int32_t ***l_1046 = &l_983;
            l_1043 = l_1042;
            /* statement id: 416 */
            assert (l_1043 == 0);
            (*l_1044) = l_1046;
        }
        /* facts after for loop */
        assert (l_1043 == 0 || l_1043 == &l_1044);
    }
    (*l_984) = 0x1.Ep-1;
    if ((*l_984))
    { /* block id: 421 */
        float l_1049 = 0x7.0CFEC3p+6;
        int32_t l_1050 = 0xBD36AD07L;
        float ****l_1103 = (void*)0;
        int32_t **l_1117 = (void*)0;
        uint16_t l_1148 = 0x0A69L;
        int32_t *l_1151 = (void*)0;
        int32_t l_1152 = (-8L);
        int64_t l_1194 = (-1L);
        int64_t l_1205 = 0L;
        l_1050 = ((float)(l_1049 > l_1050) + (float)((float)(((0x3.Ap-1 != 0xB.C18462p+72) <= (**l_983)) < (!((float)((float)((float)l_1060 - (float)l_1050) + (float)((((float)(!l_1050) / (float)((((float)((float)(l_1050 <= (*l_984)) / (float)(*l_984)) + (float)l_1050) > 0xF.CC9A6Fp-47) > l_1050)) > l_1050) == l_1050)) / (float)0x1.Bp+1))) / (float)(*l_984)));
        if (((uint16_t)((uint16_t)l_1050 >> (uint16_t)6) << (uint16_t)(0xD9B2L != (l_1050 & ((uint64_t)(0UL && (l_1074 <= ((int16_t)l_1050 * (int16_t)(((uint64_t)l_1050 / (uint64_t)((int16_t)((l_1050 <= (((((int16_t)(((0x0BB6DDCBL && 0xD97B9249L) >= 0UL) == l_1050) - (int16_t)l_1050) || (**l_983)) ^ l_1050) | (*l_984))) ^ l_1050) << (int16_t)(**l_983))) > 2UL)))) % (uint64_t)8UL)))))
        { /* block id: 423 */
            return l_1050;
        }
        else
        { /* block id: 425 */
            int16_t l_1095 = 1L;
            int32_t **l_1100 = (void*)0;
            float ****l_1104 = &l_933;
            uint16_t l_1106 = 0x6E3DL;
            int64_t l_1107 = 1L;
            const int32_t *l_1137 = (void*)0;
            uint16_t l_1220 = 0x947DL;
            int32_t *l_1222 = &l_1152;
            if ((((uint16_t)((uint16_t)((((int64_t)((int64_t)((int64_t)((int16_t)((l_1095 < ((int16_t)(l_1050 ^ (((uint16_t)(((void*)0 == l_1100) < ((int16_t)(l_1103 == l_1104) + (int16_t)(!((*l_984) | (((void*)0 != &l_983) > l_1095))))) / (uint16_t)(**l_983)) && l_1095)) << (int16_t)l_1050)) && 0x43BDL) >> (int16_t)l_1106) + (int64_t)l_1050) + (int64_t)(**l_983)) + (int64_t)0xE39A167CC05716B8LL) && l_1107) && l_1050) >> (uint16_t)12) >> (uint16_t)1) & (*l_984)))
            { /* block id: 426 */
                return l_1050;
            }
            else
            { /* block id: 428 */
                uint16_t l_1112 = 8UL;
                float ***l_1119 = &l_934;
                int32_t ***l_1146 = &l_983;
                int32_t ****l_1145 = &l_1146;
                for (l_918 = 0; (l_918 < 20); l_918++)
                { /* block id: 431 */
                    int32_t l_1116 = 0x82275270L;
                }
                if ((((*l_1104) == l_1119) ^ ((((uint16_t)((uint16_t)(((int64_t)(-2L) + (int64_t)l_1112) < ((l_1106 & (*l_984)) > l_1112)) << (uint16_t)12) % (uint16_t)l_1112) & l_1095) || (*l_984))))
                { /* block id: 436 */
                    int32_t *l_1126 = &l_1050;
                    (*l_983) = l_1126;
                    /* statement id: 437 */
                    assert (l_984 == &l_1050);
                    return l_1112;
                }
                else
                { /* block id: 439 */
                    int32_t *l_1128 = &l_1050;
                    int32_t l_1150 = 0L;
                    l_1127 = &l_932;
                    /* statement id: 440 */
                    assert (l_1127 == &l_932);
                    if (l_1107)
                        goto lbl_1129;
lbl_1129:
                    l_1128 = (void*)0;
                    /* statement id: 441 */
                    assert (l_1128 == 0);
                    for (l_1050 = (-6); (l_1050 > (-23)); l_1050 -= 1)
                    { /* block id: 445 */
                        (**l_983) = ((int32_t)l_1112 - (int32_t)0L);
                        (**l_983) = l_1134;
                    }
                    for (l_1118 = 0; (l_1118 != 52); ++l_1118)
                    { /* block id: 451 */
                        uint32_t l_1142 = 18446744073709551607UL;
                        int32_t ****l_1147 = &l_1146;
                        (*l_983) = (***l_1145);
                        return l_1150;
                    }
                }
                /* facts after branching */
                assert (l_1127 == &l_932);
                if ((0x2DB9001F8D89485ELL || l_1152))
                { /* block id: 456 */
                    int64_t l_1158 = 4L;
                    int32_t l_1163 = (-1L);
                    const float *l_1178 = &l_1049;
                    const float **l_1177 = &l_1178;
                    if (((int16_t)((!((int16_t)l_1158 << (int16_t)(***l_1146))) > (****l_1145)) * (int16_t)((int16_t)(((**l_983) != (((*l_984) <= ((void*)0 == (*l_1145))) >= ((int64_t)0xC6E4108ADC69A956LL - (int64_t)0x7567A4B037EEA187LL))) != l_1163) << (int16_t)15)))
                    { /* block id: 457 */
                        float l_1176 = (-0x3.Fp-1);
                        int32_t l_1179 = 0x5655CBAFL;
                        (*l_984) = ((int16_t)((int16_t)((void*)0 == &l_1104) >> (int16_t)l_1163) * (int16_t)(1L != ((uint16_t)((int32_t)6L / (int32_t)(((((int16_t)0x1B37L >> (int16_t)((***l_1146) | 65531UL)) != 0x9D89L) != l_1163) && l_1158)) * (uint16_t)(****l_1145))));
                        (*l_984) = (((0x0807BDA627542130LL < ((uint16_t)(((void*)0 == (*l_1145)) > l_1163) >> (uint16_t)8)) || l_1163) != 0x90693E8D6150A33CLL);
                        l_1179 = ((void*)0 == l_1177);
                        (*l_984) = l_1163;
                    }
                    else
                    { /* block id: 462 */
                        const int16_t l_1193 = 0x5F1FL;
                        int32_t l_1199 = 0x2BCA6EA1L;
                        l_1199 = (((float)((float)((-(float)((float)(((float)((float)(****l_1145) * (float)((float)l_1193 / (float)l_1194)) * (float)(0x6.5p+1 < l_1158)) != ((((float)0xE.97732Dp-11 - (float)(****l_1145)) <= (0x3.99665Ap+6 <= l_1197)) < (-0x6.6p-1))) - (float)0x1.7E9E7Bp-62)) <= l_1198) / (float)0x7.48D930p+96) / (float)0x0.861703p+88) == 0xB.B5719Ep-97);
                        (***l_1145) = (***l_1145);
                    }
                    (****l_1145) = (~((uint32_t)((int16_t)5L - (int16_t)((*l_984) != l_1205)) % (uint32_t)l_1158));
                }
                else
                { /* block id: 467 */
                    return l_1205;
                }
                (**l_1146) = (void*)0;
                /* statement id: 470 */
                assert (l_984 == 0);
            }
            /* facts after branching */
            assert (l_984 == 0);
            assert (l_1127 == &l_932);
            (*l_1222) = ((uint16_t)((uint32_t)((l_1148 >= ((((uint16_t)(((uint16_t)l_1050 * (uint16_t)((((&l_1152 == l_1137) == 4294967290UL) && 0x5E7A4E39AE2E96B3LL) >= (l_1103 == l_1104))) | (((uint16_t)((uint64_t)(((int64_t)(l_1095 == l_1220) / (int64_t)0xD2BCA7C353E383D4LL) == 18446744073709551615UL) - (uint64_t)l_1221) << (uint16_t)5) && 0x9DD7L)) >> (uint16_t)4) >= l_1194) <= l_1107)) ^ 0x16DBF644AA5F0BBDLL) - (uint32_t)0xD0AC7146L) - (uint16_t)l_1095);
        }
        /* facts after branching */
        assert (l_984 == 0);
        assert (l_1127 == &l_932);
        l_1127 = &l_1103;
        /* statement id: 474 */
        assert (l_1127 == &l_1103);
    }
    else
    { /* block id: 475 */
        int16_t l_1223 = 0x65F9L;
        const int32_t *l_1227 = &l_918;
        const int32_t **l_1226 = &l_1227;
        uint16_t l_1228 = 0x1B75L;
        (*l_1226) = func_36(l_1223, ((uint32_t)(((-1L) >= 4294967295UL) == ((((*l_984) || (l_1223 || ((l_1223 < (((void*)0 != l_1226) < (0x5787L == 0UL))) <= (**l_983)))) < 7L) ^ (*l_984))) % (uint32_t)l_1228));
        /* statement id: 476 */
        assert (l_1227 == 0);
    }
    /* facts after branching */
    assert (l_984 == &l_918 || l_984 == 0);
    //assert (l_1127 == 0 || l_1127 == dangling);
    (*l_983) = l_1229;
    /* statement id: 478 */
    assert (l_984 == &l_918);
    return l_1230;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_9(uint32_t  p_10, uint64_t  p_11, int32_t  p_12, uint32_t  p_13)
{ /* block id: 355 */
    const uint16_t l_914 = 5UL;
    float l_916 = (-0x1.1p-1);
    float *l_915 = &l_916;
    uint64_t l_917 = 0x24E32DE11331BE53LL;
    (*l_915) = l_914;
    (*l_915) = (l_917 != l_917);
    return p_13;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_16(float  p_17, float  p_18, int16_t  p_19)
{ /* block id: 1 */
    int32_t l_23 = 0xFEAF86F2L;
    int32_t *l_22 = &l_23;
    float *l_898 = (void*)0;
    float **l_897 = &l_898;
    float ***l_896 = &l_897;
    for (p_19 = (-6); (p_19 <= (-20)); p_19 -= 7)
    { /* block id: 4 */
        if (p_19)
            break;
        l_22 = (void*)0;
        /* statement id: 6 */
        assert (l_22 == 0);
        l_23 = (((-4L) | (((int16_t)l_23 - (int16_t)(((int16_t)func_28(p_19) - (int16_t)(p_19 > p_19)) >= (&l_23 != (void*)0))) == ((int16_t)0xF632L >> (int16_t)5))) || p_19);
        return l_23;
    }
    p_18 = ((p_17 == ((float)(l_896 != &l_897) - (float)(!((&l_22 != (void*)0) < ((float)((float)p_19 - (float)((*l_22) >= (((float)(*l_22) - (float)((float)((float)p_18 + (float)(-0x1.8p-1)) * (float)p_18)) > p_19))) * (float)(*l_22)))))) <= p_19);
    for (l_23 = 0; (l_23 != (-15)); l_23 -= 3)
    { /* block id: 351 */
        if (p_19)
            break;
    }
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_28(uint64_t  p_29)
{ /* block id: 7 */
    int32_t l_39 = 1L;
    int32_t l_41 = 0xEA1B1489L;
    int32_t *l_40 = &l_41;
    float l_870 = 0x0.Ep+1;
    float *l_869 = &l_870;
    float **l_868 = &l_869;
    float ***l_867 = &l_868;
    float ****l_866 = &l_867;
    int32_t **l_891 = &l_40;
    (*l_891) = func_30(func_36(l_39, (l_40 == (void*)0)), &l_41, p_29, (l_866 == &l_867), func_36(p_29, (*l_40)));
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(const int32_t * p_31, int32_t * p_32, uint16_t  p_33, uint32_t  p_34, int32_t * p_35)
{ /* block id: 334 */
    uint16_t l_871 = 0UL;
    int32_t l_874 = 0xD3CB317AL;
    int32_t *l_873 = &l_874;
    int32_t **l_872 = &l_873;
    (*p_32) = l_871;
    (*l_872) = p_35;
    /* statement id: 336 */
    assert (l_873 == 0);
    for (l_871 = 20; (l_871 < 43); l_871 += 1)
    { /* block id: 339 */
        uint64_t l_877 = 0UL;
        float l_890 = (-0x5.3p-1);
        float *l_889 = &l_890;
        float **l_888 = &l_889;
        float ***l_887 = &l_888;
        float ****l_886 = &l_887;
        (*p_32) = (l_877 || (((int16_t)(&l_873 == (void*)0) * (int16_t)p_34) ^ (l_877 != ((int64_t)p_33 - (int64_t)((int16_t)((int16_t)((void*)0 == l_886) + (int16_t)l_877) / (int16_t)p_33)))));
    }
    return p_32;
    /* statement id: 342 */
    //assert (func_30_rv == &l_41);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(float  p_37, uint32_t  p_38)
{ /* block id: 8 */
    int32_t ***l_366 = (void*)0;
    int32_t ****l_365 = &l_366;
    int32_t *****l_364 = &l_365;
    int32_t l_386 = 0x103FD7DEL;
    float *l_432 = (void*)0;
    int32_t l_433 = 0x7FCCB76EL;
    uint8_t l_467 = 7UL;
    int32_t *l_471 = (void*)0;
    float ****l_773 = (void*)0;
    int32_t *l_864 = &l_433;
    int32_t *l_865 = (void*)0;
    for (p_38 = 0; (p_38 > 31); ++p_38)
    { /* block id: 11 */
        uint16_t l_46 = 1UL;
        int32_t **l_54 = (void*)0;
        int32_t l_56 = 9L;
        int32_t *l_55 = &l_56;
        int32_t **l_360 = (void*)0;
        int32_t **l_361 = &l_55;
        const int32_t *****l_367 = (void*)0;
        float l_371 = (-0x2.3p+1);
        float *l_370 = &l_371;
        float **l_369 = &l_370;
        float ***l_368 = &l_369;
        const uint64_t l_383 = 0UL;
        l_55 = func_44(l_46);
        /* statement id: 14 */
        assert (l_55 == 0);
        (*l_361) = func_44(func_57(&l_55, func_44(func_60(&l_56))));
        (*l_361) = func_44(((((l_364 == l_367) > (l_368 == (void*)0)) & ((((((uint32_t)p_38 + (uint32_t)((int16_t)(((uint64_t)((~0x13692EB2F9758E7DLL) || p_38) - (uint64_t)(((int16_t)((int16_t)(l_383 ^ ((int16_t)(8UL == p_38) >> (int16_t)3)) << (int16_t)p_38) + (int16_t)p_38) > p_38)) || p_38) - (int16_t)0xFED7L)) != p_38) || 0xC1F29E83L) < l_386) > p_38)) || 0L));
    }
    return l_865;
    /* statement id: 333 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(int32_t  p_45)
{ /* block id: 12 */
    int32_t l_48 = 0x4484F75DL;
    int32_t *l_47 = &l_48;
    int32_t *l_49 = &l_48;
    int32_t *l_50 = &l_48;
    int32_t *l_51 = &l_48;
    int32_t *l_52 = &l_48;
    int32_t *l_53 = (void*)0;
    return l_53;
    /* statement id: 13 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_57(int32_t ** p_58, int32_t * p_59)
{ /* block id: 73 */
    int32_t l_148 = 0x4088AFD6L;
    int32_t *l_147 = &l_148;
    int32_t **l_146 = &l_147;
    int32_t ***l_145 = &l_146;
    float l_150 = 0xC.BD0D1Fp-68;
    float *l_149 = &l_150;
    const int16_t l_158 = 7L;
    float **l_349 = &l_149;
    int32_t l_359 = 1L;
    (*l_149) = ((float)((void*)0 != l_145) / (float)(**l_146));
    if (((((&l_145 != &l_145) != (((uint64_t)(((int16_t)(((uint16_t)(*l_147) + (uint16_t)(~(((1L && 7UL) & (**l_146)) != ((((((***l_145) != (**l_146)) & (**l_146)) >= 0x57D0L) & (**l_146)) & (**l_146))))) | (*l_147)) * (int16_t)0x0513L) ^ 4L) % (uint64_t)(***l_145)) || (*l_147))) <= l_158) < 0x2EBD030DF63A0E5FLL))
    { /* block id: 75 */
        int32_t *l_159 = &l_148;
        int32_t ***l_201 = &l_146;
        float l_221 = 0x1.Ep-1;
        int32_t l_223 = (-7L);
        (*p_58) = l_159;
        /* statement id: 76 */
        //assert (l_55 == &l_148);
        (*l_149) = (***l_145);
        if (((uint16_t)((int16_t)0x74B4L / (int16_t)((uint16_t)((*l_159) >= (0x1AC4L >= (((uint16_t)(18446744073709551615UL | ((((int32_t)(((uint32_t)((p_59 != p_59) == (((uint16_t)65535UL >> (uint16_t)15) <= ((0x40B5A963199CE392LL ^ ((((int16_t)(-(int16_t)(*l_159)) * (int16_t)0x5B52L) && (*l_159)) | (*l_159))) && (**l_146)))) - (uint32_t)(*l_159)) >= (***l_145)) % (int32_t)(*l_159)) == (*l_159)) & 18446744073709551615UL)) * (uint16_t)(*l_147)) >= 0x3B3BL))) << (uint16_t)(***l_145))) + (uint16_t)(**l_146)))
        { /* block id: 78 */
            const int32_t l_185 = 0xCD4B1B73L;
            (*l_149) = ((*l_159) < ((float)(((((float)((*l_147) < ((float)((float)(*l_147) * (float)l_185) / (float)((float)l_185 - (float)((float)((float)(-0x1.8p-1) + (float)(l_185 <= (l_159 != (void*)0))) - (float)0x0.7p-1)))) - (float)0x1.Ep-1) <= (*l_159)) == (*l_159)) > 0x1.7B9584p-14) / (float)(*l_159)));
            (**l_145) = (void*)0;
            /* statement id: 80 */
            assert (l_147 == 0);
            (*l_159) = ((void*)0 != p_59);
        }
        else
        { /* block id: 82 */
            int32_t *l_202 = &l_148;
            int32_t ****l_294 = &l_201;
            int16_t l_298 = 0xEE40L;
            (*l_149) = ((float)(((**l_146) == (((float)(((float)(!(0x1.Ep-1 <= (0xD.C5D1B8p+12 > (*l_147)))) + (float)((float)((void*)0 == l_201) / (float)(((**l_201) != l_202) < (*l_147)))) == (*l_202)) * (float)0xC.37DEE9p+38) < (**l_146))) <= 0x0.0p+1) + (float)0x1.2p+1);
            if (((uint64_t)((int32_t)(*l_159) - (int32_t)((*l_202) & ((-6L) < ((int16_t)(((uint64_t)((**p_58) >= ((uint16_t)((uint32_t)((***l_201) & (*l_159)) % (uint32_t)((int16_t)6L * (int16_t)(((uint16_t)(((uint16_t)(*l_159) * (uint16_t)((0xCE81L != (***l_201)) & 65535UL)) & (*l_159)) >> (uint16_t)(***l_145)) != (*l_159)))) - (uint16_t)(***l_201))) % (uint64_t)(***l_145)) & (*l_202)) * (int16_t)(*l_202))))) - (uint64_t)(**l_146)))
            { /* block id: 84 */
                float *l_222 = &l_150;
                (*l_146) = (**l_201);
                (*l_202) = (l_222 == (void*)0);
                return l_223;
                /* statement id: 87 */
                //assert (l_55 == dangling);
            }
            else
            { /* block id: 88 */
                int32_t *l_226 = &l_223;
                int32_t ****l_250 = (void*)0;
                for (l_223 = 9; (l_223 <= (-15)); l_223 -= 1)
                { /* block id: 91 */
                    int32_t *l_229 = &l_148;
                    l_202 = l_226;
                    /* statement id: 92 */
                    assert (l_202 == &l_223);
                    (*l_159) = (((int16_t)((l_229 != (*p_58)) || (**l_146)) << (int16_t)(**l_146)) > (**l_146));
                    for (l_148 = (-7); (l_148 == 22); l_148++)
                    { /* block id: 96 */
                        uint32_t l_232 = 0x0B4975F8L;
                        (*l_149) = (((*l_226) == ((l_232 < ((float)((float)(***l_201) * (float)((float)(&p_59 == (void*)0) * (float)((void*)0 == l_202))) * (float)0xC.F4DA18p+47)) >= ((float)((float)(((*l_226) >= (*l_229)) < (***l_145)) / (float)(*l_229)) / (float)0x1.Ap-1))) >= 0x8.2p+1);
                        (*l_149) = ((-0x8.8p+1) < ((float)(((float)((!(((float)((l_250 == &l_201) <= (((float)((float)(((float)((void*)0 != (*l_201)) + (float)((((float)(((void*)0 != l_202) != ((float)(((float)0xC.B4722Cp+18 - (float)(0xB.82D50Ep+43 == 0xF.534DAAp-76)) != 0x1.0p+1) / (float)(*l_202))) + (float)0x0.Ep-1) > l_232) != 0x0.D4884Fp+86)) != 0x0.2p-1) - (float)0x6.57A5ACp+26) - (float)(*l_229)) > 0x0.05D3DBp-78)) * (float)0x0.0p-1) >= (*l_229))) == (-0x1.7p+1)) + (float)0x1.Fp+1) != 0x0.9p-1) * (float)(*l_147)));
                    }
                }
                /* facts after for loop */
                assert (l_202 == &l_223 || l_202 == &l_148);
                if ((l_250 != (void*)0))
                { /* block id: 101 */
                    uint64_t l_265 = 7UL;
                    const float *l_275 = &l_221;
                    (*p_58) = func_44(((int32_t)((*l_202) ^ l_265) - (int32_t)(-(int16_t)((uint16_t)((((uint32_t)((int16_t)(p_59 == p_59) + (int16_t)((*l_147) > ((int16_t)(((l_202 == l_275) || (-8L)) >= ((int16_t)(*l_202) >> (int16_t)6)) << (int16_t)(***l_145)))) - (uint32_t)(**p_58)) == 0xE251C85CL) >= (*l_202)) << (uint16_t)0))));
                    /* statement id: 102 */
                    //assert (l_55 == 0);
                    return l_265;
                }
                else
                { /* block id: 104 */
                    (***l_145) = (&p_58 == &p_58);
                }
                for (l_148 = (-21); (l_148 != (-21)); l_148 += 9)
                { /* block id: 109 */
                    uint16_t l_297 = 0x5A49L;
                    (**l_145) = (*p_58);
                    (*l_149) = ((float)(((float)((float)((***l_201) > ((float)((0xD.F005D3p-13 < (((float)(*l_159) + (float)(((*l_159) < (((((float)((((((*l_159) >= 0x0.8p+1) == ((float)((l_294 != &l_145) != (((float)l_297 / (float)l_297) == 0x1.7p+1)) * (float)l_297)) >= (***l_201)) < (-0x9.7p-1)) > (*l_202)) + (float)0x0.Dp-1) <= 0x1.4p+1) >= 0x1.3p-1) > (*l_226))) >= l_297)) <= (-0x1.9p-1))) < (*l_147)) * (float)(*l_226))) / (float)l_298) + (float)(*l_226)) != 0x0.719298p-55) * (float)0xB.E7D8B5p+89);
                }
                (*l_149) = ((float)((&l_146 != (void*)0) > ((((((float)(((float)(***l_201) * (float)((float)((float)0xC.DF14D3p-61 + (float)(0x6.5E538Cp+69 > (((((float)(0x7.79CB04p-75 < (0x0.243415p+97 != (((float)(***l_145) / (float)(p_59 != p_59)) > (***l_201)))) + (float)(*l_226)) > (*l_202)) > (*l_202)) >= (***l_201)))) - (float)0x0.5DB324p+12)) != (-0x2.Ep-1)) * (float)0xE.0DFA86p-87) < (*l_202)) == 0x0.EF1AE5p+22) >= 0x1.Ap-1) != (***l_201))) + (float)(*l_226));
            }
            /* facts after branching */
            assert (l_202 == &l_223 || l_202 == &l_148);
            for (l_148 = (-11); (l_148 <= (-7)); l_148++)
            { /* block id: 117 */
                int32_t l_323 = 0L;
                int32_t l_334 = (-1L);
                int32_t l_335 = 0x5B8B129FL;
                l_334 = (((****l_294) != 0xB.B52015p+37) < ((float)(((float)(((float)0x1.0p+1 + (float)((float)l_323 * (float)l_323)) < ((float)((float)0xF.6E15FCp+52 - (float)((float)0xB.AFA4DCp-32 / (float)((float)(((((float)(*l_147) * (float)(l_323 <= (**l_146))) < l_323) == 0x9.Fp-1) == l_323) - (float)(****l_294)))) + (float)l_323)) / (float)(-0x3.8p-1)) != 0x1.6p-1) * (float)l_323));
                (**l_201) = &l_334;
                /* statement id: 119 */
                assert (l_147 == &l_334);
                (*l_149) = (-0x2.Bp+1);
                return l_335;
                /* statement id: 121 */
                //assert (l_55 == dangling);
            }
            (*l_146) = (**l_145);
        }
        /* facts after branching */
        assert (l_147 == &l_148 || l_147 == 0);
    }
    else
    { /* block id: 125 */
        const int32_t l_343 = 0L;
        int32_t l_351 = 0x6DD47E96L;
        int32_t *****l_354 = (void*)0;
        const int32_t **l_358 = (void*)0;
        const int32_t ***l_357 = &l_358;
        const int32_t ****l_356 = &l_357;
        const int32_t *****l_355 = &l_356;
        if ((((int16_t)(&l_146 == &p_58) * (int16_t)(((uint16_t)(((~(0x4CF6092038D5A99FLL & ((int16_t)l_343 / (int16_t)((uint32_t)((int16_t)(*l_147) * (int16_t)((-1L) <= ((((void*)0 == &l_146) < (*l_147)) | l_343))) % (uint32_t)l_343)))) & (**l_146)) | l_343) >> (uint16_t)(*l_147)) & 0x28F99BDFL)) <= 0x3423A12515FCF543LL))
        { /* block id: 126 */
            int32_t *l_348 = (void*)0;
            float ***l_350 = &l_349;
            (*p_58) = l_348;
            (*l_350) = l_349;
        }
        else
        { /* block id: 129 */
            return l_343;
        }
        l_351 = ((***l_145) ^ l_343);
        for (l_351 = (-5); (l_351 != 11); l_351 += 2)
        { /* block id: 135 */
            return l_351;
        }
        (*l_355) = &l_145;
        /* statement id: 138 */
        assert (l_356 == &l_145);
    }
    /* facts after branching */
    //assert (l_55 == 0 || l_55 == &l_148);
    assert (l_147 == &l_148 || l_147 == 0);
    (*l_146) = (*p_58);
    return l_359;
    /* statement id: 141 */
    //assert (l_55 == 0 || l_55 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_60(int32_t * p_61)
{ /* block id: 15 */
    int32_t *l_62 = (void*)0;
    float l_64 = 0xA.33B8FBp-95;
    int32_t l_96 = 0xA5D7A232L;
    float l_120 = 0xE.248422p+74;
    int32_t **l_134 = &l_62;
    int32_t ***l_133 = &l_134;
    int32_t l_137 = 7L;
    float *l_142 = &l_120;
    if (((*p_61) != 0UL))
    { /* block id: 16 */
        int32_t **l_63 = &l_62;
        int32_t l_65 = (-1L);
        uint32_t l_74 = 0x3C5815DAL;
        (*l_63) = l_62;
        (*p_61) = (*p_61);
        for (l_65 = 0; (l_65 != (-28)); l_65 -= 4)
        { /* block id: 21 */
            int64_t l_68 = 0x1A504A86D6A6C343LL;
            if (l_68)
                break;
        }
        for (l_65 = 0; (l_65 != (-12)); l_65 -= 1)
        { /* block id: 26 */
            uint64_t l_75 = 0x2871EB1C2610AA4ALL;
            if (((func_71(l_63, (l_74 != l_75)) >= l_96) && l_96))
            { /* block id: 51 */
                const uint8_t l_107 = 0x1BL;
                int32_t *l_121 = &l_96;
                for (l_75 = 12; (l_75 < 29); ++l_75)
                { /* block id: 54 */
                    (*l_63) = p_61;
                    /* statement id: 55 */
                    //assert (l_62 == &l_56);
                }
                (*p_61) = (((((int64_t)(-(int32_t)(l_75 || ((int16_t)((((uint32_t)l_75 % (uint32_t)(4294967295UL && (l_75 || (!(l_107 <= ((uint16_t)l_107 * (uint16_t)l_107)))))) > ((int16_t)((uint32_t)(((int16_t)((int16_t)((uint16_t)(0x9BB2131AL & (((((((*p_61) < (-6L)) ^ 8L) & l_75) & 0x7EE9F729L) & l_107) | l_75)) * (uint16_t)l_74) % (int16_t)l_107) >> (int16_t)l_107) != l_75) + (uint32_t)l_107) % (int16_t)l_75)) <= l_96) - (int16_t)l_107))) - (int64_t)l_107) < l_75) || l_65) & 0x4D29090FL);
                if ((*p_61))
                    break;
                (*p_61) = (18446744073709551609UL && (l_121 == (void*)0));
            }
            else
            { /* block id: 60 */
                int32_t ***l_122 = (void*)0;
                int32_t ***l_123 = &l_63;
                (*l_123) = &l_62;
                if ((*p_61))
                    break;
                (**l_123) = p_61;
                /* statement id: 63 */
                //assert (l_62 == &l_56);
            }
        }
        /* facts after for loop */
        //assert (l_62 == &l_56 || l_62 == 0);
    }
    else
    { /* block id: 66 */
        uint32_t l_124 = 0x32190EF9L;
        l_124 = (-0x2.8p-1);
        (*p_61) = ((int64_t)((int16_t)(l_124 & l_124) + (int16_t)(5L && ((int64_t)l_96 - (int64_t)(((int16_t)(l_133 != &l_134) - (int16_t)(-1L)) >= l_124)))) - (int64_t)(!(!(l_124 ^ 5L))));
        (*l_134) = func_44(l_137);
    }
    /* facts after branching */
    //assert (l_62 == &l_56 || l_62 == 0);
    (*l_142) = ((float)0x1.0p+1 * (float)((float)l_96 / (float)0xB.A4DC89p+16));
    return (*p_61);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_71(int32_t ** p_72, uint16_t  p_73)
{ /* block id: 27 */
    for (p_73 = 20; (p_73 < 3); p_73 -= 2)
    { /* block id: 30 */
        int32_t l_82 = 0L;
        const int32_t *l_81 = &l_82;
        const int32_t **l_80 = &l_81;
        const int32_t ***l_79 = &l_80;
        const int32_t ****l_78 = &l_79;
        (*l_78) = &p_72;
        /* statement id: 31 */
        assert (l_79 == &p_72);
    }
    for (p_73 = 0; (p_73 >= 50); ++p_73)
    { /* block id: 35 */
        int32_t l_85 = 0x53CC61BBL;
        int32_t *l_93 = (void*)0;
        int32_t *l_94 = (void*)0;
        int32_t *l_95 = &l_85;
        for (l_85 = 1; (l_85 == (-29)); l_85 -= 1)
        { /* block id: 38 */
            int32_t l_88 = 0x526695BDL;
            int32_t l_90 = 0xC40293E9L;
            int32_t *l_89 = &l_90;
            l_89 = func_44(l_88);
            /* statement id: 39 */
            assert (l_89 == 0);
        }
        for (l_85 = 0; (l_85 <= (-16)); l_85 -= 3)
        { /* block id: 43 */
            return l_85;
        }
        (*p_72) = func_44(((&l_85 == &l_85) == p_73));
        /* statement id: 46 */
        //assert (l_62 == 0);
        (*l_95) = l_85;
    }
    (*p_72) = (*p_72);
    return p_73;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 227
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 155
   depth: 2, occurrence: 36
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 27, occurrence: 3

XXX total number of pointers: 192

XXX times a variable address is taken: 188
XXX times a pointer is dereferenced on RHS: 223
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 54
   depth: 3, occurrence: 28
   depth: 4, occurrence: 7
XXX times a pointer is dereferenced on LHS: 119
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 44
XXX times a pointer is compared with address of another variable: 17
XXX times a pointer is compared with another pointer: 23
XXX times a pointer is qualified to be dereferenced: 939

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 287
   level: 2, occurrence: 150
   level: 3, occurrence: 71
   level: 4, occurrence: 56
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 104
XXX number of pointers point to scalars: 88
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 34.9
XXX average alias set size: 1.15

XXX times a non-volatile is read: 1275
XXX times a non-volatile is write: 340
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 149
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 39
   depth: 2, occurrence: 24
   depth: 3, occurrence: 23
   depth: 4, occurrence: 19
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 15.1
XXX percentage an existing variable is used: 84.9
********************* end of statistics **********************/

