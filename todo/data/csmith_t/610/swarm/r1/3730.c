/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      1290744908
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   uint16_t  f1;
};

union U1 {
   volatile int32_t  f0;
   uint32_t  f1;
   volatile int32_t  f2;
   int16_t  f3;
   unsigned f4 : 25;
};

union U2 {
   volatile int32_t  f0;
};

union U3 {
   uint16_t  f0;
   signed f1 : 18;
   uint16_t  f2;
   signed f3 : 9;
};

/* --- GLOBAL VARIABLES --- */
static volatile uint32_t g_2 = 0x62A2B3B7;/* VOLATILE GLOBAL g_2 */
static int32_t g_4 = 0;
static volatile int32_t **g_14 = (void*)0;
static const union U0 g_36 = {0};
static int32_t *g_59 = (void*)0;
static int32_t **g_58 = &g_59;
static union U3 g_68 = {0x1153};
static int32_t g_100 = (-1);
static volatile union U1 *g_126 = (void*)0;
static volatile union U1 g_129 = {0};/* VOLATILE GLOBAL g_129 */
static union U1 g_149 = {-6};/* VOLATILE GLOBAL g_149 */
static int32_t ****g_163 = (void*)0;
static union U2 g_295 = {0x720E6C04};/* VOLATILE GLOBAL g_295 */
static const volatile union U2 g_297 = {0xF6B4653D};/* VOLATILE GLOBAL g_297 */
static const volatile union U2 *g_296 = &g_297;
static union U0 g_316 = {0xD04433F0};
static volatile union U2 **g_361 = (void*)0;
static volatile union U2 ***g_360 = &g_361;
static uint16_t g_399 = 0x0FD3;
static union U2 g_406 = {0};/* VOLATILE GLOBAL g_406 */
static int32_t *g_414 = &g_316.f0;
static volatile union U3 *g_416 = (void*)0;
static volatile union U3 **g_415 = &g_416;
static union U3 *g_593 = (void*)0;
static union U3 **g_592 = &g_593;
static union U3 ***g_591 = &g_592;
static union U3 ****g_590 = &g_591;
static volatile union U3 **g_594 = &g_416;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t ** func_5(int32_t  p_6, int32_t ** p_7, int32_t  p_8, uint16_t  p_9, int32_t  p_10);
static uint16_t  func_15(int32_t ** p_16, union U3  p_17, union U0  p_18);
static union U3  func_19(union U3  p_20);
static union U3  func_21(int32_t ** p_22, union U0  p_23, const int32_t * p_24);
static union U0  func_25(int32_t * p_26, int32_t  p_27, uint32_t  p_28, const union U0  p_29, uint32_t  p_30);
static int32_t * func_38(uint16_t  p_39, uint32_t  p_40, int32_t  p_41);
static int32_t  func_50(uint32_t  p_51, int32_t ** p_52);
static int16_t  func_53(int32_t ** p_54, const int32_t * p_55, int32_t ** p_56, int32_t * p_57);
static int32_t * func_60(int32_t  p_61, int32_t ** p_62, union U0  p_63, union U3  p_64, int32_t  p_65);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_14 g_4 g_36 g_58 g_36.f0 g_68 g_68.f2 g_59 g_36.f1 g_100 g_126 g_68.f0 g_149.f1 g_163 g_129.f2 g_149.f3 g_129.f4 g_129.f3 g_149.f4 g_149.f0 g_296 g_360 g_297.f0 g_316.f0 g_316.f1 g_414 g_149.f2 g_415 g_416 g_406.f0 g_295.f0 g_399 g_361 g_129.f0 g_590 g_594 g_129.f1
 * writes: g_4 g_100 g_59 g_68.f0 g_58 g_163 g_149.f1 g_68.f2 g_126 g_316.f0 g_590 g_361
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_11 = (-3);
    int32_t *l_13 = &g_4;
    int32_t **l_12 = &l_13;
    uint32_t l_35 = 0x0DF39281;
    union U0 l_260 = {0x9740BE61};
    union U0 *l_380 = &g_316;
    union U0 **l_379 = &l_380;
    uint32_t l_382 = 0xEF46315E;
    union U1 *l_392 = (void*)0;
    union U1 **l_391 = &l_392;
    uint32_t l_465 = 0xD4B79847;
    int32_t l_468 = 1;
    const int32_t l_485 = (-1);
    union U3 *l_500 = &g_68;
    union U3 **l_499 = &l_500;
    uint32_t l_630 = 0xE399DF28;
    if (g_2)
    { /* block id: 1 */
        int32_t *l_3 = &g_4;
        uint32_t l_37 = 0x81230B63;
        int32_t ***l_343 = &l_12;
        union U0 l_413 = {0xF1B3B3F8};
        uint16_t l_433 = 1U;
        uint16_t l_440 = 7U;
        union U3 *l_462 = (void*)0;
        union U0 **l_463 = &l_380;
        union U2 *l_503 = &g_406;
        union U2 **l_504 = &l_503;
        (*l_3) = 0x5CABFC39;
        (*l_343) = func_5(l_11, l_12, ((&l_13 == g_14) && 0x7E3B6F9B), func_15(&l_3, func_19(func_21(&l_3, func_25(&g_4, ((safe_div_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_s((*l_13), (*l_3))) == l_35), g_4)) & g_4), g_2, g_36, l_37), l_3)), l_260), l_37);
        /* statement id: 128 */
        assert (l_3 == &g_4 || l_3 == 0);
        assert (l_13 == &g_4 || l_13 == 0);
        assert (g_59 == &g_4 || g_59 == 0);
                assert (g_126 == 0 || g_126 == &g_129);
        if (((0x1E3A && 0x40F6) || 0x4EA06207))
        { /* block id: 129 */
            volatile union U1 **l_344 = &g_126;
            (*l_344) = &g_129;
            /* statement id: 130 */
            assert (g_126 == &g_129);
        }
        else
        { /* block id: 131 */
            int16_t l_345 = 0x3A71;
            int32_t *l_381 = &g_4;
            const union U3 *l_385 = &g_68;
            uint16_t l_393 = 0x9090;
            union U2 *l_405 = &g_406;
            const uint16_t l_412 = 2U;
            int32_t l_446 = (-1);
            int32_t l_501 = 0xC2278E11;
lbl_502:
            if (((&g_129 == (void*)0) <= l_345))
            { /* block id: 132 */
                int32_t *l_350 = &g_100;
                union U0 *l_353 = &l_260;
                volatile union U3 **l_417 = &g_416;
                (*l_350) = ((g_68.f2 >= (safe_sub_func_uint32_t_u_u(g_2, (safe_rshift_func_uint16_t_u_u((((g_149.f3 | ((&g_59 == (void*)0) && 0xFAD4)) && ((**l_343) != l_350)) | (safe_add_func_int16_t_s_s(0xDFEE, g_68.f2))), g_36.f1))))) || l_37);
                (*l_350) = ((l_353 != l_353) > (safe_div_func_uint16_t_u_u(((*l_350) && l_260.f0), (safe_mod_func_uint16_t_u_u((((l_350 == (void*)0) <= ((safe_add_func_int32_t_s_s(l_345, ((void*)0 != g_360))) == l_345)) >= 0x6C267DE7), 0x813B)))));
                if ((l_345 <= ((safe_rshift_func_int16_t_s_u((~(((l_345 | (safe_sub_func_uint16_t_u_u(0xA763, g_149.f4))) ^ (safe_sub_func_int16_t_s_s((((safe_div_func_int32_t_s_s((-5), (safe_lshift_func_int16_t_s_u((safe_sub_func_int16_t_s_s((((safe_lshift_func_int16_t_s_u((((safe_rshift_func_uint16_t_u_u((*l_350), 7)) >= g_149.f1) | (0x88FD & (((void*)0 == l_379) != g_297.f0))), g_36.f1)) == g_316.f0) && l_345), g_149.f3)), 5)))) ^ 0xE671) ^ g_68.f2), 0x2F03))) > l_345)), 8)) && g_100)))
                { /* block id: 135 */
                    (*l_12) = l_381;
                    /* statement id: 136 */
                    assert (l_13 == &g_4);
                }
                else
                { /* block id: 137 */
                    return l_382;
                }
                /* facts after branching */
                assert (l_13 == &g_4);
                for (g_68.f0 = 0; (g_68.f0 < 39); g_68.f0 = safe_add_func_uint32_t_u_u(g_68.f0, 1))
                { /* block id: 142 */
                    const union U3 **l_386 = &l_385;
                    int32_t l_407 = 0xEE55107F;
                    (*l_386) = l_385;
                }
                /* facts after for loop */
                            }
            else
            { /* block id: 158 */
                int32_t l_422 = 0x9F912CC4;
                const int32_t l_455 = 8;
                uint32_t l_467 = 1U;
                uint32_t l_486 = 0xCBD0F30A;
                (*l_379) = (*l_379);
                (*l_381) = (g_149.f1 ^ (safe_rshift_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((l_422 ^ (((safe_rshift_func_uint16_t_u_s(g_316.f1, g_36.f1)) >= ((safe_lshift_func_uint16_t_u_u(((*g_414) || ((safe_div_func_int32_t_s_s(((((safe_add_func_int16_t_s_s(((l_422 || (safe_sub_func_uint32_t_u_u(g_316.f0, ((-1) < 0xF17BE234)))) || g_36.f0), 0xF7FC)) || (*g_414)) > 0) || g_316.f0), l_422)) || 6)), l_433)) != g_36.f1)) && (*g_414))), g_68.f2)), l_422)));
                if (((safe_rshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_u(0xA6C5, ((l_440 == ((safe_div_func_int16_t_s_s(l_422, 0xA0F1)) > (safe_sub_func_int32_t_s_s(((safe_unary_minus_func_int16_t_s((1U <= (6U == l_446)))) | ((((safe_sub_func_int16_t_s_s(((safe_div_func_uint16_t_u_u((l_422 == (safe_add_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((g_68.f0 == g_149.f2), g_316.f1)), g_36.f1))), g_36.f1)) > 0x4394), (-1))) >= l_455) || (*l_381)) != 0xB0D4)), 0x0D7AD230)))) < g_316.f1))) > g_149.f4), g_149.f1)) | l_455))
                { /* block id: 161 */
                    int16_t l_466 = 0x9BFE;
                    (*l_381) = ((safe_add_func_int16_t_s_s(((safe_sub_func_uint16_t_u_u(((g_149.f0 >= (safe_div_func_uint32_t_u_u(((((((*g_415) == l_462) && 0x3561) != (&l_380 != l_463)) & ((+(l_465 | ((((l_466 != g_68.f2) != 0xBA66277D) == g_316.f1) & 9U))) | 0x0E18)) || (*l_381)), l_467))) && g_406.f0), (*l_381))) > 1), g_36.f0)) > (*g_414));
                    if (g_36.f1)
                        goto lbl_502;
                    (*g_414) = l_468;
                }
                else
                { /* block id: 164 */
                    int32_t l_475 = (-9);
                    union U2 **l_487 = (void*)0;
                    union U2 **l_488 = (void*)0;
                    union U2 **l_489 = (void*)0;
                    union U2 **l_490 = &l_405;
                    (*l_381) = (safe_mod_func_uint32_t_u_u((safe_mod_func_int32_t_s_s((safe_add_func_uint16_t_u_u(g_36.f1, (l_475 && ((((safe_add_func_uint32_t_u_u((((safe_lshift_func_int16_t_s_s((&l_13 == (void*)0), 14)) > (safe_add_func_int32_t_s_s((g_36.f0 > g_295.f0), l_455))) > ((!(safe_sub_func_uint16_t_u_u((l_485 > (((l_486 != 0xCD7F) || (*g_414)) > (*g_414))), g_316.f1))) < g_399)), g_100)) < g_68.f2) < g_316.f1) <= 0U)))), g_149.f3)), (*g_414)));
                    (*l_490) = l_405;
                    (*g_414) = (safe_mod_func_int32_t_s_s((safe_sub_func_int32_t_s_s(((*l_381) && (safe_mod_func_int16_t_s_s(g_129.f2, g_316.f0))), (((l_462 == (*g_415)) >= 0U) > g_149.f4))), (*g_414)));
                    for (l_345 = (-17); (l_345 > 15); l_345 = safe_add_func_int16_t_s_s(l_345, 3))
                    { /* block id: 170 */
                        (*l_381) = (l_499 != (void*)0);
                        (**l_343) = (*g_58);
                        (*l_381) = l_501;
                    }
                }
            }
            /* facts after branching */
                        return (*g_414);
        }
        /* facts after branching */
        assert (g_126 == &g_129);
        (*l_504) = l_503;
    }
    else
    { /* block id: 181 */
        const union U2 *l_505 = &g_295;
        int32_t l_524 = 0x4B35B518;
        union U0 **l_626 = &l_380;
        (*g_414) = ((void*)0 != (*g_360));
        if (((l_505 == (void*)0) && (**l_12)))
        { /* block id: 183 */
            uint32_t l_519 = 4294967286U;
            union U2 *l_538 = &g_295;
            int32_t l_553 = 5;
            int16_t l_607 = (-1);
            if (((*l_379) == &g_36))
            { /* block id: 184 */
                int16_t l_506 = (-3);
                const union U1 *l_518 = &g_149;
                const union U1 **l_517 = &l_518;
                int32_t *l_534 = &l_468;
                (*g_414) = (-8);
                (*g_414) = 0x5B71E515;
                (**l_12) = ((0xA049B235 > l_506) < (safe_add_func_uint32_t_u_u((((void*)0 == &g_316) != (safe_rshift_func_uint16_t_u_u((*l_13), 15))), (safe_rshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((-1), ((safe_rshift_func_int16_t_s_s(3, 1)) | (((void*)0 == l_517) || l_519)))), g_149.f4)))));
                if ((*l_13))
                { /* block id: 188 */
                    const int32_t l_526 = (-1);
                    union U0 *l_527 = (void*)0;
                    for (l_506 = 0; (l_506 == 3); l_506 = safe_add_func_int16_t_s_s(l_506, 9))
                    { /* block id: 191 */
                        (**l_12) = l_519;
                        (*l_13) = (0x51AAA443 || (0U < (safe_lshift_func_uint16_t_u_s((l_524 == (2U <= (((*g_415) == (void*)0) ^ (*l_13)))), ((&l_524 == (*g_58)) >= 4U)))));
                        (*l_13) = (~(l_526 ^ l_506));
                        (**l_12) = (**l_12);
                    }
                    l_527 = (void*)0;
lbl_535:
                    if ((((safe_div_func_int16_t_s_s(0xC327, (safe_add_func_int32_t_s_s(l_519, 0xBDB30DB7)))) < (((safe_sub_func_int32_t_s_s((0x442086D0 <= g_129.f4), 0x7370EED9)) > ((void*)0 == g_163)) == (((l_506 <= 0xAF162942) ^ l_519) & 9U))) <= (-1)))
                    { /* block id: 198 */
                        (*g_58) = l_534;
                        /* statement id: 199 */
                        assert (g_59 == &l_468);
                        (*l_534) = (*g_59);
                    }
                    else
                    { /* block id: 201 */
                        (*l_12) = (*g_58);
                        /* statement id: 202 */
                        assert (l_13 == 0);
                        if (g_399)
                            goto lbl_535;
                    }
                    /* facts after branching */
                    assert (g_59 == 0 || g_59 == &l_468);
                    l_553 = (safe_add_func_uint16_t_u_u(((0xF314835B & (l_538 != &g_406)) | g_129.f0), (safe_add_func_uint32_t_u_u(((safe_sub_func_int32_t_s_s(l_519, (((safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((((void*)0 == &g_416) <= (safe_div_func_int16_t_s_s((((safe_mod_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u((g_316.f0 ^ (0x7C89B16D == l_519)), (*l_534))), l_526)) == (*l_534)) & l_524), g_149.f3))), l_519)), 0x3C1324ED)) ^ g_68.f0) < g_68.f2))) ^ g_36.f1), l_526))));
                }
                else
                { /* block id: 206 */
                    uint32_t l_556 = 1U;
                    (*g_58) = func_38((*l_534), ((*g_360) == (*g_360)), (safe_add_func_uint32_t_u_u(0x6E1642DF, (l_556 <= (safe_mod_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((*l_534), (l_519 >= (safe_add_func_uint32_t_u_u(g_316.f1, 0x0D960568))))), 1U))))));
                }
                /* facts after branching */
                assert (l_13 == 0 || l_13 == &g_4);
                assert (g_59 == 0 || g_59 == &l_468);
            }
            else
            { /* block id: 209 */
                const int16_t l_585 = 3;
                int32_t l_587 = 0x4484EA23;
                if ((safe_mod_func_int16_t_s_s((safe_sub_func_int16_t_s_s(((*g_414) & (l_553 != ((0x78C2 != ((((g_36.f0 >= 0x50C411E0) || 65529U) && g_68.f0) != (safe_rshift_func_uint16_t_u_s(((1U < (safe_sub_func_uint32_t_u_u(((((((((&g_163 != (void*)0) & (**l_12)) & 0xF68E) & l_519) | 0x87E6) & g_129.f3) && g_149.f4) & (*l_13)), (*g_414)))) != 0xB6A8FB61), 2)))) || (*g_414)))), l_524)), l_524)))
                { /* block id: 210 */
                    int16_t l_577 = 0x8D18;
                    int32_t ***l_582 = &g_58;
                    union U3 ***l_589 = &l_499;
                    union U3 ****l_588 = &l_589;
                    if (((void*)0 != &l_12))
                    { /* block id: 211 */
                        (*g_414) = (g_129.f0 & (safe_lshift_func_int16_t_s_s((((safe_div_func_int32_t_s_s(l_577, (((0x149C9556 || (safe_sub_func_int16_t_s_s(((safe_mod_func_uint16_t_u_u((l_582 != l_582), (safe_add_func_uint16_t_u_u(((65533U ^ l_585) < 4U), 0xFF09)))) || g_4), 0xA105))) >= g_316.f0) && (*g_414)))) & 0x42F3) ^ 1), 5)));
                        (**l_582) = (*g_58);
                        return (**l_12);
                    }
                    else
                    { /* block id: 215 */
                        int16_t l_586 = 0xAA1D;
                        l_586 = 0xFEC71DCD;
                    }
                    l_587 = (*g_414);
                    (*l_588) = (void*)0;
                    /* statement id: 219 */
                    assert (l_589 == 0);
                    g_590 = g_590;
                }
                else
                { /* block id: 221 */
                    (*g_360) = (*g_360);
                    (*l_13) = ((((-1) | (65532U <= (g_594 != (void*)0))) <= l_524) & g_297.f0);
                    (*l_12) = &l_524;
                    /* statement id: 224 */
                    assert (l_13 == &l_524);
                }
                /* facts after branching */
                assert (l_13 == &l_524 || l_13 == &g_4);
                (**l_12) = ((safe_lshift_func_int16_t_s_s((safe_mod_func_uint32_t_u_u(((safe_mod_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(g_406.f0, (safe_unary_minus_func_uint32_t_u((((~l_607) <= ((safe_rshift_func_uint16_t_u_u(g_149.f1, l_587)) & ((safe_lshift_func_int16_t_s_s(0x1BCF, l_607)) == g_149.f1))) | (((g_316.f0 | 0) > 0x3DFB0633) && 0xA774)))))), 4)), 0x6067)) < (*l_13)), (**l_12))), 12)) | 0x2B08);
                return (*g_414);
            }
            /* facts after branching */
            assert (l_13 == 0 || l_13 == &g_4);
            assert (g_59 == 0 || g_59 == &l_468);
            (*g_414) = ((((safe_add_func_int32_t_s_s(0x6414B256, (((safe_mod_func_int32_t_s_s(((((safe_div_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_u(7, 13)) ^ ((((0x2298EF12 | (safe_lshift_func_int16_t_s_u((0U <= (safe_div_func_int16_t_s_s(((l_626 == (void*)0) != (0 || g_149.f3)), g_129.f1))), g_36.f0))) & g_36.f1) <= g_316.f0) ^ g_316.f0)), l_607)) ^ 0x24DB) & g_100) > g_36.f1), g_4)) <= g_4) > l_524))) != 4294967291U) | g_36.f0) >= g_316.f1);
            l_524 = (0x4E10 > (l_524 <= g_149.f0));
        }
        else
        { /* block id: 231 */
            int32_t l_629 = 0x80307492;
            for (g_68.f0 = 29; (g_68.f0 != 59); g_68.f0 = safe_add_func_uint16_t_u_u(g_68.f0, 1))
            { /* block id: 234 */
                if (l_629)
                    break;
            }
        }
        /* facts after branching */
        assert (l_13 == 0 || l_13 == &g_4);
        assert (g_59 == 0 || g_59 == &l_468);
    }
    /* facts after branching */
    assert (l_13 == &g_4 || l_13 == 0);
    assert (g_59 == 0 || g_59 == &l_468 || g_59 == &g_4);
        assert (g_126 == 0 || g_126 == &g_129);
    return l_630;
    /* statement id: 239 */
    //assert (g_59 == 0 || g_59 == dangling || g_59 == &g_4);
}


/* ------------------------------------------ */
/* 
 * reads : g_149.f1 g_149.f4 g_163 g_149.f0 g_4 g_36.f1 g_296 g_129.f3 g_68.f2 g_129.f2 g_36 g_68 g_58 g_59 g_36.f0 g_149.f3
 * writes: g_4 g_126 g_163 g_149.f1 g_59
 */
static int32_t ** func_5(int32_t  p_6, int32_t ** p_7, int32_t  p_8, uint16_t  p_9, int32_t  p_10)
{ /* block id: 103 */
    uint32_t l_277 = 0x439D1B26;
    int32_t l_278 = 1;
    const union U3 *l_279 = &g_68;
    const union U3 **l_280 = (void*)0;
    const union U3 *l_281 = &g_68;
    int32_t ****l_288 = (void*)0;
    union U2 *l_294 = &g_295;
    union U2 **l_293 = &l_294;
    union U0 *l_315 = &g_316;
    l_278 = ((safe_rshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s((0x8247 == (g_149.f1 ^ 65534U)), l_277)), 15)) < 0xC0A8);
    l_281 = l_279;
    (**p_7) = (safe_mod_func_uint32_t_u_u((((safe_sub_func_int16_t_s_s(((p_10 & (g_149.f4 != p_6)) && (safe_rshift_func_uint16_t_u_s(((l_288 != g_163) > (0xC4FDDAEB == (((+p_6) <= (l_277 & (0x79C5B4ED < 4294967289U))) <= 9U))), 4))), g_149.f0)) != (-1)) || 0x7146), (**p_7)));
    if ((**p_7))
    { /* block id: 107 */
        int32_t l_290 = 0x47CEFB77;
        union U2 ***l_298 = (void*)0;
        (**p_7) = ((l_290 & g_36.f1) != (safe_sub_func_uint32_t_u_u((((l_293 != (void*)0) & ((g_149.f0 > 0x9F88) ^ (0xEFB7 & p_10))) & (g_296 != (void*)0)), g_149.f1)));
        l_298 = (void*)0;
        if ((g_129.f3 < g_149.f1))
        { /* block id: 110 */
            uint32_t l_299 = 0x72C5433B;
            (**p_7) = ((l_299 && g_68.f2) != 1U);
            return p_7;
            /* statement id: 112 */
            //assert (func_5_rv == &l_13);
        }
        else
        { /* block id: 113 */
            return p_7;
            /* statement id: 114 */
            //assert (func_5_rv == &l_13);
        }
    }
    else
    { /* block id: 116 */
        int16_t l_300 = (-1);
        if (l_300)
        { /* block id: 117 */
            uint32_t l_321 = 0x9A4C5BC5;
            volatile union U1 **l_322 = (void*)0;
            volatile union U1 **l_323 = (void*)0;
            volatile union U1 **l_324 = &g_126;
            (**p_7) = (g_68.f2 ^ ((safe_add_func_int16_t_s_s(((safe_mod_func_int16_t_s_s((safe_sub_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((0xBEAF90EE > (0x39A1 || (safe_lshift_func_uint16_t_u_u(g_149.f0, 4)))), ((**p_7) | (safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((l_315 == &g_36), 2)), (safe_sub_func_int16_t_s_s(p_9, (safe_lshift_func_int16_t_s_s((p_7 != (void*)0), 1))))))))), (-1))), g_149.f1)) & 0x0EBDD82F), 9U)) == l_321));
            (*l_324) = &g_129;
            /* statement id: 119 */
            assert (g_126 == &g_129);
        }
        else
        { /* block id: 120 */
            int32_t l_331 = 1;
            uint32_t l_342 = 0x5F375361;
            (**p_7) = 0xA04C1EA0;
            (*p_7) = func_38((safe_add_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s(((((l_331 || (&g_296 == (void*)0)) < ((safe_lshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((-1), p_9)), 12)) < (5 && ((((p_10 > (safe_mod_func_int32_t_s_s((**p_7), ((0xC0C6 >= l_300) || g_4)))) & p_10) == g_129.f2) < 65535U))), l_342)) >= 65535U)) >= 0) != 0xD36C), 0xB0FE)) < g_36.f1), p_10)), g_149.f4, (**p_7));
            /* statement id: 122 */
            //assert (l_13 == &g_4 || l_13 == 0);
            (*g_58) = (*g_58);
        }
        /* facts after branching */
        assert (g_126 == 0 || g_126 == &g_129);
        //assert (l_13 == &g_4 || l_13 == 0);
        (*g_58) = (*p_7);
    }
    /* facts after branching */
    assert (g_126 == 0 || g_126 == &g_129);
    //assert (l_13 == &g_4 || l_13 == 0);
    return p_7;
    /* statement id: 127 */
    //assert (func_5_rv == &l_13);
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_59
 * writes: g_4
 */
static uint16_t  func_15(int32_t ** p_16, union U3  p_17, union U0  p_18)
{ /* block id: 92 */
    int32_t ***l_265 = &g_58;
    int32_t l_268 = 1;
    union U2 *l_271 = (void*)0;
    union U2 **l_272 = &l_271;
    (**p_16) = (safe_add_func_int32_t_s_s((((void*)0 != (*p_16)) > (safe_rshift_func_int16_t_s_u((((void*)0 != l_265) == 7), (0xE0FF88FC <= (4294967289U || ((safe_rshift_func_uint16_t_u_u(((65526U != l_268) | 0xD848), p_18.f0)) != p_17.f2)))))), p_17.f2));
    for (p_18.f0 = (-8); (p_18.f0 > (-7)); p_18.f0 = safe_add_func_int16_t_s_s(p_18.f0, 6))
    { /* block id: 96 */
        (*p_16) = (*p_16);
        (**p_16) = (65535U || (-1));
    }
    (*p_16) = (**l_265);
    /* statement id: 100 */
    //assert (l_3 == &g_4 || l_3 == 0);
    (*l_272) = l_271;
    return p_18.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_68.f0 g_4 g_149.f1 g_163 g_36 g_68 g_36.f1 g_58 g_59 g_36.f0 g_129.f2 g_149.f3 g_129.f3 g_68.f2
 * writes: g_4 g_163 g_149.f1 g_59 g_68.f2
 */
static union U3  func_19(union U3  p_20)
{ /* block id: 72 */
    const int32_t l_218 = 0x0B686D89;
    int32_t *****l_227 = &g_163;
    int32_t *l_228 = &g_4;
    union U0 *l_239 = (void*)0;
    int32_t ***l_251 = &g_58;
    union U1 *l_255 = &g_149;
    union U1 **l_254 = &l_255;
lbl_259:
    (*l_228) = (safe_div_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(l_218, ((&g_163 == (void*)0) > ((safe_rshift_func_uint16_t_u_u(0xE718, 5)) != p_20.f0)))), (safe_div_func_int32_t_s_s((0x64536AC0 ^ ((p_20.f0 != l_218) != (l_227 != &g_163))), 0x077A8CD5))));
    if ((safe_div_func_int16_t_s_s((-2), (safe_mod_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s(g_68.f0, 14)) | ((safe_add_func_int16_t_s_s((*l_228), ((l_227 != l_227) | 7))) && ((safe_div_func_int32_t_s_s(((((l_239 == l_239) <= ((p_20.f2 & p_20.f0) > 4294967295U)) && p_20.f2) < p_20.f2), (*l_228))) == (-4)))), 0xC4174CEC)))))
    { /* block id: 74 */
        int16_t l_240 = 7;
        int32_t *l_241 = &g_100;
        l_241 = func_38(l_240, (*l_228), l_240);
        /* statement id: 75 */
        assert (l_241 == &g_4 || l_241 == 0);
        (*l_228) = p_20.f2;
        for (g_68.f2 = (-24); (g_68.f2 == 20); g_68.f2 = safe_add_func_int16_t_s_s(g_68.f2, 2))
        { /* block id: 79 */
            uint32_t l_244 = 0x8952B2BC;
            (*l_228) = (g_129.f3 == l_244);
        }
        /* facts after for loop */
            }
    else
    { /* block id: 82 */
        uint32_t l_252 = 0x0BBC23E9;
        uint32_t l_253 = 7U;
        int32_t *l_258 = &g_4;
        (*l_228) = ((safe_sub_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(65535U, (0xD4EC0B72 || ((safe_lshift_func_int16_t_s_u(((void*)0 == l_251), l_252)) < l_253)))), p_20.f2)) <= ((void*)0 != l_254));
        for (l_253 = 0; (l_253 <= 57); l_253 = safe_add_func_int32_t_s_s(l_253, 3))
        { /* block id: 86 */
            (**l_251) = l_258;
            /* statement id: 87 */
            assert (g_59 == &g_4);
            if (g_68.f2)
                goto lbl_259;
        }
    }
    /* facts after branching */
        return p_20;
    /* statement id: 91 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_129.f3 g_163 g_4 g_149.f1 g_68.f2 g_36.f0 g_2 g_68
 * writes: g_4
 */
static union U3  func_21(int32_t ** p_22, union U0  p_23, const int32_t * p_24)
{ /* block id: 68 */
    int32_t *****l_206 = &g_163;
    (**p_22) = (((g_129.f3 || (l_206 != l_206)) || (safe_sub_func_int32_t_s_s(0x2A5491B9, 0x044F22EB))) == ((((*l_206) == (*l_206)) >= (((4 & ((((&g_36 == &p_23) | (*p_24)) ^ p_23.f0) != 1)) && 0x02CA) | p_23.f0)) < g_4));
    (**p_22) = (safe_sub_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s(g_149.f1, (!((0 != ((*l_206) == (*l_206))) >= p_23.f0)))) == p_23.f1), ((p_23.f1 || g_68.f2) || (((p_23.f1 > g_36.f0) != g_2) > 0))));
    return g_68;
    /* statement id: 71 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_2 g_58 g_36.f0 g_68 g_68.f2 g_59 g_4 g_36.f1 g_100 g_126 g_68.f0 g_149.f1 g_163 g_36 g_129.f2 g_149.f3 g_129.f4
 * writes: g_4 g_100 g_59 g_68.f0 g_58 g_163 g_149.f1
 */
static union U0  func_25(int32_t * p_26, int32_t  p_27, uint32_t  p_28, const union U0  p_29, uint32_t  p_30)
{ /* block id: 3 */
    int32_t l_46 = 0xF11CAF1E;
    int32_t **l_66 = &g_59;
    union U0 l_67 = {-4};
    int32_t l_192 = 0x6D60A08B;
    int32_t l_195 = 0x8BA2E113;
    int32_t *l_202 = &g_4;
    p_26 = func_38((safe_mod_func_uint32_t_u_u((l_46 ^ (&p_26 != &p_26)), (safe_add_func_uint32_t_u_u(((~g_2) > func_50((func_53(g_58, func_60(g_36.f0, l_66, l_67, g_68, g_68.f2), &g_59, (*g_58)) == 0x6A48), l_66)), g_36.f1)))), p_30, g_36.f1);
    /* statement id: 59 */
    assert (p_26 == 0);
    (*l_202) = (((safe_rshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((g_129.f4 && g_100), 4)), (+l_192))) != (g_100 == (safe_mod_func_int32_t_s_s(g_36.f0, (l_195 | (safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u(g_68.f0, (safe_mod_func_uint16_t_u_u(l_192, g_149.f3)))), 7))))))) && g_100);
    if ((0x5FEB66E7 != p_27))
    { /* block id: 61 */
        uint32_t l_203 = 8U;
        (*g_58) = (*l_66);
        (*l_202) = l_203;
    }
    else
    { /* block id: 64 */
        return p_29;
        /* statement id: 65 */
            }
    return g_36;
    /* statement id: 67 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_149.f1 g_163 g_36 g_68 g_36.f1 g_58 g_59 g_4 g_36.f0 g_129.f2 g_149.f3
 * writes: g_163 g_149.f1 g_4 g_59
 */
static int32_t * func_38(uint16_t  p_39, uint32_t  p_40, int32_t  p_41)
{ /* block id: 41 */
    union U1 *l_148 = &g_149;
    union U1 **l_147 = &l_148;
    int32_t l_156 = 5;
    int32_t ***l_172 = &g_58;
    int32_t ****l_171 = &l_172;
    for (p_41 = 16; (p_41 >= 1); p_41 = safe_sub_func_int16_t_s_s(p_41, 1))
    { /* block id: 44 */
        uint32_t l_167 = 0xEF146544;
        union U0 **l_177 = (void*)0;
        union U1 **l_185 = &l_148;
        int32_t l_186 = (-4);
        if ((safe_div_func_int16_t_s_s((safe_add_func_int32_t_s_s(p_39, ((!(safe_mod_func_int16_t_s_s((l_147 == &g_126), (safe_mod_func_int16_t_s_s(((*l_147) == &g_149), (safe_rshift_func_int16_t_s_s(((safe_add_func_uint32_t_u_u(l_156, (((safe_lshift_func_int16_t_s_u(((safe_add_func_uint32_t_u_u((safe_div_func_int16_t_s_s(g_149.f1, p_41)), ((-1) <= l_156))) && 0xF584), 7)) | 1) == l_156))) & p_39), 11))))))) > 0x3E8202A8))), p_41)))
        { /* block id: 45 */
            int32_t *****l_164 = &g_163;
            (*l_164) = g_163;
            for (g_149.f1 = (-7); (g_149.f1 == 4); g_149.f1 = safe_add_func_uint16_t_u_u(g_149.f1, 5))
            { /* block id: 49 */
                int32_t **l_168 = &g_59;
                (*g_58) = func_60(l_167, l_168, g_36, g_68, g_36.f1);
                return (*g_58);
                /* statement id: 51 */
                //assert (func_38_rv == 0 || func_38_rv == &g_4);
            }
            /* facts after for loop */
            l_186 = (safe_rshift_func_int16_t_s_s((l_171 == (*l_164)), (safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u(((((void*)0 != l_177) ^ ((safe_add_func_int32_t_s_s(6, (!p_40))) > (safe_mod_func_int16_t_s_s(((((((p_39 == (((((l_185 == &g_126) && g_129.f2) <= (-7)) == p_39) != p_39)) | p_41) || 0U) | p_40) == 0xC0D213C7) & 65530U), l_167)))) <= 0xB772), g_149.f3)), 0U))));
        }
        else
        { /* block id: 54 */
            return (*g_58);
            /* statement id: 55 */
            //assert (func_38_rv == 0 || func_38_rv == &g_4);
        }
        /* facts after branching */
    }
    return (*g_58);
    /* statement id: 58 */
    //assert (func_38_rv == 0 || func_38_rv == &g_4);
}


/* ------------------------------------------ */
/* 
 * reads : g_68.f0
 * writes: g_68.f0 g_100 g_59 g_58
 */
static int32_t  func_50(uint32_t  p_51, int32_t ** p_52)
{ /* block id: 32 */
    int32_t l_137 = 0xC97A6105;
    for (g_68.f0 = 24; (g_68.f0 < 49); g_68.f0 = safe_add_func_uint16_t_u_u(g_68.f0, 8))
    { /* block id: 35 */
        int32_t *l_135 = &g_100;
        int32_t ***l_136 = &g_58;
        (*l_135) = 0;
        (*p_52) = (void*)0;
        (*l_136) = p_52;
    }
    return l_137;
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_36.f1 g_100 g_58 g_59 g_36.f0 g_126
 * writes: g_4 g_100 g_59
 */
static int16_t  func_53(int32_t ** p_54, const int32_t * p_55, int32_t ** p_56, int32_t * p_57)
{ /* block id: 14 */
    int32_t *l_90 = &g_4;
    int32_t **l_93 = &g_59;
    int16_t l_94 = (-1);
    int16_t l_95 = 0xF974;
    const uint16_t l_96 = 0x825F;
    (*l_90) = (~((((safe_lshift_func_int16_t_s_u(((void*)0 == l_90), 5)) <= (0x6174ED7B | ((*l_90) != (l_90 != (void*)0)))) | (g_36.f1 <= (((safe_mod_func_int32_t_s_s((&g_59 != l_93), l_94)) && l_95) && (-3)))) || l_96));
    for (g_4 = 0; (g_4 >= (-23)); g_4 = safe_sub_func_uint16_t_u_u(g_4, 9))
    { /* block id: 18 */
        int32_t *l_99 = &g_100;
        uint32_t l_123 = 0x19CD2C71;
        uint32_t l_125 = 0U;
        (*l_99) = 0x145DB5E4;
        (*p_56) = (void*)0;
        if ((*l_99))
            break;
        if (((safe_mod_func_int32_t_s_s(((safe_div_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((*l_99), ((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(((void*)0 == &p_55), 11)), 15)) && ((safe_add_func_uint16_t_u_u(((safe_div_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((*l_99), (((*l_90) > ((((((safe_sub_func_int32_t_s_s((safe_div_func_uint16_t_u_u((*l_99), (safe_div_func_int32_t_s_s((g_4 != ((void*)0 != (*g_58))), (*l_99))))), 8U)) < (-1)) || (*l_99)) && (*l_90)) & g_36.f0) & 1)) == 0xDAAC0CAA))), g_4)) != (*l_99)), (*l_99))) == (*l_99))))), g_100)) > (*l_99)), l_123)) > g_36.f0))
        { /* block id: 22 */
            const int16_t l_124 = 1;
            l_125 = l_124;
        }
        else
        { /* block id: 24 */
            volatile union U1 **l_127 = (void*)0;
            volatile union U1 *l_128 = &g_129;
            int32_t l_130 = 0xFFEB3B2B;
            const union U0 *l_132 = &g_36;
            const union U0 **l_131 = &l_132;
            l_128 = g_126;
            /* statement id: 25 */
            assert (l_128 == 0);
            if (l_130)
                continue;
            (*l_131) = &g_36;
        }
    }
    (*l_90) = ((*l_90) || g_36.f1);
    return (*l_90);
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_59 g_4 g_36.f0
 * writes: g_4
 */
static int32_t * func_60(int32_t  p_61, int32_t ** p_62, union U0  p_63, union U3  p_64, int32_t  p_65)
{ /* block id: 4 */
    int32_t *l_69 = &g_4;
    int32_t l_72 = 7;
    uint16_t l_85 = 1U;
    (*l_69) = (0xB3E1 != ((*g_58) != (*g_58)));
    for (g_4 = 0; (g_4 < (-26)); g_4 = safe_sub_func_int16_t_s_s(g_4, 1))
    { /* block id: 8 */
        l_72 = p_65;
    }
    (*l_69) = (&l_69 != (void*)0);
    (*l_69) = ((*l_69) ^ ((safe_mod_func_int32_t_s_s((safe_add_func_int32_t_s_s(((safe_div_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u(((safe_sub_func_uint16_t_u_u((*l_69), (((l_85 ^ 2U) != g_36.f0) && (p_62 != &l_69)))) ^ (!((*p_62) != (void*)0))), 9)), 0xC2642A2C)) || (*l_69)), 1U)), p_64.f2)) <= 0x11BC));
    return (*g_58);
    /* statement id: 13 */
    //assert (func_60_rv == 0 || func_60_rv == &g_4);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_36.f0, "g_36.f0", print_hash_value);
    transparent_crc(g_36.f1, "g_36.f1", print_hash_value);
    transparent_crc(g_68.f0, "g_68.f0", print_hash_value);
    transparent_crc(g_68.f2, "g_68.f2", print_hash_value);
    transparent_crc(g_100, "g_100", print_hash_value);
    transparent_crc(g_129.f0, "g_129.f0", print_hash_value);
    transparent_crc(g_129.f1, "g_129.f1", print_hash_value);
    transparent_crc(g_129.f2, "g_129.f2", print_hash_value);
    transparent_crc(g_129.f3, "g_129.f3", print_hash_value);
    transparent_crc(g_129.f4, "g_129.f4", print_hash_value);
    transparent_crc(g_149.f0, "g_149.f0", print_hash_value);
    transparent_crc(g_149.f1, "g_149.f1", print_hash_value);
    transparent_crc(g_149.f2, "g_149.f2", print_hash_value);
    transparent_crc(g_149.f3, "g_149.f3", print_hash_value);
    transparent_crc(g_149.f4, "g_149.f4", print_hash_value);
    transparent_crc(g_295.f0, "g_295.f0", print_hash_value);
    transparent_crc(g_297.f0, "g_297.f0", print_hash_value);
    transparent_crc(g_316.f0, "g_316.f0", print_hash_value);
    transparent_crc(g_316.f1, "g_316.f1", print_hash_value);
    transparent_crc(g_399, "g_399", print_hash_value);
    transparent_crc(g_406.f0, "g_406.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 127
XXX total union variables: 5

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 17
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 0
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 9

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 167
   depth: 2, occurrence: 23
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 6, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 5
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 4
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 109

XXX times a variable address is taken: 112
XXX times a pointer is dereferenced on RHS: 116
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 82
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 16
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 37
XXX times a pointer is compared with address of another variable: 17
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 530

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 275
   level: 2, occurrence: 121
   level: 3, occurrence: 20
   level: 4, occurrence: 3
   level: 5, occurrence: 11
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 21
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.4
XXX average alias set size: 1.11

XXX times a non-volatile is read: 619
XXX times a non-volatile is write: 210
XXX times a volatile is read: 31
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 277
XXX percentage of non-volatile access: 96.4

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 145
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 30
   depth: 2, occurrence: 26
   depth: 3, occurrence: 17
   depth: 4, occurrence: 22
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

