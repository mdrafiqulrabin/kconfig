/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2266747184
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
   uint8_t  f3;
   signed f4 : 18;
};

union U1 {
   float  f0;
};

union U2 {
   uint16_t  f0;
   int32_t  f1;
   int16_t  f2;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_28(void);
inline static struct S0  func_32(float  p_33, uint16_t  p_34);
static struct S0  func_35(int16_t  p_36);
inline static int32_t  func_45(int32_t  p_46, uint8_t  p_47, uint32_t  p_48, union U2  p_49);
inline static union U2  func_50(union U2  p_51, int32_t  p_52);
static int16_t  func_54(int16_t  p_55, uint32_t  p_56, union U1  p_57, uint8_t  p_58);
inline static struct S0  func_67(uint32_t  p_68);
inline static uint32_t  func_73(uint8_t  p_74, float  p_75, union U1  p_76);
static uint16_t  func_77(uint16_t  p_78);
inline static uint16_t  func_79(uint32_t  p_80, uint8_t  p_81);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_28(void)
{ /* block id: 36 */
    int32_t l_29 = 0L;
    struct S0 l_685 = {0x9DEA8204L,0x17245D8AL,0x7DDA7095L,0x81L,-206};
    uint16_t l_687 = 1UL;
    struct S0 l_689 = {4294967286UL,0x38C6F31DL,6L,0xC9L,215};
    for (l_29 = (-16); (l_29 <= (-28)); l_29 -= 7)
    { /* block id: 39 */
        if (l_29)
            break;
    }
    l_29 = ((func_32(l_29, ((func_35((l_29 , 1L)) , (l_29 <= (((int16_t)(-4L) * (int16_t)(func_67(l_29) , l_29)) == l_29))) == l_29)) , 0x5.143853p+20) <= l_29);
    for (l_29 = 0; (l_29 <= (-4)); l_29 -= 8)
    { /* block id: 305 */
        struct S0 l_686 = {0xC4D2A164L,0xE1DA6DF8L,0xD57140D6L,0xFBL,-194};
        struct S0 l_688 = {4294967295UL,0x153A977DL,0x0C282ABAL,0x5EL,332};
        l_686 = l_685;
        if (l_687)
            break;
        l_689 = l_688;
    }
    return l_685.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_32(float  p_33, uint16_t  p_34)
{ /* block id: 293 */
    int32_t l_678 = 1L;
    struct S0 l_682 = {2UL,0x2CDD0DE0L,0x47B080BAL,0xBAL,1};
    p_33 = p_34;
    for (p_34 = (-23); (p_34 == 40); p_34++)
    { /* block id: 297 */
        uint8_t l_679 = 0x99L;
        p_33 = func_79((0x06F4L >= ((((uint16_t)0x71E9L - (uint16_t)((__builtin_ffs(l_678) , l_679) && ((int16_t)(((l_678 || 4294967287UL) > p_34) || (0xACDEL || 65535UL)) << (int16_t)14))) | 0x825AL) , p_34)), l_679);
        return l_682;
    }
    return l_682;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_35(int16_t  p_36)
{ /* block id: 42 */
    uint32_t l_41 = 0xF9534236L;
    union U2 l_53 = {0x5F93L};
    union U1 l_59 = {0x5.E82B3Fp-36};
    uint32_t l_579 = 7UL;
    struct S0 l_583 = {0UL,0xFC326C97L,-1L,0x6BL,41};
    if ((((int16_t)((uint16_t)l_41 + (uint16_t)((int16_t)((!p_36) <= func_45((p_36 , ((func_50(l_53, (0xEBB1BB30L == (func_54(((p_36 <= ((p_36 ^ (p_36 ^ (((p_36 && l_41) ^ p_36) || l_53.f2))) , l_41)) || 0x7BA7L), p_36, l_59, l_41) > p_36))) , l_53.f2) >= l_53.f2)), l_53.f0, l_53.f0, l_53)) >> (int16_t)p_36)) * (int16_t)p_36) , l_41))
    { /* block id: 257 */
        uint32_t l_582 = 0xDA8D574BL;
        uint32_t l_589 = 0xFC6BAD35L;
        union U1 l_612 = {0x5.2785ECp-39};
        int32_t l_671 = 7L;
lbl_647:
        l_583 = func_67(((((int16_t)((uint32_t)0x1C526B0EL + (uint32_t)((uint32_t)((int16_t)0x09BEL >> (int16_t)((uint32_t)p_36 % (uint32_t)__builtin_clz(l_53.f0))) / (uint32_t)(~((int32_t)((uint16_t)65529UL >> (uint16_t)5) - (int32_t)(__builtin_parity(l_579) == ((int16_t)l_41 >> (int16_t)7)))))) >> (int16_t)l_582) ^ p_36) , l_579));
        if (l_53.f2)
        { /* block id: 259 */
            int16_t l_584 = 0L;
            uint8_t l_601 = 253UL;
            uint8_t l_602 = 0xB2L;
            l_602 = ((p_36 == l_584) & ((int16_t)(((l_584 >= func_79(((0x1B17D30FL < (((uint32_t)((p_36 , ((l_589 , ((-(int32_t)((int16_t)((int16_t)((int32_t)(((int16_t)l_579 >> (int16_t)10) <= (__builtin_bswap64(((int16_t)l_584 + (int16_t)(((l_589 > l_582) && p_36) , l_584))) < 0L)) + (int32_t)l_582) * (int16_t)l_601) + (int16_t)l_582)) & 0xE2C3L)) , l_589)) | l_41) / (uint32_t)p_36) < 0UL)) >= p_36), l_582)) < p_36) , l_583.f1) + (int16_t)l_582));
        }
        else
        { /* block id: 261 */
            uint32_t l_611 = 0x9DC16A3EL;
            uint16_t l_613 = 0x24CAL;
            int32_t l_614 = (-3L);
            uint32_t l_642 = 9UL;
            uint32_t l_653 = 0xD026C830L;
            l_583 = func_67(((((((int16_t)(0xE5FBL >= 1L) >> (int16_t)8) > ((((((uint32_t)(((int16_t)(((((int32_t)l_589 / (int32_t)p_36) < l_589) || (((4294967290UL == p_36) < ((l_611 >= (l_612 , 0xA02E538EL)) || 0x7D77L)) | p_36)) , (-8L)) * (int16_t)5L) | p_36) + (uint32_t)p_36) > l_583.f3) >= 0x6521D1E4L) >= 1UL) , l_613)) | p_36) && p_36) , p_36));
            l_614 = l_613;
            for (l_583.f3 = 0; (l_583.f3 == 10); l_583.f3 += 9)
            { /* block id: 266 */
                uint32_t l_635 = 0x4F068722L;
                union U2 l_643 = {1UL};
                for (p_36 = 28; (p_36 != 29); p_36 += 1)
                { /* block id: 269 */
                    int32_t l_634 = 1L;
                    struct S0 l_641 = {4294967295UL,0x05762946L,0x080B7E39L,0xFCL,126};
                    if ((((p_36 == (((int32_t)l_613 % (int32_t)((uint32_t)(p_36 ^ ((int16_t)((uint16_t)((uint32_t)l_611 % (uint32_t)(~p_36)) + (uint16_t)0L) * (int16_t)((uint16_t)l_611 - (uint16_t)(((uint16_t)9UL << (uint16_t)l_583.f3) && 0x42DF65B0L)))) % (uint32_t)p_36)) && p_36)) , 9UL) , l_582))
                    { /* block id: 270 */
                        l_614 = p_36;
                    }
                    else
                    { /* block id: 272 */
                        l_583.f4 = p_36;
                        l_635 = l_634;
                    }
                    l_583.f2 = (p_36 != func_45(((((((!((uint16_t)(((uint32_t)(0x4E2BL != (l_582 && ((0UL | 0xF845L) , (l_641 , l_641.f1)))) % (uint32_t)l_642) || func_77(l_579)) * (uint16_t)6L)) & l_53.f2) > p_36) >= l_642) <= l_641.f3) & 0L), l_642, p_36, l_643));
                    for (l_642 = 0; (l_642 > 31); ++l_642)
                    { /* block id: 279 */
                        uint32_t l_646 = 0x8A5133EAL;
                        l_646 = p_36;
                        if (l_582)
                            goto lbl_647;
                    }
                }
                l_653 = func_79(l_589, ((int32_t)((((int16_t)(-(uint32_t)((0x2ADD07DEL ^ p_36) | l_643.f2)) * (int16_t)l_582) == ((func_50(l_53, ((((p_36 & p_36) > (l_589 > 0UL)) || l_611) || 0x57F3L)) , l_643.f2) <= p_36)) | p_36) % (int32_t)p_36));
            }
            l_671 = ((int16_t)((int32_t)func_73(l_583.f1, (l_582 <= (-(float)((float)(0x9.Cp-1 == (((uint16_t)((uint16_t)0xAFD4L - (uint16_t)(((uint16_t)l_579 >> (uint16_t)1) == (-1L))) << (uint16_t)5) , ((float)((((float)(l_653 == (p_36 > p_36)) * (float)0x1.8p+1) >= l_583.f0) > p_36) - (float)l_613))) + (float)l_589))), l_59) - (int32_t)p_36) << (int16_t)l_653);
        }
        l_583.f2 = p_36;
    }
    else
    { /* block id: 289 */
        return l_583;
    }
    return l_583;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_45(int32_t  p_46, uint8_t  p_47, uint32_t  p_48, union U2  p_49)
{ /* block id: 253 */
    int16_t l_557 = 4L;
    int32_t l_560 = 0x37E70B85L;
    struct S0 l_563 = {1UL,0L,0x46A3FA14L,2UL,215};
    l_560 = (p_48 || ((4294967289UL & l_557) <= ((func_67(p_46) , (l_557 != ((uint16_t)l_560 * (uint16_t)((((((int16_t)(p_49.f2 < (p_49 , p_47)) * (int16_t)0xC92CL) != l_557) || p_48) ^ 0x9E2B7C94L) > p_48)))) | 0xE80A7A01L)));
    l_563 = l_563;
    return p_49.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_50(union U2  p_51, int32_t  p_52)
{ /* block id: 45 */
    float l_82 = (-0x1.Ap-1);
    int32_t l_90 = 4L;
    union U1 l_142 = {0x0.Cp-1};
    for (p_52 = 0; (p_52 <= 17); ++p_52)
    { /* block id: 48 */
        union U2 l_64 = {0UL};
        return l_64;
    }
    for (p_51.f2 = 0; (p_51.f2 > (-9)); p_51.f2 -= 9)
    { /* block id: 53 */
        int16_t l_83 = (-1L);
        union U1 l_264 = {0x5.CEF6D5p+69};
        struct S0 l_554 = {0x57C94430L,1L,-1L,9UL,-255};
        l_554 = func_67(((((((((uint16_t)((uint32_t)func_73((func_77(func_79((l_83 & (((uint16_t)((int16_t)((int16_t)l_90 >> (int16_t)p_51.f0) << (int16_t)__builtin_clzl(l_90)) / (uint16_t)l_90) < ((int16_t)3L / (int16_t)(((float)(-0x2.Bp-1) / (float)((__builtin_clzl((1L || p_51.f0)) >= p_52) <= 0x1.03168Fp-17)) , p_52)))), p_52)) >= l_83), p_51.f0, l_142) % (uint32_t)0x6404F572L) * (uint16_t)p_52) , l_264) , l_83) & 0UL) , 0xA38FE637L) == l_90) && l_83));
    }
    l_90 = l_90;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_54(int16_t  p_55, uint32_t  p_56, union U1  p_57, uint8_t  p_58)
{ /* block id: 43 */
    float l_60 = 0x0.0p+1;
    int32_t l_61 = (-8L);
    return l_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_67(uint32_t  p_68)
{ /* block id: 122 */
    uint32_t l_286 = 0UL;
    union U1 l_299 = {0x4.A74C5Ep-85};
    uint16_t l_314 = 0UL;
    int32_t l_316 = 1L;
    struct S0 l_331 = {1UL,5L,1L,0xA3L,437};
    struct S0 l_359 = {0x598AE991L,0xC1BEB3E6L,5L,247UL,5};
    uint16_t l_369 = 65535UL;
    struct S0 l_423 = {0xB965B373L,0xAFE914E7L,-8L,0UL,203};
    for (p_68 = 0; (p_68 != 0); p_68 += 4)
    { /* block id: 125 */
        uint32_t l_269 = 0UL;
        int32_t l_300 = 0xD353EA13L;
        union U1 l_305 = {0x1.Ep-1};
        int32_t l_313 = 0L;
        l_269 = ((int16_t)0x882EL / (int16_t)0xA023L);
        for (l_269 = 0; (l_269 != 10); ++l_269)
        { /* block id: 129 */
            int32_t l_298 = (-8L);
            int32_t l_315 = 1L;
            l_300 = (((float)((float)(((float)p_68 + (float)((float)p_68 * (float)(__builtin_parityll((((int16_t)((uint32_t)4294967295UL % (uint32_t)(p_68 , p_68)) >> (int16_t)(p_68 , ((int32_t)l_286 + (int32_t)(func_54(((int32_t)((int16_t)(((-(uint32_t)((uint32_t)((uint16_t)p_68 << (uint16_t)15) + (uint32_t)((uint32_t)(l_298 >= p_68) / (uint32_t)l_298))) ^ l_286) < l_298) * (int16_t)l_286) + (int32_t)0x442EEB04L), l_298, l_299, l_286) > p_68)))) , l_298)) >= p_68))) < 0x8.31C667p-21) - (float)0x8.A0CDF2p-67) - (float)0x1.9p-1) == 0xD.553ECEp+39);
            l_315 = (((float)((float)(l_305 , 0x5.1E8334p-84) + (float)l_286) + (float)__builtin_bswap32(p_68)) > (p_68 >= ((float)((float)(((float)0x1.C23313p+74 + (float)p_68) >= ((-(float)__builtin_clzl(p_68)) < 0x0.E09D77p-48)) - (float)l_313) / (float)l_314)));
        }
        l_316 = 0x750E86C6L;
        for (l_314 = (-28); (l_314 != 20); l_314 += 8)
        { /* block id: 136 */
            uint8_t l_333 = 0xDAL;
            union U2 l_334 = {65533UL};
            struct S0 l_349 = {0x3B8A31F7L,0x03BE8F81L,0x5B06E9F9L,0UL,101};
            if ((p_68 == (p_68 ^ (((int32_t)((((p_68 == (l_300 || ((uint16_t)((int16_t)(4294967293UL || (l_305 , __builtin_ia32_crc32qi((l_300 || ((uint16_t)((int16_t)func_79(l_314, p_68) / (int16_t)65535UL) / (uint16_t)l_269)), p_68))) * (int16_t)l_316) % (uint16_t)0xE35BL))) & l_269) , p_68) > p_68) % (int32_t)p_68) == p_68))))
            { /* block id: 137 */
                return l_331;
            }
            else
            { /* block id: 139 */
                uint16_t l_332 = 0x73A5L;
                struct S0 l_341 = {4294967288UL,0xF0F951E7L,1L,249UL,1};
                int32_t l_346 = 9L;
                l_332 = l_300;
                l_316 = (l_269 < (l_333 < (l_334 , ((uint16_t)(((((uint16_t)(((int16_t)0xC98CL - (int16_t)0UL) , p_68) + (uint16_t)(func_77(func_54(p_68, (l_333 == (__builtin_bswap64((l_341 , p_68)) && l_331.f1)), l_305, p_68)) , 0xEC81L)) & p_68) ^ p_68) == 0x0149C64DL) * (uint16_t)l_314))));
                l_300 = (((((float)l_333 - (float)p_68) >= ((-0x10.6p-1) == (((float)0x9.22876Fp+79 / (float)l_316) != func_79(l_346, p_68)))) >= (-(float)(-(float)(((l_349 , l_316) > 0xD.9C32DDp-50) < p_68)))) , l_300);
            }
            l_334.f1 = ((__builtin_parity(p_68) != (l_349.f1 <= ((0x1.6p-1 <= 0xF.597BFAp-43) <= (l_334.f2 >= (func_77((((uint16_t)((uint16_t)(l_313 ^ p_68) >> (uint16_t)13) << (uint16_t)__builtin_parity(l_300)) & 0x4B2BL)) , p_68))))) > p_68);
        }
    }
lbl_545:
    for (p_68 = 0; (p_68 != 12); ++p_68)
    { /* block id: 149 */
        struct S0 l_358 = {1UL,0L,-1L,0x0FL,216};
        for (l_331.f2 = 0; (l_331.f2 > 9); ++l_331.f2)
        { /* block id: 152 */
            l_359 = l_358;
            l_359.f4 = l_359.f4;
        }
        l_331 = l_358;
        if (l_331.f4)
            break;
        l_358 = l_359;
    }
    for (l_359.f1 = 0; (l_359.f1 == 18); l_359.f1++)
    { /* block id: 162 */
        float l_374 = 0x0.Ap+1;
        int32_t l_375 = 0xE72C066EL;
        struct S0 l_377 = {0x6DE44C6FL,5L,0x0F7B2116L,7UL,134};
        if (p_68)
        { /* block id: 163 */
            uint32_t l_366 = 0xB511B0AFL;
            struct S0 l_376 = {0UL,0x6AC0404CL,-1L,0x85L,396};
            union U1 l_392 = {0x1.Ap-1};
            l_316 = (p_68 != (((int16_t)((int16_t)l_366 << (int16_t)p_68) >> (int16_t)((((int16_t)__builtin_ffsl(l_369) << (int16_t)6) , ((int16_t)((uint32_t)p_68 / (uint32_t)p_68) << (int16_t)12)) , (((((((p_68 && l_366) & p_68) && l_331.f2) | 0xE158L) ^ l_375) | l_375) >= l_359.f0))) , p_68));
            l_316 = (1UL && l_375);
            if (((l_331.f3 || (l_376 , l_375)) < l_376.f1))
            { /* block id: 166 */
                uint16_t l_378 = 9UL;
                union U2 l_391 = {0xAE78L};
                l_376.f4 = ((((l_377 , l_378) < (((((float)__builtin_popcount((((l_299 , ((int16_t)0x55E3L - (int16_t)((p_68 <= p_68) > (l_377.f4 <= l_377.f4)))) & __builtin_bswap64(((int32_t)l_378 / (int32_t)l_378))) > l_286)) * (float)l_331.f2) < 0x6.5C1B07p-91) <= 0xE.80014Cp+69) >= p_68)) >= l_377.f0) == l_377.f1);
                l_377.f2 = (((float)0x0.Dp-1 - (float)(p_68 < (func_73(((uint32_t)0x24D7EAAAL % (uint32_t)((int32_t)(l_391 , 0x3037CC93L) / (int32_t)p_68)), l_377.f1, l_392) > l_391.f2))) , p_68);
            }
            else
            { /* block id: 169 */
                struct S0 l_393 = {0x911F6C4FL,0L,0x7178973CL,0x83L,454};
                return l_393;
            }
        }
        else
        { /* block id: 172 */
            l_377 = l_377;
        }
        l_331 = l_377;
    }
    for (l_359.f2 = (-21); (l_359.f2 > 29); l_359.f2 += 1)
    { /* block id: 179 */
        uint32_t l_396 = 1UL;
        int32_t l_420 = 2L;
        uint32_t l_451 = 0x9EE6ECA7L;
        int32_t l_510 = 0x561A88BAL;
        struct S0 l_520 = {0x23A9A361L,0x3506C35AL,1L,255UL,-66};
        uint32_t l_530 = 0x5D77C5ABL;
        uint32_t l_531 = 1UL;
        union U1 l_543 = {0xB.D1C60Cp-20};
        float l_544 = 0x4.B42B07p+22;
        l_359.f4 = (-0x1.Bp+1);
        if ((l_396 >= (0x766C397CL || (((-(uint16_t)(((~((int16_t)(l_314 > l_396) >> (int16_t)((int32_t)((l_286 != l_286) <= (((uint16_t)((((__builtin_clz((((uint32_t)(p_68 != p_68) / (uint32_t)l_316) && 1L)) , p_68) , l_396) <= l_316) , p_68) + (uint16_t)65527UL) != p_68)) % (int32_t)0xBEF7379AL))) || p_68) > p_68)) == p_68) ^ 0L))))
        { /* block id: 181 */
            int32_t l_408 = 1L;
            union U1 l_437 = {0xC.F3E1E3p+36};
            float l_441 = 0x6.9p+1;
            struct S0 l_452 = {0x9539541AL,0xB9ABF689L,0x2115EF3AL,1UL,309};
            int32_t l_453 = (-2L);
            int32_t l_519 = 0x571F5CE4L;
            l_420 = ((((!(l_396 , l_408)) && 65535UL) >= (p_68 > ((uint16_t)l_396 * (uint16_t)(((int32_t)((int16_t)(p_68 >= (-(uint32_t)(l_408 >= ((int16_t)l_396 * (int16_t)((uint16_t)l_331.f0 + (uint16_t)l_331.f2))))) + (int16_t)l_408) - (int32_t)l_408) > l_408)))) < l_359.f4);
            for (l_331.f2 = 0; (l_331.f2 >= (-7)); l_331.f2 -= 1)
            { /* block id: 185 */
                int32_t l_436 = 0x5A61A390L;
                l_423 = l_359;
                l_423.f4 = __builtin_parityll(((int16_t)(((uint16_t)((int16_t)__builtin_clzll(l_423.f3) % (int16_t)p_68) << (uint16_t)5) < ((uint16_t)(p_68 , ((uint16_t)(((func_73(__builtin_clz(l_420), p_68, (((uint16_t)(((l_436 >= ((l_408 && 0x18116297L) ^ 4294967290UL)) == p_68) | l_331.f1) << (uint16_t)l_436) , l_437)) & p_68) == 0xCCBFCE7EL) == 0x41395B51L) - (uint16_t)l_436)) << (uint16_t)l_359.f1)) % (int16_t)p_68));
            }
            for (l_286 = (-23); (l_286 <= 2); l_286++)
            { /* block id: 191 */
                uint16_t l_440 = 0UL;
                union U1 l_442 = {0x2.C62C78p+80};
                struct S0 l_464 = {0UL,0x89E560A1L,4L,0x59L,508};
                uint16_t l_476 = 0x206EL;
                l_423.f4 = (l_440 , (((func_54(l_359.f0, p_68, l_442, p_68) != (((float)((float)((float)p_68 / (float)(l_440 != ((0x4.F232AEp-85 != 0x0.6B8FDCp-91) != l_316))) * (float)0x6.4p+1) * (float)l_420) , 0xFAFB9367L)) , 7L) , p_68));
                for (l_331.f2 = 6; (l_331.f2 != 18); ++l_331.f2)
                { /* block id: 195 */
                    struct S0 l_454 = {4294967295UL,0x6E9846EEL,0xE68CFEE6L,0x51L,53};
                    if (l_451)
                    { /* block id: 196 */
                        l_452 = l_359;
                        if (l_359.f0)
                            continue;
                    }
                    else
                    { /* block id: 199 */
                        uint16_t l_455 = 65535UL;
                        if (l_453)
                            break;
                        l_420 = (p_68 == ((l_454 , p_68) == (-1L)));
                        l_455 = ((0x5.02D1D4p+67 < l_359.f2) == 0x0.7p+1);
                        l_454.f4 = (0x6.3669B7p+93 != ((-0x1.2p-1) != (((float)__builtin_parityll(l_440) - (float)l_451) > (p_68 , ((float)((float)p_68 + (float)((float)(l_464 , 0x8.0p-1) - (float)l_464.f3)) * (float)p_68)))));
                    }
                }
                l_420 = ((float)0x3.42E5E9p+8 - (float)(((float)(((float)(-(float)l_440) * (float)l_420) == ((float)((l_437 , func_54(((uint32_t)(((__builtin_popcount(l_452.f0) ^ l_420) >= l_476) , (((uint16_t)((p_68 , 0xFDB0L) != p_68) - (uint16_t)0x92F1L) | l_423.f2)) / (uint32_t)p_68), p_68, l_299, p_68)) <= 0xE.B90CF8p-17) - (float)p_68)) * (float)p_68) < l_451));
                l_420 = 0xE.82B0EBp+63;
            }
            for (l_451 = 0; (l_451 <= 24); l_451 += 2)
            { /* block id: 211 */
                uint32_t l_483 = 0xDDAF2135L;
                int32_t l_484 = (-6L);
                for (l_331.f3 = (-20); (l_331.f3 <= 10); l_331.f3++)
                { /* block id: 214 */
                    uint16_t l_495 = 0xBBFEL;
                    l_484 = l_483;
                    if (((__builtin_ffs(p_68) <= ((int16_t)l_408 >> (int16_t)(((int16_t)((uint16_t)(((0xD47B47D4L && ((int16_t)(l_452.f1 != p_68) * (int16_t)p_68)) | 4294967290UL) | ((int32_t)(((p_68 >= p_68) , 0x0D7EL) <= 0x47BCL) - (int32_t)l_495)) * (uint16_t)l_484) << (int16_t)p_68) < l_452.f4))) <= 0xF014C9FEL))
                    { /* block id: 216 */
                        if (p_68)
                            break;
                        l_453 = p_68;
                    }
                    else
                    { /* block id: 219 */
                        int16_t l_518 = 7L;
                        l_452.f4 = (((uint16_t)func_79(p_68, l_451) / (uint16_t)((int32_t)(l_483 , __builtin_clz(l_483)) / (int32_t)p_68)) > __builtin_bswap64(func_54(l_452.f1, (1L >= l_420), l_437, l_452.f2)));
                        l_519 = ((int16_t)(((int16_t)(((uint32_t)((p_68 >= (((uint32_t)l_420 - (uint32_t)l_495) || ((int16_t)l_510 * (int16_t)((uint16_t)((int32_t)(~((uint16_t)l_483 + (uint16_t)l_483)) + (int32_t)0x5869DE72L) * (uint16_t)l_518)))) > p_68) + (uint32_t)l_423.f4) , l_518) << (int16_t)p_68) && l_483) / (int16_t)p_68);
                    }
                    l_452 = l_520;
                }
            }
        }
        else
        { /* block id: 226 */
            int16_t l_523 = 0xA5F7L;
            for (l_359.f0 = 23; (l_359.f0 >= 34); l_359.f0 += 4)
            { /* block id: 229 */
                l_523 = ((l_520.f3 > __builtin_ctz(p_68)) <= (l_299 , (p_68 >= p_68)));
                return l_520;
            }
            l_520 = l_520;
            l_520.f4 = __builtin_ctz(func_77(((((uint16_t)p_68 << (uint16_t)(func_79((((((int16_t)((((uint16_t)((l_520.f0 | ((p_68 < ((l_331.f0 ^ (p_68 ^ (p_68 <= func_54((p_68 , l_530), ((((0x95A2L || 0x0156L) & l_523) || 0x8E47L) >= l_359.f1), l_299, l_523)))) || 0xDD1452EEL)) <= (-8L))) != 0x5DB60AD4L) << (uint16_t)l_396) > l_531) , l_359.f1) << (int16_t)p_68) != 1L) , p_68) ^ l_510), l_523) && l_396)) < l_523) & p_68)));
        }
        if (((int32_t)func_54(l_451, (((l_520 , l_359) , ((uint32_t)l_359.f4 / (uint32_t)0x50C5A400L)) < ((int32_t)p_68 / (int32_t)((uint32_t)(p_68 ^ ((int16_t)(-(uint16_t)(l_543 , p_68)) * (int16_t)l_520.f3)) - (uint32_t)p_68))), l_543, p_68) / (int32_t)0x30A52AECL))
        { /* block id: 236 */
            if (l_359.f4)
                goto lbl_545;
        }
        else
        { /* block id: 238 */
            uint8_t l_548 = 246UL;
            for (l_423.f0 = 0; (l_423.f0 > 56); l_423.f0 += 1)
            { /* block id: 241 */
                return l_331;
            }
            l_548 = 8L;
        }
        l_331.f4 = (((l_331.f3 ^ (l_359.f4 , p_68)) , (((l_331.f1 != l_331.f2) | (-(uint32_t)((l_359.f4 != (((uint16_t)p_68 - (uint16_t)p_68) != (l_331.f0 ^ p_68))) | 1UL))) , l_359.f3)) , 0xB.FFA732p-53);
    }
    return l_331;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_73(uint8_t  p_74, float  p_75, union U1  p_76)
{ /* block id: 92 */
    int16_t l_144 = 3L;
    union U1 l_164 = {-0x1.Ap-1};
    int32_t l_170 = 0L;
    struct S0 l_188 = {4294967295UL,3L,1L,1UL,178};
    float l_229 = 0x4.E373B6p-99;
    struct S0 l_230 = {0x98CBD84FL,-8L,2L,0x36L,142};
    uint16_t l_241 = 0xC46AL;
    uint32_t l_242 = 0x25BB58BCL;
    uint16_t l_244 = 0xDF29L;
    if (p_74)
    { /* block id: 93 */
        uint32_t l_145 = 0xF6F4DFACL;
        union U2 l_169 = {0x1578L};
        l_145 = __builtin_ctzl((!l_144));
        l_170 = ((float)((float)(((float)((float)0xA.C33A66p-86 - (float)((float)l_144 / (float)(!(p_75 > (!((float)l_145 / (float)((float)p_75 * (float)(((((float)((((l_164 , (__builtin_parity(((!(((((((__builtin_ffs((((p_74 & ((!(((int16_t)l_145 >> (int16_t)13) , l_145)) | l_145)) && p_74) && 0x1770L)) , 0x4.EBDD08p-92) , l_145) != 0x1.1p+1) , l_164) , l_169) , 65527UL) >= p_74)) | p_74)) != l_144)) != 0xE.356B4Ap-62) < l_144) != p_76.f0) * (float)(-0x10.2p-1)) > p_74) < l_169.f2) != l_145)))))))) / (float)p_75) > 0x2.41155Cp-72) * (float)0x1.2p+1) - (float)p_75);
    }
    else
    { /* block id: 96 */
        uint32_t l_171 = 0UL;
        int32_t l_172 = 0L;
        union U2 l_192 = {65535UL};
        struct S0 l_225 = {4294967295UL,5L,-1L,3UL,-431};
        uint32_t l_228 = 18446744073709551615UL;
        union U1 l_235 = {-0x1.Ap+1};
        uint32_t l_248 = 0xE07D20D7L;
        l_172 = ((0x481FL && 0xD150L) < l_171);
        if (((0x9E7F0AFDL & 4294967295UL) || (-7L)))
        { /* block id: 98 */
            uint8_t l_177 = 254UL;
            int32_t l_187 = 0x77A34269L;
            p_76.f0 = ((float)((float)p_74 * (float)(l_177 , ((float)l_177 + (float)(((((uint16_t)(!((p_74 | p_74) && l_177)) - (uint16_t)p_74) , (((int16_t)__builtin_ctz(p_74) >> (int16_t)l_170) < l_144)) , l_177) , l_171)))) - (float)l_170);
            for (l_172 = 0; (l_172 >= 4); l_172 += 1)
            { /* block id: 102 */
                l_187 = l_171;
            }
        }
        else
        { /* block id: 105 */
            struct S0 l_189 = {4294967295UL,0x2FFCB450L,0xFA698E65L,0x96L,296};
            l_189 = l_188;
            l_192.f1 = ((l_172 && 0xF1602343L) | func_77((((uint16_t)(l_192 , (((((uint16_t)((uint32_t)(l_189.f1 < (((int32_t)(((__builtin_ffs((((4294967287UL && (((uint16_t)(0x5EACDDF5L < l_172) / (uint16_t)((uint16_t)p_74 << (uint16_t)8)) | (((__builtin_clzl(((uint16_t)(l_188.f1 < p_74) * (uint16_t)0xE9FFL)) >= l_189.f0) , 3L) >= l_188.f3))) , l_192.f2) , p_74)) & p_74) == 4294967287UL) > 0xD84902EFL) % (int32_t)p_74) , 0xEF432E68L)) / (uint32_t)p_74) << (uint16_t)l_189.f0) && p_74) , (-0x9.2p+1)) , 0x888CL)) / (uint16_t)p_74) ^ 4294967295UL)));
            l_172 = (((float)0x0.Cp+1 - (float)(-(float)((float)((float)p_76.f0 / (float)(((float)((float)(!((float)(((l_192.f2 , l_144) > ((l_171 != ((float)((float)(p_74 < l_170) + (float)((((float)(((((l_225 , __builtin_ctzl((((((func_77(((int16_t)(0x06259C9FL <= l_188.f0) / (int16_t)p_74)) , l_172) , 5UL) & 0xA9F56009L) == l_228) , l_189.f4))) == p_75) > l_189.f2) > 0x1.D3CF24p-47) != l_225.f1) / (float)l_192.f2) <= l_229) == l_189.f2)) - (float)0x9.794BD2p-65)) < 0xD.FB34F4p-38)) >= 0x9.2B78B9p+60) * (float)p_76.f0)) + (float)p_75) + (float)p_76.f0) <= p_76.f0)) + (float)0x4.4p+1))) != p_76.f0);
        }
        l_188 = l_230;
        if ((p_74 >= (((((p_74 >= (((int16_t)(__builtin_clzl(((~((~(l_235 , p_74)) , 0x518EL)) == (l_230.f2 < ((uint16_t)(((int16_t)(-1L) << (int16_t)(-(int16_t)l_241)) > ((((((l_228 ^ 65535UL) ^ 0xB6DB7354L) >= l_230.f0) && l_241) , l_225.f2) != l_171)) - (uint16_t)l_144)))) ^ l_170) / (int16_t)p_74) & (-1L))) , p_74) < 0UL) & (-2L)) | l_242)))
        { /* block id: 111 */
            uint32_t l_243 = 8UL;
            int32_t l_249 = 0x68F4A9C1L;
            p_76.f0 = (l_243 , p_75);
            l_249 = (l_230.f1 | ((l_244 == (-(uint32_t)0xF7C8D718L)) ^ ((uint16_t)(p_74 , ((p_74 >= l_225.f0) != l_248)) << (uint16_t)15)));
            l_249 = (p_74 | ((int16_t)(((uint32_t)((uint16_t)0x4BD8L + (uint16_t)p_74) + (uint32_t)(l_243 , l_188.f2)) & (((uint32_t)l_171 % (uint32_t)p_74) <= ((int32_t)((int32_t)((uint16_t)((__builtin_parity(p_74) , p_74) | p_74) - (uint16_t)l_225.f4) / (int32_t)1UL) % (int32_t)0xAC5F61C7L))) + (int16_t)l_171));
            l_192.f1 = (0x0.Ep-1 != p_75);
        }
        else
        { /* block id: 116 */
            p_75 = 0x8.CEE96Cp+41;
        }
    }
    l_230 = l_230;
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_77(uint16_t  p_78)
{ /* block id: 61 */
    float l_115 = 0x9.Fp+1;
    int32_t l_127 = 0x918DDDCDL;
    struct S0 l_138 = {0xEA876B16L,3L,0x18CB2972L,0xE9L,277};
    if (p_78)
    { /* block id: 62 */
        uint32_t l_114 = 0xEA94120BL;
        int32_t l_118 = (-1L);
        int32_t l_121 = 0xE4C08A2BL;
        l_115 = (l_114 < p_78);
        for (p_78 = 0; (p_78 == 26); ++p_78)
        { /* block id: 66 */
            l_118 = p_78;
            return p_78;
        }
        for (p_78 = (-30); (p_78 != 29); p_78++)
        { /* block id: 72 */
            return l_121;
        }
        l_118 = l_114;
    }
    else
    { /* block id: 76 */
        uint8_t l_126 = 255UL;
        struct S0 l_130 = {4294967293UL,0x2C7FF412L,0xE74272ABL,0x0CL,-78};
        union U1 l_133 = {0x5.997E34p-67};
        struct S0 l_137 = {0xDCB74961L,0x1667F30DL,1L,9UL,-183};
        l_130.f4 = ((p_78 == ((int16_t)((uint16_t)(((0xEB87L && (p_78 , l_126)) || (p_78 > l_127)) , p_78) * (uint16_t)(((uint16_t)(l_130 , (((int16_t)__builtin_popcountll((((func_54(p_78, l_127, l_133, l_130.f4) <= l_130.f2) , l_127) , 0xAAA56D442F441AF3LL)) - (int16_t)p_78) , 7UL)) * (uint16_t)0xA3D7L) ^ l_127)) >> (int16_t)6)) != l_127);
        for (l_130.f1 = 0; (l_130.f1 == 16); l_130.f1 += 9)
        { /* block id: 80 */
            struct S0 l_136 = {0x33B9E22AL,0x178B3ED5L,0L,0x10L,-207};
            l_137 = l_136;
            l_136 = l_138;
            l_138.f2 = l_136.f2;
        }
    }
    for (l_138.f3 = 0; (l_138.f3 > 21); l_138.f3 += 3)
    { /* block id: 88 */
        l_138.f2 = (-(int32_t)0x434A3FD7L);
    }
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_79(uint32_t  p_80, uint8_t  p_81)
{ /* block id: 54 */
    float l_103 = (-0x1.9p+1);
    float l_104 = 0xA.BBB80Ep+85;
    int32_t l_105 = (-1L);
    union U1 l_108 = {0x4.A864CCp-15};
    int32_t l_109 = 2L;
    union U1 l_110 = {0x0.Ap+1};
    float l_111 = 0x6.Fp+1;
    struct S0 l_113 = {0x5E685AC0L,-1L,0x8566A4DCL,0UL,-409};
    if ((((func_54(p_81, ((uint16_t)((uint16_t)0x679DL >> (uint16_t)((uint16_t)(((int16_t)func_54(((p_80 >= l_105) | (func_54(((uint16_t)p_81 >> (uint16_t)(l_105 , 0x7863L)), l_105, l_108, l_105) < p_80)), p_81, l_108, l_105) >> (int16_t)3) && l_109) * (uint16_t)l_105)) / (uint16_t)l_105), l_110, l_109) != l_109) != 0x596CL) , p_81))
    { /* block id: 55 */
        struct S0 l_112 = {0UL,0x1B0F83D5L,0xB5BC1773L,253UL,47};
        l_113 = l_112;
    }
    else
    { /* block id: 57 */
        return p_80;
    }
    return p_81;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 119
   depth: 1, occurrence: 32
XXX total union variables: 22

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 32
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 21
XXX times a bitfields struct on RHS: 38
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 13

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 157
   depth: 2, occurrence: 33
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 6
   depth: 15, occurrence: 5
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2
   depth: 30, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 697
XXX times a non-volatile is write: 111
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 154
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 41
   depth: 2, occurrence: 41
   depth: 3, occurrence: 20
   depth: 4, occurrence: 7
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 19.8
XXX percentage an existing variable is used: 80.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

