/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --no-pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1424336118
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_28(void);
static int32_t  func_30(uint32_t  p_31, uint32_t  p_32, int32_t  p_33, int8_t  p_34);
static uint32_t  func_35(uint32_t  p_36, int32_t  p_37, int16_t  p_38, uint32_t  p_39);
static int32_t  func_42(uint16_t  p_43);
static int16_t  func_47(float  p_48, uint32_t  p_49, uint32_t  p_50);
static uint32_t  func_51(uint16_t  p_52);
static uint32_t  func_59(uint32_t  p_60);
static uint16_t  func_69(int16_t  p_70, int16_t  p_71);
static int16_t  func_72(int8_t  p_73, int8_t  p_74, float  p_75);
static int32_t  func_88(uint32_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_29 = 0x3EC3D4E7;
    int32_t l_318 = 0xF514575F;
    int8_t l_329 = 0xA4;
    int32_t l_342 = 7;
    int8_t l_356 = (-4);
    uint32_t l_365 = 0U;
    uint16_t l_374 = 0x74C3;
    l_29 = 0x6.398922p+68;
    l_318 = func_30(l_29, (8U >= l_29), (func_35(l_29, l_29, ((int16_t)(func_42(((((~(((int16_t)func_47((0xA.4593F6p+8 < (func_51((((int16_t)(((uint16_t)l_29 * (uint16_t)(-1)) , l_29) << (int16_t)1) , 0x9A31)) , (-0x1.4p-1))), l_29, l_29) >> (int16_t)l_29) , l_29)) , l_29) == 0) != l_29)) && 0x9EB336D3) * (int16_t)l_29), l_29) , l_29), l_29);
    if (((uint16_t)l_318 >> (uint16_t)2))
    { /* block id: 118 */
        int32_t l_321 = 0xE3CE139A;
        return l_321;
    }
    else
    { /* block id: 120 */
        float l_327 = (-0x1.0p+1);
        int8_t l_328 = 0x3B;
        int32_t l_343 = 8;
        float l_352 = 0x6.0p-1;
        int8_t l_362 = 0x3C;
        for (l_318 = 7; (l_318 >= (-5)); l_318 -= 3)
        { /* block id: 123 */
            uint32_t l_337 = 8U;
            l_342 = ((func_42(((int16_t)(!__builtin_ctz(l_328)) << (int16_t)l_328)) ^ l_328) >= ((l_329 , (!((uint32_t)(((uint16_t)(((uint16_t)__builtin_parityl(l_337) >> (uint16_t)1) ^ (((int32_t)((((((uint32_t)l_328 - (uint32_t)l_328) , l_337) || l_328) | l_328) | l_328) - (int32_t)0x498303D3) , l_337)) + (uint16_t)l_29) , l_318) + (uint32_t)0x0F6C4407))) , l_329));
        }
        l_343 = l_328;
        l_318 = ((l_343 <= ((uint16_t)l_328 >> (uint16_t)4)) , (((float)l_343 / (float)((((l_318 != ((float)l_329 + (float)((-0x1.5p+1) >= l_343))) != (l_328 >= ((float)l_342 * (float)l_352))) > l_343) != 0x0.488A8Ap+20)) != 0x6.C85A87p+63));
        if (l_29)
        { /* block id: 128 */
            int32_t l_355 = 0x12CBEF5C;
            l_318 = (__builtin_ffs(((l_29 <= l_29) || ((int32_t)((0x58D1362E <= func_72(l_355, l_343, l_329)) < __builtin_clzl(l_343)) % (int32_t)l_355))) < l_343);
            l_356 = l_355;
            l_343 = (-(uint32_t)(l_29 , l_355));
        }
        else
        { /* block id: 132 */
            float l_358 = 0xB.0C9878p+14;
            int32_t l_359 = 0xF5588D35;
            l_359 = func_72(l_29, l_329, ((l_358 >= (l_359 , ((float)((l_362 , ((((int32_t)((l_365 , (l_362 > (~l_359))) < l_359) / (int32_t)l_359) , (-0x1.8p-1)) != (-0x1.Fp-1))) , l_359) / (float)0x7.FFF6BBp-14))) != 0x0.8p+1));
            l_359 = (0xC.BBC024p-20 < (l_29 <= (l_362 == ((float)0x1.8p+1 + (float)(l_362 < l_359)))));
            l_359 = (l_359 ^ 65535U);
            l_359 = ((int16_t)((((int32_t)l_328 - (int32_t)(l_359 >= (-(uint32_t)l_356))) , ((((((0xFBF5 || func_59(l_343)) > ((l_359 ^ (((l_318 <= ((l_343 && l_29) , 0x685F)) >= l_359) ^ 0xA1F06FFC)) || l_359)) && 1U) < l_374) <= l_343) == l_365)) < l_359) >> (int16_t)l_374);
        }
    }
    return l_374;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_30(uint32_t  p_31, uint32_t  p_32, int32_t  p_33, int8_t  p_34)
{ /* block id: 78 */
    uint16_t l_202 = 5U;
    int32_t l_233 = 0xE74D01EF;
    int8_t l_314 = (-2);
    if (p_32)
    { /* block id: 79 */
lbl_317:
        l_202 = 0x5.5776E6p-30;
    }
    else
    { /* block id: 81 */
        float l_217 = 0x0.9p+1;
        int32_t l_231 = (-9);
        uint32_t l_277 = 0x19411915;
        if (l_202)
        { /* block id: 82 */
            int16_t l_223 = 0xE877;
            int8_t l_232 = 1;
            l_233 = ((float)((float)(((float)(-0x8.Ap+1) + (float)((l_202 <= ((((float)l_202 - (float)(((int16_t)((uint16_t)((uint16_t)((p_34 > p_31) , ((uint32_t)(~(__builtin_ia32_crc32qi(((int16_t)(l_223 > 4294967295U) - (int16_t)0x42C4), ((((int16_t)(((int16_t)((uint16_t)(-(uint16_t)p_33) % (uint16_t)65531U) + (int16_t)0xF996) , p_31) >> (int16_t)14) , l_231) , l_223)) | l_232)) + (uint32_t)l_232)) << (uint16_t)l_231) + (uint16_t)p_31) * (int16_t)p_33) , l_231)) < l_202) <= 0x1.4p-1)) < l_202)) == 0x7.7p-1) + (float)0x6.Ep+1) - (float)l_202);
        }
        else
        { /* block id: 84 */
            int32_t l_252 = (-1);
            int32_t l_278 = (-1);
            int16_t l_296 = 0xFF29;
            if (((((((int32_t)((int16_t)(l_231 && (((uint32_t)((uint16_t)((uint16_t)((uint16_t)p_31 % (uint16_t)p_33) >> (uint16_t)1) >> (uint16_t)(((0x5CDDA558 >= ((uint32_t)l_202 / (uint32_t)1U)) < p_33) <= ((uint16_t)l_231 >> (uint16_t)((int16_t)(func_47(__builtin_clz((p_33 ^ 0x84A6)), p_31, p_32) && 0x5341) * (int16_t)0x30E8)))) / (uint32_t)0x7EFD3BFD) == l_231)) >> (int16_t)l_252) / (int32_t)0x24A45322) >= 0x26FD) & 0U) & l_233) | 2))
            { /* block id: 85 */
                int32_t l_253 = 0;
                l_233 = (l_202 || (__builtin_popcountl((p_34 | l_253)) != (l_252 == ((int16_t)(0x0FA0 != func_35((__builtin_clzll((((uint16_t)l_253 * (uint16_t)((((((p_32 > ((uint16_t)0x4875 % (uint16_t)p_34)) == 0U) != l_253) != p_32) , 4294967295U) , l_253)) , l_231)) != 0x1ADA), p_34, l_253, p_31)) + (int16_t)l_233))));
            }
            else
            { /* block id: 87 */
                float l_279 = 0x3.BC6ABAp-91;
                int32_t l_280 = (-3);
                uint32_t l_301 = 1U;
                for (p_34 = 1; (p_34 == (-10)); p_34--)
                { /* block id: 90 */
                    int8_t l_270 = 0x7D;
                    int32_t l_297 = 0x608FC4C5;
                    l_233 = l_231;
                    if ((((uint32_t)0x0C70173F + (uint32_t)((uint16_t)(((int16_t)((int16_t)(p_31 || (l_270 || func_47(p_31, ((((int16_t)p_33 >> (int16_t)((((int16_t)l_277 - (int16_t)0xDEBD) | (p_34 == l_233)) , 0x9AB2)) , p_31) >= l_202), p_34))) << (int16_t)1) * (int16_t)l_270) < l_252) + (uint16_t)1U)) ^ 0x2399))
                    { /* block id: 92 */
                        l_278 = p_31;
                    }
                    else
                    { /* block id: 94 */
                        l_278 = l_231;
                        l_278 = 0xB230E549;
                        l_280 = ((func_88((l_280 , 0U)) > l_270) , p_31);
                    }
                    if ((l_202 | ((int32_t)(func_47(l_270, l_202, p_32) & l_278) % (int32_t)((l_280 > 0x9D19914B) , __builtin_parity(l_231)))))
                    { /* block id: 99 */
                        uint32_t l_291 = 1U;
                        int32_t l_298 = 0x5FFFB89C;
                        l_298 = (((int16_t)((int32_t)((int32_t)p_31 / (int32_t)p_31) - (int32_t)(1U >= (((((int16_t)(1 ^ func_35(l_291, (l_270 <= (__builtin_ctz(p_31) & ((int16_t)(((((uint16_t)l_280 + (uint16_t)l_296) , l_291) > p_33) == l_297) * (int16_t)4))), l_291, p_32)) << (int16_t)p_34) , p_33) , (-9)) ^ 8))) * (int16_t)p_32) >= 0x4A0E);
                    }
                    else
                    { /* block id: 101 */
                        l_280 = ((0x5.7p-1 <= __builtin_popcountll(p_33)) != (l_231 <= l_233));
                    }
                    l_280 = (func_59(((int16_t)l_301 * (int16_t)p_31)) > l_296);
                }
            }
            l_231 = ((int16_t)((uint32_t)(__builtin_ffsl((((int16_t)l_233 / (int16_t)((int32_t)((int32_t)p_34 / (int32_t)(l_296 , ((uint32_t)p_31 + (uint32_t)p_31))) / (int32_t)(p_32 , 0x6BE0F0FC))) , l_296)) & 0xFD053127) % (uint32_t)l_296) << (int16_t)10);
        }
        l_233 = (p_32 , l_314);
    }
    for (p_31 = 0; (p_31 <= 20); p_31 += 1)
    { /* block id: 113 */
        if (l_202)
            goto lbl_317;
    }
    return p_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_35(uint32_t  p_36, int32_t  p_37, int16_t  p_38, uint32_t  p_39)
{ /* block id: 75 */
    int16_t l_197 = 0;
    uint32_t l_200 = 6U;
    int32_t l_201 = (-1);
    l_201 = ((((uint32_t)((uint32_t)0x1DC8AE0D - (uint32_t)(((uint16_t)(((uint16_t)((int16_t)l_197 * (int16_t)((p_38 , p_37) == l_197)) << (uint16_t)5) >= (((((p_38 , ((float)0x5.Bp+1 / (float)(l_197 > ((p_39 , l_200) , p_36)))) > 0x9.A53846p+87) <= p_38) <= l_200) , p_39)) + (uint16_t)l_200) | p_38)) - (uint32_t)l_200) , 0x0.A82359p-27) != p_36);
    return l_200;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_42(uint16_t  p_43)
{ /* block id: 64 */
    uint16_t l_155 = 65527U;
    int32_t l_170 = 0x97128C3F;
    l_155 = 5;
    l_170 = ((float)(p_43 < p_43) - (float)(((float)p_43 / (float)((p_43 > ((float)((float)0x9.FF8C07p-58 / (float)l_155) + (float)((float)(((float)(-0x1.5p+1) / (float)(-0x1.8p+1)) > ((float)((p_43 , 0x01AE01D7) , (-0x1.Ep-1)) - (float)p_43)) - (float)l_155))) >= 0x3.88980Cp-1)) == l_155));
    l_170 = __builtin_ctz(((uint16_t)((int16_t)(-1) * (int16_t)((p_43 == 1U) || ((int16_t)l_155 + (int16_t)l_155))) >> (uint16_t)((((p_43 == ((float)((float)((float)(func_47((l_155 >= (-0x7.9p+1)), (p_43 == 0x8F72), l_155) > 0xE.A80240p+74) - (float)l_170) / (float)l_155) - (float)0x1.1p+1)) >= 0x3.7p-1) > 0x1.1p-1) , p_43)));
    for (l_170 = 9; (l_170 == (-20)); l_170 -= 1)
    { /* block id: 70 */
        float l_185 = 0x1.7p+1;
        int32_t l_186 = 0x41BD5012;
        if (l_155)
            break;
        return l_186;
    }
    return l_155;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_47(float  p_48, uint32_t  p_49, uint32_t  p_50)
{ /* block id: 61 */
    float l_151 = (-0x10.Ap-1);
    int32_t l_152 = 1;
    p_48 = (((((uint16_t)((((p_49 | ((p_50 | (p_50 & 1U)) , ((uint32_t)(l_152 <= p_49) % (uint32_t)l_152))) >= p_50) | (((float)(l_152 != l_152) * (float)p_49) , 0xCBA8)) , p_49) / (uint16_t)(-9)) || 1U) , 0) , (-0x1.Ap-1));
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_51(uint16_t  p_52)
{ /* block id: 38 */
    float l_143 = (-0x1.7p+1);
    int32_t l_144 = 0;
    int32_t l_145 = 0xAB454EC5;
    uint16_t l_146 = 65535U;
    l_144 = (((p_52 > ((float)p_52 - (float)((func_59((p_52 & (-1))) , ((((float)p_52 * (float)(l_144 , ((0x8.5946A6p-75 >= ((((l_144 < l_144) >= l_145) < p_52) <= l_144)) <= l_144))) == 0x1.0p+1) > l_146)) <= l_144))) , p_52) <= 0x0.4p+1);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_59(uint32_t  p_60)
{ /* block id: 39 */
    uint32_t l_64 = 0U;
    int32_t l_139 = 0;
    l_139 = (!((int16_t)l_64 * (int16_t)(-(int32_t)(((int32_t)((~p_60) , (p_60 < (((0x101E != (func_69((p_60 && (l_64 > func_72((p_60 , (0x584125DB <= 5U)), p_60, p_60))), p_60) == l_64)) & l_64) , p_60))) % (int32_t)l_64) <= (-6)))));
    l_139 = __builtin_ctzll(p_60);
    l_139 = ((p_60 <= ((l_64 , (-(float)l_64)) != l_139)) >= l_139);
    return l_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_69(int16_t  p_70, int16_t  p_71)
{ /* block id: 51 */
    int32_t l_128 = 1;
    int8_t l_134 = (-1);
    l_128 = (p_71 >= (p_70 == ((float)p_70 + (float)p_70)));
    l_128 = (-(int16_t)((int32_t)((int16_t)l_134 * (int16_t)(((((uint16_t)(func_72(((uint16_t)0U << (uint16_t)(((0U < p_71) && p_70) , l_128)), l_128, l_134) | 0x77DDA0CF) >> (uint16_t)p_71) ^ l_134) != p_70) >= 0xFE2E886B)) + (int32_t)p_71));
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_72(int8_t  p_73, int8_t  p_74, float  p_75)
{ /* block id: 40 */
    int16_t l_81 = 0;
    int32_t l_125 = 9;
    l_125 = ((((((int16_t)(-(int32_t)0x036C8609) * (int16_t)((((int16_t)((p_73 ^ (l_81 >= ((uint16_t)(__builtin_clzl(p_73) != ((int16_t)0xC6A0 * (int16_t)(l_81 < ((int32_t)0xE707ECB5 - (int32_t)func_88((((uint16_t)((uint16_t)(l_81 || l_81) % (uint16_t)l_81) >> (uint16_t)l_81) & l_81)))))) * (uint16_t)l_81))) ^ p_73) % (int16_t)0x4FE2) && 1) < 4)) | l_81) , l_81) | 0xE6A8) ^ 1);
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_88(uint32_t  p_89)
{ /* block id: 41 */
    int16_t l_100 = 0xC653;
    int16_t l_110 = 3;
    int32_t l_111 = 8;
    for (p_89 = 0; (p_89 == 11); p_89 += 5)
    { /* block id: 44 */
        l_111 = ((int16_t)((p_89 < p_89) || ((((int32_t)(p_89 & (l_100 || p_89)) - (int32_t)(l_100 || (((((int16_t)(-(uint16_t)((int16_t)(((uint16_t)p_89 >> (uint16_t)((int32_t)0x2D060950 / (int32_t)p_89)) == 1U) >> (int16_t)9)) * (int16_t)l_100) || l_100) || 4294967286U) < p_89))) || l_110) || p_89)) >> (int16_t)1);
    }
    l_111 = ((((int16_t)((((p_89 || ((uint16_t)((((uint32_t)(__builtin_parityll(l_110) == 65535U) - (uint32_t)((int32_t)1 - (int32_t)((!(((uint16_t)l_111 >> (uint16_t)15) , l_110)) || ((int16_t)p_89 << (int16_t)8)))) || (-9)) >= p_89) * (uint16_t)l_110)) > (-4)) < l_100) , p_89) >> (int16_t)p_89) < l_111) == l_111);
    return p_89;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 66
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 10
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 356
XXX times a non-volatile is write: 44
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 65
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 12
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 16.7
XXX percentage an existing variable is used: 83.3
********************* end of statistics **********************/

