/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3063355182
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   float  f1;
};

struct S1 {
   int16_t  f0;
   int32_t  f1;
   uint32_t  f2;
   int16_t  f3;
   int32_t  f4;
   unsigned f5 : 19;
   float  f6;
   uint32_t  f7;
   float  f8;
};

struct S2 {
   int32_t  f0;
   int32_t  f1;
   uint32_t  f2;
   int16_t  f3;
   int32_t  f4;
   int32_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
static struct S1  func_31(float  p_32, uint16_t  p_33, int32_t  p_34, uint32_t  p_35);
inline static float  func_36(int32_t  p_37, uint32_t  p_38, struct S1  p_39);
static int16_t  func_48(uint32_t  p_49);
inline static int32_t  func_50(float  p_51);
inline static uint16_t  func_56(uint32_t  p_57, struct S2  p_58, struct S2  p_59, uint16_t  p_60);
static struct S2  func_62(uint16_t  p_63, uint32_t  p_64, int16_t  p_65);
inline static uint32_t  func_79(float  p_80, struct S1  p_81);
static struct S1  func_83(struct S2  p_84, uint32_t  p_85, uint32_t  p_86, struct S2  p_87);
inline static struct S2  func_88(uint32_t  p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_40 = 0x4DE5A82A;
    int16_t l_47 = 0x866B;
    struct S1 l_480 = {8,0x1405779F,4U,2,0xB59CCD43,600,-0x3.Ap-1,1U,0x0.Bp+1};
    int32_t l_485 = 0xEEAB735D;
    l_480 = func_31((func_36(l_40, (((uint32_t)((int16_t)(((uint16_t)(((__builtin_parityl(l_40) && 0x1B8C) != (l_40 ^ l_40)) < (l_40 != l_47)) % (uint16_t)func_48(((func_50(l_47) && l_47) || l_40))) && 5) % (int16_t)l_47) + (uint32_t)l_47) <= l_40), l_480) > l_47), l_480.f7, l_485, l_480.f1);
    return l_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_31(float  p_32, uint16_t  p_33, int32_t  p_34, uint32_t  p_35)
{ /* block id: 229 */
    struct S1 l_486 = {0x0117,-1,0x1765399F,0,0xA15A1C98,661,0x0.8p+1,4294967295U,0x6.77DCC2p-77};
    p_34 = (p_35 || 8);
    return l_486;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_36(int32_t  p_37, uint32_t  p_38, struct S1  p_39)
{ /* block id: 220 */
    uint16_t l_481 = 5U;
    struct S2 l_483 = {1,-1,0x14C194D4,0xED37,0x630CDF4D,-1};
    if (l_481)
    { /* block id: 221 */
        struct S2 l_482 = {1,0xDEB0F938,0x7E7354A5,0x2B0D,0xA5E97BEE,0x317F9BE1};
        l_482 = l_482;
        p_39.f6 = (l_481 != ((0x0.7p+1 <= p_39.f8) != l_482.f1));
    }
    else
    { /* block id: 224 */
        struct S2 l_484 = {-1,-4,0x428E9263,-3,8,-1};
        l_484 = l_483;
        l_484.f1 = l_483.f0;
    }
    return p_39.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_48(uint32_t  p_49)
{ /* block id: 216 */
    struct S1 l_479 = {-1,1,9U,0x35C7,2,575,0x3.30DE5Dp+60,0xEBDF9232,-0x7.Ep+1};
    l_479 = l_479;
    l_479.f1 = (l_479.f0 <= p_49);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_50(float  p_51)
{ /* block id: 37 */
    int16_t l_61 = 0x7647;
    struct S2 l_152 = {1,-9,0x0CF37CF8,0xE107,1,-1};
    struct S0 l_242 = {0x6503A9D8,0x7.08A047p-93};
    struct S2 l_249 = {0,7,0xD6FD450B,3,0x9C8D91A4,0x2D8EFB94};
    struct S1 l_253 = {-5,8,0x44536B68,0x5E1F,3,107,0x0.8p-1,0x1A1B9127,0x6.004464p+90};
    uint32_t l_302 = 4294967287U;
    if (((int16_t)(-1) * (int16_t)(((uint16_t)func_56(l_61, func_62(((uint32_t)((uint32_t)l_61 - (uint32_t)(4294967295U <= ((uint16_t)((int16_t)__builtin_ctzll(l_61) * (int16_t)((l_61 <= (l_61 & l_61)) & 4294967287U)) << (uint16_t)15))) - (uint32_t)0xED9E6264), l_61, l_61), l_152, l_152.f2) << (uint16_t)l_152.f0) & 1U)))
    { /* block id: 119 */
        uint16_t l_195 = 65530U;
        struct S2 l_196 = {0x74455C9E,0,0xC93FC3FC,-6,7,0xA6541942};
        struct S0 l_206 = {0x782676FA,-0x1.Ap-1};
        struct S1 l_221 = {-1,0x967E0349,0x2C2B5224,0x523F,-6,5,0x6.0p+1,0xCAC7D101,0x1.7p+1};
        struct S2 l_265 = {0xACB36B85,4,0U,-1,0x4347F6A0,0xE1D5CE0B};
        uint16_t l_283 = 0x1985;
        struct S1 l_303 = {-1,8,0xFBB84C37,0xB97D,8,422,0x7.D98A26p+48,0x47F5A99F,0x1.559DDDp-86};
        uint32_t l_352 = 0x088389EF;
lbl_461:
        l_152.f1 = func_56((l_195 ^ l_195), l_196, l_196, (0xA1A27E34 < (-(uint16_t)(((uint16_t)((uint16_t)((((int16_t)(((l_196.f4 && (l_152.f3 & (0xE175 <= l_152.f5))) < 0x086E) > l_195) << (int16_t)0) && l_152.f3) & l_152.f0) - (uint16_t)0xD3D4) - (uint16_t)0U) != l_152.f0))));
        for (l_61 = (-19); (l_61 >= 0); l_61++)
        { /* block id: 123 */
            int32_t l_215 = 8;
            struct S1 l_222 = {0x512A,0x62BF9C2C,0x9A2DDA9A,0x731C,0x5E046418,364,0x1.4p+1,4U,-0x2.6p-1};
            l_206 = l_206;
            l_152.f1 = ((float)((float)(p_51 < (0x6.2p-1 <= l_61)) * (float)(((float)p_51 + (float)((float)__builtin_ffsl(l_215) - (float)(((l_215 > ((float)((((((((float)(0xE.94AC38p+84 <= (l_195 == p_51)) * (float)p_51) == 0x0.7p+1) < l_215) >= 0x4.A8FA0Fp+36) <= 0x1.4p+1) == (-0x1.Fp+1)) <= 0xF.383889p-70) * (float)p_51)) == l_196.f1) < p_51))) < p_51)) - (float)l_152.f0);
            p_51 = ((0x6.703BB8p+35 == (((-0x1.1p-1) >= 0xB.3842C4p+88) > (!func_79(p_51, l_221)))) < l_215);
            l_222 = l_222;
        }
        l_152 = func_62(((-8) <= (((((uint16_t)l_152.f4 >> (uint16_t)(!((((uint16_t)((uint16_t)(0xCD65 < (((uint32_t)l_152.f5 - (uint32_t)l_221.f2) != 0x11F5)) >> (uint16_t)((uint16_t)l_152.f5 * (uint16_t)((((uint32_t)(((uint16_t)(l_221.f7 || ((uint32_t)l_221.f1 % (uint32_t)l_221.f5)) - (uint16_t)65535U) < l_195) % (uint32_t)l_195) && l_61) | l_196.f4))) * (uint16_t)l_152.f3) && l_221.f2) && l_61))) < l_206.f0) <= l_152.f0) == l_152.f1)), l_152.f2, l_196.f0);
        for (l_221.f7 = 0; (l_221.f7 > 8); ++l_221.f7)
        { /* block id: 132 */
            int32_t l_252 = 0x14A1B8DF;
            struct S2 l_269 = {-1,0x48EBBB27,0x3A31FFB4,-1,2,0};
            float l_277 = 0x4.Ap-1;
            int32_t l_278 = 0x19995588;
            struct S0 l_282 = {1U,-0x4.0p-1};
            float l_437 = 0x0.6p-1;
            struct S1 l_441 = {0x0FA8,0x425C8348,4294967286U,0x2DD3,8,34,0x7.03F4BBp-55,4294967289U,0x1.Fp-1};
            struct S1 l_468 = {0x1541,2,0xAF639DCC,8,9,526,0x0.Cp+1,0U,-0x3.7p+1};
            l_242 = l_242;
            l_152.f1 = (-1);
            if (((uint16_t)func_79((l_152.f0 > (l_152.f3 <= ((float)0x5.A228F5p-80 * (float)((float)(l_221.f2 <= func_56(l_152.f5, l_196, l_249, (((uint16_t)l_252 % (uint16_t)l_221.f2) && (-1)))) + (float)l_252)))), l_253) * (uint16_t)65535U))
            { /* block id: 135 */
                float l_254 = 0x1.2D32F5p-88;
                int32_t l_255 = 0x7E00CCF4;
                struct S2 l_281 = {0x0D9C446D,6,4U,0xD628,-5,-8};
                if (l_255)
                { /* block id: 136 */
                    int32_t l_264 = (-1);
                    l_253 = func_83(l_196, (l_252 >= l_252), ((uint32_t)l_255 + (uint32_t)((int16_t)__builtin_ia32_crc32qi(l_152.f0, ((uint16_t)(((uint16_t)(l_255 ^ (-4)) - (uint16_t)l_252) != (0 && l_264)) * (uint16_t)l_249.f4)) >> (int16_t)l_253.f7)), l_265);
                    return l_255;
                }
                else
                { /* block id: 139 */
                    uint32_t l_268 = 0x17BF7F86;
                    struct S2 l_270 = {0x69641683,0x4A802A8A,0U,1,-5,1};
                    uint32_t l_271 = 4294967290U;
                    if (((int16_t)(l_268 < (((-3) && (__builtin_ctzl(l_196.f1) != func_56(l_253.f4, l_269, l_270, ((l_221.f1 & ((l_265.f3 < l_152.f5) <= 0xC568)) < 4294967295U)))) <= l_270.f2)) + (int16_t)l_269.f0))
                    { /* block id: 140 */
                        l_270.f1 = l_253.f0;
                        return l_265.f2;
                    }
                    else
                    { /* block id: 143 */
                        uint32_t l_274 = 4U;
                        l_269.f1 = ((((l_252 | (l_271 < (((uint16_t)l_255 << (uint16_t)l_274) ^ (((((((uint16_t)((1U && __builtin_bswap64(l_274)) > ((l_270.f4 & l_61) == l_253.f7)) - (uint16_t)l_253.f4) == 65526U) || l_271) & l_196.f0) & l_249.f0) >= 0xDD2467AC)))) != l_255) > l_152.f3) && l_278);
                    }
                    l_152 = l_270;
                    p_51 = ((l_269.f5 > (((float)l_269.f3 * (float)(p_51 >= func_56((l_269.f4 ^ l_249.f4), l_281, l_269, l_281.f5))) > (-0x7.8p+1))) > p_51);
                }
                l_282 = l_242;
                return l_283;
            }
            else
            { /* block id: 151 */
                uint16_t l_294 = 0x4F26;
                if (l_196.f2)
                    break;
                l_249.f1 = ((float)((float)((float)p_51 * (float)(0x1.3p+1 <= ((((p_51 <= ((l_196.f3 > (p_51 >= (((float)((float)p_51 + (float)((-0x1.9p+1) == (0x6.6p+1 >= (0xC.AC10FEp+55 < 0x5.2p+1)))) * (float)l_294) == l_294))) >= (-0x1.Ep+1))) > l_265.f5) >= 0xD.73470Ap+36) >= p_51))) - (float)p_51) + (float)l_265.f5);
                l_252 = (-(int16_t)l_294);
            }
            if ((((uint32_t)(((int32_t)l_253.f4 - (int32_t)((int32_t)l_278 % (int32_t)((l_221.f3 != (1U == l_196.f5)) ^ (l_269.f2 != l_278)))) != (0xCF57F94C & func_56(func_56(l_152.f1, l_196, l_152, l_269.f1), l_196, l_269, l_269.f0))) + (uint32_t)l_302) || l_196.f0))
            { /* block id: 156 */
                uint32_t l_311 = 0U;
                struct S2 l_331 = {0x4A989218,0xE4B0C4D8,0xC3E96508,0x6CEA,0,0xBCFE45B5};
                struct S1 l_351 = {0,0,0xBDAD22CC,0,0xC9A249E6,77,0x0.Dp+1,0xC9E616EE,-0x1.Bp+1};
                struct S0 l_398 = {0x2ACAABBD,-0x1.Ep-1};
                int32_t l_431 = 0xA32EF321;
                uint32_t l_460 = 0x24D027C7;
                if (l_196.f1)
                { /* block id: 157 */
                    l_303 = l_221;
                }
                else
                { /* block id: 159 */
                    int32_t l_304 = 3;
                    struct S2 l_324 = {0x5CE9EFB8,0xE764DF80,0U,-1,1,-2};
                    l_253.f1 = ((0x1.Cp+1 >= (((__builtin_ffsll(l_304) != ((float)(l_196.f5 < ((float)p_51 - (float)func_56((((int16_t)l_304 >> (int16_t)(5 > 1)) == l_303.f1), l_265, l_196, l_304))) + (float)0x0.1p-1)) < (-0x1.Fp-1)) < l_269.f1)) > 0xA.2560BBp+90);
                    if (((func_56(((((l_311 || ((l_303.f1 != l_282.f0) > (l_249.f5 < (((uint32_t)((uint16_t)((uint16_t)l_269.f1 << (uint16_t)13) + (uint16_t)l_221.f5) - (uint32_t)l_196.f5) < l_265.f1)))) || __builtin_parityl(((l_221.f3 > 65533U) < l_253.f2))) && l_304) ^ l_196.f3), l_265, l_196, l_252) || l_311) >= l_269.f4))
                    { /* block id: 161 */
                        uint16_t l_325 = 0xF139;
                        l_325 = (((uint16_t)func_79(((float)(-0x5.9p-1) * (float)(p_51 != p_51)), func_83(l_196, l_311, ((uint32_t)l_253.f0 % (uint32_t)l_249.f4), l_324)) >> (uint16_t)14) || l_311);
                    }
                    else
                    { /* block id: 163 */
                        uint16_t l_328 = 0x8C2A;
                        l_331.f1 = ((uint32_t)l_328 + (uint32_t)(((((__builtin_ia32_crc32qi(((((1U ^ ((uint16_t)l_324.f1 << (uint16_t)func_79(p_51, func_83(l_331, ((uint16_t)__builtin_clzl(l_331.f1) >> (uint16_t)3), l_324.f2, func_62((__builtin_parityll((!((uint32_t)(((((uint32_t)((int16_t)((uint32_t)4294967288U % (uint32_t)l_253.f0) << (int16_t)6) % (uint32_t)(-6)) >= l_311) || l_242.f0) && 2) % (uint32_t)l_328))) & 0x47E4AD08), l_328, l_303.f7))))) >= 0U) != l_324.f0) && l_269.f4), l_331.f3) != 4U) != 0xBA0075ED) || l_331.f0) >= l_269.f0) ^ l_253.f7));
                    }
                    return l_253.f7;
                }
                if (((uint32_t)((uint32_t)((((0x33755327 < (((((uint16_t)(l_196.f1 < (((l_249.f3 & func_56(l_269.f3, l_196, func_62(l_152.f4, l_331.f0, ((int32_t)((func_79(p_51, l_351) || l_152.f5) | 0) - (int32_t)l_351.f5)), l_269.f1)) >= 0) == 4294967291U)) * (uint16_t)l_221.f0) == 0x69D9) != l_253.f3) != 0x6F19421C)) <= l_221.f2) && l_269.f4) ^ l_351.f7) - (uint32_t)l_265.f3) + (uint32_t)l_352))
                { /* block id: 168 */
                    int16_t l_363 = (-1);
                    struct S2 l_372 = {0x330735F3,-1,0x0BB2F9CE,0xAA67,0,-1};
                    struct S0 l_399 = {4294967295U,-0x8.2p-1};
                    int32_t l_406 = (-9);
                    l_253.f4 = (0U | (((uint16_t)((int16_t)(l_221.f2 <= ((((int16_t)((uint16_t)((l_253.f4 & __builtin_ia32_crc32qi(l_269.f2, ((uint32_t)l_269.f3 + (uint32_t)l_363))) >= l_351.f1) << (uint16_t)(0 && l_269.f4)) * (int16_t)7) <= l_363) ^ l_269.f5)) << (int16_t)2) % (uint16_t)l_269.f5) != l_282.f0));
                    if ((((__builtin_ctzl(l_363) & ((int16_t)(l_351.f1 ^ ((uint32_t)(((int32_t)((((uint16_t)0xCAE9 * (uint16_t)(l_363 < func_56(l_269.f0, l_331, l_372, (~1U)))) < 0xE9C9) == l_331.f2) + (int32_t)l_221.f5) >= l_331.f1) % (uint32_t)l_372.f1)) - (int16_t)0xBB33)) >= l_269.f5) | l_152.f5))
                    { /* block id: 170 */
                        int32_t l_376 = (-2);
                        l_372 = func_88(func_79(l_265.f1, l_303));
                        l_351.f1 = ((uint16_t)(l_376 != (l_269.f5 < l_253.f0)) >> (uint16_t)l_302);
                    }
                    else
                    { /* block id: 173 */
                        int32_t l_377 = 0xBF8AFA24;
                        struct S1 l_380 = {0xF5B7,0x2C6A256C,0x74AFCB34,7,0xC18EDC46,683,-0x1.6p+1,0U,-0x9.4p-1};
                        l_265.f1 = (l_377 != ((__builtin_ffs(((((uint32_t)(func_79(p_51, l_380) & l_269.f1) + (uint32_t)(l_265.f0 ^ ((int16_t)0x8989 << (int16_t)((func_79((-(float)((l_265.f1 != (((float)((float)((float)((float)((float)((float)((((float)0x0.Cp-1 + (float)0x6.463DE3p-4) >= l_253.f5) < p_51) - (float)l_249.f4) * (float)p_51) - (float)p_51) - (float)l_303.f2) - (float)l_282.f0) * (float)0x5.5BECB5p+98) < l_351.f2)) <= l_372.f5)), l_351) | l_372.f0) ^ l_372.f2)))) < l_253.f2) <= 0x46DE2AF3)) & l_372.f3) == l_351.f2));
                    }
                    l_399 = l_398;
                    l_269.f1 = ((l_249.f1 | (0x9C00F634 <= ((uint16_t)(((uint16_t)l_331.f0 - (uint16_t)l_196.f0) ^ l_253.f3) >> (uint16_t)((int16_t)(l_351.f7 >= (((l_253.f0 | (__builtin_ctzl(l_61) < l_252)) | (-3)) != 0xC16A)) * (int16_t)l_406)))) && 0xD73B);
                }
                else
                { /* block id: 178 */
                    float l_429 = 0x4.586BAAp+48;
                    int32_t l_430 = 0xC99ACC5E;
                    struct S1 l_440 = {-1,0xC35FCF61,0x6832A09D,0x66E8,0x3A9402B9,221,-0x1.3p+1,0x6BCEFBD8,0x1.Ep+1};
                    if ((((uint16_t)(l_278 > 9) * (uint16_t)((int32_t)0 + (int32_t)(0x15BF7E9F && l_303.f5))) >= ((uint16_t)((int16_t)l_152.f4 << (int16_t)5) % (uint16_t)(((int16_t)0x741C + (int16_t)l_249.f5) & ((int32_t)((((int16_t)(!((uint16_t)((-(uint16_t)(((uint16_t)((uint16_t)((7 || 65531U) != 0x3002) * (uint16_t)l_331.f3) % (uint16_t)l_430) && 65535U)) ^ l_351.f7) - (uint16_t)l_221.f7)) >> (int16_t)l_282.f0) <= l_430) == l_431) - (int32_t)0xAA20FFC5)))))
                    { /* block id: 179 */
                        struct S2 l_432 = {0x41BD8501,0x5D0D24DE,0x3A341F3C,0x36CD,7,-1};
                        l_432 = func_88(l_430);
                        l_441 = func_83(l_269, l_206.f0, ((((((uint16_t)0U >> (uint16_t)((0xFAF1 < ((uint16_t)l_432.f2 << (uint16_t)6)) > ((int16_t)func_79((p_51 == p_51), l_440) << (int16_t)3))) <= l_282.f0) & 0U) == (-8)) ^ (-1)), l_331);
                        p_51 = (((float)((float)(l_440.f0 == 0x1.3p+1) + (float)0x5.12E550p+23) + (float)0xA.10B5C2p-59) > (p_51 <= func_56((~l_432.f0), func_62(l_152.f4, ((((((int16_t)l_269.f0 << (int16_t)12) && 0x5BB6) && l_432.f1) ^ l_352) ^ l_441.f0), l_221.f3), l_331, l_352)));
                        l_206 = l_398;
                    }
                    else
                    { /* block id: 184 */
                        l_460 = ((uint16_t)__builtin_ffsll(l_440.f1) * (uint16_t)((int16_t)((int32_t)(l_331.f2 == ((int16_t)l_440.f3 << (int16_t)((int32_t)(!((0x1BF4CB5F && func_79(l_398.f0, l_221)) & l_196.f3)) - (int32_t)l_331.f1))) % (int32_t)l_221.f4) << (int16_t)12));
                        if (l_196.f0)
                            goto lbl_461;
                    }
                }
                for (l_441.f2 = 0; (l_441.f2 < 44); l_441.f2++)
                { /* block id: 191 */
                    uint16_t l_464 = 0xDDC3;
                    struct S2 l_469 = {0xA246E98B,0,4294967290U,0xBDB5,0x1F62966B,0x9A4D8FAA};
                    l_221.f4 = l_152.f3;
                    l_464 = 0;
                    if (l_351.f1)
                        continue;
                    for (l_398.f0 = 4; (l_398.f0 == 20); l_398.f0 += 1)
                    { /* block id: 197 */
                        struct S1 l_467 = {0xD318,0x044645AC,2U,1,-2,299,0x3.BBF9F6p-98,0xDB5ED032,0x5.D2DCC7p+96};
                        l_468 = l_467;
                        l_469 = l_331;
                        l_253 = l_467;
                    }
                }
            }
            else
            { /* block id: 203 */
                float l_470 = 0x4.D8EDF3p-89;
                return l_269.f0;
            }
        }
    }
    else
    { /* block id: 207 */
        uint32_t l_474 = 0U;
        struct S1 l_477 = {0,0xE6407EA9,0xA6B2575C,7,0x67AF3AAD,313,0x6.9B6CD4p-9,0x4F23389F,-0x1.Bp-1};
        struct S2 l_478 = {0xDF847F58,0x3C5DA9F9,0xD79A69A2,0x1AF0,0xFCBE7A38,0};
        for (l_242.f0 = 0; (l_242.f0 == 41); ++l_242.f0)
        { /* block id: 210 */
            float l_473 = 0xD.01FD64p-53;
            l_474 = (p_51 == l_473);
        }
        l_477 = func_83(l_249, ((func_79(func_79(func_79((((float)(p_51 != (p_51 > __builtin_ffs(__builtin_ffs(((0x94F150EE >= 2) && l_253.f0))))) + (float)l_474) <= 0xC.8987E5p-52), l_477), l_477), l_477) > l_477.f0) < 0x33FFC3DD), l_249.f5, l_478);
    }
    return l_249.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_56(uint32_t  p_57, struct S2  p_58, struct S2  p_59, uint16_t  p_60)
{ /* block id: 102 */
    int32_t l_155 = 0xE99574A3;
    struct S2 l_157 = {0,1,0x60482E1C,0x61D4,0xFA962913,0x7DCBD80D};
    struct S1 l_166 = {5,-8,0x2E4DC6A2,0xA35C,-1,461,0x1.5p+1,0x2C6C1354,0x6.D6FB1Fp-9};
    struct S0 l_170 = {9U,0x3.5p-1};
    if (((uint16_t)l_155 << (uint16_t)8))
    { /* block id: 103 */
        struct S2 l_156 = {0x458D2133,-4,8U,0x04EE,0xDB16BE7C,0xCA683B8F};
        float l_165 = (-0x7.Ep-1);
        l_157 = l_156;
        l_157.f1 = ((float)l_157.f1 - (float)p_58.f5);
        l_156.f1 = p_59.f1;
        l_166.f4 = (((!((float)l_156.f2 + (float)(0x4.17C060p-21 < ((-0x1.1p+1) <= ((float)(((-0x1.3p-1) != l_165) < (l_156.f4 != func_79(l_157.f4, l_166))) * (float)p_59.f4))))) > p_59.f4) >= p_59.f2);
    }
    else
    { /* block id: 108 */
        int32_t l_169 = 0;
        struct S0 l_171 = {0xC475D44B,-0x7.Bp-1};
        int32_t l_193 = (-1);
        for (l_166.f7 = 16; (l_166.f7 <= 48); ++l_166.f7)
        { /* block id: 111 */
            return l_169;
        }
lbl_194:
        l_171 = l_170;
        l_193 = ((((((float)(l_166.f5 <= 0x1.74F6A4p+6) + (float)((float)(((p_59.f4 > __builtin_clz(((uint16_t)((l_166.f7 | ((uint16_t)((uint16_t)((int16_t)(l_157.f2 >= (((uint16_t)(-(uint16_t)0x1807) - (uint16_t)((((uint32_t)((int16_t)(((p_58.f3 != ((int16_t)0xCFE1 * (int16_t)p_59.f2)) < l_166.f5) != 4294967295U) >> (int16_t)l_171.f0) % (uint32_t)l_170.f0) || p_58.f1) < l_166.f5)) != l_157.f1)) >> (int16_t)12) << (uint16_t)l_157.f1) + (uint16_t)0x4B17)) < p_60) << (uint16_t)l_169))) < (-0x10.0p+1)) <= 0x1.0p-1) + (float)0xB.CBF6C0p-33)) == p_59.f2) < 0x3.01F525p-33) != p_59.f0) >= l_171.f0);
        if (l_155)
            goto lbl_194;
    }
    return l_157.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_62(uint16_t  p_63, uint32_t  p_64, int16_t  p_65)
{ /* block id: 38 */
    int16_t l_74 = 0x2B46;
    struct S2 l_75 = {-7,-3,4294967295U,0,-1,0x91A4AC15};
    int16_t l_82 = 0x743E;
    l_74 = p_64;
    l_75 = l_75;
    if (((uint16_t)(!func_79((p_64 != l_82), func_83(func_88(((l_75.f2 && (((int16_t)(p_63 ^ l_75.f4) % (int16_t)((uint16_t)((l_74 > ((0x0CFA8270 <= ((uint16_t)(((~p_63) == ((uint16_t)p_64 - (uint16_t)0x5FD7)) <= l_75.f5) << (uint16_t)l_74)) <= 1U)) >= 0x0EDEAE2A) << (uint16_t)6)) | l_75.f0)) != l_82)), p_64, l_74, l_75))) >> (uint16_t)11))
    { /* block id: 96 */
        struct S2 l_150 = {0,0,0xFC347C86,-1,0x846AC962,0xC7585655};
        l_150 = func_88(((int16_t)(((~((((int16_t)(((int16_t)__builtin_ffsll(l_82) << (int16_t)3) <= func_79(((!l_74) == p_64), func_83(l_150, p_64, l_150.f3, l_150))) * (int16_t)p_64) <= l_75.f5) | l_75.f2)) >= 0) < 0xE57E6B11) >> (int16_t)4));
    }
    else
    { /* block id: 98 */
        int32_t l_151 = 0x00B84BF0;
        l_151 = 0x953962AE;
    }
    return l_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_79(float  p_80, struct S1  p_81)
{ /* block id: 90 */
    struct S2 l_132 = {-7,0xE0FD2558,4U,0xCD93,0x51DFD2E6,-4};
    struct S0 l_141 = {4294967295U,0x0.0p+1};
    l_132 = func_88(p_81.f0);
    p_80 = ((float)((float)0x0.801A4Ep+22 + (float)((((l_132.f2 < 0xB.FBC4F1p-53) != ((((float)p_81.f1 + (float)p_81.f7) < __builtin_clz(p_81.f2)) == ((float)p_81.f7 * (float)p_81.f0))) != p_81.f4) > p_81.f6)) - (float)p_81.f7);
    l_141 = l_141;
    p_81.f4 = 0xA64CE0CA;
    return l_132.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_83(struct S2  p_84, uint32_t  p_85, uint32_t  p_86, struct S2  p_87)
{ /* block id: 86 */
    int32_t l_130 = 0x8792F598;
    struct S1 l_131 = {0,0xB0E0A5FE,0xC0FC352B,0xFD28,2,234,0x4.9p+1,4294967287U,0x9.CB1BBBp+73};
    p_87.f1 = 0x128C81A4;
    p_84.f1 = l_130;
    return l_131;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S2  func_88(uint32_t  p_89)
{ /* block id: 41 */
    uint16_t l_101 = 0U;
    struct S2 l_105 = {0xB7D9658A,0x494CAA1C,0x4AC225C5,6,-1,1};
    struct S0 l_111 = {0x570BAEA4,0x3.7A07EEp-2};
    int32_t l_116 = 2;
lbl_129:
    for (p_89 = 22; (p_89 <= 18); --p_89)
    { /* block id: 44 */
        uint16_t l_102 = 0x264E;
        l_102 = l_101;
        for (l_101 = 0; (l_101 > 54); ++l_101)
        { /* block id: 48 */
            int32_t l_108 = 0xECB25977;
            l_105 = l_105;
            l_105.f1 = ((int32_t)(p_89 != p_89) + (int32_t)(p_89 || (l_108 > ((p_89 <= l_102) < p_89))));
        }
    }
    for (l_105.f1 = 0; (l_105.f1 < (-13)); --l_105.f1)
    { /* block id: 55 */
        uint32_t l_115 = 0x73F556C0;
        int32_t l_117 = 0x65848584;
        if (p_89)
        { /* block id: 56 */
            return l_105;
        }
        else
        { /* block id: 58 */
            struct S0 l_112 = {0x9D60F7E9,0x9.A868CEp+72};
            int32_t l_118 = 1;
            l_112 = l_111;
            l_116 = ((p_89 & p_89) == ((uint16_t)((p_89 | 0x1928) >= (l_115 <= p_89)) >> (uint16_t)10));
            l_117 = p_89;
            l_118 = p_89;
        }
        l_116 = (0x010A815A | p_89);
        l_117 = l_115;
        if (p_89)
        { /* block id: 66 */
            uint16_t l_119 = 0xEB6C;
            int32_t l_120 = (-4);
            struct S2 l_121 = {-1,-7,0U,0x58CD,0x4028A08A,0x5D01A8FC};
            l_120 = (l_119 >= l_119);
            if (l_101)
                break;
            l_121 = l_121;
        }
        else
        { /* block id: 70 */
            float l_124 = 0x3.6699B5p+76;
            for (l_105.f4 = 24; (l_105.f4 < 14); l_105.f4 -= 5)
            { /* block id: 73 */
                l_116 = ((-0x6.7p+1) <= ((l_105.f1 > l_124) >= (!(__builtin_popcountl((!p_89)) == (0x0.8p-1 <= 0x8.5F5104p-94)))));
            }
            if (l_115)
                continue;
            for (l_105.f5 = 0; (l_105.f5 >= 3); l_105.f5 += 8)
            { /* block id: 79 */
                if (p_89)
                    break;
                if (l_105.f3)
                    goto lbl_129;
            }
        }
    }
    return l_105;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 65
   depth: 1, occurrence: 49
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 9
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 9

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 141
   depth: 2, occurrence: 20
   depth: 4, occurrence: 3
   depth: 7, occurrence: 4
   depth: 11, occurrence: 1
   depth: 12, occurrence: 4
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 5
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 24, occurrence: 3
   depth: 27, occurrence: 1
   depth: 29, occurrence: 2
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 513
XXX times a non-volatile is write: 85
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 125
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 26
   depth: 2, occurrence: 23
   depth: 3, occurrence: 13
   depth: 4, occurrence: 18
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

