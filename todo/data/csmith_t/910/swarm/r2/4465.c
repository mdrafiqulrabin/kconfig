/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      648907326
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   uint32_t  f1;
   const uint16_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
static int32_t  func_2(uint32_t  p_3, int32_t  p_4, const int32_t  p_5, int32_t  p_6);
static int32_t * func_10(int32_t  p_11);
static const uint16_t  func_15(union U0  p_16, int32_t * p_17, uint32_t  p_18, uint16_t  p_19, uint32_t  p_20);
inline static int16_t  func_25(int32_t  p_26, int32_t * p_27, const uint16_t  p_28, union U0  p_29);
static const uint16_t  func_30(int32_t * const  p_31, union U0  p_32, int32_t * p_33, int16_t  p_34, int32_t * p_35);
inline static int32_t * const  func_36(int32_t * p_37, int32_t * p_38);
inline static int32_t * func_39(int32_t  p_40, int16_t  p_41);
static uint16_t  func_48(const int32_t * p_49, int16_t  p_50, int16_t  p_51, int32_t  p_52, uint32_t  p_53);
inline static const int16_t  func_54(uint32_t  p_55);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_7 = 0x11738AB6;
    union U0 l_379 = {0x3C3130D0};
    union U0 *l_378 = &l_379;
    union U0 * const *l_377 = &l_378;
    int32_t *l_382 = (void*)0;
    int32_t **l_394 = &l_382;
    int32_t ***l_393 = &l_394;
    int32_t l_414 = 0x2C762218;
    int32_t *l_413 = &l_414;
    int32_t l_528 = 0x6EFA3A97;
    int16_t l_574 = (-1);
    int32_t **l_597 = (void*)0;
    uint16_t l_598 = 7U;
    if (func_2(l_7, l_7, (((int16_t)l_7 + (int16_t)0x48C4) && l_7), l_7))
    { /* block id: 151 */
        union U0 ***l_380 = (void*)0;
        union U0 * const *l_381 = (void*)0;
        l_381 = l_377;
    }
    else
    { /* block id: 153 */
        int32_t **l_383 = &l_382;
        uint32_t l_404 = 0U;
        int32_t l_407 = 2;
        union U0 *l_432 = &l_379;
        const union U0 * const l_442 = (void*)0;
        const union U0 * const *l_441 = &l_442;
        const union U0 * const **l_440 = &l_441;
        const int32_t *l_460 = &l_414;
        int32_t l_484 = 0x0B07067D;
        union U0 **l_527 = &l_378;
        union U0 ***l_526 = &l_527;
        union U0 ****l_525 = &l_526;
        union U0 *****l_524 = &l_525;
        int32_t l_530 = (-2);
        int32_t l_539 = 0xE39800B0;
        uint32_t l_576 = 0xE5D6FAA0;
        int16_t l_578 = 0xD601;
        (*l_383) = l_382;
        for (l_379.f1 = (-27); (l_379.f1 <= 42); l_379.f1 += 1)
        { /* block id: 157 */
            int16_t l_392 = 1;
            int32_t ***l_397 = &l_383;
            union U0 **l_401 = &l_378;
            union U0 *** const l_400 = &l_401;
            int32_t l_406 = 0x225A0D35;
            int32_t *l_405 = &l_406;
            (*l_405) = ((int16_t)(((uint16_t)((uint16_t)l_392 >> (uint16_t)((((void*)0 != l_393) | ((((uint16_t)(((void*)0 == l_397) > ((int16_t)(&l_377 == l_400) << (int16_t)8)) << (uint16_t)((int32_t)(l_404 | l_404) + (int32_t)0x572A71F9)) && l_404) || l_392)) < l_392)) << (uint16_t)l_404) ^ l_392) * (int16_t)(-1));
        }
        l_407 = l_379.f1;
        for (l_379.f0 = 0; (l_379.f0 >= (-17)); l_379.f0 -= 2)
        { /* block id: 163 */
            union U0 *l_412 = &l_379;
            int32_t l_417 = 6;
            uint16_t l_457 = 6U;
            int32_t ***l_529 = &l_383;
            int32_t l_544 = 0xCA8B9AF0;
            int32_t l_575 = (-3);
            int16_t l_577 = 6;
            const int32_t *l_579 = &l_544;
        }
    }
    (*l_413) = (((*l_413) <= (((-7) | (*l_413)) == ((uint16_t)(*l_413) - (uint16_t)(((int16_t)(*l_413) * (int16_t)(*l_413)) >= ((*l_393) == l_597))))) < (*l_413));
    return l_598;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_2(uint32_t  p_3, int32_t  p_4, const int32_t  p_5, int32_t  p_6)
{ /* block id: 1 */
    union U0 l_21 = {1};
    int32_t l_23 = 0xE7631615;
    int32_t *l_22 = &l_23;
    union U0 l_298 = {0x0503888E};
    union U0 *l_363 = &l_21;
    union U0 **l_362 = &l_363;
    union U0 ****l_369 = (void*)0;
    union U0 *****l_368 = &l_369;
    l_22 = func_10(((int16_t)(!func_15(l_21, l_22, (!func_25(p_6, &l_23, func_30(func_36(&l_23, func_39(((int16_t)((uint32_t)((int16_t)(*l_22) * (int16_t)(p_5 == func_48(&l_23, p_6, p_3, p_3, (*l_22)))) - (uint32_t)(*l_22)) - (int16_t)1U), p_3)), l_21, &l_23, (*l_22), &l_23), l_298)), p_5, p_5)) << (int16_t)5));
    if ((((int16_t)(-(int32_t)p_4) + (int16_t)p_4) && ((-6) && ((int16_t)(p_4 != 65534U) << (int16_t)14))))
    { /* block id: 143 */
        union U0 *l_357 = &l_298;
        union U0 **l_356 = &l_357;
        int32_t l_370 = (-5);
        int32_t **l_371 = &l_22;
        int16_t l_376 = 0;
        l_370 = ((int16_t)(1 >= (((int16_t)((uint16_t)(((uint32_t)(l_356 != (void*)0) / (uint32_t)p_3) != ((uint32_t)((((uint32_t)(l_362 == &l_357) + (uint32_t)0x224BADE5) || ((int32_t)(((((-1) == (l_368 == &l_369)) != 0x4C4CC263) & 1) & 0) + (int32_t)p_6)) && l_298.f0) + (uint32_t)p_5)) << (uint16_t)8) << (int16_t)p_3) > 0xD468)) * (int16_t)p_4);
        (*l_371) = &p_6;
        (*l_22) = ((int32_t)(p_6 == (l_376 < (**l_371))) + (int32_t)((void*)0 == &l_356));
    }
    else
    { /* block id: 147 */
        return p_3;
    }
    return p_6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_10(int32_t  p_11)
{ /* block id: 138 */
    int16_t l_321 = 9;
    int16_t l_325 = 1;
    int32_t l_335 = 0x8B215061;
    int32_t l_337 = (-10);
    int32_t *l_336 = &l_337;
    int32_t **l_338 = &l_336;
    int32_t *l_339 = &l_337;
    int32_t *l_340 = &l_337;
    int32_t *l_341 = &l_337;
    int32_t *l_342 = (void*)0;
    (*l_336) = ((int16_t)(0x72B1 ^ ((uint32_t)(p_11 == l_321) * (uint32_t)(!(((((int16_t)l_321 * (int16_t)l_325) != ((int16_t)((&p_11 == (void*)0) || ((uint16_t)((uint16_t)(!((int16_t)(((((l_335 >= p_11) == 0xCFF2) ^ p_11) | 0x1DECC0E9) >= 8) << (int16_t)l_325)) * (uint16_t)0xFD27) << (uint16_t)p_11)) << (int16_t)p_11)) && 0x74CAEB8A) && 0xAA07DD77)))) + (int16_t)l_335);
    (*l_338) = func_36(&l_337, func_39(p_11, (*l_336)));
    return l_342;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_15(union U0  p_16, int32_t * p_17, uint32_t  p_18, uint16_t  p_19, uint32_t  p_20)
{ /* block id: 135 */
    union U0 l_315 = {0x248997D2};
    union U0 *l_314 = &l_315;
    union U0 **l_313 = &l_314;
    union U0 ***l_312 = &l_313;
    int32_t l_316 = 1;
    l_316 = (l_312 == &l_313);
    return l_315.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_25(int32_t  p_26, int32_t * p_27, const uint16_t  p_28, union U0  p_29)
{ /* block id: 132 */
    int32_t l_301 = 0xD2D848F5;
    int32_t *l_300 = &l_301;
    int32_t **l_299 = &l_300;
    union U0 *****l_310 = (void*)0;
    int32_t l_311 = 0;
    (**l_299) = (((4294967288U != (l_299 != (void*)0)) < (((((uint16_t)(((uint16_t)(*l_300) >> (uint16_t)((uint32_t)(0xA7FC ^ ((uint16_t)(0xFADCD0BB && (l_310 != l_310)) - (uint16_t)(0x43430D16 != (-8)))) - (uint32_t)1)) < 0) >> (uint16_t)l_311) & (*l_300)) && (*l_300)) >= p_28)) == 0);
    return p_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_30(int32_t * const  p_31, union U0  p_32, int32_t * p_33, int16_t  p_34, int32_t * p_35)
{ /* block id: 99 */
    int32_t l_238 = 0xCAFECB23;
    int32_t *l_237 = &l_238;
    uint32_t l_275 = 0x4AE36154;
    union U0 l_291 = {0};
    union U0 *l_290 = &l_291;
    union U0 **l_289 = &l_290;
    union U0 ***l_288 = &l_289;
    union U0 ****l_287 = &l_288;
    union U0 *****l_286 = &l_287;
    int32_t **l_296 = (void*)0;
    const int32_t l_297 = 7;
    if (((int16_t)((p_32.f2 != (((((l_237 != p_33) < ((((-1) < ((*l_237) > (65530U && ((void*)0 == &p_31)))) < (*l_237)) > p_32.f0)) ^ 0x769F214E) || (*l_237)) ^ (*p_33))) != p_32.f0) + (int16_t)(*l_237)))
    { /* block id: 100 */
        union U0 l_244 = {0xC39FD4B7};
        union U0 *l_243 = &l_244;
        union U0 **l_242 = &l_243;
        union U0 ***l_241 = &l_242;
        union U0 ****l_245 = &l_241;
        (*l_245) = l_241;
        for (p_32.f1 = 0; (p_32.f1 <= 55); p_32.f1 += 2)
        { /* block id: 104 */
            int32_t *l_254 = &l_238;
            for (l_238 = (-6); (l_238 <= 1); ++l_238)
            { /* block id: 107 */
                int32_t **l_250 = (void*)0;
                int32_t **l_251 = &l_237;
                (*l_251) = (void*)0;
                if (l_244.f2)
                    break;
            }
            (*p_35) = ((int16_t)(0 ^ (0x6FFE && 0x5E1E)) >> (int16_t)14);
            p_35 = l_254;
        }
        return l_244.f1;
    }
    else
    { /* block id: 115 */
        int32_t *l_255 = &l_238;
        l_237 = l_255;
    }
    for (p_32.f1 = 0; (p_32.f1 < 12); p_32.f1 += 4)
    { /* block id: 120 */
        union U0 ***l_269 = (void*)0;
        union U0 ****l_268 = &l_269;
        int32_t l_274 = 0xC49979F6;
        (*l_237) = (((p_34 == ((uint16_t)p_32.f2 >> (uint16_t)11)) || (((((uint16_t)(((int16_t)(((int16_t)((int32_t)((void*)0 != l_268) / (int32_t)(*p_35)) % (int16_t)1) || ((uint32_t)((*l_237) >= ((((((int32_t)((void*)0 != p_31) - (int32_t)(*l_237)) != l_274) && (*l_237)) || (*l_237)) & (*p_33))) - (uint32_t)p_32.f1)) + (int16_t)p_32.f2) < l_274) * (uint16_t)p_34) & l_275) != (*l_237)) == 0x7CE5)) != (*l_237));
        if ((*l_237))
            break;
        for (l_274 = (-10); (l_274 >= (-30)); l_274 -= 1)
        { /* block id: 125 */
            union U0 l_283 = {0xA65F4457};
            const union U0 *l_282 = &l_283;
            const union U0 **l_281 = &l_282;
            const union U0 ***l_280 = &l_281;
            const union U0 ****l_279 = &l_280;
            const union U0 *****l_278 = &l_279;
            l_278 = l_278;
        }
    }
    (*l_237) = 0xD249FA4D;
    p_33 = func_39(((uint32_t)((((*l_237) <= (l_286 != &l_287)) >= p_32.f2) & ((int16_t)p_34 * (int16_t)((int16_t)((((0x999F != ((**l_288) == (****l_286))) ^ (*l_237)) < p_32.f0) & (*l_237)) - (int16_t)(*l_237)))) - (uint32_t)0x78246A17), p_32.f2);
    return l_297;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_36(int32_t * p_37, int32_t * p_38)
{ /* block id: 11 */
    const uint32_t l_71 = 0x2A48B755;
    int32_t l_75 = 0xEF5427E5;
    int32_t *l_74 = &l_75;
    union U0 l_97 = {-2};
    union U0 *l_96 = &l_97;
    int32_t **l_106 = &l_74;
    int32_t ***l_105 = &l_106;
    int32_t l_111 = 0x42BEBA84;
    const union U0 *l_183 = (void*)0;
    const union U0 **l_182 = &l_183;
    const union U0 ***l_181 = &l_182;
    uint32_t l_190 = 1U;
    uint16_t l_194 = 8U;
    int32_t *l_234 = &l_111;
    if ((l_71 & ((int16_t)l_71 + (int16_t)(l_71 && (l_74 == (void*)0)))))
    { /* block id: 12 */
        union U0 l_81 = {1};
        union U0 *l_80 = &l_81;
        union U0 *l_95 = &l_81;
        int32_t l_101 = (-1);
        uint16_t l_170 = 0xC6A6;
        for (l_75 = (-7); (l_75 < (-5)); l_75 += 1)
        { /* block id: 15 */
            int32_t **l_78 = &l_74;
            union U0 **l_91 = &l_80;
            if ((&l_75 == p_38))
            { /* block id: 16 */
                int32_t ***l_79 = &l_78;
                (*l_79) = l_78;
            }
            else
            { /* block id: 18 */
                const union U0 *l_83 = (void*)0;
                const union U0 **l_82 = &l_83;
                (*l_82) = l_80;
                (*l_82) = (*l_82);
            }
            for (l_81.f1 = 1; (l_81.f1 != 57); l_81.f1 += 7)
            { /* block id: 24 */
                uint32_t l_94 = 0xBFB9E2BF;
                int32_t **l_104 = &l_74;
                const int32_t l_140 = 0x191A0FB3;
                l_101 = ((!((((uint16_t)((uint32_t)(((void*)0 != p_37) & ((void*)0 != l_91)) + (uint32_t)(0xC9D536C3 ^ ((int16_t)((l_94 || (l_95 == l_96)) == ((uint16_t)(-(uint16_t)l_94) >> (uint16_t)l_94)) << (int16_t)14))) / (uint16_t)5) == (*p_37)) <= (**l_78))) && (-7));
            }
        }
        l_181 = (void*)0;
        (**l_105) = (**l_105);
    }
    else
    { /* block id: 78 */
        const union U0 l_189 = {0x2D90C287};
        const union U0 *l_188 = &l_189;
        int32_t *l_196 = (void*)0;
        int32_t *l_197 = (void*)0;
        int32_t *l_198 = &l_111;
        for (l_97.f0 = 21; (l_97.f0 > 18); l_97.f0 -= 2)
        { /* block id: 81 */
            int32_t *l_186 = (void*)0;
            int32_t l_187 = 0xF385F194;
            (*l_106) = l_186;
            (*l_105) = &p_37;
            (**l_105) = p_37;
            if (l_187)
                continue;
        }
        l_188 = (**l_181);
        (*l_198) = ((((l_190 > l_189.f0) ^ (+((uint16_t)((&l_182 == &l_182) == (l_194 ^ ((*l_105) == (*l_105)))) % (uint16_t)(+l_189.f1)))) <= (l_189.f1 >= l_189.f2)) ^ l_97.f2);
        for (l_97.f0 = 0; (l_97.f0 != 24); l_97.f0 += 3)
        { /* block id: 91 */
            int32_t l_201 = 0x79D41D14;
            union U0 *l_231 = &l_97;
            int16_t l_232 = 2;
            int32_t l_233 = 0x6FC2D246;
            l_233 = ((l_201 > ((~(((+(((((uint16_t)(((int16_t)((uint16_t)((int32_t)(l_201 || ((uint16_t)((int16_t)((((((uint16_t)(l_201 < l_201) * (uint16_t)((int32_t)(~(((uint16_t)((!0xBB99) >= l_201) * (uint16_t)(((int16_t)((int16_t)(((int16_t)l_201 << (int16_t)7) || (!l_201)) << (int16_t)6) >> (int16_t)(l_231 == (void*)0)) & l_201)) & l_201)) / (int32_t)0x28EBAD2A)) < l_232) != l_232) && (*l_198)) & (-4)) * (int16_t)l_194) - (uint16_t)l_232)) + (int32_t)l_232) >> (uint16_t)l_201) >> (int16_t)l_201) != 0xDDACD7A2) % (uint16_t)l_201) && 0x5CC310F3) | 0xE9454B42) >= (*l_198))) > l_201) > (*l_198))) != 0xFF2D)) & l_232);
            return p_37;
        }
    }
    (**l_105) = p_37;
    l_234 = (*l_106);
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_39(int32_t  p_40, int16_t  p_41)
{ /* block id: 8 */
    uint32_t l_59 = 1U;
    int32_t *l_60 = (void*)0;
    int32_t l_62 = 2;
    int32_t *l_61 = &l_62;
    int32_t *l_63 = &l_62;
    int32_t *l_64 = &l_62;
    int32_t *l_65 = &l_62;
    int32_t *l_66 = &l_62;
    int32_t *l_67 = &l_62;
    int32_t *l_68 = &l_62;
    int32_t *l_69 = &l_62;
    int32_t *l_70 = (void*)0;
    (*l_61) = l_59;
    return l_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(const int32_t * p_49, int16_t  p_50, int16_t  p_51, int32_t  p_52, uint32_t  p_53)
{ /* block id: 2 */
    uint32_t l_58 = 0x291260E2;
    l_58 = (p_52 == func_54(p_51));
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_54(uint32_t  p_55)
{ /* block id: 3 */
    int32_t l_57 = 0x59CDE30E;
    int32_t *l_56 = &l_57;
    l_56 = l_56;
    return p_55;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 129
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 15, occurrence: 3
   depth: 17, occurrence: 2
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 135

XXX times a variable address is taken: 137
XXX times a pointer is dereferenced on RHS: 107
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 24
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 56
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 8
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 417

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 191
   level: 2, occurrence: 128
   level: 3, occurrence: 77
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 69
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.25

XXX times a non-volatile is read: 583
XXX times a non-volatile is write: 169
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 70
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 23
   depth: 2, occurrence: 13
   depth: 3, occurrence: 6

XXX percentage a fresh-made variable is used: 18.4
XXX percentage an existing variable is used: 81.6
********************* end of statistics **********************/

