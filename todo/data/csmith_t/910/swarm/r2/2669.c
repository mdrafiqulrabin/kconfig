/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3978718920
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 18;
   const unsigned f1 : 31;
   unsigned f2 : 5;
};

/* --- GLOBAL VARIABLES --- */
static const int32_t g_5 = (-5L);
static struct S0 g_48 = {215,14363,3};
static int32_t g_124 = (-9L);
static int32_t g_141 = 0x198232C3L;
static uint32_t g_179 = 0UL;
static int16_t g_184 = 0xEB04L;
static float g_222 = 0x5.0F77C6p-78;
static int32_t g_318 = 1L;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_27(void);
inline static float  func_31(int32_t  p_32, int16_t  p_33, uint32_t  p_34, int16_t  p_35);
static uint64_t  func_39(int16_t  p_40, int32_t  p_41, uint64_t  p_42, int16_t  p_43, int32_t  p_44);
inline static int32_t  func_46(struct S0  p_47);
inline static uint32_t  func_50(uint16_t  p_51, struct S0  p_52, struct S0  p_53);
inline static int32_t  func_55(struct S0  p_56, float  p_57, int64_t  p_58, int32_t  p_59);
inline static float  func_69(int16_t  p_70, uint32_t  p_71);
inline static int32_t  func_72(float  p_73, uint64_t  p_74);
static float  func_91(uint64_t  p_92, struct S0  p_93, int32_t  p_94);
inline static float  func_97(int32_t  p_98, int32_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_48 g_124 g_141 g_184 g_179
 * writes: g_124 g_141 g_48.f0 g_179 g_184 g_222 g_318
 */
static int32_t  func_27(void)
{ /* block id: 36 */
    uint32_t l_30 = 4294967295UL;
    int32_t l_45 = 0xBBD4856CL;
    g_318 = ((float)(0x0.Ep+1 >= l_30) - (float)func_31((((uint64_t)(-(uint16_t)5UL) + (uint64_t)func_39(l_45, g_5, g_5, l_30, l_45)) >= g_5), l_45, g_48.f1, l_30));
    return g_184;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f1 g_48.f2 g_48 g_5 g_124 g_141
 * writes: g_124 g_141 g_48.f0
 */
inline static float  func_31(int32_t  p_32, int16_t  p_33, uint32_t  p_34, int16_t  p_35)
{ /* block id: 158 */
    struct S0 l_313 = {-39,45642,2};
    uint16_t l_316 = 65535UL;
    int32_t l_317 = 0x4BBDFA2EL;
    l_313.f0 = ((g_48.f1 , (l_313 , ((g_48.f2 <= p_32) <= ((((((int32_t)func_46(g_48) / (int32_t)l_313.f0) , (((p_32 , (l_313.f2 && l_316)) <= g_48.f0) <= l_313.f1)) ^ l_317) > 0x6D16L) , g_5)))) , l_313.f0);
    l_313.f0 = 0x7.D1A99Ep+82;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_5 g_124 g_141 g_184 g_179
 * writes: g_124 g_141 g_48.f0 g_179 g_184 g_222
 */
static uint64_t  func_39(int16_t  p_40, int32_t  p_41, uint64_t  p_42, int16_t  p_43, int32_t  p_44)
{ /* block id: 37 */
    int32_t l_175 = 5L;
    struct S0 l_226 = {367,35713,3};
    int16_t l_246 = (-2L);
    uint64_t l_302 = 9UL;
    if (func_46(g_48))
    { /* block id: 90 */
        const int32_t l_173 = (-1L);
        int32_t l_174 = 6L;
        l_174 = (l_173 != g_48.f2);
        l_175 = g_48.f2;
    }
    else
    { /* block id: 93 */
        uint32_t l_178 = 0x938C4D50L;
        int64_t l_201 = 0xB2E64DF4010864EBLL;
        struct S0 l_208 = {95,10417,1};
        float l_229 = 0x6.0p-1;
        int32_t l_293 = 0x760C7681L;
        uint16_t l_301 = 0x3F61L;
        uint16_t l_308 = 65532UL;
lbl_266:
        g_179 = (((float)l_175 / (float)l_178) < __builtin_bswap64(g_48.f0));
        if ((l_178 < 8L))
        { /* block id: 95 */
            struct S0 l_183 = {28,15226,3};
            g_184 = (-(float)(0xB.A045A3p-44 <= ((float)p_41 / (float)(((l_175 , l_175) != func_50(g_48.f1, g_48, l_183)) == __builtin_parityl(g_48.f1)))));
lbl_223:
            for (p_44 = 4; (p_44 < 21); p_44 += 4)
            { /* block id: 99 */
                int32_t l_202 = (-1L);
                int16_t l_216 = 1L;
                struct S0 l_221 = {-400,21115,2};
                if (((int16_t)(((uint16_t)((uint64_t)((int64_t)(((int16_t)((0xAE58DA50500D59F5LL == ((((uint16_t)((((p_43 <= func_50(l_183.f0, g_48, g_48)) || ((((int16_t)9L >> (int16_t)((p_40 , 0x54A21752L) , l_178)) ^ p_44) ^ g_124)) != l_201) || g_48.f1) >> (uint16_t)l_178) , p_44) , g_48.f2)) & g_184) >> (int16_t)9) && l_202) % (int64_t)0x86E5B775008D736BLL) % (uint64_t)l_183.f0) + (uint16_t)l_183.f1) == l_202) + (int16_t)0UL))
                { /* block id: 100 */
                    const int16_t l_211 = 8L;
                    uint32_t l_212 = 0x7C46033EL;
                    int32_t l_217 = 0x407B9BD9L;
                    l_208.f0 = (((uint16_t)(-(uint32_t)(g_48 , l_183.f2)) >> (uint16_t)((uint64_t)func_55(l_208, g_48.f0, (((uint16_t)(((5UL & (((1UL < l_202) < (0x7AEAL & (0xD69DEFF5L | g_48.f1))) < p_40)) < l_211) ^ p_44) << (uint16_t)6) != l_202), l_212) % (uint64_t)0xBABF467C7D0B8D76LL)) > l_183.f2);
                    for (g_124 = 0; (g_124 != 26); g_124 += 1)
                    { /* block id: 104 */
                        return g_141;
                    }
                    if (l_201)
                    { /* block id: 107 */
                        l_216 = (-(float)l_175);
                        l_217 = 0x4448CB30L;
                        return p_43;
                    }
                    else
                    { /* block id: 111 */
                        return p_41;
                    }
                }
                else
                { /* block id: 114 */
                    if (g_48.f2)
                        break;
                    if (l_208.f2)
                        break;
                    l_183.f0 = g_48.f2;
                }
                if (l_208.f2)
                    goto lbl_223;
                g_48.f0 = (~((int16_t)1L - (int16_t)(g_184 < p_42)));
                g_222 = (((g_141 <= (((p_44 , l_221) , p_44) > l_183.f2)) != l_183.f2) >= ((0xC.DE0336p+89 <= (((((g_124 != ((0x0.Ap+1 <= g_48.f0) <= (-0x7.0p-1))) > 0xB.C5F5F0p+93) <= (-0x1.Cp-1)) <= 0x0.2p+1) > p_43)) != 0x0.331396p-50));
            }
            l_183.f0 = (((float)(func_55(l_183, (l_175 != (g_48 , (__builtin_ffs(p_41) <= p_41))), ((g_141 , (func_55(l_226, ((__builtin_clz(((((((int16_t)p_40 >> (int16_t)g_124) < g_48.f2) | p_44) , l_183.f0) , g_141)) <= p_44) , 0x1.CDF2A6p+25), g_179, p_43) , l_183.f1)) , 0L), p_44) == p_41) + (float)g_184) > (-0x8.Ap+1));
        }
        else
        { /* block id: 124 */
            int16_t l_238 = 7L;
            struct S0 l_245 = {-5,44288,2};
            for (g_141 = (-10); (g_141 <= (-1)); g_141 += 1)
            { /* block id: 127 */
                uint64_t l_251 = 0xDCB01C2EB0A1AFBELL;
                const int32_t l_312 = 1L;
                if (((uint16_t)((((int16_t)((((l_208.f1 != (((uint16_t)(((func_72(l_238, p_44) | func_72((0xC.AAE363p+94 >= (g_124 == (((float)(((float)((float)(l_245 , (p_43 > (0x2.7p-1 >= 0x2.543485p-96))) / (float)l_201) / (float)p_40) <= l_208.f2) + (float)0x3.4p+1) , g_184))), l_226.f1)) & l_208.f1) ^ 0x3E919F614CAE8D20LL) + (uint16_t)g_48.f2) <= g_48.f0)) | 18446744073709551611UL) ^ 0x18198E80L) > 0UL) >> (int16_t)p_44) ^ g_48.f1) || 65526UL) >> (uint16_t)l_246))
                { /* block id: 128 */
                    uint32_t l_258 = 0xEB70EFD0L;
                    for (p_43 = 0; (p_43 < 25); p_43++)
                    { /* block id: 131 */
                        g_222 = (((-0x9.7p+1) != p_44) >= func_97(((int16_t)l_251 % (int16_t)(((int16_t)(__builtin_popcountll((__builtin_ffsl(((l_245.f0 > ((int16_t)p_42 >> (int16_t)l_175)) <= l_251)) , ((uint32_t)(l_258 < l_178) / (uint32_t)p_44))) | g_48.f0) << (int16_t)g_48.f0) && p_43)), p_41));
                        l_208.f0 = ((((-(int16_t)__builtin_bswap32((p_42 > 1UL))) | g_179) | ((int64_t)(p_42 , l_226.f1) / (int64_t)0x2D9BE9A1A12858ABLL)) || (__builtin_parity(func_72((((float)(func_97(g_48.f2, (g_179 , p_40)) <= 0x7.Dp-1) - (float)0x7.Bp+1) != l_226.f0), g_48.f0)) < p_42));
                        return g_48.f1;
                    }
                    for (l_178 = (-25); (l_178 <= 16); l_178 += 1)
                    { /* block id: 138 */
                        if (l_238)
                            goto lbl_266;
                    }
                }
                else
                { /* block id: 141 */
                    int64_t l_278 = 0L;
                    if ((((0L == ((__builtin_parityll((((0x32126A534EDE82F0LL == ((~g_48.f1) < g_141)) , g_48.f2) , ((uint16_t)(0x963307FDC0412EF5LL ^ (~g_5)) << (uint16_t)func_55(g_48, g_5, g_184, p_41)))) , l_208.f0) >= p_40)) || l_201) > l_238))
                    { /* block id: 142 */
                        l_226.f0 = l_245.f0;
                        l_278 = (l_251 , (!((int16_t)(l_226 , (l_251 ^ g_48.f0)) >> (int16_t)((uint16_t)0x9870L << (uint16_t)(((int16_t)((((p_41 && p_43) & 0x4F9FL) > ((0x47C4C677B6004B46LL | g_48.f2) == 1UL)) != 0x4FF01ADFF8256CFALL) << (int16_t)g_48.f2) >= g_184)))));
                        if (p_42)
                            continue;
                    }
                    else
                    { /* block id: 146 */
                        int64_t l_294 = 0x2A67AD8558D5EF94LL;
                        g_222 = (((float)g_179 - (float)g_48.f1) != ((((float)((float)((l_245.f0 , p_42) == ((float)(((g_48.f2 || p_43) , l_251) >= 0x6.42827Cp-58) + (float)((float)(((int64_t)(((int32_t)g_48.f2 + (int32_t)g_5) || p_42) / (int64_t)g_48.f1) , 0x7.C6AF29p-45) + (float)0x0.0p+1))) - (float)0xA.B31E70p+37) / (float)0x0.6p-1) >= 0x1.4p+1) != (-0x4.7p-1)));
                        if (l_293)
                            break;
                        g_48.f0 = func_55(l_208, l_294, ((int16_t)((((0x83EAFCF35AF17E0BLL && (g_184 , ((int16_t)((int16_t)((((0xF732D4BDL || (g_179 , g_141)) != func_55(l_208, l_301, l_251, l_251)) == l_245.f1) , 0x020AL) - (int16_t)0x4FA5L) / (int16_t)g_48.f0))) == l_302) , 1UL) && l_278) + (int16_t)g_179), g_48.f0);
                    }
                }
                g_48.f0 = (!func_72(((((0x1.1FD462p-58 == g_184) != ((__builtin_parityl(((int64_t)g_184 + (int64_t)(((((l_226.f1 >= l_308) | g_48.f1) , __builtin_bswap32(p_41)) != ((-(uint32_t)((((int16_t)(l_312 <= p_41) % (int16_t)(-1L)) >= l_251) , g_124)) != p_44)) >= g_5))) , 65535UL) , g_5)) >= 0xF.432B5Ep+86) == (-0x1.Fp-1)), l_308));
            }
        }
        l_226.f0 = 0x5.F3F152p+95;
    }
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f1 g_48.f0 g_5 g_48.f2 g_124 g_48 g_141
 * writes: g_124 g_141 g_48.f0
 */
inline static int32_t  func_46(struct S0  p_47)
{ /* block id: 38 */
    uint32_t l_49 = 9UL;
    struct S0 l_54 = {234,40889,2};
    uint16_t l_167 = 0x1C67L;
    uint16_t l_172 = 0x3B5EL;
    l_49 = (-5L);
    l_54.f0 = (p_47.f1 && func_50(p_47.f0, p_47, l_54));
    l_172 = (__builtin_ffsl(((p_47.f1 || l_49) , l_167)) || ((((p_47.f2 , p_47.f0) | (l_54.f2 & (((0xFCB1L == ((uint32_t)(((uint16_t)l_54.f0 - (uint16_t)g_124) > g_48.f2) / (uint32_t)g_141)) | 0x86F9DF61L) , g_5))) < l_54.f1) & 65535UL));
    return g_124;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f1 g_48.f0 g_5 g_48.f2 g_124 g_48 g_141
 * writes: g_124 g_141 g_48.f0
 */
inline static uint32_t  func_50(uint16_t  p_51, struct S0  p_52, struct S0  p_53)
{ /* block id: 40 */
    int32_t l_62 = (-2L);
    uint32_t l_163 = 0UL;
    l_163 = func_55(p_53, (g_48.f1 > (((float)(l_62 > g_48.f0) / (float)((float)(((-(float)0x8.3964E4p+90) < ((float)0x8.B108F9p-87 + (float)(!p_52.f1))) != func_69(l_62, (p_53.f2 >= (-1L)))) / (float)0x0.4p-1)) > 0x2.052D3Dp-59)), l_62, g_48.f1);
    g_48.f0 = ((-(uint16_t)g_141) || ((uint16_t)l_163 << (uint16_t)13));
    return g_141;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f2 g_48.f0 g_124 g_48.f1 g_5
 * writes:
 */
inline static int32_t  func_55(struct S0  p_56, float  p_57, int64_t  p_58, int32_t  p_59)
{ /* block id: 80 */
    int32_t l_151 = 0x8A64327DL;
    struct S0 l_159 = {142,28722,3};
    l_159.f0 = ((((l_151 == ((__builtin_bswap64(((p_56.f0 < ((float)((((int32_t)l_151 + (int32_t)(-1L)) , l_151) <= (p_56.f2 <= ((g_48.f2 == g_48.f0) == ((((!func_72(((float)((-0x1.1p+1) >= p_56.f2) - (float)g_124), g_48.f1)) , 0xA8E8ED7AL) , l_159) , 0x9.22A42Fp+1)))) - (float)p_58)) , p_56.f0)) > 0x1.Ep+1) == 0x0.Ap+1)) != 0x9.2p+1) > 0x7.7p+1) <= (-0x1.7p+1));
    l_159.f0 = ((int16_t)p_59 - (int16_t)((-(int32_t)func_72(l_159.f2, p_58)) > 0x0E7CL));
    return p_56.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f0 g_48.f1 g_5 g_48.f2 g_124 g_48 g_141
 * writes: g_124 g_141
 */
inline static float  func_69(int16_t  p_70, uint32_t  p_71)
{ /* block id: 41 */
    int32_t l_83 = 0x42EE1E3CL;
    int32_t l_123 = (-1L);
    struct S0 l_134 = {-407,7227,3};
    l_123 = __builtin_bswap64((func_72(((float)((float)__builtin_popcountll(g_48.f0) - (float)((float)(0x1.4C62B4p-81 == ((float)l_83 + (float)(((float)(-0x3.0p+1) + (float)__builtin_ctz(g_48.f1)) <= (__builtin_clzll(l_83) < l_83)))) + (float)l_83)) / (float)p_71), l_83) && g_48.f1));
    g_124 = (p_70 != p_70);
    for (g_124 = 14; (g_124 >= (-8)); g_124 -= 1)
    { /* block id: 65 */
        uint32_t l_129 = 4294967291UL;
        int32_t l_139 = 0xFC961BCEL;
        l_134.f0 = (((0xC.A650DEp+25 >= (-0x1.2p-1)) < 0xE.7AFBDFp+90) > ((__builtin_clz(((int32_t)l_129 % (int32_t)p_71)) < (((uint64_t)((int16_t)g_48.f0 >> (int16_t)(g_48.f1 < (((l_134 , l_129) >= g_48.f0) > l_129))) + (uint64_t)g_124) , p_70)) == (-0x1.Cp-1)));
        for (l_123 = 0; (l_123 == (-27)); l_123 -= 1)
        { /* block id: 69 */
            float l_140 = (-0x8.6p-1);
            int32_t l_148 = 1L;
            for (p_70 = 0; (p_70 == (-15)); p_70 -= 4)
            { /* block id: 72 */
                l_139 = p_70;
                g_141 = (-1L);
            }
            l_148 = ((int64_t)((int16_t)__builtin_clzll((((((g_48 , g_141) , 0UL) && ((uint64_t)(func_72(l_148, (l_134.f2 < ((uint32_t)(((func_72(g_141, p_71) || l_134.f1) , p_71) && 18446744073709551612UL) + (uint32_t)g_124))) , 0x4C0DA39397282F80LL) - (uint64_t)0x630802EBDDE1E780LL)) , p_71) , 0x75AEE60D347FA911LL)) / (int16_t)1UL) + (int64_t)p_71);
        }
    }
    return g_48.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f2 g_48.f1 g_5
 * writes:
 */
inline static int32_t  func_72(float  p_73, uint64_t  p_74)
{ /* block id: 42 */
    int16_t l_86 = 0x58B5L;
    struct S0 l_121 = {350,36022,4};
    l_121.f0 = (l_86 , ((float)(((0x0.3p+1 >= (0x7.21A0E5p-40 > ((float)func_91((g_48.f2 < (((float)(p_74 > func_97(l_86, ((int16_t)l_86 << (int16_t)g_48.f1))) - (float)p_74) , 0x916A7153L)), l_121, g_48.f1) + (float)l_121.f0))) != p_74) <= 0x4.99A862p+40) / (float)g_48.f1));
    return l_121.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_48.f1
 * writes:
 */
static float  func_91(uint64_t  p_92, struct S0  p_93, int32_t  p_94)
{ /* block id: 56 */
    uint16_t l_122 = 0x4541L;
    p_94 = __builtin_parity(l_122);
    return g_48.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_48.f1 g_48.f2 g_5
 * writes:
 */
inline static float  func_97(int32_t  p_98, int32_t  p_99)
{ /* block id: 43 */
    int64_t l_109 = (-1L);
    int32_t l_120 = 0x6445A0AEL;
    for (p_99 = (-23); (p_99 > 27); p_99 += 5)
    { /* block id: 46 */
        float l_112 = 0x0.D701FBp-26;
        for (p_98 = 6; (p_98 > 13); p_98 += 1)
        { /* block id: 49 */
            int32_t l_119 = 0x80F5C685L;
            l_119 = ((float)(!l_109) - (float)(((float)g_48.f1 / (float)(l_109 != (l_112 >= l_109))) == ((((int16_t)g_48.f1 << (int16_t)((int16_t)g_48.f2 << (int16_t)((g_48.f1 > ((18446744073709551609UL || l_109) && 0L)) || l_109))) , g_5) >= g_48.f1)));
        }
        l_120 = (0x6DE3L > 65529UL);
        l_120 = ((-0x1.Dp-1) > p_98);
    }
    return l_109;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_48.f0, "g_48.f0", print_hash_value);
    transparent_crc(g_48.f1, "g_48.f1", print_hash_value);
    transparent_crc(g_48.f2, "g_48.f2", print_hash_value);
    transparent_crc(g_124, "g_124", print_hash_value);
    transparent_crc(g_141, "g_141", print_hash_value);
    transparent_crc(g_179, "g_179", print_hash_value);
    transparent_crc(g_184, "g_184", print_hash_value);
    transparent_crc_bytes (&g_222, sizeof(g_222), "g_222", print_hash_value);
    transparent_crc(g_318, "g_318", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 57
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX full-bitfields structs in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 17
XXX times a single bitfield on RHS: 107

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 10, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 5
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 353
XXX times a non-volatile is write: 50
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 76
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 10
   depth: 2, occurrence: 7
   depth: 3, occurrence: 8
   depth: 4, occurrence: 9
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 17.6
XXX percentage an existing variable is used: 82.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

