/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3578714204
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   uint8_t  f3;
   uint32_t  f4;
   uint32_t  f5;
   int16_t  f6;
   uint16_t  f7;
   float  f8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_30(void);
static int32_t * func_34(uint8_t  p_35);
static int16_t  func_52(int16_t  p_53, int16_t  p_54, int32_t * p_55, uint16_t  p_56);
static uint32_t  func_69(int32_t  p_70, uint8_t  p_71);
static int32_t  func_72(struct S0  p_73, float  p_74, struct S0  p_75, int32_t  p_76, int32_t * p_77);
static int16_t  func_88(int32_t * p_89, int32_t * p_90, uint32_t  p_91, int16_t  p_92);
static int32_t * func_93(int32_t * p_94, float  p_95);
static int32_t * func_96(uint32_t  p_97, uint16_t  p_98, int32_t * p_99, float  p_100, int32_t * p_101);
static int32_t ** func_120(int32_t ** p_121, int32_t  p_122, int16_t  p_123, int32_t ** p_124);
static int32_t  func_130(struct S0  p_131);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 0L;
    for (l_31 = (-17); (l_31 <= (-4)); l_31 = safe_add_func_int16_t_s_s(l_31, 1))
    { /* block id: 39 */
        int32_t l_36 = (-1L);
        int32_t **l_668 = (void*)0;
        int32_t *l_670 = &l_31;
        int32_t **l_669 = &l_670;
        (*l_669) = func_34(l_36);
    }
    return l_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(uint8_t  p_35)
{ /* block id: 40 */
    struct S0 l_79 = {1L,4294967292UL,0x181CA8FDL,0xF3L,0x6434D12EL,5UL,0L,9UL,0xD.62DA72p-13};
    int32_t *l_338 = (void*)0;
    int32_t l_591 = 1L;
    int32_t *l_603 = &l_79.f0;
    int32_t *l_606 = (void*)0;
    int16_t l_610 = 0xCCFEL;
    struct S0 *l_619 = (void*)0;
    struct S0 **l_618 = &l_619;
    struct S0 ***l_617 = &l_618;
    struct S0 ****l_616 = &l_617;
    int32_t *l_651 = &l_591;
    int32_t *l_655 = &l_591;
    int32_t *l_657 = &l_79.f0;
    int32_t *l_659 = &l_79.f0;
    float **l_665 = (void*)0;
    float ***l_664 = &l_665;
    float ****l_663 = &l_664;
    float *****l_662 = &l_663;
    int32_t *l_666 = &l_79.f0;
    int32_t *l_667 = (void*)0;
    for (p_35 = (-20); (p_35 <= 48); p_35 = safe_add_func_int32_t_s_s(p_35, 1))
    { /* block id: 43 */
        int32_t l_39 = (-9L);
        struct S0 l_78 = {0x6F8A3E09L,0x13A3A1BBL,0xB817BB5CL,1UL,4294967288UL,0UL,0x97F6L,0x8CDEL,0x9.Bp-1};
        int32_t *l_599 = &l_591;
        int32_t *l_600 = &l_79.f0;
        int32_t *l_601 = &l_78.f0;
        int32_t *l_602 = &l_591;
        int32_t *l_604 = &l_39;
        int32_t *l_605 = &l_79.f0;
        for (l_39 = 0; (l_39 >= 9); l_39 = safe_add_func_uint16_t_u_u(l_39, 1))
        { /* block id: 46 */
            uint32_t l_62 = 0x43A64E78L;
            int32_t l_80 = 0x10AA4AECL;
            int32_t *l_81 = &l_79.f0;
            uint32_t l_590 = 0x3295B277L;
            int32_t *l_592 = &l_79.f0;
            if (((l_39 & ((0x3E80L ^ (safe_mod_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(((safe_add_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((+0xE857L), (65535UL > (safe_rshift_func_int16_t_s_u(func_52((safe_mod_func_int32_t_s_s((safe_unary_minus_func_int16_t_s((-1L))), (((((safe_add_func_uint16_t_u_u((l_62 >= (safe_add_func_int16_t_s_s(__builtin_clzll((safe_mod_func_int16_t_s_s(((__builtin_bswap32(l_62) || (safe_add_func_int32_t_s_s((func_69(func_72(l_78, p_35, l_79, l_80, l_81), p_35) <= p_35), l_79.f2))) < p_35), p_35))), 0x7845L))), p_35)) >= p_35) ^ p_35) || 0x6B73L) & p_35))), l_78.f6, l_338, l_78.f3), 11))))), l_79.f4)) == p_35))), 0x44DFL))) & p_35)) || p_35))
            { /* block id: 406 */
                int32_t *l_586 = &l_78.f0;
                int32_t **l_587 = &l_81;
                l_586 = func_93(l_586, (*l_81));
                if (p_35)
                    break;
                (*l_587) = &l_39;
                if ((*l_81))
                    break;
            }
            else
            { /* block id: 411 */
                int32_t **l_588 = (void*)0;
                int32_t **l_589 = &l_81;
                (*l_589) = &l_39;
            }
            l_590 = (-1L);
            (*l_592) = l_591;
            for (l_78.f0 = 0; (l_78.f0 > (-9)); l_78.f0 = safe_sub_func_int16_t_s_s(l_78.f0, 1))
            { /* block id: 418 */
                int32_t **l_598 = &l_81;
                for (l_591 = (-8); (l_591 > 20); l_591 = safe_add_func_int32_t_s_s(l_591, 7))
                { /* block id: 421 */
                    struct S0 *l_597 = &l_79;
                    (*l_597) = l_78;
                }
                (*l_598) = l_81;
            }
        }
        return l_606;
    }
    if (((((safe_unary_minus_func_uint16_t_u((safe_lshift_func_int16_t_s_s(func_52(l_610, func_130(l_79), &l_591, p_35), 4)))) == (0xC29BL | (*l_603))) == p_35) && (-1L)))
    { /* block id: 429 */
        int32_t *****l_615 = (void*)0;
        struct S0 ****l_620 = (void*)0;
        int32_t *l_623 = &l_591;
        int32_t *l_656 = &l_591;
        int32_t *l_658 = &l_591;
        int32_t *l_660 = &l_79.f0;
        int32_t *l_661 = (void*)0;
        if ((((-5L) < p_35) | (safe_sub_func_uint32_t_u_u((0L < (safe_add_func_int16_t_s_s(((l_615 != l_615) >= (*l_603)), 0x6EDDL))), (l_616 == l_620)))))
        { /* block id: 430 */
            struct S0 **l_621 = &l_619;
            int32_t *l_622 = &l_591;
            l_623 = func_96(((void*)0 == l_621), p_35, &l_591, p_35, l_622);
            l_622 = (void*)0;
        }
        else
        { /* block id: 433 */
            int32_t **l_624 = &l_606;
            int32_t ***l_629 = &l_624;
            int32_t *l_632 = (void*)0;
            struct S0 l_647 = {-1L,4294967295UL,0x8A5C4FDEL,0x7FL,4294967291UL,4294967291UL,-6L,0UL,0x7.Fp+1};
            struct S0 *l_648 = &l_79;
            (*l_629) = func_120(l_624, p_35, (65531UL <= p_35), &l_623);
            if (p_35)
            { /* block id: 435 */
                int32_t **l_630 = (void*)0;
                int32_t **l_631 = (void*)0;
                l_632 = &l_591;
            }
            else
            { /* block id: 437 */
                float l_643 = 0x0.3p+1;
                int32_t *l_645 = &l_591;
                int32_t **l_646 = &l_645;
                l_606 = &l_591;
                for (l_79.f2 = 0; (l_79.f2 >= 27); l_79.f2 = safe_add_func_uint16_t_u_u(l_79.f2, 1))
                { /* block id: 441 */
                    int32_t *l_638 = &l_591;
                    struct S0 l_639 = {1L,0x0BD93945L,0xE93672E4L,1UL,8UL,9UL,-8L,0x5BF6L,0x8.1EF28Ap-81};
                    int32_t **l_644 = &l_632;
                    for (l_591 = (-3); (l_591 < 18); l_591 = safe_add_func_uint32_t_u_u(l_591, 1))
                    { /* block id: 444 */
                        int32_t *l_637 = (void*)0;
                        struct S0 l_640 = {-1L,1UL,6UL,7UL,0x492B2E67L,0xD9D1D2E8L,0x35BAL,0xFCB6L,0x4.CEE27Bp-0};
                        float ***l_642 = (void*)0;
                        float ****l_641 = &l_642;
                        l_603 = l_638;
                        if (p_35)
                            break;
                        l_640 = l_639;
                        (*l_641) = (void*)0;
                    }
                    (*l_606) = 0x57680E54L;
                    (*l_644) = l_638;
                }
                (*l_646) = l_645;
            }
            (*l_648) = l_647;
            for (l_79.f7 = 3; (l_79.f7 > 36); l_79.f7 = safe_add_func_uint16_t_u_u(l_79.f7, 4))
            { /* block id: 458 */
                int32_t **l_652 = (void*)0;
                int32_t **l_653 = (void*)0;
                int32_t **l_654 = &l_651;
                (*l_654) = l_651;
            }
        }
        return l_661;
    }
    else
    { /* block id: 463 */
        l_662 = l_662;
    }
    return l_667;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_52(int16_t  p_53, int16_t  p_54, int32_t * p_55, uint16_t  p_56)
{ /* block id: 242 */
    struct S0 l_344 = {0x7EA915CFL,0xA51A2D85L,0x095A344AL,8UL,4294967286UL,0x6D435531L,0xF420L,0xDF62L,-0x8.Cp+1};
    struct S0 *l_343 = &l_344;
    struct S0 **l_342 = &l_343;
    struct S0 ***l_341 = &l_342;
    int32_t l_365 = 0x83981667L;
    int32_t **l_409 = (void*)0;
    int32_t ***l_408 = &l_409;
    struct S0 l_546 = {-6L,1UL,0xBD710D56L,8UL,0xA1C90C6EL,4294967290UL,0L,2UL,0x2.7p-1};
    if (((safe_sub_func_int32_t_s_s((l_341 == (void*)0), l_344.f5)) & (p_56 & ((p_54 != ((*l_342) == (void*)0)) > 65530UL))))
    { /* block id: 243 */
        int32_t *l_345 = &l_344.f0;
        int32_t **l_346 = (void*)0;
        struct S0 *l_349 = (void*)0;
        uint32_t l_366 = 5UL;
        struct S0 ****l_427 = &l_341;
        int32_t ****l_444 = &l_408;
        struct S0 *l_449 = (void*)0;
        uint32_t l_484 = 0x6B39C141L;
        int32_t **l_535 = &l_345;
        int32_t **l_539 = &l_345;
        float *l_566 = &l_344.f8;
        float **l_565 = &l_566;
        float ***l_564 = &l_565;
        float ****l_563 = &l_564;
        p_55 = l_345;
        for (l_344.f7 = 0; (l_344.f7 <= 32); l_344.f7 = safe_add_func_int32_t_s_s(l_344.f7, 7))
        { /* block id: 247 */
            p_55 = func_93(p_55, p_53);
            (**l_341) = (*l_342);
            if ((*l_345))
                continue;
            (*l_342) = l_349;
        }
lbl_488:
        for (p_56 = (-22); (p_56 <= 5); p_56 = safe_add_func_int16_t_s_s(p_56, 1))
        { /* block id: 255 */
            uint32_t l_362 = 5UL;
            struct S0 l_384 = {-3L,0xFF5056D0L,18446744073709551615UL,6UL,0UL,0xD2F14767L,0xC0F5L,65526UL,0x1.Fp+1};
            struct S0 ****l_428 = &l_341;
            float *l_435 = &l_344.f8;
            int32_t ****l_443 = &l_408;
        }
        if ((p_56 != (safe_add_func_uint32_t_u_u((*l_345), p_53))))
        { /* block id: 326 */
            int16_t l_465 = 0x0364L;
            struct S0 l_468 = {0x22BA4377L,0xC3B72B04L,18446744073709551606UL,0xA4L,1UL,0xDBB14683L,0x613BL,0UL,0x0.Dp-1};
            struct S0 ****l_512 = &l_341;
            int32_t *l_538 = &l_344.f0;
            if ((safe_sub_func_uint32_t_u_u(0x167E3D1BL, ((((safe_sub_func_uint16_t_u_u(l_465, ((*l_345) || 0x8E5FL))) > 65534UL) | l_465) || 0x187F322EL))))
            { /* block id: 327 */
                struct S0 l_469 = {0x21348D37L,0UL,0xCE32A651L,0xF6L,6UL,0UL,0x6908L,0x95DFL,0x1.7p+1};
                int32_t ****l_489 = (void*)0;
                float *l_536 = (void*)0;
                uint8_t l_551 = 4UL;
                float ***l_562 = (void*)0;
                float ****l_561 = &l_562;
                for (l_366 = 0; (l_366 <= 12); l_366 = safe_add_func_int32_t_s_s(l_366, 7))
                { /* block id: 330 */
                    struct S0 l_473 = {0x28965A8CL,0x39169E03L,0x84A26DB0L,1UL,1UL,0x63C3B2ADL,1L,0x687BL,0x1.6p-1};
                    l_469 = l_468;
                    for (l_344.f3 = 0; (l_344.f3 > 20); l_344.f3 = safe_add_func_int32_t_s_s(l_344.f3, 1))
                    { /* block id: 334 */
                        int32_t **l_472 = &l_345;
                        (*l_472) = (void*)0;
                        return p_56;
                    }
                    l_473 = l_468;
                }
                for (l_344.f5 = 0; (l_344.f5 > 14); l_344.f5 = safe_add_func_uint16_t_u_u(l_344.f5, 1))
                { /* block id: 342 */
                    int32_t l_487 = 0x1BD4FFE3L;
                    struct S0 l_494 = {0x401527A6L,0x644F10BCL,0UL,0x8DL,1UL,1UL,8L,0xB764L,0x0.Fp+1};
                    if (((((*l_345) || (safe_add_func_int16_t_s_s((safe_add_func_int16_t_s_s(l_468.f4, __builtin_clzl(p_56))), (((safe_sub_func_int16_t_s_s(((safe_rshift_func_int16_t_s_u(7L, ((l_484 != func_69((safe_sub_func_uint32_t_u_u(l_487, 4294967289UL)), p_53)) || 0UL))) >= p_53), 1L)) > l_468.f2) | p_56)))) >= l_469.f5) > (*l_345)))
                    { /* block id: 343 */
                        int32_t *****l_490 = (void*)0;
                        int32_t *****l_491 = &l_444;
                        struct S0 *l_492 = &l_468;
                        if (p_54)
                            goto lbl_488;
                        (*l_491) = l_489;
                        (*l_492) = l_468;
                    }
                    else
                    { /* block id: 347 */
                        float *l_493 = &l_468.f8;
                        (*l_493) = (__builtin_parityl(((*p_55) | 0x53D06A86L)) < p_53);
                    }
                    p_55 = p_55;
                    if ((*p_55))
                        continue;
                    if (func_130(l_494))
                    { /* block id: 352 */
                        float **l_505 = (void*)0;
                        float ***l_504 = &l_505;
                        float ****l_503 = &l_504;
                        (*l_345) = func_69(((safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(p_56, 6)), 5)), 1)), 6)) != p_56), p_54);
                        (*l_503) = (void*)0;
                    }
                    else
                    { /* block id: 355 */
                        int32_t ***l_506 = &l_409;
                        int32_t ****l_507 = &l_506;
                        p_55 = p_55;
                        (*l_507) = l_506;
                    }
                }
                (*p_55) = (__builtin_parityll(p_53) > (safe_lshift_func_int16_t_s_u(((safe_rshift_func_uint16_t_u_s(((void*)0 == l_512), 0)) && ((safe_add_func_uint16_t_u_u((safe_unary_minus_func_uint32_t_u(((safe_add_func_int16_t_s_s(__builtin_ffsl(__builtin_bswap32((p_53 <= (*p_55)))), p_54)) > (-4L)))), 0xEF92L)) > l_469.f0)), 8)));
                if (((l_468.f3 | p_54) & (safe_add_func_int16_t_s_s(func_69(__builtin_ctzll(p_56), (safe_lshift_func_uint16_t_u_u(((p_54 ^ p_54) < (&l_408 == &l_408)), ((p_54 > (*l_345)) | l_468.f7)))), l_465))))
                { /* block id: 361 */
                    int32_t l_523 = 0L;
                    struct S0 *l_524 = &l_344;
                    (*l_345) = ((~((l_523 <= (((((*p_55) && ((***l_427) != l_524)) > ((4294967295UL || (((((safe_add_func_uint16_t_u_u(p_54, ((p_56 > ((safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s((p_53 ^ (~0xCF55E906L)), p_53)), p_53)), (-1L))) && 1UL)) && p_54))) || p_54) & p_53) && (*p_55)) ^ 0x399EL)) ^ (*l_345))) ^ 4L) | (*p_55))) != (*p_55))) != 0xCDE96E97L);
                    if ((*p_55))
                    { /* block id: 363 */
                        return p_54;
                    }
                    else
                    { /* block id: 365 */
                        int32_t **l_534 = &l_345;
                        int32_t *l_537 = &l_523;
                        (*l_534) = &l_523;
                        l_535 = &p_55;
                        (*l_535) = func_96((l_536 == p_55), p_54, func_96(l_523, (**l_534), func_93(&l_523, p_53), (l_537 == (void*)0), l_538), p_54, (*l_535));
                        (*l_537) = ((*p_55) & ((void*)0 != l_539));
                    }
                    (*p_55) = (*l_538);
                    (*l_539) = func_96((((*p_55) < (((*l_538) && ((safe_lshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_s(p_56, p_53)), 8)) > p_56)) | (*l_538))) & p_56), p_56, &l_523, p_56, l_538);
                }
                else
                { /* block id: 373 */
                    struct S0 l_544 = {0L,0xDC98A29DL,0xAC6206D4L,0xF0L,4294967289UL,0x7FCEA9CEL,3L,1UL,-0x4.Ap+1};
                    int32_t ****l_573 = (void*)0;
                    l_544 = l_468;
                    if (((p_53 && (((void*)0 != (***l_427)) <= p_53)) <= 0x6BDEFF4AL))
                    { /* block id: 375 */
                        struct S0 *l_545 = &l_469;
                        int32_t l_552 = (-1L);
                        (*l_545) = l_544;
                        (*l_545) = l_546;
                        (*p_55) = (((*p_55) & ((void*)0 != &l_342)) > ((safe_lshift_func_uint16_t_u_s((l_552 & p_54), 8)) && 8L));
                        (*l_545) = l_469;
                    }
                    else
                    { /* block id: 380 */
                        int32_t *l_553 = &l_469.f0;
                        (*l_535) = l_553;
                    }
                    if (((safe_rshift_func_int16_t_s_s(((*p_55) | (*p_55)), (p_54 == (*l_538)))) | ((**l_535) < (safe_lshift_func_uint16_t_u_u((p_54 > p_56), __builtin_ctz(p_53))))))
                    { /* block id: 383 */
                        uint32_t l_558 = 0x21E08516L;
                        (**l_539) = (p_56 || p_56);
                        (****l_563) = ((l_544.f5 >= (((p_53 == (l_558 < ((safe_sub_func_float_f_f(p_56, p_56)) >= (-0x3.0p-1)))) > ((0xB.7C5190p+12 >= (0xF.C3B75Ep+57 != (l_561 != l_563))) <= p_53)) < (*l_538))) != p_54);
                    }
                    else
                    { /* block id: 386 */
                        int32_t *l_567 = &l_344.f0;
                        float *****l_570 = (void*)0;
                        p_55 = func_93(l_567, ((safe_add_func_float_f_f(((-0x10.Bp+1) >= (l_570 != l_570)), p_54)) != ((*l_567) > (safe_add_func_float_f_f((0xB.84FCB8p-26 <= 0x1.Ep+1), p_54)))));
                        l_489 = l_573;
                        return p_54;
                    }
                }
            }
            else
            { /* block id: 392 */
                struct S0 l_574 = {0x39086085L,0x86353B60L,0x8FD4153DL,0x0AL,0UL,0x55004BE3L,0xC90BL,0xEF46L,0xB.0E68A2p+19};
                (****l_563) = 0x4.08AF76p+63;
                (*p_55) = (func_130(l_574) | (0xA344L & ((0xB38A0751L ^ (__builtin_ctzll((((void*)0 != (*l_342)) == (*l_538))) | func_130(l_574))) == l_574.f7)));
                (*l_535) = func_96((*l_538), (**l_535), func_93(p_55, (safe_add_func_float_f_f(__builtin_popcountll((safe_lshift_func_uint16_t_u_u(65535UL, l_574.f2))), (__builtin_ctz((safe_sub_func_uint16_t_u_u((!(func_130(l_574) <= 0x8F5DL)), p_56))) != p_56)))), (*l_538), l_538);
            }
        }
        else
        { /* block id: 397 */
            int16_t l_582 = (-10L);
            return l_582;
        }
    }
    else
    { /* block id: 400 */
        int32_t *l_583 = &l_546.f0;
        int32_t **l_584 = (void*)0;
        int32_t **l_585 = &l_583;
        (*l_585) = l_583;
        (*l_585) = func_93(p_55, (p_56 > ((*l_583) >= (**l_585))));
        (*l_342) = (*l_342);
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_69(int32_t  p_70, uint8_t  p_71)
{ /* block id: 138 */
    int32_t l_211 = (-1L);
    int32_t *l_210 = &l_211;
    int32_t **l_209 = &l_210;
    struct S0 l_239 = {-1L,0x4DCBB3E8L,0UL,253UL,0x6FFBB3F4L,0x01ED4495L,3L,0xEC3DL,0x8.051045p+97};
    int32_t *l_263 = &l_239.f0;
    struct S0 *l_283 = &l_239;
    struct S0 **l_282 = &l_283;
    float *l_295 = (void*)0;
    float **l_294 = &l_295;
    float ***l_293 = &l_294;
    uint8_t l_302 = 2UL;
    float ****l_337 = &l_293;
    float *****l_336 = &l_337;
    (*l_209) = (void*)0;
    for (p_71 = (-23); (p_71 != 10); p_71 = safe_add_func_uint32_t_u_u(p_71, 3))
    { /* block id: 142 */
        uint32_t l_218 = 18446744073709551615UL;
        float l_224 = 0xF.627CF3p-65;
        float *l_223 = &l_224;
        float **l_222 = &l_223;
        uint32_t l_237 = 4294967294UL;
        int32_t l_238 = 0xEADB586EL;
        uint16_t l_247 = 65535UL;
        int32_t *l_248 = &l_239.f0;
        struct S0 l_271 = {0xFCC094F2L,0xFA778136L,4UL,5UL,0x758E7D96L,0xFE579FFBL,-4L,0x56BAL,-0x1.5p-1};
        int32_t *l_319 = (void*)0;
        struct S0 ***l_333 = (void*)0;
    }
    (*l_336) = &l_293;
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_72(struct S0  p_73, float  p_74, struct S0  p_75, int32_t  p_76, int32_t * p_77)
{ /* block id: 47 */
    uint16_t l_84 = 5UL;
    int32_t l_107 = 0x7B846FCCL;
    int32_t *l_106 = &l_107;
    int32_t *l_108 = (void*)0;
    (*p_77) = (*p_77);
    (*l_106) = ((l_84 > ((safe_lshift_func_int16_t_s_s(0xCB56L, l_84)) < ((safe_unary_minus_func_int16_t_s(func_88(func_93(func_96((safe_lshift_func_uint16_t_u_u((l_84 && 0xCFEFL), __builtin_parityl(l_84))), ((safe_mod_func_int32_t_s_s((__builtin_clzl(p_73.f5) >= 0x1071FCCBL), (-1L))) | 0xE484L), l_106, p_73.f2, l_108), p_75.f8), l_108, p_75.f2, p_73.f4))) && p_75.f0))) <= l_84);
    return (*p_77);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_88(int32_t * p_89, int32_t * p_90, uint32_t  p_91, int16_t  p_92)
{ /* block id: 131 */
    int32_t l_195 = (-1L);
    int32_t l_197 = (-2L);
    int32_t *l_196 = &l_197;
    int32_t *l_198 = (void*)0;
    int32_t **l_199 = &l_196;
    struct S0 l_206 = {0xC243D1E1L,0xFD7A930FL,0x37C21217L,0xC6L,0x3EEC5992L,0x23FAAA28L,0xD617L,0x3B7BL,0xC.02B38Fp-45};
    int32_t l_207 = 1L;
    float *l_208 = &l_206.f8;
    (*l_199) = func_96(l_195, p_92, func_93(l_196, p_91), p_92, l_198);
    (*l_199) = p_90;
    (*l_208) = ((((*l_199) != p_90) > ((((((p_92 >= (safe_sub_func_float_f_f((safe_add_func_float_f_f(p_91, ((safe_add_func_float_f_f(p_91, ((func_130(l_206) != p_91) >= (l_207 <= p_91)))) != (-0x1.6p+1)))), 0x2.F4611Ep+58))) >= (-0x1.Dp+1)) > 0x8.B0EE66p+95) < (-0x10.Bp-1)) < p_92) != p_92)) == 0x4.C0BC50p-51);
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_93(int32_t * p_94, float  p_95)
{ /* block id: 52 */
    int32_t l_113 = (-1L);
    int32_t *l_126 = &l_113;
    int32_t **l_125 = &l_126;
    struct S0 l_190 = {0x2FE8C5B5L,4294967292UL,0xB7ED1FF4L,3UL,6UL,0x211D8635L,0L,7UL,0x0.Dp+1};
    int32_t *l_193 = (void*)0;
    int32_t *l_194 = &l_190.f0;
    for (l_113 = 14; (l_113 <= (-29)); l_113 = safe_sub_func_uint32_t_u_u(l_113, 1))
    { /* block id: 55 */
        int32_t l_117 = 0x57BBF0BEL;
        int32_t *l_116 = &l_117;
        (*l_116) = 0x5C327FA8L;
        if (l_113)
            break;
        for (l_117 = 0; (l_117 == 18); l_117 = safe_add_func_uint16_t_u_u(l_117, 3))
        { /* block id: 60 */
            int32_t l_127 = 0xB4A04EC1L;
            struct S0 l_132 = {0xF8E1F03BL,0x7FC81C9DL,6UL,0xB8L,0x59D8E95AL,6UL,1L,0x9131L,-0x7.4p+1};
            int32_t **l_134 = &l_126;
            int32_t **l_189 = &l_126;
        }
        if ((*l_116))
            break;
    }
    (*l_125) = p_94;
    l_190 = l_190;
    l_113 = (safe_rshift_func_int16_t_s_s((func_130(l_190) && 0UL), (l_190.f3 < (0x2D4C9FC4L & (l_126 != l_126)))));
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_96(uint32_t  p_97, uint16_t  p_98, int32_t * p_99, float  p_100, int32_t * p_101)
{ /* block id: 49 */
    int32_t l_112 = (-10L);
    int32_t *l_111 = &l_112;
    (*p_99) = (safe_sub_func_int16_t_s_s((p_99 != l_111), 7UL));
    return p_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_120(int32_t ** p_121, int32_t  p_122, int16_t  p_123, int32_t ** p_124)
{ /* block id: 63 */
    int32_t l_137 = 0xB3A31468L;
    int32_t *l_136 = &l_137;
    int32_t **l_135 = &l_136;
    struct S0 *l_175 = (void*)0;
    int32_t **l_186 = &l_136;
    int32_t **l_187 = &l_136;
    int32_t **l_188 = (void*)0;
    if (((l_135 == (void*)0) & __builtin_bswap32((p_123 <= 65535UL))))
    { /* block id: 64 */
        struct S0 l_144 = {0x08D222C0L,0xF70B01AAL,6UL,7UL,4294967293UL,4294967295UL,0xAFD6L,0x14BBL,-0x3.Bp-1};
        int32_t *l_146 = &l_137;
        int16_t l_170 = 0x324BL;
        struct S0 **l_179 = &l_175;
        if ((**p_124))
        { /* block id: 65 */
            int32_t l_141 = (-5L);
            struct S0 *l_152 = &l_144;
            if ((p_122 > ((-1L) == (safe_add_func_int16_t_s_s((((**p_124) != (((!(65533UL < l_141)) != p_122) || (0xF37DL != (safe_rshift_func_int16_t_s_s(0xF0D9L, (p_123 | p_123)))))) | 1L), p_122)))))
            { /* block id: 66 */
                struct S0 *l_145 = &l_144;
                int32_t l_148 = 0x1E517F06L;
                int32_t l_153 = 1L;
                (*l_145) = l_144;
                (*p_121) = l_146;
                (*l_135) = func_96((((((~((((*l_146) & (l_148 == (*l_146))) != (safe_unary_minus_func_uint16_t_u((safe_add_func_int32_t_s_s((l_152 != l_152), ((**l_135) > (**p_124))))))) <= l_141)) & l_153) ^ (-4L)) && l_148) <= 0x63A0L), (*l_146), (*p_121), p_122, (*p_124));
                for (l_153 = 22; (l_153 != 5); l_153 = safe_sub_func_int32_t_s_s(l_153, 1))
                { /* block id: 72 */
                    if ((**p_124))
                    { /* block id: 73 */
                        (*p_121) = (*p_124);
                        (*l_152) = l_144;
                    }
                    else
                    { /* block id: 76 */
                        int32_t *l_156 = &l_141;
                        (**p_124) = ((1UL & (**p_121)) ^ (l_156 == (void*)0));
                    }
                    if ((*l_136))
                        break;
                }
            }
            else
            { /* block id: 81 */
                int32_t **l_157 = &l_136;
                struct S0 l_158 = {-5L,0x00EC888EL,0x995485A9L,255UL,0UL,1UL,0L,0UL,0xF.03FFABp-31};
                (*l_146) = ((p_121 == l_157) ^ (**l_157));
                (*l_157) = func_96((__builtin_popcount(p_123) | (*l_146)), (__builtin_ctzll(p_123) >= (0x6319L != 0xE392L)), (*l_135), p_123, (*l_157));
                (**l_135) = (**l_157);
            }
        }
        else
        { /* block id: 86 */
            uint32_t l_160 = 0UL;
            int32_t *l_171 = &l_144.f0;
            struct S0 l_180 = {0x3AA068DCL,1UL,18446744073709551615UL,0xF1L,0x8F814AE1L,0x9C254B31L,0xFCE8L,0xA1E7L,0xE.117623p+27};
            float *l_181 = &l_180.f8;
            if ((safe_unary_minus_func_int16_t_s(l_160)))
            { /* block id: 87 */
                float *l_161 = (void*)0;
                float *l_162 = &l_144.f8;
                (*l_162) = p_122;
            }
            else
            { /* block id: 89 */
                uint32_t l_165 = 0xEEFF2A67L;
                struct S0 l_168 = {0xB958418DL,4294967288UL,1UL,0x12L,1UL,0xA6FCDD68L,-8L,65534UL,0x6.617F60p+28};
                int32_t **l_173 = &l_171;
                int32_t ***l_174 = &l_173;
                struct S0 **l_176 = &l_175;
                for (l_144.f7 = (-3); (l_144.f7 < 35); l_144.f7 = safe_add_func_uint32_t_u_u(l_144.f7, 3))
                { /* block id: 92 */
                    uint16_t l_169 = 0x8DA6L;
                    (*l_135) = (*p_124);
                    if ((l_165 && (safe_sub_func_int16_t_s_s(func_130(l_168), (l_169 & (-2L))))))
                    { /* block id: 94 */
                        (*l_146) = (*l_146);
                        if (l_170)
                            continue;
                    }
                    else
                    { /* block id: 97 */
                        int32_t *l_172 = &l_168.f0;
                        l_172 = l_171;
                    }
                    return p_124;
                }
                (*l_174) = p_121;
                (*l_176) = l_175;
                return p_124;
            }
            for (l_144.f0 = 0; (l_144.f0 < (-19)); l_144.f0 = safe_sub_func_int32_t_s_s(l_144.f0, 1))
            { /* block id: 108 */
                (*p_124) = (*l_135);
            }
            (*l_181) = (((*l_171) >= p_122) <= (__builtin_ctzll(p_122) > (((((void*)0 != l_179) != ((void*)0 != l_175)) < (func_130(l_180) <= 0x0.990F71p-55)) < (*l_171))));
        }
    }
    else
    { /* block id: 113 */
        struct S0 **l_185 = &l_175;
        struct S0 ***l_184 = &l_185;
        for (l_137 = (-16); (l_137 != (-16)); l_137 = safe_add_func_uint16_t_u_u(l_137, 4))
        { /* block id: 116 */
            if ((**p_124))
                break;
        }
        (*p_121) = (*p_121);
        (*l_184) = &l_175;
    }
    return l_188;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_130(struct S0  p_131)
{ /* block id: 61 */
    return p_131.f4;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 168
   depth: 1, occurrence: 30
XXX total union variables: 0

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 189
   depth: 2, occurrence: 23
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 4
   depth: 8, occurrence: 3
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 203

XXX times a variable address is taken: 183
XXX times a pointer is dereferenced on RHS: 124
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 15
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 114
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 528

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 443
   level: 2, occurrence: 100
   level: 3, occurrence: 37
   level: 4, occurrence: 26
XXX number of pointers point to pointers: 100
XXX number of pointers point to scalars: 83
XXX number of pointers point to structs: 20
XXX percent of pointers has null in alias set: 32
XXX average alias set size: 1.47

XXX times a non-volatile is read: 840
XXX times a non-volatile is write: 324
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 6

XXX stmts: 160
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 21
   depth: 2, occurrence: 21
   depth: 3, occurrence: 32
   depth: 4, occurrence: 23
   depth: 5, occurrence: 35

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
********************* end of statistics **********************/

