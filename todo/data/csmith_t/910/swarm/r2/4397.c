/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1064465110
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 25;
   int64_t  f1;
   signed f2 : 18;
   unsigned f3 : 12;
   signed f4 : 1;
   unsigned f5 : 9;
   unsigned f6 : 6;
   const uint16_t  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_30(void);
inline static int16_t  func_37(uint32_t  p_38, int32_t  p_39, int16_t  p_40);
static uint64_t  func_48(uint32_t  p_49, const uint64_t  p_50, int16_t  p_51, int32_t  p_52, uint64_t  p_53);
inline static int32_t * func_56(const int32_t * p_57, int32_t * p_58);
inline static int32_t * func_68(uint32_t  p_69);
inline static int32_t  func_74(int32_t * p_75, int32_t * p_76, int16_t  p_77);
static int32_t * func_79(uint32_t  p_80, uint32_t  p_81, uint64_t  p_82, uint64_t  p_83, const int32_t  p_84);
static uint32_t  func_90(int32_t * p_91, int32_t * p_92, int16_t  p_93, const int16_t  p_94);
inline static int32_t * func_95(const int32_t  p_96, uint32_t  p_97);
inline static int32_t * func_101(int32_t * p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_30(void)
{ /* block id: 36 */
    uint32_t l_45 = 0x2F92E6C0L;
    uint32_t l_235 = 0x69774089L;
    uint16_t l_244 = 0x9466L;
    int32_t l_267 = (-1L);
    int32_t *l_266 = &l_267;
    int32_t l_281 = 0x26E526A4L;
    int32_t *l_283 = (void*)0;
    int16_t l_291 = (-4L);
    int32_t *l_312 = &l_267;
    int16_t l_315 = (-3L);
    int32_t ***l_316 = (void*)0;
    int32_t l_317 = 0xE463A389L;
    int32_t *l_379 = &l_317;
    int16_t l_381 = (-3L);
    if (((uint16_t)((int64_t)((uint16_t)((func_37(((int16_t)((int16_t)(__builtin_popcountl(__builtin_ctzl(l_45)) && (0x4593F6A08376FBFCLL != ((uint64_t)func_48(l_45, (__builtin_ffsll(((((uint16_t)(65533UL >= (((l_45 > (l_45 != ((l_45 > 0xFC02L) < 0xD991L))) & l_45) && l_45)) * (uint16_t)l_45) != l_45) <= l_45)) & l_45), l_45, l_45, l_45) % (uint64_t)l_45))) * (int16_t)0x4F61L) << (int16_t)0), l_45, l_235) | l_45) <= l_235) >> (uint16_t)l_235) % (int64_t)l_244) * (uint16_t)l_235))
    { /* block id: 129 */
        int64_t l_252 = 0x3AFA74D9B9149043LL;
        int32_t l_260 = 1L;
        int32_t *l_259 = &l_260;
        int32_t **l_258 = &l_259;
        (**l_258) = ((!((int16_t)(0x0E5491D3E571FBC6LL & ((int16_t)0L * (int16_t)l_252)) >> (int16_t)10)) | ((uint64_t)(l_235 < (-(int32_t)l_252)) + (uint64_t)((int64_t)((l_258 == &l_259) >= ((int16_t)((int32_t)(l_244 <= (l_45 == 0UL)) + (int32_t)l_235) - (int16_t)(*l_259))) + (int64_t)(*l_259))));
        (**l_258) = l_45;
    }
    else
    { /* block id: 132 */
        int32_t *l_265 = (void*)0;
        int32_t l_276 = 0xE026D30EL;
lbl_287:
        l_266 = func_101(l_265);
        for (l_244 = 0; (l_244 == 20); l_244 += 1)
        { /* block id: 136 */
            int32_t l_272 = (-1L);
            int32_t **l_275 = &l_265;
            int32_t ***l_274 = &l_275;
            int32_t ****l_273 = &l_274;
            int32_t l_277 = 0L;
            int32_t *l_278 = &l_276;
            int32_t *l_294 = &l_276;
            (*l_278) = ((uint16_t)((l_272 ^ (l_272 > ((void*)0 != l_273))) & l_276) >> (uint16_t)__builtin_popcountll(l_277));
            for (l_45 = (-23); (l_45 < 1); l_45 += 1)
            { /* block id: 140 */
                uint64_t l_282 = 1UL;
                int32_t *l_284 = &l_277;
                l_282 = l_281;
                (*l_275) = func_101(&l_267);
                /* statement id: 142 */
                assert (l_265 == &l_267);
                if ((__builtin_ffs(l_244) | func_37((*l_265), ((((l_283 == l_284) && __builtin_clzll((*l_284))) >= (((l_284 != l_284) > (*l_278)) || (*l_284))) > (***l_274)), (*l_265))))
                { /* block id: 143 */
                    (****l_273) = 6L;
                    for (l_272 = 0; (l_272 > (-21)); l_272 -= 4)
                    { /* block id: 147 */
                        if (l_267)
                            goto lbl_287;
                    }
                }
                else
                { /* block id: 150 */
                    int16_t l_290 = 0x78A0L;
                    for (l_281 = 25; (l_281 >= (-3)); l_281 -= 1)
                    { /* block id: 153 */
                        if (l_290)
                            break;
                    }
                    return l_290;
                }
                if (l_291)
                    break;
            }
            for (l_235 = 0; (l_235 >= 38); l_235 += 8)
            { /* block id: 162 */
                uint64_t l_295 = 9UL;
                (*l_278) = func_74(l_294, &l_276, (l_295 > 0x6E7CB5A7L));
            }
            (*l_274) = (void*)0;
            /* statement id: 165 */
            assert (l_275 == 0);
        }
    }
    /* facts after branching */
    assert (l_266 == 0 || l_266 == &l_267);
    if ((l_291 | l_281))
    { /* block id: 168 */
        const uint32_t l_298 = 1UL;
        int32_t *l_299 = &l_267;
        uint32_t l_310 = 4294967295UL;
        int32_t **l_311 = (void*)0;
        (*l_299) = ((int16_t)l_281 >> (int16_t)l_298);
        if ((((int32_t)(0L || ((void*)0 != l_299)) / (int32_t)(*l_299)) <= l_281))
        { /* block id: 170 */
            int32_t **l_302 = &l_266;
            (*l_302) = l_299;
            /* statement id: 171 */
            assert (l_266 == &l_267);
        }
        else
        { /* block id: 172 */
            int32_t **l_304 = (void*)0;
            int32_t ***l_303 = &l_304;
            int32_t l_305 = (-1L);
            l_303 = l_303;
            (*l_299) = (func_48((*l_299), (*l_299), l_305, __builtin_ffsll(((uint16_t)__builtin_ffsll((*l_299)) >> (uint16_t)((uint16_t)l_310 >> (uint16_t)((*l_299) > (*l_299))))), (*l_299)) & (-7L));
        }
        l_299 = l_299;
        l_299 = l_312;
    }
    else
    { /* block id: 178 */
        int32_t **l_314 = &l_283;
        int32_t ***l_313 = &l_314;
        (*l_313) = &l_266;
        /* statement id: 179 */
        assert (l_314 == &l_266);
        return l_315;
    }
    (*l_312) = 0L;
    if ((4UL && (l_316 != (void*)0)))
    { /* block id: 183 */
        const int32_t *l_318 = &l_267;
        (*l_312) = l_317;
        l_318 = l_318;
    }
    else
    { /* block id: 186 */
        int32_t *l_321 = &l_267;
        int32_t ****l_339 = &l_316;
        int32_t *****l_338 = &l_339;
        for (l_45 = 0; (l_45 > 10); l_45 += 4)
        { /* block id: 189 */
            int32_t **l_322 = &l_321;
            (*l_322) = l_321;
            (*l_312) = (*l_321);
        }
        for (l_317 = 4; (l_317 == (-11)); l_317 -= 1)
        { /* block id: 195 */
            int32_t *l_333 = (void*)0;
            uint32_t l_336 = 18446744073709551615UL;
            int32_t l_337 = 0x68A6B7EAL;
            int32_t *****l_340 = &l_339;
            struct S0 l_358 = {813,0L,217,44,0,1,2,0x331BL};
            struct S0 *l_357 = &l_358;
            uint64_t l_375 = 0xB6AAB4845D3B33B7LL;
        }
        l_379 = (void*)0;
        /* statement id: 227 */
        assert (l_379 == 0);
    }
    /* facts after branching */
    assert (l_379 == 0 || l_379 == &l_317);
    return l_381;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_37(uint32_t  p_38, int32_t  p_39, int16_t  p_40)
{ /* block id: 123 */
    int32_t ***l_236 = (void*)0;
    int32_t ****l_237 = &l_236;
    int32_t l_238 = 1L;
    int32_t l_239 = 0xE6B2783FL;
    int32_t *l_243 = &l_238;
    int32_t **l_242 = &l_243;
    (*l_237) = l_236;
    p_39 = (__builtin_ia32_crc32qi(p_39, p_38) ^ 0UL);
    (*l_242) = func_95(p_40, (l_238 ^ p_38));
    /* statement id: 126 */
    assert (l_243 == 0);
    (*l_242) = &p_39;
    /* statement id: 127 */
    assert (l_243 == &p_39);
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_48(uint32_t  p_49, const uint64_t  p_50, int16_t  p_51, int32_t  p_52, uint64_t  p_53)
{ /* block id: 37 */
    int32_t l_60 = 1L;
    const int32_t *l_59 = &l_60;
    int32_t *l_234 = (void*)0;
    int32_t **l_233 = &l_234;
    (*l_233) = func_56(l_59, &l_60);
    /* statement id: 121 */
    assert (l_234 == &l_60);
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_56(const int32_t * p_57, int32_t * p_58)
{ /* block id: 38 */
    const int32_t l_63 = 0x8F5349DDL;
    const int32_t *l_62 = &l_63;
    int32_t l_67 = 0L;
    int32_t * const l_66 = &l_67;
    int32_t *l_232 = (void*)0;
    int32_t **l_231 = &l_232;
    (*l_66) = (((p_58 != p_57) && ((!(l_62 == p_57)) < (p_57 != (void*)0))) & ((int16_t)(l_66 != (void*)0) >> (int16_t)12));
    (*l_231) = func_68((p_57 != p_57));
    return p_58;
    /* statement id: 120 */
    //assert (func_56_rv == &l_60 || func_56_rv == &l_267);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_68(uint32_t  p_69)
{ /* block id: 40 */
    int32_t *l_78 = (void*)0;
    int32_t l_100 = 0x72472F85L;
    int32_t l_148 = 8L;
    int32_t *l_228 = &l_100;
    int32_t *l_229 = &l_100;
    int32_t *l_230 = (void*)0;
    if (((((uint16_t)(((uint16_t)__builtin_ffs(func_74(l_78, func_79(p_69, p_69, p_69, (p_69 && ((-(int16_t)((int16_t)(0xBFE1A273L < ((uint32_t)func_90(func_95(((int16_t)((p_69 <= __builtin_parityl(p_69)) ^ 0xFAAB159BBC08F528LL) * (int16_t)p_69), l_100), &l_100, p_69, l_100) + (uint32_t)l_148)) % (int16_t)p_69)) < 2L)), p_69), l_148)) * (uint16_t)(-5L)) != l_148) >> (uint16_t)14) && 0x37B3L) ^ p_69))
    { /* block id: 103 */
        const int64_t l_203 = (-1L);
        int32_t *l_208 = &l_148;
        int16_t l_209 = 0x8E19L;
        (*l_208) = ((uint16_t)l_203 % (uint16_t)((int16_t)(((int16_t)p_69 << (int16_t)12) && l_203) >> (int16_t)(p_69 | (func_74(l_208, func_79((*l_208), p_69, (*l_208), ((l_209 != p_69) >= p_69), l_148), (*l_208)) >= p_69))));
    }
    else
    { /* block id: 105 */
        int32_t *l_210 = (void*)0;
        int32_t *l_211 = &l_100;
        int32_t **l_212 = &l_211;
        (*l_211) = p_69;
        (*l_212) = func_101(l_210);
        /* statement id: 107 */
        assert (l_211 == 0);
        for (l_100 = 0; (l_100 >= 23); ++l_100)
        { /* block id: 110 */
            int32_t l_217 = 0x769E6F5AL;
            int16_t l_224 = 0x623EL;
            int32_t *l_225 = &l_217;
            (*l_212) = (*l_212);
            (*l_225) = ((uint16_t)(l_217 & ((int32_t)p_69 + (int32_t)((int16_t)(((int16_t)func_74((*l_212), func_79(p_69, l_217, l_217, l_224, p_69), p_69) - (int16_t)l_224) && p_69) >> (int16_t)p_69))) * (uint16_t)p_69);
            (*l_225) = p_69;
            (*l_225) = (*l_225);
        }
    }
    (*l_228) = (0xC597L && (p_69 >= ((uint32_t)((void*)0 == &l_148) + (uint32_t)func_74(&l_148, &l_148, (p_69 > (p_69 >= (-1L)))))));
    return l_230;
    /* statement id: 118 */
    //assert (func_68_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_74(int32_t * p_75, int32_t * p_76, int16_t  p_77)
{ /* block id: 80 */
    int32_t l_159 = 0x6C32C6D1L;
    int32_t ** const *l_166 = (void*)0;
    int32_t *l_167 = &l_159;
    uint64_t l_192 = 0x02AA92F95BF6126CLL;
    int32_t l_200 = 0x57614822L;
    (*l_167) = (l_159 & (((uint64_t)l_159 - (uint64_t)((uint16_t)l_159 * (uint16_t)(__builtin_ffsl((p_77 & (l_159 >= (((int16_t)((l_166 != (void*)0) > ((p_77 == l_159) && p_77)) * (int16_t)l_159) | 0xEEF2C45EL)))) < 4294967286UL))) ^ 0x1D32L));
    if ((*l_167))
    { /* block id: 82 */
        int32_t *l_168 = &l_159;
        int32_t **l_169 = &l_168;
        int32_t ***l_180 = &l_169;
        int32_t **** const l_179 = &l_180;
        uint32_t l_181 = 4294967288UL;
        (*l_169) = l_168;
        if ((*l_167))
        { /* block id: 84 */
            int32_t *l_172 = &l_159;
            uint16_t l_178 = 0x6633L;
            for (p_77 = 20; (p_77 <= (-11)); p_77 -= 1)
            { /* block id: 87 */
                int32_t *l_175 = &l_159;
                l_167 = l_172;
                (*l_169) = p_75;
                /* statement id: 89 */
                //assert (l_168 == 0 || l_168 == &l_148 || l_168 == &l_276);
                (*l_167) = ((uint64_t)func_90(p_76, func_101(l_175), (((uint16_t)l_178 >> (uint16_t)((l_179 != &l_166) | (*l_167))) != (l_181 != ((uint32_t)((uint16_t)((uint32_t)__builtin_ctz(__builtin_bswap64(((uint64_t)((uint64_t)p_77 - (uint64_t)(*l_172)) % (uint64_t)(*l_167)))) + (uint32_t)(*l_167)) * (uint16_t)p_77) - (uint32_t)(*l_172)))), p_77) % (uint64_t)l_192);
            }
            /* facts after for loop */
            //assert (l_168 == 0 || l_168 == &l_159 || l_168 == &l_148 || l_168 == &l_276);
            (*l_172) = 0L;
        }
        else
        { /* block id: 93 */
            int32_t ****l_197 = (void*)0;
            (**l_169) = ((int16_t)(0xCBF0L ^ ((****l_179) <= ((int64_t)p_77 * (int64_t)(p_77 > p_77)))) >> (int16_t)14);
            (*l_168) = (*l_168);
            (*l_168) = ((*l_167) > ((l_197 != (void*)0) == (p_77 != ((int16_t)((void*)0 == l_197) % (int16_t)p_77))));
        }
        /* facts after branching */
        //assert (l_168 == 0 || l_168 == &l_159 || l_168 == &l_148 || l_168 == &l_276);
        (**l_180) = (*l_169);
    }
    else
    { /* block id: 99 */
        l_167 = func_101(p_76);
        /* statement id: 100 */
        //assert (l_167 == 0 || l_167 == &l_148 || l_167 == &l_276);
    }
    /* facts after branching */
    //assert (l_167 == 0 || l_167 == &l_159 || l_167 == &l_148 || l_167 == &l_276);
    return l_200;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_79(uint32_t  p_80, uint32_t  p_81, uint64_t  p_82, uint64_t  p_83, const int32_t  p_84)
{ /* block id: 75 */
    int32_t l_150 = (-1L);
    int32_t *l_149 = &l_150;
    int32_t *l_151 = &l_150;
    int32_t *l_152 = &l_150;
    int32_t *l_153 = &l_150;
    int32_t *l_154 = &l_150;
    int32_t *l_155 = &l_150;
    int32_t *l_156 = &l_150;
    int32_t *l_157 = &l_150;
    int32_t *l_158 = (void*)0;
    (*l_149) = 0xA4DE48ECL;
    (*l_149) = ((*l_149) >= (p_84 < p_80));
    (*l_149) = (*l_149);
    return l_158;
    /* statement id: 79 */
    //assert (func_79_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_90(int32_t * p_91, int32_t * p_92, int16_t  p_93, const int16_t  p_94)
{ /* block id: 51 */
    const uint64_t l_126 = 0x24FAE1B8E030C704LL;
    int32_t *l_145 = (void*)0;
    (*p_92) = (*p_92);
    if ((p_93 || p_93))
    { /* block id: 53 */
        int32_t **l_116 = (void*)0;
        int32_t ***l_115 = &l_116;
        int32_t ****l_117 = &l_115;
        (*l_117) = l_115;
        for (p_93 = 0; (p_93 >= (-12)); p_93 -= 4)
        { /* block id: 57 */
            int32_t l_122 = 7L;
            int32_t **l_146 = &l_145;
            p_91 = func_101(p_91);
            if (((0L & ((uint16_t)l_122 * (uint16_t)((uint64_t)p_94 / (uint64_t)(((!(0xD8DDL == l_126)) <= ((int16_t)((int16_t)(0xDCAF5201L & (((uint32_t)7UL % (uint32_t)((uint16_t)p_93 / (uint16_t)(((uint16_t)0x36EBL >> (uint16_t)11) | p_93))) >= p_93)) - (int16_t)p_93) << (int16_t)l_122)) | (*p_92))))) | 1UL))
            { /* block id: 59 */
                p_92 = p_92;
                (*l_117) = (*l_117);
                (*p_92) = (((int16_t)l_126 * (int16_t)((int16_t)((uint16_t)__builtin_ia32_crc32qi(p_94, p_93) << (uint16_t)6) << (int16_t)2)) && p_94);
                if ((*p_92))
                    continue;
            }
            else
            { /* block id: 64 */
                int32_t *l_144 = &l_122;
                int32_t **l_143 = &l_144;
                (*l_143) = p_92;
                /* statement id: 65 */
                //assert (l_144 == &l_100 || l_144 == &l_159);
                if ((*p_92))
                    break;
            }
            (*p_92) = (l_122 >= p_93);
            (*l_146) = l_145;
        }
    }
    else
    { /* block id: 71 */
        int32_t **l_147 = &l_145;
        (*l_147) = l_145;
    }
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_95(const int32_t  p_96, uint32_t  p_97)
{ /* block id: 41 */
    int32_t l_104 = (-2L);
    int32_t *l_103 = &l_104;
    int32_t *l_109 = &l_104;
    int32_t *l_110 = &l_104;
    int32_t *l_111 = &l_104;
    int32_t *l_112 = &l_104;
    int32_t *l_113 = &l_104;
    int32_t *l_114 = (void*)0;
    l_103 = func_101(l_103);
    (*l_103) = p_96;
    (*l_103) = 0x0AA6F331L;
    return l_114;
    /* statement id: 50 */
    //assert (func_95_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_101(int32_t * p_102)
{ /* block id: 42 */
    int32_t l_106 = 1L;
    int32_t *l_105 = &l_106;
    int32_t **l_107 = &l_105;
    int32_t *l_108 = (void*)0;
    (*l_107) = l_105;
    (*l_107) = l_108;
    /* statement id: 44 */
    assert (l_105 == 0);
    (*l_107) = (*l_107);
    return p_102;
    /* statement id: 46 */
    //assert (func_101_rv == &l_104 || func_101_rv == 0 || func_101_rv == &l_159 || func_101_rv == &l_148 || func_101_rv == &l_267 || func_101_rv == &l_276);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 107
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 1
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 1
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 1
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 127
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 107

XXX times a variable address is taken: 89
XXX times a pointer is dereferenced on RHS: 66
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 61
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 7
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 290

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 303
   level: 2, occurrence: 27
   level: 3, occurrence: 16
   level: 4, occurrence: 19
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 38
XXX number of pointers point to scalars: 67
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 33.6
XXX average alias set size: 1.35

XXX times a non-volatile is read: 412
XXX times a non-volatile is write: 160
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 104
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 26
   depth: 2, occurrence: 22
   depth: 3, occurrence: 14
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 12.8
XXX percentage an existing variable is used: 87.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

