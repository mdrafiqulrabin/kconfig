/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1623564180
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint8_t  f0;
};

struct S1 {
   const int16_t  f0;
   const int32_t  f1;
   uint32_t  f2;
   struct S0  f3;
   int32_t  f4;
   int32_t  f5;
   uint8_t  f6;
   int32_t  f7;
   int16_t  f8;
   int16_t  f9;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static float  func_1(void);
static int32_t * func_2(struct S0  p_3, int32_t * p_4, int32_t * p_5, int32_t  p_6, int32_t  p_7);
inline static const struct S0  func_11(struct S1  p_12);
inline static struct S1  func_13(int32_t * p_14, int32_t * p_15, int32_t  p_16);
static const float  func_19(uint8_t  p_20, uint8_t  p_21, int32_t * const  p_22, uint16_t  p_23, int32_t * p_24);
static int32_t * const  func_25(int32_t * p_26);
inline static int32_t * func_27(const int16_t  p_28, int32_t  p_29, struct S1  p_30);
static struct S1  func_32(const uint32_t  p_33, int32_t * p_34, int32_t * p_35);
inline static int32_t  func_45(int32_t * p_46, struct S1  p_47);
inline static struct S1  func_48(int32_t  p_49, int32_t * p_50, uint32_t  p_51);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_1(void)
{ /* block id: 0 */
    struct S0 l_8 = {0x21};
    int32_t l_18 = 1;
    int32_t *l_17 = &l_18;
    int16_t l_31 = 0x9643;
    struct S1 l_631 = {6,0x82C03D9F,4294967290U,{255U},-1,-10,1U,0xAC4A01EF,-9,0x305F};
    uint32_t l_636 = 0x26FE76D8;
    int16_t l_637 = 0x10DB;
    uint32_t l_638 = 1U;
    int32_t **l_739 = &l_17;
    (*l_739) = func_2(l_8, (((((uint32_t)(func_11((func_13(l_17, &l_18, (func_19((*l_17), (*l_17), func_25(func_27((*l_17), l_31, func_32(((*l_17) <= ((uint16_t)(((int16_t)(&l_18 == (void*)0) + (int16_t)(*l_17)) != (*l_17)) / (uint16_t)(*l_17))), &l_18, &l_18))), (*l_17), &l_18) , (*l_17))) , l_631)) , l_636) % (uint32_t)l_631.f6) ^ l_637) >= l_631.f2) , &l_18), l_17, l_631.f9, l_638);
    /* statement id: 270 */
    assert (l_17 == 0);
    return l_631.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(struct S0  p_3, int32_t * p_4, int32_t * p_5, int32_t  p_6, int32_t  p_7)
{ /* block id: 246 */
    int32_t l_642 = (-8);
    int32_t *l_641 = &l_642;
    int32_t **l_640 = &l_641;
    int32_t ***l_639 = &l_640;
    int32_t ****l_660 = &l_639;
    float * const ** const **l_691 = (void*)0;
    struct S1 ***l_697 = (void*)0;
    struct S1 ****l_696 = &l_697;
    struct S0 l_720 = {2U};
    struct S0 *l_719 = &l_720;
    struct S0 **l_718 = &l_719;
    struct S1 l_732 = {0,0x02DA0436,4294967295U,{0x2F},0x517E33AE,0xDACBE4A6,0xAA,0xF882D50D,0x812F,0xAD02};
    int32_t *l_737 = &l_642;
    if ((l_639 != &l_640))
    { /* block id: 247 */
        int32_t l_653 = 0xCBB5A18C;
        struct S1 l_661 = {0xEBB5,1,0x53093049,{0x0F},0x062198D4,-1,0xFA,-8,-8,0};
        float ** const l_690 = (void*)0;
        float ** const *l_689 = &l_690;
        float ** const **l_688 = &l_689;
        float ** const *** const l_687 = &l_688;
        if (((p_3.f0 >= ((p_6 , ((float)((float)((((float)((**l_640) == (((func_32(((uint16_t)(p_3.f0 != (((uint16_t)((4294967295U <= l_653) || ((uint32_t)(0x497A & ((((float)p_3.f0 + (float)(***l_639)) , l_660) != (void*)0)) / (uint32_t)(*p_5))) << (uint16_t)l_653) && l_653)) + (uint16_t)0x4D9F), &l_653, &l_653) , l_661) , 0x2.1C3756p+84) != 0x5.DF5D26p+79)) + (float)p_7) != l_661.f3.f0) > l_661.f2) + (float)0xE.75DC9Fp+81) - (float)(**l_640))) != l_661.f8)) , 0xC723E837))
        { /* block id: 248 */
            struct S0 *l_662 = &l_661.f3;
lbl_663:
            (**l_640) = (**l_640);
            (*l_662) = p_3;
            if (l_661.f1)
                goto lbl_663;
        }
        else
        { /* block id: 252 */
            float l_692 = 0xE.FCA246p+88;
            int32_t l_693 = (-2);
            uint32_t l_694 = 0U;
            struct S0 *l_695 = &l_661.f3;
            (**l_640) = (-5);
            (*l_695) = (((float)(0x0.1A0823p+32 == p_3.f0) + (float)(((float)((float)((((!((((float)p_3.f0 + (float)(((float)(((float)((float)(((p_7 != (-0x4.6p+1)) >= ((float)((((uint16_t)((int16_t)p_6 << (int16_t)l_661.f5) >> (uint16_t)15) , ((((((((uint32_t)(l_687 != l_691) - (uint32_t)l_661.f3.f0) != p_6) >= (-1)) >= (-8)) , p_6) , p_3.f0) , 0x3.415CB8p+9)) == p_3.f0) - (float)(-0x1.9p+1))) >= p_3.f0) - (float)p_6) - (float)p_7) <= l_693) - (float)l_693) > l_694)) < p_3.f0) < l_661.f7)) < p_3.f0) != l_693) != p_3.f0) / (float)p_3.f0) - (float)0x1.Ap+1) <= p_7)) , p_3);
        }
    }
    else
    { /* block id: 256 */
        const struct S1 *l_702 = (void*)0;
        const struct S1 **l_701 = &l_702;
        const struct S1 ***l_700 = &l_701;
        const struct S1 ****l_699 = &l_700;
        const struct S1 *****l_698 = &l_699;
        int32_t *l_705 = &l_642;
        int32_t *l_707 = (void*)0;
        (*l_698) = l_696;
        /* statement id: 257 */
        assert (l_699 == &l_697);
        for (p_6 = 15; (p_6 == (-30)); p_6 -= 5)
        { /* block id: 260 */
            int32_t *l_706 = &l_642;
            return l_707;
            /* statement id: 261 */
            //assert (func_2_rv == 0);
        }
    }
    if (((uint16_t)((((uint32_t)(((int16_t)(*l_641) >> (int16_t)5) != (((int16_t)((uint16_t)(((l_718 == &l_719) , ((int32_t)((**l_718) , ((1U & ((int16_t)((uint16_t)(((int16_t)(!(p_7 || ((uint32_t)(**l_640) + (uint32_t)(p_3.f0 || (l_732 , 0x1F85))))) >> (int16_t)11) , p_3.f0) / (uint16_t)p_7) % (int16_t)8)) & p_6)) / (int32_t)(****l_660))) == (**l_640)) >> (uint16_t)(****l_660)) - (int16_t)(****l_660)) == (*p_4))) - (uint32_t)(-1)) != (*p_5)) < (*p_5)) >> (uint16_t)15))
    { /* block id: 264 */
        int32_t *l_733 = (void*)0;
        (*l_641) = (***l_639);
        return l_733;
        /* statement id: 266 */
        //assert (func_2_rv == 0);
    }
    else
    { /* block id: 267 */
        int32_t *l_734 = &l_732.f7;
        int32_t *l_735 = &l_732.f7;
        int32_t *l_736 = &l_732.f7;
        int32_t *l_738 = (void*)0;
        return l_738;
        /* statement id: 268 */
        //assert (func_2_rv == 0);
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S0  func_11(struct S1  p_12)
{ /* block id: 243 */
    struct S0 l_633 = {247U};
    struct S0 * const l_632 = &l_633;
    struct S0 *l_635 = &l_633;
    struct S0 **l_634 = &l_635;
    (*l_634) = l_632;
    return p_12.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_13(int32_t * p_14, int32_t * p_15, int32_t  p_16)
{ /* block id: 230 */
    int32_t *l_621 = (void*)0;
    int32_t * const *l_628 = (void*)0;
    int32_t * const ** const l_627 = &l_628;
    int32_t * const ** const *l_626 = &l_627;
    struct S1 l_630 = {-9,0xDE4FB770,0xC6EDD253,{0x3C},0x9127B27D,0xE4A3F8B8,0xF6,0x51F0056F,0x0E71,0x966C};
    for (p_16 = (-12); (p_16 > (-14)); p_16 -= 1)
    { /* block id: 233 */
        int32_t *l_618 = (void*)0;
        int32_t **l_619 = (void*)0;
        int32_t **l_620 = &l_618;
        struct S1 l_629 = {0,0,0xF42AA8ED,{0x01},0,0x2E29E077,1U,2,0x968B,0x64C3};
        (*l_620) = l_618;
        (*l_620) = l_621;
        if (((*p_15) & (((((*p_15) | ((*p_15) & (*p_15))) & 0x4BFB) || (0x6A17E3FE > ((int32_t)((uint16_t)((l_626 != &l_627) ^ (*p_14)) >> (uint16_t)p_16) + (int32_t)0xF2529F0A))) & p_16)))
        { /* block id: 236 */
            return l_629;
        }
        else
        { /* block id: 238 */
            if ((*p_14))
                break;
        }
    }
    return l_630;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_19(uint8_t  p_20, uint8_t  p_21, int32_t * const  p_22, uint16_t  p_23, int32_t * p_24)
{ /* block id: 157 */
    float l_382 = 0x1.4F290Fp+27;
    int32_t l_383 = (-10);
    float *l_386 = &l_382;
    float **l_385 = &l_386;
    float ***l_384 = &l_385;
    struct S1 l_394 = {0xCB4A,0x6B666AED,4294967286U,{255U},7,0xE04F06C8,0xE7,-1,0,0x3CB0};
    struct S1 *l_393 = &l_394;
    struct S1 **l_392 = &l_393;
    int32_t ***l_412 = (void*)0;
    int32_t l_413 = 0x3B58B0D0;
    float l_436 = 0x4.Bp+1;
    uint32_t l_455 = 5U;
    float l_478 = 0x0.C34FCCp-46;
    int32_t l_511 = 0xED96D27C;
    int32_t **l_538 = (void*)0;
    int32_t l_610 = 0xB7E95BB0;
lbl_391:
    l_383 = (l_383 <= ((l_383 , l_384) == &l_385));
    if (l_383)
    { /* block id: 159 */
        struct S0 *l_396 = (void*)0;
        const int32_t **l_401 = (void*)0;
        const int32_t ***l_400 = &l_401;
        const struct S1 *l_420 = (void*)0;
        const struct S1 * const *l_419 = &l_420;
        float l_459 = 0x0.6p-1;
        float ***l_479 = &l_385;
        int32_t l_522 = 0x13600E5B;
        for (p_20 = (-12); (p_20 == 30); p_20 += 1)
        { /* block id: 162 */
            struct S0 * const l_395 = &l_394.f3;
            int32_t ***l_399 = (void*)0;
            float * const *l_410 = (void*)0;
            int32_t l_417 = 4;
            float l_444 = 0xD.B04B00p-80;
            uint32_t l_476 = 4294967291U;
            struct S1 l_537 = {0,0xB15D3C87,0x4C3B89E9,{0x67},0x792597C3,4,9U,3,0x30D6,0x8AFE};
            struct S1 **l_568 = &l_393;
            for (p_23 = 0; (p_23 >= 39); p_23 += 1)
            { /* block id: 165 */
                struct S0 l_407 = {255U};
                float **l_411 = &l_386;
                uint32_t l_449 = 1U;
                if (p_23)
                    goto lbl_391;
            }
            (*l_568) = (*l_419);
            /* statement id: 203 */
            assert (l_393 == 0);
            l_394.f3 = l_394.f3;
        }
        for (l_394.f6 = 0; (l_394.f6 > 44); l_394.f6 += 1)
        { /* block id: 208 */
            struct S0 l_573 = {0x13};
            int32_t *l_607 = &l_394.f7;
            int32_t * const *l_606 = &l_607;
            int32_t * const **l_605 = &l_606;
            int32_t * const ***l_604 = &l_605;
            for (l_394.f3.f0 = 0; (l_394.f3.f0 < 8); l_394.f3.f0 += 4)
            { /* block id: 211 */
                struct S0 *l_574 = &l_573;
                int32_t l_579 = 9;
                const struct S1 ** const l_584 = &l_420;
                (*l_574) = (p_21 , l_573);
                (*l_574) = l_573;
                (*p_24) = (p_21 || ((((uint16_t)((((((uint16_t)l_579 >> (uint16_t)((((uint32_t)((uint16_t)p_20 >> (uint16_t)10) / (uint32_t)p_23) < ((void*)0 == l_584)) < ((((uint16_t)((uint16_t)(0x3DF0D187 <= 0xA712A8B4) >> (uint16_t)11) >> (uint16_t)((((int16_t)((&l_573 == l_574) && 0U) % (int16_t)l_579) ^ p_21) > p_21)) | p_21) || l_522))) | 0x5FAF) , (*l_574)) , 0x1D7D) , p_20) << (uint16_t)1) | 0x11E9D9F5) != p_23));
                (*l_386) = ((0xD.530FA9p+0 > ((float)p_20 - (float)p_23)) >= ((((float)l_579 - (float)(p_21 != ((l_573.f0 , ((((float)((float)(((-(float)0xA.B78254p-17) >= ((float)(l_394.f3 , (l_604 == &l_605)) - (float)p_23)) != p_21) - (float)p_21) / (float)(-0x1.5p+1)) > p_21) , l_584)) == l_584))) < 0x7.CF205Cp-0) <= p_21));
            }
        }
        for (l_455 = 0; (l_455 != 57); l_455 += 1)
        { /* block id: 220 */
            int16_t l_611 = 0;
            if (l_610)
                break;
            l_611 = p_21;
        }
        p_24 = p_24;
    }
    else
    { /* block id: 225 */
        struct S0 *l_612 = &l_394.f3;
        int32_t *l_613 = (void*)0;
        int32_t **l_614 = (void*)0;
        int32_t **l_615 = &l_613;
        (*l_612) = l_394.f3;
        (*l_615) = l_613;
    }
    return l_394.f3.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_25(int32_t * p_26)
{ /* block id: 133 */
    int32_t l_343 = 0;
    uint8_t l_349 = 0x4D;
    struct S0 l_353 = {0x1A};
    struct S0 *l_381 = &l_353;
    for (l_343 = 0; (l_343 < 6); l_343 += 1)
    { /* block id: 136 */
        int32_t **l_346 = (void*)0;
        int32_t *l_348 = (void*)0;
        int32_t **l_347 = &l_348;
        (*l_347) = p_26;
        /* statement id: 137 */
        //assert (l_348 == 0 || l_348 == &l_18);
        return p_26;
        /* statement id: 138 */
        //assert (func_25_rv == 0 || func_25_rv == &l_18);
    }
    l_349 = 7;
    for (l_343 = 17; (l_343 <= (-30)); l_343--)
    { /* block id: 143 */
        struct S0 l_352 = {0x08};
        struct S0 *l_354 = &l_353;
        struct S1 l_370 = {0xED76,0xB617F0D1,0x7AFC93EF,{254U},1,0x2F358D3A,0xA6,-1,7,0x35DC};
        int32_t **l_371 = (void*)0;
        int32_t *l_373 = (void*)0;
        int32_t **l_372 = &l_373;
        l_352 = l_352;
        (*l_354) = l_353;
        (*l_372) = func_27(((uint32_t)(((uint16_t)(l_352.f0 || l_352.f0) % (uint16_t)((0xA35E8C61 && (l_352.f0 == (((int16_t)(~l_349) / (int16_t)(((l_352.f0 <= ((((((float)((float)(l_352.f0 == ((float)((float)((*l_354) , (l_352.f0 > l_353.f0)) / (float)l_343) + (float)l_352.f0)) / (float)0x0.0p+1) + (float)l_353.f0) != l_352.f0) <= l_349) <= l_349) <= l_343)) , l_352.f0) , l_343)) , 0xF228F6AB))) || l_343)) >= l_352.f0) + (uint32_t)l_353.f0), l_352.f0, l_370);
        if (l_353.f0)
        { /* block id: 147 */
            uint16_t l_374 = 65532U;
            int32_t *l_375 = &l_370.f7;
            int32_t * const l_376 = &l_370.f7;
            (*l_375) = (l_374 <= l_374);
            return p_26;
            /* statement id: 149 */
            //assert (func_25_rv == 0 || func_25_rv == &l_18);
        }
        else
        { /* block id: 150 */
            int32_t l_378 = 0x73FCD9E7;
            int32_t l_379 = 0x4337131A;
            struct S0 *l_380 = &l_352;
            l_379 = (-(float)(((l_378 >= l_349) != l_353.f0) == l_353.f0));
            l_380 = (void*)0;
            /* statement id: 152 */
            assert (l_380 == 0);
        }
    }
    (*l_381) = l_353;
    return p_26;
    /* statement id: 156 */
    //assert (func_25_rv == 0 || func_25_rv == &l_18);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_27(const int16_t  p_28, int32_t  p_29, struct S1  p_30)
{ /* block id: 27 */
    int32_t l_142 = 0;
    int32_t *l_141 = &l_142;
    int32_t *l_143 = &l_142;
    uint16_t l_151 = 0x2E92;
    struct S0 l_159 = {0U};
    struct S0 *l_158 = &l_159;
    int32_t **l_221 = &l_141;
    int32_t ***l_220 = &l_221;
    float l_226 = 0x1.1p+1;
    float *l_225 = &l_226;
    float ** const l_224 = &l_225;
    struct S1 *l_304 = (void*)0;
    struct S1 *** const l_326 = (void*)0;
    int16_t l_329 = 0x47F7;
    int32_t *l_337 = &l_142;
    int32_t *l_338 = &l_142;
    int32_t *l_339 = &l_142;
    int32_t *l_340 = &l_142;
    int32_t *l_341 = &l_142;
    int32_t *l_342 = (void*)0;
    for (p_30.f2 = 0; (p_30.f2 < 41); p_30.f2 += 7)
    { /* block id: 30 */
        uint32_t l_126 = 0x1EF9C6BE;
        int32_t l_140 = (-2);
        int32_t *l_139 = &l_140;
        int32_t *l_145 = (void*)0;
        for (p_30.f8 = 10; (p_30.f8 < 16); p_30.f8 += 1)
        { /* block id: 33 */
            uint16_t l_135 = 3U;
            float l_136 = 0x6.8BCBADp+44;
            int32_t l_137 = (-1);
            float *l_138 = &l_136;
            int32_t *l_144 = (void*)0;
            (*l_138) = (!(((float)(((float)((float)p_30.f9 - (float)((float)(((((-0x10.Ep+1) > (-(float)((!l_126) , (0xB.2F6CA1p-51 > (p_30.f1 == (((p_30.f4 < ((float)((float)((float)p_30.f2 / (float)((((int16_t)(0 & l_135) % (int16_t)l_135) , p_28) < l_126)) / (float)p_30.f2) - (float)0x8.Fp+1)) < l_135) == 0x9.E681B6p-42)))))) != 0x1.Ep+1) < l_136) >= l_126) + (float)0x8.B4F01Bp+17)) / (float)l_137) != p_30.f3.f0) / (float)p_30.f3.f0) != p_30.f1));
            return l_144;
            /* statement id: 35 */
            //assert (func_27_rv == 0);
        }
        return l_145;
        /* statement id: 37 */
        //assert (func_27_rv == 0);
    }
    if (((uint16_t)0U >> (uint16_t)((((((((((uint16_t)(*l_143) - (uint16_t)(!(l_151 != p_30.f6))) != ((uint16_t)(((uint32_t)((p_30.f4 >= (*l_143)) >= 4U) % (uint32_t)(*l_141)) != (p_30.f3.f0 < (*l_143))) + (uint16_t)p_30.f9)) , 4294967291U) == (*l_143)) | (*l_143)) >= 0x2B89) != (*l_143)) != (*l_143)) > (*l_141))))
    { /* block id: 39 */
        struct S0 l_157 = {247U};
        struct S0 *l_156 = &l_157;
        const int32_t *l_175 = (void*)0;
        const int32_t **l_174 = &l_175;
        const int32_t ***l_173 = &l_174;
        const int32_t ****l_172 = &l_173;
        struct S1 l_200 = {0,0x48171D36,0x73A9DBB0,{1U},-10,-1,0x94,0xF1CC1EF9,0,1};
        struct S1 *l_199 = &l_200;
        int32_t *l_204 = (void*)0;
lbl_198:
        l_158 = l_156;
        /* statement id: 40 */
        assert (l_158 == &l_157);
        (*l_156) = (*l_156);
        for (l_142 = (-11); (l_142 <= (-15)); l_142 -= 8)
        { /* block id: 44 */
            int32_t l_163 = 0x5BCDDAFE;
            int32_t *l_162 = &l_163;
            (*l_162) = (*l_143);
            if ((((uint32_t)((int16_t)p_30.f8 >> (int16_t)((((int32_t)p_30.f3.f0 - (int32_t)((p_30.f3 , (((-5) | p_29) > ((((uint16_t)((void*)0 == l_172) + (uint16_t)((int32_t)(-4) % (int32_t)p_30.f9)) || p_29) != 1))) || (*l_162))) ^ p_30.f2) & 0)) + (uint32_t)p_30.f2) != (*l_162)))
            { /* block id: 46 */
                int32_t l_183 = 7;
                int32_t *l_203 = &l_200.f7;
                if ((((uint16_t)(((int16_t)((!l_183) , (((uint32_t)((uint16_t)(*l_162) - (uint16_t)65535U) + (uint32_t)(*l_143)) >= (((uint16_t)p_30.f8 % (uint16_t)((((((p_30.f8 == ((*l_141) ^ ((uint16_t)(0x3928 >= 0) << (uint16_t)p_29))) || p_30.f3.f0) , (void*)0) != (void*)0) && 0x8387) & p_30.f9)) ^ l_183))) >> (int16_t)p_28) <= p_30.f4) / (uint16_t)(*l_162)) , (-5)))
                { /* block id: 47 */
                    (*l_158) = (*l_156);
                }
                else
                { /* block id: 49 */
                    uint16_t l_192 = 0x529F;
                    l_192 = l_183;
                }
                for (p_29 = 8; (p_29 < (-19)); p_29--)
                { /* block id: 54 */
                    float *l_197 = (void*)0;
                    (*l_162) = ((uint16_t)p_28 % (uint16_t)(*l_162));
                    if (((void*)0 != l_197))
                    { /* block id: 56 */
                        if (p_29)
                            goto lbl_198;
                        l_199 = &p_30;
                        /* statement id: 58 */
                        assert (l_199 == &p_30);
                    }
                    else
                    { /* block id: 59 */
                        float **l_202 = &l_197;
                        float ***l_201 = &l_202;
                        (*l_201) = &l_197;
                        (**l_173) = l_197;
                        if ((*l_143))
                            continue;
                        return l_197;
                        /* statement id: 63 */
                        //assert (func_27_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_199 == &p_30);
                }
                return l_204;
                /* statement id: 66 */
                //assert (func_27_rv == 0);
            }
            else
            { /* block id: 67 */
                (*l_162) = ((int16_t)3 >> (int16_t)(!(0U > p_30.f3.f0)));
                return l_204;
                /* statement id: 69 */
                //assert (func_27_rv == 0);
            }
        }
    }
    else
    { /* block id: 72 */
        uint16_t l_212 = 0x1C7B;
        float * const *l_215 = (void*)0;
        int32_t **l_219 = &l_143;
        int32_t ***l_218 = &l_219;
        struct S0 l_246 = {255U};
        struct S1 l_282 = {0,0x33F5BE08,4U,{4U},0xCF5ED426,-1,1U,0x968B5351,0x7D06,1};
        struct S1 *l_281 = &l_282;
        struct S1 **l_328 = &l_281;
        struct S1 ***l_327 = &l_328;
        int32_t *l_333 = (void*)0;
    }
    /* facts after branching */
    //assert (l_158 == &l_159 || l_158 == dangling);
    for (p_30.f5 = 15; (p_30.f5 <= 11); p_30.f5--)
    { /* block id: 129 */
        struct S0 *l_336 = &l_159;
        (*l_336) = p_30.f3;
    }
    return l_342;
    /* statement id: 132 */
    //assert (func_27_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_32(const uint32_t  p_33, int32_t * p_34, int32_t * p_35)
{ /* block id: 1 */
    const int32_t l_41 = 0x497C242E;
    const int32_t *l_40 = &l_41;
    int32_t l_42 = 7;
    uint32_t l_56 = 0x1BFDB9CE;
    int32_t *l_96 = (void*)0;
    int32_t **l_95 = &l_96;
    int32_t ** const *l_94 = &l_95;
    struct S0 l_106 = {1U};
    int32_t *l_107 = &l_42;
    struct S1 l_110 = {-8,0x51B8D994,0x87C28FDD,{251U},0x8B1D6983,1,1U,0xF915BDED,0x8560,-1};
lbl_93:
    l_40 = l_40;
    for (l_42 = (-21); (l_42 < (-11)); l_42 += 3)
    { /* block id: 5 */
        uint8_t l_54 = 0xAB;
        struct S1 l_55 = {-9,0x33EF28F0,9U,{0xA7},-4,-1,0x60,0xA86E60E4,6,-1};
        int32_t ***l_92 = (void*)0;
        int32_t ****l_97 = &l_92;
        if (func_45(p_34, func_48((((((-3) < ((l_54 ^ l_54) >= ((void*)0 != p_34))) <= (((l_55 , (p_35 == p_35)) ^ l_55.f1) < p_33)) != 0xE2251792) > l_55.f3.f0), &l_42, l_56)))
        { /* block id: 14 */
            int32_t *l_88 = (void*)0;
            int32_t *l_89 = &l_55.f7;
            (*l_89) = 0;
            if (l_55.f7)
                break;
        }
        else
        { /* block id: 17 */
            int32_t *l_91 = (void*)0;
            int32_t **l_90 = &l_91;
            (*l_90) = (void*)0;
            l_92 = &l_90;
            /* statement id: 19 */
            assert (l_92 == &l_90);
        }
        /* facts after branching */
        //assert (l_92 == dangling || l_92 == 0);
        if (l_55.f9)
            goto lbl_93;
        (*l_97) = l_94;
        /* statement id: 22 */
        assert (l_92 == &l_95);
    }
    (*l_107) = (65535U | (((uint32_t)4294967292U % (uint32_t)((((((uint16_t)((*l_40) < (((int16_t)(((uint32_t)(&p_35 != &p_35) - (uint32_t)((l_106 , l_107) == (*l_95))) == ((int32_t)(((-4) & p_33) && (*l_40)) + (int32_t)0x7AA6B01F)) << (int16_t)(*l_107)) == 1)) / (uint16_t)(*l_107)) || 0xC446) && (*p_34)) | (*l_107)) | (*l_40))) , p_33));
    (*l_107) = (*l_40);
    return l_110;
}


/* ------------------------------------------ */
/* 
 * reads : l_18 l_653
 * writes:
 */
inline static int32_t  func_45(int32_t * p_46, struct S1  p_47)
{ /* block id: 9 */
    int32_t **l_60 = (void*)0;
    int32_t ***l_59 = &l_60;
    int32_t l_77 = 1;
    int32_t *l_87 = &l_77;
    (*l_59) = (void*)0;
    (*l_87) = ((((int32_t)((p_47.f5 != ((int16_t)((int16_t)0x6160 % (int16_t)((uint32_t)p_47.f3.f0 % (uint32_t)(0x3843C9D4 && ((uint32_t)(((int16_t)((int16_t)(((uint32_t)(l_77 && 0xA517) / (uint32_t)(p_47.f4 ^ (p_47.f9 || (((uint16_t)((((int16_t)(((float)(!((float)p_47.f7 + (float)p_47.f8)) + (float)0x5.2223AAp-16) , p_47.f2) >> (int16_t)7) & (-4)) >= p_47.f6) >> (uint16_t)p_47.f5) >= (*p_46))))) & l_77) << (int16_t)13) - (int16_t)p_47.f7) <= 0x93D46743) + (uint32_t)0)))) << (int16_t)p_47.f6)) >= 0xFDCAF09E) % (int32_t)(*p_46)) || 0xA737) & (-2));
    (*l_87) = (*l_87);
    return (*p_46);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_48(int32_t  p_49, int32_t * p_50, uint32_t  p_51)
{ /* block id: 6 */
    int32_t l_57 = 1;
    struct S1 l_58 = {0x6EE0,4,0xDCF67A9F,{0x56},-9,-10,0x93,-1,-7,-2};
    l_57 = l_57;
    return l_58;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 141
   depth: 1, occurrence: 8
   depth: 2, occurrence: 13
XXX total union variables: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 122
   depth: 2, occurrence: 20
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 12, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 27, occurrence: 2
   depth: 28, occurrence: 1
   depth: 34, occurrence: 2

XXX total number of pointers: 171

XXX times a variable address is taken: 146
XXX times a pointer is dereferenced on RHS: 110
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 10
   depth: 3, occurrence: 15
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 66
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 473

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 205
   level: 2, occurrence: 44
   level: 3, occurrence: 46
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 82
XXX number of pointers point to scalars: 66
XXX number of pointers point to structs: 23
XXX percent of pointers has null in alias set: 35.7
XXX average alias set size: 1.13

XXX times a non-volatile is read: 800
XXX times a non-volatile is write: 191
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 107
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 30
   depth: 2, occurrence: 26
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
********************* end of statistics **********************/

