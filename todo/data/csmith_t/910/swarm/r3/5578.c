/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3347351596
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint32_t  f0;
   int32_t  f1;
};

union U1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_11 = 0xF845L;
static int32_t g_36 = 0x6917AB6DL;
static int32_t *g_48 = &g_36;
static union U0 *g_58 = (void*)0;
static int32_t **g_62 = &g_48;
static int32_t g_119 = 0L;
static int16_t g_120 = 0x7421L;
static uint32_t g_145 = 0xB0F43182L;
static float g_147 = (-0x1.3p-1);
static int32_t g_161 = 7L;
static const union U1 g_171 = {0x3B69C797L};
static union U0 g_183 = {18446744073709551608UL};
static float ***g_243 = (void*)0;
static int32_t g_282 = 9L;
static union U1 g_332 = {0x293A8304L};
static union U1 *g_331 = &g_332;
static union U1 **g_330 = &g_331;
static union U0 **g_339 = &g_58;
static union U0 ***g_338 = &g_339;
static union U1 ***g_342 = &g_330;
static int32_t *g_344 = &g_36;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_33(void);
static int32_t ** func_37(int32_t * p_38, int32_t ** p_39, int32_t * p_40, int32_t ** p_41, uint32_t  p_42);
static int32_t * func_43(int32_t ** p_44);
static int32_t ** func_49(const int32_t  p_50, const int16_t  p_51, int32_t  p_52, uint32_t  p_53);
static int32_t ** func_55(int32_t * p_56, int32_t ** p_57);
static uint16_t  func_67(const int32_t ** p_68);
static const int32_t ** func_69(int32_t *** p_70, int32_t  p_71);
static union U0  func_85(union U1  p_86, int32_t ** p_87, int32_t ** p_88);
static union U1  func_89(const int16_t  p_90, int32_t * p_91, uint32_t  p_92, uint32_t  p_93, int32_t  p_94);
static uint32_t  func_97(int32_t *** p_98, union U0 ** p_99, uint32_t  p_100, int32_t *** p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_11 g_36 g_48 g_58 g_62 g_120 g_145 g_119 g_171 g_147 g_171.f0 g_183.f0 g_183.f1 g_243 g_161 g_282 g_330 g_344
 * writes: g_36 g_58 g_62 g_48 g_11 g_119 g_120 g_147 g_161 g_145 g_282 g_338 g_342
 */
static uint32_t  func_33(void)
{ /* block id: 36 */
    const uint16_t l_34 = 0x1546L;
    union U1 l_47 = {0xC0223DECL};
    const uint32_t l_54 = 18446744073709551606UL;
    int32_t ***l_72 = &g_62;
    int32_t l_180 = 0xB245C393L;
    uint32_t l_199 = 0xCAF5ADCEL;
    uint32_t l_235 = 4294967295UL;
    int32_t *l_281 = &g_282;
    union U0 l_311 = {1UL};
    union U0 **l_321 = &g_58;
    int32_t l_329 = (-3L);
    if (l_34)
    { /* block id: 37 */
        int32_t *l_35 = &g_36;
        int32_t ***l_63 = (void*)0;
        int32_t ***l_64 = &g_62;
        union U0 *l_182 = &g_183;
        union U0 l_270 = {6UL};
        union U1 *l_284 = (void*)0;
        union U1 **l_283 = &l_284;
        (*l_35) = g_11;
        (*l_64) = func_37(l_35, &l_35, func_43((((int16_t)(l_47 , g_36) << (int16_t)g_11) , (void*)0)), func_49((((0x48648546L <= (*g_48)) ^ (*g_48)) | (*g_48)), l_54, g_36, (*l_35)), (*l_35));
        if (((uint16_t)(l_54 , func_67(func_69(l_72, g_36))) - (uint16_t)((*l_64) == g_62)))
        { /* block id: 112 */
            uint8_t l_192 = 255UL;
            uint32_t l_196 = 0xA0C7C7AFL;
            union U1 l_209 = {18446744073709551615UL};
            float *l_256 = (void*)0;
            float **l_255 = &l_256;
            union U0 **l_259 = (void*)0;
            union U0 **l_260 = &g_58;
            uint32_t l_266 = 0x03D31593L;
            int32_t l_297 = 0L;
            float ****l_300 = &g_243;
            for (g_145 = (-10); (g_145 != 6); g_145 += 1)
            { /* block id: 115 */
                uint8_t l_181 = 1UL;
                int32_t *l_193 = &g_36;
                float *l_204 = &g_147;
                float **l_203 = &l_204;
                int32_t ***l_216 = &g_62;
                if (func_97(&g_62, ((((float)((((((((-1L) & (((l_180 < l_181) , (l_182 != (void*)0)) == ((int16_t)g_119 + (int16_t)((int16_t)((int16_t)l_181 - (int16_t)(((int16_t)g_36 + (int16_t)l_181) , l_192)) >> (int16_t)14)))) & l_181) , &g_62) == &g_62) > 0x4.C1BE54p+59) > 0x7.A2DCC7p-8) <= g_120) - (float)(-0x1.9p-1)) == g_147) , (void*)0), l_181, &g_62))
                { /* block id: 116 */
                    float l_202 = 0x1.Fp+1;
                    int32_t l_214 = 0x55FCFD51L;
                    union U1 **l_237 = (void*)0;
                    union U1 *l_239 = &l_209;
                    union U1 **l_238 = &l_239;
                    if ((65527UL & (&g_62 == &g_62)))
                    { /* block id: 117 */
                        const int32_t *l_195 = &g_36;
                        const int32_t **l_194 = &l_195;
                        float ***l_205 = (void*)0;
                        float ***l_206 = &l_203;
                        (*g_62) = l_193;
                        (*l_193) = ((func_67(l_194) != (g_171.f0 , ((((l_196 & ((int32_t)(0x033A2A3AL ^ l_199) + (int32_t)0L)) , &g_183) == ((((((uint16_t)g_183.f0 % (uint16_t)l_196) > g_145) != 0x671E2B22L) , 0x6E7879B0L) , &g_183)) ^ 0x9514ADC3L))) < g_120);
                        (*l_206) = l_203;
                    }
                    else
                    { /* block id: 121 */
                        const int32_t l_215 = 0xD7125C51L;
                        uint8_t l_234 = 4UL;
                        int16_t l_236 = 0L;
                        (*g_48) = (((int16_t)g_119 << (int16_t)4) , (**g_62));
                        (*l_193) = (((((int16_t)((uint16_t)((uint16_t)__builtin_ia32_crc32qi(g_119, g_145) << (uint16_t)(((uint16_t)(((int32_t)(-(int32_t)((-(float)((float)(-(float)0x0.Cp+1) + (float)((***l_72) == 0xA.A455DDp-43))) , (1L && (((uint16_t)l_215 << (uint16_t)8) < ((***l_72) | (***l_216)))))) + (int32_t)l_234) <= l_235) << (uint16_t)l_236) < 0xC00CL)) - (uint16_t)g_171.f0) >> (int16_t)g_183.f1) && l_214) && (-1L)) && g_145);
                        return g_183.f1;
                    }
                    (*l_238) = (void*)0;
                    for (l_196 = 27; (l_196 != 34); l_196 += 1)
                    { /* block id: 129 */
                        float ***l_244 = &l_203;
                        int32_t l_247 = (-1L);
                        int32_t ***l_248 = (void*)0;
                        l_214 = ((!(g_243 != l_244)) <= (((float)((**g_62) , g_183.f1) + (float)(***l_216)) == g_119));
                    }
                }
                else
                { /* block id: 132 */
                    int16_t l_249 = 0x740BL;
                    (**l_72) = (**l_64);
                    return l_249;
                }
                (**l_72) = func_43(&g_48);
            }
            (*l_260) = (((((int32_t)((__builtin_parity(((0x6AD940D4L & ((**g_62) || (((!((float)(l_255 != ((((l_209.f0 && l_196) , ((*g_62) == (l_196 , (**l_64)))) == ((uint32_t)g_183.f1 % (uint32_t)0x1C3764CFL)) , (void*)0)) - (float)(***l_72))) , g_36) , 9UL))) , 0x65B679A5L)) >= l_196) >= 4UL) % (int32_t)(*g_48)) != 0xE7278546L) , (***l_72)) , &g_183);
            if ((g_11 == ((!g_161) < g_120)))
            { /* block id: 139 */
                uint8_t l_265 = 0x74L;
                const int32_t *l_277 = &g_161;
                const int32_t **l_276 = &l_277;
                float *l_285 = &g_147;
                if ((&g_183 != (l_192 , (*l_260))))
                { /* block id: 140 */
                    uint32_t l_264 = 1UL;
                    int32_t *l_268 = (void*)0;
                    (*g_48) = (**g_62);
                    if (((*g_48) == ((((uint16_t)g_145 >> (uint16_t)__builtin_bswap64((l_264 || l_265))) != l_264) || (g_145 , l_266))))
                    { /* block id: 142 */
                        float *l_267 = &g_147;
                        (**l_72) = (*g_62);
                        (*l_35) = 0L;
                        (*l_267) = l_264;
                    }
                    else
                    { /* block id: 146 */
                        int32_t *l_269 = &g_161;
                        (*l_35) = (func_89(g_171.f0, l_268, (&l_268 == &g_48), l_265, g_120) , (0x8FA795F4L ^ g_145));
                        l_269 = (*g_62);
                    }
                    if ((l_270 , (g_36 ^ (***l_72))))
                    { /* block id: 150 */
                        int32_t **l_271 = &l_35;
                        (*l_271) = func_43(func_55(func_43(l_271), &g_48));
                    }
                    else
                    { /* block id: 152 */
                        (*l_35) = (-5L);
                    }
                }
                else
                { /* block id: 155 */
                    (*g_62) = func_43(&g_48);
                }
                (***l_64) = 0x85720E6CL;
                (*l_285) = ((float)((float)((((((***l_72) , func_67(l_276)) | (g_11 >= ((~(((((0xC5433B60L < (((((int16_t)((void*)0 != l_281) << (int16_t)(g_183.f0 > 7UL)) ^ (*l_281)) ^ g_11) | g_11)) >= g_171.f0) < 7UL) == (*l_281)) || g_145)) > g_171.f0))) | l_209.f0) , (void*)0) == l_283) - (float)0x0.CF5E07p-20) + (float)0x4.8p+1);
            }
            else
            { /* block id: 160 */
                float ****l_286 = &g_243;
                float *****l_287 = &l_286;
                union U1 *l_295 = &l_209;
                union U1 *l_296 = &l_47;
                int32_t l_298 = 0x747DCB55L;
                (*l_287) = l_286;
                for (l_270.f1 = 0; (l_270.f1 > (-1)); l_270.f1 -= 5)
                { /* block id: 164 */
                    return g_119;
                }
                for (l_270.f0 = (-30); (l_270.f0 < 6); l_270.f0 += 9)
                { /* block id: 169 */
                    const int32_t l_299 = 0xA90E2B50L;
                    l_297 = ((float)(!(g_147 <= ((l_295 != (g_171 , l_296)) <= (***l_72)))) + (float)0x1.1EA071p+20);
                    (*l_287) = (void*)0;
                    if (l_298)
                        break;
                    (**g_62) = (l_299 > (***l_72));
                }
                (*l_287) = l_300;
            }
        }
        else
        { /* block id: 177 */
            int32_t *l_301 = &g_282;
            if ((*g_48))
            { /* block id: 178 */
                uint32_t l_304 = 0x5361B7BBL;
                float *l_318 = &g_147;
                float **l_317 = &l_318;
                (**l_64) = l_301;
                (**l_72) = (**l_72);
                (*g_48) = (__builtin_clz(g_119) , (g_145 , (((uint16_t)__builtin_ctz((((((**g_62) >= 0xCFEF64EFL) && 0x567DL) != (l_304 >= g_120)) == (&g_48 == &g_48))) - (uint16_t)(*l_301)) >= g_36)));
                (*l_35) = (g_36 != ((int32_t)__builtin_ffsl(((int32_t)(*g_48) % (int32_t)l_304)) % (int32_t)((uint16_t)(l_311 , ((uint16_t)(!((*l_301) & ((int16_t)(l_317 == (void*)0) << (int16_t)6))) >> (uint16_t)15)) + (uint16_t)(g_282 && 0UL))));
            }
            else
            { /* block id: 183 */
                uint8_t l_324 = 0x6EL;
                int32_t *l_325 = (void*)0;
                union U0 ***l_337 = &l_321;
                union U1 ***l_340 = &l_283;
                for (l_180 = 0; (l_180 > (-15)); l_180--)
                { /* block id: 186 */
                    uint16_t l_322 = 0xD041L;
                    int32_t ***l_323 = &g_62;
                    (*g_48) = l_324;
                    (*g_62) = l_325;
                    (*l_281) = (~(1UL & ((g_183.f1 , ((((int16_t)g_119 - (int16_t)(((((*l_281) , (void*)0) == (void*)0) , l_329) && (l_35 != (__builtin_popcountl(g_183.f1) , l_301)))) , g_330) != (void*)0)) ^ g_120)));
                    return g_119;
                }
                for (g_120 = 0; (g_120 > 15); g_120 += 1)
                { /* block id: 194 */
                    uint8_t l_335 = 0UL;
                    float *l_336 = &g_147;
                    union U1 ****l_341 = (void*)0;
                    (*l_336) = (g_171.f0 >= (l_335 <= g_183.f0));
                    g_338 = l_337;
                    g_342 = l_340;
                }
                (*l_301) = (**g_62);
            }
        }
    }
    else
    { /* block id: 202 */
        int32_t *l_343 = &g_36;
        l_343 = (*g_62);
        (*g_62) = (*g_62);
        (*g_62) = (*g_62);
    }
    (*g_62) = g_344;
    return g_11;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_37(int32_t * p_38, int32_t ** p_39, int32_t * p_40, int32_t ** p_41, uint32_t  p_42)
{ /* block id: 47 */
    return &g_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_48
 * writes:
 */
static int32_t * func_43(int32_t ** p_44)
{ /* block id: 39 */
    return g_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_58 g_62
 * writes: g_58
 */
static int32_t ** func_49(const int32_t  p_50, const int16_t  p_51, int32_t  p_52, uint32_t  p_53)
{ /* block id: 41 */
    int32_t *l_61 = &g_36;
    int32_t **l_60 = &l_61;
    (*l_60) = func_43(func_55(func_43(&g_48), &g_48));
    return g_62;
}


/* ------------------------------------------ */
/* 
 * reads : g_58
 * writes: g_58
 */
static int32_t ** func_55(int32_t * p_56, int32_t ** p_57)
{ /* block id: 42 */
    union U0 **l_59 = (void*)0;
    g_58 = g_58;
    return &g_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_119 g_62 g_36 g_120 g_48 g_171
 * writes: g_119 g_48 g_36 g_161 g_147
 */
static uint16_t  func_67(const int32_t ** p_68)
{ /* block id: 94 */
    int32_t *l_153 = &g_36;
    int32_t ***l_170 = &g_62;
    union U1 l_172 = {18446744073709551607UL};
    float *l_173 = (void*)0;
    float *l_174 = (void*)0;
    float *l_175 = &g_147;
    for (g_119 = 0; (g_119 < 16); g_119 += 2)
    { /* block id: 97 */
        float *l_166 = (void*)0;
        float *l_167 = &g_147;
        (*g_62) = l_153;
        for (g_36 = 25; (g_36 < (-30)); g_36--)
        { /* block id: 101 */
            const uint8_t l_158 = 0x23L;
            int32_t *l_159 = (void*)0;
            int32_t *l_160 = &g_161;
            union U0 **l_164 = &g_58;
            float *l_165 = &g_147;
            (*l_160) = (l_158 != (p_68 != (g_120 , p_68)));
            (*l_165) = ((float)((void*)0 != l_164) - (float)g_36);
            (*l_160) = (*l_153);
            (*g_62) = (*g_62);
        }
        (*l_167) = g_119;
    }
    (*g_62) = l_153;
    (*l_175) = ((*l_153) <= ((float)((&p_68 == l_170) > ((g_171 , l_153) != l_153)) + (float)g_36));
    return (*l_153);
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_62 g_48 g_11 g_120 g_145
 * writes: g_48 g_11 g_119 g_120 g_36 g_147
 */
static const int32_t ** func_69(int32_t *** p_70, int32_t  p_71)
{ /* block id: 50 */
    int32_t *l_95 = &g_36;
    union U0 **l_102 = &g_58;
    int32_t l_149 = 0x93412C06L;
    const int32_t **l_150 = (void*)0;
    (*l_95) = ((uint32_t)((uint16_t)(~((uint16_t)((((uint16_t)(((int16_t)((((!((func_85(func_89(p_71, l_95, p_71, ((*l_95) != __builtin_ffsll(((*l_95) != p_71))), (((((!((func_97(&g_62, l_102, p_71, &g_62) , p_71) <= g_36)) | 0x2DC1L) < g_36) < (*l_95)) , g_120)), (*p_70), g_62) , &l_95) == g_62)) , (*l_95)) && 0x31D74955L) < 0xB99AL) >> (int16_t)l_149) == 0x1B3DFEA1L) + (uint16_t)l_149) != g_145) , p_71) >> (uint16_t)7)) >> (uint16_t)g_145) + (uint32_t)g_145);
    return l_150;
}


/* ------------------------------------------ */
/* 
 * reads : g_145 g_36
 * writes: g_147 g_48
 */
static union U0  func_85(union U1  p_86, int32_t ** p_87, int32_t ** p_88)
{ /* block id: 88 */
    int32_t l_141 = 0xB1EAD213L;
    union U0 **l_144 = &g_58;
    float *l_146 = &g_147;
    union U0 l_148 = {18446744073709551613UL};
    (*l_146) = (0x2.42B88Bp-3 != ((((&g_58 != (((-(int32_t)((int16_t)((((uint32_t)((-(uint32_t)__builtin_ffsll(((!((uint16_t)p_86.f0 >> (uint16_t)(__builtin_parityl(l_141) == p_86.f0))) != l_141))) < ((uint32_t)((((__builtin_clz((l_144 != (void*)0)) & 8L) < g_145) == p_86.f0) >= g_36) + (uint32_t)g_145)) - (uint32_t)0xDBDB1424L) == 3UL) > 0xD7F8L) >> (int16_t)8)) == p_86.f0) , (void*)0)) ^ g_36) , p_86.f0) == l_141));
    (*p_87) = &l_141;
    return l_148;
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_48 g_36
 * writes: g_36
 */
static union U1  func_89(const int16_t  p_90, int32_t * p_91, uint32_t  p_92, uint32_t  p_93, int32_t  p_94)
{ /* block id: 85 */
    int32_t ***l_127 = &g_62;
    union U1 l_131 = {0xCAA66001L};
    (**g_62) = (((0x64988723L > ((int32_t)((int16_t)((void*)0 != l_127) << (int16_t)((uint16_t)(***l_127) >> (uint16_t)((__builtin_popcountll((!p_94)) < ((4L <= (4294967293UL <= (***l_127))) || (***l_127))) == 0x87EAL))) % (int32_t)(**g_62))) > 0x54CDL) < (***l_127));
    return l_131;
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_48 g_11 g_36 g_120
 * writes: g_48 g_11 g_119 g_120
 */
static uint32_t  func_97(int32_t *** p_98, union U0 ** p_99, uint32_t  p_100, int32_t *** p_101)
{ /* block id: 51 */
    int32_t ***l_105 = &g_62;
    (*g_62) = (**p_98);
    (**p_98) = (*g_62);
    for (g_11 = 0; (g_11 > 13); g_11 += 1)
    { /* block id: 56 */
        l_105 = (void*)0;
    }
    if (((int16_t)((uint16_t)(&g_48 == &g_48) - (uint16_t)((((g_11 , &g_48) == (void*)0) > __builtin_popcountl(p_100)) ^ (1UL > (((uint32_t)(!0xFB601BA2L) - (uint32_t)0xC5DA298BL) , p_100)))) - (int16_t)g_36))
    { /* block id: 59 */
        int32_t *l_113 = &g_36;
        (**p_98) = l_113;
        for (p_100 = 0; (p_100 > 36); p_100 += 3)
        { /* block id: 63 */
            (*g_62) = (**p_101);
            if ((**g_62))
                break;
        }
    }
    else
    { /* block id: 67 */
        float l_118 = 0x5.3A0315p+79;
        int32_t l_121 = 0x88E6FCACL;
        for (p_100 = 0; (p_100 > 18); p_100 += 1)
        { /* block id: 70 */
            (*g_62) = func_43(&g_48);
            g_119 = 0L;
            if ((**g_62))
            { /* block id: 73 */
                (**p_98) = (**p_98);
                g_120 = (***p_101);
            }
            else
            { /* block id: 76 */
                int32_t *l_122 = &l_121;
                (*l_122) = (l_121 ^ g_36);
                (*l_122) = 0xCCDF3378L;
            }
            (*g_62) = (*g_62);
        }
        return g_11;
    }
    return g_120;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    transparent_crc(g_11, "g_11", print_hash_value);
    transparent_crc(g_36, "g_36", print_hash_value);
    transparent_crc(g_119, "g_119", print_hash_value);
    transparent_crc(g_120, "g_120", print_hash_value);
    transparent_crc(g_145, "g_145", print_hash_value);
    transparent_crc_bytes (&g_147, sizeof(g_147), "g_147", print_hash_value);
    transparent_crc(g_161, "g_161", print_hash_value);
    transparent_crc(g_171.f0, "g_171.f0", print_hash_value);
    transparent_crc(g_183.f0, "g_183.f0", print_hash_value);
    transparent_crc(g_183.f1, "g_183.f1", print_hash_value);
    transparent_crc(g_282, "g_282", print_hash_value);
    transparent_crc(g_332.f0, "g_332.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 100
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 96

XXX times a variable address is taken: 107
XXX times a pointer is dereferenced on RHS: 71
breakdown:
   depth: 1, occurrence: 39
   depth: 2, occurrence: 16
   depth: 3, occurrence: 16
XXX times a pointer is dereferenced on LHS: 59
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 203

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 141
   level: 2, occurrence: 54
   level: 3, occurrence: 35
XXX number of pointers point to pointers: 54
XXX number of pointers point to scalars: 35
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.18

XXX times a non-volatile is read: 439
XXX times a non-volatile is write: 151
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 108
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 14
   depth: 2, occurrence: 14
   depth: 3, occurrence: 20
   depth: 4, occurrence: 21
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 24.2
XXX percentage an existing variable is used: 75.8
********************* end of statistics **********************/

