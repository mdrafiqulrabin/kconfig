/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1350520642
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_31(void);
static uint64_t  func_38(uint8_t  p_39, int32_t * p_40, int32_t  p_41, int32_t * p_42, uint32_t  p_43);
static uint64_t  func_44(int32_t * p_45, int32_t * p_46);
static uint16_t  func_53(int32_t * p_54, int32_t * p_55);
static int32_t * func_56(int32_t * p_57, int32_t * p_58);
static int32_t * func_59(int32_t * p_60);
static int32_t ** func_61(int32_t ** p_62, uint8_t  p_63, int16_t  p_64);
static uint16_t  func_74(uint8_t  p_75, uint64_t  p_76, int32_t * p_77);
static uint32_t  func_90(int32_t ** p_91, int16_t  p_92, int32_t * p_93);
static int32_t  func_102(uint16_t  p_103, int64_t  p_104, int16_t  p_105, int32_t  p_106, uint32_t  p_107);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0x8BDFADF6L;
    int32_t *l_718 = &l_32;
    int32_t **l_717 = &l_718;
    int32_t ***l_716 = &l_717;
    int32_t ****l_715 = &l_716;
    int16_t l_720 = 0x62F4L;
    for (l_32 = 0; (l_32 >= (-26)); l_32 -= 3)
    { /* block id: 39 */
        int32_t l_35 = 0xC7008B15L;
        int32_t *l_704 = &l_35;
        int32_t **l_703 = &l_704;
        for (l_35 = 21; (l_35 == 23); l_35 += 3)
        { /* block id: 42 */
            int32_t *l_702 = &l_32;
            int32_t l_710 = 8L;
            int32_t *l_709 = &l_710;
            (*l_703) = (func_38(__builtin_clzll(func_44(&l_32, &l_32)), l_702, ((0xE7E2L < 0x8E8FL) == (&l_702 != l_703)), &l_32, l_32) , (*l_703));
            (*l_709) ^= (*l_702);
        }
    }
    for (l_32 = (-6); (l_32 < 20); l_32 += 3)
    { /* block id: 378 */
        int32_t *l_714 = (void*)0;
        int32_t **l_713 = &l_714;
        int32_t ****l_719 = (void*)0;
        (*l_713) = &l_32;
        l_719 = l_715;
    }
    return l_720;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_38(uint8_t  p_39, int32_t * p_40, int32_t  p_41, int32_t * p_42, uint32_t  p_43)
{ /* block id: 369 */
    uint8_t l_705 = 0xFDL;
    int32_t l_707 = 0L;
    int32_t *l_706 = &l_707;
    uint32_t l_708 = 0UL;
    (*l_706) = (p_41 < (l_705 , 0xA545L));
    return l_708;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_44(int32_t * p_45, int32_t * p_46)
{ /* block id: 43 */
    int32_t l_52 = (-2L);
    int32_t l_696 = 1L;
    int32_t *l_695 = &l_696;
    int32_t l_700 = (-9L);
    int32_t l_701 = 0L;
    (*l_695) = (((uint16_t)(((uint16_t)(-(uint32_t)(p_45 == p_46)) / (uint16_t)l_52) , func_53((l_52 , func_56(func_59(&l_52), func_59(p_46))), l_695)) << (uint16_t)14) <= l_700);
    return l_701;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_53(int32_t * p_54, int32_t * p_55)
{ /* block id: 364 */
    int16_t l_699 = 0x351BL;
    (*p_55) = ((-10L) >= ((int16_t)l_699 << (int16_t)l_699));
    return l_699;
}


/* ------------------------------------------ */
/* 
 * reads : l_32
 * writes:
 */
static int32_t * func_56(int32_t * p_57, int32_t * p_58)
{ /* block id: 298 */
    int32_t **l_596 = (void*)0;
    int32_t ***l_595 = &l_596;
    uint8_t l_604 = 0x64L;
    int32_t ****l_610 = (void*)0;
    int32_t *****l_609 = &l_610;
    int32_t l_630 = 0xD32060C5L;
    int32_t *l_637 = &l_630;
    int32_t **l_636 = &l_637;
    uint8_t l_686 = 0x77L;
    if ((((void*)0 != l_595) ^ ((void*)0 != p_57)))
    { /* block id: 299 */
        return p_57;
    }
    else
    { /* block id: 301 */
        uint32_t l_599 = 0UL;
        int32_t *****l_613 = &l_610;
        int32_t l_614 = 0xE3A7BC42L;
        l_614 = (((int16_t)l_599 / (int16_t)0x4F19L) != ((((uint16_t)((uint64_t)l_599 - (uint64_t)l_604) >> (uint16_t)(((l_599 < ((uint16_t)((uint64_t)(l_609 != (((uint16_t)(func_74(l_599, l_599, p_58) | l_599) << (uint16_t)15) , l_613)) - (uint64_t)l_599) << (uint16_t)l_599)) >= l_599) & (*p_57))) == (*p_58)) ^ l_599));
    }
    (*p_57) |= (l_604 , ((uint16_t)(((int32_t)0x8CB077BEL - (int32_t)((int16_t)((*p_58) && (p_57 == (void*)0)) - (int16_t)(-1L))) || (0xCE526F1DL >= 0UL)) << (uint16_t)l_604));
    for (l_604 = 0; (l_604 > 58); l_604 += 1)
    { /* block id: 307 */
        uint64_t l_624 = 18446744073709551609UL;
        int32_t *l_635 = &l_630;
        int32_t ****l_642 = &l_595;
        uint32_t l_683 = 0x85817068L;
    }
    (*p_57) |= ((*l_637) < (((int16_t)(((((uint64_t)(((int64_t)(*l_637) + (int64_t)((**l_636) , (**l_636))) == (((((void*)0 != (*l_609)) >= (__builtin_clzll((**l_636)) , ((uint64_t)(*l_637) + (uint64_t)1UL))) >= 0xBA5333A9C6688366LL) <= 0x79E0L)) - (uint64_t)(-1L)) , &l_596) == &l_636) > 0x235DECE661882A55LL) - (int16_t)(**l_636)) > (**l_636)));
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads : l_32 l_52
 * writes:
 */
static int32_t * func_59(int32_t * p_60)
{ /* block id: 44 */
    int32_t l_67 = 0x97CBB402L;
    int32_t *l_66 = &l_67;
    int32_t **l_65 = &l_66;
    int32_t ***l_583 = &l_65;
    int64_t l_584 = 0xB71875B53FB04886LL;
    int32_t *****l_592 = (void*)0;
    int32_t ****l_594 = &l_583;
    int32_t *****l_593 = &l_594;
    (*l_583) = func_61(l_65, ((*l_66) || 1L), (**l_65));
    (**l_583) = (**l_583);
    (**l_65) ^= l_584;
    (*l_593) = ((((***l_583) , ((&p_60 != (*l_583)) ^ (((uint64_t)func_74(((uint16_t)(((-(int64_t)(-1L)) , (void*)0) != &l_583) / (uint16_t)(**l_65)), (*l_66), p_60) / (uint64_t)0x0442D2853DDCF332LL) & 0UL))) > (***l_583)) , &l_583);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_61(int32_t ** p_62, uint8_t  p_63, int16_t  p_64)
{ /* block id: 45 */
    int32_t l_80 = 7L;
    int32_t *l_79 = &l_80;
    int32_t **l_78 = &l_79;
    uint64_t l_320 = 0x63D4E4224FE820B8LL;
    if ((((int16_t)((int64_t)((uint16_t)func_74(((((((l_78 == (((__builtin_bswap32(((uint16_t)((*p_62) != (*l_78)) >> (uint16_t)p_63)) > (p_64 , ((~((0x53CF54CEAA963965LL & (*l_79)) && (p_62 != (void*)0))) ^ p_63))) & p_64) , (void*)0)) >= (**l_78)) , (**l_78)) , 4UL) < 8L) & p_63), p_64, (*p_62)) + (uint16_t)p_64) % (int64_t)(**l_78)) / (int16_t)(**l_78)) , 9L))
    { /* block id: 136 */
        return p_62;
    }
    else
    { /* block id: 138 */
        uint8_t l_260 = 0xE2L;
        int64_t l_266 = 0xC10A26E96902E5CELL;
        for (p_64 = 5; (p_64 > (-16)); p_64 -= 1)
        { /* block id: 141 */
            uint32_t l_254 = 0xF511497DL;
            int32_t **l_259 = &l_79;
            (**p_62) = (((int16_t)l_254 >> (int16_t)1) , ((0x6405L && ((*p_62) != (func_74(p_63, p_63, (*p_62)) , (*p_62)))) | 0x6B9B84ECL));
            (**p_62) &= (4L > ((int16_t)(*l_79) << (int16_t)((l_259 == ((*l_79) , l_259)) , (p_63 , ((65530UL || p_63) , l_260)))));
            for (p_63 = 24; (p_63 <= 53); p_63 += 8)
            { /* block id: 146 */
                int32_t l_265 = 2L;
                (**l_78) = (func_102((0xD9EBL != (0x17787A40E005B643LL >= (p_64 , (__builtin_ffsll(func_90((((**l_259) > (*l_79)) , p_62), l_265, (*p_62))) & p_63)))), (**l_259), (**l_259), (**p_62), (**l_78)) , 0x96001225L);
            }
            if ((**l_259))
                break;
        }
        (**l_78) = (l_260 , (p_62 == (l_266 , &l_79)));
        (**p_62) ^= (((int64_t)l_266 % (int64_t)((int32_t)(((*l_79) > ((int16_t)func_102(l_260, (*l_79), (**l_78), l_266, l_260) << (int16_t)(**l_78))) <= p_64) - (int32_t)(**l_78))) , l_260);
    }
    for (l_80 = 2; (l_80 > (-10)); l_80 -= 1)
    { /* block id: 156 */
        uint32_t l_286 = 0UL;
        int32_t l_289 = 2L;
        int32_t **l_352 = (void*)0;
        int64_t l_358 = 0x62896290C4CCBB0DLL;
        int32_t l_575 = 0L;
        l_289 ^= __builtin_ia32_crc32qi(((((uint16_t)(((int16_t)(func_102((((int16_t)((int32_t)((~(((uint64_t)func_90(p_62, (**l_78), (*l_78)) + (uint64_t)(**l_78)) < l_286)) , ((int64_t)p_63 / (int64_t)18446744073709551615UL)) + (int32_t)(l_286 == (*l_79))) - (int16_t)(*l_79)) < (**l_78)), p_63, (*l_79), l_286, l_286) , p_64) % (int16_t)1L) | (**p_62)) >> (uint16_t)6) != l_286) , (*l_79)), (*l_79));
    }
    (**p_62) = (**l_78);
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads : l_67 l_52 l_32 l_630
 * writes:
 */
static uint16_t  func_74(uint8_t  p_75, uint64_t  p_76, int32_t * p_77)
{ /* block id: 46 */
    int32_t l_96 = (-1L);
    int32_t *l_95 = &l_96;
    int32_t **l_94 = &l_95;
    int64_t l_97 = 1L;
    (*l_94) = (((((uint16_t)p_75 % (uint16_t)p_76) == ((uint16_t)__builtin_popcountl(func_90(l_94, ((65528UL | ((-9L) >= (**l_94))) || (((1UL && ((&l_95 != &l_95) , (*p_77))) != l_97) > (*l_95))), p_77)) + (uint16_t)p_75)) && 65535UL) , p_77);
    return (**l_94);
}


/* ------------------------------------------ */
/* 
 * reads : l_66 l_67 l_637 l_630
 * writes:
 */
static uint32_t  func_90(int32_t ** p_91, int16_t  p_92, int32_t * p_93)
{ /* block id: 47 */
    uint16_t l_98 = 5UL;
    int32_t l_101 = 0x82D056B0L;
    int32_t *l_100 = &l_101;
    int32_t **l_99 = &l_100;
    uint32_t l_125 = 0x21CC8E03L;
    int32_t l_187 = (-1L);
    uint16_t l_246 = 0x1FCEL;
    (**l_99) = ((((l_98 , ((l_99 != &l_100) ^ __builtin_ffs(func_102(p_92, (*l_100), (((((uint16_t)p_92 % (uint16_t)(**l_99)) , ((p_92 < ((*l_100) & 1UL)) > (*l_100))) & 0L) , (**l_99)), (**p_91), p_92)))) < (**l_99)) != (*l_100)) ^ (*l_100));
    (*l_99) = (*l_99);
    (*l_100) = (((int16_t)((((int64_t)(&p_93 != &p_93) - (int64_t)(((((*l_100) && 0L) ^ (**l_99)) , ((((**l_99) , ((uint32_t)(((((**p_91) != (*l_100)) , ((int64_t)l_125 - (int64_t)p_92)) ^ (-1L)) > (**l_99)) + (uint32_t)(*l_100))) , 0x7CF170C4L) <= 0x79DD1F38L)) && p_92)) , 0xEF296F1EL) < 0xE7C9E842L) % (int16_t)p_92) ^ p_92);
    for (l_125 = (-27); (l_125 <= 12); l_125 += 1)
    { /* block id: 57 */
        int32_t l_130 = 0x2801F5D8L;
        int32_t **l_132 = &l_100;
        uint64_t l_151 = 18446744073709551608UL;
        uint16_t l_162 = 1UL;
        uint64_t l_177 = 0x556E8D107E331B44LL;
        uint8_t l_236 = 246UL;
        int16_t l_247 = 0xC9A4L;
    }
    return p_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_102(uint16_t  p_103, int64_t  p_104, int16_t  p_105, int32_t  p_106, uint32_t  p_107)
{ /* block id: 48 */
    int32_t l_113 = (-3L);
    int32_t l_114 = 0x77DAE0A7L;
    int32_t *l_115 = (void*)0;
    int32_t *l_116 = &l_114;
    l_114 = ((uint16_t)(((void*)0 == &p_106) | (!p_106)) / (uint16_t)l_113);
    (*l_116) = l_113;
    return p_105;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 137
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 25, occurrence: 2

XXX total number of pointers: 93

XXX times a variable address is taken: 110
XXX times a pointer is dereferenced on RHS: 347
breakdown:
   depth: 1, occurrence: 181
   depth: 2, occurrence: 138
   depth: 3, occurrence: 18
   depth: 4, occurrence: 10
XXX times a pointer is dereferenced on LHS: 110
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 23
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 784

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 862
   level: 2, occurrence: 685
   level: 3, occurrence: 61
   level: 4, occurrence: 29
   level: 5, occurrence: 17
XXX number of pointers point to pointers: 47
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 15.1
XXX average alias set size: 1.47

XXX times a non-volatile is read: 1437
XXX times a non-volatile is write: 288
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 50
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 10
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 12.6
XXX percentage an existing variable is used: 87.4
********************* end of statistics **********************/

