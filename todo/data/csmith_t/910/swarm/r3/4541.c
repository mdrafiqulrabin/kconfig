/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3375782466
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint64_t  f0;
   int64_t  f1;
   signed f2 : 16;
   const uint16_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static int64_t g_5 = 0xD32FFAB8C3AD3B31LL;
static int32_t g_52 = 0x7092FF82L;
static int32_t *g_124 = (void*)0;
static int32_t **g_123 = &g_124;
static uint32_t g_125 = 0UL;
static int32_t g_132 = 0L;
static const struct S0 g_133 = {1UL,0x5E7C9E84290833C0LL,-220,0UL};
static struct S0 g_148 = {1UL,-1L,222,1UL};
static int32_t *g_228 = &g_132;
static const int32_t *g_237 = &g_52;
static const int32_t **g_236 = &g_237;
static struct S0 g_264 = {1UL,-10L,37,1UL};
static struct S0 *g_263 = &g_264;
static struct S0 **g_262 = &g_263;
static struct S0 ***g_261 = &g_262;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_26(void);
inline static int16_t  func_59(int32_t  p_60, int32_t * p_61);
static int32_t * func_62(int32_t * const  p_63, int32_t * p_64, uint64_t  p_65);
inline static const uint16_t  func_83(int32_t ** p_84, uint16_t  p_85, struct S0  p_86, int32_t * p_87);
inline static int32_t * func_91(int32_t * p_92, int32_t  p_93);
static int32_t  func_97(const int16_t  p_98, int32_t * p_99, uint64_t  p_100, int32_t * const * p_101, const int32_t ** p_102);
inline static int32_t * func_103(int32_t * p_104, int32_t ** p_105, uint64_t  p_106, int32_t * p_107);
static int16_t  func_108(int32_t * p_109, int32_t  p_110);
inline static int32_t * func_111(int32_t * p_112, struct S0  p_113, int32_t  p_114, int16_t  p_115);
static int32_t * const  func_116(uint16_t  p_117, int32_t * p_118, const int32_t  p_119, int32_t ** p_120, int64_t  p_121);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_52 g_123 g_124 g_133 g_125 g_148.f3 g_148.f2 g_148.f1 g_132 g_148.f0 g_228 g_261 g_237 g_262 g_263 g_236
 * writes: g_5 g_52 g_125 g_132 g_124 g_148.f0 g_148.f1 g_263 g_262
 */
inline static uint32_t  func_26(void)
{ /* block id: 36 */
    uint32_t l_38 = 18446744073709551615UL;
    int32_t ***l_272 = &g_123;
    int32_t ****l_271 = &l_272;
    const int32_t *l_274 = &g_132;
    struct S0 **l_275 = &g_263;
    for (g_5 = 0; (g_5 != 4); ++g_5)
    { /* block id: 39 */
        const int16_t l_49 = 1L;
        int32_t *l_266 = (void*)0;
        struct S0 ***l_273 = (void*)0;
        if ((((uint16_t)((int16_t)((int16_t)(((g_5 == (((uint16_t)0UL - (uint16_t)(-(int64_t)l_38)) <= (-1L))) , (((int16_t)(((__builtin_parity(((int16_t)(((l_38 >= l_38) <= (((int16_t)0L >> (int16_t)1) , (((((uint16_t)(0x550E8F7CF8FB6F85LL || ((int32_t)l_49 + (int32_t)l_38)) >> (uint16_t)8) & 0xC167DF2DL) ^ 0xAF0B56FEL) < g_5))) == l_38) - (int16_t)l_38)) < 0xD5B6L) > l_49) | l_38) << (int16_t)15) , g_5)) != 0x52ADL) >> (int16_t)g_5) >> (int16_t)l_49) << (uint16_t)7) , 0L))
        { /* block id: 40 */
            uint32_t l_50 = 0x21E52503L;
            int32_t *l_51 = &g_52;
            int32_t l_265 = 0x30AFC9A4L;
            (*l_51) = l_50;
            if (((void*)0 != &g_52))
            { /* block id: 42 */
                int32_t *l_66 = &g_52;
                for (g_52 = 0; (g_52 <= 21); g_52++)
                { /* block id: 45 */
                    l_265 = (((int16_t)((int16_t)func_59(g_5, func_62(&g_52, l_66, g_5)) >> (int16_t)(((g_261 == &g_262) && 3L) , (*l_66))) >> (int16_t)11) <= (*l_51));
                    if ((*g_228))
                        continue;
                    (*g_228) = (*g_237);
                }
                /* facts after for loop */
                assert (g_124 == &g_52 || g_124 == 0);
                (*g_123) = l_266;
                /* statement id: 178 */
                assert (g_124 == 0);
            }
            else
            { /* block id: 179 */
                (*g_228) = 7L;
            }
        }
        else
        { /* block id: 182 */
            (*g_262) = (*g_262);
            (*g_228) = ((uint16_t)65535UL >> (uint16_t)6);
            if ((**g_236))
                break;
            (*g_123) = (*g_123);
        }
        if ((*g_237))
            continue;
        (*g_123) = (void*)0;
        (*g_228) = (((l_273 == &g_262) , g_125) <= (-3L));
    }
    (**l_272) = (void*)0;
    l_274 = (*g_236);
    /* statement id: 193 */
    assert (l_274 == &g_52);
    (*g_261) = l_275;
    return (*l_274);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_123 g_124 g_52 g_133 g_125 g_148.f0 g_148.f3 g_148.f2 g_148.f1 g_132 g_228
 * writes: g_125 g_132 g_124 g_148.f0 g_148.f1
 */
inline static int16_t  func_59(int32_t  p_60, int32_t * p_61)
{ /* block id: 49 */
    struct S0 l_90 = {1UL,0x6BEC160668021436LL,-35,0xBEB0L};
    int32_t l_190 = 1L;
    uint32_t l_203 = 0UL;
    int32_t *l_204 = &g_132;
    uint16_t l_219 = 0xE9E4L;
    int32_t l_257 = 1L;
    for (p_60 = 21; (p_60 < 25); p_60++)
    { /* block id: 52 */
        uint32_t l_80 = 5UL;
        int32_t *l_89 = &g_52;
        int32_t **l_88 = &l_89;
        int32_t *l_191 = &g_132;
        struct S0 l_198 = {18446744073709551612UL,7L,-23,0x6485L};
        (*l_191) = (((int16_t)(g_5 == ((((((int16_t)(p_60 == (((uint16_t)(p_60 < (((int16_t)(l_80 | ((uint16_t)func_83(l_88, g_5, l_90, &g_52) >> (uint16_t)1)) + (int16_t)g_148.f2) | l_190)) - (uint16_t)0xB4A3L) , p_60)) - (int16_t)0x529AL) , g_5) , p_60) , g_148.f3) , g_125)) % (int16_t)p_60) == (-10L));
        if ((((uint16_t)(((uint16_t)(((uint64_t)((func_83(&g_124, ((p_60 , p_60) || 0x9C38CBB5L), l_198, (*g_123)) != (g_133.f0 , ((int32_t)(1UL <= p_60) - (int32_t)(-1L)))) , g_133.f1) + (uint64_t)(*l_89)) || g_148.f0) << (uint16_t)15) | l_90.f3) >> (uint16_t)8) ^ l_190))
        { /* block id: 118 */
            for (g_148.f0 = 0; (g_148.f0 != 32); g_148.f0 += 8)
            { /* block id: 121 */
                (*g_123) = (g_148.f1 , (*l_88));
                /* statement id: 122 */
                assert (g_124 == &g_52);
                (*g_123) = func_91((*g_123), p_60);
            }
            (*l_88) = (void*)0;
            /* statement id: 125 */
            assert (l_89 == 0);
            g_132 = l_90.f1;
        }
        else
        { /* block id: 127 */
            (*g_123) = (*g_123);
        }
        /* facts after branching */
        assert (l_89 == &g_52 || l_89 == 0);
        (*g_123) = (*l_88);
    }
    (*l_204) = __builtin_clz(l_203);
    for (l_203 = 0; (l_203 < 11); ++l_203)
    { /* block id: 135 */
        int32_t * const l_211 = &g_52;
        int32_t *l_212 = &g_52;
        int32_t **l_213 = &g_124;
        struct S0 *l_218 = &g_148;
        uint64_t l_225 = 1UL;
        (*l_213) = func_116(((uint32_t)(*l_204) + (uint32_t)(p_61 != (*g_123))), func_62(p_61, func_62((((((uint16_t)0x1D50L << (uint16_t)1) && __builtin_ia32_crc32qi(p_60, ((*p_61) , 6UL))) & p_60) , l_211), l_212, (*l_211)), g_125), (*l_211), &l_212, p_60);
        if (((func_83(&l_212, (((-(int32_t)((uint32_t)(!(p_60 , 1UL)) + (uint32_t)(((((((*l_204) <= ((&l_90 != l_218) <= (*l_212))) ^ 0UL) , (p_60 == l_219)) ^ p_60) != 0UL) & 0L))) && 0UL) != 0UL), g_133, (*g_123)) ^ 0xD3E02F51L) , (*p_61)))
        { /* block id: 137 */
            int32_t *l_222 = &g_52;
            for (l_90.f0 = 26; (l_90.f0 == 29); l_90.f0 += 3)
            { /* block id: 140 */
                return g_132;
            }
            (*l_204) = (((func_108(l_222, (p_60 , (~((~((g_52 & (0xEED1L | 0xB085L)) , ((g_133.f1 || (*l_211)) < (p_60 == (l_225 ^ 0x79F9L))))) , 0x190077AE96437F60LL)))) , p_60) == (*l_222)) | (*l_222));
            if ((*p_61))
                break;
        }
        else
        { /* block id: 145 */
            int32_t *l_226 = &g_132;
            struct S0 l_229 = {7UL,0xD69DBB52D67D768ELL,163,0xC644L};
            (*l_213) = func_103(l_226, &g_124, (p_60 , (((p_60 != g_133.f1) > p_60) ^ (!(*l_212)))), func_111(func_62(p_61, g_228, g_133.f0), l_229, g_148.f2, g_133.f1));
            (*g_123) = (*g_123);
            (*l_213) = p_61;
            /* statement id: 148 */
            assert (g_124 == &g_52);
            for (g_148.f1 = 0; (g_148.f1 == (-3)); g_148.f1--)
            { /* block id: 151 */
                int16_t l_238 = 0xA418L;
                struct S0 l_249 = {0x501E57F89F2780F6LL,2L,70,0x1429L};
                struct S0 **l_260 = &l_218;
            }
        }
    }
    return g_148.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_62(int32_t * const  p_63, int32_t * p_64, uint64_t  p_65)
{ /* block id: 46 */
    int32_t * const l_68 = &g_52;
    int32_t * const *l_67 = &l_68;
    int32_t *l_69 = &g_52;
    l_67 = &p_63;
    /* statement id: 47 */
    assert (l_67 == &p_63);
    return l_69;
    /* statement id: 48 */
    //assert (func_62_rv == &g_52);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_123 g_124 g_52 g_133 g_125 g_148.f0 g_148.f3 g_148.f2 g_148.f1 g_132
 * writes: g_125 g_132 g_124 g_148.f0
 */
inline static const uint16_t  func_83(int32_t ** p_84, uint16_t  p_85, struct S0  p_86, int32_t * p_87)
{ /* block id: 53 */
    int32_t l_126 = 1L;
    struct S0 l_127 = {0x7DC5EB77D2D86EA7LL,0xF159E9DC621C653CLL,-18,0x413EL};
    int32_t *l_137 = &g_52;
    int32_t **l_136 = &l_137;
    const int32_t **l_138 = (void*)0;
    (*g_123) = func_91(((((((((int16_t)(!func_97(g_5, func_103(((func_108(func_111(func_62(func_116((!g_5), (*p_84), p_85, g_123, g_5), (((g_52 >= 1L) , g_52) , (*g_123)), l_126), l_127, l_127.f1, p_86.f0), l_127.f0) == p_86.f1) , (*g_123)), l_136, p_86.f1, (*l_136)), (*l_137), &l_137, l_138)) << (int16_t)5) != g_133.f0) & 4UL) <= g_133.f2) >= g_5) < 7L) , (void*)0), g_5);
    return g_133.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_133 g_124 g_123 g_148.f1 g_132 g_125 g_5
 * writes: g_124 g_125
 */
inline static int32_t * func_91(int32_t * p_92, int32_t  p_93)
{ /* block id: 108 */
    int32_t l_179 = (-1L);
    struct S0 *l_185 = &g_148;
    const int32_t *l_187 = &g_52;
    const int32_t **l_186 = &l_187;
    if ((__builtin_bswap32(p_93) | 0xF3AEL))
    { /* block id: 109 */
        int32_t *l_188 = &g_132;
        int32_t **l_189 = &l_188;
        (*l_189) = func_116((**l_186), p_92, func_108(func_62(func_62(((g_133 , (**l_186)) , func_103(p_92, &g_124, (p_93 | p_93), ((__builtin_ia32_crc32qi((*l_187), p_93) | 0L) , p_92))), &g_132, g_148.f1), l_188, (*l_188)), (**l_186)), &l_188, g_133.f2);
        /* statement id: 110 */
        assert (l_188 == &g_52 || l_188 == 0);
    }
    else
    { /* block id: 111 */
        return (*g_123);
        /* statement id: 112 */
        //assert (func_91_rv == &g_52 || func_91_rv == 0);
    }
    return (*g_123);
    /* statement id: 114 */
    //assert (func_91_rv == &g_52 || func_91_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_52 g_123 g_124 g_148.f0 g_148.f3 g_133 g_125 g_148.f2 g_5 g_148.f1 g_132
 * writes: g_124 g_132 g_148.f0
 */
static int32_t  func_97(const int16_t  p_98, int32_t * p_99, uint64_t  p_100, int32_t * const * p_101, const int32_t ** p_102)
{ /* block id: 71 */
    struct S0 *l_147 = &g_148;
    struct S0 **l_146 = &l_147;
    int32_t l_160 = 0xEC255036L;
    for (p_100 = 0; (p_100 != 57); p_100 += 3)
    { /* block id: 74 */
        int16_t l_166 = 0xB0F6L;
        const int64_t l_174 = (-1L);
        struct S0 ***l_178 = &l_146;
        struct S0 ****l_177 = &l_178;
        if ((*p_99))
        { /* block id: 75 */
            struct S0 **l_143 = (void*)0;
            int32_t l_161 = 0x0401CC62L;
            (*g_123) = (*g_123);
            for (g_132 = 17; (g_132 >= (-15)); g_132 -= 2)
            { /* block id: 79 */
                struct S0 ***l_144 = (void*)0;
                struct S0 ***l_145 = (void*)0;
                int32_t l_152 = 2L;
                int32_t ***l_163 = &g_123;
                (*g_123) = (void*)0;
                /* statement id: 80 */
                assert (g_124 == 0);
                l_146 = l_143;
                /* statement id: 81 */
                assert (l_146 == 0);
                for (g_148.f0 = 0; (g_148.f0 != 60); g_148.f0++)
                { /* block id: 84 */
                    int32_t l_151 = (-1L);
                    int32_t *l_175 = &l_152;
                    if ((g_148.f3 | (((((func_108((*g_123), l_151) > (((__builtin_ffsll((l_152 != g_148.f2)) <= ((int16_t)((!((uint16_t)(!((~g_125) && ((-1L) && l_152))) + (uint16_t)g_148.f3)) <= l_160) >> (int16_t)p_100)) >= 0xAE5FL) , 6L)) ^ 3UL) || 2L) , g_133.f2) > 1L)))
                    { /* block id: 85 */
                        int32_t *l_162 = &l_160;
                        int32_t ****l_164 = (void*)0;
                        (*l_162) = (g_5 ^ l_161);
                        if (l_160)
                            break;
                        l_163 = l_163;
                        (*l_162) = (0x4C7584E3L | (((**p_101) == 0x07EF0612L) , (-1L)));
                    }
                    else
                    { /* block id: 90 */
                        int32_t **l_165 = &g_124;
                        int32_t *l_167 = &l_152;
                        (*l_165) = (*p_101);
                        /* statement id: 91 */
                        assert (g_124 == &g_52 || g_124 == &g_132);
                        (*l_167) = l_166;
                        (*l_167) = __builtin_ia32_crc32qi(p_98, ((((l_160 == p_100) ^ (0xED7CD517L && (-2L))) | ((((uint32_t)((g_125 == (((uint16_t)(0x09CDE0C07D60D117LL || ((*p_99) < ((uint16_t)((func_108((*g_123), l_161) & p_100) , p_98) << (uint16_t)l_174))) >> (uint16_t)g_133.f1) ^ (**g_123))) , l_151) % (uint32_t)(-8L)) > g_133.f0) & 0xA743E715EE1BD551LL)) < g_148.f1));
                    }
                    (*l_175) = 0xB5F6DFA6L;
                    if (l_161)
                        continue;
                    if ((*p_99))
                        break;
                }
                /* facts after for loop */
                assert (g_124 == &g_52 || g_124 == 0 || g_124 == &g_132);
            }
            (*g_123) = (*g_123);
        }
        else
        { /* block id: 101 */
            int32_t *l_176 = &l_160;
            (*l_176) = 1L;
            return l_166;
        }
        (*l_177) = &l_146;
    }
    /* facts after for loop */
    assert (l_146 == 0 || l_146 == &l_147);
    return (*p_99);
}


/* ------------------------------------------ */
/* 
 * reads : g_123 g_124
 * writes: g_124
 */
inline static int32_t * func_103(int32_t * p_104, int32_t ** p_105, uint64_t  p_106, int32_t * p_107)
{ /* block id: 68 */
    (*g_123) = (*p_105);
    return (*g_123);
    /* statement id: 70 */
    //assert (func_103_rv == &g_52 || func_103_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_133 g_125
 * writes:
 */
static int16_t  func_108(int32_t * p_109, int32_t  p_110)
{ /* block id: 65 */
    const struct S0 *l_135 = &g_133;
    const struct S0 **l_134 = &l_135;
    (*l_134) = (g_133 , &g_133);
    return g_125;
}


/* ------------------------------------------ */
/* 
 * reads : g_123 g_124
 * writes: g_132 g_124
 */
inline static int32_t * func_111(int32_t * p_112, struct S0  p_113, int32_t  p_114, int16_t  p_115)
{ /* block id: 57 */
    for (p_115 = 0; (p_115 <= (-13)); p_115 -= 5)
    { /* block id: 60 */
        const uint32_t l_130 = 0xEC8B7CF1L;
        int32_t *l_131 = &g_132;
        (*l_131) = l_130;
        (*g_123) = p_112;
        /* statement id: 62 */
        assert (g_124 == &g_52);
    }
    return (*g_123);
    /* statement id: 64 */
    //assert (func_111_rv == &g_52 || func_111_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_123 g_124
 * writes: g_125
 */
static int32_t * const  func_116(uint16_t  p_117, int32_t * p_118, const int32_t  p_119, int32_t ** p_120, int64_t  p_121)
{ /* block id: 54 */
    g_125 = g_5;
    return (*g_123);
    /* statement id: 56 */
    //assert (func_116_rv == 0 || func_116_rv == &g_52);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_52, "g_52", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_133.f0, "g_133.f0", print_hash_value);
    transparent_crc(g_133.f1, "g_133.f1", print_hash_value);
    transparent_crc(g_133.f2, "g_133.f2", print_hash_value);
    transparent_crc(g_133.f3, "g_133.f3", print_hash_value);
    transparent_crc(g_148.f0, "g_148.f0", print_hash_value);
    transparent_crc(g_148.f1, "g_148.f1", print_hash_value);
    transparent_crc(g_148.f2, "g_148.f2", print_hash_value);
    transparent_crc(g_148.f3, "g_148.f3", print_hash_value);
    transparent_crc(g_264.f0, "g_264.f0", print_hash_value);
    transparent_crc(g_264.f1, "g_264.f1", print_hash_value);
    transparent_crc(g_264.f2, "g_264.f2", print_hash_value);
    transparent_crc(g_264.f3, "g_264.f3", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 54
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 10

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 76

XXX times a variable address is taken: 69
XXX times a pointer is dereferenced on RHS: 75
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 234

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 481
   level: 2, occurrence: 70
   level: 3, occurrence: 4
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 40
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 31.6
XXX average alias set size: 1.42

XXX times a non-volatile is read: 393
XXX times a non-volatile is write: 114
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 85
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 15
   depth: 2, occurrence: 22
   depth: 3, occurrence: 9
   depth: 4, occurrence: 7
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

