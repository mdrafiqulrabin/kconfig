/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      591658802
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_32(void);
inline static int32_t  func_35(int32_t  p_36, const int16_t  p_37, int8_t  p_38, uint64_t  p_39);
static uint16_t  func_40(uint32_t  p_41, int8_t  p_42, const int16_t  p_43);
static uint16_t  func_45(uint32_t  p_46);
inline static uint16_t  func_51(uint32_t  p_52, int8_t  p_53, int8_t  p_54);
inline static const uint16_t  func_57(uint16_t  p_58, int16_t  p_59, uint64_t  p_60, float  p_61, int64_t  p_62);
inline static uint64_t  func_63(uint16_t  p_64);
static int16_t  func_67(int64_t  p_68, int8_t  p_69);
inline static int16_t  func_70(int8_t  p_71);
inline static int32_t  func_76(int64_t  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_32(void)
{ /* block id: 36 */
    int64_t l_44 = (-8L);
    uint32_t l_47 = 0xCA69919CL;
    uint16_t l_573 = 0UL;
    l_573 = (safe_mod_func_int64_t_s_s(((func_35(((0x83A0L <= func_40(l_44, ((((func_45(l_47) , (-1L)) || __builtin_clzl((l_44 , (safe_mul_func_uint16_t_u_u(__builtin_popcountll(l_44), l_44))))) , 6UL) && l_47), l_47)) , l_44), l_47, l_44, l_47) , 0x758EL) == l_44), l_44));
    return l_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_35(int32_t  p_36, const int16_t  p_37, int8_t  p_38, uint64_t  p_39)
{ /* block id: 239 */
    int32_t l_438 = 1L;
    int32_t l_442 = 0x226CD2CAL;
    int32_t *l_441 = &l_442;
    int32_t **l_440 = &l_441;
    int32_t ***l_439 = &l_440;
    uint64_t l_446 = 1UL;
    int8_t l_483 = (-8L);
    float ***l_493 = (void*)0;
    float ****l_492 = &l_493;
    float *****l_491 = &l_492;
    int32_t l_496 = 1L;
    uint64_t l_508 = 0x1F3F97B9983F3DA2LL;
    const int32_t *l_530 = &l_442;
    int32_t ****l_536 = (void*)0;
    int32_t *****l_535 = &l_536;
    uint64_t l_539 = 2UL;
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_40(uint32_t  p_41, int8_t  p_42, const int16_t  p_43)
{ /* block id: 236 */
    int32_t l_434 = 1L;
    int32_t *l_433 = &l_434;
    int32_t **l_435 = &l_433;
    (*l_435) = l_433;
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(uint32_t  p_46)
{ /* block id: 37 */
    int16_t l_50 = 3L;
    int16_t l_109 = 0L;
    int32_t l_430 = 0L;
    int32_t *l_429 = &l_430;
    (*l_429) = ((safe_mod_func_uint16_t_u_u(__builtin_clzll(l_50), func_51(((safe_rshift_func_int16_t_s_u(((p_46 ^ func_57(__builtin_clzll(p_46), p_46, (func_63((safe_div_func_int16_t_s_s(func_67((((func_70(p_46) , ((((p_46 && p_46) || l_50) , 0xEDF6E77AL) ^ l_50)) , l_109) , l_109), l_50), p_46))) , 0x06EA0178CA02759CLL), p_46, l_109)) == l_109), p_46)) , 18446744073709551607UL), p_46, p_46))) , l_109);
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_51(uint32_t  p_52, int8_t  p_53, int8_t  p_54)
{ /* block id: 216 */
    uint16_t l_399 = 1UL;
    float *l_402 = (void*)0;
    float **l_401 = &l_402;
    float ***l_400 = &l_401;
    float l_404 = 0x1.Dp+1;
    float *l_403 = &l_404;
    float l_423 = (-0x4.Bp+1);
    (*l_403) = (0x0.3p+1 > (safe_mul_func_float_f_f(__builtin_parityll((func_57(l_399, (l_400 != (void*)0), l_399, l_399, l_399) || ((0x7DFF19B2L && p_52) , 0x36ACF2E7L))), l_399)));
    for (p_52 = 27; (p_52 > 7); p_52 = safe_sub_func_uint16_t_u_u(p_52, 3))
    { /* block id: 220 */
        int32_t l_411 = 0L;
        if ((safe_mul_func_uint16_t_u_u(0x812EL, (((safe_mod_func_int64_t_s_s(0x20F85839FD0B5B68LL, l_411)) != p_54) >= (safe_mod_func_uint64_t_u_u((safe_sub_func_uint64_t_u_u(((safe_rshift_func_int16_t_s_s(((p_53 , func_67((l_399 , (((!(((safe_mod_func_uint64_t_u_u((func_70(__builtin_bswap32(func_76(l_399))) , l_399), p_53)) || l_399) == 0x865AL)) < p_54) , 0L)), p_52)) != 1L), 11)) | 0x8F6CL), (-6L))), 0xE3A593414256CD0BLL))))))
        { /* block id: 221 */
            int32_t *l_421 = (void*)0;
            int32_t **l_422 = &l_421;
            (*l_422) = l_421;
            return l_399;
        }
        else
        { /* block id: 224 */
            for (p_54 = 0; (p_54 != (-2)); p_54 = safe_sub_func_int16_t_s_s(p_54, 1))
            { /* block id: 227 */
                int32_t *l_426 = &l_411;
                const int32_t *l_428 = &l_411;
                const int32_t **l_427 = &l_428;
                (*l_427) = l_426;
                return p_53;
            }
        }
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_57(uint16_t  p_58, int16_t  p_59, uint64_t  p_60, float  p_61, int64_t  p_62)
{ /* block id: 213 */
    float l_395 = (-0x3.Dp+1);
    float *l_394 = &l_395;
    const int32_t l_396 = 0x30CC0569L;
    (*l_394) = p_62;
    return l_396;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_63(uint16_t  p_64)
{ /* block id: 135 */
    int32_t l_267 = 5L;
    int32_t *l_266 = &l_267;
    int32_t **l_268 = &l_266;
    int64_t l_274 = 0x7E62A801E87EC680LL;
    (*l_268) = l_266;
    if ((*l_266))
    { /* block id: 137 */
        int32_t l_271 = 6L;
        int32_t **l_314 = &l_266;
        uint64_t l_316 = 0xE29DA9801741C852LL;
        float ****l_321 = (void*)0;
        (**l_268) = p_64;
    }
    else
    { /* block id: 180 */
        int64_t l_364 = (-1L);
        int32_t *l_365 = &l_267;
        if ((func_67(((safe_add_func_uint16_t_u_u((safe_add_func_uint64_t_u_u(((**l_268) , (((7L ^ 0x68C6L) < (0xB3C94A2A389E9D28LL & (safe_lshift_func_uint16_t_u_s((*l_266), (safe_div_func_int16_t_s_s((!__builtin_ffs(((0L >= (safe_lshift_func_uint16_t_u_s((safe_sub_func_int64_t_s_s((safe_mul_func_uint16_t_u_u((((safe_mul_func_int16_t_s_s(((**l_268) > p_64), (__builtin_popcountl(l_364) || p_64))) <= p_64) | 0UL), (**l_268))), 0xA4950D67AFB20A85LL)), p_64))) == 1L))), 7UL)))))) == 0xF58DL)), (*l_266))), 0xF96FL)) | p_64), p_64) < p_64))
        { /* block id: 181 */
            uint32_t l_377 = 0x676456B2L;
            (*l_268) = l_365;
            for (p_64 = (-12); (p_64 < 23); p_64 = safe_add_func_int16_t_s_s(p_64, 1))
            { /* block id: 185 */
                int32_t l_376 = 0x9C864BF7L;
                int32_t *l_375 = &l_376;
                for (l_267 = 0; (l_267 == (-8)); l_267 = safe_sub_func_uint16_t_u_u(l_267, 2))
                { /* block id: 188 */
                    int32_t *l_374 = &l_267;
                    if (p_64)
                    { /* block id: 189 */
                        float *l_371 = (void*)0;
                        float l_373 = 0x0.3p-1;
                        float *l_372 = &l_373;
                        (*l_372) = (-p_64);
                        (*l_268) = l_374;
                        (*l_268) = l_372;
                    }
                    else
                    { /* block id: 193 */
                        float l_379 = 0x1.2p-1;
                        float *l_378 = &l_379;
                        l_375 = l_365;
                        if (l_377)
                            continue;
                        (*l_378) = (-0x1.Cp+1);
                    }
                }
            }
        }
        else
        { /* block id: 200 */
            uint32_t l_391 = 0x3BF72AAFL;
            (*l_266) = (((((p_64 , ((safe_rshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s(func_67(((func_70(((*l_365) , ((!0UL) < p_64))) && p_64) || ((*l_365) >= ((*l_365) , __builtin_ctzl((safe_rshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u(p_64, 14)) & 1L), l_391)), 15)))))), l_391), p_64)), 14)) < (**l_268))) , l_365) != l_365) >= p_64) > p_64);
            return p_64;
        }
        (*l_268) = l_365;
        (*l_268) = (*l_268);
    }
    for (p_64 = 0; (p_64 == 28); p_64 = safe_add_func_int64_t_s_s(p_64, 1))
    { /* block id: 209 */
        (*l_268) = (*l_268);
    }
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_67(int64_t  p_68, int8_t  p_69)
{ /* block id: 48 */
    float l_119 = 0x0.2p-1;
    float *l_118 = &l_119;
    float **l_117 = &l_118;
    int32_t l_121 = 0x86BC1AF3L;
    int32_t l_124 = 0xC9B65FEAL;
    float ***l_126 = &l_117;
    float ****l_125 = &l_126;
    int16_t l_143 = 0x53B0L;
    int32_t ***l_241 = (void*)0;
    int32_t ****l_240 = &l_241;
    for (p_68 = 24; (p_68 != (-4)); --p_68)
    { /* block id: 51 */
        int32_t l_113 = 0L;
        int32_t *l_112 = &l_113;
        int32_t **l_114 = &l_112;
        float l_116 = 0x4.AC298Bp+6;
        float *l_115 = &l_116;
        float ***l_120 = &l_117;
        (*l_114) = l_112;
        (*l_115) = (*l_112);
        (*l_120) = l_117;
        l_121 = ((void*)0 == &l_112);
    }
    for (l_121 = (-9); (l_121 < 27); l_121 = safe_add_func_uint16_t_u_u(l_121, 5))
    { /* block id: 59 */
        float *****l_127 = &l_125;
        int32_t l_129 = 0xC74F2DDDL;
        int32_t l_175 = (-1L);
        float ****l_179 = (void*)0;
        int32_t *l_190 = &l_124;
        int32_t **l_189 = &l_190;
        int32_t ***l_188 = &l_189;
        float **l_251 = &l_118;
        int64_t l_252 = 0xD9380DC62A66E88FLL;
        l_124 = (0x54EAL == 65527UL);
        (*l_127) = l_125;
    }
    if (l_121)
    { /* block id: 127 */
        float *l_253 = (void*)0;
        int32_t *l_254 = &l_121;
        (**l_117) = (((void*)0 == l_253) > (0x9.7199E9p-45 <= ((0xD.150FF4p-12 == (p_68 >= (p_69 >= 0x0.7p-1))) > (-0x1.7p-1))));
        l_254 = l_253;
    }
    else
    { /* block id: 130 */
        const int32_t *l_256 = &l_124;
        const int32_t **l_255 = &l_256;
        int32_t ****l_265 = &l_241;
        (*l_255) = &l_124;
        (**l_117) = (p_68 , (((safe_mul_func_float_f_f(((safe_mul_func_float_f_f(__builtin_bswap32(p_69), (safe_sub_func_float_f_f((p_68 <= func_76(__builtin_popcount(p_69))), (-0x1.Ap-1))))) >= (safe_sub_func_float_f_f(func_70(((l_265 == &l_241) > p_69)), 0x3.BBCB49p+51))), 0x1.FE4F01p-44)) > (*l_256)) == (-0x1.9p+1)));
    }
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_70(int8_t  p_71)
{ /* block id: 38 */
    float l_78 = 0x2.Fp+1;
    int32_t l_79 = (-3L);
    float *l_87 = &l_78;
    int32_t **l_88 = (void*)0;
    int32_t **l_89 = (void*)0;
    int32_t *l_91 = &l_79;
    int32_t **l_90 = &l_91;
    uint64_t l_102 = 0x85580973F91A6653LL;
    float *l_107 = &l_78;
    int32_t l_108 = 0x77FB90EFL;
    (*l_87) = (((((safe_mul_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(func_76((p_71 ^ l_79)), func_76((safe_sub_func_uint16_t_u_u(0x8BC1L, (-1L)))))), (0xAF833954656E2E31LL ^ (l_79 > l_79)))) , l_79) <= l_79) > 0x2.7DC462p+8) <= 0x4.Dp+1);
    (*l_90) = &l_79;
    (**l_90) = ((safe_mod_func_uint16_t_u_u(p_71, p_71)) < (__builtin_bswap32((*l_91)) , (((((((*l_90) == (void*)0) < (safe_lshift_func_uint16_t_u_u((5L ^ ((safe_mul_func_uint16_t_u_u((0x64560F9103153D57LL == 0x1F1B003BA2937BBCLL), p_71)) ^ p_71)), 10))) || (**l_90)) , 0xCE86L) > p_71) , (*l_91))));
    (*l_87) = ((safe_mul_func_uint16_t_u_u((((safe_rshift_func_uint16_t_u_u(func_76((l_102 != p_71)), 5)) , (&l_91 == (void*)0)) | (safe_rshift_func_uint16_t_u_s(0xAA6AL, 11))), 65527UL)) , (safe_sub_func_float_f_f((((((void*)0 == l_107) >= 0xB.8B6467p-57) <= l_108) <= 0x6.9A2339p-44), p_71)));
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_76(int64_t  p_77)
{ /* block id: 39 */
    int32_t l_81 = 5L;
    int32_t *l_80 = &l_81;
    int32_t **l_82 = &l_80;
    (*l_82) = l_80;
    (**l_82) = (**l_82);
    return p_77;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 124
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 9
   depth: 8, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 109

XXX times a variable address is taken: 111
XXX times a pointer is dereferenced on RHS: 87
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 28
   depth: 3, occurrence: 9
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 83
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 16
   depth: 3, occurrence: 6
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 285

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 126
   level: 2, occurrence: 58
   level: 3, occurrence: 37
   level: 4, occurrence: 12
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22
XXX average alias set size: 1.16

XXX times a non-volatile is read: 675
XXX times a non-volatile is write: 229
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 4

XXX stmts: 61
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 16
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 20.3
XXX percentage an existing variable is used: 79.7
********************* end of statistics **********************/

