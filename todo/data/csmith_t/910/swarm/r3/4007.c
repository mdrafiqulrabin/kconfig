/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      1520906690
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   volatile uint32_t  f0;
   int16_t  f1;
   volatile uint16_t  f2;
   volatile uint16_t  f3;
   uint32_t  f4;
   int16_t  f5;
   const int8_t  f6;
   volatile unsigned f7 : 24;
};
#pragma pack(pop)

union U1 {
   int32_t  f0;
   const uint32_t  f1;
};

union U2 {
   volatile int8_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int8_t g_4 = 0x8AL;
static int32_t g_6 = 0L;
static int32_t g_44 = 0x7A68FAB8L;
static int32_t *g_78 = &g_44;
static volatile int32_t g_83 = 1L;/* VOLATILE GLOBAL g_83 */
static volatile int32_t *g_82 = &g_83;
static volatile int32_t **g_81 = &g_82;
static volatile int32_t ***g_80 = &g_81;
static struct S0 g_150 = {0x081AEEC9L,1L,0xA743L,3UL,0xEE1BD551L,0xD9D7L,0x22L,3072};/* VOLATILE GLOBAL g_150 */
static int32_t ** const g_196 = &g_78;
static int32_t ** const *g_195 = &g_196;
static int32_t ** const **g_194 = &g_195;
static int32_t ** const ***g_193 = &g_194;
static int16_t g_223 = 5L;
static union U1 g_268 = {0xABCD3A8AL};
static int32_t g_270 = 0x07F2044AL;
static struct S0 *g_318 = &g_150;
static struct S0 **g_317 = &g_318;
static struct S0 g_438 = {0x2F836906L,9L,4UL,0xD645L,0x675CCA39L,0xDC27L,-7L,1551};/* VOLATILE GLOBAL g_438 */
static int16_t g_484 = (-1L);
static union U2 g_486 = {0L};/* VOLATILE GLOBAL g_486 */
static union U1 *g_487 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t * func_2(int32_t  p_3);
static int16_t  func_8(int32_t * p_9);
static uint16_t  func_10(int32_t * p_11, int32_t * p_12, int32_t * p_13, uint16_t  p_14);
static int32_t * func_15(int32_t * p_16, int32_t * p_17, uint32_t  p_18, const int16_t  p_19);
static int32_t * func_20(int8_t  p_21, int32_t  p_22);
static int32_t  func_26(int16_t  p_27);
static int16_t  func_28(union U1  p_29, int32_t  p_30, int32_t * p_31, uint16_t  p_32, int32_t * p_33);
static union U1  func_34(uint32_t  p_35, int32_t  p_36);
static int16_t  func_39(uint32_t  p_40);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_6 g_44 g_80 g_82 g_83 g_81 g_78 g_150.f0 g_150.f7 g_196 g_195 g_150.f4 g_194 g_193 g_150.f3 g_268 g_268.f1 g_270 g_150.f5 g_150.f1 g_150.f2 g_150.f6 g_317 g_223 g_268.f0 g_438.f4 g_438.f1 g_438.f5 g_484
 * writes: g_6 g_78 g_44 g_80 g_83 g_82 g_150.f4 g_270 g_150.f5 g_194 g_150.f1 g_438.f4 g_487
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_7 = &g_6;
    struct S0 *l_475 = &g_438;
    int32_t **l_479 = &l_7;
    int32_t ***l_478 = &l_479;
    union U2 *l_485 = &g_486;
    l_7 = func_2(g_4);
    (*l_7) = ((func_8(&g_6) || ((~((void*)0 == l_475)) > (*****g_193))) < ((int16_t)(((7L || (((void*)0 != l_478) ^ ((int32_t)((((uint32_t)((g_150.f6 && g_223) < 0x155FF02BL) - (uint32_t)g_150.f6) && g_438.f1) < 65533UL) - (int32_t)g_438.f5))) >= g_268.f1) < g_484) >> (int16_t)g_438.f5));
    /* statement id: 203 */
    assert (g_78 == &g_6);
    assert (g_82 == 0 || g_82 == &g_83);
    l_485 = (void*)0;
    /* statement id: 204 */
    assert (l_485 == 0);
    g_487 = &g_268;
    /* statement id: 205 */
    assert (g_487 == &g_268);
    return (*l_7);
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes: g_6
 */
static int32_t * func_2(int32_t  p_3)
{ /* block id: 1 */
    int32_t *l_5 = &g_6;
    (*l_5) = g_4;
    return l_5;
    /* statement id: 3 */
    //assert (func_2_rv == &g_6);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_6 g_44 g_80 g_82 g_83 g_81 g_78 g_150.f0 g_150.f7 g_196 g_195 g_150.f4 g_194 g_193 g_150.f3 g_268 g_268.f1 g_270 g_150.f5 g_150.f1 g_150.f2 g_150.f6 g_317 g_223 g_268.f0 g_438.f4 g_438.f1
 * writes: g_6 g_78 g_44 g_80 g_83 g_82 g_150.f4 g_270 g_150.f5 g_194 g_150.f1 g_438.f4
 */
static int16_t  func_8(int32_t * p_9)
{ /* block id: 5 */
    uint16_t l_23 = 0x11A7L;
    int32_t *l_269 = &g_270;
    (*g_196) = func_2(((0x58905B8BL <= g_4) && func_10(&g_6, func_2(g_6), func_15(p_9, func_20(l_23, ((int32_t)func_26(func_28(func_34(((int16_t)func_39(l_23) - (int16_t)g_4), l_23), l_23, l_269, g_268.f1, p_9)) % (int32_t)(-1L))), g_438.f1, g_4), l_23)));
    /* statement id: 201 */
    assert (g_78 == &g_6);
    assert (g_82 == 0 || g_82 == &g_83);
    return (*l_269);
}


/* ------------------------------------------ */
/* 
 * reads : g_150.f1 g_44 g_6
 * writes: g_6
 */
static uint16_t  func_10(int32_t * p_11, int32_t * p_12, int32_t * p_13, uint16_t  p_14)
{ /* block id: 196 */
    int32_t *l_458 = &g_44;
    int32_t *l_459 = (void*)0;
    int32_t **l_463 = &g_78;
    int32_t ***l_462 = &l_463;
    const int32_t *l_470 = &g_44;
    const int32_t **l_469 = &l_470;
    const int32_t ***l_468 = &l_469;
    const int32_t ****l_467 = &l_468;
    const int32_t *****l_466 = &l_467;
    (*p_11) = ((int16_t)(((uint16_t)65535UL - (uint16_t)g_150.f1) <= ((-8L) < ((int16_t)0x3230L << (int16_t)7))) << (int16_t)2);
    l_459 = l_458;
    /* statement id: 198 */
    assert (l_459 == &g_44);
    (*p_12) = ((((uint16_t)(((l_462 == (void*)0) && (p_14 > (((((uint16_t)(l_466 == (void*)0) - (uint16_t)(-(int16_t)p_14)) <= 0x1F38L) < ((uint16_t)(0xF3B15DECL || (4294967287UL | p_14)) << (uint16_t)(*l_458))) | p_14))) <= (*p_11)) >> (uint16_t)12) & 1L) || (*l_459));
    return p_14;
}


/* ------------------------------------------ */
/* 
 * reads : g_194 g_195 g_196 g_78
 * writes:
 */
static int32_t * func_15(int32_t * p_16, int32_t * p_17, uint32_t  p_18, const int16_t  p_19)
{ /* block id: 194 */
    return (***g_194);
    /* statement id: 195 */
    //assert (func_15_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_193 g_194 g_195 g_196
 * writes: g_78
 */
static int32_t * func_20(int8_t  p_21, int32_t  p_22)
{ /* block id: 190 */
    uint32_t l_448 = 0x6C17839FL;
    int32_t *l_449 = &g_44;
    (****g_193) = (void*)0;
    /* statement id: 191 */
    assert (g_78 == 0);
    p_22 = l_448;
    return l_449;
    /* statement id: 193 */
    //assert (func_20_rv == &g_44);
}


/* ------------------------------------------ */
/* 
 * reads : g_194 g_195 g_196 g_438.f4 g_193 g_78 g_44
 * writes: g_78 g_438.f4
 */
static int32_t  func_26(int16_t  p_27)
{ /* block id: 178 */
    int32_t *l_441 = &g_44;
    int32_t *l_442 = &g_44;
    (***g_194) = l_441;
    /* statement id: 179 */
    assert (g_78 == &g_44);
    (*g_196) = (void*)0;
    /* statement id: 180 */
    assert (g_78 == 0);
    l_441 = l_442;
    for (g_438.f4 = 0; (g_438.f4 > 43); g_438.f4 += 7)
    { /* block id: 184 */
        const int32_t * const **** const l_445 = (void*)0;
        int32_t l_446 = 0xF65CE011L;
        int32_t *l_447 = &g_270;
        l_446 = (l_445 == (void*)0);
        (****g_193) = l_441;
        /* statement id: 186 */
        assert (g_78 == &g_44);
        l_447 = (****g_193);
        /* statement id: 187 */
        assert (l_447 == &g_44);
    }
    /* facts after for loop */
    assert (g_78 == &g_44 || g_78 == 0);
    return (*l_442);
}


/* ------------------------------------------ */
/* 
 * reads : g_270 g_150.f5 g_150.f1 g_150.f2 g_150.f6 g_195 g_196 g_317 g_44 g_83 g_223 g_268.f0 g_150.f7 g_81 g_82 g_4 g_193 g_194 g_80 g_150.f3 g_150.f4 g_268.f1
 * writes: g_270 g_150.f5 g_78 g_82 g_194 g_150.f1
 */
static int16_t  func_28(union U1  p_29, int32_t  p_30, int32_t * p_31, uint16_t  p_32, int32_t * p_33)
{ /* block id: 115 */
    uint16_t l_277 = 0xE628L;
    int32_t * const *l_295 = &g_78;
    int32_t * const **l_294 = &l_295;
    int16_t l_320 = 0xA576L;
    int16_t l_330 = (-10L);
    int8_t l_331 = 0xFDL;
    int32_t l_435 = (-1L);
    struct S0 *l_437 = &g_438;
    uint32_t l_439 = 4294967288UL;
    int32_t *l_440 = &g_270;
    (*p_31) = ((uint16_t)((uint16_t)p_30 - (uint16_t)((int16_t)0x5C85L * (int16_t)((g_270 == (l_277 != (((((uint32_t)((uint16_t)(((uint16_t)65535UL << (uint16_t)((uint16_t)((uint16_t)((int16_t)((uint32_t)((uint16_t)l_277 - (uint16_t)g_150.f5) + (uint32_t)l_277) + (int16_t)((void*)0 != l_294)) >> (uint16_t)7) >> (uint16_t)g_150.f1)) < g_150.f2) << (uint16_t)14) - (uint32_t)1UL) && 0x3321L) ^ g_270) != p_30))) < 0x435A7197L))) % (uint16_t)g_150.f6);
    if (l_277)
    { /* block id: 117 */
        int8_t l_312 = 0xB5L;
        for (g_150.f5 = (-10); (g_150.f5 < (-6)); g_150.f5 += 9)
        { /* block id: 120 */
            int32_t ***l_311 = (void*)0;
            int32_t ****l_310 = &l_311;
            struct S0 * const *l_319 = &g_318;
            if ((*p_31))
                break;
            (**g_195) = p_33;
            /* statement id: 122 */
            assert (g_78 == &g_6);
            (*p_31) = (((int16_t)(((uint16_t)((((int16_t)((((uint32_t)0UL - (uint32_t)(*p_31)) <= ((uint32_t)(((((int16_t)(&l_294 != l_310) << (int16_t)0) || l_312) < p_29.f0) & (((0x639AL || 1UL) < ((uint32_t)((int16_t)(g_317 != l_319) >> (int16_t)12) % (uint32_t)g_44)) | l_320)) - (uint32_t)(*p_31))) == g_83) - (int16_t)l_312) < g_223) != g_150.f5) % (uint16_t)p_30) && g_270) >> (int16_t)g_268.f0) < g_150.f6);
        }
        /* facts after for loop */
        //assert (g_78 == &g_6 || g_78 == dangling || g_78 == &g_44 || g_78 == 0);
    }
    else
    { /* block id: 125 */
        uint16_t l_327 = 0x067AL;
        int32_t ***l_371 = (void*)0;
        int32_t ****l_370 = &l_371;
        int32_t *****l_369 = &l_370;
        int32_t l_408 = 0x07F0C868L;
        uint32_t l_423 = 0xD881F475L;
        int32_t l_424 = 0x18A494BDL;
        int32_t l_425 = 0x89B28858L;
        (*p_31) = (&g_318 != &g_318);
        if ((p_29.f0 >= ((0x419DL != ((((int16_t)((uint32_t)((uint16_t)l_327 << (uint16_t)7) - (uint32_t)((((0L <= 1UL) > ((uint16_t)l_330 + (uint16_t)(4UL == ((void*)0 == &g_318)))) || l_327) && l_331)) + (int16_t)g_150.f5) && (-5L)) | (-9L))) ^ l_327)))
        { /* block id: 127 */
            int32_t *l_338 = (void*)0;
            int32_t l_405 = 0xFABEAF82L;
            for (p_30 = 15; (p_30 < 6); p_30--)
            { /* block id: 130 */
                int32_t l_355 = 6L;
                int32_t ***l_368 = (void*)0;
                int32_t ****l_367 = &l_368;
                for (l_277 = 0; (l_277 == 6); l_277 += 7)
                { /* block id: 133 */
                    int32_t *l_339 = &g_270;
                    (*p_31) = (((uint16_t)((l_338 == l_339) ^ (0x8140L < p_32)) >> (uint16_t)12) == ((((uint16_t)0x217AL >> (uint16_t)(g_223 <= (~(((int16_t)((void*)0 != &p_33) << (int16_t)((*l_339) < 0x24F2L)) >= l_327)))) == 0x6623L) >= 0xAD99B445L));
                    for (l_320 = (-14); (l_320 != (-21)); l_320 -= 7)
                    { /* block id: 137 */
                        int32_t l_358 = 0x8497D294L;
                        uint32_t l_372 = 8UL;
                        int32_t l_373 = 0x1B61A870L;
                        l_355 = ((((int32_t)(g_150.f7 <= ((~(((uint32_t)(&g_318 != (void*)0) + (uint32_t)(~0x904C3285L)) | (!((*g_81) == (void*)0)))) | ((!(l_355 | ((uint32_t)g_270 + (uint32_t)g_4))) & g_270))) % (int32_t)4294967292UL) < g_150.f6) & 0x1670L);
                        l_358 = l_355;
                        (*p_31) = (((int32_t)((uint16_t)(!1UL) << (uint16_t)(p_29.f1 > ((~(((uint16_t)((*g_193) != l_367) << (uint16_t)(0x7A6F84FCL == ((l_369 == &g_194) == l_372))) >= l_373)) > l_373))) % (int32_t)(*p_31)) <= g_223);
                        (*p_31) = ((int16_t)p_29.f1 >> (int16_t)3);
                    }
                }
            }
            (*p_31) = ((int16_t)8L - (int16_t)p_30);
            for (l_277 = (-6); (l_277 == 37); l_277 += 2)
            { /* block id: 148 */
                (*p_31) = 1L;
                (**g_80) = (void*)0;
                /* statement id: 150 */
                assert (g_82 == 0);
            }
            for (l_327 = 0; (l_327 <= 52); l_327 += 8)
            { /* block id: 154 */
                int8_t l_404 = 0x14L;
                (*p_31) = (!((int32_t)(0x07E403E4L | (((int16_t)g_223 << (int16_t)0) == (-5L))) % (int32_t)(((int16_t)((((uint16_t)(g_268.f0 ^ ((-(int16_t)((int16_t)((*p_31) != ((p_29.f1 != ((int16_t)((int16_t)((int32_t)(((((((int16_t)((*p_31) == ((((uint32_t)0UL - (uint32_t)(&l_338 != (void*)0)) | 0x4988510FL) <= p_29.f0)) << (int16_t)15) == p_32) || g_270) & 4294967295UL) | 0xBDF74A55L) > 0x09E4L) - (int32_t)0xDBFB0A49L) % (int16_t)g_150.f3) - (int16_t)p_29.f1)) ^ l_404)) << (int16_t)0)) < g_150.f6)) % (uint16_t)g_150.f6) >= g_150.f4) >= 0x5D45A8E0L) >> (int16_t)l_405) & g_268.f1)));
                if (l_404)
                    break;
            }
        }
        else
        { /* block id: 158 */
            int32_t l_409 = 0x37972ECFL;
            (**g_80) = (void*)0;
            /* statement id: 159 */
            assert (g_82 == 0);
            (*g_193) = (*g_193);
            l_409 = (((void*)0 == (*l_294)) == ((p_32 <= ((**g_193) != (void*)0)) && (p_29.f0 ^ (((((*g_193) == &l_294) > ((((uint16_t)(65535UL != p_32) + (uint16_t)g_4) == (-10L)) >= l_408)) >= 1L) ^ p_32))));
            (*p_31) = (((-8L) < (((void*)0 == &l_370) < ((uint32_t)g_150.f1 + (uint32_t)(p_32 < l_409)))) < ((((*l_294) == (void*)0) & ((int16_t)(((p_29.f0 != (*p_31)) & l_409) && 0L) << (int16_t)8)) ^ 0x76DEL));
        }
        l_425 = (0L != (((((uint16_t)g_223 >> (uint16_t)9) > p_29.f0) > ((void*)0 == (*g_81))) && ((((!(((((((int32_t)((uint16_t)(((((*l_369) == (*g_193)) != ((int16_t)((g_150.f4 != ((p_29.f0 & p_29.f0) & 0xF7A4E7BDL)) & (*p_31)) >> (int16_t)p_30)) ^ (-1L)) ^ 4294967295UL) << (uint16_t)l_423) - (int32_t)0x202AC2ADL) || p_32) < 4294967289UL) <= p_29.f0) & p_30) ^ l_424)) != (*p_31)) || 0x7363E014L) || 2UL)));
    }
    /* facts after branching */
    //assert (g_78 == &g_6 || g_78 == dangling || g_78 == &g_44 || g_78 == 0);
    for (l_277 = 24; (l_277 >= 24); l_277 += 5)
    { /* block id: 168 */
        for (g_150.f1 = (-22); (g_150.f1 < (-10)); g_150.f1++)
        { /* block id: 171 */
            struct S0 * const *l_436 = &g_318;
            (*p_31) = ((uint16_t)(((**g_80) != (void*)0) < (((uint16_t)(~(g_150.f7 <= (((((l_435 || 0x8B880659L) & ((void*)0 != l_436)) && g_150.f1) > ((l_437 == (void*)0) != l_439)) & p_32))) >> (uint16_t)p_32) || g_83)) + (uint16_t)g_150.f1);
        }
        (*g_196) = p_33;
        /* statement id: 174 */
        assert (g_78 == &g_6);
        (***g_194) = l_440;
        /* statement id: 175 */
        assert (g_78 == &g_270);
    }
    /* facts after for loop */
    //assert (g_78 == &g_270 || g_78 == &g_6 || g_78 == dangling || g_78 == &g_44 || g_78 == 0);
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_150.f3 g_150.f4 g_82 g_80 g_81 g_83 g_268
 * writes: g_83 g_150.f4 g_82
 */
static union U1  func_34(uint32_t  p_35, int32_t  p_36)
{ /* block id: 106 */
    int32_t ****l_253 = (void*)0;
    int32_t l_256 = (-1L);
    (*g_82) = ((int16_t)((void*)0 == l_253) << (int16_t)(((uint16_t)(l_256 >= g_44) - (uint16_t)((&p_36 == (void*)0) == ((int16_t)((int32_t)p_36 % (int32_t)(p_35 && ((((+(((((uint32_t)((((((uint16_t)0x6E7FL >> (uint16_t)p_36) == l_256) > 0x72B5BDE4L) < g_150.f3) < 0xFCE4L) + (uint32_t)4294967295UL) || 0xFC9A4F97L) != 0x32BFF614L) & g_150.f4)) >= 0xD8C95F24L) <= p_36) <= l_256))) - (int16_t)(-10L)))) ^ p_36));
    (***g_80) = (***g_80);
    for (g_150.f4 = 0; (g_150.f4 < 19); g_150.f4++)
    { /* block id: 111 */
        (**g_80) = (void*)0;
        /* statement id: 112 */
        assert (g_82 == 0);
    }
    /* facts after for loop */
    assert (g_82 == 0 || g_82 == &g_83);
    return g_268;
    /* statement id: 114 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_44 g_4 g_80 g_82 g_83 g_81 g_78 g_150.f0 g_150.f7 g_196 g_195 g_150.f4 g_194 g_193
 * writes: g_78 g_44 g_80 g_83 g_82 g_150.f4
 */
static int16_t  func_39(uint32_t  p_40)
{ /* block id: 6 */
    const int32_t *l_43 = &g_44;
    int32_t **l_91 = &g_78;
    int32_t ***l_90 = &l_91;
    int32_t ****l_89 = &l_90;
    int8_t l_190 = (-1L);
    uint32_t l_208 = 0UL;
    uint32_t l_212 = 0xD266F9F2L;
    int16_t l_222 = 0x67D7L;
    if (((uint16_t)(l_43 != l_43) % (uint16_t)((int32_t)((uint16_t)((((((int32_t)((uint16_t)((void*)0 == &g_44) >> (uint16_t)((int16_t)((g_44 && ((((int32_t)(g_4 == ((4294967287UL || ((~(*l_43)) > p_40)) | 8L)) - (int32_t)p_40) && g_44) >= 7L)) >= (*l_43)) >> (int16_t)14)) - (int32_t)(*l_43)) ^ 2UL) & 0xAE05L) & p_40) <= 0x33E2L) << (uint16_t)0) + (int32_t)p_40)))
    { /* block id: 7 */
        return g_44;
    }
    else
    { /* block id: 9 */
        uint16_t l_76 = 0xB9DBL;
        int32_t *l_87 = &g_44;
        if ((((uint32_t)(((int16_t)g_44 - (int16_t)((uint16_t)(0x961CL < ((uint32_t)0x83B1D319L + (uint32_t)((uint16_t)(((void*)0 == l_43) || 1L) >> (uint16_t)(((-(uint16_t)((int16_t)(~(g_44 && p_40)) - (int16_t)((((uint16_t)((uint16_t)(&g_44 == &g_44) << (uint16_t)g_4) + (uint16_t)p_40) || 1L) > 1UL))) > g_4) | p_40)))) >> (uint16_t)14)) == g_44) - (uint32_t)l_76) && p_40))
        { /* block id: 10 */
            if (p_40)
            { /* block id: 11 */
                int32_t *l_77 = &g_44;
                int32_t **l_79 = &g_78;
                g_78 = l_77;
                (*l_79) = (void*)0;
                /* statement id: 13 */
                assert (g_78 == 0);
                (*l_77) = p_40;
                (*l_77) = p_40;
            }
            else
            { /* block id: 16 */
                volatile int32_t ****l_84 = &g_80;
                (*l_84) = g_80;
            }
            /* facts after branching */
            assert (g_78 == &g_44 || g_78 == 0);
            (*g_82) = l_76;
            (**g_81) = (*g_82);
            (*g_81) = (*g_81);
        }
        else
        { /* block id: 22 */
            for (g_44 = (-21); (g_44 >= (-30)); g_44 -= 7)
            { /* block id: 25 */
                int32_t **l_88 = &g_78;
                (**g_80) = (**g_80);
                (*l_88) = l_87;
                if ((*g_82))
                    break;
            }
        }
        /* facts after branching */
        assert (g_78 == &g_44 || g_78 == 0);
        (*l_87) = ((((void*)0 != l_87) >= 0x7EBAL) || (((((void*)0 != l_89) != 2L) && (&g_80 != &g_80)) < g_44));
        for (p_40 = 0; (p_40 != 56); p_40 += 4)
        { /* block id: 34 */
            int32_t *l_94 = &g_44;
            g_78 = l_94;
            /* statement id: 35 */
            assert (g_78 == &g_44);
        }
    }
    /* facts after branching */
    assert (g_78 == &g_44 || g_78 == 0);
    if ((0xCABDL <= ((((((-1L) > ((((uint32_t)(p_40 <= ((((uint32_t)(p_40 != g_83) + (uint32_t)((g_4 ^ ((p_40 >= p_40) != ((int16_t)((((*l_89) != (*l_89)) | 0xC621L) | 1UL) >> (int16_t)4))) & 0L)) && (*l_43)) ^ 0UL)) + (uint32_t)p_40) & p_40) ^ g_44)) >= p_40) ^ 0x6D63D46BL) && g_44) ^ 0L)))
    { /* block id: 38 */
        int32_t ***l_111 = &l_91;
        uint32_t l_114 = 0xC85B7F5DL;
        (*g_82) = ((int16_t)(((((uint16_t)(+((p_40 < (((int32_t)(((+(&g_80 != &g_80)) & 0x1CECC2FCL) == ((int16_t)((((void*)0 == l_111) < p_40) || 1L) % (int16_t)((int32_t)(-1L) - (int32_t)(*l_43)))) % (int32_t)0x5C0CD63DL) ^ l_114)) | g_83)) >> (uint16_t)p_40) ^ p_40) || g_4) > g_44) >> (int16_t)0);
        g_78 = (**l_111);
        (**g_81) = p_40;
        for (p_40 = 0; (p_40 > 11); p_40 += 1)
        { /* block id: 44 */
            (*g_82) = (((int32_t)(p_40 >= ((&g_81 != &g_81) == (g_83 ^ (((uint16_t)(-(int32_t)((1L >= (&g_81 != (void*)0)) ^ (!(+0x3C673DF2L)))) >> (uint16_t)((uint16_t)(((uint32_t)1UL + (uint32_t)0xC1B86B2CL) != p_40) + (uint16_t)g_44)) <= g_4)))) + (int32_t)p_40) | l_114);
            (**l_111) = (**l_111);
            if (p_40)
                break;
        }
    }
    else
    { /* block id: 49 */
        int32_t *** const *l_146 = &l_90;
        int32_t *** const **l_145 = &l_146;
        uint32_t l_164 = 4294967290UL;
        uint16_t l_226 = 0xF8F2L;
        (**g_81) = ((void*)0 == &g_81);
        for (p_40 = 0; (p_40 == 19); ++p_40)
        { /* block id: 53 */
            int32_t ****l_141 = &l_90;
            uint32_t l_165 = 0x430F9885L;
            int16_t l_166 = 0xCC87L;
            int8_t l_225 = 1L;
        }
        (*g_82) = ((g_150.f0 || l_226) == p_40);
        (*g_82) = ((int16_t)((uint16_t)(((int16_t)g_150.f7 - (int16_t)p_40) || ((((((int16_t)((((***l_146) != (*g_196)) | 0x960FL) && (((***l_145) == (*g_195)) <= p_40)) << (int16_t)p_40) | 1UL) & g_150.f0) == 2L) | p_40)) >> (uint16_t)2) + (int16_t)g_44);
    }
    for (g_150.f4 = 0; (g_150.f4 > 46); g_150.f4 += 4)
    { /* block id: 99 */
        int32_t l_237 = 0L;
        int32_t l_238 = 0x046C2142L;
        (***g_80) = l_237;
        (***g_194) = &l_237;
        /* statement id: 101 */
        assert (g_78 == &l_237);
        if (l_238)
            break;
        //assert (g_78 == dangling);
        (**g_196) = (((uint32_t)(*l_43) % (uint32_t)p_40) || ((((int32_t)(((int16_t)(((void*)0 == (**g_193)) != (((uint16_t)((uint16_t)((uint16_t)(p_40 <= (l_237 >= (((void*)0 != (***l_89)) && 8L))) >> (uint16_t)7) >> (uint16_t)10) << (uint16_t)5) == p_40)) << (int16_t)10) == p_40) % (int32_t)p_40) || 0x02E813D5L) | (-6L)));
    }
    /* facts after for loop */
    //assert (g_78 == dangling || g_78 == &g_44 || g_78 == 0);
    return p_40;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    transparent_crc(g_83, "g_83", print_hash_value);
    transparent_crc(g_150.f0, "g_150.f0", print_hash_value);
    transparent_crc(g_150.f1, "g_150.f1", print_hash_value);
    transparent_crc(g_150.f2, "g_150.f2", print_hash_value);
    transparent_crc(g_150.f3, "g_150.f3", print_hash_value);
    transparent_crc(g_150.f4, "g_150.f4", print_hash_value);
    transparent_crc(g_150.f5, "g_150.f5", print_hash_value);
    transparent_crc(g_150.f6, "g_150.f6", print_hash_value);
    transparent_crc(g_150.f7, "g_150.f7", print_hash_value);
    transparent_crc(g_223, "g_223", print_hash_value);
    transparent_crc(g_268.f0, "g_268.f0", print_hash_value);
    transparent_crc(g_268.f1, "g_268.f1", print_hash_value);
    transparent_crc(g_270, "g_270", print_hash_value);
    transparent_crc(g_438.f0, "g_438.f0", print_hash_value);
    transparent_crc(g_438.f1, "g_438.f1", print_hash_value);
    transparent_crc(g_438.f2, "g_438.f2", print_hash_value);
    transparent_crc(g_438.f3, "g_438.f3", print_hash_value);
    transparent_crc(g_438.f4, "g_438.f4", print_hash_value);
    transparent_crc(g_438.f5, "g_438.f5", print_hash_value);
    transparent_crc(g_438.f6, "g_438.f6", print_hash_value);
    transparent_crc(g_438.f7, "g_438.f7", print_hash_value);
    transparent_crc(g_484, "g_484", print_hash_value);
    transparent_crc(g_486.f0, "g_486.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 90
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 7
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 4
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 3

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 21
   depth: 3, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 18, occurrence: 3
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 26, occurrence: 2
   depth: 30, occurrence: 1

XXX total number of pointers: 83

XXX times a variable address is taken: 89
XXX times a pointer is dereferenced on RHS: 61
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 8
   depth: 3, occurrence: 8
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 64
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 11
   depth: 3, occurrence: 11
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 409

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 106
   level: 2, occurrence: 73
   level: 3, occurrence: 76
   level: 4, occurrence: 50
   level: 5, occurrence: 30
XXX number of pointers point to pointers: 46
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 21.7
XXX average alias set size: 1.13

XXX times a non-volatile is read: 487
XXX times a non-volatile is write: 180
XXX times a volatile is read: 25
XXX    times read thru a pointer: 6
XXX times a volatile is write: 20
XXX    times written thru a pointer: 20
XXX times a volatile is available for access: 224
XXX percentage of non-volatile access: 93.7

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 101
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 27
   depth: 2, occurrence: 21
   depth: 3, occurrence: 13
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 14.9
XXX percentage an existing variable is used: 85.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

