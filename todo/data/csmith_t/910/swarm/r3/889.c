/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      856135532
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   volatile signed f0 : 4;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 4294967293UL;
static int32_t g_51 = 7L;
static struct S0 g_81 = {-3};/* VOLATILE GLOBAL g_81 */
static int32_t g_85 = 0xCE01153AL;
static int32_t *g_84 = &g_85;
static struct S0 **g_90 = (void*)0;
static volatile struct S0 g_139 = {1};/* VOLATILE GLOBAL g_139 */
static struct S0 g_145 = {-1};/* VOLATILE GLOBAL g_145 */
static volatile int32_t g_168 = 0xA39D249FL;/* VOLATILE GLOBAL g_168 */
static volatile int32_t *g_167 = &g_168;
static volatile int32_t **g_166 = &g_167;
static volatile int32_t ***g_165 = &g_166;
static volatile int32_t g_185 = 0x3838C22DL;/* VOLATILE GLOBAL g_185 */
static struct S0 g_188 = {1};/* VOLATILE GLOBAL g_188 */
static uint32_t g_213 = 4294967290UL;
static volatile uint16_t g_222 = 0UL;/* VOLATILE GLOBAL g_222 */
static struct S0 g_227 = {1};/* VOLATILE GLOBAL g_227 */
static struct S0 g_254 = {2};/* VOLATILE GLOBAL g_254 */
static int32_t **g_270 = &g_84;
static int32_t ***g_269 = &g_270;
static int32_t ****g_268 = &g_269;
static int32_t *****g_267 = &g_268;
static volatile struct S0 g_311 = {2};/* VOLATILE GLOBAL g_311 */
static volatile struct S0 g_312 = {1};/* VOLATILE GLOBAL g_312 */
static const struct S0 g_313 = {-3};/* VOLATILE GLOBAL g_313 */


/* --- FORWARD DECLARATIONS --- */
inline static const struct S0  func_26(void);
inline static int32_t * func_27(int32_t  p_28, int32_t  p_29, int32_t * p_30);
static uint16_t  func_34(const int32_t * p_35, const int64_t  p_36, uint32_t  p_37);
static int32_t * func_38(int32_t * p_39, int32_t * p_40, int64_t  p_41);
inline static int32_t * func_42(uint64_t  p_43, uint16_t  p_44, uint16_t  p_45);
static int64_t  func_54(uint64_t  p_55, int32_t * p_56, int32_t * p_57);
inline static int32_t * func_58(const int32_t * p_59, uint32_t  p_60, int16_t  p_61);
static int32_t * func_62(uint16_t  p_63, int32_t  p_64);
static uint16_t  func_65(const int64_t  p_66, uint32_t  p_67, uint32_t  p_68, uint32_t  p_69);
static int32_t * func_72(int32_t * p_73, int32_t  p_74, int32_t * p_75, const uint64_t  p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_51 g_81 g_85 g_90 g_84 g_139 g_145 g_165 g_222 g_213 g_269 g_270 g_311 g_313
 * writes: g_81 g_84 g_85 g_139 g_51 g_145 g_165 g_312
 */
inline static const struct S0  func_26(void)
{ /* block id: 36 */
    uint16_t l_33 = 0xAEF6L;
    int32_t *l_50 = &g_51;
    uint16_t l_109 = 0x79D7L;
    uint32_t l_126 = 0xF8796DE1L;
    (**g_269) = func_27((safe_sub_func_int64_t_s_s(l_33, 0x29EDCA8FECF7921ELL)), ((((g_6 <= (func_34(func_38(func_42(g_6, (safe_sub_func_uint16_t_u_u((l_33 > (safe_add_func_int16_t_s_s((l_50 == (void*)0), (safe_sub_func_int64_t_s_s((func_54((*l_50), func_58(func_62(func_65(((safe_rshift_func_int16_t_s_u(0L, 14)) && (*l_50)), g_6, g_51, (*l_50)), l_109), (*l_50), g_6), &g_51) <= 0xE4AF0E761D3F42B3LL), (*l_50)))))), 0x529CL)), l_126), l_50, g_6), l_109, g_6) || g_222)) && g_213) >= g_213) < 0xEC9F885BBE77973ELL), l_50);
    /* statement id: 201 */
    assert (g_84 == &g_51);
    g_312 = g_311;
    return g_313;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_27(int32_t  p_28, int32_t  p_29, int32_t * p_30)
{ /* block id: 199 */
    int32_t *l_310 = &g_51;
    return l_310;
    /* statement id: 200 */
    //assert (func_27_rv == &g_51);
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_84 g_85 g_165
 * writes: g_51 g_85 g_165
 */
static uint16_t  func_34(const int32_t * p_35, const int64_t  p_36, uint32_t  p_37)
{ /* block id: 109 */
    int16_t l_175 = 1L;
    int32_t ***l_240 = (void*)0;
    int32_t ****l_239 = &l_240;
    uint32_t l_241 = 1UL;
    struct S0 *l_265 = &g_254;
    int16_t l_308 = 0x0795L;
    for (g_51 = (-11); (g_51 <= 10); g_51 = safe_add_func_uint64_t_u_u(g_51, 8))
    { /* block id: 112 */
        int32_t l_159 = 2L;
        int32_t **l_170 = &g_84;
        int32_t ***l_171 = (void*)0;
        int32_t ***l_172 = &l_170;
        uint32_t l_242 = 4294967295UL;
        struct S0 *l_253 = &g_254;
        uint32_t l_287 = 0x0F040C40L;
        uint64_t l_307 = 18446744073709551615UL;
        l_159 = (*g_84);
        for (g_85 = 0; (g_85 < (-3)); --g_85)
        { /* block id: 116 */
            int64_t l_164 = 0x1196D9F78EB29201LL;
            volatile int32_t ****l_169 = &g_165;
            l_159 = (safe_mod_func_uint16_t_u_u(l_164, 0xDF58L));
            (*l_169) = g_165;
        }
        (*l_172) = l_170;
    }
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_84
 * writes: g_85 g_51
 */
static int32_t * func_38(int32_t * p_39, int32_t * p_40, int64_t  p_41)
{ /* block id: 104 */
    int32_t *l_147 = &g_85;
    struct S0 *l_156 = (void*)0;
    (*g_84) = ((&g_85 == l_147) ^ __builtin_ffsll((safe_sub_func_uint64_t_u_u((safe_lshift_func_int16_t_s_s(((safe_sub_func_int64_t_s_s((*l_147), (0x5AAA48D7F8389229LL & (safe_lshift_func_uint16_t_u_s(((&p_39 == &l_147) >= (p_40 == l_147)), 0))))) != (*l_147)), 11)), (*l_147)))));
    l_147 = l_147;
    l_156 = l_156;
    return l_147;
    /* statement id: 108 */
    //assert (func_38_rv == &g_85);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_51 g_81.f0 g_85 g_81 g_90 g_84 g_139 g_145
 * writes: g_85 g_84 g_81 g_139 g_51 g_145
 */
inline static int32_t * func_42(uint64_t  p_43, uint16_t  p_44, uint16_t  p_45)
{ /* block id: 80 */
    const int64_t l_127 = 3L;
    uint32_t l_132 = 0xCF740941L;
    int32_t *l_136 = &g_85;
    struct S0 *l_146 = &g_145;
    (*l_136) = func_65(l_127, __builtin_ctzll(g_6), (g_51 || (safe_lshift_func_int16_t_s_s((p_43 | (0x6617FA17L & 4294967295UL)), 6))), ((func_54((safe_sub_func_uint64_t_u_u(l_132, ((+(safe_add_func_int32_t_s_s(l_132, 0L))) < g_81.f0))), &g_51, l_136) && 0x19DAAC0CAA660014LL) || (*l_136)));
    /* statement id: 81 */
    assert (g_84 == &g_51);
    for (p_44 = 0; (p_44 >= 16); p_44++)
    { /* block id: 84 */
        volatile struct S0 *l_140 = &g_139;
        int32_t **l_141 = &g_84;
        (*l_140) = g_139;
        if (((l_141 == (void*)0) >= ((~p_44) > (g_51 && (**l_141)))))
        { /* block id: 86 */
            (**l_141) = 0xCE035960L;
            (*l_141) = l_136;
            /* statement id: 88 */
            assert (g_84 == &g_85);
            (**l_141) = (p_44 && p_45);
        }
        else
        { /* block id: 90 */
            if ((**l_141))
                break;
            (*l_141) = (*l_141);
        }
        if (p_45)
            break;
    }
    /* facts after for loop */
    assert (g_84 == &g_51 || g_84 == &g_85);
    for (p_44 = 0; (p_44 > 39); p_44++)
    { /* block id: 98 */
        (*g_84) = p_45;
        (*g_84) = (&g_84 != (void*)0);
    }
    (*l_146) = g_145;
    return l_136;
    /* statement id: 103 */
    //assert (func_42_rv == &g_85);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_85 g_84
 */
static int64_t  func_54(uint64_t  p_55, int32_t * p_56, int32_t * p_57)
{ /* block id: 70 */
    struct S0 ***l_118 = &g_90;
    struct S0 ****l_119 = &l_118;
    int32_t l_122 = 0L;
    (*l_119) = l_118;
    p_56 = &g_51;
    /* statement id: 72 */
    assert (p_56 == &g_51);
    for (p_55 = (-3); (p_55 < 17); p_55 = safe_add_func_uint64_t_u_u(p_55, 1))
    { /* block id: 75 */
        int32_t **l_123 = (void*)0;
        int32_t **l_124 = (void*)0;
        int32_t **l_125 = &g_84;
        g_84 = func_62(l_122, p_55);
        /* statement id: 76 */
        assert (g_84 == &g_85);
        (*l_125) = &g_85;
    }
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_51 g_81 g_84
 * writes: g_81 g_85
 */
inline static int32_t * func_58(const int32_t * p_59, uint32_t  p_60, int16_t  p_61)
{ /* block id: 66 */
    int32_t *l_112 = &g_51;
    struct S0 *l_114 = &g_81;
    struct S0 **l_113 = &l_114;
    int32_t **l_115 = (void*)0;
    int32_t **l_116 = &l_112;
    int32_t *l_117 = &g_85;
    (*l_116) = func_72(l_112, ((void*)0 == l_113), l_112, g_85);
    (*l_117) = (*g_84);
    return &g_51;
    /* statement id: 69 */
    //assert (func_58_rv == &g_51);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_85
 */
static int32_t * func_62(uint16_t  p_63, int32_t  p_64)
{ /* block id: 63 */
    uint32_t l_110 = 0x5F2ABA01L;
    int32_t *l_111 = &g_85;
    (*l_111) = l_110;
    return l_111;
    /* statement id: 65 */
    //assert (func_62_rv == &g_85);
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_6 g_81 g_85 g_90 g_84
 * writes: g_81 g_84 g_85
 */
static uint16_t  func_65(const int64_t  p_66, uint32_t  p_67, uint32_t  p_68, uint32_t  p_69)
{ /* block id: 37 */
    int32_t *l_77 = &g_51;
    struct S0 *l_86 = &g_81;
    int32_t *l_87 = &g_85;
    int16_t l_91 = 8L;
    struct S0 *l_106 = &g_81;
    g_84 = func_72(l_77, (*l_77), l_77, g_6);
    /* statement id: 47 */
    assert (g_84 == &g_51);
    (*l_86) = g_81;
    (*l_87) = p_69;
    if ((((*l_77) > 0x08CDB5CFL) <= (safe_lshift_func_uint16_t_u_s((5L <= (*l_87)), (g_90 == &l_86)))))
    { /* block id: 50 */
        const struct S0 *l_97 = (void*)0;
        const struct S0 **l_96 = &l_97;
        int32_t l_102 = 0xAE9822C2L;
        (*l_87) = (l_91 & p_68);
        (*l_87) = (((0x20E5L | p_68) != p_66) ^ ((safe_mod_func_int32_t_s_s((l_96 != g_90), (safe_add_func_int64_t_s_s(((safe_rshift_func_uint16_t_u_u(0x1B4DL, 9)) ^ (*g_84)), (l_102 && (p_68 <= p_66)))))) == 18446744073709551615UL));
        for (p_69 = 0; (p_69 > 32); p_69 = safe_add_func_uint16_t_u_u(p_69, 9))
        { /* block id: 55 */
            int32_t l_105 = 0x34C8A1B6L;
            (*l_87) = (((l_86 == &g_81) ^ ((l_102 >= l_102) && l_105)) | l_102);
        }
    }
    else
    { /* block id: 58 */
        (*l_87) = ((void*)0 == l_106);
        (*l_87) = (g_85 && ((*l_77) <= (*l_87)));
    }
    return g_81.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_81 g_85
 * writes: g_81
 */
static int32_t * func_72(int32_t * p_73, int32_t  p_74, int32_t * p_75, const uint64_t  p_76)
{ /* block id: 38 */
    struct S0 *l_80 = &g_81;
    int32_t *l_83 = &g_51;
    for (p_74 = (-19); (p_74 >= (-10)); p_74 = safe_add_func_uint64_t_u_u(p_74, 2))
    { /* block id: 41 */
        struct S0 **l_82 = &l_80;
        if ((*p_73))
            break;
        (*l_82) = l_80;
    }
    (*l_80) = (*l_80);
    return l_83;
    /* statement id: 46 */
    //assert (func_72_rv == &g_51);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_51, "g_51", print_hash_value);
    transparent_crc(g_81.f0, "g_81.f0", print_hash_value);
    transparent_crc(g_85, "g_85", print_hash_value);
    transparent_crc(g_139.f0, "g_139.f0", print_hash_value);
    transparent_crc(g_145.f0, "g_145.f0", print_hash_value);
    transparent_crc(g_168, "g_168", print_hash_value);
    transparent_crc(g_185, "g_185", print_hash_value);
    transparent_crc(g_188.f0, "g_188.f0", print_hash_value);
    transparent_crc(g_213, "g_213", print_hash_value);
    transparent_crc(g_222, "g_222", print_hash_value);
    transparent_crc(g_227.f0, "g_227.f0", print_hash_value);
    transparent_crc(g_254.f0, "g_254.f0", print_hash_value);
    transparent_crc(g_311.f0, "g_311.f0", print_hash_value);
    transparent_crc(g_312.f0, "g_312.f0", print_hash_value);
    transparent_crc(g_313.f0, "g_313.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 67
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 16
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 7

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 18, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 73

XXX times a variable address is taken: 68
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 9
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 51
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 10
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 162

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 244
   level: 2, occurrence: 43
   level: 3, occurrence: 22
   level: 4, occurrence: 7
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 31
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 21.9
XXX average alias set size: 1.21

XXX times a non-volatile is read: 328
XXX times a non-volatile is write: 132
XXX times a volatile is read: 19
XXX    times read thru a pointer: 2
XXX times a volatile is write: 12
XXX    times written thru a pointer: 11
XXX times a volatile is available for access: 117
XXX percentage of non-volatile access: 93.7

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 57
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 17
   depth: 2, occurrence: 8

XXX percentage a fresh-made variable is used: 23.9
XXX percentage an existing variable is used: 76.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

