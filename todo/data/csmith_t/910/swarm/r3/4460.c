/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --safe-math --no-packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1993028030
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint16_t  f1;
   int32_t  f2;
   unsigned f3 : 4;
   int32_t  f4;
   uint32_t  f5;
};

struct S1 {
   signed f0 : 10;
   unsigned f1 : 27;
   unsigned : 0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
inline static struct S0  func_32(uint32_t  p_33, struct S1  p_34);
static struct S0  func_38(uint32_t  p_39, float  p_40, struct S0  p_41, int16_t  p_42);
inline static uint16_t  func_43(int32_t  p_44, float  p_45, struct S0  p_46, uint16_t  p_47);
static int32_t  func_62(int32_t  p_63, uint32_t  p_64);
inline static float  func_66(uint64_t  p_67, int32_t  p_68, uint64_t  p_69, struct S0  p_70, struct S1  p_71);
inline static int32_t  func_83(struct S1  p_84, uint32_t  p_85);
inline static struct S1  func_86(uint32_t  p_87, float  p_88);
inline static struct S0  func_89(uint32_t  p_90, float  p_91, float  p_92, struct S1  p_93);
inline static int64_t  func_94(int32_t  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    uint32_t l_31 = 0x07C2076AL;
    int64_t l_60 = 0x4B4404179B2C3978LL;
    struct S0 l_155 = {0L,0x5419L,0x12A095ECL,2,0xD8F89870L,0x34082CCCL};
    struct S1 l_271 = {-25,10131};
    int32_t l_305 = 0xE0A3D1CDL;
    int64_t l_312 = 0xD80D04DAC93ADBD3LL;
    if (l_31)
    { /* block id: 37 */
        int32_t l_35 = 0L;
        struct S0 l_61 = {0x4807L,1UL,0xB9EFECF4L,3,1L,0x4D244069L};
        struct S0 l_274 = {0L,65532UL,0L,3,-1L,0x1D697769L};
        l_274 = func_32(l_35, (((l_35 >= l_35) & ((safe_rshift_func_uint16_t_u_s((func_38((((l_35 != func_43(l_35, l_31, ((((safe_div_func_int64_t_s_s((safe_sub_func_int32_t_s_s((safe_sub_func_int16_t_s_s(((safe_div_func_int16_t_s_s(0xCCC4L, ((safe_mul_func_int16_t_s_s((safe_add_func_uint64_t_u_u(l_31, l_35)), l_31)) , l_35))) && l_31), 0x6013L)), l_35)), 0x4730E92F9E84EBF8LL)) > l_60) != l_60) , l_61), l_60)) <= 0xB14546EEL) >= 0x3D9F3A56L), l_61.f0, l_155, l_61.f2) , l_155.f2), l_155.f2)) || 1UL)) , l_271));
    }
    else
    { /* block id: 123 */
        int16_t l_290 = 0xAE27L;
        struct S0 l_302 = {0xAFFBL,1UL,0x73CC981AL,0,0xCEC0211FL,0xD28FF046L};
        struct S1 l_311 = {20,6847};
        int64_t l_313 = 0x750FABAB80782509LL;
        for (l_60 = (-3); (l_60 > 25); l_60 = safe_add_func_int64_t_s_s(l_60, 2))
        { /* block id: 126 */
            uint32_t l_279 = 0xA0A5BA7DL;
            for (l_155.f5 = (-22); (l_155.f5 > 27); l_155.f5 = safe_add_func_int64_t_s_s(l_155.f5, 4))
            { /* block id: 129 */
                l_271.f0 = l_279;
            }
        }
        l_271.f0 = (safe_mod_func_int64_t_s_s((safe_rshift_func_uint16_t_u_u(((l_155.f3 ^ l_31) || (!((safe_mul_func_uint16_t_u_u(l_31, func_43((!((safe_rshift_func_uint16_t_u_s(l_155.f1, 12)) && (func_94(l_290) <= (safe_unary_minus_func_int32_t_s((l_155.f3 == l_155.f4)))))), (((safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s(((safe_mod_func_uint16_t_u_u((((safe_mod_func_int32_t_s_s(func_62(l_155.f1, l_155.f1), l_155.f1)) >= 0L) || 0x89B5L), 65535UL)) , 0UL), l_31)), 8)), l_290)) == l_155.f5) , l_290), l_302, l_155.f0))) >= l_155.f5))), 14)), l_271.f0));
        l_155 = func_32(l_271.f0, func_86((2UL | (safe_rshift_func_int16_t_s_u(l_271.f0, 14))), (((func_94(l_305) , ((!(safe_div_func_float_f_f(func_43(l_155.f4, l_302.f1, func_32((0xBC355EAF38123D7DLL || __builtin_bswap64(((safe_add_func_uint32_t_u_u((__builtin_ctzll(l_302.f5) <= 0xD68CL), 0xE377B8EFL)) , l_302.f4))), l_311), l_312), 0x1.Ep-1))) < l_302.f0)) == l_311.f1) <= l_313)));
    }
    l_271.f0 = (safe_mod_func_int16_t_s_s(l_312, 0xA2B0L));
    return l_155.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_32(uint32_t  p_33, struct S1  p_34)
{ /* block id: 119 */
    int64_t l_272 = 0x2582D2ECE790BFC1LL;
    struct S0 l_273 = {1L,65535UL,3L,1,0x5026C6EBL,0xC2930577L};
    l_272 = 0xA.1C5A12p+75;
    return l_273;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_38(uint32_t  p_39, float  p_40, struct S0  p_41, int16_t  p_42)
{ /* block id: 79 */
    uint32_t l_158 = 0x847BF470L;
    struct S1 l_203 = {-17,3653};
    struct S0 l_222 = {0x09F4L,0xCCDDL,-1L,1,6L,4294967289UL};
    float l_270 = 0x1.Ap+1;
    for (p_41.f4 = 0; (p_41.f4 != (-18)); p_41.f4 = safe_sub_func_int64_t_s_s(p_41.f4, 6))
    { /* block id: 82 */
        uint32_t l_170 = 0xCD05A9BBL;
        struct S0 l_200 = {0L,65527UL,1L,0,0xD446BF52L,0x38B0DACAL};
        struct S1 l_204 = {19,8389};
        int32_t l_227 = 0x9CC71544L;
        if (l_158)
            break;
        for (p_41.f5 = (-6); (p_41.f5 < 52); p_41.f5 = safe_add_func_int16_t_s_s(p_41.f5, 7))
        { /* block id: 86 */
            uint32_t l_167 = 18446744073709551613UL;
            int32_t l_184 = 0L;
            struct S0 l_193 = {1L,0x8E68L,0x208B660CL,1,4L,4294967291UL};
            uint32_t l_194 = 0x2AC288FBL;
            struct S1 l_195 = {-26,1328};
            l_184 = (safe_mul_func_int16_t_s_s(0x2363L, (((safe_lshift_func_int16_t_s_s(((-1L) >= (safe_lshift_func_uint16_t_u_u(l_167, (safe_div_func_uint16_t_u_u(l_170, (safe_lshift_func_int16_t_s_s(l_158, 4))))))), 4)) , p_39) , (safe_sub_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_u(l_170, (safe_add_func_uint16_t_u_u((((safe_unary_minus_func_uint64_t_u(l_167)) != (safe_div_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u(((l_167 , 0xFD7AL) != l_158), l_167)) , 0xB980L), p_42))) <= l_158), p_42)))) || 0xE8D4C1FEDC4901C9LL), l_170)))));
            l_195 = func_86(((p_41.f2 & ((l_184 , (safe_lshift_func_uint16_t_u_u((p_41.f0 & ((0x2A72L < (safe_rshift_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((safe_mul_func_uint16_t_u_u((p_41.f4 == 0xD2A3L), func_43(l_158, p_41.f0, l_193, p_41.f2))), l_170)), 7))) & l_193.f5)), l_194))) | 0xD74AL)) , p_41.f5), l_170);
            if (p_41.f1)
                continue;
            l_184 = ((safe_div_func_uint64_t_u_u(p_41.f5, 0x454B42CA7F906C09LL)) , ((65535UL != ((l_193.f1 ^ (l_195.f1 != (((-4L) < p_41.f3) >= (safe_lshift_func_int16_t_s_u(l_170, 9))))) | func_43(p_41.f2, p_42, l_200, l_200.f1))) & 0x169FL));
        }
        for (p_39 = (-28); (p_39 < 32); p_39 = safe_add_func_int16_t_s_s(p_39, 3))
        { /* block id: 94 */
            int32_t l_220 = 0xCB9ADD75L;
            l_204 = l_203;
            p_40 = ((__builtin_bswap64((safe_mod_func_uint64_t_u_u(((safe_mul_func_int16_t_s_s((p_41.f3 < (!(safe_add_func_uint16_t_u_u(p_41.f2, (safe_lshift_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(0x6FC4B737L, p_41.f4)), 2)))))), ((__builtin_popcountll((safe_sub_func_int64_t_s_s(((safe_div_func_int32_t_s_s(l_220, ((((safe_unary_minus_func_uint64_t_u((((p_41.f2 | (l_222 , (safe_sub_func_int16_t_s_s((((p_41.f0 >= ((safe_add_func_uint16_t_u_u(l_227, 1UL)) || l_204.f0)) != 18446744073709551614UL) | l_222.f3), l_203.f1)))) && l_200.f1) & p_41.f5))) >= l_222.f2) ^ l_220) ^ 18446744073709551608UL))) && p_41.f5), l_200.f0))) && l_222.f0) || l_222.f4))) ^ p_39), 0xE80E6B5D3E5C67DELL))) , 0x1.0p+1) <= l_220);
            if ((safe_mul_func_uint16_t_u_u((safe_div_func_int32_t_s_s(func_62((~((__builtin_ffsl(l_204.f1) , ((((0x0B63L & 0x4E20L) , (((safe_rshift_func_uint16_t_u_u((((safe_sub_func_int32_t_s_s((((((safe_lshift_func_uint16_t_u_u((((l_220 , l_220) == (p_41.f3 | l_200.f0)) >= p_41.f4), 15)) > l_222.f2) , l_203) , 4294967286UL) | (-1L)), l_220)) < l_220) >= l_170), 10)) == p_41.f0) >= p_41.f4)) , p_42) ^ l_200.f3)) < l_220)), p_42), 0xCB556FD8L)), l_222.f0)))
            { /* block id: 97 */
                struct S1 l_242 = {-18,6186};
                uint32_t l_263 = 0UL;
                for (l_200.f2 = (-2); (l_200.f2 == 4); l_200.f2 = safe_add_func_int16_t_s_s(l_200.f2, 6))
                { /* block id: 100 */
                    struct S1 l_243 = {29,1325};
                    if ((0xE662L <= p_39))
                    { /* block id: 101 */
                        struct S1 l_241 = {12,1006};
                        l_242 = l_241;
                        l_243 = l_203;
                    }
                    else
                    { /* block id: 104 */
                        uint16_t l_250 = 5UL;
                        l_242.f0 = (((safe_mul_func_int16_t_s_s(((((safe_div_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(l_222.f3, 0x86A2L)), l_220)) || (((l_250 , (18446744073709551614UL > (safe_lshift_func_int16_t_s_s(p_41.f4, 10)))) > (safe_mul_func_int16_t_s_s(((((((safe_lshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_s((p_41.f5 | (l_243.f1 < ((((((safe_div_func_uint16_t_u_u(((((safe_lshift_func_uint16_t_u_s(((l_243.f0 ^ 0xFCCDL) <= p_39), 9)) >= 0x23EACF7FL) ^ p_41.f3) < 0x839589B9L), (-1L))) < l_200.f2) ^ 0x48997D2CL) < l_200.f4) , l_263) < p_42))), l_158)), 10)) & 0x0A2B0F9EBF1156F7LL) >= l_242.f1) <= l_220) ^ p_41.f3) >= 0xE66CL), 0UL))) | p_39)) ^ 0xCB9D27FBL) && l_243.f1), p_42)) > p_39) == 0xE8CEDF58L);
                    }
                    return p_41;
                }
            }
            else
            { /* block id: 109 */
                int32_t l_267 = 0xC26318D7L;
                l_203.f0 = (!__builtin_ctz((safe_rshift_func_uint16_t_u_s((9UL == p_41.f0), 14))));
                if (p_41.f5)
                    continue;
                if (l_267)
                    continue;
            }
            l_203 = ((0x70AC94271DECC0E9LL & ((safe_rshift_func_uint16_t_u_u(l_220, 3)) , l_203.f0)) , l_204);
        }
    }
    p_40 = l_270;
    return l_222;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_43(int32_t  p_44, float  p_45, struct S0  p_46, uint16_t  p_47)
{ /* block id: 38 */
    uint32_t l_65 = 0x6EF5427EL;
    int32_t l_154 = 7L;
    l_154 = func_62(p_47, l_65);
    return l_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_62(int32_t  p_63, uint32_t  p_64)
{ /* block id: 39 */
    int32_t l_80 = 1L;
    struct S0 l_151 = {0x81EAL,0xD68FL,0xE5417E04L,3,0xFEB8C283L,0x3F385F19L};
    struct S1 l_152 = {-19,2456};
    l_152.f0 = ((p_64 , func_66(((((safe_rshift_func_int16_t_s_s((safe_sub_func_uint64_t_u_u((safe_add_func_int16_t_s_s(7L, (safe_add_func_uint16_t_u_u(l_80, ((safe_rshift_func_int16_t_s_u((l_80 , p_63), 12)) != func_83(func_86(p_63, l_80), (l_80 , 0x3262CCAFL))))))), 1L)), 4)) == l_80) , 0xAA7700A2L) ^ p_64), l_80, l_80, l_151, l_152)) > l_151.f0);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_66(uint64_t  p_67, int32_t  p_68, uint64_t  p_69, struct S0  p_70, struct S1  p_71)
{ /* block id: 73 */
    float l_153 = 0xE.4BCF40p-91;
    return l_153;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_83(struct S1  p_84, uint32_t  p_85)
{ /* block id: 57 */
    uint16_t l_112 = 65528UL;
    int32_t l_127 = (-1L);
    struct S0 l_129 = {0xE3DAL,0xCA8AL,-1L,1,5L,0xE4ACFCA9L};
    uint16_t l_140 = 1UL;
    uint32_t l_148 = 0xA0805470L;
    if ((l_112 ^ p_84.f1))
    { /* block id: 58 */
        p_84.f0 = 0x20E0461AL;
    }
    else
    { /* block id: 60 */
        uint16_t l_117 = 0x4D57L;
        struct S1 l_128 = {-30,4140};
        p_84.f0 = (safe_mod_func_int32_t_s_s(func_94(func_94(((((safe_add_func_float_f_f((func_94(l_117) <= ((safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_div_func_float_f_f((p_84.f0 == (((p_84.f1 == __builtin_ctzll(l_117)) >= (l_112 < p_84.f0)) >= (safe_div_func_float_f_f((((func_89(__builtin_clzll((!l_117)), p_84.f0, l_127, l_128) , p_84.f0) || p_84.f1) , l_112), l_117)))), 0x9.2p+1)), p_85)) >= p_84.f1), l_112)) < p_84.f0)), l_117)) == 0xA.14E576p+97) > l_112) , l_112))), p_85));
        l_129 = l_129;
        for (p_85 = 12; (p_85 >= 37); p_85 = safe_add_func_uint64_t_u_u(p_85, 2))
        { /* block id: 65 */
            uint32_t l_132 = 4294967295UL;
            p_84.f0 = (l_132 && l_127);
        }
        l_129 = func_89(((safe_rshift_func_int16_t_s_s(((~(((safe_mul_func_int16_t_s_s((((-2L) <= p_84.f0) | p_85), ((safe_lshift_func_int16_t_s_s(l_129.f5, 11)) , (-3L)))) < l_140) | (safe_lshift_func_int16_t_s_u(((func_94((((p_84.f0 || (func_94(l_117) < 18446744073709551612UL)) < (-7L)) < l_128.f1)) != l_129.f4) > p_85), l_117)))) <= 0x06FDL), 12)) ^ (-1L)), p_85, p_84.f1, l_128);
    }
    l_127 = l_129.f0;
    p_84.f0 = (func_94(l_112) , ((!(safe_lshift_func_int16_t_s_u(p_84.f0, (safe_lshift_func_int16_t_s_s((p_84.f1 >= 0x58CEABDBL), ((l_129.f2 < (l_148 == 4L)) == (safe_rshift_func_uint16_t_u_s((0xD68B9C3B6F688DC7LL != p_84.f0), 12)))))))) <= l_129.f4));
    return p_85;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_86(uint32_t  p_87, float  p_88)
{ /* block id: 40 */
    int64_t l_98 = 0x614A4D940870E267LL;
    struct S1 l_102 = {26,10018};
    struct S0 l_111 = {1L,0x66F5L,0x3643AD1FL,3,0xD8C8EF01L,4294967289UL};
    l_102.f0 = (func_89((__builtin_ffsll(func_94((safe_sub_func_uint16_t_u_u((l_98 >= 0x5DD176C5L), l_98)))) & p_87), ((-0x1.Dp-1) >= (safe_div_func_float_f_f(((func_94(l_98) == l_98) != l_98), 0x0.D43E6Bp-32))), l_98, l_102) , l_102.f0);
    if (l_102.f1)
    { /* block id: 50 */
        return l_102;
    }
    else
    { /* block id: 52 */
        int16_t l_108 = 0L;
        l_111 = func_89(l_108, ((((l_108 != l_108) & func_94((p_87 | (func_94(p_87) , (((0L != (safe_div_func_int32_t_s_s(p_87, (-9L)))) & p_87) , 0x8BA4L))))) == p_87) , l_108), p_87, l_102);
        p_88 = l_108;
    }
    return l_102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_89(uint32_t  p_90, float  p_91, float  p_92, struct S1  p_93)
{ /* block id: 46 */
    struct S0 l_105 = {0x41A7L,0UL,-1L,3,7L,4294967293UL};
    int64_t l_106 = 1L;
    float l_107 = 0xB.D82229p-68;
    p_92 = (safe_add_func_float_f_f((p_93.f0 , (0xA.942BEBp-24 != (((0xC05799F9L | (l_105 , l_105.f5)) || (((p_90 || l_106) , p_93.f1) , (0x104DL | p_93.f0))) , 0x1.Fp-1))), l_105.f0));
    return l_105;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_94(int32_t  p_95)
{ /* block id: 41 */
    struct S1 l_99 = {0,4666};
    l_99 = l_99;
    l_99.f0 = 0x5.606BDEp+98;
    l_99.f0 = ((p_95 > p_95) , l_99.f1);
    return p_95;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 44
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 24
breakdown:
   indirect level: 0, occurrence: 24
XXX full-bitfields structs in the program: 12
breakdown:
   indirect level: 0, occurrence: 12
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 28
XXX times a single bitfield on LHS: 13
XXX times a single bitfield on RHS: 45

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 12, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 2
   depth: 31, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 298
XXX times a non-volatile is write: 40
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 61
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 15
   depth: 2, occurrence: 10
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 20.9
XXX percentage an existing variable is used: 79.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

