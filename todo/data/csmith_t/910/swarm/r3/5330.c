/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      877646702
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int32_t  f1;
   int32_t  f2;
   float  f3;
   float  f4;
   int64_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_32(void);
static int32_t * func_33(int32_t * p_34, uint64_t  p_35, int32_t * p_36);
static int32_t * func_37(uint32_t  p_38, int32_t * p_39, int32_t  p_40);
static int32_t * func_42(uint64_t  p_43, int32_t * p_44, uint16_t  p_45);
static struct S0  func_50(uint32_t  p_51, int32_t  p_52, int32_t * p_53, int32_t * p_54, uint64_t  p_55);
static uint32_t  func_58(int32_t * p_59, int32_t * p_60, int32_t * p_61, uint16_t  p_62, uint64_t  p_63);
static int32_t * func_66(int32_t * p_67, int16_t  p_68, int16_t  p_69);
static uint16_t  func_73(int64_t  p_74, int16_t  p_75, int64_t  p_76, float  p_77);
static float  func_81(uint64_t  p_82, uint16_t  p_83);
static uint64_t  func_84(uint32_t  p_85, float  p_86, uint32_t  p_87, int32_t * p_88, int32_t * p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_32(void)
{ /* block id: 36 */
    uint16_t l_41 = 0x10E5L;
    int32_t *l_46 = (void*)0;
    int64_t l_49 = 0L;
    int32_t ***l_384 = (void*)0;
    int8_t l_389 = (-9L);
    float l_406 = 0xF.35CE9Ep+2;
    float *l_405 = &l_406;
    float **l_404 = &l_405;
    int32_t l_411 = 0xF769CEDFL;
    int64_t l_424 = 0x6D62D0AB4210B8C5LL;
    int32_t l_426 = 0x847E4AD0L;
    int32_t *l_425 = &l_426;
    int32_t *****l_448 = (void*)0;
    struct S0 l_454 = {0x801B87AFL,1L,9L,0x9.Ep-1,-0x7.6p-1,-10L};
    struct S0 *l_455 = &l_454;
    uint32_t l_456 = 0xAE710A43L;
    l_46 = func_33(func_37(l_41, func_42((__builtin_popcountl(((l_41 != l_41) > 0x611FB8EB5EA28C7FLL)) > l_41), l_46, (l_41 ^ l_41)), l_49), l_41, l_46);
    if (((uint16_t)(l_41 & 1UL) >> (uint16_t)((uint16_t)(l_49 > (((uint32_t)l_49 / (uint32_t)l_41) ^ (-(uint16_t)(l_384 == l_384)))) / (uint16_t)((int32_t)((l_41 ^ ((int64_t)(-6L) % (int64_t)0x98CE2EFB70481B8DLL)) || l_389) + (int32_t)l_49))))
    { /* block id: 219 */
        int32_t l_396 = 1L;
        int32_t *l_395 = &l_396;
        for (l_389 = (-1); (l_389 < 12); l_389 += 2)
        { /* block id: 222 */
            int32_t l_393 = 0L;
            int32_t *l_392 = &l_393;
            int32_t **l_394 = &l_392;
            (*l_394) = l_392;
        }
        l_395 = l_395;
        l_46 = &l_396;
        /* statement id: 226 */
        assert (l_46 == &l_396);
        (*l_405) = ((float)(((float)func_58(&l_396, func_42((*l_395), &l_396, (!((uint32_t)(l_404 != &l_405) + (uint32_t)(((((int16_t)__builtin_popcount((*l_395)) << (int16_t)((int16_t)l_411 << (int16_t)((int32_t)(__builtin_parity((*l_46)) && 2L) - (int32_t)(*l_395)))) <= (*l_395)) <= (*l_46)) || 0x3176A2D43CEBE816LL)))), l_46, (*l_395), (*l_395)) + (float)(-0x1.4p-1)) >= (-0x7.Fp+1)) / (float)l_49);
    }
    else
    { /* block id: 228 */
        int32_t l_420 = 0xE45B5A84L;
        uint32_t l_453 = 0x31278A15L;
        if (((uint64_t)((((int64_t)l_420 + (int64_t)((uint32_t)0x4F7B4804L * (uint32_t)(!l_420))) || l_420) <= ((0x1BDC8B6CA54E26FELL == func_73(l_420, l_420, l_420, l_420)) >= 0x863AA56B7D8110DALL)) % (uint64_t)l_424))
        { /* block id: 229 */
            int32_t **l_427 = &l_46;
            (*l_427) = l_425;
            /* statement id: 230 */
            assert (l_46 == &l_426);
            return l_420;
        }
        else
        { /* block id: 232 */
            int32_t l_431 = 0x214D1C14L;
            int32_t **l_438 = &l_425;
            int32_t l_443 = 2L;
            (*l_425) = (0x52D37FD7L <= (1L || (((~((int16_t)(*l_425) >> (int16_t)(l_431 != ((uint16_t)l_420 << (uint16_t)((*l_425) >= l_431))))) && ((int32_t)l_420 + (int32_t)((int32_t)l_431 % (int32_t)l_420))) == (-1L))));
            (*l_438) = &l_431;
            /* statement id: 234 */
            assert (l_425 == &l_431);
            for (l_41 = (-10); (l_41 >= 2); l_41 += 8)
            { /* block id: 237 */
                uint64_t l_441 = 0x556FB1F53E0E9FCCLL;
                int32_t ****l_442 = &l_384;
                (*l_405) = l_420;
                (*l_425) = ((l_441 >= (l_442 == (void*)0)) < l_443);
            }
        }
        /* facts after branching */
        //assert (l_425 == dangling);
        l_420 = (func_73(__builtin_popcountll(l_420), __builtin_ctzll((((uint16_t)(l_448 != l_448) % (uint16_t)(l_420 | l_420)) & (((int16_t)(func_84(((l_420 <= (((((int16_t)((&l_404 == (void*)0) | l_420) >> (int16_t)15) && l_420) >= l_420) < l_420)) != l_420), l_420, l_420, &l_420, &l_420) | l_420) >> (int16_t)l_420) >= l_453))), l_453, l_453) || 0xAD3A0199F9680008LL);
    }
    /* facts after branching */
    //assert (l_46 == 0 || l_46 == dangling);
    //assert (l_425 == dangling || l_425 == &l_426);
    (*l_455) = l_454;
    return l_456;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_33(int32_t * p_34, uint64_t  p_35, int32_t * p_36)
{ /* block id: 213 */
    int32_t l_364 = 0xE0E923B7L;
    int32_t l_365 = 0x4E593E4FL;
    int32_t ****l_370 = (void*)0;
    int16_t l_371 = 0xED85L;
    struct S0 l_374 = {18446744073709551611UL,-7L,0L,-0x3.Cp-1,0x6.222A19p+62,-1L};
    struct S0 *l_375 = (void*)0;
    struct S0 *l_376 = &l_374;
    l_365 = ((float)l_364 / (float)l_364);
    l_365 = ((((1UL > ((l_364 && ((uint16_t)__builtin_clzl(__builtin_bswap32((0UL == p_35))) / (uint16_t)((uint16_t)(l_365 && (((void*)0 == l_370) < 4294967286UL)) << (uint16_t)p_35))) || p_35)) != l_371) ^ p_35) || 6L);
    (*l_376) = l_374;
    return p_36;
    /* statement id: 217 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(uint32_t  p_38, int32_t * p_39, int32_t  p_40)
{ /* block id: 39 */
    int32_t l_65 = 0x422F8DC7L;
    int32_t *l_64 = &l_65;
    int32_t *l_70 = &l_65;
    uint32_t l_78 = 0xF438361CL;
    int32_t l_317 = (-8L);
    struct S0 l_339 = {0xEA08A2A9L,9L,9L,0x3.1A405Fp+93,0xB.7B5E04p+80,0xF6BFF306726C21DDLL};
    struct S0 *l_340 = (void*)0;
    float *l_342 = &l_339.f4;
    float **l_341 = &l_342;
    int32_t **l_345 = &l_70;
    int32_t *l_356 = &l_65;
    int32_t *l_357 = &l_317;
    int32_t *l_358 = &l_317;
    int32_t *l_359 = &l_317;
    int32_t *l_360 = &l_339.f2;
    int32_t *l_361 = (void*)0;
    l_339 = func_50(((uint32_t)((func_58(l_64, func_66(l_70, ((uint16_t)func_73(l_78, (*l_64), (*l_70), ((((p_38 > ((float)func_81(func_84(p_40, (*l_64), ((!(__builtin_clzll(((((uint64_t)(__builtin_ctzll(p_38) <= p_40) - (uint64_t)(*l_70)) >= (*l_70)) <= 0x13E67DCAF6DDF936LL)) || (*l_70))) != (*l_70)), &l_65, &l_65), (*l_64)) / (float)p_38)) > 0x0.6p-1) == 0xD.EFBBEDp+82) != 0x0.0p-1)) >> (uint16_t)p_38), (*l_64)), &l_65, p_38, (*l_70)) && (*l_70)) == 7UL) / (uint32_t)p_40), l_317, &l_317, &l_317, p_38);
    l_340 = &l_339;
    /* statement id: 205 */
    assert (l_340 == &l_339);
    (*l_345) = func_66(func_42((*l_64), func_42((l_341 != &l_342), &l_65, (((uint32_t)((4294967292UL & (p_38 && (p_38 & (*l_70)))) > p_38) % (uint32_t)p_38) || 0x6341C7137C132428LL)), p_38), p_40, p_40);
    for (l_65 = 0; (l_65 != (-30)); l_65 -= 1)
    { /* block id: 209 */
        float l_348 = 0x9.F97041p-51;
        int32_t l_353 = (-7L);
        struct S0 l_355 = {0x8C674DE1L,0xDCA199E2L,9L,0x8.Bp+1,0xC.4F58ABp+63,-1L};
        (*l_340) = l_355;
    }
    return l_361;
    /* statement id: 212 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(uint64_t  p_43, int32_t * p_44, uint16_t  p_45)
{ /* block id: 37 */
    int32_t l_48 = 1L;
    int32_t *l_47 = &l_48;
    return p_44;
    /* statement id: 38 */
    //assert (func_42_rv == 0 || func_42_rv == &l_109 || func_42_rv == &l_100 || func_42_rv == &l_183.f1 || func_42_rv == &p_52 || func_42_rv == &l_65 || func_42_rv == &p_40 || func_42_rv == &l_396);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_50(uint32_t  p_51, int32_t  p_52, int32_t * p_53, int32_t * p_54, uint64_t  p_55)
{ /* block id: 191 */
    float l_318 = 0x2.4528E0p-1;
    int32_t l_319 = 0x256DE87AL;
    float ***l_334 = (void*)0;
    float ****l_333 = &l_334;
    float *****l_335 = &l_333;
    int32_t *l_337 = &l_319;
    int32_t **l_336 = &l_337;
    struct S0 l_338 = {0x14BD3B3BL,0x48C5682BL,0x9454B698L,-0x10.Ap-1,-0x2.3p+1,0xA895C0AAC95829EELL};
    if ((*p_54))
    { /* block id: 192 */
        int32_t *l_321 = (void*)0;
        int32_t **l_320 = &l_321;
        float *l_324 = &l_318;
        (*l_320) = func_42(l_319, &p_52, l_319);
        /* statement id: 193 */
        assert (l_321 == &p_52);
        (*l_324) = ((float)(0x9.4FB653p+66 <= (0x8.Dp+1 != (*l_321))) / (float)p_55);
    }
    else
    { /* block id: 195 */
        struct S0 l_325 = {0xC4C44AEBL,5L,0x8E144FA0L,0x0.Ep+1,0xB.8ACB36p+90,0x6220542C854347F6LL};
        struct S0 *l_326 = (void*)0;
        struct S0 *l_327 = &l_325;
        int32_t *l_328 = &l_325.f2;
        int32_t **l_332 = (void*)0;
        int32_t ***l_331 = &l_332;
        int32_t ****l_330 = &l_331;
        int32_t *****l_329 = &l_330;
        (*l_327) = l_325;
        (*p_54) = (p_52 & func_58(l_328, &p_52, func_66(l_328, p_55, ((void*)0 != &p_52)), (*l_328), p_51));
        l_329 = l_329;
    }
    (*l_335) = l_333;
    (*l_336) = &l_319;
    (**l_336) = (((func_73(p_52, p_51, (0UL && p_55), (**l_336)) <= (p_55 >= (&l_337 != (void*)0))) != p_52) == (**l_336));
    return l_338;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_58(int32_t * p_59, int32_t * p_60, int32_t * p_61, uint16_t  p_62, uint64_t  p_63)
{ /* block id: 179 */
    int32_t **l_298 = (void*)0;
    int32_t *l_300 = (void*)0;
    int32_t **l_299 = &l_300;
    float l_305 = (-0x10.5p-1);
    float *l_304 = &l_305;
    float **l_303 = &l_304;
    int32_t l_306 = 0L;
    (*l_299) = (void*)0;
    (*l_299) = p_61;
    /* statement id: 181 */
    //assert (l_300 == &l_65 || l_300 == &l_325.f2 || l_300 == &l_396);
    (**l_299) = ((((uint16_t)0UL << (uint16_t)(((((l_303 == &l_304) ^ 0x26302874L) & p_62) & l_306) || ((uint16_t)((!(**l_299)) < (((int32_t)(*p_59) + (int32_t)((*l_300) | 0x837497FDL)) >= 0x6219075D6D8AE4E6LL)) >> (uint16_t)1))) <= p_63) <= (*l_300));
    for (p_63 = (-28); (p_63 >= 52); p_63 += 7)
    { /* block id: 185 */
        uint64_t l_314 = 0x456EAE44536B6895LL;
        if (l_314)
            break;
        (*p_61) = __builtin_parityll(((int64_t)(((8L && 1UL) ^ p_63) | (**l_299)) - (int64_t)__builtin_popcountl(l_314)));
        return p_62;
    }
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_66(int32_t * p_67, int16_t  p_68, int16_t  p_69)
{ /* block id: 176 */
    int32_t **l_296 = (void*)0;
    int32_t ***l_295 = &l_296;
    int32_t ****l_297 = &l_295;
    (*l_297) = l_295;
    return p_67;
    /* statement id: 178 */
    //assert (func_66_rv == &l_65 || func_66_rv == &l_325.f2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_73(int64_t  p_74, int16_t  p_75, int64_t  p_76, float  p_77)
{ /* block id: 172 */
    float l_292 = 0x1.5p-1;
    float *l_291 = &l_292;
    struct S0 l_293 = {1UL,0x78DD2CD6L,0L,-0x1.Bp+1,0xE.131B42p+4,0x4E503AC011F5A421LL};
    struct S0 *l_294 = &l_293;
    (*l_291) = p_77;
    (*l_294) = l_293;
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_81(uint64_t  p_82, uint16_t  p_83)
{ /* block id: 43 */
    uint32_t l_106 = 0xC1D3A0C9L;
    int32_t *l_121 = (void*)0;
    int32_t **l_171 = &l_121;
    int32_t ***l_170 = &l_171;
    int32_t ****l_169 = &l_170;
    uint16_t l_180 = 0xE0C3L;
    struct S0 l_183 = {0xAD02808DL,0xF833B27FL,0x4C0B57B2L,0xE.917DE5p+62,0x0.4B3E7Ep-41,-1L};
    int32_t *l_216 = &l_183.f1;
    for (p_83 = (-9); (p_83 >= 53); p_83++)
    { /* block id: 46 */
        uint32_t l_103 = 18446744073709551615UL;
        int32_t l_109 = (-8L);
        int32_t *l_108 = &l_109;
        int32_t l_143 = (-10L);
        int32_t ***l_177 = &l_171;
        int32_t l_242 = 0x5FDFF747L;
        struct S0 *l_285 = &l_183;
    }
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_84(uint32_t  p_85, float  p_86, uint32_t  p_87, int32_t * p_88, int32_t * p_89)
{ /* block id: 40 */
    int32_t l_94 = 0xB3BD830BL;
    int32_t *l_93 = &l_94;
    int32_t **l_95 = &l_93;
    (*l_95) = l_93;
    return p_85;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 106
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 6
   depth: 4, occurrence: 3
   depth: 7, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 23, occurrence: 1
   depth: 28, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 107

XXX times a variable address is taken: 105
XXX times a pointer is dereferenced on RHS: 86
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 13
   depth: 3, occurrence: 7
XXX times a pointer is dereferenced on LHS: 63
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 6
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 317

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 169
   level: 2, occurrence: 44
   level: 3, occurrence: 22
   level: 4, occurrence: 13
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.4

XXX times a non-volatile is read: 573
XXX times a non-volatile is write: 168
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 56
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 15
   depth: 2, occurrence: 6
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 15.1
XXX percentage an existing variable is used: 84.9
********************* end of statistics **********************/

