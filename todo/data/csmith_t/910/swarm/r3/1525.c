/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      725247052
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 20;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint32_t  f0;
   const uint16_t  f1;
   struct S0  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_29(void);
inline static struct S0  func_33(float  p_34, int32_t  p_35, const int32_t  p_36, float  p_37, uint16_t  p_38);
static struct S0  func_40(struct S0  p_41, uint16_t  p_42, uint32_t  p_43, float  p_44);
static int32_t  func_57(struct S0  p_58);
static uint16_t  func_59(float  p_60, int32_t  p_61);
inline static uint32_t  func_62(int32_t  p_63, const int16_t  p_64, int16_t  p_65, uint32_t  p_66);
static int32_t  func_67(int32_t  p_68);
static int16_t  func_72(uint32_t  p_73, struct S1  p_74);
inline static uint16_t  func_77(int16_t  p_78, int32_t  p_79, struct S1  p_80);
static uint16_t  func_84(uint8_t  p_85, uint32_t  p_86, int32_t  p_87, int16_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(void)
{ /* block id: 36 */
    int32_t l_30 = 7L;
    int32_t l_706 = 0x368CA568L;
    int32_t l_707 = (-2L);
    int32_t l_708 = 0L;
    int32_t l_770 = 0xC915C015L;
    for (l_30 = 8; (l_30 <= 26); l_30++)
    { /* block id: 39 */
        int32_t l_39 = 0xF93BD5DEL;
        struct S0 l_45 = {-55};
        int32_t l_54 = 0xE91CB64BL;
        l_45 = func_33(l_39, (((func_40(l_45, l_30, __builtin_popcount(((int16_t)l_39 >> (int16_t)((l_708 = (((uint16_t)((l_707 = (l_706 = ((((int16_t)(l_54 = l_30) * (int16_t)__builtin_parityl(l_45.f0)) > (((uint16_t)l_45.f0 << (uint16_t)((func_57((func_59(l_45.f0, l_30) , l_45)) >= l_30) >= l_45.f0)) , 0L)) >= l_45.f0))) | l_30) - (uint16_t)l_30) ^ l_30)) | l_30))), l_39) , 65532UL) > l_30) ^ l_39), l_39, l_30, l_30);
    }
    l_707 = l_30;
    l_30 = (l_707 = ((float)((((float)l_30 / (float)((float)(((float)l_30 / (float)l_707) , l_708) - (float)l_30)) > (((float)(l_707 , l_708) - (float)(l_708 >= (((float)l_770 - (float)0xF.2A37C8p-20) == 0x1.D4A1ACp-77))) == l_770)) < l_708) + (float)0xC.18402Dp-1));
    return l_707;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_33(float  p_34, int32_t  p_35, const int32_t  p_36, float  p_37, uint16_t  p_38)
{ /* block id: 460 */
    struct S0 l_733 = {642};
    int32_t l_734 = 0x7B0D9FCEL;
    int32_t l_743 = 1L;
    uint32_t l_744 = 0x768CD98FL;
    struct S0 l_745 = {241};
    uint8_t l_748 = 255UL;
    uint32_t l_753 = 2UL;
    l_745 = func_40((l_733 = l_733), l_734, ((p_38 == (((int16_t)((0x24EAL < p_38) == p_38) >> (int16_t)4) <= 0xB6CB277DL)) , ((l_743 = (((uint16_t)((int32_t)(((((int16_t)0xB936L + (int16_t)(__builtin_ffsl(p_38) >= l_734)) > 0L) | 0UL) && l_734) % (int32_t)p_36) * (uint16_t)0UL) >= p_36)) , l_743)), l_744);
    l_745.f0 = ((l_743 = ((p_38 != l_745.f0) <= l_748)) != (((uint16_t)((uint16_t)l_753 - (uint16_t)((l_733.f0 = ((p_36 < ((uint16_t)((l_734 = l_748) , p_35) * (uint16_t)((uint32_t)p_38 + (uint32_t)0xD223F90EL))) > l_744)) > 0UL)) * (uint16_t)1UL) < l_744));
    return l_733;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_40(struct S0  p_41, uint16_t  p_42, uint32_t  p_43, float  p_44)
{ /* block id: 445 */
    float l_713 = 0x8.CA3148p-80;
    int32_t l_716 = 0x2FAB2E2FL;
    int32_t l_717 = 0L;
    int32_t l_718 = (-10L);
    struct S1 l_721 = {1UL,0x7741L,{832}};
    l_718 = ((1L < 65535UL) > (((uint32_t)p_42 - (uint32_t)p_42) > (p_41.f0 <= ((0x6835L != (l_717 = ((((uint32_t)(l_716 = p_41.f0) + (uint32_t)__builtin_ffs(p_43)) != 8L) | 0x9AF5L))) >= p_43))));
    l_717 = p_41.f0;
    for (l_718 = 12; (l_718 == 7); l_718 -= 1)
    { /* block id: 452 */
        int16_t l_728 = 0xF6AFL;
        int32_t l_731 = 0x4FFE3911L;
        uint8_t l_732 = 250UL;
        p_41.f0 = ((func_77(p_42, l_716, l_721) <= (((uint16_t)((p_41.f0 <= (-1L)) , l_716) << (uint16_t)15) ^ (((uint16_t)((uint16_t)((l_728 = p_41.f0) > ((uint16_t)(l_716 <= p_42) >> (uint16_t)10)) - (uint16_t)l_731) % (uint16_t)l_731) <= p_42))) , (-1L));
        if (l_732)
            break;
        p_41.f0 = 0x4EE6B65DL;
    }
    p_41 = l_721.f2;
    return l_721.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_57(struct S0  p_58)
{ /* block id: 379 */
    int32_t l_631 = 0L;
    int32_t l_632 = 0x6EB077D1L;
    int32_t l_640 = 0x32B8C5BEL;
    uint8_t l_641 = 0x4AL;
    int32_t l_642 = 0xC26C68A5L;
    int32_t l_656 = 0x834E8CF9L;
    struct S0 l_686 = {211};
    struct S1 l_692 = {0x3FD6788AL,0x86BCL,{194}};
    uint8_t l_704 = 0UL;
    l_632 = ((((int32_t)(!l_631) / (int32_t)4L) ^ (l_631 ^ l_631)) ^ p_58.f0);
    if ((p_58.f0 = (l_642 = (func_62((((int32_t)(p_58.f0 , l_631) + (int32_t)(-(int32_t)((int16_t)((uint32_t)l_631 + (uint32_t)func_62(p_58.f0, (l_632 = l_632), l_631, l_631)) / (int16_t)(l_640 = 0xDDAEL)))) && 0x5BC6F3C4L), l_631, l_631, l_641) == (-9L)))))
    { /* block id: 385 */
        int32_t l_648 = (-1L);
        int32_t l_649 = 0xA0B733C3L;
        int32_t l_682 = 0xED5490B7L;
        p_58.f0 = __builtin_ia32_crc32qi(((uint16_t)0x24D9L - (uint16_t)((int16_t)(!(l_648 = 0x100CL)) << (int16_t)5)), l_649);
        if (__builtin_popcountll(l_631))
        { /* block id: 388 */
            int32_t l_658 = (-7L);
            int32_t l_663 = 0xC0F2CF66L;
            int32_t l_664 = 0x4C0DCA46L;
            int32_t l_665 = 0x58E331A5L;
            l_640 = (l_656 = (l_665 = (p_58.f0 = ((uint16_t)(((uint16_t)p_58.f0 >> (uint16_t)p_58.f0) > l_648) << (uint16_t)((((l_664 = ((((float)(-0x1.Dp-1) * (float)((l_649 = (l_656 <= p_58.f0)) , (((-(float)l_658) != ((float)(((0x2F8239DCL ^ (l_649 = ((uint32_t)(l_632 = (p_58.f0 && l_658)) / (uint32_t)l_631))) != 7L) , (-0x1.4p-1)) * (float)l_663)) < p_58.f0))) , p_58.f0) , 0x9.1947EEp-6)) , p_58.f0) , l_663) <= l_663)))));
            return p_58.f0;
        }
        else
        { /* block id: 398 */
            const struct S0 l_666 = {-885};
            struct S0 l_667 = {-1002};
            struct S1 l_693 = {0UL,0x53CDL,{358}};
            l_667 = l_666;
            l_667.f0 = p_58.f0;
            for (l_649 = 0; (l_649 > 25); l_649++)
            { /* block id: 403 */
                uint16_t l_676 = 65528UL;
                struct S0 l_685 = {-700};
                uint8_t l_687 = 0x63L;
                for (l_656 = 15; (l_656 > 10); l_656 -= 7)
                { /* block id: 406 */
                    uint16_t l_683 = 8UL;
                    int32_t l_684 = 6L;
                    if (p_58.f0)
                    { /* block id: 407 */
                        return p_58.f0;
                    }
                    else
                    { /* block id: 409 */
                        struct S1 l_681 = {0UL,0xDC8DL,{810}};
                        l_684 = (p_58.f0 = ((int16_t)(p_58.f0 && (l_683 = (((int16_t)(l_676 = (4294967295UL & l_648)) << (int16_t)p_58.f0) | (((int16_t)(l_682 = ((uint16_t)func_77(l_667.f0, (l_640 != 5L), l_681) << (uint16_t)3)) * (int16_t)p_58.f0) == p_58.f0)))) - (int16_t)0xEFBDL));
                        l_685 = p_58;
                        l_686 = (l_681.f2 = p_58);
                        l_687 = l_648;
                    }
                }
                p_58.f0 = ((uint16_t)((int16_t)(l_648 , (p_58.f0 , func_77((l_692 , p_58.f0), l_667.f0, l_693))) << (int16_t)((~func_77((((int16_t)(l_686.f0 , p_58.f0) * (int16_t)p_58.f0) <= l_648), l_649, l_693)) > 3UL)) << (uint16_t)2);
            }
            p_58 = p_58;
        }
        return p_58.f0;
    }
    else
    { /* block id: 426 */
        uint16_t l_697 = 65535UL;
        int32_t l_699 = 0x10ACE207L;
        uint16_t l_705 = 0x4E4DL;
        p_58.f0 = __builtin_ctzll(p_58.f0);
        p_58 = l_686;
        if (l_697)
        { /* block id: 429 */
            uint32_t l_698 = 0x0857CFADL;
            l_698 = 0x9B65197EL;
            l_699 = l_697;
            p_58 = p_58;
        }
        else
        { /* block id: 433 */
            uint32_t l_702 = 0x9DB5482BL;
            int32_t l_703 = (-2L);
            p_58.f0 = ((l_703 = (p_58.f0 != ((int16_t)(l_702 = 0xDB3EL) << (int16_t)((l_697 < p_58.f0) <= p_58.f0)))) < (p_58.f0 == l_704));
        }
        l_705 = l_697;
    }
    l_686.f0 = l_686.f0;
    return l_631;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_59(float  p_60, int32_t  p_61)
{ /* block id: 41 */
    const uint16_t l_69 = 0UL;
    struct S1 l_89 = {0x9D52FFABL,65529UL,{-156}};
    int32_t l_93 = 0L;
    struct S1 l_94 = {4UL,0x59E8L,{-992}};
    int32_t l_97 = 0xB152D5F2L;
    int32_t l_98 = 3L;
    struct S1 l_100 = {0x0AFDD742L,0UL,{-970}};
    int32_t l_451 = 0xC31ED0AEL;
    struct S1 l_452 = {0xEFF14AEFL,65533UL,{70}};
    float l_468 = (-0x1.Dp+1);
    int32_t l_627 = 4L;
    l_627 = (1L > func_62(func_67((((((l_69 != (((p_61 = ((uint16_t)__builtin_parity(l_69) / (uint16_t)(l_452.f2.f0 = func_72((l_451 = (l_100.f2.f0 = ((__builtin_ctzl((((((((uint16_t)func_77(((l_69 || (-(uint16_t)((uint16_t)func_84((((l_89 , (l_98 = ((uint32_t)(((((((l_97 = (((l_93 = (-(int16_t)(l_89.f2.f0 = 0x9DAEL))) | (((l_94 , ((int16_t)(l_94.f2.f0 = l_89.f1) << (int16_t)l_94.f1)) == l_89.f1) || l_89.f0)) | p_61)) ^ 0xA01C9AC7L) == 6UL) != 65528UL) , l_94.f2.f0) > p_61) > l_89.f1) + (uint32_t)p_61))) ^ p_61) & p_61), p_61, p_61, p_61) << (uint16_t)12))) == l_69), p_61, l_100) << (uint16_t)l_94.f1) | 0xEACAF97BL) < p_61) && 0xFA5EL) | p_61) || p_61)) & 0x7D68L) ^ 0xAF50E186L))), l_452)))) > l_452.f0) || 0x6F14L)) | l_89.f0) ^ 0x3631D464L) || p_61) != l_100.f0)), l_452.f0, l_89.f0, l_89.f1));
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_62(int32_t  p_63, const int16_t  p_64, int16_t  p_65, uint32_t  p_66)
{ /* block id: 368 */
    uint16_t l_611 = 0UL;
    int32_t l_614 = (-1L);
    int16_t l_625 = 0xB611L;
    int32_t l_626 = (-2L);
    if (((((int16_t)(l_611 ^ (p_64 && ((int16_t)((l_614 = p_64) || (((uint16_t)((l_614 = 9UL) >= p_64) << (uint16_t)((int16_t)((int16_t)l_611 / (int16_t)((uint32_t)l_611 / (uint32_t)l_611)) + (int16_t)((uint32_t)l_625 + (uint32_t)p_64))) , l_625)) * (int16_t)l_626))) * (int16_t)p_64) , p_64) == 1L))
    { /* block id: 371 */
        l_614 = l_614;
    }
    else
    { /* block id: 373 */
        return p_64;
    }
    return l_614;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_67(int32_t  p_68)
{ /* block id: 251 */
    int16_t l_469 = 0L;
    int32_t l_470 = 0x005F1C4FL;
    int32_t l_473 = 0x6EC2A1C6L;
    uint32_t l_474 = 0x9B2589F4L;
    struct S1 l_496 = {1UL,65529UL,{-944}};
    uint32_t l_529 = 0UL;
    uint32_t l_560 = 0x6CE5E39EL;
    uint32_t l_608 = 0UL;
    l_470 = l_469;
    if ((l_470 && ((((l_469 < (p_68 | __builtin_bswap64(p_68))) , p_68) , (((int16_t)(l_470 | (l_473 = (l_469 && p_68))) * (int16_t)l_469) ^ p_68)) ^ p_68)))
    { /* block id: 254 */
        l_473 = 7L;
    }
    else
    { /* block id: 256 */
        struct S1 l_475 = {4294967295UL,0UL,{484}};
        struct S0 l_487 = {486};
        int32_t l_511 = 0x0DB7DEC1L;
        uint32_t l_534 = 0UL;
        l_473 = (p_68 > ((p_68 != func_72((p_68 , l_474), l_475)) < l_475.f0));
        for (l_475.f0 = 0; (l_475.f0 != 46); l_475.f0 += 1)
        { /* block id: 260 */
            int32_t l_478 = (-4L);
            int32_t l_485 = 0L;
            int32_t l_542 = 0x8A4E22AAL;
            struct S0 l_554 = {554};
            int32_t l_604 = (-1L);
            if (l_478)
            { /* block id: 261 */
                uint32_t l_486 = 1UL;
                if (((int16_t)(l_475.f2 , ((uint16_t)(((func_84(l_478, __builtin_parity(func_77(l_478, l_478, l_475)), (((4294967295UL < ((uint16_t)(l_485 = p_68) << (uint16_t)p_68)) & 0x626A049BL) , l_486), l_475.f0) >= p_68) && l_485) && l_486) * (uint16_t)p_68)) - (int16_t)p_68))
                { /* block id: 263 */
                    uint32_t l_497 = 0UL;
                    int32_t l_498 = 0x82EA51AAL;
                    l_487 = l_475.f2;
                    l_498 = ((-0x1.9p+1) < ((float)__builtin_popcountl(((4L < ((uint32_t)p_68 - (uint32_t)0L)) == ((uint32_t)((int32_t)(l_497 = (l_473 = (l_496 , p_68))) / (int32_t)p_68) - (uint32_t)l_486))) + (float)p_68));
                    if (l_486)
                        continue;
                }
                else
                { /* block id: 269 */
                    return l_487.f0;
                }
            }
            else
            { /* block id: 272 */
                struct S1 l_499 = {0x182B9280L,0UL,{-697}};
                int32_t l_517 = 0L;
                uint32_t l_530 = 0xDFB4D513L;
                struct S0 l_531 = {9};
                l_485 = func_84((((l_499.f2.f0 = (p_68 , (l_499 , ((uint16_t)((int16_t)(l_511 = ((uint16_t)l_473 << (uint16_t)((p_68 != (l_499.f2.f0 && (l_475.f2.f0 = ((l_475.f2 , ((uint16_t)(-(uint16_t)0x582FL) << (uint16_t)(6L ^ ((int16_t)(l_487.f0 = l_499.f2.f0) << (int16_t)12)))) <= 0xB469FE3BL)))) <= l_496.f0))) << (int16_t)1) - (uint16_t)p_68)))) && p_68) | 0L), p_68, p_68, l_474);
                l_496.f2 = l_499.f2;
                for (l_473 = (-25); (l_473 >= (-9)); l_473++)
                { /* block id: 281 */
                    int16_t l_518 = 0xE936L;
                    for (l_485 = 3; (l_485 >= 27); l_485 += 1)
                    { /* block id: 284 */
                        uint32_t l_516 = 0x961FFB1CL;
                        l_499.f2.f0 = (l_516 == 0x5E6EL);
                    }
                    if (l_517)
                        break;
                    l_496.f2 = (l_531 = ((func_77((l_518 ^ ((int16_t)1L + (int16_t)(((uint16_t)((int16_t)((((uint16_t)p_68 * (uint16_t)(((uint32_t)0x906F76AEL - (uint32_t)((l_529 == (p_68 , l_485)) > 1UL)) , 2UL)) && 0x46928EF8L) | 0xB096L) >> (int16_t)3) << (uint16_t)p_68) <= l_473))), l_530, l_499) , l_518) , l_496.f2));
                }
            }
            if (l_478)
            { /* block id: 292 */
                uint32_t l_537 = 0x782EF53FL;
                uint8_t l_543 = 0x53L;
                int32_t l_544 = 0x0568237DL;
                struct S0 l_561 = {-904};
                if (((p_68 && ((uint16_t)(l_534 >= ((((l_473 , p_68) < 0xC3C1324EL) , (__builtin_popcount((l_475.f1 <= (p_68 | ((int32_t)l_537 - (int32_t)((uint32_t)((uint32_t)l_542 + (uint32_t)l_537) / (uint32_t)l_474))))) && l_537)) >= p_68)) / (uint16_t)0xE0BAL)) && l_537))
                { /* block id: 293 */
                    l_544 = (l_543 = l_487.f0);
                    if ((p_68 > (l_543 < 0x05BFL)))
                    { /* block id: 296 */
                        return l_529;
                    }
                    else
                    { /* block id: 298 */
                        float l_559 = 0x1.23A54Dp+48;
                        if (p_68)
                            break;
                        l_496.f2.f0 = ((p_68 , ((float)(-0x4.3p+1) / (float)0x5.Dp-1)) > l_485);
                        l_560 = ((l_475.f2.f0 = (l_473 = ((int16_t)(((int16_t)((!0x496D7EABL) || ((uint16_t)((0x4699L | (l_469 < (l_511 = (l_554 , 0xAF41L)))) , 0xA25EL) >> (uint16_t)6)) << (int16_t)(((int32_t)(l_469 , (p_68 || ((uint16_t)l_537 - (uint16_t)0x61E1L))) - (int32_t)p_68) && p_68)) , p_68) * (int16_t)p_68))) < p_68);
                    }
                    l_561 = (l_529 , l_554);
                }
                else
                { /* block id: 307 */
                    struct S0 l_562 = {345};
                    l_562 = l_554;
                }
                l_554 = l_487;
                for (l_470 = (-9); (l_470 >= 25); l_470 += 1)
                { /* block id: 313 */
                    uint32_t l_570 = 18446744073709551615UL;
                    struct S0 l_571 = {336};
                    for (l_534 = 19; (l_534 == 14); l_534 -= 4)
                    { /* block id: 316 */
                        l_475.f2.f0 = ((p_68 | (p_68 , __builtin_parity(((uint32_t)(!l_478) + (uint32_t)(l_570 || p_68))))) , (-9L));
                        l_571 = l_571;
                    }
                }
            }
            else
            { /* block id: 321 */
                uint32_t l_574 = 0x622D0028L;
                for (l_534 = (-12); (l_534 <= 23); l_534 += 5)
                { /* block id: 324 */
                    uint16_t l_575 = 0x0550L;
                    l_478 = (l_575 = l_574);
                }
                l_470 = p_68;
                if (l_554.f0)
                    break;
            }
            l_485 = ((int16_t)p_68 * (int16_t)p_68);
            for (l_474 = 0; (l_474 != 46); l_474++)
            { /* block id: 334 */
                uint16_t l_580 = 0xFCE6L;
                int32_t l_597 = (-1L);
                struct S1 l_603 = {0xD9B6EDE9L,65535UL,{100}};
                if ((l_580 < l_580))
                { /* block id: 335 */
                    const uint32_t l_589 = 0xB2DE0D5EL;
                    uint32_t l_596 = 0x9B21BCFBL;
                    int32_t l_602 = 0xBB030C00L;
                    for (l_560 = (-28); (l_560 >= 54); l_560 += 4)
                    { /* block id: 338 */
                        l_554 = l_487;
                        l_487.f0 = (((uint16_t)1UL * (uint16_t)func_77(l_542, ((((uint16_t)((uint16_t)l_589 * (uint16_t)(((uint16_t)((int32_t)l_589 % (int32_t)(0UL | (l_597 = __builtin_parityll((l_485 = (0x6E736422L && ((((((uint16_t)l_475.f0 / (uint16_t)(l_596 = 0xB8F5L)) == (p_68 ^ 3L)) == l_589) , 0x63EBL) >= p_68))))))) * (uint16_t)l_542) | l_580)) * (uint16_t)0x0CAFL) >= 7L) || l_475.f0), l_496)) || p_68);
                    }
                    l_597 = p_68;
                    l_597 = (((int32_t)((l_604 = ((((uint16_t)0x0663L << (uint16_t)(l_475.f2.f0 = (l_602 = (-1L)))) >= ((func_77(__builtin_popcount(p_68), p_68, l_603) < __builtin_parity(p_68)) , l_485)) || p_68)) | 0x9E87FC26L) + (int32_t)p_68) & l_603.f0);
                    if (p_68)
                        continue;
                }
                else
                { /* block id: 351 */
                    for (l_529 = 0; (l_529 < 48); l_529 += 1)
                    { /* block id: 354 */
                        uint16_t l_607 = 65535UL;
                        if (p_68)
                            break;
                        l_607 = (-0x8.2p-1);
                    }
                    l_604 = (l_604 , 3L);
                }
                return l_608;
            }
        }
        l_496.f2 = (l_475.f2 = l_487);
    }
    l_496.f2.f0 = 0x2.70777Ap+85;
    return l_560;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_72(uint32_t  p_73, struct S1  p_74)
{ /* block id: 245 */
    uint16_t l_453 = 65534UL;
    int32_t l_466 = 0xE85FD5CDL;
    int16_t l_467 = 5L;
    p_74.f2.f0 = (__builtin_ctz(__builtin_ctzl(__builtin_ctz(l_453))) ^ (((int16_t)((((p_74 , (((uint16_t)p_74.f1 >> (uint16_t)13) > ((uint16_t)0UL - (uint16_t)((int32_t)__builtin_parity((((uint16_t)(((int16_t)(p_74.f0 , (l_466 = p_74.f2.f0)) - (int16_t)p_73) <= p_74.f1) + (uint16_t)4UL) | p_74.f0)) / (int32_t)4294967295UL)))) , p_74.f0) | l_467) == 2UL) / (int16_t)1UL) == (-1L)));
    return l_467;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_77(int16_t  p_78, int32_t  p_79, struct S1  p_80)
{ /* block id: 50 */
    uint8_t l_102 = 0xE7L;
    int32_t l_103 = 0xFDF2DC13L;
    int32_t l_106 = 0x33ED7856L;
    struct S0 l_107 = {-995};
    float l_163 = 0x1.2p-1;
    uint8_t l_192 = 253UL;
    uint8_t l_239 = 249UL;
    int32_t l_250 = 0xC790DA67L;
    int32_t l_255 = 0x169658B3L;
    uint32_t l_336 = 1UL;
    if ((((p_80 , p_78) ^ ((l_102 = (-(int16_t)0x5A8DL)) ^ l_103)) || (l_102 < __builtin_clzl((((float)(-0x1.8p+1) + (float)(p_80.f1 <= __builtin_parityll(l_106))) , l_103)))))
    { /* block id: 52 */
        int32_t l_146 = 0x2C06D41FL;
        int32_t l_170 = 1L;
        int32_t l_171 = (-1L);
        uint32_t l_197 = 4294967295UL;
        int32_t l_209 = 0L;
        int32_t l_251 = 6L;
        l_107 = p_80.f2;
        for (p_79 = (-24); (p_79 <= (-29)); p_79 -= 1)
        { /* block id: 56 */
            uint32_t l_112 = 0x80B3E519L;
            const struct S0 l_115 = {362};
            int16_t l_133 = (-10L);
            int32_t l_137 = 1L;
            int32_t l_138 = (-10L);
            struct S1 l_152 = {1UL,0xF590L,{676}};
            if ((1UL > l_106))
            { /* block id: 57 */
                p_80.f2 = p_80.f2;
                for (l_103 = (-23); (l_103 != (-23)); l_103 += 6)
                { /* block id: 61 */
                    l_112 = p_80.f0;
                }
            }
            else
            { /* block id: 64 */
                struct S0 l_116 = {-385};
                for (l_102 = 0; (l_102 > 12); l_102 += 2)
                { /* block id: 67 */
                    float l_132 = 0xD.5926F2p-70;
                    int32_t l_136 = 8L;
                    p_80.f2 = l_115;
                    if (p_80.f1)
                        break;
                    l_107 = l_116;
                    if ((l_138 = ((l_107.f0 = p_80.f2.f0) , ((int32_t)l_102 - (int32_t)((((int16_t)p_78 >> (int16_t)(((l_137 = (((int32_t)((uint16_t)((uint16_t)65533UL >> (uint16_t)((uint16_t)((-(uint32_t)((((int16_t)l_112 * (int16_t)((l_103 = l_133) >= 0xA6105BDFL)) | l_133) && (((uint16_t)__builtin_ffsl(p_79) * (uint16_t)p_80.f2.f0) != p_80.f0))) & p_80.f2.f0) >> (uint16_t)l_116.f0)) * (uint16_t)l_136) - (int32_t)0xCDBDB142L) != l_102)) == p_80.f2.f0) != l_116.f0)) == 0x64CBL) >= l_116.f0)))))
                    { /* block id: 75 */
                        uint8_t l_150 = 0x8EL;
                        struct S0 l_151 = {-943};
                        l_151 = (((l_102 <= ((p_78 >= ((float)(p_80.f1 > ((float)((p_78 <= ((float)((-(float)l_146) > (-(float)((float)func_84(l_106, l_136, p_80.f2.f0, ((p_80 , p_80.f0) | 65535UL)) - (float)l_136))) - (float)p_79)) < p_80.f2.f0) + (float)p_80.f1)) * (float)p_80.f0)) < p_78)) >= l_150) , p_80.f2);
                        l_116 = (((l_136 = l_136) , l_152) , (p_80.f2 = p_80.f2));
                        l_138 = ((float)((__builtin_ctzll(l_107.f0) >= 0x7.7FB2C3p-7) > ((float)((((!((float)func_84((((l_171 = (p_80.f2.f0 = (l_103 = ((~((int32_t)(l_106 , 0xD72531C4L) + (int32_t)((((int32_t)l_116.f0 - (int32_t)l_103) || (l_146 = l_146)) <= (l_151.f0 = ((uint16_t)__builtin_clzl(((uint16_t)0UL / (uint16_t)l_136)) + (uint16_t)l_116.f0))))) < l_170)))) <= p_80.f1) == p_80.f1), l_102, l_150, p_80.f0) - (float)l_116.f0)) > l_106) >= 0x1.EE271Dp-15) == 0x0.7p+1) - (float)0x9.088253p-78)) - (float)l_170);
                        l_137 = 8L;
                    }
                    else
                    { /* block id: 87 */
                        return p_78;
                    }
                }
                return l_146;
            }
        }
        if ((l_170 != ((int16_t)(l_107.f0 = (p_80.f2 , p_80.f2.f0)) >> (int16_t)0)))
        { /* block id: 95 */
            int32_t l_193 = 0L;
            uint32_t l_194 = 0x47A7A277L;
            int32_t l_198 = 0x54C286E7L;
            int32_t l_199 = 0L;
            int32_t l_200 = 8L;
            l_200 = ((((float)(l_171 = (__builtin_bswap64(p_80.f1) , (l_199 = __builtin_ffsl(((((l_198 = (((uint16_t)((int16_t)(l_146 = ((((uint32_t)(!(((!p_80.f0) > (p_78 = l_146)) < ((uint16_t)(func_84(((((int16_t)((int16_t)(((p_79 && l_146) ^ ((uint16_t)((l_193 = (l_107.f0 = (p_80.f2.f0 = l_192))) || (l_194 = l_106)) * (uint16_t)(l_103 = (((uint16_t)(l_106 , p_80.f1) + (uint16_t)l_171) | p_79)))) ^ l_197) << (int16_t)2) * (int16_t)p_80.f1) != p_79) != 1UL), l_197, p_80.f1, p_80.f1) < p_79) >> (uint16_t)p_79))) + (uint32_t)3UL) < l_102) , l_197)) / (int16_t)0x75A0L) >> (uint16_t)p_79) , 1L)) == l_102) <= l_199) & 0xD746L))))) * (float)p_79) == l_200) > (-0x1.Ep-1));
            l_103 = (((int16_t)(((p_80.f0 < (__builtin_clz((l_102 , (l_200 , ((int32_t)(((__builtin_clz((((uint32_t)0x536AC008L / (uint32_t)(((uint16_t)(__builtin_parity(p_79) ^ p_79) * (uint16_t)((l_102 , l_197) , 0x97DDL)) ^ p_80.f0)) >= p_79)) , 0x555FL) != p_80.f1) < (-1L)) / (int32_t)p_78)))) | l_171)) != (-10L)) <= l_209) * (int16_t)0x25C5L) , l_102);
            l_107 = l_107;
        }
        else
        { /* block id: 109 */
            int16_t l_210 = 0x7C52L;
            int32_t l_225 = (-1L);
            int32_t l_226 = 0xF0B04548L;
            uint32_t l_242 = 1UL;
            if (l_210)
            { /* block id: 110 */
                float l_227 = 0x1.3p-1;
                int32_t l_228 = 0xCD35E6B1L;
                int32_t l_229 = (-6L);
                uint32_t l_230 = 18446744073709551615UL;
                for (l_103 = 0; (l_103 <= 16); l_103++)
                { /* block id: 113 */
                    return l_209;
                }
                l_230 = (((float)((p_78 , ((0x0.6p-1 <= l_106) == ((l_171 = (l_228 = ((float)l_146 * (float)(l_107.f0 = (((float)func_84(((uint32_t)((uint16_t)((uint16_t)l_225 % (uint16_t)(p_80.f0 || l_225)) >> (uint16_t)((l_226 = l_197) ^ (p_79 && p_80.f1))) % (uint32_t)0xA3CFAA44L), p_80.f0, p_80.f1, p_79) / (float)l_210) != p_79))))) < l_229))) == l_103) * (float)0x4.4EA24Dp-38) <= p_80.f1);
            }
            else
            { /* block id: 121 */
                const float l_241 = 0x3.F88FC3p+67;
                int32_t l_243 = 0xA5C5DEAEL;
                l_103 = l_102;
                p_80.f2.f0 = (func_84(__builtin_parityll(((l_226 = ((int32_t)((func_84(p_79, ((int16_t)(((p_78 != 0x7BBFL) | (p_80.f0 = (((int16_t)(func_84(((uint16_t)l_192 - (uint16_t)p_78), (l_226 == l_239), (!l_102), l_210) , 1L) << (int16_t)l_239) || p_79))) < l_226) % (int16_t)p_80.f1), l_239, l_103) || p_80.f2.f0) != (-4L)) - (int32_t)l_242)) != l_210)), p_79, l_242, l_243) , p_79);
                for (l_146 = 0; (l_146 < 19); l_146 += 1)
                { /* block id: 128 */
                    return l_170;
                }
            }
            p_80.f2 = l_107;
        }
        l_255 = func_84(l_146, (l_146 | (((l_107.f0 = ((l_251 = ((uint32_t)((uint16_t)l_250 * (uint16_t)(l_107.f0 > p_80.f2.f0)) / (uint32_t)(l_171 = 0x353F1D64L))) || (-(int32_t)((uint16_t)(l_107 , (p_80.f0 , 0x0952L)) << (uint16_t)14)))) , 0x046C6167L) != p_79)), l_146, l_255);
    }
    else
    { /* block id: 138 */
        int32_t l_273 = 9L;
        int32_t l_275 = (-1L);
        struct S0 l_301 = {-946};
        for (l_102 = 0; (l_102 >= 22); l_102++)
        { /* block id: 141 */
            uint32_t l_272 = 4294967295UL;
            int32_t l_274 = (-4L);
            if (((uint16_t)((uint16_t)(p_80.f0 < ((uint32_t)(((l_102 <= (((l_107.f0 = ((uint32_t)((int32_t)((l_255 = ((0xDB04L == p_78) , l_107.f0)) >= (l_274 = (l_273 = ((uint16_t)((l_103 > ((uint32_t)((-8L) | l_106) / (uint32_t)(l_272 , p_79))) && l_273) + (uint16_t)l_106)))) - (int32_t)l_272) + (uint32_t)l_275)) & l_275) | 0xD823547AL)) , l_275) | p_80.f1) + (uint32_t)0xA89D31CDL)) / (uint16_t)0x0F6FL) << (uint16_t)l_275))
            { /* block id: 146 */
                float l_278 = (-0x1.5p+1);
                int32_t l_279 = 0x3B60F176L;
                for (l_272 = 0; (l_272 >= 55); l_272 += 1)
                { /* block id: 149 */
                    l_275 = (l_278 > l_272);
                    return l_279;
                }
            }
            else
            { /* block id: 153 */
                float l_287 = 0xA.EBE92Dp+46;
                const int32_t l_288 = 1L;
                l_273 = ((((-(uint16_t)((((int16_t)((p_78 = ((p_78 | ((uint16_t)((uint32_t)l_192 + (uint32_t)(p_80.f2.f0 , l_288)) * (uint16_t)(-(uint16_t)65528UL))) > ((uint16_t)((!(((uint16_t)((int32_t)(l_288 <= ((int32_t)((uint16_t)(__builtin_ctz(p_80.f1) , l_255) % (uint16_t)l_272) / (int32_t)l_273)) - (int32_t)p_78) << (uint16_t)7) != l_272)) >= 0x3A96L) >> (uint16_t)p_78))) & p_80.f0) * (int16_t)l_275) | l_103) || 0x04C1L)) , l_301) , p_80.f2) , l_288);
                p_80.f2 = (p_78 , p_80.f2);
            }
            for (l_103 = 3; (l_103 > (-12)); l_103 -= 7)
            { /* block id: 160 */
                p_80.f2.f0 = l_107.f0;
            }
        }
        if (l_275)
        { /* block id: 164 */
            return p_79;
        }
        else
        { /* block id: 166 */
            uint32_t l_304 = 5UL;
            int32_t l_309 = 0L;
            uint8_t l_324 = 0xF5L;
            int32_t l_344 = (-8L);
            l_273 = l_304;
            l_255 = p_79;
            if (p_80.f1)
            { /* block id: 169 */
                p_80.f2.f0 = ((l_255 && ((int16_t)__builtin_ctzl(l_304) << (int16_t)l_275)) | ((uint16_t)0x0782L >> (uint16_t)9));
                l_309 = l_304;
            }
            else
            { /* block id: 172 */
                uint8_t l_325 = 0x06L;
                int32_t l_342 = (-6L);
                int32_t l_369 = 0xEDD34A8CL;
                int32_t l_370 = 0x9AF0FEC2L;
                int16_t l_427 = 0x393EL;
                l_103 = p_78;
                if (((int16_t)((uint16_t)8UL - (uint16_t)(l_275 == p_80.f1)) * (int16_t)((int16_t)((uint16_t)__builtin_parityll((((int16_t)p_80.f1 + (int16_t)1UL) , (p_80.f2 , (p_80 , (l_250 <= ((uint16_t)(((uint16_t)(((l_102 , p_80.f2.f0) < p_80.f1) || p_80.f1) << (uint16_t)10) || l_309) * (uint16_t)65535UL)))))) - (uint16_t)l_324) >> (int16_t)13)))
                { /* block id: 174 */
                    int32_t l_326 = 0L;
                    struct S0 l_343 = {-323};
                    float l_412 = 0x8.0480A9p-0;
                    int16_t l_418 = 0x352BL;
                    if ((l_326 = (p_80.f2.f0 && l_325)))
                    { /* block id: 176 */
                        uint16_t l_331 = 65535UL;
                        l_326 = ((uint16_t)((p_80.f2.f0 ^ ((p_80.f0 >= ((int16_t)0xCB01L - (int16_t)l_331)) | p_80.f0)) <= (l_103 = p_80.f1)) << (uint16_t)((int16_t)((int32_t)(l_336 == func_84((((uint16_t)(-(uint16_t)(((l_342 = (((int16_t)(-4L) - (int16_t)5L) | (-9L))) ^ p_78) || 0xC839L)) >> (uint16_t)p_79) < l_325), l_192, l_326, l_309)) / (int32_t)l_325) * (int16_t)l_326));
                        l_301.f0 = l_325;
                        return p_79;
                    }
                    else
                    { /* block id: 182 */
                        uint32_t l_368 = 4294967291UL;
                        l_343 = l_301;
                        l_343.f0 = func_84(l_344, (p_80 , ((uint32_t)((l_342 = 0xC234BBA6L) ^ (p_80.f0 || (l_301 , ((((uint16_t)(l_107.f0 = ((uint16_t)func_84(p_78, (p_80.f0 = (l_301.f0 = (l_309 = (l_325 , (p_80 , l_325))))), l_325, p_80.f2.f0) - (uint16_t)p_80.f1)) % (uint16_t)(-1L)) != l_344) , p_80.f2.f0)))) / (uint32_t)l_325)), p_79, p_78);
                        l_326 = 0xF79306F4L;
                        l_370 = (p_80.f0 <= ((l_369 = ((float)((float)(0xF.E57CC7p-62 <= p_79) / (float)(((float)(((float)((p_78 | ((uint16_t)0UL << (uint16_t)(l_255 = (-(uint32_t)l_343.f0)))) , ((((l_342 = (p_80.f2.f0 != ((l_273 != func_84(((int16_t)((int16_t)7L * (int16_t)l_304) + (int16_t)1L), p_80.f2.f0, l_342, l_273)) < l_102))) == p_80.f2.f0) == p_80.f2.f0) <= p_78)) - (float)0x1.Ep+1) < l_368) + (float)0xC.15DCBFp-69) == p_80.f1)) / (float)p_80.f2.f0)) > p_80.f0));
                    }
                    l_344 = (l_107.f0 = (l_301.f0 = ((float)(l_255 = (l_370 <= ((float)((float)l_343.f0 - (float)((float)(p_80 , (l_369 != (l_309 = (((float)0xB.ACF49Dp+98 / (float)(l_275 = 0x1.7p+1)) < ((l_370 != l_369) , 0x1.797822p+69))))) + (float)0x7.F21BAEp+29)) + (float)p_80.f1))) * (float)p_78)));
                    l_273 = (p_80.f2.f0 = (l_343.f0 != ((int16_t)(l_342 = (((p_79 > ((l_309 = 0x75F9L) & ((uint32_t)((int16_t)(!l_326) / (int16_t)p_80.f1) / (uint32_t)((((p_80.f1 & ((p_78 = ((l_301.f0 ^ ((uint32_t)(l_103 = p_79) - (uint32_t)p_80.f1)) < p_80.f0)) != l_369)) <= 0xAA3F01E3L) , p_80.f2) , p_79)))) , p_80) , 0xAAF6L)) >> (int16_t)l_301.f0)));
                    if ((l_273 , (p_80.f0 <= (-(int32_t)((uint16_t)(((~((int16_t)p_79 - (int16_t)p_80.f0)) > (l_309 = (((uint16_t)func_84((l_343.f0 = ((uint16_t)p_80.f0 >> (uint16_t)4)), p_80.f0, ((int16_t)(p_78 = 0x4CA9L) * (int16_t)__builtin_ffsll(l_106)), p_80.f2.f0) << (uint16_t)8) , 0x637EL))) , 0xCF19L) << (uint16_t)15)))))
                    { /* block id: 211 */
                        uint16_t l_428 = 9UL;
                        l_370 = __builtin_bswap32((l_343.f0 = 0x9E99FDD9L));
                        p_80.f2.f0 = ((int32_t)((((l_428 = ((int16_t)(((uint32_t)(((int16_t)l_106 * (int16_t)(l_326 , (l_326 = (((((int16_t)(-(int32_t)(((l_370 = (((int16_t)__builtin_ctzll(l_418) + (int16_t)((int16_t)p_80.f2.f0 / (int16_t)__builtin_parity(((int16_t)((((int16_t)p_80.f0 << (int16_t)0) , ((((int16_t)l_342 >> (int16_t)9) == 0xCC45B127L) , p_80.f2)) , l_344) / (int16_t)65535UL)))) >= p_80.f1)) && p_80.f1) || p_80.f0)) / (int16_t)l_427) >= l_103) != 0xB985E9CEL) | 9L)))) != 0x8D32L) + (uint32_t)0L) >= l_273) - (int16_t)p_79)) >= l_336) > l_273) , p_78) + (int32_t)0x3EB5A4A2L);
                    }
                    else
                    { /* block id: 218 */
                        struct S0 l_437 = {153};
                        p_80.f2.f0 = (l_275 , __builtin_clzll(((l_106 & ((l_103 = l_273) && (func_84(l_107.f0, ((l_304 , (l_102 && ((uint16_t)0UL >> (uint16_t)5))) || p_78), ((uint16_t)(((int16_t)((l_437 , p_80.f2.f0) ^ p_80.f1) % (int16_t)l_418) ^ p_80.f1) / (uint16_t)0x0E8FL), p_80.f1) < p_78))) , p_78)));
                        l_301.f0 = (((int32_t)(0x92C4L >= (p_80.f2.f0 <= l_325)) / (int32_t)0x02E37A11L) , (l_275 ^ ((int16_t)(p_78 = p_80.f1) * (int16_t)l_324)));
                        p_80.f2.f0 = 6L;
                        l_309 = ((l_103 = ((l_275 = (p_80.f0 = (l_437.f0 == p_78))) && (l_344 = ((uint16_t)((((p_80.f0 = ((uint32_t)func_84(p_78, (p_80 , 4294967287UL), ((uint16_t)l_301.f0 << (uint16_t)(((l_369 = l_437.f0) && 0x32DAAF69L) > (((l_342 = func_84(p_80.f0, p_79, l_309, p_80.f2.f0)) >= p_80.f0) > l_304))), p_80.f2.f0) - (uint32_t)p_80.f1)) <= l_325) || l_343.f0) < p_79) << (uint16_t)p_80.f2.f0)))) & p_80.f2.f0);
                    }
                }
                else
                { /* block id: 233 */
                    return l_103;
                }
            }
            l_275 = ((uint16_t)(p_80.f2.f0 == p_80.f0) >> (uint16_t)l_107.f0);
        }
        l_107.f0 = ((-(float)0x5.6A7733p-64) , (l_255 = p_78));
    }
    return l_107.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_84(uint8_t  p_85, uint32_t  p_86, int32_t  p_87, int16_t  p_88)
{ /* block id: 47 */
    struct S0 l_99 = {117};
    l_99 = l_99;
    return l_99.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 158
   depth: 1, occurrence: 21
   depth: 2, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 34
breakdown:
   indirect level: 0, occurrence: 34
XXX full-bitfields structs in the program: 21
breakdown:
   indirect level: 0, occurrence: 21
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 34
XXX times a bitfields struct on RHS: 70
XXX times a single bitfield on LHS: 54
XXX times a single bitfield on RHS: 102

XXX max expression depth: 62
breakdown:
   depth: 1, occurrence: 190
   depth: 2, occurrence: 35
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 5
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 5
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 3
   depth: 32, occurrence: 1
   depth: 35, occurrence: 1
   depth: 46, occurrence: 1
   depth: 62, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 777
XXX times a non-volatile is write: 264
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 180
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 24
   depth: 2, occurrence: 27
   depth: 3, occurrence: 31
   depth: 4, occurrence: 34
   depth: 5, occurrence: 34

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

