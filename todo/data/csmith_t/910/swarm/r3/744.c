/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3770639658
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int8_t  f0;
   const uint16_t  f1;
   signed f2 : 30;
   const int16_t  f3;
   volatile uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static int64_t g_3 = 0x8A59C17633EFC07ELL;
static int32_t g_44 = 0L;
static const volatile union U0 g_81 = {-1L};/* VOLATILE GLOBAL g_81 */
static volatile union U0 g_82 = {0xDBL};/* VOLATILE GLOBAL g_82 */
static int32_t g_90 = 1L;
static int32_t * volatile g_89 = &g_90;/* VOLATILE GLOBAL g_89 */
static int32_t g_94 = 0xB2D29C61L;
static int32_t *g_96 = &g_44;
static int32_t ** volatile g_95 = &g_96;/* VOLATILE GLOBAL g_95 */
static int32_t ** volatile g_111 = &g_96;/* VOLATILE GLOBAL g_111 */
static volatile union U0 g_115 = {0L};/* VOLATILE GLOBAL g_115 */
static int8_t g_129 = 0x01L;
static union U0 g_150 = {0x84L};/* VOLATILE GLOBAL g_150 */
static int32_t * volatile g_151 = (void*)0;/* VOLATILE GLOBAL g_151 */
static volatile union U0 g_168 = {0L};/* VOLATILE GLOBAL g_168 */
static volatile union U0 *g_175 = (void*)0;
static volatile union U0 ** volatile g_174 = &g_175;/* VOLATILE GLOBAL g_174 */
static int32_t ** volatile g_183 = &g_96;/* VOLATILE GLOBAL g_183 */
static uint32_t g_194 = 0x211FA3A4L;
static int32_t ** volatile g_198 = &g_96;/* VOLATILE GLOBAL g_198 */
static int32_t * volatile g_227 = (void*)0;/* VOLATILE GLOBAL g_227 */
static int32_t * volatile g_228 = &g_44;/* VOLATILE GLOBAL g_228 */
static int32_t * volatile g_289 = &g_44;/* VOLATILE GLOBAL g_289 */
static int32_t **g_296 = &g_96;
static int32_t *** volatile g_295 = &g_296;/* VOLATILE GLOBAL g_295 */
static int32_t ** volatile g_300 = (void*)0;/* VOLATILE GLOBAL g_300 */
static int32_t ** volatile g_301 = &g_96;/* VOLATILE GLOBAL g_301 */
static volatile union U0 **g_313 = &g_175;
static volatile union U0 *** volatile g_312 = &g_313;/* VOLATILE GLOBAL g_312 */
static int32_t * volatile g_320 = &g_90;/* VOLATILE GLOBAL g_320 */
static int32_t * volatile g_334 = &g_90;/* VOLATILE GLOBAL g_334 */
static int32_t *** volatile g_336 = &g_296;/* VOLATILE GLOBAL g_336 */
static int32_t g_349 = (-8L);
static int32_t *g_348 = &g_349;
static volatile union U0 g_354 = {0L};/* VOLATILE GLOBAL g_354 */
static int32_t ***g_362 = &g_296;
static int32_t **** volatile g_361 = &g_362;/* VOLATILE GLOBAL g_361 */
static volatile union U0 g_369 = {0xCAL};/* VOLATILE GLOBAL g_369 */
static union U0 *g_414 = &g_150;
static union U0 **g_413 = &g_414;
static union U0 *** volatile g_412 = &g_413;/* VOLATILE GLOBAL g_412 */
static union U0 g_438 = {0xE3L};/* VOLATILE GLOBAL g_438 */
static volatile union U0 g_455 = {3L};/* VOLATILE GLOBAL g_455 */
static int32_t g_471 = 2L;
static uint64_t g_496 = 18446744073709551606UL;
static int32_t g_510 = (-4L);
static int16_t g_511 = 0L;
static volatile uint32_t g_519 = 0UL;/* VOLATILE GLOBAL g_519 */
static volatile union U0 g_522 = {0L};/* VOLATILE GLOBAL g_522 */
static int32_t ** volatile g_561 = (void*)0;/* VOLATILE GLOBAL g_561 */
static int32_t ** volatile g_562 = &g_96;/* VOLATILE GLOBAL g_562 */
static union U0 g_566 = {0x00L};/* VOLATILE GLOBAL g_566 */
static int32_t ** volatile g_582 = &g_96;/* VOLATILE GLOBAL g_582 */
static uint64_t g_598 = 0xD65B9FE362A4A30ALL;
static volatile union U0 *** volatile *g_604 = &g_312;
static volatile union U0 *** volatile ** volatile g_603 = &g_604;/* VOLATILE GLOBAL g_603 */
static const union U0 *g_669 = &g_566;
static const union U0 **g_668 = &g_669;
static const union U0 *** volatile g_667 = &g_668;/* VOLATILE GLOBAL g_667 */


/* --- FORWARD DECLARATIONS --- */
static const int8_t  func_23(void);
static int32_t * func_24(uint32_t  p_25, int32_t * p_26, int32_t * p_27, int32_t * p_28);
static uint16_t  func_34(int16_t  p_35);
static int64_t  func_40(uint32_t  p_41, uint32_t  p_42);
static int32_t * func_45(int32_t * p_46, int32_t * p_47, int32_t * p_48, int32_t * p_49, uint64_t  p_50);
static int32_t * func_52(int32_t  p_53, int32_t * p_54, int32_t * p_55, uint16_t  p_56);
static int32_t * func_57(int32_t  p_58, int32_t * p_59, uint64_t  p_60);
static int16_t  func_64(int32_t * p_65, uint32_t  p_66);
static int32_t * func_67(int32_t * p_68, const int32_t  p_69);
static int32_t * func_70(int16_t  p_71, int32_t * p_72, int32_t * p_73, int32_t * p_74, int32_t * p_75);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_44 g_81 g_82 g_89 g_90 g_94 g_95 g_96 g_111 g_115 g_81.f0 g_82.f0 g_168 g_174 g_183 g_194 g_115.f0 g_129 g_198 g_150.f0 g_228 g_289 g_295 g_301 g_312 g_320 g_334 g_336 g_348 g_349 g_354 g_361 g_369 g_354.f0 g_362 g_168.f0 g_412 g_413 g_438.f0 g_455 g_313 g_175 g_496 g_519 g_510 g_369.f0 g_522 g_471
 * writes: g_44 g_90 g_94 g_96 g_129 g_175 g_296 g_313 g_349 g_362 g_348 g_413 g_510
 */
static const int8_t  func_23(void)
{ /* block id: 36 */
    uint64_t l_29 = 18446744073709551609UL;
    int32_t *l_43 = &g_44;
    int32_t *l_51 = &g_44;
    uint32_t l_61 = 0xC8C5CECCL;
    int16_t l_458 = (-8L);
    int32_t *l_470 = &g_471;
    union U0 **l_521 = (void*)0;
    uint16_t l_540 = 0x8CD0L;
    union U0 ***l_556 = &g_413;
    union U0 ****l_555 = &l_556;
    uint32_t l_572 = 0x3941A4D1L;
    uint32_t l_630 = 1UL;
    int32_t l_650 = 0x71103776L;
    l_43 = func_24((l_29 >= ((int16_t)g_3 % (int16_t)((uint16_t)func_34((l_29 | ((uint16_t)((uint64_t)((func_40((((l_43 == l_43) , func_45(l_51, func_52(g_3, func_57((((((void*)0 != &g_44) , (*l_43)) > (-3L)) >= l_61), l_43, g_3), l_51, g_150.f0), g_348, &g_349, l_29)) != l_43), g_438.f0) || (*l_43)) <= 4294967292UL) % (uint64_t)l_458) << (uint16_t)g_150.f0))) / (uint16_t)g_150.f0))), l_470, l_51, &g_471);
    if ((*l_51))
    { /* block id: 243 */
        uint32_t l_475 = 0x9B65AE4BL;
        int32_t *l_476 = &g_94;
        int32_t **l_484 = &l_470;
        uint32_t l_506 = 2UL;
        (*l_484) = (g_168.f0 , l_476);
        if ((*g_320))
        { /* block id: 245 */
            int32_t l_485 = 0x52A3EAAFL;
            union U0 ***l_487 = (void*)0;
            union U0 ****l_486 = &l_487;
            (*l_486) = (l_485 , (void*)0);
            (*l_470) = ((int32_t)(((((((uint32_t)(((int64_t)(((int16_t)g_496 << (int16_t)11) ^ ((uint16_t)(&g_312 == &l_487) % (uint16_t)((uint64_t)((int16_t)(-(uint64_t)0xBC05A1244F5741F6LL) << (int16_t)((((l_485 < ((g_194 < (**l_484)) <= func_34(((void*)0 == &g_412)))) , 4294967295UL) <= g_129) || g_354.f0)) - (uint64_t)g_194))) / (int64_t)0xABEB17A40FEAA9D3LL) || l_485) / (uint32_t)(*l_476)) != 1L) != (*l_476)) , l_485) | (-2L)) | g_129) - (int32_t)l_506);
            (*l_476) = l_485;
        }
        else
        { /* block id: 249 */
            int32_t *l_507 = &g_90;
lbl_520:
            (*l_484) = l_51;
            for (l_506 = 0; (l_506 >= 1); l_506 += 8)
            { /* block id: 253 */
                int32_t l_518 = 0x70B96563L;
                l_518 = ((int32_t)((int16_t)g_90 << (int16_t)1) + (int32_t)((g_129 == ((l_518 , g_115.f0) , (((*l_43) , g_519) == ((l_518 && (((*l_476) != g_510) , (*l_507))) != 0x591201D7L)))) , g_369.f0));
                if (g_438.f0)
                    goto lbl_520;
            }
        }
    }
    else
    { /* block id: 258 */
        int32_t l_523 = 0L;
        int32_t *l_528 = &g_90;
        int16_t l_541 = 6L;
        union U0 *l_565 = &g_566;
        int32_t ***l_579 = (void*)0;
        uint32_t l_607 = 18446744073709551615UL;
        l_470 = ((l_521 != (void*)0) , (g_522 , func_52((((3UL | (((0x80EAD4ACA55B8ACALL < (0x03075554L == ((g_90 , (g_168.f0 , (l_523 , 1L))) ^ g_438.f0))) , &l_43) == &l_51)) != (*l_470)) >= 0x765CL), l_43, &l_523, g_3)));
        for (g_510 = 0; (g_510 > 5); g_510 += 2)
        { /* block id: 262 */
            int32_t l_531 = 8L;
            union U0 **l_551 = &g_414;
            union U0 ****l_567 = &l_556;
            uint16_t l_577 = 65535UL;
            int32_t l_600 = 0x575495ABL;
            int32_t *l_602 = &g_471;
            union U0 ****l_651 = &l_556;
            volatile union U0 *** volatile **l_656 = &g_604;
        }
    }
    return (*l_43);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_24(uint32_t  p_25, int32_t * p_26, int32_t * p_27, int32_t * p_28)
{ /* block id: 240 */
    int32_t *l_472 = &g_44;
    return l_472;
}


/* ------------------------------------------ */
/* 
 * reads : g_349 g_94 g_90 g_312 g_313 g_175 g_3 g_168.f0
 * writes: g_349
 */
static uint16_t  func_34(int16_t  p_35)
{ /* block id: 232 */
    union U0 ***l_466 = &g_413;
    int32_t l_469 = 0xE09A07E1L;
    for (g_349 = 19; (g_349 != (-5)); g_349 -= 2)
    { /* block id: 235 */
        l_469 = (((uint32_t)__builtin_popcountl(((-9L) | (((int16_t)(-(uint64_t)(((void*)0 != l_466) || ((uint32_t)l_469 % (uint32_t)g_94))) << (int16_t)g_90) == ((**g_312) == (*g_313))))) % (uint32_t)4L) , 0xD544BA34L);
        l_469 = (p_35 > g_168.f0);
    }
    return l_469;
}


/* ------------------------------------------ */
/* 
 * reads : g_455 g_95 g_96
 * writes: g_362
 */
static int64_t  func_40(uint32_t  p_41, uint32_t  p_42)
{ /* block id: 228 */
    int32_t ****l_453 = (void*)0;
    int32_t ****l_454 = &g_362;
    int32_t *l_456 = (void*)0;
    int32_t l_457 = (-8L);
    (*l_454) = (void*)0;
    l_456 = (g_455 , (*g_95));
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_349 g_354 g_94 g_95 g_96 g_111 g_183 g_194 g_90 g_150.f0 g_129 g_3 g_228 g_115.f0 g_44 g_168 g_289 g_348 g_361 g_369 g_354.f0 g_362 g_168.f0 g_89 g_301 g_198 g_412 g_320 g_82.f0 g_413 g_81.f0
 * writes: g_94 g_175 g_96 g_44 g_90 g_349 g_362 g_348 g_413
 */
static int32_t * func_45(int32_t * p_46, int32_t * p_47, int32_t * p_48, int32_t * p_49, uint64_t  p_50)
{ /* block id: 185 */
    const int32_t l_359 = (-9L);
    int32_t ***l_360 = &g_296;
    int32_t *l_379 = (void*)0;
    uint16_t l_422 = 0x7E88L;
    union U0 *l_437 = &g_438;
    int64_t l_444 = (-2L);
    if ((*p_48))
    { /* block id: 186 */
        int32_t *l_357 = &g_90;
        int32_t *l_358 = &g_94;
        (*g_348) = ((int32_t)(((int16_t)(func_64((g_354 , l_358), (*l_358)) ^ l_359) >> (int16_t)6) > l_359) / (int32_t)p_50);
        (*g_348) = (*l_357);
        (*g_361) = l_360;
        (*p_46) = ((uint16_t)((uint16_t)0xA485L << (uint16_t)8) >> (uint16_t)((int16_t)(g_369 , g_354.f0) + (int16_t)((g_94 == (((int16_t)(((void*)0 == &g_362) && ((int64_t)p_50 / (int64_t)g_94)) >> (int16_t)g_194) | p_50)) && (*l_358))));
    }
    else
    { /* block id: 191 */
        int64_t l_392 = 3L;
        union U0 *l_399 = &g_150;
        int32_t *l_409 = (void*)0;
        int32_t ****l_430 = &l_360;
        union U0 **l_445 = &l_399;
        int16_t l_452 = 0xCD79L;
        for (g_349 = 0; (g_349 < (-12)); g_349 -= 6)
        { /* block id: 194 */
            int8_t l_378 = 0x20L;
            union U0 *l_388 = &g_150;
            int32_t l_439 = 0L;
            int32_t *l_440 = &g_44;
            (*p_46) = __builtin_bswap64(p_50);
            if (((uint16_t)p_50 - (uint16_t)(l_378 != ((p_48 == l_379) && ((int16_t)p_50 >> (int16_t)((int64_t)((((uint16_t)(l_378 ^ ((uint64_t)((((void*)0 != l_388) , (*g_361)) == (void*)0) + (uint64_t)g_3)) >> (uint16_t)9) & p_50) && g_168.f0) + (int64_t)18446744073709551606UL))))))
            { /* block id: 196 */
                for (l_378 = 0; (l_378 == (-14)); l_378 -= 8)
                { /* block id: 199 */
                    int32_t **l_391 = &g_348;
                    (*p_46) = (*p_46);
                    (*l_391) = p_46;
                    (**l_391) = (((l_378 & l_392) > 0x5580L) , (p_50 && ((void*)0 == p_49)));
                    (**l_391) = __builtin_bswap64(l_378);
                }
            }
            else
            { /* block id: 205 */
                int8_t l_404 = 1L;
                int32_t *l_406 = &g_94;
                union U0 **l_411 = &l_388;
                int32_t *l_443 = (void*)0;
                for (l_392 = (-9); (l_392 > 9); l_392 += 1)
                { /* block id: 208 */
                    int64_t l_402 = 1L;
                    int32_t ****l_403 = (void*)0;
                    const int8_t l_405 = 0L;
                    int32_t l_433 = 0x9D2BE7B5L;
                    uint16_t l_436 = 0xDEA6L;
                    (*p_46) = (((uint16_t)((uint16_t)((l_399 == (void*)0) ^ ((*p_47) , (func_64(p_47, (((uint16_t)((((l_402 | (((l_403 == l_403) == func_64(p_46, p_50)) == 18446744073709551609UL)) != g_194) < g_3) < p_50) << (uint16_t)p_50) , l_404)) || l_405))) << (uint16_t)4) - (uint16_t)65529UL) <= l_378);
                    if ((*g_89))
                    { /* block id: 210 */
                        (*g_301) = p_47;
                    }
                    else
                    { /* block id: 212 */
                        int64_t l_419 = 0xF643FE2EC41BF3F6LL;
                        l_406 = (*g_198);
                        (*g_412) = ((!(*p_48)) , l_411);
                        (*p_46) = ((p_50 || 0x4421L) >= (((int16_t)((int16_t)l_419 << (int16_t)(((((int16_t)p_50 << (int16_t)7) < l_422) , g_115.f0) , ((__builtin_ctzl(((uint64_t)(((+((uint32_t)((uint16_t)1UL << (uint16_t)((l_430 != &g_362) || p_50)) + (uint32_t)(*g_320))) ^ 0x800FF412F7C29611LL) ^ (-1L)) + (uint64_t)p_50)) , p_50) == p_50))) / (int16_t)p_50) <= p_50));
                        l_439 = (((((p_50 >= ((uint16_t)(g_82.f0 & (*p_46)) << (uint16_t)(6UL <= l_433))) && l_378) >= (((p_50 > ((uint64_t)(((p_50 == g_194) && g_194) | l_436) + (uint64_t)g_349)) , l_437) == (*g_413))) < g_90) <= 0xBA59L);
                    }
                    l_440 = &l_439;
                }
                l_444 = ((int16_t)(g_44 , 0xA799L) >> (int16_t)(l_443 != p_49));
            }
        }
        (*p_49) = (*p_48);
        (*l_445) = l_399;
        (*g_348) = ((int64_t)g_81.f0 + (int64_t)((__builtin_ctzl(((int16_t)((int32_t)(l_452 <= (*p_48)) + (int32_t)(*p_48)) >> (int16_t)((void*)0 != &p_48))) <= (*p_47)) , __builtin_bswap32((((*p_46) > 0x4BC8077EL) >= p_50))));
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_95 g_96 g_94 g_111 g_183 g_301 g_3 g_312 g_129 g_115.f0 g_320 g_89 g_90 g_334 g_336 g_194 g_150.f0 g_228 g_168 g_289 g_198 g_81.f0
 * writes: g_175 g_96 g_44 g_94 g_313 g_90 g_296
 */
static int32_t * func_52(int32_t  p_53, int32_t * p_54, int32_t * p_55, uint16_t  p_56)
{ /* block id: 145 */
    int8_t l_316 = 0x30L;
    int32_t l_335 = 0L;
    int32_t ***l_347 = &g_296;
    int32_t ****l_346 = &l_347;
    for (p_53 = 0; (p_53 < (-24)); p_53 -= 2)
    { /* block id: 148 */
        int32_t l_299 = 0xADB7E791L;
        uint64_t l_318 = 0x33A589725621921CLL;
        int32_t l_343 = 5L;
        if ((*p_55))
        { /* block id: 149 */
            union U0 *l_332 = (void*)0;
            int32_t l_333 = 0x88293935L;
            (*g_301) = func_67((*g_95), (0x8243L | (l_299 || (g_94 != 0x87C8462C57199020LL))));
            for (g_44 = 4; (g_44 >= (-19)); g_44--)
            { /* block id: 153 */
                int32_t l_308 = 0x254D81AAL;
                for (g_94 = 0; (g_94 != 16); g_94 += 1)
                { /* block id: 156 */
                    const int32_t *l_322 = &g_94;
                    const int32_t **l_321 = &l_322;
                    uint64_t l_329 = 0x5A390C96BA849FEBLL;
                    if ((((uint16_t)(l_308 && (0UL == __builtin_parityl(g_3))) >> (uint16_t)l_299) & (-(int16_t)l_308)))
                    { /* block id: 157 */
                        int32_t **l_310 = (void*)0;
                        int32_t **l_311 = &g_96;
                        int32_t *l_319 = (void*)0;
                        (*l_311) = (void*)0;
                        (*g_312) = &g_175;
                        (*g_320) = (0xF67890D70B6333A4LL | (((uint16_t)(g_94 > ((((g_129 ^ (*p_55)) , p_56) , l_316) < (l_316 < (-(int64_t)((p_56 && (g_115.f0 >= l_318)) != 0xDFC1D7FBL))))) - (uint16_t)p_56) == p_53));
                    }
                    else
                    { /* block id: 161 */
                        if ((*g_89))
                            break;
                    }
                    (*l_321) = (void*)0;
                    if (l_299)
                        continue;
                    (*g_334) = (((((((uint32_t)l_318 / (uint32_t)(((int16_t)((uint16_t)l_329 << (uint16_t)(((((uint32_t)l_308 + (uint32_t)((void*)0 != l_332)) != (-1L)) || (0xAD2DFD22849E86D2LL == (0UL & l_308))) != p_56)) + (int16_t)g_3) , l_333)) , p_53) < p_53) != 0x78AA8BEC59F230F8LL) != (-7L)) | 0x83E0L);
                }
                if ((*p_54))
                    continue;
                l_335 = l_308;
            }
            (*g_336) = &p_54;
        }
        else
        { /* block id: 172 */
            int32_t *l_339 = (void*)0;
            (*p_55) = func_64(p_55, p_56);
            for (g_90 = 0; (g_90 != 20); g_90 += 2)
            { /* block id: 176 */
                int32_t **l_340 = &l_339;
                (*l_340) = l_339;
            }
        }
        (*g_95) = (*g_198);
        (*p_55) = ((p_56 != (*p_54)) , (p_53 , (((uint32_t)4294967295UL + (uint32_t)func_64(p_54, ((((g_90 , ((l_343 < ((((uint16_t)p_53 - (uint16_t)(&g_336 != l_346)) > p_53) <= l_299)) || g_81.f0)) && l_318) ^ g_129) & l_343))) , 0x222A849FL)));
    }
    p_55 = p_54;
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_3 g_81 g_82 g_89 g_90 g_94 g_95 g_96 g_111 g_115 g_81.f0 g_82.f0 g_168 g_174 g_183 g_194 g_115.f0 g_129 g_198 g_150.f0 g_228 g_289 g_295
 * writes: g_44 g_90 g_94 g_96 g_129 g_175 g_296
 */
static int32_t * func_57(int32_t  p_58, int32_t * p_59, uint64_t  p_60)
{ /* block id: 37 */
    int32_t *l_76 = &g_44;
    (*g_289) = ((int16_t)func_64(func_67(func_70(((__builtin_ffsl(p_60) <= g_44) , (-1L)), &g_44, l_76, (((l_76 != (((g_3 || (*p_59)) , 0x26L) , (void*)0)) > 0x12AEAFD7L) , (void*)0), l_76), g_3), p_60) << (int16_t)15);
    (*g_295) = &p_59;
    return l_76;
}


/* ------------------------------------------ */
/* 
 * reads : g_94 g_95 g_96 g_111 g_183 g_194 g_90 g_150.f0 g_129 g_3 g_228 g_115.f0 g_44 g_168 g_289
 * writes: g_94 g_175 g_96 g_44 g_90
 */
static int16_t  func_64(int32_t * p_65, uint32_t  p_66)
{ /* block id: 124 */
    uint32_t l_212 = 0xC0FF9DDBL;
    int8_t l_220 = 0L;
    int32_t *l_262 = &g_44;
    union U0 *l_265 = &g_150;
    const int32_t *l_275 = &g_94;
    const int32_t **l_274 = &l_275;
    const int32_t ***l_273 = &l_274;
    const int32_t ****l_272 = &l_273;
    int32_t *l_294 = &g_90;
    for (g_94 = 23; (g_94 > 27); g_94 += 8)
    { /* block id: 127 */
        int16_t l_219 = (-4L);
        int32_t **l_221 = &g_96;
        int64_t l_226 = 0x885194D58820E659LL;
        union U0 *l_234 = (void*)0;
        union U0 **l_233 = &l_234;
        int16_t l_241 = 0x7FEEL;
        int32_t ***l_271 = &l_221;
        int32_t ****l_270 = &l_271;
        (*l_221) = func_67((*g_95), (((int16_t)((int64_t)(-1L) % (int64_t)((uint64_t)p_66 + (uint64_t)(+(l_212 != ((uint64_t)(0x97866B3FL != ((p_66 <= (3UL < ((uint16_t)(0x1DA8L & (((uint16_t)0x4624L >> (uint16_t)6) & l_212)) >> (uint16_t)l_219))) || 0x0FA8L)) % (uint64_t)(-1L)))))) >> (int16_t)6) && l_220));
        (*g_228) = ((((((-2L) < __builtin_clzll(((uint16_t)((p_66 | ((int32_t)(g_194 ^ (g_90 , (g_150.f0 , g_94))) / (int32_t)g_129)) >= p_66) << (uint16_t)10))) <= l_220) != 0x580E9A89L) , l_226) , p_66);
        if ((l_212 , ((int16_t)((((int32_t)((l_233 == &g_175) < (g_194 , ((int16_t)((l_212 <= (4294967292UL < ((int16_t)g_115.f0 << (int16_t)((((uint32_t)(g_150.f0 , ((void*)0 != &g_90)) * (uint32_t)0L) && g_44) < 0x5E34AC40L)))) < p_66) % (int16_t)0x28A0L))) % (int32_t)l_220) >= l_241) >= p_66) << (int16_t)4)))
        { /* block id: 130 */
            int32_t *l_260 = (void*)0;
            int32_t l_261 = 5L;
            int32_t ***l_263 = (void*)0;
            int32_t ****l_264 = &l_263;
            l_262 = func_67((*g_95), (((int32_t)(g_3 != (+p_66)) / (int32_t)(((int64_t)((int16_t)((uint16_t)p_66 << (uint16_t)((int16_t)((((p_66 || ((((uint16_t)(~((uint64_t)((g_44 , p_66) != (l_220 > ((void*)0 == l_260))) % (uint64_t)l_220)) << (uint16_t)13) , 1UL) && 1L)) && l_261) == l_226) <= g_90) << (int16_t)4)) - (int16_t)3UL) - (int64_t)0x263723E2319AEFDALL) , 0x356279D2L)) >= p_66));
            (*l_264) = l_263;
        }
        else
        { /* block id: 133 */
            int16_t l_266 = 1L;
            int32_t l_267 = 0xAB1BAC27L;
            l_265 = l_265;
            l_267 = l_266;
        }
        (***l_272) = func_67(l_262, (((((int16_t)p_66 >> (int16_t)1) , __builtin_popcount(g_94)) > p_66) || ((l_270 != l_272) >= ((int32_t)((~(~g_129)) , (((g_94 , g_168) , 0x9411A3A22F7D754DLL) && p_66)) + (int32_t)0UL))));
    }
    (*g_289) = ((int32_t)(((int16_t)(((int64_t)((*l_273) != &p_65) + (int64_t)g_115.f0) & 0x3A82L) >> (int16_t)g_129) < (p_66 > (((int32_t)(~((((4294967290UL != ((void*)0 != (*l_272))) >= p_66) < p_66) || g_94)) - (int32_t)p_66) ^ g_129))) - (int32_t)g_90);
    (*l_294) = ((int16_t)((uint32_t)__builtin_ffsl(p_66) + (uint32_t)(p_66 == p_66)) >> (int16_t)g_90);
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads : g_111 g_96 g_183
 * writes: g_175 g_96
 */
static int32_t * func_67(int32_t * p_68, const int32_t  p_69)
{ /* block id: 118 */
    volatile union U0 **l_200 = (void*)0;
    volatile union U0 ***l_199 = &l_200;
    int32_t *l_201 = (void*)0;
    int32_t **l_202 = &g_96;
    p_68 = (*g_111);
    (*l_199) = &g_175;
    (**l_199) = (void*)0;
    (*l_202) = l_201;
    return (*g_183);
}


/* ------------------------------------------ */
/* 
 * reads : g_44 g_81 g_82 g_3 g_89 g_90 g_94 g_95 g_96 g_111 g_115 g_81.f0 g_82.f0 g_168 g_174 g_183 g_194 g_115.f0 g_129 g_198
 * writes: g_44 g_90 g_94 g_96 g_129 g_175
 */
static int32_t * func_70(int16_t  p_71, int32_t * p_72, int32_t * p_73, int32_t * p_74, int32_t * p_75)
{ /* block id: 38 */
    int32_t *l_84 = &g_44;
    const uint64_t l_120 = 0UL;
    union U0 *l_164 = &g_150;
    union U0 **l_163 = &l_164;
    int32_t l_172 = 0x9F941FD7L;
lbl_176:
    for (g_44 = (-23); (g_44 > 25); g_44 += 4)
    { /* block id: 41 */
        int16_t l_83 = 0x93E3L;
        int32_t *l_130 = &g_94;
        (*g_89) = ((uint32_t)g_44 / (uint32_t)(((g_44 & (__builtin_popcountll((((((g_81 , g_82) , (l_83 , l_84)) != ((l_83 | ((int16_t)(__builtin_clzl(((((l_83 ^ (((int16_t)(g_44 , 3L) >> (int16_t)g_44) != l_83)) && p_71) , p_71) & (*l_84))) , 0xBCC9L) << (int16_t)g_3)) , p_74)) , p_71) != (*l_84))) && 0x6587A760L)) != p_71) , (*l_84)));
        for (g_90 = (-20); (g_90 > 22); g_90 += 1)
        { /* block id: 45 */
            int32_t *l_93 = &g_94;
            (*l_93) = (*g_89);
            (*l_93) = (*l_93);
        }
        (*g_95) = p_73;
        for (g_94 = 0; (g_94 == 14); g_94 += 1)
        { /* block id: 52 */
            int32_t **l_103 = (void*)0;
            const int32_t *l_135 = &g_90;
            const int32_t **l_134 = &l_135;
            union U0 *l_167 = &g_150;
            if (((uint32_t)((uint16_t)(g_3 <= (l_103 != (void*)0)) << (uint16_t)3) % (uint32_t)(-9L)))
            { /* block id: 53 */
                int16_t l_106 = 7L;
                int32_t *l_121 = &g_90;
                for (g_90 = 22; (g_90 <= (-21)); g_90 -= 3)
                { /* block id: 56 */
                    int32_t *l_107 = (void*)0;
                    int32_t l_108 = 0x634C778CL;
                    l_108 = __builtin_parity(l_106);
                }
                for (l_83 = 0; (l_83 == 11); l_83 += 1)
                { /* block id: 61 */
                    int32_t **l_112 = &g_96;
                    (*g_111) = (*g_95);
                    (*l_112) = (*g_95);
                    if ((*g_89))
                        continue;
                }
                (*l_121) = (((((__builtin_ffsl(((p_71 || ((uint16_t)(p_71 == g_3) / (uint16_t)(((g_115 , (0x0A9706E1L < p_71)) == ((int64_t)((*l_84) , p_71) + (int64_t)((int32_t)(*p_72) + (int32_t)l_120))) ^ p_71))) <= 0x80F9L)) <= 0L) & p_71) <= (-1L)) , 7L) , (-1L));
                (*l_121) = ((*l_121) != ((__builtin_ffsl(p_71) , (*g_89)) < (*g_96)));
            }
            else
            { /* block id: 68 */
                int32_t l_128 = 0xCAE9FC7DL;
                union U0 *l_157 = &g_150;
                int32_t *l_171 = &g_90;
                p_75 = (((int16_t)(*l_84) << (int16_t)((uint64_t)(g_44 > (p_71 > ((*g_96) != g_3))) + (uint64_t)p_71)) , p_73);
                for (g_90 = (-11); (g_90 < 28); g_90 += 1)
                { /* block id: 72 */
                    int32_t **l_131 = &l_130;
                    int64_t l_147 = 0x757D9B7243D40911LL;
                    int32_t l_152 = (-1L);
                    g_129 = (p_71 , (l_128 , (*g_89)));
                    (*l_131) = l_130;
                    if ((g_81.f0 ^ (p_71 != (((((int64_t)((l_134 == &l_135) | (*l_130)) + (int64_t)(g_3 , p_71)) && (*g_96)) || ((uint64_t)((int64_t)(((int16_t)((((uint16_t)((int16_t)((void*)0 == &l_135) >> (int16_t)g_3) >> (uint16_t)13) | (**l_131)) || (**l_131)) + (int16_t)(**l_131)) < p_71) - (int64_t)p_71) + (uint64_t)p_71)) != p_71))))
                    { /* block id: 75 */
                        return p_72;
                    }
                    else
                    { /* block id: 77 */
                        uint64_t l_146 = 18446744073709551615UL;
                        union U0 *l_149 = &g_150;
                        union U0 **l_148 = &l_149;
                        if ((*p_75))
                            break;
                        l_147 = __builtin_clzl((__builtin_ctzl(g_44) >= l_146));
                        (*l_148) = (void*)0;
                    }
                    l_152 = (g_81.f0 , (*p_72));
                }
                for (l_83 = 0; (l_83 <= 18); l_83 += 2)
                { /* block id: 86 */
                    int32_t *l_158 = &l_128;
                    union U0 **l_162 = &l_157;
                    (*l_158) = ((uint16_t)(p_71 , ((void*)0 != l_157)) << (uint16_t)8);
                    (*l_158) = ((+((p_71 != ((*l_130) , (((__builtin_ffsll(((uint32_t)(l_162 != l_163) % (uint32_t)g_82.f0)) , ((((uint16_t)(*l_130) / (uint16_t)((&g_115 == l_167) , (*l_130))) < 0x764DL) <= p_71)) < p_71) > p_71))) & (*l_135))) , (*p_75));
                    l_130 = p_73;
                    (*l_158) = (g_168 , __builtin_parityll(g_94));
                }
                (*l_171) = (p_71 == ((int64_t)0xCE82FDDFC4C5E220LL * (int64_t)0L));
            }
            l_163 = (void*)0;
            l_172 = ((void*)0 != &l_167);
        }
    }
    if ((**g_111))
    { /* block id: 98 */
        int32_t **l_173 = &l_84;
        (*l_173) = p_74;
        return (*g_95);
    }
    else
    { /* block id: 101 */
        int32_t l_189 = 0x60E50EEEL;
        int8_t l_195 = 0x75L;
        (*g_174) = &g_168;
        if (g_94)
            goto lbl_176;
        for (l_172 = 15; (l_172 <= (-5)); l_172 -= 6)
        { /* block id: 106 */
            uint32_t l_182 = 4294967295UL;
            if (((uint16_t)(-(int64_t)l_182) << (uint16_t)6))
            { /* block id: 107 */
                int64_t l_184 = (-1L);
                (*g_183) = p_75;
                (*p_72) = ((l_184 || (((int64_t)(((l_189 >= ((int16_t)((g_44 , l_184) > ((uint16_t)(g_194 > 1UL) >> (uint16_t)11)) << (int16_t)13)) < ((l_195 != ((void*)0 == &l_189)) < 0x68A2AEEFL)) | (-6L)) - (int64_t)l_195) || p_71)) >= 0L);
                if ((*p_75))
                    break;
            }
            else
            { /* block id: 111 */
                return (*g_183);
            }
            (*g_198) = (((int16_t)((g_115.f0 ^ g_129) && 0x1A4D47DAE833BBF8LL) / (int16_t)p_71) , p_72);
        }
    }
    return (*g_198);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_23();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_44, "g_44", print_hash_value);
    transparent_crc(g_81.f0, "g_81.f0", print_hash_value);
    transparent_crc(g_82.f0, "g_82.f0", print_hash_value);
    transparent_crc(g_90, "g_90", print_hash_value);
    transparent_crc(g_94, "g_94", print_hash_value);
    transparent_crc(g_115.f0, "g_115.f0", print_hash_value);
    transparent_crc(g_129, "g_129", print_hash_value);
    transparent_crc(g_150.f0, "g_150.f0", print_hash_value);
    transparent_crc(g_168.f0, "g_168.f0", print_hash_value);
    transparent_crc(g_194, "g_194", print_hash_value);
    transparent_crc(g_349, "g_349", print_hash_value);
    transparent_crc(g_354.f0, "g_354.f0", print_hash_value);
    transparent_crc(g_369.f0, "g_369.f0", print_hash_value);
    transparent_crc(g_438.f0, "g_438.f0", print_hash_value);
    transparent_crc(g_455.f0, "g_455.f0", print_hash_value);
    transparent_crc(g_471, "g_471", print_hash_value);
    transparent_crc(g_496, "g_496", print_hash_value);
    transparent_crc(g_510, "g_510", print_hash_value);
    transparent_crc(g_511, "g_511", print_hash_value);
    transparent_crc(g_519, "g_519", print_hash_value);
    transparent_crc(g_522.f0, "g_522.f0", print_hash_value);
    transparent_crc(g_566.f0, "g_566.f0", print_hash_value);
    transparent_crc(g_598, "g_598", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 147
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 29
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 154
   depth: 2, occurrence: 30
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 4
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 155

XXX times a variable address is taken: 160
XXX times a pointer is dereferenced on RHS: 140
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 8
XXX times a pointer is dereferenced on LHS: 86
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 25
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 605

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1513
   level: 2, occurrence: 165
   level: 3, occurrence: 64
   level: 4, occurrence: 5
XXX number of pointers point to pointers: 75
XXX number of pointers point to scalars: 65
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.28

XXX times a non-volatile is read: 751
XXX times a non-volatile is write: 198
XXX times a volatile is read: 76
XXX    times read thru a pointer: 0
XXX times a volatile is write: 25
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 365
XXX percentage of non-volatile access: 90.4

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 139
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 30
   depth: 2, occurrence: 23
   depth: 3, occurrence: 21
   depth: 4, occurrence: 23
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

