/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      171672760
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_25(void);
static int32_t * func_29(int32_t  p_30, int32_t * p_31, uint32_t  p_32, uint32_t  p_33, int32_t * p_34);
static uint8_t  func_35(int32_t * p_36, int32_t * p_37);
static int32_t * func_38(int32_t * p_39, int32_t * p_40);
static int32_t * func_41(uint32_t  p_42, uint32_t  p_43, uint16_t  p_44, int32_t * p_45);
static uint16_t  func_48(int32_t  p_49);
static int32_t  func_50(uint64_t  p_51, int32_t * p_52, uint64_t  p_53);
static int8_t  func_62(const uint16_t  p_63, int64_t  p_64);
static int64_t  func_68(uint8_t  p_69, int32_t * p_70);
static uint8_t  func_71(uint64_t  p_72, uint64_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_25(void)
{ /* block id: 36 */
    int32_t l_26 = 0x97963BA2L;
    int32_t *l_335 = (void*)0;
    int64_t l_388 = (-4L);
    uint64_t l_420 = 0xB34C819D009C6021LL;
    uint64_t l_421 = 18446744073709551606UL;
    int32_t ****l_424 = (void*)0;
    uint16_t l_425 = 65531UL;
    int32_t *l_433 = &l_26;
    int8_t l_434 = 0x07L;
    for (l_26 = 0; (l_26 != 20); l_26 += 2)
    { /* block id: 39 */
        int64_t l_59 = 0x08BBD18838009552LL;
        int32_t *l_354 = &l_26;
        const int32_t *l_415 = &l_26;
        const int32_t **l_414 = &l_415;
        (*l_414) = func_29(((l_26 <= (l_26 >= func_35(func_38(func_41(((((uint16_t)func_48(func_50((((~((uint8_t)((int64_t)0L + (int64_t)__builtin_clzll(l_59)) * (uint8_t)0x30L)) == (((int8_t)func_62((((((-(int64_t)__builtin_parityl(((uint16_t)(((func_68(func_71(l_59, (&l_26 != &l_26)), &l_26) , 0xCDL) <= l_26) , 65528UL) % (uint16_t)l_26))) || 4294967290UL) , l_26) < 0UL) != l_26), l_59) - (int8_t)0xB0L) | l_26)) , l_26), l_335, l_59)) % (uint16_t)0x2D3DL) , l_59) , l_26), l_26, l_59, l_354), l_354), &l_26))) , (*l_354)), &l_26, (*l_354), l_388, &l_26);
        /* statement id: 232 */
        assert (l_415 == 0);
    }
    l_421 = (l_26 < (((uint8_t)l_388 * (uint8_t)((int16_t)((void*)0 != &l_335) % (int16_t)0xE1DAL)) == l_420));
    (*l_433) = ((((int16_t)(l_424 == (void*)0) * (int16_t)l_425) != ((l_420 <= (&l_26 != (void*)0)) | l_420)) & (~((uint8_t)(((int16_t)((uint8_t)1UL - (uint8_t)l_388) << (int16_t)9) >= 253UL) >> (uint8_t)6)));
    return l_434;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_29(int32_t  p_30, int32_t * p_31, uint32_t  p_32, uint32_t  p_33, int32_t * p_34)
{ /* block id: 223 */
    int64_t l_395 = (-6L);
    int32_t l_401 = 0xE5D3A11EL;
    int32_t *l_400 = &l_401;
    int32_t *l_409 = &l_401;
    int32_t *l_411 = (void*)0;
    int32_t *l_412 = &l_401;
    int32_t *l_413 = (void*)0;
    (*l_400) = ((int32_t)((uint32_t)((uint16_t)l_395 * (uint16_t)((uint16_t)0x5FD3L >> (uint16_t)__builtin_ia32_crc32qi(p_30, l_395))) % (uint32_t)(p_32 || (p_33 != l_395))) - (int32_t)0L);
    if (((int8_t)__builtin_clz(((((int32_t)(p_30 && p_33) + (int32_t)(*p_34)) ^ (*l_400)) <= p_33)) * (int8_t)(p_32 , (*l_400))))
    { /* block id: 225 */
        int32_t *l_406 = &l_401;
        const int32_t **l_407 = (void*)0;
        int32_t **l_408 = &l_400;
        int32_t *l_410 = &l_401;
        (*l_408) = l_406;
        return l_411;
        /* statement id: 227 */
        //assert (func_29_rv == 0);
    }
    else
    { /* block id: 228 */
        (*l_400) = 1L;
    }
    return l_413;
    /* statement id: 231 */
    //assert (func_29_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_35(int32_t * p_36, int32_t * p_37)
{ /* block id: 206 */
    int32_t l_369 = 0x762BF705L;
    int32_t l_373 = 0L;
    uint16_t l_374 = 0xFCB9L;
    int32_t ***l_379 = (void*)0;
    int32_t ****l_378 = &l_379;
    int32_t *l_385 = (void*)0;
    int32_t *l_386 = &l_373;
    uint16_t l_387 = 65526UL;
    if (__builtin_bswap32(((int64_t)((uint8_t)((((int16_t)__builtin_parityll(l_369) + (int16_t)l_369) , (void*)0) != &p_37) << (uint8_t)((uint8_t)(!((*p_36) || __builtin_ctz(((l_369 , (((((((func_48(((void*)0 != &l_369)) | 4294967295UL) & l_369) && l_373) != l_373) , (void*)0) == (void*)0) | 0xC3L)) <= l_374)))) * (uint8_t)0L)) % (int64_t)l_374)))
    { /* block id: 207 */
        uint8_t l_377 = 0xEAL;
        for (l_374 = 0; (l_374 != 33); l_374 += 1)
        { /* block id: 210 */
            return l_377;
        }
    }
    else
    { /* block id: 213 */
        int8_t l_381 = 0x8BL;
        int32_t l_384 = 0xBEBF955FL;
        if (l_373)
        { /* block id: 214 */
            int32_t *****l_380 = &l_378;
            (*l_380) = l_378;
        }
        else
        { /* block id: 216 */
            return l_381;
        }
        l_384 = (l_381 , ((uint16_t)l_381 >> (uint16_t)0));
    }
    (*l_386) = l_369;
    return l_387;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_38(int32_t * p_39, int32_t * p_40)
{ /* block id: 203 */
    int16_t l_360 = 0xEB8EL;
    int32_t l_361 = 0L;
    int32_t *l_362 = &l_361;
    l_361 = ((uint8_t)l_360 % (uint8_t)0x59L);
    return p_40;
    /* statement id: 205 */
    //assert (func_38_rv == &l_26);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(uint32_t  p_42, uint32_t  p_43, uint16_t  p_44, int32_t * p_45)
{ /* block id: 200 */
    int32_t l_357 = 0xDA255B75L;
    int32_t *l_356 = &l_357;
    int32_t **l_355 = &l_356;
    (*l_355) = p_45;
    /* statement id: 201 */
    //assert (l_356 == &l_26);
    return p_45;
    /* statement id: 202 */
    //assert (func_41_rv == &l_26);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(int32_t  p_49)
{ /* block id: 197 */
    int8_t l_345 = 0x71L;
    int32_t *l_351 = (void*)0;
    int32_t l_353 = 0xE753BC47L;
    int32_t *l_352 = &l_353;
    (*l_352) = (((uint16_t)p_49 >> (uint16_t)11) || (l_345 || (!((uint8_t)(p_49 != (l_345 | (p_49 , (((uint8_t)0x0DL >> (uint8_t)1) , p_49)))) - (uint8_t)p_49))));
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_50(uint64_t  p_51, int32_t * p_52, uint64_t  p_53)
{ /* block id: 194 */
    int32_t **l_337 = (void*)0;
    int32_t *** const l_336 = &l_337;
    int32_t l_342 = (-1L);
    const int32_t *l_341 = &l_342;
    const int32_t ** const l_340 = &l_341;
    const int32_t ** const *l_339 = &l_340;
    const int32_t ** const **l_338 = &l_339;
    (*l_338) = l_336;
    /* statement id: 195 */
    assert (l_339 == &l_337);
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_62(const uint16_t  p_63, int64_t  p_64)
{ /* block id: 64 */
    int32_t **l_115 = (void*)0;
    int32_t l_124 = 0x3379BBDCL;
    int32_t *l_125 = (void*)0;
    int32_t *l_126 = &l_124;
    uint64_t l_212 = 0x3EADC2A9FDAC8820LL;
    int32_t l_213 = (-1L);
    const int32_t *l_216 = &l_124;
    int32_t **l_217 = &l_126;
    int32_t *** const l_267 = &l_217;
    int32_t *** const * const l_266 = &l_267;
    int32_t *l_276 = &l_124;
    int32_t l_281 = (-6L);
    int64_t l_333 = (-3L);
    (*l_126) = ((l_115 != (p_63 , l_115)) == ((uint8_t)__builtin_ctzl(((int16_t)((uint16_t)((p_63 , p_64) ^ (((p_64 , p_64) , (l_124 > (0xED8564F5E99A55AELL == 18446744073709551615UL))) < p_64)) % (uint16_t)p_63) << (int16_t)14)) - (uint8_t)0x37L));
    if (((*l_126) >= ((void*)0 == &l_124)))
    { /* block id: 66 */
        const uint8_t l_129 = 0xBCL;
        int32_t ***l_140 = &l_115;
        int32_t ****l_139 = &l_140;
        for (p_64 = 0; (p_64 <= 21); p_64 += 1)
        { /* block id: 69 */
            int32_t *l_135 = &l_124;
            if (l_129)
            { /* block id: 70 */
                int32_t *l_132 = &l_124;
                int32_t * const ****l_141 = (void*)0;
                int32_t *****l_142 = &l_139;
                (*l_126) = ((((uint32_t)(l_132 != (((int8_t)0xF1L >> (int8_t)1) , l_135)) + (uint32_t)(((*l_132) && (*l_126)) ^ ((uint8_t)((+((-1L) == ((void*)0 != l_132))) >= ((*l_126) ^ 0xC0B8F99DL)) * (uint8_t)255UL))) == (*l_132)) , p_64);
                (*l_142) = l_139;
            }
            else
            { /* block id: 73 */
                uint32_t l_143 = 0xE796DA17L;
                l_135 = l_135;
                return l_143;
            }
            (*l_135) = 0x309E2023L;
        }
        return p_64;
    }
    else
    { /* block id: 80 */
        const int32_t *l_145 = &l_124;
        const int32_t **l_144 = &l_145;
        int32_t ***l_192 = &l_115;
        int32_t ****l_191 = &l_192;
        int32_t *****l_190 = &l_191;
        int32_t *l_215 = (void*)0;
        (*l_144) = &l_124;
        for (p_64 = (-15); (p_64 > (-2)); p_64 += 5)
        { /* block id: 84 */
            int64_t l_153 = (-1L);
            int32_t * const *l_185 = (void*)0;
            int32_t * const * const *l_184 = &l_185;
            int32_t *l_214 = &l_213;
            (*l_144) = (*l_144);
        }
        (*l_126) = p_64;
        l_216 = (*l_144);
    }
    (*l_217) = (void*)0;
    /* statement id: 120 */
    assert (l_126 == 0);
    for (p_64 = 16; (p_64 != 4); p_64 -= 3)
    { /* block id: 123 */
        int32_t * const * const *l_227 = (void*)0;
        int32_t *l_228 = &l_213;
        int32_t **l_247 = &l_125;
        const int16_t l_254 = 0L;
        int32_t ****l_260 = (void*)0;
        int32_t *****l_259 = &l_260;
        uint32_t l_290 = 0x91CD5F59L;
        int16_t l_311 = 0x69CBL;
        int8_t l_317 = 0xF1L;
        int32_t l_334 = 0xA50DC033L;
        for (l_212 = (-10); (l_212 > 42); l_212 += 4)
        { /* block id: 126 */
            int32_t ***l_226 = (void*)0;
            int32_t l_229 = 5L;
            int32_t l_230 = 1L;
            int32_t *****l_231 = (void*)0;
            int32_t * const ****l_232 = (void*)0;
            int32_t * const *l_236 = &l_126;
            int32_t * const **l_235 = &l_236;
            int32_t * const ***l_234 = &l_235;
            int32_t * const ****l_233 = &l_234;
            (*l_217) = (void*)0;
            /* statement id: 127 */
            assert (l_126 == 0);
            l_230 = (((int16_t)(((((int16_t)__builtin_clz((l_226 != (func_71(p_64, p_64) , l_227))) << (int16_t)0) < func_68(p_63, l_228)) && p_63) || (-8L)) >> (int16_t)3) != l_229);
            (*l_233) = &l_227;
            /* statement id: 129 */
            assert (l_234 == &l_227);
        }
        (*l_228) = ((int8_t)(((int16_t)((int8_t)0x8BL >> (int8_t)p_63) >> (int16_t)8) && __builtin_parity(p_63)) >> (int8_t)(p_63 > 0x77D6962B2ED70B56LL));
        for (l_213 = (-25); (l_213 != 9); l_213++)
        { /* block id: 134 */
            int32_t * const *l_248 = &l_126;
            int32_t l_289 = 0xD06CCA62L;
            int32_t *l_296 = (void*)0;
            int32_t ****l_305 = (void*)0;
            int32_t *l_318 = (void*)0;
            if (__builtin_parityl((*l_228)))
            { /* block id: 135 */
                int32_t l_249 = (-1L);
                const int32_t *l_252 = &l_124;
                int32_t ***l_264 = &l_217;
                uint32_t l_265 = 4UL;
                int8_t l_273 = 0x4AL;
                if ((((int8_t)((p_64 , l_247) == l_248) * (int8_t)l_249) || 1UL))
                { /* block id: 136 */
                    int32_t *l_251 = &l_213;
                    int32_t ** const *l_263 = &l_115;
                    int32_t ** const **l_262 = &l_263;
                    int32_t ** const ***l_261 = &l_262;
                    if (func_68((~p_64), l_251))
                    { /* block id: 137 */
                        int32_t **l_253 = &l_125;
                        (*l_253) = l_252;
                        /* statement id: 138 */
                        assert (l_125 == &l_124);
                        if (l_254)
                            continue;
                    }
                    else
                    { /* block id: 140 */
                        int32_t *l_255 = (void*)0;
                        int32_t *l_256 = &l_124;
                        (*l_256) = p_64;
                    }
                    if ((((__builtin_popcountl((p_64 | (((uint16_t)(0x580886FBCFDD99D9LL == (l_259 == l_261)) * (uint16_t)8L) , (((p_63 <= ((((void*)0 == (**l_261)) > ((void*)0 != l_264)) || 0x92L)) , p_64) , (*l_251))))) && p_63) <= l_265) || p_64))
                    { /* block id: 143 */
                        if (p_64)
                            break;
                        (**l_264) = (**l_264);
                        if ((*l_216))
                            continue;
                    }
                    else
                    { /* block id: 147 */
                        uint16_t l_268 = 0x3A43L;
                        (*l_217) = (*l_217);
                        l_268 = ((*l_261) == l_266);
                    }
                    if ((*l_252))
                        continue;
                    (*l_261) = (*l_261);
                }
                else
                { /* block id: 153 */
                    int32_t **l_269 = &l_126;
                    int32_t **l_280 = &l_276;
                    (*l_269) = (*l_248);
                    for (l_265 = 0; (l_265 < 60); l_265++)
                    { /* block id: 157 */
                        uint16_t l_272 = 3UL;
                        (*l_269) = (***l_266);
                        (**l_264) = (*l_269);
                        l_272 = (-9L);
                        l_273 = p_64;
                    }
                    for (l_249 = 21; (l_249 < 15); l_249--)
                    { /* block id: 165 */
                        int8_t l_279 = 0x2AL;
                        (*l_269) = l_276;
                        /* statement id: 166 */
                        assert (l_126 == &l_124);
                        (**l_267) = (***l_266);
                        (**l_248) = ((((uint8_t)l_279 * (uint8_t)p_63) , l_280) == (void*)0);
                    }
                }
                if (l_281)
                { /* block id: 171 */
                    uint16_t l_285 = 0x2927L;
                    if ((((void*)0 != (*l_264)) | (((((uint16_t)(!(p_64 <= 1L)) - (uint16_t)l_285) >= (*l_228)) >= (((~(((int32_t)(((((l_289 , ((void*)0 != (**l_266))) , l_290) , 0x9D2C9FDBBE093A50LL) & p_64) ^ p_64) - (int32_t)(*l_252)) > 18446744073709551611UL)) >= p_64) | 1L)) < p_63)))
                    { /* block id: 172 */
                        (*l_247) = (**l_264);
                    }
                    else
                    { /* block id: 174 */
                        return p_64;
                    }
                    if (p_64)
                        continue;
                }
                else
                { /* block id: 178 */
                    int32_t * const l_291 = &l_281;
                    int32_t **l_292 = &l_126;
                    (*l_292) = l_291;
                    /* statement id: 179 */
                    assert (l_126 == &l_281);
                    (**l_266) = (*l_264);
                    (***l_266) = ((+(((int64_t)((18446744073709551613UL >= (p_64 & __builtin_ffsll(p_64))) , ((*l_292) == ((**l_248) , (*l_248)))) - (int64_t)(func_71(p_64, (**l_292)) < 0UL)) != 18446744073709551615UL)) , (*l_217));
                    return p_63;
                }
            }
            else
            { /* block id: 184 */
                uint16_t l_306 = 0x4865L;
                (*l_247) = l_296;
                /* statement id: 185 */
                assert (l_125 == 0);
                (*l_276) = (((int64_t)(((uint16_t)(((*l_228) <= ((uint16_t)((int64_t)0x1EBB8F7548C9A67DLL - (int64_t)__builtin_popcount(p_63)) >> (uint16_t)(l_305 == &l_267))) , (0xB9L | func_71(p_63, p_63))) + (uint16_t)p_63) < p_63) % (int64_t)(-1L)) < l_306);
            }
            (*l_276) = (((((int8_t)(p_64 , 0xF4L) >> (int8_t)1) ^ p_64) , (*l_228)) , p_63);
            (*l_276) = ((int16_t)p_63 * (int16_t)((-(uint64_t)func_71((!((int8_t)((1L == (((int8_t)__builtin_ctzl(((int16_t)(((int16_t)((int8_t)p_63 * (int8_t)(p_64 | ((((0x4F55L > ((func_71(p_63, p_64) <= ((__builtin_bswap64((*l_228)) > p_64) || l_333)) <= 0x3E8A82FDAFAEC72DLL)) , 250UL) < p_64) & 5UL))) + (int16_t)(*l_276)) && p_64) * (int16_t)1L)) << (int8_t)4) || p_64)) | l_334) + (int8_t)p_64)), p_63)) & p_64));
        }
        (***l_266) = (*l_247);
    }
    /* facts after for loop */
    assert (l_125 == &l_124 || l_125 == 0);
    assert (l_126 == &l_124 || l_126 == 0);
    return p_63;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_68(uint8_t  p_69, int32_t * p_70)
{ /* block id: 42 */
    uint64_t l_85 = 1UL;
    const int32_t ***l_86 = (void*)0;
    int8_t l_94 = 1L;
    int32_t l_110 = 0xBFA339BCL;
    int32_t *l_109 = &l_110;
    int32_t *l_111 = (void*)0;
    int32_t *l_112 = (void*)0;
    int32_t *l_113 = &l_110;
    uint32_t l_114 = 0x76AF746AL;
    for (p_69 = 0; (p_69 <= 52); p_69 += 1)
    { /* block id: 45 */
        int32_t l_76 = 0x5C1B09C8L;
        int32_t **l_84 = (void*)0;
        int32_t *l_87 = &l_76;
        for (l_76 = (-29); (l_76 >= 21); l_76++)
        { /* block id: 48 */
            int32_t * const *l_80 = (void*)0;
            int32_t * const **l_79 = &l_80;
            uint8_t l_81 = 255UL;
            int32_t l_83 = 0xCD43A1E2L;
            int32_t *l_82 = &l_83;
            if ((*p_70))
                break;
            (*l_79) = (void*)0;
            (*l_82) = l_81;
            l_82 = p_70;
            /* statement id: 52 */
            //assert (l_82 == &l_26 || l_82 == &l_155 || l_82 == &l_213);
        }
        (*l_87) = (((p_70 != (void*)0) < (l_84 == (void*)0)) >= ((__builtin_ffsl(((l_85 > p_69) , p_69)) != (l_86 != l_86)) > p_69));
        (*l_87) = ((int8_t)(((*p_70) <= ((int8_t)l_85 + (int8_t)((uint8_t)(p_69 ^ l_94) >> (uint8_t)0))) , p_69) + (int8_t)((p_69 > (*p_70)) , p_69));
        if (((uint8_t)p_69 - (uint8_t)((p_69 , ((*l_87) != ((!((*p_70) <= 0L)) || ((int16_t)((((-(uint16_t)((int64_t)p_69 + (int64_t)(((uint16_t)((((p_70 == p_70) == __builtin_bswap32(((((int64_t)(func_71(l_85, (*l_87)) , (*l_87)) - (int64_t)0x94B98F8D6FFBA4BDLL) , p_69) & p_69))) ^ p_69) ^ (*l_87)) - (uint16_t)l_85) > (*l_87)))) , 0x186F270AL) , 1L) <= (*l_87)) >> (int16_t)0)))) < 1L)))
        { /* block id: 56 */
            int32_t l_107 = 0L;
            l_107 = (*l_87);
        }
        else
        { /* block id: 58 */
            int32_t *l_108 = &l_76;
            l_109 = l_108;
            /* statement id: 59 */
            assert (l_109 == &l_76);
        }
        /* facts after branching */
        //assert (l_109 == &l_76 || l_109 == dangling || l_109 == &l_110);
    }
    /* facts after for loop */
    //assert (l_109 == dangling || l_109 == &l_110);
    (*l_113) = (*p_70);
    return l_114;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_71(uint64_t  p_72, uint64_t  p_73)
{ /* block id: 40 */
    return p_73;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_25();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 101
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 47
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 47, occurrence: 1

XXX total number of pointers: 113

XXX times a variable address is taken: 92
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 58
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 5
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 415

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 242
   level: 2, occurrence: 61
   level: 3, occurrence: 23
   level: 4, occurrence: 21
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 57
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.2
XXX average alias set size: 1.14

XXX times a non-volatile is read: 472
XXX times a non-volatile is write: 151
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 104
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 21
   depth: 2, occurrence: 18
   depth: 3, occurrence: 8
   depth: 4, occurrence: 13
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
********************* end of statistics **********************/

