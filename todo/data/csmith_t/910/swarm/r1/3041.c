/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2067247796
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
static int32_t  func_46(int32_t  p_47);
static uint16_t  func_57(int32_t  p_58, uint32_t  p_59);
static uint32_t  func_68(int16_t  p_69);
static uint16_t  func_77(float * p_78, float * p_79, uint16_t  p_80);
static float * func_81(int32_t  p_82, uint32_t  p_83);
static int32_t  func_86(float * p_87);
static float ** const  func_91(uint32_t  p_92, int16_t  p_93, int16_t  p_94, float  p_95, float ** const  p_96);
static uint32_t  func_97(const int16_t  p_98, float * p_99, const uint16_t  p_100);
static float  func_109(int16_t  p_110, const float * const * p_111, int32_t  p_112, float * p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0x0EC3203B;
    const uint32_t l_604 = 8U;
    float l_660 = 0x5.FC09F2p-10;
    float *l_659 = &l_660;
    float **l_658 = &l_659;
    float ***l_657 = &l_658;
    float ****l_656 = &l_657;
    float *****l_655 = &l_656;
    int32_t *l_739 = &l_32;
    int32_t l_740 = 0x769C4B64;
lbl_661:
    for (l_32 = 0; (l_32 >= 8); l_32 = safe_add_func_uint16_t_u_u(l_32, 1))
    { /* block id: 39 */
        int32_t l_39 = 0;
        float l_43 = 0x9.8FAD74p-30;
        float *l_42 = &l_43;
        int32_t l_598 = 0xAB0EB29E;
        int32_t *l_599 = &l_39;
        (*l_42) = ((((safe_sub_func_float_f_f(((0 & 1) , ((safe_lshift_func_int16_t_s_u(l_32, 4)) , ((__builtin_popcount(l_39) , l_32) , ((__builtin_ia32_crc32qi(l_39, ((((safe_add_func_int16_t_s_s(l_39, (l_32 <= l_32))) & l_32) | l_32) >= l_39)) < l_39) <= l_39)))), l_32)) == l_32) <= 0x6.Cp-1) >= l_32);
        (*l_599) = ((safe_rshift_func_uint16_t_u_u(((func_46((safe_rshift_func_uint16_t_u_s(0x5123, 2))) && l_39) < ((&l_39 == &l_39) & l_32)), ((l_32 , (safe_add_func_int32_t_s_s((safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((-7), (safe_lshift_func_int16_t_s_u((((safe_sub_func_int16_t_s_s((l_39 | l_32), 5U)) , l_39) <= 0x722E), 10)))), l_32)), 0xB0370713))) , 0xA771))) >= l_598);
    }
    for (l_32 = 15; (l_32 > (-5)); l_32 = safe_sub_func_uint32_t_u_u(l_32, 5))
    { /* block id: 252 */
        const int16_t l_609 = 4;
        int32_t l_610 = 6;
        uint32_t l_632 = 0xB8167B32;
        float *****l_646 = (void*)0;
        const float *l_676 = &l_660;
        int32_t *l_677 = &l_610;
        uint32_t l_685 = 8U;
        uint32_t l_712 = 0x49513B74;
        float l_719 = 0xB.4BEED0p+8;
        int32_t *** const *l_737 = (void*)0;
        int32_t *** const ** const l_736 = &l_737;
        if (l_32)
        { /* block id: 253 */
            float l_606 = 0x1.8p-1;
            float *l_605 = &l_606;
            int32_t l_608 = 0;
            int32_t *l_607 = &l_608;
            (*l_605) = (safe_sub_func_float_f_f(l_604, 0x1.8p+1));
            l_607 = &l_32;
            /* statement id: 255 */
            assert (l_607 == &l_32);
            l_610 = ((l_609 < 0x0.Ap-1) , l_604);
            if (l_610)
            { /* block id: 257 */
                int32_t **l_611 = (void*)0;
                int32_t **l_612 = &l_607;
                (*l_612) = &l_608;
                /* statement id: 258 */
                assert (l_607 == &l_608);
            }
            else
            { /* block id: 259 */
                for (l_610 = 0; (l_610 < 16); l_610 = safe_add_func_uint16_t_u_u(l_610, 1))
                { /* block id: 262 */
                    return l_604;
                }
                return l_32;
            }
            /* facts after branching */
            assert (l_607 == &l_608);
        }
        else
        { /* block id: 267 */
            int16_t l_625 = 0x6AB2;
            float l_652 = (-0x3.4p-1);
            float *l_651 = &l_652;
            float * const **l_669 = (void*)0;
            float * const ***l_668 = &l_669;
            int32_t l_720 = 1;
            int32_t l_729 = 0x128163C9;
            int32_t ****l_735 = (void*)0;
            int32_t *****l_734 = &l_735;
            for (l_610 = (-4); (l_610 != (-22)); l_610 = safe_sub_func_int16_t_s_s(l_610, 9))
            { /* block id: 270 */
                int32_t l_617 = (-1);
                float l_631 = 0x0.Bp+1;
                float *l_630 = &l_631;
                float ***l_649 = (void*)0;
                float ****l_648 = &l_649;
                float *****l_647 = &l_648;
                float *l_650 = &l_631;
                for (l_617 = 16; (l_617 > 17); l_617 = safe_add_func_uint16_t_u_u(l_617, 3))
                { /* block id: 273 */
                    int32_t l_620 = (-1);
                    for (l_620 = 0; (l_620 >= 17); l_620 = safe_add_func_uint32_t_u_u(l_620, 1))
                    { /* block id: 276 */
                        int32_t l_624 = (-4);
                        int32_t *l_623 = &l_624;
                        (*l_623) = 0x11CD1A50;
                    }
                }
                (*l_630) = (__builtin_clzl(l_625) , ((safe_add_func_float_f_f((safe_add_func_float_f_f(0x1.Fp+1, func_77((l_625 , (void*)0), l_630, l_632))), ((!((0x6.0p-1 >= l_632) < l_604)) > 0x6.9p-1))) > l_609));
                (*l_650) = (((((((~(safe_lshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((~l_604) != __builtin_clzll(l_625)), ((safe_add_func_int16_t_s_s(__builtin_clzl(l_632), (l_32 < (safe_add_func_uint32_t_u_u(((((((safe_add_func_uint16_t_u_u(__builtin_clz(__builtin_clz(l_617)), 0xAB7D)) , &l_617) == (void*)0) , l_646) != l_647) >= l_625), l_610))))) == l_617))), l_604))) && l_604) , l_650) != l_651) > 0x1.8p-1) != 0x2.D3E0D6p+63) >= (-0x1.0p+1));
                for (l_625 = (-21); (l_625 == 21); l_625 = safe_add_func_int16_t_s_s(l_625, 1))
                { /* block id: 284 */
                    (**l_658) = (l_32 > ((l_655 == (void*)0) < l_617));
                    if (l_617)
                        continue;
                    if (l_609)
                        goto lbl_661;
                }
            }
            for (l_625 = 0; (l_625 > (-6)); l_625 = safe_sub_func_int32_t_s_s(l_625, 3))
            { /* block id: 292 */
                int16_t l_664 = (-1);
                float ****l_667 = &l_657;
                int32_t *l_696 = &l_610;
                uint16_t l_723 = 0x63EF;
                int32_t l_726 = 0;
                int32_t **l_738 = &l_677;
            }
            return l_32;
        }
    }
    (*l_739) = (0xAA0C086A == l_604);
    return l_740;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_46(int32_t  p_47)
{ /* block id: 41 */
    uint16_t l_65 = 0x2628;
    float l_453 = (-0x4.Dp-1);
    float *l_452 = &l_453;
    int32_t ****l_496 = (void*)0;
    int32_t l_522 = 0x8D137E17;
    float **l_560 = &l_452;
    float ***l_559 = &l_560;
    for (p_47 = 0; (p_47 == (-6)); --p_47)
    { /* block id: 44 */
        int32_t l_52 = 0x0040B319;
        int32_t l_60 = 0x53B72B46;
        int32_t *l_442 = &l_52;
        int32_t ** const l_441 = &l_442;
        float ***l_476 = (void*)0;
        float *** const * const l_475 = &l_476;
        int32_t **l_484 = &l_442;
        int32_t ***l_483 = &l_484;
        int32_t ****l_482 = &l_483;
        int32_t *****l_481 = &l_482;
        const float * const *l_485 = (void*)0;
        uint16_t l_495 = 0x563B;
        int32_t l_501 = 0;
        int32_t *l_523 = (void*)0;
        int16_t l_544 = 9;
        for (l_52 = 0; (l_52 <= (-5)); l_52 = safe_sub_func_int32_t_s_s(l_52, 1))
        { /* block id: 47 */
            float l_412 = 0x3.B6C084p+93;
            int32_t l_413 = 0x26E7F9DE;
            float * const *l_505 = &l_452;
            float * const **l_504 = &l_505;
            float ****l_525 = &l_476;
            float *****l_524 = &l_525;
        }
        for (l_60 = (-29); (l_60 < (-3)); l_60 = safe_add_func_int16_t_s_s(l_60, 1))
        { /* block id: 200 */
            int32_t l_528 = 0x092E8BFC;
            uint16_t l_533 = 0xB0CD;
            float **l_537 = &l_452;
            float ***l_536 = &l_537;
            if (l_528)
                break;
            (****l_481) = func_81((safe_lshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(l_533, (safe_add_func_uint32_t_u_u(p_47, ((((void*)0 != l_536) && (p_47 || (p_47 , (safe_add_func_uint32_t_u_u(((l_533 | (!1U)) > ((~l_528) && l_528)), p_47))))) | p_47))))), 3)), l_544);
            /* statement id: 202 */
            assert (l_442 == 0);
        }
        /* facts after for loop */
        assert (l_442 == 0 || l_442 == &l_52);
        (**l_483) = &p_47;
        /* statement id: 204 */
        assert (l_442 == &p_47);
        if (((((!p_47) >= (**l_484)) != p_47) <= (safe_sub_func_uint16_t_u_u((((p_47 <= (p_47 && p_47)) >= ((p_47 <= (-8)) && func_68(p_47))) >= p_47), p_47))))
        { /* block id: 205 */
            for (l_60 = 7; (l_60 <= (-1)); --l_60)
            { /* block id: 208 */
                int16_t l_552 = 1;
                (*l_452) = ((safe_add_func_float_f_f(l_552, (0x1.2F48DAp+72 != p_47))) < p_47);
                for (l_552 = 2; (l_552 == (-1)); l_552 = safe_sub_func_int16_t_s_s(l_552, 7))
                { /* block id: 212 */
                    l_522 = p_47;
                }
            }
        }
        else
        { /* block id: 216 */
            uint16_t l_562 = 1U;
            if (p_47)
                break;
            for (l_501 = 0; (l_501 >= 3); l_501 = safe_add_func_int16_t_s_s(l_501, 1))
            { /* block id: 220 */
                uint16_t l_563 = 1U;
                uint16_t l_581 = 65535U;
                uint16_t l_582 = 0U;
                float **l_583 = &l_452;
                int32_t l_585 = 0;
                l_522 = __builtin_ctzl(p_47);
                for (l_495 = (-6); (l_495 == 52); l_495 = safe_add_func_uint32_t_u_u(l_495, 4))
                { /* block id: 224 */
                    float ****l_561 = &l_476;
                    (*l_561) = l_559;
                    /* statement id: 225 */
                    assert (l_476 == &l_560);
                    if (l_562)
                        continue;
                }
                if (((l_563 == p_47) != p_47))
                { /* block id: 228 */
                    (***l_559) = (*****l_481);
                    return p_47;
                }
                else
                { /* block id: 231 */
                    const int32_t l_578 = 1;
                    float **l_584 = &l_452;
                    for (l_522 = 0; (l_522 < (-16)); l_522 = safe_sub_func_uint32_t_u_u(l_522, 1))
                    { /* block id: 234 */
                        float l_574 = 0x2.054828p+67;
                        int32_t l_575 = 0x6AAF12EE;
                        l_585 = ((p_47 != ((p_47 , (safe_add_func_float_f_f((((p_47 >= ((safe_sub_func_float_f_f((((safe_add_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(l_575, (((safe_mod_func_uint16_t_u_u((p_47 , (((p_47 ^ l_563) >= (((l_578 && ((((safe_lshift_func_uint16_t_u_s(l_563, l_575)) , l_562) , p_47) , l_581)) | l_578) && 4294967295U)) ^ 0x787C)), p_47)) || p_47) , l_582))), 0x6BCE)) , l_583) != l_584), 0x2.6B6173p-51)) == 0xE.85F4CEp+39)) < p_47) == p_47), 0x3.7DAFEAp-33))) > p_47)) == (**l_484));
                    }
                    for (l_563 = 18; (l_563 <= 30); l_563 = safe_add_func_int32_t_s_s(l_563, 3))
                    { /* block id: 239 */
                        if (p_47)
                            break;
                        if (l_562)
                            continue;
                    }
                }
            }
            /* facts after for loop */
            assert (l_476 == &l_560 || l_476 == 0);
        }
        /* facts after branching */
        assert (l_476 == &l_560 || l_476 == 0);
    }
    return l_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_57(int32_t  p_58, uint32_t  p_59)
{ /* block id: 48 */
    float *l_70 = (void*)0;
    int32_t l_192 = 2;
    float l_228 = 0x0.E68182p-78;
    float *l_227 = &l_228;
    const int32_t *l_402 = &l_192;
    const int32_t **l_401 = &l_402;
    const int32_t ***l_400 = &l_401;
    const int32_t ****l_399 = &l_400;
    float ***l_411 = (void*)0;
    if ((safe_sub_func_uint32_t_u_u(func_68(((((((l_70 == l_70) != 0x04F36CCC) == ((((safe_lshift_func_uint16_t_u_u((l_70 != l_70), ((((safe_rshift_func_uint16_t_u_s((safe_sub_func_uint16_t_u_u(func_77(func_81((p_58 , (0x6EE0 ^ (safe_mod_func_int32_t_s_s(func_86(l_70), p_58)))), l_192), l_227, p_59), 0xA4B0)), l_192)) | 0x7B35) >= 0U) <= 0x6929))) , l_192) , (void*)0) == (void*)0)) == p_59) , 65532U) < p_59)), (-1))))
    { /* block id: 153 */
        float *l_389 = &l_228;
        int32_t l_397 = 0x09F10D2E;
        uint32_t l_398 = 7U;
        const int32_t ****l_403 = &l_400;
        (*l_389) = (p_59 <= (0x1.4p+1 < ((!(!(safe_add_func_float_f_f(((void*)0 == l_389), (p_59 > (-0x6.94870Ep+8)))))) >= ((((((safe_sub_func_float_f_f(((safe_sub_func_int16_t_s_s(p_59, ((safe_sub_func_int32_t_s_s((l_397 , ((7 < 3) > l_397)), p_59)) < 0x58D3A4A6))) , l_397), l_398)) > 0x8.Dp+1) != 0x0.D72E1Fp+25) , l_399) != l_403) > (**l_401)))));
        (***l_399) = func_81(p_59, (****l_399));
        /* statement id: 155 */
        assert (l_402 == 0);
    }
    else
    { /* block id: 156 */
        int32_t * const l_404 = (void*)0;
        int32_t *l_406 = &l_192;
        int32_t **l_405 = &l_406;
        int32_t ***l_410 = (void*)0;
        int32_t ****l_409 = &l_410;
        (*l_405) = l_404;
        /* statement id: 157 */
        assert (l_406 == 0);
        (*l_405) = (((***l_400) != (safe_add_func_float_f_f((__builtin_clzl((((void*)0 != l_409) & (**l_401))) > (-0x1.Fp-1)), p_59))) , (void*)0);
        return p_58;
    }
    /* facts after branching */
    assert (l_402 == 0);
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_68(int16_t  p_69)
{ /* block id: 148 */
    uint16_t l_376 = 0xA130;
    int32_t l_378 = 0x97A47924;
    int32_t *l_377 = &l_378;
    int32_t **l_380 = &l_377;
    int32_t ***l_379 = &l_380;
    int32_t ****l_381 = &l_379;
    float l_384 = (-0x1.Bp-1);
    l_377 = func_81(p_69, l_376);
    /* statement id: 149 */
    assert (l_377 == 0);
    (*l_381) = l_379;
    (**l_379) = func_81((safe_add_func_uint16_t_u_u(__builtin_ia32_crc32qi(p_69, p_69), (p_69 & ((p_69 , (l_377 == l_377)) || p_69)))), p_69);
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_77(float * p_78, float * p_79, uint16_t  p_80)
{ /* block id: 82 */
    uint32_t l_233 = 4294967295U;
    int32_t l_296 = 0x403924B4;
    uint32_t l_342 = 1U;
lbl_370:
    (*p_79) = (*p_79);
    if ((((safe_mod_func_int32_t_s_s((((4294967292U >= (l_233 || ((safe_lshift_func_int16_t_s_s((safe_unary_minus_func_int16_t_s(((p_80 , l_233) ^ (safe_lshift_func_int16_t_s_u((0x155E1EFB & (((safe_sub_func_int16_t_s_s(l_233, (65535U > l_233))) & ((0U || p_80) && p_80)) , 1U)), 2))))), 5)) <= l_233))) >= p_80) > l_233), l_233)) <= p_80) , p_80))
    { /* block id: 84 */
        uint16_t l_243 = 65535U;
        int32_t l_249 = (-5);
        uint32_t l_264 = 0U;
        float l_268 = 0x6.818C2Bp+36;
        float *l_267 = &l_268;
        float **l_266 = &l_267;
        int32_t *l_321 = &l_249;
        for (l_233 = 0; (l_233 > 21); l_233 = safe_add_func_uint32_t_u_u(l_233, 8))
        { /* block id: 87 */
            float l_248 = 0x7.19F950p-76;
            float *l_247 = &l_248;
            int32_t l_272 = 0x3828B4F0;
            int32_t *l_282 = (void*)0;
            int32_t *l_283 = &l_272;
            float ***l_290 = &l_266;
            int32_t *l_305 = &l_296;
            int32_t l_341 = 0x6AB12BAF;
            l_249 = ((l_243 , p_80) , ((__builtin_ffsll(l_243) , l_233) > (!((*p_79) > ((((__builtin_ctzl((safe_add_func_int32_t_s_s(func_97(p_80, l_247, l_233), 1U))) < 0x0.8p+1) , p_80) == l_233) , (*p_79))))));
            if (__builtin_ctz(l_243))
            { /* block id: 89 */
                int32_t *l_250 = &l_249;
                (*l_250) = (0xE843 != p_80);
            }
            else
            { /* block id: 91 */
                uint32_t l_251 = 1U;
                float * const *l_269 = &l_267;
                uint32_t l_270 = 0x172B58A0;
                float *l_271 = &l_248;
                int16_t l_277 = 0x798B;
                int32_t *l_279 = &l_249;
                int32_t **l_278 = &l_279;
                l_272 = ((((l_251 <= 0x6058) & ((safe_mod_func_uint16_t_u_u(((l_251 , (((safe_lshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((safe_add_func_int16_t_s_s(func_97((safe_add_func_int16_t_s_s((4294967286U | (((__builtin_clzll(p_80) | (safe_sub_func_uint16_t_u_u(l_264, ((~((l_266 == l_269) , l_233)) > l_264)))) || p_80) > 65528U)), l_270)), l_271, p_80), p_80)), 7)), p_80)) && 0x7A8C1E0F) == (-2))) , p_80), l_243)) > l_233)) & 0xFBB9B6F4) , (-1));
                (*l_278) = func_81((p_80 > (l_233 & (safe_add_func_uint32_t_u_u((p_80 || (((safe_sub_func_uint16_t_u_u(0x23FB, l_277)) , p_80) > 7U)), p_80)))), p_80);
                /* statement id: 93 */
                assert (l_279 == 0);
            }
            (*l_283) = ((l_243 == l_249) && ((safe_sub_func_int16_t_s_s(p_80, l_233)) || l_272));
            for (l_264 = 0; (l_264 > 54); l_264 = safe_add_func_int32_t_s_s(l_264, 1))
            { /* block id: 98 */
                uint16_t l_295 = 65535U;
                float *l_298 = &l_248;
                int32_t l_304 = 0xB025D6F0;
                float ***l_364 = &l_266;
                l_296 = ((6 == (safe_rshift_func_int16_t_s_s((safe_add_func_uint32_t_u_u((p_80 , l_264), ((p_80 >= ((void*)0 == l_290)) ^ l_233))), ((safe_lshift_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_u(0, 1)) || l_233), p_80)) , l_295)))) > 1U);
                if (((p_80 , (void*)0) == ((*l_283) , p_79)))
                { /* block id: 100 */
                    int32_t l_297 = 0xEAF8C538;
                    int32_t **l_299 = &l_282;
                    if (((l_297 < ((((((func_97((*l_283), l_298, p_80) & ((((l_299 != (void*)0) , l_295) & (safe_rshift_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(func_97(p_80, (**l_290), l_243), p_80)), p_80))) < (*l_283))) > 0x8B5351F7) , 0U) , p_80) , p_80) || 0xC729903A)) | (-1)))
                    { /* block id: 101 */
                        l_304 = l_295;
                        (*l_299) = l_305;
                        /* statement id: 103 */
                        assert (l_282 == &l_296);
                    }
                    else
                    { /* block id: 104 */
                        uint16_t l_311 = 0x3A82;
                        (*l_299) = &l_304;
                        /* statement id: 105 */
                        assert (l_282 == &l_304);
                        if (p_80)
                            continue;
                        //assert (l_282 == dangling);
                        (*l_305) = ((~(safe_sub_func_uint32_t_u_u((*l_282), ((safe_add_func_int32_t_s_s(l_311, (((safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s(l_311, (func_86(p_78) && (safe_unary_minus_func_int16_t_s(((((0U < 0x396C) , (((((safe_add_func_int32_t_s_s(((safe_mod_func_uint32_t_u_u((p_80 > p_80), p_80)) != l_249), p_80)) < p_80) && p_80) != (-1)) || l_295)) ^ p_80) , p_80)))))), p_80)) ^ p_80) || p_80))) , l_295)))) == l_296);
                        if (p_80)
                            continue;
                        //assert (l_282 == dangling);
                    }
                    /* facts after branching */
                    assert (l_282 == &l_304 || l_282 == &l_296);
                    l_321 = (*l_299);
                    /* statement id: 110 */
                    assert (l_321 == &l_304 || l_321 == &l_296);
                    (*l_283) = (*l_305);
                    return l_304;
                }
                else
                { /* block id: 113 */
                    int32_t **l_322 = &l_321;
                    float ***l_344 = (void*)0;
                    const float ***l_366 = (void*)0;
                    const float ****l_365 = &l_366;
                    (*l_322) = &l_272;
                    /* statement id: 114 */
                    assert (l_321 == &l_272);
                    if (p_80)
                    { /* block id: 115 */
                        uint32_t l_343 = 0x957DEBA7;
                        (*l_322) = func_81(((p_80 , (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((*l_305), (*l_321))), (-1)))) | ((*l_283) < (((((safe_rshift_func_int16_t_s_s((__builtin_popcount((safe_rshift_func_uint16_t_u_s(((((((void*)0 == l_322) > (safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((((safe_add_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f(((0x0.6p+1 >= 0x3.Bp-1) > (*p_79)), 0x0.0p+1)), (*l_321))), 0x1.Ep+1)) , l_341) , (*l_305)), l_342)), 1))) && 0xE968) || p_80) == 1U), l_304))) , p_80), 5)) & p_80) , p_80) , (*l_321)) , (*l_321)))), l_343);
                        /* statement id: 116 */
                        assert (l_321 == 0);
                    }
                    else
                    { /* block id: 117 */
                        float ** const *l_346 = (void*)0;
                        float ** const **l_345 = &l_346;
                        int32_t l_363 = (-1);
                        (*l_345) = l_344;
                        (*l_305) = (safe_lshift_func_int16_t_s_u(((((safe_sub_func_int32_t_s_s(((*p_79) , (-5)), (((safe_mod_func_uint16_t_u_u(((safe_sub_func_uint32_t_u_u(((*l_321) <= ((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s(p_80, (**l_322))), ((((*p_79) == ((safe_add_func_float_f_f(((void*)0 != l_290), (l_363 < (*p_79)))) > (*p_79))) , (**l_322)) & l_363))) != 0x6B526748)), l_233)) && 0xE243), 3)) > (-1)) == p_80))) && 1U) , l_364) != (*l_345)), l_363));
                    }
                    /* facts after branching */
                    assert (l_321 == &l_272 || l_321 == 0);
                    if ((*l_305))
                        continue;
                    (*l_365) = l_290;
                    /* statement id: 122 */
                    assert (l_366 == &l_266);
                }
                /* facts after branching */
                assert (l_321 == &l_272 || l_321 == 0);
            }
            /* facts after for loop */
            //assert (l_321 == &l_272 || l_321 == 0 || l_321 == &l_249 || l_321 == dangling);
            //assert (l_282 == dangling || l_282 == 0);
        }
        /* facts after for loop */
        //assert (l_321 == dangling || l_321 == 0 || l_321 == &l_249);
        return p_80;
    }
    else
    { /* block id: 127 */
        int32_t l_369 = 2;
        for (p_80 = 0; (p_80 == 21); p_80 = safe_add_func_int32_t_s_s(p_80, 1))
        { /* block id: 130 */
            return l_369;
        }
        if (l_342)
            goto lbl_370;
        for (l_369 = (-13); (l_369 >= 13); l_369 = safe_add_func_uint32_t_u_u(l_369, 1))
        { /* block id: 136 */
            int32_t *l_375 = &l_296;
            for (l_342 = 0; (l_342 >= 46); l_342 = safe_add_func_int32_t_s_s(l_342, 1))
            { /* block id: 139 */
                l_375 = l_375;
            }
            if (p_80)
                break;
            if (l_296)
                goto lbl_370;
            (*l_375) = l_233;
        }
    }
    return l_342;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_81(int32_t  p_82, uint32_t  p_83)
{ /* block id: 79 */
    const int32_t l_203 = (-10);
    int32_t l_206 = (-1);
    int32_t *l_205 = &l_206;
    int32_t **l_204 = &l_205;
    int32_t l_214 = 0xE044C027;
    float l_218 = 0xC.2B8A50p-23;
    float *l_217 = &l_218;
    float **l_216 = &l_217;
    float ***l_215 = &l_216;
    float *l_219 = &l_218;
    float *l_220 = &l_218;
    float *l_221 = &l_218;
    float *l_222 = &l_218;
    float *l_223 = &l_218;
    float *l_224 = &l_218;
    float *l_225 = &l_218;
    float *l_226 = (void*)0;
    (*l_217) = ((~((p_83 , (safe_add_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(1U, (~((safe_sub_func_int16_t_s_s(l_203, (0x59415C78 && p_83))) , ((l_204 != ((((((safe_sub_func_int16_t_s_s((**l_204), (safe_add_func_int32_t_s_s(p_83, (safe_rshift_func_int16_t_s_s(((~((**l_204) != p_82)) || (*l_205)), l_214)))))) , l_215) == &l_216) <= (-0x9.6p+1)) , (-3)) , &l_205)) <= 0x2836))))), 13)) >= p_82), p_82))) == (*l_205))) , 0x1.Ep-1);
    return l_226;
    /* statement id: 81 */
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_86(float * p_87)
{ /* block id: 49 */
    int32_t l_88 = 0xFFC8BAB2;
    float l_167 = 0x0.9p+1;
    float *l_166 = &l_167;
    float ** const l_165 = &l_166;
    for (l_88 = (-27); (l_88 <= (-16)); l_88 = safe_add_func_uint16_t_u_u(l_88, 1))
    { /* block id: 52 */
        const float l_101 = 0x0.Cp+1;
        const int32_t l_102 = 0xD295891F;
        float **l_189 = (void*)0;
        float ***l_188 = &l_189;
        int32_t l_191 = 0xEB460E39;
        int32_t *l_190 = &l_191;
        (*l_188) = func_91(func_97(l_88, p_87, l_102), (((void*)0 == p_87) ^ (p_87 == p_87)), (l_88 && l_88), l_88, l_165);
        /* statement id: 75 */
        assert (l_189 == &l_166);
        (*l_190) = func_97(l_88, p_87, ((l_102 ^ __builtin_clz(l_102)) >= l_88));
    }
    return l_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float ** const  func_91(uint32_t  p_92, int16_t  p_93, int16_t  p_94, float  p_95, float ** const  p_96)
{ /* block id: 66 */
    int32_t l_169 = 0xD9C3D7FA;
    int32_t *l_168 = &l_169;
    int32_t **l_170 = (void*)0;
    int32_t *l_171 = &l_169;
    uint32_t l_172 = 0x0451B912;
    const int32_t l_177 = 0xA256EE45;
    int32_t **l_185 = &l_171;
    float *l_187 = (void*)0;
    float ** const l_186 = &l_187;
    l_168 = l_168;
    if (((((1 <= p_94) , l_171) != &l_169) < (__builtin_ctzll(p_94) == l_172)))
    { /* block id: 68 */
        float **l_175 = (void*)0;
        float ***l_174 = &l_175;
        float ****l_173 = &l_174;
        (*l_173) = &p_96;
        /* statement id: 69 */
        assert (l_174 == &p_96);
    }
    else
    { /* block id: 70 */
        int32_t l_176 = 0xA4F7F709;
        float l_179 = 0x3.A0364Bp-88;
        float *l_178 = &l_179;
        uint32_t l_184 = 4294967288U;
        (*l_178) = (l_176 < func_97(l_177, l_178, (((safe_lshift_func_uint16_t_u_s((0xF68907D7 & (0 < __builtin_bswap32(((((func_97((((((((((safe_add_func_int32_t_s_s(func_97(p_92, (*p_96), p_92), (*l_168))) & p_94) < 1U) & p_94) , (*l_168)) > 0xA37D) | l_176) && p_93) != p_93), l_168, l_176) != 3U) , p_92) > p_93) & (*l_171))))), l_184)) ^ p_94) , (*l_168))));
    }
    (*l_185) = &l_169;
    return p_96;
    /* statement id: 74 */
    //assert (func_91_rv == &l_166);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_97(const int16_t  p_98, float * p_99, const uint16_t  p_100)
{ /* block id: 53 */
    int32_t l_121 = 0xA5B3E5B6;
    const float l_124 = 0xF.5DFDCAp-73;
    const float * const l_123 = &l_124;
    const float * const *l_122 = &l_123;
    float l_126 = 0x0.7p-1;
    float *l_125 = &l_126;
    int32_t *l_152 = &l_121;
    (*l_152) = (!(__builtin_popcountl(p_100) > ((0x0DD2 & (!((((0x0.EEACC2p-51 != 0x5.7BC7A9p-55) != (((-6) ^ (safe_rshift_func_uint16_t_u_u(0x386F, 3))) , (func_109((safe_unary_minus_func_uint16_t_u((safe_sub_func_uint32_t_u_u(((safe_sub_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_s(l_121, 5)) ^ (((p_98 | p_100) < l_121) , 0)), 0xF703B84D)) >= l_121), 1U)))), l_122, l_121, l_125) < (-0x1.9p-1)))) > l_121) , p_98))) != 9)));
    (*l_125) = ((safe_sub_func_float_f_f(((*l_152) != ((((p_100 == p_100) , ((safe_sub_func_float_f_f(0x8.E5439Cp+38, (safe_sub_func_float_f_f((*l_152), ((((safe_lshift_func_int16_t_s_u((((safe_sub_func_uint16_t_u_u(p_98, (((*l_152) , ((((safe_lshift_func_uint16_t_u_u(((*l_152) , __builtin_parity(((p_100 , p_100) == p_98))), (*l_152))) || p_98) >= (*l_152)) || (*l_152))) < 0xE135CA44))) < 0xF607) & (*l_152)), p_100)) , p_99) != p_99) != (*l_152)))))) == (*l_152))) > (*l_152)) >= (*l_152))), (*l_152))) , (*l_152));
    return p_98;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_109(int16_t  p_110, const float * const * p_111, int32_t  p_112, float * p_113)
{ /* block id: 54 */
    int32_t l_127 = 0xCB9B5B59;
    uint32_t l_141 = 0xC4DA8BF3;
    const int32_t l_145 = (-1);
    const int32_t *l_144 = &l_145;
    uint32_t l_151 = 0x446B92DD;
    if ((((*p_111) == (*p_111)) , l_127))
    { /* block id: 55 */
        int32_t l_136 = 0;
        int32_t *l_142 = (void*)0;
        int32_t *l_143 = &l_136;
        (*l_143) = (safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s(__builtin_ffs(p_110), p_110)), ((((p_110 , (((safe_lshift_func_uint16_t_u_u(p_110, 5)) & (safe_mod_func_uint32_t_u_u(((l_136 | (((l_136 != l_136) , (safe_lshift_func_int16_t_s_s((safe_sub_func_int32_t_s_s(((p_112 <= l_127) , p_110), l_127)), l_127))) ^ p_110)) | l_136), l_136))) != p_112)) ^ l_141) && 1) <= l_141)));
    }
    else
    { /* block id: 57 */
        int32_t l_148 = (-1);
        int32_t *l_147 = &l_148;
        int32_t **l_146 = &l_147;
        (*l_146) = l_144;
        /* statement id: 58 */
        assert (l_147 == &l_145);
        return (**p_111);
    }
    p_112 = (safe_lshift_func_uint16_t_u_s(0U, l_151));
    return (*p_113);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 173
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 117
   depth: 2, occurrence: 29
   depth: 3, occurrence: 5
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 3
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1
   depth: 30, occurrence: 2

XXX total number of pointers: 163

XXX times a variable address is taken: 147
XXX times a pointer is dereferenced on RHS: 91
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 11
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 65
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 412

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 586
   level: 2, occurrence: 41
   level: 3, occurrence: 21
   level: 4, occurrence: 12
   level: 5, occurrence: 10
XXX number of pointers point to pointers: 91
XXX number of pointers point to scalars: 72
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.18

XXX times a non-volatile is read: 896
XXX times a non-volatile is write: 195
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 125
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 24
   depth: 2, occurrence: 21
   depth: 3, occurrence: 18
   depth: 4, occurrence: 20
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
********************* end of statistics **********************/

