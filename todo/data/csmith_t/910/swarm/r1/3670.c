/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3674483574
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 9;
   signed f1 : 26;
   signed f2 : 20;
   signed f3 : 16;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 0x54FDDD3FL;
static volatile int32_t g_27 = (-1L);/* VOLATILE GLOBAL g_27 */
static int32_t g_28 = 0x6D8D3833L;
static uint32_t g_103 = 0UL;
static int32_t g_108 = 0x27267125L;
static struct S0 g_131 = {3,-2906,135,4};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_24(void);
static struct S0  func_31(uint32_t  p_32);
static uint32_t  func_33(int32_t  p_34, int32_t  p_35, uint32_t  p_36);
static uint32_t  func_40(uint16_t  p_41);
static int32_t  func_44(uint8_t  p_45, int32_t  p_46, int32_t  p_47, uint32_t  p_48);
static int32_t  func_49(uint32_t  p_50, uint32_t  p_51);
static int16_t  func_57(int16_t  p_58);
static struct S0  func_65(int32_t  p_66, struct S0  p_67, uint8_t  p_68);
static struct S0  func_87(int32_t  p_88, int32_t  p_89, uint32_t  p_90, int32_t  p_91);
static int32_t  func_92(int16_t  p_93, uint16_t  p_94, uint32_t  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_28 g_27 g_103 g_131 g_108
 * writes: g_6 g_28 g_103 g_108 g_131 g_27
 */
static uint16_t  func_24(void)
{ /* block id: 36 */
    int32_t l_37 = 0x467356A0L;
    uint8_t l_357 = 0xC4L;
    for (g_6 = 22; (g_6 < 10); g_6 -= 8)
    { /* block id: 39 */
        uint32_t l_352 = 0x5F3C6F65L;
        struct S0 l_356 = {14,4889,746,184};
        for (g_28 = (-15); (g_28 != (-15)); g_28 += 1)
        { /* block id: 42 */
            uint16_t l_353 = 7UL;
            int32_t l_354 = 1L;
            l_356 = func_31(func_33(g_27, (g_6 | ((l_37 , ((((uint32_t)(((((((0x39200279L <= (func_40((g_28 | 0xA9C5L)) & ((uint16_t)((!((int16_t)(-(int16_t)(((g_6 ^ (0xB50818E7L | g_6)) ^ g_28) , 0L)) % (int16_t)l_37)) == (-3L)) - (uint16_t)l_352))) & 0x8970AAFFL) <= g_6) < l_37) , l_353) == l_352) || (-10L)) / (uint32_t)l_352) | l_354) , g_131.f2)) >= g_6)), g_6));
        }
    }
    return l_357;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_31(uint32_t  p_32)
{ /* block id: 166 */
    struct S0 l_355 = {19,-7678,927,138};
    return l_355;
}


/* ------------------------------------------ */
/* 
 * reads : g_103 g_131.f3 g_131.f0
 * writes: g_131.f0 g_27
 */
static uint32_t  func_33(int32_t  p_34, int32_t  p_35, uint32_t  p_36)
{ /* block id: 162 */
    g_131.f0 = g_103;
    g_27 = g_131.f3;
    return g_131.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_28 g_103 g_131 g_108
 * writes: g_103 g_108 g_131
 */
static uint32_t  func_40(uint16_t  p_41)
{ /* block id: 43 */
    uint32_t l_61 = 0xAF7CC73EL;
    int32_t l_327 = 0x49860C98L;
    for (p_41 = 0; (p_41 > 26); ++p_41)
    { /* block id: 46 */
        uint16_t l_56 = 0x6D99L;
        l_327 = func_44(g_6, func_49(((__builtin_parityll(g_6) , ((uint16_t)g_6 >> (uint16_t)15)) , ((uint16_t)l_56 % (uint16_t)func_57(((uint16_t)65535UL + (uint16_t)(l_61 , (((__builtin_ffsl(g_6) & g_6) , g_28) || g_6)))))), l_56), g_6, l_56);
    }
    for (l_61 = 0; (l_61 < 4); l_61 += 1)
    { /* block id: 157 */
        l_327 = ((((0x0E99DC05L <= ((uint16_t)(__builtin_clz(((int16_t)((((((0x8138L > ((int16_t)__builtin_ctz(p_41) << (int16_t)6)) | l_61) && p_41) , g_103) , g_131.f0) && ((uint16_t)((uint16_t)g_103 << (uint16_t)1) >> (uint16_t)10)) + (int16_t)0x7ADAL)) && 0L) % (uint16_t)g_131.f2)) && g_131.f0) || p_41) | g_131.f3);
    }
    l_327 = (((int16_t)l_61 + (int16_t)(((int16_t)g_28 >> (int16_t)8) > (func_57(g_6) ^ __builtin_popcount(p_41)))) <= ((((uint16_t)l_327 % (uint16_t)func_49(g_6, p_41)) && g_131.f3) != g_28));
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads : g_131
 * writes:
 */
static int32_t  func_44(uint8_t  p_45, int32_t  p_46, int32_t  p_47, uint32_t  p_48)
{ /* block id: 150 */
    struct S0 l_326 = {-4,-1811,868,-77};
    l_326 = g_131;
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_28 g_103 g_131 g_108
 * writes: g_103 g_108 g_131
 */
static int32_t  func_49(uint32_t  p_50, uint32_t  p_51)
{ /* block id: 49 */
    int16_t l_63 = 6L;
    int32_t l_64 = 0L;
    struct S0 l_69 = {21,-3741,-816,-197};
    int32_t l_86 = 0x06F8A133L;
    uint32_t l_315 = 0UL;
    l_64 = l_63;
    l_69 = func_65(l_63, l_69, (((int32_t)(((uint32_t)(((int32_t)((uint32_t)func_57(l_64) - (uint32_t)((int32_t)(p_51 , p_50) % (int32_t)((uint32_t)5UL / (uint32_t)(((uint32_t)((uint16_t)g_6 * (uint16_t)(((g_6 || (-1L)) , l_86) | 0xDFF937B1L)) + (uint32_t)p_50) , g_28)))) + (int32_t)7UL) ^ p_50) - (uint32_t)p_50) > g_6) - (int32_t)p_51) | l_69.f0));
    g_131.f0 = ((((l_315 && ((int16_t)func_92(l_63, p_50, g_131.f1) / (int16_t)g_131.f1)) && 0x3A44L) >= (-10L)) > ((int16_t)0x76B3L / (int16_t)(-8L)));
    l_69.f0 = ((((!(!l_69.f2)) != (((uint32_t)p_51 + (uint32_t)0xFB8EA656L) ^ __builtin_ctzl(((uint16_t)__builtin_popcountl(g_6) >> (uint16_t)6)))) || (func_57(l_315) ^ (0xC4E463A3L || g_6))) , 0x97DFDE01L);
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_57(int16_t  p_58)
{ /* block id: 47 */
    int32_t l_62 = 0x24C6E12CL;
    return l_62;
}


/* ------------------------------------------ */
/* 
 * reads : g_28 g_6 g_103 g_131 g_108
 * writes: g_103 g_108 g_131
 */
static struct S0  func_65(int32_t  p_66, struct S0  p_67, uint8_t  p_68)
{ /* block id: 51 */
    int32_t l_98 = (-10L);
    p_67 = func_87(func_92(g_28, ((((int16_t)l_98 >> (int16_t)((-1L) != func_57(g_6))) < ((g_28 || 65534UL) > (l_98 & 0xD42FL))) , 0UL), p_67.f1), p_67.f1, l_98, g_6);
    for (g_103 = 0; (g_103 == 8); g_103 += 4)
    { /* block id: 142 */
        int32_t l_314 = 8L;
        l_314 = __builtin_clz(p_66);
    }
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads : g_28 g_6 g_103 g_131 g_108
 * writes: g_103 g_108 g_131
 */
static struct S0  func_87(int32_t  p_88, int32_t  p_89, uint32_t  p_90, int32_t  p_91)
{ /* block id: 55 */
    int32_t l_104 = 4L;
    uint16_t l_110 = 0UL;
    struct S0 l_142 = {13,423,834,-142};
    int32_t l_151 = (-1L);
    uint32_t l_259 = 0xA46BAF6DL;
    uint32_t l_274 = 18446744073709551609UL;
    if (l_104)
    { /* block id: 56 */
        int16_t l_105 = 0L;
        g_108 = __builtin_popcount(((-4L) && func_57((func_57(l_105) & ((int16_t)func_57(g_28) + (int16_t)func_92(__builtin_clzll(p_90), __builtin_ffs(g_6), l_104))))));
        g_108 = g_103;
    }
    else
    { /* block id: 59 */
        uint8_t l_109 = 5UL;
        p_91 = (p_89 || (l_109 || 0x6B4EL));
    }
    if ((l_110 == 0x6341L))
    { /* block id: 62 */
        int16_t l_111 = (-1L);
        uint8_t l_119 = 0x78L;
        uint32_t l_152 = 18446744073709551611UL;
        int32_t l_181 = (-6L);
        struct S0 l_207 = {14,7900,-415,248};
        int32_t l_273 = 0x9CA2A995L;
        struct S0 l_310 = {0,1225,707,-234};
        if ((l_111 || p_91))
        { /* block id: 63 */
            uint16_t l_114 = 5UL;
            for (g_103 = 0; (g_103 > 45); g_103 += 8)
            { /* block id: 66 */
                l_114 = 0L;
            }
        }
        else
        { /* block id: 69 */
            uint32_t l_132 = 18446744073709551614UL;
            int32_t l_209 = (-10L);
            struct S0 l_215 = {18,1087,-206,-36};
            if ((g_103 , ((((int16_t)func_57(((int16_t)l_119 * (int16_t)(((((uint16_t)((int16_t)(((uint16_t)(__builtin_bswap32(((g_28 & (((l_111 , __builtin_ctzll((~(((uint32_t)g_103 / (uint32_t)(g_103 & (g_28 <= ((uint16_t)g_6 % (uint16_t)65535UL)))) , 0xAE1B8E03L)))) , g_131) , g_103)) & 1L)) , p_89) << (uint16_t)p_91) , g_131.f1) << (int16_t)0) >> (uint16_t)l_132) , l_132) , 0xC5B336EBL) , l_111))) % (int16_t)l_132) | l_111) == 0x474D9FADL)))
            { /* block id: 70 */
                uint16_t l_165 = 0x5356L;
                struct S0 l_182 = {-7,-5959,-919,66};
                uint8_t l_186 = 1UL;
                uint32_t l_208 = 0x4C16A462L;
                p_91 = (__builtin_parityl((((uint16_t)(!(((uint16_t)((g_28 != ((uint16_t)g_131.f1 % (uint16_t)g_108)) ^ ((int32_t)g_28 % (int32_t)p_91)) * (uint16_t)g_131.f1) == (p_91 , (((l_142 , (((int16_t)((uint32_t)((uint16_t)((int16_t)0xDCE6L + (int16_t)l_151) >> (uint16_t)p_90) / (uint32_t)l_142.f1) + (int16_t)0x8A91L) | l_152)) , 0L) <= g_28)))) / (uint16_t)p_88) != 0x4CEB9145L)) != g_131.f3);
                if ((p_91 , (~((p_91 || 0x8C9B47AFL) ^ func_57((((int16_t)(3L | p_91) << (int16_t)(l_104 != 65527UL)) == (((((~(l_142.f1 || p_90)) ^ l_132) && g_131.f1) & p_90) && 0x478149C9L)))))))
                { /* block id: 72 */
                    int32_t l_166 = 0xFA8D4CD4L;
                    struct S0 l_169 = {-1,-5331,-380,32};
                    p_89 = ((uint16_t)(g_108 != __builtin_ctzl((__builtin_clzl(p_88) || l_142.f2))) << (uint16_t)(g_131.f0 || ((((int16_t)p_90 * (int16_t)func_92((((int16_t)(((int16_t)func_92(l_165, l_152, g_131.f1) << (int16_t)g_28) , l_132) >> (int16_t)g_131.f1) & g_131.f1), g_131.f3, p_89)) >= l_166) , p_91)));
                    for (g_103 = 0; (g_103 == 18); g_103 += 4)
                    { /* block id: 76 */
                        struct S0 l_170 = {-3,7206,748,157};
                        if (p_89)
                            break;
                        g_131 = l_142;
                        l_170 = l_169;
                    }
                    g_108 = l_142.f1;
                    l_181 = ((uint16_t)((((uint16_t)l_165 >> (uint16_t)__builtin_bswap64(((uint16_t)0xAA10L * (uint16_t)p_89))) && l_119) & 65527UL) - (uint16_t)(!((uint16_t)(l_119 , (~g_131.f1)) << (uint16_t)((l_165 | g_131.f3) | 1L))));
                }
                else
                { /* block id: 83 */
                    int32_t l_185 = (-1L);
                    uint8_t l_201 = 0x4AL;
                    l_181 = p_91;
                    l_182 = l_142;
                    if ((l_185 ^ (l_186 > g_108)))
                    { /* block id: 86 */
                        int32_t l_198 = 0xCA9903D9L;
                        struct S0 l_206 = {21,1718,660,48};
                        l_198 = ((int32_t)((-(int32_t)((uint32_t)p_89 + (uint32_t)g_103)) & ((uint16_t)l_119 >> (uint16_t)13)) - (int32_t)((((uint16_t)((uint32_t)(func_57(l_185) && __builtin_ctzl(p_89)) - (uint32_t)l_198) - (uint16_t)(l_182.f0 == g_28)) > p_89) ^ l_185));
                        l_181 = (func_92(g_131.f0, __builtin_bswap64((func_57(p_90) , ((-3L) & ((int16_t)((((l_201 < l_182.f2) >= ((uint16_t)p_89 << (uint16_t)l_119)) ^ ((((int16_t)g_131.f0 * (int16_t)p_91) ^ 0xE027L) , p_88)) != 4294967295UL) + (int16_t)l_132)))), g_6) ^ (-2L));
                        l_207 = l_206;
                        l_209 = l_208;
                    }
                    else
                    { /* block id: 91 */
                        uint32_t l_214 = 1UL;
                        p_91 = (p_88 < l_209);
                        p_89 = (g_131.f1 && (g_28 && (7UL != p_91)));
                        l_182.f2 = ((int16_t)l_214 + (int16_t)g_6);
                        l_182 = l_215;
                    }
                    l_207.f0 = (((int16_t)g_6 << (int16_t)((l_181 || p_88) > ((1UL && 3UL) >= 0xFB4F793AL))) ^ ((int16_t)(g_28 , __builtin_parityll(l_185)) - (int16_t)1UL));
                }
            }
            else
            { /* block id: 99 */
                l_181 = g_6;
            }
            l_215 = l_207;
        }
        for (p_91 = (-20); (p_91 < 2); p_91 += 6)
        { /* block id: 106 */
            uint32_t l_251 = 4294967295UL;
            uint32_t l_308 = 0x63973B46L;
            int32_t l_309 = 0x9A88CA57L;
            for (p_90 = (-10); (p_90 <= 44); p_90 += 1)
            { /* block id: 109 */
                int32_t l_239 = 0x8FC4EB74L;
                struct S0 l_242 = {11,340,-224,-83};
                if (((((int16_t)(p_88 , p_90) % (int16_t)(-(int32_t)(((int16_t)(0xEFD3BFD2L < ((int32_t)((((int16_t)(-(uint16_t)(((int32_t)(((-(uint32_t)((uint16_t)l_239 % (uint16_t)(p_90 , ((int16_t)((l_242 , ((uint16_t)p_90 * (uint16_t)(0UL >= g_28))) , 1L) + (int16_t)0x5396L)))) ^ g_131.f1) || l_242.f0) + (int32_t)l_119) || 0x38E5L)) << (int16_t)1) | 0UL) ^ (-1L)) % (int32_t)1L)) << (int16_t)10) >= 0x801BL))) & p_89) > l_242.f0))
                { /* block id: 110 */
                    p_89 = (-1L);
                }
                else
                { /* block id: 112 */
                    int16_t l_260 = 0L;
                    if (((int32_t)(__builtin_ia32_crc32qi(((g_103 ^ ((((int16_t)0xB278L % (int16_t)l_207.f0) != ((int16_t)g_131.f2 / (int16_t)l_242.f1)) >= (l_251 || ((int16_t)(__builtin_ffsll(((1L || (((-(uint16_t)(((int16_t)(((uint16_t)l_251 * (uint16_t)g_28) == p_88) - (int16_t)p_91) & 0x3A11L)) > g_6) , l_259)) | p_91)) == g_131.f1) % (int16_t)65535UL)))) >= l_142.f2), l_260) ^ p_88) % (int32_t)p_88))
                    { /* block id: 113 */
                        int32_t l_265 = 0x7334A1C8L;
                        l_274 = ((((uint32_t)((uint16_t)((g_28 && l_260) < (l_265 , ((((((g_131.f1 || (((0x3D07L & (l_242.f2 == ((uint32_t)(g_131.f3 , (((((int16_t)0xDB80L / (int16_t)((-(uint32_t)(p_88 , l_273)) , p_88)) <= l_265) , l_251) ^ 9UL)) / (uint32_t)(-2L)))) <= 0x29AA79E0L) != 0x51AC87C8L)) | l_110) > 0UL) || g_108) & p_88) | (-1L)))) << (uint16_t)8) % (uint32_t)l_260) ^ l_260) > g_131.f0);
                        return l_207;
                    }
                    else
                    { /* block id: 116 */
                        l_142.f0 = 1L;
                    }
                    if (l_260)
                    { /* block id: 119 */
                        struct S0 l_279 = {-3,-7532,-856,155};
                        l_142.f0 = (~(0x941C1BC3L < g_28));
                        p_89 = (l_260 , l_151);
                        l_242.f2 = ((uint16_t)((p_89 && 0x8A85L) == (((-(int16_t)(l_279 , (((int16_t)g_6 << (int16_t)0) | (g_131.f0 != (0x7DC5L ^ 0x6BDEL))))) || p_89) > (l_251 == g_108))) % (uint16_t)g_103);
                    }
                    else
                    { /* block id: 123 */
                        if (p_88)
                            break;
                        p_89 = p_90;
                    }
                }
                if (l_274)
                    continue;
                l_207.f0 = l_242.f1;
            }
            g_108 = ((int32_t)(((l_104 , ((((int16_t)g_131.f2 >> (int16_t)((l_142.f2 != ((int16_t)((int16_t)((uint16_t)g_131.f2 / (uint16_t)((uint16_t)l_207.f0 * (uint16_t)((int16_t)l_251 << (int16_t)((int16_t)__builtin_clz(((((uint32_t)((int16_t)(__builtin_parityl(l_151) , func_92(((((int32_t)((int16_t)l_142.f2 >> (int16_t)4) + (int32_t)l_273) , l_308) >= g_6), p_91, p_91)) % (int16_t)p_91) + (uint32_t)g_131.f3) , l_142.f2) ^ g_131.f2)) * (int16_t)l_251)))) - (int16_t)l_309) + (int16_t)0xB5AEL)) , p_88)) , l_310) , p_91)) , l_308) && g_131.f3) + (int32_t)g_131.f2);
        }
    }
    else
    { /* block id: 133 */
        uint32_t l_311 = 4294967294UL;
        g_131.f2 = l_311;
    }
    l_142.f0 = l_142.f2;
    l_142 = l_142;
    return l_142;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_103
 */
static int32_t  func_92(int16_t  p_93, uint16_t  p_94, uint32_t  p_95)
{ /* block id: 52 */
    uint16_t l_101 = 0x23F1L;
    g_103 = __builtin_clz(((int16_t)func_57(l_101) * (int16_t)(-(uint32_t)0x71C63CC5L)));
    return l_101;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_24();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_27, "g_27", print_hash_value);
    transparent_crc(g_28, "g_28", print_hash_value);
    transparent_crc(g_103, "g_103", print_hash_value);
    transparent_crc(g_108, "g_108", print_hash_value);
    transparent_crc(g_131.f0, "g_131.f0", print_hash_value);
    transparent_crc(g_131.f1, "g_131.f1", print_hash_value);
    transparent_crc(g_131.f2, "g_131.f2", print_hash_value);
    transparent_crc(g_131.f3, "g_131.f3", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 52
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX full-bitfields structs in the program: 15
breakdown:
   indirect level: 0, occurrence: 15
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 18
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 60

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 340
XXX times a non-volatile is write: 57
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 7
XXX percentage of non-volatile access: 99.5

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 81
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 10
   depth: 2, occurrence: 6
   depth: 3, occurrence: 7
   depth: 4, occurrence: 11
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 17.6
XXX percentage an existing variable is used: 82.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

