/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      530672248
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   int8_t  f4;
   uint8_t  f5;
   uint16_t  f6;
};

struct S1 {
   signed f0 : 23;
   signed f1 : 2;
   unsigned f2 : 26;
   uint32_t  f3;
   signed f4 : 7;
   signed f5 : 22;
   signed f6 : 10;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_29(void);
static struct S1  func_32(uint32_t  p_33, int16_t  p_34);
inline static int16_t  func_35(uint8_t  p_36, struct S0  p_37, int16_t  p_38, struct S0  p_39);
inline static struct S0  func_40(struct S0  p_41, int32_t  p_42, uint32_t  p_43);
static struct S0  func_44(int8_t  p_45, float  p_46);
static int16_t  func_47(uint8_t  p_48, uint32_t  p_49, float  p_50, uint8_t  p_51);
static float  func_53(uint32_t  p_54);
inline static int8_t  func_60(struct S0  p_61, struct S1  p_62, float  p_63);
inline static struct S1  func_65(float  p_66, uint16_t  p_67, struct S1  p_68, int32_t  p_69, uint8_t  p_70);
static struct S1  func_76(float  p_77, uint16_t  p_78, struct S0  p_79, struct S0  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_29(void)
{ /* block id: 36 */
    int32_t l_30 = 0xDF11BBB4;
    int32_t l_31 = 0xDFE936BE;
    int16_t l_52 = 1;
    int32_t l_280 = 0x7C05EB80;
    int32_t l_299 = 0x57D3ECDB;
    int32_t l_300 = 0x6440DBB3;
    struct S0 l_312 = {-5,0xDDB6,0xCF235841,-9,-8,0x07,65533U};
    struct S1 l_325 = {-2806,0,7069,0U,-5,-820,10};
    int32_t l_331 = 9;
    l_31 = (l_30 = __builtin_clzll(l_30));
    l_31 = l_30;
    l_325 = func_32(l_30, func_35(l_31, func_40(func_44((((l_300 = (func_47(l_52, l_52, func_53(l_30), (l_280 = l_30)) & ((((int32_t)((l_299 = (l_31 | 0x1C)) | l_31) % (int32_t)0xD162C63C) < l_52) == (-1)))) < 0xD9) | l_31), l_30), l_52, l_31), l_52, l_312));
    for (l_30 = 0; (l_30 > (-13)); l_30--)
    { /* block id: 199 */
        int16_t l_328 = 0xFD3B;
        int32_t l_329 = 0x3A1D2776;
        int32_t l_330 = 0xCE2DD530;
        int32_t l_332 = 1;
        int32_t l_333 = 2;
        int32_t l_334 = 0x757676AE;
        uint32_t l_335 = 4294967294U;
        struct S0 l_345 = {0x055DAE04,0x4801,0xE7C90FF4,0x18CA9857,0x78,0U,0x4BA8};
        l_335--;
        l_299 |= ((l_312.f0 && (l_325.f2 && ((int8_t)0xB0 >> (int8_t)2))) ^ l_335);
        l_329 |= ((uint8_t)(func_35((l_330 = l_299), func_44(l_328, (((float)((((l_325.f1 = (((__builtin_ffs((l_325.f6 = l_332)) >= ((l_325.f4 >= l_335) == (-0x2.5p-1))) > l_52) <= ((!(((l_299 <= l_333) <= 0x1.2p-1) == l_332)) >= l_31))) >= 0x1.3E5D3Ap-92) >= 0x1.4DE86Ep-51) < l_312.f5) + (float)l_312.f0) > l_333)), l_334, l_345) < 0x80A36DBC) - (uint8_t)0x9A);
    }
    return l_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_32(uint32_t  p_33, int16_t  p_34)
{ /* block id: 194 */
    struct S1 l_324 = {-1102,1,1069,2U,5,-0,-6};
    return l_324;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_35(uint8_t  p_36, struct S0  p_37, int16_t  p_38, struct S0  p_39)
{ /* block id: 191 */
    uint8_t l_315 = 0xF0;
    int16_t l_316 = 0xF2C3;
    int32_t l_323 = 0x33572A64;
    l_323 = ((uint16_t)(l_315 && p_37.f5) - (uint16_t)(l_316 & ((int16_t)((0xF06E != ((uint16_t)((int32_t)(((p_39.f5 | (-1)) == l_316) || ((((-2) <= 4294967295U) & (-9)) != l_316)) - (int32_t)p_39.f3) >> (uint16_t)p_36)) >= l_316) << (int16_t)p_37.f6)));
    return l_315;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_40(struct S0  p_41, int32_t  p_42, uint32_t  p_43)
{ /* block id: 187 */
    int16_t l_304 = 0x31C0;
    int32_t l_305 = (-1);
    l_305 ^= l_304;
    l_305 = (p_41.f6 == (((float)((p_42 > (!l_304)) < (p_41.f5 >= (p_41.f2 > (0x1.8p+1 >= ((float)((-(float)(0x9.A57001p-78 < func_47(p_42, l_305, l_304, p_42))) > l_304) + (float)l_304))))) - (float)l_304) >= p_43));
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_44(int8_t  p_45, float  p_46)
{ /* block id: 183 */
    int32_t l_301 = 0x7D87469C;
    int32_t l_302 = 0x9B7E9D35;
    struct S0 l_303 = {-7,2,3U,0xC3E8A82F,0xAF,0xEC,65535U};
    l_301 = (0x7212 || (__builtin_bswap64(l_301) | (l_302 = p_45)));
    return l_303;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_47(uint8_t  p_48, uint32_t  p_49, float  p_50, uint8_t  p_51)
{ /* block id: 174 */
    int8_t l_283 = (-1);
    int32_t l_284 = 0;
    int32_t l_287 = (-2);
    int32_t l_288 = 0xBDDC878D;
    int32_t l_296 = 0x167A7BE1;
    l_296 ^= (((0xC08B88E9 && ((int8_t)(l_284 = l_283) >> (int8_t)(((((int32_t)(-1) + (int32_t)p_48) || (l_287 = 4)) >= (((p_51++) | __builtin_ffsll(p_49)) & l_283)) | (!((uint8_t)((((int16_t)(l_283 ^ l_288) % (int16_t)p_48) ^ l_288) | l_283) + (uint8_t)p_48))))) && p_48) ^ l_283);
    l_296 = (0x8.DB0E18p-67 >= (l_288 == (l_287 > (l_287 < ((l_288 == (-0x1.Cp+1)) >= p_50)))));
    return l_296;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_53(uint32_t  p_54)
{ /* block id: 40 */
    int8_t l_55 = (-2);
    int32_t l_75 = 0x517D3E82;
    int32_t l_162 = 0xB3331872;
    struct S1 l_183 = {-292,-1,2360,0x3BB3813A,8,1239,31};
    uint32_t l_186 = 4294967295U;
    int16_t l_208 = 0xCD87;
    int32_t l_209 = 0xB25FE38C;
    int32_t l_211 = 0xD302FA1F;
    int32_t l_213 = 6;
    int32_t l_217 = 0xAC364A4C;
    int32_t l_220 = 0x09E64E21;
    int32_t l_222 = 0;
    int32_t l_224 = 7;
    int32_t l_225 = 0x9B9FB790;
    int32_t l_226 = (-9);
    int32_t l_228 = 2;
    int32_t l_230 = 0xA9CAEAAB;
    int32_t l_231 = 0x5FF72895;
    int32_t l_238 = 0x36123B1B;
    int32_t l_244 = 0xB1182683;
    int32_t l_245 = 0xDDE3D06C;
    int32_t l_246 = (-1);
    int32_t l_248 = 4;
    int32_t l_252 = (-7);
    int32_t l_253 = 0xDE5451DF;
    int32_t l_255 = 0x99A9337A;
    int32_t l_258 = (-6);
    int32_t l_259 = 0x99CE5FD4;
    int32_t l_260 = 0x911529E7;
    int32_t l_261 = 0xFF7CC213;
    int32_t l_262 = 0x2B63680A;
    int32_t l_263 = 0x3D69D35C;
    int32_t l_265 = (-1);
    int32_t l_266 = 0x1195C0E0;
    int32_t l_267 = (-1);
    int32_t l_271 = (-1);
    uint8_t l_273 = 3U;
    struct S0 l_278 = {0x2915EF4D,0xA387,0x65C97938,0x4D9622DC,0,1U,65526U};
    l_55 = (-6);
    for (p_54 = 0; (p_54 > 30); p_54 += 1)
    { /* block id: 44 */
        struct S0 l_64 = {0x1AB70486,-5,0x41147C03,0xD03D8E66,-1,0x83,0xDAB8};
        struct S0 l_81 = {0xFC42E2EE,-9,1U,0x70516A45,-5,0x0E,0xFB38};
        int32_t l_160 = (-1);
        int32_t l_161 = 1;
        struct S1 l_170 = {-1647,0,2377,0xD6B0DCD2,-3,-1714,18};
        int32_t l_210 = 0x2FCFE0A5;
        int32_t l_212 = 0xDCF2E069;
        int32_t l_214 = 6;
        int32_t l_215 = 9;
        int32_t l_216 = 0x562CACFC;
        int32_t l_218 = 0xE99366D9;
        int32_t l_219 = 1;
        int32_t l_221 = 0xB61917E9;
        int32_t l_223 = 1;
        int32_t l_227 = (-1);
        int32_t l_229 = 0xE0DFFA39;
        int32_t l_232 = 0xB3D72312;
        int32_t l_233 = 0xBD3BCB1E;
        int32_t l_234 = (-9);
        int32_t l_235 = 0x9CDFA422;
        int32_t l_236 = 0xE55FA1EA;
        int32_t l_237 = 1;
        int32_t l_239 = 1;
        int32_t l_240 = (-1);
        int32_t l_241 = 3;
        int32_t l_242 = 0x895242DE;
        int32_t l_243 = 0x699C2ED7;
        int32_t l_247 = 0x363F8675;
        int32_t l_249 = 0xF59C59D2;
        int32_t l_250 = 0xE093A50B;
        int32_t l_251 = 0x475412C3;
        int32_t l_254 = 0xDA0C8096;
        int8_t l_256 = 0x84;
        int32_t l_257 = 0xC735A513;
        int32_t l_264 = 0x153CC621;
        int32_t l_268 = 0x965C811C;
        int32_t l_269 = 0;
        int32_t l_270 = (-5);
        int32_t l_272 = 0;
        if (__builtin_parityll(((int32_t)(l_162 = ((p_54 == ((p_54 & (l_161 ^= (l_160 = func_60(l_64, func_65(p_54, ((uint8_t)p_54 % (uint8_t)((uint8_t)l_55 + (uint8_t)(l_75 &= l_55))), func_76(l_55, l_64.f6, l_64, l_81), p_54, l_64.f4), p_54)))) >= l_64.f3)) > p_54)) % (int32_t)l_64.f4)))
        { /* block id: 125 */
            l_162 = p_54;
            for (l_160 = 0; (l_160 == 21); l_160++)
            { /* block id: 129 */
                uint32_t l_167 = 0U;
                int32_t l_168 = 1;
                struct S0 l_169 = {-3,0xAD12,0U,0x125292E0,-3,0x9F,2U};
                l_75 ^= ((l_168 ^= (0U > l_167)) & ((l_161 |= 0xA597C7DC) > __builtin_parityll((l_162 = func_60(l_169, l_170, l_64.f2)))));
            }
        }
        else
        { /* block id: 135 */
            int16_t l_175 = (-10);
            struct S0 l_182 = {0,0xD4C5,4294967293U,-1,-4,0x58,1U};
            int32_t l_189 = 0x32E19209;
            l_170.f6 = ((float)(((float)(((l_175 <= (__builtin_parity(((p_54 == (((0xCC == p_54) && (((int8_t)((uint16_t)((uint32_t)p_54 % (uint32_t)p_54) % (uint16_t)func_60(l_182, l_183, l_182.f1)) - (int8_t)l_170.f6) || l_182.f5)) == (-8))) || l_183.f1)) > 0x4.92B934p+96)) > (-0x1.3p-1)) == (-0x1.Fp+1)) - (float)l_182.f1) != l_170.f1) + (float)l_64.f2);
            for (l_182.f4 = (-6); (l_182.f4 != 9); l_182.f4++)
            { /* block id: 139 */
                --l_186;
            }
            l_170.f1 = (((l_170.f0 = (p_54 <= (l_189 = (-9)))) == ((((uint16_t)(l_75 |= p_54) >> (uint16_t)13) || ((int32_t)((int16_t)((int16_t)(l_170.f6 = 1) + (int16_t)0x23F7) << (int16_t)p_54) - (int32_t)(0xD9 || ((int16_t)1 - (int16_t)p_54)))) ^ (-1))) && p_54);
            if (((uint16_t)(((l_189 = ((0x5457A2E9 | ((int8_t)__builtin_bswap64(p_54) + (int8_t)(l_170.f1 &= l_170.f0))) != l_182.f4)) | (l_183.f1 &= p_54)) <= l_170.f4) >> (uint16_t)0))
            { /* block id: 150 */
                struct S0 l_204 = {0xEC739D5C,-1,4294967291U,1,-4,0x64,5U};
                l_183.f5 ^= (l_170.f0 = (p_54 & p_54));
                l_64 = l_204;
            }
            else
            { /* block id: 154 */
                for (l_81.f6 = (-9); (l_81.f6 == 27); l_81.f6 += 9)
                { /* block id: 157 */
                    uint32_t l_207 = 4294967294U;
                    l_207 = p_54;
                    l_170.f4 &= p_54;
                }
            }
        }
        l_273--;
    }
    l_183.f0 = 8;
    for (l_259 = 0; (l_259 > (-25)); l_259 -= 6)
    { /* block id: 168 */
        struct S0 l_279 = {-8,1,0x3EE34DF5,0xDCF8AAB9,0x34,255U,65535U};
        l_279 = l_278;
        return l_279.f2;
    }
    return l_278.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_60(struct S0  p_61, struct S1  p_62, float  p_63)
{ /* block id: 52 */
    int32_t l_86 = (-9);
    struct S0 l_91 = {-1,-1,0x9AB2FCBA,1,0xE4,255U,65535U};
    uint16_t l_105 = 0xCF72;
    int32_t l_118 = 0x2D9A964D;
    uint32_t l_148 = 0U;
    struct S1 l_157 = {567,-0,1021,0xD851819C,0,-1628,17};
    struct S1 l_159 = {1904,0,8037,0x86692AA9,-2,1770,6};
    if (((uint8_t)l_86 << (uint8_t)7))
    { /* block id: 53 */
        uint32_t l_87 = 4294967286U;
        return l_87;
    }
    else
    { /* block id: 55 */
        int32_t l_88 = (-3);
        struct S1 l_90 = {-1828,-0,7343,4294967293U,-1,-1850,5};
        struct S0 l_92 = {-1,0x8BAA,0x0D6DD574,0xE9346F96,0xB3,3U,0U};
        int32_t l_117 = 9;
        l_88 = 0xB.33379Bp-11;
        if (l_88)
        { /* block id: 57 */
            struct S1 l_89 = {-2535,-1,8102,0x9E5B7364,-3,1256,-30};
            p_62 = (l_90 = l_89);
            l_90.f0 |= l_86;
            l_92 = l_91;
        }
        else
        { /* block id: 62 */
            float l_98 = (-0x10.8p+1);
            int32_t l_104 = 0x22977FD2;
            int32_t l_119 = 0xDB4E21E3;
            if ((p_62.f1 = ((uint16_t)(((uint16_t)(!(p_62.f4 != (((p_61.f4 |= l_90.f0) ^ 255U) ^ l_92.f0))) + (uint16_t)((uint16_t)(l_90.f4 &= p_62.f4) + (uint16_t)__builtin_ctz((l_119 = ((l_104 = (l_90.f5 = (l_118 &= (~((int32_t)((l_105--) <= (__builtin_bswap64(l_90.f1) ^ ((int32_t)p_62.f4 + (int32_t)((uint8_t)((uint16_t)(+((int8_t)l_117 << (int8_t)7)) >> (uint16_t)7) << (uint8_t)l_91.f1)))) % (int32_t)l_104))))) ^ 1U))))) <= l_91.f5) - (uint16_t)0xEC77)))
            { /* block id: 71 */
                struct S0 l_120 = {0x4DF77CBF,-8,0x9878E731,0x53E36E8D,0x33,0U,0xD72C};
                struct S0 l_130 = {0xA0BC11C5,1,0x00ABD0B1,8,0xE8,1U,0xE502};
                int32_t l_141 = 0x906447CF;
                l_120 = p_61;
                for (p_61.f2 = 13; (p_61.f2 >= 15); p_61.f2++)
                { /* block id: 75 */
                    uint32_t l_123 = 1U;
                    l_123++;
                    p_62.f0 &= 0;
                    for (l_104 = 8; (l_104 != (-9)); --l_104)
                    { /* block id: 80 */
                        p_62.f1 = 0x06077EAA;
                        l_118 = l_119;
                    }
                }
                l_119 |= 0xCFE75BA7;
                for (l_92.f3 = 0; (l_92.f3 <= (-16)); l_92.f3 -= 5)
                { /* block id: 88 */
                    int32_t l_137 = 0xF5B91466;
                    l_119 &= (p_62.f2 && l_120.f1);
                    l_120 = l_130;
                    if ((((((p_61.f6 != ((int16_t)0 >> (int16_t)9)) != p_62.f0) >= (p_62.f2 = ((int8_t)(((p_61.f1 = (((int32_t)(l_137 <= l_137) - (int32_t)l_92.f5) >= l_137)) ^ l_137) < ((int16_t)(l_119 = (l_137 != p_61.f6)) % (int16_t)l_137)) << (int8_t)0))) >= l_137) | l_137))
                    { /* block id: 94 */
                        uint32_t l_142 = 6U;
                        p_62.f5 ^= p_62.f4;
                        p_62.f1 = (!(l_130.f5 != (l_141 = 0)));
                        l_142 = p_61.f1;
                        if (l_130.f0)
                            continue;
                    }
                    else
                    { /* block id: 100 */
                        p_62 = func_76(p_61.f2, p_62.f0, l_92, l_91);
                        p_63 = 0xA.B6AFEBp-71;
                    }
                }
            }
            else
            { /* block id: 105 */
                int8_t l_146 = 0xA3;
                int32_t l_147 = 0xB2AD5794;
                for (l_92.f0 = 0; (l_92.f0 >= (-14)); l_92.f0--)
                { /* block id: 108 */
                    uint16_t l_145 = 0xC14C;
                    p_62 = l_90;
                    if (l_145)
                        break;
                    if (l_118)
                        break;
                }
                l_148++;
            }
        }
        p_62.f0 |= (l_91.f0 || ((int8_t)((int16_t)(p_61.f1 = p_62.f4) << (int16_t)10) - (int8_t)((((int8_t)6 - (int8_t)(((p_62.f2 > p_62.f2) & (p_62.f1 & p_61.f6)) > p_61.f0)) || l_117) | l_92.f1)));
    }
    l_159 = func_65((p_63 = l_105), p_61.f3, l_157, (~p_62.f2), p_61.f4);
    return p_61.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_65(float  p_66, uint16_t  p_67, struct S1  p_68, int32_t  p_69, uint8_t  p_70)
{ /* block id: 49 */
    struct S1 l_83 = {-740,-0,3089,9U,5,720,27};
    p_66 = (0xA.15B503p-81 > 0xF.FACDC9p+80);
    return l_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_76(float  p_77, uint16_t  p_78, struct S0  p_79, struct S0  p_80)
{ /* block id: 46 */
    struct S1 l_82 = {-1472,1,4138,4294967292U,-1,-422,15};
    p_79 = p_80;
    return l_82;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 129
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 10
breakdown:
   indirect level: 0, occurrence: 10
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 6
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 22
XXX times a single bitfield on RHS: 21

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 5, occurrence: 3
   depth: 7, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 228
XXX times a non-volatile is write: 99
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 79
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 11
   depth: 2, occurrence: 10
   depth: 3, occurrence: 11
   depth: 4, occurrence: 11
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 37.6
XXX percentage an existing variable is used: 62.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

