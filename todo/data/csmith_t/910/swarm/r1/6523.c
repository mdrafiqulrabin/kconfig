/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1987042068
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int16_t g_6 = (-8L);
static struct S0 g_95 = {1UL};
static uint8_t g_145 = 0x36L;
static float g_183 = (-0x1.1p-1);
static uint16_t g_194 = 0x54A0L;
static int16_t g_220 = 1L;
static struct S0 g_226 = {0x7D3DD64FL};
static int32_t g_238 = (-1L);
static int32_t g_242 = 0L;
static uint32_t g_269 = 0xAAD6875EL;


/* --- FORWARD DECLARATIONS --- */
static float  func_26(void);
inline static float  func_38(int16_t  p_39, uint8_t  p_40, uint16_t  p_41);
static struct S0  func_48(float  p_49);
inline static float  func_52(int32_t  p_53, float  p_54, uint32_t  p_55, int32_t  p_56);
static uint16_t  func_58(struct S0  p_59, uint16_t  p_60, struct S0  p_61, uint16_t  p_62, int32_t  p_63);
static struct S0  func_64(int32_t  p_65, uint32_t  p_66, float  p_67);
inline static uint64_t  func_68(struct S0  p_69);
inline static uint32_t  func_84(uint8_t  p_85, int16_t  p_86, int8_t  p_87, struct S0  p_88, uint32_t  p_89);
inline static struct S0  func_90(struct S0  p_91, float  p_92, uint32_t  p_93, struct S0  p_94);
inline static float  func_98(uint32_t  p_99, uint32_t  p_100, int32_t  p_101, uint32_t  p_102, uint8_t  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_95 g_145 g_194 g_220 g_242 g_226.f0 g_238 g_269 g_226
 * writes: g_6 g_95.f0 g_145 g_194 g_183 g_95 g_220 g_226 g_238 g_242
 */
static float  func_26(void)
{ /* block id: 36 */
    uint32_t l_45 = 0x93BA6AEDL;
    struct S0 l_295 = {2UL};
    for (g_6 = (-16); (g_6 != (-16)); g_6 = safe_add_func_int8_t_s_s(g_6, 5))
    { /* block id: 39 */
        uint32_t l_37 = 1UL;
        uint32_t l_42 = 0xA9BCA7B5L;
        int32_t l_294 = 0x7F8F1950L;
        l_294 = (safe_mul_func_float_f_f((((safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_sub_func_float_f_f(0x1.Cp+1, l_37)), (func_38(((l_42 == ((__builtin_parity(g_6) == g_6) >= (((safe_lshift_func_int16_t_s_u((g_6 != l_45), 13)) || ((safe_add_func_uint32_t_u_u(((func_48((safe_mul_func_float_f_f((((((g_6 , g_6) >= g_6) < g_6) & 0x14L) , g_6), g_6))) , 1UL) , g_95.f0), 7L)) < 0xE62397AFL)) < l_45))) ^ l_42), g_6, l_37) >= 0x1.971ECDp-54))), l_45)) == g_269) > l_45), 0xC.0E2667p+99));
        g_226 = l_295;
    }
    return g_226.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_145 g_194 g_95.f0 g_95 g_220 g_242 g_226.f0 g_238 g_269 g_226
 * writes: g_95.f0 g_220 g_226 g_238 g_242 g_183 g_145 g_194 g_95
 */
inline static float  func_38(int16_t  p_39, uint8_t  p_40, uint16_t  p_41)
{ /* block id: 100 */
    int16_t l_213 = (-7L);
    int32_t l_214 = 0x2102788AL;
    struct S0 l_270 = {8UL};
    int32_t l_276 = (-1L);
    struct S0 l_288 = {0x699BD09FL};
    int32_t l_291 = 0x1CF811F1L;
    int8_t l_292 = 0x33L;
    int8_t l_293 = (-1L);
    for (p_41 = (-19); (p_41 <= 16); p_41 = safe_add_func_uint32_t_u_u(p_41, 3))
    { /* block id: 103 */
        uint32_t l_215 = 4294967295UL;
        struct S0 l_216 = {9UL};
        float l_236 = 0x1.4BBEC0p-57;
        int32_t l_245 = (-1L);
        uint32_t l_277 = 0x97351A84L;
        if (((safe_lshift_func_int8_t_s_s((0xBCA0CB05L == p_39), (safe_unary_minus_func_uint32_t_u((safe_mul_func_int8_t_s_s((__builtin_clz((safe_sub_func_uint16_t_u_u(func_84((safe_mul_func_int8_t_s_s(((((safe_sub_func_int32_t_s_s((((((safe_mul_func_int16_t_s_s((__builtin_parity(__builtin_parityll(p_40)) ^ 0x82L), (g_6 , 3UL))) , (l_213 = 0x38BEL)) , 0xEE94D8E9L) < l_214) < g_145), p_41)) & 5L) , l_215) >= p_39), g_194)), p_39, l_214, l_216, p_40), g_194))) != g_6), (-6L))))))) | g_145))
        { /* block id: 105 */
            struct S0 l_219 = {0x58E107FDL};
            struct S0 l_225 = {4294967295UL};
            int32_t l_259 = (-1L);
            for (g_95.f0 = (-16); (g_95.f0 < 49); g_95.f0 = safe_add_func_uint8_t_u_u(g_95.f0, 7))
            { /* block id: 108 */
                struct S0 l_246 = {1UL};
                int32_t l_257 = 0x90440BCEL;
                int32_t l_260 = 0x1682E681L;
                l_219 = g_95;
                if (p_39)
                    break;
                g_220 = p_39;
                for (p_40 = 0; (p_40 != 2); p_40 = safe_add_func_int8_t_s_s(p_40, 1))
                { /* block id: 114 */
                    float l_244 = (-0x10.1p+1);
                    int32_t l_267 = (-1L);
                    if ((safe_sub_func_int32_t_s_s(__builtin_popcount(l_214), l_219.f0)))
                    { /* block id: 115 */
                        int32_t l_237 = 0x95652836L;
                        int32_t l_241 = 9L;
                        int32_t l_243 = (-1L);
                        g_226 = l_225;
                        l_245 = ((((safe_mul_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((func_58(func_64((g_238 = (((p_39 ^ g_145) , g_6) ^ ((safe_rshift_func_uint8_t_u_s(p_40, 1)) < (!(l_214 = ((l_237 = (safe_add_func_uint8_t_u_u(l_215, l_214))) > (g_145 < 0xA0L))))))), (g_242 = (safe_lshift_func_uint16_t_u_s(g_220, l_241))), l_243), g_6, g_95, g_220, p_39) <= 0L), p_39)), p_41)) >= 0xA6L) | l_243) | 1UL);
                        l_246 = l_216;
                        if (g_242)
                            break;
                    }
                    else
                    { /* block id: 124 */
                        int8_t l_253 = (-1L);
                        int32_t l_254 = 0xB4E91CA7L;
                        int32_t l_258 = 3L;
                        l_214 = ((safe_sub_func_uint32_t_u_u(__builtin_bswap32((l_260 = (l_259 = (p_41 >= (l_258 = (l_257 = (((safe_rshift_func_int8_t_s_s((((safe_mod_func_uint16_t_u_u(g_145, __builtin_popcount((g_226.f0 = __builtin_popcountll(l_246.f0))))) & l_253) < ((((l_254 = p_40) & l_219.f0) && (safe_add_func_uint16_t_u_u(0xB1A2L, p_40))) , p_39)), 1)) > g_6) , 0x40L))))))), (-1L))) , 0x0.3p-1);
                        g_238 = (((safe_add_func_uint8_t_u_u((safe_add_func_int16_t_s_s(6L, ((((__builtin_clzll(l_257) == 0x75L) <= 0xC6BE33A2L) , l_254) > __builtin_popcountl(p_40)))), l_245)) || g_226.f0) , 0x5FCBFF38L);
                        l_258 = (safe_mul_func_float_f_f(__builtin_bswap64(l_214), l_219.f0));
                        l_216 = func_64((p_40 , l_258), l_267, (g_183 = 0xD.10E747p-90));
                    }
                    if (p_41)
                        break;
                }
            }
            g_183 = 0x9.3p+1;
            g_226 = (l_219 = func_48(g_238));
        }
        else
        { /* block id: 143 */
            struct S0 l_268 = {4294967295UL};
            g_226 = l_268;
        }
        g_95 = func_64(__builtin_parity((g_238 , g_6)), g_238, g_145);
        g_183 = (p_40 , 0xE.B34223p-42);
        l_216 = func_48(((((g_269 != (l_214 >= (func_90(l_270, g_269, (g_226.f0 == ((safe_mul_func_uint8_t_u_u((!g_242), ((func_84(l_216.f0, l_270.f0, (l_276 = (safe_mod_func_uint32_t_u_u(l_216.f0, g_95.f0))), l_270, p_41) || p_39) == 0x5A5CL))) ^ l_277)), g_95) , 0xF.587D15p+48))) < p_40) != p_41) >= 0x9.4D96B2p-9));
    }
    l_214 = ((safe_mul_func_uint16_t_u_u((g_194 = g_95.f0), g_238)) && (safe_mod_func_uint16_t_u_u((p_41 = ((safe_rshift_func_int16_t_s_s(((g_145 , l_270.f0) ^ ((((safe_lshift_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u((l_293 = (__builtin_parityll(((((func_58((p_40 , (l_288 = g_226)), (p_41 ^ g_220), ((safe_mul_func_uint8_t_u_u((1L <= p_40), l_291)) , l_270), p_41, p_41) || l_292) || l_292) != l_292) != g_226.f0)) , p_39)), l_214)) , g_194), g_6)) , 1UL) ^ l_292) > g_242)), 11)) || 1UL)), 0x6798L)));
    return l_293;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_95 g_145
 * writes: g_95.f0 g_145 g_194 g_183 g_95
 */
static struct S0  func_48(float  p_49)
{ /* block id: 40 */
    struct S0 l_57 = {0x268F57F5L};
    int32_t l_153 = 0xA8BF394CL;
    int32_t l_195 = 0x05F85640L;
    uint8_t l_196 = 9UL;
    int16_t l_197 = (-9L);
    g_95 = ((((((g_183 = (((l_195 = func_52((l_57 , (func_58(func_64(((((__builtin_bswap64(func_68(((safe_mod_func_int8_t_s_s((safe_mul_func_int8_t_s_s((((safe_add_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u((0xACL >= ((l_153 = (safe_lshift_func_uint16_t_u_s(((safe_lshift_func_int8_t_s_s(((safe_sub_func_int32_t_s_s(((func_84(l_57.f0, (g_6 < l_57.f0), l_57.f0, func_90(g_95, (l_57.f0 , __builtin_clzll((safe_mod_func_uint16_t_u_u((l_57.f0 & g_6), l_57.f0)))), l_57.f0, l_57), l_57.f0) && 0xEA549F13L) | l_57.f0), l_57.f0)) , l_57.f0), 2)) < 4294967287UL), 2))) || l_57.f0)), 255UL)), 254UL)) && l_57.f0) >= g_6), l_57.f0)), 0x86L)) , l_57))) , l_57.f0) > l_57.f0) & l_57.f0) , g_145), g_6, g_6), l_57.f0, l_57, g_6, l_57.f0) != 1L)), g_6, l_57.f0, l_57.f0)) != g_6) < 0xA.0524A1p+63)) > l_196) < p_49) == (-0x8.Ep-1)) <= l_197) , g_95);
    return g_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_95.f0 g_6
 * writes: g_194
 */
inline static float  func_52(int32_t  p_53, float  p_54, uint32_t  p_55, int32_t  p_56)
{ /* block id: 89 */
    uint32_t l_184 = 0x8BCBAD6AL;
    int32_t l_188 = 0x9F24D48FL;
    struct S0 l_189 = {7UL};
    uint8_t l_190 = 0x03L;
    int32_t l_192 = (-1L);
    int32_t l_193 = 8L;
    g_194 = ((l_193 = ((l_192 = ((-9L) && (safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s(p_55, (l_184 = 0xA8DCL))), (((((l_188 = (safe_lshift_func_int8_t_s_s((safe_unary_minus_func_int32_t_s(0x71652FD5L)), 0))) == 0x91L) == func_58(l_189, (l_190 & ((safe_unary_minus_func_uint16_t_u(p_55)) && 4294967291UL)), l_189, l_190, g_95.f0)) , 0xFA4CL) , g_6))))) & p_53)) ^ p_55);
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_58(struct S0  p_59, uint16_t  p_60, struct S0  p_61, uint16_t  p_62, int32_t  p_63)
{ /* block id: 87 */
    uint32_t l_178 = 1UL;
    return l_178;
}


/* ------------------------------------------ */
/* 
 * reads : g_145 g_95
 * writes:
 */
static struct S0  func_64(int32_t  p_65, uint32_t  p_66, float  p_67)
{ /* block id: 81 */
    uint8_t l_175 = 249UL;
    int32_t l_176 = 0L;
    int16_t l_177 = 2L;
    p_65 = (safe_mod_func_int8_t_s_s(l_175, __builtin_parity(g_145)));
    l_176 = 0x6.FC9B2Fp+0;
    l_177 = l_176;
    l_176 = 0x3.5p-1;
    return g_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_145 g_95.f0 g_6
 * writes: g_145
 */
inline static uint64_t  func_68(struct S0  p_69)
{ /* block id: 73 */
    uint32_t l_156 = 0x0C446B92L;
    for (g_145 = 24; (g_145 < 39); g_145 = safe_add_func_int32_t_s_s(g_145, 1))
    { /* block id: 76 */
        int32_t l_172 = 0xC2F6D645L;
        if (l_156)
            break;
        p_69 = ((safe_rshift_func_int16_t_s_u((g_95.f0 , ((safe_add_func_uint32_t_u_u(g_6, __builtin_ffs(p_69.f0))) & ((0xDEL >= (safe_sub_func_uint32_t_u_u(g_95.f0, ((safe_add_func_uint8_t_u_u(g_95.f0, (safe_sub_func_uint16_t_u_u((safe_rshift_func_int8_t_s_u(0xC8L, (~(safe_mod_func_int8_t_s_s((p_69.f0 == 0x07C9L), l_156))))), 0xAEA9L)))) < (-8L))))) == 1UL))), l_172)) , p_69);
    }
    return p_69.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_84(uint8_t  p_85, int16_t  p_86, int8_t  p_87, struct S0  p_88, uint32_t  p_89)
{ /* block id: 64 */
    int32_t l_150 = 3L;
    uint16_t l_152 = 65532UL;
    for (p_87 = 9; (p_87 > 0); p_87 = safe_sub_func_uint8_t_u_u(p_87, 1))
    { /* block id: 67 */
        int16_t l_149 = 0L;
        int32_t l_151 = 0x293E9D6AL;
        l_151 = (l_150 = l_149);
    }
    return l_152;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_95.f0 g_145 g_95
 * writes: g_95.f0
 */
inline static struct S0  func_90(struct S0  p_91, float  p_92, uint32_t  p_93, struct S0  p_94)
{ /* block id: 41 */
    float l_108 = 0xE.7922C1p+73;
    int32_t l_109 = 1L;
    int8_t l_112 = (-10L);
    int16_t l_121 = 1L;
    uint8_t l_122 = 0x4CL;
    int32_t l_123 = 0x8D85E261L;
    struct S0 l_131 = {0xAD64B6C7L};
    float l_144 = 0x3.5F0F44p-18;
    uint32_t l_146 = 0xD27CF1A4L;
    p_92 = func_98(((safe_lshift_func_int16_t_s_u((g_6 > p_93), ((safe_mul_func_uint8_t_u_u((l_109 = g_6), g_95.f0)) , ((l_112 = (safe_mul_func_int8_t_s_s((l_109 = (-7L)), 0xE6L))) && (l_123 = (p_94.f0 , (((safe_rshift_func_int8_t_s_s(((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint8_t_u_s((l_109 = (safe_sub_func_int32_t_s_s((0L > l_112), l_109))), 4)), l_121)) >= l_112), l_122)) == (-1L)) <= 0x58L))))))) > 0x4A06L), l_121, l_122, p_91.f0, p_93);
    l_131 = p_94;
    l_131 = p_91;
    l_123 = (safe_mod_func_uint8_t_u_u((p_94.f0 >= (p_94.f0 , (safe_sub_func_uint16_t_u_u(l_123, (((safe_mod_func_int16_t_s_s((safe_mul_func_uint16_t_u_u((g_6 , (safe_add_func_uint8_t_u_u(((safe_sub_func_int16_t_s_s(((((0xB5C0L | (p_94.f0 & l_122)) && g_6) && p_93) > l_131.f0), l_131.f0)) == g_95.f0), 253UL))), g_145)), l_146)) >= g_6) && g_6))))), g_95.f0));
    return g_95;
}


/* ------------------------------------------ */
/* 
 * reads : g_6
 * writes: g_95.f0
 */
inline static float  func_98(uint32_t  p_99, uint32_t  p_100, int32_t  p_101, uint32_t  p_102, uint8_t  p_103)
{ /* block id: 47 */
    uint8_t l_129 = 1UL;
    struct S0 l_130 = {0xC0990E41L};
    for (p_102 = (-2); (p_102 != 9); p_102 = safe_add_func_int8_t_s_s(p_102, 1))
    { /* block id: 50 */
        for (p_103 = 0; (p_103 >= 27); p_103 = safe_add_func_int8_t_s_s(p_103, 1))
        { /* block id: 53 */
            p_101 = (((g_6 < (((!(g_95.f0 = l_129)) < ((0xA1L && g_6) ^ (l_130 , p_100))) > (g_6 > __builtin_ffsll(g_6)))) >= g_6) , g_6);
        }
    }
    return l_130.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_95.f0, "g_95.f0", print_hash_value);
    transparent_crc(g_145, "g_145", print_hash_value);
    transparent_crc_bytes (&g_183, sizeof(g_183), "g_183", print_hash_value);
    transparent_crc(g_194, "g_194", print_hash_value);
    transparent_crc(g_220, "g_220", print_hash_value);
    transparent_crc(g_226.f0, "g_226.f0", print_hash_value);
    transparent_crc(g_238, "g_238", print_hash_value);
    transparent_crc(g_242, "g_242", print_hash_value);
    transparent_crc(g_269, "g_269", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 66
   depth: 1, occurrence: 14
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 61
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
   depth: 6, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 31, occurrence: 1
   depth: 34, occurrence: 1
   depth: 61, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 269
XXX times a non-volatile is write: 71
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 55
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 10
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 23.8
XXX percentage an existing variable is used: 76.2
********************* end of statistics **********************/

