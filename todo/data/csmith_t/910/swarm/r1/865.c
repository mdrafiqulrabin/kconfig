/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3711151732
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   float  f0;
};
#pragma pack(pop)

union U1 {
   uint16_t  f0;
   float  f1;
   int32_t  f2;
   struct S0  f3;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_2 = (-9);
static union U1 g_55 = {0x7F54};
static int32_t g_83[3] = {0xE2DC6606,0xE2DC6606,0xE2DC6606};
static struct S0 g_127 = {0x9.6p-1};
static int32_t *g_130 = (void*)0;
static const int32_t *g_167 = &g_83[2];
static const int32_t **g_166 = &g_167;
static const int32_t ***g_165[3][2][2] = {{{&g_166,&g_166},{&g_166,&g_166}},{{&g_166,&g_166},{&g_166,&g_166}},{{&g_166,&g_166},{&g_166,&g_166}}};
static float *g_241 = &g_55.f3.f0;
static float **g_240 = &g_241;
static int32_t g_253 = 1;
static struct S0 *g_381 = &g_127;
static struct S0 **g_380 = &g_381;
static float ****g_444 = (void*)0;
static float *****g_443 = &g_444;
static struct S0 *****g_486 = (void*)0;
static struct S0 ***g_509 = &g_380;
static struct S0 ****g_508 = &g_509;
static int32_t **g_865 = &g_130;
static int32_t ***g_864 = &g_865;
static int32_t ****g_863 = &g_864;
static int32_t *****g_862 = &g_863;
static union U1 *g_1014 = &g_55;
static union U1 **g_1013 = &g_1014;
static int32_t g_1042 = 0xC2F89057;
static uint32_t g_1389 = 4294967288U;
static uint16_t g_1441 = 0x6F84;
static float g_1464 = (-0x1.Ap-1);
static const uint16_t g_1484 = 0xBD87;
static struct S0 **g_1528 = (void*)0;
static uint32_t g_1577 = 4294967295U;
static int32_t *g_1829[3] = {&g_83[2],&g_83[2],&g_83[2]};


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static uint32_t  func_11(int16_t  p_12, uint32_t  p_13);
static int32_t  func_20(int32_t  p_21);
static uint32_t  func_30(int16_t  p_31, uint32_t  p_32, union U1  p_33);
static int16_t  func_34(const uint32_t  p_35);
static const uint32_t  func_36(uint32_t  p_37, uint32_t  p_38, float  p_39, int32_t  p_40);
static float  func_42(int32_t  p_43, float  p_44, int16_t  p_45);
static struct S0  func_50(union U1  p_51, uint32_t  p_52, int32_t  p_53, union U1  p_54);
static struct S0  func_58(float  p_59, uint32_t  p_60, int32_t  p_61, uint32_t  p_62, int32_t  p_63);
static int16_t  func_70(union U1  p_71, const uint32_t  p_72, uint32_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_83 g_55.f0 g_509 g_380 g_381 g_253 g_127 g_240 g_241 g_443 g_444 g_508 g_167 g_165 g_166 g_864 g_865 g_1042 g_863 g_130 g_862 g_55 g_1013 g_1014 g_55.f2 g_1577 g_1441 g_1829 g_1484 g_1389
 * writes: g_2 g_83 g_127 g_381 g_55.f3.f0 g_130 g_167 g_1042 g_253 g_55.f0 g_1014 g_55.f1 g_55.f2 g_1829
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_10 = (-1);
    uint16_t l_1235 = 0U;
    struct S0 l_1269 = {0xE.CE7443p+62};
    union U1 l_1284 = {0U};
    int32_t **l_1285 = &g_130;
    int32_t ***l_1380 = &g_865;
    struct S0 **l_1399[8][5][1] = {{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}},{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}},{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}},{{(void*)0},{&g_381},{&g_381},{(void*)0},{&g_381}},{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}},{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}},{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}},{{&g_381},{&g_381},{&g_381},{&g_381},{&g_381}}};
    float *l_1401 = &g_55.f3.f0;
    int32_t *****l_1440 = &g_863;
    int32_t l_1487 = (-1);
    uint32_t l_1504 = 0x128D86C0;
    float **l_1506 = &g_241;
    float ***l_1515 = &g_240;
    struct S0 ****l_1540[6][1];
    float l_1576[9] = {0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0,0xF.60E180p-0};
    float l_1609[10][4][5] = {{{0x7.DA107Ap-99,0x7.DA107Ap-99,0x0.1p-1,0xC.8E4372p-93,0x0.F32F3Cp+2},{0x0.5p-1,0x2.9FD7AAp+96,0x2.CE173Ep+81,(-0x7.3p-1),0xF.E8E2E4p-98},{(-0x8.7p-1),(-0x9.4p+1),0x0.35F5D7p+53,(-0x1.7p+1),0x5.4366E6p+11},{0x0.6p-1,0x2.9FD7AAp+96,0x3.2E37B9p+23,0x2.CE173Ep+81,(-0x1.Ep-1)}},{{0x1.6p-1,0x7.DA107Ap-99,0x7.6p-1,0x9.CBF368p-65,0x1.Ep-1},{0x3.2E37B9p+23,(-0x1.6p+1),0x1.Ep+1,0x1.Ep+1,(-0x1.6p+1)},{(-0x1.1p-1),(-0x1.7p+1),(-0x9.4p+1),0xF.E4ED8Ap+51,0x0.35F5D7p+53},{(-0x1.4p-1),0x1.7p-1,0x4.E791D0p-30,(-0x1.Ep-1),0x1.Ep+1}},{{0x0.F32F3Cp+2,0x7.FA6D46p+77,0x0.D13E54p+94,0x7.6p-1,0x0.1p-1},{(-0x1.4p-1),(-0x7.Dp-1),0x1.Fp+1,0x2.9FD7AAp+96,0xC.D69319p+7},{(-0x1.1p-1),(-0x1.6p-1),0xA.435342p+76,0x0.8p+1,0xF.E4ED8Ap+51},{0x3.2E37B9p+23,0x0.6p-1,(-0x1.6p+1),0x0.6p-1,0x3.2E37B9p+23}},{{0x1.6p-1,0x5.4p-1,0x0.8p+1,0x5.4366E6p+11,0x7.DA107Ap-99},{0x0.6p-1,0x1.4p-1,0x1.3p-1,(-0x2.0p+1),0x3.FD270Bp+58},{(-0x8.7p-1),0x0.1p-1,0x1.4p-1,0x5.4p-1,0x7.DA107Ap-99},{0x0.5p-1,(-0x2.0p+1),0x0.8p-1,0xF.59DEA0p+42,0x3.2E37B9p+23}},{{0x7.DA107Ap-99,0x7.6p-1,0x9.CBF368p-65,0x1.Ep-1,0xF.E4ED8Ap+51},{0x4.E791D0p-30,(-0x7.3p-1),(-0x7.3p-1),0x4.E791D0p-30,0xC.D69319p+7},{0x0.8p+1,0x9.5C3EE0p+48,0x7.FA6D46p+77,0x0.01F417p+85,0x0.1p-1},{0x3.FD270Bp+58,(-0x1.4p-1),0x0.6p-1,(-0x7.Cp+1),0x1.Ep+1}},{{0x1.Ep-1,(-0x8.7p-1),0xF.E4ED8Ap+51,0x0.01F417p+85,0x0.35F5D7p+53},{(-0x7.3p-1),0xE.C87862p-59,0x3.FD270Bp+58,0x4.E791D0p-30,(-0x1.6p+1)},{0xB.92DEEEp-10,0x0.35F5D7p+53,0x9.F25A69p+98,0x1.Ep-1,0x1.Ep-1},{(-0x7.Dp-1),(-0x1.3p+1),(-0x7.Dp-1),0xF.59DEA0p+42,(-0x1.Ep-1)}},{{0x7.6p-1,0xB.92DEEEp-10,(-0x1.6p-1),0x5.4p-1,0x5.4366E6p+11},{(-0x1.5p-1),0x3.2E37B9p+23,(-0x1.Ep-1),(-0x2.0p+1),0xF.E8E2E4p-98},{0x0.1p-1,0x9.F25A69p+98,(-0x1.6p-1),0x5.4366E6p+11,0x0.F32F3Cp+2},{0x1.Fp+1,(-0x1.Ep-1),(-0x7.Dp-1),0x0.6p-1,0x1.7p-1}},{{0x1.4p-1,0xA.435342p+76,0x9.F25A69p+98,0x0.8p+1,0x9.F25A69p+98},{0xF.59DEA0p+42,0xF.59DEA0p+42,0x3.FD270Bp+58,0x2.9FD7AAp+96,(-0x1.Bp-1)},{0x0.01F417p+85,0xC.8E4372p-93,0xF.E4ED8Ap+51,0x7.6p-1,(-0x1.1p-1)},{0x1.4p-1,0x0.8p-1,0x0.6p-1,(-0x1.Ep-1),0x1.Ap-1}},{{0x0.35F5D7p+53,0xC.8E4372p-93,0x7.FA6D46p+77,0xF.E4ED8Ap+51,(-0x1.7p+1)},{(-0x5.1p-1),0xF.59DEA0p+42,(-0x7.3p-1),0x1.Ep+1,(-0x1.5p-1)},{0x0.8p+1,0x5.4p-1,0x1.6p-1,0x1.6p-1,0x5.4p-1},{(-0x1.3p+1),(-0x7.Dp-1),0xF.59DEA0p+42,(-0x1.Ep-1),(-0x1.Bp-1)}},{{0x0.1p-1,(-0x9.4p+1),0x9.F25A69p+98,0xB.92DEEEp-10,0x1.6p-1},{0xF.E8E2E4p-98,0x1.Fp+1,0xC.D69319p+7,(-0x1.5p-1),0x3.FD270Bp+58},{0x0.1p-1,0x9.5C3EE0p+48,0x0.D13E54p+94,(-0x8.7p-1),0x0.35F5D7p+53},{(-0x1.3p+1),0x1.Ep+1,0xE.C87862p-59,0x1.3p-1,(-0x1.Ep-1)}}};
    union U1 l_1635[4] = {{0U},{0U},{0U},{0U}};
    int16_t l_1820 = 4;
    int i, j, k;
    for (i = 0; i < 6; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
            l_1540[i][j] = &g_509;
    }
    if (g_2)
    { /* block id: 1 */
        uint32_t l_22 = 1U;
        uint32_t l_1259 = 0x5812EC80;
        for (g_2 = 26; (g_2 > (-8)); --g_2)
        { /* block id: 4 */
            float ***l_750 = (void*)0;
            float ****l_749[3][2];
            int32_t *****l_1232 = &g_863;
            int32_t l_1237 = 1;
            int i, j;
            for (i = 0; i < 3; i = i + 1)
            {
                for (j = 0; j < 2; j = j + 1)
                    l_749[i][j] = &l_750;
            }
            if ((((int16_t)(((int16_t)(+l_10) + (int16_t)g_2) < (l_10 & func_11(g_2, (((uint32_t)((int16_t)(-5) >> (int16_t)((int16_t)(0xBEFA1E1C <= func_20(l_22)) << (int16_t)((*g_443) == l_749[1][1]))) / (uint32_t)4294967295U) && 0x1EBFC0C1)))) >> (int16_t)14) , (**g_166)))
            { /* block id: 600 */
                uint32_t l_1236 = 0x83E92C2E;
                int32_t l_1238 = 0xDE62B48E;
                const float ****l_1252 = (void*)0;
                (**g_864) = (void*)0;
                /* statement id: 601 */
                assert (g_130 == 0);
                l_1238 = (((((uint16_t)(g_55.f0 > ((uint32_t)((((((((void*)0 != l_1232) <= 0x3C7F92E4) <= ((g_83[2] , (((((int16_t)0xEB06 >> (int16_t)g_83[2]) & (l_10 == (l_1235 >= g_2))) & l_22) != l_1236)) < g_55.f0)) != (-1)) , g_83[2]) > l_1236) , 0U) % (uint32_t)0x2B1ADBE1)) - (uint16_t)0xEFDF) || l_22) && 1) != l_1237);
                for (l_1238 = 18; (l_1238 == 10); --l_1238)
                { /* block id: 605 */
                    const union U1 l_1242 = {65533U};
                    const float *l_1247 = &g_127.f0;
                    if (((void*)0 != &g_444))
                    { /* block id: 606 */
                        return l_1238;
                    }
                    else
                    { /* block id: 608 */
                        uint32_t l_1241 = 0x6C29417C;
                        (***g_863) = (((l_1241 , l_1242) , (((int16_t)((int16_t)l_1242.f0 << (int16_t)4) >> (int16_t)g_1042) <= ((void*)0 != l_1247))) , (***g_863));
                        (*g_241) = ((g_2 , ((float)l_1238 + (float)((float)((void*)0 == l_1252) * (float)((((l_22 == ((***g_509) , (((float)((float)(0x2.D5E58Fp-52 > (((-0x1.Cp+1) <= l_1236) != (-0x2.0p+1))) + (float)(-0x1.4p+1)) / (float)(-0x3.4p+1)) < l_10))) >= l_1241) < l_1242.f0) != l_1241)))) > 0x0.5p-1);
                    }
                }
                if (l_1238)
                    continue;
            }
            else
            { /* block id: 614 */
                uint32_t l_1262 = 2U;
                for (l_10 = (-15); (l_10 != (-1)); ++l_10)
                { /* block id: 617 */
                    uint32_t l_1270 = 4294967295U;
                    if ((**g_166))
                        break;
                    (**g_864) = (void*)0;
                    /* statement id: 619 */
                    assert (g_130 == 0);
                    if (l_22)
                        continue;
                    (****g_508) = func_58(l_1259, (((uint16_t)g_83[2] << (uint16_t)3) & ((l_1262 <= ((int16_t)(((g_83[1] , ((uint16_t)l_1262 * (uint16_t)(g_83[0] == ((int16_t)(l_1269 , (((**g_862) == (*g_863)) != (-1))) << (int16_t)g_253)))) > l_1262) , l_1259) % (int16_t)l_1270)) ^ g_55.f0)), (**g_166), l_1270, g_83[0]);
                    /* statement id: 621 */
                    //assert (g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0);
                }
            }
            for (g_1042 = 0; (g_1042 == 8); ++g_1042)
            { /* block id: 626 */
                for (g_253 = 1; (g_253 >= 0); g_253 -= 1)
                { /* block id: 629 */
                    if (l_22)
                        break;
                    for (g_55.f0 = 0; (g_55.f0 <= 1); g_55.f0 += 1)
                    { /* block id: 633 */
                        int32_t *l_1273 = &g_83[1];
                        (*g_865) = l_1273;
                        /* statement id: 634 */
                        assert ((g_130 >= &g_83[0] && g_130 <= &g_83[2]));
                        (*g_1013) = (*g_1013);
                    }
                }
            }
        }
        /* facts after for loop */
        //assert (g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0);
    }
    else
    { /* block id: 640 */
        int32_t *l_1274 = &g_83[0];
        union U1 l_1283 = {0xBD9B};
        struct S0 **l_1323 = &g_381;
        int32_t l_1351 = 0;
        union U1 **l_1352 = (void*)0;
        float l_1375[1];
        const int16_t l_1376[2] = {0x8FDF,0x8FDF};
        uint32_t l_1394 = 5U;
        struct S0 *l_1448 = (void*)0;
        float **l_1463 = &l_1401;
        struct S0 *l_1636 = &g_127;
        const int16_t l_1645 = (-10);
        int32_t l_1655 = (-1);
        int16_t l_1656 = (-1);
        int16_t l_1684 = 9;
        union U1 ****l_1704 = (void*)0;
        uint16_t l_1732 = 6U;
        uint32_t l_1733 = 0xB9890A5E;
        struct S0 *l_1737 = &l_1269;
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_1375[i] = (-0x3.Ap+1);
        (*g_865) = l_1274;
        /* statement id: 641 */
        assert ((g_130 >= &g_83[0] && g_130 <= &g_83[2]));
        for (g_2 = 0; (g_2 <= (-29)); --g_2)
        { /* block id: 644 */
            int32_t l_1278 = 4;
            (**g_380) = func_50((((l_10 && (g_253 | (+l_1278))) || ((uint16_t)(l_1278 , ((((g_1042 || (l_1235 >= (g_83[0] , (((**g_509) != (void*)0) || g_83[2])))) > l_1278) >= g_1042) != 4U)) * (uint16_t)l_10)) , l_1283), g_1042, g_83[2], l_1284);
            /* statement id: 645 */
            //assert (g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]));
            return (*l_1274);
        }
        if (((l_1285 == &l_1274) > ((int16_t)((~0xC6F6) <= (**g_166)) / (int16_t)(((int16_t)(((uint16_t)(**l_1285) + (uint16_t)(0x4F5240B0 == (((1 || (+(!(0 & ((0x71D0778C & (*l_1274)) && (*****g_862)))))) & 0x7D90E521) == (**l_1285)))) != 0x31B4) >> (int16_t)(**l_1285)) && 6U))))
        { /* block id: 648 */
            int16_t l_1308[2][2][3] = {{{0,0x1762,0},{0,0x1762,0}},{{0,0x1762,0},{0,0x1762,0}}};
            int32_t ***l_1334 = &l_1285;
            float *l_1350 = &l_1269.f0;
            struct S0 **l_1400[7][8] = {{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381},{&g_381,(void*)0,&g_381,&g_381,&g_381,&g_381,(void*)0,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381},{(void*)0,&g_381,&g_381,&g_381,&g_381,&g_381,(void*)0,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381}};
            struct S0 *****l_1424 = &g_508;
            int i, j, k;
            for (l_1235 = 0; (l_1235 >= 7); l_1235 += 4)
            { /* block id: 651 */
                int32_t *****l_1297[3];
                union U1 l_1302 = {65535U};
                struct S0 *l_1309 = &l_1269;
                int32_t *****l_1331 = &g_863;
                struct S0 ***l_1335 = &l_1323;
                const float l_1348[1] = {(-0x1.Cp-1)};
                int i;
                for (i = 0; i < 3; i = i + 1)
                    l_1297[i] = &g_863;
                (**g_240) = ((void*)0 == l_1297[2]);
            }
        }
        else
        { /* block id: 713 */
            int32_t l_1444 = 0x5404BDC8;
            struct S0 *l_1449 = &g_127;
            float l_1505 = (-0x3.2p-1);
            int32_t *l_1545 = &g_83[2];
            int32_t l_1546 = 0xAA7F6C06;
            uint32_t l_1574 = 0x600A56B1;
            uint32_t l_1610 = 1U;
            const uint32_t l_1628 = 0xB96DF26E;
            union U1 *l_1639[6];
            uint32_t l_1686 = 0x4336C73E;
            uint32_t l_1705[8][3];
            struct S0 ***l_1714 = &g_1528;
            int i, j;
            for (i = 0; i < 6; i = i + 1)
                l_1639[i] = &l_1635[0];
            for (i = 0; i < 8; i = i + 1)
            {
                for (j = 0; j < 3; j = j + 1)
                    l_1705[i][j] = 0x9F9B1825;
            }
        }
        if (((**l_1285) >= (((uint32_t)((int16_t)0xBE1A >> (int16_t)11) + (uint32_t)((uint32_t)((((int16_t)(g_1042 && ((**l_1285) > 0x995D23C3)) >> (int16_t)(*****l_1440)) & (((int16_t)(0x7CDC && (*l_1274)) << (int16_t)((int16_t)l_1732 >> (int16_t)(*l_1274))) > (*l_1274))) && l_1733) - (uint32_t)(*****l_1440))) & 1U)))
        { /* block id: 814 */
            uint16_t l_1734[7] = {0xD040,0xD049,0xD040,0xD040,0xD049,0xD040,0xD040};
            int32_t ***l_1758 = &g_865;
            struct S0 ***l_1812 = &g_1528;
            const float *l_1813[6] = {&l_1609[0][1][1],&l_1609[0][1][1],&l_1609[0][1][1],&l_1609[0][1][1],&l_1609[0][1][1],&l_1609[0][1][1]};
            int i;
lbl_1774:
            (**l_1506) = l_1734[2];
            if ((g_253 < 0x3AB3))
            { /* block id: 816 */
                for (g_253 = (-12); (g_253 < 2); g_253 += 5)
                { /* block id: 819 */
                    (*l_1323) = l_1737;
                    /* statement id: 820 */
                    assert (g_381 == &l_1269);
                }
                /* facts after for loop */
                assert (g_381 == &l_1269 || g_381 == &g_127);
            }
            else
            { /* block id: 822 */
                uint32_t l_1755 = 8U;
                const uint32_t l_1773 = 4294967295U;
                struct S0 **l_1815 = &g_381;
                if ((((*l_1274) , ((uint16_t)((((uint16_t)((uint32_t)(&l_1463 == &l_1506) - (uint32_t)(((uint16_t)((int16_t)(-8) % (int16_t)(((((-(uint16_t)((int32_t)((((g_253 , (**g_508)) == (void*)0) , ((***g_864) < ((((int16_t)(((int32_t)l_1755 - (int32_t)(**l_1285)) , g_1577) / (int16_t)g_1042) , g_1577) <= l_1755))) || 0xDB15C699) % (int32_t)(-6))) > (*****g_862)) == g_2) & (**g_166)) , (**l_1285))) >> (uint16_t)g_55.f0) <= (***g_864))) / (uint16_t)g_253) , (void*)0) != (void*)0) >> (uint16_t)15)) , (-1)))
                { /* block id: 823 */
                    float l_1771 = 0x1.3p-1;
                    int32_t l_1785[9] = {9,9,(-1),9,9,(-1),9,9,(-1)};
                    int32_t *l_1796 = &l_1655;
                    int i;
                    for (l_1394 = (-22); (l_1394 != 6); l_1394 += 1)
                    { /* block id: 826 */
                        int16_t l_1772[4][3][9] = {{{(-6),0,0,(-6),0,0xEDCC,0,(-6),0},{0xA0F8,0,0xE591,0x2280,0xD6F8,0x2280,0xE591,0,0xA0F8},{0,(-6),0,0xEDCC,0,(-6),0,0,(-6)}},{{0x1745,1,0xE591,1,0x1745,0x5688,(-1),0x2280,(-1)},{0,0,0,1,1,1,1,0,0},{0xA0F8,0x2A55,(-1),4,0xE591,0x5688,0x3A99,0,0x3A99}},{{(-6),0xEDCC,1,1,0xEDCC,(-6),1,(-6),0xEDCC},{0x3A99,0x2280,0x1745,0x2A55,0xD6F8,0x5688,0xD6F8,0x2A55,0x1745},{0x4E45,0x4E45,0,1,(-6),1,0,0x4E45,0x4E45}},{{0x1745,0x2A55,0xD6F8,0x5688,0xD6F8,0x2A55,0x1745,0x2280,0x3A99},{1,0,0,0,1,1,1,1,0},{0x1745,0,0x1745,4,0xA0F8,0,0xE591,0x2280,0xD6F8}}};
                        int i, j, k;
                    }
                    if (l_1732)
                        goto lbl_1774;
                    (***l_1515) = ((float)((float)((~((int32_t)(!((*g_509) == ((((***g_864) > ((int16_t)l_1785[1] * (int16_t)((***l_1380) | (((((uint16_t)((uint32_t)((l_1755 >= ((uint16_t)65535U * (uint16_t)(((***l_1758) > ((l_1785[1] >= (((uint16_t)(((void*)0 != &g_1013) <= 1U) / (uint16_t)(**l_1285)) >= (-10))) == 1U)) == l_1785[1]))) < 0x9AE988E5) + (uint32_t)0xEF466EC7) % (uint16_t)(***l_1758)) , (*g_166)) == (**l_1380)) , g_1441)))) | l_1785[1]) , (*g_509)))) - (int32_t)(**g_166))) , l_1785[8]) + (float)(***l_1758)) / (float)0x3.BDFA86p-51);
                    for (l_10 = 0; (l_10 > (-15)); --l_10)
                    { /* block id: 835 */
                        int32_t *l_1797 = &l_1487;
                        l_1796 = (***g_863);
                        /* statement id: 836 */
                        assert (l_1796 == &l_1487 || (l_1796 >= &g_83[0] && l_1796 <= &g_83[2]));
                        (***g_863) = l_1797;
                        /* statement id: 837 */
                        assert (g_130 == &l_1487);
                    }
                    /* facts after for loop */
                    assert (g_130 == &l_1487 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]));
                    assert (l_1796 == &l_1487 || (l_1796 >= &g_83[0] && l_1796 <= &g_83[2]) || l_1796 == &l_1655);
                }
                else
                { /* block id: 839 */
                    int32_t l_1811 = (-1);
                    struct S0 **l_1814 = &l_1448;
                    for (l_1284.f2 = 7; (l_1284.f2 >= 2); l_1284.f2 -= 1)
                    { /* block id: 842 */
                        int32_t *l_1798 = &l_1655;
                        (**g_509) = (*g_380);
                        (****g_862) = l_1798;
                        /* statement id: 844 */
                        assert (g_130 == &l_1655);
                        if ((**g_166))
                            break;
                    }
                    /* facts after for loop */
                    assert (g_130 == &l_1655 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]));
                                        if ((*****g_862))
                    { /* block id: 847 */
                        (***l_1380) = (4294967295U | ((int32_t)((int16_t)((*l_1274) && (((int16_t)0xA733 + (int16_t)((int16_t)((uint32_t)((uint32_t)l_1811 - (uint32_t)(*l_1274)) + (uint32_t)(((l_1812 != (*g_508)) , ((l_1813[2] == (*g_240)) > (***l_1758))) <= g_253)) + (int16_t)(***l_1380))) && 0xAAE6)) - (int16_t)1U) / (int32_t)3U));
                    }
                    else
                    { /* block id: 849 */
                        l_1815 = l_1814;
                        /* statement id: 850 */
                        assert (l_1815 == &l_1448);
                    }
                    /* facts after branching */
                    assert (l_1815 == &l_1448 || l_1815 == &g_381);
                    (***g_864) = (**g_166);
                }
                /* facts after branching */
                assert (g_130 == &l_1655 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == &l_1487);
                assert (l_1815 == &l_1448 || l_1815 == &g_381);
            }
            /* facts after branching */
            assert (g_130 == &l_1655 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == &l_1487);
            assert (g_381 == &l_1269 || g_381 == &g_127);
        }
        else
        { /* block id: 855 */
            uint32_t l_1821[8][9] = {{4294967291U,0x30E08E52,0xFE6FBFBE,0x966D37C7,0xC263FD09,0x966D37C7,0xFE6FBFBE,0x30E08E52,4294967291U},{0xC55F0DA6,0xD2F7719E,4294967292U,0x7568AF43,1U,4294967290U,0xB9E7AECD,1U,0x61FF0E76},{1U,0x966D37C7,0x1769CA3D,0x61D03D9D,0x61D03D9D,0x1769CA3D,0x966D37C7,1U,0x6CE6BCA1},{0xC55F0DA6,1U,0xB9E7AECD,0xB318AB25,0x6F3D67FF,0xFB5F0176,0x7CBB2CD1,0x7568AF43,0x7568AF43},{4294967291U,1U,4294967295U,1U,4294967295U,1U,4294967291U,3U,0x6CE6BCA1},{0xFB5F0176,1U,0U,0xD2F7719E,0x7568AF43,0x6F3D67FF,0x61FF0E76,1U,0x61FF0E76},{0x30E08E52,0x57FF8E0D,0xF1FC2D91,0xF1FC2D91,0x57FF8E0D,0x30E08E52,0x6CE6BCA1,3U,4294967291U},{1U,0xB9E7AECD,0xB318AB25,0x6F3D67FF,0xFB5F0176,0x7CBB2CD1,0x7568AF43,0x7568AF43,0x7CBB2CD1}};
            union U1 ***l_1828 = &g_1013;
            int i, j;
            (**l_1380) = (****g_862);
            if ((((uint16_t)((uint32_t)l_1820 + (uint32_t)l_1821[0][2]) << (uint16_t)((uint16_t)((uint16_t)g_1441 * (uint16_t)((uint32_t)((**l_1285) , ((0x9D2B > 0x1AAF) < (l_1828 == &g_1013))) / (uint32_t)(((0xD0E171C8 != g_83[2]) ^ (*l_1274)) | l_1821[2][7]))) >> (uint16_t)8)) <= (****g_863)))
            { /* block id: 857 */
                int16_t l_1835 = 0x38A0;
                int16_t l_1850 = 0xDC78;
                union U1 ***l_1870[2][3][3] = {{{(void*)0,(void*)0,(void*)0},{&g_1013,&g_1013,&g_1013},{(void*)0,(void*)0,(void*)0}},{{&g_1013,&g_1013,&g_1013},{(void*)0,(void*)0,(void*)0},{&g_1013,&g_1013,&g_1013}}};
                const float *l_1881 = &l_1576[2];
                const float **l_1880 = &l_1881;
                const float ***l_1879 = &l_1880;
                struct S0 *l_1882 = &g_127;
                int i, j, k;
                (*g_166) = &l_1655;
                /* statement id: 858 */
                assert (g_167 == &l_1655);
                (*g_865) = g_1829[2];
                if (((g_1484 & ((*l_1274) && ((uint32_t)0x00023C2F + (uint32_t)(+g_55.f0)))) == ((int16_t)g_83[2] >> (int16_t)0)))
                { /* block id: 860 */
                    float l_1848 = 0x2.3A7622p-67;
                    int32_t l_1849[6][9] = {{1,0xAA21924C,1,0x50FB7837,(-1),0xD4D24C6A,0x98601115,0x8CD9D922,(-6)},{0x67195849,9,(-1),0x0ABB8843,(-1),8,0xAA21924C,0xED3E756E,4},{0xD4D24C6A,0x07D112E6,(-1),0x50FB7837,0x50FB7837,(-1),0x07D112E6,0xD4D24C6A,1},{(-7),0x07D112E6,(-1),9,1,4,(-1),1,0x7ED5B433},{0x07D112E6,9,0x8CD9D922,(-1),1,0x0ABB8843,0xED3E756E,0x0ABB8843,1},{0x98601115,0xAA21924C,0xAA21924C,0x98601115,(-1),(-1),0xED3E756E,(-7),4}};
                    int i, j;
                    (*g_241) = ((***l_1380) >= ((0x0.0p+1 != (((l_1835 < ((float)(***l_1380) - (float)(((float)((float)l_1821[0][2] - (float)((((float)(l_1821[6][6] < ((float)((((-0x1.Ap+1) == ((float)(l_1848 <= (*l_1274)) - (float)(*l_1274))) >= 0x0.1p+1) == l_1849[4][4]) * (float)(**l_1285))) + (float)0x4.456E76p-92) , (void*)0) == &l_1849[4][4])) / (float)(-0x1.2p-1)) <= (*l_1274)))) != l_1821[0][2]) <= (*l_1274))) > (*l_1274)));
                    for (l_1732 = 0; (l_1732 <= 2); l_1732 += 1)
                    { /* block id: 864 */
                        int i;
                        g_1829[l_1732] = g_1829[l_1732];
                        if (l_1850)
                            break;
                        if ((*l_1274))
                            continue;
                    }
                    for (g_55.f2 = 0; (g_55.f2 <= (-1)); g_55.f2--)
                    { /* block id: 871 */
                        int32_t l_1865 = 0x0C15A2D6;
                        (**g_864) = (**g_864);
                        (*g_865) = ((((uint16_t)((int16_t)((0x7063 < 0x8321) , ((int16_t)(0x696D < 0x1025) % (int16_t)((uint16_t)((int16_t)g_1389 << (int16_t)12) >> (uint16_t)15))) * (int16_t)((l_1849[4][4] & (*l_1274)) & (((int16_t)g_253 - (int16_t)(((**g_509) == (void*)0) , g_253)) == g_55.f2))) * (uint16_t)l_1865) >= 0x50F6) , (void*)0);
                        /* statement id: 873 */
                        assert (g_130 == 0);
                        (*l_1274) = ((uint32_t)(((int16_t)((0xB90B || ((l_1870[1][0][2] != &g_1013) && (((int16_t)(g_1441 || (0x2285 >= (((uint32_t)(((void*)0 != l_1879) | (0x601062CB & (0x1222 == g_1389))) - (uint32_t)g_55.f2) >= g_1577))) << (int16_t)5) , (**g_166)))) || l_1865) >> (int16_t)g_83[1]) >= (*l_1274)) + (uint32_t)0x9F4DC25A);
                    }
                    /* facts after for loop */
                                        assert (g_130 == 0 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]));
                    (**g_509) = l_1882;
                }
                else
                { /* block id: 877 */
                    int32_t ***l_1883 = &g_865;
                    l_1883 = (**l_1440);
                }
                /* facts after branching */
                assert (g_130 == 0 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]));
            }
            else
            { /* block id: 880 */
                return g_55.f0;
            }
            /* facts after branching */
            assert (g_130 == 0 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]));
            assert (g_167 == &l_1655);
            return (*l_1274);
            /* statement id: 883 */
            //assert (g_167 == dangling);
        }
        /* facts after branching */
        assert (g_130 == &l_1655 || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == &l_1487);
        assert (g_381 == &l_1269 || g_381 == &g_127);
    }
    /* facts after branching */
    //assert (g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == &l_1487 || g_130 == 0);
    assert (g_381 == &l_1269 || g_381 == &g_127);
    (*l_1285) = &l_1487;
    /* statement id: 886 */
    assert (g_130 == &l_1487);
    return g_2;
    /* statement id: 887 */
    //assert (g_130 == dangling);
    //assert (g_381 == dangling || g_381 == &g_127);
}


/* ------------------------------------------ */
/* 
 * reads : g_381 g_508 g_509 g_380 g_167 g_83 g_127 g_165 g_166 g_240 g_241
 * writes: g_127 g_381 g_55.f3.f0
 */
static uint32_t  func_11(int16_t  p_12, uint32_t  p_13)
{ /* block id: 384 */
    uint32_t l_751[3];
    int32_t **l_765 = &g_130;
    struct S0 *l_794 = &g_127;
    union U1 l_840 = {0x3C4E};
    const int32_t **l_841 = &g_167;
    const int32_t ****l_916 = &g_165[0][1][1];
    int16_t l_928 = (-7);
    int32_t l_957 = 0x64BF0CA8;
    uint32_t l_960 = 0x8A53D64B;
    float l_968[2];
    const int16_t l_997 = 9;
    int32_t l_1009 = 0xFA57F8E5;
    struct S0 ***l_1096[6][5] = {{(void*)0,&g_380,&g_380,&g_380,&g_380},{(void*)0,(void*)0,&g_380,&g_380,(void*)0},{&g_380,&g_380,&g_380,&g_380,&g_380},{&g_380,&g_380,&g_380,&g_380,&g_380},{&g_380,&g_380,&g_380,&g_380,&g_380},{&g_380,(void*)0,&g_380,(void*)0,&g_380}};
    union U1 l_1101 = {0xC744};
    struct S0 *l_1127[9] = {&g_127,&g_127,&g_127,&g_127,&g_127,&g_127,&g_127,&g_127,&g_127};
    uint32_t l_1223[9][5] = {{0xEF513377,0xEF513377,0x9A1E0A5C,0x4D70989E,1U},{4U,4294967294U,0x9A1E0A5C,4294967293U,4294967295U},{0U,0x9A1E0A5C,4294967294U,0x9A1E0A5C,0U},{0x4D70989E,4294967294U,1U,0U,0xEF513377},{0x4D70989E,0xEF513377,4294967295U,0U,0U},{0U,0x3D280D52,0U,4294967294U,0xEF513377},{4U,0U,0xEF513377,4294967294U,0U},{0xEF513377,4294967295U,0U,0U,4294967295U},{4294967295U,4294967294U,0xEF513377,0U,1U}};
    int i, j;
    for (i = 0; i < 3; i = i + 1)
        l_751[i] = 4294967288U;
    for (i = 0; i < 2; i = i + 1)
        l_968[i] = 0x0.Ep-1;
    if (l_751[1])
    { /* block id: 385 */
        struct S0 l_752[6][10] = {{{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22}},{{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22}},{{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22}},{{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22}},{{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22}},{{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22},{0x7.772B27p+22}}};
        uint32_t l_753 = 0x13B15E57;
        int i, j;
        (*g_381) = l_752[1][4];
        return l_753;
    }
    else
    { /* block id: 388 */
        int32_t *l_768 = &g_83[2];
        const float **l_773 = (void*)0;
        const float ***l_772 = &l_773;
        union U1 l_780 = {0x3F9D};
        int32_t ***l_785[9];
        int32_t ****l_784[7] = {&l_785[6],&l_785[6],(void*)0,&l_785[6],&l_785[6],(void*)0,&l_785[6]};
        int32_t *****l_783 = &l_784[5];
        int32_t l_842 = 0;
        float *****l_843 = (void*)0;
        int16_t l_866 = 0x8CB7;
        struct S0 l_947 = {0x0.Ap+1};
        uint32_t l_949 = 0xAB1D9E42;
        uint32_t l_958 = 0x81B7E133;
        const float l_995 = 0x5.1D435Bp-46;
        float l_1041[2];
        uint16_t l_1047 = 2U;
        struct S0 ***l_1054 = &g_380;
        int i;
        for (i = 0; i < 9; i = i + 1)
            l_785[i] = (void*)0;
        for (i = 0; i < 2; i = i + 1)
            l_1041[i] = 0x1.Ep-1;
        (*g_380) = (***g_508);
        for (p_12 = 0; (p_12 >= 0); p_12 += 3)
        { /* block id: 392 */
            struct S0 ****l_758 = &g_509;
            int32_t l_766[2][7][3] = {{{0x94E42214,1,0x94E42214},{0,0,0x94E42214},{1,0x761F8CD6,0x805BE1DE},{0x805BE1DE,0x94E42214,0x375E350B},{0,(-1),0xC955149C},{0x805BE1DE,0x5984BFC3,(-3)},{1,1,1}},{{0,1,0x761F8CD6},{0x94E42214,0x5984BFC3,1},{0,(-1),0xA7685CFD},{(-3),0x94E42214,1},{7,0x761F8CD6,0x761F8CD6},{0,0,1},{0,1,(-3)}}};
            int32_t ***l_822 = &l_765;
            int32_t *****l_853 = &l_784[0];
            float ****l_892 = (void*)0;
            union U1 l_899 = {65529U};
            float *l_946 = &g_127.f0;
            uint32_t l_956 = 4294967287U;
            float l_996 = 0x5.FA0D7Bp-31;
            int32_t l_1048 = 0xA99B9EAF;
            struct S0 *****l_1053 = &g_508;
            int i, j, k;
        }
    }
    (**g_240) = (((float)((float)(**l_841) / (float)p_12) * (float)(0x8.8p-1 <= 0x8.4FDD65p-71)) >= ((float)((float)(((((float)((float)((float)(g_83[2] , (((p_12 >= ((*l_794) , ((p_13 == p_12) , p_13))) != (**l_841)) <= p_13)) * (float)p_13) - (float)(****l_916)) / (float)(**l_841)) , (*g_240)) == (void*)0) , 0xC.9146BFp+35) / (float)p_13) / (float)0x0.4p-1));
    return (**l_841);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_83 g_55.f0 g_509 g_380 g_381 g_253 g_127 g_240 g_241
 * writes: g_83
 */
static int32_t  func_20(int32_t  p_21)
{ /* block id: 5 */
    const int16_t l_233[7] = {(-2),(-2),(-2),(-2),(-2),(-2),(-2)};
    int32_t *l_406[3][6] = {{(void*)0,&g_83[0],&g_83[0],(void*)0,(void*)0,&g_83[0]},{(void*)0,(void*)0,&g_83[0],&g_83[0],(void*)0,(void*)0},{(void*)0,&g_83[0],&g_83[0],(void*)0,(void*)0,&g_83[0]}};
    union U1 l_425 = {0x8CB1};
    float l_445 = 0x2.376F4Dp+95;
    int32_t **l_469 = &l_406[2][3];
    int32_t ***l_468 = &l_469;
    float l_477[4][10] = {{0x6.349F0Ap-40,(-0x7.Bp+1),0x1.9p-1,0x6.5F1D5Ep+55,0x3.8DF679p+96,0x6.349F0Ap-40,0x6.349F0Ap-40,0x3.8DF679p+96,0x6.5F1D5Ep+55,0x1.9p-1},{(-0x7.Bp+1),(-0x7.Bp+1),0xE.5905F3p+1,0x9.8p-1,0x3.8DF679p+96,0xD.2CCD2Fp+47,(-0x7.Bp+1),0x3.8DF679p+96,0x4.617B76p+88,0x3.8DF679p+96},{(-0x7.Bp+1),0x6.349F0Ap-40,0x1.9p-1,0x9.8p-1,0x1.9p-1,0x6.349F0Ap-40,(-0x7.Bp+1),0x1.9p-1,0x6.5F1D5Ep+55,0x3.8DF679p+96},{0x6.349F0Ap-40,(-0x7.Bp+1),0x1.9p-1,0x6.5F1D5Ep+55,0x3.8DF679p+96,0x6.349F0Ap-40,0x6.349F0Ap-40,0x3.8DF679p+96,0x6.5F1D5Ep+55,0x1.9p-1}};
    float *l_492[6] = {&l_477[3][8],&l_477[3][8],&l_477[3][8],&l_477[3][8],&l_477[3][8],&l_477[3][8]};
    struct S0 l_506 = {-0x1.Fp+1};
    uint32_t l_511 = 4294967292U;
    int32_t *l_518 = &g_83[2];
    struct S0 ****l_532 = &g_509;
    uint16_t l_547[3][8][9] = {{{0xA0BF,2U,1U,0xDAFE,0x6139,0x6139,0xDAFE,1U,2U},{0xBDC7,0x59CB,0x2754,0xA866,0xA022,9U,0x2839,0U,0U},{65535U,1U,0x542B,0xCE82,0x5825,0x747D,0x810D,0x2839,0x225A},{6U,0x59CB,65526U,0xFE9C,0x03A9,0x6539,3U,0xA0BF,0x6139},{0U,2U,3U,0x542B,0xDAFE,0xA022,0x59CB,0x723D,65535U},{65527U,0x225A,0U,0xDB50,0xEBE7,0xA022,65533U,1U,0x2754},{1U,0x542B,0x747D,0x6539,2U,0x6539,0x747D,0x542B,1U},{0x03A9,0x7EBE,65527U,0x5825,1U,0x747D,1U,3U,0x2839}},{{0xCB51,0x810D,0x7320,0x9FC3,1U,9U,0U,0xA022,0x723D},{0x03A9,1U,1U,65535U,0xCB51,0x6139,0x0521,1U,0x5DF6},{1U,6U,0xCE82,0U,0x4A3F,0xC618,0xA0BF,0x9F5B,0x5825},{65527U,0x0521,0xBC4F,1U,0x4A3F,0x5DF6,0xA022,0xCE82,0xC618},{0U,0xA866,0x2BA3,0xCB51,0xCB51,0x2BA3,0xA866,0U,65527U},{6U,0U,2U,0x5825,0U,0U,0xA866,0xEBE7,0x723D},{0xA866,0x5DF6,6U,0xA0BF,0xA022,0x2839,0x2BA3,0x5825,0xF612},{1U,0xBDC7,65527U,0xBC4F,65526U,0xA0BF,0x5825,0xA866,0x6539}},{{65535U,0x225A,0x9F5B,3U,0xCB51,0x723D,0x4A3F,0x03A9,0x0521},{0xCB51,0x9FC3,65535U,3U,0xC618,1U,0xF612,0xBDC7,0xBDC7},{0x2754,0x542B,0U,0xBC4F,0U,0x542B,0x2754,0U,3U},{0xDAFE,1U,2U,0xA0BF,0x0521,3U,0xDB50,65529U,0U},{1U,65529U,0xC618,0x5825,0xBC4F,0xA022,0x9F5B,0U,0U},{0xA022,0U,0xA866,6U,65533U,1U,0x7EBE,0xBDC7,0x2839},{65527U,0x59CB,0xDB50,0xA022,0xBDC7,0x9F5B,0x7320,0x03A9,0xA866},{0x2BA3,0xFE9C,0xDB50,9U,3U,0xCE82,65533U,0xA866,65533U}}};
    int32_t l_590 = 0x0E65FA4F;
    uint32_t l_606 = 0x084ABC91;
    int32_t ****l_676 = (void*)0;
    int32_t *****l_675 = &l_676;
    float ****l_735 = (void*)0;
    float l_748 = 0x3.76E586p+90;
    int i, j, k;
    for (p_21 = 5; (p_21 < (-5)); --p_21)
    { /* block id: 8 */
        uint32_t l_41 = 9U;
        union U1 l_328[10][7][3] = {{{{0xAA1E},{1U},{65535U}},{{0U},{0U},{1U}},{{0U},{65526U},{65535U}},{{0U},{0U},{65535U}},{{0xFE7F},{65532U},{1U}},{{1U},{0U},{65535U}},{{65526U},{0x23FA},{65535U}}},{{{65532U},{0xFE7F},{1U}},{{0x23FA},{0xAA1E},{65535U}},{{0xAA1E},{1U},{65535U}},{{0U},{0U},{1U}},{{0U},{65526U},{65535U}},{{0U},{0U},{65535U}},{{0xFE7F},{65532U},{1U}}},{{{1U},{0U},{65535U}},{{65526U},{0x23FA},{65535U}},{{65532U},{0xFE7F},{1U}},{{0x23FA},{0xAA1E},{65535U}},{{0xAA1E},{1U},{65535U}},{{0U},{0U},{1U}},{{0U},{65526U},{65535U}}},{{{0U},{0U},{65535U}},{{0xFE7F},{65532U},{1U}},{{1U},{0U},{65535U}},{{65526U},{0x23FA},{65535U}},{{65532U},{0xFE7F},{1U}},{{0x23FA},{0xAA1E},{65535U}},{{0xAA1E},{1U},{65535U}}},{{{0U},{0U},{1U}},{{0U},{65526U},{65535U}},{{0U},{0U},{65535U}},{{0xFE7F},{0xB961},{65532U}},{{0xA8C6},{0x42D4},{0xFE7F}},{{0x73B8},{65528U},{0xFE7F}},{{0xB961},{0U},{65532U}}},{{{65528U},{0x5926},{0xFE7F}},{{0x5926},{0xA8C6},{0xFE7F}},{{0x7243},{0x7243},{65532U}},{{0x5946},{0x73B8},{0xFE7F}},{{0x42D4},{0x5946},{0xFE7F}},{{0U},{0xB961},{65532U}},{{0xA8C6},{0x42D4},{0xFE7F}}},{{{0x73B8},{65528U},{0xFE7F}},{{0xB961},{0U},{65532U}},{{65528U},{0x5926},{0xFE7F}},{{0x5926},{0xA8C6},{0xFE7F}},{{0x7243},{0x7243},{65532U}},{{0x5946},{0x73B8},{0xFE7F}},{{0x42D4},{0x5946},{0xFE7F}}},{{{0U},{0xB961},{65532U}},{{0xA8C6},{0x42D4},{0xFE7F}},{{0x73B8},{65528U},{0xFE7F}},{{0xB961},{0U},{65532U}},{{65528U},{0x5926},{0xFE7F}},{{0x5926},{0xA8C6},{0xFE7F}},{{0x7243},{0x7243},{65532U}}},{{{0x5946},{0x73B8},{0xFE7F}},{{0x42D4},{0x5946},{0xFE7F}},{{0U},{0xB961},{65532U}},{{0xA8C6},{0x42D4},{0xFE7F}},{{0x73B8},{65528U},{0xFE7F}},{{0xB961},{0U},{65532U}},{{65528U},{0x5926},{0xFE7F}}},{{{0x5926},{0xA8C6},{0xFE7F}},{{0x7243},{0x7243},{65532U}},{{0x5946},{0x73B8},{0xFE7F}},{{0x42D4},{0x5946},{0xFE7F}},{{0U},{0xB961},{65532U}},{{0xA8C6},{0x42D4},{0xFE7F}},{{0x73B8},{65528U},{0xFE7F}}}};
        int32_t **l_398 = &g_130;
        int32_t l_446 = (-9);
        float ***l_450 = &g_240;
        float ****l_449 = &l_450;
        int32_t ****l_481[7] = {&l_468,&l_468,(void*)0,&l_468,&l_468,(void*)0,&l_468};
        struct S0 ****l_510[3];
        int32_t l_561 = 0;
        uint32_t l_720 = 4294967295U;
        int32_t ***l_721 = &l_469;
        int i, j, k;
        for (i = 0; i < 3; i = i + 1)
            l_510[i] = (void*)0;
        if (g_2)
            break;
    }
    (*l_518) = ((int32_t)((int16_t)((((int16_t)((int16_t)((int16_t)((int32_t)(((+(*l_518)) , l_735) != l_735) + (int32_t)((uint16_t)((int32_t)((g_55.f0 & ((***l_532) != (**g_509))) , ((uint32_t)p_21 + (uint32_t)((*l_518) > p_21))) - (int32_t)4294967295U) << (uint16_t)p_21)) >> (int16_t)p_21) >> (int16_t)p_21) % (int16_t)g_253) , (*g_381)) , g_253) << (int16_t)2) % (int32_t)p_21);
    (*l_518) = (p_21 , (((int32_t)(((uint16_t)((int16_t)g_83[2] << (int16_t)(1 >= (g_253 & g_55.f0))) << (uint16_t)p_21) < (((void*)0 == (*g_240)) ^ ((g_55.f0 == p_21) == (-1)))) / (int32_t)p_21) < 0xC714B144));
    (*l_518) = 0x5626E7CF;
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads : g_166 g_253 g_167 g_83 g_241 g_127 g_55.f3.f0 g_380 g_2
 * writes: g_167 g_253 g_83 g_55.f3.f0
 */
static uint32_t  func_30(int16_t  p_31, uint32_t  p_32, union U1  p_33)
{ /* block id: 208 */
    uint32_t l_329 = 0x9D4D7828;
    int32_t *l_330 = &g_83[2];
    int16_t l_355 = 0x12E2;
    int32_t **l_361 = &l_330;
    int32_t ***l_360 = &l_361;
    int32_t ****l_359 = &l_360;
    int32_t *****l_358[7][5] = {{&l_359,&l_359,&l_359,&l_359,&l_359},{&l_359,&l_359,&l_359,&l_359,&l_359},{&l_359,&l_359,&l_359,&l_359,&l_359},{&l_359,&l_359,&l_359,&l_359,&l_359},{&l_359,&l_359,&l_359,&l_359,&l_359},{&l_359,&l_359,&l_359,&l_359,&l_359},{&l_359,&l_359,&l_359,&l_359,&l_359}};
    uint16_t l_371 = 0x5B61;
    struct S0 l_374[4] = {{0x9.Dp-1},{0x9.Dp-1},{0x9.Dp-1},{0x9.Dp-1}};
    const uint32_t l_377 = 0x7F9D6CCC;
    float ***l_378 = (void*)0;
    struct S0 **l_382[6][9] = {{(void*)0,&g_381,&g_381,(void*)0,&g_381,(void*)0,&g_381,&g_381,(void*)0},{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,(void*)0,&g_381,&g_381,&g_381},{&g_381,&g_381,(void*)0,(void*)0,&g_381,(void*)0,&g_381,(void*)0,&g_381},{&g_381,&g_381,&g_381,&g_381,&g_381,(void*)0,(void*)0,&g_381,(void*)0}};
    int i, j;
    if (l_329)
    { /* block id: 209 */
        struct S0 *l_346 = &g_55.f3;
        struct S0 **l_345 = &l_346;
        struct S0 ***l_344[2][5];
        int i, j;
        for (i = 0; i < 2; i = i + 1)
        {
            for (j = 0; j < 5; j = j + 1)
                l_344[i][j] = &l_345;
        }
        (*g_166) = l_330;
        /* statement id: 210 */
        assert ((g_167 >= &g_83[0] && g_167 <= &g_83[2]));
        for (g_253 = 1; (g_253 != (-21)); g_253 -= 2)
        { /* block id: 213 */
            struct S0 *l_343 = (void*)0;
            struct S0 **l_342 = &l_343;
            struct S0 ***l_341 = &l_342;
            uint16_t l_347 = 0xA161;
            float *l_354 = &g_55.f3.f0;
            (*l_330) = ((uint16_t)((int16_t)((int32_t)((int32_t)(l_341 == l_344[1][3]) + (int32_t)(p_33.f0 <= (l_347 , 0x038D1F01))) - (int32_t)((uint16_t)((int32_t)(((p_33.f0 != ((l_354 == g_167) != ((((((g_83[2] | l_355) || 0U) , p_33.f0) , &g_241) == &g_241) == l_347))) > 65533U) && p_33.f0) % (int32_t)p_32) * (uint16_t)(*l_330))) % (int16_t)p_33.f0) << (uint16_t)12);
            (*l_354) = 0xF.CBB987p+9;
            for (l_355 = 0; (l_355 >= 20); l_355 += 8)
            { /* block id: 218 */
                (*l_330) = 1;
                (*g_166) = l_354;
                /* statement id: 220 */
                assert (g_167 == &g_55.f3.f0);
                if ((*l_330))
                    break;
                if (p_32)
                    continue;
            }
        }
        /* facts after for loop */
        assert (g_167 == &g_55.f3.f0 || (g_167 >= &g_83[0] && g_167 <= &g_83[2]));
    }
    else
    { /* block id: 225 */
        (*g_241) = ((void*)0 != &g_240);
        l_358[0][1] = l_358[0][1];
    }
    /* facts after branching */
    //assert (g_167 == dangling || (g_167 >= &g_83[0] && g_167 <= &g_83[2]) || g_167 == 0 || g_167 == &g_55.f3.f0);
    for (g_253 = 0; (g_253 < (-9)); g_253 -= 9)
    { /* block id: 231 */
        float *****l_364 = (void*)0;
        const int32_t l_379 = 0xF519E8A7;
        l_364 = l_364;
        (*g_241) = p_33.f0;
        (*g_241) = ((float)((float)((((float)l_371 - (float)((((float)((l_374[3] , (g_127 , &g_165[0][1][0])) != (void*)0) + (float)((float)(l_377 , ((-0x2.Dp+1) > (l_378 == (void*)0))) * (float)l_379)) >= l_379) == (*l_330))) < (*g_241)) , l_379) * (float)0xA.143401p+50) / (float)0x7.3FCD9Ep+15);
        (*g_166) = &l_379;
        /* statement id: 235 */
        assert (g_167 == &l_379);
    }
    l_382[4][2] = g_380;
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_55.f2 g_83 g_166 g_253 g_55.f0 g_127 g_167 g_2 g_55.f3
 * writes: g_55.f2 g_167 g_253 g_83 g_130
 */
static int16_t  func_34(const uint32_t  p_35)
{ /* block id: 139 */
    const int32_t *l_248 = &g_83[0];
    int32_t *l_252 = &g_83[1];
    int32_t l_266 = (-5);
    float l_268 = 0xD.63A6ABp+86;
    float ***l_273 = &g_240;
    int32_t **l_289 = &g_130;
    int32_t ***l_288 = &l_289;
    int32_t ****l_287 = &l_288;
    struct S0 *l_294 = &g_127;
    struct S0 **l_293 = &l_294;
    const int32_t *l_296 = (void*)0;
    for (g_55.f2 = (-10); (g_55.f2 == 19); ++g_55.f2)
    { /* block id: 142 */
        const int32_t *l_249 = (void*)0;
        struct S0 l_321 = {0x5.38D7EEp-42};
        l_249 = l_248;
        /* statement id: 143 */
        assert ((l_249 >= &g_83[0] && l_249 <= &g_83[2]));
        if (((uint16_t)p_35 << (uint16_t)(*l_249)))
        { /* block id: 144 */
            float *l_258[7] = {&g_55.f3.f0,(void*)0,(void*)0,&g_55.f3.f0,(void*)0,(void*)0,&g_55.f3.f0};
            int32_t l_265 = 0x6CC6B5D0;
            struct S0 l_269 = {0x3.Cp+1};
            float ***l_272[7] = {&g_240,&g_240,&g_240,&g_240,&g_240,&g_240,&g_240};
            struct S0 *l_283[5][5] = {{&l_269,&g_127,&l_269,&l_269,&g_127},{(void*)0,&l_269,(void*)0,(void*)0,&l_269},{&l_269,&g_127,&l_269,&l_269,&g_127},{(void*)0,&l_269,(void*)0,(void*)0,&l_269},{&l_269,&g_127,&l_269,&l_269,&g_127}};
            struct S0 **l_282[5][4][6] = {{{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]}},{{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]}},{{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]}},{{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]}},{{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]},{(void*)0,&l_283[2][2],(void*)0,&l_283[2][2],(void*)0,&l_283[2][2]}}};
            const int32_t l_295 = 0xBDC24BC6;
            int32_t l_318 = 0x29E0859B;
            int i, j, k;
            (*g_166) = l_252;
            /* statement id: 145 */
            assert ((g_167 >= &g_83[0] && g_167 <= &g_83[2]));
            for (g_253 = 0; (g_253 <= (-23)); g_253 -= 1)
            { /* block id: 148 */
                uint32_t l_267[1][5][7] = {{{0x1F13ED7A,0xA1E7A8C1,0xA1E7A8C1,0x1F13ED7A,5U,3U,9U},{9U,0x1E76F382,2U,0xB6F4331D,0x0F0D1CF8,0x58A08477,3U},{4294967295U,5U,9U,0x1F13ED7A,9U,5U,4294967295U},{0xA1E7A8C1,0x1F13ED7A,5U,3U,9U,0x8CC197FE,0x1E76F382},{4294967295U,0x8CC197FE,0xB6F4331D,9U,0x0F0D1CF8,0x0F0D1CF8,9U}}};
                int32_t **l_279[9][8] = {{(void*)0,&l_252,&g_130,&l_252,&g_130,&l_252,&g_130,&g_130},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&g_130,(void*)0},{&l_252,&g_130,&l_252,&g_130,(void*)0,(void*)0,(void*)0,&g_130},{(void*)0,(void*)0,&g_130,&g_130,&g_130,&l_252,(void*)0,(void*)0},{(void*)0,&g_130,(void*)0,(void*)0,&l_252,&g_130,&l_252,&g_130},{(void*)0,&l_252,(void*)0,&l_252,(void*)0,&g_130,&g_130,&l_252},{(void*)0,&l_252,&g_130,&l_252,&l_252,(void*)0,(void*)0,&l_252},{&l_252,&g_130,&g_130,(void*)0,(void*)0,(void*)0,&g_130,&g_130},{&l_252,&l_252,(void*)0,&l_252,&l_252,&l_252,&l_252,&l_252}};
                struct S0 l_284 = {0x7.883884p+50};
                int i, j, k;
                (*g_166) = l_249;
                /* statement id: 149 */
                assert ((g_167 >= &g_83[0] && g_167 <= &g_83[2]));
                if ((((((*l_249) <= (&g_166 == &g_166)) , ((int16_t)(l_258[5] != ((((((int32_t)(g_83[2] <= p_35) % (int32_t)(((g_55.f2 < ((uint16_t)((((uint32_t)((l_265 , (1 <= 4294967295U)) , g_55.f0) / (uint32_t)l_266) , 0x21FC2793) | (-1)) << (uint16_t)8)) <= 0xC3EB) , l_267[0][3][2])) ^ p_35) , (*l_249)) || (*l_249)) , (void*)0)) >> (int16_t)(*l_249))) || g_83[1]) ^ 1U))
                { /* block id: 150 */
                    int32_t **l_270[7];
                    int32_t ***l_271 = &l_270[3];
                    int i;
                    for (i = 0; i < 7; i = i + 1)
                        l_270[i] = &l_252;
                    l_269 = g_127;
                    (*g_166) = (*g_166);
                    (*l_271) = l_270[3];
                    if ((***l_271))
                        continue;
                }
                else
                { /* block id: 155 */
                    return g_83[2];
                }
                if (((l_272[2] != l_273) || (((int16_t)((int16_t)((+((void*)0 != l_279[8][7])) < (l_265 && 0x1EB48717)) + (int16_t)((uint16_t)((0xF27A && ((l_282[4][0][1] != (void*)0) | 0)) , g_2) >> (uint16_t)p_35)) / (int16_t)p_35) , p_35)))
                { /* block id: 158 */
                    l_284 = g_55.f3;
                    if (((((l_287 == &g_165[2][1][1]) & (g_2 == ((*g_167) || (*l_249)))) && ((int16_t)((((-(uint16_t)((p_35 , (((l_293 == &l_294) < p_35) >= p_35)) & l_295)) , (*l_249)) < 0x2D1E) ^ p_35) % (int16_t)l_265)) == 0))
                    { /* block id: 160 */
                        int32_t *l_297 = &l_266;
                        l_296 = (*g_166);
                        /* statement id: 161 */
                        assert ((l_296 >= &g_83[0] && l_296 <= &g_83[2]));
                        (*g_166) = l_297;
                        /* statement id: 162 */
                        assert (g_167 == &l_266);
                        return g_83[2];
                        /* statement id: 163 */
                        //assert (g_167 == dangling);
                    }
                    else
                    { /* block id: 164 */
                        (*l_252) = p_35;
                    }
                }
                else
                { /* block id: 167 */
                    int32_t l_303 = 0xA5BFF3A3;
                    const struct S0 *l_307 = &g_55.f3;
                    const struct S0 **l_306[8];
                    int i;
                    for (i = 0; i < 8; i = i + 1)
                        l_306[i] = &l_307;
                    (*l_252) = ((p_35 | (0x34DD0C72 || 0xD87D5FD9)) ^ ((int16_t)((int16_t)(l_265 || (((p_35 | p_35) | p_35) & (-(uint32_t)(g_253 <= (((*l_248) == 65531U) > l_295))))) << (int16_t)p_35) << (int16_t)12));
                    (*g_166) = l_249;
                    if (l_303)
                    { /* block id: 170 */
                        float ****l_305[7] = {&l_272[1],&l_272[1],&l_272[1],&l_272[1],&l_272[1],&l_272[1],&l_272[1]};
                        float *****l_304 = &l_305[5];
                        const struct S0 ***l_308 = (void*)0;
                        int i;
                        (*l_252) = (*l_249);
                        (*l_304) = (void*)0;
                        l_306[7] = l_306[7];
                    }
                    else
                    { /* block id: 174 */
                        return l_303;
                    }
                }
                (*g_166) = &l_265;
                /* statement id: 178 */
                assert (g_167 == &l_265);
            }
            /* facts after for loop */
            assert (g_167 == &l_265 || (g_167 >= &g_83[0] && g_167 <= &g_83[2]));
            for (l_266 = 0; (l_266 <= 2); l_266 += 1)
            { /* block id: 182 */
                int16_t l_317[3];
                int i;
                for (i = 0; i < 3; i = i + 1)
                    l_317[i] = 0x1AEE;
                if ((((((uint32_t)(((((g_127 , (g_83[l_266] ^ ((((int32_t)4 % (int32_t)((int16_t)(((((((uint32_t)g_83[l_266] / (uint32_t)(g_55.f0 , p_35)) != p_35) > (0xA06AB12B == (0 <= l_317[2]))) , g_83[2]) ^ g_2) >= 6) << (int16_t)3)) <= p_35) > l_318))) | (*l_249)) != p_35) , g_83[1]) , 0x24B57395) % (uint32_t)1) | 65533U) || 0x6E5E) || g_55.f2))
                { /* block id: 183 */
                    uint32_t l_322 = 0xB9D4476A;
                    for (l_265 = 21; (l_265 > 23); ++l_265)
                    { /* block id: 186 */
                        l_321 = g_127;
                        l_322 = (*g_167);
                    }
                }
                else
                { /* block id: 190 */
                    int32_t *l_323 = &g_253;
                    if ((*l_249))
                        break;
                    if (g_83[l_266])
                        break;
                    (*l_289) = l_323;
                    /* statement id: 193 */
                    assert (g_130 == &g_253);
                }
            }
            /* facts after for loop */
            //assert (g_130 == &g_253 || g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0);
        }
        else
        { /* block id: 196 */
            return (*l_249);
        }
        /* facts after branching */
        //assert (g_130 == &g_253 || g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0);
        //assert (g_167 == dangling || (g_167 >= &g_83[0] && g_167 <= &g_83[2]));
        return p_35;
    }
    /* facts after for loop */
    for (l_266 = (-14); (l_266 > 4); ++l_266)
    { /* block id: 203 */
        int32_t *l_326 = &g_253;
        struct S0 ***l_327 = &l_293;
        (**l_288) = l_326;
        /* statement id: 204 */
        assert (g_130 == &g_253);
        (*l_327) = &l_294;
    }
    /* facts after for loop */
    //assert (g_130 == &g_253 || g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0);
    return g_83[2];
}


/* ------------------------------------------ */
/* 
 * reads : g_166 g_167 g_83
 * writes: g_167
 */
static const uint32_t  func_36(uint32_t  p_37, uint32_t  p_38, float  p_39, int32_t  p_40)
{ /* block id: 136 */
    (*g_166) = (*g_166);
    return g_83[2];
}


/* ------------------------------------------ */
/* 
 * reads : g_166 g_55.f2 g_55.f0
 * writes: g_55.f2 g_167 g_240 g_55.f0
 */
static float  func_42(int32_t  p_43, float  p_44, int16_t  p_45)
{ /* block id: 126 */
    float l_234[2];
    int32_t *l_235 = (void*)0;
    float *l_237 = &g_55.f3.f0;
    float **l_236 = &l_237;
    float ***l_238 = (void*)0;
    float ***l_239[7][4] = {{(void*)0,(void*)0,&l_236,&l_236},{&l_236,(void*)0,&l_236,&l_236},{&l_236,&l_236,&l_236,&l_236},{(void*)0,&l_236,&l_236,&l_236},{&l_236,(void*)0,&l_236,&l_236},{(void*)0,(void*)0,&l_236,&l_236},{&l_236,(void*)0,&l_236,&l_236}};
    int32_t l_245 = 0xB9BCC19F;
    int i, j;
    for (i = 0; i < 2; i = i + 1)
        l_234[i] = 0x0.D7AE1Dp-30;
    g_55.f2 = p_43;
    /* statement id: 127 */
    (*g_166) = l_235;
    /* statement id: 128 */
    assert (g_167 == 0);
    g_240 = (g_55.f2 , l_236);
    /* statement id: 129 */
    assert (g_240 == &l_237);
    for (g_55.f0 = 0; (g_55.f0 != 52); g_55.f0 += 4)
    { /* block id: 132 */
        uint32_t l_244[1][4] = {{0x50D92D6B,0x50D92D6B,0x50D92D6B,0x50D92D6B}};
        int i, j;
        return l_244[0][2];
        /* statement id: 133 */
        //assert (g_240 == dangling);
    }
    /* facts after for loop */
    return l_245;
    /* statement id: 135 */
    //assert (g_240 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_55.f0 g_55 g_2 g_83 g_165 g_166 g_167 g_127 g_55.f2
 * writes: g_55.f0 g_130 g_167 g_83 g_127 g_55.f1 g_55.f2
 */
static struct S0  func_50(union U1  p_51, uint32_t  p_52, int32_t  p_53, union U1  p_54)
{ /* block id: 10 */
    uint16_t l_80[9] = {1U,0U,1U,0U,1U,0U,1U,0U,1U};
    int32_t **l_231[3][5];
    int32_t ***l_230[3];
    struct S0 l_232 = {0x5.B666E4p+3};
    int i, j;
    for (i = 0; i < 3; i = i + 1)
    {
        for (j = 0; j < 5; j = j + 1)
            l_231[i][j] = &g_130;
    }
    for (i = 0; i < 3; i = i + 1)
        l_230[i] = &l_231[1][3];
    for (g_55.f0 = 0; (g_55.f0 < 56); g_55.f0 += 1)
    { /* block id: 13 */
        uint32_t l_77 = 0x6FEF6F1A;
        struct S0 *l_216 = &g_127;
        int32_t *l_219 = &g_83[2];
        (*l_216) = func_58(((-0x2.2p-1) >= (-0x8.Ap-1)), (p_54.f0 && ((int16_t)(((int16_t)(4294967289U ^ (func_70(g_55, (~(p_54.f0 > g_2)), (((int16_t)(l_77 != (((int32_t)((p_51.f0 != l_80[2]) ^ 0x1BF520F0) + (int32_t)0xA6CBABA2) , l_80[2])) << (int16_t)g_2) && p_53)) || l_80[2])) / (int16_t)0xB8D8) != 1U) * (int16_t)0U)), p_54.f0, p_54.f0, g_83[1]);
        for (p_52 = 0; (p_52 == 18); ++p_52)
        { /* block id: 100 */
            (*g_166) = l_219;
            if (p_53)
                continue;
            if (p_53)
                continue;
            return g_127;
        }
    }
    for (p_51.f0 = 0; (p_51.f0 > 60); ++p_51.f0)
    { /* block id: 109 */
        float *l_226 = &g_55.f1;
        int32_t **l_229 = &g_130;
        int32_t ***l_228 = &l_229;
        int32_t ****l_227 = &l_228;
        for (p_54.f2 = 8; (p_54.f2 <= (-27)); --p_54.f2)
        { /* block id: 112 */
            uint16_t l_224 = 65535U;
            int32_t *l_225 = &g_83[0];
            for (p_52 = 0; (p_52 <= 1); p_52 += 1)
            { /* block id: 115 */
                int i, j, k;
                if (p_53)
                    break;
            }
            if (p_51.f0)
                continue;
            (*l_225) = l_224;
        }
        /* facts after for loop */
                (*l_226) = p_54.f3.f0;
        /* statement id: 121 */
                g_55.f2 = ((((void*)0 != l_227) > g_55.f2) < p_54.f2);
        /* statement id: 122 */
                (*l_227) = l_230[2];
        /* statement id: 123 */
        assert ((l_228 >= &l_231[0][0] && l_228 <= &l_231[2][4]));
    }
    return l_232;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_165 g_166 g_83 g_167 g_55 g_55.f0 g_127
 * writes: g_130 g_167 g_83
 */
static struct S0  func_58(float  p_59, uint32_t  p_60, int32_t  p_61, uint32_t  p_62, int32_t  p_63)
{ /* block id: 51 */
    const uint32_t l_162 = 4294967289U;
    int32_t *l_170 = (void*)0;
    float l_173[8][8][4] = {{{(-0x1.9p-1),(-0x4.2p-1),(-0x1.Fp-1),0xA.842BFFp+58},{0x9.3p-1,(-0x9.1p-1),0x2.239478p-7,0xA.842BFFp+58},{0x7.BE6239p-83,(-0x4.2p-1),0xB.E6100Bp-84,0x0.4p-1},{(-0x1.Cp-1),0xA.C189EFp-78,0x8.B69750p-29,(-0x4.Fp-1)},{0xE.AB6CDAp-71,0x1.7p+1,0xF.2C0205p-97,0x4.524A1Ap+32},{(-0x1.7p+1),0x2.D73F8Bp+95,0x4.9p+1,0xC.477D5Bp+76},{0x8.05F298p+23,0xE.AB6CDAp-71,0x4.7CCA84p-13,0x4.4B399Ep+86},{0x8.2p+1,0x4.6p+1,0xB.E6100Bp-84,0x1.Fp+1}},{{0x0.Ap+1,0x5.Bp+1,0x4.2A52D8p+32,0xB.E6100Bp-84},{0x8.05F298p+23,0x1.Fp+1,0xA.16BB71p+13,(-0x1.9p-1)},{(-0x1.9p-1),(-0x4.9p+1),0x2.0246D1p-3,(-0x4.9p+1)},{0x8.B69750p-29,(-0x1.7p+1),0x1.Bp-1,(-0x5.2p+1)},{0x1.BDB4F0p+56,0x3.011349p-80,0xA.842BFFp+58,(-0x1.5p-1)},{0xF.2C0205p-97,0x1.Bp-1,0xF.D9C3D7p-4,(-0x1.8p-1)},{0x0.Ep-1,0x0.Ap+1,(-0x1.8p-1),0x1.1p-1},{0x0.Ap+1,0x3.011349p-80,0x0.FE078Dp-10,0x0.F7094Bp-19}},{{0x4.2A52D8p+32,0x8.B69750p-29,0x1.6p+1,(-0x4.9p+1)},{0x0.Ap+1,(-0x9.1p-1),0x0.Ap+1,0x1.Bp-1},{0xC.477D5Bp+76,0xA.DCF354p-59,(-0x4.0p+1),(-0x1.8p-1)},{0x2.239478p-7,(-0x9.1p+1),0x5.7A1B73p+69,0xA.DCF354p-59},{0x1.Bp-1,0xF.1E037Cp-19,0x5.7A1B73p+69,(-0x1.8p-1)},{0x2.239478p-7,(-0x1.7p+1),(-0x4.0p+1),0x4.6p+1},{0xC.477D5Bp+76,0x7.E92E3Bp+74,0x0.Ap+1,0xB.E6100Bp-84},{0x0.Ap+1,0xB.E6100Bp-84,0x1.6p+1,0x0.Ap+1}},{{0x4.2A52D8p+32,(-0x1.5p-1),0x0.FE078Dp-10,0x7.BE6239p-83},{0x0.Ap+1,0x0.2p+1,(-0x1.8p-1),(-0x4.Ap-1)},{0x0.Ep-1,(-0x1.7p+1),0xF.D9C3D7p-4,0x5.7A1B73p+69},{0xF.2C0205p-97,0xA.B08BCBp-63,0xA.842BFFp+58,0x7.BE6239p-83},{0x1.BDB4F0p+56,0x1.1p-1,0x1.Bp-1,(-0x1.8p-1)},{0x8.B69750p-29,0xB.E6100Bp-84,0x2.0246D1p-3,0x1.6p+1},{0x0.Ap+1,0x9.819D74p-0,(-0x4.2p-1),0x4.6p+1},{0x1.7p+1,0x8.B69750p-29,0x1.1p-1,0xA.FAA2BCp-10}},{{0xA.16BB71p+13,0xF.1E037Cp-19,0x0.Ap+1,0xF.D9C3D7p-4},{0x4.9p+1,0x7.BE6239p-83,0x6.85B24Bp-13,(-0x1.8p-1)},{0x1.7p+1,0xF.D9C3D7p-4,(-0x5.2p+1),0x0.Ap+1},{0x1.Bp-1,(-0x9.1p-1),0x2.0246D1p-3,0x2.0246D1p-3},{(-0x1.7p+1),(-0x1.7p+1),0x8.2p+1,0x0.F7094Bp-19},{0x1.BDB4F0p+56,0x7.CE4956p-31,0x0.Ap+1,(-0x1.5p-1)},{0x5.AF14A3p-60,0x0.Ap+1,0xF.D9C3D7p-4,0x0.Ap+1},{0x0.4p-1,0x0.Ap+1,(-0x2.5p+1),(-0x1.5p-1)}},{{0x0.Ap+1,0x7.CE4956p-31,0x6.B7C7C0p+32,0x0.F7094Bp-19},{0x4.7CCA84p-13,(-0x1.7p+1),0x1.6p+1,0x2.0246D1p-3},{(-0x1.8p-1),(-0x9.1p-1),0xA.842BFFp+58,0x0.Ap+1},{0xC.477D5Bp+76,0xF.D9C3D7p-4,(-0x9.1p+1),(-0x1.8p-1)},{0x1.4p-1,0x7.BE6239p-83,0x5.7A1B73p+69,0xF.D9C3D7p-4},{0x0.Ap+1,0xF.1E037Cp-19,0x2.D73F8Bp+95,0xA.FAA2BCp-10},{0x2.239478p-7,0x8.B69750p-29,(-0x9.1p+1),0x4.6p+1},{0x1.Fp+1,0x9.819D74p-0,0x0.Ap+1,0x1.6p+1}},{{(-0x1.8p-1),0xB.E6100Bp-84,(-0x4.Fp-1),(-0x1.8p-1)},{0x4.2A52D8p+32,0x1.1p-1,0x6.B7C7C0p+32,0x7.BE6239p-83},{0x1.Bp-1,0xA.B08BCBp-63,(-0x1.8p-1),0x5.7A1B73p+69},{0x0.4p-1,(-0x1.7p+1),(-0x1.Cp-1),(-0x4.Ap-1)},{0xF.2C0205p-97,0x0.2p+1,0x0.Ap+1,0x7.BE6239p-83},{(-0x1.Fp-1),(-0x1.5p-1),0x1.Bp-1,0x0.Ap+1},{(-0x1.7p+1),0xB.E6100Bp-84,0x1.6B515Ap+2,0xB.E6100Bp-84},{0x0.Ap+1,0x7.E92E3Bp+74,(-0x5.2p+1),0x4.6p+1}},{{0x0.Ep+1,(-0x1.7p+1),0x1.1p-1,(-0x1.8p-1)},{0x4.9p+1,0xF.1E037Cp-19,0xA.842BFFp+58,0xA.DCF354p-59},{0x4.9p+1,0x1.7A7CBFp+55,(-0x9.6p+1),0x5.7A1B73p+69},{(-0x4.Fp-1),(-0x1.Fp-1),0x2.76CAEAp+39,0x0.BE86AEp-32},{0xA.16BB71p+13,0x8.B69750p-29,(-0x9.1p-1),0x4.DB9FFAp+52},{0x1.Bp-1,0x8.2p+1,0x0.BE86AEp-32,0x0.2p+1},{(-0x2.5p+1),0x0.Ep+1,0x2.D73F8Bp+95,(-0x9.6p+1)},{0x2.0246D1p-3,0xA.16BB71p+13,0x1.BDB4F0p+56,0x5.7A1B73p+69}}};
    struct S0 l_174 = {-0x8.8p+1};
    int32_t *l_181 = &g_83[1];
    uint16_t l_188 = 0xD64F;
    int32_t **l_206 = &g_130;
    int32_t ***l_205 = &l_206;
    int32_t ****l_204[2][7][8] = {{{&l_205,&l_205,&l_205,&l_205,&l_205,&l_205,(void*)0,&l_205},{(void*)0,(void*)0,&l_205,(void*)0,(void*)0,&l_205,(void*)0,(void*)0},{&l_205,&l_205,&l_205,(void*)0,&l_205,&l_205,&l_205,&l_205},{(void*)0,&l_205,&l_205,(void*)0,(void*)0,&l_205,(void*)0,(void*)0},{(void*)0,&l_205,(void*)0,&l_205,&l_205,&l_205,&l_205,&l_205},{(void*)0,(void*)0,(void*)0,&l_205,(void*)0,&l_205,&l_205,&l_205},{(void*)0,&l_205,(void*)0,(void*)0,&l_205,(void*)0,&l_205,&l_205}},{{(void*)0,&l_205,&l_205,&l_205,(void*)0,&l_205,&l_205,(void*)0},{(void*)0,&l_205,&l_205,&l_205,&l_205,&l_205,&l_205,&l_205},{&l_205,&l_205,&l_205,(void*)0,(void*)0,&l_205,(void*)0,&l_205},{(void*)0,&l_205,&l_205,&l_205,&l_205,(void*)0,(void*)0,&l_205},{&l_205,&l_205,&l_205,&l_205,&l_205,(void*)0,&l_205,(void*)0},{&l_205,(void*)0,&l_205,(void*)0,&l_205,(void*)0,&l_205,&l_205},{&l_205,(void*)0,&l_205,(void*)0,&l_205,(void*)0,&l_205,(void*)0}}};
    int16_t l_208 = (-1);
    int i, j, k;
lbl_215:
    for (p_60 = 0; (p_60 <= 2); p_60 += 1)
    { /* block id: 54 */
        uint16_t l_171 = 0x57EC;
        for (p_61 = 0; (p_61 <= 2); p_61 += 1)
        { /* block id: 57 */
            struct S0 l_154 = {0x3.305F71p-65};
            int32_t **l_155 = &g_130;
            float *l_172 = &l_154.f0;
            for (p_63 = 2; (p_63 >= 0); p_63 -= 1)
            { /* block id: 60 */
                return l_154;
                /* statement id: 61 */
                //assert (g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0 || g_130 == &l_1546);
            }
            (*l_155) = &g_83[2];
            /* statement id: 63 */
            assert ((g_130 >= &g_83[0] && g_130 <= &g_83[2]));
            (*l_172) = (((p_63 != (((uint16_t)0xD02E << (uint16_t)13) || (((int16_t)(((int16_t)(g_2 , l_162) % (int16_t)(((uint16_t)((void*)0 == g_165[0][1][1]) >> (uint16_t)((((uint16_t)((void*)0 == l_170) % (uint16_t)l_171) == g_2) != p_60)) , 1)) > p_60) << (int16_t)3) , p_61))) , l_171) >= 0x8.41F5D6p+95);
        }
        if (l_171)
            break;
    }
    if (((void*)0 == &l_170))
    { /* block id: 68 */
        struct S0 *l_175 = &l_174;
        int32_t ***l_179 = (void*)0;
        int32_t ****l_178[2][8] = {{&l_179,&l_179,&l_179,&l_179,&l_179,&l_179,&l_179,&l_179},{&l_179,&l_179,&l_179,&l_179,&l_179,&l_179,&l_179,&l_179}};
        int i, j;
        (*l_175) = l_174;
        for (p_63 = 0; (p_63 <= 12); ++p_63)
        { /* block id: 72 */
            int32_t ****l_180 = &l_179;
            l_180 = l_178[1][0];
            if (p_62)
                continue;
        }
        l_170 = &p_61;
        /* statement id: 76 */
        assert (l_170 == &p_61);
        (*g_166) = l_181;
    }
    else
    { /* block id: 78 */
        int32_t **l_185 = &l_170;
        int32_t ***l_184[2];
        int32_t l_209 = (-1);
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_184[i] = &l_185;
        if ((0xF2F1483A != 0xFD3826E0))
        { /* block id: 79 */
            int16_t l_203 = (-1);
            int32_t ****l_207 = &l_184[1];
            (*g_166) = &p_61;
            /* statement id: 80 */
            assert (g_167 == &p_61);
            (*g_166) = l_181;
            /* statement id: 81 */
            assert ((g_167 >= &g_83[0] && g_167 <= &g_83[2]));
            g_83[1] = (((uint32_t)((((((((0xCB9D5BE6 && (l_184[1] != (((((uint32_t)l_188 - (uint32_t)(((uint32_t)(((int16_t)(((g_83[2] , ((int16_t)(((uint32_t)4294967295U / (uint32_t)((uint16_t)((int16_t)p_62 >> (int16_t)3) << (uint16_t)((**g_166) > (p_62 && ((int16_t)(g_55 , l_203) % (int16_t)p_61))))) ^ g_2) * (int16_t)p_61)) < g_55.f0) & 0x9565) << (int16_t)8) < p_61) - (uint32_t)p_60) != p_61)) || l_203) , p_60) , &l_185))) , l_204[0][3][0]) == l_207) && 0x307C) , l_208) , 0x6E28) ^ g_83[2]) , p_61) + (uint32_t)0xB383223A) , l_209);
        }
        else
        { /* block id: 83 */
            float *l_210 = &l_173[2][6][3];
            struct S0 *l_212 = &g_127;
            struct S0 **l_211 = &l_212;
            (*l_210) = 0x9.2FEA0Ep-94;
            (**l_205) = l_210;
            /* statement id: 85 */
            assert ((g_130 >= &l_173[0][0][0] && g_130 <= &l_173[7][7][3]));
            (*l_210) = p_61;
            (*l_211) = &l_174;
            /* statement id: 87 */
            assert (l_212 == &l_174);
        }
    }
    for (l_208 = 0; (l_208 >= (-17)); l_208--)
    { /* block id: 92 */
        if (g_55.f0)
            goto lbl_215;
        if ((**g_166))
            break;
    }
    return g_127;
    /* statement id: 96 */
    //assert (g_130 == dangling || (g_130 >= &g_83[0] && g_130 <= &g_83[2]) || g_130 == 0 || g_130 == &l_1546);
}


/* ------------------------------------------ */
/* 
 * reads : g_83
 * writes:
 */
static int16_t  func_70(union U1  p_71, const uint32_t  p_72, uint32_t  p_73)
{ /* block id: 14 */
    uint32_t l_81 = 0xF28F0E43;
    int32_t *l_82 = &g_83[2];
    struct S0 l_134 = {0x0.Fp-1};
    return g_83[2];
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_55.f0, "g_55.f0", print_hash_value);
    for (i = 0; i < 3; i = i + 1)
    {
        transparent_crc(g_83[i], "g_83[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc_bytes (&g_127.f0, sizeof(g_127.f0), "g_127.f0", print_hash_value);
    transparent_crc(g_253, "g_253", print_hash_value);
    transparent_crc(g_1042, "g_1042", print_hash_value);
    transparent_crc(g_1389, "g_1389", print_hash_value);
    transparent_crc(g_1441, "g_1441", print_hash_value);
    transparent_crc_bytes (&g_1464, sizeof(g_1464), "g_1464", print_hash_value);
    transparent_crc(g_1484, "g_1484", print_hash_value);
    transparent_crc(g_1577, "g_1577", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 411
   depth: 1, occurrence: 25
XXX total union variables: 22

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 215
   depth: 2, occurrence: 43
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 3
   depth: 27, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 288

XXX times a variable address is taken: 622
XXX times a pointer is dereferenced on RHS: 391
breakdown:
   depth: 1, occurrence: 200
   depth: 2, occurrence: 116
   depth: 3, occurrence: 40
   depth: 4, occurrence: 20
   depth: 5, occurrence: 15
XXX times a pointer is dereferenced on LHS: 195
breakdown:
   depth: 1, occurrence: 136
   depth: 2, occurrence: 32
   depth: 3, occurrence: 16
   depth: 4, occurrence: 10
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 74
XXX times a pointer is compared with address of another variable: 27
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 1978

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 852
   level: 2, occurrence: 451
   level: 3, occurrence: 144
   level: 4, occurrence: 89
   level: 5, occurrence: 146
XXX number of pointers point to pointers: 187
XXX number of pointers point to scalars: 69
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 27.4
XXX average alias set size: 1.36

XXX times a non-volatile is read: 2549
XXX times a non-volatile is write: 632
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 9

XXX stmts: 194
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 39
   depth: 2, occurrence: 36
   depth: 3, occurrence: 24
   depth: 4, occurrence: 34
   depth: 5, occurrence: 28

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

