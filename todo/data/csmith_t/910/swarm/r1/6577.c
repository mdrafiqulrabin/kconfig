/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      604346528
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   uint16_t  f5;
   int32_t  f6;
};

struct S1 {
   int32_t  f0;
   int16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const struct S1  func_27(void);
static struct S1  func_29(int32_t  p_30, int16_t  p_31);
static uint16_t  func_36(const int32_t  p_37, int32_t  p_38, uint16_t  p_39, uint16_t  p_40, uint32_t  p_41);
static int32_t  func_43(struct S1  p_44, uint16_t  p_45);
static int32_t * func_47(int32_t  p_48, int32_t * p_49, int32_t  p_50, struct S1  p_51);
static int32_t * func_52(uint32_t  p_53, int32_t * p_54, int32_t * p_55);
static int32_t * func_59(int16_t  p_60);
static struct S1  func_61(uint16_t  p_62, int32_t  p_63, const struct S1  p_64, struct S1  p_65, int32_t * p_66);
static struct S1  func_68(uint32_t  p_69, int32_t  p_70, int32_t * p_71, int32_t * p_72, uint16_t  p_73);
static int32_t * func_74(uint16_t  p_75);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S1  func_27(void)
{ /* block id: 36 */
    int16_t l_28 = 0xE39FL;
    struct S1 l_46 = {0xED0BD2F2L,0xD37FL};
    struct S1 *****l_1104 = (void*)0;
    int32_t *l_1130 = (void*)0;
    struct S1 ***l_1157 = (void*)0;
    struct S1 ****l_1156 = &l_1157;
    struct S1 l_1201 = {-6L,0L};
    struct S0 l_1225 = {0x6D56A591L,0xB3DC1160L,0L,8L,0xA437DADFL,65535UL,0x1E58BEF1L};
    int32_t l_1238 = 8L;
    struct S1 *l_1241 = &l_1201;
    struct S1 **l_1240 = &l_1241;
    int32_t l_1254 = 8L;
    struct S0 *l_1260 = (void*)0;
    struct S0 **l_1259 = &l_1260;
    struct S0 ***l_1258 = &l_1259;
    struct S0 ****l_1257 = &l_1258;
    struct S0 *****l_1256 = &l_1257;
    uint16_t l_1275 = 0x6591L;
    int32_t **l_1287 = &l_1130;
    int32_t ***l_1286 = &l_1287;
    int32_t ****l_1285 = &l_1286;
    int32_t *****l_1284 = &l_1285;
    int32_t *l_1302 = &l_1225.f3;
    uint32_t l_1319 = 4294967295UL;
    uint32_t l_1324 = 4294967295UL;
    struct S1 l_1349 = {0x7BB1D6E7L,-1L};
    uint16_t l_1358 = 1UL;
    uint32_t l_1384 = 0x044164A1L;
    int32_t l_1386 = 0x9EB8F51CL;
    int32_t l_1387 = 0xC6EDBBA1L;
    int32_t l_1390 = (-3L);
    int32_t l_1391 = 0x67FCB20CL;
    int32_t ***l_1392 = (void*)0;
    const uint16_t l_1404 = 0x816BL;
    int32_t l_1447 = 0x1BE5D0ABL;
    uint32_t l_1454 = 0xD2AA5159L;
    int16_t l_1467 = (-4L);
    int32_t l_1468 = 0x10DED26DL;
    uint32_t l_1469 = 0xDF31108BL;
    int16_t l_1470 = 0x2ADFL;
    uint32_t l_1471 = 0xA4221237L;
    int32_t l_1472 = 0xD0A51F60L;
    uint32_t l_1473 = 18446744073709551613UL;
    uint16_t l_1474 = 1UL;
    uint32_t l_1475 = 18446744073709551606UL;
    uint16_t l_1476 = 65533UL;
    const struct S1 l_1477 = {0xF22B52CDL,0x67EEL};
    if (l_28)
    { /* block id: 37 */
        uint32_t l_32 = 0xDAE974CAL;
        uint32_t l_762 = 4294967286UL;
        int32_t *l_1103 = &l_46.f0;
        struct S1 ****l_1106 = (void*)0;
        struct S1 *****l_1105 = &l_1106;
        int32_t **l_1116 = &l_1103;
        int32_t ***l_1115 = &l_1116;
        struct S0 l_1126 = {0xCD35965CL,0x93AB7195L,0x6ED7C771L,0x480D0A77L,18446744073709551615UL,65527UL,1L};
        struct S0 *l_1125 = &l_1126;
        struct S0 **l_1124 = &l_1125;
        const int32_t l_1148 = 0x32C236CCL;
        int32_t ***l_1202 = &l_1116;
        struct S1 l_1204 = {2L,0xE32DL};
        struct S1 *l_1205 = &l_1204;
lbl_1118:
        (*l_1103) = ((func_29(l_28, ((l_28 , l_32) & (((safe_div_func_uint16_t_u_u((~func_36(l_28, (~(0UL < l_28)), (((((func_43(l_46, l_32) || l_46.f0) | l_762) , l_46.f0) != l_28) , l_762), l_46.f1, l_46.f0)), 0x1028L)) , 18446744073709551610UL) , 0xEAACB906L))) , 0x72B9L) & 0xAC4FL);
        l_1105 = l_1104;
        /* statement id: 647 */
        assert (l_1105 == 0);
        for (l_762 = (-15); (l_762 != 36); ++l_762)
        { /* block id: 650 */
            const int16_t l_1109 = 0xD2C8L;
            int32_t l_1121 = (-10L);
            const struct S1 l_1123 = {5L,1L};
            struct S0 ***l_1127 = &l_1124;
            int32_t ***l_1145 = &l_1116;
            struct S1 l_1164 = {-1L,7L};
            struct S1 *l_1175 = &l_46;
            struct S1 **l_1174 = &l_1175;
            if (l_1109)
            { /* block id: 651 */
                const struct S1 l_1112 = {0x4C8FDB9EL,0xDD34L};
                if (l_1109)
                { /* block id: 652 */
                    int32_t ***l_1117 = &l_1116;
                    const struct S1 l_1122 = {-6L,-1L};
                    for (l_32 = 11; (l_32 >= 38); l_32 = safe_add_func_uint16_t_u_u(l_32, 2))
                    { /* block id: 655 */
                        return l_1112;
                    }
                    for (l_46.f0 = 0; (l_46.f0 < (-8)); l_46.f0 = safe_sub_func_int16_t_s_s(l_46.f0, 1))
                    { /* block id: 660 */
                        l_1117 = l_1115;
                        if (l_46.f0)
                            goto lbl_1118;
                        l_1121 = (4UL == (l_1112 , (safe_rshift_func_int16_t_s_s(l_1112.f0, 10))));
                        return l_1122;
                    }
                }
                else
                { /* block id: 666 */
                    return l_1112;
                }
            }
            else
            { /* block id: 669 */
                return l_1123;
            }
            (*l_1127) = l_1124;
        }
        (*l_1205) = l_1204;
    }
    else
    { /* block id: 717 */
        int32_t l_1206 = 0xE721D726L;
        struct S1 **l_1219 = (void*)0;
        struct S1 ***l_1218 = &l_1219;
        uint16_t l_1228 = 0x2775L;
        int32_t **l_1234 = (void*)0;
        int32_t ***l_1233 = &l_1234;
        struct S0 **l_1239 = (void*)0;
        int16_t l_1246 = 0xF1D5L;
        int32_t l_1251 = 0x13BFB694L;
        const uint16_t l_1283 = 0x09AFL;
        int32_t *****l_1288 = &l_1285;
        uint32_t l_1361 = 1UL;
        uint32_t l_1371 = 0UL;
        uint16_t l_1372 = 1UL;
        struct S0 **l_1373 = &l_1260;
        struct S1 *****l_1385 = (void*)0;
        struct S1 l_1388 = {0x00214B0EL,0x2A95L};
        int32_t l_1389 = 0x3E5ABB0FL;
        const uint32_t l_1441 = 0x189705EBL;
        if ((l_1206 || l_1206))
        { /* block id: 718 */
            struct S0 l_1213 = {0x4AA918BDL,-1L,0x61B4B2ACL,0x962E70C8L,5UL,0x8E02L,-2L};
            const struct S1 *l_1216 = (void*)0;
            const struct S1 **l_1215 = &l_1216;
            const struct S1 ***l_1214 = &l_1215;
            struct S0 l_1227 = {0x2637D438L,1L,0x646986D9L,0xCAD646ADL,18446744073709551615UL,0UL,0xD3C79E14L};
            for (l_1201.f1 = 0; (l_1201.f1 == 11); l_1201.f1 = safe_add_func_uint32_t_u_u(l_1201.f1, 1))
            { /* block id: 721 */
                int32_t l_1209 = 2L;
                const struct S1 l_1210 = {0L,1L};
                if (l_1209)
                    break;
                return l_1210;
            }
            for (l_1206 = 0; (l_1206 >= (-18)); l_1206 = safe_sub_func_uint32_t_u_u(l_1206, 1))
            { /* block id: 727 */
                int16_t l_1217 = 0xD221L;
                int32_t **l_1226 = &l_1130;
                int32_t *l_1229 = &l_1201.f0;
                (*l_1226) = func_74((l_1206 >= ((((l_1213 , l_1214) == (l_1217 , l_1218)) & ((safe_unary_minus_func_int32_t_s((safe_add_func_int16_t_s_s((safe_div_func_uint16_t_u_u(l_1206, (l_1225 , l_1213.f3))), l_1206)))) > 0L)) == l_1217)));
                l_1213.f3 = 2L;
                (*l_1229) = (l_1227 , l_1228);
                (*l_1229) = l_1227.f6;
            }
            for (l_1225.f5 = (-25); (l_1225.f5 > 15); l_1225.f5 = safe_add_func_int16_t_s_s(l_1225.f5, 4))
            { /* block id: 735 */
                const struct S1 l_1232 = {1L,3L};
                return l_1232;
            }
        }
        else
        { /* block id: 738 */
            int32_t ****l_1235 = &l_1233;
            struct S1 ***l_1242 = &l_1240;
            int16_t l_1243 = 0xBDA6L;
            uint16_t l_1274 = 65535UL;
            uint32_t l_1347 = 0UL;
            int32_t *l_1351 = &l_1225.f3;
            struct S1 l_1353 = {6L,-1L};
            (*l_1235) = l_1233;
            if (((safe_rshift_func_int16_t_s_u(l_1238, 4)) ^ (((l_1239 != (void*)0) < (-7L)) != (((*l_1218) == l_1240) == ((0x9F5DL ^ ((l_1242 == (void*)0) != l_1243)) != 4UL)))))
            { /* block id: 740 */
lbl_1335:
                l_1130 = func_74(l_1243);
            }
            else
            { /* block id: 742 */
                uint16_t l_1250 = 0x3A54L;
                const struct S1 l_1255 = {0x742BB7F9L,-1L};
                if (((((safe_div_func_uint32_t_u_u(l_1246, (((safe_rshift_func_uint16_t_u_u((!(l_1201.f1 | l_1243)), func_36(((l_1250 , l_1250) == (l_1251 > l_1225.f3)), l_1250, (safe_div_func_uint32_t_u_u(l_1254, (-1L))), l_1250, l_1201.f0))) <= l_1250) ^ l_1250))) >= 0xAF07L) && l_1225.f2) | l_1243))
                { /* block id: 743 */
                    return l_1255;
                }
                else
                { /* block id: 745 */
                    struct S0 *****l_1261 = &l_1257;
                    l_1261 = l_1256;
                    return l_1255;
                }
            }
            if (((safe_mod_func_uint16_t_u_u((((safe_sub_func_int32_t_s_s(((l_1243 != (safe_lshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(l_1225.f1, __builtin_parityll(l_1274))), l_1275)), 6))) < ((safe_div_func_uint32_t_u_u(((((safe_unary_minus_func_int32_t_s(l_1274)) > l_1225.f0) == l_1225.f2) <= (safe_mod_func_int32_t_s_s((safe_lshift_func_int16_t_s_s(0x769FL, l_1283)), l_1238))), l_1274)) > 0L)), 0x71979C6CL)) , l_1284) != l_1288), 65535UL)) < l_1243))
            { /* block id: 750 */
                struct S1 *l_1289 = (void*)0;
                struct S0 *l_1291 = (void*)0;
                (**l_1242) = l_1289;
                /* statement id: 751 */
                assert (l_1241 == 0);
                if (l_1246)
                    goto lbl_1290;
lbl_1290:
                (****l_1256) = (*l_1259);
                (****l_1256) = l_1291;
            }
            else
            { /* block id: 755 */
                uint32_t l_1299 = 0x89755871L;
                int32_t l_1303 = (-5L);
                struct S1 l_1304 = {-5L,-1L};
                struct S1 **l_1305 = (void*)0;
                int32_t l_1306 = 1L;
                uint16_t l_1323 = 0x108DL;
                struct S0 *l_1325 = &l_1225;
                uint16_t l_1332 = 0xC616L;
                int32_t *l_1333 = &l_46.f0;
                int32_t l_1350 = (-1L);
                int16_t l_1352 = (-1L);
                for (l_1254 = 13; (l_1254 > 1); l_1254 = safe_sub_func_uint16_t_u_u(l_1254, 5))
                { /* block id: 758 */
                    int16_t l_1297 = 1L;
                    const int32_t *l_1298 = (void*)0;
                    struct S1 l_1307 = {0xAC6E6E0AL,0xE3D5L};
                    uint32_t l_1312 = 4294967295UL;
                    int32_t *l_1334 = (void*)0;
                    uint32_t l_1342 = 0xECACC0AEL;
                    const int16_t l_1348 = 7L;
                    for (l_1225.f4 = (-4); (l_1225.f4 > 8); l_1225.f4 = safe_add_func_int16_t_s_s(l_1225.f4, 5))
                    { /* block id: 761 */
                        int32_t l_1296 = 9L;
                        (**l_1242) = (**l_1242);
                        l_1307 = func_29(l_1296, func_36(((l_1304 , l_1305) != (*l_1218)), l_1299, l_1306, l_1243, l_1296));
                        (**l_1240) = (***l_1242);
                        (*l_1287) = (void*)0;
                    }
                    for (l_1299 = 23; (l_1299 <= 58); l_1299 = safe_add_func_int32_t_s_s(l_1299, 8))
                    { /* block id: 769 */
                        uint16_t l_1320 = 65535UL;
                        struct S0 *l_1326 = (void*)0;
                        int32_t l_1327 = 0xB0971DD5L;
                        l_1327 = ((((safe_lshift_func_uint16_t_u_u(65527UL, l_1312)) , ((safe_add_func_int16_t_s_s((l_1306 , l_1306), (safe_sub_func_int16_t_s_s((l_1304.f0 ^ ((safe_mul_func_int16_t_s_s(((0x26438B18L | l_1319) >= (l_1320 & ((((((safe_lshift_func_uint16_t_u_s((l_1304.f0 < l_1323), 4)) || l_1324) , l_1325) != l_1326) | 0x9B245055L) > 0L))), 1L)) , l_1320)), 0UL)))) , l_1327)) != l_1303) ^ l_1327);
                    }
                    for (l_1251 = 0; (l_1251 < (-2)); l_1251 = safe_sub_func_int32_t_s_s(l_1251, 1))
                    { /* block id: 774 */
                        int16_t l_1330 = 0x1F27L;
                        struct S1 l_1331 = {0x6376BE36L,5L};
                        (***l_1242) = func_61(l_1330, l_1304.f0, (***l_1242), l_1331, (l_1307 , l_1334));
                        if (l_1306)
                            goto lbl_1335;
                        (**l_1286) = (***l_1285);
                        l_1333 = (void*)0;
                        /* statement id: 778 */
                        assert (l_1333 == 0);
                    }
                    (**l_1240) = ((safe_mul_func_uint16_t_u_u(((func_43((**l_1240), (*l_1351)) , l_1299) != l_1352), l_1306)) , (**l_1240));
                }
                /* facts after for loop */
                assert (l_1333 == 0 || l_1333 == &l_46.f0);
                (***l_1242) = l_1353;
                (***l_1242) = (**l_1240);
                (***l_1242) = (***l_1242);
            }
            /* facts after branching */
            assert (l_1241 == &l_1201 || l_1241 == 0);
        }
        /* facts after branching */
        assert (l_1241 == &l_1201 || l_1241 == 0);
        (*l_1302) = ((*l_1302) >= (safe_sub_func_uint16_t_u_u(((safe_div_func_int16_t_s_s((((l_1358 < (*l_1302)) , l_1206) && ((*l_1302) , (safe_lshift_func_int16_t_s_u(((*l_1302) != l_1228), ((***l_1288) != (((*l_1302) , 7UL) , (*l_1286))))))), (-7L))) < l_1251), l_1361)));
lbl_1443:
        for (l_1238 = (-15); (l_1238 <= (-4)); l_1238++)
        { /* block id: 790 */
            struct S0 **l_1364 = &l_1260;
            int32_t l_1367 = 0x034C5631L;
            const int32_t *l_1370 = (void*)0;
            const int32_t **l_1369 = &l_1370;
            const int32_t ***l_1368 = &l_1369;
            (**l_1257) = l_1364;
            (*l_1302) = (safe_lshift_func_uint16_t_u_u((((l_1367 , l_1368) == (l_1371 , (**l_1288))) ^ ((((l_1372 ^ (((l_1367 , l_1373) == (((*l_1257) == (void*)0) , (void*)0)) || 4294967289UL)) & l_1206) && (*l_1302)) <= l_1251)), 3));
            (**l_1368) = (****l_1288);
            (*l_1302) = (safe_mod_func_int16_t_s_s(((safe_div_func_uint16_t_u_u(l_1251, ((safe_mul_func_int16_t_s_s((safe_add_func_int32_t_s_s(0x7C69943FL, l_1283)), ((safe_mul_func_uint32_t_u_u(__builtin_clz(l_1384), (l_1385 == l_1385))) >= func_43(l_1388, l_1389)))) , l_1367))) == l_1390), l_1391));
        }
        if ((l_1392 != (void*)0))
        { /* block id: 796 */
            struct S1 l_1397 = {-9L,0xA694L};
            struct S1 *l_1400 = &l_1349;
            (*l_1302) = (((((safe_lshift_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(func_43(l_1397, l_1397.f1), (safe_div_func_uint32_t_u_u((&l_1397 == l_1400), l_1397.f1)))) & ((l_1397.f1 <= (func_43((*l_1400), (safe_rshift_func_uint16_t_u_s((l_1397.f1 , 0x1530L), l_1397.f1))) , l_1397.f1)) & l_1397.f1)), 2)) ^ 4UL) | l_1397.f1) < 9UL) , l_1397.f0);
            (****l_1284) = (***l_1285);
            (*l_1287) = (*l_1287);
        }
        else
        { /* block id: 800 */
            uint32_t l_1403 = 0x1BEAD3E4L;
            int32_t *l_1428 = &l_1206;
            const struct S1 l_1446 = {1L,0xF88AL};
            if ((l_1403 <= l_1404))
            { /* block id: 801 */
                const struct S1 l_1405 = {3L,0x31A8L};
                (**l_1286) = (****l_1288);
                return l_1405;
            }
            else
            { /* block id: 804 */
                uint16_t l_1410 = 65531UL;
                const int16_t l_1411 = (-1L);
                int32_t l_1412 = 0L;
                int16_t l_1425 = 0xFA05L;
                int32_t l_1437 = 0x0E14BFF1L;
                struct S1 l_1442 = {-6L,0xDF59L};
                if ((((*l_1302) | (((0x69B9L > (0UL ^ ((safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(0x8B1AL, 8)), l_1403)) > (l_1410 , ((((l_1403 || l_1403) >= 0x5861L) == l_1410) , l_1410))))) | 65530UL) < l_1403)) == l_1411))
                { /* block id: 805 */
                    const uint32_t l_1426 = 0xD0AD9A37L;
                    l_1412 = l_1403;
                    for (l_1358 = 4; (l_1358 != 43); l_1358 = safe_add_func_int32_t_s_s(l_1358, 1))
                    { /* block id: 809 */
                        (*l_1302) = (safe_lshift_func_uint16_t_u_u(l_1403, (safe_rshift_func_uint16_t_u_s(l_1411, 9))));
                    }
                    if (l_1410)
                    { /* block id: 812 */
                        int32_t *l_1419 = &l_1389;
                        int32_t l_1422 = 0x3829E931L;
                        (****l_1284) = l_1419;
                        /* statement id: 813 */
                        assert (l_1130 == &l_1389);
                        (*l_1130) = (safe_div_func_uint16_t_u_u((l_1422 == ((safe_rshift_func_int16_t_s_u((2L != l_1425), 7)) == (4L < l_1426))), (safe_unary_minus_func_int32_t_s((65535UL != 0UL)))));
                        (****l_1288) = ((l_1410 , ((*l_1130) > 1UL)) , l_1428);
                        /* statement id: 815 */
                        assert (l_1130 == &l_1206);
                        (****l_1284) = (void*)0;
                        /* statement id: 816 */
                        assert (l_1130 == 0);
                    }
                    else
                    { /* block id: 817 */
                        l_1412 = (-1L);
                    }
                    return l_1388;
                }
                else
                { /* block id: 821 */
                    uint32_t l_1432 = 0xFB34010AL;
                    if ((!(safe_add_func_int16_t_s_s(l_1432, __builtin_ffs((*l_1428))))))
                    { /* block id: 822 */
                        int32_t l_1438 = (-8L);
                        (*l_1302) = (safe_rshift_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u(l_1437, l_1438)), func_43((((safe_sub_func_uint16_t_u_u((*l_1428), (((l_1432 == __builtin_ctzl((*l_1428))) || l_1441) ^ (l_1425 < 1L)))) >= (-2L)) , l_1442), l_1432)));
                        if (l_1391)
                            goto lbl_1443;
                    }
                    else
                    { /* block id: 825 */
                        uint16_t l_1444 = 0UL;
                        const struct S1 l_1445 = {0x6727BA0FL,0x588FL};
                        (*l_1428) = ((l_1444 , l_1412) , l_1444);
                        return l_1445;
                    }
                    (****l_1288) = func_59((*l_1302));
                    return l_1446;
                }
            }
        }
    }
    /* facts after branching */
    assert (l_1241 == &l_1201 || l_1241 == 0);
    (*l_1302) = ((l_1447 , ((safe_sub_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s((l_1225 , func_36((l_1349 , (*l_1302)), func_43(((safe_div_func_int32_t_s_s((l_1454 , (safe_sub_func_int32_t_s_s(((((((65535UL && (safe_div_func_uint16_t_u_u(((safe_div_func_int32_t_s_s(__builtin_clzll((func_29((((safe_sub_func_int32_t_s_s((((safe_add_func_int16_t_s_s(0xEE6FL, (safe_div_func_int32_t_s_s((*l_1302), func_36((*l_1302), l_1467, (*l_1302), l_1468, l_1469))))) && 0xDACAL) != (*l_1302)), (*l_1302))) , (**l_1258)) == (****l_1256)), (*l_1302)) , 18446744073709551615UL)), l_1470)) >= (*l_1302)), 65526UL))) | l_1471) > l_1472) , (**l_1285)) == (*l_1286)) != l_1473), 1L))), (*l_1302))) , l_1349), (*l_1302)), (*l_1302), l_1474, l_1475)), 0x41A6L)) > (*l_1302)), 0x149FL)) , l_1476)) & 65534UL);
    return l_1477;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_29(int32_t  p_30, int16_t  p_31)
{ /* block id: 552 */
    int32_t l_893 = 0x2579E515L;
    struct S1 l_896 = {0L,0xBB25L};
    struct S1 *l_895 = &l_896;
    struct S1 **l_894 = &l_895;
    int32_t *l_897 = &l_896.f0;
    int16_t l_900 = 1L;
    int16_t l_902 = 1L;
    int32_t **l_907 = &l_897;
    int32_t ***l_906 = &l_907;
    int32_t ****l_905 = &l_906;
    int32_t l_908 = 0x044F19D4L;
    struct S1 ***l_914 = (void*)0;
    struct S1 ****l_913 = &l_914;
    struct S0 l_922 = {4L,-6L,0x8A87F399L,-1L,1UL,0x21C4L,0x95E28EF6L};
    int32_t l_968 = 1L;
    struct S0 *l_973 = &l_922;
    struct S0 **l_972 = &l_973;
    struct S0 ***l_971 = &l_972;
    struct S0 ****l_970 = &l_971;
    struct S0 *****l_969 = &l_970;
    uint32_t l_1079 = 0UL;
    uint16_t l_1080 = 65535UL;
    uint16_t l_1085 = 65533UL;
    int32_t l_1088 = 0x636A2BFBL;
    struct S1 l_1102 = {0x16DEB785L,0L};
    l_897 = func_52(((safe_mul_func_int16_t_s_s((-1L), ((!l_893) == p_30))) | (l_893 , ((void*)0 != l_894))), func_47(p_30, l_897, p_30, (**l_894)), l_897);
    /* statement id: 553 */
    assert (l_897 == 0);
    if (__builtin_popcountll(((__builtin_clzll(l_900) == (safe_unary_minus_func_uint32_t_u(__builtin_ffs(l_902)))) ^ (0L & (safe_add_func_int16_t_s_s(((p_30 , (l_905 != &l_906)) > p_31), l_908))))))
    { /* block id: 554 */
        uint32_t l_909 = 1UL;
        const int32_t *l_910 = &l_908;
        struct S1 l_912 = {-1L,0xC8D3L};
        struct S1 *****l_915 = &l_913;
        int32_t *l_946 = &l_896.f0;
        if (l_909)
        { /* block id: 555 */
            int32_t **l_911 = &l_897;
            (*l_911) = l_910;
            /* statement id: 556 */
            assert (l_897 == &l_908);
        }
        else
        { /* block id: 557 */
            (*l_895) = (**l_894);
            (*l_894) = (*l_894);
            (*l_895) = l_912;
        }
        /* facts after branching */
        assert (l_897 == 0 || l_897 == &l_908);
        (*l_915) = l_913;
        for (l_896.f1 = 0; (l_896.f1 <= (-17)); l_896.f1 = safe_sub_func_int16_t_s_s(l_896.f1, 8))
        { /* block id: 565 */
            uint16_t l_920 = 65535UL;
            struct S0 l_921 = {0x499D654CL,0L,0L,0x19368C98L,0UL,65526UL,0xED45DA4AL};
            int32_t *l_931 = &l_922.f3;
            (*l_931) = ((safe_rshift_func_uint16_t_u_s(l_920, ((l_921 , l_922) , (0x047DL >= (0xD5E07FA9L >= (0xF540L ^ (safe_rshift_func_int16_t_s_u((safe_sub_func_uint32_t_u_u((((((safe_mod_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(p_30, __builtin_ffsll((*l_910)))), 9UL)) ^ 0xEE7CL) , (void*)0) == &l_905) | 0x4D9CL), p_31)), 1)))))))) == 0x52D66F23L);
            if (p_30)
                continue;
        }
        (*l_946) = (safe_mul_func_int16_t_s_s((safe_sub_func_int32_t_s_s(p_31, (safe_rshift_func_uint16_t_u_u((p_31 >= p_31), p_31)))), (safe_add_func_uint32_t_u_u(((safe_add_func_int32_t_s_s(((((*l_910) && 65531UL) || p_30) >= (safe_lshift_func_int16_t_s_s(7L, (safe_rshift_func_int16_t_s_u((*l_910), 3))))), 0xBC59A21CL)) <= (*l_910)), p_30))));
    }
    else
    { /* block id: 570 */
        struct S1 l_947 = {0xA892AEDEL,0xEF1AL};
        (*l_907) = &p_30;
        /* statement id: 571 */
        assert (l_897 == &p_30);
        return l_947;
    }
    /* facts after branching */
    assert (l_897 == 0 || l_897 == &l_908);
    for (p_31 = 0; (p_31 != (-10)); p_31 = safe_sub_func_uint32_t_u_u(p_31, 1))
    { /* block id: 576 */
        uint32_t l_950 = 0x12231DFAL;
        int32_t l_951 = 0L;
        struct S1 l_979 = {0xA99F45A9L,0x2B9FL};
        struct S0 ****l_994 = &l_971;
        uint16_t l_1100 = 1UL;
        int32_t *l_1101 = &l_968;
        l_951 = (p_31 || (p_31 >= ((*l_895) , l_950)));
        for (l_922.f4 = 0; (l_922.f4 >= 5); l_922.f4 = safe_add_func_int32_t_s_s(l_922.f4, 7))
        { /* block id: 580 */
            uint16_t l_961 = 0UL;
            uint32_t l_1001 = 0x6797C3D7L;
            struct S1 l_1016 = {1L,3L};
            struct S1 ***l_1039 = &l_894;
            int32_t *l_1051 = (void*)0;
            struct S0 ***l_1068 = &l_972;
            int32_t *l_1081 = &l_951;
            for (l_951 = 16; (l_951 == (-1)); l_951 = safe_sub_func_int16_t_s_s(l_951, 1))
            { /* block id: 583 */
                uint32_t l_958 = 3UL;
                int32_t *l_980 = &l_908;
                struct S1 l_983 = {0xE37C4A47L,-4L};
                struct S1 l_1014 = {0xF178C2C3L,0L};
                int16_t l_1028 = (-1L);
                uint16_t l_1040 = 0x387AL;
            }
            if (l_1016.f0)
            { /* block id: 624 */
                int32_t l_1062 = 0x924E0C9EL;
                int32_t *l_1065 = &l_922.f2;
                (**l_906) = l_1051;
                /* statement id: 625 */
                assert (l_897 == 0);
                if (p_31)
                    continue;
                if (((((((safe_add_func_uint32_t_u_u((safe_sub_func_int32_t_s_s((p_30 > l_1016.f1), ((safe_mul_func_int16_t_s_s(p_30, (safe_sub_func_int32_t_s_s((l_951 || (safe_div_func_uint16_t_u_u(((***l_971) , 65526UL), l_1062))), (p_31 != (safe_mod_func_uint32_t_u_u(((((((l_979.f0 == l_979.f1) > 1UL) <= 0x825BL) <= l_1062) ^ p_31) , p_31), p_31))))))) || p_30))), 0xEA1B0C6BL)) >= 0xAF1F4383L) == l_1062) != l_979.f0) | l_1062) | 0xFC45DB69L))
                { /* block id: 627 */
                    l_1065 = (*l_907);
                    /* statement id: 628 */
                    assert (l_1065 == 0);
                    l_1016.f0 = p_30;
                }
                else
                { /* block id: 630 */
                    (*l_1065) = ((*l_1065) <= (safe_unary_minus_func_int16_t_s((p_30 > (*l_1065)))));
                    if (p_31)
                        continue;
                }
                /* facts after branching */
                assert (l_1065 == &l_922.f2 || l_1065 == 0);
            }
            else
            { /* block id: 634 */
                int32_t *l_1067 = &l_908;
                int32_t *l_1082 = (void*)0;
                (*l_1067) = p_31;
                (**l_969) = l_1068;
                (**l_906) = func_52((safe_unary_minus_func_uint32_t_u((safe_rshift_func_uint16_t_u_s(func_43((***l_1039), p_31), (l_951 > (p_31 || ((safe_rshift_func_uint16_t_u_u(65526UL, 9)) <= (safe_mul_func_int16_t_s_s(((func_36((*l_1067), p_30, (~((safe_rshift_func_int16_t_s_u(0x27FAL, 10)) , l_1079)), l_979.f0, l_1080) & p_30) == 0L), l_979.f1))))))))), (*l_907), l_1081);
                (*l_907) = l_1082;
                /* statement id: 638 */
                assert (l_897 == 0);
            }
            /* facts after branching */
            assert (l_897 == 0);
            (*l_907) = &p_30;
            /* statement id: 640 */
            assert (l_897 == &p_30);
        }
        p_30 = (((safe_mul_func_int16_t_s_s(l_1085, (safe_lshift_func_int16_t_s_u((l_1088 && (safe_lshift_func_uint16_t_u_u(p_30, (safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(p_30, (safe_mul_func_int16_t_s_s(p_30, p_31)))), l_979.f0))))), (0xB43A7935L == (safe_mul_func_uint16_t_u_u((!(l_1100 <= p_31)), p_31))))))) && 3L) ^ 1UL);
        (*l_1101) = ((((((((func_36(l_1100, p_31, l_950, p_30, (0x7EFE41B5L ^ (l_1100 , (__builtin_clzl(p_31) || p_30)))) || p_30) != l_1100) >= 0x119FL) ^ l_979.f0) > p_31) & 1UL) | (-5L)) , p_30);
    }
    /* facts after for loop */
    assert (l_897 == &p_30 || l_897 == 0 || l_897 == &l_908);
    return l_1102;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_36(const int32_t  p_37, int32_t  p_38, uint16_t  p_39, uint16_t  p_40, uint32_t  p_41)
{ /* block id: 483 */
    int32_t **l_764 = (void*)0;
    int32_t ***l_763 = &l_764;
    int32_t l_765 = 0xE495B936L;
    int32_t *l_766 = &l_765;
    int32_t *l_767 = &l_765;
    uint32_t l_776 = 0x250081F6L;
    struct S0 l_779 = {0L,0xF9EE9152L,0x44046E67L,-1L,1UL,65527UL,0x06F36CB2L};
    struct S0 *l_778 = &l_779;
    struct S0 **l_777 = &l_778;
    struct S1 l_786 = {0x01150BD0L,0L};
    struct S1 *l_785 = &l_786;
    struct S1 **l_784 = &l_785;
    struct S0 ***l_804 = (void*)0;
    struct S0 ****l_803 = &l_804;
    struct S0 *****l_802 = &l_803;
    uint32_t l_838 = 18446744073709551615UL;
    if ((l_763 == (func_68(p_37, __builtin_popcountll(l_765), l_766, l_767, __builtin_ffs((((__builtin_bswap32((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((*l_766), (safe_lshift_func_int16_t_s_s((safe_div_func_int16_t_s_s(((__builtin_ffsl(l_776) , l_777) != &l_778), (*l_766))), 4)))), p_38))) != p_37) <= p_38) , p_37))) , &l_764)))
    { /* block id: 484 */
        int32_t *l_780 = &l_779.f3;
        int32_t **l_781 = &l_766;
        struct S1 l_810 = {-1L,0L};
        (*l_781) = func_52(p_40, l_780, l_780);
        /* statement id: 485 */
        assert (l_766 == &l_779.f3);
        for (l_779.f2 = 0; (l_779.f2 == (-26)); l_779.f2 = safe_sub_func_uint16_t_u_u(l_779.f2, 5))
        { /* block id: 488 */
            struct S1 ***l_787 = &l_784;
            struct S1 l_795 = {-1L,-1L};
            uint32_t l_805 = 0x07FE5C98L;
            (*l_787) = l_784;
            for (l_779.f1 = (-13); (l_779.f1 <= (-5)); l_779.f1++)
            { /* block id: 492 */
                int32_t l_790 = 0L;
                int32_t *l_806 = &l_765;
                struct S1 l_807 = {0L,0L};
                (*l_781) = func_47((l_790 , (safe_mul_func_int16_t_s_s((l_790 | ((p_40 >= ((safe_lshift_func_int16_t_s_s((func_43(l_795, (*l_780)) & (safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s((p_39 , __builtin_ffs((safe_mul_func_int16_t_s_s((((void*)0 != l_802) | p_38), (*l_780))))), 15)), 2))), (*l_767))) > l_795.f0)) | 65535UL)), l_805))), l_806, p_40, l_807);
                /* statement id: 493 */
                assert (l_766 == 0);
            }
        }
        /* facts after for loop */
        assert (l_766 == 0 || l_766 == &l_779.f3);
        (*l_780) = (safe_add_func_int32_t_s_s(__builtin_bswap64((*l_780)), (func_43(l_810, ((((l_810 , 3L) | ((safe_mod_func_int16_t_s_s((p_39 >= __builtin_parity((*l_767))), (p_40 , p_40))) < 0xDCA0L)) > p_37) , (*l_780))) && (*l_780))));
    }
    else
    { /* block id: 497 */
        struct S1 l_813 = {-2L,-5L};
        const int32_t *l_845 = &l_779.f2;
        const int32_t **l_844 = &l_845;
        const int32_t ***l_843 = &l_844;
        const int32_t ****l_842 = &l_843;
        const int32_t *****l_841 = &l_842;
lbl_846:
        if (func_43(l_813, (p_39 <= ((p_38 <= (((safe_add_func_int32_t_s_s(func_43((p_40 , l_813), p_40), (safe_mul_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u(l_813.f0, (8UL & p_39))), (-7L))), p_39)))) == 0L) | 2L)) , 0x54605D30L))))
        { /* block id: 498 */
            uint16_t l_828 = 0x311CL;
            int32_t *l_829 = (void*)0;
            int32_t **l_830 = &l_767;
            for (l_813.f1 = 0; (l_813.f1 >= (-21)); l_813.f1 = safe_sub_func_int32_t_s_s(l_813.f1, 6))
            { /* block id: 501 */
                return l_813.f1;
            }
            (*l_830) = func_52(p_39, func_52((safe_div_func_int16_t_s_s((p_40 > (*l_767)), p_39)), func_59((safe_mul_func_int16_t_s_s(1L, l_828))), l_829), l_829);
            /* statement id: 504 */
            assert (l_767 == 0);
            return l_813.f1;
        }
        else
        { /* block id: 506 */
            struct S1 ****l_831 = (void*)0;
            struct S1 ***l_833 = &l_784;
            struct S1 ****l_832 = &l_833;
            (*l_832) = (void*)0;
            /* statement id: 507 */
            assert (l_833 == 0);
        }
        (*l_766) = (((safe_sub_func_int16_t_s_s((p_39 | (safe_add_func_int32_t_s_s(((((l_813.f0 < func_43(((l_813.f1 , func_43(func_61(p_41, ((l_838 | (safe_rshift_func_int16_t_s_u((l_841 != (void*)0), 10))) | (func_43((*l_785), p_39) , p_40)), l_813, l_813, &l_765), p_39)) , (*l_785)), p_40)) == (*l_767)) || p_39) , 0x9FED736DL), p_39))), (-1L))) || (*l_845)) && p_39);
        if (l_838)
            goto lbl_846;
        (****l_841) = &p_38;
        /* statement id: 511 */
        assert (l_845 == &p_38);
    }
    /* facts after branching */
    assert (l_766 == &l_765 || l_766 == 0 || l_766 == &l_779.f3);
    (*l_767) = 0x79624AE1L;
    for (l_779.f5 = 0; (l_779.f5 < 26); ++l_779.f5)
    { /* block id: 516 */
        struct S1 ***l_863 = &l_784;
        int32_t ****l_867 = &l_763;
        int32_t *****l_866 = &l_867;
        int32_t l_875 = 0L;
        for (l_779.f3 = (-10); (l_779.f3 >= 5); l_779.f3 = safe_add_func_int16_t_s_s(l_779.f3, 3))
        { /* block id: 519 */
            int16_t l_857 = 0xDFE1L;
            struct S1 ***l_862 = &l_784;
            int32_t *l_868 = &l_765;
            if (p_37)
                break;
            (***l_863) = func_61(p_41, (safe_rshift_func_uint16_t_u_s((0xF39E5F5CL > ((safe_lshift_func_uint16_t_u_s((safe_mul_func_int16_t_s_s(l_857, (safe_mod_func_int32_t_s_s(0x14CEF7ADL, (safe_lshift_func_uint16_t_u_s(p_40, ((l_862 == l_863) != (safe_rshift_func_int16_t_s_s(((l_866 != &l_867) < (*l_767)), p_38))))))))), l_857)) != l_857)), 13)), (**l_784), (***l_863), l_868);
        }
        if ((safe_unary_minus_func_int16_t_s(p_40)))
        { /* block id: 523 */
            const int16_t l_874 = 0L;
            struct S1 l_876 = {0xD39086C6L,-1L};
            int32_t *l_877 = &l_779.f3;
            (**l_784) = func_61((safe_mul_func_int16_t_s_s(p_40, (safe_mul_func_int16_t_s_s(l_874, (((l_875 , func_43(l_876, p_37)) <= p_39) , l_876.f0))))), p_40, (**l_784), (**l_784), l_877);
            for (l_779.f3 = 22; (l_779.f3 <= (-26)); l_779.f3 = safe_sub_func_int16_t_s_s(l_779.f3, 1))
            { /* block id: 527 */
                const uint16_t l_882 = 0xF0C3L;
                for (l_876.f0 = (-8); (l_876.f0 != 3); ++l_876.f0)
                { /* block id: 530 */
                    (*l_767) = p_40;
                    if (l_882)
                        continue;
                }
            }
        }
        else
        { /* block id: 535 */
            int32_t *l_883 = (void*)0;
            (*l_866) = &l_763;
            l_883 = l_883;
            return p_37;
        }
    }
    if (((*l_767) != (safe_rshift_func_uint16_t_u_s((p_38 > 0UL), 1))))
    { /* block id: 541 */
        int32_t *l_888 = &l_786.f0;
        for (l_838 = 0; (l_838 != 57); ++l_838)
        { /* block id: 544 */
            int32_t **l_889 = &l_767;
            (*l_889) = l_888;
            /* statement id: 545 */
            assert (l_767 == &l_786.f0);
            if (p_39)
                break;
        }
        /* facts after for loop */
        assert (l_767 == &l_786.f0 || l_767 == &l_765);
    }
    else
    { /* block id: 548 */
        return p_37;
    }
    /* facts after branching */
    assert (l_767 == &l_786.f0 || l_767 == &l_765);
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_43(struct S1  p_44, uint16_t  p_45)
{ /* block id: 38 */
    int32_t l_56 = (-1L);
    int32_t l_58 = 0L;
    int32_t *l_57 = &l_58;
    const struct S1 l_67 = {4L,8L};
    struct S0 l_746 = {0x40ED0A94L,0xAF0B0EB6L,0L,-9L,0xE325903CL,0UL,0L};
    struct S1 *l_759 = (void*)0;
    struct S1 l_761 = {1L,3L};
    struct S1 *l_760 = &l_761;
    l_57 = func_47(p_44.f1, func_52(l_56, l_57, func_59((__builtin_clzll(((func_61((*l_57), ((*l_57) <= (*l_57)), l_67, func_68((*l_57), p_44.f1, &l_58, &l_58, p_44.f0), &l_58) , 0x875E01DEL) , (*l_57))) > (*l_57)))), (*l_57), l_67);
    /* statement id: 473 */
    assert (l_57 == 0);
    for (p_45 = 0; (p_45 != 26); ++p_45)
    { /* block id: 476 */
        uint16_t l_749 = 0xD6D7L;
        struct S0 l_756 = {7L,0x89060D38L,0x1AC5392DL,-5L,0x36D1B473L,0xD32BL,0xF3CBF79DL};
        int16_t l_757 = 0x8768L;
        int32_t *l_758 = &l_746.f3;
        (*l_758) = ((p_45 >= (l_746 , ((safe_lshift_func_int16_t_s_s(l_58, 10)) | p_44.f1))) == (((l_749 || ((((safe_mul_func_int16_t_s_s(l_749, (safe_div_func_int32_t_s_s((safe_rshift_func_int16_t_s_u((l_756 , __builtin_ctz(l_757)), 9)), l_756.f1)))) , 4294967295UL) , p_44) , p_45)) || l_756.f3) ^ l_756.f4));
        (*l_758) = p_45;
        (*l_758) = p_45;
    }
    (*l_760) = l_67;
    return l_746.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_47(int32_t  p_48, int32_t * p_49, int32_t  p_50, struct S1  p_51)
{ /* block id: 469 */
    int16_t l_729 = 0x2DE7L;
    int32_t l_731 = 0xF02AC3C2L;
    int32_t *l_730 = &l_731;
    int32_t **l_734 = &l_730;
    int32_t *l_735 = &l_731;
    int32_t *l_736 = &l_731;
    int32_t *l_737 = &l_731;
    int32_t *l_738 = &l_731;
    int32_t *l_739 = &l_731;
    int32_t *l_740 = &l_731;
    int32_t *l_741 = &l_731;
    int32_t *l_742 = &l_731;
    int32_t *l_743 = (void*)0;
    (*l_734) = func_74((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s(((0x3450L <= (p_51.f0 | ((l_729 | l_729) || (((__builtin_ia32_crc32qi(p_50, (((void*)0 == l_730) , (safe_div_func_int16_t_s_s((((&p_51 == &p_51) & 0L) , 0xB9C8L), (*l_730))))) ^ (*l_730)) <= (*l_730)) && p_50)))) , p_51.f1), 8)) <= (*l_730)), (*l_730))));
    /* statement id: 470 */
    assert (l_730 == 0);
    (*p_49) = (*p_49);
    return l_743;
    /* statement id: 472 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_52(uint32_t  p_53, int32_t * p_54, int32_t * p_55)
{ /* block id: 466 */
    struct S0 l_724 = {9L,-1L,0xD66BCDC8L,0xEF94410AL,0UL,0x9734L,-1L};
    const struct S0 *l_723 = &l_724;
    const struct S0 **l_722 = &l_723;
    l_722 = l_722;
    return p_54;
    /* statement id: 468 */
    //assert (func_52_rv == &l_58 || func_52_rv == &l_779.f3 || func_52_rv == 0 || func_52_rv == &l_908 || func_52_rv == &p_30);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_59(int16_t  p_60)
{ /* block id: 391 */
    int32_t l_553 = 0xD8C874EDL;
    int32_t *l_552 = &l_553;
    int32_t **l_554 = &l_552;
    int32_t ***l_559 = &l_554;
    int32_t ****l_558 = &l_559;
    int32_t *****l_557 = &l_558;
    struct S1 l_560 = {-1L,2L};
    int32_t *****l_561 = &l_558;
    struct S1 *l_563 = &l_560;
    struct S1 **l_562 = &l_563;
    int16_t l_600 = 0x5AAFL;
    int32_t *l_605 = &l_560.f0;
    int32_t *l_610 = &l_553;
    int32_t *l_628 = &l_560.f0;
    int32_t *l_629 = &l_553;
    struct S0 l_634 = {1L,1L,0xDD607CB6L,0xE34FEFF9L,0x643DCFF6L,0x8088L,-3L};
    struct S0 *l_633 = &l_634;
    struct S0 **l_632 = &l_633;
    struct S0 ***l_631 = &l_632;
    uint32_t l_659 = 4UL;
    int32_t *l_661 = &l_553;
    int32_t *l_663 = &l_560.f0;
    int32_t *l_666 = &l_560.f0;
    struct S0 ****l_694 = &l_631;
    struct S0 *****l_693 = &l_694;
    int32_t *l_709 = &l_634.f3;
    int32_t *l_717 = &l_634.f2;
    int32_t *l_718 = &l_634.f3;
    int32_t *l_719 = &l_553;
    int32_t *l_720 = &l_560.f0;
    int32_t *l_721 = (void*)0;
    (*l_554) = l_552;
    (*l_554) = (*l_554);
    (*l_563) = func_61(p_60, p_60, func_68(p_60, (((((safe_sub_func_int16_t_s_s((**l_554), (l_557 == (l_560 , l_561)))) , l_560) , p_60) , l_562) == (void*)0), (****l_557), (*l_554), p_60), (**l_562), (*l_554));
    for (p_60 = 14; (p_60 > (-19)); p_60 = safe_sub_func_int16_t_s_s(p_60, 1))
    { /* block id: 397 */
        const int32_t l_571 = 0L;
        struct S1 *l_576 = (void*)0;
        int32_t ****l_597 = &l_559;
        const uint16_t l_602 = 0x8A12L;
        int32_t *l_607 = &l_553;
        int32_t *l_609 = &l_560.f0;
        int32_t *l_611 = (void*)0;
        int32_t **l_635 = (void*)0;
        struct S0 l_639 = {0x5C68C13CL,-1L,0x1F7A13F4L,-6L,18446744073709551611UL,0x3539L,1L};
        uint32_t l_660 = 0UL;
        struct S1 l_662 = {0x3835BEE5L,-1L};
        int32_t *l_665 = &l_634.f2;
        struct S0 ****l_688 = &l_631;
        int32_t *l_706 = &l_560.f0;
        int32_t *l_707 = (void*)0;
        int32_t *l_712 = &l_553;
        int32_t *l_714 = &l_639.f2;
        int32_t *l_716 = (void*)0;
        if (((func_61((((((safe_unary_minus_func_uint32_t_u((((safe_add_func_uint32_t_u_u(p_60, ((**l_554) < (!((!4L) , l_571))))) < ((safe_sub_func_uint32_t_u_u((*****l_557), p_60)) >= (((safe_lshift_func_uint16_t_u_u(((0x8BEEL || (*****l_557)) , l_571), l_571)) , l_576) == (void*)0))) , 0x7A7EC0E9L))) < p_60) ^ p_60) == 8L) , l_571), p_60, (**l_562), (*l_563), (****l_557)) , 0UL) > p_60))
        { /* block id: 398 */
            const struct S1 l_589 = {0x32590158L,0xE40BL};
            int32_t *l_601 = &l_553;
            int32_t *l_608 = &l_553;
            struct S0 ***l_618 = (void*)0;
            struct S0 ****l_617 = &l_618;
            int32_t *l_664 = &l_560.f0;
            int32_t *l_667 = (void*)0;
            (***l_559) = p_60;
            if ((safe_add_func_int32_t_s_s(p_60, (func_61(p_60, ((safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(__builtin_ia32_crc32qi(((safe_add_func_int16_t_s_s((safe_mul_func_uint16_t_u_u(1UL, (p_60 == ((__builtin_bswap32(((__builtin_bswap64(p_60) != (l_571 , (***l_559))) , p_60)) & 6UL) <= 0x13A0L)))), (-7L))) != 0x77E2F420L), (**l_554)), p_60)), (-5L))) == l_571), l_589, (**l_562), (****l_557)) , (-1L)))))
            { /* block id: 400 */
                uint32_t l_591 = 1UL;
                int32_t *l_603 = &l_553;
                struct S1 l_621 = {0x069987C9L,0L};
                int32_t *l_630 = (void*)0;
                if ((*l_552))
                { /* block id: 401 */
                    int32_t *****l_592 = &l_558;
                    (***l_558) = func_74((((~l_589.f1) , func_68(p_60, (((((l_589.f0 | (l_591 ^ ((void*)0 == l_592))) , func_68(((((((safe_mod_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(p_60, (((l_597 == ((safe_mod_func_int16_t_s_s((p_60 || 0xF3BE7702L), p_60)) , l_597)) , p_60) > 0x741F419AL))), (-1L))) , p_60) && l_591) & 0x1728E7C0L) && (****l_597)) , (****l_597)), l_600, (****l_592), l_601, (*l_552))) , 0L) , l_591) , (-4L)), (***l_597), (****l_592), l_591)) , 0x495EL));
                    /* statement id: 402 */
                    assert (l_552 == 0);
                }
                else
                { /* block id: 403 */
                    int32_t *l_604 = &l_553;
                    struct S1 l_616 = {0x63C43478L,0x991AL};
                    int32_t l_626 = (-1L);
                    if (l_591)
                    { /* block id: 404 */
                        (*****l_561) = l_602;
                        (*l_563) = l_589;
                        (****l_558) = p_60;
                        (***l_559) = 0x60AD2882L;
                    }
                    else
                    { /* block id: 409 */
                        int32_t *l_606 = &l_560.f0;
                        return l_611;
                        /* statement id: 410 */
                        //assert (func_59_rv == 0);
                    }
                    (***l_597) = l_604;
                    (***l_597) = l_601;
                    if (((safe_div_func_int32_t_s_s(((****l_597) >= (safe_add_func_uint32_t_u_u(((l_616 , func_61((((*l_603) || (l_601 != (void*)0)) || (l_617 != (void*)0)), (((((*l_603) , ((safe_add_func_int32_t_s_s(((*l_603) ^ 9UL), 1UL)) > 1UL)) <= p_60) , p_60) ^ (*l_603)), l_589, l_621, l_603)) , 0x37D19D19L), 0x7607D01DL))), (-1L))) , p_60))
                    { /* block id: 414 */
                        (*l_603) = (safe_mod_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u(((*l_608) & (*l_604)), ((l_576 != (void*)0) == l_626))), p_60));
                    }
                    else
                    { /* block id: 416 */
                        int32_t *l_627 = &l_616.f0;
                        (*l_609) = 0xF3160F2FL;
                        return l_630;
                        /* statement id: 418 */
                        //assert (func_59_rv == 0);
                    }
                }
                /* facts after branching */
                assert (l_552 == &l_553 || l_552 == 0);
                (*l_601) = ((*l_617) != ((**l_562) , l_631));
                (*l_554) = func_74(((l_635 != &l_608) , (*l_601)));
                /* statement id: 422 */
                assert (l_552 == 0);
                (**l_631) = (*l_632);
            }
            else
            { /* block id: 424 */
                uint16_t l_636 = 0xC63DL;
                struct S1 ***l_637 = &l_562;
                struct S1 ****l_638 = &l_637;
                (*l_610) = ((*l_608) < (*l_607));
                (***l_559) = (*l_605);
                if (l_636)
                    break;
                (*l_638) = l_637;
            }
            /* facts after branching */
            assert (l_552 == &l_553 || l_552 == 0);
            l_662 = (l_639 , func_68(((safe_rshift_func_uint16_t_u_u(1UL, 4)) , ((safe_lshift_func_uint16_t_u_u(p_60, 3)) == p_60)), ((safe_unary_minus_func_uint32_t_u((((((safe_add_func_uint16_t_u_u(p_60, p_60)) || (safe_rshift_func_int16_t_s_s((p_60 && (safe_mod_func_uint32_t_u_u((safe_add_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((p_60 < (*l_608)), (*l_628))), l_659)), p_60)), l_660)), (*l_605)))), 0))) , 0x4524L) < p_60) || p_60))) , 0x36F28BD8L), l_601, l_661, p_60));
            return l_667;
            /* statement id: 431 */
            //assert (func_59_rv == 0);
        }
        else
        { /* block id: 432 */
            int32_t *l_672 = &l_639.f2;
            struct S0 ***l_673 = &l_632;
            int32_t *l_689 = (void*)0;
            (****l_561) = (((p_60 >= (safe_mod_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((func_68(p_60, p_60, (*l_554), l_672, (*l_665)) , (&l_632 == ((__builtin_parityl(((l_673 == &l_632) | (****l_597))) == 0xD7E9ABD4L) , (void*)0))), p_60)), (*l_605)))) != (*l_609)) , (**l_559));
            if (((((*l_672) , p_60) , ((safe_unary_minus_func_int16_t_s((__builtin_clz(p_60) | ((((0xCB22A602L | (((l_662 , &l_673) == &l_673) , (safe_lshift_func_int16_t_s_u((*l_672), p_60)))) , (***l_559)) && (*l_665)) < 0x2C2BDD78L)))) , p_60)) & (-1L)))
            { /* block id: 434 */
                struct S1 **l_681 = &l_563;
                int32_t l_699 = (-1L);
                for (l_639.f3 = 0; (l_639.f3 != (-20)); l_639.f3 = safe_sub_func_int32_t_s_s(l_639.f3, 5))
                { /* block id: 437 */
                    struct S0 *****l_692 = (void*)0;
                    (*l_607) = (((p_60 , (void*)0) == (void*)0) , (safe_mod_func_int32_t_s_s(0xC7DAAE2DL, ((0x89E9L | (*l_609)) || p_60))));
                    (**l_562) = func_61(p_60, (((*l_672) , l_681) != &l_576), func_61((safe_add_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((l_688 == (void*)0), p_60)), 2)), (*l_672))), p_60, (*l_563), l_662, l_689), (**l_681), (****l_561));
                    for (l_639.f5 = 0; (l_639.f5 >= 9); l_639.f5 = safe_add_func_uint32_t_u_u(l_639.f5, 6))
                    { /* block id: 442 */
                        l_693 = l_692;
                        /* statement id: 443 */
                        assert (l_693 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_693 == 0 || l_693 == &l_694);
                (****l_597) = (safe_sub_func_uint16_t_u_u(p_60, (safe_sub_func_int32_t_s_s((-1L), (p_60 && l_699)))));
            }
            else
            { /* block id: 447 */
                (**l_559) = (***l_597);
                if ((*l_609))
                { /* block id: 449 */
                    (****l_561) = (void*)0;
                    /* statement id: 450 */
                    assert (l_552 == 0);
                    (****l_561) = (****l_557);
                }
                else
                { /* block id: 452 */
                    (*****l_557) = (*l_609);
                    (***l_559) = (((***l_673) , (safe_lshift_func_uint16_t_u_s(0xA3CEL, ((void*)0 != (*l_559))))) ^ (9UL != (*l_672)));
                }
                /* facts after branching */
                assert (l_552 == &l_553 || l_552 == 0);
            }
            /* facts after branching */
            assert (l_552 == &l_553 || l_552 == 0);
            assert (l_693 == 0 || l_693 == &l_694);
        }
        /* facts after branching */
        assert (l_552 == &l_553 || l_552 == 0);
        assert (l_693 == 0 || l_693 == &l_694);
        if (((safe_mul_func_uint16_t_u_u(p_60, p_60)) , (*l_661)))
        { /* block id: 458 */
            int32_t *l_704 = &l_639.f2;
            int32_t *l_705 = &l_553;
            (**l_559) = func_74(p_60);
            /* statement id: 459 */
            assert (l_552 == 0);
            return l_707;
            /* statement id: 460 */
            //assert (func_59_rv == 0);
        }
        else
        { /* block id: 461 */
            int32_t *l_708 = &l_639.f2;
            int32_t *l_710 = &l_662.f0;
            int32_t *l_711 = &l_560.f0;
            int32_t *l_713 = &l_560.f0;
            int32_t *l_715 = &l_634.f2;
            return l_716;
            /* statement id: 462 */
            //assert (func_59_rv == 0);
        }
    }
    return l_721;
    /* statement id: 465 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_61(uint16_t  p_62, int32_t  p_63, const struct S1  p_64, struct S1  p_65, int32_t * p_66)
{ /* block id: 288 */
    int32_t **l_417 = (void*)0;
    int32_t ***l_416 = &l_417;
    int32_t ****l_415 = &l_416;
    uint32_t l_424 = 0x345A6B21L;
    uint32_t l_444 = 0x5E47515CL;
    struct S0 l_448 = {-1L,0x0A404044L,-8L,0x8A2B8D36L,18446744073709551615UL,65535UL,0x98A925A2L};
    const struct S1 l_455 = {0L,0x1765L};
    struct S0 *l_469 = &l_448;
    struct S0 **l_468 = &l_469;
    struct S0 ***l_467 = &l_468;
    uint16_t l_523 = 65529UL;
    struct S1 l_531 = {-1L,-5L};
    struct S1 *l_530 = &l_531;
    struct S1 **l_529 = &l_530;
    for (p_65.f1 = 0; (p_65.f1 <= 10); p_65.f1 = safe_add_func_uint16_t_u_u(p_65.f1, 4))
    { /* block id: 291 */
        uint16_t l_412 = 0xEDEEL;
        int32_t ****l_421 = &l_416;
        struct S1 l_427 = {0L,-8L};
        struct S1 *l_431 = (void*)0;
        struct S1 **l_430 = &l_431;
        struct S1 **l_432 = &l_431;
        uint32_t l_471 = 0x8C8E7351L;
        uint16_t l_482 = 0x95C4L;
        const int32_t l_522 = 0x47022D93L;
    }
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_68(uint32_t  p_69, int32_t  p_70, int32_t * p_71, int32_t * p_72, uint16_t  p_73)
{ /* block id: 39 */
    const int16_t l_99 = 0x5621L;
    struct S1 **l_136 = (void*)0;
    struct S1 l_174 = {0x1CA15E86L,0L};
    int32_t *l_180 = &l_174.f0;
    int32_t l_181 = (-1L);
    int32_t *l_189 = &l_181;
    uint32_t l_202 = 4294967292UL;
    struct S0 ***l_205 = (void*)0;
    int32_t l_254 = 0x4A52FFC3L;
    uint32_t l_297 = 5UL;
    uint32_t l_383 = 0x9C3A3E59L;
    struct S1 l_394 = {-1L,0x09CCL};
    struct S0 l_396 = {0xC6C9B1D3L,0x90BD9C6BL,1L,1L,0x35C08C91L,0x0A30L,7L};
    struct S0 *l_395 = &l_396;
    struct S1 l_409 = {0L,0x98CBL};
lbl_190:
    if ((*p_72))
    { /* block id: 40 */
        int32_t l_90 = 4L;
        int32_t *l_89 = &l_90;
        int32_t **l_88 = &l_89;
        struct S0 l_98 = {0xD263D1F0L,-6L,1L,2L,2UL,9UL,0xD1E4559FL};
        struct S0 *l_97 = &l_98;
        const struct S1 l_109 = {0xEC1833B1L,2L};
        const struct S1 *l_108 = &l_109;
lbl_130:
        (*l_88) = func_74(p_69);
        /* statement id: 44 */
        assert (l_89 == 0);
        if ((~p_70))
        { /* block id: 45 */
            const struct S0 l_93 = {-1L,1L,0x3F16A1EAL,1L,0xCDB7CFF1L,0UL,0xA36B4E13L};
            const struct S0 *l_92 = &l_93;
            struct S0 l_96 = {0x2D3F7CC8L,0x7221BDB0L,0x0F3E77DFL,0xEBE340CFL,18446744073709551609UL,65535UL,1L};
            struct S0 *l_95 = &l_96;
            struct S0 **l_94 = &l_95;
            int16_t l_121 = (-6L);
            const struct S1 l_127 = {0x714D024AL,-1L};
            int32_t *l_128 = &l_98.f3;
            (*l_94) = l_92;
            /* statement id: 46 */
            assert (l_95 == &l_93);
            l_98.f2 = (((((l_97 != (*l_94)) != ((p_69 <= ((((((2UL | l_99) >= 0xA8392DDEL) >= (((((*l_97) , ((((*p_71) < ((safe_div_func_int32_t_s_s((p_73 < p_69), 0x96F09779L)) <= 0xE7469BA6L)) <= p_69) ^ 0x5C55787DL)) <= p_69) || l_99) > p_69)) < 0xE52AL) < 0x9839L) , 0xFD4BL)) ^ l_93.f3)) , p_70) != l_93.f4) , (*p_72));
            for (l_98.f1 = 0; (l_98.f1 >= (-25)); l_98.f1 = safe_sub_func_int16_t_s_s(l_98.f1, 2))
            { /* block id: 50 */
                const int32_t l_113 = 0xCCA7CC92L;
                struct S1 l_114 = {7L,0L};
                int32_t *l_116 = &l_114.f0;
                for (l_96.f4 = 0; (l_96.f4 == 8); l_96.f4++)
                { /* block id: 53 */
                    for (p_69 = 0; (p_69 >= 43); p_69 = safe_add_func_int32_t_s_s(p_69, 9))
                    { /* block id: 56 */
                        struct S1 l_112 = {0x3A75F931L,4L};
                        struct S1 *l_111 = &l_112;
                        struct S1 **l_110 = &l_111;
                        (*l_110) = l_108;
                        /* statement id: 57 */
                        assert (l_111 == &l_109);
                    }
                    (*l_88) = &p_70;
                    /* statement id: 59 */
                    assert (l_89 == &p_70);
                    if (((*l_97) , l_113))
                    { /* block id: 60 */
                        return l_114;
                    }
                    else
                    { /* block id: 62 */
                        int32_t *l_115 = (void*)0;
                        (*l_88) = l_115;
                        /* statement id: 63 */
                        assert (l_89 == 0);
                    }
                    /* facts after branching */
                    assert (l_89 == 0);
                }
                p_70 = (0x2FC4CEA7L || p_69);
                (*l_116) = 0x316AA2C9L;
            }
            (*l_128) = ((safe_mod_func_int16_t_s_s(p_69, (safe_sub_func_uint16_t_u_u(l_121, (safe_add_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(p_73, (p_73 , ((!(*p_72)) , p_73)))), ((((*l_97) , (&p_70 != (l_127 , (*l_88)))) , &l_98) == (void*)0))))))) && l_93.f4);
        }
        else
        { /* block id: 70 */
            int32_t **l_129 = &l_89;
            p_70 = (&p_71 != l_129);
            if (l_98.f0)
                goto lbl_130;
        }
        if (l_99)
        { /* block id: 74 */
            struct S1 l_132 = {-6L,1L};
            struct S1 *l_131 = &l_132;
            (*l_131) = (*l_108);
        }
        else
        { /* block id: 76 */
            int32_t *l_133 = &l_98.f3;
            (*l_133) = (*p_71);
            (*l_88) = func_74(l_99);
        }
    }
    else
    { /* block id: 80 */
        int32_t l_135 = 4L;
        int32_t *l_134 = &l_135;
        struct S1 l_139 = {0x85FA8931L,0xE4F0L};
        struct S1 *l_138 = &l_139;
        struct S1 **l_137 = &l_138;
        (*l_134) = ((&p_70 == l_134) == (l_99 , (*l_134)));
        l_137 = l_136;
        /* statement id: 82 */
        assert (l_137 == 0);
        for (l_139.f0 = (-23); (l_139.f0 > 19); l_139.f0 = safe_add_func_int32_t_s_s(l_139.f0, 3))
        { /* block id: 85 */
            struct S1 l_142 = {0x89711EE9L,0x90BCL};
            return l_142;
        }
    }
    if (((0xAB53L >= 8UL) == (l_99 ^ (safe_sub_func_uint16_t_u_u(p_70, l_99)))))
    { /* block id: 89 */
        const int32_t l_147 = 0L;
        const int32_t *l_146 = &l_147;
        const int32_t **l_145 = &l_146;
        struct S1 l_162 = {0x95350F15L,1L};
        struct S1 *l_161 = &l_162;
        struct S0 l_166 = {1L,0x1C1CC915L,7L,0x15A15C47L,8UL,0xF346L,-5L};
        struct S0 *l_165 = &l_166;
        uint32_t l_296 = 0UL;
        uint32_t l_307 = 0xC8871E69L;
        int32_t **l_329 = &l_189;
        int32_t ***l_328 = &l_329;
        int32_t ****l_327 = &l_328;
        (*l_145) = (void*)0;
        /* statement id: 90 */
        assert (l_146 == 0);
        for (p_73 = 12; (p_73 >= 39); p_73++)
        { /* block id: 93 */
            struct S1 l_150 = {0x5580C9BFL,0L};
            struct S0 l_164 = {-8L,1L,0xDBB92B38L,0xC65EB622L,4UL,0UL,-10L};
            struct S0 *l_163 = &l_164;
            int32_t *l_214 = &l_166.f2;
            int32_t **l_314 = &l_214;
            int32_t ***l_313 = &l_314;
            if (((((l_150 , (l_150.f0 != (l_150 , (safe_sub_func_int32_t_s_s((safe_sub_func_int32_t_s_s(l_150.f0, (!(p_70 | l_150.f0)))), (((0xA545A54EL <= (~l_99)) > (safe_mod_func_int16_t_s_s((((((((safe_sub_func_int16_t_s_s((((((l_99 != 0xC016F782L) < 0x2D68L) > 0x83C55790L) , 0x01A0L) ^ l_99), p_73)) , (void*)0) == l_161) , l_163) != l_165) , (*p_71)) , p_70), p_70))) >= p_69)))))) && (*p_72)) ^ p_70) , l_164.f3))
            { /* block id: 94 */
                uint32_t l_168 = 0UL;
                struct S1 l_173 = {1L,0xFF55L};
                struct S0 **l_184 = &l_165;
                int32_t **l_193 = &l_180;
                int16_t l_217 = 0xA880L;
                p_70 = ((l_150 , ((~l_164.f0) & 1UL)) > (0UL || l_168));
                for (l_164.f4 = 8; (l_164.f4 != 38); l_164.f4 = safe_add_func_int16_t_s_s(l_164.f4, 1))
                { /* block id: 98 */
                    struct S0 l_186 = {0x549B09EDL,0x30AC0004L,0x7FC37884L,6L,7UL,0x9580L,0xE8CAA09BL};
                    struct S0 *l_185 = &l_186;
                    for (l_162.f1 = 0; (l_162.f1 != (-18)); l_162.f1 = safe_sub_func_uint16_t_u_u(l_162.f1, 2))
                    { /* block id: 101 */
                        struct S0 ***l_175 = (void*)0;
                        struct S0 **l_177 = &l_165;
                        struct S0 ***l_176 = &l_177;
                        (*l_145) = (void*)0;
                        /* statement id: 102 */
                        assert (l_146 == 0);
                        l_174 = l_173;
                        (*l_176) = &l_165;
                        (*l_145) = (*l_145);
                    }
                    (*l_145) = func_74(((((((safe_mod_func_uint32_t_u_u(((((void*)0 != l_180) > (__builtin_ffs(l_168) < l_181)) && p_73), l_173.f1)) == __builtin_clz((safe_mod_func_uint16_t_u_u(0xA861L, ((&l_163 != l_184) || (*p_72)))))) > 1UL) <= 0x8FB1L) > p_73) , p_70));
                    /* statement id: 107 */
                    assert (l_146 == 0);
                    l_185 = &l_164;
                    /* statement id: 108 */
                    assert (l_185 == &l_164);
                    for (l_166.f5 = 0; (l_166.f5 != 0); l_166.f5 = safe_add_func_uint32_t_u_u(l_166.f5, 8))
                    { /* block id: 111 */
                        (*l_145) = l_189;
                        /* statement id: 112 */
                        assert (l_146 == &l_181);
                        if (l_181)
                            goto lbl_190;
                    }
                    /* facts after for loop */
                    assert (l_146 == &l_181 || l_146 == 0);
                }
                if (((safe_add_func_uint16_t_u_u(0xFDBFL, ((*p_71) >= (l_193 == l_193)))) != (safe_mul_func_int16_t_s_s((__builtin_parity((((p_69 , (safe_mul_func_uint16_t_u_u((**l_193), (safe_lshift_func_uint16_t_u_u(p_70, p_73))))) , (safe_mod_func_uint16_t_u_u(l_164.f5, 1L))) ^ l_202)) , 0x89D2L), p_69))))
                { /* block id: 116 */
                    int32_t *l_213 = &l_150.f0;
                    if ((safe_mul_func_int16_t_s_s(l_164.f1, (((void*)0 == l_205) , l_150.f0))))
                    { /* block id: 117 */
                        struct S1 l_210 = {-5L,4L};
                        p_72 = (*l_193);
                        /* statement id: 118 */
                        assert (p_72 == &p_70 || p_72 == &l_174.f0);
                        (*l_145) = ((safe_mul_func_uint16_t_u_u((&p_72 == &p_72), ((*p_72) <= ((safe_lshift_func_uint16_t_u_u((*l_180), 8)) , (*p_71))))) , (*l_145));
                        if ((*p_71))
                            continue;
                        return l_210;
                    }
                    else
                    { /* block id: 122 */
                        (*l_145) = (*l_145);
                        (*l_189) = __builtin_parity((*l_180));
                    }
                    (*l_145) = func_74(p_73);
                    /* statement id: 126 */
                    assert (l_146 == 0);
                    for (l_162.f0 = 0; (l_162.f0 < 13); l_162.f0 = safe_add_func_uint16_t_u_u(l_162.f0, 3))
                    { /* block id: 129 */
                        (*l_193) = &p_70;
                        /* statement id: 130 */
                        assert (l_180 == &p_70);
                        l_214 = l_213;
                        /* statement id: 131 */
                        assert (l_214 == &l_150.f0);
                        if ((*p_72))
                            break;
                        (**l_193) = ((*l_189) < (*l_180));
                    }
                    /* facts after for loop */
                    assert (l_214 == &l_150.f0 || l_214 == &l_166.f2);
                    for (p_70 = 5; (p_70 != 17); p_70 = safe_add_func_int16_t_s_s(p_70, 3))
                    { /* block id: 137 */
                        (*l_193) = func_74(l_217);
                        /* statement id: 138 */
                        assert (l_180 == 0);
                        return l_173;
                    }
                }
                else
                { /* block id: 141 */
                    int16_t l_231 = 0xD995L;
                    struct S0 l_233 = {0xA8E80D33L,0xB072DD7AL,7L,0x8F8EAD33L,1UL,1UL,8L};
                    for (l_164.f6 = 0; (l_164.f6 <= 25); l_164.f6 = safe_add_func_int16_t_s_s(l_164.f6, 4))
                    { /* block id: 144 */
                        int32_t l_234 = 0xC96EE17FL;
                        struct S1 *l_235 = &l_150;
                        (*l_214) = (safe_mod_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(p_69, ((safe_unary_minus_func_int32_t_s(__builtin_ffs((*l_189)))) != ((safe_mod_func_uint32_t_u_u((safe_add_func_int16_t_s_s((((**l_193) , ((((safe_mul_func_int16_t_s_s(p_69, (**l_193))) >= l_231) , (safe_unary_minus_func_int32_t_s(((((((((l_233 , &l_165) == l_184) | (*l_214)) < l_234) == 0x0CA24133L) < 0xAAAEAED0L) , &l_150) != l_235)))) != 65526UL)) == l_234), p_73)), 0x17F0F52EL)) & p_69)))) , l_234), (*l_189)));
                    }
                }
                /* facts after branching */
                assert (l_214 == &l_150.f0 || l_214 == &l_166.f2);
            }
            else
            { /* block id: 148 */
                uint32_t l_240 = 1UL;
                int32_t **l_245 = &l_214;
                const struct S1 l_257 = {1L,-1L};
                if ((*p_72))
                { /* block id: 149 */
                    uint32_t l_243 = 0x4DA91A52L;
                    int32_t l_244 = 0xFA00B79EL;
                    int32_t l_247 = 0x7611255DL;
                    for (l_150.f0 = 0; (l_150.f0 <= (-9)); l_150.f0 = safe_sub_func_uint32_t_u_u(l_150.f0, 1))
                    { /* block id: 152 */
                        uint16_t l_246 = 65535UL;
                        struct S0 **l_248 = &l_165;
                        l_247 = (p_70 && ((0x7B7F45CDL && (((p_70 | (&p_70 == &p_70)) <= (safe_mul_func_int16_t_s_s(((l_240 && (safe_rshift_func_int16_t_s_u(((*l_161) , (((((l_243 == ((l_244 , 0xD6DE4146L) == l_240)) && 0xD559L) >= (*l_214)) , &l_146) != l_245)), l_246))) ^ 4294967291UL), p_73))) > 0x59700A65L)) < 65535UL));
                        if (l_246)
                            goto lbl_190;
                        (*l_214) = (((void*)0 == l_248) , (&l_162 == (void*)0));
                    }
                    (*l_161) = l_150;
                }
                else
                { /* block id: 158 */
                    struct S1 l_249 = {-1L,0L};
                    return l_249;
                }
                (*l_245) = &p_70;
                /* statement id: 161 */
                assert (l_214 == &p_70);
                if ((**l_245))
                { /* block id: 162 */
                    int32_t l_268 = (-3L);
                    struct S0 **l_269 = (void*)0;
                    (*l_245) = ((safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(l_254, p_69)), ((&l_163 == (void*)0) , (((p_70 , ((safe_mod_func_int16_t_s_s((p_70 | (l_257 , (((safe_sub_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((safe_sub_func_int32_t_s_s((**l_245), (((safe_rshift_func_uint16_t_u_s(((**l_245) ^ 0UL), l_268)) | 0x629BL) , (*p_72)))), p_69)), 1L)) , l_268) , (*p_72)))), p_70)) , l_269)) == (void*)0) >= p_70)))) , (void*)0);
                    /* statement id: 163 */
                    assert (l_214 == 0);
                    (*l_189) = (safe_div_func_int32_t_s_s(((l_268 == (*p_71)) || __builtin_popcount(p_70)), (*p_71)));
                    for (p_69 = 27; (p_69 >= 30); p_69 = safe_add_func_int16_t_s_s(p_69, 9))
                    { /* block id: 167 */
                        struct S1 l_274 = {0x9113BFD8L,0x0E4EL};
                        return l_274;
                    }
                }
                else
                { /* block id: 170 */
                    (**l_245) = ((**l_245) || p_73);
                }
                /* facts after branching */
                assert (l_214 == &p_70 || l_214 == 0);
            }
            /* facts after branching */
            assert (l_214 == &p_70 || l_214 == 0 || l_214 == &l_150.f0 || l_214 == &l_166.f2);
            l_166.f3 = (*p_71);
            for (l_254 = 0; (l_254 == (-6)); l_254 = safe_sub_func_uint32_t_u_u(l_254, 1))
            { /* block id: 177 */
                uint32_t l_281 = 18446744073709551607UL;
                struct S0 **l_285 = &l_163;
                int32_t l_286 = 0x82FDE8DAL;
                struct S1 l_300 = {-4L,-4L};
                int32_t ****l_326 = &l_313;
                int32_t l_339 = (-7L);
            }
        }
        /* facts after for loop */
        assert (l_146 == &l_181 || l_146 == 0);
    }
    else
    { /* block id: 223 */
        int32_t *l_342 = &l_254;
        const int32_t **l_343 = (void*)0;
        int32_t **l_344 = &l_189;
        struct S1 l_345 = {-1L,0xDF22L};
        struct S0 l_348 = {4L,0x22EAAC3AL,0xBA4F4107L,0xF472926FL,0xE8B8BF44L,65535UL,0xDD124928L};
        struct S0 *l_347 = &l_348;
        struct S0 **l_346 = &l_347;
        for (p_69 = 0; (p_69 >= 20); p_69++)
        { /* block id: 226 */
            (*l_189) = (*p_71);
        }
        (*l_344) = l_342;
        /* statement id: 229 */
        assert (l_189 == &l_254);
        (**l_344) = (((l_345 , (((((p_69 , l_346) == &l_347) > (*l_342)) || (**l_344)) , &p_72)) == &l_342) >= (**l_344));
        for (l_345.f1 = 0; (l_345.f1 == 9); l_345.f1 = safe_add_func_int16_t_s_s(l_345.f1, 1))
        { /* block id: 233 */
            int16_t l_351 = 2L;
            const struct S1 l_353 = {-8L,0xDE70L};
            if (l_351)
            { /* block id: 234 */
                int16_t l_352 = 0xE66FL;
                l_352 = (*p_72);
                if ((*p_71))
                    break;
                l_174 = l_353;
            }
            else
            { /* block id: 238 */
                const int32_t l_354 = 0xBBA7D40BL;
                struct S1 *l_355 = &l_174;
                if (l_354)
                { /* block id: 239 */
                    (*l_180) = (*p_71);
                }
                else
                { /* block id: 241 */
                    (**l_344) = (*l_189);
                }
                (*l_344) = (void*)0;
                /* statement id: 244 */
                assert (l_189 == 0);
                (*l_355) = l_353;
                l_189 = &p_70;
                /* statement id: 246 */
                assert (l_189 == &p_70);
            }
        }
        /* facts after for loop */
        assert (l_189 == &p_70 || l_189 == &l_254);
    }
    /* facts after branching */
    assert (l_189 == &p_70 || l_189 == &l_254 || l_189 == &l_181);
    (*l_180) = __builtin_parity((safe_sub_func_int32_t_s_s((*l_180), (p_70 , ((safe_mod_func_uint32_t_u_u((safe_mul_func_uint16_t_u_u((*l_180), (safe_sub_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((((p_73 , (((*l_189) , (safe_add_func_int16_t_s_s(0xA2A0L, ((((*p_72) >= p_73) >= 0x8C111F8AL) > (*l_180))))) & 0xA9AFL)) , p_70) & p_73), 0xE16E3645L)), p_73)))), (*p_71))) < (*l_189))))));
    for (l_297 = 0; (l_297 > 8); l_297 = safe_add_func_uint32_t_u_u(l_297, 6))
    { /* block id: 253 */
        struct S1 l_370 = {0x6D7FA70DL,0L};
        struct S1 l_371 = {0x253AB809L,0x7C71L};
        uint32_t l_376 = 0xBF465107L;
        int32_t *l_390 = (void*)0;
        struct S1 *l_406 = &l_394;
        struct S1 **l_405 = &l_406;
        l_371 = l_370;
        if (((((safe_add_func_int32_t_s_s(l_371.f0, (*l_180))) <= (safe_add_func_uint32_t_u_u((__builtin_ctzl((l_371 , l_376)) != p_69), (l_370.f0 && (((safe_add_func_int32_t_s_s((safe_sub_func_uint32_t_u_u(p_70, p_69)), 0xE30E5366L)) < (*l_180)) == 0x82E4L))))) < p_70) < l_370.f1))
        { /* block id: 255 */
            struct S1 *l_393 = &l_371;
            (*l_189) = (safe_mul_func_int16_t_s_s(p_70, 65535UL));
            (*l_189) = l_383;
            for (l_376 = 2; (l_376 > 42); ++l_376)
            { /* block id: 260 */
                struct S1 *l_391 = &l_371;
                int32_t l_392 = 0x6D2E92B1L;
                for (l_371.f0 = (-23); (l_371.f0 < 15); l_371.f0 = safe_add_func_int16_t_s_s(l_371.f0, 6))
                { /* block id: 263 */
                    for (l_370.f0 = 5; (l_370.f0 >= (-18)); l_370.f0 = safe_sub_func_uint32_t_u_u(l_370.f0, 1))
                    { /* block id: 266 */
                        l_390 = &p_70;
                        /* statement id: 267 */
                        assert (l_390 == &p_70);
                        (*l_390) = 0L;
                    }
                    (*l_189) = (*p_71);
                }
                (*l_391) = l_371;
                p_72 = func_74(l_392);
                /* statement id: 273 */
                assert (p_72 == 0);
            }
            /* facts after for loop */
            assert (l_390 == &p_70 || l_390 == 0);
            (*l_393) = l_370;
        }
        else
        { /* block id: 276 */
            struct S0 **l_397 = &l_395;
            int32_t **l_402 = &l_189;
            int32_t ***l_401 = &l_402;
            int32_t ****l_400 = &l_401;
            (*l_189) = (l_394 , (*l_189));
            (*l_397) = l_395;
            for (l_370.f1 = 6; (l_370.f1 <= (-30)); l_370.f1 = safe_sub_func_int32_t_s_s(l_370.f1, 6))
            { /* block id: 281 */
                const int32_t *****l_403 = (void*)0;
                int32_t *****l_404 = &l_400;
                (*l_404) = l_400;
            }
            (***l_401) = (((p_69 != (((void*)0 != l_405) , (safe_lshift_func_uint16_t_u_s(((((*l_400) != (void*)0) , (*l_405)) != (*l_405)), ((*l_189) != (((**l_405) , (****l_400)) | 0L)))))) & 0x0A78L) != l_370.f1);
        }
        /* facts after branching */
        assert (l_390 == &p_70 || l_390 == 0);
    }
    /* facts after for loop */
    //assert (p_72 == 0 || p_72 == &p_70 || p_72 == &l_174.f0 || p_72 == &l_58 || p_72 == &l_462.f0 || p_72 == &l_553 || p_72 == &l_639.f2 || p_72 == &l_765);
    return l_409;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_74(uint16_t  p_75)
{ /* block id: 41 */
    struct S1 l_76 = {0x7820EAADL,-1L};
    struct S1 *l_77 = (void*)0;
    struct S1 *l_78 = &l_76;
    int32_t *l_79 = &l_76.f0;
    int32_t *l_80 = &l_76.f0;
    int32_t *l_81 = &l_76.f0;
    int32_t *l_82 = &l_76.f0;
    int32_t *l_83 = &l_76.f0;
    int32_t *l_84 = &l_76.f0;
    int32_t *l_85 = &l_76.f0;
    int32_t *l_86 = &l_76.f0;
    int32_t *l_87 = (void*)0;
    (*l_78) = l_76;
    return l_87;
    /* statement id: 43 */
    //assert (func_74_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 399
   depth: 1, occurrence: 86
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 45
breakdown:
   depth: 1, occurrence: 377
   depth: 2, occurrence: 71
   depth: 3, occurrence: 6
   depth: 4, occurrence: 10
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 8
   depth: 14, occurrence: 3
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 4
   depth: 18, occurrence: 6
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 3
   depth: 23, occurrence: 4
   depth: 24, occurrence: 4
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 34, occurrence: 1
   depth: 45, occurrence: 1

XXX total number of pointers: 349

XXX times a variable address is taken: 360
XXX times a pointer is dereferenced on RHS: 334
breakdown:
   depth: 1, occurrence: 240
   depth: 2, occurrence: 41
   depth: 3, occurrence: 32
   depth: 4, occurrence: 19
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 216
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 31
   depth: 3, occurrence: 21
   depth: 4, occurrence: 14
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 30
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 1878

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1683
   level: 2, occurrence: 392
   level: 3, occurrence: 192
   level: 4, occurrence: 171
   level: 5, occurrence: 59
XXX number of pointers point to pointers: 173
XXX number of pointers point to scalars: 122
XXX number of pointers point to structs: 54
XXX percent of pointers has null in alias set: 26.9
XXX average alias set size: 1.22

XXX times a non-volatile is read: 2091
XXX times a non-volatile is write: 679
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 8

XXX stmts: 338
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 48
   depth: 2, occurrence: 72
   depth: 3, occurrence: 64
   depth: 4, occurrence: 58
   depth: 5, occurrence: 61

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
********************* end of statistics **********************/

