/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2210315972
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_29(void);
static int16_t  func_34(int32_t  p_35, uint32_t  p_36);
static uint16_t  func_40(int16_t  p_41, int16_t  p_42);
static int32_t  func_44(uint16_t  p_45, const uint32_t  p_46);
static uint32_t  func_58(const uint16_t  p_59, uint32_t  p_60, uint16_t  p_61, int32_t  p_62, int32_t  p_63);
static struct S0  func_64(int32_t  p_65);
static struct S0  func_68(int32_t  p_69, int16_t  p_70);
static int32_t  func_71(int32_t  p_72);
static int32_t  func_73(int16_t  p_74, uint32_t  p_75, int32_t  p_76);
inline static int32_t  func_81(int32_t  p_82, struct S0  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_29(void)
{ /* block id: 36 */
    int16_t l_37 = 7;
    int32_t l_49 = 0x7B38EB16;
    struct S0 l_210 = {0xD118C778};
    uint32_t l_211 = 0x77B06565;
    l_210.f0 = ((uint16_t)((((int16_t)func_34(l_37, ((l_37 > (__builtin_clz(((((uint16_t)func_40((((!func_44(((int16_t)l_49 << (int16_t)2), l_49)) && ((((uint32_t)((uint16_t)((l_49 >= (((func_81(l_37, (l_210 , l_210)) , l_49) || 0x90A1) , l_37)) , l_210.f0) % (uint16_t)0x1223) % (uint32_t)4294967295U) && 3U) , l_37)) > l_49), l_211) * (uint16_t)0xEE6C) , l_210.f0) & 0x2D7F)) <= l_210.f0)) > (-1))) + (int16_t)l_211) | 0x80B7E346) , l_210.f0) >> (uint16_t)9);
    l_210 = l_210;
    return l_210.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_34(int32_t  p_35, uint32_t  p_36)
{ /* block id: 87 */
    int16_t l_213 = 0x87F2;
    struct S0 l_237 = {1};
    int32_t l_257 = 0x67867E56;
    uint32_t l_299 = 0U;
    int32_t l_322 = 0x28F6B505;
    int32_t l_335 = 1;
    int32_t l_350 = 9;
    int32_t l_360 = 0x5D151C89;
    int32_t l_362 = (-1);
    int32_t l_363 = (-9);
    int32_t l_368 = 0xCACBB113;
    int32_t l_381 = 9;
    int32_t l_384 = 0xF8FF0CC1;
    int32_t l_389 = (-7);
    int32_t l_394 = 1;
    int32_t l_396 = 0xF74CC398;
    uint32_t l_442 = 0x0006C132;
    uint32_t l_453 = 4294967295U;
    const uint32_t l_480 = 0xD4E75E4C;
    uint32_t l_535 = 4294967289U;
    if (l_213)
    { /* block id: 88 */
        return p_35;
    }
    else
    { /* block id: 90 */
        struct S0 l_220 = {0xFBE81AC6};
        uint32_t l_223 = 0x20C650B9;
        uint32_t l_289 = 4294967289U;
        int32_t l_315 = 0xA8426479;
        int32_t l_317 = 0x23CE44F5;
        int32_t l_318 = 0x2BD604E9;
        int32_t l_325 = (-5);
        int32_t l_326 = 0x4F853981;
        int32_t l_328 = 0x8FEF89A3;
        int32_t l_349 = 0xC4C04C65;
        int32_t l_373 = 0x15648FCB;
        int32_t l_382 = 5;
        int32_t l_386 = (-1);
        int32_t l_390 = 0x0624372E;
        int32_t l_395 = 0xF5892148;
        uint32_t l_398 = 0x0BBEF1F7;
        int32_t l_432 = 0;
        if ((0x58433A3D != (((!(((0U > 5) | ((uint16_t)((uint16_t)((!((((((p_36 < (p_35 < (l_220 , (0 == ((uint16_t)((-4) || p_36) >> (uint16_t)3))))) && l_213) & p_35) || p_35) || p_35) , p_35)) == l_220.f0) + (uint16_t)0xD2D4) * (uint16_t)9)) || l_223)) ^ 1) , p_36)))
        { /* block id: 91 */
            struct S0 l_234 = {0x95996FE7};
            uint32_t l_298 = 4294967295U;
            int32_t l_316 = 0x143310F7;
            int32_t l_323 = 0x18E075F6;
            int32_t l_330 = 7;
            int32_t l_340 = 0;
            int32_t l_355 = 0x6F5524AC;
            int32_t l_357 = 0x8669CBBF;
            int32_t l_358 = 0x56025032;
            int32_t l_359 = 5;
            int32_t l_361 = 1;
            int32_t l_378 = 0xA71606EB;
            int32_t l_380 = 0xDFAD66BD;
            for (l_213 = 20; (l_213 > 9); l_213 -= 4)
            { /* block id: 94 */
                uint32_t l_235 = 6U;
                if (p_36)
                { /* block id: 95 */
                    int32_t l_226 = 1;
                    struct S0 l_236 = {-1};
                    p_35 = ((__builtin_popcountll((p_36 , l_226)) | ((__builtin_clzll(((func_71(func_81(((0U > (0x9FD1 | (p_36 , ((((p_35 && ((uint16_t)((int16_t)(__builtin_popcountll(((func_64(func_81((~((int16_t)func_81((p_36 != (((l_234 , p_35) != l_234.f0) >= l_235)), l_236) * (int16_t)p_35)), l_220)) , p_35) | 0xD3E2A85B)) ^ l_213) >> (int16_t)3) % (uint16_t)l_213)) == p_36) <= p_36) != l_213)))) <= p_35), l_237)) || 0x0386AEEF) ^ 0xBCF4FF70)) | 0xF5A8E2E1) , p_35)) , l_213);
                    l_237.f0 = __builtin_parityll(l_235);
                }
                else
                { /* block id: 98 */
                    int32_t l_238 = 0xEAB918B3;
                    int16_t l_250 = 0xDB0D;
                    p_35 = (l_235 , ((((__builtin_ffs(p_36) , ((p_36 , 0x2739) < l_238)) , l_234.f0) < (((uint16_t)0x4BAE >> (uint16_t)7) > (l_213 <= 0x0F9FCF56))) < p_36));
                    if (func_71(l_237.f0))
                    { /* block id: 100 */
                        struct S0 l_251 = {-1};
                        l_220.f0 ^= ((((uint16_t)((((uint16_t)(((uint32_t)(~func_81(l_250, l_251)) + (uint32_t)l_213) >= ((uint32_t)((uint16_t)(-(uint16_t)((p_36 <= 0x49A0) , (((l_223 || 65535U) >= l_237.f0) != 0xDDF1))) + (uint16_t)l_257) + (uint32_t)p_36)) % (uint16_t)p_35) || 0xD368) < 0x2EE9E647) * (uint16_t)l_234.f0) > p_35) , l_235);
                        p_35 ^= ((((int16_t)p_36 * (int16_t)(l_237.f0 || (l_234.f0 != ((uint16_t)p_36 >> (uint16_t)3)))) >= (((uint16_t)((uint16_t)((p_36 != ((func_44((((uint32_t)(__builtin_clz(__builtin_ffsl(l_234.f0)) & l_235) + (uint32_t)l_213) & 0x772E), l_250) , p_36) || l_238)) < l_213) << (uint16_t)l_235) << (uint16_t)9) & l_237.f0)) | p_36);
                        p_35 = ((uint16_t)((((int16_t)((__builtin_clzll(((l_223 , ((__builtin_ctzll((func_81((l_237.f0 , 3), l_220) & (-(int16_t)0x6B3E))) == l_235) != ((uint16_t)((((p_35 <= p_36) , l_238) ^ p_35) == p_36) << (uint16_t)7))) <= (-1))) & l_237.f0) ^ l_220.f0) + (int16_t)l_220.f0) || l_235) | l_235) - (uint16_t)l_220.f0);
                    }
                    else
                    { /* block id: 104 */
                        if (p_36)
                            break;
                    }
                }
            }
            if ((~((((uint16_t)(6 == (1 <= ((p_36 >= func_44(l_220.f0, l_220.f0)) && p_35))) * (uint16_t)(l_234 , (p_36 >= 65535U))) == 0xCF1F) && 4294967295U)))
            { /* block id: 109 */
                int32_t l_282 = 0x4662EA83;
                for (p_36 = 0; (p_36 < 21); p_36 += 5)
                { /* block id: 112 */
                    return p_35;
                }
                l_234 = l_234;
                p_35 ^= p_36;
                p_35 = ((l_220.f0 > ((int16_t)l_234.f0 >> (int16_t)func_40(p_35, l_282))) || p_36);
            }
            else
            { /* block id: 118 */
                const struct S0 l_283 = {-9};
                struct S0 l_291 = {0xDD6E749E};
                int32_t l_319 = 0xE13376DD;
                int32_t l_327 = 0xE01CB1AA;
                int32_t l_336 = 0xA4492F3A;
                int32_t l_337 = (-1);
                int32_t l_338 = (-1);
                int32_t l_341 = 0x95FA6978;
                int32_t l_342 = 0x5218622F;
                int32_t l_345 = 0x0578F1FD;
                int32_t l_351 = 5;
                int32_t l_352 = 4;
                int32_t l_356 = (-1);
                int32_t l_364 = 0x88E5EA57;
                int32_t l_365 = 0x99754386;
                int32_t l_366 = 1;
                int32_t l_369 = 0xAC443F89;
                int32_t l_375 = 0x405790A0;
                int32_t l_376 = 0x3EEE2655;
                int32_t l_377 = 0xBDD68C78;
                int32_t l_383 = (-1);
                int32_t l_385 = 0;
                int32_t l_393 = (-1);
                int16_t l_429 = 1;
                struct S0 l_436 = {5};
                l_237 = l_283;
                if (__builtin_popcountll(p_35))
                { /* block id: 120 */
                    uint32_t l_290 = 4294967295U;
                    struct S0 l_300 = {2};
                    int32_t l_320 = 1;
                    int32_t l_321 = 0x6FBCDAFE;
                    int32_t l_324 = (-6);
                    int32_t l_329 = 0xB57BD719;
                    l_291 = func_64(((l_223 ^ (l_237.f0 | ((0x0F14 < ((~(((uint16_t)(__builtin_parityll(l_237.f0) | (l_234 , ((uint16_t)((((l_237 , (l_289 < p_36)) , p_35) , 0x2EADB3B8) >= l_223) >> (uint16_t)p_35))) + (uint16_t)p_35) && l_290)) == 0)) , l_283.f0))) , p_36));
                    for (l_290 = 0; (l_290 <= 25); l_290++)
                    { /* block id: 124 */
                        return p_36;
                    }
                    if (l_290)
                    { /* block id: 127 */
                        int32_t l_310 = 0x7FD2305C;
                        l_234 = func_68(p_35, (l_237.f0 , (__builtin_clzl(p_36) && func_71(((uint16_t)((p_36 < (((((uint16_t)l_290 >> (uint16_t)2) , func_64(p_36)) , l_234.f0) & l_298)) <= l_299) - (uint16_t)1)))));
                        p_35 = l_289;
                        l_234 = l_300;
                        l_220.f0 = (((((int16_t)((p_36 , (((uint16_t)(((uint16_t)((uint32_t)0xAEEA7E62 % (uint32_t)p_35) - (uint16_t)(!(0x892C <= ((func_40(l_237.f0, l_291.f0) , (l_289 >= (l_298 < p_36))) != l_310)))) , l_223) * (uint16_t)l_223) ^ (-9))) || 4U) >> (int16_t)15) != 0xF06B) | l_291.f0) && p_35);
                    }
                    else
                    { /* block id: 132 */
                        uint16_t l_331 = 65535U;
                        l_300.f0 |= func_44(((uint16_t)1U - (uint16_t)__builtin_ffsll(((uint16_t)0xF80D << (uint16_t)14))), p_36);
                        p_35 &= l_299;
                        p_35 = l_290;
                        l_331++;
                    }
                }
                else
                { /* block id: 138 */
                    int32_t l_334 = 0;
                    int32_t l_339 = 1;
                    int32_t l_343 = 0x8A6A471C;
                    int32_t l_344 = (-2);
                    int32_t l_346 = (-1);
                    int32_t l_347 = (-9);
                    int32_t l_348 = 0x7D91602F;
                    int32_t l_353 = (-7);
                    int32_t l_354 = (-1);
                    int32_t l_367 = 0xB5DE8801;
                    int32_t l_370 = 1;
                    int32_t l_371 = 0xEF5FA5D4;
                    int32_t l_372 = 0xB57541A5;
                    int32_t l_374 = 0xF4388EDD;
                    int32_t l_379 = (-8);
                    int32_t l_387 = 0xC209DBF3;
                    int32_t l_388 = (-1);
                    int32_t l_391 = 0x1151B42E;
                    int32_t l_392 = 0x701E8A4B;
                    int32_t l_397 = 0;
                    l_398++;
                    p_35 = ((uint16_t)((int16_t)0x7DC5 >> (int16_t)10) << (uint16_t)6);
                }
                l_234 = l_220;
                if (((uint32_t)((__builtin_ffs(((int16_t)((((uint16_t)((((int16_t)func_73((-(uint16_t)(~((int32_t)((uint16_t)(__builtin_parity((0xF508 | ((p_35 , ((uint16_t)l_396 >> (uint16_t)(func_64(l_323) , ((uint16_t)p_36 + (uint16_t)((uint16_t)(((int32_t)0x6B25F4EC - (int32_t)((uint32_t)0xBD7E762A + (uint32_t)((0x1D10 & (-8)) && p_35))) , p_35) << (uint16_t)p_35))))) , p_36))) > l_384) << (uint16_t)p_36) - (int32_t)p_36))), l_393, l_299) + (int16_t)l_398) ^ l_429) & 0xE874) * (uint16_t)0xDBE3) ^ 0x49A14BB4) || 0xDDC31635) << (int16_t)l_335)) != l_338) > p_36) - (uint32_t)0x123E6323))
                { /* block id: 143 */
                    for (l_289 = 0; (l_289 < 26); l_289++)
                    { /* block id: 146 */
                        uint32_t l_433 = 1U;
                        l_384 = l_432;
                        if (l_433)
                            continue;
                        l_326 = (((((int16_t)p_36 << (int16_t)p_35) ^ ((1 == p_35) >= func_44(l_386, p_35))) , (p_35 || (p_35 >= p_36))) & 1);
                    }
                    l_436 = func_64(p_36);
                    for (l_368 = 23; (l_368 < (-6)); l_368 -= 2)
                    { /* block id: 154 */
                        l_237 = l_234;
                        p_35 = __builtin_popcount(p_35);
                    }
                    l_381 ^= p_36;
                }
                else
                { /* block id: 159 */
                    struct S0 l_439 = {1};
                    l_439 = l_220;
                    for (l_368 = 0; (l_368 != 8); l_368 += 1)
                    { /* block id: 163 */
                        return l_442;
                    }
                    p_35 = ((uint16_t)0U + (uint16_t)(((uint16_t)((func_71(__builtin_parityll((((int16_t)func_73((((int16_t)((l_363 >= (-7)) , (4294967289U > (((int32_t)((func_58(p_36, l_257, l_439.f0, (p_35 == (((l_373 && p_35) < l_381) & 0x43CC1BD8)), l_257) == 0x9A72) > 0x4854B9D9) % (int32_t)p_35) , l_351))) * (int16_t)p_35) != p_36), l_439.f0, p_35) << (int16_t)15) , l_453))) < l_340) == 0) - (uint16_t)l_340) & l_439.f0));
                    if (func_40((l_380 && p_36), p_36))
                    { /* block id: 167 */
                        int32_t l_460 = 0;
                        struct S0 l_461 = {0x2760B0B6};
                        p_35 ^= l_289;
                        p_35 = (((int16_t)((int32_t)((uint16_t)(l_460 & func_58(l_439.f0, __builtin_parityll(((l_461 , p_35) & ((((int16_t)(((int16_t)l_365 >> (int16_t)15) ^ ((__builtin_parityll(l_439.f0) || l_328) && ((uint16_t)l_461.f0 - (uint16_t)0xE61A))) - (int16_t)1U) <= l_298) & p_35))), p_36, l_460, l_439.f0)) << (uint16_t)5) + (int32_t)p_35) << (int16_t)p_35) , 0xB31ACDA0);
                        l_338 = (l_291.f0 , ((uint16_t)l_336 * (uint16_t)(-1)));
                    }
                    else
                    { /* block id: 171 */
                        p_35 = ((int16_t)p_35 << (int16_t)15);
                        return p_36;
                    }
                }
            }
        }
        else
        { /* block id: 177 */
            uint16_t l_481 = 65535U;
            int32_t l_482 = 0xA6C8538B;
            struct S0 l_483 = {0x8A49D51B};
            l_237 = l_220;
            p_35 = (1 < ((((((int32_t)p_35 % (int32_t)((uint16_t)(65535U ^ (((int32_t)(l_220 , (((p_35 ^ p_36) != ((0 || 0xD7FE) < ((((int16_t)(((l_381 | p_35) & 0x83D03F56) == l_480) - (int16_t)l_481) || p_36) & (-7)))) , (-1))) - (int32_t)p_35) && l_481)) >> (uint16_t)6)) < 0x3B0C) || 0x88CFB329) || 0U) , l_482));
            l_220 = l_220;
            l_237 = l_483;
        }
        for (l_328 = (-19); (l_328 <= (-17)); l_328 += 7)
        { /* block id: 185 */
            uint32_t l_490 = 0x4E785703;
            struct S0 l_497 = {0x4C842035};
            p_35 = ((uint32_t)p_36 % (uint32_t)__builtin_ctzll(p_35));
            for (l_322 = 0; (l_322 >= 23); l_322++)
            { /* block id: 189 */
                uint16_t l_494 = 0U;
                p_35 = ((l_490 & ((uint16_t)(!func_40(p_36, ((p_35 || l_494) | ((p_36 > (((0x000DF9B1 || (0xF15A > l_213)) != l_213) == p_35)) | l_326)))) * (uint16_t)0U)) , l_373);
            }
            if (((((uint16_t)65535U + (uint16_t)(0xF174 == (((func_81(l_490, l_497) , (((((uint16_t)((uint16_t)l_490 - (uint16_t)p_35) >> (uint16_t)8) > (func_71(l_381) , l_328)) >= l_386) == 0x22FCAD34)) , (-10)) & p_35))) <= p_36) >= 0xDFA88ACE))
            { /* block id: 192 */
                if (l_490)
                    break;
            }
            else
            { /* block id: 194 */
                struct S0 l_503 = {-1};
                int32_t l_506 = 1;
                if (l_325)
                { /* block id: 195 */
                    l_497 = l_220;
                }
                else
                { /* block id: 197 */
                    int16_t l_502 = 0;
                    if (l_502)
                        break;
                }
                l_506 |= (l_503 , ((int16_t)l_497.f0 << (int16_t)p_36));
                l_350 |= (((__builtin_clzll((l_382 | ((l_398 , l_398) >= ((p_36 || ((((p_35 , __builtin_ctzll((l_389 >= (((int16_t)(((((int16_t)(((int16_t)((int16_t)((int16_t)p_36 % (int16_t)__builtin_ffsll(((int16_t)6 << (int16_t)((uint16_t)((p_36 != l_363) & 0xC59F) * (uint16_t)l_490)))) % (int16_t)l_490) - (int16_t)l_506) & l_386) * (int16_t)0x2A73) || 0xCA7C) != l_497.f0) < 0) << (int16_t)p_36) & l_490)))) != p_36) ^ l_318) && l_503.f0)) == p_35)))) & 0x056B) && 4294967295U) < p_35);
                l_535 = (l_490 != (((int32_t)__builtin_parity((((int16_t)((int32_t)p_36 + (int32_t)(__builtin_ctzll(p_36) , (0U != p_36))) * (int16_t)((((uint16_t)0x28A1 << (uint16_t)p_35) > ((uint32_t)((int16_t)((int16_t)l_503.f0 * (int16_t)0x6562) >> (int16_t)10) % (uint32_t)0xD4506120)) >= p_36)) >= 0xF96B)) % (int32_t)p_36) <= (-1)));
            }
        }
        p_35 = (l_395 ^ ((int32_t)0 + (int32_t)(!(((uint16_t)((int32_t)func_44(((__builtin_popcountll(((uint16_t)p_36 * (uint16_t)((int16_t)p_35 % (int16_t)l_381))) , (8 < (((uint32_t)(((l_453 & ((int16_t)l_394 - (int16_t)l_373)) , 0) <= 4294967287U) % (uint32_t)4U) ^ 0xE797))) , 0xECA3), l_535) % (int32_t)p_36) >> (uint16_t)4) < p_36))));
    }
    return l_237.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_40(int16_t  p_41, int16_t  p_42)
{ /* block id: 85 */
    int32_t l_212 = 0x209DD696;
    return l_212;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_44(uint16_t  p_45, const uint32_t  p_46)
{ /* block id: 37 */
    int16_t l_56 = (-1);
    uint32_t l_67 = 4294967290U;
    uint32_t l_183 = 0xF97FD67A;
    int32_t l_205 = 0;
    l_205 = (((uint16_t)((uint16_t)(((uint16_t)p_46 * (uint16_t)l_56) , (~(((func_58((func_64(p_45) , 0x8F15), p_46, l_67, ((func_68((((func_71(func_73(((uint16_t)0x12A7 << (uint16_t)10), (((int16_t)(p_45 >= 0x6C14) << (int16_t)8) > 0xDB3F), l_56)) == p_46) , l_67) > l_183), l_67) , 1U) , 1), l_67) && l_56) > l_67) & 0x89F1))) - (uint16_t)l_56) >> (uint16_t)7) <= p_46);
    l_205 = l_67;
    return l_205;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_58(const uint16_t  p_59, uint32_t  p_60, uint16_t  p_61, int32_t  p_62, int32_t  p_63)
{ /* block id: 78 */
    const uint32_t l_187 = 0x111B8B91;
    int32_t l_192 = (-1);
    struct S0 l_204 = {0};
    l_192 &= ((int32_t)p_61 + (int32_t)(l_187 ^ ((int16_t)((uint16_t)((0x9193 & (__builtin_ctzl(l_187) | __builtin_bswap64(__builtin_popcount(l_187)))) < p_62) % (uint16_t)l_187) % (int16_t)p_60)));
    l_204 = func_64(((uint16_t)((uint16_t)((uint16_t)((l_187 | (p_63 ^ (-(int32_t)((int16_t)(l_192 >= l_187) * (int16_t)(((p_59 || (((-6) || (l_187 == (0xA5DB >= 0xC010))) <= p_61)) == p_60) && p_59))))) & p_59) * (uint16_t)0x35E6) << (uint16_t)7) << (uint16_t)3));
    return l_204.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_64(int32_t  p_65)
{ /* block id: 38 */
    struct S0 l_66 = {0x2F1EFAE0};
    l_66 = l_66;
    return l_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_68(int32_t  p_69, int16_t  p_70)
{ /* block id: 76 */
    struct S0 l_184 = {0xF1FBA9B0};
    return l_184;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_71(int32_t  p_72)
{ /* block id: 66 */
    int16_t l_153 = 0x4B5F;
    int32_t l_154 = 0x53C78930;
    struct S0 l_162 = {8};
    const int32_t l_163 = 0x7A100109;
    l_154 = l_153;
    l_154 = (l_154 >= (((uint16_t)((!((uint32_t)(((((func_64(((p_72 , (((p_72 , 0) == (p_72 , __builtin_ctzl((((-9) != ((uint16_t)p_72 >> (uint16_t)9)) , func_81(l_153, l_162))))) <= 0xB703)) || l_154)) , l_154) , l_153) <= l_154) != l_162.f0) <= p_72) - (uint32_t)0U)) != p_72) - (uint16_t)p_72) <= 0xDFB1));
    l_154 = ((l_162 , 4) | ((p_72 & ((p_72 > (__builtin_parityl((l_163 && ((((((int16_t)p_72 - (int16_t)(((-(uint32_t)((int16_t)((0x644E > ((int16_t)(((int16_t)(l_162 , ((uint16_t)(0xC5061D60 == p_72) * (uint16_t)l_154)) >> (int16_t)l_163) , 1) << (int16_t)6)) || l_163) >> (int16_t)p_72)) >= 0x2E7E) > l_163)) | 0) < l_163) || p_72) , p_72))) || 0x3390C0CC)) >= l_153)) < l_163));
    for (l_153 = 0; (l_153 >= (-10)); l_153 -= 1)
    { /* block id: 72 */
        int32_t l_179 = 0x2E44315D;
        int32_t l_182 = 0x0BFAB2E0;
        l_182 ^= (l_163 != (func_73((l_162 , ((p_72 , (l_179 && (l_179 > func_73(l_179, ((l_179 | ((int16_t)0xC22E * (int16_t)((l_154 == (-6)) ^ 4294967295U))) == p_72), p_72)))) & p_72)), p_72, l_163) > l_179));
    }
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_73(int16_t  p_74, uint32_t  p_75, int32_t  p_76)
{ /* block id: 41 */
    uint32_t l_90 = 4294967293U;
    struct S0 l_100 = {0xC6596AAD};
    uint16_t l_101 = 65533U;
    uint32_t l_102 = 4294967295U;
    uint16_t l_103 = 2U;
    int32_t l_105 = (-8);
    int32_t l_110 = (-1);
    l_105 ^= func_81(p_75, (((p_74 , ((int32_t)((int32_t)p_74 - (int32_t)(__builtin_popcountl((!(((p_76 > (((func_64(p_75) , (!(l_90 < ((uint16_t)l_90 + (uint16_t)((((((int32_t)((-(int16_t)(((((int32_t)(((int16_t)(func_64(((l_100 , p_75) , 1)) , 0x80ED) << (int16_t)p_75) | l_100.f0) - (int32_t)p_75) < l_101) <= p_76) ^ 0x1B0A)) || l_101) + (int32_t)p_74) & l_100.f0) != l_101) >= (-1)) , l_90))))) >= 1) && l_102)) < l_103) ^ l_102))) && 0xD11E6AC9)) + (int32_t)0xD01971A0)) > 1U) , l_100));
    l_110 ^= ((-3) && (func_81(((uint16_t)(((int16_t)l_105 * (int16_t)l_105) <= ((p_76 != l_100.f0) || ((p_76 && l_100.f0) ^ 1U))) >> (uint16_t)6), func_64(((l_100.f0 , 1) != l_102))) , l_100.f0));
    l_100 = l_100;
    for (l_100.f0 = 0; (l_100.f0 <= 4); l_100.f0++)
    { /* block id: 51 */
        int32_t l_120 = 1;
        uint32_t l_121 = 0x73594313;
        uint32_t l_122 = 0x2B0E7447;
        int32_t l_136 = 0xCD7CB0FD;
        int16_t l_147 = (-10);
        struct S0 l_152 = {0x15C06464};
        for (l_101 = (-12); (l_101 <= 1); l_101 += 1)
        { /* block id: 54 */
            uint32_t l_127 = 0x7F7E758A;
            struct S0 l_135 = {-1};
            for (p_74 = 0; (p_74 <= 28); p_74 += 5)
            { /* block id: 57 */
                const int32_t l_119 = 0xC2D9EA4C;
                uint32_t l_128 = 3U;
                l_110 = ((int16_t)l_119 * (int16_t)(p_75 >= (__builtin_ctzl(__builtin_ctzl(l_120)) , __builtin_ffsl((l_121 <= l_122)))));
                l_136 = (__builtin_popcountl(p_74) , ((p_74 >= ((int16_t)((func_81((((uint16_t)l_127 - (uint16_t)__builtin_ia32_crc32qi(p_75, l_127)) || (l_128 , func_81(((int16_t)((((int16_t)((int16_t)(7 | p_75) << (int16_t)p_76) >> (int16_t)p_74) == p_74) < l_120) << (int16_t)3), l_100))), l_135) , l_120) != 1U) - (int16_t)1U)) , l_135.f0));
            }
            return p_76;
        }
        l_152.f0 = ((uint16_t)(func_81((((((p_75 != ((int32_t)func_81(((uint16_t)((int16_t)((((p_75 >= (l_121 , __builtin_clzl((l_120 , (((uint16_t)((p_75 , ((l_147 <= ((uint32_t)((int16_t)(0x5089D572 && (__builtin_ffs((((((func_81(p_74, l_152) & 65535U) >= p_75) , (-4)) > 4294967287U) > l_102)) , l_136)) % (int16_t)0xB7E8) % (uint32_t)0x80028DF6)) ^ l_102)) >= 0x5DCD) >> (uint16_t)l_122) < 1))))) ^ (-1)) <= 0x05804987) || 0xD7FFC97D) - (int16_t)l_120) << (uint16_t)0), l_152) + (int32_t)l_105)) == l_152.f0) , p_76) < 6) ^ l_136), l_152) < l_102) << (uint16_t)6);
    }
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_81(int32_t  p_82, struct S0  p_83)
{ /* block id: 42 */
    uint32_t l_104 = 0U;
    p_83 = p_83;
    l_104 ^= 0xEDDB647B;
    return p_82;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 148
   depth: 1, occurrence: 22
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 18
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 31, occurrence: 3
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1
   depth: 37, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 523
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 107
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 7
   depth: 2, occurrence: 11
   depth: 3, occurrence: 17
   depth: 4, occurrence: 20
   depth: 5, occurrence: 24

XXX percentage a fresh-made variable is used: 25
XXX percentage an existing variable is used: 75
********************* end of statistics **********************/

