/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      1119587536
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   float  f0;
   uint8_t  f1;
   uint32_t  f2;
};

union U1 {
   volatile int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 0;
static union U0 g_15 = {-0x9.1p+1};
static int32_t g_70 = 0x3AED5EBA;
static float g_76 = 0xF.CDCBD5p+33;
static int32_t *g_78 = &g_5;
static int32_t **g_77 = &g_78;
static volatile union U1 g_142 = {-1};/* VOLATILE GLOBAL g_142 */
static volatile union U1 *g_141 = &g_142;
static union U1 g_159 = {0};/* VOLATILE GLOBAL g_159 */
static volatile union U0 *g_199 = (void*)0;
static volatile union U0 **g_198 = &g_199;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
static union U0 * func_2(int32_t  p_3, union U0 * p_4);
static union U0 * func_6(union U0 * p_7);
static union U0 * func_8(int32_t  p_9, union U0 * p_10, union U0 * p_11, union U0 * p_12, union U0 * p_13);
static int32_t  func_18(union U0 * p_19, float  p_20, union U0  p_21, int32_t  p_22, union U0 * p_23);
static union U0 * func_24(union U0 * p_25, int32_t  p_26, union U0 * p_27);
static union U0 * func_29(uint32_t  p_30, union U0  p_31, int32_t  p_32, uint32_t  p_33, uint16_t  p_34);
static int32_t  func_46(uint32_t  p_47, uint32_t  p_48, int32_t ** p_49, int32_t  p_50, uint16_t  p_51);
static int32_t ** func_52(int32_t ** p_53, union U0 * p_54);
static int32_t ** func_55(union U0 * p_56, union U0  p_57, union U0 * p_58, float  p_59, union U0 * p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_15.f2 g_15 g_15.f1 g_77 g_70 g_78 g_141 g_142.f0 g_159.f0 g_198
 * writes: g_15.f2 g_70 g_76 g_78 g_141
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    union U0 *l_14 = &g_15;
    union U0 **l_185 = &l_14;
    int32_t l_193 = 1;
    union U0 ***l_204 = &l_185;
    union U0 ****l_203 = &l_204;
    union U0 *****l_202 = &l_203;
    uint32_t l_207 = 4294967295U;
    uint32_t l_208 = 0xE2895D01;
    int32_t *l_209 = &g_70;
    (*l_185) = func_2(g_5, func_6(func_8(g_5, l_14, l_14, &g_15, &g_15)));
    /* statement id: 112 */
        assert (l_14 == 0);
    assert (g_78 == 0);
    (*l_209) = ((~(((((int16_t)(((uint16_t)((((int16_t)((l_193 ^ ((((((uint16_t)((int32_t)l_193 % (int32_t)((((void*)0 != g_198) <= ((int32_t)((void*)0 != l_202) / (int32_t)l_193)) || ((g_15.f1 ^ ((int16_t)(l_193 && 0xB70C1D37) >> (int16_t)l_193)) && l_193))) << (uint16_t)l_193) > l_193) == l_193) & l_193) >= l_193)) != g_15.f2) + (int16_t)g_70) <= 3U) == l_207) << (uint16_t)l_208) & g_159.f0) << (int16_t)11) < l_207) < l_207) || l_208)) | l_208);
    (*g_77) = (void*)0;
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_77
 * writes: g_78
 */
static union U0 * func_2(int32_t  p_3, union U0 * p_4)
{ /* block id: 109 */
    int32_t *l_183 = (void*)0;
    union U0 *l_184 = (void*)0;
    (*g_77) = l_183;
    /* statement id: 110 */
    assert (g_78 == 0);
    return l_184;
    /* statement id: 111 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_78
 * writes:
 */
static union U0 * func_6(union U0 * p_7)
{ /* block id: 106 */
    int32_t *l_181 = &g_70;
    union U0 *l_182 = &g_15;
    l_181 = (*g_77);
    /* statement id: 107 */
    assert (l_181 == &g_70 || l_181 == &g_5);
    return l_182;
    /* statement id: 108 */
    //assert (func_6_rv == &g_15);
}


/* ------------------------------------------ */
/* 
 * reads : g_15.f2 g_15 g_5 g_15.f1 g_77 g_70 g_78 g_141 g_142.f0 g_159.f0
 * writes: g_15.f2 g_70 g_76 g_78 g_141
 */
static union U0 * func_8(int32_t  p_9, union U0 * p_10, union U0 * p_11, union U0 * p_12, union U0 * p_13)
{ /* block id: 1 */
    uint32_t l_40 = 0xC1FCC8AF;
    for (g_15.f2 = 0; (g_15.f2 != 55); ++g_15.f2)
    { /* block id: 4 */
        union U0 *l_28 = &g_15;
        int32_t *l_180 = &g_70;
        (*l_180) = ((func_18(func_24(l_28, g_15.f2, func_29(((uint32_t)((uint16_t)((void*)0 != l_28) >> (uint16_t)(l_28 != l_28)) + (uint32_t)p_9), (*p_10), (~0x6C47), g_15.f2, l_40)), l_40, (*p_12), g_15.f1, &g_15) | p_9) == g_5);
        /* statement id: 103 */
        assert (g_78 == &g_70);
    }
    /* facts after for loop */
        assert (g_78 == &g_70 || g_78 == &g_5);
    return p_10;
    /* statement id: 105 */
    //assert (func_8_rv == &g_15);
}


/* ------------------------------------------ */
/* 
 * reads : g_77
 * writes: g_78
 */
static int32_t  func_18(union U0 * p_19, float  p_20, union U0  p_21, int32_t  p_22, union U0 * p_23)
{ /* block id: 99 */
    union U0 *l_177 = &g_15;
    union U0 **l_176 = &l_177;
    union U0 ***l_175 = &l_176;
    union U0 ****l_174 = &l_175;
    union U0 *****l_178 = &l_174;
    int32_t *l_179 = &g_70;
    (*l_178) = l_174;
    (*g_77) = l_179;
    /* statement id: 101 */
    assert (g_78 == &g_70);
    return p_21.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_15 g_15.f1 g_77 g_70 g_78 g_15.f2 g_141 g_142.f0 g_159.f0
 * writes: g_70 g_76 g_78 g_141
 */
static union U0 * func_24(union U0 * p_25, int32_t  p_26, union U0 * p_27)
{ /* block id: 13 */
    int16_t l_61 = 0x7A8D;
    union U0 *l_64 = &g_15;
    float *l_127 = &g_76;
    int32_t *l_131 = &g_70;
    union U1 *l_158 = &g_159;
    union U1 **l_157 = &l_158;
    uint32_t l_163 = 4U;
    if (((-5) | func_46(g_5, p_26, func_52(func_55(&g_15, (*p_25), func_29((p_26 ^ ((0xED73 >= l_61) || ((uint32_t)l_61 / (uint32_t)p_26))), g_15, p_26, p_26, l_61), l_61, l_64), l_64), l_61, p_26)))
    { /* block id: 44 */
        union U0 **l_104 = (void*)0;
        union U0 ***l_105 = &l_104;
        (*l_105) = l_104;
        (*g_77) = (*g_77);
    }
    else
    { /* block id: 47 */
        int32_t *l_108 = (void*)0;
        int32_t l_113 = 0xD96A1273;
        union U0 *l_114 = &g_15;
        union U0 **l_119 = &l_114;
        uint16_t l_164 = 65535U;
lbl_133:
        (*g_77) = (void*)0;
        /* statement id: 48 */
        assert (g_78 == 0);
        if ((((uint16_t)(l_108 != (void*)0) << (uint16_t)p_26) >= (((int32_t)l_61 % (int32_t)((uint16_t)l_113 / (uint16_t)g_15.f1)) == (p_26 & (&g_15 == l_114)))))
        { /* block id: 49 */
            float l_126 = 0x5.8p-1;
            for (l_113 = 0; (l_113 == (-10)); l_113 -= 1)
            { /* block id: 52 */
                const float *l_128 = (void*)0;
                int32_t l_132 = (-4);
                union U0 **l_134 = &l_64;
                if ((((int32_t)(l_119 != (void*)0) % (int32_t)((uint16_t)((int16_t)((int32_t)(((l_61 >= p_26) || (l_108 == l_127)) != (l_128 == l_128)) + (int32_t)(p_26 && p_26)) << (int16_t)6) / (uint16_t)1)) >= p_26))
                { /* block id: 53 */
                    for (l_61 = 7; (l_61 <= 29); l_61++)
                    { /* block id: 56 */
                        l_131 = &l_113;
                        /* statement id: 57 */
                        assert (l_131 == &l_113);
                        if (l_132)
                            break;
                        (*g_77) = (*g_77);
                        (*g_77) = (void*)0;
                    }
                    /* facts after for loop */
                    assert (l_131 == &l_113 || l_131 == &g_70);
                    return &g_15;
                    /* statement id: 62 */
                    //assert (func_24_rv == &g_15);
                }
                else
                { /* block id: 63 */
                    if (l_113)
                        goto lbl_133;
                    if (p_26)
                        break;
                    (*l_127) = (0x7.2A541Ep-49 > (l_134 == l_134));
                    (*g_77) = (*g_77);
                }
                l_132 = (g_15.f2 == (&l_113 == &l_113));
            }
        }
        else
        { /* block id: 71 */
            uint32_t l_150 = 4U;
            for (l_61 = 0; (l_61 == 0); l_61 += 3)
            { /* block id: 74 */
                for (g_70 = (-2); (g_70 != (-16)); g_70 -= 1)
                { /* block id: 77 */
                    int16_t l_147 = 0x90BB;
                    for (p_26 = 0; (p_26 != (-20)); p_26 -= 1)
                    { /* block id: 80 */
                        volatile union U1 **l_143 = &g_141;
                        union U0 ***l_145 = &l_119;
                        union U0 ****l_144 = &l_145;
                        union U0 *****l_146 = &l_144;
                        (*l_143) = g_141;
                        (*l_146) = l_144;
                        (*l_127) = l_147;
                    }
                    if (g_70)
                        goto lbl_133;
                    if (l_147)
                        goto lbl_133;
                }
            }
            (*l_131) = ((0x7B59 | (((((uint16_t)l_150 % (uint16_t)((int16_t)((((int16_t)(((g_142.f0 < (0x33B9E22A <= (((void*)0 != &p_27) | (l_157 == &l_158)))) <= (((uint16_t)((!(0xFFB9 < p_26)) >= l_163) + (uint16_t)p_26) > p_26)) >= p_26) << (int16_t)14) >= l_150) < p_26) >> (int16_t)5)) ^ 1) <= l_164) == (*l_131))) || 65526U);
        }
        for (l_164 = 0; (l_164 > 39); l_164++)
        { /* block id: 93 */
            int32_t l_167 = 0x131093E8;
            (*l_131) = (l_167 >= (((((uint32_t)((l_127 == &l_113) ^ p_26) + (uint32_t)(&l_131 == &l_131)) == (((uint32_t)0U / (uint32_t)p_26) > (0x3BB2BE9F | g_159.f0))) > g_15.f1) & g_15.f2));
        }
    }
    /* facts after branching */
    assert (g_78 == 0 || g_78 == &g_70);
    (*l_157) = &g_159;
    return p_27;
    /* statement id: 98 */
    //assert (func_24_rv == &g_15);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0 * func_29(uint32_t  p_30, union U0  p_31, int32_t  p_32, uint32_t  p_33, uint16_t  p_34)
{ /* block id: 5 */
    int32_t *l_45 = &g_5;
    int32_t **l_44 = &l_45;
    for (p_32 = 0; (p_32 >= 4); p_32++)
    { /* block id: 8 */
        union U0 *l_43 = &g_15;
        return l_43;
        /* statement id: 9 */
        //assert (func_29_rv == &g_15);
    }
    (*l_44) = &g_5;
    return &g_15;
    /* statement id: 12 */
    //assert (func_29_rv == &g_15);
}


/* ------------------------------------------ */
/* 
 * reads : g_77 g_70 g_78
 * writes: g_78 g_70
 */
static int32_t  func_46(uint32_t  p_47, uint32_t  p_48, int32_t ** p_49, int32_t  p_50, uint16_t  p_51)
{ /* block id: 39 */
    int32_t *l_92 = &g_70;
    const union U0 *l_102 = &g_15;
    uint16_t l_103 = 0xF477;
    (*g_77) = l_92;
    /* statement id: 40 */
    assert (g_78 == &g_70);
    (*l_92) = ((((-(int16_t)0xDE68) ^ ((uint16_t)(((void*)0 != l_92) == (((uint16_t)p_50 % (uint16_t)(*l_92)) < ((uint16_t)(p_49 == &l_92) % (uint16_t)((int16_t)((l_102 == (void*)0) & (**p_49)) + (int16_t)0x9686)))) - (uint16_t)g_70)) < g_70) || (*l_92));
    (*g_77) = l_92;
    return l_103;
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_77 g_78
 * writes: g_78
 */
static int32_t ** func_52(int32_t ** p_53, union U0 * p_54)
{ /* block id: 25 */
    float l_83 = 0x0.7p-1;
    int32_t l_84 = 5;
    if (((uint32_t)(((int16_t)l_84 + (int16_t)(!(4294967295U != ((uint32_t)g_70 + (uint32_t)5)))) | (((-1) || 1) < (-1))) - (uint32_t)((int16_t)((void*)0 == p_54) % (int16_t)l_84)))
    { /* block id: 26 */
        for (l_84 = (-29); (l_84 <= (-24)); ++l_84)
        { /* block id: 29 */
            return p_53;
            /* statement id: 30 */
            //assert (func_52_rv == &g_78);
        }
        (*g_77) = (*g_77);
        (*p_53) = (*g_77);
    }
    else
    { /* block id: 34 */
        (*p_53) = (*g_77);
        return &g_78;
        /* statement id: 36 */
        //assert (func_52_rv == &g_78);
    }
    return p_53;
    /* statement id: 38 */
    //assert (func_52_rv == &g_78);
}


/* ------------------------------------------ */
/* 
 * reads : g_15.f1 g_77
 * writes: g_70 g_76
 */
static int32_t ** func_55(union U0 * p_56, union U0  p_57, union U0 * p_58, float  p_59, union U0 * p_60)
{ /* block id: 14 */
    const int32_t *l_68 = &g_5;
    const int32_t **l_67 = &l_68;
    int32_t *l_69 = &g_70;
    (*l_69) = ((int16_t)(((void*)0 != l_67) <= g_15.f1) >> (int16_t)p_57.f1);
    (*l_67) = (*l_67);
    for (p_57.f1 = 0; (p_57.f1 <= 12); p_57.f1 += 2)
    { /* block id: 19 */
        float *l_75 = &g_76;
        (*l_67) = (*l_67);
        (*l_75) = ((float)0x1.9p+1 - (float)0x1.Cp-1);
        return g_77;
        /* statement id: 22 */
        //assert (func_55_rv == &g_78);
    }
    /* facts after for loop */
        return &g_78;
    /* statement id: 24 */
    //assert (func_55_rv == &g_78);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc_bytes (&g_15.f0, sizeof(g_15.f0), "g_15.f0", print_hash_value);
    transparent_crc(g_15.f1, "g_15.f1", print_hash_value);
    transparent_crc(g_15.f2, "g_15.f2", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc_bytes (&g_76, sizeof(g_76), "g_76", print_hash_value);
    transparent_crc(g_142.f0, "g_142.f0", print_hash_value);
    transparent_crc(g_159.f0, "g_159.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 44
XXX total union variables: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 11
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 70

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 16
breakdown:
   depth: 1, occurrence: 15
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 31
breakdown:
   depth: 1, occurrence: 31
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 64

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 69
   level: 2, occurrence: 7
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 15
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 12.9
XXX average alias set size: 1.06

XXX times a non-volatile is read: 176
XXX times a non-volatile is write: 75
XXX times a volatile is read: 3
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 19
XXX percentage of non-volatile access: 98.8

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 68
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 15
   depth: 2, occurrence: 5
   depth: 3, occurrence: 3
   depth: 4, occurrence: 9
   depth: 5, occurrence: 7

XXX percentage a fresh-made variable is used: 23.5
XXX percentage an existing variable is used: 76.5
********************* end of statistics **********************/

