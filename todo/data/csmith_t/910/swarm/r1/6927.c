/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      161091578
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
   const volatile int8_t  f1;
   int8_t  f2;
   volatile uint8_t  f3;
   int64_t  f4;
   volatile int32_t  f5;
   uint32_t  f6;
   const signed f7 : 17;
   float  f8;
   const volatile unsigned f9 : 27;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 4294967293UL;
static int32_t g_114 = (-10L);
static int32_t *g_169 = &g_114;
static uint64_t g_182 = 18446744073709551615UL;
static int16_t g_184 = 0x75E5L;
static float g_186 = 0x3.972AE7p-86;
static struct S0 g_205 = {9UL,0L,0xDDL,1UL,0x98BFE20E5FF1E6A9LL,0xE86D8666L,0x7B7FC80EL,-341,0x0.Bp+1,5802};/* VOLATILE GLOBAL g_205 */
static float *g_210 = &g_205.f8;
static int32_t ****g_243 = (void*)0;
static struct S0 g_248 = {3UL,0x96L,0x0AL,0xD9L,1L,-1L,0x49BB206EL,257,0xB.3327D6p+3,7524};/* VOLATILE GLOBAL g_248 */
static int32_t g_257 = 0x329542E1L;
static struct S0 g_261 = {0x43BDL,0xAFL,0x5AL,0xD2L,0x52D83404B277A049LL,0x3F908AAEL,4294967293UL,-321,0xB.5314CBp-74,11401};/* VOLATILE GLOBAL g_261 */
static volatile float g_280 = 0x2.B82FD0p-36;/* VOLATILE GLOBAL g_280 */
static struct S0 g_308 = {0x789FL,-4L,8L,1UL,0x3EABFC5C242C3BECLL,0x0692321CL,0xB2DCD15BL,328,0x9.1DD053p-43,6443};/* VOLATILE GLOBAL g_308 */
static int32_t **g_313 = &g_169;
static int32_t ***g_312 = &g_313;
static int32_t ****g_379 = &g_312;
static int32_t **** const *g_378 = &g_379;


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_28(void);
static int8_t  func_31(int32_t  p_32, int32_t  p_33);
static int8_t  func_37(int16_t  p_38, uint16_t  p_39, float  p_40);
static uint8_t  func_41(int32_t  p_42, int32_t  p_43, int64_t  p_44, int32_t  p_45, int64_t  p_46);
static int8_t  func_51(uint32_t  p_52);
static uint16_t  func_61(uint32_t  p_62);
static int8_t  func_65(uint64_t  p_66, const uint64_t  p_67, int32_t  p_68, int64_t  p_69, const float  p_70);
static const uint8_t  func_75(uint32_t  p_76, float  p_77, const uint8_t  p_78, uint16_t  p_79, const uint32_t  p_80);
static uint8_t  func_81(uint32_t  p_82, int16_t  p_83, uint16_t  p_84, uint8_t  p_85);
static uint16_t  func_98(int32_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_114 g_182 g_184 g_169 g_205 g_210 g_257 g_243 g_248 g_261 g_312 g_313 g_308.f4 g_308.f0 g_308.f1 g_378 g_379
 * writes: g_114 g_169 g_186 g_182 g_243 g_205.f5 g_205.f8 g_308.f0 g_257
 */
static const uint32_t  func_28(void)
{ /* block id: 36 */
    uint16_t l_34 = 65534UL;
    int32_t ***l_385 = &g_313;
    const uint16_t l_392 = 6UL;
    int16_t l_393 = 0xCAD0L;
    float l_394 = 0x2.53DDF2p-2;
    int32_t l_395 = 0xA0C2CFD8L;
    struct S0 *l_398 = &g_308;
    float **l_432 = &g_210;
    float ***l_431 = &l_432;
    if ((__builtin_popcountll((((uint8_t)((func_31(l_34, l_34) <= (__builtin_bswap64((l_34 || (((int16_t)l_34 >> (int16_t)((((g_248.f4 != ((((uint16_t)func_51(l_34) + (uint16_t)(((g_308.f4 , g_261.f6) , g_378) != &g_379)) , g_261.f4) >= l_34)) ^ 0xA6040539L) > (-7L)) ^ 0UL)) | g_248.f0))) == g_261.f0)) ^ l_34) << (uint8_t)g_308.f4) , 0xF7F697AC61EB78E1LL)) , l_34))
    { /* block id: 214 */
        int8_t l_384 = 0xF6L;
        int32_t l_397 = (-7L);
        for (g_114 = 0; (g_114 <= 1); g_114 += 3)
        { /* block id: 217 */
            int8_t l_396 = 0x8CL;
            struct S0 **l_399 = &l_398;
            struct S0 *l_400 = (void*)0;
            (*l_399) = (((int32_t)l_384 - (int32_t)(((void*)0 == l_385) == ((int16_t)(0L != l_384) << (int16_t)((+((((((l_384 >= ((((((int8_t)((func_98((~(g_205.f3 >= l_395))) == l_396) >= g_257) >> (int8_t)0) , &l_385) != (void*)0) >= l_384) <= l_384)) || l_397) , l_398) != (void*)0) & g_261.f6) , g_261.f0)) , l_397)))) , &g_205);
            (*l_399) = l_400;
        }
    }
    else
    { /* block id: 221 */
        float l_407 = 0x0.1p+1;
        int32_t l_416 = 0x05E8E35BL;
        int32_t ****l_430 = (void*)0;
        (*g_210) = ((float)((((float)((float)(0x3.017171p-32 < l_407) * (float)((*g_210) != __builtin_popcount(g_261.f3))) + (float)0xE.0D92E2p-47) > ((float)((-0x4.7p-1) == func_65(l_392, ((uint8_t)((uint16_t)__builtin_ctz(((int8_t)g_261.f0 / (int8_t)0x30L)) >> (uint16_t)g_205.f6) % (uint8_t)g_308.f4), g_308.f4, l_416, (*g_210))) + (float)(*g_210))) >= 0x5.Fp-1) * (float)0x5.BD02CDp+55);
        for (l_34 = (-24); (l_34 > 25); l_34 += 2)
        { /* block id: 225 */
            const uint8_t l_423 = 0UL;
            (*g_169) = ((uint16_t)((uint64_t)(***l_385) % (uint64_t)__builtin_clz(g_184)) + (uint16_t)((0x5F7A7125L > (l_423 >= ((**g_379) != (void*)0))) <= (((((g_261.f4 == ((uint8_t)((uint8_t)(func_98(((((uint64_t)(l_430 != (void*)0) + (uint64_t)g_205.f1) ^ (***l_385)) != (-8L))) , g_184) >> (uint8_t)g_261.f2) / (uint8_t)255UL)) ^ 0xBABF0F96L) , (void*)0) == &g_243) != (-5L))));
            (**l_385) = (*g_313);
        }
    }
    (*l_431) = (void*)0;
    return l_393;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_114 g_182 g_184 g_169 g_205 g_210 g_257 g_243 g_248 g_261 g_312 g_313 g_308.f4 g_308.f0 g_308.f1
 * writes: g_114 g_169 g_186 g_182 g_243 g_205.f5 g_205.f8 g_308.f0 g_257
 */
static int8_t  func_31(int32_t  p_32, int32_t  p_33)
{ /* block id: 37 */
    uint16_t l_59 = 0x8B4BL;
    int8_t l_60 = (-1L);
    int32_t *l_373 = &g_257;
    (*l_373) = ((int8_t)func_37(p_32, g_3, (p_32 == (((func_41((((((uint8_t)p_32 * (uint8_t)((int8_t)func_51(p_33) * (int8_t)((uint64_t)p_33 % (uint64_t)p_32))) > g_3) ^ l_59) ^ l_59), g_3, l_60, g_3, g_3) & p_33) || l_59) , l_59))) % (int8_t)0xEEL);
    return g_257;
}


/* ------------------------------------------ */
/* 
 * reads : g_313 g_312 g_210 g_182
 * writes: g_169 g_257 g_205.f8
 */
static int8_t  func_37(int16_t  p_38, uint16_t  p_39, float  p_40)
{ /* block id: 195 */
    float l_355 = 0x2.3p+1;
    int32_t l_367 = 7L;
    int32_t *l_370 = &l_367;
    if (p_38)
    { /* block id: 196 */
        int32_t *l_356 = (void*)0;
        (*g_313) = l_356;
        return p_39;
    }
    else
    { /* block id: 199 */
        int32_t l_357 = 0x52FF0263L;
        int32_t *l_358 = &g_257;
        const int32_t *l_361 = &g_257;
        const int32_t **l_360 = &l_361;
        const int32_t ***l_359 = &l_360;
        const int32_t ****l_362 = &l_359;
        int32_t *l_371 = &l_367;
        (*l_358) = l_357;
        (*l_362) = l_359;
        for (l_357 = (-2); (l_357 <= (-27)); l_357 -= 4)
        { /* block id: 204 */
            struct S0 *l_366 = &g_205;
            const int32_t *****l_372 = &l_362;
            (*l_358) = (((!((void*)0 == l_366)) == l_367) >= ((int8_t)((p_38 , &g_205) != &g_261) * (int8_t)(l_370 != (void*)0)));
            (**g_312) = l_371;
            (*l_372) = &l_359;
        }
        (*g_210) = (-0x3.Ap+1);
    }
    return g_182;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_114 g_182 g_184 g_169 g_205 g_210 g_257 g_243 g_248 g_261 g_312 g_313 g_308.f4 g_308.f0 g_308.f1
 * writes: g_114 g_169 g_186 g_182 g_243 g_205.f5 g_205.f8 g_308.f0 g_257
 */
static uint8_t  func_41(int32_t  p_42, int32_t  p_43, int64_t  p_44, int32_t  p_45, int64_t  p_46)
{ /* block id: 45 */
    const float l_90 = 0x8.1p-1;
    int32_t l_91 = (-6L);
    int64_t l_112 = 1L;
    struct S0 *l_307 = &g_308;
    int32_t ***l_314 = &g_313;
    if (((func_61((((0xA9172C2EL == ((int8_t)(func_65(((int16_t)((((uint32_t)((func_75((0xAEL < func_81(p_43, ((int8_t)((uint16_t)3UL * (uint16_t)l_91) << (int8_t)((uint32_t)((int16_t)l_91 - (int16_t)(((uint16_t)func_98(p_42) << (uint16_t)__builtin_parity(l_112)) , 0xADDAL)) + (uint32_t)l_112)), g_3, g_3)), l_91, g_3, g_182, l_112) , l_91) < g_205.f7) / (uint32_t)l_112) < l_112) && p_45) << (int16_t)p_44), l_112, g_205.f2, p_42, l_112) != 8UL) >> (int8_t)l_112)) <= p_43) < 0x5138A19F7B7F5E46LL)) && p_42) || l_112))
    { /* block id: 147 */
        int16_t l_277 = 0x019AL;
        int32_t **l_283 = &g_169;
        float *l_310 = &g_186;
lbl_342:
        if (p_45)
        { /* block id: 148 */
            int32_t **l_275 = (void*)0;
            int32_t **l_276 = &g_169;
            (*l_276) = &p_42;
        }
        else
        { /* block id: 150 */
            return g_261.f3;
        }
        if (p_45)
        { /* block id: 153 */
            uint64_t l_286 = 0x06B0FEA9B3E444B3LL;
            float *l_311 = &g_186;
            int32_t *l_321 = &g_114;
            if ((l_277 | (((uint64_t)(0x83B52146C8C352A3LL < l_91) % (uint64_t)l_91) | (&p_43 != (void*)0))))
            { /* block id: 154 */
                uint64_t l_287 = 7UL;
lbl_306:
                l_91 = (((((float)(&g_169 != l_283) + (float)(*g_210)) >= ((float)(func_98(l_286) >= ((((*g_210) != (l_287 == 0x3.943C49p+9)) < p_46) > 0xE.8AA9EEp-6)) * (float)0x1.8p-1)) > p_42) != (**l_283));
                if (((__builtin_ctzl(((uint16_t)(**l_283) >> (uint16_t)1)) || ((int64_t)((uint8_t)(((+(((uint64_t)func_75(p_44, (l_286 != ((*g_210) <= l_91)), l_91, ((((uint64_t)((l_286 < ((((-(uint16_t)(func_65(p_42, g_261.f3, g_248.f6, p_43, p_45) , l_112)) < 8UL) , (*g_169)) <= g_182)) ^ 0xC9L) + (uint64_t)6UL) >= p_44) , g_205.f6), p_45) - (uint64_t)1UL) != g_261.f7)) <= g_248.f2) <= p_45) * (uint8_t)g_261.f6) % (int64_t)l_286)) , l_287))
                { /* block id: 156 */
                    uint64_t l_317 = 9UL;
                    const int32_t *l_318 = &g_114;
                    if (((int8_t)((((int16_t)func_65((p_46 , g_205.f1), ((l_287 ^ ((int64_t)g_248.f7 - (int64_t)(__builtin_parity(p_44) <= 0L))) , 0x1A94851BE001E574LL), __builtin_ffsll(((*g_169) < g_248.f2)), g_205.f4, (*g_210)) * (int16_t)g_248.f4) != l_287) != 65533UL) / (int8_t)p_46))
                    { /* block id: 157 */
                        if (g_261.f4)
                            goto lbl_306;
                        l_307 = &g_205;
                    }
                    else
                    { /* block id: 160 */
                        uint64_t l_309 = 0xB25A575AA0C160E5LL;
                        const int32_t **l_319 = (void*)0;
                        const int32_t **l_320 = &l_318;
                        (*g_210) = ((l_309 > (l_310 != l_311)) >= (l_112 < ((g_312 != l_314) >= ((((uint16_t)g_261.f6 / (uint16_t)((***l_314) && g_261.f5)) , l_317) < (*g_210)))));
                        (*l_310) = (p_44 == func_61(g_261.f5));
                        (*l_320) = (g_205.f5 , l_318);
                    }
                    (**g_312) = (**l_314);
                    (*g_313) = (*g_313);
                    l_321 = (**g_312);
                }
                else
                { /* block id: 168 */
                    int32_t *l_324 = &g_114;
                    if ((**g_313))
                    { /* block id: 169 */
                        int32_t ** const *l_323 = &l_283;
                        int32_t ** const **l_322 = &l_323;
                        (*g_169) = (l_322 != &g_312);
                        l_324 = (void*)0;
                        return g_261.f2;
                    }
                    else
                    { /* block id: 173 */
                        int64_t l_341 = 0L;
                        l_341 = (func_98((((uint8_t)((uint16_t)(((!g_205.f0) <= (((g_261.f5 >= (!((uint64_t)((((void*)0 != &g_243) && (((uint16_t)((uint8_t)(((g_182 != (*l_324)) && (((0L > (**g_313)) < ((int16_t)(((void*)0 == (*g_313)) , 0x62F7L) - (int16_t)g_182)) || p_42)) < g_248.f0) * (uint8_t)7UL) << (uint16_t)14) > (***g_312))) , p_44) - (uint64_t)g_261.f4))) == 5L) , g_205.f7)) , g_261.f5) + (uint16_t)g_308.f4) + (uint8_t)0UL) || 0xB5212171L)) >= (-1L));
                    }
                    if (g_114)
                        goto lbl_342;
                }
                return (*l_321);
            }
            else
            { /* block id: 179 */
                return p_42;
            }
        }
        else
        { /* block id: 182 */
            return g_261.f1;
        }
    }
    else
    { /* block id: 185 */
        uint32_t l_345 = 0x236C3F1CL;
        int32_t *l_354 = &g_257;
        for (g_308.f0 = 0; (g_308.f0 >= 27); ++g_308.f0)
        { /* block id: 188 */
            if (l_345)
                break;
            if ((**g_313))
                break;
        }
        (*l_354) = ((int16_t)((int64_t)0x880EE76E8D941ABELL % (int64_t)((uint16_t)(((int8_t)p_44 % (int8_t)func_75(g_308.f4, (*g_210), p_45, (***l_314), g_308.f1)) >= (p_46 >= 0x72L)) >> (uint16_t)l_345)) * (int16_t)p_43);
    }
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_51(uint32_t  p_52)
{ /* block id: 38 */
    int16_t l_56 = 0xCAB4L;
    for (p_52 = 0; (p_52 != 5); p_52 += 5)
    { /* block id: 41 */
        uint8_t l_55 = 1UL;
        if (l_55)
            break;
    }
    return l_56;
}


/* ------------------------------------------ */
/* 
 * reads : g_182 g_114 g_169 g_257 g_3 g_205.f0 g_205.f2 g_210 g_205.f8 g_243 g_248 g_261 g_205.f4 g_184
 * writes: g_182 g_114 g_169 g_243 g_205.f5 g_205.f8
 */
static uint16_t  func_61(uint32_t  p_62)
{ /* block id: 112 */
    int32_t **l_225 = &g_169;
    int32_t ***l_226 = (void*)0;
    int32_t ***l_227 = (void*)0;
    int32_t ***l_228 = &l_225;
    uint8_t l_242 = 0x8DL;
    uint32_t l_272 = 0xE808619DL;
    int16_t l_274 = (-8L);
    (*l_228) = l_225;
    if (p_62)
    { /* block id: 114 */
        int64_t l_237 = (-1L);
        int32_t * const *l_253 = &g_169;
        int32_t * const **l_252 = &l_253;
        int32_t * const ***l_251 = &l_252;
        int32_t *l_260 = (void*)0;
        for (g_182 = 0; (g_182 == 17); g_182 += 2)
        { /* block id: 117 */
            int16_t l_245 = 0L;
            int32_t *l_258 = &g_257;
            for (g_114 = 0; (g_114 < 18); g_114 += 3)
            { /* block id: 120 */
                int32_t ***l_236 = (void*)0;
                int32_t *l_259 = &g_114;
                for (p_62 = 14; (p_62 != 60); p_62 += 1)
                { /* block id: 123 */
                    int32_t *l_256 = &g_257;
                    if ((*g_169))
                        break;
                    if (((((-(uint8_t)(l_236 == (void*)0)) < (__builtin_popcountl(((l_237 , &g_114) == (void*)0)) | __builtin_ffs((*g_169)))) , func_98(__builtin_bswap64(func_65(((uint16_t)(((int32_t)p_62 % (int32_t)0xE9505AA5L) | g_205.f0) % (uint16_t)g_205.f0), g_205.f2, l_242, g_205.f2, (*g_210))))) ^ 0x11BDL))
                    { /* block id: 125 */
                        int32_t *****l_244 = &g_243;
                        (*l_244) = g_243;
                    }
                    else
                    { /* block id: 127 */
                        const float l_254 = (-0x6.7p-1);
                        int32_t l_255 = (-1L);
                        g_205.f5 = (((func_65(l_245, func_51((((int8_t)__builtin_clzl((((__builtin_clzll(p_62) == p_62) , g_248) , ((__builtin_clzl(((uint16_t)6UL << (uint16_t)((void*)0 != l_251))) | (-9L)) < p_62))) << (int8_t)p_62) <= p_62)), g_248.f6, l_245, l_254) , p_62) & p_62) != l_255);
                    }
                    l_256 = (*l_225);
                    (*l_225) = l_258;
                }
                l_260 = l_259;
                l_260 = l_259;
                if (p_62)
                    break;
            }
            return g_248.f7;
        }
        (*l_225) = (**l_228);
        (***l_228) = (g_261 , ((p_62 >= (&l_225 != (void*)0)) , p_62));
    }
    else
    { /* block id: 141 */
        int32_t **l_273 = (void*)0;
        (*g_210) = 0xF.857D90p-25;
        (*g_210) = ((float)p_62 - (float)func_65(g_248.f5, ((((int8_t)((int16_t)0xA952L - (int16_t)(((int8_t)((int16_t)l_272 * (int16_t)(1L ^ (*g_169))) << (int8_t)(l_273 == (void*)0)) , (l_274 < g_257))) / (int8_t)g_205.f4) && g_261.f0) <= g_261.f6), g_184, p_62, p_62));
    }
    (**l_228) = (**l_228);
    return g_257;
}


/* ------------------------------------------ */
/* 
 * reads : g_205.f2
 * writes: g_169
 */
static int8_t  func_65(uint64_t  p_66, const uint64_t  p_67, int32_t  p_68, int64_t  p_69, const float  p_70)
{ /* block id: 109 */
    int32_t **l_224 = &g_169;
    (*l_224) = &g_114;
    return g_205.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_182 g_205 g_114 g_3 g_184 g_169 g_210 g_257
 * writes: g_182 g_114 g_169 g_186 g_257
 */
static const uint8_t  func_75(uint32_t  p_76, float  p_77, const uint8_t  p_78, uint16_t  p_79, const uint32_t  p_80)
{ /* block id: 95 */
    uint64_t l_211 = 0x16A95EDDA54EEA5DLL;
    for (g_182 = 0; (g_182 == 16); g_182 += 1)
    { /* block id: 98 */
        float l_199 = 0x5.86663Ap-70;
        int32_t l_204 = 1L;
        int16_t l_208 = 0L;
        float *l_209 = &g_205.f8;
        int32_t *l_212 = &g_114;
        (*l_212) = ((p_78 | ((((((int16_t)func_81((p_76 >= (func_98((((int8_t)p_78 - (int8_t)(((__builtin_clzll(((l_204 , ((9UL & (g_205 , ((int16_t)l_204 + (int16_t)func_81(l_208, p_80, p_79, p_80)))) , l_209)) != g_210)) != l_204) , g_205.f0) && l_211)) >= p_79)) <= p_78)), g_205.f6, g_205.f7, p_80) / (int16_t)p_76) , g_3) != l_211) < p_80) , 1L)) , (*g_169));
        for (l_204 = 5; (l_204 >= (-12)); l_204--)
        { /* block id: 102 */
            return g_205.f5;
        }
        return l_211;
    }
    (*g_169) = ((((uint16_t)g_205.f4 - (uint16_t)3UL) >= (*g_169)) < (!((((uint16_t)(l_211 & l_211) >> (uint16_t)g_205.f0) < (g_205.f7 >= (((int8_t)((int8_t)l_211 >> (int8_t)(p_80 > p_78)) >> (int8_t)p_79) < l_211))) ^ 0x13L)));
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads : g_114 g_3 g_182 g_184 g_169 g_257
 * writes: g_114 g_169 g_186
 */
static uint8_t  func_81(uint32_t  p_82, int16_t  p_83, uint16_t  p_84, uint8_t  p_85)
{ /* block id: 49 */
    int32_t *l_113 = &g_114;
    int32_t **l_115 = &l_113;
    uint32_t l_187 = 0x7C683C3FL;
    (*l_115) = l_113;
    (**l_115) = 0x1F898AFBL;
    if ((p_84 >= ((func_98(func_51((**l_115))) , (-(uint16_t)g_3)) == (~g_3))))
    { /* block id: 52 */
        int64_t l_129 = 0x83D71515025B9248LL;
        if (p_82)
        { /* block id: 53 */
            uint16_t l_132 = 0xD71AL;
            for (p_83 = 10; (p_83 <= (-28)); p_83--)
            { /* block id: 56 */
                int32_t l_135 = 0x8E2D0685L;
                int32_t l_167 = 0x3CD92788L;
                int32_t *l_168 = &g_114;
                if (((int8_t)2L - (int8_t)((uint64_t)(((0xECL ^ (((uint16_t)(+g_114) * (uint16_t)g_114) ^ (((p_85 ^ (g_3 >= (-5L))) <= l_129) <= 0x9C0213A2BBEBC4FFLL))) , g_114) & g_114) / (uint64_t)p_85)))
                { /* block id: 57 */
                    uint16_t l_149 = 0UL;
                    int8_t l_150 = 0xF4L;
                    int32_t *l_151 = &l_135;
                    (*l_115) = (void*)0;
                    (*l_151) = (g_114 | func_98(((int16_t)(l_132 != ((int16_t)((((l_135 > ((uint8_t)(((int16_t)0xDF8BL * (int16_t)g_114) , (((int16_t)(((int32_t)p_85 + (int32_t)((uint32_t)__builtin_bswap64(((int64_t)(g_3 || (+(g_114 != ((l_132 <= g_114) >= l_149)))) - (int64_t)0x84ACF1AFC50B8361LL)) / (uint32_t)g_114)) && l_150) % (int16_t)l_149) || l_135)) / (uint8_t)0xC2L)) , l_132) || 0xE52BDABFL) , 0L) * (int16_t)65534UL)) * (int16_t)p_82)));
                }
                else
                { /* block id: 60 */
                    int32_t *l_152 = &g_114;
                    if (l_129)
                        break;
                    (*l_115) = l_152;
                }
                l_135 = 0x83983135L;
                (*l_168) = (0x140BD20A5AE12EA5LL || (((int8_t)(((int16_t)((((int64_t)0L - (int64_t)(0x5884173B194E8990LL <= ((uint16_t)((uint16_t)(l_132 & (0x9C7346DDL && ((uint32_t)l_135 + (uint32_t)0x2D388EECL))) - (uint16_t)0x6690L) % (uint16_t)g_114))) & g_114) , g_3) - (int16_t)l_167) != 0x6F2BE0B9L) * (int8_t)g_3) > 0xB0L));
            }
        }
        else
        { /* block id: 67 */
            int16_t l_173 = 0L;
            int32_t *l_180 = &g_114;
            if (g_3)
            { /* block id: 68 */
                g_169 = &g_114;
            }
            else
            { /* block id: 70 */
                uint8_t l_172 = 253UL;
                int32_t * const l_181 = &g_114;
                if (((-2L) <= (((uint16_t)(l_172 < 0UL) / (uint16_t)__builtin_parityll(l_173)) & ((int64_t)((((g_3 >= __builtin_ctz(((int32_t)((l_172 >= l_173) <= p_83) / (int32_t)0x2C337E63L))) ^ (-1L)) , 0x9AE860EEL) <= 0x78ED21FDL) % (int64_t)p_85))))
                { /* block id: 71 */
                    float *l_185 = &g_186;
                    (**l_115) = (((int64_t)(l_180 == ((*l_113) , l_181)) / (int64_t)g_182) && (((!((func_51(g_182) > (*l_180)) , g_184)) , l_180) != (*l_115)));
                    (*l_185) = ((*l_180) <= p_85);
                    (*l_185) = (p_82 , (__builtin_parity((*l_113)) > __builtin_popcount(l_187)));
                    (*l_181) = ((int32_t)(((uint16_t)(**l_115) + (uint16_t)(__builtin_popcount(g_184) ^ ((p_83 || (func_98((*g_169)) & __builtin_ffsll(p_83))) <= (p_85 <= 0x19L)))) | 0x44B6L) + (int32_t)0x4BA02FE3L);
                }
                else
                { /* block id: 76 */
                    int32_t **l_192 = (void*)0;
                    int32_t **l_193 = &l_113;
                    (*l_115) = l_180;
                    (*l_193) = l_181;
                    (**l_193) = (*l_181);
                    (*l_180) = ((**l_115) <= ((int8_t)g_182 * (int8_t)p_84));
                }
                (*l_115) = &g_114;
            }
            if ((g_3 > (65535UL == 65535UL)))
            { /* block id: 84 */
                return g_114;
            }
            else
            { /* block id: 86 */
                g_186 = 0xD.E21FBFp-68;
            }
        }
    }
    else
    { /* block id: 90 */
        int32_t *l_196 = &g_114;
        (*l_115) = ((&g_114 != (void*)0) , l_196);
        return (*l_196);
    }
    return g_182;
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes:
 */
static uint16_t  func_98(int32_t  p_99)
{ /* block id: 46 */
    int16_t l_102 = 0L;
    int32_t l_111 = 0xBFF020A7L;
    l_111 = ((int32_t)(__builtin_ia32_crc32qi(l_102, (1UL || (7L == ((int8_t)(((((uint16_t)(((uint64_t)18446744073709551609UL / (uint64_t)(255UL ^ p_99)) && ((uint8_t)l_102 % (uint8_t)0xA1L)) - (uint16_t)l_102) && 2L) , 0x47L) && p_99) / (int8_t)l_102)))) , p_99) / (int32_t)g_3);
    return p_99;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_114, "g_114", print_hash_value);
    transparent_crc(g_182, "g_182", print_hash_value);
    transparent_crc(g_184, "g_184", print_hash_value);
    transparent_crc_bytes (&g_186, sizeof(g_186), "g_186", print_hash_value);
    transparent_crc(g_205.f0, "g_205.f0", print_hash_value);
    transparent_crc(g_205.f1, "g_205.f1", print_hash_value);
    transparent_crc(g_205.f2, "g_205.f2", print_hash_value);
    transparent_crc(g_205.f3, "g_205.f3", print_hash_value);
    transparent_crc(g_205.f4, "g_205.f4", print_hash_value);
    transparent_crc(g_205.f5, "g_205.f5", print_hash_value);
    transparent_crc(g_205.f6, "g_205.f6", print_hash_value);
    transparent_crc(g_205.f7, "g_205.f7", print_hash_value);
    transparent_crc_bytes (&g_205.f8, sizeof(g_205.f8), "g_205.f8", print_hash_value);
    transparent_crc(g_205.f9, "g_205.f9", print_hash_value);
    transparent_crc(g_248.f0, "g_248.f0", print_hash_value);
    transparent_crc(g_248.f1, "g_248.f1", print_hash_value);
    transparent_crc(g_248.f2, "g_248.f2", print_hash_value);
    transparent_crc(g_248.f3, "g_248.f3", print_hash_value);
    transparent_crc(g_248.f4, "g_248.f4", print_hash_value);
    transparent_crc(g_248.f5, "g_248.f5", print_hash_value);
    transparent_crc(g_248.f6, "g_248.f6", print_hash_value);
    transparent_crc(g_248.f7, "g_248.f7", print_hash_value);
    transparent_crc_bytes (&g_248.f8, sizeof(g_248.f8), "g_248.f8", print_hash_value);
    transparent_crc(g_248.f9, "g_248.f9", print_hash_value);
    transparent_crc(g_257, "g_257", print_hash_value);
    transparent_crc(g_261.f0, "g_261.f0", print_hash_value);
    transparent_crc(g_261.f1, "g_261.f1", print_hash_value);
    transparent_crc(g_261.f2, "g_261.f2", print_hash_value);
    transparent_crc(g_261.f3, "g_261.f3", print_hash_value);
    transparent_crc(g_261.f4, "g_261.f4", print_hash_value);
    transparent_crc(g_261.f5, "g_261.f5", print_hash_value);
    transparent_crc(g_261.f6, "g_261.f6", print_hash_value);
    transparent_crc(g_261.f7, "g_261.f7", print_hash_value);
    transparent_crc_bytes (&g_261.f8, sizeof(g_261.f8), "g_261.f8", print_hash_value);
    transparent_crc(g_261.f9, "g_261.f9", print_hash_value);
    transparent_crc_bytes (&g_280, sizeof(g_280), "g_280", print_hash_value);
    transparent_crc(g_308.f0, "g_308.f0", print_hash_value);
    transparent_crc(g_308.f1, "g_308.f1", print_hash_value);
    transparent_crc(g_308.f2, "g_308.f2", print_hash_value);
    transparent_crc(g_308.f3, "g_308.f3", print_hash_value);
    transparent_crc(g_308.f4, "g_308.f4", print_hash_value);
    transparent_crc(g_308.f5, "g_308.f5", print_hash_value);
    transparent_crc(g_308.f6, "g_308.f6", print_hash_value);
    transparent_crc(g_308.f7, "g_308.f7", print_hash_value);
    transparent_crc_bytes (&g_308.f8, sizeof(g_308.f8), "g_308.f8", print_hash_value);
    transparent_crc(g_308.f9, "g_308.f9", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 98
   depth: 1, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 7
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 7

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 14
   depth: 3, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 68

XXX times a variable address is taken: 75
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 13
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 200

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 228
   level: 2, occurrence: 58
   level: 3, occurrence: 16
   level: 4, occurrence: 2
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 36
XXX number of pointers point to scalars: 28
XXX number of pointers point to structs: 4
XXX percent of pointers has null in alias set: 25
XXX average alias set size: 1.21

XXX times a non-volatile is read: 494
XXX times a non-volatile is write: 130
XXX times a volatile is read: 16
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 123
XXX percentage of non-volatile access: 97.3

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 119
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 25
   depth: 2, occurrence: 19
   depth: 3, occurrence: 16
   depth: 4, occurrence: 22
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

