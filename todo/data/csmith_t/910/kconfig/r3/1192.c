/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2279716704
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int8_t  f0;
   int16_t  f1;
   int16_t  f2;
   int32_t  f3;
   unsigned f4 : 13;
};

union U1 {
   int8_t * const  f0;
   int16_t  f1;
   uint16_t  f2;
   int16_t  f3;
};

union U2 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static const uint16_t  func_4(union U1  p_5, struct S0  p_6, int8_t * p_7);
static union U1  func_8(int8_t  p_9, const uint32_t  p_10, int32_t  p_11);
static uint8_t  func_24(int8_t * p_25);
inline static int32_t * func_28(const union U2 * p_29, int8_t * p_30, int32_t * p_31);
inline static int32_t * func_34(union U1  p_35);
static int32_t  func_39(union U2 * p_40, int8_t * p_41, int32_t  p_42, int8_t * p_43);
static int32_t  func_47(int8_t * p_48, int8_t * const  p_49, uint16_t  p_50);
static int8_t * func_53(int8_t  p_54, int8_t * p_55, union U2 * p_56, uint16_t  p_57, int8_t  p_58);
static union U2 * func_59(uint16_t  p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_12 = (-6);
    int8_t l_16 = (-9);
    int8_t *l_15 = &l_16;
    struct S0 l_22 = {-1,0x5452,0xA814,0x11F3813B,39};
    int32_t l_669 = 5;
    int32_t l_673 = (-2);
    uint32_t l_674 = 4294967289U;
    union U1 ***l_716 = (void*)0;
    union U2 l_736 = {0x1634};
    union U2 *l_735 = &l_736;
    struct S0 ***l_784 = (void*)0;
    int32_t l_787 = 4;
    uint32_t l_801 = 8U;
    int32_t *l_807 = &l_669;
    int32_t **l_806 = &l_807;
    int32_t ***l_805 = &l_806;
    uint8_t l_808 = 0x9F;
    int8_t l_842 = (-1);
    uint8_t l_843 = 0xD5;
    uint8_t l_845 = 0U;
    const int32_t l_857 = 4;
    int16_t l_886 = 0xA643;
    uint32_t l_904 = 4294967291U;
    int8_t l_929 = 1;
    uint32_t l_954 = 0U;
    union U2 **l_958 = &l_735;
    union U2 ***l_957 = &l_958;
    uint8_t l_985 = 0U;
    int32_t l_986 = 0xFD16EA50;
lbl_744:
    if ((safe_lshift_func_uint16_t_u_s(func_4(func_8(l_12, l_12, ((safe_div_func_uint16_t_u_u(((l_12 > (l_15 != &l_16)) & (safe_lshift_func_int8_t_s_s(l_16, 7))), l_12)) > l_12)), l_22, &l_16), l_22.f1)))
    { /* block id: 225 */
        int8_t l_632 = 0xD7;
        return l_632;
    }
    else
    { /* block id: 227 */
        int32_t l_637 = 0x95C481AC;
        struct S0 *l_644 = &l_22;
        struct S0 **l_643 = &l_644;
        struct S0 ***l_642 = &l_643;
        int32_t l_647 = (-1);
        union U2 l_652 = {0xD9A9};
        union U2 *l_651 = &l_652;
        int32_t *l_675 = &l_669;
        for (l_22.f1 = 3; (l_22.f1 > 29); l_22.f1 = safe_add_func_int32_t_s_s(l_22.f1, 1))
        { /* block id: 230 */
            int32_t l_639 = 0xA15B89DE;
            int32_t *l_638 = &l_639;
            union U2 **l_653 = &l_651;
            union U1 l_664 = {0};
            union U1 * const l_663 = &l_664;
            (*l_638) = (safe_sub_func_int32_t_s_s((-1), l_637));
            for (l_12 = (-29); (l_12 == (-30)); l_12--)
            { /* block id: 234 */
                l_642 = l_642;
                l_638 = (void*)0;
                /* statement id: 236 */
                assert (l_638 == 0);
                (**l_642) = &l_22;
            }
            /* facts after for loop */
            assert (l_638 == 0 || l_638 == &l_639);
            if (((safe_div_func_uint8_t_u_u(l_22.f4, l_647)) ^ l_637))
            { /* block id: 239 */
                uint32_t l_656 = 0x4E8433C7;
                int16_t l_659 = 0x804D;
                union U1 **l_665 = (void*)0;
                union U1 *l_667 = (void*)0;
                union U1 **l_666 = &l_667;
                if (l_22.f3)
                    break;
                if (((safe_rshift_func_int16_t_s_s(((l_637 ^ (!(l_651 != (void*)0))) == ((((0U <= (l_653 != (void*)0)) & (safe_sub_func_int16_t_s_s(l_656, (safe_lshift_func_int8_t_s_s(0x37, ((((l_656 > 0xC96B18DE) && l_22.f4) < l_637) ^ 0x0E0C)))))) > l_22.f2) < l_22.f3)), 13)) > 0x9A2B3576))
                { /* block id: 241 */
                    l_647 = l_12;
                }
                else
                { /* block id: 243 */
                    const union U2 *l_660 = &l_652;
                    if ((l_656 != l_12))
                    { /* block id: 244 */
                        return l_659;
                    }
                    else
                    { /* block id: 246 */
                        int8_t *l_661 = &l_16;
                        int32_t **l_662 = &l_638;
                        (*l_662) = func_28(l_660, l_661, &l_639);
                        /* statement id: 247 */
                        assert (l_638 == &l_639);
                    }
                    /* facts after branching */
                    assert (l_638 == &l_639);
                }
                (*l_666) = l_663;
                /* statement id: 250 */
                assert (l_664.f0 == 0);
                assert (l_667 == &l_664);
            }
            else
            { /* block id: 251 */
                int16_t l_668 = 0x4706;
                (*l_643) = (*l_643);
                l_669 = l_668;
            }
            /* facts after branching */
            assert (l_664.f0 == 0);
            return l_652.f0;
        }
        (*l_675) = (safe_sub_func_int32_t_s_s(9, ((~((l_637 | l_12) && l_652.f0)) < (l_22.f1 >= ((((l_652.f0 >= (l_673 >= ((((l_637 && 4294967290U) < 1U) > l_16) || 65535U))) > l_647) >= l_12) || l_674)))));
        (*l_675) = (l_22.f2 == 0xD7DF);
    }
    for (l_674 = (-30); (l_674 == 10); l_674 = safe_add_func_int16_t_s_s(l_674, 1))
    { /* block id: 262 */
        union U2 l_683 = {0x16A3};
        union U2 *l_682 = &l_683;
        union U2 **l_681 = &l_682;
        union U2 ***l_680 = &l_681;
        int8_t *l_684 = (void*)0;
        int32_t *l_685 = &l_673;
        int32_t **l_686 = &l_685;
        struct S0 *l_691 = (void*)0;
        union U1 l_755 = {0};
        union U1 *l_754 = &l_755;
        union U1 **l_753 = &l_754;
        union U1 ***l_752 = &l_753;
        uint8_t l_788 = 251U;
        uint32_t l_924 = 0xE043C6F0;
        int32_t l_942 = 0x6F036CAF;
        uint16_t l_951 = 0xE04C;
        (*l_686) = func_28(func_59((safe_rshift_func_uint16_t_u_u(((void*)0 == l_680), (&l_16 != &l_16)))), l_684, l_685);
        if ((safe_lshift_func_uint16_t_u_u((l_22.f4 == (safe_mod_func_uint32_t_u_u((l_691 == &l_22), (safe_rshift_func_uint16_t_u_u(l_673, (0U && (safe_lshift_func_int16_t_s_s(0x829B, (safe_sub_func_uint32_t_u_u((((0U >= 0U) | 4294967295U) || l_12), 0x71FAD2DB)))))))))), 1)))
        { /* block id: 264 */
            uint8_t l_712 = 0xDA;
            union U1 l_720 = {0};
            union U1 *l_719 = &l_720;
            union U1 **l_718 = &l_719;
            union U1 ***l_717 = &l_718;
            union U2 ****l_740 = &l_680;
            int32_t ***l_776 = (void*)0;
            int32_t ****l_775 = &l_776;
            struct S0 *l_790 = &l_22;
            uint32_t l_846 = 0x87B434D9;
            int16_t l_847 = 5;
            (**l_686) = 0x5A978901;
            for (l_22.f1 = 0; (l_22.f1 != (-7)); l_22.f1--)
            { /* block id: 268 */
                int16_t l_704 = (-9);
                union U2 **l_709 = &l_682;
                int8_t *l_729 = &l_16;
                int32_t *l_738 = &l_673;
                union U2 ****l_739 = &l_680;
                struct S0 *l_800 = &l_22;
                for (l_673 = 0; (l_673 > (-29)); l_673 = safe_sub_func_uint8_t_u_u(l_673, 3))
                { /* block id: 271 */
                    int32_t **l_706 = (void*)0;
                    for (l_12 = (-10); (l_12 != (-25)); l_12 = safe_sub_func_uint16_t_u_u(l_12, 3))
                    { /* block id: 274 */
                        int32_t *l_705 = &l_669;
                        int32_t ***l_707 = (void*)0;
                        int32_t ***l_708 = &l_686;
                        l_704 = (*l_685);
                        (*l_705) = 0;
                        (*l_708) = l_706;
                        /* statement id: 277 */
                        assert (l_686 == 0);
                    }
                }
                if (((((((*l_680) != l_709) >= ((safe_rshift_func_int16_t_s_s((l_712 & (safe_add_func_int16_t_s_s((safe_unary_minus_func_uint16_t_u((l_716 == l_717))), ((*l_685) > (safe_div_func_uint16_t_u_u(65535U, (-3))))))), 4)) && (safe_div_func_int32_t_s_s(((0x7F & 0x16) >= l_704), 0xCCCBD2EC)))) & 0x486B) != l_22.f0) != l_22.f1))
                { /* block id: 280 */
                    int32_t l_737 = 0xC633036B;
                    int32_t **l_741 = &l_685;
                    for (l_16 = 14; (l_16 > (-21)); l_16 = safe_sub_func_uint8_t_u_u(l_16, 1))
                    { /* block id: 283 */
                        const union U2 *l_727 = &l_683;
                        int32_t l_728 = (-1);
                        union U2 *l_730 = (void*)0;
                        l_738 = func_28(l_727, l_729, &l_673);
                        l_728 = (l_728 <= (l_739 == l_740));
                        if ((*l_738))
                            continue;
                        return l_728;
                    }
                    (*l_741) = &l_669;
                    /* statement id: 289 */
                    assert (l_685 == &l_669);
                    return l_712;
                }
                else
                { /* block id: 291 */
                    struct S0 * const *l_746 = (void*)0;
                    struct S0 * const **l_745 = &l_746;
                    int32_t l_749 = 0xAFD59670;
                    const int32_t *l_765 = &l_673;
                    const int32_t **l_764 = &l_765;
                    const int32_t ***l_763 = &l_764;
                    for (l_704 = 28; (l_704 <= 2); l_704 = safe_sub_func_int16_t_s_s(l_704, 8))
                    { /* block id: 294 */
                        if (l_673)
                            goto lbl_744;
                    }
                    (*l_745) = &l_691;
                    /* statement id: 297 */
                    assert (l_746 == &l_691);
                    for (l_669 = 0; (l_669 == (-14)); l_669 = safe_sub_func_uint8_t_u_u(l_669, 2))
                    { /* block id: 300 */
                        const uint32_t l_760 = 0xD1BD7756;
                        int32_t **l_761 = (void*)0;
                        int32_t **l_762 = &l_738;
                        int32_t ***l_767 = (void*)0;
                        int32_t ****l_766 = &l_767;
                        l_673 = (l_749 & ((l_22.f2 > (safe_rshift_func_uint8_t_u_s(l_712, (((void*)0 == l_752) <= (((safe_rshift_func_uint8_t_u_u((0xE941 <= 0), 7)) && (safe_sub_func_int32_t_s_s(((0U && l_749) || l_22.f1), 4294967290U))) > l_760))))) <= 0U));
                        (*l_762) = func_34((***l_717));
                        /* statement id: 302 */
                        assert (l_738 == 0);
                        (*l_766) = l_763;
                        /* statement id: 303 */
                        assert (l_767 == &l_764);
                        (***l_767) = ((***l_763) && ((-7) == (0xF109 && ((****l_766) <= l_22.f1))));
                    }
                    /* facts after for loop */
                    assert (l_738 == 0 || l_738 == &l_673);
                    assert (l_755.f0 == 0);
                    (*l_685) = (safe_add_func_uint16_t_u_u(0xEDAC, l_712));
                }
                /* facts after branching */
                assert (l_738 == 0 || l_738 == &l_673);
                if (((safe_add_func_uint16_t_u_u(65532U, l_712)) < (((safe_unary_minus_func_int8_t_s(((((safe_lshift_func_int16_t_s_u((((void*)0 != l_775) == (safe_add_func_int32_t_s_s((*l_685), (l_12 || (safe_sub_func_int16_t_s_s(((safe_add_func_int8_t_s_s((!((void*)0 != l_784)), ((safe_div_func_int8_t_s_s((l_704 | (*l_685)), l_673)) != l_22.f4))) > l_22.f0), l_787)))))), l_704)) < l_788) && 0x74C4260F) >= l_674))) <= 0xA81A) != (*l_685))))
                { /* block id: 308 */
                    int32_t **l_789 = &l_738;
                    struct S0 l_792 = {0xBF,0x84A2,-4,0x518D10BD,25};
                    struct S0 *l_791 = &l_792;
                    int8_t *l_804 = (void*)0;
                    (*l_789) = l_738;
                    l_791 = l_790;
                    /* statement id: 310 */
                    assert (l_791 == &l_22);
                    (*l_685) = ((safe_rshift_func_uint16_t_u_s((safe_rshift_func_int16_t_s_u(((~(safe_mod_func_uint8_t_u_u(((l_800 == (void*)0) >= (((((((void*)0 == (*l_789)) == 1) | l_801) && l_12) > (safe_add_func_int32_t_s_s(l_704, (l_804 == (void*)0)))) == (*l_685))), l_792.f3))) == 0x0B0D003D), l_669)), l_792.f4)) != l_669);
                }
                else
                { /* block id: 312 */
                    int8_t l_840 = 0;
                    const int32_t **** const l_841 = (void*)0;
                    int8_t l_844 = 7;
                    (*l_685) = ((((void*)0 == l_805) ^ l_808) & (safe_div_func_uint8_t_u_u(((safe_mod_func_uint8_t_u_u((((((safe_mod_func_uint16_t_u_u(((safe_mod_func_int32_t_s_s(((safe_mod_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((safe_div_func_uint32_t_u_u((((safe_div_func_int8_t_s_s((safe_sub_func_uint8_t_u_u((1 != (safe_sub_func_int16_t_s_s((*l_685), (safe_sub_func_uint8_t_u_u((safe_rshift_func_uint8_t_u_s((0x3398 < (~(safe_rshift_func_uint16_t_u_s(((safe_mod_func_int16_t_s_s((((safe_rshift_func_int8_t_s_u((l_840 > (l_841 == &l_805)), (*l_685))) == 0U) || (*l_685)), 0x82CC)) <= l_704), (***l_805))))), (*l_685))), (*l_685)))))), l_840)), 0x21)) != l_842) <= (***l_805)), 0xA5E4E82A)), l_843)), l_704)) || (*l_685)), 6U)) <= l_704), l_844)) == l_845) >= l_846) || (*l_807)) | 0x60AD7329), (*l_807))) || (*l_685)), 0x4A)));
                    return l_847;
                }
            }
            /* facts after for loop */
            assert (l_686 == 0 || l_686 == &l_685);
            assert (l_720.f0 == 0);
            assert (l_755.f0 == 0);
        }
        else
        { /* block id: 317 */
            uint16_t l_852 = 65534U;
            union U1 *l_866 = (void*)0;
            int32_t l_910 = 0;
            int32_t * const *l_914 = &l_807;
            int32_t * const **l_913 = &l_914;
            int32_t * const ***l_912 = &l_913;
            union U1 l_917 = {0};
            int8_t l_953 = 0x3F;
            int8_t l_984 = 6;
            if ((*l_685))
                break;
            for (l_683.f0 = 15; (l_683.f0 == 16); l_683.f0 = safe_add_func_int32_t_s_s(l_683.f0, 3))
            { /* block id: 321 */
                uint16_t l_864 = 0x3B09;
                int32_t l_887 = 0x0458D6C7;
                const struct S0 *l_888 = (void*)0;
                const union U1 *l_894 = &l_755;
                const union U1 **l_893 = &l_894;
                const union U1 ** const *l_892 = &l_893;
                const union U1 ** const **l_891 = &l_892;
                if ((safe_lshift_func_int8_t_s_s((l_852 || ((l_852 & ((safe_rshift_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(l_857, 2)), 1)) || (*l_685))) || (safe_add_func_int8_t_s_s(((safe_unary_minus_func_uint16_t_u((((!(**l_806)) || 0xABB4) < (***l_805)))) & (safe_sub_func_uint8_t_u_u((0x2D5EF3C3 <= (l_864 & (***l_805))), (***l_805)))), (-10))))), 2)))
                { /* block id: 322 */
                    union U1 *l_865 = &l_755;
                    if ((&l_805 != (void*)0))
                    { /* block id: 323 */
                        if (l_22.f0)
                            goto lbl_744;
                        (**l_806) = ((-1) > ((l_865 != l_866) != (*l_807)));
                        if (l_852)
                            break;
                    }
                    else
                    { /* block id: 327 */
                        int32_t ***l_867 = &l_686;
                        if ((*l_685))
                            break;
                        (***l_805) = ((l_864 || ((void*)0 != l_867)) || 0x160F2FE7);
                    }
                }
                else
                { /* block id: 331 */
                    int32_t l_872 = 0xFEF6223D;
                    (*l_685) = l_852;
                    for (l_673 = 14; (l_673 == 2); l_673 = safe_sub_func_int8_t_s_s(l_673, 9))
                    { /* block id: 335 */
                        uint16_t l_873 = 0x26F6;
                        struct S0 l_890 = {0x7C,1,1,0x2E5936F5,84};
                        const struct S0 *l_889 = &l_890;
                        union U1 ****l_896 = &l_752;
                        union U1 *****l_895 = &l_896;
                        l_887 = (safe_add_func_int32_t_s_s(((l_872 ^ (l_873 <= ((0x1CD3 && 0x5E15) == (safe_add_func_int16_t_s_s(((*l_686) != (*l_686)), (safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u((safe_mod_func_uint32_t_u_u(((safe_sub_func_int16_t_s_s((safe_unary_minus_func_int16_t_s(((0 ^ (safe_unary_minus_func_int8_t_s((1 ^ 3U)))) < l_864))), l_872)) ^ (*l_685)), (***l_805))), l_886)), 0xF6E8088D))))))) != l_864), (***l_805)));
                        l_889 = l_888;
                        /* statement id: 337 */
                        assert (l_889 == 0);
                        (*l_895) = l_891;
                        /* statement id: 338 */
                        assert (l_896 == &l_892);
                        if (l_872)
                            continue;
                    }
                }
            }
            for (l_788 = 28; (l_788 > 14); l_788 = safe_sub_func_int8_t_s_s(l_788, 1))
            { /* block id: 345 */
                int32_t l_901 = 1;
                int32_t **** const l_916 = &l_805;
                int32_t **** const *l_915 = &l_916;
                int32_t l_952 = 0x7FD85FB8;
                union U1 *** const l_978 = &l_753;
                int32_t l_983 = 0;
                for (l_16 = 0; (l_16 > 8); ++l_16)
                { /* block id: 348 */
                    const int32_t l_911 = 0xD81C3C37;
                    int32_t l_930 = 0xE99619C7;
                    int16_t l_935 = 0xC121;
                    union U1 *l_981 = &l_755;
                    int16_t l_982 = (-3);
                    if (l_901)
                        break;
                }
                /* facts after for loop */
                assert (l_917.f0 == 0);
            }
            /* facts after for loop */
            assert (l_917.f0 == 0);
            return l_985;
        }
        /* facts after branching */
        assert (l_686 == 0 || l_686 == &l_685);
        assert (l_755.f0 == 0);
        (*l_806) = func_28(func_59((***l_805)), l_684, (**l_805));
    }
    if (l_22.f1)
        goto lbl_744;
    return l_986;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_4(union U1  p_5, struct S0  p_6, int8_t * p_7)
{ /* block id: 4 */
    uint32_t l_23 = 1U;
    int8_t l_27 = 0xAF;
    int8_t *l_26 = &l_27;
    int32_t *l_626 = (void*)0;
    int32_t *l_627 = (void*)0;
    int32_t l_628 = (-1);
    int32_t **l_629 = &l_627;
    union U2 l_631 = {0x1705};
    const union U2 *l_630 = &l_631;
    l_628 = (l_23 || func_24(l_26));
    (*l_629) = (void*)0;
    (*l_629) = func_28(l_630, &l_27, (*l_629));
    return p_6.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_8(int8_t  p_9, const uint32_t  p_10, int32_t  p_11)
{ /* block id: 1 */
    union U2 l_20 = {0xDDAE};
    union U2 *l_19 = &l_20;
    union U1 l_21 = {0};
    l_19 = (void*)0;
    /* statement id: 2 */
    assert (l_19 == 0);
    return l_21;
    /* statement id: 3 */
    //assert (func_8_rv.f0 == 0);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_24(int8_t * p_25)
{ /* block id: 5 */
    union U2 l_33 = {0U};
    const union U2 *l_32 = &l_33;
    union U1 l_36 = {0};
    int32_t l_620 = 1;
    int32_t *l_619 = &l_620;
    int32_t **l_618 = &l_619;
    (*l_618) = func_28(l_32, p_25, func_34(l_36));
    /* statement id: 214 */
    assert (l_36.f0 == 0);
    assert (l_619 == 0);
    for (l_620 = 0; (l_620 != (-17)); l_620 = safe_sub_func_uint32_t_u_u(l_620, 1))
    { /* block id: 217 */
        int8_t l_623 = 0xA0;
        int32_t l_625 = 0x264594DE;
        int32_t *l_624 = &l_625;
        (*l_624) = l_623;
    }
    return l_33.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_28(const union U2 * p_29, int8_t * p_30, int32_t * p_31)
{ /* block id: 212 */
    int32_t l_617 = (-3);
    int32_t *l_616 = &l_617;
    return p_31;
    /* statement id: 213 */
    //assert (func_28_rv == 0 || func_28_rv == &l_639 || func_28_rv == &l_673 || func_28_rv == &l_669);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_34(union U1  p_35)
{ /* block id: 6 */
    union U2 *l_44 = (void*)0;
    int8_t l_46 = 0xDC;
    int8_t *l_45 = &l_46;
    int32_t *l_583 = (void*)0;
    int32_t l_585 = (-1);
    int32_t *l_584 = &l_585;
    uint32_t l_590 = 4294967295U;
    uint32_t l_595 = 0x0BF71D97;
    int32_t **l_596 = &l_584;
    int32_t l_597 = 0xCFD4E2F4;
    int32_t *l_599 = (void*)0;
    int32_t *l_609 = &l_585;
    int32_t *l_610 = &l_585;
    int32_t *l_611 = &l_585;
    int32_t *l_612 = &l_585;
    int32_t *l_613 = &l_585;
    int32_t *l_614 = &l_585;
    int32_t *l_615 = (void*)0;
    (*l_584) = (safe_sub_func_int32_t_s_s(func_39(l_44, l_45, l_46, &l_46), (safe_sub_func_int32_t_s_s(l_46, ((void*)0 == &l_46)))));
    (*l_584) = (((*l_584) >= ((*l_584) < ((safe_sub_func_uint32_t_u_u((0 >= ((safe_sub_func_int32_t_s_s(0x8FBDD4F9, l_590)) | (((*l_584) != ((safe_add_func_int8_t_s_s(((safe_sub_func_uint16_t_u_u((*l_584), (*l_584))) && (*l_584)), (-1))) <= l_595)) ^ (*l_584)))), (*l_584))) <= 0xFF))) || 0xA5);
    (*l_596) = (void*)0;
    /* statement id: 205 */
    assert (l_584 == 0);
    if (l_597)
    { /* block id: 206 */
        int32_t *l_598 = &l_585;
        return l_599;
        /* statement id: 207 */
        //assert (func_34_rv == 0);
    }
    else
    { /* block id: 208 */
        int16_t l_604 = 0x8263;
        struct S0 l_607 = {-8,0x95F5,-7,-3,56};
        struct S0 *l_606 = &l_607;
        struct S0 **l_605 = &l_606;
        int32_t l_608 = 1;
        l_608 = ((safe_sub_func_int16_t_s_s(0xE2FD, ((safe_lshift_func_int8_t_s_u((-4), 4)) < l_604))) <= (l_605 != &l_606));
    }
    return l_615;
    /* statement id: 211 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_39(union U2 * p_40, int8_t * p_41, int32_t  p_42, int8_t * p_43)
{ /* block id: 7 */
    int8_t l_52 = 0;
    int8_t *l_51 = &l_52;
    int32_t l_62 = 4;
    int32_t *l_61 = &l_62;
    union U2 l_68 = {65535U};
    union U2 *l_67 = &l_68;
    union U2 **l_570 = &l_67;
    union U2 ***l_569 = &l_570;
    (*l_61) = func_47(l_51, func_53(l_52, &l_52, func_59((((((void*)0 == p_40) == (p_42 > (l_61 == &l_62))) | (safe_lshift_func_uint16_t_u_s((safe_mod_func_uint8_t_u_u((l_67 != p_40), 255U)), 8))) >= p_42)), p_42, (*l_61)), p_42);
    (*l_569) = (void*)0;
    /* statement id: 200 */
    assert (l_570 == 0);
    (*l_61) = ((*p_43) == (safe_sub_func_uint16_t_u_u((247U || 0x9C), (safe_mod_func_int16_t_s_s((((-1) && (*l_61)) || ((safe_sub_func_uint8_t_u_u(((p_42 == p_42) || ((safe_div_func_uint8_t_u_u(((*l_61) >= ((safe_sub_func_uint32_t_u_u((*l_61), (*l_61))) && p_42)), (*l_61))) >= (*l_61))), (*l_61))) > (*l_61))), (-9))))));
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_47(int8_t * p_48, int8_t * const  p_49, uint16_t  p_50)
{ /* block id: 110 */
    int32_t l_322 = 0xE7CB9A90;
    int32_t *l_328 = &l_322;
    int32_t **l_327 = &l_328;
    int32_t ***l_326 = &l_327;
    int32_t ****l_325 = &l_326;
    int32_t *****l_324 = &l_325;
    union U2 l_333 = {0U};
    union U2 *l_332 = &l_333;
    union U2 **l_331 = &l_332;
    union U2 ***l_330 = &l_331;
    union U2 ****l_329 = &l_330;
    union U1 l_346 = {0};
    union U1 *l_345 = &l_346;
    union U1 * const * const l_344 = &l_345;
    uint32_t l_425 = 0x93B77E51;
    int32_t l_431 = (-1);
    int16_t l_466 = (-7);
    int8_t l_487 = (-1);
    const struct S0 *l_528 = (void*)0;
    const struct S0 **l_527 = &l_528;
    uint16_t l_558 = 1U;
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t * func_53(int8_t  p_54, int8_t * p_55, union U2 * p_56, uint16_t  p_57, int8_t  p_58)
{ /* block id: 106 */
    int16_t l_307 = 0x6DE4;
    int32_t l_308 = 0x029318B5;
    int32_t *l_311 = &l_308;
    int8_t l_313 = 0;
    int8_t *l_312 = &l_313;
    int8_t *l_314 = (void*)0;
    l_308 = ((((*p_55) & 0x00) && l_307) && l_307);
    (*l_311) = (safe_lshift_func_int16_t_s_u(l_308, 14));
    return l_314;
    /* statement id: 109 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_59(uint16_t  p_60)
{ /* block id: 8 */
    uint32_t l_87 = 6U;
    union U2 l_91 = {0U};
    union U2 *l_90 = &l_91;
    int32_t l_139 = (-2);
    int32_t *l_138 = &l_139;
    int32_t **l_137 = &l_138;
    int32_t ***l_136 = &l_137;
    struct S0 l_144 = {0x2F,2,0,8,47};
    struct S0 *l_143 = &l_144;
    union U1 l_252 = {0};
    const union U1 *l_251 = &l_252;
    union U2 *l_301 = &l_91;
    union U2 *l_302 = &l_91;
    union U2 *l_303 = &l_91;
    union U2 *l_304 = &l_91;
    union U2 *l_305 = &l_91;
    union U2 *l_306 = (void*)0;
    for (p_60 = (-14); (p_60 < 10); ++p_60)
    { /* block id: 11 */
        int16_t l_71 = (-1);
        union U2 l_76 = {0U};
        union U2 *l_75 = &l_76;
        int32_t l_94 = 0xD5949333;
        int32_t *l_96 = &l_94;
        struct S0 * const l_99 = (void*)0;
        int32_t * const **l_242 = (void*)0;
        int32_t * const ***l_241 = &l_242;
        int32_t * const ****l_240 = &l_241;
        union U1 *l_287 = &l_252;
        union U2 ** const * const l_290 = (void*)0;
        union U2 * const *l_293 = &l_75;
        union U2 * const **l_292 = &l_293;
        union U2 * const ***l_291 = &l_292;
    }
    /* facts after for loop */
    assert (l_252.f0 == 0);
    (**l_137) = p_60;
    (*l_137) = (**l_136);
    return l_306;
    /* statement id: 105 */
    //assert (func_59_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 242
   depth: 1, occurrence: 1
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 10
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 5

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 108
   depth: 2, occurrence: 22
   depth: 3, occurrence: 3
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 254

XXX times a variable address is taken: 231
XXX times a pointer is dereferenced on RHS: 179
breakdown:
   depth: 1, occurrence: 108
   depth: 2, occurrence: 24
   depth: 3, occurrence: 30
   depth: 4, occurrence: 9
   depth: 5, occurrence: 8
XXX times a pointer is dereferenced on LHS: 98
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 14
   depth: 3, occurrence: 8
   depth: 4, occurrence: 7
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 44
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 21
XXX times a pointer is qualified to be dereferenced: 668

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 202
   level: 2, occurrence: 68
   level: 3, occurrence: 64
   level: 4, occurrence: 47
   level: 5, occurrence: 23
XXX number of pointers point to pointers: 113
XXX number of pointers point to scalars: 76
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 30.7
XXX average alias set size: 1.13

XXX times a non-volatile is read: 1114
XXX times a non-volatile is write: 306
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 106
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 10
   depth: 2, occurrence: 10
   depth: 3, occurrence: 13
   depth: 4, occurrence: 19
   depth: 5, occurrence: 23

XXX percentage a fresh-made variable is used: 18.9
XXX percentage an existing variable is used: 81.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

