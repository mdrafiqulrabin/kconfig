/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2949570800
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static const uint16_t  func_7(int16_t  p_8);
static uint16_t  func_17(int32_t  p_18, uint32_t  p_19, const int16_t  p_20, int32_t  p_21, uint32_t  p_22);
static int16_t  func_24(int16_t  p_25, uint16_t  p_26, int32_t  p_27, int16_t  p_28);
static int32_t * func_39(int32_t * p_40, int32_t  p_41, int32_t * p_42, uint32_t  p_43, int32_t * p_44);
static uint16_t  func_48(int32_t * p_49, int32_t * p_50, int32_t * p_51, uint16_t  p_52);
static int32_t * func_54(int32_t  p_55, const int32_t * p_56, uint32_t  p_57, const int32_t  p_58);
static const int32_t * func_60(const uint16_t  p_61);
static const int32_t  func_67(int16_t  p_68);
static uint32_t  func_73(int32_t * p_74, int32_t * p_75, int32_t  p_76, int16_t  p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    const uint16_t l_4 = 2U;
    uint32_t l_36 = 9U;
    int32_t l_353 = 1;
    l_353 = (((int16_t)(l_4 && (((uint16_t)func_7((0xE08C >= (((int16_t)((((uint16_t)0xC902 >> (uint16_t)10) < (l_4 || ((uint16_t)((((uint16_t)func_17(l_4, l_4, (~func_24((l_4 | ((l_4 <= (((uint16_t)l_4 << (uint16_t)l_4) ^ 0xF8E3)) & 0x18C84B7B)), l_4, l_4, l_4)), l_4, l_36) << (uint16_t)13) , l_36) , 1U) % (uint16_t)l_36))) && l_36) << (int16_t)l_4) , l_36))) + (uint16_t)l_4) | l_36)) % (int16_t)l_4) >= l_4);
    return l_4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_7(int16_t  p_8)
{ /* block id: 138 */
    int32_t l_341 = 0;
    int32_t *l_340 = &l_341;
    int32_t **l_339 = &l_340;
    for (p_8 = 0; (p_8 <= (-9)); p_8 -= 1)
    { /* block id: 141 */
        int32_t *l_329 = (void*)0;
        int32_t l_331 = 0x6CF623B8;
        int32_t *l_330 = &l_331;
        int32_t **l_332 = &l_330;
        (*l_330) = 5;
        (*l_332) = &l_331;
    }
    for (p_8 = 0; (p_8 <= (-12)); p_8 -= 9)
    { /* block id: 147 */
        int32_t *l_336 = (void*)0;
        int32_t **l_335 = &l_336;
        int32_t l_350 = 0x2CBFD598;
    }
    return p_8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_17(int32_t  p_18, uint32_t  p_19, const int16_t  p_20, int32_t  p_21, uint32_t  p_22)
{ /* block id: 4 */
    int16_t l_37 = 0x5BF7;
    uint32_t l_38 = 0U;
    int32_t *l_45 = (void*)0;
    uint16_t l_59 = 65528U;
    int32_t **l_312 = &l_45;
    int32_t ***l_311 = &l_312;
    int32_t ****l_310 = &l_311;
    int32_t **l_317 = &l_45;
    uint32_t l_318 = 0xEDEECB3B;
    uint32_t l_325 = 4294967288U;
    int16_t l_326 = 0x8BEF;
    if ((func_24(l_37, l_38, p_22, l_38) , (l_38 ^ 4294967295U)))
    { /* block id: 5 */
        uint32_t l_53 = 1U;
        int32_t **l_299 = &l_45;
        uint32_t l_300 = 4294967295U;
        int32_t *l_301 = (void*)0;
        int32_t l_303 = 0;
        int32_t *l_302 = &l_303;
        (*l_299) = func_39(l_45, (-(uint32_t)((-(int16_t)((func_48((l_53 , (p_21 , func_54(l_59, func_60(p_18), p_22, p_18))), l_45, l_45, p_22) && 9) == 0xB442EEB0)) && l_53)), l_45, p_20, l_45);
        (*l_302) = l_300;
        for (p_21 = 17; (p_21 <= 4); p_21 -= 1)
        { /* block id: 127 */
            int32_t ***l_309 = (void*)0;
            int32_t ****l_308 = &l_309;
            int32_t l_316 = 1;
            (*l_302) = ((uint16_t)((l_308 != (((l_310 != &l_309) && (((p_20 | (0U >= (*l_302))) <= (p_18 == (~p_18))) , ((p_18 | l_316) ^ p_22))) , &l_311)) , 0U) + (uint16_t)p_21);
        }
        (*l_311) = (p_18 , (void*)0);
    }
    else
    { /* block id: 131 */
        (**l_311) = (**l_311);
    }
    (*l_317) = ((p_19 | 0x577DD6AF) , ((p_22 | 8U) , l_45));
    (*l_317) = (*l_317);
    l_326 = ((((3U || ((l_318 , &l_310) == ((((uint16_t)(0 > (&l_311 != &l_311)) - (uint16_t)0U) != ((((int16_t)(((((((((uint16_t)((p_20 , 0x651242CB) && p_21) >> (uint16_t)6) | 0x68DE) & p_22) != p_18) , (*l_317)) != (void*)0) >= l_325) <= (-1)) << (int16_t)p_19) >= p_21) & p_18)) , &l_310))) != p_21) , (*l_317)) != (*l_317));
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_24(int16_t  p_25, uint16_t  p_26, int32_t  p_27, int16_t  p_28)
{ /* block id: 1 */
    int32_t l_35 = 0x9628EAF6;
    int32_t *l_34 = &l_35;
    (*l_34) = ((int16_t)(!p_28) >> (int16_t)p_28);
    return p_25;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_39(int32_t * p_40, int32_t  p_41, int32_t * p_42, uint32_t  p_43, int32_t * p_44)
{ /* block id: 120 */
    const int32_t l_295 = 0xED91531C;
    const int32_t * const l_294 = &l_295;
    int32_t l_298 = 1;
    int32_t *l_297 = &l_298;
    int32_t **l_296 = &l_297;
    (*l_296) = l_294;
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(int32_t * p_49, int32_t * p_50, int32_t * p_51, uint16_t  p_52)
{ /* block id: 103 */
    int32_t l_249 = 2;
    int32_t *l_266 = (void*)0;
    int32_t **l_265 = &l_266;
    int32_t ***l_264 = &l_265;
    int32_t ****l_263 = &l_264;
    int16_t l_275 = 0xD20D;
    uint16_t l_289 = 65531U;
    int32_t l_290 = 0;
    int32_t *l_293 = &l_290;
    for (p_52 = (-24); (p_52 <= 2); p_52 += 1)
    { /* block id: 106 */
        int32_t l_262 = 0;
        uint32_t l_267 = 1U;
        const int32_t l_268 = 0x5B1F0BCF;
        l_267 = (l_249 || (0xD7F8 == ((uint16_t)(((int32_t)(~((((uint32_t)(-(uint32_t)(p_52 ^ (p_52 != 0x24FA))) % (uint32_t)((int16_t)(l_262 | p_52) + (int16_t)p_52)) , l_263) == &l_264)) - (int32_t)0xE27A70E2) > 65535U) >> (uint16_t)15)));
        (***l_263) = func_54(l_267, (**l_264), l_262, l_268);
    }
    if ((0xD12E > (((p_52 , p_52) == (((int16_t)(l_249 & (((((int16_t)p_52 % (int16_t)65535U) , (((-1) || ((0x2AC9 != (&l_264 != (void*)0)) == l_249)) == l_275)) , l_275) ^ p_52)) - (int16_t)p_52) == p_52)) && 1U)))
    { /* block id: 110 */
        return p_52;
    }
    else
    { /* block id: 112 */
        int32_t l_276 = 2;
        int32_t ****l_286 = &l_264;
        int32_t *l_291 = (void*)0;
        int32_t *l_292 = &l_290;
        (*l_265) = p_50;
        l_290 = ((1U ^ ((p_52 < (((((l_276 != (((((uint16_t)(~l_276) - (uint16_t)((uint16_t)(((l_276 == ((int16_t)((int32_t)((((l_286 != (((int16_t)0xDD1E - (int16_t)((((void*)0 != &l_263) , p_52) < 0x4E311F92)) , (void*)0)) | p_52) ^ 1) & l_289) % (int32_t)p_52) - (int16_t)p_52)) <= 0x6015) , l_276) - (uint16_t)p_52)) , (void*)0) != &l_286) <= p_52)) == l_276) < p_52) <= p_52) < 65535U)) & p_52)) || p_52);
        (*l_264) = &p_50;
        (*l_292) = (l_276 < p_52);
    }
    (*l_293) = 0xAAF09B1D;
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_54(int32_t  p_55, const int32_t * p_56, uint32_t  p_57, const int32_t  p_58)
{ /* block id: 78 */
    const int32_t ****l_184 = (void*)0;
    int32_t *****l_185 = (void*)0;
    int32_t *****l_186 = (void*)0;
    int32_t l_243 = (-1);
    int32_t *l_242 = &l_243;
    int32_t *l_244 = (void*)0;
    l_184 = l_184;
    for (p_57 = (-14); (p_57 > 26); p_57 += 1)
    { /* block id: 82 */
        int16_t l_191 = 3;
        const int32_t *****l_207 = &l_184;
        uint32_t l_208 = 0xCBEDFB48;
        int16_t l_209 = 0x943B;
        int32_t **l_225 = (void*)0;
        int32_t ***l_224 = &l_225;
        if (((((int16_t)((((((l_191 == p_58) >= l_191) ^ (((uint32_t)(&l_184 != (void*)0) % (uint32_t)((uint16_t)(((int16_t)((int16_t)(!((-10) ^ (((int16_t)((int32_t)((uint16_t)((void*)0 != l_207) >> (uint16_t)0) - (int32_t)l_208) + (int16_t)p_57) , p_58))) % (int16_t)0xDEAC) - (int16_t)0U) || p_55) + (uint16_t)p_57)) & l_209)) <= p_57) ^ 65531U) ^ 0x9FE6) << (int16_t)0) & 0x7779B4FE) | p_55))
        { /* block id: 83 */
            int32_t l_215 = 0xFBDC1381;
            int32_t *l_214 = &l_215;
            int32_t * const *l_213 = &l_214;
            int32_t * const **l_212 = &l_213;
            int32_t ****l_226 = &l_224;
            (***l_212) = ((((int16_t)((void*)0 != l_212) + (int16_t)((uint16_t)(((((**l_213) || ((p_57 == ((~p_58) != ((-(int32_t)(((int16_t)(0x7537 >= 0x9033) >> (int16_t)((p_58 == p_58) == p_55)) || p_57)) , p_57))) == p_55)) || 0x67C41F25) || (***l_212)) || 0U) << (uint16_t)p_57)) == p_55) == p_55);
            p_56 = &p_55;
            (*l_226) = l_224;
            (*l_214) = (***l_212);
        }
        else
        { /* block id: 88 */
            p_55 = 0xF115A300;
            for (p_55 = 2; (p_55 > 13); p_55 += 1)
            { /* block id: 92 */
                int32_t l_231 = 0xB64E5738;
                const int32_t *l_230 = &l_231;
                const int32_t **l_229 = &l_230;
                (*l_229) = &p_55;
            }
        }
    }
    for (p_55 = 0; (p_55 <= 1); p_55 += 5)
    { /* block id: 99 */
        int32_t l_238 = 9;
        int32_t *l_237 = &l_238;
        int32_t **l_236 = &l_237;
        int32_t ***l_235 = &l_236;
        int32_t ****l_234 = &l_235;
        int32_t *****l_239 = (void*)0;
        int32_t *****l_240 = (void*)0;
        int32_t *****l_241 = &l_234;
        (*l_241) = l_234;
    }
    return l_244;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_60(const uint16_t  p_61)
{ /* block id: 6 */
    int32_t l_64 = 1;
    int32_t *l_78 = &l_64;
    int32_t *l_79 = &l_64;
    uint16_t l_80 = 0xE0E2;
    int32_t **l_136 = &l_78;
    int32_t *** const l_135 = &l_136;
    int32_t l_154 = 0xA42F3C5D;
    const int32_t *l_183 = (void*)0;
    (*l_78) = ((uint32_t)(l_64 , (((uint16_t)((func_67((((uint16_t)((uint32_t)4294967295U - (uint32_t)func_73(l_78, l_79, l_80, (*l_78))) - (uint16_t)(0x7496 == (((int32_t)(l_135 == &l_136) + (int32_t)p_61) <= p_61))) ^ (-1))) , p_61) && (***l_135)) % (uint16_t)p_61) < l_154)) % (uint32_t)p_61);
    (*l_136) = (*l_136);
    if (((uint16_t)(p_61 ^ ((uint32_t)p_61 * (uint32_t)(0x64CFDF4E < ((((uint32_t)(65535U & (((*l_78) < (-7)) & 0x9157)) + (uint32_t)(*l_79)) <= p_61) | (*l_78))))) >> (uint16_t)5))
    { /* block id: 52 */
        int32_t ***l_161 = &l_136;
        (***l_161) = ((&l_136 == (void*)0) & ((void*)0 == l_161));
    }
    else
    { /* block id: 54 */
        for (l_64 = 14; (l_64 < 0); l_64 -= 1)
        { /* block id: 57 */
            int32_t *l_164 = &l_154;
            (*l_164) = p_61;
            (*l_136) = l_164;
        }
    }
    if (p_61)
    { /* block id: 62 */
        uint32_t l_167 = 0U;
        const int32_t *l_168 = (void*)0;
        for (l_154 = 0; (l_154 > (-5)); l_154 -= 1)
        { /* block id: 65 */
            (*l_79) = (7U < l_167);
            (*l_79) = (p_61 & p_61);
        }
        (**l_135) = (*l_136);
        return l_168;
    }
    else
    { /* block id: 71 */
        const int16_t l_179 = 1;
        int32_t *l_182 = &l_64;
        (*l_78) = ((((uint16_t)(((uint32_t)p_61 + (uint32_t)((*l_78) > ((((uint32_t)4294967290U - (uint32_t)(((uint16_t)8U % (uint16_t)(((0 & ((uint32_t)l_179 % (uint32_t)((int16_t)(-1) - (int16_t)l_179))) | (((***l_135) , l_179) >= 3)) , p_61)) , l_179)) ^ p_61) || p_61))) <= p_61) >> (uint16_t)l_179) < 0U) <= p_61);
        (**l_135) = l_182;
        l_182 = (void*)0;
        (**l_135) = (**l_135);
    }
    return l_183;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t  func_67(int16_t  p_68)
{ /* block id: 46 */
    int32_t l_138 = (-9);
    int32_t *l_137 = &l_138;
    int32_t **l_139 = (void*)0;
    l_137 = l_137;
    (*l_137) = (~(((int32_t)((uint16_t)(p_68 | (((uint16_t)((void*)0 != &l_137) % (uint16_t)p_68) | ((((!(-(int32_t)((uint16_t)(0xDFAC948D > ((uint16_t)(((void*)0 == &l_137) >= ((*l_137) == ((((((~0x355D) , 4U) > 0xAB54) , (*l_137)) == 1U) <= (*l_137)))) + (uint16_t)0x9F6C)) % (uint16_t)65535U))) <= p_68) , &l_139) == &l_139))) >> (uint16_t)11) % (int32_t)0xE40C6877) > (-1)));
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_73(int32_t * p_74, int32_t * p_75, int32_t  p_76, int16_t  p_77)
{ /* block id: 7 */
    int32_t l_82 = (-1);
    int32_t *l_81 = &l_82;
    int32_t **l_83 = &l_81;
    uint32_t l_89 = 9U;
    (*l_83) = l_81;
    (*l_83) = (void*)0;
    if ((1 == (((p_76 , (~(*p_74))) == (((((-8) && ((((void*)0 == (*l_83)) > (((uint16_t)(p_77 != p_77) >> (uint16_t)0) <= ((int16_t)((((((void*)0 == &p_76) == p_77) | 6U) & 0xEE2C) ^ 0x0316) - (int16_t)l_89))) , p_76)) , 0x99D0) >= p_77) != (*p_75))) < 1U)))
    { /* block id: 10 */
        int32_t l_95 = 0xB7F440AF;
        uint32_t l_106 = 3U;
        int32_t *l_119 = &l_82;
        uint32_t l_121 = 0x0F3C6490;
        int32_t **l_130 = &l_81;
        if (((&p_74 != &l_81) ^ p_77))
        { /* block id: 11 */
            int32_t **l_96 = &l_81;
            for (p_77 = (-16); (p_77 < (-17)); p_77 -= 1)
            { /* block id: 14 */
                int32_t ***l_92 = &l_83;
                (*l_92) = (void*)0;
            }
            p_74 = &l_82;
            for (l_89 = 0; (l_89 == 8); l_89 += 1)
            { /* block id: 20 */
                l_95 = (*p_74);
                return l_95;
            }
            (*l_96) = &l_82;
        }
        else
        { /* block id: 25 */
            int32_t l_100 = 0x596CDD17;
            if ((((~p_77) , ((*p_74) == ((int32_t)(*p_74) + (int32_t)(((&p_76 != (((l_100 == ((0x1B0F83D5 >= (((uint32_t)(0xCA68 & (((uint16_t)(((p_77 < (-(int32_t)1)) , l_106) , 0x2142) << (uint16_t)l_100) & p_77)) - (uint32_t)0x798ED4FF) , 0xEA94120B)) & l_100)) | 1) , (void*)0)) , (void*)0) != &p_74)))) != l_106))
            { /* block id: 26 */
                int32_t ***l_107 = (void*)0;
                int32_t * const *l_109 = &l_81;
                int32_t * const **l_108 = &l_109;
                (*l_108) = &p_75;
                (*l_83) = &p_76;
                return (***l_108);
            }
            else
            { /* block id: 30 */
                uint16_t l_116 = 65535U;
                const int32_t *l_118 = (void*)0;
                int32_t l_120 = (-8);
                uint16_t l_122 = 0x3C10;
                int32_t ***l_129 = (void*)0;
                for (l_82 = 0; (l_82 >= (-7)); l_82 -= 1)
                { /* block id: 33 */
                    int32_t *l_117 = (void*)0;
                    if (l_95)
                        break;
                    l_120 = ((int16_t)(((l_116 , &p_76) != l_117) == (l_118 == l_119)) - (int16_t)(((&l_83 != &l_83) && ((((void*)0 == l_117) | l_100) != (*l_119))) ^ l_100));
                }
                l_130 = (((*p_74) , (l_121 , (l_122 > (((uint16_t)((p_77 > ((uint16_t)0U >> (uint16_t)10)) , 65534U) % (uint16_t)0xF441) || ((int16_t)(65534U && ((&l_119 == &l_81) < 0x3C429AA7)) >> (int16_t)12))))) , &p_74);
            }
        }
        (*p_75) = ((*p_75) && (*p_75));
    }
    else
    { /* block id: 41 */
        (*l_83) = (void*)0;
        return p_76;
    }
    return p_76;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 65
XXX total union variables: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 85

XXX times a variable address is taken: 88
XXX times a pointer is dereferenced on RHS: 41
breakdown:
   depth: 1, occurrence: 29
   depth: 2, occurrence: 7
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 43
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 4
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 272

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 76
   level: 2, occurrence: 53
   level: 3, occurrence: 40
   level: 4, occurrence: 28
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 43
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 42.4
XXX average alias set size: 1.14

XXX times a non-volatile is read: 368
XXX times a non-volatile is write: 122
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 90
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 29
   depth: 2, occurrence: 16
   depth: 3, occurrence: 9
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 13.5
XXX percentage an existing variable is used: 86.5
********************* end of statistics **********************/

