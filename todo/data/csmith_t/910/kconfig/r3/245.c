/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1916465780
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   const float  f1;
   float  f2;
   int32_t  f3;
   int32_t  f4;
   int16_t  f5;
   const unsigned f6 : 14;
   uint16_t  f7;
   int16_t  f8;
};

union U1 {
   const int16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint16_t  func_31(void);
static int32_t  func_33(union U1  p_34, union U1  p_35, uint32_t  p_36, int32_t  p_37);
inline static float  func_40(uint32_t  p_41);
static uint16_t  func_43(int16_t  p_44, uint16_t  p_45, uint16_t  p_46, union U1  p_47, union U1  p_48);
inline static uint16_t  func_49(float  p_50);
inline static float  func_51(struct S0  p_52, union U1  p_53, float  p_54, uint32_t  p_55, uint32_t  p_56);
static struct S0  func_57(uint32_t  p_58, uint32_t  p_59, uint32_t  p_60);
inline static struct S0 * func_62(struct S0  p_63, uint16_t  p_64);
inline static struct S0  func_65(int32_t  p_66, struct S0 * p_67, struct S0 * p_68);
inline static int32_t  func_69(uint32_t  p_70, uint32_t  p_71, struct S0 * p_72, int32_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 1;
    union U1 l_39 = {5};
    struct S0 l_658 = {0xEC47,-0x10.Dp+1,0x1.7CFEDCp+60,3,-9,0x2D85,82,7U,0x36CB};
    struct S0 *l_657 = &l_658;
    struct S0 **l_656 = &l_657;
    struct S0 ***l_655 = &l_656;
    struct S0 ****l_654 = &l_655;
    int32_t *l_678 = &l_658.f4;
    int32_t **l_677 = &l_678;
    int32_t *** const l_676 = &l_677;
    int16_t l_695 = 1;
    const union U1 *l_717 = &l_39;
    const union U1 **l_716 = &l_717;
    uint16_t l_732 = 9U;
    union U1 *l_748 = (void*)0;
    union U1 **l_747 = &l_748;
    int32_t ***l_776 = (void*)0;
    int16_t l_800 = 0;
    uint32_t l_801 = 5U;
    float *l_802 = &l_658.f2;
    const int32_t l_803 = 0x40C49F0A;
    if (l_32)
    { /* block id: 37 */
        union U1 l_38 = {0xB42B};
        struct S0 *** const l_662 = &l_656;
        int32_t *l_672 = &l_32;
        int32_t **l_671 = &l_672;
        int32_t ***l_670 = &l_671;
        float l_753 = 0x0.9p+1;
        union U1 l_754 = {0x6A94};
        uint32_t l_765 = 0x16673D42;
        const uint16_t l_791 = 65531U;
        union U1 l_794 = {-8};
        union U1 *l_793 = &l_794;
        if ((l_32 == func_33(l_38, l_39, l_38.f0, l_38.f0)))
        { /* block id: 425 */
            int32_t *l_628 = &l_32;
            (*l_628) = 0x275825DF;
        }
        else
        { /* block id: 427 */
            struct S0 l_639 = {0,0x1.2p+1,-0x1.8p+1,0x3722EAA7,0xFD7F1260,1,91,65533U,0x713F};
            struct S0 *l_638 = &l_639;
            int32_t *l_647 = &l_32;
            const int32_t *l_664 = &l_639.f4;
            union U1 l_709 = {0x3470};
            uint32_t l_712 = 4294967288U;
            union U1 *l_715 = &l_709;
            union U1 **l_714 = &l_715;
            const int16_t l_722 = (-9);
            struct S0 ***l_731 = &l_656;
            int32_t ****l_739 = &l_670;
            union U1 ***l_763 = &l_747;
            union U1 * const *l_786 = (void*)0;
            union U1 * const **l_785 = &l_786;
            for (l_32 = 4; (l_32 < 21); ++l_32)
            { /* block id: 430 */
                int32_t *l_631 = &l_32;
                int32_t **l_632 = (void*)0;
                int32_t **l_633 = &l_631;
                int32_t l_634 = 0xB2839A54;
                union U1 *l_653 = &l_39;
                (*l_633) = l_631;
                if ((*l_631))
                    break;
                for (l_634 = 0; (l_634 > (-23)); l_634--)
                { /* block id: 435 */
                    struct S0 **l_637 = (void*)0;
                    int32_t l_640 = 0x6EC612AB;
                    int32_t **l_665 = &l_631;
                    if (l_39.f0)
                        break;
                    l_638 = (void*)0;
                    /* statement id: 437 */
                    assert (l_638 == 0);
                    if ((l_640 | (((uint32_t)l_640 % (uint32_t)((int16_t)l_639.f5 << (int16_t)7)) <= ((((int16_t)((l_647 == (void*)0) && __builtin_parity(l_640)) + (int16_t)((uint32_t)((0xFA22 != l_39.f0) >= l_39.f0) + (uint32_t)l_38.f0)) < 0U) == 0U))))
                    { /* block id: 438 */
                        union U1 l_650 = {2};
                        float *l_659 = &l_658.f2;
                        int32_t *l_660 = (void*)0;
                        (*l_659) = (l_38.f0 == (func_33(l_650, l_39, ((int32_t)((((l_653 == (void*)0) && l_650.f0) || ((*l_647) <= (((*l_647) < (l_654 != (void*)0)) ^ l_650.f0))) > l_650.f0) + (int32_t)0x361C70C2), l_38.f0) != l_38.f0));
                        (*l_633) = l_660;
                        /* statement id: 440 */
                        assert (l_631 == 0);
                    }
                    else
                    { /* block id: 441 */
                        union U1 **l_661 = &l_653;
                        int32_t *l_663 = &l_658.f4;
                        if ((*l_631))
                            break;
                        (*l_661) = l_653;
                        (*l_663) = ((void*)0 == l_662);
                        (*l_633) = (*l_633);
                    }
                    /* facts after branching */
                    assert (l_631 == &l_639.f4 || l_631 == &l_32 || l_631 == 0);
                    (*l_665) = l_664;
                    /* statement id: 447 */
                    assert (l_631 == &l_639.f4);
                }
                /* facts after for loop */
                assert (l_631 == &l_639.f4 || l_631 == &l_32);
                if (l_658.f0)
                { /* block id: 449 */
                    int32_t *l_668 = &l_32;
                    for (l_639.f8 = (-12); (l_639.f8 == 17); l_639.f8++)
                    { /* block id: 452 */
                        int32_t **l_669 = &l_668;
                        (*l_633) = l_668;
                        if ((*l_647))
                            break;
                        (*l_669) = l_664;
                        /* statement id: 455 */
                        assert (l_668 == &l_639.f4);
                    }
                    /* facts after for loop */
                    assert (l_668 == &l_639.f4 || l_668 == &l_32);
                    return l_38.f0;
                }
                else
                { /* block id: 458 */
                    uint32_t l_673 = 0x9855776F;
                    union U1 l_696 = {0x1F79};
                    int32_t l_697 = (-7);
                    float *l_718 = &l_639.f2;
                    if (((((void*)0 != l_670) & (**l_633)) <= ((*l_631) & (*l_664))))
                    { /* block id: 459 */
                        int32_t ***l_679 = &l_632;
                        float *l_699 = &l_658.f2;
                        l_673 = (-3);
                        l_697 = func_43((*l_647), ((((int16_t)((l_676 != l_679) < ((uint16_t)(**l_671) >> (uint16_t)(**l_671))) << (int16_t)0) != ((int16_t)(((int16_t)((-(uint16_t)((uint16_t)((int32_t)(((*l_647) >= (((uint16_t)1U + (uint16_t)((uint32_t)((***l_670) <= ((*l_672) >= 0x4A01EF84)) % (uint32_t)(***l_670))) >= (**l_671))) & (*l_647)) - (int32_t)(*l_647)) - (uint16_t)l_695)) >= l_673) >> (int16_t)(*l_678)) == 4) - (int16_t)(***l_676))) >= (*l_672)), (**l_677), l_696, l_696);
                        (*l_670) = &l_647;
                        /* statement id: 462 */
                        assert (l_671 == &l_647);
                        (*l_699) = (!(*l_664));
                    }
                    else
                    { /* block id: 464 */
                        const int32_t l_702 = 0xB599EEE4;
                        float *l_713 = &l_658.f2;
                        (*l_713) = (((float)((**l_671) <= l_702) - (float)(((float)((float)(func_69(((int32_t)(func_33(l_38, l_709, l_702, ((l_702 > (((**l_671) <= ((uint16_t)((l_696.f0 && l_702) == (*l_647)) << (uint16_t)l_702)) || l_702)) == 0xEF97A338)) && 0x62866242) % (int32_t)(**l_633)), l_697, (**l_662), (*l_647)) <= 0x0.Ap+1) - (float)l_712) + (float)l_702) > 0x1.Ap-1)) < 0x7.Ep+1);
                        if ((*l_672))
                            break;
                    }
                    (*l_718) = ((__builtin_parityll(l_697) != ((-0x1.Bp-1) >= ((*l_676) == (*l_670)))) > (l_714 != l_716));
                    for (l_658.f7 = 17; (l_658.f7 > 54); l_658.f7++)
                    { /* block id: 471 */
                        int32_t *l_721 = &l_639.f4;
                        (*l_671) = l_721;
                        /* statement id: 472 */
                        assert (l_647 == &l_639.f4 || l_647 == &l_32);
                        assert (l_672 == &l_639.f4 || l_672 == &l_32);
                        (*l_718) = (*l_721);
                        return l_722;
                    }
                }
            }
            /* facts after for loop */
            assert (l_638 == 0 || l_638 == &l_639);
            assert (l_671 == &l_672 || l_671 == &l_647);
            for (l_712 = 0; (l_712 != 13); ++l_712)
            { /* block id: 480 */
                int32_t l_728 = 0x585EE882;
                struct S0 l_740 = {0xA331,0x4.Ep+1,0x7.B8EF83p-80,0xF9AFFF9B,0xAF0F9DC9,0,30,65531U,0x44BE};
                for (l_32 = 0; (l_32 < 12); l_32 += 2)
                { /* block id: 483 */
                    float *l_727 = &l_658.f2;
                    int32_t l_729 = 1;
                    struct S0 ***l_730 = (void*)0;
                    int32_t ****l_737 = (void*)0;
                    (*l_727) = (***l_670);
                    (*l_671) = (**l_670);
                }
            }
            if (__builtin_parityl(func_43(((((int16_t)((((l_747 != &l_715) > (*l_647)) & (**l_671)) && ((void*)0 != (*l_714))) << (int16_t)((((((int32_t)((int16_t)(((((func_43((*l_647), (*l_678), (*l_678), (**l_714), l_38) ^ 0xC53EE8B1) ^ (****l_739)) != 0xFA91) < (**l_677)) | 0x850B) >> (int16_t)(*l_672)) + (int32_t)0) ^ 0xE452) <= (***l_676)) == (-4)) || (*l_647))) > 0x83F1) & (*l_647)), (**l_671), (*l_678), l_754, l_754)))
            { /* block id: 500 */
                uint32_t l_756 = 7U;
                (*l_678) = (__builtin_parity((****l_739)) == (~((l_756 ^ 1U) & 0x64D91C60)));
            }
            else
            { /* block id: 502 */
                int32_t l_759 = 0x21A739BD;
                const int16_t l_781 = 0x517B;
                if (((uint16_t)((*l_647) ^ ((*l_647) < (((*l_676) == (void*)0) > ((l_759 < ((func_49(((**l_662) != (void*)0)) > ((int16_t)((((-(uint16_t)(8 & 0)) != (***l_676)) & 0x370D3360) <= (***l_676)) << (int16_t)12)) & (*l_672))) || l_759)))) << (uint16_t)(***l_670)))
                { /* block id: 503 */
                    (*l_671) = (**l_676);
                    /* statement id: 504 */
                    assert (l_647 == &l_658.f4 || l_647 == &l_32);
                    assert (l_672 == &l_658.f4 || l_672 == &l_32);
                }
                else
                { /* block id: 505 */
                    union U1 l_764 = {0};
                    int32_t *****l_775 = &l_739;
                    l_763 = (void*)0;
                    /* statement id: 506 */
                    assert (l_763 == 0);
                    (***l_676) = func_33(l_764, l_764, l_759, l_764.f0);
                    if (l_759)
                    { /* block id: 508 */
                        (***l_676) = l_765;
                    }
                    else
                    { /* block id: 510 */
                        int32_t l_777 = 0xB0C560A9;
                        int32_t l_778 = (-1);
                        (*l_672) = ((uint16_t)0x7174 >> (uint16_t)(((uint16_t)__builtin_ffsl(((((((uint32_t)(__builtin_ctzl(func_49((-(float)(((((((float)((l_759 >= __builtin_clz((**l_671))) >= (*l_678)) + (float)(l_775 != &l_739)) == (l_776 == (void*)0)) >= 0x2.725BBDp-24) != (***l_670)) > l_777) < (***l_676))))) && l_778) + (uint32_t)(*****l_775)) >= l_777) <= l_759) == (**l_671)) > (**l_671))) << (uint16_t)l_778) | (*****l_775)));
                    }
                    if (((int16_t)((*l_739) != (**l_775)) >> (int16_t)2))
                    { /* block id: 513 */
                        return l_781;
                    }
                    else
                    { /* block id: 515 */
                        const int32_t l_782 = (-4);
                        float *l_787 = (void*)0;
                        float *l_788 = &l_639.f2;
                        int32_t l_792 = 0xE854B1BC;
                        (**l_670) = (**l_676);
                        /* statement id: 516 */
                        assert (l_647 == &l_658.f4 || l_647 == &l_32);
                        assert (l_672 == &l_658.f4 || l_672 == &l_32);
                        (*l_788) = ((((l_782 <= (*****l_775)) != ((*****l_775) != (***l_676))) < (((float)(**l_671) + (float)(0x1.4p+1 > (**l_671))) != (((void*)0 != l_785) <= 0x1.0p+1))) != l_781);
                        l_792 = ((((((int32_t)l_791 % (int32_t)((*l_647) ^ 3)) < __builtin_ia32_crc32qi((*l_678), (0xE5A32EAD && ((*l_672) >= l_781)))) <= (**l_671)) != (**l_671)) >= (-8));
                    }
                    /* facts after branching */
                    assert (l_647 == &l_658.f4 || l_647 == &l_32);
                    assert (l_672 == &l_658.f4 || l_672 == &l_32);
                }
                /* facts after branching */
                assert (l_647 == &l_658.f4 || l_647 == &l_32);
                assert (l_672 == &l_658.f4 || l_672 == &l_32);
                assert (l_763 == 0 || l_763 == &l_747);
            }
            /* facts after branching */
            assert (l_647 == &l_658.f4 || l_647 == &l_32);
            assert (l_672 == &l_658.f4 || l_672 == &l_32);
            assert (l_763 == 0 || l_763 == &l_747);
        }
        /* facts after branching */
        assert (l_672 == &l_658.f4 || l_672 == &l_32);
        //assert (l_671 == &l_672 || l_671 == dangling);
        l_793 = &l_38;
        /* statement id: 523 */
        assert (l_793 == &l_38);
    }
    else
    { /* block id: 524 */
        const int32_t l_795 = 0x2636A92A;
        return l_795;
    }
    (*l_802) = __builtin_parityl(((int16_t)((uint32_t)(__builtin_popcount((*l_678)) && ((1U < (***l_676)) && ((***l_676) > (func_33((**l_716), (*l_717), (*l_678), (l_800 && (***l_676))) <= l_801)))) % (uint32_t)(**l_677)) + (int16_t)(*l_678)));
    (*l_716) = (*l_716);
    (***l_676) = (**l_677);
    return l_803;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_33(union U1  p_34, union U1  p_35, uint32_t  p_36, int32_t  p_37)
{ /* block id: 38 */
    int16_t l_42 = (-1);
    union U1 l_616 = {0xEE51};
    float l_626 = 0x0.9p-1;
    float *l_625 = &l_626;
    float l_627 = 0x0.Dp+1;
    (*l_625) = func_40(((__builtin_ffsl(l_42) && func_43(__builtin_bswap64(p_36), ((p_36 == func_49(l_42)) || l_42), p_37, p_34, l_616)) >= 0xCF5824F4));
    (*l_625) = p_35.f0;
    return l_616.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_40(uint32_t  p_41)
{ /* block id: 418 */
    int32_t *l_621 = (void*)0;
    int32_t **l_620 = &l_621;
    struct S0 *l_623 = (void*)0;
    int32_t l_624 = 0xAFEA38CC;
    (*l_620) = (void*)0;
    l_624 = ((p_41 >= (~p_41)) || ((void*)0 == l_623));
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_43(int16_t  p_44, uint16_t  p_45, uint16_t  p_46, union U1  p_47, union U1  p_48)
{ /* block id: 415 */
    int32_t l_618 = 0x88C82E67;
    int32_t *l_617 = &l_618;
    int32_t **l_619 = &l_617;
    (*l_619) = l_617;
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_49(float  p_50)
{ /* block id: 39 */
    int32_t l_61 = 1;
    union U1 l_607 = {0xA99C};
    float l_615 = 0x0.320B51p-0;
    float *l_614 = &l_615;
    (*l_614) = func_51(func_57(l_61, l_61, l_61), l_607, p_50, l_61, l_607.f0);
    return l_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_51(struct S0  p_52, union U1  p_53, float  p_54, uint32_t  p_55, uint32_t  p_56)
{ /* block id: 407 */
    int16_t l_608 = 0;
    int32_t l_610 = 0x3E334D8D;
    int32_t *l_609 = &l_610;
    int32_t **l_611 = &l_609;
    float l_613 = 0xE.99945Ap+87;
    float *l_612 = &l_613;
    (*l_609) = l_608;
    (*l_611) = &l_610;
    (*l_612) = 0x7.CA0863p-59;
    (*l_611) = (*l_611);
    return p_52.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_57(uint32_t  p_58, uint32_t  p_59, uint32_t  p_60)
{ /* block id: 40 */
    float l_74 = 0x4.C28C4Fp-6;
    int32_t l_78 = (-6);
    struct S0 l_80 = {0xBF52,0xC.09DEA6p+11,0x2.A27FA5p+35,0,0x9BECC425,0x8E10,123,1U,0xB9CC};
    struct S0 *l_79 = &l_80;
    struct S0 **l_511 = &l_79;
    float *l_512 = (void*)0;
    int32_t *l_513 = &l_80.f4;
    union U1 l_540 = {-1};
    union U1 *l_539 = &l_540;
    const int32_t l_551 = 0x606CE886;
    int32_t **l_553 = &l_513;
    int32_t ***l_552 = &l_553;
    uint32_t l_554 = 0U;
    float l_559 = 0x3.7p-1;
    (*l_511) = func_62(func_65((func_69(p_60, __builtin_parityll(((int16_t)(-(int32_t)(l_78 == 1U)) + (int16_t)p_59)), l_79, __builtin_popcountl(p_58)) >= p_58), &l_80, &l_80), p_60);
    /* statement id: 347 */
    assert (l_79 == 0);
    l_78 = p_59;
    l_513 = &l_78;
    /* statement id: 349 */
    assert (l_513 == &l_78);
    if (p_59)
    { /* block id: 350 */
        struct S0 l_514 = {0,0xF.CF7F68p-62,0x0.7C1749p-35,0,0x50A9CAA3,2,26,0xB194,9};
        return l_514;
    }
    else
    { /* block id: 352 */
        struct S0 l_516 = {0x70DE,0x2.Fp-1,0x4.8p+1,6,0xEA31AFB0,0xF292,35,65535U,1};
        struct S0 *l_515 = &l_516;
        union U1 *** const l_524 = (void*)0;
        struct S0 ***l_576 = &l_511;
        struct S0 ****l_575 = &l_576;
        struct S0 *****l_574 = &l_575;
        int32_t *l_577 = &l_80.f4;
lbl_595:
        l_515 = (void*)0;
        /* statement id: 353 */
        assert (l_515 == 0);
        if (((uint16_t)(p_59 ^ ((int16_t)0 % (int16_t)0x0A1A)) + (uint16_t)0x6AC2))
        { /* block id: 354 */
            const union U1 *l_527 = (void*)0;
            const union U1 **l_526 = &l_527;
            const union U1 ***l_525 = &l_526;
            int32_t l_538 = 1;
            float *l_546 = (void*)0;
            struct S0 *** const l_596 = &l_511;
            if (p_59)
            { /* block id: 355 */
                int32_t **l_521 = &l_513;
                int32_t *l_522 = (void*)0;
                int32_t *l_523 = &l_80.f4;
                (*l_521) = (void*)0;
                /* statement id: 356 */
                assert (l_513 == 0);
                (*l_523) = p_60;
            }
            else
            { /* block id: 358 */
                int32_t l_532 = 0xCC02263D;
                struct S0 **l_533 = (void*)0;
                int32_t **l_544 = &l_513;
                int32_t **l_545 = &l_513;
                float *l_547 = &l_80.f2;
                union U1 *l_562 = &l_540;
                struct S0 ****l_597 = &l_576;
                if (((l_524 == l_525) ^ p_58))
                { /* block id: 359 */
                    const uint32_t l_535 = 0x01052792;
                    const union U1 * const l_541 = (void*)0;
                    (*l_513) = p_58;
                    if (((l_516.f5 > ((int16_t)((((((int16_t)(l_532 > 0x88A3AD5C) + (int16_t)((void*)0 == l_533)) || (+l_535)) > l_532) | ((l_532 <= ((uint16_t)(l_532 < 1U) << (uint16_t)5)) != (*l_513))) <= p_59) % (int16_t)l_538)) >= p_60))
                    { /* block id: 361 */
                        (*l_513) = (((l_539 == l_541) < 0x6.8p+1) > func_69(((int16_t)0xEE31 << (int16_t)15), (l_544 == l_545), (*l_511), ((0x84DC0047 && (l_546 != l_547)) || 65534U)));
                        (**l_544) = l_535;
                        (*l_547) = (!((((float)(0x1.Cp-1 >= __builtin_bswap32(l_516.f5)) - (float)((0xD.EA0F8Ap-72 == 0xC.99DE25p-35) != 0x1.7p-1)) != p_60) < p_59));
                    }
                    else
                    { /* block id: 365 */
                        (*l_513) = p_59;
                        (*l_547) = l_551;
                        (*l_547) = (((void*)0 == l_552) <= (((l_554 > ((float)((void*)0 == &l_540) - (float)func_69(((int16_t)p_60 - (int16_t)((**l_553) < (((int16_t)(0x449CC034 ^ l_535) % (int16_t)l_535) >= l_538))), (**l_545), &l_516, p_60))) != p_60) > l_516.f0));
                        (*l_526) = l_562;
                        /* statement id: 369 */
                        assert (l_527 == &l_540);
                    }
                    /* facts after branching */
                    assert (l_527 == &l_540 || l_527 == 0);
                }
                else
                { /* block id: 371 */
                    int32_t *l_563 = &l_80.f4;
                    union U1 *l_588 = (void*)0;
                    (**l_552) = l_563;
                    /* statement id: 372 */
                    assert (l_513 == &l_80.f4);
                    if (l_80.f6)
                        goto lbl_570;
                    (*l_563) = ((~(**l_545)) ^ l_538);
                    if (p_59)
                    { /* block id: 374 */
                        (*l_547) = ((*l_544) != (void*)0);
lbl_570:
                        (*l_547) = ((float)(-(float)((float)p_60 + (float)p_59)) - (float)0x0.195720p+52);
lbl_594:
                        l_516.f4 = p_59;
                        (*l_553) = l_563;
                        /* statement id: 379 */
                        assert (l_513 == &l_80.f4);
                    }
                    else
                    { /* block id: 380 */
                        struct S0 *****l_573 = (void*)0;
                        (**l_545) = ((float)p_60 - (float)p_60);
                        l_574 = l_573;
                        /* statement id: 382 */
                        assert (l_574 == 0);
                        (**l_552) = l_577;
                    }
                    if ((__builtin_ffsl(((~(&l_511 == (void*)0)) ^ ((int16_t)((int16_t)(((uint32_t)(!(((uint16_t)0xD024 >> (uint16_t)((l_562 == l_588) && (l_538 && (p_58 >= ((p_59 == ((uint32_t)__builtin_parityll(((func_69(((uint16_t)(~p_60) >> (uint16_t)p_59), l_538, (*l_511), p_60) <= (**l_544)) > p_60)) + (uint32_t)0x5B8DCA52)) & (**l_553)))))) || 0x48DA1B2E)) + (uint32_t)(**l_544)) && (-5)) + (int16_t)p_59) >> (int16_t)13))) || p_58))
                    { /* block id: 385 */
                        (*l_544) = (void*)0;
                        /* statement id: 386 */
                        assert (l_513 == 0);
                        if (p_60)
                            goto lbl_594;
                        (**l_525) = l_588;
                    }
                    else
                    { /* block id: 389 */
                        if (l_80.f5)
                            goto lbl_595;
                    }
                    /* facts after branching */
                    assert (l_513 == &l_80.f4 || l_513 == 0);
                }
                /* facts after branching */
                assert (l_513 == &l_80.f4 || l_513 == 0 || l_513 == &l_78);
                assert (l_527 == &l_540 || l_527 == 0);
                (*l_597) = l_596;
            }
            /* facts after branching */
            assert (l_513 == &l_80.f4 || l_513 == 0 || l_513 == &l_78);
            assert (l_527 == &l_540 || l_527 == 0);
        }
        else
        { /* block id: 395 */
            int32_t *l_598 = &l_80.f4;
            (*l_553) = l_598;
            /* statement id: 396 */
            assert (l_513 == &l_80.f4);
        }
        /* facts after branching */
        assert (l_513 == &l_80.f4 || l_513 == 0 || l_513 == &l_78);
        for (l_516.f5 = 26; (l_516.f5 != (-26)); --l_516.f5)
        { /* block id: 400 */
            int32_t l_601 = (-1);
            struct S0 *l_602 = &l_80;
            union U1 *l_605 = &l_540;
            float *l_606 = &l_516.f2;
            (*l_606) = ((p_58 >= (l_601 == (*l_577))) < func_69(p_60, p_58, l_602, (p_59 <= (((int16_t)p_60 << (int16_t)(((&l_540 != l_605) && p_60) < (*l_577))) >= l_601))));
            (*l_606) = ((void*)0 != &l_79);
            (*l_553) = &l_601;
            /* statement id: 403 */
            assert (l_513 == &l_601);
        }
        /* facts after for loop */
        //assert (l_513 == dangling || l_513 == &l_80.f4 || l_513 == 0 || l_513 == &l_78);
    }
    /* facts after branching */
    //assert (l_513 == dangling || l_513 == &l_80.f4 || l_513 == 0 || l_513 == &l_78);
    return l_80;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_62(struct S0  p_63, uint16_t  p_64)
{ /* block id: 343 */
    uint16_t l_504 = 5U;
    int32_t l_506 = 0x71EA74E1;
    int32_t *l_505 = &l_506;
    struct S0 l_508 = {0x0600,0x3.18006Fp+22,0x0.7p+1,0x6D1E40F1,0,0,114,0x1B34,0x8E54};
    struct S0 *l_507 = &l_508;
    struct S0 **l_509 = &l_507;
    struct S0 *l_510 = (void*)0;
    (*l_505) = l_504;
    (*l_509) = l_507;
    return l_510;
    /* statement id: 346 */
    //assert (func_62_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_65(int32_t  p_66, struct S0 * p_67, struct S0 * p_68)
{ /* block id: 262 */
    uint32_t l_365 = 0x4A38D7EE;
    int32_t l_374 = 0xF72A92D6;
    int32_t *l_373 = &l_374;
    union U1 l_418 = {0};
    union U1 * const l_417 = &l_418;
    int32_t ***l_477 = (void*)0;
    struct S0 ****l_481 = (void*)0;
    if ((l_365 < p_66))
    { /* block id: 263 */
        union U1 l_368 = {0xC827};
        union U1 *l_367 = &l_368;
        union U1 **l_366 = &l_367;
        int32_t l_370 = 0x55E6FC16;
        int32_t *l_369 = &l_370;
        struct S0 l_383 = {0xF203,0x1.Bp-1,0x5.32A649p+15,0x119D4D78,1,-1,41,0x1DBC,0xD311};
        struct S0 *l_382 = &l_383;
        int32_t **l_437 = (void*)0;
        int32_t **l_438 = (void*)0;
lbl_436:
        (*l_369) = (l_365 >= (l_366 != (void*)0));
        (*l_369) = l_365;
        for (p_66 = (-10); (p_66 <= 21); p_66++)
        { /* block id: 268 */
            int32_t **l_375 = &l_373;
            union U1 *l_416 = &l_368;
            int32_t *l_435 = &l_383.f4;
            (*l_375) = l_373;
            if (((int32_t)(__builtin_parityll((*l_369)) && (((uint32_t)0U + (uint32_t)((uint16_t)65528U << (uint16_t)(*l_369))) && __builtin_ctzll((*l_369)))) - (int32_t)(*l_369)))
            { /* block id: 270 */
                struct S0 **l_384 = &l_382;
                (*l_384) = l_382;
            }
            else
            { /* block id: 272 */
                uint32_t l_391 = 0x1BDBC665;
                struct S0 ** const **l_410 = (void*)0;
                struct S0 ** const ***l_409 = &l_410;
                struct S0 *l_413 = &l_383;
                int32_t *l_433 = &l_370;
                if (((p_66 != p_66) <= ((int16_t)(p_66 < ((int32_t)(((0x1EE038D1 != (*l_369)) < 0x4A4B0801) & p_66) + (int32_t)((int16_t)l_391 + (int16_t)((int16_t)(((int16_t)p_66 - (int16_t)p_66) < p_66) % (int16_t)0x9EA3)))) % (int16_t)p_66)))
                { /* block id: 273 */
                    int32_t l_400 = 7;
                    union U1 **l_406 = (void*)0;
                    struct S0 ** const ***l_411 = (void*)0;
                    if (((int16_t)(l_391 || l_391) << (int16_t)((int32_t)(func_69(p_66, p_66, &l_383, p_66) >= (p_66 ^ 0x5B96)) % (int32_t)l_400)))
                    { /* block id: 274 */
                        float *l_403 = &l_383.f2;
                        int32_t l_407 = 0xB98AA170;
                        (*l_403) = ((float)l_400 - (float)l_400);
                        (**l_375) = func_69(((int16_t)(((void*)0 == l_406) || 65529U) + (int16_t)6U), l_407, p_68, p_66);
                        (*l_403) = p_66;
                    }
                    else
                    { /* block id: 278 */
                        float l_408 = 0x6.7E3D8Dp+88;
                        if (p_66)
                            break;
                        (*l_369) = (p_66 < (**l_375));
                    }
                    if ((l_409 != l_411))
                    { /* block id: 282 */
                        int32_t * const l_412 = &l_370;
                        struct S0 **l_414 = &l_382;
                        l_369 = l_412;
                        (*l_414) = l_413;
                        /* statement id: 284 */
                        assert (l_382 == &l_383);
                    }
                    else
                    { /* block id: 285 */
                        uint32_t l_415 = 0xE9904F22;
                        float *l_419 = &l_383.f2;
                        union U1 ** const *l_420 = &l_366;
                        (*l_369) = l_415;
                        (*l_419) = (l_416 == l_417);
                        if ((*l_373))
                            continue;
                        (*l_419) = ((void*)0 == l_420);
                    }
                }
                else
                { /* block id: 291 */
                    (*l_373) = l_391;
                    (*l_375) = (*l_375);
                }
                if (func_69(((int16_t)p_66 - (int16_t)(!__builtin_popcountl(((*l_373) & (*l_373))))), ((((uint16_t)p_66 >> (uint16_t)func_69((((((int16_t)((int16_t)((uint32_t)(((**l_375) & ((0x9DE8 == ((*l_409) == (void*)0)) ^ (*l_369))) ^ 0x0457) % (uint32_t)p_66) >> (int16_t)p_66) << (int16_t)8) <= p_66) != p_66) <= (**l_375)), (*l_369), p_67, p_66)) | l_391) & p_66), p_67, (*l_369)))
                { /* block id: 295 */
                    int32_t l_434 = 7;
                    if ((2 | 0x99B6))
                    { /* block id: 296 */
                        struct S0 **l_432 = &l_382;
                        (*l_432) = p_68;
                        /* statement id: 297 */
                        //assert (l_382 == &l_80 || l_382 == 0);
                    }
                    else
                    { /* block id: 298 */
                        if (p_66)
                            break;
                        (*l_375) = l_433;
                        /* statement id: 300 */
                        assert (l_373 == &l_370);
                        if (l_434)
                            break;
                        if (p_66)
                            break;
                    }
                    /* facts after branching */
                    assert (l_373 == &l_370 || l_373 == &l_374 || l_373 == &l_383.f4);
                    (*l_375) = l_435;
                    /* statement id: 304 */
                    assert (l_373 == &l_383.f4);
                    (*l_369) = 0x29C8DF18;
                }
                else
                { /* block id: 306 */
                    (*l_366) = l_416;
                }
                if (l_391)
                    goto lbl_436;
            }
        }
        /* facts after for loop */
        assert (l_373 == &l_370 || l_373 == &l_374 || l_373 == &l_383.f4);
        l_369 = &l_374;
        /* statement id: 312 */
        assert (l_369 == &l_374);
    }
    else
    { /* block id: 313 */
        int32_t l_448 = 4;
        union U1 *l_461 = &l_418;
        uint32_t l_464 = 0xB0D0B993;
        const int32_t ***l_478 = (void*)0;
        float l_502 = 0x8.19016Fp-47;
        float *l_501 = &l_502;
        int32_t *l_503 = &l_374;
        if (((uint32_t)(~((*l_373) >= (((uint16_t)0x44D5 - (uint16_t)(func_69(p_66, __builtin_bswap64(((int16_t)((uint32_t)l_448 + (uint32_t)(0x93CA != (((((uint16_t)(p_66 & ((((uint16_t)(((int16_t)p_66 - (int16_t)((uint16_t)l_448 << (uint16_t)(((uint16_t)((((uint16_t)1U >> (uint16_t)p_66) | l_448) < 65535U) - (uint16_t)8) == l_448))) || 0) << (uint16_t)(*l_373)) < 0x1419D0CF) && 0x3B51)) - (uint16_t)(*l_373)) && p_66) == l_448) == (*l_373)))) % (int16_t)l_448)), p_67, l_448) ^ p_66)) != l_448))) - (uint32_t)0x53C9033E))
        { /* block id: 314 */
            (*l_373) = (l_461 != (void*)0);
        }
        else
        { /* block id: 316 */
            float l_462 = 0x4.F4186Dp+40;
            float *l_463 = &l_462;
            int32_t l_493 = 0x61F6D0D2;
            int32_t l_496 = 0;
            union U1 *l_498 = (void*)0;
            (*l_463) = l_462;
            if (l_464)
            { /* block id: 318 */
                int32_t l_465 = (-7);
                int32_t **l_466 = (void*)0;
                (*l_463) = l_465;
                l_373 = l_463;
                /* statement id: 320 */
                assert (l_373 == &l_462);
                if (((uint32_t)0xF73B9A51 - (uint32_t)((int16_t)(func_69(((uint32_t)((uint32_t)p_66 % (uint32_t)(-(int16_t)(-(int32_t)p_66))) + (uint32_t)(l_464 >= l_464)), (*l_373), p_68, p_66) && p_66) + (int16_t)0)))
                { /* block id: 321 */
                    (*l_373) = (l_477 != l_478);
                }
                else
                { /* block id: 323 */
                    const int16_t l_487 = 8;
                    uint32_t l_494 = 0xB8E1D687;
                    int32_t *l_495 = (void*)0;
                    for (l_465 = 8; (l_465 > 29); l_465 += 7)
                    { /* block id: 326 */
                        struct S0 ***l_483 = (void*)0;
                        struct S0 ****l_482 = &l_483;
                        int32_t l_486 = 0xC3087075;
                        (*l_373) = 4;
                        (*l_373) = (l_481 != l_482);
                        l_486 = (((int16_t)(l_486 & (-4)) >> (int16_t)1) > (l_487 <= (((uint16_t)((uint16_t)0x8B18 >> (uint16_t)11) + (uint16_t)((+l_493) == l_494)) < func_69(l_486, l_494, p_68, p_66))));
                    }
                    l_495 = &l_493;
                    /* statement id: 331 */
                    assert (l_495 == &l_493);
                }
            }
            else
            { /* block id: 333 */
                uint16_t l_497 = 0x8E49;
                l_497 = l_496;
            }
            /* facts after branching */
            assert (l_373 == &l_374 || l_373 == &l_462);
            l_498 = &l_418;
            /* statement id: 336 */
            assert (l_498 == &l_418);
            (*l_463) = ((float)(-0x1.Cp-1) - (float)l_496);
        }
        /* facts after branching */
        //assert (l_373 == &l_374 || l_373 == dangling);
        (*l_501) = p_66;
        l_373 = l_503;
        /* statement id: 340 */
        assert (l_373 == &l_374);
    }
    /* facts after branching */
    //assert (l_373 == dangling || l_373 == &l_374);
    return (*p_67);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_69(uint32_t  p_70, uint32_t  p_71, struct S0 * p_72, int32_t  p_73)
{ /* block id: 41 */
    int32_t l_81 = (-1);
    int32_t l_108 = (-3);
    struct S0 **l_129 = (void*)0;
    uint32_t l_141 = 0xC646EC4B;
    int16_t l_198 = 0xE94D;
    union U1 l_210 = {0xFD1B};
    union U1 *l_209 = &l_210;
    union U1 **l_208 = &l_209;
    union U1 ***l_207 = &l_208;
    uint32_t l_228 = 7U;
    struct S0 l_230 = {-1,0x5.Ep-1,0x3.0p+1,0xB8020A6B,0xE54040A6,0xBE89,57,8U,0x9817};
    struct S0 *l_229 = &l_230;
    int32_t *l_246 = &l_81;
    int32_t *l_325 = &l_230.f4;
    p_73 = l_81;
    return p_73;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 221
   depth: 1, occurrence: 2
XXX total union variables: 9

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 12
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 15
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 31
breakdown:
   depth: 1, occurrence: 225
   depth: 2, occurrence: 25
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 2
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1

XXX total number of pointers: 223

XXX times a variable address is taken: 210
XXX times a pointer is dereferenced on RHS: 165
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 41
   depth: 3, occurrence: 18
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 159
breakdown:
   depth: 1, occurrence: 143
   depth: 2, occurrence: 11
   depth: 3, occurrence: 5
XXX times a pointer is compared with null: 30
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 448

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 562
   level: 2, occurrence: 117
   level: 3, occurrence: 34
   level: 4, occurrence: 4
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 110
XXX number of pointers point to scalars: 73
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 32.3
XXX average alias set size: 1.25

XXX times a non-volatile is read: 1032
XXX times a non-volatile is write: 403
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 176
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 14
   depth: 2, occurrence: 16
   depth: 3, occurrence: 19
   depth: 4, occurrence: 34
   depth: 5, occurrence: 61

XXX percentage a fresh-made variable is used: 25.4
XXX percentage an existing variable is used: 74.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

