/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1711469840
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   int32_t  f1;
   uint32_t  f2;
   int32_t  f3;
   uint32_t  f4;
   signed f5 : 8;
   uint16_t  f6;
   signed f7 : 26;
   uint16_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int16_t g_5 = 0x2631;
static uint32_t g_33 = 0U;
static struct S0 g_94 = {9U,0x7FFF3577,0x8ED4FF94,0xDEA94120,8U,5,7U,-5942,0xE3F1};
static int16_t g_204 = 0xA20A;
static struct S0 g_287 = {0xE3640A0D,0x183B725F,6U,0x9CE884C0,0x448FBCCC,-2,65532U,-7982,65531U};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_26(void);
static int16_t  func_30(uint16_t  p_31, uint16_t  p_32);
static uint16_t  func_34(int16_t  p_35, struct S0  p_36, int32_t  p_37);
static struct S0  func_38(uint32_t  p_39, struct S0  p_40);
static struct S0  func_42(uint32_t  p_43, int16_t  p_44);
static uint32_t  func_46(struct S0  p_47, struct S0  p_48, int16_t  p_49, uint32_t  p_50);
static struct S0  func_51(uint16_t  p_52);
static uint16_t  func_64(int16_t  p_65, uint16_t  p_66, uint16_t  p_67, uint32_t  p_68);
static int16_t  func_88(int32_t  p_89, struct S0  p_90, int32_t  p_91, int16_t  p_92, uint32_t  p_93);
static int32_t  func_95(uint32_t  p_96, uint32_t  p_97, int32_t  p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_33 g_5 g_94 g_204 g_287.f2 g_287.f6
 * writes: g_94.f5 g_94 g_204 g_287 g_33
 */
static uint16_t  func_26(void)
{ /* block id: 36 */
    int16_t l_29 = 0x22BA;
    uint32_t l_41 = 4294967291U;
    uint32_t l_45 = 0x2964071C;
    int32_t l_53 = 1;
    struct S0 l_80 = {0x93538B87,-7,0U,-1,0xBC84746B,10,1U,4300,0x90AC};
    l_80.f5 = ((uint32_t)(l_29 || l_29) + (uint32_t)(func_30((0xF928 > g_33), (func_34(l_29, func_38(l_41, func_42(g_33, (l_45 < func_46(func_51(l_53), l_80, g_33, g_5)))), g_33) ^ g_5)) & l_80.f6));
    g_287 = l_80;
    return g_287.f6;
}


/* ------------------------------------------ */
/* 
 * reads : g_33 g_94
 * writes: g_33 g_287
 */
static int16_t  func_30(uint16_t  p_31, uint16_t  p_32)
{ /* block id: 170 */
    for (g_33 = (-11); (g_33 > 48); g_33 += 1)
    { /* block id: 173 */
        g_287 = g_94;
        return p_31;
    }
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads : g_94.f3 g_94 g_33 g_5 g_204 g_287.f2
 * writes: g_94 g_204 g_287
 */
static uint16_t  func_34(int16_t  p_35, struct S0  p_36, int32_t  p_37)
{ /* block id: 90 */
    int32_t l_170 = 5;
    int32_t l_176 = 1;
    struct S0 l_177 = {0x946F77F4,1,0x537B0903,1,4294967292U,7,0x93C7,-5057,9U};
    int32_t l_199 = 4;
    int32_t l_213 = 0x8925AE96;
    if (func_46(func_38((((uint32_t)(((l_170 | (((int16_t)((0xFF3C < (((p_36.f6 < ((uint16_t)65532U - (uint16_t)(!((((((-1) > 0xF6C7) >= ((65535U <= p_36.f0) | l_170)) < l_170) | l_170) && l_170)))) | p_37) < l_170)) | l_170) - (int16_t)g_94.f3) > 0x514E)) ^ 0U) <= p_36.f7) + (uint32_t)l_170) != l_176), p_36), l_177, l_176, g_33))
    { /* block id: 91 */
        p_36.f7 = p_36.f8;
    }
    else
    { /* block id: 93 */
        int32_t l_178 = (-6);
        struct S0 l_180 = {0xB260FA43,-2,1U,0x600962F2,4294967295U,1,0x3005,959,0xB7FE};
        int32_t l_219 = 0x77AC5F61;
        uint16_t l_266 = 65532U;
        int32_t l_285 = 0x91FC1BEB;
        l_178 = (-5);
        if ((~0x4EFE0625))
        { /* block id: 95 */
            int16_t l_198 = 0x163C;
            uint32_t l_200 = 5U;
            int32_t l_209 = 0;
            int32_t l_210 = (-1);
            uint32_t l_214 = 0U;
            l_180 = func_51(l_177.f5);
            if (((((-2) && p_36.f7) >= 0) ^ func_46(g_94, p_36, p_36.f3, g_94.f8)))
            { /* block id: 97 */
                uint32_t l_196 = 0x41802645;
                uint32_t l_197 = 0U;
                l_200 = ((((-(int32_t)(((uint16_t)0xBD84 >> (uint16_t)((int32_t)(l_177.f8 == (((uint32_t)(func_64(l_180.f1, p_36.f2, ((uint16_t)(g_94.f5 <= p_36.f0) >> (uint16_t)((int16_t)((((int32_t)p_36.f5 - (int32_t)(func_64(l_196, (l_197 <= l_180.f0), l_198, p_36.f8) & 0xDC8FD093)) > g_94.f7) | 0x3D24E930) >> (int16_t)g_94.f7)), l_199) <= l_198) - (uint32_t)0x0E2737E1) != l_177.f6)) - (int32_t)l_198)) ^ p_36.f2)) & p_37) < 5) != l_196);
                if (l_177.f5)
                { /* block id: 99 */
                    if (g_5)
                    { /* block id: 100 */
                        uint16_t l_201 = 1U;
                        l_210 = (l_201 != (4294967292U || (l_198 | (((g_204 | g_204) <= (((uint32_t)(func_46(func_51(p_36.f1), l_180, ((int16_t)l_180.f3 << (int16_t)12), l_209) & p_36.f4) - (uint32_t)0x8D71842A) == 0xB6F5)) < g_5))));
                    }
                    else
                    { /* block id: 102 */
                        return p_36.f1;
                    }
                    l_213 = ((l_197 == 0xD79F) > (__builtin_clzll((((int16_t)p_36.f8 << (int16_t)p_36.f7) > __builtin_ia32_crc32qi(g_204, p_36.f8))) || l_177.f3));
                }
                else
                { /* block id: 106 */
                    l_214 = l_197;
                }
            }
            else
            { /* block id: 109 */
                for (p_36.f0 = (-10); (p_36.f0 >= 3); p_36.f0 += 1)
                { /* block id: 112 */
                    return g_33;
                }
            }
        }
        else
        { /* block id: 116 */
            int32_t l_238 = (-4);
            int16_t l_277 = (-1);
            for (g_204 = (-12); (g_204 != 17); g_204 += 1)
            { /* block id: 119 */
                uint32_t l_233 = 0xF24C6D4E;
                struct S0 l_268 = {1U,-7,0U,0x722876F9,0U,8,65535U,-1745,0xDB49};
                int32_t l_286 = 4;
                g_94.f5 = 0x28862E0C;
                p_37 = ((p_36.f6 && g_33) && l_219);
                for (p_36.f4 = 0; (p_36.f4 >= 35); p_36.f4 += 7)
                { /* block id: 124 */
                    struct S0 l_237 = {0U,-10,0x0FA6E5D1,0xB0926F43,0x218535F4,12,0x52EE,-3273,0xBC2D};
                    l_180.f7 = 0xCFF9A101;
                    if (((uint16_t)0U >> (uint16_t)((int32_t)l_180.f3 % (int32_t)((uint16_t)func_95(g_94.f2, g_33, (((int16_t)(~3U) - (int16_t)(((uint16_t)l_233 << (uint16_t)1) > 0)) < p_36.f1)) >> (uint16_t)g_94.f1))))
                    { /* block id: 126 */
                        struct S0 l_236 = {0xA52184DD,1,2U,-10,4294967295U,4,65527U,-895,9U};
                        p_36.f7 = g_94.f7;
                        p_36.f7 = ((uint16_t)0U << (uint16_t)10);
                        l_237 = l_236;
                        p_36.f5 = (l_233 >= ((((l_238 & ((uint16_t)(-(int16_t)((((((uint16_t)l_236.f4 + (uint16_t)(g_94.f7 > p_36.f1)) <= ((((int32_t)g_94.f8 + (int32_t)(!(((l_233 > (l_236.f2 || l_233)) <= 0x8434) != l_177.f1))) == 0U) & p_36.f5)) > g_94.f0) == g_204) | p_36.f6)) * (uint16_t)0)) < 0x72DE) && g_94.f6) | 0x9794D5BF));
                    }
                    else
                    { /* block id: 131 */
                        l_237.f7 = (((g_94.f4 >= (!__builtin_ffsl(l_233))) | (!((uint16_t)g_94.f6 % (uint16_t)l_180.f3))) && ((int32_t)g_94.f6 % (int32_t)g_94.f3));
                        if (g_94.f4)
                            break;
                        p_37 = (g_5 || 1U);
                    }
                    if ((((((((uint16_t)(((!((((__builtin_ffs(((int16_t)(((int16_t)(0U & g_33) << (int16_t)(((-8) == ((int32_t)(l_237.f8 ^ (__builtin_ffsll(((uint16_t)l_219 >> (uint16_t)15)) < g_94.f1)) - (int32_t)((int16_t)(l_237.f3 <= 0xE9DA6D73) << (int16_t)g_94.f3))) | 1U)) | p_36.f5) << (int16_t)7)) && p_36.f0) | g_94.f0) && 1) >= p_36.f3)) | l_233) <= p_36.f2) << (uint16_t)2) & 0xD8CBC5EB) != g_33) && 0) >= 65526U) && 65531U))
                    { /* block id: 136 */
                        int32_t l_267 = 0;
                        p_36.f5 = ((((((0x54C5F1AE > (65532U <= g_94.f5)) != ((func_64(g_94.f5, p_36.f1, l_266, l_266) != p_36.f1) == 1U)) == 0xD481) <= l_267) || g_94.f7) <= g_33);
                        l_268 = func_51(__builtin_ffsll(p_36.f8));
                        l_268 = p_36;
                        g_94 = p_36;
                    }
                    else
                    { /* block id: 141 */
                        g_94.f5 = 0x354CBC2A;
                        g_94.f7 = (-9);
                    }
                    l_237.f5 = (g_94.f8 == (1 != ((uint32_t)func_64((((int16_t)((uint16_t)((uint16_t)l_277 >> (uint16_t)9) + (uint16_t)((uint16_t)((g_94.f5 && (((g_33 != (-(uint16_t)p_36.f6)) != __builtin_bswap64(((int16_t)((int16_t)g_94.f6 << (int16_t)((l_268.f3 ^ (p_36.f0 > g_5)) <= l_277)) + (int16_t)(-5)))) && p_36.f8)) > l_237.f1) << (uint16_t)15)) + (int16_t)p_36.f2) & p_36.f0), l_285, p_36.f2, l_286) % (uint32_t)0xFDB875EC)));
                }
                l_180.f7 = g_94.f7;
            }
            g_287 = func_38(p_36.f2, g_94);
            g_287 = func_38(__builtin_ctz(p_36.f8), p_36);
            p_36 = l_180;
        }
        for (g_94.f1 = (-10); (g_94.f1 == (-1)); g_94.f1 += 1)
        { /* block id: 155 */
            uint32_t l_290 = 0xD78261AB;
            l_290 = 0xD8716988;
            return g_204;
        }
    }
    l_177.f7 = 0x040179BD;
    p_36.f5 = g_287.f2;
    for (g_94.f1 = 0; (g_94.f1 >= 27); g_94.f1 += 1)
    { /* block id: 164 */
        p_37 = l_170;
        l_177 = p_36;
        return l_177.f4;
    }
    return l_177.f8;
}


/* ------------------------------------------ */
/* 
 * reads : g_94 g_33 g_5
 * writes: g_94
 */
static struct S0  func_38(uint32_t  p_39, struct S0  p_40)
{ /* block id: 78 */
    int16_t l_162 = 0x844E;
    int32_t l_163 = 0;
    struct S0 l_167 = {0xE17F8277,-9,0xBA113A25,0x8FA3BE20,0xCE9429D6,-0,0xB9B3,-3076,65532U};
    p_40 = func_42(l_162, (l_163 | 1U));
    for (l_162 = (-1); (l_162 > (-6)); l_162 -= 1)
    { /* block id: 82 */
        uint32_t l_166 = 3U;
        p_40 = p_40;
        l_163 = (l_163 == l_166);
        return p_40;
    }
    p_40 = p_40;
    g_94 = func_51(g_33);
    return l_167;
}


/* ------------------------------------------ */
/* 
 * reads : g_94
 * writes:
 */
static struct S0  func_42(uint32_t  p_43, int16_t  p_44)
{ /* block id: 75 */
    int32_t l_160 = (-1);
    int32_t l_161 = 0x6A2F9622;
    l_161 = l_160;
    return g_94;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_94 g_33
 * writes: g_94.f5 g_94
 */
static uint32_t  func_46(struct S0  p_47, struct S0  p_48, int16_t  p_49, uint32_t  p_50)
{ /* block id: 43 */
    int16_t l_83 = (-1);
    int32_t l_126 = 0x2DDD9115;
    int32_t l_150 = 0x0C1D3726;
    int16_t l_158 = (-6);
    uint32_t l_159 = 4294967295U;
    if ((((int32_t)__builtin_popcountll(func_64(l_83, l_83, g_5, p_48.f1)) - (int32_t)((uint16_t)((uint16_t)0x71CF << (uint16_t)3) >> (uint16_t)func_64((func_88((p_48.f8 == 1), g_94, p_49, l_83, g_5) | g_33), g_33, g_33, p_48.f2))) >= g_5))
    { /* block id: 51 */
        int16_t l_131 = 9;
        int32_t l_141 = (-5);
        l_126 = g_94.f4;
        if (((uint32_t)(((int16_t)1 << (int16_t)p_47.f3) <= l_131) % (uint32_t)__builtin_ctzll(func_64((((int32_t)p_48.f1 - (int32_t)p_48.f2) == 4294967293U), l_126, ((((int16_t)((uint32_t)(((p_47.f2 || ((uint32_t)(((((~(p_47.f5 & 0)) && 0U) ^ g_94.f3) < p_47.f5) <= 0x64CF) + (uint32_t)l_131)) & p_47.f2) >= g_94.f6) + (uint32_t)l_131) << (int16_t)7) | g_94.f0) ^ g_94.f3), l_131))))
        { /* block id: 53 */
            l_141 = __builtin_popcountll(p_48.f5);
            p_47 = func_51(p_47.f8);
        }
        else
        { /* block id: 56 */
            uint32_t l_144 = 4U;
            for (l_83 = 0; (l_83 == 0); l_83 += 1)
            { /* block id: 59 */
                g_94 = p_48;
                p_47 = func_51(l_144);
            }
        }
    }
    else
    { /* block id: 64 */
        uint16_t l_149 = 0U;
        p_47.f7 = ((((uint16_t)((int32_t)(-1) + (int32_t)l_149) >> (uint16_t)4) >= (((l_150 ^ p_47.f4) < ((7U > ((uint16_t)((uint16_t)l_150 + (uint16_t)(g_5 || g_94.f1)) >> (uint16_t)p_47.f6)) < g_94.f5)) > l_149)) | l_83);
    }
    for (l_83 = 0; (l_83 <= (-15)); l_83 -= 1)
    { /* block id: 69 */
        uint16_t l_157 = 0xDA53;
        g_94.f5 = p_49;
        l_157 = (p_48.f8 ^ (p_48.f4 < l_126));
        p_47.f5 = func_88(p_48.f0, p_47, (65526U || (((((0xBCEAF5C8 <= l_157) > p_48.f6) | l_158) >= l_159) < __builtin_ctz(g_94.f4))), p_48.f2, l_157);
    }
    return g_94.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes:
 */
static struct S0  func_51(uint16_t  p_52)
{ /* block id: 37 */
    int32_t l_63 = 0x72ABF771;
    struct S0 l_79 = {0x79E2962D,-7,0x53F47794,0xD42BE3C6,0U,0,65535U,6687,0x3A9B};
    l_63 = ((uint16_t)((int32_t)p_52 % (int32_t)((int16_t)((((uint16_t)(-(int16_t)6) % (uint16_t)0x2835) ^ l_63) < (func_64(((uint32_t)((int32_t)p_52 % (int32_t)((int16_t)(l_63 | l_63) + (int16_t)p_52)) % (uint32_t)((int16_t)(((((g_5 | l_63) < p_52) >= 0x1D39) && 0xBC07) != g_5) << (int16_t)2)), p_52, g_5, g_5) <= 0xDD5A)) - (int16_t)l_63)) >> (uint16_t)1);
    return l_79;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_64(int16_t  p_65, uint16_t  p_66, uint16_t  p_67, uint32_t  p_68)
{ /* block id: 38 */
    uint32_t l_77 = 4294967289U;
    int32_t l_78 = 0x2BB76079;
    l_78 = l_77;
    return l_77;
}


/* ------------------------------------------ */
/* 
 * reads : g_94.f5 g_94.f0 g_5 g_94.f6 g_94.f8 g_94
 * writes: g_94.f5 g_94
 */
static int16_t  func_88(int32_t  p_89, struct S0  p_90, int32_t  p_91, int16_t  p_92, uint32_t  p_93)
{ /* block id: 44 */
    int32_t l_101 = 0x28131091;
    int32_t l_112 = 0x42F441AF;
    uint32_t l_113 = 0x38EE533B;
    int32_t l_125 = 0x9CFF1310;
    g_94.f5 = func_95(((g_94.f5 ^ ((__builtin_parityl((((0xEB87 != ((__builtin_ffs(l_101) > ((((int32_t)l_101 + (int32_t)((((int16_t)__builtin_popcount(l_101) >> (int16_t)7) ^ ((uint16_t)((uint16_t)((uint32_t)(0xF147 && ((g_94.f0 > 65529U) <= p_91)) % (uint32_t)p_89) >> (uint16_t)p_90.f2) << (uint16_t)p_90.f6)) ^ 9)) > l_112) & 4294967292U)) < 0U)) ^ g_5) || l_101)) && p_90.f2) ^ 0x6C63)) == 0x74C4), l_113, g_94.f6);
    g_94 = g_94;
    g_94 = func_51(((int16_t)(((uint16_t)((uint16_t)p_93 - (uint16_t)func_95(g_94.f4, l_112, ((l_113 == ((uint32_t)p_93 % (uint32_t)((g_94.f1 < (g_94.f8 <= ((int16_t)l_101 << (int16_t)8))) | (((~(p_91 < g_94.f2)) | l_125) != l_113)))) == p_90.f0))) + (uint16_t)65526U) == 0x19732EC2) % (int16_t)l_113));
    return l_125;
}


/* ------------------------------------------ */
/* 
 * reads : g_94.f8
 * writes:
 */
static int32_t  func_95(uint32_t  p_96, uint32_t  p_97, int32_t  p_98)
{ /* block id: 45 */
    return g_94.f8;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_94.f0, "g_94.f0", print_hash_value);
    transparent_crc(g_94.f1, "g_94.f1", print_hash_value);
    transparent_crc(g_94.f2, "g_94.f2", print_hash_value);
    transparent_crc(g_94.f3, "g_94.f3", print_hash_value);
    transparent_crc(g_94.f4, "g_94.f4", print_hash_value);
    transparent_crc(g_94.f5, "g_94.f5", print_hash_value);
    transparent_crc(g_94.f6, "g_94.f6", print_hash_value);
    transparent_crc(g_94.f7, "g_94.f7", print_hash_value);
    transparent_crc(g_94.f8, "g_94.f8", print_hash_value);
    transparent_crc(g_204, "g_204", print_hash_value);
    transparent_crc(g_287.f0, "g_287.f0", print_hash_value);
    transparent_crc(g_287.f1, "g_287.f1", print_hash_value);
    transparent_crc(g_287.f2, "g_287.f2", print_hash_value);
    transparent_crc(g_287.f3, "g_287.f3", print_hash_value);
    transparent_crc(g_287.f4, "g_287.f4", print_hash_value);
    transparent_crc(g_287.f5, "g_287.f5", print_hash_value);
    transparent_crc(g_287.f6, "g_287.f6", print_hash_value);
    transparent_crc(g_287.f7, "g_287.f7", print_hash_value);
    transparent_crc(g_287.f8, "g_287.f8", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 56
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 10
breakdown:
   indirect level: 0, occurrence: 10
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 20
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 19
XXX times a single bitfield on RHS: 23

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 17
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 27, occurrence: 3
   depth: 28, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 319
XXX times a non-volatile is write: 64
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 90
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 18
   depth: 2, occurrence: 11
   depth: 3, occurrence: 9
   depth: 4, occurrence: 8
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

