/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      439834676
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_27(void);
inline static uint64_t  func_29(int32_t  p_30, int64_t  p_31, uint32_t  p_32, int32_t  p_33, float  p_34);
inline static int16_t  func_35(int16_t  p_36, int64_t  p_37);
static int32_t * func_39(int32_t * p_40);
inline static int32_t * const  func_46(uint32_t  p_47, int32_t * p_48, uint64_t  p_49, int64_t  p_50, int32_t  p_51);
static uint32_t  func_52(uint32_t  p_53);
inline static int32_t * func_55(uint8_t  p_56, int16_t  p_57, int32_t  p_58, const int32_t * p_59, uint32_t  p_60);
static float  func_68(int32_t * p_69);
static int32_t * func_70(int32_t * p_71, int32_t  p_72, int32_t * p_73, int32_t * p_74, int32_t * p_75);
static int32_t * func_79(int32_t * p_80, int32_t * p_81, uint64_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_27(void)
{ /* block id: 36 */
    int16_t l_28 = 0x5681L;
    int32_t l_363 = 0xBC64D5B5L;
    float l_372 = 0x5.1937CEp-49;
    float *l_371 = &l_372;
    const int32_t ***l_385 = (void*)0;
    const int32_t ****l_384 = &l_385;
    const int32_t *****l_383 = &l_384;
    if ((((((l_28 == func_29(l_28, (func_35(l_28, __builtin_popcountl(l_28)) < (l_28 != (l_28 ^ ((-4L) <= 0x5EB9F0F1L)))), l_28, l_363, l_363)) || l_363) > l_28) ^ l_363) && (-1L)))
    { /* block id: 255 */
        int32_t l_366 = 0L;
        int32_t * const l_365 = &l_366;
        const int32_t *l_368 = &l_366;
        const int32_t **l_367 = &l_368;
        uint16_t l_369 = 0x0BEDL;
        float *l_373 = &l_372;
        int16_t l_374 = 0L;
lbl_375:
        (*l_367) = l_365;
        /* statement id: 256 */
        assert (l_368 == &l_366);
        (*l_367) = func_55(l_363, (*l_365), (((l_369 & (**l_367)) >= (-(uint64_t)l_28)) != func_29(l_28, ((*l_367) == (*l_367)), ((l_371 == l_373) && l_363), (*l_368), l_374)), (*l_367), (**l_367));
        /* statement id: 257 */
        assert (l_368 == 0);
        (*l_365) = (l_28 && l_363);
        if (l_369)
            goto lbl_375;
    }
    else
    { /* block id: 260 */
        float *l_378 = &l_372;
        int32_t l_379 = 0x00F45F9FL;
        for (l_28 = 0; (l_28 >= (-29)); l_28 -= 1)
        { /* block id: 263 */
            int32_t *****l_382 = (void*)0;
            uint8_t l_396 = 0xCEL;
            l_379 = (l_378 == (void*)0);
            for (l_379 = (-26); (l_379 > (-26)); ++l_379)
            { /* block id: 267 */
                int32_t *l_386 = &l_379;
                uint32_t l_389 = 4UL;
                int32_t *l_390 = &l_379;
                int32_t **l_391 = &l_390;
                (*l_391) = l_390;
                for (l_363 = 6; (l_363 != (-10)); --l_363)
                { /* block id: 271 */
                    int32_t **l_394 = (void*)0;
                    int32_t ***l_395 = &l_391;
                }
            }
            (*l_378) = (0xA.C82A2Ep-7 != l_396);
        }
    }
    (*l_371) = l_28;
    return l_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_29(int32_t  p_30, int64_t  p_31, uint32_t  p_32, int32_t  p_33, float  p_34)
{ /* block id: 253 */
    uint16_t l_364 = 0x91A3L;
    return l_364;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_35(int16_t  p_36, int64_t  p_37)
{ /* block id: 37 */
    uint64_t l_38 = 9UL;
    int32_t l_357 = 0xEF0EF6DEL;
    if (l_38)
    { /* block id: 38 */
        int32_t l_42 = 1L;
        int32_t *l_41 = &l_42;
        l_41 = func_39(l_41);
        /* statement id: 235 */
        assert (l_41 == 0);
    }
    else
    { /* block id: 236 */
        int32_t l_356 = 0xE48052E4L;
        int32_t *l_355 = &l_356;
        int32_t **l_354 = &l_355;
        l_357 = (0x37B2DE80L || (l_38 != ((int16_t)(l_354 != &l_355) >> (int16_t)10)));
        for (l_356 = 0; (l_356 > 5); l_356 += 5)
        { /* block id: 240 */
            int32_t *l_362 = &l_356;
            for (l_357 = 0; (l_357 == 9); ++l_357)
            { /* block id: 243 */
                (*l_354) = l_362;
                /* statement id: 244 */
                assert (l_355 == &l_356);
            }
            (*l_354) = (void*)0;
            /* statement id: 246 */
            assert (l_355 == 0);
            l_362 = (*l_354);
            /* statement id: 247 */
            assert (l_362 == 0);
            (*l_354) = &l_357;
            /* statement id: 248 */
            assert (l_355 == &l_357);
        }
        /* facts after for loop */
        assert (l_355 == &l_357 || l_355 == &l_356);
        return l_38;
    }
    return l_357;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_39(int32_t * p_40)
{ /* block id: 39 */
    int32_t l_43 = 1L;
    int32_t **l_224 = (void*)0;
    int32_t ***l_223 = &l_224;
    int64_t l_227 = 1L;
    uint32_t l_240 = 0x26E06BE9L;
    uint64_t l_259 = 1UL;
    const float l_273 = (-0x9.Fp-1);
    uint8_t l_292 = 246UL;
    uint64_t l_313 = 0xA0A5ABD8B400A94ALL;
    int32_t *l_315 = &l_43;
    int32_t *l_339 = &l_43;
    uint64_t l_344 = 0UL;
    int32_t *l_347 = &l_43;
    int32_t *l_348 = &l_43;
    int32_t *l_349 = &l_43;
    int32_t *l_350 = &l_43;
    int32_t *l_351 = (void*)0;
    for (l_43 = 0; (l_43 < (-27)); l_43--)
    { /* block id: 42 */
        int32_t l_54 = 0xDD2E91C8L;
        uint16_t l_219 = 0x6255L;
        int32_t ***l_222 = (void*)0;
        int32_t *l_239 = &l_43;
        int32_t **l_238 = &l_239;
        (*l_238) = func_46(func_52(l_54), p_40, l_219, ((int32_t)(l_222 != l_223) - (int32_t)(*p_40)), (l_219 != ((uint16_t)(&p_40 != (void*)0) << (uint16_t)l_227)));
        /* statement id: 171 */
        assert (l_239 == 0);
        (*l_238) = p_40;
        /* statement id: 172 */
        //assert (l_239 == &l_42);
    }
    if (func_52(l_240))
    { /* block id: 174 */
        int32_t *l_242 = &l_43;
        int32_t **l_241 = &l_242;
        (*l_241) = p_40;
        /* statement id: 175 */
        //assert (l_242 == &l_42);
        for (l_43 = 20; (l_43 == (-18)); l_43 -= 3)
        { /* block id: 178 */
            int16_t l_245 = 0xA4D6L;
            int32_t ** const **l_249 = (void*)0;
            int32_t ** const ***l_248 = &l_249;
            (*p_40) = (l_245 ^ ((0x5BE66359415C7811LL <= ((uint16_t)0x3112L << (uint16_t)((void*)0 != l_248))) | 0x07D3DD64F9C2C93FLL));
            (*l_241) = p_40;
        }
        (*p_40) = (*p_40);
        for (l_227 = 19; (l_227 >= (-16)); l_227 -= 1)
        { /* block id: 185 */
            float l_260 = 0x9.191B56p-44;
            for (l_240 = 0; (l_240 < 43); l_240++)
            { /* block id: 188 */
                int64_t l_256 = (-1L);
                if ((*p_40))
                    break;
                (*p_40) = (((p_40 == (void*)0) >= (**l_241)) && (((((uint16_t)l_256 << (uint16_t)4) < (*p_40)) || ((int16_t)(l_259 && 3UL) << (int16_t)(*l_242))) != ((int32_t)0L - (int32_t)(**l_241))));
            }
        }
    }
    else
    { /* block id: 193 */
        float l_263 = 0x9.6299EDp+46;
        uint32_t l_264 = 0UL;
        const int32_t *l_265 = &l_43;
        uint32_t l_314 = 9UL;
        int32_t *l_317 = &l_43;
        p_40 = func_55(func_52((&p_40 != &p_40)), __builtin_ffs((l_264 || (0xE28CL ^ (func_52((0x9AB7E0C7B68BE60ALL >= l_264)) | (*p_40))))), (*p_40), l_265, (*l_265));
        /* statement id: 194 */
        assert (p_40 == 0);
        if (((int64_t)(*l_265) + (int64_t)(0xBE89911EL != ((uint16_t)__builtin_parityl((((uint16_t)(*l_265) >> (uint16_t)11) <= 0xC865190E703EE88BLL)) / (uint16_t)(~(*l_265))))))
        { /* block id: 195 */
            uint32_t l_275 = 0x6403DF32L;
            float *l_276 = &l_263;
            (*l_276) = (-(float)l_275);
        }
        else
        { /* block id: 197 */
            uint32_t l_283 = 1UL;
            int32_t *l_290 = &l_43;
            int16_t l_312 = 2L;
            if ((((0x818204FBL <= ((*l_265) < ((int32_t)((int16_t)(((uint16_t)(l_283 <= __builtin_ctz(((((l_283 && __builtin_clz(l_283)) > (*l_265)) >= (*l_265)) > ((uint64_t)(((((int16_t)(func_52((1L > (*l_265))) == l_283) << (int16_t)(*l_265)) != 0x6D7AE1D0L) | (*l_265)) == 4L) + (uint64_t)(*l_265))))) - (uint16_t)l_283) == l_283) << (int16_t)11) % (int32_t)0x22433CC3L))) <= 0x4E2FFC6FEF38C781LL) | 0xEEF5A3A1L))
            { /* block id: 198 */
                float *l_288 = (void*)0;
                float *l_289 = &l_263;
                (*l_289) = (*l_265);
            }
            else
            { /* block id: 200 */
                const int32_t **l_291 = &l_265;
                int32_t *l_316 = &l_43;
                (*l_291) = l_290;
                if (l_292)
                { /* block id: 202 */
                    int32_t **l_293 = &l_290;
                    l_293 = &p_40;
                    /* statement id: 203 */
                    assert (l_293 == &p_40);
                    if (((int16_t)((uint32_t)(((int32_t)(**l_291) + (int32_t)func_52(((*l_290) > ((uint16_t)((int16_t)0x2841L >> (int16_t)((uint16_t)__builtin_bswap32((*l_290)) >> (uint16_t)__builtin_parityl((*l_265)))) >> (uint16_t)14)))) >= __builtin_ffsl(((int64_t)((int32_t)((int64_t)l_312 + (int64_t)(*l_290)) % (int32_t)l_313) / (int64_t)(*l_290)))) / (uint32_t)l_314) >> (int16_t)13))
                    { /* block id: 204 */
                        int32_t *l_318 = &l_43;
                        return p_40;
                        /* statement id: 205 */
                        //assert (func_39_rv == 0);
                    }
                    else
                    { /* block id: 206 */
                        int32_t *l_319 = &l_43;
                        return p_40;
                        /* statement id: 207 */
                        //assert (func_39_rv == 0);
                    }
                }
                else
                { /* block id: 209 */
                    const uint64_t l_323 = 0UL;
                    for (l_264 = 0; (l_264 >= 52); l_264++)
                    { /* block id: 212 */
                        int32_t **l_322 = &l_316;
                        (*l_223) = l_322;
                        /* statement id: 213 */
                        assert (l_224 == &l_316);
                        if (l_323)
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_224 == &l_316 || l_224 == 0);
                    (*l_317) = 0x1FEC4C8CL;
                }
                /* facts after branching */
                assert (l_224 == &l_316 || l_224 == 0);
                (*l_317) = ((*l_265) > (**l_291));
            }
            /* facts after branching */
            //assert (l_224 == dangling || l_224 == 0);
        }
        /* facts after branching */
        //assert (l_224 == dangling || l_224 == 0);
    }
    /* facts after branching */
    //assert (p_40 == 0 || p_40 == &l_42);
    //assert (l_224 == dangling || l_224 == 0);
    if (((int16_t)(((uint16_t)(*l_315) >> (uint16_t)11) > (*l_315)) / (int16_t)((uint64_t)0x7C03A1E7A8C1E0F0LL + (uint64_t)(*l_315))))
    { /* block id: 222 */
        int16_t l_332 = 0x31D1L;
        float l_334 = 0x8.3p-1;
        float *l_333 = &l_334;
        (*l_333) = (((float)l_332 + (float)l_332) >= l_332);
    }
    else
    { /* block id: 224 */
        int32_t ****l_336 = (void*)0;
        int32_t *****l_335 = &l_336;
        p_40 = &l_43;
        /* statement id: 225 */
        assert (p_40 == &l_43);
        l_335 = l_335;
        for (l_227 = 0; (l_227 > 3); ++l_227)
        { /* block id: 229 */
            p_40 = func_79(p_40, l_339, (*l_339));
        }
    }
    /* facts after branching */
    //assert (p_40 == &l_43 || p_40 == 0 || p_40 == &l_42);
    (*l_315) = (((int16_t)(*l_339) + (int16_t)((uint16_t)__builtin_parityll((*l_315)) >> (uint16_t)l_344)) >= ((uint16_t)__builtin_ia32_crc32qi((&l_223 != &l_223), (&l_224 != &l_224)) % (uint16_t)(*l_315)));
    return l_351;
    /* statement id: 234 */
    //assert (func_39_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_42
 * writes: l_42
 */
inline static int32_t * const  func_46(uint32_t  p_47, int32_t * p_48, uint64_t  p_49, int64_t  p_50, int32_t  p_51)
{ /* block id: 168 */
    uint8_t l_231 = 0x18L;
    int32_t l_234 = 0xBE6BB753L;
    int32_t l_236 = 1L;
    int32_t * const l_235 = &l_236;
    int32_t * const l_237 = (void*)0;
    (*p_48) = ((*p_48) | ((int16_t)(-(uint16_t)(__builtin_bswap32(l_231) ^ (((l_231 <= ((int16_t)(p_49 != l_231) << (int16_t)4)) | p_51) | ((l_231 != func_52(l_234)) | p_51)))) - (int16_t)l_234));
    return l_237;
    /* statement id: 170 */
    //assert (func_46_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_52(uint32_t  p_53)
{ /* block id: 43 */
    int64_t l_61 = 0x99643747C914A3A6LL;
    const int32_t l_63 = 0xB05EF135L;
    const int32_t *l_62 = &l_63;
    int32_t l_218 = 3L;
    int32_t *l_217 = &l_218;
    int32_t **l_216 = &l_217;
    (*l_216) = func_55(p_53, l_61, p_53, l_62, (*l_62));
    /* statement id: 166 */
    assert (l_217 == 0);
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_55(uint8_t  p_56, int16_t  p_57, int32_t  p_58, const int32_t * p_59, uint32_t  p_60)
{ /* block id: 44 */
    int32_t l_77 = 0x079D62BFL;
    int32_t *l_76 = &l_77;
    int64_t l_177 = (-1L);
    uint32_t l_197 = 0x5D680402L;
    int32_t *l_214 = &l_77;
    int32_t *l_215 = (void*)0;
    return l_215;
    /* statement id: 165 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_68(int32_t * p_69)
{ /* block id: 120 */
    uint64_t l_166 = 18446744073709551615UL;
    int32_t l_168 = 9L;
    int32_t *l_167 = &l_168;
    l_167 = func_70(p_69, ((+l_166) & 0xE6C1E6BCL), l_167, p_69, p_69);
    /* statement id: 121 */
    //assert (l_167 == &l_77);
    (*l_167) = ((*l_167) || ((uint32_t)(*l_167) / (uint32_t)((int16_t)(1L != (*p_69)) >> (int16_t)12)));
    return (*l_167);
}


/* ------------------------------------------ */
/* 
 * reads : l_77
 * writes: l_77
 */
static int32_t * func_70(int32_t * p_71, int32_t  p_72, int32_t * p_73, int32_t * p_74, int32_t * p_75)
{ /* block id: 51 */
    float l_92 = 0x7.DF6F6Dp+2;
    const int32_t l_99 = 0xF3A6825DL;
    int32_t l_106 = 0L;
    int32_t *l_105 = &l_106;
    const int32_t *l_108 = &l_106;
    int32_t *** const ** const l_159 = (void*)0;
    int32_t **l_163 = &l_105;
    int32_t ***l_162 = &l_163;
    int32_t *** const *l_161 = &l_162;
    int32_t *** const **l_160 = &l_161;
    int32_t *l_164 = &l_106;
    if (((int32_t)((uint64_t)p_72 - (uint64_t)p_72) / (int32_t)((int32_t)((int16_t)0x2248L + (int16_t)((uint64_t)(l_99 && l_99) / (uint64_t)p_72)) - (int32_t)__builtin_parityll(l_99))))
    { /* block id: 52 */
        int32_t l_103 = 3L;
        int32_t *l_102 = &l_103;
        for (p_72 = 0; (p_72 >= (-28)); p_72--)
        { /* block id: 55 */
            int32_t **l_104 = &l_102;
            (*l_104) = l_102;
        }
    }
    else
    { /* block id: 58 */
        int32_t **l_107 = &l_105;
        (*p_75) = (*p_74);
        (*l_107) = func_79(p_75, l_105, p_72);
    }
    if ((p_72 | p_72))
    { /* block id: 62 */
        l_108 = &l_99;
        /* statement id: 63 */
        assert (l_108 == &l_99);
    }
    else
    { /* block id: 64 */
        int32_t *l_109 = &l_106;
        int16_t l_117 = 8L;
        int32_t **l_118 = &l_109;
    }
    /* facts after branching */
    assert (l_108 == &l_106 || l_108 == &l_99);
    l_160 = l_159;
    /* statement id: 117 */
    assert (l_160 == 0);
    (***l_161) = func_79(func_79(p_73, p_73, (&p_73 != &p_75)), l_164, p_72);
    return p_75;
    /* statement id: 119 */
    //assert (func_70_rv == &l_77);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_77 l_168
 */
static int32_t * func_79(int32_t * p_80, int32_t * p_81, uint64_t  p_82)
{ /* block id: 48 */
    uint32_t l_85 = 0x05C8A2DBL;
    int32_t l_87 = 0L;
    int32_t *l_86 = &l_87;
    (*p_80) = (((int16_t)p_82 >> (int16_t)13) || ((l_85 == 1UL) ^ l_85));
    return p_81;
    /* statement id: 50 */
    //assert (func_79_rv == &l_77 || func_79_rv == &l_106 || func_79_rv == &l_168 || func_79_rv == &l_43);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 109
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 109

XXX times a variable address is taken: 102
XXX times a pointer is dereferenced on RHS: 82
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 55
breakdown:
   depth: 1, occurrence: 53
   depth: 2, occurrence: 1
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 310

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 170
   level: 2, occurrence: 25
   level: 3, occurrence: 26
   level: 4, occurrence: 5
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 68
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 28.4
XXX average alias set size: 1.27

XXX times a non-volatile is read: 439
XXX times a non-volatile is write: 156
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 82
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 25
   depth: 2, occurrence: 14
   depth: 3, occurrence: 9
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
********************* end of statistics **********************/

