/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      792180888
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   unsigned f1 : 7;
   const unsigned f2 : 13;
   const signed f3 : 5;
   unsigned : 0;
};

union U1 {
   int32_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_31(void);
inline static int16_t  func_34(int16_t  p_35, union U1  p_36);
inline static uint32_t  func_38(struct S0  p_39, int16_t  p_40, uint32_t  p_41, union U1  p_42, uint32_t  p_43);
inline static uint16_t  func_51(union U1  p_52);
static int32_t  func_84(int32_t ** p_85, uint32_t  p_86);
inline static float  func_87(const int16_t  p_88, int32_t * p_89, uint32_t  p_90);
static int16_t  func_95(int32_t ** p_96);
inline static uint16_t  func_100(int32_t  p_101, int32_t  p_102);
static uint16_t  func_113(uint32_t  p_114);
static union U1 * func_121(int32_t ** p_122, union U1 * p_123, float  p_124, int32_t ** p_125, union U1  p_126);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_31(void)
{ /* block id: 36 */
    float l_32 = 0x5.936BE8p-54;
    int32_t l_33 = 0xA5308633;
    struct S0 l_44 = {0xC2E3A4C6,9,26,2};
    union U1 l_53 = {0x5BB5FB49};
    if ((9U == (l_33 == func_34((~(l_33 ^ (0U != func_38(l_44, ((uint16_t)((int32_t)(0xE7EB < (0x285F ^ __builtin_clzl((((int32_t)l_44.f1 - (int32_t)(func_51(l_53) & l_53.f0)) && l_33)))) + (int32_t)l_44.f2) << (uint16_t)5), l_44.f1, l_53, l_44.f3)))), l_53))))
    { /* block id: 671 */
        int32_t *l_990 = &l_33;
        const int32_t *l_992 = (void*)0;
        const int32_t **l_991 = &l_992;
        float *l_995 = &l_32;
        (*l_991) = l_990;
        /* statement id: 672 */
        assert (l_992 == &l_33);
        (*l_995) = ((float)l_53.f0 - (float)l_53.f0);
    }
    else
    { /* block id: 674 */
        struct S0 l_996 = {0x63DFC9E2,9,10,-4};
        return l_996;
    }
    for (l_53.f0 = (-17); (l_53.f0 != 11); l_53.f0 += 7)
    { /* block id: 679 */
        return l_44;
    }
    return l_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_34(int16_t  p_35, union U1  p_36)
{ /* block id: 541 */
    struct S0 **l_813 = (void*)0;
    struct S0 ***l_812 = &l_813;
    int32_t l_819 = 0x4E59B238;
    struct S0 *l_848 = (void*)0;
    float l_853 = 0x2.904612p-8;
    float *l_852 = &l_853;
    int32_t *l_854 = &l_819;
    struct S0 ****l_873 = &l_812;
    struct S0 *****l_872 = &l_873;
    union U1 l_950 = {0x9FBE6B92};
    union U1 *l_949 = &l_950;
    union U1 **l_948 = &l_949;
    int32_t * const *l_962 = (void*)0;
    int32_t * const **l_961 = &l_962;
    int32_t * const ***l_960 = &l_961;
    int32_t *l_989 = &l_819;
    for (p_36.f1 = (-1); (p_36.f1 < 26); p_36.f1 += 3)
    { /* block id: 544 */
        int32_t l_806 = 1;
        int32_t *l_807 = (void*)0;
        int32_t l_809 = 0xD8EE91EA;
        int32_t *l_808 = &l_809;
        uint16_t l_827 = 0xB603;
        int16_t l_841 = 3;
        struct S0 ****l_851 = &l_812;
        struct S0 *****l_850 = &l_851;
        (*l_808) = l_806;
        for (l_806 = 18; (l_806 < 18); l_806 += 2)
        { /* block id: 548 */
            int32_t l_814 = 0xAEAA0C25;
            int32_t l_815 = 0xFD2CBEBA;
            struct S0 l_826 = {3U,5,67,4};
            l_812 = (void*)0;
            /* statement id: 549 */
            assert (l_812 == 0);
            if (l_814)
                continue;
            l_815 = p_36.f0;
            if ((!p_36.f0))
            { /* block id: 552 */
                float l_818 = 0x0.3p+1;
                float *l_817 = &l_818;
                (*l_817) = p_36.f0;
                if (l_819)
                    break;
                (*l_817) = (((p_36.f1 >= ((float)(((float)(((float)0x5.1p+1 - (float)func_38(l_826, p_36.f0, (*l_808), p_36, l_827)) <= l_819) + (float)p_36.f0) < l_819) + (float)l_826.f2)) <= (-0x1.Dp+1)) != 0x6.C7813Ep+2);
                (*l_817) = 0x3.9EE55Cp+52;
            }
            else
            { /* block id: 557 */
                int32_t *l_828 = &l_819;
                l_828 = &l_819;
                if (l_819)
                    continue;
                return p_36.f1;
            }
        }
        if (p_36.f0)
        { /* block id: 563 */
            uint16_t l_831 = 0x56C0;
            (*l_808) = p_36.f1;
            (*l_808) = p_36.f0;
            (*l_808) = ((int16_t)(l_831 | (l_819 != ((int16_t)((l_819 != ((int32_t)func_51(p_36) - (int32_t)0x0C38ECF0)) < (((int16_t)(p_36.f0 >= (65534U == l_819)) >> (int16_t)14) & l_831)) << (int16_t)2))) >> (int16_t)p_36.f0);
        }
        else
        { /* block id: 567 */
            int32_t *l_840 = &l_809;
            struct S0 *l_849 = (void*)0;
            l_819 = (((float)((((void*)0 == l_840) > l_841) != ((float)((float)((float)0x1.6p-1 + (float)p_36.f0) + (float)(__builtin_clz(p_35) < (*l_840))) - (float)(p_36.f1 != p_36.f0))) - (float)0x7.8p-1) > p_36.f0);
            l_849 = l_848;
        }
        (*l_850) = &l_812;
    }
    /* facts after for loop */
        assert (l_812 == 0 || l_812 == &l_813);
    (*l_854) = (__builtin_ffsl((l_852 == (void*)0)) ^ p_36.f1);
    if ((*l_854))
    { /* block id: 574 */
        uint32_t l_855 = 0x6D18A176;
        (*l_854) = __builtin_ffsll(p_36.f1);
        (*l_854) = 0x864335A4;
        (*l_854) = (6U > (func_100((*l_854), l_855) <= 0x9FC66C6B));
    }
    else
    { /* block id: 578 */
        int32_t * const l_856 = &l_819;
        (*l_854) = ((l_856 != l_856) == (*l_854));
    }
    for (p_35 = 18; (p_35 < 20); ++p_35)
    { /* block id: 583 */
        uint16_t l_861 = 0x5042;
        int32_t **l_864 = (void*)0;
        int32_t ***l_863 = &l_864;
        int32_t *** const *l_862 = &l_863;
        float *l_868 = &l_853;
        struct S0 ****l_871 = &l_812;
        struct S0 **** const *l_870 = &l_871;
        union U1 ***l_892 = (void*)0;
        union U1 ****l_891 = &l_892;
        int32_t l_910 = 0x66737CBA;
        uint16_t l_987 = 0xA475;
        for (p_36.f1 = 0; (p_36.f1 > 7); p_36.f1++)
        { /* block id: 586 */
            (*l_854) = l_861;
        }
        if ((l_862 != (void*)0))
        { /* block id: 589 */
            if (((int16_t)p_36.f0 >> (int16_t)12))
            { /* block id: 590 */
                (*l_854) = (+p_36.f0);
            }
            else
            { /* block id: 592 */
                l_854 = &l_819;
                if ((*l_854))
                    continue;
                if (p_36.f1)
                    continue;
            }
        }
        else
        { /* block id: 597 */
            float *l_869 = &l_853;
            (*l_854) = (l_868 != l_869);
        }
        if ((l_870 == l_872))
        { /* block id: 600 */
            uint16_t l_883 = 0x85A2;
            union U1 *l_885 = (void*)0;
            union U1 **l_884 = &l_885;
            struct S0 ****l_918 = (void*)0;
            struct S0 l_936 = {3U,10,52,2};
            struct S0 *l_935 = &l_936;
            for (l_861 = 0; (l_861 <= 25); ++l_861)
            { /* block id: 603 */
                int32_t *l_888 = (void*)0;
                struct S0 ** const **l_896 = (void*)0;
                const union U1 l_905 = {1};
                const union U1 *l_904 = &l_905;
                const union U1 **l_903 = &l_904;
            }
        }
        else
        { /* block id: 638 */
            union U1 *l_953 = &l_950;
            int32_t ****l_959 = &l_863;
            int32_t l_988 = 0xDFCDC706;
            if ((*l_854))
            { /* block id: 639 */
                uint16_t l_939 = 65535U;
                return l_939;
            }
            else
            { /* block id: 641 */
                int32_t l_954 = 6;
                l_910 = ((int32_t)(((int16_t)0xFE9F - (int16_t)((__builtin_clz(((int16_t)(func_113(((int16_t)(((l_948 != &l_949) < (*l_854)) | p_36.f1) % (int16_t)((*l_854) & ((int16_t)((*l_948) != l_953) >> (int16_t)10)))) || p_35) << (int16_t)0)) & p_35) && p_36.f1)) != 7) % (int32_t)l_954);
                (*l_854) = (((uint16_t)((uint16_t)p_36.f1 >> (uint16_t)(l_959 == l_960)) + (uint16_t)(p_35 && ((p_36.f0 & 0xB3A1) > ((int32_t)(((uint32_t)0U + (uint32_t)p_36.f0) && p_36.f0) - (int32_t)(*l_854))))) ^ p_36.f0);
                for (l_954 = 8; (l_954 < 9); l_954 += 9)
                { /* block id: 646 */
                    int32_t *l_972 = &l_910;
                    for (p_36.f1 = 7; (p_36.f1 > 12); p_36.f1 += 8)
                    { /* block id: 649 */
                        int32_t *l_971 = &l_954;
                        l_972 = l_971;
                        /* statement id: 650 */
                        assert (l_972 == &l_954);
                    }
                    /* facts after for loop */
                    assert (l_972 == &l_954 || l_972 == &l_910);
                    (*l_852) = p_35;
                    for (p_36.f1 = 0; (p_36.f1 <= 9); p_36.f1++)
                    { /* block id: 655 */
                        (*l_868) = ((float)l_954 + (float)((float)(__builtin_bswap64(p_35) != (*l_972)) - (float)p_36.f0));
                    }
                    (*l_868) = p_36.f0;
                }
                for (l_954 = 0; (l_954 <= (-19)); l_954--)
                { /* block id: 662 */
                    if (p_35)
                        break;
                }
            }
            (*l_854) = (((uint16_t)p_36.f0 % (uint16_t)((int32_t)0x8FD535CE % (int32_t)((uint32_t)(l_987 ^ l_988) % (uint32_t)0x1F2B0B24))) != p_36.f1);
            l_989 = &l_910;
            /* statement id: 667 */
            assert (l_989 == &l_910);
        }
        /* facts after branching */
        //assert (l_989 == &l_910 || l_989 == dangling || l_989 == &l_819);
    }
    /* facts after for loop */
    //assert (l_989 == dangling || l_989 == &l_819);
    return p_36.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_38(struct S0  p_39, int16_t  p_40, uint32_t  p_41, union U1  p_42, uint32_t  p_43)
{ /* block id: 536 */
    int32_t l_797 = 0;
    int32_t *l_796 = &l_797;
    int32_t **l_798 = &l_796;
    struct S0 ****l_801 = (void*)0;
    (*l_798) = l_796;
    (*l_798) = (*l_798);
    (*l_796) = (((((uint32_t)p_42.f1 - (uint32_t)(((void*)0 == (*l_798)) == (l_801 != l_801))) > ((int16_t)((void*)0 != &l_801) + (int16_t)((*l_798) == (*l_798)))) > (-9)) || p_42.f0);
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_51(union U1  p_52)
{ /* block id: 37 */
    int32_t *l_59 = (void*)0;
    int32_t l_65 = 0x5493A50E;
    struct S0 l_731 = {0x363A8CA5,8,66,1};
    const struct S0 *l_730 = &l_731;
    uint32_t l_740 = 0x1C24B581;
    struct S0 *l_780 = &l_731;
    struct S0 * const *l_779 = &l_780;
    struct S0 * const **l_778 = &l_779;
    struct S0 * const ***l_777 = &l_778;
    if (p_52.f0)
    { /* block id: 38 */
        int32_t l_55 = 9;
        int32_t *l_54 = &l_55;
        int32_t **l_56 = &l_54;
        float l_61 = 0x1.1p-1;
        float *l_60 = &l_61;
        (*l_56) = l_54;
        (*l_60) = (((-0x3.Bp+1) != ((float)p_52.f1 + (float)((l_59 == (void*)0) <= p_52.f0))) == 0xC.4840C2p-12);
    }
    else
    { /* block id: 41 */
        return p_52.f0;
    }
    for (p_52.f1 = 0; (p_52.f1 > (-7)); p_52.f1--)
    { /* block id: 46 */
        float l_64 = 0x0.Dp+1;
        int32_t **l_71 = &l_59;
    }
    /* facts after for loop */
        if (((((int16_t)(((+p_52.f0) > 0xDF4587C9) && (l_777 != &l_778)) >> (int16_t)13) != p_52.f0) ^ p_52.f0))
    { /* block id: 524 */
        struct S0 *l_781 = &l_731;
        struct S0 **l_782 = &l_780;
        (*l_782) = l_781;
    }
    else
    { /* block id: 526 */
        uint16_t l_783 = 6U;
        int32_t *l_788 = &l_65;
        (*l_788) = (l_783 < ((int16_t)(0xB584 & (((uint16_t)p_52.f1 << (uint16_t)2) ^ p_52.f1)) << (int16_t)p_52.f0));
        for (l_740 = (-27); (l_740 >= 48); l_740 += 8)
        { /* block id: 530 */
            uint32_t l_791 = 4294967295U;
            (*l_788) = ((l_791 && 0x49AEDBE1) == (p_52.f1 == ((int32_t)((int16_t)p_52.f1 >> (int16_t)3) - (int32_t)3)));
            (*l_788) = 0x9C373328;
        }
    }
    return p_52.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_84(int32_t ** p_85, uint32_t  p_86)
{ /* block id: 52 */
    float l_684 = 0x1.9p+1;
    float *l_683 = &l_684;
    int32_t l_685 = (-7);
    union U1 ****l_702 = (void*)0;
    float **l_722 = &l_683;
    int32_t *l_723 = &l_685;
    int32_t l_724 = 0x399357E3;
    (*l_683) = (p_86 < func_87(p_86, (*p_85), p_86));
    (*l_683) = ((-0x1.6p+1) == l_685);
    if (((int16_t)(p_86 <= (+((p_86 ^ ((+__builtin_parity((((int16_t)p_86 - (int16_t)__builtin_bswap64(((int16_t)0 << (int16_t)1))) & l_685))) <= l_685)) == __builtin_ia32_crc32qi(p_86, l_685)))) >> (int16_t)p_86))
    { /* block id: 451 */
        l_685 = 0xA1B7E462;
        (*p_85) = (*p_85);
    }
    else
    { /* block id: 454 */
        union U1 l_697 = {0xD8690CB9};
        union U1 *l_696 = &l_697;
        float *l_710 = &l_684;
        for (p_86 = 9; (p_86 <= 21); ++p_86)
        { /* block id: 457 */
            uint16_t l_707 = 0xACD9;
            (*p_85) = &l_685;
            /* statement id: 458 */
            //assert (l_59 == &l_685);
            l_696 = l_696;
            (*l_710) = ((float)((float)p_86 - (float)((l_702 != (void*)0) < p_86)) + (float)((float)p_86 + (float)((float)l_707 + (float)((p_86 != ((float)((((void*)0 != l_710) < p_86) > 0x1.9p+1) + (float)0x0.7p-1)) <= p_86))));
        }
        /* facts after for loop */
        //assert (l_59 == &l_685 || l_59 == 0 || l_59 == &l_73);
        if ((((-(int16_t)(((uint16_t)((p_86 || __builtin_clzl(p_86)) || p_86) << (uint16_t)0) <= ((uint16_t)p_86 >> (uint16_t)6))) > (((uint16_t)p_86 << (uint16_t)2) | ((int16_t)p_86 + (int16_t)p_86))) > (((void*)0 != p_85) < l_685)))
        { /* block id: 462 */
            (*p_85) = &l_685;
            /* statement id: 463 */
            //assert (l_59 == &l_685);
            return l_685;
            /* statement id: 464 */
            //assert (l_59 == dangling);
        }
        else
        { /* block id: 465 */
            int32_t *l_720 = &l_685;
            (*l_720) = (-1);
        }
    }
    /* facts after branching */
    //assert (l_59 == &l_685 || l_59 == 0 || l_59 == &l_73);
    (*l_723) = (!(&l_683 == l_722));
    return l_724;
    /* statement id: 470 */
    //assert (l_59 == dangling || l_59 == 0 || l_59 == &l_73);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_87(const int16_t  p_88, int32_t * p_89, uint32_t  p_90)
{ /* block id: 53 */
    int32_t l_99 = 0x4DC4505A;
    int32_t *l_98 = &l_99;
    int32_t **l_97 = &l_98;
    const uint32_t l_569 = 4294967288U;
    union U1 l_607 = {0x40FF83EB};
    union U1 *l_606 = &l_607;
    union U1 **l_618 = &l_606;
    union U1 ***l_617 = &l_618;
    union U1 ****l_616 = &l_617;
    union U1 *****l_615 = &l_616;
    if (((uint32_t)((int16_t)func_95(l_97) << (int16_t)l_569) + (uint32_t)((func_113(l_569) || ((int32_t)p_90 - (int32_t)(__builtin_popcountll(p_88) > p_90))) ^ 0x6551)))
    { /* block id: 363 */
        int32_t l_575 = 0xA1359E93;
        int32_t *l_583 = &l_99;
        for (p_90 = 0; (p_90 > 25); p_90++)
        { /* block id: 366 */
            int32_t **l_574 = &l_98;
            int32_t l_642 = 0x5096AF42;
            union U1 *l_670 = &l_607;
            if (p_88)
                break;
        }
    }
    else
    { /* block id: 440 */
        struct S0 l_678 = {0xC97FB50E,3,49,4};
        struct S0 *l_677 = &l_678;
        struct S0 **l_679 = &l_677;
        int32_t *l_682 = &l_99;
        (*l_679) = l_677;
        for (l_99 = (-19); (l_99 < 23); ++l_99)
        { /* block id: 444 */
            (*l_97) = l_682;
            /* statement id: 445 */
            assert (l_98 == &l_99);
        }
    }
    /* facts after branching */
    //assert (l_98 == &l_99 || l_98 == 0 || l_98 == dangling);
    return p_90;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_95(int32_t ** p_96)
{ /* block id: 54 */
    uint16_t l_103 = 0x8398;
    int32_t **l_370 = (void*)0;
    int32_t ***l_369 = &l_370;
    union U1 **l_460 = (void*)0;
    union U1 ***l_459 = &l_460;
    int32_t l_512 = (-1);
    int32_t *l_511 = &l_512;
    const struct S0 l_552 = {0U,10,45,-1};
    const struct S0 *l_551 = &l_552;
    const struct S0 **l_550 = &l_551;
    float *l_560 = (void*)0;
    float l_562 = (-0x6.4p-1);
    float *l_561 = &l_562;
    struct S0 *l_567 = (void*)0;
    struct S0 **l_566 = &l_567;
    struct S0 ***l_565 = &l_566;
    struct S0 *** const * const l_564 = &l_565;
    struct S0 *** const * const *l_563 = &l_564;
    int16_t l_568 = 0x281E;
    if (__builtin_ia32_crc32qi((func_100(l_103, l_103) ^ (l_103 || (+(((uint16_t)(l_103 > ((uint16_t)((**p_96) <= (((int16_t)l_103 >> (int16_t)15) >= l_103)) << (uint16_t)2)) >> (uint16_t)7) >= ((void*)0 != l_369))))), l_103))
    { /* block id: 249 */
        int16_t l_373 = 4;
        union U1 l_398 = {0x2BB7B0CE};
        union U1 *l_397 = &l_398;
        union U1 * const *l_396 = &l_397;
        union U1 * const **l_395 = &l_396;
        int32_t l_423 = (-1);
        int32_t l_427 = 6;
        uint32_t l_485 = 0U;
        int32_t *l_492 = &l_427;
        float **l_500 = (void*)0;
        float ***l_499 = &l_500;
        if (((int16_t)(l_373 != ((int32_t)0x3BC47F2C - (int32_t)0x599F4A2D)) - (int16_t)l_373))
        { /* block id: 250 */
            int32_t l_380 = (-5);
            struct S0 l_382 = {1U,4,68,-3};
            struct S0 *l_381 = &l_382;
            int32_t l_394 = 0x927A84E4;
            if (__builtin_ffsll(((int16_t)l_373 >> (int16_t)l_373)))
            { /* block id: 251 */
                uint32_t l_388 = 1U;
                struct S0 **l_393 = &l_381;
                struct S0 ***l_392 = &l_393;
                struct S0 ****l_391 = &l_392;
                const uint32_t l_428 = 5U;
                int32_t *l_431 = &l_427;
                union U1 *l_434 = &l_398;
                if (((uint32_t)(0xE618 && 0x3DA2) % (uint32_t)l_373))
                { /* block id: 252 */
                    int32_t *l_384 = &l_380;
                    union U1 **l_401 = &l_397;
                    union U1 ***l_400 = &l_401;
                    union U1 ****l_399 = &l_400;
                    if ((((void*)0 != (*p_96)) > func_113(l_380)))
                    { /* block id: 253 */
                        (*p_96) = (*p_96);
                    }
                    else
                    { /* block id: 255 */
                        struct S0 **l_383 = &l_381;
                        (*l_383) = l_381;
                        (*p_96) = l_384;
                        /* statement id: 257 */
                        //assert (l_98 == &l_380);
                    }
                    /* facts after branching */
                    //assert (l_98 == &l_380 || l_98 == &l_99);
                    (*l_384) = ((int16_t)((((!((l_373 | l_388) == (((uint16_t)((void*)0 == l_391) - (uint16_t)(((-1) | 0xD4A8) ^ __builtin_ffs((8 >= l_394)))) & l_388))) >= (*l_384)) <= l_373) <= 4294967295U) % (int16_t)1);
                    (*l_399) = l_395;
                    /* statement id: 260 */
                    assert (l_400 == &l_396);
                }
                else
                { /* block id: 261 */
                    const int32_t l_416 = 1;
                    if (((((int16_t)((int32_t)(**p_96) % (int32_t)((int16_t)l_388 - (int16_t)((int16_t)(((int16_t)l_398.f1 >> (int16_t)9) || ((int16_t)l_398.f0 + (int16_t)(((uint16_t)((l_416 >= (((int32_t)(((void*)0 != (**l_391)) || __builtin_parityll(l_398.f1)) % (int32_t)l_416) != l_416)) && l_416) >> (uint16_t)l_416) > l_388))) + (int16_t)l_388))) - (int16_t)l_416) <= l_382.f3) | (**p_96)))
                    { /* block id: 262 */
                        int32_t l_424 = (-1);
                        float l_430 = 0x0.5p+1;
                        float *l_429 = &l_430;
                        (*l_429) = (l_416 > ((((float)((float)(((((((((l_423 > (0xD.5F1330p-65 != ((__builtin_clzl(l_388) >= l_382.f3) >= l_388))) <= l_424) <= ((float)(-0x1.Fp-1) + (float)l_388)) != l_416) != 0x1.5p+1) > 0x1.7p-1) != l_382.f3) >= l_427) <= 0x0.2FDCECp-55) - (float)l_388) + (float)l_428) > (-0x2.Ap-1)) <= l_373));
                        (*p_96) = l_431;
                        /* statement id: 264 */
                        //assert (l_98 == &l_427);
                        (***l_391) = &l_382;
                        return l_416;
                        /* statement id: 266 */
                        //assert (l_98 == dangling);
                    }
                    else
                    { /* block id: 267 */
                        (*p_96) = (void*)0;
                        /* statement id: 268 */
                        //assert (l_98 == 0);
                        (*l_431) = ((uint16_t)((void*)0 == l_434) - (uint16_t)4);
                    }
                    /* facts after branching */
                    //assert (l_98 == 0);
                    for (l_380 = 0; (l_380 > 16); l_380++)
                    { /* block id: 273 */
                        (*l_391) = (void*)0;
                        /* statement id: 274 */
                        assert (l_392 == 0);
                    }
                    /* facts after for loop */
                    assert (l_392 == 0 || l_392 == &l_393);
                }
                /* facts after branching */
                //assert (l_98 == 0 || l_98 == &l_380 || l_98 == &l_99);
                assert (l_392 == 0 || l_392 == &l_393);
                for (l_388 = 0; (l_388 <= 23); l_388 += 1)
                { /* block id: 279 */
                    int32_t l_454 = 0;
                    struct S0 * const *l_457 = &l_381;
                    struct S0 * const **l_456 = &l_457;
                    struct S0 * const ***l_455 = &l_456;
                    struct S0 *****l_458 = &l_391;
                }
            }
            else
            { /* block id: 290 */
                union U1 ****l_461 = &l_459;
                int32_t l_462 = 0;
                (*l_461) = l_459;
                (*p_96) = (void*)0;
                /* statement id: 292 */
                //assert (l_98 == 0);
                l_394 = l_462;
            }
            /* facts after branching */
            //assert (l_98 == 0 || l_98 == &l_380 || l_98 == &l_99);
        }
        else
        { /* block id: 295 */
            int32_t *l_472 = &l_427;
            if (((**p_96) < l_423))
            { /* block id: 296 */
                float l_465 = 0xD.158F80p-77;
                int32_t l_468 = 0xD20593E7;
                float *l_471 = &l_465;
                (*l_471) = (l_423 <= ((float)l_465 - (float)((float)__builtin_bswap32(l_468) - (float)((float)(l_398.f0 > ((-0x1.Dp+1) >= 0x6.89F1D7p-66)) + (float)0x1.C719AAp-8))));
                (*p_96) = l_472;
                /* statement id: 298 */
                //assert (l_98 == &l_427);
            }
            else
            { /* block id: 299 */
                float l_480 = (-0x3.Bp+1);
                int32_t l_490 = (-3);
                float *l_491 = &l_480;
                (*p_96) = (*p_96);
                l_472 = (*p_96);
                /* statement id: 301 */
                //assert (l_472 == &l_99 || l_472 == &l_65);
                (*l_472) = (~((uint16_t)func_100(l_398.f0, l_398.f1) % (uint16_t)(3 ^ (*l_472))));
                (*l_491) = (((void*)0 != (*l_459)) < ((float)0x6.1E3287p-50 - (float)(((float)l_480 - (float)0x1.2p+1) == ((((float)(((float)func_113(l_485) - (float)__builtin_clz(((uint16_t)0xB4B0 << (uint16_t)((int32_t)(0xBD28 ^ 0) % (int32_t)(**p_96))))) == l_490) + (float)l_490) > (*l_472)) > 0x1.9p-1))));
            }
            /* facts after branching */
            //assert (l_98 == &l_99 || l_98 == &l_427);
            //assert (l_472 == &l_99 || l_472 == &l_427 || l_472 == &l_65);
            (*p_96) = l_472;
            l_492 = l_472;
            /* statement id: 306 */
            //assert (l_492 == &l_99 || l_492 == &l_427 || l_492 == &l_65);
        }
        /* facts after branching */
        //assert (l_98 == &l_99 || l_98 == &l_427 || l_98 == 0 || l_98 == dangling);
        //assert (l_492 == &l_99 || l_492 == &l_427 || l_492 == &l_65);
        for (l_398.f0 = 0; (l_398.f0 > 29); ++l_398.f0)
        { /* block id: 310 */
            int32_t l_495 = 0x93C588D4;
            float *l_496 = (void*)0;
            float l_498 = 0x3.2700F4p+5;
            float *l_497 = &l_498;
            (*l_497) = (l_495 >= (*l_492));
            return l_495;
            /* statement id: 312 */
            //assert (l_98 == &l_99 || l_98 == 0 || l_98 == dangling);
        }
        if ((l_499 == &l_500))
        { /* block id: 314 */
            union U1 *l_503 = &l_398;
            int32_t l_504 = 2;
            int32_t l_505 = 0x58C5A75C;
            float l_507 = 0x0.Bp-1;
            float *l_506 = &l_507;
            l_505 = ((((float)((*l_492) <= ((((l_103 < (-0x2.Ap+1)) < ((0xC.309246p+82 <= (func_113(func_113((*l_492))) == (l_503 == (void*)0))) <= l_504)) <= l_504) != l_504)) - (float)l_504) < l_504) <= 0x1.Bp-1);
            (*l_506) = (((*l_492) <= 0xA.4D9D22p+2) <= (*l_492));
        }
        else
        { /* block id: 317 */
            int16_t l_508 = 1;
            float l_510 = 0xD.C6346Bp-67;
            float *l_509 = &l_510;
            (*l_509) = (l_508 == (*l_492));
            (*l_492) = (0x39D021F3 || func_113(l_508));
        }
        l_511 = &l_427;
        /* statement id: 321 */
        assert (l_511 == &l_427);
    }
    else
    { /* block id: 322 */
        uint32_t l_513 = 4294967287U;
        int32_t l_516 = 0xAEEBAF70;
        union U1 l_536 = {2};
        union U1 *l_535 = &l_536;
        float **l_542 = (void*)0;
        float ***l_541 = &l_542;
        if (l_513)
        { /* block id: 323 */
            float l_515 = 0xB.7386A1p-48;
            float *l_514 = &l_515;
            (*l_511) = (l_514 == (void*)0);
        }
        else
        { /* block id: 325 */
            union U1 l_534 = {0xF5D6356D};
            union U1 *l_533 = &l_534;
            int32_t l_539 = 0x7A1A031D;
            int32_t *l_540 = &l_539;
            if ((l_513 <= l_516))
            { /* block id: 326 */
                int32_t l_517 = 0x15189674;
                int32_t *l_530 = &l_512;
                if (l_517)
                { /* block id: 327 */
                    int32_t l_529 = 0x0BC9B0F4;
                    for (l_513 = 29; (l_513 != 29); l_513 += 4)
                    { /* block id: 330 */
                        float *l_527 = (void*)0;
                        int32_t l_528 = (-7);
                        l_528 = ((__builtin_popcountl((((uint32_t)4294967295U - (uint32_t)((uint16_t)l_517 >> (uint16_t)3)) || ((int16_t)((-1) ^ (l_517 == (+(__builtin_clzl((__builtin_clz(l_517) & 0x57B7)) ^ 0xCC200F24)))) << (int16_t)l_516))) == l_517) >= (-0x10.3p+1));
                        (**p_96) = (0x9434 == l_529);
                    }
                }
                else
                { /* block id: 334 */
                    (*p_96) = (*p_96);
                    (*p_96) = l_530;
                    /* statement id: 336 */
                    //assert (l_98 == &l_512);
                }
                /* facts after branching */
                //assert (l_98 == &l_512 || l_98 == &l_99);
                (*l_530) = (-1);
            }
            else
            { /* block id: 339 */
                float l_531 = (-0x7.1p-1);
                int32_t l_532 = 0;
                return l_532;
            }
            /* facts after branching */
            //assert (l_98 == &l_512 || l_98 == &l_99);
            (*p_96) = (*p_96);
            l_539 = ((l_533 == l_535) <= ((int32_t)1 - (int32_t)(**p_96)));
            l_540 = &l_539;
        }
        /* facts after branching */
        //assert (l_98 == &l_512 || l_98 == &l_99);
        if (((-1) == ((l_516 && ((void*)0 == l_541)) <= ((uint16_t)((int16_t)(*l_511) >> (int16_t)4) >> (uint16_t)((uint16_t)(*l_511) >> (uint16_t)15)))))
        { /* block id: 346 */
            union U1 **l_549 = &l_535;
            int32_t l_553 = 0x9ADFA597;
            (*p_96) = (*p_96);
            (*l_459) = l_549;
            /* statement id: 348 */
            assert (l_460 == &l_535);
            l_553 = ((*l_511) | (((((*l_459) != &l_535) == 0U) <= l_536.f0) && (l_550 != &l_551)));
            (*l_460) = func_121(p_96, (**l_459), ((float)(-0x8.6p+1) + (float)l_553), p_96, (***l_459));
            /* statement id: 350 */
            assert (l_535 == 0);
        }
        else
        { /* block id: 351 */
            union U1 *l_556 = (void*)0;
            int32_t l_557 = 0xEB963E05;
            float l_559 = 0x1.9p+1;
            float *l_558 = &l_559;
            (*l_511) = (**p_96);
            (*p_96) = (*p_96);
            (**p_96) = (l_536.f0 > (l_556 != (void*)0));
            (*l_558) = (((l_536.f1 <= l_557) < func_113(l_557)) != (&l_557 == (void*)0));
        }
        /* facts after branching */
        assert (l_460 == 0 || l_460 == &l_535);
        assert (l_535 == &l_536 || l_535 == 0);
        (**p_96) = l_536.f1;
    }
    /* facts after branching */
    //assert (l_98 == &l_512 || l_98 == &l_99 || l_98 == 0 || l_98 == dangling);
    //assert (l_460 == 0 || l_460 == dangling);
    //assert (l_511 == &l_512 || l_511 == dangling);
    (*l_561) = ((l_552.f1 >= (&l_459 == (void*)0)) >= __builtin_parityll(l_552.f1));
    (*l_561) = l_552.f3;
    l_563 = l_563;
    return l_568;
    /* statement id: 362 */
    //assert (l_98 == &l_99 || l_98 == 0 || l_98 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_100(int32_t  p_101, int32_t  p_102)
{ /* block id: 55 */
    uint32_t l_104 = 4294967295U;
    float l_118 = 0x0.9AAE81p+92;
    float *l_117 = &l_118;
    union U1 l_197 = {5};
    union U1 *l_196 = &l_197;
    union U1 * const *l_195 = &l_196;
    int32_t l_220 = (-1);
    int32_t *l_219 = &l_220;
    int32_t **l_218 = &l_219;
    int32_t *l_252 = &l_220;
    uint16_t l_268 = 65535U;
    int32_t *l_294 = &l_220;
    float **l_336 = (void*)0;
    float ** const *l_335 = &l_336;
    struct S0 ***l_337 = (void*)0;
    if ((((((1U > ((l_104 & ((((uint16_t)__builtin_popcountl(((uint16_t)(((((uint16_t)(p_102 && p_102) + (uint16_t)((uint16_t)func_113((__builtin_bswap32((((int32_t)(l_117 != (void*)0) % (int32_t)2) & ((int16_t)((__builtin_popcountl(l_104) && p_102) >= p_102) << (int16_t)4))) || p_101)) % (uint16_t)l_104)) > l_104) == p_102) != 9U) >> (uint16_t)8)) >> (uint16_t)l_104) != l_104) && l_104)) == 0xDDB27898)) != p_102) && l_104) >= l_104) | l_104))
    { /* block id: 63 */
        const uint16_t l_152 = 0x02EC;
        int32_t *l_176 = (void*)0;
        union U1 l_189 = {1};
        union U1 *l_188 = &l_189;
        int32_t l_210 = 0xC9C01031;
        int32_t *l_209 = &l_210;
        if ((((-1) && p_101) || ((0x1BBE26AF <= p_101) != (((uint32_t)(p_102 <= (((int16_t)(-1) >> (int16_t)5) || ((p_101 > (p_102 | (((+((int16_t)0x0B25 << (int16_t)l_104)) && l_152) == 0xA799))) | 0x2D9A))) - (uint32_t)0) && 0xE726552C))))
        { /* block id: 64 */
            uint32_t l_155 = 4294967295U;
            int32_t l_178 = 0x18AE1307;
            int32_t *l_177 = &l_178;
            union U1 **l_198 = &l_188;
            int32_t *l_212 = &l_178;
            int32_t **l_213 = &l_209;
            if (((int32_t)l_155 - (int32_t)0x0665BEC7))
            { /* block id: 65 */
                int32_t l_162 = 1;
                int32_t *l_161 = &l_162;
                int32_t **l_160 = &l_161;
                union U1 *l_199 = (void*)0;
lbl_192:
                if ((((int16_t)(((int16_t)((void*)0 != l_160) << (int16_t)2) != func_113(l_155)) - (int16_t)p_102) == ((uint16_t)(1 & p_101) << (uint16_t)(p_101 ^ p_102))))
                { /* block id: 66 */
                    const uint32_t l_165 = 0x75BA722E;
                    (*l_160) = l_117;
                    /* statement id: 67 */
                    assert (l_161 == &l_118);
                    p_102 = func_113((p_101 >= l_165));
                }
                else
                { /* block id: 69 */
                    float l_166 = 0xF.AA6A4Dp-72;
                    int32_t l_175 = 0x53DDAA5E;
                    if (p_102)
                    { /* block id: 70 */
                        int32_t l_170 = (-1);
                        (*l_117) = ((!(0x1.Ap-1 <= ((float)l_170 - (float)(-0x1.Fp+1)))) >= ((float)((float)l_175 + (float)p_101) - (float)p_101));
                        l_176 = &p_102;
                        /* statement id: 72 */
                        assert (l_176 == &p_102);
                    }
                    else
                    { /* block id: 73 */
                        const int32_t l_180 = (-5);
                        l_177 = &p_102;
                        /* statement id: 74 */
                        assert (l_177 == &p_102);
                        (*l_117) = (+l_180);
                        l_175 = ((int32_t)__builtin_parityll(((uint32_t)(*l_177) % (uint32_t)(-(int32_t)((((uint16_t)((l_180 | l_175) > __builtin_bswap64(l_175)) << (uint16_t)1) ^ l_104) > ((*l_161) == __builtin_ctzl(l_175)))))) % (int32_t)p_101);
                    }
                    if ((0xAF8E2B3D != l_175))
                    { /* block id: 78 */
                        union U1 **l_190 = (void*)0;
                        union U1 **l_191 = &l_188;
                        (*l_161) = p_101;
                        (*l_191) = l_188;
                        if (p_102)
                            goto lbl_192;
                    }
                    else
                    { /* block id: 81 */
                        (*l_160) = l_117;
                        /* statement id: 82 */
                        assert (l_161 == &l_118);
                        (*l_177) = l_175;
                        (**l_160) = ((void*)0 != &p_102);
                    }
                    /* facts after branching */
                    assert (l_161 == &l_118 || l_161 == &l_162);
                }
                /* facts after branching */
                assert (l_161 == &l_118 || l_161 == &l_162);
                for (l_189.f1 = (-25); (l_189.f1 < 16); ++l_189.f1)
                { /* block id: 90 */
                    (*l_117) = ((l_161 != l_177) >= (l_195 == l_198));
                    (*l_198) = l_199;
                    /* statement id: 92 */
                    assert (l_188 == 0);
                    (*l_160) = &p_102;
                    /* statement id: 93 */
                    assert (l_161 == &p_102);
                    return p_101;
                }
                /* facts after for loop */
                                return p_102;
            }
            else
            { /* block id: 97 */
                for (l_178 = 0; (l_178 < 10); l_178 += 9)
                { /* block id: 100 */
                    return p_102;
                }
                if (((uint16_t)func_113(p_101) >> (uint16_t)14))
                { /* block id: 103 */
                    int16_t l_204 = 4;
                    l_204 = 0x0.Ep-1;
                    (*l_177) = func_113(__builtin_bswap64(((int16_t)(l_204 == p_101) % (int16_t)l_197.f1)));
                }
                else
                { /* block id: 106 */
                    int32_t **l_211 = &l_177;
                    for (l_189.f0 = (-26); (l_189.f0 != 2); ++l_189.f0)
                    { /* block id: 109 */
                        (*l_117) = (*l_177);
                    }
                    (*l_211) = l_209;
                    /* statement id: 112 */
                    assert (l_177 == &l_210);
                }
                /* facts after branching */
                assert (l_177 == &l_210 || l_177 == &l_178);
            }
            /* facts after branching */
            assert (l_177 == &l_210 || l_177 == &l_178);
            (*l_213) = l_212;
            /* statement id: 115 */
            assert (l_209 == &l_178);
        }
        else
        { /* block id: 116 */
            int32_t *l_214 = &l_210;
            int32_t **l_215 = &l_176;
            l_214 = &l_210;
            (*l_215) = &p_102;
            /* statement id: 118 */
            assert (l_176 == &p_102);
            (*l_214) = ((**l_215) || (&l_210 != (void*)0));
        }
        /* facts after branching */
        assert (l_176 == &p_102 || l_176 == 0);
        //assert (l_209 == &l_210 || l_209 == dangling);
    }
    else
    { /* block id: 121 */
        return p_102;
    }
    if (((uint32_t)(l_218 != (void*)0) + (uint32_t)(-1)))
    { /* block id: 124 */
        int32_t *l_225 = &l_220;
        int32_t ***l_281 = &l_218;
        const union U1 **l_288 = (void*)0;
        (*l_218) = &p_102;
        /* statement id: 125 */
        assert (l_219 == &p_102);
lbl_341:
        if (p_102)
        { /* block id: 126 */
            uint32_t l_223 = 3U;
            int32_t l_224 = (-1);
            int32_t *l_226 = &l_220;
            const int32_t *l_243 = &l_224;
            const int32_t **l_242 = &l_243;
            const int32_t ***l_241 = &l_242;
            union U1 **l_249 = &l_196;
            l_224 = ((float)l_223 + (float)l_223);
            l_226 = l_225;
            p_102 = ((uint32_t)p_102 - (uint32_t)(*l_226));
            if ((65535U < (((uint16_t)((int16_t)func_113(((uint32_t)((&p_102 != (void*)0) ^ ((void*)0 == &l_226)) - (uint32_t)((((void*)0 == &l_226) != 65535U) || (((*l_226) == (*l_219)) == (*l_226))))) + (int16_t)p_101) << (uint16_t)15) ^ (*l_226))))
            { /* block id: 130 */
                float l_235 = 0xB.AF4CE8p-82;
                int32_t l_236 = 0xD4623137;
                uint32_t l_248 = 4294967295U;
                (**l_218) = p_102;
                (*l_225) = (l_236 || func_113(l_236));
                for (l_197.f1 = 26; (l_197.f1 < 5); l_197.f1 -= 6)
                { /* block id: 135 */
                    union U1 * const *l_250 = &l_196;
                    int32_t *l_251 = &l_220;
                    for (l_104 = 1; (l_104 >= 1); --l_104)
                    { /* block id: 138 */
                        int32_t ** const *l_245 = &l_218;
                        int32_t ** const **l_244 = &l_245;
                        (*l_244) = l_241;
                        /* statement id: 139 */
                        assert (l_245 == &l_242);
                        (*l_226) = ((float)0xA.FDB9DDp-52 - (float)(l_248 < (l_249 != l_250)));
                        (***l_244) = l_251;
                        /* statement id: 141 */
                        assert (l_243 == &l_220);
                    }
                    (*l_218) = &l_236;
                    /* statement id: 143 */
                    assert (l_219 == &l_236);
                    (*l_226) = p_101;
                    (*l_242) = l_252;
                    /* statement id: 145 */
                    assert (l_243 == &l_220);
                }
                /* facts after for loop */
                                assert (l_219 == &l_236 || l_219 == &l_220 || l_219 == &p_102);
                assert (l_243 == &l_220 || l_243 == &l_224);
            }
            else
            { /* block id: 147 */
                const float **l_253 = (void*)0;
                float * const *l_255 = &l_117;
                float * const **l_254 = &l_255;
                int32_t l_263 = 0x50D544D0;
                (*l_254) = l_253;
                /* statement id: 148 */
                assert (l_255 == 0);
                (*l_225) = (((uint16_t)((***l_241) != ((~p_102) >= (((((((((((int16_t)((int16_t)(*l_219) << (int16_t)15) << (int16_t)((void*)0 != &l_225)) & l_263) < __builtin_parity(func_113((((uint32_t)0xD8F16D91 - (uint32_t)(((int16_t)l_268 >> (int16_t)13) < (((uint16_t)(-(int32_t)p_101) << (uint16_t)p_101) ^ (*l_225)))) ^ 0x82994EBA)))) > (*l_225)) && (*l_225)) & (**l_242)) & 2U) ^ (***l_241)) > 0xF7C8) & 0x32BB3065))) << (uint16_t)(*l_243)) != (-8));
                (*l_219) = (((int32_t)(*l_225) + (int32_t)(*l_225)) > (((*l_195) == (void*)0) >= 0x805CE073));
                for (l_220 = 0; (l_220 >= 14); l_220 += 6)
                { /* block id: 153 */
                    uint16_t l_280 = 0x08AE;
                }
            }
            /* facts after branching */
                        //assert (l_219 == dangling || l_219 == &l_220 || l_219 == &p_102);
            assert (l_243 == &l_220 || l_243 == &l_224);
        }
        else
        { /* block id: 168 */
            (*l_117) = 0xA.0666A6p+93;
        }
        /* facts after branching */
                //assert (l_219 == dangling || l_219 == &l_220 || l_219 == &p_102);
        (*l_218) = l_294;
        /* statement id: 171 */
        assert (l_219 == &l_220);
        if ((*l_294))
        { /* block id: 172 */
            const uint16_t l_299 = 5U;
            if (p_102)
            { /* block id: 173 */
                uint32_t l_300 = 0xD7BFA6EB;
                float *l_306 = &l_118;
                (*l_117) = ((((func_113((**l_218)) >= ((p_101 > func_113((**l_218))) == (__builtin_clz(p_102) >= 0xD.CD69E2p-57))) <= ((float)(((float)l_299 + (float)l_300) >= l_299) - (float)(-0x1.Dp+1))) == l_299) >= l_299);
                for (l_300 = 0; (l_300 < 33); l_300 += 1)
                { /* block id: 177 */
                    float *l_305 = &l_118;
                    int32_t l_309 = 9;
                    (**l_281) = &p_102;
                    /* statement id: 178 */
                    assert (l_219 == &p_102);
                    (*l_225) = (0x2C9F && (p_102 < (((int32_t)((l_305 == l_306) <= ((void*)0 != (*l_195))) - (int32_t)(((int16_t)p_102 << (int16_t)9) <= (__builtin_popcountl((l_309 > 8U)) ^ 0xFF7CC213))) < 9U)));
                    return p_102;
                }
            }
            else
            { /* block id: 182 */
                uint32_t l_310 = 4U;
                if (((void*)0 != l_288))
                { /* block id: 183 */
                    (*l_219) = l_310;
                }
                else
                { /* block id: 185 */
                    uint16_t l_313 = 0U;
                    (*l_225) = ((int16_t)l_310 - (int16_t)l_310);
                    (*l_117) = l_313;
                    (***l_281) = l_310;
                }
            }
            (*l_218) = &p_102;
            /* statement id: 191 */
            assert (l_219 == &p_102);
            (**l_218) = ((uint16_t)0xBA93 - (uint16_t)(((((((*l_225) | func_113(p_101)) == ((p_101 > p_101) || __builtin_popcount(l_299))) ^ ((*l_294) && p_101)) ^ (***l_281)) & p_102) != p_101));
            (**l_218) = (l_299 && ((&l_252 == (void*)0) != (l_299 > ((int16_t)(+(((uint16_t)__builtin_clz(p_102) << (uint16_t)(~((uint16_t)(l_299 != __builtin_ffs(p_101)) + (uint16_t)5U))) > 0)) - (int16_t)(-7)))));
        }
        else
        { /* block id: 194 */
            int32_t l_351 = 0xD0BA7A7D;
            const int32_t *l_352 = &l_220;
            (*l_117) = ((*l_294) >= (0x8.EFF3E8p-36 >= (l_225 == l_225)));
            if ((-(int32_t)(*l_252)))
            { /* block id: 196 */
                int32_t *l_329 = &l_220;
                struct S0 l_334 = {0x942CA0AF,3,38,-2};
                const struct S0 *l_333 = &l_334;
                for (p_101 = 0; (p_101 <= (-13)); p_101 -= 9)
                { /* block id: 199 */
                    struct S0 l_331 = {0x12D4DC24,0,83,-0};
                    const struct S0 *l_330 = &l_331;
                    (*l_218) = l_329;
                    if ((*l_329))
                    { /* block id: 201 */
                        struct S0 **l_332 = (void*)0;
                        l_333 = l_330;
                        /* statement id: 202 */
                        assert (l_333 == &l_331);
                    }
                    else
                    { /* block id: 203 */
                        struct S0 ** const **l_338 = (void*)0;
                        const struct S0 ***l_340 = (void*)0;
                        const struct S0 ****l_339 = &l_340;
                        (**l_281) = l_329;
                        (*l_117) = (0x2.0E1881p-11 > (l_335 != &l_336));
                        (**l_281) = &p_102;
                        /* statement id: 206 */
                        assert (l_219 == &p_102);
                        (*l_339) = l_337;
                    }
                    /* facts after branching */
                    assert (l_219 == &p_102 || l_219 == &l_220);
                    //assert (l_333 == &l_334 || l_333 == dangling || l_333 == &l_331);
                    (**l_281) = l_329;
                    /* statement id: 209 */
                    assert (l_219 == &l_220);
                }
                /* facts after for loop */
                //assert (l_333 == &l_334 || l_333 == dangling);
                (*l_218) = (**l_281);
                if (p_101)
                    goto lbl_341;
            }
            else
            { /* block id: 213 */
                struct S0 l_347 = {0x8B250B62,8,10,2};
                struct S0 *l_346 = &l_347;
                struct S0 **l_345 = &l_346;
                struct S0 ***l_344 = &l_345;
                int32_t *l_356 = &l_220;
                for (l_197.f0 = 0; (l_197.f0 != (-2)); l_197.f0--)
                { /* block id: 216 */
                    struct S0 * const *l_350 = &l_346;
                    struct S0 * const **l_349 = &l_350;
                    struct S0 * const ***l_348 = &l_349;
                    int32_t **l_353 = &l_294;
                    (*l_348) = l_344;
                    /* statement id: 217 */
                    assert (l_349 == &l_345);
                    if (__builtin_ia32_crc32qi((l_351 != p_101), p_101))
                    { /* block id: 218 */
                        if (p_102)
                            break;
                        return p_101;
                    }
                    else
                    { /* block id: 221 */
                        (*l_294) = p_102;
                    }
                    (*l_353) = l_352;
                    (*l_218) = (*l_218);
                }
                /* facts after for loop */
                                for (l_351 = 0; (l_351 < 11); l_351++)
                { /* block id: 229 */
                    (*l_218) = &p_102;
                    /* statement id: 230 */
                    assert (l_219 == &p_102);
                    (**l_281) = l_356;
                    /* statement id: 231 */
                    assert (l_219 == &l_220);
                    for (l_220 = 6; (l_220 <= (-12)); l_220 -= 5)
                    { /* block id: 234 */
                        struct S0 ** const *l_360 = &l_345;
                        struct S0 ** const **l_359 = &l_360;
                        (*l_218) = l_356;
                        (*l_359) = (void*)0;
                        /* statement id: 236 */
                        assert (l_360 == 0);
                        return p_102;
                    }
                }
            }
        }
        /* facts after branching */
        assert (l_219 == &l_220 || l_219 == &p_102);
    }
    else
    { /* block id: 242 */
        uint32_t l_361 = 0x1B2EE99A;
        l_361 = p_101;
        (*l_218) = (void*)0;
        /* statement id: 244 */
        assert (l_219 == 0);
    }
    /* facts after branching */
        assert (l_219 == 0 || l_219 == &l_220 || l_219 == &p_102);
    l_196 = (*l_195);
    (*l_117) = 0x0.8p-1;
    return p_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_113(uint32_t  p_114)
{ /* block id: 56 */
    int32_t **l_127 = (void*)0;
    union U1 l_129 = {-1};
    union U1 *l_128 = &l_129;
    union U1 **l_139 = &l_128;
    int32_t l_141 = (-3);
    int32_t * const l_140 = &l_141;
    int32_t *l_143 = &l_141;
    int32_t **l_142 = &l_143;
    int16_t l_144 = 0;
    (*l_139) = func_121(l_127, l_128, l_129.f0, l_127, (*l_128));
    /* statement id: 60 */
    assert (l_128 == 0);
    (*l_142) = l_140;
    return l_144;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1 * func_121(int32_t ** p_122, union U1 * p_123, float  p_124, int32_t ** p_125, union U1  p_126)
{ /* block id: 57 */
    float *l_130 = (void*)0;
    float l_132 = 0x0.1p+1;
    float *l_131 = &l_132;
    union U1 l_134 = {-1};
    union U1 *l_133 = &l_134;
    union U1 *l_135 = &l_134;
    union U1 *l_136 = &l_134;
    union U1 *l_137 = &l_134;
    union U1 *l_138 = (void*)0;
    (*l_131) = (-0x9.5p-1);
    return l_138;
    /* statement id: 59 */
    //assert (func_121_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 256
   depth: 1, occurrence: 3
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 7
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 16
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 19
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 16

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 339
   depth: 2, occurrence: 52
   depth: 3, occurrence: 13
   depth: 4, occurrence: 8
   depth: 5, occurrence: 7
   depth: 6, occurrence: 7
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 5
   depth: 14, occurrence: 5
   depth: 15, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 265

XXX times a variable address is taken: 276
XXX times a pointer is dereferenced on RHS: 112
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 16
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 202
breakdown:
   depth: 1, occurrence: 178
   depth: 2, occurrence: 18
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 46
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 614

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 628
   level: 2, occurrence: 144
   level: 3, occurrence: 69
   level: 4, occurrence: 16
XXX number of pointers point to pointers: 138
XXX number of pointers point to scalars: 84
XXX number of pointers point to structs: 17
XXX percent of pointers has null in alias set: 22.3
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1013
XXX times a non-volatile is write: 525
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 283
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 38
   depth: 1, occurrence: 43
   depth: 2, occurrence: 65
   depth: 3, occurrence: 50
   depth: 4, occurrence: 47
   depth: 5, occurrence: 40

XXX percentage a fresh-made variable is used: 23.3
XXX percentage an existing variable is used: 76.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

