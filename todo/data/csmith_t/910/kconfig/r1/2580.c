/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1352685408
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 30;
   signed f1 : 27;
   signed f2 : 17;
   int32_t  f3;
   signed f4 : 10;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 20;
   unsigned f1 : 27;
};
#pragma pack(pop)

struct S2 {
   signed f0 : 19;
   unsigned f1 : 22;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_35(void);
static uint16_t  func_52(uint32_t  p_53, uint32_t  p_54);
inline static uint32_t  func_85(int32_t  p_86, uint32_t  p_87, struct S0  p_88);
inline static int16_t  func_95(uint32_t  p_96, int16_t  p_97, struct S1  p_98, struct S1  p_99);
inline static struct S1  func_100(struct S2  p_101, uint16_t  p_102, int32_t  p_103, uint32_t  p_104);
static struct S2  func_105(struct S1  p_106, struct S2  p_107, struct S2  p_108);
static struct S2  func_110(struct S1  p_111);
static int32_t  func_113(uint16_t  p_114, uint32_t  p_115, struct S0  p_116);
inline static int16_t  func_124(int16_t  p_125, uint16_t  p_126, int32_t  p_127, struct S2  p_128);
inline static uint16_t  func_129(struct S0  p_130, uint32_t  p_131, uint32_t  p_132, int32_t  p_133);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_35(void)
{ /* block id: 36 */
    int32_t l_36 = 0x52FA814B;
    int32_t l_37 = 0;
    struct S2 l_50 = {463,1283};
    int32_t l_376 = 0xA7F7F5ED;
    int32_t l_377 = 4;
    uint16_t l_378 = 0xC848;
    struct S1 l_385 = {-397,10398};
    struct S1 l_386 = {748,6252};
    struct S0 l_387 = {-16836,1740,-72,2,3};
    l_37 = l_36;
    l_377 &= ((uint32_t)((uint16_t)__builtin_parity(l_37) >> (uint16_t)14) % (uint32_t)(l_36 ^ ((uint16_t)(((uint32_t)((uint32_t)(l_37 >= ((uint16_t)((l_36 , l_50) , __builtin_ffsl(l_50.f0)) * (uint16_t)(~(l_376 = func_52(((uint16_t)(((((int16_t)l_50.f1 * (int16_t)l_37) == l_50.f1) , l_50.f0) & l_50.f1) - (uint16_t)l_37), l_50.f1))))) + (uint32_t)l_50.f1) - (uint32_t)0x9884D231) , l_50.f1) + (uint16_t)l_36)));
    l_376 |= (l_378 < (((int16_t)l_378 + (int16_t)((int16_t)((int16_t)func_95(l_377, __builtin_popcountll(l_377), (l_385 = l_385), l_386) - (int16_t)l_386.f1) + (int16_t)l_386.f1)) || l_377));
    return l_387;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_52(uint32_t  p_53, uint32_t  p_54)
{ /* block id: 38 */
    int16_t l_59 = 2;
    struct S0 l_91 = {-4068,9610,290,0x446CA37E,-26};
    int16_t l_314 = (-4);
    struct S2 l_315 = {-717,588};
    struct S1 l_347 = {-76,62};
    int32_t l_373 = (-4);
    struct S2 l_374 = {544,1811};
    uint16_t l_375 = 0U;
    if ((p_54 && l_59))
    { /* block id: 39 */
        uint32_t l_77 = 1U;
        struct S0 l_92 = {-1408,-6755,-25,1,5};
        uint32_t l_311 = 4294967286U;
        for (p_53 = (-18); (p_53 != 54); p_53 += 8)
        { /* block id: 42 */
            uint32_t l_62 = 0x759F32F5;
            int32_t l_78 = 0xD5762CC6;
            l_62 ^= p_53;
            l_92.f1 = ((uint32_t)((int16_t)((uint32_t)(((uint32_t)4294967290U % (uint32_t)__builtin_bswap64(((uint16_t)((((int32_t)(l_78 = ((int32_t)l_62 - (int32_t)l_77)) - (int32_t)0xCA67B110) && p_53) || ((int16_t)((p_54 , (((int16_t)((int16_t)p_53 * (int16_t)65535U) * (int16_t)(func_85(((int16_t)(((l_91 , l_78) , l_92) , p_54) - (int16_t)p_54), l_91.f2, l_91) > l_91.f0)) <= (-3))) > l_62) - (int16_t)0x2C29)) + (uint16_t)p_54))) & l_62) % (uint32_t)p_54) >> (int16_t)p_53) % (uint32_t)l_92.f1);
        }
        l_91.f4 = ((((int16_t)l_92.f1 + (int16_t)l_311) <= (l_91.f1 < l_92.f4)) == p_54);
    }
    else
    { /* block id: 166 */
        int32_t l_317 = 1;
        struct S1 l_327 = {383,1111};
        struct S0 l_332 = {15411,-8252,-120,0x89346247,-11};
        struct S2 l_354 = {347,1225};
        uint32_t l_355 = 0x75C4DA1E;
        for (l_91.f3 = (-24); (l_91.f3 != (-17)); l_91.f3 += 1)
        { /* block id: 169 */
            uint32_t l_316 = 1U;
            int32_t l_320 = 0;
            l_315.f0 = (l_91.f0 ^= ((5 > func_95(l_91.f4, l_314, func_100(l_315, l_316, (l_317 < (((int16_t)(l_320 = l_316) + (int16_t)((uint32_t)(((l_316 && ((int16_t)(l_91.f1 |= ((uint16_t)p_53 + (uint16_t)0xDD30)) - (int16_t)p_53)) <= l_317) && 0xC1874894) - (uint32_t)l_317)) < l_316)), p_54), l_327)) , 0xF0AE9239));
        }
        if (l_327.f0)
        { /* block id: 175 */
            int32_t l_330 = 0xA0C2D7F6;
            uint16_t l_337 = 1U;
            int32_t l_338 = (-4);
            l_338 = (((int16_t)p_53 * (int16_t)((p_54 = (l_327.f0 , p_54)) < (l_330 || 0x2872917E))) >= (~func_129(l_332, (__builtin_popcountl((((int32_t)func_85(p_53, (((((uint32_t)l_337 + (uint32_t)l_330) == 0x7C13) >= 0U) || 0x8C7E), l_91) + (int32_t)l_332.f4) == 0x3847FEAD)) ^ l_59), l_332.f4, l_330)));
            l_332 = l_91;
        }
        else
        { /* block id: 179 */
            int16_t l_348 = 1;
            int32_t l_358 = 0x14C40C3B;
            l_332.f4 = l_91.f3;
            l_91.f1 = (l_314 >= (func_100(l_315, ((uint16_t)l_332.f0 * (uint16_t)(p_54 < ((uint32_t)((p_53 != ((uint16_t)((int16_t)(func_95((p_54 != __builtin_popcount(p_54)), l_59, l_347, l_347) == p_54) >> (int16_t)7) * (uint16_t)l_348)) || 0xB8BF441B) % (uint32_t)p_54))), l_348, p_54) , 65526U));
            l_355 = (l_332.f2 ^= ((~(((int16_t)p_54 >> (int16_t)l_347.f0) || (((l_91.f1 |= (((uint16_t)(((func_100(l_354, p_54, p_53, p_54) , (l_332.f4 = p_53)) >= l_314) , p_53) % (uint16_t)p_54) && l_332.f3)) | l_327.f0) ^ l_348))) <= 0x8B60CCDD));
            l_358 |= ((int32_t)p_53 + (int32_t)l_348);
        }
    }
    l_374.f0 = func_124(((int16_t)l_91.f4 * (int16_t)((func_100(func_105(l_347, (l_315 = (func_129(l_91, ((uint16_t)p_54 + (uint16_t)((((int32_t)(4294967294U ^ (l_314 == (((uint16_t)(!func_95(((uint16_t)(p_54 != 3U) % (uint16_t)((((int16_t)(~0xBD3E55AA) * (int16_t)l_373) > 0U) , l_91.f3)), l_91.f0, l_347, l_347)) << (uint16_t)p_53) < l_91.f1))) % (int32_t)1U) | 0x3AB809C7) == l_314)), p_53, l_59) , l_315)), l_374), l_91.f0, p_54, l_91.f2) , l_375) || l_374.f1)), p_54, l_374.f1, l_374);
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_85(int32_t  p_86, uint32_t  p_87, struct S0  p_88)
{ /* block id: 45 */
    struct S1 l_109 = {252,3120};
    struct S1 l_112 = {-390,10897};
    struct S2 l_157 = {-467,548};
    struct S1 l_161 = {628,11453};
    uint32_t l_177 = 4294967295U;
    uint16_t l_206 = 65533U;
    struct S0 l_226 = {-20015,-6659,21,0x7BED9066,-17};
    uint32_t l_240 = 0x2E07C214;
    int32_t l_259 = 8;
    struct S2 l_279 = {-609,1641};
    int32_t l_303 = (-4);
    p_88.f4 |= ((int16_t)func_95(((l_112.f0 = ((func_100(func_105((l_109 = l_109), func_110(l_112), (((l_112.f1 ^ 0xB607) , func_110(l_112)) , l_157)), p_86, p_88.f1, p_88.f0) , l_112.f0) ^ p_88.f2)) <= l_112.f1), p_86, l_161, l_161) - (int16_t)0x14F5);
    if (l_161.f0)
    { /* block id: 89 */
        p_88.f4 &= __builtin_ctzll(l_109.f0);
    }
    else
    { /* block id: 91 */
        int32_t l_165 = 0xB5352CA7;
        struct S1 l_171 = {-850,9873};
        struct S2 l_172 = {-75,1458};
        struct S1 l_175 = {93,1294};
        struct S0 l_225 = {-11115,5615,21,0x24C49024,-27};
        for (p_86 = 0; (p_86 < (-9)); p_86 -= 1)
        { /* block id: 94 */
            uint16_t l_166 = 1U;
            struct S2 l_176 = {697,899};
            int16_t l_184 = 0x9B0C;
            struct S0 l_214 = {-5465,-9835,85,0xCD63981B,1};
            int32_t l_263 = 0xC17A1031;
            if (__builtin_ctzl(p_88.f3))
            { /* block id: 95 */
                int32_t l_178 = 0x01D58953;
                struct S0 l_179 = {19080,533,117,8,-2};
                l_166 ^= (p_88.f1 = l_165);
                l_178 = __builtin_bswap32(((uint16_t)((l_165 = (l_165 && (p_86 != p_88.f3))) | (p_88.f0 = ((((-1) == ((int16_t)l_161.f0 + (int16_t)p_88.f2)) | ((((func_100(func_105(l_171, l_172, (((uint16_t)(l_109.f0 = ((l_175 = l_171) , l_171.f1)) + (uint16_t)p_88.f0) , l_176)), p_87, l_172.f1, p_88.f4) , 0xD43CF306) , l_176.f1) && 5) > 0x98A8)) ^ l_112.f1))) - (uint16_t)l_177));
                p_88.f4 = (l_166 , (func_105(func_100(func_110(l_175), p_86, func_129(l_179, (l_171.f0 |= (p_87 = __builtin_popcount(l_176.f1))), ((((uint16_t)((func_105(l_175, (((int16_t)p_86 << (int16_t)0) , l_176), l_176) , l_165) && l_175.f0) + (uint16_t)p_88.f2) , 0) , 0U), p_88.f1), l_161.f1), l_176, l_176) , 0xAA7743CD));
                p_88.f2 = l_166;
            }
            else
            { /* block id: 107 */
                uint32_t l_197 = 0x15696D62;
                struct S0 l_198 = {-3341,-6052,145,0x4EA22E85,15};
                int32_t l_199 = 8;
                struct S2 l_207 = {-656,768};
                struct S1 l_221 = {239,10171};
                if ((l_112.f0 , (l_184 & __builtin_ia32_crc32qi(l_176.f0, ((uint16_t)((int32_t)l_184 % (int32_t)(l_199 &= (func_113(((0x2732 && (~((!l_184) < p_88.f4))) < (((uint32_t)(((uint32_t)(((uint32_t)l_175.f0 + (uint32_t)l_175.f0) & p_88.f2) - (uint32_t)0x0B106958) & p_88.f1) % (uint32_t)l_175.f1) && l_197)), p_88.f2, l_198) < l_198.f2))) << (uint16_t)9)))))
                { /* block id: 109 */
                    uint32_t l_213 = 0xFAE4BFFE;
                    int16_t l_229 = (-1);
                    p_88.f1 ^= __builtin_popcount((l_165 = (func_105(func_100(l_176, p_86, (p_88.f3 , (p_88.f2 , (l_197 , 0x179A8617))), ((p_87 , (l_112.f0 = ((uint32_t)l_112.f0 - (uint32_t)((uint32_t)((((l_199 |= ((int32_t)l_166 - (int32_t)l_112.f0)) > p_88.f4) | 2U) < l_165) % (uint32_t)l_206)))) , p_88.f0)), l_207, l_157) , 0x88709DC6)));
                    if (((uint16_t)p_88.f1 * (uint16_t)(((int32_t)func_129(p_88, (((!(p_88.f1 && 0x818B)) , l_184) , p_88.f0), p_86, l_198.f1) + (int32_t)l_213) || 0x614C)))
                    { /* block id: 114 */
                        l_109.f0 = l_161.f0;
                        l_172.f0 = l_171.f0;
                        l_172.f0 = ((func_113(l_175.f0, l_109.f0, l_214) >= ((int16_t)((((uint32_t)((uint16_t)p_87 << (uint16_t)13) + (uint32_t)0x33F7625D) >= (l_221 , (((uint16_t)(((l_171.f0 != (((((__builtin_clzll(((-(uint16_t)l_213) , l_214.f0)) ^ 1) == 7) & l_214.f4) & 0xB6A1) && p_88.f3)) , p_88.f0) < p_88.f0) * (uint16_t)0x9DA0) != p_88.f2))) >= p_88.f0) >> (int16_t)l_213)) > p_87);
                    }
                    else
                    { /* block id: 118 */
                        int16_t l_228 = 0x378E;
                        int32_t l_230 = 0x041E959A;
                        l_226 = l_225;
                        if (l_199)
                            break;
                        l_230 |= ((l_225.f4 ^= func_95(((((!l_157.f1) < (l_228 = (0x7C09 | (l_176 , 0x4E9D)))) != p_88.f4) , (l_229 , 4294967295U)), p_88.f1, l_175, l_171)) , p_87);
                        p_88.f2 = p_86;
                    }
                    p_88.f0 &= (l_198.f1 , ((uint16_t)(l_226.f0 |= (-(int32_t)((((0x86A49EC6 ^ p_88.f4) , ((int16_t)((int32_t)(l_172.f1 ^ ((int16_t)(l_225.f0 = p_86) + (int16_t)((l_165 || p_87) <= ((l_214.f0 <= (p_88.f2 = p_88.f1)) <= l_240)))) % (int32_t)0xDFD013E8) * (int16_t)0x2993)) < 0U) | p_86))) >> (uint16_t)l_161.f0));
                }
                else
                { /* block id: 130 */
                    struct S1 l_258 = {170,4622};
                    if (l_184)
                        break;
                    for (l_226.f3 = 13; (l_226.f3 < 13); l_226.f3 += 8)
                    { /* block id: 134 */
                        struct S1 l_257 = {903,2154};
                        int32_t l_260 = 0xE0442374;
                        l_260 &= ((((int16_t)((((uint16_t)(p_88.f0 ^ 0x939D09D1) << (uint16_t)0) & l_197) > (((int16_t)(l_198.f0 = (((int16_t)l_225.f2 - (int16_t)(l_198.f4 |= ((l_257.f0 = (l_207.f0 && ((uint16_t)((((uint16_t)(p_88.f0 && func_95(__builtin_clz(((uint32_t)(p_88.f1 | l_214.f1) - (uint32_t)l_225.f3)), l_172.f1, l_257, l_258)) << (uint16_t)p_88.f2) == p_88.f2) , 65535U) + (uint16_t)0x47C1))) | l_207.f0))) | l_214.f4)) * (int16_t)l_257.f1) > 1U)) % (int16_t)l_214.f4) >= p_88.f4) | l_259);
                        l_260 &= ((l_214.f1 = ((((((uint16_t)l_157.f1 >> (uint16_t)l_263) ^ __builtin_ctzll(l_257.f0)) ^ ((int16_t)p_88.f1 << (int16_t)(((!(((!p_88.f2) >= p_86) <= (l_214.f2 > p_88.f0))) > p_87) ^ l_257.f1))) == 0x94EEF04C) == 8U)) ^ l_226.f1);
                    }
                }
            }
        }
    }
    if (l_112.f0)
    { /* block id: 146 */
        int32_t l_275 = 1;
        struct S0 l_278 = {28507,-9015,1,-7,-27};
        p_88.f2 = ((uint16_t)p_88.f3 + (uint16_t)(l_109.f0 , ((uint32_t)(!((uint32_t)l_275 - (uint32_t)(((l_161.f0 = ((int16_t)func_129(l_278, ((p_88.f2 | (p_88 , l_112.f1)) , ((l_279 = (p_88.f2 , (l_157 = func_110((l_278 , l_161))))) , 0xBEBF25DA)), p_88.f3, l_278.f4) - (int16_t)p_88.f1)) >= p_88.f0) >= l_226.f4))) - (uint32_t)p_88.f3)));
        l_279.f0 = 0x82136C56;
    }
    else
    { /* block id: 152 */
        int32_t l_286 = (-1);
        struct S2 l_287 = {-515,1599};
        struct S0 l_290 = {-816,-9848,278,0x7EB04718,-0};
        struct S1 l_291 = {-365,5363};
        uint32_t l_307 = 0x60709DD3;
        struct S1 l_308 = {682,9609};
        l_290.f0 = ((((uint16_t)((((uint32_t)(((uint16_t)(l_286 = ((p_88.f2 > l_206) < ((__builtin_popcount(l_177) | (-4)) & l_286))) << (uint16_t)10) , (l_290.f2 = (func_113((((l_287 = l_287) , ((((p_88.f0 ^ 0xBC70) , l_290) , l_226.f3) == 0)) || 65535U), p_88.f3, p_88) || p_87))) + (uint32_t)l_290.f1) != l_290.f3) < l_290.f1) >> (uint16_t)13) != l_290.f3) != l_240);
        l_291 = l_291;
        p_88.f4 ^= ((uint32_t)(((uint16_t)l_109.f0 % (uint16_t)((int16_t)((((__builtin_bswap32(((uint16_t)((l_157.f0 > ((l_287.f0 = 0xE9E3D297) & (p_88.f2 &= ((-(int16_t)func_95(p_88.f0, ((int32_t)l_303 - (int32_t)(((-(int16_t)(-8)) , (((uint16_t)((l_307 == (__builtin_ffsll(p_87) ^ 0xDC43)) > p_88.f1) * (uint16_t)0x0B11) > 0x17C2)) | p_88.f3)), l_291, l_308)) , 0xFB92A9F2)))) < 0xE0D6846D) % (uint16_t)2)) ^ (-3)) != l_291.f1) || 0xCEA3) || 0xBD1F3727) >> (int16_t)l_109.f1)) || p_88.f0) - (uint32_t)p_86);
    }
    return l_303;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_95(uint32_t  p_96, int16_t  p_97, struct S1  p_98, struct S1  p_99)
{ /* block id: 86 */
    int32_t l_162 = 1;
    return l_162;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_100(struct S2  p_101, uint16_t  p_102, int32_t  p_103, uint32_t  p_104)
{ /* block id: 82 */
    int32_t l_159 = 0xEB54A4BB;
    struct S1 l_160 = {-475,246};
    l_159 = (-9);
    return l_160;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_105(struct S1  p_106, struct S2  p_107, struct S2  p_108)
{ /* block id: 79 */
    int16_t l_158 = 0;
    l_158 |= __builtin_clz(p_108.f1);
    return p_108;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S2  func_110(struct S1  p_111)
{ /* block id: 47 */
    uint32_t l_134 = 0xF9B9B769;
    struct S0 l_137 = {12547,7842,-37,0xBBA09B98,-1};
    struct S2 l_141 = {25,1598};
    int32_t l_145 = 0x2B5FF26A;
    struct S0 l_146 = {-5896,-1979,295,0x53E4EB4C,-10};
    p_111.f0 = func_113((((uint16_t)__builtin_clzl(p_111.f1) << (uint16_t)8) == ((uint16_t)(0x6CAF4455 >= ((l_137.f0 = ((!(((uint16_t)0U << (uint16_t)4) , func_124((func_129(((((((l_134 <= __builtin_bswap32(p_111.f0)) & ((int16_t)(p_111.f0 , (p_111.f0 || p_111.f0)) % (int16_t)0x1744)) , 0x3DEF630F) , l_134) < l_134) , l_137), p_111.f0, l_137.f2, p_111.f0) ^ l_137.f0), p_111.f1, p_111.f1, l_141))) == l_141.f1)) , l_137.f1)) - (uint16_t)l_134)), l_145, l_146);
    for (l_134 = 7; (l_134 <= 27); l_134 += 4)
    { /* block id: 70 */
        uint16_t l_154 = 1U;
        struct S2 l_156 = {-379,1720};
        if ((((uint16_t)((l_137.f1 = 0xBDBD) >= l_137.f2) * (uint16_t)l_154) != l_154))
        { /* block id: 72 */
            struct S2 l_155 = {-244,387};
            return l_155;
        }
        else
        { /* block id: 74 */
            return l_156;
        }
    }
    return l_141;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_113(uint16_t  p_114, uint32_t  p_115, struct S0  p_116)
{ /* block id: 57 */
    uint32_t l_149 = 0xA865B3CA;
    for (p_116.f3 = 0; (p_116.f3 > (-21)); p_116.f3 -= 1)
    { /* block id: 60 */
        p_116.f2 = ((0x664A1005 && p_116.f0) , (0xF7B8 <= (l_149 ^= p_116.f4)));
        return p_116.f2;
    }
    p_116.f1 = p_116.f2;
    return p_116.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_124(int16_t  p_125, uint16_t  p_126, int32_t  p_127, struct S2  p_128)
{ /* block id: 52 */
    uint32_t l_142 = 0U;
    int32_t l_143 = 0x389D4FE0;
    int32_t l_144 = 0x8E951F22;
    l_144 = (l_143 ^= l_142);
    return l_142;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_129(struct S0  p_130, uint32_t  p_131, uint32_t  p_132, int32_t  p_133)
{ /* block id: 48 */
    uint32_t l_138 = 0xA86FCAFA;
    int32_t l_139 = 0x0FDB04FC;
    int32_t l_140 = (-2);
    l_138 = p_133;
    l_140 = (l_139 != l_139);
    return l_139;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_35();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 70
   depth: 1, occurrence: 41
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 41
breakdown:
   indirect level: 0, occurrence: 41
XXX full-bitfields structs in the program: 28
breakdown:
   indirect level: 0, occurrence: 28
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 10
XXX times a bitfields struct on RHS: 71
XXX times a single bitfield on LHS: 48
XXX times a single bitfield on RHS: 153

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 14
   depth: 5, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 3
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 27, occurrence: 2
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 417
XXX times a non-volatile is write: 94
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 72
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 14
   depth: 2, occurrence: 12
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 22.2
XXX percentage an existing variable is used: 77.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

