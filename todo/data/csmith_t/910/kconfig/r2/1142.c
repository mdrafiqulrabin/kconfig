/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2609875960
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 10;
};

union U1 {
   int8_t * f0;
   int16_t  f1;
   uint32_t  f2;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2[8] = {(-1),(-4),(-1),(-1),(-4),(-1),(-1),(-4)};
static struct S0 g_28 = {19};
static int8_t g_32 = (-6);
static int8_t *g_31 = &g_32;
static int32_t g_78[5] = {0x1000BAF3,0x1000BAF3,0x1000BAF3,0x1000BAF3,0x1000BAF3};
static int32_t **g_84 = (void*)0;
static uint16_t g_99 = 3U;
static union U1 g_233 = {0};
static int32_t *** const *g_267 = (void*)0;
static struct S0 *g_314 = &g_28;
static struct S0 **g_313 = &g_314;
static union U1 *g_325[10][7] = {{(void*)0,&g_233,(void*)0,&g_233,&g_233,&g_233,&g_233},{&g_233,&g_233,&g_233,&g_233,&g_233,&g_233,&g_233},{&g_233,&g_233,&g_233,(void*)0,&g_233,&g_233,&g_233},{&g_233,&g_233,&g_233,&g_233,&g_233,&g_233,&g_233},{&g_233,&g_233,&g_233,&g_233,&g_233,&g_233,(void*)0},{(void*)0,(void*)0,&g_233,&g_233,&g_233,&g_233,(void*)0},{&g_233,&g_233,&g_233,&g_233,&g_233,&g_233,&g_233},{&g_233,(void*)0,(void*)0,&g_233,&g_233,&g_233,&g_233},{&g_233,&g_233,&g_233,&g_233,&g_233,&g_233,&g_233},{&g_233,&g_233,&g_233,&g_233,&g_233,&g_233,&g_233}};
static union U1 **g_324 = &g_325[7][2];
static const union U1 ***g_335[2] = {(void*)0,(void*)0};
static const union U1 ****g_334[5] = {&g_335[0],&g_335[0],&g_335[0],&g_335[0],&g_335[0]};
static int32_t *g_390[1][9] = {{&g_78[2],&g_78[2],&g_78[2],&g_78[2],&g_78[2],&g_78[2],&g_78[2],&g_78[2],&g_78[2]}};
static int32_t *g_431 = &g_78[0];
static union U1 ***g_588 = &g_324;
static int16_t g_710 = 0xC979;
static int8_t * const *g_773 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
inline static int32_t * func_5(int32_t  p_6, const int8_t * p_7, uint8_t  p_8);
inline static int32_t  func_13(int32_t  p_14);
inline static int32_t * func_17(int8_t * p_18, uint16_t  p_19, int8_t * p_20, int16_t  p_21);
static int8_t * func_22(int32_t  p_23, int32_t * p_24, int8_t  p_25);
inline static struct S0  func_41(const uint32_t  p_42, int32_t * p_43, int32_t  p_44, uint16_t  p_45, int32_t  p_46);
static int32_t * func_47(int32_t  p_48, int8_t  p_49, int32_t  p_50, struct S0  p_51, uint32_t  p_52);
inline static int32_t  func_57(uint8_t  p_58, uint32_t  p_59);
static int8_t  func_63(int32_t ** p_64, int8_t * p_65, int32_t  p_66, int16_t  p_67);
inline static int32_t ** func_68(int8_t * p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes: g_2 g_773
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    int8_t l_9[2][8][9] = {{{0x6D,0x4D,0x8D,0,0xEB,(-5),(-5),0xEB,0},{(-5),(-1),(-5),3,0xA0,0x4D,0xAD,0xEB,1},{(-1),0x8D,0x79,1,0xAD,0xAE,0,0xAE,0xAD},{3,0,0,3,0x8D,(-1),0xAE,0,0xAD},{0,(-5),(-7),0,(-5),1,0xA0,0xA0,1},{0x8D,0x49,3,0x49,0x8D,0,(-5),(-7),0},{0x8D,(-1),0xAE,0,0xAD,(-5),0xEB,0x4D,0xEB},{0,0xA0,0x6D,0x6D,0xA0,0,(-1),0x8D,0x79}},{{3,0xA0,0x4D,0xAD,0xEB,1,0x6D,0x49,0x49},{(-1),(-1),1,(-7),1,(-1),(-1),0x6D,0x4D},{(-5),0x49,1,(-1),(-7),0xAE,0xEB,(-1),0},{0x6D,(-5),0x4D,(-1),(-1),0x4D,(-5),0x6D,(-5)},{0x79,0,0x6D,(-1),3,(-5),0xA0,0x49,0xAE},{(-5),0x8D,0xAE,(-1),0x79,(-1),0xAE,0x8D,(-5)},{0xEB,(-1),3,(-7),0x79,0xA0,0,0x4D,0},{0x49,0x4D,(-7),0xAE,(-5),(-5),0xAE,0x6D,0}}};
    int32_t **l_755 = &g_390[0][7];
    int8_t l_769 = 0x42;
    int8_t **l_772 = &g_31;
    int8_t ***l_771[8][6] = {{(void*)0,&l_772,(void*)0,&l_772,(void*)0,&l_772},{&l_772,&l_772,&l_772,&l_772,&l_772,&l_772},{(void*)0,&l_772,(void*)0,&l_772,(void*)0,&l_772},{&l_772,&l_772,&l_772,&l_772,&l_772,&l_772},{(void*)0,&l_772,(void*)0,&l_772,(void*)0,&l_772},{&l_772,&l_772,&l_772,&l_772,&l_772,&l_772},{(void*)0,&l_772,(void*)0,&l_772,(void*)0,&l_772},{&l_772,&l_772,&l_772,&l_772,&l_772,&l_772}};
    uint32_t l_774 = 1U;
    int i, j, k;
    for (g_2[2] = 0; (g_2[2] > (-6)); g_2[2] = safe_sub_func_uint16_t_u_u(g_2[2], 1))
    { /* block id: 3 */
        const int8_t *l_10 = &l_9[1][4][1];
        int32_t **l_751 = &g_390[0][7];
        int32_t l_760 = 0xDEE12901;
        uint16_t l_770 = 5U;
    }
    /* facts after for loop */
    g_773 = (void*)0;
    return l_774;
}


/* ------------------------------------------ */
/* 
 * reads : g_32
 * writes: g_32
 */
inline static int32_t * func_5(int32_t  p_6, const int8_t * p_7, uint8_t  p_8)
{ /* block id: 349 */
    int8_t l_742 = 0xA2;
    struct S0 l_748 = {4};
    int32_t *l_749 = &g_2[3];
    for (g_32 = 0; (g_32 <= (-20)); g_32--)
    { /* block id: 352 */
        uint8_t l_728 = 1U;
        struct S0 *l_747[1];
        int32_t **l_750 = &l_749;
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_747[i] = &g_28;
        (*l_750) = l_749;
    }
    return l_749;
    /* statement id: 355 */
    //assert ((func_5_rv >= &g_2[0] && func_5_rv <= &g_2[7]));
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_31 g_28.f0 g_32 g_28 g_78 g_99 g_267 g_313 g_324 g_84 g_334 g_325 g_390 g_431 g_314
 * writes: g_28 g_78 g_314 g_325 g_99 g_390 g_32 g_84 g_431
 */
inline static int32_t  func_13(int32_t  p_14)
{ /* block id: 4 */
    struct S0 l_15[8][5][4] = {{{{28},{1},{11},{29}},{{12},{21},{13},{21}},{{21},{11},{28},{21}},{{28},{21},{29},{29}},{{1},{1},{13},{12}}},{{{1},{11},{29},{1}},{{28},{12},{28},{29}},{{21},{12},{13},{1}},{{12},{11},{11},{12}},{{28},{1},{11},{29}}},{{{12},{21},{13},{21}},{{21},{11},{28},{21}},{{28},{21},{29},{29}},{{1},{1},{13},{12}},{{1},{11},{29},{1}}},{{{28},{12},{28},{29}},{{21},{12},{13},{1}},{{12},{11},{11},{12}},{{28},{1},{11},{29}},{{12},{21},{13},{21}}},{{{21},{11},{28},{21}},{{28},{21},{29},{29}},{{1},{1},{13},{12}},{{1},{11},{29},{1}},{{28},{12},{28},{29}}},{{{21},{12},{13},{1}},{{12},{11},{11},{12}},{{28},{1},{11},{29}},{{12},{21},{13},{21}},{{21},{11},{28},{21}}},{{{28},{21},{29},{29}},{{1},{1},{13},{12}},{{1},{11},{29},{1}},{{28},{12},{28},{29}},{{29},{11},{1},{28}}},{{{11},{13},{13},{11}},{{14},{28},{13},{20}},{{11},{29},{1},{29}},{{29},{13},{14},{29}},{{14},{29},{20},{20}}}};
    struct S0 *l_16 = &l_15[1][3][1];
    int32_t *l_26 = &g_2[2];
    int32_t **l_723[7][10] = {{&g_431,(void*)0,&l_26,&g_431,&l_26,&g_390[0][8],&g_390[0][5],&g_390[0][8],&l_26,&g_431},{&g_431,&g_390[0][8],&g_431,&l_26,&g_431,&g_390[0][5],&g_431,&l_26,&l_26,&g_431},{&g_390[0][5],&g_431,&l_26,&l_26,&g_431,&g_431,&l_26,&l_26,&g_431,&g_390[0][5]},{(void*)0,(void*)0,&g_431,(void*)0,&l_26,&g_431,&l_26,&g_390[0][8],&g_390[0][5],&g_390[0][8]},{(void*)0,&g_431,&l_26,(void*)0,&l_26,&g_431,(void*)0,&g_431,&l_26,&g_390[0][5]},{&l_26,&l_26,&g_431,&l_26,&g_431,&g_431,(void*)0,(void*)0,&g_431,&g_431},{&l_26,&l_26,&l_26,&l_26,&g_431,&l_26,(void*)0,&g_390[0][5],&g_390[0][2],&g_431}};
    int32_t l_724 = (-6);
    int i, j, k;
    (*l_16) = l_15[1][1][2];
    g_431 = func_17(func_22(g_2[2], l_26, (*l_26)), g_2[2], &g_32, (safe_add_func_uint8_t_u_u(p_14, (((safe_mod_func_int32_t_s_s((safe_lshift_func_uint8_t_u_u(g_28.f0, (*l_26))), 6)) == 0) != (*l_26)))));
    /* statement id: 347 */
    assert (g_314 == &g_28 || g_314 == 0);
    //assert (g_390[0][0] == 0 || (g_390[0][0] >= &g_78[0] && g_390[0][0] <= &g_78[4]) || (g_390[0][0] >= &g_2[0] && g_390[0][0] <= &g_2[7]) || g_390[0][0] == dangling);
    return l_724;
}


/* ------------------------------------------ */
/* 
 * reads : g_32 g_28.f0 g_28 g_2 g_78 g_31 g_99 g_267 g_313 g_324 g_84 g_334 g_325 g_390 g_431 g_314
 * writes: g_28 g_78 g_314 g_325 g_99 g_390 g_32 g_84
 */
inline static int32_t * func_17(int8_t * p_18, uint16_t  p_19, int8_t * p_20, int16_t  p_21)
{ /* block id: 10 */
    int32_t *l_39 = (void*)0;
    int32_t **l_40 = &l_39;
    int8_t *l_56 = (void*)0;
    int8_t l_61 = 0;
    struct S0 l_118 = {25};
    (*l_40) = l_39;
    l_118 = func_41(p_19, func_47(p_19, (safe_lshift_func_int16_t_s_s(0, ((!(l_56 != l_56)) || (*p_18)))), func_57((g_32 != (~l_61)), g_28.f0), l_118, p_21), p_21, g_2[5], p_21);
    /* statement id: 345 */
    assert (g_314 == &g_28 || g_314 == 0);
    //assert (g_390[0][0] == 0 || (g_390[0][0] >= &g_78[0] && g_390[0][0] <= &g_78[4]) || (g_390[0][0] >= &g_2[0] && g_390[0][0] <= &g_2[7]) || g_390[0][0] == dangling);
    return &g_78[2];
    /* statement id: 346 */
    //assert ((func_17_rv >= &g_78[0] && func_17_rv <= &g_78[4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_31
 * writes:
 */
static int8_t * func_22(int32_t  p_23, int32_t * p_24, int8_t  p_25)
{ /* block id: 6 */
    struct S0 *l_27 = &g_28;
    int32_t *l_29 = (void*)0;
    int32_t l_30 = 0x9FA9EF81;
    p_23 = (l_27 == l_27);
    p_23 = (l_30 || 0xC1477A14);
    return g_31;
    /* statement id: 9 */
    //assert (func_22_rv == &g_32);
}


/* ------------------------------------------ */
/* 
 * reads : g_99 g_78 g_28.f0 g_431 g_32 g_2 g_313 g_314 g_31 g_28 g_84
 * writes: g_78 g_32 g_390 g_99 g_314 g_28 g_84
 */
inline static struct S0  func_41(const uint32_t  p_42, int32_t * p_43, int32_t  p_44, uint16_t  p_45, int32_t  p_46)
{ /* block id: 211 */
    int32_t l_477 = 0x7B47D256;
    union U1 * const *l_496 = &g_325[7][2];
    union U1 * const **l_495 = &l_496;
    union U1 * const ***l_494[6] = {&l_495,(void*)0,(void*)0,&l_495,(void*)0,(void*)0};
    struct S0 l_501 = {24};
    int32_t ***l_511 = &g_84;
    int32_t l_607 = 0x4AFA983C;
    uint8_t l_623 = 0x9E;
    uint32_t l_631 = 3U;
    int8_t l_711[4] = {4,4,4,4};
    union U1 ***l_718 = &g_324;
    union U1 ***l_719 = &g_324;
    int32_t ***l_722 = &g_84;
    int i;
    for (p_46 = 1; (p_46 >= 0); p_46 -= 1)
    { /* block id: 214 */
        int8_t l_478 = 0;
        (*g_431) = (safe_mul_func_uint8_t_u_u((((safe_div_func_int8_t_s_s((safe_div_func_uint8_t_u_u(p_45, 0xB7)), 0x7D)) <= (safe_unary_minus_func_uint16_t_u(((g_99 && (safe_mul_func_uint8_t_u_u(0x46, p_46))) & p_46)))) == (5U || (safe_mul_func_int8_t_s_s((safe_lshift_func_int16_t_s_s(l_477, g_78[2])), l_478)))), g_28.f0));
    }
    if ((~(safe_lshift_func_int8_t_s_u(((6U > (safe_lshift_func_int8_t_s_s(((0xEB && (safe_rshift_func_uint16_t_u_s((safe_mul_func_int8_t_s_s((safe_div_func_int32_t_s_s((0x427D | (g_28.f0 >= ((((safe_add_func_int32_t_s_s(((void*)0 != l_494[5]), 4294967288U)) & (safe_sub_func_int16_t_s_s(l_477, 0xC3E4))) & l_477) != 0x99D08253))), g_32)), l_477)), p_42))) >= (-5)), l_477))) != p_46), p_45))))
    { /* block id: 217 */
        for (l_477 = 28; (l_477 > (-8)); --l_477)
        { /* block id: 220 */
            struct S0 l_502 = {9};
            l_502 = l_501;
            if ((*g_431))
                break;
        }
    }
    else
    { /* block id: 224 */
        struct S0 *l_505 = &l_501;
        int32_t ***l_510 = &g_84;
        union U1 ***l_549[3][4] = {{&g_324,&g_324,&g_324,&g_324},{&g_324,&g_324,&g_324,&g_324},{&g_324,&g_324,&g_324,&g_324}};
        int i, j;
lbl_528:
        if (((safe_mod_func_uint16_t_u_u(((((void*)0 != l_505) & (safe_add_func_uint16_t_u_u(l_477, (l_477 <= l_501.f0)))) != (p_46 < (safe_add_func_int16_t_s_s((((l_510 == l_511) < (safe_rshift_func_uint8_t_u_u(g_2[2], g_2[7]))) < 65535U), 0xE7A1)))), p_42)) | 4294967293U))
        { /* block id: 225 */
            (*g_431) = (safe_lshift_func_uint16_t_u_s((g_78[2] && (p_43 != p_43)), 7));
        }
        else
        { /* block id: 227 */
            struct S0 l_525[3] = {{31},{31},{31}};
            int32_t *l_526 = &l_477;
            int32_t **l_527 = &l_526;
            int i;
            for (p_44 = (-16); (p_44 > 17); p_44 = safe_add_func_int8_t_s_s(p_44, 1))
            { /* block id: 230 */
                for (g_32 = 0; (g_32 < (-13)); g_32--)
                { /* block id: 233 */
                    for (p_45 = 5; (p_45 < 16); p_45 = safe_add_func_uint16_t_u_u(p_45, 1))
                    { /* block id: 236 */
                        struct S0 l_522 = {18};
                        (*l_505) = l_522;
                    }
                }
                g_390[0][7] = p_43;
                if (p_45)
                    goto lbl_528;
            }
            (*l_527) = l_526;
            (*l_505) = l_501;
        }
        (*g_431) = (safe_sub_func_int16_t_s_s(g_99, (safe_div_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_int16_t_s_s(((*g_431) && p_44), (safe_mod_func_int8_t_s_s(((safe_rshift_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((safe_mul_func_uint8_t_u_u(((((safe_mod_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u((((*g_313) == l_505) & g_2[3]), (p_42 < (0x01AF > (l_549[0][1] == l_549[0][1]))))), 0x07)) && 1U) & 0xCAD12B6D) > l_477), p_44)), 0xF5D1)), 2)) > p_45), (-5))))) | p_45), 2)), 0x9B539028))));
    }
    /* facts after branching */
    //assert (g_390[0][0] == 0 || (g_390[0][0] >= &g_78[0] && g_390[0][0] <= &g_78[4]) || (g_390[0][0] >= &g_2[0] && g_390[0][0] <= &g_2[7]) || g_390[0][0] == dangling);
    if ((safe_mul_func_int16_t_s_s((safe_div_func_uint16_t_u_u(g_28.f0, 0xE0FF)), 65535U)))
    { /* block id: 248 */
        uint32_t l_558[10][7][3] = {{{0U,8U,0x4188C375},{0U,0xD17459A9,0U},{4294967295U,0x5E591BB0,1U},{1U,0xD17459A9,0x63C681DB},{0x76D82210,8U,4294967292U},{4U,0x9C3CC93B,0U},{0x76D82210,4294967295U,0x71FCBE8D}},{{1U,4294967295U,0x2C602348},{4294967295U,8U,0x71FCBE8D},{0U,0x9BF1A73D,0U},{0U,0x5E591BB0,4294967292U},{1U,0x9BF1A73D,0x63C681DB},{0x53D8A287,8U,1U},{4U,4294967295U,0U}},{{0x53D8A287,4294967295U,0x4188C375},{1U,0x9C3CC93B,0x2C602348},{0U,8U,0x4188C375},{0U,0xD17459A9,0U},{4294967295U,0x5E591BB0,1U},{1U,0xD17459A9,0x63C681DB},{0x76D82210,8U,4294967292U}},{{4U,0x9C3CC93B,0U},{0x76D82210,4294967295U,0x71FCBE8D},{1U,4294967295U,0x2C602348},{0x653B0071,0x53D8A287,0xE602DE46},{0x436AAF7C,0x703EC121,0x436AAF7C},{4294967295U,0x4188C375,4294967288U},{4294967295U,0x703EC121,6U}},{{4294967289U,0x53D8A287,0U},{1U,6U,0x436AAF7C},{4294967289U,0x71FCBE8D,0U},{4294967295U,0x91FA4E18,1U},{4294967295U,0x53D8A287,0U},{0x436AAF7C,0x300B62B6,0x436AAF7C},{0x653B0071,0x4188C375,0U}},{{4294967295U,0x300B62B6,6U},{4294967291U,0x53D8A287,4294967288U},{1U,0x91FA4E18,0x436AAF7C},{4294967291U,0x71FCBE8D,0xE602DE46},{4294967295U,6U,1U},{0x653B0071,0x53D8A287,0xE602DE46},{0x436AAF7C,0x703EC121,0x436AAF7C}},{{4294967295U,0x4188C375,4294967288U},{4294967295U,0x703EC121,6U},{4294967289U,0x53D8A287,0U},{1U,6U,0x436AAF7C},{4294967289U,0x71FCBE8D,0U},{4294967295U,0x91FA4E18,1U},{4294967295U,0x53D8A287,0U}},{{0x436AAF7C,0x300B62B6,0x436AAF7C},{0x653B0071,0x4188C375,0U},{4294967295U,0x300B62B6,6U},{4294967291U,0x53D8A287,4294967288U},{1U,0x91FA4E18,0x436AAF7C},{4294967291U,0x71FCBE8D,0xE602DE46},{4294967295U,6U,1U}},{{0x653B0071,0x53D8A287,0xE602DE46},{0x436AAF7C,0x703EC121,0x436AAF7C},{4294967295U,0x4188C375,4294967288U},{4294967295U,0x703EC121,6U},{4294967289U,0x53D8A287,0U},{1U,6U,0x436AAF7C},{4294967289U,0x71FCBE8D,0U}},{{4294967295U,0x91FA4E18,1U},{4294967295U,0x53D8A287,0U},{0x436AAF7C,0x300B62B6,0x436AAF7C},{0x653B0071,0x4188C375,0U},{4294967295U,0x300B62B6,6U},{4294967291U,0x53D8A287,4294967288U},{1U,0x91FA4E18,0x436AAF7C}}};
        union U1 ** const *l_577[10];
        int32_t *l_596[9][6] = {{&g_2[1],&g_2[2],(void*)0,&g_78[4],&l_477,(void*)0},{&g_2[1],&g_78[1],&g_78[4],(void*)0,&g_78[1],&g_78[4]},{&g_78[4],&g_2[2],&g_78[2],(void*)0,&g_78[2],(void*)0},{&g_2[1],&g_78[2],&g_2[1],&g_78[4],&g_2[2],&g_78[2]},{&g_2[1],&g_78[2],&g_2[0],(void*)0,&g_78[2],(void*)0},{&g_78[4],&g_78[2],(void*)0,(void*)0,&l_477,&g_78[4]},{&g_2[1],&l_477,&g_78[4],&g_78[4],&g_78[2],&g_78[2]},{&g_2[1],&g_2[2],(void*)0,(void*)0,&g_2[2],&g_2[1]},{&g_78[4],&l_477,&g_78[2],(void*)0,&g_2[2],&g_78[1]}};
        struct S0 l_657 = {4};
        int8_t *l_704 = &g_32;
        int i, j, k;
        for (i = 0; i < 10; i = i + 1)
            l_577[i] = &g_324;
lbl_681:
        for (l_477 = (-14); (l_477 < 1); l_477 = safe_add_func_int32_t_s_s(l_477, 1))
        { /* block id: 251 */
            union U1 **l_570[2];
            uint32_t l_578 = 0x874411FA;
            int32_t l_579 = 0xEACAC37D;
            uint16_t l_622 = 0U;
            int i;
            for (i = 0; i < 2; i = i + 1)
                l_570[i] = &g_325[7][6];
            l_579 = (safe_mul_func_int8_t_s_s((l_558[4][6][2] == ((safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((safe_mod_func_uint8_t_u_u((safe_unary_minus_func_int32_t_s((((l_558[9][3][2] >= (safe_mul_func_int8_t_s_s(p_46, ((safe_mul_func_uint8_t_u_u((g_32 == (l_570[0] != (*l_495))), (safe_div_func_uint16_t_u_u((((l_558[4][6][2] && ((safe_mul_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s((0x5A == (&l_570[0] == l_577[0])), 9)), 254U)) <= p_42)) && 0xA7) == l_558[4][6][2]), 0x3C2E)))) < l_578)))) ^ l_578) ^ g_78[1]))), 0xAF)), 3)), l_558[5][4][2])) <= (-3))), l_558[4][6][2]));
        }
        for (g_32 = 6; (g_32 >= 0); g_32 -= 1)
        { /* block id: 295 */
            uint16_t l_626 = 0x828E;
            union U1 ***l_632[10] = {&g_324,&g_324,&g_324,&g_324,&g_324,&g_324,&g_324,&g_324,&g_324,&g_324};
            int32_t **l_641 = &g_390[0][7];
            struct S0 l_656 = {15};
            int32_t l_687 = 0x805347CB;
            int i;
            if (p_46)
                break;
            (*g_431) = 0;
            if ((((~l_626) == (safe_lshift_func_int8_t_s_s((safe_mod_func_int32_t_s_s(l_631, 3)), (((l_577[9] != l_632[2]) < (g_32 | ((-1) != (safe_lshift_func_uint16_t_u_s(g_78[2], 2))))) | p_46)))) >= l_626))
            { /* block id: 298 */
                struct S0 *l_652[2];
                int32_t l_655 = 1;
                int32_t ****l_684 = (void*)0;
                int32_t ****l_685 = (void*)0;
                int32_t ****l_686 = &l_511;
                int i;
                for (i = 0; i < 2; i = i + 1)
                    l_652[i] = (void*)0;
                (*g_431) = (safe_lshift_func_uint16_t_u_u((safe_mul_func_int8_t_s_s((safe_mul_func_int16_t_s_s((((void*)0 != &p_43) == (((l_641 != l_641) & p_44) & (((safe_mod_func_int32_t_s_s((((safe_rshift_func_int8_t_s_u((safe_lshift_func_uint16_t_u_s((safe_mod_func_int16_t_s_s((safe_div_func_uint16_t_u_u(((*g_313) == l_652[1]), (safe_lshift_func_int16_t_s_s(g_32, (0x528A50D8 > 0x9859092F))))), g_99)), p_45)), 2)) <= p_44) < 0x8B0A664F), p_42)) & 5U) || l_655))), g_2[2])), g_99)), 15));
                for (p_46 = 4; (p_46 >= 0); p_46 -= 1)
                { /* block id: 302 */
                    l_657 = l_656;
                    if ((*g_431))
                        break;
                    if ((*g_431))
                        continue;
                    (*g_431) = (safe_mod_func_uint8_t_u_u((((*g_31) | (~((((*g_31) == p_45) || ((void*)0 == (*g_313))) == p_45))) || (safe_unary_minus_func_uint16_t_u((((~g_78[4]) | g_78[2]) != (p_45 & 0x77))))), p_45));
                }
                for (g_99 = 0; (g_99 <= 2); g_99 += 1)
                { /* block id: 310 */
                    int8_t *l_677 = &g_32;
                    int32_t l_680 = 0xAD2FD9D4;
                    struct S0 l_683 = {12};
                    l_680 = ((safe_add_func_uint16_t_u_u(0xAFE2, ((safe_mod_func_int32_t_s_s((safe_mod_func_int32_t_s_s(9, ((safe_lshift_func_uint8_t_u_u(0U, (((safe_mul_func_uint16_t_u_u(((((safe_rshift_func_int16_t_s_u(g_99, (((l_677 == (void*)0) || (g_32 & p_45)) | (((safe_add_func_uint8_t_u_u(g_28.f0, (*g_31))) || 1) == l_680)))) && l_655) <= 0x2367ABED) == p_46), g_99)) <= 0xB1) < g_28.f0))) | p_42))), p_44)) < 1U))) == 0x500A7374);
                    (*g_313) = l_652[1];
                    /* statement id: 312 */
                    assert (g_314 == 0);
                    for (l_631 = 0; (l_631 <= 1); l_631 += 1)
                    { /* block id: 315 */
                        struct S0 l_682 = {10};
                        if (l_680)
                            goto lbl_681;
                        p_43 = p_43;
                        l_683 = l_682;
                    }
                }
                (*l_686) = &l_641;
                /* statement id: 321 */
                assert (l_511 == &l_641);
            }
            else
            { /* block id: 322 */
                (*l_641) = p_43;
            }
            /* facts after branching */
            //assert (l_511 == &g_84 || l_511 == dangling || l_511 == &l_641);
            l_687 = (*g_431);
            for (l_687 = 0; (l_687 <= 6); l_687 += 1)
            { /* block id: 328 */
                int32_t **l_696 = &g_431;
                int32_t l_705 = (-10);
            }
        }
        for (l_477 = 4; (l_477 == (-11)); l_477 = safe_sub_func_int32_t_s_s(l_477, 1))
        { /* block id: 337 */
            int32_t l_708 = 0x01141246;
            l_708 = p_44;
        }
    }
    else
    { /* block id: 340 */
        union U1 ** const *l_709 = (void*)0;
        uint8_t l_716[4][10][6] = {{{255U,0x85,255U,1U,0x03,1U},{6U,0xC6,255U,0x66,1U,0U},{0U,6U,1U,0x0F,0x6F,255U},{0x0F,0x6F,255U,1U,0U,1U},{0U,0x66,252U,0U,1U,1U},{0x0B,0U,255U,0U,0U,255U},{0x85,0x85,1U,0xB4,255U,0U},{0U,0x0B,255U,0U,0x57,1U},{0x66,0U,255U,0x0F,0x85,0U},{0x6F,0x0F,1U,6U,0U,255U}},{{6U,0U,255U,0U,0xB4,1U},{0xC6,6U,252U,0x6F,0x85,1U},{0x85,255U,255U,0x57,0x03,255U},{1U,0x0B,1U,0U,0x08,0U},{0xC6,1U,255U,0U,0U,1U},{0x0F,255U,255U,6U,0x0B,0U},{0xB4,0x66,1U,0x66,0xB4,255U},{0x66,0xB4,255U,0U,0x6F,1U},{255U,0x0F,252U,0xB4,0x0B,1U},{1U,0xC6,255U,0x03,0x57,255U}},{{0x0B,1U,1U,0x6F,0x8B,0U},{255U,0x85,255U,1U,0x03,1U},{6U,0xC6,255U,0x66,1U,0U},{0U,6U,1U,0x0F,0x6F,255U},{0x0F,0x6F,255U,1U,0U,1U},{0U,0x66,252U,0U,1U,1U},{0x0B,0U,255U,0U,0U,255U},{0x85,0x85,1U,0xB4,255U,0U},{0U,0x0B,255U,0U,0x57,1U},{0x66,0U,255U,0x0F,0x85,0U}},{{0xDC,255U,0x85,0U,0x6A,0U},{0U,0x6A,0U,0x2A,0xBB,255U},{0x79,0U,0x8B,0xDC,0x5E,255U},{0x5E,0xFD,0U,249U,0U,0U},{0x77,255U,0x85,0x6A,0U,0U},{0x79,0x77,0x6F,1U,0x9B,0x85},{255U,0xFD,0x6F,0U,255U,0U},{0xBB,0x32,0x85,0x32,0xBB,0U},{0x32,0xBB,0U,1U,0xDC,255U},{0xFD,255U,0x8B,0xBB,255U,255U}}};
        int32_t **l_717[4][1];
        int i, j, k;
        for (i = 0; i < 4; i = i + 1)
        {
            for (j = 0; j < 1; j = j + 1)
                l_717[i][j] = &g_390[0][7];
        }
        g_390[0][3] = &g_78[2];
    }
    /* facts after branching */
    //assert (l_511 == &g_84 || l_511 == dangling);
    (*l_722) = func_68(func_22((l_718 == l_719), p_43, (safe_mul_func_int8_t_s_s(((void*)0 == p_43), ((void*)0 == p_43)))));
    return l_501;
}


/* ------------------------------------------ */
/* 
 * reads : g_28.f0 g_78 g_31 g_32 g_2 g_28 g_99 g_267 g_313 g_324 g_84 g_334 g_325 g_390 g_431
 * writes: g_28 g_78 g_314 g_325 g_99 g_390
 */
static int32_t * func_47(int32_t  p_48, int8_t  p_49, int32_t  p_50, struct S0  p_51, uint32_t  p_52)
{ /* block id: 54 */
    int32_t *l_121 = &g_78[2];
    int8_t *l_138 = &g_32;
    uint32_t l_157[4][8] = {{4294967295U,0x9CA7B657,4294967295U,4294967295U,4294967294U,4294967295U,0x5E5C7849,0x5E5C7849},{0x5E5C7849,0x71F1E863,4294967286U,4294967286U,0x71F1E863,0x5E5C7849,4294967294U,0x0ACBBF45},{0x5E5C7849,4294967287U,0x5692BD29,0x71F1E863,4294967294U,0x71F1E863,0x5692BD29,4294967287U},{4294967295U,0x5692BD29,4294967295U,0x71F1E863,0x0ACBBF45,4294967295U,4294967295U,0x0ACBBF45}};
    union U1 *l_232 = &g_233;
    uint32_t l_274 = 1U;
    union U1 *** const l_319 = (void*)0;
    struct S0 *l_331 = &g_28;
    int32_t *l_332 = &g_78[2];
    uint32_t l_432 = 0x2AF201FA;
    const union U1 * const *l_446[6];
    int i, j;
    for (i = 0; i < 6; i = i + 1)
        l_446[i] = (void*)0;
    if (((((0x79 == (l_121 == l_121)) & (!(((g_28.f0 != (safe_mul_func_int16_t_s_s((&l_121 != &l_121), (safe_rshift_func_int16_t_s_s(((safe_div_func_uint32_t_u_u((((safe_rshift_func_int16_t_s_u((safe_add_func_uint16_t_u_u(g_78[2], (~(safe_lshift_func_int16_t_s_s(((safe_mul_func_uint8_t_u_u(((void*)0 != l_138), 0x2E)) != 249U), (*l_121)))))), 15)) && (*g_31)) ^ 4294967291U), 0x964D50EE)) | p_51.f0), 9))))) | (*l_121)) < p_51.f0))) && 0xE0600665) < (*g_31)))
    { /* block id: 55 */
        int16_t l_139 = 0x714D;
        uint32_t l_158 = 0xAE6EC67F;
        int32_t **l_188 = (void*)0;
        union U1 *l_235 = &g_233;
        uint16_t l_275 = 0x69E2;
        struct S0 *l_311 = &g_28;
        uint8_t l_327[10][10][2] = {{{1U,0U},{0U,249U},{250U,3U},{0xA7,0x0E},{0x3D,0xBB},{252U,255U},{1U,0x94},{3U,255U},{0xA9,255U},{0xA1,247U}},{{0U,0x48},{0xAE,0U},{247U,249U},{253U,0xAE},{255U,0U},{0U,0xF9},{0x35,252U},{0xCD,255U},{1U,0U},{0x98,0xB5}},{{1U,1U},{249U,0x47},{0x19,4U},{255U,0x52},{0xD4,0xF1},{0x0E,0x5A},{0U,0x3F},{0xF5,0x11},{0x52,0x8C},{3U,0xA1}},{{0x0C,0x46},{1U,7U},{0xBB,253U},{0x4F,2U},{0x47,0xF5},{0xB5,248U},{0x50,255U},{5U,0U},{0x8C,4U},{247U,0x3D}},{{4U,0x3D},{247U,4U},{0x8C,0U},{5U,255U},{0x50,248U},{0xB5,0xF5},{0x47,2U},{0x4F,253U},{0xBB,7U},{2U,255U}},{{255U,0x5A},{0U,0x94},{0x3C,1U},{0U,0U},{255U,0x8C},{0xF0,0xA7},{4U,0x3C},{7U,0x0C},{252U,0x0E},{0x50,0x98}},{{0x52,0x47},{0x1C,0xD4},{0x3D,7U},{0U,0x54},{255U,255U},{255U,1U},{0xBB,0x46},{0x11,0x50},{255U,247U},{0x46,0x2C}},{{3U,0xCA},{0x5A,1U},{0U,0x4F},{3U,0xA1},{0U,249U},{0x54,1U},{0U,0xF0},{0xA9,0U},{0U,0x48},{249U,249U}},{{5U,0U},{247U,2U},{0xCD,1U},{0xF5,0xCD},{0xD4,255U},{0xD4,0xCD},{0xF5,1U},{0xCD,2U},{247U,0U},{5U,249U}},{{249U,0x48},{0U,0U},{0xA9,0xF0},{0U,1U},{0x54,249U},{0U,0xA1},{3U,0x4F},{0U,1U},{0x5A,0xCA},{3U,0x2C}}};
        int32_t **l_330 = (void*)0;
        int i, j, k;
        if ((l_139 & (safe_mod_func_uint16_t_u_u(0x4987, (safe_lshift_func_int16_t_s_s(((safe_lshift_func_uint8_t_u_s((safe_add_func_uint32_t_u_u((safe_unary_minus_func_uint32_t_u((((safe_add_func_uint32_t_u_u((((safe_lshift_func_uint16_t_u_u(((safe_div_func_int8_t_s_s((*l_121), (((void*)0 == &p_49) & p_52))) && (((safe_rshift_func_uint16_t_u_u((p_51.f0 <= (4294967293U >= 0)), 6)) > g_32) | (*l_121))), (*l_121))) ^ 8U) != g_2[5]), 0U)) > l_139) & l_139))), l_157[1][7])), 7)) != g_78[2]), l_158))))))
        { /* block id: 56 */
            struct S0 *l_159 = &g_28;
            int32_t l_183 = 0x4843688B;
            union U1 *l_249 = &g_233;
            int32_t ***l_255 = &l_188;
            int32_t *l_269[8];
            struct S0 **l_315 = &l_159;
            union U1 **l_317 = &l_249;
            union U1 ***l_316 = &l_317;
            int i;
            for (i = 0; i < 8; i = i + 1)
                l_269[i] = &g_78[0];
            (*l_159) = g_28;
            for (p_49 = 0; (p_49 != 12); p_49 = safe_add_func_uint8_t_u_u(p_49, 1))
            { /* block id: 60 */
                uint32_t l_169 = 1U;
                int32_t *l_182 = &g_78[2];
                if (g_32)
                    break;
                if ((safe_mul_func_uint16_t_u_u((safe_add_func_uint8_t_u_u((safe_unary_minus_func_uint16_t_u(((safe_sub_func_int8_t_s_s(l_169, l_158)) & (safe_sub_func_int32_t_s_s((p_48 | (safe_add_func_int16_t_s_s((((-1) < (safe_lshift_func_int8_t_s_s(((g_78[3] > ((safe_add_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((((0xC658C38B != (safe_sub_func_uint8_t_u_u((((&p_48 == l_182) != (*l_182)) | 65535U), g_2[3]))) != 2U) || g_2[3]), g_78[3])), 0U)) != (*l_121))) >= l_139), 4))) ^ l_139), g_32))), l_183))))), l_158)), (-1))))
                { /* block id: 62 */
                    int32_t *l_200 = (void*)0;
                    if ((safe_sub_func_int16_t_s_s((safe_mul_func_int16_t_s_s((l_188 != l_188), l_183)), (((safe_unary_minus_func_uint8_t_u((((*l_121) & ((safe_div_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((safe_div_func_int32_t_s_s((safe_add_func_int16_t_s_s((0x1803 > 2U), (safe_mod_func_uint16_t_u_u((*l_121), (g_99 | ((l_200 == (void*)0) ^ 0x92)))))), 0x98D0BA58)) == g_99), 5)), p_52)) < p_52)) > 0xF89493EA))) || p_52) >= p_51.f0))))
                    { /* block id: 63 */
                        (*l_121) = (&p_51 != &p_51);
                        (*l_121) = p_50;
                    }
                    else
                    { /* block id: 66 */
                        (*l_121) = (safe_mod_func_int32_t_s_s((safe_div_func_int16_t_s_s(((((safe_lshift_func_uint8_t_u_u(((p_50 | (0xB1 | (p_51.f0 | ((safe_mul_func_uint8_t_u_u((((p_52 <= (safe_mul_func_int8_t_s_s((safe_rshift_func_uint8_t_u_s(((void*)0 != &p_51), 4)), p_49))) > (safe_mod_func_int16_t_s_s(((void*)0 == &p_49), 0xE011))) || 0x9F09), p_49)) >= g_78[2])))) >= (*l_121)), g_2[2])) != g_99) > p_49) >= 250U), p_49)), 4294967294U));
                    }
                    (*l_121) = (safe_sub_func_int16_t_s_s(p_50, ((void*)0 != &p_51)));
                }
                else
                { /* block id: 70 */
                    int32_t **l_217[9][9] = {{&l_121,&l_121,&l_121,&l_182,&l_182,(void*)0,&l_182,(void*)0,&l_182},{&l_121,&l_121,&l_121,&l_121,&l_121,&l_182,&l_121,&l_182,&l_121},{&l_182,&l_121,&l_121,&l_121,&l_121,&l_182,(void*)0,&l_121,(void*)0},{&l_121,&l_182,&l_182,&l_121,&l_121,&l_182,&l_182,&l_121,&l_182},{(void*)0,&l_121,(void*)0,(void*)0,&l_182,&l_182,(void*)0,(void*)0,&l_121},{&l_121,&l_121,&l_182,&l_182,&l_121,&l_121,&l_121,&l_121,&l_182},{&l_182,&l_182,&l_182,(void*)0,(void*)0,(void*)0,&l_182,&l_182,(void*)0},{&l_182,&l_121,&l_121,&l_121,&l_182,&l_182,&l_121,&l_121,&l_121},{(void*)0,&l_121,(void*)0,(void*)0,(void*)0,&l_121,(void*)0,(void*)0,&l_182}};
                    union U1 **l_242 = &l_232;
                    int i, j;
                    l_121 = &l_183;
                    /* statement id: 71 */
                    assert (l_121 == &l_183);
                    for (l_158 = 0; (l_158 <= 28); ++l_158)
                    { /* block id: 74 */
                        (*l_182) = ((safe_rshift_func_uint16_t_u_s(((((((255U || ((~(safe_div_func_uint16_t_u_u(((&g_28 == (void*)0) & ((0xC490428B > ((l_183 | ((-7) > (g_99 == (!0x70B56FAF)))) > ((~(0x788D9956 ^ p_49)) == 4294967294U))) >= p_52)), g_2[1]))) != g_78[4])) != p_50) <= p_50) >= 0x2D) <= 0) & 0xD3FF), p_52)) <= 1U);
                    }
                    for (p_52 = (-2); (p_52 == 21); p_52 = safe_add_func_uint16_t_u_u(p_52, 1))
                    { /* block id: 79 */
                        uint32_t l_231 = 0xE19209CF;
                        union U1 **l_234[10] = {(void*)0,&l_232,&l_232,(void*)0,&l_232,&l_232,(void*)0,&l_232,&l_232,&l_232};
                        int i;
                        (*l_182) = (-1);
                        l_231 = ((3U < p_52) && (*l_182));
                        l_235 = l_232;
                        (*l_121) = ((((safe_div_func_int8_t_s_s(((((safe_sub_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(((((void*)0 == l_242) & (safe_div_func_int32_t_s_s(0x6C6404DC, (safe_rshift_func_int16_t_s_s(g_2[2], ((((&p_51 != (void*)0) <= (safe_div_func_int8_t_s_s((1U | (&g_28 == &p_51)), (*l_121)))) >= 1) ^ l_231)))))) & p_50), p_48)), 0x5CE0736A)) >= 0x829F) | p_49) < g_28.f0), 254U)) == p_51.f0) | 0U) & 0x13);
                    }
                    if (p_48)
                        break;
                }
                if ((l_249 != &g_233))
                { /* block id: 87 */
                    return l_182;
                    /* statement id: 88 */
                    //assert ((func_47_rv >= &g_78[0] && func_47_rv <= &g_78[4]));
                }
                else
                { /* block id: 89 */
                    int32_t *l_268 = &g_2[6];
                    for (p_52 = 0; (p_52 != 40); p_52 = safe_add_func_int16_t_s_s(p_52, 8))
                    { /* block id: 92 */
                        int32_t ****l_252 = (void*)0;
                        int32_t ***l_254 = (void*)0;
                        int32_t ****l_253[1];
                        int i;
                        for (i = 0; i < 1; i = i + 1)
                            l_253[i] = &l_254;
                        l_255 = &g_84;
                        /* statement id: 93 */
                        assert (l_255 == &g_84);
                        (*l_159) = p_51;
                        if (p_50)
                            continue;
                    }
                    p_48 = ((safe_div_func_int16_t_s_s(g_2[2], ((l_159 == (void*)0) || ((((l_255 == l_255) != (p_51.f0 && (safe_rshift_func_uint16_t_u_s((safe_add_func_int16_t_s_s(((!(safe_mul_func_int16_t_s_s((safe_add_func_int8_t_s_s(p_48, ((void*)0 == g_267))), p_50))) > (*l_121)), g_78[2])), (*l_182))))) || p_49) && p_48)))) != (-8));
                    l_269[3] = l_268;
                }
            }
            /* facts after for loop */
            assert (l_121 == &l_183 || (l_121 >= &g_78[0] && l_121 <= &g_78[4]));
            assert (l_255 == &g_84 || l_255 == &l_188);
            //assert ((l_269[0] >= &g_2[0] && l_269[0] <= &g_2[7]) || (l_269[0] >= &g_78[0] && l_269[0] <= &g_78[4]));
lbl_293:
            l_121 = l_121;
            if ((0xF352 < ((safe_mod_func_int16_t_s_s((0xA543894A >= l_274), l_275)) <= ((g_99 && ((safe_rshift_func_uint16_t_u_u((!(safe_div_func_uint32_t_u_u((~(safe_mul_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u(2, 12)), (safe_rshift_func_uint16_t_u_u((0x3F | (*g_31)), p_49))))), 0x5F59C59D))), 12)) < (*l_121))) ^ p_52))))
            { /* block id: 102 */
                int32_t *l_288[1];
                int i;
                for (i = 0; i < 1; i = i + 1)
                    l_288[i] = &g_2[2];
                return l_288[0];
                /* statement id: 103 */
                //assert ((func_47_rv >= &g_2[0] && func_47_rv <= &g_2[7]));
            }
            else
            { /* block id: 104 */
                uint16_t l_305 = 0x965C;
                int32_t **l_308 = &l_269[3];
                union U1 **l_329[1];
                int32_t l_342 = 0x411FD18A;
                int i;
                for (i = 0; i < 1; i = i + 1)
                    l_329[i] = &l_249;
                for (p_49 = 27; (p_49 >= (-30)); --p_49)
                { /* block id: 107 */
                    int32_t ***l_304 = &g_84;
                    for (p_48 = 0; (p_48 < 23); p_48 = safe_add_func_int32_t_s_s(p_48, 1))
                    { /* block id: 110 */
                        (*l_159) = g_28;
                        if (l_158)
                            goto lbl_293;
                    }
                    if ((safe_div_func_uint16_t_u_u(((safe_mod_func_uint16_t_u_u((((safe_mul_func_uint8_t_u_u(0x13, (safe_sub_func_uint32_t_u_u((((void*)0 != l_304) < (g_32 < p_52)), l_305)))) && (((safe_div_func_int32_t_s_s(((void*)0 != l_308), (safe_mul_func_uint8_t_u_u((((&p_51 != (void*)0) && 4294967293U) == 255U), (**l_308))))) <= (*g_31)) <= p_50)) | 0xD962), p_50)) ^ p_49), 3U)))
                    { /* block id: 114 */
                        struct S0 **l_312 = &l_159;
                        (*l_312) = l_311;
                        if (p_50)
                            continue;
                        l_315 = g_313;
                        /* statement id: 117 */
                        assert (l_315 == &g_314);
                    }
                    else
                    { /* block id: 118 */
                        union U1 ****l_318 = &l_316;
                        if (p_49)
                            goto lbl_293;
                        (*l_318) = l_316;
                        (*l_308) = &p_48;
                    }
                }
                if ((((void*)0 == l_319) < ((0xBC && 1) == ((((safe_lshift_func_uint8_t_u_s((((**l_308) && (-9)) <= (&l_159 == (void*)0)), (*l_121))) != 0xE804) > 1U) && p_51.f0))))
                { /* block id: 124 */
                    union U1 **l_326[1];
                    int i;
                    for (i = 0; i < 1; i = i + 1)
                        l_326[i] = &l_235;
                    for (l_183 = 7; (l_183 <= 16); ++l_183)
                    { /* block id: 127 */
                        l_326[0] = g_324;
                        if (l_327[5][4][1])
                            break;
                    }
                    /* facts after for loop */
                    //assert ((l_326[0] >= &g_325[0][0] && l_326[0] <= &g_325[9][6]) || l_326[0] == &l_235);
                }
                else
                { /* block id: 131 */
                    int32_t *l_333[6];
                    int i;
                    for (i = 0; i < 6; i = i + 1)
                        l_333[i] = (void*)0;
                    if ((~(5U && (p_52 & (((l_329[0] == &l_235) > (l_330 == (*l_255))) > p_51.f0)))))
                    { /* block id: 132 */
                        (*l_315) = l_331;
                    }
                    else
                    { /* block id: 134 */
                        (*l_308) = &p_48;
                        return l_332;
                        /* statement id: 136 */
                        //assert ((func_47_rv >= &g_78[0] && func_47_rv <= &g_78[4]));
                    }
                    for (l_183 = 1; (l_183 <= 4); l_183 += 1)
                    { /* block id: 140 */
                        int i;
                        (*g_313) = (void*)0;
                        /* statement id: 141 */
                        assert (g_314 == 0);
                        if (g_78[l_183])
                            break;
                        return l_333[1];
                        /* statement id: 143 */
                        //assert (func_47_rv == 0);
                    }
                    /* facts after for loop */
                    assert (g_314 == 0 || g_314 == &g_28);
                }
                /* facts after branching */
                assert (g_314 == 0 || g_314 == &g_28);
                l_342 = ((g_334[0] != (void*)0) & (safe_rshift_func_int16_t_s_s(((p_51.f0 ^ ((((safe_mod_func_uint32_t_u_u(0x57001960, (*l_121))) ^ g_32) <= ((&l_159 != &l_311) ^ p_48)) != g_28.f0)) >= p_50), 6)));
                (*g_313) = (void*)0;
                /* statement id: 147 */
                assert (g_314 == 0);
            }
            /* facts after branching */
            assert (g_314 == 0);
        }
        else
        { /* block id: 149 */
            union U1 *l_343 = (void*)0;
            int32_t *l_345 = &g_78[1];
            struct S0 **l_369 = &l_331;
            int32_t ****l_376[2][2];
            int i, j;
            for (i = 0; i < 2; i = i + 1)
            {
                for (j = 0; j < 2; j = j + 1)
                    l_376[i][j] = (void*)0;
            }
            (*g_324) = l_235;
            if (((&p_48 == (void*)0) >= ((l_343 == (*g_324)) >= (~(l_331 == &p_51)))))
            { /* block id: 151 */
                int16_t l_351 = 0xCA4D;
                union U1 ***l_361 = &g_324;
                l_345 = l_121;
                if (g_28.f0)
                    goto lbl_346;
lbl_346:
                (*l_332) = (*l_345);
                for (l_139 = 0; (l_139 <= (-2)); l_139 = safe_sub_func_int32_t_s_s(l_139, 6))
                { /* block id: 157 */
                    int32_t l_370[7] = {2,2,2,2,2,2,2};
                    int8_t l_371 = 0;
                    int i;
                    for (g_99 = 18; (g_99 < 54); g_99 = safe_add_func_int8_t_s_s(g_99, 8))
                    { /* block id: 160 */
                        (*l_332) = p_50;
                    }
                }
            }
            else
            { /* block id: 166 */
                (*l_345) = ((safe_sub_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u(((&g_32 == (void*)0) & ((g_267 != l_376[0][0]) == (safe_rshift_func_int8_t_s_s((((((0x3B != ((safe_add_func_uint32_t_u_u((!(g_2[2] != (safe_lshift_func_int8_t_s_s((*g_31), (0x0B5D & (0x30 && g_2[0])))))), (*l_332))) <= g_78[2])) <= p_52) < (-1)) > g_99) & g_32), p_52)))), 0xE7712620)), g_99)) <= (*l_345));
            }
            for (l_274 = 0; (l_274 <= 51); l_274 = safe_add_func_int32_t_s_s(l_274, 2))
            { /* block id: 171 */
                int32_t *l_386 = &g_78[2];
                l_386 = &p_48;
                /* statement id: 172 */
                assert (l_386 == &p_48);
                l_386 = &p_48;
            }
        }
        /* facts after branching */
        //assert (l_121 == dangling || (l_121 >= &g_78[0] && l_121 <= &g_78[4]));
        assert (g_314 == &g_28 || g_314 == 0);
    }
    else
    { /* block id: 176 */
        int32_t **l_413 = &g_390[0][3];
        int16_t l_417 = 0x16DD;
        union U1 **l_447 = &g_325[7][2];
        struct S0 * const *l_450[3];
        int i;
        for (i = 0; i < 3; i = i + 1)
            l_450[i] = &l_331;
lbl_463:
        for (p_52 = (-3); (p_52 == 43); p_52 = safe_add_func_int16_t_s_s(p_52, 1))
        { /* block id: 179 */
            int32_t **l_389 = (void*)0;
            int32_t l_411 = 4;
            int32_t **l_412[1];
            int i;
            for (i = 0; i < 1; i = i + 1)
                l_412[i] = &l_121;
            g_390[0][7] = &p_48;
            (*l_121) = ((safe_rshift_func_uint8_t_u_u((safe_add_func_int8_t_s_s(((!(safe_div_func_int8_t_s_s((0xCF >= (safe_lshift_func_uint8_t_u_s((((((*g_31) || ((&l_331 != (void*)0) | (safe_sub_func_uint16_t_u_u((~0x4C), ((((*l_121) && (safe_add_func_uint16_t_u_u((safe_mul_func_int8_t_s_s((safe_lshift_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u(((*l_121) || p_49), p_51.f0)), p_50)), (*g_31))), 0xB879))) || p_49) | p_48))))) <= l_411) | (*l_332)) != p_50), 7))), g_2[6]))) || p_51.f0), 0x8F)), 3)) ^ p_52);
            l_332 = &p_48;
            /* statement id: 182 */
            assert (l_332 == &p_48);
        }
        (*l_413) = l_121;
        if (((**l_413) != ((safe_rshift_func_uint16_t_u_u((((~l_417) | ((((safe_mul_func_uint16_t_u_u((((safe_rshift_func_int8_t_s_s((safe_mul_func_uint16_t_u_u(g_2[2], ((safe_add_func_uint16_t_u_u((**l_413), (safe_add_func_int8_t_s_s(((safe_rshift_func_int8_t_s_s((safe_unary_minus_func_int16_t_s((g_431 != l_332))), 2)) > p_52), (&p_48 != (void*)0))))) <= p_50))), 6)) > 0x05346F7C) < (*g_31)), g_2[2])) || 0U) & 0x8A) < p_51.f0)) != l_432), (*l_332))) || (*l_121))))
        { /* block id: 185 */
            struct S0 *l_440 = &g_28;
            (*l_332) = ((safe_add_func_int32_t_s_s(1, ((void*)0 != &g_335[1]))) ^ (!(*l_121)));
            p_48 = (((safe_mod_func_int16_t_s_s(1, ((safe_div_func_int32_t_s_s(((void*)0 != l_440), (g_78[2] & ((~p_51.f0) & (safe_sub_func_int8_t_s_s((safe_rshift_func_int8_t_s_u((4294967289U || 1), ((l_446[5] != l_447) ^ p_49))), p_52)))))) | 0x8404))) <= (-5)) > g_32);
        }
        else
        { /* block id: 188 */
            for (l_417 = 0; (l_417 >= (-28)); --l_417)
            { /* block id: 191 */
                struct S0 **l_460 = &g_314;
                int32_t ***l_461 = &l_413;
                if (((((&g_314 != l_450[2]) >= g_78[4]) >= (*g_31)) > 1U))
                { /* block id: 192 */
                    if ((safe_add_func_uint8_t_u_u((p_52 && (((safe_lshift_func_uint8_t_u_s(g_99, (6 != (-9)))) != (safe_div_func_int8_t_s_s(0x95, (**l_413)))) > ((((((p_51.f0 | p_49) && ((safe_unary_minus_func_uint16_t_u((safe_div_func_uint16_t_u_u(((void*)0 == l_460), g_78[2])))) >= 6)) | p_48) == 0x4482) != (*l_332)) >= 0x4D034F18))), 9U)))
                    { /* block id: 193 */
                        int32_t ****l_462 = &l_461;
                        (*l_462) = l_461;
                    }
                    else
                    { /* block id: 195 */
                        if (l_417)
                            goto lbl_463;
                    }
                    (**l_461) = &p_48;
                    (*l_332) = 0x6B061BF0;
                    (*l_413) = &g_78[2];
                }
                else
                { /* block id: 201 */
                    (**l_461) = &p_48;
                }
                if (p_50)
                    continue;
            }
            (*l_413) = &p_48;
        }
        (*l_413) = (*l_413);
    }
    /* facts after branching */
    //assert (l_121 == dangling || (l_121 >= &g_78[0] && l_121 <= &g_78[4]));
    assert (g_314 == &g_28 || g_314 == 0);
    assert (l_332 == &p_48 || (l_332 >= &g_78[0] && l_332 <= &g_78[4]));
    //assert (g_390[0][0] == &p_48 || (g_390[0][0] >= &g_2[0] && g_390[0][0] <= &g_2[7]) || (g_390[0][0] >= &g_78[0] && g_390[0][0] <= &g_78[4]));
    return &g_2[2];
    /* statement id: 210 */
    //assert (g_390[0][0] == dangling || (g_390[0][0] >= &g_2[0] && g_390[0][0] <= &g_2[7]) || (g_390[0][0] >= &g_78[0] && g_390[0][0] <= &g_78[4]));
    //assert ((func_47_rv >= &g_2[0] && func_47_rv <= &g_2[7]));
}


/* ------------------------------------------ */
/* 
 * reads : g_28 g_2
 * writes: g_28
 */
inline static int32_t  func_57(uint8_t  p_58, uint32_t  p_59)
{ /* block id: 12 */
    struct S0 *l_62 = &g_28;
    int32_t *l_70 = &g_2[2];
    int8_t l_75 = (-1);
    uint32_t l_105[8];
    int i;
    for (i = 0; i < 8; i = i + 1)
        l_105[i] = 1U;
    (*l_62) = g_28;
    return (*l_70);
}


/* ------------------------------------------ */
/* 
 * reads : g_31 g_32
 * writes:
 */
static int8_t  func_63(int32_t ** p_64, int8_t * p_65, int32_t  p_66, int16_t  p_67)
{ /* block id: 23 */
    return (*g_31);
}


/* ------------------------------------------ */
/* 
 * reads : g_78 g_28 g_84
 * writes: g_78 g_28
 */
inline static int32_t ** func_68(int8_t * p_69)
{ /* block id: 14 */
    struct S0 l_81 = {9};
    int32_t *l_83 = &g_78[2];
    for (g_78[2] = 11; (g_78[2] != 21); g_78[2] = safe_add_func_int16_t_s_s(g_78[2], 5))
    { /* block id: 17 */
        struct S0 *l_82 = &g_28;
        (*l_82) = l_81;
        (*l_82) = (*l_82);
    }
    (*l_83) = l_81.f0;
    return g_84;
    /* statement id: 22 */
    //assert (func_68_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    for (i = 0; i < 8; i = i + 1)
    {
        transparent_crc(g_2[i], "g_2[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_28.f0, "g_28.f0", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    for (i = 0; i < 5; i = i + 1)
    {
        transparent_crc(g_78[i], "g_78[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_99, "g_99", print_hash_value);
    transparent_crc(g_710, "g_710", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 132
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 24
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 5
XXX full-bitfields structs in the program: 12
breakdown:
   indirect level: 0, occurrence: 12
XXX times a bitfields struct's address is taken: 21
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 26
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 34

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 171
   depth: 2, occurrence: 32
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 4
   depth: 22, occurrence: 5
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 263
XXX times a pointer is dereferenced on RHS: 86
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 67
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 496

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 562
   level: 2, occurrence: 63
   level: 3, occurrence: 31
XXX number of pointers point to pointers: 73
XXX number of pointers point to scalars: 41
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 33.6
XXX average alias set size: 1.31

XXX times a non-volatile is read: 667
XXX times a non-volatile is write: 213
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 158
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 16
   depth: 2, occurrence: 27
   depth: 3, occurrence: 25
   depth: 4, occurrence: 29
   depth: 5, occurrence: 34

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

