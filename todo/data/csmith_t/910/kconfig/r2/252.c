/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3564673604
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
static int32_t  func_5(uint32_t  p_6, uint32_t  p_7, const int16_t  p_8, int32_t  p_9, int16_t  p_10);
static uint32_t  func_18(uint16_t  p_19);
static int32_t  func_20(uint32_t  p_21);
static int32_t * func_28(uint16_t  p_29, int32_t ** const  p_30, int32_t * const * p_31, uint32_t  p_32);
static int32_t * const * func_34(int32_t  p_35, uint16_t  p_36);
static uint16_t  func_45(int32_t  p_46, int8_t  p_47);
static uint16_t  func_56(uint32_t  p_57);
static uint32_t  func_66(int32_t * p_67, int32_t  p_68, int32_t * const  p_69, int32_t * const * p_70);
static int32_t * func_71(uint16_t  p_72);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 0x462D5E48L;
    int32_t l_340 = 0x1B35FC2BL;
    int8_t l_349 = (-1L);
    int32_t *l_350 = &l_2;
    const int32_t l_352 = 0x9E9668B0L;
    int32_t l_353 = (-1L);
    for (l_2 = 25; (l_2 <= (-28)); l_2 = safe_sub_func_int16_t_s_s(l_2, 1))
    { /* block id: 3 */
        int16_t l_17 = 0xFAC1L;
        int32_t l_224 = 8L;
        int32_t ** const *l_333 = (void*)0;
        if (((func_5(((safe_add_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(l_17, func_18(l_2))), l_2)), (l_2 >= ((l_17 == l_2) < (safe_sub_func_uint32_t_u_u((l_17 == (l_2 <= l_2)), l_2)))))) && 1UL), l_2, l_17, l_224, l_2) < 0x378B8574L) <= l_17))
        { /* block id: 126 */
            return l_224;
        }
        else
        { /* block id: 128 */
            uint32_t l_339 = 0xAB7FDA88L;
            int32_t *l_342 = &l_2;
            int32_t ** const l_341 = &l_342;
            uint16_t l_343 = 65535UL;
            l_340 = (((l_333 != (void*)0) == (safe_unary_minus_func_int32_t_s((safe_lshift_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(l_2, 12)), 3))))) || l_339);
            (*l_341) = func_28(l_339, l_341, func_34(l_2, l_340), l_2);
            (*l_341) = (*l_341);
            return l_343;
        }
    }
    (*l_350) = (l_340 || (((l_340 != 0x417FA21AL) == 4L) && (((l_340 ^ (((safe_rshift_func_uint16_t_u_u((((safe_sub_func_uint32_t_u_u(l_2, l_340)) || ((!(l_340 || (l_2 > l_2))) || l_2)) < 1L), l_340)) > l_2) > l_349)) <= l_340) & l_349)));
    (*l_350) = ((0xBA8E6F8EL != (*l_350)) & (((void*)0 == &l_2) | 8UL));
    (*l_350) = (~(0x15E6ECEBL <= l_352));
    return l_353;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_5(uint32_t  p_6, uint32_t  p_7, const int16_t  p_8, int32_t  p_9, int16_t  p_10)
{ /* block id: 69 */
    int32_t *l_226 = (void*)0;
    int32_t ** const l_225 = &l_226;
    int32_t l_227 = 0x122300B1L;
    int32_t l_262 = 8L;
    int32_t l_296 = 0x9EE29C00L;
    int32_t **l_305 = (void*)0;
    int32_t ***l_304 = &l_305;
    int32_t **** const l_303 = &l_304;
    int32_t ***l_308 = (void*)0;
    int16_t l_313 = 1L;
    const int32_t l_323 = 1L;
    if (p_6)
    { /* block id: 70 */
        int32_t l_232 = 9L;
        int32_t **l_233 = &l_226;
        int32_t *l_234 = &l_227;
        int32_t ***l_236 = &l_233;
        int32_t ****l_235 = &l_236;
        (*l_225) = func_28(p_10, l_225, &l_226, l_227);
        (*l_234) = (safe_rshift_func_int16_t_s_s(((void*)0 != &p_9), (0x0AC7L & (safe_sub_func_int32_t_s_s(0x73EEE6CDL, (l_232 >= ((4UL || (&l_226 != l_233)) <= (((-5L) == p_6) && 0x50C9L))))))));
        (*l_234) = p_9;
        (*l_235) = &l_233;
    }
    else
    { /* block id: 75 */
        const int32_t l_259 = 0x59D7E22BL;
        int32_t *l_266 = &l_227;
        int32_t l_279 = 1L;
        int32_t **l_287 = &l_226;
        int32_t ***l_286 = &l_287;
        int32_t ****l_285 = &l_286;
        uint32_t l_322 = 0UL;
        for (p_7 = 0; (p_7 == 42); ++p_7)
        { /* block id: 78 */
            int16_t l_239 = 0x6663L;
            int32_t *l_240 = &l_227;
            int32_t ***l_299 = &l_287;
            int32_t ****l_300 = (void*)0;
            int32_t *** const *l_307 = &l_286;
            int32_t *** const **l_306 = &l_307;
            (*l_240) = l_239;
            for (p_10 = 23; (p_10 == 28); ++p_10)
            { /* block id: 82 */
                uint32_t l_263 = 1UL;
                int32_t l_281 = 0xEE913CB2L;
                int32_t *l_289 = (void*)0;
                if ((safe_add_func_uint32_t_u_u(1UL, (safe_sub_func_int16_t_s_s(p_10, (safe_sub_func_uint32_t_u_u(0xAC69C330L, (safe_mod_func_int32_t_s_s(0x21723561L, ((safe_rshift_func_uint16_t_u_u((p_7 == (((safe_sub_func_int32_t_s_s((safe_mod_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(l_259, ((safe_rshift_func_int16_t_s_u(p_8, (*l_240))) < (l_259 < l_262)))) & l_259), p_6)), (-1L))) <= l_263) & (*l_240))), p_6)) && p_7))))))))))
                { /* block id: 83 */
                    int32_t l_275 = 0x94709979L;
                    int32_t **** const l_284 = (void*)0;
                    for (p_6 = 0; (p_6 <= 46); p_6 = safe_add_func_uint32_t_u_u(p_6, 1))
                    { /* block id: 86 */
                        l_266 = func_71(p_8);
                        /* statement id: 87 */
                        assert (l_266 == 0);
                        (*l_240) = (safe_unary_minus_func_uint16_t_u(p_7));
                        if (p_10)
                            break;
                        (*l_225) = (void*)0;
                    }
                    for (l_227 = 0; (l_227 >= (-19)); l_227 = safe_sub_func_int32_t_s_s(l_227, 1))
                    { /* block id: 94 */
                        uint16_t l_280 = 8UL;
                        int32_t *l_288 = &l_275;
                        l_281 = (((((((~2L) && (p_9 != (p_9 && (safe_sub_func_uint16_t_u_u((l_275 || ((~(safe_mod_func_uint16_t_u_u(((l_279 == p_7) && (9L & l_280)), (0x35E2949DL || p_9)))) > (*l_240))), l_263))))) >= p_7) && p_10) > p_10) && 0x9643D45AL) & p_7);
                        (*l_288) = ((safe_lshift_func_int16_t_s_u((l_284 != l_285), l_280)) && 0UL);
                        if ((*l_240))
                            continue;
                        l_289 = &p_9;
                        /* statement id: 98 */
                        assert (l_289 == &p_9);
                    }
                    /* facts after for loop */
                    assert (l_289 == &p_9 || l_289 == 0);
                    for (l_239 = 4; (l_239 > 15); l_239 = safe_add_func_int16_t_s_s(l_239, 1))
                    { /* block id: 102 */
                        p_9 = p_10;
                        (*l_240) = ((p_6 >= (((safe_rshift_func_int16_t_s_s(p_8, ((((*l_240) > (safe_rshift_func_uint16_t_u_s(l_296, 15))) != 4294967292UL) | (safe_sub_func_uint32_t_u_u((&l_225 != l_299), (((&l_289 == &l_226) <= p_6) < p_9)))))) ^ p_9) ^ p_8)) > p_8);
                        if (p_9)
                            continue;
                    }
                    (*l_287) = (*l_225);
                }
                else
                { /* block id: 108 */
                    int32_t *****l_301 = (void*)0;
                    int32_t *****l_302 = &l_285;
                    (*l_302) = l_300;
                    /* statement id: 109 */
                    assert (l_285 == 0);
                }
                /* facts after branching */
                assert (l_289 == &p_9 || l_289 == 0);
            }
            (*l_306) = l_303;
            /* statement id: 112 */
            assert (l_307 == &l_304);
            if (p_10)
                break;
        }
        /* facts after for loop */
        assert (l_266 == 0 || l_266 == &l_227);
        assert (l_285 == 0 || l_285 == &l_286);
        (*l_303) = l_308;
        /* statement id: 115 */
        assert (l_304 == 0);
        l_305 = (*l_286);
        /* statement id: 116 */
        assert (l_305 == &l_226);
        if ((((((safe_lshift_func_int16_t_s_u((&p_9 != (void*)0), p_10)) && ((((p_8 & ((((&l_285 == &l_285) ^ ((p_7 < (safe_sub_func_int32_t_s_s(p_10, 0xBC5584FAL))) >= p_8)) >= p_8) == 0x8E2C7871L)) > p_7) == l_313) < 4UL)) || p_6) && p_9) != p_9))
        { /* block id: 117 */
            int32_t l_320 = 1L;
            int32_t l_324 = 0x4731B12DL;
            l_324 = ((safe_lshift_func_int16_t_s_u((safe_mod_func_uint16_t_u_u(p_6, (safe_mod_func_int16_t_s_s((1L | (65535UL <= l_320)), ((l_320 || (4294967289UL && (safe_unary_minus_func_uint32_t_u(l_322)))) ^ p_10))))), 7)) <= ((65535UL > l_323) > l_320));
            p_9 = (0xAA9CE8E0L < (safe_unary_minus_func_int32_t_s(((&l_303 != (void*)0) >= ((safe_sub_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_s((p_9 ^ (l_324 == (((**l_286) != (*l_287)) || p_10))), 11)) <= (p_6 ^ 0x2F15L)) <= p_8), p_8)) | l_320)))));
        }
        else
        { /* block id: 120 */
            int8_t l_332 = (-5L);
            (*l_287) = (void*)0;
            return l_332;
        }
    }
    /* facts after branching */
    assert (l_305 == &l_226 || l_305 == 0);
    assert (l_304 == 0 || l_304 == &l_305);
    return p_6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_18(uint16_t  p_19)
{ /* block id: 4 */
    int32_t *l_23 = (void*)0;
    int32_t l_25 = 0xC45C1D10L;
    int32_t *l_24 = &l_25;
    int32_t **l_27 = &l_24;
    int8_t l_33 = 0x3DL;
    (*l_24) = func_20(p_19);
    if (p_19)
        goto lbl_26;
lbl_26:
    (*l_24) = (&l_25 == &l_25);
    (*l_27) = &l_25;
    (*l_27) = func_28(l_33, &l_23, func_34((**l_27), ((p_19 ^ (safe_add_func_uint16_t_u_u(p_19, (p_19 >= (safe_mod_func_uint16_t_u_u((safe_mod_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(p_19, func_45(func_20((func_20((*l_24)) | (*l_24))), (*l_24)))), p_19)), (*l_24))))))) == p_19)), p_19);
    /* statement id: 67 */
    assert (l_24 == 0);
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_20(uint32_t  p_21)
{ /* block id: 5 */
    int16_t l_22 = 1L;
    return l_22;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_28(uint16_t  p_29, int32_t ** const  p_30, int32_t * const * p_31, uint32_t  p_32)
{ /* block id: 64 */
    uint16_t l_194 = 0x19FEL;
    int16_t l_201 = 0xA201L;
    int32_t l_221 = 1L;
    l_221 = ((safe_rshift_func_uint16_t_u_s(((safe_lshift_func_uint16_t_u_s((safe_mod_func_uint32_t_u_u(((!((safe_mod_func_int16_t_s_s(l_194, ((((((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u((((safe_sub_func_uint16_t_u_u(((((l_194 != l_194) & (l_201 ^ (((safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u(((~((((!((safe_mod_func_int16_t_s_s(l_194, (safe_lshift_func_int16_t_s_u(((safe_mod_func_int32_t_s_s((safe_sub_func_int16_t_s_s(p_29, 65535UL)), (safe_sub_func_int32_t_s_s((safe_mod_func_uint16_t_u_u((!(p_32 < (l_201 & 0L))), l_194)), 0x1A26D265L)))) | 0xFAA68A6CL), l_194)))) == l_201)) | p_32) >= l_194) < 1UL)) >= l_194), l_194)), 6)) && 0x0B5F74D8L) || l_194))) < p_32) < l_194), p_32)) <= l_194) != l_194), l_194)), l_201)) && l_201) == 0xC0104BDEL) | p_32) == p_29) || l_194))) <= p_32)) >= 1UL), 0x61942F87L)), 4)) || p_29), l_201)) && l_194);
    return (*p_30);
    /* statement id: 66 */
    //assert (func_28_rv == 0 || func_28_rv == &l_2);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const * func_34(int32_t  p_35, uint16_t  p_36)
{ /* block id: 61 */
    int32_t **l_179 = (void*)0;
    int32_t l_182 = (-4L);
    int32_t *l_181 = &l_182;
    int32_t **l_180 = &l_181;
    int32_t * const *l_183 = &l_181;
    int32_t * const *l_184 = (void*)0;
    (*l_180) = func_71(p_36);
    /* statement id: 62 */
    assert (l_181 == 0);
    return l_184;
    /* statement id: 63 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(int32_t  p_46, int8_t  p_47)
{ /* block id: 11 */
    int32_t l_51 = (-1L);
    int16_t l_52 = 0x988FL;
    int32_t *l_53 = &l_51;
lbl_176:
    (*l_53) = (~((safe_add_func_uint16_t_u_u(((&p_46 != (void*)0) == func_20(l_51)), ((func_20(p_46) & l_52) <= (0L == (-1L))))) == l_52));
    if (((safe_lshift_func_uint16_t_u_s(func_56((((-1L) < ((func_20((safe_rshift_func_uint16_t_u_u(p_46, 7))) != (safe_rshift_func_uint16_t_u_s((p_46 >= func_20(p_47)), (func_20((*l_53)) && (p_47 <= (*l_53)))))) ^ 0x5BFF9046L)) > (*l_53))), (*l_53))) ^ p_46))
    { /* block id: 48 */
        const uint32_t l_154 = 0UL;
        int32_t **l_177 = &l_53;
        (*l_53) = p_47;
        (*l_53) = ((safe_add_func_uint16_t_u_u((((0xB3803432L >= (!(-2L))) >= ((0UL || ((l_154 && l_154) > (-5L))) && (~(safe_mod_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s(p_46, 11)) >= (((safe_lshift_func_uint16_t_u_s((0x772CL && p_46), 15)) == 4L) | 0x159E33F9L)), l_154))))) != (*l_53)), p_47)) >= l_154);
        if (((safe_lshift_func_int16_t_s_u((p_46 <= (((void*)0 != &l_51) ^ (p_46 | ((p_46 | (!(!((safe_rshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s(l_154, (4294967287UL | ((safe_rshift_func_uint16_t_u_u(((8UL && ((((safe_mod_func_int16_t_s_s((((safe_sub_func_uint32_t_u_u(0x5F293FBDL, p_46)) > p_47) | 0xEA649016L), l_154)) < l_154) >= l_154) <= l_154)) < 0xF058L), (*l_53))) < 0xA607CF51L)))), p_47)) > l_154)))) || p_46)))), p_46)) || (*l_53)))
        { /* block id: 51 */
            if (p_47)
                goto lbl_176;
        }
        else
        { /* block id: 53 */
            return p_46;
        }
        (*l_177) = func_71((*l_53));
        /* statement id: 56 */
        assert (l_53 == 0);
    }
    else
    { /* block id: 57 */
        int32_t l_178 = 0x5061D604L;
        return l_178;
    }
    /* facts after branching */
    assert (l_53 == 0);
    return l_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_56(uint32_t  p_57)
{ /* block id: 13 */
    int32_t l_76 = 0xA61EB613L;
    int32_t *l_75 = &l_76;
    uint32_t l_86 = 0x4961F084L;
    int32_t **l_147 = &l_75;
    int32_t ***l_146 = &l_147;
    int32_t **** const l_145 = &l_146;
    int16_t l_150 = 0x0DE8L;
    (*l_75) = func_20((((safe_mod_func_uint32_t_u_u(0xAD50A0C2L, func_66(func_71((p_57 < (l_75 == &l_76))), (safe_sub_func_uint16_t_u_u(((((~(((l_86 >= ((((safe_rshift_func_int16_t_s_s(p_57, ((*l_75) ^ ((safe_rshift_func_int16_t_s_s((((((!(&l_75 == &l_75)) && p_57) | 0L) >= 0L) & (*l_75)), p_57)) != p_57)))) & 0x50D6AE9EL) ^ 0x28EE66DBL) != p_57)) || p_57) >= (-10L))) >= 0x15C855A4L) ^ (*l_75)) ^ 0L), 0xD3C4L)), &l_76, &l_75))) >= p_57) > p_57));
    (**l_147) = ((safe_rshift_func_uint16_t_u_s((safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((*l_75), 0)), p_57)), (p_57 && ((!((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_uint16_t_u_u(((void*)0 != l_145), 3)) & p_57), 2)) & p_57)) > (-4L))))) ^ ((safe_sub_func_uint16_t_u_u((*l_75), p_57)) & 0x2D45L));
    (****l_145) = ((**l_145) != (void*)0);
    return l_150;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_66(int32_t * p_67, int32_t  p_68, int32_t * const  p_69, int32_t * const * p_70)
{ /* block id: 17 */
    int32_t l_96 = 0L;
    int32_t *l_95 = &l_96;
    int32_t ** const l_94 = &l_95;
    uint32_t l_102 = 0xB30C50D1L;
    int32_t l_103 = (-1L);
    uint32_t l_120 = 0x73D52B76L;
    int32_t *l_125 = &l_103;
    int32_t **l_131 = &l_95;
    int32_t ***l_130 = &l_131;
    int32_t ****l_129 = &l_130;
    if ((safe_mod_func_int32_t_s_s((l_94 == (void*)0), p_68)))
    { /* block id: 18 */
        int32_t **l_97 = &l_95;
        (*l_97) = (*p_70);
        /* statement id: 19 */
        //assert (l_95 == &l_76);
        (**l_97) = (safe_add_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u((3UL >= (((-1L) >= (0UL == (p_68 & 0x0CEF6D7BL))) == ((0xE8DF325EL > (3L & ((**l_94) ^ (l_102 == 1UL)))) || 1L))), l_103)), (*l_95)));
        (*p_69) = (*p_69);
        (*l_95) = ((*p_70) == (*l_94));
    }
    else
    { /* block id: 23 */
        int32_t *l_104 = &l_103;
        int32_t **l_123 = (void*)0;
        int32_t **l_124 = &l_95;
        (*l_94) = l_104;
        /* statement id: 24 */
        assert (l_95 == &l_103);
        for (l_103 = 0; (l_103 < 3); l_103 = safe_add_func_uint32_t_u_u(l_103, 1))
        { /* block id: 27 */
            int32_t l_107 = 0x6B9E65AFL;
        }
        if (l_103)
            goto lbl_126;
        (*l_124) = (*p_70);
        /* statement id: 33 */
        //assert (l_95 == &l_76);
    }
    /* facts after branching */
    //assert (l_95 == &l_76);
lbl_126:
    (*l_94) = l_125;
    /* statement id: 35 */
    assert (l_95 == &l_103);
    if ((**l_94))
    { /* block id: 37 */
        int32_t **l_128 = &l_95;
        int32_t ***l_127 = &l_128;
        int32_t *****l_132 = &l_129;
        (*l_127) = &p_67;
        /* statement id: 38 */
        assert (l_128 == &p_67);
        (*l_132) = l_129;
    }
    else
    { /* block id: 40 */
        int32_t l_133 = 1L;
        return l_133;
    }
    return p_68;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_71(uint16_t  p_72)
{ /* block id: 14 */
    int32_t l_78 = (-2L);
    int32_t *l_77 = &l_78;
    const int32_t **l_79 = (void*)0;
    int32_t **l_80 = &l_77;
    int32_t *l_81 = &l_78;
    int32_t *l_82 = (void*)0;
    (*l_80) = l_77;
    return l_82;
    /* statement id: 16 */
    //assert (func_71_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 64
XXX total union variables: 0

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 4
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 24, occurrence: 1
   depth: 31, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 68

XXX times a variable address is taken: 72
XXX times a pointer is dereferenced on RHS: 48
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 44
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 3
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 213

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 105
   level: 2, occurrence: 40
   level: 3, occurrence: 6
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 45
XXX number of pointers point to scalars: 23
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 38.2
XXX average alias set size: 1.21

XXX times a non-volatile is read: 368
XXX times a non-volatile is write: 110
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 88
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 25
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 5
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 14.7
XXX percentage an existing variable is used: 85.3
********************* end of statistics **********************/

