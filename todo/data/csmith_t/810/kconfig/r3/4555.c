/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3618772560
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   unsigned f1 : 3;
   signed f2 : 11;
   const unsigned f3 : 1;
   int32_t  f4;
   unsigned f5 : 19;
   unsigned f6 : 12;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int64_t  func_6(float  p_7, uint8_t  p_8, int16_t  p_9);
inline static int64_t  func_18(uint8_t  p_19, uint8_t  p_20);
static uint8_t  func_21(uint8_t  p_22, uint16_t  p_23, int32_t  p_24, uint32_t  p_25, uint8_t  p_26);
static int64_t  func_27(struct S0  p_28, int8_t  p_29, float  p_30, uint16_t  p_31, int16_t  p_32);
inline static struct S0  func_33(uint64_t  p_34);
inline static int32_t * func_40(uint64_t  p_41, int32_t * p_42, uint64_t  p_43, int32_t  p_44);
static uint8_t  func_49(int32_t * const  p_50, const int32_t  p_51, int32_t * p_52);
static int32_t * const  func_53(int32_t * p_54);
static int32_t * func_57(uint32_t  p_58);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 6L;
    uint64_t l_15 = 0xE80D68F985589B58LL;
    if (l_2)
    { /* block id: 1 */
        int8_t l_5 = 0L;
        for (l_2 = 0; (l_2 < 4); l_2 = safe_add_func_int32_t_s_s(l_2, 1))
        { /* block id: 4 */
            return l_5;
        }
    }
    else
    { /* block id: 7 */
        const int64_t l_12[9] = {0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL,0x69F4981FF29ACD40LL};
        float l_37[2];
        int32_t *l_1084[1][8] = {{(void*)0,&l_2,(void*)0,(void*)0,&l_2,(void*)0,(void*)0,&l_2}};
        int i, j;
        for (i = 0; i < 2; i++)
            l_37[i] = 0x0.3p+1;
        l_2 = (func_6((safe_add_func_float_f_f(0x7.FBBD0Ap+22, l_12[8])), (((safe_mul_func_uint16_t_u_u(l_15, l_12[1])) && ((safe_sub_func_int64_t_s_s(func_18(l_12[3], func_21(l_15, l_12[6], (func_27(func_33((safe_mul_func_uint16_t_u_u((l_15 <= ((safe_add_func_int64_t_s_s(l_12[8], 18446744073709551609UL)) ^ l_15)), l_15))), l_12[8], l_15, l_12[8], l_12[8]) < 2L), l_12[0], l_12[7])), l_15)) || 0x2FA9L)) & l_12[8]), l_12[2]) && l_2);
    }
    return l_15;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_6(float  p_7, uint8_t  p_8, int16_t  p_9)
{ /* block id: 483 */
    int32_t l_1040[6] = {0x62C23DC5L,0x62C23DC5L,0x62C23DC5L,0x62C23DC5L,0x62C23DC5L,0x62C23DC5L};
    int32_t *l_1039 = &l_1040[5];
    struct S0 l_1079[5] = {{0x9CA011F3L,1,31,0,0xFCC737FAL,32,58},{0x9CA011F3L,1,31,0,0xFCC737FAL,32,58},{0x9CA011F3L,1,31,0,0xFCC737FAL,32,58},{0x9CA011F3L,1,31,0,0xFCC737FAL,32,58},{0x9CA011F3L,1,31,0,0xFCC737FAL,32,58}};
    struct S0 *l_1078 = &l_1079[0];
    struct S0 **l_1077[10][7][3] = {{{&l_1078,(void*)0,&l_1078},{(void*)0,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,(void*)0},{(void*)0,&l_1078,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,(void*)0,&l_1078},{&l_1078,&l_1078,(void*)0},{&l_1078,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,(void*)0,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,(void*)0,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,(void*)0},{&l_1078,(void*)0,(void*)0},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078}},{{(void*)0,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078}},{{&l_1078,(void*)0,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,(void*)0,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,(void*)0},{&l_1078,&l_1078,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,(void*)0,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{&l_1078,(void*)0,&l_1078}},{{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{(void*)0,&l_1078,(void*)0},{&l_1078,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078},{(void*)0,&l_1078,&l_1078},{&l_1078,&l_1078,&l_1078}}};
    struct S0 ***l_1076 = &l_1077[6][0][0];
    int32_t **l_1083 = &l_1039;
    int i, j, k;
    for (p_9 = (-11); (p_9 < 27); p_9++)
    { /* block id: 486 */
        uint16_t l_1080[9] = {0xBC0DL,0xBC0DL,65535UL,0xBC0DL,0xBC0DL,65535UL,0xBC0DL,0xBC0DL,65535UL};
        int32_t *l_1082 = &l_1040[2];
        int i;
        for (p_8 = 0; (p_8 == 7); p_8 = safe_add_func_int8_t_s_s(p_8, 7))
        { /* block id: 489 */
            const int32_t *l_1036 = (void*)0;
            const int32_t **l_1035[10][8] = {{(void*)0,(void*)0,&l_1036,(void*)0,&l_1036,(void*)0,(void*)0,(void*)0},{&l_1036,&l_1036,&l_1036,&l_1036,&l_1036,&l_1036,(void*)0,(void*)0},{(void*)0,(void*)0,&l_1036,(void*)0,&l_1036,&l_1036,&l_1036,&l_1036},{&l_1036,(void*)0,&l_1036,(void*)0,&l_1036,&l_1036,(void*)0,(void*)0},{&l_1036,&l_1036,&l_1036,&l_1036,(void*)0,&l_1036,&l_1036,(void*)0},{(void*)0,&l_1036,&l_1036,(void*)0,(void*)0,&l_1036,(void*)0,&l_1036},{(void*)0,&l_1036,&l_1036,(void*)0,&l_1036,&l_1036,&l_1036,(void*)0},{&l_1036,&l_1036,&l_1036,&l_1036,(void*)0,&l_1036,(void*)0,(void*)0},{&l_1036,&l_1036,&l_1036,(void*)0,&l_1036,&l_1036,(void*)0,&l_1036},{&l_1036,&l_1036,&l_1036,(void*)0,(void*)0,&l_1036,&l_1036,(void*)0}};
            const int32_t ***l_1034 = &l_1035[6][0];
            const int32_t ****l_1033 = &l_1034;
            float l_1038 = (-0x1.Ap-1);
            float *l_1037 = &l_1038;
            int32_t l_1041[10] = {0x3009E8B8L,1L,1L,0x3009E8B8L,0L,0x3009E8B8L,1L,1L,0x3009E8B8L,0L};
            int32_t l_1045[6];
            int32_t l_1046 = 0xD361A7A1L;
            int i, j;
            for (i = 0; i < 6; i++)
                l_1045[i] = 0L;
            (*l_1037) = (0xC.8DB2D0p-63 > (p_8 >= ((void*)0 != l_1033)));
            l_1039 = (void*)0;
            /* statement id: 491 */
            assert (l_1039 == 0);
            for (l_1041[7] = 0; (l_1041[7] > 16); l_1041[7]++)
            { /* block id: 494 */
                int32_t *l_1044[3][7] = {{(void*)0,&l_1040[5],&l_1041[9],(void*)0,(void*)0,&l_1041[9],&l_1040[5]},{(void*)0,&l_1040[5],&l_1040[5],(void*)0,&l_1041[7],&l_1041[7],(void*)0},{&l_1040[5],&l_1040[5],&l_1040[5],&l_1041[7],&l_1040[5],&l_1040[5],&l_1040[5]}};
                int i, j;
                l_1045[3] = p_9;
                return p_8;
            }
            for (l_1046 = 0; (l_1046 != 24); l_1046 = safe_add_func_uint8_t_u_u(l_1046, 2))
            { /* block id: 500 */
                int32_t l_1049 = 7L;
                const float * const *** const l_1065 = (void*)0;
                int32_t *l_1081 = &l_1041[0];
                for (l_1049 = 0; (l_1049 > (-2)); l_1049--)
                { /* block id: 503 */
                    int32_t l_1052 = 0x0BD6536BL;
                    for (l_1052 = 6; (l_1052 >= 0); l_1052 -= 1)
                    { /* block id: 506 */
                        int i;
                        if (l_1041[(l_1052 + 2)])
                            break;
                    }
                    if (p_8)
                        break;
                }
                (*l_1081) = (safe_mod_func_int16_t_s_s(p_8, (p_9 || (((((l_1049 ^ ((safe_div_func_int32_t_s_s((safe_rshift_func_uint8_t_u_u(((safe_add_func_int64_t_s_s(((safe_mul_func_uint16_t_u_u((p_8 ^ (safe_sub_func_int16_t_s_s(((0UL && ((void*)0 == l_1065)) == ((safe_add_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((safe_mul_func_int8_t_s_s(((safe_lshift_func_uint8_t_u_s(((0x05DAL > (safe_unary_minus_func_uint16_t_u((!(((((void*)0 == l_1076) > 0xC2L) >= 0xAC69L) == l_1080[7]))))) < 0xF6L), 3)) != l_1049), 0xE3L)), l_1049)), l_1079[0].f6)) ^ (-2L))), 0x0B20L))), p_9)) == l_1080[7]), l_1049)) ^ p_9), 0)), 0x0614B800L)) & p_9)) <= p_9) >= p_8) > p_8) > 0x76L))));
                for (l_1049 = 0; l_1049 < 9; l_1049 += 1)
                {
                    l_1080[l_1049] = 0x0D32L;
                }
                l_1082 = &l_1049;
                /* statement id: 513 */
                assert (l_1082 == &l_1049);
            }
        }
        /* facts after for loop */
        //assert (l_1082 == dangling || (l_1082 >= &l_1040[0] && l_1082 <= &l_1040[5]));
    }
    /* facts after for loop */
    assert (l_1039 == 0 || (l_1039 >= &l_1040[0] && l_1039 <= &l_1040[5]));
    (*l_1083) = &l_1040[5];
    /* statement id: 517 */
    assert ((l_1039 >= &l_1040[0] && l_1039 <= &l_1040[5]));
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_18(uint8_t  p_19, uint8_t  p_20)
{ /* block id: 189 */
    uint64_t l_392[3];
    int32_t l_408 = 0x3E933A93L;
    int32_t *l_447[1];
    int32_t **l_446 = &l_447[0];
    uint64_t l_450 = 18446744073709551615UL;
    int8_t l_476 = 1L;
    struct S0 l_559 = {0xDA1DDBE4L,1,-9,0,8L,665,14};
    struct S0 *l_558 = &l_559;
    struct S0 **l_557 = &l_558;
    uint16_t l_585 = 0x0DD6L;
    int32_t l_587 = 1L;
    int32_t l_621 = (-7L);
    uint64_t l_663 = 0x32FD3F6AA859A6D3LL;
    int32_t l_666[5];
    const struct S0 * const l_770[1][4] = {{&l_559,&l_559,&l_559,&l_559}};
    const struct S0 * const *l_769 = &l_770[0][0];
    const struct S0 * const **l_768[3];
    const struct S0 * const ***l_767 = &l_768[0];
    const struct S0 * const ****l_766 = &l_767;
    uint16_t l_893 = 0x18A4L;
    uint32_t l_924[5] = {5UL,5UL,5UL,5UL,5UL};
    int16_t l_971 = 0L;
    const int32_t *l_975 = &l_587;
    float l_986 = (-0x9.Bp-1);
    float *l_985 = &l_986;
    float **l_984 = &l_985;
    int64_t l_1028 = 0xCE81E92EE812BBE9LL;
    int i, j;
    for (i = 0; i < 3; i++)
        l_392[i] = 9UL;
    for (i = 0; i < 1; i++)
        l_447[i] = (void*)0;
    for (i = 0; i < 5; i++)
        l_666[i] = 5L;
    for (i = 0; i < 3; i++)
        l_768[i] = &l_769;
lbl_832:
    for (p_20 = 0; (p_20 <= 2); p_20 += 1)
    { /* block id: 192 */
        int32_t *l_399 = (void*)0;
        int32_t **l_398 = &l_399;
        int32_t ***l_397 = &l_398;
        struct S0 l_445 = {18446744073709551611UL,1,27,0,-1L,563,39};
        struct S0 *l_444 = &l_445;
        struct S0 **l_443 = &l_444;
        struct S0 ***l_442 = &l_443;
        uint32_t l_448[10] = {0x282519BDL,0x282519BDL,0x80C36692L,0x282519BDL,0x282519BDL,0x80C36692L,0x282519BDL,0x282519BDL,0x80C36692L,0x282519BDL};
        int i;
        for (p_19 = 0; (p_19 <= 2); p_19 += 1)
        { /* block id: 195 */
            int32_t l_393 = 0xED486541L;
            int32_t l_396 = 3L;
            int32_t *l_395 = &l_396;
            int32_t *l_409 = &l_408;
            uint32_t l_415 = 0UL;
            for (l_393 = 0; (l_393 <= 2); l_393 += 1)
            { /* block id: 198 */
                int32_t *l_412 = &l_408;
                float l_417 = 0xB.A37453p+81;
                float *l_416[1][5];
                struct S0 *l_449 = &l_445;
                int i, j;
                for (i = 0; i < 1; i++)
                {
                    for (j = 0; j < 5; j++)
                        l_416[i][j] = &l_417;
                }
            }
            (*l_446) = func_53((*l_446));
        }
    }
    l_450 = p_19;
    if (p_20)
    { /* block id: 241 */
        for (l_450 = 0; (l_450 <= 0); l_450 += 1)
        { /* block id: 244 */
            int32_t l_452 = 0L;
            int32_t *l_451 = &l_452;
            for (l_408 = 0; (l_408 <= 2); l_408 += 1)
            { /* block id: 247 */
                int i;
                l_451 = (void*)0;
                /* statement id: 248 */
                assert (l_451 == 0);
                return l_392[l_408];
            }
        }
    }
    else
    { /* block id: 252 */
        int32_t *** const l_456 = (void*)0;
        int32_t *** const *l_455[2][1][1];
        struct S0 l_465 = {1UL,0,-6,0,-2L,670,20};
        struct S0 *l_464 = &l_465;
        struct S0 * const *l_463 = &l_464;
        struct S0 * const **l_462 = &l_463;
        struct S0 * const ***l_461 = &l_462;
        int32_t l_586[10][1][6] = {{{(-1L),0xE0786122L,0xE0786122L,(-1L),0L,0xD580A792L}},{{(-1L),0L,0xD580A792L,0x0385E88DL,0xE0786122L,0xD580A792L}},{{0x50C5A400L,0x87DAEB41L,0xE0786122L,0xBB830A52L,0xE0786122L,0x87DAEB41L}},{{0x0385E88DL,0L,6L,0xBB830A52L,0L,0xE0786122L}},{{0x50C5A400L,0xE0786122L,6L,0x0385E88DL,0x87DAEB41L,0x87DAEB41L}},{{(-1L),0xE0786122L,0xE0786122L,(-1L),0L,0xD580A792L}},{{(-1L),0L,0xD580A792L,0x0385E88DL,0xE0786122L,0xD580A792L}},{{0x50C5A400L,0x87DAEB41L,0xE0786122L,0xBB830A52L,0xE0786122L,0x87DAEB41L}},{{0x0385E88DL,0L,1L,0L,0x0F104D1CL,0xF09820A1L}},{{0xE0786122L,0xF09820A1L,1L,0xD580A792L,(-1L),(-1L)}}};
        int32_t l_680 = 0xCA8EC19BL;
        int16_t l_728[5];
        int32_t *l_814 = &l_559.f4;
        float l_819[7];
        float *l_818 = &l_819[0];
        float **l_817 = &l_818;
        const int32_t *l_829 = &l_408;
        int i, j, k;
        for (i = 0; i < 2; i++)
        {
            for (j = 0; j < 1; j++)
            {
                for (k = 0; k < 1; k++)
                    l_455[i][j][k] = &l_456;
            }
        }
        for (i = 0; i < 5; i++)
            l_728[i] = 5L;
        for (i = 0; i < 7; i++)
            l_819[i] = (-0x6.9p+1);
        for (p_20 = 0; (p_20 <= 2); p_20 += 1)
        { /* block id: 255 */
            int16_t l_466 = 0xE417L;
            uint32_t l_523 = 0xC1FDB081L;
            uint64_t l_551[10][6] = {{18446744073709551615UL,0xC06E6E6B571F5CE4LL,0x375FB842AC23A9A3LL,0x1211D8B410406FBDLL,0xE4BF430DAA9E5042LL,0xE4BF430DAA9E5042LL},{0xC06E6E6B571F5CE4LL,0UL,0UL,0xC06E6E6B571F5CE4LL,0x095B625FD2A935E3LL,0xE4BF430DAA9E5042LL},{18446744073709551615UL,0xE4BF430DAA9E5042LL,0x375FB842AC23A9A3LL,0x103506C35ACBBCE1LL,0x1211D8B410406FBDLL,0x103506C35ACBBCE1LL},{0x095B625FD2A935E3LL,0xB19DBEBBF000EBF2LL,0x095B625FD2A935E3LL,0xA72A61A78C10EF60LL,0x1211D8B410406FBDLL,18446744073709551615UL},{0x375FB842AC23A9A3LL,0xE4BF430DAA9E5042LL,18446744073709551615UL,0x095B625FD2A935E3LL,0x095B625FD2A935E3LL,18446744073709551615UL},{0UL,0UL,0xC06E6E6B571F5CE4LL,0x095B625FD2A935E3LL,0xE4BF430DAA9E5042LL,0xA72A61A78C10EF60LL},{0x375FB842AC23A9A3LL,0xC06E6E6B571F5CE4LL,18446744073709551615UL,0xA72A61A78C10EF60LL,18446744073709551615UL,0xC06E6E6B571F5CE4LL},{0x095B625FD2A935E3LL,0x375FB842AC23A9A3LL,18446744073709551615UL,0x103506C35ACBBCE1LL,0UL,0xA72A61A78C10EF60LL},{18446744073709551615UL,0x103506C35ACBBCE1LL,0xC06E6E6B571F5CE4LL,0xC06E6E6B571F5CE4LL,0x103506C35ACBBCE1LL,18446744073709551615UL},{0xC06E6E6B571F5CE4LL,0x103506C35ACBBCE1LL,18446744073709551615UL,0x1211D8B410406FBDLL,0UL,18446744073709551615UL}};
            int32_t **l_554[6][3] = {{&l_447[0],&l_447[0],&l_447[0]},{(void*)0,&l_447[0],(void*)0},{&l_447[0],&l_447[0],&l_447[0]},{(void*)0,(void*)0,&l_447[0]},{&l_447[0],&l_447[0],(void*)0},{&l_447[0],(void*)0,&l_447[0]}};
            uint32_t l_616 = 18446744073709551610UL;
            float l_662 = 0x1.3p+1;
            const int32_t ****l_688 = (void*)0;
            int64_t l_789 = (-5L);
            int32_t l_809[6][6][5] = {{{0x7F167316L,0x5F3DBC0FL,(-1L),1L,6L},{6L,0x7499C8A9L,0xAB0D68F7L,(-1L),(-1L)},{(-1L),1L,1L,(-1L),0x7499C8A9L},{(-1L),1L,0xA430C2DDL,1L,(-1L)},{(-1L),0x7499C8A9L,(-1L),0x5A3633F5L,(-10L)},{0xA430C2DDL,0x5F3DBC0FL,1L,1L,1L}},{{0x5F3DBC0FL,(-1L),0x5F3DBC0FL,(-1L),(-1L)},{0x5F3DBC0FL,1L,0x5A3633F5L,(-1L),(-1L)},{0xA430C2DDL,1L,0x7499C8A9L,1L,0x46718D8DL},{(-1L),1L,0x5A3633F5L,(-1L),0x5A3633F5L},{(-1L),(-1L),0x5F3DBC0FL,1L,0x5A3633F5L},{(-1L),(-1L),1L,(-10L),0x46718D8DL}},{{6L,(-10L),(-1L),0x7F167316L,(-1L)},{0x7F167316L,(-1L),0xA430C2DDL,0xA430C2DDL,(-1L)},{0x46718D8DL,(-1L),1L,0xA430C2DDL,1L},{0x7499C8A9L,1L,0xAB0D68F7L,0x7F167316L,(-10L)},{1L,1L,(-1L),(-10L),(-1L)},{0x7499C8A9L,1L,(-1L),1L,0x7499C8A9L}},{{0x46718D8DL,(-1L),(-1L),(-1L),(-1L)},{0x7F167316L,0x5F3DBC0FL,(-1L),1L,6L},{6L,0x7499C8A9L,0xAB0D68F7L,1L,6L},{0x5F3DBC0FL,(-1L),(-1L),0x5F3DBC0FL,1L},{6L,(-1L),(-1L),0x5A3633F5L,0x5F3DBC0FL},{1L,1L,6L,0x7499C8A9L,0xAB0D68F7L}},{{(-1L),0x46718D8DL,0x7F167316L,0x5A3633F5L,0x5A3633F5L},{0x46718D8DL,1L,0x46718D8DL,0x5F3DBC0FL,(-10L)},{0x46718D8DL,1L,0x7499C8A9L,1L,0xA430C2DDL},{(-1L),0x7F167316L,1L,(-1L),1L},{1L,0x5A3633F5L,0x7499C8A9L,0xA430C2DDL,0x7499C8A9L},{6L,6L,0x46718D8DL,1L,0x7499C8A9L}},{{0x5F3DBC0FL,(-10L),0x7F167316L,0xAB0D68F7L,1L},{(-9L),0xAB0D68F7L,6L,(-1L),0xA430C2DDL},{(-1L),(-10L),(-1L),(-1L),(-10L)},{1L,6L,(-1L),(-1L),0x5A3633F5L},{1L,0x5A3633F5L,(-1L),(-1L),0xAB0D68F7L},{1L,0x7F167316L,0xA430C2DDL,0xAB0D68F7L,0x5F3DBC0FL}}};
            struct S0 *l_813 = &l_559;
            struct S0 ***l_823[2];
            struct S0 **** const l_822 = &l_823[0];
            int i, j, k;
            for (i = 0; i < 2; i++)
                l_823[i] = &l_557;
        }
        (**l_817) = ((*l_446) != l_829);
        for (l_450 = 0; (l_450 < 44); l_450 = safe_add_func_int32_t_s_s(l_450, 7))
        { /* block id: 404 */
            struct S0 *****l_835 = (void*)0;
            int32_t l_840[9] = {0xE662BBA4L,0xE662BBA4L,0xE662BBA4L,0xE662BBA4L,0xE662BBA4L,0xE662BBA4L,0xE662BBA4L,0xE662BBA4L,0xE662BBA4L};
            uint8_t l_849 = 0x77L;
            struct S0 ***l_860 = &l_557;
            float *l_889[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            int32_t *l_907 = &l_840[6];
            float **l_996[5] = {&l_985,&l_985,&l_985,&l_985,&l_985};
            int i;
            if (p_20)
                goto lbl_832;
        }
    }
    (**l_984) = (safe_mul_func_float_f_f((&l_447[0] == (void*)0), ((safe_mul_func_float_f_f(0x2.825274p-66, (p_20 == ((((((safe_add_func_float_f_f(((safe_mul_func_float_f_f(0x6.5p+1, (safe_div_func_float_f_f((*l_975), (0x7.EB947Ep+82 <= p_19))))) <= (safe_sub_func_float_f_f((safe_div_func_float_f_f((p_20 >= p_20), (*l_975))), (-0x7.9p-1)))), p_19)) <= l_1028) == p_19) <= (*l_975)) != p_20) >= p_20)))) < p_20)));
    return p_20;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_21(uint8_t  p_22, uint16_t  p_23, int32_t  p_24, uint32_t  p_25, uint8_t  p_26)
{ /* block id: 180 */
    struct S0 ** const l_372 = (void*)0;
    int32_t l_373 = 0x640A0DB1L;
    int32_t *l_376 = &l_373;
    int32_t **l_375 = &l_376;
    int32_t ***l_374 = &l_375;
    struct S0 * const **l_382 = (void*)0;
    struct S0 * const ***l_381 = &l_382;
    uint16_t l_383 = 0x855BL;
    float l_385 = 0x1.2D7826p+4;
    float *l_384 = &l_385;
    (*l_384) = (-(safe_div_func_float_f_f((((((-(((((l_372 == l_372) != ((l_373 <= 0x4.725F03p+55) <= (((void*)0 == l_374) <= (safe_sub_func_float_f_f(((safe_mul_func_float_f_f(p_25, (l_381 == &l_382))) != (*l_376)), l_383))))) <= (*l_376)) > p_24) != 0xF.F3B490p-31)) >= p_25) != (*l_376)) < (**l_375)) > p_25), p_23)));
    for (l_383 = (-24); (l_383 == 6); l_383++)
    { /* block id: 184 */
        struct S0 l_390 = {8UL,0,-13,0,0x5AEF02EEL,292,30};
        struct S0 *l_389 = &l_390;
        struct S0 **l_388[4];
        struct S0 ***l_391 = &l_388[2];
        int i;
        for (i = 0; i < 4; i++)
            l_388[i] = &l_389;
        (*l_391) = l_388[1];
        (**l_374) = (*l_375);
    }
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_27(struct S0  p_28, int8_t  p_29, float  p_30, uint16_t  p_31, int16_t  p_32)
{ /* block id: 139 */
    uint8_t l_343 = 248UL;
    struct S0 *l_352 = (void*)0;
    struct S0 **l_351 = &l_352;
    struct S0 ***l_350 = &l_351;
    int32_t *l_358 = (void*)0;
    int32_t **l_357 = &l_358;
    for (p_32 = 11; (p_32 >= 22); ++p_32)
    { /* block id: 142 */
        float l_324[9][6] = {{0x6.83E9DAp-30,0x6.83E9DAp-30,(-0x2.Ep-1),0x0.0p+1,(-0x2.Ep-1),0x6.83E9DAp-30},{(-0x2.Ep-1),0x1.7p+1,0x0.0p+1,0x0.0p+1,0x1.7p+1,(-0x2.Ep-1)},{0x6.83E9DAp-30,(-0x2.Ep-1),0x0.0p+1,(-0x2.Ep-1),0x6.83E9DAp-30,0x6.83E9DAp-30},{0x1.Fp-1,(-0x2.Ep-1),(-0x2.Ep-1),0x1.Fp-1,0x1.7p+1,0x1.Fp-1},{0x1.Fp-1,0x1.7p+1,0x1.Fp-1,(-0x2.Ep-1),(-0x2.Ep-1),0x1.Fp-1},{0x6.83E9DAp-30,0x6.83E9DAp-30,(-0x2.Ep-1),0x0.0p+1,(-0x2.Ep-1),0x6.83E9DAp-30},{(-0x2.Ep-1),0x1.7p+1,0x0.0p+1,0x0.0p+1,0x1.7p+1,(-0x2.Ep-1)},{0x6.83E9DAp-30,(-0x2.Ep-1),0x0.0p+1,(-0x2.Ep-1),0x6.83E9DAp-30,0x6.83E9DAp-30},{0x1.Fp-1,(-0x2.Ep-1),(-0x2.Ep-1),0x1.Fp-1,0x1.7p+1,0x1.Fp-1}};
        int32_t l_326 = 0xDE9F75FFL;
        int32_t *l_325 = &l_326;
        struct S0 **** const *l_344 = (void*)0;
        int i, j;
        for (p_31 = 0; (p_31 <= 5); p_31 += 1)
        { /* block id: 145 */
            uint32_t l_330 = 0UL;
            int32_t **l_336 = &l_325;
            int32_t l_366 = 3L;
            for (p_29 = 0; (p_29 <= 5); p_29 += 1)
            { /* block id: 148 */
                uint8_t l_340 = 0xF1L;
                struct S0 ***l_347 = (void*)0;
                struct S0 ****l_346 = &l_347;
                struct S0 **** const *l_345[9][9] = {{&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346},{&l_346,(void*)0,(void*)0,&l_346,&l_346,(void*)0,&l_346,(void*)0,&l_346},{&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346},{&l_346,(void*)0,(void*)0,&l_346,&l_346,(void*)0,&l_346,(void*)0,&l_346},{&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346},{(void*)0,&l_346,&l_346,(void*)0,&l_346,(void*)0,(void*)0,(void*)0,&l_346},{&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346},{(void*)0,&l_346,&l_346,(void*)0,&l_346,(void*)0,(void*)0,(void*)0,&l_346},{&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346,&l_346}};
                int i, j;
                for (p_28.f4 = 0; (p_28.f4 <= 5); p_28.f4 += 1)
                { /* block id: 151 */
                    int32_t **l_337 = &l_325;
                    for (p_28.f0 = 0; (p_28.f0 <= 5); p_28.f0 += 1)
                    { /* block id: 154 */
                        int i, j;
                        l_325 = l_325;
                    }
                    if (p_29)
                        continue;
                    l_345[5][5] = l_344;
                }
                for (l_343 = 1; (l_343 <= 5); l_343 += 1)
                { /* block id: 164 */
                    int64_t l_364 = 6L;
                    struct S0 *****l_365 = (void*)0;
                    for (l_326 = 4; (l_326 >= 0); l_326 -= 1)
                    { /* block id: 167 */
                        int32_t l_363 = 1L;
                        int i, j;
                        l_324[l_326][l_343] = ((l_324[(l_326 + 4)][(l_326 + 1)] < l_340) == (((-0x8.5p-1) == l_343) > (safe_mul_func_float_f_f(((void*)0 == l_350), (safe_sub_func_float_f_f(((safe_sub_func_float_f_f((l_357 == &l_325), (safe_add_func_float_f_f((safe_add_func_float_f_f((&p_28 == (void*)0), p_32)), 0xD.D0A15Ep-42)))) < l_363), 0x1.B2B7A4p+28))))));
                        if (l_364)
                            continue;
                        l_344 = l_365;
                    }
                }
            }
            if ((**l_336))
                break;
            return l_366;
        }
        (*l_325) = (+p_28.f0);
    }
    return p_28.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_33(uint64_t  p_34)
{ /* block id: 8 */
    int32_t l_56 = 0x630DE2FDL;
    int32_t *l_55[8][8] = {{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,(void*)0},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{(void*)0,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56},{&l_56,&l_56,(void*)0,&l_56,&l_56,&l_56,&l_56,(void*)0},{&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56,&l_56}};
    uint8_t l_300 = 252UL;
    uint32_t l_301[6][3] = {{0xD2AB83D3L,18446744073709551610UL,0xD2AB83D3L},{0xD2AB83D3L,0UL,0UL},{0xD2AB83D3L,0xE5AF4E9BL,18446744073709551615UL},{0xD2AB83D3L,18446744073709551610UL,0xD2AB83D3L},{0xD2AB83D3L,0UL,0UL},{0xD2AB83D3L,0xE5AF4E9BL,18446744073709551615UL}};
    uint32_t l_302[4];
    int32_t **l_320 = &l_55[7][6];
    struct S0 l_321 = {18446744073709551615UL,0,23,0,0x79E35B24L,555,40};
    int i, j;
    for (i = 0; i < 4; i++)
        l_302[i] = 0UL;
    (*l_320) = func_40(((safe_sub_func_uint16_t_u_u((safe_div_func_uint16_t_u_u(((func_49(func_53(l_55[7][6]), p_34, func_57(p_34)) >= (safe_mod_func_int8_t_s_s((safe_rshift_func_int8_t_s_u(((5L ^ 0L) <= (((safe_lshift_func_uint8_t_u_s(0x86L, p_34)) & l_300) == 0L)), p_34)), l_301[5][0]))) ^ p_34), p_34)), l_302[0])) != 0x45L), &l_56, p_34, p_34);
    return l_321;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(uint64_t  p_41, int32_t * p_42, uint64_t  p_43, int32_t  p_44)
{ /* block id: 128 */
    struct S0 l_307 = {0UL,1,-31,0,0L,300,30};
    struct S0 *l_306 = &l_307;
    uint8_t l_308[9] = {255UL,255UL,255UL,255UL,255UL,255UL,255UL,255UL,255UL};
    float *l_313 = (void*)0;
    float l_319 = 0x1.3p+1;
    float *l_318 = &l_319;
    int i;
    l_307.f4 = (!(safe_mul_func_float_f_f(0x9.998434p-99, ((void*)0 != l_306))));
    for (p_44 = 0; (p_44 <= 8); p_44 += 1)
    { /* block id: 132 */
        return p_42;
        /* statement id: 133 */
        //assert (func_40_rv == &l_56 || func_40_rv == &l_408 || (func_40_rv >= &l_785[0] && func_40_rv <= &l_785[0]) || func_40_rv == 0 || (func_40_rv >= &l_840[0] && func_40_rv <= &l_840[8]) || (func_40_rv >= &l_819[0] && func_40_rv <= &l_819[6]));
    }
    (*l_318) = ((p_43 < (((((safe_mul_func_float_f_f((safe_div_func_float_f_f(l_307.f6, p_41)), ((l_307.f2 < p_41) != (0xE.370A9Bp-9 >= (l_313 == p_42))))) != ((!((safe_div_func_float_f_f(((+((void*)0 == p_42)) == (-0x7.4p-1)), l_307.f4)) >= (-0x1.6p+1))) <= p_41)) > p_43) < p_43) == l_308[8])) > p_43);
    return l_313;
    /* statement id: 136 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_49(int32_t * const  p_50, const int32_t  p_51, int32_t * p_52)
{ /* block id: 102 */
    uint32_t l_213[5] = {4UL,4UL,4UL,4UL,4UL};
    int32_t l_214 = (-1L);
    int32_t **l_230 = (void*)0;
    int32_t ***l_229 = &l_230;
    int16_t l_238 = 0xC253L;
    struct S0 l_262 = {0x3D6F2558L,0,-42,0,0xB62A77DDL,548,62};
    struct S0 *l_261 = &l_262;
    struct S0 **l_260 = &l_261;
    struct S0 ***l_259 = &l_260;
    int16_t l_283 = 0x84DDL;
    int i;
lbl_291:
    for (l_214 = 4; (l_214 >= 1); l_214 -= 1)
    { /* block id: 105 */
        int32_t l_231 = 0xAF60F279L;
        int i;
        l_231 = (safe_mul_func_float_f_f(0x0.C21528p+35, (((safe_add_func_float_f_f(((0x9.EF2E49p-13 >= l_213[l_214]) != ((safe_add_func_float_f_f(l_213[l_214], ((!p_51) < 0x0.Ap+1))) > (-(safe_sub_func_float_f_f(l_213[1], ((safe_add_func_float_f_f((safe_add_func_float_f_f((p_51 >= ((l_229 == &l_230) == p_51)), l_213[l_214])), p_51)) != 0xD.8DED1Cp+89)))))), 0x6.093CF0p+13)) <= p_51) >= l_213[l_214])));
    }
    for (l_214 = 12; (l_214 == 11); --l_214)
    { /* block id: 110 */
        uint32_t l_253 = 18446744073709551615UL;
        int32_t l_258 = (-5L);
        if (p_51)
        { /* block id: 111 */
            float *l_235 = (void*)0;
            float l_237 = 0x4.6DB735p+11;
            float *l_236 = &l_237;
            (*l_236) = ((!0x1.AC6151p-83) <= p_51);
            return l_238;
        }
        else
        { /* block id: 114 */
            int32_t * const * const *l_241 = (void*)0;
            struct S0 * const *l_265 = &l_261;
            struct S0 * const **l_264 = &l_265;
            struct S0 * const ***l_263[5][4][10] = {{{&l_264,&l_264,&l_264,(void*)0,&l_264,&l_264,&l_264,(void*)0,(void*)0,&l_264},{&l_264,&l_264,(void*)0,&l_264,(void*)0,&l_264,(void*)0,&l_264,&l_264,&l_264},{&l_264,(void*)0,(void*)0,&l_264,&l_264,&l_264,&l_264,&l_264,(void*)0,&l_264},{&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,(void*)0}},{{(void*)0,&l_264,(void*)0,&l_264,&l_264,&l_264,&l_264,&l_264,(void*)0,(void*)0},{&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264},{(void*)0,&l_264,&l_264,&l_264,(void*)0,(void*)0,&l_264,&l_264,&l_264,&l_264},{&l_264,&l_264,&l_264,(void*)0,(void*)0,&l_264,&l_264,&l_264,&l_264,&l_264}},{{&l_264,(void*)0,&l_264,&l_264,&l_264,&l_264,(void*)0,&l_264,(void*)0,&l_264},{(void*)0,(void*)0,&l_264,&l_264,&l_264,(void*)0,(void*)0,&l_264,&l_264,&l_264},{&l_264,&l_264,&l_264,&l_264,(void*)0,&l_264,&l_264,&l_264,&l_264,&l_264},{&l_264,&l_264,(void*)0,&l_264,&l_264,&l_264,(void*)0,&l_264,&l_264,&l_264}},{{&l_264,(void*)0,(void*)0,&l_264,&l_264,&l_264,(void*)0,&l_264,&l_264,(void*)0},{&l_264,(void*)0,&l_264,&l_264,(void*)0,&l_264,&l_264,&l_264,&l_264,(void*)0},{&l_264,&l_264,(void*)0,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264},{&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,(void*)0}},{{&l_264,&l_264,&l_264,&l_264,(void*)0,&l_264,(void*)0,(void*)0,(void*)0,&l_264},{&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264},{&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264,&l_264},{&l_264,&l_264,&l_264,&l_264,&l_264,(void*)0,(void*)0,&l_264,&l_264,&l_264}}};
            struct S0 ***l_266 = &l_260;
            float l_285 = 0x1.6p-1;
            float *l_284 = &l_285;
            int32_t **l_286 = (void*)0;
            int32_t **l_287 = (void*)0;
            int32_t **l_288 = (void*)0;
            int32_t *l_290 = &l_258;
            int32_t **l_289 = &l_290;
            int i, j, k;
            l_258 = (safe_mul_func_float_f_f((((l_241 == l_241) < p_51) >= (+((safe_add_func_float_f_f(((safe_div_func_float_f_f(((l_214 >= (safe_sub_func_float_f_f((((((p_51 == (safe_sub_func_float_f_f(((safe_div_func_float_f_f(l_253, p_51)) == (safe_add_func_float_f_f((l_253 != ((safe_add_func_float_f_f(p_51, l_253)) < p_51)), 0x4.676201p+38))), p_51))) < (-0x7.Ep-1)) <= (-0x1.Ep-1)) > (-0x2.Dp-1)) > 0xC.68F4A9p-6), l_253))) <= p_51), 0x6.11B6DAp+78)) >= p_51), p_51)) >= 0x1.DEF7D7p+94))), p_51));
            l_266 = l_259;
            (*l_284) = ((((((safe_div_func_float_f_f((safe_div_func_float_f_f((p_50 != p_52), ((safe_div_func_float_f_f(((((safe_div_func_float_f_f(p_51, p_51)) < (safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_mul_func_float_f_f(l_253, (safe_div_func_float_f_f(0x4.F18D47p+13, (&l_260 != (void*)0))))), p_51)), p_51))) == p_51) >= 0x5.C00601p+62), p_51)) >= l_283))), l_253)) <= 0xD.CF49A6p-39) >= l_253) >= p_51) > 0xD.6A9F0Fp+79) == p_51);
            (*l_289) = func_53(func_57(l_253));
            /* statement id: 118 */
            assert (l_290 == 0);
        }
        if (l_214)
            goto lbl_291;
        for (l_283 = 0; (l_283 >= (-4)); l_283 = safe_sub_func_int8_t_s_s(l_283, 3))
        { /* block id: 123 */
            if (l_253)
                goto lbl_291;
        }
    }
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_53(int32_t * p_54)
{ /* block id: 9 */
    return p_54;
    /* statement id: 10 */
    //assert (func_53_rv == 0 || func_53_rv == &l_56 || func_53_rv == &l_75 || (func_53_rv >= &l_60[0][0][0] && func_53_rv <= &l_60[6][8][3]) || func_53_rv == &l_408 || (func_53_rv >= &l_819[0] && func_53_rv <= &l_819[6]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_57(uint32_t  p_58)
{ /* block id: 11 */
    int32_t l_60[7][9][4] = {{{1L,0x27326B30L,0x08375F08L,(-4L)},{0xD03168F1L,(-1L),0x6D3C1D26L,0x53593517L},{(-1L),(-3L),0xEC37461BL,0x6D3C1D26L},{1L,0x390AC9F7L,1L,1L},{0x962DE1B4L,0L,0xEF39980AL,0xEA4F543AL},{0x9FF1DB06L,0x27326B30L,0x4B492BB7L,0x6723FF49L},{0x38B87B6FL,0xD03168F1L,0L,0L},{(-3L),(-1L),(-1L),0xEA4F543AL},{6L,0x5DFEA44EL,0x6D3C1D26L,(-2L)}},{{0xE0BBE0E2L,0x390AC9F7L,0L,0x8BD5E570L},{0x76BF08EAL,1L,0xD0AB83DCL,0x40AFAA93L},{0xED357DCCL,0x9FF1DB06L,(-10L),0L},{1L,4L,(-4L),(-1L)},{0x4B492BB7L,3L,(-1L),(-1L)},{(-3L),0x77944D42L,0x4BC07302L,3L},{0xEC37461BL,0xCBD5F5ABL,0x27326B30L,0x40AFAA93L},{(-8L),0xED357DCCL,(-1L),(-1L)},{(-5L),0L,1L,0xB16E5D1CL}},{{1L,0x76BF08EAL,0x406CCCE4L,0x6723FF49L},{(-6L),(-10L),0xD0AB83DCL,(-1L)},{0xB16E5D1CL,(-6L),0L,0L},{(-8L),(-8L),(-3L),0x7CF5EE2CL},{0x6723FF49L,0xB0536403L,0xBF6251CAL,0x76BF08EAL},{0xC0429090L,6L,(-1L),0xBF6251CAL},{0x9FF1DB06L,6L,0x4D865E42L,0x76BF08EAL},{6L,0xB0536403L,0x915D4894L,0x7CF5EE2CL},{0xED357DCCL,(-8L),0xCB2DC507L,0L}},{{0x4B492BB7L,(-6L),0xBC84746BL,(-1L)},{0x39C2D96AL,(-10L),7L,0x6723FF49L},{0L,0x76BF08EAL,0x4BC07302L,0xB16E5D1CL},{0x77944D42L,0L,1L,(-1L)},{0x9FF1DB06L,0xED357DCCL,0xCB2DC507L,0x40AFAA93L},{1L,0xCBD5F5ABL,0xC0429090L,3L},{1L,0x77944D42L,(-4L),(-1L)},{0x9FF1DB06L,3L,0L,(-1L)},{(-10L),4L,0x4BC07302L,0L}},{{0x2CD5B9AAL,0x9FF1DB06L,(-3L),0x40AFAA93L},{0x39C2D96AL,1L,0x08375F08L,(-1L)},{(-5L),6L,0xCB2DC507L,(-5L)},{(-6L),0x76BF08EAL,(-1L),0xEC37461BL},{6L,(-1L),0xD0AB83DCL,0xAE39B9AAL},{1L,0x2CD5B9AAL,(-1L),0L},{0x39C2D96AL,4L,9L,0xEC37461BL},{0x6723FF49L,0xB16E5D1CL,7L,0x4B492BB7L},{(-3L),6L,0L,7L}},{{0x76BF08EAL,0L,0x4D865E42L,0x40AFAA93L},{(-6L),1L,(-10L),0x7CF5EE2CL},{1L,4L,1L,(-1L)},{0x4B492BB7L,0xEC37461BL,0xD5AE9098L,(-1L)},{(-8L),(-10L),0x4BC07302L,0xEC37461BL},{3L,0xCBD5F5ABL,0x4BC07302L,0xC2878486L},{(-8L),(-6L),0xD5AE9098L,(-1L)},{0x4B492BB7L,1L,1L,0x76BF08EAL},{1L,0x76BF08EAL,(-10L),0L}},{{(-6L),0x77944D42L,0x4D865E42L,(-1L)},{0x76BF08EAL,0xD55A9D45L,0L,0xAE39B9AAL},{(-3L),(-8L),7L,0L},{0x6723FF49L,0xCBD5F5ABL,9L,1L},{(-1L),0L,9L,0x915D4894L},{(-4L),0L,1L,(-4L)},{0L,0xED357DCCL,(-1L),0x62A889E4L},{3L,1L,0L,(-4L)},{0x4D865E42L,9L,0x27326B30L,9L}}};
    int32_t * const l_59 = &l_60[5][0][0];
    const int32_t *l_63 = &l_60[5][0][0];
    const int32_t **l_62[6];
    const int32_t ***l_61 = &l_62[0];
    struct S0 l_69 = {0x4B5BC177L,1,10,0,0L,422,23};
    struct S0 *l_68 = &l_69;
    int64_t l_202[9][5] = {{0xB975996908100F81LL,0xB975996908100F81LL,0x3CE37CC862B96CBFLL,0xB975996908100F81LL,0xB975996908100F81LL},{(-2L),0x4BFDF1D08C604228LL,(-2L),(-2L),0x4BFDF1D08C604228LL},{0xB975996908100F81LL,0x52B824888C0F74BFLL,0x52B824888C0F74BFLL,0xB975996908100F81LL,0x52B824888C0F74BFLL},{0x4BFDF1D08C604228LL,0x4BFDF1D08C604228LL,(-1L),0x4BFDF1D08C604228LL,0x4BFDF1D08C604228LL},{0x52B824888C0F74BFLL,0xB975996908100F81LL,0x52B824888C0F74BFLL,0x52B824888C0F74BFLL,0xB975996908100F81LL},{0x4BFDF1D08C604228LL,(-2L),(-2L),0x4BFDF1D08C604228LL,(-2L)},{0xB975996908100F81LL,0xB975996908100F81LL,0x3CE37CC862B96CBFLL,0xB975996908100F81LL,0xB975996908100F81LL},{(-2L),0x4BFDF1D08C604228LL,(-2L),(-2L),0x4BFDF1D08C604228LL},{0xB975996908100F81LL,0x52B824888C0F74BFLL,0x52B824888C0F74BFLL,0xB975996908100F81LL,0x52B824888C0F74BFLL}};
    int32_t *l_207 = &l_69.f4;
    int32_t *l_209 = (void*)0;
    int32_t *l_212 = (void*)0;
    int i, j, k;
    for (i = 0; i < 6; i++)
        l_62[i] = &l_63;
    (*l_59) = ((void*)0 != l_59);
    (*l_61) = &l_59;
    /* statement id: 13 */
    //assert (l_62[0] == &l_59 || l_62[0] == &l_63);
    if ((safe_mul_func_uint8_t_u_u(p_58, 0x59L)))
    { /* block id: 14 */
        int32_t * const l_72 = &l_60[5][0][0];
        float l_124 = 0x0.7p-1;
        float *l_123 = &l_124;
        const int32_t *l_125[6][4][3] = {{{(void*)0,&l_69.f4,&l_60[0][8][2]},{(void*)0,&l_60[5][5][2],&l_69.f4},{(void*)0,&l_60[5][0][0],&l_69.f4},{(void*)0,&l_60[0][5][0],(void*)0}},{{&l_69.f4,&l_60[5][0][0],(void*)0},{&l_69.f4,&l_60[5][5][2],(void*)0},{&l_60[0][8][2],&l_69.f4,(void*)0},{&l_60[1][2][1],&l_60[1][2][1],(void*)0}},{{&l_60[0][8][2],&l_69.f4,&l_69.f4},{&l_69.f4,(void*)0,(void*)0},{&l_69.f4,&l_69.f4,&l_69.f4},{(void*)0,&l_69.f4,(void*)0}},{{(void*)0,&l_69.f4,&l_69.f4},{(void*)0,&l_60[5][0][0],(void*)0},{(void*)0,&l_60[5][0][0],(void*)0},{(void*)0,&l_60[5][0][0],(void*)0}},{{&l_69.f4,&l_69.f4,(void*)0},{(void*)0,&l_69.f4,(void*)0},{&l_69.f4,&l_69.f4,&l_69.f4},{(void*)0,(void*)0,&l_69.f4}},{{&l_69.f4,&l_69.f4,&l_60[0][8][2]},{(void*)0,&l_60[1][2][1],&l_60[1][2][1]},{(void*)0,&l_69.f4,&l_60[0][8][2]},{(void*)0,&l_60[5][5][2],&l_69.f4}}};
        int i, j, k;
        for (p_58 = 23; (p_58 >= 6); --p_58)
        { /* block id: 17 */
            struct S0 **l_70 = &l_68;
            int32_t *l_71 = (void*)0;
            if (p_58)
                break;
            (*l_70) = l_68;
            for (l_69.f0 = 0; (l_69.f0 <= 3); l_69.f0 += 1)
            { /* block id: 22 */
                int32_t **l_73[6] = {&l_71,&l_71,(void*)0,&l_71,&l_71,(void*)0};
                int32_t **l_74 = &l_71;
                int i;
            }
        }
        (*l_123) = ((safe_add_func_float_f_f((*l_72), ((-0x1.2p-1) > (safe_div_func_float_f_f((safe_mul_func_float_f_f((0x6.546519p-73 == ((-0x1.Ap-1) <= 0xF.BB2BE9p-87)), ((((*l_61) != &l_72) != (*l_72)) > (*l_72)))), p_58))))) == 0x8.B7AB54p+21);
        l_125[1][3][1] = (**l_61);
    }
    else
    { /* block id: 53 */
        uint8_t l_128 = 1UL;
        float l_130 = 0x0.5p-1;
        float *l_129 = &l_130;
        struct S0 *l_133 = &l_69;
        int32_t *l_157 = &l_69.f4;
        int32_t **l_156 = &l_157;
        (*l_59) = (safe_sub_func_uint16_t_u_u(l_128, ((l_129 != (void*)0) == (*l_59))));
        for (l_69.f4 = (-9); (l_69.f4 == 20); l_69.f4++)
        { /* block id: 57 */
            int64_t l_144 = 0x7FCA46356B4AE7F9LL;
            struct S0 **l_148 = &l_133;
            int32_t *l_155 = (void*)0;
            int32_t **l_154 = &l_155;
            int32_t ***l_164 = (void*)0;
            int32_t *l_206[7] = {&l_60[5][0][0],&l_60[5][0][0],&l_69.f4,&l_60[5][0][0],&l_60[5][0][0],&l_69.f4,&l_60[5][0][0]};
            int32_t **l_210[7] = {&l_209,&l_206[4],&l_206[4],&l_209,&l_206[4],&l_206[4],&l_209};
            int32_t **l_211 = &l_157;
            int i;
        }
    }
    return l_212;
    /* statement id: 101 */
    //assert (func_57_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 216
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 35
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 18
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 6

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 34
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 11, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 219

XXX times a variable address is taken: 479
XXX times a pointer is dereferenced on RHS: 85
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 12
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 98
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 10
XXX times a pointer is compared with null: 34
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 834

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 261
   level: 2, occurrence: 73
   level: 3, occurrence: 32
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 119
XXX number of pointers point to scalars: 84
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 36.1
XXX average alias set size: 1.39

XXX times a non-volatile is read: 966
XXX times a non-volatile is write: 314
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 22
   depth: 2, occurrence: 22
   depth: 3, occurrence: 10
   depth: 4, occurrence: 6
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 18.5
XXX percentage an existing variable is used: 81.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

