/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      802449576
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 2;
   unsigned f1 : 15;
   signed f2 : 21;
   const unsigned f3 : 13;
   signed f4 : 8;
   signed f5 : 31;
   unsigned f6 : 1;
   signed f7 : 18;
   signed f8 : 14;
};

union U1 {
   int8_t * f0;
   int8_t  f1;
};

union U2 {
   int8_t  f0;
   uint8_t  f1;
};

union U3 {
   signed f0 : 9;
   uint16_t  f1;
};

union U4 {
   uint32_t  f0;
   int8_t  f1;
   int16_t  f2;
   uint32_t  f3;
   uint8_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_1(void);
inline static uint8_t  func_7(union U2  p_8, union U3  p_9, int32_t * p_10);
static union U2  func_11(int32_t  p_12);
static int32_t * const  func_14(int8_t * p_15);
inline static int8_t * func_16(struct S0  p_17);
inline static int32_t  func_22(union U1  p_23, union U1  p_24, union U4  p_25);
inline static int32_t * func_33(union U2  p_34, union U4  p_35, int32_t * p_36);
inline static union U4  func_38(union U2  p_39, uint32_t  p_40);
inline static union U2  func_41(int32_t * p_42, const int8_t * p_43, int32_t * p_44, uint8_t  p_45, uint32_t  p_46);
static int32_t * func_47(const struct S0  p_48, int8_t * const  p_49, int32_t  p_50, union U3  p_51);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_1(void)
{ /* block id: 0 */
    const int16_t l_2 = (-6);
    int32_t l_4 = 0xBE56890C;
    int32_t *l_3 = &l_4;
    uint32_t l_13 = 0U;
    union U3 l_354 = {0x88785A1A};
    int32_t l_433 = 0x42CFCF38;
    uint32_t l_434 = 0x80B6D513;
    int32_t *l_435 = &l_433;
    int32_t **l_436 = &l_435;
    union U1 l_437 = {0};
    (*l_3) = l_2;
    (*l_3) = (safe_sub_func_int32_t_s_s((func_7(func_11(l_13), l_354, &l_4) | ((safe_lshift_func_uint16_t_u_u(l_13, (safe_add_func_int16_t_s_s((safe_div_func_int8_t_s_s(((safe_div_func_uint8_t_u_u(0x10, l_354.f0)) == ((~l_354.f0) < l_433)), l_433)), l_13)))) || l_433)), l_434));
    (*l_436) = l_435;
    return l_437;
    /* statement id: 169 */
    //assert (func_1_rv.f0 == 0);
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_7(union U2  p_8, union U3  p_9, int32_t * p_10)
{ /* block id: 142 */
    int8_t l_363 = 0x67;
    union U3 l_419 = {7};
    union U3 *l_418 = &l_419;
    union U3 **l_417 = &l_418;
    union U3 ***l_416 = &l_417;
    if ((safe_sub_func_int8_t_s_s(((safe_div_func_uint32_t_u_u(((safe_lshift_func_int8_t_s_u(p_9.f0, (p_9.f0 < (0x4F ^ (safe_mod_func_int8_t_s_s(4, (((l_363 | ((safe_rshift_func_int16_t_s_s(p_8.f0, l_363)) <= 1)) || ((l_363 >= 0xB6BF) | 0x56)) & p_8.f0))))))) >= l_363), (-2))) && p_9.f0), l_363)))
    { /* block id: 143 */
        int32_t l_366 = 0x8D69C6D1;
        (*p_10) = ((l_366 & ((safe_rshift_func_int8_t_s_s((0x09EA | 0x5B03), (safe_add_func_int8_t_s_s((l_363 <= l_366), (((((safe_add_func_uint32_t_u_u(p_8.f0, (&p_8 != (void*)0))) > l_366) && 0x82D7) >= 0xB295) < (*p_10)))))) & p_8.f0)) ^ (-9));
    }
    else
    { /* block id: 145 */
        int32_t **l_373 = (void*)0;
        int32_t l_375 = 0x97431A8F;
        int32_t *l_374 = &l_375;
        l_374 = (void*)0;
        /* statement id: 146 */
        assert (l_374 == 0);
        return l_363;
    }
    if (((0U && (safe_rshift_func_int16_t_s_u(l_363, ((safe_rshift_func_uint8_t_u_u((safe_div_func_int8_t_s_s((1U <= (safe_rshift_func_uint16_t_u_u(0x3038, 10))), (l_363 ^ ((7 || 65535U) & 1)))), 4)) && p_9.f0)))) == l_363))
    { /* block id: 149 */
        const struct S0 l_384 = {-0,11,-1270,15,-1,-41456,0,-399,-92};
        int8_t * const l_385 = (void*)0;
        union U3 l_386 = {0xC0CD3579};
        int32_t l_389 = 0xAAF909D7;
        int32_t *l_388 = &l_389;
        int32_t **l_387 = &l_388;
        (*l_387) = func_47(l_384, l_385, l_363, l_386);
        /* statement id: 150 */
        assert (l_388 == 0);
    }
    else
    { /* block id: 151 */
        uint32_t l_400 = 0x97D69C0A;
        struct S0 l_402 = {1,15,-757,29,-8,40583,0,-504,-47};
        struct S0 *l_401 = &l_402;
        union U3 **l_420 = &l_418;
        for (l_363 = 0; (l_363 != 26); l_363 = safe_add_func_int32_t_s_s(l_363, 1))
        { /* block id: 154 */
            int32_t l_395 = 0xD4DA4AE4;
            int32_t *l_394 = &l_395;
            int32_t **l_393 = &l_394;
            int32_t ***l_392 = &l_393;
            const int32_t * const l_399 = &l_395;
            const int32_t * const *l_398 = &l_399;
            const int32_t * const **l_397 = &l_398;
            const int32_t * const ***l_396 = &l_397;
            (*l_396) = l_392;
            /* statement id: 155 */
            assert (l_397 == &l_393);
            (*l_394) = l_400;
            l_401 = l_401;
        }
        for (p_9.f1 = 27; (p_9.f1 < 7); p_9.f1 = safe_sub_func_uint32_t_u_u(p_9.f1, 1))
        { /* block id: 161 */
            struct S0 **l_405 = &l_401;
            union U3 ***l_415 = (void*)0;
            int32_t l_423 = 4;
            (*l_405) = &l_402;
            l_419.f0 = ((safe_sub_func_int8_t_s_s((((l_363 == ((safe_unary_minus_func_int16_t_s((safe_lshift_func_uint8_t_u_u((safe_rshift_func_int8_t_s_u((l_402.f5 || 0xB274), ((safe_add_func_int16_t_s_s((l_415 != l_416), ((void*)0 != l_420))) < p_8.f0))), 3)))) ^ (safe_rshift_func_int16_t_s_u(0, 15)))) > (-1)) < l_363), p_9.f1)) == l_423);
        }
        /* facts after for loop */
            }
    /* facts after branching */
        return p_8.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_11(int32_t  p_12)
{ /* block id: 2 */
    struct S0 l_18 = {-0,126,1120,89,4,-31967,0,-365,116};
    int32_t l_352 = 0x5C1F3B26;
    int32_t *l_351 = &l_352;
    int32_t **l_350 = &l_351;
    union U2 l_353 = {0xF1};
    (*l_350) = func_14(func_16(l_18));
    /* statement id: 140 */
    assert (l_351 == 0);
    return l_353;
    /* statement id: 141 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_14(int8_t * p_15)
{ /* block id: 5 */
    union U1 l_26 = {0};
    union U4 l_27 = {0xE33ECDC0};
    union U3 l_201 = {0};
    union U3 *l_200 = &l_201;
    int32_t ***l_209 = (void*)0;
    union U2 l_230 = {6};
    int32_t l_232 = 0xB09B231F;
    int32_t *l_231 = &l_232;
    const struct S0 l_238 = {1,67,808,63,11,11049,0,188,94};
    const int8_t l_248 = 0x9C;
    uint8_t l_249 = 1U;
    int8_t *l_274 = &l_230.f0;
    int16_t l_299 = 0x126A;
    int32_t l_331 = 1;
    int32_t *l_330 = &l_331;
    int32_t ****l_337 = &l_209;
    int32_t * const l_338 = &l_331;
    int32_t * const l_339 = &l_232;
    int32_t * const l_340 = &l_331;
    int32_t * const l_341 = &l_331;
    int32_t * const l_342 = &l_331;
    int32_t * const l_343 = &l_331;
    int32_t * const l_344 = &l_331;
    int32_t * const l_345 = &l_232;
    int32_t * const l_346 = &l_232;
    int32_t * const l_347 = &l_331;
    int32_t * const l_348 = &l_232;
    int32_t * const l_349 = (void*)0;
    if (func_22(l_26, l_26, l_27))
    { /* block id: 94 */
        union U3 **l_202 = (void*)0;
        union U3 **l_203 = (void*)0;
        union U3 **l_204 = &l_200;
        int32_t l_215 = 0xC175E385;
        int32_t *l_214 = &l_215;
        (*l_204) = l_200;
        for (l_27.f0 = 0; (l_27.f0 < 3); l_27.f0 = safe_add_func_uint16_t_u_u(l_27.f0, 1))
        { /* block id: 98 */
            int32_t l_213 = 0x81CC2B1C;
            int32_t *l_212 = &l_213;
            int32_t **l_211 = &l_212;
            int32_t ***l_210 = &l_211;
            (**l_211) = (safe_add_func_uint8_t_u_u(((l_209 != l_210) != (l_214 == (void*)0)), ((safe_add_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((***l_210), ((!(safe_lshift_func_int8_t_s_s(((((*l_210) != (void*)0) && ((((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_uint8_t_u_u((safe_div_func_int32_t_s_s((~0xF4D2), (*l_214))), 6)) | (*l_214)), (**l_211))) || (*l_214)) == (**l_211)) != (*l_214))) >= (**l_211)), (**l_211)))) && l_27.f1))), 0x0CC7)) | (***l_210))));
            (***l_210) = 0x1D0A5002;
        }
        (*l_214) = (l_202 != l_203);
    }
    else
    { /* block id: 103 */
        int32_t **l_233 = &l_231;
        (*l_233) = func_33(l_230, l_27, l_231);
        /* statement id: 104 */
        assert (l_231 == 0 || l_231 == &l_232);
    }
    /* facts after branching */
    assert (l_26.f0 == 0);
    assert (l_231 == 0 || l_231 == &l_232);
    for (l_232 = (-28); (l_232 >= 16); l_232 = safe_add_func_int16_t_s_s(l_232, 1))
    { /* block id: 108 */
        int32_t *l_236 = &l_232;
        int32_t **l_237 = &l_231;
        union U3 l_239 = {0xD1606331};
        int32_t l_251 = 0x40BF26BA;
        int32_t *l_250 = &l_251;
        uint32_t l_268 = 0U;
        uint16_t l_269 = 0xE1F3;
        int32_t ****l_279 = &l_209;
        int32_t l_289 = 0xB56DCD95;
        union U3 **l_298 = &l_200;
        int8_t *l_313 = &l_230.f0;
        (*l_237) = l_236;
        /* statement id: 109 */
        assert (l_231 == &l_232);
        (*l_237) = func_47(l_238, p_15, (*l_231), l_239);
        /* statement id: 110 */
        assert (l_231 == 0);
        (*l_250) = (((*l_236) ^ (safe_sub_func_uint32_t_u_u((safe_mod_func_int8_t_s_s(((*l_236) != (safe_rshift_func_int16_t_s_u(((((safe_div_func_uint32_t_u_u(((*l_236) >= (*l_236)), l_248)) <= 0xB7F0B09D) & (0 <= (&l_232 == (void*)0))) < (*l_236)), (*l_236)))), (*l_236))), (-1)))) <= l_249);
    }
    return l_349;
    /* statement id: 139 */
    //assert (func_14_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t * func_16(struct S0  p_17)
{ /* block id: 3 */
    int8_t l_20 = 0;
    int8_t *l_19 = &l_20;
    int8_t *l_21 = (void*)0;
    return l_21;
    /* statement id: 4 */
    //assert (func_16_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_22(union U1  p_23, union U1  p_24, union U4  p_25)
{ /* block id: 6 */
    int32_t l_30 = (-3);
    union U3 l_53 = {0x19BA600A};
    int32_t l_73 = 0xB0C4F31B;
    int32_t *l_72 = &l_73;
    int32_t **l_190 = &l_72;
    int32_t ***l_189 = &l_190;
lbl_199:
    for (p_25.f3 = 20; (p_25.f3 > 56); p_25.f3 = safe_add_func_int16_t_s_s(p_25.f3, 1))
    { /* block id: 9 */
        int32_t l_32 = (-1);
        int32_t *l_31 = &l_32;
        union U2 l_37 = {-1};
        const struct S0 l_52 = {0,70,278,53,1,-13719,0,196,-71};
        const int8_t *l_71 = (void*)0;
        int32_t **l_186 = &l_72;
        int32_t ****l_198 = &l_189;
        int32_t *****l_197 = &l_198;
        (*l_31) = l_30;
        if (l_30)
            break;
        if (l_30)
            goto lbl_199;
    }
    /* facts after for loop */
        return p_25.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_33(union U2  p_34, union U4  p_35, int32_t * p_36)
{ /* block id: 43 */
    int8_t l_150 = 2;
    int8_t *l_149 = &l_150;
    int32_t l_164 = 0x999ABEDA;
    int32_t *l_163 = &l_164;
    if ((*p_36))
    { /* block id: 44 */
        return p_36;
        /* statement id: 45 */
        //assert (func_33_rv == &l_73 || func_33_rv == &l_232);
    }
    else
    { /* block id: 46 */
        uint8_t l_144 = 1U;
        int32_t *l_165 = &l_164;
        const struct S0 l_170 = {1,53,176,51,-2,-23285,0,349,-84};
        union U3 l_182 = {0x0D59F51D};
        for (p_35.f4 = 19; (p_35.f4 == 22); p_35.f4 = safe_add_func_int8_t_s_s(p_35.f4, 4))
        { /* block id: 49 */
            int16_t l_145 = 0x9E39;
            uint32_t l_154 = 0xE331E6C2;
            int32_t **l_168 = &l_163;
            int32_t ***l_167 = &l_168;
            int32_t ****l_169 = &l_167;
            if ((*p_36))
            { /* block id: 50 */
                int32_t l_143 = (-7);
                int32_t *l_142 = &l_143;
                int32_t **l_141 = &l_142;
                (*l_141) = (void*)0;
                /* statement id: 51 */
                assert (l_142 == 0);
                l_145 = l_144;
                (*l_141) = (void*)0;
            }
            else
            { /* block id: 54 */
                uint32_t l_151 = 4294967293U;
                int32_t l_162 = 0xEE683975;
                int32_t *l_161 = &l_162;
                int32_t *l_166 = (void*)0;
                (*p_36) = (p_36 == p_36);
                (*p_36) = ((safe_add_func_uint8_t_u_u(247U, ((~((*p_36) || ((void*)0 == l_149))) || (*p_36)))) > ((p_34.f1 == ((l_151 ^ 0x49) >= (safe_add_func_uint8_t_u_u(l_145, l_154)))) | 1));
                for (l_151 = 0; (l_151 != 14); l_151 = safe_add_func_uint8_t_u_u(l_151, 7))
                { /* block id: 59 */
                    int32_t **l_157 = (void*)0;
                    int32_t l_160 = 1;
                    int32_t *l_159 = &l_160;
                    int32_t **l_158 = &l_159;
                    (*l_158) = p_36;
                    /* statement id: 60 */
                    //assert (l_159 == &l_73 || l_159 == &l_232);
                    p_36 = l_161;
                    /* statement id: 61 */
                    assert (p_36 == &l_162);
                    return l_166;
                    /* statement id: 62 */
                    //assert (func_33_rv == 0);
                }
            }
            (*l_169) = l_167;
            (*l_169) = (*l_169);
            (***l_167) = 0xA979D12D;
        }
        /* facts after for loop */
                if ((*l_165))
        { /* block id: 69 */
            uint16_t l_177 = 65532U;
            const int32_t *l_184 = &l_164;
            const int32_t **l_183 = &l_184;
            (*l_183) = func_47(l_170, &l_150, (((((safe_lshift_func_int8_t_s_u((2U < (!(~(safe_rshift_func_uint16_t_u_s((&l_163 == (void*)0), 13))))), ((*l_165) < (l_177 | (safe_sub_func_int32_t_s_s((*p_36), ((safe_mod_func_uint32_t_u_u(4294967295U, 0x61F3FAF8)) || (*p_36)))))))) <= 0U) <= 0U) > p_35.f1) || 3), l_182);
            /* statement id: 70 */
            assert (l_184 == 0);
        }
        else
        { /* block id: 71 */
            int32_t **l_185 = &l_163;
            (*l_185) = p_36;
            /* statement id: 72 */
            //assert (l_163 == &l_73 || l_163 == &l_232);
            (*l_185) = &l_164;
            /* statement id: 73 */
            assert (l_163 == &l_164);
            (*l_163) = (*l_165);
        }
    }
    /* facts after branching */
        return p_36;
    /* statement id: 77 */
    //assert (func_33_rv == &l_73 || func_33_rv == &l_232);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U4  func_38(union U2  p_39, uint32_t  p_40)
{ /* block id: 29 */
    const int32_t ***l_108 = (void*)0;
    const int32_t ****l_107 = &l_108;
    int32_t l_114 = (-2);
    int32_t *l_113 = &l_114;
    int32_t **l_112 = &l_113;
    int32_t ***l_111 = &l_112;
    int32_t ****l_110 = &l_111;
    int32_t *****l_109 = &l_110;
    union U4 l_130 = {4294967288U};
    int32_t *l_138 = &l_114;
    (*l_109) = l_107;
    /* statement id: 30 */
    assert (l_110 == &l_108);
    (**l_112) = (p_40 != ((safe_sub_func_int8_t_s_s((((0x3D7553AF < (p_39.f0 != (safe_unary_minus_func_uint32_t_u((safe_add_func_uint8_t_u_u(((*l_113) == p_39.f0), ((4294967294U >= (safe_unary_minus_func_int8_t_s(0xA8))) | p_40))))))) <= (safe_rshift_func_int16_t_s_u(0, p_39.f1))) != (**l_112)), 0x80)) ^ p_40));
    for (p_39.f1 = 0; (p_39.f1 < 59); p_39.f1 = safe_add_func_int16_t_s_s(p_39.f1, 1))
    { /* block id: 34 */
        uint32_t l_129 = 0U;
        union U4 l_131 = {1U};
        if ((safe_mod_func_uint16_t_u_u(l_129, ((&l_107 == (void*)0) & l_129))))
        { /* block id: 35 */
            return l_130;
            /* statement id: 36 */
                    }
        else
        { /* block id: 37 */
            return l_131;
            /* statement id: 38 */
                    }
    }
    /* facts after for loop */
        (**l_112) = (safe_div_func_int32_t_s_s(0x1AC0D59B, ((((((safe_rshift_func_int16_t_s_u((**l_112), ((safe_add_func_int32_t_s_s((l_138 == (*l_112)), ((**l_111) == (*l_112)))) & (9U & (0xE8ED7A3F > p_39.f1))))) >= p_39.f0) || (-1)) >= p_39.f1) || (-10)) | p_40)));
    return l_130;
    /* statement id: 42 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_41(int32_t * p_42, const int8_t * p_43, int32_t * p_44, uint8_t  p_45, uint32_t  p_46)
{ /* block id: 15 */
    uint32_t l_78 = 0x52423599;
    int8_t l_83 = 0xB0;
    int8_t *l_82 = &l_83;
    int32_t l_85 = 0x420880F5;
    int32_t *l_84 = &l_85;
    const int32_t **l_86 = (void*)0;
    int32_t **l_87 = &l_84;
    const struct S0 l_89 = {1,12,-625,20,-1,-23703,0,169,-102};
    union U3 l_91 = {0x4BD6B41A};
    int32_t ***l_103 = &l_87;
    int32_t **** const l_102 = &l_103;
    union U2 l_106 = {0xE5};
    (*p_44) = ((((((safe_rshift_func_int16_t_s_s((safe_div_func_int8_t_s_s(l_78, l_78)), (0xD735AE52 && l_78))) & (0 | l_78)) && ((!(safe_lshift_func_int16_t_s_s(p_46, 13))) > (p_45 == ((void*)0 == l_82)))) <= p_45) <= (-7)) > 4294967293U);
    (*l_87) = l_84;
    (*l_87) = (void*)0;
    /* statement id: 18 */
    assert (l_84 == 0);
    if ((*p_44))
    { /* block id: 19 */
        int32_t ***l_88 = &l_87;
        int8_t * const l_90 = &l_83;
        int32_t l_95 = 0x95C78ED0;
        union U3 l_96 = {8};
        (*l_88) = &l_84;
        (**l_88) = func_47(l_89, l_90, ((p_46 & 0x62) == p_46), l_91);
        (*l_87) = func_47(l_89, l_90, (safe_unary_minus_func_uint8_t_u((safe_rshift_func_uint8_t_u_u(l_95, ((p_46 || l_95) || p_46))))), l_96);
    }
    else
    { /* block id: 23 */
        int32_t l_99 = (-7);
        int32_t ****l_105 = &l_103;
        int32_t *****l_104 = &l_105;
        (*p_44) = ((safe_rshift_func_int16_t_s_s((l_99 ^ 0xA3A0A773), 0)) >= ((safe_add_func_int16_t_s_s((((p_45 != l_99) && l_99) ^ ((*p_44) && ((l_99 | p_45) ^ p_45))), p_45)) < p_45));
        (*l_104) = l_102;
        return l_106;
        /* statement id: 26 */
            }
    return l_106;
    /* statement id: 28 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_47(const struct S0  p_48, int8_t * const  p_49, int32_t  p_50, union U3  p_51)
{ /* block id: 12 */
    uint32_t l_56 = 0xDC0AC77A;
    int8_t *l_59 = (void*)0;
    int32_t l_68 = 0xF20CF680;
    int32_t * const l_67 = &l_68;
    int32_t *l_69 = &l_68;
    int32_t *l_70 = (void*)0;
    (*l_67) = ((safe_add_func_int16_t_s_s((0x1B && l_56), (((safe_mod_func_uint32_t_u_u((p_49 != l_59), l_56)) ^ (safe_div_func_uint16_t_u_u((safe_add_func_uint8_t_u_u((p_49 == p_49), (!((safe_lshift_func_uint16_t_u_u(((void*)0 == l_67), 0)) & 0x88A0)))), 0x86E6))) != p_48.f4))) == (*l_67));
    return l_70;
    /* statement id: 14 */
    //assert (func_47_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 109
   depth: 1, occurrence: 6
XXX total union variables: 17

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 14
   indirect level: 1, occurrence: 2
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 2
XXX full-bitfields structs in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX times a bitfields struct's address is taken: 4
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 12

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 6
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 135

XXX times a variable address is taken: 119
XXX times a pointer is dereferenced on RHS: 85
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 14
   depth: 3, occurrence: 14
XXX times a pointer is dereferenced on LHS: 54
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 375

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 199
   level: 2, occurrence: 43
   level: 3, occurrence: 36
   level: 4, occurrence: 18
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 64
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 1
XXX percent of pointers has null in alias set: 30.4
XXX average alias set size: 1.15

XXX times a non-volatile is read: 471
XXX times a non-volatile is write: 139
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 81
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 26
   depth: 2, occurrence: 17
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

