/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      138451784
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int16_t  f0;
   uint8_t  f1;
   const unsigned f2 : 25;
   uint8_t  f3;
   uint16_t  f4;
   unsigned f5 : 26;
   uint8_t  f6;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 15;
   const unsigned f1 : 30;
   unsigned f2 : 17;
   unsigned f3 : 14;
   signed f4 : 30;
};

union U2 {
   int8_t  f0;
   uint32_t  f1;
};

union U3 {
   signed f0 : 25;
   int8_t  f1;
   uint16_t  f2;
   uint32_t  f3;
   int32_t  f4;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_14 = (-1);
static struct S0 g_28 = {-3,0x1B,5413,0x7A,0xD7C8,5562,0x6A};
static int32_t g_58 = 0xC1B2D863;
static int32_t * const g_57 = &g_58;
static union U3 g_90 = {9};
static struct S0 *g_113[7][8] = {{&g_28,(void*)0,&g_28,&g_28,(void*)0,&g_28,&g_28,(void*)0},{(void*)0,&g_28,&g_28,(void*)0,&g_28,&g_28,(void*)0,&g_28},{(void*)0,(void*)0,&g_28,(void*)0,(void*)0,&g_28,(void*)0,(void*)0},{&g_28,(void*)0,&g_28,&g_28,(void*)0,&g_28,&g_28,(void*)0},{(void*)0,&g_28,&g_28,(void*)0,&g_28,&g_28,(void*)0,&g_28},{(void*)0,(void*)0,&g_28,(void*)0,(void*)0,&g_28,&g_28,&g_28},{&g_28,&g_28,&g_28,&g_28,&g_28,&g_28,&g_28,&g_28}};
static struct S0 **g_112 = &g_113[3][1];
static const uint8_t g_117 = 0U;
static union U3 **g_123 = (void*)0;
static int32_t g_130 = 0x377FA487;
static int32_t *g_129 = &g_130;
static uint16_t g_157 = 0x1531;
static int8_t g_163[8] = {(-5),1,1,(-5),1,1,(-5),1};
static union U3 ****g_185 = (void*)0;
static union U3 *g_205 = (void*)0;
static const union U2 g_231 = {-5};
static const struct S0 *g_249 = &g_28;
static const struct S0 **g_248[8][6] = {{&g_249,&g_249,&g_249,&g_249,(void*)0,(void*)0},{&g_249,&g_249,&g_249,&g_249,&g_249,&g_249},{&g_249,&g_249,(void*)0,&g_249,&g_249,&g_249},{&g_249,&g_249,&g_249,&g_249,&g_249,&g_249},{&g_249,&g_249,&g_249,&g_249,&g_249,&g_249},{&g_249,&g_249,&g_249,(void*)0,(void*)0,&g_249},{&g_249,&g_249,(void*)0,&g_249,&g_249,&g_249},{&g_249,&g_249,&g_249,&g_249,(void*)0,(void*)0}};
static const struct S0 ***g_247 = &g_248[6][3];
static const struct S0 ****g_246 = &g_247;
static union U2 *g_254 = (void*)0;
static union U2 **g_253 = &g_254;
static struct S1 g_314 = {130,27229,345,120,-21571};
static const struct S1 *g_313 = &g_314;
static union U3 g_319 = {0xF48B5C4B};
static union U2 g_366 = {0x97};
static union U3 ***g_448 = &g_123;
static int8_t g_630 = 0;
static int32_t g_638 = 0x3C57D527;
static int32_t *g_637 = &g_638;
static const int32_t *g_653 = &g_14;
static int32_t g_659 = (-1);
static const union U2 *g_699 = (void*)0;
static struct S0 g_727 = {-2,8U,1741,1U,1U,3372,0x7D};
static int32_t g_729 = 0xB50B9649;


/* --- FORWARD DECLARATIONS --- */
inline static union U3  func_1(void);
static int32_t * func_2(int32_t * p_3, const struct S1  p_4, struct S0  p_5, int32_t * p_6);
static int32_t * func_7(uint8_t  p_8, int32_t * p_9, int32_t * p_10, int32_t * p_11);
inline static int32_t * func_15(struct S0  p_16, const int32_t * p_17, struct S1  p_18, uint32_t  p_19);
inline static struct S0  func_20(union U3  p_21);
inline static int32_t * func_29(int16_t  p_30, int32_t * p_31, int32_t * const  p_32, int32_t * p_33);
inline static const uint32_t  func_36(int32_t * p_37, uint32_t  p_38, uint32_t  p_39, const uint32_t  p_40);
static int32_t * func_41(int16_t  p_42, int32_t * const  p_43);
inline static const uint32_t  func_44(int32_t * p_45, const union U2  p_46, int32_t * p_47, uint32_t  p_48, uint32_t  p_49);
inline static int32_t * func_51(int32_t * const  p_52, int32_t * const  p_53, const uint32_t  p_54, int32_t * p_55, union U3  p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_28 g_57 g_58 g_112 g_117 g_113 g_123 g_157 g_90.f1 g_90.f0 g_163 g_185 g_90.f2 g_129 g_130 g_246 g_253 g_231.f0 g_319.f0 g_314.f3 g_630 g_637 g_254 g_314.f2 g_638 g_313 g_314 g_90.f4 g_366.f0 g_448 g_653 g_366.f1 g_727
 * writes: g_14 g_58 g_90.f1 g_90.f3 g_123 g_129 g_130 g_163 g_185 g_205 g_90.f2 g_113 g_253 g_157 g_638 g_90.f4 g_653 g_28.f1 g_254 g_28.f6 g_28.f4 g_699 g_637 g_319.f1 g_366.f1
 */
inline static union U3  func_1(void)
{ /* block id: 0 */
    uint8_t l_12 = 0x0D;
    int32_t *l_13 = &g_14;
    union U3 l_22 = {0x11721670};
    const union U2 l_50 = {-1};
    uint8_t l_636 = 0x12;
    int32_t *l_728 = &g_729;
    int32_t **l_731 = &l_728;
    (*l_731) = func_2(func_7(l_12, l_13, l_13, func_15(func_20(l_22), func_29(((safe_mod_func_int16_t_s_s((func_36(func_41((func_44(l_13, l_50, func_51(g_57, &g_58, g_58, &g_58, l_22), g_28.f2, g_28.f1) <= 1), l_13), g_231.f0, g_157, g_28.f2) | g_28.f6), l_636)) || g_28.f5), g_637, l_13, &g_638), (*g_313), g_28.f1)), (*g_313), g_727, l_728);
    /* statement id: 488 */
    //assert (g_129 == &g_58 || g_129 == &g_130 || g_129 == &g_14 || g_129 == 0 || g_129 == dangling);
    assert (g_185 == &g_448);
    assert (g_637 == &g_14 || g_637 == &g_638 || g_637 == &g_130);
    assert (g_653 == &g_130 || g_653 == &g_14);
    assert (g_699 == &g_231 || g_699 == &g_366 || g_699 == 0);
    assert (l_728 == &g_638 || l_728 == &g_130);
    return l_22;
    /* statement id: 489 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_185
 */
static int32_t * func_2(int32_t * p_3, const struct S1  p_4, struct S0  p_5, int32_t * p_6)
{ /* block id: 485 */
    union U3 *****l_730 = &g_185;
    (*l_730) = &g_448;
    return p_3;
    /* statement id: 487 */
    //assert (func_2_rv == &g_638 || func_2_rv == &g_130);
}


/* ------------------------------------------ */
/* 
 * reads : g_366.f1 g_14 g_112
 * writes: g_14 g_366.f1 g_205 g_113
 */
static int32_t * func_7(uint8_t  p_8, int32_t * p_9, int32_t * p_10, int32_t * p_11)
{ /* block id: 475 */
    struct S0 *l_726 = &g_28;
    (*p_9) = ((void*)0 != &g_246);
    for (g_366.f1 = 16; (g_366.f1 == 42); g_366.f1 = safe_add_func_int16_t_s_s(g_366.f1, 5))
    { /* block id: 479 */
        union U3 **l_725 = &g_205;
        if ((*p_9))
            break;
        (*l_725) = (void*)0;
        (*g_112) = l_726;
    }
    /* facts after for loop */
    return p_11;
    /* statement id: 484 */
    //assert (func_7_rv == &g_638 || func_7_rv == &g_130);
}


/* ------------------------------------------ */
/* 
 * reads : g_90.f4 g_366.f0 g_185 g_448 g_123 g_630 g_14 g_90.f0 g_117 g_57 g_253 g_254 g_653 g_130 g_90.f1 g_28.f6 g_28.f2 g_319.f0 g_58 g_637 g_28.f1
 * writes: g_185 g_90.f4 g_653 g_58 g_28.f1 g_254 g_28.f6 g_28.f4 g_699 g_637 g_638 g_130 g_319.f1
 */
inline static int32_t * func_15(struct S0  p_16, const int32_t * p_17, struct S1  p_18, uint32_t  p_19)
{ /* block id: 415 */
    union U3 ****l_646 = &g_448;
    union U3 *****l_647 = &g_185;
    int32_t l_655 = 0xE01946F3;
    struct S1 * const l_661 = (void*)0;
    struct S1 * const *l_660 = &l_661;
    struct S0 ** const l_668 = &g_113[3][1];
    (*l_647) = l_646;
    /* statement id: 416 */
    assert (g_185 == &g_448);
    for (g_90.f4 = 0; (g_90.f4 >= (-6)); g_90.f4--)
    { /* block id: 419 */
        const int32_t **l_650 = (void*)0;
        const int32_t *l_652 = &g_14;
        const int32_t **l_651[1][9] = {{&l_652,&l_652,&l_652,&l_652,&l_652,&l_652,&l_652,&l_652,&l_652}};
        int32_t l_654[8][7] = {{0xC6E5A259,0xC6E5A259,0,0xC6E5A259,0xC6E5A259,0,0xC6E5A259},{0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259},{0xA643E928,0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259,0xA643E928,0xA643E928},{0xC6E5A259,0xC6E5A259,0,0xC6E5A259,0xC6E5A259,0,0xC6E5A259},{0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259},{0xA643E928,0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259,0xA643E928,0xA643E928},{0xC6E5A259,0xC6E5A259,0,0xC6E5A259,0xC6E5A259,0,0xC6E5A259},{0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259,0xA643E928,0xA643E928,0xC6E5A259}};
        int32_t *l_662[6][4][9] = {{{&g_130,&g_58,(void*)0,(void*)0,&g_130,&g_130,&l_655,&g_130,&g_14},{&g_130,&g_130,&l_655,&g_130,(void*)0,&g_58,&g_130,&l_655,&g_638},{&g_58,&l_655,(void*)0,&g_130,&g_58,&l_655,&g_638,&g_638,&l_655},{&g_130,&g_638,&g_58,&g_638,&g_130,(void*)0,&g_14,&g_58,&l_655}},{{&g_130,&l_655,(void*)0,&g_638,&l_655,&g_130,&l_655,(void*)0,&g_14},{&g_58,(void*)0,&g_638,&g_638,&g_14,(void*)0,&l_655,&g_58,&g_638},{&g_130,&g_638,&g_130,&g_130,&g_14,&l_655,(void*)0,(void*)0,(void*)0},{&g_14,&g_638,(void*)0,&g_130,(void*)0,&g_58,(void*)0,(void*)0,&g_638}},{{(void*)0,&g_130,&g_130,&g_130,&g_638,&g_130,&g_130,&l_655,&g_130},{&g_130,&g_130,&l_655,(void*)0,&g_130,&g_14,&g_130,(void*)0,&g_14},{&g_130,&g_638,&g_14,&g_58,&g_130,&g_58,(void*)0,&l_655,(void*)0},{(void*)0,&g_14,&g_130,&g_130,&g_14,(void*)0,&g_14,&g_130,&l_655}},{{(void*)0,&g_14,&g_130,(void*)0,&l_655,&g_58,&g_58,(void*)0,&g_130},{&g_130,&g_130,&l_655,&g_638,&g_58,&l_655,&g_14,&g_14,&g_58},{&g_14,(void*)0,&g_14,&g_130,&g_130,&g_58,(void*)0,&g_638,&l_655},{&g_638,&g_130,(void*)0,&g_130,(void*)0,&g_14,&g_130,&l_655,&l_655}},{{&l_655,&g_14,&g_14,&g_130,&g_130,(void*)0,&g_130,&g_58,(void*)0},{&g_130,&g_14,&g_14,(void*)0,&g_58,&g_14,(void*)0,(void*)0,&l_655},{&g_130,&g_638,(void*)0,(void*)0,&l_655,&g_14,(void*)0,&g_130,&g_130},{&g_130,&l_655,&g_14,(void*)0,&g_14,&l_655,&g_130,&g_58,&l_655}},{{&g_58,&g_130,&l_655,(void*)0,&g_638,&l_655,&g_130,&l_655,(void*)0},{&g_638,&g_638,&g_130,&g_14,&g_58,&g_638,&g_58,&g_58,&g_638},{&g_58,(void*)0,&g_130,&g_14,&g_638,(void*)0,&g_638,&g_130,&g_58},{&g_638,&l_655,&g_14,&g_14,&g_14,(void*)0,&g_638,(void*)0,&g_58}}};
        union U3 ** const *l_674[7][7][5] = {{{(void*)0,&g_123,(void*)0,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,(void*)0,&g_123,&g_123},{(void*)0,&g_123,&g_123,&g_123,(void*)0},{&g_123,&g_123,(void*)0,&g_123,&g_123},{(void*)0,&g_123,(void*)0,&g_123,&g_123},{&g_123,&g_123,&g_123,(void*)0,&g_123}},{{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,(void*)0,&g_123},{&g_123,&g_123,&g_123,(void*)0,&g_123},{&g_123,&g_123,&g_123,&g_123,(void*)0}},{{&g_123,&g_123,&g_123,(void*)0,&g_123},{&g_123,(void*)0,&g_123,&g_123,(void*)0},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,(void*)0,&g_123,&g_123},{(void*)0,&g_123,&g_123,&g_123,(void*)0},{(void*)0,&g_123,&g_123,&g_123,(void*)0},{(void*)0,(void*)0,&g_123,(void*)0,&g_123}},{{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,(void*)0,&g_123,(void*)0},{&g_123,&g_123,&g_123,&g_123,(void*)0}},{{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,(void*)0,&g_123},{&g_123,(void*)0,(void*)0,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{(void*)0,&g_123,&g_123,(void*)0,&g_123},{&g_123,&g_123,(void*)0,&g_123,(void*)0}},{{&g_123,(void*)0,&g_123,&g_123,(void*)0},{(void*)0,&g_123,&g_123,&g_123,&g_123},{&g_123,(void*)0,&g_123,(void*)0,&g_123},{&g_123,&g_123,(void*)0,&g_123,(void*)0},{(void*)0,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,(void*)0},{&g_123,&g_123,(void*)0,(void*)0,&g_123}},{{&g_123,&g_123,(void*)0,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{(void*)0,&g_123,&g_123,&g_123,&g_123},{(void*)0,&g_123,&g_123,(void*)0,&g_123},{&g_123,(void*)0,&g_123,(void*)0,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123},{&g_123,&g_123,&g_123,&g_123,&g_123}}};
        union U3 ** const **l_673 = &l_674[6][1][0];
        int32_t l_719 = (-9);
        int i, j, k;
        g_653 = p_17;
        p_17 = &g_14;
        /* statement id: 421 */
        assert (p_17 == &g_14);
        (*g_57) = (((!(safe_sub_func_uint8_t_u_u(0x34, p_18.f2))) && ((((safe_sub_func_int32_t_s_s(((l_668 == (void*)0) & (0x9A47CA6D ^ g_366.f0)), ((((((safe_lshift_func_int16_t_s_s(((void*)0 != (**g_185)), 12)) == ((((safe_add_func_uint8_t_u_u((((l_673 != &l_674[4][0][0]) || 0x24) ^ 2U), 0xAC)) & g_630) > 0x3A667183) && (*l_652))) ^ p_18.f2) < g_90.f0) & p_18.f1) | 0))) >= g_117) > p_18.f0) < l_655)) ^ g_366.f0);
        for (p_16.f0 = 5; (p_16.f0 > 12); p_16.f0 = safe_add_func_uint32_t_u_u(p_16.f0, 1))
        { /* block id: 425 */
            int16_t l_689 = 0xE629;
            int32_t *l_700 = &g_58;
            for (g_28.f1 = (-27); (g_28.f1 > 46); g_28.f1 = safe_add_func_uint8_t_u_u(g_28.f1, 8))
            { /* block id: 428 */
                uint16_t l_696 = 2U;
                (*g_253) = (*g_253);
                for (g_28.f6 = 0; (g_28.f6 > 55); ++g_28.f6)
                { /* block id: 432 */
                    union U2 ** const l_688 = &g_254;
                    union U3 *l_710 = &g_319;
                    for (g_28.f4 = 0; (g_28.f4 < 12); g_28.f4 = safe_add_func_uint8_t_u_u(g_28.f4, 9))
                    { /* block id: 435 */
                        uint16_t l_683[5] = {65531U,65531U,65531U,65531U,65531U};
                        const union U2 *l_697[3][6][5] = {{{&g_366,(void*)0,&g_366,&g_231,&g_231},{&g_366,&g_366,&g_366,&g_366,&g_231},{&g_366,&g_366,&g_366,&g_366,&g_366},{&g_366,(void*)0,&g_231,(void*)0,&g_366},{&g_366,&g_366,&g_366,&g_366,&g_366},{&g_231,&g_366,&g_366,&g_366,(void*)0}},{{&g_366,&g_231,&g_366,(void*)0,(void*)0},{&g_366,&g_366,(void*)0,&g_366,(void*)0},{(void*)0,(void*)0,&g_366,&g_366,&g_366},{(void*)0,(void*)0,&g_366,&g_231,&g_366},{&g_366,&g_366,(void*)0,(void*)0,&g_366},{&g_366,(void*)0,(void*)0,&g_366,&g_231}},{{&g_231,(void*)0,(void*)0,&g_366,&g_231},{&g_366,&g_366,(void*)0,&g_366,(void*)0},{&g_366,&g_231,&g_366,&g_366,&g_231},{&g_366,&g_366,&g_366,&g_366,&g_231},{&g_366,&g_366,(void*)0,(void*)0,(void*)0},{&g_366,(void*)0,&g_366,&g_231,&g_231}}};
                        const union U2 **l_698[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                        int i, j, k;
                        l_683[3] = (*g_653);
                        (*g_57) = (((safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(((void*)0 != l_688), ((g_90.f1 != l_689) >= (safe_sub_func_uint8_t_u_u(((p_16.f0 | (((safe_sub_func_uint8_t_u_u(p_18.f1, g_28.f6)) != (0xC9 < (safe_sub_func_int32_t_s_s(((l_696 >= 0x71) && g_90.f0), p_18.f4)))) >= g_28.f2)) | p_18.f4), p_16.f0))))), l_655)) | l_683[3]) & l_696);
                        g_699 = l_697[0][0][3];
                        p_17 = l_700;
                    }
                    for (p_16.f6 = 28; (p_16.f6 > 13); p_16.f6 = safe_sub_func_int32_t_s_s(p_16.f6, 8))
                    { /* block id: 443 */
                        struct S1 *l_704 = &g_314;
                        struct S1 **l_703 = &l_704;
                        union U2 **l_705 = &g_254;
                        union U2 ***l_706 = &l_705;
                        (*l_703) = &g_314;
                        (*l_706) = l_705;
                        g_637 = &g_130;
                        /* statement id: 446 */
                        assert (g_637 == &g_130);
                    }
                    for (p_16.f1 = 0; (p_16.f1 >= 33); p_16.f1 = safe_add_func_int8_t_s_s(p_16.f1, 6))
                    { /* block id: 450 */
                        union U3 *l_709 = &g_90;
                        l_710 = l_709;
                        /* statement id: 451 */
                        assert (l_710 == &g_90);
                    }
                    /* facts after for loop */
                    assert (l_710 == &g_90 || l_710 == &g_319);
                }
                for (g_638 = 0; (g_638 == (-25)); --g_638)
                { /* block id: 456 */
                    l_700 = &g_14;
                    /* statement id: 457 */
                    assert (l_700 == &g_14);
                    if (l_696)
                        continue;
                }
                (*g_637) = (p_16.f1 < ((g_28.f6 > (&l_661 != (void*)0)) | (((safe_lshift_func_uint8_t_u_u((g_90.f4 && ((l_655 <= (safe_add_func_uint32_t_u_u(g_319.f0, 0x04C37E2B))) && (safe_add_func_int16_t_s_s(((((*l_700) != 0x75) < l_655) || p_18.f2), g_366.f0)))), 4)) ^ p_18.f4) >= l_719)));
            }
            /* facts after for loop */
            assert (g_637 == &g_130 || g_637 == &g_638);
            assert (p_17 == &g_58 || p_17 == &g_14);
            assert (g_699 == &g_231 || g_699 == &g_366 || g_699 == 0);
            assert (l_700 == &g_14 || l_700 == &g_58);
            return &g_638;
            /* statement id: 462 */
            //assert (func_15_rv == &g_638);
        }
    }
    /* facts after for loop */
    assert (p_17 == &g_14 || p_17 == &g_130);
    assert (g_653 == &g_130 || g_653 == &g_14);
    for (g_28.f1 = 0; (g_28.f1 != 57); g_28.f1 = safe_add_func_uint32_t_u_u(g_28.f1, 1))
    { /* block id: 467 */
        for (g_319.f1 = 4; (g_319.f1 >= 0); g_319.f1 -= 1)
        { /* block id: 470 */
            int32_t **l_722 = &g_637;
            (*l_722) = &g_14;
            /* statement id: 471 */
            assert (g_637 == &g_14);
        }
        /* facts after for loop */
    }
    /* facts after for loop */
    assert (g_637 == &g_14 || g_637 == &g_638);
    return &g_130;
    /* statement id: 474 */
    //assert (func_15_rv == &g_130);
}


/* ------------------------------------------ */
/* 
 * reads : g_14 g_28
 * writes: g_14
 */
inline static struct S0  func_20(union U3  p_21)
{ /* block id: 1 */
    uint32_t l_23 = 2U;
    int32_t *l_24 = (void*)0;
    int32_t *l_25 = (void*)0;
    int32_t *l_26 = (void*)0;
    int32_t *l_27 = &g_14;
    (*l_27) = l_23;
    (*l_27) = (*l_27);
    return g_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_253 g_254 g_163 g_314.f2 g_130 g_638
 * writes: g_638
 */
inline static int32_t * func_29(int16_t  p_30, int32_t * p_31, int32_t * const  p_32, int32_t * p_33)
{ /* block id: 411 */
    union U2 *l_642 = (void*)0;
    int32_t l_645[5] = {0x77F682C8,0x77F682C8,0x77F682C8,0x77F682C8,0x77F682C8};
    int i;
    (*p_33) = (!(safe_mod_func_uint32_t_u_u(0xC41000C8, ((0x46EC1913 >= ((*g_253) == l_642)) && (((g_163[5] == 65535U) <= ((safe_rshift_func_int8_t_s_s(0x5F, ((l_645[4] | (0x55C20194 && 5)) == g_314.f2))) != g_314.f2)) ^ g_130)))));
    (*p_33) = (*p_33);
    return &g_130;
    /* statement id: 414 */
    //assert (func_29_rv == &g_130);
}


/* ------------------------------------------ */
/* 
 * reads : g_90.f2 g_130 g_163 g_58 g_57 g_319.f0 g_28.f0 g_314.f3 g_630
 * writes: g_90.f2 g_130 g_129 g_157 g_58
 */
inline static const uint32_t  func_36(int32_t * p_37, uint32_t  p_38, uint32_t  p_39, const uint32_t  p_40)
{ /* block id: 143 */
    int32_t l_286 = 1;
    int32_t *l_320 = &g_58;
    union U2 **l_332[7];
    int32_t l_515[1];
    struct S1 *l_529 = &g_314;
    struct S0 ***l_564 = &g_112;
    struct S0 ****l_563 = &l_564;
    int32_t l_603 = 0x8424E8B0;
    uint32_t l_606 = 8U;
    int i;
    for (i = 0; i < 7; i = i + 1)
        l_332[i] = &g_254;
    for (i = 0; i < 1; i = i + 1)
        l_515[i] = 0x7793DC51;
lbl_625:
    for (g_90.f2 = 0; (g_90.f2 <= 5); g_90.f2 += 1)
    { /* block id: 146 */
        uint8_t l_277[5];
        int32_t *l_288 = &g_58;
        int32_t **l_291 = &l_288;
        const int8_t l_355 = 0x20;
        uint32_t l_357 = 0x46ECEDAA;
        const union U3 *l_395 = (void*)0;
        const union U3 **l_394 = &l_395;
        const union U3 ***l_393 = &l_394;
        const union U3 ****l_392 = &l_393;
        const union U3 *****l_391 = &l_392;
        struct S0 *l_409 = &g_28;
        struct S1 *l_411 = &g_314;
        struct S1 **l_410[6][10] = {{&l_411,(void*)0,&l_411,(void*)0,&l_411,&l_411,(void*)0,&l_411,(void*)0,&l_411},{&l_411,(void*)0,&l_411,(void*)0,&l_411,&l_411,(void*)0,&l_411,(void*)0,&l_411},{&l_411,(void*)0,(void*)0,(void*)0,&l_411,&l_411,(void*)0,&l_411,&l_411,&l_411},{&l_411,(void*)0,&l_411,(void*)0,&l_411,&l_411,(void*)0,&l_411,(void*)0,&l_411},{&l_411,(void*)0,&l_411,(void*)0,&l_411,&l_411,(void*)0,&l_411,(void*)0,&l_411},{&l_411,(void*)0,(void*)0,(void*)0,&l_411,&l_411,(void*)0,&l_411,&l_411,&l_411}};
        int32_t l_459 = 0x2AF85F3C;
        const uint16_t l_498[8][10][3] = {{{0xD354,0xB51D,0xDDAE},{8U,8U,0xC578},{0x8C03,0xE4D9,0xB9EB},{0x2E25,0xD722,0xB68D},{5U,0x9CE0,0xEEFC},{0x8B17,0x2E25,0xB68D},{0xDDAE,1U,0xB9EB},{9U,0x93AB,0xC578},{0x8336,0x35EA,0x9CE0},{65529U,1U,0xBF4B}},{{3U,0xA993,0xBC5B},{0x3A7C,9U,0xE4D9},{0x76D0,0U,0xE14F},{0xEEFC,0x3509,1U},{0xD722,0xCDB7,0x8332},{0x39F4,9U,0U},{0x2638,0x8B17,65532U},{65535U,0U,0xCF87},{1U,0xC578,0U},{1U,0x39F4,0x2638}},{{65535U,1U,0xD354},{0x2638,0x8332,1U},{0x39F4,0U,0xE7C6},{0xD722,65529U,0x486A},{0xEEFC,0xDDAE,0xB2A4},{0x76D0,0x2667,0x3A7C},{0x3A7C,0xD5E6,0x8B17},{3U,0xB9EB,3U},{65529U,0xD085,0xD085},{0x8336,0x89F0,0x2E25}},{{9U,0x6155,0x76D0},{0xDDAE,1U,0x39F4},{0x8B17,0xC0D5,0xF118},{5U,1U,0x9756},{0x2E25,0x6155,0xBE9F},{0x8C03,0x89F0,0xA993},{8U,0xD085,0x2667},{1U,0xB9EB,1U},{9U,0xD5E6,65528U},{6U,0x2667,1U}},{{0x8332,0xDDAE,65535U},{65532U,65529U,65535U},{1U,0U,65531U},{65535U,0x8332,8U},{0xBA79,1U,0x93AB},{0x3509,0x39F4,0xAFB8},{0xC0D5,0xC578,0xAFB8},{0x4497,0U,0x93AB},{1U,0x8B17,8U},{0xBE9F,9U,65531U}},{{0xE4D9,0xCDB7,65535U},{0U,0x3509,65535U},{65535U,0U,1U},{1U,9U,65528U},{0xB2A4,0xA993,1U},{0x35EA,1U,0x2667},{0xA993,0x35EA,0xA993},{65535U,0x93AB,0xBE9F},{0xBC5B,1U,0x9756},{65531U,0x2E25,0xF118}},{{8U,0x9CE0,0x39F4},{65531U,0xD722,0x76D0},{0xBC5B,0xE4D9,0x2E25},{65535U,8U,0xD085},{0xA993,0xD354,0xB9EB},{0U,0xC0EB,3U},{65535U,0x486A,0x52DA},{0xCDB7,0xD5E6,65535U},{0x8B17,0xCF87,0x2572},{0xCF87,0x8C03,0xA993}},{{3U,0xB2A4,65535U},{0xDDAE,0xC0D5,1U},{0x6155,6U,8U},{0x3509,0U,0xCF87},{0x4497,0U,0x2638},{0xE14F,6U,0xB51D},{0x76D0,0xC0D5,0x9756},{0xC0EB,0xB2A4,0xD722},{0x8336,0x8C03,0xCDB7},{0xB51D,0xCF87,0xF118}}};
        struct S0 ***l_526 = (void*)0;
        struct S0 ***l_528 = &g_112;
        const uint32_t l_542 = 0xCD0C41B4;
        int i, j, k;
        for (i = 0; i < 5; i = i + 1)
            l_277[i] = 0xFD;
        for (g_130 = 1; (g_130 <= 7); g_130 += 1)
        { /* block id: 149 */
            int32_t *l_273 = &g_58;
            for (p_39 = 0; (p_39 <= 7); p_39 += 1)
            { /* block id: 152 */
                int32_t **l_274[5][10] = {{&l_273,&g_129,&l_273,&l_273,&g_129,(void*)0,(void*)0,(void*)0,&g_129,&l_273},{&l_273,(void*)0,&l_273,(void*)0,&l_273,(void*)0,&l_273,(void*)0,&l_273,&l_273},{(void*)0,&l_273,(void*)0,&l_273,&l_273,&l_273,&l_273,(void*)0,&l_273,(void*)0},{&l_273,&l_273,&l_273,&g_129,&l_273,&l_273,&g_129,(void*)0,(void*)0,(void*)0},{&l_273,&l_273,&l_273,&l_273,&l_273,&l_273,&l_273,&l_273,(void*)0,(void*)0}};
                int i, j;
                g_129 = l_273;
                /* statement id: 153 */
                assert (g_129 == &g_58);
                g_129 = (void*)0;
                /* statement id: 154 */
                assert (g_129 == 0);
            }
            for (g_157 = 0; (g_157 <= 5); g_157 += 1)
            { /* block id: 158 */
                int i;
                if (g_163[g_130])
                    break;
            }
            for (g_157 = 0; (g_157 <= 5); g_157 += 1)
            { /* block id: 163 */
                const uint32_t l_287 = 0x6B0A57D7;
                int i;
                for (p_38 = 0; (p_38 <= 7); p_38 += 1)
                { /* block id: 166 */
                    for (p_39 = 0; (p_39 <= 7); p_39 += 1)
                    { /* block id: 169 */
                        int i;
                        if (g_163[(g_90.f2 + 1)])
                            break;
                        if ((*p_37))
                            continue;
                        (*l_273) = (((safe_sub_func_int32_t_s_s(5, ((p_38 & p_40) & l_277[0]))) != (((0xE05B != ((safe_sub_func_int32_t_s_s((*g_57), ((*g_57) < (safe_rshift_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_s(((1 >= l_286) ^ 5U), g_58)), l_277[0])), 5))))) == 0xB32BA95D)) == g_130) && 0x0061F076)) & l_287);
                    }
                    (*g_57) = (l_288 == (void*)0);
                }
                (*l_288) = ((safe_add_func_uint8_t_u_u((g_163[g_130] | (*l_273)), p_39)) | 0xAD);
            }
        }
        (*l_291) = &g_58;
    }
    /* facts after for loop */
    if (((0xE33333A8 > ((safe_add_func_uint32_t_u_u(((*l_320) <= (-1)), (*p_37))) >= ((safe_sub_func_uint32_t_u_u((g_58 != (safe_rshift_func_uint8_t_u_s(p_38, 1))), (((((safe_sub_func_int8_t_s_s((*l_320), ((*g_57) & 0U))) || g_319.f0) | (*l_320)) && p_40) <= g_28.f0))) <= (*g_57)))) < p_39))
    { /* block id: 398 */
        if (p_39)
            goto lbl_625;
    }
    else
    { /* block id: 400 */
        l_320 = &g_58;
    }
    (*g_57) = (safe_rshift_func_uint8_t_u_u((safe_sub_func_int8_t_s_s(((void*)0 == &g_313), (((0U == (p_40 | (p_40 > ((((g_314.f3 == ((((-5) > (g_630 > p_40)) == p_40) && (*l_320))) == (-1)) & 255U) < (*l_320))))) & 0xB908DBCF) > p_38))), 3));
    for (p_38 = 0; (p_38 >= 8); ++p_38)
    { /* block id: 406 */
        int32_t **l_633 = &g_129;
        struct S1 *l_634[10] = {&g_314,&g_314,&g_314,&g_314,&g_314,&g_314,&g_314,&g_314,&g_314,&g_314};
        struct S1 **l_635 = &l_634[0];
        int i;
        (*l_633) = &g_58;
        /* statement id: 407 */
        assert (g_129 == &g_58);
        (*l_635) = l_634[9];
    }
    /* facts after for loop */
    //assert (g_129 == &g_58 || g_129 == &g_130 || g_129 == &g_14 || g_129 == 0 || g_129 == dangling);
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_28.f0 g_112 g_28.f5 g_117 g_57 g_58 g_28.f6 g_113 g_90.f3 g_123 g_130 g_157 g_90.f1 g_28.f3 g_90.f0 g_28.f2 g_163 g_28.f1 g_185 g_90.f2 g_28.f4 g_129 g_246 g_253 g_231.f0
 * writes: g_90.f3 g_58 g_123 g_129 g_130 g_163 g_185 g_90.f1 g_205 g_90.f2 g_113 g_253
 */
static int32_t * func_41(int16_t  p_42, int32_t * const  p_43)
{ /* block id: 47 */
    uint8_t l_114 = 0U;
    int32_t l_128 = 0xF1F153C6;
    int8_t l_162 = 1;
    int32_t **l_189 = &g_129;
    union U3 l_191 = {1};
    struct S0 *** const l_192 = &g_112;
    union U3 *l_197 = &g_90;
    union U3 **l_196[6][2][10] = {{{&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197},{&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197}},{{&l_197,&l_197,&l_197,&l_197,(void*)0,&l_197,(void*)0,&l_197,&l_197,&l_197},{(void*)0,&l_197,&l_197,(void*)0,&l_197,&l_197,(void*)0,&l_197,&l_197,(void*)0}},{{&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197},{(void*)0,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,(void*)0,&l_197,(void*)0}},{{&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197},{&l_197,(void*)0,&l_197,&l_197,(void*)0,&l_197,&l_197,(void*)0,&l_197,&l_197}},{{&l_197,(void*)0,&l_197,(void*)0,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197},{&l_197,&l_197,&l_197,&l_197,&l_197,(void*)0,&l_197,(void*)0,&l_197,&l_197}},{{(void*)0,&l_197,(void*)0,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,(void*)0},{&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197,&l_197}}};
    const uint8_t l_260 = 0U;
    int i, j, k;
    if ((((safe_sub_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((((safe_sub_func_uint8_t_u_u((g_28.f0 ^ ((void*)0 != g_112)), ((-1) | l_114))) >= ((p_42 == (((((p_42 & (safe_rshift_func_int16_t_s_u(g_28.f5, 5))) ^ ((((((p_42 >= l_114) == 2U) ^ (-4)) >= p_42) | 0x232C3778) > l_114)) == l_114) || g_117) & (*g_57))) < 0U)) != p_42) == (*g_57)), 4)), g_28.f6)) <= p_42) && 0xEB))
    { /* block id: 48 */
        int32_t l_120 = 1;
        struct S0 ***l_198 = &g_112;
        int32_t *l_229 = &l_128;
        struct S0 ** const *l_243 = &g_112;
        struct S0 ** const **l_242 = &l_243;
        struct S0 ** const ***l_241[2];
        union U2 ***l_255[1];
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_241[i] = &l_242;
        for (i = 0; i < 1; i = i + 1)
            l_255[i] = &g_253;
        if ((((safe_lshift_func_int8_t_s_u((-1), ((0x4B6F1E52 <= ((*g_112) == (void*)0)) | ((void*)0 == &g_58)))) == (0U || (l_120 != (p_42 && l_114)))) < 0x11A9))
        { /* block id: 49 */
            union U3 *** const l_133 = &g_123;
            const struct S0 **l_138 = (void*)0;
            const struct S0 ** const * const l_137[4][3][1] = {{{&l_138},{&l_138},{&l_138}},{{&l_138},{&l_138},{&l_138}},{{&l_138},{&l_138},{&l_138}},{{&l_138},{&l_138},{&l_138}}};
            int8_t l_141 = 1;
            int32_t *l_190 = &g_130;
            int i, j, k;
            for (g_90.f3 = 0; (g_90.f3 <= 6); g_90.f3 += 1)
            { /* block id: 52 */
                int32_t *l_142 = &g_130;
                int32_t **l_143[6];
                struct S0 **** const *l_164 = (void*)0;
                int i;
                for (i = 0; i < 6; i = i + 1)
                    l_143[i] = &l_142;
                for (g_58 = 2; (g_58 <= 6); g_58 += 1)
                { /* block id: 55 */
                    union U3 *l_122 = (void*)0;
                    union U3 ** const l_121 = &l_122;
                    if ((((void*)0 != l_121) || 0))
                    { /* block id: 56 */
                        union U3 ***l_124 = &g_123;
                        int32_t *l_127[7];
                        int i;
                        for (i = 0; i < 7; i = i + 1)
                            l_127[i] = (void*)0;
                        (*l_124) = g_123;
                        l_128 = (safe_lshift_func_uint16_t_u_u(p_42, 10));
                    }
                    else
                    { /* block id: 59 */
                        union U3 ***l_134 = &g_123;
                        int32_t *l_135 = (void*)0;
                        int32_t *l_136 = &g_130;
                        const struct S0 ** const *l_140 = &l_138;
                        const struct S0 ** const **l_139 = &l_140;
                        g_129 = (void*)0;
                        /* statement id: 60 */
                        assert (g_129 == 0);
                        (*l_136) = (safe_lshift_func_uint8_t_u_u((l_133 == (void*)0), ((void*)0 == l_134)));
                        (*l_139) = l_137[1][0][0];
                    }
                    if (l_141)
                        break;
                    l_142 = &l_128;
                    /* statement id: 65 */
                    assert (l_142 == &l_128);
                }
                /* facts after for loop */
                assert (l_142 == &l_128 || l_142 == &g_130);
                g_129 = l_142;
                /* statement id: 67 */
                assert (g_129 == &l_128 || g_129 == &g_130);
                for (g_130 = 1; (g_130 <= 5); g_130 += 1)
                { /* block id: 70 */
                    int32_t l_153[4];
                    int32_t **l_161 = &g_129;
                    struct S0 ***l_167 = &g_112;
                    struct S0 **** const l_166 = &l_167;
                    struct S0 **** const *l_165[5];
                    int i;
                    for (i = 0; i < 4; i = i + 1)
                        l_153[i] = 0x40DF3FCB;
                    for (i = 0; i < 5; i = i + 1)
                        l_165[i] = &l_166;
                    (*g_57) = 0x2C573671;
                    for (l_114 = 0; (l_114 <= 5); l_114 += 1)
                    { /* block id: 74 */
                        int i;
                        (*g_57) = ((safe_unary_minus_func_uint32_t_u((safe_add_func_uint32_t_u_u((l_143[l_114] == (void*)0), ((safe_lshift_func_int8_t_s_u((l_120 || ((safe_sub_func_uint16_t_u_u(g_28.f0, ((safe_lshift_func_int8_t_s_s((l_141 && (0x1E331E6C == 0xE64EF7B2)), 3)) | 0))) == (((p_42 && p_42) >= l_153[3]) ^ 0x97))), g_28.f5)) > 9U))))) != 1);
                    }
                    for (g_58 = 4; (g_58 >= 1); g_58 -= 1)
                    { /* block id: 79 */
                        const struct S0 *l_158 = (void*)0;
                        g_163[5] = (safe_sub_func_uint8_t_u_u((((((((l_120 < (+(251U != g_157))) <= ((g_90.f1 && ((*g_112) == l_158)) < (((((safe_rshift_func_uint8_t_u_s((((&p_43 != l_161) <= (g_28.f3 > l_141)) == l_128), 4)) != g_90.f0) == l_162) >= p_42) && 0x66))) | g_28.f2) & (-1)) != g_157) >= 0U) > l_162), p_42));
                        l_165[0] = l_164;
                        if (l_141)
                            continue;
                        if ((*g_57))
                            break;
                    }
                    /* facts after for loop */
                    //assert (l_165[0] == 0 || l_165[0] == &l_166);
                    for (l_114 = 0; (l_114 <= 6); l_114 += 1)
                    { /* block id: 87 */
                        (*l_161) = (void*)0;
                        /* statement id: 88 */
                        assert (g_129 == 0);
                    }
                }
                /* facts after for loop */
                assert (g_129 == 0 || g_129 == &l_128 || g_129 == &g_130);
                for (g_130 = 0; (g_130 <= 6); g_130 += 1)
                { /* block id: 93 */
                    uint8_t l_174 = 1U;
                    if (((safe_rshift_func_uint8_t_u_s((g_117 <= (safe_lshift_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s((l_174 ^ (g_58 <= ((((1U < p_42) <= ((0xF45DD7FD == p_42) <= (safe_add_func_uint16_t_u_u((0x36 >= (safe_sub_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((safe_add_func_int16_t_s_s((((*g_57) > (*g_57)) ^ g_163[2]), 65535U)), g_117)), p_42))), g_28.f1)))) < l_120) < 0xC5))), 2)), g_90.f1))), p_42)) > 4294967295U))
                    { /* block id: 94 */
                        return &g_130;
                        /* statement id: 95 */
                        //assert (g_129 == 0 || g_129 == dangling || g_129 == &g_130);
                        //assert (func_41_rv == &g_130);
                    }
                    else
                    { /* block id: 96 */
                        union U3 *****l_186 = &g_185;
                        (*l_186) = g_185;
                        if (l_141)
                            continue;
                    }
                }
            }
            /* facts after for loop */
            assert (g_129 == 0 || g_129 == &l_128 || g_129 == &g_130);
            l_190 = func_51(p_43, &g_58, ((g_90.f2 & p_42) < (safe_sub_func_uint16_t_u_u(((&p_43 == l_189) ^ (((l_120 <= 0) == p_42) <= g_90.f2)), l_141))), l_190, l_191);
            /* statement id: 102 */
            assert (l_190 == &g_58 || l_190 == &g_130);
        }
        else
        { /* block id: 103 */
            int8_t l_199 = 0x39;
            union U3 *l_202 = &g_90;
            int32_t l_250 = 1;
            (*g_57) = ((l_192 != l_192) != ((+(((((safe_rshift_func_int16_t_s_u((((void*)0 == l_196[2][0][4]) | (1 != 0xAC0D40F6)), 6)) >= ((void*)0 != l_198)) == ((l_120 <= (-9)) > 0xD573)) < 0x3289A580) >= 65526U)) || l_199));
            if ((g_28.f4 >= l_199))
            { /* block id: 105 */
                int32_t **l_200 = &g_129;
                int32_t l_204[6];
                int i;
                for (i = 0; i < 6; i = i + 1)
                    l_204[i] = (-1);
                (*l_200) = p_43;
                /* statement id: 106 */
                assert (g_129 == &g_14);
                if ((!p_42))
                { /* block id: 107 */
                    uint16_t l_203 = 4U;
                    l_202 = (void*)0;
                    /* statement id: 108 */
                    assert (l_202 == 0);
                    l_204[5] = l_203;
                }
                else
                { /* block id: 110 */
                    g_205 = (void*)0;
                }
                /* facts after branching */
                assert (l_202 == &g_90 || l_202 == 0);
                (*g_57) = (*g_57);
            }
            else
            { /* block id: 114 */
                int8_t l_218 = 0x51;
                struct S0 ****l_227 = &l_198;
                struct S0 ***** const l_226 = &l_227;
                const union U2 *l_230 = &g_231;
                for (g_90.f2 = 0; (g_90.f2 > 38); g_90.f2 = safe_add_func_uint32_t_u_u(g_90.f2, 1))
                { /* block id: 117 */
                    uint32_t l_228[5][9][1] = {{{4294967294U},{0x1ABEA055},{4294967295U},{4294967295U},{0x1ABEA055},{4294967294U},{0x84916890},{0x1ABEA055},{0x84916890}},{{4294967294U},{0x1ABEA055},{4294967295U},{4294967295U},{0x1ABEA055},{4294967294U},{0x84916890},{0x1ABEA055},{0x84916890}},{{4294967294U},{0x1ABEA055},{4294967295U},{4294967295U},{0x1ABEA055},{4294967294U},{0x84916890},{0x1ABEA055},{0x84916890}},{{4294967294U},{0x1ABEA055},{4294967295U},{4294967295U},{0x1ABEA055},{4294967294U},{0x84916890},{0x1ABEA055},{0x84916890}},{{4294967294U},{0x1ABEA055},{4294967295U},{4294967295U},{0x1ABEA055},{4294967294U},{0x84916890},{0x1ABEA055},{0x84916890}}};
                    int i, j, k;
                    if ((safe_mod_func_int32_t_s_s(((safe_rshift_func_int16_t_s_s(((safe_lshift_func_uint8_t_u_u(g_28.f2, ((safe_add_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s(g_90.f2, l_218)), l_199)) <= ((safe_rshift_func_int8_t_s_s(((~0x51) && (safe_lshift_func_int8_t_s_u(((-1) != ((0xFA | (safe_mod_func_int8_t_s_s((l_226 != (void*)0), 6))) <= l_228[3][3][0])), 3))), 1)) > g_58)))) >= 0U), 8)) <= g_28.f0), (**l_189))))
                    { /* block id: 118 */
                        (****l_226) = (*g_112);
                        return (*l_189);
                        /* statement id: 120 */
                        //assert (func_41_rv == &g_130);
                    }
                    else
                    { /* block id: 121 */
                        const union U2 **l_232 = &l_230;
                        (*l_232) = l_230;
                    }
                    return &g_130;
                    /* statement id: 124 */
                    //assert (func_41_rv == &g_130);
                }
                /* facts after for loop */
                l_250 = (1U == (p_42 < (safe_add_func_int8_t_s_s(((safe_add_func_int8_t_s_s((((safe_add_func_uint32_t_u_u((safe_add_func_uint32_t_u_u((&l_227 == l_241[1]), (**l_189))), ((((safe_sub_func_uint8_t_u_u(255U, (l_218 == ((g_246 != (*l_226)) < (**l_189))))) ^ p_42) == p_42) && l_218))) & g_117) <= g_90.f2), p_42)) || 4294967295U), 0x78))));
            }
            /* facts after branching */
            assert (g_129 == &g_130 || g_129 == &g_14);
            assert (l_202 == &g_90 || l_202 == 0);
            for (l_191.f4 = (-24); (l_191.f4 != (-5)); l_191.f4 = safe_add_func_uint32_t_u_u(l_191.f4, 1))
            { /* block id: 130 */
                (*l_229) = 0;
            }
            /* facts after for loop */
                        (*l_229) = 1;
        }
        /* facts after branching */
        assert (g_129 == &g_130 || g_129 == &g_14 || g_129 == 0 || g_129 == &l_128);
        g_253 = g_253;
    }
    else
    { /* block id: 136 */
        (*g_129) = (safe_add_func_uint16_t_u_u((g_163[5] > 5U), (safe_mod_func_int8_t_s_s(g_28.f0, 255U))));
        (*g_57) = (l_260 <= g_28.f4);
        (*g_129) = p_42;
    }
    /* facts after branching */
    assert (g_129 == &g_130 || g_129 == &g_14 || g_129 == 0 || g_129 == &l_128);
    (*g_57) = (safe_sub_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(((safe_add_func_int16_t_s_s(p_42, g_28.f1)) <= ((0 >= ((safe_lshift_func_uint8_t_u_s(l_191.f0, (6 && (&g_57 != (void*)0)))) == (g_28.f5 < ((1 ^ 0x2D83) >= 0x576F)))) && g_28.f4)), p_42)), g_231.f0));
    return &g_58;
    /* statement id: 142 */
    //assert (g_129 == &g_130 || g_129 == &g_14 || g_129 == 0 || g_129 == dangling);
    //assert (func_41_rv == &g_58);
}


/* ------------------------------------------ */
/* 
 * reads : g_28.f3 g_28.f4 g_57
 * writes: g_58
 */
inline static const uint32_t  func_44(int32_t * p_45, const union U2  p_46, int32_t * p_47, uint32_t  p_48, uint32_t  p_49)
{ /* block id: 44 */
    struct S0 *l_105[1];
    int i;
    for (i = 0; i < 1; i = i + 1)
        l_105[i] = &g_28;
    (*g_57) = (safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((~((-1) > (((&g_28 != l_105[0]) & (0U & g_28.f3)) < 0xCFDD0FD0))), g_28.f4)), 7));
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_28.f2 g_28.f6 g_57 g_28.f1
 * writes: g_58 g_90.f1
 */
inline static int32_t * func_51(int32_t * const  p_52, int32_t * const  p_53, const uint32_t  p_54, int32_t * p_55, union U3  p_56)
{ /* block id: 5 */
    const struct S0 *l_63 = &g_28;
    const struct S0 *l_65 = (void*)0;
    int32_t l_78 = 0x4791A13C;
    uint32_t l_81 = 1U;
    union U3 *l_89 = &g_90;
    uint8_t l_97 = 0x89;
    const struct S0 **l_98 = &l_65;
    for (p_56.f3 = 0; (p_56.f3 != 28); p_56.f3 = safe_add_func_uint16_t_u_u(p_56.f3, 2))
    { /* block id: 8 */
        struct S0 *l_76 = &g_28;
        int32_t l_77 = (-1);
        uint32_t l_84 = 0x3350090E;
        union U3 *l_93 = &g_90;
        for (g_58 = 15; (g_58 >= (-29)); --g_58)
        { /* block id: 11 */
            const struct S0 **l_64 = (void*)0;
            int32_t *l_79 = (void*)0;
            int32_t *l_80[5];
            union U3 *l_92 = &g_90;
            int i;
            for (i = 0; i < 5; i = i + 1)
                l_80[i] = &l_78;
            l_65 = l_63;
            /* statement id: 12 */
            assert (l_65 == &g_28);
            l_81 = (((safe_mod_func_int32_t_s_s(((safe_mod_func_int32_t_s_s((p_55 != (void*)0), (((p_56.f4 && (safe_rshift_func_uint8_t_u_u(((((safe_sub_func_uint32_t_u_u((p_56.f1 | ((safe_sub_func_int32_t_s_s((((l_76 == (void*)0) & 1) > (1U == g_28.f2)), l_77)) != l_78)), l_77)) != 1) & l_78) ^ g_28.f6), 0))) == 0xC4) & g_28.f2))) == 0U), (*g_57))) & (*p_53)) != g_28.f1);
            for (l_78 = 27; (l_78 < (-24)); l_78 = safe_sub_func_uint32_t_u_u(l_78, 1))
            { /* block id: 16 */
                int32_t **l_85 = (void*)0;
                int32_t **l_86 = &l_80[1];
                l_84 = (*p_53);
                (*l_86) = &g_58;
                for (l_81 = 25; (l_81 > 2); l_81--)
                { /* block id: 21 */
                    union U3 **l_91[4][1][5] = {{{&l_89,&l_89,&l_89,&l_89,&l_89}},{{&l_89,&l_89,&l_89,&l_89,&l_89}},{{&l_89,&l_89,&l_89,&l_89,&l_89}},{{&l_89,&l_89,&l_89,&l_89,&l_89}}};
                    int i, j, k;
                    p_55 = &g_58;
                    /* statement id: 22 */
                    assert (p_55 == &g_58);
                    l_92 = l_89;
                    l_93 = l_92;
                }
                for (g_90.f1 = (-25); (g_90.f1 < 27); ++g_90.f1)
                { /* block id: 28 */
                    const struct S0 **l_96 = &l_65;
                    if ((*g_57))
                        break;
                    (*l_96) = l_63;
                    (*l_96) = (*l_96);
                }
                /* facts after for loop */
            }
            /* facts after for loop */
            //assert (l_80[0] == &g_58 || l_80[0] == &l_78);
        }
        /* facts after for loop */
        assert (l_65 == &g_28 || l_65 == 0);
        return p_55;
        /* statement id: 35 */
        //assert (func_51_rv == &g_58 || func_51_rv == &g_130);
    }
    /* facts after for loop */
        if (l_97)
    { /* block id: 37 */
        union U3 **l_99 = &l_89;
        l_98 = &l_63;
        /* statement id: 38 */
        assert (l_98 == &l_63);
        (*l_99) = &p_56;
        /* statement id: 39 */
        assert (l_89 == &p_56);
    }
    else
    { /* block id: 40 */
        return &g_58;
        /* statement id: 41 */
        //assert (func_51_rv == &g_58);
    }
    /* facts after branching */
    assert (l_89 == &p_56);
    assert (l_98 == &l_63);
    return &g_58;
    /* statement id: 43 */
    //assert (func_51_rv == &g_58);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_14, "g_14", print_hash_value);
    transparent_crc(g_28.f0, "g_28.f0", print_hash_value);
    transparent_crc(g_28.f1, "g_28.f1", print_hash_value);
    transparent_crc(g_28.f2, "g_28.f2", print_hash_value);
    transparent_crc(g_28.f3, "g_28.f3", print_hash_value);
    transparent_crc(g_28.f4, "g_28.f4", print_hash_value);
    transparent_crc(g_28.f5, "g_28.f5", print_hash_value);
    transparent_crc(g_28.f6, "g_28.f6", print_hash_value);
    transparent_crc(g_58, "g_58", print_hash_value);
    transparent_crc(g_90.f0, "g_90.f0", print_hash_value);
    transparent_crc(g_90.f1, "g_90.f1", print_hash_value);
    transparent_crc(g_90.f2, "g_90.f2", print_hash_value);
    transparent_crc(g_90.f3, "g_90.f3", print_hash_value);
    transparent_crc(g_90.f4, "g_90.f4", print_hash_value);
    transparent_crc(g_117, "g_117", print_hash_value);
    transparent_crc(g_130, "g_130", print_hash_value);
    transparent_crc(g_157, "g_157", print_hash_value);
    for (i = 0; i < 8; i = i + 1)
    {
        transparent_crc(g_163[i], "g_163[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_231.f0, "g_231.f0", print_hash_value);
    transparent_crc(g_314.f0, "g_314.f0", print_hash_value);
    transparent_crc(g_314.f1, "g_314.f1", print_hash_value);
    transparent_crc(g_314.f2, "g_314.f2", print_hash_value);
    transparent_crc(g_314.f3, "g_314.f3", print_hash_value);
    transparent_crc(g_314.f4, "g_314.f4", print_hash_value);
    transparent_crc(g_366.f0, "g_366.f0", print_hash_value);
    transparent_crc(g_366.f1, "g_366.f1", print_hash_value);
    transparent_crc(g_630, "g_630", print_hash_value);
    transparent_crc(g_638, "g_638", print_hash_value);
    transparent_crc(g_659, "g_659", print_hash_value);
    transparent_crc(g_727.f0, "g_727.f0", print_hash_value);
    transparent_crc(g_727.f1, "g_727.f1", print_hash_value);
    transparent_crc(g_727.f2, "g_727.f2", print_hash_value);
    transparent_crc(g_727.f3, "g_727.f3", print_hash_value);
    transparent_crc(g_727.f4, "g_727.f4", print_hash_value);
    transparent_crc(g_727.f5, "g_727.f5", print_hash_value);
    transparent_crc(g_727.f6, "g_727.f6", print_hash_value);
    transparent_crc(g_729, "g_729", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 157
   depth: 1, occurrence: 2
XXX total union variables: 3

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 59
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 25
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 7
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 38
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 50

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 161
   depth: 2, occurrence: 38
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 182

XXX times a variable address is taken: 386
XXX times a pointer is dereferenced on RHS: 129
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 16
XXX times a pointer is dereferenced on LHS: 101
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 3
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 42
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 608

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 464
   level: 2, occurrence: 43
   level: 3, occurrence: 7
   level: 4, occurrence: 4
XXX number of pointers point to pointers: 91
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 25.8
XXX average alias set size: 1.36

XXX times a non-volatile is read: 820
XXX times a non-volatile is write: 305
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 146
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 24
   depth: 2, occurrence: 15
   depth: 3, occurrence: 23
   depth: 4, occurrence: 26
   depth: 5, occurrence: 28

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

