/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1877321880
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const float  f0;
   const uint32_t  f1;
};

union U1 {
   uint64_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_31(void);
inline static int32_t * func_32(int64_t  p_33, union U0  p_34, int32_t * p_35, int64_t  p_36);
static const float  func_43(int32_t  p_44);
inline static int32_t  func_45(int32_t * const  p_46, int32_t * p_47, int32_t * p_48, int16_t  p_49);
static int32_t * func_50(const int32_t * p_51);
inline static int32_t * func_52(uint16_t  p_53, int32_t  p_54, uint32_t  p_55, union U1  p_56, int32_t * p_57);
static int32_t  func_63(uint32_t  p_64, uint32_t  p_65, union U0  p_66, uint64_t  p_67);
static int16_t  func_70(const int32_t * p_71, int32_t * p_72, int32_t * p_73, uint32_t  p_74);
inline static const int32_t * func_75(int32_t * const  p_76, int32_t  p_77, union U1  p_78, int32_t * p_79);
static int32_t  func_83(float  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_31(void)
{ /* block id: 36 */
    uint64_t l_37 = 0x4F5AC3D6C1DFE936LL;
    union U0 l_38 = {0xA.C9B996p+79};
    int32_t *l_39 = (void*)0;
    int16_t l_40 = 7L;
    float l_186 = 0x1.7p-1;
    float *l_185 = &l_186;
    int64_t l_189 = 0xD180367A8BF02E39LL;
    uint64_t l_225 = 18446744073709551606UL;
    int32_t l_226 = 3L;
    union U1 l_248 = {0x484F157AF34785C4LL};
    uint16_t l_275 = 8UL;
    uint16_t l_294 = 6UL;
    float l_302 = 0x3.Dp-1;
    float **l_303 = &l_185;
    int32_t *l_329 = (void*)0;
    uint32_t l_332 = 0UL;
    uint16_t l_345 = 0x8411L;
    uint32_t l_352 = 0x3FE61844L;
    int32_t l_355 = 0L;
    l_39 = func_32(l_37, l_38, l_39, l_40);
    (*l_185) = 0x1.1p+1;
    if (((l_38.f1 <= ((int32_t)l_37 % (int32_t)l_189)) < (l_189 & 4L)))
    { /* block id: 89 */
        int32_t **l_190 = &l_39;
        const int32_t l_191 = 1L;
        int32_t l_199 = 0x6D3FFD88L;
        union U0 l_207 = {0x9.576A33p+36};
        int64_t l_223 = 6L;
        float l_232 = 0xE.E87FF4p+3;
        float **l_243 = &l_185;
        uint32_t l_274 = 0x529E7C32L;
        uint8_t l_290 = 0xF5L;
        if ((((void*)0 == l_190) < ((-1L) ^ l_191)))
        { /* block id: 90 */
            const int32_t *l_196 = &l_191;
            int32_t l_200 = 0xB3C6BB11L;
            for (l_40 = 0; (l_40 >= 28); l_40++)
            { /* block id: 93 */
                if (l_191)
                    break;
            }
            for (l_40 = 27; (l_40 >= (-12)); l_40 -= 6)
            { /* block id: 98 */
                l_39 = func_50(l_196);
            }
            l_200 = ((float)(l_199 == (*l_196)) - (float)0x7.B33318p+42);
        }
        else
        { /* block id: 102 */
            int32_t l_206 = 0xC77FDBCAL;
            int32_t *l_205 = &l_206;
            int64_t l_224 = 0x7D6962B2ED70B56FLL;
            int32_t * const **l_239 = (void*)0;
            float *l_247 = (void*)0;
            uint32_t l_255 = 0xC0DA5156L;
            int32_t l_273 = 3L;
            union U1 *l_286 = &l_248;
            int32_t *l_295 = &l_226;
            for (l_189 = 0; (l_189 != 15); ++l_189)
            { /* block id: 105 */
                int32_t ***l_211 = &l_190;
                int32_t l_212 = 0x62BB3BD2L;
                const int32_t *l_220 = &l_191;
                const int32_t **l_219 = &l_220;
                const int32_t ***l_218 = &l_219;
                int32_t l_231 = 1L;
                int64_t l_272 = (-1L);
                uint32_t l_276 = 0xB874153CL;
                int32_t ****l_279 = &l_211;
                int32_t *****l_278 = &l_279;
                if (l_199)
                { /* block id: 106 */
                    int32_t l_204 = 0xE31D69C6L;
                    int32_t *l_203 = &l_204;
                    int32_t ***l_209 = &l_190;
                    int32_t ****l_208 = &l_209;
                    l_205 = l_203;
                    /* statement id: 107 */
                    assert (l_205 == &l_204);
                    (*l_190) = func_50(func_32(__builtin_ffs((*l_203)), l_207, (*l_190), __builtin_bswap32((*l_205))));
                    /* statement id: 108 */
                    assert (l_39 == 0);
                    (*l_208) = (void*)0;
                    /* statement id: 109 */
                    assert (l_209 == 0);
                }
                else
                { /* block id: 110 */
                    int32_t *l_210 = &l_206;
                    (*l_190) = l_210;
                    /* statement id: 111 */
                    assert (l_39 == &l_206);
                }
                (*l_211) = &l_39;
                if ((l_212 == 0UL))
                { /* block id: 114 */
                    int64_t l_213 = 0xAF4CE8BB6BBBDF83LL;
                    return l_213;
                }
                else
                { /* block id: 116 */
                    float *l_216 = &l_186;
                    int32_t l_217 = 5L;
                    int32_t *l_233 = &l_217;
                    int32_t *** const l_242 = &l_190;
                    l_226 = (((uint32_t)(__builtin_ffsll(((((void*)0 != l_216) | l_217) < ((void*)0 != l_218))) && ((uint16_t)0UL - (uint16_t)((l_223 >= ((func_70((*l_219), &l_206, l_185, l_224) <= l_217) == l_225)) | (*l_220)))) % (uint32_t)0x1AB08536L) > l_217);
                    (*l_233) = (((int16_t)((uint16_t)((void*)0 != &l_39) - (uint16_t)l_231) >> (int16_t)4) == 0xE8EBL);
                    for (l_40 = (-1); (l_40 != 24); ++l_40)
                    { /* block id: 121 */
                        uint16_t l_236 = 65535UL;
                        float **l_244 = &l_216;
                        (*l_233) = l_236;
                        (*l_185) = (((float)(l_207.f1 != ((-0x1.1p-1) > (func_83((l_239 == &l_219)) < (((float)(((void*)0 != l_242) == ((void*)0 == l_216)) + (float)(-0x1.4p+1)) > 0x2.974CBEp-54)))) / (float)0x0.7p-1) == l_225);
                        l_244 = l_243;
                        /* statement id: 124 */
                        assert (l_244 == &l_185);
                    }
                }
                if ((**l_219))
                { /* block id: 127 */
                    uint64_t l_250 = 0x82D74585E3A436BDLL;
                    int32_t *l_251 = (void*)0;
                    int32_t ****l_258 = &l_211;
                    union U0 *l_280 = &l_38;
                    for (l_231 = 0; (l_231 < (-28)); l_231--)
                    { /* block id: 130 */
                        uint32_t l_249 = 1UL;
                        float l_252 = 0x4.Dp-1;
                        int32_t *l_253 = &l_206;
                        int16_t l_254 = 0x0367L;
                        (**l_218) = l_251;
                        /* statement id: 131 */
                        assert (l_220 == 0);
                        (*l_219) = &l_226;
                        /* statement id: 132 */
                        assert (l_220 == &l_226);
                        (*l_253) = (func_63(l_207.f1, __builtin_parity(l_255), l_38, (((uint64_t)0UL + (uint64_t)(***l_218)) <= (*l_253))) == l_255);
                    }
                    /* facts after for loop */
                    assert (l_220 == &l_226 || l_220 == &l_191);
                    (*l_258) = &l_219;
                    /* statement id: 135 */
                    assert (l_211 == &l_219);
                    if ((__builtin_parityl((((uint16_t)(((uint32_t)(((((func_63(((int32_t)(((uint16_t)l_226 + (uint16_t)(((&l_39 == &l_39) <= (-(uint16_t)((uint32_t)(1UL ^ ((uint16_t)__builtin_parityl((*l_220)) - (uint16_t)l_199)) / (uint32_t)l_191))) >= (__builtin_clzll(l_207.f1) <= 0x9D2C9FDBL))) ^ (***l_218)) + (int32_t)3L), (*l_220), l_38, (****l_258)) < (****l_258)) | 0x1E199A9337A33399LL) < l_272) < l_273) >= 1UL) - (uint32_t)l_274) != l_275) / (uint16_t)(-1L)) <= l_276)) && (*l_220)))
                    { /* block id: 136 */
                        int32_t *****l_277 = (void*)0;
                        l_278 = l_277;
                        /* statement id: 137 */
                        assert (l_278 == 0);
                        l_206 = (**l_219);
                    }
                    else
                    { /* block id: 139 */
                        const union U0 *l_282 = &l_207;
                        const union U0 **l_281 = &l_282;
                        union U1 *l_283 = &l_248;
                        union U1 **l_284 = (void*)0;
                        union U1 **l_285 = (void*)0;
                        (*l_281) = l_280;
                        /* statement id: 140 */
                        assert (l_282 == &l_38);
                        l_286 = l_283;
                    }
                    /* facts after branching */
                    assert (l_278 == &l_279 || l_278 == 0);
                }
                else
                { /* block id: 143 */
                    uint16_t l_289 = 0x8D36L;
                    int32_t l_291 = 0x23497646L;
                    float *l_293 = &l_232;
                    for (l_40 = 4; (l_40 <= (-19)); l_40 -= 3)
                    { /* block id: 146 */
                        const int32_t *l_292 = (void*)0;
                        if (l_289)
                            break;
                        l_291 = l_290;
                        (****l_278) = func_50(l_292);
                        /* statement id: 149 */
                        assert (l_39 == 0);
                        l_294 = (l_293 == l_292);
                    }
                    if (l_289)
                        break;
                    (*l_219) = func_50((****l_278));
                    /* statement id: 153 */
                    assert (l_220 == 0);
                }
                /* facts after branching */
                assert (l_211 == &l_190 || l_211 == &l_219);
                assert (l_220 == 0 || l_220 == &l_226 || l_220 == &l_191);
                assert (l_278 == &l_279 || l_278 == 0);
            }
            /* facts after for loop */
            assert (l_39 == &l_206 || l_39 == 0);
            //assert (l_205 == &l_206 || l_205 == dangling);
            (*l_295) = l_248.f1;
        }
        /* facts after branching */
        //assert (l_39 == dangling || l_39 == 0);
        l_39 = &l_226;
        /* statement id: 158 */
        assert (l_39 == &l_226);
    }
    else
    { /* block id: 159 */
        int32_t * const ***l_296 = (void*)0;
        int32_t ****l_298 = (void*)0;
        int32_t *****l_297 = &l_298;
        union U0 *l_316 = &l_38;
        union U1 l_328 = {6UL};
        const union U0 l_337 = {0xA.DE9391p-47};
        const union U0 *l_336 = &l_337;
        uint32_t l_342 = 4294967294UL;
        uint16_t l_348 = 65535UL;
        uint32_t l_353 = 0UL;
        int32_t *l_354 = &l_248.f1;
        (*l_297) = l_296;
        for (l_248.f1 = 12; (l_248.f1 < 18); l_248.f1 += 1)
        { /* block id: 163 */
            int32_t * const l_301 = &l_248.f1;
            int32_t *****l_319 = &l_298;
            float l_331 = (-0x1.1p+1);
            const union U0 *l_335 = &l_38;
            int32_t l_341 = 1L;
            if (__builtin_popcount((l_301 == (void*)0)))
            { /* block id: 164 */
                int32_t l_304 = 7L;
                int32_t *l_321 = &l_226;
                (*l_185) = __builtin_ffsl((*l_301));
                if ((((void*)0 != l_303) >= l_304))
                { /* block id: 166 */
                    uint32_t l_305 = 0x9D91489FL;
                    int32_t ** const * const **l_320 = (void*)0;
                    uint32_t l_330 = 0UL;
                    (**l_303) = ((*l_301) < l_305);
                    (*l_185) = ((float)((float)(((float)((float)l_304 / (float)((float)(l_316 == (void*)0) / (float)0x9.Fp+1)) / (float)((float)(l_319 == l_320) - (float)((void*)0 == l_321))) == ((float)((*l_321) >= (*l_301)) + (float)0x4.Cp-1)) - (float)l_38.f1) / (float)0x4.3p-1);
                    for (l_275 = 0; (l_275 > 4); l_275 += 8)
                    { /* block id: 171 */
                        uint16_t l_326 = 0x0DBBL;
                        int32_t * const l_327 = &l_248.f1;
                        (*l_321) = l_326;
                        l_329 = func_50(func_75(l_327, l_305, l_328, l_321));
                        return l_330;
                    }
                    return l_332;
                }
                else
                { /* block id: 177 */
                    uint32_t l_338 = 0xDBA26975L;
                    for (l_328.f1 = (-24); (l_328.f1 <= 23); ++l_328.f1)
                    { /* block id: 180 */
                        l_336 = l_335;
                        /* statement id: 181 */
                        assert (l_336 == &l_38);
                        return l_338;
                    }
                }
            }
            else
            { /* block id: 185 */
                union U0 * const *l_340 = &l_316;
                union U0 * const **l_339 = &l_340;
                (*l_339) = &l_335;
                /* statement id: 186 */
                assert (l_340 == &l_335);
            }
            l_341 = (*l_301);
        }
        /* facts after for loop */
                        (*l_354) = (l_294 || (__builtin_ia32_crc32qi((((l_342 == ((int16_t)l_345 >> (int16_t)l_37)) & l_337.f1) & (((uint16_t)l_348 >> (uint16_t)(~((int16_t)l_348 >> (int16_t)(func_45(&l_226, &l_226, &l_226, l_352) <= l_294)))) < l_332)), l_353) && 0x7CBACDE2L));
    }
    /* facts after branching */
    assert (l_39 == 0 || l_39 == &l_226);
        return l_355;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_32(int64_t  p_33, union U0  p_34, int32_t * p_35, int64_t  p_36)
{ /* block id: 37 */
    uint64_t l_42 = 18446744073709551615UL;
    union U1 l_61 = {0x9C821F997EC53A21LL};
    int32_t *l_62 = &l_61.f1;
    float l_174 = (-0x4.Fp-1);
    float *l_173 = &l_174;
    int32_t **l_175 = &l_62;
    const uint16_t l_178 = 5UL;
    uint32_t l_183 = 2UL;
    union U0 l_184 = {0xC.AE52F1p-40};
    (*l_173) = ((-(float)p_34.f1) == (((p_36 == (p_35 == (void*)0)) < (l_42 == 0x0.7p-1)) <= (func_43(func_45(func_50(func_52(l_42, p_36, ((uint32_t)((-(int64_t)(l_42 <= 4294967288UL)) | 0xDDBB7A2E255BB5FBLL) % (uint32_t)l_42), l_61, l_62)), l_62, p_35, p_36)) <= p_36)));
    /* statement id: 83 */
        (*l_175) = p_35;
    /* statement id: 84 */
    //assert (l_62 == 0 || l_62 == &l_206);
    (*l_173) = ((((float)(((l_178 < p_36) >= 0x6.Cp-1) != p_36) + (float)(func_63((p_33 & (((uint16_t)((void*)0 == (*l_175)) << (uint16_t)((uint16_t)p_33 << (uint16_t)14)) == p_36)), l_183, l_184, p_34.f1) <= 0x0.5p+1)) == l_183) >= 0x6.BD15FEp+20);
    return p_35;
    /* statement id: 86 */
    //assert (func_32_rv == 0 || func_32_rv == &l_206);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_43(int32_t  p_44)
{ /* block id: 80 */
    int32_t l_172 = 0xE4044F88L;
    int32_t *l_171 = &l_172;
    l_171 = l_171;
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_45(int32_t * const  p_46, int32_t * p_47, int32_t * p_48, int16_t  p_49)
{ /* block id: 63 */
    uint8_t l_141 = 0UL;
    union U1 l_144 = {5UL};
    const int32_t *l_145 = (void*)0;
    int32_t *l_168 = &l_144.f1;
    int32_t **l_169 = (void*)0;
    int32_t **l_170 = &l_168;
    if (l_141)
    { /* block id: 64 */
        int32_t l_143 = 1L;
        int32_t * const l_142 = &l_143;
        const int32_t **l_146 = (void*)0;
        int32_t *l_148 = &l_143;
        int32_t **l_147 = &l_148;
        (*l_147) = l_145;
        /* statement id: 65 */
        assert (l_148 == 0);
    }
    else
    { /* block id: 66 */
        int16_t l_149 = 7L;
        int32_t *l_151 = &l_144.f1;
        int32_t **l_150 = &l_151;
        float l_154 = 0x9.099EBFp+54;
        l_144.f1 = l_149;
        /* statement id: 67 */
                (*l_150) = p_46;
        /* statement id: 68 */
        //assert (l_151 == 0 || l_151 == &l_226);
        (*p_47) = ((l_141 < (p_49 != p_49)) | ((*p_47) ^ ((uint16_t)p_49 + (uint16_t)((((int16_t)((uint16_t)(p_49 <= (p_48 != (void*)0)) >> (uint16_t)13) >> (int16_t)((uint32_t)(__builtin_parityll(p_49) != 0L) - (uint32_t)1L)) || p_49) < 4UL))));
    }
    /* facts after branching */
        for (p_49 = (-12); (p_49 < (-20)); p_49 -= 3)
    { /* block id: 73 */
        const int32_t *l_167 = &l_144.f1;
        (*l_168) = ((uint16_t)((int32_t)l_144.f1 - (int32_t)((((((p_47 != p_46) == (p_49 | (l_145 == (void*)0))) != 0x6E4AE6EC67F3A6B8LL) || 0L) > (*l_167)) < 0x82D9615D0954A6F3LL)) << (uint16_t)11);
        if ((*l_167))
            break;
    }
    (*p_47) = (*l_168);
    (*l_170) = p_47;
    /* statement id: 78 */
    //assert (l_168 == &l_61.f1 || l_168 == &l_226);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_50(const int32_t * p_51)
{ /* block id: 61 */
    int32_t l_134 = 1L;
    int32_t *l_133 = &l_134;
    int32_t *l_135 = &l_134;
    int32_t *l_136 = &l_134;
    int32_t *l_137 = &l_134;
    int32_t *l_138 = &l_134;
    int32_t *l_139 = &l_134;
    int32_t *l_140 = (void*)0;
    return l_140;
    /* statement id: 62 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_52(uint16_t  p_53, int32_t  p_54, uint32_t  p_55, union U1  p_56, int32_t * p_57)
{ /* block id: 38 */
    int32_t l_81 = 0xE2192FE2L;
    int32_t * const l_80 = &l_81;
    union U1 l_82 = {0UL};
    int32_t *l_99 = (void*)0;
    union U0 l_123 = {0x1.A9739Ap+59};
    const int32_t *l_132 = &l_81;
    const int32_t **l_131 = &l_132;
    (*p_57) = func_63(p_54, ((int16_t)func_70(func_75(l_80, (*p_57), l_82, &l_81), l_99, p_57, p_53) - (int16_t)l_82.f0), l_123, p_56.f1);
    /* statement id: 58 */
        (*l_131) = func_75(&l_81, func_70(p_57, &l_81, &l_81, (l_99 != p_57)), p_56, p_57);
    /* statement id: 59 */
    assert (l_132 == 0);
    return p_57;
    /* statement id: 60 */
    //assert (func_52_rv == &l_61.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_63(uint32_t  p_64, uint32_t  p_65, union U0  p_66, uint64_t  p_67)
{ /* block id: 54 */
    int32_t * const l_124 = (void*)0;
    uint32_t l_127 = 0xFA302576L;
    union U1 l_128 = {0UL};
    int32_t *l_129 = &l_128.f1;
    const int32_t *l_130 = &l_128.f1;
    l_130 = func_75(l_124, ((uint16_t)l_127 - (uint16_t)(p_66.f1 != l_127)), l_128, l_129);
    /* statement id: 55 */
        assert (l_130 == 0);
    l_130 = l_129;
    /* statement id: 56 */
    assert (l_130 == &l_128.f1);
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads : l_61.f1
 * writes: l_61.f1
 */
static int16_t  func_70(const int32_t * p_71, int32_t * p_72, int32_t * p_73, uint32_t  p_74)
{ /* block id: 44 */
    float l_100 = 0x1.0p-1;
    int32_t *l_103 = (void*)0;
    int32_t l_104 = 2L;
    union U1 l_105 = {0x76AF746A6ECCD282LL};
    int32_t **l_106 = &l_103;
    int16_t l_117 = 0x9BBDL;
    (*p_73) = (__builtin_parityll(p_74) ^ ((p_74 || ((uint16_t)(l_103 == p_71) % (uint16_t)(-2L))) < l_104));
    (*l_106) = func_75(p_73, l_104, l_105, &l_104);
    for (l_104 = 4; (l_104 <= (-15)); l_104 -= 6)
    { /* block id: 49 */
        const int32_t l_114 = (-1L);
        float *l_118 = (void*)0;
        float *l_119 = (void*)0;
        int32_t l_120 = 0L;
        int32_t *l_121 = (void*)0;
        int32_t *l_122 = &l_120;
        l_120 = (p_74 >= (((p_74 < 0x1.7B9DA0p-48) == 0x0.03A71Bp+1) == (((float)((float)(-(float)0x1.Bp-1) - (float)((((l_114 <= (p_74 < (((float)l_114 / (float)0x7.4C4DC4p+98) < (-0x5.8p+1)))) != p_74) <= l_117) <= l_114)) / (float)l_114) >= p_74)));
        (*l_122) = (*p_73);
    }
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_61.f1
 */
inline static const int32_t * func_75(int32_t * const  p_76, int32_t  p_77, union U1  p_78, int32_t * p_79)
{ /* block id: 39 */
    float l_85 = 0x4.8p+1;
    int32_t l_88 = 0x10F1939EL;
    const int32_t *l_87 = &l_88;
    const int32_t *l_89 = &l_88;
    const int32_t *l_90 = &l_88;
    const int32_t *l_91 = &l_88;
    const int32_t *l_92 = &l_88;
    const int32_t *l_93 = &l_88;
    const int32_t *l_94 = &l_88;
    const int32_t *l_95 = &l_88;
    const int32_t *l_96 = &l_88;
    const int32_t *l_97 = &l_88;
    const int32_t *l_98 = (void*)0;
    (*p_79) = func_83(l_85);
    return l_98;
    /* statement id: 43 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_83(float  p_84)
{ /* block id: 40 */
    int16_t l_86 = 0x1456L;
    return l_86;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 144
XXX total union variables: 11

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 19
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 105

XXX times a variable address is taken: 95
XXX times a pointer is dereferenced on RHS: 30
breakdown:
   depth: 1, occurrence: 22
   depth: 2, occurrence: 3
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 38
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 2
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 242

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 115
   level: 2, occurrence: 37
   level: 3, occurrence: 11
   level: 4, occurrence: 11
   level: 5, occurrence: 12
XXX number of pointers point to pointers: 33
XXX number of pointers point to scalars: 65
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 37.1
XXX average alias set size: 1.38

XXX times a non-volatile is read: 334
XXX times a non-volatile is write: 112
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 96
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 13
   depth: 2, occurrence: 7
   depth: 3, occurrence: 9
   depth: 4, occurrence: 19
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
********************* end of statistics **********************/

