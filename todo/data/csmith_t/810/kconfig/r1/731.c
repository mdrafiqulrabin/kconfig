/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1954355296
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 30;
};

union U1 {
   int16_t  f0;
   uint32_t  f1;
};

union U2 {
   int32_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_34(void);
inline static struct S0  func_38(int16_t  p_39);
static int32_t  func_43(int32_t  p_44, union U2  p_45, int32_t  p_46);
inline static union U2  func_47(int8_t  p_48, struct S0  p_49, uint32_t  p_50, int8_t  p_51, int32_t  p_52);
static uint32_t  func_53(int16_t  p_54);
inline static int16_t  func_76(union U2  p_77, int16_t  p_78, union U2  p_79, uint32_t  p_80);
static uint32_t  func_86(uint16_t  p_87);
static int16_t  func_89(int32_t  p_90, union U1  p_91, int32_t  p_92);
inline static union U1  func_109(struct S0  p_110, struct S0  p_111, union U1  p_112);
inline static struct S0  func_113(int8_t  p_114, int16_t  p_115, union U1  p_116);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(void)
{ /* block id: 36 */
    int32_t l_35 = 0x1355FFF8;
    union U1 l_59 = {0xDB20};
    uint16_t l_70 = 0xF88D;
    int32_t l_73 = 5;
    int32_t l_74 = 0xD23037D9;
    int32_t l_75 = 0x79538E5E;
    int32_t l_286 = 0x0234A52F;
    union U2 l_305 = {-1};
    for (l_35 = 3; (l_35 > 24); l_35 += 7)
    { /* block id: 39 */
        struct S0 l_41 = {-7215};
        int32_t l_42 = 1;
        int32_t l_71 = (-9);
        uint32_t l_312 = 0x17D8BD1D;
        union U2 l_313 = {0};
        int32_t l_314 = 0x8252909B;
        l_41 = func_38(l_35);
        l_42 |= l_41.f0;
        l_286 = func_43(l_35, func_47(l_35, l_41, l_35, (l_75 = (l_74 = (l_73 = (l_41.f0 < (func_53(((l_71 ^= ((l_42 = (65530U != ((((uint32_t)((int16_t)__builtin_ctzll((((l_59 , ((int16_t)((((int16_t)((uint16_t)((uint32_t)(((int16_t)0xA048 << (int16_t)8) ^ l_59.f0) - (uint32_t)l_70) % (uint16_t)8) - (int16_t)l_42) && l_59.f0) == l_41.f0) - (int16_t)1U)) <= l_70) == 0xFB11)) + (int16_t)l_42) + (uint32_t)l_41.f0) , 0x231D) | 6U))) ^ l_41.f0)) <= l_41.f0)) | l_70))))), l_70), l_41.f0);
        for (l_71 = 0; (l_71 != (-11)); l_71 -= 1)
        { /* block id: 190 */
            int32_t l_299 = 0xC4D6C543;
            int32_t l_300 = 0xE76519DB;
            int32_t l_310 = 0;
            int32_t l_311 = 0x815FF81F;
            l_314 |= func_43(((int32_t)l_71 % (int32_t)((uint32_t)((l_311 &= (l_41.f0 &= ((uint16_t)(((((int16_t)(l_300 = ((uint16_t)l_299 >> (uint16_t)l_286)) * (int16_t)((int32_t)((int16_t)(l_35 | (func_43((l_42 = (l_73 = l_71)), l_305, l_299) , (((uint16_t)((uint16_t)l_299 >> (uint16_t)l_73) << (uint16_t)10) , 0xAD1F110C))) >> (int16_t)12) - (int32_t)l_310)) != 0xB91C) == l_71) >= l_310) >> (uint16_t)l_70))) , l_42) + (uint32_t)l_312)), l_313, l_299);
            return l_75;
        }
    }
    return l_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_38(int16_t  p_39)
{ /* block id: 40 */
    struct S0 l_40 = {-20687};
    l_40 = l_40;
    return l_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_43(int32_t  p_44, union U2  p_45, int32_t  p_46)
{ /* block id: 136 */
    uint32_t l_226 = 4294967287U;
    int32_t l_229 = 0;
    int32_t l_244 = 0xF6CD2DBE;
    int32_t l_245 = (-7);
    union U1 l_250 = {-6};
    uint32_t l_255 = 4294967293U;
    struct S0 l_269 = {788};
    struct S0 l_285 = {-10192};
    p_46 = ((0xAE4B >= (-(uint16_t)(l_226 > ((int16_t)3 * (int16_t)l_226)))) != (((l_229 = l_226) & ((((l_245 = (((int32_t)((((int16_t)((int32_t)((l_244 = (((uint16_t)(((uint32_t)((int16_t)l_226 >> (int16_t)8) + (uint32_t)(((uint16_t)p_45.f0 * (uint16_t)(p_44 > p_44)) && p_45.f0)) || 0x7C59) << (uint16_t)p_45.f0) , 0xE250)) && 65535U) % (int32_t)0xE760C5D1) >> (int16_t)p_44) | 1U) == 1) + (int32_t)p_44) , p_46)) && p_44) && p_46) <= l_226)) == p_44));
    if ((((((-1) <= (-1)) != ((((uint16_t)(((uint16_t)func_89(l_229, l_250, ((-(uint32_t)4U) ^ p_46)) << (uint16_t)12) , __builtin_ctzll(((uint16_t)(l_244 < ((-8) >= (-1))) + (uint16_t)p_46))) >> (uint16_t)l_229) || l_244) > 0U)) , 0U) , 0x7C09D144))
    { /* block id: 141 */
        p_46 = 0xE9D99575;
        p_45.f0 = 0;
    }
    else
    { /* block id: 144 */
        struct S0 l_254 = {14848};
        int32_t l_282 = 1;
        int32_t l_283 = 0xAABCE9E3;
        union U1 l_284 = {6};
        if ((p_45.f0 = ((l_244 = p_45.f0) , 4)))
        { /* block id: 147 */
            l_254 = l_254;
        }
        else
        { /* block id: 149 */
            int32_t l_256 = 0xD18F8EAD;
            l_255 = (p_44 = p_45.f0);
            return l_256;
        }
        p_44 = (-1);
        for (l_244 = (-9); (l_244 == (-9)); l_244 += 1)
        { /* block id: 157 */
            uint32_t l_259 = 0xAAAEAED0;
            struct S0 l_268 = {10801};
            l_245 = (-1);
            if (p_44)
            { /* block id: 159 */
                p_46 = l_254.f0;
                l_229 &= p_44;
                if (p_44)
                    break;
                l_259 &= (l_245 |= (0x405F || p_44));
            }
            else
            { /* block id: 165 */
                int32_t l_264 = 0;
                int32_t l_265 = 1;
                p_45.f0 = ((uint32_t)4294967295U - (uint32_t)(l_265 = (~(~__builtin_clzll(__builtin_parity(l_264))))));
                l_254.f0 |= l_259;
                for (l_250.f1 = 8; (l_250.f1 <= 39); l_250.f1 += 1)
                { /* block id: 171 */
                    l_269 = (p_45 , l_268);
                    p_44 ^= (p_46 = (p_45.f1 ^= 0));
                }
            }
        }
        l_285 = func_113((((p_44 >= (((p_45.f0 = (l_283 ^= func_76(func_47((l_229 ^= ((l_244 &= p_44) >= ((uint16_t)((p_44 || ((int16_t)(((((uint16_t)((~(~(l_269 , l_245))) & p_46) << (uint16_t)__builtin_ffs(((int16_t)func_86((l_254.f0 = l_254.f0)) * (int16_t)(((int32_t)((p_46 || l_282) , p_45.f0) - (int32_t)(-1)) & 0x1776)))) == l_282) || p_46) , 0x81C3) >> (int16_t)13)) , l_254.f0) - (uint16_t)l_269.f0))), l_269, l_250.f0, l_282, l_282), l_282, p_45, l_282))) > 1) < 0xA9A4EBCB)) > 0x374C) , l_269.f0), p_44, l_284);
    }
    return l_226;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_47(int8_t  p_48, struct S0  p_49, uint32_t  p_50, int8_t  p_51, int32_t  p_52)
{ /* block id: 53 */
    union U2 l_81 = {-1};
    int32_t l_133 = 0x1E45A2DC;
    int32_t l_134 = 0x7469BA6C;
    int32_t l_135 = 0x5787DF3D;
    union U1 l_136 = {1};
    struct S0 l_140 = {17469};
    l_81.f1 = ((((func_76(l_81, ((int32_t)((uint16_t)func_53((__builtin_ffsl((((func_86(p_52) , func_109((p_49 = func_113(((uint16_t)l_81.f0 + (uint16_t)((uint16_t)(p_49.f0 , ((uint16_t)0x4A9C + (uint16_t)0xD72F)) >> (uint16_t)(l_135 = (((int16_t)(l_134 = ((uint16_t)((uint32_t)p_50 - (uint32_t)((uint32_t)((p_52 = (l_133 = (((uint32_t)((l_81 , l_81.f0) , 0x4C626C48) % (uint32_t)0xDB7DE593) && p_48))) , l_81.f1) % (uint32_t)l_81.f1)) << (uint16_t)10)) - (int16_t)p_50) , l_133)))), p_51, l_136)), l_140, l_136)) , 0x0F1C71BA) | l_136.f0)) && l_134)) * (uint16_t)1U) + (int32_t)l_81.f1), l_81, p_50) == 1) , 0x93C0) || l_135) != p_50);
    p_52 = (l_81.f1 , p_48);
    p_49 = l_140;
    return l_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(int16_t  p_54)
{ /* block id: 47 */
    struct S0 l_72 = {1240};
    l_72 = l_72;
    return l_72.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_76(union U2  p_77, int16_t  p_78, union U2  p_79, uint32_t  p_80)
{ /* block id: 84 */
    uint16_t l_161 = 7U;
    union U1 l_170 = {1};
    struct S0 l_171 = {-29029};
    union U1 l_172 = {1};
    int32_t l_173 = 2;
    if ((l_173 ^= (p_79.f1 |= ((((((func_109(func_113(l_161, ((l_161 != (((int16_t)((uint16_t)((((uint16_t)((int32_t)func_89(p_78, l_170, l_170.f0) - (int32_t)l_170.f0) << (uint16_t)l_170.f0) > p_77.f1) | l_161) >> (uint16_t)p_80) >> (int16_t)7) & 5U)) , p_80), l_170), l_171, l_172) , 0x60635580) , 0xBFB8) || l_172.f0) == 1) , 1) < 0x419DF025))))
    { /* block id: 87 */
        int32_t l_174 = 0;
        int32_t l_178 = 0;
        union U1 l_184 = {0x6E19};
        struct S0 l_187 = {-108};
        int32_t l_188 = 0;
        l_174 = (p_77.f1 < (p_77.f1 == p_80));
        for (l_172.f1 = (-5); (l_172.f1 >= 50); l_172.f1 += 5)
        { /* block id: 91 */
            int32_t l_177 = 2;
            struct S0 l_183 = {15644};
            l_177 ^= (p_79.f1 = p_77.f1);
            l_178 = (p_79.f1 = 0x8B036ACE);
            l_188 ^= func_89(l_178, func_109((l_171 = (((int16_t)((l_172 , func_89((l_173 = (0x43CF && ((uint16_t)0xF2D6 * (uint16_t)((l_183 = l_183) , (l_183.f0 = l_183.f0))))), (l_170 = l_184), ((uint16_t)(p_79.f0 >= p_79.f1) << (uint16_t)3))) <= l_177) * (int16_t)0x6FC5) , l_171)), l_187, l_184), p_77.f0);
        }
    }
    else
    { /* block id: 103 */
        int8_t l_197 = 0x4D;
        int32_t l_218 = 0x71E43657;
        int16_t l_219 = 0;
        for (l_172.f0 = 0; (l_172.f0 == (-10)); l_172.f0 -= 1)
        { /* block id: 106 */
            int16_t l_212 = 0;
            union U1 l_213 = {-4};
            int32_t l_220 = (-9);
            if (((uint16_t)(l_171.f0 = p_80) << (uint16_t)15))
            { /* block id: 108 */
                uint32_t l_200 = 0xE2E2A71E;
                union U1 l_221 = {0x13C7};
                int32_t l_222 = (-1);
                union U1 l_223 = {0x487F};
                if ((l_218 = __builtin_bswap32((((l_222 |= ((uint16_t)(0x3BFF2BCA < ((l_197 = l_161) && (((int16_t)func_89(l_200, ((((uint16_t)(l_220 = func_89(p_77.f1, (((p_78 = (!((int32_t)((int16_t)(((int32_t)(p_79.f1 = ((((int16_t)(0 >= (func_89(l_212, l_213, (((l_170.f0 && func_53(((((uint16_t)((int32_t)__builtin_ctzll((l_173 &= (l_172.f0 > l_212))) - (int32_t)l_161) << (uint16_t)9) >= l_213.f0) < p_77.f1))) == p_79.f1) , 7)) > 8U)) >> (int16_t)l_218) == p_77.f0) <= l_200)) - (int32_t)l_170.f0) < 4294967295U) + (int16_t)l_219) + (int32_t)p_77.f0))) < p_77.f1) , l_172), p_80)) >> (uint16_t)p_80) <= l_172.f0) , l_221), l_213.f0) % (int16_t)0xC18A) != 0))) + (uint16_t)0U)) == l_221.f0) | 0x5F2A))))
                { /* block id: 116 */
                    l_171 = func_113(p_80, p_78, l_223);
                    return p_79.f0;
                }
                else
                { /* block id: 119 */
                    int8_t l_224 = 0;
                    return l_224;
                }
            }
            else
            { /* block id: 122 */
                return l_173;
            }
        }
        l_171 = l_171;
        return p_80;
    }
    p_79.f1 ^= l_172.f0;
    p_77.f0 = p_79.f1;
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_86(uint16_t  p_87)
{ /* block id: 54 */
    int16_t l_88 = 0x6F63;
    int32_t l_97 = (-3);
    int32_t l_98 = 0xA36B4E13;
    int32_t l_101 = 7;
    union U1 l_102 = {0};
    int32_t l_108 = 0x9F947EB5;
    l_108 = ((l_88 = func_53(p_87)) && func_89(((uint16_t)((((l_101 = ((((int16_t)(l_98 = (l_97 |= ((1 | 0U) < (-3)))) + (int16_t)(((int32_t)p_87 - (int32_t)l_88) & (l_88 != l_88))) >= l_88) ^ p_87)) && l_88) <= l_88) , l_101) - (uint16_t)p_87), l_102, l_88));
    return l_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_89(int32_t  p_90, union U1  p_91, int32_t  p_92)
{ /* block id: 59 */
    int32_t l_106 = 0x45D263D1;
    int32_t l_107 = (-3);
    l_107 &= (p_91.f0 == (p_90 >= ((uint32_t)(p_92 , (8U & 0x65C9)) + (uint32_t)func_53((l_106 = (!p_91.f0))))));
    return p_90;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_109(struct S0  p_110, struct S0  p_111, union U1  p_112)
{ /* block id: 75 */
    int32_t l_147 = (-9);
    union U2 l_150 = {0xBAC90574};
    int32_t l_152 = 0;
    l_152 ^= (1 != ((uint16_t)func_86(p_110.f0) >> (uint16_t)(func_53((((int16_t)(((uint16_t)(p_112.f0 & (l_147 >= (((uint32_t)(l_150 , (((-(int16_t)p_111.f0) <= 0x4CA122FC) || (0x4CB0 | 0))) + (uint32_t)(-1)) <= p_112.f0))) - (uint16_t)l_147) < 1U) % (int16_t)0x1005) != 65528U)) ^ 0x85BF1637)));
    l_152 = (p_111.f0 = p_110.f0);
    l_147 ^= (((-4) & (p_112.f1 = (((uint32_t)((int32_t)(-(uint32_t)(p_112.f0 >= 0x14D0)) - (int32_t)p_110.f0) + (uint32_t)(((int32_t)((!((l_150.f0 = (l_152 = (-1))) <= 0x1477)) , l_150.f1) + (int32_t)p_110.f0) , ((p_111.f0 | l_152) , l_150.f1))) == 0xD7867E7C))) >= p_111.f0);
    return p_112;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_113(int8_t  p_114, int16_t  p_115, union U1  p_116)
{ /* block id: 69 */
    int8_t l_137 = 0xFD;
    struct S0 l_138 = {-13210};
    struct S0 l_139 = {-23828};
    l_137 = p_114;
    l_139 = (l_138 = func_38(l_137));
    return l_138;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 80
   depth: 1, occurrence: 13
XXX total union variables: 15

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX full-bitfields structs in the program: 13
breakdown:
   indirect level: 0, occurrence: 13
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 14
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 6
XXX times a single bitfield on RHS: 22

XXX max expression depth: 49
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 13
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 36, occurrence: 1
   depth: 41, occurrence: 1
   depth: 43, occurrence: 1
   depth: 49, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 264
XXX times a non-volatile is write: 102
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 68
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 15
   depth: 2, occurrence: 11
   depth: 3, occurrence: 9
   depth: 4, occurrence: 5

XXX percentage a fresh-made variable is used: 25.6
XXX percentage an existing variable is used: 74.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

