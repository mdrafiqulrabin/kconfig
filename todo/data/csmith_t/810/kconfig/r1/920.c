/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2321134452
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
   int64_t  f1;
   uint64_t  f2;
   int32_t  f3;
   const uint64_t  f4;
   uint8_t  f5;
   int32_t  f6;
   const int64_t  f7;
   const int64_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_32(void);
static int32_t * func_36(struct S0  p_37, int32_t * p_38, int32_t * p_39);
static struct S0  func_40(int64_t  p_41);
inline static int64_t  func_44(float  p_45, int32_t * p_46, int32_t * p_47, int64_t  p_48, uint8_t  p_49);
inline static int32_t * func_51(int16_t  p_52, int32_t  p_53, int16_t  p_54);
inline static int32_t * func_65(int32_t  p_66, uint64_t  p_67, int32_t  p_68, const int64_t  p_69);
static int64_t  func_74(int32_t * const  p_75, int32_t  p_76);
inline static int32_t * func_77(int16_t  p_78, int64_t  p_79, int32_t * p_80, int32_t  p_81);
inline static int32_t * func_92(int64_t  p_93);
inline static int64_t  func_94(int32_t * p_95, int32_t  p_96, int32_t  p_97, int32_t * p_98, int32_t * p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_32(void)
{ /* block id: 36 */
    int32_t l_33 = 0x7FA3DFADL;
    int32_t *l_407 = &l_33;
    uint8_t l_408 = 1UL;
    int32_t l_681 = 0xC4585EE8L;
    uint32_t l_683 = 6UL;
    for (l_33 = (-23); (l_33 >= (-4)); l_33 += 1)
    { /* block id: 39 */
        int64_t l_50 = (-8L);
        const uint8_t l_59 = 1UL;
        int32_t *l_60 = &l_33;
        int32_t **l_679 = (void*)0;
        int32_t **l_680 = &l_60;
        uint32_t l_682 = 4294967295UL;
        (*l_680) = func_36(func_40(((uint64_t)l_33 % (uint64_t)func_44(l_50, func_51((__builtin_popcountl(l_50) | ((int64_t)((int64_t)l_59 - (int64_t)((&l_33 == l_60) > l_33)) + (int64_t)0x9BEBB6F2BA10F40BLL)), (*l_60), (*l_60)), l_407, l_408, (*l_407)))), l_60, l_60);
        l_681 = (*l_60);
        return l_682;
    }
    return l_683;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(struct S0  p_37, int32_t * p_38, int32_t * p_39)
{ /* block id: 366 */
    float ***l_675 = (void*)0;
    float l_678 = (-0x1.Cp+1);
    float *l_677 = &l_678;
    float **l_676 = &l_677;
    l_676 = (void*)0;
    /* statement id: 367 */
    assert (l_676 == 0);
    return p_39;
    /* statement id: 368 */
    //assert (func_36_rv == &l_33);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_40(int64_t  p_41)
{ /* block id: 354 */
    uint8_t l_664 = 255UL;
    int32_t l_665 = 0x27BE1C43L;
    int32_t *l_673 = (void*)0;
    int32_t **l_672 = &l_673;
    struct S0 l_674 = {0L,0xCC3E8ECB23F14195LL,0x62C8EAE4526F6467LL,0x07FD5DA2L,0x966393ADAFA2DF2FLL,0xC1L,0x37562A68L,-3L,0xD2659EDAC41D2F0ALL};
lbl_668:
    l_665 = l_664;
    for (l_664 = 29; (l_664 < 7); l_664--)
    { /* block id: 358 */
        int32_t *l_669 = &l_665;
        int32_t **l_670 = (void*)0;
        int32_t **l_671 = &l_669;
        if (l_664)
            goto lbl_668;
        l_669 = &l_665;
        (*l_669) = (*l_669);
        (*l_671) = &l_665;
    }
    (*l_672) = &l_665;
    /* statement id: 364 */
    assert (l_673 == &l_665);
    return l_674;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_44(float  p_45, int32_t * p_46, int32_t * p_47, int64_t  p_48, uint8_t  p_49)
{ /* block id: 236 */
    int16_t l_420 = (-5L);
    float l_445 = 0x5.1p-1;
    float *l_444 = &l_445;
    int32_t l_451 = (-1L);
    float l_474 = 0x1.06F3F8p+80;
    float *** const *l_475 = (void*)0;
    uint32_t l_497 = 4294967290UL;
    int32_t *l_498 = &l_451;
    struct S0 **l_502 = (void*)0;
    struct S0 ***l_501 = &l_502;
    float l_521 = 0x1.Cp-1;
    int32_t l_575 = 0x00BDC78AL;
    const uint64_t l_623 = 1UL;
    int32_t **l_628 = (void*)0;
    int32_t ***l_627 = &l_628;
    int32_t ****l_626 = &l_627;
    int32_t *****l_625 = &l_626;
    int32_t l_646 = 0xE38690E2L;
lbl_655:
    for (p_49 = 20; (p_49 < 20); p_49++)
    { /* block id: 239 */
        struct S0 ***l_426 = (void*)0;
        int32_t l_442 = 0xA6C9B00FL;
        float * const ****l_449 = (void*)0;
        int32_t *l_454 = &l_451;
        int32_t **l_453 = &l_454;
        int32_t l_457 = 0xB18FB161L;
        int32_t *l_472 = &l_451;
        const uint8_t l_473 = 0xEBL;
        int32_t *****l_482 = (void*)0;
        const uint8_t l_491 = 1UL;
        const int32_t *l_495 = &l_442;
        const int32_t *l_496 = &l_451;
        for (p_48 = (-14); (p_48 == 23); p_48 += 8)
        { /* block id: 242 */
            int32_t l_424 = (-1L);
            int32_t *l_423 = &l_424;
            uint8_t l_425 = 0x54L;
            struct S0 l_431 = {0L,-1L,0UL,0L,0UL,255UL,5L,0x9F1200FA1EC1111FLL,0x79E0AD510BEB1297LL};
            struct S0 *l_430 = &l_431;
            struct S0 ** const l_429 = &l_430;
            struct S0 ** const *l_428 = &l_429;
            struct S0 ** const **l_427 = &l_428;
            (*l_423) = func_74(p_46, ((p_48 >= 0xA45528EACBFA641BLL) ^ (4UL == ((uint16_t)((uint16_t)p_49 << (uint16_t)10) + (uint16_t)(p_49 == ((int16_t)(((+(0x97F3908799C12719LL < l_420)) & ((uint16_t)p_49 >> (uint16_t)4)) || 0x3063F14597D608EFLL) / (int16_t)p_48))))));
            if (l_425)
                break;
            (*l_427) = l_426;
            /* statement id: 245 */
            assert (l_428 == 0);
            for (l_431.f2 = 0; (l_431.f2 < 26); l_431.f2 += 1)
            { /* block id: 248 */
                const float l_440 = 0x0.95985Fp-41;
                int32_t l_441 = 0x203FE1B8L;
                int32_t **l_452 = (void*)0;
                for (l_424 = 0; (l_424 >= (-14)); l_424 -= 9)
                { /* block id: 251 */
                    const float *l_443 = (void*)0;
                    int32_t *l_450 = (void*)0;
                    l_451 = (((((uint32_t)(((int16_t)p_48 << (int16_t)l_441) >= 0xFF65F103L) + (uint32_t)l_442) < ((l_443 != l_444) == ((int32_t)(-(int64_t)(((void*)0 == l_449) < (p_49 >= p_48))) - (int32_t)(*p_47)))) <= p_49) > p_49);
                }
                (*l_423) = 0L;
                (*l_423) = l_441;
                p_46 = p_47;
                /* statement id: 256 */
                //assert (p_46 == &l_33);
            }
        }
        (*l_453) = &l_451;
        if ((*l_454))
        { /* block id: 260 */
            int32_t *l_455 = (void*)0;
            int32_t *l_456 = &l_442;
            (*l_453) = (void*)0;
            /* statement id: 261 */
            assert (l_454 == 0);
            (*l_456) = (*p_47);
        }
        else
        { /* block id: 263 */
            (**l_453) = l_457;
            p_45 = p_49;
        }
        /* facts after branching */
        assert (l_454 == &l_451 || l_454 == 0);
        if (((int32_t)1L / (int32_t)l_451))
        { /* block id: 267 */
            float l_468 = 0x2.9p-1;
            int32_t l_471 = 1L;
            uint32_t l_483 = 18446744073709551612UL;
            uint16_t l_484 = 1UL;
            if (l_420)
            { /* block id: 268 */
                return l_451;
            }
            else
            { /* block id: 270 */
                float **l_479 = &l_444;
                float ***l_478 = &l_479;
                float ****l_477 = &l_478;
                float *****l_476 = &l_477;
                (*l_476) = l_475;
                /* statement id: 271 */
                assert (l_477 == 0);
                (*l_453) = func_65(((int16_t)__builtin_popcount((0UL | (((void*)0 == l_482) & l_483))) << (int16_t)15), ((l_484 <= ((uint16_t)(((-1L) >= 0xE05E394CL) != ((int32_t)((int64_t)l_420 + (int64_t)0x3F37361870DE6C0FLL) % (int32_t)l_491)) >> (uint16_t)10)) == p_49), p_49, p_48);
                /* statement id: 272 */
                assert (l_454 == 0);
                (*l_453) = (*l_453);
                return l_420;
            }
        }
        else
        { /* block id: 276 */
            uint32_t l_494 = 0x9639F522L;
            (*l_444) = (0xA.3E0AA7p+92 != (((((((float)p_45 + (float)(p_49 != ((-0x1.6p-1) <= (-0x8.Dp-1)))) >= (p_48 >= l_494)) != 0x3.BBC1B4p+61) < l_420) > p_45) <= p_49));
            l_496 = l_495;
            /* statement id: 278 */
            assert (l_496 == &l_442);
        }
        /* facts after branching */
        assert (l_496 == &l_442);
    }
lbl_534:
    l_498 = func_92(l_497);
    /* statement id: 281 */
    assert (l_498 == 0);
    for (l_497 = 0; (l_497 >= 40); l_497 += 6)
    { /* block id: 284 */
        uint16_t l_508 = 0x6975L;
        int32_t *l_520 = &l_451;
        float **l_526 = &l_444;
        float ***l_525 = &l_526;
        float ****l_524 = &l_525;
        float *****l_523 = &l_524;
        struct S0 l_574 = {0x738B05482821DB6BLL,0x2B6AAF12EEC62A99LL,0x4CE3A270CD71CD6CLL,-9L,5UL,248UL,-1L,0xC3A3E334D8D64D94LL,4L};
        const struct S0 *l_573 = &l_574;
        const struct S0 **l_572 = &l_573;
        int32_t l_576 = 0xF6B61732L;
        int16_t l_612 = 0L;
        if (func_74(p_47, __builtin_bswap64((l_501 == &l_502))))
        { /* block id: 285 */
            int64_t l_507 = 0xB32DE50FDF09AB01LL;
            int32_t * const l_515 = (void*)0;
            float ** const ***l_522 = (void*)0;
            int32_t l_538 = (-1L);
            int32_t l_561 = 1L;
            if (((((0xA288A3ADL & ((int16_t)p_48 << (int16_t)l_507)) & (p_48 > __builtin_ffs(l_508))) != (__builtin_ia32_crc32qi(p_49, ((int16_t)l_508 % (int16_t)((((uint16_t)(p_49 <= l_507) << (uint16_t)l_507) >= p_48) & p_49))) && (-6L))) != l_508))
            { /* block id: 286 */
                int16_t l_516 = 0x9174L;
                uint32_t l_517 = 18446744073709551608UL;
                int32_t l_519 = 0xDC00473BL;
                int32_t **l_527 = &l_498;
                for (l_507 = 0; (l_507 == 0); l_507++)
                { /* block id: 289 */
                    int32_t **l_518 = &l_498;
                    (*l_518) = func_77(p_49, __builtin_popcountl(func_74(l_515, l_516)), p_47, l_517);
                    /* statement id: 290 */
                    assert (l_498 == 0);
                    l_519 = p_48;
                    (*l_518) = (void*)0;
                    (*l_518) = func_77(l_517, p_48, l_520, (*p_47));
                }
                (*l_527) = func_51(p_49, p_48, (l_522 != l_523));
                /* statement id: 295 */
                assert (l_498 == 0);
                (*l_527) = p_46;
                /* statement id: 296 */
                //assert (l_498 == &l_33 || l_498 == 0);
                for (l_451 = 0; (l_451 <= 21); ++l_451)
                { /* block id: 299 */
                    struct S0 l_531 = {0x8BC2A5C8606CE886LL,0xCA14DCAE1B7B4221LL,1UL,0x894E57A8L,0x0F6A262D9FF99654LL,0UL,0x7283F89CL,0xE35A6D86730176DALL,-1L};
                    struct S0 *l_530 = &l_531;
                    l_530 = l_530;
                }
            }
            else
            { /* block id: 302 */
                float **l_537 = &l_444;
                int32_t l_550 = (-1L);
                for (l_507 = (-24); (l_507 < 8); l_507 += 4)
                { /* block id: 305 */
                    int32_t l_547 = 0xA6C3F0EDL;
                    int32_t **l_562 = &l_498;
                    if (p_48)
                        goto lbl_534;
                    for (p_49 = (-3); (p_49 != 42); p_49 += 5)
                    { /* block id: 309 */
                        const int32_t l_544 = 0xE41FB136L;
                        (*l_525) = l_537;
                        (*****l_523) = ((l_538 != ((float)((*l_520) <= __builtin_bswap64(((+(p_48 & ((uint16_t)l_544 >> (uint16_t)(*l_520)))) > ((uint16_t)(p_48 <= p_48) >> (uint16_t)l_550)))) / (float)0x5.37F50Ep-84)) <= p_45);
                    }
                    (*l_562) = func_65(((uint64_t)((int64_t)(((uint16_t)p_48 / (uint16_t)4L) || 0x4AEDL) + (int64_t)(((uint64_t)(0xFA77A25A86136CE8LL ^ (p_48 <= p_49)) - (uint64_t)l_550) < 0UL)) - (uint64_t)l_547), l_547, p_48, p_48);
                    /* statement id: 313 */
                    assert (l_498 == 0);
                }
            }
        }
        else
        { /* block id: 316 */
            struct S0 l_564 = {-1L,1L,0x4C8E7FF3C31E116ELL,0x489CD1DFL,0x6746A294085524D1LL,248UL,-1L,0x428787CF84BC5B8DLL,1L};
            struct S0 *l_563 = &l_564;
            struct S0 **l_565 = &l_563;
            (*l_565) = l_563;
            if ((*l_520))
                break;
            (*l_444) = p_49;
            (*****l_523) = __builtin_parity((p_49 < l_564.f0));
        }
        if ((((int64_t)p_49 + (int64_t)p_49) != ((((uint16_t)p_48 + (uint16_t)(*l_520)) != (*l_520)) || ((uint16_t)(func_74(l_520, (func_74(func_92(((0x9EDEL <= ((p_49 | ((((((void*)0 != l_572) <= 0xCCAEL) ^ p_48) <= 0xF4302A0EL) < 2UL)) || p_48)) < p_49)), l_575) ^ l_576)) & (*l_520)) >> (uint16_t)11))))
        { /* block id: 322 */
            struct S0 **l_584 = (void*)0;
            (***l_525) = ((((((float)(-(float)__builtin_ctzll(p_49)) - (float)((float)(((p_45 == ((*l_501) == (void*)0)) >= 0x1.1p-1) == ((float)p_49 / (float)p_49)) / (float)(l_584 != (*l_501)))) < 0xB.39A542p-64) > 0x7.139C74p-14) == 0xC.A0F39Fp+43) == (*l_520));
        }
        else
        { /* block id: 324 */
            int64_t l_589 = 0xAB098BFE0FB11AE6LL;
            int32_t *l_594 = (void*)0;
            uint16_t l_624 = 1UL;
            if ((((p_48 < ((((uint64_t)(+(+((((0x9B09FCEF07E1576DLL != p_48) != (*l_520)) > l_589) <= ((****l_523) != (**l_525))))) + (uint64_t)(((((int64_t)(((((*l_520) && l_497) & 0x75FAFA22766F41D7LL) > p_49) || p_48) - (int64_t)p_48) ^ (*l_520)) != 4294967294UL) != 0x1140L)) & (*l_520)) <= 0UL)) >= p_48) < p_48))
            { /* block id: 325 */
                uint16_t l_609 = 65535UL;
                const struct S0 ***l_611 = &l_572;
                uint32_t l_639 = 4294967295UL;
                int32_t *l_647 = &l_574.f6;
                for (l_451 = (-3); (l_451 > 18); l_451 += 8)
                { /* block id: 328 */
                    int32_t **l_595 = (void*)0;
                    int32_t **l_596 = &l_520;
                    float * const l_610 = &l_521;
                    (*l_596) = l_594;
                    /* statement id: 329 */
                    assert (l_520 == 0);
                    (*l_596) = l_520;
                    if (((int16_t)(((int64_t)0xC9B78254AECEE97ALL / (int64_t)((int64_t)((__builtin_popcountll((((int16_t)(((uint32_t)p_49 - (uint32_t)((int16_t)l_609 << (int16_t)6)) | l_609) - (int16_t)(l_610 != l_610)) < ((void*)0 != l_611))) && l_609) > 1L) - (int64_t)18446744073709551608UL)) != l_612) << (int16_t)l_420))
                    { /* block id: 331 */
                        int32_t l_615 = 0xA52A53C0L;
                        p_46 = func_65(((int16_t)((((p_49 ^ (*p_47)) == 0xFC09F2529F0A3708LL) <= p_48) & (*p_47)) << (int16_t)0), p_48, l_615, p_48);
                        /* statement id: 332 */
                        assert (p_46 == 0);
                    }
                    else
                    { /* block id: 333 */
                        int32_t *****l_629 = &l_626;
                        l_629 = l_625;
                    }
                }
                /* facts after for loop */
                assert (l_520 == 0 || l_520 == &l_451);
                if (l_589)
                    continue;
                l_647 = func_65(((uint16_t)((int64_t)((int16_t)((int16_t)(~l_639) / (int16_t)((((int16_t)((uint16_t)p_48 << (uint16_t)((uint32_t)0x3B8A658AL / (uint32_t)(*p_47))) << (int16_t)13) == 0x639CL) || ((l_646 >= (-2L)) > __builtin_ctz(p_48)))) % (int16_t)l_609) + (int64_t)p_49) / (uint16_t)0xC762L), p_49, p_48, l_574.f3);
                /* statement id: 338 */
                assert (l_647 == 0);
            }
            else
            { /* block id: 339 */
                const int32_t **l_654 = (void*)0;
                const int32_t ***l_653 = &l_654;
                const int32_t ****l_652 = &l_653;
                l_498 = func_65(p_48, p_49, ((int16_t)((p_49 && ((int16_t)(l_652 != &l_653) >> (int16_t)2)) ^ func_74(l_594, (*p_47))) + (int16_t)p_48), (*l_520));
                /* statement id: 340 */
                assert (l_498 == 0);
                if (l_576)
                    goto lbl_655;
            }
            /* facts after branching */
            assert (l_520 == 0 || l_520 == &l_451);
            (**l_526) = ((-0x8.0p+1) < 0x4.18D809p+12);
            return p_48;
        }
        (*l_520) = ((int16_t)0L % (int16_t)((1UL < (*l_520)) ^ 18446744073709551615UL));
    }
    /* facts after for loop */
    //assert (l_498 == &l_33 || l_498 == 0);
    for (l_575 = 0; (l_575 < 25); l_575 += 1)
    { /* block id: 350 */
        int32_t l_662 = 2L;
        int32_t l_663 = 0xB3D18497L;
        l_663 = ((uint16_t)l_662 >> (uint16_t)15);
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_51(int16_t  p_52, int32_t  p_53, int16_t  p_54)
{ /* block id: 40 */
    const int32_t l_61 = (-5L);
    int32_t l_62 = (-6L);
    int32_t *l_330 = &l_62;
    int32_t *l_332 = &l_62;
    int32_t *l_334 = (void*)0;
    const int32_t ***l_339 = (void*)0;
    uint64_t l_347 = 18446744073709551612UL;
    float ** const **l_361 = (void*)0;
    int32_t *l_367 = &l_62;
    int64_t l_379 = 0x6068BCC3F394957BLL;
    int32_t l_384 = (-7L);
    int32_t *l_387 = &l_62;
    int32_t *l_388 = &l_62;
    int32_t *l_391 = &l_62;
    int32_t *l_394 = &l_62;
    int32_t *l_395 = (void*)0;
    int32_t *l_396 = &l_62;
    int32_t *l_397 = &l_62;
    int32_t *l_398 = &l_62;
    int32_t *l_399 = &l_62;
    int32_t *l_400 = &l_62;
    int32_t *l_401 = &l_62;
    int32_t *l_402 = &l_62;
    int32_t *l_403 = &l_62;
    int32_t *l_404 = &l_62;
    int32_t *l_405 = &l_62;
    int32_t *l_406 = (void*)0;
    l_62 = (l_61 <= (&l_61 == (void*)0));
    for (l_62 = 0; (l_62 == 15); ++l_62)
    { /* block id: 44 */
        int32_t *l_82 = &l_62;
        int32_t **l_321 = &l_82;
        uint64_t l_324 = 0xDFF55233B5517A02LL;
        int32_t *l_326 = &l_62;
        int32_t *l_329 = &l_62;
        int32_t *l_333 = &l_62;
        int32_t l_346 = 0L;
        int32_t *l_345 = &l_346;
        (*l_321) = func_65(((uint64_t)((uint16_t)p_52 % (uint16_t)7UL) / (uint64_t)p_52), ((((func_74(func_77(p_53, l_61, l_82, p_54), ((int16_t)((0xC4C8L | p_52) > 1L) << (int16_t)l_62)) > 0x420FC968B5351F7DLL) & p_52) < (-1L)) ^ p_52), p_52, (*l_82));
        /* statement id: 192 */
        assert (l_82 == 0);
        if (p_53)
            continue;
        if (((int32_t)func_74((*l_321), ((((1UL | p_53) == p_52) >= l_324) & ((void*)0 != &l_61))) / (int32_t)p_53))
        { /* block id: 194 */
            int32_t *l_325 = &l_62;
            int32_t *l_327 = &l_62;
            int32_t *l_328 = &l_62;
            int32_t *l_331 = &l_62;
            return l_334;
            /* statement id: 195 */
            //assert (func_51_rv == 0);
        }
        else
        { /* block id: 196 */
            int64_t l_340 = 0x104CF704929BF389LL;
            int32_t *l_341 = &l_62;
            int32_t *l_342 = (void*)0;
            int32_t l_343 = 8L;
            int32_t *l_344 = &l_343;
            (*l_321) = (void*)0;
            (*l_344) = (p_53 < (__builtin_ffsl(p_52) || __builtin_clz(((uint64_t)((*l_326) == (*l_341)) + (uint64_t)(*l_332)))));
        }
        (*l_345) = (*l_329);
    }
    if (l_347)
    { /* block id: 202 */
        uint16_t l_354 = 0xEA62L;
        uint16_t l_360 = 0UL;
        int32_t *l_364 = &l_62;
        int32_t *l_368 = (void*)0;
        for (p_52 = 15; (p_52 > 27); p_52++)
        { /* block id: 205 */
            uint32_t l_355 = 0xCB03ED47L;
            int32_t *l_365 = (void*)0;
            (*l_332) = p_52;
            if (l_61)
                goto lbl_366;
            l_332 = func_65(p_54, (((uint16_t)((uint16_t)__builtin_ffsll((l_354 && l_355)) << (uint16_t)(((uint64_t)p_53 + (uint64_t)18446744073709551607UL) || ((0x6FC1L >= 0x2C3FL) || __builtin_ffsl(((int64_t)(l_354 >= 65535UL) - (int64_t)p_52))))) >> (uint16_t)l_355) >= l_360), p_53, l_360);
            /* statement id: 207 */
            assert (l_332 == 0);
            if (l_355)
                break;
            if (l_355)
            { /* block id: 209 */
                float ****l_363 = (void*)0;
                float *****l_362 = &l_363;
                (*l_362) = l_361;
                return l_365;
                /* statement id: 211 */
                //assert (func_51_rv == 0);
            }
            else
            { /* block id: 212 */
                return l_365;
                /* statement id: 213 */
                //assert (func_51_rv == 0);
            }
        }
        /* facts after for loop */
        assert (l_332 == 0 || l_332 == &l_62);
lbl_366:
        (*l_364) = __builtin_ctz((l_364 != l_364));
        return l_368;
        /* statement id: 218 */
        //assert (func_51_rv == 0);
    }
    else
    { /* block id: 219 */
        int32_t *l_371 = &l_62;
        float l_378 = (-0x8.1p+1);
        float *l_377 = &l_378;
        float **l_376 = &l_377;
        float ***l_375 = &l_376;
        float ****l_374 = &l_375;
        for (l_347 = 0; (l_347 > 10); l_347 += 3)
        { /* block id: 222 */
            l_371 = func_92((*l_367));
            /* statement id: 223 */
            assert (l_371 == 0);
            l_371 = func_65((*l_330), p_54, p_52, ((uint64_t)(p_54 & (l_361 != l_374)) + (uint64_t)(0x4A4BL > l_379)));
        }
        /* facts after for loop */
        assert (l_371 == 0 || l_371 == &l_62);
        (*l_367) = p_52;
        (*l_332) = ((float)((float)l_384 + (float)(0xE.07D278p-22 > (*l_330))) / (float)p_52);
        (*l_332) = (0x7924034DBA47CB31LL || p_53);
    }
    if (((((*l_367) ^ (*l_332)) <= 2L) && 0xA2A0B72BA6D88E89LL))
    { /* block id: 230 */
        (*l_367) = ((l_339 == l_339) == 4294967294UL);
    }
    else
    { /* block id: 232 */
        int32_t *l_385 = &l_62;
        int32_t *l_386 = &l_62;
        int32_t *l_389 = &l_62;
        int32_t *l_390 = &l_62;
        int32_t *l_392 = &l_62;
        int32_t *l_393 = &l_62;
        return l_395;
        /* statement id: 233 */
        //assert (func_51_rv == 0);
    }
    return l_406;
    /* statement id: 235 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(int32_t  p_66, uint64_t  p_67, int32_t  p_68, const int64_t  p_69)
{ /* block id: 188 */
    int32_t * const l_315 = (void*)0;
    const int32_t l_318 = 8L;
    const int32_t *l_317 = &l_318;
    const int32_t **l_316 = &l_317;
    int32_t *****l_319 = (void*)0;
    int32_t *l_320 = (void*)0;
    (*l_316) = func_92(func_74(l_315, p_69));
    /* statement id: 189 */
    assert (l_317 == 0);
    l_319 = l_319;
    return l_320;
    /* statement id: 191 */
    //assert (func_65_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_74(int32_t * const  p_75, int32_t  p_76)
{ /* block id: 162 */
    uint32_t l_281 = 4294967295UL;
    uint64_t l_284 = 1UL;
    const int32_t l_288 = 9L;
    const int32_t *l_287 = &l_288;
    int32_t l_305 = 0L;
    int32_t *l_304 = &l_305;
    struct S0 **l_313 = (void*)0;
    struct S0 ***l_312 = &l_313;
    if ((p_76 ^ (l_281 == ((int32_t)l_284 - (int32_t)(0x7A8C1E0FL >= (&p_76 != l_287))))))
    { /* block id: 163 */
        for (p_76 = 0; (p_76 != 20); ++p_76)
        { /* block id: 166 */
            int32_t l_291 = 9L;
            int32_t *l_292 = &l_291;
            (*l_292) = (p_76 > l_291);
        }
        for (l_284 = 0; (l_284 == 47); l_284 += 1)
        { /* block id: 171 */
            struct S0 **l_295 = (void*)0;
            struct S0 ***l_296 = &l_295;
            (*l_296) = l_295;
        }
    }
    else
    { /* block id: 174 */
        int32_t l_300 = (-9L);
        int32_t *l_299 = &l_300;
        float l_307 = 0x4.937118p+55;
        float *l_306 = &l_307;
        uint32_t l_314 = 18446744073709551612UL;
        for (p_76 = 0; (p_76 != (-5)); p_76--)
        { /* block id: 177 */
            l_299 = func_92(p_76);
            /* statement id: 178 */
            assert (l_299 == 0);
        }
        /* facts after for loop */
        assert (l_299 == 0 || l_299 == &l_300);
        (*l_306) = ((func_94(&p_76, ((uint64_t)((((1L <= (~(func_94(&p_76, p_76, (__builtin_ctzl((*l_287)) != (0x1494L && (*l_287))), &l_300, &l_300) & l_300))) & l_300) ^ (*l_287)) && 0x231903B4F77BA6C6LL) + (uint64_t)(*l_287)), (*l_287), l_304, &l_305) >= (*l_287)) <= l_300);
        if (((*l_304) | p_76))
        { /* block id: 181 */
            (*l_304) = (((*l_287) < 0x6E48L) | ((l_312 != (void*)0) & l_314));
        }
        else
        { /* block id: 183 */
            return p_76;
        }
    }
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_77(int16_t  p_78, int64_t  p_79, int32_t * p_80, int32_t  p_81)
{ /* block id: 45 */
    int32_t l_101 = 0x735F31A3L;
    int32_t *l_100 = &l_101;
    uint32_t l_106 = 1UL;
    float l_108 = (-0x1.Bp-1);
    const uint16_t l_113 = 65535UL;
    struct S0 *l_139 = (void*)0;
    int32_t l_153 = (-8L);
    float **l_214 = (void*)0;
    uint32_t l_264 = 0x5F7610E7L;
    struct S0 **l_271 = &l_139;
    float *l_273 = (void*)0;
    int32_t *l_274 = &l_101;
    int32_t *l_275 = &l_101;
    int32_t *l_276 = &l_153;
    int32_t *l_277 = &l_101;
    int32_t *l_278 = (void*)0;
    for (p_79 = 0; (p_79 == 4); p_79++)
    { /* block id: 48 */
        uint8_t l_107 = 0UL;
        int32_t l_135 = 1L;
        struct S0 **l_165 = (void*)0;
        int32_t *l_166 = (void*)0;
        int32_t **l_184 = &l_100;
        struct S0 **l_193 = &l_139;
        float *l_208 = &l_108;
        float **l_207 = &l_208;
        uint32_t l_258 = 1UL;
        int32_t l_261 = 0xB9AAB883L;
        for (p_81 = 10; (p_81 == (-11)); p_81 -= 5)
        { /* block id: 51 */
            float l_87 = 0xD.10B09Ep-10;
            int32_t l_89 = 0x5F814D19L;
            int32_t *l_88 = &l_89;
            (*l_88) = 0x2E963E9BL;
        }
    }
    (*l_100) = (*l_100);
    return l_278;
    /* statement id: 161 */
    //assert (func_77_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_92(int64_t  p_93)
{ /* block id: 66 */
    int32_t l_123 = 0xF7313610L;
    int32_t *l_122 = &l_123;
    int32_t ** const l_121 = &l_122;
    float *l_130 = (void*)0;
    int32_t *l_131 = &l_123;
    int32_t *l_132 = (void*)0;
    (**l_121) = ((l_121 == &l_122) <= (__builtin_ffs((**l_121)) == (**l_121)));
    (**l_121) = __builtin_parity(((uint32_t)((int64_t)(*l_122) - (int64_t)__builtin_bswap32((*l_122))) / (uint32_t)((int16_t)(*l_122) << (int16_t)14)));
    return l_132;
    /* statement id: 69 */
    //assert (func_92_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_94(int32_t * p_95, int32_t  p_96, int32_t  p_97, int32_t * p_98, int32_t * p_99)
{ /* block id: 56 */
    int32_t **l_114 = (void*)0;
    int32_t *l_116 = (void*)0;
    int32_t **l_115 = &l_116;
    (*l_115) = &p_97;
    /* statement id: 57 */
    assert (l_116 == &p_97);
    for (p_96 = 0; (p_96 == 26); p_96 += 2)
    { /* block id: 60 */
        (*p_95) = (-1L);
        if ((*p_98))
            continue;
    }
    (**l_115) = (*p_99);
    return p_96;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 211
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 31
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1

XXX total number of pointers: 200

XXX times a variable address is taken: 188
XXX times a pointer is dereferenced on RHS: 106
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 5
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 79
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 14
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 457

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 481
   level: 2, occurrence: 62
   level: 3, occurrence: 7
   level: 4, occurrence: 5
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 91
XXX number of pointers point to scalars: 102
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 37
XXX average alias set size: 1.17

XXX times a non-volatile is read: 718
XXX times a non-volatile is write: 239
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 143
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 36
   depth: 2, occurrence: 36
   depth: 3, occurrence: 22
   depth: 4, occurrence: 12
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 15
XXX percentage an existing variable is used: 85
********************* end of statistics **********************/

