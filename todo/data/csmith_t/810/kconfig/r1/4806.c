/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      782859264
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 14;
   unsigned f1 : 11;
   const uint32_t  f2;
   unsigned f3 : 9;
   signed f4 : 20;
   signed f5 : 27;
   const unsigned f6 : 13;
   unsigned f7 : 14;
   unsigned f8 : 26;
};

union U1 {
   uint32_t  f0;
   int32_t  f1;
   signed f2 : 10;
   int16_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const struct S0  func_31(void);
static int32_t * func_35(struct S0  p_36);
static struct S0  func_37(int32_t * p_38, int32_t * p_39, uint64_t  p_40, const struct S0  p_41);
static int32_t * func_42(int32_t * p_43);
static uint64_t  func_57(int64_t  p_58, int32_t  p_59, int16_t  p_60);
static int16_t  func_62(float  p_63);
inline static int32_t  func_86(float * p_87, int64_t  p_88, uint32_t  p_89);
static struct S0 * func_99(struct S0 * const *** const  p_100, uint8_t  p_101);
static struct S0 * const *** func_102(int32_t  p_103, struct S0 ** p_104, uint64_t  p_105, uint32_t  p_106, float ** p_107);
inline static struct S0 ** func_108(uint64_t  p_109, int16_t  p_110, int32_t  p_111, const struct S0  p_112, uint8_t  p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S0  func_31(void)
{ /* block id: 36 */
    int32_t *l_32 = (void*)0;
    int32_t l_34 = 0xAE07EA4CL;
    int32_t *l_33 = &l_34;
    int32_t l_48 = 0x435D7D23L;
    const struct S0 l_49 = {38,25,0xCA67B110L,2,-146,2340,55,117,5309};
    int32_t **l_339 = &l_33;
    int32_t *l_348 = (void*)0;
    (*l_33) = 0L;
    (*l_339) = func_35(func_37(func_42(&l_34), l_33, l_48, l_49));
    /* statement id: 186 */
    assert (l_33 == 0);
    for (l_34 = 0; (l_34 != 10); ++l_34)
    { /* block id: 189 */
        int16_t l_344 = 0x9938L;
        int32_t l_345 = (-2L);
        float l_347 = (-0x5.4p+1);
        float *l_346 = &l_347;
        l_345 = ((uint16_t)l_344 >> (uint16_t)7);
        if (l_344)
            break;
        (*l_346) = (&l_32 != &l_33);
        (*l_346) = l_344;
    }
    l_48 = (l_49.f2 == l_49.f7);
    return l_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_35(struct S0  p_36)
{ /* block id: 51 */
    int64_t l_61 = 0xC66C3C348FB8AAA8LL;
    struct S0 l_289 = {106,38,4294967295UL,20,477,5131,35,33,5239};
    struct S0 *l_288 = &l_289;
    float l_291 = 0x3.04E1ABp+22;
    float *l_290 = &l_291;
    float l_292 = (-0x1.3p+1);
    union U1 l_315 = {0x5E941047L};
    union U1 *l_314 = &l_315;
    union U1 **l_313 = &l_314;
    int32_t *l_332 = &l_315.f1;
    int32_t *l_333 = &l_315.f1;
    int32_t *l_334 = &l_315.f1;
    int32_t *l_335 = &l_315.f1;
    int32_t *l_336 = &l_315.f1;
    int32_t *l_337 = &l_315.f1;
    int32_t *l_338 = (void*)0;
    if (((func_57(l_61, l_61, func_62(p_36.f7)) && 1UL) != l_61))
    { /* block id: 171 */
        int16_t l_293 = 0x136CL;
        int32_t l_295 = (-7L);
        int32_t *l_294 = &l_295;
        int32_t **l_296 = &l_294;
        (*l_294) = ((int16_t)((int32_t)((&p_36 == l_288) < (func_86(l_290, l_293, (p_36.f0 & l_293)) < (1UL & (__builtin_ctz(l_293) <= l_293)))) % (int32_t)l_293) << (int16_t)p_36.f0);
        (*l_290) = (p_36.f1 <= p_36.f0);
        (*l_296) = func_42(l_290);
        /* statement id: 174 */
        assert (l_294 == &l_291);
    }
    else
    { /* block id: 175 */
        float l_311 = 0x5.9DA9D1p-10;
        int32_t l_312 = 0xB576518FL;
        const float l_316 = 0xD.05617Fp+34;
        int32_t *l_317 = &l_312;
        (*l_317) = (0xF694L == ((((func_57(l_289.f7, ((((int64_t)((((int64_t)6L - (int64_t)((uint16_t)((uint16_t)__builtin_ctzll(p_36.f3) >> (uint16_t)(__builtin_ffsl(p_36.f3) > (((int16_t)l_312 << (int16_t)(l_313 == (void*)0)) == l_61))) << (uint16_t)l_312)) | 0x354AL) > p_36.f7) + (int64_t)p_36.f1) | 18446744073709551610UL) != 0x96F4DC4DL), l_61) >= p_36.f3) || 0L) <= p_36.f5) < l_315.f0));
        for (l_315.f3 = 0; (l_315.f3 < 23); l_315.f3++)
        { /* block id: 179 */
            if (l_289.f6)
                break;
        }
        /* facts after for loop */
            }
    /* facts after branching */
        (*l_290) = p_36.f6;
    (*l_332) = ((uint64_t)l_315.f3 - (uint64_t)((((uint16_t)(&l_288 == &l_288) - (uint16_t)((18446744073709551615UL <= ((-2L) & l_289.f4)) || (((int64_t)__builtin_ctzll(p_36.f4) / (int64_t)((uint16_t)((((uint64_t)((int32_t)p_36.f4 % (int32_t)l_289.f4) % (uint64_t)0x1116317C229614BALL) && l_289.f6) | 7L) >> (uint16_t)8)) & 0x699FL))) == 0x0D68L) > p_36.f6));
    /* statement id: 184 */
        return l_338;
    /* statement id: 185 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_37(int32_t * p_38, int32_t * p_39, uint64_t  p_40, const struct S0  p_41)
{ /* block id: 42 */
    int32_t *l_51 = (void*)0;
    int32_t **l_50 = &l_51;
    struct S0 l_56 = {118,23,0UL,2,-362,-2795,8,90,5362};
    (*l_50) = (void*)0;
    if ((p_39 != p_39))
    { /* block id: 44 */
        (*p_39) = (+0xBDEC7E1EL);
        (*p_39) = 0xF9BDEFABL;
    }
    else
    { /* block id: 47 */
        float *l_53 = (void*)0;
        float l_55 = (-0x6.8p-1);
        float *l_54 = &l_55;
        (*l_54) = p_41.f2;
    }
    return l_56;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(int32_t * p_43)
{ /* block id: 38 */
    uint16_t l_44 = 0xEC8FL;
    (*p_43) = (l_44 >= 0x91450187E526954ELL);
    (*p_43) = ((l_44 || (((l_44 == 4UL) || ((uint16_t)__builtin_clzl(l_44) - (uint16_t)(-(uint32_t)l_44))) <= 2L)) == l_44);
    return p_43;
    /* statement id: 41 */
    //assert (func_42_rv == &l_34 || func_42_rv == &l_91 || func_42_rv == &l_92 || func_42_rv == &l_291);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_57(int64_t  p_58, int32_t  p_59, int16_t  p_60)
{ /* block id: 55 */
    int32_t l_92 = 2L;
    const struct S0 *l_192 = (void*)0;
    struct S0 l_207 = {77,16,0x17789D2CL,12,671,-2449,79,98,7884};
    struct S0 *l_206 = &l_207;
    struct S0 **l_205 = &l_206;
    float l_210 = (-0x9.Cp+1);
    float *l_209 = &l_210;
    float **l_208 = &l_209;
    int32_t *l_283 = &l_92;
    int32_t **l_282 = &l_283;
    for (p_60 = (-21); (p_60 <= (-11)); p_60++)
    { /* block id: 58 */
        float l_71 = 0x9.8p+1;
        float *l_70 = &l_71;
        float **l_69 = &l_70;
        float ***l_72 = &l_69;
        int32_t l_181 = (-6L);
        struct S0 ***l_224 = &l_205;
        int64_t l_242 = 0xF2DFD3FBD4D54A4CLL;
        uint64_t l_280 = 0x64655A230B5BDB62LL;
        (*l_72) = l_69;
        for (p_58 = 0; (p_58 != (-29)); p_58--)
        { /* block id: 62 */
            int32_t *l_83 = (void*)0;
            struct S0 *l_191 = (void*)0;
            struct S0 * const *** const l_223 = (void*)0;
            union U1 l_239 = {0x2D086A49L};
            union U1 *l_238 = &l_239;
            const int32_t *l_246 = &l_239.f1;
            const int32_t **l_245 = &l_246;
            for (p_59 = 0; (p_59 != 29); ++p_59)
            { /* block id: 65 */
                int16_t l_77 = (-10L);
                int32_t l_91 = 0x263D1F07L;
                int32_t *l_90 = &l_91;
                (*l_70) = func_62(l_77);
                for (l_77 = 0; (l_77 >= (-5)); l_77 -= 5)
                { /* block id: 69 */
                    struct S0 **l_80 = (void*)0;
                    struct S0 *l_82 = (void*)0;
                    struct S0 **l_81 = &l_82;
                    struct S0 ** const *l_85 = (void*)0;
                    struct S0 ** const **l_84 = &l_85;
                    (*l_81) = (void*)0;
                    l_83 = (void*)0;
                    (*l_84) = &l_81;
                    /* statement id: 72 */
                    assert (l_85 == &l_81);
                    if (l_77)
                        continue;
                }
                if (func_86(func_42(func_42(l_90)), p_59, l_92))
                { /* block id: 105 */
                    const struct S0 **l_199 = &l_192;
                    const struct S0 ***l_198 = &l_199;
                    for (l_92 = 22; (l_92 > 29); l_92 += 3)
                    { /* block id: 108 */
                        return l_181;
                    }
                    l_92 = (!((((p_58 || ((((int16_t)p_58 << (int16_t)15) >= func_62(((float)(-0x2.Bp+1) / (float)(*l_90)))) == (__builtin_ffsll((*l_90)) == (*l_90)))) | (0xB023839C7493250CLL | 0xB94B598FB1967CBALL)) & 2L) > 0x7E4F7073549B09EDLL));
                    for (l_77 = 0; (l_77 == (-10)); --l_77)
                    { /* block id: 114 */
                        int32_t *l_204 = (void*)0;
                        (**l_198) = func_99(func_102((((uint16_t)p_58 * (uint16_t)(l_191 != l_192)) == ((-(int32_t)((int16_t)((((int64_t)((p_60 > (((void*)0 == l_198) || (0xCFF2L < (((int16_t)(&l_91 == l_204) / (int16_t)p_59) < p_58)))) >= p_58) % (int64_t)p_59) & p_60) | l_92) >> (int16_t)p_59)) != 65530UL)), l_205, p_60, p_58, l_208), p_59);
                    }
                }
                else
                { /* block id: 117 */
                    int16_t l_217 = 0L;
                    union U1 l_219 = {0x11DD1DBFL};
                    union U1 *l_218 = &l_219;
                    int32_t *l_244 = &l_91;
                    if (func_62(((float)((float)((float)p_58 / (float)(l_217 != __builtin_parityl(l_217))) / (float)p_60) + (float)(-0x1.0p-1))))
                    { /* block id: 118 */
                        union U1 **l_220 = &l_218;
                        int32_t **l_221 = (void*)0;
                        int32_t **l_222 = &l_90;
                        (*l_220) = l_218;
                        (*l_222) = &l_91;
                        if (p_60)
                            break;
                        (*l_220) = (void*)0;
                        /* statement id: 122 */
                        assert (l_218 == 0);
                    }
                    else
                    { /* block id: 123 */
                        (*l_205) = func_99(l_223, ((void*)0 != l_224));
                        /* statement id: 124 */
                        assert (l_206 == 0);
                    }
                    /* facts after branching */
                    assert (l_218 == &l_219 || l_218 == 0);
                    if ((&l_69 != &l_69))
                    { /* block id: 126 */
                        float *l_229 = &l_71;
                        int32_t l_236 = 4L;
                        (*l_90) = p_60;
                        l_236 = ((float)(((float)(p_59 >= func_86(l_229, l_219.f3, ((func_62(((float)0x1.Ep+1 - (float)(((float)__builtin_popcountl(((((p_60 & (l_181 <= ((p_58 <= (p_60 < l_236)) == 0UL))) == p_58) <= l_236) == l_92)) / (float)0x0.445D63p-93) == 0x5.9D9957p-66))) < (*l_90)) && 0x7463E53FL))) + (float)p_59) >= 0x0.Dp-1) + (float)0x0.1p-1);
                        (*l_229) = ((p_59 != l_219.f3) == p_60);
                    }
                    else
                    { /* block id: 130 */
                        int32_t **l_237 = &l_90;
                        int32_t *l_243 = &l_92;
                        (*l_237) = &p_59;
                        /* statement id: 131 */
                        assert (l_90 == &p_59);
                        (*l_243) = ((((void*)0 != l_238) != p_59) & ((int64_t)l_242 / (int64_t)func_86((*l_208), (*l_90), ((func_62((**l_237)) >= p_58) ^ p_59))));
                    }
                    /* facts after branching */
                    assert (l_90 == &p_59 || l_90 == &l_91);
                    (*l_244) = __builtin_popcountll((((p_60 <= 0L) == l_207.f1) > l_207.f5));
                    if (p_59)
                        break;
                }
                /* facts after branching */
                assert (l_90 == &p_59 || l_90 == &l_91);
            }
            (*l_245) = func_42(&l_92);
            /* statement id: 138 */
            assert (l_246 == &l_92);
            for (l_239.f3 = 0; (l_239.f3 == (-21)); l_239.f3 -= 6)
            { /* block id: 141 */
                union U1 *l_249 = &l_239;
                union U1 **l_250 = &l_249;
                int32_t l_251 = 0L;
                int32_t *l_281 = &l_181;
                (*l_250) = l_249;
                if (l_251)
                { /* block id: 143 */
                    if (p_60)
                        break;
                    if (l_251)
                    { /* block id: 145 */
                        int32_t *l_252 = &l_181;
                        l_252 = &l_181;
                        (**l_208) = (((float)(**l_245) + (float)0x8.3CAB9Cp+11) <= func_62(p_60));
                    }
                    else
                    { /* block id: 148 */
                        uint64_t l_259 = 0xEC8C7DFA00B79E95LL;
                        int32_t *l_260 = &l_92;
                        (*l_260) = ((int64_t)((0xB985607DL <= 0xA3FD36FCL) != 4294967295UL) % (int64_t)(0x4661L ^ ((uint16_t)p_59 >> (uint16_t)(l_259 == (((__builtin_ffs((0x6EBF33B00657D72FLL < p_58)) && l_92) | l_242) >= 4294967295UL)))));
                        (*l_250) = (*l_250);
                    }
                }
                else
                { /* block id: 152 */
                    uint32_t l_261 = 0x42488E89L;
                    uint64_t l_275 = 0x17B01C23CCA6638CLL;
                    if (l_261)
                    { /* block id: 153 */
                        if (p_60)
                            break;
                        if (p_59)
                            continue;
                    }
                    else
                    { /* block id: 156 */
                        int32_t *l_273 = &l_251;
                        if (p_59)
                            break;
                        p_59 = ((int16_t)((uint16_t)((uint16_t)(*l_246) - (uint16_t)l_251) << (uint16_t)(+(((uint32_t)((uint32_t)((&p_59 != l_273) > 0x81DA6610234A52FFLL) - (uint32_t)(l_207.f0 <= (p_59 <= (p_58 <= l_181)))) - (uint32_t)0x67D72278L) != l_242))) >> (int16_t)0);
                        (**l_208) = (((+(-0x5.5p+1)) <= l_275) < (((func_86((**l_72), p_59, ((int32_t)((uint32_t)p_58 % (uint32_t)0xA06D27C6L) - (int32_t)l_280)) <= 0x6.5AD0F7p-48) != p_60) > 0x2.Cp-1));
                    }
                    l_207.f5 = l_207.f4;
                    (*l_245) = l_281;
                    /* statement id: 162 */
                    assert (l_246 == &l_181);
                    if (l_207.f1)
                        continue;
                }
            }
            /* facts after for loop */
                        assert (l_246 == &l_181 || l_246 == &l_92);
        }
        /* facts after for loop */
        assert (l_206 == 0 || l_206 == &l_207);
        return p_59;
    }
    (*l_282) = (void*)0;
    /* statement id: 169 */
    assert (l_283 == 0);
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_62(float  p_63)
{ /* block id: 52 */
    float l_65 = 0x6.F155D2p-14;
    float *l_64 = &l_65;
    int32_t l_66 = 6L;
    (*l_64) = 0xA.FDC3C1p-44;
    return l_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_86(float * p_87, int64_t  p_88, uint32_t  p_89)
{ /* block id: 75 */
    int32_t l_94 = (-1L);
    int32_t *l_93 = &l_94;
    struct S0 **l_116 = (void*)0;
    struct S0 ***l_115 = &l_116;
    struct S0 ****l_114 = &l_115;
    float l_123 = 0x1.9p-1;
    float *l_122 = &l_123;
    float ** const l_121 = &l_122;
    float ** const *l_120 = &l_121;
    int32_t l_178 = (-9L);
    (*l_93) = 0xE4559F94L;
    for (p_89 = (-7); (p_89 != 55); p_89++)
    { /* block id: 79 */
        struct S0 ****l_117 = &l_115;
        int32_t l_132 = 8L;
        int32_t **l_177 = &l_93;
        for (p_88 = 0; (p_88 != (-16)); p_88 -= 4)
        { /* block id: 82 */
            uint16_t l_124 = 2UL;
            const struct S0 l_125 = {32,40,0xC3DD168CL,10,87,-3722,62,81,4856};
            struct S0 l_176 = {69,20,0x299B2AD0L,10,631,11467,26,122,1992};
            struct S0 *l_175 = &l_176;
            struct S0 **l_174 = &l_175;
            (*l_93) = p_88;
            (*l_174) = func_99(func_102(func_62((*p_87)), func_108(((l_114 == l_117) <= (((((uint16_t)((l_120 != &l_121) != 0UL) >> (uint16_t)__builtin_bswap32(l_124)) != 0xA119L) != 0UL) || 0xCAFA2358462BD54ELL)), (*l_93), p_89, l_125, l_125.f6), l_132, p_89, &l_122), (*l_93));
            /* statement id: 100 */
            assert (l_175 == 0);
        }
        (*l_177) = &l_94;
    }
    return l_178;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_99(struct S0 * const *** const  p_100, uint8_t  p_101)
{ /* block id: 91 */
    int32_t l_160 = 0L;
    int32_t *l_159 = &l_160;
    int32_t **l_161 = &l_159;
    struct S0 l_164 = {50,34,0x6379E6B5L,21,-886,-1490,23,6,6865};
    struct S0 *l_163 = &l_164;
    struct S0 **l_162 = &l_163;
    float l_167 = 0xE.E9C12Cp+63;
    float *l_166 = &l_167;
    float **l_165 = &l_166;
    struct S0 *l_170 = &l_164;
    struct S0 *l_171 = &l_164;
    struct S0 *l_172 = &l_164;
    struct S0 *l_173 = (void*)0;
    (*l_161) = l_159;
    (*l_166) = (((void*)0 == l_162) > (l_165 == &l_166));
    for (p_101 = 0; (p_101 >= 40); ++p_101)
    { /* block id: 96 */
        (**l_165) = (*l_159);
    }
    return l_173;
    /* statement id: 99 */
    //assert (func_99_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * const *** func_102(int32_t  p_103, struct S0 ** p_104, uint64_t  p_105, uint32_t  p_106, float ** p_107)
{ /* block id: 87 */
    const struct S0 l_134 = {56,14,4294967295UL,1,87,10270,26,27,8141};
    const struct S0 *l_133 = &l_134;
    struct S0 l_137 = {36,16,0x4AA9F20BL,9,760,-564,11,115,3451};
    struct S0 *l_136 = &l_137;
    struct S0 **l_135 = &l_136;
    struct S0 *** const *l_139 = (void*)0;
    struct S0 *** const **l_138 = &l_139;
    struct S0 * const *l_142 = &l_136;
    struct S0 * const **l_141 = &l_142;
    struct S0 * const ***l_140 = &l_141;
    struct S0 * const ***l_143 = &l_141;
    struct S0 * const ***l_144 = &l_141;
    struct S0 * const ***l_145 = &l_141;
    struct S0 * const ***l_146 = &l_141;
    struct S0 * const ***l_147 = &l_141;
    struct S0 * const ***l_148 = &l_141;
    struct S0 * const ***l_149 = &l_141;
    struct S0 * const ***l_150 = &l_141;
    struct S0 * const ***l_151 = &l_141;
    struct S0 * const ***l_152 = &l_141;
    struct S0 * const ***l_153 = &l_141;
    struct S0 * const ***l_154 = &l_141;
    struct S0 * const ***l_155 = &l_141;
    struct S0 * const ***l_156 = &l_141;
    struct S0 * const ***l_157 = &l_141;
    struct S0 * const ***l_158 = (void*)0;
    (*l_135) = l_133;
    /* statement id: 88 */
    assert (l_136 == &l_134);
    l_138 = l_138;
    return l_158;
    /* statement id: 90 */
    //assert (func_102_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 ** func_108(uint64_t  p_109, int16_t  p_110, int32_t  p_111, const struct S0  p_112, uint8_t  p_113)
{ /* block id: 84 */
    uint8_t l_126 = 0xE9L;
    struct S0 l_129 = {14,26,0xCA7CC927L,1,272,8231,51,58,7697};
    struct S0 *l_128 = &l_129;
    struct S0 **l_127 = &l_128;
    struct S0 **l_130 = &l_128;
    struct S0 **l_131 = (void*)0;
    l_126 = p_112.f2;
    return l_131;
    /* statement id: 86 */
    //assert (func_108_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 96
   depth: 1, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 43
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 20
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 15
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 15
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 27

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 22
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 17, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1

XXX total number of pointers: 125

XXX times a variable address is taken: 113
XXX times a pointer is dereferenced on RHS: 15
breakdown:
   depth: 1, occurrence: 12
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 43
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 5
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 470

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 119
   level: 2, occurrence: 17
   level: 3, occurrence: 2
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 64
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 15
XXX percent of pointers has null in alias set: 24
XXX average alias set size: 1.17

XXX times a non-volatile is read: 281
XXX times a non-volatile is write: 120
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 99
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 18
   depth: 2, occurrence: 6
   depth: 3, occurrence: 5
   depth: 4, occurrence: 17
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 12.5
XXX percentage an existing variable is used: 87.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

