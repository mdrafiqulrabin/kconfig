/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      558170808
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 10;
   signed f1 : 23;
   unsigned f2 : 29;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0x60F57A7C;
static uint32_t g_37 = 1U;
static struct S0 g_102 = {10,6,21030};
static uint32_t g_147 = 0x2099EBF9;
static int32_t g_169 = 0xC60FB405;
static struct S0 g_170 = {26,575,17863};
static int16_t g_184 = 1;
static uint32_t g_269 = 0x2116EFC7;
static int16_t g_316 = 0x3478;
static int32_t g_325 = 3;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_26(void);
static struct S0  func_27(uint32_t  p_28, uint32_t  p_29);
static uint16_t  func_33(int32_t  p_34, uint32_t  p_35);
static int32_t  func_43(int32_t  p_44, uint32_t  p_45);
static int32_t  func_48(uint32_t  p_49, struct S0  p_50, int32_t  p_51);
static uint32_t  func_52(int16_t  p_53, uint32_t  p_54);
static int16_t  func_55(int32_t  p_56, int32_t  p_57, uint32_t  p_58, uint32_t  p_59, uint32_t  p_60);
static uint16_t  func_65(int32_t  p_66, uint32_t  p_67, uint32_t  p_68);
static uint16_t  func_74(uint16_t  p_75, int32_t  p_76);
static uint32_t  func_98(struct S0  p_99, int32_t  p_100, int16_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_37 g_102 g_147 g_169 g_170 g_184 g_269 g_316 g_325
 * writes: g_37 g_102.f1 g_147 g_102 g_170.f1 g_169 g_170 g_184 g_325
 */
static uint32_t  func_26(void)
{ /* block id: 36 */
    uint32_t l_30 = 0U;
    struct S0 l_247 = {6,401,22461};
    uint16_t l_301 = 0x0C8B;
    uint32_t l_315 = 0xEA6EA959;
    l_247 = func_27(l_30, (l_30 && (0xDC99CDF9 & (((l_30 || (1U <= (g_3 > g_3))) > func_33(g_3, g_3)) & 0U))));
    for (g_147 = 0; (g_147 != 57); g_147 += 1)
    { /* block id: 171 */
        uint32_t l_253 = 0x69D35C18;
        uint32_t l_260 = 0x1C94D667;
        struct S0 l_273 = {12,166,21443};
        if (g_102.f0)
        { /* block id: 172 */
            struct S0 l_250 = {1,430,19675};
            g_170 = l_250;
            g_102.f1 = ((int32_t)l_253 % (int32_t)(((uint16_t)(((((uint16_t)((uint16_t)(0 || (func_48(l_260, g_170, l_247.f2) ^ func_74(((g_184 > l_247.f1) >= ((int32_t)g_102.f0 - (int32_t)g_169)), g_170.f2))) - (uint16_t)0x061E) % (uint16_t)g_3) | l_250.f2) || g_147) == g_147) >> (uint16_t)l_250.f1) && l_253));
            for (l_260 = (-29); (l_260 < 22); l_260 += 1)
            { /* block id: 177 */
                l_250.f1 = 0xAAB92349;
                return l_250.f0;
            }
        }
        else
        { /* block id: 181 */
            int32_t l_272 = 0xC52C7789;
            struct S0 l_275 = {20,2382,17868};
            l_273 = func_27((__builtin_ffs(g_102.f1) < ((g_170.f2 == ((!(((int32_t)0x8FE40136 + (int32_t)(!g_269)) > (g_102.f1 <= __builtin_ffs(((uint32_t)(l_272 != ((l_272 || __builtin_ffsll(g_170.f2)) <= l_247.f0)) - (uint32_t)g_170.f0))))) > 0x575D)) || l_272)), l_253);
            g_170.f1 = (g_170.f0 && (~(0x89F9 == l_272)));
            l_275 = g_102;
        }
        l_273 = g_102;
    }
    g_102.f1 = ((4 != g_170.f2) | l_247.f1);
    for (l_30 = 0; (l_30 >= 42); l_30 += 1)
    { /* block id: 191 */
        uint16_t l_284 = 0xD671;
        struct S0 l_286 = {27,2310,21851};
        g_102.f1 = g_3;
        for (g_147 = 11; (g_147 > 59); g_147 += 1)
        { /* block id: 195 */
            int32_t l_302 = 9;
            int16_t l_333 = (-4);
            struct S0 l_346 = {29,-1415,3247};
            int16_t l_361 = (-4);
            if (((int16_t)((int32_t)g_170.f2 + (int32_t)((g_269 ^ g_170.f1) == l_284)) - (int16_t)g_184))
            { /* block id: 196 */
                struct S0 l_285 = {13,2404,8487};
                l_286 = l_285;
                g_102.f1 = ((uint16_t)(0x1E79 >= g_170.f2) << (uint16_t)(g_170.f2 > l_247.f2));
            }
            else
            { /* block id: 199 */
                uint16_t l_296 = 0x59D1;
                int32_t l_362 = 0x51254CA7;
                if ((-(int16_t)((uint16_t)(((uint16_t)g_170.f1 >> (uint16_t)(((((uint32_t)l_296 + (uint32_t)((uint16_t)0x1D4B % (uint16_t)((int16_t)(((0x975CEA95 > (g_147 ^ 0x98EF82A8)) == g_102.f0) < func_65((((l_30 < (g_170.f1 ^ g_102.f1)) <= g_3) ^ 1U), g_3, g_3)) << (int16_t)g_147))) > 4294967294U) > l_301) ^ l_296)) | g_102.f2) >> (uint16_t)5)))
                { /* block id: 200 */
                    uint16_t l_349 = 65528U;
                    struct S0 l_352 = {11,-887,16188};
                    if ((((l_302 | (__builtin_ffsll(g_37) != ((uint16_t)(g_170.f0 >= g_269) << (uint16_t)((((int16_t)l_247.f0 - (int16_t)((~func_48(l_286.f1, g_102, g_102.f1)) == g_102.f1)) > l_296) == g_102.f2)))) == g_102.f0) ^ g_102.f1))
                    { /* block id: 201 */
                        struct S0 l_308 = {14,2607,14938};
                        l_308 = g_170;
                        g_170.f1 = ((int32_t)0xF79DBF3E % (int32_t)func_74(((((g_170.f2 > __builtin_popcount(g_170.f2)) & func_55(((((int32_t)((((((uint16_t)__builtin_parity((0x519D > ((__builtin_parity((l_308.f0 == g_170.f1)) | (g_147 & g_269)) >= l_296))) >> (uint16_t)g_102.f1) | g_147) <= g_3) & l_301) || 0x1FCB9207) % (int32_t)0xD4A889A8) && l_315) & g_102.f2), g_169, g_316, g_170.f1, g_184)) == g_170.f1) ^ g_269), l_30));
                    }
                    else
                    { /* block id: 204 */
                        int32_t l_350 = (-1);
                        int32_t l_351 = 0x68F69760;
                        g_170.f1 = (~(__builtin_ia32_crc32qi((g_102.f0 >= (~l_296)), (0x730E20BC && ((int16_t)(((int16_t)(g_316 == ((65526U < (((int16_t)(g_325 ^ (((uint32_t)(0x42444259 != g_269) % (uint32_t)(0x5C52C26C && g_169)) > 4U)) << (int16_t)g_170.f0) ^ 4294967288U)) & l_301)) >> (int16_t)g_102.f0) ^ (-1)) << (int16_t)g_102.f2))) >= l_302));
                        g_325 = ((uint16_t)l_247.f0 - (uint16_t)((4294967292U ^ (((uint16_t)(-(int16_t)(((g_3 >= (l_333 < ((uint16_t)(~func_55((((uint16_t)__builtin_parityl((~g_316)) << (uint16_t)((int16_t)((int32_t)(((((int16_t)__builtin_popcountll(func_98(l_346, g_102.f1, ((int16_t)g_170.f2 >> (int16_t)l_315))) - (int16_t)g_147) >= 0xE9BE) && (-1)) >= g_269) - (int32_t)g_316) - (int16_t)g_37)) != g_316), l_349, l_350, g_316, l_349)) - (uint16_t)l_351))) > l_349) >= l_346.f1)) + (uint16_t)65528U) <= g_170.f1)) <= l_296));
                    }
                    if (func_65((((func_48(g_184, l_352, ((int16_t)(-1) * (int16_t)(((uint32_t)((uint16_t)g_316 << (uint16_t)10) - (uint32_t)((((uint16_t)0x8A22 + (uint16_t)(((g_3 || 0xBAA07DB0) == ((((((l_346.f2 ^ 0x93242E56) && 1) >= g_316) | 1) < 7) > l_361)) == g_269)) && l_361) > l_315)) >= 0x555A09A9))) || (-6)) || 1) || g_102.f2), g_170.f1, l_362))
                    { /* block id: 208 */
                        int32_t l_363 = 0x95A60534;
                        if (l_247.f1)
                            break;
                        l_363 = l_352.f1;
                        g_325 = g_102.f2;
                    }
                    else
                    { /* block id: 212 */
                        uint32_t l_368 = 4294967295U;
                        g_325 = (((__builtin_ffsll(((((int16_t)((((int16_t)(g_102.f1 >= ((((l_368 <= ((g_102.f1 | ((uint32_t)((((65535U || 0x5F3E) < g_170.f0) == l_362) || (((int32_t)l_346.f0 - (int32_t)0x3B3B1A93) ^ g_170.f0)) % (uint32_t)g_102.f1)) | g_169)) <= l_346.f0) ^ 0xB7DE) > g_102.f1)) >> (int16_t)2) < 0xE30A) & 0xF228) % (int16_t)l_296) ^ 0x404E) != g_170.f1)) <= g_169) && g_102.f2) | g_102.f2);
                    }
                }
                else
                { /* block id: 215 */
                    g_102.f1 = g_269;
                }
                g_102 = g_102;
            }
            g_170.f1 = 0xFA15BBDB;
        }
    }
    return l_247.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_184 g_170.f0 g_170 g_102.f2 g_102.f1 g_169 g_3 g_147 g_102
 * writes: g_184 g_169 g_102.f1 g_170.f1 g_170
 */
static struct S0  func_27(uint32_t  p_28, uint32_t  p_29)
{ /* block id: 125 */
    struct S0 l_213 = {23,1994,3011};
    l_213 = l_213;
    for (g_184 = 0; (g_184 > (-9)); g_184 -= 2)
    { /* block id: 129 */
        int16_t l_225 = 0xE38C;
        int32_t l_226 = 4;
        struct S0 l_227 = {16,659,17619};
        l_213.f1 = ((((func_74(l_213.f1, (5U > p_29)) != 1U) >= ((int16_t)(p_28 ^ ((g_170.f0 <= ((((int16_t)p_29 << (int16_t)12) || (((uint16_t)(!((int32_t)(p_28 >= l_225) % (int32_t)p_28)) - (uint16_t)g_184) >= l_225)) <= g_184)) && 0x15F34AE0)) + (int16_t)l_213.f0)) | l_226) && l_213.f2);
        l_227 = l_227;
    }
    l_213 = g_170;
    if (g_102.f2)
    { /* block id: 134 */
        int16_t l_228 = (-1);
        l_228 = p_28;
        if ((l_213.f0 || ((int16_t)g_102.f1 >> (int16_t)func_48((((uint16_t)l_228 >> (uint16_t)l_228) < g_170.f2), g_170, l_213.f0))))
        { /* block id: 136 */
            if (g_102.f2)
            { /* block id: 137 */
                g_169 = 0xAD3B0C1B;
                g_102.f1 = (-7);
            }
            else
            { /* block id: 140 */
                uint32_t l_233 = 0x952072D0;
                g_170.f1 = p_28;
                l_233 = g_169;
                g_170.f1 = 0x124B1641;
            }
        }
        else
        { /* block id: 145 */
            int32_t l_236 = 0xA543894A;
            for (g_169 = (-4); (g_169 < (-12)); g_169 -= 1)
            { /* block id: 148 */
                if (g_184)
                    break;
                return l_213;
            }
            l_236 = p_28;
            g_102.f1 = g_170.f0;
            l_213.f1 = ((-(int16_t)((uint16_t)(g_184 <= 0x3699C2ED) % (uint16_t)__builtin_clzl((l_236 | 3U)))) && ((int16_t)(-(int32_t)l_236) << (int16_t)((int16_t)__builtin_clz(l_213.f0) << (int16_t)13)));
        }
        for (p_28 = 25; (p_28 < 51); p_28 += 5)
        { /* block id: 158 */
            l_213.f1 = g_147;
            g_170 = g_102;
            return g_102;
        }
        l_213.f1 = l_228;
    }
    else
    { /* block id: 164 */
        return g_102;
    }
    return g_102;
}


/* ------------------------------------------ */
/* 
 * reads : g_37 g_3 g_102 g_147 g_169 g_170 g_184
 * writes: g_37 g_102.f1 g_147 g_102 g_170.f1 g_169 g_170
 */
static uint16_t  func_33(int32_t  p_34, uint32_t  p_35)
{ /* block id: 37 */
    int32_t l_36 = 0x60813C27;
    int32_t l_42 = (-4);
    g_37 = l_36;
    p_34 = ((uint16_t)((int16_t)((l_42 != ((g_37 || func_43(g_37, g_3)) | (__builtin_bswap32(g_184) && g_184))) && ((((uint16_t)((g_184 >= 0xFDD9) ^ l_36) + (uint16_t)0x1ED2) && g_169) && l_42)) % (int16_t)0x1E8A) >> (uint16_t)2);
    l_36 = 0x6404DC0F;
    l_36 = p_34;
    return g_170.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_37 g_3 g_102 g_147 g_169 g_170 g_184
 * writes: g_102.f1 g_147 g_102 g_170.f1 g_169 g_37 g_170
 */
static int32_t  func_43(int32_t  p_44, uint32_t  p_45)
{ /* block id: 39 */
    int16_t l_71 = 0x7D5B;
    int32_t l_193 = 0;
    int16_t l_201 = 0x3384;
    g_170.f1 = ((0U >= ((uint16_t)(4294967295U ^ g_37) - (uint16_t)(((func_48(func_52(func_55(((int16_t)(((uint16_t)func_65(p_44, ((uint16_t)l_71 - (uint16_t)((uint32_t)(func_74(p_45, p_45) > 0x1456) % (uint32_t)g_3)), l_71) % (uint16_t)l_71) == 0) + (int16_t)g_3), l_71, g_102.f2, g_102.f2, g_102.f0), g_3), g_170, p_44) | g_170.f1) <= l_71) >= p_45))) <= 0x6CD91451);
    g_169 = (((((uint16_t)((int16_t)((int32_t)func_52((0x6E003A77 != (l_71 < func_55(g_170.f0, ((l_71 < (g_147 == __builtin_popcountll(((uint16_t)l_71 << (uint16_t)(((((uint16_t)(((uint16_t)((p_44 != l_71) || g_169) << (uint16_t)l_71) | l_71) + (uint16_t)1) || p_45) == p_44) != p_45))))) == g_170.f0), g_102.f2, g_184, l_71))), l_71) + (int32_t)g_170.f0) - (int16_t)g_3) >> (uint16_t)p_44) && 1) != g_170.f1) < l_71);
    if (g_37)
    { /* block id: 107 */
        int16_t l_186 = (-10);
        struct S0 l_202 = {18,-1853,18918};
        l_186 = (-(int32_t)p_44);
        l_193 = ((g_37 | (((uint32_t)func_55(p_45, l_71, p_45, g_169, ((uint16_t)0x9C6C % (uint16_t)((l_186 == ((((int16_t)(g_170.f0 != (p_45 >= l_71)) - (int16_t)65535U) == g_169) <= p_45)) && 1))) + (uint32_t)g_3) <= 7U)) ^ 0x262FDF43);
        l_193 = func_48((0xB3BD2D33 && (l_71 < (((g_184 >= g_170.f2) == ((uint16_t)((~((int16_t)((((uint32_t)(g_170.f1 != l_71) - (uint32_t)0xC57027B0) >= l_201) <= p_45) >> (int16_t)9)) && g_184) << (uint16_t)g_37)) && 8U))), l_202, l_201);
    }
    else
    { /* block id: 111 */
        int32_t l_210 = (-8);
        for (g_37 = (-18); (g_37 > 40); g_37 += 7)
        { /* block id: 114 */
            l_210 = (~((uint32_t)(((((l_201 == g_3) | func_65((l_71 && ((65527U != (p_45 ^ ((int16_t)((l_210 | p_44) | ((l_71 > 0x43E8) | g_102.f0)) >> (int16_t)p_45))) > 0x44DA636D)), l_210, l_201)) || g_37) == l_201) && p_44) - (uint32_t)0));
        }
        return l_193;
    }
    g_170 = g_102;
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_48(uint32_t  p_49, struct S0  p_50, int32_t  p_51)
{ /* block id: 102 */
    struct S0 l_171 = {17,1,19307};
    p_50 = l_171;
    return p_50.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_102 g_37 g_3 g_147 g_169
 * writes: g_102.f1 g_147 g_102
 */
static uint32_t  func_52(int16_t  p_53, uint32_t  p_54)
{ /* block id: 61 */
    struct S0 l_119 = {27,1147,20712};
    int32_t l_121 = 0xABA4BFF0;
    l_119 = g_102;
    l_119.f1 = (((-1) == 3) < (g_102.f1 && g_37));
    if ((__builtin_ctz((4U > l_119.f1)) != p_53))
    { /* block id: 64 */
        struct S0 l_120 = {16,-279,3686};
        l_120 = l_120;
        l_120.f1 = (p_54 != func_98(l_120, p_54, g_102.f2));
    }
    else
    { /* block id: 67 */
        l_119 = l_119;
    }
    if (l_121)
    { /* block id: 70 */
        int16_t l_122 = 0;
        struct S0 l_145 = {14,780,668};
        if (l_122)
        { /* block id: 71 */
            uint32_t l_127 = 0x90BACEAE;
            l_145.f1 = (((uint16_t)(g_3 <= g_3) << (uint16_t)13) & ((uint16_t)(l_127 != __builtin_clz(((uint16_t)((int32_t)(l_119.f2 <= ((int16_t)(0xE26A > (((~((int16_t)((uint32_t)4294967295U + (uint32_t)p_53) << (int16_t)9)) < g_37) != ((int32_t)(__builtin_clzll((((uint16_t)((((uint16_t)(func_98(l_145, l_119.f0, p_53) & g_3) << (uint16_t)g_102.f2) || g_102.f0) >= p_53) + (uint16_t)l_122) >= 0xBEC7)) > (-6)) + (int32_t)g_3))) << (int16_t)15)) + (int32_t)g_102.f0) >> (uint16_t)7))) << (uint16_t)1));
            return l_145.f0;
        }
        else
        { /* block id: 74 */
            int32_t l_146 = 1;
            struct S0 l_153 = {2,-2577,90};
            g_147 = func_98(g_102, p_53, l_146);
            for (l_146 = 5; (l_146 < (-18)); l_146 -= 1)
            { /* block id: 78 */
                for (p_54 = 0; (p_54 < 56); p_54 += 1)
                { /* block id: 81 */
                    struct S0 l_152 = {10,-1962,10300};
                    l_119.f1 = p_53;
                    g_102 = g_102;
                    l_145.f1 = g_102.f1;
                    l_153 = l_152;
                }
                l_153.f1 = (-1);
            }
        }
        g_102.f1 = g_102.f1;
        l_145 = l_145;
    }
    else
    { /* block id: 92 */
        uint32_t l_164 = 3U;
        int32_t l_165 = 0;
        l_165 = ((uint16_t)((((uint32_t)0x2840ACBB + (uint32_t)(0x5C784999 && (((uint32_t)p_54 - (uint32_t)(((0xFA41 >= l_121) ^ (((uint16_t)p_54 << (uint16_t)((((uint16_t)p_53 << (uint16_t)5) == (4294967295U >= ((l_164 < g_102.f1) & 0x044F))) | g_102.f0)) != 0x642D8EDD)) >= g_3)) <= g_3))) ^ l_165) != 4294967295U) << (uint16_t)g_147);
        for (p_53 = 0; (p_53 >= 20); p_53 += 7)
        { /* block id: 96 */
            g_102.f1 = g_102.f0;
        }
        l_165 = ((~g_37) ^ (65535U || 65535U));
    }
    return g_169;
}


/* ------------------------------------------ */
/* 
 * reads : g_102.f2
 * writes:
 */
static int16_t  func_55(int32_t  p_56, int32_t  p_57, uint32_t  p_58, uint32_t  p_59, uint32_t  p_60)
{ /* block id: 58 */
    int32_t l_118 = 0xEE114377;
    p_56 = l_118;
    return g_102.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_37 g_3 g_102
 * writes: g_102.f1
 */
static uint16_t  func_65(int32_t  p_66, uint32_t  p_67, uint32_t  p_68)
{ /* block id: 42 */
    int32_t l_90 = 0;
    int32_t l_103 = 1;
    l_90 = ((int16_t)((uint32_t)(((-(int16_t)((int32_t)(~((uint32_t)(((uint32_t)func_74(p_66, l_90) + (uint32_t)((int32_t)(p_67 && ((((!0xF5B6EF3B) <= g_37) <= func_74(p_67, l_90)) ^ l_90)) + (int32_t)1)) & p_68) + (uint32_t)0U)) % (int32_t)g_3)) == l_90) ^ l_90) + (uint32_t)5) << (int16_t)9);
    l_90 = __builtin_clz(p_66);
    l_103 = (func_74((((0x7A12 < ((int16_t)0 + (int16_t)((((uint16_t)(p_67 > func_98(g_102, l_103, g_102.f0)) >> (uint16_t)((uint16_t)((uint16_t)((0x420D6CD4 && ((int16_t)((uint16_t)g_3 - (uint16_t)g_37) % (int16_t)l_103)) && g_102.f2) >> (uint16_t)g_37) - (uint16_t)1U)) <= p_67) || g_3))) < l_103) & p_66), p_66) || g_102.f1);
    l_90 = ((func_74(p_67, l_103) & 0x993E) == 0x3379);
    return g_102.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_74(uint16_t  p_75, int32_t  p_76)
{ /* block id: 40 */
    uint32_t l_77 = 0xA8A7E8B7;
    return l_77;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_102.f0
 * writes: g_102.f1
 */
static uint32_t  func_98(struct S0  p_99, int32_t  p_100, int16_t  p_101)
{ /* block id: 45 */
    uint16_t l_106 = 0xA170;
    for (p_101 = (-19); (p_101 >= 8); p_101 += 1)
    { /* block id: 48 */
        uint16_t l_109 = 0x39BC;
        if (l_106)
            break;
        g_102.f1 = (1 >= ((int16_t)l_109 << (int16_t)__builtin_popcountl(l_106)));
        g_102.f1 = (l_109 ^ (g_3 > (g_102.f0 || p_99.f0)));
        if (l_109)
            continue;
    }
    return l_106;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_37, "g_37", print_hash_value);
    transparent_crc(g_102.f0, "g_102.f0", print_hash_value);
    transparent_crc(g_102.f1, "g_102.f1", print_hash_value);
    transparent_crc(g_102.f2, "g_102.f2", print_hash_value);
    transparent_crc(g_147, "g_147", print_hash_value);
    transparent_crc(g_169, "g_169", print_hash_value);
    transparent_crc(g_170.f0, "g_170.f0", print_hash_value);
    transparent_crc(g_170.f1, "g_170.f1", print_hash_value);
    transparent_crc(g_170.f2, "g_170.f2", print_hash_value);
    transparent_crc(g_184, "g_184", print_hash_value);
    transparent_crc(g_269, "g_269", print_hash_value);
    transparent_crc(g_316, "g_316", print_hash_value);
    transparent_crc(g_325, "g_325", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 54
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 20
XXX times a bitfields struct on RHS: 33
XXX times a single bitfield on LHS: 29
XXX times a single bitfield on RHS: 118

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 13
   depth: 3, occurrence: 3
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 5
   depth: 21, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 3
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 435
XXX times a non-volatile is write: 86
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 118
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 29
   depth: 2, occurrence: 22
   depth: 3, occurrence: 15
   depth: 4, occurrence: 7
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 14.7
XXX percentage an existing variable is used: 85.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

