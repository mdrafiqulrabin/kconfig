/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2601138080
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 30;
   unsigned f1 : 27;
   unsigned f2 : 17;
   unsigned f3 : 25;
   signed f4 : 4;
   signed f5 : 11;
   unsigned f6 : 29;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int16_t  func_3(uint32_t  p_4, int32_t  p_5, int32_t  p_6, struct S0  p_7);
static int32_t  func_8(uint32_t  p_9, uint16_t  p_10);
static int32_t  func_11(int16_t  p_12, uint32_t  p_13);
static uint16_t  func_17(uint16_t  p_18, uint16_t  p_19);
static uint16_t  func_21(int32_t  p_22, uint16_t  p_23);
static uint16_t  func_27(uint16_t  p_28, uint32_t  p_29, struct S0  p_30, uint8_t  p_31, uint16_t  p_32);
static uint32_t  func_33(int32_t  p_34, uint32_t  p_35);
static struct S0  func_40(struct S0  p_41, uint16_t  p_42);
static uint16_t  func_48(uint32_t  p_49, uint32_t  p_50, uint8_t  p_51);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_2 = 248U;
    int32_t l_260 = 0xFF81F1C5;
    struct S0 l_261 = {-13469,8422,285,720,-1,28,10625};
    l_261.f0 = (l_2 & (func_3(l_2, l_2, ((func_8(l_2, l_2) >= ((uint16_t)l_2 - (uint16_t)0x06EB)) >= (((uint16_t)((uint32_t)0x7789EAE0 + (uint32_t)l_260) % (uint16_t)l_2) > 0x9517D8BD)), l_261) | 0x5ABE));
    l_261 = l_261;
    l_261.f0 = (-8);
    return l_261.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_3(uint32_t  p_4, int32_t  p_5, int32_t  p_6, struct S0  p_7)
{ /* block id: 84 */
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_8(uint32_t  p_9, uint16_t  p_10)
{ /* block id: 1 */
    uint32_t l_20 = 0x7AF2C9A1;
    uint16_t l_24 = 0x2894;
    struct S0 l_200 = {-18448,7652,308,3320,-1,35,3097};
    int32_t l_201 = (-1);
    uint8_t l_202 = 3U;
    l_200.f4 = (func_11(((int16_t)(~func_17(l_20, func_21(l_24, ((uint16_t)(((0x799040C3 < ((p_9 > func_27(l_24, func_33(p_9, p_9), l_200, l_201, l_202)) >= 1)) || 6) == p_10) % (uint16_t)p_9)))) << (int16_t)7), l_200.f0) ^ l_200.f2);
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_11(int16_t  p_12, uint32_t  p_13)
{ /* block id: 78 */
    uint16_t l_252 = 0xBDB6;
    struct S0 l_253 = {-22896,7565,142,2081,0,27,19842};
    l_252 = p_13;
    l_253 = l_253;
    return l_253.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_17(uint16_t  p_18, uint16_t  p_19)
{ /* block id: 75 */
    uint8_t l_250 = 1U;
    int32_t l_251 = (-2);
    l_251 = (l_250 > (0x04CFCC2D == l_250));
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_21(int32_t  p_22, uint16_t  p_23)
{ /* block id: 68 */
    uint8_t l_249 = 1U;
    for (p_23 = 0; (p_23 >= 14); p_23 += 1)
    { /* block id: 71 */
        uint32_t l_239 = 4294967295U;
        uint8_t l_248 = 250U;
        p_22 = (((l_239 ^ (((uint32_t)5U + (uint32_t)((uint16_t)(((int16_t)0x6112 >> (int16_t)((((uint16_t)((((l_248 || l_239) >= ((-1) == ((((0U && ((l_239 || l_249) > 0x0DEA)) <= 0xE3EF1A15) == l_249) && 0x7AC1))) && l_248) >= l_249) << (uint16_t)11) || 0x70E6) <= p_22)) ^ 3U) << (uint16_t)p_23)) && p_23)) | l_248) && 0x1B04);
    }
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_27(uint16_t  p_28, uint32_t  p_29, struct S0  p_30, uint8_t  p_31, uint16_t  p_32)
{ /* block id: 63 */
    int16_t l_210 = 1;
    int32_t l_222 = 0xF8EAD33D;
    p_30.f4 = ((uint32_t)0x1A0814C5 - (uint32_t)((!((uint16_t)((int16_t)1 >> (int16_t)10) << (uint16_t)10)) <= ((l_210 ^ (!((((((int16_t)((((((int32_t)((uint16_t)((int16_t)p_30.f0 >> (int16_t)(((uint16_t)l_210 << (uint16_t)7) & p_30.f6)) << (uint16_t)3) - (int32_t)0xE24BE174) | ((0xADBFCEA1 == ((0x59A6 >= l_210) == l_210)) | 0x07A8)) < p_29) && l_222) ^ l_222) << (int16_t)l_210) == l_222) != l_210) > p_32) & p_30.f2))) > l_222)));
    p_30.f0 = ((((uint16_t)p_30.f4 + (uint16_t)((int32_t)((1U != (l_210 || (((((int16_t)(p_30.f3 | (~((((((int16_t)l_222 >> (int16_t)((int16_t)((uint16_t)(l_222 == (((((0xFF55C6AC < p_30.f0) & (-(uint16_t)l_222)) <= 0) && p_31) && p_30.f0)) - (uint16_t)p_30.f2) << (int16_t)11)) == l_210) <= p_31) || 0x939D) != l_210))) << (int16_t)l_222) & 0xF4A132B8) == l_222) == l_210))) ^ 0xFC47) + (int32_t)p_30.f3)) == 0x661E) >= l_210);
    l_222 = l_222;
    return p_30.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_33(int32_t  p_34, uint32_t  p_35)
{ /* block id: 2 */
    uint16_t l_38 = 1U;
    int32_t l_39 = 1;
    struct S0 l_43 = {-23284,3134,158,1525,2,-38,21495};
    uint16_t l_199 = 0xEE02;
    l_39 = (((uint16_t)l_38 >> (uint16_t)p_34) >= l_38);
    l_43 = func_40(l_43, p_35);
    for (p_35 = 0; (p_35 <= 44); p_35 += 1)
    { /* block id: 58 */
        uint32_t l_198 = 0x5521639E;
        p_34 = ((int16_t)((uint16_t)l_198 + (uint16_t)(l_199 != p_34)) << (int16_t)2);
    }
    l_43.f0 = p_35;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_40(struct S0  p_41, uint16_t  p_42)
{ /* block id: 4 */
    uint16_t l_67 = 0xA37E;
    int32_t l_158 = 0xD408D08F;
    struct S0 l_174 = {8750,5005,206,4548,-2,6,9476};
    int16_t l_187 = 0x2692;
    struct S0 l_191 = {25042,7949,14,3476,1,15,14754};
    for (p_42 = 0; (p_42 <= 53); p_42 += 1)
    { /* block id: 7 */
        uint32_t l_52 = 0U;
        int16_t l_68 = 0x3BD6;
        uint16_t l_70 = 0xE3B9;
        uint16_t l_71 = 0U;
        struct S0 l_102 = {9771,5519,192,545,2,6,336};
        if (((((((uint16_t)func_48(l_52, ((int32_t)((int32_t)p_42 - (int32_t)(((int16_t)(((p_41.f3 <= (((p_41.f0 > (((int16_t)((int16_t)l_52 % (int16_t)((int16_t)(p_41.f1 != (p_41.f2 == (((int16_t)l_52 % (int16_t)(l_67 & l_52)) > l_68))) % (int16_t)l_67)) << (int16_t)p_41.f5) > l_67)) || l_52) || l_67)) != 0x56E035D6) && 0x1F9D3F58) << (int16_t)2) > 0U)) + (int32_t)p_41.f2), p_41.f3) >> (uint16_t)14) != 0xE0EF155D) <= l_70) == l_67) | l_71))
        { /* block id: 11 */
            uint32_t l_91 = 4294967294U;
            struct S0 l_175 = {-25865,1876,183,1706,-3,-12,21789};
            if (p_41.f3)
            { /* block id: 12 */
                uint16_t l_97 = 65532U;
                int32_t l_98 = (-1);
                struct S0 l_103 = {-8839,862,287,618,1,-11,15574};
                if (p_41.f2)
                    break;
                if ((l_52 < l_71))
                { /* block id: 14 */
                    int32_t l_96 = 0;
                    if ((((uint16_t)((uint16_t)65535U << (uint16_t)14) >> (uint16_t)13) > ((uint32_t)((uint16_t)((((int16_t)(((int16_t)(((uint32_t)((!l_68) | ((((((int16_t)((((p_41.f2 && (((int16_t)((((((((l_91 ^ ((p_41.f4 > l_91) | ((uint16_t)((((uint16_t)l_96 << (uint16_t)0) || ((l_97 != (p_41.f1 ^ 5)) >= l_91)) != 4294967288U) % (uint16_t)p_41.f0))) | l_91) > l_52) < 65535U) || l_67) && p_41.f5) || l_98) <= 1) << (int16_t)l_67) == 0xE8BAC283)) <= l_91) && l_68) ^ l_70) - (int16_t)p_41.f2) | p_41.f0) != p_41.f4) ^ l_67) | l_91)) + (uint32_t)l_96) < p_41.f3) >> (int16_t)l_67) | l_98) - (int16_t)p_42) != 3U) | p_41.f6) << (uint16_t)12) - (uint32_t)l_67)))
                    { /* block id: 15 */
                        uint32_t l_101 = 1U;
                        p_41.f5 = (((uint32_t)l_96 - (uint32_t)((-6) >= l_101)) || (-5));
                        p_41 = l_102;
                        if (p_41.f5)
                            continue;
                    }
                    else
                    { /* block id: 19 */
                        int16_t l_113 = 0x4BD6;
                        int32_t l_127 = 1;
                        l_103 = p_41;
                        l_127 = (-(int32_t)(((int16_t)p_41.f2 << (int16_t)(((((uint32_t)l_103.f2 % (uint32_t)p_41.f5) ^ ((-(uint32_t)(p_41.f3 || (-(int16_t)((uint16_t)p_42 - (uint16_t)l_113)))) || ((int32_t)((uint16_t)((int32_t)((((4294967295U ^ ((int16_t)((~(((uint16_t)((((((l_102.f4 | ((uint16_t)0xFBAC >> (uint16_t)3)) ^ 1) >= p_41.f5) <= l_96) && l_70) | 0x1C71BA02) % (uint16_t)p_41.f4) >= p_41.f4)) && l_113) >> (int16_t)l_113)) < 0xBB2E) || l_102.f5) && l_96) % (int32_t)p_41.f3) - (uint16_t)0x5E83) + (int32_t)p_41.f1))) | l_113) & l_96)) <= l_103.f3));
                    }
                    p_41.f5 = ((int16_t)((uint16_t)(((((p_42 && ((p_41.f5 == ((uint16_t)p_42 + (uint16_t)((int16_t)l_71 + (int16_t)0x9AD6))) > (0 | (~((uint16_t)(((uint16_t)((p_41.f6 != ((int32_t)((uint16_t)(((uint32_t)((int16_t)l_102.f4 << (int16_t)(((((uint16_t)((l_102.f1 == 0xC42B59B2) < 0x861C) % (uint16_t)l_96) == p_41.f4) == p_41.f5) <= 8U)) - (uint32_t)1) | 4) << (uint16_t)p_41.f3) % (int32_t)p_41.f4)) | l_91) >> (uint16_t)l_52) < p_41.f4) + (uint16_t)5U))))) != p_41.f5) == 0xEBE3) | 0x7CFD9A5C) & p_41.f2) << (uint16_t)13) << (int16_t)p_42);
                }
                else
                { /* block id: 24 */
                    uint16_t l_157 = 0U;
                    if ((((l_91 < ((uint16_t)(p_41.f0 && 0x7827581F) - (uint16_t)((p_42 && p_42) != ((uint16_t)((((65535U != l_91) & (((int16_t)p_41.f3 - (int16_t)(((0x385C > l_91) | p_41.f3) && l_91)) > p_41.f2)) <= p_41.f3) < 1) % (uint16_t)l_67)))) | l_68) & l_71))
                    { /* block id: 25 */
                        l_103.f4 = l_157;
                        p_41.f0 = l_102.f3;
                    }
                    else
                    { /* block id: 28 */
                        l_158 = 0x5C47ABEC;
                        return l_103;
                    }
                }
                if (l_67)
                    break;
            }
            else
            { /* block id: 34 */
                uint32_t l_161 = 0U;
                int32_t l_173 = 0x5696D624;
                l_102.f4 = (((int16_t)l_102.f6 >> (int16_t)l_102.f2) <= l_91);
                l_161 = 0xFE9C12CE;
                l_173 = ((((uint32_t)(((((p_41.f1 < (p_41.f1 != ((((((uint16_t)0x31CC % (uint16_t)((~((uint32_t)(((uint16_t)p_41.f1 << (uint16_t)l_161) < 0x36A8) + (uint32_t)((int16_t)(p_41.f1 ^ p_41.f6) + (int16_t)l_91))) | l_161)) > p_41.f1) ^ l_91) == p_41.f0) >= p_41.f2))) | 0xF0EA) || 4U) != p_42) ^ l_70) - (uint32_t)0) <= 1) || p_41.f4);
                l_175 = l_174;
            }
            l_174 = p_41;
        }
        else
        { /* block id: 41 */
            struct S0 l_178 = {-16469,5323,191,3556,3,22,2039};
            for (l_158 = 24; (l_158 <= 29); l_158 += 1)
            { /* block id: 44 */
                l_178 = l_102;
            }
            l_187 = (((1 <= ((((0x29614939 <= (!((l_178.f1 < ((int32_t)l_70 + (int32_t)l_102.f4)) != ((int16_t)(~0xB1AD) << (int16_t)l_102.f0)))) & (l_174.f5 | ((int16_t)((p_41.f6 ^ l_174.f1) < p_41.f3) << (int16_t)p_41.f1))) == l_174.f4) > l_70)) & 1U) < l_178.f1);
            p_41.f0 = l_178.f1;
        }
        p_41.f0 = (((int16_t)(p_41.f3 | l_102.f3) >> (int16_t)5) & 0x73AE872C);
        l_102.f0 = (-(uint32_t)1U);
    }
    l_191 = p_41;
    return l_174;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(uint32_t  p_49, uint32_t  p_50, uint8_t  p_51)
{ /* block id: 8 */
    struct S0 l_69 = {-6717,3202,284,3524,3,8,7797};
    l_69 = l_69;
    return l_69.f1;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX full-bitfields structs in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 10
XXX times a bitfields struct on RHS: 14
XXX times a single bitfield on LHS: 14
XXX times a single bitfield on RHS: 88

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 252
XXX times a non-volatile is write: 39
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 58
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 5
   depth: 2, occurrence: 5
   depth: 3, occurrence: 8
   depth: 4, occurrence: 3
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

