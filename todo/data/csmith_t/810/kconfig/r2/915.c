/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1180139968
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 14;
};

union U1 {
   uint32_t  f0;
   const uint32_t  f1;
   uint32_t  f2;
   int16_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_29(void);
static uint32_t  func_32(uint32_t  p_33, int16_t  p_34, const struct S0  p_35);
static uint16_t  func_56(struct S0  p_57, float  p_58, union U1  p_59, struct S0  p_60, int32_t  p_61);
inline static int32_t  func_64(uint32_t  p_65);
inline static int32_t * func_67(int32_t * p_68, int32_t * const  p_69, union U1  p_70);
inline static int32_t * func_71(int32_t * p_72);
static int32_t * func_73(uint16_t  p_74);
static struct S0  func_83(uint16_t  p_84, float  p_85, int32_t * p_86);
inline static uint16_t  func_89(int32_t * p_90, int32_t * const  p_91, struct S0  p_92);
inline static int32_t * func_93(uint32_t  p_94, uint32_t  p_95, int32_t * p_96, union U1  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_29(void)
{ /* block id: 36 */
    uint16_t l_36 = 0xE071;
    const struct S0 l_49 = {64};
    uint32_t l_622 = 0U;
    int32_t l_624 = 0xF82F6E1E;
    int32_t *l_623 = &l_624;
    int32_t **l_625 = (void*)0;
    const int32_t **l_626 = (void*)0;
    uint16_t l_627 = 1U;
    (*l_623) = ((int16_t)(func_32(l_36, (((int16_t)(((uint16_t)0xF545 + (uint16_t)__builtin_ctzl(((!(-(int32_t)((uint16_t)l_36 % (uint16_t)l_36))) > l_36))) < ((-1) && l_36)) >> (int16_t)(((int32_t)(((int16_t)(((l_36 | 65535U) >= l_36) || 5U) - (int16_t)0xAA96) >= l_36) + (int32_t)l_36) & l_36)) == l_36), l_49) | l_49.f0) << (int16_t)l_622);
    l_623 = &l_624;
    return l_627;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(uint32_t  p_33, int16_t  p_34, const struct S0  p_35)
{ /* block id: 37 */
    union U1 l_62 = {0xD6326003};
    struct S0 l_63 = {117};
    int32_t *l_549 = (void*)0;
    uint32_t l_563 = 8U;
    int16_t l_597 = 6;
    int32_t * const *l_614 = &l_549;
    int32_t * const **l_613 = &l_614;
    int32_t * const ***l_612 = &l_613;
    union U1 *l_618 = &l_62;
    union U1 **l_617 = &l_618;
    const struct S0 *l_621 = &l_63;
    const struct S0 **l_620 = &l_621;
    if (((((((((0 > ((int16_t)((int16_t)p_34 >> (int16_t)((uint16_t)func_56(p_35, p_35.f0, l_62, l_63, p_34) >> (uint16_t)((uint16_t)(p_34 < l_62.f2) >> (uint16_t)3))) - (int16_t)l_62.f1)) >= l_62.f1) >= p_35.f0) ^ l_62.f1) ^ l_62.f2) ^ p_33) != l_62.f3) ^ l_62.f3))
    { /* block id: 295 */
        int32_t *l_545 = (void*)0;
        union U1 *l_574 = &l_62;
        union U1 **l_573 = &l_574;
        union U1 *** const l_572 = &l_573;
        struct S0 l_577 = {70};
        float l_591 = 0x5.D3E0BBp+92;
        float *l_590 = &l_591;
        float **l_589 = &l_590;
        struct S0 *l_609 = &l_577;
        for (l_62.f2 = 0; (l_62.f2 >= 33); l_62.f2 += 9)
        { /* block id: 298 */
            int32_t l_538 = 0x3520F130;
            int32_t *l_537 = &l_538;
            struct S0 *l_539 = &l_63;
            int16_t l_554 = 0x60B3;
            union U1 l_555 = {1U};
            float *l_557 = (void*)0;
            float *l_558 = (void*)0;
            float l_560 = 0x6.A1002Bp-30;
            float *l_559 = &l_560;
            (*l_539) = func_83(l_62.f0, p_34, l_537);
            for (p_34 = 0; (p_34 < 11); p_34 += 6)
            { /* block id: 302 */
                int32_t *l_546 = &l_538;
                union U1 l_548 = {5U};
                int32_t **l_551 = &l_546;
                for (p_33 = 0; (p_33 != 4); p_33 += 1)
                { /* block id: 305 */
                    uint16_t l_544 = 0x4CD4;
                    (*l_537) = p_34;
                }
                (*l_551) = l_546;
                if (((*l_546) >= (((uint32_t)5U - (uint32_t)(l_545 != l_549)) >= ((**l_551) < p_34))))
                { /* block id: 316 */
                    (*l_539) = p_35;
                }
                else
                { /* block id: 318 */
                    int32_t *l_556 = &l_538;
                    (*l_551) = func_71(l_556);
                    if (p_34)
                        continue;
                }
            }
            (*l_559) = (0x5.5p-1 < 0xE.96B18Dp-76);
            if (((int16_t)((p_34 | (*l_537)) > 9) % (int16_t)l_563))
            { /* block id: 324 */
                int32_t l_575 = 0;
                for (p_33 = 0; (p_33 == 27); ++p_33)
                { /* block id: 327 */
                    struct S0 **l_566 = &l_539;
                    int32_t l_576 = 0xE07B1410;
                    (*l_566) = l_539;
                    if ((((p_33 & (((!((uint32_t)p_35.f0 - (uint32_t)((uint16_t)((void*)0 != l_572) >> (uint16_t)l_575))) > __builtin_ia32_crc32qi(l_575, l_576)) < (p_34 & p_34))) < (*l_537)) != l_576))
                    { /* block id: 329 */
                        (**l_566) = p_35;
                        return p_35.f0;
                    }
                    else
                    { /* block id: 332 */
                        return p_33;
                    }
                }
                (*l_539) = l_577;
                (*l_539) = p_35;
            }
            else
            { /* block id: 338 */
                float l_584 = 0x4.D6DA28p+36;
                int32_t *l_587 = &l_538;
                union U1 *l_608 = &l_62;
                for (l_563 = 0; (l_563 > 12); l_563++)
                { /* block id: 341 */
                    int32_t *l_583 = &l_538;
                    union U1 l_588 = {1U};
                    float ***l_592 = &l_589;
                    (*l_537) = func_56(p_35, (((float)((!l_584) != (((float)func_89(l_587, &l_538, func_83(p_33, (__builtin_clzl((*l_537)) <= p_33), l_587)) - (float)0x4.7p-1) < (-0x8.Ap+1))) - (float)p_34) > p_34), l_588, p_35, p_33);
                    (*l_592) = l_589;
                    for (l_554 = 17; (l_554 > (-4)); l_554--)
                    { /* block id: 346 */
                        (*l_583) = ((float)(((*l_587) <= l_597) > (((*l_587) <= (p_33 != ((float)0xB.DDB8F9p+45 - (float)((float)((float)(-0x1.4p-1) - (float)((*l_583) > (((float)__builtin_ffsl((((uint32_t)p_33 + (uint32_t)0) ^ (-3))) - (float)0xC.DAAA27p+52) >= (-0x1.Ep-1)))) - (float)(*l_537))))) <= (-0x1.Bp+1))) - (float)(*l_537));
                        (*l_559) = func_64(p_33);
                        (**l_572) = l_608;
                    }
                }
            }
        }
        /* facts after for loop */
                l_549 = l_549;
        (*l_609) = p_35;
        l_549 = l_545;
    }
    else
    { /* block id: 357 */
        struct S0 *l_610 = &l_63;
        float l_616 = (-0x3.Ep-1);
        float *l_615 = &l_616;
        union U1 ***l_619 = &l_617;
        (*l_610) = l_63;
        (*l_615) = (((-(float)p_34) < ((-0x2.5p-1) <= (p_35.f0 <= ((void*)0 != l_612)))) > (0x9.37537Ep-79 >= 0x0.269186p+55));
        (*l_619) = l_617;
    }
    /* facts after branching */
        (*l_612) = (*l_612);
    (*l_620) = &l_63;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_56(struct S0  p_57, float  p_58, union U1  p_59, struct S0  p_60, int32_t  p_61)
{ /* block id: 38 */
    int32_t l_76 = 0;
    int32_t *l_75 = &l_76;
    union U1 l_523 = {0x8BD8E4BD};
    union U1 *l_522 = &l_523;
    struct S0 l_524 = {76};
    float l_532 = 0x8.AAB2A0p-9;
    float *l_531 = &l_532;
    if (func_64((0xCEB2CFB1 >= 0x89A45823)))
    { /* block id: 41 */
        uint32_t l_81 = 4294967288U;
        int32_t * const l_495 = &l_76;
        union U1 l_496 = {4294967294U};
        int32_t **l_521 = &l_75;
        struct S0 *l_525 = &l_524;
        (*l_521) = func_67(func_71(func_73(((__builtin_parityll(((void*)0 != l_75)) || ((int16_t)func_64((__builtin_clzl((*l_75)) != func_64((*l_75)))) >> (int16_t)((__builtin_clz(l_81) != 65534U) < 0))) > (*l_75)))), l_495, l_496);
        /* statement id: 287 */
        assert (l_75 == 0);
        l_522 = (void*)0;
        /* statement id: 288 */
        assert (l_522 == 0);
        (*l_525) = l_524;
    }
    else
    { /* block id: 290 */
        uint16_t l_526 = 0x867E;
        l_526 = (*l_75);
    }
    /* facts after branching */
    assert (l_75 == &l_76 || l_75 == 0);
    assert (l_522 == &l_523 || l_522 == 0);
    (*l_531) = (0xC.A99503p+73 < (__builtin_popcount(p_59.f1) > ((float)((((l_523.f3 != p_59.f0) > ((((float)l_76 - (float)__builtin_popcountl(p_59.f2)) != p_59.f2) > p_61)) > 0xC.971CE6p-49) != p_60.f0) + (float)0x6.77B58Ep+6)));
    return p_59.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_64(uint32_t  p_65)
{ /* block id: 39 */
    int16_t l_66 = (-1);
    return l_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_67(int32_t * p_68, int32_t * const  p_69, union U1  p_70)
{ /* block id: 266 */
    int16_t l_497 = 0xD329;
    float l_508 = 0xE.1A6B96p+43;
    float *l_507 = &l_508;
    float ***l_509 = (void*)0;
    struct S0 *l_513 = (void*)0;
    if (l_497)
    { /* block id: 267 */
        int32_t l_503 = 0;
        int32_t l_510 = 0x5CA382A8;
        for (p_70.f0 = 10; (p_70.f0 >= 50); p_70.f0++)
        { /* block id: 270 */
            int32_t l_502 = 0x7AE38FBD;
            const int32_t *l_501 = &l_502;
            const int32_t **l_500 = &l_501;
            struct S0 l_504 = {125};
            (*l_500) = p_69;
            /* statement id: 271 */
            //assert (l_501 == &l_76);
            (*p_69) = l_503;
            (*l_507) = ((p_70.f1 < func_89(&l_503, &l_503, l_504)) != ((float)((((l_507 != (void*)0) <= ((((l_509 == (void*)0) > l_510) > (*l_501)) >= p_70.f3)) >= l_510) != l_497) - (float)p_70.f2));
        }
    }
    else
    { /* block id: 275 */
        union U1 l_512 = {0x2F4FFE47};
        union U1 *l_511 = &l_512;
        struct S0 **l_514 = &l_513;
        int32_t l_518 = 0x343A8D19;
        int32_t *l_517 = &l_518;
        l_511 = &p_70;
        /* statement id: 276 */
        assert (l_511 == &p_70);
        (*l_514) = l_513;
        for (p_70.f3 = (-5); (p_70.f3 != (-5)); p_70.f3 += 5)
        { /* block id: 280 */
            return p_68;
            /* statement id: 281 */
            //assert (func_67_rv == 0);
        }
        /* facts after for loop */
                (*p_69) = ((((uint16_t)l_497 >> (uint16_t)0) & __builtin_popcountll(((((&l_513 == &l_513) == (*l_517)) || func_64(func_64((*l_517)))) && p_70.f3))) && 1U);
    }
    /* facts after branching */
        (*l_507) = 0x9.9p-1;
    return p_68;
    /* statement id: 286 */
    //assert (func_67_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_71(int32_t * p_72)
{ /* block id: 262 */
    float l_471 = 0xE.652DCBp+34;
    uint16_t l_472 = 0x8297;
    const int32_t l_477 = 3;
    const int32_t *l_476 = &l_477;
    const int32_t **l_475 = &l_476;
    union U1 l_494 = {0x6A118B43};
    (*l_475) = func_73((((uint16_t)0xE13F + (uint16_t)((+(-(uint32_t)((((l_472 | 0xDD14) == (__builtin_clzl(l_472) <= ((int32_t)l_472 - (int32_t)(l_472 < 4294967295U)))) ^ l_472) & 0xC2B9D959))) & l_472)) && 8U));
    /* statement id: 263 */
    assert (l_476 == 0);
    (*l_475) = func_93((((int16_t)((+((uint16_t)((int32_t)(0x7E79 < (0x676639DB > l_472)) + (int32_t)l_477) - (uint16_t)(((((int16_t)l_477 >> (int16_t)(+((int16_t)(l_477 | (((uint16_t)((&l_475 != &l_475) > func_64(((void*)0 != p_72))) + (uint16_t)l_477) > 3)) >> (int16_t)10))) > l_472) || 4294967294U) > l_472))) == (-1)) << (int16_t)l_477) & 4U), l_472, p_72, l_494);
    /* statement id: 264 */
    //assert (l_476 == 0 || l_476 == &l_538);
    return p_72;
    /* statement id: 265 */
    //assert (func_71_rv == 0 || func_71_rv == &l_538);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_73(uint16_t  p_74)
{ /* block id: 42 */
    int32_t l_82 = (-1);
    int32_t l_88 = 2;
    int32_t *l_87 = &l_88;
    uint32_t l_104 = 0xF0EBE340;
    union U1 l_105 = {4294967295U};
    float l_264 = 0x7.6126E0p-79;
    float *l_263 = &l_264;
    float **l_262 = &l_263;
    float ***l_261 = &l_262;
    struct S0 l_273 = {117};
    const int32_t ****l_300 = (void*)0;
    int32_t *l_309 = &l_88;
    const union U1 *l_397 = &l_105;
    const union U1 **l_396 = &l_397;
    const union U1 ***l_395 = &l_396;
    const uint32_t l_438 = 0xBDFED1B2;
    int32_t **l_450 = &l_87;
    int32_t *** const l_449 = &l_450;
    int32_t *l_466 = (void*)0;
    if ((l_82 != 0x22E3BD65))
    { /* block id: 43 */
        const int32_t l_103 = 0x89E6D542;
        struct S0 l_109 = {1};
        int32_t l_233 = 0xA3F0311D;
        int32_t *l_232 = &l_233;
        struct S0 *l_235 = &l_109;
        union U1 * const l_236 = &l_105;
        const union U1 **l_237 = (void*)0;
        union U1 *l_239 = &l_105;
        union U1 **l_238 = &l_239;
        const float ***l_260 = (void*)0;
        struct S0 l_278 = {17};
        float **l_286 = (void*)0;
        int32_t *l_293 = &l_233;
        int32_t *l_315 = &l_233;
        int32_t *l_320 = &l_88;
        int32_t *l_323 = &l_88;
        int32_t *l_326 = (void*)0;
        (*l_235) = func_83(((((void*)0 != l_87) != (0xA435 || func_89(func_93(func_64(((p_74 | (0x16A1 && ((((+6) > ((int16_t)p_74 - (int16_t)__builtin_clz(((int16_t)l_103 % (int16_t)p_74)))) > 8) && p_74))) ^ (*l_87))), l_104, &l_88, l_105), &l_88, l_109))) >= 0x2580), p_74, l_232);
        (*l_238) = l_236;
        l_87 = func_93(p_74, (*l_232), &l_88, (*l_236));
        if ((*l_87))
        { /* block id: 131 */
            uint16_t l_246 = 0xCFEF;
            int32_t *l_257 = &l_88;
            for (l_105.f2 = 22; (l_105.f2 > 2); l_105.f2 -= 1)
            { /* block id: 134 */
                uint16_t l_251 = 0x3201;
                int32_t * const l_255 = (void*)0;
                int32_t **l_256 = &l_87;
            }
            /* facts after for loop */
                        l_257 = &l_233;
            /* statement id: 143 */
            assert (l_257 == &l_233);
            (*l_232) = ((float)(l_260 != l_261) + (float)p_74);
            if (((*l_232) | ((uint16_t)__builtin_parity((+((*l_257) != (*l_87)))) >> (uint16_t)(*l_232))))
            { /* block id: 145 */
                float ****l_268 = (void*)0;
                float ****l_269 = (void*)0;
                float ****l_270 = (void*)0;
                float ****l_271 = &l_261;
                int32_t l_272 = 0x964B614F;
                (*l_271) = (void*)0;
                /* statement id: 146 */
                assert (l_261 == 0);
                (*l_232) = p_74;
                l_273 = func_83((*l_257), ((*l_232) <= l_272), &l_272);
            }
            else
            { /* block id: 149 */
                int32_t **l_274 = &l_87;
                (*l_274) = &l_233;
                /* statement id: 150 */
                assert (l_87 == &l_233);
                (*l_274) = &l_233;
            }
            /* facts after branching */
            assert (l_87 == &l_233 || l_87 == &l_88);
            assert (l_261 == &l_262 || l_261 == 0);
        }
        else
        { /* block id: 153 */
            int32_t * const l_277 = &l_88;
            int32_t *l_279 = &l_88;
            union U1 l_280 = {0U};
            int32_t **l_281 = &l_87;
            const int32_t ****l_301 = (void*)0;
            int32_t *l_338 = &l_88;
            uint32_t l_358 = 0U;
            struct S0 *l_380 = &l_109;
            (*l_281) = func_93((((((uint16_t)(*l_87) >> (uint16_t)(*l_232)) == 0xADD0) != ((l_277 == &l_88) && ((*l_232) != 9U))) == (*l_277)), (*l_277), l_279, l_280);
            (*l_238) = &l_105;
            if ((*l_232))
            { /* block id: 156 */
                uint32_t l_288 = 4294967292U;
                int32_t *l_289 = &l_88;
                int32_t *l_292 = &l_88;
                int32_t *l_308 = &l_88;
                int32_t *l_312 = &l_88;
                int32_t *l_318 = &l_88;
                int32_t *l_322 = &l_233;
                int32_t *l_340 = (void*)0;
                (*l_281) = &l_88;
lbl_305:
                (*l_232) = p_74;
                for (p_74 = 0; (p_74 != 20); p_74 += 4)
                { /* block id: 161 */
                    float l_287 = 0x2.9318B5p+70;
                    int32_t *l_290 = &l_88;
                    int32_t *l_307 = &l_233;
                    int32_t *l_310 = &l_88;
                    int32_t *l_311 = &l_88;
                    int32_t *l_313 = &l_88;
                    int32_t *l_314 = &l_88;
                    int32_t *l_316 = &l_88;
                    int32_t *l_319 = &l_233;
                    int32_t *l_321 = &l_88;
                    if (((int16_t)((void*)0 == l_286) >> (int16_t)l_288))
                    { /* block id: 162 */
                        int32_t *l_291 = &l_88;
                        int32_t *l_294 = (void*)0;
                        return l_294;
                        /* statement id: 163 */
                        //assert (func_73_rv == 0);
                    }
                    else
                    { /* block id: 164 */
                        struct S0 **l_295 = &l_235;
                        float *l_302 = &l_264;
                        (*l_295) = &l_109;
                        (*l_277) = ((int32_t)__builtin_parity(((int32_t)(__builtin_parity(p_74) < p_74) + (int32_t)((*l_279) ^ ((((*l_87) <= (l_300 != l_301)) || (((l_277 == l_302) < (*l_289)) ^ (*l_290))) == (-1))))) % (int32_t)(*l_292));
                    }
                    if ((((-8) ^ ((p_74 || ((uint32_t)func_89(&l_88, l_290, (*l_235)) % (uint32_t)(0x29B3 | (0x38082337 < 0xC0702C48)))) | p_74)) < p_74))
                    { /* block id: 168 */
                        (*l_281) = &l_233;
                        /* statement id: 169 */
                        assert (l_87 == &l_233);
                    }
                    else
                    { /* block id: 170 */
                        int32_t *l_306 = &l_88;
                        int32_t *l_317 = &l_88;
                        int32_t *l_324 = &l_88;
                        int32_t *l_325 = &l_88;
                        if (l_233)
                            goto lbl_305;
                        return l_326;
                        /* statement id: 172 */
                        //assert (func_73_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_87 == &l_233);
                }
                for (l_280.f2 = 0; (l_280.f2 != 54); l_280.f2 += 9)
                { /* block id: 177 */
                    uint32_t l_337 = 4294967289U;
                    int32_t *l_339 = &l_233;
                    (*l_263) = 0x7.Bp-1;
                    for (l_105.f0 = 13; (l_105.f0 == 9); l_105.f0--)
                    { /* block id: 181 */
                        int32_t *****l_331 = (void*)0;
                        const int32_t *l_336 = &l_88;
                        const int32_t **l_335 = &l_336;
                        const int32_t ** const *l_334 = &l_335;
                        const int32_t ** const **l_333 = &l_334;
                        const int32_t ** const ***l_332 = &l_333;
                        (*l_332) = l_301;
                        /* statement id: 182 */
                        assert (l_333 == 0);
                        (*l_309) = (*l_232);
                        if (l_337)
                            break;
                    }
                    return l_340;
                    /* statement id: 186 */
                    //assert (func_73_rv == 0);
                }
                /* facts after for loop */
                            }
            else
            { /* block id: 188 */
                int32_t l_341 = 0x257C1A50;
                uint32_t l_354 = 0xD14600C4;
                int32_t *l_355 = &l_341;
                struct S0 l_356 = {52};
lbl_357:
                (*l_281) = &l_233;
                /* statement id: 189 */
                assert (l_87 == &l_233);
lbl_368:
                (*l_281) = &l_233;
                if ((p_74 >= l_341))
                { /* block id: 191 */
                    uint32_t l_342 = 0xA032CACB;
                    int32_t *l_343 = &l_341;
                    struct S0 * const l_364 = (void*)0;
                    if ((l_342 ^ 9U))
                    { /* block id: 192 */
                        struct S0 l_344 = {67};
                        float *l_353 = &l_264;
                        (***l_261) = (p_74 != func_89(l_343, &l_88, l_344));
                        (*l_343) = l_344.f0;
                        l_355 = func_93(((uint16_t)p_74 - (uint16_t)p_74), ((((int16_t)p_74 << (int16_t)(1 != (func_64(p_74) <= ((int16_t)p_74 << (int16_t)((uint16_t)((void*)0 != l_353) + (uint16_t)l_354))))) | 0x073444A4) <= (*l_338)), &l_341, (*l_236));
                        l_356 = func_83((**l_281), (0x2.3D9938p-75 == p_74), l_343);
                    }
                    else
                    { /* block id: 197 */
                        int32_t l_363 = (-4);
                        struct S0 *l_365 = &l_273;
                        if (p_74)
                            goto lbl_357;
                        (*l_281) = func_93(l_358, (*l_343), (*l_281), l_280);
                        (*l_277) = (((p_74 && (*l_355)) == (((9 == (((int16_t)(&l_343 != &l_232) >> (int16_t)2) & ((uint16_t)((0xC6893462 && (__builtin_ia32_crc32qi(((*l_355) >= ((void*)0 != &l_343)), p_74) && 0xBEBC32C6)) || p_74) << (uint16_t)p_74))) != 0U) != l_363)) >= p_74);
                        l_365 = l_364;
                        /* statement id: 201 */
                        assert (l_365 == 0);
                    }
                    for (p_74 = 0; (p_74 <= 6); ++p_74)
                    { /* block id: 205 */
                        if (l_280.f3)
                            goto lbl_368;
                    }
                    (*l_281) = func_93(p_74, ((((int32_t)(p_74 < ((uint16_t)((+p_74) | 0) - (uint16_t)65535U)) - (int32_t)(((uint16_t)((int16_t)0x0E83 % (int16_t)(*l_355)) >> (uint16_t)9) != (*l_355))) != (p_74 <= 1)) != 0x4805), (*l_281), (*l_239));
                }
                else
                { /* block id: 209 */
                    float l_381 = 0x5.8p-1;
                    if (((int16_t)(*l_279) << (int16_t)(((&l_356 == l_380) && (*l_355)) & (p_74 > (p_74 | p_74)))))
                    { /* block id: 210 */
                        struct S0 **l_382 = (void*)0;
                        struct S0 **l_383 = (void*)0;
                        struct S0 *l_384 = &l_109;
                        l_384 = &l_109;
                        (*l_263) = 0x1.1DF9F0p+29;
                    }
                    else
                    { /* block id: 213 */
                        int32_t *l_385 = &l_88;
                        const float l_394 = 0x1.Cp-1;
                        (*l_281) = l_385;
                        /* statement id: 214 */
                        assert (l_87 == &l_88);
                        (**l_281) = __builtin_ia32_crc32qi((*l_338), ((int32_t)p_74 - (int32_t)((uint16_t)((((int16_t)func_64(p_74) % (int16_t)((*l_385) | 4U)) || ((*l_323) & 0xB1F4020B)) || (((int16_t)(*l_355) % (int16_t)(*l_385)) & 0xDA1E)) << (uint16_t)4)));
                        (*l_281) = &l_233;
                        /* statement id: 216 */
                        assert (l_87 == &l_233);
                    }
                }
            }
            /* facts after branching */
            assert (l_87 == &l_233 || l_87 == &l_88);
                    }
        /* facts after branching */
        assert (l_87 == &l_233 || l_87 == &l_88);
                assert (l_261 == &l_262 || l_261 == 0);
    }
    else
    { /* block id: 221 */
        int16_t l_400 = (-1);
        union U1 l_408 = {0xF128C111};
        int32_t *l_443 = &l_88;
        uint16_t l_460 = 0x52C1;
lbl_439:
        l_395 = l_395;
        for (l_105.f2 = 0; (l_105.f2 > 32); l_105.f2 += 2)
        { /* block id: 225 */
            uint16_t l_406 = 2U;
            int32_t *l_407 = &l_88;
            int32_t **l_409 = &l_309;
            struct S0 l_414 = {117};
            uint32_t l_459 = 0x4A86C97D;
            union U1 l_465 = {4294967295U};
            (*l_409) = func_93(l_400, ((int16_t)(p_74 & ((uint16_t)(!0x6A233A8C) + (uint16_t)((0x1D9A2A01 & 4294967287U) ^ 0x9EA4978A))) - (int16_t)l_406), l_407, l_408);
            /* statement id: 226 */
            assert (l_309 == &l_88);
            (*l_409) = (*l_409);
            (*l_409) = (void*)0;
            /* statement id: 228 */
            assert (l_309 == 0);
            for (p_74 = 0; (p_74 <= 39); p_74 += 9)
            { /* block id: 231 */
                int32_t *****l_423 = (void*)0;
                union U1 *l_428 = &l_105;
                uint32_t l_464 = 0U;
                if ((((0xD976 != ((uint16_t)__builtin_ffs(l_408.f2) % (uint16_t)__builtin_bswap32(p_74))) || p_74) && (p_74 && 4)))
                { /* block id: 232 */
                    struct S0 *l_415 = (void*)0;
                    struct S0 *l_416 = &l_414;
                    (*l_416) = l_414;
                }
                else
                { /* block id: 234 */
                    uint32_t l_427 = 0x43F3F6BD;
                    if (p_74)
                        break;
                    (*l_407) = (!(((uint16_t)65535U >> (uint16_t)2) != (((-(int16_t)((uint16_t)(0x7F5ED74E >= ((&l_300 != l_423) != (((((int32_t)p_74 - (int32_t)l_408.f2) == ((-(uint32_t)(p_74 | (__builtin_popcountll(p_74) && 0xD47C410B))) && (-3))) || 0x545C) <= p_74))) % (uint16_t)l_427)) == p_74) <= p_74)));
                    (*l_396) = l_428;
                }
                for (l_406 = 0; (l_406 == 1); l_406 += 1)
                { /* block id: 241 */
                    int32_t *l_440 = (void*)0;
                    int32_t l_442 = 1;
                    uint32_t l_448 = 3U;
                    if (p_74)
                    { /* block id: 242 */
                        union U1 **l_434 = &l_428;
                        union U1 ***l_433 = &l_434;
                        (**l_262) = (((float)__builtin_popcountll(p_74) + (float)p_74) == (((void*)0 != l_433) == (-(float)((float)0x7.84915Dp-62 - (float)l_438))));
                        if (l_104)
                            goto lbl_439;
                        l_440 = (*l_409);
                        l_442 = (~65532U);
                    }
                    else
                    { /* block id: 247 */
                        (**l_262) = (0x8.104D5Cp-43 > ((void*)0 != l_443));
                    }
                    if (((((*l_407) & (*l_87)) && (*l_87)) > (((int32_t)0x271EE976 - (int32_t)(4294967295U == 8U)) && 0x26CF)))
                    { /* block id: 250 */
                        l_440 = l_443;
                        /* statement id: 251 */
                        assert (l_440 == &l_88);
                        if (p_74)
                            break;
                    }
                    else
                    { /* block id: 253 */
                        (**l_262) = ((float)l_448 - (float)(((void*)0 != l_449) > ((float)(*l_443) - (float)((((float)((float)__builtin_parity(((uint16_t)p_74 << (uint16_t)7)) - (float)p_74) + (float)((l_459 <= (0x6.Cp-1 >= (-0x5.Ep-1))) != p_74)) == 0x0.6p-1) <= p_74))));
                    }
                    /* facts after branching */
                    assert (l_440 == 0 || l_440 == &l_88);
                    (*l_450) = func_93(l_460, (*l_407), func_93((!(l_464 ^ (4 >= (*l_443)))), __builtin_parityll((*l_443)), (*l_450), l_465), l_465);
                }
            }
        }
        /* facts after for loop */
            }
    /* facts after branching */
    //assert (l_87 == dangling || l_87 == &l_88);
        assert (l_261 == &l_262 || l_261 == 0);
    assert (l_309 == 0 || l_309 == &l_88);
    return l_466;
    /* statement id: 261 */
    //assert (func_73_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_83(uint16_t  p_84, float  p_85, int32_t * p_86)
{ /* block id: 126 */
    struct S0 l_234 = {90};
    return l_234;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_89(int32_t * p_90, int32_t * const  p_91, struct S0  p_92)
{ /* block id: 47 */
    uint16_t l_110 = 0x6E71;
    int32_t l_168 = (-1);
    int32_t *l_167 = &l_168;
    int32_t **l_170 = &l_167;
    int32_t ***l_169 = &l_170;
    float l_189 = 0x5.E694C0p-10;
    float *l_188 = &l_189;
    struct S0 l_217 = {105};
    float **l_231 = &l_188;
    float ***l_230 = &l_231;
    if (l_110)
    { /* block id: 48 */
        uint16_t l_111 = 0xE455;
        float l_113 = (-0x10.1p+1);
        float *l_112 = &l_113;
        float **l_115 = (void*)0;
        float ***l_114 = &l_115;
        (*l_112) = (func_64((p_92.f0 | l_111)) <= l_111);
        (*l_114) = &l_112;
        /* statement id: 50 */
        assert (l_115 == &l_112);
    }
    else
    { /* block id: 51 */
        uint32_t l_118 = 1U;
        int16_t l_149 = (-4);
        int32_t l_166 = 0x9317E4F0;
        int32_t *** const l_190 = &l_170;
        const struct S0 l_193 = {93};
        float *l_198 = &l_189;
        float * const * const l_205 = &l_198;
        float * const * const *l_204 = &l_205;
        uint16_t l_216 = 65535U;
        for (l_110 = (-27); (l_110 > 8); l_110++)
        { /* block id: 54 */
            int32_t l_153 = 0x43A1FAE6;
            int32_t *l_152 = &l_153;
            int32_t **l_151 = &l_152;
            int32_t ***l_150 = &l_151;
            union U1 l_201 = {4294967293U};
            float * const * const l_203 = (void*)0;
            float * const * const *l_202 = &l_203;
        }
        (***l_169) = ((***l_190) <= ((***l_190) != ((***l_169) ^ 0U)));
        (*l_198) = (0x5.B1F743p-71 > __builtin_ctzll(((uint16_t)((p_92.f0 <= (*p_91)) > (***l_169)) - (uint16_t)(***l_169))));
        if (((int16_t)((((uint16_t)((void*)0 != (*l_169)) >> (uint16_t)0) < 0x37A0) > p_92.f0) % (int16_t)((uint16_t)(((uint16_t)((***l_190) & p_92.f0) >> (uint16_t)4) | (*p_90)) % (uint16_t)(((p_90 != (*l_205)) & p_92.f0) | l_216))))
        { /* block id: 111 */
            struct S0 *l_218 = &l_217;
            (*l_218) = l_217;
            for (l_216 = (-8); (l_216 <= 52); l_216 += 7)
            { /* block id: 115 */
                if ((***l_190))
                    break;
            }
            return p_92.f0;
        }
        else
        { /* block id: 119 */
            const uint32_t l_223 = 0U;
            (*l_198) = (((float)((((l_223 <= ((float)func_64(((int32_t)(((p_92.f0 ^ 0x2692) ^ l_223) || 1U) - (int32_t)((*l_167) ^ ((void*)0 != &l_190)))) - (float)p_92.f0)) < 0xC.FFDF52p-10) <= 0x2.2CB338p-63) > 0x1.8p+1) - (float)0x1.Dp-1) >= (***l_190));
            (*l_167) = (l_223 | ((**l_169) != p_90));
            (*p_91) = (p_92.f0 <= (l_230 == (void*)0));
        }
    }
    return p_92.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_93(uint32_t  p_94, uint32_t  p_95, int32_t * p_96, union U1  p_97)
{ /* block id: 44 */
    int32_t l_108 = 0xAE3B8AEA;
    int32_t *l_107 = &l_108;
    int32_t **l_106 = &l_107;
    (*l_106) = p_96;
    /* statement id: 45 */
    //assert (l_107 == &l_88 || l_107 == &l_233 || l_107 == &l_341 || l_107 == 0 || l_107 == &l_538);
    return p_96;
    /* statement id: 46 */
    //assert (func_93_rv == &l_88 || func_93_rv == &l_233 || func_93_rv == &l_341 || func_93_rv == 0 || func_93_rv == &l_538);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 170
   depth: 1, occurrence: 16
XXX total union variables: 12

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 22
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 6
XXX full-bitfields structs in the program: 16
breakdown:
   indirect level: 0, occurrence: 16
XXX times a bitfields struct's address is taken: 19
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 34
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 36

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 186
   depth: 2, occurrence: 24
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 6
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 4
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 180

XXX times a variable address is taken: 188
XXX times a pointer is dereferenced on RHS: 101
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 7
   depth: 3, occurrence: 10
XXX times a pointer is dereferenced on LHS: 109
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 22
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 359

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 286
   level: 2, occurrence: 32
   level: 3, occurrence: 60
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 73
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 27.8
XXX average alias set size: 1.24

XXX times a non-volatile is read: 691
XXX times a non-volatile is write: 275
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 161
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 28
   depth: 2, occurrence: 25
   depth: 3, occurrence: 22
   depth: 4, occurrence: 25
   depth: 5, occurrence: 37

XXX percentage a fresh-made variable is used: 17.9
XXX percentage an existing variable is used: 82.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

