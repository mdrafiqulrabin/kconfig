/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1534988756
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   float  f1;
   float  f2;
   const uint16_t  f3;
   uint16_t  f4;
   int32_t  f5;
   float  f6;
   uint32_t  f7;
   int32_t  f8;
};
#pragma pack(pop)

struct S1 {
   const uint32_t  f0;
   float  f1;
   int64_t  f2;
   uint64_t  f3;
   const float  f4;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   unsigned f0 : 28;
   struct S0  f1;
   struct S0  f2;
   int32_t  f3;
   const uint64_t  f4;
   uint32_t  f5;
   unsigned f6 : 9;
   const struct S0  f7;
};
#pragma pack(pop)

union U3 {
   const unsigned f0 : 8;
   uint8_t  f1;
};

union U4 {
   unsigned f0 : 19;
   uint16_t  f1;
   int16_t  f2;
   uint64_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_26(void);
static struct S0 * const  func_27(struct S0 * p_28);
static struct S0 * func_29(struct S2  p_30, union U4  p_31, struct S0 * p_32, struct S0 * p_33, float  p_34);
static union U4  func_36(struct S0 * p_37);
static struct S0 * func_38(struct S0 * p_39);
inline static struct S0 * func_40(uint8_t  p_41, const union U4  p_42);
static uint16_t  func_44(uint32_t  p_45);
static int64_t  func_48(struct S0 * p_49, uint8_t  p_50, uint32_t  p_51);
inline static int16_t  func_55(const uint64_t  p_56, struct S1  p_57, uint32_t  p_58, struct S1  p_59, struct S0 * const  p_60);
static uint64_t  func_63(struct S0 * p_64, int16_t  p_65);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_26(void)
{ /* block id: 36 */
    struct S2 l_35 = {3134,{0x9C906054L,-0x1.3p+1,0x5.B46FACp-14,4UL,0x6D77L,0x74D37718L,0x0.68266Cp+58,0x3B22489AL,0L},{-3L,0x1.Ep-1,-0x9.Ap+1,65530UL,65534UL,0x2F3A6825L,0x8.284A89p+68,0UL,1L},3L,1UL,18446744073709551611UL,6,{-6L,0xF.FC5A51p-24,-0x3.Dp+1,0x864BL,9UL,-4L,0x0.9p-1,0xA6CBABA2L,-8L}};
    uint64_t l_43 = 18446744073709551613UL;
    struct S0 *l_52 = &l_35.f1;
    struct S1 l_70 = {0x1AB19369L,0x0.5p-1,-9L,0x0B5C0E846833E316LL,-0x1.7p+1};
    struct S0 * const l_71 = &l_35.f2;
    int16_t l_175 = 0L;
    const union U4 l_249 = {0x0A703117L};
    struct S0 **l_671 = &l_52;
    int32_t *l_675 = &l_35.f2.f5;
    int16_t l_685 = (-1L);
    struct S2 *l_691 = &l_35;
    struct S2 **l_690 = &l_691;
    struct S2 ***l_689 = &l_690;
    struct S2 ****l_688 = &l_689;
    struct S2 *****l_687 = &l_688;
    int32_t l_711 = 3L;
    int32_t l_712 = 0L;
    (*l_671) = func_27(func_29(l_35, func_36(func_38(func_40((l_43 & func_44((((int64_t)(18446744073709551615UL >= l_35.f3) / (int64_t)func_48(l_52, ((((!l_43) ^ (!func_55(((uint64_t)func_63(l_52, l_35.f1.f0) + (uint64_t)l_35.f2.f4), l_70, l_35.f1.f8, l_70, l_71))) < (-5L)) >= l_175), l_35.f2.f0)) && 0x7EC74853L))), l_249))), l_52, l_52, l_35.f4));
    for (l_35.f2.f7 = 5; (l_35.f2.f7 <= 14); l_35.f2.f7 += 4)
    { /* block id: 464 */
        int32_t *l_674 = &l_35.f3;
        int32_t **l_676 = &l_675;
        int16_t l_710 = 0x03FBL;
        l_675 = l_674;
        /* statement id: 465 */
        assert (l_675 == &l_35.f3);
        (*l_676) = l_674;
        if ((-(uint32_t)((int64_t)((int16_t)(&l_52 != (void*)0) % (int16_t)6UL) + (int64_t)((((**l_676) <= 0xE18858E5L) < (-(uint64_t)0xCAFEA47086EAA916LL)) ^ (*l_675)))))
        { /* block id: 467 */
            float *l_683 = &l_35.f2.f6;
            (*l_675) = (*l_674);
            (*l_676) = l_675;
            (*l_683) = (*l_674);
        }
        else
        { /* block id: 471 */
            float *l_684 = &l_35.f1.f6;
            int32_t l_686 = (-1L);
            int64_t l_709 = 1L;
            (*l_684) = (*l_675);
            (**l_676) = __builtin_popcountl(l_685);
            if ((l_686 > (l_687 != (void*)0)))
            { /* block id: 474 */
                int32_t *l_692 = &l_35.f2.f5;
                (**l_676) = l_686;
                (*l_676) = l_692;
                /* statement id: 476 */
                assert (l_675 == &l_35.f2.f5);
                (*l_676) = l_675;
            }
            else
            { /* block id: 478 */
                uint64_t l_695 = 0xC70E85005E7EA23ELL;
                (*l_684) = (0x5.Ap-1 >= ((float)l_686 + (float)(l_695 <= ((*l_675) > ((float)func_44(l_695) / (float)(l_695 == ((float)((float)((float)(((float)((float)(**l_676) - (float)(+l_695)) + (float)l_686) != l_709) + (float)0xF.E3E2A3p-29) - (float)l_695) / (float)(*l_675))))))));
                (*l_674) = __builtin_ffs(l_710);
            }
            /* facts after branching */
            assert (l_675 == &l_35.f3 || l_675 == &l_35.f2.f5);
            (*l_674) = ((*l_675) == (-1L));
        }
        /* facts after branching */
        assert (l_675 == &l_35.f3 || l_675 == &l_35.f2.f5);
        return l_711;
    }
    (*l_675) = ((*l_675) ^ (*l_675));
    return l_712;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * const  func_27(struct S0 * p_28)
{ /* block id: 458 */
    int32_t *l_670 = (void*)0;
    int32_t **l_669 = &l_670;
    (*l_669) = (void*)0;
    return p_28;
    /* statement id: 460 */
    //assert (func_27_rv == &l_35.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_29(struct S2  p_30, union U4  p_31, struct S0 * p_32, struct S0 * p_33, float  p_34)
{ /* block id: 454 */
    int32_t *l_652 = (void*)0;
    struct S2 ***l_664 = (void*)0;
    struct S2 ****l_663 = &l_664;
    const int32_t l_666 = 0xF0A3F159L;
    int32_t l_668 = (-3L);
    int32_t *l_667 = &l_668;
    l_652 = l_652;
    (*l_667) = func_44((((int64_t)(((int16_t)(((uint32_t)p_30.f1.f4 - (uint32_t)(((uint16_t)0x7B86L / (uint16_t)((uint16_t)(l_663 != &l_664) >> (uint16_t)15)) | p_30.f1.f0)) < p_30.f3) >> (int16_t)p_30.f2.f4) & (((+p_30.f3) | (p_30.f5 > l_666)) & 0xE5972768L)) - (int64_t)p_30.f7.f3) && p_30.f7.f7));
    return p_33;
    /* statement id: 457 */
    //assert (func_29_rv == &l_35.f1);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U4  func_36(struct S0 * p_37)
{ /* block id: 250 */
    int32_t l_346 = 0L;
    int32_t *l_351 = (void*)0;
    int32_t **l_350 = &l_351;
    int32_t *** const l_349 = &l_350;
    int32_t *** const * const l_348 = &l_349;
    int32_t *** const * const *l_347 = &l_348;
    int32_t l_352 = 0L;
    struct S1 l_358 = {0x04A81537L,-0x6.4p-1,5L,18446744073709551615UL,-0x1.Cp+1};
    int32_t *l_388 = &l_346;
    struct S2 l_419 = {11231,{0x7C174908L,0xC.7E50A9p-0,0x1.0F8ACBp-39,65529UL,0UL,-5L,0xC.2531EAp-99,0x57E05E39L,0xC3D9D83AL},{0x06E50A03L,0x4.0A5F40p-49,0x1.3F3736p+13,0UL,0x6C0FL,0x35685CE0L,0x0.A31AFBp-2,0x29236EE4L,0L},0x9271E52DL,0xF69CD38E1897AE2ALL,0xE8383E0AL,16,{2L,0x8.Ap-1,-0x8.Bp+1,1UL,0x3DA9L,0x93017CB9L,-0x9.0p-1,0x818053F5L,-9L}};
    struct S2 *l_418 = &l_419;
    struct S2 **l_417 = &l_418;
    union U4 l_421 = {0xFD6C4037L};
    struct S2 ** const **l_432 = (void*)0;
    struct S1 **l_479 = (void*)0;
    struct S0 *l_488 = (void*)0;
    union U3 *l_618 = (void*)0;
    uint32_t l_637 = 0x4E45C702L;
    if (((((int16_t)0x67CBL % (int16_t)l_346) >= __builtin_ctz((l_347 != (void*)0))) <= l_352))
    { /* block id: 251 */
        int32_t *l_353 = &l_346;
        const struct S1 *l_366 = &l_358;
        struct S0 l_368 = {-9L,0xE.34627Bp+36,0x1.7p+1,7UL,0x964AL,-3L,0x6.Fp+1,0x6907D06CL,0xCBC2341EL};
        struct S0 * const l_367 = &l_368;
        float l_386 = 0x3.16C79Cp-89;
        uint16_t l_387 = 0x4E21L;
        (****l_347) = l_353;
        /* statement id: 252 */
        assert (l_351 == &l_346);
        if (((uint16_t)(((uint16_t)func_55((*****l_347), l_358, ((int16_t)(((-1L) != ((int64_t)((!((int16_t)__builtin_parity((*l_353)) >> (int16_t)3)) == (*l_353)) - (int64_t)(l_366 != &l_358))) | (65532UL == 0UL)) - (int16_t)(**l_350)), l_358, l_367) >> (uint16_t)(*l_351)) && 0xB0755153C9033E01LL) >> (uint16_t)11))
        { /* block id: 253 */
            int32_t l_369 = 0x4468B27AL;
            if (func_44(l_369))
            { /* block id: 254 */
                (**l_350) = (func_48(&l_368, (!((****l_348) > ((uint64_t)9UL / (uint64_t)(*l_353)))), ((p_37 == p_37) > 1UL)) & ((uint16_t)1UL >> (uint16_t)11));
            }
            else
            { /* block id: 256 */
                float *l_375 = &l_368.f6;
                (*l_375) = 0x1.985F0Dp-81;
                (**l_350) = l_369;
            }
        }
        else
        { /* block id: 260 */
            int32_t *l_376 = &l_346;
            (*l_350) = l_376;
        }
        (***l_349) = (((((uint16_t)(****l_348) * (uint16_t)(((****l_348) != (*l_351)) > (*l_353))) && ((+__builtin_ctz(((((uint64_t)((*****l_347) & ((((*l_353) && ((uint32_t)(*l_353) + (uint32_t)0xAA6BB1ACL)) <= (((uint16_t)(*l_353) << (uint16_t)(*l_353)) | (*l_353))) & l_387)) / (uint64_t)(*l_351)) == (*l_353)) | (****l_348)))) | (**l_350))) <= (*l_353)) < (*l_353));
        (****l_347) = l_388;
    }
    else
    { /* block id: 265 */
        union U3 l_391 = {0x217EABC0L};
        union U3 *l_390 = &l_391;
        union U3 ** const l_389 = &l_390;
        float *l_392 = (void*)0;
        float *l_393 = &l_358.f1;
        int32_t * const **l_404 = (void*)0;
        struct S1 * const l_424 = &l_358;
        struct S2 ** const *l_431 = &l_417;
        struct S2 ** const **l_430 = &l_431;
        int32_t *l_473 = &l_419.f3;
        (*l_393) = (l_389 == (void*)0);
        if (l_391.f0)
        { /* block id: 267 */
            int32_t *l_402 = &l_352;
            struct S1 *l_426 = &l_358;
            struct S1 **l_425 = &l_426;
            for (l_346 = 0; (l_346 != (-12)); l_346 -= 3)
            { /* block id: 270 */
                union U4 l_396 = {0x888E49BAL};
                (*l_350) = l_392;
                (*l_350) = l_393;
                /* statement id: 272 */
                assert (l_351 == &l_358.f1);
                return l_396;
                /* statement id: 273 */
                            }
            for (l_352 = 10; (l_352 >= 0); l_352--)
            { /* block id: 277 */
                int32_t *l_401 = &l_352;
                struct S2 **l_420 = &l_418;
                union U3 **l_423 = &l_390;
                union U3 ***l_422 = &l_423;
                for (l_358.f3 = 16; (l_358.f3 > 36); l_358.f3 += 5)
                { /* block id: 280 */
                    (*l_350) = l_401;
                    /* statement id: 281 */
                    assert (l_351 == &l_352);
                }
                /* facts after for loop */
                assert (l_351 == &l_352 || l_351 == 0);
                if (l_391.f0)
                { /* block id: 283 */
                    union U4 l_403 = {0x16B0B04BL};
                    (*l_350) = l_402;
                    /* statement id: 284 */
                    assert (l_351 == &l_352);
                    if (l_391.f0)
                        break;
                    return l_403;
                    /* statement id: 286 */
                                    }
                else
                { /* block id: 287 */
                    (***l_348) = (void*)0;
                    /* statement id: 288 */
                    assert (l_351 == 0);
                }
                /* facts after branching */
                assert (l_351 == 0);
                if (((void*)0 == l_404))
                { /* block id: 290 */
                    uint16_t l_410 = 0x3F81L;
                    (*l_393) = (((float)((float)(+l_410) + (float)((*l_401) == (*l_401))) + (float)((+((0x8.9E84C1p+44 < (*l_402)) <= (!((*l_401) != ((float)((((float)l_391.f0 - (float)((l_410 >= ((l_417 != l_420) != 0x1.6p+1)) > (*l_401))) < (*l_402)) == l_410) / (float)(*l_401)))))) > l_410)) >= 0x8.9p+1);
                    (*l_389) = (void*)0;
                    /* statement id: 292 */
                    assert (l_390 == 0);
                    if ((*l_401))
                        continue;
                }
                else
                { /* block id: 294 */
                    return l_421;
                    /* statement id: 295 */
                                    }
                /* facts after branching */
                assert (l_390 == 0);
                (*l_422) = &l_390;
            }
            /* facts after for loop */
            assert (l_351 == &l_352 || l_351 == 0);
            assert (l_390 == 0 || l_390 == &l_391);
            (*l_350) = (*l_350);
            (*l_425) = l_424;
        }
        else
        { /* block id: 301 */
            int32_t *l_427 = &l_346;
            struct S1 l_472 = {0x1E116E14L,-0x6.Dp-1,0xF26746A294085524LL,0x17722493428787CFLL,0x0.Cp-1};
            (*l_350) = l_427;
            /* statement id: 302 */
            assert (l_351 == &l_346);
            if (((*****l_347) & ((uint16_t)(*l_427) >> (uint16_t)__builtin_ffsl(func_63(p_37, (*l_427))))))
            { /* block id: 303 */
                l_432 = l_430;
                /* statement id: 304 */
                assert (l_432 == &l_431);
            }
            else
            { /* block id: 305 */
                const int16_t l_435 = 0x25CFL;
                const union U4 l_448 = {0UL};
                float *l_452 = (void*)0;
                uint8_t l_463 = 0x5AL;
                uint64_t l_471 = 2UL;
                for (l_419.f1.f5 = 0; (l_419.f1.f5 < 28); ++l_419.f1.f5)
                { /* block id: 308 */
                    float l_446 = 0x7.1894E5p-49;
                    int32_t l_449 = 0L;
                    struct S1 *l_469 = (void*)0;
                }
                (***l_349) = (*l_473);
            }
            /* facts after branching */
            assert (l_432 == 0 || l_432 == &l_431);
            for (l_419.f2.f5 = 29; (l_419.f2.f5 <= 26); --l_419.f2.f5)
            { /* block id: 338 */
                int32_t *l_476 = &l_346;
                struct S1 ***l_480 = &l_479;
                l_473 = l_476;
                /* statement id: 339 */
                assert (l_473 == &l_346);
                for (l_472.f2 = 0; (l_472.f2 < 7); ++l_472.f2)
                { /* block id: 342 */
                    (****l_347) = (**l_349);
                }
                (*l_480) = l_479;
                (****l_347) = l_476;
            }
            /* facts after for loop */
            assert (l_473 == &l_346 || l_473 == &l_419.f3);
        }
        /* facts after branching */
        assert (l_351 == &l_346 || l_351 == &l_352 || l_351 == 0);
        assert (l_390 == 0 || l_390 == &l_391);
        assert (l_432 == 0 || l_432 == &l_431);
        assert (l_473 == &l_346 || l_473 == &l_419.f3);
    }
    /* facts after branching */
    assert (l_351 == &l_346 || l_351 == &l_352 || l_351 == 0);
    //assert (l_432 == 0 || l_432 == dangling);
    if (((int16_t)((*l_388) < ((*l_388) != ((uint64_t)((void*)0 == &l_358) - (uint64_t)((0UL <= (*l_388)) >= 0x270CL)))) << (int16_t)7))
    { /* block id: 350 */
        union U4 l_494 = {0xD8EE51C5L};
        int32_t **l_529 = &l_351;
        struct S2 ** const *l_565 = &l_417;
        uint32_t l_586 = 0UL;
        uint64_t l_601 = 0x161FD81A27D616F2LL;
        float *l_604 = (void*)0;
        int32_t *l_615 = (void*)0;
        union U3 l_632 = {0x009BB854L};
        union U3 *l_631 = &l_632;
        struct S0 *l_635 = &l_419.f1;
        for (l_419.f2.f0 = (-22); (l_419.f2.f0 != 8); l_419.f2.f0 += 3)
        { /* block id: 353 */
            float l_492 = 0xB.4870DFp+45;
            const int32_t l_498 = (-10L);
            struct S1 l_504 = {18446744073709551615UL,-0x2.6p-1,0L,0x723D82754025B283LL,0xA.542B23p-86};
            int32_t l_506 = 1L;
            union U4 l_530 = {4294967295UL};
            int16_t l_551 = (-5L);
            struct S2 * const *l_567 = &l_418;
            struct S2 * const **l_566 = &l_567;
            int64_t l_570 = 0xE0455C175984C273LL;
            int32_t ***l_572 = &l_529;
            int32_t ****l_571 = &l_572;
            uint16_t l_622 = 0x0B10L;
            if ((!(l_488 != (void*)0)))
            { /* block id: 354 */
                uint32_t l_491 = 0xA661446CL;
                int32_t l_493 = 0xF454D577L;
                union U3 l_496 = {0x8C82E678L};
                union U3 *l_495 = &l_496;
                union U3 **l_497 = &l_495;
                struct S1 l_499 = {18446744073709551615UL,-0x1.Ep-1,-8L,0x16A30CD1E362D200LL,0x2.C78A02p+97};
                struct S0 * const l_505 = &l_419.f1;
                for (l_419.f1.f7 = 0; (l_419.f1.f7 < 17); ++l_419.f1.f7)
                { /* block id: 357 */
                    l_493 = l_491;
                    return l_494;
                    /* statement id: 359 */
                                    }
                (*l_497) = l_495;
                l_506 = func_55(l_498, l_499, ((0x39C2L > (__builtin_popcountll(((uint16_t)((l_494.f0 <= l_494.f0) & l_499.f2) << (uint16_t)11)) != 2L)) & (l_494.f0 != l_496.f0)), l_504, l_505);
            }
            else
            { /* block id: 363 */
                int32_t **l_509 = &l_351;
                uint8_t l_512 = 1UL;
                struct S2 ** const *l_523 = (void*)0;
                struct S2 ** const **l_522 = &l_523;
                uint16_t l_550 = 0x0DCAL;
                float l_552 = 0xA.66CDE4p-32;
                if (((uint64_t)((l_509 != l_509) == ((*l_388) < ((((int64_t)(*l_388) % (int64_t)0x7E1576D526EC612ALL) > 4294967295UL) != l_512))) / (uint64_t)(((void*)0 != &l_479) ^ l_504.f3)))
                { /* block id: 364 */
                    int32_t *l_515 = &l_419.f3;
                    const struct S1 * const **l_525 = (void*)0;
                    float *l_554 = &l_419.f2.f2;
                    for (l_512 = 0; (l_512 >= 57); l_512 += 6)
                    { /* block id: 367 */
                        int32_t **l_516 = &l_515;
                        float *l_517 = (void*)0;
                        float *l_518 = (void*)0;
                        float *l_519 = &l_419.f1.f1;
                        (****l_347) = l_515;
                        /* statement id: 368 */
                        assert (l_351 == &l_419.f3);
                    }
                    if ((*l_515))
                    { /* block id: 373 */
                        uint16_t l_524 = 3UL;
                        float *l_526 = &l_358.f1;
                        (*l_526) = ((float)(((void*)0 == l_522) <= l_524) - (float)(((l_388 == l_515) == ((l_525 == &l_479) >= l_504.f0)) > l_512));
                        (*l_515) = ((uint64_t)0x392C9B78254AECEELL - (uint64_t)((**l_348) != l_529));
                        return l_530;
                        /* statement id: 376 */
                                            }
                    else
                    { /* block id: 377 */
                        uint8_t l_545 = 0xF2L;
                        int32_t l_553 = 0x1E04C250L;
                        l_553 = ((((int16_t)((uint16_t)((uint16_t)(((uint16_t)65535UL + (uint16_t)((int64_t)__builtin_ffsl(__builtin_ffsl((0xB036L ^ ((uint64_t)(((((*l_388) != ((func_44((!((+1L) && l_545))) || l_504.f0) >= (((uint64_t)((int16_t)((l_550 != l_545) ^ l_545) << (int16_t)l_494.f0) % (uint64_t)l_545) ^ (*l_515)))) > (*l_515)) ^ l_545) == l_551) % (uint64_t)1UL)))) % (int64_t)0xBB151787E6108BD3LL)) || 0xB8F4L) << (uint16_t)15) % (uint16_t)l_545) + (int16_t)(*l_515)) != 0x6A17L) & (*l_515));
                        (*l_509) = (*l_529);
                        if (l_553)
                            continue;
                    }
                    (*l_515) = l_551;
                    (*l_554) = func_63(func_40((l_512 ^ (*l_515)), l_494), (*l_515));
                }
                else
                { /* block id: 384 */
                    uint8_t l_557 = 0x8BL;
                    for (l_504.f2 = 15; (l_504.f2 <= 14); l_504.f2 -= 8)
                    { /* block id: 387 */
                        l_506 = l_557;
                    }
                    for (l_504.f3 = (-26); (l_504.f3 > 24); l_504.f3++)
                    { /* block id: 392 */
                        float *l_560 = &l_419.f1.f1;
                        (****l_347) = (*l_509);
                        (*l_560) = 0x4.5E8EA5p+99;
                    }
                    if (l_504.f3)
                        continue;
                }
                (*l_350) = (*l_509);
            }
            if ((((0x8B84F665L >= l_504.f2) | ((((uint16_t)65535UL >> (uint16_t)14) || 0x909BC16BL) ^ (l_565 == l_566))) > (l_494.f0 != ((((l_551 <= ((uint32_t)(0x7D10F451CD1CF68ALL && l_570) % (uint32_t)l_504.f2)) & 0x76D85C82L) && l_551) < (*l_388)))))
            { /* block id: 400 */
                (*l_350) = (*l_529);
                l_571 = l_571;
            }
            else
            { /* block id: 403 */
                const uint32_t l_573 = 18446744073709551608UL;
                struct S0 *l_574 = &l_419.f1;
                int32_t l_578 = 0x11CD0CCBL;
                struct S0 **l_636 = &l_574;
                if (l_573)
                { /* block id: 404 */
                    uint16_t l_577 = 0x0421L;
                    l_578 = __builtin_parityl(((l_573 & (func_44(func_63(l_574, ((int16_t)__builtin_clzll((*l_388)) % (int16_t)l_577))) | l_577)) <= 0xECC49CA7L));
                    (***l_571) = (****l_347);
                    return l_494;
                    /* statement id: 407 */
                                    }
                else
                { /* block id: 408 */
                    float *l_580 = &l_492;
                    int32_t l_583 = (-1L);
                    (*l_580) = (l_551 >= (!(*l_388)));
                    (*l_388) = 0x97A3386EL;
                    (*l_388) = ((int16_t)func_44(l_583) << (int16_t)12);
                }
                if (((int16_t)__builtin_bswap32((l_586 == ((((uint16_t)((uint32_t)((uint32_t)((int32_t)(l_578 <= (__builtin_ctzll((((int64_t)l_578 + (int64_t)(((int64_t)((**l_348) == l_529) * (int64_t)(!l_573)) & (~l_573))) || l_573)) != l_601)) / (int32_t)l_578) - (uint32_t)l_586) % (uint32_t)l_573) << (uint16_t)l_551) > l_578) | l_494.f0))) << (int16_t)l_578))
                { /* block id: 413 */
                    uint32_t l_605 = 0x0A314201L;
                    float *l_606 = &l_504.f1;
                    int32_t l_608 = (-1L);
                    (*l_606) = ((float)__builtin_ffsl(((void*)0 != l_604)) + (float)(l_494.f0 > l_605));
                    l_608 = (-(int64_t)(l_565 != &l_567));
                }
                else
                { /* block id: 416 */
                    float l_609 = 0x6.4p+1;
                    int32_t l_613 = 1L;
                    struct S2 ***l_620 = &l_417;
                    if (l_573)
                    { /* block id: 417 */
                        uint16_t l_610 = 0x5C42L;
                        if (l_610)
                            break;
                        (***l_348) = (void*)0;
                        /* statement id: 419 */
                        assert (l_351 == 0);
                        (*l_388) = ((uint16_t)(0UL < __builtin_popcountl(l_610)) - (uint16_t)l_613);
                        if (l_610)
                            break;
                    }
                    else
                    { /* block id: 422 */
                        int32_t *l_614 = &l_419.f2.f5;
                        (*l_388) = (*l_388);
                        (***l_571) = (***l_348);
                        l_615 = l_614;
                        /* statement id: 425 */
                        assert (l_615 == &l_419.f2.f5);
                    }
                    for (l_358.f2 = 0; (l_358.f2 >= 3); ++l_358.f2)
                    { /* block id: 429 */
                        union U3 **l_619 = &l_618;
                        float *l_621 = &l_419.f1.f2;
                        (*l_619) = l_618;
                        l_565 = l_620;
                        (*l_388) = __builtin_bswap32(l_613);
                        (*l_621) = __builtin_ia32_crc32qi(l_613, l_613);
                    }
                    (*l_388) = (l_622 == (((int16_t)(__builtin_clzll(l_613) <= (*l_388)) - (int16_t)((int16_t)((((uint64_t)(l_613 <= (l_578 || ((*l_348) != (void*)0))) % (uint64_t)((int16_t)1L >> (int16_t)(*l_388))) && 6L) != l_613) >> (int16_t)l_573)) & 0xAB73A845L));
                    l_631 = l_631;
                }
                for (l_419.f2.f7 = (-4); (l_419.f2.f7 > 41); ++l_419.f2.f7)
                { /* block id: 440 */
                    return l_530;
                    /* statement id: 441 */
                                    }
                (*l_636) = l_635;
            }
            (*l_388) = 7L;
        }
        /* facts after for loop */
        assert (l_351 == &l_419.f3 || l_351 == &l_346 || l_351 == &l_352 || l_351 == 0);
        assert (l_615 == &l_419.f2.f5 || l_615 == 0);
        (*l_388) = (l_637 <= ((*l_388) | (1UL != 0xE4A64AAAL)));
    }
    else
    { /* block id: 448 */
        uint8_t l_638 = 0x51L;
        l_638 = 0x3A1E3D3DL;
        (*l_388) = (((*l_388) | (l_638 || ((l_638 | ((int16_t)(((18446744073709551615UL | ((int16_t)l_638 % (int16_t)(~(func_63(l_488, l_638) < ((l_488 == l_488) != l_638))))) > 0xA0F6BB18L) < l_638) - (int16_t)9UL)) || l_638))) & l_638);
        (*l_388) = ((l_638 > l_638) == ((uint32_t)l_638 - (uint32_t)((l_638 || ((uint16_t)((uint16_t)((int16_t)(((void*)0 != &p_37) || (*l_388)) >> (int16_t)14) << (uint16_t)3) % (uint16_t)1L)) | (l_638 >= 1L))));
    }
    /* facts after branching */
    assert (l_351 == &l_419.f3 || l_351 == &l_346 || l_351 == &l_352 || l_351 == 0);
    return l_421;
    /* statement id: 453 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_38(struct S0 * p_39)
{ /* block id: 221 */
    int32_t l_302 = 2L;
    int32_t *l_301 = &l_302;
    int32_t **l_303 = &l_301;
    int32_t l_311 = 0L;
    struct S1 l_320 = {8UL,-0x8.Dp-1,6L,0xCEA800BAB020CAECLL,0x9.100C42p+45};
    struct S1 *l_319 = &l_320;
    struct S0 l_343 = {-1L,0x9.2DF4F2p-6,0x1.Fp-1,1UL,65535UL,0xB2EC9E85L,0x0.D3D560p+55,0xF56B1342L,1L};
    struct S0 *l_342 = &l_343;
    (*l_303) = l_301;
    (*l_303) = (*l_303);
    for (l_302 = 22; (l_302 == (-2)); l_302 -= 5)
    { /* block id: 226 */
        uint64_t l_306 = 1UL;
        int32_t *l_317 = &l_311;
        int32_t * const **l_334 = (void*)0;
        int32_t * const *** const l_333 = &l_334;
        if (l_306)
        { /* block id: 227 */
            int32_t *l_307 = &l_302;
            (*l_303) = l_307;
        }
        else
        { /* block id: 229 */
            float l_313 = 0x0.7p+1;
            int32_t *l_318 = &l_311;
            int32_t l_339 = (-3L);
            for (l_306 = (-7); (l_306 <= 4); l_306 += 4)
            { /* block id: 232 */
                int32_t *l_310 = &l_302;
                l_311 = (l_310 != (void*)0);
            }
            if ((__builtin_clzl(l_306) >= l_306))
            { /* block id: 235 */
                float *l_312 = (void*)0;
                union U3 l_315 = {0UL};
                union U3 *l_314 = &l_315;
                float *l_316 = &l_313;
                const struct S1 *l_322 = &l_320;
                const struct S1 **l_321 = &l_322;
                l_313 = 0x1.D2E3B1p+23;
                (*l_316) = ((void*)0 == l_314);
                l_318 = l_317;
                (*l_321) = l_319;
            }
            else
            { /* block id: 240 */
                float *l_323 = &l_320.f1;
                int32_t l_330 = 0xF916B465L;
                (*l_323) = (*l_318);
                (*l_323) = ((float)((__builtin_bswap32((__builtin_ctz(((void*)0 == l_323)) && __builtin_clzll(((((__builtin_ffsl((*l_318)) < (*l_317)) | ((uint64_t)((uint32_t)l_330 - (uint32_t)(((((**l_303) == (l_333 != &l_334)) != l_330) != 0xA7B2L) || (*l_318))) % (uint64_t)(*l_318))) != 0xF7BDL) > 2UL)))) != (*l_318)) == l_330) / (float)l_330);
                l_330 = 0xFEBDA90EL;
            }
            (*l_317) = ((((-3L) || ((int16_t)(*l_318) / (int16_t)l_339)) > (**l_303)) > (func_55((*l_317), (*l_319), ((((((((uint16_t)(*l_318) << (uint16_t)(l_317 == l_301)) != (*l_318)) > (*l_317)) <= (*l_318)) ^ (*l_318)) || 3UL) <= (-5L)), (*l_319), p_39) != (**l_303)));
            if ((*l_318))
                break;
        }
    }
    return p_39;
    /* statement id: 249 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_40(uint8_t  p_41, const union U4  p_42)
{ /* block id: 178 */
    uint8_t l_252 = 8UL;
    struct S0 * const * const l_267 = (void*)0;
    uint8_t l_268 = 0x75L;
    int32_t l_285 = 0x614A238AL;
    int32_t *l_284 = &l_285;
    struct S0 *l_297 = (void*)0;
    if ((((int16_t)(l_252 > p_41) << (int16_t)((uint16_t)((int16_t)(((p_42.f0 ^ 0x61AEE968L) | ((uint16_t)((int32_t)(p_42.f0 || 0x065729E0859B879CLL) - (int32_t)(((int16_t)((uint16_t)((uint16_t)(l_267 != l_267) + (uint16_t)(l_252 > l_268)) << (uint16_t)l_268) - (int16_t)p_42.f0) | 0xE4EAL)) / (uint16_t)l_268)) != p_42.f0) >> (int16_t)l_268) + (uint16_t)p_42.f0)) & 0xB00B315BCC31C596LL))
    { /* block id: 179 */
        int32_t l_274 = 0L;
        const int32_t *l_273 = &l_274;
        int32_t **l_296 = &l_284;
        for (l_252 = 0; (l_252 < 4); l_252 += 1)
        { /* block id: 182 */
            const int32_t *l_294 = &l_274;
            for (p_41 = 0; (p_41 <= 29); ++p_41)
            { /* block id: 185 */
                const int32_t *l_275 = &l_274;
                l_275 = l_273;
                /* statement id: 186 */
                assert (l_275 == &l_285 || l_275 == &l_274);
            }
            for (l_268 = 4; (l_268 == 40); l_268 += 2)
            { /* block id: 190 */
                int32_t *l_290 = (void*)0;
                const int32_t *l_295 = (void*)0;
                for (p_41 = 0; (p_41 <= 51); p_41 += 1)
                { /* block id: 193 */
                    float l_289 = 0x8.03773Bp+30;
                    float *l_288 = &l_289;
                    int32_t **l_291 = &l_284;
                    for (l_274 = 0; (l_274 >= 26); l_274++)
                    { /* block id: 196 */
                        int32_t l_283 = 0x342D46C6L;
                        int32_t *l_282 = &l_283;
                        int32_t **l_286 = (void*)0;
                        int32_t **l_287 = &l_282;
                        (*l_282) = p_41;
                        (*l_287) = l_284;
                        /* statement id: 198 */
                        assert (l_282 == 0 || l_282 == &l_285);
                    }
                    (*l_288) = p_41;
                    (*l_291) = l_290;
                    /* statement id: 201 */
                    assert (l_284 == 0);
                }
                for (l_274 = 0; (l_274 > (-7)); l_274--)
                { /* block id: 205 */
                    l_295 = l_294;
                    /* statement id: 206 */
                    assert (l_295 == &l_274);
                    l_273 = &l_285;
                    /* statement id: 207 */
                    assert (l_273 == &l_285);
                }
                /* facts after for loop */
                assert (l_295 == &l_274 || l_295 == 0);
            }
        }
        /* facts after for loop */
        assert (l_273 == &l_285 || l_273 == &l_274);
        assert (l_284 == 0 || l_284 == &l_285);
        (*l_296) = &l_285;
        /* statement id: 211 */
        assert (l_284 == &l_285);
    }
    else
    { /* block id: 212 */
        return l_297;
        /* statement id: 213 */
        //assert (func_40_rv == 0);
    }
    for (l_268 = 0; (l_268 > 15); ++l_268)
    { /* block id: 217 */
        const int32_t **l_300 = (void*)0;
        l_284 = &l_285;
    }
    return l_297;
    /* statement id: 220 */
    //assert (func_40_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_44(uint32_t  p_45)
{ /* block id: 176 */
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_48(struct S0 * p_49, uint8_t  p_50, uint32_t  p_51)
{ /* block id: 134 */
    uint64_t l_181 = 0x2DA4C94F83D7E182LL;
    int32_t l_183 = 1L;
    int32_t * const l_182 = &l_183;
    struct S1 l_232 = {0x710F9EE0L,0x7.0p-1,1L,0xC00BED4B9811396CLL,-0x8.Fp+1};
    struct S2 ****l_235 = (void*)0;
    struct S0 * const l_238 = (void*)0;
    struct S2 *****l_246 = (void*)0;
    struct S0 l_248 = {0x146068D3L,0xF.84AD03p+97,-0x1.Dp-1,65526UL,0x81ACL,0x702F4191L,0xF.3F4B73p-64,18446744073709551612UL,0L};
    struct S0 *l_247 = &l_248;
    if ((~p_51))
    { /* block id: 135 */
        uint32_t l_186 = 0xCB9365FCL;
        for (p_50 = 0; (p_50 <= 34); ++p_50)
        { /* block id: 138 */
            int32_t l_202 = 0L;
            int16_t l_223 = 0x7C77L;
            struct S2 l_225 = {9216,{-4L,-0x6.9p-1,0xA.FA435Bp+67,0xC2BBL,0x7FB0L,-1L,-0x1.0p-1,0xD552A8F9L,0x9C1DC014L},{0x4EE0FE0DL,0x7.3p+1,0x0.3p+1,0xE9E5L,65529UL,0x2AC07442L,-0x4.2p+1,0x903B4F77L,0xA6C62A8AL},0xFE75ABEDL,0UL,0x267F2E3DL,12,{1L,0x7.61EB48p-89,0x3.7DE5B8p+56,65535UL,0UL,0x84B929F2L,0x3.BC4D60p+22,0xAD6C18F8L,0x03924B46L}};
            struct S2 *l_224 = &l_225;
            float *l_230 = &l_225.f2.f6;
            for (p_51 = 0; (p_51 == 19); p_51++)
            { /* block id: 141 */
                struct S2 *l_193 = (void*)0;
                int32_t ***l_215 = (void*)0;
                int32_t **** const l_214 = &l_215;
                int32_t **** const *l_213 = &l_214;
                float *l_229 = &l_225.f1.f2;
                if (((-1L) & l_181))
                { /* block id: 142 */
                    const int32_t *l_185 = &l_183;
                    const int32_t **l_184 = &l_185;
                    struct S1 l_199 = {0x98A1C93EL,-0x1.3p+1,0x40841C12841510BDLL,18446744073709551612UL,0x0.73E6FFp+23};
                    int16_t l_206 = 1L;
                    (*l_184) = l_182;
                    if (p_51)
                    { /* block id: 144 */
                        return l_186;
                    }
                    else
                    { /* block id: 146 */
                        struct S1 l_196 = {0xDDAE1D84L,0x7.91164Bp+76,1L,18446744073709551609UL,0xE.C30774p-0};
                        struct S0 l_201 = {0x292E38BFL,0xB.8A0A5Ap-44,0xA.400A94p-55,65533UL,65532UL,0xA9CF794CL,0x7.BA9A8Cp+55,0xFA5EDEFCL,0x24070B36L};
                        struct S0 * const l_200 = &l_201;
                        float *l_203 = &l_199.f1;
                        uint32_t l_211 = 18446744073709551606UL;
                        struct S2 **l_226 = &l_193;
                        (*l_203) = (((float)(((p_51 > ((float)((float)(p_50 < (((l_193 != l_193) > ((float)func_55(p_50, l_196, (((*l_182) < ((((4294967290UL | ((uint16_t)p_51 << (uint16_t)p_50)) == p_50) < l_196.f3) || 0x8DE72FA70736F6A9LL)) >= 0xAD850D4A36DFC68BLL), l_199, l_200) + (float)0x1.2p-1)) < l_202)) + (float)0x5.18C2B6p-60) + (float)0xB.7B0658p+58)) == 0xC.9F821Fp-32) != p_51) / (float)(*l_185)) != p_50);
                        (*l_182) = ((uint64_t)(p_50 != l_206) % (uint64_t)((int16_t)(((uint16_t)p_51 >> (uint16_t)l_211) & ((~func_63(p_49, ((void*)0 != l_213))) && ((int16_t)((uint16_t)(~((((uint64_t)(*l_182) / (uint64_t)p_51) | (*l_185)) | p_50)) % (uint16_t)(-1L)) - (int16_t)l_223))) % (int16_t)0xF195L));
                        (*l_203) = p_51;
                        (*l_226) = l_224;
                        /* statement id: 150 */
                        assert (l_193 == &l_225);
                    }
                    /* facts after branching */
                    assert (l_193 == &l_225);
                }
                else
                { /* block id: 152 */
                    for (l_225.f2.f8 = 0; (l_225.f2.f8 > 25); l_225.f2.f8 += 1)
                    { /* block id: 155 */
                        return l_225.f1.f3;
                    }
                }
                /* facts after branching */
                assert (l_193 == 0 || l_193 == &l_225);
                (*l_229) = ((void*)0 == (*l_213));
            }
            (*l_230) = l_225.f7.f4;
        }
    }
    else
    { /* block id: 163 */
        int32_t l_231 = 0L;
        int32_t *l_245 = &l_183;
        int32_t **l_244 = &l_245;
        (*l_182) = func_55(__builtin_ctzll(l_231), l_232, (((int16_t)0x937CL >> (int16_t)(((void*)0 == l_235) || (p_51 | ((int64_t)((void*)0 == &l_231) % (int64_t)p_51)))) & 0xAC1276B3L), l_232, l_238);
        for (l_231 = 15; (l_231 != 5); l_231 -= 2)
        { /* block id: 167 */
            return l_231;
        }
        (*l_182) = ((uint16_t)(~0xDF00L) / (uint16_t)l_231);
        (*l_244) = &l_183;
    }
    l_235 = l_235;
    l_247 = p_49;
    /* statement id: 174 */
    //assert (l_247 == &l_35.f1 || l_247 == &l_368 || l_247 == &l_419.f1);
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_55(const uint64_t  p_56, struct S1  p_57, uint32_t  p_58, struct S1  p_59, struct S0 * const  p_60)
{ /* block id: 41 */
    int32_t l_73 = (-1L);
    int32_t *l_72 = &l_73;
    int32_t l_84 = 0x4DA8BF39L;
    union U3 l_99 = {0UL};
    union U3 *l_98 = &l_99;
    uint64_t l_115 = 0UL;
    struct S0 *l_148 = (void*)0;
    const int32_t **l_165 = (void*)0;
    const int32_t ** const *l_164 = &l_165;
    const int32_t ** const **l_163 = &l_164;
    struct S2 **l_173 = (void*)0;
    struct S2 ** const *l_172 = &l_173;
    struct S2 ** const **l_171 = &l_172;
    uint32_t l_174 = 0x290440BCL;
    (*l_72) = p_59.f2;
    l_72 = &l_73;
    for (p_58 = 8; (p_58 <= 29); ++p_58)
    { /* block id: 46 */
        struct S0 l_88 = {-1L,0x0.Dp-1,-0x3.Cp+1,0xEEE8L,0x1B3CL,0xCD66DA80L,0x4.DD30C4p-1,8UL,0L};
        struct S0 *l_87 = &l_88;
        int32_t * const l_94 = &l_88.f5;
        struct S1 *l_143 = (void*)0;
        int32_t *l_145 = &l_88.f5;
        union U3 *l_159 = &l_99;
    }
    (*l_171) = (void*)0;
    /* statement id: 132 */
    assert (l_172 == 0);
    return l_174;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_63(struct S0 * p_64, int16_t  p_65)
{ /* block id: 37 */
    uint8_t l_66 = 246UL;
    float l_68 = 0xA.E040EEp-66;
    float *l_67 = &l_68;
    int32_t *l_69 = (void*)0;
    (*l_67) = l_66;
    l_69 = l_67;
    /* statement id: 39 */
    assert (l_69 == &l_68);
    return p_65;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 181
   depth: 1, occurrence: 8
   depth: 2, occurrence: 1
XXX total union variables: 7

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 29
breakdown:
   indirect level: 0, occurrence: 8
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 18

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 242
   depth: 2, occurrence: 44
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 12, occurrence: 1
   depth: 14, occurrence: 4
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 202

XXX times a variable address is taken: 170
XXX times a pointer is dereferenced on RHS: 127
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 6
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 125
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 5
   depth: 3, occurrence: 8
   depth: 4, occurrence: 6
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 469

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 332
   level: 2, occurrence: 70
   level: 3, occurrence: 50
   level: 4, occurrence: 61
   level: 5, occurrence: 23
XXX number of pointers point to pointers: 89
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 42
XXX percent of pointers has null in alias set: 27.7
XXX average alias set size: 1.21

XXX times a non-volatile is read: 806
XXX times a non-volatile is write: 360
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 201
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 25
   depth: 2, occurrence: 29
   depth: 3, occurrence: 46
   depth: 4, occurrence: 40
   depth: 5, occurrence: 29

XXX percentage a fresh-made variable is used: 24.1
XXX percentage an existing variable is used: 75.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

