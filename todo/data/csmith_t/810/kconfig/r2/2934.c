/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1753497216
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static uint8_t  func_7(int8_t  p_8, int8_t  p_9);
static int32_t  func_10(uint8_t  p_11, uint16_t  p_12);
static int32_t * func_14(uint32_t  p_15, int32_t * p_16, uint32_t  p_17, int32_t  p_18, int32_t * p_19);
inline static uint16_t  func_21(int32_t * p_22, int32_t * p_23, int32_t * const  p_24, int32_t * p_25);
static int32_t * func_26(int32_t  p_27, int8_t  p_28, int32_t * p_29, int32_t * p_30, uint32_t  p_31);
inline static int32_t * func_35(uint32_t  p_36, uint32_t  p_37, int32_t * p_38);
static uint16_t  func_39(int32_t * p_40);
static int32_t * func_41(uint32_t  p_42, int8_t  p_43, int16_t  p_44, int32_t  p_45, const int32_t * p_46);
inline static const uint8_t  func_47(int32_t * p_48, int32_t  p_49, int16_t  p_50);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_6 = 0xE1265AB3;
    int16_t l_423 = 1;
    int32_t l_425 = (-9);
    int32_t *l_424 = &l_425;
    int32_t l_436 = 0xE84D2678;
    (*l_424) = (safe_rshift_func_uint16_t_u_s(((safe_sub_func_uint8_t_u_u(l_6, func_7(l_6, l_6))) >= (l_423 >= (l_424 == &l_425))), 2));
    (*l_424) = (((0x00C4 && (0xA4 & (!(((safe_mod_func_int32_t_s_s(1, (*l_424))) & (*l_424)) < (*l_424))))) ^ (safe_add_func_int16_t_s_s(((((safe_add_func_int8_t_s_s((*l_424), (!((safe_div_func_uint32_t_u_u(((*l_424) >= (*l_424)), 4294967294U)) | 0x130411F7)))) > 0x50F9E100) >= 0U) | (*l_424)), (*l_424)))) < 0x3902DA11);
    return l_436;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_7(int8_t  p_8, int8_t  p_9)
{ /* block id: 1 */
    int32_t l_13 = 0x9EDBDA7F;
    int32_t *l_421 = &l_13;
    (*l_421) = func_10(p_8, l_13);
    (*l_421) = p_8;
    (*l_421) = (!p_8);
    (*l_421) = 1;
    return p_8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_10(uint8_t  p_11, uint16_t  p_12)
{ /* block id: 2 */
    int8_t l_34 = 0x83;
    int32_t l_52 = (-2);
    int32_t *l_51 = &l_52;
    int32_t *l_58 = &l_52;
    int32_t **l_396 = &l_58;
    uint32_t l_402 = 0x66131344;
    int32_t ****l_414 = (void*)0;
    int32_t *****l_413 = &l_414;
    int32_t l_415 = 0;
    int8_t l_420 = 0x59;
    (*l_396) = func_14((~func_21(func_26((safe_sub_func_uint16_t_u_u(0x4F23, l_34)), l_34, func_35(p_12, (func_39(func_41((func_47(l_51, (!((safe_sub_func_uint16_t_u_u((((safe_lshift_func_uint8_t_u_s(((((l_58 != (void*)0) >= (safe_div_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u((((safe_rshift_func_uint8_t_u_u((safe_unary_minus_func_int32_t_s(0)), p_11)) >= p_12) != (*l_58)), (*l_58))), (*l_51)))) | 0xC653) <= p_12), p_12)) && 0x0595) != p_11), (*l_58))) & (*l_58))), (*l_51)) ^ p_11), p_11, (*l_51), (*l_51), &l_52)) < p_11), &l_52), &l_52, (*l_58)), l_51, l_58, l_58)), l_58, p_12, p_11, l_51);
    /* statement id: 129 */
    assert (l_58 == 0 || l_58 == &l_52);
    (*l_396) = func_35((((~(((safe_sub_func_uint32_t_u_u((safe_sub_func_int16_t_s_s(0x18DB, (l_402 <= (*l_51)))), (safe_mod_func_int8_t_s_s(p_12, (safe_add_func_uint32_t_u_u((p_12 && ((safe_rshift_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_u((*l_51), 9)) != p_12), (safe_sub_func_uint16_t_u_u((0xFB92A9F2 > (((((l_413 != &l_414) > p_11) || 3) || p_12) >= p_11)), (*l_51))))) ^ p_11)), 0U)))))) < p_11) < p_11)) ^ (*l_51)) & 1), l_415, (*l_396));
    /* statement id: 130 */
    assert (l_58 == 0);
    (*l_51) = (safe_lshift_func_int8_t_s_u((p_11 || (((*l_51) != 0x0D) <= 0x9E)), l_420));
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_14(uint32_t  p_15, int32_t * p_16, uint32_t  p_17, int32_t  p_18, int32_t * p_19)
{ /* block id: 89 */
    int32_t ** const l_307 = (void*)0;
    int32_t ** const *l_306 = &l_307;
    const int16_t l_316 = 0x6FA7;
    int32_t l_391 = (-1);
    int32_t *l_390 = &l_391;
    int32_t **l_389 = &l_390;
    int32_t ***l_388 = &l_389;
    int32_t ****l_387 = &l_388;
    int32_t *****l_386 = &l_387;
    int32_t *l_395 = &l_391;
    if (((safe_sub_func_uint8_t_u_u((safe_div_func_int32_t_s_s(((p_18 >= (((safe_lshift_func_int16_t_s_s((((l_306 == &l_307) <= 255U) || ((((p_15 <= (((p_17 != (safe_rshift_func_uint16_t_u_u((p_17 >= (safe_add_func_int32_t_s_s((*p_19), (safe_div_func_uint32_t_u_u((safe_add_func_int8_t_s_s((p_18 >= p_18), 0x6D)), p_15))))), 11))) | l_316) ^ (*p_16))) & p_15) ^ p_17) | p_18)), 6)) & p_17) & 0x6112)) || 0x9042488E), 0x45B81C32)), p_17)) >= p_15))
    { /* block id: 90 */
        int32_t l_320 = 1;
        uint8_t l_346 = 0x02;
        int32_t **l_373 = (void*)0;
        int32_t ***l_372 = &l_373;
        int32_t ****l_371 = &l_372;
        int32_t ***** const l_370 = &l_371;
        for (p_15 = 0; (p_15 < 4); ++p_15)
        { /* block id: 93 */
            int16_t l_319 = 0x1787;
            int32_t l_323 = 1;
            int32_t *l_322 = &l_323;
            int32_t **l_321 = &l_322;
            const int32_t l_328 = 0xAB1E3EF1;
            (*l_321) = func_41(l_319, l_320, p_15, ((&p_19 != l_321) ^ (safe_lshift_func_uint8_t_u_s((safe_div_func_uint16_t_u_u(0x481D, l_320)), l_320))), p_19);
            /* statement id: 94 */
            assert (l_322 == 0);
            if (l_328)
                break;
            for (l_323 = 0; (l_323 < (-22)); l_323 = safe_sub_func_int32_t_s_s(l_323, 7))
            { /* block id: 98 */
                (*l_321) = (*l_321);
            }
            if (((&l_306 != (void*)0) < (p_15 < p_15)))
            { /* block id: 101 */
                int32_t l_350 = 0x5E5F06EB;
                int32_t ** const *l_355 = (void*)0;
                for (l_323 = (-18); (l_323 == 15); l_323 = safe_add_func_int8_t_s_s(l_323, 1))
                { /* block id: 104 */
                    int16_t l_337 = 0xDB94;
                    int32_t **l_356 = &l_322;
                    int32_t ****l_375 = &l_372;
                    if (l_320)
                        break;
                    if ((safe_add_func_int16_t_s_s(((safe_div_func_uint16_t_u_u((0U <= l_337), p_15)) | ((safe_div_func_uint8_t_u_u((safe_rshift_func_int8_t_s_u((safe_div_func_int16_t_s_s(0x6465, (safe_div_func_uint16_t_u_u(l_320, l_337)))), l_320)), ((l_346 || (safe_unary_minus_func_uint32_t_u(((safe_mod_func_int16_t_s_s((l_320 <= p_17), l_350)) == p_17)))) && l_346))) && (-9))), l_320)))
                    { /* block id: 106 */
                        int32_t l_374 = (-9);
                        (*p_19) = ((safe_rshift_func_int16_t_s_u(((safe_sub_func_uint16_t_u_u(((void*)0 == l_355), ((&p_19 == l_356) ^ (safe_sub_func_int32_t_s_s(((&p_19 != (void*)0) == ((safe_mod_func_int8_t_s_s(((safe_add_func_int32_t_s_s((~((p_15 ^ (safe_lshift_func_uint16_t_u_s((safe_add_func_int32_t_s_s((safe_mod_func_int16_t_s_s(0x7FF1, ((l_370 != (void*)0) | p_15))), p_18)), 15))) <= p_15)), p_15)) != p_15), 0x11)) >= p_15)), 0x8BF16BD3))))) ^ l_374), 15)) > p_18);
                    }
                    else
                    { /* block id: 108 */
                        (*l_321) = p_19;
                        /* statement id: 109 */
                        //assert (l_322 == &l_52);
                        if ((*p_19))
                            break;
                    }
                    (*l_375) = &l_307;
                    /* statement id: 112 */
                    assert (l_372 == &l_307);
                }
                /* facts after for loop */
                //assert (l_322 == &l_52 || l_322 == 0);
            }
            else
            { /* block id: 114 */
                p_16 = (void*)0;
                /* statement id: 115 */
                assert (p_16 == 0);
            }
            /* facts after branching */
            //assert (l_322 == &l_52 || l_322 == 0);
        }
        /* facts after for loop */
        //assert (p_16 == 0 || p_16 == &l_52);
        assert (l_372 == &l_307 || l_372 == &l_373);
    }
    else
    { /* block id: 118 */
        uint32_t l_378 = 0xD63B712D;
        uint32_t l_384 = 0U;
        int32_t l_385 = 0;
        l_385 = ((((safe_add_func_int32_t_s_s((*p_16), 0x6152E5FB)) <= ((0U < (((0 <= l_378) | p_17) & 0x4104)) < (safe_sub_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u((0 != (safe_unary_minus_func_int8_t_s(p_18))), p_15)), p_15)))) > l_384) ^ 0x78);
        l_386 = l_386;
    }
    /* facts after branching */
    //assert (p_16 == 0 || p_16 == &l_52);
    for (p_15 = 0; (p_15 != 32); p_15 = safe_add_func_int8_t_s_s(p_15, 8))
    { /* block id: 124 */
        uint16_t l_394 = 0x5A89;
        (*p_19) = l_394;
    }
    (****l_386) = l_395;
    return p_16;
    /* statement id: 128 */
    //assert (func_14_rv == 0 || func_14_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_21(int32_t * p_22, int32_t * p_23, int32_t * const  p_24, int32_t * p_25)
{ /* block id: 87 */
    uint32_t l_299 = 0xCD8EA7C6;
    return l_299;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_26(int32_t  p_27, int8_t  p_28, int32_t * p_29, int32_t * p_30, uint32_t  p_31)
{ /* block id: 21 */
    int32_t l_101 = 0x6C6A45D3;
    int32_t *l_100 = &l_101;
    int32_t **l_99 = &l_100;
    int32_t ***l_140 = &l_99;
    int32_t ****l_139 = &l_140;
    uint8_t l_279 = 0xF8;
    if (((1U > ((void*)0 != l_99)) != (!((safe_rshift_func_uint16_t_u_s((safe_mod_func_uint8_t_u_u((*l_100), (safe_lshift_func_int8_t_s_s((*l_100), (safe_mod_func_uint16_t_u_u((1 | (safe_sub_func_uint16_t_u_u(((((safe_mod_func_int32_t_s_s((*p_30), (safe_sub_func_int32_t_s_s(((safe_mod_func_int32_t_s_s((safe_unary_minus_func_int32_t_s(((*l_99) == (void*)0))), 0x808108B9)) == p_28), (**l_99))))) >= 0xCADD) && (**l_99)) == (**l_99)), 0xC771))), p_28)))))), (**l_99))) > 0xD29F))))
    { /* block id: 22 */
        int16_t l_127 = 0x01E4;
        int32_t *l_143 = (void*)0;
        const uint32_t l_155 = 0x65D98765;
        int32_t ****l_158 = &l_140;
        uint8_t l_159 = 0x22;
        int32_t *****l_178 = (void*)0;
        int32_t l_277 = (-7);
        l_143 = func_35((((safe_add_func_int8_t_s_s(((!(safe_mod_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u((l_127 >= ((1U >= p_31) && (safe_mod_func_uint32_t_u_u((safe_add_func_uint16_t_u_u((l_127 && (safe_div_func_uint16_t_u_u(0U, (safe_mod_func_uint8_t_u_u((~(safe_sub_func_int32_t_s_s(((void*)0 == l_139), (((((safe_mod_func_int8_t_s_s((***l_140), (****l_139))) && 0x58) && (****l_139)) | 9U) ^ p_28)))), l_127))))), 0xB4EC)), (*p_30))))), (-2))) & (****l_139)), l_127))) ^ p_27), l_127)) ^ 0U) >= 65529U), p_31, p_29);
        if (p_31)
            goto lbl_160;
        if ((4 > (safe_mod_func_int8_t_s_s(((safe_div_func_uint32_t_u_u((safe_unary_minus_func_int8_t_s((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_uint16_t_u_u((0xC96F != ((***l_140) ^ ((((*p_30) != (safe_mod_func_int16_t_s_s(l_155, ((safe_add_func_int16_t_s_s(((l_158 != (void*)0) & ((void*)0 == (*l_158))), p_31)) && 0xC9157731)))) > 65535U) | p_27))), 3)) == 2), 3)))), 4294967288U)) | l_159), 0xA9))))
        { /* block id: 24 */
lbl_160:
            (*p_30) = 0;
            (***l_140) = 0x4AA9F20B;
        }
        else
        { /* block id: 28 */
            uint32_t l_169 = 4294967288U;
            int32_t *l_172 = &l_101;
            int32_t *****l_220 = &l_158;
            for (l_101 = 0; (l_101 == (-6)); l_101--)
            { /* block id: 31 */
                uint16_t l_170 = 65528U;
                int32_t *l_171 = &l_101;
                (*p_30) = (*p_30);
                (*p_30) = ((****l_158) && (safe_div_func_uint8_t_u_u(p_28, (safe_div_func_int16_t_s_s((0x1FBA64A4 ^ ((((safe_sub_func_int16_t_s_s((l_169 || l_169), ((p_31 ^ (***l_140)) == ((((0xFEB662F6 ^ ((****l_158) ^ p_27)) | (-1)) != 0x4661) != (-3))))) == p_31) > l_170) <= 0x44EF14F5)), l_169)))));
                return p_29;
                /* statement id: 34 */
                //assert (func_26_rv == 0);
            }
            for (p_27 = 0; (p_27 >= 3); p_27 = safe_add_func_uint8_t_u_u(p_27, 1))
            { /* block id: 38 */
                uint16_t l_218 = 65530U;
                for (p_31 = 3; (p_31 >= 55); ++p_31)
                { /* block id: 41 */
                    int32_t * const *l_185 = (void*)0;
                    int32_t * const **l_184 = &l_185;
                    int32_t l_217 = 0x08D08F60;
                    if ((*p_30))
                    { /* block id: 42 */
                        return p_29;
                        /* statement id: 43 */
                        //assert (func_26_rv == 0);
                    }
                    else
                    { /* block id: 44 */
                        int32_t *****l_177 = &l_158;
                        l_178 = l_177;
                        /* statement id: 45 */
                        assert (l_178 == &l_158);
                        if (l_127)
                            goto lbl_221;
                        (***l_158) = l_172;
                        /* statement id: 46 */
                        assert (l_100 == &l_101);
                        (***l_139) = (***l_158);
                    }
                    /* facts after branching */
                    assert (l_100 == &l_101);
                    assert (l_178 == &l_158);
                    for (l_169 = 0; (l_169 < 19); l_169 = safe_add_func_int16_t_s_s(l_169, 7))
                    { /* block id: 51 */
                        int32_t **l_181 = &l_100;
                        int32_t *l_219 = &l_217;
                        (*p_30) = (p_31 || (((void*)0 != l_181) || (((safe_rshift_func_int16_t_s_u((*l_172), p_31)) > (((void*)0 != l_184) & (safe_lshift_func_int16_t_s_s(7, (safe_add_func_int32_t_s_s((((((safe_mod_func_int8_t_s_s(((*l_172) & (*l_100)), p_28)) <= p_31) && (**l_181)) == p_28) > 0x59D8DA1D), 0x6160A43F)))))) != p_28)));
                        l_219 = func_41((**l_181), p_31, (safe_mod_func_uint8_t_u_u((safe_add_func_int32_t_s_s(((safe_mod_func_uint16_t_u_u((safe_mod_func_int32_t_s_s(((safe_lshift_func_uint8_t_u_s(0x7A, 4)) ^ (safe_div_func_int16_t_s_s(((safe_div_func_uint16_t_u_u((((*l_172) == (safe_lshift_func_uint8_t_u_s((safe_add_func_int32_t_s_s((*p_30), (((safe_mod_func_uint32_t_u_u(p_28, (*****l_178))) <= (safe_lshift_func_uint8_t_u_u(p_27, (((safe_div_func_int8_t_s_s((~(0U && (*l_172))), (**l_181))) >= 0x91) || p_31)))) | p_31))), l_217))) & 0x3BFF2BCA), p_31)) || l_218), (*****l_178)))), (*p_30))), p_27)) > p_27), 1U)), (****l_158))), p_27, (**l_140));
                        /* statement id: 53 */
                        assert (l_219 == 0);
                    }
                    (***l_158) = func_35((****l_158), l_218, (****l_178));
                    /* statement id: 55 */
                    assert (l_100 == 0);
                }
                /* facts after for loop */
                assert (l_100 == 0 || l_100 == &l_101);
                assert (l_178 == &l_158 || l_178 == 0);
                return p_30;
                /* statement id: 57 */
                //assert (func_26_rv == &l_52);
            }
lbl_221:
            (*l_220) = &l_140;
            (**l_140) = (**l_140);
        }
        /* facts after branching */
        assert (l_100 == 0 || l_100 == &l_101);
        assert (l_178 == &l_158 || l_178 == 0);
        if (((safe_lshift_func_int8_t_s_u(p_27, 0)) ^ (p_31 && p_28)))
        { /* block id: 63 */
            int32_t ****l_246 = &l_140;
            (**l_140) = func_41((((safe_sub_func_uint32_t_u_u((safe_mod_func_uint8_t_u_u((safe_lshift_func_int8_t_s_s((((((safe_div_func_int8_t_s_s(0xF2, p_27)) ^ ((*p_30) >= ((&l_139 != (void*)0) && (0x560B < (safe_rshift_func_uint16_t_u_s((7U | ((1U != (0xC08D != 1U)) == p_27)), 1)))))) <= p_28) < p_27) && p_27), p_28)), p_31)), 0xB0E1CB3E)) ^ p_28) > 5), p_28, p_27, p_31, p_30);
            /* statement id: 64 */
            assert (l_100 == 0);
            for (l_159 = (-20); (l_159 <= 16); l_159 = safe_add_func_int16_t_s_s(l_159, 3))
            { /* block id: 67 */
                int32_t ****l_247 = &l_140;
                (*p_30) = (safe_mod_func_uint32_t_u_u(((safe_mod_func_uint8_t_u_u(((safe_sub_func_uint8_t_u_u(p_31, (safe_rshift_func_int8_t_s_u(p_27, p_28)))) < ((((safe_lshift_func_uint16_t_u_u((l_246 == l_247), (safe_rshift_func_int16_t_s_s((safe_add_func_uint8_t_u_u((safe_add_func_int8_t_s_s((safe_mod_func_uint8_t_u_u(p_28, (0xF621 ^ (safe_lshift_func_int16_t_s_u(3, ((!((&l_139 == &l_158) | p_28)) == p_27)))))), p_27)), p_31)), 12)))) || (-5)) || (*p_30)) > (*p_30))), p_28)) < p_27), p_31));
                if ((*p_30))
                    continue;
            }
            l_246 = &l_140;
            (*p_30) = (*p_30);
        }
        else
        { /* block id: 73 */
            uint32_t l_276 = 0x6FC9603B;
            int32_t l_278 = 0xC927E87A;
            (**l_140) = (*l_99);
            (*l_158) = (*l_139);
            l_278 = ((-3) && (safe_div_func_uint8_t_u_u((&l_140 != &l_140), (safe_add_func_uint32_t_u_u((((safe_div_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(0U, ((safe_sub_func_uint8_t_u_u((safe_mod_func_uint8_t_u_u(((safe_add_func_int8_t_s_s(((safe_unary_minus_func_uint8_t_u((safe_mod_func_uint32_t_u_u((l_276 != (l_276 >= (&l_140 != (void*)0))), (l_276 & l_276))))) != p_28), p_28)) <= p_28), l_277)), 0xBC)) < l_276))) == l_276), p_27)) ^ p_31) != p_31), (*p_30))))));
        }
        (**l_140) = func_35(l_279, (safe_sub_func_int16_t_s_s(p_31, ((safe_lshift_func_uint8_t_u_s((safe_div_func_int16_t_s_s(((safe_rshift_func_uint8_t_u_s(((safe_lshift_func_int8_t_s_u((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint8_t_u_u((((4294967287U || (safe_add_func_uint8_t_u_u(0x8E, (l_158 == l_158)))) & ((void*)0 != (**l_140))) != ((-7) && (*p_30))), p_31)), p_27)), p_31)) && p_31), 4)) | p_31), 1U)), p_31)) ^ 246U))), (***l_139));
        /* statement id: 78 */
        assert (l_100 == 0);
    }
    else
    { /* block id: 79 */
        for (p_28 = 0; (p_28 != 14); ++p_28)
        { /* block id: 82 */
            int32_t *l_298 = &l_101;
            return p_30;
            /* statement id: 83 */
            //assert (func_26_rv == &l_52);
        }
    }
    /* facts after branching */
    assert (l_100 == &l_101 || l_100 == 0);
    return p_30;
    /* statement id: 86 */
    //assert (func_26_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_35(uint32_t  p_36, uint32_t  p_37, int32_t * p_38)
{ /* block id: 17 */
    int32_t *l_95 = (void*)0;
    const int32_t l_98 = 0x221BDB03;
    const int32_t *l_97 = &l_98;
    const int32_t **l_96 = &l_97;
    (*l_96) = l_95;
    /* statement id: 18 */
    assert (l_97 == 0);
    (*l_96) = (*l_96);
    return l_95;
    /* statement id: 20 */
    //assert (func_35_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_39(int32_t * p_40)
{ /* block id: 11 */
    int32_t l_86 = 1;
    int32_t *l_93 = &l_86;
    uint32_t l_94 = 1U;
    (*l_93) = (safe_sub_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_s(l_86, 15)) && l_86), (((0x795B == l_86) < ((safe_rshift_func_int8_t_s_s((&l_86 == (void*)0), 7)) && ((safe_add_func_int16_t_s_s(0x3FE8, l_86)) <= l_86))) > l_86)));
    p_40 = (void*)0;
    (*l_93) = (*l_93);
    (*l_93) = (*l_93);
    return l_94;
}


/* ------------------------------------------ */
/* 
 * reads : l_52
 * writes:
 */
static int32_t * func_41(uint32_t  p_42, int8_t  p_43, int16_t  p_44, int32_t  p_45, const int32_t * p_46)
{ /* block id: 6 */
    int32_t l_73 = 1;
    int32_t *l_72 = &l_73;
    int32_t **l_71 = &l_72;
    int32_t ***l_70 = &l_71;
    const int32_t *l_77 = &l_73;
    const int32_t **l_76 = &l_77;
    const int32_t ***l_75 = &l_76;
    const int32_t ****l_74 = &l_75;
    int32_t *l_80 = &l_73;
    int32_t *l_81 = (void*)0;
    (*l_74) = l_70;
    /* statement id: 7 */
    assert (l_75 == &l_71);
    (**l_71) = (*p_46);
    (***l_70) = (((p_42 > ((*l_74) == (*l_74))) ^ (((*l_74) == (void*)0) < (safe_div_func_int16_t_s_s((((p_45 | 0U) & 1U) != (0xD9 || 0U)), p_43)))) || 0xE5);
    return l_81;
    /* statement id: 10 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint8_t  func_47(int32_t * p_48, int32_t  p_49, int16_t  p_50)
{ /* block id: 3 */
    int32_t l_67 = (-10);
    int32_t *l_66 = &l_67;
    int32_t **l_68 = (void*)0;
    int32_t **l_69 = &l_66;
    (*l_69) = l_66;
    return p_49;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 64
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 2
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 25, occurrence: 3
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 69

XXX times a variable address is taken: 68
XXX times a pointer is dereferenced on RHS: 85
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 10
   depth: 3, occurrence: 5
   depth: 4, occurrence: 8
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 41
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 5
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 342

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 128
   level: 2, occurrence: 37
   level: 3, occurrence: 31
   level: 4, occurrence: 34
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 37
XXX number of pointers point to scalars: 32
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 33.3
XXX average alias set size: 1.17

XXX times a non-volatile is read: 488
XXX times a non-volatile is write: 119
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 0

XXX stmts: 87
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 10
   depth: 2, occurrence: 18
   depth: 3, occurrence: 10
   depth: 4, occurrence: 6
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 12.3
XXX percentage an existing variable is used: 87.7
********************* end of statistics **********************/

