/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2914295080
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int32_t  f0;
   int32_t  f1;
   uint64_t  f2;
   signed f3 : 22;
   uint8_t  f4;
   int64_t  f5;
   const uint8_t  f6;
   uint32_t  f7;
   int64_t  f8;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   unsigned f0 : 4;
   signed f1 : 16;
   struct S0  f2;
   unsigned f3 : 15;
   unsigned f4 : 11;
   unsigned f5 : 22;
   unsigned f6 : 26;
   unsigned f7 : 8;
};
#pragma pack(pop)

struct S2 {
   const signed f0 : 27;
   struct S0  f1;
   signed f2 : 31;
   const unsigned f3 : 2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_29(void);
inline static float  func_35(uint32_t  p_36, struct S0  p_37, uint64_t  p_38, int16_t  p_39, struct S1  p_40);
inline static int32_t  func_48(int16_t  p_49, int16_t  p_50, int16_t  p_51, int16_t  p_52, int64_t  p_53);
static int16_t  func_56(uint16_t  p_57);
static const int16_t  func_85(int32_t ** p_86, int32_t  p_87, uint64_t  p_88, uint32_t  p_89, int32_t  p_90);
static int32_t ** func_91(float  p_92, const uint8_t  p_93);
static int32_t * func_101(int32_t  p_102, uint32_t  p_103);
static int32_t * func_109(const uint16_t  p_110, uint8_t  p_111);
static uint16_t  func_118(int64_t  p_119, float ** p_120);
inline static float ** func_124(int32_t  p_125, int32_t * p_126, float * const ** p_127, const uint32_t  p_128);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_29(void)
{ /* block id: 36 */
    const uint32_t l_34 = 0UL;
    struct S0 l_41 = {1L,1L,0x2B3395CC9E520C3DLL,-1816,0x89L,-2L,0x29L,0xAD982FC9L,-3L};
    struct S1 l_412 = {0,80,{0xD513D345L,0xF8A4F2D4L,1UL,-1556,251UL,0x38994FFB7BE2BC12LL,0x71L,18446744073709551614UL,0L},73,34,797,1375,8};
    int64_t l_431 = 3L;
    float l_433 = 0x1.34FC2Dp-48;
    float *l_432 = &l_433;
    const float *l_439 = &l_433;
    const float **l_438 = &l_439;
    const float *** const l_437 = &l_438;
    int32_t *l_469 = (void*)0;
    int32_t **l_468 = &l_469;
    struct S2 l_489 = {1258,{7L,-1L,0xF53D4998C55F51B6LL,13,0x35L,0L,0x73L,0xDD5C3C14L,6L},10405,0};
    struct S2 * const l_488 = &l_489;
    struct S2 * const *l_487 = &l_488;
    uint8_t l_505 = 0UL;
    struct S0 * const l_525 = &l_412.f2;
    struct S0 * const *l_524 = &l_525;
    struct S0 * const **l_523 = &l_524;
    int32_t l_539 = (-1L);
    const float * const **l_564 = (void*)0;
    const float * const ***l_563 = &l_564;
    const float * const ****l_562 = &l_563;
    struct S0 *l_581 = &l_41;
    uint64_t l_599 = 0UL;
    int16_t l_612 = (-5L);
    struct S1 *l_629 = (void*)0;
    struct S1 **l_628 = &l_629;
    float *** const **l_635 = (void*)0;
    int16_t l_669 = 0x6EC1L;
    (*l_432) = ((float)((float)(0xC.98963Ep+79 >= l_34) / (float)(((func_35(l_34, l_41, ((int16_t)((((((1L != ((int16_t)((uint32_t)l_41.f5 + (uint32_t)l_41.f2) << (int16_t)4)) > ((__builtin_ia32_crc32qi(((func_48(l_41.f3, (((int16_t)func_56(l_41.f8) >> (int16_t)13) > 1UL), l_41.f5, l_41.f3, l_41.f6) <= l_41.f3) >= 65531UL), l_41.f6) < 1UL) <= l_41.f3)) || l_41.f2) ^ l_41.f3) != 18446744073709551615UL) & l_41.f5) >> (int16_t)12), l_41.f6, l_412) <= l_412.f2.f6) < l_431) <= l_412.f4)) + (float)0x0.Fp+1);
    return l_669;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_35(uint32_t  p_36, struct S0  p_37, uint64_t  p_38, int16_t  p_39, struct S1  p_40)
{ /* block id: 225 */
    uint8_t l_417 = 0x89L;
    struct S0 l_419 = {0xC780D751L,0L,0x5533B808DDD28121LL,1990,0x74L,0x63121926EB2AE677LL,0xC0L,0xD9ADC42FL,0x442EC23F51DE6E45LL};
    struct S0 * const l_418 = &l_419;
    int32_t l_424 = (-1L);
    int32_t *l_423 = &l_424;
    int32_t **l_422 = &l_423;
    struct S2 l_428 = {-7741,{-7L,0L,18446744073709551614UL,-1566,0xF9L,0x229C48321FA8646DLL,0x4DL,0xB0D7B6BBL,0L},19673,1};
    struct S2 *l_427 = &l_428;
    struct S2 **l_426 = &l_427;
    struct S2 ***l_425 = &l_426;
    struct S2 * const **l_430 = (void*)0;
    struct S2 * const ***l_429 = &l_430;
    (*l_422) = func_101((((int16_t)0L + (int16_t)(((uint16_t)l_417 << (uint16_t)1) == ((void*)0 != l_418))) | p_37.f5), ((int16_t)(0x325A27A8972BC3EALL || (((l_419.f7 || (0xAA1BL | (p_40.f2.f2 > p_37.f1))) | p_40.f2.f6) > 0xFC4DL)) % (int16_t)0xB5A8L));
    /* statement id: 226 */
    assert (l_423 == 0);
    (*l_429) = l_425;
    /* statement id: 227 */
    assert (l_430 == &l_426);
    (*l_422) = (void*)0;
    return p_40.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_48(int16_t  p_49, int16_t  p_50, int16_t  p_51, int16_t  p_52, int64_t  p_53)
{ /* block id: 40 */
    struct S2 *l_67 = (void*)0;
    int32_t l_99 = 0xECF30466L;
    float ** const **l_384 = (void*)0;
    float l_404 = 0x9.Ap-1;
    float *l_403 = &l_404;
    float **l_402 = &l_403;
    if (p_52)
    { /* block id: 41 */
        float l_64 = 0x2.F57566p+58;
        float * const l_63 = &l_64;
        float * const *l_62 = &l_63;
        float * const **l_61 = &l_62;
        struct S2 l_66 = {2355,{0xA6B1F15FL,0xD345D190L,18446744073709551606UL,947,0x24L,-5L,253UL,0x53D1739CL,0x6DE1F29A3A768FB0LL},-12040,1};
        struct S2 *l_65 = &l_66;
        struct S0 *l_76 = (void*)0;
        const struct S0 **l_393 = (void*)0;
        const struct S0 ***l_392 = &l_393;
        struct S0 **l_401 = &l_76;
        struct S0 ***l_400 = &l_401;
        (*l_61) = (void*)0;
        /* statement id: 42 */
        assert (l_62 == 0);
lbl_385:
        l_67 = l_65;
        /* statement id: 43 */
        assert (l_67 == &l_66);
        for (l_66.f1.f5 = 0; (l_66.f1.f5 >= 25); l_66.f1.f5 += 8)
        { /* block id: 46 */
            int32_t l_71 = 0x8D9E2CD2L;
            int32_t *l_70 = &l_71;
            int32_t **l_72 = &l_70;
            float *l_96 = &l_64;
            float **l_95 = &l_96;
            float ***l_94 = &l_95;
            (*l_72) = l_70;
            for (p_53 = (-18); (p_53 >= 20); p_53++)
            { /* block id: 50 */
                uint32_t l_75 = 0x27840302L;
                struct S0 l_78 = {0x26DE3FE2L,-6L,0x2E6445A0AE891756LL,-390,251UL,1L,0x67L,1UL,0xE64A2B5195E1C378LL};
                struct S0 *l_77 = &l_78;
                if (l_75)
                    break;
                if ((*l_70))
                { /* block id: 52 */
                    l_77 = l_76;
                    /* statement id: 53 */
                    assert (l_77 == 0);
                }
                else
                { /* block id: 54 */
                    int32_t l_372 = 1L;
                    (*l_70) = (((int16_t)(((int32_t)((int16_t)func_85(func_91((&l_62 != l_94), func_56((0x0DEC7D61L || __builtin_ctzll(((uint32_t)l_99 / (uint32_t)(~(*l_70))))))), p_51, l_372, l_66.f1.f3, (*l_70)) + (int16_t)0xABCEL) - (int32_t)p_50) == 0xAD145C0F2A8A3E8CLL) % (int16_t)p_50) >= l_66.f1.f7);
                    l_66.f1.f3 = l_75;
                }
                /* facts after branching */
                assert (l_77 == &l_78 || l_77 == 0);
                (***l_94) = ((float)(((*l_70) == p_51) <= (l_63 != &l_99)) - (float)(&l_94 == l_384));
                if (p_51)
                    goto lbl_385;
            }
            (*l_70) = __builtin_parityl(((int16_t)((*l_70) >= ((uint32_t)(__builtin_bswap32(p_53) == ((int64_t)(*l_70) + (int64_t)(((l_392 == (void*)0) ^ ((uint64_t)(((uint64_t)func_118(__builtin_ffsl(((int32_t)(&l_393 != l_400) + (int32_t)p_51)), l_402) % (uint64_t)l_99) <= l_66.f1.f8) + (uint64_t)p_50)) ^ (-7L)))) % (uint32_t)0x8392DC42L)) / (int16_t)p_51));
            if (p_53)
                continue;
        }
        l_66.f1.f3 = ((int32_t)l_99 + (int32_t)((int16_t)p_49 << (int16_t)func_56(p_51)));
    }
    else
    { /* block id: 217 */
        for (p_53 = 7; (p_53 < (-5)); --p_53)
        { /* block id: 220 */
            float l_411 = 0x4.302C10p-95;
            return p_51;
        }
    }
    /* facts after branching */
    //assert (l_67 == 0 || l_67 == dangling);
    return l_99;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_56(uint16_t  p_57)
{ /* block id: 37 */
    int16_t l_58 = 0x6EE4L;
    float l_60 = 0x7.07D3E6p+39;
    float *l_59 = &l_60;
    (*l_59) = __builtin_ctzl(l_58);
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_85(int32_t ** p_86, int32_t  p_87, uint64_t  p_88, uint32_t  p_89, int32_t  p_90)
{ /* block id: 198 */
    int16_t l_373 = (-1L);
    int32_t *l_374 = (void*)0;
    int32_t l_375 = 0xBB460943L;
    l_375 = l_373;
    for (p_89 = 0; (p_89 > 29); ++p_89)
    { /* block id: 202 */
        int32_t l_378 = 0L;
        int32_t *l_379 = (void*)0;
        int32_t *l_380 = (void*)0;
        int32_t *l_381 = &l_375;
        (*l_381) = l_378;
    }
    l_374 = (void*)0;
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_91(float  p_92, const uint8_t  p_93)
{ /* block id: 55 */
    uint32_t l_104 = 4294967292UL;
    int32_t l_108 = 0x3DFDFBADL;
    int32_t *l_107 = &l_108;
    int32_t **l_106 = &l_107;
    int32_t **l_368 = &l_107;
    int32_t **l_369 = &l_107;
    int32_t **l_370 = &l_107;
    int32_t **l_371 = (void*)0;
    (*l_106) = func_101(l_104, p_93);
    /* statement id: 58 */
    assert (l_107 == 0);
    (*l_106) = func_109(p_93, p_93);
    return l_371;
    /* statement id: 197 */
    //assert (func_91_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_101(int32_t  p_102, uint32_t  p_103)
{ /* block id: 56 */
    int32_t *l_105 = (void*)0;
    return l_105;
    /* statement id: 57 */
    //assert (func_101_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_109(const uint16_t  p_110, uint8_t  p_111)
{ /* block id: 59 */
    int32_t l_123 = 6L;
    int32_t *l_122 = &l_123;
    int32_t * const *l_121 = &l_122;
    float * const **l_129 = (void*)0;
    int32_t l_363 = 0L;
    const int32_t *l_365 = &l_363;
    const int32_t **l_364 = &l_365;
    int32_t *l_366 = &l_123;
    int32_t *l_367 = (void*)0;
    (*l_364) = func_101(((uint16_t)(p_110 <= ((int32_t)((uint16_t)func_118((l_121 != (void*)0), func_124(p_111, &l_123, l_129, ((uint64_t)0UL % (uint64_t)(((*l_122) ^ p_111) | (**l_121))))) >> (uint16_t)p_111) / (int32_t)p_111)) % (uint16_t)l_363), p_111);
    /* statement id: 194 */
    assert (l_365 == 0);
    return l_367;
    /* statement id: 195 */
    //assert (func_109_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_118(int64_t  p_119, float ** p_120)
{ /* block id: 190 */
    float *l_360 = (void*)0;
    int32_t l_361 = 0x34CF7A4BL;
    int32_t *l_362 = &l_361;
    l_361 = p_119;
    (*l_362) = p_119;
    return p_119;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float ** func_124(int32_t  p_125, int32_t * p_126, float * const ** p_127, const uint32_t  p_128)
{ /* block id: 60 */
    uint32_t l_138 = 1UL;
    int32_t l_147 = 1L;
    int32_t *l_146 = &l_147;
    float **l_169 = (void*)0;
    struct S1 **l_271 = (void*)0;
    struct S0 l_349 = {-9L,0L,5UL,245,0xB6L,0x20A7527264FA5962LL,1UL,1UL,0x7ABC6312C1E3334ALL};
    struct S0 *l_348 = &l_349;
    struct S0 ** const l_347 = &l_348;
    struct S0 ** const *l_346 = &l_347;
    int16_t l_354 = 1L;
    float l_356 = 0x0.9p+1;
    float *l_355 = &l_356;
    float **l_357 = &l_355;
    float **l_358 = &l_355;
    float **l_359 = (void*)0;
    for (p_125 = (-21); (p_125 <= 18); p_125 += 5)
    { /* block id: 63 */
        int16_t l_134 = 1L;
        int32_t l_137 = 1L;
        int32_t *l_136 = &l_137;
        int32_t **l_135 = &l_136;
        (*l_135) = func_101(l_134, p_128);
        /* statement id: 64 */
        assert (l_136 == 0);
        (*l_135) = &p_125;
        /* statement id: 65 */
        assert (l_136 == &p_125);
        (*p_126) = func_56(l_138);
    }
    if (((int16_t)((int16_t)0x8AB2L >> (int16_t)15) + (int16_t)(((uint16_t)(!((p_125 < (l_138 || 65532UL)) | l_138)) / (uint16_t)l_138) != 0x911A91DCBA93E3F5LL)))
    { /* block id: 68 */
        uint64_t l_156 = 0x6A96B581468E88EELL;
        float l_159 = 0xF.C10F06p-22;
        float *l_158 = &l_159;
        float **l_157 = &l_158;
        struct S2 l_177 = {8670,{0L,0xB5522D6DL,18446744073709551615UL,-1948,0x14L,-7L,0xDFL,0x14FAD7DEL,1L},-23161,1};
        struct S2 *l_176 = &l_177;
        struct S0 *l_184 = &l_177.f1;
        int32_t *l_187 = &l_147;
        struct S0 **l_276 = &l_184;
        struct S0 ***l_275 = &l_276;
        p_126 = l_146;
        /* statement id: 69 */
        assert (p_126 == &l_147);
    }
    else
    { /* block id: 178 */
        int32_t l_350 = (-1L);
        for (p_125 = 24; (p_125 != (-23)); --p_125)
        { /* block id: 181 */
            float ***l_353 = &l_169;
            float *** const *l_352 = &l_353;
            float *** const **l_351 = &l_352;
            (*p_126) = ((uint64_t)((int64_t)p_128 + (int64_t)(l_346 == (void*)0)) - (uint64_t)(*l_146));
            if (l_350)
                continue;
            (*l_351) = &p_127;
            /* statement id: 184 */
            assert (l_352 == &p_127);
        }
    }
    /* facts after branching */
    //assert (p_126 == &l_123 || p_126 == &l_147);
    (*l_146) = l_354;
    (*l_355) = p_125;
    return l_359;
    /* statement id: 189 */
    //assert (func_124_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 158
   depth: 1, occurrence: 1
   depth: 2, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 11
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 32
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 16
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 7
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 17
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 4
XXX times a single bitfield on RHS: 12

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 8
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 165

XXX times a variable address is taken: 153
XXX times a pointer is dereferenced on RHS: 101
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 11
XXX times a pointer is dereferenced on LHS: 98
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 415

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 319
   level: 2, occurrence: 71
   level: 3, occurrence: 2
   level: 4, occurrence: 0
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 96
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 32.1
XXX average alias set size: 1.17

XXX times a non-volatile is read: 680
XXX times a non-volatile is write: 258
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 54
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 11
   depth: 2, occurrence: 8
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3

XXX percentage a fresh-made variable is used: 16.4
XXX percentage an existing variable is used: 83.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

