/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3335821984
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint32_t  f4;
};
#pragma pack(pop)

union U1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = (-1);
static int32_t g_25 = 0;
static union U1 g_68 = {0U};
static struct S0 g_89 = {0,0x320EC44C,-1,0x417F16C3,2U};
static struct S0 g_99 = {-5,0x3F29F9B9,0x769E501E,1,4294967295U};


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_27(void);
static uint16_t  func_45(uint16_t  p_46, uint16_t  p_47);
static uint32_t  func_52(struct S0  p_53, struct S0  p_54);
static struct S0  func_59(struct S0  p_60);
static struct S0  func_61(int16_t  p_62, int16_t  p_63, uint32_t  p_64, int16_t  p_65);
static int16_t  func_66(union U1  p_67);
static uint16_t  func_71(int16_t  p_72, uint32_t  p_73, union U1  p_74);
static struct S0  func_76(struct S0  p_77, uint16_t  p_78);
static struct S0  func_79(struct S0  p_80, struct S0  p_81, uint32_t  p_82);
static struct S0  func_83(uint32_t  p_84, uint32_t  p_85, uint32_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_25 g_68 g_3 g_89.f4 g_89 g_99 g_68.f0
 * writes: g_89 g_99.f0 g_99.f2 g_99.f4 g_99 g_25
 */
static uint16_t  func_27(void)
{ /* block id: 36 */
    uint32_t l_30 = 0x83C67EE3;
    struct S0 l_533 = {1,4U,0x6CE8CAD3,1,4294967287U};
    if (((int32_t)l_30 + (int32_t)((uint16_t)g_25 >> (uint16_t)0)))
    { /* block id: 37 */
        struct S0 l_55 = {-7,0xDE905F4D,0xC653DDB2,0,4294967287U};
        uint16_t l_58 = 2U;
        uint32_t l_527 = 0x6C76C8D7;
        l_55.f2 = ((int16_t)((uint16_t)(((g_25 | g_25) < (((int32_t)g_25 - (int32_t)((uint16_t)((((uint16_t)((uint16_t)func_45(l_30, ((int32_t)((uint32_t)((((__builtin_bswap32(l_30) > func_52(l_55, l_55)) && l_30) > g_25) <= l_58) + (uint32_t)l_30) - (int32_t)(-4))) >> (uint16_t)5) >> (uint16_t)g_68.f0) != g_3) & 0U) << (uint16_t)l_30)) && g_99.f1)) <= g_25) - (uint16_t)g_3) >> (int16_t)g_25);
        l_527 = (l_30 != g_99.f2);
    }
    else
    { /* block id: 265 */
        uint32_t l_530 = 0x828D17BC;
        int32_t l_532 = 0x7746CD10;
        struct S0 l_538 = {0x13FE2F50,4294967295U,-1,0xD891E444,0x486C4828};
        if ((((uint16_t)(g_89.f0 ^ __builtin_bswap32(g_68.f0)) >> (uint16_t)1) || (g_89.f4 | (0x24DB7E52 <= l_530))))
        { /* block id: 266 */
            uint16_t l_531 = 65535U;
            struct S0 l_534 = {0x1AFFFFF6,4U,0x962453D6,0xC72CEACC,4294967295U};
            g_99.f2 = (g_89.f4 > (g_99.f4 > l_531));
            l_532 = l_30;
            l_534 = l_533;
        }
        else
        { /* block id: 270 */
            struct S0 l_539 = {0x75F7998D,0x7E2F4206,0x9131DF7B,-7,0xEA7DE556};
            for (l_533.f1 = 6; (l_533.f1 == 9); l_533.f1 += 1)
            { /* block id: 273 */
                uint32_t l_537 = 0xF2B6A29D;
                l_537 = g_3;
                g_99.f0 = (g_99.f4 <= g_68.f0);
            }
            l_533.f2 = (func_52(l_538, l_539) >= l_539.f0);
            g_25 = ((uint16_t)g_89.f2 + (uint16_t)l_530);
            l_538.f2 = ((func_45((l_533.f4 == g_99.f1), l_539.f3) ^ l_533.f1) != (0U | (((uint16_t)(l_533.f0 ^ (((int16_t)l_538.f0 + (int16_t)((((((int16_t)0x3DE5 % (int16_t)l_530) != 0xE34CE680) <= g_68.f0) >= 1) | 0xE770)) >= 0x4015C741)) >> (uint16_t)l_539.f3) <= 0x2841)));
        }
        l_533.f0 = 0x31F3B27E;
    }
    return l_533.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_68 g_3 g_89.f4 g_89 g_25 g_99 g_68.f0
 * writes: g_89 g_99.f0 g_99.f2 g_99.f4 g_99
 */
static uint16_t  func_45(uint16_t  p_46, uint16_t  p_47)
{ /* block id: 41 */
    int32_t l_87 = (-1);
    struct S0 l_112 = {1,0x664A1005,0x543FC1E9,1,1U};
    union U1 l_113 = {0x61DEDA81};
    uint16_t l_216 = 0x6125;
    uint32_t l_236 = 4294967295U;
    struct S0 l_294 = {-8,0U,8,1,0x2CA25392};
    int16_t l_315 = 0x5E64;
    struct S0 l_336 = {1,1U,0x2773E2D9,1,0x9BF46510};
    uint16_t l_345 = 0x98BD;
    uint32_t l_354 = 0x81A67B9E;
    int32_t l_393 = 0x3DC5F1FE;
    int32_t l_417 = 0x0436C59E;
    uint16_t l_463 = 4U;
    l_112 = func_59(func_61(func_66(g_68), (func_71(p_46, (((!(((func_52(func_76(func_79(func_83(l_87, p_46, p_47), g_99, p_46), l_87), l_112) & l_112.f4) || 0x6B4620FE) && g_99.f4)) | p_47) >= g_99.f0), l_113) ^ g_99.f3), l_112.f2, p_47));
    for (p_47 = 1; (p_47 <= 56); p_47 += 2)
    { /* block id: 116 */
        uint32_t l_179 = 0x14682580;
        uint16_t l_196 = 0U;
        int32_t l_199 = (-1);
        uint16_t l_213 = 0U;
        if (g_89.f2)
        { /* block id: 117 */
            return l_179;
        }
        else
        { /* block id: 119 */
            struct S0 l_180 = {-7,0U,0x1DBFA455,0x1639E250,0x355CF6CD};
            l_180 = g_89;
            l_199 = ((-(int16_t)((uint16_t)__builtin_ctz((((g_89.f2 == func_66(g_68)) || (((uint16_t)((int32_t)l_180.f0 % (int32_t)((uint16_t)65529U << (uint16_t)((int16_t)((int16_t)((g_99.f3 && (l_196 || (((((int16_t)func_66(g_68) >> (int16_t)5) >= 65534U) > g_89.f2) && 0x3201))) & p_46) % (int16_t)1U) % (int16_t)l_112.f2))) >> (uint16_t)2) == p_46)) & p_46)) >> (uint16_t)8)) != g_89.f1);
            l_199 = (!(l_112.f3 >= (((g_89.f1 != (((65527U <= (((int16_t)(~(((uint16_t)((int32_t)(g_89.f2 || (((int32_t)(((!(((g_89.f4 || (0 || ((int16_t)l_213 >> (int16_t)4))) == l_112.f1) > ((uint16_t)0U >> (uint16_t)15))) >= 0xE07C) >= 0) - (int32_t)0xD013E866) <= g_99.f0)) + (int32_t)g_3) % (uint16_t)(-1)) != 0xC6D6)) << (int16_t)p_46) || 1U)) ^ l_213) != l_196)) & l_216) || p_46)));
        }
    }
    g_99.f0 = (0x6AC7 || l_112.f1);
    for (l_112.f3 = 0; (l_112.f3 == (-20)); l_112.f3 -= 1)
    { /* block id: 128 */
        int32_t l_221 = 0;
        uint32_t l_222 = 2U;
        int32_t l_237 = 0xE7CB9A90;
        int32_t l_246 = 9;
        struct S0 l_295 = {1,0xEC65BDC4,1,0xAB2BB56A,4294967287U};
        uint16_t l_316 = 0U;
        union U1 l_317 = {0xBBA7D40B};
        int16_t l_416 = (-1);
        for (g_99.f0 = (-23); (g_99.f0 > (-3)); g_99.f0 += 1)
        { /* block id: 131 */
            struct S0 l_247 = {1,0xCD69BB4E,0x28B6DCFA,0x13AD1F11,4294967295U};
            int32_t l_365 = 1;
            if (p_47)
            { /* block id: 132 */
                int32_t l_234 = (-6);
                uint32_t l_259 = 8U;
                if (p_47)
                { /* block id: 133 */
                    g_99.f2 = l_221;
                    l_221 = (l_222 == __builtin_clzll(p_47));
                }
                else
                { /* block id: 136 */
                    union U1 l_251 = {1U};
                    struct S0 l_279 = {0x7F08B360,4294967291U,0xD38E6171,5,4294967295U};
                    uint32_t l_337 = 1U;
                    for (g_99.f4 = 16; (g_99.f4 == 10); g_99.f4 -= 1)
                    { /* block id: 139 */
                        int32_t l_235 = 0xA53CB9E1;
                        l_237 = (((int16_t)g_99.f1 % (int16_t)(__builtin_ia32_crc32qi(g_99.f4, ((~(g_89.f4 >= ((((int16_t)(0x7905CFCB > (0x28AB4817 & ((uint16_t)(((int16_t)g_99.f4 >> (int16_t)l_234) & l_235) - (uint16_t)(l_235 && g_3)))) + (int16_t)g_99.f4) ^ g_99.f0) > 0x8342FEDE))) | p_46)) ^ l_236)) >= 4);
                        l_247 = func_76(g_89, ((int16_t)((((0x11EA | g_89.f0) & ((((g_89.f4 <= ((uint16_t)((int32_t)(((int16_t)__builtin_ctzl(p_47) + (int16_t)1U) & ((1U && (0x57A06D27 || 0x3937DDB6)) > l_246)) % (int32_t)5) >> (uint16_t)p_46)) & g_89.f3) < p_47) == 0)) >= p_46) < 0x48DB) << (int16_t)g_68.f0));
                        g_99.f2 = func_71(p_46, (((uint16_t)(((func_66(g_68) != p_47) | 1U) | func_71((p_47 < ((0xBEBF25DA ^ (~0xF71F)) ^ ((l_246 <= g_68.f0) || 0x36C56402))), g_99.f4, l_251)) % (uint16_t)p_46) & p_46), l_113);
                    }
                    if ((((~(((uint16_t)((uint32_t)(((-(int32_t)((((func_52(g_89, func_79(g_99, l_247, (-(int16_t)((((l_216 == (1U && (0x7EB04718 > (l_247.f0 & g_99.f3)))) != g_89.f3) <= 0x3678) < l_112.f1)))) ^ l_259) && 0x33C6B0B5) != 9U) || g_89.f0)) == 0xB975) && p_47) - (uint32_t)g_89.f4) % (uint16_t)(-1)) < 4294967295U)) ^ g_99.f0) != 1U))
                    { /* block id: 144 */
                        return g_89.f4;
                    }
                    else
                    { /* block id: 146 */
                        uint16_t l_278 = 0x4EE3;
                        l_247.f0 = (((((int16_t)((uint16_t)p_46 + (uint16_t)((int16_t)((uint32_t)((uint16_t)(!((((uint16_t)p_46 % (uint16_t)0xD5C0) ^ ((-(int32_t)((int16_t)((uint16_t)p_47 % (uint16_t)l_278) % (int16_t)func_52(func_79(g_99, func_76(func_83(g_99.f4, (g_99.f0 < 0x3416), l_234), g_99.f1), l_234), l_279))) < 9)) >= 0x8871)) % (uint16_t)1U) % (uint32_t)p_47) % (int16_t)g_99.f0)) >> (int16_t)p_47) && g_89.f1) <= 0) > g_99.f1);
                    }
                    if (g_3)
                    { /* block id: 149 */
                        union U1 l_283 = {1U};
                        l_247.f0 = (((int16_t)l_259 << (int16_t)func_52(l_279, g_89)) ^ 0x9B6EA8F3);
                        g_99.f2 = (0xA6F3B492 && (((0xB0C5A6CC || ((g_99.f2 ^ (((8U != p_46) < ((((((!(p_47 >= (p_46 <= (func_71(((__builtin_ffsl(g_99.f2) != 0U) < p_46), g_68.f0, l_283) <= g_99.f4)))) != p_46) && 1U) ^ g_99.f1) != 0xD6F0) == l_237)) || p_46)) || p_46)) || 3) ^ p_47));
                        l_294 = func_83(((g_99.f3 != ((int16_t)__builtin_popcount(p_47) << (int16_t)1)) >= ((((int16_t)(((int16_t)g_99.f4 - (int16_t)((uint16_t)func_52(g_89, g_99) << (uint16_t)5)) >= g_3) + (int16_t)((((int16_t)0x78A6 << (int16_t)8) <= 0x8869) > g_89.f1)) <= 1) > g_99.f1)), l_283.f0, l_279.f1);
                        if (g_99.f3)
                            continue;
                    }
                    else
                    { /* block id: 154 */
                        int16_t l_296 = 6;
                        l_294.f0 = l_247.f3;
                        l_279.f2 = (l_247.f1 && func_52(l_295, l_294));
                        l_296 = (-1);
                        l_316 = ((int16_t)((uint16_t)p_47 << (uint16_t)3) - (int16_t)((p_47 == (p_47 <= ((((((int32_t)g_89.f2 % (int32_t)(((uint16_t)(((int16_t)((((((uint16_t)((uint16_t)l_246 % (uint16_t)((__builtin_bswap64(p_46) == ((int16_t)((uint32_t)(g_89.f2 ^ (((l_237 ^ g_99.f0) == p_47) & l_279.f1)) % (uint32_t)g_89.f0) >> (int16_t)g_68.f0)) ^ l_234)) >> (uint16_t)g_25) == l_259) <= 0x78DEA3D8) ^ p_46) & l_315) + (int16_t)0) & p_46) - (uint16_t)p_47) ^ l_247.f4)) || 2) || l_296) | p_47) || l_251.f0))) <= 1));
                    }
                    if (l_294.f2)
                    { /* block id: 160 */
                        struct S0 l_318 = {-2,0xCDDFB4A6,0xA11A75C4,3,0x64B3CA65};
                        l_318 = func_83(g_89.f4, __builtin_ffsl(func_66(l_317)), l_259);
                        g_99.f2 = ((uint16_t)((int16_t)(((uint16_t)((int16_t)p_47 % (int16_t)(-1)) >> (uint16_t)9) < ((uint16_t)0U >> (uint16_t)(g_89.f1 != (g_89.f0 || func_52(g_89, g_99))))) + (int16_t)((g_89.f4 | p_46) != l_247.f4)) >> (uint16_t)g_99.f0);
                    }
                    else
                    { /* block id: 163 */
                        int32_t l_341 = 0x30FED956;
                        l_337 = (!(__builtin_clzl(g_68.f0) > ((int16_t)((uint16_t)(__builtin_parityll(((1 && (l_112.f0 > 0xC3C4)) || ((((uint16_t)65535U - (uint16_t)g_89.f1) || (((((g_89.f4 > func_52(l_336, l_112)) > g_99.f3) <= g_99.f3) & (-1)) ^ 0x74E3)) < g_99.f2))) < p_47) >> (uint16_t)l_279.f3) >> (int16_t)4)));
                        g_99.f2 = ((__builtin_parityl(((uint16_t)((((!func_66(g_68)) != ((p_46 >= (func_71(l_251.f0, p_47, g_68) <= 1)) | (1 & p_47))) >= l_341) < g_99.f3) << (uint16_t)l_247.f4)) ^ l_216) < l_259);
                    }
                }
                l_246 = (0x217493E9 & (!((uint16_t)l_345 % (uint16_t)p_47)));
            }
            else
            { /* block id: 169 */
                int32_t l_348 = 3;
                int32_t l_353 = 0xE8A2A857;
                uint32_t l_376 = 0x76DE3CCA;
                l_353 = (((uint32_t)1U + (uint32_t)(l_348 == p_46)) == (((((((int16_t)g_99.f0 >> (int16_t)6) <= (p_46 <= l_348)) != (__builtin_ffsl(l_247.f3) | ((uint16_t)p_46 >> (uint16_t)g_99.f2))) > g_89.f0) || p_47) < l_348));
                l_353 = __builtin_popcountl(l_354);
                for (l_294.f4 = 0; (l_294.f4 == 21); l_294.f4 += 2)
                { /* block id: 174 */
                    int16_t l_357 = 0xD179;
                    struct S0 l_360 = {0x642F902C,4294967295U,0x5F8686FE,-1,0xB1DC92F3};
                    l_247.f0 = l_357;
                    for (l_112.f4 = 0; (l_112.f4 <= 17); l_112.f4 += 8)
                    { /* block id: 178 */
                        l_360 = l_336;
                    }
                    g_89 = g_99;
                    l_353 = (((int16_t)((((uint32_t)(g_99.f3 <= (((l_365 < l_246) & (0 ^ ((int16_t)((int16_t)((uint32_t)((uint16_t)65531U << (uint16_t)((((g_68.f0 > 0x156664AC) ^ p_46) >= (((int32_t)p_47 - (int32_t)g_99.f3) == 0)) ^ p_46)) + (uint32_t)1U) >> (int16_t)p_46) >> (int16_t)l_247.f0))) < l_112.f0)) % (uint32_t)g_99.f2) <= 0x61B7) || p_46) << (int16_t)l_376) ^ l_295.f1);
                }
            }
            return p_46;
        }
        g_89 = l_295;
        if (((uint16_t)func_66(l_113) - (uint16_t)(l_345 > (l_112.f2 != ((((int16_t)(-1) - (int16_t)func_71((((((uint16_t)l_237 + (uint16_t)g_89.f1) == __builtin_bswap64(((uint16_t)((uint16_t)((uint16_t)((__builtin_parity(((0xFD1387B7 & (0x458DE11E != g_99.f1)) < l_393)) & g_89.f3) >= l_295.f2) >> (uint16_t)4) % (uint16_t)g_99.f0) >> (uint16_t)2))) != 0xD8A2B8D3) || g_89.f0), p_47, l_113)) == l_221) <= 0x6E89)))))
        { /* block id: 188 */
            int32_t l_396 = (-1);
            int32_t l_399 = 0x37635581;
            l_399 = ((((l_246 ^ g_99.f4) && ((uint16_t)l_396 - (uint16_t)((int32_t)(g_89.f4 == 0x5A0E) + (int32_t)((p_46 >= (l_396 && func_66(l_113))) && p_46)))) != g_99.f1) == p_46);
            l_336.f2 = ((uint16_t)((uint16_t)g_99.f2 - (uint16_t)g_99.f3) >> (uint16_t)((g_3 >= l_112.f2) && __builtin_ffs(g_99.f1)));
            g_99 = func_83((((p_46 == ((uint16_t)g_3 >> (uint16_t)13)) < (g_99.f0 || 0xCA7491A2)) && (((uint16_t)0x249E % (uint16_t)l_112.f0) & (((uint16_t)g_89.f0 << (uint16_t)((((__builtin_popcount(((uint16_t)g_99.f4 - (uint16_t)((uint32_t)(p_46 == g_89.f1) % (uint32_t)0xB284F151))) | l_416) & 0x6DC8848B) < g_3) == l_295.f4)) <= l_416))), l_417, g_99.f4);
        }
        else
        { /* block id: 192 */
            uint16_t l_418 = 65533U;
            struct S0 l_452 = {0x1002B68F,7U,0xA10C5DAC,1,4294967295U};
            uint32_t l_471 = 4294967286U;
            if (l_418)
            { /* block id: 193 */
                uint32_t l_419 = 1U;
                union U1 l_436 = {0x3E825C8B};
                int32_t l_437 = 0xB9AE5922;
                uint32_t l_446 = 4U;
                l_419 = 8;
                if (((uint16_t)0x0CA2 << (uint16_t)10))
                { /* block id: 195 */
                    uint16_t l_451 = 1U;
                    struct S0 l_464 = {0xA52866C1,0x64AA1F1E,-1,0x7A30C04C,4294967288U};
                    l_295.f0 = (~func_66(g_68));
                    for (l_113.f0 = 1; (l_113.f0 >= 37); l_113.f0 += 1)
                    { /* block id: 199 */
                        uint16_t l_431 = 65533U;
                        l_294 = func_83((((((p_47 > __builtin_ffsl(func_52(l_336, func_83(l_418, ((uint16_t)g_89.f4 << (uint16_t)(((g_89.f1 > (__builtin_ffsl((((uint16_t)5U - (uint16_t)g_99.f3) == ((g_89.f4 == func_52(l_294, l_294)) == (-1)))) < 0x4DEE00CD)) == p_46) & p_46)), l_418)))) || p_47) & p_47) >= p_47) ^ 65533U), p_46, g_3);
                        if (l_431)
                            continue;
                        g_99.f0 = ((0x81D7 && (p_47 ^ ((p_46 ^ 0xC9520C32) && (p_47 <= ((int16_t)((uint32_t)func_71(p_46, (func_71(g_99.f3, g_89.f3, l_113) == p_47), l_436) - (uint32_t)l_418) + (int16_t)p_47))))) >= 0);
                    }
                    if (g_99.f1)
                    { /* block id: 204 */
                        l_437 = 1;
                        l_437 = l_316;
                        l_294 = l_336;
                        l_452 = func_61(g_89.f2, ((uint32_t)(l_112.f1 & p_46) - (uint32_t)(0x4F744FA6 >= (__builtin_clz(((uint16_t)((uint32_t)func_66(l_436) - (uint32_t)(((uint32_t)g_3 % (uint32_t)l_446) >= ((uint32_t)((uint32_t)(0xA38FC2E0 || g_68.f0) + (uint32_t)l_451) + (uint32_t)0x18DEDDCC))) - (uint16_t)p_46)) | 0U))), l_418, g_99.f4);
                    }
                    else
                    { /* block id: 209 */
                        int32_t l_470 = 1;
                        l_464 = func_83(p_47, p_46, ((-(int32_t)(g_99.f1 >= l_237)) < ((int32_t)(g_89.f0 | ((int32_t)__builtin_ctz((((((((uint16_t)(((int16_t)(!((-5) || l_436.f0)) - (int16_t)((p_47 != l_354) > p_46)) & g_99.f2) - (uint16_t)0x856A) || 0U) > l_222) > g_89.f4) >= 0xF0210141) <= p_46)) + (int32_t)5U)) % (int32_t)l_463)));
                        if (g_89.f2)
                            continue;
                        l_452.f2 = (~((int16_t)1 >> (int16_t)(func_52(g_89, g_89) != ((uint16_t)(p_47 != ((p_47 == __builtin_popcountl(l_451)) ^ l_470)) << (uint16_t)8))));
                    }
                    l_471 = p_46;
                }
                else
                { /* block id: 215 */
                    l_437 = (g_25 || (func_71(g_99.f2, (((int16_t)p_47 >> (int16_t)13) < ((l_295.f0 == ((uint16_t)((int16_t)__builtin_bswap32(g_89.f2) % (int16_t)(((int16_t)func_66(l_317) + (int16_t)(-(uint32_t)g_99.f4)) || 6)) << (uint16_t)g_99.f0)) != l_419)), g_68) == p_47));
                }
            }
            else
            { /* block id: 218 */
                for (l_417 = 0; (l_417 == (-21)); l_417 -= 9)
                { /* block id: 221 */
                    g_99 = g_99;
                    l_295 = l_295;
                    if (g_99.f3)
                        continue;
                }
                for (l_463 = 23; (l_463 != 31); l_463 += 8)
                { /* block id: 228 */
                    int16_t l_491 = 0x6D1F;
                    g_89.f0 = __builtin_ctzll(((uint16_t)((uint16_t)(2 < (((p_46 ^ ((int16_t)l_491 + (int16_t)0x447B)) == ((((l_336.f1 > ((uint16_t)((uint32_t)((uint16_t)65535U << (uint16_t)5) % (uint32_t)func_52(l_295, g_99)) >> (uint16_t)p_47)) && 0U) && g_25) && g_99.f1)) & l_491)) - (uint16_t)g_99.f0) << (uint16_t)8));
                }
            }
            g_99.f0 = (((uint16_t)((0xF2B78BEB & (p_46 | ((int16_t)l_452.f2 + (int16_t)(g_3 | ((-1) == __builtin_ffs(l_452.f2)))))) != ((((int16_t)g_89.f3 + (int16_t)((uint16_t)((((int16_t)(-7) >> (int16_t)1) < l_471) || l_471) % (uint16_t)0x43AF)) || 0x8DA2) <= g_89.f1)) << (uint16_t)6) >= p_47);
            for (l_295.f0 = 24; (l_295.f0 < (-5)); l_295.f0 -= 2)
            { /* block id: 235 */
                uint32_t l_510 = 0x2D8EBAD7;
                struct S0 l_511 = {-8,0x866D73C9,0x1C03A962,0x1547B91E,0x47ADE208};
                l_511 = func_61(l_295.f0, g_89.f2, l_510, __builtin_bswap64(g_89.f2));
                for (l_452.f2 = 0; (l_452.f2 >= (-26)); l_452.f2 -= 1)
                { /* block id: 239 */
                    return l_112.f3;
                }
                if (l_295.f4)
                { /* block id: 242 */
                    l_511.f0 = func_66(l_317);
                }
                else
                { /* block id: 244 */
                    uint32_t l_514 = 4294967293U;
                    int32_t l_515 = 0x0EB32F37;
                    if (((-1) || (0x2A4A8CEA == p_46)))
                    { /* block id: 245 */
                        l_452.f2 = (0x0C58 || l_511.f0);
                        l_515 = l_514;
                        l_295.f2 = l_515;
                        if (p_47)
                            continue;
                    }
                    else
                    { /* block id: 250 */
                        uint16_t l_516 = 0xC005;
                        l_452 = l_511;
                        l_516 = __builtin_clzll(g_3);
                        if (g_68.f0)
                            continue;
                    }
                }
                l_246 = ((int16_t)((int16_t)(p_46 != ((p_46 > l_511.f4) == (((int32_t)((int16_t)((uint16_t)((l_236 < ((((l_354 ^ (0 != 0xC221DAD8)) != (g_99.f1 >= __builtin_parityl(l_511.f2))) != 9) ^ 65535U)) | g_99.f1) << (uint16_t)l_511.f3) << (int16_t)0) + (int32_t)p_47) || 0U))) + (int16_t)g_99.f1) % (int16_t)l_511.f0);
            }
            if (g_89.f4)
                continue;
        }
        if (g_99.f4)
            continue;
    }
    return g_89.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_52(struct S0  p_53, struct S0  p_54)
{ /* block id: 38 */
    uint32_t l_56 = 0x954EB856;
    int32_t l_57 = 0x32F520A0;
    l_57 = l_56;
    return p_53.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_99.f0 g_89.f4 g_99.f3 g_3 g_89.f3 g_99.f1 g_99.f2 g_89
 * writes: g_89.f2
 */
static struct S0  func_59(struct S0  p_60)
{ /* block id: 108 */
    int16_t l_175 = (-1);
    struct S0 l_176 = {0x217DE881,0xA7A1799D,0xB88D7C33,1,0x5D64D038};
    p_60.f2 = ((g_99.f0 && ((uint32_t)((uint16_t)(((int16_t)(-4) >> (int16_t)((int32_t)g_89.f4 - (int32_t)(g_99.f3 == ((0U > 0xDF79) && ((uint16_t)((int32_t)l_175 % (int32_t)g_3) - (uint16_t)g_89.f3))))) | g_99.f1) << (uint16_t)6) + (uint32_t)g_99.f2)) >= l_175);
    g_89.f2 = g_89.f4;
    l_176 = l_176;
    return g_89;
}


/* ------------------------------------------ */
/* 
 * reads : g_99.f0 g_99 g_89 g_3 g_68 g_25 g_68.f0
 * writes: g_99.f0 g_89.f0 g_89
 */
static struct S0  func_61(int16_t  p_62, int16_t  p_63, uint32_t  p_64, int16_t  p_65)
{ /* block id: 62 */
    struct S0 l_118 = {0x1C05FA5A,2U,1,1,0x71BA02A5};
    union U1 l_145 = {1U};
    for (g_99.f0 = 12; (g_99.f0 > (-18)); g_99.f0 -= 2)
    { /* block id: 65 */
        struct S0 l_119 = {0x9FEB662F,9U,0xBDD5AF53,-4,0xAE813F23};
        l_119 = l_118;
        for (l_119.f3 = 0; (l_119.f3 != 11); l_119.f3 += 1)
        { /* block id: 69 */
            int16_t l_122 = 0;
            uint16_t l_133 = 0x3C26;
            struct S0 l_134 = {-8,0x359DE98D,0x0478C99D,0x4A88B036,0xCEBE310A};
            l_119.f2 = (((-10) <= 1U) ^ (p_63 ^ (func_52(l_118, g_99) && g_99.f0)));
            g_89.f0 = l_122;
            for (l_119.f0 = 5; (l_119.f0 != 29); l_119.f0 += 1)
            { /* block id: 74 */
                struct S0 l_140 = {1,2U,3,0x5D7662A5,0xBB92B385};
                if (((uint32_t)g_99.f4 % (uint32_t)g_99.f0))
                { /* block id: 75 */
                    struct S0 l_128 = {0xD98EA379,0xF8A60635,0x80C9BFB8,0xD1E39FD5,0xAA24F531};
                    l_134 = func_83((!func_52(l_128, g_89)), ((int16_t)l_118.f0 + (int16_t)((uint16_t)l_133 << (uint16_t)(4294967295U ^ p_64))), p_62);
                    if ((l_119.f2 & p_62))
                    { /* block id: 77 */
                        l_118 = func_83(((int32_t)p_63 - (int32_t)l_119.f0), g_99.f0, ((int16_t)0xA83C >> (int16_t)5));
                        return g_99;
                    }
                    else
                    { /* block id: 80 */
                        int16_t l_139 = (-1);
                        g_89 = l_128;
                        l_139 = (0xD86A && g_89.f4);
                        return l_119;
                    }
                }
                else
                { /* block id: 85 */
                    struct S0 l_157 = {0,4294967289U,-1,0x86176E38,4294967295U};
                    l_140 = l_119;
                    if (p_65)
                        break;
                    if ((65535U & ((int16_t)(((0x5C47 > g_89.f0) & (1 == __builtin_ctzll(p_65))) > 0x2BCA) + (int16_t)((l_118.f3 || (l_119.f0 > 65527U)) != l_133))))
                    { /* block id: 88 */
                        l_140.f2 = (((int32_t)((func_66(l_145) < g_68.f0) ^ ((((((int16_t)(~((p_65 == (((uint16_t)p_64 << (uint16_t)(((g_99.f2 && (-1)) != ((int16_t)(((int16_t)__builtin_ffsll((p_62 & ((uint16_t)0xE77D + (uint16_t)g_99.f4))) >> (int16_t)g_89.f0) | g_3) % (int16_t)0x7DD3)) && l_122)) < 0U)) <= 0x2E85)) >> (int16_t)l_119.f4) && p_62) || l_119.f4) ^ l_119.f2) < g_89.f3)) % (int32_t)0xABB1F743) > 0);
                    }
                    else
                    { /* block id: 90 */
                        l_119.f2 = func_52(l_157, l_119);
                        l_118 = l_157;
                    }
                }
                l_118.f0 = ((~g_99.f3) > l_134.f4);
                for (l_140.f3 = 0; (l_140.f3 >= 2); l_140.f3 += 1)
                { /* block id: 98 */
                    if (g_68.f0)
                        break;
                }
            }
            if (l_119.f1)
                break;
        }
        g_89.f0 = (((int16_t)(p_63 == g_89.f2) >> (int16_t)l_118.f1) ^ (g_3 < (l_119.f0 >= g_89.f2)));
    }
    l_118 = l_118;
    return g_89;
}


/* ------------------------------------------ */
/* 
 * reads : g_3
 * writes:
 */
static int16_t  func_66(union U1  p_67)
{ /* block id: 42 */
    struct S0 l_70 = {0x7A64A0F0,0U,-1,1,4294967291U};
    l_70.f0 = (!func_52(l_70, l_70));
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_89
 */
static uint16_t  func_71(int16_t  p_72, uint32_t  p_73, union U1  p_74)
{ /* block id: 58 */
    uint32_t l_114 = 0xDBD1F826;
    struct S0 l_115 = {0xA9F20BB8,4294967295U,0x3B604336,1,0x5813BB0F};
    l_114 = p_72;
    g_89 = l_115;
    return p_74.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_68.f0 g_99.f3 g_89.f2 g_99.f1 g_89
 * writes: g_89.f0 g_89.f2
 */
static struct S0  func_76(struct S0  p_77, uint16_t  p_78)
{ /* block id: 52 */
    uint32_t l_100 = 4294967295U;
    union U1 l_101 = {0x7C9A86FC};
    int16_t l_110 = 0xE350;
    uint32_t l_111 = 0xBB316AA2;
    g_89.f0 = (-7);
    p_77.f0 = 0x2835E52A;
    l_100 = g_3;
    g_89.f2 = (((g_68.f0 >= func_66(l_101)) > (((uint16_t)((uint16_t)(((uint16_t)(((uint16_t)g_99.f3 + (uint16_t)((0xDC6F3D13 > 4294967295U) == ((((l_101.f0 <= 0xBAC90574) | p_77.f1) >= l_110) != p_77.f2))) <= 2U) - (uint16_t)l_110) & g_89.f2) + (uint16_t)g_99.f3) >> (uint16_t)l_111) == l_101.f0)) & g_99.f1);
    return g_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_79(struct S0  p_80, struct S0  p_81, uint32_t  p_82)
{ /* block id: 49 */
    p_80.f0 = (-1);
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads : g_89.f4 g_89 g_3 g_68 g_25
 * writes: g_89
 */
static struct S0  func_83(uint32_t  p_84, uint32_t  p_85, uint32_t  p_86)
{ /* block id: 45 */
    struct S0 l_88 = {0x33086262,9U,0x68E5B495,0xE89E6D54,0xD3F7CC82};
    struct S0 l_96 = {0x349FFB2E,0x76CAF445,0x642E063A,0x9C5D0792,0x0D6E0D24};
    g_89 = l_88;
    l_96.f0 = (((int16_t)p_84 << (int16_t)__builtin_ffs(((uint32_t)((int16_t)__builtin_parityl((g_89.f4 == (func_52(g_89, l_96) && (((((__builtin_popcountl(g_89.f3) <= ((uint16_t)l_88.f1 - (uint16_t)func_66(g_68))) & p_86) == l_96.f2) < l_96.f2) > 0xA104)))) % (int16_t)g_25) - (uint32_t)0xF6C633F4))) ^ 0U);
    return l_88;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_25, "g_25", print_hash_value);
    transparent_crc(g_68.f0, "g_68.f0", print_hash_value);
    transparent_crc(g_89.f0, "g_89.f0", print_hash_value);
    transparent_crc(g_89.f1, "g_89.f1", print_hash_value);
    transparent_crc(g_89.f2, "g_89.f2", print_hash_value);
    transparent_crc(g_89.f3, "g_89.f3", print_hash_value);
    transparent_crc(g_89.f4, "g_89.f4", print_hash_value);
    transparent_crc(g_99.f0, "g_99.f0", print_hash_value);
    transparent_crc(g_99.f1, "g_99.f1", print_hash_value);
    transparent_crc(g_99.f2, "g_99.f2", print_hash_value);
    transparent_crc(g_99.f3, "g_99.f3", print_hash_value);
    transparent_crc(g_99.f4, "g_99.f4", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 78
   depth: 1, occurrence: 30
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 169
   depth: 2, occurrence: 30
   depth: 3, occurrence: 7
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 5
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 4
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 24, occurrence: 5
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 606
XXX times a non-volatile is write: 112
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 156
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 12
   depth: 2, occurrence: 24
   depth: 3, occurrence: 18
   depth: 4, occurrence: 28
   depth: 5, occurrence: 43

XXX percentage a fresh-made variable is used: 15.7
XXX percentage an existing variable is used: 84.3
********************* end of statistics **********************/

