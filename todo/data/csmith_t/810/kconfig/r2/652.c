/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1375192568
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_36(void);
static uint16_t  func_45(const uint64_t  p_46, int16_t  p_47, int16_t  p_48, const int32_t  p_49);
inline static const uint32_t  func_54(uint64_t  p_55, uint8_t  p_56, int64_t  p_57, const float  p_58);
static uint64_t  func_83(uint32_t  p_84, uint64_t  p_85, uint32_t  p_86, int32_t * const * p_87, float  p_88);
static int64_t  func_91(int32_t * p_92, int32_t ** p_93, const uint16_t  p_94);
static int32_t * func_95(int32_t  p_96, uint32_t  p_97, uint32_t  p_98, const int32_t  p_99, float  p_100);
inline static uint64_t  func_103(uint32_t  p_104, int32_t * const * p_105, uint32_t  p_106);
static int32_t * func_114(int32_t ** p_115, int32_t *** p_116, uint8_t  p_117, uint16_t  p_118);
inline static float  func_138(float  p_139);
inline static int32_t * func_149(int32_t ** p_150, int32_t  p_151, uint16_t  p_152, int32_t  p_153, int32_t ** const * p_154);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_36(void)
{ /* block id: 36 */
    int32_t l_37 = 0L;
    const float l_68 = 0xF.8CD908p-63;
    float l_358 = (-0x1.1p+1);
    int32_t **l_359 = (void*)0;
    float ***l_373 = (void*)0;
    float ****l_372 = &l_373;
    uint32_t l_404 = 18446744073709551615UL;
    float l_415 = 0x0.E6A570p+36;
    int64_t l_464 = 1L;
    const int32_t *l_487 = &l_37;
    const int32_t **l_486 = &l_487;
    const int32_t ***l_485 = &l_486;
    const int32_t ****l_484 = &l_485;
    const int32_t *****l_483 = &l_484;
    int64_t l_521 = 1L;
    for (l_37 = (-19); (l_37 >= 10); l_37 += 7)
    { /* block id: 39 */
        const uint8_t l_42 = 0x6DL;
        int16_t l_346 = 6L;
        float l_350 = 0x4.06DFE7p-83;
        float *l_349 = &l_350;
        uint32_t l_357 = 0x9E7C32A7L;
        int32_t *l_360 = (void*)0;
        int16_t l_374 = 0x9750L;
        float *****l_386 = &l_372;
        float * const **l_395 = (void*)0;
        float * const *l_397 = &l_349;
        float * const **l_396 = &l_397;
        (*l_349) = ((float)l_42 / (float)(__builtin_ia32_crc32qi(((uint32_t)(func_45(l_37, (l_42 < ((l_42 > (((uint16_t)0UL >> (uint16_t)12) >= ((int64_t)(func_54(l_42, ((int16_t)((uint16_t)((int64_t)(~0x2FF5FF74L) - (int64_t)l_42) << (uint16_t)(((uint16_t)l_42 >> (uint16_t)l_42) < l_37)) << (int16_t)1), l_37, l_68) ^ l_42) + (int64_t)l_346))) ^ l_37)), l_37, l_37) | l_37) + (uint32_t)0x1CD5F59CL), l_37) <= l_346));
        (*l_349) = ((float)(l_37 <= ((__builtin_ctzll((l_37 && (l_37 > 7L))) <= func_54(((-5L) >= ((int16_t)(l_357 > (0x3EBFL != ((__builtin_clz(l_42) > l_37) >= 3UL))) >> (int16_t)l_37)), l_42, l_42, l_357)) >= 0xA.F038DEp-40)) + (float)0xA.875ADBp-11);
        if (func_91(l_349, l_359, l_42))
        { /* block id: 171 */
            int32_t l_366 = (-4L);
            float *l_371 = (void*)0;
            int32_t *l_375 = &l_366;
            float **l_381 = (void*)0;
            l_360 = (void*)0;
            if (l_42)
                break;
            l_375 = func_149(l_359, (((uint16_t)(!l_42) << (uint16_t)15) && ((int16_t)__builtin_parityl(l_37) >> (int16_t)1)), __builtin_clz(l_366), ((int16_t)(((l_371 != (void*)0) >= (l_372 == (void*)0)) & l_366) / (int16_t)l_374), &l_359);
            /* statement id: 174 */
            assert (l_375 == 0);
            if (l_37)
            { /* block id: 175 */
                int64_t l_376 = 0x997202116EFC7179LL;
                return l_376;
            }
            else
            { /* block id: 177 */
                int32_t l_383 = 0x1A1BC2A7L;
                float **** const *l_387 = &l_372;
                int32_t l_390 = (-6L);
                for (l_357 = 9; (l_357 >= 60); l_357 += 8)
                { /* block id: 180 */
                    for (l_346 = 0; (l_346 != 12); ++l_346)
                    { /* block id: 183 */
                        float **l_382 = &l_349;
                        l_382 = l_381;
                        /* statement id: 184 */
                        assert (l_382 == 0);
                        return l_383;
                    }
                    if (l_383)
                        break;
                }
                l_375 = l_349;
                /* statement id: 189 */
                assert (l_375 == &l_350);
                l_390 = (l_374 < ((float)(l_386 == l_387) - (float)((l_383 != 0xA.80A167p-51) != (((float)l_383 - (float)__builtin_popcountll((*l_375))) < ((*l_375) <= l_383)))));
                (*l_375) = func_54(l_37, (*l_375), (*l_375), (*l_375));
            }
            /* facts after branching */
            assert (l_375 == &l_350);
        }
        else
        { /* block id: 193 */
            float l_391 = 0x1.0p-1;
            int32_t l_393 = 0x5A2EF250L;
            int32_t *l_392 = &l_393;
            int32_t **l_394 = &l_360;
            (*l_392) = l_357;
            (*l_394) = l_349;
            /* statement id: 195 */
            assert (l_360 == &l_350);
        }
        /* facts after branching */
        assert (l_360 == &l_350 || l_360 == 0);
        (*l_396) = &l_349;
    }
    if (l_37)
    { /* block id: 199 */
        uint16_t l_398 = 0x57F7L;
        int32_t *l_399 = &l_37;
        const int32_t *l_401 = &l_37;
        const int32_t **l_400 = &l_401;
        uint8_t l_406 = 0UL;
        float **l_424 = (void*)0;
        int32_t *l_469 = &l_37;
        (*l_399) = l_398;
        (*l_399) = __builtin_ctzll((*l_399));
        (*l_400) = &l_37;
        for (l_37 = 0; (l_37 != 24); l_37++)
        { /* block id: 205 */
            const uint32_t l_405 = 1UL;
            int32_t l_411 = 0xD3B933D1L;
            uint16_t l_416 = 0xD949L;
            int32_t *l_425 = (void*)0;
            uint16_t l_431 = 0xAE5FL;
            const uint16_t l_441 = 0x5C7FL;
            uint64_t l_471 = 0xFCF75B379C0B1A54LL;
            int32_t l_474 = 0xF33E96E9L;
            int32_t l_479 = (-4L);
            int32_t *l_478 = &l_479;
            if (l_404)
                break;
        }
    }
    else
    { /* block id: 257 */
        uint32_t l_499 = 18446744073709551612UL;
        int32_t l_506 = 2L;
        for (l_37 = 0; (l_37 < (-9)); l_37--)
        { /* block id: 260 */
            const int32_t *****l_488 = &l_484;
            int32_t * const l_520 = &l_37;
            int32_t * const *l_519 = &l_520;
            l_488 = l_483;
            for (l_464 = 0; (l_464 == (-5)); l_464--)
            { /* block id: 264 */
                int32_t l_498 = 0x6CCA64ABL;
                const int32_t l_503 = 4L;
                const int32_t *l_502 = &l_503;
                int32_t * const l_510 = &l_506;
                int32_t * const *l_509 = &l_510;
            }
            (****l_483) = (void*)0;
            /* statement id: 278 */
            assert (l_487 == 0);
        }
        /* facts after for loop */
        assert (l_487 == 0 || l_487 == &l_37);
    }
    /* facts after branching */
    assert (l_487 == 0 || l_487 == &l_37);
    return l_521;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(const uint64_t  p_46, int16_t  p_47, int16_t  p_48, const int32_t  p_49)
{ /* block id: 166 */
    int32_t l_348 = (-1L);
    int32_t *l_347 = &l_348;
    (*l_347) = 6L;
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_54(uint64_t  p_55, uint8_t  p_56, int64_t  p_57, const float  p_58)
{ /* block id: 40 */
    int32_t *l_70 = (void*)0;
    int32_t **l_69 = &l_70;
    const int64_t l_326 = 0x7984CDCF2E0697B8LL;
    float l_340 = 0x4.D72312p+99;
    float *l_339 = &l_340;
    float **l_338 = &l_339;
    (*l_69) = (void*)0;
    for (p_56 = (-3); (p_56 >= 2); p_56++)
    { /* block id: 44 */
        int32_t * const *l_108 = &l_70;
        int32_t l_345 = 8L;
        for (p_57 = 0; (p_57 == (-5)); p_57 -= 8)
        { /* block id: 47 */
            uint16_t l_107 = 0x147CL;
            float l_113 = 0xF.000286p+18;
            int32_t **l_248 = &l_70;
            int32_t l_305 = 1L;
            int32_t *l_304 = &l_305;
            const float *l_316 = &l_113;
            const float **l_315 = &l_316;
            (*l_304) = ((uint16_t)((uint16_t)(0x067D5B4499C77E21LL != ((int16_t)(-(uint32_t)(~(3UL <= func_83(p_57, ((int64_t)func_91(func_95((((int64_t)p_56 + (int64_t)1L) < (1L & func_103(l_107, l_108, (!1UL)))), l_107, p_57, p_57, l_107), l_248, p_56) / (int64_t)(-5L)), p_56, l_108, p_55)))) >> (int16_t)2)) >> (uint16_t)11) << (uint16_t)15);
            (*l_304) = 2L;
            if (p_57)
                continue;
            for (l_305 = 0; (l_305 == (-22)); l_305--)
            { /* block id: 142 */
                int64_t l_314 = 0x26D5457A2E974CBELL;
                int32_t ** const *l_317 = &l_248;
                float **l_323 = (void*)0;
                int32_t l_344 = 0x9E2DA4D1L;
            }
        }
        if (l_345)
            continue;
    }
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_83(uint32_t  p_84, uint64_t  p_85, uint32_t  p_86, int32_t * const * p_87, float  p_88)
{ /* block id: 101 */
    float l_249 = 0xA.1DB4CFp-8;
    int32_t l_257 = 0L;
    int32_t **l_259 = (void*)0;
    int32_t ** const *l_258 = &l_259;
    int32_t *l_260 = &l_257;
    float *l_291 = &l_249;
    float * const *l_290 = &l_291;
    float * const **l_289 = &l_290;
    float ** const *l_303 = (void*)0;
    float ** const **l_302 = &l_303;
    float ** const ***l_301 = &l_302;
    if ((p_84 | 18446744073709551609UL))
    { /* block id: 102 */
        float *l_255 = &l_249;
        float **l_254 = &l_255;
        int32_t l_262 = (-8L);
        for (p_85 = (-25); (p_85 == 4); ++p_85)
        { /* block id: 105 */
            int32_t *l_253 = (void*)0;
            int32_t **l_252 = &l_253;
            float ** const l_256 = &l_255;
            int32_t *l_261 = &l_257;
            l_260 = func_149(l_252, (0x49C4L != 1L), (l_254 == l_256), __builtin_bswap64(l_257), l_258);
            /* statement id: 106 */
            assert (l_260 == 0);
            (*l_261) = 0x63DA6633L;
        }
        /* facts after for loop */
        assert (l_260 == 0 || l_260 == &l_257);
        l_262 = p_84;
    }
    else
    { /* block id: 110 */
        int32_t **l_263 = &l_260;
        float *l_264 = &l_249;
        int32_t l_268 = 1L;
        int32_t ***l_299 = &l_259;
        int32_t **** const l_298 = &l_299;
        uint8_t l_300 = 1UL;
        (*l_263) = (*p_87);
        /* statement id: 111 */
        //assert (l_260 == 0 || l_260 == &l_305);
        (*l_264) = p_86;
        for (p_86 = 22; (p_86 <= 56); p_86 += 6)
        { /* block id: 115 */
            uint32_t l_267 = 7UL;
            return l_267;
        }
        if ((l_268 != ((uint64_t)1UL + (uint64_t)(l_268 || l_268))))
        { /* block id: 118 */
            int32_t *l_273 = &l_268;
            float **l_293 = &l_291;
            float ***l_292 = &l_293;
            float ****l_294 = &l_292;
            (*l_273) = ((uint32_t)p_86 + (uint32_t)l_268);
            for (p_86 = 0; (p_86 < 60); ++p_86)
            { /* block id: 122 */
                uint64_t l_284 = 9UL;
                (*l_273) = ((*l_273) == (((uint16_t)((p_85 & (p_84 | ((*l_273) > (((uint16_t)(p_85 < ((*l_273) ^ 0x5E15677DB30F1BEDLL)) << (uint16_t)(1UL > ((int16_t)(4UL > p_86) << (int16_t)11))) > l_284)))) == l_284) >> (uint16_t)8) & p_86));
                (**l_290) = ((((*l_273) == (&p_87 != &l_263)) != ((float)p_84 + (float)__builtin_parityl((l_284 < func_91(l_273, &l_273, (((int16_t)(l_289 != l_292) << (int16_t)15) <= p_84)))))) > p_86);
                l_268 = 0L;
            }
            (*l_294) = &l_290;
            /* statement id: 127 */
            assert (l_292 == &l_290);
            (****l_294) = p_88;
        }
        else
        { /* block id: 129 */
            (*l_264) = (((!(p_88 > ((void*)0 != l_263))) != __builtin_ctz(((((uint16_t)__builtin_clzll(p_84) >> (uint16_t)5) | (4L == 0x4D7D783D8B824882LL)) <= ((void*)0 != l_298)))) != 0x9.FF4ED3p-11);
            return l_300;
        }
    }
    /* facts after branching */
    //assert (l_260 == 0 || l_260 == &l_257 || l_260 == &l_305);
    l_301 = l_301;
    (*l_291) = p_85;
    return p_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_91(int32_t * p_92, int32_t ** p_93, const uint16_t  p_94)
{ /* block id: 99 */
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_95(int32_t  p_96, uint32_t  p_97, uint32_t  p_98, const int32_t  p_99, float  p_100)
{ /* block id: 51 */
    int32_t *l_120 = (void*)0;
    int32_t **l_119 = &l_120;
    int32_t l_130 = 0xBD88186FL;
    uint64_t l_131 = 0UL;
    const float l_240 = 0x8.B95618p-28;
    float **l_245 = (void*)0;
    int32_t *l_246 = &l_130;
    int32_t *l_247 = (void*)0;
    (*l_119) = func_114(l_119, &l_119, (((p_96 < p_99) | ((uint64_t)((~p_99) & ((uint32_t)((uint32_t)6UL - (uint32_t)(((p_96 > p_97) <= ((uint16_t)(p_98 | l_130) - (uint16_t)p_96)) == l_131)) / (uint32_t)p_98)) + (uint64_t)p_97)) ^ l_130), p_99);
    (*l_119) = func_149(&l_120, ((int16_t)((l_130 <= 0x5D88C539L) & p_97) >> (int16_t)3), (0UL < (__builtin_parityll(((uint32_t)p_96 % (uint32_t)p_98)) >= (((l_245 == (void*)0) | p_99) != p_99))), p_98, &l_119);
    return l_247;
    /* statement id: 98 */
    //assert (func_95_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_103(uint32_t  p_104, int32_t * const * p_105, uint32_t  p_106)
{ /* block id: 48 */
    int32_t * const l_111 = (void*)0;
    int32_t * const *l_110 = &l_111;
    int32_t * const **l_112 = &l_110;
    (*l_112) = l_110;
    return p_104;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_114(int32_t ** p_115, int32_t *** p_116, uint8_t  p_117, uint16_t  p_118)
{ /* block id: 52 */
    int32_t l_133 = (-1L);
    int32_t *l_132 = &l_133;
    float *l_231 = (void*)0;
    float ***l_232 = (void*)0;
    const float l_236 = 0x8.DDB30Ep+94;
    const float *l_235 = &l_236;
    const float **l_234 = &l_235;
    const float ***l_233 = &l_234;
    int32_t *l_237 = (void*)0;
    (**p_116) = l_132;
    /* statement id: 53 */
    //assert (l_120 == &l_133);
    for (l_133 = 0; (l_133 < 9); l_133 += 4)
    { /* block id: 56 */
        int16_t l_145 = (-1L);
        int32_t * const *l_225 = &l_132;
        float l_227 = 0x0.3p-1;
        float *l_226 = &l_227;
        (*l_226) = ((float)func_138(((float)p_117 / (float)((0x1.DEE132p-35 != ((float)(*l_132) / (float)(*l_132))) == (-(float)__builtin_popcount((l_145 >= (*l_132))))))) - (float)((((float)(!__builtin_ffsll((func_103(__builtin_bswap64((*l_132)), l_225, p_118) == (-9L)))) / (float)0xE.B96E4Ap+23) != p_117) < p_118));
    }
    (*l_132) = (0x6.F35BB4p-30 > (-(float)(p_118 > ((float)(*l_132) / (float)0x0.0B1FDEp-6))));
    (*l_233) = &l_231;
    /* statement id: 94 */
    assert (l_234 == &l_231);
    return l_237;
    /* statement id: 95 */
    //assert (l_120 == dangling);
    //assert (func_114_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_138(float  p_139)
{ /* block id: 57 */
    int32_t l_146 = 0x47B9DA01L;
    int32_t **l_155 = (void*)0;
    for (l_146 = 0; (l_146 >= (-17)); l_146--)
    { /* block id: 60 */
        float l_156 = 0x4.2AC9E0p+57;
        int32_t l_157 = 0xE810F1DDL;
        int32_t *l_219 = (void*)0;
        int32_t **l_218 = &l_219;
        (*l_218) = func_149(l_155, l_157, (l_157 || (l_157 >= l_157)), l_157, &l_155);
        for (l_157 = 0; (l_157 >= 3); l_157 += 7)
        { /* block id: 85 */
            (*l_218) = (*l_218);
        }
        (*l_218) = (*l_218);
    }
    return p_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_149(int32_t ** p_150, int32_t  p_151, uint16_t  p_152, int32_t  p_153, int32_t ** const * p_154)
{ /* block id: 61 */
    uint8_t l_174 = 4UL;
    int32_t l_211 = 0x7979DB4EL;
    int32_t *l_210 = &l_211;
    int32_t * const *l_209 = &l_210;
    int32_t **l_213 = &l_210;
    int32_t *l_214 = &l_211;
    int32_t *l_215 = &l_211;
    int32_t *l_216 = &l_211;
    int32_t *l_217 = (void*)0;
    for (p_153 = 0; (p_153 == (-29)); p_153--)
    { /* block id: 64 */
        int32_t l_161 = 0xB8CEE114L;
        int32_t *l_160 = &l_161;
        uint32_t l_175 = 1UL;
        int64_t l_192 = 5L;
        const int32_t *l_208 = &l_161;
        const int32_t **l_207 = &l_208;
        if (((void*)0 == l_160))
        { /* block id: 65 */
            int64_t l_169 = 8L;
            int16_t l_193 = 2L;
            int32_t **l_206 = &l_160;
            for (l_161 = (-19); (l_161 < (-28)); --l_161)
            { /* block id: 68 */
                int32_t **l_166 = (void*)0;
                int32_t ***l_165 = &l_166;
                int32_t ****l_164 = &l_165;
                float l_179 = 0x9.4F57EBp-97;
                float *l_178 = &l_179;
                (*l_164) = &p_150;
                /* statement id: 69 */
                assert (l_165 == &p_150);
                (*l_178) = (((float)l_169 - (float)0x0.2p-1) == ((float)((float)l_174 - (float)l_175) / (float)((float)(*l_160) + (float)0x6.FCBA47p+74)));
            }
            (*l_160) = ((uint16_t)((int32_t)((int64_t)(func_103(((int32_t)(*l_160) - (int32_t)(p_153 <= 0x402E7910L)), p_150, ((uint16_t)(((void*)0 == &p_150) <= (-6L)) << (uint16_t)((int64_t)l_192 % (int64_t)18446744073709551615UL))) != (*l_160)) + (int64_t)l_193) / (int32_t)(-7L)) - (uint16_t)(-1L));
            (*l_160) = p_151;
            (*l_160) = __builtin_bswap32(((int32_t)((uint32_t)((((int16_t)p_153 % (int16_t)((uint32_t)func_103((func_103((func_103((((void*)0 == &l_161) ^ l_169), p_150, ((int16_t)((l_206 == l_207) && (func_103(((**l_206) != p_153), p_150, p_153) > (**l_207))) >> (int16_t)9)) <= p_151), l_209, (*l_210)) & (**l_207)), &l_210, (*l_160)) % (uint32_t)(**l_206))) != 0xDF77L) | (**l_209)) + (uint32_t)0x8E731B53L) / (int32_t)0x6E8D0335L));
        }
        else
        { /* block id: 75 */
            int32_t *l_212 = (void*)0;
            (*l_207) = l_212;
            /* statement id: 76 */
            assert (l_208 == 0);
        }
        /* facts after branching */
        assert (l_208 == 0 || l_208 == &l_161);
        (*l_207) = (*l_209);
        /* statement id: 78 */
        assert (l_208 == &l_211);
    }
    (*l_213) = &p_151;
    /* statement id: 80 */
    assert (l_210 == &p_151);
    return l_217;
    /* statement id: 81 */
    //assert (func_149_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_36();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 141
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 21
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 134

XXX times a variable address is taken: 123
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 64
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 3
   depth: 3, occurrence: 0
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 442

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 171
   level: 2, occurrence: 97
   level: 3, occurrence: 30
   level: 4, occurrence: 17
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 77
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 32.8
XXX average alias set size: 1.28

XXX times a non-volatile is read: 533
XXX times a non-volatile is write: 178
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 94
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 23
   depth: 2, occurrence: 29
   depth: 3, occurrence: 10
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 20.8
XXX percentage an existing variable is used: 79.2
********************* end of statistics **********************/

