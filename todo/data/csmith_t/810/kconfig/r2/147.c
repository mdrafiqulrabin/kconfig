/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2838971712
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_31(void);
inline static float  func_32(uint32_t  p_33, int16_t  p_34, int32_t  p_35, int32_t  p_36, uint32_t  p_37);
static int16_t  func_41(int16_t  p_42);
static int16_t  func_43(uint32_t  p_44, int32_t  p_45, uint16_t  p_46, float  p_47, int16_t  p_48);
inline static int32_t  func_54(int16_t  p_55);
inline static int16_t  func_60(float  p_61, int16_t  p_62, uint32_t  p_63, float  p_64);
inline static int16_t  func_65(uint32_t  p_66, uint16_t  p_67, uint16_t  p_68, int16_t  p_69);
inline static int16_t  func_75(uint32_t  p_76, int16_t  p_77, uint16_t  p_78, uint32_t  p_79);
inline static uint32_t  func_80(int32_t  p_81, float  p_82, int32_t  p_83, uint16_t  p_84, uint16_t  p_85);
static float  func_86(uint32_t  p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_31(void)
{ /* block id: 36 */
    uint16_t l_38 = 9UL;
    int16_t l_51 = 0x9964L;
    uint16_t l_311 = 0UL;
    float l_330 = 0xE.ED0E2Ep+98;
    l_330 = func_32(l_38, l_38, l_38, (((int16_t)func_41(func_43(((((l_38 && ((int32_t)((l_51 != ((l_51 > (((int32_t)func_54((((int16_t)__builtin_parity((__builtin_clzll(l_51) <= (1L & 65528UL))) % (int16_t)0x6339L) && 3UL)) + (int32_t)l_51) != 4294967295UL)) & l_38)) | 0xE292L) % (int32_t)4UL)) > l_38) && l_51) | l_311), l_311, l_38, l_38, l_51)) >> (int16_t)1) == 65531UL), l_311);
    return l_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_32(uint32_t  p_33, int16_t  p_34, int32_t  p_35, int32_t  p_36, uint32_t  p_37)
{ /* block id: 247 */
    int32_t *l_328 = (void*)0;
    int32_t **l_329 = &l_328;
    (*l_329) = l_328;
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_41(int16_t  p_42)
{ /* block id: 241 */
    int32_t l_317 = 0L;
    int32_t *l_316 = &l_317;
    int32_t **l_315 = &l_316;
    float *l_322 = (void*)0;
    float **l_321 = &l_322;
    float ***l_320 = &l_321;
    float ****l_319 = &l_320;
    float *****l_318 = &l_319;
    int32_t *l_327 = &l_317;
    (*l_315) = (void*)0;
    (*l_315) = (void*)0;
    l_318 = l_318;
    (*l_327) = ((uint16_t)((uint32_t)p_42 - (uint32_t)p_42) >> (uint16_t)p_42);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_43(uint32_t  p_44, int32_t  p_45, uint16_t  p_46, float  p_47, int16_t  p_48)
{ /* block id: 234 */
    int32_t l_314 = 3L;
    for (p_48 = 0; (p_48 >= 15); p_48 += 9)
    { /* block id: 237 */
        return p_44;
    }
    return l_314;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_54(int16_t  p_55)
{ /* block id: 37 */
    uint16_t l_74 = 0x42FAL;
    int32_t l_187 = 1L;
    int32_t l_193 = 9L;
    int32_t *l_192 = &l_193;
    uint32_t l_207 = 0x7827581FL;
    float l_295 = 0xD.3F0311p+78;
    float *l_294 = &l_295;
    float **l_293 = &l_294;
    float ***l_292 = &l_293;
    int32_t ***l_308 = (void*)0;
    int32_t **l_310 = &l_192;
    int32_t ***l_309 = &l_310;
    l_187 = (((((int16_t)func_60(p_55, ((((2L != (func_65(((uint16_t)(p_55 || (p_55 && (((((uint16_t)l_74 + (uint16_t)l_74) <= ((l_74 <= p_55) >= func_75(func_80(p_55, p_55, p_55, l_74, p_55), l_74, p_55, p_55))) >= p_55) > p_55))) << (uint16_t)4), l_74, p_55, l_74) && p_55)) >= l_74) != l_74) > 0x1C71L), l_74, l_74) << (int16_t)12) <= l_74) & 0x252EC475L) <= 0xDA5914D9L);
    for (l_187 = 24; (l_187 < 6); l_187 -= 1)
    { /* block id: 136 */
        int32_t l_191 = 0x8EFB7419L;
        int32_t *l_190 = &l_191;
        (*l_190) = 1L;
        (*l_190) = p_55;
        if (p_55)
            continue;
        l_192 = &l_187;
    }
    for (l_74 = (-4); (l_74 >= 50); l_74 += 1)
    { /* block id: 144 */
        uint32_t l_204 = 0x7D859D8DL;
        int32_t *l_216 = &l_187;
        uint32_t l_245 = 0x5F2194A6L;
        int32_t l_249 = (-2L);
        float ***l_296 = &l_293;
        int32_t **l_307 = &l_216;
    }
    (*l_309) = &l_192;
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_60(float  p_61, int16_t  p_62, uint32_t  p_63, float  p_64)
{ /* block id: 123 */
    int16_t l_173 = 0x5D86L;
    uint32_t l_174 = 4294967295UL;
    int32_t l_183 = 1L;
    int32_t *l_182 = &l_183;
    float l_186 = 0x1.2p-1;
    float *l_185 = &l_186;
    if (((int32_t)(!0x4BB2L) - (int32_t)((int32_t)((__builtin_ffsll(p_62) < p_63) | ((l_173 < p_62) ^ (l_174 && (l_174 || (!p_62))))) - (int32_t)l_174)))
    { /* block id: 124 */
        int32_t l_177 = 1L;
        int32_t *l_176 = &l_177;
        (*l_176) = l_174;
    }
    else
    { /* block id: 126 */
        float l_179 = (-0x1.Dp-1);
        float *l_178 = &l_179;
        int32_t l_181 = 0L;
        int32_t *l_180 = &l_181;
        int32_t **l_184 = &l_182;
        (*l_178) = p_62;
        (*l_180) = l_174;
        (*l_184) = l_182;
    }
    (*l_185) = p_63;
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_65(uint32_t  p_66, uint16_t  p_67, uint16_t  p_68, int16_t  p_69)
{ /* block id: 50 */
    float *l_110 = (void*)0;
    int32_t l_112 = 0x018BFD1EL;
    float **l_122 = (void*)0;
    int32_t *l_124 = &l_112;
    for (p_68 = 0; (p_68 <= 4); p_68 += 1)
    { /* block id: 53 */
        float l_109 = 0xA.0016C6p-46;
        float *l_108 = &l_109;
        int32_t l_116 = 9L;
        int32_t *l_120 = &l_116;
        uint32_t l_138 = 0x89D4FE02L;
        for (p_69 = 0; (p_69 >= (-18)); p_69 -= 1)
        { /* block id: 56 */
            uint16_t l_105 = 0x7CC8L;
            int32_t *l_113 = &l_112;
            int32_t **l_121 = &l_113;
            if (l_105)
            { /* block id: 57 */
                int32_t *l_107 = (void*)0;
                int32_t **l_106 = &l_107;
                (*l_106) = (void*)0;
                if (p_66)
                { /* block id: 59 */
                    (*l_106) = (*l_106);
                }
                else
                { /* block id: 61 */
                    int32_t l_111 = 0L;
                    (*l_108) = func_86((l_108 != l_110));
                    l_111 = 0xA206E71DL;
                    l_112 = l_112;
                    (*l_106) = l_113;
                }
                l_112 = ((((uint16_t)0UL % (uint16_t)0x63A2L) | l_116) | (p_66 < ((int16_t)(__builtin_ctzl(p_67) || ((__builtin_popcountl(((l_113 != (void*)0) > p_68)) > p_69) <= 1UL)) >> (int16_t)0)));
            }
            else
            { /* block id: 68 */
                uint32_t l_119 = 0x1DFF66F6L;
                (*l_113) = p_66;
                (*l_113) = l_119;
                (*l_113) = (0xEDB7DE59L & 0x29F9B9B7L);
                l_120 = l_113;
            }
            (*l_121) = &l_116;
            (*l_113) = p_68;
        }
        if ((*l_120))
        { /* block id: 77 */
            int32_t *l_123 = &l_116;
            int32_t **l_128 = &l_120;
            l_122 = &l_108;
            l_124 = l_123;
            for (p_66 = (-1); (p_66 >= 49); p_66 += 1)
            { /* block id: 82 */
                float *l_127 = &l_109;
                (*l_124) = (l_127 == (void*)0);
                (*l_123) = (*l_120);
                return p_67;
            }
            (*l_128) = &l_112;
        }
        else
        { /* block id: 88 */
            float **l_143 = &l_108;
            int32_t l_146 = (-2L);
            for (l_112 = 0; (l_112 >= (-20)); l_112 -= 1)
            { /* block id: 91 */
                float ***l_132 = &l_122;
                float ****l_131 = &l_132;
                int32_t l_137 = 1L;
                int32_t **l_162 = &l_120;
                (*l_131) = &l_122;
            }
        }
    }
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_75(uint32_t  p_76, int16_t  p_77, uint16_t  p_78, uint32_t  p_79)
{ /* block id: 43 */
    for (p_78 = 0; (p_78 >= 28); p_78 += 1)
    { /* block id: 46 */
        return p_79;
    }
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_80(int32_t  p_81, float  p_82, int32_t  p_83, uint16_t  p_84, uint16_t  p_85)
{ /* block id: 38 */
    int32_t l_90 = 0xA138DBECL;
    uint32_t l_95 = 4294967295UL;
    float l_98 = 0x1.33FE8Fp-46;
    float *l_97 = &l_98;
    (*l_97) = ((((0x3.9CC132p+45 != (func_86(((p_81 ^ ((uint16_t)((l_90 > __builtin_clzl(__builtin_ffsl((0L && ((uint32_t)((int16_t)((p_83 | l_90) | (((-1L) | p_83) & p_85)) << (int16_t)5) - (uint32_t)0x324B7C80L))))) > 0x02F4L) << (uint16_t)13)) & l_95)) > l_95)) != p_85) <= 0x8.A84115p+66) >= 0x5.FF443Ap+30);
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_86(uint32_t  p_87)
{ /* block id: 39 */
    uint32_t l_96 = 4294967295UL;
    return l_96;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 68
XXX total union variables: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 21, occurrence: 1
   depth: 32, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 72

XXX times a variable address is taken: 74
XXX times a pointer is dereferenced on RHS: 28
breakdown:
   depth: 1, occurrence: 28
XXX times a pointer is dereferenced on LHS: 55
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 3
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 113

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 167
   level: 2, occurrence: 9
XXX number of pointers point to pointers: 38
XXX number of pointers point to scalars: 34
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20.8
XXX average alias set size: 1.19

XXX times a non-volatile is read: 302
XXX times a non-volatile is write: 151
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 62
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 12
   depth: 2, occurrence: 8
   depth: 3, occurrence: 11
   depth: 4, occurrence: 5

XXX percentage a fresh-made variable is used: 24.6
XXX percentage an existing variable is used: 75.4
********************* end of statistics **********************/

