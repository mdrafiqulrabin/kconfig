/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1300764512
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int32_t * func_2(int32_t  p_3, uint32_t  p_4, int32_t * p_5, uint16_t  p_6);
static int32_t * const  func_12(const int16_t  p_13, uint16_t  p_14);
static int16_t  func_23(const int32_t * p_24);
static const int32_t * func_25(uint32_t  p_26, int32_t  p_27);
static uint32_t  func_28(int16_t  p_29, const uint32_t  p_30, int32_t  p_31, int32_t * p_32);
static uint16_t  func_35(uint16_t  p_36, int32_t  p_37, int32_t * p_38, const int32_t  p_39);
static int32_t  func_40(int8_t  p_41, const int32_t  p_42, int32_t  p_43, int32_t * p_44);
static uint16_t  func_48(int32_t * p_49, int32_t  p_50, uint16_t  p_51);
static int32_t * func_52(int32_t * p_53, uint32_t  p_54, int32_t * p_55, uint16_t  p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_9 = 0x3921DED6L;
    const int32_t *l_8 = &l_9;
    const int32_t **l_357 = &l_8;
    (*l_357) = func_2((~(((void*)0 == l_8) & (*l_8))), (*l_8), &l_9, ((safe_lshift_func_uint16_t_u_s(0x2A8DL, (*l_8))) && 0x18A5L));
    /* statement id: 129 */
    assert (l_8 == 0);
    return l_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(int32_t  p_3, uint32_t  p_4, int32_t * p_5, uint16_t  p_6)
{ /* block id: 1 */
    const uint32_t l_18 = 3UL;
    int32_t l_58 = 0x92764969L;
    int32_t *l_57 = &l_58;
    int32_t l_59 = (-1L);
    int32_t *l_82 = (void*)0;
    int32_t *l_90 = &l_59;
    const int32_t *l_349 = (void*)0;
    const int32_t **l_348 = &l_349;
    int32_t *l_356 = (void*)0;
    (*l_348) = func_12((((safe_add_func_int32_t_s_s((&p_3 == (void*)0), (safe_unary_minus_func_uint16_t_u((0x0F4FL == (((l_18 || l_18) & (safe_rshift_func_uint16_t_u_s(((safe_sub_func_int16_t_s_s(func_23(func_25(func_28(p_6, (safe_rshift_func_int16_t_s_u(l_18, func_35(l_18, func_40((safe_unary_minus_func_int32_t_s((safe_lshift_func_int16_t_s_u((func_48(func_52(l_57, p_3, &l_58, l_59), p_3, p_6) ^ 1L), 13)))), p_4, p_6, l_82), l_90, (*p_5)))), p_6, l_57), l_18)), p_3)) == p_6), 1))) > 9L)))))) & 0x8F3C2C29L) < p_4), p_3);
    (*l_90) = (*l_57);
    (*l_57) = (((safe_unary_minus_func_uint32_t_u((((*p_5) && (-6L)) | (safe_sub_func_uint16_t_u_u(p_4, (safe_lshift_func_uint16_t_u_s((!0L), 14))))))) | (p_3 >= p_4)) | (*l_90));
    return l_356;
    /* statement id: 128 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_12(const int16_t  p_13, uint16_t  p_14)
{ /* block id: 117 */
    uint32_t l_318 = 0xF2C9B0C5L;
    int32_t l_335 = 0x151F2F3DL;
    int32_t l_344 = 7L;
    int32_t * const l_343 = &l_344;
    int32_t * const l_345 = &l_344;
    int32_t * const l_346 = &l_344;
    int32_t * const l_347 = (void*)0;
    if (((safe_sub_func_int32_t_s_s(l_318, ((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((((p_14 || (((safe_add_func_uint16_t_u_u((safe_sub_func_int32_t_s_s(((p_13 >= (((l_318 != ((4UL | (safe_rshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(p_14, (safe_mod_func_uint32_t_u_u(((((safe_add_func_uint16_t_u_u(l_318, 0x444AL)) && p_14) && p_14) >= 0xF4C61EB7L), p_14)))), 2))) || l_318)) > l_335) ^ p_14)) | l_318), 1UL)), 0x35C8L)) >= 2UL) <= 8UL)) || p_13) > p_14), p_13)), l_318)) ^ l_318))) < l_335))
    { /* block id: 118 */
        int32_t l_337 = 0xD8A5F0AEL;
        int32_t *l_336 = &l_337;
        (*l_336) = 0L;
    }
    else
    { /* block id: 120 */
        int8_t l_338 = (-1L);
        int32_t l_340 = 0x18A17545L;
        int32_t *l_339 = &l_340;
        int32_t **l_341 = (void*)0;
        int32_t **l_342 = &l_339;
        (*l_339) = l_338;
        (*l_342) = &l_340;
    }
    return l_347;
    /* statement id: 124 */
    //assert (func_12_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_23(const int32_t * p_24)
{ /* block id: 62 */
    const int32_t l_206 = 0x0B29F1C3L;
    int32_t l_208 = 0x3C314682L;
    int32_t *l_207 = &l_208;
    int32_t **l_247 = &l_207;
    int32_t ***l_246 = &l_247;
    int32_t ****l_245 = &l_246;
    int32_t *****l_244 = &l_245;
    int16_t l_266 = 0x00A6L;
    uint32_t l_313 = 0UL;
    const uint32_t l_314 = 4UL;
    uint32_t l_315 = 18446744073709551615UL;
    (*l_207) = l_206;
    for (l_208 = 6; (l_208 != (-16)); l_208 = safe_sub_func_int16_t_s_s(l_208, 1))
    { /* block id: 66 */
        int32_t l_211 = 0xBFA45521L;
        const int32_t *l_218 = &l_211;
        const int32_t **l_217 = &l_218;
        const int32_t ***l_239 = (void*)0;
        const int32_t ****l_238 = &l_239;
        uint16_t l_240 = 65529UL;
        uint32_t l_267 = 0xBCE9E383L;
        uint16_t l_288 = 1UL;
        int8_t l_289 = 0x3DL;
        int32_t l_290 = 0x09BAAA91L;
        int32_t l_304 = 0L;
        int32_t ***l_305 = &l_247;
        for (l_211 = 0; (l_211 <= (-15)); --l_211)
        { /* block id: 69 */
            int32_t **l_214 = &l_207;
            int16_t l_221 = 0L;
            int32_t l_243 = 0x93796DFDL;
            int32_t *****l_248 = &l_245;
            const int32_t *l_284 = &l_208;
            int32_t *****l_286 = &l_245;
            int32_t l_287 = 1L;
            (*l_214) = (void*)0;
            /* statement id: 70 */
            assert (l_207 == 0);
        }
        l_290 = ((((**l_244) == l_305) ^ ((l_206 & ((!(-9L)) & (safe_add_func_int16_t_s_s((((*l_217) == (*l_217)) || (0x495E9E3DL & (**l_217))), (((safe_rshift_func_uint16_t_u_s((((*l_218) | 65529UL) || 0UL), l_313)) > (*l_218)) <= (**l_217)))))) ^ l_314)) <= (**l_217));
    }
    /* facts after for loop */
    assert (l_207 == 0 || l_207 == &l_208);
    return l_315;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_25(uint32_t  p_26, int32_t  p_27)
{ /* block id: 56 */
    int32_t l_191 = (-1L);
    int32_t *l_190 = &l_191;
    int32_t **l_192 = (void*)0;
    const int32_t **l_193 = (void*)0;
    int32_t **l_194 = &l_190;
    const int32_t *l_202 = &l_191;
    const int32_t *l_203 = &l_191;
    const int32_t *l_204 = &l_191;
    const int32_t *l_205 = (void*)0;
    (*l_194) = l_190;
    (*l_190) = (0xBA6E04B3L && (p_27 ^ 0x4F707354L));
    (**l_194) = ((*l_190) || ((safe_add_func_uint32_t_u_u((0x11E1L || (safe_rshift_func_uint16_t_u_s(((((!0x3608L) || 65532UL) && (0UL & (*l_190))) & (**l_194)), 14))), (p_27 <= ((((&l_194 != &l_193) == p_27) < (-5L)) && 3L)))) <= 0xD9788A37L));
    (*l_190) = (1L >= (((65535UL || (p_26 & (0xC2FFL == 65535UL))) <= p_27) < 0xB338L));
    return l_205;
    /* statement id: 61 */
    //assert (func_25_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_28(int16_t  p_29, const uint32_t  p_30, int32_t  p_31, int32_t * p_32)
{ /* block id: 32 */
    int32_t l_104 = 5L;
    int32_t *l_103 = &l_104;
    int32_t **l_102 = &l_103;
    int32_t ***l_101 = &l_102;
    int32_t ****l_100 = &l_101;
    int16_t l_162 = 0x5BFAL;
    int32_t l_187 = 0x070889BAL;
    if (((safe_rshift_func_int16_t_s_s((((safe_sub_func_int32_t_s_s(((void*)0 != l_100), (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s(p_29, (0UL > (0xCBABL ^ (0x66F6L < ((void*)0 != (*l_100))))))), (***l_101))))) | 9L) != (**l_102)), 9)) & (*p_32)))
    { /* block id: 33 */
        int16_t l_109 = (-4L);
        int32_t *l_110 = (void*)0;
        int32_t * const *l_138 = &l_110;
        int32_t * const **l_137 = &l_138;
        int32_t * const ***l_136 = &l_137;
        int32_t l_152 = (-1L);
        uint32_t l_173 = 0UL;
        (*l_103) = ((****l_100) == l_109);
        if ((((l_110 == (*l_102)) || (!(***l_101))) || (***l_101)))
        { /* block id: 35 */
            (**l_102) = (*p_32);
            (*p_32) = 1L;
        }
        else
        { /* block id: 38 */
            const int32_t l_118 = 0x0FDB04FCL;
            int32_t ***l_147 = (void*)0;
            if ((safe_rshift_func_int16_t_s_u(((p_30 != (0xA4F77C9AL && (safe_mod_func_uint32_t_u_u(((safe_mod_func_uint32_t_u_u(l_118, (((safe_sub_func_int16_t_s_s((1UL >= ((((*p_32) != 0x9D4FE02EL) > (safe_add_func_int16_t_s_s(((!(safe_rshift_func_uint16_t_u_s(p_30, (safe_mod_func_int16_t_s_s((((((p_30 || (safe_lshift_func_int16_t_s_u((((*l_103) > (*p_32)) < 0x5DD65D98L), 6))) > p_31) != l_118) >= 7UL) < p_30), p_30))))) & l_118), p_31))) >= l_118)), 0x6DA8L)) > p_29) ^ (*p_32)))) & (*p_32)), 0x68C91577L)))) != p_31), p_30)))
            { /* block id: 39 */
                int32_t ****l_139 = (void*)0;
                int32_t l_163 = 0L;
                int32_t l_172 = 1L;
                (*p_32) = (safe_sub_func_int32_t_s_s((safe_mod_func_int16_t_s_s(l_118, (safe_mod_func_uint32_t_u_u((l_136 == l_139), ((**l_102) && (l_118 || ((**l_102) <= 0x07E6L))))))), 0xDD2F3D6CL));
                (****l_100) = ((l_118 != ((!((safe_sub_func_int32_t_s_s(((safe_sub_func_int32_t_s_s(((**l_136) == &p_32), (safe_lshift_func_uint16_t_u_s(((((((*l_136) == l_147) == ((!(safe_unary_minus_func_uint16_t_u((((safe_lshift_func_int16_t_s_s(((p_30 != (0xA9BDD0B6L > l_152)) & (((safe_mod_func_int16_t_s_s((*l_103), 0xD823L)) >= 0xDAFFDA28L) | p_29)), 3)) || 4294967289UL) ^ p_30)))) | p_29)) && 0xA5914D98L) < (*p_32)) <= p_31), (*l_103))))) >= p_30), (***l_101))) | 0x4F53L)) >= p_29)) > (*l_103));
                (*p_32) = ((((*l_101) == (void*)0) >= ((*l_136) != (*l_100))) && (safe_rshift_func_int16_t_s_u((((safe_rshift_func_int16_t_s_s((((safe_unary_minus_func_int16_t_s((*l_103))) != (p_31 < (l_162 > (*p_32)))) < p_31), l_163)) && (***l_101)) == 0UL), 0)));
                (*p_32) = (safe_lshift_func_uint16_t_u_u((((***l_136) == (void*)0) <= p_30), (p_29 ^ (p_29 <= (((((safe_add_func_uint32_t_u_u(1UL, (safe_rshift_func_uint16_t_u_s(((safe_add_func_uint16_t_u_u(p_30, ((1L > (-5L)) != p_29))) <= p_30), 6)))) && (***l_101)) < l_172) || p_31) && p_30)))));
            }
            else
            { /* block id: 44 */
                int32_t l_176 = 0x41CF9FCAL;
                (***l_101) = l_173;
                (****l_100) = ((safe_sub_func_uint32_t_u_u(((-3L) > (l_176 > p_29)), 0UL)) | ((p_31 > (((l_176 && ((safe_sub_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(p_29, ((safe_add_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(((safe_add_func_int32_t_s_s((0x0461CA15L & ((*p_32) == (*p_32))), 0x0A0F2B41L)) <= 1L), p_29)), p_31)) <= l_187))), 0xE156L)) < 0x696DL)) < (-1L)) & (**l_102))) != 0x573C08D3L));
            }
            (*l_103) = (safe_rshift_func_uint16_t_u_u(p_29, 5));
        }
        (*p_32) = 0xB1F7435FL;
    }
    else
    { /* block id: 51 */
        (***l_100) = (void*)0;
        /* statement id: 52 */
        assert (l_103 == 0);
        (*p_32) = (*p_32);
    }
    /* facts after branching */
    assert (l_103 == 0 || l_103 == &l_104);
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_35(uint16_t  p_36, int32_t  p_37, int32_t * p_38, const int32_t  p_39)
{ /* block id: 26 */
    int32_t l_93 = 1L;
    int32_t *l_92 = &l_93;
    int32_t **l_91 = &l_92;
    int32_t ***l_95 = &l_91;
    int32_t ****l_94 = &l_95;
    (*l_91) = &p_39;
    /* statement id: 27 */
    assert (l_92 == &p_39);
    (*l_94) = &l_91;
    (*l_95) = &p_38;
    /* statement id: 29 */
    assert (l_91 == &p_38);
    (**l_91) = (((***l_95) == (0xAD8FL <= (**l_91))) < (((p_37 == (p_36 == (&l_95 == &l_95))) < 0xFB2EF76CL) >= (p_36 != (***l_95))));
    return (**l_91);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_40(int8_t  p_41, const int32_t  p_42, int32_t  p_43, int32_t * p_44)
{ /* block id: 20 */
    int32_t **l_84 = (void*)0;
    int32_t ***l_83 = &l_84;
    int32_t l_86 = (-1L);
    int32_t *l_85 = &l_86;
    int32_t l_89 = (-3L);
    p_44 = p_44;
    (*l_85) = ((void*)0 == l_83);
    l_89 = ((((p_42 > (&l_84 == &l_84)) && 0x693CL) && (p_44 != p_44)) < (p_41 | (p_43 || ((*l_85) ^ p_43))));
    p_44 = p_44;
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_48(int32_t * p_49, int32_t  p_50, uint16_t  p_51)
{ /* block id: 17 */
    int8_t l_81 = 1L;
    (*p_49) = l_81;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_52(int32_t * p_53, uint32_t  p_54, int32_t * p_55, uint16_t  p_56)
{ /* block id: 2 */
    int32_t l_68 = 6L;
    int32_t *l_67 = &l_68;
    int32_t **l_70 = &l_67;
    int32_t *** const l_69 = &l_70;
    int32_t ***l_72 = &l_70;
    int32_t ****l_71 = &l_72;
    for (p_56 = (-10); (p_56 > 42); p_56 = safe_add_func_int16_t_s_s(p_56, 1))
    { /* block id: 5 */
        int32_t l_63 = 0xF121F205L;
        int32_t *l_62 = &l_63;
        int32_t **l_64 = &l_62;
        (*l_64) = l_62;
        for (p_54 = 21; (p_54 >= 32); p_54 = safe_add_func_uint16_t_u_u(p_54, 4))
        { /* block id: 9 */
            (*l_64) = l_67;
            /* statement id: 10 */
            assert (l_62 == &l_68);
        }
        /* facts after for loop */
        assert (l_62 == &l_68 || l_62 == &l_63);
    }
    (*l_71) = l_69;
    (*p_55) = (((p_56 & (p_54 || ((((*l_67) != (safe_lshift_func_uint16_t_u_s((((*p_55) > (***l_69)) == (p_56 < ((*l_72) != (void*)0))), 13))) == ((safe_mod_func_int16_t_s_s((*l_67), p_54)) <= (*p_53))) != (***l_72)))) > p_54) && (***l_72));
    (***l_72) = (p_54 != ((****l_71) > (((((&l_72 != &l_72) || (safe_lshift_func_int16_t_s_u(((0xEC8E4446L | p_56) & ((*l_71) != (*l_71))), p_56))) | (-1L)) != 0x444FL) <= p_56)));
    return p_55;
    /* statement id: 16 */
    //assert (func_52_rv == &l_58);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 72
XXX total union variables: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 20, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 2
   depth: 39, occurrence: 1

XXX total number of pointers: 80

XXX times a variable address is taken: 74
XXX times a pointer is dereferenced on RHS: 104
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 24
   depth: 3, occurrence: 14
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 42
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 3
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 362

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 108
   level: 2, occurrence: 63
   level: 3, occurrence: 39
   level: 4, occurrence: 28
   level: 5, occurrence: 15
XXX number of pointers point to pointers: 38
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30
XXX average alias set size: 1.12

XXX times a non-volatile is read: 505
XXX times a non-volatile is write: 128
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 59
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 12
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6

XXX percentage a fresh-made variable is used: 11.2
XXX percentage an existing variable is used: 88.8
********************* end of statistics **********************/

