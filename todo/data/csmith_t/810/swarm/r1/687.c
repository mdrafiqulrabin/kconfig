/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      3495879726
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   const int16_t  f0;
   uint32_t  f1;
};

union U1 {
   volatile int16_t  f0;
   volatile int16_t  f1;
   volatile int32_t  f2;
   int32_t  f3;
   float  f4;
};

/* --- GLOBAL VARIABLES --- */
static const union U1 g_15 = {0x4FFC};/* VOLATILE GLOBAL g_15 */
static const union U1 *g_14 = &g_15;
static volatile int32_t g_16 = (-4);/* VOLATILE GLOBAL g_16 */
static int32_t g_17 = 1;
static float g_22 = 0xA.E24307p+7;
static volatile int32_t * volatile g_47 = &g_16;/* VOLATILE GLOBAL g_47 */
static volatile int32_t * volatile * volatile g_46 = &g_47;/* VOLATILE GLOBAL g_46 */
static union U0 g_49 = {0x19AE};
static union U1 g_51 = {0x82A7};/* VOLATILE GLOBAL g_51 */
static volatile int32_t g_64 = 9;/* VOLATILE GLOBAL g_64 */
static volatile int32_t *g_63 = &g_64;
static volatile int32_t **g_62 = &g_63;
static int32_t *g_81 = &g_17;
static int32_t ** volatile g_80 = &g_81;/* VOLATILE GLOBAL g_80 */
static volatile int32_t *g_125 = &g_16;
static int32_t ** volatile g_134 = (void*)0;/* VOLATILE GLOBAL g_134 */
static int32_t ** volatile g_135 = &g_81;/* VOLATILE GLOBAL g_135 */
static int32_t g_138 = 1;
static int32_t ** volatile *g_261 = (void*)0;
static int32_t ** volatile ** volatile g_260 = &g_261;/* VOLATILE GLOBAL g_260 */
static union U1 g_278 = {0x2CA8};/* VOLATILE GLOBAL g_278 */
static union U1 g_281 = {0x889F};/* VOLATILE GLOBAL g_281 */
static int32_t ** volatile g_289 = &g_81;/* VOLATILE GLOBAL g_289 */
static union U1 * volatile g_294 = &g_278;/* VOLATILE GLOBAL g_294 */
static union U1 * volatile *g_293 = &g_294;
static union U1 * volatile ** volatile g_292 = &g_293;/* VOLATILE GLOBAL g_292 */
static uint16_t g_323 = 0xCF9F;
static union U1 g_325 = {0xD062};/* VOLATILE GLOBAL g_325 */
static union U0 **g_399 = (void*)0;
static union U1 * volatile ** volatile *g_410 = &g_292;
static union U1 * volatile ** volatile ** volatile g_409 = &g_410;/* VOLATILE GLOBAL g_409 */
static union U1 g_448 = {0};/* VOLATILE GLOBAL g_448 */
static union U0 g_495 = {0x2897};
static union U1 g_559 = {-1};/* VOLATILE GLOBAL g_559 */
static int32_t *g_577 = &g_138;
static union U1 g_676 = {1};/* VOLATILE GLOBAL g_676 */
static union U1 g_678 = {-1};/* VOLATILE GLOBAL g_678 */
static union U1 *g_677 = &g_678;
static uint16_t g_698 = 0xFE44;
static union U1 *g_701 = &g_51;


/* --- FORWARD DECLARATIONS --- */
inline static float  func_1(void);
static union U1 * func_2(uint16_t  p_3, union U1 * p_4, uint32_t  p_5, union U1 * p_6);
inline static union U1  func_9(union U1 * p_10, union U0  p_11);
static union U1  func_12(const union U1 * p_13);
static union U0  func_23(float * p_24, union U1 * p_25, float * p_26, uint16_t  p_27);
inline static union U1  func_28(const float  p_29, float  p_30);
inline static float  func_31(float * p_32, uint32_t  p_33);
static int32_t * func_36(float * p_37, uint16_t  p_38);
static uint32_t  func_39(int32_t * p_40, union U0  p_41, union U1 * p_42);
static int32_t * func_43(uint32_t  p_44);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_14 g_17 g_15 g_15.f1 g_46 g_49 g_62 g_49.f0 g_15.f0 g_63 g_16 g_64 g_80 g_47 g_51.f3 g_51.f1 g_22 g_81 g_125 g_135 g_138 g_51 g_51.f0 g_49.f1 g_289 g_292 g_293 g_294 g_278 g_278.f0 g_281.f0 g_323 g_325 g_278.f3 g_260 g_261 g_676 g_677 g_678.f0 g_495.f0 g_698 g_577 g_701 g_325.f0
 * writes: g_17 g_22 g_46 g_81 g_63 g_51.f3 g_47 g_16 g_64 g_49.f1 g_138 g_292 g_278.f3 g_577 g_294
 */
inline static float  func_1(void)
{ /* block id: 0 */
    union U1 *l_326 = &g_281;
    union U0 l_327 = {0};
    (*g_293) = func_2(((0xCDEA > ((uint16_t)(func_9((func_12(g_14) , l_326), l_327) , ((l_327.f0 >= 5) < (g_15.f1 , l_327.f0))) + (uint16_t)(-1))) >= l_327.f0), l_326, l_327.f0, g_677);
    /* statement id: 294 */
    assert (g_63 == &g_16 || g_63 == &g_64);
        assert (g_294 == &g_51);
    assert (g_577 == &g_17);
    return g_325.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_16 g_64 g_138 g_678.f0 g_495.f0 g_278.f3 g_49.f0 g_80 g_81 g_62 g_698 g_46 g_577 g_701
 * writes: g_46 g_577 g_17
 */
static union U1 * func_2(uint16_t  p_3, union U1 * p_4, uint32_t  p_5, union U1 * p_6)
{ /* block id: 290 */
    uint16_t l_682 = 0x2717;
    int32_t **l_699 = &g_577;
    (*l_699) = func_43(((int16_t)((~(((((((*g_63) >= (g_138 == l_682)) && p_5) && ((((-(int16_t)(((g_678.f0 >= ((uint16_t)8U * (uint16_t)((((((((uint16_t)((int16_t)((uint16_t)((int32_t)(g_495.f0 && ((int16_t)(0 >= ((uint32_t)(l_682 | l_682) + (uint32_t)p_5)) << (int16_t)13)) % (int32_t)p_5) * (uint16_t)l_682) * (int16_t)65535U) << (uint16_t)15) && (-3)) | g_278.f3) , p_5) != p_5) == 0x6AE9B6DB) | p_5))) & p_5) & g_49.f0)) <= l_682) & l_682) == 0x9228FCCA)) && l_682) , (*g_80)) == (*g_62))) <= g_698) % (int16_t)p_3));
    /* statement id: 291 */
    assert (g_577 == &g_17);
    (**l_699) = (+(p_3 && (-1)));
    return g_701;
    /* statement id: 293 */
    //assert (func_2_rv == &g_51);
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_138 g_278.f3 g_81 g_17 g_63 g_135 g_260 g_261 g_22 g_676
 * writes: g_278.f3 g_16 g_64 g_17 g_22
 */
inline static union U1  func_9(union U1 * p_10, union U0  p_11)
{ /* block id: 147 */
    float *l_328 = &g_22;
    uint32_t l_335 = 6U;
    union U1 *l_346 = &g_278;
    union U1 **l_345 = &l_346;
    union U1 ***l_344 = &l_345;
    union U0 *l_398 = &g_49;
    union U0 **l_397 = &l_398;
    int32_t l_433 = 0xFE222A19;
    int32_t *l_572 = (void*)0;
    float *l_574 = &g_22;
    union U0 *l_643 = (void*)0;
    float *l_664 = &g_22;
    if (((((((void*)0 == l_328) <= g_16) , (p_11.f0 < ((uint16_t)(&g_293 == (void*)0) - (uint16_t)p_11.f0))) == (-(int32_t)((p_11.f0 , 9) >= p_11.f0))) <= g_138))
    { /* block id: 148 */
        union U1 **l_334 = (void*)0;
        const int32_t l_336 = 0xD43211AB;
        for (g_278.f3 = (-17); (g_278.f3 <= 5); g_278.f3 += 6)
        { /* block id: 151 */
            (*g_63) = (((void*)0 == l_334) < ((l_335 != ((l_335 < l_336) <= (0x2F513778 | ((int32_t)(l_336 != (((float)0x2.2149DFp-44 * (float)l_335) , p_11.f0)) - (int32_t)(*g_81))))) == 9U));
            (**g_135) = (((((int16_t)p_11.f0 - (int16_t)(0xB9AC ^ p_11.f0)) <= (~l_336)) || l_336) & ((((((void*)0 == l_344) | l_335) ^ l_335) , 0x8562) >= p_11.f0));
            l_344 = (void*)0;
            /* statement id: 154 */
            assert (l_344 == 0);
            if (l_335)
                continue;
        }
        /* facts after for loop */
        assert (l_344 == 0 || l_344 == &l_345);
    }
    else
    { /* block id: 157 */
        int32_t ** const l_360 = &g_81;
        int32_t ** const *l_359 = &l_360;
        int32_t ** const **l_358 = &l_359;
        union U1 **l_372 = &l_346;
        union U0 l_426 = {0};
        const float l_434 = 0x7.C957AFp-91;
        uint32_t l_435 = 0xB9D94C1E;
        float *l_513 = &g_22;
        uint16_t l_526 = 0xD2C6;
        float * const l_556 = &g_278.f4;
        uint16_t l_558 = 65535U;
        float l_594 = 0xB.9C4B21p-67;
        int32_t *l_654 = &g_138;
        (*l_328) = (((float)(((!((uint16_t)((uint32_t)((int16_t)((int16_t)(l_358 == &g_261) % (int16_t)p_11.f0) * (int16_t)p_11.f0) % (uint32_t)p_11.f0) - (uint16_t)((*g_260) != (*l_358)))) , (l_335 , (+(((uint16_t)((void*)0 == &p_11) * (uint16_t)(****l_358)) , 0xA.A997E5p+32)))) > 0x5.CE0839p+48) + (float)g_22) < 0x3.4D8659p+94);
        for (g_278.f3 = (-6); (g_278.f3 > 20); g_278.f3 += 2)
        { /* block id: 161 */
            uint32_t l_379 = 0x3E966DBC;
            int32_t *l_412 = &g_138;
            union U1 *l_447 = &g_448;
            union U1 ****l_460 = &l_344;
            union U0 *l_475 = &g_49;
            uint32_t l_479 = 0xAACA16AE;
            uint16_t l_502 = 0x5E8A;
        }
        /* facts after for loop */
    }
    /* facts after branching */
    assert (l_344 == 0 || l_344 == &l_345);
    return g_676;
    /* statement id: 289 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_17 g_14 g_15 g_15.f1 g_46 g_49 g_62 g_49.f0 g_15.f0 g_63 g_16 g_64 g_80 g_47 g_51.f3 g_51.f1 g_22 g_81 g_125 g_135 g_138 g_51 g_51.f0 g_49.f1 g_289 g_292 g_293 g_294 g_278 g_278.f0 g_281.f0 g_323 g_325
 * writes: g_17 g_22 g_46 g_81 g_63 g_51.f3 g_47 g_16 g_64 g_49.f1 g_138 g_292
 */
static union U1  func_12(const union U1 * p_13)
{ /* block id: 1 */
    int16_t l_20 = 0;
    float *l_21 = &g_22;
    union U1 *l_311 = &g_278;
    const union U0 *l_313 = (void*)0;
    const union U0 ** const l_312 = &l_313;
    int32_t l_324 = 0x740A228F;
    for (g_17 = 0; (g_17 == 10); g_17 += 1)
    { /* block id: 4 */
        return (*g_14);
        /* statement id: 5 */
            }
    (*l_21) = l_20;
    (*l_21) = 0x0.426A76p-64;
    l_324 = (((func_23(l_21, (func_28(func_31(l_21, l_20), g_138) , l_311), l_21, ((l_312 != &l_313) && l_20)) , g_281.f0) >= g_323) < l_20);
    return g_325;
    /* statement id: 146 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_138 g_17 g_46 g_80 g_47 g_63 g_16 g_51.f1 g_49.f0 g_22 g_51.f3 g_14 g_15 g_81 g_125 g_135 g_278.f0
 * writes: g_46 g_81 g_63 g_51.f3 g_22 g_47 g_16 g_138 g_17
 */
static union U0  func_23(float * p_24, union U1 * p_25, float * p_26, uint16_t  p_27)
{ /* block id: 142 */
    const int32_t *l_318 = (void*)0;
    const int32_t **l_317 = &l_318;
    const int32_t ***l_316 = &l_317;
    float *l_319 = &g_22;
    union U0 l_322 = {4};
    (*p_26) = ((float)(((((((l_316 == (void*)0) , func_36(l_319, g_138)) != (((uint16_t)(p_27 == 5) + (uint16_t)g_138) , l_318)) > g_49.f0) < g_49.f0) , g_278.f0) != 0x0.1p+1) - (float)0xB.AC240Fp+18);
    /* statement id: 143 */
    assert (g_81 == &g_17);
    return l_322;
    /* statement id: 144 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_63 g_51.f0 g_49.f0 g_138 g_125 g_64 g_17 g_62 g_49.f1 g_14 g_15 g_80 g_81 g_289 g_15.f0 g_292 g_49 g_293 g_294 g_278
 * writes: g_16 g_64 g_49.f1 g_138 g_81 g_292 g_17
 */
inline static union U1  func_28(const float  p_29, float  p_30)
{ /* block id: 78 */
    uint16_t l_164 = 65535U;
    union U1 * const l_169 = &g_51;
    union U0 *l_177 = &g_49;
    union U0 **l_176 = &l_177;
    int32_t * const l_186 = &g_17;
    int32_t **l_202 = (void*)0;
    int32_t ***l_201 = &l_202;
    volatile int32_t **l_206 = (void*)0;
    int32_t l_287 = 0xAC7D101B;
    uint16_t l_310 = 0xC362;
    (*g_63) = (+l_164);
    if (l_164)
        goto lbl_178;
lbl_178:
    (*g_125) = (l_164 <= (((uint16_t)((int16_t)(g_51.f0 , (l_169 == l_169)) << (int16_t)g_49.f0) - (uint16_t)(((uint32_t)(((((int16_t)((int16_t)((0x9D697DB5 & ((((l_164 , ((l_164 < (l_176 == &l_177)) != g_138)) != l_164) , l_164) >= g_138)) , g_138) >> (int16_t)l_164) * (int16_t)(-1)) == 0U) > l_164) <= l_164) - (uint32_t)l_164) , g_49.f0)) & 0xC8FC));
    if (((~l_164) ^ ((((int16_t)l_164 + (int16_t)((uint16_t)((int16_t)g_64 >> (int16_t)g_17) >> (uint16_t)11)) , l_186) == (*g_62))))
    { /* block id: 82 */
        const int32_t l_191 = 3;
        union U0 l_241 = {0xE74A};
        float *l_249 = &g_22;
        float l_250 = 0x1.D6A654p+86;
        union U0 ** const l_252 = &l_177;
        int16_t l_277 = (-1);
        for (g_49.f1 = 21; (g_49.f1 < 34); g_49.f1 += 1)
        { /* block id: 85 */
            uint16_t l_193 = 0xA3B7;
            union U0 l_194 = {9};
            int32_t *l_203 = (void*)0;
            union U1 ** const l_255 = (void*)0;
            for (g_138 = 6; (g_138 < 11); g_138 += 4)
            { /* block id: 88 */
                union U0 l_192 = {0xE7E0};
                int32_t ***l_213 = &l_202;
                float *l_246 = (void*)0;
                if (l_191)
                    break;
            }
            return (*g_14);
            /* statement id: 134 */
                    }
        /* facts after for loop */
                (*g_289) = (*g_80);
    }
    else
    { /* block id: 137 */
        g_292 = (((uint16_t)g_15.f0 >> (uint16_t)1) , g_292);
    }
    (*l_186) = ((uint16_t)((int16_t)g_15.f0 >> (int16_t)7) + (uint16_t)((((g_17 != ((((*l_186) <= ((int32_t)(*l_186) + (int32_t)(((uint16_t)(*l_186) >> (uint16_t)g_17) > (+(*l_186))))) && (*l_186)) > ((((int32_t)(((int16_t)((int32_t)((**l_176) , 0x5A0D80B1) + (int32_t)(*l_186)) - (int16_t)(*l_186)) && 0x11F5) + (int32_t)g_49.f0) , &g_62) != &l_202))) == 7U) || (*l_186)) ^ l_310));
    return (**g_293);
    /* statement id: 141 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_17 g_15.f1 g_46 g_49 g_62 g_49.f0 g_15.f0 g_63 g_16 g_64 g_80 g_47 g_51.f3 g_51.f1 g_22 g_14 g_15 g_81 g_125 g_135 g_138 g_51
 * writes: g_17 g_46 g_22 g_81 g_63 g_51.f3 g_47 g_16
 */
inline static float  func_31(float * p_32, uint32_t  p_33)
{ /* block id: 9 */
    int32_t l_72 = 9;
    int32_t *l_137 = &g_138;
    int32_t ***l_142 = (void*)0;
    union U0 l_154 = {0x812A};
    for (g_17 = (-23); (g_17 < (-24)); g_17 -= 4)
    { /* block id: 12 */
        union U1 *l_50 = &g_51;
        int32_t l_71 = 0xDDF936BB;
        int32_t **l_139 = &g_81;
        float l_157 = 0xE.04A83Bp+70;
        float l_162 = 0x1.42021Ap+30;
        l_137 = func_36(p_32, (((func_39(func_43((+g_15.f1)), g_49, l_50) , (((uint16_t)((l_71 | ((*g_63) > (0xB582 | p_33))) == g_17) >> (uint16_t)14) || l_72)) | 0x0576189E) , l_72));
        /* statement id: 72 */
        assert (g_81 == &g_17);
        assert (l_137 == &g_22 || l_137 == &g_17);
        (*l_139) = p_32;
        /* statement id: 73 */
        assert (g_81 == &g_22);
        (**l_139) = ((((int16_t)(l_142 != l_142) + (int16_t)(0x387E9A70 <= (((int32_t)(**g_135) + (int32_t)(*l_137)) , ((uint16_t)(((void*)0 == (*l_139)) > ((0x341A <= (p_33 ^ p_33)) <= p_33)) % (uint16_t)p_33)))) > p_33) , (*p_32));
        (*g_47) = ((-(uint16_t)g_138) < (((int16_t)((uint16_t)(((0xED6609A1 & ((uint16_t)(((l_154 , (*l_50)) , ((((((uint16_t)g_64 - (uint16_t)(**l_139)) < (*g_81)) >= ((((int32_t)((uint16_t)p_33 * (uint16_t)(9 == 0U)) + (int32_t)p_33) && g_17) == 9)) <= p_33) == p_33)) & 65532U) - (uint16_t)p_33)) < g_138) != g_138) % (uint16_t)g_17) * (int16_t)3U) >= 0x0E52));
    }
    /* facts after for loop */
    assert (g_81 == &g_22 || g_81 == &g_17);
    assert (l_137 == &g_17 || l_137 == &g_22 || l_137 == &g_138);
    return (*p_32);
}


/* ------------------------------------------ */
/* 
 * reads : g_17 g_46 g_80 g_47 g_51.f3 g_63 g_16 g_51.f1 g_49.f0 g_22 g_14 g_15 g_81 g_125 g_135
 * writes: g_46 g_81 g_63 g_51.f3 g_22 g_47 g_16
 */
static int32_t * func_36(float * p_37, uint16_t  p_38)
{ /* block id: 19 */
    const union U0 l_77 = {-10};
    union U1 *l_79 = &g_51;
    union U0 l_105 = {-6};
    int32_t **l_136 = &g_81;
    for (p_38 = 0; (p_38 < 6); p_38 += 6)
    { /* block id: 22 */
        const int16_t l_75 = 0x900F;
        int32_t l_76 = 0x06037BAD;
        union U0 l_78 = {6};
        volatile int32_t * volatile *l_82 = &g_63;
        float *l_106 = &g_51.f4;
        int32_t *l_122 = &l_76;
        (*g_80) = func_43(((l_75 ^ (l_76 && ((l_77 , (l_78 , l_79)) == l_79))) , g_17));
        /* statement id: 23 */
        assert (g_81 == &g_17);
        if (p_38)
            break;
        (*l_82) = (*g_46);
        /* statement id: 25 */
        assert (g_63 == &g_16);
        for (g_51.f3 = 0; (g_51.f3 == (-12)); g_51.f3 -= 1)
        { /* block id: 28 */
            int16_t l_102 = 0xF881;
            union U0 *l_128 = &l_78;
            if ((*g_63))
                break;
            (*p_37) = ((float)0x0.Ep-1 + (float)((float)g_51.f1 - (float)(g_49.f0 < ((float)l_77.f0 + (float)(g_22 >= ((float)0x0.4p+1 + (float)((float)(l_77.f0 >= ((float)((float)l_77.f0 * (float)((-(float)(((float)(0x1.6p-1 < (*p_37)) * (float)l_102) >= g_51.f3)) != l_102)) * (float)g_51.f3)) * (float)0x2.Ep-1)))))));
            (*p_37) = (-0x3.9p+1);
            for (l_78.f1 = 0; (l_78.f1 <= 60); l_78.f1 += 8)
            { /* block id: 34 */
                int32_t l_121 = 0xAAA13A23;
                (*p_37) = (l_77.f0 , (p_38 , ((l_105 , (((*g_14) , l_106) != p_37)) >= l_105.f0)));
                (*p_37) = g_49.f0;
                if (((int32_t)(p_38 == ((uint32_t)((int16_t)p_38 << (int16_t)p_38) * (uint32_t)(((uint32_t)((int16_t)g_51.f3 + (int16_t)(**l_82)) + (uint32_t)((0U != ((((g_17 == g_49.f0) >= ((uint16_t)p_38 % (uint16_t)g_49.f0)) > g_49.f0) != (*g_81))) > g_49.f0)) <= 4294967286U))) - (int32_t)(-7)))
                { /* block id: 37 */
                    l_121 = ((uint16_t)0U >> (uint16_t)8);
                }
                else
                { /* block id: 39 */
                    l_122 = func_43(l_77.f0);
                    /* statement id: 40 */
                    assert (l_122 == &g_17);
                    for (l_102 = 0; (l_102 <= 28); l_102 += 3)
                    { /* block id: 43 */
                        (*g_46) = g_125;
                        return (*g_80);
                        /* statement id: 45 */
                        //assert (func_36_rv == &g_17);
                    }
                    (*p_37) = 0x2.C64AC2p-97;
                    if (p_38)
                        break;
                }
                for (l_102 = 0; (l_102 > (-6)); l_102 -= 1)
                { /* block id: 52 */
                    union U0 **l_129 = &l_128;
                    (*l_129) = l_128;
                    for (l_76 = 0; (l_76 == (-10)); l_76 -= 1)
                    { /* block id: 56 */
                        (*g_63) = p_38;
                        return p_37;
                        /* statement id: 58 */
                        //assert (func_36_rv == &g_22);
                    }
                    for (l_105.f1 = (-17); (l_105.f1 != 2); l_105.f1 += 1)
                    { /* block id: 62 */
                        return p_37;
                        /* statement id: 63 */
                        //assert (func_36_rv == &g_22);
                    }
                    /* facts after for loop */
                                    }
            }
            /* facts after for loop */
                    }
        /* facts after for loop */
        assert (l_122 == &g_17 || l_122 == &l_76);
    }
    (*g_135) = func_43(g_16);
    /* statement id: 69 */
    assert (g_81 == &g_17);
    (*l_136) = (*g_135);
    return p_37;
    /* statement id: 71 */
    //assert (func_36_rv == &g_22);
}


/* ------------------------------------------ */
/* 
 * reads : g_15.f1 g_62 g_17 g_49.f0 g_15.f0
 * writes: g_22
 */
static uint32_t  func_39(int32_t * p_40, union U0  p_41, union U1 * p_42)
{ /* block id: 16 */
    int32_t *l_52 = (void*)0;
    const int32_t l_65 = 0xD69B12DB;
    uint16_t l_66 = 0xF317;
    float *l_67 = &g_22;
    int32_t l_68 = 0;
    (*l_67) = (((((((void*)0 != l_52) >= ((int16_t)(((uint16_t)((((void*)0 == p_40) != (g_15.f1 <= 0xADE8)) , (-(uint16_t)0xEAA4)) % (uint16_t)((int16_t)(((uint32_t)((void*)0 == g_62) + (uint32_t)1) < g_17) * (int16_t)l_65)) & g_49.f0) * (int16_t)g_49.f0)) , g_15.f0) >= l_66) > g_17) > g_49.f0);
    return l_68;
}


/* ------------------------------------------ */
/* 
 * reads : g_46
 * writes: g_46
 */
static int32_t * func_43(uint32_t  p_44)
{ /* block id: 13 */
    volatile int32_t * volatile * volatile *l_48 = &g_46;
    (*l_48) = g_46;
    return &g_17;
    /* statement id: 15 */
    //assert (func_43_rv == &g_17);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_15.f0, "g_15.f0", print_hash_value);
    transparent_crc(g_15.f1, "g_15.f1", print_hash_value);
    transparent_crc(g_16, "g_16", print_hash_value);
    transparent_crc(g_17, "g_17", print_hash_value);
    transparent_crc_bytes (&g_22, sizeof(g_22), "g_22", print_hash_value);
    transparent_crc(g_49.f0, "g_49.f0", print_hash_value);
    transparent_crc(g_51.f0, "g_51.f0", print_hash_value);
    transparent_crc(g_51.f1, "g_51.f1", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc(g_138, "g_138", print_hash_value);
    transparent_crc(g_278.f0, "g_278.f0", print_hash_value);
    transparent_crc(g_278.f1, "g_278.f1", print_hash_value);
    transparent_crc(g_278.f2, "g_278.f2", print_hash_value);
    transparent_crc(g_278.f3, "g_278.f3", print_hash_value);
    transparent_crc_bytes (&g_278.f4, sizeof(g_278.f4), "g_278.f4", print_hash_value);
    transparent_crc(g_281.f0, "g_281.f0", print_hash_value);
    transparent_crc(g_281.f1, "g_281.f1", print_hash_value);
    transparent_crc(g_323, "g_323", print_hash_value);
    transparent_crc(g_325.f0, "g_325.f0", print_hash_value);
    transparent_crc(g_325.f1, "g_325.f1", print_hash_value);
    transparent_crc(g_448.f0, "g_448.f0", print_hash_value);
    transparent_crc(g_448.f1, "g_448.f1", print_hash_value);
    transparent_crc(g_495.f0, "g_495.f0", print_hash_value);
    transparent_crc(g_559.f0, "g_559.f0", print_hash_value);
    transparent_crc(g_559.f1, "g_559.f1", print_hash_value);
    transparent_crc(g_676.f0, "g_676.f0", print_hash_value);
    transparent_crc(g_676.f1, "g_676.f1", print_hash_value);
    transparent_crc(g_678.f0, "g_678.f0", print_hash_value);
    transparent_crc(g_678.f1, "g_678.f1", print_hash_value);
    transparent_crc(g_698, "g_698", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 147
XXX total union variables: 19

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 17
   depth: 3, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 136

XXX times a variable address is taken: 134
XXX times a pointer is dereferenced on RHS: 141
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 27
   depth: 3, occurrence: 11
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 77
breakdown:
   depth: 1, occurrence: 63
   depth: 2, occurrence: 7
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 388

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 481
   level: 2, occurrence: 70
   level: 3, occurrence: 39
   level: 4, occurrence: 15
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 63
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.3
XXX average alias set size: 1.28

XXX times a non-volatile is read: 832
XXX times a non-volatile is write: 193
XXX times a volatile is read: 107
XXX    times read thru a pointer: 32
XXX times a volatile is write: 27
XXX    times written thru a pointer: 15
XXX times a volatile is available for access: 257
XXX percentage of non-volatile access: 88.4

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 73
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 15
   depth: 2, occurrence: 10
   depth: 3, occurrence: 5
   depth: 4, occurrence: 8
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 17
XXX percentage an existing variable is used: 83
********************* end of statistics **********************/

