/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3851896944
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 6;
   int32_t  f1;
   int16_t  f2;
   int8_t  f3;
   uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static int32_t  func_2(uint32_t  p_3, struct S0  p_4, int32_t  p_5);
static struct S0  func_7(int32_t  p_8, int32_t  p_9, int8_t  p_10, uint32_t  p_11);
static struct S0  func_22(int32_t  p_23, uint32_t  p_24, int8_t  p_25, int64_t  p_26);
static uint16_t  func_29(int32_t  p_30, int16_t  p_31);
static int32_t * func_32(int32_t * p_33, uint32_t  p_34, int32_t * p_35);
static int32_t * func_36(struct S0  p_37, int32_t  p_38);
static struct S0  func_39(struct S0  p_40, int16_t  p_41, int32_t  p_42, uint32_t  p_43, uint32_t  p_44);
static struct S0  func_45(int32_t * p_46, int32_t * p_47);
static int32_t * func_48(int32_t * p_49, int32_t  p_50, int32_t  p_51);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    uint64_t l_6 = 18446744073709551615UL;
    int32_t l_1219 = 6L;
    int32_t *l_1218 = &l_1219;
    struct S0 l_1220 = {5,0xE871E07AL,0xB1FAL,0x39L,0UL};
    uint16_t l_1255 = 0xE076L;
    int32_t ***l_1269 = (void*)0;
    int32_t ****l_1268 = &l_1269;
    int32_t *****l_1267 = &l_1268;
    int64_t l_1277 = 9L;
    struct S0 **l_1285 = (void*)0;
    int32_t *l_1288 = &l_1220.f1;
    int32_t *l_1290 = &l_1220.f1;
    struct S0 ***l_1305 = &l_1285;
    struct S0 ****l_1304 = &l_1305;
    struct S0 *****l_1303 = &l_1304;
    int32_t l_1306 = 0L;
    struct S0 *l_1307 = &l_1220;
    int32_t l_1308 = 0L;
    (*l_1218) = ((func_2(l_6, func_7(l_6, l_6, l_6, ((((uint64_t)((((int64_t)((int32_t)l_6 - (int32_t)(~(((uint16_t)(-(uint16_t)((l_6 < (((func_22(((l_6 & ((uint64_t)((((-1L) >= func_29((8UL >= l_6), l_6)) || l_6) & l_6) + (uint64_t)l_6)) == l_6), l_6, l_6, l_6) , l_6) >= l_6) && 0UL)) ^ 0xEA63802CL)) - (uint16_t)l_6) < l_6))) / (int64_t)l_6) || l_6) && 0x39539541L) / (uint64_t)0xBF68952115EF3ABFLL) && l_6) , l_6)), l_6) == 4294967295UL) && l_6);
    if ((*l_1218))
    { /* block id: 394 */
        int16_t l_1223 = 0x6627L;
        int8_t l_1254 = 0x1EL;
        int64_t l_1256 = 0x3B8D261DBEBE2A37LL;
        int32_t **l_1257 = &l_1218;
        uint64_t l_1278 = 0x76F49165A4086CAFLL;
        struct S0 l_1284 = {7,6L,0L,1L,0x24A75DE8L};
        int32_t *l_1287 = &l_1219;
        (*l_1257) = func_36(l_1220, ((uint16_t)l_1223 << (uint16_t)(((int16_t)((int16_t)((int16_t)((int16_t)((((int64_t)((((uint16_t)((((uint32_t)(((((0x28E55664L & (((uint16_t)l_1223 >> (uint16_t)((((((uint16_t)((uint16_t)((uint16_t)((((int16_t)(func_45(&l_1219, &l_1219) , ((((0x6F7692CDL <= ((int32_t)((((int32_t)0x1F65918CL / (int32_t)(*l_1218)) | 5UL) , 0xCAF72624L) + (int32_t)(*l_1218))) | 0L) , (*l_1218)) == l_1254)) * (int16_t)(*l_1218)) , l_1223) < (*l_1218)) << (uint16_t)l_1255) >> (uint16_t)l_1254) - (uint16_t)0xD1EFL) != 0xFAA75057180DBA99LL) & (*l_1218)) == l_1254) || 18446744073709551615UL)) > (*l_1218))) ^ 0UL) < (*l_1218)) , l_1256) == (*l_1218)) - (uint32_t)l_1254) && 5L) , 0xEE6FL) - (uint16_t)0x95D2L) == (*l_1218)) != 0x855D3FA7A545FE79LL) % (int64_t)0x26B3077EBC3CB2F1LL) >= (*l_1218)) | l_1256) - (int16_t)l_1223) * (int16_t)l_1254) << (int16_t)4) << (int16_t)(*l_1218)) < l_1254)));
        /* statement id: 395 */
        assert (l_1218 == 0);
        for (l_1255 = 0; (l_1255 > 20); l_1255 += 2)
        { /* block id: 398 */
            int64_t l_1260 = 1L;
            int64_t l_1279 = 0xF8C3757AC33DF961LL;
            uint64_t l_1280 = 0x81CEB3AF76B1349CLL;
            int32_t l_1281 = 0x8E65F4FFL;
            l_1281 = (l_1260 < (((((((l_1260 < ((((((uint32_t)((((uint16_t)((uint16_t)((&l_1218 == l_1257) , ((void*)0 == l_1267)) >> (uint16_t)(((((int32_t)((int16_t)l_1223 - (int16_t)(l_1260 != (~((int64_t)l_1260 / (int64_t)l_1277)))) + (int32_t)0x4379E75DL) | l_1278) || l_1279) || l_1279)) / (uint16_t)0x16F5L) | 0x3A5473F3F5201E7ELL) ^ l_1279) - (uint32_t)l_1279) ^ l_1223) < l_1279) != 0x9726L) > l_1223)) && l_1260) , 0x7EB5F08EL) , (-10L)) | l_1280) > l_1279) , l_1279));
        }
        for (l_1219 = (-18); (l_1219 >= 10); ++l_1219)
        { /* block id: 403 */
            int32_t l_1286 = (-3L);
            l_1286 = ((l_1278 , (l_1284 , (void*)0)) == l_1285);
            return l_1284.f4;
        }
        (*l_1287) = l_1254;
    }
    else
    { /* block id: 408 */
        int32_t **l_1289 = &l_1288;
        (*l_1289) = l_1288;
    }
    /* facts after branching */
    assert (l_1218 == &l_1219 || l_1218 == 0);
    (*l_1307) = func_45(l_1290, (((((*l_1288) >= (*l_1288)) >= ((-1L) == (((*l_1288) != (((uint16_t)((uint16_t)((int16_t)((int16_t)(((l_1303 == (void*)0) < (-7L)) >= 65527UL) * (int16_t)0x329FL) * (int16_t)0x73B4L) >> (uint16_t)8) << (uint16_t)12) >= 0x365A9C4DF9659AB3LL)) > l_1306))) > (*l_1290)) , &l_1219));
    return l_1308;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_2(uint32_t  p_3, struct S0  p_4, int32_t  p_5)
{ /* block id: 389 */
    int32_t *l_1193 = (void*)0;
    int32_t l_1206 = 0x79E6DBA8L;
    int8_t l_1207 = (-1L);
    struct S0 l_1215 = {2,0x3BC3EF24L,0x386AL,0x13L,0x2ED2C8F8L};
    struct S0 *l_1214 = &l_1215;
    struct S0 **l_1213 = &l_1214;
    struct S0 ***l_1212 = &l_1213;
    struct S0 ****l_1211 = &l_1212;
    struct S0 *****l_1210 = &l_1211;
    int32_t **l_1216 = &l_1193;
    int32_t *l_1217 = &l_1206;
    (*l_1216) = func_32(l_1193, ((((p_4.f4 || ((uint16_t)((((uint16_t)(((int32_t)(((uint32_t)((((uint16_t)((uint32_t)(p_4.f2 && l_1206) - (uint32_t)p_4.f2) * (uint16_t)0xE4A0L) || ((((((l_1207 <= (p_3 && ((int16_t)((p_4.f0 , l_1210) == &l_1211) * (int16_t)1L))) == p_5) >= l_1215.f0) || p_4.f1) <= p_4.f2) , p_4.f0)) , p_5) - (uint32_t)p_4.f2) == l_1215.f1) - (int32_t)p_3) || p_4.f0) * (uint16_t)p_3) <= p_4.f2) >= p_4.f3) + (uint16_t)l_1215.f3)) | 0x39621BE15A11AC68LL) || p_5) , p_3), &l_1206);
    (*l_1217) = 0x935C6A21L;
    return p_4.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_7(int32_t  p_8, int32_t  p_9, int8_t  p_10, uint32_t  p_11)
{ /* block id: 145 */
    int32_t l_468 = 0xC245D851L;
    int32_t *l_467 = &l_468;
    int32_t **l_466 = &l_467;
    struct S0 l_475 = {2,0xD056996BL,1L,-4L,0xD68C842EL};
    int32_t *l_478 = (void*)0;
    struct S0 **l_564 = (void*)0;
    struct S0 ***l_563 = &l_564;
    uint32_t l_643 = 1UL;
    uint16_t l_706 = 65526UL;
    int32_t l_707 = 0x8533BF59L;
    int32_t ***l_762 = (void*)0;
    int32_t ****l_761 = &l_762;
    int8_t l_821 = 0xD7L;
    uint32_t l_951 = 0x9F6C3D2CL;
    uint32_t l_957 = 0x39E718B5L;
    int64_t l_958 = 1L;
    uint16_t l_1031 = 65526UL;
    struct S0 *****l_1078 = (void*)0;
    uint32_t l_1126 = 4UL;
    uint32_t l_1127 = 4294967293UL;
    uint32_t l_1128 = 18446744073709551613UL;
    struct S0 *l_1129 = &l_475;
    uint32_t l_1186 = 0x98CBCE38L;
    struct S0 l_1192 = {0,0x19B23A88L,1L,0L,18446744073709551610UL};
    if (((uint16_t)(-(uint32_t)0xF0104374L) << (uint16_t)14))
    { /* block id: 146 */
        int32_t l_459 = (-5L);
        int32_t *l_461 = (void*)0;
        int32_t **l_460 = &l_461;
        struct S0 l_465 = {4,0x293D730EL,0L,0x8DL,1UL};
        struct S0 *l_464 = &l_465;
        uint64_t l_473 = 0x1295B1A4478303DCLL;
        uint64_t l_481 = 18446744073709551610UL;
        int32_t l_527 = 0x471CA468L;
        struct S0 **l_530 = &l_464;
        struct S0 ***l_529 = &l_530;
        int16_t l_548 = 1L;
        int8_t l_678 = 0x32L;
        int32_t l_739 = (-4L);
        struct S0 **l_752 = (void*)0;
        int32_t l_847 = 0x38798BFEL;
        int16_t l_912 = (-1L);
        uint64_t l_917 = 1UL;
        uint32_t l_975 = 0x43FC338DL;
        struct S0 l_980 = {0,-1L,1L,0x49L,0xF142BE87L};
        int16_t l_981 = (-5L);
        int32_t *l_1003 = &l_475.f1;
        int16_t l_1044 = 0xBF3AL;
        uint32_t l_1046 = 3UL;
        int32_t *l_1050 = &l_459;
        if (((uint64_t)((uint16_t)((1UL || ((int16_t)0x66E9L << (int16_t)(l_459 & (l_460 == (((uint16_t)(l_464 == (void*)0) >> (uint16_t)13) , l_466))))) & (((uint16_t)(**l_466) % (uint16_t)((-1L) | p_8)) | 0x089E560A1FF2559CLL)) >> (uint16_t)l_459) / (uint64_t)(**l_466)))
        { /* block id: 147 */
            uint64_t l_474 = 18446744073709551612UL;
            struct S0 l_508 = {4,0L,-9L,-5L,1UL};
            struct S0 **l_514 = (void*)0;
            struct S0 ***l_513 = &l_514;
            struct S0 ****l_512 = &l_513;
            int32_t *l_516 = &l_468;
            struct S0 l_731 = {0,0L,0x4F4BL,0x6DL,0UL};
            int32_t ***l_785 = &l_460;
            if (((6UL > p_10) & ((((((((((p_11 < ((func_39(((p_9 & ((int16_t)5L * (int16_t)(0UL <= ((p_11 > ((((((((p_11 | l_473) != p_10) | 0L) == p_9) && l_474) < p_9) == (**l_466)) <= 0xEBEEA759L)) != p_11)))) , l_475), l_474, (*l_467), p_9, (**l_466)) , 0x1AD2A608L) , (*l_467))) < 7UL) || 0x28EE41843362B28ELL) & p_11) & p_11) != p_9) < p_8) != 0x47D4L) , 0x5BA14C7D38188DBCLL) == p_10)))
            { /* block id: 148 */
                int32_t l_482 = 0x53CF38F0L;
                struct S0 **l_489 = &l_464;
                struct S0 ***l_488 = &l_489;
                struct S0 ****l_487 = &l_488;
                int32_t l_547 = 0x0DE2BDF2L;
                uint64_t l_630 = 0x7F4E04A87671A741LL;
                int32_t l_631 = 0xF4DE2BB9L;
                for (p_8 = 4; (p_8 <= (-14)); p_8 -= 1)
                { /* block id: 151 */
                    struct S0 **l_490 = &l_464;
                    int32_t l_502 = 0x5869DE72L;
                    if (p_9)
                        break;
                    if (p_11)
                        break;
                }
                if ((4294967295UL | ((uint32_t)((((int64_t)(-1L) / (int64_t)l_474) , (l_508 , p_10)) , ((p_8 > (((uint16_t)(((-(int32_t)((void*)0 == l_512)) , ((-(uint64_t)0x46A76162333D6506LL) >= 18446744073709551615UL)) , l_508.f3) << (uint16_t)p_8) == l_508.f0)) > 0L)) / (uint32_t)p_9)))
                { /* block id: 161 */
                    int64_t l_528 = 0x9C47D63294EEDCF5LL;
                    int32_t *l_551 = &l_547;
                    (*l_460) = func_48(l_516, p_10, ((p_8 == ((((((&l_487 != &l_487) && (((int16_t)((uint16_t)p_9 << (uint16_t)((uint16_t)((((p_11 , (((l_482 , (((((uint16_t)(((int16_t)l_527 * (int16_t)p_10) == 4294967291UL) >> (uint16_t)4) , 0xEECA2CE9A02F5DB6LL) > l_528) > p_10)) , p_9) > p_10)) == l_528) <= (*l_516)) >= (*l_516)) % (uint16_t)p_10)) * (int16_t)p_8) <= 0x110DL)) & l_482) < 0L) , (void*)0) != l_529)) , p_11));
                    for (l_465.f3 = 0; (l_465.f3 != 13); l_465.f3++)
                    { /* block id: 165 */
                        (*l_516) = p_9;
                        (*l_460) = &p_9;
                        /* statement id: 167 */
                        assert (l_461 == &p_9);
                        (*l_466) = &p_9;
                        /* statement id: 168 */
                        assert (l_467 == &p_9);
                    }
                    /* facts after for loop */
                    assert (l_461 == &p_9 || l_461 == 0);
                    assert (l_467 == &p_9 || l_467 == &l_468);
                    (*l_516) = (((int64_t)(((0x5BFBE83BFA716B42LL ^ ((1L == ((((((((uint16_t)((uint16_t)((l_482 != (((uint16_t)l_482 + (uint16_t)(((((((int16_t)l_482 << (int16_t)((((uint32_t)(((uint32_t)p_8 - (uint32_t)(&l_530 == (p_9 , (void*)0))) && l_482) / (uint32_t)p_9) && p_11) , (*l_467))) , 0L) , &p_9) != &p_9) >= 0x944300DDB63E37F8LL) == 0xFAA1L)) & p_10)) , p_9) % (uint16_t)0xE190L) >> (uint16_t)p_11) || p_8) < 2L) & p_8) & l_547) >= (-1L)) > p_10)) & p_8)) < l_548) != p_10) - (int64_t)(*l_516)) , 0x5EC22979L);
                    for (l_482 = (-19); (l_482 != 5); l_482 += 8)
                    { /* block id: 173 */
                        (*l_466) = l_551;
                        /* statement id: 174 */
                        assert (l_467 == &l_547);
                        (*l_516) = ((uint16_t)((uint64_t)(((((*l_516) , (**l_466)) , (*l_513)) != (((**l_466) == ((p_8 != (*l_516)) , ((((~((((-9L) < 0xDC9CFD18L) & ((int16_t)((uint64_t)0x146107DB0D48962ALL % (uint64_t)(*l_467)) >> (int16_t)8)) , (**l_466))) >= p_10) >= (*l_516)) | p_9))) , (void*)0)) , p_9) / (uint64_t)p_9) << (uint16_t)p_9);
                        (*l_460) = &p_9;
                        /* statement id: 176 */
                        assert (l_461 == &p_9);
                    }
                    /* facts after for loop */
                    assert (l_467 == &l_547 || l_467 == &p_9 || l_467 == &l_468);
                }
                else
                { /* block id: 178 */
                    uint32_t l_579 = 0x71EFD2C5L;
                    struct S0 l_580 = {4,-6L,0x606BL,0L,0x81EF61D4L};
                    for (l_508.f1 = 0; (l_508.f1 != (-22)); --l_508.f1)
                    { /* block id: 181 */
                        int64_t l_572 = 1L;
                        int32_t *l_581 = &l_482;
                        int32_t *l_582 = &l_580.f1;
                        (*l_487) = l_563;
                        /* statement id: 182 */
                        assert (l_488 == &l_564);
                        (**l_489) = func_22(p_9, ((1L <= ((uint16_t)((((int16_t)(-(uint16_t)((int16_t)(0L && (l_572 ^ (((int16_t)(((void*)0 != (*l_512)) || (((uint16_t)0x2376L >> (uint16_t)9) | ((int32_t)((l_579 , l_580) , (*l_467)) / (int32_t)(-1L)))) << (int16_t)p_9) > l_572))) - (int16_t)l_580.f2)) - (int16_t)p_9) , (-3L)) || 0x0319L) * (uint16_t)p_8)) | p_9), (*l_516), (*l_467));
                        l_516 = l_581;
                        /* statement id: 184 */
                        assert (l_516 == &l_482);
                        (*l_466) = l_582;
                        /* statement id: 185 */
                        assert (l_467 == &l_580.f1);
                    }
                    /* facts after for loop */
                    assert (l_467 == &l_580.f1 || l_467 == &l_468);
                    assert (l_488 == &l_564 || l_488 == &l_489);
                    assert (l_516 == &l_482 || l_516 == &l_468);
                    return l_580;
                }
                /* facts after branching */
                assert (l_461 == &p_9 || l_461 == 0);
                assert (l_467 == &l_547 || l_467 == &p_9 || l_467 == &l_468);
                (*l_467) = ((((((int16_t)(((int16_t)(((int16_t)((uint16_t)((0x16E39AFFL & (((uint16_t)((int16_t)((((p_10 || ((((uint32_t)((int32_t)((l_482 < (p_9 , (*l_516))) < (*l_516)) + (int32_t)(**l_466)) - (uint32_t)((*l_516) >= (((uint32_t)((uint16_t)((uint16_t)l_547 * (uint16_t)p_10) % (uint16_t)1L) - (uint32_t)(*l_467)) >= p_9))) == 1L) > p_11)) ^ l_482) || (-8L)) == 0xF003FEE8L) * (int16_t)0x8F1EL) / (uint16_t)6L) > (*l_467))) <= p_11) * (uint16_t)(**l_466)) + (int16_t)0UL) ^ (*l_467)) + (int16_t)p_11) & p_8) >> (int16_t)p_8) , p_10) || (*l_516)) ^ (*l_516)) | p_9);
                for (l_475.f2 = 0; (l_475.f2 > 28); ++l_475.f2)
                { /* block id: 192 */
                    int32_t l_613 = 0x220BE0A8L;
                    struct S0 l_632 = {6,0x9E133E00L,0x7091L,0xCDL,1UL};
                    l_482 = (0x2785EC50F4389B07LL == p_10);
                    (*l_516) = ((uint64_t)(((((((p_9 | ((uint16_t)((int16_t)l_613 * (int16_t)(p_9 == (0x8D72F7C87E3B5D45LL | (p_8 ^ (p_8 & (((int32_t)((int32_t)((uint16_t)((int32_t)l_613 + (int32_t)(((((int64_t)((int32_t)(0xF378B4259D565244LL > ((uint16_t)(((int16_t)0xCA89L << (int16_t)14) , 0x254CL) - (uint16_t)0xEB45L)) % (int32_t)0x7C42DF65L) / (int64_t)l_630) && p_10) < (*l_516)) == p_8)) >> (uint16_t)7) % (int32_t)(*l_467)) + (int32_t)p_10) < (-1L))))))) >> (uint16_t)8)) || (*l_516)) , p_9) > (*l_516)) | l_631) , &l_529) == (void*)0) / (uint64_t)(*l_516));
                    return l_632;
                }
            }
            else
            { /* block id: 197 */
                int8_t l_635 = 1L;
                int32_t l_648 = 0x6A7CA8ECL;
                int8_t l_658 = (-10L);
                int64_t l_695 = 0x6840EE6719E3A81FLL;
                (*l_466) = (void*)0;
                /* statement id: 198 */
                assert (l_467 == 0);
                for (p_11 = (-12); (p_11 >= 49); p_11++)
                { /* block id: 201 */
                    int64_t l_647 = 1L;
                    int32_t *l_649 = &l_475.f1;
                    if ((p_10 <= (l_635 & (*l_516))))
                    { /* block id: 202 */
                        (*l_530) = (**l_529);
                    }
                    else
                    { /* block id: 204 */
                        uint64_t l_646 = 0x7A3E2A152F62680ELL;
                        p_9 = ((-1L) <= (0x6234L != ((-(uint64_t)(p_9 <= (((uint64_t)((p_8 == (((uint32_t)(((uint16_t)(p_11 , p_9) * (uint16_t)(l_643 || ((((int32_t)l_646 / (int32_t)l_635) && p_8) || 0x8762EF2367A982ADLL))) != l_646) % (uint32_t)p_9) && l_635)) && p_10) - (uint64_t)18446744073709551607UL) >= l_647))) || l_646)));
                        if (l_647)
                            break;
                        if (p_9)
                            break;
                        l_648 = p_9;
                    }
                    l_649 = (void*)0;
                    /* statement id: 210 */
                    assert (l_649 == 0);
                }
                if (((&l_461 == (((((int16_t)p_9 * (int16_t)((((int16_t)((uint16_t)(((p_11 <= p_11) <= l_635) | p_9) * (uint16_t)((p_11 ^ p_10) != ((((uint32_t)((void*)0 == &l_564) % (uint32_t)p_10) ^ p_8) < p_8))) + (int16_t)l_658) > 0x3182B4E709B196B5LL) == p_11)) <= 0x22B6BC46L) , p_8) , &l_461)) , p_10))
                { /* block id: 212 */
                    int64_t l_664 = (-1L);
                    struct S0 l_709 = {2,7L,0xEB5CL,0xA0L,0x6A66C8E1L};
                    (*l_516) = p_11;
                    for (l_475.f1 = 0; (l_475.f1 == 21); l_475.f1 += 4)
                    { /* block id: 216 */
                        struct S0 *****l_661 = &l_512;
                        (*l_661) = &l_563;
                        /* statement id: 217 */
                        assert (l_512 == &l_563);
                        if (l_468)
                            goto lbl_708;
                        if (p_11)
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_512 == &l_563 || l_512 == &l_513);
                    if ((((uint32_t)l_664 - (uint32_t)((uint32_t)((uint16_t)(p_10 == ((int64_t)0xA02C455BB3AC60C2LL - (int64_t)((int32_t)((7L & (((uint16_t)0x28AAL / (uint16_t)(((int64_t)(~(l_678 >= (((((((uint16_t)((((uint32_t)l_664 / (uint32_t)((int16_t)((uint16_t)((((uint16_t)((int32_t)((uint16_t)(((uint32_t)(((p_8 , p_9) >= 0x2506L) | (-1L)) / (uint32_t)0x7C4D2A16L) < p_10) >> (uint16_t)13) % (int32_t)0x140D6DFBL) << (uint16_t)p_11) == 3UL) , p_10) >> (uint16_t)p_11) << (int16_t)14)) >= p_9) , 0xD70CL) >> (uint16_t)8) , p_10) , (*l_516)) > l_648) < p_10) ^ (*l_516)))) - (int64_t)0x849CFDE55B947408LL) || p_11)) > p_11)) && p_8) / (int32_t)p_8))) >> (uint16_t)p_8) / (uint32_t)(*l_516))) < p_11))
                    { /* block id: 220 */
                        p_9 = ((p_10 < ((l_695 <= 0UL) & 0x70EFC127L)) ^ ((l_635 && (p_8 <= (((*l_512) != &l_530) != ((int64_t)((uint16_t)((((int32_t)((((int16_t)((int16_t)l_706 << (int16_t)11) - (int16_t)l_664) != 5UL) , l_707) % (int32_t)(-1L)) >= l_664) && 0L) + (uint16_t)(*l_516)) % (int64_t)0x8FF40F7E67DE3694LL)))) >= p_8));
                    }
                    else
                    { /* block id: 222 */
lbl_708:
                        (*l_466) = (*l_460);
                        return l_709;
                    }
                    for (l_706 = 0; (l_706 == 39); l_706 += 8)
                    { /* block id: 229 */
                        (***l_529) = (**l_530);
                    }
                }
                else
                { /* block id: 232 */
                    int32_t *l_712 = &l_465.f1;
                    (*l_460) = l_712;
                    /* statement id: 233 */
                    assert (l_461 == &l_465.f1);
                }
                /* facts after branching */
                assert (l_461 == &l_465.f1 || l_461 == 0);
                assert (l_512 == &l_563 || l_512 == &l_513);
            }
            /* facts after branching */
            assert (l_461 == &l_465.f1 || l_461 == 0 || l_461 == &p_9);
            //assert (l_467 == 0 || l_467 == dangling || l_467 == &p_9 || l_467 == &l_468);
            assert (l_512 == &l_563 || l_512 == &l_513);
            (*l_460) = (void*)0;
            /* statement id: 236 */
            assert (l_461 == 0);
            for (l_475.f4 = (-29); (l_475.f4 == 16); l_475.f4 += 6)
            { /* block id: 239 */
                int32_t *l_715 = (void*)0;
                uint64_t l_716 = 18446744073709551612UL;
                int8_t l_721 = 0x1CL;
                int64_t l_722 = (-10L);
                int8_t l_726 = 0xA7L;
                struct S0 l_740 = {2,1L,1L,0x50L,5UL};
                (*l_466) = func_48(func_48(l_715, p_11, l_716), ((int16_t)((uint16_t)(((p_8 > p_11) && l_721) | ((*l_513) != (*l_529))) << (uint16_t)7) - (int16_t)0xDFA2L), p_11);
                /* statement id: 240 */
                assert (l_467 == 0);
                if ((p_8 & (l_722 < ((((~p_11) && (&l_563 == (void*)0)) == 9L) ^ ((uint16_t)l_726 - (uint16_t)((uint32_t)((int16_t)(l_731 , ((p_9 && 1UL) , p_11)) >> (int16_t)12) + (uint32_t)0x59BA08C2L))))))
                { /* block id: 241 */
                    uint64_t l_736 = 0UL;
                    (*l_466) = func_48(&p_9, p_11, ((uint16_t)((int16_t)(l_736 || ((int16_t)l_739 >> (int16_t)9)) >> (int16_t)15) << (uint16_t)9));
                }
                else
                { /* block id: 243 */
                    if (p_9)
                    { /* block id: 244 */
                        return l_740;
                    }
                    else
                    { /* block id: 246 */
                        int32_t ****l_741 = (void*)0;
                        int32_t ***l_742 = &l_460;
                        struct S0 *l_743 = &l_465;
                        l_742 = &l_466;
                        /* statement id: 247 */
                        assert (l_742 == &l_466);
                        l_743 = (*l_530);
                    }
                }
            }
            for (l_474 = 0; (l_474 < 45); l_474 += 7)
            { /* block id: 254 */
                uint64_t l_763 = 0x22350376C1C0E452LL;
                int32_t *l_783 = &l_459;
                struct S0 *l_799 = &l_731;
                uint32_t l_807 = 0x88472955L;
                uint64_t l_809 = 0xBE226CBEEE59684ALL;
                uint64_t l_823 = 0x80B3F4AE90651582LL;
            }
        }
        else
        { /* block id: 278 */
lbl_856:
            for (l_527 = 23; (l_527 < (-18)); l_527 -= 1)
            { /* block id: 281 */
                struct S0 l_826 = {4,0x4F48DBEEL,0L,0xCDL,0xCD2D5FE6L};
                return l_826;
            }
        }
        /* facts after branching */
        //assert (l_467 == 0 || l_467 == dangling || l_467 == &p_9 || l_467 == &l_468);
        if (((uint16_t)(((((void*)0 != &p_9) || ((uint16_t)(&l_563 != &l_529) << (uint16_t)p_9)) < p_8) || ((int16_t)(p_8 < ((uint16_t)((*l_530) != (*l_530)) * (uint16_t)l_678)) * (int16_t)p_9)) >> (uint16_t)p_11))
        { /* block id: 285 */
            struct S0 ***l_844 = (void*)0;
            int32_t l_845 = 1L;
            struct S0 ****l_931 = &l_529;
            struct S0 *****l_930 = &l_931;
            uint16_t l_974 = 0x3576L;
lbl_936:
            p_9 = (((uint16_t)(p_10 == 1L) >> (uint16_t)7) ^ ((uint64_t)(!((uint16_t)((int16_t)0L * (int16_t)(((void*)0 == l_844) & l_845)) + (uint16_t)l_845)) + (uint64_t)(((!l_847) , (((int16_t)((int16_t)((uint16_t)(~(~((((p_9 ^ 0x368F9350L) & p_10) < p_9) != 1L))) - (uint16_t)0xE8E8L) >> (int16_t)p_10) * (int16_t)p_9) , (*l_529))) == (*l_529))));
            if (p_11)
            { /* block id: 287 */
                int32_t l_877 = (-7L);
                struct S0 ****l_894 = &l_529;
                if (l_473)
                    goto lbl_856;
                if (((uint16_t)(((uint16_t)((((((uint32_t)(((uint64_t)18446744073709551609UL % (uint64_t)((int16_t)l_845 << (int16_t)0)) , ((uint16_t)((int64_t)((int16_t)((int16_t)(((uint64_t)l_877 + (uint64_t)(0L <= ((l_877 < ((int16_t)(((int16_t)(((int16_t)((((**l_529) != (void*)0) < (((p_9 & ((int32_t)((((int64_t)((int64_t)((((((((uint16_t)p_10 * (uint16_t)p_10) , (void*)0) == l_844) , p_9) | l_845) & 0xF784L) | 0x1E21D109L) + (int64_t)p_11) % (int64_t)l_845) , l_894) == &l_844) + (int32_t)p_8)) && p_11) , l_877)) > 9L) >> (int16_t)15) < 0x2AA8D0A66DA82082LL) % (int16_t)l_877) ^ p_8) / (int16_t)0x880FL)) < p_9))) , p_8) << (int16_t)9) << (int16_t)4) / (int64_t)1L) + (uint16_t)p_9)) + (uint32_t)0x9007E778L) , p_8) , (void*)0) != &l_461) , l_877) << (uint16_t)11) , p_9) - (uint16_t)p_8))
                { /* block id: 289 */
                    uint32_t l_911 = 1UL;
                    int32_t *l_913 = &l_468;
                    struct S0 l_916 = {1,-7L,0x43C3L,0x78L,0UL};
                    struct S0 *****l_932 = &l_894;
                    int32_t l_935 = 0L;
                    for (l_707 = 0; (l_707 <= 21); l_707 += 2)
                    { /* block id: 292 */
                        struct S0 l_897 = {4,0L,1L,1L,18446744073709551612UL};
                        return l_897;
                    }
                    (***l_529) = func_45(func_32(func_36((****l_894), ((((((uint16_t)(((((uint32_t)(l_845 == ((void*)0 != &l_894)) - (uint32_t)(((int16_t)((~((uint16_t)(((((***l_894) == (*l_530)) , (0x2DBD7E87D195E5F0LL & ((uint16_t)3UL << (uint16_t)((((uint16_t)(l_911 , l_845) * (uint16_t)p_9) > l_845) >= 0xE19BE593CFB35BA3LL)))) != p_11) , 0x55E1L) + (uint16_t)p_10)) & p_8) << (int16_t)p_9) >= l_911)) && l_912) && 0x89D3L) , 0x5466L) >> (uint16_t)9) > p_11) >= l_911) == p_8) ^ p_9)), l_877, l_913), l_913);
                    (*l_913) = ((int64_t)(p_11 != (p_8 & (l_877 && (((p_10 , func_39(l_916, l_877, p_10, (p_9 , p_8), p_10)) , p_8) && p_11)))) / (int64_t)l_917);
                    p_9 = (p_11 , (((int16_t)(~((int16_t)p_8 % (int16_t)l_845)) * (int16_t)(!(((uint64_t)(p_9 | ((((int16_t)(((((uint16_t)(l_930 != l_932) + (uint16_t)(p_8 >= p_10)) == (((((int16_t)((((l_877 , l_845) , (*l_913)) & p_10) , 4L) << (int16_t)14) , (*l_563)) == (*l_529)) ^ 0x2740L)) != p_8) & p_10) - (int16_t)l_935) < 5L) || 0x15EC8E3C29101CE6LL)) + (uint64_t)(*l_913)) <= p_10))) , p_8));
                }
                else
                { /* block id: 298 */
                    if (l_473)
                        goto lbl_936;
                }
                if (l_845)
                    goto lbl_936;
                (***l_894) = (***l_894);
            }
            else
            { /* block id: 303 */
                int32_t *l_937 = &l_459;
                (*l_460) = func_32(l_937, l_739, &l_845);
            }
            for (l_468 = 5; (l_468 > 21); l_468 += 1)
            { /* block id: 308 */
                int32_t l_944 = (-1L);
                struct S0 l_959 = {5,0xE5769D1EL,-3L,0xFAL,5UL};
                int32_t ***l_973 = &l_460;
                for (l_739 = 0; (l_739 < (-25)); l_739 -= 1)
                { /* block id: 311 */
                    int16_t l_952 = 0L;
                    p_9 = ((int16_t)((l_944 && (-7L)) > (l_845 ^ ((p_8 , ((uint16_t)(((uint16_t)((int32_t)l_951 + (int32_t)((((0x80B5L != (((((l_952 != ((uint16_t)p_11 << (uint16_t)7)) , ((uint64_t)l_845 - (uint64_t)p_9)) | p_11) > l_957) | p_9)) != l_952) == l_958) & (-8L))) << (uint16_t)0) == l_845) / (uint16_t)p_10)) != 0xEDFDB1C3A1BD0A46LL))) << (int16_t)l_952);
                    return l_959;
                }
                if (l_845)
                    goto lbl_856;
                if (l_845)
                { /* block id: 316 */
                    uint32_t l_972 = 0x81309EF5L;
                    int32_t *l_976 = (void*)0;
                    int32_t *l_977 = &l_944;
                    (*l_977) = (~((int16_t)p_9 * (int16_t)(((int16_t)0x98B8L - (int16_t)(~((((int16_t)(p_10 , (((int16_t)(((uint16_t)l_972 << (uint16_t)(l_973 == (void*)0)) , l_972) >> (int16_t)14) <= (p_11 | ((func_39((***l_529), p_8, l_974, p_10, p_11) , p_8) ^ l_975)))) * (int16_t)4UL) ^ 0L) < 7L))) < l_972)));
                }
                else
                { /* block id: 318 */
                    int16_t l_978 = 0xE1BCL;
                    int32_t *l_979 = &l_944;
                    if (p_8)
                        break;
                    l_978 = p_11;
                    (*l_979) = 0x63E8988CL;
                }
            }
        }
        else
        { /* block id: 324 */
            int32_t l_985 = 0xF9EA56D7L;
            int32_t **l_992 = (void*)0;
            struct S0 *l_993 = &l_475;
            int32_t *l_994 = &l_468;
            int16_t l_1005 = 0xDE8CL;
            struct S0 ****l_1075 = &l_563;
            if ((((func_39(l_980, p_11, (0xEB947E7BL || l_981), ((!(func_45((((uint64_t)(l_985 || ((uint16_t)(((int64_t)((((((int16_t)(&l_461 == l_992) >> (int16_t)14) || (0xB5C7D88D4A1B4368LL == l_985)) , l_993) != l_993) != p_8) + (int64_t)0x30F5106EC47925D7LL) != p_11) % (uint16_t)p_8)) + (uint64_t)0x942820ACAC8CE000LL) , &p_9), l_994) , (*l_994))) >= 0x527F9C0DL), (*l_994)) , p_11) < p_11) >= (*l_994)))
            { /* block id: 325 */
                struct S0 **l_1006 = &l_464;
                p_9 = p_9;
                (*l_466) = (void*)0;
                /* statement id: 327 */
                assert (l_467 == 0);
                (*l_460) = ((((uint16_t)((p_10 < ((void*)0 == &l_994)) != p_8) >> (uint16_t)((((uint64_t)(((uint64_t)((***l_529) , ((((((uint32_t)(0xF63764777E1D9C46LL <= (((func_45(l_1003, ((-(int16_t)((void*)0 == &l_994)) , &p_9)) , p_9) | l_1005) == (-4L))) - (uint32_t)p_8) || p_10) , l_1006) == l_1006) ^ p_11)) - (uint64_t)p_8) | 7UL) % (uint64_t)2UL) | 1L) && p_11)) ^ (-7L)) , (void*)0);
            }
            else
            { /* block id: 329 */
                struct S0 ****l_1012 = (void*)0;
                int32_t *l_1043 = &l_475.f1;
                int32_t l_1045 = 0xE42AB00BL;
                int32_t ****l_1049 = &l_762;
                struct S0 ***l_1060 = &l_564;
                struct S0 l_1081 = {1,0L,1L,0x98L,0x8B143270L};
                (*l_1043) = (((((int16_t)(((int32_t)(*l_994) + (int32_t)(p_9 && (~(((l_1012 == ((((p_10 >= ((uint16_t)(((uint64_t)(((int16_t)(((uint64_t)((int16_t)(((uint16_t)((int16_t)1L >> (int16_t)0) - (uint16_t)((uint16_t)(((uint16_t)l_1031 * (uint16_t)p_8) <= ((int32_t)((int16_t)((int16_t)((((((((int16_t)p_11 * (int16_t)((!((uint16_t)(&p_9 != l_1043) - (uint16_t)0UL)) , p_11)) <= 65535UL) , (*l_464)) , (*l_994)) , 0x24318EE3L) , (*l_994)) >= p_10) << (int16_t)7) << (int16_t)10) + (int32_t)(*l_1003))) << (uint16_t)9)) & (*l_1043)) * (int16_t)p_8) % (uint64_t)(*l_1043)) == (*l_994)) * (int16_t)l_1044) == 0xCE8BDB0225E008E8LL) / (uint64_t)(*l_1003)) , 5UL) - (uint16_t)0x30D3L)) , 1L) && (*l_1043)) , (void*)0)) != l_1045) < 0x68A43C81L)))) , 2L) << (int16_t)p_9) , (*l_994)) , p_11) || l_1046);
                for (l_468 = 9; (l_468 <= (-14)); l_468 -= 6)
                { /* block id: 333 */
                    struct S0 ***l_1059 = &l_530;
                    struct S0 l_1076 = {1,0x79C5268CL,1L,0L,0x6E21F338L};
                    struct S0 *****l_1077 = &l_1012;
                    (*l_1003) = (l_1049 == &l_762);
                    (*l_1003) = 0x14DFF13BL;
                    (*l_466) = l_1050;
                    /* statement id: 336 */
                    assert (l_467 == &l_459);
                    if ((((int16_t)((p_8 <= ((int32_t)((((int64_t)p_8 + (int64_t)(((int16_t)0x5E10L * (int16_t)p_8) != ((l_1059 != l_1060) >= ((((int16_t)((4294967292UL >= (((((uint16_t)p_11 - (uint16_t)p_9) <= 18446744073709551615UL) > 0UL) != (*l_467))) <= (-9L)) / (int16_t)p_8) >= (*l_1050)) > p_11)))) ^ 65530UL) ^ p_10) + (int32_t)p_8)) >= 65527UL) * (int16_t)p_10) | p_9))
                    { /* block id: 337 */
                        int32_t l_1067 = 0x22F679DCL;
                        struct S0 l_1079 = {5,0x914502E3L,0xE472L,0x16L,0xC7C388A2L};
                        l_1076 = func_39(func_45((((0xC21D6A06L < p_8) | (p_10 > (l_1067 || ((((uint64_t)((uint16_t)((!(p_9 != ((((((uint16_t)(0xADABL && ((((p_8 , (void*)0) == l_993) , &l_529) == (void*)0)) - (uint16_t)65535UL) && p_10) != l_1067) , l_1075) != (void*)0))) , p_10) >> (uint16_t)p_8) / (uint64_t)(*l_1043)) , &p_9) != &p_9)))) , (*l_466)), (*l_466)), p_10, p_10, p_8, l_1067);
                        l_1078 = l_1077;
                        /* statement id: 339 */
                        assert (l_1078 == &l_1012);
                        return l_1079;
                    }
                    else
                    { /* block id: 341 */
                        struct S0 l_1080 = {7,8L,0L,1L,0xF5A28932L};
                        (***l_1059) = (***l_1059);
                        if (l_465.f1)
                            goto lbl_1082;
                        return l_1080;
                    }
                }
                return l_1081;
            }
            /* facts after branching */
            assert (l_467 == 0);
lbl_1082:
            (*l_529) = (*l_529);
            (*l_993) = (*l_993);
            (*l_460) = (*l_460);
        }
        /* facts after branching */
        //assert (l_467 == &l_459 || l_467 == 0 || l_467 == dangling || l_467 == &p_9 || l_467 == &l_468);
    }
    else
    { /* block id: 353 */
        struct S0 ****l_1084 = &l_563;
        struct S0 *****l_1083 = &l_1084;
        l_1083 = l_1083;
        if (l_475.f3)
            goto lbl_1099;
    }
    /* facts after branching */
    //assert (l_467 == 0 || l_467 == dangling || l_467 == &p_9 || l_467 == &l_468);
lbl_1099:
    p_9 = (&p_9 != (((int64_t)(p_8 ^ (0x7606873AL <= ((int16_t)0xCE87L * (int16_t)(((int16_t)p_8 / (int16_t)((int16_t)(-3L) << (int16_t)10)) , ((uint16_t)65535UL >> (uint16_t)3))))) - (int64_t)(p_8 >= (((((uint16_t)((uint64_t)0x7F70555E6BC01440LL % (uint64_t)p_9) - (uint16_t)p_11) , p_11) >= p_10) == p_9))) , &p_9));
    l_1129 = (func_22((((int64_t)(((int16_t)((uint64_t)p_10 + (uint64_t)(((int64_t)p_11 % (int64_t)(((uint16_t)(((((int32_t)((int16_t)(((int16_t)(((((int16_t)((uint32_t)(~p_11) - (uint32_t)((int32_t)((&l_762 == &l_762) != (!p_9)) % (int32_t)p_11)) - (int16_t)(p_10 < (((-10L) >= p_10) < 0x7F5CL))) , p_9) > l_1126) <= 0L) >> (int16_t)15) != 0xE3DBCCDE273DDF96LL) >> (int16_t)3) % (int32_t)l_1031) != 0x416F9382L) , (void*)0) != &p_9) + (uint16_t)0x6E52L) , 1UL)) ^ p_10)) * (int16_t)l_1127) >= l_1128) % (int64_t)p_10) , p_9), p_8, p_8, p_11) , &l_475);
    for (l_468 = 0; (l_468 == (-16)); l_468 -= 3)
    { /* block id: 361 */
        struct S0 **l_1141 = &l_1129;
        int32_t l_1162 = 0x02BB2056L;
        int64_t l_1163 = 0x51F1E7AFE5B4ADCBLL;
        int32_t ****l_1181 = &l_762;
        int32_t **l_1188 = &l_467;
        int32_t *****l_1191 = &l_1181;
        (*l_466) = (void*)0;
        /* statement id: 362 */
        assert (l_467 == 0);
        for (l_475.f1 = (-10); (l_475.f1 != (-6)); l_475.f1++)
        { /* block id: 365 */
            struct S0 **l_1140 = &l_1129;
            int32_t ***l_1161 = &l_466;
            struct S0 l_1165 = {3,0x138A898DL,0x6049L,0x15L,0xD1DF27E0L};
            struct S0 *l_1164 = &l_1165;
            (*l_1164) = func_22(p_8, ((0UL ^ ((p_11 , (((uint32_t)(((int16_t)((int16_t)(l_1140 == l_1141) * (int16_t)((uint16_t)(-(int32_t)((p_8 < ((uint64_t)p_11 % (uint64_t)((int32_t)(((int64_t)((uint16_t)(!(((!((int16_t)((uint16_t)((uint32_t)1UL + (uint32_t)((((l_1161 == l_1161) >= l_1162) < 1UL) , 0L)) >> (uint16_t)6) / (int16_t)p_10)) && p_8) > p_10)) * (uint16_t)l_1162) + (int64_t)0x957A2701D2FCA568LL) , p_11) + (int32_t)p_9))) <= p_9)) / (uint16_t)l_1163)) >> (int16_t)3) > l_1163) + (uint32_t)p_11) , (void*)0)) == &l_1140)) | (-1L)), p_10, p_9);
            for (l_958 = 0; (l_958 < 27); ++l_958)
            { /* block id: 369 */
                int8_t l_1174 = 0x7FL;
                int32_t *l_1189 = &l_1165.f1;
                int32_t *****l_1190 = &l_761;
                for (l_821 = 0; (l_821 > 14); l_821 += 1)
                { /* block id: 372 */
                    struct S0 ****l_1173 = &l_563;
                    struct S0 *****l_1172 = &l_1173;
                    int32_t ***l_1176 = &l_466;
                    for (l_475.f2 = 18; (l_475.f2 > (-23)); l_475.f2 -= 2)
                    { /* block id: 375 */
                        struct S0 *****l_1187 = &l_1173;
                        (*l_466) = ((l_1172 == ((l_1174 != (!((l_1176 == ((0xF6770B4BL <= (l_1163 , ((p_8 ^ (((uint16_t)((l_1181 != &l_762) | ((uint16_t)((uint16_t)((((p_10 , 0xF58F5F49E9E16D42LL) == p_9) && l_1186) <= p_9) >> (uint16_t)l_1174) * (uint16_t)p_8)) * (uint16_t)p_11) | p_9)) >= p_8))) , (void*)0)) >= 18446744073709551608UL))) , l_1187)) , &p_9);
                        /* statement id: 376 */
                        assert (l_467 == &p_9);
                        (*l_1141) = (*l_1141);
                        (**l_1188) = (l_1188 == (p_9 , (*l_1176)));
                    }
                }
                l_1189 = (*l_1188);
                /* statement id: 381 */
                assert (l_1189 == &p_9 || l_1189 == 0);
                l_1191 = l_1190;
                /* statement id: 382 */
                assert (l_1191 == &l_761);
            }
            (*l_466) = &p_9;
            /* statement id: 384 */
            assert (l_467 == &p_9);
        }
        /* facts after for loop */
        assert (l_467 == &p_9 || l_467 == 0);
        assert (l_1191 == &l_761 || l_1191 == &l_1181);
        (*l_466) = &p_9;
        /* statement id: 386 */
        assert (l_467 == &p_9);
    }
    return l_1192;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_22(int32_t  p_23, uint32_t  p_24, int8_t  p_25, int64_t  p_26)
{ /* block id: 135 */
    int32_t *l_410 = (void*)0;
    int32_t **l_409 = &l_410;
    int32_t l_425 = 0x7F7D65FCL;
    uint16_t l_428 = 65531UL;
    int32_t *l_433 = &l_425;
    struct S0 l_445 = {4,0x19BDB98CL,0xD40DL,0x1FL,0UL};
    struct S0 *l_444 = &l_445;
    struct S0 ****l_446 = (void*)0;
    struct S0 **l_448 = (void*)0;
    struct S0 ***l_447 = &l_448;
    struct S0 l_449 = {4,1L,0x6B8FL,0xC0L,0UL};
    (*l_409) = (void*)0;
    (*l_433) = ((int16_t)((int64_t)((-(int64_t)((uint32_t)(((((((uint16_t)(!p_23) << (uint16_t)((uint16_t)(((uint16_t)(l_425 != p_25) * (uint16_t)(p_23 >= (((uint64_t)((l_428 , (p_23 , &l_410)) == (((int16_t)p_24 >> (int16_t)((uint64_t)(l_428 && 0xD17797F5CF4C9835LL) / (uint64_t)p_24)) , &l_410)) / (uint64_t)p_24) != 5L))) && 0xCB7B7E35L) >> (uint16_t)3)) && p_24) <= 0x7830L) ^ 0x5C79E42D54BD7E9FLL) & p_26) , p_24) - (uint32_t)0L)) , p_26) % (int64_t)p_26) * (int16_t)1L);
    for (p_23 = 0; (p_23 < (-9)); p_23 -= 1)
    { /* block id: 140 */
        struct S0 ****l_442 = (void*)0;
        int32_t l_443 = 0L;
        (*l_409) = func_32((*l_409), ((uint64_t)((int16_t)0x2975L >> (int16_t)((int16_t)(l_442 != ((((p_24 & (l_443 , 0xF0BDL)) , l_444) == &l_445) , l_446)) / (int16_t)0x750CL)) / (uint64_t)p_23), &l_443);
    }
    (*l_433) = ((void*)0 == l_447);
    return l_449;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_29(int32_t  p_30, int16_t  p_31)
{ /* block id: 1 */
    int32_t l_53 = 0xEBAE88B1L;
    int32_t *l_52 = &l_53;
    struct S0 l_56 = {4,0x2EF39980L,0x6F85L,-1L,0x9D45C545L};
    int32_t *l_208 = &l_53;
    uint64_t l_215 = 18446744073709551609UL;
    struct S0 **l_279 = (void*)0;
    int32_t l_337 = 0xCF623B8AL;
    struct S0 ***l_383 = &l_279;
    uint32_t l_392 = 0xAD876D7FL;
    int32_t l_406 = 0xE1BA1B34L;
    struct S0 *l_408 = &l_56;
    l_52 = func_32(func_36(func_39(func_45(func_48(l_52, (((((uint32_t)((0x2CD0L > (((l_56 , (((*l_52) != 0xCF2EC28784865E5ALL) , ((((uint32_t)(((~p_31) >= (!((((uint16_t)((((void*)0 != &p_30) == ((void*)0 != &p_30)) , (*l_52)) >> (uint16_t)10) | 0x35ED357DCCC76BF0LL) , p_31))) ^ 0L) / (uint32_t)(*l_52)) <= p_31) ^ p_31))) ^ (-1L)) > 65529UL)) != (-1L)) / (uint32_t)(*l_52)) >= p_31) & (*l_52)) == (*l_52)), p_30), &l_53), (*l_52), (*l_52), p_31, p_31), (*l_52)), (*l_52), &l_53);
    /* statement id: 70 */
    assert (l_52 == 0);
    (*l_208) = (~(p_31 || ((uint32_t)(((((uint16_t)((uint16_t)(p_30 != (((uint16_t)(((((~((&l_56 != (void*)0) ^ ((p_31 , ((uint64_t)p_31 - (uint64_t)(-1L))) & ((uint16_t)p_31 >> (uint16_t)4)))) != (p_31 || 0UL)) & (-6L)) != 0x45E75F00L) != p_31) << (uint16_t)10) & 0x2AE1L)) >> (uint16_t)4) << (uint16_t)p_31) > p_30) <= l_56.f0) && p_30) + (uint32_t)(-5L))));
    if (((((int16_t)(((p_31 == (*l_208)) & (((((((void*)0 != &p_30) == ((uint16_t)l_215 >> (uint16_t)((-2L) && ((l_56 , p_30) ^ p_30)))) , 0x55L) , 0x2CDDA9EB16AD88BDLL) && (*l_208)) < p_30)) | (*l_208)) + (int16_t)0x64E5L) == (*l_208)) , p_30))
    { /* block id: 72 */
        struct S0 *l_216 = &l_56;
        int32_t l_220 = (-1L);
        int32_t **l_266 = &l_208;
        struct S0 ***l_307 = &l_279;
        int32_t *l_322 = (void*)0;
        uint32_t l_343 = 0UL;
        struct S0 l_365 = {4,1L,-1L,-3L,0xB21165C5L};
        (*l_216) = l_56;
        if (((p_31 && (!p_30)) >= (*l_208)))
        { /* block id: 74 */
            struct S0 ****l_225 = (void*)0;
            int32_t l_244 = 0xDE11C7F7L;
            struct S0 ***l_298 = &l_279;
            struct S0 ****l_297 = &l_298;
            for (l_53 = 0; (l_53 >= 12); ++l_53)
            { /* block id: 77 */
                int32_t l_245 = 0L;
                if (l_220)
                    break;
                for (l_220 = 0; (l_220 >= 22); l_220 += 6)
                { /* block id: 81 */
                    int64_t l_232 = 1L;
                    int32_t **l_246 = &l_208;
                    for (p_30 = (-24); (p_30 <= (-8)); p_30 += 1)
                    { /* block id: 84 */
                        int32_t **l_226 = &l_208;
                        l_225 = (void*)0;
                        (*l_226) = &p_30;
                        /* statement id: 86 */
                        assert (l_208 == &p_30);
                    }
                    (*l_246) = (((0x2FFDF36518EE9594LL < (((p_31 >= ((((int32_t)0x930141AFL % (int32_t)((uint16_t)(((!0x1BAF48159CCD5EB8LL) || l_232) , (((uint32_t)(((((uint32_t)(-(int16_t)l_232) % (uint32_t)((uint16_t)0x8C96L - (uint16_t)((uint32_t)(*l_208) % (uint32_t)((uint64_t)(((0x0625L || 0x58BCL) <= l_244) & (*l_208)) + (uint64_t)p_31)))) <= p_31) && 65535UL) , 4294967287UL) + (uint32_t)p_30) > p_30)) * (uint16_t)8L)) & 0x8D71842AC9BB6F5CLL) ^ l_245)) ^ (-2L)) < p_31)) || l_220) , &p_30);
                    /* statement id: 88 */
                    assert (l_208 == &p_30);
                    (*l_208) = (((uint64_t)p_31 % (uint64_t)((int64_t)2L % (int64_t)(*l_208))) , (((uint16_t)(((((uint16_t)(((uint32_t)(((0xCD451E0E9AD63D6FLL | (((-(uint32_t)((uint16_t)((int16_t)((((int32_t)((int16_t)p_31 % (int16_t)p_31) - (int32_t)(l_266 != (void*)0)) , ((uint16_t)(((((((uint16_t)((int16_t)(((uint16_t)((int16_t)((uint16_t)(p_30 == (*l_208)) % (uint16_t)l_245) >> (int16_t)13) << (uint16_t)8) , p_31) % (int16_t)p_31) >> (uint16_t)3) >= l_244) , p_31) , (**l_246)) < 0xF5FAL) ^ 0xE72F24C6D4E311F9LL) * (uint16_t)(*l_208))) >= l_245) * (int16_t)(**l_266)) % (uint16_t)p_30)) & l_244) < 0x09FFL)) , (**l_266)) == p_30) % (uint32_t)p_31) == 0x84DD8C9BA08D8BCFLL) * (uint16_t)1UL) == 0x43169765L) , l_279) != &l_216) >> (uint16_t)3) ^ (*l_208)));
                    for (l_232 = 0; (l_232 >= (-20)); l_232 -= 1)
                    { /* block id: 92 */
                        int32_t *l_294 = &l_220;
                        (*l_246) = ((((int16_t)0xF431L << (int16_t)1) && ((int16_t)((uint32_t)(*l_208) + (uint32_t)((uint16_t)((((uint16_t)p_30 << (uint16_t)10) != (p_31 ^ ((l_244 < ((void*)0 != l_294)) > (((int16_t)((((((&l_279 != &l_279) || 1UL) != p_31) || 0xED91531C6678C474LL) , (**l_266)) , p_30) * (int16_t)(-7L)) & p_31)))) , p_30) % (uint16_t)l_245)) - (int16_t)p_31)) , (*l_246));
                    }
                }
            }
            /* facts after for loop */
            assert (l_208 == &p_30 || l_208 == &l_53);
            (*l_297) = &l_279;
        }
        else
        { /* block id: 98 */
            int64_t l_304 = 0x9F503595D045B5DBLL;
            int32_t **l_305 = &l_52;
            struct S0 ***l_306 = (void*)0;
            uint32_t l_336 = 0x3DB49053L;
            if ((**l_266))
            { /* block id: 99 */
                struct S0 **l_301 = &l_216;
                int32_t l_320 = 0xD9890B11L;
                p_30 = p_31;
                (*l_266) = func_48((*l_266), ((p_30 ^ p_31) | ((int32_t)p_31 + (int32_t)(l_301 != (void*)0))), (((((uint16_t)65526UL * (uint16_t)l_304) , (l_305 != l_305)) , l_306) != l_307));
                /* statement id: 101 */
                assert (l_208 == 0);
                if (((uint16_t)(((int16_t)p_30 * (int16_t)((uint16_t)(((uint32_t)(0UL ^ 0x968CA8C2L) / (uint32_t)(((p_31 && 0xBA40BAC577DD6AF2LL) , ((int16_t)(&p_30 != ((((((((((int16_t)p_31 * (int16_t)(4294967287UL ^ l_320)) <= p_30) | p_31) , p_30) | l_320) & 0x394302581F7334F8LL) < p_31) && l_320) , (void*)0)) << (int16_t)p_31)) , p_31)) | 0x83E9DA6DL) << (uint16_t)p_31)) | 0xF0A7L) << (uint16_t)6))
                { /* block id: 102 */
                    p_30 = l_304;
                }
                else
                { /* block id: 104 */
                    int32_t *l_321 = &l_320;
                    (*l_321) = 0x83DFED90L;
                    (*l_305) = l_322;
                }
            }
            else
            { /* block id: 108 */
                uint32_t l_329 = 9UL;
                (*l_208) = ((uint16_t)(((uint16_t)((uint16_t)l_329 << (uint16_t)10) * (uint16_t)0x562FL) == (p_31 > (p_31 || (((p_30 ^ (!((uint16_t)0x90D4L << (uint16_t)((((~((uint16_t)(p_31 > ((0x6EC3L > (((l_336 ^ p_31) == (**l_266)) != p_31)) != 18446744073709551608UL)) * (uint16_t)l_337)) != (*l_208)) <= p_31) && 0x9F9FL)))) != 1UL) , p_31)))) * (uint16_t)p_30);
            }
            /* facts after branching */
            assert (l_208 == &l_53 || l_208 == 0);
            for (l_337 = 0; (l_337 >= (-21)); l_337 -= 1)
            { /* block id: 113 */
                int32_t l_348 = (-1L);
                struct S0 l_349 = {5,-1L,0L,0x59L,18446744073709551608UL};
                int16_t l_358 = 2L;
                for (l_56.f1 = 0; (l_56.f1 >= 19); l_56.f1++)
                { /* block id: 116 */
                    int32_t l_342 = 0xB3597BFAL;
                    struct S0 l_345 = {0,0xF0344009L,0x8FF1L,0xE6L,1UL};
                    struct S0 *l_344 = &l_345;
                    p_30 = 0x1A217AB7L;
                    (*l_344) = func_39((*l_216), p_31, p_30, l_342, l_343);
                }
                if ((((int64_t)((l_348 > (((*l_216) , func_36(l_349, (&l_53 != ((&l_53 != &p_30) , func_48((((((((int64_t)(((uint16_t)l_349.f0 * (uint16_t)((uint32_t)((uint32_t)((p_31 < (&l_56 == &l_56)) , 0xEA158747L) / (uint32_t)0x963F5E78L) % (uint32_t)p_30)) > l_349.f0) - (int64_t)p_30) , l_305) == &l_322) || p_31) ^ 0x3FCAEC78794BD401LL) , (*l_266)), p_31, l_358))))) == (void*)0)) == p_30) % (int64_t)0x85EC9B8C997FF8A4LL) | l_358))
                { /* block id: 120 */
                    struct S0 ***l_359 = (void*)0;
                    int32_t l_364 = 0x34BA4E07L;
                    p_30 = (p_30 | (((((p_30 || ((((0L != (l_359 != &l_279)) ^ (18446744073709551606UL | ((uint64_t)p_31 + (uint64_t)p_30))) , ((uint64_t)(0x1C7195CB3C5C33FCLL == 0x04CD1A385CBB0ED4LL) + (uint64_t)l_364)) != 18446744073709551615UL)) > (-3L)) > l_349.f1) == p_30) , p_30));
                    (*l_266) = (l_365 , func_48(&p_30, l_364, l_349.f2));
                    /* statement id: 122 */
                    assert (l_208 == 0);
                    l_349 = l_56;
                }
                else
                { /* block id: 124 */
                    int32_t l_366 = (-1L);
                    int32_t *l_381 = &l_220;
                    (*l_381) = (l_366 , ((int16_t)(((int16_t)0x9C50L / (int16_t)((int16_t)((void*)0 != &p_30) % (int16_t)0x3A93L)) <= ((uint16_t)(((uint16_t)((int32_t)p_31 / (int32_t)(((int32_t)((p_30 , ((-1L) > (p_31 ^ p_31))) != p_30) - (int32_t)6UL) & l_358)) << (uint16_t)10) <= p_30) % (uint16_t)p_30)) << (int16_t)p_31));
                }
            }
        }
        /* facts after branching */
        assert (l_208 == &l_53 || l_208 == 0 || l_208 == &p_30);
        (*l_266) = (*l_266);
    }
    else
    { /* block id: 130 */
        struct S0 ***l_382 = &l_279;
        int32_t l_393 = (-6L);
        struct S0 *l_400 = &l_56;
        l_383 = l_382;
        (*l_208) = (((uint64_t)(((((((int64_t)(*l_208) - (int64_t)((int32_t)(((uint16_t)l_392 >> (uint16_t)l_393) == ((uint16_t)(((uint64_t)(((uint32_t)((l_393 && l_393) < (l_400 == (((int32_t)((-(int16_t)((p_30 | ((uint16_t)(l_406 , (-(uint32_t)(18446744073709551610UL | 0x29D1AC3D0BC41B95LL))) << (uint16_t)(*l_208))) >= 0x4C1116C5L)) == 0xADB8AA7565D6A2F6LL) / (int32_t)p_30) , l_408))) + (uint32_t)0x739512A2L) & l_393) / (uint64_t)l_393) ^ l_393) * (uint16_t)4L)) - (int32_t)(*l_208))) , p_31) > l_393) ^ 0x127CL) == l_393) >= 0x6769E6BECDB6F072LL) / (uint64_t)l_393) , 0L);
    }
    /* facts after branching */
    assert (l_208 == &l_53 || l_208 == 0 || l_208 == &p_30);
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_32(int32_t * p_33, uint32_t  p_34, int32_t * p_35)
{ /* block id: 67 */
    uint64_t l_189 = 18446744073709551615UL;
    struct S0 l_190 = {6,1L,-1L,1L,0UL};
    uint16_t l_192 = 1UL;
    int32_t *l_193 = (void*)0;
    (*p_35) = ((-(uint32_t)(((l_189 , (func_39(l_190, p_34, (*p_35), (((~0x9B0FDDEAL) | ((((l_190.f2 <= p_34) == (p_34 != ((p_34 || (-1L)) , l_192))) == 0xAB0B14FC1BAD8490LL) , l_189)) == p_34), p_34) , l_190.f4)) ^ 1UL) <= 0x8D7A2F4DL)) | l_190.f4);
    return l_193;
    /* statement id: 69 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(struct S0  p_37, int32_t  p_38)
{ /* block id: 64 */
    int32_t l_184 = 0x40BF3EC7L;
    int32_t *l_183 = &l_184;
    int32_t **l_182 = &l_183;
    int32_t *l_185 = &l_184;
    int32_t *l_186 = &l_184;
    int32_t *l_187 = (void*)0;
    (*l_182) = &p_38;
    /* statement id: 65 */
    assert (l_183 == &p_38);
    return l_187;
    /* statement id: 66 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_39(struct S0  p_40, int16_t  p_41, int32_t  p_42, uint32_t  p_43, uint32_t  p_44)
{ /* block id: 60 */
    int32_t l_175 = 0x377A3426L;
    struct S0 l_179 = {4,0x74F60197L,0xA6A2L,0x96L,9UL};
    struct S0 *l_178 = &l_179;
    struct S0 **l_177 = &l_178;
    struct S0 ***l_176 = &l_177;
    int32_t *l_180 = &l_179.f1;
    int32_t **l_181 = &l_180;
    (*l_180) = ((int16_t)(l_175 ^ p_41) >> (int16_t)(l_175 >= ((void*)0 == l_176)));
    l_181 = &l_180;
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_45(int32_t * p_46, int32_t * p_47)
{ /* block id: 57 */
    int32_t l_171 = (-7L);
    int32_t *l_170 = &l_171;
    struct S0 l_172 = {6,3L,-1L,0L,2UL};
    p_46 = l_170;
    /* statement id: 58 */
    assert (p_46 == &l_171);
    return l_172;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_48(int32_t * p_49, int32_t  p_50, int32_t  p_51)
{ /* block id: 2 */
    struct S0 l_75 = {7,0L,0x9B16L,0x5DL,1UL};
    struct S0 *l_74 = &l_75;
    struct S0 **l_73 = &l_74;
    int32_t *l_99 = &l_75.f1;
    int32_t l_163 = (-9L);
    int32_t **l_165 = &l_99;
    int32_t *l_166 = &l_75.f1;
    int32_t *l_167 = &l_75.f1;
    int32_t *l_168 = &l_75.f1;
    int32_t *l_169 = (void*)0;
    for (p_50 = (-28); (p_50 < (-4)); p_50++)
    { /* block id: 5 */
        struct S0 *l_72 = (void*)0;
        struct S0 **l_71 = &l_72;
        uint32_t l_80 = 4294967286UL;
        struct S0 **l_131 = &l_72;
        int32_t *l_132 = &l_75.f1;
        int32_t **l_164 = &l_132;
        for (p_51 = 0; (p_51 <= 2); ++p_51)
        { /* block id: 8 */
            struct S0 *l_69 = (void*)0;
            struct S0 **l_70 = &l_69;
            (*l_70) = l_69;
        }
    }
    (*l_165) = &p_50;
    /* statement id: 55 */
    assert (l_99 == &p_50);
    return l_169;
    /* statement id: 56 */
    //assert (func_48_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 229
   depth: 1, occurrence: 27
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 80
breakdown:
   indirect level: 0, occurrence: 27
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 12
   indirect level: 3, occurrence: 13
   indirect level: 4, occurrence: 9
   indirect level: 5, occurrence: 9
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 22
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 44
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 8

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 210
   depth: 2, occurrence: 35
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 4
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 5
   depth: 23, occurrence: 2
   depth: 25, occurrence: 3
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 3
   depth: 29, occurrence: 3
   depth: 31, occurrence: 1
   depth: 32, occurrence: 2
   depth: 33, occurrence: 3
   depth: 34, occurrence: 1
   depth: 36, occurrence: 1
   depth: 37, occurrence: 2
   depth: 39, occurrence: 1
   depth: 42, occurrence: 1
   depth: 44, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 180

XXX times a variable address is taken: 236
XXX times a pointer is dereferenced on RHS: 199
breakdown:
   depth: 1, occurrence: 165
   depth: 2, occurrence: 28
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 103
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 3
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 19
XXX times a pointer is qualified to be dereferenced: 864

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 337
   level: 2, occurrence: 153
   level: 3, occurrence: 46
   level: 4, occurrence: 37
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 100
XXX number of pointers point to scalars: 61
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 25
XXX average alias set size: 1.23

XXX times a non-volatile is read: 1401
XXX times a non-volatile is write: 293
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 4

XXX stmts: 197
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 19
   depth: 2, occurrence: 23
   depth: 3, occurrence: 35
   depth: 4, occurrence: 49
   depth: 5, occurrence: 38

XXX percentage a fresh-made variable is used: 14.9
XXX percentage an existing variable is used: 85.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

