/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1890307712
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int8_t g_3 = 0x48L;
static int32_t g_76 = 1L;
static int32_t * volatile g_75 = &g_76;/* VOLATILE GLOBAL g_75 */
static int32_t g_110 = 0L;
static int32_t * volatile g_134 = (void*)0;/* VOLATILE GLOBAL g_134 */
static int32_t g_136 = 6L;
static int32_t **g_139 = (void*)0;
static int32_t g_143 = 0xB769E501L;
static int32_t *g_148 = &g_110;
static int32_t ** volatile g_147 = &g_148;/* VOLATILE GLOBAL g_147 */
static int32_t g_164 = 0x691D68C9L;
static int32_t ** volatile g_192 = (void*)0;/* VOLATILE GLOBAL g_192 */
static int32_t ** volatile g_195 = &g_148;/* VOLATILE GLOBAL g_195 */
static int32_t ** volatile g_220 = &g_148;/* VOLATILE GLOBAL g_220 */
static volatile int32_t g_242 = 0x6177B4B0L;/* VOLATILE GLOBAL g_242 */
static volatile int32_t *g_241 = &g_242;
static volatile int32_t ** volatile g_243 = &g_241;/* VOLATILE GLOBAL g_243 */
static int32_t ** volatile g_262 = &g_148;/* VOLATILE GLOBAL g_262 */
static int32_t ** volatile g_350 = &g_148;/* VOLATILE GLOBAL g_350 */
static int32_t g_376 = 1L;
static int8_t g_385 = 0x5EL;
static int16_t g_414 = 0x75D1L;
static int16_t g_516 = 0x72CBL;
static int32_t ** volatile * volatile g_551 = &g_262;/* VOLATILE GLOBAL g_551 */
static int32_t ** volatile * volatile * volatile g_550 = &g_551;/* VOLATILE GLOBAL g_550 */
static volatile int8_t g_582 = (-4L);/* VOLATILE GLOBAL g_582 */
static int32_t *g_600 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_27(void);
static int32_t  func_36(uint32_t  p_37, int32_t  p_38, uint32_t  p_39, int16_t  p_40);
static uint16_t  func_43(int32_t  p_44);
static uint16_t  func_48(uint16_t  p_49, int16_t  p_50, int32_t  p_51, int8_t  p_52, int16_t  p_53);
static uint32_t  func_58(uint32_t  p_59, int8_t  p_60, int16_t  p_61, uint32_t  p_62, uint32_t  p_63);
static int16_t  func_69(int16_t  p_70, int32_t  p_71, int32_t  p_72);
static int32_t  func_84(uint32_t  p_85, int32_t  p_86);
static int16_t  func_87(uint32_t  p_88, int32_t * p_89);
static int32_t * func_92(int32_t * p_93, int32_t * p_94);
static int32_t * func_95(uint32_t  p_96, uint32_t  p_97, uint32_t  p_98, int32_t * p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_143 g_241 g_242 g_136 g_164 g_75 g_76 g_195 g_148 g_262 g_110 g_147 g_220 g_243 g_414 g_139 g_385 g_376 g_350 g_600
 * writes: g_143 g_136 g_76 g_110 g_242 g_376 g_164 g_139 g_148 g_241
 */
static uint32_t  func_27(void)
{ /* block id: 36 */
    uint16_t l_30 = 65534UL;
    int32_t l_287 = 0xAECDC9E8L;
    int32_t *l_311 = &g_76;
    uint32_t l_315 = 4294967292UL;
    int32_t *l_332 = (void*)0;
    int32_t ***l_339 = (void*)0;
    uint16_t l_377 = 0x354AL;
    int32_t l_463 = 0x04AFCE30L;
    int16_t l_475 = 0xB0ECL;
    int32_t l_517 = 0x2D643A89L;
    uint32_t l_540 = 0x9BD7BBCCL;
    uint16_t l_593 = 0UL;
    if (((int16_t)(l_30 <= g_3) << (int16_t)1))
    { /* block id: 37 */
        int32_t l_33 = 0xC383C67EL;
        uint32_t l_77 = 0xF32F520AL;
        int32_t *l_277 = (void*)0;
        uint16_t l_291 = 65535UL;
        volatile int32_t **l_308 = &g_241;
        uint32_t l_316 = 0x9C88E312L;
        uint32_t l_449 = 0xCA2AA58FL;
        int32_t l_486 = 0xD93545C0L;
        int32_t ****l_552 = &l_339;
        int32_t ***l_559 = &g_139;
        if (((int32_t)l_33 + (int32_t)__builtin_popcountll(g_3)))
        { /* block id: 38 */
            uint32_t l_47 = 0x040C3F30L;
            int32_t *l_268 = &g_136;
            int32_t **l_279 = &l_277;
            for (l_30 = (-3); (l_30 < 12); l_30 += 1)
            { /* block id: 41 */
                uint32_t l_54 = 1UL;
                int32_t *l_261 = &g_143;
                int32_t *l_278 = (void*)0;
                if (g_3)
                    break;
            }
            for (g_143 = 0; (g_143 != (-14)); g_143 -= 1)
            { /* block id: 168 */
                int32_t l_286 = 9L;
                int32_t l_292 = 7L;
                int32_t l_293 = 0xCE292E26L;
                (*l_268) ^= (*g_241);
                if (func_69(g_164, ((int16_t)((g_3 & ((uint32_t)l_286 % (uint32_t)g_242)) < __builtin_ffsl(l_30)) >> (int16_t)4), (l_30 < (l_287 && ((int16_t)((!(__builtin_ctz(l_291) | l_287)) ^ l_292) >> (int16_t)l_293)))))
                { /* block id: 170 */
                    uint32_t l_306 = 3UL;
                    (**g_195) = ((int16_t)0L - (int16_t)(__builtin_ctzll(g_3) != ((uint32_t)0xBE17463EL / (uint32_t)((uint16_t)0x624AL - (uint16_t)((uint32_t)((int16_t)((uint16_t)g_136 - (uint16_t)((l_286 || l_306) || l_306)) << (int16_t)13) + (uint32_t)l_287)))));
                    if ((*l_268))
                    { /* block id: 172 */
                        (*l_279) = &l_293;
                    }
                    else
                    { /* block id: 174 */
                        uint16_t l_307 = 0x57A1L;
                        if ((**g_262))
                            break;
                        (*g_148) |= (l_307 == g_164);
                        (*l_268) ^= (**g_195);
                        (*l_279) = (*g_147);
                    }
                    if (l_287)
                    { /* block id: 180 */
                        l_293 ^= 0x4B614F71L;
                        l_308 = &g_241;
                        (*l_277) = (((int32_t)(l_311 != (void*)0) - (int32_t)g_76) | (__builtin_clz(((__builtin_parityll((-(uint16_t)0xADD0L)) >= g_76) >= l_315)) <= (((*l_311) || (**g_220)) != l_316)));
                    }
                    else
                    { /* block id: 184 */
                        (*g_241) = __builtin_popcountll(((-4L) && (**g_262)));
                        (*l_311) &= 0x8B985607L;
                    }
                }
                else
                { /* block id: 188 */
                    uint32_t l_319 = 0xDDB8EC8CL;
                    (**l_308) &= ((0L | ((l_319 >= l_319) >= (g_110 == l_293))) | ((uint32_t)g_136 - (uint32_t)((void*)0 == (*l_308))));
                }
            }
            (*l_279) = (*g_262);
        }
        else
        { /* block id: 193 */
            uint32_t l_326 = 0x75A53CB9L;
            int16_t l_329 = 0xE383L;
            int32_t l_386 = 8L;
            l_332 = func_95((((int16_t)((*l_311) != ((**g_243) || 4294967288UL)) * (int16_t)(((uint32_t)__builtin_bswap64((l_326 != (g_143 && ((uint16_t)l_329 - (uint16_t)((uint16_t)g_143 << (uint16_t)14))))) - (uint32_t)l_326) || g_76)) && l_326), l_77, (*l_311), &g_136);
            for (g_76 = (-12); (g_76 < (-4)); g_76 += 4)
            { /* block id: 197 */
                int32_t *l_342 = &g_143;
                int8_t l_374 = 0L;
                (*l_332) = ((*g_75) <= (((uint32_t)1UL - (uint32_t)(*l_332)) || 0x5103CEEFL));
            }
            l_277 = (*g_220);
        }
        if (__builtin_bswap32((*l_311)))
        { /* block id: 220 */
            uint16_t l_398 = 1UL;
            int32_t ***l_425 = &g_139;
            int8_t l_481 = 0L;
            for (l_77 = 10; (l_77 <= 27); l_77 += 3)
            { /* block id: 223 */
                int32_t **l_395 = &l_277;
                for (g_376 = 0; (g_376 == 4); g_376 += 1)
                { /* block id: 226 */
                    for (l_377 = 0; (l_377 >= 6); l_377 += 5)
                    { /* block id: 229 */
                        return g_242;
                    }
                    (*l_311) = ((uint16_t)g_76 << (uint16_t)3);
                    (*g_148) = (&g_75 == l_395);
                }
                for (g_164 = 27; (g_164 != 11); g_164 -= 1)
                { /* block id: 237 */
                    int16_t l_399 = 1L;
                    int32_t *l_419 = &g_164;
                    int32_t ***l_424 = &g_139;
                    if (l_398)
                    { /* block id: 238 */
                        if (l_399)
                            break;
                    }
                    else
                    { /* block id: 240 */
                        (*l_395) = (*g_195);
                    }
                    for (l_315 = (-19); (l_315 < 16); l_315 += 5)
                    { /* block id: 245 */
                        int32_t ***l_402 = (void*)0;
                        (**l_395) ^= ((l_402 != &l_308) < ((g_136 != ((uint32_t)(~4294967295UL) - (uint32_t)((int16_t)1L << (int16_t)func_69(g_164, g_136, ((~((int16_t)l_399 >> (int16_t)(!(((int16_t)(-9L) >> (int16_t)g_164) < g_414)))) == (-1L)))))) & 0UL));
                        (*g_148) = (l_398 | ((*l_311) < ((((int32_t)((int16_t)1L * (int16_t)((*g_75) && (((l_419 == (*g_220)) ^ (((int16_t)((uint16_t)((((l_424 == l_425) > (4294967295UL | 4294967294UL)) | 0xE17D8A5FL) && (-1L)) << (uint16_t)g_110) << (int16_t)g_143) ^ (*g_148))) & 0x17CAL))) % (int32_t)(*g_148)) > 0L) & (*l_419))));
                    }
                }
                if (((int32_t)((void*)0 == l_425) / (int32_t)((uint32_t)__builtin_parityll((**l_395)) / (uint32_t)__builtin_ffsll(((int32_t)(**l_395) % (int32_t)(*l_277))))))
                { /* block id: 250 */
                    (*g_148) &= (*g_241);
                }
                else
                { /* block id: 252 */
                    for (g_164 = (-28); (g_164 == 2); g_164 += 3)
                    { /* block id: 255 */
                        int16_t l_442 = 1L;
                        (*l_311) &= (func_84((0x3865L && (((int16_t)g_143 * (int16_t)(&g_262 == (void*)0)) < ((uint16_t)((uint32_t)g_3 / (uint32_t)((int32_t)((l_442 == ((uint16_t)(&g_350 == (void*)0) * (uint16_t)g_110)) || g_3) / (int32_t)(**g_220))) >> (uint16_t)(*l_277)))), (*g_148)) ^ 0x7BD8L);
                    }
                }
                if ((((int32_t)(&g_148 != (void*)0) + (int32_t)g_385) && __builtin_ffs(((int16_t)(__builtin_ffsll(g_242) & __builtin_ffsl(l_449)) / (int16_t)1L))))
                { /* block id: 259 */
                    if ((**l_395))
                    { /* block id: 260 */
                        int32_t l_452 = 0xBFFCE8DCL;
                        (**g_220) |= ((int16_t)__builtin_popcountll(l_452) - (int16_t)(!((void*)0 == &g_241)));
                        return g_136;
                    }
                    else
                    { /* block id: 263 */
                        return g_164;
                    }
                }
                else
                { /* block id: 266 */
                    int32_t l_460 = (-7L);
                    for (l_291 = 0; (l_291 < 55); l_291 += 8)
                    { /* block id: 269 */
                        (*g_241) |= ((int16_t)g_110 + (int16_t)g_385);
                        (*l_425) = &l_277;
                    }
                    l_463 &= (func_69(g_164, ((uint16_t)(&g_195 != &l_395) >> (uint16_t)11), l_460) == ((uint16_t)5UL >> (uint16_t)5));
                    (*l_395) = func_95((((uint32_t)g_143 / (uint32_t)(func_87(((int16_t)g_414 - (int16_t)((-2L) | g_164)), &l_460) | 1UL)) == (((~g_385) | g_143) & (*g_241))), g_164, g_385, &l_460);
                }
            }
            if (((((uint16_t)func_48(func_84(g_385, (((int16_t)g_143 * (int16_t)((**g_243) & (func_84(((uint32_t)(l_475 > l_398) - (uint32_t)((((int16_t)((*g_148) >= g_385) >> (int16_t)__builtin_ctzll(g_136)) >= (*l_277)) <= (*l_277))), (*g_148)) || (*g_148)))) & 1UL)), g_385, g_376, g_385, g_385) % (uint16_t)0xB809L) & g_414) <= 0x72B7L))
            { /* block id: 277 */
                return g_110;
            }
            else
            { /* block id: 279 */
                int32_t l_478 = 0x20927C93L;
                int32_t *l_487 = (void*)0;
                int32_t *l_488 = &g_164;
                (*g_241) ^= ((&g_220 == &g_220) < (0xB5DEE580L == l_478));
                (*l_488) |= ((8UL & ((uint16_t)((0x9884D231L || (((*l_311) != l_481) >= 3UL)) != ((*l_277) & ((uint16_t)(((int16_t)0x145DL % (int16_t)(**l_308)) < l_478) + (uint16_t)0x9FF1L))) * (uint16_t)0UL)) && l_486);
                (*l_277) = 0L;
            }
        }
        else
        { /* block id: 284 */
            uint32_t l_495 = 0x9A0BE3B2L;
            int16_t l_525 = 0x6D61L;
            int32_t *l_563 = &g_76;
            int32_t ***l_572 = (void*)0;
            int8_t l_580 = 1L;
            for (g_136 = (-16); (g_136 == (-14)); g_136 += 1)
            { /* block id: 287 */
                int8_t l_491 = 0x33L;
                int32_t ****l_492 = &l_339;
                int32_t l_497 = (-1L);
                (*g_148) &= (l_491 < g_242);
                (*l_492) = l_339;
            }
            (*l_277) = ((**g_262) >= 0x5FF4D235L);
        }
        (*l_308) = (void*)0;
    }
    else
    { /* block id: 336 */
        uint16_t l_585 = 0x6642L;
        int32_t l_586 = 0x7D53E825L;
        (*g_241) = (((int16_t)(func_84(g_3, func_36(__builtin_ctzl(l_585), l_586, l_586, __builtin_parityl((((uint16_t)((((uint16_t)0xCF1CL % (uint16_t)((int16_t)l_593 >> (int16_t)((int16_t)((uint16_t)((uint16_t)func_87(((**g_350) > g_110), g_600) + (uint16_t)l_586) >> (uint16_t)0) >> (int16_t)2))) == g_414) == 0x2DE21AB9L) >> (uint16_t)(*l_311)) < 3UL)))) ^ g_164) - (int16_t)g_3) > 0L);
    }
    return (*l_311);
}


/* ------------------------------------------ */
/* 
 * reads : g_241 g_75 g_76
 * writes: g_242
 */
static int32_t  func_36(uint32_t  p_37, int32_t  p_38, uint32_t  p_39, int16_t  p_40)
{ /* block id: 142 */
    (*g_241) = p_38;
    return (*g_75);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_75 g_76 g_143 g_195 g_148 g_110 g_136 g_164 g_220 g_241 g_243
 * writes: g_143 g_148 g_76 g_136 g_164 g_110 g_241
 */
static uint16_t  func_43(int32_t  p_44)
{ /* block id: 96 */
    int16_t l_180 = 8L;
    int32_t *l_202 = &g_76;
    uint32_t l_218 = 0xA2447EBBL;
    if (((int16_t)(0x33A36175L ^ 4294967287UL) + (int16_t)(l_180 ^ (l_180 <= ((uint16_t)g_3 - (uint16_t)((int16_t)((uint16_t)65535UL / (uint16_t)((int32_t)(0xE32CL != l_180) / (int32_t)(*g_75))) - (int16_t)l_180))))))
    { /* block id: 97 */
        uint16_t l_194 = 0x5BB3L;
        int32_t **l_196 = &g_148;
        int32_t ***l_197 = &l_196;
        for (g_143 = (-1); (g_143 > 0); g_143 += 6)
        { /* block id: 100 */
            int32_t *l_191 = &g_143;
            int32_t **l_193 = &g_148;
            (*l_193) = l_191;
            return l_194;
        }
        (*g_195) = &p_44;
        (*g_148) |= 0xDA28E2A2L;
        (*l_197) = l_196;
    }
    else
    { /* block id: 107 */
        uint16_t l_212 = 65531UL;
        int16_t l_217 = 8L;
        uint32_t l_221 = 1UL;
        int32_t l_222 = (-1L);
        int32_t l_234 = 0x0BB31F0EL;
        for (g_76 = 22; (g_76 <= (-1)); g_76 -= 1)
        { /* block id: 110 */
            uint16_t l_204 = 0xD428L;
            int32_t *l_206 = &g_164;
            l_204 &= ((uint16_t)func_87(l_180, l_202) - (uint16_t)__builtin_popcountll((-(uint16_t)g_143)));
            (*l_206) = (!((l_204 && l_204) && (6L & l_204)));
            for (g_110 = 0; (g_110 >= 3); g_110 += 1)
            { /* block id: 115 */
                int32_t *l_219 = &g_76;
                for (g_164 = (-30); (g_164 == (-19)); g_164 += 2)
                { /* block id: 118 */
                    int32_t **l_211 = &l_202;
                    (*l_211) = (void*)0;
                    return l_212;
                }
                if ((((*l_202) && ((1L | (&g_75 == &g_134)) || ((*l_202) <= g_76))) && (p_44 != (9L > (((int32_t)((int16_t)(l_217 && (*l_202)) * (int16_t)g_136) - (int32_t)p_44) || (*l_206))))))
                { /* block id: 122 */
                    int32_t **l_223 = &l_219;
                    (*l_206) = (l_218 < (*l_206));
                    (*g_220) = l_219;
                    if ((g_76 == g_76))
                    { /* block id: 125 */
                        l_222 ^= (l_221 != (*l_219));
                    }
                    else
                    { /* block id: 127 */
                        return g_76;
                    }
                    (*l_223) = &p_44;
                }
                else
                { /* block id: 131 */
                    (*l_206) |= ((int32_t)(4L || ((uint16_t)(0x31E0CC64L < func_87((p_44 == (((uint16_t)g_3 * (uint16_t)(*l_219)) ^ (-3L))), l_219)) >> (uint16_t)14)) / (int32_t)((uint16_t)((0x2732L >= g_143) <= 0xF70AFF55L) - (uint16_t)p_44));
                }
            }
            (*l_206) = ((((int16_t)(-1L) >> (int16_t)1) >= l_234) == ((uint16_t)(((0xE77DL ^ __builtin_parityll(g_76)) & p_44) && (*l_202)) * (uint16_t)((int16_t)g_3 - (int16_t)((uint32_t)func_87(l_221, l_206) + (uint32_t)l_221))));
        }
        (*l_202) = __builtin_bswap64((*l_202));
        (*g_243) = g_241;
    }
    (*l_202) &= p_44;
    return (*l_202);
}


/* ------------------------------------------ */
/* 
 * reads : g_147 g_148 g_75 g_76 g_143 g_136 g_3 g_110 g_139 g_164
 * writes: g_148 g_110 g_76 g_136 g_139 g_143 g_164
 */
static uint16_t  func_48(uint16_t  p_49, int16_t  p_50, int32_t  p_51, int8_t  p_52, int16_t  p_53)
{ /* block id: 77 */
    int32_t **l_151 = &g_148;
    uint32_t l_152 = 0UL;
    int32_t *l_163 = &g_164;
    for (p_50 = 0; (p_50 != (-19)); p_50 -= 1)
    { /* block id: 80 */
        uint16_t l_146 = 0x5578L;
        l_146 ^= p_52;
        (*g_147) = &p_51;
        if (p_50)
            continue;
    }
    (*l_163) ^= ((int16_t)((((((void*)0 == l_151) <= ((l_152 <= (!((((int16_t)(-(uint16_t)((void*)0 == (*l_151))) / (int16_t)func_58(((0xD13389D4L != (((uint16_t)((uint16_t)(((0x2B5FF26AL && ((uint32_t)((-1L) && (*g_75)) % (uint32_t)g_143)) == 0xA34CL) | p_53) >> (uint16_t)p_49) >> (uint16_t)g_143) || 0x65DD65D9L)) == g_76), g_136, g_76, p_50, g_76)) < p_49) == 0xEEF7L))) ^ g_3)) | p_49) <= l_152) & p_52) << (int16_t)10);
    for (p_49 = 0; (p_49 <= 28); p_49 += 7)
    { /* block id: 88 */
        uint32_t l_171 = 0x3BB0F311L;
    }
    (*l_151) = &p_51;
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_76 g_75 g_110 g_136 g_139 g_143
 * writes: g_110 g_76 g_136 g_139 g_143
 */
static uint32_t  func_58(uint32_t  p_59, int8_t  p_60, int16_t  p_61, uint32_t  p_62, uint32_t  p_63)
{ /* block id: 46 */
    uint32_t l_102 = 18446744073709551609UL;
    int32_t *l_103 = &g_76;
    int32_t *l_142 = &g_143;
    (*l_142) ^= ((uint16_t)((uint16_t)((uint16_t)p_63 << (uint16_t)6) >> (uint16_t)0) << (uint16_t)(func_84(p_61, ((func_87(((uint16_t)(&g_76 == (void*)0) << (uint16_t)2), func_92(func_95(((uint16_t)((p_62 | 1L) <= (g_3 == (0UL != (&g_76 == &g_76)))) * (uint16_t)l_102), g_76, g_76, l_103), l_103)) != g_3) <= l_102)) > p_62));
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_75 g_76
 * writes: g_76
 */
static int16_t  func_69(int16_t  p_70, int32_t  p_71, int32_t  p_72)
{ /* block id: 43 */
    (*g_75) &= (g_3 < 65529UL);
    return g_76;
}


/* ------------------------------------------ */
/* 
 * reads : g_110 g_136 g_139
 * writes: g_139 g_110 g_136
 */
static int32_t  func_84(uint32_t  p_85, int32_t  p_86)
{ /* block id: 66 */
    int32_t *l_138 = &g_136;
    int32_t **l_137 = &l_138;
    g_139 = l_137;
    for (g_110 = 7; (g_110 >= 28); g_110 += 8)
    { /* block id: 70 */
        (*l_138) ^= 0xB7A8BFC0L;
    }
    (**g_139) = (0xBABA1048L <= (__builtin_clz(p_85) | (**g_139)));
    return (**l_137);
}


/* ------------------------------------------ */
/* 
 * reads : g_76 g_110 g_3 g_136
 * writes: g_136
 */
static int16_t  func_87(uint32_t  p_88, int32_t * p_89)
{ /* block id: 63 */
    int8_t l_120 = 0xFBL;
    int32_t *l_135 = &g_136;
    (*l_135) &= (p_88 != ((uint16_t)(__builtin_ffsll((p_89 != p_89)) && (((l_120 >= ((uint32_t)(-(uint32_t)(__builtin_popcountl(((int16_t)(g_76 ^ ((uint32_t)l_120 + (uint32_t)((uint16_t)l_120 >> (uint16_t)((int16_t)((int16_t)(g_76 <= g_110) % (int16_t)p_88) >> (int16_t)14)))) << (int16_t)7)) >= 0xE063A29CL)) % (uint32_t)5L)) && 0x0D6E0D24L) >= l_120)) / (uint16_t)g_3));
    return (*l_135);
}


/* ------------------------------------------ */
/* 
 * reads : g_110 g_3 g_76
 * writes: g_110 g_76
 */
static int32_t * func_92(int32_t * p_93, int32_t * p_94)
{ /* block id: 59 */
    int32_t l_115 = 0x4E133846L;
    (*p_93) |= 0x3F16A1EAL;
    (*p_94) |= (l_115 & (g_110 != g_3));
    return &g_110;
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_76 g_3 g_110
 * writes: g_110 g_76 g_143 g_136
 */
static int32_t * func_95(uint32_t  p_96, uint32_t  p_97, uint32_t  p_98, int32_t * p_99)
{ /* block id: 47 */
    uint16_t l_106 = 0xEC8EL;
    int32_t *l_109 = &g_110;
    (*l_109) |= ((uint16_t)l_106 * (uint16_t)((l_106 <= ((p_97 > ((void*)0 != p_99)) >= (*g_75))) <= ((int16_t)(l_106 | (((0x02F4L || g_3) != l_106) && g_3)) % (int16_t)l_106)));
    for (p_96 = 0; (p_96 < 45); p_96 += 3)
    { /* block id: 51 */
        for (l_106 = 0; (l_106 == 25); l_106 += 6)
        { /* block id: 54 */
            (*p_99) = (g_110 <= g_76);
        }
    }
    return l_109;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_76, "g_76", print_hash_value);
    transparent_crc(g_110, "g_110", print_hash_value);
    transparent_crc(g_136, "g_136", print_hash_value);
    transparent_crc(g_143, "g_143", print_hash_value);
    transparent_crc(g_164, "g_164", print_hash_value);
    transparent_crc(g_242, "g_242", print_hash_value);
    transparent_crc(g_376, "g_376", print_hash_value);
    transparent_crc(g_385, "g_385", print_hash_value);
    transparent_crc(g_414, "g_414", print_hash_value);
    transparent_crc(g_516, "g_516", print_hash_value);
    transparent_crc(g_582, "g_582", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 116
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 33
   depth: 3, occurrence: 4
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 19, occurrence: 2
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 69

XXX times a variable address is taken: 87
XXX times a pointer is dereferenced on RHS: 108
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 27
XXX times a pointer is dereferenced on LHS: 93
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 12
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 432

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 451
   level: 2, occurrence: 104
   level: 3, occurrence: 18
   level: 4, occurrence: 11
XXX number of pointers point to pointers: 32
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.7
XXX average alias set size: 1.38

XXX times a non-volatile is read: 578
XXX times a non-volatile is write: 211
XXX times a volatile is read: 61
XXX    times read thru a pointer: 17
XXX times a volatile is write: 25
XXX    times written thru a pointer: 11
XXX times a volatile is available for access: 187
XXX percentage of non-volatile access: 90.2

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 122
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 16
   depth: 2, occurrence: 17
   depth: 3, occurrence: 16
   depth: 4, occurrence: 22
   depth: 5, occurrence: 23

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
********************* end of statistics **********************/

