/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      927030588
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int8_t  f0;
};

union U1 {
   const uint16_t  f0;
   int16_t  f1;
   uint16_t  f2;
   const struct S0  f3;
   int8_t * f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U1  func_1(void);
inline static const int32_t * func_2(uint16_t  p_3, int8_t * p_4, int32_t  p_5, int8_t * p_6, union U1  p_7);
inline static int8_t * func_9(uint32_t  p_10, int32_t * p_11, float  p_12, union U1  p_13);
static int32_t * func_14(int32_t  p_15, int8_t  p_16, int32_t  p_17, float  p_18);
inline static uint16_t  func_24(int32_t * p_25, int32_t * p_26, int32_t  p_27, int8_t * p_28, int8_t * p_29);
inline static int32_t * func_30(int32_t * p_31, int8_t * p_32, int32_t * p_33, int8_t  p_34);
inline static const uint32_t  func_39(uint16_t  p_40);
static int16_t  func_44(const int32_t * p_45, int32_t  p_46);
static int32_t * func_47(int32_t * p_48, int32_t  p_49, union U1  p_50);
static uint16_t  func_57(int8_t * p_58, const int32_t * p_59, float  p_60, const uint32_t  p_61, int16_t  p_62);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_1(void)
{ /* block id: 0 */
    int8_t l_8 = 0x3D;
    union U1 l_19 = {0U};
    int32_t l_36 = 0x7D228D5F;
    int32_t *l_35 = &l_36;
    int16_t l_418 = 0;
    union U1 l_727 = {0U};
    const int32_t *l_821 = &l_36;
    struct S0 l_822 = {-1};
    struct S0 *l_823 = &l_822;
    float l_826 = (-0x8.9p-1);
    int8_t *l_852 = (void*)0;
    int8_t **l_851 = &l_852;
    const int32_t l_873 = 0x2376C821;
    uint32_t l_930 = 7U;
    union U1 *l_932 = &l_727;
    union U1 **l_931 = &l_932;
    uint32_t l_943 = 0x867AD276;
    uint32_t l_989 = 9U;
    int32_t l_1029 = (-1);
    float l_1039 = 0x3.7p+1;
    int8_t l_1041 = 0xDC;
    uint32_t l_1047 = 9U;
    int32_t l_1048 = 0x4512847C;
    union U1 l_1051 = {0x286A};
    l_821 = func_2(l_8, func_9(l_8, func_14((0x70A3 >= (l_19 , ((int32_t)l_19.f1 - (int32_t)(((uint16_t)func_24(func_30(l_35, &l_8, &l_36, (((int16_t)(func_39(((((uint16_t)(((((*l_35) , (void*)0) == (void*)0) , (*l_35)) == 0xDCEE0524) * (uint16_t)(*l_35)) ^ (*l_35)) | (*l_35))) > 3) / (int16_t)(*l_35)) != (-1))), &l_36, (*l_35), &l_8, &l_8) << (uint16_t)l_19.f0) , (*l_35))))), l_418, l_418, l_19.f0), l_19.f1, l_19), l_19.f0, &l_8, l_727);
    (*l_35) = (*l_35);
    (*l_823) = l_822;
    for (l_418 = 0; (l_418 < 2); l_418 += 7)
    { /* block id: 288 */
        int16_t l_831 = 4;
        float *l_837 = &l_826;
        float l_841 = (-0x1.5p+1);
        int8_t ***l_895 = &l_851;
        union U1 l_902 = {65530U};
        const int8_t l_915 = 4;
        union U1 *l_920 = &l_19;
        union U1 **l_919 = &l_920;
        union U1 ***l_918 = &l_919;
        int32_t l_927 = 0x823B1CDA;
        int8_t l_948 = 1;
        int8_t l_954 = 0;
        int32_t l_963 = 0x5BB2A744;
        int8_t *l_974 = &l_8;
        const int32_t **l_988 = &l_821;
        uint32_t l_1040 = 0x7878C89D;
        if ((*l_35))
        { /* block id: 289 */
            float *l_838 = &l_826;
            int32_t l_842 = 0x7812EFBE;
            int8_t **l_853 = &l_852;
            union U1 *l_870 = &l_19;
            uint16_t l_896 = 65535U;
            uint32_t l_901 = 9U;
            uint32_t l_916 = 0xB32FB7CD;
            (*l_35) = ((((int32_t)((uint32_t)l_831 / (uint32_t)((uint16_t)((uint16_t)(+((l_831 == (l_837 == l_838)) == ((uint16_t)((((((0x4049 || l_842) , (((uint16_t)((int16_t)((uint16_t)(((uint32_t)((l_727 , l_851) != l_853) - (uint32_t)(*l_35)) ^ 0x61BF) % (uint16_t)0x3513) + (int16_t)l_831) >> (uint16_t)11) == l_831)) >= l_842) , l_831) != l_842) & 0xEE5861C3) * (uint16_t)l_831))) << (uint16_t)l_831) % (uint16_t)l_831)) + (int32_t)(*l_35)) & 0x6677945A) < l_831);
            for (l_8 = 29; (l_8 >= 11); l_8 -= 5)
            { /* block id: 293 */
                int8_t l_876 = 7;
                union U1 l_894 = {65535U};
                uint32_t l_897 = 0x504BD36A;
            }
        }
        else
        { /* block id: 315 */
            const int32_t *l_935 = &l_36;
            int32_t **l_936 = &l_35;
            int32_t l_947 = 0;
            struct S0 **l_960 = &l_823;
            struct S0 l_976 = {-9};
            union U1 l_1007 = {0x519C};
            (*l_936) = l_935;
            if (((((uint16_t)(1 > (((0x295C <= (*l_35)) | (((uint16_t)(l_831 || l_915) * (uint16_t)((l_943 < (+(((((void*)0 == (**l_895)) != ((((((uint32_t)(*l_35) + (uint32_t)l_947) ^ 65530U) >= (**l_936)) ^ 65535U) < (*l_35))) > (*l_35)) , (-3)))) || 0U)) > (**l_936))) <= l_948)) << (uint16_t)l_902.f2) , (*l_932)) , l_915))
            { /* block id: 317 */
                const uint32_t l_951 = 4294967289U;
                uint16_t l_955 = 65535U;
                const struct S0 l_964 = {3};
                (*l_35) = (((**l_936) >= ((**l_936) && ((-5) == ((int16_t)(l_927 >= (((l_951 <= ((&l_36 != (void*)0) == 0xBD6BC1DC)) <= ((((uint16_t)(((1U >= l_902.f1) & l_951) && l_915) << (uint16_t)l_954) < (-1)) && 65529U)) | (*l_35))) + (int16_t)l_955)))) < (*l_935));
                (**l_936) = ((uint16_t)((((uint16_t)0U * (uint16_t)((((((void*)0 == l_960) == ((int16_t)0xD0E2 * (int16_t)(l_963 | (**l_936)))) , (((*l_35) & (*l_935)) < (l_963 == 0x7A463D9F))) ^ l_948) <= l_902.f1)) , 0x808D) == l_951) % (uint16_t)l_927);
                (*l_936) = (*l_936);
                (**l_960) = l_964;
            }
            else
            { /* block id: 322 */
                int32_t *l_967 = &l_927;
                int32_t l_968 = 0xA4B84191;
                struct S0 *l_1005 = (void*)0;
                uint16_t l_1026 = 0x5BEE;
                for (l_954 = 18; (l_954 > 20); l_954 += 9)
                { /* block id: 325 */
                    int8_t ***l_972 = &l_851;
                    int32_t l_973 = (-1);
                    int32_t **l_987 = (void*)0;
                    int8_t *l_1006 = (void*)0;
                    float *l_1027 = &l_841;
                    union U1 ***l_1028 = &l_919;
                }
                l_927 = (*l_35);
            }
        }
        if ((~((int16_t)((int16_t)(l_954 > (*l_35)) << (int16_t)(0xB2336F94 | (((uint16_t)(l_927 != ((((uint16_t)((l_927 , (l_1040 ^ ((l_1041 <= ((uint16_t)((0x5544 != (((uint16_t)(((~((((0x462B6B86 == 0xCD9C1ACF) , 7U) != 0xE5D663CB) < (*l_35))) ^ 0x3BEA633E) >= (*l_35)) - (uint16_t)(*l_35)) == 0x746B38DE)) == l_1047) >> (uint16_t)(*l_35))) >= (*l_35)))) != l_1048) << (uint16_t)l_963) != 0x09CA7560) , 0x9BDBEEFA)) << (uint16_t)14) < (*l_35)))) / (int16_t)(*l_35))))
        { /* block id: 342 */
            int16_t l_1049 = 0x9360;
            l_927 = l_1049;
        }
        else
        { /* block id: 344 */
            union U1 ****l_1050 = &l_918;
            (*l_1050) = &l_931;
        }
    }
    return l_1051;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_2(uint16_t  p_3, int8_t * p_4, int32_t  p_5, int8_t * p_6, union U1  p_7)
{ /* block id: 241 */
    union U1 l_730 = {0x6EFB};
    int32_t *l_731 = (void*)0;
    float l_744 = 0x1.277E27p-43;
    float *l_743 = &l_744;
    struct S0 l_774 = {1};
    int16_t l_817 = 0x3FA1;
lbl_736:
    for (p_3 = (-22); (p_3 != 2); p_3 += 8)
    { /* block id: 244 */
        int32_t **l_732 = &l_731;
        union U1 **l_733 = (void*)0;
        union U1 *l_735 = &l_730;
        union U1 **l_734 = &l_735;
        (*l_732) = (l_730 , l_731);
        if (p_3)
            goto lbl_736;
        (*l_734) = &l_730;
        if (l_730.f0)
            goto lbl_736;
    }
    for (p_5 = (-10); (p_5 <= 6); p_5 += 9)
    { /* block id: 252 */
        float l_739 = 0x7.819AA4p+5;
        int32_t l_740 = 0x6EBD1A48;
        float *l_745 = &l_744;
        int32_t **l_768 = &l_731;
        struct S0 l_769 = {0x9E};
        const int8_t *l_820 = &l_774.f0;
        const int8_t **l_819 = &l_820;
        const int8_t ***l_818 = &l_819;
    }
    return l_731;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t * func_9(uint32_t  p_10, int32_t * p_11, float  p_12, union U1  p_13)
{ /* block id: 160 */
    int32_t *l_457 = (void*)0;
    int32_t **l_456 = &l_457;
    int32_t ***l_455 = &l_456;
    int32_t ****l_454 = &l_455;
    int8_t l_475 = 0x04;
    int8_t *l_474 = &l_475;
    int8_t **l_473 = &l_474;
    int8_t ***l_510 = &l_473;
    struct S0 l_521 = {0x5B};
    struct S0 *l_528 = &l_521;
    int32_t l_537 = 0x290F1359;
    union U1 l_598 = {1U};
    union U1 *l_597 = &l_598;
    union U1 **l_596 = &l_597;
    int8_t *l_610 = &l_475;
    int8_t *l_678 = (void*)0;
    int8_t *l_698 = &l_521.f0;
    int8_t l_708 = (-1);
    int8_t l_723 = 0x85;
    int32_t l_724 = 0x3E775A52;
    int8_t *l_725 = &l_521.f0;
    int8_t *l_726 = (void*)0;
    for (p_10 = 0; (p_10 <= 4); p_10++)
    { /* block id: 163 */
        int32_t l_434 = 0x72AB68A4;
        int8_t l_441 = 0x7D;
        int8_t *l_440 = &l_441;
        int32_t *l_453 = (void*)0;
        int32_t **l_452 = &l_453;
        int32_t ***l_451 = &l_452;
        int32_t ****l_450 = &l_451;
        int16_t l_458 = (-10);
        union U1 l_465 = {0U};
        union U1 *l_464 = &l_465;
        struct S0 l_500 = {0xFD};
        struct S0 *l_499 = &l_500;
        int32_t l_625 = 0xE6B401B5;
        int8_t *l_697 = &l_521.f0;
        int8_t *l_699 = &l_441;
        int8_t *l_703 = &l_521.f0;
        for (l_434 = 15; (l_434 >= 3); l_434 -= 1)
        { /* block id: 166 */
            int32_t *l_438 = (void*)0;
            int32_t **l_437 = &l_438;
            int8_t ***l_439 = (void*)0;
            union U1 l_443 = {0x1D84};
            union U1 *l_442 = &l_443;
            struct S0 l_460 = {0x04};
            struct S0 *l_459 = &l_460;
            int32_t l_524 = 7;
            uint32_t l_542 = 1U;
            int32_t l_544 = 6;
            int8_t *l_585 = &l_475;
            int8_t *l_586 = &l_500.f0;
            int8_t *l_588 = &l_475;
            int8_t *l_591 = (void*)0;
            (*l_437) = (void*)0;
        }
        if (l_625)
            continue;
        for (l_441 = 6; (l_441 <= 8); l_441 += 3)
        { /* block id: 211 */
            union U1 l_628 = {65535U};
            int32_t *l_629 = (void*)0;
            uint16_t l_630 = 0xCA7B;
            int8_t *l_634 = &l_441;
            const int32_t l_641 = 0xE215AE74;
            const int32_t *l_648 = &l_434;
            struct S0 l_663 = {1};
            int8_t *l_676 = &l_521.f0;
            int8_t *l_701 = &l_521.f0;
            (*l_456) = (l_628 , func_47(l_629, l_630, (**l_596)));
            for (l_500.f0 = 23; (l_500.f0 != 7); l_500.f0--)
            { /* block id: 215 */
                struct S0 **l_633 = &l_528;
                (*l_633) = &l_521;
            }
            l_648 = &l_641;
            for (l_434 = (-14); (l_434 <= 16); l_434 += 1)
            { /* block id: 221 */
                int32_t l_653 = 5;
                float l_661 = 0x1.8p-1;
                float *l_660 = &l_661;
                int32_t *l_662 = &l_537;
                union U1 *l_666 = &l_598;
                int8_t *l_669 = &l_475;
                int8_t *l_672 = &l_663.f0;
                int8_t *l_677 = &l_500.f0;
                int8_t *l_695 = &l_441;
                int8_t *l_700 = &l_441;
                int8_t *l_702 = &l_475;
                int8_t *l_704 = &l_500.f0;
                int8_t *l_705 = (void*)0;
                (*l_660) = ((float)l_653 / (float)(0x0.3p-1 < ((float)(0x5.A26307p-32 > p_12) / (float)((float)((float)l_653 * (float)(((p_12 != (*l_648)) >= (-0x9.Dp-1)) < p_13.f1)) + (float)0x2.3E8EF4p+76))));
                (*l_662) = (*l_648);
                (*l_499) = l_663;
                for (l_458 = 0; (l_458 >= 8); l_458++)
                { /* block id: 227 */
                    int8_t *l_670 = &l_500.f0;
                    int8_t *l_673 = &l_475;
                    int8_t *l_675 = &l_521.f0;
                    const int32_t l_692 = 0xE13BADAA;
                    float *l_693 = &l_661;
                    int8_t *l_696 = &l_441;
                    (*l_596) = l_666;
                    if (((int16_t)p_10 >> (int16_t)8))
                    { /* block id: 229 */
                        int8_t *l_671 = &l_441;
                        int8_t *l_674 = &l_500.f0;
                        return l_678;
                    }
                    else
                    { /* block id: 231 */
                        int8_t *l_694 = &l_475;
                        (*l_662) = (((int16_t)p_13.f0 * (int16_t)(p_13.f1 , ((((((((uint32_t)4294967295U + (uint32_t)((((((uint16_t)(*l_662) / (uint16_t)((!(((((((uint32_t)6U + (uint32_t)p_13.f0) || ((uint32_t)((int32_t)((((*l_455) == (void*)0) && l_692) != l_692) - (int32_t)4294967295U) % (uint32_t)0x673F1BD5)) | p_13.f0) & p_13.f0) || p_13.f2) != p_13.f1)) , p_10)) != p_13.f2) || l_692) != p_13.f1) && l_692)) , p_10) , (-1)) | (*l_662)) , 0xEAC51B79) , l_693) != l_457))) , 0x661BD51D);
                        return l_705;
                    }
                }
            }
        }
    }
    l_724 = ((uint32_t)(l_708 >= (p_13.f1 < (((((uint16_t)((int16_t)((int16_t)(((((((((int32_t)((((int16_t)(65531U >= ((((int32_t)p_13.f2 - (int32_t)((((p_13.f0 , p_13.f0) , ((void*)0 == (*l_455))) && (p_13.f1 < p_13.f2)) != 6)) & 0x53DC0A3C) || 0x5004)) << (int16_t)p_13.f2) && 0) | 1) / (int32_t)4) > l_723) | p_13.f0) != p_13.f0) , (*l_596)) != (*l_596)) <= p_13.f1) | 6) * (int16_t)p_13.f0) << (int16_t)8) - (uint16_t)p_10) & p_10) <= p_13.f0) > p_13.f1))) + (uint32_t)(-1));
    return l_726;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_14(int32_t  p_15, int8_t  p_16, int32_t  p_17, float  p_18)
{ /* block id: 154 */
    int32_t **l_419 = (void*)0;
    int32_t **l_420 = (void*)0;
    int32_t **l_421 = (void*)0;
    int32_t l_423 = (-1);
    int32_t *l_422 = &l_423;
    struct S0 l_425 = {1};
    struct S0 *l_424 = &l_425;
    struct S0 **l_426 = &l_424;
    int32_t *l_427 = &l_423;
    int32_t *l_428 = &l_423;
    int32_t *l_429 = &l_423;
    int32_t *l_430 = &l_423;
    int32_t *l_431 = (void*)0;
    l_422 = &p_17;
    (*l_426) = l_424;
    (*l_426) = (*l_426);
    (*l_424) = (**l_426);
    return l_431;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_24(int32_t * p_25, int32_t * p_26, int32_t  p_27, int8_t * p_28, int8_t * p_29)
{ /* block id: 93 */
    union U1 l_282 = {0x3BA5};
    union U1 *l_281 = &l_282;
    struct S0 l_283 = {-1};
    int8_t *l_286 = &l_283.f0;
    int8_t **l_285 = &l_286;
    int8_t ***l_284 = &l_285;
    const int32_t *l_290 = (void*)0;
    const int32_t **l_289 = &l_290;
    int32_t l_326 = 0x35BA4CF4;
    uint16_t l_354 = 0xFF22;
    int32_t l_404 = 0;
    if (((uint16_t)(l_281 == (((l_283 , l_284) == &l_285) , &l_282)) >> (uint16_t)8))
    { /* block id: 94 */
        int32_t l_291 = 0xB7763822;
        struct S0 l_331 = {0x12};
        union U1 *l_345 = (void*)0;
        int32_t *l_358 = &l_326;
        for (p_27 = 0; (p_27 == 22); p_27 += 7)
        { /* block id: 97 */
            int32_t l_294 = 0x693F941D;
            struct S0 l_327 = {-1};
            int32_t *l_337 = (void*)0;
            l_291 = (p_27 < ((l_289 != &p_26) >= 0x5.147843p-17));
            if (((l_294 & ((void*)0 == (*l_284))) | (((l_291 >= 0U) && ((int16_t)((((uint16_t)(((((int32_t)0 / (int32_t)(((l_294 > ((p_27 != (((1U && p_27) <= l_294) & 3)) , (*p_25))) != 65535U) ^ l_291)) & 0xF3FE) == p_27) >= 0x3E921230) >> (uint16_t)l_291) ^ (-7)) ^ 8U) >> (int16_t)l_291)) >= l_291)))
            { /* block id: 99 */
                const int8_t l_305 = 0x57;
                int8_t *l_338 = (void*)0;
                int32_t *l_347 = &l_326;
                if (((int16_t)((((*p_25) || l_305) | ((((uint32_t)(((void*)0 == &l_281) || (((p_27 , ((0x72F1 || ((((int32_t)((((((((uint32_t)((((int16_t)(((uint16_t)6U << (uint16_t)5) , (((uint32_t)(((int16_t)((uint32_t)(((int32_t)(l_294 , (((uint16_t)0x2520 >> (uint16_t)9) <= l_291)) - (int32_t)4) || p_27) + (uint32_t)p_27) >> (int16_t)p_27) > l_326) % (uint32_t)(-1)) , (-3))) / (int16_t)p_27) , p_27) ^ p_27) - (uint32_t)p_27) | l_294) , (-7)) >= (-6)) <= 0xB3E879FE) != p_27) >= l_305) / (int32_t)l_291) , p_27) , p_27)) ^ 1U)) && p_27) , 1U)) + (uint32_t)p_27) , l_294) != l_305)) && p_27) * (int16_t)p_27))
                { /* block id: 100 */
                    struct S0 l_328 = {0x73};
                    l_328 = l_327;
                }
                else
                { /* block id: 102 */
                    for (l_294 = 0; (l_294 <= 14); l_294 += 1)
                    { /* block id: 105 */
                        struct S0 *l_332 = &l_327;
                        (*l_332) = l_331;
                    }
                    for (l_327.f0 = 18; (l_327.f0 >= 21); l_327.f0 += 5)
                    { /* block id: 110 */
                        float l_336 = (-0x2.6p+1);
                        float *l_335 = &l_336;
                        int32_t l_346 = 0x99BDF1EA;
                        (*l_335) = 0x1.7p+1;
                        (*l_289) = l_347;
                        (*l_289) = (void*)0;
                    }
                    (*p_25) = (*p_25);
                }
                l_326 = l_331.f0;
            }
            else
            { /* block id: 118 */
                int16_t l_357 = 0xFDBE;
                l_358 = func_30(&l_291, p_29, &l_291, ((int16_t)((((int32_t)((int16_t)((((&p_26 == (void*)0) ^ (0xC137 > l_354)) >= ((int16_t)p_27 << (int16_t)(((1 < l_357) && l_357) , 0x3399))) != l_357) % (int16_t)l_357) + (int32_t)(-10)) , (*p_25)) || l_331.f0) + (int16_t)p_27));
                for (l_326 = 26; (l_326 < (-26)); l_326 -= 8)
                { /* block id: 122 */
                    struct S0 *l_361 = &l_331;
                    union U1 **l_362 = &l_345;
                    int32_t l_363 = (-1);
                    float l_365 = (-0x3.3p+1);
                    float *l_364 = &l_365;
                    (*l_361) = l_327;
                    (*l_364) = (((l_362 == (void*)0) && (l_363 , (&l_283 == &l_283))) , (-0x2.Cp+1));
                    (*l_289) = func_47(&l_363, l_357, (*l_281));
                }
                (*p_25) = (*p_26);
            }
        }
    }
    else
    { /* block id: 130 */
        int8_t l_366 = 0x10;
        float l_368 = 0xE.7F253Ep-45;
        const float *l_367 = &l_368;
        int32_t *l_393 = &l_326;
        int32_t **l_392 = &l_393;
        int32_t ***l_391 = &l_392;
        union U1 **l_416 = &l_281;
        if (((l_283 , (((0xA54F258C & l_366) , l_290) != l_367)) == (*p_26)))
        { /* block id: 131 */
            const int8_t l_390 = 0x20;
            for (p_27 = (-22); (p_27 == (-27)); p_27--)
            { /* block id: 134 */
                int16_t l_387 = (-8);
                for (l_366 = 0; (l_366 <= (-20)); l_366 -= 3)
                { /* block id: 137 */
                    uint32_t l_379 = 0x8FB73719;
                    union U1 l_388 = {1U};
                    uint32_t l_389 = 0x2FEB1DDC;
                    (*p_25) = ((((uint16_t)((((int16_t)((((uint16_t)(l_379 != (((int16_t)0x817D * (int16_t)(((int16_t)l_366 * (int16_t)((uint16_t)p_27 >> (uint16_t)(((!((((void*)0 == (**l_284)) < ((&p_29 == (((((*p_25) < (&l_285 == (void*)0)) > l_379) , p_27) , (void*)0)) , l_387)) , p_27)) , l_388) , 9))) && 1U)) != l_366)) << (uint16_t)l_366) , p_27) != l_388.f1) % (int16_t)l_388.f0) || 1) && l_379) / (uint16_t)l_389) < p_27) && 5U);
                    if ((*p_26))
                        break;
                    (***l_391) = ((((((0x4757 || (p_27 == l_390)) <= ((0xA80F ^ l_387) <= ((((l_391 != &l_392) , l_390) | ((uint16_t)((uint32_t)((***l_391) , 1U) % (uint32_t)0x4E70C977) >> (uint16_t)14)) , l_388.f0))) , (void*)0) == p_28) != l_387) <= (-4));
                    if ((*p_26))
                        break;
                }
                if ((*p_26))
                    break;
            }
        }
        else
        { /* block id: 145 */
            uint16_t l_406 = 2U;
            int32_t l_417 = (-1);
            (**l_392) = ((((((uint16_t)((int16_t)((int16_t)l_404 * (int16_t)((**l_392) == (!((0x8D96F55D ^ ((((l_406 && (l_406 | (((*l_393) != l_406) , ((((uint16_t)((int16_t)(+((-1) <= (((int16_t)((uint16_t)(l_416 != l_416) >> (uint16_t)8) * (int16_t)65535U) > 0))) % (int16_t)(***l_391)) % (uint16_t)0x9EFC) || l_417) >= p_27)))) , (*l_285)) != (void*)0) >= 0x7162)) , (***l_391))))) * (int16_t)p_27) * (uint16_t)(**l_392)) >= 4294967295U) <= 0xFE8B) > (*p_26)) != 0x71BC);
            return p_27;
        }
        return p_27;
    }
    (*l_289) = func_47(&l_326, p_27, (*l_281));
    p_25 = func_30(&l_326, p_29, &l_326, (*p_28));
    return l_404;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_30(int32_t * p_31, int8_t * p_32, int32_t * p_33, int8_t  p_34)
{ /* block id: 89 */
    int32_t l_251 = 0x82E6EA6D;
    int32_t *l_250 = &l_251;
    union U1 l_259 = {0xF2A4};
    union U1 *l_258 = &l_259;
    int32_t **l_262 = &l_250;
    int8_t l_264 = 5;
    const int8_t *l_263 = &l_264;
    const struct S0 l_271 = {0x2A};
    uint32_t l_278 = 0x0D83C71B;
    (*l_262) = func_47(l_250, ((uint16_t)((((uint32_t)(*l_250) + (uint32_t)((uint16_t)0xA1D5 >> (uint16_t)6)) ^ (l_258 == &l_259)) , 65534U) << (uint16_t)(0x2E42D4C9 & ((uint32_t)(*l_250) % (uint32_t)0x484EA1F2))), (*l_258));
    (*l_262) = func_47(((((((void*)0 == l_263) ^ (0x34DAAF50 > ((int16_t)((int16_t)0 % (int16_t)(-1)) % (int16_t)((uint16_t)((((l_271 , p_34) && ((int16_t)(((*p_31) , ((uint16_t)((uint16_t)0xD7FB * (uint16_t)65528U) - (uint16_t)7)) == p_34) << (int16_t)l_278)) >= p_34) | p_34) / (uint16_t)5U)))) & 1U) < 0xEFCC) , p_33), p_34, (*l_258));
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_39(uint16_t  p_40)
{ /* block id: 1 */
    uint16_t l_43 = 65535U;
    int32_t l_52 = 0x4FE10EF7;
    int32_t *l_51 = &l_52;
    int8_t l_64 = 6;
    int8_t *l_63 = &l_64;
    union U1 l_77 = {0x2CF1};
    const uint16_t l_105 = 0U;
    int32_t ***l_144 = (void*)0;
    int32_t ****l_143 = &l_144;
    union U1 l_185 = {65529U};
    union U1 *l_184 = &l_185;
    float l_249 = 0x9.Fp-1;
    float *l_248 = &l_249;
    if ((((l_43 & p_40) > func_44(func_47(l_51, ((int16_t)(*l_51) + (int16_t)(((uint16_t)p_40 >> (uint16_t)func_57(l_63, &l_52, ((float)((((uint16_t)(*l_51) - (uint16_t)((((&l_64 != (void*)0) | (*l_51)) < (*l_51)) && (*l_51))) | (*l_51)) , (*l_51)) - (float)0x2.7EBDCFp+32), p_40, p_40)) | (*l_51))), l_77), p_40)) && 0xB5C3))
    { /* block id: 27 */
        return l_105;
    }
    else
    { /* block id: 29 */
        int32_t **l_106 = &l_51;
        int32_t ***l_107 = &l_106;
        int8_t *l_126 = &l_64;
        struct S0 l_242 = {1};
        struct S0 *l_243 = &l_242;
        (*l_107) = l_106;
        if (p_40)
        { /* block id: 31 */
            int8_t l_125 = (-7);
            if (((int32_t)1 + (int32_t)(((uint16_t)((*l_51) || (0x1A75D104 > 1)) - (uint16_t)((!((uint16_t)(p_40 <= ((int32_t)((uint16_t)(p_40 < ((!((0x93D5 == (+((int32_t)l_125 + (int32_t)(((((*l_51) <= p_40) , l_126) != (void*)0) , 0xEB7B5DC4)))) | 1U)) ^ (*l_51))) * (uint16_t)0x9DB4) % (int32_t)(*l_51))) * (uint16_t)l_125)) ^ p_40)) >= p_40)))
            { /* block id: 32 */
                struct S0 l_127 = {0xF4};
                struct S0 *l_128 = &l_127;
                (*l_128) = l_127;
            }
            else
            { /* block id: 34 */
                (*l_51) = ((uint16_t)65532U >> (uint16_t)10);
            }
        }
        else
        { /* block id: 37 */
            float l_140 = 0x3.Ap+1;
            union U1 *l_146 = &l_77;
            int32_t l_159 = 0xB95FC1DD;
            int8_t l_183 = 0x83;
            struct S0 *l_202 = (void*)0;
            int8_t l_238 = 1;
            for (l_43 = 0; (l_43 != 22); l_43 += 1)
            { /* block id: 40 */
                int32_t *l_135 = (void*)0;
                int32_t ****l_145 = (void*)0;
                for (l_52 = 0; (l_52 >= (-14)); l_52--)
                { /* block id: 43 */
                    struct S0 l_154 = {-8};
                    struct S0 *l_153 = &l_154;
                    union U1 l_170 = {0x0AF2};
                    int32_t *l_197 = &l_159;
                    l_135 = &l_52;
                    for (l_64 = 0; (l_64 <= (-4)); l_64 -= 2)
                    { /* block id: 47 */
                        int32_t l_142 = 1;
                        int32_t *l_141 = &l_142;
                        union U1 **l_147 = (void*)0;
                        union U1 **l_148 = (void*)0;
                        union U1 **l_149 = (void*)0;
                        const union U1 *l_151 = &l_77;
                        const union U1 **l_150 = &l_151;
                    }
                    if (((-(int16_t)((void*)0 == l_153)) >= (((p_40 && ((int32_t)((l_159 == ((((+0) || (l_159 == ((int16_t)((((int16_t)(1 >= p_40) * (int16_t)2U) , (void*)0) != (void*)0) >> (int16_t)2))) , 0xD8E1) | 0x4629)) || 5U) / (int32_t)p_40)) >= 0) >= p_40)))
                    { /* block id: 53 */
                        union U1 l_171 = {6U};
                        int32_t ***l_174 = &l_106;
                        int32_t *l_186 = &l_159;
                        (*l_106) = func_47(func_47((*l_106), ((uint16_t)65535U >> (uint16_t)((!p_40) , p_40)), (((int16_t)0x90A9 + (int16_t)l_154.f0) , (*l_146))), p_40, l_170);
                        (*l_106) = (l_171 , (**l_107));
                        l_184 = (((float)((((void*)0 == (**l_107)) == ((void*)0 != l_174)) >= p_40) * (float)((float)((((float)(p_40 < ((0x5.01E2ACp+2 >= ((float)((((float)0xF.D96F57p-93 + (float)p_40) <= p_40) <= p_40) * (float)l_183)) < p_40)) / (float)0x0.Bp-1) >= 0x1.B5A963p-88) < l_183) - (float)p_40)) , (void*)0);
                        (*l_186) = (l_145 == (void*)0);
                    }
                    else
                    { /* block id: 58 */
                        int32_t *l_187 = &l_52;
                        float *l_194 = &l_140;
                        (**l_107) = l_187;
                        (*l_194) = ((float)((float)0x6.Dp+1 / (float)(((p_40 <= p_40) < ((void*)0 == &l_185)) , (&l_183 == (((uint16_t)p_40 / (uint16_t)0x578D) , (void*)0)))) + (float)l_154.f0);
                    }
                    (*l_197) = (l_159 != (((uint32_t)0xE961C82C / (uint32_t)(4294967287U | p_40)) || 0x99B7));
                }
            }
            if (p_40)
            { /* block id: 65 */
                return p_40;
            }
            else
            { /* block id: 67 */
                int32_t l_207 = (-1);
                int32_t *l_241 = &l_159;
                for (l_43 = (-21); (l_43 == 26); l_43 += 1)
                { /* block id: 70 */
                    int32_t l_219 = (-1);
                    if (((int16_t)((((void*)0 != l_202) < (p_40 != l_183)) , ((int16_t)((uint16_t)(l_207 > (((0x011E != p_40) > (((int16_t)(p_40 == ((int32_t)((((uint16_t)((uint32_t)((int16_t)(((+(4294967293U < 3U)) >= l_183) | 0xBB6E3EA3) << (int16_t)5) % (uint32_t)p_40) / (uint16_t)p_40) != 1) ^ 0xFAD472F8) - (int32_t)l_219)) * (int16_t)l_219) , p_40)) != 0xCC31)) << (uint16_t)12) * (int16_t)65526U)) * (int16_t)p_40))
                    { /* block id: 71 */
                        return l_219;
                    }
                    else
                    { /* block id: 73 */
                        const int8_t *l_221 = &l_64;
                        const int8_t **l_220 = &l_221;
                        int8_t **l_223 = &l_63;
                        int8_t ***l_222 = &l_223;
                        int32_t *l_224 = (void*)0;
                        float *l_225 = &l_140;
                        (*l_222) = l_220;
                        if (p_40)
                            break;
                        l_224 = l_224;
                        (*l_225) = l_207;
                    }
                    l_159 = 0x00FD19F2;
                }
                (*l_241) = ((((uint16_t)((uint16_t)(((uint16_t)((int16_t)0x0D73 + (int16_t)(&l_106 == (*l_143))) % (uint16_t)(((int16_t)(((uint16_t)l_183 >> (uint16_t)p_40) != p_40) + (int16_t)l_238) , ((uint16_t)0x9236 >> (uint16_t)p_40))) || 0x46BDB765) * (uint16_t)(-1)) - (uint16_t)p_40) >= 0xDAF6) != p_40);
                return p_40;
            }
        }
        (*l_243) = l_242;
    }
    (*l_248) = ((float)((((*l_51) <= p_40) >= p_40) , (*l_51)) + (float)((float)(*l_51) + (float)0x0.Fp-1));
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_44(const int32_t * p_45, int32_t  p_46)
{ /* block id: 19 */
    float l_87 = (-0x1.6p+1);
    int32_t l_96 = (-8);
    if ((((((p_46 , &p_45) != (((int16_t)(4U == ((uint16_t)(p_46 || ((uint16_t)((uint16_t)l_96 - (uint16_t)p_46) >> (uint16_t)((uint32_t)(l_96 | ((l_96 <= ((((l_96 , (-7)) ^ 0x9DA5) != p_46) | l_96)) == l_96)) % (uint32_t)l_96))) + (uint16_t)l_96)) << (int16_t)12) , (void*)0)) & l_96) > 0) , l_96))
    { /* block id: 20 */
        struct S0 l_99 = {3};
        struct S0 *l_100 = &l_99;
        (*l_100) = l_99;
    }
    else
    { /* block id: 22 */
        int32_t **l_101 = (void*)0;
        int32_t *l_103 = (void*)0;
        int32_t **l_102 = &l_103;
        int32_t l_104 = 0x37C870D1;
        (*l_102) = (void*)0;
        l_96 = (l_104 , 0x1160C006);
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_47(int32_t * p_48, int32_t  p_49, union U1  p_50)
{ /* block id: 14 */
    struct S0 l_78 = {-1};
    struct S0 *l_79 = &l_78;
    const int32_t l_81 = 0x12EA0FEF;
    const int32_t *l_80 = &l_81;
    int32_t l_84 = 0xDF200869;
    int32_t *l_83 = &l_84;
    int32_t **l_82 = &l_83;
    int32_t *l_85 = &l_84;
    int32_t *l_86 = (void*)0;
    (*l_79) = l_78;
    (*l_82) = l_80;
    p_48 = (*l_82);
    return l_86;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_57(int8_t * p_58, const int32_t * p_59, float  p_60, const uint32_t  p_61, int16_t  p_62)
{ /* block id: 2 */
    struct S0 l_76 = {1};
    struct S0 *l_75 = &l_76;
    for (p_62 = 0; (p_62 >= 7); p_62++)
    { /* block id: 5 */
        if ((*p_59))
        { /* block id: 6 */
            int8_t l_71 = (-3);
            return l_71;
        }
        else
        { /* block id: 8 */
            int32_t l_72 = 0x4D97F668;
            int32_t l_74 = 5;
            int32_t *l_73 = &l_74;
            (*l_73) = l_72;
        }
    }
    l_75 = l_75;
    return l_76.f0;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 242
   depth: 1, occurrence: 21
XXX total union variables: 14

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 28
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 4
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 27, occurrence: 2
   depth: 28, occurrence: 2
   depth: 31, occurrence: 1
   depth: 39, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 263

XXX times a variable address is taken: 241
XXX times a pointer is dereferenced on RHS: 160
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 23
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 96
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 781

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 352
   level: 2, occurrence: 125
   level: 3, occurrence: 55
   level: 4, occurrence: 29
XXX number of pointers point to pointers: 80
XXX number of pointers point to scalars: 149
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 20.9
XXX average alias set size: 1.16

XXX times a non-volatile is read: 1087
XXX times a non-volatile is write: 257
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 138
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 20
   depth: 2, occurrence: 21
   depth: 3, occurrence: 25
   depth: 4, occurrence: 19
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 12.5
XXX percentage an existing variable is used: 87.5
********************* end of statistics **********************/

