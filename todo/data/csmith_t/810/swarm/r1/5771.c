/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --no-math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3371130690
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   float  f1;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_8 = 4294967293U;
static int32_t g_42 = 1;
static int32_t *g_43 = &g_42;
static struct S0 g_44 = {5,0x0.B6F85Ap+11};
static uint16_t g_54 = 65535U;
static uint32_t g_66 = 4294967291U;
static int32_t g_75 = 0xCCEA59F7;
static struct S0 g_92 = {-6,0x2.EB7F04p-36};
static struct S0 *g_91 = &g_92;
static uint16_t *g_99 = &g_54;
static uint16_t **g_98 = &g_99;
static uint32_t *g_148 = &g_66;
static uint32_t **g_147 = &g_148;
static int32_t **g_154 = &g_43;
static int32_t ***g_153 = &g_154;
static struct S0 **g_158 = (void*)0;
static int16_t g_169 = (-3);
static struct S0 g_186 = {0x22DB6E2B,0xD.1B4A57p+87};
static float *g_244 = &g_92.f1;
static float **g_243 = &g_244;
static int8_t g_375 = 0;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static float  func_2(struct S0  p_3);
static int32_t  func_11(uint32_t  p_12, float  p_13);
static float  func_15(uint32_t  p_16, int8_t  p_17, struct S0  p_18, float  p_19);
static int8_t  func_20(float  p_21, int32_t  p_22, int16_t  p_23);
static float  func_26(struct S0  p_27, int8_t  p_28, uint16_t  p_29, int16_t  p_30, int16_t  p_31);
static struct S0  func_32(uint32_t  p_33, int8_t  p_34, int8_t  p_35, int32_t  p_36, int16_t  p_37);
static uint16_t ** func_46(uint32_t  p_47, uint16_t * p_48, int32_t * p_49, uint16_t ** p_50, int32_t * p_51);
static uint16_t ** func_56(int32_t  p_57, uint32_t  p_58, uint16_t * p_59);
static int32_t  func_62(uint16_t * p_63, uint32_t  p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_44 g_66 g_43 g_75 g_91 g_92.f0 g_54 g_98 g_99 g_147 g_154 g_153 g_186 g_42 g_92 g_148 g_169 g_243 g_375 g_244
 * writes: g_43 g_66 g_44.f0 g_42 g_75 g_91 g_92.f1 g_54 g_92.f0 g_92 g_153 g_158 g_169 g_98 g_147 g_44.f1 g_186.f0
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    struct S0 l_4 = {0x3152C58F,-0x7.0p-1};
    (*g_244) = func_2(l_4);
    /* statement id: 183 */
    assert (g_43 == &g_42 || g_43 == &g_92.f1);
    //assert (g_153 == &g_154 || g_153 == dangling);
    assert (g_158 == 0 || g_158 == &g_91);
    return l_4.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_44 g_66 g_43 g_75 g_91 g_92.f0 g_54 g_98 g_99 g_147 g_154 g_153 g_186 g_42 g_92 g_148 g_169 g_243 g_375 g_244
 * writes: g_43 g_66 g_44.f0 g_42 g_75 g_91 g_92.f1 g_54 g_92.f0 g_92 g_153 g_158 g_169 g_98 g_147 g_44.f1 g_186.f0
 */
static float  func_2(struct S0  p_3)
{ /* block id: 1 */
    float l_7 = 0xC.3E86F8p-70;
    int16_t l_14 = (-9);
    int32_t l_38 = 5;
    uint16_t l_39 = 65528U;
    uint16_t *l_40 = &l_39;
    uint32_t l_190 = 4294967287U;
    int32_t *l_191 = &g_42;
    float ***l_314 = &g_243;
    float ***l_317 = &g_243;
    uint32_t l_325 = 0x772FEA18;
    int32_t l_359 = 0;
    float **l_367 = &g_244;
    uint32_t ***l_376 = &g_147;
    uint32_t ***l_377 = &g_147;
    int8_t l_384 = (-4);
    uint16_t l_385 = 0xD262;
    int32_t *l_386 = &g_75;
    if ((safe_mul_func_uint16_t_u_u(g_8, ((safe_div_func_uint32_t_u_u(0x8D19C921, (g_8 || (p_3.f0 = ((*l_191) = (l_190 = func_11(l_14, func_15(l_14, func_20(((safe_div_func_float_f_f(p_3.f1, (func_26(func_32(((l_38 = ((-1) > (-6))) && (((*l_40) = l_39) | l_38)), l_14, l_14, p_3.f0, l_14), l_14, p_3.f0, p_3.f0, g_8) > 0x7.84CBF7p-2))) == g_8), g_44.f0, p_3.f0), g_186, l_14)))))))) != 0x35D5))))
    { /* block id: 90 */
        int32_t *l_192 = &l_38;
        float *l_193 = &g_92.f1;
        uint16_t ***l_213 = &g_98;
        uint16_t ****l_212 = &l_213;
        int32_t l_229 = 0xF838165E;
        (*g_154) = (*g_154);
        g_44.f1 = ((-0x8.5p-1) == ((l_192 != (void*)0) != ((*l_193) = ((void*)0 == &l_38))));
        (*g_154) = l_193;
        /* statement id: 94 */
        assert (g_43 == &g_92.f1);
        for (p_3.f0 = 0; (p_3.f0 != (-19)); p_3.f0 = safe_sub_func_int16_t_s_s(p_3.f0, 1))
        { /* block id: 97 */
            int16_t l_214 = 0x7C72;
            float *l_226 = (void*)0;
            float *l_228 = &l_7;
            int32_t l_253 = (-3);
            int32_t l_254 = 3;
            uint16_t l_280 = 9U;
            int8_t l_302 = 0xE2;
            float ****l_315 = (void*)0;
            float ****l_316 = &l_314;
            for (l_38 = 0; (l_38 != 17); l_38 = safe_add_func_uint32_t_u_u(l_38, 1))
            { /* block id: 100 */
                int8_t l_222 = 0xEE;
                float *l_223 = &l_7;
                float **l_227 = &l_226;
                uint32_t l_236 = 0x87C9332B;
                int16_t *l_242 = &l_214;
                float ***l_245 = (void*)0;
                float ***l_246 = &l_227;
                float l_295 = 0x3.BFE8D4p-66;
            }
            (*g_91) = (*g_91);
            (*g_43) = ((safe_mod_func_uint16_t_u_u(((safe_div_func_uint32_t_u_u(((0xDC01 <= (((*g_99) = l_302) == (!(safe_lshift_func_int16_t_s_u((*l_192), ((*g_43) ^ ((safe_sub_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_u(0xD156, (safe_mod_func_uint16_t_u_u(((((l_254 = ((safe_lshift_func_uint16_t_u_u((((*l_316) = l_314) != l_317), l_280)) == (-1))) < 65534U) < p_3.f0) | g_92.f0), g_186.f0)))) & (**g_154)), (**g_154))) ^ p_3.f0))))))) & p_3.f0), (*g_148))) >= p_3.f0), (*l_191))) & p_3.f0);
            if ((*l_192))
                break;
        }
    }
    else
    { /* block id: 154 */
        return p_3.f1;
    }
    /* facts after branching */
    assert (g_43 == &g_92.f1);
    //assert (g_153 == &g_154 || g_153 == dangling);
    assert (g_158 == 0 || g_158 == &g_91);
    for (g_186.f0 = 14; (g_186.f0 <= (-20)); g_186.f0 = safe_sub_func_uint32_t_u_u(g_186.f0, 7))
    { /* block id: 159 */
        float l_361 = 0x3.402E81p+84;
        int32_t l_374 = 1;
        for (g_75 = (-11); (g_75 <= (-12)); g_75 = safe_sub_func_int16_t_s_s(g_75, 9))
        { /* block id: 162 */
            uint32_t l_322 = 0xD1AC8189;
            uint32_t *l_326 = &l_190;
            uint32_t **l_327 = &l_326;
            uint32_t *l_329 = &g_66;
            uint32_t **l_328 = &l_329;
            int16_t *l_360 = (void*)0;
            int16_t *l_362 = &l_14;
            float ***l_368 = &l_367;
            int16_t **l_373 = (void*)0;
            (*g_43) = ((l_322 > (*l_191)) <= (safe_lshift_func_uint16_t_u_s((l_325 > (*l_191)), ((*g_147) != ((*l_328) = ((*l_327) = l_326))))));
            /* statement id: 165 */
            assert (l_329 == &l_190);
            (*g_43) = (safe_sub_func_int16_t_s_s(((*l_362) = ((safe_mul_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((safe_sub_func_int16_t_s_s(0xFF77, (safe_div_func_int16_t_s_s(((*l_191) = (((safe_rshift_func_uint16_t_u_u((safe_div_func_int32_t_s_s(1, (0U | (p_3.f0 || 0)))), 10)) ^ (~((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s((safe_mul_func_int16_t_s_s((((safe_mul_func_uint16_t_u_u((0xB4AF432E < (safe_mul_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((0xD93B319A < (g_92.f0 & (((void*)0 != &g_99) <= 1U))), l_322)), p_3.f0))), p_3.f0)) != 4294967295U) < l_359), p_3.f0)), (*g_148))), 0)) > 8U))) != (**g_98))), p_3.f0)))), g_44.f0)), g_169)) & 0x80EF6ECB)), p_3.f0));
            (*l_191) = ((safe_mul_func_uint16_t_u_u((**g_98), g_186.f0)) == (((safe_sub_func_uint32_t_u_u(((*l_314) != ((*l_368) = l_367)), ((g_54 == ((((*l_362) = (g_169 = (((safe_add_func_uint32_t_u_u(((((safe_mul_func_int16_t_s_s(((((l_360 = &g_169) == (void*)0) & l_374) < ((*g_43) = ((**g_98) > g_42))), g_375)) != g_169) >= 0x5372) == (*l_191)), p_3.f0)) != p_3.f0) >= p_3.f0))) && 0x730A) & 65533U)) == (*l_191)))) & p_3.f0) >= (*l_191)));
            /* statement id: 174 */
            assert (l_360 == &g_169);
        }
    }
    l_376 = (l_377 = l_376);
    (*l_386) = (g_375 == (p_3.f0 || ((safe_mul_func_int16_t_s_s(((((((((*l_191) = (((void*)0 != (**l_314)) != (safe_sub_func_int16_t_s_s((((**g_154) = ((safe_add_func_uint32_t_u_u(p_3.f0, (0x22CA6194 ^ (**g_154)))) == ((((*l_191) < (0xDAB3 < p_3.f0)) == p_3.f0) < (*l_191)))) >= l_384), g_66)))) >= (**g_147)) | l_385) || (**g_154)) | g_44.f0) >= 0x73E2F334) >= l_325), g_92.f0)) > 4294967295U)));
    return (**g_243);
}


/* ------------------------------------------ */
/* 
 * reads : g_43
 * writes: g_147 g_42
 */
static int32_t  func_11(uint32_t  p_12, float  p_13)
{ /* block id: 83 */
    uint32_t **l_188 = (void*)0;
    uint32_t ***l_189 = &g_147;
    (*g_43) = (!(l_188 != ((*l_189) = &g_148)));
    return p_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_43 g_42
 * writes: g_42
 */
static float  func_15(uint32_t  p_16, int8_t  p_17, struct S0  p_18, float  p_19)
{ /* block id: 80 */
    (*g_43) = (*g_43);
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads : g_44.f0 g_66 g_43 g_75 g_91 g_92.f0 g_54 g_8 g_98 g_99 g_147 g_154 g_153
 * writes: g_66 g_44.f0 g_43 g_42 g_75 g_91 g_92.f1 g_54 g_92.f0 g_92 g_153 g_158 g_169 g_98
 */
static int8_t  func_20(float  p_21, int32_t  p_22, int16_t  p_23)
{ /* block id: 10 */
    uint32_t l_52 = 1U;
    uint16_t *l_53 = &g_54;
    int32_t *l_55 = &g_44.f0;
    uint32_t *l_65 = &g_66;
    struct S0 **l_93 = &g_91;
    int32_t l_94 = (-1);
    uint16_t ***l_180 = &g_98;
    (*l_180) = func_46(l_52, l_53, l_55, func_56((p_23 && (func_62(l_53, ((*l_55) = ((*l_65) = g_44.f0))) != ((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s((((((safe_add_func_int32_t_s_s((((safe_mul_func_uint16_t_u_u((~(((*l_93) = g_91) == &g_92)), 0xAC96)) < l_94) <= 0xEC16), g_92.f0)) >= p_22) != g_54) & 1U) >= 0xD44E), g_92.f0)), 15)), 0xDC67)) > g_8))), g_54, l_53), l_55);
    /* statement id: 70 */
    //assert (g_153 == &g_154 || g_153 == dangling);
    assert (g_158 == 0 || g_158 == &g_91);
    for (g_54 = 14; (g_54 <= 20); g_54 = safe_add_func_int16_t_s_s(g_54, 1))
    { /* block id: 73 */
        int32_t *l_183 = (void*)0;
        l_183 = &p_22;
        /* statement id: 74 */
        assert (l_183 == &p_22);
        if (p_23)
            continue;
        l_55 = l_183;
        /* statement id: 76 */
        assert (l_55 == &p_22);
    }
    /* facts after for loop */
    assert (l_55 == &p_22 || l_55 == &g_44.f0);
    (*g_43) = (safe_sub_func_uint16_t_u_u((**g_98), ((void*)0 == g_43)));
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_8
 * writes:
 */
static float  func_26(struct S0  p_27, int8_t  p_28, uint16_t  p_29, int16_t  p_30, int16_t  p_31)
{ /* block id: 7 */
    int8_t l_45 = (-1);
    p_27.f0 = l_45;
    return g_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_44
 * writes: g_43
 */
static struct S0  func_32(uint32_t  p_33, int8_t  p_34, int8_t  p_35, int32_t  p_36, int16_t  p_37)
{ /* block id: 4 */
    int32_t *l_41 = &g_42;
    g_43 = l_41;
    return g_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_44.f0 g_43 g_98 g_99 g_54 g_75 g_8 g_92.f0 g_147 g_91 g_154 g_153
 * writes: g_42 g_54 g_44.f0 g_92.f0 g_92.f1 g_92 g_153 g_158 g_169 g_98 g_43
 */
static uint16_t ** func_46(uint32_t  p_47, uint16_t * p_48, int32_t * p_49, uint16_t ** p_50, int32_t * p_51)
{ /* block id: 33 */
    int32_t *l_108 = &g_42;
    int32_t *l_109 = &g_44.f0;
    int32_t l_113 = 1;
    uint16_t l_114 = 0xE450;
    int32_t *l_115 = (void*)0;
    int32_t *l_116 = &g_92.f0;
    int32_t **l_142 = &l_109;
    struct S0 l_150 = {0xC85B7F5D,0x6.CDD4D0p-78};
    uint16_t l_172 = 1U;
    uint16_t ***l_175 = &g_98;
    (*l_116) = (((safe_mod_func_int32_t_s_s((((*p_51) = (safe_div_func_int32_t_s_s(((*g_43) = (((void*)0 != p_49) < (safe_mul_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(((l_108 = p_49) == l_109), (0xF8785D54 ^ (~g_66)))), (*l_109))))), (1U || (((safe_lshift_func_uint16_t_u_s((((*p_48) = (**g_98)) ^ 0xD00D), (*l_109))) && (*l_109)) >= (*l_109)))))) == g_75), l_113)) && l_114) < g_8);
    /* statement id: 38 */
    assert (l_108 == &g_44.f0);
    if ((safe_rshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u(((*l_109) == (*l_116)), (safe_div_func_uint32_t_u_u((safe_unary_minus_func_uint16_t_u((*p_48))), 8)))), 1)))
    { /* block id: 39 */
        uint16_t *l_127 = &g_54;
        uint16_t **l_126 = &l_127;
        uint32_t *l_130 = &g_66;
        uint32_t *l_132 = &g_66;
        uint32_t **l_131 = &l_132;
        uint32_t l_133 = 4294967291U;
        uint16_t *l_135 = &g_54;
        int32_t **l_141 = &l_108;
        int32_t ***l_140 = &l_141;
        float *l_143 = &g_92.f1;
        (*l_109) = ((((*l_143) = (safe_add_func_float_f_f(((*g_98) != ((*l_126) = (*p_50))), (safe_div_func_float_f_f((l_130 == ((*l_131) = &g_66)), (l_133 >= (-((((*p_50) != l_135) < p_47) == (safe_sub_func_float_f_f((safe_mul_func_float_f_f(((l_142 = ((*l_140) = &g_43)) != &l_116), p_47)), 0xF.790E36p+37)))))))))) >= g_75) <= 0x1.82584Fp-7);
        /* statement id: 45 */
        assert (l_141 == &g_43);
        assert (l_142 == &g_43);
    }
    else
    { /* block id: 46 */
        uint16_t l_146 = 0xB192;
        uint32_t **l_149 = (void*)0;
        int32_t *l_159 = &l_113;
        uint16_t ***l_176 = &g_98;
        if ((l_146 <= ((l_149 = g_147) == &g_148)))
        { /* block id: 48 */
            int32_t ***l_152 = &l_142;
            int32_t ***l_156 = &g_154;
            int32_t ****l_155 = &l_156;
            (*g_91) = l_150;
            if ((!((g_153 = l_152) == ((*l_155) = &g_154))))
            { /* block id: 52 */
                struct S0 **l_157 = &g_91;
                int16_t *l_168 = &g_169;
                uint16_t ***l_173 = (void*)0;
                uint16_t ***l_174 = &g_98;
                g_158 = l_157;
                /* statement id: 53 */
                assert (g_158 == &g_91);
                (*l_142) = l_159;
                /* statement id: 54 */
                assert (l_109 == &l_113);
                (*l_174) = func_56((*p_49), (safe_div_func_int16_t_s_s(((-1) == (safe_mod_func_uint16_t_u_u((safe_mul_func_int16_t_s_s(((safe_sub_func_uint32_t_u_u((((0xFAEA && 1U) & 1) <= ((*l_168) = p_47)), ((*l_159) < (safe_mul_func_int16_t_s_s(g_75, (((****l_155) = (p_47 <= 0x2CC9)) || 4294967295U)))))) == l_172), p_47)), g_54))), 0x72B5)), (*g_98));
            }
            else
            { /* block id: 58 */
                return &g_99;
                /* statement id: 59 */
                //assert (g_153 == dangling);
                //assert (func_46_rv == &g_99);
            }
            /* facts after branching */
            assert (l_109 == &l_113);
            assert (g_153 == &l_142);
            assert (g_158 == &g_91);
        }
        else
        { /* block id: 61 */
            uint16_t ****l_177 = &l_175;
            (*l_177) = (l_176 = l_175);
        }
        /* facts after branching */
        assert (l_109 == &g_44.f0 || l_109 == &l_113);
        assert (l_149 == &g_148);
        assert (g_153 == &g_154 || g_153 == &l_142);
        assert (g_158 == 0 || g_158 == &g_91);
        (**g_153) = (*g_154);
        /* statement id: 65 */
        assert (l_109 == &g_42 || l_109 == &g_44.f0 || l_109 == &l_113);
        (*l_116) = (safe_rshift_func_int16_t_s_s(p_47, 0));
    }
    /* facts after branching */
    assert (l_109 == &g_42 || l_109 == &g_44.f0 || l_109 == &l_113);
    assert (l_142 == &l_109 || l_142 == &g_43);
    assert (g_153 == &g_154 || g_153 == &l_142);
    assert (g_158 == 0 || g_158 == &g_91);
    (**l_142) = (&l_142 != &l_142);
    return &g_99;
    /* statement id: 69 */
    //assert (g_153 == &g_154 || g_153 == dangling);
    //assert (func_46_rv == &g_99);
}


/* ------------------------------------------ */
/* 
 * reads : g_44.f0 g_98
 * writes: g_92.f1
 */
static uint16_t ** func_56(int32_t  p_57, uint32_t  p_58, uint16_t * p_59)
{ /* block id: 29 */
    int32_t *l_95 = &g_44.f0;
    int32_t **l_96 = (void*)0;
    int32_t **l_97 = &l_95;
    (*l_97) = l_95;
    g_92.f1 = g_44.f0;
    return g_98;
    /* statement id: 32 */
    //assert (func_56_rv == &g_99);
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_44.f0 g_43 g_75
 * writes: g_66 g_43 g_44.f0 g_42 g_75
 */
static int32_t  func_62(uint16_t * p_63, uint32_t  p_64)
{ /* block id: 13 */
    struct S0 l_76 = {0x2DA0D3D7,0xD.A349A2p-83};
    int32_t *l_78 = &g_75;
    int32_t **l_79 = &l_78;
    for (g_66 = 25; (g_66 >= 50); g_66 = safe_add_func_uint32_t_u_u(g_66, 4))
    { /* block id: 16 */
        int32_t **l_69 = &g_43;
        (*l_69) = &g_42;
    }
    for (g_44.f0 = 0; (g_44.f0 <= 21); g_44.f0 = safe_add_func_int32_t_s_s(g_44.f0, 1))
    { /* block id: 21 */
        float l_72 = 0x6.E4674Ep+30;
        int32_t *l_73 = (void*)0;
        int32_t *l_74 = &g_75;
        struct S0 *l_77 = &l_76;
        (*l_74) = ((*g_43) = p_64);
        (*l_77) = l_76;
    }
    (*l_79) = l_78;
    return (**l_79);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_44.f0, "g_44.f0", print_hash_value);
    transparent_crc_bytes (&g_44.f1, sizeof(g_44.f1), "g_44.f1", print_hash_value);
    transparent_crc(g_54, "g_54", print_hash_value);
    transparent_crc(g_66, "g_66", print_hash_value);
    transparent_crc(g_75, "g_75", print_hash_value);
    transparent_crc(g_92.f0, "g_92.f0", print_hash_value);
    transparent_crc_bytes (&g_92.f1, sizeof(g_92.f1), "g_92.f1", print_hash_value);
    transparent_crc(g_169, "g_169", print_hash_value);
    transparent_crc(g_186.f0, "g_186.f0", print_hash_value);
    transparent_crc_bytes (&g_186.f1, sizeof(g_186.f1), "g_186.f1", print_hash_value);
    transparent_crc(g_375, "g_375", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 71
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 29, occurrence: 2
   depth: 35, occurrence: 1

XXX total number of pointers: 93

XXX times a variable address is taken: 91
XXX times a pointer is dereferenced on RHS: 53
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 13
XXX times a pointer is dereferenced on LHS: 75
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 237

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 151
   level: 2, occurrence: 42
   level: 3, occurrence: 3
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 48
XXX number of pointers point to scalars: 43
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 14
XXX average alias set size: 1.16

XXX times a non-volatile is read: 329
XXX times a non-volatile is write: 199
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 60
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 16
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4

XXX percentage a fresh-made variable is used: 21.2
XXX percentage an existing variable is used: 78.8
********************* end of statistics **********************/

