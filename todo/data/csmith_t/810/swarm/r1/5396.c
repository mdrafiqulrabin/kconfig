/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --no-bitfields --no-comma-operators --compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1713883080
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int64_t g_17 = (-1L);
static int32_t g_50 = 0xFA6F63EEL;
static uint32_t g_56 = 0x6ADD33D7L;
static uint64_t g_58 = 0UL;
static uint32_t g_73 = 18446744073709551611UL;
static int32_t g_96 = 0x06EE4F12L;
static int32_t *g_109 = (void*)0;
static int32_t ** volatile g_108 = &g_109;/* VOLATILE GLOBAL g_108 */
static volatile struct S0 g_110 = {1L};/* VOLATILE GLOBAL g_110 */
static uint32_t **g_120 = (void*)0;
static uint16_t g_155 = 65529UL;
static struct S0 g_166[6][8][5] = {{{{2L},{0x4D7A56A24BEC2C41LL},{0x0101A31BCC97913BLL},{0x3E89965A7D269447LL},{0x3F4F6D35079E5195LL}},{{0x98E80C9BE5D540DALL},{0x903A0161F22465FALL},{0x85434852D9DEA424LL},{0L},{0x939D7BC268F25B8ALL}},{{2L},{4L},{0xD83B3E919F614CAELL},{0xD83B3E919F614CAELL},{4L}},{{0x98E80C9BE5D540DALL},{-2L},{0xC5A253C7AF3F720ALL},{5L},{0xAB9BFD8F9DC3F5DALL}},{{2L},{0x3F4F6D35079E5195LL},{0x3E89965A7D269447LL},{0x0101A31BCC97913BLL},{0x4D7A56A24BEC2C41LL}},{{0x98E80C9BE5D540DALL},{-1L},{0xB4B798DF4D21E74ELL},{0x84B9C5F8BC2CC7AFLL},{0xF37C5CFF5E1EA3A6LL}},{{2L},{0x336C12986392380DLL},{3L},{9L},{-2L}},{{0x98E80C9BE5D540DALL},{0xD20A931D57787EE9LL},{-8L},{1L},{0xCC1B0773BA691A81LL}}},{{{2L},{-2L},{9L},{3L},{0x336C12986392380DLL}},{{0x98E80C9BE5D540DALL},{0x070758AC69C4AB7FLL},{0xAB9BFD8F9DC3F5DALL},{-2L},{0xAC2E1585BBCD1606LL}},{{0x25B38493D40E6857LL},{0x1ABEA055E4C58097LL},{-2L},{0x336C12986392380DLL},{-10L}},{{0x7803233C0C79DF27LL},{7L},{0x5A91684916890952LL},{0xD4CE2010D2CAD3D6LL},{0x61FC436A30DA47F4LL}},{{0x25B38493D40E6857LL},{0x7CEE369ADF10BACBLL},{4L},{4L},{0x7CEE369ADF10BACBLL}},{{0x7803233C0C79DF27LL},{0x8CB307BCC87407B9LL},{0xF37C5CFF5E1EA3A6LL},{-1L},{0x50F9E0A5FCD0D6B2LL}},{{0x25B38493D40E6857LL},{-10L},{0x336C12986392380DLL},{-2L},{0x1ABEA055E4C58097LL}},{{0x7803233C0C79DF27LL},{0x74F4B611BEE515C3LL},{0x939D7BC268F25B8ALL},{0x903A0161F22465FALL},{-1L}}},{{{0x25B38493D40E6857LL},{0x0FEA248F7BE4936ELL},{0x4D7A56A24BEC2C41LL},{0x3F4F6D35079E5195LL},{0x2973F10C4547A68ELL}},{{0x7803233C0C79DF27LL},{0x3B49664FB15D4968LL},{0xCC1B0773BA691A81LL},{0xD20A931D57787EE9LL},{0x18CA032275AA4AC0LL}},{{0x25B38493D40E6857LL},{0x2973F10C4547A68ELL},{0x3F4F6D35079E5195LL},{0x4D7A56A24BEC2C41LL},{0x0FEA248F7BE4936ELL}},{{0x7803233C0C79DF27LL},{0x070758AC69C4AB7FLL},{0xAB9BFD8F9DC3F5DALL},{-2L},{0xAC2E1585BBCD1606LL}},{{0x25B38493D40E6857LL},{0x1ABEA055E4C58097LL},{-2L},{0x336C12986392380DLL},{-10L}},{{0x7803233C0C79DF27LL},{7L},{0x5A91684916890952LL},{0xD4CE2010D2CAD3D6LL},{0x61FC436A30DA47F4LL}},{{0x25B38493D40E6857LL},{0x7CEE369ADF10BACBLL},{4L},{4L},{0x7CEE369ADF10BACBLL}},{{0x7803233C0C79DF27LL},{0x8CB307BCC87407B9LL},{0xF37C5CFF5E1EA3A6LL},{-1L},{0x50F9E0A5FCD0D6B2LL}}},{{{0x25B38493D40E6857LL},{-10L},{0x336C12986392380DLL},{-2L},{0x1ABEA055E4C58097LL}},{{0x7803233C0C79DF27LL},{0x74F4B611BEE515C3LL},{0x939D7BC268F25B8ALL},{0x903A0161F22465FALL},{-1L}},{{0x25B38493D40E6857LL},{0x0FEA248F7BE4936ELL},{0x4D7A56A24BEC2C41LL},{0x3F4F6D35079E5195LL},{0x2973F10C4547A68ELL}},{{0x7803233C0C79DF27LL},{0x3B49664FB15D4968LL},{0xCC1B0773BA691A81LL},{0xD20A931D57787EE9LL},{0x18CA032275AA4AC0LL}},{{0x25B38493D40E6857LL},{0x2973F10C4547A68ELL},{0x3F4F6D35079E5195LL},{0x4D7A56A24BEC2C41LL},{0x0FEA248F7BE4936ELL}},{{0x7803233C0C79DF27LL},{0x070758AC69C4AB7FLL},{0xAB9BFD8F9DC3F5DALL},{-2L},{0xAC2E1585BBCD1606LL}},{{0x25B38493D40E6857LL},{0x1ABEA055E4C58097LL},{-2L},{0x336C12986392380DLL},{-10L}},{{0x7803233C0C79DF27LL},{7L},{0x5A91684916890952LL},{0xD4CE2010D2CAD3D6LL},{0x61FC436A30DA47F4LL}}},{{{0x25B38493D40E6857LL},{0x7CEE369ADF10BACBLL},{4L},{4L},{0x7CEE369ADF10BACBLL}},{{0x7803233C0C79DF27LL},{0x8CB307BCC87407B9LL},{0xF37C5CFF5E1EA3A6LL},{-1L},{0x50F9E0A5FCD0D6B2LL}},{{0x25B38493D40E6857LL},{-10L},{0x336C12986392380DLL},{-2L},{0x1ABEA055E4C58097LL}},{{0x7803233C0C79DF27LL},{0x74F4B611BEE515C3LL},{0x939D7BC268F25B8ALL},{0x903A0161F22465FALL},{-1L}},{{0x25B38493D40E6857LL},{0x0FEA248F7BE4936ELL},{0x4D7A56A24BEC2C41LL},{0x3F4F6D35079E5195LL},{0x2973F10C4547A68ELL}},{{0x7803233C0C79DF27LL},{0x3B49664FB15D4968LL},{0xCC1B0773BA691A81LL},{0xD20A931D57787EE9LL},{0x18CA032275AA4AC0LL}},{{0x25B38493D40E6857LL},{0x2973F10C4547A68ELL},{0x3F4F6D35079E5195LL},{0x4D7A56A24BEC2C41LL},{0x0FEA248F7BE4936ELL}},{{0x7803233C0C79DF27LL},{0x070758AC69C4AB7FLL},{0xAB9BFD8F9DC3F5DALL},{-2L},{0xAC2E1585BBCD1606LL}}},{{{0x25B38493D40E6857LL},{0x1ABEA055E4C58097LL},{-2L},{0x336C12986392380DLL},{-10L}},{{0x7803233C0C79DF27LL},{7L},{0x5A91684916890952LL},{0xD4CE2010D2CAD3D6LL},{0x61FC436A30DA47F4LL}},{{0x25B38493D40E6857LL},{0x7CEE369ADF10BACBLL},{4L},{4L},{0x7CEE369ADF10BACBLL}},{{0x7803233C0C79DF27LL},{0x8CB307BCC87407B9LL},{0xF37C5CFF5E1EA3A6LL},{-1L},{0x50F9E0A5FCD0D6B2LL}},{{0x25B38493D40E6857LL},{-10L},{0x336C12986392380DLL},{-2L},{0x1ABEA055E4C58097LL}},{{0x7803233C0C79DF27LL},{0x74F4B611BEE515C3LL},{0x939D7BC268F25B8ALL},{0x903A0161F22465FALL},{-1L}},{{0x25B38493D40E6857LL},{0x0FEA248F7BE4936ELL},{0x4D7A56A24BEC2C41LL},{0x3F4F6D35079E5195LL},{0x2973F10C4547A68ELL}},{{0x7803233C0C79DF27LL},{0x3B49664FB15D4968LL},{0x18CA032275AA4AC0LL},{0x3B49664FB15D4968LL},{0x98E80C9BE5D540DALL}}}};
static struct S0 * volatile g_165[7] = {&g_166[2][2][1],&g_166[2][5][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[2][5][1],&g_166[2][2][1],&g_166[2][2][1]};
static int32_t g_198 = 0x9779F3C6L;
static int32_t g_217 = (-1L);
static int32_t * volatile g_216 = &g_217;/* VOLATILE GLOBAL g_216 */
static struct S0 *g_220 = &g_166[1][6][3];
static struct S0 ** volatile g_219 = &g_220;/* VOLATILE GLOBAL g_219 */
static int32_t ** volatile g_222 = &g_109;/* VOLATILE GLOBAL g_222 */
static int32_t * volatile g_225 = (void*)0;/* VOLATILE GLOBAL g_225 */
static const uint64_t g_231 = 0xDB34CF7A4B4D117CLL;
static uint32_t g_240 = 0x70606D16L;
static uint32_t ** volatile *g_260 = (void*)0;
static uint32_t ** volatile **g_259 = &g_260;
static int16_t g_283 = (-1L);
static int16_t *g_282[2] = {&g_283,&g_283};
static int16_t *g_285 = (void*)0;
static uint8_t g_296 = 0x02L;
static volatile int8_t g_305 = 5L;/* VOLATILE GLOBAL g_305 */
static volatile uint64_t g_306 = 0UL;/* VOLATILE GLOBAL g_306 */
static int32_t ** volatile g_311[6] = {&g_109,&g_109,&g_109,&g_109,&g_109,&g_109};
static int32_t ** volatile g_312 = &g_109;/* VOLATILE GLOBAL g_312 */
static uint64_t *g_333[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static uint64_t **g_332 = &g_333[1];
static uint64_t *g_343 = &g_58;
static int32_t g_359 = 5L;
static int32_t * volatile *g_362 = &g_225;
static int32_t * volatile ** volatile g_361 = &g_362;/* VOLATILE GLOBAL g_361 */
static struct S0 **g_382 = &g_220;
static struct S0 ***g_381 = &g_382;
static uint16_t g_404 = 1UL;
static struct S0 * volatile g_411 = &g_166[5][3][3];/* VOLATILE GLOBAL g_411 */
static int32_t * volatile g_438[1] = {(void*)0};
static uint32_t *g_486 = &g_56;
static volatile uint16_t * volatile * volatile g_521 = (void*)0;/* VOLATILE GLOBAL g_521 */
static volatile uint16_t * volatile * volatile * volatile g_522 = &g_521;/* VOLATILE GLOBAL g_522 */
static const uint64_t g_545 = 2UL;
static uint32_t g_610 = 0x38610210L;
static int32_t g_648 = 1L;
static uint64_t * volatile **g_689 = (void*)0;
static uint64_t * volatile ***g_688[6] = {(void*)0,(void*)0,&g_689,(void*)0,(void*)0,&g_689};
static int8_t g_700 = 0x80L;
static int32_t *g_701 = &g_217;


/* --- FORWARD DECLARATIONS --- */
inline static const struct S0  func_32(void);
static int32_t  func_40(uint16_t  p_41, int64_t  p_42);
static int32_t  func_45(uint16_t  p_46, uint32_t  p_47, const int32_t  p_48, int64_t  p_49);
inline static int32_t * func_61(uint32_t * p_62, uint32_t  p_63);
static uint32_t  func_64(uint64_t * p_65, const uint64_t * p_66);
static uint64_t * func_68(int64_t  p_69, int64_t  p_70, int32_t * p_71);
static int32_t * func_75(int32_t  p_76, int32_t * p_77, struct S0  p_78);
static uint16_t  func_82(int64_t  p_83, const uint16_t  p_84);
static uint16_t  func_88(int32_t  p_89, uint16_t  p_90, uint32_t * p_91);
inline static uint32_t ** func_98(int64_t  p_99, uint32_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_17 g_222 g_109 g_312 g_50 g_688 g_486 g_56 g_610 g_700 g_96 g_108 g_362 g_382 g_220 g_166
 * writes: g_17 g_109 g_50 g_56 g_610 g_701 g_225
 */
inline static const struct S0  func_32(void)
{ /* block id: 36 */
    int16_t l_44 = 0x900BL;
    struct S0 l_613 = {0x0A0AC91A798A2101LL};
    int32_t l_620 = 0L;
    int32_t l_621 = 8L;
    int32_t l_622[3][10] = {{(-4L),(-4L),1L,(-4L),(-4L),1L,(-4L),(-4L),1L,(-4L)},{(-4L),0xA1487E6DL,0xA1487E6DL,(-4L),0xA1487E6DL,0xA1487E6DL,(-4L),0xA1487E6DL,0xA1487E6DL,(-4L)},{0xA1487E6DL,(-4L),0xA1487E6DL,0xA1487E6DL,(-4L),0xA1487E6DL,0xA1487E6DL,(-4L),0xA1487E6DL,0xA1487E6DL}};
    const uint32_t l_634[8] = {6UL,6UL,6UL,6UL,6UL,6UL,6UL,6UL};
    int32_t l_637 = 0x703D3739L;
    uint32_t *l_650[8][4][8] = {{{&g_56,&g_240,&g_56,&g_56,&g_240,&g_240,&g_56,(void*)0},{&g_610,&g_610,&g_56,&g_56,&g_56,&g_56,&g_56,&g_56},{&g_610,&g_56,&g_56,&g_610,&g_610,&g_56,&g_56,&g_610},{(void*)0,&g_240,(void*)0,(void*)0,&g_56,(void*)0,&g_56,&g_56}},{{&g_56,&g_240,&g_240,&g_240,&g_610,&g_56,&g_240,&g_240},{&g_610,&g_56,&g_240,&g_240,(void*)0,&g_56,(void*)0,&g_610},{&g_56,&g_610,&g_240,&g_56,&g_240,&g_240,&g_56,&g_56},{&g_610,&g_240,&g_56,&g_56,&g_610,&g_610,&g_240,&g_610}},{{&g_610,&g_610,&g_240,&g_610,&g_610,&g_56,(void*)0,&g_56},{(void*)0,&g_56,&g_240,&g_610,&g_56,&g_610,&g_56,&g_610},{(void*)0,&g_610,&g_240,&g_56,&g_610,(void*)0,(void*)0,(void*)0},{&g_56,&g_240,&g_240,&g_56,&g_610,&g_240,&g_240,&g_240}},{{&g_610,&g_240,&g_56,&g_240,&g_240,&g_240,&g_56,&g_610},{&g_240,&g_240,&g_240,&g_610,&g_240,&g_56,(void*)0,(void*)0},{&g_610,&g_240,&g_240,&g_240,&g_240,&g_610,&g_240,&g_56},{&g_610,&g_56,&g_610,&g_56,&g_240,&g_240,&g_240,&g_56}},{{&g_240,&g_240,&g_56,&g_56,&g_610,(void*)0,(void*)0,&g_56},{&g_56,&g_610,&g_610,(void*)0,&g_610,&g_240,&g_56,&g_56},{&g_56,&g_56,&g_610,&g_56,&g_56,(void*)0,&g_56,(void*)0},{&g_610,&g_240,&g_56,&g_610,&g_240,&g_240,&g_610,&g_610}},{{&g_240,&g_240,&g_56,&g_56,&g_56,&g_240,&g_240,&g_240},{(void*)0,(void*)0,&g_240,&g_240,(void*)0,&g_56,&g_610,(void*)0},{&g_56,&g_56,&g_56,&g_240,(void*)0,&g_56,&g_240,&g_56},{(void*)0,&g_56,&g_240,(void*)0,&g_56,&g_56,(void*)0,&g_56}},{{&g_240,(void*)0,&g_240,&g_56,&g_240,&g_240,&g_56,&g_56},{&g_610,(void*)0,&g_240,(void*)0,&g_56,&g_56,&g_240,&g_610},{&g_56,&g_56,&g_610,&g_610,&g_610,&g_610,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_240,&g_610,(void*)0,&g_610,&g_240}},{{&g_240,(void*)0,&g_240,&g_610,&g_240,(void*)0,&g_240,&g_240},{&g_56,&g_56,&g_240,&g_56,(void*)0,&g_610,&g_240,&g_56},{&g_240,&g_56,&g_610,&g_240,(void*)0,&g_56,(void*)0,&g_56},{&g_610,(void*)0,&g_56,&g_240,&g_56,&g_240,(void*)0,&g_240}}};
    struct S0 ****l_653 = (void*)0;
    int32_t *l_669 = &l_621;
    int i, j, k;
    for (g_17 = (-9); (g_17 < (-19)); g_17 -= 3)
    { /* block id: 39 */
        int32_t l_43 = 0L;
        int32_t *l_612 = &g_217;
        int32_t l_617 = 4L;
        int32_t l_618 = 0L;
        int32_t l_619 = 7L;
        int32_t l_623 = 0x09A01F75L;
        int32_t l_624 = 1L;
        uint32_t l_625 = 0x4DE931BBL;
        uint32_t ***l_647[10] = {&g_120,&g_120,&g_120,&g_120,&g_120,&g_120,&g_120,&g_120,&g_120,&g_120};
        int i;
    }
    (*g_312) = (*g_222);
    for (g_50 = 0; (g_50 > 1); g_50 += 4)
    { /* block id: 523 */
        uint32_t l_685 = 0x8210E466L;
        uint32_t ***l_698 = &g_120;
        uint32_t ****l_697 = &l_698;
        uint16_t l_699 = 0x152FL;
        if (((int32_t)func_82((((uint32_t)((int64_t)l_685 + (int64_t)(__builtin_ffsl(((*l_669) = 0x9ED3C136L)) | (l_685 ^ (((uint32_t)((void*)0 != g_688[3]) - (uint32_t)l_685) < (~(((g_610 |= ((*g_486) = __builtin_ctz(((*g_486) ^= ((uint16_t)((((int64_t)((int16_t)l_620 >> (int16_t)(((*l_697) = &g_120) != (void*)0)) + (int64_t)l_685) != l_699) ^ l_699) << (uint16_t)15))))) != 0xE8575505L) && l_634[3])))))) + (uint32_t)l_685) >= g_700), l_699) % (int32_t)1UL))
        { /* block id: 529 */
            g_701 = (*g_108);
            /* statement id: 530 */
            assert (g_701 == 0);
        }
        else
        { /* block id: 531 */
            (*g_362) = (*g_108);
        }
    }
    /* facts after for loop */
    assert (g_701 == &g_217 || g_701 == 0);
    return (**g_382);
}


/* ------------------------------------------ */
/* 
 * reads : g_17 g_58 g_96 g_108 g_110 g_120 g_50 g_109 g_73 g_155 g_166.f0 g_216 g_217 g_219 g_222 g_56 g_231 g_198 g_259 g_283 g_306 g_312 g_332 g_305 g_343 g_359 g_361 g_362 g_240 g_225 g_411
 * writes: g_50 g_56 g_58 g_96 g_73 g_109 g_120 g_110 g_155 g_198 g_217 g_220 g_240 g_282 g_285 g_283 g_306 g_359 g_362 g_381 g_404 g_166 g_610
 */
static int32_t  func_40(uint16_t  p_41, int64_t  p_42)
{ /* block id: 40 */
    int8_t l_53 = 1L;
    uint32_t *l_54 = (void*)0;
    uint32_t *l_55 = &g_56;
    uint64_t *l_57 = &g_58;
    g_610 = func_45(p_41, p_41, __builtin_parityll(((*l_57) ^= (((((g_17 ^ (g_50 = (-10L))) <= ((*l_55) = (g_17 == (l_53 = (((uint16_t)p_41 << (uint16_t)0) | 1UL))))) < 0x12D49381L) >= 65535UL) <= p_42))), g_17);
    /* statement id: 474 */
    assert (g_220 == 0 || (g_220 >= &g_166[0][0][0] && g_220 <= &g_166[5][7][4]));
    //assert (g_282[0] == dangling || g_282[0] == &g_283);
    //assert (g_285 == 0 || g_285 == dangling);
    assert (g_362 == &g_216 || g_362 == &g_225);
    assert (g_381 == 0 || g_381 == &g_382);
    return l_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_17 g_58 g_96 g_108 g_110 g_120 g_50 g_109 g_73 g_155 g_166.f0 g_216 g_217 g_219 g_222 g_56 g_231 g_198 g_259 g_283 g_306 g_312 g_332 g_305 g_343 g_359 g_361 g_362 g_240 g_225 g_411
 * writes: g_96 g_73 g_50 g_109 g_120 g_110 g_58 g_155 g_198 g_217 g_220 g_56 g_240 g_282 g_285 g_283 g_306 g_359 g_362 g_381 g_404 g_166
 */
static int32_t  func_45(uint16_t  p_46, uint32_t  p_47, const int32_t  p_48, int64_t  p_49)
{ /* block id: 45 */
    uint32_t l_85 = 0x18101BC6L;
    const int64_t l_223 = 1L;
    int32_t *l_394 = &g_217;
    int32_t l_405 = 0x8F1871BFL;
    int32_t l_449[10];
    struct S0 *l_499[3][4][7] = {{{&g_166[2][2][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[4][3][1],&g_166[2][2][1],&g_166[0][6][3],&g_166[3][5][1]},{&g_166[2][2][1],&g_166[4][4][1],&g_166[2][2][1],&g_166[0][6][3],(void*)0,(void*)0,(void*)0},{&g_166[2][2][1],&g_166[0][6][3],&g_166[1][2][3],&g_166[0][6][3],&g_166[2][2][1],&g_166[1][3][4],(void*)0},{&g_166[2][2][1],&g_166[2][2][1],&g_166[4][0][4],&g_166[4][3][1],&g_166[5][7][0],&g_166[2][2][1],&g_166[2][7][0]}},{{(void*)0,&g_166[2][2][1],&g_166[3][2][3],&g_166[2][2][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[5][7][0]},{&g_166[2][2][1],&g_166[4][3][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[1][2][3],(void*)0,&g_166[2][2][1]},{&g_166[2][2][1],&g_166[1][2][3],(void*)0,(void*)0,&g_166[4][3][1],&g_166[2][2][1],&g_166[5][7][0]},{&g_166[3][2][3],&g_166[2][2][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[3][5][1],&g_166[2][2][1]}},{{&g_166[1][2][3],&g_166[2][2][1],(void*)0,&g_166[2][2][1],&g_166[3][5][1],&g_166[2][2][1],&g_166[2][2][1]},{&g_166[2][2][1],&g_166[2][2][1],&g_166[2][2][1],&g_166[5][7][0],&g_166[2][2][1],&g_166[4][3][1],&g_166[2][2][1]},{(void*)0,&g_166[4][3][1],&g_166[2][2][1],&g_166[3][2][3],&g_166[2][2][1],&g_166[4][3][1],(void*)0},{&g_166[2][2][1],&g_166[4][0][4],&g_166[3][2][3],&g_166[3][5][1],&g_166[5][7][0],&g_166[2][2][1],(void*)0}}};
    const int16_t *l_511 = &g_283;
    uint32_t l_531 = 0x1382418BL;
    int16_t l_554 = 0L;
    uint64_t *l_559 = &g_58;
    int32_t l_567 = (-1L);
    int32_t l_570 = 1L;
    int32_t l_576 = 0xF0FE4A00L;
    int32_t l_577 = 0L;
    int32_t l_578 = 0xE3055846L;
    int32_t l_579 = 3L;
    int32_t l_580 = 0xC866A409L;
    int32_t l_582 = 0x4A92A7ECL;
    int32_t l_583 = 1L;
    int32_t l_587 = 0xE945587CL;
    int32_t l_590[3];
    int i, j, k;
    for (i = 0; i < 10; i++)
        l_449[i] = 0x6EA4C664L;
    for (i = 0; i < 3; i++)
        l_590[i] = 0x5419DD3FL;
    for (p_47 = (-15); (p_47 <= 40); p_47 += 5)
    { /* block id: 48 */
        uint64_t *l_67 = &g_58;
        uint32_t *l_72[9][2][1] = {{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}},{{&g_73},{&g_73}}};
        int32_t l_74 = 1L;
        int32_t l_81[2][10] = {{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)},{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)}};
        int32_t *l_94 = (void*)0;
        int32_t *l_95 = &g_96;
        int32_t l_97 = 0x7D3E67B3L;
        struct S0 l_228 = {1L};
        uint16_t *l_402 = &g_155;
        uint16_t *l_403 = &g_404;
        int i, j, k;
        l_394 = func_61(&g_56, func_64(l_67, func_68(__builtin_parityl((l_74 ^= 0xEF5D3CC1L)), g_17, func_75(((int16_t)l_81[0][6] >> (int16_t)func_82(l_85, ((((((uint16_t)func_88(((*l_95) = ((int16_t)p_46 << (int16_t)l_85)), l_97, l_94) << (uint16_t)11) ^ l_85) == g_166[2][2][1].f0) <= g_56) ^ l_223))), &l_81[0][6], l_228))));
        l_405 = (((int16_t)p_46 << (int16_t)((~((int16_t)((*l_95) = (*l_95)) % (int16_t)((*l_403) = ((*l_402) = ((uint64_t)((*l_394) ^= p_46) - (uint64_t)g_231))))) != g_17)) > p_48);
    }
    /* facts after for loop */
    assert (g_220 == 0 || (g_220 >= &g_166[0][0][0] && g_220 <= &g_166[5][7][4]));
    //assert (g_282[0] == dangling || g_282[0] == &g_283);
    //assert (g_285 == 0 || g_285 == dangling);
    assert (g_362 == &g_216 || g_362 == &g_225);
    assert (g_381 == 0 || g_381 == &g_382);
    for (g_155 = 5; (g_155 != 17); g_155 += 3)
    { /* block id: 329 */
        struct S0 l_410 = {0xC90896BF1FCE55A8LL};
        int32_t *l_421 = (void*)0;
        uint64_t *l_437 = &g_58;
        int8_t l_440[3][8][4] = {{{0x8BL,0x5AL,(-4L),(-4L)},{0x24L,0x24L,(-4L),0x21L},{0x8BL,0x1CL,(-10L),0x5AL},{(-1L),(-10L),0x21L,(-10L)},{0x21L,(-10L),(-1L),0x5AL},{(-10L),0x1CL,0x8BL,0x21L},{(-4L),0x24L,0x24L,(-4L)},{(-4L),0x5AL,0x8BL,(-6L)}},{{(-10L),(-4L),(-1L),0L},{0x21L,(-5L),0x21L,0L},{(-1L),(-4L),(-10L),(-6L)},{0x8BL,0x5AL,(-4L),(-4L)},{0x24L,0x24L,(-4L),0x21L},{0x8BL,0x1CL,(-10L),0x5AL},{(-1L),(-10L),0x21L,(-10L)},{0x21L,(-10L),(-1L),0x5AL}},{{(-10L),0x1CL,0x8BL,0x21L},{(-4L),0x24L,0x24L,(-4L)},{(-4L),0x5AL,0x8BL,(-6L)},{(-10L),(-4L),(-1L),0L},{0x21L,(-5L),0x21L,0L},{(-1L),(-4L),(-10L),(-6L)},{0x8BL,0x5AL,(-4L),(-4L)},{0x24L,0x24L,(-4L),0x21L}}};
        uint16_t l_458 = 0x78BEL;
        uint64_t l_465 = 0x6FAE6D1EB2E24CA4LL;
        uint32_t **l_502 = &g_486;
        int32_t l_565 = 0L;
        int16_t l_585[1];
        int32_t l_588 = 0L;
        int32_t l_589 = 0L;
        int32_t l_591 = 0x2D0BE024L;
        uint32_t l_592 = 0UL;
        int i, j, k;
        for (i = 0; i < 1; i++)
            l_585[i] = 0x3CF6L;
        for (p_47 = 15; (p_47 == 5); p_47 -= 1)
        { /* block id: 332 */
            uint32_t l_420 = 0x264C1F11L;
            const uint32_t *l_482 = &g_240;
            uint32_t *l_490 = &l_85;
            uint32_t l_498 = 4294967294UL;
            int32_t l_519 = 0xD41FF7B1L;
            const uint64_t *l_541 = &g_58;
            int32_t l_549[6][9] = {{0xAF320F0AL,0x7F6882E3L,0xD2DD8162L,0x9421FF47L,0x602001DAL,0x9421FF47L,0xD2DD8162L,0x7F6882E3L,0xAF320F0AL},{0x065081DBL,0x9421FF47L,0xAF320F0AL,0x602001DAL,8L,0x6AE8B2CFL,8L,0x602001DAL,0xAF320F0AL},{8L,0x8E292773L,8L,0x9421FF47L,0x6AE8B2CFL,0xD2DD8162L,(-3L),0xD2DD8162L,0x6AE8B2CFL},{8L,0x8E292773L,0x8E292773L,8L,0x9421FF47L,0x6AE8B2CFL,0xD2DD8162L,(-3L),0xD2DD8162L},{(-3L),0x065081DBL,8L,8L,0x065081DBL,(-3L),0x7F6882E3L,0x8E292773L,0xAF320F0AL},{0x633EE555L,0x6AE8B2CFL,(-3L),0x9421FF47L,0x9421FF47L,(-3L),0x6AE8B2CFL,0x633EE555L,0x065081DBL}};
            uint32_t *l_596 = &l_592;
            uint32_t l_607 = 0x9A64A1C3L;
            int i, j;
            (*g_411) = l_410;
        }
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_240 g_198 g_362 g_216 g_225
 * writes: g_240 g_198
 */
inline static int32_t * func_61(uint32_t * p_62, uint32_t  p_63)
{ /* block id: 308 */
    int32_t *l_393 = &g_217;
    for (g_240 = 26; (g_240 > 58); g_240 += 1)
    { /* block id: 311 */
        for (g_198 = (-15); (g_198 != 25); g_198 += 8)
        { /* block id: 314 */
            int32_t * volatile l_392 = &g_217;/* VOLATILE GLOBAL l_392 */
            l_392 = (*g_362);
            /* statement id: 315 */
            //assert (l_392 == &g_217 || l_392 == 0 || l_392 == &l_519);
        }
        if (p_63)
            break;
    }
    return l_393;
    /* statement id: 319 */
    //assert (func_61_rv == &g_217);
}


/* ------------------------------------------ */
/* 
 * reads : g_198 g_217 g_96 g_17 g_216 g_231 g_359 g_361 g_362 g_166.f0 g_56
 * writes: g_198 g_58 g_359 g_362 g_50 g_381 g_217 g_166.f0
 */
static uint32_t  func_64(uint64_t * p_65, const uint64_t * p_66)
{ /* block id: 282 */
    const struct S0 **l_349 = (void*)0;
    int32_t l_354 = 0xBA795881L;
    int32_t l_356 = 0x1BFF0094L;
    int32_t l_357 = 0L;
    int32_t l_365 = 0x835956C4L;
    int32_t l_367 = 0L;
    int32_t l_368[4][3];
    int64_t l_386 = 0xC6DF3298D81E27CALL;
    int16_t l_387[5][7][3] = {{{0xDBCDL,0x54DCL,0L},{0x54DCL,0xDBCDL,(-1L)},{0x2D11L,0xDBCDL,0x1CA1L},{1L,0x54DCL,0xC3DFL},{0x2D11L,0x2D11L,0xC3DFL},{0x54DCL,1L,0x1CA1L},{0xDBCDL,0x2D11L,(-1L)}},{{0xDBCDL,0x54DCL,0L},{0x54DCL,0xDBCDL,(-1L)},{0x2D11L,0xDBCDL,0x1CA1L},{1L,0x54DCL,0xC3DFL},{0x2D11L,0x2D11L,0xC3DFL},{0x54DCL,1L,0x1CA1L},{0xDBCDL,0x2D11L,(-1L)}},{{0xDBCDL,0x54DCL,0L},{0x54DCL,0xDBCDL,(-1L)},{0x2D11L,0xDBCDL,0x1CA1L},{1L,0x54DCL,0xC3DFL},{0x2D11L,0x2D11L,0xC3DFL},{0x54DCL,1L,0x1CA1L},{0xDBCDL,0x2D11L,(-1L)}},{{0xDBCDL,0x54DCL,0L},{0x54DCL,0xDBCDL,(-1L)},{0x2D11L,0xDBCDL,0x1CA1L},{1L,0x54DCL,0xC3DFL},{0x2D11L,0x2D11L,0xC3DFL},{0x54DCL,1L,0x1CA1L},{0xDBCDL,0x2D11L,(-1L)}},{{0xDBCDL,0x54DCL,0L},{0x54DCL,0xDBCDL,(-1L)},{0x2D11L,0xDBCDL,0x1CA1L},{1L,0x54DCL,0xC3DFL},{0x2D11L,0x2D11L,0xC3DFL},{0x54DCL,1L,0x1CA1L},{0xDBCDL,0x2D11L,(-1L)}}};
    int i, j, k;
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 3; j++)
            l_368[i][j] = 0xCA7BEFD9L;
    }
    for (g_198 = 1; (g_198 <= 5); g_198 += 1)
    { /* block id: 285 */
        int16_t l_348 = 0xE9F5L;
        int32_t *l_358[10] = {&l_357,&l_357,&g_217,&l_357,&l_357,&g_217,&l_357,&l_357,&g_217,&l_357};
        int32_t * volatile **l_360 = (void*)0;
        int8_t l_374[9][5] = {{(-2L),0x16L,(-3L),1L,0xC5L},{(-6L),(-3L),3L,(-3L),(-6L)},{(-9L),0x16L,(-9L),(-6L),(-10L)},{(-9L),(-10L),0xC5L,0x12L,0x12L},{(-6L),0xB1L,(-6L),0x16L,(-10L)},{(-2L),0x12L,(-10L),0x16L,(-6L)},{(-10L),0xC5L,0x12L,0x12L,0xC5L},{0xC5L,0x40L,(-10L),(-6L),(-9L)},{0xB1L,(-9L),0x12L,0xB1L,(-2L)}};
        struct S0 l_384[4][4] = {{{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL}},{{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL}},{{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL}},{{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL},{0xEFF9168DD87A80F3LL}}};
        int i, j;
        g_359 ^= (((int16_t)(((int64_t)g_217 % (int64_t)func_82(l_348, (&g_220 != l_349))) | ((uint16_t)(__builtin_ffs(l_348) <= ((*p_65) = ((uint16_t)((l_356 = (((l_354 ^= l_348) | ((~l_348) ^ (*g_216))) | 0x0EA7L)) && 0x8488L) << (uint16_t)g_231))) << (uint16_t)15)) + (int16_t)l_348) <= l_357);
        (*g_361) = &g_216;
        /* statement id: 290 */
        assert (g_362 == &g_216);
        for (g_50 = 5; (g_50 >= 0); g_50 -= 1)
        { /* block id: 293 */
            int32_t l_363 = 0xA9931376L;
            int32_t l_364 = 1L;
            int32_t l_366 = 0x61A76142L;
            int32_t l_369 = 0x8A096DBFL;
            int32_t l_370 = 1L;
            int32_t l_371 = 1L;
            int64_t l_372 = 0L;
            int32_t l_373[10][8] = {{0x89D81224L,0xE49E0866L,0x39DB502AL,0x89D81224L,0L,0x39DB502AL,0x39DB502AL,0L},{0L,0x39DB502AL,0x39DB502AL,0L,0x89D81224L,0x39DB502AL,0xE49E0866L,0x89D81224L},{0L,0xE49E0866L,0L,0L,0L,0L,0xE49E0866L,0L},{0x89D81224L,0xE49E0866L,0x39DB502AL,0x89D81224L,0L,0x39DB502AL,0x39DB502AL,0L},{0L,0x39DB502AL,0x39DB502AL,0L,0x89D81224L,0x39DB502AL,0xE49E0866L,0x89D81224L},{0L,0xE49E0866L,0L,0L,0L,0L,0xE49E0866L,0L},{0x89D81224L,0xE49E0866L,0x39DB502AL,0x89D81224L,0L,0x39DB502AL,0x39DB502AL,0L},{0L,0x39DB502AL,0x39DB502AL,0L,0x89D81224L,0x39DB502AL,0xE49E0866L,0x89D81224L},{0L,0xE49E0866L,0L,0L,0L,0L,0xE49E0866L,0L},{0x89D81224L,0xE49E0866L,0x39DB502AL,0x89D81224L,0L,0x39DB502AL,0x39DB502AL,0L}};
            int32_t l_375[7];
            uint32_t l_376 = 0UL;
            struct S0 ***l_379 = (void*)0;
            int i, j;
            for (i = 0; i < 7; i++)
                l_375[i] = 0x6655A303L;
            l_376++;
            for (l_356 = 0; (l_356 <= 5); l_356 += 1)
            { /* block id: 297 */
                struct S0 ****l_380[9];
                int32_t l_383 = 0x02D4ADF3L;
                int32_t *l_385 = &l_371;
                int i;
                for (i = 0; i < 9; i++)
                    l_380[i] = &l_379;
                g_381 = l_379;
                /* statement id: 298 */
                assert (g_381 == 0);
                l_385 = &l_367;
                /* statement id: 299 */
                assert (l_385 == &l_367);
                (**g_362) = ((*l_385) |= l_357);
            }
            l_386 = (0L ^ ((**g_362) = (func_82(l_356, g_166[2][2][1].f0) || g_56)));
        }
    }
    return l_387[1][1][1];
}


/* ------------------------------------------ */
/* 
 * reads : g_306 g_50 g_222 g_109 g_312 g_96 g_198 g_56 g_332 g_240 g_283 g_305 g_343
 * writes: g_306 g_50 g_109 g_96 g_240 g_58 g_198
 */
static uint64_t * func_68(int64_t  p_69, int64_t  p_70, int32_t * p_71)
{ /* block id: 241 */
    int32_t *l_300 = &g_198;
    int32_t *l_301 = &g_96;
    int32_t *l_302 = &g_96;
    int32_t *l_303 = &g_198;
    int32_t *l_304[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    struct S0 l_325 = {0xAA201D12309B60FBLL};
    uint64_t *l_331 = &g_58;
    uint64_t **l_330 = &l_331;
    int32_t l_342 = 0x82760A48L;
    int i;
    g_306++;
    if (p_69)
    { /* block id: 243 */
        int64_t l_313 = (-1L);
        int32_t l_316[3];
        int32_t **l_317 = &g_109;
        int i;
        for (i = 0; i < 3; i++)
            l_316[i] = (-1L);
        for (g_50 = 0; (g_50 >= (-10)); g_50 -= 1)
        { /* block id: 246 */
            (*g_312) = (*g_222);
        }
        (*l_302) |= (p_69 == l_313);
        l_316[2] &= func_82(g_198, ((int16_t)9L >> (int16_t)0));
        (*l_317) = (void*)0;
    }
    else
    { /* block id: 252 */
        uint64_t *l_320 = &g_58;
        uint64_t **l_319 = &l_320;
        uint64_t ***l_318[2];
        uint64_t ****l_321 = &l_318[0];
        uint64_t ***l_322 = &l_319;
        struct S0 l_323[10] = {{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL},{0xB714C4D434EBCE35LL}};
        int32_t *l_326 = &g_198;
        int i;
        for (i = 0; i < 2; i++)
            l_318[i] = &l_319;
        if (((p_70 == ((((*l_321) = l_318[0]) != (l_322 = l_322)) >= 0xA2A863D4604AC793LL)) < 0xCA323F51F510D637LL))
        { /* block id: 255 */
            struct S0 *l_324[4];
            int32_t **l_327 = &l_301;
            int i;
            for (i = 0; i < 4; i++)
                l_324[i] = &l_323[3];
            l_325 = l_323[9];
            p_71 = ((*l_327) = l_326);
            /* statement id: 258 */
            assert (p_71 == &g_198);
            assert (l_301 == &g_198);
        }
        else
        { /* block id: 259 */
            if ((*l_326))
            { /* block id: 260 */
                (*l_302) = (((int64_t)g_56 + (int64_t)p_69) == p_70);
                (*l_301) |= (l_330 == ((*l_322) = g_332));
                /* statement id: 263 */
                assert ((l_319 >= &g_333[0] && l_319 <= &g_333[5]));
                for (g_240 = (-29); (g_240 < 54); g_240++)
                { /* block id: 266 */
                    int32_t l_341 = 0xD1D9D8BAL;
                    for (g_58 = (-27); (g_58 < 15); g_58++)
                    { /* block id: 269 */
                        (*l_326) = func_82(((uint16_t)(!g_283) << (uint16_t)(*l_326)), g_305);
                        if (l_341)
                            continue;
                        if (l_342)
                            continue;
                        (*l_322) = (void*)0;
                        /* statement id: 273 */
                        assert (l_319 == 0);
                    }
                }
                /* facts after for loop */
                assert (l_319 == 0 || (l_319 >= &g_333[0] && l_319 <= &g_333[5]));
            }
            else
            { /* block id: 276 */
                (*l_300) = p_70;
            }
            /* facts after branching */
            assert (l_319 == &l_320 || l_319 == 0 || (l_319 >= &g_333[0] && l_319 <= &g_333[5]));
        }
        /* facts after branching */
        assert (l_301 == &g_96 || l_301 == &g_198);
        assert (l_319 == &l_320 || l_319 == 0 || (l_319 >= &g_333[0] && l_319 <= &g_333[5]));
    }
    /* facts after branching */
    assert (l_301 == &g_96 || l_301 == &g_198);
    return g_343;
    /* statement id: 281 */
    //assert (func_68_rv == &g_58);
}


/* ------------------------------------------ */
/* 
 * reads : g_73 g_231 g_58 g_96 g_222 g_198 g_217 g_216 g_259 g_56 g_166.f0 g_283 g_50 g_109
 * writes: g_73 g_56 g_240 g_58 g_109 g_155 g_217 g_282 g_285 g_283
 */
static int32_t * func_75(int32_t  p_76, int32_t * p_77, struct S0  p_78)
{ /* block id: 176 */
    int16_t l_236 = 1L;
    struct S0 **l_237[6][3] = {{&g_220,&g_220,&g_220},{&g_220,&g_220,&g_220},{&g_220,&g_220,&g_220},{&g_220,&g_220,&g_220},{&g_220,&g_220,&g_220},{&g_220,&g_220,&g_220}};
    int32_t l_256 = (-4L);
    uint32_t ***l_258 = &g_120;
    uint32_t ****l_257 = &l_258;
    int32_t *l_298 = &g_198;
    const int32_t l_299[8] = {0x697EFC4DL,0x697EFC4DL,0x697EFC4DL,0x697EFC4DL,0x697EFC4DL,0x697EFC4DL,0x697EFC4DL,0x697EFC4DL};
    int i, j;
    for (g_73 = (-5); (g_73 > 34); g_73++)
    { /* block id: 179 */
        uint32_t *l_238 = &g_56;
        uint32_t *l_239 = &g_240;
        int32_t l_247 = 2L;
        int16_t *l_281 = &l_236;
        (*p_77) |= (g_231 >= ((*l_239) = ((0L == (((uint32_t)((*l_238) = (65528UL == ((l_236 > func_82(((void*)0 == l_237[0][1]), g_58)) && g_96))) - (uint32_t)l_236) < l_236)) && 1UL)));
        if (l_236)
        { /* block id: 183 */
            uint32_t *l_241 = &g_73;
            struct S0 l_242[10] = {{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL},{0x11C2D9155A29D448LL}};
            int i;
            (*p_77) ^= (l_236 == (l_239 != l_241));
            for (g_58 = 0; (g_58 <= 6); g_58 += 1)
            { /* block id: 187 */
                int32_t l_243 = (-1L);
                int i;
                p_78 = l_242[3];
                if (l_243)
                    continue;
            }
            for (p_78.f0 = 4; (p_78.f0 > (-16)); p_78.f0 -= 1)
            { /* block id: 193 */
                uint32_t *l_246 = &g_56;
                (*p_77) |= (((l_246 = p_77) != &g_240) <= l_247);
                /* statement id: 195 */
                //assert ((l_246 >= &l_81[0][0] && l_246 <= &l_81[1][9]));
            }
        }
        else
        { /* block id: 197 */
            int32_t **l_248[6] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
            int64_t *l_251[4] = {&g_166[2][2][1].f0,&g_166[2][2][1].f0,&g_166[2][2][1].f0,&g_166[2][2][1].f0};
            uint16_t *l_252 = &g_155;
            int8_t l_254 = 1L;
            int16_t *l_255 = &l_236;
            uint16_t l_287 = 65527UL;
            uint32_t l_288 = 7UL;
            int i;
            (*g_222) = (void*)0;
            (*p_77) = (((*l_252) = ((65527UL == __builtin_ffsl(g_198)) < ((int64_t)(g_73 != (((p_78.f0 = __builtin_ffsl(p_76)) > (((*l_255) |= func_82((((*l_252) = ((l_238 = (void*)0) != &g_240)) & (((!((p_76 > l_254) && (*p_77))) <= 7L) <= 0xF895L)), p_76)) > g_217)) >= 3L)) + (int64_t)0xB8DD5268C0C089D6LL))) & l_256);
            /* statement id: 204 */
            assert (l_238 == 0);
            (*g_216) &= (*p_77);
            if ((l_257 != g_259))
            { /* block id: 206 */
                if (l_236)
                    break;
            }
            else
            { /* block id: 208 */
                int32_t *l_290 = &g_198;
                int8_t l_297 = 0xB1L;
                if (func_82((p_78.f0 = (-3L)), p_76))
                { /* block id: 210 */
                    int16_t l_286[6];
                    int32_t l_289 = (-1L);
                    int i;
                    for (i = 0; i < 6; i++)
                        l_286[i] = 0x0011L;
                    (*p_77) = (*g_216);
                    if ((*p_77))
                        continue;
                    for (l_236 = 2; (l_236 <= (-7)); l_236 -= 5)
                    { /* block id: 215 */
                        if ((*p_77))
                            break;
                    }
                    for (g_217 = 1; (g_217 <= 4); g_217 += 1)
                    { /* block id: 220 */
                        uint32_t l_276 = 6UL;
                        int16_t *l_284 = &l_236;
                        l_289 |= ((uint64_t)((int16_t)(((uint32_t)g_56 + (uint32_t)((!(g_283 |= ((uint16_t)((int32_t)(((int16_t)((*l_255) = (((l_276 && (((int32_t)((*p_77) = ((!(~((g_282[0] = l_281) != (g_285 = l_284)))) > (((p_76 || ((__builtin_ffsl(l_247) ^ (0x757702AA31F853D6LL ^ 3UL)) <= g_56)) | 0xD4EE6D12B43228F5LL) ^ p_78.f0))) % (int32_t)l_286[4]) != 0L)) < p_76) | 0xA8F70EA9L)) + (int16_t)l_287) & p_76) - (int32_t)(*g_216)) << (uint16_t)g_166[2][2][1].f0))) > (-1L))) | l_288) << (int16_t)p_76) - (uint64_t)g_50);
                    }
                    /* facts after for loop */
                    //assert (g_282[0] == &l_236 || g_282[0] == &g_283 || g_282[0] == dangling);
                    //assert (g_285 == 0 || g_285 == &l_236 || g_285 == dangling);
                }
                else
                { /* block id: 228 */
                    uint32_t l_294 = 7UL;
                    uint8_t *l_295[7][4][9] = {{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,(void*)0,&g_296,(void*)0,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,(void*)0,&g_296,&g_296,(void*)0,&g_296,(void*)0,&g_296}},{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,(void*)0,(void*)0,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,(void*)0,&g_296,&g_296,&g_296,&g_296,(void*)0,&g_296}},{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,(void*)0,(void*)0,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296}},{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{(void*)0,&g_296,&g_296,&g_296,&g_296,(void*)0,&g_296,(void*)0,&g_296}},{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{(void*)0,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,(void*)0,&g_296,(void*)0,&g_296,&g_296,&g_296,(void*)0,&g_296}},{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{(void*)0,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296}},{{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{(void*)0,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,(void*)0,&g_296},{&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296,&g_296},{&g_296,&g_296,(void*)0,(void*)0,(void*)0,&g_296,&g_296,&g_296,&g_296}}};
                    int i, j, k;
                    (*p_77) = l_247;
                    l_290 = (void*)0;
                    /* statement id: 230 */
                    assert (l_290 == 0);
                    (*g_216) ^= ((*p_77) = ((uint16_t)__builtin_ia32_crc32qi((!__builtin_ia32_crc32qi(l_294, (l_297 = p_78.f0))), p_78.f0) << (uint16_t)10));
                }
                /* facts after branching */
                //assert (g_282[0] == &l_236 || g_282[0] == &g_283 || g_282[0] == dangling);
                //assert (g_285 == 0 || g_285 == &l_236 || g_285 == dangling);
                assert (l_290 == 0 || l_290 == &g_198);
                return l_298;
                /* statement id: 235 */
                //assert (g_282[0] == dangling || g_282[0] == &g_283);
                //assert (g_285 == 0 || g_285 == dangling);
                //assert (func_75_rv == &g_198);
            }
        }
        /* facts after branching */
        assert (l_238 == 0 || l_238 == &g_56);
        if (l_299[3])
            break;
    }
    return (*g_222);
    /* statement id: 240 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_96
 * writes:
 */
static uint16_t  func_82(int64_t  p_83, const uint16_t  p_84)
{ /* block id: 173 */
    int32_t l_224 = 0L;
    int32_t *l_226[5] = {&g_217,&g_217,&g_217,&g_217,&g_217};
    int8_t l_227[3];
    int i;
    for (i = 0; i < 3; i++)
        l_227[i] = (-6L);
    l_227[2] |= l_224;
    return g_96;
}


/* ------------------------------------------ */
/* 
 * reads : g_58 g_73 g_17 g_96 g_50 g_108 g_110 g_120 g_109 g_155 g_166.f0 g_216 g_217 g_219 g_222
 * writes: g_73 g_96 g_50 g_109 g_120 g_110 g_58 g_155 g_198 g_217 g_220
 */
static uint16_t  func_88(int32_t  p_89, uint16_t  p_90, uint32_t * p_91)
{ /* block id: 51 */
    uint16_t l_101 = 0UL;
    uint32_t ***l_124 = &g_120;
    int16_t l_131[5][4] = {{(-1L),(-1L),0xCBA4L,0x9556L},{0x9556L,0xC54CL,0xCBA4L,0xC54CL},{(-1L),0L,0x6098L,0xCBA4L},{0xC54CL,0L,0L,0xC54CL},{0L,0xC54CL,(-1L),0x9556L}};
    uint32_t l_192 = 4294967295UL;
    int i, j;
    (*l_124) = func_98(__builtin_parityll(l_101), g_58);
    for (p_89 = 0; (p_89 == 26); p_89 += 6)
    { /* block id: 74 */
        struct S0 l_130 = {0xD33F623BA0E38899LL};
        for (g_73 = 0; (g_73 < 6); g_73++)
        { /* block id: 77 */
            int32_t *l_129 = &g_96;
            (*l_129) = p_90;
            g_110 = l_130;
        }
    }
    for (l_101 = 0; (l_101 <= 3); l_101 += 1)
    { /* block id: 84 */
        uint32_t ***l_137 = (void*)0;
        uint32_t ****l_136 = &l_137;
        int32_t l_138 = 0xA08C46E7L;
        int32_t *l_142 = &l_138;
        int32_t *l_144 = &l_138;
        int32_t *l_145 = &l_138;
        uint64_t *l_175[3];
        uint64_t **l_174 = &l_175[1];
        int32_t **l_221 = &l_144;
        int i;
        for (i = 0; i < 3; i++)
            l_175[i] = &g_58;
        if (((int16_t)((int16_t)((g_58 = (((*l_136) = (l_124 = &g_120)) == &g_120)) | (((l_138 == (p_89 > (~g_50))) || ((int32_t)((*l_142) = p_90) + (int32_t)p_90)) && (((0xB137L >= g_110.f0) == p_89) & 4294967287UL))) << (int16_t)9) << (int16_t)g_50))
        { /* block id: 89 */
            int32_t **l_143[3][2][4] = {{{&g_109,(void*)0,&l_142,(void*)0},{&l_142,(void*)0,&g_109,&l_142}},{{(void*)0,&g_109,&l_142,&l_142},{(void*)0,&g_109,&g_109,(void*)0}},{{(void*)0,&l_142,&l_142,&g_109},{(void*)0,(void*)0,&g_109,(void*)0}}};
            uint32_t ***l_152 = &g_120;
            uint32_t l_157 = 0x2A5121ECL;
            struct S0 l_164[8][6] = {{{0xA33B35A5BBF8F425LL},{1L},{1L},{0xA33B35A5BBF8F425LL},{-1L},{0xA33B35A5BBF8F425LL}},{{0xA33B35A5BBF8F425LL},{-1L},{0xA33B35A5BBF8F425LL},{1L},{1L},{0xA33B35A5BBF8F425LL}},{{-1L},{-1L},{1L},{0x38545A47AEA757CBLL},{1L},{-1L}},{{1L},{-1L},{0x38545A47AEA757CBLL},{0x38545A47AEA757CBLL},{-1L},{1L}},{{-1L},{1L},{0x38545A47AEA757CBLL},{1L},{-1L},{-1L}},{{0xA33B35A5BBF8F425LL},{1L},{1L},{0xA33B35A5BBF8F425LL},{-1L},{0xA33B35A5BBF8F425LL}},{{0xA33B35A5BBF8F425LL},{-1L},{0xA33B35A5BBF8F425LL},{1L},{1L},{0xA33B35A5BBF8F425LL}},{{-1L},{-1L},{1L},{0x38545A47AEA757CBLL},{1L},{-1L}}};
            struct S0 *l_167 = &l_164[0][5];
            int i, j, k;
            l_145 = (l_144 = (*g_108));
            /* statement id: 91 */
            assert (l_144 == 0);
            assert (l_145 == 0);
            if (((int64_t)(~((int16_t)p_90 >> (int16_t)5)) % (int64_t)18446744073709551615UL))
            { /* block id: 92 */
                uint32_t l_151 = 0x7553AF01L;
                uint32_t ***l_153[3];
                uint16_t *l_154 = &g_155;
                uint16_t *l_156[3];
                int32_t l_158 = 0L;
                int32_t l_159 = (-1L);
                int i;
                for (i = 0; i < 3; i++)
                    l_153[i] = &g_120;
                for (i = 0; i < 3; i++)
                    l_156[i] = (void*)0;
                l_159 |= (__builtin_bswap32(l_151) < (((((((-6L) | ((*l_142) < (((*l_136) = l_152) != l_153[0]))) & p_89) < ((g_96 <= (l_158 = ((l_157 = ((*l_154) = ((0x69A1ECA9F70EF1A5LL ^ p_90) || 18446744073709551606UL))) || 0x66FAL))) | p_90)) <= p_89) > l_151) && 0x3FF9C57FF43755ECLL));
                p_89 = (&g_56 != (p_91 = &g_56));
                /* statement id: 99 */
                assert (p_91 == &g_56);
            }
            else
            { /* block id: 100 */
                for (l_138 = 0; (l_138 <= 1); l_138 += 1)
                { /* block id: 103 */
                    uint64_t l_160[4];
                    struct S0 l_161[5][8][6] = {{{{0L},{0xEABB79EB048EBA30LL},{-9L},{-8L},{0x72D6ACA7BD2AF93ALL},{0x02F2754ED04B031DLL}},{{-5L},{0xA3B5EBD512F4ECBCLL},{0L},{3L},{0x72D6ACA7BD2AF93ALL},{0x071259696208B9B0LL}},{{-1L},{0xEABB79EB048EBA30LL},{0L},{0xCD532626EB52EEBBLL},{4L},{0x4519CD9794359D76LL}},{{0x9D581DC2E7BD33CELL},{0x6678658A4148A961LL},{5L},{7L},{0x14898B9DDC81AE91LL},{0xBEF20378A6B184C1LL}},{{0L},{0x01D1870374A045A3LL},{1L},{0L},{1L},{0x688B2FF17D062AD8LL}},{{5L},{0x701C1B6254A21752LL},{-1L},{0x00A8503D30EE1A22LL},{0x2CE7F336F0E25250LL},{-1L}},{{0x999ABEDA80D186C8LL},{0L},{0xEABB79EB048EBA30LL},{6L},{-10L},{0xE91FFD6F7C90A92FLL}},{{-1L},{-1L},{0x1848BC0DD118ECCFLL},{0x19CEE68397568C23LL},{-1L},{6L}}},{{{0x99C40DF3FCB1527DLL},{3L},{-1L},{-3L},{0x4519CD9794359D76LL},{0x01D1870374A045A3LL}},{{-1L},{0x00A8503D30EE1A22LL},{0L},{0x1848BC0DD118ECCFLL},{-1L},{0L}},{{3L},{0xF97960EBF8190269LL},{0xE91FFD6F7C90A92FLL},{0L},{0x688B2FF17D062AD8LL},{0x9D581DC2E7BD33CELL}},{{0x00A8503D30EE1A22LL},{0x58DA50500D59F51DLL},{-1L},{-9L},{0xBEF20378A6B184C1LL},{1L}},{{0x4519CD9794359D76LL},{1L},{-3L},{1L},{0x4519CD9794359D76LL},{1L}},{{0L},{0x1531938C4D5004DBLL},{-3L},{0x701C1B6254A21752LL},{0x071259696208B9B0LL},{0x14898B9DDC81AE91LL}},{{0x8F49FF72C97804E3LL},{0x999ABEDA80D186C8LL},{3L},{0x1531938C4D5004DBLL},{0x02F2754ED04B031DLL},{0x14898B9DDC81AE91LL}},{{0L},{0L},{-3L},{-1L},{0x506553B8602F1270LL},{1L}}},{{{0x02F2754ED04B031DLL},{-6L},{-3L},{-3L},{0x14898B9DDC81AE91LL},{1L}},{{1L},{0xC676211E331E6C26LL},{-1L},{0x05832D056028530BLL},{0x999ABEDA80D186C8LL},{0x9D581DC2E7BD33CELL}},{{0xE873C8D9F3E27632LL},{0x72D6ACA7BD2AF93ALL},{0xE91FFD6F7C90A92FLL},{0x19CEE68397568C23LL},{0x0EE989E982BA979DLL},{0L}},{{0xC676211E331E6C26LL},{0x99C40DF3FCB1527DLL},{-1L},{1L},{0xF97960EBF8190269LL},{6L}},{{-10L},{0x0EE989E982BA979DLL},{0x72D6ACA7BD2AF93ALL},{0L},{-1L},{0x58DA50500D59F51DLL}},{{0L},{-8L},{0x1531938C4D5004DBLL},{0x999ABEDA80D186C8LL},{0x6678658A4148A961LL},{7L}},{{0x19CEE68397568C23LL},{3L},{0x6678658A4148A961LL},{0x02F2754ED04B031DLL},{1L},{-9L}},{{3L},{-2L},{6L},{0x9D581DC2E7BD33CELL},{0x99C40DF3FCB1527DLL},{-8L}}},{{{0L},{5L},{0xE873C8D9F3E27632LL},{4L},{4L},{-2L}},{{0xE91FFD6F7C90A92FLL},{-2L},{0x14898B9DDC81AE91LL},{0x14898B9DDC81AE91LL},{-2L},{0xE91FFD6F7C90A92FLL}},{{0x506553B8602F1270LL},{0x2CE7F336F0E25250LL},{0xF97960EBF8190269LL},{5L},{-9L},{0x19CEE68397568C23LL}},{{-9L},{0xCD532626EB52EEBBLL},{0L},{4L},{3L},{-10L}},{{-9L},{6L},{4L},{5L},{0x58DA50500D59F51DLL},{-1L}},{{0x506553B8602F1270LL},{-9L},{-2L},{0x14898B9DDC81AE91LL},{0xEABB79EB048EBA30LL},{0x00A8503D30EE1A22LL}},{{0xE91FFD6F7C90A92FLL},{-9L},{7L},{4L},{0x19CEE68397568C23LL},{-5L}},{{0L},{-1L},{0L},{0x9D581DC2E7BD33CELL},{0xE873C8D9F3E27632LL},{-1L}}},{{{3L},{0x701C1B6254A21752LL},{0L},{0x02F2754ED04B031DLL},{-3L},{-8L}},{{0x19CEE68397568C23LL},{0xA3B5EBD512F4ECBCLL},{0x00A8503D30EE1A22LL},{0x999ABEDA80D186C8LL},{-8L},{1L}},{{0L},{0x1848BC0DD118ECCFLL},{0x58DA50500D59F51DLL},{0L},{0x361ACFDDCEC7099BLL},{-2L}},{{-10L},{0x8F49FF72C97804E3LL},{0x1848BC0DD118ECCFLL},{1L},{1L},{3L}},{{0xC676211E331E6C26LL},{-1L},{-9L},{0x19CEE68397568C23LL},{-9L},{0x999ABEDA80D186C8LL}},{{0xE873C8D9F3E27632LL},{0xE91FFD6F7C90A92FLL},{0x361ACFDDCEC7099BLL},{0x05832D056028530BLL},{0xCD532626EB52EEBBLL},{1L}},{{1L},{-9L},{1L},{-3L},{1L},{-9L}},{{0x02F2754ED04B031DLL},{0L},{6L},{-1L},{5L},{0xA3B5EBD512F4ECBCLL}}}};
                    int32_t *l_163[10][10] = {{(void*)0,&g_96,(void*)0,(void*)0,&g_96,(void*)0,(void*)0,(void*)0,&l_138,&g_96},{&g_96,&l_138,&g_96,(void*)0,&l_138,&g_96,&l_138,(void*)0,&g_96,&l_138},{&g_96,&g_96,&l_138,(void*)0,&g_96,&g_96,&l_138,&l_138,&l_138,&l_138},{&g_96,&l_138,&l_138,&l_138,&l_138,&g_96,&g_96,(void*)0,&l_138,&g_96},{&g_96,&l_138,&g_96,(void*)0,&l_138,&g_96,&l_138,(void*)0,&g_96,&l_138},{&g_96,&g_96,&l_138,(void*)0,&g_96,&g_96,&l_138,&l_138,&l_138,&l_138},{&g_96,&l_138,&l_138,&l_138,&l_138,&g_96,&g_96,(void*)0,&l_138,&g_96},{&g_96,&l_138,&g_96,(void*)0,&l_138,&g_96,&l_138,(void*)0,&g_96,&l_138},{&g_96,&g_96,&l_138,(void*)0,&g_96,&g_96,&l_138,&l_138,&l_138,&l_138},{&g_96,&l_138,&l_138,&l_138,&l_138,&g_96,&g_96,(void*)0,&l_138,&g_96}};
                    int i, j, k;
                    for (i = 0; i < 4; i++)
                        l_160[i] = 0x8A0C824337CDB552LL;
                    for (g_58 = 0; (g_58 <= 1); g_58 += 1)
                    { /* block id: 106 */
                        struct S0 *l_162 = &l_161[2][0][0];
                        int i, j, k;
                        l_160[1] |= (g_96 = l_131[(g_58 + 2)][(g_58 + 1)]);
                        (*l_162) = l_161[2][0][0];
                        if (p_89)
                            continue;
                    }
                    for (g_73 = 0; (g_73 <= 1); g_73 += 1)
                    { /* block id: 114 */
                        int i, j, k;
                        l_163[4][6] = &p_89;
                        /* statement id: 115 */
                        //assert (l_163[0][0] == &p_89 || l_163[0][0] == &l_138 || l_163[0][0] == 0 || l_163[0][0] == &g_96);
                        p_89 ^= 9L;
                        return l_131[(g_73 + 1)][l_138];
                    }
                }
            }
            (*l_167) = l_164[0][5];
            (*l_142) = p_90;
        }
        else
        { /* block id: 123 */
            int32_t **l_168 = &l_144;
            uint32_t *l_173 = &g_73;
            uint16_t *l_180 = (void*)0;
            int16_t l_203 = 0x6813L;
            (*l_168) = (*g_108);
            /* statement id: 124 */
            assert (l_144 == 0);
            if (((uint64_t)(g_58 = (((*l_136) = &g_120) == &g_120)) % (uint64_t)(g_96 | (__builtin_popcountl(((*l_173) = (p_90 & ((uint32_t)g_155 - (uint32_t)((void*)0 == &p_89))))) < p_89))))
            { /* block id: 128 */
                const uint64_t *l_182 = (void*)0;
                int32_t l_193[10][3] = {{0xC9E143BAL,0x34803006L,0x34803006L},{0x9BE4A16BL,1L,0xA8A99E67L},{0xF9F1FA6DL,0xC9E143BAL,0xA57D7B11L},{0x9BE4A16BL,0x9BE4A16BL,(-1L)},{0xC9E143BAL,0xF9F1FA6DL,(-1L)},{1L,0x9BE4A16BL,1L},{0x34803006L,0xC9E143BAL,0x6004B460L},{(-6L),1L,1L},{0x6004B460L,0x34803006L,(-1L)},{0x32BA95D1L,(-6L),(-1L)}};
                uint32_t *l_214 = (void*)0;
                int i, j;
                for (p_89 = 0; (p_89 <= 3); p_89 += 1)
                { /* block id: 131 */
                    uint64_t ***l_176[1];
                    uint16_t *l_177[9][5] = {{&l_101,(void*)0,&g_155,(void*)0,(void*)0},{&l_101,&l_101,(void*)0,&l_101,(void*)0},{&g_155,&g_155,&g_155,&l_101,(void*)0},{&l_101,&l_101,(void*)0,&l_101,(void*)0},{&l_101,&l_101,&g_155,&l_101,&l_101},{&l_101,&l_101,&l_101,&l_101,&l_101},{(void*)0,&g_155,(void*)0,&l_101,&l_101},{&g_155,&l_101,(void*)0,&l_101,&l_101},{&l_101,(void*)0,&l_101,&l_101,&l_101}};
                    uint16_t **l_178 = (void*)0;
                    uint16_t **l_179 = &l_177[1][2];
                    int i, j;
                    for (i = 0; i < 1; i++)
                        l_176[i] = &l_174;
                    l_174 = l_174;
                    if ((((*l_179) = l_177[1][2]) != l_180))
                    { /* block id: 134 */
                        int i, j;
                        return l_131[p_89][l_101];
                    }
                    else
                    { /* block id: 136 */
                        int32_t *l_181 = &g_96;
                        const uint32_t l_191[4][1][8] = {{{0x12EF5272L,4294967287UL,0xBE05BE54L,0xBE05BE54L,4294967287UL,0x12EF5272L,4294967287UL,0xBE05BE54L}},{{0xC1FECEB4L,4294967287UL,0xC1FECEB4L,0x12EF5272L,0x12EF5272L,0xC1FECEB4L,4294967287UL,0xC1FECEB4L}},{{0x66BC57D9L,0x12EF5272L,0xBE05BE54L,0x12EF5272L,0x66BC57D9L,0x66BC57D9L,0x12EF5272L,4294967287UL}},{{0x12EF5272L,0x12EF5272L,0xC1FECEB4L,4294967287UL,0xC1FECEB4L,0x12EF5272L,0x12EF5272L,0xC1FECEB4L}}};
                        int i, j, k;
                        (*l_181) &= ((*l_145) = 7L);
                        if (p_89)
                            continue;
                        (*l_142) &= ((p_90 <= ((void*)0 != l_182)) && (g_155 ^= ((3UL != ((p_89 & p_89) < 0L)) || ((((l_131[0][0] == ((uint64_t)(l_193[1][2] = ((uint64_t)((int16_t)((int16_t)((l_191[0][0][6] & l_192) ^ p_90) << (int16_t)p_89) << (int16_t)p_90) + (uint64_t)l_193[8][1])) + (uint64_t)(*l_181))) == 0x6CFA103EE57E1535LL) || p_89) & 65535UL))));
                        if ((*l_181))
                            continue;
                    }
                    for (p_90 = 2; (p_90 <= 6); p_90 += 1)
                    { /* block id: 147 */
                        int16_t *l_215 = &l_131[4][0];
                        (*l_142) = g_96;
                        (*g_216) &= ((int16_t)((g_155 >= ((uint16_t)(g_198 = l_193[6][0]) >> (uint16_t)((uint32_t)((0xDCC5L ^ (((uint32_t)l_203 - (uint32_t)((int16_t)p_90 >> (int16_t)13)) < ((int16_t)((*l_215) = ((-1L) || (p_90 | ((int32_t)__builtin_ffsll(((((int16_t)(-1L) % (int16_t)((int16_t)(l_214 == (void*)0) << (int16_t)g_166[2][2][1].f0)) < g_96) < l_193[1][2])) - (int32_t)(-1L))))) >> (int16_t)4))) == 0xBDB47CDA25B2F48BLL) + (uint32_t)p_89))) <= (*l_142)) - (int16_t)g_155);
                    }
                }
            }
            else
            { /* block id: 154 */
                struct S0 *l_218 = (void*)0;
                for (g_217 = 4; (g_217 >= 0); g_217 -= 1)
                { /* block id: 157 */
                    for (l_192 = 0; (l_192 <= 6); l_192 += 1)
                    { /* block id: 160 */
                        (*l_168) = &l_138;
                        /* statement id: 161 */
                        assert (l_144 == &l_138);
                    }
                    /* facts after for loop */
                    assert (l_144 == &l_138 || l_144 == 0);
                    return p_89;
                }
                (*g_219) = l_218;
                /* statement id: 165 */
                assert (g_220 == 0);
                (*l_168) = &p_89;
                /* statement id: 166 */
                assert (l_144 == &p_89);
            }
            /* facts after branching */
            assert (l_144 == &p_89 || l_144 == 0);
        }
        /* facts after branching */
        assert (l_137 == &g_120);
        assert (l_144 == &p_89 || l_144 == 0);
        assert (l_145 == &l_138 || l_145 == 0);
        (*l_221) = (*g_108);
        /* statement id: 169 */
        assert (l_144 == 0);
    }
    /* facts after for loop */
    assert (p_91 == 0 || p_91 == &g_56);
    (*g_222) = (*g_108);
    return l_192;
}


/* ------------------------------------------ */
/* 
 * reads : g_73 g_17 g_96 g_50 g_108 g_110 g_120
 * writes: g_73 g_96 g_50 g_109
 */
inline static uint32_t ** func_98(int64_t  p_99, uint32_t  p_100)
{ /* block id: 52 */
    uint64_t l_104 = 18446744073709551611UL;
    uint32_t *l_122 = (void*)0;
    uint32_t **l_121 = &l_122;
    uint32_t **l_123 = &l_122;
    for (g_73 = 16; (g_73 != 8); g_73 -= 1)
    { /* block id: 55 */
        volatile struct S0 l_112[3] = {{0L},{0L},{0L}};
        uint32_t *l_118[5][5][6] = {{{&g_56,&g_56,&g_56,&g_56,&g_56,(void*)0},{&g_56,&g_56,(void*)0,&g_56,&g_56,&g_56},{(void*)0,&g_56,&g_56,&g_56,&g_56,&g_56},{(void*)0,&g_56,&g_56,&g_56,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_56,&g_56,&g_56}},{{&g_56,&g_56,&g_56,(void*)0,(void*)0,&g_56},{&g_56,(void*)0,&g_56,(void*)0,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_56,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_56,(void*)0,&g_56},{(void*)0,(void*)0,&g_56,&g_56,&g_56,&g_56}},{{(void*)0,&g_56,&g_56,&g_56,(void*)0,&g_56},{&g_56,(void*)0,&g_56,&g_56,&g_56,&g_56},{&g_56,(void*)0,&g_56,(void*)0,&g_56,&g_56},{&g_56,&g_56,&g_56,(void*)0,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_56,&g_56,&g_56}},{{&g_56,(void*)0,&g_56,&g_56,&g_56,(void*)0},{(void*)0,&g_56,&g_56,&g_56,&g_56,&g_56},{(void*)0,(void*)0,&g_56,&g_56,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_56,&g_56,&g_56},{&g_56,&g_56,&g_56,(void*)0,&g_56,&g_56}},{{&g_56,&g_56,&g_56,(void*)0,&g_56,&g_56},{&g_56,&g_56,&g_56,&g_56,&g_56,(void*)0},{&g_56,&g_56,(void*)0,&g_56,&g_56,&g_56},{(void*)0,&g_56,&g_56,&g_56,&g_56,&g_56},{(void*)0,&g_56,&g_56,&g_56,&g_56,&g_56}}};
        uint32_t **l_117 = &l_118[2][3][2];
        int i, j, k;
        g_96 &= (l_104 & (p_100 && g_17));
        for (g_50 = 0; (g_50 < (-27)); g_50 -= 1)
        { /* block id: 59 */
            int32_t *l_107 = (void*)0;
            volatile struct S0 *l_111[9] = {&g_110,&g_110,&g_110,&g_110,&g_110,&g_110,&g_110,&g_110,&g_110};
            int i;
            (*g_108) = l_107;
            l_112[2] = g_110;
            for (p_99 = (-19); (p_99 < (-5)); p_99++)
            { /* block id: 64 */
                int32_t *l_119 = &g_96;
                (*l_119) = ((uint64_t)(((void*)0 != l_117) | ((void*)0 == (*l_117))) + (uint64_t)(g_110.f0 == ((void*)0 != l_118[2][3][2])));
                return g_120;
                /* statement id: 66 */
                //assert (func_98_rv == 0);
            }
        }
    }
    return g_120;
    /* statement id: 70 */
    //assert (func_98_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    transparent_crc(g_17, "g_17", print_hash_value);
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_56, "g_56", print_hash_value);
    transparent_crc(g_58, "g_58", print_hash_value);
    transparent_crc(g_73, "g_73", print_hash_value);
    transparent_crc(g_96, "g_96", print_hash_value);
    transparent_crc(g_110.f0, "g_110.f0", print_hash_value);
    transparent_crc(g_155, "g_155", print_hash_value);
    for (i = 0; i < 6; i++)
    {
        for (j = 0; j < 8; j++)
        {
            for (k = 0; k < 5; k++)
            {
                transparent_crc(g_166[i][j][k].f0, "g_166[i][j][k].f0", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_198, "g_198", print_hash_value);
    transparent_crc(g_217, "g_217", print_hash_value);
    transparent_crc(g_231, "g_231", print_hash_value);
    transparent_crc(g_240, "g_240", print_hash_value);
    transparent_crc(g_283, "g_283", print_hash_value);
    transparent_crc(g_296, "g_296", print_hash_value);
    transparent_crc(g_305, "g_305", print_hash_value);
    transparent_crc(g_306, "g_306", print_hash_value);
    transparent_crc(g_359, "g_359", print_hash_value);
    transparent_crc(g_404, "g_404", print_hash_value);
    transparent_crc(g_545, "g_545", print_hash_value);
    transparent_crc(g_610, "g_610", print_hash_value);
    transparent_crc(g_648, "g_648", print_hash_value);
    transparent_crc(g_700, "g_700", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 229
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 135
   depth: 2, occurrence: 38
   depth: 3, occurrence: 7
   depth: 4, occurrence: 5
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 190

XXX times a variable address is taken: 437
XXX times a pointer is dereferenced on RHS: 64
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 127
breakdown:
   depth: 1, occurrence: 125
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 1944

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 575
   level: 2, occurrence: 78
   level: 3, occurrence: 13
   level: 4, occurrence: 7
XXX number of pointers point to pointers: 69
XXX number of pointers point to scalars: 111
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 34.7
XXX average alias set size: 1.41

XXX times a non-volatile is read: 533
XXX times a non-volatile is write: 354
XXX times a volatile is read: 34
XXX    times read thru a pointer: 3
XXX times a volatile is write: 36
XXX    times written thru a pointer: 17
XXX times a volatile is available for access: 811
XXX percentage of non-volatile access: 92.7

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 135
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 22
   depth: 2, occurrence: 29
   depth: 3, occurrence: 22
   depth: 4, occurrence: 15
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 24.1
XXX percentage an existing variable is used: 75.9
********************* end of statistics **********************/

