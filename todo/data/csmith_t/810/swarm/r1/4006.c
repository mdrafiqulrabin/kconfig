/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      944145738
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 19;
   signed f1 : 28;
   const unsigned f2 : 14;
   const unsigned f3 : 2;
   signed f4 : 9;
   signed f5 : 28;
   unsigned f6 : 10;
   signed f7 : 23;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint32_t  f0;
   int32_t  f1;
   uint32_t  f2;
   uint16_t  f3;
   int32_t  f4;
   struct S0  f5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const uint16_t  func_34(void);
static float * func_50(struct S0  p_51, float * p_52, float * p_53);
static struct S0  func_54(float * p_55, int32_t  p_56, float * p_57, float  p_58);
static int16_t  func_66(uint16_t  p_67, float * p_68, uint32_t  p_69, const uint16_t  p_70, struct S0  p_71);
static uint16_t  func_72(uint32_t  p_73);
static int32_t  func_80(float * p_81, uint32_t  p_82);
static float * func_83(const struct S1  p_84, float * p_85, int32_t  p_86, float * p_87);
static struct S1  func_88(float * p_89, float * p_90, uint16_t  p_91);
static float * func_92(struct S1  p_93);
static struct S1  func_94(struct S1  p_95, struct S0  p_96, float * p_97, float * p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint16_t  func_34(void)
{ /* block id: 36 */
    const uint32_t l_42 = 0x0090AE73L;
    float l_44 = 0xB.9D9E62p-20;
    float *l_43 = &l_44;
    float *l_59 = &l_44;
    struct S1 l_99 = {0xFC0BD789L,0x2EB5F757L,18446744073709551613UL,0x9E21L,0L,{-612,7606,127,1,14,-14597,0,-2843}};
    float *l_100 = &l_44;
    float *l_101 = (void*)0;
    float *l_410 = &l_44;
    float *l_416 = (void*)0;
    float *l_417 = &l_44;
    int32_t l_692 = 1L;
    float *l_722 = (void*)0;
    uint32_t l_723 = 0x0F128A65L;
    int16_t l_742 = (-3L);
    int16_t *l_741 = &l_742;
    float *l_743 = &l_44;
    float *l_751 = &l_44;
    float *l_752 = &l_44;
    const float *l_815 = (void*)0;
    const float **l_814 = &l_815;
    const float *l_816 = &l_44;
    const float l_817 = (-0x2.Fp-1);
    int32_t *l_835 = &l_99.f1;
    int32_t **l_834 = &l_835;
    const uint32_t l_836 = 0xACEF57FFL;
    (*l_43) = ((float)(-0x1.5p+1) / (float)((float)0xE.A18461p-45 / (float)((+(-0x6.8p-1)) <= ((float)0x4.59EC13p+83 - (float)l_42))));
    if (((uint16_t)((uint16_t)(~(((*l_814) = func_50(func_54(l_59, (((int16_t)l_42 / (int16_t)((*l_741) = (l_42 || ((uint32_t)(((((int32_t)(func_66(func_72(((((uint16_t)((int16_t)((int32_t)func_80(func_83(func_88(func_92(func_94(l_99, l_99.f5, l_100, l_101)), l_410, l_99.f5.f7), l_416, l_99.f1, l_417), l_99.f5.f0) - (int32_t)0x7F388809L) + (int16_t)l_99.f5.f4) >> (uint16_t)1) <= l_99.f5.f2) || l_692)), l_722, l_723, l_99.f5.f6, l_99.f5) != 65535UL) % (int32_t)(-1L)) && l_99.f3) > (-8L)) > l_692) - (uint32_t)0x374F1271L)))) | l_99.f5.f1), l_743, l_692), l_751, l_752)) != l_816)) >> (uint16_t)13) << (uint16_t)l_99.f0))
    { /* block id: 531 */
        return l_99.f3;
    }
    else
    { /* block id: 533 */
        struct S1 **l_818 = (void*)0;
        struct S1 *l_819 = (void*)0;
        int32_t l_826 = (-1L);
        int32_t *l_829 = &l_99.f1;
        int32_t *l_832 = (void*)0;
        int32_t *l_833 = &l_826;
        l_819 = &l_99;
        (*l_833) = ((uint32_t)((0x2F952DE3L || (((((((uint16_t)func_72(l_826) + (uint16_t)l_826) < (l_692 < ((*l_829) = ((uint16_t)l_99.f5.f1 >> (uint16_t)0)))) && 0L) && ((int16_t)(((*l_829) > (__builtin_popcountl(((*l_829) < (*l_829))) <= (*l_829))) | l_723) - (int16_t)(*l_829))) <= l_692) == 7L)) > 0xB7F0A5CEL) % (uint32_t)l_99.f5.f4);
    }
    (*l_834) = l_752;
    return l_836;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_50(struct S0  p_51, float * p_52, float * p_53)
{ /* block id: 494 */
    int32_t l_753 = 0x280DB3CBL;
    const struct S1 l_754 = {0x39893BE5L,-1L,0x56944E92L,0x1920L,1L,{-49,-2437,39,1,17,-6866,3,2273}};
    float *l_755 = (void*)0;
    int32_t l_757 = (-1L);
    int32_t *l_785 = &l_757;
    uint16_t l_793 = 1UL;
    uint16_t *l_792 = &l_793;
    int32_t l_795 = 0xF10E5A99L;
    int16_t l_808 = (-5L);
    if (l_753)
    { /* block id: 495 */
        int16_t l_756 = 0xFEE4L;
        float *l_763 = (void*)0;
        float **l_762 = &l_763;
        int32_t *l_765 = &l_757;
        int32_t **l_764 = &l_765;
        struct S1 l_772 = {0xD01E0DE2L,0x9E54F3ADL,0UL,0UL,0x0576930EL,{342,-11589,89,0,9,6443,9,-896}};
        struct S1 *l_771 = &l_772;
        struct S1 **l_773 = &l_771;
        (*l_764) = func_83(l_754, func_92(func_88(p_53, l_755, ((((p_51.f7 != l_756) != (l_757 = 4L)) & ((int16_t)((int16_t)func_72(func_66(l_756, ((*l_762) = (void*)0), l_754.f5.f5, l_756, p_51)) >> (int16_t)l_756) >> (int16_t)13)) | p_51.f0))), l_756, p_52);
        for (l_756 = 25; (l_756 == 1); l_756 -= 5)
        { /* block id: 501 */
            float l_769 = 0xC.2371FEp-99;
            float *l_768 = &l_769;
            int32_t l_770 = 0xDEE8E443L;
            if ((*l_765))
                break;
            if (l_754.f5.f7)
                break;
            p_51.f5 = (((*l_762) = func_83(l_754, p_52, (**l_764), (*l_762))) == l_768);
            if (l_770)
                break;
        }
        (*l_773) = l_771;
    }
    else
    { /* block id: 509 */
        int16_t l_783 = 4L;
        struct S1 l_784 = {0x8CFD9F78L,-7L,1UL,1UL,1L,{220,15385,17,1,8,1435,22,-307}};
        uint16_t *l_794 = &l_784.f3;
        int32_t *l_800 = (void*)0;
        int32_t *l_801 = (void*)0;
        int32_t *l_802 = &l_784.f1;
        uint32_t l_805 = 0x74298835L;
        for (l_757 = 19; (l_757 >= 18); l_757 -= 8)
        { /* block id: 512 */
            const int16_t l_777 = (-1L);
            int32_t l_779 = 0x1815AA83L;
            int32_t *l_778 = &l_779;
            struct S1 l_780 = {1UL,0x8A823FC7L,18446744073709551606UL,0xB31DL,1L,{-86,-12908,58,0,-13,-3144,21,2164}};
            const int32_t *l_782 = &l_757;
            const int32_t **l_781 = &l_782;
            (*l_778) = (((-(int16_t)l_777) >= l_777) <= p_51.f3);
            (*l_781) = func_92(l_780);
            if (l_783)
                break;
        }
        l_785 = func_92(l_784);
        p_51.f4 = (p_51.f1 < ((int16_t)(((uint16_t)((uint16_t)(l_792 == (l_794 = l_794)) / (uint16_t)l_795) % (uint16_t)((uint32_t)((int32_t)((*l_802) = p_51.f0) - (int32_t)((int32_t)(p_51.f7 = l_805) + (int32_t)p_51.f5)) - (uint32_t)((uint16_t)__builtin_bswap32(p_51.f1) % (uint16_t)p_51.f0))) > p_51.f2) % (int16_t)l_808));
        (*l_802) = func_72(p_51.f0);
    }
    for (l_793 = 4; (l_793 != 28); l_793 += 8)
    { /* block id: 526 */
        struct S1 l_813 = {0x531E6EF9L,-3L,0xD4D8E173L,0x0345L,0x1A91DAA8L,{-61,-12778,120,1,-5,11753,23,-2242}};
        struct S1 *l_812 = &l_813;
        struct S1 **l_811 = &l_812;
        (*l_811) = (void*)0;
    }
    return l_755;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_54(float * p_55, int32_t  p_56, float * p_57, float  p_58)
{ /* block id: 484 */
    int32_t l_745 = 1L;
    const int32_t *l_744 = &l_745;
    int32_t *l_747 = &l_745;
    int32_t **l_746 = &l_747;
    struct S0 l_750 = {324,5398,24,1,-1,20,5,-730};
lbl_749:
    (*l_746) = l_744;
    if (p_56)
    { /* block id: 486 */
        (*l_746) = (void*)0;
    }
    else
    { /* block id: 488 */
        uint32_t l_748 = 0x7AF73D95L;
        l_748 = 0xDA2D41D2L;
        if (p_56)
            goto lbl_749;
    }
    (*l_746) = p_57;
    return l_750;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_66(uint16_t  p_67, float * p_68, uint32_t  p_69, const uint16_t  p_70, struct S0  p_71)
{ /* block id: 475 */
    int16_t ***l_725 = (void*)0;
    int16_t ****l_724 = &l_725;
    int32_t l_726 = 0x4FD74DEDL;
    int16_t *l_734 = (void*)0;
    int16_t l_736 = 0x88A6L;
    int16_t *l_735 = &l_736;
    const int32_t l_737 = 0xF23D2FE6L;
    float l_739 = (-0x1.2p+1);
    float *l_738 = &l_739;
    int32_t l_740 = 0x729D0760L;
    l_724 = l_724;
    (*l_738) = ((l_726 = ((0xD.DB9889p+15 <= (l_726 >= l_726)) < ((float)(l_726 != (__builtin_ctzl((!((int32_t)((uint16_t)p_71.f0 - (uint16_t)((*l_735) = p_69)) - (int32_t)__builtin_popcountl(p_71.f1)))) < (-0x1.Fp-1))) / (float)p_71.f4))) > l_737);
    (*l_738) = l_740;
    l_726 = (-6L);
    return l_737;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_72(uint32_t  p_73)
{ /* block id: 460 */
    float l_693 = 0x5.0p-1;
    int32_t l_694 = 1L;
    int32_t *l_695 = &l_694;
    struct S0 l_699 = {-72,8318,49,1,-2,-11592,5,1083};
    struct S0 *l_698 = &l_699;
    const uint64_t **l_703 = (void*)0;
    struct S1 l_711 = {0xE0D27B19L,0x9271B03EL,0x03E098ACL,65535UL,2L,{201,4297,125,1,-0,-6124,16,165}};
    struct S1 *l_710 = &l_711;
    (*l_695) = (l_694 >= p_73);
    for (l_694 = 16; (l_694 >= (-9)); l_694 -= 2)
    { /* block id: 464 */
        float *l_700 = &l_693;
        uint64_t *l_702 = (void*)0;
        uint64_t **l_701 = &l_702;
        int32_t l_704 = 0x12CA5CD6L;
        struct S1 **l_712 = &l_710;
        struct S1 *l_714 = &l_711;
        struct S1 **l_713 = &l_714;
        float *l_715 = (void*)0;
        float l_717 = 0xF.8CF037p+40;
        float *l_716 = &l_717;
        uint16_t l_718 = 65535UL;
        float l_720 = 0x0.152E0Cp-3;
        float *l_719 = &l_720;
        const float l_721 = 0x9.7p+1;
        (*l_700) = (l_698 != &l_699);
        (*l_700) = (l_701 == l_703);
        l_704 = (((*l_719) = (l_704 != ((float)(+(((__builtin_ctzl((*l_695)) != (-0x1.Ap+1)) < (((((*l_716) = ((*l_700) = ((float)func_80(l_700, (((*l_712) = l_710) != ((*l_713) = &l_711))) / (float)(*l_695)))) != (*l_695)) < p_73) >= l_704)) > 0xE.DF4553p+7)) / (float)l_718))) == l_721);
    }
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_80(float * p_81, uint32_t  p_82)
{ /* block id: 458 */
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_83(const struct S1  p_84, float * p_85, int32_t  p_86, float * p_87)
{ /* block id: 280 */
    int32_t l_420 = 0x623F3E8BL;
    struct S0 l_422 = {-622,10102,91,1,-18,5572,4,-1801};
    struct S0 *l_421 = &l_422;
    uint64_t l_428 = 0x4E7248802F0B265BLL;
    uint64_t *l_427 = &l_428;
    uint64_t **l_426 = &l_427;
    int16_t l_449 = (-1L);
    int16_t *l_448 = &l_449;
    int32_t l_456 = 0x985CADD1L;
    int32_t *l_455 = &l_456;
    float l_554 = (-0x6.9p+1);
    float *l_553 = &l_554;
    float *l_555 = &l_554;
    struct S0 l_595 = {208,15480,71,0,-6,14941,25,1076};
    const struct S0 *l_594 = &l_595;
    int16_t ***l_633 = (void*)0;
    int16_t ****l_632 = &l_633;
    struct S1 **l_637 = (void*)0;
    struct S1 ***l_636 = &l_637;
    float l_674 = 0x1.Fp+1;
    for (p_86 = 0; (p_86 != (-10)); p_86 -= 1)
    { /* block id: 283 */
        float l_453 = (-0x4.5p+1);
        int16_t *l_466 = &l_449;
        const int32_t l_471 = 0x25971B6AL;
        uint32_t l_472 = 0x2A46E927L;
        uint64_t ***l_483 = &l_426;
        int32_t *l_484 = &l_456;
        int32_t l_486 = (-2L);
        int32_t *l_485 = &l_486;
        struct S1 l_589 = {0x87793941L,0x4D1BE87EL,18446744073709551609UL,0x2FD7L,0x706192A3L,{603,-9777,4,1,13,16240,4,1797}};
        struct S1 *l_588 = &l_589;
        int16_t **l_631 = (void*)0;
        int16_t ***l_630 = &l_631;
        int16_t ****l_629 = &l_630;
        int32_t *l_670 = &l_486;
        uint32_t l_673 = 0x753B200AL;
        uint32_t *l_675 = &l_472;
        int32_t l_688 = 0x703DD7E3L;
        int32_t *l_689 = &l_456;
    }
    (*l_455) = ((int32_t)(*l_455) / (int32_t)(*l_455));
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_88(float * p_89, float * p_90, uint16_t  p_91)
{ /* block id: 272 */
    int32_t l_411 = (-2L);
    int32_t *l_412 = &l_411;
    struct S1 l_415 = {0UL,0x2E3C69D2L,18446744073709551613UL,2UL,0x1B3ED8FFL,{-72,-3892,109,1,7,-7791,10,-1389}};
    (*l_412) = l_411;
    for (l_411 = (-22); (l_411 == 11); l_411 += 6)
    { /* block id: 276 */
        return l_415;
    }
    return l_415;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_92(struct S1  p_93)
{ /* block id: 269 */
    int16_t l_399 = (-1L);
    float *l_405 = (void*)0;
    float l_407 = 0xA.3D8554p+23;
    float *l_406 = &l_407;
    float *l_408 = &l_407;
    float *l_409 = (void*)0;
    (*l_406) = (0x3.8F75A0p+87 <= (((float)(((float)p_93.f5.f4 / (float)(p_93.f5.f6 >= p_93.f5.f4)) > ((float)l_399 + (float)(p_93.f5.f6 <= (!(((float)0xA.F851A6p+54 / (float)((float)__builtin_popcountl(p_93.f4) / (float)l_399)) != l_399))))) - (float)l_399) > l_399));
    return l_409;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_94(struct S1  p_95, struct S0  p_96, float * p_97, float * p_98)
{ /* block id: 38 */
    int32_t l_104 = 0x82083236L;
    int32_t *l_103 = &l_104;
    int32_t **l_102 = &l_103;
    uint32_t l_113 = 18446744073709551615UL;
    float l_126 = 0xB.0E5992p-47;
    float *l_125 = &l_126;
    struct S1 l_137 = {18446744073709551607UL,0xB50BCEF8L,0x2069947AL,0xBBF6L,0L,{623,1374,89,1,11,10363,22,-2162}};
    struct S1 *l_136 = &l_137;
    int16_t l_176 = (-1L);
    const int16_t *l_175 = &l_176;
    uint32_t l_188 = 4294967292UL;
    struct S0 *l_241 = &l_137.f5;
    int16_t *l_305 = (void*)0;
    int16_t **l_304 = &l_305;
    int16_t ***l_303 = &l_304;
    int16_t ****l_306 = &l_303;
    uint64_t l_311 = 0x18D95EC47EE0E8DCLL;
    uint64_t *l_310 = &l_311;
    uint64_t **l_309 = &l_310;
    struct S1 **l_373 = (void*)0;
    struct S1 ***l_372 = &l_373;
    struct S1 ****l_371 = &l_372;
    uint16_t l_386 = 65532UL;
    (*l_102) = p_97;
    return p_95;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 182
   depth: 1, occurrence: 1
   depth: 2, occurrence: 8
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 42
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 22
   indirect level: 2, occurrence: 2
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX times a bitfields struct's address is taken: 34
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 49
XXX times a single bitfield on LHS: 12
XXX times a single bitfield on RHS: 94

XXX max expression depth: 47
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 47, occurrence: 1

XXX total number of pointers: 258

XXX times a variable address is taken: 233
XXX times a pointer is dereferenced on RHS: 76
breakdown:
   depth: 1, occurrence: 59
   depth: 2, occurrence: 17
XXX times a pointer is dereferenced on LHS: 194
breakdown:
   depth: 1, occurrence: 179
   depth: 2, occurrence: 13
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 464

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 362
   level: 2, occurrence: 70
   level: 3, occurrence: 3
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 113
XXX number of pointers point to scalars: 120
XXX number of pointers point to structs: 25
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.19

XXX times a non-volatile is read: 717
XXX times a non-volatile is write: 480
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 5

XXX stmts: 55
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 18
   depth: 2, occurrence: 7

XXX percentage a fresh-made variable is used: 24.4
XXX percentage an existing variable is used: 75.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

