/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1331616886
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
   const volatile uint16_t  f1;
   uint16_t  f2;
   uint8_t  f3;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int64_t g_3 = 0L;
static struct S0 g_30 = {0x1A4E665969A22DB7LL,1UL,0x478CL,255UL};/* VOLATILE GLOBAL g_30 */
static volatile int32_t g_63 = 0L;/* VOLATILE GLOBAL g_63 */
static struct S0 *g_110 = &g_30;
static struct S0 **g_109 = &g_110;
static int32_t *g_111 = (void*)0;
static int32_t g_134 = 0xE3026CBAL;
static int32_t ** volatile g_150 = &g_111;/* VOLATILE GLOBAL g_150 */
static struct S0 ***g_153 = &g_109;
static const int32_t *g_156 = &g_134;
static const int32_t ** volatile g_155 = &g_156;/* VOLATILE GLOBAL g_155 */
static const int32_t ** volatile g_177 = (void*)0;/* VOLATILE GLOBAL g_177 */
static const int32_t ** volatile g_182 = &g_156;/* VOLATILE GLOBAL g_182 */
static const int32_t ** volatile g_186 = &g_156;/* VOLATILE GLOBAL g_186 */
static int32_t * volatile g_189 = &g_134;/* VOLATILE GLOBAL g_189 */
static int32_t * volatile g_236 = &g_134;/* VOLATILE GLOBAL g_236 */
static const int32_t ** volatile g_237 = &g_156;/* VOLATILE GLOBAL g_237 */
static int32_t * volatile g_244 = &g_134;/* VOLATILE GLOBAL g_244 */
static int32_t * volatile g_247 = &g_134;/* VOLATILE GLOBAL g_247 */
static int32_t ** volatile g_250 = &g_111;/* VOLATILE GLOBAL g_250 */
static const int32_t ** volatile *g_255 = &g_182;
static const int32_t ** volatile **g_254 = &g_255;
static const int32_t ** volatile *** volatile g_256 = &g_254;/* VOLATILE GLOBAL g_256 */
static int32_t * volatile g_265 = (void*)0;/* VOLATILE GLOBAL g_265 */
static int32_t * volatile g_266 = &g_134;/* VOLATILE GLOBAL g_266 */
static struct S0 g_319 = {0x0C468759E3B7EF3DLL,9UL,1UL,0x06L};/* VOLATILE GLOBAL g_319 */
static const uint32_t g_355 = 0x37C8973BL;
static struct S0 ***** volatile g_539 = (void*)0;/* VOLATILE GLOBAL g_539 */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_29(void);
inline static int8_t  func_31(int64_t  p_32, uint64_t  p_33, int64_t  p_34, uint64_t  p_35, int32_t  p_36);
static uint32_t  func_37(int32_t  p_38, uint16_t  p_39);
inline static int8_t  func_42(int64_t  p_43, uint32_t  p_44);
inline static uint32_t  func_48(uint8_t  p_49);
inline static int64_t  func_75(uint16_t  p_76, uint32_t  p_77, uint8_t  p_78);
inline static uint32_t  func_85(uint32_t  p_86, int32_t * p_87, int32_t  p_88, int64_t  p_89, struct S0 * p_90);
inline static const int8_t  func_94(struct S0 ** p_95);
static struct S0  func_97(const int32_t  p_98, const uint64_t  p_99);
static int32_t  func_100(const int32_t  p_101, struct S0 ** p_102, int16_t  p_103, struct S0 ** p_104, int32_t * p_105);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_30 g_109 g_155 g_156 g_236 g_134 g_319.f3 g_254 g_255 g_182 g_63 g_256 g_111 g_319.f2 g_150 g_237 g_319.f1 g_355 g_319.f0 g_110 g_153
 * writes: g_63 g_110 g_3 g_134 g_319.f2 g_156 g_111 g_30.f2 g_30.f0 g_153
 */
inline static uint64_t  func_29(void)
{ /* block id: 36 */
    uint16_t l_45 = 0UL;
    int16_t l_522 = (-1L);
    int32_t *l_532 = &g_134;
    const int32_t *l_554 = (void*)0;
    if (g_3)
    { /* block id: 37 */
        uint32_t l_58 = 0xEE8B7203L;
        uint16_t l_528 = 0xAD38L;
        int64_t l_529 = 7L;
        if ((g_30 , ((((func_31(g_30.f2, (((func_37(((uint8_t)(func_42(l_45, (((uint32_t)func_48(((uint8_t)(((uint8_t)g_30.f2 + (uint8_t)((uint32_t)((7L | (__builtin_popcountl((((((int16_t)(4294967295UL | 0xA5FC0266L) >> (int16_t)(__builtin_clz((((0xC73EE49CE5708880LL & g_3) < 0x1EAE883781CDFFA8LL) && 0xA501900312349124LL)) != g_30.f2)) <= l_58) == l_58) >= g_30.f2)) , g_30.f3)) < 0x5DBF6070L) % (uint32_t)g_30.f2)) == g_3) * (uint8_t)l_58)) % (uint32_t)g_319.f3) <= l_58)) ^ 255UL) * (uint8_t)g_319.f3), l_45) || l_58) >= 0x01B48D667C5F155DLL) , l_45), l_522, g_30.f2, g_30.f0) || 0xF4L) , l_528) , l_529) != g_30.f0)))
        { /* block id: 313 */
            (***g_254) = (*g_150);
            for (g_30.f2 = (-18); (g_30.f2 != 30); g_30.f2 += 2)
            { /* block id: 317 */
                if (l_522)
                    break;
            }
            (*g_150) = l_532;
        }
        else
        { /* block id: 321 */
            if ((*l_532))
            { /* block id: 322 */
                uint32_t l_533 = 0xC95A2D97L;
                uint32_t l_534 = 0xACDED3C5L;
                (***g_254) = (*g_237);
                l_534 = l_533;
                (*l_532) = ((uint16_t)g_134 >> (uint16_t)13);
                return g_319.f1;
            }
            else
            { /* block id: 327 */
                const int32_t l_542 = (-6L);
                for (g_319.f2 = 0; (g_319.f2 >= 7); g_319.f2++)
                { /* block id: 330 */
                    struct S0 ****l_541 = &g_153;
                    struct S0 *****l_540 = &l_541;
                    (*l_540) = &g_153;
                }
                (*l_532) = l_542;
            }
        }
    }
    else
    { /* block id: 336 */
        int32_t **l_548 = &l_532;
        (*l_532) = ((((18446744073709551615UL != 0x72A662529F20F999LL) > (((*l_532) & ((((int64_t)((((((((*l_532) && (!(0x98L | ((uint8_t)(g_319.f3 , 0x99L) - (uint8_t)g_355)))) > (l_548 != &l_532)) , 0x0E09586C9228D044LL) <= g_319.f3) , g_319.f0) <= g_319.f0) , (**l_548)) + (int64_t)g_63) | (*l_532)) > 2UL)) == 4294967295UL)) , 0x810EA93CL) ^ (**l_548));
        return g_319.f1;
    }
    for (l_522 = 0; (l_522 < 29); l_522 += 8)
    { /* block id: 342 */
        const int32_t *l_551 = (void*)0;
        int32_t *l_564 = &g_134;
        l_551 = (***g_254);
        for (g_134 = 0; (g_134 <= 3); ++g_134)
        { /* block id: 346 */
            int16_t l_575 = 0x4466L;
            int32_t *l_576 = (void*)0;
            struct S0 ****l_577 = (void*)0;
            struct S0 ****l_578 = &g_153;
            l_554 = (*g_155);
            for (g_30.f0 = 0; (g_30.f0 < 11); g_30.f0++)
            { /* block id: 350 */
                for (g_30.f2 = 27; (g_30.f2 == 1); g_30.f2 -= 5)
                { /* block id: 353 */
                    for (l_45 = 22; (l_45 >= 2); l_45--)
                    { /* block id: 356 */
                        uint32_t l_561 = 0x5DA8ABE5L;
                        (**g_153) = (*g_109);
                        return l_561;
                    }
                    for (g_319.f2 = 0; (g_319.f2 <= 45); ++g_319.f2)
                    { /* block id: 362 */
                        (***g_254) = (g_30.f0 , l_564);
                    }
                    l_575 = (g_319.f1 | (((1L > (((uint8_t)((uint16_t)65535UL >> (uint16_t)((int8_t)(((int8_t)((int64_t)0xD7ECBDB177373839LL + (int64_t)g_30.f0) * (int8_t)g_134) & (__builtin_popcountll((*l_532)) && g_319.f3)) >> (int8_t)1)) * (uint8_t)254UL) , g_30.f3)) <= 0x50L) && g_30.f0));
                    (**g_255) = (*g_150);
                }
                (**g_255) = l_576;
            }
            (*l_578) = &g_109;
        }
    }
    return g_319.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_256 g_254 g_255 g_182 g_319.f2
 * writes: g_156
 */
inline static int8_t  func_31(int64_t  p_32, uint64_t  p_33, int64_t  p_34, uint64_t  p_35, int32_t  p_36)
{ /* block id: 309 */
    int32_t *l_523 = (void*)0;
    const int32_t **l_527 = &g_156;
    const int32_t ***l_526 = &l_527;
    const int32_t ****l_525 = &l_526;
    const int32_t *****l_524 = &l_525;
    (****g_256) = l_523;
    (*l_524) = (void*)0;
    return g_319.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_254 g_255 g_182 g_134 g_256 g_111
 * writes: g_156 g_111
 */
static uint32_t  func_37(int32_t  p_38, uint16_t  p_39)
{ /* block id: 304 */
    uint32_t l_512 = 0xCB1DAB4EL;
    int32_t *l_513 = &g_134;
    int32_t **l_520 = &g_111;
    int32_t ***l_519 = &l_520;
    int32_t ****l_518 = &l_519;
    uint8_t l_521 = 0xF3L;
    l_512 = p_39;
    (***g_254) = l_513;
    (*l_520) = (((uint32_t)(*l_513) + (uint32_t)((uint16_t)(l_518 == (p_38 , (*g_256))) >> (uint16_t)15)) , (*l_520));
    return l_521;
}


/* ------------------------------------------ */
/* 
 * reads : g_254 g_255 g_182 g_63
 * writes: g_156
 */
inline static int8_t  func_42(int64_t  p_43, uint32_t  p_44)
{ /* block id: 301 */
    int32_t *l_511 = (void*)0;
    (***g_254) = l_511;
    return g_63;
}


/* ------------------------------------------ */
/* 
 * reads : g_30.f1 g_109 g_155 g_156 g_236 g_134
 * writes: g_63 g_110 g_3 g_134 g_319.f2
 */
inline static uint32_t  func_48(uint8_t  p_49)
{ /* block id: 38 */
    int64_t l_66 = 0xF75BAE5BD571E957LL;
    struct S0 *l_74 = (void*)0;
    struct S0 **l_73 = &l_74;
    int32_t l_320 = 0x320A0211L;
    int32_t *l_324 = &g_134;
    int32_t *****l_388 = (void*)0;
    int32_t ***l_392 = (void*)0;
    int32_t ****l_391 = &l_392;
    int32_t *****l_390 = &l_391;
    int32_t ****l_423 = &l_392;
    int32_t l_438 = 0L;
    uint16_t l_504 = 0x8243L;
    if ((!0x61L))
    { /* block id: 39 */
        for (p_49 = 15; (p_49 != 43); p_49++)
        { /* block id: 42 */
            volatile int32_t *l_62 = &g_63;
            (*l_62) = g_30.f1;
        }
    }
    else
    { /* block id: 45 */
        uint64_t l_64 = 0x99E6047311EBC848LL;
        struct S0 **l_96 = &l_74;
        int32_t l_333 = (-1L);
        int32_t *l_356 = (void*)0;
        int32_t *****l_394 = (void*)0;
        if ((l_64 < (~(l_66 && p_49))))
        { /* block id: 46 */
            struct S0 *l_67 = &g_30;
            struct S0 **l_68 = &l_67;
            int32_t l_84 = (-1L);
            int32_t *l_91 = (void*)0;
            (*l_68) = l_67;
            for (l_64 = 12; (l_64 == 43); l_64 += 1)
            { /* block id: 50 */
                uint32_t l_316 = 0UL;
                struct S0 *l_317 = &g_30;
                int32_t *l_327 = (void*)0;
            }
            (*g_109) = (*l_68);
            for (g_3 = 0; (g_3 > (-18)); g_3 -= 1)
            { /* block id: 188 */
                int32_t l_332 = 0L;
                struct S0 **l_370 = &g_110;
                int32_t **l_389 = (void*)0;
                int32_t *****l_393 = &l_391;
                (*l_324) = ((&l_84 != (*g_155)) ^ p_49);
            }
        }
        else
        { /* block id: 215 */
            uint16_t l_408 = 0x39B3L;
            int32_t l_409 = 1L;
            (*l_324) = (*g_236);
            l_409 = l_408;
        }
    }
    for (g_319.f2 = 24; (g_319.f2 > 39); g_319.f2++)
    { /* block id: 222 */
        const uint8_t l_419 = 6UL;
        struct S0 **l_420 = &g_110;
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_134
 * writes: g_134
 */
inline static int64_t  func_75(uint16_t  p_76, uint32_t  p_77, uint8_t  p_78)
{ /* block id: 170 */
    uint8_t l_321 = 0x3BL;
    int32_t *l_322 = &g_134;
    (*l_322) = l_321;
    return g_134;
}


/* ------------------------------------------ */
/* 
 * reads : g_63 g_3 g_134 g_254 g_255 g_182
 * writes: g_156
 */
inline static uint32_t  func_85(uint32_t  p_86, int32_t * p_87, int32_t  p_88, int64_t  p_89, struct S0 * p_90)
{ /* block id: 162 */
    int32_t l_295 = 0x7B99C51BL;
    int32_t l_314 = 0xE3CE139AL;
    uint64_t l_315 = 18446744073709551615UL;
    if (__builtin_clz(l_295))
    { /* block id: 163 */
        struct S0 ***l_306 = (void*)0;
        int32_t l_309 = 0x17F35A23L;
        l_314 = ((uint8_t)l_295 >> (uint8_t)((uint8_t)((uint32_t)(((uint8_t)g_63 * (uint8_t)(((uint32_t)(l_306 != ((((int8_t)(-1L) - (int8_t)l_309) <= (((uint32_t)__builtin_ia32_crc32qi(((uint64_t)__builtin_bswap64(p_86) + (uint64_t)l_309), p_88) % (uint32_t)9UL) > 255UL)) , (void*)0)) % (uint32_t)l_309) == 0x75F8L)) , 0x82947E04L) - (uint32_t)0x8659274AL) - (uint8_t)g_134));
        (***g_254) = &l_309;
    }
    else
    { /* block id: 166 */
        return l_315;
    }
    return p_88;
}


/* ------------------------------------------ */
/* 
 * reads : g_109 g_111 g_30.f3 g_30.f0 g_110 g_30.f2 g_30.f1 g_63 g_134 g_30 g_3 g_150 g_155 g_189 g_237 g_244 g_247 g_250 g_254 g_256 g_255 g_182 g_266 g_156 g_153 g_236
 * writes: g_63 g_111 g_153 g_156 g_134 g_30.f0 g_254
 */
inline static const int8_t  func_94(struct S0 ** p_95)
{ /* block id: 52 */
    int8_t l_108 = 0xFBL;
    int32_t **l_285 = &g_111;
    int32_t ***l_284 = &l_285;
    struct S0 ***l_290 = &g_109;
    struct S0 **l_291 = &g_110;
    uint32_t l_292 = 5UL;
    int32_t l_293 = 0x2B6956E6L;
    (*g_236) = ((func_97(func_100(((uint64_t)l_108 % (uint64_t)l_108), g_109, l_108, p_95, g_111), l_108) , (*g_109)) == (void*)0);
    l_293 = (((int8_t)(((l_284 != &l_285) > ((uint16_t)(l_108 <= ((uint16_t)(func_100(((l_108 < g_63) < (l_290 == (void*)0)), l_291, g_134, p_95, (**l_284)) , 1UL) >> (uint16_t)g_3)) * (uint16_t)l_108)) , l_292) << (int8_t)g_30.f0) < g_3);
    return g_30.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_250 g_30.f0 g_254 g_256 g_255 g_182 g_266 g_237 g_156 g_153 g_109 g_110 g_30
 * writes: g_111 g_30.f0 g_254 g_156 g_134
 */
static struct S0  func_97(const int32_t  p_98, const uint64_t  p_99)
{ /* block id: 140 */
    int32_t *l_249 = (void*)0;
    int16_t l_251 = 0xBBA2L;
    int32_t l_263 = 0x8FB19411L;
    (*g_250) = l_249;
    l_251 = p_98;
    for (g_30.f0 = 8; (g_30.f0 == (-24)); --g_30.f0)
    { /* block id: 145 */
        int32_t l_257 = 6L;
        struct S0 **l_262 = (void*)0;
        uint64_t l_279 = 5UL;
        (*g_256) = g_254;
        if (l_257)
        { /* block id: 147 */
            uint16_t l_260 = 1UL;
            int32_t *l_264 = (void*)0;
            l_263 = ((uint64_t)l_260 + (uint64_t)(((0xBBA08E5EL | l_251) > (((!((void*)0 != &g_254)) , __builtin_ctzll(l_260)) == p_99)) == p_99));
            (**g_255) = &p_98;
            (*g_266) = l_260;
            l_279 = ((((uint8_t)((0x945770A4L | (l_257 & 0x78988055L)) == 0xB2L) << (uint8_t)((uint16_t)((uint16_t)1UL * (uint16_t)((int16_t)((int64_t)((l_257 == (**g_237)) == ((int8_t)((0x8222L >= (p_98 >= l_257)) | 0x59L) * (int8_t)p_99)) + (int64_t)p_99) << (int16_t)10)) << (uint16_t)p_99)) , (**g_153)) != (void*)0);
        }
        else
        { /* block id: 152 */
            int8_t l_280 = 0L;
            int32_t *l_281 = &g_134;
            (**g_255) = &p_98;
            (*l_281) = l_280;
            (*l_281) = ((*g_254) != (void*)0);
        }
    }
    return (**g_109);
}


/* ------------------------------------------ */
/* 
 * reads : g_30.f3 g_30.f0 g_109 g_110 g_30.f2 g_30.f1 g_63 g_134 g_30 g_3 g_150 g_155 g_189 g_237 g_244 g_247
 * writes: g_63 g_111 g_153 g_156 g_134
 */
static int32_t  func_100(const int32_t  p_101, struct S0 ** p_102, int16_t  p_103, struct S0 ** p_104, int32_t * p_105)
{ /* block id: 53 */
    uint32_t l_127 = 0UL;
    int32_t l_131 = 0x16D66C25L;
    int32_t *l_132 = (void*)0;
    int32_t **l_173 = &g_111;
    const int32_t *l_176 = &g_134;
    uint32_t l_195 = 4294967292UL;
    const int16_t l_242 = 1L;
    int32_t ***l_245 = (void*)0;
    int32_t ***l_246 = &l_173;
    int32_t l_248 = 0x74089B94L;
    if ((((int8_t)(((int16_t)((int16_t)(p_101 , ((int8_t)((-(int16_t)p_103) || (g_30.f3 == ((uint16_t)((((int8_t)g_30.f0 * (int8_t)p_103) | ((((uint32_t)0x1D34D3BEL + (uint32_t)l_127) < (((~((uint64_t)((void*)0 == (*g_109)) + (uint64_t)0xE4714FE20FE05587LL)) ^ l_131) , p_103)) & l_127)) != 0x7FL) * (uint16_t)g_30.f2))) % (int8_t)g_30.f1)) << (int16_t)8) + (int16_t)65532UL) , p_103) << (int8_t)l_131) ^ l_131))
    { /* block id: 54 */
        const int32_t *l_133 = &g_134;
        int32_t l_135 = 0x699391FDL;
        int32_t l_136 = 0xABE1F69FL;
        int8_t l_145 = 0L;
        int64_t l_149 = 0x7EA9C8C9C88BE142LL;
        struct S0 ***l_167 = &g_109;
        int32_t l_188 = (-1L);
        int32_t l_225 = (-10L);
        l_135 = ((g_63 , l_132) != l_133);
        if (g_30.f1)
        { /* block id: 56 */
            struct S0 *l_139 = (void*)0;
            int64_t l_144 = 0xAC02D6B031E64C26LL;
            struct S0 ***l_152 = &g_109;
            g_63 = l_136;
            if (((((int64_t)((l_139 != (g_134 , (*p_102))) < ((&p_101 != ((((uint16_t)65532UL * (uint16_t)(((**g_109) , (g_3 | ((((uint8_t)__builtin_bswap64(p_103) >> (uint8_t)l_144) <= 1L) < l_144))) , g_30.f1)) , 0L) , l_132)) <= 5L)) + (int64_t)p_101) && 0x2309139EL) , l_145))
            { /* block id: 58 */
                int32_t *l_148 = &l_136;
                const int32_t **l_154 = &l_133;
                (*l_148) = ((int16_t)g_30.f3 % (int16_t)(-1L));
                if (l_145)
                    goto lbl_151;
lbl_151:
                (*g_150) = (l_149 , &l_135);
                g_153 = l_152;
                (*l_154) = &p_101;
            }
            else
            { /* block id: 64 */
                (*g_150) = (void*)0;
            }
            (*g_155) = &p_101;
            p_105 = l_132;
        }
        else
        { /* block id: 69 */
            uint32_t l_161 = 0x45EC307DL;
            int32_t l_179 = 1L;
            uint32_t l_180 = 0x8E39048CL;
            int32_t ***l_185 = &l_173;
            uint32_t l_207 = 0x46911956L;
            uint64_t l_226 = 7UL;
            for (l_131 = 0; (l_131 < (-26)); l_131 -= 1)
            { /* block id: 72 */
                const int32_t *l_159 = &l_136;
                const int32_t **l_160 = &l_159;
                (*l_160) = l_159;
                return l_161;
            }
        }
        (*g_189) = (*l_133);
        (*g_237) = &p_101;
    }
    else
    { /* block id: 133 */
        uint32_t l_243 = 0xE5E66213L;
        (*g_155) = &p_101;
        (*g_244) = ((int16_t)g_63 * (int16_t)(g_3 == ((uint16_t)p_101 * (uint16_t)(((p_101 , __builtin_clzl((p_101 != p_103))) > ((((*l_176) || (*l_176)) != 1L) != l_242)) == l_243))));
    }
    (*l_246) = (void*)0;
    (*g_247) = (g_3 ^ __builtin_popcount(g_3));
    return l_248;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_30.f0, "g_30.f0", print_hash_value);
    transparent_crc(g_30.f1, "g_30.f1", print_hash_value);
    transparent_crc(g_30.f2, "g_30.f2", print_hash_value);
    transparent_crc(g_30.f3, "g_30.f3", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_134, "g_134", print_hash_value);
    transparent_crc(g_319.f0, "g_319.f0", print_hash_value);
    transparent_crc(g_319.f1, "g_319.f1", print_hash_value);
    transparent_crc(g_319.f2, "g_319.f2", print_hash_value);
    transparent_crc(g_319.f3, "g_319.f3", print_hash_value);
    transparent_crc(g_355, "g_355", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 152
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 41, occurrence: 1

XXX total number of pointers: 124

XXX times a variable address is taken: 117
XXX times a pointer is dereferenced on RHS: 84
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 14
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 89
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 14
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 442

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 272
   level: 2, occurrence: 74
   level: 3, occurrence: 35
   level: 4, occurrence: 18
   level: 5, occurrence: 14
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 12
XXX percent of pointers has null in alias set: 29.8
XXX average alias set size: 1.21

XXX times a non-volatile is read: 636
XXX times a non-volatile is write: 221
XXX times a volatile is read: 44
XXX    times read thru a pointer: 3
XXX times a volatile is write: 44
XXX    times written thru a pointer: 20
XXX times a volatile is available for access: 248
XXX percentage of non-volatile access: 90.7

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 18
   depth: 2, occurrence: 26
   depth: 3, occurrence: 18
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
********************* end of statistics **********************/

