/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      645683544
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint16_t  f1;
   int16_t  f2;
   int64_t  f3;
   int64_t  f4;
   const float  f5;
   uint32_t  f6;
   uint32_t  f7;
   const float  f8;
};

struct S1 {
   uint64_t  f0;
   uint64_t  f1;
};

struct S2 {
   uint8_t  f0;
   uint16_t  f1;
   uint64_t  f2;
   int32_t  f3;
   uint8_t  f4;
   float  f5;
   const int32_t  f6;
   uint32_t  f7;
   const uint8_t  f8;
};

union U3 {
   uint32_t  f0;
   uint32_t  f1;
   int32_t  f2;
};

union U4 {
   uint32_t  f0;
   const uint16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   int64_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_33(void);
inline static int32_t  func_34(int32_t  p_35, int64_t  p_36);
inline static int64_t  func_38(struct S0  p_39, const struct S1  p_40);
inline static struct S1  func_42(int32_t  p_43, int16_t  p_44, struct S0  p_45);
inline static uint32_t  func_51(union U3  p_52, struct S0  p_53);
static union U3  func_54(int16_t  p_55, int64_t  p_56, const int16_t  p_57, uint32_t  p_58);
static int32_t * func_60(uint16_t  p_61);
static float  func_81(uint8_t  p_82, int64_t  p_83, float  p_84, float  p_85);
inline static uint8_t  func_86(union U3  p_87, uint16_t  p_88, struct S0  p_89, int32_t  p_90, uint8_t  p_91);
static int64_t  func_94(union U3  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_33(void)
{ /* block id: 36 */
    uint64_t l_37 = 0xF7B1466AC3A60813LL;
    struct S0 l_41 = {18446744073709551615UL,4UL,-1L,0x645487972E7EB665LL,0xF093D7F285F402BELL,0x9.5p-1,4294967286UL,5UL,0x2.7B4D2Cp-89};
    uint64_t l_59 = 0xED3351F4A1AB7048LL;
    union U3 l_319 = {18446744073709551615UL};
    const uint64_t l_322 = 0xF4A2D3D38F9BDD79LL;
    float l_325 = 0x1.D07611p+58;
    int32_t *l_339 = (void*)0;
    struct S0 *l_347 = &l_41;
    struct S0 **l_346 = &l_347;
    union U4 l_375 = {0x021F33E9L};
    union U4 *l_374 = &l_375;
    int64_t l_380 = 0L;
    struct S2 l_401 = {0xADL,0UL,0x01FA34B627779FA1LL,0x66EDB2B0L,0x23L,0x2.6p-1,0x46557EADL,0x09399532L,1UL};
    struct S2 *l_400 = &l_401;
    struct S1 l_428 = {0xCD96559237EF3F9CLL,0xC5CBC6346BD332B8LL};
    struct S1 *l_427 = &l_428;
    struct S1 **l_426 = &l_427;
    struct S1 ***l_425 = &l_426;
    struct S1 **** const l_424 = &l_425;
    uint64_t l_445 = 0x88BC74710C580E44LL;
    uint32_t l_459 = 4294967295UL;
    int16_t l_473 = 1L;
    union U3 l_508 = {0x0F63CC25L};
    const struct S2 *l_522 = (void*)0;
    int32_t **l_555 = (void*)0;
    int32_t ***l_554 = &l_555;
    struct S2 * const **l_561 = (void*)0;
    uint32_t l_567 = 0x462DF318L;
    union U3 l_598 = {0xC6F82B4DL};
    const uint32_t l_609 = 0x52D0B4CBL;
    int64_t l_610 = 0x1C6EBD82BBA5C051LL;
    uint32_t l_611 = 0x012FC3BEL;
    uint16_t l_612 = 0UL;
    uint64_t l_613 = 3UL;
    if (func_34(l_37, (l_37 | func_38(l_41, func_42((safe_rshift_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u(l_41.f6, l_41.f2)), (+((func_51(func_54(l_41.f1, l_41.f3, l_41.f1, (l_59 && 0x4411L)), l_41) ^ l_37) && l_41.f7)))), l_37, l_41)))))
    { /* block id: 194 */
        struct S0 l_320 = {2UL,0x7116L,0x58D0L,-1L,-1L,0xB.5570C8p-32,0x0382C805L,0xA5AF9E53L,0x3.B62CF2p+85};
        const int64_t l_326 = 8L;
        struct S1 l_328 = {0x8844DFC33572A64BLL,0x8E8E59E138D61C2ELL};
        struct S1 *l_327 = &l_328;
        struct S2 l_333 = {0xD3L,0UL,0UL,7L,255UL,0x5.C4384Ep+34,0x4FC59C9FL,0x5A341899L,0xA5L};
        struct S2 *l_332 = &l_333;
        struct S2 **l_331 = &l_332;
        struct S2 ***l_330 = &l_331;
        struct S2 ****l_329 = &l_330;
        int32_t l_336 = 0L;
        int32_t *l_335 = &l_336;
        int32_t **l_334 = &l_335;
        int32_t l_337 = 1L;
        int32_t l_352 = 0xCE96DD3BL;
        uint32_t l_387 = 0x02C7A5C5L;
        struct S1 **l_411 = &l_327;
        struct S1 ***l_410 = &l_411;
        struct S1 ****l_409 = &l_410;
        uint64_t l_437 = 0x2D7324796A68E759LL;
        uint32_t l_444 = 0xF0C64A28L;
        uint32_t l_467 = 0UL;
        uint64_t l_490 = 18446744073709551615UL;
        uint8_t l_517 = 0UL;
        union U4 *l_539 = &l_375;
        union U3 l_568 = {0x38126FFDL};
        struct S0 ***l_577 = &l_346;
        const int64_t l_582 = 0xAEB0EC205DFD9B37LL;
        (*l_327) = func_42((safe_lshift_func_int16_t_s_s(func_51(func_54((((safe_add_func_int32_t_s_s(func_51(l_319, l_320), (+__builtin_popcountll((l_41.f7 <= l_322))))) || l_322) | (safe_add_func_int16_t_s_s(func_86(func_54(l_37, l_320.f2, l_320.f4, l_319.f2), l_320.f2, l_41, l_320.f6, l_41.f6), 0x6590L))), l_59, l_326, l_320.f1), l_41), 7)), l_41.f7, l_41);
        (*l_329) = (void*)0;
        (*l_334) = func_60(l_333.f4);
        if (__builtin_clzl(l_337))
        { /* block id: 198 */
            uint64_t l_342 = 1UL;
            int32_t l_343 = 3L;
            struct S0 *l_344 = (void*)0;
            int32_t *l_359 = &l_343;
            union U4 ** const l_367 = (void*)0;
            union U4 l_378 = {8UL};
            union U4 *l_377 = &l_378;
            struct S2 ** const * const l_389 = &l_331;
            if ((+(l_319.f0 & l_333.f1)))
            { /* block id: 199 */
                l_339 = l_339;
                l_343 = (safe_mod_func_int64_t_s_s(l_342, (-5L)));
            }
            else
            { /* block id: 202 */
                struct S0 **l_345 = &l_344;
                float *l_348 = (void*)0;
                float *l_349 = &l_333.f5;
                (*l_345) = l_344;
                (*l_349) = (l_346 == l_345);
                return l_41.f7;
            }
            if (l_343)
            { /* block id: 207 */
                uint16_t l_357 = 0x2B60L;
                int32_t l_372 = 0xB379C0B1L;
                float *l_373 = &l_333.f5;
                for (l_320.f4 = 0; (l_320.f4 <= 14); ++l_320.f4)
                { /* block id: 210 */
                    if (l_352)
                        break;
                }
                for (l_41.f2 = (-1); (l_41.f2 != 1); l_41.f2++)
                { /* block id: 215 */
                    int32_t l_358 = 5L;
                    for (l_319.f0 = (-17); (l_319.f0 < 55); ++l_319.f0)
                    { /* block id: 218 */
                        (*l_334) = (*l_334);
                    }
                    if (l_357)
                    { /* block id: 221 */
                        (*l_334) = func_60(l_358);
                    }
                    else
                    { /* block id: 223 */
                        float l_364 = 0x5.209F7Cp+90;
                        int32_t l_365 = 0x53ABEA12L;
                        union U4 **l_366 = (void*)0;
                        l_359 = (void*)0;
                        l_358 = (safe_add_func_float_f_f(__builtin_popcountl((l_357 & (safe_sub_func_int64_t_s_s(__builtin_bswap64(l_358), ((((__builtin_ctzll((l_365 || l_358)) >= (l_366 != l_367)) || (safe_sub_func_int16_t_s_s((l_358 > 0x4CA984D77968AAB9LL), l_358))) > l_365) < l_358))))), l_365));
                    }
                }
                l_372 = (safe_mod_func_int64_t_s_s(l_352, l_333.f1));
                (*l_373) = (&l_347 != &l_347);
            }
            else
            { /* block id: 230 */
                union U4 **l_376 = (void*)0;
                int32_t l_388 = 0x49A6F945L;
                struct S2 ***l_390 = &l_331;
                float *l_391 = &l_333.f5;
                struct S0 l_394 = {0xE3472C88L,0x9B70L,1L,0xDD6318096DA207F8LL,-1L,-0x1.2p+1,0x3242E564L,0UL,0x2.Cp+1};
                const struct S1 l_417 = {0x61BF074DAA309246LL,4UL};
                l_377 = l_374;
                (*l_391) = (((+0x7.E2BCA4p-65) >= __builtin_ffs(__builtin_clzll(l_380))) >= (safe_add_func_float_f_f((safe_add_func_float_f_f((0x7.0p+1 < (safe_add_func_float_f_f(l_387, (l_388 >= ((__builtin_parityll((l_389 == l_390)) <= 0x5.DB5E4Ep+28) > 0x1.Ap-1))))), 0x3.66E59Ap-16)), l_388)));
                if ((safe_sub_func_int64_t_s_s(func_38(l_394, (*l_327)), l_394.f2)))
                { /* block id: 233 */
                    (*l_334) = l_339;
                }
                else
                { /* block id: 235 */
                    union U3 l_402 = {18446744073709551615UL};
                    if ((*l_359))
                    { /* block id: 236 */
                        const uint8_t l_397 = 1UL;
                        struct S0 l_403 = {0x0BA9720EL,0xE5ECL,0xE385L,0x3E33FAE959DB557BLL,0L,0x1.1p-1,1UL,5UL,0x0.Bp-1};
                        int32_t l_404 = 9L;
                        struct S1 **l_405 = &l_327;
                        struct S1 ***l_406 = &l_405;
                        (*l_391) = (((safe_add_func_float_f_f(__builtin_popcountll((*l_359)), l_397)) >= (((((safe_sub_func_float_f_f(l_394.f4, ((void*)0 != l_400))) > __builtin_clzl((0x1D87F689L <= func_51(l_402, l_403)))) <= l_403.f3) <= 0x0.4p-1) >= (*l_359))) < l_403.f1);
                        l_404 = (0x0CE8L || l_402.f0);
                        (*l_391) = 0x0.B39038p-33;
                        (*l_406) = l_405;
                    }
                    else
                    { /* block id: 241 */
                        int64_t l_412 = (-1L);
                        uint8_t l_416 = 0x5DL;
                        int32_t l_431 = 0x32C23461L;
                        (*l_359) = ((l_402.f2 < (((safe_sub_func_int32_t_s_s((((void*)0 == l_409) > (l_394.f4 != 0x7D85DBEBL)), ((0x5C55L | l_412) ^ ((safe_sub_func_uint32_t_u_u(0x7E2D96D4L, ((((safe_unary_minus_func_uint64_t_u((l_412 >= l_416))) <= l_402.f2) || (*l_359)) ^ 0xC820B1F87285B826LL))) | l_388)))) > 0x9A9FL) >= (-3L))) ^ 1UL);
                        (*l_327) = l_417;
                        (*l_359) = (((-9L) || (((safe_rshift_func_uint16_t_u_s(((*l_359) < (safe_add_func_uint64_t_u_u((safe_sub_func_int32_t_s_s(((void*)0 != l_424), ((*l_359) >= (((safe_rshift_func_int16_t_s_s(func_34(l_402.f1, (*l_359)), ((l_416 <= l_394.f3) < l_394.f1))) || l_402.f2) || l_431)))), 0x4876D71B7427DB5CLL))), l_412)) && l_412) == (*l_359))) & l_416);
                        (*l_334) = func_60((*l_359));
                    }
                    (*l_334) = (void*)0;
                    return l_402.f1;
                }
            }
        }
        else
        { /* block id: 251 */
            union U4 **l_434 = &l_374;
            union U4 ***l_433 = &l_434;
            union U4 ****l_432 = &l_433;
            uint64_t l_443 = 0UL;
            struct S2 * const l_463 = &l_333;
            uint64_t l_472 = 0UL;
            struct S1 *l_492 = &l_428;
            struct S2 ****l_495 = &l_330;
            int32_t l_502 = 0x40D96EB0L;
            struct S0 l_509 = {0x4228D920L,0x6DBDL,-9L,-1L,0L,0x6.08B6E8p+52,0x42AC63BEL,0x127158A5L,0xF.57B2B4p+10};
            uint8_t l_548 = 0x06L;
            int16_t l_550 = 0x2094L;
            const struct S1 l_551 = {0x51528A50D8690CB9LL,0x59092F2680E70EC2LL};
            l_432 = (void*)0;
            (*l_334) = func_60(((safe_rshift_func_uint16_t_u_u(__builtin_popcount(l_437), (safe_add_func_uint64_t_u_u(((safe_add_func_int16_t_s_s(((+l_443) || l_443), l_443)) ^ func_86(l_319, ((l_339 == l_339) | l_401.f8), l_320, l_444, l_443)), l_443)))) < l_443));
            if (func_51(func_54(l_443, l_445, l_443, l_443), (**l_346)))
            { /* block id: 254 */
                return l_443;
            }
            else
            { /* block id: 256 */
                float l_446 = 0x3.9DF437p+71;
                int32_t l_449 = 0x1C60C0C0L;
                struct S0 *l_457 = &l_320;
                union U4 * const *l_462 = (void*)0;
                union U4 * const **l_461 = &l_462;
                struct S2 l_465 = {255UL,1UL,0xEA2E9DD434D3A08BLL,0x0AEB04C0L,5UL,-0x1.2p-1,0L,0x6E186F4EL,0x48L};
                struct S2 *l_464 = &l_465;
                if ((__builtin_ia32_crc32qi(l_443, l_443) | (safe_sub_func_int64_t_s_s(l_443, (l_449 >= l_443)))))
                { /* block id: 257 */
                    int32_t l_450 = 0xC8DF442AL;
                    l_450 = l_449;
                }
                else
                { /* block id: 259 */
                    uint32_t l_458 = 0x749B941BL;
                    float *l_460 = &l_446;
                    (*l_460) = (safe_add_func_float_f_f(0xA.85C877p-74, ((l_449 < (0xF.6C518Bp-23 == __builtin_parityl(l_449))) >= (safe_sub_func_float_f_f(((safe_sub_func_float_f_f((l_457 == (void*)0), (func_81(l_443, l_458, l_443, l_459) <= l_443))) != (-0x9.Dp+1)), l_449)))));
                }
                if (((void*)0 == l_461))
                { /* block id: 262 */
                    float l_476 = (-0x5.Ep+1);
                    struct S0 l_477 = {18446744073709551610UL,0x66EBL,0xEA5EL,0xC05423A454D9FA69LL,0x16ED7927356551CFLL,0x0.8p+1,0x3F1D0265L,0x9EE26C2DL,0x1.5p-1};
                    if (__builtin_popcount(l_443))
                    { /* block id: 263 */
                        return l_449;
                    }
                    else
                    { /* block id: 265 */
                        uint32_t l_466 = 0xB70C7615L;
                        l_464 = l_463;
                        (*l_346) = l_457;
                        (**l_411) = func_42((l_466 >= 0x116B153CL), (l_467 & (safe_rshift_func_uint16_t_u_u(l_465.f6, __builtin_ffsll((safe_sub_func_int64_t_s_s(l_472, (l_465.f3 || (((l_473 == (safe_add_func_uint64_t_u_u(l_465.f8, l_466))) | l_466) == 0x9E0FF025628F3874LL)))))))), l_477);
                    }
                    (****l_409) = func_42(l_477.f0, l_59, l_477);
                }
                else
                { /* block id: 271 */
                    float *l_478 = &l_401.f5;
                    int32_t l_483 = 5L;
                    (*l_478) = l_472;
                    (***l_425) = func_42(l_465.f0, (safe_add_func_int32_t_s_s((safe_add_func_int16_t_s_s(func_34(l_472, (((l_449 ^ ((-8L) <= l_483)) | (safe_add_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(l_472, ((safe_rshift_func_int16_t_s_u(func_86(l_319, l_465.f4, (*l_457), l_483, l_465.f8), 12)) ^ l_401.f1))), l_465.f7))) >= 0x0E8AC800L)), l_483)), 1UL)), l_320);
                }
                if (l_490)
                { /* block id: 275 */
                    struct S0 l_491 = {0x5EEDD2B8L,0xD812L,0xBC73L,0x653B0071A631D278LL,-2L,0x4.8C3755p+28,0xACE0F4FEL,5UL,-0x1.6p-1};
                    (****l_424) = (**l_411);
                    (*l_327) = func_42((&l_425 != &l_410), l_472, l_491);
                    l_492 = l_492;
                    l_449 = (safe_rshift_func_uint16_t_u_s(((void*)0 != &l_425), 8));
                }
                else
                { /* block id: 280 */
                    (*l_334) = (void*)0;
                }
                (**l_410) = l_492;
            }
            if (l_443)
            { /* block id: 285 */
                struct S0 **l_500 = &l_347;
                int32_t l_503 = 0x76F203C2L;
                struct S1 ***l_510 = &l_426;
                union U3 l_511 = {0xE58A54B1L};
                int64_t l_513 = 0x3211514C04C149F1LL;
                int32_t *l_521 = &l_502;
                if ((l_495 != (void*)0))
                { /* block id: 286 */
                    for (l_333.f7 = 0; (l_333.f7 <= 43); ++l_333.f7)
                    { /* block id: 289 */
                        struct S1 * const l_498 = &l_328;
                        const struct S1 **l_499 = (void*)0;
                        l_492 = l_498;
                    }
                }
                else
                { /* block id: 292 */
                    uint32_t l_501 = 0xCA1F2D75L;
                    struct S1 *l_506 = &l_428;
                    struct S0 l_512 = {18446744073709551614UL,0UL,0L,0xC3A3B31FDA103C6BLL,9L,0x8.A3299Ep-7,0x9FAC7718L,6UL,0x1.3p+1};
                    union U3 l_518 = {0x391E9E2EL};
                    l_502 = (((void*)0 == l_500) & l_501);
                    if ((__builtin_bswap64(l_501) > __builtin_bswap32(l_503)))
                    { /* block id: 294 */
                        int32_t *l_504 = &l_336;
                        float *l_505 = &l_333.f5;
                        (*l_504) = 0xB9B0D887L;
                        (**l_433) = &l_375;
                        (*l_505) = ((*l_504) == l_501);
                    }
                    else
                    { /* block id: 298 */
                        int32_t *l_507 = &l_502;
                        l_506 = (***l_424);
                        (*l_507) = l_501;
                        (*l_506) = func_42((*l_507), func_51(l_508, l_509), l_320);
                        (****l_409) = (*l_492);
                    }
                    if (((l_510 == (void*)0) > (func_86(l_511, l_509.f1, l_512, (l_428.f0 || (l_511.f0 | (l_512.f0 | l_509.f0))), l_513) != l_512.f1)))
                    { /* block id: 304 */
                        struct S1 ***l_514 = &l_411;
                        (*l_492) = func_42(l_502, l_509.f7, l_320);
                        l_503 = (l_514 != (void*)0);
                    }
                    else
                    { /* block id: 307 */
                        struct S2 **l_523 = &l_332;
                        (**l_426) = func_42(l_443, l_401.f6, (**l_500));
                        l_521 = func_60(func_86(l_511, (safe_mod_func_uint64_t_u_u(l_517, func_94(l_518))), l_512, (safe_lshift_func_int16_t_s_u(0L, 7)), l_509.f0));
                        (*l_523) = l_522;
                    }
                    (*l_506) = func_42(l_502, l_509.f1, l_512);
                }
            }
            else
            { /* block id: 314 */
                int32_t l_524 = 0L;
                int32_t ***l_556 = &l_555;
                struct S2 ***l_562 = &l_331;
                union U3 l_566 = {0xAB5EB85CL};
                struct S0 l_579 = {0xE4B62A37L,0x7406L,0xEB6CL,0xD49DC7950D2E7379LL,0x73BE726E5963A6ACLL,-0x6.Ap-1,0xFD9D4AC8L,4294967295UL,0x6.CBA623p+19};
                if (__builtin_popcountl(l_524))
                { /* block id: 315 */
                    const int16_t l_533 = 1L;
                    int32_t *l_534 = &l_336;
                    union U3 l_549 = {18446744073709551608UL};
                    (*l_534) = (((safe_sub_func_uint64_t_u_u(l_443, ((safe_mod_func_int32_t_s_s((safe_add_func_uint64_t_u_u(((safe_mod_func_int64_t_s_s(l_533, (l_533 | __builtin_clz((l_533 >= (((void*)0 != l_534) >= (safe_sub_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_u(0x1AA6L, (l_524 > ((void*)0 != l_539)))), l_524)))))))) <= 0x2FFCF27CL), l_524)), (*l_534))) & l_509.f6))) < l_509.f3) | 1UL);
                    (*l_334) = func_60(l_472);
                    l_534 = &l_502;
                    (*l_534) = (safe_lshift_func_uint16_t_u_u(l_524, (safe_mod_func_uint64_t_u_u((((*l_534) != ((safe_mod_func_int64_t_s_s((safe_lshift_func_uint16_t_u_u(l_548, 8)), l_509.f1)) ^ ((((*l_534) && func_86(l_549, (*l_534), l_320, l_550, l_443)) < l_524) & 0x6297C236B1BB0430LL))) != l_443), (*l_534)))));
                }
                else
                { /* block id: 320 */
                    int32_t *l_552 = &l_502;
                    struct S1 l_553 = {1UL,0x9189EAB94F431ACDLL};
                    (****l_409) = l_551;
                    l_552 = (*l_334);
                    (*l_492) = l_553;
                }
                l_556 = l_554;
                for (l_333.f4 = 0; (l_333.f4 != 58); l_333.f4++)
                { /* block id: 328 */
                    int16_t l_563 = 1L;
                    const uint16_t l_569 = 0x168DL;
                    int32_t *l_570 = (void*)0;
                    int32_t *l_571 = &l_352;
                    struct S2 *l_572 = &l_401;
                    union U4 ****l_576 = &l_433;
                    struct S0 ***l_578 = (void*)0;
                    (*l_571) = ((safe_add_func_int64_t_s_s((l_561 == l_562), l_563)) && (safe_lshift_func_int16_t_s_u((((func_94(l_566) ^ (l_566.f2 <= l_567)) < (func_86(l_568, l_563, l_320, l_563, l_563) & l_569)) == l_551.f1), 7)));
                    (*l_331) = l_572;
                    (*l_571) = (safe_add_func_uint32_t_u_u((!(&l_433 == l_576)), (0x3DA0F1B8DFB3080ELL && 0xB6419F0363A8CA5ELL)));
                    l_578 = l_577;
                }
                (**l_411) = func_42(func_38(l_579, (****l_424)), (safe_rshift_func_uint16_t_u_s(l_582, 2)), l_509);
            }
        }
    }
    else
    { /* block id: 337 */
        struct S1 *l_585 = &l_428;
        int32_t l_589 = 1L;
        int32_t *l_588 = &l_589;
        for (l_59 = 16; (l_59 < 25); l_59 = safe_add_func_int16_t_s_s(l_59, 9))
        { /* block id: 340 */
            int32_t l_587 = 0xE7C898E8L;
            int32_t *l_586 = &l_587;
            (**l_425) = l_585;
            l_588 = l_586;
        }
        l_588 = (void*)0;
    }
    (*l_427) = func_42((safe_sub_func_uint32_t_u_u((l_41.f3 && (safe_lshift_func_uint16_t_u_s(l_59, (safe_lshift_func_uint16_t_u_u(l_428.f0, (safe_add_func_uint16_t_u_u((((l_41.f2 <= func_86(l_598, (safe_lshift_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((safe_add_func_uint32_t_u_u(l_473, (safe_lshift_func_uint16_t_u_u((l_375.f0 | (safe_add_func_uint16_t_u_u(l_401.f2, ((l_380 ^ l_609) | 0x0A40L)))), 5)))), l_610)), 13)), l_41, l_598.f0, l_611)) > l_401.f4) & 18446744073709551615UL), (-2L)))))))), 4294967295UL)), l_612, l_41);
    return l_613;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(int32_t  p_35, int64_t  p_36)
{ /* block id: 173 */
    struct S1 l_289 = {0UL,18446744073709551611UL};
    struct S1 *l_290 = (void*)0;
    struct S1 l_297 = {0x49A9B351D39479D9LL,0UL};
    struct S0 l_312 = {0x7E9D353CL,0x452AL,8L,-6L,0xD4C3E8A82FDAFAECLL,0x7.1p+1,0x1B74DEAFL,6UL,0xB.9A496Bp+99};
    int32_t l_314 = 0x4AC12D3BL;
    int32_t *l_313 = &l_314;
    l_289 = l_289;
    for (l_289.f1 = 27; (l_289.f1 != 35); l_289.f1 = safe_add_func_int64_t_s_s(l_289.f1, 4))
    { /* block id: 177 */
        struct S1 *l_293 = (void*)0;
        struct S1 l_296 = {8UL,18446744073709551610UL};
        int32_t **l_298 = (void*)0;
        int32_t **l_299 = (void*)0;
        int32_t l_302 = (-1L);
        int32_t *l_301 = &l_302;
        int32_t **l_300 = &l_301;
        if ((1UL >= p_35))
        { /* block id: 178 */
            struct S1 l_295 = {0x7F3A2DD5C52C7789LL,0x5770ADE47298B66DLL};
            struct S1 *l_294 = &l_295;
            l_294 = l_293;
            l_297 = l_296;
        }
        else
        { /* block id: 181 */
            if (p_36)
                break;
            return l_289.f1;
        }
        (*l_300) = func_60(l_296.f1);
    }
    if (((7UL || l_297.f1) || 0xEDF2L))
    { /* block id: 187 */
        int16_t l_303 = 0x27C9L;
        int32_t l_305 = 8L;
        int32_t *l_304 = &l_305;
        (*l_304) = l_303;
    }
    else
    { /* block id: 189 */
        int32_t l_307 = 0xF0752AFEL;
        int32_t *l_306 = &l_307;
        (*l_306) = p_35;
    }
    (*l_313) = (0xC6A78CF5L > (((func_51(func_54(p_36, p_36, (p_35 == (p_35 | (safe_mod_func_uint16_t_u_u(l_289.f0, __builtin_ctz(p_36))))), (((safe_sub_func_uint32_t_u_u(l_297.f0, 0x220F7FBAL)) >= 0x3FD0BA7A7D87469CLL) && p_36)), l_312) > 0xBA26975CEA956860LL) > p_36) ^ p_36));
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_38(struct S0  p_39, const struct S1  p_40)
{ /* block id: 71 */
    int32_t l_136 = 0xDB762060L;
    const int32_t * const l_135 = &l_136;
    union U3 l_137 = {0x8C1B616BL};
    int32_t *l_171 = &l_136;
    uint32_t l_177 = 0xF75C09CCL;
    union U4 l_185 = {4294967287UL};
    union U4 *l_184 = &l_185;
    union U4 **l_221 = &l_184;
    union U4 *** const l_220 = &l_221;
    struct S1 * const l_246 = (void*)0;
    struct S2 *l_275 = (void*)0;
    int32_t **l_283 = (void*)0;
    int32_t **l_284 = &l_171;
    const uint64_t l_287 = 18446744073709551613UL;
    int32_t *l_288 = &l_136;
    if ((safe_add_func_uint16_t_u_u((((l_135 == &l_136) ^ p_39.f1) ^ func_86(l_137, p_39.f7, p_39, (*l_135), (*l_135))), 7UL)))
    { /* block id: 72 */
        struct S1 *l_140 = (void*)0;
        struct S1 **l_139 = &l_140;
        struct S1 ***l_138 = &l_139;
        int32_t *l_144 = &l_136;
        int32_t **l_143 = &l_144;
        union U4 l_183 = {1UL};
        union U4 *l_182 = &l_183;
        if ((0UL > p_39.f0))
        { /* block id: 73 */
            struct S1 ****l_141 = &l_138;
            int32_t *l_142 = &l_136;
            (*l_141) = l_138;
            (*l_142) = p_39.f6;
            (*l_144) = (((l_143 != &l_142) ^ 0xAFE8A4A7E502840ALL) ^ __builtin_ctzll(((-2L) || (*l_142))));
            (*l_143) = (*l_143);
        }
        else
        { /* block id: 78 */
            struct S1 l_146 = {1UL,0x8AE1307C177FA41FLL};
            struct S1 *l_145 = &l_146;
            int32_t l_163 = (-3L);
            int32_t *l_169 = (void*)0;
            union U4 l_181 = {1UL};
            union U4 *l_180 = &l_181;
            float *l_191 = (void*)0;
            float l_193 = 0x7.3p+1;
            float *l_192 = &l_193;
            (*l_145) = p_40;
            for (p_39.f1 = 0; (p_39.f1 < 11); p_39.f1 = safe_add_func_int64_t_s_s(p_39.f1, 1))
            { /* block id: 82 */
                const int64_t l_159 = (-7L);
                float l_162 = (-0x5.1p+1);
                float *l_161 = &l_162;
                if (p_39.f7)
                    break;
            }
            (*l_192) = ((l_182 == l_184) == ((safe_sub_func_float_f_f(p_40.f1, (**l_143))) > (+(safe_add_func_float_f_f(0x6.5p+1, (-0x1.9p-1))))));
        }
        return p_39.f4;
    }
    else
    { /* block id: 115 */
        int32_t l_198 = (-1L);
        struct S1 l_226 = {0xBA6E25E85E3D3FF8LL,9UL};
        struct S1 *l_225 = &l_226;
        struct S1 **l_224 = &l_225;
        union U4 ***l_265 = &l_221;
        uint64_t l_268 = 0x451DF1B9022DA0C8LL;
        int32_t *l_269 = &l_136;
        struct S2 l_277 = {0xD8L,0xE965L,0UL,0xC0DFE4C1L,0UL,0x6.DEA131p-24,1L,0xADBA9351L,0xBAL};
        struct S2 *l_276 = &l_277;
        for (p_39.f2 = (-19); (p_39.f2 == (-17)); p_39.f2 = safe_add_func_int16_t_s_s(p_39.f2, 4))
        { /* block id: 118 */
            int16_t l_199 = (-1L);
            union U4 **l_208 = &l_184;
            float l_215 = 0x5.88AC7Ep-21;
            union U3 l_237 = {0UL};
            struct S2 l_248 = {2UL,0UL,0x697B8A6DA849F534LL,-3L,1UL,-0x2.Bp-1,-8L,0UL,0x2CL};
            struct S2 *l_247 = &l_248;
            (*l_171) = (safe_lshift_func_int16_t_s_u(((l_198 != 0x7DB3L) & l_199), ((safe_sub_func_int64_t_s_s(((*l_135) & (safe_mod_func_int32_t_s_s((((p_39.f2 && (safe_add_func_int64_t_s_s(p_39.f7, (safe_lshift_func_uint16_t_u_s((l_208 != (void*)0), ((safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s(l_198, p_40.f0)), 9)), (*l_135))) || l_198)))))) | p_39.f1) && 0xC25799EF2C490428LL), 1UL))), p_40.f0)) | (-1L))));
            for (l_185.f3 = (-28); (l_185.f3 < (-20)); l_185.f3 = safe_add_func_int64_t_s_s(l_185.f3, 6))
            { /* block id: 122 */
                uint16_t l_233 = 0x8088L;
                int32_t *l_251 = (void*)0;
                struct S1 l_274 = {18446744073709551615UL,0x5C18B874153CC621LL};
            }
        }
        for (l_277.f4 = (-27); (l_277.f4 >= 45); l_277.f4 = safe_add_func_uint16_t_u_u(l_277.f4, 2))
        { /* block id: 163 */
            int32_t *l_280 = &l_136;
            int32_t **l_281 = &l_280;
            struct S1 ***l_282 = (void*)0;
            (*l_281) = l_280;
            if ((*l_280))
                break;
            l_282 = (void*)0;
            (*l_281) = func_60(p_39.f3);
        }
    }
    (*l_284) = func_60((*l_171));
    (*l_288) = ((safe_lshift_func_int16_t_s_u((p_39.f1 == p_40.f1), 8)) != l_287);
    return p_39.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_42(int32_t  p_43, int16_t  p_44, struct S0  p_45)
{ /* block id: 69 */
    struct S1 l_132 = {9UL,18446744073709551615UL};
    return l_132;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_51(union U3  p_52, struct S0  p_53)
{ /* block id: 42 */
    int16_t l_78 = 0xE839L;
    union U3 l_92 = {0UL};
    struct S0 l_93 = {3UL,0xBF01L,0xE2F9L,0xBC330632420D6CD4LL,0xB9DA0115B503A71BLL,0xF.ACDC9Fp-27,4294967287UL,0x43C7198FL,0xA.05BB7Ep-87};
    union U3 l_96 = {0UL};
    float l_131 = 0x6.50EE72p+77;
    float *l_130 = &l_131;
    (*l_130) = (safe_add_func_float_f_f(l_78, (0xF.91505Fp+30 > (safe_add_func_float_f_f(p_53.f0, func_81(func_86(l_92, p_52.f2, l_93, p_53.f2, (func_94(l_96) >= 1UL)), l_93.f4, p_53.f7, l_96.f2))))));
    return l_93.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U3  func_54(int16_t  p_55, int64_t  p_56, const int16_t  p_57, uint32_t  p_58)
{ /* block id: 37 */
    int32_t l_67 = 0xB14BE569L;
    const int32_t *l_66 = &l_67;
    int32_t *l_74 = &l_67;
    int32_t **l_73 = &l_74;
    union U3 l_75 = {0x5FBD26DAL};
    (*l_73) = func_60((((0x581CA9286DF497A8LL >= (p_55 <= ((p_57 || 1UL) > __builtin_popcountll(((safe_rshift_func_uint16_t_u_u(((l_66 == &l_67) >= (((safe_add_func_int64_t_s_s(p_58, 9L)) && __builtin_bswap64((*l_66))) != p_55)), 6)) < (*l_66)))))) | 0x8880L) > p_56));
    return l_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_60(uint16_t  p_61)
{ /* block id: 38 */
    int32_t l_71 = (-1L);
    int32_t *l_70 = &l_71;
    int32_t *l_72 = (void*)0;
    return l_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_81(uint8_t  p_82, int64_t  p_83, float  p_84, float  p_85)
{ /* block id: 64 */
    struct S1 l_127 = {0x7F86792DBF0B25D9LL,0UL};
    struct S1 *l_126 = &l_127;
    float l_129 = 0xF.99B5C0p-95;
    float *l_128 = &l_129;
    (*l_128) = (safe_add_func_float_f_f((l_126 == &l_127), l_127.f0));
    return l_127.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_86(union U3  p_87, uint16_t  p_88, struct S0  p_89, int32_t  p_90, uint8_t  p_91)
{ /* block id: 46 */
    uint64_t l_101 = 18446744073709551615UL;
    uint8_t l_102 = 251UL;
    uint32_t l_103 = 18446744073709551615UL;
    struct S1 l_110 = {0xB86B6EF1402E7910LL,8UL};
    int32_t l_116 = 0xC1309E20L;
    int32_t *l_115 = &l_116;
    struct S1 *l_123 = &l_110;
    struct S1 **l_122 = &l_123;
    if ((safe_mod_func_int64_t_s_s((l_101 < l_101), func_94(func_54(l_102, l_103, l_103, l_102)))))
    { /* block id: 47 */
        uint32_t l_104 = 0x41811343L;
        struct S1 l_106 = {0UL,0xD54F57EB90776C57LL};
        int32_t **l_121 = &l_115;
        l_104 = 0x1.2p+1;
        if ((!p_89.f6))
        { /* block id: 49 */
            struct S1 *l_107 = &l_106;
            (*l_107) = l_106;
            return l_106.f0;
        }
        else
        { /* block id: 52 */
            int32_t l_109 = 0xD5741E93L;
            int32_t *l_108 = &l_109;
            struct S1 *l_111 = &l_110;
            int32_t **l_112 = &l_108;
            (*l_108) = p_89.f6;
            (*l_111) = l_110;
            (*l_112) = &l_109;
            (*l_115) = (safe_add_func_uint64_t_u_u(0xDDB278982BF9DFF4LL, (6UL < (((*l_112) != l_115) | (safe_lshift_func_uint16_t_u_s((safe_add_func_uint64_t_u_u(__builtin_parityll((*l_115)), (*l_108))), 8))))));
        }
        l_121 = l_121;
    }
    else
    { /* block id: 59 */
        return p_87.f2;
    }
    (*l_122) = &l_110;
    return p_89.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_94(union U3  p_95)
{ /* block id: 43 */
    struct S1 l_97 = {0x64F5E99A55AEF273LL,8UL};
    struct S1 *l_98 = &l_97;
    (*l_98) = l_97;
    return p_95.f1;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 181
   depth: 1, occurrence: 24
XXX total union variables: 16

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 188
   depth: 2, occurrence: 33
   depth: 3, occurrence: 4
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
   depth: 6, occurrence: 4
   depth: 7, occurrence: 2
   depth: 8, occurrence: 2
   depth: 10, occurrence: 2
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 4
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 146

XXX times a variable address is taken: 137
XXX times a pointer is dereferenced on RHS: 47
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 93
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 7
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 315

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 140
   level: 2, occurrence: 55
   level: 3, occurrence: 21
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 65
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 30
XXX percent of pointers has null in alias set: 30.8
XXX average alias set size: 1.18

XXX times a non-volatile is read: 634
XXX times a non-volatile is write: 257
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 160
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 18
   depth: 2, occurrence: 31
   depth: 3, occurrence: 23
   depth: 4, occurrence: 34
   depth: 5, occurrence: 29

XXX percentage a fresh-made variable is used: 28.4
XXX percentage an existing variable is used: 71.6
********************* end of statistics **********************/

