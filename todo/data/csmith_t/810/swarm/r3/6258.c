/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      184120094
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 29;
   signed f1 : 30;
   unsigned f2 : 8;
   signed f3 : 20;
};

union U1 {
   uint16_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   uint16_t  f3;
   int32_t  f4;
};

union U2 {
   int32_t  f0;
   const uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_34(void);
static struct S0  func_35(int16_t  p_36);
static int32_t  func_45(int16_t  p_46, int32_t  p_47);
static union U1  func_52(int32_t  p_53, uint16_t  p_54, uint32_t  p_55, uint16_t  p_56);
static uint32_t  func_57(int32_t  p_58, uint32_t  p_59, int16_t  p_60, union U1  p_61, uint16_t  p_62);
static struct S0  func_65(uint32_t  p_66, union U1  p_67, const uint32_t  p_68, struct S0  p_69);
static union U1  func_71(uint32_t  p_72, int32_t  p_73);
static int16_t  func_75(struct S0  p_76, int32_t  p_77, union U2  p_78);
static const struct S0  func_79(int32_t  p_80);
static int32_t  func_84(int32_t  p_85, int32_t  p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_34(void)
{ /* block id: 36 */
    int32_t l_41 = (-5);
    uint32_t l_63 = 4294967295U;
    union U1 l_64 = {0xCB0B};
    struct S0 l_202 = {6434,-22489,1,-641};
    const uint32_t l_212 = 0xDBFCDDE5;
    const uint32_t l_225 = 0xFE65D847;
    int32_t l_226 = 1;
    union U2 l_270 = {1};
    int32_t l_296 = 0x30DEAA8D;
    uint16_t l_327 = 0xC095;
    const uint16_t l_387 = 65531U;
    int16_t l_391 = (-7);
    int32_t l_447 = 0xD6141241;
    int16_t l_457 = 0;
    uint16_t l_490 = 65529U;
    uint16_t l_491 = 65529U;
    int16_t l_492 = 0xFF64;
    l_202 = func_35(((int32_t)((int32_t)l_41 + (int32_t)(-(int32_t)(((uint16_t)l_41 + (uint16_t)5) != func_45(l_41, l_41)))) + (int32_t)(0xD711A53F | ((uint16_t)(~(((func_52((func_57(l_41, (func_45(((func_45(l_41, l_63) | l_41) == l_41), l_41) ^ l_41), l_63, l_64, l_63) >= l_64.f3), l_41, l_63, l_41) , l_64.f0) == l_64.f3) < l_41)) + (uint16_t)l_41))));
    for (l_64.f2 = (-30); (l_64.f2 != 19); l_64.f2 += 7)
    { /* block id: 94 */
        int32_t l_205 = 8;
        l_202 = (l_64.f4 , func_79(l_205));
        for (l_41 = 0; (l_41 < (-16)); l_41 -= 1)
        { /* block id: 98 */
            if (l_202.f1)
                break;
            l_202 = l_202;
        }
        l_202.f3 = (((int16_t)__builtin_ctz(((uint16_t)(l_212 , (__builtin_parity((((((uint16_t)((uint32_t)((l_64 , (l_64.f3 & ((uint32_t)(((((int32_t)((((int16_t)((int32_t)(func_71(l_64.f1, l_205) , l_205) - (int32_t)l_205) << (int16_t)5) & l_225) || l_205) % (int32_t)l_41) & 0x6FFE) && 65535U) < 9U) + (uint32_t)l_64.f0))) != 1) + (uint32_t)l_205) >> (uint16_t)l_63) ^ (-1)) , l_212) , 0xEDC91CA6)) <= l_226)) % (uint16_t)0xDF3F)) >> (int16_t)l_205) & l_202.f3);
    }
    for (l_63 = 21; (l_63 >= 49); l_63 += 1)
    { /* block id: 106 */
        uint32_t l_233 = 0x8E0E80E6;
        uint16_t l_244 = 5U;
        int32_t l_245 = 0x0E6EDD9A;
        l_245 = ((l_202 , ((uint16_t)(((__builtin_clzl((65528U < (((uint16_t)(((l_233 < ((uint32_t)(func_45((__builtin_parityll((((~(l_233 != ((0xE7210429 >= (0xE207 == (l_233 <= l_233))) < ((int16_t)(((int16_t)((((int16_t)(!l_244) % (int16_t)l_244) != l_212) < 4294967289U) >> (int16_t)4) > l_202.f1) >> (int16_t)10)))) , l_202.f2) & 0xF2CDD3E7)) >= 0x1C24B065), l_244) || 1) % (uint32_t)l_202.f1)) | 0U) >= 0U) << (uint16_t)l_64.f1) , 0x87C9))) >= l_233) , l_202.f1) | 0U) % (uint16_t)l_233)) && 4);
        if (l_64.f0)
            break;
        l_245 = l_202.f3;
    }
    if (l_64.f2)
    { /* block id: 111 */
        const int32_t l_251 = 0xB32C21BF;
        int32_t l_261 = 1;
        struct S0 l_275 = {-17355,-31479,10,-615};
        int32_t l_276 = 1;
        int32_t l_277 = 5;
        int32_t l_299 = 1;
        uint32_t l_325 = 4294967295U;
        int32_t l_377 = 0x3005CFBD;
        int32_t l_384 = (-1);
        uint16_t l_388 = 0x1689;
        struct S0 l_423 = {-14941,6879,5,-993};
        struct S0 l_467 = {2872,2994,7,832};
lbl_421:
        for (l_64.f0 = 0; (l_64.f0 < 32); l_64.f0 += 1)
        { /* block id: 114 */
            uint16_t l_250 = 0x4F59;
            union U1 l_260 = {0x7E70};
            struct S0 l_269 = {15367,-532,8,988};
            l_261 = func_57((l_225 != (((int32_t)0xC1FA4A3D - (int32_t)0) || (l_250 != (l_202.f3 > (l_251 || ((func_57(l_250, l_202.f2, ((((uint16_t)((uint32_t)((uint16_t)((uint16_t)(l_202.f2 , l_64.f3) + (uint16_t)l_64.f3) << (uint16_t)l_202.f0) - (uint32_t)l_202.f3) >> (uint16_t)l_250) <= l_202.f3) , 0), l_260, l_260.f3) , l_260) , 1U)))))), l_202.f1, l_250, l_64, l_202.f0);
            if (l_251)
                break;
            l_269.f3 = ((l_260.f0 == (((int32_t)((uint16_t)(0x3EAC ^ (-10)) + (uint16_t)(+((int16_t)(((1U >= l_251) ^ (0 == 1U)) | (l_269 , l_251)) >> (int16_t)l_260.f3))) % (int32_t)4294967289U) | l_202.f3)) == l_251);
        }
        l_202.f0 = (l_270 , ((int16_t)((uint16_t)(((func_65(l_63, func_71((l_275 , l_212), l_212), l_41, l_202) , l_275.f0) , l_276) >= l_277) << (uint16_t)15) + (int16_t)l_276));
        for (l_276 = (-25); (l_276 > 6); l_276 += 2)
        { /* block id: 122 */
            uint32_t l_293 = 0U;
            struct S0 l_297 = {10205,19063,7,112};
            if (l_276)
            { /* block id: 123 */
                uint32_t l_288 = 0U;
                struct S0 l_298 = {19904,7329,15,163};
                l_202.f1 = (((uint16_t)((uint16_t)((int16_t)((l_275.f1 || (((((uint32_t)(l_277 , ((0x5037 && l_288) ^ (-4))) - (uint32_t)(l_288 & (((uint16_t)(l_202.f2 , (l_288 > (-1))) + (uint16_t)0xC657) , 65534U))) | 0xCAC8) >= l_275.f0) != 0x9923A281)) < 0x5BA7D9BF) - (int16_t)0x2F68) + (uint16_t)l_270.f1) >> (uint16_t)l_275.f3) || l_275.f0);
                l_275 = ((((((uint32_t)__builtin_popcountl(l_293) + (uint32_t)l_288) | l_202.f1) , 4294967289U) <= l_226) , func_35(((((l_270 , (l_296 == l_202.f2)) & 0) <= l_275.f1) <= l_275.f3)));
                l_298 = l_297;
            }
            else
            { /* block id: 127 */
                l_261 = ((-1) >= l_299);
                return l_202.f2;
            }
        }
        if (l_275.f3)
        { /* block id: 132 */
            int16_t l_308 = 0x67DA;
            union U2 l_333 = {1};
            union U1 l_334 = {65527U};
            const int16_t l_335 = 9;
            int32_t l_357 = (-1);
            union U1 l_361 = {0U};
            for (l_296 = 0; (l_296 < 5); l_296 += 1)
            { /* block id: 135 */
                int16_t l_309 = 0x4E71;
                union U1 l_328 = {0x2E22};
                for (l_64.f3 = 15; (l_64.f3 < 60); l_64.f3 += 2)
                { /* block id: 138 */
                    uint32_t l_326 = 4294967290U;
                    int32_t l_329 = 0x9B55ACEF;
                    l_329 = (((((int16_t)(((uint16_t)l_212 >> (uint16_t)15) & l_308) >> (int16_t)14) || l_309) < (((((int16_t)((uint16_t)((((int16_t)(-(int32_t)((uint16_t)func_57(((l_275.f3 , ((((int16_t)0xDB8F + (int16_t)__builtin_bswap32(l_308)) || func_84(((((int16_t)(((int16_t)l_309 + (int16_t)1U) | 0x6B61) - (int16_t)l_225) < l_202.f1) != l_325), l_63)) & l_326)) >= l_309), l_327, l_308, l_328, l_275.f3) - (uint16_t)4U)) >> (int16_t)1) | l_226) != l_328.f3) - (uint16_t)0x261C) << (int16_t)5) || 0U) && 0x8467) & l_212)) >= l_308);
                }
            }
            if (((func_45(l_308, l_202.f0) > (l_202.f1 && ((+(((l_308 == ((l_333 , func_57(l_333.f1, (func_45((((l_334 , 0x2EB4) != l_251) < l_335), l_333.f0) != l_296), l_275.f2, l_334, l_270.f0)) & l_251)) >= l_277) > 0xC2859998)) < l_333.f0))) ^ l_335))
            { /* block id: 142 */
                l_276 = l_333.f1;
            }
            else
            { /* block id: 144 */
                const uint16_t l_347 = 65527U;
                uint32_t l_356 = 0x48865426;
                l_261 = l_64.f0;
                if (((((int16_t)((int32_t)(!(((uint16_t)l_334.f3 >> (uint16_t)9) , ((((((uint16_t)((uint16_t)0xC7AE - (uint16_t)l_347) % (uint16_t)l_325) < l_334.f0) | ((uint16_t)((int32_t)func_57(l_275.f0, __builtin_popcountll((((((uint32_t)(l_333.f1 <= __builtin_ia32_crc32qi(l_347, ((int32_t)(-6) % (int32_t)l_335))) % (uint32_t)1U) > l_225) != 0x16861AB3) , l_275.f2)), l_202.f0, l_64, l_356) - (int32_t)l_333.f0) >> (uint16_t)l_333.f0)) , l_356) , l_270.f1))) + (int32_t)0x0B42B693) << (int16_t)l_275.f3) > l_299) ^ l_347))
                { /* block id: 146 */
                    l_357 = 0x9CA4ECB6;
                }
                else
                { /* block id: 148 */
                    for (l_327 = 0; (l_327 < 22); l_327 += 1)
                    { /* block id: 151 */
                        uint32_t l_360 = 0x11742DD1;
                        return l_360;
                    }
                    if (l_270.f1)
                        goto lbl_366;
                }
            }
lbl_366:
            l_299 = (l_361 , (l_202.f2 <= (0x5F08 || ((int32_t)(((l_296 != (((l_361.f0 != (l_296 >= l_334.f3)) != (((int16_t)l_41 + (int16_t)(l_202 , l_333.f0)) & 0)) <= 0U)) <= 0U) , (-1)) - (int32_t)l_202.f0))));
            for (l_334.f0 = 0; (l_334.f0 <= 45); l_334.f0 += 7)
            { /* block id: 160 */
                uint32_t l_371 = 4294967295U;
                int32_t l_376 = 0x9305815C;
                struct S0 l_378 = {12445,-9042,12,396};
                l_202.f0 = ((int16_t)(__builtin_bswap64(l_202.f0) > l_371) >> (int16_t)((((((int32_t)l_277 + (int32_t)(func_84(l_325, func_45((((int16_t)1 << (int16_t)l_202.f0) ^ l_296), l_376)) , l_275.f2)) != l_202.f3) && l_377) , l_378) , 0x7500));
                l_202 = l_275;
                l_275.f1 = l_334.f3;
                l_357 = (((!((uint16_t)0U * (uint16_t)(func_45(l_276, (((int16_t)((l_384 ^ ((uint16_t)(func_45(l_357, l_334.f0) && (l_334.f3 ^ l_361.f0)) + (uint16_t)l_378.f0)) < 0x94B7FE14) >> (int16_t)5) || 0xB1C9B85E)) <= l_64.f0))) <= 1U) < l_387);
            }
        }
        else
        { /* block id: 166 */
            int32_t l_400 = 0x72BEE661;
            int32_t l_409 = 0;
            uint16_t l_417 = 0xD2AC;
            struct S0 l_422 = {-9953,-1241,15,558};
            if (__builtin_ctzll(((l_388 || __builtin_ctz(((int16_t)0x41AB + (int16_t)func_45(l_391, l_388)))) | (((int16_t)((int32_t)((((int32_t)0xD80AE462 % (int32_t)((uint16_t)((l_400 & ((uint16_t)((int16_t)(((uint16_t)((((((uint16_t)(l_64.f0 & l_275.f0) + (uint16_t)l_270.f1) , l_391) > 0xA12F2140) != l_275.f1) == (-5)) << (uint16_t)l_384) , l_409) << (int16_t)l_388) >> (uint16_t)l_277)) != l_409) << (uint16_t)2)) ^ l_384) == 0xA5BF75F0) % (int32_t)l_202.f1) << (int16_t)13) ^ 0xE4F7))))
            { /* block id: 167 */
                int32_t l_413 = 0x58FC8657;
                uint32_t l_416 = 0xAD91B2CF;
                struct S0 l_429 = {17983,11250,11,-967};
                for (l_261 = (-16); (l_261 <= 25); l_261 += 1)
                { /* block id: 170 */
                    int32_t l_412 = 0x5CA9C594;
                    if ((l_412 < (l_413 , (l_64 , (((uint16_t)((l_409 , ((l_416 , l_417) || l_64.f0)) | ((+((l_400 <= (((uint16_t)((__builtin_popcountl(l_409) , l_202.f2) || l_391) - (uint16_t)l_377) >= 0x416E9E66)) & l_413)) == l_327)) + (uint16_t)0xE807) | l_63)))))
                    { /* block id: 171 */
                        if (l_327)
                            goto lbl_421;
                        if (l_413)
                            break;
                        l_423 = l_422;
                        if (l_423.f2)
                            continue;
                    }
                    else
                    { /* block id: 176 */
                        int32_t l_426 = 0;
                        l_41 = ((uint16_t)(l_416 || l_426) << (uint16_t)(l_275.f2 & ((uint16_t)l_202.f0 >> (uint16_t)4)));
                    }
                    l_202.f0 = (l_202 , l_422.f3);
                }
                l_296 = __builtin_ffsll(((l_226 && l_422.f3) & l_41));
                l_429 = l_202;
                l_261 = func_45(l_422.f0, l_416);
            }
            else
            { /* block id: 184 */
                int32_t l_446 = 7;
                union U2 l_454 = {0xBAD744F6};
                l_423.f0 = ((!__builtin_ctzll(((int16_t)0xF274 << (int16_t)((uint32_t)((((uint16_t)((~__builtin_bswap64(__builtin_ctzll(l_261))) | (((l_417 != __builtin_parityll(__builtin_popcountll((((int32_t)((int16_t)(!l_422.f2) - (int16_t)(((((~((int16_t)(__builtin_ffsll(l_446) && l_422.f2) << (int16_t)6)) && l_446) < l_422.f1) <= l_447) && l_422.f0)) % (int32_t)0x46948929) == l_446)))) , l_446) , l_446)) << (uint16_t)1) >= 0x829056F2) & l_270.f1) + (uint32_t)l_261)))) == l_202.f0);
                l_423.f1 = ((uint16_t)((int16_t)((int16_t)func_75(l_422, l_409, l_454) % (int16_t)(func_45(((int32_t)l_327 + (int32_t)l_388), l_457) , func_84(l_391, l_276))) - (int16_t)l_270.f0) % (uint16_t)(-1));
                l_422.f1 = (((uint32_t)l_446 % (uint32_t)(l_423.f2 | ((((((~__builtin_parity(l_377)) || l_226) >= (l_447 < ((uint32_t)l_400 - (uint32_t)l_275.f0))) < ((uint16_t)0x4836 + (uint16_t)0xAC75)) & l_454.f0) != l_225))) , 2);
            }
            for (l_400 = (-21); (l_400 != (-16)); l_400 += 1)
            { /* block id: 191 */
                int32_t l_468 = (-10);
                l_467 = l_422;
                l_467.f1 = ((l_468 || ((((l_457 > ((0x93328005 && ((uint16_t)((func_75(l_467, (l_409 && (l_202.f2 <= ((l_275.f3 != ((int16_t)(+l_468) % (int16_t)((uint16_t)(((int16_t)l_468 - (int16_t)(-1)) < 65529U) % (uint16_t)l_467.f1))) | 0xCF16))), l_270) | 1) & l_212) >> (uint16_t)6)) ^ l_468)) < (-1)) , l_251) || l_422.f3)) && 0xCF90);
                if (l_277)
                    break;
            }
            return l_422.f0;
        }
    }
    else
    { /* block id: 198 */
        uint32_t l_478 = 6U;
        union U1 l_489 = {8U};
        l_492 = (__builtin_ctz(l_478) ^ ((((int16_t)(((((l_225 > (((uint16_t)(((uint16_t)4U >> (uint16_t)14) || l_478) % (uint16_t)l_447) || l_202.f0)) & (((uint16_t)(((int16_t)0x7EDF >> (int16_t)13) , (((l_489 , l_478) & l_489.f3) && 0x17344577)) << (uint16_t)l_489.f3) >= 0xB8A4CC51)) , l_225) > l_490) > 4294967291U) >> (int16_t)l_491) >= l_478) & l_478));
    }
    return l_212;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_35(int16_t  p_36)
{ /* block id: 69 */
    int16_t l_145 = 2;
    struct S0 l_150 = {9323,-32554,6,671};
    uint32_t l_151 = 0x75ADD045;
    int32_t l_154 = 0x1666784C;
    uint16_t l_184 = 0x8E95;
    union U1 l_199 = {65535U};
    if (((int16_t)(p_36 > ((p_36 <= ((((int16_t)l_145 << (int16_t)7) > (((((int16_t)((int32_t)((l_150 , ((func_52((0xEFA3 > l_145), l_150.f0, l_151, ((int16_t)l_150.f3 - (int16_t)(-5))) , 4) < l_145)) & l_150.f3) % (int32_t)p_36) + (int16_t)p_36) | 4294967289U) & p_36) >= l_150.f3)) != p_36)) == l_154)) - (int16_t)0x05A1))
    { /* block id: 70 */
        uint32_t l_158 = 0U;
        int32_t l_160 = 0x0BB3AF78;
        for (l_154 = 0; (l_154 != 18); l_154 += 9)
        { /* block id: 73 */
            uint32_t l_159 = 0x9F1547C5;
            l_159 = (~l_158);
            l_160 = l_154;
        }
    }
    else
    { /* block id: 77 */
        uint16_t l_165 = 0x2CBC;
        struct S0 l_169 = {-11320,20803,5,854};
        union U1 l_181 = {0x4042};
        const int16_t l_200 = 0;
        for (p_36 = 0; (p_36 != (-1)); p_36 -= 1)
        { /* block id: 80 */
            uint32_t l_168 = 0x77A17B2D;
            struct S0 l_170 = {-22038,-13373,12,-739};
            uint32_t l_177 = 4294967291U;
            union U1 l_185 = {0xE3D4};
            struct S0 l_201 = {-5427,12215,1,-837};
            l_170 = func_65(p_36, func_71(((uint32_t)l_165 % (uint32_t)(4294967291U && p_36)), p_36), l_165, (((int32_t)(__builtin_ctz((p_36 > ((func_52(p_36, p_36, p_36, l_168) , p_36) , l_165))) | l_165) - (int32_t)0U) , l_169));
            for (l_154 = (-3); (l_154 != (-13)); l_154 -= 5)
            { /* block id: 84 */
                uint16_t l_178 = 65533U;
                int32_t l_186 = 0;
                l_186 = ((p_36 , ((int16_t)((uint16_t)((l_177 >= (l_178 , ((l_169.f3 | ((func_45(((((func_79(((int16_t)func_57(((p_36 & ((((((l_181 , (p_36 || ((int32_t)l_170.f2 - (int32_t)0))) <= l_170.f3) != p_36) != l_184) >= l_169.f0) , l_181.f0)) , p_36), p_36, l_150.f1, l_185, p_36) >> (int16_t)10)) , 0x2441) , 0x7A1E) , l_178) <= 0x0BB9802B), l_169.f0) , l_169.f1) && l_165)) || p_36))) && l_165) + (uint16_t)l_178) - (int16_t)65531U)) && p_36);
            }
            l_201 = func_65(p_36, (((int16_t)((int16_t)((((p_36 <= ((uint16_t)func_57(p_36, (p_36 | (((int32_t)l_168 % (int32_t)(((((int16_t)0x3B62 + (int16_t)__builtin_ctzll(((uint32_t)0xAA03C2B8 % (uint32_t)l_154))) | l_150.f3) , l_150.f3) || 0xF336)) || 0x288FB31F)), p_36, l_199, l_169.f3) >> (uint16_t)l_150.f1)) | l_165) >= 0x45C73037) < p_36) % (int16_t)p_36) << (int16_t)12) , l_181), l_200, l_169);
        }
    }
    return l_150;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_45(int16_t  p_46, int32_t  p_47)
{ /* block id: 37 */
    int32_t l_48 = (-1);
    return l_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_52(int32_t  p_53, uint16_t  p_54, uint32_t  p_55, uint16_t  p_56)
{ /* block id: 64 */
    int32_t l_132 = 4;
    union U1 l_133 = {0x0370};
    struct S0 l_137 = {-18893,30552,12,434};
    uint16_t l_140 = 0xBE3D;
    l_137.f0 = ((func_65(l_132, l_133, ((-(int32_t)(+(!l_133.f0))) != (l_132 & l_132)), l_137) , (((+((((0xB3E6A653 <= ((!l_140) | p_53)) , l_133.f3) ^ p_55) <= 0xA972)) , l_132) || l_137.f3)) , l_137.f0);
    l_137.f3 = l_133.f0;
    l_137 = l_137;
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_57(int32_t  p_58, uint32_t  p_59, int16_t  p_60, union U1  p_61, uint16_t  p_62)
{ /* block id: 39 */
    uint16_t l_70 = 0x4356;
    int16_t l_74 = 0xF47A;
    struct S0 l_128 = {10464,-3842,2,-336};
    l_128 = func_65(l_70, func_71(l_74, l_70), (!0xB81D3E15), l_128);
    return p_61.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_65(uint32_t  p_66, union U1  p_67, const uint32_t  p_68, struct S0  p_69)
{ /* block id: 59 */
    uint32_t l_129 = 0xE7BC92A3;
    int32_t l_130 = 0;
    struct S0 l_131 = {-10716,11829,13,1010};
    l_130 = (l_129 , p_68);
    return l_131;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_71(uint32_t  p_72, int32_t  p_73)
{ /* block id: 40 */
    int32_t l_81 = (-10);
    uint32_t l_90 = 0x1E611887;
    int32_t l_91 = 0x43A495B2;
    struct S0 l_93 = {-20732,-12201,5,985};
    union U2 l_94 = {0x63C96AAD};
    union U1 l_126 = {0xF66B};
    l_81 = (func_75((func_79(func_45(l_81, (((uint16_t)((func_84(p_72, p_73) | ((((uint32_t)(l_90 >= __builtin_popcountl(l_90)) % (uint32_t)((l_81 , p_72) , p_73)) & 1) > l_91)) | l_81) >> (uint16_t)p_72) ^ l_81))) , l_93), p_73, l_94) ^ l_93.f2);
    l_81 = ((((((int16_t)(0xA06974D8 <= l_94.f0) << (int16_t)2) < p_73) , (p_73 , __builtin_ia32_crc32qi(l_94.f1, ((int32_t)(((uint16_t)((p_72 ^ ((__builtin_ctzll((((-(uint16_t)(((uint16_t)65535U >> (uint16_t)l_90) <= (((((int16_t)(p_72 < 0x48CF4EDB) % (int16_t)(-1)) ^ 1) , l_93) , p_72))) <= p_72) || l_93.f1)) == p_73) < 65528U)) , l_94.f1) << (uint16_t)7) >= p_73) % (int32_t)l_81)))) , 4294967290U) < 8);
    return l_126;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_75(struct S0  p_76, int32_t  p_77, union U2  p_78)
{ /* block id: 45 */
    const int32_t l_102 = 0;
    union U2 l_110 = {0xD18E14F0};
    int32_t l_111 = 0x45F480A8;
    union U1 l_112 = {0U};
    struct S0 l_114 = {-11324,-15297,8,-337};
    for (p_77 = 5; (p_77 == 27); p_77 += 2)
    { /* block id: 48 */
        uint32_t l_97 = 0U;
        l_97 = 0xDDC18638;
        if (p_77)
            goto lbl_113;
    }
    l_111 = (((((uint16_t)1U - (uint16_t)((int16_t)(l_102 > ((uint32_t)((uint16_t)(l_102 , ((int16_t)(!(func_45(l_102, __builtin_ctzl(p_76.f0)) , __builtin_ffsll(((l_110 , l_110.f0) , l_110.f1)))) << (int16_t)13)) + (uint16_t)p_76.f0) + (uint32_t)l_110.f1)) - (int16_t)p_76.f2)) >= (-1)) <= l_102) > p_76.f0);
lbl_113:
    l_111 = ((p_76.f3 , 0xA84720AF) > (l_112 , p_76.f2));
    p_76 = l_114;
    return p_76.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_79(int32_t  p_80)
{ /* block id: 43 */
    const struct S0 l_92 = {7326,-32529,1,430};
    return l_92;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_84(int32_t  p_85, int32_t  p_86)
{ /* block id: 41 */
    uint32_t l_87 = 0U;
    return l_87;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_34();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 109
   depth: 1, occurrence: 20
XXX total union variables: 17

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 14
XXX times a bitfields struct on RHS: 27
XXX times a single bitfield on LHS: 13
XXX times a single bitfield on RHS: 94

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 18
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 13, occurrence: 4
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 3
   depth: 26, occurrence: 2
   depth: 27, occurrence: 3
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 515
XXX times a non-volatile is write: 65
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 95
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 15
   depth: 2, occurrence: 18
   depth: 3, occurrence: 24
   depth: 4, occurrence: 6
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 23.5
XXX percentage an existing variable is used: 76.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

