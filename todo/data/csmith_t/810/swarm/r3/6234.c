/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2507352902
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int32_t  f0;
   int32_t  f1;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_6 = 0x7E8B72FDL;
static int32_t *g_45 = &g_6;
static int32_t **g_44 = &g_45;
static uint8_t g_47 = 0xE0L;
static int32_t **g_48 = &g_45;
static int32_t g_61 = 0x66C146DFL;
static uint32_t g_63 = 0xC19AC4E6L;
static int32_t g_95 = 7L;
static struct S0 g_98 = {0x9D72FAF7L,0x239D1334L};
static struct S0 *g_97 = &g_98;
static struct S0 g_100 = {-1L,-7L};
static int32_t *g_101 = &g_95;
static struct S0 **g_112 = &g_97;
static int32_t g_116 = 0x8AFAEF9AL;
static uint16_t g_135 = 7UL;
static const uint32_t g_174 = 0xF27D3598L;
static int16_t g_193 = 3L;
static uint32_t g_199 = 0x2DB0CE19L;
static uint16_t g_220 = 0x8DE8L;
static uint32_t *g_260 = &g_63;
static uint32_t **g_259 = &g_260;
static uint16_t *g_266 = &g_135;
static uint16_t **g_265 = &g_266;
static uint16_t g_348 = 0UL;
static int16_t g_404 = (-8L);
static int16_t g_408 = 0xA2BFL;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_28(void);
static int32_t * func_33(uint16_t  p_34, const int32_t * p_35, int32_t * p_36, int32_t  p_37);
static int32_t * func_38(uint32_t  p_39, uint32_t  p_40, uint32_t  p_41, uint32_t  p_42, int32_t ** p_43);
static int32_t * func_65(uint32_t  p_66, const uint32_t * p_67);
static int32_t ** func_70(uint32_t  p_71, int32_t ** p_72);
static int16_t  func_74(int32_t ** p_75, struct S0  p_76, int32_t ** p_77);
static int32_t ** func_78(int32_t * p_79, int32_t  p_80);
static int32_t * func_82(uint32_t  p_83, int32_t * p_84);
static int32_t * func_88(uint32_t  p_89);
static const int16_t  func_90(uint16_t  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_44 g_48 g_45 g_47 g_97 g_63 g_61 g_100.f1 g_174 g_259 g_260 g_265 g_266 g_135
 * writes: g_6 g_47 g_48 g_61 g_63 g_95 g_101 g_112 g_116 g_45 g_100.f1 g_193 g_404 g_408 g_98.f1 g_259
 */
static struct S0  func_28(void)
{ /* block id: 36 */
    int32_t *l_30 = &g_6;
    int32_t **l_29 = &l_30;
    uint32_t l_423 = 0UL;
    struct S0 l_426 = {0x3C04D749L,0L};
lbl_425:
    (*l_29) = (void*)0;
    /* statement id: 37 */
    assert (l_30 == 0);
    for (g_6 = 5; (g_6 < (-29)); --g_6)
    { /* block id: 40 */
        int32_t **l_46 = &l_30;
        int32_t l_424 = 0L;
        (*l_29) = (void*)0;
        (*g_44) = func_33(g_6, func_38(g_6, g_6, (g_44 == l_46), (g_47 = g_6), (g_48 = &g_45)), func_65((safe_sub_func_int32_t_s_s(6L, 0xE8F88485L)), l_30), (**g_44));
        /* statement id: 336 */
        //assert (g_101 == dangling);
        l_424 = l_423;
    }
    if (g_63)
        goto lbl_425;
    return l_426;
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_63 g_61 g_100.f1 g_174 g_45 g_6 g_259 g_260 g_44 g_265 g_266 g_135
 * writes: g_45 g_101 g_63 g_61 g_100.f1 g_193 g_404 g_408 g_98.f1 g_259 g_116 g_95
 */
static int32_t * func_33(uint16_t  p_34, const int32_t * p_35, int32_t * p_36, int32_t  p_37)
{ /* block id: 81 */
    const uint8_t l_120 = 255UL;
    int32_t ***l_133 = (void*)0;
    uint8_t l_138 = 0x59L;
    int32_t **l_147 = &g_45;
    struct S0 l_160 = {0x0E1B1DC0L,0x404CF588L};
    uint32_t l_210 = 0UL;
    int32_t *l_212 = &g_116;
    uint16_t ***l_279 = &g_265;
    const uint8_t l_323 = 0xFDL;
    struct S0 **l_361 = &g_97;
    int32_t l_400 = 0xD0E820FAL;
    int32_t *l_422 = &g_6;
    for (p_34 = 0; (p_34 >= 55); p_34 = safe_add_func_int32_t_s_s(p_34, 1))
    { /* block id: 84 */
        int32_t **l_121 = (void*)0;
        int32_t **l_122 = &g_101;
        uint16_t *l_134 = &g_135;
        uint32_t *l_162 = &g_63;
        uint32_t **l_161 = &l_162;
        struct S0 ***l_171 = &g_112;
        int32_t l_280 = 0x9A31C922L;
        uint16_t **l_359 = (void*)0;
        p_37 = l_120;
        (*l_122) = ((*g_48) = &p_37);
        /* statement id: 87 */
        assert (g_45 == &p_37);
        assert (g_101 == &p_37);
    }
    /* facts after for loop */
    assert (g_45 == &p_37 || g_45 == &g_6);
    //assert (g_101 == &p_37 || g_101 == dangling);
    for (g_63 = 1; (g_63 < 34); g_63 = safe_add_func_int16_t_s_s(g_63, 7))
    { /* block id: 309 */
        uint32_t l_393 = 1UL;
        int16_t l_413 = 0x890FL;
        uint32_t ***l_414 = (void*)0;
        uint32_t ***l_415 = (void*)0;
        uint32_t ***l_416 = &g_259;
        int32_t *l_421 = &g_95;
        for (l_138 = 0; (l_138 == 33); ++l_138)
        { /* block id: 312 */
            uint32_t l_399 = 0xDC29D404L;
            int32_t l_405 = 0xB8611599L;
            for (g_61 = 0; (g_61 > (-20)); g_61 = safe_sub_func_uint32_t_u_u(g_61, 4))
            { /* block id: 315 */
                int32_t l_406 = 1L;
                for (g_100.f1 = (-3); (g_100.f1 != (-21)); g_100.f1 = safe_sub_func_uint32_t_u_u(g_100.f1, 6))
                { /* block id: 318 */
                    int32_t l_398 = 3L;
                    int16_t *l_401 = (void*)0;
                    int16_t *l_402 = &g_193;
                    int16_t *l_403 = &g_404;
                    int16_t *l_407 = &g_408;
                    p_37 = __builtin_ffsl((g_98.f1 = ((((*l_407) = (~((safe_rshift_func_uint16_t_u_s(p_34, p_37)) != ((0x4EA3L != ((0x31E5L ^ g_174) ^ (l_405 = (((*l_403) = ((*l_402) = (safe_div_func_uint32_t_u_u((safe_add_func_int32_t_s_s((**g_48), ((!p_37) <= ((l_398 = ((l_393 ^ ((safe_div_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(((*p_35) < (*p_36)), p_34)), p_34)) ^ (-1L))) & 0xE854735EL)) ^ l_399)))), l_400)))) && 0x2397L)))) <= l_406)))) & 0x4DA2L) < (**g_259))));
                    (*g_44) = (*g_48);
                }
            }
            (*g_44) = (*g_48);
        }
        (*l_421) = (safe_mod_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((((p_34 > 0xA27B2922L) | l_413) & (p_36 != g_45)), ((**g_48) >= ((*l_212) = (((*l_416) = &g_260) != (void*)0))))), (safe_mod_func_int32_t_s_s((safe_lshift_func_int16_t_s_u(((*g_260) | (*g_260)), (**g_265))), (**g_48)))));
    }
    return l_422;
    /* statement id: 335 */
    //assert (g_45 == dangling || g_45 == &g_6);
    //assert (g_101 == dangling);
    //assert (func_33_rv == &g_6);
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_45 g_6 g_47 g_44 g_95
 * writes: g_61 g_63
 */
static int32_t * func_38(uint32_t  p_39, uint32_t  p_40, uint32_t  p_41, uint32_t  p_42, int32_t ** p_43)
{ /* block id: 44 */
    uint32_t *l_55 = (void*)0;
    uint32_t *l_56 = (void*)0;
    uint32_t *l_57 = (void*)0;
    uint32_t *l_58 = (void*)0;
    int32_t l_59 = (-4L);
    int32_t l_60 = 0x4E20EEB4L;
    uint32_t *l_62 = &g_63;
    int32_t *l_64 = &l_59;
    (*l_64) = (l_60 = (safe_add_func_int32_t_s_s((**g_48), __builtin_ctzll((p_41 <= ((*l_62) = (0x55E9L >= __builtin_parityl(((safe_div_func_uint32_t_u_u(((l_59 = 0UL) < (g_61 = (((void*)0 != l_57) <= (0x0971CF71L & ((l_60 == 0x3CA30775L) | g_47))))), 0x8962600BL)) | (**g_44))))))))));
    return (*g_44);
    /* statement id: 50 */
    //assert (func_38_rv == &g_6 || func_38_rv == &g_95 || func_38_rv == &l_184);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_6 g_97 g_44
 * writes: g_95 g_101 g_112 g_116
 */
static int32_t * func_65(uint32_t  p_66, const uint32_t * p_67)
{ /* block id: 51 */
    uint32_t l_73 = 0x38BE40E8L;
    int32_t *l_81 = &g_6;
    struct S0 l_109 = {0L,3L};
    int32_t **l_117 = &l_81;
    l_117 = func_70((l_73 <= (__builtin_parityl(p_66) != (((void*)0 == g_45) != func_74(func_78(l_81, p_66), l_109, &g_45)))), &l_81);
    /* statement id: 79 */
    //assert (g_101 == dangling);
    return (*g_44);
    /* statement id: 80 */
    //assert (func_65_rv == &g_6 || func_65_rv == &p_37 || func_65_rv == &l_184);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_95 g_116
 */
static int32_t ** func_70(uint32_t  p_71, int32_t ** p_72)
{ /* block id: 75 */
    int32_t l_113 = 0x5C258348L;
    int32_t *l_114 = &g_95;
    int32_t *l_115 = &g_116;
    (*l_115) = ((*l_114) = (p_71 != (l_113 >= p_71)));
    return p_72;
    /* statement id: 78 */
    //assert (func_70_rv == &l_81 || func_70_rv == &g_45);
}


/* ------------------------------------------ */
/* 
 * reads : g_6
 * writes: g_112
 */
static int16_t  func_74(int32_t ** p_75, struct S0  p_76, int32_t ** p_77)
{ /* block id: 71 */
    struct S0 **l_111 = &g_97;
    struct S0 ***l_110 = &l_111;
    g_112 = ((*l_110) = &g_97);
    return g_6;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_45 g_97 g_44 p_37 l_184
 * writes: g_95 g_101
 */
static int32_t ** func_78(int32_t * p_79, int32_t  p_80)
{ /* block id: 52 */
    uint32_t l_87 = 4UL;
    int32_t l_92 = 0xE8A086CCL;
    int32_t **l_105 = (void*)0;
    int32_t **l_106 = &g_101;
    int32_t **l_108 = &g_101;
lbl_107:
    (*l_106) = func_82((safe_mod_func_int32_t_s_s((l_87 = (*p_79)), 4294967288UL)), func_88((0xAAE7L <= ((func_90((((__builtin_parity(__builtin_ffs((*g_45))) <= l_92) == p_80) >= l_92)) | g_6) && g_6))));
    /* statement id: 67 */
    assert (g_101 == &g_95);
    (*l_106) = &p_80;
    /* statement id: 68 */
    assert (g_101 == &p_80);
    if (l_92)
        goto lbl_107;
    return &g_45;
    /* statement id: 70 */
    //assert (g_101 == dangling);
    //assert (func_78_rv == &g_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_95
 */
static int32_t * func_82(uint32_t  p_83, int32_t * p_84)
{ /* block id: 63 */
    int32_t **l_102 = &g_101;
    int32_t ***l_103 = &l_102;
    int32_t l_104 = (-3L);
    (*l_103) = l_102;
    (*p_84) = l_104;
    return p_84;
    /* statement id: 66 */
    //assert (func_82_rv == &g_95);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_97 g_44 g_45
 * writes: g_95 g_101
 */
static int32_t * func_88(uint32_t  p_89)
{ /* block id: 57 */
    int32_t *l_96 = &g_95;
    struct S0 *l_99 = &g_100;
    (*l_96) = func_90(g_6);
    l_99 = g_97;
    /* statement id: 59 */
    assert (l_99 == &g_98 || l_99 == 0);
    g_101 = (*g_44);
    /* statement id: 60 */
    //assert (g_101 == &g_6 || g_101 == &p_37 || g_101 == &l_184 || g_101 == 0);
    (*l_96) = (-5L);
    return l_96;
    /* statement id: 62 */
    //assert (func_88_rv == &g_95);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_95
 */
static const int16_t  func_90(uint16_t  p_91)
{ /* block id: 54 */
    int32_t *l_93 = (void*)0;
    int32_t *l_94 = &g_95;
    (*l_94) = 0x8D9F6C85L;
    return p_91;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_47, "g_47", print_hash_value);
    transparent_crc(g_61, "g_61", print_hash_value);
    transparent_crc(g_63, "g_63", print_hash_value);
    transparent_crc(g_95, "g_95", print_hash_value);
    transparent_crc(g_98.f0, "g_98.f0", print_hash_value);
    transparent_crc(g_98.f1, "g_98.f1", print_hash_value);
    transparent_crc(g_100.f0, "g_100.f0", print_hash_value);
    transparent_crc(g_100.f1, "g_100.f1", print_hash_value);
    transparent_crc(g_116, "g_116", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc(g_174, "g_174", print_hash_value);
    transparent_crc(g_193, "g_193", print_hash_value);
    transparent_crc(g_199, "g_199", print_hash_value);
    transparent_crc(g_220, "g_220", print_hash_value);
    transparent_crc(g_348, "g_348", print_hash_value);
    transparent_crc(g_404, "g_404", print_hash_value);
    transparent_crc(g_408, "g_408", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 91
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 9
   depth: 4, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 118

XXX times a variable address is taken: 114
XXX times a pointer is dereferenced on RHS: 103
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 37
XXX times a pointer is dereferenced on LHS: 116
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 21
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 536

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 438
   level: 2, occurrence: 171
   level: 3, occurrence: 10
XXX number of pointers point to pointers: 60
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 2
XXX percent of pointers has null in alias set: 22.9
XXX average alias set size: 1.38

XXX times a non-volatile is read: 469
XXX times a non-volatile is write: 309
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 41
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 7
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 19.4
XXX percentage an existing variable is used: 80.6
********************* end of statistics **********************/

