/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1604116344
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
inline static int32_t * func_34(uint64_t  p_35, uint64_t  p_36);
static uint32_t  func_38(float  p_39, int32_t * p_40);
inline static float  func_41(int64_t  p_42, int16_t  p_43);
static int16_t  func_46(uint16_t  p_47, float  p_48, int64_t  p_49, int32_t * p_50);
inline static float  func_53(uint32_t  p_54, float  p_55, int32_t * p_56);
inline static float  func_61(uint16_t  p_62);
inline static int64_t  func_63(uint64_t  p_64, int32_t  p_65, uint32_t  p_66);
inline static uint32_t  func_84(int32_t * p_85, int64_t  p_86, uint64_t  p_87, uint16_t  p_88);
static int32_t * func_96(int64_t  p_97, int32_t ** p_98, uint64_t  p_99, float  p_100, int32_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 0x2DD78F4FL;
    int64_t l_766 = 0L;
    int32_t *l_775 = (void*)0;
    int32_t **l_779 = &l_775;
    int32_t ***l_778 = &l_779;
    int32_t ****l_777 = &l_778;
    int32_t *****l_776 = &l_777;
    int64_t l_781 = 8L;
    float l_785 = 0x1.4p-1;
    for (l_31 = 0; (l_31 >= 12); ++l_31)
    { /* block id: 39 */
        int32_t *l_37 = &l_31;
        int32_t **l_758 = &l_37;
        int32_t l_759 = 0x994CBE12L;
        uint32_t l_772 = 4294967295UL;
        int32_t l_773 = 0L;
        int32_t l_774 = 0L;
        uint32_t l_780 = 2UL;
        int32_t ****l_782 = &l_778;
        int32_t l_783 = 0x39AC66EEL;
        int32_t *l_784 = &l_759;
        float *l_786 = &l_785;
        (*l_758) = func_34((l_37 != &l_31), (*l_37));
        /* statement id: 460 */
        assert (l_37 == 0);
        if (l_759)
            continue;
        (*l_784) = (l_31 , ((uint32_t)(((0x7D2FL < ((((((((((l_31 > (l_31 | ((uint16_t)(((l_766 , (void*)0) != l_776) > l_780) << (uint16_t)11))) < (-1L)) && l_781) > l_774) <= 0UL) <= 0x52A6L) < l_780) > 4294967295UL) , 0xB898AA5F93BC8A55LL) && l_772)) , l_782) == l_782) % (uint32_t)l_783));
        (*l_786) = l_785;
    }
    return l_766;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_34(uint64_t  p_35, uint64_t  p_36)
{ /* block id: 40 */
    int32_t l_52 = 1L;
    int32_t *l_51 = &l_52;
    float l_496 = 0x2.Fp+1;
    float *l_495 = &l_496;
    float **l_494 = &l_495;
    float l_497 = (-0x4.2p-1);
    uint64_t l_519 = 1UL;
    int32_t **l_588 = &l_51;
    int32_t ***l_587 = &l_588;
    int32_t ****l_586 = &l_587;
    int32_t l_589 = 0x719613A4L;
    uint32_t l_607 = 0x0F1B8DFBL;
    int32_t *l_619 = &l_52;
    int64_t l_632 = 0L;
    int32_t *l_672 = (void*)0;
    int32_t *l_686 = (void*)0;
    int32_t *l_753 = &l_52;
    int32_t *l_754 = &l_52;
    int32_t *l_755 = &l_52;
    int32_t *l_756 = &l_52;
    int32_t *l_757 = (void*)0;
    return l_757;
    /* statement id: 459 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_38(float  p_39, int32_t * p_40)
{ /* block id: 300 */
    uint32_t l_468 = 1UL;
    int32_t l_478 = 0L;
    int32_t *l_477 = &l_478;
    int32_t **l_479 = &l_477;
    (*l_479) = func_96(((((l_468 > (l_468 == (l_468 | ((int16_t)l_468 >> (int16_t)6)))) >= (func_63((((int16_t)(((int32_t)((uint16_t)l_468 - (uint16_t)(l_477 == (p_39 , p_40))) - (int32_t)(*p_40)) & (*l_477)) >> (int16_t)3) , (*l_477)), (*l_477), (*l_477)) > (*l_477))) < (*l_477)) | (*l_477)), &l_477, (*l_477), (*l_477), (*l_477));
    /* statement id: 301 */
    assert (l_477 == 0);
    return l_478;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_41(int64_t  p_42, int16_t  p_43)
{ /* block id: 296 */
    float l_462 = 0xF.7C5CC1p-77;
    int32_t l_463 = 0xAEEF9496L;
    int32_t *l_465 = &l_463;
    int32_t **l_464 = &l_465;
    (*l_464) = (l_463 , &l_463);
    (*l_464) = (*l_464);
    return p_43;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_46(uint16_t  p_47, float  p_48, int64_t  p_49, int32_t * p_50)
{ /* block id: 294 */
    uint64_t l_461 = 5UL;
    return l_461;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_53(uint32_t  p_54, float  p_55, int32_t * p_56)
{ /* block id: 291 */
    float l_459 = 0x9.454FFEp-2;
    float *l_458 = &l_459;
    int32_t l_460 = 0x285C877AL;
    (*l_458) = (-0x8.Ep-1);
    return l_460;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_61(uint16_t  p_62)
{ /* block id: 287 */
    int32_t l_454 = 0xC0C862F9L;
    int32_t **l_455 = (void*)0;
    int32_t *l_456 = &l_454;
    uint16_t l_457 = 65535UL;
    l_454 = 0x49ADDAF8L;
    l_456 = &l_454;
    return l_457;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_63(uint64_t  p_64, int32_t  p_65, uint32_t  p_66)
{ /* block id: 41 */
    int32_t *l_76 = (void*)0;
    int16_t l_350 = 0x6231L;
    float l_363 = (-0x1.7p+1);
    float *l_362 = &l_363;
    float **l_361 = &l_362;
    float ***l_360 = &l_361;
    int16_t l_376 = (-1L);
    if (p_64)
    { /* block id: 42 */
        int32_t l_95 = 9L;
        int32_t *l_94 = &l_95;
        float l_329 = 0x9.FAE5F7p+6;
        float *l_328 = &l_329;
        float **l_327 = &l_328;
        for (p_66 = 13; (p_66 != 6); p_66 -= 1)
        { /* block id: 45 */
            int32_t l_73 = 0x1A932DA3L;
            int32_t *l_72 = &l_73;
            int32_t **l_71 = &l_72;
            int32_t *l_77 = &l_73;
            (*l_71) = (void*)0;
            /* statement id: 46 */
            assert (l_72 == 0);
            for (p_64 = 0; (p_64 == 30); ++p_64)
            { /* block id: 49 */
                p_65 = (p_66 > p_64);
                l_76 = &p_65;
                /* statement id: 51 */
                assert (l_76 == &p_65);
            }
            (*l_77) = p_66;
            for (p_64 = (-11); (p_64 > 17); ++p_64)
            { /* block id: 56 */
                int32_t l_93 = (-1L);
                float *l_324 = (void*)0;
                float l_326 = (-0x8.9p+1);
                float *l_325 = &l_326;
                float ***l_330 = (void*)0;
                float ***l_331 = &l_327;
                (*l_94) = ((((int32_t)(((uint16_t)(p_65 & p_65) >> (uint16_t)15) , 1L) - (int32_t)func_84(((((int32_t)(&p_65 != l_76) + (int32_t)((int32_t)(l_93 != (((l_94 != (*l_71)) | p_66) <= (*l_94))) + (int32_t)8L)) >= p_65) , &p_65), p_64, p_66, (*l_94))) <= (*l_94)) || 8L);
                (*l_325) = (*l_94);
                (*l_331) = l_327;
            }
        }
        /* facts after for loop */
        assert (l_76 == &p_65 || l_76 == 0);
    }
    else
    { /* block id: 238 */
        uint16_t l_345 = 4UL;
        int32_t l_349 = 0x19DCE2DDL;
        int32_t *l_348 = &l_349;
        float l_354 = 0x1.0p-1;
        float *l_353 = &l_354;
        float **l_352 = &l_353;
        float ***l_351 = &l_352;
        int32_t **l_356 = &l_76;
        int32_t ***l_355 = &l_356;
        int32_t l_357 = 1L;
        l_348 = func_96((+((uint64_t)((p_66 == __builtin_ffs(__builtin_ffs(p_65))) , ((uint32_t)(((uint16_t)(+((uint16_t)((uint64_t)(((-(int16_t)(((l_345 , ((float)p_66 - (float)((p_65 < func_84(l_348, (((*l_348) ^ l_350) , (-1L)), (*l_348), p_65)) < (*l_348)))) , p_64) ^ (*l_348))) | (*l_348)) & 0x4E41F5C7FB693478LL) + (uint64_t)p_66) + (uint16_t)1L)) % (uint16_t)4UL) <= l_350) % (uint32_t)p_65)) % (uint64_t)p_65)), &l_76, l_350, p_64, p_65);
        /* statement id: 239 */
        //assert (l_76 == dangling || l_76 == 0);
        assert (l_348 == 0);
        if ((0xD680730E20BCBD8FLL < (l_351 != (((l_355 != &l_356) , ((p_65 , __builtin_clzl(p_65)) && (__builtin_ctzl((l_357 & ((uint32_t)((p_65 <= p_65) || p_64) % (uint32_t)p_66))) , 0x1EBBL))) , l_360))))
        { /* block id: 240 */
            uint16_t l_373 = 9UL;
            uint32_t l_382 = 18446744073709551615UL;
            int32_t ****l_414 = &l_355;
            int32_t l_429 = 0xE98533E3L;
            float **l_437 = &l_353;
            float l_438 = (-0x1.7p+1);
            uint32_t l_439 = 1UL;
            if (p_66)
            { /* block id: 241 */
                int64_t l_364 = 0x090773055DAE0484LL;
                (***l_351) = l_364;
            }
            else
            { /* block id: 243 */
                int32_t l_370 = 0x655A909AL;
                int32_t **l_383 = &l_348;
                int16_t l_400 = 0x2AF2L;
                float **l_403 = &l_362;
                uint32_t l_415 = 0x3FFCBA95L;
                for (l_350 = 0; (l_350 <= 6); l_350 += 3)
                { /* block id: 246 */
                    uint32_t l_369 = 18446744073709551615UL;
                    int32_t l_385 = 0x6490D080L;
                    int16_t l_394 = 0x64ABL;
                    int32_t **l_397 = (void*)0;
                    if ((p_64 <= ((int16_t)(l_369 == (p_65 > l_370)) >> (int16_t)((65535UL ^ ((0x5873L && (((int16_t)((l_373 , ((l_370 < (((int16_t)l_373 % (int16_t)p_66) < 0xD77EL)) < p_64)) != p_65) << (int16_t)5) == l_376)) ^ 0xC0B1A54CAF07905FLL)) <= 3UL))))
                    { /* block id: 247 */
                        uint64_t l_381 = 0x1C773F36A349A6F9LL;
                        float l_384 = 0x2.62143Ep+48;
                        l_385 = (((int32_t)l_370 + (int32_t)(p_64 , ((int16_t)((p_65 ^ p_66) , l_373) - (int16_t)__builtin_parityl(((p_66 && ((((p_65 , p_64) | l_369) , p_65) , 0x0C7C5717E3472C88LL)) , l_369))))) , l_381);
                    }
                    else
                    { /* block id: 249 */
                        int64_t l_401 = 0x46557EAD50939953LL;
                        int32_t l_402 = 0L;
                        l_402 = ((((2UL != 0x5C6DL) & (p_65 > ((uint16_t)p_66 + (uint16_t)(((uint32_t)((int32_t)((int16_t)l_394 >> (int16_t)(((int16_t)(p_65 , (((((void*)0 != l_397) ^ ((int16_t)p_66 >> (int16_t)l_400)) , p_65) ^ 0x627779FA1166EDB2LL)) >> (int16_t)0) , l_401)) - (int32_t)0xC9BB6DF1L) - (uint32_t)p_66) > p_66)))) && l_373) , p_64);
                    }
                    if ((((void*)0 != l_403) || __builtin_bswap32(p_66)))
                    { /* block id: 252 */
                        int32_t *l_408 = &l_349;
                        int32_t ****l_411 = &l_355;
                        if (p_66)
                            break;
                        (*l_408) = __builtin_ctz((((((((p_65 , ((int32_t)((int16_t)p_66 >> (int16_t)6) % (int32_t)func_84(l_408, p_64, p_65, l_382))) >= (p_64 & ((int16_t)((void*)0 == &p_65) >> (int16_t)5))) | p_64) , p_64) == 1L) != 0x5572L) , 0xFAD3BD01L));
                        (*l_411) = (void*)0;
                        /* statement id: 255 */
                        assert (l_355 == 0);
                    }
                    else
                    { /* block id: 256 */
                        return p_66;
                    }
                    /* facts after branching */
                    assert (l_355 == 0);
                    return p_66;
                }
                for (l_357 = 0; (l_357 >= (-23)); l_357 -= 1)
                { /* block id: 263 */
                    uint64_t l_416 = 18446744073709551615UL;
                    int32_t *l_424 = &l_357;
                    int32_t *l_426 = &l_349;
                    uint16_t l_430 = 65535UL;
                    (*l_356) = l_424;
                    /* statement id: 264 */
                    assert (l_76 == &l_357);
                    (*l_426) = (!(***l_355));
                    if ((****l_414))
                        break;
                }
                /* facts after for loop */
                //assert (l_76 == &l_357 || l_76 == dangling || l_76 == 0);
            }
            /* facts after branching */
            //assert (l_76 == &l_357 || l_76 == dangling || l_76 == 0);
            (***l_414) = l_362;
            /* statement id: 270 */
            assert (l_76 == &l_363);
        }
        else
        { /* block id: 271 */
            int32_t l_440 = 0L;
            int32_t *l_441 = &l_349;
            (*l_441) = (l_440 & l_440);
            (*l_355) = (*l_355);
            if (((uint16_t)((p_66 & p_66) , (*l_441)) >> (uint16_t)(p_65 != (((int16_t)((((((uint16_t)func_84(l_441, (p_64 != ((int16_t)(p_66 > ((&l_441 == &l_76) <= 0xAD23L)) + (int16_t)0xACBCL)), p_65, p_65) >> (uint16_t)(*l_441)) <= p_66) > l_376) < p_65) != 0xA01BL) << (int16_t)p_66) & p_66))))
            { /* block id: 274 */
                for (p_64 = 0; (p_64 == 52); p_64 += 3)
                { /* block id: 277 */
                    int64_t l_452 = 4L;
                    (**l_355) = l_441;
                    /* statement id: 278 */
                    assert (l_76 == &l_349);
                    if (l_452)
                        break;
                }
                /* facts after for loop */
                //assert (l_76 == &l_349 || l_76 == dangling || l_76 == 0);
            }
            else
            { /* block id: 281 */
                int32_t *l_453 = &l_349;
                (*l_356) = l_453;
                /* statement id: 282 */
                assert (l_76 == &l_349);
            }
            /* facts after branching */
            //assert (l_76 == &l_349 || l_76 == dangling || l_76 == 0);
        }
        /* facts after branching */
        //assert (l_76 == &l_349 || l_76 == dangling || l_76 == 0 || l_76 == &l_363);
    }
    /* facts after branching */
    //assert (l_76 == dangling || l_76 == 0 || l_76 == &l_363 || l_76 == &p_65);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_84(int32_t * p_85, int64_t  p_86, uint64_t  p_87, uint16_t  p_88)
{ /* block id: 57 */
    int16_t l_102 = 0x1000L;
    int32_t *l_323 = (void*)0;
    int32_t **l_322 = &l_323;
    (*l_322) = func_96(l_102, (l_102 , &p_85), p_86, l_102, (*p_85));
    /* statement id: 231 */
    //assert (p_85 == dangling || p_85 == &p_65 || p_85 == &l_349 || p_85 == &l_363 || p_85 == &l_52);
    return p_87;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_96(int64_t  p_97, int32_t ** p_98, uint64_t  p_99, float  p_100, int32_t  p_101)
{ /* block id: 58 */
    uint64_t l_105 = 8UL;
    int32_t *l_123 = (void*)0;
    int32_t **l_175 = &l_123;
    int32_t l_224 = 0x544D09D3L;
    uint32_t l_238 = 6UL;
    int32_t *l_316 = &l_224;
    int32_t *l_318 = &l_224;
    int32_t *l_321 = (void*)0;
    if (((int32_t)0x1929B4DBL - (int32_t)l_105))
    { /* block id: 59 */
        int32_t l_109 = 0x466640DDL;
        int32_t *l_108 = &l_109;
        (*l_108) = ((l_105 , l_105) <= (0UL > p_101));
        if ((((int64_t)p_101 + (int64_t)0x1094B98F8D6FFBA4LL) , l_105))
        { /* block id: 61 */
            (*p_98) = (*p_98);
        }
        else
        { /* block id: 63 */
            (*p_98) = &l_109;
            /* statement id: 64 */
            //assert (p_85 == &l_109);
        }
        /* facts after branching */
        //assert (p_85 == &l_109 || p_85 == &p_65 || p_85 == &l_349 || p_85 == &l_363 || p_85 == &l_52);
    }
    else
    { /* block id: 66 */
        int32_t l_122 = 1L;
        int32_t *l_121 = &l_122;
        int64_t l_164 = 0xFD3A0BC11C586F40LL;
        int32_t *l_268 = &l_122;
        int32_t ***l_303 = (void*)0;
        uint32_t l_308 = 0UL;
        float l_312 = 0x4.8A2071p-73;
        float *l_311 = &l_312;
        for (p_99 = 0; (p_99 >= 21); p_99 += 1)
        { /* block id: 69 */
            int32_t l_118 = 2L;
            int32_t **l_130 = &l_121;
            int32_t l_145 = 0x71BBE26AL;
            float l_155 = (-0x3.6p-1);
            float *l_154 = &l_155;
            uint32_t l_196 = 0x9CC3E7F2L;
        }
        for (p_101 = 1; (p_101 != 19); p_101 += 3)
        { /* block id: 160 */
            int32_t *l_221 = (void*)0;
            (*l_121) = 1L;
        }
        for (p_101 = (-25); (p_101 > 24); p_101 += 1)
        { /* block id: 167 */
            int64_t l_227 = 0x8FD024E14C23F783LL;
            int32_t **l_243 = &l_121;
            uint32_t l_264 = 0x74A84839L;
            int32_t *l_279 = (void*)0;
            int32_t l_281 = 0x40D0F788L;
        }
        (*l_311) = ((((void*)0 == (*l_175)) >= (p_101 >= p_101)) == (((((float)(((float)p_97 - (float)((l_238 > l_308) > ((p_101 || ((int16_t)((*l_121) && p_97) >> (int16_t)p_97)) , p_99))) < 0x1.Cp+1) + (float)l_224) != 0x5.9p-1) <= p_100) == p_100));
    }
    /* facts after branching */
    //assert (p_85 == dangling || p_85 == &p_65 || p_85 == &l_349 || p_85 == &l_363 || p_85 == &l_52);
    for (p_101 = 25; (p_101 != 9); p_101 -= 1)
    { /* block id: 226 */
        int32_t *l_315 = &l_224;
        int32_t *l_317 = &l_224;
        int32_t *l_319 = &l_224;
        int32_t *l_320 = (void*)0;
        (*p_98) = l_315;
        /* statement id: 227 */
        //assert (p_85 == &l_224);
        return l_320;
        /* statement id: 228 */
        //assert (p_85 == dangling);
        //assert (func_96_rv == 0);
    }
    return l_321;
    /* statement id: 230 */
    //assert (func_96_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 204
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 7, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 144

XXX times a variable address is taken: 158
XXX times a pointer is dereferenced on RHS: 161
breakdown:
   depth: 1, occurrence: 118
   depth: 2, occurrence: 35
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
XXX times a pointer is dereferenced on LHS: 110
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 10
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 854

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 410
   level: 2, occurrence: 183
   level: 3, occurrence: 65
   level: 4, occurrence: 41
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 64
XXX number of pointers point to scalars: 80
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.6
XXX average alias set size: 1.26

XXX times a non-volatile is read: 1152
XXX times a non-volatile is write: 309
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 9

XXX stmts: 72
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 21
   depth: 1, occurrence: 15
   depth: 2, occurrence: 12
   depth: 3, occurrence: 10
   depth: 4, occurrence: 8
   depth: 5, occurrence: 6

XXX percentage a fresh-made variable is used: 13.3
XXX percentage an existing variable is used: 86.7
********************* end of statistics **********************/

