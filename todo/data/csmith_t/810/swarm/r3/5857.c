/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2966205362
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int64_t  f1;
   const uint64_t  f2;
   uint16_t  f3;
   uint32_t  f4;
   int16_t  f5;
   uint32_t  f6;
   const int8_t  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_30(void);
static int16_t  func_33(uint32_t  p_34, int64_t  p_35);
static int16_t  func_38(float  p_39, int32_t  p_40, int8_t  p_41);
inline static const float  func_49(uint32_t  p_50, const int16_t  p_51, const struct S0  p_52, uint32_t  p_53, uint16_t  p_54);
inline static const int16_t  func_55(uint32_t  p_56, int8_t  p_57, int64_t  p_58, int8_t  p_59);
static int32_t  func_70(uint32_t  p_71);
inline static int64_t  func_76(uint64_t  p_77, uint32_t  p_78, float  p_79);
inline static uint8_t  func_84(int32_t  p_85, int16_t  p_86, int64_t  p_87);
static uint8_t  func_91(int32_t  p_92, uint64_t  p_93, struct S0  p_94, uint16_t  p_95, uint32_t  p_96);
static int8_t  func_110(uint32_t  p_111, int32_t  p_112, uint8_t  p_113, int32_t  p_114, uint8_t  p_115);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_30(void)
{ /* block id: 36 */
    int32_t l_32 = 0xF88039D6L;
    int32_t l_480 = 0xEF9AA07CL;
    l_480 = ((+l_32) < func_33(l_32, l_32));
    return l_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_33(uint32_t  p_34, int64_t  p_35)
{ /* block id: 37 */
    uint32_t l_36 = 8UL;
    int32_t l_37 = 0x3A0F0F5EL;
    l_37 = l_36;
    l_37 = p_34;
    l_37 = (func_38(p_34, (p_35 >= (p_34 <= (-1L))), l_36) & ((uint8_t)l_36 >> (uint8_t)__builtin_ffsl(__builtin_bswap64((((int16_t)((l_36 || (!4UL)) && p_34) << (int16_t)p_35) > l_37)))));
    return l_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_38(float  p_39, int32_t  p_40, int8_t  p_41)
{ /* block id: 40 */
    uint32_t l_42 = 0xD2A6F9A4L;
    const struct S0 l_436 = {8UL,5L,18446744073709551612UL,0xCFDCL,0UL,0xA0ECL,18446744073709551615UL,-10L};
    l_42 = 0x0.Cp+1;
    p_39 = ((float)((float)((float)((p_40 != func_49(l_42, func_55((p_40 != (((uint32_t)4294967287UL / (uint32_t)((uint8_t)(((int64_t)__builtin_ctz(__builtin_parityl(l_42)) % (int64_t)((uint8_t)(p_40 != (0UL ^ (-3L))) >> (uint8_t)p_41)) > p_40) >> (uint8_t)l_42)) == l_42)), l_42, l_42, p_41), l_436, l_436.f0, l_436.f3)) >= (-0x6.5p+1)) - (float)l_436.f0) + (float)0x3.2p-1) + (float)l_436.f1);
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_49(uint32_t  p_50, const int16_t  p_51, const struct S0  p_52, uint32_t  p_53, uint16_t  p_54)
{ /* block id: 148 */
    const uint64_t l_443 = 0x99BEEA28F6C8B6C8LL;
    struct S0 l_460 = {3UL,0xF69E3C95EAEA01EALL,18446744073709551615UL,0x4433L,0x563B06DAL,0x584CL,0xEC100D98L,6L};
    int32_t l_466 = 0L;
    for (p_53 = 9; (p_53 > 13); p_53 += 7)
    { /* block id: 151 */
        uint8_t l_452 = 0xA4L;
        float l_459 = 0x1.6p-1;
        int32_t l_461 = 0x68BC98F5L;
        uint16_t l_462 = 0xF2BFL;
        uint16_t l_463 = 65535UL;
        l_461 = __builtin_ctzl(func_76(((int8_t)((uint16_t)(l_443 != (((int8_t)((uint8_t)p_52.f2 >> (uint8_t)1) + (int8_t)((int8_t)(l_443 ^ (((int8_t)((l_443 ^ (l_452 != ((int8_t)p_52.f1 / (int8_t)0x1FL))) == ((int16_t)(func_91(((uint16_t)func_91(l_452, ((65535UL != p_53) || 0x24L), l_460, p_52.f0, l_460.f2) << (uint16_t)10), p_52.f7, l_460, l_452, l_452) > 9L) >> (int16_t)14)) % (int8_t)255UL) == l_452)) + (int8_t)l_452)) < p_52.f2)) - (uint16_t)0UL) + (int8_t)p_52.f1), p_52.f7, p_52.f5));
        l_466 = (l_462 > (l_463 >= ((int16_t)l_452 << (int16_t)11)));
        l_466 = (((float)(l_461 != ((float)((float)(-0x1.5p+1) / (float)((__builtin_clz(p_52.f5) < 0x3.B76097p+82) >= 0xB.277B47p-62)) / (float)l_460.f3)) * (float)(p_52.f3 < l_461)) >= l_463);
    }
    l_466 = (0x0.6p-1 == p_51);
    l_466 = (p_52.f4 != 0L);
    return l_466;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_55(uint32_t  p_56, int8_t  p_57, int64_t  p_58, int8_t  p_59)
{ /* block id: 42 */
    int16_t l_427 = 0L;
    int32_t l_432 = 0x5B68615EL;
    int16_t l_433 = 0x489EL;
    l_427 = func_70(p_56);
    l_432 = ((float)((((p_59 > l_427) != (-0x1.7p+1)) == ((float)(0x2.B31005p+65 > (p_58 != (l_427 <= l_427))) / (float)((l_427 == l_427) < p_58))) >= p_56) * (float)l_427);
    l_433 = l_427;
    l_432 = ((int8_t)p_57 + (int8_t)p_59);
    return l_432;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_70(uint32_t  p_71)
{ /* block id: 43 */
    uint16_t l_88 = 7UL;
    float l_89 = 0xD.BE308Dp+21;
    struct S0 l_97 = {0x866CA241L,0L,0x996DCEBFDCAE3649LL,0UL,0x08A9CBEBL,1L,0x38B4FD08L,1L};
    int32_t l_388 = (-1L);
    int32_t l_389 = (-2L);
    l_388 = (((0x4656E2E31B546539LL && 0xB38A83A56CF6D707LL) & ((uint8_t)__builtin_clzll(p_71) % (uint8_t)((uint32_t)((((func_76(((int32_t)(((int16_t)(func_84(l_88, l_88, ((-(int16_t)(0x18L | ((func_91(l_88, p_71, l_97, l_97.f6, l_97.f3) != l_97.f1) ^ l_97.f6))) < 0x4EL)) & l_97.f1) % (int16_t)p_71) || p_71) + (int32_t)l_97.f6), l_97.f3, p_71) >= l_97.f3) ^ p_71) <= p_71) & 1UL) + (uint32_t)l_97.f0))) == 0x41DAB4DFL);
    l_389 = p_71;
    if ((0xE2F1D7D21DF0A651LL ^ (-(int16_t)((uint8_t)(0x6676456B29B314F7LL & l_97.f5) + (uint8_t)p_71))))
    { /* block id: 134 */
        int32_t l_395 = (-1L);
        uint8_t l_416 = 0x00L;
        l_395 = ((int16_t)p_71 << (int16_t)15);
        l_388 = ((((uint16_t)((__builtin_parityl(l_97.f5) < ((int64_t)((uint8_t)0xA4L - (uint8_t)((uint16_t)l_97.f4 % (uint16_t)p_71)) % (int64_t)__builtin_parityl(p_71))) >= p_71) << (uint16_t)5) > ((p_71 >= l_395) <= 0xF8C37268L)) && l_389);
        l_388 = (((((float)p_71 * (float)l_97.f6) != l_395) < (l_97.f1 >= l_395)) <= func_76((l_395 != ((int16_t)((uint16_t)65527UL / (uint16_t)p_71) - (int16_t)((uint8_t)(((uint16_t)((int8_t)(-3L) << (int8_t)p_71) - (uint16_t)l_416) | p_71) * (uint8_t)l_389))), p_71, p_71));
    }
    else
    { /* block id: 138 */
        float l_417 = 0xC.F83DF6p-18;
        int32_t l_422 = (-10L);
        l_388 = 0x0E58691EL;
        l_422 = (0x3.972C5Ep-38 == ((float)(l_97.f6 >= ((float)(func_91(l_422, l_422, l_97, ((uint8_t)((int16_t)p_71 << (int16_t)10) - (uint8_t)0UL), p_71) < l_422) / (float)0x0.Bp+1)) + (float)p_71));
    }
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_76(uint64_t  p_77, uint32_t  p_78, float  p_79)
{ /* block id: 50 */
    int64_t l_129 = 0xC2412408B304F1BCLL;
    struct S0 l_130 = {0xED26586BL,-1L,18446744073709551615UL,65535UL,1UL,0x4D63L,0xF5A50E62L,0x17L};
    int32_t l_133 = 6L;
    int32_t l_264 = (-9L);
    int32_t l_307 = 8L;
    uint64_t l_310 = 18446744073709551611UL;
    float l_387 = 0x4.4A3762p+69;
    for (p_78 = 0; (p_78 > 5); p_78 += 9)
    { /* block id: 53 */
        int64_t l_122 = 0xB06E2AFE58852677LL;
        struct S0 l_258 = {0x199E9942L,0x188FF261ECBF7E81LL,9UL,65527UL,0xF5489188L,1L,0x84813EE7L,-1L};
        int32_t l_260 = 0xA5EF5FE0L;
        if (((uint8_t)((uint16_t)((uint8_t)func_91(((int8_t)func_110(((int32_t)func_91(((int64_t)__builtin_bswap32((((((uint8_t)l_122 >> (uint8_t)(l_122 || func_91(((int16_t)((uint8_t)((int16_t)(-7L) << (int16_t)3) >> (uint8_t)l_129) >> (int16_t)9), l_122, l_130, l_122, (l_130.f2 != func_84(((((uint16_t)(p_78 != p_77) + (uint16_t)l_122) > l_122) <= (-7L)), l_133, p_77))))) || p_77) > p_77) == l_122)) / (int64_t)p_78), l_133, l_130, l_130.f0, p_78) / (int32_t)l_122), p_78, l_130.f6, l_130.f3, p_77) + (int8_t)p_78), l_122, l_258, l_258.f4, p_78) * (uint8_t)p_78) >> (uint16_t)4) - (uint8_t)1L))
        { /* block id: 87 */
            uint64_t l_259 = 0x590D36859830C119LL;
            if (__builtin_clzll(l_259))
            { /* block id: 88 */
                l_260 = (-0x5.8p+1);
            }
            else
            { /* block id: 90 */
                p_79 = ((func_84(((int8_t)p_78 << (int8_t)p_77), l_260, l_258.f2) != 0x1.3p-1) >= (+p_78));
                return l_258.f7;
            }
            l_133 = func_91((l_258.f1 != __builtin_clzll(l_130.f2)), l_264, l_130, l_259, ((uint64_t)__builtin_parityll(p_77) % (uint64_t)((uint16_t)(((int16_t)((((int16_t)0x8892L * (int16_t)p_78) && 4UL) | 0xB1B9816CL) >> (int16_t)l_260) >= p_78) / (uint16_t)65527UL)));
        }
        else
        { /* block id: 95 */
            uint16_t l_279 = 4UL;
            struct S0 l_308 = {0xAAB1AC60L,-9L,0x47E5CDF20B0982D6LL,0x9CECL,0xF4C687C5L,-6L,0x7A52A20EL,-5L};
            int8_t l_309 = 0xB5L;
            uint16_t l_311 = 65535UL;
            int32_t l_312 = 0xCA204FFAL;
            for (l_258.f6 = 0; (l_258.f6 < 15); l_258.f6 += 7)
            { /* block id: 98 */
                l_133 = ((uint16_t)p_77 << (uint16_t)6);
                if ((p_77 > ((int8_t)4L + (int8_t)255UL)))
                { /* block id: 100 */
                    return l_130.f2;
                }
                else
                { /* block id: 102 */
                    return l_279;
                }
            }
            for (l_258.f1 = 0; (l_258.f1 >= (-9)); l_258.f1 -= 8)
            { /* block id: 108 */
                int32_t l_286 = 0xD02848F1L;
                uint64_t l_316 = 0xCD277CD82FAD60E4LL;
                int32_t l_345 = 4L;
                struct S0 l_385 = {18446744073709551614UL,0x30AD3EC22CC2C125LL,0UL,0x7754L,0x4CAA32A4L,-2L,0x67AFB20AL,0L};
                if (__builtin_ffs(((uint64_t)l_130.f1 - (uint64_t)func_110(((uint64_t)l_286 - (uint64_t)((uint16_t)p_77 * (uint16_t)((uint32_t)(l_286 || (((int16_t)((uint32_t)((int8_t)((uint16_t)l_129 * (uint16_t)(((((((uint64_t)0xE3C27CBA657FA000LL + (uint64_t)2UL) < (((int8_t)(((uint8_t)((uint64_t)func_91(l_279, l_307, l_308, l_258.f7, l_309) + (uint64_t)0x6A66F2389C7B4440LL) - (uint8_t)p_78) >= l_310) * (int8_t)l_258.f5) ^ p_77)) < p_77) && p_77) || 0UL) || 3L)) - (int8_t)p_77) - (uint32_t)l_309) >> (int16_t)l_286) | 0UL)) - (uint32_t)1UL))), l_308.f5, l_311, l_130.f4, p_78))))
                { /* block id: 109 */
                    int8_t l_317 = 0xDFL;
                    int32_t l_318 = 0L;
                    int16_t l_321 = (-1L);
                    l_312 = (-1L);
                    if (l_258.f1)
                    { /* block id: 111 */
                        int16_t l_313 = 0x9F85L;
                        l_313 = (0L ^ 0x77L);
                        l_318 = ((uint16_t)l_316 >> (uint16_t)func_110(l_317, l_317, p_77, p_78, l_308.f3));
                        l_133 = ((float)l_321 - (float)((((float)p_79 + (float)((float)(+(!func_91(l_258.f0, p_77, l_308, p_78, (l_313 == (0x6C2899AFL ^ 1L))))) + (float)l_286)) == p_77) > 0x1.8p-1));
                    }
                    else
                    { /* block id: 115 */
                        l_345 = (-(float)((float)(((-0x2.2p-1) <= (-0x6.7p-1)) <= ((float)(((float)p_77 + (float)((float)((float)p_77 * (float)func_110(p_78, (((uint16_t)p_78 % (uint16_t)((uint8_t)(((((int64_t)0x6EA03D3E3130C64ELL + (int64_t)p_78) ^ __builtin_ffsll((0x9FAC3A7E1613166CLL != 18446744073709551615UL))) & l_258.f1) && p_78) << (uint8_t)0)) && l_311), p_78, p_77, p_77)) + (float)0x7.A8CC6Dp+74)) < l_286) / (float)p_78)) * (float)p_77));
                    }
                    l_312 = (func_91(p_77, p_77, l_258, ((p_78 ^ l_130.f2) > ((!0UL) | l_258.f7)), l_311) == 65535UL);
                }
                else
                { /* block id: 119 */
                    int32_t l_365 = 0x6CE27E5EL;
                    int32_t l_366 = 1L;
                    l_260 = 0x3677A516L;
                    l_366 = ((uint16_t)((((uint64_t)0x1102A6E8E867B30FLL + (uint64_t)((uint64_t)((p_77 && ((uint32_t)((int16_t)((int8_t)0xC5L - (int8_t)(((uint16_t)(+((-6L) > (5UL == (l_309 != (((p_77 || (l_312 || (!0xE7BAL))) | 0x89L) | l_130.f5))))) << (uint16_t)l_310) < 0x18F66F7A08163BCBLL)) + (int16_t)p_77) % (uint32_t)p_77)) | 0x5C20L) / (uint64_t)l_308.f0)) ^ p_78) | l_365) >> (uint16_t)p_77);
                }
                l_345 = (-0x1.9p+1);
                l_260 = ((float)p_78 / (float)(l_129 != ((float)l_308.f2 + (float)((float)p_78 + (float)((float)l_258.f3 - (float)p_77)))));
                l_133 = func_91(((p_77 >= l_309) ^ ((int16_t)((uint16_t)l_309 >> (uint16_t)func_84(((uint16_t)l_258.f5 % (uint16_t)__builtin_popcount(((uint8_t)((int8_t)p_78 << (int8_t)6) >> (uint8_t)2))), l_316, l_308.f1)) + (int16_t)p_77)), p_78, l_385, l_316, l_258.f3);
            }
            return p_78;
        }
    }
    l_133 = (!p_77);
    return l_130.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_84(int32_t  p_85, int16_t  p_86, int64_t  p_87)
{ /* block id: 47 */
    uint16_t l_99 = 0xCDC8L;
    l_99 = 5L;
    return l_99;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_91(int32_t  p_92, uint64_t  p_93, struct S0  p_94, uint16_t  p_95, uint32_t  p_96)
{ /* block id: 44 */
    p_92 = (!__builtin_parityll(p_93));
    return p_94.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_110(uint32_t  p_111, int32_t  p_112, uint8_t  p_113, int32_t  p_114, uint8_t  p_115)
{ /* block id: 54 */
    uint64_t l_136 = 18446744073709551607UL;
    int32_t l_139 = 0x16ADEA61L;
    struct S0 l_142 = {2UL,0x1440D3F7D50A455CLL,1UL,0xAB99L,0xCC17125CL,-1L,18446744073709551611UL,0x21L};
    uint16_t l_169 = 65534UL;
    uint32_t l_257 = 18446744073709551611UL;
    if (((uint8_t)l_136 >> (uint8_t)p_111))
    { /* block id: 55 */
        float l_145 = 0xD.FBF5E0p+27;
        int8_t l_153 = (-1L);
        uint32_t l_170 = 0UL;
        struct S0 l_171 = {0x31A1128FL,-10L,18446744073709551612UL,0xF1CAL,0x8E4F1F3AL,0x2AEAL,0x53E6A3F3L,-1L};
        l_139 = ((float)p_111 / (float)(-0x1.0p-1));
        p_114 = (0L & (((uint8_t)func_91((l_139 ^ p_114), p_112, l_142, l_142.f4, p_113) * (uint8_t)((((((int16_t)(0x477C2843333429DDLL > p_111) % (int16_t)0x5936L) == 0x81L) >= p_112) >= l_139) && p_115)) && 0x2726E94FL));
        p_114 = ((int64_t)(((int8_t)((l_142.f3 || __builtin_parityll(__builtin_clzll(((int32_t)((+p_112) < l_153) % (int32_t)l_136)))) != ((uint16_t)65535UL * (uint16_t)((uint16_t)((__builtin_clz(((uint16_t)(((uint8_t)(l_142.f4 & ((uint64_t)(+func_91((((uint16_t)((int16_t)0L >> (int16_t)p_114) >> (uint16_t)13) || l_169), l_170, l_171, p_111, p_113)) / (uint64_t)1L)) >> (uint8_t)p_112) && 0xA1L) * (uint16_t)l_171.f1)) > p_115) != 255UL) + (uint16_t)l_136))) % (int8_t)l_171.f1) && 0x62B7E369L) % (int64_t)l_171.f4);
        p_114 = ((uint8_t)l_142.f1 >> (uint8_t)(0xA3L > (((uint32_t)((+((uint8_t)l_171.f3 * (uint8_t)p_115)) && ((uint8_t)0x63L * (uint8_t)func_91(p_114, (__builtin_popcountl(p_115) >= (l_153 || p_113)), l_142, p_115, l_171.f5))) / (uint32_t)l_142.f6) > l_171.f0)));
    }
    else
    { /* block id: 60 */
        uint8_t l_195 = 0x79L;
        p_114 = func_84((p_111 == ((((l_142.f3 & p_112) && 4L) || ((int16_t)(func_84(((p_113 < ((int16_t)p_113 << (int16_t)15)) == (((int32_t)(((((((int8_t)(-3L) >> (int8_t)((uint16_t)((-1L) ^ ((uint32_t)(l_195 & l_139) / (uint32_t)l_142.f4)) - (uint16_t)l_195)) && 0xECL) && p_114) != 1L) && p_111) & 255UL) + (int32_t)l_142.f7) >= p_114)), l_142.f5, l_142.f6) == 1UL) % (int16_t)p_115)) == l_195)), l_195, l_142.f5);
        p_114 = (((int16_t)(l_195 && (!(~((uint16_t)0xACE6L / (uint16_t)(((uint16_t)func_91(((uint16_t)__builtin_clz((((p_113 != l_142.f3) > l_169) && ((int64_t)p_114 % (int64_t)3L))) / (uint16_t)l_195), l_195, l_142, p_112, p_112) << (uint16_t)10) || p_112))))) >> (int16_t)l_195) < p_112);
    }
    p_114 = p_111;
    if (((uint8_t)0xF9L << (uint8_t)4))
    { /* block id: 65 */
        uint32_t l_224 = 1UL;
        struct S0 l_227 = {0x8726DF7CL,0xC0EF68449CD76D8CLL,0x317FEB46863D7E0BLL,3UL,0x3984BC84L,3L,0x74453018L,1L};
        int32_t l_242 = 0x77EC2AD8L;
        for (l_142.f0 = 0; (l_142.f0 >= 22); l_142.f0 += 3)
        { /* block id: 68 */
            uint16_t l_223 = 0xA1DFL;
            for (p_111 = 0; (p_111 >= 3); p_111 += 1)
            { /* block id: 71 */
                float l_225 = 0x0.0p+1;
                int32_t l_226 = 0L;
                l_139 = func_84(p_114, (((((int8_t)(-7L) + (int8_t)(((uint8_t)0xC8L - (uint8_t)((int8_t)(0x3DL >= func_91(((0xCAAF734E6BA9F1CBLL > (1L >= 0x6AL)) > (-1L)), ((((~((int64_t)(l_223 && l_224) - (int64_t)l_142.f3)) & 0x3987L) >= p_111) || l_226), l_227, p_111, l_139)) >> (int8_t)4)) & p_115)) != 0x42A9DD39L) < l_226) != l_227.f1), l_142.f5);
                return p_113;
            }
            l_242 = func_84(((uint8_t)((uint32_t)p_115 / (uint32_t)((int16_t)((uint8_t)(((uint8_t)l_223 + (uint8_t)((uint16_t)p_115 << (uint16_t)7)) | (((-1L) < __builtin_popcountll(((__builtin_clzl(l_227.f6) < __builtin_clzll(((int32_t)l_142.f6 - (int32_t)p_111))) <= 0x1BL))) == l_142.f3)) << (uint8_t)l_223) % (int16_t)0xCDA5L)) + (uint8_t)0xC6L), p_111, l_223);
            if (p_114)
                continue;
        }
        l_139 = (((float)0x8.16CE41p+66 + (float)(((float)l_227.f6 - (float)(((float)__builtin_parityll(((uint8_t)((int32_t)(((func_84(((uint64_t)l_227.f6 / (uint64_t)l_227.f2), p_114, p_113) <= (+(l_142.f4 ^ (l_139 & l_169)))) <= l_169) | p_111) % (int32_t)p_112) << (uint8_t)4)) - (float)0x1.308C90p+29) <= p_111)) >= l_169)) < p_114);
    }
    else
    { /* block id: 79 */
        uint64_t l_256 = 0x510EADCF1EF60FB9LL;
        if (p_114)
        { /* block id: 80 */
            return l_256;
        }
        else
        { /* block id: 82 */
            return l_256;
        }
    }
    return l_257;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 70
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 83
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 10, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 34, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 426
XXX times a non-volatile is write: 56
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 18
   depth: 2, occurrence: 10
   depth: 3, occurrence: 11
   depth: 4, occurrence: 7
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
********************* end of statistics **********************/

