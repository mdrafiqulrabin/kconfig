/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2438789630
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_30(void);
inline static int32_t * func_31(uint32_t  p_32);
inline static int16_t  func_36(int32_t * p_37, int16_t  p_38);
inline static int32_t * func_39(int16_t  p_40, uint64_t  p_41, int32_t * p_42);
inline static int32_t  func_52(int32_t * p_53, int32_t * p_54, uint32_t  p_55);
inline static uint32_t  func_62(uint32_t  p_63, int16_t  p_64, int32_t * p_65, int64_t  p_66, int32_t * p_67);
static int16_t  func_69(int32_t * p_70, const int64_t  p_71, int32_t  p_72, int64_t  p_73);
static int32_t * func_74(int16_t  p_75, int32_t * p_76);
static const int64_t  func_82(int32_t * p_83, int32_t * p_84);
inline static int64_t  func_92(int32_t  p_93, int8_t  p_94, int32_t  p_95, int32_t  p_96, uint32_t  p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_30(void)
{ /* block id: 36 */
    int32_t l_48 = (-1L);
    int32_t *l_47 = &l_48;
    int32_t l_450 = 1L;
    int32_t **l_452 = &l_47;
    uint32_t l_484 = 1UL;
    int64_t l_509 = (-7L);
    int32_t ***l_521 = &l_452;
    int32_t ****l_520 = &l_521;
    int32_t *****l_519 = &l_520;
    const uint32_t l_529 = 0x5395F9D7L;
    int32_t l_534 = 0L;
    (*l_452) = func_31((!__builtin_ia32_crc32qi(((int16_t)func_36(func_39((((uint16_t)((int16_t)(l_47 != (void*)0) * (int16_t)((uint16_t)((*l_47) > ((*l_47) < (-(int64_t)(func_52(&l_48, &l_48, (*l_47)) & (*l_47))))) >> (uint16_t)3)) + (uint16_t)1UL) < (*l_47)), (*l_47), &l_48), (*l_47)) << (int16_t)l_450), l_450)));
    /* statement id: 300 */
    assert (l_47 == 0);
    for (l_450 = 18; (l_450 >= 20); l_450 += 1)
    { /* block id: 303 */
        int16_t l_455 = 0x96BAL;
        int32_t *l_456 = (void*)0;
        int32_t *l_457 = &l_48;
        int32_t ***l_481 = (void*)0;
        int32_t ****l_480 = &l_481;
        int32_t *****l_482 = (void*)0;
        int32_t *****l_483 = &l_480;
        int32_t ****l_505 = &l_481;
        uint16_t l_508 = 1UL;
        (*l_457) = l_455;
        for (l_48 = 0; (l_48 != 12); l_48 += 6)
        { /* block id: 307 */
            int32_t l_460 = (-1L);
            int32_t *l_461 = &l_450;
            int32_t ***l_468 = (void*)0;
            int32_t l_474 = 0x6E31C739L;
            int32_t l_479 = 1L;
            int32_t *l_478 = &l_479;
            if (l_460)
            { /* block id: 308 */
                (*l_452) = l_461;
                /* statement id: 309 */
                assert (l_47 == &l_450);
            }
            else
            { /* block id: 310 */
                int32_t ***l_469 = &l_452;
                int32_t l_473 = 0x69C467ECL;
                int32_t *l_472 = &l_473;
                int32_t *l_477 = (void*)0;
                (*l_472) = ((((*l_461) <= 1L) & ((uint64_t)(*l_461) / (uint64_t)((((int16_t)((int64_t)(l_468 != l_469) - (int64_t)(&l_47 != &l_47)) - (int16_t)0x49C6L) & ((int16_t)0L << (int16_t)12)) | (*l_457)))) == 1L);
                (*l_472) = (0x8E5AL >= (*l_461));
                for (l_455 = 0; (l_455 != (-6)); l_455 -= 6)
                { /* block id: 315 */
                    (**l_469) = l_461;
                    /* statement id: 316 */
                    assert (l_47 == &l_450);
                    if ((**l_452))
                        break;
                }
                (**l_469) = l_477;
                /* statement id: 319 */
                assert (l_47 == 0);
            }
            /* facts after branching */
            assert (l_47 == 0 || l_47 == &l_450);
            (*l_478) = (*l_457);
            l_452 = &l_47;
        }
        (*l_483) = l_480;
        if (l_484)
        { /* block id: 325 */
            int32_t l_494 = 0L;
            int32_t l_499 = 0xDF36D354L;
            for (l_48 = (-20); (l_48 <= (-17)); l_48 += 1)
            { /* block id: 328 */
                int32_t l_489 = 0x250ECAABL;
                int32_t l_500 = 0xAF08930FL;
                l_500 = ((((uint16_t)(7L < l_489) + (uint16_t)(((uint16_t)(((int64_t)(l_494 ^ l_489) + (int64_t)l_489) & ((l_494 | ((int64_t)l_489 - (int64_t)((uint32_t)l_48 - (uint32_t)l_494))) == l_494)) % (uint16_t)l_499) < l_489)) ^ l_489) <= l_499);
                l_500 = l_494;
                (*l_452) = &l_500;
                /* statement id: 331 */
                assert (l_47 == &l_500);
                (**l_452) = ((uint16_t)(&l_494 != (void*)0) / (uint16_t)(((int16_t)(l_499 <= l_500) + (int16_t)l_494) & __builtin_parity((**l_452))));
            }
            l_494 = (func_82(func_74(((void*)0 == l_505), func_39(__builtin_ffsll(l_499), (((func_69(func_39(l_499, ((((uint16_t)(&l_494 == &l_499) / (uint16_t)(*l_457)) == (*l_457)) | l_508), &l_494), l_499, l_509, l_494) >= l_494) | l_494) | l_499), &l_499)), &l_499) != (-1L));
        }
        else
        { /* block id: 335 */
            int32_t l_510 = 0x5D6FAA04L;
            int32_t **l_513 = &l_47;
            (*l_457) = l_510;
            for (l_508 = 0; (l_508 == 3); l_508 += 1)
            { /* block id: 339 */
                int32_t *l_514 = &l_450;
                (*l_452) = func_39((l_513 == &l_47), l_510, l_514);
                /* statement id: 340 */
                assert (l_47 == &l_450);
            }
        }
    }
    /* facts after for loop */
    //assert (l_47 == dangling || l_47 == 0 || l_47 == &l_450);
    for (l_48 = 24; (l_48 > 22); --l_48)
    { /* block id: 346 */
        (*l_452) = (void*)0;
        /* statement id: 347 */
        assert (l_47 == 0);
    }
    if (((-9L) || ((int16_t)(func_36(&l_450, ((void*)0 == l_519)) != ((uint64_t)((-1L) != ((int32_t)(!((*l_519) != (void*)0)) + (int32_t)((uint64_t)l_509 + (uint64_t)l_484))) / (uint64_t)l_529)) / (int16_t)0x3280L)))
    { /* block id: 349 */
        int32_t *l_530 = (void*)0;
        int32_t l_531 = (-1L);
        l_48 = ((l_530 == (void*)0) != l_531);
    }
    else
    { /* block id: 351 */
        int32_t *l_532 = &l_48;
        int32_t l_533 = 8L;
        (**l_521) = l_532;
        /* statement id: 352 */
        assert (l_47 == &l_48);
        return l_533;
    }
    return l_534;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_31(uint32_t  p_32)
{ /* block id: 297 */
    int32_t *l_451 = (void*)0;
    l_451 = (void*)0;
    return l_451;
    /* statement id: 299 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_36(int32_t * p_37, int16_t  p_38)
{ /* block id: 293 */
    int32_t l_443 = 0x40752941L;
    int32_t *l_442 = &l_443;
    int32_t **l_441 = &l_442;
    int8_t l_444 = 0x45L;
    (*l_441) = p_37;
    /* statement id: 294 */
    //assert (l_442 == &l_48 || l_442 == &l_450);
    (*p_37) = ((p_38 > l_444) | __builtin_ctzl(((((uint64_t)(**l_441) % (uint64_t)(~0x80AEL)) && ((void*)0 == &p_37)) > func_82(p_37, (*l_441)))));
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_39(int16_t  p_40, uint64_t  p_41, int32_t * p_42)
{ /* block id: 242 */
    uint16_t l_328 = 65530UL;
    int32_t l_331 = 0xA5CBA992L;
    int32_t *l_330 = &l_331;
    int32_t **l_356 = &l_330;
    int32_t ***l_355 = &l_356;
    int32_t ****l_354 = &l_355;
    int32_t *****l_353 = &l_354;
    int32_t *l_359 = &l_331;
    if ((~l_328))
    { /* block id: 243 */
        int32_t **l_329 = (void*)0;
        l_330 = p_42;
        /* statement id: 244 */
        //assert (l_330 == &l_48 || l_330 == &l_494 || l_330 == &l_499 || l_330 == &l_450);
        return p_42;
        /* statement id: 245 */
        //assert (func_39_rv == &l_48 || func_39_rv == &l_494 || func_39_rv == &l_499 || func_39_rv == &l_450);
    }
    else
    { /* block id: 246 */
        int8_t l_350 = 0x70L;
        int32_t *l_358 = (void*)0;
        int8_t l_388 = (-1L);
        int32_t ****l_416 = &l_355;
lbl_440:
        for (p_41 = 0; (p_41 > 9); p_41 += 1)
        { /* block id: 249 */
            int64_t l_344 = 0x18014C4CC2631A32LL;
            (*l_330) = (((uint64_t)((uint16_t)func_92((4UL != ((((int16_t)(((uint16_t)((int32_t)((0xE312L && l_344) | 1UL) % (int32_t)((int32_t)(18446744073709551611UL || (p_40 ^ (p_40 <= ((!((uint16_t)l_350 * (uint16_t)(l_344 & (*p_42)))) == p_40)))) - (int32_t)(*p_42))) * (uint16_t)l_350) & p_41) >> (int16_t)3) != (*l_330)) & p_41)), (*l_330), (*p_42), l_350, p_41) << (uint16_t)p_41) % (uint64_t)(*l_330)) & l_350);
        }
        for (l_328 = 0; (l_328 <= 1); l_328 += 1)
        { /* block id: 254 */
            int16_t l_357 = 0x315EL;
            int16_t l_363 = 1L;
            int32_t *****l_373 = &l_354;
            int32_t *l_378 = (void*)0;
        }
        if (l_328)
            goto lbl_440;
    }
    return p_42;
    /* statement id: 292 */
    //assert (func_39_rv == &l_48 || func_39_rv == &l_494 || func_39_rv == &l_499 || func_39_rv == &l_450);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_52(int32_t * p_53, int32_t * p_54, uint32_t  p_55)
{ /* block id: 37 */
    int32_t l_68 = (-1L);
    int32_t *l_144 = &l_68;
    int32_t **l_157 = (void*)0;
    int32_t ***l_156 = &l_157;
    int32_t ****l_155 = &l_156;
    int32_t *****l_207 = &l_155;
    int32_t *l_225 = &l_68;
    int32_t l_240 = 0x197A97A6L;
    int32_t *****l_284 = (void*)0;
    int32_t l_317 = 1L;
    int32_t l_326 = (-6L);
    for (p_55 = 0; (p_55 <= 46); p_55 += 3)
    { /* block id: 40 */
        int32_t *l_85 = (void*)0;
        int64_t l_126 = 0x3F7513D964400D43LL;
        int32_t *l_130 = &l_68;
        int64_t l_131 = 0xE448D75FB7473AC0LL;
        const int32_t ***l_204 = (void*)0;
        const int32_t ****l_203 = &l_204;
        int32_t l_206 = (-8L);
    }
    if (((void*)0 != p_54))
    { /* block id: 183 */
        uint32_t l_278 = 18446744073709551609UL;
        int32_t *l_281 = &l_68;
        if ((((uint16_t)p_55 / (uint16_t)p_55) | 0xEDC84E98L))
        { /* block id: 184 */
            int32_t *l_265 = &l_68;
            int32_t *****l_269 = &l_155;
            for (l_68 = 0; (l_68 < (-15)); --l_68)
            { /* block id: 187 */
                int32_t **l_266 = &l_144;
                p_53 = l_265;
                /* statement id: 188 */
                assert (p_53 == &l_68);
                (*l_266) = p_53;
                p_53 = func_74(((int16_t)0L - (int16_t)((l_269 != l_269) >= ((int64_t)((uint16_t)((int16_t)p_55 * (int16_t)((uint32_t)l_278 - (uint32_t)(p_55 > __builtin_ctzl((**l_266))))) % (uint16_t)p_55) - (int64_t)p_55))), (*l_266));
            }
            /* facts after for loop */
            //assert (p_53 == &l_68 || p_53 == &l_48);
            (*l_225) = ((int32_t)l_278 + (int32_t)((*l_207) == (*l_207)));
            (*l_265) = (*p_54);
            (*l_265) = (*p_54);
        }
        else
        { /* block id: 195 */
            int32_t *l_282 = &l_68;
            l_281 = func_74((((*p_54) == p_55) >= (l_281 == l_281)), l_282);
            if (p_55)
                goto lbl_283;
            l_282 = p_53;
            /* statement id: 197 */
            //assert (l_282 == &l_48);
lbl_283:
            (*l_225) = (*l_225);
            l_207 = l_284;
            /* statement id: 200 */
            assert (l_207 == 0);
        }
        /* facts after branching */
        //assert (p_53 == &l_68 || p_53 == &l_48);
        assert (l_207 == 0 || l_207 == &l_155);
        for (l_278 = (-18); (l_278 <= 3); l_278 += 3)
        { /* block id: 204 */
            int64_t l_299 = 0xC80D2B85DA368D0BLL;
            p_54 = func_74(p_55, p_53);
            for (l_240 = 0; (l_240 > (-15)); l_240--)
            { /* block id: 208 */
                int32_t **l_289 = &l_225;
                int32_t l_294 = (-4L);
                const int32_t *l_300 = &l_68;
                (*l_289) = func_74((*l_281), p_54);
                if (((((int64_t)p_55 % (int64_t)((**l_289) & ((**l_289) <= (**l_289)))) >= (*l_281)) >= __builtin_popcount(l_294)))
                { /* block id: 210 */
                    for (p_55 = 0; (p_55 == 37); p_55 += 1)
                    { /* block id: 213 */
                        if ((*p_53))
                            break;
                    }
                    for (l_294 = 3; (l_294 >= (-24)); --l_294)
                    { /* block id: 218 */
                        return l_299;
                    }
                }
                else
                { /* block id: 221 */
                    int32_t **l_301 = &l_281;
                    (*l_301) = l_300;
                }
            }
        }
        /* facts after for loop */
        //assert (p_54 == &l_68 || p_54 == &l_48);
        //assert (l_225 == &l_68 || l_225 == &l_48);
    }
    else
    { /* block id: 226 */
        uint32_t l_305 = 0xD3C6D8B2L;
        int32_t *l_316 = (void*)0;
        (*l_144) = (-(uint16_t)((int16_t)l_305 % (int16_t)((*p_53) ^ ((__builtin_popcountll(((int64_t)(&p_54 == &p_54) + (int64_t)((((int16_t)p_55 - (int16_t)0x66C5L) <= (p_55 != ((int16_t)5L % (int16_t)((uint16_t)((uint16_t)func_82(l_316, p_54) << (uint16_t)6) >> (uint16_t)p_55)))) & 0xCF6FL))) <= l_317) >= (*l_144)))));
        (*l_144) = (*p_53);
        for (p_55 = 0; (p_55 != 36); p_55 += 1)
        { /* block id: 231 */
            for (l_305 = 0; (l_305 == 1); l_305 += 1)
            { /* block id: 234 */
                (*l_144) = ((int64_t)p_55 - (int64_t)1UL);
            }
            (*l_225) = (*l_144);
        }
        (*l_225) = (func_62(((**l_207) == (*l_155)), p_55, p_53, (*l_225), p_53) < (*l_144));
    }
    /* facts after branching */
    //assert (p_53 == &l_68 || p_53 == &l_48);
    //assert (p_54 == &l_68 || p_54 == &l_48);
    assert (l_207 == 0 || l_207 == &l_155);
    //assert (l_225 == &l_68 || l_225 == &l_48);
    return l_326;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_62(uint32_t  p_63, int16_t  p_64, int32_t * p_65, int64_t  p_66, int32_t * p_67)
{ /* block id: 68 */
    int32_t l_129 = (-10L);
    int32_t *l_128 = &l_129;
    int32_t **l_127 = &l_128;
    (*l_127) = (void*)0;
    /* statement id: 69 */
    assert (l_128 == 0);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_69(int32_t * p_70, const int64_t  p_71, int32_t  p_72, int64_t  p_73)
{ /* block id: 66 */
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads : l_48
 * writes:
 */
static int32_t * func_74(int16_t  p_75, int32_t * p_76)
{ /* block id: 49 */
    uint16_t l_114 = 0x03F4L;
    int32_t *l_115 = (void*)0;
    int32_t l_117 = 0x638AA3AEL;
    int32_t *l_116 = &l_117;
    (*l_116) = l_114;
    if ((*l_116))
    { /* block id: 51 */
lbl_125:
        (*l_116) = func_82(&l_117, &l_117);
        return p_76;
        /* statement id: 53 */
        //assert (func_74_rv == &l_48 || func_74_rv == &l_68 || func_74_rv == &l_206 || func_74_rv == &l_331 || func_74_rv == &l_499);
    }
    else
    { /* block id: 54 */
        int32_t l_121 = 0x91F4D940L;
        int32_t **l_122 = &l_115;
        (*l_116) = (!((int64_t)l_121 - (int64_t)((void*)0 == l_122)));
        for (l_117 = (-11); (l_117 <= 16); l_117 += 1)
        { /* block id: 58 */
            (*l_122) = p_76;
            /* statement id: 59 */
            //assert (l_115 == &l_48 || l_115 == &l_68 || l_115 == &l_206 || l_115 == &l_331 || l_115 == &l_499);
            (*l_122) = p_76;
            if (l_117)
                goto lbl_125;
        }
        /* facts after for loop */
        //assert (l_115 == &l_48 || l_115 == 0 || l_115 == &l_68 || l_115 == &l_206 || l_115 == &l_331 || l_115 == &l_499);
    }
    /* facts after branching */
    //assert (l_115 == &l_48 || l_115 == 0 || l_115 == &l_68 || l_115 == &l_206 || l_115 == &l_331 || l_115 == &l_499);
    (*l_116) = (*p_76);
    return p_76;
    /* statement id: 65 */
    //assert (func_74_rv == &l_48 || func_74_rv == &l_68 || func_74_rv == &l_206 || func_74_rv == &l_331 || func_74_rv == &l_499);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_82(int32_t * p_83, int32_t * p_84)
{ /* block id: 41 */
    uint32_t l_98 = 1UL;
    int32_t l_100 = 1L;
    int32_t *l_99 = &l_100;
    uint16_t l_103 = 0x571BL;
    const uint32_t l_113 = 0xCAFB12B2L;
    (*l_99) = ((uint16_t)((uint64_t)((int64_t)func_92(l_98, ((p_84 != l_99) & ((int32_t)l_103 / (int32_t)1L)), (*l_99), __builtin_clzl((*l_99)), (*l_99)) / (int64_t)(*l_99)) + (uint64_t)4L) * (uint16_t)0x8795L);
    return l_113;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_92(int32_t  p_93, int8_t  p_94, int32_t  p_95, int32_t  p_96, uint32_t  p_97)
{ /* block id: 42 */
    int32_t *l_105 = (void*)0;
    int32_t **l_104 = &l_105;
    const int32_t ***l_106 = (void*)0;
    const int32_t *l_109 = (void*)0;
    const int32_t **l_108 = &l_109;
    const int32_t ***l_107 = &l_108;
    int32_t l_111 = 1L;
    int32_t *l_110 = &l_111;
    int64_t l_112 = 5L;
    (*l_107) = l_104;
    /* statement id: 43 */
    assert (l_108 == &l_105);
    (*l_110) = p_97;
    (*l_107) = (*l_107);
    return l_112;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 127
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 20
   depth: 3, occurrence: 7
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 2

XXX total number of pointers: 111

XXX times a variable address is taken: 106
XXX times a pointer is dereferenced on RHS: 129
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 19
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 82
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 20
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 607

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 489
   level: 2, occurrence: 68
   level: 3, occurrence: 47
   level: 4, occurrence: 29
   level: 5, occurrence: 30
XXX number of pointers point to pointers: 58
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.6
XXX average alias set size: 1.5

XXX times a non-volatile is read: 709
XXX times a non-volatile is write: 237
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 23
   depth: 2, occurrence: 24
   depth: 3, occurrence: 16
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 16
XXX percentage an existing variable is used: 84
********************* end of statistics **********************/

