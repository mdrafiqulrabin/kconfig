/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --no-structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2440364020
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
   uint16_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_26(void);
static int32_t * func_30(int16_t  p_31, uint32_t  p_32, int16_t  p_33, int32_t * p_34);
static int32_t  func_38(int32_t * p_39, int32_t * p_40, int32_t * p_41);
static int32_t * func_42(int32_t  p_43, int32_t * p_44, uint8_t  p_45, int16_t  p_46);
inline static uint16_t  func_57(int32_t * p_58, int32_t ** p_59, int32_t  p_60, uint16_t  p_61);
static int32_t * func_62(int16_t  p_63, int32_t * p_64, int32_t * p_65, uint8_t  p_66);
static int32_t * func_68(int32_t *** p_69, int16_t  p_70, uint8_t  p_71, int32_t  p_72, uint8_t  p_73);
static int16_t  func_79(int32_t  p_80);
inline static uint32_t  func_81(int32_t * p_82);
inline static int32_t * func_89(int32_t * p_90, const int16_t  p_91, int32_t * p_92, int32_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_26(void)
{ /* block id: 36 */
    int32_t l_27 = 0;
    uint16_t l_48 = 0x0466;
    int32_t *l_407 = &l_27;
    int32_t **l_412 = (void*)0;
    int32_t ***l_411 = &l_412;
    int32_t ****l_410 = &l_411;
    int32_t *****l_409 = &l_410;
    union U0 l_433 = {0x57A9};
    union U0 *l_432 = &l_433;
    int16_t l_466 = 0x101E;
    uint8_t l_471 = 0xC1;
    uint16_t l_492 = 0xDC8B;
    const uint16_t l_496 = 0x916C;
    int32_t l_500 = 0x3B781DC5;
    int32_t **l_503 = &l_407;
    union U0 l_504 = {65535U};
    for (l_27 = (-27); (l_27 > 0); l_27 += 4)
    { /* block id: 39 */
        uint16_t l_35 = 65535U;
        uint8_t l_47 = 255U;
        int32_t *l_375 = &l_27;
        int32_t **l_403 = &l_375;
        (*l_403) = func_30(l_27, (l_35 > ((int32_t)((func_38(func_42(l_35, &l_27, l_47, l_48), &l_27, l_375) && (*l_375)) == (-1)) % (int32_t)4294967291U)), (*l_375), l_375);
    }
    if (l_27)
    { /* block id: 279 */
        int32_t *l_406 = &l_27;
        union U0 *l_434 = &l_433;
        int32_t ****l_437 = (void*)0;
        uint16_t l_453 = 0x4A76;
        int16_t l_465 = 0x63B3;
        int32_t *l_494 = &l_27;
        int32_t *l_495 = &l_27;
        for (l_48 = 28; (l_48 >= 25); l_48 -= 6)
        { /* block id: 282 */
            int32_t l_408 = 0xBA47CB31;
            int32_t ***l_414 = &l_412;
            int16_t l_438 = 0x9E7D;
            int32_t l_439 = 3;
            union U0 l_440 = {1U};
            union U0 *l_473 = &l_440;
        }
        l_495 = l_494;
        l_406 = func_89(l_494, l_496, l_406, __builtin_ffsl((*l_494)));
        l_406 = &l_27;
    }
    else
    { /* block id: 329 */
        (*l_407) = __builtin_clz((*l_407));
        (*l_407) = 0xABC095B8;
    }
    (*l_503) = &l_27;
    return l_504;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_30(int16_t  p_31, uint32_t  p_32, int16_t  p_33, int32_t * p_34)
{ /* block id: 270 */
    int32_t l_394 = 1;
    int32_t *l_393 = &l_394;
    int32_t **l_392 = &l_393;
    int32_t l_395 = 0xE7069F1B;
    if ((((int16_t)func_57(p_34, l_392, p_31, (((**l_392) < __builtin_ctz(l_395)) == ((*l_393) | ((uint16_t)(((uint16_t)((int16_t)(*l_393) >> (int16_t)((-8) || 0x38D1F01A)) << (uint16_t)p_32) || 0xD96A4606) << (uint16_t)11)))) - (int16_t)p_33) || 65528U))
    { /* block id: 271 */
        int32_t *l_402 = (void*)0;
        return l_402;
    }
    else
    { /* block id: 273 */
        (*l_392) = (*l_392);
    }
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_38(int32_t * p_39, int32_t * p_40, int32_t * p_41)
{ /* block id: 266 */
    int32_t l_376 = 0xBCC31C59;
    int32_t l_378 = 0x855E6FC1;
    int32_t *l_377 = &l_378;
    union U0 l_382 = {0x33CA};
    union U0 *l_381 = &l_382;
    uint16_t l_389 = 0x73B8;
    (*l_377) = l_376;
    (*l_377) = ((uint16_t)(l_381 != (void*)0) >> (uint16_t)((int32_t)(((uint32_t)(*l_377) + (uint32_t)((*l_377) >= (0xEBC7 & ((uint16_t)1U % (uint16_t)(((*l_377) | 0) && ((-4) == (*l_377))))))) < 4294967288U) + (int32_t)(*p_41)));
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_42(int32_t  p_43, int32_t * p_44, uint8_t  p_45, int16_t  p_46)
{ /* block id: 40 */
    int32_t l_52 = 0x193FE696;
    int32_t *l_51 = &l_52;
    int32_t **l_50 = &l_51;
    int32_t ***l_49 = &l_50;
    int16_t l_144 = (-2);
    int32_t ****l_251 = &l_49;
    int32_t *****l_250 = &l_251;
    int32_t l_281 = 0;
    uint32_t l_297 = 0x03924B46;
    uint32_t l_364 = 0x7CEEA620;
    int32_t *l_374 = (void*)0;
    (*l_49) = &p_44;
    for (p_46 = 0; (p_46 != 12); p_46 += 2)
    { /* block id: 44 */
        uint16_t l_67 = 0x914A;
        int32_t ***l_74 = &l_50;
        int32_t *l_283 = &l_52;
        (*l_51) = ((uint16_t)func_57(func_62(l_67, func_68(l_74, ((((int16_t)(((uint32_t)(((0x4B1C | func_79((func_81(p_44) && ((p_43 ^ ((((uint16_t)(p_43 ^ p_45) % (uint16_t)(-1)) || (*p_44)) & 0xAB19369D)) >= 4294967295U)))) || 0U) < 8) + (uint32_t)(***l_74)) >= (***l_74)) << (int16_t)p_46) & 4294967290U) ^ p_43), l_144, p_46, p_43), p_44, (***l_49)), (*l_74), p_46, p_45) << (uint16_t)p_43);
        (*l_51) = (***l_74);
        for (l_67 = 0; (l_67 >= 19); l_67 += 3)
        { /* block id: 173 */
            int32_t **l_246 = &l_51;
            int32_t *****l_274 = &l_251;
            int32_t *l_282 = &l_52;
        }
        for (p_45 = 0; (p_45 < 51); p_45++)
        { /* block id: 212 */
            int32_t l_294 = 0xFE75ABED;
            int32_t l_317 = (-9);
            int32_t l_337 = 0;
            (*l_51) = 7;
            (*l_283) = ((int16_t)p_43 << (int16_t)14);
            for (l_144 = 0; (l_144 == 5); l_144 += 4)
            { /* block id: 217 */
                int32_t *l_310 = &l_294;
                const int32_t l_313 = 3;
                int32_t *l_314 = &l_52;
                if (((uint16_t)((uint32_t)l_294 + (uint32_t)(((uint32_t)(((__builtin_parityl(p_46) ^ (l_297 >= (((int16_t)0xC896 + (int16_t)((int16_t)((int32_t)((int16_t)((int16_t)((uint32_t)__builtin_clzl(func_57(l_310, &l_310, p_46, ((((uint16_t)(*****l_250) + (uint16_t)(**l_50)) | p_46) & (*p_44)))) - (uint32_t)0x7FAE3E55) >> (int16_t)(**l_50)) << (int16_t)2) - (int32_t)0xB5579BDA) >> (int16_t)l_294)) < p_43))) < p_46) | p_46) + (uint32_t)p_46) < l_313)) - (uint16_t)0x16EC))
                { /* block id: 218 */
                    if ((*p_44))
                    { /* block id: 219 */
                        if ((*l_283))
                            break;
                    }
                    else
                    { /* block id: 221 */
                        (**l_49) = l_314;
                    }
                    (***l_251) = p_44;
                    for (l_294 = 0; (l_294 <= 7); l_294 += 9)
                    { /* block id: 227 */
                        if ((*p_44))
                            break;
                        l_317 = (*p_44);
                        (*l_51) = 0xBAB025D6;
                    }
                    (*l_314) = ((int16_t)1 % (int16_t)((int16_t)((int16_t)(((int16_t)__builtin_ctz(l_317) << (int16_t)4) != (*l_310)) >> (int16_t)0) << (int16_t)((int16_t)l_294 >> (int16_t)15)));
                }
                else
                { /* block id: 233 */
                    uint32_t l_338 = 0x40D87D5F;
                    for (l_297 = (-4); (l_297 <= 3); l_297 += 1)
                    { /* block id: 236 */
                        union U0 l_331 = {0U};
                        union U0 *l_330 = &l_331;
                        union U0 **l_332 = &l_330;
                        (*l_49) = &p_44;
                        (*l_332) = l_330;
                    }
                    (*l_310) = (((int16_t)p_43 >> (int16_t)((int16_t)l_337 + (int16_t)l_338)) > (__builtin_ffsl((((int32_t)__builtin_bswap32((((uint16_t)(***l_74) >> (uint16_t)5) ^ (1U == l_294))) + (int32_t)4294967293U) > ((int16_t)((uint16_t)p_46 - (uint16_t)0U) % (int16_t)0x3952))) == 0x748AC127));
                }
            }
        }
    }
    (*l_51) = (*p_44);
    if ((*****l_250))
    { /* block id: 246 */
        int32_t ****l_353 = &l_49;
        for (l_297 = 4; (l_297 <= 43); l_297 += 1)
        { /* block id: 249 */
            if ((*p_44))
                break;
            if ((*p_44))
                break;
        }
        (*l_51) = ((int16_t)((((int16_t)((l_353 == (*l_250)) <= (****l_353)) << (int16_t)8) & (((****l_353) < (~(**l_50))) | (((uint16_t)((-(int16_t)(*l_51)) > ((int16_t)(***l_49) << (int16_t)3)) % (uint16_t)(****l_353)) ^ (*l_51)))) != 0x07B4E46D) + (int16_t)p_43);
    }
    else
    { /* block id: 254 */
        uint32_t l_370 = 4294967295U;
        int32_t ***l_371 = &l_50;
        int32_t *****l_373 = &l_251;
        (****l_250) = p_44;
        for (l_281 = 25; (l_281 < 7); l_281--)
        { /* block id: 258 */
            uint8_t l_365 = 0x6A;
            int32_t *l_372 = (void*)0;
            (*l_51) = ((uint16_t)(l_364 == l_365) + (uint16_t)((uint16_t)(l_365 == ((uint16_t)((((void*)0 == p_44) || 0xF5B7) != l_370) + (uint16_t)((*p_44) >= ((void*)0 != l_371)))) >> (uint16_t)p_43));
            (*l_51) = func_57(l_372, &p_44, (&l_251 == l_373), p_45);
            if ((*p_44))
                continue;
        }
        (****l_250) = (void*)0;
    }
    return l_374;
}


/* ------------------------------------------ */
/* 
 * reads : l_27
 * writes:
 */
inline static uint16_t  func_57(int32_t * p_58, int32_t ** p_59, int32_t  p_60, uint16_t  p_61)
{ /* block id: 165 */
    uint32_t l_239 = 4294967295U;
    int32_t l_241 = 0x97BB59C8;
    int32_t *l_240 = &l_241;
    uint8_t l_242 = 0xCA;
    (*l_240) = l_239;
    (*p_59) = func_62((*l_240), (*p_59), (*p_59), p_61);
    return l_242;
}


/* ------------------------------------------ */
/* 
 * reads : l_27 l_52 l_294 l_394
 * writes:
 */
static int32_t * func_62(int16_t  p_63, int32_t * p_64, int32_t * p_65, uint8_t  p_66)
{ /* block id: 84 */
    int16_t l_151 = (-7);
    int32_t l_165 = 0x6EC4B94A;
    int32_t *l_164 = &l_165;
    int32_t **l_227 = &l_164;
    int32_t ***l_226 = &l_227;
    l_151 = (&p_64 == (void*)0);
    for (l_151 = 0; (l_151 >= 3); l_151++)
    { /* block id: 88 */
        uint32_t l_156 = 9U;
        int32_t l_161 = 0x5439C88B;
        l_161 = ((uint16_t)l_156 - (uint16_t)((uint16_t)((int16_t)l_151 << (int16_t)1) << (uint16_t)p_63));
    }
    for (p_63 = 0; (p_63 > (-30)); p_63 -= 5)
    { /* block id: 93 */
        int32_t **l_166 = &l_164;
        (*l_166) = l_164;
        for (p_66 = 0; (p_66 <= 26); p_66 += 8)
        { /* block id: 97 */
            uint32_t l_169 = 1U;
            (*l_164) = (l_169 || p_63);
            if ((p_65 != p_65))
            { /* block id: 99 */
                uint16_t l_172 = 0x9281;
                (*l_164) = ((uint16_t)__builtin_bswap32(l_172) << (uint16_t)p_63);
                if ((*p_65))
                    break;
            }
            else
            { /* block id: 102 */
                for (l_165 = 0; (l_165 == 1); l_165 += 8)
                { /* block id: 105 */
                    for (l_151 = 0; (l_151 >= 29); l_151 += 1)
                    { /* block id: 108 */
                        int32_t l_178 = (-10);
                        int32_t *l_177 = &l_178;
                        (*l_177) = (*p_64);
                        if ((*p_65))
                            continue;
                        (*l_177) = __builtin_popcountll((*l_164));
                        if ((*p_65))
                            break;
                    }
                }
            }
        }
        (*l_166) = &l_165;
        return p_65;
    }
    if (((int32_t)0x608B997A % (int32_t)((uint16_t)func_81(p_65) - (uint16_t)((*l_164) <= (&l_165 == &l_165)))))
    { /* block id: 120 */
        int16_t l_185 = 0xBDB4;
        int32_t **l_186 = &l_164;
        const uint16_t l_199 = 8U;
        (*l_164) = (((int16_t)l_185 << (int16_t)0) && p_63);
        (*l_186) = p_65;
        if ((*p_65))
        { /* block id: 123 */
            (*l_186) = (void*)0;
        }
        else
        { /* block id: 125 */
            uint8_t l_200 = 0xB5;
            if ((*p_65))
            { /* block id: 126 */
                uint8_t l_189 = 0x20;
                int32_t ***l_191 = &l_186;
                int32_t ****l_190 = &l_191;
                int32_t ***l_198 = &l_186;
                int16_t l_201 = 0;
                if ((p_63 == (((uint16_t)1U << (uint16_t)7) ^ p_66)))
                { /* block id: 127 */
                    int32_t *****l_192 = &l_190;
                    l_189 = (*p_65);
                    (*l_192) = l_190;
                    (*l_186) = &l_165;
                    if (((void*)0 != &p_64))
                    { /* block id: 131 */
                        int16_t l_195 = 0xFE2E;
                        (*****l_192) = (p_63 && (((uint16_t)(0xA1A4 | (l_195 || func_81(p_64))) - (uint16_t)p_63) > (5U <= 65532U)));
                        (**l_186) = ((((int32_t)((p_63 < (0U || 8)) >= (*p_65)) - (int32_t)((**l_192) != l_198)) <= (l_199 && l_200)) > p_63);
                        l_201 = (p_66 ^ ((void*)0 != &l_190));
                    }
                    else
                    { /* block id: 135 */
                        int16_t l_203 = 4;
                        (***l_191) = ((!l_203) == p_63);
                        (***l_191) = (!p_66);
                    }
                }
                else
                { /* block id: 139 */
                    return p_65;
                }
            }
            else
            { /* block id: 142 */
                int32_t l_205 = 0xBE6BB753;
                l_205 = (l_205 != p_66);
            }
            p_64 = p_65;
        }
    }
    else
    { /* block id: 147 */
        uint8_t l_217 = 0x37;
        if ((*l_164))
        { /* block id: 148 */
            uint32_t l_206 = 1U;
            int32_t **l_222 = &l_164;
            int32_t ***l_221 = &l_222;
            int32_t **l_232 = (void*)0;
            (*l_164) = ((0x6772AFA6 == 1U) || (func_81(&l_165) | (((l_206 >= p_66) == ((uint32_t)(0x4AB5 || ((p_66 < func_79(((l_206 || p_63) < 3U))) != p_66)) + (uint32_t)(*p_64))) <= (-1))));
            if (__builtin_ffsll(((uint16_t)(l_206 != (-1)) << (uint16_t)(((int32_t)(((uint16_t)((uint16_t)0xE342 >> (uint16_t)13) >> (uint16_t)func_79(p_66)) || l_206) + (int32_t)l_217) != (l_217 != __builtin_ffsll((p_66 == 0x78C6F71F)))))))
            { /* block id: 150 */
                return p_65;
            }
            else
            { /* block id: 152 */
                int16_t l_223 = 0x5DB1;
                const int32_t *l_231 = (void*)0;
                const int32_t **l_230 = &l_231;
                const int32_t ***l_229 = &l_230;
                const int32_t ****l_228 = &l_229;
                l_223 = ((int32_t)(~func_79((l_221 == (void*)0))) % (int32_t)(*l_164));
                (***l_221) = ((int16_t)p_66 - (int16_t)l_223);
                (*l_228) = l_226;
            }
            (**l_222) = (((*l_226) == l_232) & (((int32_t)(*p_65) % (int32_t)l_217) & (0xA6299ED9 <= func_79(((uint32_t)(!((-(int32_t)l_217) && (l_217 ^ 4294967289U))) - (uint32_t)((***l_226) | 0x03EBDBDE))))));
            (*l_221) = (*l_226);
        }
        else
        { /* block id: 159 */
            (***l_226) = 1;
        }
        (*l_164) = (*p_64);
    }
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_68(int32_t *** p_69, int16_t  p_70, uint8_t  p_71, int32_t  p_72, uint8_t  p_73)
{ /* block id: 81 */
    int32_t l_148 = 7;
    int32_t *l_147 = &l_148;
    int32_t **l_146 = &l_147;
    int32_t ***l_145 = &l_146;
    const int32_t ***l_150 = (void*)0;
    const int32_t ****l_149 = &l_150;
    (*l_149) = l_145;
    return (**p_69);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_79(int32_t  p_80)
{ /* block id: 76 */
    int32_t l_137 = 8;
    int32_t *l_136 = &l_137;
    int32_t **l_142 = &l_136;
    int32_t ***l_143 = &l_142;
    (*l_142) = func_89(l_136, (((int16_t)(((p_80 >= ((uint16_t)((*l_136) && 4294967295U) >> (uint16_t)6)) & ((*l_136) == ((func_81(&l_137) ^ (1 >= func_81(&l_137))) && (*l_136)))) & p_80) >> (int16_t)0) == p_80), &l_137, (*l_136));
    (*l_143) = &l_136;
    (*l_142) = (*l_142);
    return p_80;
}


/* ------------------------------------------ */
/* 
 * reads : l_27 l_52 l_254 l_294 l_394
 * writes:
 */
inline static uint32_t  func_81(int32_t * p_82)
{ /* block id: 45 */
    int32_t l_83 = 0xBF68D270;
    int32_t l_131 = 0xE5B6057B;
    int32_t *l_130 = &l_131;
    int32_t *l_132 = &l_83;
    uint8_t l_133 = 1U;
    for (l_83 = 0; (l_83 != 23); l_83 += 1)
    { /* block id: 48 */
        int32_t *l_86 = (void*)0;
        int32_t l_88 = 0x2F725DC8;
        int32_t *l_87 = &l_88;
        int16_t l_107 = (-1);
        int32_t **l_129 = (void*)0;
        (*l_87) = 0x0245597E;
        l_130 = func_89(&l_88, l_83, &l_88, ((0x6F6D7797 < (*l_87)) >= ((uint16_t)(l_83 & ((uint32_t)((int32_t)(l_83 > ((!(((int16_t)l_83 - (int16_t)((uint16_t)(((uint16_t)(*l_87) << (uint16_t)14) >= (*p_82)) - (uint16_t)l_107)) & (*l_87))) == l_83)) % (int32_t)(*p_82)) - (uint32_t)0x2DC6606A)) >> (uint16_t)6)));
        (*l_87) = ((*l_130) && 0U);
    }
    (*l_132) = __builtin_popcountl(l_131);
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_89(int32_t * p_90, const int16_t  p_91, int32_t * p_92, int32_t  p_93)
{ /* block id: 50 */
    int32_t l_111 = 8;
    int32_t l_114 = 0x38CF8356;
    int32_t *l_113 = &l_114;
    if (((((*p_92) == ((uint16_t)p_93 >> (uint16_t)(~p_91))) | (((-1) == l_111) == (p_91 | 0xFA5B))) > (l_111 ^ ((!l_111) > l_111))))
    { /* block id: 51 */
        p_90 = p_92;
        (*p_92) = l_111;
        (*p_92) = (*p_92);
    }
    else
    { /* block id: 55 */
        int32_t **l_115 = &l_113;
        (*l_115) = l_113;
    }
    for (l_111 = 0; (l_111 >= 14); l_111 += 1)
    { /* block id: 60 */
        int32_t **l_118 = &l_113;
        (*l_118) = p_92;
        if (((((p_91 != p_91) ^ ((int16_t)0x6160 % (int16_t)((uint32_t)(((*l_113) ^ ((uint16_t)0xC718 >> (uint16_t)14)) < 0x64D7) % (uint32_t)6))) ^ 4294967295U) <= (__builtin_clzl((**l_118)) != 0x219E)))
        { /* block id: 62 */
            (*p_92) = ((uint16_t)p_93 % (uint16_t)p_93);
        }
        else
        { /* block id: 64 */
            uint32_t l_127 = 0x319DC099;
            (**l_118) = (*p_92);
            (*p_90) = __builtin_bswap64(l_127);
        }
    }
    (*l_113) = ((~(&p_92 == &p_90)) < (*l_113));
    return p_90;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 122
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 148
   depth: 2, occurrence: 31
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 25, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 107

XXX times a variable address is taken: 110
XXX times a pointer is dereferenced on RHS: 142
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 15
   depth: 3, occurrence: 16
   depth: 4, occurrence: 5
   depth: 5, occurrence: 4
XXX times a pointer is dereferenced on LHS: 85
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 11
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 499

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 729
   level: 2, occurrence: 92
   level: 3, occurrence: 123
   level: 4, occurrence: 45
   level: 5, occurrence: 29
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 15.9
XXX average alias set size: 1.58

XXX times a non-volatile is read: 682
XXX times a non-volatile is write: 249
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 131
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 37
   depth: 2, occurrence: 21
   depth: 3, occurrence: 10
   depth: 4, occurrence: 12
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 20.3
XXX percentage an existing variable is used: 79.7
********************* end of statistics **********************/

