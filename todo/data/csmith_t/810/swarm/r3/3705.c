/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      372005146
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static volatile int32_t g_2 = (-1);/* VOLATILE GLOBAL g_2 */
static int32_t g_3 = (-3);
static uint16_t g_50 = 65534U;
static int32_t g_53 = (-8);
static int32_t g_89 = 0;
static int32_t *g_88 = &g_89;
static int32_t **g_100 = &g_88;
static int32_t ***g_99 = &g_100;
static int32_t **** volatile g_98 = &g_99;/* VOLATILE GLOBAL g_98 */
static uint32_t g_105 = 0xA97CAD95;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static uint16_t  func_10(const int32_t  p_11, int32_t  p_12, float  p_13, uint16_t  p_14);
static int32_t  func_17(uint32_t  p_18, uint32_t  p_19, int16_t  p_20);
static int16_t  func_25(uint16_t  p_26);
static uint16_t  func_27(uint32_t  p_28, const uint32_t  p_29, uint32_t  p_30, uint32_t  p_31, uint32_t  p_32);
static int32_t * func_44(int16_t  p_45);
static float  func_62(int32_t  p_63, int32_t ** p_64, float  p_65);
static int16_t  func_68(uint32_t  p_69, int32_t * p_70, int32_t  p_71, uint32_t  p_72, int16_t  p_73);
static uint32_t  func_74(uint32_t  p_75, int32_t ** p_76);
static int32_t * func_84(int32_t  p_85, const int16_t  p_86, int32_t * p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_88 g_98 g_99 g_100 g_89 g_2 g_53 g_50 g_105
 * writes: g_3 g_88
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    int16_t l_8 = 1;
    uint32_t l_77 = 0xD4A52D86;
    int32_t *l_79 = &g_3;
    int32_t **l_78 = &l_79;
    int32_t ***l_122 = (void*)0;
    int32_t ** const l_141 = &l_79;
    int32_t l_142 = 0xF5884173;
    for (g_3 = (-28); (g_3 == 23); g_3 += 1)
    { /* block id: 3 */
        uint32_t l_23 = 4294967290U;
    }
    if ((((int16_t)((uint16_t)((int16_t)((int32_t)(g_88 == g_88) / (int32_t)4294967291U) * (int16_t)((int32_t)(((*l_78) == (***g_98)) && ((uint16_t)((((int32_t)((*g_88) || (((uint16_t)((((((uint16_t)(l_141 == (void*)0) << (uint16_t)8) && ((*l_79) >= l_142)) >= 4294967295U) == (**l_78)) ^ g_2) * (uint16_t)(**l_78)) > 0U)) + (int32_t)g_53) > g_50) ^ 0x6167) + (uint16_t)0xCF82)) / (int32_t)4294967295U)) << (uint16_t)4) >> (int16_t)8) != 65529U))
    { /* block id: 73 */
        uint16_t l_147 = 0xC877;
        for (l_8 = 0; (l_8 < 26); l_8 += 1)
        { /* block id: 76 */
            uint32_t l_148 = 0x73C59DB3;
            (**l_141) = ((((((((float)l_147 - (float)(g_2 <= g_3)) < l_148) != g_50) != (((float)g_53 - (float)(((float)(((float)g_105 - (float)(l_148 != (+0x5.3F9BE9p-74))) > (*l_79)) - (float)g_89) < l_148)) != l_148)) == g_89) == (-0x4.4p-1)) > (-0x1.Ep+1));
            return l_148;
        }
    }
    else
    { /* block id: 80 */
        int16_t l_166 = 0x0831;
        (*l_79) = (((((****g_98) != 1) < ((uint32_t)((uint32_t)g_3 + (uint32_t)(((int16_t)(*l_79) << (int16_t)(g_89 && ((*l_79) < (***g_99)))) ^ ((int32_t)((int16_t)g_3 - (int16_t)(0xFB5A > 0x06BD)) % (int32_t)l_166))) / (uint32_t)(-4))) > (**g_100)) & (-8));
        (*g_100) = (**g_99);
    }
    return g_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_10(const int32_t  p_11, int32_t  p_12, float  p_13, uint16_t  p_14)
{ /* block id: 18 */
    int16_t l_60 = 3;
    l_60 = ((float)p_13 / (float)p_13);
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_17(uint32_t  p_18, uint32_t  p_19, int16_t  p_20)
{ /* block id: 15 */
    int32_t *l_55 = &g_3;
    int32_t **l_56 = (void*)0;
    int32_t **l_57 = &l_55;
    (*l_57) = l_55;
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_25(uint16_t  p_26)
{ /* block id: 12 */
    uint32_t l_51 = 1U;
    int32_t *l_52 = &g_53;
    float l_54 = 0x0.7p-1;
    l_52 = func_44(l_51);
    /* statement id: 13 */
    assert (l_52 == &g_3);
    return p_26;
}


/* ------------------------------------------ */
/* 
 * reads : g_50
 * writes: g_50
 */
static uint16_t  func_27(uint32_t  p_28, const uint32_t  p_29, uint32_t  p_30, uint32_t  p_31, uint32_t  p_32)
{ /* block id: 5 */
    int32_t *l_48 = &g_3;
    int32_t **l_47 = &l_48;
    int32_t l_49 = 0x28CBD6CD;
    (*l_47) = func_44(p_31);
    (*l_47) = (void*)0;
    /* statement id: 9 */
    assert (l_48 == 0);
    g_50 = l_49;
    return g_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(int16_t  p_45)
{ /* block id: 6 */
    int32_t *l_46 = &g_3;
    return l_46;
    /* statement id: 7 */
    //assert (func_44_rv == &g_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_53 g_89 g_105 g_50
 * writes: g_89 g_105
 */
static float  func_62(int32_t  p_63, int32_t ** p_64, float  p_65)
{ /* block id: 31 */
    float l_109 = 0x4.A1D25Fp+40;
    int32_t l_112 = 0x0E8981CC;
    for (p_63 = 20; (p_63 >= (-26)); p_63--)
    { /* block id: 34 */
        if ((0xFBB1 ^ g_53))
        { /* block id: 35 */
            for (g_89 = 0; (g_89 < (-6)); g_89 -= 2)
            { /* block id: 38 */
                g_105 = p_65;
            }
        }
        else
        { /* block id: 41 */
            int32_t l_106 = 0;
            const uint16_t l_113 = 0x371D;
            (**p_64) = (l_106 >= ((((uint32_t)(g_105 | (**p_64)) + (uint32_t)((0 <= g_50) | (0 | (((uint32_t)0U % (uint32_t)l_112) && ((l_106 > 0U) != l_106))))) >= 0x3A2B) < l_113));
            (**p_64) = 0xAC63FEC7;
        }
    }
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads : g_98 g_3
 * writes: g_99
 */
static int16_t  func_68(uint32_t  p_69, int32_t * p_70, int32_t  p_71, uint32_t  p_72, int16_t  p_73)
{ /* block id: 28 */
    int32_t ***l_97 = (void*)0;
    (*g_98) = l_97;
    /* statement id: 29 */
    assert (g_99 == 0);
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_50
 * writes: g_53
 */
static uint32_t  func_74(uint32_t  p_75, int32_t ** p_76)
{ /* block id: 22 */
    const int16_t l_80 = 0xAEAB;
    int32_t *l_83 = &g_53;
    (*l_83) = (l_80 > ((uint16_t)p_75 << (uint16_t)((g_3 & 0xBF9C) <= 0x3A0DCB3D)));
    return g_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_88
 */
static int32_t * func_84(int32_t  p_85, const int16_t  p_86, int32_t * p_87)
{ /* block id: 25 */
    int32_t *l_90 = &g_89;
    g_88 = func_44(p_86);
    /* statement id: 26 */
    assert (g_88 == &g_3);
    return l_90;
    /* statement id: 27 */
    //assert (func_84_rv == &g_89);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_53, "g_53", print_hash_value);
    transparent_crc(g_89, "g_89", print_hash_value);
    transparent_crc(g_105, "g_105", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 31
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 9
   depth: 5, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 26

XXX times a variable address is taken: 20
XXX times a pointer is dereferenced on RHS: 24
breakdown:
   depth: 1, occurrence: 11
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 21
breakdown:
   depth: 1, occurrence: 14
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 1
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 59

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 39
   level: 2, occurrence: 25
   level: 3, occurrence: 7
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 12
XXX number of pointers point to scalars: 14
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.1
XXX average alias set size: 1.23

XXX times a non-volatile is read: 152
XXX times a non-volatile is write: 61
XXX times a volatile is read: 8
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 35
XXX percentage of non-volatile access: 95.9

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 32
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 4
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 24
XXX percentage an existing variable is used: 76
********************* end of statistics **********************/

