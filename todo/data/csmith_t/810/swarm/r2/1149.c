/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3922335670
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 9;
   uint16_t  f1;
   signed f2 : 2;
   unsigned f3 : 28;
   signed f4 : 17;
   int32_t  f5;
   unsigned f6 : 22;
   signed f7 : 23;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_32(void);
inline static int64_t  func_47(uint64_t  p_48, int32_t  p_49);
inline static int32_t  func_50(struct S0  p_51);
static struct S0  func_52(uint8_t  p_53, uint16_t  p_54);
static uint32_t  func_65(int16_t  p_66, int32_t  p_67);
inline static int64_t  func_70(float  p_71, uint32_t  p_72, uint16_t  p_73, int32_t  p_74);
inline static float  func_75(float  p_76, int16_t  p_77, uint16_t  p_78, uint16_t  p_79);
inline static uint16_t  func_82(int16_t  p_83, uint8_t  p_84);
inline static struct S0 * func_88(uint8_t  p_89, int32_t * p_90);
inline static float  func_96(uint64_t  p_97, int32_t  p_98, int16_t  p_99, uint64_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_32(void)
{ /* block id: 36 */
    uint32_t l_40 = 0x47CDEDFCL;
    int32_t l_1035 = 0x4D1FC364L;
    int32_t *l_1034 = &l_1035;
    uint32_t **l_1042 = (void*)0;
    uint32_t ***l_1041 = &l_1042;
    uint8_t l_1043 = 0x94L;
    float l_1045 = (-0x4.2p+1);
    float *l_1044 = &l_1045;
    uint8_t l_1046 = 255UL;
    int32_t ****l_1047 = (void*)0;
    float l_1048 = 0x5.856D79p+26;
    int32_t l_1049 = 1L;
    uint32_t l_1050 = 0x08F2278EL;
    (*l_1034) = ((safe_mod_func_int32_t_s_s((safe_lshift_func_uint16_t_u_u((!__builtin_parity(((safe_add_func_uint16_t_u_u((l_40 | (l_40 < ((safe_sub_func_int32_t_s_s(((*l_1034) = (safe_mod_func_int64_t_s_s(0x4593F6A08376FBFCLL, (safe_add_func_int64_t_s_s(l_40, func_47(l_40, l_40)))))), ((((safe_mod_func_uint32_t_u_u(func_70((safe_sub_func_float_f_f(((((*l_1044) = (((((!(((l_1041 = (void*)0) == (((l_40 && l_1043) & 0x3709L) , (void*)0)) != l_40)) >= l_1043) < l_40) < l_1043) == 0x1.5p-1)) > l_1043) < 0x9.B5D7EEp-12), 0xF.209786p-58)), l_40, l_1046, l_40), l_1046)) | l_40) , l_1047) == l_1047))) || 0x69026184EE6ECF9DLL))), l_1046)) , 0x7DBEBB89L))), l_1046)), 0x0F32E80DL)) < l_1049);
    (*l_1034) = (*l_1034);
    return l_1050;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_47(uint64_t  p_48, int32_t  p_49)
{ /* block id: 37 */
    uint32_t l_55 = 0x0BA5FC02L;
    uint32_t l_85 = 0xE5BD571EL;
    int32_t l_87 = (-1L);
    int32_t *l_86 = &l_87;
    float *l_480 = (void*)0;
    float *l_481 = (void*)0;
    float l_483 = 0x0.Ep+1;
    float *l_482 = &l_483;
    int64_t l_484 = (-1L);
    int16_t *l_493 = (void*)0;
    int16_t l_495 = (-5L);
    int16_t *l_494 = &l_495;
    uint32_t l_496 = 0xEE17E45DL;
    int64_t *l_498 = &l_484;
    uint8_t l_846 = 0x00L;
    float l_894 = 0x4.EDACF6p+33;
    uint32_t l_895 = 4294967290UL;
    struct S0 l_902 = {19,65535UL,-0,3662,-354,-1L,350,2485};
    int32_t l_903 = 0xC8850E34L;
    uint16_t *l_954 = &l_902.f1;
    uint16_t **l_953 = &l_954;
    uint16_t ***l_952 = &l_953;
    struct S0 l_1002 = {12,0x1455L,-0,11166,-264,0xC7B07A6AL,1285,2862};
    struct S0 ***l_1030 = (void*)0;
    struct S0 ****l_1029 = &l_1030;
    if (func_50(func_52(l_55, ((__builtin_ctzl(((safe_unary_minus_func_int32_t_s(0x7CC73EE4L)) != p_48)) == ((*l_498) = ((safe_add_func_int64_t_s_s((((safe_sub_func_int16_t_s_s(p_48, ((safe_lshift_func_uint16_t_u_s(9UL, 15)) & func_65(((*l_494) = (safe_lshift_func_int16_t_s_s((func_70(func_75((((safe_mod_func_int32_t_s_s((((*l_482) = (l_55 >= (((func_82((l_85 = l_55), ((((*l_86) = ((p_48 , l_55) , l_55)) == p_49) <= 6UL)) && p_48) , p_49) != 0x1.2p-1))) , (*l_86)), p_48)) || l_484) , p_49), p_49, p_48, p_49), p_49, p_48, p_48) <= p_48), p_48))), l_496)))) , 1UL) == p_48), l_484)) != 0x7C6BC45FL))) > 0xF6C3278EL))))
    { /* block id: 615 */
        uint16_t *l_851 = (void*)0;
        struct S0 l_854 = {-18,0x2A8BL,0,1416,-19,0x484A8CB7L,394,2241};
        int32_t *l_856 = &l_854.f5;
        int32_t **l_859 = &l_856;
        int32_t ***l_858 = &l_859;
        float l_862 = 0xE.B7D415p-79;
        int32_t l_893 = (-5L);
        if (__builtin_popcountl(((safe_sub_func_int16_t_s_s(0x1DFFL, (safe_sub_func_int16_t_s_s((*l_86), p_48)))) , (p_49 || l_846))))
        { /* block id: 616 */
            uint16_t **l_852 = (void*)0;
            uint16_t **l_853 = &l_851;
            int32_t ***l_860 = (void*)0;
            (*l_86) = p_48;
            if ((safe_lshift_func_uint16_t_u_s((((*l_853) = ((safe_lshift_func_int16_t_s_s(1L, 7)) , l_851)) == (void*)0), 8)))
            { /* block id: 619 */
                return p_48;
            }
            else
            { /* block id: 621 */
                struct S0 *l_855 = &l_854;
                int32_t **l_857 = &l_856;
                int32_t ****l_861 = &l_860;
                (*l_855) = l_854;
                (*l_857) = (p_49 , l_856);
                (**l_859) = (p_49 < ((l_858 == ((*l_861) = l_860)) <= p_49));
            }
        }
        else
        { /* block id: 627 */
            int32_t l_873 = (-1L);
            uint64_t l_875 = 18446744073709551615UL;
            uint64_t *l_878 = &l_875;
            struct S0 l_879 = {0,65526UL,-1,11556,93,4L,956,2138};
            int64_t l_889 = 6L;
            int32_t l_891 = (-1L);
            int32_t *l_890 = &l_891;
            uint8_t *l_892 = &l_846;
            (*l_856) = (((((((((*l_878) = ((((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u((*l_86), (safe_lshift_func_int16_t_s_u(((safe_mod_func_int32_t_s_s((safe_add_func_int16_t_s_s(((*l_494) = p_49), l_873)), (((&l_55 != (void*)0) <= (l_851 == (((((((~l_875) , ((safe_add_func_int64_t_s_s((*l_856), __builtin_bswap64(p_49))) | (*l_86))) | 3L) , 0xB.067CFEp+28) , (*l_86)) , p_48) , (void*)0))) && l_875))) || p_49), l_873)))), 8)) > 18446744073709551615UL) <= (-1L)) != (*l_86))) | 9L) != (*l_856)) & l_873) >= l_873) | l_873) && p_48) == 0x6367BC29L);
            (*l_482) = (func_75(p_48, (l_879 , (safe_add_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_u(((safe_sub_func_uint16_t_u_u(p_49, ((!((l_879.f5 , &l_85) == (void*)0)) > func_82((l_893 = ((func_52(((*l_892) = func_65(p_49, ((*l_890) = (safe_sub_func_uint64_t_u_u((l_854 , ((***l_858) && l_889)), 0x2DAE328AB04EB01CLL))))), (*l_856)) , 7UL) <= (*l_856))), p_49)))) ^ 0x64D9E762L), 3)), 0x3315A859B1A19B1CLL))), l_895, p_48) , l_879.f6);
        }
        for (p_48 = 0; (p_48 <= 5); p_48++)
        { /* block id: 638 */
            l_902 = func_52(((safe_lshift_func_int16_t_s_s(0xA356L, 13)) == (safe_rshift_func_int16_t_s_u((*l_856), 2))), p_48);
        }
    }
    else
    { /* block id: 641 */
        uint32_t l_919 = 8UL;
        int32_t *l_921 = &l_87;
        uint16_t *l_927 = (void*)0;
        uint16_t **l_926 = &l_927;
        uint16_t ***l_925 = &l_926;
        uint8_t l_967 = 255UL;
        int32_t *l_982 = &l_87;
        uint8_t *l_1014 = &l_846;
        uint8_t **l_1013 = &l_1014;
        uint8_t ***l_1012 = &l_1013;
        uint8_t ****l_1011 = &l_1012;
        if ((p_48 || ((*l_498) = (*l_86))))
        { /* block id: 643 */
            int32_t l_905 = 0xDF060BF4L;
            struct S0 ***l_947 = (void*)0;
            int32_t **l_979 = &l_86;
            int32_t ***l_978 = &l_979;
            int32_t ****l_977 = &l_978;
            int32_t *****l_976 = &l_977;
            uint8_t *l_1010 = &l_846;
            uint8_t **l_1009 = &l_1010;
            uint8_t ***l_1008 = &l_1009;
            uint8_t ****l_1007 = &l_1008;
        }
        else
        { /* block id: 727 */
            struct S0 ***l_1028 = (void*)0;
            struct S0 ****l_1027 = &l_1028;
            int32_t l_1031 = 1L;
            uint16_t ****l_1032 = &l_925;
            int32_t **l_1033 = &l_86;
            (*l_1033) = (p_49 , ((__builtin_ctzll((l_1027 == l_1029)) < (l_1031 == ((*l_494) = (l_1031 && (((*l_86) == 0xA740L) | ((((((*l_1032) = &l_953) != &l_926) != (*l_982)) , (*l_86)) <= (*l_86))))))) , (void*)0));
        }
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_50(struct S0  p_51)
{ /* block id: 316 */
    int32_t **l_500 = (void*)0;
    int32_t l_503 = 0x7A81C603L;
    int32_t *l_502 = &l_503;
    int32_t **l_501 = &l_502;
    uint32_t l_512 = 3UL;
    struct S0 l_515 = {0,2UL,0,7444,-229,0L,334,-2230};
    int64_t l_523 = 0xE411ACD9326DD496LL;
    int64_t *l_522 = &l_523;
    int64_t l_530 = (-4L);
    uint32_t l_536 = 1UL;
    struct S0 *l_544 = &l_515;
    struct S0 **l_543 = &l_544;
    struct S0 ***l_542 = &l_543;
    uint32_t **l_578 = (void*)0;
    int32_t l_637 = 0x97FD2A08L;
    uint32_t l_646 = 0xE0BCD769L;
    uint32_t l_678 = 4294967295UL;
    uint8_t l_715 = 0x0FL;
    uint64_t l_716 = 18446744073709551615UL;
    float l_737 = 0x2.5E681Fp+80;
    uint16_t l_767 = 65535UL;
    int16_t l_777 = 0xD5A7L;
    int32_t l_833 = (-1L);
    (*l_501) = (void*)0;
    return p_51.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_52(uint8_t  p_53, uint16_t  p_54)
{ /* block id: 314 */
    struct S0 l_499 = {8,4UL,-0,14167,-244,1L,1503,-2719};
    return l_499;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_65(int16_t  p_66, int32_t  p_67)
{ /* block id: 311 */
    uint16_t l_497 = 0x4CB2L;
    return l_497;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_70(float  p_71, uint32_t  p_72, uint16_t  p_73, int32_t  p_74)
{ /* block id: 307 */
    int32_t l_491 = 1L;
    int32_t *l_490 = &l_491;
    int32_t **l_492 = &l_490;
    (*l_492) = l_490;
    return p_74;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_75(float  p_76, int16_t  p_77, uint16_t  p_78, uint16_t  p_79)
{ /* block id: 303 */
    uint32_t l_485 = 0xA9E135BEL;
    int32_t l_487 = 0xA630F82AL;
    int32_t *l_486 = &l_487;
    struct S0 l_488 = {-2,0xE1CAL,0,15014,157,0L,892,2119};
    struct S0 *l_489 = &l_488;
    (*l_486) = (p_78 , __builtin_clzl(l_485));
    (*l_489) = l_488;
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_82(int16_t  p_83, uint8_t  p_84)
{ /* block id: 40 */
    uint8_t l_93 = 0UL;
    struct S0 l_95 = {-8,0xD443L,1,10685,-179,0xE05992E4L,385,836};
    struct S0 *l_94 = &l_95;
    int32_t *l_131 = &l_95.f5;
    struct S0 **l_477 = &l_94;
    struct S0 *****l_478 = (void*)0;
    struct S0 *l_479 = &l_95;
    (*l_477) = func_88(((safe_rshift_func_uint16_t_u_s(l_93, ((l_94 != &l_95) == ((func_96(p_84, l_95.f2, (p_84 != ((l_95.f7 = l_95.f5) || ((__builtin_clz(p_83) & l_95.f0) > (-1L)))), l_95.f3) , p_84) , p_84)))) || l_95.f6), l_131);
    l_478 = (void*)0;
    (*l_479) = l_95;
    return p_83;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_88(uint8_t  p_89, int32_t * p_90)
{ /* block id: 63 */
    struct S0 **l_140 = (void*)0;
    struct S0 ***l_139 = &l_140;
    int32_t l_148 = (-1L);
    uint16_t **l_165 = (void*)0;
    struct S0 *l_188 = (void*)0;
    int32_t l_290 = 0x8642B3C9L;
    int32_t l_311 = 0xA758E5FCL;
    uint32_t l_321 = 0xA876B3CFL;
    uint32_t *l_320 = &l_321;
    int64_t l_327 = 0x41D896C24658D136LL;
    int64_t *l_326 = &l_327;
    int16_t l_329 = 0x12CBL;
    int16_t *l_328 = &l_329;
    uint64_t *l_330 = (void*)0;
    uint64_t *l_331 = (void*)0;
    uint64_t *l_332 = (void*)0;
    uint64_t l_334 = 0xFDE053CD6AE3D4CDLL;
    uint64_t *l_333 = &l_334;
    uint64_t l_355 = 3UL;
    struct S0 l_365 = {8,0xF4DEL,-1,9859,-317,1L,1727,229};
    struct S0 *l_364 = &l_365;
    int32_t *l_410 = &l_148;
    struct S0 *l_448 = &l_365;
    struct S0 *l_450 = &l_365;
    struct S0 *l_453 = &l_365;
    struct S0 *l_472 = &l_365;
    struct S0 *l_473 = &l_365;
    struct S0 *l_474 = &l_365;
    struct S0 *l_475 = &l_365;
    struct S0 *l_476 = (void*)0;
    for (p_89 = 0; (p_89 != 56); p_89 = safe_add_func_int32_t_s_s(p_89, 8))
    { /* block id: 66 */
        struct S0 l_137 = {16,0xA5C8L,0,13243,347,-4L,1218,-354};
        struct S0 *l_136 = &l_137;
        struct S0 **l_135 = &l_136;
        struct S0 ***l_134 = &l_135;
        struct S0 ****l_138 = (void*)0;
        if ((*p_90))
            break;
        l_139 = l_134;
        for (l_137.f5 = (-13); (l_137.f5 == (-18)); l_137.f5 = safe_sub_func_int32_t_s_s(l_137.f5, 1))
        { /* block id: 71 */
            struct S0 *l_143 = &l_137;
            (**l_134) = l_143;
            if ((*p_90))
                continue;
            (*l_135) = (**l_139);
        }
    }
    for (p_89 = 0; (p_89 > 60); ++p_89)
    { /* block id: 79 */
        struct S0 ***l_146 = &l_140;
        int32_t l_147 = 0x39DC62CBL;
        int32_t *l_159 = &l_148;
        int16_t l_202 = 0xBCF4L;
        int16_t *l_201 = &l_202;
        struct S0 l_206 = {-0,0xA3F5L,-1,4542,337,1L,1034,-1527};
        uint16_t *l_219 = &l_206.f1;
        uint16_t **l_218 = &l_219;
        int32_t l_221 = 0L;
        struct S0 *l_239 = (void*)0;
        uint64_t l_270 = 0xC5DCDB8084EC3894LL;
        uint64_t *l_269 = &l_270;
        int32_t l_297 = 0x6850E3D9L;
        (*p_90) = (((l_146 != l_146) < 0x5BCB3CA9L) , (((((p_89 >= ((p_89 <= __builtin_ctzll(p_89)) && ((((l_147 , (-6L)) && l_147) < l_147) && 0x796FF316L))) == (-1L)) >= l_148) , (void*)0) != (void*)0));
        if (l_147)
        { /* block id: 81 */
            struct S0 ****l_149 = &l_146;
            int32_t *l_151 = &l_148;
            int32_t **l_150 = &l_151;
            l_149 = l_149;
            (*l_146) = (*l_146);
            (*l_150) = p_90;
            for (l_148 = (-16); (l_148 >= (-30)); l_148 = safe_sub_func_uint32_t_u_u(l_148, 1))
            { /* block id: 87 */
                (*l_150) = p_90;
            }
        }
        else
        { /* block id: 90 */
            struct S0 l_186 = {-14,65534UL,-1,2731,230,1L,1365,2052};
            struct S0 *l_185 = &l_186;
            for (l_147 = 0; (l_147 == (-29)); l_147 = safe_sub_func_uint16_t_u_u(l_147, 1))
            { /* block id: 93 */
                int32_t *l_156 = &l_148;
                struct S0 l_158 = {16,0x3904L,0,10225,-46,0x13F0835FL,1791,-2359};
                struct S0 *l_157 = &l_158;
                int32_t **l_167 = &l_156;
                if ((((l_156 != (((p_89 , l_157) != &l_158) , l_159)) || (*l_159)) , l_148))
                { /* block id: 94 */
                    for (l_158.f5 = 0; (l_158.f5 <= 9); l_158.f5 = safe_add_func_uint64_t_u_u(l_158.f5, 4))
                    { /* block id: 97 */
                        int32_t **l_162 = &l_156;
                        struct S0 *l_164 = (void*)0;
                        (*l_162) = p_90;
                        (**l_162) = (~(*p_90));
                        return l_164;
                    }
                    (*l_156) = (*l_159);
                }
                else
                { /* block id: 103 */
                    uint16_t ***l_166 = &l_165;
                    (*l_166) = l_165;
                }
                (*l_167) = l_156;
            }
            for (l_147 = (-1); (l_147 <= (-30)); l_147 = safe_sub_func_uint32_t_u_u(l_147, 4))
            { /* block id: 110 */
                uint64_t l_176 = 18446744073709551614UL;
                uint32_t l_180 = 0UL;
                uint32_t *l_179 = &l_180;
                int16_t l_182 = 1L;
                int16_t *l_181 = &l_182;
                struct S0 *l_187 = &l_186;
                if ((((*l_181) = ((((safe_sub_func_uint64_t_u_u((safe_add_func_int64_t_s_s(p_89, (safe_lshift_func_int16_t_s_u(l_176, 8)))), __builtin_clz(p_89))) , (safe_mod_func_uint32_t_u_u(((*l_179) = 0xC9A99D27L), 0x2AA92F95L))) ^ 0x6126C607L) == __builtin_ctzl(l_148))) == p_89))
                { /* block id: 113 */
                    struct S0 l_184 = {-2,0x4C50L,0,3263,286,0L,850,-1002};
                    struct S0 *l_183 = &l_184;
                    if (l_148)
                        break;
                    return l_188;
                }
                else
                { /* block id: 116 */
                    for (l_186.f5 = 0; (l_186.f5 <= (-27)); l_186.f5 = safe_sub_func_uint16_t_u_u(l_186.f5, 7))
                    { /* block id: 119 */
                        float l_198 = 0xB.15883Fp-35;
                        float *l_197 = &l_198;
                        float l_200 = (-0x6.0p+1);
                        float *l_199 = &l_200;
                        (*l_199) = (0x2.761482p-77 <= (safe_add_func_float_f_f(((*l_197) = (((((safe_sub_func_uint32_t_u_u(6UL, (safe_sub_func_int16_t_s_s((0L > (p_90 == p_90)), (p_89 , (l_186.f0 = ((*l_181) = l_148))))))) ^ (9UL & p_89)) && 1L) , 0x1.6p-1) != l_148)), (-0x4.1p-1))));
                    }
                }
            }
            (*l_185) = (*l_185);
        }
        if (((((*l_201) = p_89) || (*l_159)) > l_148))
        { /* block id: 130 */
            int32_t **l_203 = &l_159;
            struct S0 l_207 = {-17,65535UL,0,3167,146,1L,320,-2769};
            struct S0 l_208 = {-6,0x0183L,-1,4015,253,0x08B9188FL,1149,-2556};
            (*l_159) = (*l_159);
            (*l_203) = p_90;
            for (l_147 = 0; (l_147 < (-30)); l_147 = safe_sub_func_uint32_t_u_u(l_147, 1))
            { /* block id: 135 */
                struct S0 l_209 = {16,65528UL,1,11904,172,0xB83AE85CL,173,1197};
                struct S0 *l_210 = &l_209;
                l_208 = (l_207 = l_206);
                (*l_210) = l_209;
            }
        }
        else
        { /* block id: 140 */
            uint32_t l_212 = 1UL;
            uint64_t l_214 = 0xC53DE24A45322D53LL;
            uint64_t *l_213 = &l_214;
            int32_t **l_215 = &l_159;
            uint16_t **l_220 = &l_219;
            struct S0 *l_238 = &l_206;
            uint32_t l_240 = 2UL;
            int16_t l_289 = 5L;
            float l_300 = (-0x8.6p-1);
            float *l_299 = &l_300;
            float l_308 = 0x1.DE6D40p-50;
            float *l_307 = &l_308;
            struct S0 ****l_310 = (void*)0;
            struct S0 *****l_309 = &l_310;
            (*l_215) = ((l_148 != __builtin_parityll(((*l_213) = ((l_148 == (+(__builtin_clzll(l_148) , l_212))) || p_89)))) , (void*)0);
            if ((safe_add_func_int32_t_s_s((((l_218 == l_220) && (*p_90)) || 4294967295UL), l_148)))
            { /* block id: 143 */
                uint32_t l_222 = 0x22E32B80L;
                int32_t l_223 = 0x227E0448L;
                struct S0 *l_253 = (void*)0;
                if ((l_223 = ((p_89 == l_221) || l_222)))
                { /* block id: 145 */
                    uint32_t l_226 = 0x98A15B14L;
                    int64_t l_233 = 0x1AEA985D862F89DFLL;
                    int64_t *l_232 = &l_233;
                    float l_235 = 0x1.2p+1;
                    float *l_234 = &l_235;
                    (*l_234) = ((safe_add_func_uint64_t_u_u(l_226, (safe_sub_func_uint16_t_u_u(p_89, (p_89 ^ 0L))))) , (((65529UL <= (!(p_89 ^ (((safe_add_func_int64_t_s_s(((*l_232) = (p_89 || l_206.f7)), p_89)) && p_89) && p_89)))) == 0x199BL) , 0x6.273AD2p-92));
                }
                else
                { /* block id: 148 */
                    for (l_214 = 0; (l_214 >= 14); ++l_214)
                    { /* block id: 151 */
                        return l_239;
                    }
                }
                if (l_240)
                    break;
                if ((*p_90))
                    continue;
                for (l_212 = 0; (l_212 == 5); l_212 = safe_add_func_uint32_t_u_u(l_212, 1))
                { /* block id: 159 */
                    int16_t l_254 = (-1L);
                    if ((safe_lshift_func_int16_t_s_s((-1L), 1)))
                    { /* block id: 160 */
                        int64_t l_247 = 0L;
                        float l_249 = 0x8.AB25B9p-45;
                        float *l_248 = &l_249;
                        float l_251 = 0x8.719FA1p+2;
                        float *l_250 = &l_251;
                        struct S0 *l_252 = &l_206;
                        (*l_250) = ((*l_248) = (safe_sub_func_float_f_f(l_247, 0x2.E61869p-58)));
                        return l_253;
                    }
                    else
                    { /* block id: 164 */
                        if ((*p_90))
                            break;
                        if (l_254)
                            break;
                    }
                    if ((*p_90))
                        continue;
                    for (l_206.f5 = 0; (l_206.f5 >= 16); l_206.f5 = safe_add_func_uint64_t_u_u(l_206.f5, 1))
                    { /* block id: 171 */
                        (*l_215) = p_90;
                        if ((**l_215))
                            break;
                        if ((*p_90))
                            continue;
                        (*l_215) = p_90;
                    }
                    (*l_215) = (*l_215);
                }
            }
            else
            { /* block id: 179 */
                int32_t *l_257 = &l_148;
                uint16_t ***l_292 = (void*)0;
                (*l_215) = p_90;
                (*l_215) = l_257;
                for (l_206.f5 = 4; (l_206.f5 < (-20)); l_206.f5 = safe_sub_func_uint16_t_u_u(l_206.f5, 8))
                { /* block id: 184 */
                    int16_t l_266 = 0xE113L;
                    int16_t l_272 = (-1L);
                    int16_t *l_271 = &l_272;
                    int16_t *l_273 = &l_266;
                    uint8_t l_274 = 0x07L;
                    (*l_215) = p_90;
                    if (__builtin_clzll(((*l_269) = (((**l_215) <= (*l_257)) || (safe_lshift_func_int16_t_s_s(((*l_273) = (safe_lshift_func_uint16_t_u_s((safe_add_func_int64_t_s_s(l_266, (safe_add_func_int16_t_s_s((1L > ((*l_159) && p_89)), (((*l_271) = ((((*l_201) = ((l_213 = (void*)0) == l_269)) >= 4L) > p_89)) > 1L))))), l_266))), l_274))))))
                    { /* block id: 191 */
                        struct S0 ****l_279 = &l_139;
                        struct S0 ****l_280 = &l_146;
                        int32_t l_285 = 0xC4F4EFCBL;
                        float l_287 = 0x0.6p+1;
                        float *l_286 = &l_287;
                        uint16_t ***l_291 = &l_165;
                        uint16_t ***l_293 = &l_165;
                        uint32_t *l_296 = &l_212;
                        int32_t *l_298 = &l_285;
                        (*l_286) = (safe_add_func_float_f_f((((l_266 , p_89) > ((((((0x1545FFFBL < ((0xAB577FE8L && (safe_mod_func_uint16_t_u_u(((p_89 > (&l_140 != ((*l_280) = (void*)0))) != ((safe_rshift_func_uint16_t_u_s(((*l_257) , (safe_add_func_uint16_t_u_u(((**l_220) = p_89), l_285))), 9)) <= 0x87F0693F87E3A3C1LL)), 5L))) >= 1UL)) | p_89) >= 0x6BE0F0FCL) , 0xDC5E76BDE149198ALL) <= l_285) , (*l_159))) , p_89), l_285));
                        (*l_215) = l_159;
                        (**l_215) = l_148;
                        (*l_298) = (l_290 = ((-1L) < (+(l_297 = (((*l_296) = ((0x4A44L != ((*l_257) = p_89)) | ((*l_273) = (p_89 > (((**l_220) = l_289) | ((((*l_159) = l_290) , ((((l_291 == (l_293 = l_292)) || ((safe_rshift_func_int16_t_s_u((**l_215), 7)) < 0x1F3B6397L)) & 1L) | p_89)) > l_274)))))) >= (-1L))))));
                    }
                    else
                    { /* block id: 206 */
                        (*l_159) = (-1L);
                    }
                }
            }
            (*l_309) = ((((*l_238) , ((p_89 != ((*l_299) = l_148)) == (safe_add_func_float_f_f(p_89, l_290)))) >= ((*l_307) = (safe_sub_func_float_f_f(p_89, (safe_sub_func_float_f_f(p_89, (-0x1.8p-1))))))) , &l_139);
        }
    }
    if ((l_311 | (safe_lshift_func_uint16_t_u_u((p_89 , (((*l_333) = (((((safe_rshift_func_int16_t_s_u((safe_sub_func_uint64_t_u_u((safe_mod_func_uint32_t_u_u(((*l_320) = l_290), (((*l_328) = (safe_mul_func_int64_t_s_s(((l_311 <= (safe_sub_func_int16_t_s_s(l_290, l_290))) <= 0UL), (l_326 != &l_327)))) , l_329))), p_89)), 6)) , &l_327) != (void*)0) <= 18446744073709551613UL) >= l_327)) & p_89)), 14))))
    { /* block id: 219 */
        for (l_327 = 0; (l_327 <= (-14)); l_327 = safe_sub_func_uint32_t_u_u(l_327, 1))
        { /* block id: 222 */
            int32_t *l_338 = &l_148;
            int32_t **l_337 = &l_338;
            (*l_337) = p_90;
        }
    }
    else
    { /* block id: 225 */
        float l_340 = (-0x1.8p-1);
        float *l_339 = &l_340;
        int32_t **l_343 = (void*)0;
        int32_t *l_345 = &l_148;
        int32_t **l_344 = &l_345;
        int32_t l_346 = 0x10637C89L;
        int16_t l_347 = 0xCCB4L;
        (*l_339) = p_89;
        l_347 = (l_346 = (safe_add_func_int16_t_s_s(((p_90 = ((*l_344) = p_90)) == l_339), l_329)));
        (*p_90) = (**l_344);
        (*l_339) = (p_89 != (safe_sub_func_float_f_f(0xF.B8C2FFp-83, (l_334 == (safe_add_func_float_f_f((-0x6.Cp+1), (!(((*l_345) = (safe_mod_func_uint16_t_u_u(l_355, ((*p_90) ^ (safe_mod_func_uint32_t_u_u((safe_mod_func_uint32_t_u_u(((p_89 , ((safe_mod_func_int64_t_s_s((((*p_90) <= (safe_rshift_func_int16_t_s_u((4294967286UL || (*p_90)), p_89))) >= (*l_345)), l_334)) >= (-6L))) && 7L), p_89)), (*p_90))))))) , p_89))))))));
    }
    if (((*p_90) = 0xB691785BL))
    { /* block id: 236 */
        struct S0 *l_366 = (void*)0;
        return l_366;
    }
    else
    { /* block id: 238 */
        int32_t **l_367 = (void*)0;
        int32_t *l_369 = &l_290;
        int32_t **l_368 = &l_369;
        struct S0 *l_445 = &l_365;
        struct S0 *l_454 = &l_365;
        struct S0 *l_469 = (void*)0;
        (*l_368) = p_90;
        (**l_368) = (((l_365.f7 = 3UL) >= 0x3C6F657B8970AAFFLL) , (*l_369));
        if (((l_329 < (safe_lshift_func_uint16_t_u_s((~((safe_mod_func_uint32_t_u_u(4294967291UL, (**l_368))) | p_89)), 3))) <= l_327))
        { /* block id: 242 */
            float l_376 = 0x5.Ap+1;
            float *l_375 = &l_376;
            (*l_375) = p_89;
        }
        else
        { /* block id: 244 */
            int16_t l_382 = 3L;
            int32_t l_401 = 1L;
            int64_t l_433 = 0x799C365DECAD3550LL;
            struct S0 *l_437 = &l_365;
            if ((*p_90))
            { /* block id: 245 */
                int32_t l_379 = 0L;
                if (((safe_rshift_func_int16_t_s_s(l_379, (safe_rshift_func_uint16_t_u_u(l_290, p_89)))) , 2L))
                { /* block id: 246 */
                    float l_384 = 0x2.1596AAp-40;
                    float *l_383 = &l_384;
                    p_90 = &l_379;
lbl_385:
                    (**l_368) = (l_382 & ((*l_326) = p_89));
                    (*l_383) = l_382;
                    if (l_355)
                        goto lbl_385;
                }
                else
                { /* block id: 252 */
                    uint32_t l_392 = 0x67F04626L;
                    uint16_t *l_402 = &l_365.f1;
                    (**l_368) = (safe_mod_func_uint16_t_u_u(((*l_402) = (safe_sub_func_int32_t_s_s((p_89 < (-2L)), (((((*l_326) = p_89) < l_392) , (p_89 == (((safe_add_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s(((l_401 = ((p_89 & (safe_sub_func_int16_t_s_s(((__builtin_popcountll((*l_369)) <= (safe_rshift_func_int16_t_s_u(0x3DCAL, 1))) ^ l_382), p_89))) , l_392)) > l_327), p_89)), (*p_90))) | p_89) <= (*l_369)))) < 0L)))), p_89));
                }
            }
            else
            { /* block id: 258 */
                int32_t *l_403 = &l_401;
                uint16_t *l_409 = &l_365.f1;
                struct S0 l_414 = {-15,0x83E0L,-1,3264,-306,0xA28781A0L,455,-356};
                uint8_t l_417 = 0UL;
                struct S0 *l_452 = &l_414;
                p_90 = l_403;
                if (__builtin_ctzl(((safe_sub_func_int64_t_s_s((safe_unary_minus_func_uint32_t_u((safe_lshift_func_uint16_t_u_s(((*l_409) = 0x05DDL), ((&l_401 != (l_410 = ((*l_368) = &l_401))) & (l_365.f4 = (+(((l_365.f5 , p_89) , (safe_add_func_int64_t_s_s(l_401, ((0xD39D242DL ^ (l_414 , (safe_rshift_func_int16_t_s_s((l_334 , 0x25F7L), p_89)))) , (*l_403))))) > l_417)))))))), 0x2E3FFC807B8FDB14LL)) && 0xDCE6AB1FL)))
                { /* block id: 264 */
                    uint16_t l_423 = 0xA940L;
                    int32_t *l_434 = &l_290;
                    struct S0 *l_444 = &l_414;
                    struct S0 *l_447 = &l_365;
                    if ((safe_sub_func_int16_t_s_s(((((((*l_326) = (safe_sub_func_uint32_t_u_u(p_89, (*p_90)))) == (safe_unary_minus_func_int16_t_s((l_382 & l_423)))) , (safe_add_func_uint64_t_u_u(((safe_add_func_int32_t_s_s(1L, 0UL)) < __builtin_ffsll((((safe_lshift_func_int16_t_s_u(((safe_sub_func_int32_t_s_s((*p_90), (!(((-1L) ^ ((0xC8A6L <= l_423) ^ l_401)) , 4L)))) > 4294967295UL), 4)) <= l_401) <= 0xD6B21FF38C22F99CLL))), (*l_410)))) && l_433) ^ p_89), p_89)))
                    { /* block id: 266 */
                        uint32_t l_438 = 0xDB1492B4L;
                        float l_440 = 0x0.8p+1;
                        float *l_439 = &l_440;
                        struct S0 *l_446 = &l_365;
                        struct S0 *l_449 = &l_365;
                        struct S0 *l_451 = &l_414;
                        struct S0 *l_455 = (void*)0;
                        (*l_368) = l_434;
                        (*l_439) = (l_414 , (p_89 <= func_96((((*l_326) = ((*l_434) , (((*l_403) , (((*l_328) = (((void*)0 == l_369) ^ (safe_rshift_func_int16_t_s_s((p_89 , p_89), (((*l_403) = (((void*)0 != l_437) ^ l_438)) == p_89))))) > (-1L))) != l_438))) == p_89), p_89, p_89, l_433)));
                        (*l_434) = (1L >= (((((!(0x75CC8E43L | ((safe_mod_func_int64_t_s_s((*l_410), p_89)) >= ((0UL | __builtin_ctzll(p_89)) & ((l_438 < (*p_90)) | (*l_410)))))) && 0L) != 0xA62E8586L) & (**l_368)) != p_89));
                        return l_455;
                    }
                    else
                    { /* block id: 274 */
                        int32_t *l_465 = &l_365.f5;
                        (*l_410) = l_433;
                        (*l_434) = (safe_rshift_func_int16_t_s_u(((*l_403) = (safe_mod_func_uint64_t_u_u(p_89, ((safe_rshift_func_uint16_t_u_s((p_89 , (__builtin_ia32_crc32qi((safe_mod_func_int16_t_s_s(__builtin_parityl((+((*l_320) = p_89))), 1L)), (*l_434)) != ((*l_403) > 2UL))), (*l_403))) | p_89)))), 14));
                        (*l_368) = l_465;
                    }
                }
                else
                { /* block id: 281 */
                    struct S0 *l_468 = &l_365;
                    for (l_433 = (-16); (l_433 >= 2); l_433 = safe_add_func_uint64_t_u_u(l_433, 1))
                    { /* block id: 284 */
                        return l_469;
                    }
                }
                for (l_290 = (-23); (l_290 != 12); l_290 = safe_add_func_uint32_t_u_u(l_290, 7))
                { /* block id: 290 */
                    (*l_368) = (*l_368);
                    if ((*p_90))
                        break;
                }
            }
        }
    }
    return l_476;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_96(uint64_t  p_97, int32_t  p_98, int16_t  p_99, uint64_t  p_100)
{ /* block id: 42 */
    struct S0 l_102 = {9,0x0F30L,1,3626,191,0x5C26FF55L,1715,-2466};
    struct S0 *l_101 = &l_102;
    struct S0 **l_103 = &l_101;
    uint16_t *l_104 = &l_102.f1;
    struct S0 *l_115 = (void*)0;
    struct S0 l_117 = {12,65535UL,-0,662,322,0L,1787,-2798};
    struct S0 *l_116 = &l_117;
    struct S0 l_119 = {7,0x9484L,-0,6716,-43,3L,1746,688};
    struct S0 *l_118 = &l_119;
    l_102.f7 = (l_101 != &l_102);
    (*l_103) = &l_102;
lbl_122:
    (*l_118) = ((*l_116) = (((p_97 != (((*l_104) = l_102.f5) < (safe_add_func_uint16_t_u_u(l_102.f3, (((((1L ^ (p_97 < p_100)) >= ((((((((l_102.f4 || (((safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_u((l_102.f4 & (safe_add_func_uint32_t_u_u((safe_add_func_uint64_t_u_u(0x55878DFE8548DC09LL, p_98)), l_102.f6))), 14)), p_100)) , (void*)0) == (*l_103))) > l_102.f0) , (void*)0) == (*l_103)) != l_102.f0) , 0x266FL) || l_102.f5) & l_102.f5)) ^ l_102.f5) < 0xE50A8E0669094389LL) || 0x1DCF01E3026CBAADLL))))) , p_99) , (*l_101)));
    for (l_102.f1 = (-7); (l_102.f1 == 36); l_102.f1 = safe_add_func_uint32_t_u_u(l_102.f1, 4))
    { /* block id: 50 */
        int32_t *l_123 = &l_102.f5;
        int32_t **l_124 = &l_123;
        int32_t **l_125 = (void*)0;
        int32_t *l_127 = (void*)0;
        int32_t **l_126 = &l_127;
        struct S0 l_130 = {-19,0x3785L,0,4447,-354,0xCD894E17L,1400,915};
        if (l_102.f2)
            goto lbl_122;
        (*l_126) = ((*l_124) = l_123);
        for (l_117.f1 = (-1); (l_117.f1 > 59); l_117.f1++)
        { /* block id: 56 */
            l_130 = (*l_101);
            return p_98;
        }
        (*l_118) = l_130;
    }
    return l_102.f4;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 239
   depth: 1, occurrence: 23
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 76
breakdown:
   indirect level: 0, occurrence: 23
   indirect level: 1, occurrence: 38
   indirect level: 2, occurrence: 0
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 55
XXX times a bitfields struct on LHS: 11
XXX times a bitfields struct on RHS: 51
XXX times a single bitfield on LHS: 9
XXX times a single bitfield on RHS: 122

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 159
   depth: 2, occurrence: 25
   depth: 3, occurrence: 4
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 5
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 3
   depth: 16, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 3
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1
   depth: 38, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 324

XXX times a variable address is taken: 309
XXX times a pointer is dereferenced on RHS: 139
breakdown:
   depth: 1, occurrence: 120
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 280
breakdown:
   depth: 1, occurrence: 256
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 727

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 561
   level: 2, occurrence: 83
   level: 3, occurrence: 32
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 116
XXX number of pointers point to scalars: 152
XXX number of pointers point to structs: 56
XXX percent of pointers has null in alias set: 20.1
XXX average alias set size: 1.15

XXX times a non-volatile is read: 1140
XXX times a non-volatile is write: 696
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 8

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 22
   depth: 2, occurrence: 27
   depth: 3, occurrence: 21
   depth: 4, occurrence: 23
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 19.9
XXX percentage an existing variable is used: 80.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

