/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      2893640462
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   int16_t  f1;
   int32_t  f2;
   int32_t  f3;
   uint8_t  f4;
   int16_t  f5;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint32_t  f0;
   volatile float  f1;
};
#pragma pack(pop)

struct S2 {
   uint32_t  f0;
   volatile int32_t  f1;
   volatile uint8_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_4 = 1L;
static volatile struct S1 g_31 = {0xE9734172L,0xF.48F4A8p-43};/* VOLATILE GLOBAL g_31 */
static struct S0 g_40 = {0x8FA4L,-1L,-4L,-10L,0x9DL,8L};
static struct S0 *g_39 = &g_40;
static struct S0 **g_38 = &g_39;
static struct S0 *** volatile g_37 = &g_38;/* VOLATILE GLOBAL g_37 */
static struct S0 ***g_80 = (void*)0;
static struct S1 g_83 = {0x355A2C03L,0x7.Ap-1};/* VOLATILE GLOBAL g_83 */
static uint8_t g_93 = 0x03L;
static uint16_t g_108 = 0UL;
static int32_t g_118 = 0L;
static float g_120 = (-0x1.3p-1);
static int32_t *g_135 = &g_40.f2;
static int32_t **g_134 = &g_135;
static volatile struct S2 *g_155 = (void*)0;
static struct S1 g_172 = {18446744073709551615UL,0x7.Cp+1};/* VOLATILE GLOBAL g_172 */
static struct S1 g_174 = {0x3543D046L,0xE.539A05p+67};/* VOLATILE GLOBAL g_174 */
static volatile struct S2 g_210 = {18446744073709551607UL,0L,0xC9L};/* VOLATILE GLOBAL g_210 */
static struct S2 g_240 = {18446744073709551610UL,-1L,8UL};/* VOLATILE GLOBAL g_240 */
static struct S1 g_244 = {0UL,0xE.C3FBF1p+4};/* VOLATILE GLOBAL g_244 */
static volatile struct S1 g_258 = {18446744073709551615UL,-0x7.Dp-1};/* VOLATILE GLOBAL g_258 */
static volatile struct S1 *g_257 = &g_258;
static float * volatile g_293 = &g_120;/* VOLATILE GLOBAL g_293 */
static float * volatile *g_292 = &g_293;
static struct S1 g_302 = {3UL,0x4.327F8Bp-96};/* VOLATILE GLOBAL g_302 */
static struct S1 *g_301 = &g_302;
static struct S1 ** volatile g_300 = &g_301;/* VOLATILE GLOBAL g_300 */
static struct S1 ** volatile *g_299 = &g_300;
static struct S1 g_371 = {6UL,0xB.643EAFp+20};/* VOLATILE GLOBAL g_371 */
static struct S2 g_373 = {0x99FCA559L,0xDD172D46L,0x76L};/* VOLATILE GLOBAL g_373 */
static struct S1 g_401 = {18446744073709551615UL,0x0.Bp-1};/* VOLATILE GLOBAL g_401 */
static int32_t *** volatile g_412 = &g_134;/* VOLATILE GLOBAL g_412 */
static int32_t *** volatile * volatile g_411 = &g_412;/* VOLATILE GLOBAL g_411 */
static int32_t *** volatile * volatile * volatile g_410 = &g_411;/* VOLATILE GLOBAL g_410 */
static struct S0 ** volatile g_415 = &g_39;/* VOLATILE GLOBAL g_415 */
static struct S1 g_455 = {1UL,0x0.7p+1};/* VOLATILE GLOBAL g_455 */
static struct S0 ** volatile g_456 = &g_39;/* VOLATILE GLOBAL g_456 */
static struct S2 g_473 = {1UL,0x5E898998L,0x22L};/* VOLATILE GLOBAL g_473 */
static struct S2 g_474 = {18446744073709551606UL,1L,0xD5L};/* VOLATILE GLOBAL g_474 */
static volatile struct S2 **g_477 = &g_155;
static volatile struct S2 *** volatile g_476 = &g_477;/* VOLATILE GLOBAL g_476 */
static int32_t g_489 = 6L;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_28(void);
inline static struct S0 * func_33(int16_t  p_34, struct S0 * p_35);
inline static int32_t  func_45(int32_t  p_46, int32_t  p_47);
static uint16_t  func_50(int32_t * p_51, int32_t * p_52, struct S1 * p_53);
inline static int32_t * func_55(struct S0 *** p_56, struct S0 * p_57, int16_t  p_58, uint16_t  p_59, int32_t  p_60);
static struct S0 *** func_61(struct S0 ** p_62, float  p_63);
inline static struct S0 ** func_64(uint16_t  p_65, struct S0 * p_66, uint32_t  p_67, float  p_68, int16_t  p_69);
inline static uint16_t  func_70(struct S0 * p_71);
static int32_t  func_73(uint16_t  p_74, int32_t ** p_75, uint32_t  p_76);
static uint16_t  func_77(struct S0 *** p_78, int32_t * p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_4 g_31 g_37 g_415 g_371.f0 g_40.f3 g_134
 * writes: g_4 g_31 g_38 g_40.f2 g_39 g_371.f0 g_40.f3 g_135
 */
inline static int32_t  func_28(void)
{ /* block id: 36 */
    struct S2 *l_417 = &g_373;
    struct S2 **l_416 = &l_417;
    int32_t l_430 = 0x4DFE6B94L;
    struct S1 *l_454 = &g_455;
    for (g_4 = 0; (g_4 != (-16)); g_4 = safe_sub_func_uint16_t_u_u(g_4, 8))
    { /* block id: 39 */
        volatile struct S1 *l_32 = &g_31;
        struct S0 *l_36 = (void*)0;
        (*l_32) = g_31;
        (*g_415) = func_33(g_4, l_36);
        /* statement id: 336 */
        assert (g_39 == 0);
        //assert (g_38 == dangling);
    }
    /* facts after for loop */
    assert (g_39 == 0 || g_39 == &g_40);
    //assert (g_38 == dangling || g_38 == &g_39);
    (*l_416) = &g_373;
    for (g_371.f0 = 0; (g_371.f0 != 20); g_371.f0 = safe_add_func_int32_t_s_s(g_371.f0, 1))
    { /* block id: 341 */
        int16_t l_441 = 1L;
        struct S0 ***l_445 = &g_38;
        int32_t *l_501 = &l_430;
        (*l_416) = &g_373;
        for (g_40.f3 = 0; (g_40.f3 >= 3); ++g_40.f3)
        { /* block id: 345 */
            int32_t *l_440 = (void*)0;
            struct S0 *l_447 = (void*)0;
            int32_t l_486 = 0x2BEF0158L;
            uint32_t l_494 = 3UL;
        }
    }
    (*g_134) = (void*)0;
    /* statement id: 389 */
    assert (g_135 == 0);
    return l_430;
}


/* ------------------------------------------ */
/* 
 * reads : g_37 g_40.f2
 * writes: g_38 g_40.f2
 */
inline static struct S0 * func_33(int16_t  p_34, struct S0 * p_35)
{ /* block id: 41 */
    int32_t *l_42 = &g_40.f2;
    int32_t **l_41 = &l_42;
    (*g_37) = &p_35;
    /* statement id: 42 */
    assert (g_38 == &p_35);
    (*l_41) = (void*)0;
    /* statement id: 43 */
    assert (l_42 == 0);
    for (g_40.f2 = 0; (g_40.f2 >= 8); g_40.f2 = safe_add_func_int32_t_s_s(g_40.f2, 4))
    { /* block id: 46 */
        int32_t *l_414 = &g_118;
    }
    return p_35;
    /* statement id: 335 */
    //assert (g_38 == dangling);
    //assert (func_33_rv == 0 || func_33_rv == &g_40);
}


/* ------------------------------------------ */
/* 
 * reads : g_37 g_38 g_4 g_40.f3 g_80 g_40.f2 g_40.f0 g_40.f4 g_40.f1 g_39 g_40 g_118 g_83.f0 g_93 g_108 g_134 g_135 g_120 g_155 g_172.f0 g_174.f0 g_257 g_240.f0 g_292 g_299 g_244.f0 g_301 g_371 g_300 g_293 g_373.f0 g_302 g_410
 * writes: g_93 g_108 g_118 g_120 g_135 g_155 g_39 g_40.f1 g_257 g_172.f0 g_40.f5 g_299 g_301 g_174.f0 g_302 g_40.f3 g_134 g_258 g_410
 */
inline static int32_t  func_45(int32_t  p_46, int32_t  p_47)
{ /* block id: 47 */
    int32_t *l_54 = (void*)0;
    struct S0 *l_72 = &g_40;
    struct S1 *l_370 = &g_371;
    int32_t l_413 = 0L;
    if ((p_46 >= (((*g_37) == &g_39) < ((safe_lshift_func_uint16_t_u_u(g_4, func_50(l_54, func_55(func_61(func_64(func_70(l_72), l_72, g_83.f0, p_46, p_47), g_40.f4), l_72, g_83.f0, p_47, p_47), l_370))) ^ 0x5FD84620L))))
    { /* block id: 287 */
        (***g_299) = (*l_370);
        if ((g_172.f0 < p_46))
        { /* block id: 289 */
            int32_t ***l_382 = &g_134;
            for (g_40.f3 = 24; (g_40.f3 == 23); g_40.f3--)
            { /* block id: 292 */
                return p_47;
            }
            (*l_382) = (void*)0;
            /* statement id: 295 */
            assert (g_134 == 0);
            return p_46;
        }
        else
        { /* block id: 297 */
            (*g_134) = &p_46;
            /* statement id: 298 */
            assert (g_135 == &p_46);
            (**g_299) = l_370;
            /* statement id: 299 */
            assert (g_301 == &g_371);
        }
        /* facts after branching */
        assert (g_135 == &p_46);
        assert (g_301 == &g_371);
        for (p_47 = (-21); (p_47 > 17); p_47 = safe_add_func_uint32_t_u_u(p_47, 4))
        { /* block id: 303 */
            return p_46;
            /* statement id: 304 */
            //assert (g_135 == dangling);
        }
        (*g_134) = &p_47;
        /* statement id: 306 */
        assert (g_135 == &p_47);
    }
    else
    { /* block id: 307 */
        int32_t *****l_385 = (void*)0;
        (**g_292) = ((l_385 == (void*)0) < (**g_292));
    }
    /* facts after branching */
    //assert (g_39 == &g_40 || g_39 == dangling);
    //assert (p_35 == dangling || p_35 == 0);
    //assert (g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120 || g_135 == &p_47);
    assert (g_301 == &g_302 || g_301 == &g_371);
    for (g_40.f3 = 0; (g_40.f3 < 2); g_40.f3 = safe_add_func_int16_t_s_s(g_40.f3, 1))
    { /* block id: 312 */
        struct S1 *l_400 = &g_401;
        int16_t l_402 = 7L;
        int32_t *l_404 = &g_118;
        struct S0 **l_405 = &g_39;
        if (p_47)
        { /* block id: 313 */
            for (g_93 = (-5); (g_93 >= 9); ++g_93)
            { /* block id: 316 */
                struct S0 l_390 = {-1L,0x8F71L,0x0FEE5A66L,0x493B48CEL,0x18L,-1L};
                int32_t *l_399 = &l_390.f2;
                int16_t l_403 = 0xEDF1L;
                l_390 = (*l_72);
                (**g_292) = ((*g_293) >= (safe_add_func_float_f_f((-0x1.0p+1), (safe_sub_func_float_f_f((safe_sub_func_float_f_f((p_46 <= ((p_46 != (safe_add_func_float_f_f(func_50(l_54, l_399, l_400), (0x4.E9F4E4p-62 != l_402)))) == l_403)), p_47)), g_373.f0)))));
                (*g_257) = (**g_300);
            }
            (*g_38) = (void*)0;
            /* statement id: 321 */
            //assert (p_35 == 0);
            (*g_134) = (void*)0;
            /* statement id: 322 */
            assert (g_135 == 0);
            (*g_134) = (void*)0;
        }
        else
        { /* block id: 324 */
            l_404 = &p_46;
            /* statement id: 325 */
            assert (l_404 == &p_46);
        }
        /* facts after branching */
        assert (l_404 == &p_46 || l_404 == &g_118);
        (*g_134) = func_55(&g_38, &g_40, ((*l_404) > ((p_46 ^ (((((0x26CEL || p_47) || (((((safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((*g_292) != l_404), g_4)), p_46)) != 0L) || 0xC681E322L) || 0x5259L) | g_83.f0)) & p_47) & g_83.f0) > p_47)) >= p_46)), p_47, p_46);
        /* statement id: 327 */
        assert (g_135 == &g_118);
        g_410 = g_410;
    }
    return l_413;
    /* statement id: 330 */
    //assert (g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f1 g_174.f0 g_40.f0
 * writes: g_118
 */
static uint16_t  func_50(int32_t * p_51, int32_t * p_52, struct S1 * p_53)
{ /* block id: 282 */
    struct S2 *l_372 = &g_373;
    struct S2 **l_374 = (void*)0;
    struct S2 **l_375 = &l_372;
    struct S0 l_376 = {0x7808L,4L,0L,0x31313D4EL,0xEFL,0x8340L};
    struct S0 *l_377 = &l_376;
    (*l_375) = l_372;
    (*l_377) = l_376;
    (*p_52) = (safe_mod_func_uint32_t_u_u(g_40.f1, __builtin_ia32_crc32qi(((l_376.f0 > 0xDD203B5EL) <= g_174.f0), g_40.f0)));
    return g_40.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_174.f0 g_134 g_40
 * writes: g_174.f0 g_135
 */
inline static int32_t * func_55(struct S0 *** p_56, struct S0 * p_57, int16_t  p_58, uint16_t  p_59, int32_t  p_60)
{ /* block id: 272 */
    struct S0 l_367 = {0x4D6CL,1L,0x127003CCL,-1L,3UL,0xF94CL};
    int32_t *l_369 = &g_118;
    for (g_174.f0 = 0; (g_174.f0 >= 5); ++g_174.f0)
    { /* block id: 275 */
        int32_t *l_366 = (void*)0;
        struct S0 *l_368 = &l_367;
        (*g_134) = l_366;
        /* statement id: 276 */
        assert (g_135 == 0);
        (*l_368) = l_367;
    }
    l_367.f2 = p_59;
    l_367 = (*p_57);
    return l_369;
    /* statement id: 281 */
    //assert (func_55_rv == &g_118);
}


/* ------------------------------------------ */
/* 
 * reads : g_93 g_108 g_40.f2 g_134 g_118 g_135 g_4 g_40.f1 g_39 g_120 g_40.f0 g_155 g_40 g_172.f0 g_174.f0 g_257 g_240.f0 g_292 g_83.f0 g_299 g_38 g_244.f0 g_301
 * writes: g_118 g_120 g_135 g_93 g_155 g_39 g_40.f1 g_257 g_172.f0 g_40.f5 g_299 g_301 p_35
 */
static struct S0 *** func_61(struct S0 ** p_62, float  p_63)
{ /* block id: 86 */
    uint32_t l_127 = 0xB3C44AE9L;
    float l_132 = (-0x1.5p-1);
    int32_t l_133 = (-10L);
    struct S0 *l_143 = &g_40;
    int16_t l_144 = (-1L);
    int32_t **l_145 = &g_135;
    float l_148 = (-0x1.Ap+1);
    uint16_t l_149 = 0x5036L;
    struct S0 ***l_150 = &g_38;
    int32_t *l_151 = &g_40.f2;
    uint8_t l_152 = 252UL;
    struct S1 *l_171 = &g_172;
    int32_t **l_295 = &l_151;
    float l_324 = 0xD.73D204p-32;
    struct S0 l_328 = {1L,-6L,-1L,-9L,1UL,0x6B51L};
    float *l_342 = &l_324;
    float **l_341 = &l_342;
    if (((g_93 != (4UL == (safe_lshift_func_uint16_t_u_s(0UL, __builtin_ffsll(((0xBAC11434L >= (0x5D29L == ((g_108 == (__builtin_bswap64(l_127) <= func_73((safe_sub_func_uint16_t_u_u((((((safe_rshift_func_uint16_t_u_s(l_127, 2)) != l_127) || l_127) ^ l_133) && l_127), g_40.f2)), g_134, l_127))) ^ g_93))) < g_4)))))) > l_127))
    { /* block id: 87 */
        float *l_137 = &g_120;
        (**g_134) = (~((l_137 != (void*)0) != g_40.f1));
        (*g_134) = l_137;
        /* statement id: 89 */
        assert (g_135 == &g_120);
    }
    else
    { /* block id: 90 */
        int16_t l_138 = (-3L);
        (**g_134) = (*g_135);
        (*g_135) = l_138;
    }
    /* facts after branching */
    assert (g_135 == &g_118 || g_135 == &g_120);
    for (g_93 = 0; (g_93 > 13); ++g_93)
    { /* block id: 96 */
        (**g_134) = (safe_rshift_func_uint16_t_u_u(5UL, ((l_143 != (*p_62)) > g_93)));
        (*g_135) = (&g_39 != p_62);
        if ((*g_135))
            continue;
    }
    if (((func_73(l_144, l_145, (**l_145)) ^ (((safe_sub_func_int32_t_s_s(((g_4 & l_149) && g_93), (*l_151))) | g_40.f0) > (*l_151))) < l_152))
    { /* block id: 101 */
        struct S0 l_158 = {1L,-1L,0x4B26C247L,-1L,0xA5L,0x5748L};
        float *l_159 = &g_120;
        int32_t *l_205 = &l_158.f2;
        struct S0 *l_216 = &g_40;
        struct S1 *l_243 = &g_244;
        for (l_127 = 0; (l_127 >= 55); ++l_127)
        { /* block id: 104 */
            volatile struct S2 **l_156 = &g_155;
            struct S0 l_157 = {1L,0x5D01L,1L,-1L,0x97L,0x59C6L};
            (*l_156) = g_155;
            l_158 = l_157;
        }
        (*g_134) = (*g_134);
        (*l_159) = (&l_158 == (void*)0);
        if ((safe_add_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(7L, ((((0xD821L && 0xC81AL) | (safe_lshift_func_uint16_t_u_s(0xAA16L, 7))) ^ (**l_145)) | (g_40.f2 ^ (*g_135))))), (((0x7DB5L & (*l_151)) <= 5UL) < l_158.f0))))
        { /* block id: 110 */
            struct S0 l_166 = {6L,4L,-10L,0xC0765CA4L,0x0DL,0L};
            float *l_197 = &g_120;
            volatile struct S2 **l_207 = (void*)0;
            volatile struct S2 **l_208 = (void*)0;
            volatile struct S2 *l_209 = &g_210;
            l_166 = l_166;
            if ((**l_145))
            { /* block id: 112 */
                struct S1 **l_191 = &l_171;
                int32_t l_196 = 0x2C3DD90FL;
                (*p_62) = &l_166;
                /* statement id: 113 */
                assert (g_39 == &l_166);
                if ((**g_134))
                { /* block id: 114 */
                    struct S1 *l_173 = &g_174;
                    int32_t l_178 = 0xE7E0054FL;
                    for (l_166.f5 = (-15); (l_166.f5 == (-4)); l_166.f5 = safe_add_func_int32_t_s_s(l_166.f5, 1))
                    { /* block id: 117 */
                        int32_t l_175 = 0x808DCF83L;
                        (*l_145) = (void*)0;
                        /* statement id: 118 */
                        assert (g_135 == 0);
                        l_178 = (safe_rshift_func_int16_t_s_s(((l_171 != l_173) != (l_175 && (safe_lshift_func_int16_t_s_s(0x2B29L, g_40.f2)))), 0));
                        (*l_159) = (l_159 != l_159);
                    }
                    /* facts after for loop */
                    assert (g_135 == 0 || g_135 == &g_118);
                }
                else
                { /* block id: 122 */
                    struct S1 **l_192 = &l_171;
                    for (g_40.f1 = (-16); (g_40.f1 != 8); ++g_40.f1)
                    { /* block id: 125 */
                        uint32_t l_183 = 0x96275E07L;
                        struct S1 *l_195 = (void*)0;
                        int32_t **l_198 = &l_151;
                        (*l_159) = (safe_sub_func_float_f_f(l_183, (safe_sub_func_float_f_f(l_166.f2, (safe_add_func_float_f_f((-((safe_add_func_float_f_f(((l_191 != l_192) > (safe_add_func_float_f_f((((((void*)0 == l_159) <= ((*l_192) != l_195)) >= l_196) != 0xC.CEB7EDp-8), l_183))), p_63)) == p_63)), g_4))))));
                        (*l_197) = ((l_197 != l_159) == (((p_63 != (l_198 == l_198)) >= (__builtin_clzll((safe_rshift_func_uint16_t_u_s((safe_add_func_int16_t_s_s(((**l_198) | (65535UL >= (**l_198))), (safe_mod_func_int16_t_s_s((g_4 >= (-1L)), 65533UL)))), 7))) != 0x7.83B8F3p-66)) < p_63));
                        if ((*g_135))
                            continue;
                    }
                    (*g_134) = l_197;
                    /* statement id: 130 */
                    assert (g_135 == &g_120);
                }
                /* facts after branching */
                assert (g_135 == &g_120 || g_135 == 0 || g_135 == &g_118);
                l_205 = (*g_134);
                /* statement id: 132 */
                assert (l_205 == &g_120 || l_205 == 0 || l_205 == &g_118);
            }
            else
            { /* block id: 133 */
                struct S0 *l_206 = &l_158;
                (*l_206) = (*l_143);
            }
            /* facts after branching */
            assert (g_39 == &g_40 || g_39 == &l_166);
            assert (g_135 == &g_120 || g_135 == 0 || g_135 == &g_118);
            assert (l_205 == &l_158.f2 || l_205 == &g_120 || l_205 == 0 || l_205 == &g_118);
            l_209 = g_155;
            /* statement id: 136 */
            assert (l_209 == 0);
        }
        else
        { /* block id: 137 */
            int32_t *l_217 = &g_40.f2;
            int32_t l_223 = 7L;
            float **l_253 = &l_159;
            struct S0 l_255 = {-1L,1L,0L,0x8BB7CF6DL,1UL,0L};
            if ((safe_lshift_func_int16_t_s_u((safe_sub_func_int16_t_s_s(g_40.f1, (~(l_216 != &l_158)))), 1)))
            { /* block id: 138 */
                struct S0 l_218 = {0xE5DDL,0x06F2L,0L,0x3C908D26L,0x2EL,-2L};
                struct S0 *l_219 = &l_158;
                (*g_134) = l_217;
                /* statement id: 139 */
                assert (g_135 == &g_40.f2);
                (*l_219) = l_218;
            }
            else
            { /* block id: 141 */
                uint32_t l_222 = 0xE0FA803EL;
                struct S1 **l_237 = &l_171;
                struct S1 ***l_236 = &l_237;
                int32_t *l_247 = (void*)0;
                struct S0 l_261 = {1L,0L,0x4B60E2EDL,1L,255UL,1L};
                if (((safe_lshift_func_int16_t_s_s(l_222, 8)) <= (l_223 != (((*l_217) == g_108) > (((safe_mod_func_int16_t_s_s((l_222 != (safe_add_func_uint32_t_u_u(((void*)0 != l_159), (*l_151)))), func_73(__builtin_parity((l_222 >= 0x42F718E4L)), &g_135, g_40.f5))) != l_222) > (*l_217))))))
                { /* block id: 142 */
                    if (((0x2E74L | (-2L)) && ((((safe_rshift_func_uint16_t_u_s((safe_mod_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(g_4, 0xBCE5L)) && (safe_lshift_func_uint16_t_u_s((l_222 > g_93), 10))), (*l_217))), 9)) < (*l_217)) == ((((&g_38 == (void*)0) <= 0x6B08L) > (**l_145)) > (*l_205))) < g_172.f0)))
                    { /* block id: 143 */
                        struct S1 ****l_238 = &l_236;
                        struct S2 *l_239 = &g_240;
                        struct S2 **l_241 = (void*)0;
                        struct S2 **l_242 = &l_239;
                        (*l_238) = l_236;
                        (*l_242) = l_239;
                        (*g_134) = &l_223;
                        /* statement id: 146 */
                        assert (g_135 == &l_223);
                    }
                    else
                    { /* block id: 147 */
                        uint32_t l_250 = 18446744073709551612UL;
                        (*l_237) = l_171;
                        (**l_236) = l_243;
                        /* statement id: 149 */
                        assert (l_171 == &g_244);
                        (*l_205) = (safe_lshift_func_int16_t_s_s(((__builtin_ffsll(((*l_205) ^ (((*l_217) & (((l_247 != (*g_134)) | ((safe_lshift_func_int16_t_s_u(0x6541L, (*l_217))) || (((**g_134) == __builtin_ia32_crc32qi(g_4, g_40.f5)) | 0xF776L))) != 0x7E34FB19L)) != (**l_145)))) ^ (**l_145)) != l_250), (*l_205)));
                        (*l_145) = (void*)0;
                        /* statement id: 151 */
                        assert (g_135 == 0);
                    }
                    /* facts after branching */
                    assert (g_135 == 0 || g_135 == &l_223);
                    assert (l_171 == &g_244 || l_171 == &g_172);
                }
                else
                { /* block id: 153 */
                    struct S0 **l_256 = (void*)0;
                    if ((**g_134))
                    { /* block id: 154 */
                        struct S0 ***l_251 = &g_38;
                        int32_t l_252 = 0xAA2D425EL;
                        l_252 = (((void*)0 == l_251) != (g_174.f0 == g_108));
                    }
                    else
                    { /* block id: 156 */
                        float ***l_254 = &l_253;
                        volatile struct S1 **l_259 = (void*)0;
                        volatile struct S1 **l_260 = &g_257;
                        (*l_254) = l_253;
                        l_255 = (**p_62);
                        (*l_159) = (((void*)0 != l_256) >= (0x6.6A8F6Bp-0 > 0x5.5p+1));
                        (*l_260) = g_257;
                    }
                }
                /* facts after branching */
                assert (g_135 == &g_118 || g_135 == 0 || g_135 == &l_223);
                assert (l_171 == &g_244 || l_171 == &g_172);
                (*l_205) = l_222;
                l_261 = (*g_39);
                (**l_253) = (-0x1.8p-1);
            }
            /* facts after branching */
            assert (g_135 == &g_118 || g_135 == 0 || g_135 == &l_223 || g_135 == &g_40.f2);
            assert (l_171 == &g_244 || l_171 == &g_172);
            (*l_205) = (*l_217);
            (*l_159) = g_118;
        }
        /* facts after branching */
        //assert (g_39 == &g_40 || g_39 == dangling);
        //assert (g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
        assert (l_171 == &g_244 || l_171 == &g_172);
        assert (l_205 == &l_158.f2 || l_205 == &g_120 || l_205 == 0 || l_205 == &g_118);
    }
    else
    { /* block id: 170 */
        int32_t ****l_262 = (void*)0;
        int32_t ***l_264 = &l_145;
        int32_t ****l_263 = &l_264;
        (*l_263) = &l_145;
        (*l_145) = (*l_145);
        return &g_38;
        /* statement id: 173 */
        //assert (func_61_rv == &g_38);
    }
    /* facts after branching */
    //assert (g_39 == &g_40 || g_39 == dangling);
    //assert (g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
    assert (l_171 == &g_244 || l_171 == &g_172);
    if (((g_40.f1 & __builtin_ffsl((*l_151))) || (*l_151)))
    { /* block id: 175 */
        int16_t l_265 = 0xBE56L;
        uint32_t l_268 = 0xB5224E52L;
        int32_t **l_271 = &l_151;
        struct S0 *l_281 = (void*)0;
        struct S0 *l_288 = &g_40;
        int32_t *l_291 = &l_133;
        struct S1 **l_316 = &g_301;
        struct S1 ***l_315 = &l_316;
        int32_t l_344 = 0xBC05B624L;
        g_118 = (*l_151);
        if (l_265)
        { /* block id: 177 */
            float l_269 = 0x6.0p+1;
            int32_t l_270 = 0x1BBB7458L;
            struct S0 l_327 = {0x70B4L,1L,-1L,0L,0x08L,0x002FL};
            if ((safe_sub_func_uint32_t_u_u((g_240.f0 < (((l_268 > l_270) || ((((0xA105L == l_268) > 0xF5A50C07L) && ((65535UL < 0x12A2L) | ((l_270 > (*l_151)) == l_265))) < 0x7ABCL)) | 7UL)), l_270)))
            { /* block id: 178 */
                l_271 = &l_151;
            }
            else
            { /* block id: 180 */
                int32_t l_276 = 0x98B16B54L;
                (*l_145) = &l_270;
                /* statement id: 181 */
                assert (g_135 == &l_270);
                if (((safe_sub_func_uint32_t_u_u(g_40.f0, ((((*l_151) < l_270) >= __builtin_ctzll((**l_271))) | g_40.f4))) | __builtin_ctzl(((safe_sub_func_uint16_t_u_u(((l_276 & l_270) ^ g_172.f0), 0x65A0L)) >= (*l_151)))))
                { /* block id: 182 */
                    for (g_172.f0 = 0; (g_172.f0 <= 4); g_172.f0 = safe_add_func_uint32_t_u_u(g_172.f0, 1))
                    { /* block id: 185 */
                        float l_284 = (-0x1.Ep-1);
                        float *l_285 = &l_284;
                        (*l_285) = ((__builtin_popcountl((l_276 || (safe_sub_func_int32_t_s_s(0xC704BBC3L, (**l_271))))) > (safe_sub_func_float_f_f(g_40.f5, (((0x4.E4DCE9p+38 <= ((l_276 < 0xA.BF98AFp+86) < g_40.f4)) != l_284) == g_40.f0)))) > p_63);
                    }
                    for (g_40.f5 = 0; (g_40.f5 == 28); ++g_40.f5)
                    { /* block id: 190 */
                        (**l_145) = (**g_134);
                    }
                }
                else
                { /* block id: 193 */
                    (*l_145) = (*g_134);
                    for (l_152 = (-20); (l_152 >= 27); l_152 = safe_add_func_uint16_t_u_u(l_152, 6))
                    { /* block id: 197 */
                        (*l_145) = l_291;
                        /* statement id: 198 */
                        assert (g_135 == &l_133);
                    }
                    /* facts after for loop */
                    assert (g_135 == &l_133 || g_135 == &l_270);
                }
                /* facts after branching */
                assert (g_135 == &l_133 || g_135 == &l_270);
            }
            /* facts after branching */
            //assert (g_135 == &l_133 || g_135 == &l_270 || g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
            if (__builtin_ctzll((**l_271)))
            { /* block id: 202 */
                int32_t *l_306 = &g_118;
                float *l_325 = &l_324;
                if (((**l_271) & l_270))
                { /* block id: 203 */
                    uint32_t l_294 = 0x59C8D91AL;
                    struct S0 ****l_298 = &g_80;
                    struct S0 *****l_297 = &l_298;
                    if (((((*l_291) || ((void*)0 != g_292)) || l_294) > (*l_151)))
                    { /* block id: 204 */
                        int32_t ***l_296 = &l_145;
                        (*l_296) = l_295;
                        /* statement id: 205 */
                        assert (l_145 == &l_151);
                    }
                    else
                    { /* block id: 206 */
                        (*l_291) = 0x497FD416L;
                    }
                    /* facts after branching */
                    assert (l_145 == &g_135 || l_145 == &l_151);
                    (*l_291) = (g_83.f0 != (g_40.f0 == l_270));
                    (*l_297) = (void*)0;
                    /* statement id: 210 */
                    assert (l_298 == 0);
                    if (l_270)
                    { /* block id: 211 */
                        struct S1 ** volatile **l_303 = (void*)0;
                        struct S1 ** volatile **l_304 = &g_299;
                        (*l_304) = g_299;
                        (*g_134) = (*l_295);
                        /* statement id: 213 */
                        assert (g_135 == &g_40.f2);
                    }
                    else
                    { /* block id: 214 */
                        struct S0 *l_305 = (void*)0;
                        int32_t l_309 = 6L;
                        (**l_150) = l_305;
                        /* statement id: 215 */
                        //assert (p_35 == 0);
                        (*l_145) = l_306;
                        /* statement id: 216 */
                        assert (l_151 == &g_118 || l_151 == &g_40.f2);
                        (*l_291) = ((-8L) > (safe_add_func_uint32_t_u_u(((l_309 != (l_270 && (__builtin_ctzll(g_40.f2) && ((safe_lshift_func_int16_t_s_s((g_40.f5 == (safe_sub_func_int16_t_s_s(l_270, (safe_unary_minus_func_int32_t_s(l_270))))), (*l_306))) ^ l_309)))) & 4294967295UL), g_108)));
                        (*l_297) = (*l_297);
                    }
                    /* facts after branching */
                    assert (l_151 == &g_118 || l_151 == &g_40.f2);
                }
                else
                { /* block id: 220 */
                    struct S1 ****l_317 = &l_315;
                    (*l_317) = l_315;
                    (*g_134) = (void*)0;
                    /* statement id: 222 */
                    assert (g_135 == 0);
                }
                /* facts after branching */
                assert (l_145 == &g_135 || l_145 == &l_151);
                assert (l_151 == &g_118 || l_151 == &g_40.f2);
                (*l_325) = (safe_add_func_float_f_f(p_63, (((safe_sub_func_float_f_f(((*l_295) != (void*)0), (-0x3.9p-1))) != (safe_sub_func_float_f_f(p_63, (l_324 != (((*l_306) == p_63) == ((g_40.f4 == l_270) <= p_63)))))) <= p_63)));
            }
            else
            { /* block id: 225 */
                float *l_326 = &l_324;
                (*l_326) = (0x7.Dp-1 < l_270);
            }
            /* facts after branching */
            assert (l_145 == &g_135 || l_145 == &l_151);
            assert (l_151 == &g_118 || l_151 == &g_40.f2);
            l_328 = l_327;
        }
        else
        { /* block id: 229 */
            struct S0 *l_343 = (void*)0;
            int32_t l_345 = 0x9B6341C7L;
            if ((safe_lshift_func_int16_t_s_s(g_244.f0, (**l_295))))
            { /* block id: 230 */
                volatile struct S2 **l_331 = &g_155;
                int32_t l_332 = 3L;
                int32_t *l_356 = &l_332;
                struct S0 *l_357 = &l_328;
                (*l_331) = g_155;
                if ((l_332 ^ (safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((((((safe_add_func_uint16_t_u_u(3UL, (l_341 != g_292))) && 65528UL) <= (0xF82BL > (l_332 || (l_332 ^ (((g_40.f3 || 0x24EAL) < 65530UL) != (*l_291)))))) > 1L) && l_344) ^ l_345), (*l_151))), (**l_271)))))
                { /* block id: 232 */
                    struct S0 l_351 = {-6L,-1L,1L,0x85A4F545L,248UL,9L};
                    for (l_152 = 0; (l_152 >= 39); ++l_152)
                    { /* block id: 235 */
                        return &g_38;
                        /* statement id: 236 */
                        //assert (func_61_rv == &g_38);
                    }
                    (*l_316) = (*l_316);
                    if ((safe_lshift_func_uint16_t_u_s(((g_240.f0 == g_40.f2) >= l_345), (*l_151))))
                    { /* block id: 239 */
                        uint32_t l_350 = 0x74DE13DCL;
                        (**l_341) = (0x6.6FD628p+88 != (l_332 < (g_93 != l_350)));
                    }
                    else
                    { /* block id: 241 */
                        int32_t ****l_352 = (void*)0;
                        int32_t *****l_353 = &l_352;
                        (*l_291) = 9L;
                        l_351 = g_40;
                        (*l_353) = l_352;
                    }
                }
                else
                { /* block id: 246 */
                    for (g_172.f0 = (-28); (g_172.f0 <= 10); g_172.f0 = safe_add_func_int16_t_s_s(g_172.f0, 1))
                    { /* block id: 249 */
                        return &g_38;
                        /* statement id: 250 */
                        //assert (func_61_rv == &g_38);
                    }
                    l_356 = &g_118;
                    /* statement id: 252 */
                    assert (l_356 == &g_118);
                }
                /* facts after branching */
                assert (l_356 == &g_118 || l_356 == &l_332);
                (*p_62) = l_357;
                /* statement id: 254 */
                assert (g_39 == &l_328);
                for (g_172.f0 = 18; (g_172.f0 >= 11); g_172.f0 = safe_sub_func_uint32_t_u_u(g_172.f0, 7))
                { /* block id: 257 */
                    (**l_341) = p_63;
                }
            }
            else
            { /* block id: 260 */
                for (l_127 = 0; (l_127 != 30); l_127 = safe_add_func_int16_t_s_s(l_127, 5))
                { /* block id: 263 */
                    struct S0 l_362 = {-9L,-8L,-6L,0x505C1A46L,1UL,0x8D7BL};
                    l_362 = (*l_143);
                }
            }
            /* facts after branching */
            //assert (g_39 == &g_40 || g_39 == dangling || g_39 == &l_328);
        }
        /* facts after branching */
        //assert (g_39 == &g_40 || g_39 == dangling || g_39 == &l_328);
        //assert (g_135 == &l_133 || g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
        assert (l_145 == &g_135 || l_145 == &l_151);
        assert (l_151 == &g_118 || l_151 == &g_40.f2);
    }
    else
    { /* block id: 268 */
        int32_t *l_363 = &l_328.f2;
        (*l_295) = l_363;
        /* statement id: 269 */
        assert (l_151 == &l_328.f2);
    }
    /* facts after branching */
    //assert (g_39 == &g_40 || g_39 == dangling || g_39 == &l_328);
    //assert (g_135 == &l_133 || g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
    assert (l_145 == &g_135 || l_145 == &l_151);
    assert (l_151 == &l_328.f2 || l_151 == &g_118 || l_151 == &g_40.f2);
    return l_150;
    /* statement id: 271 */
    //assert (g_39 == &g_40 || g_39 == dangling);
    //assert (g_135 == &g_118 || g_135 == 0 || g_135 == dangling || g_135 == &g_40.f2 || g_135 == &g_120);
    //assert (func_61_rv == &g_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 ** func_64(uint16_t  p_65, struct S0 * p_66, uint32_t  p_67, float  p_68, int16_t  p_69)
{ /* block id: 84 */
    return &g_39;
    /* statement id: 85 */
    //assert (func_64_rv == &g_39);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f3 g_80 g_40.f2 g_40.f0 g_40.f4 g_40.f1 g_38 g_39 g_40 g_4 g_118 p_35
 * writes: g_93 g_108 g_118 g_120 p_35
 */
inline static uint16_t  func_70(struct S0 * p_71)
{ /* block id: 48 */
    int32_t *l_81 = &g_40.f2;
    int32_t *l_122 = &g_118;
    (*l_122) = ((g_40.f3 && 0xBBBBL) || func_73((func_77(g_80, l_81) < (__builtin_ctz(g_40.f2) >= ((safe_lshift_func_int16_t_s_u((-1L), (safe_mod_func_uint32_t_u_u((safe_add_func_uint16_t_u_u((*l_81), g_40.f5)), 4294967291UL)))) || (*l_81)))), &l_81, (*l_81)));
    /* statement id: 82 */
    //assert (p_35 == dangling || p_35 == 0);
    assert (l_81 == &g_40.f2 || l_81 == &g_118);
    return g_40.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_118 g_135
 * writes: g_118 g_120 g_135
 */
static int32_t  func_73(uint16_t  p_74, int32_t ** p_75, uint32_t  p_76)
{ /* block id: 76 */
    int32_t l_115 = (-6L);
    int32_t *l_116 = (void*)0;
    int32_t *l_117 = &g_118;
    float *l_119 = &g_120;
    struct S0 **l_121 = &g_39;
    (*l_117) = l_115;
    (*l_119) = (*l_117);
    l_121 = l_121;
    (*p_75) = &g_118;
    /* statement id: 80 */
    //assert (l_81 == &g_118);
    return (**p_75);
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f2 g_40.f0 g_40.f4 g_40.f1 g_38 g_39 g_40 g_4 p_35
 * writes: g_93 g_108 p_35
 */
static uint16_t  func_77(struct S0 *** p_78, int32_t * p_79)
{ /* block id: 49 */
    struct S1 *l_82 = &g_83;
    struct S0 l_85 = {3L,-4L,0x13E67DCAL,-9L,0xF9L,-3L};
    struct S0 **l_87 = &g_39;
    float l_97 = (-0x1.1p-1);
    if (((*p_79) && (g_40.f0 != g_40.f4)))
    { /* block id: 50 */
        struct S1 **l_84 = &l_82;
        (*l_84) = l_82;
    }
    else
    { /* block id: 52 */
        struct S0 *l_86 = &l_85;
        int32_t *l_92 = &l_85.f2;
        (*l_86) = l_85;
        (*l_92) = ((l_87 != &l_86) ^ ((safe_rshift_func_uint16_t_u_u(65527UL, 3)) == (safe_lshift_func_int16_t_s_u(g_40.f0, 0))));
    }
    if ((*p_79))
    { /* block id: 56 */
        g_93 = (*p_79);
    }
    else
    { /* block id: 58 */
        int32_t l_96 = 0L;
        float *l_98 = &l_97;
        struct S0 *l_99 = &l_85;
        int32_t *l_101 = &l_85.f2;
        int32_t **l_100 = &l_101;
        (*l_98) = (((g_40.f1 == g_40.f4) < (safe_add_func_float_f_f(((*g_38) == (*l_87)), (l_85.f5 <= l_96)))) != l_97);
        (*l_99) = (*g_39);
        (*l_100) = &g_4;
        /* statement id: 61 */
        assert (l_101 == &g_4);
        for (l_96 = 0; (l_96 > (-16)); l_96 = safe_sub_func_int16_t_s_s(l_96, 1))
        { /* block id: 64 */
            uint16_t l_104 = 0x4228L;
            (*l_98) = l_104;
            for (l_85.f4 = 0; (l_85.f4 > 14); l_85.f4 = safe_add_func_int16_t_s_s(l_85.f4, 1))
            { /* block id: 68 */
                struct S0 ***l_107 = &l_87;
                (*l_107) = &l_99;
                /* statement id: 69 */
                assert (l_87 == &l_99);
                (*g_38) = l_99;
                /* statement id: 70 */
                //assert (p_35 == &l_85);
                g_108 = g_4;
            }
        }
        /* facts after for loop */
        //assert (p_35 == &l_85 || p_35 == 0);
        assert (l_87 == &l_99 || l_87 == &g_39);
    }
    /* facts after branching */
    //assert (p_35 == &l_85 || p_35 == 0);
    //assert (l_87 == dangling || l_87 == &g_39);
    return g_40.f4;
    /* statement id: 75 */
    //assert (p_35 == dangling || p_35 == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_4, "g_4", print_hash_value);
    transparent_crc(g_31.f0, "g_31.f0", print_hash_value);
    transparent_crc_bytes (&g_31.f1, sizeof(g_31.f1), "g_31.f1", print_hash_value);
    transparent_crc(g_40.f0, "g_40.f0", print_hash_value);
    transparent_crc(g_40.f1, "g_40.f1", print_hash_value);
    transparent_crc(g_40.f2, "g_40.f2", print_hash_value);
    transparent_crc(g_40.f3, "g_40.f3", print_hash_value);
    transparent_crc(g_40.f4, "g_40.f4", print_hash_value);
    transparent_crc(g_40.f5, "g_40.f5", print_hash_value);
    transparent_crc(g_83.f0, "g_83.f0", print_hash_value);
    transparent_crc_bytes (&g_83.f1, sizeof(g_83.f1), "g_83.f1", print_hash_value);
    transparent_crc(g_93, "g_93", print_hash_value);
    transparent_crc(g_108, "g_108", print_hash_value);
    transparent_crc(g_118, "g_118", print_hash_value);
    transparent_crc_bytes (&g_120, sizeof(g_120), "g_120", print_hash_value);
    transparent_crc(g_172.f0, "g_172.f0", print_hash_value);
    transparent_crc_bytes (&g_172.f1, sizeof(g_172.f1), "g_172.f1", print_hash_value);
    transparent_crc(g_174.f0, "g_174.f0", print_hash_value);
    transparent_crc_bytes (&g_174.f1, sizeof(g_174.f1), "g_174.f1", print_hash_value);
    transparent_crc(g_210.f0, "g_210.f0", print_hash_value);
    transparent_crc(g_210.f1, "g_210.f1", print_hash_value);
    transparent_crc(g_210.f2, "g_210.f2", print_hash_value);
    transparent_crc(g_240.f0, "g_240.f0", print_hash_value);
    transparent_crc(g_240.f1, "g_240.f1", print_hash_value);
    transparent_crc(g_240.f2, "g_240.f2", print_hash_value);
    transparent_crc(g_244.f0, "g_244.f0", print_hash_value);
    transparent_crc_bytes (&g_244.f1, sizeof(g_244.f1), "g_244.f1", print_hash_value);
    transparent_crc(g_258.f0, "g_258.f0", print_hash_value);
    transparent_crc_bytes (&g_258.f1, sizeof(g_258.f1), "g_258.f1", print_hash_value);
    transparent_crc(g_302.f0, "g_302.f0", print_hash_value);
    transparent_crc_bytes (&g_302.f1, sizeof(g_302.f1), "g_302.f1", print_hash_value);
    transparent_crc(g_371.f0, "g_371.f0", print_hash_value);
    transparent_crc_bytes (&g_371.f1, sizeof(g_371.f1), "g_371.f1", print_hash_value);
    transparent_crc(g_373.f0, "g_373.f0", print_hash_value);
    transparent_crc(g_373.f1, "g_373.f1", print_hash_value);
    transparent_crc(g_373.f2, "g_373.f2", print_hash_value);
    transparent_crc(g_401.f0, "g_401.f0", print_hash_value);
    transparent_crc_bytes (&g_401.f1, sizeof(g_401.f1), "g_401.f1", print_hash_value);
    transparent_crc(g_455.f0, "g_455.f0", print_hash_value);
    transparent_crc_bytes (&g_455.f1, sizeof(g_455.f1), "g_455.f1", print_hash_value);
    transparent_crc(g_473.f0, "g_473.f0", print_hash_value);
    transparent_crc(g_473.f1, "g_473.f1", print_hash_value);
    transparent_crc(g_473.f2, "g_473.f2", print_hash_value);
    transparent_crc(g_474.f0, "g_474.f0", print_hash_value);
    transparent_crc(g_474.f1, "g_474.f1", print_hash_value);
    transparent_crc(g_474.f2, "g_474.f2", print_hash_value);
    transparent_crc(g_489, "g_489", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 126
   depth: 1, occurrence: 17
XXX total union variables: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 240
   depth: 2, occurrence: 30
   depth: 3, occurrence: 5
   depth: 4, occurrence: 7
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 5
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2

XXX total number of pointers: 151

XXX times a variable address is taken: 150
XXX times a pointer is dereferenced on RHS: 106
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 26
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 115
breakdown:
   depth: 1, occurrence: 96
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 462

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 440
   level: 2, occurrence: 139
   level: 3, occurrence: 18
   level: 4, occurrence: 3
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 72
XXX number of pointers point to scalars: 39
XXX number of pointers point to structs: 40
XXX percent of pointers has null in alias set: 22.5
XXX average alias set size: 1.3

XXX times a non-volatile is read: 609
XXX times a non-volatile is write: 282
XXX times a volatile is read: 26
XXX    times read thru a pointer: 9
XXX times a volatile is write: 17
XXX    times written thru a pointer: 9
XXX times a volatile is available for access: 107
XXX percentage of non-volatile access: 95.4

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 185
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 39
   depth: 2, occurrence: 25
   depth: 3, occurrence: 28
   depth: 4, occurrence: 22
   depth: 5, occurrence: 35

XXX percentage a fresh-made variable is used: 21.5
XXX percentage an existing variable is used: 78.5
********************* end of statistics **********************/

