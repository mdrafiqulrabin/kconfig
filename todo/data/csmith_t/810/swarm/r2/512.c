/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --longlong --int8 --uint8 --float --math64 --no-inline-function --muls --safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3816926544
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_29(void);
static const int32_t * func_30(uint16_t  p_31, float  p_32);
static const uint32_t  func_38(uint32_t  p_39, int32_t * const  p_40, int8_t  p_41, int32_t * p_42);
static int64_t  func_53(uint32_t  p_54, int32_t * p_55, const int32_t  p_56, int8_t  p_57, uint32_t  p_58);
static int32_t * func_59(uint64_t  p_60, int32_t  p_61, int32_t * p_62, int16_t  p_63, int32_t * p_64);
static int32_t  func_65(const int32_t * p_66, int32_t * p_67);
static int32_t * func_68(int32_t * p_69, int16_t  p_70);
static int32_t * func_71(int64_t  p_72, uint32_t  p_73);
static float  func_78(int32_t * p_79, uint16_t  p_80, int32_t  p_81, uint8_t  p_82, int32_t  p_83);
static uint16_t  func_85(int32_t * p_86);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_29(void)
{ /* block id: 36 */
    int16_t l_33 = 7L;
    int32_t l_35 = 0L;
    int32_t * const l_34 = &l_35;
    int32_t *l_253 = &l_35;
    int32_t **l_252 = &l_253;
    const int16_t l_267 = (-1L);
    int32_t l_268 = 0x61C7C29BL;
    (*l_252) = func_30(l_33, ((l_34 != (void*)0) , ((((*l_34) < __builtin_popcountll((safe_add_func_uint32_t_u_u(func_38((*l_34), &l_35, (1UL | __builtin_ctzll((((*l_34) == (((void*)0 == &l_35) || (*l_34))) && (*l_34)))), &l_35), (*l_34))))) >= 0x6.1p+1) <= (*l_34))));
    for (l_35 = 0; (l_35 != 15); l_35 = safe_add_func_int8_t_s_s(l_35, 3))
    { /* block id: 144 */
        int32_t l_257 = 0L;
        int32_t *l_256 = &l_257;
        (*l_256) = (*l_34);
        (*l_252) = (((safe_sub_func_uint64_t_u_u((safe_unary_minus_func_uint64_t_u(18446744073709551606UL)), (((*l_256) == ((0x2C40L > (&l_256 != &l_34)) > __builtin_parity((*l_34)))) != (safe_add_func_int32_t_s_s((((*l_256) || (((((safe_mul_func_float_f_f(((safe_mul_func_float_f_f(((*l_256) != 0x8.3p-1), l_267)) >= 0x1.Ep-1), (*l_256))) <= 0xD.9F3F7Cp+89) == (*l_256)) <= 0x2.A937B6p+98) , (*l_256))) >= (*l_256)), (*l_256)))))) != (-8L)) , (*l_252));
        l_256 = (*l_252);
    }
    return l_268;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_30(uint16_t  p_31, float  p_32)
{ /* block id: 138 */
    uint32_t l_244 = 18446744073709551615UL;
    float l_248 = 0xE.6A1A6Ap-52;
    float * const l_247 = &l_248;
    int32_t l_250 = (-1L);
    int32_t *l_249 = &l_250;
    const int32_t *l_251 = (void*)0;
    (*l_249) = func_38(((safe_mod_func_uint16_t_u_u(1UL, ((safe_add_func_float_f_f((safe_add_func_float_f_f(p_31, (safe_mul_func_float_f_f(0x1.3p+1, 0x6.EE9594p-60)))), (((l_244 ^ p_31) == ((l_247 != (void*)0) || ((p_31 , l_244) == (-7L)))) , 0x0.1p-1))) , (-1L)))) , 0x69FCEB6DL), l_247, l_244, l_249);
    return l_251;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_38(uint32_t  p_39, int32_t * const  p_40, int8_t  p_41, int32_t * p_42)
{ /* block id: 37 */
    int8_t l_52 = 0x7AL;
    int32_t l_175 = 1L;
    int32_t *l_174 = &l_175;
    int32_t ****l_234 = (void*)0;
    int32_t *****l_233 = &l_234;
    for (p_41 = 0; (p_41 < (-8)); p_41 = safe_sub_func_int16_t_s_s(p_41, 9))
    { /* block id: 40 */
        int32_t l_46 = 0xF6082F4EL;
        int32_t *l_45 = &l_46;
        const int32_t *l_231 = &l_175;
        int32_t **l_232 = &l_45;
        int32_t **l_235 = &l_174;
        if (((void*)0 != l_45))
        { /* block id: 41 */
            uint64_t l_49 = 6UL;
            int32_t *l_74 = &l_46;
            if ((*l_45))
                break;
            for (p_39 = 22; (p_39 > 22); p_39 = safe_add_func_uint8_t_u_u(p_39, 2))
            { /* block id: 45 */
                int32_t l_207 = 0x5C0E4766L;
                float l_223 = 0x4.08EFB3p+49;
                float *l_222 = &l_223;
                int32_t *l_224 = (void*)0;
                int32_t **l_227 = &l_45;
            }
        }
        else
        { /* block id: 126 */
            const uint8_t l_230 = 0x30L;
            for (l_46 = 0; (l_46 != (-14)); l_46 = safe_sub_func_int16_t_s_s(l_46, 1))
            { /* block id: 129 */
                return l_230;
            }
        }
        (*l_232) = l_231;
        l_233 = (p_39 , (void*)0);
        (*l_235) = p_40;
    }
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_53(uint32_t  p_54, int32_t * p_55, const int32_t  p_56, int8_t  p_57, uint32_t  p_58)
{ /* block id: 117 */
    int32_t l_209 = 0x946F77F4L;
    int32_t *l_208 = &l_209;
    int32_t **l_210 = (void*)0;
    int32_t **l_211 = &l_208;
    float l_219 = 0xC.3CF241p-17;
    float *l_218 = &l_219;
    int32_t ***l_221 = &l_211;
    int32_t ****l_220 = &l_221;
    (*l_211) = l_208;
    (*l_218) = (0x2.F519B7p+33 >= ((safe_mul_func_float_f_f((((**l_211) , (p_58 == (safe_sub_func_float_f_f(func_65((*l_211), (p_58 , func_68(((((((p_58 >= __builtin_popcountl((safe_add_func_int16_t_s_s(p_58, p_56)))) > p_58) , (**l_211)) , p_58) != (**l_211)) , p_55), (*l_208)))), 0x0.Fp-1)))) > 0x8.AD5EC5p+14), (**l_211))) <= (-0x5.3p+1)));
    (*l_220) = &l_211;
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads : l_35
 * writes:
 */
static int32_t * func_59(uint64_t  p_60, int32_t  p_61, int32_t * p_62, int16_t  p_63, int32_t * p_64)
{ /* block id: 102 */
    uint16_t l_177 = 65532UL;
    float l_187 = 0x0.6p+1;
    float *l_186 = &l_187;
    int32_t l_188 = 0xC62AA60DL;
    l_188 = ((((p_63 != ((l_177 || (safe_mul_func_int16_t_s_s(func_65(((safe_mul_func_uint16_t_u_u((safe_add_func_int64_t_s_s(((l_177 != ((l_177 >= (safe_rshift_func_uint16_t_u_s(l_177, ((l_186 != (void*)0) > func_85(l_186))))) || l_177)) > 0x7A3C92833B97862BLL), 1UL)), l_177)) , (void*)0), l_186), 0UL))) < 0x83E9L)) , (*p_64)) ^ l_177) >= 0x50L);
    if ((*p_62))
    { /* block id: 104 */
        uint32_t l_199 = 1UL;
        int32_t *l_202 = (void*)0;
        int32_t **l_201 = &l_202;
        int32_t ***l_200 = &l_201;
        (*l_186) = ((safe_sub_func_float_f_f(p_63, 0xB.E8BE2Ep+17)) < (safe_sub_func_float_f_f(l_188, (safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_add_func_float_f_f(((-0x1.Fp+1) >= (l_199 < l_199)), func_85(func_68(func_68(p_64, ((((((void*)0 == &l_186) <= l_188) != l_177) , l_200) != (void*)0)), l_177)))), 0x1.0p+1)), p_60)))));
        for (l_177 = 0; (l_177 == 27); l_177++)
        { /* block id: 108 */
            return p_64;
        }
        return p_62;
    }
    else
    { /* block id: 112 */
        int32_t *l_205 = &l_188;
        int32_t **l_206 = &l_205;
        l_188 = 0x9.975996p-63;
        (*l_206) = l_205;
        return p_62;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_65(const int32_t * p_66, int32_t * p_67)
{ /* block id: 100 */
    int8_t l_176 = 0xD1L;
    return l_176;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_68(int32_t * p_69, int16_t  p_70)
{ /* block id: 82 */
    int32_t l_158 = 0x0C1D3726L;
    int32_t *l_157 = &l_158;
    if ((l_157 != &l_158))
    { /* block id: 83 */
        int32_t **l_170 = &l_157;
        float l_172 = (-0x8.3p-1);
        float *l_171 = &l_172;
        for (p_70 = 0; (p_70 <= 27); p_70 = safe_add_func_int8_t_s_s(p_70, 1))
        { /* block id: 86 */
            int32_t *l_169 = &l_158;
            for (l_158 = 0; (l_158 == 1); l_158 = safe_add_func_int32_t_s_s(l_158, 9))
            { /* block id: 89 */
                int32_t **l_163 = &l_157;
                (*l_163) = (void*)0;
            }
            (*l_169) = ((((((-10L) == (safe_unary_minus_func_uint16_t_u((__builtin_clzll(p_70) , p_70)))) , ((safe_sub_func_uint8_t_u_u(((safe_sub_func_uint16_t_u_u(func_85(l_169), p_70)) >= (*l_169)), p_70)) ^ (*l_169))) > 3L) , (-1L)) != p_70);
        }
        (*l_170) = p_69;
        (*l_171) = 0x9.4419D3p-13;
    }
    else
    { /* block id: 96 */
        const int64_t l_173 = 0x807E85E602B377A3LL;
        (*l_157) = l_173;
    }
    return p_69;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_71(int64_t  p_72, uint32_t  p_73)
{ /* block id: 46 */
    const uint32_t l_75 = 0x7E3C2391L;
    int32_t l_95 = 6L;
    int32_t *l_94 = &l_95;
    uint64_t l_127 = 0x2E46A4E19C9FCC30LL;
    int32_t ** const l_129 = &l_94;
    int32_t ** const *l_128 = &l_129;
    int32_t *l_134 = &l_95;
    int32_t *l_141 = &l_95;
    int32_t *l_142 = &l_95;
    int32_t *l_143 = &l_95;
    int32_t *l_145 = &l_95;
    int32_t *l_146 = &l_95;
    int32_t *l_147 = &l_95;
    float *l_151 = (void*)0;
    float **l_150 = &l_151;
    float l_153 = (-0x1.4p+1);
    float *l_152 = &l_153;
    int32_t *l_154 = &l_95;
    int32_t *l_155 = &l_95;
    int32_t *l_156 = (void*)0;
    if (((__builtin_clzl(p_73) <= l_75) , 0x055833AEL))
    { /* block id: 47 */
        int32_t l_77 = 0x576105F6L;
        int32_t * const l_76 = &l_77;
        int32_t *l_84 = &l_77;
        float *l_132 = (void*)0;
        float **l_131 = &l_132;
        float ***l_130 = &l_131;
        if (((void*)0 != l_76))
        { /* block id: 48 */
            int32_t l_89 = 0x0E206F6EL;
            (*l_84) = ((func_78(l_84, func_85((((safe_rshift_func_uint8_t_u_u((l_89 || ((l_75 , (((((((safe_mod_func_int16_t_s_s((p_73 > p_72), ((((*l_76) <= 2UL) , (*l_84)) , (safe_lshift_func_uint16_t_u_u((((p_72 == 0x03AC4640L) , (void*)0) != &l_89), 6))))) , 0xCA2AE39BL) , p_72) , 7UL) ^ p_72) , p_73) || l_75)) , p_73)), (*l_84))) >= 0x8947L) , l_94)), l_89, p_72, (*l_94)) >= (*l_94)) > l_89);
            for (p_73 = 0; (p_73 == 30); p_73 = safe_add_func_uint64_t_u_u(p_73, 7))
            { /* block id: 64 */
                int8_t l_109 = 1L;
                float l_113 = 0x0.Dp+1;
                float *l_112 = &l_113;
                (*l_112) = (l_109 == func_78(&l_89, (p_72 > p_72), (!__builtin_clzll((*l_94))), ((l_109 >= ((6L & (+0xAC9F79E4B39C2D96LL)) == l_109)) , 0UL), l_89));
            }
        }
        else
        { /* block id: 67 */
            int32_t * const *l_115 = &l_84;
            int32_t * const **l_114 = &l_115;
            (**l_129) = ((l_114 == ((p_72 ^ (((~((((((*l_84) || ((((p_72 ^ ((((safe_mul_func_float_f_f((*l_84), (***l_114))) <= (safe_sub_func_float_f_f((safe_sub_func_float_f_f((((*l_84) == (safe_add_func_float_f_f(p_73, __builtin_ia32_crc32qi((safe_mod_func_int64_t_s_s(p_72, p_73)), (*l_84))))) > p_72), p_72)), (*l_94)))) , 0xEE7E4EBB7C4EAE4CLL) >= p_73)) , p_73) == p_72) <= (-5L))) & (***l_114)) , (*l_94)) | 0x1FF1C732L) <= l_127)) | (-1L)) || p_73)) , l_128)) ^ 0x9A6AL);
        }
        (*l_130) = (void*)0;
    }
    else
    { /* block id: 71 */
        int32_t *l_133 = &l_95;
        int32_t *l_135 = &l_95;
        int32_t *l_136 = (void*)0;
        return l_136;
    }
    for (l_127 = 0; (l_127 != 35); ++l_127)
    { /* block id: 76 */
        int32_t *l_139 = &l_95;
        int32_t *l_140 = &l_95;
        int32_t *l_144 = &l_95;
        int32_t *l_148 = &l_95;
        int32_t *l_149 = (void*)0;
        return l_149;
    }
    l_150 = l_150;
    (*l_152) = 0x1.4p-1;
    return l_156;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_78(int32_t * p_79, uint16_t  p_80, int32_t  p_81, uint8_t  p_82, int32_t  p_83)
{ /* block id: 57 */
    int32_t l_106 = 0L;
    int32_t *l_105 = &l_106;
    int32_t **l_104 = &l_105;
    (*l_104) = (void*)0;
    (*p_79) = 0x909801C1L;
    return p_81;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_85(int32_t * p_86)
{ /* block id: 49 */
    int32_t l_96 = 0x7D07A125L;
    int32_t l_100 = 0xD03168F1L;
    int32_t *l_99 = &l_100;
    int32_t **l_102 = (void*)0;
    int32_t ***l_101 = &l_102;
    int32_t l_103 = 0x9D02BD44L;
    for (l_96 = (-8); (l_96 > 3); l_96++)
    { /* block id: 52 */
        l_99 = &l_96;
    }
    (*l_101) = &p_86;
    return l_103;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 68
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 14
   depth: 4, occurrence: 1
   depth: 13, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 76

XXX times a variable address is taken: 74
XXX times a pointer is dereferenced on RHS: 52
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 4
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 27
breakdown:
   depth: 1, occurrence: 26
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 287

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 101
   level: 2, occurrence: 13
   level: 3, occurrence: 3
XXX number of pointers point to pointers: 25
XXX number of pointers point to scalars: 51
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25
XXX average alias set size: 1.25

XXX times a non-volatile is read: 295
XXX times a non-volatile is write: 71
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 61
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 22
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3

XXX percentage a fresh-made variable is used: 11.7
XXX percentage an existing variable is used: 88.3
********************* end of statistics **********************/

