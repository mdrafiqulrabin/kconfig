/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      3915242126
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint32_t  f1;
   int16_t  f2;
   uint32_t  f3;
   int32_t  f4;
   int32_t  f5;
   uint32_t  f6;
   int32_t  f7;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_32(void);
static uint32_t  func_39(int32_t  p_40);
static struct S0  func_59(int16_t  p_60, int16_t  p_61);
static int16_t  func_63(int16_t  p_64, uint16_t  p_65, struct S0  p_66, const int32_t  p_67);
static int32_t  func_88(uint32_t  p_89, uint32_t  p_90);
static int16_t  func_93(int32_t  p_94, int32_t  p_95, int32_t  p_96, int32_t  p_97);
static struct S0  func_98(int16_t  p_99, uint32_t  p_100, int32_t  p_101);
static struct S0  func_103(int16_t  p_104, int16_t  p_105, uint32_t  p_106, uint16_t  p_107);
static uint32_t  func_108(int32_t  p_109);
static int16_t  func_117(uint32_t  p_118, int32_t  p_119, const int32_t  p_120, int16_t  p_121);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(void)
{ /* block id: 36 */
    int16_t l_33 = 0x2034L;
    int32_t l_49 = 0x944DCD6AL;
    int32_t l_50 = 0xE46552DEL;
    int32_t l_381 = 0x436942E8L;
    struct S0 l_383 = {6L,0x9D94C1EBL,0x15FAL,9UL,-1L,0L,5UL,1L};
    if (l_33)
    { /* block id: 37 */
        int32_t l_34 = 0x7A329EF4L;
        return l_34;
    }
    else
    { /* block id: 39 */
        uint32_t l_47 = 0x920B2455L;
        int32_t l_48 = 0x16309070L;
        uint32_t l_57 = 3UL;
        int32_t l_382 = (-1L);
        l_382 = ((((int32_t)(l_381 = ((uint32_t)func_39(__builtin_bswap32(((int16_t)((0L || ((l_50 = ((int16_t)((int32_t)(l_33 , l_47) - (int32_t)(l_48 == 0x294BL)) / (int16_t)(l_49 = l_47))) == ((int32_t)(((int32_t)__builtin_parity(l_33) % (int32_t)((int16_t)l_47 / (int16_t)0x55D4L)) | 0x6422L) % (int32_t)l_33))) > l_57) >> (int16_t)12))) / (uint32_t)l_57)) - (int32_t)l_48) == 65535UL) ^ l_33);
        l_383 = l_383;
        return l_57;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_39(int32_t  p_40)
{ /* block id: 42 */
    uint32_t l_58 = 4294967288UL;
    int32_t l_81 = 0xE71C9EEBL;
    int32_t l_359 = 9L;
    int32_t l_360 = 0x9862D915L;
    int32_t l_363 = 0xE3E1FD3EL;
    struct S0 l_368 = {5L,0xD0330E28L,0xF59EL,0xE923B787L,-1L,0x534E593EL,18446744073709551608UL,8L};
    int32_t l_377 = 1L;
    int32_t l_378 = (-1L);
    int32_t l_379 = 1L;
    int32_t l_380 = (-7L);
    if (l_58)
    { /* block id: 43 */
        int16_t l_62 = 1L;
        uint16_t l_72 = 0x8383L;
        int32_t l_82 = 0x0BF04B2BL;
        struct S0 l_83 = {-6L,1UL,-1L,0x576189EFL,0x4ED9E626L,-6L,18446744073709551615UL,0xE2B40743L};
        l_83 = func_59(l_62, func_63(p_40, (l_82 = (l_81 = ((int16_t)(0x08F497C3L != (l_58 < (l_62 & l_62))) - (int16_t)((uint16_t)l_72 * (uint16_t)((uint16_t)(((uint16_t)65535UL - (uint16_t)((int16_t)((int16_t)p_40 + (int16_t)1UL) * (int16_t)p_40)) < l_62) / (uint16_t)l_72))))), l_83, p_40));
    }
    else
    { /* block id: 177 */
        uint32_t l_345 = 0x0CEF86DEL;
        int32_t l_350 = 0xD807AB2BL;
        int32_t l_352 = 0x76BE43E4L;
        l_81 = ((uint16_t)((((uint16_t)p_40 * (uint16_t)(l_345 = 0xBE68L)) & 0L) ^ ((int16_t)0xD246L << (int16_t)10)) + (uint16_t)(l_352 = ((p_40 | ((int32_t)((-1L) == l_81) + (int32_t)(((l_350 = p_40) >= ((__builtin_parityll((-(uint16_t)0x0D9CL)) >= l_58) & 4L)) < p_40))) ^ p_40)));
        l_352 = l_345;
        l_352 = ((-7L) || (p_40 & ((l_350 ^ l_58) & l_352)));
        for (l_352 = 0; (l_352 <= 22); l_352++)
        { /* block id: 186 */
            l_350 = ((((int16_t)l_81 << (int16_t)__builtin_popcountll((l_360 = ((uint16_t)(l_359 = p_40) << (uint16_t)5)))) & (p_40 , l_58)) != l_81);
        }
    }
    l_359 = (0x17E63882L == p_40);
    l_380 = ((int32_t)(l_379 = (((l_359 = l_363) <= ((int32_t)((uint16_t)(((((p_40 , (l_81 = p_40)) == ((l_360 = func_108(l_363)) && ((((l_368 = l_368) , (l_360 = l_368.f7)) & ((((uint32_t)(((int16_t)(l_363 & ((uint16_t)(l_378 = ((l_377 = ((uint16_t)p_40 - (uint16_t)l_58)) <= l_363)) >> (uint16_t)l_363)) >> (int16_t)l_58) & 0x8C04L) - (uint32_t)p_40) != l_58) , p_40)) , 0x1313D4E5L))) & 0x0461L) >= p_40) & l_58) * (uint16_t)0x0C0EL) + (int32_t)p_40)) ^ p_40)) % (int32_t)p_40);
    return l_360;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_59(int16_t  p_60, int16_t  p_61)
{ /* block id: 55 */
    int32_t l_102 = 0x11FE8BE9L;
    struct S0 l_122 = {6L,0x61C1CA36L,6L,0UL,-1L,0xAEE99EADL,0x92BF48DFL,9L};
    int32_t l_123 = 0xAF9C35C0L;
    int32_t l_127 = (-6L);
    int32_t l_140 = 0x58485844L;
    int32_t l_152 = 0x28C81A46L;
    uint32_t l_337 = 1UL;
    l_102 = func_88(p_61, ((__builtin_ffsl(((int16_t)func_93((func_98(l_102, p_60, (l_152 = ((func_103((l_140 = (l_102 == func_108((((int16_t)(-(uint16_t)p_60) / (int16_t)((int16_t)((int16_t)(l_127 = func_117(func_63(l_102, (0xD7C0820FL & l_102), l_122, p_61), l_123, l_122.f6, p_60)) / (int16_t)l_122.f5) - (int16_t)l_122.f7)) ^ l_122.f2)))), l_122.f2, l_122.f0, p_60) , p_61) ^ l_122.f2))) , 0x4315AF73L), p_61, p_61, l_122.f3) % (int16_t)(-3L))) != 0UL) ^ 0xFFB4L));
    if (((l_122.f7 >= (((int32_t)(l_102 = l_122.f2) / (int32_t)l_122.f6) <= (p_60 < ((int16_t)((int16_t)func_88(l_337, l_122.f2) << (int16_t)1) * (int16_t)__builtin_ctz((((p_61 >= 0x6BFFL) | p_61) || 0x1DDFA2F9L)))))) >= p_61))
    { /* block id: 169 */
        uint32_t l_338 = 0UL;
        l_140 = (l_122.f7 == ((l_338 != 0x811BL) || (4L < (65535UL > p_60))));
    }
    else
    { /* block id: 171 */
        l_102 = l_102;
        return l_122;
    }
    return l_122;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_63(int16_t  p_64, uint16_t  p_65, struct S0  p_66, const int32_t  p_67)
{ /* block id: 46 */
    uint16_t l_86 = 2UL;
    int32_t l_87 = 0x3A0C94A7L;
    for (p_66.f0 = 0; (p_66.f0 == (-20)); p_66.f0 -= 9)
    { /* block id: 49 */
        l_87 = __builtin_clzl(l_86);
        if (p_66.f6)
            break;
    }
    l_87 = l_86;
    return p_66.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_88(uint32_t  p_89, uint32_t  p_90)
{ /* block id: 164 */
    struct S0 l_328 = {0x7E5AL,0x778CE083L,1L,0x07AB9D66L,0xD8659369L,0x4168314AL,0UL,0x8A70B46EL};
    l_328 = l_328;
    return p_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_93(int32_t  p_94, int32_t  p_95, int32_t  p_96, int32_t  p_97)
{ /* block id: 150 */
    uint32_t l_304 = 0xA9D8E908L;
    int32_t l_305 = (-1L);
    struct S0 l_309 = {0xA243L,4294967295UL,8L,0xD450B8E1L,0x9C8D91A4L,0x2D8EFB94L,0x29A290CDL,-2L};
    int32_t l_310 = (-8L);
    int32_t l_311 = 8L;
    struct S0 l_312 = {0x327FL,4294967294UL,0x4EDFL,4UL,0x08364240L,0L,0xDEBC78CBL,-10L};
    int32_t l_324 = 0x2FD9BEF9L;
    int32_t l_325 = (-5L);
    int32_t l_326 = 0x8453F7F7L;
    uint32_t l_327 = 0x8CBDFFCEL;
    p_96 = (0x8EA20BC5L || ((uint32_t)p_97 - (uint32_t)((int16_t)__builtin_ctzll((((int32_t)__builtin_clzl((l_305 = l_304)) / (int32_t)__builtin_ia32_crc32qi(l_304, ((!l_304) , (((l_310 = ((int16_t)0x8210L >> (int16_t)((((func_63(p_96, p_96, l_309, l_309.f7) <= 0x471C5D8BL) ^ p_97) || l_309.f0) == l_309.f4))) , 4294967288UL) < l_311)))) , l_309.f3)) << (int16_t)6)));
    l_312 = l_312;
    l_309 = func_98(((l_326 = ((l_310 = (l_311 = (0x8FCEAAE3L & (l_312 , l_309.f7)))) & ((uint32_t)(((0xEFC1L & l_309.f0) <= 0xAC1FL) , ((uint16_t)((int16_t)l_312.f3 >> (int16_t)4) * (uint16_t)(l_309.f6 , ((int16_t)(+((int32_t)((l_325 = (p_96 = ((l_324 = (l_305 = l_312.f7)) , l_304))) | l_309.f1) - (int32_t)p_94)) * (int16_t)l_312.f2)))) + (uint32_t)p_94))) , l_327), l_312.f3, l_309.f3);
    return l_312.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_98(int16_t  p_99, uint32_t  p_100, int32_t  p_101)
{ /* block id: 79 */
    int16_t l_153 = 0x2E87L;
    int32_t l_158 = 7L;
    int32_t l_159 = 0x9D9FE8ACL;
    int32_t l_190 = (-1L);
    struct S0 l_268 = {1L,4UL,-1L,0xA865AC17L,-5L,0x86C627A4L,18446744073709551615UL,0xF9C3CA28L};
    int32_t l_295 = 1L;
    l_153 = 0x4AA1647FL;
    if ((((l_153 ^ 4294967295UL) & l_153) && (((p_100 | (l_159 = ((((uint16_t)p_101 + (uint16_t)p_99) >= p_101) != ((uint16_t)(((p_100 , (l_158 = __builtin_parityll((p_101 | p_99)))) > 1UL) != p_100) * (uint16_t)0x801AL)))) <= 0x9EEEL) | l_153)))
    { /* block id: 83 */
        int32_t l_181 = 0x61DA5A7FL;
        int32_t l_185 = (-10L);
        uint32_t l_202 = 2UL;
        struct S0 l_258 = {-1L,0x4BC92DBEL,-10L,1UL,0x0DD5D192L,1L,0UL,0x2D425E7FL};
        int32_t l_269 = 1L;
        int32_t l_270 = (-2L);
        for (l_153 = 0; (l_153 >= (-25)); l_153 -= 4)
        { /* block id: 86 */
            int32_t l_178 = 0L;
            int32_t l_206 = 0L;
            for (p_101 = (-9); (p_101 < (-6)); p_101++)
            { /* block id: 89 */
                int32_t l_183 = 0x87A080E1L;
                int32_t l_207 = 0x2139280DL;
                if ((((uint16_t)p_100 / (uint16_t)p_100) ^ (p_99 = l_158)))
                { /* block id: 91 */
                    uint32_t l_182 = 4294967290UL;
                    uint16_t l_184 = 0xEDC9L;
                    l_185 = ((uint16_t)(p_101 , ((uint16_t)((uint16_t)((((uint16_t)((p_100 >= (((int32_t)((uint32_t)__builtin_popcountll(l_178) + (uint32_t)(((int16_t)l_181 << (int16_t)2) || (l_183 = __builtin_clzl(l_182)))) % (int32_t)p_99) , (((func_108(l_178) <= 0L) , l_182) | 0xF534L))) ^ p_101) + (uint16_t)l_182) == 1L) & l_184) / (uint16_t)l_178) >> (uint16_t)2)) >> (uint16_t)5);
                    if (l_182)
                        continue;
                }
                else
                { /* block id: 95 */
                    uint32_t l_203 = 0x332A2132L;
                    l_159 = ((((uint32_t)p_100 + (uint32_t)(((uint32_t)l_190 - (uint32_t)((+((int16_t)p_100 >> (int16_t)((l_207 = (((uint32_t)((int16_t)((uint32_t)((uint16_t)l_202 * (uint16_t)l_203) / (uint32_t)((int16_t)(p_99 != __builtin_clzll((l_159 , (l_206 = ((__builtin_ctzl(l_203) , l_158) <= p_101))))) + (int16_t)1L)) / (int16_t)l_178) / (uint32_t)0xF7DCBD80L) & (-1L))) & p_101))) | l_185)) || p_101)) | p_99) , 0x833108A3L);
                }
                l_158 = ((p_100 && (l_159 = p_100)) , l_202);
                for (l_178 = 0; (l_178 >= (-25)); l_178 -= 8)
                { /* block id: 104 */
                    const uint16_t l_218 = 0UL;
                    int32_t l_230 = 0x41899611L;
                    int32_t l_231 = 0x2CC8EED5L;
                    l_185 = (((uint32_t)((((p_99 = ((l_158 = (l_231 = ((int32_t)(((int16_t)((int32_t)0xFA35CBEAL % (int32_t)l_218) + (int16_t)(-1L)) , (0L >= (9UL < (l_230 = ((int16_t)((uint32_t)(!((l_207 = ((uint32_t)l_159 / (uint32_t)(l_190 | ((int16_t)((((uint32_t)((p_101 || (p_100 , p_100)) , p_99) % (uint32_t)l_178) && p_99) == 65533UL) << (int16_t)p_101)))) | l_183)) % (uint32_t)p_99) + (int16_t)l_202))))) + (int32_t)p_101))) ^ (-2L))) , 0x0449L) & 65530UL) == 0x16FBCE5CL) + (uint32_t)4294967295UL) , 0xBCE40628L);
                    l_206 = __builtin_ffsll((l_185 = ((int16_t)((p_101 | 65535UL) <= (65535UL ^ ((4L >= p_99) > ((((int32_t)(((int16_t)l_183 << (int16_t)p_101) || l_230) + (int32_t)__builtin_clzl((((int16_t)((int16_t)p_101 % (int16_t)p_101) + (int16_t)p_99) >= p_100))) , l_181) < l_218)))) * (int16_t)p_99)));
                }
            }
            l_185 = p_100;
            for (l_206 = (-30); (l_206 == (-18)); l_206++)
            { /* block id: 118 */
                int16_t l_253 = 0x4455L;
                int32_t l_254 = 6L;
                int32_t l_255 = 0x41942EB4L;
                int32_t l_257 = 0x144F9DCCL;
                struct S0 l_259 = {0x0133L,0x60276B29L,-1L,4294967295UL,0x34544C11L,0L,0xFCA105D9L,0xA13DB782L};
                for (l_185 = 28; (l_185 == (-26)); l_185 -= 1)
                { /* block id: 121 */
                    int32_t l_250 = 0xDB2E776EL;
                    int32_t l_256 = 0x7E34FB19L;
                    l_259 = ((((uint16_t)((((uint16_t)func_108((l_159 = l_250)) * (uint16_t)(((int16_t)(func_117(l_253, (l_255 = ((l_254 = p_100) , 5L)), (l_256 = func_117(func_117(p_100, l_158, __builtin_popcount(p_99), l_250), l_190, l_253, p_100)), p_100) , l_257) % (int16_t)4L) , 0x7658L)) < l_250) , 0xF477L) << (uint16_t)p_100) & 1UL) , l_258);
                }
                l_185 = p_99;
            }
        }
        l_268 = ((l_159 = ((int16_t)(((uint16_t)l_202 >> (uint16_t)((int16_t)__builtin_ctzll(l_159) << (int16_t)((func_108(((int16_t)(l_269 = (l_185 = (l_268 , p_100))) << (int16_t)((l_270 = (-2L)) != p_100))) || __builtin_parityll(((uint16_t)p_99 % (uint16_t)0x4FD5L))) , 0xDBC6L))) <= l_153) + (int16_t)p_100)) , l_258);
    }
    else
    { /* block id: 136 */
        int32_t l_273 = 0x6A8D8B00L;
        int32_t l_284 = 0L;
        int32_t l_293 = 9L;
        int32_t l_294 = (-5L);
        int32_t l_296 = (-2L);
        struct S0 l_297 = {0L,0xF5635189L,1L,0xA39C704BL,0L,0L,6UL,5L};
        l_294 = ((((l_158 = (l_268.f7 < __builtin_parity((l_273 = l_268.f6)))) <= (0UL || ((uint16_t)(((uint32_t)((uint16_t)(((p_99 = ((uint16_t)(l_284 = ((uint16_t)(l_159 = p_99) >> (uint16_t)2)) * (uint16_t)((uint32_t)((uint16_t)(2UL && ((l_293 = (l_296 = ((int16_t)((int16_t)p_101 << (int16_t)func_108((l_295 = (l_293 | ((((l_293 , l_268.f7) , l_268.f3) , l_293) || l_294))))) + (int16_t)p_101))) > p_99)) * (uint16_t)0L) / (uint32_t)l_268.f0))) && l_159) & 0xD65AL) - (uint16_t)7UL) - (uint32_t)p_100) , l_268.f0) << (uint16_t)1))) <= l_294) != p_100);
        return l_297;
    }
    l_268 = l_268;
    return l_268;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_103(int16_t  p_104, int16_t  p_105, uint32_t  p_106, uint16_t  p_107)
{ /* block id: 73 */
    uint32_t l_142 = 4294967295UL;
    int32_t l_149 = 0x67568466L;
    int32_t l_150 = 0L;
    struct S0 l_151 = {9L,0xAC954279L,0L,0UL,-2L,-1L,0UL,-10L};
    l_150 = (l_149 = ((p_107 = ((!(l_142 <= ((p_107 <= ((((int16_t)(-2L) << (int16_t)((((int32_t)l_142 - (int32_t)p_107) , l_142) & ((uint16_t)((p_106 | func_117(p_105, p_106, p_107, l_142)) , 0x8570L) % (uint16_t)l_142))) != 0x2021A1DBL) && 4294967288UL)) <= l_142))) , 0xFA51L)) > p_106));
    return l_151;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_108(int32_t  p_109)
{ /* block id: 65 */
    int32_t l_128 = (-1L);
    int32_t l_135 = 0x310EE7DBL;
    struct S0 l_136 = {0xA6A3L,0x9BDABD65L,0x6C33L,0x96C8B9E1L,0L,0xB9DDBBE0L,0xB323EC08L,0x7FF2A757L};
    int32_t l_137 = 2L;
    int32_t l_138 = (-6L);
    int32_t l_139 = 0x502624D5L;
    l_128 = (l_128 | (func_117(((l_138 = (l_137 = (p_109 != func_117(p_109, ((((l_135 = ((int16_t)((uint16_t)((uint32_t)0xDE0B6AD7L / (uint32_t)p_109) << (uint16_t)p_109) << (int16_t)0)) , l_135) != 1L) ^ func_63((l_136 , 4L), l_136.f4, l_136, p_109)), l_136.f5, l_136.f3)))) ^ p_109), l_136.f5, l_136.f1, l_136.f7) & 0x873BCDA4L));
    l_136 = l_136;
    return l_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_117(uint32_t  p_118, int32_t  p_119, const int32_t  p_120, int16_t  p_121)
{ /* block id: 56 */
    int32_t l_126 = 1L;
    for (p_119 = (-4); (p_119 == (-4)); p_119 += 4)
    { /* block id: 59 */
        return p_118;
    }
    l_126 = p_119;
    return l_126;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 93
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 64
   depth: 2, occurrence: 10
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 15, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 319
XXX times a non-volatile is write: 107
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 63
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 19
   depth: 2, occurrence: 4
   depth: 3, occurrence: 5
   depth: 4, occurrence: 6

XXX percentage a fresh-made variable is used: 24.9
XXX percentage an existing variable is used: 75.1
********************* end of statistics **********************/

