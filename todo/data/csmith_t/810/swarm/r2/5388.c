/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      474137434
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint16_t g_2 = 0xC692;
static float g_5 = 0x6.5p-1;
static int32_t g_17 = 5;
static int16_t g_34 = 6;
static volatile int32_t g_97 = 5;/* VOLATILE GLOBAL g_97 */
static volatile int32_t *g_96 = &g_97;
static volatile int32_t **g_95 = &g_96;
static volatile float g_105 = 0x4.Ap+1;/* VOLATILE GLOBAL g_105 */
static volatile float *g_104 = &g_105;
static volatile float **g_103 = &g_104;
static int32_t g_123 = 0x81A7339E;
static float **g_125 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static float  func_1(void);
static int8_t  func_9(float * p_10);
inline static float * func_11(float * p_12);
inline static int32_t * func_18(uint32_t  p_19, uint32_t  p_20, int32_t  p_21);
inline static int8_t  func_22(int16_t  p_23, int32_t ** p_24, int32_t ** p_25);
inline static int8_t  func_28(int32_t ** p_29, float * p_30, uint32_t  p_31, int32_t * p_32, int32_t * p_33);
inline static float ** func_39(float * p_40, uint8_t  p_41, float ** p_42, uint32_t  p_43, uint8_t  p_44);
static float * func_45(int32_t  p_46, int32_t  p_47, float * p_48);
static int16_t  func_52(int32_t  p_53, float  p_54);
inline static int32_t  func_55(int32_t  p_56, float * p_57, int32_t  p_58, int16_t  p_59, uint32_t  p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_17 g_34 g_5 g_95 g_96 g_97 g_103 g_125 g_123 g_104 g_105
 * writes: g_5 g_97 g_96 g_123 g_105 g_34 g_17
 */
static float  func_1(void)
{ /* block id: 0 */
    float *l_3 = (void*)0;
    float *l_4 = &g_5;
    int32_t l_6 = 0xEBB6748F;
    (*l_4) = g_2;
    if (l_6)
    { /* block id: 2 */
        float *l_13 = &g_5;
        int32_t *l_231 = &l_6;
        float ***l_233 = (void*)0;
        float ****l_232 = &l_233;
        (*l_231) = ((int8_t)l_6 % (int8_t)func_9(func_11(l_13)));
        /* statement id: 77 */
        assert (g_96 == 0 || g_96 == &g_97);
        (*l_232) = &g_125;
        /* statement id: 78 */
        assert (l_233 == &g_125);
        (**g_103) = (*l_231);
    }
    else
    { /* block id: 80 */
        volatile uint32_t l_234 = 0x9745CED4;/* VOLATILE GLOBAL l_234 */
        if ((**g_95))
        { /* block id: 81 */
            int32_t *l_236 = &g_17;
            int32_t **l_235 = &l_236;
            (*g_96) = (**g_95);
            (*g_95) = (void*)0;
            /* statement id: 83 */
            assert (g_96 == 0);
            l_234 = (*g_104);
            (**l_235) = (l_235 == (void*)0);
        }
        else
        { /* block id: 86 */
            (*g_95) = (*g_95);
            for (g_34 = 0; (g_34 <= (-22)); g_34 -= 6)
            { /* block id: 90 */
                int32_t *l_241 = &g_17;
                int32_t **l_240 = &l_241;
                int32_t ***l_239 = &l_240;
                int32_t ****l_242 = (void*)0;
                int32_t ****l_243 = &l_239;
                (*l_243) = l_239;
            }
        }
        /* facts after branching */
        assert (g_96 == &g_97 || g_96 == 0);
    }
    /* facts after branching */
    assert (g_96 == 0 || g_96 == &g_97);
    return (*g_104);
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_17
 * writes:
 */
static int8_t  func_9(float * p_10)
{ /* block id: 74 */
    float l_219 = 0x0.6p-1;
    int32_t l_220 = (-3);
    float *l_224 = &l_219;
    float **l_223 = &l_224;
    int32_t *l_228 = (void*)0;
    int32_t **l_227 = &l_228;
    l_220 = (l_220 > ((((l_220 >= ((uint32_t)((void*)0 != l_223) - (uint32_t)((((uint32_t)(l_227 == &l_228) - (uint32_t)g_34) ^ ((int8_t)((&g_104 == &g_104) ^ g_17) / (int8_t)1)) && 255U))) == 0x5E) <= l_220) < 0xDC));
    return g_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_17 g_34 g_5 g_95 g_96 g_97 g_103 g_125 g_123 g_104 g_105
 * writes: g_5 g_97 g_96 g_123 g_105 g_34
 */
inline static float * func_11(float * p_12)
{ /* block id: 3 */
    int16_t l_14 = 9;
    int32_t *l_16 = &g_17;
    int32_t **l_15 = &l_16;
    int32_t **l_199 = &l_16;
    (*p_12) = l_14;
    (*l_15) = (void*)0;
    /* statement id: 5 */
    assert (l_16 == 0);
    (*l_199) = func_18(((g_2 & (func_22(((uint32_t)(g_17 >= ((func_28(&l_16, l_16, g_34, &g_17, &g_17) < 0x21) | 0x6C)) - (uint32_t)5U), l_199, &l_16) < 255U)) <= g_17), g_2, g_2);
    /* statement id: 72 */
    assert (l_16 == &g_123);
    assert (g_96 == 0 || g_96 == &g_97);
    return p_12;
    /* statement id: 73 */
    //assert (func_11_rv == &g_5);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_18(uint32_t  p_19, uint32_t  p_20, int32_t  p_21)
{ /* block id: 70 */
    return &g_123;
    /* statement id: 71 */
    //assert (func_18_rv == &g_123);
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_97 g_123 g_2 g_17
 * writes: g_34 g_123
 */
inline static int8_t  func_22(int16_t  p_23, int32_t ** p_24, int32_t ** p_25)
{ /* block id: 63 */
    int8_t l_206 = 0;
    for (g_34 = 0; (g_34 >= (-9)); g_34--)
    { /* block id: 66 */
        int32_t l_217 = 0x682B91D3;
        float *l_218 = &g_5;
        (*p_25) = func_45(((int16_t)((uint16_t)l_206 % (uint16_t)g_97) + (int16_t)((uint16_t)(((uint32_t)(((((((void*)0 == &g_104) | g_34) ^ ((int32_t)((int32_t)(&g_103 != (void*)0) % (int32_t)(g_123 & (1U != 0xC1))) % (int32_t)l_217)) < p_23) >= g_123) & p_23) + (uint32_t)l_206) && l_217) >> (uint16_t)3)), l_206, l_218);
        /* statement id: 67 */
        //assert (l_16 == &g_123);
    }
    /* facts after for loop */
    //assert (l_16 == &g_123 || l_16 == 0);
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_2 g_17 g_5 g_95 g_96 g_97 g_103 g_125 g_123 g_104 g_105
 * writes: g_5 g_97 g_96 g_123 g_105
 */
inline static int8_t  func_28(int32_t ** p_29, float * p_30, uint32_t  p_31, int32_t * p_32, int32_t * p_33)
{ /* block id: 6 */
    int32_t l_37 = 0x1516EA3D;
    float *l_110 = (void*)0;
    if (((int8_t)g_34 - (int8_t)l_37))
    { /* block id: 7 */
        uint32_t l_38 = 0U;
        return l_38;
    }
    else
    { /* block id: 9 */
        float *l_51 = (void*)0;
        float **l_50 = &l_51;
        int8_t l_61 = 0xE8;
        int16_t l_124 = (-1);
        float ***l_198 = &l_50;
        (*l_198) = func_39(func_45((-(uint32_t)((l_50 != (void*)0) || func_52((func_55((l_61 == (!((!((uint8_t)0U >> (uint8_t)0)) >= (l_61 && (l_51 == (void*)0))))), (*l_50), (!((void*)0 != &g_17)), p_31, g_2) && p_31), g_2))), g_2, l_110), l_124, g_125, g_17, l_61);
        /* statement id: 60 */
        assert (l_50 == 0);
        assert (g_96 == 0 || g_96 == &g_97);
    }
    /* facts after branching */
    assert (g_96 == 0 || g_96 == &g_97);
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_95 g_96 g_17 g_123 g_103 g_104 g_105 g_5 g_34 g_2 g_125
 * writes: g_105 g_123 g_5
 */
inline static float ** func_39(float * p_40, uint8_t  p_41, float ** p_42, uint32_t  p_43, uint8_t  p_44)
{ /* block id: 49 */
    int16_t l_133 = 0x7AA0;
    int32_t *l_179 = (void*)0;
    float *l_194 = &g_5;
    float **l_193 = &l_194;
    int32_t **l_196 = &l_179;
    float **l_197 = &l_194;
    if (((uint32_t)(((void*)0 == (*g_95)) & g_17) % (uint32_t)((((int8_t)((~((uint32_t)(0xC50B || (&g_96 != (void*)0)) / (uint32_t)0xC8015B33)) == l_133) >> (int8_t)7) < ((uint32_t)8U + (uint32_t)7)) ^ l_133)))
    { /* block id: 50 */
        int32_t l_146 = (-1);
        uint32_t l_164 = 0x34670EA8;
        (*g_104) = (((&g_104 != &p_40) != ((float)(((float)(*p_40) + (float)((**g_103) < 0x0.Cp+1)) < (((0xA.40BD20p+57 > (-0x1.Ep+1)) != ((float)((((float)(((((float)l_133 / (float)(p_40 == (*g_95))) < g_17) < l_133) != l_146) - (float)(*p_40)) > (-0x1.9p+1)) > g_5) / (float)(-0x2.7p+1))) < 0x4.28E4EAp-80)) / (float)(*p_40))) <= (*p_40));
        (*p_40) = ((((((void*)0 == &g_96) > ((float)((**g_103) == ((float)((float)(((((float)0x0.Dp+1 / (float)((((-(float)(((float)((((float)l_146 / (float)((((float)(((((void*)0 != &p_40) == 0xF.7E885Cp+30) > ((float)(*p_40) / (float)l_133)) > (*p_40)) + (float)l_164) >= g_34) == l_146)) != l_133) != (*p_40)) + (float)g_34) < 0x7.2p-1)) < 0x8.FACB5Cp-67) > l_133) < l_133)) < 0x0.2p-1) != (-0x4.8p-1)) < 0xD.67006Bp+38) / (float)g_34) - (float)g_123)) + (float)0xF.83140Ap+44)) <= g_17) < g_17) >= (*p_40));
    }
    else
    { /* block id: 53 */
        int32_t l_182 = 1;
        int32_t **l_195 = &l_179;
        (**g_103) = ((float)0xE.7EA6E2p-63 + (float)((-(float)0x0.3p+1) != ((float)(*g_104) / (float)((((float)((float)((((float)(((((float)(((-(float)((p_40 != l_179) >= ((float)((l_182 > g_2) <= ((float)0x0.4p+1 + (float)(*p_40))) - (float)0xA.FE3867p-74))) > (-0x1.7p+1)) < g_5) - (float)0x1.2p-1) == 0x6.7814A7p+23) != 0x5.F9DC64p-43) > (*p_40)) / (float)(*p_40)) > 0x5.B13CA6p-23) < g_5) / (float)(*p_40)) / (float)g_5) != (*p_40)) == (*p_40)))));
        (*l_194) = ((float)((float)0x4.3p+1 + (float)((float)(0xC.5938EEp-77 == ((*g_104) == 0x4.Cp+1)) - (float)((float)((((&p_40 == l_193) <= ((l_195 == &g_96) != ((l_182 > g_123) != g_2))) != (*p_40)) >= (*p_40)) / (float)0x8.05DE68p+12))) / (float)(*p_40));
    }
    (*g_104) = ((((*p_40) >= (*p_40)) != (*p_40)) == (&g_96 != &g_96));
    (*l_196) = p_40;
    /* statement id: 58 */
    assert (l_179 == &g_123);
    return g_125;
    /* statement id: 59 */
    //assert (func_39_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_17
 * writes: g_123
 */
static float * func_45(int32_t  p_46, int32_t  p_47, float * p_48)
{ /* block id: 40 */
    int16_t l_113 = (-1);
    int32_t *l_122 = &g_123;
    for (p_47 = 0; (p_47 < 2); p_47 += 1)
    { /* block id: 43 */
        if (p_47)
            break;
        l_113 = 0xD4231368;
    }
    (*l_122) = ((p_46 > (0x10 ^ (((((uint32_t)(((((uint8_t)0x5E << (uint8_t)1) && (g_2 | (((uint8_t)p_46 >> (uint8_t)4) & ((uint16_t)l_113 + (uint16_t)(2 <= l_113))))) == (p_46 || l_113)) && g_17) / (uint32_t)p_47) || p_46) <= p_46) >= l_113))) >= 0xA9CAF05E);
    return l_122;
    /* statement id: 48 */
    //assert (func_45_rv == &g_123);
}


/* ------------------------------------------ */
/* 
 * reads : g_95 g_96
 * writes: g_96
 */
static int16_t  func_52(int32_t  p_53, float  p_54)
{ /* block id: 31 */
    int32_t *l_108 = &g_17;
    int32_t **l_109 = &l_108;
    for (p_53 = 0; (p_53 != 24); p_53 += 6)
    { /* block id: 34 */
        (*g_95) = (*g_95);
        (*g_95) = (void*)0;
        /* statement id: 36 */
        assert (g_96 == 0);
    }
    /* facts after for loop */
    assert (g_96 == 0 || g_96 == &g_97);
    (*l_109) = l_108;
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_17 g_5 g_34 g_95 g_96 g_97 g_103
 * writes: g_5 g_97
 */
inline static int32_t  func_55(int32_t  p_56, float * p_57, int32_t  p_58, int16_t  p_59, uint32_t  p_60)
{ /* block id: 10 */
    float *l_79 = &g_5;
    int32_t l_98 = 1;
    for (p_58 = 0; (p_58 < (-22)); p_58 -= 7)
    { /* block id: 13 */
        int32_t l_94 = 0;
        int32_t *l_100 = &l_98;
        int32_t **l_99 = &l_100;
        if (g_2)
        { /* block id: 14 */
            float *l_80 = &g_5;
            int32_t l_91 = 0xED9A830F;
            (*l_79) = ((((float)((float)((float)(((((float)((float)(0x4.2F5217p+69 <= ((g_17 <= p_58) != (l_79 != l_80))) - (float)((((float)0x7.4p+1 + (float)((float)((float)(((float)g_5 - (float)((float)l_91 - (float)((float)g_17 + (float)p_60))) >= l_91) - (float)0x0.9p-1) - (float)g_2)) > g_34) == l_91)) / (float)0x0.CFE74Dp-85) == 0xB.C0C20Ep+88) < g_5) == 0x7.D54759p-47) - (float)l_91) / (float)0xB.7FE6D7p+96) + (float)g_34) >= l_94) < l_94);
            if (g_34)
                break;
            (*g_96) = ((void*)0 != g_95);
        }
        else
        { /* block id: 18 */
            if ((*g_96))
                break;
            return l_98;
        }
        (*l_99) = &p_56;
        /* statement id: 22 */
        assert (l_100 == &p_56);
        for (l_94 = (-24); (l_94 != (-30)); l_94--)
        { /* block id: 25 */
            (**g_95) = (g_103 == &g_104);
            (*l_99) = &p_58;
            /* statement id: 27 */
            assert (l_100 == &p_58);
        }
        /* facts after for loop */
        assert (l_100 == &p_58 || l_100 == &p_56);
    }
    return l_98;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc_bytes (&g_5, sizeof(g_5), "g_5", print_hash_value);
    transparent_crc(g_17, "g_17", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_97, "g_97", print_hash_value);
    transparent_crc_bytes (&g_105, sizeof(g_105), "g_105", print_hash_value);
    transparent_crc(g_123, "g_123", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 40
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 10
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 59

XXX times a variable address is taken: 59
XXX times a pointer is dereferenced on RHS: 35
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 4
XXX times a pointer is dereferenced on LHS: 29
breakdown:
   depth: 1, occurrence: 25
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 171

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 63
   level: 2, occurrence: 21
XXX number of pointers point to pointers: 27
XXX number of pointers point to scalars: 32
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.14

XXX times a non-volatile is read: 210
XXX times a non-volatile is write: 63
XXX times a volatile is read: 10
XXX    times read thru a pointer: 9
XXX times a volatile is write: 8
XXX    times written thru a pointer: 7
XXX times a volatile is available for access: 37
XXX percentage of non-volatile access: 93.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 58
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 18
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 14.8
XXX percentage an existing variable is used: 85.2
********************* end of statistics **********************/

