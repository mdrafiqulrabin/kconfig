/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1397341476
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 23;
   unsigned f1 : 30;
   unsigned f2 : 2;
   signed f3 : 15;
   unsigned f4 : 13;
   signed f5 : 2;
   unsigned f6 : 6;
   signed f7 : 19;
   signed f8 : 5;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_3 = 65535U;
static int16_t g_10 = 0x37A9;
static struct S0 g_34 = {301,18155,1,126,40,-1,5,-413,4};
static int32_t g_62 = 0x837E05AF;
static int32_t g_71 = 0xE767E792;
static float g_95 = (-0x1.3p-1);
static uint32_t g_96 = 1U;
static int32_t *g_113 = &g_71;
static int32_t **g_112 = &g_113;
static struct S0 *g_127 = &g_34;
static struct S0 **g_126 = &g_127;
static float *g_179 = &g_95;
static float **g_178 = &g_179;


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_28(void);
inline static struct S0  func_29(int32_t  p_30);
static int32_t * func_35(uint32_t  p_36, int16_t  p_37);
inline static uint32_t  func_38(uint32_t  p_39, float  p_40, int32_t  p_41, float  p_42);
inline static float  func_44(int16_t  p_45);
static struct S0 * func_48(int32_t * p_49, float  p_50, struct S0 * p_51);
inline static int32_t * func_52(uint32_t  p_53);
inline static int32_t * func_54(int16_t  p_55, int32_t * p_56, int32_t  p_57, int32_t  p_58, float  p_59);
static int32_t  func_67(uint32_t  p_68);
static int32_t  func_75(uint32_t  p_76, int32_t ** p_77, uint32_t  p_78, struct S0 * p_79, float  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_34 g_62 g_71 g_3 g_112 g_113 g_126 g_127 g_96 g_178
 * writes: g_10 g_34 g_71 g_113 g_62 g_95 g_127 g_96 g_3 g_178
 */
inline static int32_t  func_28(void)
{ /* block id: 36 */
    uint16_t l_31 = 0x166C;
    struct S0 *l_162 = &g_34;
    float *l_163 = &g_95;
    int16_t l_194 = 0x672A;
    uint16_t l_196 = 0x028F;
    (*l_162) = func_29(l_31);
    /* statement id: 126 */
    assert (g_127 == &g_34 || g_127 == 0);
    (*l_163) = 0x1.4p-1;
    if ((**g_112))
    { /* block id: 128 */
        int32_t *l_166 = &g_62;
        (*g_112) = func_52((l_163 != (void*)0));
        /* statement id: 129 */
        assert (g_113 == &g_62);
        for (l_31 = 22; (l_31 >= 5); l_31 -= 1)
        { /* block id: 132 */
            struct S0 *l_171 = &g_34;
            int32_t l_181 = 0xFB177962;
            (*g_112) = l_166;
            /* statement id: 133 */
            assert (g_113 == &g_62);
            for (g_96 = 19; (g_96 == 6); g_96 -= 3)
            { /* block id: 136 */
                (*l_166) = ((int16_t)((*g_126) != l_171) - (int16_t)(*l_166));
                for (g_3 = 21; (g_3 < 46); g_3++)
                { /* block id: 140 */
                    (**g_112) = ((uint16_t)(*l_166) % (uint16_t)0x292C);
                }
            }
            for (g_96 = 13; (g_96 >= 49); g_96 += 6)
            { /* block id: 146 */
                float ***l_180 = &g_178;
                struct S0 l_182 = {1146,31659,1,-106,81,-1,2,423,-1};
                (*l_180) = g_178;
                if ((**g_112))
                    continue;
                (*l_171) = l_182;
            }
            (*g_112) = func_35((g_34.f1 & ((*l_166) & (g_34.f6 || ((*l_166) ^ (((int16_t)(-1) >> (int16_t)15) & (((uint16_t)g_10 >> (uint16_t)8) && (*g_113))))))), ((((**g_112) != ((((**g_112) && 0xDBF33FCB) <= (-6)) | l_181)) || 0xAF00) ^ g_34.f2));
            /* statement id: 151 */
            assert (g_113 == &g_71);
        }
        /* facts after for loop */
        assert (g_113 == &g_71 || g_113 == &g_62);
    }
    else
    { /* block id: 153 */
        int32_t *l_187 = (void*)0;
        (*g_112) = l_187;
        /* statement id: 154 */
        assert (g_113 == 0);
        if (((int32_t)l_31 - (int32_t)4294967294U))
        { /* block id: 155 */
            int16_t l_192 = (-1);
            struct S0 *l_193 = &g_34;
            int32_t *l_195 = &g_71;
            for (g_3 = 3; (g_3 <= 51); g_3 += 4)
            { /* block id: 158 */
                if (l_192)
                    break;
                (*g_126) = l_193;
                /* statement id: 160 */
                assert (g_127 == &g_34);
            }
            (*g_126) = l_162;
            /* statement id: 162 */
            assert (g_127 == &g_34);
            (*l_195) = (0xAC108E42 & (__builtin_popcount(l_31) | (l_194 == ((0xF099 ^ l_194) == g_96))));
        }
        else
        { /* block id: 164 */
            (*l_162) = (*l_162);
        }
    }
    /* facts after branching */
    assert (g_113 == 0 || g_113 == &g_71 || g_113 == &g_62);
    return l_196;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_34 g_62 g_71 g_3 g_112 g_113 g_126 g_127 g_96
 * writes: g_10 g_34 g_71 g_113 g_62 g_95 g_127
 */
inline static struct S0  func_29(int32_t  p_30)
{ /* block id: 37 */
    int32_t l_43 = (-5);
    struct S0 l_161 = {2652,3394,1,106,37,-0,1,-538,0};
    for (g_10 = 0; (g_10 <= (-16)); g_10 -= 1)
    { /* block id: 40 */
        return g_34;
    }
    (*g_112) = func_35(func_38(g_10, l_43, ((&l_43 != &l_43) && 65534U), (func_44(l_43) > (!g_96))), l_43);
    /* statement id: 124 */
    assert (g_127 == &g_34 || g_127 == 0);
    return l_161;
}


/* ------------------------------------------ */
/* 
 * reads : g_112 g_113
 * writes: g_62
 */
static int32_t * func_35(uint32_t  p_36, int16_t  p_37)
{ /* block id: 121 */
    int32_t *l_160 = &g_71;
    (**g_112) = 8;
    return l_160;
    /* statement id: 123 */
    //assert (func_35_rv == &g_71);
}


/* ------------------------------------------ */
/* 
 * reads : g_112 g_34.f3
 * writes: g_113
 */
inline static uint32_t  func_38(uint32_t  p_39, float  p_40, int32_t  p_41, float  p_42)
{ /* block id: 114 */
    int32_t *l_159 = &g_62;
    for (p_41 = 0; (p_41 > (-9)); --p_41)
    { /* block id: 117 */
        (*g_112) = l_159;
    }
    return g_34.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_62 g_71 g_3 g_112 g_113 g_126 g_10 g_127
 * writes: g_34 g_71 g_113 g_62 g_95 g_127
 */
inline static float  func_44(int16_t  p_45)
{ /* block id: 43 */
    for (p_45 = 0; (p_45 < 15); p_45 += 3)
    { /* block id: 46 */
        g_34 = g_34;
    }
    (*g_126) = func_48(func_52(p_45), g_10, (*g_126));
    /* statement id: 112 */
    assert (g_113 == &g_62);
    assert (g_127 == &g_34 || g_127 == 0);
    return g_34.f6;
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_112 g_113 g_34.f5 g_127 g_34 g_3
 * writes: g_62 g_34 g_113
 */
static struct S0 * func_48(int32_t * p_49, float  p_50, struct S0 * p_51)
{ /* block id: 93 */
    uint16_t l_132 = 65535U;
    int32_t l_147 = 0xBB719D35;
    float *l_151 = &g_95;
    struct S0 *l_155 = (void*)0;
    for (g_62 = 0; (g_62 <= 6); g_62 += 1)
    { /* block id: 96 */
        int32_t l_143 = 1;
        struct S0 *l_144 = &g_34;
        float *l_152 = &g_95;
        if (l_132)
        { /* block id: 97 */
            int32_t l_137 = (-3);
            float *l_153 = (void*)0;
            if (((((uint16_t)((uint16_t)l_137 + (uint16_t)(((~(((uint16_t)(((*p_49) & ((**g_112) ^ (l_137 & ((int16_t)(0xCB4C || g_34.f5) << (int16_t)(l_137 < ((void*)0 == &g_113)))))) & l_132) - (uint16_t)l_137) || 9U)) ^ l_137) && l_143)) << (uint16_t)l_132) < (*p_49)) >= l_143))
            { /* block id: 98 */
                return l_144;
                /* statement id: 99 */
                //assert (func_48_rv == &g_34);
            }
            else
            { /* block id: 100 */
                l_147 = (!(-(int16_t)l_143));
            }
            (*g_127) = (*g_127);
            (*g_112) = func_54(l_137, (*g_112), ((uint32_t)l_132 - (uint32_t)__builtin_clz((((!((void*)0 != l_151)) != l_137) | (l_152 != l_153)))), g_3, l_143);
        }
        else
        { /* block id: 105 */
            struct S0 l_154 = {773,20060,0,93,78,0,5,188,-0};
            (*p_51) = l_154;
        }
    }
    (*g_113) = (*g_113);
    (*g_112) = p_49;
    return l_155;
    /* statement id: 111 */
    //assert (func_48_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_62 g_34.f1 g_34.f5 g_71 g_34.f7 g_3 g_112 g_113 g_126
 * writes: g_71 g_113 g_62 g_34 g_95
 */
inline static int32_t * func_52(uint32_t  p_53)
{ /* block id: 49 */
    uint32_t l_60 = 0x213633E7;
    int32_t *l_61 = &g_62;
    int32_t l_117 = 4;
    struct S0 l_124 = {2729,7777,1,149,49,0,5,369,-0};
    struct S0 **l_128 = &g_127;
    (*g_112) = func_54(l_60, l_61, p_53, (((uint32_t)((*l_61) && 4294967291U) + (uint32_t)((int16_t)p_53 << (int16_t)15)) ^ func_67((((4294967287U != g_34.f1) != (*l_61)) & (-1)))), (*l_61));
    /* statement id: 82 */
    assert (g_113 == &g_62);
    if ((4294967289U && (((int16_t)p_53 << (int16_t)((**g_112) >= (**g_112))) || __builtin_ffs(l_117))))
    { /* block id: 83 */
        int32_t **l_120 = &l_61;
        uint32_t l_123 = 0x13D3D183;
        (*g_112) = func_54(((int16_t)func_75(p_53, &g_113, ((void*)0 != l_120), &g_34, (*l_61)) << (int16_t)((int16_t)p_53 % (int16_t)p_53)), (*l_120), g_62, (*l_61), p_53);
        (*l_61) = l_123;
    }
    else
    { /* block id: 86 */
        struct S0 *l_125 = &g_34;
        float *l_129 = &g_95;
        (*l_125) = l_124;
        (*l_61) = (*g_113);
        l_128 = g_126;
        (*l_129) = 0x9.9p+1;
    }
    return (*g_112);
    /* statement id: 92 */
    //assert (func_52_rv == &g_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_54(int16_t  p_55, int32_t * p_56, int32_t  p_57, int32_t  p_58, float  p_59)
{ /* block id: 80 */
    return p_56;
    /* statement id: 81 */
    //assert (func_54_rv == &g_62);
}


/* ------------------------------------------ */
/* 
 * reads : g_34.f5 g_71 g_34.f7 g_62 g_3 g_112 g_113
 * writes: g_71 g_113
 */
static int32_t  func_67(uint32_t  p_68)
{ /* block id: 50 */
    uint32_t l_69 = 0xE0AEE481;
    int32_t *l_70 = &g_71;
    l_69 = 0xF.7E5FF1p-22;
    (*l_70) = 3;
    for (p_68 = 0; (p_68 == 53); p_68++)
    { /* block id: 55 */
        int32_t **l_74 = &l_70;
        struct S0 *l_81 = (void*)0;
        int16_t l_88 = 1;
        (*l_74) = &g_71;
        /* statement id: 56 */
        assert (l_70 == &g_71);
        if (func_75((p_68 == p_68), l_74, g_34.f5, l_81, (&g_71 == (void*)0)))
        { /* block id: 60 */
            int32_t *l_85 = (void*)0;
            for (g_71 = (-23); (g_71 > 3); g_71 += 7)
            { /* block id: 63 */
                float *l_93 = (void*)0;
                float *l_94 = &g_95;
                (*l_74) = l_70;
            }
        }
        else
        { /* block id: 72 */
            int32_t *l_98 = &g_62;
            float *l_111 = &g_95;
            int32_t l_114 = 0;
            (*l_74) = (*l_74);
            (*l_74) = (void*)0;
            /* statement id: 74 */
            assert (l_70 == 0);
            (*l_74) = l_98;
            /* statement id: 75 */
            assert (l_70 == &g_62);
            l_114 = ((uint16_t)((uint16_t)((int16_t)((int16_t)0xE9E8 + (int16_t)((uint32_t)(((void*)0 != l_81) & g_34.f7) + (uint32_t)p_68)) >> (int16_t)6) << (uint16_t)((*l_98) | func_75(((4294967289U >= ((uint16_t)(((void*)0 != l_111) || g_3) << (uint16_t)(*l_70))) < (**l_74)), g_112, p_68, l_81, (*l_98)))) << (uint16_t)15);
            /* statement id: 76 */
            assert (g_113 == &g_71);
        }
        /* facts after branching */
        assert (l_70 == &g_62 || l_70 == &g_71);
    }
    /* facts after for loop */
    assert (l_70 == &g_62 || l_70 == &g_71);
    return (**g_112);
}


/* ------------------------------------------ */
/* 
 * reads : g_71
 * writes: g_113
 */
static int32_t  func_75(uint32_t  p_76, int32_t ** p_77, uint32_t  p_78, struct S0 * p_79, float  p_80)
{ /* block id: 57 */
    int32_t *l_82 = &g_71;
    (*p_77) = l_82;
    return (*l_82);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_10, "g_10", print_hash_value);
    transparent_crc(g_34.f0, "g_34.f0", print_hash_value);
    transparent_crc(g_34.f1, "g_34.f1", print_hash_value);
    transparent_crc(g_34.f2, "g_34.f2", print_hash_value);
    transparent_crc(g_34.f3, "g_34.f3", print_hash_value);
    transparent_crc(g_34.f4, "g_34.f4", print_hash_value);
    transparent_crc(g_34.f5, "g_34.f5", print_hash_value);
    transparent_crc(g_34.f6, "g_34.f6", print_hash_value);
    transparent_crc(g_34.f7, "g_34.f7", print_hash_value);
    transparent_crc(g_34.f8, "g_34.f8", print_hash_value);
    transparent_crc(g_62, "g_62", print_hash_value);
    transparent_crc(g_71, "g_71", print_hash_value);
    transparent_crc_bytes (&g_95, sizeof(g_95), "g_95", print_hash_value);
    transparent_crc(g_96, "g_96", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 48
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 12
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 2
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 13

XXX max expression depth: 19
breakdown:
   depth: 1, occurrence: 86
   depth: 2, occurrence: 14
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 2
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1

XXX total number of pointers: 44

XXX times a variable address is taken: 38
XXX times a pointer is dereferenced on RHS: 36
breakdown:
   depth: 1, occurrence: 27
   depth: 2, occurrence: 9
XXX times a pointer is dereferenced on LHS: 38
breakdown:
   depth: 1, occurrence: 36
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 95

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 154
   level: 2, occurrence: 27
XXX number of pointers point to pointers: 8
XXX number of pointers point to scalars: 25
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 27.3
XXX average alias set size: 1.18

XXX times a non-volatile is read: 217
XXX times a non-volatile is write: 94
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 72
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 16
   depth: 2, occurrence: 17
   depth: 3, occurrence: 10
   depth: 4, occurrence: 1

XXX percentage a fresh-made variable is used: 27.6
XXX percentage an existing variable is used: 72.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

