/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1877919652
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 26;
   uint32_t  f1;
   unsigned f2 : 28;
   unsigned f3 : 31;
   signed f4 : 5;
   unsigned f5 : 22;
   unsigned f6 : 21;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_31(void);
inline static int32_t * func_32(int32_t  p_33, int32_t  p_34, int32_t * p_35);
inline static int32_t * func_38(int32_t  p_39, int32_t * p_40, uint16_t  p_41);
static uint16_t  func_45(struct S0  p_46);
static int32_t ** func_48(struct S0  p_49, struct S0  p_50, int32_t  p_51, int32_t * p_52);
static uint64_t  func_53(int32_t ** p_54);
static int32_t ** func_55(uint16_t  p_56, uint32_t  p_57, int32_t * p_58);
inline static int32_t * func_60(uint32_t  p_61, int16_t  p_62, int32_t ** p_63, int32_t  p_64, uint16_t  p_65);
inline static uint32_t  func_71(uint32_t  p_72, int32_t  p_73, struct S0  p_74, uint32_t  p_75);
inline static int32_t * func_87(int32_t * p_88, int16_t  p_89, uint32_t  p_90, uint32_t  p_91, uint16_t  p_92);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_31(void)
{ /* block id: 36 */
    int32_t l_37 = 0x1CE3CB5A;
    int32_t *l_36 = &l_37;
    int32_t *l_450 = &l_37;
    int32_t **l_451 = (void*)0;
    int32_t **l_452 = (void*)0;
    int32_t **l_453 = &l_36;
    int32_t l_454 = 0xA08C83F3;
    l_36 = func_32((l_36 == (void*)0), (*l_36), func_38((&l_37 == (void*)0), &l_37, (*l_36)));
    (*l_453) = func_32((l_37 >= l_37), __builtin_clzl(l_37), l_450);
    return l_454;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_32(int32_t  p_33, int32_t  p_34, int32_t * p_35)
{ /* block id: 255 */
    int32_t l_371 = 0;
    int32_t *l_370 = &l_371;
    int32_t *l_384 = &l_371;
    struct S0 l_389 = {7932,0x25770872,7010,14190,-4,1823,29};
    int16_t l_424 = 9;
    int32_t *l_440 = &l_371;
    int32_t *l_441 = &l_371;
    int32_t *l_442 = &l_371;
    int32_t *l_443 = &l_371;
    int32_t *l_444 = &l_371;
    int32_t *l_445 = &l_371;
    int32_t *l_446 = &l_371;
    int32_t *l_447 = &l_371;
    int32_t *l_448 = &l_371;
    int32_t *l_449 = (void*)0;
    if (__builtin_ctz(p_34))
    { /* block id: 256 */
        l_370 = l_370;
    }
    else
    { /* block id: 258 */
        struct S0 l_388 = {7803,4294967293U,13511,43837,-1,977,1279};
        int32_t *l_439 = &l_371;
        if ((*l_370))
        { /* block id: 259 */
            struct S0 *l_387 = (void*)0;
            int32_t **l_390 = &l_370;
            struct S0 *l_391 = &l_389;
            for (p_34 = (-27); (p_34 < 23); p_34 += 1)
            { /* block id: 262 */
                int32_t **l_381 = &l_370;
                int32_t *l_382 = &l_371;
                if (p_33)
                    break;
                for (l_371 = (-27); (l_371 < 8); l_371 += 6)
                { /* block id: 266 */
                    int32_t *l_379 = &l_371;
                    int32_t **l_380 = &l_370;
                    int32_t *l_383 = (void*)0;
                    for (p_33 = 0; (p_33 < (-2)); p_33 -= 2)
                    { /* block id: 269 */
                        int32_t **l_378 = &l_370;
                        (*l_378) = (void*)0;
                    }
                    (*l_380) = l_379;
                    if (func_53(l_381))
                    { /* block id: 273 */
                        return l_383;
                    }
                    else
                    { /* block id: 275 */
                        (*l_380) = l_384;
                        if ((**l_380))
                            break;
                    }
                    (*l_381) = &p_33;
                }
            }
            l_389 = l_388;
            (*l_390) = &l_371;
            (*l_391) = l_388;
        }
        else
        { /* block id: 285 */
            struct S0 l_394 = {4255,0x8B6AEAC0,8398,1962,1,210,837};
            int32_t l_404 = (-3);
            for (p_34 = (-25); (p_34 <= 19); p_34 += 2)
            { /* block id: 288 */
                struct S0 *l_395 = &l_389;
                int32_t **l_396 = (void*)0;
                int32_t **l_397 = &l_384;
                (*l_395) = l_394;
                (*l_397) = &p_33;
                (*l_384) = (p_34 > (((l_394.f2 | (func_71(l_388.f4, p_33, (*l_395), p_34) ^ __builtin_clzll((((-10) ^ (((uint16_t)((*l_384) < 0xBAB30439) - (uint16_t)(*l_370)) && p_34)) >= p_33)))) > (**l_397)) & p_33));
            }
lbl_432:
            (*l_384) = ((int16_t)((uint16_t)l_394.f2 % (uint16_t)l_404) % (int16_t)65535U);
            for (l_371 = 0; (l_371 < 6); l_371 += 6)
            { /* block id: 296 */
                int32_t l_413 = 8;
                int32_t **l_433 = &l_384;
                for (p_34 = (-24); (p_34 >= (-14)); p_34 += 8)
                { /* block id: 299 */
                    uint32_t l_414 = 6U;
                    int32_t **l_428 = &l_384;
                    if (((uint16_t)(((int16_t)((l_413 <= (l_414 > l_413)) >= ((((!(((uint16_t)((0xE4BB47E3 | ((uint16_t)(((l_394.f4 < __builtin_ffsl(p_34)) || ((((uint16_t)((uint32_t)(p_33 == (p_34 && 0xA1AC)) - (uint32_t)0x64A0E397) + (uint16_t)p_34) < l_394.f4) && p_34)) == p_33) - (uint16_t)l_388.f0)) & l_424) >> (uint16_t)(*l_370)) < l_414)) == l_388.f4) ^ (*l_370)) <= l_413)) - (int16_t)65530U) != l_404) >> (uint16_t)p_34))
                    { /* block id: 300 */
                        uint16_t l_425 = 0xC879;
                        if (l_425)
                            break;
                    }
                    else
                    { /* block id: 302 */
                        l_388.f4 = (__builtin_popcount(((int16_t)p_33 % (int16_t)p_33)) | 1U);
                    }
                    (*l_428) = &l_404;
                    for (p_33 = 0; (p_33 <= (-7)); p_33 -= 1)
                    { /* block id: 308 */
                        struct S0 *l_431 = &l_388;
                        (*l_431) = l_388;
                    }
                }
                if (l_394.f3)
                    goto lbl_432;
                (*l_433) = &l_371;
            }
            (*l_439) = (((uint16_t)(+0U) - (uint16_t)(&p_35 != &p_35)) && ((int16_t)(&l_371 == l_439) % (int16_t)p_34));
        }
    }
    return l_449;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_38(int32_t  p_39, int32_t * p_40, uint16_t  p_41)
{ /* block id: 37 */
    struct S0 l_47 = {5116,4294967295U,1705,3120,0,1042,438};
    int32_t l_363 = 0xF5CE1E3A;
    int32_t *l_362 = &l_363;
    int32_t *l_368 = (void*)0;
    int32_t *l_369 = (void*)0;
    if (((((uint16_t)p_39 / (uint16_t)(+((func_45(l_47) | p_41) == (p_41 > (l_47.f6 != l_47.f3))))) > (func_71(((void*)0 != l_362), (*p_40), l_47, p_39) <= (*l_362))) != p_41))
    { /* block id: 247 */
        int32_t **l_364 = &l_362;
        struct S0 *l_365 = (void*)0;
        struct S0 *l_366 = &l_47;
        (*l_364) = &p_39;
        (*l_366) = l_47;
        (*l_366) = l_47;
    }
    else
    { /* block id: 251 */
        int32_t *l_367 = &l_363;
        return l_368;
    }
    return l_369;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(struct S0  p_46)
{ /* block id: 38 */
    int32_t l_59 = 0xC489718B;
    int32_t l_81 = 0xCB52F506;
    int32_t *l_80 = &l_81;
    int32_t **l_79 = &l_80;
    int32_t ***l_261 = &l_79;
    int32_t ****l_260 = &l_261;
    struct S0 l_353 = {1937,1U,6121,6515,-3,1294,1377};
    struct S0 *l_352 = &l_353;
    struct S0 **l_351 = &l_352;
    if (p_46.f1)
    { /* block id: 39 */
        int32_t *l_68 = (void*)0;
        int32_t ***l_240 = &l_79;
        struct S0 l_249 = {2759,0xA3353FAB,6183,6551,1,1639,933};
        struct S0 *l_248 = &l_249;
        struct S0 **l_247 = &l_248;
        (*l_240) = func_48(p_46, p_46, (__builtin_bswap64(func_53(func_55(p_46.f3, l_59, func_60(((int16_t)(l_68 == (void*)0) - (int16_t)0x77FC), (l_59 || ((uint32_t)func_71(p_46.f3, l_59, p_46, l_59) - (uint32_t)p_46.f5)), l_79, (*l_80), (*l_80))))) > 5), l_68);
lbl_255:
        p_46.f4 = p_46.f5;
        for (l_81 = 3; (l_81 < 21); l_81 += 4)
        { /* block id: 150 */
            int32_t **l_265 = &l_80;
            int32_t *l_267 = &l_81;
            struct S0 **l_287 = &l_248;
            for (l_59 = 0; (l_59 >= (-25)); l_59 -= 1)
            { /* block id: 153 */
                int32_t l_250 = 0xF5A8E2E1;
                int32_t l_253 = 0x32DF4A33;
                int32_t *l_252 = &l_253;
                struct S0 *l_254 = &l_249;
                struct S0 **l_266 = &l_248;
                uint32_t l_292 = 0xADB36972;
                for (p_46.f1 = (-1); (p_46.f1 < 8); p_46.f1 += 4)
                { /* block id: 156 */
                    int32_t ****l_262 = &l_261;
                    l_247 = l_247;
                    if (p_46.f0)
                    { /* block id: 158 */
                        if (p_46.f1)
                            break;
                    }
                    else
                    { /* block id: 160 */
                        return p_46.f6;
                    }
                    if (p_46.f2)
                    { /* block id: 163 */
                        if (l_250)
                            break;
                    }
                    else
                    { /* block id: 165 */
                        int32_t *l_251 = &l_81;
                        l_252 = l_251;
                        (*l_247) = l_254;
                        if (p_46.f1)
                            goto lbl_255;
                        if ((*l_252))
                            break;
                    }
                    p_46.f4 = (((uint32_t)((int16_t)(((l_260 != l_262) != 0x90C31A17) == ((int16_t)(-10) >> (int16_t)0)) >> (int16_t)0) - (uint32_t)(p_46.f2 & p_46.f1)) > func_53(l_265));
                }
                p_46.f4 = (((-7) && p_46.f0) | (l_266 == &l_254));
                (*l_265) = l_267;
                if ((__builtin_ctzll(p_46.f1) | ((int16_t)((uint32_t)__builtin_parity(p_46.f5) + (uint32_t)(*l_252)) - (int16_t)p_46.f1)))
                { /* block id: 175 */
                    if (p_46.f4)
                        break;
                    for (l_249.f1 = 0; (l_249.f1 <= 59); l_249.f1 += 9)
                    { /* block id: 179 */
                        p_46.f4 = func_53((*l_261));
                        if (p_46.f6)
                            goto lbl_255;
                    }
                    return p_46.f0;
                }
                else
                { /* block id: 184 */
                    int32_t l_276 = 0x988B3323;
                    (*l_265) = (void*)0;
                    l_253 = (((uint16_t)__builtin_ffs((l_276 == ((uint16_t)0x83CA + (uint16_t)((((func_53(&l_252) > __builtin_bswap32(p_46.f1)) >= (p_46.f1 & p_46.f5)) | (((uint16_t)(&p_46 == (*l_247)) << (uint16_t)13) || 5)) | (*l_267))))) << (uint16_t)11) ^ 0x28A0);
                    if (((*l_240) == &l_267))
                    { /* block id: 187 */
                        int32_t *l_293 = (void*)0;
                        l_68 = (void*)0;
                        p_46.f4 = ((int32_t)((int32_t)func_71((((uint16_t)(l_287 != l_287) >> (uint16_t)p_46.f1) >= ((uint16_t)((p_46.f0 || (((((((int32_t)(&p_46 == &p_46) - (int32_t)p_46.f1) && (0xCC2AE391 == l_292)) & 0x0578) ^ l_276) >= 1) && 1)) & p_46.f3) - (uint16_t)p_46.f5)), p_46.f0, p_46, p_46.f0) / (int32_t)l_276) - (int32_t)0x831052E9);
                    }
                    else
                    { /* block id: 190 */
                        return p_46.f2;
                    }
                    return p_46.f4;
                }
            }
        }
    }
    else
    { /* block id: 197 */
        int32_t ***l_296 = &l_79;
        struct S0 *l_298 = (void*)0;
        struct S0 **l_297 = &l_298;
        int32_t l_339 = 7;
        int32_t l_360 = 4;
        for (l_59 = 0; (l_59 > 23); l_59 += 1)
        { /* block id: 200 */
            struct S0 ***l_299 = &l_297;
            int32_t l_304 = 1;
            int32_t **l_322 = &l_80;
        }
        (***l_260) = (void*)0;
        for (l_81 = (-4); (l_81 <= 26); l_81 += 1)
        { /* block id: 240 */
            struct S0 **l_350 = &l_298;
            int32_t l_356 = 0x86EE01CB;
            int32_t **l_357 = &l_80;
            int32_t *l_358 = (void*)0;
            int32_t *l_359 = &l_356;
            p_46.f4 = ((func_71((l_339 ^ (((uint16_t)((int16_t)((~((uint16_t)(+((p_46.f2 != ((int16_t)p_46.f4 >> (int16_t)(l_350 != l_351))) == p_46.f2)) + (uint16_t)(-(uint32_t)((-(int16_t)((l_356 && (l_357 != (void*)0)) & p_46.f6)) != p_46.f5)))) & (-1)) + (int16_t)p_46.f5) << (uint16_t)p_46.f6) || p_46.f6)), p_46.f2, p_46, p_46.f0) > p_46.f2) >= p_46.f6);
            (*l_359) = p_46.f0;
        }
        p_46.f4 = ((__builtin_bswap32(l_339) > l_360) > __builtin_clz((!0x2A3EE8A6)));
    }
    return p_46.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_48(struct S0  p_49, struct S0  p_50, int32_t  p_51, int32_t * p_52)
{ /* block id: 143 */
    int32_t l_236 = (-8);
    int32_t *l_235 = &l_236;
    int32_t **l_234 = &l_235;
    int32_t **l_237 = &l_235;
    int32_t **l_238 = &l_235;
    int32_t **l_239 = (void*)0;
    (*l_234) = &p_51;
    return l_239;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_53(int32_t ** p_54)
{ /* block id: 139 */
    int32_t *l_228 = (void*)0;
    int32_t l_229 = 0xC8F83BE1;
    struct S0 l_231 = {2038,3U,12151,14199,-0,845,134};
    struct S0 *l_230 = &l_231;
    struct S0 **l_232 = (void*)0;
    struct S0 **l_233 = (void*)0;
    l_229 = 0xC4373212;
    l_230 = l_230;
    return l_229;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_55(uint16_t  p_56, uint32_t  p_57, int32_t * p_58)
{ /* block id: 135 */
    int32_t *l_218 = (void*)0;
    int32_t **l_219 = (void*)0;
    int32_t **l_220 = &l_218;
    struct S0 l_221 = {2885,1U,5991,11118,-3,991,523};
    struct S0 *l_222 = &l_221;
    int32_t **l_223 = &l_218;
    int32_t **l_224 = &l_218;
    int32_t **l_225 = &l_218;
    int32_t **l_226 = &l_218;
    int32_t **l_227 = (void*)0;
    (*l_220) = l_218;
    (*l_222) = l_221;
    return l_227;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_60(uint32_t  p_61, int16_t  p_62, int32_t ** p_63, int32_t  p_64, uint16_t  p_65)
{ /* block id: 43 */
    uint32_t l_84 = 0xD71F6E69;
    int32_t l_86 = 1;
    int32_t *l_85 = &l_86;
    int32_t l_96 = 0x2CD76E66;
    int16_t l_192 = 1;
    struct S0 l_199 = {3078,0x86180D30,9672,8762,0,430,339};
    uint32_t l_206 = 0U;
    int32_t *l_216 = &l_96;
    int32_t *l_217 = (void*)0;
    if (((uint16_t)l_84 >> (uint16_t)13))
    { /* block id: 44 */
        int32_t *l_93 = &l_86;
        (*l_85) = (l_85 != &l_86);
        (*p_63) = func_87(l_93, p_64, p_64, ((uint32_t)l_96 + (uint32_t)(*l_85)), (0xBCD59021 | p_62));
    }
    else
    { /* block id: 116 */
        int16_t l_200 = 0xED91;
        struct S0 l_201 = {4500,4294967295U,3079,2466,-2,745,1175};
        struct S0 *l_202 = &l_201;
lbl_203:
        for (l_84 = 0; (l_84 < 11); l_84++)
        { /* block id: 119 */
            struct S0 l_198 = {6645,0x0E5196A2,8549,42839,4,1747,1035};
            struct S0 *l_197 = &l_198;
        }
        (*l_202) = l_201;
        if (p_64)
            goto lbl_203;
    }
    if (((int16_t)((l_206 | __builtin_parityl((*l_85))) ^ ((int32_t)((&l_85 != &l_85) <= (0x0D9D & ((int16_t)(((0xEEE6CD1A ^ (~((-1) > ((*l_85) > (*l_85))))) || 0xFB0687F2) > (*l_85)) << (int16_t)p_64))) + (int32_t)p_65)) % (int16_t)p_64))
    { /* block id: 127 */
        (*l_85) = ((*l_85) | ((uint16_t)0x63BC << (uint16_t)10));
        (*p_63) = (*p_63);
        (*l_85) = p_64;
    }
    else
    { /* block id: 131 */
        (*p_63) = (*p_63);
    }
    return l_217;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_71(uint32_t  p_72, int32_t  p_73, struct S0  p_74, uint32_t  p_75)
{ /* block id: 40 */
    int32_t l_78 = 0xD9913D70;
    int32_t *l_77 = &l_78;
    int32_t **l_76 = &l_77;
    (*l_76) = (void*)0;
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads : l_81
 * writes: l_81
 */
inline static int32_t * func_87(int32_t * p_88, int16_t  p_89, uint32_t  p_90, uint32_t  p_91, uint16_t  p_92)
{ /* block id: 46 */
    int32_t *l_98 = (void*)0;
    int32_t **l_97 = &l_98;
    int32_t ***l_99 = &l_97;
    struct S0 l_128 = {3186,0U,10479,17148,-4,808,145};
    int32_t l_153 = 0x19F4420C;
    struct S0 *l_189 = &l_128;
lbl_188:
    (*l_99) = l_97;
    if ((-(uint32_t)8U))
    { /* block id: 48 */
        int16_t l_101 = 0xD5D2;
        struct S0 l_111 = {989,0xE8DF325E,1900,45879,2,111,103};
        struct S0 *l_110 = &l_111;
        int32_t ***l_127 = &l_97;
        int16_t l_142 = 0x8F02;
        int16_t l_147 = 0x7A0D;
        if ((l_101 > ((uint16_t)((0xE6AC >= ((int16_t)(((l_101 != (*p_88)) > (((int16_t)(p_89 <= (p_91 | p_92)) << (int16_t)6) | ((__builtin_ffs((*p_88)) && p_92) || 0x9FB0E7FB))) > 65535U) << (int16_t)15)) >= 0x75DCB435) % (uint16_t)p_91)))
        { /* block id: 49 */
            struct S0 l_109 = {3593,0xE7F8E482,2352,43361,-4,1139,390};
            struct S0 *l_108 = &l_109;
            l_110 = l_108;
            (*p_88) = ((int32_t)((int16_t)(-(uint32_t)(l_111.f3 == (func_71(l_109.f0, (*p_88), (*l_108), ((uint16_t)(p_88 != p_88) << (uint16_t)13)) & (&l_109 == &l_111)))) - (int16_t)l_109.f2) + (int32_t)p_90);
        }
        else
        { /* block id: 52 */
            int32_t **l_119 = &l_98;
            int16_t l_134 = 0xA4EC;
            uint32_t l_139 = 0U;
            int32_t l_154 = 5;
            struct S0 *l_172 = &l_128;
            if (__builtin_ffsl((((void*)0 == l_119) <= p_89)))
            { /* block id: 53 */
                int32_t ***l_126 = &l_119;
                struct S0 l_148 = {50,0xE4526E09,15731,41918,3,1517,384};
                if (((0 & ((int16_t)((uint16_t)((__builtin_ffsl(((uint32_t)p_92 - (uint32_t)((l_126 != l_127) & (4294967293U > (-4))))) >= 1U) < p_89) >> (uint16_t)5) << (int16_t)p_92)) <= 0x496E341D))
                { /* block id: 54 */
                    int32_t l_138 = 0x3ABD0210;
                    (*l_110) = l_128;
                    (*p_88) = ((((uint16_t)(p_92 == (p_89 > (((uint16_t)((~((((void*)0 != l_127) && (((p_90 < __builtin_clz(l_134)) & p_92) == ((-(uint32_t)((uint16_t)((*l_127) == &p_88) % (uint16_t)p_92)) && l_138))) < p_92)) | l_139) + (uint16_t)p_90) || p_92))) >> (uint16_t)12) & 0xA098) < p_92);
                    for (l_128.f1 = 7; (l_128.f1 == 4); l_128.f1 -= 1)
                    { /* block id: 59 */
                        p_88 = (**l_127);
                    }
                }
                else
                { /* block id: 62 */
                    (*p_88) = (*p_88);
                }
                l_154 = (l_142 && ((int16_t)func_71(p_92, ((int32_t)l_147 - (int32_t)(p_90 >= p_92)), l_148, (((int16_t)(l_101 == p_92) - (int16_t)((int32_t)l_153 % (int32_t)p_90)) == p_89)) + (int16_t)l_148.f2));
                return p_88;
            }
            else
            { /* block id: 67 */
                struct S0 l_155 = {1074,0x44E1F5B4,8958,27634,0,309,633};
                int32_t ***l_161 = &l_119;
                (*l_110) = l_155;
                if ((*p_88))
                { /* block id: 69 */
                    int32_t *l_160 = &l_154;
                    if ((((uint16_t)p_90 + (uint16_t)1U) < p_89))
                    { /* block id: 70 */
                        int32_t **l_158 = &l_98;
lbl_159:
                        l_158 = l_119;
                        (*p_88) = (*p_88);
                        if (l_128.f0)
                            goto lbl_159;
                    }
                    else
                    { /* block id: 74 */
                        int32_t ****l_162 = &l_161;
                        struct S0 **l_163 = &l_110;
                        (**l_99) = l_160;
                        (*l_162) = l_161;
                        (*l_163) = &l_111;
                    }
                    (**l_99) = p_88;
                    if ((5U && ((((int32_t)(*l_160) * (int32_t)(!(l_127 != &l_97))) != (*l_160)) > (0 | (+(***l_127))))))
                    { /* block id: 80 */
                        (*l_97) = p_88;
                    }
                    else
                    { /* block id: 82 */
                        (**l_97) = (***l_99);
                        (***l_99) = 0x68F058C4;
                        (**l_127) = (void*)0;
                        l_128 = l_128;
                    }
                }
                else
                { /* block id: 88 */
                    return p_88;
                }
            }
            for (p_91 = (-7); (p_91 < 35); p_91 += 1)
            { /* block id: 94 */
                uint32_t l_183 = 0U;
                int32_t l_187 = 1;
            }
            (**l_99) = p_88;
        }
        (**l_99) = (**l_99);
        if (l_153)
            goto lbl_188;
    }
    else
    { /* block id: 109 */
        return p_88;
    }
    (*l_97) = p_88;
    (*l_189) = l_128;
    return p_88;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 112
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 10
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 6
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 22
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 35
XXX times a single bitfield on LHS: 9
XXX times a single bitfield on RHS: 61

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 170
   depth: 2, occurrence: 22
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 128

XXX times a variable address is taken: 123
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 8
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 72
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 10
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 306

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 229
   level: 2, occurrence: 76
   level: 3, occurrence: 53
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 61
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 31.2
XXX average alias set size: 1.23

XXX times a non-volatile is read: 498
XXX times a non-volatile is write: 212
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 6

XXX stmts: 143
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 26
   depth: 2, occurrence: 16
   depth: 3, occurrence: 17
   depth: 4, occurrence: 26
   depth: 5, occurrence: 31

XXX percentage a fresh-made variable is used: 12.1
XXX percentage an existing variable is used: 87.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

