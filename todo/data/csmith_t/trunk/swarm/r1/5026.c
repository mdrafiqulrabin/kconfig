/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3352501296
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   float  f0;
   uint32_t  f1;
   int16_t  f2;
   unsigned f3 : 21;
   uint32_t  f4;
   unsigned f5 : 24;
   uint32_t  f6;
   float  f7;
   uint32_t  f8;
};
#pragma pack(pop)

struct S1 {
   int16_t  f0;
   const unsigned f1 : 16;
   const uint32_t  f2;
   struct S0  f3;
   struct S0  f4;
   int32_t  f5;
   float  f6;
   uint32_t  f7;
   int32_t  f8;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   signed f0 : 6;
   const unsigned f1 : 5;
   unsigned f2 : 23;
   signed f3 : 5;
   const signed f4 : 16;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S3 {
   const signed f0 : 16;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_30(void);
inline static struct S2 * func_31(const struct S2 * p_32);
static int32_t  func_35(struct S2 * const  p_36, struct S0  p_37, struct S2 * p_38, uint16_t  p_39, struct S2 * const  p_40);
inline static struct S1  func_41(uint16_t  p_42, struct S3  p_43, struct S2 * p_44, int16_t  p_45, struct S2  p_46);
static uint16_t  func_47(int32_t  p_48, int32_t  p_49, struct S3  p_50);
inline static const int32_t  func_60(struct S3  p_61, struct S2 * p_62, uint16_t  p_63);
inline static struct S3  func_64(struct S2 * p_65, int32_t  p_66, int32_t  p_67, struct S2 * p_68);
inline static struct S2 * func_69(const int16_t  p_70, uint32_t  p_71);
inline static uint32_t  func_74(struct S2 * p_75, struct S2 * p_76);
inline static struct S2 * func_77(struct S2 * p_78, const struct S2 * p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_30(void)
{ /* block id: 36 */
    struct S2 l_34 = {5,4,1365,1,88};
    const struct S2 *l_33 = &l_34;
    struct S2 **l_254 = (void*)0;
    struct S2 *l_256 = &l_34;
    struct S2 **l_255 = &l_256;
    struct S3 *l_257 = (void*)0;
    struct S3 l_270 = {-185};
    const struct S3 **l_280 = (void*)0;
    const struct S3 ***l_279 = &l_280;
    const struct S3 ****l_278 = &l_279;
    int32_t l_287 = 8L;
    const struct S3 *l_296 = &l_270;
    const struct S3 **l_295 = &l_296;
    struct S1 l_297 = {0x2532L,92,0xC98F07CFL,{0x3.AE7860p+61,4294967286UL,0x9355L,1045,0x9AC1A0D1L,2085,18446744073709551613UL,0x0.3B0A82p-29,0xF27435C9L},{0x5.6p+1,4294967295UL,7L,695,2UL,2537,18446744073709551606UL,0x7.36181Ap-16,0x55DD7CDDL},-7L,-0x3.2p+1,7UL,1L};
    (*l_255) = func_31(l_33);
    if ((l_34.f3 <= (((l_257 != (((l_34.f0 || l_34.f0) <= (l_34.f0 , ((int16_t)((uint16_t)func_74((*l_255), (*l_255)) * (uint16_t)1L) >> (int16_t)l_34.f1))) , l_257)) , 0x41384D2EL) <= l_34.f1)))
    { /* block id: 188 */
        int32_t l_263 = (-1L);
        int32_t *l_262 = &l_263;
        int32_t **l_264 = (void*)0;
        int32_t **l_265 = &l_262;
        struct S2 *l_271 = &l_34;
        uint16_t l_275 = 65535UL;
        float l_277 = 0x0.Cp-1;
        float *l_276 = &l_277;
        (*l_265) = l_262;
        (*l_276) = ((float)((float)(*l_262) / (float)0x6.6p+1) * (float)__builtin_ia32_crc32qi((func_41(l_34.f2, l_270, l_271, (l_34.f1 | ((*l_262) == ((!0L) < ((int16_t)l_34.f2 + (int16_t)(-1L))))), (*l_33)) , l_275), l_34.f2));
    }
    else
    { /* block id: 191 */
        uint16_t l_290 = 0xFDCDL;
        struct S3 l_291 = {153};
        int32_t *l_292 = &l_287;
        int32_t **l_293 = &l_292;
        struct S1 l_294 = {0L,187,0xC5C33FC1L,{0x4.6AC040p+61,4294967295UL,-5L,852,2UL,1758,1UL,0xB.413634p+93,0xE0764ED3L},{-0x1.9p-1,4294967292UL,0L,571,18446744073709551612UL,3390,0x5B3812A1L,-0x1.Bp-1,18446744073709551615UL},0x6DE44C6FL,0x2.780F7Bp-61,7UL,1L};
        (*l_292) = ((l_278 == (void*)0) && ((((((int16_t)__builtin_parityl(l_34.f3) * (int16_t)(((int16_t)((uint16_t)l_287 - (uint16_t)(((uint16_t)(0x7040L & func_47(l_290, (l_34.f0 <= l_34.f2), l_291)) >> (uint16_t)6) == l_290)) << (int16_t)l_291.f0) > (-1L))) >= l_291.f0) ^ l_290) == l_290) | 0xADB1L));
        (*l_293) = &l_287;
        return l_294;
    }
    (*l_295) = (void*)0;
    return l_297;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S2 * func_31(const struct S2 * p_32)
{ /* block id: 37 */
    uint32_t l_51 = 0x8375F08AL;
    struct S2 l_81 = {-3,0,43,0,-210};
    struct S2 *l_80 = &l_81;
    struct S3 l_195 = {219};
    struct S0 l_229 = {0x0.DA6D73p-1,0x6BEF0A75L,0x0527L,615,0x8E152159L,2413,18446744073709551615UL,0xD.383DFEp+74,1UL};
    int32_t l_236 = 0L;
    int32_t *l_235 = &l_236;
    struct S2 **l_251 = &l_80;
    struct S2 *l_252 = &l_81;
    struct S2 *l_253 = (void*)0;
    if (func_35(((func_41(func_47(l_51, (((int16_t)(((int16_t)((int32_t)l_51 % (int32_t)((int32_t)((4294967295UL | func_60(func_64(func_69((l_51 , ((uint32_t)(l_51 && func_74(func_77(l_80, &l_81), func_77(&l_81, &l_81))) + (uint32_t)l_51)), l_81.f0), l_81.f3, l_81.f1, &l_81), &l_81, l_81.f3)) != l_81.f4) - (int32_t)0xB6DB7354L)) << (int16_t)8) != l_81.f1) >> (int16_t)12) != l_81.f2), l_195), l_195, &l_81, l_81.f0, (*l_80)) , 0UL) , &l_81), l_229, &l_81, l_81.f0, &l_81))
    { /* block id: 163 */
        uint16_t l_232 = 0xAE00L;
        int32_t l_234 = (-1L);
        int32_t *l_233 = &l_234;
        int32_t **l_237 = &l_233;
        struct S2 *l_238 = (void*)0;
        (*l_233) = (l_232 <= l_229.f3);
        (*l_237) = l_235;
        if (l_51)
            goto lbl_250;
        (*l_237) = (*l_237);
        return l_238;
    }
    else
    { /* block id: 168 */
        struct S2 **l_239 = (void*)0;
        struct S2 **l_240 = &l_80;
        (*l_240) = p_32;
    }
lbl_250:
    if ((*l_235))
    { /* block id: 171 */
        struct S0 *l_241 = &l_229;
        int32_t *l_242 = &l_236;
        int32_t **l_243 = &l_235;
        struct S2 *l_246 = &l_81;
        l_235 = &l_236;
        (*l_241) = l_229;
        (*l_243) = l_242;
        for (l_229.f4 = 0; (l_229.f4 != 49); l_229.f4 += 7)
        { /* block id: 177 */
            struct S2 *l_247 = (void*)0;
            return l_247;
        }
    }
    else
    { /* block id: 180 */
        struct S3 l_249 = {-144};
        struct S3 *l_248 = &l_249;
        l_248 = &l_195;
    }
    l_229 = l_229;
    (*l_251) = (void*)0;
    return l_253;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_35(struct S2 * const  p_36, struct S0  p_37, struct S2 * p_38, uint16_t  p_39, struct S2 * const  p_40)
{ /* block id: 160 */
    struct S2 *l_231 = (void*)0;
    struct S2 **l_230 = &l_231;
    (*l_230) = (void*)0;
    return p_37.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_41(uint16_t  p_42, struct S3  p_43, struct S2 * p_44, int16_t  p_45, struct S2  p_46)
{ /* block id: 143 */
    float l_212 = 0xC.8862E0p-14;
    float *l_211 = &l_212;
    struct S3 ***l_213 = (void*)0;
    struct S3 ****l_214 = &l_213;
    int32_t l_215 = 0L;
    struct S0 l_224 = {0x7.0p-1,4294967290UL,0xFE98L,1051,0x80ABBFA4L,468,0xF8A4C053L,0x1.6E9918p-27,18446744073709551613UL};
    struct S1 l_228 = {0x9794L,125,0xBFBD02E4L,{0x0.5p-1,0x1D9F5035L,0x5D04L,469,0x5DB38199L,3803,1UL,-0x10.6p+1,0xB0ADA181L},{-0x8.2p-1,0xA26B157EL,0x74C6L,405,0UL,1827,18446744073709551615UL,0x9.E694BAp+22,18446744073709551615UL},2L,0x2.4p-1,0x8C6923B6L,0xD0AE36DBL};
    (*l_211) = p_42;
    (*l_214) = l_213;
    if ((l_215 < l_215))
    { /* block id: 146 */
        struct S1 l_216 = {0x10DEL,88,0x57C2B75BL,{0x2.Cp+1,0x9A101D9BL,0x75CEL,278,0x6C84C521L,1033,0xDAD5565FL,0x3.6FFF55p+19,0x404F5728L},{0x2.F161DFp-91,1UL,0L,1433,0xEF6D558AL,1857,6UL,0x1.8p+1,0x5DD1E5A3L},1L,0xE.7BB388p+19,18446744073709551613UL,-1L};
        return l_216;
    }
    else
    { /* block id: 148 */
        const int32_t *l_219 = &l_215;
        struct S0 l_222 = {0xC.218DD0p-0,0xB34429F3L,0x94ABL,924,0x2EEB0421L,1059,0x5F938C1AL,0xB.C5E4DCp+16,1UL};
        int32_t *l_226 = (void*)0;
        int32_t **l_225 = &l_226;
        struct S2 *l_227 = (void*)0;
        for (p_45 = 11; (p_45 != (-11)); --p_45)
        { /* block id: 151 */
            int32_t *l_221 = &l_215;
            int32_t **l_220 = &l_221;
            struct S0 *l_223 = &l_222;
            (*l_220) = l_219;
            (*l_223) = l_222;
            (*l_223) = l_224;
        }
        (*l_225) = &l_215;
        p_44 = l_227;
    }
    return l_228;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_47(int32_t  p_48, int32_t  p_49, struct S3  p_50)
{ /* block id: 129 */
    float l_198 = 0x1.Bp+1;
    int32_t l_199 = 0xF2295907L;
    int32_t *l_200 = &l_199;
    uint32_t l_206 = 0x10F45062L;
    (*l_200) = ((uint32_t)__builtin_bswap64(p_49) % (uint32_t)l_199);
    for (p_48 = (-2); (p_48 > 29); p_48 += 6)
    { /* block id: 133 */
        struct S0 l_203 = {0xB.D7519Bp-82,0x22D99573L,0x97A5L,879,1UL,2835,18446744073709551615UL,0x2.2C40DFp-36,6UL};
        int32_t l_207 = (-7L);
        if (p_49)
        { /* block id: 134 */
            struct S0 *l_204 = &l_203;
            struct S2 l_205 = {7,4,1709,2,-120};
            (*l_204) = l_203;
            l_207 = (l_205 , (l_206 , (*l_200)));
        }
        else
        { /* block id: 137 */
            struct S3 l_210 = {127};
            struct S3 *l_209 = &l_210;
            struct S3 **l_208 = &l_209;
            l_208 = (p_50 , l_208);
            if ((*l_200))
                continue;
        }
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_60(struct S3  p_61, struct S2 * p_62, uint16_t  p_63)
{ /* block id: 121 */
    uint16_t l_188 = 1UL;
    int32_t l_190 = 0x02645416L;
    int32_t *l_189 = &l_190;
    struct S0 l_193 = {0x5.163CD0p-65,0xED1CDC8FL,0x093CL,487,0x600BE36BL,1226,18446744073709551606UL,-0x1.4p-1,0x30141AF6L};
    (*l_189) = l_188;
    for (p_63 = 29; (p_63 < 22); p_63 -= 1)
    { /* block id: 125 */
        struct S0 *l_194 = &l_193;
        (*l_194) = l_193;
    }
    return p_61.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S3  func_64(struct S2 * p_65, int32_t  p_66, int32_t  p_67, struct S2 * p_68)
{ /* block id: 81 */
    uint32_t l_166 = 4294967295UL;
    int32_t l_181 = 0L;
    const int32_t *l_180 = &l_181;
    const int32_t **l_179 = &l_180;
    const int32_t ***l_178 = &l_179;
    struct S3 l_187 = {200};
    if (p_67)
    { /* block id: 82 */
        int32_t l_151 = (-7L);
        int32_t *l_150 = &l_151;
        struct S0 l_152 = {0x1.0p-1,0xFDF31C3DL,0x0739L,1105,18446744073709551610UL,3779,0xE68C3BF2L,-0x1.Ap-1,0x4DF6C7F8L};
        struct S3 l_155 = {-255};
        struct S3 *l_154 = &l_155;
        struct S3 **l_153 = &l_154;
        (*l_150) = p_66;
        l_152 = l_152;
        (*l_153) = (void*)0;
    }
    else
    { /* block id: 86 */
        const int16_t l_162 = 0L;
        int32_t l_164 = (-7L);
        int32_t *l_163 = &l_164;
        struct S3 l_182 = {8};
        for (p_67 = 0; (p_67 <= 8); ++p_67)
        { /* block id: 89 */
            struct S0 l_169 = {0xF.5F4BB7p-24,4294967295UL,-1L,552,4UL,274,18446744073709551607UL,0xF.354FE0p+1,0xFD3CF241L};
            struct S3 *l_184 = &l_182;
            struct S0 *l_186 = (void*)0;
            struct S0 **l_185 = &l_186;
            if ((p_67 < (((uint16_t)p_67 + (uint16_t)0x05C0L) , ((0xE043946FL <= 0xF4DF6753L) || ((uint16_t)p_66 * (uint16_t)func_74(p_65, func_69(l_162, p_67)))))))
            { /* block id: 90 */
                int32_t **l_165 = &l_163;
                (*l_165) = l_163;
                if (p_66)
                    break;
                if (l_166)
                    continue;
            }
            else
            { /* block id: 94 */
                struct S0 l_167 = {0xA.57F1B4p-53,4294967291UL,0x8762L,146,0UL,3156,18446744073709551613UL,0x1.Bp+1,0xEB109393L};
                struct S0 *l_168 = (void*)0;
                l_169 = l_167;
                if ((-(int32_t)p_67))
                { /* block id: 96 */
                    struct S0 *l_173 = &l_169;
                    const int32_t *l_177 = &l_164;
                    const int32_t **l_176 = &l_177;
                    const int32_t ***l_175 = &l_176;
                    for (l_169.f8 = 11; (l_169.f8 > 29); l_169.f8 += 6)
                    { /* block id: 99 */
                        struct S0 **l_174 = &l_173;
                        (*l_163) = l_167.f1;
                        (*l_174) = l_173;
                        l_178 = l_175;
                        if (p_66)
                            break;
                    }
                }
                else
                { /* block id: 105 */
                    return l_182;
                }
                if ((!((void*)0 != l_184)))
                { /* block id: 108 */
                    (*l_179) = (*l_179);
                }
                else
                { /* block id: 110 */
                    if (p_67)
                        break;
                    return l_182;
                }
            }
            (*l_185) = (void*)0;
        }
        (*l_163) = (**l_179);
    }
    p_66 = (*l_180);
    return l_187;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S2 * func_69(const int16_t  p_70, uint32_t  p_71)
{ /* block id: 73 */
    struct S0 l_137 = {0x4.29C1E9p+54,0x419D3951L,0L,313,0UL,783,18446744073709551615UL,0xC.BCEAF5p+67,1UL};
    struct S0 *l_138 = &l_137;
    struct S2 l_140 = {-1,1,1190,0,90};
    struct S2 *l_139 = &l_140;
    struct S2 *l_141 = &l_140;
    struct S2 *l_142 = &l_140;
    struct S2 *l_143 = &l_140;
    struct S2 *l_144 = &l_140;
    struct S2 *l_145 = &l_140;
    struct S2 *l_146 = &l_140;
    struct S2 *l_147 = &l_140;
    struct S2 *l_148 = &l_140;
    struct S2 *l_149 = (void*)0;
    for (p_71 = 0; (p_71 > 57); p_71 += 1)
    { /* block id: 76 */
        const struct S0 *l_133 = (void*)0;
        struct S0 l_136 = {-0x9.Bp+1,0x79D1BA22L,-1L,683,0UL,1124,0xC2FE74D0L,0x2.D5FEEAp+64,0x331A3B0DL};
        struct S0 *l_135 = &l_136;
        struct S0 **l_134 = &l_135;
        (*l_134) = l_133;
    }
    (*l_138) = l_137;
    return l_149;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_74(struct S2 * p_75, struct S2 * p_76)
{ /* block id: 68 */
    struct S0 l_127 = {0x4.7p-1,0x2F195638L,1L,888,0x422DCD2DL,3484,0UL,-0x5.1p+1,0x105C8CF0L};
    struct S0 *l_128 = &l_127;
    const struct S0 **l_129 = (void*)0;
    struct S0 **l_130 = &l_128;
    (*l_128) = l_127;
    (*l_130) = &l_127;
    (**l_130) = (l_127.f5 , (*l_128));
    return l_127.f8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S2 * func_77(struct S2 * p_78, const struct S2 * p_79)
{ /* block id: 38 */
    int32_t l_83 = (-9L);
    int32_t *l_82 = &l_83;
    struct S1 l_88 = {0x8B85L,54,0xA4DCBD99L,{0x0.A08098p-84,0x1431463DL,5L,1188,0x14255FA7L,3487,1UL,0x0.9p-1,0UL},{-0x5.4p+1,1UL,0x4120L,779,0xA556116AL,3755,1UL,0x3.2C5A17p-79,0x03748AADL},1L,0x7.D3A0D6p-51,18446744073709551615UL,6L};
lbl_95:
    l_82 = (void*)0;
    for (l_83 = 29; (l_83 <= 26); l_83 -= 8)
    { /* block id: 42 */
        int32_t l_86 = 0x85BB29A1L;
        uint16_t l_87 = 0xB5BCL;
        if (((l_86 ^ l_87) > ((*p_79) , ((((l_87 , (l_88 , (-(uint16_t)l_88.f4.f2))) , l_86) < (l_86 > (((int32_t)((l_87 != l_86) ^ l_87) + (int32_t)l_88.f5) == l_87))) ^ 0x6A3DL))))
        { /* block id: 43 */
            struct S0 l_92 = {0xC.7D7DB6p+26,0xC429AA74L,1L,1410,1UL,3794,0x2BC438EEL,0xA.3B9E22p-99,18446744073709551606UL};
            struct S1 *l_94 = &l_88;
            struct S1 **l_93 = &l_94;
            l_92 = l_92;
            (*l_93) = &l_88;
            return p_78;
        }
        else
        { /* block id: 47 */
            if (l_88.f4.f6)
                goto lbl_95;
            if (l_87)
                continue;
        }
    }
    for (l_88.f4.f1 = 0; (l_88.f4.f1 <= 13); ++l_88.f4.f1)
    { /* block id: 54 */
        float l_100 = 0x8.07BB3Ep-12;
        int32_t l_101 = (-1L);
        uint16_t l_119 = 65532UL;
        if (((l_88.f3.f8 && ((uint32_t)((l_101 , (l_101 | l_101)) >= (-(uint32_t)(l_88.f3.f6 || (((((int32_t)((uint16_t)0xC948L * (uint16_t)((int16_t)0x8794L >> (int16_t)9)) % (int32_t)(((int16_t)(((uint16_t)(l_101 ^ (((int32_t)((int32_t)l_101 - (int32_t)0xB6355D27L) + (int32_t)l_101) >= l_88.f3.f8)) * (uint16_t)l_101) , l_101) / (int16_t)l_119) , l_119)) ^ l_119) & l_101) != l_101)))) / (uint32_t)(-1L))) <= l_119))
        { /* block id: 55 */
            uint32_t l_123 = 0x0DBC4827L;
            float *l_124 = &l_88.f4.f7;
            for (l_119 = 0; (l_119 <= 10); l_119 += 4)
            { /* block id: 58 */
                int32_t **l_122 = &l_82;
                (*l_122) = &l_83;
            }
            (*l_124) = __builtin_ctzl((__builtin_ctzl(l_123) ^ l_123));
            return p_78;
        }
        else
        { /* block id: 63 */
            struct S0 l_125 = {0xA.569DADp+15,4294967289UL,6L,1326,0x52D19C51L,1920,18446744073709551613UL,0xE.7702E8p+21,0xD0841373L};
            struct S0 *l_126 = &l_125;
            (*l_126) = l_125;
        }
    }
    return p_78;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 64
   depth: 1, occurrence: 18
   depth: 2, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 4
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 50
breakdown:
   indirect level: 0, occurrence: 23
   indirect level: 1, occurrence: 24
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 1
XXX full-bitfields structs in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX times a bitfields struct's address is taken: 42
XXX times a bitfields struct on LHS: 4
XXX times a bitfields struct on RHS: 46
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 28

XXX max expression depth: 42
breakdown:
   depth: 1, occurrence: 127
   depth: 2, occurrence: 16
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 19, occurrence: 1
   depth: 22, occurrence: 1
   depth: 42, occurrence: 1

XXX total number of pointers: 105

XXX times a variable address is taken: 90
XXX times a pointer is dereferenced on RHS: 15
breakdown:
   depth: 1, occurrence: 14
   depth: 2, occurrence: 1
XXX times a pointer is dereferenced on LHS: 41
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 61

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 72
   level: 2, occurrence: 4
   level: 3, occurrence: 1
XXX number of pointers point to pointers: 33
XXX number of pointers point to scalars: 18
XXX number of pointers point to structs: 54
XXX percent of pointers has null in alias set: 26.7
XXX average alias set size: 1.12

XXX times a non-volatile is read: 240
XXX times a non-volatile is write: 105
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 30
   depth: 2, occurrence: 19
   depth: 3, occurrence: 7
   depth: 4, occurrence: 5
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 20.8
XXX percentage an existing variable is used: 79.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

