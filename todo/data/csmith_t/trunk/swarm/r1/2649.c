/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2924228656
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 4294967291U;
static int32_t g_57 = 0x9628EAF6;
static int32_t g_99 = 1;
static int32_t g_101 = 0;
static int32_t g_104 = 0;
static int32_t *g_103 = &g_104;
static int16_t g_131 = (-1);
static volatile int32_t g_224 = (-1);/* VOLATILE GLOBAL g_224 */
static volatile int32_t *g_223 = &g_224;
static volatile int32_t **g_222 = &g_223;
static volatile int32_t ***g_221 = &g_222;
static int32_t *g_291 = &g_104;
static int32_t g_293 = 0x26B157E5;
static int16_t g_340 = 0x60C5;
static int32_t g_402 = 0x81449091;
static int32_t *g_401 = &g_402;


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_27(void);
static int32_t * func_28(int32_t * p_29, uint32_t  p_30, int32_t * p_31);
static int32_t * func_32(int32_t  p_33, uint32_t  p_34, int32_t * p_35);
static int16_t  func_38(int16_t  p_39, const int32_t  p_40, int16_t  p_41, uint16_t  p_42, uint16_t  p_43);
static int32_t  func_48(uint32_t  p_49, int32_t  p_50, uint16_t  p_51, uint16_t  p_52, int32_t * p_53);
static int32_t  func_59(int32_t * p_60, const int16_t  p_61, int32_t * p_62);
static int32_t * func_63(int32_t * p_64, const int16_t  p_65, int32_t * p_66, uint32_t  p_67, int32_t * p_68);
static int32_t * func_69(int32_t  p_70, int32_t * p_71, uint32_t  p_72, int32_t * p_73);
static int16_t  func_74(int32_t * p_75, const int32_t * p_76, uint32_t  p_77, int32_t * p_78, int16_t  p_79);
static int32_t * func_80(int32_t * p_81, uint32_t  p_82, int32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_57 g_99 g_101 g_103 g_104 g_131 g_224 g_291 g_221 g_222 g_223 g_340 g_293 g_401 g_402
 * writes: g_57 g_101 g_104 g_103 g_99 g_131 g_291 g_224 g_293 g_222 g_223 g_402
 */
static uint16_t  func_27(void)
{ /* block id: 36 */
    int16_t l_44 = (-1);
    int32_t *l_56 = &g_57;
    const int16_t l_58 = 0;
    int16_t l_421 = 0x4816;
    const int32_t *l_422 = &g_402;
    const uint32_t l_423 = 6U;
    l_56 = func_28(func_32(g_5, (safe_rshift_func_int16_t_s_u(func_38((l_44 != ((safe_rshift_func_int16_t_s_u((-7), ((!(1U | ((l_44 == __builtin_parity(l_44)) > func_48(g_5, (safe_sub_func_uint16_t_u_u(__builtin_popcountl(l_44), l_44)), g_5, l_44, l_56)))) & l_44))) | l_44)), l_58, g_5, l_58, l_58), g_293)), &g_293), g_5, g_401);
    /* statement id: 288 */
    assert (l_56 == &g_402);
    assert (g_103 == &g_293 || g_103 == &g_104 || g_103 == &g_57 || g_103 == &g_101);
    assert (g_291 == &g_101 || g_291 == &g_293 || g_291 == &g_57);
    (*l_56) = (0x0419 | ((safe_sub_func_uint16_t_u_u((safe_add_func_uint32_t_u_u(g_101, 5U)), ((safe_sub_func_uint16_t_u_u(1U, (safe_rshift_func_uint16_t_u_s(((-6) < 0x62C7), 2)))) & 0))) & (*l_56)));
    (*g_223) = (safe_mod_func_int16_t_s_s(((-6) != (func_74(&g_293, &g_101, (safe_sub_func_int16_t_s_s((safe_mod_func_int32_t_s_s(l_421, 0x843F403E)), ((void*)0 != l_422))), l_56, (*l_56)) <= l_423)), (*l_56)));
    return (*l_422);
}


/* ------------------------------------------ */
/* 
 * reads : g_402 g_221 g_222 g_223
 * writes: g_103 g_224
 */
static int32_t * func_28(int32_t * p_29, uint32_t  p_30, int32_t * p_31)
{ /* block id: 280 */
    int32_t *l_405 = &g_104;
    for (p_30 = 0; (p_30 <= 55); p_30 = safe_add_func_int32_t_s_s(p_30, 9))
    { /* block id: 283 */
        int32_t **l_406 = &g_103;
        (*l_406) = l_405;
        /* statement id: 284 */
        assert (g_103 == &g_104);
        (***g_221) = (*p_31);
    }
    return &g_402;
    /* statement id: 287 */
    //assert (func_28_rv == &g_402);
}


/* ------------------------------------------ */
/* 
 * reads : g_221 g_222 g_223 g_224 g_5 g_101 g_131 g_57 g_103 g_104 g_99 g_293 g_291 g_340
 * writes: g_224 g_293 g_104 g_57 g_101 g_103 g_99 g_131 g_291 g_222 g_223
 */
static int32_t * func_32(int32_t  p_33, uint32_t  p_34, int32_t * p_35)
{ /* block id: 229 */
    int32_t l_341 = (-2);
    int32_t ****l_343 = (void*)0;
    int32_t *****l_342 = &l_343;
    const int32_t *****l_344 = (void*)0;
    uint32_t l_345 = 1U;
    int32_t ***l_352 = (void*)0;
    int32_t ****l_351 = &l_352;
    int16_t l_369 = (-1);
    int32_t *l_400 = (void*)0;
    (***g_221) = l_341;
    (***g_221) = (g_224 == (l_342 != l_344));
    (*p_35) = (p_33 == p_34);
    if (__builtin_bswap32(l_345))
    { /* block id: 233 */
        int16_t l_347 = 4;
        int32_t *l_348 = &g_101;
        int32_t **l_395 = &g_103;
        int32_t ***l_394 = &l_395;
        if ((~g_101))
        { /* block id: 234 */
            uint32_t l_368 = 0x6ECBC03D;
            if (l_347)
            { /* block id: 235 */
                int32_t l_353 = 0x8D93EB98;
                int32_t **l_354 = &g_291;
                (*l_354) = func_63(l_348, g_131, func_69(p_33, func_69((safe_lshift_func_int16_t_s_s(0xB8C4, (l_351 != &g_221))), &g_57, l_353, &g_57), g_131, &g_293), l_353, &g_293);
                /* statement id: 236 */
                assert (g_103 == &g_293 || g_103 == &g_104 || g_103 == &g_57 || g_103 == &g_101);
                assert (g_291 == &g_293 || g_291 == &g_57);
                if (l_341)
                    goto lbl_385;
            }
            else
            { /* block id: 237 */
                uint16_t l_360 = 1U;
                int32_t ****l_367 = &l_352;
                (*p_35) = ((***g_221) <= (((!((safe_add_func_uint32_t_u_u((((&l_348 != (*g_221)) < (__builtin_clzl((safe_rshift_func_int16_t_s_s(l_360, 15))) & (safe_sub_func_uint16_t_u_u(g_131, ((safe_add_func_uint32_t_u_u(((*l_348) == (l_360 & (safe_lshift_func_uint16_t_u_s((l_367 == &g_221), 1)))), p_34)) != l_368))))) ^ 65529U), 0x96C2EF98)) & (*p_35))) & (*g_291)) > g_293));
                (*g_223) = (***g_221);
            }
            /* facts after branching */
            assert (g_103 == &g_293 || g_103 == &g_104 || g_103 == &g_57 || g_103 == &g_101);
            assert (g_291 == &g_101 || g_291 == &g_293 || g_291 == &g_57);
        }
        else
        { /* block id: 241 */
            int32_t l_371 = 5;
            if (l_369)
            { /* block id: 242 */
                const int32_t l_370 = (-1);
                (*g_221) = (*g_221);
                (**g_222) = l_371;
            }
            else
            { /* block id: 245 */
                uint32_t l_384 = 1U;
                (***g_221) = (safe_add_func_int32_t_s_s((safe_add_func_uint32_t_u_u(g_104, (*g_291))), (safe_rshift_func_int16_t_s_u(0x0574, ((*g_103) == ((__builtin_clzl((*l_348)) >= (safe_rshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_u((-8), g_340)), 11))) == ((((safe_rshift_func_uint16_t_u_s(((*p_35) <= 0x482958C2), 9)) >= l_384) >= 0) != 1)))))));
                return &g_104;
                /* statement id: 247 */
                //assert (func_32_rv == &g_104);
            }
        }
        /* facts after branching */
        assert (g_103 == &g_293 || g_103 == &g_104 || g_103 == &g_57 || g_103 == &g_101);
        assert (g_291 == &g_101 || g_291 == &g_293 || g_291 == &g_57);
lbl_385:
        (*g_291) = (*l_348);
        for (l_345 = 0; (l_345 >= 21); l_345 = safe_add_func_uint32_t_u_u(l_345, 2))
        { /* block id: 254 */
            uint16_t l_388 = 0x2113;
            int32_t **l_392 = &l_348;
            int32_t ***l_391 = &l_392;
            (*p_35) = l_388;
            for (g_99 = (-9); (g_99 <= (-19)); g_99 = safe_sub_func_int16_t_s_s(g_99, 9))
            { /* block id: 258 */
                int32_t *****l_399 = (void*)0;
                (***g_221) = (*l_348);
                if ((*g_223))
                { /* block id: 260 */
                    uint32_t l_396 = 0x1AFC6B86;
                    if ((((((p_34 || (((void*)0 == l_391) & (~(l_396 >= (((g_104 & 0x94FC5A9C) && 0) != 6))))) >= 0xD14B2B6D) != (***g_221)) >= g_104) || 2U))
                    { /* block id: 261 */
                        return &g_104;
                        /* statement id: 262 */
                        //assert (func_32_rv == &g_104);
                    }
                    else
                    { /* block id: 263 */
                        (**g_222) = (g_293 && 7);
                        (**g_221) = (*g_222);
                        return &g_57;
                        /* statement id: 266 */
                        //assert (func_32_rv == &g_57);
                    }
                }
                else
                { /* block id: 268 */
                    (**g_222) = (&l_394 != &l_394);
                }
                (*p_35) = (safe_mod_func_int16_t_s_s(p_34, g_293));
                l_399 = (void*)0;
            }
            if ((*p_35))
                continue;
        }
    }
    else
    { /* block id: 276 */
        (*g_222) = (*g_222);
    }
    /* facts after branching */
    assert (g_103 == &g_293 || g_103 == &g_104 || g_103 == &g_57 || g_103 == &g_101);
    assert (g_291 == &g_101 || g_291 == &g_293 || g_291 == &g_57);
    return l_400;
    /* statement id: 279 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_57 g_99 g_101 g_103 g_104 g_131 g_224 g_291 g_221 g_222 g_223 g_340
 * writes: g_57 g_101 g_104 g_103 g_99 g_131 g_291 g_224
 */
static int16_t  func_38(int16_t  p_39, const int32_t  p_40, int16_t  p_41, uint16_t  p_42, uint16_t  p_43)
{ /* block id: 40 */
    uint16_t l_98 = 0x8622;
    int32_t *l_100 = &g_101;
    int32_t ***l_332 = (void*)0;
    int32_t ****l_331 = &l_332;
    int32_t *****l_330 = &l_331;
    int32_t *l_336 = &g_293;
    int32_t **l_338 = (void*)0;
    int32_t ***l_337 = &l_338;
    int32_t *l_339 = (void*)0;
    (*l_100) = (g_5 <= func_59(func_63(func_69(((((void*)0 != &g_57) ^ func_74(func_80(&g_57, func_48(((safe_sub_func_int32_t_s_s((safe_sub_func_int16_t_s_s(((func_48(((0U | (safe_mod_func_uint16_t_u_u(0U, (safe_rshift_func_int16_t_s_u(__builtin_ctzl(p_39), 10))))) > (safe_add_func_uint32_t_u_u((safe_add_func_int32_t_s_s((safe_sub_func_int16_t_s_s(l_98, l_98)), l_98)), g_5))), g_5, p_40, l_98, &g_57) || p_42) | g_5), g_99)), l_98)) || p_43), p_43, p_40, g_5, l_100), g_99), l_100, g_5, l_100, g_5)) < 4294967295U), g_103, p_41, l_100), p_41, l_100, p_42, l_100), p_41, l_100));
    /* statement id: 225 */
    assert (g_103 == &g_104 || g_103 == &g_57 || g_103 == &g_101);
    assert (g_291 == &g_101);
    l_330 = l_330;
    (**g_222) = (safe_lshift_func_uint16_t_u_u((p_42 | ((((((((!((((**g_222) || (0x511B0AF7 ^ g_340)) | (-1)) && 0x90436ECE)) == (*g_103)) < p_40) != (-1)) & p_43) | 4294967292U) == p_39) >= 0x7F09)), 4));
    return g_340;
}


/* ------------------------------------------ */
/* 
 * reads : g_57 g_101
 * writes: g_57 g_101
 */
static int32_t  func_48(uint32_t  p_49, int32_t  p_50, uint16_t  p_51, uint16_t  p_52, int32_t * p_53)
{ /* block id: 37 */
    (*p_53) = (-1);
    return (*p_53);
}


/* ------------------------------------------ */
/* 
 * reads : g_224 g_104 g_131 g_5 g_57 g_291 g_99 g_101 g_221 g_222 g_223
 * writes: g_57 g_101 g_291 g_131
 */
static int32_t  func_59(int32_t * p_60, const int16_t  p_61, int32_t * p_62)
{ /* block id: 213 */
    int32_t **l_325 = (void*)0;
    int32_t ***l_324 = &l_325;
    int32_t ****l_323 = &l_324;
    int32_t *****l_326 = &l_323;
    (*l_326) = l_323;
    g_291 = func_80(func_80(p_62, g_224, ((func_74(func_80(p_62, ((g_104 < (p_60 != (void*)0)) != func_48(g_131, p_61, p_61, g_5, &g_57)), (*g_291)), &g_104, p_61, p_62, g_104) & g_99) >= p_61)), g_131, (*g_291));
    /* statement id: 215 */
    assert (g_291 == &g_101);
    for (g_131 = 0; (g_131 > (-8)); g_131 = safe_sub_func_int32_t_s_s(g_131, 9))
    { /* block id: 218 */
        int32_t l_329 = 0xB1ACB9F7;
        if (l_329)
            break;
        if ((***g_221))
            break;
        if (l_329)
            continue;
        return l_329;
    }
    return (***g_221);
}


/* ------------------------------------------ */
/* 
 * reads : g_57 g_103 g_5 g_104 g_99 g_101 g_131
 * writes: g_104 g_101 g_57 g_103 g_99 g_131 g_293
 */
static int32_t * func_63(int32_t * p_64, const int16_t  p_65, int32_t * p_66, uint32_t  p_67, int32_t * p_68)
{ /* block id: 49 */
    int16_t l_105 = 0x0222;
    int32_t *l_109 = &g_57;
    int16_t l_156 = 0xC21B;
    int32_t l_169 = (-4);
    int16_t l_258 = 1;
    int32_t **l_289 = &l_109;
    int32_t *l_309 = &g_293;
    if (l_105)
    { /* block id: 50 */
        const int32_t *l_108 = &g_104;
        (*p_68) = (safe_lshift_func_int16_t_s_u(((func_74(&g_104, l_108, ((void*)0 == p_64), p_66, (&g_104 != l_109)) != g_57) == g_57), (*l_109)));
    }
    else
    { /* block id: 52 */
        int32_t l_110 = 0x1D26016E;
        int32_t *l_120 = &g_101;
        (*g_103) = l_110;
        if (l_105)
            goto lbl_116;
lbl_116:
        for (g_57 = (-26); (g_57 == (-26)); g_57 = safe_add_func_uint32_t_u_u(g_57, 1))
        { /* block id: 56 */
            int32_t **l_113 = (void*)0;
            int32_t **l_114 = (void*)0;
            int32_t **l_115 = &g_103;
            (*p_64) = (g_5 && 0xCC4390AC);
            (*l_115) = &g_57;
            /* statement id: 58 */
            assert (g_103 == &g_57);
            return &g_57;
            /* statement id: 59 */
            //assert (func_63_rv == &g_57);
        }
        (*p_64) = func_74(l_109, func_80(&g_57, p_65, (((safe_unary_minus_func_int32_t_s(0x0EC92890)) | (safe_rshift_func_uint16_t_u_u(__builtin_clzll((l_120 != l_120)), 11))) && (((safe_mod_func_int32_t_s_s((safe_unary_minus_func_int16_t_s((safe_add_func_uint16_t_u_u((~p_65), __builtin_parityl(((g_104 ^ (*l_109)) != 3)))))), g_57)) <= g_57) ^ p_67))), g_5, p_64, g_104);
    }
    (*l_109) = 1;
    for (g_99 = 0; (g_99 <= 22); g_99 = safe_add_func_uint16_t_u_u(g_99, 1))
    { /* block id: 67 */
        uint32_t l_136 = 0x7EB87603;
        int32_t l_155 = 1;
        uint32_t l_165 = 0xBBC66260;
        int32_t **l_231 = &g_103;
        int32_t l_247 = (-9);
        int16_t l_255 = 0;
        int32_t *l_267 = (void*)0;
        if (((((safe_mod_func_uint32_t_u_u(__builtin_parity(g_131), (*g_103))) ^ (safe_mod_func_uint16_t_u_u((~g_104), (safe_unary_minus_func_int32_t_s((-4)))))) < (((*l_109) || g_5) >= (l_136 | 0xA0BD))) == g_57))
        { /* block id: 68 */
            int32_t l_141 = 7;
            uint32_t l_154 = 4294967295U;
            for (l_136 = (-23); (l_136 >= 31); ++l_136)
            { /* block id: 71 */
                (*p_66) = ((safe_add_func_int16_t_s_s(l_141, (safe_lshift_func_uint16_t_u_u((&g_104 != (void*)0), (((safe_sub_func_int16_t_s_s((p_64 != l_109), (g_101 ^ ((l_136 == (p_67 > l_141)) != g_99)))) && g_101) && (*g_103)))))) & p_65);
                return &g_57;
                /* statement id: 73 */
                //assert (func_63_rv == &g_57);
            }
            for (g_131 = 0; (g_131 == (-15)); g_131 = safe_sub_func_int16_t_s_s(g_131, 7))
            { /* block id: 77 */
                (*g_103) = ((1 || (~((safe_rshift_func_int16_t_s_u(g_57, (*l_109))) & (((void*)0 == &p_66) >= (~(l_141 == 1U)))))) ^ (((((g_57 ^ (safe_sub_func_int16_t_s_s((p_67 != l_136), 0U))) || (*g_103)) | l_154) || p_67) == (*l_109)));
            }
        }
        else
        { /* block id: 80 */
            uint32_t l_161 = 0x63DC2C33;
            int32_t **l_162 = &l_109;
            (*p_64) = (*p_64);
            (*g_103) = (*p_64);
            (*l_162) = func_69(g_101, &g_57, ((g_99 < (l_155 && (l_156 && (l_109 != &g_57)))) >= ((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(p_65, g_131)), g_101)) || l_161)), &g_104);
            /* statement id: 83 */
            assert (l_109 == &g_101);
        }
    }
    /* facts after for loop */
    assert (l_109 == &g_101 || l_109 == &g_57);
    g_103 = p_68;
    /* statement id: 211 */
    assert (g_103 == &g_101 || g_103 == &g_293);
    return p_68;
    /* statement id: 212 */
    //assert (func_63_rv == &g_101 || func_63_rv == &g_293);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int32_t  p_70, int32_t * p_71, uint32_t  p_72, int32_t * p_73)
{ /* block id: 47 */
    return &g_101;
    /* statement id: 48 */
    //assert (func_69_rv == &g_101);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_101 g_104 g_57 g_293
 */
static int16_t  func_74(int32_t * p_75, const int32_t * p_76, uint32_t  p_77, int32_t * p_78, int16_t  p_79)
{ /* block id: 44 */
    (*p_75) = 0x709715B7;
    return p_77;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_99 g_101
 * writes: g_101 g_57 g_104
 */
static int32_t * func_80(int32_t * p_81, uint32_t  p_82, int32_t  p_83)
{ /* block id: 41 */
    int32_t l_102 = 0xB35ED357;
    (*p_81) = (p_83 & (func_48(__builtin_popcountl((((void*)0 != &p_83) | 1U)), g_99, g_101, l_102, &g_101) < 1U));
    return &g_101;
    /* statement id: 43 */
    //assert (func_80_rv == &g_101);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_57, "g_57", print_hash_value);
    transparent_crc(g_99, "g_99", print_hash_value);
    transparent_crc(g_101, "g_101", print_hash_value);
    transparent_crc(g_104, "g_104", print_hash_value);
    transparent_crc(g_131, "g_131", print_hash_value);
    transparent_crc(g_224, "g_224", print_hash_value);
    transparent_crc(g_293, "g_293", print_hash_value);
    transparent_crc(g_340, "g_340", print_hash_value);
    transparent_crc(g_402, "g_402", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 95
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 48
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 14
   depth: 3, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 48, occurrence: 1

XXX total number of pointers: 83

XXX times a variable address is taken: 116
XXX times a pointer is dereferenced on RHS: 119
breakdown:
   depth: 1, occurrence: 95
   depth: 2, occurrence: 19
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 83
breakdown:
   depth: 1, occurrence: 65
   depth: 2, occurrence: 10
   depth: 3, occurrence: 8
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 12
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 332

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 361
   level: 2, occurrence: 31
   level: 3, occurrence: 23
   level: 4, occurrence: 8
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 41
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.7
XXX average alias set size: 1.42

XXX times a non-volatile is read: 643
XXX times a non-volatile is write: 194
XXX times a volatile is read: 18
XXX    times read thru a pointer: 11
XXX times a volatile is write: 19
XXX    times written thru a pointer: 19
XXX times a volatile is available for access: 62
XXX percentage of non-volatile access: 95.8

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 81
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 16
   depth: 2, occurrence: 13
   depth: 3, occurrence: 15
   depth: 4, occurrence: 2
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 14.7
XXX percentage an existing variable is used: 85.3
********************* end of statistics **********************/

