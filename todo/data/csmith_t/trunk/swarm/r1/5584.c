/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1476860876
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 20;
   unsigned f1 : 25;
   volatile unsigned f2 : 23;
   unsigned f3 : 7;
   volatile int32_t  f4;
   volatile uint32_t  f5;
   signed f6 : 21;
   volatile signed f7 : 26;
   volatile signed f8 : 3;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = 6L;
static int32_t g_73 = (-10L);
static int32_t **g_91 = (void*)0;
static volatile struct S0 g_93[10] = {{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1},{-87,663,996,10,0x79D740F4L,4294967290UL,1383,3010,-1}};
static volatile struct S0 *g_92 = &g_93[9];
static int32_t g_97 = 0xECCDF337L;
static float g_103[4][6] = {{0xA.3C4023p+54,0x7.376920p-65,(-0x1.7p-1),(-0x1.7p-1),0x7.376920p-65,0xA.3C4023p+54},{0x5.BD055Dp+27,0xA.3C4023p+54,(-0x1.7p-1),0xA.3C4023p+54,0x5.BD055Dp+27,0x5.BD055Dp+27},{0x1.EEEF66p+80,0xA.3C4023p+54,0xA.3C4023p+54,0x1.EEEF66p+80,0x7.376920p-65,0x1.EEEF66p+80},{0x1.EEEF66p+80,0x7.376920p-65,0x1.EEEF66p+80,0xA.3C4023p+54,0xA.3C4023p+54,0x1.EEEF66p+80}};
static struct S0 g_109 = {4,3469,988,7,0x19DAAC0CL,0xA660014BL,1225,3635,1};/* VOLATILE GLOBAL g_109 */
static uint16_t g_140 = 0x7237L;
static int32_t g_163[4][1][1] = {{{1L}},{{1L}},{{1L}},{{1L}}};
static volatile struct S0 **g_250 = &g_92;
static volatile struct S0 ***g_249[6][7][4] = {{{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250}},{{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250}},{{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250}},{{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250}},{{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250}},{{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250},{&g_250,&g_250,&g_250,&g_250}}};
static int32_t *g_271 = &g_163[2][0][0];
static int32_t *g_300 = &g_5;
static struct S0 g_306[5][7][1] = {{{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{186,2784,1689,10,0xABDC0804L,0x0A983902L,917,8167,1}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}}},{{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{186,2784,1689,10,0xABDC0804L,0x0A983902L,917,8167,1}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}}},{{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{186,2784,1689,10,0xABDC0804L,0x0A983902L,917,8167,1}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}}},{{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{186,2784,1689,10,0xABDC0804L,0x0A983902L,917,8167,1}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}}},{{{-755,4722,2827,9,1L,0x950CD63CL,-296,-1395,-1}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{-579,5083,2088,4,0xA39968E0L,0x4FD85A1BL,-1266,-447,1}},{{-654,4338,1379,0,0xA23E02C3L,0x5D0388B1L,-1197,-4106,-0}},{{917,1549,2800,0,0xCD6CE9E9L,0x2AF1B3B3L,471,-5330,-0}},{{186,2784,1689,10,0xABDC0804L,0x0A983902L,917,8167,1}},{{-538,3213,480,7,0x3DFD6F59L,0x46947678L,261,6558,1}}}};
static struct S0 g_308 = {849,2655,2761,9,0x85E9CE2AL,4294967295UL,-1433,472,-1};/* VOLATILE GLOBAL g_308 */
static float g_346 = (-0x10.Ep+1);
static struct S0 g_354 = {-742,1677,2724,5,0xF397B278L,0x9F81DC6FL,-1275,-6591,-1};/* VOLATILE GLOBAL g_354 */
static int32_t ***g_367 = &g_91;
static int32_t ****g_366 = &g_367;
static int32_t *g_368 = &g_97;
static volatile struct S0 g_373 = {305,316,1841,10,0xA23490A3L,4294967290UL,1039,5036,-0};/* VOLATILE GLOBAL g_373 */
static volatile uint8_t g_386 = 0UL;/* VOLATILE GLOBAL g_386 */
static volatile int32_t g_390 = (-1L);/* VOLATILE GLOBAL g_390 */
static volatile int32_t *g_389 = &g_390;
static volatile struct S0 *****g_400 = (void*)0;
static volatile float g_408 = 0x7.Ep-1;/* VOLATILE GLOBAL g_408 */
static volatile float *g_407 = &g_408;
static volatile float **g_406 = &g_407;
static volatile float ***g_405 = &g_406;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_25(void);
inline static struct S0  func_26(int16_t  p_27, int32_t  p_28, int32_t  p_29, int32_t  p_30);
inline static int32_t * func_32(int32_t  p_33, int32_t  p_34, int32_t  p_35, uint16_t  p_36, int32_t * p_37);
static int32_t  func_44(int32_t * p_45);
inline static int32_t * func_46(int32_t * p_47, uint16_t  p_48, uint16_t  p_49);
inline static int32_t * func_50(int32_t * p_51, int32_t * p_52, uint32_t  p_53, int32_t * p_54);
static int32_t * func_56(uint32_t  p_57);
static int16_t  func_59(uint32_t  p_60, int32_t * p_61, uint8_t  p_62, int32_t * p_63);
inline static int32_t * func_65(uint32_t  p_66, int32_t  p_67, int32_t * p_68);
inline static uint16_t  func_78(uint8_t  p_79, int32_t  p_80, uint16_t  p_81, uint32_t  p_82, int32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_73 g_91 g_92 g_93.f0 g_109.f4 g_109.f0 g_109.f3 g_93.f1 g_97 g_109.f6 g_103 g_109.f1 g_93.f5 g_140 g_93 g_109.f8 g_109.f5 g_163 g_249 g_306.f0 g_366 g_368 g_109.f7 g_373 g_306.f1 g_386 g_389 g_367 g_390 g_400 g_300 g_405
 * writes: g_73 g_97 g_103 g_109 g_140 g_93.f0 g_163 g_271 g_368 g_93 g_300 g_389 g_91 g_390 g_400
 */
inline static uint32_t  func_25(void)
{ /* block id: 36 */
    uint32_t l_31 = 18446744073709551615UL;
    int32_t *l_419 = (void*)0;
    (*g_92) = func_26(l_31, g_5, g_5, ((l_31 < g_5) <= g_5));
    /* statement id: 359 */
    assert (g_91 == 0 || g_91 == &g_271);
    //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling || g_271 == &g_73);
    l_419 = l_419;
    return g_373.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_73 g_91 g_92 g_93.f0 g_109.f4 g_109.f0 g_109.f3 g_93.f1 g_97 g_109.f6 g_103 g_109.f1 g_93.f5 g_140 g_93 g_109.f8 g_109.f5 g_163 g_249 g_306.f0 g_366 g_368 g_109.f7 g_373 g_306.f1 g_386 g_389 g_367 g_390 g_400 g_300 g_405
 * writes: g_73 g_97 g_103 g_109 g_140 g_93.f0 g_163 g_271 g_368 g_93 g_300 g_389 g_91 g_390 g_400
 */
inline static struct S0  func_26(int16_t  p_27, int32_t  p_28, int32_t  p_29, int32_t  p_30)
{ /* block id: 37 */
    int32_t *l_40 = &g_5;
    int32_t l_41 = 0x579DEB47L;
    int32_t *l_402 = &g_97;
    int32_t ***l_411 = &g_91;
    uint16_t l_412 = 65535UL;
    float *l_417 = &g_103[3][2];
    float **l_416 = &l_417;
    int32_t **l_418 = &g_368;
    l_402 = func_32((p_30 != (((int16_t)((void*)0 != l_40) >> (int16_t)14) == (g_5 & (l_41 == ((int16_t)g_5 << (int16_t)0))))), p_28, func_44(func_46(&g_5, p_29, p_30)), p_28, l_40);
    /* statement id: 356 */
    assert (g_91 == 0 || g_91 == &g_271);
    //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling || g_271 == &g_73);
    assert (g_368 == 0 || g_368 == &g_97 || g_368 == &g_5 || (g_368 >= &g_163[0][0][0] && g_368 <= &g_163[3][0][0]));
    (*l_418) = func_32(((0xBCA930C2L ^ (g_405 != (void*)0)) & (*l_402)), ((uint32_t)((void*)0 != l_411) * (uint32_t)((0x58BECFD6L >= l_412) > ((uint16_t)(~(l_416 != &l_417)) << (uint16_t)10))), p_30, p_29, l_40);
    /* statement id: 357 */
    assert (g_368 == &g_97);
    return (*g_92);
}


/* ------------------------------------------ */
/* 
 * reads : g_400 g_300 g_5
 * writes: g_400
 */
inline static int32_t * func_32(int32_t  p_33, int32_t  p_34, int32_t  p_35, uint16_t  p_36, int32_t * p_37)
{ /* block id: 347 */
    int16_t l_399 = 0x9BC3L;
    int32_t *l_401 = &g_97;
    for (p_36 = 0; (p_36 <= 33); p_36 += 9)
    { /* block id: 350 */
        if (l_399)
            break;
        g_400 = g_400;
        if ((*g_300))
            continue;
    }
    return l_401;
    /* statement id: 355 */
    //assert (func_32_rv == &g_97);
}


/* ------------------------------------------ */
/* 
 * reads : g_140 g_5 g_306.f1 g_386 g_389 g_367 g_73 g_366 g_91 g_97 g_390
 * writes: g_140 g_271 g_389 g_91 g_73 g_390 g_97
 */
static int32_t  func_44(int32_t * p_45)
{ /* block id: 314 */
    int16_t l_385 = 0x80B6L;
    int32_t *l_387 = &g_73;
    for (g_140 = 0; (g_140 <= 3); g_140 += 1)
    { /* block id: 317 */
        float ***l_377 = (void*)0;
        int32_t l_384 = (-9L);
        int32_t ****l_396 = &g_367;
        if (((((*p_45) != ((void*)0 == l_377)) ^ ((uint16_t)65526UL << (uint16_t)((int32_t)(1L && (((((((65528UL >= ((uint16_t)l_384 + (uint16_t)((l_385 || (g_306[2][4][0].f1 && l_385)) == l_385))) > 0x1A78L) < 0x14CE7F40L) <= 0UL) > g_386) ^ 0x4052L) > l_385)) - (int32_t)l_384))) >= (*p_45)))
        { /* block id: 318 */
            int32_t **l_388 = &g_271;
            volatile int32_t **l_391 = &g_389;
            p_45 = (void*)0;
            /* statement id: 319 */
            assert (p_45 == 0);
            (*l_388) = l_387;
            /* statement id: 320 */
            assert (g_271 == &g_73);
            (*l_391) = g_389;
            (*g_367) = l_388;
            /* statement id: 322 */
            assert (g_91 == &g_271);
        }
        else
        { /* block id: 323 */
            int32_t ****l_392 = &g_367;
            int32_t *****l_393 = (void*)0;
            int32_t *****l_394 = (void*)0;
            int32_t *****l_395[2][6] = {{&l_392,&l_392,&l_392,&l_392,&l_392,&l_392},{&l_392,&l_392,&l_392,&l_392,&l_392,&l_392}};
            int i, j;
            l_396 = l_392;
            for (g_73 = 3; (g_73 >= 0); g_73 -= 1)
            { /* block id: 327 */
                p_45 = p_45;
                (*g_389) = (&l_387 != (**g_366));
                for (l_384 = 0; (l_384 <= 9); l_384 += 1)
                { /* block id: 332 */
                    for (g_97 = 9; (g_97 >= 0); g_97 -= 1)
                    { /* block id: 335 */
                        (*g_389) = 1L;
                        if ((*p_45))
                            continue;
                        if ((*p_45))
                            break;
                    }
                }
            }
            if ((*g_389))
                continue;
        }
        /* facts after branching */
        assert (g_91 == 0 || g_91 == &g_271);
        //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling || g_271 == &g_73);
        assert (p_45 == &g_5 || p_45 == 0);
        return (*l_387);
    }
    return (*p_45);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_73 g_91 g_92 g_93.f0 g_109.f4 g_109.f0 g_109.f3 g_93.f1 g_97 g_109.f6 g_103 g_109.f1 g_93.f5 g_140 g_93 g_109.f8 g_109.f5 g_163 g_249 g_306.f0 g_366 g_368 g_109.f7 g_373
 * writes: g_73 g_97 g_103 g_109 g_140 g_93.f0 g_163 g_271 g_368 g_93 g_300
 */
inline static int32_t * func_46(int32_t * p_47, uint16_t  p_48, uint16_t  p_49)
{ /* block id: 38 */
    if (((0xE3C8D3FDL ^ (p_47 == (void*)0)) == ((void*)0 == &g_5)))
    { /* block id: 39 */
        int32_t *l_55 = &g_5;
        if (((*p_47) | 4294967286UL))
        { /* block id: 40 */
            int32_t **l_370 = &g_368;
            (*l_370) = func_50(&g_5, l_55, g_5, &g_5);
            /* statement id: 300 */
            //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling);
            assert (g_368 == &g_5 || g_368 == &g_97 || (g_368 >= &g_163[0][0][0] && g_368 <= &g_163[3][0][0]));
        }
        else
        { /* block id: 301 */
            return p_47;
            /* statement id: 302 */
            //assert (func_46_rv == &g_5);
        }
        /* facts after branching */
        //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling);
        assert (g_368 == &g_5 || g_368 == &g_97 || (g_368 >= &g_163[0][0][0] && g_368 <= &g_163[3][0][0]));
    }
    else
    { /* block id: 304 */
        int32_t **l_374 = &g_300;
        for (p_48 = 0; (p_48 != 13); p_48 += 1)
        { /* block id: 307 */
            g_368 = (void*)0;
            /* statement id: 308 */
            assert (g_368 == 0);
        }
        /* facts after for loop */
        assert (g_368 == 0 || g_368 == &g_97);
        (*g_92) = g_373;
        (*l_374) = p_47;
    }
    /* facts after branching */
    //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling);
    assert (g_368 == 0 || g_368 == &g_97 || g_368 == &g_5 || (g_368 >= &g_163[0][0][0] && g_368 <= &g_163[3][0][0]));
    return p_47;
    /* statement id: 313 */
    //assert (func_46_rv == &g_5);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_73 g_91 g_92 g_93.f0 g_109.f4 g_109.f0 g_109.f3 g_93.f1 g_97 g_109.f6 g_103 g_109.f1 g_93.f5 g_140 g_93 g_109.f8 g_109.f5 g_163 g_249 g_306.f0 g_366 g_368 g_109.f7
 * writes: g_73 g_97 g_103 g_109 g_140 g_93.f0 g_163 g_271
 */
inline static int32_t * func_50(int32_t * p_51, int32_t * p_52, uint32_t  p_53, int32_t * p_54)
{ /* block id: 41 */
    uint8_t l_64 = 0x68L;
    int32_t *l_369 = &g_163[1][0][0];
    l_369 = func_56(((~func_59(l_64, &g_5, g_5, func_65(p_53, (*p_51), p_51))) >= ((uint16_t)(__builtin_ffsll(p_53) < (-1L)) + (uint16_t)0x6287L)));
    /* statement id: 297 */
    //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling);
    assert (l_369 == &g_5 || l_369 == &g_97 || (l_369 >= &g_163[0][0][0] && l_369 <= &g_163[3][0][0]));
    l_369 = l_369;
    return l_369;
    /* statement id: 299 */
    //assert (func_50_rv == &g_5 || func_50_rv == &g_97 || (func_50_rv >= &g_163[0][0][0] && func_50_rv <= &g_163[3][0][0]));
}


/* ------------------------------------------ */
/* 
 * reads : g_73 g_5 g_91 g_92 g_93.f0 g_109.f4 g_109.f0 g_109.f3 g_93.f1 g_97 g_109.f6 g_103 g_109.f1 g_93.f5 g_140 g_93 g_109.f8 g_109.f5 g_163 g_249 g_306.f0 g_366 g_368 g_109.f7
 * writes: g_73 g_97 g_103 g_109 g_140 g_93.f0 g_163 g_271
 */
static int32_t * func_56(uint32_t  p_57)
{ /* block id: 46 */
    int16_t l_72[9] = {6L,0x57A8L,6L,0x57A8L,6L,0x57A8L,6L,0x57A8L,6L};
    int32_t *l_90 = &g_5;
    int32_t **l_89 = &l_90;
    struct S0 **l_98 = (void*)0;
    float l_113 = 0x8.7FF9E3p-44;
    int32_t l_205 = 8L;
    struct S0 ***l_303[4];
    struct S0 ****l_302 = &l_303[2];
    float *l_365 = &l_113;
    int i;
    for (i = 0; i < 4; i++)
        l_303[i] = &l_98;
    for (p_57 = 0; (p_57 <= 8); p_57 += 1)
    { /* block id: 49 */
        int32_t *l_99 = (void*)0;
        uint32_t l_107 = 0x61D2E80BL;
        uint32_t l_156 = 0x72F47A7AL;
        uint8_t l_173 = 255UL;
        struct S0 *l_203[9] = {&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109};
        struct S0 **l_202 = &l_203[4];
        int i;
        for (g_73 = 0; (g_73 <= 8); g_73 += 1)
        { /* block id: 52 */
            int32_t *l_75 = &g_5;
            int32_t **l_74 = &l_75;
            int32_t *l_96 = &g_97;
            int i;
            (*l_74) = (void*)0;
            /* statement id: 53 */
            assert (l_75 == 0);
            (*l_96) = (l_72[g_73] || ((uint16_t)65530UL * (uint16_t)__builtin_bswap64(((func_78(p_57, g_73, (~g_5), ((uint16_t)p_57 >> (uint16_t)13), (((int16_t)4L + (int16_t)((l_89 != g_91) != p_57)) <= p_57)) >= p_57) ^ 6L))));
            (*l_89) = (*l_89);
            l_99 = func_65(g_93[9].f0, (l_98 == &g_92), l_99);
            /* statement id: 59 */
            assert (l_99 == &g_5);
        }
        /* facts after for loop */
        assert (l_99 == &g_5 || l_99 == 0);
        for (g_73 = 0; (g_73 <= 8); g_73 += 1)
        { /* block id: 63 */
            int32_t *l_104 = (void*)0;
            struct S0 *l_108 = &g_109;
            int32_t l_136 = 0x418A4649L;
            uint32_t l_161 = 6UL;
            int32_t *l_162 = &g_163[1][0][0];
            int i;
            if (((uint16_t)(l_72[p_57] || 4294967293UL) << (uint16_t)p_57))
            { /* block id: 64 */
                float *l_102 = &g_103[3][1];
                int32_t l_110 = (-5L);
                struct S0 *l_114 = (void*)0;
                (*l_102) = p_57;
                (*l_89) = l_104;
                /* statement id: 66 */
                assert (l_90 == 0);
                if (((uint16_t)func_78(l_107, g_73, ((void*)0 != l_108), l_110, (func_59(((uint32_t)func_78(__builtin_parity(p_57), (g_109.f4 ^ l_110), g_109.f0, p_57, p_57) % (uint32_t)p_57), l_104, g_109.f3, &g_5) == 8UL)) << (uint16_t)4))
                { /* block id: 67 */
                    struct S0 **l_115 = (void*)0;
                    struct S0 **l_116[2][10] = {{&l_114,&l_114,&l_114,&l_114,&l_114,&l_114,&l_114,&l_114,&l_114,&l_114},{&l_108,&l_114,&l_108,&l_114,&l_108,&l_114,&l_108,&l_114,&l_108,&l_114}};
                    int i, j;
                    l_108 = l_114;
                    /* statement id: 68 */
                    assert (l_108 == 0);
                }
                else
                { /* block id: 69 */
                    uint32_t l_126 = 1UL;
                    g_103[3][1] = (((float)g_93[9].f1 + (float)(0x3.BF5080p-79 == (0x1.851ED0p-79 == ((float)((((float)(g_97 != 0x0.4249AAp-49) - (float)((g_73 < g_109.f6) < (((!((float)0x1.9p+1 * (float)((__builtin_parityll(g_73) <= g_103[3][1]) == 0x0.0p+1))) <= 0x0.4p-1) != p_57))) < l_110) < l_126) + (float)0x4.179A93p-37)))) == 0x1.6D41FCp-52);
                    for (l_126 = 3; (l_126 <= 8); l_126 += 1)
                    { /* block id: 73 */
                        (*l_89) = (void*)0;
                    }
                }
                /* facts after branching */
                assert (l_108 == &g_109 || l_108 == 0);
            }
            else
            { /* block id: 77 */
                uint32_t l_127 = 0xB292015BL;
                for (l_107 = 0; (l_107 <= 8); l_107 += 1)
                { /* block id: 80 */
                    int i;
                    l_127 = (l_72[p_57] != g_109.f1);
                }
                for (l_127 = 0; (l_127 <= 8); l_127 += 1)
                { /* block id: 85 */
                    int16_t l_138 = 0x46B1L;
                    if ((((((uint16_t)((((uint16_t)(&l_104 == g_91) * (uint16_t)((void*)0 == l_98)) ^ ((int16_t)l_127 >> (int16_t)3)) <= (~((-(uint16_t)((p_57 & (((-10L) || g_97) != 0xF175425EL)) == p_57)) != l_136))) << (uint16_t)7) > g_109.f3) == g_73) | g_93[9].f5))
                    { /* block id: 86 */
                        int32_t *l_137 = &g_97;
                        return l_137;
                        /* statement id: 87 */
                        //assert (func_56_rv == &g_97);
                    }
                    else
                    { /* block id: 88 */
                        uint8_t l_141 = 0x25L;
                        float *l_142 = &l_113;
                        (*l_142) = ((((g_93[9].f1 > ((l_138 == (((p_57 > (func_78((-(uint16_t)1UL), __builtin_ctzll(p_57), g_140, g_5, p_57) < 0xE.EC1B3Ep-72)) < 0x9.16DB7Cp-97) > l_141)) >= p_57)) > 0x0.2773D6p+5) < p_57) > g_109.f0);
                        (*l_89) = &g_97;
                        /* statement id: 90 */
                        assert (l_90 == &g_97);
                        return &g_5;
                        /* statement id: 91 */
                        //assert (func_56_rv == &g_5);
                    }
                }
                (*l_108) = (*g_92);
                if (g_140)
                    continue;
            }
            /* facts after branching */
            assert (l_108 == &g_109 || l_108 == 0);
            if (p_57)
            { /* block id: 97 */
                uint8_t l_143 = 0xEAL;
                (*l_89) = func_65(g_109.f8, func_78(l_143, (func_59(g_109.f0, func_65((((g_140 | ((g_97 & ((uint16_t)(((uint16_t)g_5 * (uint16_t)__builtin_popcount(__builtin_ctzl(g_109.f3))) > p_57) * (uint16_t)g_109.f1)) < 65535UL)) | (-1L)) != g_109.f6), l_143, l_99), g_5, &g_97) >= g_140), l_143, l_143, g_5), l_99);
                /* statement id: 98 */
                assert (l_90 == &g_5);
            }
            else
            { /* block id: 99 */
                if (p_57)
                    break;
            }
            if ((((l_104 == l_99) > ((uint16_t)g_109.f5 * (uint16_t)((int16_t)1L % (int16_t)((int16_t)((int16_t)l_156 << (int16_t)((-(uint32_t)l_107) | 0L)) + (int16_t)0xE344L)))) || g_140))
            { /* block id: 102 */
                int32_t *l_174 = (void*)0;
                for (l_136 = 5; (l_136 >= 0); l_136 -= 1)
                { /* block id: 105 */
                    float *l_159 = &g_103[3][0];
                    int32_t l_160 = 5L;
                    for (l_156 = 3; (l_156 <= 8); l_156 += 1)
                    { /* block id: 108 */
                        float *l_158 = &g_103[1][2];
                        int i;
                        (*l_158) = l_72[g_73];
                        l_160 = (l_159 == (void*)0);
                        if (l_72[l_156])
                            continue;
                        if (l_161)
                            break;
                    }
                    for (g_97 = 0; (g_97 <= 3); g_97 += 1)
                    { /* block id: 116 */
                        int32_t *l_172 = (void*)0;
                        l_162 = &l_160;
                        /* statement id: 117 */
                        assert (l_162 == &l_160);
                        (*l_162) = (((uint32_t)(((uint16_t)((int16_t)g_163[1][0][0] >> (int16_t)g_109.f4) << (uint16_t)g_109.f1) >= ((g_140 != ((int16_t)func_59(g_109.f6, &l_160, (((func_59(p_57, (*l_89), (l_172 == (void*)0), &g_73) <= g_97) <= g_109.f1) ^ 0x294BL), &l_136) * (int16_t)g_109.f1)) ^ l_173)) - (uint32_t)g_163[1][0][0]) <= 0x5B3C0A78L);
                        (*l_162) = 0L;
                        l_174 = (*l_89);
                    }
                    /* facts after for loop */
                    //assert (l_162 == &l_160 || l_162 == dangling || (l_162 >= &g_163[0][0][0] && l_162 <= &g_163[3][0][0]));
                    if (p_57)
                        continue;
                    //assert (l_162 == dangling || (l_162 >= &g_163[0][0][0] && l_162 <= &g_163[3][0][0]));
                }
                /* facts after for loop */
                //assert (l_162 == dangling || (l_162 >= &g_163[0][0][0] && l_162 <= &g_163[3][0][0]));
                assert (l_174 == &g_5 || l_174 == 0);
                (*l_89) = l_99;
            }
            else
            { /* block id: 125 */
                uint32_t l_194[2][8][7] = {{{4294967295UL,4294967295UL,0x6079C38AL,0x8E2EF629L,3UL,4294967295UL,4294967295UL},{8UL,4294967295UL,0UL,0x0B664D11L,3UL,1UL,8UL},{8UL,4294967295UL,0x6079C38AL,0x0B664D11L,0x6079C38AL,4294967295UL,8UL},{4294967295UL,4294967295UL,0x6079C38AL,0x8E2EF629L,3UL,4294967295UL,4294967295UL},{8UL,4294967295UL,0UL,0x0B664D11L,3UL,1UL,8UL},{8UL,4294967295UL,0x6079C38AL,0x0B664D11L,0x6079C38AL,4294967295UL,8UL},{4294967295UL,4294967295UL,0x6079C38AL,0x8E2EF629L,3UL,4294967295UL,4294967295UL},{8UL,4294967295UL,0UL,0x0B664D11L,3UL,1UL,8UL}},{{8UL,4294967295UL,0x6079C38AL,0x0B664D11L,0x6079C38AL,4294967295UL,8UL},{4294967295UL,4294967295UL,0x6079C38AL,0x8E2EF629L,3UL,4294967295UL,4294967295UL},{8UL,4294967295UL,0UL,0x0B664D11L,3UL,1UL,8UL},{8UL,4294967295UL,0x6079C38AL,0x0B664D11L,0x6079C38AL,4294967295UL,8UL},{4294967295UL,4294967295UL,0x6079C38AL,0x8E2EF629L,3UL,4294967295UL,4294967295UL},{8UL,4294967295UL,0UL,0x0B664D11L,3UL,1UL,8UL},{8UL,4294967295UL,0x6079C38AL,0x0B664D11L,0x6079C38AL,4294967295UL,8UL},{4294967295UL,4294967295UL,0x6079C38AL,0x8E2EF629L,3UL,4294967295UL,4294967295UL}}};
                struct S0 **l_204 = &l_203[6];
                int i, j, k;
                for (l_161 = 0; (l_161 <= 3); l_161 += 1)
                { /* block id: 128 */
                    int32_t l_190 = 1L;
                    for (g_140 = 0; (g_140 <= 8); g_140 += 1)
                    { /* block id: 131 */
                        int32_t l_191 = 0x50B4F93AL;
                        int i, j;
                        if (p_57)
                            break;
                        g_103[l_161][(l_161 + 1)] = (!((func_59((((int32_t)((int32_t)(((uint16_t)0x952AL >> (uint16_t)((&g_93[p_57] != &g_93[4]) <= (g_109.f8 >= p_57))) && ((int16_t)(-7L) << (int16_t)7)) - (int32_t)((uint16_t)((int16_t)g_109.f3 * (int16_t)(p_57 || p_57)) >> (uint16_t)g_109.f6)) + (int32_t)0x0CF9BFE5L) >= g_109.f3), &l_136, p_57, &g_5) >= 0x2.2D24EAp+99) != (-0x1.7p+1)));
                        if (g_93[9].f7)
                            continue;
                        g_93[p_57].f0 = ((uint16_t)(l_190 ^ (g_93[9].f6 | p_57)) - (uint16_t)l_191);
                    }
                    if (((g_93[9].f7 >= (p_57 == ((uint16_t)l_194[1][1][6] * (uint16_t)p_57))) <= ((int16_t)(((((uint16_t)((((-2L) || (p_57 ^ __builtin_parity((__builtin_bswap32(l_190) <= ((int16_t)(0x660CL >= l_194[0][7][2]) << (int16_t)p_57))))) || p_57) | 0x749A3EB6L) % (uint16_t)g_109.f0) | (*l_162)) <= g_73) ^ p_57) << (int16_t)p_57)))
                    { /* block id: 137 */
                        (*l_89) = l_99;
                    }
                    else
                    { /* block id: 139 */
                        struct S0 ***l_201[6][3][8] = {{{&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,(void*)0},{&l_98,&l_98,(void*)0,&l_98,(void*)0,(void*)0,(void*)0,(void*)0},{&l_98,(void*)0,(void*)0,&l_98,&l_98,&l_98,(void*)0,(void*)0}},{{&l_98,(void*)0,&l_98,&l_98,&l_98,&l_98,&l_98,(void*)0},{&l_98,(void*)0,&l_98,&l_98,(void*)0,&l_98,&l_98,&l_98},{&l_98,&l_98,&l_98,(void*)0,&l_98,&l_98,&l_98,&l_98}},{{&l_98,(void*)0,(void*)0,&l_98,&l_98,&l_98,&l_98,&l_98},{&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,(void*)0,&l_98},{&l_98,&l_98,&l_98,(void*)0,&l_98,&l_98,&l_98,&l_98}},{{&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,(void*)0,(void*)0},{&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98},{&l_98,&l_98,&l_98,(void*)0,&l_98,&l_98,(void*)0,&l_98}},{{&l_98,&l_98,&l_98,&l_98,(void*)0,&l_98,&l_98,&l_98},{&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98},{&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98}},{{(void*)0,(void*)0,&l_98,(void*)0,&l_98,&l_98,&l_98,&l_98},{&l_98,(void*)0,&l_98,&l_98,&l_98,&l_98,&l_98,(void*)0},{(void*)0,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98,&l_98}}};
                        int i, j, k;
                        l_202 = (void*)0;
                        /* statement id: 140 */
                        assert (l_202 == 0);
                    }
                }
                (*l_162) = (p_57 <= (&g_92 == l_204));
            }
            /* facts after branching */
            //assert (l_162 == dangling || (l_162 >= &g_163[0][0][0] && l_162 <= &g_163[3][0][0]));
        }
        /* facts after for loop */
        assert (l_202 == 0 || (l_202 >= &l_203[0] && l_202 <= &l_203[8]));
    }
    /* facts after for loop */
    assert (l_90 == &g_5 || l_90 == 0);
    if ((((g_97 > 0x8E0CL) | p_57) != g_93[9].f5))
    { /* block id: 147 */
        struct S0 *l_207 = &g_109;
        struct S0 **l_206 = &l_207;
        uint32_t l_220 = 0UL;
        float *l_229 = &l_113;
        int32_t l_234 = (-1L);
        uint16_t l_270 = 0x2CBAL;
        for (g_140 = 0; (g_140 <= 0); g_140 += 1)
        { /* block id: 150 */
            uint32_t l_235 = 1UL;
            int32_t *l_245[10][9][2] = {{{&g_97,&g_97},{(void*)0,&g_97},{&g_97,(void*)0},{&g_5,&g_97},{&g_5,&g_5},{&g_73,&g_73},{&g_97,&g_73},{&g_163[1][0][0],&g_5},{(void*)0,&g_97}},{{&g_97,(void*)0},{&g_97,&g_5},{(void*)0,(void*)0},{&g_5,&g_97},{(void*)0,&g_97},{&g_163[1][0][0],(void*)0},{&g_97,&g_97},{&g_73,&g_97},{(void*)0,(void*)0}},{{&g_73,(void*)0},{(void*)0,&g_73},{(void*)0,(void*)0},{(void*)0,&g_73},{(void*)0,(void*)0},{&g_73,(void*)0},{(void*)0,&g_97},{&g_73,&g_97},{&g_97,(void*)0}},{{&g_163[1][0][0],&g_97},{(void*)0,&g_97},{&g_5,(void*)0},{(void*)0,&g_5},{&g_97,(void*)0},{&g_97,&g_97},{(void*)0,&g_5},{&g_163[1][0][0],&g_73},{&g_97,&g_5}},{{&g_73,(void*)0},{&g_97,&g_73},{(void*)0,&g_163[2][0][0]},{(void*)0,(void*)0},{&g_73,(void*)0},{(void*)0,&g_163[2][0][0]},{(void*)0,&g_73},{&g_97,(void*)0},{&g_73,&g_5}},{{(void*)0,&g_73},{&g_73,&g_97},{(void*)0,&l_205},{(void*)0,(void*)0},{&l_205,(void*)0},{&g_163[1][0][0],&g_163[1][0][0]},{(void*)0,(void*)0},{&g_163[2][0][0],(void*)0},{(void*)0,&g_163[1][0][0]}},{{(void*)0,(void*)0},{(void*)0,&g_73},{&g_163[1][0][0],&g_163[3][0][0]},{&g_73,(void*)0},{&g_163[1][0][0],&g_73},{(void*)0,&g_5},{(void*)0,&g_73},{&g_163[1][0][0],(void*)0},{&g_73,&g_163[3][0][0]}},{{&g_163[1][0][0],&g_73},{(void*)0,(void*)0},{(void*)0,&g_163[1][0][0]},{(void*)0,(void*)0},{&g_163[2][0][0],(void*)0},{(void*)0,&g_163[1][0][0]},{&g_163[1][0][0],(void*)0},{&l_205,(void*)0},{(void*)0,&l_205}},{{(void*)0,&g_97},{&g_73,&g_73},{(void*)0,&g_5},{&g_73,(void*)0},{&g_97,&g_73},{(void*)0,&g_163[2][0][0]},{(void*)0,(void*)0},{&g_73,(void*)0},{(void*)0,&g_163[2][0][0]}},{{(void*)0,&g_73},{&g_97,(void*)0},{&g_73,&g_5},{(void*)0,&g_73},{&g_73,&g_97},{(void*)0,&l_205},{(void*)0,(void*)0},{&l_205,(void*)0},{&g_163[1][0][0],&g_163[1][0][0]}}};
            int32_t *l_246[3][4][8] = {{{&g_163[3][0][0],&g_73,&l_205,&g_73,&g_163[3][0][0],(void*)0,&g_163[3][0][0],&g_73},{&l_205,&g_73,&l_205,(void*)0,&g_163[3][0][0],(void*)0,&l_205,&g_73},{&g_163[3][0][0],(void*)0,&l_205,&g_73,&l_205,(void*)0,&g_163[3][0][0],(void*)0},{&g_163[3][0][0],&g_73,&l_205,&g_73,&g_163[3][0][0],(void*)0,&g_163[3][0][0],&g_73}},{{&l_205,&g_73,&l_205,(void*)0,&g_163[3][0][0],(void*)0,&l_205,&g_73},{&g_163[3][0][0],(void*)0,&l_205,&g_73,&l_205,(void*)0,&g_163[3][0][0],(void*)0},{&g_163[3][0][0],&g_73,&l_205,&g_73,&g_163[3][0][0],(void*)0,&g_163[3][0][0],&g_73},{&l_205,&g_73,&l_205,(void*)0,&g_163[3][0][0],(void*)0,&l_205,&g_73}},{{&g_163[3][0][0],(void*)0,&l_205,&g_73,&l_205,(void*)0,&g_163[3][0][0],(void*)0},{&g_163[3][0][0],&g_73,&l_205,&g_73,&g_163[3][0][0],(void*)0,&g_163[3][0][0],&g_73},{&l_205,&g_73,&l_205,(void*)0,&l_205,(void*)0,&l_205,(void*)0},{&l_205,(void*)0,&l_205,(void*)0,&l_205,(void*)0,&l_205,(void*)0}}};
            struct S0 **l_255[3];
            int i, j, k;
            for (i = 0; i < 3; i++)
                l_255[i] = &l_207;
            l_205 = p_57;
            l_206 = l_206;
            for (p_57 = 0; (p_57 <= 0); p_57 += 1)
            { /* block id: 155 */
                uint8_t l_211 = 0UL;
                int32_t *l_221 = &g_163[1][0][0];
                struct S0 **l_243[7] = {&l_207,&l_207,&l_207,&l_207,&l_207,&l_207,&l_207};
                uint32_t l_269 = 0x87CFA903L;
                int i;
                (*l_221) = (~(((((uint32_t)l_211 - (uint32_t)__builtin_bswap64(g_109.f4)) < 0x487F1438L) > ((uint16_t)((__builtin_ctz(((((l_211 || ((void*)0 != l_98)) || ((uint16_t)((uint16_t)(g_5 > ((uint16_t)p_57 * (uint16_t)p_57)) << (uint16_t)5) - (uint16_t)g_163[1][0][0])) | 0x9E9FL) ^ 65535UL)) < l_220) ^ g_109.f3) >> (uint16_t)g_5)) || p_57));
                for (g_73 = 0; (g_73 >= 0); g_73 -= 1)
                { /* block id: 159 */
                    float *l_228 = &l_113;
                    int32_t **l_256 = &l_90;
                    int i, j, k;
                    g_163[g_140][g_140][g_140] = ((int16_t)((int16_t)(((((int16_t)0xACBAL * (int16_t)(__builtin_ffsll(((l_228 == l_229) && func_78(g_163[(g_73 + 2)][g_73][p_57], g_163[(g_140 + 1)][g_140][g_73], (*l_221), g_140, ((int16_t)(65532UL || ((uint16_t)(__builtin_ffsl(l_234) ^ 0UL) % (uint16_t)g_163[(g_140 + 1)][g_140][g_73])) % (int16_t)0x9F8FL)))) | p_57)) | g_93[9].f5) | p_57) || l_235) % (int16_t)(*l_221)) * (int16_t)p_57);
                    if (p_57)
                    { /* block id: 161 */
                        uint8_t l_244 = 0xE5L;
                        (*l_89) = (void*)0;
                        /* statement id: 162 */
                        assert (l_90 == 0);
                        (*l_221) = ((uint16_t)g_93[9].f8 + (uint16_t)(~((p_57 ^ ((func_78(g_109.f0, p_57, p_57, l_220, (g_109.f1 != (p_57 | ((int16_t)((uint32_t)(l_243[4] != &l_207) % (uint32_t)l_244) + (int16_t)l_244)))) > 0x091DL) < (-4L))) <= g_109.f0)));
                        (*l_89) = l_245[9][4][0];
                        /* statement id: 164 */
                        assert (l_90 == &g_97 || l_90 == &l_205 || l_90 == &g_73 || l_90 == 0 || (l_90 >= &g_163[0][0][0] && l_90 <= &g_163[3][0][0]) || l_90 == &g_5);
                        (*l_89) = l_246[2][1][2];
                    }
                    else
                    { /* block id: 166 */
                        g_163[(g_140 + 1)][g_140][g_73] = ((uint16_t)func_78((__builtin_parityll(l_234) != func_59(p_57, func_65(l_220, l_220, l_245[1][6][1]), p_57, l_221)), g_93[9].f1, p_57, p_57, g_97) >> (uint16_t)6);
                        return &g_97;
                        /* statement id: 168 */
                        //assert (func_56_rv == &g_97);
                    }
                    if (l_220)
                    { /* block id: 170 */
                        if (g_109.f0)
                            break;
                        (*l_221) = ((void*)0 != g_249[0][4][2]);
                        (*l_221) = 0x04161D74L;
                    }
                    else
                    { /* block id: 174 */
                        (*l_228) = ((float)g_163[(g_140 + 1)][g_140][g_73] - (float)((float)0x4.F59FADp-5 + (float)(l_255[1] == (void*)0)));
                    }
                    if (((&l_246[2][1][2] == l_256) & ((int16_t)((uint16_t)0xFED7L >> (uint16_t)__builtin_bswap32(g_163[1][0][0])) << (int16_t)l_220)))
                    { /* block id: 177 */
                        int32_t *l_261 = &g_163[(g_140 + 1)][g_140][g_73];
                        (*l_89) = (*l_256);
                        return l_261;
                        /* statement id: 179 */
                        //assert ((func_56_rv >= &g_163[0][0][0] && func_56_rv <= &g_163[3][0][0]));
                    }
                    else
                    { /* block id: 180 */
                        int32_t *l_262 = &g_73;
                        int i;
                        (*l_89) = func_65(p_57, p_57, l_262);
                        /* statement id: 181 */
                        assert (l_90 == &g_5);
                        (*l_256) = func_65((*l_221), func_78(((l_234 && p_57) <= (4294967295UL == ((uint16_t)p_57 >> (uint16_t)((uint32_t)(((((uint32_t)__builtin_popcountl(func_59(g_93[9].f4, l_246[2][3][4], (&g_93[(g_140 + 2)] == &g_93[(p_57 + 1)]), l_229)) - (uint32_t)g_73) != 0UL) != (**l_89)) & g_109.f3) % (uint32_t)l_269)))), g_163[1][0][0], g_163[0][0][0], p_57, p_57), l_221);
                        if ((*l_262))
                            continue;
                        if (l_270)
                            break;
                    }
                    /* facts after branching */
                    assert (l_90 == &g_5);
                }
            }
        }
        /* facts after for loop */
        assert (l_90 == &g_97 || l_90 == &l_205 || l_90 == &g_73 || l_90 == 0 || (l_90 >= &g_163[0][0][0] && l_90 <= &g_163[3][0][0]) || l_90 == &g_5);
        g_271 = l_229;
        /* statement id: 189 */
        assert (g_271 == &l_113);
        (*l_89) = &g_163[1][0][0];
        /* statement id: 190 */
        assert ((l_90 >= &g_163[0][0][0] && l_90 <= &g_163[3][0][0]));
        (*l_89) = func_65((*l_90), (*l_90), (*l_89));
        /* statement id: 191 */
        assert (l_90 == &g_5);
    }
    else
    { /* block id: 192 */
        int32_t *l_291 = (void*)0;
        int32_t l_292 = 1L;
        int32_t *l_362[3];
        int i;
        for (i = 0; i < 3; i++)
            l_362[i] = &g_163[1][0][0];
        for (p_57 = 0; (p_57 <= 0); p_57 += 1)
        { /* block id: 195 */
            float *l_276 = &g_103[2][3];
            int32_t l_279 = 0x607C4CD5L;
            int32_t ***l_339 = &l_89;
            struct S0 *l_355 = (void*)0;
        }
        for (l_292 = (-2); (l_292 <= 12); l_292 += 8)
        { /* block id: 291 */
            return l_362[1];
            /* statement id: 292 */
            //assert ((func_56_rv >= &g_163[0][0][0] && func_56_rv <= &g_163[3][0][0]));
        }
    }
    /* facts after branching */
    assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == &l_113);
    (*l_89) = func_65(g_306[2][4][0].f0, (((uint16_t)(((void*)0 != l_365) <= ((void*)0 != g_366)) * (uint16_t)(func_59(g_5, (*l_89), g_109.f0, g_368) != g_109.f7)) | 4294967291UL), (*l_89));
    /* statement id: 295 */
    assert (l_90 == &g_5);
    return &g_163[2][0][0];
    /* statement id: 296 */
    //assert ((g_271 >= &g_163[0][0][0] && g_271 <= &g_163[3][0][0]) || g_271 == dangling);
    //assert ((func_56_rv >= &g_163[0][0][0] && func_56_rv <= &g_163[3][0][0]));
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes:
 */
static int16_t  func_59(uint32_t  p_60, int32_t * p_61, uint8_t  p_62, int32_t * p_63)
{ /* block id: 44 */
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_65(uint32_t  p_66, int32_t  p_67, int32_t * p_68)
{ /* block id: 42 */
    int32_t *l_69 = &g_5;
    return l_69;
    /* statement id: 43 */
    //assert (func_65_rv == &g_5);
}


/* ------------------------------------------ */
/* 
 * reads : g_92
 * writes:
 */
inline static uint16_t  func_78(uint8_t  p_79, int32_t  p_80, uint16_t  p_81, uint32_t  p_82, int32_t  p_83)
{ /* block id: 54 */
    volatile struct S0 **l_94 = (void*)0;
    volatile struct S0 *l_95 = (void*)0;
    l_95 = g_92;
    /* statement id: 55 */
    assert ((l_95 >= &g_93[0] && l_95 <= &g_93[9]));
    return p_79;
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_73, "g_73", print_hash_value);
    for (i = 0; i < 10; i++)
    {
        transparent_crc(g_93[i].f0, "g_93[i].f0", print_hash_value);
        transparent_crc(g_93[i].f1, "g_93[i].f1", print_hash_value);
        transparent_crc(g_93[i].f2, "g_93[i].f2", print_hash_value);
        transparent_crc(g_93[i].f3, "g_93[i].f3", print_hash_value);
        transparent_crc(g_93[i].f4, "g_93[i].f4", print_hash_value);
        transparent_crc(g_93[i].f5, "g_93[i].f5", print_hash_value);
        transparent_crc(g_93[i].f6, "g_93[i].f6", print_hash_value);
        transparent_crc(g_93[i].f7, "g_93[i].f7", print_hash_value);
        transparent_crc(g_93[i].f8, "g_93[i].f8", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_97, "g_97", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 6; j++)
        {
            transparent_crc_bytes(&g_103[i][j], sizeof(g_103[i][j]), "g_103[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_109.f0, "g_109.f0", print_hash_value);
    transparent_crc(g_109.f1, "g_109.f1", print_hash_value);
    transparent_crc(g_109.f2, "g_109.f2", print_hash_value);
    transparent_crc(g_109.f3, "g_109.f3", print_hash_value);
    transparent_crc(g_109.f4, "g_109.f4", print_hash_value);
    transparent_crc(g_109.f5, "g_109.f5", print_hash_value);
    transparent_crc(g_109.f6, "g_109.f6", print_hash_value);
    transparent_crc(g_109.f7, "g_109.f7", print_hash_value);
    transparent_crc(g_109.f8, "g_109.f8", print_hash_value);
    transparent_crc(g_140, "g_140", print_hash_value);
    for (i = 0; i < 4; i++)
    {
        for (j = 0; j < 1; j++)
        {
            for (k = 0; k < 1; k++)
            {
                transparent_crc(g_163[i][j][k], "g_163[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 7; j++)
        {
            for (k = 0; k < 1; k++)
            {
                transparent_crc(g_306[i][j][k].f0, "g_306[i][j][k].f0", print_hash_value);
                transparent_crc(g_306[i][j][k].f1, "g_306[i][j][k].f1", print_hash_value);
                transparent_crc(g_306[i][j][k].f2, "g_306[i][j][k].f2", print_hash_value);
                transparent_crc(g_306[i][j][k].f3, "g_306[i][j][k].f3", print_hash_value);
                transparent_crc(g_306[i][j][k].f4, "g_306[i][j][k].f4", print_hash_value);
                transparent_crc(g_306[i][j][k].f5, "g_306[i][j][k].f5", print_hash_value);
                transparent_crc(g_306[i][j][k].f6, "g_306[i][j][k].f6", print_hash_value);
                transparent_crc(g_306[i][j][k].f7, "g_306[i][j][k].f7", print_hash_value);
                transparent_crc(g_306[i][j][k].f8, "g_306[i][j][k].f8", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_308.f0, "g_308.f0", print_hash_value);
    transparent_crc(g_308.f1, "g_308.f1", print_hash_value);
    transparent_crc(g_308.f2, "g_308.f2", print_hash_value);
    transparent_crc(g_308.f3, "g_308.f3", print_hash_value);
    transparent_crc(g_308.f4, "g_308.f4", print_hash_value);
    transparent_crc(g_308.f5, "g_308.f5", print_hash_value);
    transparent_crc(g_308.f6, "g_308.f6", print_hash_value);
    transparent_crc(g_308.f7, "g_308.f7", print_hash_value);
    transparent_crc(g_308.f8, "g_308.f8", print_hash_value);
    transparent_crc_bytes (&g_346, sizeof(g_346), "g_346", print_hash_value);
    transparent_crc(g_354.f0, "g_354.f0", print_hash_value);
    transparent_crc(g_354.f1, "g_354.f1", print_hash_value);
    transparent_crc(g_354.f2, "g_354.f2", print_hash_value);
    transparent_crc(g_354.f3, "g_354.f3", print_hash_value);
    transparent_crc(g_354.f4, "g_354.f4", print_hash_value);
    transparent_crc(g_354.f5, "g_354.f5", print_hash_value);
    transparent_crc(g_354.f6, "g_354.f6", print_hash_value);
    transparent_crc(g_354.f7, "g_354.f7", print_hash_value);
    transparent_crc(g_354.f8, "g_354.f8", print_hash_value);
    transparent_crc(g_373.f0, "g_373.f0", print_hash_value);
    transparent_crc(g_373.f1, "g_373.f1", print_hash_value);
    transparent_crc(g_373.f2, "g_373.f2", print_hash_value);
    transparent_crc(g_373.f3, "g_373.f3", print_hash_value);
    transparent_crc(g_373.f4, "g_373.f4", print_hash_value);
    transparent_crc(g_373.f5, "g_373.f5", print_hash_value);
    transparent_crc(g_373.f6, "g_373.f6", print_hash_value);
    transparent_crc(g_373.f7, "g_373.f7", print_hash_value);
    transparent_crc(g_373.f8, "g_373.f8", print_hash_value);
    transparent_crc(g_386, "g_386", print_hash_value);
    transparent_crc(g_390, "g_390", print_hash_value);
    transparent_crc_bytes (&g_408, sizeof(g_408), "g_408", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 113
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 3
XXX structs with bitfields in the program: 21
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 2
   indirect level: 4, occurrence: 2
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 52

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 138
   depth: 2, occurrence: 27
   depth: 3, occurrence: 2
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 4
   depth: 21, occurrence: 3
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 110

XXX times a variable address is taken: 229
XXX times a pointer is dereferenced on RHS: 43
breakdown:
   depth: 1, occurrence: 33
   depth: 2, occurrence: 10
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 58
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 423

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 149
   level: 2, occurrence: 49
   level: 3, occurrence: 22
   level: 4, occurrence: 7
XXX number of pointers point to pointers: 46
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 8
XXX percent of pointers has null in alias set: 30.9
XXX average alias set size: 1.49

XXX times a non-volatile is read: 488
XXX times a non-volatile is write: 186
XXX times a volatile is read: 31
XXX    times read thru a pointer: 5
XXX times a volatile is write: 10
XXX    times written thru a pointer: 9
XXX times a volatile is available for access: 236
XXX percentage of non-volatile access: 94.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 132
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 23
   depth: 1, occurrence: 17
   depth: 2, occurrence: 21
   depth: 3, occurrence: 18
   depth: 4, occurrence: 15
   depth: 5, occurrence: 38

XXX percentage a fresh-made variable is used: 17.1
XXX percentage an existing variable is used: 82.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

