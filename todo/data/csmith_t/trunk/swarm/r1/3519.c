/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --no-bitfields --comma-operators --compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2712535242
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint64_t  f0;
   int64_t  f1;
   int32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int64_t  func_31(void);
static int64_t  func_41(int16_t  p_42, int16_t  p_43, int32_t  p_44, uint32_t  p_45, int32_t  p_46);
static int32_t * func_67(struct S0  p_68, int32_t * p_69, int32_t ** p_70, int32_t ** p_71);
static int32_t * func_73(int16_t * const  p_74);
inline static int16_t * const  func_75(uint16_t  p_76);
static int16_t  func_81(int64_t  p_82, int32_t ** p_83, int32_t * p_84);
static uint16_t  func_88(struct S0  p_89, int16_t * const  p_90, struct S0  p_91, int32_t  p_92);
static int16_t * const  func_96(int16_t * p_97, const int16_t  p_98, uint32_t  p_99);
static int64_t  func_102(const int32_t ** p_103);
inline static const int32_t ** func_104(struct S0 * p_105, const int16_t * p_106);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0L;
    uint16_t l_35[6] = {8UL,65533UL,8UL,8UL,65533UL,8UL};
    int64_t l_776 = 0L;
    int64_t *l_775 = &l_776;
    int64_t **l_774[7][5] = {{&l_775,&l_775,&l_775,&l_775,&l_775},{&l_775,&l_775,&l_775,&l_775,&l_775},{&l_775,&l_775,(void*)0,&l_775,&l_775},{&l_775,&l_775,&l_775,&l_775,&l_775},{&l_775,&l_775,&l_775,&l_775,&l_775},{&l_775,&l_775,(void*)0,&l_775,&l_775},{&l_775,&l_775,&l_775,&l_775,&l_775}};
    int64_t ***l_773 = &l_774[2][2];
    int64_t **** const l_772 = &l_773;
    int32_t l_797 = 0xE86F7577L;
    int32_t l_798[1][8];
    int16_t l_819[4];
    uint64_t l_837 = 0x3776108DCF6D8896LL;
    int16_t * const l_844 = &l_819[1];
    int16_t * const *l_843 = &l_844;
    int16_t * const ** const l_842 = &l_843;
    int8_t *** const l_900 = (void*)0;
    int32_t l_918 = (-1L);
    uint64_t l_931 = 18446744073709551612UL;
    int32_t *l_956[3];
    int32_t **l_955 = &l_956[0];
    struct S0 l_1005[10] = {{0x7537DF590FB91850LL,0x3E334EF98DEAD196LL,0x8B0B1DA1L,18446744073709551613UL},{18446744073709551609UL,0x7DF9E2855FD47348LL,0xEA2ACF17L,0xE9BBAC22L},{18446744073709551609UL,0x7DF9E2855FD47348LL,0xEA2ACF17L,0xE9BBAC22L},{0x7537DF590FB91850LL,0x3E334EF98DEAD196LL,0x8B0B1DA1L,18446744073709551613UL},{18446744073709551609UL,0x7DF9E2855FD47348LL,0xEA2ACF17L,0xE9BBAC22L},{0x7D97A4865DC22B8CLL,0x792F4F09064B70A1LL,0L,0xD60B6285L},{18446744073709551609UL,0x7DF9E2855FD47348LL,0xEA2ACF17L,0xE9BBAC22L},{0x7D97A4865DC22B8CLL,0x792F4F09064B70A1LL,0L,0xD60B6285L},{0x7D97A4865DC22B8CLL,0x792F4F09064B70A1LL,0L,0xD60B6285L},{18446744073709551609UL,0x7DF9E2855FD47348LL,0xEA2ACF17L,0xE9BBAC22L}};
    struct S0 *l_1004 = &l_1005[3];
    struct S0 *l_1007 = (void*)0;
    struct S0 **l_1006 = &l_1007;
    int32_t l_1008 = (-3L);
    int i, j;
    for (i = 0; i < 1; i = i + 1)
    {
        for (j = 0; j < 8; j = j + 1)
            l_798[i][j] = (-1L);
    }
    for (i = 0; i < 4; i = i + 1)
        l_819[i] = 0xA0FCL;
    for (i = 0; i < 3; i = i + 1)
        l_956[i] = &l_798[0][5];
    for (l_32 = (-22); (l_32 > (-24)); l_32 -= 8)
    { /* block id: 39 */
        int32_t l_36[4];
        const uint16_t ****l_725 = (void*)0;
        struct S0 l_727[1][2] = {{{0x979A24E43DCBBDB2LL,0x7EA9ED103084B7F3LL,-1L,18446744073709551610UL},{0x979A24E43DCBBDB2LL,0x7EA9ED103084B7F3LL,-1L,18446744073709551610UL}}};
        struct S0 * const l_726 = &l_727[0][0];
        int16_t **l_767 = (void*)0;
        int16_t ***l_766[6][7][5] = {{{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,(void*)0,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{(void*)0,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,(void*)0,(void*)0,&l_767,&l_767},{&l_767,(void*)0,&l_767,&l_767,&l_767}},{{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,(void*)0,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767}},{{&l_767,(void*)0,(void*)0,&l_767,&l_767},{&l_767,(void*)0,&l_767,(void*)0,&l_767},{(void*)0,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{(void*)0,&l_767,&l_767,&l_767,(void*)0},{&l_767,&l_767,&l_767,&l_767,&l_767}},{{&l_767,&l_767,(void*)0,&l_767,&l_767},{&l_767,(void*)0,&l_767,(void*)0,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,(void*)0,&l_767}},{{&l_767,(void*)0,&l_767,&l_767,(void*)0},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,(void*)0,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767}},{{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{(void*)0,&l_767,&l_767,&l_767,&l_767},{&l_767,&l_767,&l_767,&l_767,&l_767},{&l_767,(void*)0,&l_767,&l_767,(void*)0},{&l_767,&l_767,&l_767,&l_767,&l_767},{(void*)0,&l_767,(void*)0,&l_767,&l_767}}};
        int16_t ****l_765 = &l_766[1][2][0];
        uint32_t l_796 = 4294967295UL;
        uint32_t *l_795[4][2] = {{&l_796,&l_796},{&l_796,&l_796},{&l_796,&l_796},{&l_796,&l_796}};
        int32_t *l_815 = (void*)0;
        int32_t *l_816 = &l_727[0][0].f2;
        uint16_t *l_817 = &l_35[5];
        int8_t l_818 = 0xD2L;
        const int16_t l_862 = 0L;
        int32_t l_892[1][10][2] = {{{(-1L),(-5L)},{(-1L),0xD801A532L},{(-1L),(-1L)},{0xD801A532L,(-1L)},{(-5L),(-1L)},{0xD801A532L,(-1L)},{(-1L),0xD801A532L},{(-1L),(-5L)},{(-1L),0xD801A532L},{(-1L),(-1L)}}};
        int64_t ****l_911 = &l_773;
        int i, j, k;
        for (i = 0; i < 4; i = i + 1)
            l_36[i] = 0xE815F842L;
        for (l_36[3] = 5; (l_36[3] >= 0); l_36[3] -= 1)
        { /* block id: 42 */
            int32_t l_37 = (-1L);
            struct S0 l_740 = {1UL,0xFBA76E2F633A3E4BLL,-1L,0x8EEE9CA4L};
            for (l_37 = 1; (l_37 <= 5); l_37 += 1)
            { /* block id: 45 */
                int32_t l_38 = 6L;
                int16_t l_54 = 0x9F48L;
                int16_t *l_53 = &l_54;
                int16_t *l_55 = (void*)0;
                int16_t l_57 = 2L;
                int16_t *l_56 = &l_57;
                int32_t l_716[10] = {(-1L),(-9L),7L,(-9L),(-1L),(-1L),(-9L),7L,(-9L),(-1L)};
                const uint16_t *l_721 = &l_35[2];
                const uint16_t **l_720 = &l_721;
                const uint16_t ***l_719 = &l_720;
                const uint16_t ****l_718 = &l_719;
                int32_t *l_753 = &l_740.f2;
                int i;
                for (l_38 = 5; (l_38 >= 1); l_38 -= 1)
                { /* block id: 48 */
                    int i;
                    return l_35[l_36[3]];
                }
                if (((uint32_t)(0xA41B870004DDC877LL >= ((l_38 >= l_35[3]) , func_41((l_36[3] , (0x9942C3B03C3FA3C9LL | l_37)), (l_38 = l_36[3]), ((int16_t)((*l_56) = ((*l_53) = ((uint32_t)(((((((int16_t)(__builtin_bswap64(l_35[5]) & l_32) % (int16_t)l_37) != 8L) > 0x0B2B0402L) , l_37) && l_36[1]) <= 0x32A5B4D633C66883LL) / (uint32_t)l_36[3]))) >> (int16_t)l_37), l_37, l_37))) / (uint32_t)l_716[0]))
                { /* block id: 445 */
                    for (l_57 = 5; (l_57 >= 1); l_57 -= 1)
                    { /* block id: 448 */
                        return l_36[3];
                    }
                }
                else
                { /* block id: 451 */
                    int64_t l_717[3][9][8] = {{{1L,(-8L),0x3CF950DA920D9D03LL,8L,0xCD707780DB21F0BALL,1L,0x8683844494486627LL,1L},{0xDBEE1D9DC84AC738LL,0xCD707780DB21F0BALL,0xC54B2CA039466A27LL,9L,(-1L),0x478F4E98ED316568LL,0x490A228A39EBDA48LL,(-1L)},{0xD7422CC811C14A0DLL,(-1L),0x1CAD353F23169BAELL,1L,0x41FB0AE83B1F7FE9LL,1L,(-6L),3L},{0xCD707780DB21F0BALL,(-1L),0x1C00EDEB1DAF2436LL,0L,(-6L),0x1C00EDEB1DAF2436LL,(-4L),0x8683844494486627LL},{0xDBEE1D9DC84AC738LL,3L,3L,1L,0x8683844494486627LL,0L,0xC54B2CA039466A27LL,(-8L)},{3L,1L,0x490A228A39EBDA48LL,0x2193B84FDA0A54E4LL,1L,0x5B30444C2D8317A8LL,0L,0x5B30444C2D8317A8LL},{1L,1L,6L,1L,1L,0x1C00EDEB1DAF2436LL,0xAA56692E4C582A98LL,0x052BEDD8BF22F229LL},{0x5B30444C2D8317A8LL,(-4L),0x68DC244CEEF6A606LL,0xA18C9E2AD9EB2828LL,0xD7422CC811C14A0DLL,0xA75E2E6F12E969B1LL,(-1L),1L},{(-1L),(-1L),0x68DC244CEEF6A606LL,0xAA56692E4C582A98LL,0x478F4E98ED316568LL,(-6L),0xAA56692E4C582A98LL,0xDBEE1D9DC84AC738LL}},{{0xD7422CC811C14A0DLL,0x8683844494486627LL,6L,0x052BEDD8BF22F229LL,(-1L),1L,0L,0xD7422CC811C14A0DLL},{3L,(-1L),0x490A228A39EBDA48LL,0x478F4E98ED316568LL,(-1L),9L,0xC54B2CA039466A27LL,0xCD707780DB21F0BALL},{(-4L),0L,3L,1L,4L,0xA18C9E2AD9EB2828LL,(-4L),0xDBEE1D9DC84AC738LL},{8L,0x052BEDD8BF22F229LL,0x1C00EDEB1DAF2436LL,0x2193B84FDA0A54E4LL,1L,0xE316027EDFE20F22LL,(-6L),3L},{0xA75E2E6F12E969B1LL,3L,0x1CAD353F23169BAELL,0xA18C9E2AD9EB2828LL,1L,0x490A228A39EBDA48LL,0x490A228A39EBDA48LL,1L},{3L,0xC54B2CA039466A27LL,0xC54B2CA039466A27LL,3L,4L,0xA75E2E6F12E969B1LL,0x8683844494486627LL,0x5B30444C2D8317A8LL},{(-8L),0xD7422CC811C14A0DLL,0x3CF950DA920D9D03LL,0xF3018C5D73677442LL,0L,6L,0x1CAD353F23169BAELL,0xA75E2E6F12E969B1LL},{0xDFC696A04C89D329LL,0x41FB0AE83B1F7FE9LL,2L,1L,0xA18C9E2AD9EB2828LL,0xE5F920251E4ED060LL,0x38FC12DB752CB08ALL,0x41FB0AE83B1F7FE9LL},{0x33E375D721729C78LL,1L,0x12FD0482D33C8AF5LL,3L,2L,6L,0xA75E2E6F12E969B1LL,0xDFC696A04C89D329LL}},{{1L,0xC54B2CA039466A27LL,(-1L),1L,0x33E375D721729C78LL,(-1L),1L,1L},{0x7C0AEFE934526C5CLL,1L,6L,0x12FD0482D33C8AF5LL,1L,0xE87705C020277AD2LL,0x38FC12DB752CB08ALL,0xDBEE1D9DC84AC738LL},{9L,0x3CF950DA920D9D03LL,9L,0x68DC244CEEF6A606LL,1L,0x12FD0482D33C8AF5LL,0x478F4E98ED316568LL,0xE5F920251E4ED060LL},{0xDBEE1D9DC84AC738LL,0xA75E2E6F12E969B1LL,0x052BEDD8BF22F229LL,0xC54B2CA039466A27LL,0x41FB0AE83B1F7FE9LL,0xAA56692E4C582A98LL,0x41FB0AE83B1F7FE9LL,0xC54B2CA039466A27LL},{0xF5A8D5B74AFB5343LL,(-1L),0xF5A8D5B74AFB5343LL,0x12FD0482D33C8AF5LL,(-1L),0x38FC12DB752CB08ALL,6L,1L},{(-1L),0L,0x38FC12DB752CB08ALL,0x490A228A39EBDA48LL,0x567B6C8956D2D1BCLL,0xE5F920251E4ED060LL,(-1L),0xDFC696A04C89D329LL},{(-1L),1L,(-1L),4L,(-1L),(-1L),0xA75E2E6F12E969B1LL,0x33E375D721729C78LL},{0xF5A8D5B74AFB5343LL,0x68DC244CEEF6A606LL,0xB447305ED182475ELL,1L,0x41FB0AE83B1F7FE9LL,0x7C0AEFE934526C5CLL,1L,1L},{0xDBEE1D9DC84AC738LL,0x1C00EDEB1DAF2436LL,0x12FD0482D33C8AF5LL,0x1CAD353F23169BAELL,1L,0x3CF950DA920D9D03LL,3L,0x7C0AEFE934526C5CLL}}};
                    int8_t l_748 = 0xADL;
                    int16_t **l_758[5];
                    int16_t ***l_757 = &l_758[2];
                    int16_t ****l_756 = &l_757;
                    int64_t l_768 = 3L;
                    int i, j, k;
                    for (i = 0; i < 5; i = i + 1)
                        l_758[i] = &l_55;
                    if (l_717[0][1][3])
                    { /* block id: 452 */
                        const uint16_t * const ****l_722 = (void*)0;
                        const uint16_t *** const *l_724 = &l_719;
                        const uint16_t *** const **l_723[2];
                        const struct S0 *l_729 = &l_727[0][0];
                        const struct S0 **l_728 = &l_729;
                        int i;
                        for (i = 0; i < 2; i = i + 1)
                            l_723[i] = &l_724;
                        l_725 = l_718;
                        /* statement id: 453 */
                        assert (l_725 == &l_719);
                        (*l_728) = l_726;
                    }
                    else
                    { /* block id: 455 */
                        const int32_t *l_731 = (void*)0;
                        const int32_t **l_730 = &l_731;
                        uint32_t l_737 = 1UL;
                        uint32_t *l_736 = &l_737;
                        uint64_t l_741 = 5UL;
                        uint16_t l_747 = 0x48F2L;
                        uint16_t *l_746 = &l_747;
                        int32_t *l_749 = &l_716[8];
                        int i;
                        (*l_730) = (void*)0;
                        (*l_749) = ((l_35[l_36[3]] = 1UL) < ((uint16_t)((*l_746) = ((uint32_t)((((((*l_736) = 0UL) == (((uint32_t)4294967295UL + (uint32_t)(l_740 , l_741)) ^ ((uint16_t)l_727[0][0].f0 >> (uint16_t)(((*l_56) = (((uint32_t)l_717[0][1][1] + (uint32_t)(func_102(&l_731) < l_37)) ^ l_740.f2)) ^ l_717[0][1][3])))) > l_38) == l_37) && l_38) / (uint32_t)l_32)) * (uint16_t)l_748));
                        if (l_716[0])
                            break;
                        (*l_730) = ((*l_726) , (*l_730));
                    }
                    /* facts after branching */
                    //assert (l_725 == 0 || l_725 == dangling || l_725 == &l_719);
                    if (l_717[1][8][7])
                    { /* block id: 465 */
                        const int32_t *l_750 = (void*)0;
                        if (l_748)
                            break;
                        //assert (l_725 == 0 || l_725 == dangling);
                        l_750 = l_750;
                    }
                    else
                    { /* block id: 468 */
                        int32_t *l_751 = (void*)0;
                        int32_t **l_752 = &l_751;
                        int32_t *l_754 = &l_716[0];
                        int32_t l_755[9] = {1L,1L,1L,1L,1L,1L,1L,1L,1L};
                        int32_t *l_769 = &l_727[0][0].f2;
                        int i;
                        if (l_35[5])
                            break;
                        //assert (l_725 == 0 || l_725 == dangling);
                        l_38 &= l_727[0][0].f3;
                        l_754 = (l_753 = ((*l_752) = (void*)0));
                        /* statement id: 473 */
                        assert (l_753 == 0);
                        assert (l_754 == 0);
                        (*l_769) ^= (l_740.f2 != ((l_755[5] && (((l_756 == (((l_36[3] & ((uint16_t)l_35[4] / (uint16_t)(((int32_t)((0x230E7A4364FEEE75LL <= ((int64_t)l_32 - (int64_t)(((l_740.f0 , (***l_718)) != (**l_719)) , l_727[0][0].f1))) & (-2L)) / (int32_t)(-7L)) && l_717[2][6][2]))) < 0x106A2BBBL) , l_765)) , 0x83FCEB46L) && l_768)) , 6UL));
                    }
                    /* facts after branching */
                    assert (l_753 == 0 || l_753 == &l_740.f2);
                    for (l_740.f0 = (-1); (l_740.f0 != 20); l_740.f0 += 7)
                    { /* block id: 478 */
                        int64_t ****l_778[9][2] = {{&l_773,&l_773},{(void*)0,&l_773},{&l_773,(void*)0},{&l_773,&l_773},{(void*)0,&l_773},{&l_773,(void*)0},{&l_773,&l_773},{(void*)0,&l_773},{&l_773,(void*)0}};
                        int64_t *****l_777 = &l_778[2][0];
                        int i, j;
                        (*l_777) = l_772;
                    }
                }
                /* facts after branching */
                //assert (l_725 == 0 || l_725 == dangling || l_725 == &l_719);
                assert (l_753 == 0 || l_753 == &l_740.f2);
            }
        }
        /* facts after for loop */
        //assert (l_725 == 0 || l_725 == dangling);
        l_798[0][5] |= (((int16_t)l_32 << (int16_t)__builtin_popcountll(((uint32_t)l_727[0][0].f2 % (uint32_t)(((int16_t)((l_797 = (((((uint64_t)(((((((uint16_t)l_35[1] - (uint16_t)(l_727[0][0].f2 == 8UL)) , ((0x8D94DAF12B6CED6FLL & (1UL != ((((int16_t)(l_36[0] = (2L || ((uint16_t)((int32_t)l_36[3] + (int32_t)l_36[3]) / (uint16_t)l_727[0][0].f3))) >> (int16_t)14) , l_727[0][0].f1) , l_776))) && l_36[3])) <= l_35[0]) < 18446744073709551615UL) , l_776) , l_35[2]) - (uint64_t)l_727[0][0].f3) , l_727[0][0].f1) > 0xE0B6C4363D06F04ALL) ^ l_35[2])) && l_776) % (int16_t)0xECB1L) && l_35[5])))) < 0x095AL);
    }
    (**l_955) = (l_1004 != ((*l_1006) = &l_1005[0]));
    /* statement id: 598 */
    assert ((l_1007 >= &l_1005[0] && l_1007 <= &l_1005[9]));
    return l_1008;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_41(int16_t  p_42, int16_t  p_43, int32_t  p_44, uint32_t  p_45, int32_t  p_46)
{ /* block id: 54 */
    int32_t l_62 = (-2L);
    int32_t * const l_61 = &l_62;
    int32_t *l_181 = &l_62;
    int32_t **l_180 = &l_181;
    struct S0 l_506 = {1UL,0x0347D94C0175571CLL,0x4AF81ADAL,0x7DD07D60L};
    struct S0 *l_505 = &l_506;
    int32_t **l_514 = &l_181;
    int16_t l_520 = 0xD07FL;
    int16_t * const l_519 = &l_520;
    uint16_t l_527 = 1UL;
    int16_t ****l_599 = (void*)0;
    int16_t *****l_598 = &l_599;
    int64_t ****l_603 = (void*)0;
    const uint32_t l_686 = 0x063CCC8EL;
    uint32_t l_689 = 0xB7852D5FL;
    uint16_t *l_715 = &l_527;
    uint16_t **l_714 = &l_715;
    for (p_42 = 0; (p_42 <= (-27)); p_42 -= 1)
    { /* block id: 57 */
        int32_t l_60 = 0x39802EEDL;
        struct S0 l_72 = {0x69E1D62101101210LL,0xDF3F1863D476FC58LL,1L,0UL};
        int32_t *l_179 = &l_72.f2;
        int32_t **l_178 = &l_179;
        uint32_t l_497[6];
        int16_t **** const l_550 = (void*)0;
        int8_t *l_610 = (void*)0;
        int8_t **l_609 = &l_610;
        int32_t *l_633 = &l_60;
        int32_t *l_640 = &l_506.f2;
        int16_t l_642 = 5L;
        int16_t *l_641 = &l_642;
        uint32_t l_643 = 0x5A5727B4L;
        int64_t *l_644 = &l_72.f1;
        struct S0 l_681 = {0xAEC2E59432F91665LL,0x3AA340119471F1E1LL,0L,0xDD250ABBL};
        int i;
        for (i = 0; i < 6; i = i + 1)
            l_497[i] = 3UL;
    }
    (*l_505) = (*l_505);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_67(struct S0  p_68, int32_t * p_69, int32_t ** p_70, int32_t ** p_71)
{ /* block id: 114 */
    const int32_t l_191 = 0x80EDB35DL;
    const int32_t **l_230 = (void*)0;
    int16_t **l_239 = (void*)0;
    int16_t ***l_238 = &l_239;
    int32_t l_245 = 1L;
    int16_t ****l_261 = (void*)0;
    int16_t *****l_260 = &l_261;
    int16_t *****l_262 = (void*)0;
    int32_t *l_281 = (void*)0;
    int32_t **l_280 = &l_281;
    uint16_t l_381 = 0xC7E0L;
    uint16_t *l_380 = &l_381;
    int32_t l_480 = 0L;
    int32_t *l_486 = &l_245;
    for (p_68.f3 = 0; (p_68.f3 != 12); p_68.f3 += 1)
    { /* block id: 117 */
        int64_t l_184 = (-1L);
        const int16_t l_203 = 0x70DDL;
        const int16_t *l_202 = &l_203;
        const int16_t **l_201 = &l_202;
        const int16_t ***l_200 = &l_201;
        const int16_t ****l_199 = &l_200;
        int16_t l_241 = 0xA485L;
        int16_t * const l_240 = &l_241;
        int32_t l_258 = 0x66BCB5D3L;
        uint32_t l_259 = 1UL;
        struct S0 l_285[3] = {{3UL,0x2DA4460E21C45891LL,5L,0x6D1B619EL},{3UL,0x2DA4460E21C45891LL,5L,0x6D1B619EL},{3UL,0x2DA4460E21C45891LL,5L,0x6D1B619EL}};
        const int32_t ***l_289 = (void*)0;
        int32_t **l_290 = (void*)0;
        int16_t l_291 = 0x50E1L;
        const int32_t *l_336[9];
        const int32_t **l_335 = &l_336[6];
        int64_t * const l_407 = &l_285[0].f1;
        int64_t * const *l_406 = &l_407;
        int16_t * const * const l_408 = (void*)0;
        int64_t l_479 = (-5L);
        int i;
        for (i = 0; i < 9; i = i + 1)
            l_336[i] = &l_245;
    }
    return (*p_70);
    /* statement id: 274 */
    //assert (func_67_rv == &l_72.f2 || func_67_rv == &l_62 || func_67_rv == 0 || func_67_rv == &l_853 || (func_67_rv >= &l_798[0][0] && func_67_rv <= &l_798[0][7]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_73(int16_t * const  p_74)
{ /* block id: 108 */
    struct S0 l_167 = {18446744073709551615UL,0x9854563BEC67E8D8LL,0x32C7286EL,18446744073709551615UL};
    struct S0 *l_168 = (void*)0;
    uint16_t l_170 = 0UL;
    uint16_t *l_169[10][5] = {{&l_170,&l_170,&l_170,&l_170,&l_170},{&l_170,(void*)0,&l_170,&l_170,(void*)0},{&l_170,&l_170,(void*)0,&l_170,(void*)0},{(void*)0,(void*)0,&l_170,(void*)0,(void*)0},{(void*)0,&l_170,(void*)0,&l_170,&l_170},{(void*)0,&l_170,&l_170,(void*)0,&l_170},{&l_170,&l_170,&l_170,&l_170,&l_170},{&l_170,(void*)0,&l_170,&l_170,(void*)0},{&l_170,&l_170,(void*)0,&l_170,(void*)0},{(void*)0,(void*)0,&l_170,(void*)0,(void*)0}};
    int32_t l_172 = 0x53028FBCL;
    int32_t *l_171 = &l_172;
    int32_t **l_173 = &l_171;
    int32_t *l_174 = &l_172;
    int32_t *l_175 = &l_167.f2;
    int32_t *l_176 = &l_172;
    int32_t *l_177 = (void*)0;
    int i, j;
    l_167 = l_167;
    (*l_171) |= (((l_167.f2 = l_167.f2) , l_167.f0) < (__builtin_ffsll(l_170) != l_170));
    (*l_173) = &l_172;
    return l_177;
    /* statement id: 113 */
    //assert (func_73_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t * const  func_75(uint16_t  p_76)
{ /* block id: 60 */
    int16_t l_85 = 7L;
    struct S0 l_93 = {18446744073709551614UL,-6L,-3L,18446744073709551614UL};
    struct S0 *l_94[9] = {&l_93,(void*)0,&l_93,(void*)0,&l_93,(void*)0,&l_93,(void*)0,&l_93};
    struct S0 l_95 = {1UL,1L,-9L,18446744073709551606UL};
    int16_t *l_101 = &l_85;
    int16_t **l_100 = &l_101;
    struct S0 l_124 = {0x69B51010FFDB434ELL,0xFA99CDC6EB25118CLL,0x2C6A0115L,1UL};
    int16_t **l_125 = &l_101;
    struct S0 l_126 = {0x13C7C5A92DAE4FB3LL,0xE2C827C01AD3E3C3LL,6L,18446744073709551612UL};
    int32_t *l_140 = &l_93.f2;
    int32_t **l_139 = &l_140;
    uint16_t *l_151 = (void*)0;
    uint16_t l_153 = 0x33A8L;
    uint16_t *l_152 = &l_153;
    struct S0 l_156 = {0x1CBB092B1045D443LL,1L,1L,18446744073709551615UL};
    struct S0 l_160 = {6UL,4L,-5L,0xFC8DD5CAL};
    int32_t *l_161[4] = {&l_126.f2,&l_126.f2,&l_126.f2,&l_126.f2};
    int32_t l_162[3][10] = {{0x43815406L,0x43815406L,0xB6AF6FE2L,0x43815406L,0x43815406L,0xB6AF6FE2L,0x43815406L,0x43815406L,0x43815406L,(-1L)},{(-1L),0xB6AF6FE2L,0xB6AF6FE2L,(-1L),0xB6AF6FE2L,0xB6AF6FE2L,(-1L),0xB6AF6FE2L,0xB6AF6FE2L,(-1L)},{0xB6AF6FE2L,(-1L),0xB6AF6FE2L,0xB6AF6FE2L,(-1L),0xB6AF6FE2L,0xB6AF6FE2L,(-1L),0xB6AF6FE2L,0xB6AF6FE2L}};
    struct S0 *l_163 = &l_156;
    int16_t * const l_164 = &l_85;
    int16_t * const l_165 = &l_85;
    int16_t * const l_166 = (void*)0;
    int i, j;
    (**l_139) = (((int32_t)(((((int16_t)func_81((l_85 || ((uint16_t)func_88((l_95 = l_93), ((*l_125) = func_96(((*l_100) = (void*)0), (((func_102(func_104(&l_93, &l_85)) ^ l_93.f1) && (l_124 , 0x11EFL)) <= 5L), p_76)), l_126, p_76) * (uint16_t)0x3BA7L)), l_139, (*l_139)) >> (int16_t)(**l_139)) , p_76) , p_76) && (**l_139)) + (int32_t)0x7F47FA05L) <= p_76);
    /* statement id: 102 */
    assert (l_101 == &l_85 || l_101 == 0);
    l_162[2][3] &= ((((uint16_t)(p_76 = ((((int16_t)(((*l_152) |= (*l_140)) != p_76) << (int16_t)4) > (**l_139)) <= ((int16_t)func_88(l_156, func_96(((*l_140) , (*l_100)), (~4294967295UL), ((uint16_t)0x159AL >> (uint16_t)11)), l_160, (*l_140)) * (int16_t)(**l_139)))) - (uint16_t)(*l_140)) , &l_125) != &l_100);
    (*l_140) = (((void*)0 == l_163) != (*l_140));
    return l_166;
    /* statement id: 107 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_81(int64_t  p_82, int32_t ** p_83, int32_t * p_84)
{ /* block id: 93 */
    uint32_t l_146 = 0x739B9925L;
    for (p_82 = 26; (p_82 < 26); p_82 += 1)
    { /* block id: 96 */
        struct S0 l_143 = {0x7FC644E58EE9C46ALL,0x01C7F31148879A0FLL,1L,1UL};
        struct S0 l_145 = {5UL,0x5FBD2053445193B0LL,0x3500CD51L,0x2C662BADL};
        struct S0 *l_144 = &l_145;
        (*l_144) = (l_143 = l_143);
    }
    l_146 |= (**p_83);
    return l_146;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_88(struct S0  p_89, int16_t * const  p_90, struct S0  p_91, int32_t  p_92)
{ /* block id: 87 */
    int32_t l_127 = (-10L);
    int32_t l_129 = 0L;
    int32_t *l_128 = &l_129;
    struct S0 l_131 = {1UL,0L,6L,0x1AF397C0L};
    struct S0 *l_130 = &l_131;
    int16_t l_134 = 0L;
    int16_t *l_133 = &l_134;
    int16_t **l_132 = &l_133;
    const int16_t l_136 = 0xA4D4L;
    const int16_t *l_135 = &l_136;
    int32_t **l_137[10][9][1] = {{{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128}},{{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128}},{{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0}},{{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0}},{{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{(void*)0}},{{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128}},{{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128}},{{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0}},{{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0}},{{&l_128},{&l_128},{&l_128},{&l_128},{&l_128},{(void*)0},{&l_128},{&l_128},{(void*)0}}};
    int32_t *l_138 = &l_129;
    int i, j, k;
    (*l_128) |= (0xB277L > l_127);
    l_138 = (func_102(func_104(l_130, (l_135 = ((*l_132) = (void*)0)))) , &l_129);
    /* statement id: 91 */
    assert (l_133 == 0);
    assert (l_135 == 0);
    return p_89.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t * const  func_96(int16_t * p_97, const int16_t  p_98, uint32_t  p_99)
{ /* block id: 84 */
    return p_97;
    /* statement id: 85 */
    //assert (func_96_rv == 0 || func_96_rv == &l_85);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_102(const int32_t ** p_103)
{ /* block id: 65 */
    int16_t l_116 = 0x7F09L;
    int16_t *l_115 = &l_116;
    int16_t **l_114 = &l_115;
    int16_t ***l_113[3];
    int16_t ****l_117 = &l_113[1];
    int i;
    for (i = 0; i < 3; i = i + 1)
        l_113[i] = &l_114;
lbl_123:
    (*l_117) = l_113[0];
    for (l_116 = 0; (l_116 <= 8); l_116 += 1)
    { /* block id: 69 */
        int32_t l_120 = 0x20081CEEL;
        int32_t *l_122 = &l_120;
        for (l_120 = 2; (l_120 >= 0); l_120 -= 1)
        { /* block id: 72 */
            int32_t l_121 = 0xFC4C5E22L;
            for (l_121 = 0; (l_121 <= 2); l_121 += 1)
            { /* block id: 75 */
                return l_120;
            }
        }
        (*l_122) ^= (0xB066L == l_116);
        if (l_120)
            goto lbl_123;
        if (l_120)
            goto lbl_123;
    }
    return l_116;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t ** func_104(struct S0 * p_105, const int16_t * p_106)
{ /* block id: 63 */
    int32_t l_109 = 0xC0CF43ACL;
    const int32_t *l_108[2];
    const int32_t **l_107 = &l_108[1];
    const int32_t **l_110[6] = {&l_108[1],&l_108[1],&l_108[1],&l_108[1],&l_108[1],&l_108[1]};
    const int32_t **l_111[7][1] = {{&l_108[1]},{&l_108[1]},{&l_108[1]},{&l_108[1]},{&l_108[1]},{&l_108[1]},{&l_108[1]}};
    const int32_t **l_112 = (void*)0;
    int i, j;
    for (i = 0; i < 2; i = i + 1)
        l_108[i] = &l_109;
    return l_112;
    /* statement id: 64 */
    //assert (func_104_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 240
   depth: 1, occurrence: 25
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 300

XXX times a variable address is taken: 623
XXX times a pointer is dereferenced on RHS: 119
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 49
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 174
breakdown:
   depth: 1, occurrence: 142
   depth: 2, occurrence: 28
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 1251

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 635
   level: 2, occurrence: 251
   level: 3, occurrence: 14
   level: 4, occurrence: 10
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 139
XXX number of pointers point to scalars: 141
XXX number of pointers point to structs: 20
XXX percent of pointers has null in alias set: 34.7
XXX average alias set size: 1.37

XXX times a non-volatile is read: 1041
XXX times a non-volatile is write: 519
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 58
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 7
   depth: 2, occurrence: 2
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 18.1
XXX percentage an existing variable is used: 81.9
********************* end of statistics **********************/

