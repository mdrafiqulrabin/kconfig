/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      433240716
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint16_t  f1;
   uint16_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0x73838A1F;
static volatile struct S0 g_80 = {6U,65535U,0x53AA};/* VOLATILE GLOBAL g_80 */
static struct S0 g_81 = {0U,0x33BC,0xC2DB};
static int32_t g_84 = 0x4E228C51;
static int32_t *g_99 = &g_84;
static int32_t **g_98 = &g_99;
static struct S0 g_113 = {0U,0x825F,65535U};
static struct S0 ***g_194 = (void*)0;
static int32_t *****g_245 = (void*)0;
static struct S0 g_262 = {0xC6506466,7U,0x9658};
static struct S0 *g_303 = (void*)0;
static int32_t ***g_368 = &g_98;
static int32_t ****g_367 = &g_368;
static struct S0 *****g_377 = (void*)0;
static uint32_t g_399 = 0U;
static int32_t g_402 = 5;
static volatile int32_t g_424 = 0x0E186AC2;/* VOLATILE GLOBAL g_424 */
static int32_t g_448 = 7;
static int32_t g_459 = 0x9EB94F8D;
static const int32_t g_481 = 0xC5EA47B8;
static volatile int32_t *g_547 = (void*)0;
static uint16_t g_562 = 1U;
static struct S0 *****g_577 = (void*)0;


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_30(void);
inline static int32_t  func_31(uint32_t  p_32, uint32_t  p_33, uint32_t  p_34, int32_t  p_35, int32_t  p_36);
inline static uint16_t  func_37(int16_t  p_38, const uint32_t  p_39, int32_t  p_40);
static int16_t  func_41(const uint32_t  p_42, struct S0  p_43, uint16_t  p_44, uint32_t  p_45, int16_t  p_46);
static uint16_t  func_47(uint32_t  p_48, uint32_t  p_49, int32_t  p_50, struct S0  p_51);
inline static int16_t  func_56(uint16_t  p_57);
inline static uint16_t  func_58(int16_t  p_59);
inline static int16_t  func_60(int32_t  p_61, uint16_t  p_62, const uint16_t  p_63, struct S0  p_64);
inline static int16_t  func_71(int32_t  p_72);
static uint16_t  func_75(struct S0  p_76, struct S0  p_77, int16_t  p_78, struct S0  p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_30(void)
{ /* block id: 36 */
    int32_t l_65 = 3;
    struct S0 l_82 = {1U,0xC2C1,1U};
    struct S0 **l_431 = &g_303;
    uint16_t l_440 = 0xAF1D;
    int32_t *l_469 = &g_84;
    int32_t ***l_518 = (void*)0;
    struct S0 ****l_546 = &g_194;
    struct S0 *****l_545 = &l_546;
    volatile int32_t *l_548 = &g_424;
    int32_t *****l_579 = &g_367;
    uint32_t l_636 = 0xBC2FAB2E;
    return l_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_99
 */
inline static int32_t  func_31(uint32_t  p_32, uint32_t  p_33, uint32_t  p_34, int32_t  p_35, int32_t  p_36)
{ /* block id: 230 */
    int32_t **l_400 = &g_99;
    int32_t l_401 = 1;
    (*l_400) = (void*)0;
    /* statement id: 231 */
    assert (g_99 == 0);
    return l_401;
}


/* ------------------------------------------ */
/* 
 * reads : g_81.f1 g_377 g_3 g_262.f1 g_113.f2 g_80.f1 g_84 g_113.f1 g_262.f2 g_81
 * writes: g_99 g_113.f2 g_84 g_98 g_81
 */
inline static uint16_t  func_37(int16_t  p_38, const uint32_t  p_39, int32_t  p_40)
{ /* block id: 214 */
    struct S0 l_374 = {0xE722CEAE,0xB508,0x3B59};
    struct S0 **l_376 = &g_303;
    struct S0 ***l_375 = &l_376;
    int32_t *l_394 = &g_84;
    struct S0 l_397 = {0xE8F852F5,0U,65529U};
    int32_t **l_398 = &g_99;
    if (((safe_sub_func_uint16_t_u_u(0U, ((g_81.f1 == ((l_374 , (void*)0) != ((((void*)0 != l_375) , l_374.f2) , g_377))) && (((__builtin_bswap32((g_3 > l_374.f0)) , g_262.f1) | 0x5A1B) , p_40)))) , p_38))
    { /* block id: 215 */
        int32_t * const l_378 = &g_84;
        int32_t **l_379 = &g_99;
        struct S0 **l_380 = &g_303;
        struct S0 *l_383 = &g_81;
        const struct S0 *l_389 = &g_81;
        const struct S0 **l_388 = &l_389;
        const struct S0 ***l_387 = &l_388;
        const struct S0 ****l_386 = &l_387;
        (*l_379) = l_378;
        /* statement id: 216 */
        assert (g_99 == &g_84);
        l_380 = l_380;
        for (g_113.f2 = 0; (g_113.f2 >= 44); g_113.f2 = safe_add_func_uint16_t_u_u(g_113.f2, 1))
        { /* block id: 220 */
            return p_40;
        }
        (*l_378) = (((((void*)0 != l_383) , g_80.f1) > (safe_mod_func_int32_t_s_s((l_386 == (void*)0), (safe_sub_func_int16_t_s_s(0, ((p_39 > (((p_39 | (*l_378)) && l_374.f0) >= l_374.f2)) ^ g_113.f1)))))) > (-1));
    }
    else
    { /* block id: 224 */
        int32_t *l_392 = (void*)0;
        int32_t **l_393 = &g_99;
        (*l_393) = l_392;
        /* statement id: 225 */
        assert (g_99 == 0);
    }
    /* facts after branching */
    assert (g_99 == 0 || g_99 == &g_84);
    (*l_394) = (-1);
    (*l_398) = (func_60((((*l_394) & (safe_lshift_func_uint16_t_u_s((*l_394), 14))) , (&p_40 == (void*)0)), g_262.f2, p_40, l_397) , &p_40);
    /* statement id: 228 */
    assert (g_99 == &p_40);
    return p_39;
    /* statement id: 229 */
    //assert (g_99 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_99 g_84 g_113.f1 g_262.f1 g_262.f2 g_81.f0 g_80.f1 g_80 g_3 g_113.f2 g_81 g_113.f0 g_194 g_113 g_262.f0 g_367
 * writes: g_99 g_84 g_113.f1 g_262.f1 g_98 g_81 g_113 g_245 g_303
 */
static int16_t  func_41(const uint32_t  p_42, struct S0  p_43, uint16_t  p_44, uint32_t  p_45, int16_t  p_46)
{ /* block id: 145 */
    int32_t *l_264 = &g_84;
    int32_t **l_265 = (void*)0;
    int32_t **l_266 = &g_99;
    struct S0 *l_269 = &g_113;
    int32_t ** const ***l_333 = (void*)0;
    (*l_266) = l_264;
    /* statement id: 146 */
    assert (g_99 == &g_84);
    (*l_264) = ((void*)0 == &l_265);
    if (((*g_99) <= (((p_43.f2 <= ((safe_lshift_func_uint16_t_u_u(0xBC9D, 11)) & p_43.f0)) , (l_269 == (void*)0)) <= (**l_266))))
    { /* block id: 148 */
        int32_t l_289 = 0x0CF5E070;
        for (g_113.f1 = 0; (g_113.f1 > 44); g_113.f1 = safe_add_func_uint16_t_u_u(g_113.f1, 8))
        { /* block id: 151 */
            int32_t l_288 = 0;
            struct S0 l_298 = {0x28751E7A,65535U,2U};
            struct S0 l_299 = {0x69B939C0,0x9957,0xB83E};
            int32_t *l_317 = &g_84;
            for (p_43.f2 = (-1); (p_43.f2 >= 6); p_43.f2++)
            { /* block id: 154 */
                int32_t ** const *l_279 = (void*)0;
                int32_t ** const **l_278 = &l_279;
                struct S0 l_339 = {4294967295U,65527U,65535U};
                struct S0 l_346 = {0U,65533U,0x4821};
            }
            if (l_289)
                continue;
        }
        for (g_262.f1 = 12; (g_262.f1 <= 60); g_262.f1 = safe_add_func_uint32_t_u_u(g_262.f1, 4))
        { /* block id: 193 */
            uint16_t l_352 = 65535U;
            struct S0 l_355 = {0U,0x699D,0xBD61};
            (*g_99) = 0xB90FCD6B;
            if ((~g_262.f2))
            { /* block id: 195 */
                return g_81.f0;
            }
            else
            { /* block id: 197 */
                (*l_264) = func_56(((safe_add_func_uint16_t_u_u(g_80.f1, (9 | (((((p_44 >= l_352) ^ (safe_sub_func_uint16_t_u_u(__builtin_ffsl((l_355 , p_44)), (safe_add_func_int32_t_s_s(l_352, p_43.f0))))) , 0x7C4C) == g_113.f1) | p_42)))) ^ p_42));
                /* statement id: 198 */
                //assert (g_99 == 0 || g_99 == &g_84 || g_99 == dangling);
                return g_81.f0;
            }
        }
        for (g_81.f1 = 0; (g_81.f1 >= 17); g_81.f1 = safe_add_func_uint32_t_u_u(g_81.f1, 3))
        { /* block id: 204 */
            int32_t l_370 = (-1);
            (**l_266) = (((safe_rshift_func_uint16_t_u_u(((((*l_269) , ((~(__builtin_ia32_crc32qi((*l_264), g_80.f0) > ((safe_lshift_func_int16_t_s_u((((safe_add_func_int32_t_s_s((((g_262.f0 < ((((g_367 == &g_368) < ((4U <= (~g_262.f2)) , g_113.f0)) , 4U) <= p_43.f2)) <= 0xBA6C3AF9) | 0x218AC65C), 0xAF631810)) , g_113.f0) <= 0x996700F8), p_43.f0)) , g_113.f2))) == p_43.f0)) != p_43.f2) == p_46), p_46)) || (-1)) , 0x2F9BF1B5);
            if (l_370)
                continue;
        }
        (**l_266) = 0xDA96A55C;
    }
    else
    { /* block id: 209 */
        struct S0 *l_371 = &g_113;
        g_303 = l_371;
        /* statement id: 210 */
        assert (g_303 == &g_113);
    }
    p_43 = g_81;
    return g_262.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_47(uint32_t  p_48, uint32_t  p_49, int32_t  p_50, struct S0  p_51)
{ /* block id: 142 */
    int32_t l_263 = 1;
    l_263 = l_263;
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_80 g_84 g_3 g_113.f1 g_113.f2 g_81 g_99 g_113.f0 g_194
 * writes: g_84 g_113.f1 g_99 g_98 g_81 g_113 g_245
 */
inline static int16_t  func_56(uint16_t  p_57)
{ /* block id: 68 */
    int32_t *l_117 = &g_84;
    uint32_t l_118 = 0x88ECCDF3;
    struct S0 *l_168 = &g_81;
    int32_t l_193 = (-1);
    int16_t l_239 = (-1);
    if (p_57)
    { /* block id: 69 */
        int32_t *l_116 = &g_84;
        uint32_t l_125 = 0xC325DF25;
        int32_t **l_128 = &l_117;
        l_117 = l_116;
        (*l_116) = (l_118 >= ((g_80 , (safe_add_func_uint32_t_u_u((safe_add_func_uint16_t_u_u((g_80 , 65535U), p_57)), (((((((*l_117) > __builtin_parity((safe_lshift_func_int16_t_s_u((-4), ((p_57 > 65535U) == 0))))) && g_3) && l_125) >= 0x0697) ^ (*l_116)) | 5)))) <= p_57));
        for (g_113.f1 = 0; (g_113.f1 == 47); g_113.f1++)
        { /* block id: 74 */
            (*l_116) = (p_57 , (*l_117));
        }
        (*l_128) = l_117;
    }
    else
    { /* block id: 78 */
        struct S0 l_131 = {0x323B5E53,0x9B4D,0x16D4};
        int32_t *l_150 = &g_84;
        uint16_t l_176 = 0x2F31;
        int32_t ***l_236 = &g_98;
        int32_t ****l_235 = &l_236;
lbl_198:
        (*l_117) = (0x715C | (((safe_sub_func_uint32_t_u_u((((l_131 , l_117) == &g_84) >= (safe_lshift_func_int16_t_s_s(((0x596026DF ^ ((*l_117) ^ (((((g_80 , (!(-4))) , ((safe_mod_func_uint32_t_u_u((0x5926 && (-2)), 3U)) == g_113.f2)) < 0xDF17F541) ^ l_131.f1) >= p_57))) && (*l_117)), 8))), (*l_117))) >= 4294967295U) , p_57));
        if ((safe_mod_func_uint16_t_u_u(((safe_sub_func_uint16_t_u_u(6U, (-8))) > (l_131 , (*l_117))), (safe_add_func_uint16_t_u_u(p_57, (safe_unary_minus_func_uint32_t_u((*l_117))))))))
        { /* block id: 80 */
            uint32_t l_156 = 0U;
            struct S0 l_158 = {0xCA39D249,0U,65535U};
            for (g_113.f1 = 21; (g_113.f1 > 53); g_113.f1 = safe_add_func_uint32_t_u_u(g_113.f1, 6))
            { /* block id: 83 */
                int16_t l_159 = (-5);
                struct S0 *l_169 = &g_113;
                struct S0 **l_197 = &l_168;
                struct S0 ***l_196 = &l_197;
                for (p_57 = 0; (p_57 <= 1); p_57++)
                { /* block id: 86 */
                    int32_t **l_151 = &g_99;
                    struct S0 l_152 = {0x12C06D41,0xC1B3,1U};
                    (*l_151) = l_150;
                    /* statement id: 87 */
                    assert (g_99 == &g_84);
                    if (p_57)
                        continue;
                    if ((((func_75(l_152, g_81, ((!(safe_add_func_uint32_t_u_u((*l_150), l_156))) ^ g_3), l_158) ^ l_159) && g_80.f0) && (*g_99)))
                    { /* block id: 89 */
                        struct S0 *l_160 = &l_152;
                        int32_t l_161 = 0;
                        volatile struct S0 **l_170 = (void*)0;
                        volatile struct S0 *l_172 = &g_80;
                        volatile struct S0 **l_171 = &l_172;
                        (*l_160) = g_81;
                        (*l_171) = (((((l_161 && ((l_156 , (g_81.f2 , (void*)0)) != (((safe_lshift_func_int16_t_s_u((~((0x672896A2 || p_57) | (safe_lshift_func_uint16_t_u_s((!(((0x63B3E495 & ((l_168 != (((*l_117) < l_161) , l_169)) >= (*l_117))) , (*g_99)) || (**l_151))), 3)))), 7)) == 0xD3DACF38) , l_160))) <= 0xEC01) ^ p_57) , 0xB608) , &g_80);
                        (*l_151) = (((((0xF55A02C1 & (!(safe_lshift_func_uint16_t_u_u(65535U, 0)))) & (l_176 , 0x905C)) != l_158.f0) , p_57) , &l_161);
                        /* statement id: 92 */
                        assert (g_99 == &l_161);
                    }
                    else
                    { /* block id: 93 */
                        int32_t ***l_178 = (void*)0;
                        int32_t ****l_177 = &l_178;
                        struct S0 ****l_195 = (void*)0;
                        (*l_177) = &g_98;
                        /* statement id: 94 */
                        assert (l_178 == &g_98);
                        (**l_151) = (safe_rshift_func_int16_t_s_u((safe_add_func_uint16_t_u_u((safe_add_func_int16_t_s_s((((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(((func_60(l_159, g_113.f0, (safe_add_func_int16_t_s_s(__builtin_popcountl(p_57), ((p_57 != (safe_lshift_func_uint16_t_u_u(g_113.f0, 7))) < g_3))), g_80) & l_193) || 0x730F), p_57)), 1)) , 4294967292U) | p_57), g_113.f0)), p_57)), 1));
                        l_196 = g_194;
                        /* statement id: 96 */
                        assert (l_196 == 0);
                    }
                    /* facts after branching */
                    //assert (g_99 == &g_84 || g_99 == dangling);
                }
                /* facts after for loop */
                assert (l_196 == 0 || l_196 == &l_197);
                if (l_131.f1)
                    goto lbl_198;
            }
        }
        else
        { /* block id: 101 */
            const int32_t *l_199 = &g_84;
            const int32_t **l_200 = (void*)0;
            const int32_t **l_201 = &l_199;
            struct S0 l_219 = {0x55FCFD51,0x1E4F,0U};
            int32_t l_226 = 0x3B81CEEB;
            (*l_201) = l_199;
            (*l_150) = (p_57 > p_57);
            if ((~((safe_add_func_int32_t_s_s((((**l_201) ^ (func_58(g_81.f1) > p_57)) , (*l_150)), __builtin_popcount(__builtin_clz(((safe_lshift_func_uint16_t_u_s(7U, 14)) & (safe_sub_func_int16_t_s_s(g_3, ((safe_rshift_func_uint16_t_u_u(((*l_117) & g_84), p_57)) > p_57)))))))) > (*l_117))))
            { /* block id: 104 */
                struct S0 * const *l_213 = &l_168;
                struct S0 * const **l_212 = &l_213;
                struct S0 * const ***l_211 = &l_212;
                struct S0 * const ****l_214 = &l_211;
                (*l_214) = l_211;
                (*l_150) = __builtin_popcount(((func_58((((2 > (safe_lshift_func_int16_t_s_u(((*l_150) , p_57), (safe_sub_func_uint16_t_u_u(g_113.f1, (l_219 , 65535U)))))) != ((**l_212) == &l_131)) || (((safe_rshift_func_uint16_t_u_u(func_75(l_131, l_219, g_80.f0, (*l_168)), p_57)) < (*l_150)) , p_57))) , (*l_117)) != 0U));
            }
            else
            { /* block id: 107 */
                uint32_t l_240 = 0xB7566744;
                int32_t l_244 = 0xF3958A3B;
                struct S0 ****l_261 = &g_194;
                struct S0 *****l_260 = &l_261;
                (*l_117) = (**l_201);
                if (p_57)
                { /* block id: 109 */
                    int32_t ****l_222 = (void*)0;
                    int32_t *l_225 = &g_84;
                    if (p_57)
                    { /* block id: 110 */
                        int32_t *****l_223 = (void*)0;
                        int32_t *****l_224 = &l_222;
                        (*l_224) = l_222;
                        (*l_201) = l_225;
                        l_226 = (*l_150);
                        (*l_201) = l_225;
                    }
                    else
                    { /* block id: 115 */
                        int16_t l_227 = 0x1EFE;
                        const int32_t ***l_238 = &l_200;
                        const int32_t ****l_237 = &l_238;
                        struct S0 *l_241 = &l_219;
                        l_227 = p_57;
                        (*l_117) = (safe_unary_minus_func_int16_t_s(((__builtin_bswap32(((((safe_sub_func_int16_t_s_s(0x5227, ((safe_sub_func_uint16_t_u_u((*l_150), __builtin_clz(p_57))) == func_60(__builtin_ctzll((((safe_rshift_func_int16_t_s_u(__builtin_ffs((*l_117)), (l_235 != l_237))) < g_81.f0) , l_239)), (*l_225), g_81.f2, l_219)))) || g_113.f2) && p_57) , 4294967294U)) > (*l_199)) > l_240)));
                        l_241 = l_168;
                        /* statement id: 118 */
                        assert (l_241 == &g_81);
                        (*l_168) = l_131;
                    }
                    for (p_57 = 0; (p_57 == 47); p_57 = safe_add_func_int32_t_s_s(p_57, 1))
                    { /* block id: 123 */
                        l_244 = (-1);
                        (*l_201) = (*l_201);
                        return g_80.f1;
                    }
                    g_245 = &l_222;
                    /* statement id: 128 */
                    assert (g_245 == &l_222);
                }
                else
                { /* block id: 129 */
                    uint32_t l_252 = 4294967291U;
                    if (((safe_add_func_int32_t_s_s((p_57 > (safe_sub_func_int32_t_s_s(__builtin_parityll(p_57), ((((safe_rshift_func_uint16_t_u_s(0xA7F0, 14)) >= l_252) != ((safe_lshift_func_uint16_t_u_u(((__builtin_popcountll(l_240) , (((safe_add_func_uint32_t_u_u(l_252, p_57)) , 0x5B51C376) & 0x5E0AD077)) <= (-4)), 6)) | p_57)) < 1U)))), 0x6F29B824)) , 0x278546D8))
                    { /* block id: 130 */
                        struct S0 **l_257 = &l_168;
                        (*l_257) = l_168;
                        (*l_201) = l_117;
                    }
                    else
                    { /* block id: 133 */
                        struct S0 ****l_259 = &g_194;
                        struct S0 *****l_258 = &l_259;
                        (*l_258) = &g_194;
                    }
                }
                (*l_117) = ((void*)0 == l_260);
            }
        }
    }
    return g_81.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_80 g_81.f0 g_81
 * writes: g_99 g_81.f0 g_113 g_81
 */
inline static uint16_t  func_58(int16_t  p_59)
{ /* block id: 48 */
    uint32_t l_103 = 0U;
    int32_t l_104 = (-1);
    struct S0 l_114 = {1U,8U,65535U};
    struct S0 *l_115 = &g_81;
    if (l_103)
    { /* block id: 49 */
        volatile struct S0 l_105 = {4294967295U,0x2365,3U};/* VOLATILE GLOBAL l_105 */
        int32_t *l_106 = (void*)0;
        int32_t **l_107 = &g_99;
        l_104 = p_59;
        l_105 = g_80;
        (*l_107) = l_106;
        /* statement id: 52 */
        assert (g_99 == 0);
    }
    else
    { /* block id: 53 */
        return l_104;
    }
    /* facts after branching */
    assert (g_99 == 0);
    for (g_81.f0 = 28; (g_81.f0 >= 12); g_81.f0 = safe_sub_func_int32_t_s_s(g_81.f0, 2))
    { /* block id: 58 */
        for (l_103 = 0; (l_103 == 27); l_103 = safe_add_func_uint32_t_u_u(l_103, 3))
        { /* block id: 61 */
            struct S0 *l_112 = &g_113;
            (*l_112) = g_81;
            (*l_112) = g_80;
        }
    }
    (*l_115) = l_114;
    return g_81.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_81
 * writes: g_98 g_81
 */
inline static int16_t  func_60(int32_t  p_61, uint16_t  p_62, const uint16_t  p_63, struct S0  p_64)
{ /* block id: 44 */
    int32_t ***l_100 = &g_98;
    struct S0 *l_101 = (void*)0;
    struct S0 *l_102 = &g_81;
    (*l_100) = (void*)0;
    /* statement id: 45 */
    assert (g_98 == 0);
    (*l_102) = g_81;
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads : g_98 g_81.f1
 * writes: g_99
 */
inline static int16_t  func_71(int32_t  p_72)
{ /* block id: 41 */
    int32_t l_97 = (-6);
    (*g_98) = (((safe_rshift_func_int16_t_s_s((((safe_unary_minus_func_int16_t_s((safe_sub_func_uint32_t_u_u(p_72, (safe_lshift_func_int16_t_s_s(p_72, 10)))))) | ((safe_rshift_func_int16_t_s_s((-1), 13)) , (-1))) , ((~((l_97 , &g_84) == &g_84)) ^ (g_98 != &g_99))), 1)) & g_81.f1) , &l_97);
    /* statement id: 42 */
    assert (g_99 == &l_97);
    return l_97;
    /* statement id: 43 */
    //assert (g_99 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_75(struct S0  p_76, struct S0  p_77, int16_t  p_78, struct S0  p_79)
{ /* block id: 37 */
    int32_t *l_83 = &g_84;
    int32_t **l_85 = &l_83;
    int32_t l_86 = 0x68E480B0;
    (*l_85) = l_83;
    (*l_85) = (*l_85);
    return l_86;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_80.f0, "g_80.f0", print_hash_value);
    transparent_crc(g_80.f1, "g_80.f1", print_hash_value);
    transparent_crc(g_80.f2, "g_80.f2", print_hash_value);
    transparent_crc(g_81.f0, "g_81.f0", print_hash_value);
    transparent_crc(g_81.f1, "g_81.f1", print_hash_value);
    transparent_crc(g_81.f2, "g_81.f2", print_hash_value);
    transparent_crc(g_84, "g_84", print_hash_value);
    transparent_crc(g_113.f0, "g_113.f0", print_hash_value);
    transparent_crc(g_113.f1, "g_113.f1", print_hash_value);
    transparent_crc(g_113.f2, "g_113.f2", print_hash_value);
    transparent_crc(g_262.f0, "g_262.f0", print_hash_value);
    transparent_crc(g_262.f1, "g_262.f1", print_hash_value);
    transparent_crc(g_262.f2, "g_262.f2", print_hash_value);
    transparent_crc(g_399, "g_399", print_hash_value);
    transparent_crc(g_402, "g_402", print_hash_value);
    transparent_crc(g_424, "g_424", print_hash_value);
    transparent_crc(g_448, "g_448", print_hash_value);
    transparent_crc(g_459, "g_459", print_hash_value);
    transparent_crc(g_481, "g_481", print_hash_value);
    transparent_crc(g_562, "g_562", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 143
   depth: 1, occurrence: 31
XXX total union variables: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 126
   depth: 2, occurrence: 15
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 138

XXX times a variable address is taken: 137
XXX times a pointer is dereferenced on RHS: 78
breakdown:
   depth: 1, occurrence: 66
   depth: 2, occurrence: 12
XXX times a pointer is dereferenced on LHS: 83
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 573

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 656
   level: 2, occurrence: 116
   level: 3, occurrence: 41
   level: 4, occurrence: 38
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 86
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 23
XXX percent of pointers has null in alias set: 29.7
XXX average alias set size: 1.21

XXX times a non-volatile is read: 698
XXX times a non-volatile is write: 242
XXX times a volatile is read: 30
XXX    times read thru a pointer: 0
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 287
XXX percentage of non-volatile access: 96.8

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 21
   depth: 2, occurrence: 14
   depth: 3, occurrence: 10
   depth: 4, occurrence: 7
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
********************* end of statistics **********************/

