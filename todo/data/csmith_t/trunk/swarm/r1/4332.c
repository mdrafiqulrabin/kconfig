/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3422588584
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_13 = 0x1AC48889L;
static int32_t *g_62 = &g_13;
static int32_t **g_61 = &g_62;
static int32_t ***g_60 = &g_61;
static int32_t g_68 = 3L;
static int32_t g_75 = 0x9242039CL;
static uint64_t g_77 = 18446744073709551615UL;
static uint16_t g_81 = 0xEE1EL;
static uint32_t g_89 = 0x120B2523L;
static int32_t g_93 = 9L;
static uint32_t g_98 = 0xBC4638B1L;
static int16_t g_126 = (-2L);
static uint16_t *g_193 = &g_81;
static uint16_t **g_192 = &g_193;
static float g_195 = 0xE.1A35A1p+10;
static uint32_t g_197 = 1UL;
static uint32_t *g_222 = &g_197;
static uint32_t **g_221 = &g_222;
static int32_t g_242 = 0xB8D76940L;
static int64_t g_254 = 0L;
static float g_308 = 0xE.B9AC39p+90;
static int16_t g_319 = (-1L);
static volatile uint16_t g_322 = 0x9DB4L;/* VOLATILE GLOBAL g_322 */
static const uint64_t g_360 = 18446744073709551609UL;
static const int32_t g_365 = 0xC696D4DFL;
static uint16_t g_404 = 0x16DBL;
static uint64_t g_406 = 0x75902A8F9CB82273LL;
static int32_t g_408 = 1L;


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
inline static uint16_t  func_4(uint64_t  p_5, int32_t  p_6, uint32_t  p_7);
static int32_t ** func_14(uint32_t  p_15, int32_t  p_16, int32_t ** p_17, uint32_t  p_18);
inline static uint32_t  func_19(int32_t ** p_20, const int32_t ** p_21);
static const int32_t ** func_25(uint32_t  p_26, int32_t  p_27);
static const uint64_t  func_28(int32_t ** p_29, const int32_t  p_30);
inline static int64_t  func_33(int8_t  p_34);
static const uint64_t  func_42(int32_t ** p_43, uint16_t  p_44, uint16_t  p_45, int32_t ** p_46, uint64_t  p_47);
inline static int32_t ** func_48(int32_t  p_49, uint64_t  p_50, int32_t * p_51, int32_t *** p_52);
static uint32_t  func_53(const uint16_t  p_54, int32_t *** p_55, int32_t *** p_56, uint64_t  p_57, int32_t * p_58);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_13 g_98 g_126 g_193 g_81 g_222 g_77 g_61 g_62 g_319 g_242 g_89 g_322 g_68 g_192 g_197 g_221 g_93 g_60 g_75 g_365 g_408
 * writes: g_13 g_197 g_93 g_60 g_61 g_319 g_242 g_75 g_193 g_195 g_404 g_406 g_408
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int16_t l_8 = 0x56A9L;
    int32_t *l_12 = &g_13;
    int8_t l_402 = 4L;
    uint16_t *l_403 = &g_404;
    uint64_t *l_405 = &g_406;
    int32_t *l_407 = &g_408;
    (*l_407) &= (safe_lshift_func_uint16_t_u_s(func_4(l_8, ((*l_12) |= ((!1UL) == 0UL)), l_8), (safe_mod_func_uint64_t_u_u(((*l_405) = (((*l_403) = (safe_mod_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(1UL, (safe_mod_func_uint16_t_u_u(((-1L) < ((safe_sub_func_uint16_t_u_u(l_8, (&g_126 == &l_8))) < l_8)), l_402)))), g_365))) ^ 0x47ABL)), 18446744073709551608UL))));
    /* statement id: 239 */
    //assert (g_60 == dangling);
    return (*l_407);
}


/* ------------------------------------------ */
/* 
 * reads : g_13 g_98 g_126 g_193 g_81 g_222 g_77 g_61 g_62 g_319 g_242 g_89 g_322 g_68 g_192 g_197 g_221 g_93 g_60 g_75
 * writes: g_197 g_93 g_60 g_61 g_319 g_242 g_75 g_193 g_13 g_195
 */
inline static uint16_t  func_4(uint64_t  p_5, int32_t  p_6, uint32_t  p_7)
{ /* block id: 2 */
    int32_t *l_23 = &g_13;
    int32_t **l_22 = &l_23;
    int32_t ***l_24 = &l_22;
    uint32_t ***l_316 = &g_221;
    int32_t *l_317 = &g_93;
    int16_t *l_318 = &g_319;
    const int32_t *l_364 = &g_365;
    const int32_t **l_363 = &l_364;
    const int32_t ***l_362 = &l_363;
    (*l_24) = func_14(func_19(((*l_24) = l_22), ((*l_362) = func_25(p_6, (((g_13 | (func_28(&l_23, ((((safe_rshift_func_uint16_t_u_u((func_33((~p_5)) <= g_126), 0)) | ((*l_318) |= ((g_61 = func_48(((*l_317) = (((safe_sub_func_uint32_t_u_u(((*g_222) = (safe_rshift_func_int16_t_s_u(((~0x0CC2756EL) && (l_316 != &g_221)), (*g_193)))), 0xC9A4B138L)) <= 65527UL) && g_77)), g_81, (*g_61), l_24)) != &g_62))) <= p_5) != g_242)) >= g_89)) == g_322) || (*l_23))))), g_68, &l_317, p_5);
    /* statement id: 235 */
    assert (l_22 == &l_317);
    assert (g_60 == &l_22);
    assert (l_363 == 0);
    return p_5;
    /* statement id: 236 */
    //assert (g_60 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_81 g_62 g_13 g_68 g_192 g_193 g_242 g_197 g_61 g_221 g_222 g_93 g_89
 * writes: g_197 g_75 g_319 g_193 g_13 g_242 g_195
 */
static int32_t ** func_14(uint32_t  p_15, int32_t  p_16, int32_t ** p_17, uint32_t  p_18)
{ /* block id: 228 */
    const int32_t **l_385 = (void*)0;
    const int32_t ***l_384 = &l_385;
    float *l_386 = &g_195;
    uint16_t *l_387 = (void*)0;
    uint16_t *l_389 = &g_81;
    uint16_t **l_388 = &l_389;
    int32_t l_390 = 0x1A7FB561L;
    int32_t l_391 = 0xE0E8798EL;
    l_391 = (safe_sub_func_float_f_f(((safe_div_func_float_f_f((((*l_384) = func_25(g_81, (*g_62))) != (void*)0), ((l_390 = (((*l_386) = ((void*)0 != &g_222)) <= (l_387 == ((*l_388) = l_387)))) < 0x0.Dp+1))) > g_89), 0x0.Fp+1));
    /* statement id: 233 */
    assert (l_389 == 0);
    return p_17;
    /* statement id: 234 */
    //assert (func_14_rv == &l_317);
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_62 g_13 g_60 g_222 g_197 g_75 g_89
 * writes: g_75 g_13
 */
inline static uint32_t  func_19(int32_t ** p_20, const int32_t ** p_21)
{ /* block id: 222 */
    float *l_370 = &g_308;
    const int64_t *l_373 = &g_254;
    int32_t l_374 = 0x8D5EF94FL;
    int32_t *l_375 = &g_75;
    int32_t ****l_379 = &g_60;
    int32_t *****l_378 = &l_379;
    (*l_375) &= ((((safe_add_func_int64_t_s_s((-4L), (safe_div_func_int16_t_s_s(((l_370 != (void*)0) || (**g_61)), 8L)))) <= 7UL) == (safe_sub_func_uint64_t_u_u((((&g_254 != l_373) == (((*g_62) > 0xF047D995L) <= (***g_60))) < (*g_222)), l_374))) <= (-7L));
    (**g_61) &= (g_89 & (safe_sub_func_int32_t_s_s(((l_378 = l_378) != &l_379), 0x839C4DF7L)));
    (**g_60) = (****l_378);
    return (*****l_378);
}


/* ------------------------------------------ */
/* 
 * reads : g_68 g_192 g_193 g_242 g_197 g_62 g_13 g_61 g_221 g_222 g_93
 * writes: g_197 g_75 g_319 g_193 g_13 g_242
 */
static const int32_t ** func_25(uint32_t  p_26, int32_t  p_27)
{ /* block id: 182 */
    int8_t l_329 = (-1L);
    const uint64_t *l_359 = &g_360;
    const int32_t **l_361 = (void*)0;
    for (p_27 = (-2); (p_27 != (-25)); p_27 = safe_sub_func_int16_t_s_s(p_27, 1))
    { /* block id: 185 */
        uint32_t l_327 = 4294967292UL;
        const int32_t *l_349 = &g_93;
        const int32_t **l_348 = &l_349;
        for (g_197 = 0; (g_197 > 45); g_197 = safe_add_func_int16_t_s_s(g_197, 4))
        { /* block id: 188 */
            int16_t *l_328 = (void*)0;
            const uint16_t *l_344 = &g_81;
            const int32_t **l_351 = (void*)0;
            int32_t *l_352 = &g_242;
            if ((65535UL | (l_329 = (p_27 == (g_68 == l_327)))))
            { /* block id: 190 */
                const int32_t **l_350 = &l_349;
                for (g_75 = 0; (g_75 <= 10); g_75 = safe_add_func_uint16_t_u_u(g_75, 2))
                { /* block id: 193 */
                    const uint64_t l_345 = 9UL;
                    for (g_319 = 4; (g_319 < 14); g_319 = safe_add_func_uint64_t_u_u(g_319, 2))
                    { /* block id: 196 */
                        (*g_62) |= (0UL || (~(safe_add_func_int16_t_s_s((safe_add_func_uint32_t_u_u((((safe_rshift_func_uint16_t_u_s(((0x3BE05BE5L <= (4294967288UL > 0xC57D9547L)) && (~9L)), 12)) | (l_327 != ((((l_344 == ((*g_192) = (*g_192))) ^ (g_242 ^ g_197)) >= 0xBA95D1FD82234803LL) < l_329))) != 1UL), p_26)), l_345))));
                    }
                    if ((*g_62))
                        continue;
                    for (g_242 = (-17); (g_242 != 20); g_242 = safe_add_func_uint32_t_u_u(g_242, 1))
                    { /* block id: 203 */
                        (*g_62) |= p_27;
                        (**g_61) = p_26;
                        return l_351;
                        /* statement id: 206 */
                        //assert (func_25_rv == 0);
                    }
                    (*l_348) = (l_352 = &p_27);
                    /* statement id: 209 */
                    assert (l_349 == &p_27);
                    assert (l_352 == &p_27);
                }
                /* facts after for loop */
                assert (l_352 == &p_27 || l_352 == &g_242);
                if (p_26)
                    break;
                (*g_62) ^= (-8L);
            }
            else
            { /* block id: 213 */
                uint64_t **l_356 = (void*)0;
                uint64_t *l_358 = &g_77;
                uint64_t **l_357 = &l_358;
                (**g_61) = (((!(**g_221)) | (*l_349)) > (((*l_357) = &g_77) != (l_359 = &g_77)));
                /* statement id: 216 */
                assert (l_359 == &g_77);
            }
            /* facts after branching */
            assert (l_352 == &p_27 || l_352 == &g_242);
        }
        /* facts after for loop */
        assert (l_349 == &p_27 || l_349 == &g_93);
    }
    /* facts after for loop */
    assert (l_359 == &g_77 || l_359 == &g_360);
    return l_361;
    /* statement id: 220 */
    //assert (func_25_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_242
 * writes: g_242
 */
static const uint64_t  func_28(int32_t ** p_29, const int32_t  p_30)
{ /* block id: 178 */
    int32_t ****l_320 = &g_60;
    int32_t *l_321 = &g_242;
    (*l_321) &= (l_320 != (void*)0);
    (*l_321) = (-5L);
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads : g_98
 * writes:
 */
inline static int64_t  func_33(int8_t  p_34)
{ /* block id: 4 */
    const uint32_t l_59 = 0x3F2A6ADDL;
    int32_t ***l_63 = (void*)0;
    int32_t *l_65 = &g_13;
    int8_t l_236 = 0xE3L;
    int32_t *l_237 = &g_68;
    int32_t *l_238 = (void*)0;
    int32_t *l_239 = (void*)0;
    int32_t *l_240 = (void*)0;
    int32_t *l_241 = &g_242;
    uint16_t *l_263 = &g_81;
    int32_t *l_269 = (void*)0;
    return g_98;
}


/* ------------------------------------------ */
/* 
 * reads : g_62
 * writes: g_62
 */
static const uint64_t  func_42(int32_t ** p_43, uint16_t  p_44, uint16_t  p_45, int32_t ** p_46, uint64_t  p_47)
{ /* block id: 100 */
    (*p_46) = (*p_43);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_60
 */
inline static int32_t ** func_48(int32_t  p_49, uint64_t  p_50, int32_t * p_51, int32_t *** p_52)
{ /* block id: 96 */
    int32_t *l_233 = &g_93;
    int32_t ****l_234 = (void*)0;
    int32_t ****l_235 = &g_60;
    l_233 = (void*)0;
    /* statement id: 97 */
    assert (l_233 == 0);
    (*l_235) = p_52;
    /* statement id: 98 */
    //assert (g_60 == 0 || g_60 == &l_22);
    return &g_62;
    /* statement id: 99 */
    //assert (func_48_rv == &g_62);
}


/* ------------------------------------------ */
/* 
 * reads : g_68 g_61 g_75 g_62 g_13 g_93 g_98 g_126 g_77 g_60 g_81 g_192 g_197 g_221 g_222
 * writes: g_68 g_75 g_77 g_81 g_89 g_93 g_62 g_126 g_98 g_195 g_197 g_60 g_221
 */
static uint32_t  func_53(const uint16_t  p_54, int32_t *** p_55, int32_t *** p_56, uint64_t  p_57, int32_t * p_58)
{ /* block id: 5 */
    int64_t l_73 = 6L;
    int32_t ****l_103 = &g_60;
    int32_t ****l_111 = &g_60;
    int32_t l_116 = 0x5C685B35L;
    uint16_t *l_168 = &g_81;
    uint32_t l_184 = 1UL;
    float l_196 = 0x7.7B2E30p-99;
    int8_t l_213 = 0x45L;
    for (p_57 = 0; (p_57 <= 46); p_57 = safe_add_func_int64_t_s_s(p_57, 1))
    { /* block id: 8 */
        const int32_t *l_72 = &g_68;
        const int32_t **l_71 = &l_72;
        int32_t *l_94 = &g_13;
        for (g_68 = (-2); (g_68 <= 18); g_68 = safe_add_func_int64_t_s_s(g_68, 6))
        { /* block id: 11 */
            int32_t *l_74 = &g_75;
            int32_t l_121 = 0xA0AE8917L;
            const int32_t ***l_217 = &l_71;
            const int32_t ****l_216 = &l_217;
            const int32_t *****l_215 = &l_216;
            int32_t l_232 = 0x66B95E14L;
            if (((*l_74) = (((*p_55) == (l_71 = l_71)) == l_73)))
            { /* block id: 14 */
                uint64_t *l_76 = &g_77;
                int32_t ***l_85 = &g_61;
                const int16_t l_90 = 0x0C28L;
                int16_t l_91 = 0L;
                int32_t l_102 = 3L;
                int32_t *****l_104 = &l_103;
                if ((((*l_76) = (0x202F603F559CDE89LL && g_75)) != g_68))
                { /* block id: 16 */
                    uint16_t *l_80 = &g_81;
                    int32_t ****l_86 = &l_85;
                    uint32_t *l_87 = (void*)0;
                    uint32_t *l_88 = &g_89;
                    int32_t *l_92 = &g_93;
                    (*l_92) &= (safe_sub_func_int32_t_s_s((((((*l_80) = 65535UL) > ((~l_73) && (***p_55))) <= (safe_rshift_func_int16_t_s_u((((((*l_86) = l_85) != &g_61) < ((*l_88) = p_57)) && (((*l_76) = g_75) ^ 0xFBB05D09421A0E57LL)), 1))) || l_90), l_91));
                    (***l_86) = l_94;
                }
                else
                { /* block id: 23 */
                    int8_t l_95 = (-6L);
                    l_95 ^= (*g_62);
                }
                for (l_91 = (-4); (l_91 >= 15); l_91 = safe_add_func_int64_t_s_s(l_91, 1))
                { /* block id: 28 */
                    return g_98;
                }
                l_116 = (safe_sub_func_int64_t_s_s(((~l_102) > (((*l_104) = l_103) == (void*)0)), (safe_add_func_uint64_t_u_u((((*l_94) ^ (safe_add_func_uint32_t_u_u(((safe_sub_func_uint16_t_u_u((l_111 == &g_60), (((safe_add_func_uint16_t_u_u((safe_div_func_int16_t_s_s(7L, 65535UL)), 1L)) != p_54) && p_57))) >= g_75), (**g_61)))) >= (-1L)), g_13))));
            }
            else
            { /* block id: 33 */
                int16_t *l_125 = &g_126;
                int32_t l_135 = 0x1A24168CL;
                int32_t *l_136 = &l_116;
                int64_t *l_154 = &l_73;
                uint32_t *l_155 = (void*)0;
                uint32_t *l_156 = (void*)0;
                uint32_t *l_157 = &g_89;
                uint16_t *l_158 = &g_81;
                uint32_t *l_159 = &g_98;
                int32_t ***l_228 = &g_61;
                (*l_136) ^= (safe_add_func_uint32_t_u_u((safe_div_func_uint32_t_u_u(l_121, (safe_lshift_func_uint16_t_u_s((((safe_unary_minus_func_int16_t_s(((*l_125) ^= 0x7891L))) || (((safe_mod_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(p_57, 4)), g_77)) != (*l_74)) != ((safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((****l_103), 4)), (*l_74))) == 1L))) || l_135), (*l_74))))), 3UL));
                (*g_61) = (**g_60);
                if ((((*l_159) = (safe_lshift_func_uint16_t_u_s(((safe_div_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((safe_sub_func_int64_t_s_s((!(safe_lshift_func_uint16_t_u_s(((*l_158) = (((*l_74) >= (((((*l_157) = (safe_lshift_func_int16_t_s_s((*l_74), ((((((safe_mod_func_uint16_t_u_u((****l_111), (p_57 | (((*l_154) = (safe_sub_func_int16_t_s_s(((*l_136) & ((*l_125) |= g_77)), (&g_77 != &p_57)))) & p_54)))) >= (*g_62)) | (***p_55)) == 7L) & 18446744073709551609UL) >= (*l_136))))) > 4294967295UL) != 0xC377822EL) || 0x48307115L)) <= p_57)), (*l_136)))), g_68)), (****l_111))), (*l_94))) != 0x24BAAF50L), p_57))) ^ g_13))
                { /* block id: 42 */
                    uint16_t **l_169 = &l_158;
                    int32_t l_170 = 0L;
                    int32_t l_171 = 0xC0D59BB7L;
                    int32_t **l_178 = &l_94;
                    const int32_t *****l_218 = &l_216;
                    int32_t ***l_220 = &g_61;
                    int32_t ****l_219 = &l_220;
                    if ((((l_171 &= (safe_lshift_func_int16_t_s_s(0L, (((void*)0 == p_58) == (safe_lshift_func_int16_t_s_s((5UL & (1L > (safe_mod_func_int32_t_s_s(((g_77 | (safe_add_func_int64_t_s_s(p_54, (((((*l_169) = l_168) != (void*)0) && (*l_94)) || l_170)))) >= (*g_62)), 0x1ECA9F70L)))), 15)))))) != 1L) == 1UL))
                    { /* block id: 45 */
                        return p_54;
                    }
                    else
                    { /* block id: 47 */
                        uint32_t *l_181 = (void*)0;
                        uint32_t **l_182 = &l_157;
                        uint64_t *l_183 = &g_77;
                        float *l_194 = &g_195;
                        int32_t l_206 = 0x979D12DCL;
                        uint32_t ***l_211 = (void*)0;
                        uint32_t ***l_212 = &l_182;
                        int32_t *****l_214 = (void*)0;
                        l_184 = (((0xDDA491F1F153C6A9LL < (g_13 != 0xED364FFCL)) == (***p_55)) || (safe_add_func_uint64_t_u_u((((safe_mod_func_uint64_t_u_u(((*l_183) |= (~(!((****l_111) | (((l_178 = (*g_60)) != (*p_55)) & (safe_add_func_uint64_t_u_u((((((*l_182) = l_181) == (void*)0) < p_54) <= (-4L)), 0xF6226F77E7A5B985LL))))))), 18446744073709551612UL)) | p_54) ^ p_57), g_81)));
                        /* statement id: 51 */
                        assert (l_157 == &g_89 || l_157 == 0);
                        assert (l_178 == &l_94 || l_178 == &g_62);
                        g_197 = (0xD.6C93ECp-95 >= ((*l_136) <= (-((((safe_add_func_float_f_f((safe_add_func_float_f_f((safe_add_func_float_f_f(((*l_194) = ((g_192 == (void*)0) <= g_81)), (*l_136))), ((0x7.8F49FFp-43 != ((0x3.6211E3p-47 >= l_196) != 0xB.696208p+5)) != (*l_72)))), g_81)) <= p_57) >= 0xE.7BD33Cp-50) < 0x0.Dp-1))));
                        (*l_74) = (safe_rshift_func_uint16_t_u_u(((safe_sub_func_uint32_t_u_u(p_57, ((safe_rshift_func_uint16_t_u_u((((*l_74) != (l_213 |= ((***g_60) > (safe_div_func_int64_t_s_s(((**l_178) == l_206), ((safe_mod_func_int64_t_s_s((8L ^ (((((*l_212) = &l_181) != (void*)0) || ((***l_103) != (*g_61))) == p_57)), g_81)) || l_206)))))) && (**l_178)), 13)) & 65535UL))) < 0xCBE003A25DF1CAE4LL), 1));
                        /* statement id: 56 */
                        assert (l_182 == &l_181);
                        (*l_74) ^= (((*l_159) = (l_214 != (l_218 = l_215))) && ((((*l_159) = g_197) >= 0x0378A6B1L) < (***g_60)));
                    }
                    /* facts after branching */
                    assert (l_157 == &g_89 || l_157 == 0);
                    assert (l_178 == &l_94 || l_178 == &g_62);
                    if ((((*l_103) = &g_61) == ((*l_219) = &g_61)))
                    { /* block id: 64 */
                        uint32_t ***l_223 = &g_221;
                        uint32_t **l_225 = (void*)0;
                        uint32_t ***l_224 = &l_225;
                        (**g_60) = (***l_103);
                        (*l_224) = ((*l_223) = g_221);
                        /* statement id: 67 */
                        assert (l_225 == &g_222);
                    }
                    else
                    { /* block id: 68 */
                        return (**l_71);
                    }
                    for (g_81 = 0; (g_81 <= 23); g_81 = safe_add_func_int32_t_s_s(g_81, 1))
                    { /* block id: 73 */
                        l_171 ^= (l_228 == &g_61);
                    }
                    for (g_93 = 0; (g_93 > 18); g_93 = safe_add_func_int64_t_s_s(g_93, 1))
                    { /* block id: 78 */
                        if ((***p_55))
                            break;
                        (*l_178) = (**l_228);
                        (****l_215) = ((***l_111) = (**g_60));
                        /* statement id: 82 */
                        assert (l_72 == &g_13);
                    }
                }
                else
                { /* block id: 84 */
                    const int32_t *l_231 = &g_68;
                    (****l_215) = l_231;
                    /* statement id: 85 */
                    assert (l_72 == &g_68);
                    if ((**l_71))
                        break;
                }
                /* facts after branching */
                assert (l_157 == &g_89 || l_157 == 0);
            }
            (*l_74) = l_232;
            (***l_111) = (*g_61);
        }
        /* facts after for loop */
        assert (l_72 == &g_13 || l_72 == &g_68);
        if ((***g_60))
            continue;
    }
    (**p_55) = (**g_60);
    return (**g_221);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_13, "g_13", print_hash_value);
    transparent_crc(g_68, "g_68", print_hash_value);
    transparent_crc(g_75, "g_75", print_hash_value);
    transparent_crc(g_77, "g_77", print_hash_value);
    transparent_crc(g_81, "g_81", print_hash_value);
    transparent_crc(g_89, "g_89", print_hash_value);
    transparent_crc(g_93, "g_93", print_hash_value);
    transparent_crc(g_98, "g_98", print_hash_value);
    transparent_crc(g_126, "g_126", print_hash_value);
    transparent_crc_bytes (&g_195, sizeof(g_195), "g_195", print_hash_value);
    transparent_crc(g_197, "g_197", print_hash_value);
    transparent_crc(g_242, "g_242", print_hash_value);
    transparent_crc(g_254, "g_254", print_hash_value);
    transparent_crc_bytes (&g_308, sizeof(g_308), "g_308", print_hash_value);
    transparent_crc(g_319, "g_319", print_hash_value);
    transparent_crc(g_322, "g_322", print_hash_value);
    transparent_crc(g_360, "g_360", print_hash_value);
    transparent_crc(g_365, "g_365", print_hash_value);
    transparent_crc(g_404, "g_404", print_hash_value);
    transparent_crc(g_406, "g_406", print_hash_value);
    transparent_crc(g_408, "g_408", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 79
XXX total union variables: 0

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 15
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 30, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 120
XXX times a pointer is dereferenced on RHS: 77
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 14
   depth: 3, occurrence: 10
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 91
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 378

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 347
   level: 2, occurrence: 76
   level: 3, occurrence: 58
   level: 4, occurrence: 36
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 60
XXX number of pointers point to scalars: 71
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26
XXX average alias set size: 1.14

XXX times a non-volatile is read: 393
XXX times a non-volatile is write: 239
XXX times a volatile is read: 1
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 20
XXX percentage of non-volatile access: 99.8

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 71
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 24
   depth: 1, occurrence: 3
   depth: 2, occurrence: 4
   depth: 3, occurrence: 10
   depth: 4, occurrence: 14
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 23
XXX percentage an existing variable is used: 77
********************* end of statistics **********************/

