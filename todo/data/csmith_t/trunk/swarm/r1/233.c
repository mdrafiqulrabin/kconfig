/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3738025184
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint8_t  f1;
   const int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_12 = 1;
static const struct S0 g_40 = {0xDAE974CA,0x79,0};
static volatile uint16_t g_42 = 65534U;/* VOLATILE GLOBAL g_42 */
static int16_t g_75 = (-10);
static int16_t g_128 = (-1);
static uint8_t g_154 = 0x79;
static int32_t g_162 = (-3);
static uint8_t g_209 = 4U;
static volatile int32_t g_211 = 0x2692C927;/* VOLATILE GLOBAL g_211 */
static volatile uint32_t g_212 = 3U;/* VOLATILE GLOBAL g_212 */
static int32_t g_291 = 0xB915A60A;
static volatile uint8_t g_317 = 0xCC;/* VOLATILE GLOBAL g_317 */
static int16_t g_369 = 0x0B09;
static int32_t g_399 = (-1);


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_30(void);
inline static uint16_t  func_35(const struct S0  p_36, int32_t  p_37, int32_t  p_38, int32_t  p_39);
static const int16_t  func_46(struct S0  p_47, int16_t  p_48);
inline static const uint32_t  func_53(uint32_t  p_54, uint32_t  p_55, const int32_t  p_56, const uint32_t  p_57);
inline static uint16_t  func_58(uint32_t  p_59);
inline static uint16_t  func_70(int16_t  p_71);
inline static int16_t  func_85(int32_t  p_86);
static int32_t  func_90(uint8_t  p_91);
inline static uint16_t  func_92(struct S0  p_93, uint32_t  p_94);
inline static const struct S0  func_102(int16_t  p_103, uint8_t  p_104, uint32_t  p_105);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_40 g_42 g_75 g_128 g_154 g_162 g_209 g_212 g_211 g_291 g_317 g_369 g_399
 * writes: g_12 g_75 g_128 g_154 g_162 g_212 g_291 g_317 g_369 g_399
 */
static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_45 = (-1);
    int32_t l_386 = 0;
    for (g_12 = 22; (g_12 == 15); g_12 -= 1)
    { /* block id: 39 */
        uint16_t l_41 = 0x0B91;
        uint32_t l_433 = 4294967295U;
        if (((((uint16_t)__builtin_ctzll((func_35(g_40, ((((l_41 < g_42) , ((((((l_45 , g_40) , 3) == (l_41 < (func_46(g_40, g_42) ^ g_40.f2))) != 0x6DC0) , g_12) && g_42)) && 4294967295U) , l_41), g_40.f1, g_40.f2) == l_41)) >> (uint16_t)15) == l_386) , 0xE17F145D))
        { /* block id: 180 */
            int32_t l_387 = (-7);
            int32_t l_388 = 0xB08D9354;
            l_388 = (l_41 < l_387);
            g_162 = g_12;
        }
        else
        { /* block id: 183 */
            const int32_t l_389 = (-2);
            struct S0 l_390 = {8U,9U,0};
            int32_t l_396 = 0x88C6C9B1;
            g_162 = (l_389 > ((((l_390 , (((int32_t)(g_40.f2 && g_317) % (int32_t)l_386) >= (l_386 , 0xB217))) , (g_128 & 0x4915D709)) && 65534U) == g_209));
            for (g_75 = 0; (g_75 == 24); g_75 += 1)
            { /* block id: 187 */
                int32_t l_395 = 0;
                l_396 ^= l_395;
                g_162 |= (g_369 && (-7));
                g_162 = ((uint16_t)0x5310 >> (uint16_t)(0xA0C64F53 || g_317));
                return g_399;
            }
        }
        if ((((g_399 , __builtin_popcountll(l_41)) >= ((uint16_t)l_41 + (uint16_t)((((l_41 == ((g_211 || 0xEC7B) != ((((int16_t)l_41 + (int16_t)((((((int16_t)g_162 >> (int16_t)6) | (-3)) | g_40.f1) == g_128) , 65533U)) == g_369) , g_12))) , 0U) | l_45) & g_154))) , l_45))
        { /* block id: 194 */
            int32_t l_414 = 0xA345A6B2;
            uint16_t l_417 = 0xADD1;
            int32_t l_432 = 0;
            l_386 = l_41;
            g_399 = ((uint32_t)((((uint16_t)9U - (uint16_t)l_386) ^ (((((g_369 ^ g_317) || ((int32_t)((((int32_t)l_45 + (int32_t)(g_209 != 0xA595)) , ((g_212 , (g_40.f0 && g_40.f1)) || l_414)) | 0x372B4156) - (int32_t)g_162)) != g_209) | 0x7BB3) != g_75)) , g_40.f0) - (uint32_t)9U);
            l_432 |= ((uint32_t)l_417 - (uint32_t)((uint16_t)((uint16_t)((4294967295U && g_128) , (((65535U | (((((int16_t)(g_154 ^ ((uint16_t)((~(-(int16_t)0x7E79)) ^ l_417) + (uint16_t)g_40.f1)) >> (int16_t)6) != ((uint32_t)((((int16_t)((l_41 || l_45) ^ (-1)) << (int16_t)g_317) != g_40.f2) , l_45) - (uint32_t)0xB8B5409C)) || g_212) != 0x470653C7)) , g_212) && 0xF2BE)) + (uint16_t)g_209) - (uint16_t)g_399));
        }
        else
        { /* block id: 198 */
            l_386 |= (g_40.f0 | 0x2458);
            g_162 = 0x1A75E040;
            if (l_433)
                break;
        }
    }
    return l_386;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f0 g_40.f1 g_40.f2 g_12 g_42 g_75 g_40 g_128 g_154 g_162 g_209 g_212 g_211 g_291 g_317 g_369
 * writes: g_75 g_128 g_154 g_162 g_212 g_291 g_317 g_369
 */
inline static uint16_t  func_35(const struct S0  p_36, int32_t  p_37, int32_t  p_38, int32_t  p_39)
{ /* block id: 42 */
    int32_t l_52 = 0xB856A759;
    l_52 = ((((__builtin_ffs(p_36.f0) <= ((uint32_t)(p_39 , ((p_36.f0 <= p_37) ^ l_52)) - (uint32_t)l_52)) <= func_53((p_36.f2 == func_58(((uint16_t)65531U << (uint16_t)2))), l_52, g_40.f1, p_36.f1)) | g_40.f0) , g_211);
    return p_36.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_46(struct S0  p_47, int16_t  p_48)
{ /* block id: 40 */
    const int16_t l_49 = 0x9384;
    return l_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_40 g_317 g_42 g_12 g_75 g_128 g_154
 * writes: g_128 g_154 g_75 g_162
 */
inline static const uint32_t  func_53(uint32_t  p_54, uint32_t  p_55, const int32_t  p_56, const uint32_t  p_57)
{ /* block id: 171 */
    struct S0 l_384 = {6U,249U,3};
    uint8_t l_385 = 0U;
    for (p_55 = (-18); (p_55 != 56); p_55 += 1)
    { /* block id: 174 */
        uint8_t l_381 = 0x72;
        l_385 = ((l_381 <= 65532U) < (func_92(g_40, g_317) >= (((uint32_t)l_381 + (uint32_t)func_46(l_384, p_54)) & g_40.f0)));
    }
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f0 g_40.f1 g_40.f2 g_12 g_42 g_75 g_40 g_128 g_154 g_162 g_209 g_212 g_211 g_291 g_317 g_369
 * writes: g_75 g_128 g_154 g_162 g_212 g_291 g_317 g_369
 */
inline static uint16_t  func_58(uint32_t  p_59)
{ /* block id: 43 */
    struct S0 l_69 = {0U,0x62,0};
    int32_t l_76 = 0xA1818855;
    l_76 = ((int32_t)((uint32_t)g_40.f0 + (uint32_t)((uint16_t)((-(uint16_t)func_46(l_69, g_40.f1)) , (p_59 , func_70(p_59))) - (uint16_t)__builtin_bswap32(g_40.f0))) % (int32_t)4294967288U);
    l_76 = g_42;
    l_76 = (l_69.f2 & (((uint16_t)((int32_t)(-(uint32_t)func_46(l_69, p_59)) - (int32_t)(((uint16_t)func_46(l_69, ((!func_85(g_75)) | ((uint16_t)(((g_40.f2 , g_12) , p_59) | 0x8429) >> (uint16_t)4))) >> (uint16_t)5) != 1)) >> (uint16_t)4) , 0xBCEE));
    return g_40.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_40.f2
 * writes: g_75
 */
inline static uint16_t  func_70(int16_t  p_71)
{ /* block id: 44 */
    int16_t l_74 = 0x0ED6;
    g_75 = (g_40.f2 , ((uint16_t)__builtin_ctzll(l_74) << (uint16_t)p_71));
    return p_71;
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_40 g_42 g_12 g_128 g_154 g_162 g_209 g_212 g_211 g_291 g_317 g_369
 * writes: g_128 g_154 g_75 g_162 g_212 g_291 g_317 g_369
 */
inline static int16_t  func_85(int32_t  p_86)
{ /* block id: 49 */
    int32_t l_88 = (-8);
    struct S0 l_95 = {4294967288U,255U,0x495AE89E};
    int16_t l_193 = 7;
    uint16_t l_196 = 0x757B;
    int32_t l_220 = 0xB80F26FC;
    int32_t l_299 = 0x4AD2E39D;
    struct S0 l_346 = {0U,1U,3};
    uint32_t l_356 = 0x5E980E34;
    uint32_t l_368 = 0x4348B525;
    if (g_75)
    { /* block id: 50 */
        int16_t l_87 = 0xBE56;
        struct S0 l_89 = {4294967293U,0x54,0x8FDC3C1A};
        int32_t l_166 = 0xACCF6E19;
        uint32_t l_268 = 0xDB64655A;
        int16_t l_290 = 0x1F38;
        int32_t l_322 = 0xCC17CFA8;
        int32_t l_323 = 5;
        p_86 = ((l_87 , (l_88 != 0x358B)) , 0x0795B172);
        if (((func_46(l_89, func_46(g_40, p_86)) && func_90(((func_92(l_95, p_86) && __builtin_clz((((int16_t)p_86 + (int16_t)g_40.f2) , g_40.f2))) , g_75))) != 0x01A0E296))
        { /* block id: 76 */
            uint32_t l_173 = 0x759984D6;
            struct S0 l_190 = {4294967295U,1U,0x08070889};
            uint8_t l_221 = 0x4A;
            uint32_t l_228 = 0x010FE33B;
            int16_t l_233 = 0xCE29;
            l_166 ^= g_128;
            g_162 = (((int32_t)(g_40.f0 | g_40.f2) - (int32_t)__builtin_bswap32(p_86)) == 0x7662);
            g_162 = (l_95.f1 | func_70(g_154));
            for (l_87 = 16; (l_87 != 21); l_87 += 5)
            { /* block id: 82 */
                uint32_t l_208 = 0xA6F621B4;
                int32_t l_210 = 5;
                if ((p_86 & (l_89.f1 < g_12)))
                { /* block id: 83 */
                    g_162 = ((((__builtin_bswap32((((int32_t)g_40.f2 % (int32_t)4294967291U) <= l_173)) || p_86) | ((int32_t)g_162 - (int32_t)((l_89.f1 != (1 >= (p_86 || p_86))) || p_86))) == 0xDD9E1A7E) > (-5));
                    return g_75;
                }
                else
                { /* block id: 86 */
                    uint32_t l_183 = 0U;
                    p_86 = ((int16_t)(((int16_t)(~func_70(g_162)) << (int16_t)0) & (((int16_t)l_183 << (int16_t)7) == p_86)) >> (int16_t)7);
                }
                l_88 = ((int16_t)(((((uint16_t)(g_40.f0 && (-1)) - (uint16_t)__builtin_ffsl(((int16_t)((l_190 , (g_12 , g_75)) >= (((uint16_t)l_193 >> (uint16_t)(-(int16_t)((p_86 , g_162) , (((-(uint16_t)g_40.f2) && 8) >= 0x7F16)))) ^ 1)) >> (int16_t)p_86))) , (-10)) != 0xC749) >= l_196) << (int16_t)p_86);
                for (g_128 = 0; (g_128 < (-13)); --g_128)
                { /* block id: 92 */
                    uint16_t l_201 = 0U;
                    if ((((0xAC000487 ^ (((uint32_t)l_201 + (uint32_t)(((uint16_t)g_154 - (uint16_t)g_12) & (0x29614939 & ((uint16_t)(((int32_t)g_154 - (int32_t)((g_12 != func_90(l_208)) == 0x397D913F)) != g_75) << (uint16_t)g_209)))) & p_86)) || 0x788A) , p_86))
                    { /* block id: 93 */
                        return g_40.f0;
                    }
                    else
                    { /* block id: 95 */
                        --g_212;
                        l_220 = (func_70(g_154) != ((((uint16_t)((p_86 == ((l_193 < (__builtin_ctz((((uint16_t)65535U >> (uint16_t)15) || (((g_211 < 9U) == (-(uint32_t)__builtin_clz((((g_40.f0 ^ l_190.f0) , 0U) >= p_86)))) < g_154))) || p_86)) | 1U)) || p_86) << (uint16_t)p_86) <= g_209) , (-1)));
                        l_221 |= (-1);
                    }
                    p_86 = (((uint16_t)((int32_t)((int16_t)l_228 - (int16_t)((((int32_t)__builtin_popcountl(((((uint16_t)(((((__builtin_ffs(p_86) ^ __builtin_popcount(l_201)) == ((0U == 0xCB5AC61B) != p_86)) ^ (l_233 , 1U)) & p_86) && p_86) % (uint16_t)g_40.f2) < g_211) , 1U)) - (int32_t)l_210) , (-8)) > l_210)) + (int32_t)l_208) % (uint16_t)l_210) == 0x3FBDC801);
                    g_162 = (-10);
                    g_162 ^= p_86;
                }
                p_86 |= g_75;
            }
        }
        else
        { /* block id: 106 */
            uint8_t l_236 = 0x07;
            l_236 |= ((int16_t)g_154 >> (int16_t)p_86);
        }
        for (l_89.f0 = 2; (l_89.f0 != 45); l_89.f0 += 1)
        { /* block id: 111 */
            int32_t l_252 = (-6);
            if (((!0x94F7) >= p_86))
            { /* block id: 112 */
                int32_t l_240 = 0x86A49EC6;
                return l_240;
            }
            else
            { /* block id: 114 */
                p_86 = (0x01F2 >= p_86);
                g_162 = __builtin_ctzll(p_86);
            }
            g_162 = (((uint16_t)65535U >> (uint16_t)func_90((((((p_86 | ((~(((int16_t)((int16_t)g_42 - (int16_t)l_89.f1) << (int16_t)(((int16_t)((uint32_t)(g_154 ^ ((p_86 & (((g_162 >= (((__builtin_clz((g_40 , (p_86 >= p_86))) & l_95.f2) ^ 0x9D16) || g_12)) <= g_154) , l_252)) , p_86)) % (uint32_t)l_252) - (int16_t)l_89.f1) || l_252)) == g_154)) > 0x91A5)) < g_154) > 0U) & l_95.f0) , g_40.f0))) || l_252);
        }
        for (l_95.f1 = 0; (l_95.f1 <= 11); l_95.f1 += 1)
        { /* block id: 122 */
            uint32_t l_259 = 0U;
            uint8_t l_271 = 0x1F;
            g_162 = ((((((((uint32_t)(((int16_t)(-1) << (int16_t)0) & __builtin_parityl(p_86)) % (uint32_t)l_89.f2) && g_209) >= l_259) , 1) & (((int32_t)(((__builtin_bswap64((l_95.f2 == ((l_220 || 0xE261F0A9) , p_86))) | p_86) || l_259) != l_259) + (int32_t)l_193) & g_128)) , g_40.f2) , (-1));
            g_162 ^= (p_86 | ((((__builtin_ffsl(p_86) && (0x67D72278 | (-9))) , ((int16_t)((func_90(((int32_t)(g_211 == ((((int32_t)p_86 % (int32_t)l_166) , 65535U) && 0x57FE)) + (int32_t)p_86)) >= l_95.f1) == g_40.f0) >> (int16_t)15)) && l_259) , g_75));
            if (g_154)
            { /* block id: 125 */
                uint8_t l_289 = 0U;
                l_220 &= l_268;
                g_291 &= ((((int16_t)((g_40.f2 == (l_271 < ((((int32_t)(((int32_t)(((int16_t)g_154 << (int16_t)8) != g_12) - (int32_t)(((int16_t)(((int16_t)((uint16_t)(2 < (p_86 != ((int32_t)((int16_t)(((-(uint32_t)__builtin_parity(__builtin_bswap32(p_86))) , g_75) ^ p_86) << (int16_t)l_95.f1) + (int32_t)0x6C564025))) << (uint16_t)5) + (int16_t)(-1)) > 1U) + (int16_t)g_154) > l_289)) >= g_128) % (int32_t)0xFF55E27A) < g_162) && 65535U))) <= 0x3694) >> (int16_t)l_289) != g_154) >= l_290);
                l_88 = ((uint32_t)((((((uint16_t)l_289 << (uint16_t)8) || (g_40.f1 , ((l_289 & ((__builtin_bswap64(p_86) >= g_128) , 4294967295U)) != ((int16_t)((((g_212 , 0x20B6152E) < p_86) , g_291) , g_209) - (int16_t)l_289)))) , g_211) != g_209) , l_88) - (uint32_t)0x6518F146);
            }
            else
            { /* block id: 129 */
                uint32_t l_298 = 0U;
                if (l_89.f1)
                    break;
                g_162 = l_298;
                p_86 = (g_212 , (func_102(l_299, func_90(p_86), ((l_89.f0 && (0x4DC4 ^ p_86)) , (p_86 & p_86))) , 6));
                return l_259;
            }
            if (((uint32_t)((p_86 < func_90((p_86 & g_212))) & ((int32_t)(((int16_t)g_75 - (int16_t)65534U) , (((uint16_t)(((int16_t)(((int16_t)((int16_t)((!(((uint16_t)func_70(g_40.f1) << (uint16_t)0) , func_46(g_40, g_209))) && 0xF11B) >> (int16_t)l_268) << (int16_t)13) < p_86) >> (int16_t)l_87) != g_162) + (uint16_t)65535U) < g_162)) % (int32_t)0x4BA55517)) - (uint32_t)p_86))
            { /* block id: 135 */
                g_162 = (l_290 , 0x92A9F23F);
                return g_291;
            }
            else
            { /* block id: 138 */
                uint16_t l_334 = 0xEC61;
                --g_317;
                if (p_86)
                { /* block id: 140 */
                    const uint16_t l_335 = 0x530D;
                    g_162 = ((((((((g_42 > ((int16_t)(((((l_322 <= (((l_259 && __builtin_clz(l_323)) & (((1U <= (((uint16_t)((uint16_t)1U + (uint16_t)(g_162 || (((uint16_t)((uint16_t)(((int16_t)0x6BEC >> (int16_t)l_268) || 0) >> (uint16_t)7) % (uint16_t)65535U) || p_86))) - (uint16_t)0x02A8) >= l_87)) < l_334) , l_271)) | l_323)) < g_209) == (-1)) && g_291) | 0) - (int16_t)l_166)) < 1) ^ 3U) && g_291) > l_335) , 0x50F9) < 0x0025) , 0xF0AE9239);
                }
                else
                { /* block id: 142 */
                    int32_t l_338 = 0x8869D018;
                    p_86 = (p_86 ^ g_162);
                    for (l_95.f0 = 14; (l_95.f0 < 14); l_95.f0 += 1)
                    { /* block id: 146 */
                        l_338 = l_95.f2;
                    }
                }
            }
        }
    }
    else
    { /* block id: 152 */
        uint32_t l_343 = 0U;
        int32_t l_351 = 7;
        int32_t l_352 = 0;
        int32_t l_353 = 7;
        int32_t l_355 = 0x0E83303B;
        if (((((int16_t)(p_86 <= (((((((int16_t)l_343 << (int16_t)8) & ((uint16_t)__builtin_parityll(g_317) << (uint16_t)func_46(l_346, ((uint32_t)(!g_40.f2) + (uint32_t)g_75)))) < (((0x247C && p_86) > 0x2C3F) || 0x8C7E)) <= g_12) < l_299) != p_86)) >> (int16_t)g_40.f2) < (-5)) , 0))
        { /* block id: 153 */
            int16_t l_354 = 0xBB53;
            l_351 = ((!(-1)) != 0xBD4B);
            --l_356;
            return g_291;
        }
        else
        { /* block id: 157 */
            const uint16_t l_366 = 1U;
            uint16_t l_367 = 65535U;
            g_369 ^= ((l_352 ^ ((((((int32_t)g_75 + (int32_t)((0x222E <= (~(((int16_t)p_86 << (int16_t)0) , ((int16_t)__builtin_ffsll(func_46(func_102(((g_291 , ((func_102((g_75 >= l_366), (p_86 , (l_367 > 0)), l_368) , g_42) ^ g_75)) > g_128), l_346.f2, g_162), g_40.f0)) << (int16_t)11)))) , g_42)) == 0x2EE290AA) & 2U) ^ g_40.f1) != p_86)) != 0xD7C5358B);
        }
    }
    g_162 = 0xB60CCDDF;
    if (((int16_t)0xDA1E - (int16_t)(p_86 < (((g_317 , p_86) < (g_209 , ((func_70((0x4C93 ^ __builtin_popcountll((((((uint16_t)(4294967295U <= l_346.f2) + (uint16_t)(((uint16_t)l_346.f1 >> (uint16_t)0) | p_86)) >= 0x78A3B0EC) < p_86) , p_86)))) <= 0xC736) , l_196))) <= 0xF8ADE7CE))))
    { /* block id: 162 */
        uint8_t l_376 = 0x78;
        p_86 |= ((l_376 & g_317) | 3);
    }
    else
    { /* block id: 164 */
        return p_86;
    }
    p_86 = p_86;
    return l_95.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_154
 * writes:
 */
static int32_t  func_90(uint8_t  p_91)
{ /* block id: 73 */
    uint32_t l_165 = 0x83C55790;
    l_165 &= g_154;
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_40.f1 g_40.f2 g_40.f0 g_12 g_75 g_128 g_154
 * writes: g_128 g_154 g_75 g_162
 */
inline static uint16_t  func_92(struct S0  p_93, uint32_t  p_94)
{ /* block id: 52 */
    uint8_t l_106 = 0xE7;
    int32_t l_129 = (-8);
    uint32_t l_152 = 0xDC045D86;
    uint16_t l_153 = 0x8971;
    if (((int16_t)((((int16_t)((int32_t)g_42 - (int32_t)((func_102(l_106, __builtin_bswap32(((int32_t)0xD1F0774A + (int32_t)(((p_94 != ((int16_t)(g_40.f1 && (((((((int32_t)(p_93.f0 & __builtin_parity((p_93.f2 <= (((((int16_t)((p_93.f0 & 0x9E23) , l_106) + (int16_t)1U) , l_106) == l_106) > 1)))) % (int32_t)g_40.f2) < l_106) & 0xF4C6) , g_40.f0) < 0xEDB7DE59) || l_106)) << (int16_t)l_106)) > l_106) || 0x794F))), l_106) , l_106) > g_75)) + (int16_t)1U) < p_93.f1) , (-1)) - (int16_t)9))
    { /* block id: 55 */
        uint16_t l_116 = 0x9819;
        return l_116;
    }
    else
    { /* block id: 57 */
        const uint8_t l_119 = 0xA2;
        for (l_106 = (-18); (l_106 != 46); l_106 += 1)
        { /* block id: 60 */
            g_128 &= ((((l_119 , l_106) , (((int32_t)((0x68C8 && (((((uint16_t)((int16_t)((l_106 < ((uint32_t)((func_46(p_93, g_42) != ((p_93 , 1) && p_93.f2)) || p_93.f2) % (uint32_t)(-8))) , 0x8C96) << (int16_t)5) + (uint16_t)l_106) != 1U) > 0xA799) & l_119)) & (-1)) + (int32_t)p_93.f0) , 0xA2C9F03B)) >= p_93.f0) || g_12);
        }
    }
    l_129 |= 0x664A1005;
    for (p_93.f1 = 8; (p_93.f1 <= 15); p_93.f1 += 1)
    { /* block id: 67 */
        uint8_t l_132 = 1U;
        if (g_40.f0)
            break;
        g_154 = (((l_132 , (((!((((int16_t)__builtin_clz((((int16_t)((int32_t)g_75 - (int32_t)func_46(func_102(l_132, (((((int16_t)(((((((uint32_t)(0x7867E7C5 == (g_42 != (((uint16_t)p_93.f0 >> (uint16_t)9) || (func_46(func_102(p_94, ((uint32_t)(p_93.f1 && (((int16_t)((int32_t)g_128 % (int32_t)g_40.f2) >> (int16_t)14) , l_152)) % (uint32_t)0x6617F50B), g_40.f2), p_93.f2) , 0x5509)))) % (uint32_t)p_93.f2) ^ l_132) >= 0xE8EB) < l_129) == l_153) ^ l_106) >> (int16_t)13) , g_128) <= g_40.f2) ^ p_93.f0), l_153), p_93.f0)) << (int16_t)g_75) < p_94)) << (int16_t)10) > 0x32EDDAFF) && g_128)) | l_152) , 0xE15252EC)) , l_132) , l_129);
    }
    g_162 = __builtin_parityl((func_70(((__builtin_popcountll(l_129) , (((uint16_t)(9 || p_93.f0) << (uint16_t)10) <= g_42)) < ((((uint16_t)((l_129 & (((int16_t)((~p_93.f1) , 7) << (int16_t)10) ^ func_46(p_93, p_94))) , l_153) << (uint16_t)g_154) < 4294967290U) > l_129))) == 0x1D73));
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S0  func_102(int16_t  p_103, uint8_t  p_104, uint32_t  p_105)
{ /* block id: 53 */
    const struct S0 l_115 = {5U,0x6C,-2};
    return l_115;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_40.f0, "g_40.f0", print_hash_value);
    transparent_crc(g_40.f1, "g_40.f1", print_hash_value);
    transparent_crc(g_40.f2, "g_40.f2", print_hash_value);
    transparent_crc(g_42, "g_42", print_hash_value);
    transparent_crc(g_75, "g_75", print_hash_value);
    transparent_crc(g_128, "g_128", print_hash_value);
    transparent_crc(g_154, "g_154", print_hash_value);
    transparent_crc(g_162, "g_162", print_hash_value);
    transparent_crc(g_209, "g_209", print_hash_value);
    transparent_crc(g_211, "g_211", print_hash_value);
    transparent_crc(g_212, "g_212", print_hash_value);
    transparent_crc(g_291, "g_291", print_hash_value);
    transparent_crc(g_317, "g_317", print_hash_value);
    transparent_crc(g_369, "g_369", print_hash_value);
    transparent_crc(g_399, "g_399", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 88
   depth: 1, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 43
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 43, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 445
XXX times a non-volatile is write: 66
XXX times a volatile is read: 32
XXX    times read thru a pointer: 0
XXX times a volatile is write: 2
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 149
XXX percentage of non-volatile access: 93.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 103
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 14
   depth: 2, occurrence: 26
   depth: 3, occurrence: 22
   depth: 4, occurrence: 10
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
********************* end of statistics **********************/

