/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      348003869
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   int8_t  f1;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
inline static float  func_33(float  p_34);
static float  func_37(int32_t  p_38);
static int16_t  func_42(uint32_t  p_43, uint16_t  p_44, struct S0  p_45);
inline static int16_t  func_46(uint16_t  p_47, int8_t  p_48, uint32_t  p_49);
static uint32_t  func_53(uint32_t  p_54);
inline static int32_t  func_58(int32_t  p_59, int8_t  p_60);
inline static struct S0  func_62(int8_t  p_63, uint32_t  p_64);
static uint16_t  func_74(uint16_t  p_75, uint32_t  p_76, struct S0  p_77);
inline static struct S0  func_79(uint32_t  p_80, int8_t  p_81, struct S0  p_82, int32_t  p_83, uint32_t  p_84);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_41 = 0x96A0B597L;
    int32_t l_566 = (-10L);
    int32_t l_567 = 0L;
    struct S0 l_569 = {18446744073709551615UL,-10L};
    int8_t l_784 = 6L;
    int32_t l_785 = 4L;
    int32_t l_786 = 0x884F5338L;
    l_786 = ((float)0x7.8D927Fp+91 / (float)((func_33(((0x0.9p+1 < ((float)(func_37(((l_567 = ((uint32_t)(l_41 <= (l_41 & (func_42((l_41 | l_41), (func_46(l_41, (0UL ^ (!(((((uint32_t)(l_566 = func_53(l_41)) + (uint32_t)l_41) && l_41) < l_567) == 0x0EB170FAL))), l_41) != l_41), l_569) != 0xC48BL))) + (uint32_t)0x67758D9DL)) > l_41)) == l_41) + (float)l_569.f1)) > 0x5.CDE661p-13)) >= l_784) > l_785));
    return l_566;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_33(float  p_34)
{ /* block id: 321 */
    int16_t l_594 = 0x0EF0L;
    int32_t l_597 = 0x8B62525DL;
    struct S0 l_606 = {3UL,0x4AL};
    uint16_t l_607 = 0xF475L;
    int16_t l_608 = (-1L);
    uint32_t l_617 = 0xF76C4CF8L;
    int32_t l_620 = (-1L);
    uint32_t l_713 = 0xB47940FBL;
    int32_t l_756 = (-3L);
    int32_t l_757 = 0x68BD78BAL;
    int32_t l_758 = 0L;
    l_594 = (-1L);
    l_606 = func_62((l_597 = ((uint16_t)l_594 << (uint16_t)l_594)), (l_594 | (((l_594 ^ (l_594 || (func_74(((((uint16_t)(l_594 == l_594) >> (uint16_t)8) & l_594) & ((((int32_t)((uint32_t)(((uint16_t)(l_594 == l_594) >> (uint16_t)l_594) > l_594) - (uint32_t)l_594) / (int32_t)l_594) ^ l_594) && l_594)), l_594, l_606) != l_606.f1))) <= 5UL) > 0x6E7C2798L)));
    if ((l_608 = l_607))
    { /* block id: 326 */
        int32_t l_613 = 0xD5275FA7L;
        struct S0 l_623 = {0xF0E37AB3L,0x13L};
        int32_t l_639 = 0xC7879251L;
        int16_t l_645 = 0xE4FFL;
        int32_t l_656 = 0xB7AA850CL;
        int8_t l_669 = 0x32L;
        struct S0 l_681 = {0x4B1D95CCL,0xCEL};
        if ((((uint16_t)((uint32_t)l_594 - (uint32_t)l_594) + (uint16_t)(l_613 ^ (l_597 = l_606.f0))) == ((~((int32_t)l_617 / (int32_t)func_74(((((uint32_t)l_613 % (uint32_t)l_613) & 0x26B5L) < (l_620 = l_613)), l_617, l_606))) & l_613)))
        { /* block id: 329 */
            for (l_594 = (-19); (l_594 >= (-12)); l_594 += 1)
            { /* block id: 332 */
                l_623 = l_623;
            }
            l_606 = l_606;
            l_597 = l_620;
        }
        else
        { /* block id: 337 */
            int32_t l_632 = 0L;
            float l_663 = 0xE.81B984p-77;
            int32_t l_664 = 0L;
            l_620 = (__builtin_parity(l_594) < ((uint16_t)((int16_t)((int16_t)((65527UL & ((uint32_t)func_53((l_597 = l_623.f0)) + (uint32_t)l_606.f0)) && func_46(((l_632 ^ ((uint16_t)(((uint16_t)((int32_t)(l_623.f0 > ((l_639 = l_632) ^ l_613)) / (int32_t)l_632) / (uint16_t)l_632) >= (-5L)) << (uint16_t)l_632)) & l_623.f1), l_594, l_613)) - (int16_t)0x7975L) - (int16_t)l_594) % (uint16_t)l_632));
            for (l_639 = (-15); (l_639 != 8); l_639++)
            { /* block id: 343 */
                int16_t l_655 = (-3L);
                int32_t l_657 = (-1L);
                int32_t l_659 = (-1L);
                struct S0 l_680 = {0x0A59EAFFL,0x22L};
                for (l_632 = 0; (l_632 >= (-9)); l_632 -= 3)
                { /* block id: 346 */
                    int32_t l_644 = (-3L);
                    int32_t l_675 = 1L;
                    if (l_617)
                    { /* block id: 347 */
                        float l_654 = 0x3.DC3287p+69;
                        int32_t l_658 = (-1L);
                        if (l_644)
                            break;
                        l_659 = (l_645 > (((uint16_t)(((uint16_t)((int32_t)((((int16_t)l_632 / (int16_t)l_594) < (l_656 = l_655)) == (l_632 > 0x417BA2DDL)) - (int32_t)((0x937AL | 0x4A70L) != (l_657 = l_655))) >> (uint16_t)2) < 0L) + (uint16_t)0xF998L) ^ l_658));
                    }
                    else
                    { /* block id: 352 */
                        uint16_t l_660 = 65531UL;
                        l_664 = ((__builtin_ffsl(l_660) != ((uint32_t)l_597 - (uint32_t)((l_632 || 0x7BF5DA8CL) < l_644))) ^ l_660);
                    }
                    l_620 = ((l_644 < ((l_656 = l_659) && __builtin_ffsl(l_644))) == ((l_664 = func_58(l_659, (l_669 = ((uint32_t)(__builtin_popcountll(l_613) ^ ((int32_t)l_664 % (int32_t)(l_644 || l_623.f1))) - (uint32_t)8L)))) | l_623.f0));
                    l_680 = func_79(((int32_t)((uint16_t)4UL / (uint16_t)65535UL) + (int32_t)(+((l_675 = l_644) < (l_664 | ((int32_t)((uint16_t)((l_655 & (l_632 == ((((func_58(l_644, l_664) > l_639) && l_657) >= l_644) < l_645))) ^ l_623.f1) / (uint16_t)l_659) % (int32_t)l_655))))), l_613, l_623, l_664, l_659);
                }
            }
            l_681 = (l_623 = l_623);
            l_597 = ((l_620 = ((float)p_34 - (float)((((float)func_37(((int16_t)8L << (int16_t)1)) - (float)p_34) > (0x0.Cp+1 < (-0x4.Cp-1))) == l_664))) >= l_594);
        }
        if (l_669)
        { /* block id: 368 */
            struct S0 l_688 = {0xF9AF414FL,0L};
            int32_t l_689 = 0x7E54F2EAL;
            l_623 = l_688;
            p_34 = (l_689 = (l_656 = 0xA.A0C0C4p+99));
        }
        else
        { /* block id: 373 */
            int32_t l_690 = 0x225E58B1L;
            struct S0 l_691 = {0x4B2E83BEL,0xECL};
            p_34 = ((0xE.8AD16Cp-30 > (l_656 = l_690)) < p_34);
            if (l_606.f1)
                goto lbl_692;
lbl_692:
            l_691 = l_691;
            l_639 = ((0x658189BBL > (4294967294UL ^ (l_597 = ((int32_t)((int32_t)((!l_691.f0) == l_639) - (int32_t)l_691.f0) - (int32_t)(l_656 = 0x5667429AL))))) & __builtin_ctzl(((uint16_t)((0L < func_58(l_691.f1, l_639)) > l_691.f1) >> (uint16_t)14)));
        }
    }
    else
    { /* block id: 382 */
        struct S0 l_700 = {0xE952C97EL,-4L};
        int32_t l_705 = 1L;
        int8_t l_706 = (-2L);
        int32_t l_732 = 0x7AA8007AL;
        uint16_t l_733 = 0x2B4AL;
        int32_t l_755 = (-1L);
        l_606 = l_700;
        if (((((int16_t)l_700.f1 + (int16_t)__builtin_parityl(((int16_t)(((l_705 = l_700.f0) & l_700.f0) & (l_706 = l_597)) + (int16_t)((((((int32_t)l_700.f1 / (int32_t)(l_597 ^ l_606.f0)) && func_53((l_700.f1 != ((int16_t)((uint16_t)(l_700.f1 >= 0xB4AFL) >> (uint16_t)3) << (int16_t)l_713)))) || l_700.f0) && 0x2FD8L) != l_597)))) == l_620) && l_617))
        { /* block id: 386 */
            struct S0 l_716 = {0xA5EC6EF1L,-1L};
            for (l_617 = (-16); (l_617 <= 56); l_617 += 1)
            { /* block id: 389 */
                uint16_t l_719 = 0x19C1L;
                struct S0 l_724 = {0xD2806A04L,0x83L};
                l_606 = l_716;
                l_724 = func_62(l_705, ((uint32_t)l_719 / (uint32_t)((uint16_t)0UL - (uint16_t)(((int16_t)l_719 << (int16_t)l_705) <= l_705))));
            }
            l_716 = func_79((l_713 ^ ((l_705 = l_706) & ((0x7C88L >= (l_706 & (l_732 = ((int32_t)(((l_700.f0 > ((l_706 >= ((uint32_t)((!((uint16_t)l_716.f0 >> (uint16_t)l_716.f1)) >= l_706) % (uint32_t)l_700.f0)) ^ l_716.f1)) <= (-6L)) >= l_716.f0) / (int32_t)1UL)))) < l_716.f1))), l_733, l_606, l_700.f1, l_606.f1);
            for (l_700.f0 = 0; (l_700.f0 == 20); l_700.f0 += 1)
            { /* block id: 398 */
                float l_740 = 0x8.1EA38Dp-77;
                p_34 = (p_34 > ((float)((float)l_732 - (float)p_34) / (float)0xD.9A776Cp-20));
                return l_740;
            }
            p_34 = l_716.f1;
        }
        else
        { /* block id: 403 */
            uint32_t l_750 = 0x2235E695L;
            l_758 = (p_34 = (((p_34 > p_34) > func_37(((uint16_t)l_606.f0 >> (uint16_t)l_705))) <= ((float)((l_757 = (l_756 = (l_755 = (((float)(((float)(+(((l_732 = func_53(l_750)) != (((float)l_705 - (float)((float)(l_597 = ((l_620 = l_620) == l_713)) - (float)0x4.EC0587p-49)) > l_617)) < p_34)) / (float)0x8.7p-1) < 0xE.24045Ap+23) / (float)0x9.90372Bp+17) < p_34)))) >= 0x0.Fp-1) - (float)0x7.E1A324p-68)));
            return p_34;
        }
        p_34 = (l_705 = (__builtin_clz((((int16_t)l_713 + (int16_t)((uint16_t)__builtin_bswap64(((((int32_t)l_755 - (int32_t)(((uint16_t)((uint16_t)(func_46((l_758 = ((int16_t)l_700.f1 >> (int16_t)11)), l_757, l_700.f0) != l_594) << (uint16_t)(0x1809L == ((uint32_t)((int16_t)l_700.f0 / (int16_t)l_597) + (uint32_t)l_606.f1))) << (uint16_t)l_705) & 6UL)) | l_597) ^ l_756)) >> (uint16_t)l_705)) != 1L)) != l_755));
    }
    l_757 = ((func_53(l_757) > (!(!0x5.DB9732p-2))) <= ((float)((float)(l_756 = (p_34 = (l_620 = p_34))) / (float)((-(float)(((float)(l_758 = 0x0.5p+1) - (float)l_597) <= l_597)) <= l_608)) - (float)func_58(l_597, l_607)));
    return l_594;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_37(int32_t  p_38)
{ /* block id: 311 */
    int32_t l_571 = 0xC25D2B4CL;
    uint32_t l_572 = 0x291AE296L;
    int32_t l_579 = 0x73024753L;
    int32_t l_580 = 3L;
    struct S0 l_581 = {18446744073709551615UL,0x6CL};
    uint32_t l_592 = 0x8BB4B703L;
    int32_t l_593 = 0x950B8D68L;
    l_581 = func_62(((l_571 = ((-1L) != (0xA63EL < ((0xB3075D88L & l_571) | l_572)))) || (((int16_t)((int16_t)(((l_579 = __builtin_clz((l_571 = p_38))) && l_572) != (l_572 > p_38)) % (int16_t)p_38) >> (int16_t)l_572) <= l_572)), l_580);
    l_593 = ((float)((((float)(l_579 = ((float)((l_580 = l_572) < ((float)p_38 / (float)p_38)) / (float)(l_571 = p_38))) - (float)0x1.Ap+1) > 0x7.7p+1) > ((float)(__builtin_parityll(l_592) == __builtin_ffsl(p_38)) - (float)l_581.f0)) - (float)0x7.2p+1);
    return l_579;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_42(uint32_t  p_43, uint16_t  p_44, struct S0  p_45)
{ /* block id: 308 */
    uint16_t l_570 = 65535UL;
    return l_570;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_46(uint16_t  p_47, int8_t  p_48, uint32_t  p_49)
{ /* block id: 306 */
    int8_t l_568 = 0x2EL;
    return l_568;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_53(uint32_t  p_54)
{ /* block id: 37 */
    int8_t l_61 = (-9L);
    int32_t l_562 = 0xBC3D9DAAL;
    struct S0 l_563 = {0xE778CAB6L,0x61L};
    int32_t l_564 = 0x3F5ABAE5L;
    int32_t l_565 = 0x4B5FE86FL;
    for (p_54 = 6; (p_54 >= 14); p_54 += 5)
    { /* block id: 40 */
        float l_57 = 0xD.83DE37p-27;
        l_57 = 0xE.A7AD11p+19;
    }
    l_565 = ((func_58(p_54, __builtin_clzl(l_61)) || ((int16_t)(l_564 = func_74(p_54, __builtin_bswap64((l_562 = p_54)), l_563)) / (int16_t)l_61)) == 0xCDD42822L);
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_58(int32_t  p_59, int8_t  p_60)
{ /* block id: 43 */
    int16_t l_65 = (-1L);
    struct S0 l_241 = {0UL,0L};
    uint32_t l_250 = 0UL;
    int32_t l_254 = 0x3CA480CBL;
    int32_t l_257 = 0xAC5E7A40L;
    uint32_t l_258 = 0x4A270C91L;
    uint32_t l_259 = 18446744073709551615UL;
    int32_t l_270 = 0x275E4F8DL;
    uint16_t l_284 = 0x6FBEL;
    int32_t l_285 = 0x2CF54E4AL;
    float l_317 = 0x1.8p-1;
    int32_t l_374 = 0xE2FE3639L;
    int8_t l_392 = 0x76L;
    struct S0 l_485 = {0xFA09181EL,1L};
    int32_t l_559 = 0xB6E7A952L;
    l_241 = func_62(l_65, p_59);
lbl_347:
    l_259 = ((float)l_241.f0 / (float)((((float)((float)0xB.C2EB08p+74 / (float)l_241.f1) / (float)func_74(((uint16_t)l_250 % (uint16_t)((-(uint16_t)(((0L == 1L) <= (l_254 = ((uint16_t)p_59 + (uint16_t)l_250))) <= ((((l_257 = (((uint16_t)p_59 << (uint16_t)9) | p_59)) != l_241.f1) < l_250) ^ p_59))) && 0x8A1BA6F0L)), l_258, l_241)) <= 0x5.AF70EBp-69) > 0x0.8p+1));
    for (l_259 = 0; (l_259 < 18); l_259 += 1)
    { /* block id: 187 */
        int16_t l_275 = 1L;
        int32_t l_282 = 0x8137329BL;
        struct S0 l_283 = {0xD74E9707L,-8L};
        int32_t l_320 = 0L;
        struct S0 l_355 = {0x742A9A8AL,1L};
        int8_t l_407 = 0x99L;
        uint16_t l_422 = 0x5C9AL;
        int32_t l_468 = (-1L);
        int32_t l_469 = 0xB7C658BEL;
        if ((l_257 = (((uint32_t)(p_60 < ((uint16_t)(((int16_t)((l_270 ^ ((p_60 == (((((uint32_t)(l_254 = l_275) % (uint32_t)((uint32_t)(((int16_t)l_275 >> (int16_t)8) != p_59) - (uint32_t)(((uint32_t)func_74(p_60, ((l_282 = l_270) & (-9L)), l_283) - (uint32_t)l_241.f0) == p_60))) || p_59) ^ p_60) <= p_60)) >= l_284)) ^ l_283.f0) >> (int16_t)14) ^ 0x0BEDL) / (uint16_t)l_283.f1)) / (uint32_t)p_60) < l_285)))
        { /* block id: 191 */
            uint16_t l_312 = 9UL;
            int32_t l_318 = 1L;
            int32_t l_319 = 0L;
            if (((uint16_t)((int16_t)((int16_t)((((int16_t)((uint32_t)p_60 + (uint32_t)0xC6AC34F8L) % (int16_t)((uint16_t)((uint16_t)((int16_t)l_241.f1 % (int16_t)((int16_t)((l_254 = ((((int16_t)(6UL >= ((int16_t)(p_59 & (((uint16_t)((uint16_t)l_250 % (uint16_t)l_312) >> (uint16_t)8) ^ ((uint16_t)(l_283.f1 < ((int32_t)(l_319 = (l_282 = (l_318 = func_74((p_60 ^ 0xB7977424L), l_312, l_283)))) - (int32_t)l_312)) << (uint16_t)4))) / (int16_t)p_59)) << (int16_t)p_59) < p_60) > p_59)) != l_257) >> (int16_t)p_60)) % (uint16_t)l_312) << (uint16_t)4)) | p_59) & p_60) - (int16_t)l_312) << (int16_t)l_283.f1) >> (uint16_t)p_60))
            { /* block id: 196 */
                float l_336 = 0xB.7E5032p-54;
                int32_t l_337 = 0x2A58B849L;
                l_282 = (l_320 >= p_59);
                l_254 = ((+(l_257 = ((int32_t)((int16_t)((int16_t)p_60 / (int16_t)func_74(((((int32_t)((((uint16_t)(l_319 || p_60) << (uint16_t)2) ^ ((int32_t)(l_312 || 1UL) / (int32_t)p_60)) < 0x4B58L) + (int32_t)((uint16_t)((l_241.f1 & __builtin_clz(p_59)) > p_60) % (uint16_t)p_60)) | p_59) & 0L), p_59, l_283)) >> (int16_t)8) - (int32_t)p_60))) && l_337);
            }
            else
            { /* block id: 200 */
                int32_t l_346 = (-1L);
                l_283 = func_62(__builtin_ctz(((l_346 = (l_318 | ((int32_t)p_59 + (int32_t)func_74((l_282 = (-(uint16_t)((l_319 = (((p_60 <= 0xCDF892E8L) < ((uint32_t)(l_257 = p_60) + (uint32_t)0xEF4EC5B9L)) != (0x42AD64B7L && p_60))) && (-(uint32_t)(((int16_t)p_59 / (int16_t)l_312) && p_60))))), l_283.f1, l_241)))) & p_60)), p_60);
                if (l_241.f1)
                    goto lbl_347;
            }
            l_355 = (l_283 = func_62((((int32_t)(((uint16_t)0UL >> (uint16_t)12) || func_74(l_319, (((int16_t)l_241.f1 >> (int16_t)11) > (~p_60)), l_283)) % (int32_t)l_283.f1) <= l_270), ((p_60 && p_59) || 0L)));
            l_282 = l_312;
        }
        else
        { /* block id: 211 */
            int32_t l_361 = (-8L);
            l_254 = ((float)p_59 / (float)(l_361 = ((float)(+(l_282 = l_361)) / (float)(l_257 = p_59))));
        }
        if (((((int32_t)(p_59 && ((int16_t)(l_282 || l_254) >> (int16_t)__builtin_clz((((int32_t)((int16_t)p_59 >> (int16_t)((0UL & ((uint32_t)((int16_t)(l_283.f0 <= ((65526UL < ((l_374 = (func_74(__builtin_parity((l_257 = p_60)), l_65, l_241) != p_60)) < p_59)) | 0x83EF03D1L)) / (int16_t)(-8L)) - (uint32_t)4UL)) >= l_250)) / (int32_t)l_320) != 0x947FFBDCL)))) % (int32_t)p_59) | 0xF102A202L) > l_320))
        { /* block id: 219 */
            uint32_t l_375 = 0UL;
            int32_t l_391 = (-1L);
            struct S0 l_406 = {0xE5519FD2L,0xFBL};
            l_241 = l_283;
            l_375 = p_60;
            if ((l_374 = ((uint32_t)(l_282 = func_74(l_375, l_259, (l_241 = func_79(((int32_t)l_284 / (int32_t)l_282), (+((int32_t)(((l_254 = ((uint32_t)l_284 - (uint32_t)(l_257 = ((l_275 == ((p_60 ^ func_74(((int16_t)(-9L) >> (int16_t)func_74(__builtin_ctzll((l_391 = ((int16_t)l_65 / (int16_t)(-1L)))), l_392, l_283)), l_355.f1, l_241)) < p_59)) > l_283.f1)))) == p_60) <= p_59) % (int32_t)p_60)), l_241, l_320, l_375)))) / (uint32_t)l_283.f1)))
            { /* block id: 228 */
                uint16_t l_404 = 1UL;
                int32_t l_405 = 0L;
                uint32_t l_448 = 0x610CEB80L;
                l_257 = p_60;
                if ((((int16_t)(l_282 = (func_74(((l_375 || (~func_74(l_320, (0x8338062DL && (p_59 != ((uint32_t)((int16_t)(p_60 & (func_74((((uint16_t)(((int32_t)((l_404 = 4294967288UL) | l_285) + (int32_t)(p_60 && func_74((l_405 ^ 4294967288UL), p_60, l_355))) <= p_59) + (uint16_t)l_285) & 0x770EAE17L), l_258, l_241) <= p_60)) >> (int16_t)l_375) + (uint32_t)0x95767BE0L))), l_406))) || l_407), l_406.f0, l_406) >= p_59)) << (int16_t)p_59) != p_59))
                { /* block id: 232 */
                    int32_t l_423 = 0x6D58FD66L;
                    struct S0 l_427 = {0UL,-1L};
                    l_241 = func_62(((uint32_t)0x3EE7A5ABL + (uint32_t)(l_405 ^ ((uint32_t)4294967295UL / (uint32_t)p_60))), (((int16_t)(-1L) << (int16_t)(((((l_282 = 4294967293UL) || (((((uint32_t)((l_391 = p_60) > ((((uint16_t)((int32_t)((uint16_t)0UL / (uint16_t)__builtin_bswap64(l_405)) % (int32_t)p_59) - (uint16_t)l_275) >= p_60) > l_422)) - (uint32_t)p_60) >= 0UL) == p_59) && l_423)) > l_283.f1) > 0x10BCL) < 9UL)) & l_407));
                    if (l_65)
                    { /* block id: 236 */
                        int32_t l_426 = 0x054315FEL;
                        l_426 = ((uint32_t)l_423 / (uint32_t)__builtin_ctzll(p_60));
                    }
                    else
                    { /* block id: 238 */
                        struct S0 l_428 = {0xBAF0D8E3L,0xE9L};
                        l_355 = l_427;
                        l_428 = l_428;
                    }
                }
                else
                { /* block id: 242 */
                    int32_t l_442 = 0xE19129FBL;
                    int32_t l_449 = (-8L);
                    struct S0 l_450 = {1UL,4L};
                    l_391 = (((uint32_t)p_60 - (uint32_t)p_59) < p_59);
                    if (p_60)
                        continue;
                    l_374 = ((float)__builtin_clz(((__builtin_clz(l_406.f1) != p_60) <= ((uint32_t)(((uint16_t)((int32_t)((((((uint32_t)p_60 % (uint32_t)(l_442 = (+l_392))) >= ((uint32_t)((uint16_t)(1UL <= (-1L)) - (uint16_t)((+l_407) > (-5L))) - (uint32_t)p_60)) != (-5L)) > p_60) || l_448) % (int32_t)p_59) << (uint16_t)p_59) & l_449) % (uint32_t)1L))) + (float)l_65);
                    l_241 = (l_355 = (l_450 = (l_283 = l_406)));
                }
                if (p_59)
                    continue;
            }
            else
            { /* block id: 253 */
                int16_t l_451 = 0x307CL;
                uint32_t l_452 = 0xAE5AE873L;
                int32_t l_465 = 0L;
                l_469 = ((p_59 | (l_451 & l_452)) >= ((uint16_t)((uint16_t)((int16_t)((int16_t)((l_468 = (((int16_t)(0xFE5EFB6FL >= (l_282 = ((int16_t)((l_391 = (p_59 & p_59)) | (0x86FDL == ((l_465 = 0L) != ((uint32_t)((0xD20AL && 0x2C6EL) < l_406.f1) - (uint32_t)l_452)))) / (int16_t)l_259))) << (int16_t)l_406.f1) || l_391)) && p_60) % (int16_t)0x6308L) << (int16_t)p_60) % (uint16_t)l_258) >> (uint16_t)p_60));
            }
        }
        else
        { /* block id: 260 */
            int32_t l_476 = (-9L);
            int32_t l_498 = 4L;
            int32_t l_514 = 0x057C7EEDL;
            struct S0 l_542 = {0x1B5344A7L,0L};
            if (((int16_t)2L + (int16_t)((int16_t)p_60 >> (int16_t)12)))
            { /* block id: 261 */
                l_282 = (-1L);
                return p_60;
            }
            else
            { /* block id: 264 */
                uint32_t l_483 = 18446744073709551615UL;
                int32_t l_489 = 0x69DF3D12L;
                int32_t l_513 = 0x67DC141AL;
                for (p_59 = 0; (p_59 >= 14); p_59 += 1)
                { /* block id: 267 */
                    struct S0 l_484 = {18446744073709551615UL,0L};
                    int32_t l_486 = (-1L);
                    int16_t l_503 = 0x9098L;
                    uint32_t l_511 = 0UL;
                    float l_512 = (-0x1.Ep-1);
                    l_486 = (p_59 != ((l_476 >= ((int32_t)0L - (int32_t)l_250)) >= (((uint16_t)__builtin_ffsll(((func_74((((int16_t)(l_483 >= (((l_469 = func_74(p_60, l_258, l_484)) | p_60) || l_407)) - (int16_t)l_283.f0) < p_60), p_59, l_485) <= l_284) <= 0xFAE9L)) + (uint16_t)p_60) && 1UL)));
                    for (l_484.f0 = (-20); (l_484.f0 == 1); l_484.f0 += 5)
                    { /* block id: 272 */
                        if (l_483)
                            break;
                        l_489 = __builtin_popcountll(p_60);
                    }
                    if (((int16_t)((uint32_t)((p_60 | 0UL) || ((int16_t)(p_60 & l_355.f1) + (int16_t)l_476)) + (uint32_t)((int16_t)l_498 - (int16_t)l_498)) + (int16_t)((((uint16_t)__builtin_parityll((((-1L) == 3UL) | p_60)) >> (uint16_t)12) | 0xF221L) || l_483)))
                    { /* block id: 276 */
                        uint32_t l_504 = 0x2614E631L;
                        l_503 = ((float)((__builtin_clzll(p_59) <= (p_60 <= (-0x1.Ep-1))) > (l_257 > l_476)) + (float)(-0x4.Bp+1));
                        l_504 = p_59;
                        l_469 = (((int16_t)(((uint16_t)l_489 << (uint16_t)3) & ((uint16_t)l_407 << (uint16_t)l_392)) / (int16_t)l_511) < ((func_74((l_513 = (l_468 = (l_282 = (l_257 = (l_504 && ((l_259 > p_59) || 0x01602A6DL)))))), l_283.f1, l_355) > l_486) <= l_476));
                        l_514 = l_489;
                    }
                    else
                    { /* block id: 285 */
                        int32_t l_540 = 8L;
                        int32_t l_541 = 0x1BC57F52L;
                        l_514 = (((int16_t)p_59 >> (int16_t)(((l_282 = l_320) > ((int16_t)((uint16_t)((uint32_t)(((uint16_t)(((uint16_t)(l_484.f1 <= (l_540 = ((uint32_t)(8UL & (p_60 <= ((int16_t)((uint16_t)((int16_t)l_483 << (int16_t)((int32_t)__builtin_ctzl(l_483) + (int32_t)(+p_59))) - (uint16_t)l_513) >> (int16_t)l_285))) % (uint32_t)(-1L)))) + (uint16_t)0x4660L) < 0x8A367013L) - (uint16_t)l_503) <= 1UL) + (uint32_t)p_60) + (uint16_t)l_254) << (int16_t)p_60)) == l_541)) < l_489);
                        l_355 = l_542;
                    }
                    if (p_60)
                        continue;
                }
                l_513 = (!p_60);
            }
        }
    }
    l_485 = func_62(((+l_257) >= (p_60 < ((((((uint32_t)((int32_t)((int16_t)(func_74(p_59, ((func_74(l_250, l_485.f0, l_241) < (!(((int16_t)(l_254 = (~1L)) + (int16_t)(((int32_t)(l_374 = 1L) % (int32_t)l_241.f1) >= 4294967286UL)) >= p_59))) && 0x9749A4BEL), l_241) || l_485.f1) >> (int16_t)3) + (int32_t)p_59) - (uint32_t)0xD3D781EBL) && l_284) || 0x778CL) & l_559) ^ 0xD8DF74B6L))), p_59);
    return l_285;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_62(int8_t  p_63, uint32_t  p_64)
{ /* block id: 44 */
    int32_t l_70 = 0L;
    int32_t l_71 = 0L;
    int32_t l_78 = 0xE151060FL;
    int32_t l_85 = 0x9D99D06DL;
    int32_t l_88 = 0L;
    struct S0 l_89 = {0xB35667B2L,0xF1L};
    int16_t l_90 = (-1L);
    uint32_t l_237 = 0xE1656023L;
    struct S0 l_240 = {7UL,0x54L};
    for (p_63 = 13; (p_63 < (-6)); p_63 -= 1)
    { /* block id: 47 */
        struct S0 l_72 = {0x46ED4D34L,0L};
        struct S0 l_73 = {0xD4A2B52FL,0L};
        l_71 = (p_63 | ((int16_t)(p_64 & p_63) >> (int16_t)l_70));
        if (p_63)
            continue;
        l_73 = l_72;
        return l_72;
    }
    if ((func_74((l_78 = (l_71 = l_71)), l_70, func_79((l_85 = ((l_70 && p_64) | 0x5453L)), (((int16_t)(4L > (-1L)) % (int16_t)0x5755L) || l_88), l_89, l_88, l_90)) ^ p_64))
    { /* block id: 96 */
        struct S0 l_142 = {0x1BA0C285L,0x1DL};
        l_142 = l_89;
    }
    else
    { /* block id: 98 */
        uint16_t l_149 = 0xA516L;
        int32_t l_150 = (-1L);
        struct S0 l_151 = {0xE128E9C8L,-10L};
        l_85 = ((uint16_t)((uint32_t)p_63 - (uint32_t)l_88) << (uint16_t)7);
        l_89 = func_79(p_64, ((uint32_t)(__builtin_ctz(p_64) ^ (l_150 = (l_149 = 0x76B26871L))) % (uint32_t)(l_71 = 2L)), l_151, l_151.f1, __builtin_popcountll(l_88));
        if (l_89.f0)
        { /* block id: 104 */
            int32_t l_159 = (-1L);
            for (l_151.f0 = (-2); (l_151.f0 <= 42); l_151.f0 += 2)
            { /* block id: 107 */
                uint32_t l_162 = 18446744073709551611UL;
                for (l_78 = 0; (l_78 > 1); l_78 += 1)
                { /* block id: 110 */
                    for (l_89.f1 = 10; (l_89.f1 == 29); l_89.f1 += 1)
                    { /* block id: 113 */
                        float l_158 = (-0x1.Ep-1);
                        l_88 = (l_158 = l_149);
                        if (l_159)
                            break;
                    }
                }
                if (p_63)
                    continue;
                l_162 = ((int16_t)l_159 + (int16_t)0x14F6L);
            }
        }
        else
        { /* block id: 122 */
            int8_t l_179 = 7L;
            struct S0 l_200 = {18446744073709551615UL,0L};
            int32_t l_201 = 1L;
            int32_t l_232 = 0x7F63BE11L;
            int8_t l_233 = (-1L);
            l_78 = ((uint32_t)p_64 + (uint32_t)0x8269CF34L);
            for (l_90 = (-8); (l_90 == (-9)); l_90 -= 1)
            { /* block id: 126 */
                uint32_t l_174 = 0xE577B4CAL;
                int32_t l_175 = 0xCBD10C21L;
                int32_t l_176 = 0x9F33108CL;
                struct S0 l_234 = {0xFCEB201EL,0x52L};
                for (l_151.f0 = 0; (l_151.f0 != 10); l_151.f0 += 2)
                { /* block id: 129 */
                    struct S0 l_171 = {0xB1BD9B2BL,0x32L};
                    for (l_149 = 0; (l_149 >= 51); l_149 += 1)
                    { /* block id: 132 */
                        return l_171;
                    }
                    for (l_85 = 0; (l_85 >= 23); l_85++)
                    { /* block id: 137 */
                        l_176 = (l_175 = (l_174 = p_63));
                    }
                }
                for (l_89.f0 = 0; (l_89.f0 > 12); l_89.f0 += 1)
                { /* block id: 145 */
                    uint16_t l_190 = 1UL;
                    struct S0 l_191 = {0UL,1L};
                    int32_t l_211 = (-1L);
                    int8_t l_214 = 0xE4L;
                    if ((func_74((l_176 = l_179), ((l_179 > p_63) != ((((__builtin_popcountl(((((uint32_t)func_74(((int16_t)((int16_t)l_174 / (int16_t)(l_190 = (l_175 = __builtin_bswap32(((int16_t)(!(~(l_150 = 0x4584B11EL))) << (int16_t)4))))) << (int16_t)2), p_64, l_191) / (uint32_t)(-1L)) ^ l_191.f0) & l_179)) & p_64) >= l_151.f1) < 0x690FF0A8L) ^ p_64)), l_151) && l_174))
                    { /* block id: 150 */
                        int32_t l_194 = 0L;
                        struct S0 l_215 = {0xFFF882CAL,0xFBL};
                        int32_t l_216 = 8L;
                        l_150 = (((float)(func_74(l_90, l_194, func_79((l_175 && __builtin_clzll(l_90)), ((__builtin_parity(l_176) > (+__builtin_ffs((p_63 & ((uint32_t)((uint16_t)__builtin_parity((l_201 = func_74(p_63, l_179, l_200))) >> (uint16_t)l_151.f0) / (uint32_t)l_191.f0))))) != l_200.f1), l_191, p_63, l_71)) >= l_179) / (float)l_194) < p_64);
                        l_175 = ((float)((float)(((float)(l_194 = ((float)((l_151.f0 < p_63) > (l_194 != ((l_211 = (!p_63)) >= ((float)func_74(l_214, p_64, (l_215 = l_151)) + (float)func_74(((p_64 || 0xDFC4L) > p_63), p_63, l_89))))) + (float)p_64)) + (float)0x2.E17E32p+78) < l_216) + (float)0x0.9EAA1Dp-15) + (float)0x0.4D4EBDp+94);
                    }
                    else
                    { /* block id: 157 */
                        float l_217 = 0x3.6p+1;
                        int32_t l_222 = 0L;
                        l_211 = 0xDD84C012L;
                        l_211 = ((int16_t)((~__builtin_popcountl(p_63)) > (!0x3A8BL)) >> (int16_t)11);
                        l_222 = l_85;
                        l_150 = (-1L);
                    }
                    l_201 = l_211;
                }
                l_85 = ((((int32_t)p_64 % (int32_t)p_63) <= func_74(func_74(func_74((l_201 = (p_64 > (((!((uint16_t)p_64 >> (uint16_t)l_85)) && (l_88 = (l_78 = (((uint32_t)(l_150 = (((l_71 = (0xF9EC2223L && l_201)) & (l_175 = ((3L >= (((uint16_t)(l_232 = l_151.f0) + (uint16_t)3L) != l_89.f0)) == l_149))) != l_85)) + (uint32_t)(-1L)) >= l_233)))) <= p_63))), l_233, l_234), p_64, l_234), l_151.f0, l_151)) | l_179);
            }
            l_201 = (((((l_78 = ((float)(0xD.69E8B4p-44 >= p_64) + (float)__builtin_parityll(l_200.f1))) != (l_85 = 0xC.81397Ap+12)) == func_74(l_237, p_64, func_79(p_64, ((uint32_t)p_64 + (uint32_t)(-1L)), l_151, p_63, l_150))) <= 0x2.2p-1) <= (-0x1.Ep-1));
        }
        l_78 = l_151.f0;
    }
    return l_240;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_74(uint16_t  p_75, uint32_t  p_76, struct S0  p_77)
{ /* block id: 59 */
    int32_t l_95 = (-1L);
    int32_t l_107 = 0x96C032BEL;
    int32_t l_108 = 0x20D9FD67L;
    int32_t l_109 = 3L;
    struct S0 l_110 = {0x8A2FD92DL,-1L};
    int32_t l_140 = 8L;
    for (p_77.f1 = (-29); (p_77.f1 <= (-17)); p_77.f1 += 1)
    { /* block id: 62 */
        uint32_t l_96 = 0xCA6AFE10L;
        l_96 = l_95;
        l_95 = __builtin_ctzll(l_96);
        l_95 = p_77.f0;
        for (l_95 = 0; (l_95 == 28); l_95 += 1)
        { /* block id: 68 */
            int8_t l_99 = 0x0FL;
            l_99 = l_96;
            if (p_75)
                continue;
        }
    }
    p_77 = func_79(l_95, p_75, p_77, (((p_77.f1 > ((+(7UL == l_95)) <= p_77.f0)) < (l_109 = ((((uint32_t)(((uint32_t)(l_108 = (l_107 = l_95)) % (uint32_t)p_77.f0) <= p_76) + (uint32_t)p_77.f0) || 1UL) <= p_77.f0))) == (-7L)), l_95);
    p_77 = func_79(l_108, l_95, l_110, ((int32_t)((p_77.f0 >= l_95) != p_77.f0) / (int32_t)(l_109 & (l_107 = ((p_76 && __builtin_ffs(p_76)) || p_77.f0)))), p_77.f0);
    if (((l_107 = (l_108 = ((int16_t)((int16_t)p_76 << (int16_t)((p_75 = p_75) >= (!((l_109 = (((((int16_t)0x1214L >> (int16_t)0) & 0x9EACL) && (l_110.f1 == l_107)) > p_77.f1)) <= (((int32_t)__builtin_parityl(l_95) + (int32_t)(-1L)) | 0xC64A1B41L))))) - (int16_t)65535UL))) <= 1L))
    { /* block id: 83 */
        struct S0 l_124 = {0xB67715EEL,0x52L};
        l_110 = (p_77 = l_124);
    }
    else
    { /* block id: 86 */
        int32_t l_125 = 0xEC2A0AA5L;
        float l_137 = (-0x1.7p+1);
        int32_t l_138 = (-1L);
        int32_t l_139 = 0x742A4258L;
        int32_t l_141 = 8L;
        l_109 = ((((-0x1.7p+1) == (l_108 = (l_107 = l_125))) >= l_125) == (l_95 >= l_95));
        l_141 = ((l_125 | ((l_125 & __builtin_ctzl(((int16_t)((l_109 = ((l_139 = (p_77.f1 > (p_76 < ((~p_76) & ((uint32_t)((int16_t)((uint16_t)((int32_t)((p_77.f0 < ((p_75 | 1L) > (l_138 = p_75))) >= 0x58E7L) / (int32_t)0x438F6180L) - (uint16_t)p_77.f1) << (int16_t)p_75) - (uint32_t)l_109))))) <= l_140)) || p_77.f0) - (int16_t)p_77.f0))) | l_110.f0)) < 0xFF10L);
    }
    return l_109;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_79(uint32_t  p_80, int8_t  p_81, struct S0  p_82, int32_t  p_83, uint32_t  p_84)
{ /* block id: 56 */
    int32_t l_91 = 0x63BF156DL;
    struct S0 l_92 = {0UL,1L};
    l_91 = l_91;
    return l_92;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 156
   depth: 1, occurrence: 36
XXX total union variables: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 29
   depth: 3, occurrence: 7
   depth: 4, occurrence: 5
   depth: 6, occurrence: 1
   depth: 7, occurrence: 4
   depth: 10, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 6
   depth: 16, occurrence: 1
   depth: 18, occurrence: 4
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 7
   depth: 23, occurrence: 4
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 4
   depth: 27, occurrence: 2
   depth: 31, occurrence: 1
   depth: 33, occurrence: 3
   depth: 34, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 712
XXX times a non-volatile is write: 243
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 1

XXX stmts: 153
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 24
   depth: 2, occurrence: 33
   depth: 3, occurrence: 24
   depth: 4, occurrence: 18
   depth: 5, occurrence: 24

XXX percentage a fresh-made variable is used: 20.5
XXX percentage an existing variable is used: 79.5
********************* end of statistics **********************/

