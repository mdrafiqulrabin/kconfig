/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2083057549
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 5;
   int32_t  f1;
   unsigned f2 : 8;
   const signed f3 : 12;
   unsigned f4 : 3;
   signed f5 : 5;
   int32_t  f6;
   signed : 0;
};

/* --- GLOBAL VARIABLES --- */
static int16_t g_3 = 0x7DD6;
static int32_t g_81 = 0xBA999493;
static struct S0 g_96 = {-2,-1,15,-31,1,-3,-2};
static const struct S0 *g_95 = &g_96;
static const struct S0 g_98 = {-4,-1,8,-48,0,-0,-1};
static uint16_t g_118 = 0xCE25;
static float g_120 = (-0x4.1p-1);
static int32_t *g_122 = &g_96.f6;
static int32_t **g_121 = &g_122;
static struct S0 ***g_215 = (void*)0;
static int16_t g_231 = 1;
static uint8_t g_360 = 0xC9;
static int32_t ***g_398 = &g_121;
static int32_t ****g_397 = &g_398;
static int32_t *****g_396 = &g_397;
static int32_t g_404 = 0xFD62C2FF;
static struct S0 ****g_451 = &g_215;
static struct S0 *****g_450 = &g_451;
static float *g_581 = &g_120;
static float **g_580 = &g_581;
static uint8_t g_616 = 0x14;
static struct S0 *g_780 = (void*)0;
static int32_t g_825 = 1;


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_24(void);
static uint32_t  func_25(uint8_t  p_26, uint8_t  p_27, int32_t  p_28);
static uint8_t  func_29(int32_t  p_30, uint8_t  p_31, uint32_t  p_32);
static float  func_34(int32_t  p_35, float  p_36, uint32_t  p_37, struct S0  p_38, uint8_t  p_39);
static int32_t * func_46(int32_t * p_47, uint32_t  p_48, int32_t * p_49);
static int32_t * func_50(int32_t * p_51, uint8_t  p_52, int32_t  p_53);
static int32_t * func_54(int32_t  p_55, struct S0  p_56);
static int32_t  func_57(uint16_t  p_58, uint8_t  p_59, const int32_t * p_60, int32_t * p_61, uint32_t  p_62);
static uint32_t  func_63(int32_t * p_64, float  p_65, const int32_t * p_66, uint16_t  p_67);
static int32_t * func_68(int16_t  p_69, float  p_70, int32_t  p_71, uint32_t  p_72, const uint32_t  p_73);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_81
 * writes:
 */
static uint8_t  func_24(void)
{ /* block id: 36 */
    int32_t l_33 = 0x302AFF63;
    struct S0 l_44 = {2,0x1DBA1DD7,9,51,1,1,-8};
    uint16_t l_45 = 1U;
    int32_t l_724 = 0x640CEBCF;
    float l_750 = 0x7.4FA47Fp+84;
    int16_t l_765 = 0x4DFD;
    int32_t *l_773 = &g_81;
    struct S0 *l_781 = (void*)0;
    uint32_t l_853 = 0xFF8B0B07;
    int32_t ****l_870 = &g_398;
    return (*l_773);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_25(uint8_t  p_26, uint8_t  p_27, int32_t  p_28)
{ /* block id: 406 */
    int32_t l_723 = 0xE5536225;
    return l_723;
}


/* ------------------------------------------ */
/* 
 * reads : g_118 g_580 g_581 g_121 g_122 g_398 g_81 g_96.f6
 * writes: g_118 g_120 g_81 g_96.f6
 */
static uint8_t  func_29(int32_t  p_30, uint8_t  p_31, uint32_t  p_32)
{ /* block id: 397 */
    uint32_t l_718 = 0xF28484C2;
    const int32_t *l_719 = &g_81;
    const int32_t *l_721 = &g_96.f6;
    int32_t ****l_722 = &g_398;
    for (g_118 = 19; (g_118 <= 39); g_118 += 1)
    { /* block id: 400 */
        const int32_t **l_720 = (void*)0;
        (**g_580) = l_718;
        l_721 = l_719;
        /* statement id: 402 */
        assert (l_721 == &g_81);
        (**g_121) = (l_722 != l_722);
    }
    /* facts after for loop */
    assert (l_721 == &g_81 || l_721 == &g_96.f6);
    return (****l_722);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_81 g_96.f3 g_96.f0 g_98.f4 g_98.f6 g_122 g_121 g_96.f2 g_96.f6 g_118 g_96.f1 g_397 g_398 g_98.f5 g_396 g_450 g_96.f5 g_404 g_98.f1 g_231 g_96.f4 g_581 g_120 g_360 g_580 g_98.f0
 * writes: g_81 g_96.f6 g_122 g_120 g_397 g_404
 */
static float  func_34(int32_t  p_35, float  p_36, uint32_t  p_37, struct S0  p_38, uint8_t  p_39)
{ /* block id: 37 */
    uint32_t l_74 = 7U;
    int32_t *l_80 = &g_81;
    struct S0 l_413 = {-2,0x8710527B,9,-16,1,-2,-1};
    (*g_121) = func_46(func_50(func_54(func_57(__builtin_ia32_crc32qi(func_63(func_68(l_74, ((p_38.f1 <= g_3) > ((((((int16_t)((int32_t)(!65529U) * (int32_t)((void*)0 == l_80)) << (int16_t)((int32_t)g_3 - (int32_t)g_81)) | g_81) && g_81) & p_38.f3) , (-0x1.0p-1))), p_38.f4, p_35, g_81), g_96.f2, l_80, g_96.f0), l_74), p_38.f0, l_80, l_80, l_74), l_413), g_96.f1, p_38.f1), p_38.f2, l_80);
    /* statement id: 390 */
    assert (g_122 == &g_81 || g_122 == &g_96.f6);
    for (g_404 = 5; (g_404 <= 0); g_404--)
    { /* block id: 393 */
        (***g_397) = l_80;
        /* statement id: 394 */
        assert (g_122 == &g_81);
    }
    return (**g_580);
}


/* ------------------------------------------ */
/* 
 * reads : g_98.f5 g_122 g_81 g_96.f6 g_398 g_121 g_96.f2 g_397 g_3 g_98.f4 g_96.f3 g_404 g_581 g_120 g_360 g_396 g_96.f4 g_580 g_96.f1 g_98.f1 g_231 g_118 g_96.f0 g_98.f0
 * writes: g_96.f6 g_122 g_120 g_81 g_404
 */
static int32_t * func_46(int32_t * p_47, uint32_t  p_48, int32_t * p_49)
{ /* block id: 323 */
    int32_t **l_537 = &g_122;
    float *l_547 = (void*)0;
    float **l_546 = &l_547;
    int16_t l_548 = 0x7B59;
    struct S0 l_587 = {3,0xCFBA7764,12,17,1,2,0};
    int32_t *l_590 = (void*)0;
    uint32_t l_631 = 1U;
    struct S0 **l_638 = (void*)0;
    struct S0 ***l_637 = &l_638;
    uint16_t l_652 = 65527U;
    int32_t ****l_657 = &g_398;
    if ((((((uint16_t)(((int16_t)g_98.f5 + (int16_t)((int16_t)((void*)0 != l_537) + (int16_t)((uint32_t)(((int16_t)(**l_537) * (int16_t)(((uint16_t)((void*)0 != l_546) * (uint16_t)(**l_537)) & ((**l_537) > (**l_537)))) || l_548) + (uint32_t)(**l_537)))) && p_48) % (uint16_t)p_48) >= (-4)) | (-3)) > 1U))
    { /* block id: 324 */
        for (g_96.f6 = 0; (g_96.f6 == (-11)); g_96.f6 -= 4)
        { /* block id: 327 */
            (**g_398) = (**g_398);
        }
    }
    else
    { /* block id: 330 */
        int16_t l_555 = 0x1C53;
        const int32_t *l_571 = &g_96.f1;
        int32_t l_595 = 0x9D906CE6;
        int32_t ***l_606 = (void*)0;
        (*g_121) = (((int32_t)((**l_537) | g_96.f2) - (int32_t)((uint16_t)(g_81 , ((l_555 , (*g_397)) == (void*)0)) - (uint16_t)1U)) , p_47);
        if (((-(int16_t)(func_57(((((uint16_t)((uint32_t)(-(uint32_t)((void*)0 != &g_451)) + (uint32_t)9U) / (uint16_t)(__builtin_popcountll((~1U)) | ((int16_t)g_98.f4 - (int16_t)((uint16_t)65535U << (uint16_t)(__builtin_popcount(g_98.f5) , g_96.f3))))) < l_555) , l_555), p_48, l_571, p_47, p_48) , 0xB633)) & 0x010E))
        { /* block id: 332 */
            int32_t l_582 = 0x2EC9CF85;
            struct S0 ***l_639 = &l_638;
            for (g_96.f6 = 0; (g_96.f6 > 26); g_96.f6++)
            { /* block id: 335 */
                uint32_t l_576 = 4294967286U;
                struct S0 l_577 = {0,0x8E2EEE1C,8,-60,1,1,7};
                int32_t *****l_604 = &g_397;
            }
            (*g_581) = ((p_48 <= (((((l_637 != l_639) , (((***g_398) | func_57(p_48, p_48, p_49, (*l_537), g_96.f3)) , g_404)) , l_582) <= 0x4.6p+1) >= (*g_581))) < (**l_537));
            (****g_397) = ((int16_t)((int16_t)g_360 * (int16_t)((int16_t)((int16_t)(((uint32_t)func_57(p_48, func_57(((***g_398) && 0x3FDBF1C4), ((uint16_t)(l_652 ^ ((l_582 > 0x28D11457) , 0x4C470BCA)) - (uint16_t)g_404), (****g_396), (**g_398), p_48), (*l_537), &l_582, (**l_537)) + (uint32_t)0x49102AE3) && p_48) / (int16_t)0x4E3C) << (int16_t)1)) >> (int16_t)5);
        }
        else
        { /* block id: 368 */
            (**g_580) = (0x4.2FA9CEp-36 > __builtin_ctzl(((****g_397) ^ ((((((int16_t)(((((uint32_t)(8 > (*p_47)) + (uint32_t)((p_48 >= (0xE317 ^ g_3)) < 1)) , l_657) == (*g_396)) == g_96.f4) % (int16_t)p_48) != 4294967295U) == 0xEF58) , 1U) | p_48))));
        }
        for (l_595 = (-16); (l_595 <= (-21)); l_595 -= 1)
        { /* block id: 373 */
            return (***g_397);
            /* statement id: 374 */
            //assert (func_46_rv == &g_81 || func_46_rv == &g_96.f6);
        }
        if ((*p_49))
        { /* block id: 376 */
            uint32_t l_662 = 0xBA769C1A;
            struct S0 *l_675 = &g_96;
            struct S0 **l_674 = &l_675;
            (*****g_396) = (***g_398);
            (**g_398) = (*g_121);
            (*p_47) = (~func_63(p_47, p_48, func_50(((*l_571) , (**g_398)), p_48, (*p_47)), g_98.f5));
        }
        else
        { /* block id: 380 */
            int32_t l_694 = (-1);
            (*p_47) = (((uint16_t)g_96.f4 >> (uint16_t)g_96.f6) ^ ((*g_581) , (p_48 | ((int16_t)((int16_t)p_48 * (int16_t)(((((uint16_t)((p_48 && (p_48 , func_57(l_694, g_231, (**g_398), (***l_657), p_48))) , g_96.f4) << (uint16_t)l_694) , p_48) <= l_694) >= p_48)) >> (int16_t)7))));
        }
    }
    for (g_404 = 0; (g_404 == (-18)); g_404--)
    { /* block id: 386 */
        struct S0 l_703 = {2,0,14,28,1,4,0x3289E1DF};
        (***g_398) = (0 ^ ((int16_t)((!0x8A1B) <= (((int32_t)((~(l_703 , ((uint16_t)((((**g_121) , (g_118 == (((uint16_t)((int32_t)((((p_48 > (((uint16_t)((uint32_t)((*l_657) != (*l_657)) - (uint32_t)(****l_657)) * (uint16_t)p_48) > (***g_398))) > g_98.f4) , 0x44C4) != g_96.f4) % (int32_t)g_404) % (uint16_t)0xDEB2) | (**g_121)))) > g_96.f0) | 0xC573) * (uint16_t)(-1)))) != 0x58F2) + (int32_t)g_98.f0) ^ p_48)) << (int16_t)g_360));
    }
    return (*g_121);
    /* statement id: 389 */
    //assert (func_46_rv == &g_81 || func_46_rv == &g_96.f6);
}


/* ------------------------------------------ */
/* 
 * reads : g_81 g_98.f1 g_231 g_118 g_96.f1 g_398 g_121 g_122 g_96.f6 g_96.f4 g_397 g_98.f4 g_404
 * writes: g_81 g_120 g_122 g_96.f6
 */
static int32_t * func_50(int32_t * p_51, uint8_t  p_52, int32_t  p_53)
{ /* block id: 304 */
    int32_t l_491 = (-2);
    struct S0 l_522 = {-4,0x2D4A4537,3,25,0,2,0x425EE4E8};
    uint32_t l_527 = 0x6ABC98EC;
    for (g_81 = 0; (g_81 != 2); g_81 += 1)
    { /* block id: 307 */
        int32_t l_504 = 0;
        int32_t *l_514 = (void*)0;
        int32_t *l_515 = (void*)0;
        struct S0 ****l_528 = &g_215;
        int32_t *l_529 = (void*)0;
        int32_t *l_530 = &l_504;
        if ((g_98.f1 , __builtin_ffsl(l_491)))
        { /* block id: 308 */
            int32_t l_497 = 0x5ED73066;
            float *l_499 = (void*)0;
            float **l_498 = &l_499;
            if (((uint16_t)(((int16_t)(-8) * (int16_t)(-(int16_t)((l_497 , l_498) != (void*)0))) != l_497) / (uint16_t)(((uint32_t)(g_231 != 4294967295U) % (uint32_t)(1U & (((uint16_t)65535U * (uint16_t)l_497) , g_118))) && l_504)))
            { /* block id: 309 */
                uint32_t l_511 = 0x28DB75DD;
                g_120 = ((float)((float)g_96.f1 - (float)l_491) - (float)((float)0xC.6D05DBp-2 * (float)l_511));
            }
            else
            { /* block id: 311 */
                int32_t *l_512 = &g_81;
                if ((***g_398))
                    break;
                (*g_121) = l_512;
                /* statement id: 313 */
                assert (g_122 == &g_81);
                if ((***g_398))
                    break;
            }
        }
        else
        { /* block id: 316 */
            g_120 = g_96.f4;
        }
        g_96.f6 = (-(int32_t)p_53);
        (*l_530) = (((*g_397) == (((uint16_t)((int16_t)(((-(int16_t)g_98.f4) <= (!(l_522 , ((int16_t)((((int16_t)l_527 * (int16_t)0x90CC) && (g_81 ^ ((void*)0 == l_528))) <= ((p_53 | g_404) , 0x8AD1)) * (int16_t)p_53)))) || 0x94565B53) / (int16_t)l_491) * (uint16_t)4) , (*g_397))) && l_522.f4);
    }
    return (**g_398);
    /* statement id: 322 */
    //assert (func_50_rv == &g_81 || func_50_rv == &g_96.f6);
}


/* ------------------------------------------ */
/* 
 * reads : g_96.f6 g_98.f6 g_81 g_118 g_121 g_122 g_96.f1 g_397 g_398 g_98.f5 g_3 g_98.f4 g_96.f0 g_96.f3 g_396 g_96.f2 g_450 g_96.f5 g_404
 * writes: g_96.f6 g_122 g_120 g_81 g_397 g_404
 */
static int32_t * func_54(int32_t  p_55, struct S0  p_56)
{ /* block id: 249 */
    int16_t l_422 = (-1);
    int32_t *l_423 = (void*)0;
    int32_t l_452 = 0xA660723C;
    float l_471 = 0x7.8p-1;
    if (((uint16_t)(p_56.f3 ^ (((g_96.f6 == 0xFFEF) != (~func_57(((int16_t)0x83A3 >> (int16_t)(((uint16_t)g_98.f6 / (uint16_t)((!l_422) && 0xD1C0)) & g_81)), g_118, (*g_121), l_423, g_96.f1))) & l_422)) * (uint16_t)0x8220))
    { /* block id: 250 */
        int32_t l_428 = 1;
        for (l_422 = 0; (l_422 != (-17)); l_422--)
        { /* block id: 253 */
            const int32_t l_433 = 1;
            (**g_121) = (****g_397);
            for (p_56.f1 = 8; (p_56.f1 >= (-21)); p_56.f1 -= 2)
            { /* block id: 257 */
                float l_441 = 0xF.C6A1D4p+54;
                (**g_398) = func_68((((l_428 ^ 0xB50AAFC2) > g_118) , g_118), (((float)((float)g_98.f5 + (float)l_433) + (float)(((float)((!((-0x1.2p-1) >= ((float)((((float)func_63((*g_121), l_433, &l_428, p_56.f2) / (float)g_96.f0) >= l_441) >= 0x1.Bp-1) - (float)0x3.28BF43p+85))) != p_56.f5) / (float)g_98.f6) , p_56.f3)) < p_56.f5), p_55, p_56.f1, g_81);
            }
            for (p_56.f6 = 15; (p_56.f6 >= 28); p_56.f6 += 7)
            { /* block id: 262 */
                (*g_396) = (*g_396);
            }
        }
    }
    else
    { /* block id: 266 */
        int32_t l_461 = 0x392B0C70;
        g_120 = ((float)(((((uint16_t)0x3476 >> (uint16_t)g_96.f2) == ((void*)0 != g_450)) , g_96.f0) != (l_452 , ((float)(((float)p_56.f4 * (float)(((uint16_t)((int16_t)l_461 / (int16_t)(l_461 & 0xCD74454D)) * (uint16_t)0x8D77) , 0xB.E06191p+78)) > 0x9.839793p+95) / (float)0x1.05DD03p+28))) - (float)0x5.B767ABp-16);
        if (p_56.f5)
            goto lbl_465;
lbl_465:
        for (l_452 = 27; (l_452 < (-7)); l_452 -= 9)
        { /* block id: 270 */
            int32_t *l_464 = (void*)0;
            return l_464;
            /* statement id: 271 */
            //assert (func_54_rv == 0);
        }
        for (g_96.f6 = 0; (g_96.f6 == (-12)); g_96.f6--)
        { /* block id: 276 */
            struct S0 *l_487 = (void*)0;
            struct S0 **l_486 = &l_487;
            p_56.f0 = ((-9) == (~g_96.f5));
            if ((****g_397))
                break;
            for (g_404 = 0; (g_404 < 2); g_404++)
            { /* block id: 281 */
                float *l_481 = &l_471;
                float **l_480 = &l_481;
                int32_t l_488 = 0x8FE040A3;
            }
        }
    }
    l_423 = l_423;
    return l_423;
    /* statement id: 303 */
    //assert (func_54_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_57(uint16_t  p_58, uint8_t  p_59, const int32_t * p_60, int32_t * p_61, uint32_t  p_62)
{ /* block id: 246 */
    uint32_t l_411 = 1U;
    int32_t l_412 = 0x5485DCA0;
    l_412 = l_411;
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads : g_96.f6 g_121 g_122 g_3 g_98.f4 g_81
 * writes: g_96.f6 g_122 g_120
 */
static uint32_t  func_63(int32_t * p_64, float  p_65, const int32_t * p_66, uint16_t  p_67)
{ /* block id: 125 */
    const uint8_t l_185 = 0x4D;
    const float *l_187 = &g_120;
    float *l_188 = &g_120;
    int32_t **l_199 = &g_122;
    struct S0 *l_258 = &g_96;
    struct S0 **l_257 = &l_258;
    int32_t l_286 = (-5);
    const int32_t l_326 = 1;
    int32_t l_341 = 0x8D79EC2C;
    struct S0 l_394 = {2,0xA7724EE0,15,44,0,-3,0x2A8E1AED};
    struct S0 ****l_395 = &g_215;
    struct S0 l_409 = {4,-1,1,59,1,0,1};
    for (g_96.f6 = 0; (g_96.f6 < 4); g_96.f6 += 6)
    { /* block id: 128 */
        uint32_t l_184 = 4294967293U;
        float *l_186 = (void*)0;
        (*g_121) = (*g_121);
        g_120 = (((uint32_t)l_184 % (uint32_t)(*p_64)) , (l_185 , ((((void*)0 == l_186) == ((l_185 , l_187) != l_186)) != p_67)));
    }
    (*l_188) = l_185;
    for (g_96.f6 = 0; (g_96.f6 != 1); ++g_96.f6)
    { /* block id: 135 */
        uint8_t l_234 = 0xCD;
        const struct S0 **l_259 = (void*)0;
        int32_t l_262 = 0xB88A4E7F;
        struct S0 ****l_268 = &g_215;
        const int32_t *l_279 = (void*)0;
        const int32_t **l_278 = &l_279;
        const int32_t ***l_277 = &l_278;
        int32_t ***l_336 = &g_121;
        int32_t ****l_335 = &l_336;
        uint16_t l_407 = 8U;
        int32_t *l_408 = &l_394.f1;
    }
    (*l_188) = ((l_409 , __builtin_clz((~p_67))) > (g_98.f4 <= (p_67 , p_65)));
    return (**l_199);
}


/* ------------------------------------------ */
/* 
 * reads : g_81 g_96.f3 g_96.f0 g_98.f4 g_98.f6 g_122 g_121
 * writes: g_81 g_96.f6 g_122
 */
static int32_t * func_68(int16_t  p_69, float  p_70, int32_t  p_71, uint32_t  p_72, const uint32_t  p_73)
{ /* block id: 38 */
    int32_t *l_84 = &g_81;
    int32_t **l_85 = &l_84;
    int32_t l_128 = (-1);
    const struct S0 l_129 = {3,1,15,20,1,-3,-8};
    float l_147 = 0xD.6A84ADp+50;
    int32_t l_176 = 0xF8BFC011;
    (*l_85) = l_84;
    for (p_72 = (-14); (p_72 >= 24); ++p_72)
    { /* block id: 42 */
        uint32_t l_90 = 2U;
        struct S0 *l_99 = &g_96;
        int32_t *l_137 = &g_96.f6;
        uint16_t l_155 = 65526U;
    }
    for (g_81 = 0; (g_81 >= 21); g_81 += 6)
    { /* block id: 117 */
        uint8_t l_171 = 0xF9;
        float *l_177 = &l_147;
        struct S0 *l_179 = &g_96;
        struct S0 **l_178 = &l_179;
        (*l_177) = ((float)((float)((float)g_96.f3 + (float)(((uint16_t)((p_72 ^ (((uint16_t)(((uint16_t)0x9FEA << (uint16_t)l_171) & ((int16_t)g_96.f3 << (int16_t)(((int16_t)(*l_84) >> (int16_t)((((**l_85) != g_96.f0) > g_98.f4) , l_176)) , 0))) << (uint16_t)p_69) ^ 0)) , g_98.f6) + (uint16_t)p_73) , (**l_85))) - (float)l_171) * (float)p_72);
        p_70 = p_71;
        (*g_122) = p_73;
        (*l_178) = (void*)0;
        /* statement id: 121 */
        assert (l_179 == 0);
    }
    (*g_121) = (*g_121);
    return (*g_121);
    /* statement id: 124 */
    //assert (func_68_rv == &g_96.f6);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_24();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_81, "g_81", print_hash_value);
    transparent_crc(g_96.f0, "g_96.f0", print_hash_value);
    transparent_crc(g_96.f1, "g_96.f1", print_hash_value);
    transparent_crc(g_96.f2, "g_96.f2", print_hash_value);
    transparent_crc(g_96.f3, "g_96.f3", print_hash_value);
    transparent_crc(g_96.f4, "g_96.f4", print_hash_value);
    transparent_crc(g_96.f5, "g_96.f5", print_hash_value);
    transparent_crc(g_96.f6, "g_96.f6", print_hash_value);
    transparent_crc(g_98.f0, "g_98.f0", print_hash_value);
    transparent_crc(g_98.f1, "g_98.f1", print_hash_value);
    transparent_crc(g_98.f2, "g_98.f2", print_hash_value);
    transparent_crc(g_98.f3, "g_98.f3", print_hash_value);
    transparent_crc(g_98.f4, "g_98.f4", print_hash_value);
    transparent_crc(g_98.f5, "g_98.f5", print_hash_value);
    transparent_crc(g_98.f6, "g_98.f6", print_hash_value);
    transparent_crc(g_118, "g_118", print_hash_value);
    transparent_crc_bytes (&g_120, sizeof(g_120), "g_120", print_hash_value);
    transparent_crc(g_231, "g_231", print_hash_value);
    transparent_crc(g_360, "g_360", print_hash_value);
    transparent_crc(g_404, "g_404", print_hash_value);
    transparent_crc(g_616, "g_616", print_hash_value);
    transparent_crc(g_825, "g_825", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 167
   depth: 1, occurrence: 17
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 6
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 40
breakdown:
   indirect level: 0, occurrence: 17
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 137

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 74
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 12, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2
   depth: 35, occurrence: 1

XXX total number of pointers: 129

XXX times a variable address is taken: 118
XXX times a pointer is dereferenced on RHS: 237
breakdown:
   depth: 1, occurrence: 127
   depth: 2, occurrence: 69
   depth: 3, occurrence: 14
   depth: 4, occurrence: 21
   depth: 5, occurrence: 6
XXX times a pointer is dereferenced on LHS: 126
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 30
   depth: 3, occurrence: 13
   depth: 4, occurrence: 5
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 545

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 341
   level: 2, occurrence: 200
   level: 3, occurrence: 56
   level: 4, occurrence: 43
   level: 5, occurrence: 23
XXX number of pointers point to pointers: 60
XXX number of pointers point to scalars: 56
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 32.6
XXX average alias set size: 1.32

XXX times a non-volatile is read: 1370
XXX times a non-volatile is write: 410
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 76
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 24
   depth: 2, occurrence: 19
   depth: 3, occurrence: 6

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

