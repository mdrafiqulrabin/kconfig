/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1049229599
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_27(void);
static uint16_t  func_34(int32_t  p_35, uint32_t  p_36, uint8_t  p_37, uint16_t  p_38);
static uint32_t  func_44(int32_t  p_45, float  p_46, uint8_t  p_47);
inline static uint8_t  func_48(int32_t  p_49, int32_t  p_50, uint16_t  p_51);
inline static uint8_t  func_53(uint8_t  p_54, uint32_t  p_55, float  p_56, float  p_57);
static float  func_61(int32_t  p_62, int8_t  p_63, const int64_t  p_64);
static int8_t  func_69(int32_t  p_70, uint16_t  p_71, uint64_t  p_72, uint64_t  p_73, int32_t  p_74);
inline static int32_t  func_84(int32_t * p_85);
inline static int32_t  func_93(int32_t  p_94, uint16_t  p_95);
inline static int32_t * func_99(int32_t * p_100, int32_t  p_101, int32_t  p_102, uint16_t  p_103, int16_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_27(void)
{ /* block id: 36 */
    int32_t l_28 = 0x64E6DC66L;
    uint16_t l_52 = 0x66E5L;
    uint32_t l_894 = 7UL;
    float l_898 = 0x5.CF8900p-62;
    float *l_897 = &l_898;
    float **l_896 = &l_897;
    float ***l_895 = &l_896;
    float l_905 = 0xB.E8201Fp-96;
    float ***l_908 = (void*)0;
    int32_t *l_909 = &l_28;
    float l_912 = (-0x10.0p+1);
lbl_891:
    for (l_28 = 13; (l_28 > (-23)); l_28 -= 3)
    { /* block id: 39 */
        int32_t l_39 = 0L;
        if (((+(func_34((l_39 < ((((uint64_t)l_39 - (uint64_t)l_39) <= 0x09L) < l_39)), (((int16_t)l_28 << (int16_t)(__builtin_bswap32(func_44(l_28, l_39, func_48((l_28 > l_52), l_28, l_39))) <= l_28)) && l_39), l_52, l_52) <= 0L)) | 0xE24CB67A6AE3FC82LL))
        { /* block id: 462 */
            int32_t *l_888 = &l_39;
            if (l_39)
                break;
            (*l_888) = (l_28 | 1UL);
        }
        else
        { /* block id: 465 */
            int32_t *l_890 = &l_39;
            int32_t **l_889 = &l_890;
            (*l_889) = &l_39;
            return l_52;
        }
        if (l_39)
            goto lbl_891;
    }
    (*l_909) = ((((int16_t)l_894 + (int16_t)((void*)0 == l_895)) || ((uint16_t)((uint64_t)((int32_t)func_84(&l_28) - (int32_t)func_34(l_894, l_894, (((int8_t)0L >> (int8_t)(l_908 == &l_896)) <= 0L), l_894)) - (uint64_t)l_52) >> (uint16_t)l_52)) && l_28);
    (**l_896) = (((0xB.3B558Ep-12 > func_34(((void*)0 != (*l_895)), (*l_909), (0UL > (*l_909)), (*l_909))) < ((float)0x1.BC005Cp+25 / (float)(*l_909))) < (*l_909));
    return l_912;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_34(int32_t  p_35, uint32_t  p_36, uint8_t  p_37, uint16_t  p_38)
{ /* block id: 459 */
    float l_880 = 0x0.5p-1;
    float *l_879 = &l_880;
    float **l_878 = &l_879;
    int32_t l_885 = 0L;
    (*l_879) = ((((((((float)((float)((void*)0 == l_878) + (float)((float)(0x9.1p+1 < ((float)p_38 / (float)l_885)) - (float)0x0.Ap-1)) / (float)(0x1.Bp-1 >= l_885)) > ((float)p_38 - (float)p_38)) == 0x1.Cp+1) >= 0x0.Cp-1) < p_35) != p_37) != l_885);
    return l_885;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_44(int32_t  p_45, float  p_46, uint8_t  p_47)
{ /* block id: 431 */
    int64_t l_839 = 0x76E4A401CF8A739ALL;
    int32_t l_847 = (-1L);
    int32_t * const l_846 = &l_847;
    int32_t * const *l_845 = &l_846;
    int32_t *l_873 = &l_847;
    for (p_45 = 0; (p_45 <= 9); p_45 += 2)
    { /* block id: 434 */
        int8_t l_833 = 0L;
        int32_t *l_834 = (void*)0;
        int32_t l_836 = 0xCD81A29EL;
        int32_t *l_835 = &l_836;
        float l_868 = (-0x4.5p+1);
        (*l_835) = l_833;
        (*l_835) = ((((int8_t)p_47 >> (int8_t)l_839) == 0UL) <= ((int8_t)l_839 - (int8_t)(*l_835)));
        if ((((p_47 & 0x3439L) || l_839) > ((((((+(l_845 != &l_834)) > (p_47 >= ((uint16_t)p_45 << (uint16_t)((int64_t)func_93((*l_846), p_45) / (int64_t)18446744073709551615UL)))) || p_47) || (**l_845)) <= p_45) || p_47)))
        { /* block id: 437 */
            int32_t *l_854 = &l_836;
            int32_t **l_855 = &l_854;
            for (l_847 = 0; (l_847 == (-11)); l_847 -= 5)
            { /* block id: 440 */
                return p_45;
            }
            (*l_855) = l_854;
            for (l_839 = 3; (l_839 > 26); l_839 += 1)
            { /* block id: 446 */
                uint16_t l_858 = 0x40F0L;
                float l_860 = 0x0.D3588Ap-5;
                float *l_859 = &l_860;
                int32_t * const **l_870 = &l_845;
                int32_t * const ***l_869 = &l_870;
                (*l_859) = l_858;
                (*l_855) = l_859;
                /* statement id: 448 */
                assert (l_854 == &l_860);
                (*l_869) = (void*)0;
                /* statement id: 449 */
                assert (l_870 == 0);
            }
            /* facts after for loop */
            //assert (l_854 == dangling || l_854 == &l_836);
        }
        else
        { /* block id: 451 */
            int32_t **l_871 = (void*)0;
            int32_t **l_872 = &l_835;
            (*l_872) = &l_836;
            if ((**l_845))
                break;
        }
        if ((*l_846))
            continue;
    }
    l_873 = (*l_845);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_48(int32_t  p_49, int32_t  p_50, uint16_t  p_51)
{ /* block id: 40 */
    uint8_t l_58 = 0xF1L;
    uint16_t l_710 = 5UL;
    int32_t *l_826 = (void*)0;
    int32_t l_828 = (-1L);
    int32_t *l_827 = &l_828;
    int32_t **l_829 = (void*)0;
    int32_t *l_830 = (void*)0;
    (*l_827) = ((((((__builtin_bswap32(p_50) <= func_53(l_58, p_50, p_51, ((0x5.0p+1 != ((((0x8.D832CBp-86 != (((float)func_61(((uint8_t)p_51 >> (uint8_t)0), ((p_50 || 0x87L) | 0L), p_51) + (float)l_58) > l_58)) == l_710) != l_58) >= p_50)) < 0x1.Cp+1))) || 0xCAF80B05L) & 0x3FD8BE6BL) >= p_50) == l_58) == p_49);
    l_830 = (void*)0;
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_53(uint8_t  p_54, uint32_t  p_55, float  p_56, float  p_57)
{ /* block id: 380 */
    uint64_t l_729 = 18446744073709551611UL;
    const uint32_t l_761 = 0xE15A9909L;
    const int32_t * const *l_775 = (void*)0;
    const int32_t * const **l_774 = &l_775;
    const int32_t * const ***l_773 = &l_774;
    int32_t l_806 = 0xCDCF11DCL;
    int32_t **l_807 = (void*)0;
    int32_t *l_808 = &l_806;
    float *l_824 = (void*)0;
    float **l_823 = &l_824;
    float ***l_825 = &l_823;
    for (p_54 = 0; (p_54 <= 27); p_54 += 1)
    { /* block id: 383 */
        uint32_t l_715 = 0xA4851E1FL;
        int32_t l_726 = 0xA8BE2389L;
        int32_t *l_725 = &l_726;
        int32_t **l_724 = &l_725;
        int32_t ***l_723 = &l_724;
        int32_t ****l_722 = &l_723;
        int32_t ****l_728 = (void*)0;
        float l_738 = 0x8.9D5F30p+5;
        float *l_737 = &l_738;
        float **l_736 = &l_737;
        for (p_55 = 19; (p_55 > 13); p_55 -= 5)
        { /* block id: 386 */
            int64_t l_718 = 0x0D44A58109B8730BLL;
            int32_t *l_719 = (void*)0;
            int32_t l_721 = 0x9A48B250L;
            int32_t *l_720 = &l_721;
            int32_t *****l_727 = (void*)0;
            int64_t l_779 = 0x391C17339BE37234LL;
            float ***l_782 = (void*)0;
            (*l_720) = ((l_715 | ((int16_t)7L << (int16_t)l_715)) && l_718);
            l_728 = l_722;
            /* statement id: 388 */
            assert (l_728 == &l_723);
            if ((l_729 ^ p_54))
            { /* block id: 389 */
                (*l_722) = (*l_722);
                return p_54;
            }
            else
            { /* block id: 392 */
                const int32_t l_741 = 0x3D5F59EBL;
                for (l_726 = (-1); (l_726 >= 25); l_726 += 4)
                { /* block id: 395 */
                    uint32_t l_733 = 0x21735952L;
                    float **l_739 = &l_737;
                    uint64_t l_740 = 18446744073709551607UL;
                }
            }
            for (l_729 = 0; (l_729 < 5); l_729 += 1)
            { /* block id: 402 */
                int64_t l_746 = 0L;
                int32_t * const ***l_750 = (void*)0;
                int32_t *l_795 = &l_721;
                int32_t l_796 = 0x45793492L;
                for (l_721 = 15; (l_721 == 4); l_721 -= 6)
                { /* block id: 405 */
                    const int32_t l_757 = 0x09BCC5FDL;
                    uint16_t l_760 = 0UL;
                    int32_t l_763 = 0x289E33AFL;
                    float **l_770 = &l_737;
                    int32_t ***l_789 = &l_724;
                }
                l_806 = (((float)p_57 / (float)(!(((&l_736 != (void*)0) <= p_55) <= ((float)(*l_725) + (float)0xF.FE95C4p-76)))) > ((float)(p_57 == ((float)__builtin_ffsll(p_54) / (float)0x8.A8D379p+53)) + (float)(*l_720)));
                return p_55;
            }
        }
        /* facts after for loop */
        assert (l_728 == &l_723 || l_728 == 0);
        (*l_737) = (**l_724);
    }
    l_808 = (void*)0;
    /* statement id: 424 */
    assert (l_808 == 0);
    l_806 = (~((uint16_t)p_55 >> (uint16_t)((int8_t)(!((int64_t)p_55 % (int64_t)(((int32_t)((((int8_t)(p_55 != p_54) >> (int8_t)p_55) && p_54) != p_55) % (int32_t)(((int32_t)0x78C38C58L + (int32_t)p_55) & p_54)) || 0x38206D5AL))) % (int8_t)p_54)));
    (*l_825) = l_823;
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_61(int32_t  p_62, int8_t  p_63, const int64_t  p_64)
{ /* block id: 41 */
    uint64_t l_75 = 0x5CEC8167BA9AC04BLL;
    int32_t ****l_612 = (void*)0;
    int32_t *****l_611 = &l_612;
    float ***l_622 = (void*)0;
    int32_t * const ***l_647 = (void*)0;
    int32_t * const ****l_646 = &l_647;
    uint8_t l_667 = 0xAFL;
    uint32_t l_677 = 0x8F06794BL;
    uint32_t l_706 = 4294967294UL;
    int32_t l_709 = 0x342F822FL;
    int32_t *l_708 = &l_709;
    int32_t **l_707 = &l_708;
    if (((int16_t)((func_69(p_64, l_75, p_63, p_62, (+((0x0CL > (__builtin_ctzll(p_64) && l_75)) && (p_64 != l_75)))) <= l_75) | 4L) >> (int16_t)9))
    { /* block id: 299 */
        float ** const *l_582 = (void*)0;
        int32_t l_587 = 0xBF043807L;
        uint64_t l_598 = 0x5AEA0100CADD5DA0LL;
        if (((l_582 != (void*)0) >= (0x741943BED0798762LL == ((int64_t)((int16_t)(l_587 ^ (p_64 || p_62)) << (int16_t)13) % (int64_t)18446744073709551615UL))))
        { /* block id: 300 */
            if (((((((~((uint16_t)((uint32_t)p_62 / (uint32_t)0x267B111FL) / (uint16_t)l_75)) & l_587) < __builtin_parityl(p_64)) ^ ((+l_75) > ((int32_t)(((int32_t)l_598 + (int32_t)p_62) == 0x774FL) + (int32_t)7L))) >= p_64) > 5L))
            { /* block id: 301 */
                uint16_t l_599 = 0x1087L;
                return l_599;
            }
            else
            { /* block id: 303 */
                int32_t *l_601 = (void*)0;
                int32_t **l_600 = &l_601;
                int32_t *l_608 = &l_587;
                (*l_600) = &p_62;
                /* statement id: 304 */
                assert (l_601 == &p_62);
                for (l_75 = (-14); (l_75 < 42); l_75 += 1)
                { /* block id: 307 */
                    float l_604 = 0x1.Ep+1;
                    int32_t l_606 = (-7L);
                    float *l_607 = &l_604;
                    (*l_607) = (((*l_601) >= ((0x0.3p-1 > l_604) != p_62)) == (((-0x1.Fp+1) <= func_69((!l_598), l_606, l_75, p_63, p_62)) <= l_606));
                    if (p_64)
                        break;
                    (*l_601) = 1L;
                }
                (*l_600) = (void*)0;
                /* statement id: 312 */
                assert (l_601 == 0);
                (*l_608) = (__builtin_parity(((-8L) >= p_62)) <= l_75);
            }
        }
        else
        { /* block id: 315 */
            int32_t *l_614 = &l_587;
            int32_t **l_613 = &l_614;
            int16_t l_641 = 0xB109L;
            for (p_63 = (-23); (p_63 < (-5)); p_63 += 1)
            { /* block id: 318 */
                int32_t ***l_615 = &l_613;
                l_611 = l_611;
                (*l_615) = l_613;
            }
            for (l_75 = 18; (l_75 > 40); l_75 += 7)
            { /* block id: 324 */
                float l_623 = (-0x5.9p+1);
                int32_t *l_624 = &l_587;
                float *l_630 = &l_623;
                float **l_629 = &l_630;
            }
        }
    }
    else
    { /* block id: 342 */
        uint16_t l_642 = 7UL;
        int32_t * const **l_645 = (void*)0;
        int32_t * const ***l_644 = &l_645;
        int32_t * const **** const l_643 = &l_644;
        int32_t *l_671 = (void*)0;
        uint64_t l_705 = 18446744073709551614UL;
lbl_648:
        if (l_642)
        { /* block id: 343 */
            p_62 = 2L;
        }
        else
        { /* block id: 345 */
            l_646 = l_643;
            /* statement id: 346 */
            assert (l_646 == &l_644);
            if (p_64)
                goto lbl_648;
        }
        for (p_62 = (-8); (p_62 >= (-16)); p_62 -= 1)
        { /* block id: 351 */
            int32_t l_652 = 0xD16394A2L;
            float l_654 = 0x0.7p-1;
            float *l_653 = &l_654;
            int32_t l_666 = 6L;
            (*l_653) = (-(float)l_652);
            if (p_63)
                break;
            for (p_63 = (-9); (p_63 == (-22)); p_63 -= 1)
            { /* block id: 356 */
                int32_t **l_659 = (void*)0;
                int32_t ** const *l_658 = &l_659;
                int32_t ** const * const * const l_657 = &l_658;
                int32_t * const * const ***l_660 = (void*)0;
                int32_t ** const * const *l_661 = &l_658;
                l_661 = l_657;
                if (p_63)
                { /* block id: 358 */
                    int32_t ***l_664 = &l_659;
                    l_666 = (((uint8_t)((*l_657) == l_664) << (uint8_t)(p_63 | (~p_64))) & ((void*)0 != &l_661));
                    return l_667;
                }
                else
                { /* block id: 361 */
                    int32_t *l_668 = &l_666;
                    l_666 = l_666;
                    l_671 = func_99(l_668, p_62, (*l_668), l_666, (__builtin_popcountl(p_64) & ((l_666 || p_64) != (((uint8_t)p_62 / (uint8_t)p_64) >= l_652))));
                    (*l_653) = (0x5.0F2B8Fp-43 <= p_62);
                    if (p_64)
                        continue;
                }
                (*l_653) = ((float)((0x0.9p-1 <= ((float)(0x1.4p+1 > ((+l_677) < p_64)) / (float)(!p_63))) != ((float)((float)(p_64 != (func_69(((uint32_t)(1UL | l_652) / (uint32_t)p_62), p_63, p_63, p_63, p_63) >= l_666)) - (float)p_64) - (float)p_62)) + (float)p_62);
            }
        }
        for (l_677 = 0; (l_677 >= 31); l_677 += 1)
        { /* block id: 372 */
            uint16_t l_687 = 0x0324L;
            int32_t l_690 = 0xB81BEB09L;
            float *l_691 = (void*)0;
            float l_693 = 0x0.6p-1;
            float *l_692 = &l_693;
            (*l_692) = (0x0.D5DB41p-39 < ((-0x3.5p+1) == (__builtin_parityl((p_62 ^ ((l_687 ^ ((uint8_t)(l_690 ^ p_63) << (uint8_t)4)) || p_63))) >= p_63)));
            p_62 = (((int64_t)p_63 % (int64_t)((uint16_t)(((uint16_t)l_687 + (uint16_t)(+(func_69((p_62 > p_64), (p_62 ^ (((uint16_t)((int64_t)(((l_671 != (void*)0) < ((((void*)0 == (**l_643)) ^ 0L) ^ p_62)) < p_64) % (int64_t)l_687) >> (uint16_t)3) ^ 0xE5L)), p_64, p_62, l_705) != p_62))) < l_706) << (uint16_t)6)) <= 0xDCA194C6L);
            (*l_692) = p_64;
        }
    }
    /* facts after branching */
    //assert (l_646 == dangling || l_646 == &l_647);
    (*l_707) = (void*)0;
    /* statement id: 378 */
    assert (l_708 == 0);
    return p_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_69(int32_t  p_70, uint16_t  p_71, uint64_t  p_72, uint64_t  p_73, int32_t  p_74)
{ /* block id: 42 */
    int32_t **l_77 = (void*)0;
    int32_t l_80 = 0L;
    int32_t *l_79 = &l_80;
    int32_t **l_78 = &l_79;
    const uint16_t l_571 = 0xD1DCL;
    int32_t *** const l_581 = &l_77;
    int32_t *** const *l_580 = &l_581;
    (*l_78) = &p_74;
    /* statement id: 43 */
    assert (l_79 == &p_74);
    for (p_70 = 0; (p_70 > 5); p_70 += 1)
    { /* block id: 46 */
        uint8_t l_83 = 0x1CL;
        int32_t *l_86 = &l_80;
        uint32_t l_552 = 0x838411B8L;
        const int16_t l_575 = 0x3ECFL;
        if (p_70)
            break;
        if (((l_83 != func_84(l_86)) < (l_552 != p_74)))
        { /* block id: 282 */
            int64_t l_555 = 0xDCC6FA711EAD79FBLL;
            int32_t l_565 = 1L;
            (*l_86) = ((int16_t)0xC467L >> (int16_t)l_555);
            (*l_86) = p_70;
            for (p_71 = (-17); (p_71 == 56); p_71 += 1)
            { /* block id: 287 */
                float *l_558 = (void*)0;
                float l_560 = 0x6.0p-1;
                float *l_559 = &l_560;
                int32_t l_566 = 0x6C5446F4L;
                int32_t *l_567 = &l_80;
                (*l_559) = p_73;
                l_567 = func_99((*l_78), p_74, l_555, (**l_78), l_565);
                /* statement id: 289 */
                assert (l_567 == 0);
            }
        }
        else
        { /* block id: 291 */
            uint32_t l_568 = 18446744073709551615UL;
            float l_579 = 0x0.5p-1;
            float *l_578 = &l_579;
            l_568 = (((*l_79) >= (p_71 == ((p_74 == p_70) ^ 255UL))) | p_71);
            (*l_578) = ((float)(((0x7.Ep-1 == l_571) == ((float)l_568 / (float)((l_568 < (-0x7.Cp+1)) != l_568))) == p_70) + (float)l_568);
        }
        return p_72;
    }
    l_580 = l_580;
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_84(int32_t * p_85)
{ /* block id: 48 */
    uint16_t l_87 = 65529UL;
    float l_543 = (-0x1.Dp-1);
    float *l_542 = &l_543;
    float **l_541 = &l_542;
    if (__builtin_popcountll((l_87 >= (l_87 >= ((~0xF2L) | l_87)))))
    { /* block id: 49 */
        int32_t l_90 = 0x65D5A10DL;
        int32_t * const l_89 = &l_90;
        int32_t *l_92 = (void*)0;
        int32_t **l_91 = &l_92;
        (*l_91) = l_89;
        /* statement id: 50 */
        assert (l_92 == &l_90);
    }
    else
    { /* block id: 51 */
        int16_t l_96 = 0x6771L;
        int32_t l_544 = 0L;
        (*p_85) = func_93(l_87, l_96);
        l_544 = (l_87 < ((void*)0 == l_541));
        for (l_544 = 0; (l_544 < (-5)); l_544 -= 1)
        { /* block id: 274 */
            int32_t *l_547 = &l_544;
            int32_t l_549 = 0L;
            int32_t **l_550 = (void*)0;
            int32_t **l_551 = &l_547;
            (*p_85) = l_87;
            (*l_551) = func_99(l_547, ((((func_93((+(-9L)), (*l_547)) != (*l_547)) == 0xCCAB8F38L) && (*l_547)) != __builtin_ia32_crc32qi(l_87, (*l_547))), l_87, l_549, l_87);
            /* statement id: 276 */
            assert (l_547 == 0);
            if ((*p_85))
                continue;
            (*l_551) = &l_544;
            /* statement id: 278 */
            assert (l_547 == &l_544);
        }
    }
    return (*p_85);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_93(int32_t  p_94, uint16_t  p_95)
{ /* block id: 52 */
    int32_t l_106 = 0xCD180C48L;
    int32_t *l_105 = &l_106;
    float l_327 = (-0x1.3p+1);
    float *l_326 = &l_327;
    float **l_325 = &l_326;
    int32_t *****l_432 = (void*)0;
    int32_t l_509 = 1L;
    int32_t **l_537 = &l_105;
    int32_t ***l_536 = &l_537;
    int32_t * const *l_539 = (void*)0;
    int32_t * const **l_538 = &l_539;
    int32_t *l_540 = &l_509;
    if (p_94)
    { /* block id: 53 */
        uint16_t l_107 = 0x2A2DL;
        float l_318 = 0xE.60922Dp+47;
        float *l_317 = &l_318;
        int32_t **l_319 = &l_105;
        uint64_t l_328 = 0x6CC775CB11263A52LL;
        int8_t l_329 = 0xE7L;
        for (p_94 = (-5); (p_94 > 10); p_94 += 3)
        { /* block id: 56 */
            const int32_t **l_300 = (void*)0;
            int32_t **l_301 = &l_105;
            if (p_95)
                break;
        }
        (*l_317) = ((float)((float)(0x5.51B945p+48 != p_94) / (float)((float)((float)0xC.717930p+71 - (float)0x0.Bp-1) - (float)(((!(((float)(__builtin_ffsl((((int16_t)((int16_t)p_94 / (int16_t)p_94) << (int16_t)(*l_105)) > 18446744073709551615UL)) < p_94) - (float)p_94) >= (-0x1.4p+1))) == (*l_105)) >= p_95))) - (float)0x0.F14A98p-75);
        (*l_319) = &l_106;
        (*l_319) = func_99((*l_319), (p_95 == (*l_105)), ((int16_t)(~((uint64_t)((void*)0 != l_325) - (uint64_t)(p_95 >= (__builtin_ctz((((((*l_319) == &l_106) != ((l_328 == 0x1A74L) < p_95)) | p_94) != p_94)) < (*l_105))))) << (int16_t)p_95), l_329, p_95);
        /* statement id: 158 */
        assert (l_105 == 0);
    }
    else
    { /* block id: 159 */
        const int32_t ***l_347 = (void*)0;
        const int32_t ****l_346 = &l_347;
        const int32_t *****l_345 = &l_346;
        float ***l_388 = &l_325;
        int16_t l_444 = 0x5DDEL;
        for (l_106 = (-15); (l_106 >= (-27)); l_106 -= 7)
        { /* block id: 162 */
            uint8_t l_336 = 255UL;
            int32_t l_366 = (-6L);
            int32_t *l_365 = &l_366;
            int32_t * const *l_404 = &l_365;
            int32_t * const **l_403 = &l_404;
            int32_t * const ***l_402 = &l_403;
            int32_t * const ****l_401 = &l_402;
            int8_t l_405 = 0x7EL;
            int32_t **l_443 = &l_365;
            for (p_94 = 0; (p_94 <= 22); p_94 += 1)
            { /* block id: 165 */
                int16_t l_358 = 0L;
                int32_t l_360 = 3L;
                const int32_t *l_371 = (void*)0;
                const int32_t **l_370 = &l_371;
                int16_t l_413 = (-1L);
                uint64_t l_423 = 0xF6AE4E403861C090LL;
                int32_t **l_429 = &l_105;
                int32_t ***l_428 = &l_429;
                int32_t *** const *l_427 = &l_428;
            }
            (*l_443) = func_99(&l_366, p_95, ((int16_t)p_95 >> (int16_t)11), (l_432 == &l_402), (((uint64_t)p_95 - (uint64_t)((+(((*l_401) == (void*)0) != (((((int32_t)((((int32_t)((uint32_t)(+(****l_402)) - (uint32_t)0xF1C41A08L) - (int32_t)(**l_404)) < (****l_402)) && (***l_403)) + (int32_t)p_95) > 0UL) & p_95) > (**l_404)))) & p_95)) >= (****l_402)));
            /* statement id: 209 */
            assert (l_365 == 0);
        }
    }
    /* facts after branching */
    assert (l_105 == &l_106 || l_105 == 0);
    if (l_106)
    { /* block id: 217 */
        const int32_t *l_452 = (void*)0;
        const int32_t **l_451 = &l_452;
        const int32_t ** const *l_463 = &l_451;
        const int32_t ** const **l_462 = &l_463;
        const int32_t ** const ** const *l_461 = &l_462;
        int32_t l_502 = (-1L);
        int32_t *l_525 = &l_106;
        for (p_94 = 0; (p_94 == 22); p_94 += 1)
        { /* block id: 220 */
            int32_t **l_454 = &l_105;
            int32_t ***l_453 = &l_454;
            (*l_326) = (p_94 != p_94);
            (*l_453) = l_451;
            /* statement id: 222 */
            assert (l_454 == &l_452);
        }
        (*l_525) = __builtin_parityll(p_94);
    }
    else
    { /* block id: 264 */
        uint64_t l_526 = 0x7B733B5EDC1AEA65LL;
        int32_t *l_527 = &l_106;
        int32_t **l_528 = &l_105;
        (*l_528) = l_527;
        /* statement id: 265 */
        assert (l_105 == &l_106);
    }
    (*l_540) = (((((+(((int16_t)(-10L) + (int16_t)(2L ^ (p_94 < (((p_95 == p_94) || (p_94 | ((uint8_t)p_94 / (uint8_t)p_94))) != (l_536 != l_538))))) || p_95)) && 0x5B662D18C72D4844LL) & 18446744073709551613UL) & p_95) == p_94);
    (*l_540) = ((0UL >= p_95) > 0xF234A87FL);
    return p_94;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_99(int32_t * p_100, int32_t  p_101, int32_t  p_102, uint16_t  p_103, int16_t  p_104)
{ /* block id: 58 */
    uint32_t l_112 = 1UL;
    int32_t l_122 = 1L;
    int32_t *l_121 = &l_122;
    int32_t *l_129 = &l_122;
    int32_t *l_132 = &l_122;
    int32_t *l_133 = &l_122;
    int32_t *l_134 = &l_122;
    int32_t *l_136 = &l_122;
    int32_t *l_210 = &l_122;
    int32_t ***l_265 = (void*)0;
    uint8_t l_280 = 0x0EL;
    int32_t **l_290 = &l_134;
    float l_294 = 0x1.Ep+1;
    float *l_293 = &l_294;
    float **l_292 = &l_293;
    float ***l_291 = &l_292;
    int32_t *l_295 = &l_122;
    int32_t *l_296 = &l_122;
    int32_t *l_297 = &l_122;
    int32_t *l_298 = &l_122;
    int32_t *l_299 = (void*)0;
    if ((l_112 < l_112))
    { /* block id: 59 */
        int32_t *l_123 = &l_122;
        int32_t *l_127 = &l_122;
        int32_t *l_131 = &l_122;
        int32_t *l_135 = &l_122;
        int32_t *l_137 = &l_122;
        int32_t *l_138 = &l_122;
        int32_t *l_139 = &l_122;
        int32_t *l_140 = (void*)0;
        for (p_103 = (-30); (p_103 < 56); p_103 += 4)
        { /* block id: 62 */
            int32_t l_120 = 0L;
            int32_t *l_119 = &l_120;
            int32_t *l_125 = &l_120;
            int32_t *l_130 = (void*)0;
            for (l_112 = 0; (l_112 == 48); l_112 += 9)
            { /* block id: 65 */
                int32_t l_118 = 0xB1DFEB85L;
                int32_t *l_117 = &l_118;
                l_117 = l_117;
            }
            if (((void*)0 == &p_100))
            { /* block id: 68 */
                int32_t *l_124 = (void*)0;
                if (l_112)
                    break;
                return l_124;
                /* statement id: 70 */
                //assert (func_99_rv == 0);
            }
            else
            { /* block id: 71 */
                int32_t *l_126 = &l_120;
                int32_t *l_128 = &l_122;
                return l_130;
                /* statement id: 72 */
                //assert (func_99_rv == 0);
            }
        }
        return l_140;
        /* statement id: 75 */
        //assert (func_99_rv == 0);
    }
    else
    { /* block id: 76 */
        uint32_t l_170 = 1UL;
        const int32_t ****l_184 = (void*)0;
        const int32_t *****l_183 = &l_184;
        int32_t *l_203 = &l_122;
        int32_t *l_204 = &l_122;
        int32_t *l_208 = &l_122;
        int32_t **l_249 = &l_129;
        int32_t ***l_248 = &l_249;
        int32_t ****l_250 = &l_248;
        for (l_122 = 0; (l_122 != (-5)); l_122 -= 1)
        { /* block id: 79 */
            int32_t ***l_143 = (void*)0;
            int32_t ****l_144 = &l_143;
            int32_t *l_206 = &l_122;
            int32_t *l_207 = &l_122;
            int32_t **l_246 = (void*)0;
            int32_t **l_247 = &l_204;
            (*l_144) = l_143;
        }
        (*l_208) = (p_102 <= 0L);
        (*l_250) = l_248;
        (**l_249) = (p_101 != (((*l_134) | ((0x9DA5B25BL < 1UL) | 0L)) > ((int8_t)((uint8_t)0x88L + (uint8_t)(((0xDEL ^ ((uint64_t)((uint16_t)__builtin_ctzll((1L | ((int16_t)(((int32_t)(((int16_t)((l_265 != l_265) <= (*p_100)) - (int16_t)(*l_134)) ^ (*l_133)) - (int32_t)(*l_210)) > (*l_133)) + (int16_t)p_103))) - (uint16_t)p_104) + (uint64_t)0x0313B4598823A165LL)) && 0xBAL) & (*l_133))) + (int8_t)p_103)));
    }
    if (((&l_265 == &l_265) && (((((&l_133 != (void*)0) == (0xDE91FDDAL >= (*p_100))) == (((void*)0 == &p_102) < (-1L))) <= p_101) >= p_104)))
    { /* block id: 141 */
        int16_t l_268 = 0x57BCL;
        int32_t **** const l_276 = &l_265;
        uint32_t l_279 = 8UL;
        (*l_129) = ((float)((((-0x4.8p-1) == l_268) <= ((float)(p_101 < __builtin_bswap64(((uint16_t)(((!((int32_t)((l_276 == (void*)0) | ((int16_t)p_103 >> (int16_t)l_279)) / (int32_t)((*l_133) || (p_101 | (*l_136))))) | p_103) || p_101) - (uint16_t)p_104))) + (float)0x0.9p-1)) < 0xD.0E0DADp+97) - (float)l_280);
    }
    else
    { /* block id: 143 */
        int32_t *l_284 = &l_122;
        int32_t *l_287 = (void*)0;
        if ((p_102 ^ ((int16_t)0xB64FL - (int16_t)0xEB90L)))
        { /* block id: 144 */
            int32_t *l_283 = &l_122;
            int32_t *l_285 = &l_122;
            int32_t *l_286 = &l_122;
            return l_287;
            /* statement id: 145 */
            //assert (func_99_rv == 0);
        }
        else
        { /* block id: 146 */
            int32_t **l_288 = (void*)0;
            int32_t **l_289 = &l_133;
            (*l_289) = (void*)0;
            /* statement id: 147 */
            assert (l_133 == 0);
        }
        /* facts after branching */
        assert (l_133 == 0);
        return l_287;
        /* statement id: 149 */
        //assert (func_99_rv == 0);
    }
    (*l_290) = &p_102;
    /* statement id: 151 */
    assert (l_134 == &p_102);
    (*l_291) = (void*)0;
    /* statement id: 152 */
    assert (l_292 == 0);
    return l_299;
    /* statement id: 153 */
    //assert (func_99_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 222
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 156
   depth: 2, occurrence: 34
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1

XXX total number of pointers: 224

XXX times a variable address is taken: 228
XXX times a pointer is dereferenced on RHS: 133
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 19
   depth: 3, occurrence: 5
   depth: 4, occurrence: 5
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 106
breakdown:
   depth: 1, occurrence: 94
   depth: 2, occurrence: 8
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 689

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 631
   level: 2, occurrence: 80
   level: 3, occurrence: 46
   level: 4, occurrence: 49
   level: 5, occurrence: 33
XXX number of pointers point to pointers: 119
XXX number of pointers point to scalars: 105
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29
XXX average alias set size: 1.25

XXX times a non-volatile is read: 1120
XXX times a non-volatile is write: 300
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 151
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 36
   depth: 2, occurrence: 44
   depth: 3, occurrence: 26
   depth: 4, occurrence: 9

XXX percentage a fresh-made variable is used: 12.6
XXX percentage an existing variable is used: 87.4
********************* end of statistics **********************/

