/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2869398806
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   const uint32_t  f1;
   int8_t  f2;
   int16_t  f3;
   int16_t  f4;
   signed f5 : 2;
   uint8_t  f6;
   const int16_t  f7;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int8_t g_10 = 0x91;
static int32_t g_27 = 0x2E607D19;
static struct S0 g_105 = {2U,0x6FF5532C,1,0,2,0,0xCA,0x23F1};
static struct S0 *g_104 = &g_105;
static int32_t *g_109 = (void*)0;
static int32_t **g_108 = &g_109;
static uint8_t g_127 = 0U;
static const uint8_t g_151 = 0xE4;
static const int32_t g_213 = 0x4804F9BF;
static const int32_t g_215 = 0x924758F7;
static int32_t g_219 = 0x435D7CC8;
static uint8_t *g_225 = &g_127;
static uint8_t **g_224 = &g_225;
static const int16_t *g_348 = &g_105.f4;
static const int16_t g_375 = (-1);
static uint32_t *g_384 = &g_105.f0;
static uint32_t **g_383 = &g_384;
static uint8_t ***g_397 = &g_224;
static uint8_t ****g_396 = &g_397;
static int16_t *g_404 = &g_105.f3;
static int32_t *g_417 = &g_27;
static uint16_t g_442 = 0xF4DE;
static int16_t **g_454 = &g_404;
static int16_t ***g_453 = &g_454;
static int16_t *g_457 = &g_105.f3;


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_1(void);
static int32_t * func_2(uint16_t  p_3, uint16_t  p_4, int32_t  p_5, int32_t * p_6, uint32_t  p_7);
static const uint8_t  func_8(uint32_t  p_9);
inline static uint16_t  func_19(int32_t  p_20, uint32_t  p_21);
static int32_t *** func_33(int32_t *** p_34, uint8_t  p_35, uint32_t  p_36);
static int32_t *** func_37(const int32_t * p_38, int8_t  p_39, int32_t *** p_40, int16_t  p_41, int32_t * p_42);
static int32_t *** func_43(int32_t *** p_44, const uint8_t  p_45, uint16_t  p_46, int32_t * p_47);
inline static uint8_t  func_51(int32_t ** p_52, const uint32_t  p_53, const int8_t  p_54);
inline static int16_t  func_58(int32_t  p_59, int32_t ** p_60, int8_t  p_61, int32_t *** p_62);
static int32_t ** func_64(int8_t  p_65, const int8_t  p_66, int32_t ** p_67, const int32_t *** p_68, int16_t  p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_10 g_27 g_108 g_105.f5 g_105.f3 g_105.f1 g_105.f4 g_109 g_105.f7 g_127 g_105.f6 g_213 g_105.f0 g_224 g_225 g_219 g_215 g_348 g_105.f2 g_375 g_383 g_396 g_384 g_442 g_453 g_454 g_404 g_151
 * writes: g_27 g_104 g_105.f6 g_127 g_105.f2 g_109 g_105.f4 g_105.f3 g_224 g_105.f0 g_219 g_10 g_225 g_383 g_396 g_404 g_417 g_442 g_457
 */
inline static uint16_t  func_1(void)
{ /* block id: 0 */
    int8_t l_15 = (-3);
    int32_t l_16 = (-5);
    int32_t *l_26 = &g_27;
    int32_t l_418 = 0xD5BF3B3C;
    int8_t l_419 = 0xBD;
    int32_t *l_458 = &g_219;
    int16_t l_459 = 5;
    (*g_108) = func_2((func_8((g_10 || ((uint8_t)((((int8_t)g_10 - (int8_t)l_15) > l_16) || 1U) + (uint8_t)(((int16_t)g_10 >> (int16_t)func_19(l_16, ((int8_t)(l_16 || ((*l_26) = ((((uint16_t)g_10 % (uint16_t)g_10) || g_10) != 0))) * (int8_t)g_10))) | 0xB948)))) > l_15), g_105.f5, l_418, &l_16, l_419);
    /* statement id: 198 */
    assert (g_104 == 0 || g_104 == &g_105);
    assert (g_109 == &g_27);
    assert (g_224 == 0 || g_224 == &g_225);
    assert (g_404 == 0 || g_404 == &g_105.f3);
    //assert (g_417 == &g_27 || g_417 == dangling);
    (*l_26) = ((uint16_t)(g_442 & ((int16_t)((uint16_t)(((uint16_t)((((g_453 != &g_454) || (*g_109)) | ((uint32_t)(0x82E7 != (*l_26)) - (uint32_t)((**g_453) == (g_457 = (void*)0)))) == ((((*l_458) = (*l_26)) > (*g_109)) < (*l_26))) >> (uint16_t)5) > (*l_26)) * (uint16_t)g_151) + (int16_t)(*l_26))) + (uint16_t)l_459);
    /* statement id: 201 */
    assert (g_457 == 0);
    return (*l_458);
}


/* ------------------------------------------ */
/* 
 * reads : g_383 g_384 g_105.f0 g_225 g_105.f6 g_105.f7 g_108
 * writes: g_105.f2 g_105.f4 g_127 g_442 g_109
 */
static int32_t * func_2(uint16_t  p_3, uint16_t  p_4, int32_t  p_5, int32_t * p_6, uint32_t  p_7)
{ /* block id: 189 */
    uint8_t l_424 = 0U;
    int8_t *l_425 = &g_105.f2;
    int16_t *l_440 = &g_105.f4;
    uint16_t *l_441 = &g_442;
    int32_t l_443 = 3;
    int32_t *l_444 = &g_27;
    (*p_6) = (l_443 = (((*l_441) = (((uint8_t)p_3 + (uint8_t)((*l_425) = ((~(0 | (-(uint16_t)0xD8A8))) && l_424))) < ((int16_t)((int32_t)((uint8_t)((*g_225) = ((uint8_t)(p_4 <= (!(&g_109 != &g_109))) % (uint8_t)(~((*l_440) = ((int16_t)(((uint8_t)l_424 * (uint8_t)(&l_424 == &l_424)) < (**g_383)) * (int16_t)(-6)))))) >> (uint8_t)g_105.f6) % (int32_t)(*p_6)) * (int16_t)g_105.f7))) | 0x39C4));
    (*g_108) = &l_443;
    /* statement id: 196 */
    assert (g_109 == &l_443);
    return l_444;
    /* statement id: 197 */
    //assert (g_109 == dangling);
    //assert (func_2_rv == &g_27);
}


/* ------------------------------------------ */
/* 
 * reads : g_225 g_127 g_215 g_219 g_108 g_109 g_105.f1 g_348 g_105.f2 g_375 g_383 g_27 g_213 g_396
 * writes: g_105.f0 g_10 g_127 g_105.f2 g_219 g_109 g_225 g_105.f4 g_224 g_27 g_383 g_396 g_404 g_105.f3 g_417
 */
static const uint8_t  func_8(uint32_t  p_9)
{ /* block id: 92 */
    uint8_t ***l_291 = &g_224;
    uint8_t ***l_292 = &g_224;
    uint32_t *l_305 = &g_105.f0;
    uint8_t ***l_313 = &g_224;
    int32_t l_314 = 0x7B0C9AB2;
    int8_t *l_315 = &g_105.f2;
    int32_t *l_316 = &g_219;
    struct S0 **l_335 = &g_104;
    int16_t **l_411 = &g_404;
    int32_t **l_415 = &l_316;
    int32_t **l_416 = (void*)0;
    (*l_316) = (((*l_315) = ((((l_291 = l_291) == l_292) && p_9) ^ (((uint8_t)(l_314 = (0x73 ^ ((uint8_t)(((int8_t)((((int16_t)((((int8_t)(((uint8_t)((*g_225) = (((g_10 = (((*l_305) = 0x9C812F4B) || (((int16_t)((uint32_t)p_9 - (uint32_t)((~((uint8_t)((void*)0 == l_313) % (uint8_t)l_314)) <= l_314)) % (int16_t)0xCA4C) ^ 4294967295U))) || (*g_225)) & 5U)) << (uint8_t)p_9) || 0x39) - (int8_t)0x0A) == l_314) == 65535U) * (int16_t)p_9) >= l_314) < p_9) % (int8_t)l_314) <= 0) * (uint8_t)p_9))) + (uint8_t)g_215) || g_127))) ^ 1U);
    if ((*l_316))
    { /* block id: 100 */
        int8_t l_327 = 0xAA;
        int32_t l_330 = (-9);
        uint8_t ***l_359 = &g_224;
        if ((0x044A < p_9))
        { /* block id: 101 */
            (*g_108) = (*g_108);
        }
        else
        { /* block id: 103 */
            uint8_t *l_329 = &g_127;
            int32_t l_331 = 8;
            int16_t *l_332 = &g_105.f4;
            if (((uint8_t)(((int8_t)((void*)0 == g_109) * (int8_t)p_9) != 0) - (uint8_t)(~((*l_332) = (((p_9 & ((((uint16_t)(l_330 = (!((int16_t)(((l_327 = (*l_316)) & (-(uint32_t)0xC3E4385C)) <= ((g_225 = l_329) != &g_127)) << (int16_t)15))) * (uint16_t)l_331) <= 0) || 0x3555BB47)) || g_105.f1) >= 0x79E077B5)))))
            { /* block id: 108 */
                uint8_t ***l_344 = &g_224;
                int32_t l_354 = 0xBE0F0FC9;
                for (l_327 = 0; (l_327 == (-6)); l_327 -= 6)
                { /* block id: 111 */
                    uint8_t l_336 = 0U;
                    uint8_t ***l_342 = (void*)0;
                    uint8_t ****l_343 = &l_291;
                    int16_t *l_347 = &g_105.f4;
                    uint8_t **l_353 = &g_225;
                    int32_t *l_355 = &l_354;
                    l_335 = &g_104;
                    (*l_355) = ((l_336 <= ((!g_127) > (((uint8_t)((uint32_t)((((*l_343) = l_342) != l_344) <= ((uint8_t)(((*l_305) = ((l_332 = l_347) != g_348)) > ((int32_t)((*l_316) = ((int8_t)((*l_315) = 0x63) << (int8_t)2)) - (int32_t)(l_353 == ((*l_313) = &g_225)))) >> (uint8_t)g_105.f1)) + (uint32_t)0xDCEBE090) << (uint8_t)l_354) ^ l_331))) | 0xDE);
                    /* statement id: 119 */
                    assert (g_224 == &g_225);
                    assert (l_291 == 0);
                    for (g_27 = (-7); (g_27 <= (-8)); g_27--)
                    { /* block id: 122 */
                        int32_t **l_358 = &l_355;
                        (*l_358) = ((*g_108) = &l_330);
                        /* statement id: 124 */
                        assert (g_109 == &l_330);
                        assert (l_355 == &l_330);
                        (*l_358) = (*g_108);
                    }
                    /* facts after for loop */
                    assert (l_355 == &l_330 || l_355 == &l_354);
                }
                /* facts after for loop */
                assert (g_109 == &l_330 || g_109 == 0 || g_109 == &g_27);
                assert (l_291 == 0 || l_291 == &g_224);
                (*g_108) = (*g_108);
                (*l_316) = p_9;
            }
            else
            { /* block id: 130 */
                uint8_t ****l_360 = &l_313;
                uint8_t ****l_361 = &l_359;
                int8_t *l_365 = (void*)0;
                int8_t *l_366 = (void*)0;
                int8_t *l_367 = (void*)0;
                int8_t *l_368 = &g_10;
                int32_t l_382 = 0x6C39933C;
                uint32_t ***l_385 = &g_383;
                (*l_361) = ((*l_360) = l_359);
                (*g_108) = &l_330;
                /* statement id: 133 */
                assert (g_109 == &l_330);
                if (((((0x5CD9103E > (*l_316)) < ((g_219 ^ p_9) > 1U)) <= (((int8_t)((*l_368) = ((*l_315) = (-(int8_t)g_105.f2))) + (int8_t)(~((int16_t)(((uint32_t)p_9 - (uint32_t)(!g_375)) || ((((uint8_t)((uint16_t)(g_109 != g_109) << (uint16_t)10) % (uint8_t)g_215) || (*l_316)) || g_375)) << (int16_t)1))) >= p_9)) < 0x3C6850E3))
                { /* block id: 136 */
                    return p_9;
                    /* statement id: 137 */
                    //assert (g_109 == dangling);
                }
                else
                { /* block id: 138 */
                    if (l_327)
                    { /* block id: 139 */
                        (*l_316) = (((*l_316) && (**g_108)) <= 0xC6);
                        (*l_316) = ((uint8_t)l_382 << (uint8_t)4);
                    }
                    else
                    { /* block id: 142 */
                        return (*g_225);
                        /* statement id: 143 */
                        //assert (g_109 == dangling);
                    }
                }
                (*l_385) = g_383;
            }
            /* facts after branching */
            assert (g_109 == &l_330 || g_109 == 0 || g_109 == &g_27);
            assert (l_291 == 0 || l_291 == &g_224);
            if (((int32_t)((int8_t)(l_330 = ((int16_t)(l_331 <= (g_27 | g_213)) + (int16_t)p_9)) - (int8_t)p_9) - (int32_t)4294967295U))
            { /* block id: 149 */
                for (l_330 = 6; (l_330 >= 23); l_330 += 3)
                { /* block id: 152 */
                    (*l_316) = 0xE282A758;
                    return l_331;
                    /* statement id: 154 */
                    //assert (g_109 == dangling || g_109 == 0 || g_109 == &g_27);
                }
                (*g_108) = &l_331;
                /* statement id: 156 */
                assert (g_109 == &l_331);
            }
            else
            { /* block id: 157 */
                uint8_t *****l_398 = &g_396;
                int16_t *l_403 = (void*)0;
                (*l_316) = ((int8_t)(((((*l_398) = g_396) != &l_292) & (p_9 | 0x5A)) == ((uint8_t)l_331 << (uint8_t)3)) - (int8_t)(0x84C55312 | ((uint16_t)0x655E >> (uint16_t)(l_403 != (g_404 = l_403)))));
                /* statement id: 160 */
                assert (g_404 == 0);
                (*l_316) = 0x1D896C24;
            }
            /* facts after branching */
            assert (g_109 == &l_330 || g_109 == 0 || g_109 == &g_27 || g_109 == &l_331);
            assert (g_404 == 0 || g_404 == &g_105.f3);
            l_330 = (l_329 == l_329);
            return (*l_316);
            /* statement id: 164 */
            //assert (g_109 == dangling || g_109 == 0 || g_109 == &g_27);
        }
    }
    else
    { /* block id: 166 */
        int16_t l_413 = 0x5ACE;
        for (g_105.f2 = 20; (g_105.f2 == 25); g_105.f2 += 1)
        { /* block id: 169 */
            int32_t *l_414 = &l_314;
            for (g_105.f3 = 15; (g_105.f3 >= 1); g_105.f3 -= 7)
            { /* block id: 172 */
                for (g_10 = 27; (g_10 == 18); g_10--)
                { /* block id: 175 */
                    int16_t ***l_412 = &l_411;
                    (*g_108) = (*g_108);
                    (*l_412) = l_411;
                    if (l_413)
                        continue;
                }
                (*g_108) = l_414;
                /* statement id: 180 */
                assert (g_109 == &l_314);
            }
        }
        /* facts after for loop */
        assert (g_109 == &l_314 || g_109 == 0 || g_109 == &g_27);
    }
    /* facts after branching */
    assert (g_109 == &l_314 || g_109 == 0 || g_109 == &g_27);
    (*g_108) = &l_314;
    /* statement id: 184 */
    assert (g_109 == &l_314);
    g_417 = ((*l_415) = ((*g_108) = &l_314));
    /* statement id: 187 */
    assert (l_316 == &l_314);
    assert (g_417 == &l_314);
    return (*g_225);
    /* statement id: 188 */
    //assert (g_109 == dangling);
    //assert (g_417 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_27 g_10 g_108 g_105.f5 g_105.f3 g_105.f1 g_105.f4 g_109 g_105.f7 g_127 g_105.f6 g_213 g_105.f0 g_224 g_225 g_219
 * writes: g_27 g_104 g_105.f6 g_127 g_105.f2 g_109 g_105.f4 g_105.f3 g_224 g_105.f0 g_219
 */
inline static uint16_t  func_19(int32_t  p_20, uint32_t  p_21)
{ /* block id: 2 */
    int32_t *l_29 = &g_27;
    int32_t **l_28 = &l_29;
    int32_t ***l_30 = &l_28;
    (*l_30) = l_28;
    for (p_21 = 0; (p_21 != 52); p_21 += 1)
    { /* block id: 6 */
        int32_t ***l_48 = &l_28;
        int32_t *l_218 = &g_219;
        int32_t ****l_280 = (void*)0;
        l_48 = func_33(func_37((*l_28), (0xAEDF ^ 0xF28A), func_43(l_48, p_20, ((uint8_t)p_21 << (uint8_t)(func_51((*l_48), g_27, (((int8_t)p_21 + (int8_t)(**l_28)) & p_20)) == p_20)), l_218), g_105.f7, (*l_28)), p_20, p_21);
        /* statement id: 87 */
        assert (g_109 == &g_27);
        assert (g_224 == 0);
        assert (l_48 == &g_108);
    }
    /* facts after for loop */
    assert (g_104 == 0 || g_104 == &g_105);
    assert (g_109 == &g_27 || g_109 == 0);
    assert (g_224 == 0 || g_224 == &g_225);
    (*g_108) = (*l_28);
    /* statement id: 89 */
    assert (g_109 == &g_27);
    (*l_29) = (((int8_t)((uint32_t)g_105.f6 % (uint32_t)(**l_28)) + (int8_t)((p_20 <= (***l_30)) | ((int8_t)(((((((p_20 || (*l_29)) && p_20) < ((0x440013EB != ((uint8_t)((uint32_t)((void*)0 != l_29) % (uint32_t)p_20) - (uint8_t)0xC0)) ^ (*g_109))) >= g_105.f4) <= 0) ^ p_20) != (**l_28)) >> (int8_t)4))) >= 0x39);
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads : g_108
 * writes: g_109
 */
static int32_t *** func_33(int32_t *** p_34, uint8_t  p_35, uint32_t  p_36)
{ /* block id: 84 */
    int32_t *l_279 = &g_27;
    (*g_108) = l_279;
    /* statement id: 85 */
    assert (g_109 == &g_27);
    return p_34;
    /* statement id: 86 */
    //assert (func_33_rv == &g_108);
}


/* ------------------------------------------ */
/* 
 * reads : g_105.f3 g_224 g_109 g_27 g_108 g_225 g_127 g_10 g_219 g_213
 * writes: g_105.f3 g_27 g_224 g_105.f0 g_127 g_219 g_109
 */
static int32_t *** func_37(const int32_t * p_38, int8_t  p_39, int32_t *** p_40, int16_t  p_41, int32_t * p_42)
{ /* block id: 62 */
    uint8_t ***l_227 = (void*)0;
    uint8_t ***l_228 = &g_224;
    int32_t l_242 = 0x12DD9B8E;
    uint32_t *l_243 = &g_105.f0;
    for (g_105.f3 = 0; (g_105.f3 >= (-16)); g_105.f3 -= 9)
    { /* block id: 65 */
        uint8_t **l_226 = &g_225;
        l_226 = g_224;
        /* statement id: 66 */
        assert (l_226 == &g_225 || l_226 == 0);
        if ((*g_109))
            break;
        (**g_108) = (&g_10 != &g_10);
    }
    if (((((*l_228) = (void*)0) != (void*)0) & (((*l_243) = ((uint8_t)(((int32_t)(((uint8_t)((*g_109) >= ((int8_t)(((uint16_t)((l_242 = (((((int8_t)(~(p_41 <= l_242)) - (int8_t)((l_242 >= l_242) ^ (((void*)0 == &g_10) >= p_41))) < p_41) != 0xACBFB422) > (*g_225))) >= 0x1E) + (uint16_t)(-10)) < 0xF3EDA6D5) << (int8_t)(*g_225))) >> (uint8_t)6) && p_39) + (int32_t)(**g_108)) == p_39) + (uint8_t)0x36)) && (-2))))
    { /* block id: 73 */
        uint32_t l_262 = 0x0A057982;
        int32_t *l_275 = &g_219;
        (**p_40) = (*g_108);
        (*l_275) = (((uint8_t)((int8_t)g_10 - (int8_t)((*g_225) = ((((uint8_t)((((uint8_t)((uint16_t)(p_41 > ((int16_t)((((uint8_t)((uint16_t)((*g_225) ^ (l_262 <= (((***p_40) = 0xE4A769E6) == l_242))) >> (uint16_t)((uint8_t)((uint8_t)((int16_t)((int8_t)(l_262 & ((uint8_t)p_41 - (uint8_t)((uint32_t)(&g_224 != (void*)0) - (uint32_t)0x59306392))) >> (int8_t)3) % (int16_t)g_219) * (uint8_t)l_242) + (uint8_t)l_242)) >> (uint8_t)(*g_225)) ^ g_213) <= 0x28C5A1FB) << (int16_t)g_10)) << (uint16_t)1) % (uint8_t)p_41) && l_242) & 1) % (uint8_t)p_39) && g_27) & 0xB83AE85C))) - (uint8_t)p_41) & l_242);
        (*g_108) = &l_242;
        /* statement id: 78 */
        assert (g_109 == &l_242);
    }
    else
    { /* block id: 79 */
        int16_t l_278 = 0x0027;
        (*p_42) = ((uint16_t)l_278 >> (uint16_t)1);
    }
    /* facts after branching */
    assert (g_109 == &g_27 || g_109 == &l_242);
    assert (g_224 == 0);
    (*p_42) = 1;
    return &g_108;
    /* statement id: 83 */
    //assert (g_109 == &g_27 || g_109 == dangling);
    //assert (func_37_rv == &g_108);
}


/* ------------------------------------------ */
/* 
 * reads : g_108
 * writes: g_109
 */
static int32_t *** func_43(int32_t *** p_44, const uint8_t  p_45, uint16_t  p_46, int32_t * p_47)
{ /* block id: 58 */
    const struct S0 *l_220 = (void*)0;
    const struct S0 **l_221 = &l_220;
    (*l_221) = l_220;
    (*g_108) = (**p_44);
    /* statement id: 60 */
    assert (g_109 == &g_27);
    return p_44;
    /* statement id: 61 */
    //assert (func_43_rv == &l_28);
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_27 g_108 g_105.f5 g_105.f3 g_105.f1 g_105.f4 g_109 g_105.f7 g_127 g_105.f6 g_213 g_105.f0
 * writes: g_27 g_104 g_105.f6 g_127 g_105.f2 g_109 g_105.f4
 */
inline static uint8_t  func_51(int32_t ** p_52, const uint32_t  p_53, const int8_t  p_54)
{ /* block id: 7 */
    int32_t *l_57 = (void*)0;
    uint32_t l_63 = 1U;
    int32_t *l_75 = &g_27;
    int32_t **l_74 = &l_75;
    const int32_t ***l_80 = (void*)0;
    int32_t ***l_110 = &g_108;
    uint32_t l_217 = 8U;
    l_217 = (((&g_27 == l_57) | (0xDFD7 || func_58(l_63, func_64(((p_53 || ((((uint8_t)(0 && (((uint8_t)(&g_27 == ((*l_74) = (*p_52))) << (uint8_t)1) | (((int16_t)((uint16_t)g_10 << (uint16_t)g_10) - (int16_t)8) != p_54))) >> (uint8_t)p_53) && (*l_75)) | 0xC74F348F)) < g_27), g_27, p_52, l_80, p_54), p_54, l_110))) != p_54);
    return g_105.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_105.f5 g_105.f3 g_105.f1 g_105.f4 g_108 g_109 g_105.f7 g_27 g_127 g_105.f6 g_213 g_105.f0
 * writes: g_105.f6 g_127 g_105.f2 g_109 g_27 g_105.f4
 */
inline static int16_t  func_58(int32_t  p_59, int32_t ** p_60, int8_t  p_61, int32_t *** p_62)
{ /* block id: 22 */
    uint16_t l_119 = 0U;
    uint8_t *l_121 = &g_105.f6;
    uint8_t *l_125 = (void*)0;
    uint8_t **l_124 = &l_125;
    uint8_t *l_126 = &g_127;
    int8_t *l_138 = &g_105.f2;
    int32_t *l_139 = &g_27;
    uint16_t *l_143 = &l_119;
    int32_t ***l_148 = &g_108;
    int8_t l_194 = 0xC0;
    uint8_t *l_198 = (void*)0;
    const int32_t *l_212 = &g_213;
    const int32_t **l_211 = &l_212;
    const int32_t *l_214 = &g_215;
    int32_t *l_216 = &g_27;
    if (((int8_t)g_105.f5 << (int8_t)((((uint32_t)((int8_t)((uint8_t)l_119 << (uint8_t)((*l_121) = (~p_61))) - (int8_t)(l_119 > ((uint32_t)((((*l_126) = (l_121 == ((*l_124) = l_121))) || (((int32_t)((int16_t)(((uint16_t)65535U - (uint16_t)(((int16_t)(7 > ((int8_t)((*l_138) = ((g_105.f5 == g_105.f3) && g_105.f1)) * (int8_t)0x87)) << (int16_t)l_119) ^ 0xC0916D66)) & 0) * (int16_t)l_119) - (int32_t)g_105.f5) < l_119)) >= g_105.f4) + (uint32_t)l_119))) % (uint32_t)p_59) & l_119) && l_119)))
    { /* block id: 27 */
        l_139 = ((*g_108) = (*g_108));
        /* statement id: 29 */
        assert (l_139 == 0 || l_139 == &g_27);
        return p_61;
    }
    else
    { /* block id: 31 */
        int32_t *l_140 = &g_27;
        (**p_62) = l_140;
        /* statement id: 32 */
        assert (g_109 == &g_27);
    }
    /* facts after branching */
    assert (g_109 == &g_27);
    assert (l_125 == &g_105.f6);
    if (((uint16_t)((*l_143) = (g_105.f7 ^ (&p_60 != &p_60))) * (uint16_t)(g_105.f1 || 0x9328501D)))
    { /* block id: 35 */
        const uint8_t *l_150 = &g_151;
        const uint8_t **l_149 = &l_150;
        int32_t l_156 = 0xFA96CD89;
        int32_t l_157 = 1;
        uint8_t l_158 = 0x9A;
        (*l_139) = ((uint16_t)(p_61 <= ((int8_t)p_61 * (int8_t)(0x69DBBC94 != (((p_62 = &p_60) != l_148) >= ((((*l_149) = &g_127) == (void*)0) == ((*l_125) = (((uint16_t)(((int8_t)((-1) ^ (l_156 = ((p_59 != 0x98) ^ p_61))) >> (int8_t)6) > l_157) >> (uint16_t)l_157) >= l_157))))))) >> (uint16_t)l_158);
        /* statement id: 40 */
        assert (p_62 == &p_60);
        assert (l_150 == &g_127);
    }
    else
    { /* block id: 41 */
        uint32_t l_168 = 0x1A4DE48E;
        int8_t l_193 = 0x25;
        int32_t l_195 = (-1);
        (***p_62) = ((g_105.f5 <= ((~(((int16_t)(((int16_t)((int8_t)p_59 >> (int8_t)((g_105.f2 = (((((*l_126) = (((int32_t)1 % (int32_t)l_168) != (((int8_t)((uint16_t)(-(int8_t)((int32_t)(**p_60) % (int32_t)((uint8_t)(((int32_t)((~((l_195 = ((uint16_t)((uint32_t)0x6465E51F + (uint32_t)(((*l_121) = (65531U & (((int32_t)(((uint32_t)((uint16_t)1U << (uint16_t)((int8_t)(l_168 == l_168) + (int8_t)p_61)) + (uint32_t)(*g_109)) && (***l_148)) % (int32_t)0xA6A52982) | l_193))) & l_194)) * (uint16_t)65526U)) & (*l_139))) & 0U) - (int32_t)1U) | 0x424E) >> (uint8_t)p_61))) + (uint16_t)g_127) * (int8_t)g_105.f3) & p_59))) & 0x59) | (**p_60)) < l_168)) & p_59)) + (int16_t)4) != (***l_148)) >> (int16_t)g_105.f3) | 1)) & (*l_139))) | (*l_139));
        (***l_148) = (p_59 <= g_105.f5);
    }
    /* facts after branching */
    assert (p_62 == &g_108 || p_62 == &p_60);
    (*l_139) = (((uint8_t)((void*)0 != l_198) >> (uint8_t)p_61) <= ((int16_t)(g_105.f4 = (((uint16_t)((int16_t)((uint8_t)((*g_109) && (((int8_t)((int32_t)((p_61 || g_105.f6) | p_61) - (int32_t)((((**l_148) = (**l_148)) == (l_214 = ((*l_211) = l_139))) & 6)) + (int8_t)g_213) || p_59)) * (uint8_t)0x02) * (int16_t)0x7FB8) % (uint16_t)6U) & 2U)) >> (int16_t)g_105.f0));
    /* statement id: 53 */
    assert (l_212 == &g_213 || l_212 == &g_27);
    assert (l_214 == &g_215 || l_214 == &g_27);
    (**p_62) = l_216;
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads : g_10 g_27 g_108 l_29
 * writes: g_27 g_104
 */
static int32_t ** func_64(int8_t  p_65, const int8_t  p_66, int32_t ** p_67, const int32_t *** p_68, int16_t  p_69)
{ /* block id: 9 */
    uint8_t l_81 = 0x9E;
    int32_t l_97 = 0xB159BBC0;
    int32_t *l_107 = &l_97;
    int32_t **l_106 = &l_107;
    (**p_67) = l_81;
    l_97 = ((int8_t)((int8_t)(0x937B <= ((uint16_t)((int16_t)g_10 << (int16_t)5) * (uint16_t)(l_81 || 5U))) + (int8_t)((uint16_t)((int32_t)(l_81 ^ 0x60) % (int32_t)(~(((**p_67) = (p_69 | 0xDA)) < ((int8_t)0x7D * (int8_t)g_10)))) + (uint16_t)0x1728)) >> (int8_t)l_81);
    for (p_69 = 6; (p_69 <= 9); p_69 += 1)
    { /* block id: 15 */
        int32_t *l_100 = &g_27;
        int32_t **l_101 = (void*)0;
        int32_t **l_102 = &l_100;
        struct S0 *l_103 = (void*)0;
        (*l_102) = l_100;
        (*l_102) = &g_27;
        if ((*l_100))
            continue;
        g_104 = l_103;
        /* statement id: 19 */
        assert (g_104 == 0);
    }
    return g_108;
    /* statement id: 21 */
    //assert (func_64_rv == &g_109);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_10, "g_10", print_hash_value);
    transparent_crc(g_27, "g_27", print_hash_value);
    transparent_crc(g_105.f0, "g_105.f0", print_hash_value);
    transparent_crc(g_105.f1, "g_105.f1", print_hash_value);
    transparent_crc(g_105.f2, "g_105.f2", print_hash_value);
    transparent_crc(g_105.f3, "g_105.f3", print_hash_value);
    transparent_crc(g_105.f4, "g_105.f4", print_hash_value);
    transparent_crc(g_105.f5, "g_105.f5", print_hash_value);
    transparent_crc(g_105.f6, "g_105.f6", print_hash_value);
    transparent_crc(g_105.f7, "g_105.f7", print_hash_value);
    transparent_crc(g_127, "g_127", print_hash_value);
    transparent_crc(g_151, "g_151", print_hash_value);
    transparent_crc(g_213, "g_213", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    transparent_crc(g_219, "g_219", print_hash_value);
    transparent_crc(g_375, "g_375", print_hash_value);
    transparent_crc(g_442, "g_442", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 74
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 4
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 1
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 6

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 18
   depth: 3, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 4
   depth: 23, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 30, occurrence: 1
   depth: 34, occurrence: 1
   depth: 39, occurrence: 1

XXX total number of pointers: 110

XXX times a variable address is taken: 106
XXX times a pointer is dereferenced on RHS: 58
breakdown:
   depth: 1, occurrence: 44
   depth: 2, occurrence: 11
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 85
breakdown:
   depth: 1, occurrence: 75
   depth: 2, occurrence: 7
   depth: 3, occurrence: 3
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 285

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 200
   level: 2, occurrence: 57
   level: 3, occurrence: 22
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 55
XXX number of pointers point to scalars: 52
XXX number of pointers point to structs: 3
XXX percent of pointers has null in alias set: 20.9
XXX average alias set size: 1.19

XXX times a non-volatile is read: 376
XXX times a non-volatile is write: 219
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 90
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 20
   depth: 2, occurrence: 6
   depth: 3, occurrence: 13
   depth: 4, occurrence: 10
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 16.9
XXX percentage an existing variable is used: 83.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

