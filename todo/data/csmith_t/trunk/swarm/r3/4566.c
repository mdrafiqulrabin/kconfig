/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3743760780
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   const float  f1;
   uint16_t  f2;
};

struct S1 {
   uint16_t  f0;
   uint16_t  f1;
   const float  f2;
   int32_t  f3;
   signed f4 : 10;
   struct S0  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const float  func_1(void);
static float  func_14(int8_t  p_15, float * p_16, int16_t  p_17, const int32_t  p_18);
inline static float * func_19(int32_t  p_20, const float * p_21, int32_t  p_22);
static float * func_23(float * const  p_24, float * p_25, int16_t  p_26, const float * p_27, float * p_28);
inline static float * func_31(uint32_t  p_32);
inline static float * func_34(struct S0  p_35, const struct S0  p_36);
inline static uint32_t  func_44(float * p_45);
static float * func_46(float * p_47, float * p_48, struct S0  p_49, uint32_t  p_50, const float * p_51);
static float * func_53(struct S1  p_54, int32_t  p_55, float * p_56, const int8_t  p_57, float * p_58);
inline static uint16_t  func_62(int8_t  p_63, float  p_64, float * p_65, float  p_66, struct S0  p_67);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_1(void)
{ /* block id: 0 */
    int16_t l_2 = 0x811F;
    float l_4 = 0x3.3p+1;
    float *l_3 = &l_4;
    int32_t l_9 = (-4);
    float l_30 = (-0x1.Dp+1);
    float * const l_29 = &l_30;
    float *l_33 = &l_30;
    struct S0 l_37 = {2,0x8.CB314Bp-66,0x30B6};
    float *l_415 = &l_30;
    float **l_414 = &l_415;
    float *l_416 = &l_30;
    float *l_418 = &l_30;
    float **l_417 = &l_418;
    uint32_t l_420 = 0x7DA0E0BF;
    uint32_t *l_419 = &l_420;
    const float *l_480 = &l_37.f1;
    float *l_481 = &l_30;
    int32_t l_799 = 6;
    uint32_t l_800 = 0x743EF446;
    l_9 = (l_2 != ((((*l_3) = l_2) != (((*l_481) = (((float)(((float)l_9 - (float)((float)((float)(l_799 = func_14(l_9, func_19((l_9 | l_9), func_23(l_29, func_31(((*l_419) = (l_33 == ((*l_417) = (l_416 = ((*l_414) = func_34(l_37, l_37))))))), l_9, l_480, l_481), l_2), l_2, l_37.f0)) + (float)0x1.CA41CCp-59) - (float)l_9)) >= l_800) + (float)l_800) >= l_2)) > 0xB.64C2B4p-94)) != l_9));
    /* statement id: 479 */
    assert (l_415 == 0);
    assert (l_416 == 0);
    assert (l_418 == 0);
    return l_799;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_14(int8_t  p_15, float * p_16, int16_t  p_17, const int32_t  p_18)
{ /* block id: 473 */
    struct S1 l_787 = {1U,0x580F,0x3.7A8F22p-23,0x18402DCE,-9,{-4,0x1.D4414Ap+14,0xE177}};
    uint32_t l_788 = 0xFDE7A61B;
    const float *l_789 = &l_787.f2;
    const uint16_t l_792 = 65527U;
    float l_794 = 0x1.CFA665p-54;
    float *l_793 = &l_794;
    int32_t *l_796 = (void*)0;
    int32_t **l_795 = &l_796;
    int32_t *l_798 = &l_787.f3;
    int32_t **l_797 = &l_798;
    (*l_797) = ((*l_795) = func_53(l_787, l_788, func_19(p_15, l_789, ((p_15 >= ((int16_t)l_787.f0 % (int16_t)((p_18 && 0xCD63) | p_15))) ^ (-1))), l_792, l_793));
    /* statement id: 475 */
    assert (l_796 == &l_794);
    assert (l_798 == &l_794);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_19(int32_t  p_20, const float * p_21, int32_t  p_22)
{ /* block id: 281 */
    int8_t l_515 = 0xCE;
    int8_t *l_514 = &l_515;
    uint32_t l_522 = 4294967295U;
    int32_t l_523 = 0x5BB55210;
    struct S1 l_541 = {0U,0xCCA1,0x5.6DFB4Dp-13,0xECCE02C5,-14,{0x7B80,-0x2.6p-1,4U}};
    struct S1 * const l_540 = &l_541;
    uint32_t **l_576 = (void*)0;
    uint32_t ***l_575 = &l_576;
    struct S0 *l_639 = &l_541.f5;
    struct S0 **l_638 = &l_639;
    int32_t *l_716 = &l_523;
    int32_t **l_715 = &l_716;
    int32_t ***l_714 = &l_715;
    uint16_t *l_737 = (void*)0;
    struct S0 *l_766 = (void*)0;
    int16_t *l_777 = (void*)0;
    int16_t *l_778 = &l_541.f5.f0;
    uint32_t *l_781 = (void*)0;
    uint32_t l_783 = 0x3A8AF550;
    uint32_t *l_782 = &l_783;
    uint32_t *l_786 = &l_522;
    for (p_20 = 0; (p_20 <= (-11)); p_20 -= 5)
    { /* block id: 284 */
        uint32_t l_512 = 0x324052EE;
        int8_t *l_517 = &l_515;
        int8_t **l_516 = &l_517;
        int32_t l_519 = 9;
        int32_t *l_518 = &l_519;
        int16_t l_525 = 0x87AF;
        int16_t *l_524 = &l_525;
        int32_t *l_526 = &l_523;
        int32_t l_528 = 3;
        int32_t *l_527 = &l_528;
        float l_547 = 0x1.2p-1;
        const int32_t l_622 = 0x4DBB867E;
        const int32_t *l_621 = &l_622;
        struct S1 l_721 = {0x448A,0x0578,0x0.0p+1,5,-16,{2,0xD.6FD0ECp+44,1U}};
        int8_t ***l_761 = &l_516;
        int8_t ****l_760 = &l_761;
        float *l_769 = (void*)0;
        (*l_527) = ((*l_526) = ((((((p_22 & ((*l_524) = ((uint16_t)((((int16_t)((l_512 & (-(uint16_t)((((l_514 == ((*l_516) = &l_515)) == p_22) <= p_20) == (p_22 != (((*l_518) = p_22) & (((int32_t)0xF71FBF82 % (int32_t)l_515) | p_20)))))) > 0U) << (int16_t)p_22) != l_522) >= 9U) + (uint16_t)l_523))) | p_20) ^ l_523) && p_22) ^ p_20) >= 0x36BA));
        for (l_525 = 0; (l_525 > (-17)); l_525 -= 4)
        { /* block id: 292 */
            for (p_22 = 0; (p_22 <= (-12)); p_22 -= 1)
            { /* block id: 295 */
                struct S1 l_535 = {0xF05E,65535U,0x0.Ep+1,0xF314835B,24,{0x1BC9,0x2.07F361p-7,1U}};
                struct S1 *l_534 = &l_535;
                struct S1 **l_533 = &l_534;
                (*l_533) = (void*)0;
                /* statement id: 296 */
                assert (l_534 == 0);
                if (l_515)
                    break;
                for (l_535.f5.f2 = 7; (l_535.f5.f2 < 56); ++l_535.f5.f2)
                { /* block id: 300 */
                    if (l_515)
                        break;
                }
            }
            for (p_22 = 6; (p_22 < (-19)); p_22 -= 8)
            { /* block id: 306 */
                const struct S1 *l_543 = &l_541;
                const struct S1 **l_542 = &l_543;
                (*l_542) = l_540;
            }
        }
    }
    (**l_715) = (((((((((((int32_t)3 - (int32_t)(p_22 >= 4294967287U)) >= (((*l_782) = (((0x7CB1 && (((int16_t)((int16_t)(***l_714) << (int16_t)((p_20 = ((p_22 || p_20) | ((*l_778) = (~p_22)))) != ((((uint16_t)65530U << (uint16_t)(**l_715)) ^ 0x5AC13105) >= (-1)))) >> (int16_t)p_22) && p_22)) > 1) != 0xBC6F)) == 0xF36BC769)) > p_22) != (**l_715)) & (**l_715)) >= (***l_714)) <= 1U) && p_20) > 0xB40CF64B) == (**l_715));
    (*l_715) = func_31(((*l_786) = ((*l_716) = ((uint16_t)0xC391 << (uint16_t)9))));
    /* statement id: 471 */
    assert (l_716 == 0);
    return l_716;
    /* statement id: 472 */
    //assert (func_19_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_23(float * const  p_24, float * p_25, int16_t  p_26, const float * p_27, float * p_28)
{ /* block id: 267 */
    const uint32_t l_482 = 0U;
    struct S0 l_485 = {0x536A,-0x1.Ap+1,1U};
    struct S0 *l_484 = &l_485;
    struct S0 * const *l_483 = &l_484;
    uint32_t ****l_486 = (void*)0;
    uint32_t * const l_491 = (void*)0;
    uint32_t * const *l_490 = &l_491;
    uint32_t * const **l_489 = &l_490;
    uint32_t * const ***l_488 = &l_489;
    uint32_t * const ****l_487 = &l_488;
    int32_t l_492 = 9;
    const int8_t l_493 = 0xBF;
    int32_t *l_495 = (void*)0;
    int32_t * const *l_494 = &l_495;
    int32_t **l_505 = &l_495;
    (*p_24) = (((l_492 = (l_482 <= ((((l_483 != (void*)0) < (((*l_487) = l_486) == (void*)0)) <= ((-0x9.Dp+1) < ((((*p_27) == (-0x10.2p-1)) != ((*p_27) == l_485.f0)) >= 0x3.2p+1))) > (-0x1.8p+1)))) != (*p_24)) >= l_493);
    /* statement id: 270 */
    assert (l_488 == 0);
    l_494 = l_494;
    for (l_485.f0 = 0; (l_485.f0 > 4); ++l_485.f0)
    { /* block id: 274 */
        struct S0 l_498 = {0,0x0.2p-1,2U};
        uint32_t l_500 = 0x76A19489;
        uint32_t *l_499 = &l_500;
        float l_503 = 0x8.21D3F2p-9;
        float *l_502 = &l_503;
        float **l_501 = &l_502;
        int32_t **l_504 = &l_495;
        (*l_504) = p_24;
        /* statement id: 277 */
        //assert (l_495 == &l_30);
    }
    /* facts after for loop */
    //assert (l_495 == &l_30 || l_495 == 0);
    (*l_505) = (void*)0;
    /* statement id: 279 */
    assert (l_495 == 0);
    return p_28;
    /* statement id: 280 */
    //assert (func_23_rv == &l_30);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_31(uint32_t  p_32)
{ /* block id: 231 */
    int32_t l_435 = 0x0247E36C;
    int32_t *l_434 = &l_435;
    int32_t **l_436 = &l_434;
    struct S0 l_470 = {0xCD4D,0x8.397B27p+55,0U};
    struct S0 *l_469 = &l_470;
    struct S0 **l_468 = &l_469;
    struct S0 ***l_467 = &l_468;
    float l_473 = 0x7.CA8E42p+92;
    float *l_472 = &l_473;
    float *l_474 = &l_473;
    float *l_475 = &l_473;
    float *l_476 = &l_473;
    float *l_477 = &l_473;
    float *l_478 = &l_473;
    float *l_479 = (void*)0;
    for (p_32 = 0; (p_32 > 51); p_32 += 1)
    { /* block id: 234 */
        int32_t l_423 = (-9);
        int32_t l_430 = 0xDF71DA4B;
        float **l_431 = (void*)0;
        for (l_423 = 27; (l_423 == (-28)); l_423 -= 2)
        { /* block id: 237 */
            float l_433 = 0xC.85CFFAp+31;
            float *l_432 = &l_433;
            (*l_432) = ((float)(l_430 = ((float)p_32 - (float)l_423)) + (float)((((void*)0 == l_431) == 0x0.7p-1) >= p_32));
        }
    }
    (*l_436) = l_434;
    for (p_32 = 0; (p_32 <= 55); ++p_32)
    { /* block id: 245 */
        uint32_t l_439 = 0x9C755FA3;
        uint32_t *l_453 = (void*)0;
        uint32_t l_455 = 0x6BAF50E1;
        uint32_t *l_454 = &l_455;
        int16_t l_457 = 0;
        int16_t *l_456 = &l_457;
        (*l_436) = (*l_436);
        if (l_439)
            break;
    }
    for (l_435 = 23; (l_435 > 14); l_435 -= 1)
    { /* block id: 263 */
        struct S0 ****l_471 = &l_467;
        (*l_471) = l_467;
    }
    return l_479;
    /* statement id: 266 */
    //assert (func_31_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_34(struct S0  p_35, const struct S0  p_36)
{ /* block id: 2 */
    int32_t l_38 = 1;
    float l_40 = 0x0.Ap+1;
    float *l_39 = &l_40;
    struct S1 l_59 = {0U,65529U,0x0.6C2DB6p+96,0x08CDB5CF,-22,{-3,0x1.585C2Cp-40,0U}};
    int8_t l_294 = 0x97;
    int8_t *l_293 = &l_294;
    int8_t **l_292 = &l_293;
    int16_t *l_310 = &l_59.f5.f0;
    int16_t ** const l_309 = &l_310;
    int16_t **l_311 = &l_310;
    float *l_413 = (void*)0;
    if (l_38)
    { /* block id: 3 */
        float *l_41 = (void*)0;
        return l_41;
        /* statement id: 4 */
        //assert (func_34_rv == 0);
    }
    else
    { /* block id: 5 */
        float *l_68 = &l_40;
        int8_t l_74 = 0x71;
        int8_t *l_73 = &l_74;
        int16_t l_87 = 0x4D73;
        int32_t l_308 = 1;
        int32_t *l_315 = &l_59.f3;
        uint32_t l_320 = 0x94D68D3C;
        const uint16_t l_347 = 0U;
        const int32_t ***l_392 = (void*)0;
        uint32_t l_412 = 0x48A7D601;
        for (p_35.f0 = 0; (p_35.f0 < (-28)); p_35.f0 -= 3)
        { /* block id: 8 */
            float *l_52 = &l_40;
            int8_t l_70 = 0;
            int8_t *l_69 = &l_70;
            int8_t l_72 = 1;
            int8_t *l_71 = &l_72;
            struct S0 l_75 = {0x4BCA,0xE.96394Ap-71,65532U};
            int16_t l_307 = 0x09BE;
            int32_t l_344 = 0xC7FD1788;
            const int32_t *l_384 = &l_308;
            uint16_t *l_407 = (void*)0;
            const struct S0 *l_410 = &l_75;
            const struct S0 **l_409 = &l_410;
            uint16_t *l_411 = (void*)0;
            if ((((0x5D1CC0C7 >= func_44(func_46(l_52, func_53(l_59, ((uint16_t)func_62(((*l_71) = ((*l_69) = (l_52 != l_68))), (l_69 != l_73), l_52, l_74, l_75) << (uint16_t)p_36.f2), l_68, l_59.f5.f2, l_52), p_35, l_87, l_68))) != l_87) == 0xFC0C68FD))
            { /* block id: 154 */
                int8_t **l_289 = &l_69;
                int8_t ***l_290 = (void*)0;
                int8_t ***l_291 = &l_289;
                uint32_t l_299 = 1U;
                uint32_t *l_298 = &l_299;
                int32_t *l_300 = &l_59.f3;
                l_308 = ((uint16_t)((((*l_291) = l_289) != l_292) | (((((*l_300) = (-(int16_t)(((*l_298) = ((uint32_t)0x94391B95 - (uint32_t)p_36.f2)) != (-1)))) || (*l_300)) > (((int16_t)(((int16_t)0xE182 - (int16_t)0) ^ ((int16_t)(0x7448 > l_307) - (int16_t)p_35.f2)) + (int16_t)l_74) != 4294967295U)) && p_36.f2)) + (uint16_t)l_294);
            }
            else
            { /* block id: 159 */
                int32_t *l_314 = &l_308;
                uint16_t *l_321 = (void*)0;
                struct S0 l_387 = {0xFDD9,0x6.ADBCF6p+94,0x21BA};
                float *l_399 = (void*)0;
                int32_t **l_400 = &l_315;
                l_311 = l_309;
                if (((p_35.f2 = (((int16_t)l_87 % (int16_t)p_36.f2) > ((l_52 != (l_315 = l_314)) >= (((((int16_t)((int16_t)(*l_314) >> (int16_t)l_320) >> (int16_t)11) < ((p_36.f2 <= 0x72C5) ^ (4294967295U && p_36.f0))) == p_35.f2) >= p_36.f2)))) | p_35.f0))
                { /* block id: 163 */
                    struct S0 *l_323 = &l_59.f5;
                    struct S0 **l_322 = &l_323;
                    int32_t *l_328 = (void*)0;
                    int32_t *l_329 = (void*)0;
                    int32_t *l_330 = &l_59.f3;
                    int16_t *l_345 = (void*)0;
                    int16_t *l_346 = &l_87;
                    (*l_322) = &l_75;
                    /* statement id: 164 */
                    assert (l_323 == &l_75);
                    if (((*l_315) = (((int32_t)(*l_315) % (int32_t)((*l_330) = 1)) || ((((l_321 == (void*)0) || (!0x5246AA7B)) > p_35.f0) != (((l_38 = ((int16_t)((int16_t)(0xDF09FE07 ^ (*l_315)) >> (int16_t)1) << (int16_t)((uint16_t)(((p_35.f2 = ((((int16_t)(l_59.f4 = (((int16_t)((int16_t)((*l_346) = (l_344 = ((**l_311) = ((0x62E1F7FC == 0x2087CFA9) == p_36.f2)))) << (int16_t)10) >> (int16_t)11) > l_347)) + (int16_t)l_294) < (*l_315)) <= p_36.f0)) != p_35.f0) & 0x6716) >> (uint16_t)p_36.f2))) >= 0U) | 0xBC3B)))))
                    { /* block id: 173 */
                        if ((*l_330))
                            break;
                    }
                    else
                    { /* block id: 175 */
                        int32_t **l_348 = (void*)0;
                        int32_t **l_349 = (void*)0;
                        int32_t **l_350 = &l_330;
                        (*l_350) = &l_308;
                        /* statement id: 176 */
                        assert (l_330 == &l_308);
                        return l_329;
                        /* statement id: 177 */
                        //assert (func_34_rv == 0);
                    }
                    if (p_35.f2)
                    { /* block id: 179 */
                        float **l_358 = &l_68;
                        int32_t **l_361 = &l_328;
                        uint32_t ***l_363 = (void*)0;
                        uint32_t ****l_362 = &l_363;
                        (*l_39) = (((void*)0 == l_52) != ((void*)0 != &l_323));
                        (*l_330) = ((0xA1D3 >= (((*l_322) = (void*)0) == (void*)0)) ^ ((65535U != (!(((*l_314) = ((int16_t)((((uint16_t)((uint16_t)(&l_68 == l_358) - (uint16_t)(((int16_t)(*l_330) % (int16_t)p_35.f0) == (((*l_361) = &l_344) != &l_308))) >> (uint16_t)1) || l_75.f0) ^ 0x25E5) << (int16_t)2)) || p_36.f0))) < p_36.f2));
                        /* statement id: 184 */
                        assert (l_323 == 0);
                        assert (l_328 == &l_344);
                        (*l_362) = (void*)0;
                    }
                    else
                    { /* block id: 186 */
                        int32_t **l_364 = (void*)0;
                        int32_t **l_365 = &l_328;
                        (*l_365) = &l_38;
                        /* statement id: 187 */
                        assert (l_328 == &l_38);
                        (*l_322) = &p_35;
                        /* statement id: 188 */
                        assert (l_323 == &p_35);
                        (*l_365) = (*l_365);
                    }
                    /* facts after branching */
                    assert (l_323 == &p_35 || l_323 == 0);
                    assert (l_328 == &l_38 || l_328 == &l_344);
                }
                else
                { /* block id: 191 */
                    int32_t **l_368 = &l_314;
                    for (l_59.f5.f0 = 0; (l_59.f5.f0 == 5); l_59.f5.f0 += 5)
                    { /* block id: 194 */
                        int32_t ***l_369 = &l_368;
                        uint32_t l_381 = 0x51D62543;
                        uint32_t *l_380 = &l_381;
                        uint32_t l_383 = 4294967287U;
                        uint32_t *l_382 = &l_383;
                        (*l_52) = p_35.f0;
                        (*l_369) = l_368;
                        (*l_314) = (-6);
                        (*l_314) = ((int16_t)((((0xA482D9A3 <= 0x466D3CF2) <= 65533U) || (***l_369)) < ((int16_t)l_75.f2 << (int16_t)p_36.f2)) % (int16_t)((int16_t)((((uint16_t)(((uint16_t)(((((*l_382) = ((*l_380) = 0x710A52F9)) | ((void*)0 == l_384)) | 6) && (*l_314)) >> (uint16_t)p_36.f2) >= 0xBCD46B94) - (uint16_t)0x172D) & p_35.f2) >= 0x6B85FABE) << (int16_t)p_36.f2));
                    }
                }
                /* facts after branching */
                assert (l_315 == &l_308);
                for (l_294 = 0; (l_294 != 14); ++l_294)
                { /* block id: 205 */
                    int32_t l_388 = 1;
                    uint16_t *l_389 = &l_59.f0;
                    const float *l_390 = &l_75.f1;
                    int32_t *l_391 = &l_344;
                    l_391 = func_46(l_315, l_52, l_387, (l_388 < ((*l_389) = p_35.f2)), l_390);
                    /* statement id: 207 */
                    assert (l_391 == 0 || l_391 == &l_40 || l_391 == &l_308);
                    if ((((void*)0 == l_392) > 1U))
                    { /* block id: 208 */
                        float l_395 = 0x8.E064FDp+48;
                        l_344 = ((((*l_52) = ((float)p_36.f1 - (float)(p_36.f2 < l_395))) > p_36.f2) > p_36.f2);
                        (*l_315) = (*l_314);
                    }
                    else
                    { /* block id: 212 */
                        struct S1 *l_397 = &l_59;
                        struct S1 **l_396 = &l_397;
                        float *l_398 = &l_40;
                        (*l_396) = (void*)0;
                        /* statement id: 213 */
                        assert (l_397 == 0);
                        return l_399;
                        /* statement id: 214 */
                        //assert (func_34_rv == 0);
                    }
                }
                (*l_400) = &l_38;
                /* statement id: 217 */
                assert (l_315 == &l_38);
            }
            if (p_35.f2)
                break;
            l_308 = (0 == ((((~(((int16_t)(!((l_412 = ((uint16_t)(((*l_384) && ((l_344 = 0x87CC) & (p_36.f2 >= ((((*l_315) = (0xB5A4A2F8 != (*l_384))) | (~(((void*)0 != l_52) == ((void*)0 != l_409)))) || 0x3C7E)))) >= p_35.f0) - (uint16_t)p_35.f2)) < (*l_384))) % (int16_t)p_36.f2) == 0x7AD1C559)) && 0xF7F560B4) > (*l_384)) ^ p_36.f0));
        }
        /* facts after for loop */
        assert (l_315 == &l_308 || l_315 == &l_38 || l_315 == &l_59.f3);
    }
    return l_413;
    /* statement id: 226 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_44(float * p_45)
{ /* block id: 149 */
    int16_t l_276 = 0;
    float l_281 = 0x0.57962Fp+59;
    int32_t l_282 = 0xD622D2A8;
    float *l_283 = &l_281;
    uint32_t l_284 = 0xE55CF61E;
    float l_286 = 0x3.7177AAp-53;
    float *l_285 = &l_286;
    (*l_285) = ((-0x10.Dp-1) >= (-(float)((((float)((l_276 == ((((!((((*l_283) = ((!(l_282 = ((l_276 != ((void*)0 == p_45)) <= ((l_276 < (l_276 == ((-0x9.Ap-1) < (((float)l_281 + (float)l_276) != l_276)))) > 0xF.5CD4BFp-33)))) != 0x0.2p-1)) >= l_276) != l_276)) == l_284) != 0x7.Dp+1) <= 0x2.67CE19p-11)) <= l_284) - (float)l_276) == l_284) <= 0x4.BCBD64p-81)));
    return l_284;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_46(float * p_47, float * p_48, struct S0  p_49, uint32_t  p_50, const float * p_51)
{ /* block id: 24 */
    int8_t l_100 = (-1);
    const int8_t *l_99 = &l_100;
    int32_t l_108 = (-9);
    int32_t l_124 = 0x6CD28588;
    int16_t l_132 = 7;
    struct S0 l_134 = {8,0x0.Cp-1,0x99FC};
    struct S0 *l_133 = &l_134;
    uint32_t l_136 = 0xA87E6343;
    uint32_t *l_135 = &l_136;
    uint32_t l_137 = 1U;
    int16_t *l_138 = &l_134.f0;
    int32_t l_214 = 0;
    struct S1 l_228 = {3U,8U,0x1.C877E7p-17,1,-9,{0x50CD,0xD.CE996Ap+75,0x0D45}};
    int32_t *l_235 = (void*)0;
    for (p_49.f0 = 0; (p_49.f0 <= 16); p_49.f0 += 1)
    { /* block id: 27 */
        float *l_90 = (void*)0;
        int8_t l_97 = 0x9E;
        int8_t *l_96 = &l_97;
        int8_t **l_98 = &l_96;
        int8_t *l_102 = (void*)0;
        int8_t **l_101 = &l_102;
        int32_t l_104 = (-1);
        int32_t *l_103 = &l_104;
        int16_t l_117 = 0xC743;
        int32_t l_126 = 5;
        int32_t *l_125 = &l_126;
        int8_t * const *l_127 = &l_96;
        (*l_103) = ((p_49.f2 < (l_90 != p_47)) && ((int16_t)((-(uint16_t)((uint16_t)((((((((*l_98) = l_96) == ((*l_101) = l_99)) | ((((void*)0 != &l_100) ^ ((p_50 != p_49.f0) != l_97)) > l_97)) != l_100) != p_50) && p_49.f0) | 0x92FD) % (uint16_t)0xA0DA)) != l_100) << (int16_t)12));
        /* statement id: 30 */
        assert (l_102 == 0 || l_102 == &l_100);
        (*l_125) = (((*l_103) = ((int32_t)(&l_99 == (void*)0) % (int32_t)((((-(uint16_t)6U) | ((p_50 | (l_108 = 0x7409415F)) ^ ((uint32_t)(((int16_t)l_100 >> (int16_t)((uint16_t)((uint16_t)((l_124 = ((l_117 | l_100) >= ((uint16_t)(-(uint32_t)(((int16_t)(((!((l_100 & 1) != p_49.f2)) ^ p_50) <= 0x4CE2) >> (int16_t)8) || l_100)) % (uint16_t)p_50))) <= p_49.f2) + (uint16_t)(-1)) % (uint16_t)l_100)) ^ (*l_103)) - (uint32_t)0))) >= l_100) | p_50))) || (-1));
        (*l_125) = (l_127 != &l_102);
    }
    if (((((uint16_t)(0x1B0F4318 || (((uint16_t)l_124 >> (uint16_t)l_132) == ((*l_135) = (l_133 != &l_134)))) << (uint16_t)((*l_138) = l_137)) && (l_108 | ((void*)0 == &l_100))) < l_134.f2))
    { /* block id: 39 */
        uint32_t l_141 = 6U;
        struct S0 ** const l_148 = (void*)0;
        uint32_t l_149 = 0U;
        int32_t l_150 = 0xDF186003;
        int32_t l_151 = 1;
        float l_153 = (-0x8.2p-1);
        float *l_152 = &l_153;
        (*l_152) = ((-0x1.3p-1) >= ((((l_151 = ((float)((l_141 >= (0x1.2p-1 >= ((l_150 = ((((*p_47) = (((float)(((float)((float)(*p_47) - (float)((void*)0 != p_47)) - (float)0xC.146544p+27) > (&l_133 == l_148)) - (float)l_149) > l_141)) > l_149) < 0x7.7p+1)) > 0x7.7FB2C3p-19))) < l_151) + (float)0x1.Cp+1)) < l_149) <= l_149) != 0x1.9p+1));
    }
    else
    { /* block id: 44 */
        int32_t *l_155 = (void*)0;
        int32_t **l_154 = &l_155;
        struct S0 **l_165 = &l_133;
        const int32_t l_166 = (-1);
        uint16_t *l_167 = &l_134.f2;
        int32_t *l_168 = &l_124;
        (*l_154) = (void*)0;
        (*l_168) = ((uint32_t)(p_47 != (void*)0) + (uint32_t)((*l_135) = (((p_51 != p_48) & p_49.f0) || (p_50 >= ((uint32_t)((uint16_t)((uint16_t)(p_49.f2 && (-(uint16_t)((*l_167) = (0x1DC0D213 & ((((((((*l_165) = &l_134) != (void*)0) >= l_166) != l_124) & p_49.f2) ^ 0xE12AA013) != p_50))))) - (uint16_t)p_50) % (uint16_t)0x2C1B) + (uint32_t)p_49.f0)))));
        l_124 = p_49.f2;
        (*l_168) = (*p_48);
    }
    for (l_108 = 12; (l_108 >= 24); l_108 += 5)
    { /* block id: 55 */
        struct S1 l_178 = {65535U,0x2E74,0x0.0p+1,-7,21,{0x4E9F,0x5.8E123Bp-14,0xB66E}};
        const uint16_t *l_184 = &l_134.f2;
        int8_t l_188 = 0xD0;
        int32_t *l_194 = &l_124;
        for (l_124 = 0; (l_124 != (-6)); l_124 -= 1)
        { /* block id: 58 */
            int32_t *l_174 = (void*)0;
            int32_t **l_173 = &l_174;
            uint32_t l_186 = 4294967295U;
            struct S1 *l_192 = &l_178;
            (*l_173) = (void*)0;
            for (l_100 = 0; (l_100 <= (-7)); l_100 -= 1)
            { /* block id: 62 */
                struct S0 **l_177 = &l_133;
                int8_t *l_181 = &l_100;
                int8_t **l_180 = &l_181;
                float l_185 = 0x0.2p-1;
                const int32_t l_187 = 0;
                (*l_177) = &p_49;
                /* statement id: 63 */
                assert (l_133 == &p_49);
                (*l_173) = func_53(l_178, (((-(int16_t)((void*)0 == &l_134)) ^ (-5)) != ((l_180 == &l_99) != ((uint16_t)((((l_184 != (void*)0) == p_49.f2) == p_49.f0) & l_178.f4) - (uint16_t)l_186))), p_48, l_187, l_174);
            }
            if ((l_188 && ((int16_t)0xE2AC >> (int16_t)7)))
            { /* block id: 66 */
                uint32_t **l_191 = (void*)0;
                l_191 = &l_135;
                /* statement id: 67 */
                assert (l_191 == &l_135);
                return p_47;
                /* statement id: 68 */
                //assert (func_46_rv == &l_40 || func_46_rv == &l_308 || func_46_rv == &l_547);
            }
            else
            { /* block id: 69 */
                struct S1 **l_193 = &l_192;
                (*l_193) = l_192;
            }
        }
        if (((*l_194) = l_188))
        { /* block id: 74 */
            uint32_t l_195 = 1U;
            struct S1 l_196 = {65532U,1U,0x2.5917A2p+79,0x50D1834D,-13,{0,0xD.145D4Fp+32,0x0D53}};
            int32_t **l_197 = (void*)0;
            int32_t **l_198 = (void*)0;
            int32_t **l_199 = &l_194;
            if (l_195)
                break;
            (*l_199) = func_53(l_196, ((*l_194) = 0x5BF0B686), l_135, l_108, l_194);
        }
        else
        { /* block id: 78 */
            int32_t **l_200 = &l_194;
            int32_t l_224 = (-7);
            (*l_200) = p_47;
            /* statement id: 79 */
            //assert (l_194 == &l_40 || l_194 == &l_308 || l_194 == &l_547);
            l_194 = (*l_200);
            for (l_178.f3 = 0; (l_178.f3 <= (-9)); --l_178.f3)
            { /* block id: 83 */
                uint32_t l_212 = 4294967293U;
                float l_216 = (-0x9.2p-1);
                float *l_215 = &l_216;
                int32_t l_223 = 0;
            }
            return p_47;
            /* statement id: 99 */
            //assert (func_46_rv == &l_40 || func_46_rv == &l_308 || func_46_rv == &l_547);
        }
    }
    /* facts after for loop */
    assert (l_133 == &p_49 || l_133 == &l_134);
    if ((l_214 || p_49.f0))
    { /* block id: 102 */
        return p_48;
        /* statement id: 103 */
        //assert (func_46_rv == &l_40 || func_46_rv == &l_523 || func_46_rv == &l_519 || func_46_rv == &l_547);
    }
    else
    { /* block id: 104 */
        struct S1 l_229 = {2U,1U,0x9.Fp+1,-8,26,{0x60A9,0x2.48E669p-24,0x1AA5}};
        int32_t *l_230 = (void*)0;
        int32_t *l_231 = &l_124;
        float l_233 = 0xF.546D85p-88;
        float *l_232 = &l_233;
        int32_t **l_234 = &l_230;
        int16_t *l_248 = &l_134.f0;
        (*l_234) = func_53(l_228, p_49.f0, func_53(l_229, (l_108 = ((*l_231) = 9)), p_48, p_49.f0, l_232), p_50, l_135);
        /* statement id: 107 */
        assert (l_230 == &l_136);
        l_235 = &l_124;
        /* statement id: 108 */
        assert (l_235 == &l_124);
        for (l_108 = 12; (l_108 == 3); --l_108)
        { /* block id: 111 */
            (*l_234) = p_47;
            /* statement id: 112 */
            //assert (l_230 == &l_40 || l_230 == &l_308 || l_230 == &l_547);
        }
        /* facts after for loop */
        //assert (l_230 == &l_40 || l_230 == &l_136 || l_230 == &l_308 || l_230 == &l_547);
        for (l_228.f5.f2 = (-12); (l_228.f5.f2 > 35); l_228.f5.f2 += 4)
        { /* block id: 116 */
            int16_t l_242 = 0x046C;
            for (l_137 = 0; (l_137 == 7); ++l_137)
            { /* block id: 119 */
                int16_t **l_247 = (void*)0;
                const struct S1 **l_249 = (void*)0;
                const int32_t l_269 = 0x00E812EF;
                float *l_272 = (void*)0;
                (*l_231) = l_242;
                if (((uint32_t)(((l_138 = &l_132) == l_248) > (p_51 == p_48)) + (uint32_t)((8U <= p_49.f2) < ((void*)0 == l_249))))
                { /* block id: 122 */
                    struct S1 l_252 = {0U,0x1472,0x1.9p+1,-1,-30,{0x8E35,-0x5.6p+1,0U}};
                    float *l_260 = &l_233;
                    float *l_261 = (void*)0;
                    float l_263 = 0xD.53DA89p-94;
                    float *l_262 = &l_263;
                    float *l_266 = (void*)0;
                    float l_268 = 0x6.Cp-1;
                    float *l_267 = &l_268;
                    for (l_229.f0 = 9; (l_229.f0 != 42); ++l_229.f0)
                    { /* block id: 125 */
                        float **l_253 = &l_232;
                        (*l_234) = func_53(l_252, p_50, p_47, p_49.f0, ((*l_253) = (void*)0));
                        /* statement id: 127 */
                        assert (l_230 == 0);
                        assert (l_232 == 0);
                    }
                    (*p_48) = ((l_252.f3 < (((float)((float)((*p_47) != ((*l_262) = ((*p_51) > ((l_252.f4 = ((float)((*l_260) = 0x1.8p+1) + (float)(*p_47))) != (*p_51))))) + (float)((*l_235) < 0xD.6F371Bp-15)) + (float)(((*l_267) = (((float)(0x0.Dp-1 == 0xB.503CBCp+99) - (float)(-0x5.4p-1)) <= 0x3.0F1761p+82)) > l_252.f3)) != 0x1.1p+1)) >= l_269);
                    (*l_262) = 0x6.282E64p-34;
                }
                else
                { /* block id: 135 */
                    if (p_49.f2)
                        break;
                    if (((int16_t)1 >> (int16_t)9))
                    { /* block id: 137 */
                        (*p_47) = (*p_48);
                        return p_48;
                        /* statement id: 139 */
                        //assert (func_46_rv == &l_40 || func_46_rv == &l_523 || func_46_rv == &l_519 || func_46_rv == &l_547);
                    }
                    else
                    { /* block id: 140 */
                        (*l_234) = &l_108;
                        /* statement id: 141 */
                        assert (l_230 == &l_108);
                        return l_272;
                        /* statement id: 142 */
                        //assert (func_46_rv == 0);
                    }
                }
                /* facts after branching */
                assert (l_138 == &l_132);
            }
        }
        /* facts after for loop */
        assert (l_138 == &l_132 || l_138 == &l_134.f0);
        //assert (l_230 == 0 || l_230 == &l_40 || l_230 == &l_136 || l_230 == &l_308 || l_230 == &l_547);
        assert (l_232 == 0 || l_232 == &l_233);
    }
    /* facts after branching */
    assert (l_138 == &l_132 || l_138 == &l_134.f0);
    assert (l_235 == &l_124);
    return p_48;
    /* statement id: 148 */
    //assert (func_46_rv == &l_40 || func_46_rv == &l_523 || func_46_rv == &l_519 || func_46_rv == &l_547);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_53(struct S1  p_54, int32_t  p_55, float * p_56, const int8_t  p_57, float * p_58)
{ /* block id: 20 */
    struct S0 l_82 = {0x34C8,-0x7.6p+1,1U};
    struct S0 *l_81 = &l_82;
    struct S0 **l_83 = &l_81;
    int32_t l_84 = 0;
    float l_86 = (-0x8.3p+1);
    float *l_85 = &l_86;
    (*l_83) = l_81;
    l_84 = p_55;
    return p_58;
    /* statement id: 23 */
    //assert (func_53_rv == &l_40 || func_53_rv == 0 || func_53_rv == &l_124 || func_53_rv == &l_233 || func_53_rv == &l_136 || func_53_rv == &l_547 || func_53_rv == &l_794);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_62(int8_t  p_63, float  p_64, float * p_65, float  p_66, struct S0  p_67)
{ /* block id: 11 */
    uint32_t l_80 = 1U;
    for (p_63 = 0; (p_63 != 16); p_63 += 4)
    { /* block id: 14 */
        struct S0 *l_78 = (void*)0;
        struct S0 **l_79 = &l_78;
        if (p_63)
            break;
        (*l_79) = l_78;
        return l_80;
    }
    return l_80;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 165
   depth: 1, occurrence: 5
   depth: 2, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 14
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 6
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 5

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 27
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 31, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 284

XXX times a variable address is taken: 240
XXX times a pointer is dereferenced on RHS: 69
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 175
breakdown:
   depth: 1, occurrence: 171
   depth: 2, occurrence: 4
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 457

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1019
   level: 2, occurrence: 48
   level: 3, occurrence: 12
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 112
XXX number of pointers point to scalars: 154
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 29.9
XXX average alias set size: 1.3

XXX times a non-volatile is read: 777
XXX times a non-volatile is write: 442
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 126
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 27
   depth: 2, occurrence: 17
   depth: 3, occurrence: 16
   depth: 4, occurrence: 12
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

