/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2463980812
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
   uint16_t  f3;
   uint32_t  f4;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint16_t  f0;
   float  f1;
   float  f2;
   uint32_t  f3;
   int16_t  f4;
   int16_t  f5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static const float g_11 = 0xF.3EC752p+69;
static const int32_t g_12 = 0L;
static int32_t g_36 = 0xEB476352L;
static int32_t *g_46 = (void*)0;
static int32_t **g_45 = &g_46;
static float g_75 = 0xA.88E6FCp+28;
static struct S1 g_95 = {65535UL,0x1.Fp-1,0x4.6p+1,0xDC12F674L,-1L,7L};
static const struct S0 g_129[4] = {{0x18A46498L,0xA426AC6DL,0x1E7DF7C4L,1UL,4294967295UL},{0x18A46498L,0xA426AC6DL,0x1E7DF7C4L,1UL,4294967295UL},{0x18A46498L,0xA426AC6DL,0x1E7DF7C4L,1UL,4294967295UL},{0x18A46498L,0xA426AC6DL,0x1E7DF7C4L,1UL,4294967295UL}};
static struct S1 *g_136 = &g_95;
static struct S1 **g_135 = &g_136;
static struct S1 ***g_134 = &g_135;
static int32_t g_156 = 0xA4B03959L;
static struct S0 g_161 = {4294967290UL,0xD5A12BEBL,0x04F644B9L,0UL,0xAC27A575L};
static const float **g_212 = (void*)0;
static int32_t ***g_237 = &g_45;
static const int32_t *g_371[7][6] = {{&g_36,&g_36,(void*)0,(void*)0,(void*)0,&g_36},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&g_36,(void*)0,(void*)0,(void*)0,&g_36,&g_36},{&g_36,(void*)0,(void*)0,&g_36,(void*)0,&g_36},{&g_36,(void*)0,&g_36,(void*)0,(void*)0,&g_36},{&g_36,&g_36,(void*)0,(void*)0,(void*)0,&g_36},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
static struct S0 g_458[6] = {{4294967295UL,0x90F7BAA6L,0x82EF53F3L,65526UL,0x316FB4B6L},{4294967295UL,0x90F7BAA6L,0x82EF53F3L,65526UL,0x316FB4B6L},{4294967295UL,0x90F7BAA6L,0x82EF53F3L,65526UL,0x316FB4B6L},{4294967295UL,0x90F7BAA6L,0x82EF53F3L,65526UL,0x316FB4B6L},{4294967295UL,0x90F7BAA6L,0x82EF53F3L,65526UL,0x316FB4B6L},{4294967295UL,0x90F7BAA6L,0x82EF53F3L,65526UL,0x316FB4B6L}};
static struct S1 g_499 = {65534UL,0x4.Dp+1,0xC.D61C1Fp-33,0x59E2A293L,0L,0L};
static struct S0 *g_527 = &g_458[4];
static struct S0 **g_526 = &g_527;
static struct S0 ***g_525[1][8] = {{&g_526,&g_526,&g_526,&g_526,&g_526,&g_526,&g_526,&g_526}};
static struct S1 ****g_556 = &g_134;
static struct S1 *****g_555 = &g_556;
static int16_t g_630 = 0x8532L;
static int32_t g_784[1] = {(-3L)};
static int32_t ****g_819 = &g_237;
static int32_t *****g_818[4] = {&g_819,&g_819,&g_819,&g_819};
static struct S0 ****g_989 = &g_525[0][4];
static struct S0 *****g_988 = &g_989;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static const float  func_2(uint32_t  p_3, int32_t  p_4, const int32_t  p_5, uint16_t  p_6);
static uint32_t  func_7(const uint16_t  p_8, uint16_t  p_9, struct S0  p_10);
static struct S0  func_14(int32_t  p_15);
static int16_t  func_18(const int16_t  p_19);
static uint16_t  func_38(struct S1  p_39, uint16_t  p_40, uint16_t  p_41, int32_t ** p_42, int16_t  p_43);
static float  func_47(int32_t ** p_48, struct S0  p_49, int32_t  p_50, int32_t * p_51);
static struct S0  func_53(const int16_t  p_54, const struct S0  p_55, uint32_t  p_56, uint32_t  p_57);
static uint32_t  func_58(struct S1  p_59);
static uint32_t  func_63(int32_t * p_64);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_12 g_36 g_45 g_75 g_95.f5 g_95.f3 g_95.f4 g_95.f0 g_46 g_129 g_134 g_135 g_136 g_161.f3 g_161.f4 g_161.f0 g_212 g_95 g_237 g_161.f2 g_156 g_161.f1 g_371 g_161 g_458.f2 g_525 g_499.f3 g_526 g_527 g_458 g_499.f5 g_499.f2 g_499.f0 g_630 g_499.f4 g_556 g_819
 * writes: g_75 g_95 g_46 g_156 g_161 g_36 g_136 g_237 g_371 g_135 g_499 g_555 g_527 g_458 g_630
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_13 = 1L;
    const int16_t l_34 = 0xF0D4L;
    float *l_758 = &g_499.f1;
    struct S1 l_764[5][7] = {{{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L}},{{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0x5553L,0x9.C35648p-73,0x3.3B8663p-69,9UL,0xF24FL,0x83CEL},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0x5553L,0x9.C35648p-73,0x3.3B8663p-69,9UL,0xF24FL,0x83CEL},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L}},{{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{0UL,0x2.4B5B1Fp+49,0xD.1B68A4p+3,7UL,-1L,7L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{0UL,0x2.4B5B1Fp+49,0xD.1B68A4p+3,7UL,-1L,7L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L}},{{0x5553L,0x9.C35648p-73,0x3.3B8663p-69,9UL,0xF24FL,0x83CEL},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0x5553L,0x9.C35648p-73,0x3.3B8663p-69,9UL,0xF24FL,0x83CEL},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0UL,0xD.309474p-48,0x3.1CB5C7p-63,4294967295UL,0xDD06L,0x94D6L},{0x5553L,0x9.C35648p-73,0x3.3B8663p-69,9UL,0xF24FL,0x83CEL}},{{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{0x5CA1L,-0x1.1p+1,-0x1.5p-1,0UL,-4L,0xC266L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L},{65528UL,-0x1.Cp-1,0x3.7DEDD4p+94,0xEA1FCDFEL,0xB460L,1L}}};
    struct S0 l_768 = {8UL,0x8A1A6BB1L,0x385EB4D3L,0x5DF8L,0x07C0155FL};
    struct S1 *****l_829 = &g_556;
    uint32_t l_874 = 0x39537D7CL;
    const struct S1 *l_875[7][7][1] = {{{&g_499},{&g_95},{&l_764[4][6]},{&g_95},{&g_499},{&l_764[4][6]},{(void*)0}},{{(void*)0},{&l_764[4][6]},{&g_499},{&g_95},{&l_764[4][6]},{&g_95},{&g_499}},{{&l_764[4][6]},{(void*)0},{(void*)0},{&l_764[4][6]},{&g_499},{&g_95},{&l_764[4][6]}},{{&g_95},{&g_499},{&l_764[4][6]},{(void*)0},{(void*)0},{&l_764[4][6]},{&g_499}},{{&g_95},{&l_764[4][6]},{&g_95},{&g_499},{&l_764[4][6]},{(void*)0},{(void*)0}},{{&l_764[4][6]},{&g_499},{&g_95},{&l_764[4][6]},{&g_95},{&g_499},{&l_764[4][6]}},{{(void*)0},{(void*)0},{&l_764[4][6]},{&g_499},{&g_95},{&l_764[4][6]},{&g_95}}};
    int32_t l_894 = 0x63891599L;
    int32_t l_897 = 7L;
    uint16_t l_1028 = 0xA90DL;
    int32_t *l_1037 = &l_894;
    struct S0 **l_1065 = &g_527;
    int32_t l_1069 = (-8L);
    int i, j, k;
    (*l_758) = (func_2(func_7(g_12, l_13, func_14(((int16_t)func_18(((int16_t)l_13 >> (int16_t)((int16_t)((int16_t)((((int32_t)(((65531UL ^ (((uint32_t)l_13 % (uint32_t)((int16_t)((uint16_t)g_12 >> (uint16_t)(l_13 != ((0x40DFL > ((l_13 && g_12) < l_13)) >= 0x509BL))) + (int16_t)0x0385L)) || 0L)) >= 0x1058L) <= g_12) - (int32_t)0UL) >= 0x1F19L) , l_13) << (int16_t)l_34) / (int16_t)0x7698L))) >> (int16_t)9))), g_129[3].f4, l_13, g_12) < 0x6.191FF1p-15);
    /* statement id: 382 */
    //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
    //assert (g_136 == dangling || g_136 == &g_95);
    assert (g_135 == 0 || g_135 == &g_136);
    //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
    //assert (g_555 == &g_556 || g_555 == dangling);
    (**g_237) = (l_34 , &l_13);
    /* statement id: 383 */
    assert (g_46 == &l_13);
    if (((!4L) ^ g_95.f0))
    { /* block id: 384 */
        (*l_758) = g_36;
    }
    else
    { /* block id: 386 */
        const int16_t l_760 = (-1L);
        const struct S0 l_761 = {0x7DF3C328L,18446744073709551615UL,1UL,65535UL,1UL};
        struct S0 *l_767[8][10][1] = {{{(void*)0},{&g_458[0]},{(void*)0},{&g_458[2]},{&g_161},{&g_458[2]},{(void*)0},{&g_458[0]},{(void*)0},{(void*)0}},{{&g_161},{&g_161},{&g_161},{(void*)0},{(void*)0},{&g_458[0]},{(void*)0},{&g_458[2]},{&g_161},{&g_458[2]}},{{(void*)0},{&g_458[0]},{(void*)0},{(void*)0},{&g_161},{&g_161},{&g_161},{(void*)0},{(void*)0},{&g_458[0]}},{{(void*)0},{&g_458[2]},{&g_161},{&g_458[2]},{(void*)0},{&g_458[0]},{(void*)0},{(void*)0},{&g_161},{&g_161}},{{&g_161},{(void*)0},{(void*)0},{&g_458[0]},{(void*)0},{&g_458[2]},{&g_161},{&g_458[2]},{(void*)0},{&g_458[0]}},{{(void*)0},{(void*)0},{&g_161},{&g_161},{&g_161},{(void*)0},{(void*)0},{&g_458[0]},{(void*)0},{&g_458[2]}},{{&g_161},{&g_458[2]},{(void*)0},{&g_458[0]},{(void*)0},{(void*)0},{&g_161},{&g_161},{&g_161},{(void*)0}},{{(void*)0},{&g_458[0]},{(void*)0},{&g_458[2]},{&g_161},{&g_458[2]},{(void*)0},{&g_458[0]},{(void*)0},{(void*)0}}};
        const int32_t l_816 = 0x910BB9D9L;
        struct S0 *l_825[9] = {&g_458[5],&g_458[5],&g_458[5],&g_458[5],&g_458[5],&g_458[5],&g_458[5],&g_458[5],&g_458[5]};
        const struct S1 l_864[1][9][7] = {{{{65535UL,0x5.0p-1,0x0.96CF09p-75,7UL,1L,0x80DCL},{65534UL,0x0.Ap+1,0xC.63BE88p+68,1UL,0xB865L,0L},{65535UL,0x5.0p-1,0x0.96CF09p-75,7UL,1L,0x80DCL},{0xD8A8L,0x5.1DAA8Ap-52,0x1.C0F7B6p-68,0x4A1C09CAL,0xABF0L,0L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{8UL,0xE.DC75D9p+12,0x8.DF3B6Dp+0,4294967292UL,-9L,0x9683L}},{{65534UL,0x0.Ap+1,0xC.63BE88p+68,1UL,0xB865L,0L},{2UL,0x3.CCA225p-99,0xF.5D4CA3p+23,0x1BABAD44L,0x57EAL,0xD866L},{65535UL,0x5.0p-1,0x0.96CF09p-75,7UL,1L,0x80DCL},{0xD213L,0x5.F73659p-6,0x7.BCDE72p-53,0x6BD625BBL,0x9E02L,-4L},{0x4FE4L,0xF.E5B61Ep+49,0x0.0p+1,0xE06CEEC5L,-2L,0L},{0xD213L,0x5.F73659p-6,0x7.BCDE72p-53,0x6BD625BBL,0x9E02L,-4L},{65535UL,0x5.0p-1,0x0.96CF09p-75,7UL,1L,0x80DCL}},{{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{0xD213L,0x5.F73659p-6,0x7.BCDE72p-53,0x6BD625BBL,0x9E02L,-4L},{0xDFEAL,0x1.8C5F52p-12,0xC.AD0781p-90,0xD840E9FFL,0xE939L,0x545DL},{0x7D8CL,0x0.4p-1,-0x1.Ap+1,0x392A3C85L,0xB3DFL,-5L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{65534UL,0x0.Ap+1,0xC.63BE88p+68,1UL,0xB865L,0L}},{{0xDFEAL,0x1.8C5F52p-12,0xC.AD0781p-90,0xD840E9FFL,0xE939L,0x545DL},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L}},{{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L},{2UL,0x3.CCA225p-99,0xF.5D4CA3p+23,0x1BABAD44L,0x57EAL,0xD866L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{65535UL,0x5.0p-1,0x0.96CF09p-75,7UL,1L,0x80DCL},{0x7D8CL,0x0.4p-1,-0x1.Ap+1,0x392A3C85L,0xB3DFL,-5L},{0xD8A8L,0x5.1DAA8Ap-52,0x1.C0F7B6p-68,0x4A1C09CAL,0xABF0L,0L},{0xDFEAL,0x1.8C5F52p-12,0xC.AD0781p-90,0xD840E9FFL,0xE939L,0x545DL}},{{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L},{65534UL,0x0.Ap+1,0xC.63BE88p+68,1UL,0xB865L,0L},{0x4FE4L,0xF.E5B61Ep+49,0x0.0p+1,0xE06CEEC5L,-2L,0L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{0x4FE4L,0xF.E5B61Ep+49,0x0.0p+1,0xE06CEEC5L,-2L,0L},{65534UL,0x0.Ap+1,0xC.63BE88p+68,1UL,0xB865L,0L},{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L}},{{0xDFEAL,0x1.8C5F52p-12,0xC.AD0781p-90,0xD840E9FFL,0xE939L,0x545DL},{0xD8A8L,0x5.1DAA8Ap-52,0x1.C0F7B6p-68,0x4A1C09CAL,0xABF0L,0L},{0x7D8CL,0x0.4p-1,-0x1.Ap+1,0x392A3C85L,0xB3DFL,-5L},{65535UL,0x5.0p-1,0x0.96CF09p-75,7UL,1L,0x80DCL},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{2UL,0x3.CCA225p-99,0xF.5D4CA3p+23,0x1BABAD44L,0x57EAL,0xD866L},{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L}},{{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{9UL,0x9.398DC9p+66,0xB.DC3B13p+73,0x0BAB9276L,0xFA17L,0x5023L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{0xDFEAL,0x1.8C5F52p-12,0xC.AD0781p-90,0xD840E9FFL,0xE939L,0x545DL}},{{65534UL,0x0.Ap+1,0xC.63BE88p+68,1UL,0xB865L,0L},{0x1CBFL,0xC.E8977Cp-75,0x6.A1132Cp-8,4UL,5L,-1L},{0x7D8CL,0x0.4p-1,-0x1.Ap+1,0x392A3C85L,0xB3DFL,-5L},{0xDFEAL,0x1.8C5F52p-12,0xC.AD0781p-90,0xD840E9FFL,0xE939L,0x545DL},{0xD213L,0x5.F73659p-6,0x7.BCDE72p-53,0x6BD625BBL,0x9E02L,-4L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L},{0x7A1CL,-0x8.9p-1,0x7.Ap-1,6UL,0L,0x7205L}}}};
        const struct S1 *l_895 = &l_864[0][3][2];
        uint32_t l_898[5] = {0x48D6D6A3L,0x48D6D6A3L,0x48D6D6A3L,0x48D6D6A3L,0x48D6D6A3L};
        uint16_t l_909 = 0x75C2L;
        float *l_910 = &l_764[4][6].f1;
        struct S1 ***l_966[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
        int32_t **l_967 = &g_46;
        struct S1 *****l_1000 = &g_556;
        const uint32_t l_1066 = 0x8030347CL;
        int32_t l_1068 = 0x9BDB2AABL;
        int i, j, k;
        l_768 = func_53(l_760, l_761, ((65535UL != (((int32_t)l_13 + (int32_t)1UL) , (l_13 ^ ((func_14((((l_764[4][6] , (((l_761.f4 < ((((uint16_t)g_161.f1 >> (uint16_t)0) > 5L) , g_95.f4)) , 0x4DBFBCA3L) | 0xE629EFC1L)) | g_129[3].f2) > (***g_237))) , l_758) == l_758)))) , l_761.f4), l_761.f0);
        for (g_161.f0 = 0; (g_161.f0 == 51); g_161.f0 += 1)
        { /* block id: 390 */
            int16_t l_777 = 1L;
            struct S0 l_824 = {4294967293UL,0x0A250994L,4294967295UL,0xD773L,4294967295UL};
            int32_t *l_850 = (void*)0;
            struct S1 *l_896[3];
            int32_t ***l_932 = &g_45;
            struct S0 *****l_987 = (void*)0;
            struct S1 *****l_999 = &g_556;
            int32_t ****l_1034 = (void*)0;
            struct S0 **l_1064 = &l_767[3][2][0];
            uint32_t l_1067 = 0x91E3ECECL;
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_896[i] = &l_764[1][2];
        }
    }
    (***g_819) = (**g_237);
    return l_1069;
    /* statement id: 480 */
    //assert (g_46 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_499
 */
static const float  func_2(uint32_t  p_3, int32_t  p_4, const int32_t  p_5, uint16_t  p_6)
{ /* block id: 379 */
    struct S1 l_755 = {0x8377L,0x1.8p-1,0x5.9C3388p-31,0xF65F5AC8L,0x2D59L,0xA734L};
    struct S1 *l_756[8] = {&g_499,&g_499,&g_499,&g_499,&g_499,&g_499,&g_499,&g_499};
    const float l_757[3] = {0xC.80B6FDp-88,0xC.80B6FDp-88,0xC.80B6FDp-88};
    int i;
    g_499 = l_755;
    return l_757[1];
}


/* ------------------------------------------ */
/* 
 * reads : g_458.f2 g_525 g_237 g_45 g_161.f4 g_499.f3 g_526 g_527 g_458 g_161.f3 g_129.f2 g_161.f0 g_156 g_46 g_499.f5 g_499.f2 g_95.f3 g_12 g_95.f4 g_95.f2 g_129.f1 g_212 g_161.f2 g_129.f0 g_129.f3 g_630 g_499.f4 g_95.f5 g_556 g_134 g_499.f0 g_161.f1
 * writes: g_161.f4 g_156 g_95.f4 g_46 g_499 g_95.f3 g_555 g_237 g_527 g_95.f5 g_458 g_161.f3 g_630 g_75 g_95
 */
static uint32_t  func_7(const uint16_t  p_8, uint16_t  p_9, struct S0  p_10)
{ /* block id: 238 */
    uint32_t l_504 = 0UL;
    struct S0 *l_510 = &g_458[2];
    struct S0 **l_509 = &l_510;
    uint32_t l_524[5][1];
    struct S1 l_534 = {0x7D1CL,0x5.E935D9p+50,0x3.0B733Cp-90,4294967295UL,-5L,-1L};
    uint32_t l_546 = 0x2BA32941L;
    int32_t l_557 = 0L;
    uint32_t l_579[4];
    struct S1 **l_580 = &g_136;
    float *l_704 = (void*)0;
    float **l_703 = &l_704;
    float ***l_702 = &l_703;
    struct S1 *****l_716 = (void*)0;
    int32_t **l_740 = &g_46;
    struct S1 l_745 = {0x7596L,0x0.6p-1,-0x2.2p-1,0x23F5EC66L,0xD7C3L,7L};
    int i, j;
    for (i = 0; i < 5; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
            l_524[i][j] = 6UL;
    }
    for (i = 0; i < 4; i = i + 1)
        l_579[i] = 0x828B368CL;
    if ((((uint16_t)(((int32_t)l_504 + (int32_t)((uint16_t)((uint32_t)g_458[2].f2 - (uint32_t)7UL) / (uint16_t)((l_509 != &l_510) | 0xAB461D3EL))) != ((int16_t)(-10L) % (int16_t)((int16_t)((uint16_t)((int32_t)(((uint32_t)((int32_t)((0x18E0L ^ (+(((0x6F4E3DEAL | p_10.f2) != p_10.f4) || l_504))) ^ l_504) + (int32_t)0L) / (uint32_t)l_524[3][0]) & p_9) + (int32_t)p_9) + (uint16_t)l_524[3][0]) << (int16_t)p_10.f1))) - (uint16_t)l_524[2][0]) || 9L))
    { /* block id: 239 */
        const int32_t l_550 = 0x64E2B877L;
        struct S1 l_560 = {1UL,0x9.Dp-1,0x4.57F836p+30,0x2E43DBF8L,-10L,0x9183L};
        struct S1 **l_568[2][9][1] = {{{(void*)0},{(void*)0},{&g_136},{&g_136},{&g_136},{(void*)0},{(void*)0},{(void*)0},{&g_136}},{{&g_136},{&g_136},{(void*)0},{(void*)0},{(void*)0},{&g_136},{&g_136},{&g_136},{(void*)0}}};
        int32_t *l_697 = &l_557;
        float ***l_746 = &l_703;
        const uint32_t l_747 = 0UL;
        int i, j, k;
lbl_661:
        for (g_161.f4 = 0; (g_161.f4 <= 0); g_161.f4 += 1)
        { /* block id: 242 */
            struct S0 ***l_528 = &g_526;
            int32_t *l_529 = &g_156;
            for (g_156 = 5; (g_156 >= 0); g_156 -= 1)
            { /* block id: 245 */
                struct S0 **l_532 = (void*)0;
                int32_t l_533 = 0x11F2B11DL;
                int32_t *l_559[2];
                int i;
                for (i = 0; i < 2; i = i + 1)
                    l_559[i] = &g_36;
                l_528 = g_525[0][4];
                for (l_504 = 0; (l_504 <= 0); l_504 += 1)
                { /* block id: 249 */
                    int i, j;
                    for (g_95.f4 = 5; (g_95.f4 >= 0); g_95.f4 -= 1)
                    { /* block id: 252 */
                        struct S1 *l_535 = &g_499;
                        (**g_237) = l_529;
                        /* statement id: 253 */
                        assert (g_46 == &g_156);
                        l_533 = (((uint16_t)0xD742L >> (uint16_t)14) < (&l_510 == l_532));
                        (*l_535) = l_534;
                    }
                    return l_524[(g_161.f4 + 3)][l_504];
                    /* statement id: 257 */
                    //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                    //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                }
                for (g_95.f3 = 0; (g_95.f3 <= 0); g_95.f3 += 1)
                { /* block id: 261 */
                    float l_536 = 0xC.0834E8p-49;
                    struct S1 l_549 = {0x6283L,0x1.0p+1,-0x1.Fp+1,5UL,1L,0x55AAL};
                    int16_t l_551 = 0xF7F9L;
                    int16_t l_552 = 0x2E0EL;
                    if ((((((l_534.f0 & (g_499.f3 & ((-10L) != (((((((**g_526) , &p_10) == (void*)0) ^ ((int16_t)(+((uint16_t)((int32_t)(l_546 != ((((0xD2CAL >= (((int32_t)(l_549 , p_10.f4) + (int32_t)p_10.f1) , g_161.f3)) , 0xC0A2CD49L) || l_533) != g_129[3].f2)) % (int32_t)6UL) << (uint16_t)g_161.f0)) << (int16_t)8)) & l_549.f4) >= l_549.f4) || l_549.f0)))) ^ 0UL) , l_550) <= l_551) ^ l_552))
                    { /* block id: 262 */
                        struct S1 ****l_554 = &g_134;
                        struct S1 *****l_553 = &l_554;
                        int32_t ****l_558 = &g_237;
                        g_555 = l_553;
                        /* statement id: 263 */
                        assert (g_555 == &l_554);
                        l_557 = (0xDD7FL > (&p_10 != ((*l_529) , ((p_10.f0 == 0UL) , (l_534 , (**l_528))))));
                        (*l_558) = &g_45;
                    }
                    else
                    { /* block id: 266 */
                        (*g_45) = (**g_237);
                        (*g_526) = &p_10;
                        /* statement id: 268 */
                        assert (g_527 == &p_10);
                        l_559[1] = (**g_237);
                    }
                    for (l_534.f4 = 0; (l_534.f4 >= 0); l_534.f4 -= 1)
                    { /* block id: 273 */
                        l_560 = l_560;
                        (**g_237) = (*g_45);
                        return p_10.f1;
                        /* statement id: 276 */
                        //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                        //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                    }
                }
                /* facts after for loop */
                //assert (l_559[0] == &l_557 || l_559[0] == &g_156 || l_559[0] == 0 || l_559[0] == &g_36);
            }
            for (g_95.f5 = 0; (g_95.f5 <= 5); g_95.f5 += 1)
            { /* block id: 282 */
                const struct S0 l_569 = {1UL,0xD3078027L,0xEC2BBE00L,0xF245L,0x4762F34FL};
                for (l_546 = 0; (l_546 <= 5); l_546 += 1)
                { /* block id: 285 */
                    float *l_581[8][8] = {{&l_534.f2,&l_534.f2,(void*)0,&l_534.f1,(void*)0,&l_534.f2,&l_534.f2,(void*)0},{&g_95.f1,(void*)0,(void*)0,&g_95.f1,&g_95.f2,&g_95.f1,(void*)0,(void*)0},{(void*)0,&g_95.f2,&l_534.f1,&l_534.f1,&g_95.f2,(void*)0,&g_95.f2,&l_534.f1},{&g_95.f1,&g_95.f2,&g_95.f1,(void*)0,(void*)0,&g_95.f1,&g_95.f2,&g_95.f1},{&l_534.f2,(void*)0,&l_534.f1,(void*)0,&l_534.f2,&l_534.f2,(void*)0,&l_534.f1},{&l_534.f2,&l_534.f2,(void*)0,&l_534.f1,(void*)0,&l_534.f2,&l_534.f2,(void*)0},{&g_95.f1,(void*)0,(void*)0,&g_95.f1,&g_95.f2,&g_95.f1,(void*)0,(void*)0},{(void*)0,&g_95.f2,&l_534.f1,&l_534.f1,&g_95.f2,(void*)0,&g_95.f2,&l_534.f1}};
                    int i, j;
                    g_499.f1 = (((float)(((float)(+((((((int16_t)(l_568[0][5][0] != (func_53(p_10.f2, l_569, (((int32_t)((uint32_t)(l_504 > (0UL <= (((uint16_t)(((+0x4D2FL) < (p_10.f3 != ((p_10 , 0x393BL) || l_579[0]))) <= l_569.f0) >> (uint16_t)6) , l_560.f4))) / (uint32_t)l_546) - (int32_t)p_10.f2) | g_499.f5), p_8) , l_580)) << (int16_t)p_8) != 0xAB8874ABL) , l_569.f4) > (-0x1.Bp-1)) == 0xD.0D0A11p-57)) / (float)g_499.f2) == g_95.f3) / (float)0x5.1ABF29p-38) != l_534.f3);
                    return g_12;
                    /* statement id: 287 */
                    //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                    //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                }
            }
            for (l_560.f4 = 0; (l_560.f4 <= 0); l_560.f4 += 1)
            { /* block id: 292 */
                uint16_t l_588 = 0xCC57L;
                struct S1 l_593 = {0x77A0L,0x9.ABA56Dp+13,-0x1.2p-1,0xF607F173L,0x6359L,0xC050L};
                float *l_599 = (void*)0;
                float *l_600 = &l_534.f2;
                (*l_529) = ((uint16_t)p_8 - (uint16_t)g_156);
                (*l_600) = ((0x0.D82DBEp+69 > (((float)(p_10.f2 != ((0xB.FF0BE7p-95 > 0x1.73F640p-82) <= (((float)(l_588 >= ((float)((l_560.f0 == ((-(float)(+((l_593 , (((float)((float)g_95.f4 + (float)((!(0x1.DAF9F9p-14 != p_8)) < g_95.f2)) + (float)l_504) < (*l_529))) > 0x2.47D2ECp-14))) < 0x5.65DAE5p+11)) >= l_588) + (float)l_579[0])) + (float)l_593.f4) < 0xD.9654DBp+62))) / (float)l_579[0]) == (*l_529))) < 0xF.F149BAp+90);
                l_593 = l_593;
                if (((int32_t)((int16_t)l_560.f5 << (int16_t)p_10.f0) / (int32_t)((*l_529) && g_499.f3)))
                { /* block id: 296 */
                    struct S1 *l_605 = &l_593;
                    int i;
                    l_605 = &l_534;
                    /* statement id: 297 */
                    assert (l_605 == &l_534);
                    g_458[(l_560.f4 + 4)] = p_10;
                    if (p_10.f0)
                        continue;
                }
                else
                { /* block id: 300 */
                    (*l_600) = (-(float)(0xF.52B92Fp-10 < ((((((int16_t)((*l_529) && ((((uint16_t)((((int16_t)(g_129[3].f1 ^ 0x44825281L) - (int16_t)((0x383ADA91L < 0x24D5CD3BL) > ((l_593.f5 <= ((int16_t)(((int16_t)(g_458[2].f3 < p_10.f2) >> (int16_t)g_499.f5) <= l_560.f0) >> (int16_t)p_10.f1)) <= 1UL))) <= 6UL) && p_8) / (uint16_t)(*l_529)) != p_10.f3) >= g_156)) >> (int16_t)g_458[2].f1) && g_12) , (void*)0) != g_212) > l_579[0])));
                }
            }
        }
        for (g_499.f0 = 0; (g_499.f0 <= 0); g_499.f0 += 1)
        { /* block id: 307 */
            struct S1 l_617 = {0xBA93L,0x1.7p+1,0x0.Ep-1,4294967295UL,-1L,0x7AB8L};
            uint32_t l_639 = 0UL;
            struct S1 **l_642 = &g_136;
            struct S0 **l_660 = &g_527;
            const int32_t *l_693 = (void*)0;
            int32_t *l_700 = (void*)0;
            int16_t l_701 = 0xA9D4L;
            l_617 = l_617;
            for (g_161.f3 = 0; (g_161.f3 <= 0); g_161.f3 += 1)
            { /* block id: 311 */
                int32_t l_620 = 0x7C812C65L;
                p_10 = (**l_509);
                if ((g_161.f2 & (((~(-(int32_t)0x603C42A6L)) & p_10.f4) >= l_620)))
                { /* block id: 313 */
                    return g_161.f2;
                    /* statement id: 314 */
                    //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                    //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                }
                else
                { /* block id: 315 */
                    int32_t l_621 = 0xF54EFDE7L;
                    for (g_161.f4 = 0; (g_161.f4 <= 0); g_161.f4 += 1)
                    { /* block id: 318 */
                        return p_10.f2;
                        /* statement id: 319 */
                        //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                        //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                    }
                    if (l_621)
                    { /* block id: 321 */
                        const uint32_t l_631 = 0xA60A37B8L;
                        int32_t *l_632[8] = {(void*)0,(void*)0,&l_557,(void*)0,(void*)0,&l_557,(void*)0,(void*)0};
                        int i;
                        l_557 = ((int16_t)(g_458[2].f4 > p_10.f1) >> (int16_t)(((int32_t)((((((g_129[3].f0 == ((((uint16_t)1UL << (uint16_t)6) || g_129[3].f3) , ((65535UL <= (p_8 < (g_129[3].f1 <= (((int16_t)g_458[2].f4 >> (int16_t)p_10.f0) , 0x95A6L)))) <= g_161.f3))) && 0L) && 9L) || g_630) , 0x2B4BL) & p_10.f2) % (int32_t)l_631) != 1L));
                        return p_10.f0;
                        /* statement id: 323 */
                        //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                        //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                    }
                    else
                    { /* block id: 324 */
                        return l_620;
                        /* statement id: 325 */
                        //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
                        //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
                    }
                }
            }
            l_617 = l_617;
            if ((p_10.f3 , (((int32_t)(((int32_t)((func_53(l_617.f0, func_53(((((l_639 || ((uint16_t)(l_642 != (void*)0) << (uint16_t)(((uint16_t)((uint16_t)((((int16_t)(((int32_t)(l_534.f3 && (+((int32_t)((uint16_t)p_10.f2 << (uint16_t)1) / (int32_t)l_534.f3))) + (int32_t)(((func_53(((((int16_t)((uint32_t)g_161.f4 / (uint32_t)l_579[0]) << (int16_t)l_617.f3) >= 4294967295UL) , l_617.f4), p_10, p_10.f3, p_10.f3) , l_550) , p_10.f3) ^ (-5L))) || 0x93CE4832L) << (int16_t)g_630) , (void*)0) != l_660) + (uint16_t)0xB9C8L) / (uint16_t)l_534.f0) < p_8))) | 0xCF09L) || 0UL) > l_617.f0), (*g_527), g_499.f4, l_560.f3), g_95.f4, l_560.f4) , l_560.f5) || p_10.f2) - (int32_t)p_10.f3) & g_458[2].f0) - (int32_t)g_156) > l_617.f0)))
            { /* block id: 330 */
                int16_t l_668 = 1L;
                struct S1 l_671 = {0UL,0xE.C59C29p-49,0xF.1CD204p+35,0x2B3935B2L,1L,0xB6C9L};
                struct S1 *****l_685[10];
                int i;
                for (i = 0; i < 10; i = i + 1)
                    l_685[i] = &g_556;
                if (l_550)
                    goto lbl_661;
                if (((uint16_t)((((g_95.f3 ^ ((int16_t)g_95.f3 >> (int16_t)((((float)l_668 / (float)((((float)(g_212 != g_212) - (float)((l_671 , &l_509) != &g_526)) < (((float)(((((float)(((!(&l_671 == &l_617)) < g_129[3].f1) != 0x0.1p-1) - (float)p_9) >= 0xB.9A4990p+46) == l_617.f5) >= g_458[2].f0) / (float)p_10.f3) >= p_8)) <= p_10.f1)) , 1L) > (-5L)))) != 1L) || g_95.f3) & g_161.f3) / (uint16_t)2UL))
                { /* block id: 332 */
                    (**g_526) = (**l_660);
                }
                else
                { /* block id: 334 */
                    int32_t l_690 = 0L;
                    struct S1 l_694[1][9] = {{{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L},{0xA2B9L,0x0.85BC8Fp+88,-0x1.9p+1,4294967295UL,0x3482L,0x6B68L}}};
                    int32_t *l_696 = &g_36;
                    int i, j;
                    for (g_499.f5 = 0; (g_499.f5 <= 0); g_499.f5 += 1)
                    { /* block id: 337 */
                        const int32_t *l_691 = &l_557;
                        const int32_t **l_692[8] = {&l_691,&g_371[0][1],&l_691,&l_691,&g_371[0][1],&l_691,&l_691,&l_691};
                        int i;
                        l_690 = ((0L ^ ((uint16_t)1UL + (uint16_t)((((uint32_t)((int16_t)((((int16_t)((l_685[8] != (void*)0) <= (((l_550 == (((uint16_t)p_10.f1 / (uint16_t)(((uint16_t)(l_579[1] & (&l_534 != (void*)0)) >> (uint16_t)9) , p_10.f3)) < 7UL)) <= g_630) || 2UL)) << (int16_t)l_560.f3) > g_458[2].f0) == g_458[2].f0) - (int16_t)1UL) % (uint32_t)p_8) != 0x7D0A1252L) <= g_95.f5))) < l_550);
                        if (g_499.f5)
                            goto lbl_661;
                        l_693 = l_691;
                        /* statement id: 340 */
                        assert (l_693 == &l_557);
                    }
                    /* facts after for loop */
                    assert (l_693 == &l_557 || l_693 == 0);
                    for (g_630 = 0; (g_630 <= 0); g_630 += 1)
                    { /* block id: 344 */
                        struct S1 l_695 = {0UL,0x7.EEFAD9p-70,0x1.Ap-1,4294967295UL,0x506BL,5L};
                        if (p_8)
                            break;
                        l_695 = l_694[0][4];
                        (**g_237) = l_696;
                        /* statement id: 347 */
                        assert (g_46 == &g_36);
                    }
                }
                /* facts after branching */
                assert (l_693 == &l_557 || l_693 == 0);
            }
            else
            { /* block id: 350 */
                struct S1 l_698 = {0x3A25L,-0x3.1p-1,0x7.A2AF68p+29,1UL,0xDF8AL,0x2660L};
                (**g_237) = l_697;
                /* statement id: 351 */
                assert (g_46 == &l_557);
                l_698 = l_698;
            }
            /* facts after branching */
            assert (l_693 == &l_557 || l_693 == 0);
            for (l_534.f5 = 0; (l_534.f5 >= 0); l_534.f5 -= 1)
            { /* block id: 356 */
                struct S1 *****l_715 = &g_556;
                int32_t l_736[10][1] = {{0x1BDCE53FL},{0x954C56B6L},{0x1BDCE53FL},{0x1BDCE53FL},{0x954C56B6L},{0x1BDCE53FL},{0x1BDCE53FL},{0x954C56B6L},{0x1BDCE53FL},{0x1BDCE53FL}};
                int i, j;
                g_75 = ((!(((p_10.f3 , 0x9.2C3A6Cp-87) >= (((((((0L == 0xAD75109EL) >= (((((l_580 != ((&l_557 != l_700) , (l_617 , l_568[0][5][0]))) >= 0x215EL) , p_10.f1) , l_534.f0) >= l_701)) , (-0x8.5p+1)) >= l_534.f0) , (void*)0) != l_702) >= 0xB.7E120Ap-46)) <= 0x2.254E88p+65)) != 0x8.878E9Dp-93);
                for (p_10.f3 = 0; (p_10.f3 <= 0); p_10.f3 += 1)
                { /* block id: 360 */
                    const int32_t **l_719 = (void*)0;
                    struct S1 l_737 = {5UL,0x0.555B24p-6,-0x2.Ep-1,0x4A488011L,0x74F6L,-1L};
                    for (p_10.f4 = 0; (p_10.f4 <= 0); p_10.f4 += 1)
                    { /* block id: 363 */
                        struct S0 *l_712 = &g_458[2];
                        int32_t *l_720 = (void*)0;
                        const struct S1 *l_721 = &g_499;
                        const struct S1 **l_722 = &l_721;
                        int i, j, k;
                        (*l_697) = (+((int16_t)(((uint16_t)((uint32_t)(l_712 == (void*)0) + (uint32_t)g_161.f4) - (uint16_t)(&l_568[(l_534.f5 + 1)][(g_499.f0 + 5)][g_499.f0] == (*g_556))) | ((((int16_t)(*l_697) << (int16_t)1) , l_715) == l_716)) - (int16_t)((((uint16_t)(&g_212 != (void*)0) << (uint16_t)0) , l_719) != (*g_237))));
                        (**g_237) = l_720;
                        /* statement id: 365 */
                        assert (g_46 == 0);
                        (*l_722) = l_721;
                    }
                    (*l_697) = ((~(p_10.f4 >= ((*g_556) != (((int16_t)((uint16_t)((((p_10.f2 == g_12) | (p_10.f1 ^ ((uint16_t)(((int16_t)((uint16_t)((int32_t)l_534.f0 - (int32_t)(((8L < g_161.f1) , (*l_697)) || l_557)) / (uint16_t)0x4AE5L) >> (int16_t)14) | 0x80FC6764L) % (uint16_t)p_8))) || l_579[1]) <= l_736[4][0]) >> (uint16_t)g_458[2].f4) >> (int16_t)7) , (**l_715))))) > 2UL);
                    g_95 = ((g_458[2].f0 >= ((p_10.f2 <= l_736[4][0]) < p_10.f4)) , l_737);
                    (**g_237) = (**g_237);
                }
            }
        }
        l_557 = (l_697 == (((uint32_t)(((&l_697 == l_740) ^ ((((uint16_t)((*l_697) || (((int16_t)(p_10.f4 , (((l_745 , &l_703) == l_746) , g_458[2].f3)) << (int16_t)0) < (*l_697))) - (uint16_t)p_8) <= (*l_697)) != 0x9EBBL)) && l_747) + (uint32_t)p_10.f4) , (void*)0));
    }
    else
    { /* block id: 375 */
        float l_752 = 0x0.Dp+1;
        int32_t l_754 = (-8L);
        l_754 = ((float)(p_8 <= (!(p_10.f3 <= (((0x5.01C0D6p-45 >= ((+l_752) < 0x0.Cp+1)) >= 0x2.Cp+1) == ((g_129[3].f3 < (+(&l_509 != (void*)0))) < 0x9.6p-1))))) / (float)p_10.f0);
    }
    /* facts after branching */
    assert (g_46 == &l_557 || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
    assert (g_527 == &p_10 || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
    //assert (g_555 == &g_556 || g_555 == dangling);
    return p_8;
    /* statement id: 378 */
    //assert (g_46 == dangling || g_46 == &g_156 || g_46 == 0 || g_46 == &g_36);
    //assert (g_527 == dangling || (g_527 >= &g_458[0] && g_527 <= &g_458[5]));
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_129.f1 g_161.f0 g_161 g_95.f5 g_129
 * writes: g_135 g_95.f5 g_161.f4 g_156
 */
static struct S0  func_14(int32_t  p_15)
{ /* block id: 170 */
    uint32_t l_393[1];
    struct S1 ***l_399 = &g_135;
    uint32_t l_410 = 0xAE6BA4F4L;
    int32_t *l_412[7][4] = {{&g_156,(void*)0,&g_156,&g_156},{&g_156,&g_156,&g_156,&g_156},{&g_156,&g_36,&g_156,&g_156},{&g_156,&g_156,&g_156,&g_156},{(void*)0,&g_156,&g_156,&g_156},{&g_156,&g_36,&g_36,&g_156},{&g_156,&g_156,&g_36,&g_156}};
    struct S1 l_413[2] = {{0x494CL,0x5.7p-1,-0x1.5p-1,9UL,-1L,6L},{0x494CL,0x5.7p-1,-0x1.5p-1,9UL,-1L,6L}};
    uint16_t l_443 = 65535UL;
    uint32_t l_492 = 0x59095C9FL;
    int i, j;
    for (i = 0; i < 1; i = i + 1)
        l_393[i] = 0xC97DFEB3L;
    if ((p_15 >= ((uint32_t)((uint16_t)((int16_t)(((((uint16_t)((uint16_t)0x08D4L % (uint16_t)p_15) - (uint16_t)(((int32_t)p_15 % (int32_t)l_393[0]) ^ ((+((((int16_t)((uint32_t)((p_15 ^ (g_12 <= (l_399 != (((int16_t)(((((uint32_t)((uint16_t)(((float)((float)p_15 / (float)l_393[0]) + (float)0xC.12418Ap+63) , g_129[3].f1) >> (uint16_t)11) + (uint32_t)p_15) , p_15) > p_15) != p_15) / (int16_t)l_410) , &g_135)))) == p_15) % (uint32_t)p_15) - (int16_t)p_15) <= g_12) > p_15)) == l_393[0]))) ^ g_161.f0) ^ l_410) < l_410) / (int16_t)0x635DL) >> (uint16_t)l_393[0]) % (uint32_t)l_393[0])))
    { /* block id: 171 */
        (*l_399) = (void*)0;
        /* statement id: 172 */
        assert (g_135 == 0);
        return g_161;
    }
    else
    { /* block id: 174 */
        int32_t *l_411 = &g_36;
        l_412[1][2] = l_411;
    }
    l_413[1] = l_413[1];
    for (g_95.f5 = 0; (g_95.f5 <= 0); g_95.f5 += 1)
    { /* block id: 180 */
        int32_t **l_414 = &g_46;
        int32_t l_420 = (-2L);
        int32_t l_456 = 0xBD3278CBL;
        struct S0 l_459 = {4294967294UL,0x3BBF8FDAL,0xD2AD0458L,65535UL,0UL};
        struct S1 l_497[2] = {{1UL,0x7.Bp+1,-0x6.Cp+1,1UL,0x08BCL,-1L},{1UL,0x7.Bp+1,-0x6.Cp+1,1UL,0x08BCL,-1L}};
        int i;
        for (g_161.f4 = 0; (g_161.f4 <= 0); g_161.f4 += 1)
        { /* block id: 183 */
            g_156 = p_15;
        }
    }
    return g_129[2];
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_45 g_12 g_75 g_95.f5 g_95.f3 g_95.f4 g_95.f0 g_46 g_129 g_134 g_135 g_136 g_161.f3 g_161.f4 g_161.f0 g_212 g_95 g_237 g_161.f2 g_156 g_161.f1 g_371 g_161
 * writes: g_75 g_95 g_46 g_156 g_161 g_36 g_136 g_237 g_371
 */
static int16_t  func_18(const int16_t  p_19)
{ /* block id: 1 */
    int32_t *l_35 = &g_36;
    int32_t **l_37 = &l_35;
    struct S1 l_44 = {0xD3FDL,0xA.538E0Ep+88,0x1.Ep-1,4294967295UL,0x53AAL,0xB223L};
    int32_t **l_52[7];
    struct S0 l_172 = {0x1187F988L,1UL,0x89940662L,0UL,4294967293UL};
    const float *l_215 = &g_75;
    const float **l_214 = &l_215;
    struct S0 *l_267 = &g_161;
    int32_t ****l_310 = &g_237;
    uint16_t l_330[5][2] = {{0xF526L,0x3E91L},{0xF526L,0xF526L},{0x3E91L,0xF526L},{0xF526L,0x3E91L},{0xF526L,0xF526L}};
    struct S0 **l_375[7] = {(void*)0,&l_267,(void*)0,(void*)0,&l_267,(void*)0,(void*)0};
    int i, j;
    for (i = 0; i < 7; i = i + 1)
        l_52[i] = (void*)0;
lbl_380:
    (*l_37) = l_35;
    if ((((func_38(l_44, (*l_35), p_19, (g_36 , g_45), (func_47(l_52[1], func_53(p_19, (func_58(l_44) , g_129[3]), p_19, p_19), p_19, (*l_37)) , 0L)) , l_172) , 0xE489L) < p_19))
    { /* block id: 61 */
        uint32_t l_184 = 0UL;
        const struct S0 *l_199 = &g_129[2];
        int16_t l_233 = 0x36F0L;
        int32_t ***l_235 = &g_45;
        uint32_t l_249[2][5] = {{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x4C1EA071L,18446744073709551615UL,0x4C1EA071L,0x4C1EA071L,18446744073709551615UL}};
        struct S1 *l_272 = &l_44;
        const struct S0 l_329[10] = {{0x8E064FD8L,0xA1BAFF7DL,0xAAD0FF3DL,0xD6F5L,0xA4694767L},{0xDB987CA8L,0UL,6UL,1UL,0x679F912CL},{0xDB987CA8L,0UL,6UL,1UL,0x679F912CL},{0x8E064FD8L,0xA1BAFF7DL,0xAAD0FF3DL,0xD6F5L,0xA4694767L},{0xDB987CA8L,0UL,6UL,1UL,0x679F912CL},{0xDB987CA8L,0UL,6UL,1UL,0x679F912CL},{0x8E064FD8L,0xA1BAFF7DL,0xAAD0FF3DL,0xD6F5L,0xA4694767L},{0xDB987CA8L,0UL,6UL,1UL,0x679F912CL},{0xDB987CA8L,0UL,6UL,1UL,0x679F912CL},{0x8E064FD8L,0xA1BAFF7DL,0xAAD0FF3DL,0xD6F5L,0xA4694767L}};
        float ***l_331 = (void*)0;
        int i, j;
lbl_240:
        (*l_35) = ((int32_t)0xC3766656L - (int32_t)(((uint32_t)(((((int16_t)((&g_45 == &g_45) >= (((int32_t)(((4294967287UL | (&l_44 != (p_19 , &l_44))) >= (~(-10L))) , ((((uint16_t)p_19 << (uint16_t)g_129[3].f0) != p_19) | 0x604DL)) / (int32_t)l_184) != p_19)) >> (int16_t)g_129[3].f2) < 0xDAB54255L) | l_184) > p_19) / (uint32_t)p_19) ^ 0x0A6EL));
        (**l_37) = 3L;
        if (((uint16_t)((((((((uint16_t)(((((uint16_t)l_184 * (uint16_t)((((((((int32_t)((uint16_t)((uint16_t)(p_19 ^ l_184) + (uint16_t)(((((int16_t)((void*)0 == l_199) << (int16_t)((((((int16_t)(p_19 , (-7L)) >> (int16_t)((int16_t)g_161.f4 >> (int16_t)(((int32_t)p_19 + (int32_t)4294967291UL) && (-1L)))) > g_129[3].f0) , 1UL) != g_95.f3) >= g_129[3].f2)) < p_19) < 0UL) , l_184)) >> (uint16_t)2) / (int32_t)g_36) & l_184) <= 5UL) | 0x40BEL) >= l_184) , p_19) == g_161.f4)) != p_19) | p_19) || g_95.f3) >> (uint16_t)g_129[3].f0) >= 0x27CE996AL) > p_19) && g_129[3].f1) | 2UL) < p_19) && g_161.f0) + (uint16_t)0xF483L))
        { /* block id: 64 */
            struct S1 *l_208 = &g_95;
            uint32_t l_234 = 0x70BC1345L;
            int32_t ****l_246 = &g_237;
            float **l_254 = (void*)0;
            if (((uint32_t)0xAAB16F6DL - (uint32_t)(&g_129[3] != &g_161)))
            { /* block id: 65 */
                const float ***l_213[7];
                struct S1 l_223 = {65533UL,0x0.1p-1,0x3.737F3Dp-20,0xF1D640A9L,7L,1L};
                int i;
                for (i = 0; i < 7; i = i + 1)
                    l_213[i] = &g_212;
                (*g_135) = l_208;
                for (l_184 = 0; (l_184 != 42); l_184 += 6)
                { /* block id: 69 */
                    uint32_t l_211 = 0x27660C2BL;
                    return l_211;
                }
                l_214 = g_212;
                /* statement id: 72 */
                assert (l_214 == 0);
                if (((+(((-(float)(((((((float)((float)((+(l_184 <= p_19)) != (l_223 , (((float)(func_53(((int16_t)l_184 << (int16_t)((uint32_t)0x9169658BL / (uint32_t)(((p_19 , ((0x58BBB98BL != ((((uint16_t)((~p_19) , ((((func_53(((p_19 ^ p_19) & p_19), (*l_199), l_223.f0, g_129[3].f2) , 0UL) != 0xB4EDL) >= 0UL) | p_19)) >> (uint16_t)g_129[3].f4) == g_129[3].f4) != 4294967287UL)) , p_19)) <= 7L) & 0xB0487F14L))), l_172, (**l_37), (**l_37)) , l_233) - (float)g_161.f4) < 0x9.2B0FFDp+95))) + (float)l_234) + (float)0x8.795148p+64) <= 0xB.25AF46p+52) != p_19) <= (-0x5.7p-1)) == l_233) > 0x0.Bp+1)) == p_19) <= (-0x1.5p+1))) , 0x547ADA87L))
                { /* block id: 73 */
                    int32_t ****l_236[2][5][10] = {{{&l_235,(void*)0,(void*)0,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235},{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235},{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,(void*)0,&l_235,&l_235,&l_235},{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,(void*)0,&l_235},{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235}},{{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235},{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235},{(void*)0,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235},{&l_235,&l_235,(void*)0,(void*)0,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235},{&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235,&l_235}}};
                    int i, j, k;
                    g_237 = l_235;
                    (*l_37) = (**l_235);
                    /* statement id: 75 */
                    assert (l_35 == 0);
                }
                else
                { /* block id: 76 */
                    return p_19;
                }
                /* facts after branching */
                assert (l_35 == 0);
            }
            else
            { /* block id: 79 */
                uint32_t l_245 = 0x5CF70B33L;
                int32_t *l_266 = &g_36;
                for (l_44.f5 = 1; (l_44.f5 >= 8); l_44.f5 += 1)
                { /* block id: 82 */
                    if (g_161.f3)
                        goto lbl_240;
                    (*l_208) = ((9L && (((float)((float)(p_19 == (l_245 < (0x1.46FBA3p+98 != (g_95.f0 , (((((g_129[3] , (&g_237 == l_246)) <= (((((((float)p_19 - (float)p_19) <= p_19) >= p_19) < (**l_37)) < l_245) >= p_19)) < (-0x10.Ep+1)) , 0x7.D82FD8p+9) > 0x8.02C535p+40))))) / (float)p_19) / (float)l_245) , 2UL)) , (*l_208));
                }
                if ((l_249[1][4] ^ 4L))
                { /* block id: 86 */
                    int32_t l_261 = 0x7D7F6A1AL;
                    struct S0 l_269 = {0x99C83E0CL,0x4391B956L,4294967295UL,0UL,4294967295UL};
                    (**g_237) = (*g_45);
                    if (((*l_35) == ((int16_t)((((uint16_t)(l_254 != (void*)0) >> (uint16_t)5) , ((int16_t)(((int16_t)1L >> (int16_t)7) & ((((float)(l_261 == ((float)(0x1.820917p-59 <= (((float)p_19 - (float)((void*)0 == (**g_237))) != p_19)) + (float)0x0.7p-1)) + (float)0x3.B4B55Fp-78) , &l_254) != &g_212)) << (int16_t)l_261)) < p_19) >> (int16_t)g_95.f0)))
                    { /* block id: 88 */
                        (**g_237) = l_266;
                        /* statement id: 89 */
                        assert (g_46 == &g_36);
                    }
                    else
                    { /* block id: 90 */
                        struct S0 **l_268 = &l_267;
                        (*l_268) = l_267;
                        (*l_267) = l_269;
                    }
                    /* facts after branching */
                    assert (g_46 == 0 || g_46 == &g_36);
                    (*l_267) = g_129[3];
                }
                else
                { /* block id: 95 */
                    for (l_245 = (-3); (l_245 != (-3)); l_245 += 5)
                    { /* block id: 98 */
                        return g_129[3].f3;
                    }
                }
                /* facts after branching */
                assert (g_46 == 0 || g_46 == &g_36);
                (**g_237) = (***l_246);
            }
            /* facts after branching */
            assert (l_35 == &g_36 || l_35 == 0);
            assert (g_46 == 0 || g_46 == &g_36);
            assert (l_214 == &l_215 || l_214 == 0);
        }
        else
        { /* block id: 104 */
            const struct S0 l_313 = {0x56D97829L,0xDDACF115L,0xCBFC918AL,0xD33FL,1UL};
            uint32_t l_314[3][8][6] = {{{1UL,0x0607C4CDL,0x5C24B93AL,0UL,4294967288UL,0x602C2478L},{8UL,0x16749064L,0x0387FDDEL,0UL,0UL,4294967295UL},{0UL,0x16749064L,0xF1A482D9L,5UL,0xF49DBCD6L,0x291E4BA6L},{4294967288UL,0xC39E34AFL,0xFBF50513L,0x7536035EL,0x0607C4CDL,0UL},{0xE762944AL,0xFE5A6F23L,0x0387FDDEL,0UL,4UL,4294967294UL},{4294967288UL,0UL,1UL,0x6AB84D60L,4294967295UL,5UL},{0x28839783L,0xF49DBCD6L,0x2F77C82EL,0xF49DBCD6L,0x28839783L,0xA1123219L},{4294967295UL,0x2F77C82EL,4294967288UL,4294967294UL,4294967295UL,0x3AF94921L}},{{0x6AB84D60L,0xF17528EBL,0x46E22EB2L,0x2F77C82EL,0xF1E0DD79L,0x3AF94921L},{0x3AF94921L,4294967288UL,4294967288UL,0xFBF50513L,0xF1A482D9L,0xA1123219L},{0xF1E0DD79L,4294967293UL,0x2F77C82EL,0x7DD56023L,0xFE5A6F23L,5UL},{1UL,0x9404D511L,1UL,4294967289UL,4294967293UL,4294967294UL},{0UL,0x28839783L,0x0387FDDEL,0xC6C6E6C7L,4294967295UL,0UL},{4294967289UL,0UL,0xFBF50513L,0xE762944AL,0x0FD3A3C4L,0x291E4BA6L},{4294967294UL,0UL,0xF1A482D9L,0xF17528EBL,0x466D3CF2L,4294967295UL},{0UL,0x7CEC86A8L,0xC39E34AFL,0x0387FDDEL,0x202F784CL,0x202F784CL}},{{4294967293UL,1UL,1UL,4294967293UL,0xFBF50513L,0UL},{4UL,4294967295UL,4294967295UL,0x202F784CL,4294967288UL,0x2F77C82EL},{4294967286UL,4294967288UL,0xC6C6E6C7L,1UL,4294967288UL,0x82215A0CL},{0x7536035EL,4294967295UL,0x291E4BA6L,0x9404D511L,0xFBF50513L,4294967289UL},{0x181019B4L,1UL,0UL,0xA1123219L,0x202F784CL,0xE762944AL},{4294967295UL,0x7CEC86A8L,4294967293UL,0xFE5A6F23L,0x466D3CF2L,0x28839783L},{4294967295UL,0UL,1UL,0x05D4DD67L,0x0FD3A3C4L,4294967293UL},{0x9404D511L,0UL,0x7DD56023L,0UL,4294967295UL,0xF1A482D9L}}};
            int32_t ****l_328 = &g_237;
            float *l_334 = (void*)0;
            float **l_333 = &l_334;
            float ***l_332 = &l_333;
            int i, j, k;
            for (l_172.f3 = 0; (l_172.f3 <= 1); l_172.f3 += 1)
            { /* block id: 107 */
                (**g_134) = l_272;
                /* statement id: 108 */
                assert (g_136 == &l_44);
                return l_249[1][4];
                /* statement id: 109 */
                //assert (g_136 == dangling);
            }
            (**l_235) = (**l_235);
            for (g_95.f5 = 1; (g_95.f5 >= 0); g_95.f5 -= 1)
            { /* block id: 114 */
                int32_t l_282 = (-9L);
                int32_t **l_338 = &g_46;
                int32_t l_339 = 0xCE8F852FL;
                struct S1 l_342[6] = {{65535UL,-0x2.Ap-1,0x8.0p-1,1UL,-3L,-4L},{65535UL,-0x2.Ap-1,0x8.0p-1,1UL,-3L,-4L},{65535UL,-0x2.Ap-1,0x8.0p-1,1UL,-3L,-4L},{65535UL,-0x2.Ap-1,0x8.0p-1,1UL,-3L,-4L},{65535UL,-0x2.Ap-1,0x8.0p-1,1UL,-3L,-4L},{65535UL,-0x2.Ap-1,0x8.0p-1,1UL,-3L,-4L}};
                int i;
                for (l_172.f3 = 2; (l_172.f3 <= 6); l_172.f3 += 1)
                { /* block id: 117 */
                    int i, j;
                    for (l_44.f4 = 6; (l_44.f4 >= 0); l_44.f4 -= 1)
                    { /* block id: 120 */
                        float *l_273 = &g_95.f1;
                        int i, j;
                        (*l_273) = l_249[g_95.f5][(g_95.f5 + 1)];
                    }
                    (**g_237) = (l_249[g_95.f5][(g_95.f5 + 1)] , ((((void*)0 == &g_212) || (l_249[g_95.f5][(g_95.f5 + 1)] && ((l_199 != l_199) && ((((uint16_t)g_95.f5 << (uint16_t)((uint16_t)65535UL << (uint16_t)1)) || (((((((uint16_t)((uint32_t)0x370A0293L - (uint32_t)(*l_35)) << (uint16_t)2) | 4294967295UL) ^ g_161.f2) == 4UL) , l_282) > 8L)) & 0xA288L)))) , &l_282));
                    /* statement id: 123 */
                    assert (g_46 == &l_282);
                    if ((((int16_t)((***l_235) && ((int32_t)(*g_46) / (int32_t)((int16_t)((int32_t)((((uint32_t)((***g_237) == ((***l_235) ^ (*l_35))) - (uint32_t)((0x9A76L ^ g_12) | ((g_95.f5 , g_36) != p_19))) && g_129[3].f1) == p_19) / (int32_t)(*g_46)) << (int16_t)g_161.f3))) << (int16_t)p_19) || (**l_37)))
                    { /* block id: 124 */
                        const uint16_t l_317 = 0x6B85L;
                        (***l_235) = ((*g_46) >= 0xA0A62E1FL);
                        (***g_237) = ((uint16_t)((uint32_t)((((((int32_t)(((int16_t)(p_19 | p_19) - (int16_t)(+(((((4294967295UL ^ p_19) || (((int16_t)(((int16_t)((uint32_t)(func_53(g_129[3].f4, func_53((((((int32_t)((void*)0 != l_310) / (int32_t)((int16_t)g_12 >> (int16_t)13)) , (l_313 , p_19)) != l_313.f3) ^ 0x0FEC2A3CL), g_129[1], p_19, p_19), l_314[2][4][0], p_19) , p_19) - (uint32_t)g_129[3].f1) % (int16_t)g_156) > 1L) << (int16_t)p_19) >= l_282)) > g_161.f4) , 4294967295UL) < (***l_235)))) == 0x151D6254L) / (int32_t)(**g_45)) & l_282) < 0x29DA96A5L) , 0x0BEEL) ^ g_156) - (uint32_t)l_314[2][4][0]) << (uint16_t)g_161.f3);
                        (*l_267) = func_53(((((float)l_317 / (float)((float)(p_19 != (-0x7.6p-1)) + (float)0xF.FB379Cp-28)) , ((int16_t)((int32_t)((((void*)0 == &g_134) | (((((float)((***l_235) == ((float)(func_53((l_310 == l_328), (*l_199), p_19, g_161.f1) , (****l_328)) / (float)p_19)) - (float)0x1.7p+1) <= 0x1.0p+1) , (**g_45)) & 1L)) && (***l_235)) / (int32_t)(***g_237)) << (int16_t)l_282)) | g_161.f3), l_329[4], l_330[0][1], g_161.f3);
                        if ((***g_237))
                            continue;
                    }
                    else
                    { /* block id: 129 */
                        if (p_19)
                            break;
                        g_95.f1 = ((l_331 == l_332) > p_19);
                    }
                    (*g_45) = (((~g_161.f3) ^ ((int32_t)(0xE1AAF17BL || ((void*)0 != l_338)) - (int32_t)p_19)) , (**l_235));
                }
                /* facts after for loop */
                assert (g_46 == &l_282 || g_46 == &g_156 || g_46 == 0);
                (*l_338) = (void*)0;
                /* statement id: 135 */
                assert (g_46 == 0);
                for (g_161.f2 = 0; (g_161.f2 <= 1); g_161.f2 += 1)
                { /* block id: 138 */
                    float **l_351 = &l_334;
                    for (g_36 = 0; (g_36 <= 1); g_36 += 1)
                    { /* block id: 141 */
                        int32_t *l_352 = &g_156;
                        int i, j;
                        if (l_249[g_161.f2][(g_161.f2 + 2)])
                            break;
                        (***l_328) = (**g_237);
                        (**g_237) = ((l_339 <= (0xC.D94D4Fp+67 > ((((l_342[2] , g_95.f3) >= (((uint16_t)((uint32_t)((int32_t)(g_161.f2 >= (p_19 == ((int32_t)(((void*)0 == (***l_310)) , ((l_351 == g_212) == 65535UL)) + (int32_t)p_19))) + (int32_t)0x90D7AD23L) - (uint32_t)1UL) << (uint16_t)15) <= p_19)) ^ 1L) , 0x1.Fp+1))) , l_352);
                        /* statement id: 144 */
                        assert (g_46 == &g_156);
                        (****l_328) = ((float)(&g_237 == l_328) / (float)0xC.51541Bp-85);
                    }
                }
                /* facts after for loop */
                assert (g_46 == &g_156 || g_46 == 0);
                for (g_161.f1 = 0; (g_161.f1 <= 1); g_161.f1 += 1)
                { /* block id: 150 */
                    float **l_370 = &l_334;
                    if (((uint16_t)(g_129[3].f3 ^ ((int32_t)p_19 - (int32_t)(~(-(uint32_t)p_19)))) - (uint16_t)((!((uint16_t)((uint32_t)(((int16_t)p_19 >> (int16_t)((uint16_t)((((((void*)0 != l_370) ^ (0xC4EFA5E1L && (p_19 , (p_19 , p_19)))) != p_19) & g_95.f0) , p_19) - (uint16_t)p_19)) ^ g_36) / (uint32_t)p_19) - (uint16_t)3UL)) | g_95.f5)))
                    { /* block id: 151 */
                        const int32_t **l_372 = &g_371[3][2];
                        (*l_372) = g_371[6][1];
                        if (p_19)
                            continue;
                        if (p_19)
                            break;
                    }
                    else
                    { /* block id: 155 */
                        (*l_35) = 3L;
                        if (l_249[1][0])
                            break;
                        (*l_272) = l_342[2];
                    }
                }
            }
            /* facts after for loop */
            assert (g_46 == &g_156 || g_46 == 0);
            return g_95.f3;
        }
        /* facts after branching */
        assert (l_35 == &g_36 || l_35 == 0);
        assert (g_46 == 0 || g_46 == &g_36);
        assert (l_214 == &l_215 || l_214 == 0);
        g_95.f2 = (((float)((void*)0 == l_375[2]) + (float)(0x0.1p-1 < ((float)((float)((*l_267) , p_19) / (float)(p_19 == ((-0x8.Ep+1) >= ((g_95.f5 > p_19) , p_19)))) - (float)g_129[3].f3))) < g_129[3].f1);
    }
    else
    { /* block id: 165 */
        if (l_172.f4)
            goto lbl_380;
    }
    /* facts after branching */
    assert (l_35 == &g_36 || l_35 == 0);
    assert (g_46 == 0 || g_46 == &g_36);
    assert (l_214 == &l_215 || l_214 == 0);
    (**g_237) = (*g_45);
    return g_161.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_129 g_161.f3 g_135 g_136
 * writes: g_161 g_95.f1 g_95
 */
static uint16_t  func_38(struct S1  p_39, uint16_t  p_40, uint16_t  p_41, int32_t ** p_42, int16_t  p_43)
{ /* block id: 52 */
    int32_t l_159 = 0x3E6B62B2L;
    if (l_159)
    { /* block id: 53 */
        struct S0 *l_160 = &g_161;
        float *l_169 = &g_95.f1;
        (*l_160) = g_129[3];
        (*l_169) = ((float)(-(float)((float)l_159 - (float)g_161.f3)) + (float)((float)((void*)0 == l_160) - (float)l_159));
    }
    else
    { /* block id: 56 */
        int32_t ***l_171[2];
        int32_t ****l_170 = &l_171[1];
        int i;
        for (i = 0; i < 2; i = i + 1)
            l_171[i] = &g_45;
        (*l_170) = &p_42;
        /* statement id: 57 */
        //assert (l_171[0] == &p_42 || l_171[0] == &g_45);
    }
    (**g_135) = p_39;
    return l_159;
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_134 g_135 g_136 g_36 g_129.f4 g_129.f3
 * writes: g_46 g_156
 */
static float  func_47(int32_t ** p_48, struct S0  p_49, int32_t  p_50, int32_t * p_51)
{ /* block id: 46 */
    int32_t *l_133 = (void*)0;
    struct S1 ***l_137[5][1][2] = {{{&g_135,&g_135}},{{&g_135,&g_135}},{{&g_135,&g_135}},{{&g_135,&g_135}},{{&g_135,&g_135}}};
    uint32_t l_138 = 0UL;
    float l_151 = 0x9.8804D5p-41;
    int32_t *l_152 = (void*)0;
    int32_t *l_153 = (void*)0;
    int32_t *l_154 = (void*)0;
    int32_t *l_155 = &g_156;
    struct S0 l_157 = {4294967295UL,6UL,1UL,65535UL,0x56614784L};
    struct S0 *l_158 = &l_157;
    int i, j, k;
    (*g_45) = l_133;
    /* statement id: 47 */
    assert (g_46 == 0);
    (*l_155) = ((((p_49.f4 != (g_134 != l_137[4][0][0])) >= l_138) , p_49.f2) > (~((uint16_t)(((uint32_t)(((int16_t)((void*)0 != (*g_134)) << (int16_t)(((int16_t)(0x123B5FEBL || (!((**g_134) == (**g_134)))) - (int16_t)(-1L)) && p_49.f1)) > (*p_51)) - (uint32_t)g_129[3].f4) && p_49.f1) / (uint16_t)p_49.f0)));
    (*l_158) = l_157;
    (*l_158) = (*l_158);
    return g_129[3].f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_53(const int16_t  p_54, const struct S0  p_55, uint32_t  p_56, uint32_t  p_57)
{ /* block id: 39 */
    for (p_56 = 0; (p_56 == 39); p_56 += 1)
    { /* block id: 42 */
        struct S0 l_132 = {4294967295UL,0x237EC01DL,4294967295UL,0x8CECL,0xB3EE271DL};
        return l_132;
    }
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_12 g_75 g_95.f5 g_45 g_95.f3 g_95.f4 g_95.f0 g_46
 * writes: g_75 g_95 g_46
 */
static uint32_t  func_58(struct S1  p_59)
{ /* block id: 3 */
    int32_t *l_65 = &g_36;
    if (((uint16_t)((~g_36) || ((func_63(l_65) || p_59.f4) || 0x6189FD49L)) + (uint16_t)(l_65 == l_65)))
    { /* block id: 32 */
        struct S1 *l_124 = (void*)0;
        struct S1 **l_123 = &l_124;
        (*l_123) = &g_95;
        /* statement id: 33 */
        assert (l_124 == &g_95);
    }
    else
    { /* block id: 34 */
        struct S1 *l_127 = &g_95;
        struct S1 **l_126 = &l_127;
        struct S1 ***l_125 = &l_126;
        struct S1 ****l_128 = &l_125;
        (*l_128) = l_125;
        return g_95.f5;
    }
    /* facts after branching */
    //assert (g_46 == dangling || g_46 == 0);
    return g_12;
}


/* ------------------------------------------ */
/* 
 * reads : g_12 g_36 g_75 g_95.f5 g_45 g_95.f3 g_95.f4 g_95.f0 g_46
 * writes: g_75 g_95 g_46
 */
static uint32_t  func_63(int32_t * p_64)
{ /* block id: 4 */
    uint16_t l_70 = 1UL;
    int32_t l_85[3][5][4] = {{{(-4L),0x910F8796L,(-1L),0xA2B3C28CL},{(-1L),0xA2B3C28CL,0x51B5D7ECL,0x51B5D7ECL},{0x33ED7856L,0x33ED7856L,0xEEF6617FL,1L},{(-1L),1L,(-2L),0xF2706978L},{(-1L),1L,5L,(-2L)}},{{0xA2B3C28CL,1L,0xF2DC1352L,0xF2706978L},{1L,1L,0x172C1376L,1L},{(-7L),0x33ED7856L,1L,0x51B5D7ECL},{0x207283BDL,0xA2B3C28CL,0xF2DC1352L,0xA2B3C28CL},{0L,0x910F8796L,(-7L),(-4L)}},{{(-1L),0L,0x3A9B92FDL,(-1L)},{(-1L),(-7L),(-1L),0x910F8796L},{(-1L),1L,0x3A9B92FDL,5L},{0L,0x910F8796L,3L,(-5L)},{0x51B5D7ECL,0x172C1376L,0xF2706978L,(-7L)}}};
    struct S0 l_91 = {0x53CB79D8L,0x571715C7L,4UL,0x42B8L,1UL};
    struct S1 l_94 = {0UL,0x6.DD5270p-86,0x1.5p+1,0x1B6A4893L,-2L,-8L};
    int i, j, k;
    if (((uint16_t)(g_12 != ((((((int16_t)g_12 % (int16_t)(((((((l_70 , (*p_64)) > ((l_70 && 0xC5DAL) < ((uint32_t)g_12 / (uint32_t)(~(1UL != ((((l_70 == (-9L)) == g_36) && g_36) || l_70)))))) & 0x33F2F191L) | l_70) , (-2L)) <= (*p_64)) & g_36)) , 0x8F1B1E9EL) == (*p_64)) & g_12) | 1UL)) - (uint16_t)0xDD74L))
    { /* block id: 5 */
        float *l_74 = &g_75;
        int32_t l_90 = 0xC5A18187L;
        int32_t l_92 = 0x53D9B4DCL;
        uint32_t l_93 = 0x596026DFL;
        int32_t *l_98 = (void*)0;
        int32_t *l_99 = &l_85[0][4][0];
        (*l_74) = 0x2.Fp+1;
        if (((int16_t)(((0x0.Fp-1 < (+((float)(((((float)((float)l_85[0][4][0] - (float)((g_75 >= ((float)((float)(l_70 != l_90) / (float)0x9.Fp-1) - (float)(l_85[1][1][1] != l_70))) != (l_91 , l_92))) + (float)g_36) >= 0x8.B00F8Cp-64) > l_92) == g_36) / (float)l_91.f3))) , l_91.f0) | l_93) / (int16_t)0xCE27L))
        { /* block id: 7 */
            g_95 = l_94;
        }
        else
        { /* block id: 9 */
            struct S1 l_96 = {0x8DA2L,0xB.51ED01p-56,0x3.318276p+8,1UL,-10L,0L};
            struct S1 *l_97 = &g_95;
            (*l_97) = l_96;
        }
        (*l_99) = (g_36 < l_94.f0);
    }
    else
    { /* block id: 13 */
        struct S1 *l_100 = &l_94;
        int32_t l_109[4] = {4L,4L,4L,4L};
        int i;
        if (((l_100 != &l_94) , ((uint16_t)(~((int16_t)((uint16_t)g_36 << (uint16_t)15) << (int16_t)(!g_95.f5))) + (uint16_t)l_109[2])))
        { /* block id: 14 */
            for (l_91.f4 = 0; (l_91.f4 == 1); l_91.f4 += 1)
            { /* block id: 17 */
                (*g_45) = &l_109[2];
                /* statement id: 18 */
                assert ((g_46 >= &l_109[0] && g_46 <= &l_109[3]));
            }
            /* facts after for loop */
            assert ((g_46 >= &l_109[0] && g_46 <= &l_109[3]) || g_46 == 0);
            for (l_91.f2 = 0; (l_91.f2 < 23); l_91.f2 += 1)
            { /* block id: 22 */
                int16_t l_122[5];
                int i;
                for (i = 0; i < 5; i = i + 1)
                    l_122[i] = 0x377CL;
                l_122[4] = (g_95.f3 ^ ((l_100 != (void*)0) < ((int16_t)(-(uint16_t)((((int16_t)((-(uint16_t)((int16_t)(-1L) + (int16_t)l_109[2])) || (g_95.f4 > g_95.f0)) >> (int16_t)7) && (l_94.f3 , 0UL)) ^ l_91.f4)) >> (int16_t)3)));
            }
        }
        else
        { /* block id: 25 */
            return g_95.f0;
        }
        /* facts after branching */
        assert ((g_46 >= &l_109[0] && g_46 <= &l_109[3]) || g_46 == 0);
        for (l_94.f0 = 0; l_94.f0 < 3; l_94.f0 += 1)
        {
            for (l_70 = 0; l_70 < 5; l_70 += 1)
            {
                for (g_95.f0 = 0; g_95.f0 < 4; g_95.f0 += 1)
                {
                    l_85[l_94.f0][l_70][g_95.f0] = 3L;
                }
            }
        }
        (*g_45) = (*g_45);
    }
    /* facts after branching */
    //assert (g_46 == dangling || g_46 == 0);
    return l_70;
}




/* ---------------------------------------- */
int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc_bytes (&g_11, sizeof(g_11), "g_11", print_hash_value);
    transparent_crc(g_12, "g_12", print_hash_value);
    transparent_crc(g_36, "g_36", print_hash_value);
    transparent_crc_bytes (&g_75, sizeof(g_75), "g_75", print_hash_value);
    transparent_crc(g_95.f0, "g_95.f0", print_hash_value);
    transparent_crc_bytes (&g_95.f1, sizeof(g_95.f1), "g_95.f1", print_hash_value);
    transparent_crc_bytes (&g_95.f2, sizeof(g_95.f2), "g_95.f2", print_hash_value);
    transparent_crc(g_95.f3, "g_95.f3", print_hash_value);
    transparent_crc(g_95.f4, "g_95.f4", print_hash_value);
    transparent_crc(g_95.f5, "g_95.f5", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        transparent_crc(g_129[i].f0, "g_129[i].f0", print_hash_value);
        transparent_crc(g_129[i].f1, "g_129[i].f1", print_hash_value);
        transparent_crc(g_129[i].f2, "g_129[i].f2", print_hash_value);
        transparent_crc(g_129[i].f3, "g_129[i].f3", print_hash_value);
        transparent_crc(g_129[i].f4, "g_129[i].f4", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_156, "g_156", print_hash_value);
    transparent_crc(g_161.f0, "g_161.f0", print_hash_value);
    transparent_crc(g_161.f1, "g_161.f1", print_hash_value);
    transparent_crc(g_161.f2, "g_161.f2", print_hash_value);
    transparent_crc(g_161.f3, "g_161.f3", print_hash_value);
    transparent_crc(g_161.f4, "g_161.f4", print_hash_value);
    for (i = 0; i < 6; i = i + 1)
    {
        transparent_crc(g_458[i].f0, "g_458[i].f0", print_hash_value);
        transparent_crc(g_458[i].f1, "g_458[i].f1", print_hash_value);
        transparent_crc(g_458[i].f2, "g_458[i].f2", print_hash_value);
        transparent_crc(g_458[i].f3, "g_458[i].f3", print_hash_value);
        transparent_crc(g_458[i].f4, "g_458[i].f4", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_499.f0, "g_499.f0", print_hash_value);
    transparent_crc_bytes (&g_499.f1, sizeof(g_499.f1), "g_499.f1", print_hash_value);
    transparent_crc_bytes (&g_499.f2, sizeof(g_499.f2), "g_499.f2", print_hash_value);
    transparent_crc(g_499.f3, "g_499.f3", print_hash_value);
    transparent_crc(g_499.f4, "g_499.f4", print_hash_value);
    transparent_crc(g_499.f5, "g_499.f5", print_hash_value);
    transparent_crc(g_630, "g_630", print_hash_value);
    for (i = 0; i < 1; i = i + 1)
    {
        transparent_crc(g_784[i], "g_784[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 188
   depth: 1, occurrence: 47
XXX total union variables: 0

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 205
   depth: 2, occurrence: 39
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 4
   depth: 21, occurrence: 2
   depth: 22, occurrence: 4
   depth: 23, occurrence: 2
   depth: 25, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 37, occurrence: 2
   depth: 42, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 162

XXX times a variable address is taken: 290
XXX times a pointer is dereferenced on RHS: 116
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 38
   depth: 3, occurrence: 23
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 94
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 22
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 784

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 160
   level: 2, occurrence: 145
   level: 3, occurrence: 92
   level: 4, occurrence: 41
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 89
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 29
XXX percent of pointers has null in alias set: 29
XXX average alias set size: 1.33

XXX times a non-volatile is read: 1266
XXX times a non-volatile is write: 325
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 9

XXX stmts: 192
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 29
   depth: 2, occurrence: 19
   depth: 3, occurrence: 31
   depth: 4, occurrence: 36
   depth: 5, occurrence: 46

XXX percentage a fresh-made variable is used: 16.1
XXX percentage an existing variable is used: 83.9
********************* end of statistics **********************/

