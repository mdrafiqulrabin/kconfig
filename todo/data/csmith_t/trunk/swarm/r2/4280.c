/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      3432113268
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   float  f0;
   int16_t  f1;
   uint32_t  f2;
   int32_t  f3;
   int8_t  f4;
   uint32_t  f5;
   int8_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_5(int8_t  p_6, int32_t * p_7, uint32_t  p_8, int32_t * p_9, int32_t * p_10);
static int32_t * func_12(int16_t  p_13);
static uint16_t  func_22(uint16_t  p_23);
static int32_t  func_28(int32_t * p_29);
static struct S0  func_30(int32_t * p_31, int16_t  p_32);
static int32_t * func_49(int16_t  p_50);
static struct S0  func_62(uint32_t  p_63, uint32_t  p_64, float * p_65);
static int32_t  func_67(float * p_68, struct S0 * p_69, int32_t * p_70, struct S0 ** p_71, float * p_72);
static struct S0 * func_73(struct S0 * p_74, int32_t * p_75, struct S0 * p_76, int32_t * p_77);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = (-2);
    int32_t *l_349 = &l_2;
    int32_t **l_348 = &l_349;
    int32_t l_354 = 9;
    float l_356 = 0x1.Ap+1;
    float *l_355 = &l_356;
    uint32_t l_361 = 4294967288U;
    float l_370 = 0x1.4E809Fp+7;
    float **l_383 = &l_355;
    struct S0 *l_384 = (void*)0;
    int32_t l_387 = 0x9C8DF182;
    for (l_2 = 0; (l_2 == (-9)); l_2 -= 8)
    { /* block id: 3 */
        uint32_t l_11 = 4294967295U;
        int32_t *l_19 = (void*)0;
        int32_t **l_338 = &l_19;
        (*l_338) = func_5(l_11, func_12(((((uint16_t)((((uint32_t)(-(uint16_t)(&l_2 == l_19)) % (uint32_t)0xBEFA1E1C) || l_11) > ((uint16_t)func_22(l_2) << (uint16_t)((int16_t)l_2 % (int16_t)(1 || l_11)))) * (uint16_t)l_2) <= 0xCC3E4EA6) < 9U)), l_2, l_19, &l_2);
    }
    (*l_355) = (!((l_2 >= ((l_2 > l_2) >= ((float)((l_2 > ((float)(((float)((float)(l_348 != &l_349) - (float)(**l_348)) - (float)((float)((float)(-0x4.Cp-1) - (float)(*l_349)) * (float)0x6.8p-1)) <= 0x1.Ap+1) * (float)0x0.8p+1)) > (*l_349)) + (float)(*l_349)))) == l_354));
    for (l_2 = 14; (l_2 >= 25); l_2++)
    { /* block id: 209 */
        uint32_t l_366 = 0x0767012B;
        float *l_382 = &l_370;
        struct S0 l_386 = {0x1.Dp-1,0x0EC0,4U,3,0,0xBD3D5600,0x9F};
        struct S0 *l_385 = &l_386;
        for (l_354 = 0; (l_354 <= 8); l_354 += 6)
        { /* block id: 212 */
            int16_t l_367 = 0xF916;
            int32_t *l_371 = &l_2;
            struct S0 l_373 = {0x1.Fp-1,0xE5BD,6U,0x5D2DD311,-8,1U,0x3A};
            struct S0 *l_372 = &l_373;
        }
    }
    return l_387;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_5(int8_t  p_6, int32_t * p_7, uint32_t  p_8, int32_t * p_9, int32_t * p_10)
{ /* block id: 195 */
    int8_t l_326 = 1;
    struct S0 l_328 = {0xB.C01DDEp+21,0x243F,0x7FCD342D,0x6C6D6545,0x46,1U,-1};
    struct S0 *l_327 = &l_328;
    struct S0 **l_329 = &l_327;
    int32_t *l_335 = (void*)0;
    l_326 = (*p_10);
    (*l_329) = &l_328;
    if (((~l_328.f5) == ((int32_t)(((uint16_t)(((p_8 != 0x2117) && (l_328.f1 || (p_10 == p_10))) | (((void*)0 != l_335) | ((void*)0 == p_10))) % (uint16_t)0xEA9D) == 9U) - (int32_t)p_8)))
    { /* block id: 198 */
        int32_t *l_336 = &l_328.f3;
        int32_t **l_337 = &l_335;
        (*l_337) = l_336;
        return p_7;
    }
    else
    { /* block id: 201 */
        return l_335;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_12(int16_t  p_13)
{ /* block id: 192 */
    uint32_t l_322 = 4294967295U;
    float l_324 = 0x1.6p+1;
    float *l_323 = &l_324;
    int32_t *l_325 = (void*)0;
    (*l_323) = ((p_13 > (-0x6.7p-1)) > (l_322 <= (l_322 < p_13)));
    return l_325;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_22(uint16_t  p_23)
{ /* block id: 4 */
    float l_24 = 0x0.1p+1;
    int8_t l_25 = 0x53;
    int32_t l_27 = (-3);
    int32_t *l_26 = &l_27;
    float *l_245 = &l_24;
    struct S0 l_319 = {0x5.6p+1,4,9U,1,0x3D,4294967295U,4};
    struct S0 *l_318 = &l_319;
    (*l_26) = (l_25 > 0xDAB551FA);
    if (func_28(&l_27))
    { /* block id: 140 */
        struct S0 l_244 = {0x0.Ap+1,0x5ABD,4294967294U,-1,0,0xAAFD5ADA,9};
        l_244 = l_244;
    }
    else
    { /* block id: 142 */
        return p_23;
    }
    if ((l_245 != (void*)0))
    { /* block id: 145 */
        return p_23;
    }
    else
    { /* block id: 147 */
        int32_t l_246 = (-2);
        int32_t *l_247 = (void*)0;
        struct S0 l_269 = {0x6.Fp-1,1,0x609877FA,0x35BA57C2,-1,1U,1};
        struct S0 *l_268 = &l_269;
        struct S0 **l_267 = &l_268;
        if (l_246)
        { /* block id: 148 */
            uint32_t l_256 = 0xA048263A;
            float *l_259 = (void*)0;
            struct S0 **l_278 = &l_268;
            float **l_313 = (void*)0;
            float ***l_312 = &l_313;
            int32_t **l_317 = (void*)0;
lbl_291:
            l_247 = &l_246;
            if ((p_23 <= (((uint32_t)((uint16_t)(((uint16_t)0xE0C6 + (uint16_t)((uint16_t)l_256 % (uint16_t)((uint16_t)(((((void*)0 == l_259) ^ ((int32_t)(-(uint16_t)((int32_t)((int16_t)((((void*)0 != l_267) ^ (((((((uint16_t)0xC326 << (uint16_t)p_23) & 4294967295U) != 0U) != l_256) && 1U) ^ (*l_26))) & l_256) % (int16_t)l_256) % (int32_t)p_23)) - (int32_t)(*l_26))) | 0xC18F) < 0x24B468D6) - (uint16_t)l_256))) || (*l_247)) - (uint16_t)p_23) % (uint32_t)0x14887734) > (*l_247))))
            { /* block id: 150 */
                uint32_t l_274 = 1U;
                struct S0 **l_277 = &l_268;
                float **l_293 = &l_245;
                float *l_314 = &l_24;
                if (((int16_t)p_23 >> (int16_t)6))
                { /* block id: 151 */
                    int32_t **l_289 = (void*)0;
                    (*l_245) = ((l_274 > ((((((float)(-0x1.4p+1) + (float)(l_277 != l_278)) <= ((float)((!(((0x2.6E4805p+9 > (-(float)(-(float)((0x1.F6DE1Dp-94 != (p_23 > ((float)((float)p_23 + (float)(((-(float)0xD.5351F7p-67) >= 0x7.C5ADFDp+76) > l_256)) * (float)0x1.9p+1))) == p_23)))) < p_23) == (-0x8.4p+1))) == p_23) - (float)l_274)) >= l_274) < p_23) <= (-0x1.Dp+1))) >= (*l_26));
                    if (l_246)
                        goto lbl_290;
lbl_290:
                    l_247 = func_49(l_274);
                    if (l_246)
                        goto lbl_291;
                }
                else
                { /* block id: 156 */
                    uint32_t l_292 = 4294967295U;
                    float **l_298 = &l_245;
                    struct S0 *l_305 = (void*)0;
                    int32_t *l_309 = &l_269.f3;
                    if ((((0x823F19AB < (*l_26)) <= l_292) | l_292))
                    { /* block id: 157 */
                        int32_t **l_294 = &l_247;
                        int8_t l_295 = 1;
                        (*l_247) = ((void*)0 == l_293);
                        (*l_294) = func_49((l_259 != (*l_293)));
                        (**l_293) = l_295;
                        (**l_277) = (**l_267);
                    }
                    else
                    { /* block id: 162 */
                        int32_t **l_306 = &l_247;
                        (*l_26) = p_23;
                        (*l_247) = 0xD86706A4;
                        (*l_26) = ((int32_t)(l_298 != &l_245) % (int32_t)((uint16_t)(((void*)0 != (*l_298)) || ((uint32_t)l_292 - (uint32_t)p_23)) % (uint16_t)((uint16_t)0x4A39 + (uint16_t)(6U >= ((((l_305 != (*l_267)) ^ l_274) && p_23) > 0x58F806DD)))));
                        (*l_306) = func_49(l_274);
                    }
                    if (l_269.f5)
                        goto lbl_311;
lbl_311:
                    for (l_269.f4 = 0; (l_269.f4 <= 19); l_269.f4++)
                    { /* block id: 170 */
                        int32_t **l_310 = &l_309;
                        (*l_26) = 1;
                        (*l_310) = l_309;
                    }
                    (**l_278) = func_62((*l_26), ((void*)0 != l_312), l_314);
                }
            }
            else
            { /* block id: 177 */
                int32_t **l_315 = &l_26;
                struct S0 l_316 = {0xE.4E46D7p+83,0x4853,2U,0xE006D20A,0,4294967293U,1};
                (*l_315) = func_49(l_256);
                (*l_247) = p_23;
                (**l_278) = l_316;
            }
            l_26 = (void*)0;
            l_26 = func_49(p_23);
        }
        else
        { /* block id: 184 */
            return p_23;
        }
        (*l_267) = l_318;
        (*l_268) = (**l_267);
    }
    l_319.f3 = ((0xD.573957p+43 > l_25) > l_319.f6);
    return p_23;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_28(int32_t * p_29)
{ /* block id: 6 */
    int32_t l_34 = 5;
    int32_t *l_33 = &l_34;
    struct S0 l_215 = {0xF.CD96F6p-30,1,4294967289U,0xFF993564,-5,0x3290440B,-3};
    struct S0 *l_214 = &l_215;
    float l_224 = 0xB.AE1D0Cp-39;
    uint16_t l_225 = 0U;
    float **l_232 = (void*)0;
    (*l_214) = func_30(l_33, (*l_33));
    if ((((0 <= ((int16_t)((-1) | ((*l_33) >= (*l_33))) << (int16_t)(((((int16_t)((int16_t)0x8515 + (int16_t)(((void*)0 == &l_215) <= ((65535U == (((uint16_t)(*l_33) >> (uint16_t)(*l_33)) < 0)) > (*p_29)))) + (int16_t)65535U) | (*l_33)) == (*l_33)) > 0xF7AC18CA))) | l_225) & (*l_33)))
    { /* block id: 121 */
        struct S0 l_226 = {-0x1.1p-1,-1,4294967295U,-4,-3,4294967295U,0};
        float *l_242 = &l_224;
        (*l_214) = l_226;
        for (l_215.f1 = 0; (l_215.f1 != 20); l_215.f1 += 5)
        { /* block id: 125 */
            int32_t l_231 = 0xEE90912E;
            float ***l_233 = &l_232;
            for (l_215.f4 = 9; (l_215.f4 == 22); l_215.f4 += 1)
            { /* block id: 128 */
                return l_231;
            }
            (*l_233) = l_232;
            if ((*p_29))
                break;
        }
        (*l_242) = l_226.f4;
    }
    else
    { /* block id: 136 */
        int32_t l_243 = 1;
        (*l_33) = l_243;
    }
    return (*p_29);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_30(int32_t * p_31, int16_t  p_32)
{ /* block id: 7 */
    struct S0 l_36 = {-0x1.Dp+1,0x94DF,0x99643747,0x914A3A6D,0xD0,0x549C4B05,1};
    struct S0 *l_35 = &l_36;
    struct S0 **l_37 = &l_35;
    int32_t *l_38 = &l_36.f3;
    struct S0 l_213 = {0x0.8p-1,0x11EF,0x817D9523,0xD534F489,0xC3,0x69B45853,0};
    (*l_37) = l_35;
    p_31 = l_38;
    (**l_37) = (*l_35);
    if ((*l_38))
    { /* block id: 11 */
        uint32_t l_48 = 1U;
        struct S0 l_115 = {-0x2.Dp+1,0xBF39,0xC470FE6C,4,7,1U,-1};
        float *l_117 = &l_115.f0;
        for (p_32 = 0; (p_32 > (-23)); p_32 -= 7)
        { /* block id: 14 */
            uint16_t l_66 = 0x5F07;
            for (l_36.f2 = (-10); (l_36.f2 >= 29); l_36.f2++)
            { /* block id: 17 */
                struct S0 **l_47 = &l_35;
                struct S0 *l_116 = &l_115;
                for (l_36.f1 = 11; (l_36.f1 == 14); l_36.f1 += 3)
                { /* block id: 20 */
                    uint16_t l_61 = 3U;
                    struct S0 l_113 = {-0x6.Cp-1,0x7E09,0x21D5E08C,0x29F52E16,-7,4294967295U,0x29};
                    struct S0 *l_112 = &l_113;
                    int32_t **l_114 = &l_38;
                    for (l_36.f5 = (-23); (l_36.f5 <= 25); l_36.f5++)
                    { /* block id: 23 */
                        int32_t **l_60 = &l_38;
                        l_47 = (void*)0;
                        if (l_48)
                            continue;
                        (*l_60) = func_49(p_32);
                        if (l_61)
                            break;
                    }
                    (*l_112) = func_62(p_32, l_66, p_31);
                    (*l_114) = l_38;
                    if (l_66)
                        break;
                }
                (*l_116) = l_115;
            }
        }
        (*l_117) = p_32;
    }
    else
    { /* block id: 69 */
        uint32_t l_123 = 1U;
        struct S0 l_155 = {0x1.8p+1,0xFE2E,4294967295U,1,-10,1U,0xD8};
        int32_t *l_183 = &l_155.f3;
        struct S0 **l_209 = &l_35;
        int32_t **l_212 = (void*)0;
        int32_t ***l_211 = &l_212;
        for (l_36.f5 = (-27); (l_36.f5 >= 41); l_36.f5 += 6)
        { /* block id: 72 */
            uint32_t l_126 = 0x2407C9B6;
            uint32_t l_143 = 0xD9C3D7FA;
            int32_t **l_152 = &l_38;
            float *l_208 = &l_36.f0;
            struct S0 *l_210 = &l_155;
        }
        (*l_211) = &p_31;
    }
    return l_213;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_49(int16_t  p_50)
{ /* block id: 26 */
    struct S0 l_55 = {0xC.98BE49p+3,2,0x46153B72,0x46FAC5AD,0,0xD77974D3,0x71};
    struct S0 *l_54 = &l_55;
    struct S0 **l_53 = &l_54;
    int32_t *l_58 = &l_55.f3;
    int32_t *l_59 = (void*)0;
    for (p_50 = (-5); (p_50 < (-12)); p_50 -= 3)
    { /* block id: 29 */
        struct S0 **l_56 = &l_54;
        float *l_57 = &l_55.f0;
        (*l_57) = (l_53 == l_56);
    }
    return l_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_62(uint32_t  p_63, uint32_t  p_64, float * p_65)
{ /* block id: 36 */
    struct S0 *l_78 = (void*)0;
    int32_t l_104 = 0xD2708467;
    int32_t *l_103 = &l_104;
    struct S0 l_111 = {0x1.Dp+1,0x49FE,0x5CAB5B23,1,0xF6,0xD02479DA,0x6A};
    (*l_103) = func_67(func_49(p_64), func_73(l_78, p_65, l_78, func_49(p_64)), l_103, &l_78, p_65);
    (*l_103) = p_63;
    return l_111;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_67(float * p_68, struct S0 * p_69, int32_t * p_70, struct S0 ** p_71, float * p_72)
{ /* block id: 49 */
    struct S0 l_105 = {0x1.Bp-1,0x64B6,0x7F149919,0xF91B2076,0x13,0x9F8C36B4,0xDB};
    struct S0 l_106 = {0xC.09E5C5p+75,0xEA73,7U,0x010E05D1,0xE0,0x0EEAA445,-5};
    float l_109 = 0xD.F92971p+35;
lbl_110:
    l_106 = l_105;
    for (l_106.f4 = 0; (l_106.f4 == (-17)); l_106.f4 -= 9)
    { /* block id: 53 */
        return (*p_70);
    }
    if (l_105.f4)
        goto lbl_110;
    return (*p_70);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: l_36.f3 l_24
 */
static struct S0 * func_73(struct S0 * p_74, int32_t * p_75, struct S0 * p_76, int32_t * p_77)
{ /* block id: 37 */
    uint16_t l_81 = 65526U;
    float *l_82 = (void*)0;
    float l_84 = 0x1.Bp-1;
    float *l_83 = &l_84;
    int32_t l_102 = 2;
    int32_t *l_101 = &l_102;
    (*p_75) = 0x086565EA;
    (*l_83) = ((float)l_81 - (float)0x3.A9F656p-51);
    for (l_81 = 0; (l_81 > 32); l_81 += 1)
    { /* block id: 42 */
        int32_t l_91 = 4;
        int32_t l_100 = 0;
        int32_t *l_99 = &l_100;
        int32_t **l_98 = &l_99;
        (*l_98) = func_49((((((int16_t)((uint16_t)(p_74 != (void*)0) * (uint16_t)l_91) << (int16_t)(((uint16_t)l_91 << (uint16_t)((((-(int32_t)((uint16_t)(-(uint32_t)(p_75 != l_83)) >> (uint16_t)(((p_75 != p_77) != l_91) & (-9)))) >= l_81) | 0x86F73136) && l_91)) != l_91)) | l_91) | l_91) != l_91));
        (*l_98) = func_49(l_81);
        (*l_98) = l_82;
    }
    l_101 = p_77;
    return p_74;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 74
   depth: 1, occurrence: 10
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 27
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 15, occurrence: 1
   depth: 18, occurrence: 3
   depth: 21, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 104

XXX times a variable address is taken: 86
XXX times a pointer is dereferenced on RHS: 58
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 11
XXX times a pointer is dereferenced on LHS: 66
breakdown:
   depth: 1, occurrence: 60
   depth: 2, occurrence: 6
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 147

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 131
   level: 2, occurrence: 27
XXX number of pointers point to pointers: 35
XXX number of pointers point to scalars: 47
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 33.7
XXX average alias set size: 1.16

XXX times a non-volatile is read: 373
XXX times a non-volatile is write: 166
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 102
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 24
   depth: 2, occurrence: 9
   depth: 3, occurrence: 7
   depth: 4, occurrence: 12
   depth: 5, occurrence: 14

XXX percentage a fresh-made variable is used: 18.7
XXX percentage an existing variable is used: 81.3
********************* end of statistics **********************/

