/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      3315627436
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const uint16_t  f0;
   uint16_t  f1;
   int16_t  f2;
   uint32_t  f3;
   int16_t  f4;
   uint32_t  f5;
   int32_t  f6;
   int16_t  f7;
   uint32_t  f8;
};

struct S1 {
   const signed f0 : 28;
   uint32_t  f1;
   signed f2 : 1;
   signed f3 : 8;
   signed f4 : 20;
   const unsigned f5 : 17;
   const unsigned f6 : 20;
   unsigned f7 : 18;
   unsigned f8 : 27;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
inline static int32_t * func_9(int32_t ** p_10, int32_t  p_11, int32_t ** p_12);
inline static int32_t  func_13(int32_t  p_14, int32_t  p_15, struct S1  p_16, int32_t  p_17, const int32_t * p_18);
static const int32_t * func_21(uint32_t  p_22, uint32_t  p_23);
static uint16_t  func_27(int32_t  p_28, int32_t  p_29);
inline static int32_t * func_40(int32_t  p_41, uint32_t  p_42);
inline static uint16_t  func_47(int8_t  p_48, int32_t * p_49, struct S1  p_50);
static int32_t  func_51(const struct S1  p_52, uint32_t  p_53, int32_t ** p_54, int32_t * p_55);
inline static const struct S1  func_56(struct S0  p_57, uint32_t  p_58);
inline static int16_t  func_60(int32_t ** p_61, int32_t ** p_62, int16_t  p_63);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_2 = 65535U;
    int32_t l_4 = 0xE0566A92;
    int32_t *l_3 = &l_4;
    uint32_t l_37 = 4294967295U;
    uint32_t l_142 = 1U;
    int32_t **l_380 = &l_3;
    uint16_t l_388 = 65535U;
    (*l_3) = (l_2 > l_2);
    if ((*l_3))
    { /* block id: 2 */
        int32_t *l_5 = (void*)0;
        int32_t **l_6 = &l_3;
        int8_t l_38 = 0xE1;
        int32_t **l_378 = (void*)0;
        int32_t **l_379 = &l_5;
        (*l_6) = l_5;
        for (l_2 = 0; (l_2 < 16); ++l_2)
        { /* block id: 6 */
            uint16_t l_19 = 0x5F76;
            struct S1 l_20 = {-1036,0x2D5FBA25,-0,10,-495,114,226,447,5468};
            int32_t l_36 = (-1);
            int32_t **l_333 = &l_3;
            (*l_6) = func_9(&l_3, func_13(l_19, l_19, l_20, l_20.f8, func_21((((uint32_t)((-(uint16_t)(func_27(((uint32_t)(((((int16_t)l_20.f0 * (int16_t)(((uint16_t)(l_19 ^ ((l_36 = 2) > l_37)) - (uint16_t)l_38) >= l_20.f3)) | l_20.f7) && (-1)) >= l_20.f3) - (uint32_t)0x9335309F), l_37) | l_142)) && l_142) - (uint32_t)(-1)) ^ l_20.f4), l_20.f2)), l_333);
        }
        (*l_379) = func_21(l_38, l_37);
    }
    else
    { /* block id: 206 */
        int32_t ***l_381 = (void*)0;
        int32_t ***l_382 = &l_380;
        int32_t **l_384 = &l_3;
        int32_t ***l_383 = &l_384;
        int32_t **l_385 = &l_3;
        (*l_385) = func_9(((*l_382) = l_380), (*l_3), ((*l_383) = &l_3));
        l_388 = ((int16_t)0 * (int16_t)0xC94A);
    }
    return l_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_9(int32_t ** p_10, int32_t  p_11, int32_t ** p_12)
{ /* block id: 161 */
    int32_t *l_334 = (void*)0;
    int32_t l_338 = (-1);
    int32_t **l_345 = &l_334;
    int32_t ***l_344 = &l_345;
    int32_t ****l_343 = &l_344;
    struct S0 l_373 = {0x292E,1U,0xE5CB,1U,0,0xA8C57EA8,0xA41679F9,-2,4294967295U};
    struct S0 *l_372 = &l_373;
    struct S0 *l_375 = (void*)0;
    struct S0 **l_374 = &l_375;
    struct S0 l_377 = {1U,65535U,0,0xA8C30F78,0x3223,6U,0x21128C3E,0x849B,0x4E487063};
    struct S0 *l_376 = &l_377;
    (*p_12) = l_334;
    if (p_11)
    { /* block id: 163 */
        l_334 = ((*p_12) = (void*)0);
    }
    else
    { /* block id: 166 */
        uint32_t l_351 = 4294967293U;
        int32_t *l_352 = &l_338;
        l_334 = (*p_12);
        for (p_11 = 0; (p_11 <= (-30)); p_11 -= 1)
        { /* block id: 170 */
            int32_t *l_337 = (void*)0;
            const int32_t *l_349 = &l_338;
            const int32_t **l_348 = &l_349;
            const int32_t ***l_347 = &l_348;
            const int32_t ****l_346 = &l_347;
            int32_t *l_350 = &l_338;
            l_338 = 0;
            for (l_338 = 0; (l_338 == (-30)); l_338 -= 1)
            { /* block id: 174 */
                uint16_t l_341 = 65529U;
                int32_t l_342 = 0;
                l_342 = l_341;
                if (l_342)
                    continue;
            }
            (*l_350) = (l_343 != l_346);
            if (l_351)
                break;
        }
        (**l_344) = l_352;
        for (l_338 = 0; (l_338 >= 8); l_338++)
        { /* block id: 184 */
            struct S1 l_357 = {14838,0xE7D97D77,0,13,-41,224,997,293,8698};
            struct S1 *l_356 = &l_357;
            struct S1 **l_355 = &l_356;
            struct S1 ***l_358 = (void*)0;
            struct S1 ***l_359 = &l_355;
            uint16_t l_363 = 0x965C;
            uint16_t *l_362 = &l_363;
            uint32_t *l_366 = (void*)0;
            uint32_t *l_367 = &l_351;
            int32_t l_369 = 0x947678D6;
            int32_t *l_368 = &l_369;
            (*l_359) = l_355;
            if ((**l_345))
                continue;
            p_11 = ((*l_368) = (((uint16_t)((*l_362) = (p_11 > 1U)) * (uint16_t)(p_11 < ((*l_367) = ((l_357.f0 <= (l_357.f3 = ((uint16_t)(((((void*)0 != l_362) || ((void*)0 == &l_362)) || 0xD652) <= (*l_352)) - (uint16_t)(****l_343)))) >= (*l_352))))) | 0xD85A1BAF));
            for (p_11 = 0; (p_11 == 25); p_11 += 9)
            { /* block id: 194 */
                return (*p_12);
            }
        }
    }
    l_376 = ((*l_374) = (l_372 = l_372));
    return (*p_10);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_13(int32_t  p_14, int32_t  p_15, struct S1  p_16, int32_t  p_17, const int32_t * p_18)
{ /* block id: 158 */
    int32_t l_327 = 0xE5F21BAE;
    int32_t **l_328 = (void*)0;
    int32_t **l_329 = (void*)0;
    int32_t **l_330 = (void*)0;
    int32_t l_332 = (-6);
    int32_t *l_331 = &l_332;
    l_331 = func_40(l_327, p_16.f1);
    return l_327;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_21(uint32_t  p_22, uint32_t  p_23)
{ /* block id: 52 */
    int32_t l_147 = 0xB66E786C;
    int32_t *l_146 = &l_147;
    int32_t **l_145 = &l_146;
    struct S0 l_191 = {0xAA44,1U,0x7B37,4294967295U,0x863C,4294967290U,1,0x227D,0x37D6E895};
    struct S0 *l_190 = &l_191;
    struct S1 *l_215 = (void*)0;
    uint16_t *l_269 = (void*)0;
    uint16_t l_275 = 65535U;
    struct S0 l_300 = {0x3A83,1U,0xB209,0xCC29EC63,7,4294967295U,5,1,0xB3C05E57};
    struct S0 *l_299 = &l_300;
    const int16_t l_303 = (-1);
    const int32_t *l_312 = &l_147;
    int32_t *l_324 = &l_147;
    const int32_t *l_325 = &l_147;
    const int32_t *l_326 = (void*)0;
    (*l_145) = func_40(p_23, ((int32_t)1 + (int32_t)p_23));
    if (p_23)
    { /* block id: 54 */
        int32_t *l_152 = &l_147;
        int32_t ***l_156 = &l_145;
        int32_t l_188 = (-6);
        struct S1 **l_277 = &l_215;
        struct S0 *l_298 = (void*)0;
        if (((((int16_t)(p_22 == (p_22 >= 1U)) * (int16_t)(0x0033 > p_23)) && ((int16_t)p_22 >> (int16_t)2)) & ((l_152 != l_152) || ((&l_146 == (void*)0) || p_23))))
        { /* block id: 55 */
            int32_t *l_154 = &l_147;
            const int32_t *l_183 = &l_147;
            const int32_t *l_185 = (void*)0;
            struct S0 *l_189 = (void*)0;
            l_152 = ((*l_145) = (*l_145));
            (*l_154) = (+((((*l_145) = l_152) == (void*)0) <= 4294967292U));
            (*l_154) = ((((-(uint16_t)p_22) == (l_156 != (void*)0)) & (!(+(((uint16_t)(*l_154) * (uint16_t)((&l_146 == &l_154) > (((p_22 & 0x5917A22F) == p_22) > 7))) & p_22)))) & p_23);
            for (l_147 = 0; (l_147 <= (-18)); l_147 -= 1)
            { /* block id: 63 */
                const int16_t l_187 = 1;
                const int16_t *l_186 = &l_187;
                for (p_23 = 0; (p_23 >= 46); p_23++)
                { /* block id: 66 */
                    uint32_t l_169 = 0x482B3DB3;
                    int32_t l_172 = 0x53FEDF42;
                    int32_t l_177 = 0xC1FD706C;
                    const int32_t *l_182 = &l_147;
                    for (p_22 = 0; (p_22 < 53); p_22 += 1)
                    { /* block id: 69 */
                        int8_t l_178 = 1;
                        int32_t *l_179 = &l_177;
                        (**l_156) = func_40((l_178 = ((int16_t)(l_172 = ((l_169 = ((*l_156) != (*l_156))) ^ ((int16_t)(*l_154) >> (int16_t)0))) + (int16_t)((((int16_t)((&l_145 != (void*)0) ^ ((uint16_t)((l_177 || (((p_23 <= (-1)) == (0xD3D9F213 | 1)) != p_23)) >= 0U) * (uint16_t)0xAB54)) % (int16_t)p_23) && p_22) ^ p_22))), p_23);
                        (*l_179) = p_22;
                    }
                    for (l_172 = (-24); (l_172 != (-3)); l_172 += 7)
                    { /* block id: 78 */
                        const int32_t *l_184 = &l_147;
                        (**l_156) = &l_177;
                        return l_185;
                    }
                    l_188 = ((void*)0 != l_186);
                    l_190 = l_189;
                }
            }
        }
        else
        { /* block id: 86 */
            struct S1 l_197 = {-4175,1U,-0,-4,317,159,229,383,1773};
            struct S1 *l_196 = &l_197;
            uint32_t *l_206 = (void*)0;
            uint32_t l_230 = 5U;
            uint16_t *l_239 = &l_191.f1;
            int16_t *l_250 = (void*)0;
            int16_t *l_251 = (void*)0;
            int16_t *l_252 = &l_191.f2;
            const int32_t l_253 = 1;
            struct S0 *l_274 = &l_191;
            int32_t l_291 = 0;
            uint32_t l_301 = 4294967292U;
            for (l_191.f3 = 0; (l_191.f3 < 32); ++l_191.f3)
            { /* block id: 89 */
                uint16_t l_216 = 65535U;
                struct S0 l_228 = {0U,0x0848,1,1U,0xD48E,3U,0x199CA37C,0,0x25579C5B};
                struct S0 *l_227 = &l_228;
                int32_t l_234 = 0xC04E2F62;
                for (l_191.f6 = 0; (l_191.f6 >= 28); l_191.f6++)
                { /* block id: 92 */
                    int8_t l_214 = (-1);
                    uint16_t *l_219 = &l_191.f1;
                    int32_t l_220 = 0x6506466B;
                    int16_t *l_229 = &l_191.f4;
                    uint32_t *l_231 = (void*)0;
                    uint32_t *l_232 = &l_228.f5;
                    int16_t *l_233 = &l_228.f7;
                    int32_t *l_235 = &l_188;
                    l_196 = l_196;
                    (*l_152) = (0x875F < ((uint32_t)((int16_t)0xADAB << (int16_t)2) % (uint32_t)(((((((uint16_t)(l_197.f3 >= ((*l_152) || ((int16_t)(((l_206 != &p_22) ^ (((uint16_t)((((int16_t)(+0xB08E) + (int16_t)((int32_t)l_214 - (int32_t)((l_215 == (void*)0) & 4294967295U))) & (-6)) && 5) * (uint16_t)(-1)) <= (-6))) | l_197.f5) * (int16_t)p_23))) * (uint16_t)l_214) ^ 0xCE69) == l_197.f7) && (*l_152)) && 2) & l_197.f2)));
                    if (p_22)
                        break;
                    (*l_235) = ((l_216 != ((l_234 = ((*l_233) = ((int16_t)((((*l_232) = ((0xE1A5 < ((l_220 = ((*l_219) = l_197.f8)) & (((((*l_152) = (l_197.f4 = ((*l_152) != ((uint32_t)(1 < ((int16_t)0xF503 - (int16_t)(((int16_t)((*l_229) = ((void*)0 != l_227)) >> (int16_t)10) >= p_22))) - (uint32_t)l_214)))) && p_22) == l_197.f6) | 0))) && l_230)) || p_23) & l_228.f3) % (int16_t)l_216))) > l_230)) >= 0U);
                }
            }
            for (p_23 = (-14); (p_23 <= 7); p_23 += 7)
            { /* block id: 109 */
                const int32_t *l_238 = &l_147;
                return l_206;
            }
            (*l_152) = ((-1) < ((*l_239) = l_197.f1));
            if ((1 || ((l_215 != &l_197) == ((int16_t)((int16_t)(p_23 > (((*l_152) > ((*l_252) = (+(((-2) <= (0xD5CF70B3 != (!((((uint16_t)((int32_t)((p_23 >= (-1)) || (*l_152)) - (int32_t)p_23) >> (uint16_t)p_22) | 0U) <= l_197.f2)))) == p_22)))) <= p_23)) - (int16_t)l_253) * (int16_t)l_253))))
            { /* block id: 115 */
                int16_t l_254 = 0xF7C0;
                int32_t ***l_263 = &l_145;
                const uint16_t *l_267 = &l_191.f0;
                struct S1 *l_271 = &l_197;
                struct S1 **l_272 = &l_215;
                int16_t **l_273 = &l_251;
                uint32_t *l_276 = &l_191.f5;
                struct S1 ***l_278 = &l_272;
                uint16_t *l_292 = &l_191.f1;
                uint16_t *l_302 = &l_300.f1;
                if (((l_254 = l_197.f4) >= (0 ^ 65531U)))
                { /* block id: 117 */
                    int32_t ****l_264 = &l_156;
                    uint16_t **l_268 = &l_239;
                    int32_t *l_270 = &l_188;
                    (*l_270) = ((*l_152) = ((int16_t)(((!((int16_t)((void*)0 != &l_145) << (int16_t)3)) && ((uint16_t)(~(l_254 <= 7U)) >> (uint16_t)12)) ^ ((l_263 == ((*l_264) = l_156)) | (~(~(((*l_268) = l_267) == l_269))))) + (int16_t)l_197.f3));
                    (*l_270) = (&l_267 != l_268);
                    (*l_152) = p_22;
                }
                else
                { /* block id: 124 */
                    (*l_152) = (l_197.f5 | (l_197.f2 = (-3)));
                }
                (*l_272) = l_271;
                l_188 = (((*l_276) = ((((*l_273) = (void*)0) == l_269) | (l_275 = (l_274 != l_274)))) >= ((*l_152) = (((*l_278) = l_277) == (void*)0)));
                (*l_152) = ((int16_t)(((*l_252) = ((((uint16_t)((uint16_t)((int16_t)((uint16_t)0U << (uint16_t)((uint16_t)(((((*l_302) = ((((*l_292) = (((*l_278) == (void*)0) == l_291)) < (0xC249 == (((int16_t)1 % (int16_t)(+p_23)) < ((int16_t)((p_23 ^ ((((l_190 = l_298) == l_299) || l_230) >= l_301)) ^ 0) % (int16_t)p_22)))) && p_22)) >= (-2)) && 0xCFC9B87D) && p_23) >> (uint16_t)p_22)) - (int16_t)l_303) + (uint16_t)p_22) * (uint16_t)p_23) || 0) && p_23)) | (-1)) - (int16_t)p_23);
            }
            else
            { /* block id: 140 */
                int32_t ****l_304 = &l_156;
                (**l_156) = (**l_156);
                l_291 = (l_304 == &l_156);
            }
        }
    }
    else
    { /* block id: 145 */
        const int32_t l_307 = 1;
        int32_t *l_308 = &l_147;
        const int32_t *l_313 = &l_147;
        const int32_t *l_314 = &l_307;
        int32_t ***l_317 = &l_145;
        int32_t ****l_318 = (void*)0;
        int32_t ****l_319 = &l_317;
        int32_t ***l_321 = &l_145;
        int32_t ****l_320 = &l_321;
        (*l_308) = ((uint16_t)l_307 - (uint16_t)p_22);
        for (l_191.f6 = (-10); (l_191.f6 != (-22)); l_191.f6 -= 1)
        { /* block id: 149 */
            const int32_t *l_311 = &l_147;
            const int32_t *l_315 = &l_307;
            const int32_t *l_316 = (void*)0;
            (*l_308) = p_22;
            return l_316;
        }
        (*l_320) = ((*l_319) = l_317);
    }
    (*l_324) = (4294967295U | (65534U ^ ((int32_t)(*l_312) + (int32_t)5U)));
    return l_326;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_27(int32_t  p_28, int32_t  p_29)
{ /* block id: 8 */
    int32_t *l_39 = (void*)0;
    int32_t **l_140 = (void*)0;
    int32_t **l_141 = &l_39;
    if (p_28)
    { /* block id: 9 */
        l_39 = l_39;
    }
    else
    { /* block id: 11 */
        struct S0 l_59 = {0x40F4,2U,0x12B1,0x2D5F2ABA,0x1C9A,4294967295U,0x6A48ADB2,0,0x74433F2F};
        int32_t l_91 = (-1);
        int32_t *l_90 = &l_91;
        struct S1 l_97 = {-9551,0xF541A3AC,0,-11,-721,300,719,155,6549};
        uint32_t *l_107 = &l_59.f5;
        l_39 = func_40(p_28, ((*l_107) = ((uint16_t)(((uint16_t)func_47((func_51(func_56(l_59, l_59.f3), p_28, &l_39, l_90) && (((!((int16_t)((uint16_t)(65535U < 6) * (uint16_t)0xF35E) * (int16_t)p_29)) != p_29) == p_28)), l_39, l_97) * (uint16_t)(-7)) && 0x202A) >> (uint16_t)0)));
    }
    (*l_141) = &p_28;
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_40(int32_t  p_41, uint32_t  p_42)
{ /* block id: 34 */
    int32_t l_113 = 0xDF585002;
    int32_t *l_112 = &l_113;
    int32_t *l_116 = &l_113;
    int32_t *l_117 = &l_113;
    int32_t *l_118 = (void*)0;
    const int32_t **l_121 = (void*)0;
    int32_t **l_124 = &l_116;
    int32_t *l_125 = &l_113;
    int32_t *l_126 = &l_113;
    int32_t *l_127 = &l_113;
    int32_t *l_128 = &l_113;
    int32_t *l_129 = &l_113;
    int32_t *l_130 = &l_113;
    int32_t *l_131 = &l_113;
    int32_t *l_132 = &l_113;
    int32_t *l_133 = &l_113;
    int32_t *l_134 = &l_113;
    int32_t *l_135 = &l_113;
    int32_t *l_136 = &l_113;
    int32_t *l_137 = &l_113;
    int32_t *l_138 = &l_113;
    int32_t *l_139 = (void*)0;
    for (p_42 = 0; (p_42 >= 22); p_42 += 8)
    { /* block id: 37 */
        int32_t l_111 = 1;
        int32_t *l_110 = &l_111;
        int32_t *l_114 = &l_111;
        int32_t *l_115 = &l_113;
        return l_118;
    }
    for (p_42 = 0; (p_42 != 53); p_42++)
    { /* block id: 42 */
        int32_t **l_123 = (void*)0;
        int32_t ***l_122 = &l_123;
        (**l_124) = (((*l_122) = l_121) == l_124);
    }
    (*l_112) = (*l_117);
    return l_139;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_47(int8_t  p_48, int32_t * p_49, struct S1  p_50)
{ /* block id: 28 */
    int32_t l_100 = 1;
    int32_t *l_99 = &l_100;
    int32_t **l_98 = &l_99;
    int16_t l_102 = (-1);
    int16_t *l_101 = &l_102;
    const int32_t *l_105 = &l_100;
    const int32_t **l_104 = &l_105;
    const int32_t ***l_103 = &l_104;
    int32_t *l_106 = &l_100;
    (*l_98) = p_49;
    (*l_106) = ((((1U >= ((void*)0 != l_101)) <= (p_50.f1 == (&p_49 != &l_99))) != ((*l_101) = ((&l_98 == (void*)0) == (&l_98 == l_103)))) ^ p_50.f2);
    return p_50.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_51(const struct S1  p_52, uint32_t  p_53, int32_t ** p_54, int32_t * p_55)
{ /* block id: 26 */
    return (*p_55);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S1  func_56(struct S0  p_57, uint32_t  p_58)
{ /* block id: 12 */
    int32_t l_66 = (-10);
    int32_t *l_65 = &l_66;
    int32_t **l_64 = &l_65;
    int32_t **l_68 = &l_65;
    int32_t ***l_67 = &l_68;
    int32_t **l_70 = (void*)0;
    int32_t ***l_69 = &l_70;
    int32_t **l_72 = (void*)0;
    int32_t ***l_71 = &l_72;
    int32_t *l_78 = &l_66;
    int32_t **l_77 = &l_78;
    int32_t ***l_79 = (void*)0;
    int32_t **l_81 = &l_65;
    int32_t ***l_80 = &l_81;
    int16_t *l_82 = (void*)0;
    int16_t l_84 = 0xD150;
    int16_t *l_83 = &l_84;
    const struct S1 l_89 = {-4959,0xFD2A9E32,-0,-5,965,81,585,427,7575};
    (*l_78) = ((func_60(l_64, ((*l_71) = ((*l_69) = ((*l_67) = &l_65))), ((*l_83) = (((uint16_t)(p_57.f2 | (p_57.f4 >= (**l_64))) >> (uint16_t)9) > (p_57.f3 && (p_57.f5 & ((l_77 = &l_65) != ((*l_80) = &l_78))))))) || 5) == 0x6F42);
    return l_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_60(int32_t ** p_61, int32_t ** p_62, int16_t  p_63)
{ /* block id: 19 */
    int32_t l_86 = 0xC5A18187;
    int32_t *l_85 = &l_86;
    (*p_61) = l_85;
    (*l_85) = ((int32_t)0 % (int32_t)(*l_85));
    (*p_62) = (*p_61);
    return p_63;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 103
   depth: 1, occurrence: 4
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 8
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 4
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 6
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 20

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 26
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 6, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 2
   depth: 22, occurrence: 2
   depth: 24, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 159

XXX times a variable address is taken: 143
XXX times a pointer is dereferenced on RHS: 27
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 3
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 73
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 568

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 135
   level: 2, occurrence: 57
   level: 3, occurrence: 43
   level: 4, occurrence: 8
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 84
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 26.4
XXX average alias set size: 1.09

XXX times a non-volatile is read: 289
XXX times a non-volatile is write: 196
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 95
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 18
   depth: 2, occurrence: 19
   depth: 3, occurrence: 12
   depth: 4, occurrence: 12
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 14.1
XXX percentage an existing variable is used: 85.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

