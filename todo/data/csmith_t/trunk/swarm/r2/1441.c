/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      3776103296
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = 0xA48BBCA6;
static int32_t ** volatile g_17 = (void*)0;/* VOLATILE GLOBAL g_17 */
static int32_t *g_19 = (void*)0;
static int32_t ** volatile g_18 = &g_19;/* VOLATILE GLOBAL g_18 */
static volatile int32_t g_48 = 0x031EA062;/* VOLATILE GLOBAL g_48 */
static int32_t g_49 = 0x0A7C6DD3;
static float g_54 = 0x0.9p-1;
static float * volatile g_53 = &g_54;/* VOLATILE GLOBAL g_53 */
static int32_t **g_87 = &g_19;
static int32_t ** volatile *g_86 = &g_87;
static float * volatile g_90 = &g_54;/* VOLATILE GLOBAL g_90 */
static int32_t * volatile g_103 = &g_49;/* VOLATILE GLOBAL g_103 */
static int32_t * volatile g_105 = &g_49;/* VOLATILE GLOBAL g_105 */
static float * const  volatile g_125 = &g_54;/* VOLATILE GLOBAL g_125 */
static int32_t * volatile g_137 = (void*)0;/* VOLATILE GLOBAL g_137 */
static int32_t * const  volatile g_138 = &g_49;/* VOLATILE GLOBAL g_138 */
static int32_t * volatile g_151 = &g_49;/* VOLATILE GLOBAL g_151 */
static float * volatile g_264 = &g_54;/* VOLATILE GLOBAL g_264 */
static volatile int32_t *g_271 = &g_48;
static volatile int32_t **g_270 = &g_271;
static volatile int32_t ***g_269 = &g_270;
static volatile int32_t **** volatile g_268 = &g_269;/* VOLATILE GLOBAL g_268 */
static volatile int32_t **** volatile *g_267 = &g_268;
static float * volatile g_378 = &g_54;/* VOLATILE GLOBAL g_378 */
static float * const  volatile g_394 = &g_54;/* VOLATILE GLOBAL g_394 */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int8_t  func_7(uint16_t  p_8, uint16_t  p_9, int8_t  p_10);
static uint16_t  func_11(int8_t  p_12, int32_t  p_13, uint8_t  p_14);
static int32_t *** func_20(int8_t  p_21, const float  p_22, int32_t  p_23);
static int32_t  func_27(uint16_t  p_28, const uint32_t  p_29);
static int32_t  func_32(int32_t ** p_33, float  p_34, uint16_t  p_35, int8_t  p_36, int32_t  p_37);
static float  func_42(int32_t ** p_43, uint8_t  p_44);
static int32_t * func_46(int32_t * p_47);
static int32_t * func_55(uint32_t  p_56, float  p_57, const int8_t  p_58, int32_t  p_59, float * p_60);
static float * func_63(int32_t ** p_64, uint32_t  p_65, float  p_66);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_18 g_19 g_53 g_54 g_49 g_86 g_90 g_87 g_103 g_105 g_48 g_125 g_138 g_151 g_264 g_267 g_269 g_270 g_271 g_268 g_378 g_394
 * writes: g_2 g_19 g_49 g_54 g_267 g_271 g_48 g_87
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t l_15 = 0x55595070;
    int32_t ** const *l_178 = &g_87;
    int32_t ** const **l_399 = &l_178;
    int32_t ** const ***l_398 = &l_399;
    for (g_2 = 27; (g_2 >= (-6)); g_2 -= 1)
    { /* block id: 3 */
        uint16_t l_177 = 0xF025;
        int32_t *l_375 = &g_49;
        int32_t ***l_379 = &g_87;
        (*l_375) = ((int8_t)func_7(g_2, func_11(l_15, g_2, g_2), ((int8_t)((uint8_t)l_177 - (uint8_t)(l_178 == (void*)0)) + (int8_t)((uint8_t)((((uint16_t)(0xAC | 0x5A) << (uint16_t)4) >= l_177) || g_2) * (uint8_t)0xD4))) * (int8_t)0x15);
        /* statement id: 138 */
        assert (g_19 == &g_2 || g_19 == &g_49);
        (*g_378) = ((float)(*g_90) - (float)0x9.A442AEp+38);
        (*l_379) = (*l_178);
        if (((***l_178) > g_49))
        { /* block id: 141 */
            uint8_t l_392 = 0x34;
            (*l_375) = ((uint16_t)((int8_t)(0xC4 != ((uint16_t)((void*)0 != &g_378) - (uint16_t)g_2)) - (int8_t)0x5C) * (uint16_t)((int8_t)g_2 << (int8_t)((***l_178) <= 0x0A9B597B)));
            (*g_394) = ((float)((float)0x4.1E1DB4p-73 - (float)l_392) - (float)(!(*g_125)));
            (*g_87) = (**l_178);
        }
        else
        { /* block id: 145 */
            float *l_397 = &g_54;
            float **l_396 = &l_397;
            float ***l_395 = &l_396;
            (*l_395) = (void*)0;
            /* statement id: 146 */
            assert (l_396 == 0);
            (*l_397) = (***l_178);
        }
    }
    /* facts after for loop */
    assert (g_19 == &g_2 || g_19 == &g_49 || g_19 == 0);
    (*l_398) = &l_178;
    return g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_48 g_2 g_87 g_19 g_125 g_54 g_86 g_90 g_264 g_267 g_269 g_270 g_271 g_268 g_53
 * writes: g_49 g_54 g_19 g_267 g_271 g_48
 */
static int8_t  func_7(uint16_t  p_8, uint16_t  p_9, int8_t  p_10)
{ /* block id: 81 */
    uint8_t l_183 = 0x31;
    int32_t *l_184 = &g_49;
    int32_t ***l_193 = &g_87;
    int32_t ****l_192 = &l_193;
    int32_t l_194 = 0x4652DBFB;
    int8_t l_228 = 0xC2;
    int32_t l_245 = 0x8CAA09B4;
    uint32_t l_260 = 0x175B47AC;
    int32_t l_261 = 0xB0B29F1C;
    float *l_304 = &g_54;
    float **l_303 = &l_304;
    const uint32_t l_372 = 0x56643B3F;
    (*l_184) = l_183;
    if ((~(((int16_t)(((*l_184) | (((((((*l_184) != (((uint8_t)(*l_184) - (uint8_t)p_9) != ((int8_t)((l_192 == (void*)0) < (g_49 > 255U)) << (int8_t)p_9))) < 0xA5) ^ 1) & g_48) || l_194) && g_2)) >= g_49) * (int16_t)p_10) ^ 0xF8)))
    { /* block id: 83 */
        uint8_t l_213 = 0x71;
        if (((int16_t)(l_184 == (void*)0) % (int16_t)((int16_t)1 * (int16_t)((~g_2) && (((uint16_t)(!((uint16_t)((uint8_t)(((uint16_t)(((int32_t)((int8_t)l_213 << (int8_t)(((int16_t)(((uint16_t)((int32_t)(((2 < g_48) != ((int16_t)((uint8_t)((uint16_t)(((int8_t)(l_213 & 0x1CC493F2) - (int8_t)l_213) && g_49) << (uint16_t)3) * (uint8_t)l_213) - (int16_t)0xF70A)) == 0x55B3299B) % (int32_t)p_8) % (uint16_t)p_9) == 250U) - (int16_t)(*l_184)) && l_228)) - (int32_t)7U) < (***l_193)) >> (uint16_t)5) || g_2) >> (uint8_t)p_9) >> (uint16_t)p_9)) - (uint16_t)(***l_193)) > g_2)))))
        { /* block id: 84 */
            float *l_229 = &g_54;
            int32_t *l_230 = (void*)0;
            (*l_229) = (&l_193 != &g_86);
            l_230 = l_229;
            /* statement id: 86 */
            assert (l_230 == &g_54);
        }
        else
        { /* block id: 87 */
            int32_t l_246 = 3;
            float *l_247 = (void*)0;
            float *l_248 = (void*)0;
            float *l_249 = &g_54;
            (*l_249) = ((float)0x8.Fp+1 * (float)((((float)((float)(*g_125) - (float)(-(float)((((((((float)0xA.DEB179p+22 * (float)0xC.6E3802p+95) < ((((float)0x0.7p-1 - (float)(!(((((((float)0x0.Bp+1 + (float)(0x7.C57E4Fp+23 == ((g_49 <= ((void*)0 != &g_86)) >= l_245))) < 0x1.440EA3p-75) >= (-0x6.8p+1)) > (-0x1.8p-1)) >= l_246) > l_246))) == g_2) >= g_54)) > 0x6.608D48p+23) != l_246) >= 0x6.0CB262p+5) >= (****l_192)) >= (-0x2.5p-1)))) - (float)0xA.818BB1p+71) == g_54) <= (-0x1.3p+1)));
        }
    }
    else
    { /* block id: 90 */
        int32_t *l_250 = &g_2;
        (**l_193) = l_250;
        /* statement id: 91 */
        assert (g_19 == &g_2);
        for (p_10 = (-23); (p_10 < 23); p_10 += 4)
        { /* block id: 94 */
            (*l_184) = ((~(-(uint8_t)((**g_86) == (void*)0))) || g_48);
        }
        l_261 = ((l_184 == l_250) > (!(247U != (((*l_250) == ((uint32_t)((int8_t)p_9 % (int8_t)p_10) - (uint32_t)l_260)) > (&l_193 == &g_86)))));
    }
    if ((&g_18 == (*l_192)))
    { /* block id: 99 */
        const int32_t *l_280 = &l_261;
        const int32_t ** const l_279 = &l_280;
        (*g_264) = (0xF.C4CCA3p+61 >= ((float)p_8 - (float)(*g_90)));
        for (l_245 = 0; (l_245 > (-20)); l_245 -= 6)
        { /* block id: 103 */
            int32_t ****l_278 = &l_193;
            g_267 = g_267;
            (**g_269) = (**g_269);
            (**g_270) = (0xDB80F26F || (((int8_t)((int8_t)(l_278 == l_278) * (int8_t)(*l_184)) * (int8_t)(l_279 != (*l_193))) && (0xEF <= ((int16_t)(0 == ((void*)0 == (*g_87))) >> (int16_t)7))));
        }
    }
    else
    { /* block id: 108 */
        int16_t l_289 = 5;
        int32_t *l_300 = (void*)0;
        uint16_t l_301 = 65535U;
        const uint32_t l_302 = 0xD086A49E;
        if ((((int32_t)(-(int16_t)(0x7581 == (((int8_t)(~((0x4CE292E2 != (l_289 && ((int8_t)(***l_193) << (int8_t)3))) == ((uint16_t)((uint8_t)(****l_192) << (uint8_t)1) - (uint16_t)((*g_267) != (void*)0)))) % (int8_t)(*l_184)) <= ((int32_t)((((int32_t)((void*)0 != l_300) % (int32_t)g_2) || l_301) > 0x1D) + (int32_t)0xAD33D034)))) % (int32_t)0xA8265699) == l_302))
        { /* block id: 109 */
            float **l_305 = &l_304;
            l_305 = l_303;
        }
        else
        { /* block id: 111 */
            uint32_t l_319 = 0U;
            int32_t **l_324 = &l_184;
            int32_t * const *l_330 = (void*)0;
            int32_t * const **l_329 = &l_330;
            int32_t * const ***l_328 = &l_329;
            float *l_347 = (void*)0;
            int8_t l_352 = (-1);
            int16_t l_361 = 0xF110;
            for (p_8 = 19; (p_8 >= 21); p_8 += 4)
            { /* block id: 114 */
                int32_t **l_310 = &l_184;
                (***g_269) = (((int8_t)((((p_9 <= (l_310 != (void*)0)) <= ((uint16_t)p_10 >> (uint16_t)9)) || (((int16_t)(7 ^ (p_9 | ((int16_t)(((uint8_t)0x91 >> (uint8_t)1) >= ((0x5EB5E7AD ^ 0U) | p_9)) % (int16_t)l_319))) + (int16_t)g_49) ^ 4294967288U)) < g_48) << (int8_t)0) & (**l_310));
                for (p_10 = 0; (p_10 < 14); p_10 += 1)
                { /* block id: 118 */
                    int32_t * const *l_325 = (void*)0;
                    float l_331 = (-0x1.2p-1);
                    (**l_303) = ((float)(l_324 == l_325) * (float)((p_10 < ((float)((l_328 != (void*)0) > ((l_331 < ((*g_264) >= (p_10 != 0x2.0657D7p-0))) < g_49)) + (float)p_8)) >= g_2));
                    (***g_269) = (0x65 || p_10);
                }
            }
            if (((int16_t)((*g_267) == (void*)0) >> (int16_t)8))
            { /* block id: 123 */
                float l_348 = 0x5.38A905p+8;
                int32_t l_349 = 0;
                for (l_261 = 0; (l_261 < 15); l_261 += 8)
                { /* block id: 126 */
                    int32_t l_338 = 0x81AABCE9;
                    int32_t l_353 = (-1);
                    (*****g_267) = ((int16_t)((g_2 != l_338) | ((((uint8_t)((int8_t)(((0xBD7C >= (g_48 >= (((int16_t)g_49 * (int16_t)(((uint8_t)((l_347 != (void*)0) <= (l_349 < ((uint8_t)(g_2 < p_9) - (uint8_t)l_349))) * (uint8_t)(**l_324)) || p_9)) == 0))) | (**l_324)) & p_9) % (int8_t)l_352) + (uint8_t)9U) < l_353) ^ p_10)) * (int16_t)g_2);
                }
                (**l_303) = (-(float)((((float)(l_300 != (void*)0) * (float)((0x7.372CC0p-91 <= (*g_53)) == ((float)(((float)((l_361 < (p_10 >= ((p_10 >= ((-(float)(((float)((((-0x10.6p-1) <= 0x1.8p-1) > l_349) != p_9) - (float)l_349) < p_10)) != 0x3.3B0911p+85)) < g_54))) > p_8) + (float)p_8) <= g_54) - (float)(**l_324)))) > 0x3.DA6E1Cp-49) >= 0xC.71F425p+35));
            }
            else
            { /* block id: 130 */
                (*l_328) = (void*)0;
                /* statement id: 131 */
                assert (l_329 == 0);
            }
            /* facts after branching */
            assert (l_329 == 0 || l_329 == &l_330);
        }
        (**l_303) = ((float)(((*g_53) >= (*l_184)) >= (((0x6.8p-1 >= (!((((g_267 != g_267) >= (-(float)0x0.Ep+1)) > (g_54 != ((-(float)((((float)(g_2 >= (g_54 < 0x2.Fp+1)) - (float)p_8) == g_54) == p_9)) == g_54))) > g_54))) == p_8) >= l_372)) * (float)0xB.14FEBEp-19);
        (*l_304) = ((((0x7.3896E1p-40 > ((0x1.3p-1 != (((p_10 >= 0xA.2FDE8Dp-72) >= (*g_53)) == ((g_49 == ((float)((void*)0 != &l_300) + (float)0x5.712D7Dp-19)) >= p_10))) >= p_9)) == g_49) < 0x4.ACA435p-45) > (*l_184));
    }
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads : g_18 g_2 g_19 g_53 g_54 g_49 g_86 g_90 g_87 g_103 g_105 g_48 g_125 g_138 g_151
 * writes: g_19 g_49 g_54
 */
static uint16_t  func_11(int8_t  p_12, int32_t  p_13, uint8_t  p_14)
{ /* block id: 4 */
    int32_t *l_16 = &g_2;
    int32_t ***l_172 = &g_87;
    int32_t ****l_171 = &l_172;
    (*g_18) = l_16;
    /* statement id: 5 */
    assert (g_19 == &g_2);
    (*l_171) = func_20(((int8_t)p_14 >> (int8_t)0), ((!0xA.39F3FAp-82) <= (-0x1.6p+1)), func_27(p_13, p_13));
    /* statement id: 79 */
    assert (g_19 == &g_2 || g_19 == &g_49);
    return g_48;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_19 g_53 g_54 g_49 g_86 g_90 g_87 g_103 g_105 g_48 g_125 g_138 g_151
 * writes: g_49 g_54 g_19
 */
static int32_t *** func_20(int8_t  p_21, const float  p_22, int32_t  p_23)
{ /* block id: 8 */
    int32_t **l_45 = &g_19;
    int32_t *l_92 = &g_2;
    int32_t * const *l_91 = &l_92;
    int8_t l_148 = 4;
    int32_t l_165 = 0xA9BDD0B6;
    float l_170 = 0x6.0p-1;
    for (p_23 = 0; (p_23 <= (-29)); p_23--)
    { /* block id: 11 */
        int32_t **l_38 = &g_19;
        int32_t *l_104 = (void*)0;
        uint16_t l_117 = 0x06E7;
        int8_t l_141 = (-4);
        float *l_150 = &g_54;
        (*g_105) = func_32(l_38, ((g_2 >= (-(float)((float)((func_42(l_45, func_27(p_21, g_2)) == (((void*)0 != l_91) < 0x0.Cp+1)) != (-0x1.Cp+1)) + (float)(*l_92)))) < p_21), p_21, g_2, p_23);
        if (((uint8_t)1U >> (uint8_t)3))
        { /* block id: 45 */
            int32_t *l_118 = &g_49;
            for (p_21 = (-13); (p_21 == 12); p_21 += 6)
            { /* block id: 48 */
                int32_t *l_110 = &g_49;
                (*g_87) = l_110;
                /* statement id: 49 */
                assert (g_19 == &g_49);
            }
            (*g_105) = ((int16_t)((uint8_t)p_21 - (uint8_t)(g_49 ^ g_2)) + (int16_t)(((((**l_91) || ((*l_45) == (void*)0)) ^ (((int16_t)((**l_45) ^ (**l_38)) << (int16_t)0) <= (**l_38))) | g_48) ^ l_117));
            (*l_38) = (void*)0;
            /* statement id: 52 */
            assert (g_19 == 0);
            (*l_45) = l_118;
            /* statement id: 53 */
            assert (g_19 == &g_49);
        }
        else
        { /* block id: 54 */
            uint16_t l_128 = 0x4C62;
            int32_t *l_131 = &g_2;
            int32_t *l_132 = (void*)0;
            float *l_149 = &g_54;
            (*g_87) = (**g_86);
            for (p_21 = 0; (p_21 <= (-17)); p_21 -= 1)
            { /* block id: 58 */
                uint8_t l_124 = 0x35;
                int32_t ***l_126 = &l_38;
                int32_t l_133 = 0xDD168C87;
                if (((int16_t)(((void*)0 == (*g_87)) && p_23) - (int16_t)p_23))
                { /* block id: 59 */
                    int32_t **l_123 = &g_19;
                    (*l_123) = (*l_91);
                    /* statement id: 60 */
                    assert (g_19 == &g_2);
                }
                else
                { /* block id: 61 */
                    (*g_125) = l_124;
                }
                l_133 = (l_124 > ((((l_126 == &l_38) & ((((((-(int32_t)l_128) != 0x48) == (((((*g_86) != (*l_126)) && (((((int8_t)(((l_131 != l_132) < p_23) | g_48) * (int8_t)254U) || (***l_126)) | (-2)) > (*l_131))) > 7) < g_49)) ^ 0xDA4F) & (*l_92)) == (***g_86))) == 0x8462) && 8));
            }
            for (l_128 = (-14); (l_128 > 54); l_128 += 1)
            { /* block id: 68 */
                uint8_t l_136 = 252U;
                (*g_138) = l_136;
            }
            (*l_149) = ((*g_53) == ((((float)(0x1.1p+1 == (((l_141 != ((float)0x0.Ep+1 - (float)(0x1.Fp-1 <= g_2))) < ((float)(&g_87 != (void*)0) * (float)((((float)0x0.5p-1 - (float)0x9.43FC1Ep-89) >= p_21) != g_54))) != 0x8.F256DAp+19)) + (float)p_23) < p_22) == l_148));
        }
        (*l_150) = ((l_150 == (void*)0) == 0x0.Ap-1);
    }
    /* facts after for loop */
    assert (g_19 == &g_2 || g_19 == &g_49);
    (*g_151) = (**l_91);
    l_165 = (g_49 & ((((((*g_138) | ((uint16_t)((void*)0 != &g_87) << (uint16_t)2)) | ((uint8_t)((((uint16_t)(((-(int32_t)(&g_87 != &l_91)) | ((int16_t)g_49 >> (int16_t)((uint32_t)(((((***g_86) | (((uint32_t)(g_49 >= (**l_45)) + (uint32_t)0) | g_49)) || 0x6B46) < p_23) && g_2) - (uint32_t)g_49))) == 4294967295U) % (uint16_t)(**l_91)) & 0xF14F5BEE) ^ g_2) + (uint8_t)g_2)) != g_2) > (**l_45)) < (**g_87)));
    l_170 = ((p_22 == ((&l_92 == &l_92) != (*g_90))) != (!(0x0.2p+1 != ((!(**l_91)) < ((float)(((void*)0 != &l_92) == g_2) * (float)p_22)))));
    return &g_87;
    /* statement id: 78 */
    //assert (func_20_rv == &g_87);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_27(uint16_t  p_28, const uint32_t  p_29)
{ /* block id: 6 */
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads : g_86 g_87 g_19 g_103
 * writes: g_49
 */
static int32_t  func_32(int32_t ** p_33, float  p_34, uint16_t  p_35, int8_t  p_36, int32_t  p_37)
{ /* block id: 41 */
    uint32_t l_96 = 1U;
    uint16_t l_102 = 4U;
    (*g_103) = ((-8) != ((uint8_t)(4294967295U & (5U != (((p_35 >= ((-(uint16_t)l_96) > ((void*)0 == (**g_86)))) >= (!((uint8_t)0U << (uint8_t)((int16_t)0xA435 << (int16_t)l_96)))) == 0x348F))) % (uint8_t)l_102));
    return l_96;
}


/* ------------------------------------------ */
/* 
 * reads : g_19 g_49 g_53 g_2 g_54 g_86 g_90
 * writes: g_49 g_54 g_19
 */
static float  func_42(int32_t ** p_43, uint8_t  p_44)
{ /* block id: 12 */
    float l_82 = 0x8.CFB115p-46;
    int32_t l_85 = 0x2CC684CA;
    int32_t **l_88 = (void*)0;
    float *l_89 = (void*)0;
    (*p_43) = func_46((*p_43));
    for (p_44 = 0; (p_44 >= 6); p_44++)
    { /* block id: 35 */
        return (*g_53);
    }
    (*g_53) = ((float)(*g_53) + (float)(((float)((float)l_82 + (float)((float)(-0x1.4p+1) * (float)g_2)) * (float)(l_85 < (((void*)0 != p_43) >= g_49))) > ((g_86 != &g_87) < p_44)));
    (*g_90) = ((void*)0 == l_88);
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_53 g_2 g_19
 * writes: g_49 g_54 g_19
 */
static int32_t * func_46(int32_t * p_47)
{ /* block id: 13 */
    float l_62 = 0x0.764969p+46;
    int32_t **l_67 = &g_19;
    for (g_49 = 0; (g_49 > 23); g_49 += 4)
    { /* block id: 16 */
        float l_52 = 0x9.Fp-1;
        int32_t l_61 = 0xF5BF8160;
        int32_t ***l_68 = &l_67;
        (*g_53) = l_52;
        (**l_68) = func_55(l_61, l_62, g_2, l_61, func_63(&p_47, ((void*)0 == l_67), (l_61 != (&g_18 == l_68))));
        /* statement id: 28 */
        assert (g_19 == 0);
        assert (p_47 == &g_2);
    }
    /* facts after for loop */
    assert (g_19 == 0 || g_19 == &g_2 || g_19 == &g_49);
    (*l_67) = (*l_67);
    return p_47;
    /* statement id: 31 */
    //assert (func_46_rv == &g_2 || func_46_rv == &g_49);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_55(uint32_t  p_56, float  p_57, const int8_t  p_58, int32_t  p_59, float * p_60)
{ /* block id: 21 */
    int32_t *l_73 = (void*)0;
    for (p_59 = 0; (p_59 < 8); p_59 += 2)
    { /* block id: 24 */
        if (p_59)
            break;
    }
    return l_73;
    /* statement id: 27 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_63(int32_t ** p_64, uint32_t  p_65, float  p_66)
{ /* block id: 18 */
    int32_t *l_69 = &g_2;
    float *l_70 = &g_54;
    (*p_64) = l_69;
    /* statement id: 19 */
    //assert (p_47 == &g_2);
    return l_70;
    /* statement id: 20 */
    //assert (func_63_rv == &g_54);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_48, "g_48", print_hash_value);
    transparent_crc(g_49, "g_49", print_hash_value);
    transparent_crc_bytes (&g_54, sizeof(g_54), "g_54", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 71
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 21
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 4
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 84

XXX times a variable address is taken: 81
XXX times a pointer is dereferenced on RHS: 68
breakdown:
   depth: 1, occurrence: 38
   depth: 2, occurrence: 19
   depth: 3, occurrence: 9
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 37
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 26
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 10
XXX times a pointer is qualified to be dereferenced: 248

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 211
   level: 2, occurrence: 82
   level: 3, occurrence: 35
   level: 4, occurrence: 5
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 40
XXX number of pointers point to scalars: 44
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 21.4
XXX average alias set size: 1.07

XXX times a non-volatile is read: 384
XXX times a non-volatile is write: 111
XXX times a volatile is read: 29
XXX    times read thru a pointer: 8
XXX times a volatile is write: 18
XXX    times written thru a pointer: 5
XXX times a volatile is available for access: 90
XXX percentage of non-volatile access: 91.3

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 87
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 20
   depth: 2, occurrence: 23
   depth: 3, occurrence: 9
   depth: 4, occurrence: 5

XXX percentage a fresh-made variable is used: 20.6
XXX percentage an existing variable is used: 79.4
********************* end of statistics **********************/

