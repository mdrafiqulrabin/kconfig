/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1944502464
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_32(void);
static int32_t * func_36(int32_t ** p_37, int32_t  p_38, int32_t * p_39, int32_t ** p_40, uint32_t  p_41);
inline static int32_t  func_42(int16_t  p_43, uint64_t  p_44);
static int32_t * func_51(int32_t * p_52, int32_t * p_53, int32_t ** p_54, int64_t  p_55);
inline static int32_t * func_56(uint32_t  p_57, int32_t * p_58, int16_t  p_59);
inline static uint16_t  func_75(uint32_t  p_76, int32_t ** p_77, uint32_t  p_78, uint16_t  p_79, int16_t  p_80);
inline static int32_t * func_81(int32_t  p_82);
static int64_t  func_110(uint16_t  p_111, uint64_t  p_112, uint64_t  p_113, uint8_t  p_114, uint64_t  p_115);
inline static uint64_t  func_116(int32_t * p_117, int32_t ** p_118, int32_t ** p_119, int32_t ** p_120);
static int32_t * func_121(uint64_t  p_122, int16_t  p_123, int32_t ** p_124);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_32(void)
{ /* block id: 36 */
    int32_t l_35 = 1L;
    int32_t *l_34 = &l_35;
    int32_t **l_33 = &l_34;
    int64_t l_500 = 0x2CCF0B8B5409C428LL;
    (*l_33) = (void*)0;
    /* statement id: 37 */
    assert (l_34 == 0);
    (*l_33) = func_36(&l_34, func_42(l_35, (&l_34 == &l_34)), (*l_33), &l_34, (((*l_33) == (*l_33)) & 0x3E17F145L));
    if (l_35)
    { /* block id: 278 */
        int32_t *l_485 = &l_35;
        int32_t l_486 = 0x3FE9918FL;
        uint8_t l_491 = 0UL;
        int32_t ***l_493 = &l_33;
        int32_t ****l_492 = &l_493;
        l_485 = func_81(((*l_33) == l_485));
        /* statement id: 279 */
        assert (l_485 == 0);
        (*l_33) = (*l_33);
        (*l_492) = &l_33;
    }
    else
    { /* block id: 282 */
        int32_t ***l_494 = &l_33;
        int32_t l_499 = 0x1676639DL;
        (*l_494) = &l_34;
        l_499 = (((uint64_t)((**l_494) != (void*)0) - (uint64_t)__builtin_ctzll(l_35)) > (__builtin_ia32_crc32qi(l_499, l_35) != l_35));
        (*l_33) = (void*)0;
    }
    return l_500;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(int32_t ** p_37, int32_t  p_38, int32_t * p_39, int32_t ** p_40, uint32_t  p_41)
{ /* block id: 254 */
    uint32_t l_459 = 0xB8E9D4F1L;
    int32_t l_474 = (-1L);
    int32_t *l_473 = &l_474;
    int32_t ***l_480 = (void*)0;
    int32_t ****l_479 = &l_480;
    int32_t *l_483 = &l_474;
    int32_t *l_484 = (void*)0;
    for (p_38 = (-29); (p_38 > 23); p_38 += 1)
    { /* block id: 257 */
        int32_t l_454 = 0L;
        int32_t *l_453 = &l_454;
        int32_t l_472 = 0xA30C8913L;
        int32_t *****l_481 = (void*)0;
        int32_t *****l_482 = &l_479;
        (*p_37) = l_453;
        /* statement id: 258 */
        //assert (l_34 == &l_454);
        if ((*l_453))
            continue;
        //assert (l_34 == dangling);
        for (l_454 = 0; (l_454 < (-29)); l_454 -= 1)
        { /* block id: 262 */
            int32_t **l_467 = &l_453;
            int32_t ***l_466 = &l_467;
            int32_t ****l_465 = &l_466;
            for (p_41 = 3; (p_41 == 44); p_41++)
            { /* block id: 265 */
                int32_t **l_464 = &l_453;
                int32_t ***l_463 = &l_464;
                int32_t ****l_462 = &l_463;
                if (l_459)
                    break;
                l_472 = (2UL ^ ((((l_462 != l_465) > 18446744073709551615UL) | (&p_37 != (void*)0)) | ((int16_t)((int64_t)0x96B44387E8C34437LL - (int64_t)func_42((p_41 == p_38), p_38)) << (int16_t)1)));
            }
            (**l_466) = (*p_37);
            l_473 = (*p_37);
            /* statement id: 270 */
            assert (l_473 == &l_454);
            l_474 = ((func_42(p_41, ((*l_453) && 0x7FD8L)) != ((int16_t)(((*l_473) || (***l_466)) & (0xA2A857ABA26CF543LL >= (((*l_473) | ((int16_t)p_41 >> (int16_t)p_41)) == p_41))) >> (int16_t)p_41)) >= p_41);
        }
        /* facts after for loop */
        //assert (l_473 == &l_454 || l_473 == dangling || l_473 == &l_474);
        (*l_482) = l_479;
    }
    /* facts after for loop */
    //assert (l_34 == dangling || l_34 == 0);
    //assert (l_473 == dangling || l_473 == &l_474);
    p_38 = (6UL && l_474);
    return l_484;
    /* statement id: 276 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_42(int16_t  p_43, uint64_t  p_44)
{ /* block id: 38 */
    int16_t l_47 = (-7L);
    int32_t l_48 = (-10L);
    int32_t l_363 = 1L;
    int32_t *l_369 = (void*)0;
    int32_t **l_368 = &l_369;
    uint32_t l_380 = 6UL;
    int64_t l_384 = (-3L);
    int64_t l_404 = 0xE552FFEF7812CA25LL;
    int32_t ***l_444 = &l_368;
    int32_t ****l_443 = &l_444;
    l_48 = ((uint64_t)__builtin_popcount(l_47) - (uint64_t)(l_47 == 0xA4C5706BL));
    for (l_48 = 25; (l_48 >= (-30)); l_48 -= 1)
    { /* block id: 42 */
        int16_t l_63 = 8L;
        int32_t *l_64 = &l_48;
        int32_t **l_294 = &l_64;
        uint32_t l_383 = 18446744073709551615UL;
        (*l_294) = func_51(&l_48, func_56(((int32_t)(-(uint64_t)l_63) % (int32_t)l_48), l_64, ((int16_t)((int16_t)(((int16_t)__builtin_ffs(l_47) - (int16_t)((uint16_t)((((int16_t)((p_43 | ((func_75((p_44 < 3UL), &l_64, p_43, l_47, p_43) ^ l_47) < 0x75416565E832032BLL)) == l_48) << (int16_t)13) <= (*l_64)) & p_43) >> (uint16_t)l_47)) == 2L) << (int16_t)11) << (int16_t)6)), &l_64, p_44);
        /* statement id: 158 */
        assert (l_64 == &l_48 || l_64 == 0);
        if (((uint64_t)(&l_64 == (void*)0) - (uint64_t)l_47))
        { /* block id: 159 */
            return p_43;
        }
        else
        { /* block id: 161 */
            int32_t l_299 = 1L;
            int32_t *l_332 = &l_48;
            int32_t ***l_395 = &l_368;
            int32_t *l_425 = &l_363;
            int16_t l_434 = (-1L);
            if ((((int16_t)0L % (int16_t)(l_299 ^ p_44)) > __builtin_parityl(p_44)))
            { /* block id: 162 */
                int32_t l_308 = 0xA68498C8L;
                uint32_t l_343 = 0UL;
                int32_t *l_350 = &l_48;
                int32_t l_360 = 0x10183994L;
                int32_t l_362 = 0x03896E17L;
                int32_t *l_361 = &l_362;
                if (p_43)
                { /* block id: 163 */
                    int32_t l_311 = 0x40C4DA91L;
                    int32_t **l_319 = &l_64;
                    if ((((int16_t)func_116(func_81((((uint32_t)((uint64_t)((uint16_t)l_308 << (uint16_t)11) % (uint64_t)((((l_299 == ((int32_t)((((l_299 == l_311) > l_308) ^ 0UL) > p_44) + (int32_t)0x777DDB8EL)) == (~((int16_t)(((uint16_t)(((uint16_t)l_311 << (uint16_t)11) && 18446744073709551609UL) >> (uint16_t)3) != p_44) << (int16_t)13))) || 0xA6FAL) | 0x4E5C6B99L)) - (uint32_t)0x905CFCB8L) != l_48)), &l_64, l_319, &l_64) - (int16_t)p_43) | 0xD45B81C3L))
                    { /* block id: 164 */
                        return p_44;
                    }
                    else
                    { /* block id: 166 */
                        (*l_294) = (void*)0;
                        /* statement id: 167 */
                        assert (l_64 == 0);
                    }
                    /* facts after branching */
                    assert (l_64 == 0);
                }
                else
                { /* block id: 169 */
                    int32_t *l_327 = &l_48;
                    int32_t l_349 = 0x8A6C8DEDL;
                    int32_t *l_348 = &l_349;
                    (*l_348) = ((int16_t)(-(int64_t)((int16_t)((int64_t)(&l_48 == l_327) + (int64_t)(((uint32_t)(__builtin_popcount(((((int32_t)((p_44 <= (l_332 == l_327)) | 0x67D7L) % (int32_t)func_110(p_44, (((int16_t)(((int16_t)(((uint64_t)l_343 % (uint64_t)((((int16_t)(((int16_t)((*l_327) != (*l_327)) % (int16_t)p_43) < 0x55A230B5BDB629B3LL) << (int16_t)(*l_327)) >= l_47) || 18446744073709551615UL)) <= p_43) >> (int16_t)0) && 0L) << (int16_t)p_43) != 0UL), p_44, (*l_332), p_43)) | (*l_327)) ^ 0x0CBC175E5F06EB51LL)) < 0xABB9L) + (uint32_t)p_43) || p_43)) >> (int16_t)l_343)) << (int16_t)6);
                    if (p_44)
                    { /* block id: 171 */
                        (*l_294) = l_350;
                        /* statement id: 172 */
                        assert (l_64 == &l_48);
                        (*l_348) = p_43;
                    }
                    else
                    { /* block id: 174 */
                        (*l_294) = func_121((*l_350), (*l_350), &l_348);
                        /* statement id: 175 */
                        assert (l_64 == 0);
                        (*l_294) = (void*)0;
                    }
                    (*l_348) = p_44;
                }
                (*l_361) = (0x5826BE5335BF8213LL == ((int16_t)0x7FDAL + (int16_t)((((((~(18446744073709551607UL == ((__builtin_popcountll((*l_350)) ^ ((-3L) == ((int16_t)__builtin_popcountll(p_43) >> (int16_t)10))) < (((uint16_t)l_360 << (uint16_t)(*l_350)) && p_44)))) & p_44) == 18446744073709551613UL) & p_43) & p_43) < p_44)));
            }
            else
            { /* block id: 181 */
                uint8_t l_364 = 0x5FL;
                int32_t ***l_367 = &l_294;
                int32_t l_373 = 0x89C14EC5L;
                l_363 = 1L;
                if (l_364)
                { /* block id: 183 */
                    int64_t l_370 = 0xD7715F622DDEA787LL;
                    int32_t *l_382 = &l_363;
                    l_373 = ((uint16_t)__builtin_ffsll(((*l_332) > l_373)) % (uint16_t)l_370);
                    for (p_44 = 0; (p_44 == 21); p_44 += 1)
                    { /* block id: 187 */
                        int32_t *l_381 = &l_363;
                        (**l_367) = l_332;
                        /* statement id: 188 */
                        assert (l_64 == &l_48);
                        (*l_381) = (*l_381);
                    }
                    for (l_370 = 0; (l_370 > (-25)); l_370 -= 7)
                    { /* block id: 193 */
                        (*l_382) = p_43;
                    }
                    if (((int16_t)(p_43 & 0xA6F3L) << (int16_t)4))
                    { /* block id: 196 */
                        (*l_382) = (*l_382);
                        (*l_294) = (*l_368);
                        /* statement id: 198 */
                        assert (l_64 == &l_363 || l_64 == &l_48 || l_64 == 0);
                    }
                    else
                    { /* block id: 199 */
                        int16_t l_389 = 0xB0C5L;
                        if (l_389)
                            break;
                    }
                    /* facts after branching */
                    assert (l_64 == &l_363 || l_64 == &l_48 || l_64 == 0);
                }
                else
                { /* block id: 202 */
                    int32_t *l_396 = &l_48;
                    for (l_383 = 0; (l_383 >= 54); l_383 += 1)
                    { /* block id: 205 */
                        uint8_t l_394 = 0xBAL;
                        (*l_294) = l_396;
                        /* statement id: 206 */
                        assert (l_64 == &l_48);
                    }
                    if ((((int16_t)((uint64_t)__builtin_ctz((*l_396)) + (uint64_t)((void*)0 == (*l_368))) + (int16_t)((-(uint64_t)p_43) ^ p_43)) | p_44))
                    { /* block id: 208 */
                        l_404 = (((*l_396) <= (*l_396)) | p_44);
                    }
                    else
                    { /* block id: 210 */
                        uint32_t l_405 = 0x4BB74991L;
                        int32_t *l_410 = &l_373;
                        l_363 = ((-7L) > (__builtin_clzll(l_405) < (*l_332)));
                        (*l_368) = l_396;
                        /* statement id: 212 */
                        assert (l_369 == &l_48);
                        (*l_410) = (((__builtin_popcountll(p_44) && p_43) && (((uint32_t)((uint16_t)(((**l_368) >= 0x78F9L) >= p_44) >> (uint16_t)((void*)0 != l_410)) - (uint32_t)0xEFD7E304L) & (***l_395))) <= (*l_396));
                        (*l_410) = func_75(p_43, &l_410, __builtin_parityl((p_44 <= (-3L))), ((int64_t)((uint64_t)p_44 % (uint64_t)__builtin_ctz(((uint16_t)((int16_t)((uint32_t)(0xA2AA58F5251EB5EDLL == ((int16_t)(*l_369) + (int16_t)p_43)) + (uint32_t)p_44) / (int16_t)(*l_396)) - (uint16_t)0xFFCEL))) - (int64_t)p_43), p_43);
                    }
                    if (p_43)
                    { /* block id: 216 */
                        l_373 = ((int16_t)1L + (int16_t)(p_44 > 0x1249L));
                    }
                    else
                    { /* block id: 218 */
                        (*l_368) = l_396;
                        /* statement id: 219 */
                        assert (l_369 == &l_48);
                        if (p_44)
                            continue;
                        (*l_367) = &l_369;
                        /* statement id: 221 */
                        assert (l_294 == &l_369);
                    }
                    /* facts after branching */
                    assert (l_294 == &l_369 || l_294 == &l_64);
                }
                /* facts after branching */
                assert (l_64 == &l_363 || l_64 == &l_48 || l_64 == 0);
                assert (l_294 == &l_369 || l_294 == &l_64);
                if (p_44)
                { /* block id: 224 */
                    (*l_294) = l_425;
                }
                else
                { /* block id: 226 */
                    return p_44;
                }
            }
            /* facts after branching */
            assert (l_64 == &l_363 || l_64 == &l_48 || l_64 == 0);
            assert (l_294 == &l_369 || l_294 == &l_64);
            (*l_425) = (((uint64_t)((uint16_t)(&l_294 == l_395) << (uint16_t)(l_63 != p_44)) - (uint64_t)p_44) < ((((int16_t)0L + (int16_t)(l_434 | ((*l_425) < (((*l_332) | p_43) > p_44)))) || p_43) & p_44));
        }
        /* facts after branching */
        assert (l_64 == &l_363 || l_64 == 0 || l_64 == &l_48);
        assert (l_294 == &l_369 || l_294 == &l_64);
    }
    /* facts after for loop */
    assert (l_369 == &l_363 || l_369 == &l_48 || l_369 == 0);
    (*l_368) = func_81(p_43);
    /* statement id: 233 */
    assert (l_369 == 0);
    for (p_44 = (-14); (p_44 <= 60); p_44 += 1)
    { /* block id: 236 */
        int32_t *l_437 = &l_48;
        uint64_t l_445 = 0xD59C3C4198429342LL;
        int32_t ***l_446 = &l_368;
    }
    return l_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(int32_t * p_52, int32_t * p_53, int32_t ** p_54, int64_t  p_55)
{ /* block id: 139 */
    uint32_t l_284 = 0UL;
    int32_t **l_286 = (void*)0;
    int32_t ***l_285 = &l_286;
    int32_t l_293 = 0xAED0E2EEL;
    for (p_55 = 0; (p_55 <= 19); p_55 += 4)
    { /* block id: 142 */
        int32_t l_269 = 0x65D2405DL;
        int32_t *l_268 = &l_269;
        int32_t **l_267 = &l_268;
        int32_t ***l_266 = &l_267;
        int32_t ****l_270 = &l_266;
        (*l_270) = l_266;
        (*l_270) = &p_54;
        /* statement id: 144 */
        assert (l_266 == &p_54);
        if ((*l_268))
        { /* block id: 145 */
            int32_t *l_271 = (void*)0;
            return l_271;
            /* statement id: 146 */
            //assert (func_51_rv == 0);
        }
        else
        { /* block id: 147 */
            int32_t *l_272 = &l_269;
            return (*p_54);
            /* statement id: 148 */
            //assert (func_51_rv == &l_48);
        }
    }
    (*p_54) = func_56((-(int32_t)((uint64_t)0UL + (uint64_t)((int16_t)((uint16_t)(((uint32_t)((uint16_t)l_284 - (uint16_t)l_284) - (uint32_t)(l_285 == &l_286)) || 0x1CB5L) / (uint16_t)p_55) << (int16_t)(~(((((p_55 > (((void*)0 != &l_285) <= p_55)) == 0x8D39L) <= p_55) || (*p_52)) >= p_55))))), (*p_54), p_55);
    if ((p_55 >= ((*l_285) == &p_52)))
    { /* block id: 152 */
        int16_t l_292 = (-2L);
        l_293 = (__builtin_ctz(p_55) && ((int16_t)0x343AL << (int16_t)((int16_t)p_55 / (int16_t)((&p_54 != &p_54) | l_292))));
    }
    else
    { /* block id: 154 */
        return (*p_54);
        /* statement id: 155 */
        //assert (func_51_rv == &l_48);
    }
    return (*p_54);
    /* statement id: 157 */
    //assert (func_51_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads : l_48
 * writes:
 */
inline static int32_t * func_56(uint32_t  p_57, int32_t * p_58, int16_t  p_59)
{ /* block id: 76 */
    int32_t l_191 = (-1L);
    int32_t *l_190 = &l_191;
    int32_t **l_189 = &l_190;
    int32_t **l_263 = &l_190;
    for (p_59 = 0; (p_59 > (-21)); p_59 -= 1)
    { /* block id: 79 */
        int32_t **l_192 = &l_190;
        int16_t l_224 = 0xAFF5L;
        int32_t *l_254 = &l_191;
        int32_t *l_255 = &l_191;
        if (((uint32_t)(((void*)0 != p_58) & func_116(p_58, l_189, &p_58, l_192)) + (uint32_t)(*p_58)))
        { /* block id: 80 */
            int64_t l_193 = 0x2555567A964C9D42LL;
            int32_t l_194 = (-1L);
            l_194 = (1UL & ((0xE8534C0AFD8232EDLL && (4294967295UL >= __builtin_parityll((p_57 | (p_57 ^ __builtin_popcountll((*l_190))))))) & (__builtin_clzll(((__builtin_bswap32(p_59) == 0x48EFL) >= l_193)) | (**l_189))));
            (**l_189) = l_194;
        }
        else
        { /* block id: 83 */
            (**l_192) = ((p_58 != p_58) != ((int16_t)0x9DE9L % (int16_t)p_57));
        }
        if ((*p_58))
        { /* block id: 86 */
            int32_t l_208 = 2L;
            if (((uint64_t)((int16_t)((int64_t)(((p_57 == ((uint32_t)((((((uint64_t)(__builtin_ffsll(p_57) | ((*l_192) != p_58)) - (uint64_t)(1L <= (*p_58))) || p_57) < p_59) <= 1UL) < (**l_189)) + (uint32_t)0x6FC58545L)) ^ p_57) != (**l_189)) % (int64_t)0x385C65EB62234214LL) << (int16_t)0) + (uint64_t)(**l_192)))
            { /* block id: 87 */
                int16_t l_207 = (-8L);
                if (l_207)
                    break;
                l_208 = l_207;
            }
            else
            { /* block id: 90 */
                if ((*l_190))
                    break;
                for (p_57 = 20; (p_57 < 27); p_57++)
                { /* block id: 94 */
                    int32_t **l_211 = &l_190;
                }
            }
            for (l_191 = 0; (l_191 > 11); l_191 += 4)
            { /* block id: 102 */
                uint32_t l_215 = 0x8D72E106L;
                int32_t l_239 = 0x2A7C57E4L;
            }
        }
        else
        { /* block id: 126 */
            if ((*l_190))
                break;
        }
        (**l_192) = ((void*)0 != (*l_192));
        return p_58;
        /* statement id: 130 */
        //assert (func_56_rv == &l_48);
    }
    (**l_189) = (*p_58);
    if (((int16_t)(!((uint16_t)((int16_t)0x9E25L << (int16_t)((void*)0 == l_263)) / (uint16_t)p_59)) << (int16_t)0))
    { /* block id: 133 */
        (*l_189) = func_81((*l_190));
        /* statement id: 134 */
        assert (l_190 == 0);
    }
    else
    { /* block id: 135 */
        (*l_263) = p_58;
        /* statement id: 136 */
        //assert (l_190 == &l_48);
    }
    /* facts after branching */
    //assert (l_190 == &l_48 || l_190 == 0);
    return p_58;
    /* statement id: 138 */
    //assert (func_56_rv == &l_48);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_75(uint32_t  p_76, int32_t ** p_77, uint32_t  p_78, uint16_t  p_79, int16_t  p_80)
{ /* block id: 43 */
    int32_t l_100 = 0x66A4358BL;
    int32_t *l_99 = &l_100;
    int64_t l_107 = (-7L);
    uint32_t l_171 = 1UL;
    l_99 = func_81(((uint64_t)((int16_t)p_78 << (int16_t)5) % (uint64_t)p_79));
    /* statement id: 47 */
    assert (l_99 == 0);
    for (p_80 = 0; (p_80 <= (-7)); p_80 -= 1)
    { /* block id: 50 */
        int32_t l_106 = 0xFDC3C1A3L;
        l_100 = (!((uint64_t)(l_106 & __builtin_parityl(p_76)) - (uint64_t)p_78));
    }
    if ((l_107 == ((uint16_t)(((&l_100 != &l_100) & func_110(p_78, func_116(func_121(p_79, p_79, &l_99), &l_99, &l_99, p_77), l_107, p_79, l_100)) >= l_171) << (uint16_t)13)))
    { /* block id: 64 */
        int64_t l_174 = 3L;
        int64_t l_179 = (-1L);
        int32_t *l_180 = &l_100;
        (*l_180) = ((uint16_t)(l_174 <= 0x2B6AL) << (uint16_t)__builtin_parityl((((int16_t)l_107 << (int16_t)((int64_t)l_179 % (int64_t)p_78)) > (**p_77))));
        for (p_76 = 0; (p_76 < 15); p_76 += 8)
        { /* block id: 68 */
            return p_80;
        }
        l_99 = func_121(p_76, ((uint16_t)((0UL == (&l_180 == (void*)0)) <= p_78) + (uint16_t)p_76), &l_99);
    }
    else
    { /* block id: 72 */
        l_99 = func_81((**p_77));
    }
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_81(int32_t  p_82)
{ /* block id: 44 */
    uint8_t l_87 = 1UL;
    int32_t *l_88 = (void*)0;
    int32_t l_90 = (-2L);
    int32_t *l_89 = &l_90;
    int32_t *l_91 = &l_90;
    int32_t *l_92 = &l_90;
    int32_t *l_93 = &l_90;
    int32_t *l_94 = &l_90;
    int32_t *l_95 = &l_90;
    int32_t *l_96 = &l_90;
    int32_t *l_97 = &l_90;
    int32_t *l_98 = (void*)0;
    (*l_89) = l_87;
    return l_98;
    /* statement id: 46 */
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_110(uint16_t  p_111, uint64_t  p_112, uint64_t  p_113, uint8_t  p_114, uint64_t  p_115)
{ /* block id: 59 */
    uint16_t l_168 = 0xE9F9L;
    int32_t l_170 = 0xF1637F25L;
    int32_t *l_169 = &l_170;
    (*l_169) = l_168;
    (*l_169) = (*l_169);
    (*l_169) = (-3L);
    return p_113;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_116(int32_t * p_117, int32_t ** p_118, int32_t ** p_119, int32_t ** p_120)
{ /* block id: 57 */
    int32_t l_167 = 0xF03B65DDL;
    return l_167;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_121(uint64_t  p_122, int16_t  p_123, int32_t ** p_124)
{ /* block id: 53 */
    uint32_t l_131 = 4294967295UL;
    int32_t l_153 = 1L;
    int32_t l_155 = (-6L);
    int32_t *l_154 = &l_155;
    int32_t l_164 = 0xF53E4EB4L;
    int32_t *l_165 = &l_155;
    int32_t *l_166 = (void*)0;
    (*l_154) = ((int16_t)((int32_t)(((__builtin_ctzll(p_123) | ((int64_t)(((l_131 < __builtin_parityl(__builtin_clzll(((((int32_t)((((uint32_t)((int16_t)((uint16_t)1UL << (uint16_t)8) + (int16_t)(((int16_t)((l_131 && ((!((uint16_t)(l_131 & (!((~0x285EFCBABA1048D1LL) > p_123))) / (uint16_t)((int32_t)(((uint16_t)((int64_t)4L - (int64_t)p_122) << (uint16_t)p_123) <= 8UL) / (int32_t)l_131))) != l_131)) ^ l_153) >> (int16_t)l_153) <= p_123)) % (uint32_t)l_131) || 0xC2835E52L) || p_122) + (int32_t)l_153) <= l_131) | 1UL)))) == 65535UL) > 0x60A5L) / (int64_t)l_153)) < 0xC9A86FCAL) & l_153) + (int32_t)l_153) + (int16_t)l_153);
    (*l_154) = (__builtin_ffs(((int64_t)((uint64_t)(*l_154) % (uint64_t)0xB49816E0766B1C03LL) / (int64_t)((uint16_t)((void*)0 == &l_154) << (uint16_t)(*l_154)))) ^ (((int32_t)(((*l_154) && (*l_154)) & 0x26467E2B5FF26AE3LL) / (int32_t)l_164) <= p_123));
    return l_166;
    /* statement id: 56 */
    //assert (func_121_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 109
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 135
   depth: 2, occurrence: 19
   depth: 3, occurrence: 6
   depth: 4, occurrence: 7
   depth: 5, occurrence: 2
   depth: 7, occurrence: 3
   depth: 8, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1

XXX total number of pointers: 88

XXX times a variable address is taken: 113
XXX times a pointer is dereferenced on RHS: 94
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 13
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 63
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 10
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 415

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 232
   level: 2, occurrence: 87
   level: 3, occurrence: 35
   level: 4, occurrence: 6
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.9
XXX average alias set size: 1.25

XXX times a non-volatile is read: 574
XXX times a non-volatile is write: 179
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 124
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 34
   depth: 1, occurrence: 28
   depth: 2, occurrence: 16
   depth: 3, occurrence: 11
   depth: 4, occurrence: 13
   depth: 5, occurrence: 22

XXX percentage a fresh-made variable is used: 12.9
XXX percentage an existing variable is used: 87.1
********************* end of statistics **********************/

