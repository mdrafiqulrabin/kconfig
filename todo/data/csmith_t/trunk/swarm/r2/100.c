/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --math64 --no-inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3840686700
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   volatile unsigned f0 : 23;
};

/* --- GLOBAL VARIABLES --- */
static uint16_t g_8 = 65535U;
static int32_t g_49 = 0xD840DFE9;
static volatile uint16_t g_89 = 0x31B5;/* VOLATILE GLOBAL g_89 */
static int32_t g_105 = 0x2D5F2ABA;
static int32_t *g_104 = &g_105;
static uint32_t g_135 = 0xB3FDF2DC;
static int32_t * const *g_151 = &g_104;
static int32_t * const **g_150 = &g_151;
static union U0 g_159 = {8U};/* VOLATILE GLOBAL g_159 */
static union U0 **g_170 = (void*)0;
static volatile int32_t g_205 = (-1);/* VOLATILE GLOBAL g_205 */
static volatile int32_t *g_204 = &g_205;
static volatile int32_t **g_203 = &g_204;
static volatile int32_t ***g_202 = &g_203;
static uint8_t g_285 = 0xF5;
static union U0 g_300 = {0xC00C78AF};/* VOLATILE GLOBAL g_300 */
static uint16_t g_329 = 0x2C5E;
static int16_t g_348 = (-6);
static volatile uint8_t g_386 = 252U;/* VOLATILE GLOBAL g_386 */
static int32_t g_420 = 9;


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_29(void);
static uint16_t  func_33(uint32_t  p_34, uint16_t  p_35);
static uint32_t  func_43(const uint32_t  p_44, uint8_t  p_45);
static uint16_t  func_55(int32_t * p_56, uint32_t  p_57);
static int32_t  func_62(uint32_t  p_63, int32_t * p_64, int32_t  p_65, const int32_t * p_66, uint32_t  p_67);
static int32_t * func_71(uint32_t  p_72);
static uint32_t  func_73(int32_t  p_74, uint32_t  p_75, uint32_t  p_76);
static uint32_t  func_83(int32_t * p_84, int32_t  p_85, uint8_t  p_86);
static uint16_t  func_92(int32_t  p_93, const int16_t  p_94, int16_t  p_95);
static int32_t  func_141(uint32_t  p_142, const int16_t  p_143, int32_t * p_144);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_49 g_89 g_135 g_105 g_104 g_150 g_151 g_170 g_348 g_204 g_205 g_202 g_203 g_386 g_159.f0 g_329 g_420
 * writes: g_49 g_104 g_135 g_105 g_348 g_205 g_386 g_420 g_204
 */
static int16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 3U;
    int32_t **l_422 = (void*)0;
    int32_t **l_423 = (void*)0;
    int32_t *l_424 = (void*)0;
    if ((0x50F82BAE ^ (l_30 < ((((int16_t)((__builtin_ctzl(l_30) >= g_8) <= 0x1FC65786) << (int16_t)7) == func_33(((uint16_t)((int32_t)((~((uint32_t)func_43(g_8, ((~1U) < 0xF7C2F5A2)) / (uint32_t)g_8)) | l_30) - (int32_t)1) - (uint16_t)0U), l_30)) & (-1)))))
    { /* block id: 197 */
        uint8_t l_418 = 0xBB;
        int32_t *l_419 = &g_420;
        (*l_419) ^= (((uint16_t)func_92(g_205, ((l_30 && (g_329 >= 0)) >= __builtin_parity(l_30)), l_418) >> (uint16_t)l_30) == g_105);
    }
    else
    { /* block id: 199 */
        int32_t **l_421 = &g_104;
        (*l_421) = (*g_151);
    }
    (*g_203) = (*g_203);
    l_424 = func_71(g_8);
    return g_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_159.f0 g_105
 * writes: g_104
 */
static uint16_t  func_33(uint32_t  p_34, uint16_t  p_35)
{ /* block id: 193 */
    union U0 *l_413 = &g_159;
    union U0 **l_414 = &l_413;
    int32_t **l_415 = &g_104;
    (*l_414) = l_413;
    (*l_415) = func_71(g_159.f0);
    return g_105;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_49 g_89 g_135 g_105 g_104 g_150 g_151 g_170 g_348 g_204 g_205 g_202 g_203 g_386
 * writes: g_49 g_104 g_135 g_105 g_348 g_205 g_386
 */
static uint32_t  func_43(const uint32_t  p_44, uint8_t  p_45)
{ /* block id: 37 */
    int32_t *l_48 = &g_49;
    const uint32_t l_402 = 1U;
    uint32_t l_407 = 0x3E8CAEB4;
    (*l_48) |= (!g_8);
    if ((+(((uint32_t)0U - (uint32_t)g_8) > (((p_45 <= (l_48 != l_48)) & g_8) > (((uint16_t)func_55(&g_49, p_44) / (uint16_t)l_402) && g_105)))))
    { /* block id: 182 */
        const int32_t *l_403 = (void*)0;
        const int32_t **l_404 = &l_403;
        int32_t **l_408 = &g_104;
        (***g_202) ^= ((void*)0 != g_170);
        (*l_404) = l_403;
        if (g_348)
            goto lbl_409;
lbl_409:
        (*l_48) = (l_407 && ((void*)0 != l_408));
        (*g_204) = p_44;
    }
    else
    { /* block id: 188 */
        (***g_202) &= ((+__builtin_ctz(((uint16_t)__builtin_ffsll(g_49) >> (uint16_t)8))) <= (*l_48));
    }
    (***g_202) &= (**g_151);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_8 g_89 g_135 g_105 g_104 g_150 g_151 g_170 g_348 g_204 g_205 g_202 g_203 g_386
 * writes: g_49 g_104 g_135 g_105 g_348 g_205 g_386
 */
static uint16_t  func_55(int32_t * p_56, uint32_t  p_57)
{ /* block id: 39 */
    int32_t l_58 = 0xD579DEB4;
    int32_t *l_59 = (void*)0;
    int32_t l_70 = 0;
    int32_t l_265 = 0x82483C1F;
    int32_t l_272 = (-9);
    int32_t l_283 = 8;
    union U0 *l_298 = (void*)0;
    int32_t ***l_334 = (void*)0;
    uint8_t l_341 = 0xA8;
    uint8_t l_352 = 255U;
    int32_t l_355 = 0xB0487F14;
    (*p_56) &= l_58;
    (*p_56) = (((void*)0 == l_59) >= ((int16_t)((void*)0 == l_59) << (int16_t)2));
    if (func_62(((-9) & (((uint32_t)(g_49 > (2U | l_70)) / (uint32_t)g_49) == (p_57 || l_58))), func_71(func_73(g_8, (((~((int16_t)(l_59 != &g_49) >> (int16_t)p_57)) ^ l_58) > g_8), g_49)), g_8, l_59, p_57))
    { /* block id: 98 */
        int32_t l_197 = 0x3B3E4958;
        int32_t l_310 = 5;
        int32_t l_354 = 0xA795F43D;
        if ((((((func_141(g_89, g_49, p_56) >= ((-(int32_t)(*p_56)) ^ (l_197 >= l_197))) || __builtin_popcount(((p_57 == p_57) > (**g_151)))) <= p_57) >= l_197) & (*p_56)))
        { /* block id: 99 */
            uint32_t l_236 = 0U;
            int32_t l_249 = (-1);
            int32_t l_256 = 0x294B59A6;
            int32_t l_266 = (-6);
            int32_t **l_303 = &g_104;
            int32_t ***l_302 = &l_303;
            union U0 *l_306 = (void*)0;
            int32_t *l_336 = &l_197;
            int32_t *l_337 = (void*)0;
            int32_t *l_338 = &l_265;
            int32_t *l_339 = &l_249;
            int32_t *l_340 = &l_256;
            for (l_70 = 0; (l_70 >= (-3)); l_70--)
            { /* block id: 102 */
                int32_t **l_206 = &l_59;
                int32_t l_209 = (-9);
                int32_t l_210 = 0x2EDA5BF8;
                union U0 * const *l_301 = &l_298;
            }
            ++l_341;
        }
        else
        { /* block id: 148 */
            int32_t l_347 = 1;
            union U0 *l_353 = &g_300;
            int32_t l_370 = 0x3376282E;
            for (g_105 = 10; (g_105 > (-16)); g_105 -= 7)
            { /* block id: 151 */
                int16_t l_346 = 1;
                g_348 |= func_92(l_346, l_197, (l_347 < (*p_56)));
                (*g_204) |= (((((~(((int16_t)4 % (int16_t)l_352) <= (&g_300 != l_353))) & 0x8C4D48E7) | __builtin_popcountll((l_347 && func_92(p_57, p_57, func_92(l_310, l_346, l_354))))) < l_355) | 0xCF6DA364);
            }
            l_370 &= ((uint32_t)0xB847CEFB - (uint32_t)((l_310 | l_310) & ((((int32_t)(((uint16_t)(__builtin_parity((((int32_t)((uint16_t)((int16_t)p_57 % (int16_t)l_354) / (uint16_t)(((int32_t)((&l_334 != (void*)0) ^ l_347) / (int32_t)((0xD747B503 > p_57) | (*g_104))) ^ p_57)) - (int32_t)(***g_202)) ^ l_197)) >= 0x1E64) >> (uint16_t)5) || 0x8D98CD05) % (int32_t)p_57) || 0xF7DF0B75) <= 0x7DE6)));
        }
        for (l_310 = 17; (l_310 <= 0); l_310 -= 8)
        { /* block id: 159 */
            int32_t *l_374 = (void*)0;
            int32_t *l_375 = &l_197;
            int32_t *l_376 = &l_272;
            int32_t *l_377 = &l_283;
            int32_t *l_378 = &l_272;
            int32_t *l_379 = &l_272;
            int32_t *l_380 = &g_105;
            int32_t *l_381 = &g_105;
            int32_t *l_382 = &l_265;
            int32_t *l_383 = &l_272;
            int32_t *l_384 = &g_105;
            int32_t *l_385 = &l_272;
            p_56 = func_71((+(-1)));
            g_386--;
            l_374 = (*g_151);
        }
        for (l_354 = 0; (l_354 >= 9); l_354 += 3)
        { /* block id: 166 */
            uint8_t l_391 = 0x76;
            int32_t **l_395 = &l_59;
            l_391--;
            (*l_395) = func_71((~(-1)));
            (*p_56) = (*p_56);
        }
        (**g_151) = (l_197 & (__builtin_clz((0U < l_197)) & l_197));
    }
    else
    { /* block id: 172 */
        uint32_t l_396 = 4294967295U;
        (*g_104) = l_396;
    }
    for (l_355 = 29; (l_355 == (-13)); l_355 -= 1)
    { /* block id: 177 */
        uint8_t l_401 = 1U;
        (**g_151) &= ((int32_t)l_401 / (int32_t)l_401);
        return l_401;
    }
    return p_57;
}


/* ------------------------------------------ */
/* 
 * reads : g_150 g_151 g_104 g_105 g_49
 * writes: g_105 g_49
 */
static int32_t  func_62(uint32_t  p_63, int32_t * p_64, int32_t  p_65, const int32_t * p_66, uint32_t  p_67)
{ /* block id: 90 */
    uint32_t l_188 = 2U;
    if (((int16_t)((int16_t)p_65 / (int16_t)((uint16_t)l_188 - (uint16_t)((**g_150) != p_66))) >> (int16_t)__builtin_parity((~8U))))
    { /* block id: 91 */
        int16_t l_190 = 0x7C44;
        (*g_104) &= l_190;
    }
    else
    { /* block id: 93 */
        uint8_t l_192 = 246U;
        int32_t l_193 = (-10);
        l_192 = (+p_63);
        l_193 ^= (*p_64);
    }
    return (**g_151);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_71(uint32_t  p_72)
{ /* block id: 88 */
    int32_t *l_181 = &g_105;
    return l_181;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_89 g_8 g_135 g_105 g_104 g_150 g_151 g_170
 * writes: g_104 g_135 g_105
 */
static uint32_t  func_73(int32_t  p_74, uint32_t  p_75, uint32_t  p_76)
{ /* block id: 42 */
    uint16_t l_81 = 0x2876;
    int32_t l_82 = 0x2FA57A88;
    int32_t l_176 = 0xCEBB1B1B;
    int32_t *l_180 = &l_82;
    l_82 ^= ((-(uint16_t)l_81) & p_75);
    (*l_180) = (func_83(&l_82, l_81, g_49) == (p_74 | ((l_176 || (+l_81)) == (((int16_t)p_76 % (int16_t)p_75) == 0U))));
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads : g_89 g_8 g_135 g_49 g_105 g_104 g_150 g_151 g_170
 * writes: g_104 g_135 g_105
 */
static uint32_t  func_83(int32_t * p_84, int32_t  p_85, uint8_t  p_86)
{ /* block id: 44 */
    uint32_t l_96 = 4U;
    int32_t *l_102 = (void*)0;
    int32_t **l_154 = &g_104;
    int32_t ***l_153 = &l_154;
lbl_172:
    for (p_86 = 0; (p_86 == 37); p_86 += 1)
    { /* block id: 47 */
        const uint16_t l_97 = 0U;
        int32_t *l_155 = &g_49;
        int16_t l_165 = 0x5BDF;
        int32_t **l_171 = &l_102;
        (*p_84) |= __builtin_popcount((g_89 < ((uint16_t)(func_92(((__builtin_ctzll(l_96) ^ 0U) & 7), l_97, ((uint16_t)(((uint32_t)(l_96 != (l_102 != &p_85)) - (uint32_t)p_86) || g_8) % (uint16_t)0x7A74)) | p_86) / (uint16_t)p_85)));
        if (((uint16_t)(-(uint32_t)p_86) + (uint16_t)(g_89 & func_141(g_105, g_49, l_102))))
        { /* block id: 62 */
            int32_t * const **l_152 = &g_151;
            l_152 = g_150;
            if (((0xCAA66001 >= func_141(((((*p_84) < func_141(g_8, ((void*)0 != l_153), &g_49)) | g_49) == g_89), p_85, l_155)) | g_49))
            { /* block id: 64 */
                (*p_84) = ((int16_t)0x717E << (int16_t)15);
            }
            else
            { /* block id: 66 */
                const union U0 *l_158 = &g_159;
                const union U0 **l_160 = &l_158;
                (*l_154) = (*l_154);
                (*l_160) = l_158;
                if ((***g_150))
                    break;
                (*p_84) &= ((uint16_t)0xAC5C + (uint16_t)(-5));
            }
        }
        else
        { /* block id: 72 */
            (*p_84) = (((int32_t)(**g_151) - (int32_t)(***g_150)) < (l_165 && (__builtin_ffsll(p_85) > ((((*l_155) < (((int32_t)0 - (int32_t)((int16_t)(***l_153) >> (int16_t)(g_170 == g_170))) > p_85)) && (*p_84)) <= g_135))));
            if (g_49)
                goto lbl_172;
            (*p_84) = ((*l_155) <= p_85);
            return p_86;
        }
        (*l_171) = (**g_150);
    }
    for (g_135 = 0; (g_135 <= 40); g_135 += 1)
    { /* block id: 82 */
        int16_t l_175 = 0;
        return l_175;
    }
    return g_105;
}


/* ------------------------------------------ */
/* 
 * reads : g_135 g_49
 * writes: g_104 g_135
 */
static uint16_t  func_92(int32_t  p_93, const int16_t  p_94, int16_t  p_95)
{ /* block id: 48 */
    int32_t **l_103 = (void*)0;
    int32_t l_106 = 0x48ADB298;
    int32_t *l_107 = &l_106;
    int32_t l_108 = 0x9166C0C0;
    int32_t *l_109 = &l_108;
    int32_t l_110 = (-2);
    int32_t *l_111 = (void*)0;
    int32_t *l_112 = &l_108;
    int32_t *l_113 = &g_105;
    int32_t l_114 = 0x9E5145DB;
    int32_t *l_115 = &l_108;
    int32_t *l_116 = (void*)0;
    int32_t *l_117 = &l_108;
    int32_t *l_118 = &g_105;
    int32_t *l_119 = &g_105;
    int32_t *l_120 = &g_105;
    int32_t *l_121 = &l_106;
    int32_t *l_122 = &l_110;
    int32_t *l_123 = (void*)0;
    int32_t *l_124 = (void*)0;
    int32_t *l_125 = (void*)0;
    int32_t *l_126 = &g_105;
    int32_t *l_127 = &l_108;
    int32_t *l_128 = &g_105;
    int32_t *l_129 = &l_114;
    int32_t *l_130 = &l_106;
    int32_t *l_131 = &l_110;
    int32_t *l_132 = &l_110;
    int32_t *l_133 = &l_110;
    int32_t *l_134 = (void*)0;
    g_104 = &g_49;
    g_135--;
    return g_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_135 g_105 g_104 g_49
 * writes: g_135 g_104 g_105
 */
static int32_t  func_141(uint32_t  p_142, const int16_t  p_143, int32_t * p_144)
{ /* block id: 53 */
    uint32_t l_148 = 0xB48F2706;
    int32_t *l_149 = &g_105;
    for (g_135 = (-8); (g_135 <= 35); g_135 += 1)
    { /* block id: 56 */
        int32_t **l_147 = &g_104;
        (*l_147) = &g_105;
        if (l_148)
            continue;
    }
    (*l_149) &= __builtin_ffsll(l_148);
    return (*g_104);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_29();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_49, "g_49", print_hash_value);
    transparent_crc(g_89, "g_89", print_hash_value);
    transparent_crc(g_105, "g_105", print_hash_value);
    transparent_crc(g_135, "g_135", print_hash_value);
    transparent_crc(g_159.f0, "g_159.f0", print_hash_value);
    transparent_crc(g_205, "g_205", print_hash_value);
    transparent_crc(g_285, "g_285", print_hash_value);
    transparent_crc(g_300.f0, "g_300.f0", print_hash_value);
    transparent_crc(g_329, "g_329", print_hash_value);
    transparent_crc(g_348, "g_348", print_hash_value);
    transparent_crc(g_386, "g_386", print_hash_value);
    transparent_crc(g_420, "g_420", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 88
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 8
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 6
   indirect level: 2, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 5
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 1
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 3

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 144

XXX times a variable address is taken: 123
XXX times a pointer is dereferenced on RHS: 40
breakdown:
   depth: 1, occurrence: 24
   depth: 2, occurrence: 7
   depth: 3, occurrence: 9
XXX times a pointer is dereferenced on LHS: 47
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 6
   depth: 3, occurrence: 6
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 415

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 142
   level: 2, occurrence: 38
   level: 3, occurrence: 41
XXX number of pointers point to pointers: 27
XXX number of pointers point to scalars: 111
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.2
XXX average alias set size: 1.08

XXX times a non-volatile is read: 310
XXX times a non-volatile is write: 132
XXX times a volatile is read: 13
XXX    times read thru a pointer: 3
XXX times a volatile is write: 10
XXX    times written thru a pointer: 9
XXX times a volatile is available for access: 244
XXX percentage of non-volatile access: 95.1

XXX forward jumps: 2
XXX backward jumps: 0

XXX stmts: 78
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 24
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7

XXX percentage a fresh-made variable is used: 25
XXX percentage an existing variable is used: 75
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

