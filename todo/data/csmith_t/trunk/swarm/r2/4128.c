/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2445616356
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   const unsigned f1 : 21;
   const volatile signed f2 : 3;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-1);
static int32_t g_33 = 9;
static int32_t *g_61 = &g_2;
static int32_t **g_60 = &g_61;
static volatile int32_t g_65 = 0x633E7A32;/* VOLATILE GLOBAL g_65 */
static volatile int32_t g_66 = 0xC837E05A;/* VOLATILE GLOBAL g_66 */
static int32_t g_67 = 0x9FB95C1F;
static int32_t g_95 = 1;
static const int32_t *g_94 = &g_95;
static int8_t g_96 = 0xF2;
static union U0 g_172 = {0x753EC00B};/* VOLATILE GLOBAL g_172 */
static uint16_t g_201 = 0xE519;
static volatile union U0 g_211 = {0};/* VOLATILE GLOBAL g_211 */
static volatile union U0 * const g_210 = &g_211;
static volatile union U0 * const *g_209 = &g_210;
static volatile union U0 * const ** const g_208 = &g_209;
static volatile float g_231 = 0x0.7D2B29p+22;/* VOLATILE GLOBAL g_231 */
static volatile float *g_230 = &g_231;
static volatile float **g_229 = &g_230;
static int32_t *g_343 = &g_2;
static int32_t **g_342 = &g_343;
static int32_t *** const *g_346 = (void*)0;
static int32_t *g_426 = &g_33;


/* --- FORWARD DECLARATIONS --- */
inline static union U0  func_1(void);
static int16_t  func_9(uint32_t  p_10, int16_t  p_11, int32_t  p_12);
inline static int32_t  func_15(int32_t  p_16, uint32_t  p_17, uint32_t  p_18, int32_t ** p_19, int32_t * p_20);
inline static const int32_t  func_24(int32_t * p_25, const float  p_26, float  p_27);
inline static int32_t * func_28(float  p_29);
static float  func_35(int32_t * p_36, const int32_t * p_37, int32_t * p_38, int32_t  p_39);
static int32_t * func_41(uint16_t  p_42, int8_t  p_43, int32_t * p_44);
inline static int32_t * func_45(int32_t * p_46, uint32_t  p_47, const int32_t  p_48, int8_t  p_49, int32_t  p_50);
static int32_t ** func_56(float  p_57, const int32_t * p_58);
inline static const int32_t * func_62(int32_t ** p_63);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_208 g_209 g_210 g_60 g_61 g_342 g_211
 * writes: g_2 g_343
 */
inline static union U0  func_1(void)
{ /* block id: 0 */
    int32_t *l_40 = &g_2;
    float ***l_463 = (void*)0;
    float *** const *l_473 = &l_463;
    union U0 **l_477 = (void*)0;
    volatile union U0 *l_480 = (void*)0;
    volatile union U0 **l_479 = &l_480;
    union U0 ***l_482 = &l_477;
    union U0 ****l_481 = &l_482;
    union U0 *****l_483 = &l_481;
    for (g_2 = 0; (g_2 > (-5)); g_2 -= 1)
    { /* block id: 3 */
        int32_t *l_6 = &g_2;
        int32_t **l_5 = &l_6;
        uint32_t l_21 = 4294967293U;
        uint32_t l_327 = 4294967295U;
        const int16_t l_352 = 0xBCBA;
        int32_t l_418 = (-1);
        (*l_5) = &g_2;
    }
    (*l_479) = (**g_208);
    (*l_483) = l_481;
    (*g_342) = (*g_60);
    return (***g_208);
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_61 g_342 g_96
 * writes: g_343
 */
static int16_t  func_9(uint32_t  p_10, int16_t  p_11, int32_t  p_12)
{ /* block id: 147 */
    (*g_342) = (*g_60);
    return g_96;
}


/* ------------------------------------------ */
/* 
 * reads : g_60
 * writes: g_61 g_94
 */
inline static int32_t  func_15(int32_t  p_16, uint32_t  p_17, uint32_t  p_18, int32_t ** p_19, int32_t * p_20)
{ /* block id: 144 */
    int32_t *** const l_345 = &g_342;
    int32_t *** const *l_344 = &l_345;
    float *l_350 = (void*)0;
    float * const *l_349 = &l_350;
    const int32_t **l_351 = &g_94;
    (*l_351) = func_62(&p_20);
    return p_18;
}


/* ------------------------------------------ */
/* 
 * reads : g_230 g_231 g_95 g_67 g_172.f1 g_172.f0 g_33 g_2
 * writes: g_231
 */
inline static const int32_t  func_24(int32_t * p_25, const float  p_26, float  p_27)
{ /* block id: 141 */
    int32_t l_340 = 0xF66D644B;
    int32_t l_341 = 9;
    (*g_230) = ((((((0x1.5p+1 >= ((((*g_230) == 0x7.E6D6B8p+81) < ((float)((float)((float)((float)(((float)((((float)l_340 / (float)(0x1.B3B8D3p-29 < g_95)) != (l_340 > 0x1.Cp+1)) != (((p_27 <= p_27) != 0xD.6B6C0Dp+15) != l_340)) - (float)l_341) > l_341) - (float)g_67) / (float)l_341) + (float)p_26) / (float)g_172.f1)) >= g_172.f0)) < g_95) == p_27) <= g_33) == l_340) == l_341);
    return (*p_25);
}


/* ------------------------------------------ */
/* 
 * reads : g_2
 * writes: g_33
 */
inline static int32_t * func_28(float  p_29)
{ /* block id: 5 */
    int32_t *l_31 = &g_2;
    int32_t **l_30 = &l_31;
    int32_t *l_32 = &g_33;
    (*l_30) = &g_2;
    (*l_32) = (((&l_31 != &l_31) > ((**l_30) & 65535U)) ^ (4294967288U ^ 0));
    return &g_2;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_60 g_61 g_67 g_65 g_94 g_95 g_66 g_96 g_172.f0 g_201 g_208 g_209 g_229 g_230 g_211.f2 g_210 g_172.f2 g_231 g_211.f0 g_211.f1 g_172.f1
 * writes: g_61 g_67 g_94 g_96 g_60 g_229 g_95 g_231 g_172.f0
 */
static float  func_35(int32_t * p_36, const int32_t * p_37, int32_t * p_38, int32_t  p_39)
{ /* block id: 9 */
    int32_t **l_321 = &g_61;
    int32_t l_323 = 1;
    union U0 * const l_324 = &g_172;
    (*l_321) = func_41(g_2, g_2, func_45(p_38, g_2, p_39, ((-(int16_t)g_2) == p_39), g_2));
    (*l_321) = func_41(p_39, p_39, func_41((((~l_323) | (l_324 == l_324)) == ((((4294967294U >= (g_201 <= 0x37A7E7F2)) || ((int32_t)((*l_321) != p_38) - (int32_t)4294967288U)) ^ g_66) <= g_201)), l_323, (*g_60)));
    return (*g_230);
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_61
 * writes: g_61
 */
static int32_t * func_41(uint16_t  p_42, int8_t  p_43, int32_t * p_44)
{ /* block id: 134 */
    union U0 *l_319 = (void*)0;
    union U0 **l_320 = &l_319;
    (*l_320) = l_319;
    (*g_60) = (void*)0;
    return (*g_60);
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_61 g_67 g_2 g_65 g_94 g_95 g_66 g_96 g_172.f0 g_201 g_208 g_209 g_229 g_230 g_211.f2 g_210 g_172.f2 g_231 g_211.f0 g_211.f1 g_172.f1
 * writes: g_61 g_67 g_94 g_96 g_60 g_229 g_95 g_231 g_172.f0
 */
inline static int32_t * func_45(int32_t * p_46, uint32_t  p_47, const int32_t  p_48, int8_t  p_49, int32_t  p_50)
{ /* block id: 10 */
    float l_106 = 0x1.0p+1;
    const int32_t **l_113 = &g_94;
    uint16_t l_202 = 0x36E8;
    int32_t l_207 = (-1);
    union U0 *l_223 = (void*)0;
    union U0 **l_222 = &l_223;
    union U0 ***l_221 = &l_222;
    union U0 ****l_220 = &l_221;
    uint32_t l_227 = 0x50C90199;
    float **l_273 = (void*)0;
    const uint16_t l_294 = 0x5C4C;
    const int32_t ***l_299 = (void*)0;
    const int32_t ****l_298 = &l_299;
    int32_t *l_318 = &g_95;
    for (p_49 = (-21); (p_49 == 18); p_49 += 7)
    { /* block id: 13 */
        int32_t l_108 = 0xFD3C4F90;
        uint16_t l_114 = 0x43EF;
        int32_t ***l_163 = (void*)0;
        union U0 **l_224 = (void*)0;
        float *l_272 = &l_106;
        float **l_271 = &l_272;
        for (p_47 = 0; (p_47 != 8); p_47 += 1)
        { /* block id: 16 */
            int32_t **l_64 = &g_61;
            int32_t ***l_97 = &g_60;
            uint32_t l_124 = 0x25DDBF1A;
            union U0 *l_188 = &g_172;
            const int32_t *l_193 = (void*)0;
            (*l_97) = func_56((!(g_60 != &p_46)), func_62(l_64));
            if ((((int16_t)(((((uint16_t)0x0469 >> (uint16_t)(((p_50 < ((((((int16_t)((uint32_t)((*p_46) < (!(l_108 ^ (-3)))) + (uint32_t)(((int16_t)p_50 >> (int16_t)12) == (((int32_t)0xA32D9FB0 / (int32_t)((l_113 == l_113) && (**g_60))) >= p_47))) / (int16_t)g_67) == l_114) != g_95) >= 4294967295U) | 0xAF80CEF6)) ^ 0xCAAAB22D) > (**l_113))) > 0xDF32) == g_67) >= g_65) << (int16_t)9) & 0x19BE1704))
            { /* block id: 37 */
                int8_t l_115 = 0xD9;
                int32_t **l_119 = (void*)0;
                uint32_t l_123 = 0x46991E3C;
                const union U0 *l_171 = &g_172;
                int32_t *l_178 = &g_172.f0;
                uint32_t l_192 = 6U;
                if (((l_115 ^ ((l_108 != (((-(uint16_t)((((l_119 == (void*)0) > (((int16_t)((void*)0 == &p_46) - (int16_t)(0xE65AFEF7 < ((!(((&g_94 != l_119) <= g_67) <= (**l_64))) == g_67))) != p_47)) & l_123) <= g_66)) > p_47) != 0x818A95D6)) & (**l_64))) && l_124))
                { /* block id: 38 */
                    uint32_t l_136 = 0xD7F9BA6D;
                    int32_t l_137 = (-5);
                    l_137 = ((((((uint16_t)(((((g_65 & ((uint16_t)((int16_t)(l_114 != ((p_48 & ((!(((int16_t)(-1) << (int16_t)(((uint16_t)0x8B9B << (uint16_t)0) <= (*p_46))) <= ((void*)0 != &g_60))) >= (p_50 == (*p_46)))) == g_96)) / (int16_t)g_96) >> (uint16_t)7)) || g_96) ^ g_67) || l_136) == (*g_61)) >> (uint16_t)g_2) | g_2) > (*g_94)) >= p_48) >= 0xEFA4);
                    l_137 = (((void*)0 != (*l_113)) && (((((&g_60 == (void*)0) != ((uint32_t)(p_49 | ((uint16_t)g_67 + (uint16_t)((**l_113) >= ((uint32_t)g_66 - (uint32_t)(&g_60 != &g_60))))) - (uint32_t)0xE8F33800)) && p_48) && (*p_46)) < g_2));
                }
                else
                { /* block id: 41 */
                    int32_t *l_146 = &g_67;
                    int32_t ***l_170 = &l_119;
                    (*l_113) = (*l_113);
                    for (l_123 = (-7); (l_123 == 8); l_123 += 1)
                    { /* block id: 45 */
                        float *l_152 = &l_106;
                        (**l_97) = l_146;
                        (*l_152) = ((((-(float)0x6.FD80D4p-73) < (((void*)0 != &g_60) != g_66)) != ((float)((float)(l_113 == (void*)0) - (float)(**l_113)) - (float)((void*)0 == (*g_60)))) <= p_49);
                    }
                    if (((&l_108 != (*g_60)) != ((uint16_t)((void*)0 == l_146) << (uint16_t)((int32_t)((uint16_t)((void*)0 == (*l_64)) << (uint16_t)10) % (int32_t)((int16_t)(((p_48 || ((int16_t)((l_163 == &l_64) && p_50) + (int16_t)0xE018)) & p_50) > (-8)) - (int16_t)(-8))))))
                    { /* block id: 49 */
                        float *l_164 = (void*)0;
                        float *l_165 = &l_106;
                        (*l_165) = (-0x4.4p-1);
                        (*l_146) = (((-(int32_t)0x36EAB1F2) == (~((((uint16_t)(p_46 != (void*)0) >> (uint16_t)g_95) == (l_170 != l_163)) & 0U))) == (((p_47 | (0x6490 ^ p_49)) <= (**l_64)) || p_50));
                    }
                    else
                    { /* block id: 52 */
                        const union U0 **l_173 = &l_171;
                        (*l_173) = l_171;
                        (*g_60) = p_46;
                        g_94 = func_62((*l_97));
                    }
                    if ((*g_94))
                        continue;
                }
                if ((*p_46))
                    continue;
                if ((1U <= 0))
                { /* block id: 60 */
                    float *l_181 = &l_106;
                    (*l_181) = ((float)(p_46 != l_178) + (float)((float)((void*)0 != (*g_60)) / (float)p_49));
                }
                else
                { /* block id: 62 */
                    uint16_t l_182 = 9U;
                    int32_t l_203 = 1;
                    if ((l_182 ^ (*l_178)))
                    { /* block id: 63 */
                        float *l_183 = &l_106;
                        p_46 = (*g_60);
                        (*l_183) = (&l_178 != &p_46);
                    }
                    else
                    { /* block id: 66 */
                        (*l_97) = (*l_97);
                        (*g_60) = p_46;
                    }
                    l_193 = func_62(func_56((((-0x8.5p-1) != (((g_67 == 0x0.Dp-1) != (-0x1.Fp+1)) > 0x0.Fp+1)) >= ((float)((((float)(((void*)0 != l_188) > ((-(float)(((float)l_192 - (float)(*l_178)) >= 0x2.B7DADBp+20)) == 0x2.2E08F3p-51)) + (float)g_172.f0) <= (-0x5.7p-1)) == 0x2.Bp+1) / (float)(***l_97))), (*g_60)));
                    l_203 = ((((int32_t)(**l_113) - (int32_t)((*g_61) & (((((((p_50 || ((uint16_t)(((((uint32_t)l_182 - (uint32_t)(&g_94 == &g_61)) >= (((-(int16_t)p_48) >= (***l_97)) < (1U >= 1))) | g_95) & 0xD265) / (uint16_t)g_67)) ^ (*p_46)) > g_201) <= 0x25B1) & p_49) ^ l_202) ^ p_47))) >= (**l_113)) & 1U);
                    if ((**g_60))
                        continue;
                }
                (*l_113) = func_62(&p_46);
            }
            else
            { /* block id: 75 */
                int16_t l_206 = 0x1942;
                union U0 ****l_219 = (void*)0;
                for (l_124 = 23; (l_124 < 14); l_124 -= 1)
                { /* block id: 78 */
                    volatile union U0 * const **l_213 = &g_209;
                    volatile union U0 * const ***l_212 = &l_213;
                    int32_t *l_228 = &l_108;
                    if ((*g_61))
                    { /* block id: 79 */
                        l_206 = 0x3D140ED9;
                    }
                    else
                    { /* block id: 81 */
                        l_207 = (-4);
                        return (*g_60);
                    }
                    (*l_212) = g_208;
                    if (((((int32_t)((((-(uint16_t)(0x1B3F > ((l_219 == l_220) <= g_2))) & (l_224 != (*g_208))) == (((((int16_t)l_206 + (int16_t)(l_163 == &l_64)) <= p_47) ^ 0x358F) <= (-4))) < 0xB0687F24) / (int32_t)0x958433A3) | 0x8CF5AA1C) ^ l_227))
                    { /* block id: 86 */
                        volatile float ***l_232 = &g_229;
                        (**l_97) = (*g_60);
                        l_228 = p_46;
                        (*l_232) = g_229;
                    }
                    else
                    { /* block id: 90 */
                        (*l_64) = p_46;
                    }
                }
            }
            if (((uint32_t)((int16_t)(p_48 | g_65) >> (int16_t)((int32_t)((**g_60) < ((&g_230 != (void*)0) == (((int32_t)((*g_229) == (void*)0) - (int32_t)0xA8A250D8) | (*p_46)))) % (int32_t)0x74E035A3)) + (uint32_t)(***l_97)))
            { /* block id: 95 */
                uint32_t l_247 = 8U;
                float *l_255 = &l_106;
                int32_t *l_256 = &g_95;
                l_207 = (*g_61);
                (*l_256) = ((uint16_t)(((int16_t)((int16_t)l_247 >> (int16_t)p_48) - (int16_t)(((((int32_t)(**g_60) + (int32_t)((uint16_t)(~((&p_46 != &p_46) != (0x04FD572D && (((void*)0 == l_255) == (p_50 == p_49))))) << (uint16_t)g_211.f2)) <= g_95) != g_2) != p_49)) == 0x3AE3880B) + (uint16_t)p_49);
            }
            else
            { /* block id: 98 */
                const int16_t l_258 = (-10);
                union U0 ** const *l_266 = (void*)0;
                union U0 ** const ** const l_265 = &l_266;
                if (((void*)0 != (**g_208)))
                { /* block id: 99 */
                    if ((**g_60))
                        break;
                    (*l_222) = (**l_221);
                    (*g_60) = (*g_60);
                    (*l_113) = func_62(&g_61);
                }
                else
                { /* block id: 104 */
                    uint32_t l_267 = 0x7021F964;
                    int32_t *l_274 = (void*)0;
                    int32_t *l_275 = (void*)0;
                    int32_t *l_276 = &g_172.f0;
                    if ((p_50 && (!((((*p_46) <= (l_258 >= (((uint16_t)(5U < ((int32_t)(((uint16_t)(((((*g_209) == (void*)0) & (l_265 == (void*)0)) & (***l_97)) != l_267) >> (uint16_t)9) | g_66) + (int32_t)(*g_61))) - (uint16_t)g_2) | (*p_46)))) <= p_48) || g_172.f2))))
                    { /* block id: 105 */
                        int32_t l_268 = 1;
                        (**g_229) = (l_268 <= (!((void*)0 != &g_230)));
                        (*l_64) = p_46;
                        (*l_113) = func_62(&g_61);
                    }
                    else
                    { /* block id: 109 */
                        const int32_t *l_270 = (void*)0;
                        if ((*g_94))
                            break;
                        (*l_113) = func_62(func_56((0x5.3p-1 >= (**g_229)), l_270));
                        g_94 = (*l_113);
                    }
                    (*l_276) = (l_271 == l_273);
                }
            }
        }
        if ((p_50 | ((((*g_209) != (void*)0) & ((~(((((uint16_t)(p_47 && 0xB0D09343) + (uint16_t)(g_211.f0 ^ ((~(((**l_220) != l_224) && p_47)) < g_95))) <= (*g_61)) && g_66) >= 0)) && (**l_113))) >= g_172.f0)))
        { /* block id: 118 */
            float ***l_285 = &l_273;
            int32_t l_292 = 0;
            const union U0 **l_293 = (void*)0;
            int32_t *l_295 = &g_172.f0;
            (*l_295) = ((g_96 && ((uint32_t)((void*)0 != l_285) / (uint32_t)(-(uint32_t)p_49))) != (((0x58E8 == ((((((uint32_t)(((!(((((uint16_t)7U + (uint16_t)(l_292 | (l_293 != l_293))) && g_211.f1) != (*p_46)) | (**l_113))) >= 0x93677515) || 0x486A7071) / (uint32_t)l_292) | 0x72E7577D) && (*g_94)) && (**l_113)) <= g_2)) != l_294) >= 0xCC853F98));
            l_295 = (*g_60);
        }
        else
        { /* block id: 121 */
            (**l_221) = (void*)0;
            (*g_60) = p_46;
        }
    }
    for (g_172.f0 = 0; (g_172.f0 >= (-6)); g_172.f0 -= 3)
    { /* block id: 128 */
        (**g_229) = (&g_208 == &g_208);
    }
    (*l_298) = &l_113;
    (*l_318) = ((uint16_t)(((0xD62DBF7B || 0x93004D83) != g_95) < ((int32_t)((((uint16_t)((int16_t)((uint16_t)7U << (uint16_t)0) >> (int16_t)((((*p_46) | ((****l_298) < ((int16_t)((uint16_t)((int32_t)((int16_t)5 << (int16_t)9) - (int32_t)(g_96 > p_48)) % (uint16_t)(***l_299)) / (int16_t)(***l_299)))) < g_211.f0) && g_172.f0)) + (uint16_t)0x2E9B) || 0xCE8E) > p_50) + (int32_t)(**l_113))) << (uint16_t)g_172.f1);
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_2 g_65 g_61 g_60 g_94
 * writes: g_67 g_61 g_94 g_96
 */
static int32_t ** func_56(float  p_57, const int32_t * p_58)
{ /* block id: 20 */
    int32_t l_91 = 0xC7BE4440;
    int32_t **l_93 = &g_61;
    for (g_67 = 0; (g_67 == 4); g_67 += 1)
    { /* block id: 23 */
        uint32_t l_72 = 0x724D257E;
        uint16_t l_92 = 0x6AAD;
        if ((((uint16_t)1U >> (uint16_t)((((((p_58 == (void*)0) | l_72) <= (l_72 ^ (((uint32_t)((int32_t)((int16_t)g_67 >> (int16_t)14) - (int32_t)(((l_72 | ((int16_t)((l_72 > (((int32_t)((uint16_t)((int32_t)((uint16_t)(((g_2 | (-10)) ^ g_67) ^ l_91) % (uint16_t)g_65) / (int32_t)9U) >> (uint16_t)15) + (int32_t)l_72) ^ l_91)) >= 0U) + (int16_t)l_72)) <= l_72) == 1)) / (uint32_t)l_72) == 0U))) >= 0xFA943C7D) != l_92) > l_91)) & 0xF0846D72))
        { /* block id: 24 */
            g_94 = func_62(l_93);
            if ((*g_94))
                break;
        }
        else
        { /* block id: 27 */
            if ((*g_61))
            { /* block id: 28 */
                return &g_61;
            }
            else
            { /* block id: 30 */
                g_96 = (-0x10.1p+1);
            }
        }
    }
    return l_93;
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_60
 * writes: g_61
 */
inline static const int32_t * func_62(int32_t ** p_63)
{ /* block id: 17 */
    (*g_60) = (*p_63);
    return (*p_63);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_65, "g_65", print_hash_value);
    transparent_crc(g_66, "g_66", print_hash_value);
    transparent_crc(g_67, "g_67", print_hash_value);
    transparent_crc(g_95, "g_95", print_hash_value);
    transparent_crc(g_96, "g_96", print_hash_value);
    transparent_crc(g_172.f0, "g_172.f0", print_hash_value);
    transparent_crc(g_172.f1, "g_172.f1", print_hash_value);
    transparent_crc(g_172.f2, "g_172.f2", print_hash_value);
    transparent_crc(g_201, "g_201", print_hash_value);
    transparent_crc(g_211.f0, "g_211.f0", print_hash_value);
    transparent_crc(g_211.f1, "g_211.f1", print_hash_value);
    transparent_crc(g_211.f2, "g_211.f2", print_hash_value);
    transparent_crc_bytes (&g_231, sizeof(g_231), "g_231", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 84
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 14

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 114
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 28, occurrence: 1

XXX total number of pointers: 115

XXX times a variable address is taken: 120
XXX times a pointer is dereferenced on RHS: 133
breakdown:
   depth: 1, occurrence: 87
   depth: 2, occurrence: 34
   depth: 3, occurrence: 11
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 69
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 8
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 357

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 268
   level: 2, occurrence: 87
   level: 3, occurrence: 22
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 62
XXX number of pointers point to scalars: 43
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.22

XXX times a non-volatile is read: 599
XXX times a non-volatile is write: 165
XXX times a volatile is read: 33
XXX    times read thru a pointer: 10
XXX times a volatile is write: 9
XXX    times written thru a pointer: 9
XXX times a volatile is available for access: 126
XXX percentage of non-volatile access: 94.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 98
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 5
   depth: 2, occurrence: 10
   depth: 3, occurrence: 10
   depth: 4, occurrence: 20
   depth: 5, occurrence: 24

XXX percentage a fresh-made variable is used: 16
XXX percentage an existing variable is used: 84
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

