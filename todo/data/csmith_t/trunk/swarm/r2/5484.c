/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1053540192
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int16_t  f0;
   signed f1 : 12;
   volatile int32_t  f2;
   uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = 0x8FAAAEB9;
static int16_t g_29 = 0xE4A9;
static int32_t g_55 = 8;
static int32_t *g_57 = (void*)0;
static int32_t g_70 = 0x4C5F6B4A;
static int32_t g_118 = (-1);
static int32_t g_125 = 0x1F0774A7;
static volatile union U0 *g_126 = (void*)0;
static uint32_t g_132 = 0x0D248760;
static union U0 g_141 = {1};/* VOLATILE GLOBAL g_141 */
static int32_t *g_144 = (void*)0;
static int32_t **g_143 = &g_144;
static int32_t g_160 = 2;
static union U0 g_162 = {0x6AE3};/* VOLATILE GLOBAL g_162 */
static union U0 g_178 = {0x662F};/* VOLATILE GLOBAL g_178 */


/* --- FORWARD DECLARATIONS --- */
static union U0  func_28(void);
static int32_t  func_34(int32_t  p_35, int32_t  p_36, int32_t  p_37, int32_t  p_38, int32_t  p_39);
static uint16_t  func_45(int16_t  p_46, int32_t  p_47);
static int32_t  func_50(uint16_t  p_51);
static int32_t * func_71(int32_t  p_72, int32_t * p_73, int32_t  p_74, uint16_t  p_75);
static int32_t * func_76(int32_t ** p_77);
static uint32_t  func_100(int32_t ** p_101, int32_t ** p_102);
static int32_t ** func_103(int32_t ** p_104, int32_t ** p_105, int32_t ** p_106);
static int32_t ** func_107(uint32_t  p_108, int32_t * p_109);
static int32_t  func_112(uint32_t  p_113, uint16_t  p_114, int32_t * p_115, int32_t ** p_116, uint32_t  p_117);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_29 g_57 g_55 g_70 g_118 g_125 g_126 g_132 g_143 g_141.f0 g_144 g_160 g_178
 * writes: g_29 g_57 g_55 g_70 g_125 g_126 g_132 g_141.f0 g_144 g_160
 */
static union U0  func_28(void)
{ /* block id: 36 */
    int32_t l_42 = 0;
    int32_t *l_177 = &g_70;
    g_29 = g_8;
    (*l_177) = ((int16_t)((int32_t)func_34(((uint32_t)(1 <= l_42) % (uint32_t)1), ((uint16_t)func_45(g_8, ((uint32_t)l_42 - (uint32_t)func_50(((int16_t)g_8 + (int16_t)g_29)))) << (uint16_t)14), g_8, g_8, l_42) % (int32_t)l_42) * (int16_t)0x5416);
    /* statement id: 120 */
    assert (g_57 == &g_70 || g_57 == &g_55);
    //assert (g_144 == dangling || g_144 == 0 || g_144 == &g_55);
    return g_178;
    /* statement id: 121 */
    }


/* ------------------------------------------ */
/* 
 * reads : g_8 g_57 g_55 g_70 g_29 g_118 g_125 g_126 g_132 g_143 g_141.f0 g_144 g_160
 * writes: g_70 g_55 g_125 g_57 g_126 g_132 g_29 g_141.f0 g_144 g_160
 */
static int32_t  func_34(int32_t  p_35, int32_t  p_36, int32_t  p_37, int32_t  p_38, int32_t  p_39)
{ /* block id: 44 */
    int16_t l_62 = (-1);
    int32_t **l_68 = &g_57;
    int32_t *l_69 = &g_70;
    union U0 *l_161 = &g_162;
    (*l_69) &= ((uint16_t)__builtin_ffs(((int16_t)l_62 - (int16_t)(6 <= (((uint16_t)(g_8 ^ (0x5BF8 | l_62)) % (uint16_t)((-(int16_t)(((((uint16_t)l_62 * (uint16_t)(&g_57 == l_68)) != (((*l_68) != &p_35) > g_8)) == 0x856A) && (**l_68))) || p_38)) != (**l_68))))) % (uint16_t)(**l_68));
    (*l_68) = func_71(p_39, func_76(&g_57), p_39, ((void*)0 != l_161));
    /* statement id: 101 */
    assert (g_57 == &g_70);
    assert (g_144 == 0 || g_144 == &g_55);
    if ((**l_68))
    { /* block id: 102 */
        int32_t **l_168 = (void*)0;
        int32_t *l_170 = &g_160;
        (*l_69) = (g_55 && func_50(((int16_t)g_160 >> (int16_t)(1 == (~(((*l_69) && (-(int16_t)g_8)) == (((~((4 > g_55) < (**l_68))) <= g_118) && g_55)))))));
        /* statement id: 103 */
        assert (g_57 == &g_70 || g_57 == &g_55);
        (*l_170) &= (*g_57);
        return (*l_170);
    }
    else
    { /* block id: 106 */
        union U0 *l_171 = (void*)0;
        if (((void*)0 == l_171))
        { /* block id: 107 */
            (**l_68) &= ((void*)0 == &l_171);
        }
        else
        { /* block id: 109 */
            uint32_t l_175 = 7U;
            for (p_36 = (-23); (p_36 <= 5); p_36 += 1)
            { /* block id: 112 */
                int16_t l_176 = (-4);
                p_35 = ((*g_57) | (!(l_175 >= (l_176 != 0x5199))));
            }
            (*g_143) = &p_39;
            /* statement id: 115 */
            assert (g_144 == &p_39);
            return (*g_57);
            /* statement id: 116 */
            //assert (g_144 == dangling);
        }
    }
    return (*g_57);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_45(int16_t  p_46, int32_t  p_47)
{ /* block id: 42 */
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : g_57 g_55
 * writes: g_57 g_55
 */
static int32_t  func_50(uint16_t  p_51)
{ /* block id: 38 */
    int32_t *l_54 = &g_55;
    int32_t **l_56 = (void*)0;
    g_57 = l_54;
    /* statement id: 39 */
    assert (g_57 == &g_55);
    (*l_54) = p_51;
    return (*g_57);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_71(int32_t  p_72, int32_t * p_73, int32_t  p_74, uint16_t  p_75)
{ /* block id: 99 */
    int32_t *l_163 = &g_70;
    return l_163;
    /* statement id: 100 */
    //assert (func_71_rv == &g_70);
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_57 g_8 g_29 g_70 g_118 g_125 g_126 g_132 g_143 g_141.f0 g_144 g_160
 * writes: g_55 g_125 g_57 g_126 g_132 g_29 g_70 g_141.f0 g_144 g_160
 */
static int32_t * func_76(int32_t ** p_77)
{ /* block id: 46 */
    int32_t *l_80 = &g_70;
    for (g_55 = (-24); (g_55 == (-26)); g_55 -= 1)
    { /* block id: 49 */
        return &g_55;
        /* statement id: 50 */
        //assert (func_76_rv == &g_55);
    }
    l_80 = (*p_77);
    /* statement id: 52 */
    assert (l_80 == &g_55);
    if ((((p_77 != &g_57) > ((uint16_t)((int16_t)func_45((*l_80), g_8) >> (int16_t)((void*)0 == &g_57)) >> (uint16_t)(((uint16_t)2U >> (uint16_t)(0x1C2A <= (*l_80))) >= 0xFA237FF9))) <= g_29))
    { /* block id: 53 */
        int16_t l_93 = 1;
        int32_t **l_119 = &g_57;
        int32_t l_158 = (-4);
        int32_t *l_159 = &g_160;
        (**p_77) |= __builtin_ffsl(g_70);
        (*l_159) ^= ((int16_t)((uint16_t)((uint16_t)65535U % (uint16_t)func_45(l_93, l_93)) + (uint16_t)((uint16_t)((uint16_t)((((uint32_t)func_100(&l_80, func_103(func_107((g_29 < ((int32_t)(65532U < ((func_112((*l_80), (__builtin_popcountll(g_118) ^ l_93), l_80, l_119, (**l_119)) && (**l_119)) != g_70)) % (int32_t)(*l_80))), &g_70), g_143, &g_144)) % (uint32_t)l_93) > l_93) && l_158) >> (uint16_t)5) << (uint16_t)l_93)) >> (int16_t)g_8);
        /* statement id: 94 */
        assert (g_144 == &g_55);
    }
    else
    { /* block id: 95 */
        (*g_143) = (*g_143);
    }
    /* facts after branching */
    assert (g_144 == 0 || g_144 == &g_55);
    return (*g_143);
    /* statement id: 98 */
    //assert (func_76_rv == 0 || func_76_rv == &g_55);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_55
 */
static uint32_t  func_100(int32_t ** p_101, int32_t ** p_102)
{ /* block id: 91 */
    uint32_t l_157 = 5U;
    (**p_101) = (-5);
    return l_157;
}


/* ------------------------------------------ */
/* 
 * reads : g_141.f0 g_57 g_143 g_144 g_55 g_118
 * writes: g_141.f0 g_125 g_70 g_144 g_55
 */
static int32_t ** func_103(int32_t ** p_104, int32_t ** p_105, int32_t ** p_106)
{ /* block id: 71 */
    int32_t *l_156 = &g_55;
    for (g_141.f0 = 21; (g_141.f0 == (-15)); g_141.f0 -= 3)
    { /* block id: 74 */
        int32_t *l_155 = &g_55;
        for (g_125 = 0; (g_125 >= 2); g_125 += 8)
        { /* block id: 77 */
            union U0 *l_150 = (void*)0;
            union U0 **l_149 = &l_150;
            (*l_149) = &g_141;
            /* statement id: 78 */
            assert (l_150 == &g_141);
        }
        for (g_70 = 0; (g_70 >= (-24)); g_70--)
        { /* block id: 82 */
            (*g_143) = (*p_104);
            /* statement id: 83 */
            assert (g_144 == &g_55);
            (**g_143) &= (-9);
            (*p_105) = (*g_143);
            (**p_105) |= ((((int32_t)(l_155 != l_155) - (int32_t)(l_155 == (*p_106))) == 0x462B) || g_118);
        }
    }
    /* facts after for loop */
    assert (g_144 == &g_55 || g_144 == 0);
    (*p_106) = l_156;
    /* statement id: 89 */
    assert (g_144 == &g_55);
    return &g_57;
    /* statement id: 90 */
    //assert (func_103_rv == &g_57);
}


/* ------------------------------------------ */
/* 
 * reads : g_29
 * writes: g_29 g_70
 */
static int32_t ** func_107(uint32_t  p_108, int32_t * p_109)
{ /* block id: 61 */
    int32_t *l_138 = &g_70;
    union U0 *l_140 = &g_141;
    union U0 **l_139 = &l_140;
    int32_t **l_142 = &g_57;
    for (g_29 = 0; (g_29 != (-7)); g_29 -= 7)
    { /* block id: 64 */
        uint32_t l_135 = 0x1065C771;
        int32_t *l_136 = (void*)0;
        int32_t **l_137 = &l_136;
        if (l_135)
            break;
        (*l_137) = l_136;
        l_138 = p_109;
        (*p_109) = (l_139 == (void*)0);
    }
    return l_142;
    /* statement id: 70 */
    //assert (func_107_rv == &g_57);
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_57 g_70 g_125 g_126 g_8 g_132
 * writes: g_125 g_57 g_126 g_132
 */
static int32_t  func_112(uint32_t  p_113, uint16_t  p_114, int32_t * p_115, int32_t ** p_116, uint32_t  p_117)
{ /* block id: 55 */
    int32_t **l_122 = &g_57;
    volatile union U0 **l_127 = &g_126;
    g_125 ^= (((uint16_t)((void*)0 == l_122) - (uint16_t)g_55) <= ((int32_t)(0U != ((**l_122) == p_117)) + (int32_t)((**p_116) <= g_70)));
    (*l_122) = (*l_122);
    (*l_127) = g_126;
    g_132 ^= ((int16_t)((uint16_t)g_8 << (uint16_t)(**l_122)) << (int16_t)9);
    return (**l_122);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_29, "g_29", print_hash_value);
    transparent_crc(g_55, "g_55", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc(g_118, "g_118", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_141.f0, "g_141.f0", print_hash_value);
    transparent_crc(g_160, "g_160", print_hash_value);
    transparent_crc(g_162.f0, "g_162.f0", print_hash_value);
    transparent_crc(g_178.f0, "g_178.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 39
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 5
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 1
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 3
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 2
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 10
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 41

XXX times a variable address is taken: 35
XXX times a pointer is dereferenced on RHS: 30
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 11
XXX times a pointer is dereferenced on LHS: 22
breakdown:
   depth: 1, occurrence: 17
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 6
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 92

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 61
   level: 2, occurrence: 43
XXX number of pointers point to pointers: 20
XXX number of pointers point to scalars: 16
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 19.5
XXX average alias set size: 1.17

XXX times a non-volatile is read: 167
XXX times a non-volatile is write: 62
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 20
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 52
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 14
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 26
XXX percentage an existing variable is used: 74
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

