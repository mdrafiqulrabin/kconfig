/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      750639500
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int16_t  f1;
   int32_t  f2;
   uint16_t  f3;
   uint16_t  f4;
   int16_t  f5;
   uint32_t  f6;
   const uint16_t  f7;
   const uint32_t  f8;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int32_t  f0;
   int16_t  f1;
   uint32_t  f2;
   int8_t  f3;
   float  f4;
   int32_t  f5;
   int8_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_32(void);
inline static int32_t * func_36(int32_t * p_37, uint16_t  p_38);
static int32_t *** func_42(int32_t *** p_43, const int32_t ** p_44, int32_t *** p_45);
static const struct S0  func_48(const uint16_t  p_49, int32_t *** p_50, uint16_t  p_51, int32_t  p_52, float  p_53);
inline static int32_t *** func_54(struct S1  p_55, struct S1  p_56, uint16_t  p_57, int32_t ** p_58);
inline static uint16_t  func_60(int32_t ** p_61, int8_t  p_62, int32_t ** p_63, const uint16_t  p_64);
static int32_t ** func_65(struct S0  p_66, int32_t * p_67, int8_t  p_68);
static struct S0  func_69(uint16_t  p_70);
inline static const struct S1  func_80(uint32_t  p_81, int32_t ** p_82);
static int32_t ** func_88(uint32_t  p_89, int32_t ** p_90, int32_t  p_91, int32_t ** p_92, uint16_t  p_93);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_32(void)
{ /* block id: 36 */
    int32_t l_33 = 0;
    int32_t *l_759 = &l_33;
    struct S1 l_761 = {0x63482E6B,3,0x2252F4FD,0xF0,0x7.BA90F7p-5,0,-4};
    struct S1 *l_760 = &l_761;
    uint16_t l_765 = 65527U;
    struct S0 *l_778 = (void*)0;
    struct S0 **l_777 = &l_778;
    struct S1 **l_799 = &l_760;
    struct S1 ***l_798 = &l_799;
    struct S1 ****l_797 = &l_798;
    struct S1 *****l_796 = &l_797;
    uint32_t l_858 = 1U;
    float l_864 = (-0x4.1p-1);
    int32_t **l_919 = (void*)0;
    int32_t ***l_934 = &l_919;
    int32_t ****l_933 = &l_934;
    struct S1 *l_962 = &l_761;
    struct S1 l_993 = {0xD176647C,0x782A,4294967295U,-7,0x4.7E7681p-99,0x2D48C107,0xDA};
    float l_998 = (-0x1.4p+1);
    struct S1 l_1000 = {-2,1,0xCB0CA113,1,0x1.Ep-1,0xF0998819,0xED};
    int8_t l_1014 = (-6);
    uint16_t l_1054 = 0U;
    const int32_t l_1060 = 0xC77534DA;
    int8_t l_1063 = 0x77;
    float l_1068 = 0x0.C9E13Dp+97;
    uint16_t l_1069 = 0x630C;
    uint16_t l_1070 = 0x7BB8;
    uint16_t l_1072 = 0x7901;
    const float l_1075 = (-0x1.3p+1);
    const int16_t l_1076 = 0x36D2;
    float l_1079 = 0x1.4p-1;
    int32_t l_1097 = (-8);
    float l_1122 = 0x1.1125EDp+75;
    int8_t l_1126 = 0;
    int32_t **l_1144 = &l_759;
    const uint32_t l_1166 = 0x8B772113;
    int16_t l_1172 = 0xF979;
    const int16_t l_1207 = 0xCE0C;
    uint32_t l_1215 = 0U;
    uint16_t l_1271 = 0U;
    struct S1 ****l_1274 = &l_798;
    int8_t l_1301 = 5;
    uint32_t l_1306 = 9U;
    float l_1308 = (-0x1.2p-1);
    int32_t l_1309 = (-8);
    uint32_t l_1310 = 1U;
    int8_t l_1311 = 0xF5;
    uint16_t l_1315 = 0x1F3A;
    int32_t l_1322 = 0xB39C1F01;
    uint32_t l_1331 = 0x5E5D2BA4;
    const float l_1338 = 0x4.DDE72Cp+11;
    int8_t l_1367 = 0x29;
    int16_t l_1411 = (-2);
    const uint16_t l_1430 = 65530U;
    int8_t l_1446 = 0xEE;
    uint32_t l_1447 = 0x67E99907;
    uint32_t l_1448 = 6U;
    float l_1450 = 0x0.7p+1;
    uint32_t l_1459 = 0x9AA79FAE;
    int32_t l_1460 = 0x728EB53E;
    int16_t l_1484 = (-2);
    uint32_t l_1493 = 4294967295U;
    int32_t l_1497 = 7;
    const float l_1498 = 0x0.Fp+1;
    int8_t l_1505 = 0;
    for (l_33 = 0; (l_33 == 7); l_33 = safe_add_func_uint16_t_u_u(l_33, 1))
    { /* block id: 39 */
        return l_33;
    }
    l_759 = func_36(&l_33, (0 <= 0xD53A38D0));
    if (((*l_759) , (*l_759)))
    { /* block id: 384 */
        struct S1 **l_762 = &l_760;
        int32_t l_763 = 0;
        (*l_762) = l_760;
        return l_763;
    }
    else
    { /* block id: 387 */
        int32_t *l_764 = &l_761.f0;
        int32_t **l_766 = &l_764;
        int32_t l_795 = 0xF199A1D4;
        const struct S1 l_809 = {0x3FE6EE91,0xB908,0x1930A0A9,0x99,0x5.4p+1,1,6};
        uint32_t l_831 = 0xA7B9F1C2;
        int32_t **l_845 = (void*)0;
        int16_t l_859 = 0x998A;
        int32_t l_867 = (-1);
        struct S0 l_868 = {0,-1,0x73C78BBB,0x5FF2,0x6846,0xC1C7,4294967295U,9U,0x0589D411};
        const struct S0 *l_903 = &l_868;
        const struct S0 **l_902 = &l_903;
        int32_t l_937 = 0xD108698E;
        struct S1 *****l_967 = &l_797;
        struct S0 ***l_990 = &l_777;
        struct S0 ****l_989 = &l_990;
        int32_t **l_996 = &l_764;
        int8_t l_1019 = 1;
        uint16_t l_1052 = 0xEC2C;
        uint32_t l_1066 = 0x54C8AE15;
        int32_t l_1067 = 0;
        int32_t l_1071 = 1;
        const float l_1073 = 0x5.E85CE3p+14;
        int32_t l_1074 = 1;
        int32_t l_1099 = 0x0A2AEA5D;
        int8_t l_1128 = 0x0A;
        int16_t l_1137 = 0x2780;
        int32_t l_1168 = 0xF96E3725;
        int32_t **l_1205 = &l_764;
        const int32_t l_1206 = 1;
        int8_t l_1290 = 0xF2;
        float l_1297 = (-0x1.1p-1);
        (*l_766) = func_36(func_36(func_36(l_764, (*l_764)), l_765), (*l_759));
        if (__builtin_popcountl((*l_759)))
        { /* block id: 389 */
            int32_t l_771 = 0xA3AE44DF;
            (*l_766) = (*l_766);
            for (l_761.f3 = 0; (l_761.f3 <= (-28)); --l_761.f3)
            { /* block id: 393 */
                struct S0 **l_779 = &l_778;
                uint32_t l_781 = 4294967289U;
                struct S0 ***l_783 = &l_779;
                struct S0 ****l_782 = &l_783;
                (*l_782) = ((**l_766) , ((((safe_sub_func_int16_t_s_s(((l_771 != (safe_add_func_int16_t_s_s((safe_add_func_uint32_t_u_u((((0 ^ (!(-1))) , l_777) == l_779), (safe_unary_minus_func_int32_t_s((l_781 ^ ((((*l_764) < (0xF45733F4 || 0xD1199B03)) != (*l_759)) & l_771)))))), (*l_764)))) <= 0x6A766C46), l_771)) , 1) < (*l_759)) , &l_777));
                return l_781;
            }
            (*l_766) = (*l_766);
        }
        else
        { /* block id: 398 */
            struct S1 l_784 = {-1,0,4294967286U,0x25,0x1.8p+1,0xF702D878,0};
            int32_t **l_788 = &l_764;
            struct S1 **l_792 = (void*)0;
            struct S1 ***l_791 = &l_792;
            struct S1 ****l_790 = &l_791;
            struct S1 *****l_789 = &l_790;
            float *l_800 = &l_784.f4;
            const struct S0 l_818 = {-1,0x4C56,0x669FDC6B,65533U,65531U,0xBE4A,0x976E79FA,0xB123,0U};
            const struct S0 *l_817 = &l_818;
            const struct S0 **l_816 = &l_817;
            const struct S0 ***l_815 = &l_816;
            const struct S0 ****l_814 = &l_815;
            const int8_t l_837 = 0xC3;
            uint32_t l_851 = 1U;
            uint32_t l_876 = 4294967294U;
            uint16_t l_921 = 0x5F1A;
            int32_t ***l_925 = &l_919;
            int32_t ****l_924 = &l_925;
            struct S1 l_968 = {0x592C592F,0xCDA5,1U,0xCB,-0x1.Dp-1,0x7FF45223,0x2E};
            uint32_t l_984 = 0x97290DEA;
            struct S1 ***l_992 = &l_799;
            int8_t l_994 = 0x9C;
            int8_t l_1018 = (-1);
            int16_t l_1022 = 3;
            (*l_760) = l_784;
            (*l_800) = ((-(*l_759)) < __builtin_ffsll((safe_sub_func_int32_t_s_s(((*l_759) > ((-1) >= (func_80((*l_764), l_788) , (**l_788)))), (l_789 == ((safe_lshift_func_int16_t_s_s(((**l_766) && 0xC12A), l_795)) , l_796))))));
            if ((*l_759))
            { /* block id: 401 */
                struct S0 l_802 = {1,0xAAFD,2,8U,0x80EF,-1,1U,3U,0x6939E7FD};
                struct S0 *l_801 = &l_802;
                int16_t l_803 = 4;
                const int8_t l_810 = 0x11;
                uint16_t l_813 = 0x764F;
                const int8_t l_819 = (-1);
                const uint32_t l_823 = 1U;
                int32_t **l_838 = &l_759;
                struct S1 l_872 = {0x1F26E130,0,1U,1,-0x1.5p+1,0x7DCDE9E1,-3};
                int32_t l_958 = 0x6A5453A2;
                uint32_t l_959 = 0U;
                int8_t l_961 = 0x4D;
                struct S1 *****l_966 = &l_790;
                uint32_t l_985 = 0x48E0200E;
                (*l_777) = l_801;
                if (l_803)
                { /* block id: 403 */
                    int8_t l_808 = 0x57;
                    int16_t l_836 = 0x9DD8;
                    int32_t **l_840 = &l_764;
                    int32_t **l_846 = &l_764;
                    int32_t *****l_871 = (void*)0;
                    struct S1 l_875 = {-6,0xF2DC,4294967295U,0x4B,0x8.8A8094p-59,1,0xD9};
                    if ((safe_div_func_int16_t_s_s((-4), (safe_sub_func_int16_t_s_s((l_808 != (l_809 , (l_808 >= ((l_810 == (((safe_lshift_func_uint16_t_u_s((*l_759), (l_813 , 0x3F63))) != (l_814 == (void*)0)) , (*l_764))) == 2U)))), l_819)))))
                    { /* block id: 404 */
                        struct S1 l_820 = {0xE5C6871E,0x3189,0x563A4C6F,0x01,0x6.A05972p+7,0x9182BD3A,0xBD};
                        (***l_798) = l_809;
                        (*l_800) = ((l_820 , (l_820.f3 < (-0x8.Cp+1))) == (*l_759));
                    }
                    else
                    { /* block id: 407 */
                        int32_t **l_839 = &l_764;
                        struct S0 ***l_860 = &l_777;
                        (**l_839) = ((0x30E4 & (safe_add_func_int16_t_s_s((l_808 || (0xD7C358D9 >= (l_831 <= (*l_759)))), 65526U))) , ((**l_788) ^ (((l_836 <= (func_60(func_88(((l_808 >= l_837) , 0xE29BB0A5), l_838, (*l_764), l_839, (**l_766)), (*l_759), l_840, (**l_838)) != (*l_759))) ^ (**l_839)) >= 1)));
                        (*l_788) = func_36((*l_839), (safe_lshift_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_s((l_845 != l_846), 15)) <= (((safe_sub_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(0U, (**l_788))), l_851)) ^ ((((0xCFE442D1 > ((safe_mul_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((((**l_839) & (safe_mod_func_int16_t_s_s((-6), (*l_764)))) && (**l_838)), (**l_839))), l_858)) && 4U)) && 0x989CAA24) ^ (**l_766)) , l_859)) < 0xBCBA)), (**l_788))));
                        (*l_860) = &l_778;
                    }
                    (**l_846) = (((safe_lshift_func_int16_t_s_s(0xEA4A, 1)) && (*l_759)) , (((**l_788) != (-1)) != 1U));
                    (**l_840) = (func_60(l_838, (**l_788), l_788, (((((safe_unary_minus_func_int16_t_s(((**l_788) & (**l_838)))) >= ((*l_764) ^ (**l_788))) == __builtin_bswap64(((*l_759) , (safe_lshift_func_int16_t_s_s(func_60(((((((&l_766 == (void*)0) >= 0x6A85F7A4) , (-1)) , (*l_759)) < (*l_759)) , (void*)0), (**l_840), l_838, (**l_788)), (**l_838)))))) | 0xBF40) > (*l_759))) | l_867);
                    if (__builtin_ctzl(((*l_759) , (((safe_div_func_int16_t_s_s(((void*)0 != l_871), (**l_788))) > (**l_788)) | 0x581D))))
                    { /* block id: 414 */
                        (*l_838) = (void*)0;
                        (*l_846) = func_36((*l_840), (*l_764));
                        (*l_760) = l_872;
                    }
                    else
                    { /* block id: 418 */
                        uint32_t l_879 = 1U;
                        int32_t ****l_881 = (void*)0;
                        int32_t *****l_880 = &l_881;
                        uint32_t l_884 = 1U;
                        (*l_759) = (safe_add_func_int32_t_s_s((l_875 , (l_876 == (safe_sub_func_uint32_t_u_u(4294967294U, 0x4BDB6B0B)))), l_879));
                        (**l_838) = ((0x4D34 ^ (0xF6C3 ^ ((-1) >= ((((**l_766) , l_880) != (void*)0) , ((((safe_lshift_func_int16_t_s_u(((void*)0 != (*l_777)), 15)) >= ((**l_788) == (**l_838))) <= l_884) ^ (**l_838)))))) , (*l_764));
                        (*l_800) = (*l_759);
                    }
                }
                else
                { /* block id: 423 */
                    int16_t l_887 = 5;
                    struct S0 **l_914 = &l_778;
                    int8_t l_939 = 4;
                    if ((safe_mod_func_uint32_t_u_u(l_887, (((safe_add_func_int16_t_s_s((**l_838), (safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s((**l_838), 11)), (safe_mul_func_int16_t_s_s((l_887 > ((safe_lshift_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u((safe_lshift_func_int16_t_s_s((l_902 != (void*)0), (safe_div_func_uint16_t_u_u((**l_838), (safe_add_func_uint16_t_u_u(0x3B9F, l_887)))))), (**l_766))) != 1), 0)) , (**l_838))), (**l_838))))))) , 0U) ^ 4294967292U))))
                    { /* block id: 424 */
                        struct S0 **l_915 = &l_801;
                        const int32_t l_920 = 0x8E961EB0;
                        (**l_788) = (0x64751D6D == ((safe_lshift_func_int16_t_s_u(((safe_mod_func_uint32_t_u_u(((**l_788) && ((safe_rshift_func_int16_t_s_u((l_914 == l_915), (safe_mul_func_uint16_t_u_u(((*l_759) >= (*l_759)), ((~(*l_764)) | l_921))))) >= 0x17E6)), 0xA7A14623)) , 1), l_920)) <= 0x0E247D40));
                        (*l_759) = (65535U != l_887);
                        (**l_788) = (safe_mul_func_int16_t_s_s((**l_788), (l_924 != (void*)0)));
                    }
                    else
                    { /* block id: 428 */
                        int32_t *l_938 = &l_784.f0;
                        (****l_797) = l_872;
                        (**l_788) = (safe_unary_minus_func_uint32_t_u(((safe_rshift_func_uint16_t_u_u(l_887, 8)) < ((((safe_sub_func_int16_t_s_s((safe_mod_func_uint32_t_u_u((l_933 == (void*)0), (safe_add_func_int16_t_s_s((-1), 7U)))), (**l_838))) || 0xFB2CE939) , (void*)0) != (void*)0))));
                    }
                }
                if ((*l_764))
                { /* block id: 433 */
                    struct S0 l_940 = {0x31F5BD12,0x3494,-2,1U,65535U,1,3U,5U,4294967287U};
                    uint32_t l_947 = 2U;
                    const uint16_t l_960 = 0x606D;
                    (**l_788) = (((l_940 , ((safe_lshift_func_uint16_t_u_s((((((**l_788) || 0x01A880AA) && (**l_788)) | (((((((safe_add_func_int32_t_s_s(((l_940.f8 , l_947) >= ((safe_sub_func_int32_t_s_s((safe_mul_func_uint16_t_u_u(((safe_sub_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(l_940.f6, ((safe_add_func_int16_t_s_s(0xEB53, l_940.f2)) | (-4)))), (*l_764))) > l_940.f6), l_803)), 0x6F1ACD70)) == l_940.f2)), (**l_766))) >= 0xE7FA5E4F) | (**l_766)) , l_809) , (**l_766)) , l_958) > 0)) , l_947), (**l_766))) < l_959)) , l_802.f8) ^ l_960);
                    (***l_789) = (**l_790);
                    (**l_788) = l_961;
                    (*l_799) = l_962;
                }
                else
                { /* block id: 438 */
                    uint32_t l_965 = 0xE27D63F6;
                    struct S0 l_991 = {3,0x33E8,-4,0x4A59,65535U,0x21FF,0U,65533U,0x569C4C0C};
                    for (l_876 = 0; (l_876 >= 59); l_876 = safe_add_func_int16_t_s_s(l_876, 1))
                    { /* block id: 441 */
                        return l_965;
                    }
                    if (((*l_764) , (l_966 != l_967)))
                    { /* block id: 444 */
                        struct S1 **l_981 = &l_760;
                        int32_t l_982 = (-7);
                        struct S0 ***l_983 = &l_777;
                        (*l_760) = l_968;
                        (**l_766) = (safe_mul_func_int16_t_s_s(((safe_sub_func_uint32_t_u_u(((((safe_sub_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((((l_965 && (safe_mod_func_int16_t_s_s((safe_add_func_int32_t_s_s(((l_981 == (**l_797)) , (l_965 != l_982)), (((*l_814) != ((**l_788) , l_983)) , ((void*)0 != &l_902)))), l_982))) & l_984) , (**l_788)) && l_965), l_982)), l_965)) && 3U) < 0xC11D) && l_965), (**l_766))) < l_872.f6), 1U));
                        return l_982;
                    }
                    else
                    { /* block id: 448 */
                        int8_t l_988 = 0x9D;
                        (*l_764) = l_985;
                        (*l_800) = ((l_802.f1 , (safe_rshift_func_int16_t_s_u((*l_764), 6))) , (((l_965 , l_988) < 0xE.280650p+68) != (((**l_788) , (l_965 , &l_815)) == l_989)));
                    }
                    (**l_788) = l_965;
                    l_993 = func_80((l_991 , (__builtin_parityl((**l_766)) && (l_992 == (**l_967)))), &l_764);
                }
            }
            else
            { /* block id: 455 */
                uint32_t l_995 = 4294967288U;
                int32_t *l_997 = &l_784.f0;
                const float l_999 = 0x0.2p+1;
                int16_t l_1027 = (-1);
                (****l_797) = (l_994 , func_80(l_995, func_88((*l_764), l_996, (l_995 , l_995), func_65((****l_814), l_997, (((*l_997) != (**l_788)) > 0x9EDF0DF3)), (*l_764))));
                (***l_798) = l_1000;
                for (l_784.f5 = (-3); (l_784.f5 >= 0); l_784.f5 = safe_add_func_uint32_t_u_u(l_784.f5, 1))
                { /* block id: 460 */
                    float l_1007 = 0x5.ABAD44p+3;
                    int32_t l_1008 = 0;
                    int32_t **l_1020 = &l_764;
                    int32_t *l_1033 = &l_784.f0;
                    struct S1 l_1034 = {0x80E221C9,0,4U,1,0x1.0F12A1p+96,-10,-2};
                    int32_t **l_1035 = &l_759;
                    int8_t l_1040 = 0x21;
                    for (l_33 = 13; (l_33 < (-1)); l_33--)
                    { /* block id: 463 */
                        int32_t l_1005 = 1;
                        int32_t *l_1006 = (void*)0;
                        struct S1 l_1009 = {0x8F96CF09,-3,0xD3C7280D,4,0x9.A398DCp-12,0x8DDC3B13,0xCD};
                        int32_t l_1017 = 1;
                        int32_t l_1021 = 0x15B76557;
                        (*l_798) = (**l_790);
                        (*l_996) = (l_1005 , l_1006);
                        (*l_800) = l_1009.f1;
                    }
                    if (l_1022)
                        continue;
                    (*l_1033) = func_60(func_88(((safe_sub_func_uint16_t_u_u(((((((*l_759) | (0 > (*l_759))) && 0x69EF) < l_1027) >= ((l_1034 , 0) <= 0xC112F955)) , 1U), 65535U)) , 4294967287U), (**l_933), (*l_997), l_1035, (*l_1033)), (*l_997), &l_997, (*l_997));
                    (*l_1033) = (func_60(((*l_759) , &l_1033), (l_1034 , ((*l_997) , ((__builtin_clzl((safe_mod_func_int16_t_s_s((((0x690F && (safe_sub_func_int16_t_s_s((*l_997), ((void*)0 != &l_815)))) != (*l_1033)) > 0x6A7C4D51), 0x4E4B))) , (void*)0) == (void*)0))), &l_1033, (*l_997)) , l_1040);
                }
                (*l_997) = (*l_997);
            }
        }
        for (l_858 = 0; (l_858 == 49); l_858 = safe_add_func_int32_t_s_s(l_858, 6))
        { /* block id: 477 */
            int32_t l_1045 = 0xE6477862;
            int32_t **l_1048 = &l_759;
            const int32_t l_1051 = 0x063C7C29;
            float *l_1053 = &l_993.f4;
            for (l_1014 = 26; (l_1014 <= 27); l_1014 = safe_add_func_int32_t_s_s(l_1014, 7))
            { /* block id: 480 */
                return l_1045;
            }
            if (l_1045)
                break;
            (*l_1053) = ((safe_add_func_float_f_f((l_1048 == (**l_933)), l_1045)) >= (safe_sub_func_float_f_f(l_1052, l_1051)));
        }
        if ((((l_868.f1 <= l_1074) , l_993.f5) & l_993.f6))
        { /* block id: 486 */
            float *l_1077 = &l_998;
            (*l_1077) = l_1076;
        }
        else
        { /* block id: 488 */
            uint32_t l_1078 = 0x070AADA0;
            uint32_t l_1080 = 0xA1D745BB;
            struct S1 l_1087 = {1,0xD664,4294967290U,0,-0x8.3p+1,1,0x19};
            int16_t l_1088 = 0x3525;
            struct S1 **l_1089 = (void*)0;
            uint16_t l_1090 = 0x121F;
            int32_t **l_1091 = &l_759;
            int32_t **l_1092 = &l_759;
            uint16_t l_1105 = 65533U;
            uint16_t l_1124 = 1U;
            struct S0 l_1145 = {0x43550596,-1,0xC424A72B,0x72EA,7U,-1,0xA5E072D0,65533U,4294967291U};
            uint32_t l_1146 = 0U;
            const int16_t l_1149 = (-1);
            int32_t **l_1186 = &l_759;
            struct S0 ****l_1189 = &l_990;
            uint32_t l_1197 = 0x19E8E97B;
            const uint32_t l_1239 = 0xC3638B66;
            uint16_t l_1255 = 0xD4EC;
            struct S1 ****l_1270 = &l_798;
            int32_t l_1289 = 0x5474B9BF;
            if ((l_1078 , l_1078))
            { /* block id: 489 */
                int32_t *l_1081 = &l_33;
                int32_t *l_1083 = &l_868.f0;
                uint16_t l_1085 = 65531U;
                struct S1 l_1086 = {7,3,1U,0,0xD.08E82Dp+94,-1,0};
                uint16_t l_1095 = 1U;
                int32_t ***l_1107 = &l_1091;
                struct S0 ****l_1113 = &l_990;
                int32_t l_1120 = 1;
                if (l_1080)
                { /* block id: 490 */
                    float l_1082 = 0x9.57CFD6p-19;
                    l_1083 = func_36(l_1081, l_1080);
                    l_1087 = l_1086;
                }
                else
                { /* block id: 493 */
                    const float l_1093 = 0x0.Dp-1;
                    const int32_t l_1094 = 1;
                    int32_t l_1096 = 0;
                    int32_t **l_1098 = &l_764;
                    uint32_t l_1123 = 1U;
                    int32_t l_1127 = 6;
                    (*l_1081) = (l_1087.f2 <= ((**l_797) != (l_1088 , l_1089)));
                    if (l_1099)
                    { /* block id: 495 */
                        float l_1100 = 0x0.5p+1;
                        int32_t l_1101 = 0x01BF8714;
                        const int32_t l_1106 = 0;
                        uint32_t l_1108 = 0x9020942A;
                        int32_t **l_1109 = &l_1081;
                        (*l_1098) = (__builtin_ctzl(func_60(func_88(((void*)0 == &l_845), l_1098, (*l_1083), ((func_48(((((*l_1083) , (4294967291U && (l_1101 > ((safe_sub_func_int16_t_s_s(l_1101, (safe_unary_minus_func_uint32_t_u((0xCF41 > l_1105))))) | 7U)))) , 6U) , l_1106), l_1107, l_1108, (*l_1081), l_1101) , (*l_1083)) , (**l_933)), l_1108), (*l_1083), l_1109, (**l_1109))) , (*l_1091));
                    }
                    else
                    { /* block id: 497 */
                        int32_t *l_1110 = &l_1000.f0;
                        int32_t l_1121 = 1;
                        struct S1 ***l_1125 = &l_799;
                        (**l_967) = (*l_797);
                        l_1110 = (*l_1098);
                        l_1110 = l_1110;
                        (*l_962) = l_809;
                    }
                }
            }
            else
            { /* block id: 504 */
                int32_t l_1133 = 0xA928AD09;
                int32_t **l_1140 = &l_764;
                int32_t l_1143 = 0xA6A5F5FE;
                uint16_t l_1147 = 0xFF16;
                struct S1 l_1150 = {0xF38299E4,0xC670,5U,1,0xD.838995p-52,0x68030347,1};
                float l_1176 = 0x7.468185p+93;
                float l_1177 = 0xB.AC320Fp+55;
                const struct S0 ***l_1228 = &l_902;
                for (l_868.f0 = 0; (l_868.f0 <= 8); ++l_868.f0)
                { /* block id: 507 */
                    int16_t l_1136 = 0x09EB;
                    int32_t **l_1148 = &l_764;
                    struct S1 *l_1152 = &l_1150;
                    (***l_796) = (*l_798);
                    l_1067 = (safe_sub_func_int32_t_s_s(l_1133, ((safe_mod_func_uint32_t_u_u(l_1136, ((l_1133 || (l_1137 & (safe_add_func_uint32_t_u_u(0x8AC9E04E, 4294967290U)))) || (l_1133 , l_1133)))) >= 0x3C629AA6)));
                    if ((l_1145.f6 , l_1136))
                    { /* block id: 510 */
                        struct S1 l_1151 = {1,0xAFD4,0x5B779934,0x00,0x3.1920A9p-60,0x48CE4B76,0xF6};
                        struct S1 **l_1153 = (void*)0;
                        const struct S1 *l_1155 = (void*)0;
                        const struct S1 **l_1154 = &l_1155;
                        l_1151 = l_1150;
                        (*l_1154) = l_1152;
                    }
                    else
                    { /* block id: 513 */
                        int32_t l_1156 = 0;
                        return l_1156;
                    }
                    if ((safe_lshift_func_uint16_t_u_u(4U, 2)))
                    { /* block id: 516 */
                        const uint32_t l_1165 = 0xD11835EB;
                        float *l_1167 = &l_1000.f4;
                        (*l_1167) = ((safe_add_func_float_f_f(l_1165, 0x6.E06E8Cp-66)) == l_1136);
                        (*l_760) = l_1150;
                        return l_1168;
                    }
                    else
                    { /* block id: 520 */
                        int32_t *l_1169 = &l_1145.f2;
                        float *l_1175 = &l_864;
                        (*l_1169) = 0x0058F98E;
                        (*l_1169) = (*l_1169);
                        (*l_1175) = (((*l_1169) != func_60(&l_1169, (safe_sub_func_int16_t_s_s(l_1150.f1, __builtin_ctzl(l_1172))), &l_1169, (*l_1169))) <= (((safe_sub_func_float_f_f(__builtin_clzll(((0 == 1U) < (*l_1169))), 0x6.6p+1)) == l_1136) > (*l_1169)));
                    }
                }
                l_1150.f0 = l_1087.f5;
                for (l_1087.f0 = (-29); (l_1087.f0 > (-1)); l_1087.f0 = safe_add_func_int16_t_s_s(l_1087.f0, 1))
                { /* block id: 529 */
                    uint16_t l_1193 = 65532U;
                    int32_t *l_1194 = &l_993.f0;
                    int32_t *l_1198 = &l_1150.f0;
                    struct S0 ***l_1230 = (void*)0;
                    struct S1 l_1240 = {1,0xFC15,0xD51D706F,0x32,-0x1.4p-1,1,0x29};
                    for (l_1080 = (-18); (l_1080 >= 60); l_1080 = safe_add_func_uint16_t_u_u(l_1080, 1))
                    { /* block id: 532 */
                        uint16_t l_1190 = 65535U;
                        (*l_1194) = ((safe_add_func_int16_t_s_s((safe_add_func_uint32_t_u_u((*l_1194), l_1190)), l_1147)) && 4U);
                    }
                    (*l_1144) = ((1 ^ __builtin_ia32_crc32qi(l_1147, (*l_1194))) , func_36(func_36(l_1198, ((((*l_1198) > (safe_div_func_int32_t_s_s((0x8C5B || (*l_1198)), (*l_1194)))) < (*l_1194)) , (*l_1198))), (*l_1198)));
                    if ((**l_1144))
                    { /* block id: 536 */
                        float *l_1208 = &l_1087.f4;
                        (*l_1208) = 0xB.DD9A4Cp+90;
                        (*l_1194) = (**l_1186);
                    }
                    else
                    { /* block id: 539 */
                        float *l_1214 = &l_993.f4;
                        int32_t l_1216 = (-1);
                        struct S0 *l_1229 = (void*)0;
                        (*l_1214) = (safe_add_func_float_f_f((-(safe_mul_func_float_f_f((**l_1186), __builtin_clzl((**l_1091))))), (**l_1091)));
                        l_1216 = l_1215;
                        (*l_1214) = ((safe_sub_func_float_f_f((safe_sub_func_float_f_f((((~(safe_sub_func_uint16_t_u_u((safe_add_func_int16_t_s_s((l_1216 , (safe_mod_func_int32_t_s_s((0xDE88C158 || (l_1228 == ((((void*)0 != l_1229) || (*l_1198)) , l_1230))), (~(safe_lshift_func_int16_t_s_s((0xDCCB7F90 != (~(safe_lshift_func_int16_t_s_u(((__builtin_clzl(((*l_1198) , 0x403B611D)) >= 0) , (**l_1092)), l_1150.f5)))), l_1216)))))), (*l_1194))), (*l_1194)))) | 0x9C3A) , (*l_1194)), l_1239)), (**l_1092))) > 0x0.Dp+1);
                    }
                    l_1240 = l_1150;
                }
            }
            for (l_1145.f3 = 0; (l_1145.f3 < 53); l_1145.f3 = safe_add_func_uint16_t_u_u(l_1145.f3, 5))
            { /* block id: 549 */
                for (l_1054 = (-4); (l_1054 != 28); l_1054 = safe_add_func_int32_t_s_s(l_1054, 8))
                { /* block id: 552 */
                    int16_t l_1245 = 1;
                    if (l_1245)
                        break;
                    (*l_766) = (void*)0;
                }
                for (l_937 = 8; (l_937 <= 20); l_937 = safe_add_func_uint16_t_u_u(l_937, 3))
                { /* block id: 558 */
                    int32_t *l_1248 = &l_1099;
                    (*l_1248) = ((void*)0 != l_967);
                    for (l_1000.f1 = 0; (l_1000.f1 == (-9)); l_1000.f1 = safe_sub_func_int16_t_s_s(l_1000.f1, 4))
                    { /* block id: 562 */
                        uint32_t l_1251 = 0x509FAF11;
                        return l_1251;
                    }
                }
            }
            if (((l_1089 != (void*)0) , (0x5B63 ^ (safe_rshift_func_int16_t_s_u((~0U), l_1255)))))
            { /* block id: 567 */
                uint32_t l_1256 = 3U;
                struct S1 l_1259 = {0x2CD226EC,0x2C9C,0xC1F088C6,2,0x3.Fp-1,0xD85F032A,0xE5};
                int32_t **l_1260 = &l_759;
                (**l_990) = (l_1256 , &l_1145);
                l_33 = l_1256;
                for (l_1071 = 0; (l_1071 <= (-6)); l_1071 = safe_sub_func_int32_t_s_s(l_1071, 6))
                { /* block id: 572 */
                    l_1259 = l_809;
                    (*l_962) = l_1259;
                }
                (*l_996) = (*l_1205);
            }
            else
            { /* block id: 577 */
                int32_t l_1261 = 2;
                int32_t *l_1272 = (void*)0;
                int32_t *l_1273 = &l_993.f0;
                struct S0 *l_1275 = (void*)0;
                const struct S1 l_1279 = {0x05C708A2,0x2466,0U,0x34,0x9.7376D7p-42,0x7ED0DB5D,0};
                const struct S1 **l_1294 = (void*)0;
                const struct S1 ***l_1293 = &l_1294;
                const struct S1 ****l_1292 = &l_1293;
                const struct S1 *****l_1291 = &l_1292;
                (*l_996) = (*l_766);
                (*l_1273) = (l_1261 ^ ((safe_rshift_func_uint16_t_u_u(l_1261, 4)) > (((safe_mul_func_float_f_f(l_1261, (safe_sub_func_float_f_f(l_1261, (safe_add_func_float_f_f(((void*)0 == (**l_933)), (l_1270 != (void*)0))))))) , l_1271) ^ 0x6CD2F247)));
                if ((((((((l_1274 != ((*l_1273) , (*l_796))) , l_1275) == l_1275) , ((*l_1273) >= (safe_mod_func_uint32_t_u_u((__builtin_ia32_crc32qi((*l_1273), __builtin_popcountll((*l_1273))) >= 0U), (*l_1273))))) && (*l_1273)) | 0xE4B0) , l_1145.f8))
                { /* block id: 580 */
                    int32_t *l_1278 = (void*)0;
                    (*l_1144) = l_1278;
                }
                else
                { /* block id: 582 */
                    int32_t *l_1280 = &l_1261;
                    struct S1 *****l_1295 = &l_1270;
                    (*l_760) = l_1279;
                    (*l_766) = l_1280;
                    for (l_1145.f0 = 7; (l_1145.f0 > (-26)); --l_1145.f0)
                    { /* block id: 587 */
                        const int16_t l_1296 = 1;
                        float *l_1298 = &l_1068;
                        (*l_1298) = (((*l_1280) == (safe_mul_func_int16_t_s_s((safe_mul_func_int16_t_s_s((**l_996), (*l_764))), func_60(func_88((*l_764), (*l_934), (**l_1205), (*l_934), ((safe_add_func_int16_t_s_s(((((((**l_766) && (l_1289 | l_1290)) > (**l_766)) , l_1291) == l_1295) ^ 1U), l_1296)) , (*l_1273))), (**l_996), &l_764, (*l_1280))))) , (**l_1205));
                    }
                }
            }
        }
    }
    if ((safe_div_func_int32_t_s_s((l_1301 >= (safe_mod_func_int32_t_s_s(((safe_div_func_int32_t_s_s((l_1306 <= (((safe_unary_minus_func_int16_t_s(((l_1000.f2 > (-3)) , 0x392B))) | (l_1097 && l_1000.f5)) ^ l_993.f6)), l_1309)) < 0x16C3CE73), l_1310))), l_1311)))
    { /* block id: 594 */
        uint32_t l_1314 = 4294967295U;
        int32_t *l_1323 = &l_33;
        (*l_1144) = func_36((((((safe_mod_func_int32_t_s_s(((l_1314 > l_1315) > (((l_1314 <= (safe_mod_func_int32_t_s_s(l_1314, (safe_rshift_func_int16_t_s_s(l_1314, 8))))) & ((l_1314 & (-1)) || l_1314)) || (safe_add_func_int32_t_s_s(l_1314, l_1322)))), 0x38C933C5)) , l_1314) >= l_1314) < l_1314) , l_1323), (*l_1323));
        (*l_933) = (void*)0;
        (*l_1144) = l_1323;
        if ((safe_add_func_uint32_t_u_u(__builtin_ctzl(__builtin_clzl((*l_1323))), (*l_1323))))
        { /* block id: 598 */
            int32_t *l_1326 = &l_1000.f0;
            l_1326 = l_1326;
        }
        else
        { /* block id: 600 */
            struct S1 **l_1327 = &l_760;
            (**l_1274) = l_1327;
            (*l_1144) = l_1323;
        }
    }
    else
    { /* block id: 604 */
        uint32_t l_1328 = 4294967288U;
        int32_t l_1329 = (-6);
        int32_t **l_1330 = &l_759;
        struct S1 *****l_1332 = &l_1274;
        int8_t l_1333 = 0xD7;
        int16_t l_1381 = 0x9655;
        int32_t *****l_1383 = (void*)0;
        float l_1405 = 0x5.21A4C1p+81;
        int32_t **l_1418 = &l_759;
        int32_t l_1433 = 0x5CBE0F7D;
        int32_t l_1463 = 5;
        uint32_t l_1464 = 0xB6DC16DB;
        int32_t l_1490 = 0x4342EA25;
        struct S0 l_1496 = {0xF23E6E99,0xD4F8,7,0xD5B2,7U,9,3U,65534U,0x6316B913};
        int32_t *l_1499 = (void*)0;
        int32_t *l_1500 = (void*)0;
        int32_t *l_1501 = &l_1496.f2;
        if ((l_1328 <= (l_1329 > __builtin_ffsl(l_1329))))
        { /* block id: 605 */
            int32_t l_1345 = (-9);
            uint16_t l_1354 = 0xD452;
            const uint32_t l_1356 = 0x7F233613;
            struct S0 l_1361 = {-1,0x510C,3,0x433C,0x3AE9,0x14ED,0x276A46C2,0xBA81,4294967290U};
            struct S0 *l_1360 = &l_1361;
            int32_t *l_1368 = &l_761.f0;
            for (l_1072 = 16; (l_1072 == 58); l_1072 = safe_add_func_uint16_t_u_u(l_1072, 6))
            { /* block id: 608 */
                int32_t l_1346 = 0;
                int32_t **l_1357 = &l_759;
                struct S1 *l_1358 = &l_993;
                if ((safe_mul_func_int16_t_s_s((safe_add_func_uint16_t_u_u(__builtin_ctzl((0x2A4C > __builtin_ctzl(l_1345))), (((l_1345 & l_1333) , l_1346) < (safe_rshift_func_int16_t_s_s(1, 15))))), l_1346)))
                { /* block id: 609 */
                    uint32_t l_1353 = 0xE7310AAB;
                    struct S0 ***l_1355 = &l_777;
                    struct S1 **l_1359 = &l_760;
                    (**l_1355) = (((safe_lshift_func_int16_t_s_u(((l_1346 == ((safe_div_func_float_f_f(l_1353, ((l_1346 , 0xC.4B2FC4p+81) < l_1353))) , l_1354)) != 5), l_1353)) || l_1353) , (void*)0);
                    (*l_1359) = l_1358;
                    (**l_1359) = (*l_760);
                    (*l_777) = l_1360;
                }
                else
                { /* block id: 614 */
                    int16_t l_1362 = (-8);
                    int32_t *l_1365 = &l_1322;
                    if (l_1362)
                        break;
                    for (l_1000.f5 = (-22); (l_1000.f5 == (-5)); l_1000.f5 = safe_add_func_int32_t_s_s(l_1000.f5, 3))
                    { /* block id: 618 */
                        struct S1 l_1366 = {-4,0x237A,0U,1,-0x1.Ap+1,-2,-1};
                        l_1365 = &l_1346;
                        (*l_962) = l_1366;
                        l_1366.f0 = l_1367;
                    }
                }
                if (l_1346)
                    continue;
                (*l_1357) = l_1368;
            }
        }
        else
        { /* block id: 627 */
            int32_t **l_1375 = (void*)0;
            int32_t l_1378 = 0x6F686970;
            uint32_t l_1382 = 1U;
            struct S1 *l_1386 = &l_993;
            int32_t l_1407 = 0xB0E23E74;
            struct S0 l_1421 = {0,-1,0x37F52142,65534U,0x46EE,1,1U,0x7BED,1U};
            int32_t *l_1432 = &l_1378;
            uint32_t l_1449 = 4294967292U;
            struct S0 **l_1462 = &l_778;
            const struct S1 ****l_1488 = (void*)0;
            const struct S1 *****l_1487 = &l_1488;
            l_1329 = (((safe_rshift_func_int16_t_s_s(0x279E, (((safe_lshift_func_uint16_t_u_s(((safe_mul_func_int16_t_s_s(((l_1330 != l_1375) ^ (safe_div_func_uint16_t_u_u((l_1378 , (safe_sub_func_uint16_t_u_u(((&l_933 != (void*)0) <= (l_1378 > (1 || __builtin_clzll(l_1381)))), l_1382))), l_1382))), l_1333)) , 0x4798), l_1382)) | l_1378) == 0x334F0038))) , (void*)0) != l_1383);
            if ((safe_add_func_uint32_t_u_u(l_1382, l_1382)))
            { /* block id: 629 */
                struct S1 **l_1387 = &l_760;
                int32_t l_1404 = 0x333BDB6B;
                int32_t **l_1406 = &l_759;
                const struct S1 ****l_1410 = (void*)0;
                const struct S1 *****l_1409 = &l_1410;
                int32_t *l_1422 = (void*)0;
                uint32_t l_1435 = 4294967295U;
                int32_t ****l_1440 = &l_934;
                (*l_1387) = l_1386;
                for (l_1333 = 0; (l_1333 == (-15)); l_1333 = safe_sub_func_int16_t_s_s(l_1333, 1))
                { /* block id: 633 */
                    const struct S0 l_1395 = {-1,0x8037,0xF82071CE,0xE149,65535U,0xD4F5,0U,0x1C58,0x4720C36E};
                    struct S1 l_1398 = {-1,7,4294967291U,0xBF,0x2.5p+1,0x455CFAE0,-10};
                    int32_t **l_1402 = &l_759;
                    int8_t l_1403 = 0xAB;
                    struct S1 *****l_1408 = &l_797;
                    int32_t *l_1413 = (void*)0;
                    uint32_t l_1429 = 4294967295U;
                    uint16_t l_1431 = 0x113B;
                    const uint32_t l_1434 = 0x915F9BF8;
                    for (l_1069 = 19; (l_1069 < 5); l_1069 = safe_sub_func_int32_t_s_s(l_1069, 7))
                    { /* block id: 636 */
                        float l_1392 = 0x4.3CB8DEp+85;
                        float *l_1393 = (void*)0;
                        float *l_1394 = &l_998;
                        int32_t l_1399 = 0x35DE7AAE;
                        int32_t **l_1412 = &l_759;
                        (*l_1394) = l_1392;
                        (*l_760) = (**l_1387);
                        (**l_1387) = ((**l_1387) , (*l_1386));
                        (*l_760) = (*l_1386);
                    }
                    (*l_1144) = &l_1378;
                }
                (*l_1330) = func_36(((((l_1435 , (((safe_rshift_func_int16_t_s_u((*l_1432), (l_1328 <= (safe_mod_func_uint16_t_u_u((*l_1432), ((l_1440 != (void*)0) && (((__builtin_bswap64((safe_rshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((safe_unary_minus_func_int16_t_s((__builtin_clz((((func_69(l_1446) , l_1447) || (-7)) <= 8)) && 0x7E20F05A))), l_1448)), (*l_1432)))) ^ l_1449) , 6) | (-1)))))))) , 0xCC) , (*l_1432))) , 0x2AFC) , (*l_1432)) , &l_1329), (*l_1432));
            }
            else
            { /* block id: 645 */
                uint32_t l_1454 = 0xF4F75C18;
                for (l_1310 = (-26); (l_1310 < 44); l_1310 = safe_add_func_int16_t_s_s(l_1310, 1))
                { /* block id: 648 */
                    int32_t *l_1453 = &l_1433;
                    (*l_1330) = l_1453;
                    return l_1454;
                }
                (*l_1432) = l_1454;
            }
            (*l_1432) = (((safe_add_func_int32_t_s_s((65527U || (safe_mod_func_uint16_t_u_u(l_1459, ((((*l_1432) < l_1460) >= 0x0.4p+1) , (safe_unary_minus_func_int32_t_s((l_1462 != &l_778))))))), (((0x8698 ^ ((&l_777 != &l_1462) || l_1463)) , (*l_1432)) & l_1381))) > 1U) <= (*l_1432));
            if (l_1464)
            { /* block id: 655 */
                int16_t l_1467 = 0x9F26;
                int32_t **l_1485 = &l_1432;
                struct S1 l_1486 = {0x74D45166,0xC5EB,1U,1,0xB.F216DFp-26,0xE88FB0D1,0xDD};
                float *l_1489 = &l_1068;
                l_1486 = func_80(((safe_add_func_int16_t_s_s((*l_1432), l_1467)) > (safe_mod_func_int32_t_s_s(0xAFF0DA1D, (safe_sub_func_int32_t_s_s((~(((0x1D0B == (safe_mod_func_uint16_t_u_u(__builtin_clzl(((safe_mul_func_int16_t_s_s(((safe_lshift_func_int16_t_s_s(((((l_1467 , (!(((safe_div_func_uint16_t_u_u(((*l_1432) < (*l_1432)), (safe_lshift_func_int16_t_s_u(l_1467, (*l_1432))))) && l_1467) && 0x46B9))) >= 0x5050) , (*l_934)) != (void*)0), 0)) & l_1484), 0x105B)) , l_1467)), l_1467))) & l_1467) || 0x31F9)), l_1467))))), l_1485);
                l_1487 = (void*)0;
                (**l_1485) = ((*l_1432) <= (((((l_1421 , l_1489) != l_1489) | (l_1490 && ((0x998C && ((*l_1432) < ((*l_1432) == __builtin_popcount(((void*)0 == &l_778))))) != (*l_1432)))) , (-0x7.4p+1)) <= (-0x5.Bp+1)));
            }
            else
            { /* block id: 659 */
                int8_t l_1491 = 0xC4;
                (*l_1144) = func_36(func_36(&l_1378, l_1491), l_1491);
                (**l_1144) = (~l_1493);
            }
        }
        (*l_1501) = (safe_mod_func_uint16_t_u_u(65535U, (l_1496 , l_1464)));
        for (l_1310 = (-18); (l_1310 < 47); l_1310 = safe_add_func_int32_t_s_s(l_1310, 1))
        { /* block id: 667 */
            float *l_1504 = &l_1068;
            (*l_1504) = (-0x1.7p+1);
        }
    }
    return l_1505;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_36(int32_t * p_37, uint16_t  p_38)
{ /* block id: 42 */
    int32_t l_40 = 0;
    int32_t *l_39 = &l_40;
    int32_t **l_41 = &l_39;
    const int32_t *l_47 = &l_40;
    const int32_t **l_46 = &l_47;
    struct S1 l_59 = {-1,0,0U,-8,0x4.Ap-1,-1,0xD8};
    int32_t ***l_757 = &l_41;
    int32_t ****l_756 = &l_757;
    int32_t *l_758 = &l_40;
    (*l_41) = l_39;
    (*l_756) = (p_38 , func_42(&l_41, l_46, (func_48((**l_41), func_54(l_59, l_59, func_60(func_65(func_69((((safe_mod_func_int16_t_s_s(((void*)0 == &l_41), 0x2BAB)) <= 0x68E480B0) ^ (**l_46))), p_37, (**l_46)), p_38, &l_39, (*l_39)), &l_39), p_38, p_38, (**l_41)) , &l_41)));
    (**l_41) = (*p_37);
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t *** func_42(int32_t *** p_43, const int32_t ** p_44, int32_t *** p_45)
{ /* block id: 254 */
    int32_t l_452 = 0x7320F75E;
    int32_t *l_470 = (void*)0;
    int32_t **l_469 = &l_470;
    struct S1 l_471 = {0x4739A51E,5,9U,5,0x0.5p-1,-1,0x28};
    int16_t l_485 = 0x195E;
    uint32_t l_488 = 0xF1BC9D70;
    struct S0 l_490 = {0x628FBCA9,0x0C2B,0xAB4C6E2B,0x3278,0xB8FE,5,0x89B16D8A,0x03ED,0x6BDD7E7F};
    float l_516 = (-0x3.Ep-1);
    struct S0 *l_520 = &l_490;
    struct S0 **l_519 = &l_520;
    int32_t *l_578 = &l_490.f0;
    int32_t ***l_624 = &l_469;
    int32_t ****l_623 = &l_624;
    int32_t *****l_622 = &l_623;
    uint32_t l_639 = 0U;
    uint16_t l_669 = 0xB374;
    int32_t l_694 = 0x1B94CB40;
    struct S1 *l_721 = (void*)0;
    struct S1 **l_720 = &l_721;
    struct S1 ***l_719 = &l_720;
    struct S1 ****l_718 = &l_719;
    uint32_t l_730 = 0xEB85BF3D;
    uint16_t l_754 = 65535U;
    float *l_755 = &l_471.f4;
    for (l_452 = (-21); (l_452 < (-16)); l_452 = safe_add_func_int16_t_s_s(l_452, 1))
    { /* block id: 257 */
        struct S1 l_456 = {-6,0xBC62,0xA049B235,0x5C,0x1.5p+1,0x1BD91A23,0x8A};
        struct S1 *l_455 = &l_456;
        int32_t ****l_464 = (void*)0;
        int32_t *****l_463 = &l_464;
        struct S0 l_474 = {0x03F76D67,0x422D,0x24052EEA,65535U,0xCF48,1,0U,65534U,6U};
        struct S0 *l_473 = &l_474;
        struct S0 **l_472 = &l_473;
        int32_t **l_499 = &l_470;
        int8_t l_518 = (-2);
        int8_t l_610 = 5;
        struct S0 *l_664 = (void*)0;
        uint32_t l_680 = 4294967295U;
        struct S1 ****l_704 = (void*)0;
        struct S1 *****l_703 = &l_704;
        uint32_t l_728 = 4294967287U;
        (*l_455) = func_80(l_452, (*p_43));
    }
    (*l_755) = ((safe_sub_func_float_f_f((safe_sub_func_float_f_f((-0x1.7p-1), (safe_sub_func_float_f_f(((void*)0 == (*l_720)), (*l_578))))), (safe_sub_func_float_f_f((*l_578), l_754)))) <= (*l_578));
    (***p_45) = (-6);
    (***l_718) = (void*)0;
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_48(const uint16_t  p_49, int32_t *** p_50, uint16_t  p_51, int32_t  p_52, float  p_53)
{ /* block id: 241 */
    uint16_t l_423 = 65529U;
    struct S1 l_425 = {0x1D21E9CE,-6,0x3D818842,0xB2,-0x1.Ep-1,0xA678C517,-5};
    struct S1 *l_424 = &l_425;
    const float l_428 = (-0x1.Ep-1);
    int32_t l_433 = 0xF81DC6F3;
    float *l_439 = (void*)0;
    int32_t *l_441 = &l_433;
    int32_t **l_440 = &l_441;
    const struct S0 l_451 = {0xE9268ECC,-1,0xD52031F2,0xB875,65535U,-1,0x635DCA35,0xF5B1,5U};
    (*l_440) = (((((safe_lshift_func_uint16_t_u_u((((p_51 ^ l_423) , (p_52 & (((l_424 != ((((safe_sub_func_int16_t_s_s(l_425.f2, (safe_mul_func_int16_t_s_s(((safe_sub_func_int16_t_s_s(l_433, l_425.f1)) , l_423), ((safe_mul_func_uint16_t_u_u((safe_div_func_int32_t_s_s((!0x2C39), 0x7EA1D27C)), l_425.f2)) <= 0xF1DE974F))))) || p_49) >= l_425.f1) , &l_425)) != l_425.f6) , 0x4CCF6A44))) || l_425.f2), l_425.f1)) && 0x4D23D029) , (void*)0) == l_439) , &l_433);
    for (l_425.f1 = (-19); (l_425.f1 <= (-4)); ++l_425.f1)
    { /* block id: 245 */
        struct S1 **l_446 = (void*)0;
        struct S1 ***l_445 = &l_446;
        struct S1 ****l_444 = &l_445;
        struct S1 *****l_447 = &l_444;
        (*l_447) = l_444;
    }
    if (p_51)
    { /* block id: 248 */
        const struct S0 l_448 = {-1,0xCEA6,0,6U,0U,0xEF2A,0x02D725E3,0xA1E9,0xB2589F4A};
        return l_448;
    }
    else
    { /* block id: 250 */
        int32_t l_449 = (-2);
        float *l_450 = &l_425.f4;
        (*l_450) = l_449;
        return l_451;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t *** func_54(struct S1  p_55, struct S1  p_56, uint16_t  p_57, int32_t ** p_58)
{ /* block id: 238 */
    const float l_416 = 0xD.C9A296p-59;
    int32_t l_417 = (-1);
    int32_t **l_419 = (void*)0;
    int32_t ***l_418 = &l_419;
    int32_t ***l_420 = (void*)0;
    l_417 = l_417;
    return l_420;
}


/* ------------------------------------------ */
/* 
 * reads : l_39 l_40
 * writes:
 */
inline static uint16_t  func_60(int32_t ** p_61, int8_t  p_62, int32_t ** p_63, const uint16_t  p_64)
{ /* block id: 95 */
    int16_t l_192 = 0x04D3;
    int32_t *l_193 = (void*)0;
    struct S0 l_195 = {0x71EFC389,0x0A6E,-1,0x5A95,1U,0,0U,0xF3EE,1U};
    struct S0 *l_194 = &l_195;
    int16_t l_200 = 0x70A5;
    int8_t l_216 = 0x4E;
    int32_t **l_218 = &l_193;
    int32_t ***l_217 = &l_218;
    struct S1 l_236 = {-3,6,0xF040C40D,0xDE,0x0.D1DC79p+32,0,0xFA};
    int32_t l_415 = 0x77335672;
    if (((safe_lshift_func_uint16_t_u_u(p_64, l_192)) | ((*p_63) == l_193)))
    { /* block id: 96 */
        struct S0 **l_196 = (void*)0;
        struct S0 l_198 = {1,0x4F93,7,0xEEBA,0xCA5C,0x174C,8U,0U,2U};
        struct S0 *l_197 = &l_198;
        l_197 = l_194;
    }
    else
    { /* block id: 98 */
        uint32_t l_199 = 0x21D5CA3C;
        int32_t ***l_201 = (void*)0;
        const int32_t *l_205 = &l_195.f2;
        const int32_t **l_204 = &l_205;
        const int32_t ***l_203 = &l_204;
        const int32_t ****l_202 = &l_203;
        int32_t ****l_209 = (void*)0;
        int32_t *****l_208 = &l_209;
        l_200 = l_199;
        (*l_202) = l_201;
        for (l_195.f4 = (-23); (l_195.f4 < 30); ++l_195.f4)
        { /* block id: 103 */
            return p_64;
        }
        (*l_208) = &l_203;
    }
    if ((safe_sub_func_int32_t_s_s((&p_63 == (void*)0), 4294967288U)))
    { /* block id: 108 */
        uint16_t l_212 = 0xF730;
        struct S1 l_215 = {0xE960850B,0xF93A,4294967292U,0x8F,0xA.12D827p+19,0x6EFAB756,0x74};
        struct S0 *l_220 = &l_195;
        int32_t *l_239 = &l_236.f0;
        const int32_t *l_241 = &l_195.f2;
        struct S1 **l_286 = (void*)0;
        struct S1 ***l_285 = &l_286;
        const int32_t **l_296 = &l_241;
        const int32_t ***l_295 = &l_296;
        const int32_t ****l_294 = &l_295;
        const int32_t *****l_293 = &l_294;
        if (__builtin_popcount((l_212 , (safe_sub_func_uint16_t_u_u((l_215 , l_216), __builtin_ffsl((((((l_217 != (void*)0) || (!__builtin_ia32_crc32qi((l_220 == &l_195), __builtin_ffsl(((safe_sub_func_int16_t_s_s(__builtin_clzl(((safe_mod_func_uint32_t_u_u((safe_add_func_uint16_t_u_u(p_64, (safe_add_func_uint16_t_u_u(65535U, 0)))), 0xE153FFEB)) , p_62)), (-1))) >= (**p_63)))))) | (-1)) && l_215.f2) | 0)))))))
        { /* block id: 109 */
            const int32_t l_233 = 1;
            const int32_t *l_242 = &l_236.f0;
            struct S0 l_251 = {0x547ADA87,3,0,0U,0U,1,1U,1U,1U};
            int32_t l_267 = 0x32CC38E0;
            if ((safe_add_func_int32_t_s_s((((safe_rshift_func_uint16_t_u_s(((p_62 == l_233) , (safe_rshift_func_uint16_t_u_u((p_64 , (((l_236 , l_233) <= 0xC0A8395A) != (safe_mul_func_uint16_t_u_u((&p_61 == &p_61), (((8U <= p_62) ^ 0) && l_215.f5))))), 3))), l_215.f2)) , (void*)0) == (void*)0), 0x8A74AC35)))
            { /* block id: 110 */
                int32_t *l_240 = &l_195.f2;
                int32_t **l_243 = &l_240;
                l_239 = (*p_63);
                (**l_217) = l_240;
                l_241 = &l_233;
                (*l_243) = l_242;
            }
            else
            { /* block id: 115 */
                int32_t l_248 = 0;
                struct S1 l_268 = {0x1F37E9A4,0x5BC5,3U,0xE8,-0x6.4p-1,2,0xA9};
                struct S1 *l_276 = &l_215;
                struct S1 **l_275 = &l_276;
                for (l_212 = (-29); (l_212 >= 50); l_212 = safe_add_func_uint16_t_u_u(l_212, 1))
                { /* block id: 118 */
                    int32_t l_247 = 0xBAC825AF;
                    (**l_217) = (**l_217);
                    (**l_217) = (*p_63);
                    (*l_239) = (**p_63);
                    if ((((***l_217) , ((1U >= ((~p_64) >= ((l_247 && (l_248 && ((safe_rshift_func_int16_t_s_s(3, 11)) && (**p_63)))) && 0xFB74))) , l_251)) , (**p_63)))
                    { /* block id: 122 */
                        uint32_t l_252 = 0U;
                        return l_252;
                    }
                    else
                    { /* block id: 124 */
                        float *l_253 = &l_215.f4;
                        (*l_239) = (*l_241);
                        (*l_253) = p_64;
                        (*l_253) = ((void*)0 == p_63);
                        (*l_218) = (*p_63);
                    }
                }
                for (l_236.f6 = 27; (l_236.f6 < 21); l_236.f6 = safe_sub_func_uint16_t_u_u(l_236.f6, 5))
                { /* block id: 133 */
                    struct S1 *l_271 = &l_268;
                    struct S1 **l_270 = &l_271;
                    struct S1 ***l_269 = &l_270;
                    int32_t l_272 = 0x52471F1D;
                    float *l_273 = (void*)0;
                    float *l_274 = &l_268.f4;
                    l_248 = (~(safe_div_func_int32_t_s_s(((safe_mod_func_int32_t_s_s((**p_63), (safe_rshift_func_int16_t_s_u(((65529U != l_248) != (safe_mul_func_int16_t_s_s((*l_239), (*l_241)))), ((safe_rshift_func_uint16_t_u_u(0U, 1)) , ((p_62 , p_64) | (*l_239))))))) || 0), l_248)));
                    if (l_267)
                    { /* block id: 135 */
                        (**l_217) = (*p_63);
                        l_268 = l_215;
                        (*l_218) = (*l_218);
                    }
                    else
                    { /* block id: 139 */
                        l_269 = l_269;
                        (**l_217) = &l_248;
                        return l_272;
                    }
                    (*l_274) = p_64;
                }
                (*l_275) = &l_268;
                (*l_239) = (**p_63);
            }
            (*l_218) = l_239;
            for (l_267 = 0; (l_267 > 24); l_267 = safe_add_func_uint16_t_u_u(l_267, 1))
            { /* block id: 152 */
                int32_t *l_279 = &l_251.f2;
                (*l_218) = l_279;
            }
        }
        else
        { /* block id: 155 */
            uint32_t l_280 = 1U;
            struct S1 ***l_287 = (void*)0;
            uint32_t l_325 = 0xDD6611CE;
            struct S1 *l_330 = &l_236;
            if ((l_280 , 0xFC0C68FD))
            { /* block id: 156 */
                (**l_217) = (*p_63);
            }
            else
            { /* block id: 158 */
                const int16_t l_282 = (-3);
                (*l_239) = (safe_unary_minus_func_int32_t_s(((**p_63) , l_282)));
                (*l_218) = (*p_63);
            }
            if ((safe_sub_func_uint16_t_u_u((l_285 != l_287), __builtin_ctzl(__builtin_parityll((p_62 ^ (*l_239)))))))
            { /* block id: 162 */
                int32_t ****l_292 = &l_217;
                int32_t *****l_291 = &l_292;
                struct S0 *l_303 = &l_195;
                struct S0 **l_304 = &l_194;
                struct S1 *l_305 = &l_215;
                for (l_236.f3 = (-26); (l_236.f3 != (-7)); ++l_236.f3)
                { /* block id: 165 */
                    int8_t l_290 = 0x1A;
                    if ((__builtin_clzl(((((l_290 != (l_290 >= (((l_291 != l_293) , (safe_mod_func_int32_t_s_s((*****l_291), (safe_lshift_func_uint16_t_u_s((safe_div_func_int16_t_s_s((-1), ((l_280 != __builtin_clzll(((*****l_291) | (*****l_291)))) || (*l_241)))), 8))))) || 0x5F561E7C))) | (**l_218)) , (*l_194)) , l_280)) || 0))
                    { /* block id: 166 */
                        (****l_293) = (*p_63);
                    }
                    else
                    { /* block id: 168 */
                        if ((****l_294))
                            break;
                    }
                }
                (*l_304) = l_303;
                (*l_305) = l_236;
            }
            else
            { /* block id: 174 */
                const int32_t l_312 = (-5);
                for (l_195.f6 = 18; (l_195.f6 >= 8); l_195.f6--)
                { /* block id: 177 */
                    return (*l_193);
                }
                (*l_239) = (safe_rshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u((l_312 != (safe_mod_func_int16_t_s_s(0x7BF4, l_312))), __builtin_ffsl((__builtin_popcountl((*l_193)) && 4294967288U)))), l_280));
            }
            (*l_330) = ((safe_rshift_func_uint16_t_u_u((((safe_rshift_func_int16_t_s_u((l_239 == l_193), 8)) , (***l_293)) == (((safe_rshift_func_uint16_t_u_u(p_64, 4)) || (safe_mul_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(p_64, 13)) < ((((l_325 == ((-5) ^ p_64)) < ((((safe_sub_func_int16_t_s_s(__builtin_clzl(((__builtin_clz((safe_rshift_func_uint16_t_u_u(p_62, 15))) , l_236) , 4294967289U)), p_64)) & p_62) , p_64) | (-1))) , (**l_218)) , 0x1E5C)), (-4)))) , p_61)), 11)) , l_236);
            (**l_295) = ((((****l_294) <= (safe_sub_func_int16_t_s_s(((*l_193) & (safe_add_func_uint32_t_u_u(p_64, (safe_mul_func_uint16_t_u_u((l_280 || (!0x0FCD6BA3)), (**l_218)))))), 1U))) , l_236) , (****l_293));
        }
        l_293 = &l_294;
    }
    else
    { /* block id: 186 */
        uint32_t l_342 = 0U;
        int32_t *l_368 = &l_236.f0;
        struct S0 l_379 = {-1,0x6CE9,0x952AF1B3,65529U,65535U,-1,4294967290U,65528U,0x9968E064};
        int8_t l_396 = 0x94;
        struct S1 l_403 = {0,0,0x817C311D,0xF8,0x7.FFACD8p-52,-2,2};
        float *l_413 = (void*)0;
        float *l_414 = &l_236.f4;
        for (l_195.f4 = 0; (l_195.f4 != 54); l_195.f4 = safe_add_func_uint16_t_u_u(l_195.f4, 1))
        { /* block id: 189 */
            float l_348 = 0x6.84C0FBp-43;
            int32_t l_354 = 0x0C25E5F2;
            for (l_236.f0 = 0; (l_236.f0 != (-21)); l_236.f0 = safe_sub_func_int16_t_s_s(l_236.f0, 7))
            { /* block id: 192 */
                float l_347 = (-0x4.6p-1);
                int32_t l_353 = (-1);
                int32_t *l_387 = &l_195.f2;
                if (((**p_63) ^ (l_342 , ((((safe_mod_func_int16_t_s_s(((safe_div_func_int16_t_s_s(0, l_342)) , (safe_add_func_uint16_t_u_u(0x0607, p_62))), (safe_add_func_int32_t_s_s(l_353, (l_354 < (((**p_63) >= (**p_63)) && l_354)))))) | 0xAF7D) | 0x6023) , 0x7E60BC75))))
                { /* block id: 193 */
                    int8_t l_364 = 0;
                    struct S1 l_365 = {0x3291E4BA,0xC3AF,0x49218AC6,0,-0x9.3p-1,0xF6318101,0xB4};
                    l_354 = 0xCF097603;
                    l_354 = (safe_sub_func_uint16_t_u_u((~((safe_mod_func_uint32_t_u_u((p_62 , (0xCC767CEC != (l_353 && (l_342 , (safe_div_func_int32_t_s_s(((-7) == (safe_mul_func_int16_t_s_s((l_342 == l_364), ((p_62 , l_365) , 0x7FC3)))), 4294967295U)))))), l_354)) != 0)), l_342));
                    return l_354;
                }
                else
                { /* block id: 197 */
                    int32_t *l_374 = &l_195.f2;
                    struct S0 **l_381 = &l_194;
                    int32_t ****l_384 = &l_217;
                    for (l_195.f5 = 7; (l_195.f5 <= (-3)); l_195.f5--)
                    { /* block id: 200 */
                        struct S1 l_370 = {1,0x72D3,1U,5,0x8.85FABEp-99,0x637EBF14,-1};
                        struct S1 *l_369 = &l_370;
                        l_368 = l_368;
                        l_369 = &l_236;
                    }
                    (*l_374) = (safe_add_func_uint32_t_u_u((safe_unary_minus_func_uint32_t_u(p_62)), p_62));
                    l_354 = (((*l_368) | (((safe_sub_func_float_f_f((((safe_add_func_uint16_t_u_u(0U, p_62)) , p_62) > (l_379 , (-0x1.Bp-1))), ((((l_354 != ((~p_64) & ((void*)0 != l_381))) | l_353) <= 1) , 0x5.0E0FF5p+15))) , (*l_374)) && l_354)) >= 0x1F52);
                    if ((l_354 ^ (safe_mod_func_uint32_t_u_u(l_354, p_64))))
                    { /* block id: 206 */
                        (*l_218) = (void*)0;
                    }
                    else
                    { /* block id: 208 */
                        int32_t *****l_385 = (void*)0;
                        int32_t *****l_386 = &l_384;
                        if ((*l_368))
                            break;
                        (*l_386) = l_384;
                        (*l_218) = ((p_62 != p_62) , &l_353);
                    }
                }
                (**l_217) = l_387;
            }
            for (l_379.f2 = 0; (l_379.f2 != (-1)); --l_379.f2)
            { /* block id: 218 */
                struct S1 *l_391 = &l_236;
                struct S1 **l_390 = &l_391;
                int32_t l_404 = 5;
                (*l_390) = &l_236;
                for (p_62 = 0; (p_62 < (-26)); p_62--)
                { /* block id: 222 */
                    if ((*l_368))
                        break;
                    if (__builtin_popcount(p_62))
                    { /* block id: 224 */
                        (*l_368) = (**p_63);
                    }
                    else
                    { /* block id: 226 */
                        int32_t ****l_397 = &l_217;
                        struct S1 **l_400 = &l_391;
                        const struct S1 *l_402 = &l_236;
                        const struct S1 **l_401 = &l_402;
                        l_403 = func_80((safe_rshift_func_uint16_t_u_s(l_396, (((p_64 , p_62) , ((l_397 != &l_217) < (*l_368))) | ((((safe_sub_func_uint32_t_u_u(1U, ((p_62 != (((l_400 == l_401) || (**p_63)) , p_62)) < 0U))) , (*l_368)) || 0xDDDB) || l_354)))), p_63);
                    }
                    l_404 = (p_64 <= 0x2.9p-1);
                }
                (*l_368) = (*l_368);
            }
        }
        (*l_414) = (((l_403 , ((safe_add_func_float_f_f(0xF.F7561Dp-79, (((safe_add_func_float_f_f(__builtin_parity(p_64), (p_62 != (__builtin_bswap64((*l_368)) < (safe_add_func_float_f_f(((safe_mul_func_float_f_f(0x1.8p+1, (*l_368))) != p_62), p_64)))))) <= 0x0.3p+1) < p_62))) <= p_62)) >= (*l_368)) > p_64);
        (*l_218) = (void*)0;
    }
    return l_415;
}


/* ------------------------------------------ */
/* 
 * reads : l_33 l_40 l_761.f0 l_784.f0 l_1150.f0 l_1378 l_1329
 * writes:
 */
static int32_t ** func_65(struct S0  p_66, int32_t * p_67, int8_t  p_68)
{ /* block id: 58 */
    uint32_t l_112 = 0x9B986BC5;
    const struct S1 l_123 = {0xF2D4CE27,0x7FF9,0x38BD6013,0xAD,0x0.7p+1,0,-1};
    int8_t l_124 = 1;
    int8_t l_131 = 3;
    uint32_t l_136 = 0xCEBB1B1B;
    int32_t *l_141 = (void*)0;
    int32_t **l_164 = &l_141;
    int32_t **l_167 = (void*)0;
    int32_t l_178 = 0x46011D50;
    int32_t **l_184 = &l_141;
    int32_t **l_185 = &l_141;
    int32_t **l_186 = &l_141;
    int32_t **l_187 = &l_141;
    int32_t **l_188 = &l_141;
    int32_t **l_189 = (void*)0;
    if ((safe_div_func_int16_t_s_s(p_66.f6, l_112)))
    { /* block id: 59 */
        int32_t l_130 = 0x28DA2785;
        int32_t *l_129 = &l_130;
        struct S1 l_133 = {0xC4DD9E31,0x7495,0x0B438E4B,-8,0x5.4p+1,0,1};
        struct S1 *l_132 = &l_133;
        (*l_129) = (((safe_mod_func_int32_t_s_s(((safe_sub_func_uint16_t_u_u((((p_66.f0 ^ ((((((safe_sub_func_int32_t_s_s((*p_67), (((safe_mod_func_int32_t_s_s((((safe_sub_func_uint32_t_u_u((l_123 , l_123.f1), l_124)) | (*p_67)) > p_68), ((((safe_add_func_float_f_f((safe_div_func_float_f_f(p_66.f5, p_68)), p_66.f1)) , p_67) == l_129) | (*p_67)))) & 0x3D230C2C) > l_123.f2))) == p_66.f1) <= (*p_67)) , p_66) , p_66.f1) ^ l_131)) , l_124) && l_123.f5), p_68)) < (*l_129)), (-7))) || 7U) | (*l_129));
        (*l_132) = l_123;
        if ((safe_add_func_int32_t_s_s(l_136, (0x3E82 <= ((safe_mul_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(((l_124 == ((void*)0 != &l_133)) && p_68), (&l_133 != (void*)0))), 0xA39D)) || (*p_67))))))
        { /* block id: 62 */
            int32_t **l_142 = &l_129;
            (*l_142) = l_141;
        }
        else
        { /* block id: 64 */
            int32_t **l_143 = (void*)0;
            int32_t **l_144 = (void*)0;
            int32_t **l_145 = &l_141;
            (*l_145) = &l_130;
            return l_143;
        }
    }
    else
    { /* block id: 68 */
        int32_t **l_149 = &l_141;
        int32_t l_156 = 0x7970BCD7;
        int32_t **l_165 = &l_141;
        int32_t **l_166 = &l_141;
        struct S1 *l_169 = (void*)0;
        if ((((~(safe_add_func_uint16_t_u_u(((((&l_141 != l_149) | l_123.f1) != ((safe_mul_func_uint16_t_u_u(p_66.f1, (safe_div_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(p_66.f2, 12)), 65535U)))) ^ (l_156 && (safe_sub_func_int32_t_s_s(0, (p_66.f6 <= p_66.f1)))))) , p_66.f8), 0x385D))) != 0x11DC0D21) & p_68))
        { /* block id: 69 */
            struct S0 l_161 = {0,0x5DE8,2,0xB3EE,1U,0x16DB,0xC975BB60,0U,4294967287U};
            struct S0 *l_160 = &l_161;
            struct S0 **l_159 = &l_160;
            int32_t **l_162 = &l_141;
            int32_t **l_163 = &l_141;
            (*l_159) = &p_66;
            return l_167;
        }
        else
        { /* block id: 72 */
            float l_168 = 0x6.8p-1;
            const struct S1 *l_171 = &l_123;
            const struct S1 **l_170 = &l_171;
            l_168 = p_66.f5;
            (*l_170) = l_169;
            for (l_156 = (-12); (l_156 != 8); l_156 = safe_add_func_uint16_t_u_u(l_156, 2))
            { /* block id: 77 */
                struct S1 l_176 = {-4,0xE3EA,0xB03959C9,0x88,0x1.4p+1,-1,-10};
                for (p_66.f3 = 0; (p_66.f3 <= 58); ++p_66.f3)
                { /* block id: 80 */
                    struct S1 *l_177 = &l_176;
                    (*l_177) = l_176;
                }
            }
        }
        l_178 = __builtin_ffsl(p_66.f3);
        for (l_112 = 26; (l_112 < 52); l_112 = safe_add_func_int32_t_s_s(l_112, 1))
        { /* block id: 88 */
            int32_t *l_181 = &l_156;
            struct S1 l_182 = {5,1,4294967295U,5,0x4.D04F64p-19,0xF4E2AC27,-7};
            struct S1 *l_183 = &l_182;
            (*l_149) = p_67;
            l_181 = (*l_149);
            (*l_183) = l_182;
        }
    }
    return l_189;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_69(uint16_t  p_70)
{ /* block id: 44 */
    const uint32_t l_87 = 1U;
    int32_t l_96 = 7;
    int32_t *l_95 = &l_96;
    int32_t **l_94 = &l_95;
    int32_t **l_97 = &l_95;
    int16_t l_105 = 7;
    const struct S1 l_106 = {0,0xAFDD,0x4211FA8B,0x40,0xE.590C99p-8,1,0x6F};
    struct S1 l_108 = {-1,0x8D4E,0xAF0E761D,0xF4,0xC.3FDF2Dp+15,1,1};
    struct S1 *l_107 = &l_108;
    struct S0 l_109 = {0x64988723,1,0x856BCC6B,0U,65532U,0xE3C4,4294967295U,5U,0x70E0EEEF};
    (**l_94) = (safe_rshift_func_int16_t_s_s((~(safe_mod_func_int32_t_s_s(((((safe_add_func_uint16_t_u_u((func_80((safe_add_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((l_87 , func_88(l_87, l_94, p_70, l_97, p_70)) == (((*l_95) , (**l_94)) , (void*)0)), 1)), (-1))), &l_95) , 65535U), (**l_97))) & p_70) ^ p_70) != p_70), (**l_97)))), (**l_94)));
    (*l_95) = l_105;
    (*l_107) = l_106;
    return l_109;
}


/* ------------------------------------------ */
/* 
 * reads : l_39 l_40 l_471.f0 l_470 l_578 l_490.f0 l_764 l_761.f0 l_759 l_33 l_997 l_784.f0 l_1033 l_1081 l_1169 l_1145.f2 l_1194 l_993.f0 l_1261
 * writes:
 */
inline static const struct S1  func_80(uint32_t  p_81, int32_t ** p_82)
{ /* block id: 47 */
    float l_103 = 0xF.65B212p-35;
    const struct S1 l_104 = {0x5F4E4D73,0xB847,0x7EE7A741,1,0x4.40F48Bp-43,0x2B152D5F,0xAB};
    for (p_81 = 0; (p_81 <= 59); ++p_81)
    { /* block id: 50 */
        if ((**p_82))
            break;
    }
    return l_104;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_88(uint32_t  p_89, int32_t ** p_90, int32_t  p_91, int32_t ** p_92, uint16_t  p_93)
{ /* block id: 45 */
    int32_t l_100 = (-1);
    int32_t *l_99 = &l_100;
    int32_t **l_98 = &l_99;
    return p_90;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 472
   depth: 1, occurrence: 50
XXX total union variables: 0

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 371
   depth: 2, occurrence: 58
   depth: 3, occurrence: 10
   depth: 4, occurrence: 9
   depth: 5, occurrence: 4
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 10, occurrence: 5
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 5
   depth: 15, occurrence: 5
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 5
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 4
   depth: 23, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 4
   depth: 28, occurrence: 1

XXX total number of pointers: 331

XXX times a variable address is taken: 341
XXX times a pointer is dereferenced on RHS: 501
breakdown:
   depth: 1, occurrence: 285
   depth: 2, occurrence: 153
   depth: 3, occurrence: 40
   depth: 4, occurrence: 15
   depth: 5, occurrence: 8
XXX times a pointer is dereferenced on LHS: 195
breakdown:
   depth: 1, occurrence: 138
   depth: 2, occurrence: 39
   depth: 3, occurrence: 15
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 38
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 2264

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 2478
   level: 2, occurrence: 1559
   level: 3, occurrence: 265
   level: 4, occurrence: 306
   level: 5, occurrence: 214
XXX number of pointers point to pointers: 209
XXX number of pointers point to scalars: 77
XXX number of pointers point to structs: 45
XXX percent of pointers has null in alias set: 20.8
XXX average alias set size: 1.45

XXX times a non-volatile is read: 2368
XXX times a non-volatile is write: 557
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 313
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 36
   depth: 2, occurrence: 43
   depth: 3, occurrence: 59
   depth: 4, occurrence: 69
   depth: 5, occurrence: 75

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
********************* end of statistics **********************/

