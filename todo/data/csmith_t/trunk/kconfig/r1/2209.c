/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      152791046
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 17;
   signed f1 : 2;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = 0x55B7CEFA;
static struct S0 g_88 = {-165,-1};
static struct S0 g_381 = {41,0};


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_28(void);
static int32_t  func_39(uint32_t  p_40, uint16_t  p_41, uint32_t  p_42, int16_t  p_43);
static uint32_t  func_46(int32_t  p_47, uint16_t  p_48, struct S0  p_49);
static uint32_t  func_56(struct S0  p_57, int32_t  p_58);
static struct S0  func_59(int32_t  p_60, int32_t  p_61, uint32_t  p_62);
static uint16_t  func_65(uint32_t  p_66, int32_t  p_67, uint32_t  p_68);
static struct S0  func_74(int16_t  p_75, uint32_t  p_76);
static int16_t  func_83(uint32_t  p_84, uint32_t  p_85);
static uint16_t  func_86(int16_t  p_87);
static int32_t  func_90(int16_t  p_91, uint32_t  p_92, int32_t  p_93, uint16_t  p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_88 g_381
 * writes: g_88.f1 g_88.f0 g_88 g_381
 */
static int32_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_29 = 0x04272BA7;
    int32_t l_38 = 0xBBB66EFE;
    uint16_t l_69 = 1U;
    struct S0 l_393 = {321,1};
    l_29 = (-1);
    l_38 = __builtin_parity(((int16_t)((int32_t)((l_29 == (((int16_t)(l_29 || ((int32_t)(((l_38 > func_39(((uint16_t)(func_46((((uint16_t)((g_8 <= ((uint32_t)((int16_t)(-1) << (int16_t)(func_56(func_59(l_38, g_8, ((uint16_t)func_65(l_29, (l_69 < 0x4E69A457), g_8) << (uint16_t)g_8)), l_38) ^ l_29)) - (uint32_t)g_8)) | l_29) >> (uint16_t)13) <= l_29), l_38, g_381) <= l_38) >> (uint16_t)g_381.f0), g_8, l_29, g_381.f1)) && g_381.f0) | g_8) - (int32_t)0xE96F79EB)) % (int16_t)g_8) != 0x0CB86044)) != g_8) + (int32_t)(-1)) % (int16_t)l_29));
    l_38 = g_381.f1;
    l_393 = l_393;
    return l_393.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_381 g_88.f1 g_88
 * writes: g_381 g_88.f1 g_88
 */
static int32_t  func_39(uint32_t  p_40, uint16_t  p_41, uint32_t  p_42, int16_t  p_43)
{ /* block id: 185 */
    struct S0 l_382 = {-11,0};
    l_382 = g_381;
    g_381 = g_381;
    l_382.f1 = ((int16_t)((uint16_t)p_41 % (uint16_t)l_382.f0) - (int16_t)((-3) <= ((int16_t)((int32_t)((int16_t)func_86(g_88.f1) >> (int16_t)9) + (int32_t)p_42) << (int16_t)9)));
    g_88 = l_382;
    return g_88.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_88.f1
 */
static uint32_t  func_46(int32_t  p_47, uint16_t  p_48, struct S0  p_49)
{ /* block id: 182 */
    g_88.f1 = __builtin_ctzl(p_47);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_56(struct S0  p_57, int32_t  p_58)
{ /* block id: 180 */
    uint16_t l_380 = 0xB62F;
    return l_380;
}


/* ------------------------------------------ */
/* 
 * reads : g_88.f0 g_88.f1
 * writes:
 */
static struct S0  func_59(int32_t  p_60, int32_t  p_61, uint32_t  p_62)
{ /* block id: 176 */
    int32_t l_373 = 3;
    uint32_t l_378 = 4294967286U;
    struct S0 l_379 = {-67,1};
    p_60 = (g_88.f0 == (g_88.f1 && l_373));
    l_378 = (((int16_t)((uint16_t)p_61 >> (uint16_t)7) >> (int16_t)9) != (l_373 || (p_60 == g_88.f1)));
    return l_379;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_88
 * writes: g_88.f1 g_88.f0 g_88
 */
static uint16_t  func_65(uint32_t  p_66, int32_t  p_67, uint32_t  p_68)
{ /* block id: 38 */
    struct S0 l_73 = {219,0};
    uint16_t l_318 = 65535U;
    struct S0 l_358 = {223,-1};
    p_67 = g_8;
    for (p_68 = 0; (p_68 <= 57); p_68 += 2)
    { /* block id: 42 */
        struct S0 l_72 = {271,1};
        int32_t l_372 = 6;
        l_73 = l_72;
        p_67 = 1;
        if (l_72.f0)
        { /* block id: 45 */
            int32_t l_316 = 0;
            l_72 = func_74(l_73.f1, (0xCFB99634 >= l_72.f1));
            for (p_66 = (-4); (p_66 < 57); p_66 += 1)
            { /* block id: 151 */
                p_67 = ((uint32_t)__builtin_bswap64((1 | ((int16_t)(4294967295U || ((uint16_t)(((int16_t)func_83((((int32_t)0x1D4E9A3B % (int32_t)__builtin_parity((__builtin_ctzll(((int32_t)g_8 - (int32_t)(((int16_t)((uint16_t)0x64AD >> (uint16_t)((int32_t)g_88.f1 - (int32_t)p_68)) % (int16_t)(-(int32_t)((uint16_t)g_8 >> (uint16_t)11))) >= 1))) >= g_88.f0))) && l_72.f1), g_8) >> (int16_t)l_316) != 1) % (uint16_t)p_67)) + (int16_t)l_73.f0))) + (uint32_t)p_66);
                g_88.f0 = l_73.f0;
            }
        }
        else
        { /* block id: 155 */
            int32_t l_326 = 0x4FF36451;
            uint16_t l_348 = 0xB0A0;
            int32_t l_357 = (-1);
            if ((!(((((((1 != g_88.f0) ^ g_88.f1) == l_318) ^ l_318) > func_83((g_88.f1 > ((uint16_t)__builtin_ctzl(g_8) + (uint16_t)(((int32_t)(((int32_t)(p_66 <= p_67) % (int32_t)g_88.f1) > 0x7E99EAB1) + (int32_t)g_88.f0) != 4294967291U))), p_68)) != 0x10A8) >= 0x4281389A)))
            { /* block id: 156 */
                uint32_t l_325 = 0x6048124E;
                if (l_325)
                    break;
            }
            else
            { /* block id: 158 */
                struct S0 l_327 = {123,1};
                l_326 = l_318;
                l_327 = func_74(g_88.f0, l_326);
                if ((((~(0x1FC3 <= ((((((g_8 >= (l_72.f1 < g_8)) > (g_88.f1 & 0x74DD7B4E)) | ((int32_t)g_88.f0 - (int32_t)__builtin_popcountll(((0x804D ^ g_88.f0) || 0x3DE6F462)))) > 0x9E41796E) >= l_326) <= p_66))) != 4294967295U) > 0xA66A))
                { /* block id: 161 */
                    uint16_t l_349 = 0x7A1D;
                    p_67 = ((!(-(int32_t)l_73.f0)) < (((((((uint16_t)l_327.f1 - (uint16_t)l_72.f0) != ((uint16_t)(((uint16_t)l_73.f1 - (uint16_t)(((int16_t)((int16_t)0 << (int16_t)((int32_t)((-(int32_t)((int32_t)(p_68 == ((l_326 != 0U) ^ (-1))) - (int32_t)0x8CEAEB1F)) ^ p_67) % (int32_t)l_327.f1)) >> (int16_t)l_72.f1) >= l_348)) != 0xC7D8247C) >> (uint16_t)g_88.f1)) && p_67) ^ p_68) >= p_68) != l_349));
                    p_67 = g_88.f0;
                }
                else
                { /* block id: 164 */
                    p_67 = (__builtin_ffsll(((g_88.f0 && (~(__builtin_ctz(l_72.f0) >= 0xCBA844F2))) < 0U)) < (0x3BB3 <= ((int16_t)func_86((p_68 || (((uint16_t)((uint16_t)g_88.f0 + (uint16_t)l_73.f1) % (uint16_t)(-1)) != (-4)))) >> (int16_t)0)));
                }
                l_358 = func_74(g_88.f1, (4294967295U <= ((l_357 > 0x6FF6255C) > (g_88.f0 >= l_73.f0))));
            }
            p_67 = g_8;
            if (p_67)
                break;
            l_326 = g_88.f0;
        }
        l_372 = (l_72.f0 == (((uint32_t)((-1) >= (func_90((0x7DC2 > ((~(func_86(l_72.f1) <= ((uint16_t)g_8 << (uint16_t)9))) || (((int16_t)((int16_t)((uint16_t)0xBCFA - (uint16_t)(l_372 > (p_68 ^ g_88.f0))) << (int16_t)g_8) - (int16_t)l_72.f0) || 65535U))), p_67, l_358.f1, l_358.f0) < (-2))) + (uint32_t)0xC8CA38CB) >= g_88.f0));
    }
    return p_67;
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_88
 * writes: g_88.f1 g_88.f0 g_88
 */
static struct S0  func_74(int16_t  p_75, uint32_t  p_76)
{ /* block id: 46 */
    int16_t l_77 = 0x86B2;
    struct S0 l_141 = {-203,-1};
    uint32_t l_202 = 0x58EEB3F8;
    int32_t l_291 = 6;
    if (((g_8 > 1U) > l_77))
    { /* block id: 47 */
        uint16_t l_78 = 0xB2A4;
        int32_t l_79 = 0x16D714E2;
        uint16_t l_107 = 0xEF2A;
        l_79 = l_78;
        g_88.f0 = (l_77 || (~((int16_t)p_75 >> (int16_t)func_83(((func_86(g_8) | ((uint16_t)((int32_t)(0x2FD4 & ((((((9 | l_107) >= ((uint32_t)g_88.f0 + (uint32_t)(~(l_107 >= 0x60710019)))) ^ g_8) == g_8) | p_76) >= p_76)) + (int32_t)g_8) - (uint16_t)g_8)) != l_77), p_75))));
    }
    else
    { /* block id: 67 */
        uint32_t l_115 = 0x91FCF288;
        int32_t l_130 = 0xCB3A5686;
        uint16_t l_158 = 0U;
        int32_t l_225 = 7;
        struct S0 l_273 = {-331,1};
        int32_t l_292 = (-3);
        if (((int32_t)((-(int32_t)0x5B034E2D) != (((g_88.f0 != (__builtin_clzll(p_76) > (l_115 ^ (func_83(l_77, (65531U && p_75)) | p_75)))) <= 0xC76A8768) == l_77)) - (int32_t)g_8))
        { /* block id: 68 */
            int32_t l_120 = 0x68EE181C;
            struct S0 l_132 = {326,0};
            for (l_115 = 4; (l_115 < 19); l_115 += 1)
            { /* block id: 71 */
                uint32_t l_129 = 0x75ADB6E2;
                int32_t l_131 = 0xEC4AE7C4;
                l_130 = ((((int16_t)g_88.f1 << (int16_t)(__builtin_ctzll(func_83(l_120, ((int16_t)(((g_8 == (~((int16_t)((p_76 != func_83(l_77, (((!((uint16_t)(g_8 <= (0xF0579679 || l_115)) << (uint16_t)l_129)) ^ g_88.f0) > l_120))) < l_129) >> (int16_t)14))) || 4294967287U) || l_129) % (int16_t)0x313C))) == l_120)) & g_88.f1) != 1U);
                l_131 = l_120;
                g_88 = l_132;
                if (g_88.f0)
                    continue;
            }
            return g_88;
        }
        else
        { /* block id: 78 */
            l_130 = 1;
        }
        if ((~(6 || func_86((((int16_t)(((uint32_t)((0x0369 || (g_88.f0 || ((l_115 ^ l_77) <= (g_88.f0 & l_77)))) && 0xD28546E3) - (uint32_t)(((((uint32_t)(g_8 == l_130) + (uint32_t)l_115) | 0x70CE46C4) > g_88.f0) != p_76)) ^ l_130) >> (int16_t)g_8) < l_130)))))
        { /* block id: 81 */
            struct S0 l_140 = {-274,-0};
            int32_t l_142 = 0x03CF1BE4;
            l_141 = l_140;
            g_88.f1 = (0U ^ ((l_141.f0 > p_76) == 5));
            l_142 = l_130;
        }
        else
        { /* block id: 85 */
            struct S0 l_145 = {84,0};
            int16_t l_153 = 0;
            struct S0 l_181 = {-288,-0};
            uint32_t l_271 = 2U;
            l_141.f0 = g_8;
            for (p_76 = 0; (p_76 <= 20); p_76 += 8)
            { /* block id: 89 */
                struct S0 l_146 = {275,-0};
                l_146 = l_145;
                g_88.f0 = (4294967289U ^ (l_145.f0 == p_75));
                for (l_115 = 0; (l_115 == 57); l_115 += 1)
                { /* block id: 94 */
                    g_88.f0 = (((uint16_t)((((uint32_t)l_77 + (uint32_t)((l_145.f0 == l_153) != ((uint16_t)(((-1) > ((((uint16_t)l_158 >> (uint16_t)(((int16_t)p_75 << (int16_t)8) && 0x95BA468D)) == ((uint16_t)6U >> (uint16_t)((8 & l_145.f1) > p_76))) ^ l_146.f1)) >= p_76) << (uint16_t)9))) == l_77) && l_146.f1) - (uint16_t)65531U) ^ g_8);
                    g_88.f1 = __builtin_bswap64((((uint16_t)((((int16_t)((uint16_t)(0xD69AD938 > ((uint16_t)p_75 % (uint16_t)g_88.f0)) << (uint16_t)(((uint16_t)(g_88.f1 > ((uint16_t)g_88.f0 << (uint16_t)l_146.f1)) >> (uint16_t)p_75) >= ((uint32_t)(((((uint16_t)((uint16_t)0x15AF - (uint16_t)((0U & 4294967295U) > 0x5CB7)) + (uint16_t)g_8) > p_76) == 1U) & l_115) + (uint32_t)0xDCB43784))) >> (int16_t)g_88.f0) >= p_75) > 4294967295U) % (uint16_t)p_75) & (-1)));
                    l_181 = l_145;
                }
                g_88.f0 = 0xAC48BB85;
            }
            if ((l_153 > ((int16_t)(!((~1U) ^ ((uint32_t)(g_8 && 65535U) + (uint32_t)l_158))) + (int16_t)((((uint32_t)g_88.f0 - (uint32_t)func_90(g_88.f0, ((int32_t)0xF74BF3BD + (int32_t)((((int16_t)((((int16_t)g_88.f1 >> (int16_t)15) < p_76) != 0x6271) % (int16_t)g_8) > l_145.f0) != l_77)), l_158, g_88.f1)) & 65531U) || l_130))))
            { /* block id: 101 */
                uint32_t l_209 = 4294967295U;
                int32_t l_220 = 1;
                uint32_t l_231 = 0U;
                uint32_t l_238 = 0x0742F6B5;
                struct S0 l_272 = {-112,-0};
                l_130 = ((int16_t)(l_145.f0 == 2U) + (int16_t)((uint16_t)(((int16_t)g_8 - (int16_t)__builtin_parity(l_202)) < 1) >> (uint16_t)4));
                l_141.f0 = l_141.f0;
                if (g_88.f1)
                { /* block id: 104 */
                    uint16_t l_208 = 1U;
                    for (l_130 = 0; (l_130 > 20); l_130 += 1)
                    { /* block id: 107 */
                        l_209 = func_90(g_8, ((!((((-7) || ((uint16_t)((g_8 & g_88.f1) || func_86(l_141.f0)) << (uint16_t)9)) <= ((0 ^ p_76) ^ __builtin_popcountl(p_75))) == p_76)) | l_208), g_88.f0, p_76);
                        g_88.f0 = (!l_130);
                    }
                    l_145 = l_141;
                }
                else
                { /* block id: 112 */
                    int32_t l_219 = 0x5190DBC9;
                    if ((((int16_t)g_88.f1 - (int16_t)((uint16_t)g_88.f0 - (uint16_t)((0xEA30 ^ g_8) && ((((4294967293U <= ((uint16_t)((65535U && (((int32_t)0x8A0C2E42 - (int32_t)l_219) <= 0xAAEB)) >= l_209) << (uint16_t)11)) <= 0xE320F675) >= g_88.f1) | g_88.f1)))) || g_8))
                    { /* block id: 113 */
                        l_220 = g_88.f1;
                    }
                    else
                    { /* block id: 115 */
                        l_231 = ((uint16_t)l_181.f1 << (uint16_t)((p_76 >= (l_209 > ((-5) & (0xC518A76D == (l_225 ^ (-(int32_t)((int16_t)l_141.f1 << (int16_t)8))))))) < ((uint16_t)g_8 >> (uint16_t)12)));
                        l_141.f1 = (l_225 > p_76);
                    }
                    if ((((p_75 & __builtin_popcountll(p_75)) == (g_88.f1 >= ((l_77 != (l_220 || ((((func_83(((uint16_t)1U << (uint16_t)p_76), (((uint16_t)(((uint16_t)l_130 >> (uint16_t)g_8) >= l_238) << (uint16_t)7) <= l_219)) < 7U) != 0xB078) < g_8) || l_181.f1))) && p_75))) <= l_220))
                    { /* block id: 119 */
                        g_88.f0 = l_219;
                        g_88.f0 = func_83(p_76, l_181.f1);
                    }
                    else
                    { /* block id: 122 */
                        int32_t l_252 = 0x45068F4A;
                        g_88.f0 = __builtin_parity(((int32_t)(func_86(((uint32_t)__builtin_parityll(((int16_t)p_76 >> (int16_t)(((((((uint16_t)(1U && (-(int32_t)(0xF197 & ((uint32_t)l_219 + (uint32_t)p_75)))) >> (uint16_t)12) != ((func_86(p_75) == (g_8 && (((uint16_t)((p_76 > 0x54BA6421) > g_88.f0) << (uint16_t)14) > l_141.f0))) <= 0U)) != l_252) == l_252) || p_76) || 0x31C9))) - (uint32_t)0U)) & p_75) - (int32_t)l_219));
                    }
                    l_145.f0 = ((int16_t)g_8 >> (int16_t)15);
                    if ((-(int16_t)(func_83(g_88.f1, (0x9782C05E == g_88.f0)) > (~(__builtin_ffsll(((g_8 != 0x8610FE71) | ((((int16_t)p_75 << (int16_t)12) > p_75) > 65535U))) != l_238)))))
                    { /* block id: 126 */
                        uint16_t l_270 = 0xFC91;
                        l_271 = ((((uint32_t)(g_8 & func_90(g_88.f0, (((((g_88.f1 | (((int32_t)p_76 + (int32_t)((int16_t)((p_76 && ((uint16_t)p_76 >> (uint16_t)((int32_t)g_88.f1 - (int32_t)g_8))) ^ func_83((-(int32_t)(g_8 <= g_88.f1)), l_145.f0)) - (int16_t)0x0275)) ^ g_88.f1)) && g_88.f1) < 9) <= l_270) > 0x6FB30011), g_88.f0, g_8)) - (uint32_t)l_219) < 0U) && g_88.f1);
                    }
                    else
                    { /* block id: 128 */
                        struct S0 l_274 = {265,1};
                        l_272 = l_141;
                        l_273 = l_145;
                        g_88 = l_274;
                    }
                }
                l_145.f1 = l_181.f0;
            }
            else
            { /* block id: 135 */
                return g_88;
            }
            for (p_75 = 0; (p_75 < 22); p_75 += 1)
            { /* block id: 140 */
                g_88.f0 = (g_88.f1 | p_75);
            }
        }
        l_273.f1 = (((uint32_t)((0 >= ((((uint32_t)l_158 + (uint32_t)((l_77 & ((uint16_t)0x0D3D << (uint16_t)6)) != ((uint32_t)((p_75 & (((uint16_t)(((uint32_t)((g_88.f1 ^ ((uint16_t)p_75 >> (uint16_t)5)) | ((0xC8995CB6 > ((l_291 && l_141.f0) != p_76)) & l_292)) % (uint32_t)l_202) > 0U) + (uint16_t)(-10)) < g_88.f1)) == 3U) - (uint32_t)4294967295U))) || 0U) | 4294967293U)) || l_273.f0) % (uint32_t)0x020281DD) >= l_141.f0);
        l_141.f1 = (-1);
    }
    return l_141;
}


/* ------------------------------------------ */
/* 
 * reads : g_88
 * writes:
 */
static int16_t  func_83(uint32_t  p_84, uint32_t  p_85)
{ /* block id: 63 */
    struct S0 l_111 = {-222,-0};
    l_111 = g_88;
    return p_84;
}


/* ------------------------------------------ */
/* 
 * reads : g_88
 * writes: g_88.f1
 */
static uint16_t  func_86(int16_t  p_87)
{ /* block id: 49 */
    struct S0 l_89 = {243,0};
    l_89 = g_88;
    l_89.f0 = func_90(g_88.f0, l_89.f0, l_89.f0, g_88.f1);
    return l_89.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_88.f1 g_88.f0
 * writes: g_88.f1
 */
static int32_t  func_90(int16_t  p_91, uint32_t  p_92, int32_t  p_93, uint16_t  p_94)
{ /* block id: 51 */
    uint32_t l_102 = 0x4C0C5DC7;
    for (p_92 = 0; (p_92 != 43); p_92 += 1)
    { /* block id: 54 */
        int32_t l_99 = 6;
        l_99 = ((uint16_t)g_88.f1 >> (uint16_t)14);
        g_88.f1 = (-7);
        if (g_88.f0)
            continue;
    }
    l_102 = ((int16_t)(g_88.f0 < g_88.f0) << (int16_t)1);
    return g_88.f1;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_88.f0, "g_88.f0", print_hash_value);
    transparent_crc(g_88.f1, "g_88.f1", print_hash_value);
    transparent_crc(g_381.f0, "g_381.f0", print_hash_value);
    transparent_crc(g_381.f1, "g_381.f1", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 49
   depth: 1, occurrence: 20
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX full-bitfields structs in the program: 20
breakdown:
   indirect level: 0, occurrence: 20
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 18
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 23
XXX times a single bitfield on RHS: 123

XXX max expression depth: 39
breakdown:
   depth: 1, occurrence: 123
   depth: 2, occurrence: 13
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 39, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 381
XXX times a non-volatile is write: 76
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 103
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 13
   depth: 2, occurrence: 16
   depth: 3, occurrence: 21
   depth: 4, occurrence: 12
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 15.5
XXX percentage an existing variable is used: 84.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

