/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2110017361
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const int32_t  f0;
   const int64_t  f1;
   signed f2 : 14;
   uint8_t  f3;
   uint8_t  f4;
   uint8_t  f5;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint8_t  func_1(void);
static int32_t  func_2(const int8_t  p_3, uint16_t  p_4, int32_t  p_5);
inline static int32_t  func_7(int16_t  p_8, float  p_9, uint32_t  p_10, float  p_11);
static float  func_14(struct S0  p_15, uint64_t  p_16, uint64_t  p_17, float  p_18, int8_t  p_19);
static struct S0  func_20(float  p_21);
inline static int32_t * func_33(uint32_t  p_34, int32_t * p_35, int64_t  p_36, int16_t  p_37);
static int16_t  func_38(int32_t * p_39, int64_t  p_40, int32_t * p_41, int32_t * const  p_42, int32_t * p_43);
static int32_t * func_44(const int32_t * p_45, int32_t * p_46, uint32_t  p_47, int64_t  p_48);
static int32_t * func_51(uint64_t  p_52, int32_t  p_53, int32_t  p_54, uint8_t  p_55);
static int32_t  func_56(float  p_57, int32_t * p_58, int32_t * p_59, int32_t * p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_6 = 0xB8EE41B6L;
    int32_t l_27 = 1L;
    int32_t *l_949 = &l_6;
    int32_t **l_948 = &l_949;
    int32_t ***l_947 = &l_948;
    struct S0 *l_958 = (void*)0;
    struct S0 **l_957 = &l_958;
    const uint8_t l_1049 = 1UL;
    struct S0 ***l_1080 = (void*)0;
    struct S0 ****l_1079 = &l_1080;
    struct S0 *****l_1078 = &l_1079;
    float *l_1131 = (void*)0;
    float l_1133[4][7][5] = {{{0x1.5p-1,0x1.5p-1,0x4.332FD9p-57,0x4.332FD9p-57,0x1.5p-1},{0x8.DE44C5p-31,0xA.2AB10Fp-46,0x8.0294F8p+15,0x5.244E56p-74,0xC.753CBDp+22},{0x1.5p-1,0x1.5p-1,0x4.332FD9p-57,0x4.332FD9p-57,0x1.5p-1},{0x8.DE44C5p-31,0xA.2AB10Fp-46,0x8.0294F8p+15,0x5.244E56p-74,0xC.753CBDp+22},{0x1.5p-1,0x1.5p-1,0x4.332FD9p-57,0x4.332FD9p-57,0x1.5p-1},{0x8.DE44C5p-31,0xA.2AB10Fp-46,0x8.0294F8p+15,0x5.244E56p-74,0xC.753CBDp+22},{0x1.5p-1,0x1.5p-1,0x4.332FD9p-57,0x4.332FD9p-57,0x1.5p-1}},{{0x8.DE44C5p-31,0xA.2AB10Fp-46,0x8.0294F8p+15,0x5.244E56p-74,0xC.753CBDp+22},{0x1.5p-1,0x1.5p-1,0x4.332FD9p-57,0x4.332FD9p-57,0x1.5p-1},{0x8.DE44C5p-31,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52}},{{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1}},{{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52},{0x8.7F50EAp-2,0x8.2p+1,0x1.5p-1,0x1.5p-1,0x8.2p+1},{0x1.Cp-1,(-0x1.Ap-1),0xC.753CBDp+22,0xA.2AB10Fp-46,0x5.5CC1BAp-52}}};
    float *l_1132 = &l_1133[2][5][1];
    uint32_t l_1134 = 4294967292UL;
    int i, j, k;
    if (func_2((248UL == (l_6 || l_6)), l_6, func_7(l_6, l_6, l_6, (safe_div_func_float_f_f(func_14(func_20(((safe_sub_func_float_f_f((-((l_6 <= (safe_sub_func_float_f_f(0x0.2p-1, l_27))) >= (-0x7.2p-1))), 0x2.8p-1)) >= 0x1.80AE7Bp+68)), l_6, l_6, l_6, l_6), l_6)))))
    { /* block id: 445 */
        const int32_t ****l_950 = (void*)0;
        int32_t * const **l_952 = (void*)0;
        int32_t * const ***l_951 = &l_952;
        (*l_951) = l_947;
        /* statement id: 446 */
        assert (l_952 == &l_948);
    }
    else
    { /* block id: 447 */
        const int16_t l_962[7][5] = {{0x8D54L,0x8D54L,0x8D54L,0x8D54L,0x8D54L},{1L,(-1L),1L,(-1L),1L},{0x8D54L,0x8D54L,0x8D54L,0x8D54L,0x8D54L},{1L,(-1L),1L,(-1L),1L},{0x8D54L,0x8D54L,0x8D54L,0x8D54L,0x8D54L},{1L,(-1L),1L,(-1L),1L},{0x8D54L,0x8D54L,0x8D54L,0x8D54L,0x8D54L}};
        uint8_t l_965 = 1UL;
        int32_t l_1003 = 0x30BB0211L;
        uint32_t l_1035 = 0xC7072117L;
        float l_1062 = 0x6.7A794Ap-82;
        const int8_t l_1063[9][1] = {{0x15L},{0x19L},{0x15L},{0x19L},{0x15L},{0x19L},{0x15L},{0x19L},{0x15L}};
        uint64_t l_1064 = 0x91BF39AC9D22020ALL;
        struct S0 *****l_1081 = (void*)0;
        uint64_t l_1100 = 0xD1AF4C856F4A8AFCLL;
        int32_t *l_1103 = &l_6;
        uint32_t l_1112 = 0x85C3F69EL;
        int i, j;
        if ((safe_mod_func_uint64_t_u_u((((0x45L && (**l_948)) | ((l_957 != &l_958) || ((+0xEEF36DDFED4E016DLL) <= ((safe_mod_func_uint32_t_u_u((((l_962[1][1] ^ (*l_949)) >= (*l_949)) && (safe_mod_func_int32_t_s_s(l_962[1][1], 0xB0910B49L))), (-2L))) != (*l_949))))) < l_962[6][2]), l_962[0][3])))
        { /* block id: 448 */
lbl_993:
            (***l_947) = l_965;
        }
        else
        { /* block id: 450 */
            uint32_t l_966 = 0UL;
            float **l_974[4][1][5] = {{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}}};
            int64_t l_1033 = 2L;
            int32_t ***l_1061 = &l_948;
            int16_t l_1065 = (-1L);
            int8_t l_1101 = 1L;
            int i, j, k;
            if ((((**l_948) > 0x85L) && l_966))
            { /* block id: 451 */
                struct S0 ***l_968 = &l_957;
                struct S0 ****l_967 = &l_968;
                struct S0 *****l_969 = &l_967;
                int32_t l_992 = 1L;
                float ***l_1036 = &l_974[1][0][4];
                int32_t **l_1042 = &l_949;
                (*l_969) = l_967;
                for (l_6 = 0; (l_6 > 22); l_6++)
                { /* block id: 455 */
                    int8_t l_987 = 0xE2L;
                    int32_t *** const l_1002 = &l_948;
                    uint32_t l_1034 = 1UL;
                    float ****l_1037 = &l_1036;
                    if ((0xEFF4E3C6L & (safe_div_func_int8_t_s_s((((l_974[1][0][3] != (void*)0) & 0x992A17F7195A9E7ALL) >= l_965), (safe_add_func_int16_t_s_s((safe_add_func_int8_t_s_s(((((safe_lshift_func_uint16_t_u_u(l_966, 11)) < (((safe_sub_func_int8_t_s_s((((safe_add_func_uint16_t_u_u((safe_add_func_int8_t_s_s(l_987, (((((((((*l_949) && ((l_962[1][1] ^ l_966) < 0UL)) >= 0L) <= 0x3DL) >= l_992) & 0UL) <= 0xFEL) > 0UL) && 7UL))), l_987)) < l_966) | 8UL), l_966)) & l_987) < l_987)) >= l_992) && l_992), 0xBEL)), l_987))))))
                    { /* block id: 456 */
                        (*l_948) = (*l_948);
                    }
                    else
                    { /* block id: 458 */
                        int32_t *l_996 = &l_992;
                        l_992 = (-1L);
                        if (l_965)
                            goto lbl_993;
                        (*l_996) = (safe_div_func_uint8_t_u_u(0xB9L, l_962[4][2]));
                    }
                    for (l_965 = (-30); (l_965 != 15); ++l_965)
                    { /* block id: 465 */
                        const int32_t *l_1001 = &l_992;
                        const int32_t **l_1000 = &l_1001;
                        const int32_t ***l_999 = &l_1000;
                        l_1003 = (l_999 == l_1002);
                    }
                    l_1003 = (safe_mod_func_int64_t_s_s((!l_966), ((((((((safe_sub_func_uint32_t_u_u((safe_rshift_func_uint8_t_u_s(((safe_lshift_func_uint16_t_u_s((safe_add_func_int32_t_s_s((**l_948), ((safe_lshift_func_uint8_t_u_s(((1L == (((safe_div_func_int8_t_s_s((safe_div_func_uint64_t_u_u(l_992, (~l_992))), ((safe_rshift_func_int16_t_s_u((safe_rshift_func_int8_t_s_u(((safe_rshift_func_int8_t_s_u((*l_949), 1)) <= (safe_add_func_int32_t_s_s(l_962[0][3], (safe_rshift_func_uint16_t_u_s((~l_1033), 10))))), l_1034)), l_992)) && (***l_1002)))) && l_1035) | (**l_948))) && (**l_948)), 0)) && l_992))), (***l_947))) != l_966), 0)), l_992)) & (***l_1002)) > l_992) > (*l_949)) <= 0xCB38L) & 0xBF2C8835L) < (-1L)) || (*l_949))));
                    (*l_1037) = l_1036;
                }
                for (l_1003 = 0; (l_1003 >= 0); l_1003 -= 1)
                { /* block id: 473 */
                    int32_t l_1038 = 0L;
                    struct S0 **l_1039 = &l_958;
                    (**l_1042) = (l_1038 & (((l_1039 == (void*)0) <= (l_1038 && (((safe_mul_func_int32_t_s_s(((*l_949) | 0L), ((l_1042 == l_1042) <= l_1033))) ^ (**l_1042)) != (-3L)))) && l_966));
                    return l_1038;
                }
                return l_966;
            }
            else
            { /* block id: 478 */
                uint16_t l_1048 = 0x8CB9L;
                struct S0 * const *l_1075[6];
                struct S0 * const **l_1074 = &l_1075[3];
                struct S0 * const ***l_1073 = &l_1074;
                struct S0 * const ****l_1072 = &l_1073;
                int32_t *l_1083 = &l_1003;
                uint32_t l_1084 = 1UL;
                const int32_t *l_1111 = &l_1003;
                const int32_t **l_1110[4] = {&l_1111,&l_1111,&l_1111,&l_1111};
                const int32_t ***l_1109 = &l_1110[1];
                int i;
                for (i = 0; i < 6; i++)
                    l_1075[i] = &l_958;
                (*l_949) = ((((safe_rshift_func_int16_t_s_u((~(safe_div_func_uint8_t_u_u((l_1048 >= (l_1049 & l_962[1][1])), (safe_unary_minus_func_int8_t_s(((safe_div_func_uint8_t_u_u((safe_mod_func_int8_t_s_s(((safe_div_func_uint64_t_u_u((safe_sub_func_int16_t_s_s(l_1048, ((l_1048 > (246UL && (((safe_unary_minus_func_uint8_t_u((~((void*)0 == l_1061)))) >= ((l_1003 <= (-1L)) != 5UL)) != (***l_1061)))) == l_1063[4][0]))), (***l_947))) > l_1064), 0x38L)), (-1L))) || (***l_1061))))))), (**l_948))) & (***l_1061)) & 0x0852BF2BL) == l_1065);
                for (l_965 = 0; (l_965 >= 42); l_965++)
                { /* block id: 482 */
                    const uint64_t l_1082 = 1UL;
                    struct S0 *****l_1102[7] = {&l_1079,&l_1079,&l_1079,&l_1079,&l_1079,&l_1079,&l_1079};
                    int32_t *l_1104 = &l_6;
                    int i;
                    if ((((**l_948) <= (safe_add_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_s(0UL, 3)), (***l_1061)))) >= (*l_949)))
                    { /* block id: 483 */
                        (*l_948) = func_44(&l_1003, (**l_1061), l_1063[2][0], (((void*)0 == l_1072) | (0x9C6AB86BL <= (safe_rshift_func_int16_t_s_s((-7L), ((l_1078 != l_1081) == l_1082))))));
                    }
                    else
                    { /* block id: 485 */
                        int64_t l_1089 = 0xE3DB7034970679C1LL;
                        (*l_948) = l_1083;
                        /* statement id: 486 */
                        assert (l_949 == &l_1003);
                        (**l_947) = func_51((0x4CL & (l_1084 > (safe_div_func_uint32_t_u_u(((safe_mod_func_int16_t_s_s(((((l_1089 != ((safe_add_func_uint8_t_u_u(l_1063[1][0], (***l_1061))) & (18446744073709551615UL ^ ((safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s((safe_mod_func_int8_t_s_s((l_1063[4][0] >= (((safe_add_func_int8_t_s_s(l_1035, 0xD4L)) > 0L) == 255UL)), 0x15L)), 13)), (*l_949))) && l_1089)))) >= l_1100) && 1L) & (***l_1061)), 0x5266L)) < (***l_1061)), (*l_1083))))), (***l_1061), l_1101, l_962[4][4]);
                        /* statement id: 487 */
                        assert (l_949 == 0);
                        l_1078 = l_1102[0];
                        (**l_947) = l_1103;
                        /* statement id: 489 */
                        assert (l_949 == &l_6);
                    }
                    (**l_1061) = func_44(&l_1003, l_1104, (***l_1061), ((*l_1104) < (*l_1103)));
                    for (l_1065 = 24; (l_1065 == (-28)); --l_1065)
                    { /* block id: 494 */
                        (**l_947) = l_1104;
                        (**l_948) = (safe_sub_func_float_f_f((***l_1061), (l_1061 == l_1109)));
                    }
                }
                return l_1112;
            }
        }
    }
    (*l_1132) = ((0xE.F6D416p-90 >= (**l_948)) == ((+(((safe_div_func_float_f_f((((safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_add_func_float_f_f(0xB.582A04p-32, ((safe_add_func_float_f_f((((safe_add_func_float_f_f((-(safe_sub_func_float_f_f((***l_947), (0x6.0C39A5p+18 <= (safe_sub_func_float_f_f((*l_949), 0x4.Fp-1)))))), ((((&l_947 != &l_947) <= (*l_949)) != (**l_948)) < (***l_947)))) > 0x7.4p+1) < (-0x5.6p-1)), 0x1.Ep+1)) <= 0x0.0p+1))), (**l_948))) <= (*l_949)), (**l_948))) != (*l_949)) < 0xE.98D08Ep-65), 0x8.Fp-1)) >= (***l_947)) < (-0x7.Ep+1))) != (*l_949)));
    return l_1134;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_2(const int8_t  p_3, uint16_t  p_4, int32_t  p_5)
{ /* block id: 383 */
    float l_831 = 0xD.0DBDE9p+48;
    float *l_830 = &l_831;
    float *l_832 = &l_831;
    int32_t l_837 = (-6L);
    const int8_t l_856 = 0L;
    int32_t * const l_868 = &l_837;
    int32_t * const *l_867 = &l_868;
    float **l_906 = &l_830;
    float ***l_905 = &l_906;
    struct S0 l_943 = {0x00D0A941L,0x638D22B76414389ELL,-110,0xD8L,0xD4L,255UL};
    struct S0 *l_942 = &l_943;
    int32_t *l_946 = (void*)0;
    if (((safe_sub_func_int32_t_s_s((~0x9FBDL), (l_830 != l_832))) != (safe_add_func_uint64_t_u_u((safe_rshift_func_int8_t_s_s((-9L), l_837)), p_5))))
    { /* block id: 384 */
        int32_t *l_838 = &l_837;
        float **l_854 = &l_830;
        float ***l_853 = &l_854;
        uint32_t l_869 = 1UL;
        int32_t **l_904[3];
        int32_t ***l_903 = &l_904[1];
        int i;
        for (i = 0; i < 3; i++)
            l_904[i] = &l_838;
lbl_839:
        (*l_838) = p_3;
        if (l_837)
        { /* block id: 386 */
            if (p_3)
                goto lbl_839;
        }
        else
        { /* block id: 388 */
            float *l_844[1][6][5] = {{{&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,(void*)0,(void*)0},{&l_831,&l_831,&l_831,&l_831,&l_831},{(void*)0,&l_831,&l_831,(void*)0,&l_831},{(void*)0,(void*)0,(void*)0,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831}}};
            int32_t l_849[4][4][10] = {{{0L,3L,0x2B040032L,1L,0x0868908BL,0xDCCB74ACL,0x8DFA1675L,3L,0L,0L},{0L,2L,4L,(-1L),1L,(-4L),(-4L),1L,(-1L),4L},{0L,0L,(-2L),1L,0x45EBAA8CL,(-1L),0L,4L,0x33152A2FL,2L},{0x8DFA1675L,0xDCCB74ACL,0x0868908BL,1L,0x2B040032L,3L,0L,(-4L),(-1L),0x32FCEC55L}},{{(-1L),0L,(-1L),3L,2L,(-1L),(-4L),1L,0x0868908BL,(-1L)},{4L,2L,(-10L),(-1L),0x8DFA1675L,0x33152A2FL,0x8DFA1675L,(-1L),(-10L),2L},{0x925623C1L,3L,(-4L),0x8DFA1675L,4L,(-1L),1L,(-1L),(-1L),0x45EBAA8CL},{(-1L),0x925623C1L,(-1L),(-1L),1L,(-1L),0xA299C172L,0L,4L,(-4L)}},{{0x925623C1L,0L,1L,0L,0x9EB68066L,0x33152A2FL,0x925623C1L,4L,(-2L),8L},{4L,(-1L),0xDCCB74ACL,0x32FCEC55L,(-1L),(-1L),0x32FCEC55L,0xDCCB74ACL,(-1L),4L},{(-1L),(-1L),4L,0x2B040032L,0L,3L,(-1L),8L,(-4L),0x2B040032L},{0x8DFA1675L,0L,7L,(-1L),0L,(-1L),4L,0x9EB68066L,1L,4L}},{{0L,(-1L),3L,2L,(-1L),(-4L),1L,0x0868908BL,(-1L),8L},{0L,8L,0x2B040032L,0xDCCB74ACL,0x9EB68066L,0xDCCB74ACL,0x2B040032L,8L,0L,(-4L)},{0L,2L,(-2L),1L,1L,(-10L),0L,1L,(-1L),0x45EBAA8CL},{0L,(-4L),0xDCCB74ACL,1L,4L,3L,0L,0xA299C172L,0L,2L}}};
            float ***l_855 = &l_854;
            int i, j, k;
            (***l_853) = ((((((safe_div_func_float_f_f(((safe_sub_func_float_f_f(((void*)0 == l_844[0][2][0]), ((safe_add_func_float_f_f((safe_add_func_float_f_f(l_849[3][2][3], (safe_sub_func_float_f_f(p_5, ((p_4 != l_849[3][2][3]) > p_3))))), ((-((l_853 == l_855) <= 0x1.A09FECp-70)) <= p_5))) < 0x5.BDE5B0p+16))) < 0x5.9p+1), p_5)) >= p_5) == p_4) >= (-0x2.9p+1)) == l_849[3][2][3]) < 0xD.792473p-59);
            (*l_838) = (l_856 | (l_856 | ((**l_855) == (void*)0)));
        }
        if ((safe_lshift_func_int8_t_s_u(((((((p_4 >= ((safe_mod_func_int16_t_s_s((safe_rshift_func_uint16_t_u_u((p_5 < (-4L)), l_856)), l_856)) < ((*l_838) <= 9L))) | l_856) != ((safe_lshift_func_int8_t_s_u(((l_867 == &l_868) > 5L), 6)) > 1UL)) != (*l_838)) < l_869) != 0x35L), (*l_868))))
        { /* block id: 392 */
            int8_t l_899 = (-1L);
            int32_t *l_921 = (void*)0;
            for (l_837 = 0; (l_837 != 0); l_837 = safe_add_func_int64_t_s_s(l_837, 6))
            { /* block id: 395 */
                struct S0 l_878 = {-7L,0x7143BB4ECACB5E0DLL,110,0x25L,0x5EL,0x9FL};
                struct S0 *l_877 = &l_878;
                struct S0 **l_876[1][1];
                int i, j;
                for (i = 0; i < 1; i++)
                {
                    for (j = 0; j < 1; j++)
                        l_876[i][j] = &l_877;
                }
                for (l_869 = (-4); (l_869 >= 23); l_869++)
                { /* block id: 398 */
                    for (p_4 = 0; (p_4 == 22); p_4++)
                    { /* block id: 401 */
                        struct S0 ***l_879 = &l_876[0][0];
                        (*l_879) = l_876[0][0];
                    }
                }
                for (l_878.f4 = 0; (l_878.f4 >= 38); l_878.f4 = safe_add_func_int16_t_s_s(l_878.f4, 7))
                { /* block id: 407 */
                    int32_t **l_882 = &l_838;
                    (*l_882) = (void*)0;
                    /* statement id: 408 */
                    assert (l_838 == 0);
                    for (l_878.f5 = 0; (l_878.f5 > 24); l_878.f5 = safe_add_func_uint8_t_u_u(l_878.f5, 4))
                    { /* block id: 411 */
                        int32_t l_900[6] = {0L,0L,0L,0L,0L,0L};
                        int i;
                        (**l_854) = p_5;
                        (*l_882) = func_33((safe_rshift_func_int16_t_s_u(p_4, 2)), (*l_882), (safe_add_func_uint8_t_u_u(0xC6L, (safe_div_func_int16_t_s_s((safe_lshift_func_int16_t_s_u((safe_div_func_uint8_t_u_u(((1L > (safe_div_func_int32_t_s_s((((safe_sub_func_uint32_t_u_u(((l_899 >= p_4) ^ l_878.f4), ((p_4 && l_878.f4) == p_5))) == (*l_868)) > 0x138595D801AFBA00LL), p_3))) == 0xBF6315291AAE7A63LL), p_4)), 4)), p_4)))), l_900[0]);
                    }
                    (*l_882) = &p_5;
                    /* statement id: 415 */
                    assert (l_838 == &p_5);
                    (*l_838) = (((safe_rshift_func_uint8_t_u_u((((void*)0 == l_903) != (((((void*)0 != l_905) < (((safe_div_func_int32_t_s_s((safe_rshift_func_int16_t_s_s((safe_lshift_func_int8_t_s_u((-1L), (1UL <= (safe_add_func_uint64_t_u_u(((safe_mod_func_int32_t_s_s((**l_882), (safe_mod_func_int32_t_s_s((0x979E3E51L ^ ((safe_mod_func_uint8_t_u_u(((-1L) ^ (*l_868)), 0xC6L)) ^ (**l_882))), l_878.f5)))) < l_899), (*l_868)))))), 12)), p_5)) | l_899) >= 1UL)) ^ (**l_867)) > p_4)), 4)) && l_899) >= p_4);
                }
                for (l_869 = 0; (l_869 <= 2); l_869 += 1)
                { /* block id: 420 */
                    int i;
                    (**l_903) = (void*)0;
                    /* statement id: 421 */
                    assert (l_838 == 0);
                    for (l_878.f3 = 0; (l_878.f3 <= 2); l_878.f3 += 1)
                    { /* block id: 424 */
                        return l_878.f0;
                    }
                    (**l_903) = (void*)0;
                }
            }
            /* facts after for loop */
            assert (l_838 == 0 || l_838 == &p_5 || l_838 == &l_837);
            (**l_903) = l_921;
            /* statement id: 430 */
            assert (l_838 == 0);
        }
        else
        { /* block id: 431 */
            float l_926 = 0x6.EDE268p+97;
            int32_t l_929 = (-7L);
            (*l_868) = (safe_lshift_func_uint8_t_u_s((safe_add_func_uint64_t_u_u(((**l_867) <= 0x5065F988L), (p_4 ^ ((safe_div_func_int64_t_s_s(0x480058F4622AED32LL, (0x0121A3730ED78075LL | ((((0xAEE8F77B6F82E9CELL || p_5) & (***l_903)) != l_929) ^ p_3)))) != p_3)))), (*l_868)));
        }
        /* facts after branching */
        assert (l_838 == &l_837 || l_838 == 0);
    }
    else
    { /* block id: 434 */
        int16_t l_937 = 0xA736L;
        int32_t *l_939 = &l_837;
        int32_t **l_944 = (void*)0;
        int32_t **l_945[6][4] = {{&l_939,&l_939,&l_939,&l_939},{&l_939,&l_939,&l_939,&l_939},{&l_939,&l_939,&l_939,&l_939},{&l_939,&l_939,&l_939,&l_939},{&l_939,&l_939,&l_939,&l_939},{&l_939,&l_939,&l_939,&l_939}};
        int i, j;
        for (p_5 = 0; (p_5 < 1); p_5 = safe_add_func_int16_t_s_s(p_5, 1))
        { /* block id: 437 */
            float *l_936 = &l_831;
            int32_t **l_938 = (void*)0;
            struct S0 l_941 = {-6L,5L,114,0x09L,0xA2L,3UL};
            struct S0 *l_940[4];
            int i;
            for (i = 0; i < 4; i++)
                l_940[i] = &l_941;
            (*l_868) = (safe_sub_func_int64_t_s_s((3UL & (safe_rshift_func_int16_t_s_s(((void*)0 != l_936), 1))), l_937));
            l_939 = func_44(&l_837, l_936, p_3, l_937);
            /* statement id: 439 */
            assert (l_939 == &l_831);
            l_942 = l_940[3];
            /* statement id: 440 */
            assert (l_942 == &l_941);
        }
        /* facts after for loop */
        assert (l_939 == &l_831 || l_939 == &l_837);
        //assert (l_942 == dangling || l_942 == &l_943);
        l_946 = (void*)0;
    }
    /* facts after branching */
    //assert (l_942 == dangling || l_942 == &l_943);
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_7(int16_t  p_8, float  p_9, uint32_t  p_10, float  p_11)
{ /* block id: 380 */
    int32_t l_826 = 0x4ED938CBL;
    int32_t *l_825 = &l_826;
    l_825 = (void*)0;
    /* statement id: 381 */
    assert (l_825 == 0);
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_14(struct S0  p_15, uint64_t  p_16, uint64_t  p_17, float  p_18, int8_t  p_19)
{ /* block id: 4 */
    const int32_t l_50 = 0xF356D9DEL;
    const int32_t *l_49 = &l_50;
    int32_t *l_61 = (void*)0;
    for (p_15.f3 = (-10); (p_15.f3 == 17); p_15.f3 = safe_add_func_uint32_t_u_u(p_15.f3, 7))
    { /* block id: 7 */
        int32_t l_63 = 9L;
        int32_t *l_62 = &l_63;
        int32_t l_583 = 0x8A137D83L;
        int32_t **l_824 = &l_62;
        (*l_824) = func_33((func_38(func_44(l_49, func_51((*l_49), func_56(p_19, l_61, l_62, l_61), ((*l_49) >= ((safe_div_func_int16_t_s_s((&l_50 == (void*)0), p_15.f1)) && 2L)), (*l_62)), (*l_62), (*l_49)), (*l_62), &l_63, l_61, l_61) != l_583), l_61, l_583, (*l_49));
        /* statement id: 377 */
        assert (l_62 == 0);
    }
    return p_15.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_20(float  p_21)
{ /* block id: 1 */
    int32_t l_29 = 0xB9338886L;
    int32_t *l_28 = &l_29;
    struct S0 l_30[6] = {{0xD0E834ABL,0L,-90,0UL,0xC9L,1UL},{0xD0E834ABL,0L,-90,0UL,0xC9L,1UL},{0xD0E834ABL,0L,-90,0UL,0xC9L,1UL},{0xD0E834ABL,0L,-90,0UL,0xC9L,1UL},{0xD0E834ABL,0L,-90,0UL,0xC9L,1UL},{0xD0E834ABL,0L,-90,0UL,0xC9L,1UL}};
    int i;
    l_28 = l_28;
    return l_30[2];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_33(uint32_t  p_34, int32_t * p_35, int64_t  p_36, int16_t  p_37)
{ /* block id: 252 */
    int32_t ** const l_588 = (void*)0;
    int32_t ** const *l_587 = &l_588;
    int32_t ** const ** const l_586 = &l_587;
    uint16_t l_597 = 0x11C0L;
    int32_t l_604[9] = {0xD5982946L,(-10L),0xD5982946L,(-10L),0xD5982946L,(-10L),0xD5982946L,(-10L),0xD5982946L};
    uint8_t l_605 = 0x37L;
    int32_t *l_606 = (void*)0;
    int32_t l_608[7][3][10] = {{{8L,(-3L),(-8L),(-1L),0x52F0B213L,0xBDCA4FB8L,(-1L),0x45A5A546L,0x45A5A546L,(-1L)},{0x5BCCE20BL,0L,(-1L),(-1L),0L,0x5BCCE20BL,(-1L),0xEDC4F0FAL,(-1L),(-8L)},{0x5F5CADD3L,(-3L),0x2110B905L,(-1L),(-1L),4L,(-8L),0x2110B905L,0x45A5A546L,0x606AE8D6L}},{{0x5F5CADD3L,0x800BB6C0L,0x45A5A546L,(-1L),(-3L),0x5BCCE20BL,0x606AE8D6L,0x2110B905L,0xEDC4F0FAL,(-3L)},{0x5BCCE20BL,0x606AE8D6L,0x2110B905L,0xEDC4F0FAL,(-3L),0xBDCA4FB8L,(-3L),0xEDC4F0FAL,0x2110B905L,0x606AE8D6L},{8L,0x606AE8D6L,(-1L),(-8L),(-1L),9L,0x606AE8D6L,0x45A5A546L,0x2110B905L,(-8L)}},{{0xBDCA4FB8L,0x800BB6C0L,(-8L),0xEDC4F0FAL,0L,9L,(-8L),(-1L),0xEDC4F0FAL,(-1L)},{8L,(-3L),(-8L),(-1L),0x52F0B213L,0xBDCA4FB8L,(-1L),0x45A5A546L,0x45A5A546L,(-1L)},{0x5BCCE20BL,0L,(-1L),(-1L),0L,0x5BCCE20BL,(-1L),0xEDC4F0FAL,(-1L),(-8L)}},{{0x5F5CADD3L,(-3L),0x2110B905L,(-1L),(-1L),4L,(-8L),0x2110B905L,0x45A5A546L,0x606AE8D6L},{0x5F5CADD3L,0x800BB6C0L,0x45A5A546L,(-1L),(-3L),0x5BCCE20BL,0x606AE8D6L,0x2110B905L,0xEDC4F0FAL,(-3L)},{0x5BCCE20BL,0x606AE8D6L,0x2110B905L,0xEDC4F0FAL,(-3L),0xBDCA4FB8L,(-3L),0xEDC4F0FAL,0x2110B905L,0x606AE8D6L}},{{8L,0x606AE8D6L,(-1L),(-8L),(-1L),9L,0x606AE8D6L,0x45A5A546L,0x2110B905L,(-8L)},{0xBDCA4FB8L,0x800BB6C0L,(-8L),0xEDC4F0FAL,0L,9L,(-8L),(-1L),0xEDC4F0FAL,(-1L)},{8L,(-3L),(-8L),(-1L),0x52F0B213L,0xBDCA4FB8L,(-1L),0x45A5A546L,0x45A5A546L,(-1L)}},{{0x5BCCE20BL,0L,(-1L),(-1L),0L,0x5BCCE20BL,(-1L),0xEDC4F0FAL,(-1L),(-8L)},{0x5F5CADD3L,(-3L),0x2110B905L,(-1L),(-1L),4L,(-8L),0x2110B905L,0x52F0B213L,0xFE54F21CL},{0L,0x374987E1L,0x52F0B213L,(-8L),0xF96B50E0L,0xC500E391L,0xFE54F21CL,0L,0x606AE8D6L,0xF96B50E0L}},{{0xC500E391L,0xFE54F21CL,0L,0x606AE8D6L,0xF96B50E0L,2L,0xF96B50E0L,0x606AE8D6L,0L,0xFE54F21CL},{0x94C7BD57L,0xFE54F21CL,(-1L),(-3L),0xC8F0780FL,1L,0xFE54F21CL,0x52F0B213L,0L,(-2L)},{2L,0x374987E1L,(-3L),0x606AE8D6L,0L,1L,(-2L),(-8L),0x606AE8D6L,0xC8F0780FL}}};
    int32_t *l_607 = &l_608[5][2][3];
    float l_612 = (-0x1.7p+1);
    float * const l_611 = &l_612;
    float * const *l_610[10] = {&l_611,&l_611,&l_611,&l_611,&l_611,&l_611,&l_611,&l_611,&l_611,&l_611};
    float * const **l_609 = &l_610[3];
    int16_t l_723 = 0x6C99L;
    int32_t *l_765 = (void*)0;
    struct S0 l_777 = {1L,0x497A15904ECC825DLL,29,5UL,0x5AL,0x23L};
    struct S0 *l_776 = &l_777;
    const int32_t *l_823 = &l_608[2][1][5];
    const int32_t **l_822 = &l_823;
    int i, j, k;
    (*l_607) = ((((safe_lshift_func_int8_t_s_u(((void*)0 == l_586), 3)) & (safe_rshift_func_int8_t_s_u(((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int8_t_s_u((safe_div_func_int8_t_s_s((0xF348L == (l_597 & l_597)), ((((safe_add_func_uint64_t_u_u(p_36, (!(-1L)))) <= (!(((((l_604[1] ^ ((void*)0 == &l_587)) == l_597) ^ p_36) < p_36) == p_34))) ^ p_36) ^ p_36))), l_605)), 15)) < 1L), p_36))) > p_37) <= p_34);
    if ((p_37 | ((void*)0 == l_609)))
    { /* block id: 254 */
        int32_t l_615 = (-10L);
        int32_t * const *l_623 = &l_607;
        int32_t * const **l_622 = &l_623;
        float *l_693 = &l_612;
        float **l_692 = &l_693;
        float ***l_691 = &l_692;
        int32_t *l_694 = &l_608[5][2][3];
        struct S0 l_728 = {-1L,0x5DC5DE7A881CBF21LL,-44,0x58L,0x03L,9UL};
        struct S0 *l_727 = &l_728;
        struct S0 **l_726 = &l_727;
        struct S0 ***l_725 = &l_726;
        int32_t *l_742 = (void*)0;
        int32_t l_812 = 1L;
        for (p_36 = 0; (p_36 <= 9); p_36 += 1)
        { /* block id: 257 */
            int32_t l_624 = 0xA58A465DL;
            struct S0 l_631 = {7L,0xCAD3445E5A8A51BELL,-3,0xC0L,255UL,247UL};
            struct S0 *l_630 = &l_631;
            struct S0 **l_629 = &l_630;
            struct S0 ***l_628 = &l_629;
            int64_t l_632 = 0x0908BFAFFCD57A6ALL;
            int32_t l_676 = 0L;
            uint8_t l_688 = 0x8DL;
            const int8_t l_697 = 0xB5L;
            uint64_t l_760 = 0x564E056D7D8795FELL;
            int32_t *l_766 = (void*)0;
            int32_t **l_803 = &l_694;
            int32_t ***l_802 = &l_803;
            int32_t ****l_801 = &l_802;
            int32_t *****l_800 = &l_801;
            int i;
            l_615 = (safe_sub_func_float_f_f(p_36, 0x0.9p-1));
            p_35 = p_35;
        }
        for (l_728.f5 = 0; (l_728.f5 > 5); l_728.f5++)
        { /* block id: 368 */
            int32_t *l_817 = (void*)0;
            return l_817;
            /* statement id: 369 */
            //assert (func_33_rv == 0);
        }
    }
    else
    { /* block id: 371 */
        struct S0 ***l_819[2];
        struct S0 **** const l_818 = &l_819[1];
        struct S0 ****l_820 = (void*)0;
        int32_t *l_821 = &l_608[5][0][1];
        int i;
        for (i = 0; i < 2; i++)
            l_819[i] = (void*)0;
        l_820 = l_818;
        /* statement id: 372 */
        assert ((l_820 >= &l_819[0] && l_820 <= &l_819[1]));
        l_821 = p_35;
        /* statement id: 373 */
        assert (l_821 == 0);
    }
    (*l_822) = (void*)0;
    /* statement id: 375 */
    assert (l_823 == 0);
    return p_35;
    /* statement id: 376 */
    //assert (func_33_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_38(int32_t * p_39, int64_t  p_40, int32_t * p_41, int32_t * const  p_42, int32_t * p_43)
{ /* block id: 192 */
    struct S0 l_483[7] = {{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL},{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL},{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL},{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL},{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL},{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL},{-6L,0xFF676EC7671CB164LL,25,0xF0L,0x6BL,0UL}};
    struct S0 *l_482 = &l_483[0];
    int32_t l_485 = 0x04268EFDL;
    int32_t *l_484[7][8] = {{&l_485,(void*)0,(void*)0,&l_485,&l_485,&l_485,(void*)0,(void*)0},{(void*)0,&l_485,&l_485,&l_485,&l_485,(void*)0,&l_485,&l_485},{&l_485,&l_485,&l_485,(void*)0,(void*)0,&l_485,&l_485,&l_485},{&l_485,(void*)0,&l_485,(void*)0,&l_485,&l_485,(void*)0,&l_485},{&l_485,&l_485,(void*)0,&l_485,(void*)0,&l_485,&l_485,(void*)0},{&l_485,(void*)0,(void*)0,&l_485,&l_485,&l_485,(void*)0,(void*)0},{(void*)0,&l_485,&l_485,&l_485,&l_485,(void*)0,&l_485,&l_485}};
    int32_t **l_486 = &l_484[6][2];
    const int32_t ***l_488 = (void*)0;
    const int32_t **** const l_487 = &l_488;
    int16_t l_492 = 1L;
    uint16_t l_498 = 1UL;
    struct S0 ***l_501 = (void*)0;
    int32_t ** const *l_545[1];
    int32_t ** const **l_544 = &l_545[0];
    int32_t ** const ***l_543 = &l_544;
    float l_568[1][1][9];
    float *l_567 = &l_568[0][0][5];
    float ** const l_566 = &l_567;
    uint8_t l_580 = 0xCFL;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_545[i] = &l_486;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 1; j++)
        {
            for (k = 0; k < 9; k++)
                l_568[i][j][k] = 0x1.7p-1;
        }
    }
    l_482 = l_482;
    (*l_486) = l_484[5][3];
    if ((l_487 == &l_488))
    { /* block id: 195 */
        int32_t *l_489 = &l_485;
        int32_t ** const * const l_491 = &l_486;
        int32_t ** const * const *l_490 = &l_491;
        (*l_486) = l_489;
        l_492 = ((void*)0 == l_490);
    }
    else
    { /* block id: 198 */
        int32_t ***l_495 = &l_486;
        int32_t ****l_494 = &l_495;
        int32_t *****l_493 = &l_494;
        float l_497[7][2] = {{0xC.57236Dp-10,0xC.57236Dp-10},{0x1.6p-1,0xC.57236Dp-10},{0xC.57236Dp-10,0x1.6p-1},{0xC.57236Dp-10,0xC.57236Dp-10},{0x1.6p-1,0xC.57236Dp-10},{0xC.57236Dp-10,0x1.6p-1},{0xC.57236Dp-10,0xC.57236Dp-10}};
        float *l_496 = &l_497[3][1];
        int i, j;
        (*l_496) = ((void*)0 == l_493);
        (**l_495) = func_51(l_498, (0x2596A0A95EC7957ALL || ((p_41 != p_42) & p_40)), ((p_43 != (void*)0) < (safe_mod_func_uint32_t_u_u((l_501 == (void*)0), (*p_41)))), p_40);
    }
    if ((9UL || (((safe_div_func_int16_t_s_s(p_40, ((p_40 ^ p_40) && (safe_sub_func_int8_t_s_s(0xB6L, ((p_40 & ((((safe_mod_func_int64_t_s_s((((p_43 == (*l_486)) == (*p_41)) != p_40), p_40)) <= 4UL) <= 0x73L) != p_40)) && 1L)))))) & p_40) & p_40)))
    { /* block id: 202 */
        int64_t l_511 = 0xFEAE2BD94C2BE8C4LL;
        int32_t ** const *l_542 = (void*)0;
        int32_t ** const **l_541 = &l_542;
        int32_t ** const ***l_540 = &l_541;
        int16_t l_562 = 1L;
        float l_563 = (-0x1.Bp-1);
        for (l_485 = 5; (l_485 >= 0); l_485 -= 1)
        { /* block id: 205 */
            int32_t l_510 = (-10L);
            int32_t ***l_514 = &l_486;
            int32_t ****l_513 = &l_514;
            int32_t ***** const l_512 = &l_513;
            int32_t l_546 = 0x7344011DL;
            if (l_510)
                break;
            if (l_511)
            { /* block id: 207 */
                (*p_41) = ((&l_487 != l_512) || ((safe_lshift_func_int16_t_s_u((-1L), 3)) & (safe_lshift_func_int16_t_s_s(p_40, 8))));
            }
            else
            { /* block id: 209 */
                struct S0 **l_519 = &l_482;
                struct S0 ***l_520 = &l_519;
                int32_t l_535 = (-1L);
                int32_t l_539 = 0L;
                (*l_520) = l_519;
                if ((safe_div_func_int16_t_s_s((safe_rshift_func_int8_t_s_s((((safe_div_func_uint8_t_u_u((safe_add_func_int32_t_s_s((safe_add_func_uint16_t_u_u(p_40, p_40)), l_511)), (-10L))) >= l_511) != (safe_mod_func_int16_t_s_s((safe_div_func_int16_t_s_s(((0xEBB2CC8573C973EFLL && 0x856DB8F834512622LL) != 0x57F0L), l_535)), p_40))), 2)), p_40)))
                { /* block id: 211 */
                    if ((~p_40))
                    { /* block id: 212 */
                        float l_538 = 0x9.ABF1F3p-25;
                        float *l_537 = &l_538;
                        (*l_537) = (((***l_513) != &l_535) >= (p_40 == p_40));
                        if ((*p_41))
                            break;
                    }
                    else
                    { /* block id: 215 */
                        (*p_41) = l_539;
                    }
                }
                else
                { /* block id: 218 */
                    for (p_40 = 0; (p_40 <= 6); p_40 += 1)
                    { /* block id: 221 */
                        int i, j;
                        l_543 = l_540;
                        /* statement id: 222 */
                        assert (l_543 == &l_541);
                        l_484[(l_485 + 1)][(l_485 + 2)] = l_484[p_40][(l_485 + 2)];
                    }
                    /* facts after for loop */
                    assert (l_543 == &l_541 || l_543 == &l_544);
                    (*l_544) = (*l_541);
                    /* statement id: 225 */
                    //assert (l_545[0] == 0 || l_545[0] == &l_486);
                }
                /* facts after branching */
                //assert (l_545[0] == 0 || l_545[0] == &l_486);
                assert (l_543 == &l_541 || l_543 == &l_544);
                for (p_40 = 6; (p_40 >= 0); p_40 -= 1)
                { /* block id: 229 */
                    return p_40;
                }
                l_546 = (*p_41);
            }
            /* facts after branching */
            //assert (l_545[0] == 0 || l_545[0] == &l_486);
            assert (l_543 == &l_541 || l_543 == &l_544);
            return p_40;
        }
        if ((safe_rshift_func_uint16_t_u_u(p_40, (((((safe_sub_func_int8_t_s_s((((safe_add_func_int16_t_s_s((safe_sub_func_int8_t_s_s((!((1L >= (((void*)0 == l_501) == ((safe_add_func_int32_t_s_s((~(((p_40 <= (((~((safe_lshift_func_uint8_t_u_u(p_40, (p_40 == 0xF3L))) <= (p_40 != p_40))) & p_40) | p_40)) == p_40) != l_562)), 0L)) == p_40))) | 0L)), p_40)), p_40)) > l_562) <= p_40), p_40)) | p_40) == p_40) && p_40) ^ p_40))))
        { /* block id: 236 */
            for (l_511 = (-9); (l_511 <= 16); l_511 = safe_add_func_int32_t_s_s(l_511, 8))
            { /* block id: 239 */
                return p_40;
            }
        }
        else
        { /* block id: 242 */
            float **l_570 = &l_567;
            float ***l_569 = &l_570;
            (*l_569) = l_566;
        }
        (****l_543) = (void*)0;
        return p_40;
    }
    else
    { /* block id: 247 */
        int8_t l_581 = 1L;
        int32_t l_582 = 1L;
        l_582 = (-(safe_div_func_float_f_f((safe_add_func_float_f_f(((safe_sub_func_float_f_f((safe_sub_func_float_f_f((l_501 == (void*)0), ((l_580 == 0x0.977C2Ep+33) <= (((p_40 > (p_40 == (p_40 == (p_40 == (l_581 > p_40))))) != l_581) != 0xE.6730E5p+77)))), p_40)) == 0x1.5p-1), p_40)), l_581)));
        (*p_41) = l_581;
    }
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_44(const int32_t * p_45, int32_t * p_46, uint32_t  p_47, int64_t  p_48)
{ /* block id: 64 */
    int32_t l_167[2][3][10] = {{{(-10L),(-3L),(-3L),(-10L),(-3L),(-10L),(-3L),(-3L),(-10L),(-3L)},{(-10L),(-3L),(-3L),(-10L),(-3L),(-10L),(-3L),(-3L),(-10L),(-3L)},{(-10L),(-3L),(-3L),(-10L),(-3L),(-10L),(-3L),(-3L),(-10L),(-3L)}},{{(-10L),(-3L),(-3L),(-10L),(-3L),(-10L),(-3L),(-3L),(-10L),(-3L)},{(-10L),(-3L),(-3L),(-10L),(-3L),(-10L),(-3L),(-3L),(-10L),(-3L)},{(-10L),(-3L),(-3L),(-10L),(-3L),(-10L),(-3L),(-3L),(-10L),(-3L)}}};
    int32_t *l_166 = &l_167[1][0][7];
    int32_t l_175 = 0x4A68E686L;
    int32_t ****l_269 = (void*)0;
    int32_t **l_275 = &l_166;
    int32_t ***l_274[6][9] = {{(void*)0,(void*)0,(void*)0,&l_275,(void*)0,&l_275,(void*)0,&l_275,&l_275},{&l_275,&l_275,&l_275,&l_275,&l_275,(void*)0,&l_275,&l_275,(void*)0},{&l_275,&l_275,(void*)0,(void*)0,&l_275,&l_275,&l_275,&l_275,(void*)0},{&l_275,&l_275,&l_275,&l_275,(void*)0,(void*)0,&l_275,&l_275,&l_275},{&l_275,&l_275,&l_275,(void*)0,(void*)0,&l_275,&l_275,&l_275,&l_275},{(void*)0,&l_275,&l_275,&l_275,&l_275,(void*)0,(void*)0,&l_275,&l_275}};
    struct S0 ** const *l_286 = (void*)0;
    int64_t l_342 = (-10L);
    float l_469 = 0xE.16583Ep-77;
    int i, j, k;
    for (p_47 = 21; (p_47 < 4); --p_47)
    { /* block id: 67 */
        uint16_t l_165[10] = {0x620FL,65533UL,0x620FL,0x620FL,65533UL,0x620FL,0x620FL,65533UL,0x620FL,0x620FL};
        const int32_t *l_168[3];
        int32_t *l_176 = (void*)0;
        int32_t *l_177[10][4] = {{&l_167[1][2][6],&l_167[1][1][6],&l_175,&l_167[1][0][7]},{&l_167[1][0][7],&l_167[1][0][8],&l_167[1][0][7],&l_167[0][2][2]},{&l_167[1][0][7],(void*)0,(void*)0,&l_167[0][2][2]},{&l_167[1][1][6],&l_167[1][0][8],&l_167[1][0][7],&l_167[1][0][7]},{&l_167[1][0][7],&l_167[1][1][6],&l_167[1][0][7],&l_175},{(void*)0,&l_167[1][2][3],&l_167[1][0][7],&l_167[1][0][8]},{&l_167[0][2][2],&l_167[1][0][7],&l_167[1][0][7],&l_167[1][2][3]},{&l_167[1][0][7],&l_167[1][0][7],&l_167[1][0][7],(void*)0},{&l_167[0][2][2],&l_167[1][0][9],&l_167[1][0][7],&l_167[1][0][7]},{(void*)0,(void*)0,&l_167[1][0][7],&l_167[1][0][7]}};
        int i, j;
        for (i = 0; i < 3; i++)
            l_168[i] = &l_167[1][0][7];
        for (p_48 = 9; (p_48 >= 1); p_48 -= 1)
        { /* block id: 70 */
            l_166 = (void*)0;
            /* statement id: 71 */
            assert (l_166 == 0);
            p_45 = l_168[0];
            /* statement id: 72 */
            assert ((p_45 >= &l_167[0][0][0] && p_45 <= &l_167[1][2][9]));
        }
        l_167[1][0][8] = (safe_mod_func_int64_t_s_s(p_48, (safe_rshift_func_uint16_t_u_s(p_47, (safe_div_func_int8_t_s_s(l_175, p_48))))));
    }
    /* facts after for loop */
    //assert ((p_45 >= &l_167[0][0][0] && p_45 <= &l_167[1][2][9]) || p_45 == &l_50 || p_45 == &l_615 || (p_45 >= &l_608[0][0][0] && p_45 <= &l_608[6][2][9]) || p_45 == 0 || p_45 == &l_734 || p_45 == &l_837 || p_45 == &l_1003);
    assert (l_166 == 0 || (l_166 >= &l_167[0][0][0] && l_166 <= &l_167[1][2][9]));
    for (p_47 = 22; (p_47 != 45); p_47++)
    { /* block id: 78 */
        int32_t **l_187 = (void*)0;
        int32_t ** const *l_186 = &l_187;
        int32_t *l_190 = &l_175;
        int32_t *****l_214 = (void*)0;
        int8_t l_280 = 0L;
        int16_t l_315[5];
        uint32_t l_316[6][4] = {{1UL,0x1F0CD584L,1UL,0x1F0CD584L},{1UL,0x1F0CD584L,1UL,0x1F0CD584L},{1UL,0x1F0CD584L,1UL,0x1F0CD584L},{1UL,0x1F0CD584L,1UL,0x1F0CD584L},{1UL,0x1F0CD584L,1UL,0x1F0CD584L},{1UL,0x1F0CD584L,1UL,0x1F0CD584L}};
        struct S0 l_318 = {3L,1L,-67,0xF9L,0x7DL,0xDDL};
        struct S0 *l_317 = &l_318;
        int64_t l_341 = 7L;
        int8_t l_359 = 0xA7L;
        uint32_t l_364 = 9UL;
        int i, j;
        for (i = 0; i < 5; i++)
            l_315[i] = 0xC19AL;
    }
    return p_46;
    /* statement id: 191 */
    //assert (func_44_rv == 0 || (func_44_rv >= &l_608[0][0][0] && func_44_rv <= &l_608[6][2][9]) || func_44_rv == &l_624 || func_44_rv == &l_831 || func_44_rv == &l_6);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_51(uint64_t  p_52, int32_t  p_53, int32_t  p_54, uint8_t  p_55)
{ /* block id: 10 */
    int64_t l_69[2];
    int32_t l_72[3][3] = {{6L,0x2651EF22L,6L},{0x5BCDCEC4L,0x5BCDCEC4L,0x5BCDCEC4L},{6L,0x2651EF22L,6L}};
    int32_t *l_71 = &l_72[0][2];
    int32_t **l_70 = &l_71;
    uint8_t l_79[10][2][8] = {{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}},{{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L},{0xF5L,8UL,8UL,0xF5L,0xF5L,8UL,8UL,0xF5L}}};
    int32_t ***l_149 = &l_70;
    int32_t ****l_148[5] = {&l_149,&l_149,&l_149,&l_149,&l_149};
    int32_t *****l_147 = &l_148[2];
    int32_t *l_150 = &l_72[0][2];
    int32_t *l_151[9] = {&l_72[0][2],&l_72[0][2],&l_72[0][2],&l_72[0][2],&l_72[0][2],&l_72[0][2],&l_72[0][2],&l_72[0][2],&l_72[0][2]};
    int32_t *l_152 = &l_72[0][2];
    int32_t *l_153 = &l_72[0][2];
    int32_t *l_154 = &l_72[2][0];
    int32_t *l_155 = &l_72[2][1];
    int32_t *l_156 = &l_72[2][0];
    int32_t *l_157 = &l_72[0][2];
    int32_t *l_158 = &l_72[1][2];
    int32_t *l_159 = &l_72[0][2];
    int32_t *l_160 = &l_72[0][2];
    int32_t *l_161 = &l_72[0][2];
    int32_t *l_162 = (void*)0;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_69[i] = 0xD2DC0978C764457CLL;
    for (p_52 = 0; (p_52 == 53); p_52++)
    { /* block id: 13 */
        int32_t **l_76 = &l_71;
    }
    for (p_54 = 0; (p_54 >= (-26)); p_54 = safe_sub_func_int8_t_s_s(p_54, 8))
    { /* block id: 57 */
        int32_t ***l_145 = (void*)0;
        int32_t ****l_146 = &l_145;
        (*l_146) = l_145;
        l_147 = l_147;
        (**l_70) = 1L;
        (**l_70) = (&l_148[0] == (void*)0);
    }
    return l_162;
    /* statement id: 63 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_56(float  p_57, int32_t * p_58, int32_t * p_59, int32_t * p_60)
{ /* block id: 8 */
    uint32_t l_64 = 0x0C0F3ADCL;
    return l_64;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 230
   depth: 1, occurrence: 1
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 31
breakdown:
   indirect level: 0, occurrence: 1
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 6
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 12
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 12
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 140
   depth: 2, occurrence: 32
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 4
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 2

XXX total number of pointers: 256

XXX times a variable address is taken: 351
XXX times a pointer is dereferenced on RHS: 141
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 28
   depth: 3, occurrence: 29
XXX times a pointer is dereferenced on LHS: 101
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 19
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 53
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 21
XXX times a pointer is qualified to be dereferenced: 1205

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 195
   level: 2, occurrence: 99
   level: 3, occurrence: 94
   level: 4, occurrence: 32
   level: 5, occurrence: 8
XXX number of pointers point to pointers: 146
XXX number of pointers point to scalars: 96
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 29.7
XXX average alias set size: 1.24

XXX times a non-volatile is read: 1207
XXX times a non-volatile is write: 332
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 7

XXX stmts: 134
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 28
   depth: 2, occurrence: 21
   depth: 3, occurrence: 16
   depth: 4, occurrence: 21
   depth: 5, occurrence: 21

XXX percentage a fresh-made variable is used: 13.6
XXX percentage an existing variable is used: 86.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

