/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3476442613
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint64_t  f0;
   const signed f1 : 14;
   int16_t  f2;
   int64_t  f3;
   uint8_t  f4;
   uint64_t  f5;
   int16_t  f6;
   const uint8_t  f7;
};
#pragma pack(pop)

union U1 {
   int32_t  f0;
   int16_t  f1;
   unsigned f2 : 1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_29(void);
inline static const uint16_t  func_30(float  p_31);
inline static int32_t  func_37(int32_t  p_38, uint32_t  p_39);
inline static union U1 * func_55(uint8_t  p_56, const float  p_57, uint32_t  p_58, const float  p_59, int16_t  p_60);
inline static const uint16_t  func_61(uint64_t  p_62, union U1 * p_63, int32_t * p_64, uint16_t  p_65);
inline static union U1 * func_68(int64_t  p_69, const int32_t  p_70, int32_t ** p_71, int16_t  p_72);
inline static int16_t  func_75(int32_t ** p_76, int32_t ** p_77, uint32_t  p_78, uint8_t  p_79);
static int32_t ** func_80(union U1  p_81, int64_t  p_82);
static int64_t  func_84(int32_t ** const  p_85, int32_t ** p_86);
static int32_t ** const  func_87(int32_t * p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_29(void)
{ /* block id: 36 */
    int64_t l_32 = 0x4C20F746E33A79CCLL;
    int32_t *l_34 = (void*)0;
    int32_t l_36 = 0x16AAC895L;
    int32_t *l_35 = &l_36;
    union U1 *l_562 = (void*)0;
    int64_t l_563 = 0x03FF2FEEC0DB6353LL;
    uint32_t l_569 = 0x8F959661L;
    float l_588 = (-0x1.Ap-1);
    float *l_587 = &l_588;
    float **l_586 = &l_587;
    uint32_t l_590 = 0x88E19E70L;
    struct S0 *l_591 = (void*)0;
    uint16_t l_604 = 65527UL;
    int32_t **l_636 = (void*)0;
    int32_t ***l_635 = &l_636;
    int32_t ****l_634 = &l_635;
    int32_t l_650 = 7L;
    struct S0 **l_654 = &l_591;
    struct S0 ***l_653 = &l_654;
    int32_t **l_661 = &l_34;
    float l_663 = 0x0.53B3EFp-58;
    uint64_t l_664 = 0UL;
    (*l_35) = (func_30(l_32) & l_32);
    if (func_37(((void*)0 == &l_36), (*l_35)))
    { /* block id: 277 */
        float l_549 = 0xD.8FB024p+35;
        for (l_36 = 0; (l_36 == 0); ++l_36)
        { /* block id: 280 */
            int32_t l_548 = 0x32BCC5FBL;
            int32_t *l_547 = &l_548;
            l_547 = &l_36;
            /* statement id: 281 */
            assert (l_547 == &l_36);
        }
        (*l_35) = ((*l_35) > (*l_35));
    }
    else
    { /* block id: 284 */
        float l_553 = 0x6.F985EDp+24;
        float *l_552 = &l_553;
        float **l_551 = &l_552;
        float ***l_550 = &l_551;
        (*l_550) = (void*)0;
        /* statement id: 285 */
        assert (l_551 == 0);
    }
    if ((((int16_t)(*l_35) >> (int16_t)(((int32_t)((((int16_t)((int16_t)(-6L) + (int16_t)(l_562 == (void*)0)) << (int16_t)15) < (*l_35)) == __builtin_parityll((*l_35))) % (int32_t)(0L || l_563)) & 0L)) == 6L))
    { /* block id: 287 */
        int32_t **l_564 = &l_34;
        int64_t l_566 = 0x9FDF000C7C49730CLL;
        float l_573 = 0xD.3B92E2p+51;
        float *l_572 = &l_573;
        (*l_35) = (l_564 != (void*)0);
        (*l_572) = (func_37((*l_35), (!l_566)) >= ((float)l_569 / (float)((*l_35) <= (((l_566 >= 0x7.676A14p-57) < l_566) >= ((((float)0x1.Bp+1 / (float)0x1.Ap+1) == 0xE.80EB57p-44) <= (*l_35))))));
    }
    else
    { /* block id: 290 */
        int32_t l_578 = 0xCA3F76A0L;
        const struct S0 l_596 = {0x46A77814C447D380LL,-52,1L,0x3750173537218091LL,255UL,0x9E66F8DE00E42C1ALL,1L,6UL};
        const struct S0 *l_595 = &l_596;
        int32_t **l_600 = (void*)0;
        float l_601 = 0x8.2p+1;
        int32_t l_602 = 0x28BE11B7L;
        uint8_t l_603 = 0xBCL;
        float **l_659 = &l_587;
        union U1 l_660 = {0x3160AA2DL};
        uint32_t l_662 = 0UL;
lbl_647:
        if (((int64_t)((int16_t)(*l_35) + (int16_t)l_578) % (int64_t)__builtin_parityll((-(uint64_t)((uint16_t)((int16_t)((int16_t)(((l_586 == &l_587) < l_578) ^ ((~l_590) & (*l_35))) >> (int16_t)(*l_35)) << (int16_t)6) + (uint16_t)(65526UL == 0xA26EL))))))
        { /* block id: 291 */
            struct S0 **l_592 = &l_591;
            int32_t l_599 = 0x5ED819B4L;
            uint32_t l_617 = 0x9AD6F3C8L;
            (*l_592) = l_591;
            (*l_35) = ((uint16_t)((l_595 == &l_596) < (((((int16_t)(18446744073709551614UL & (*l_35)) + (int16_t)(l_599 | (func_75(l_600, l_600, (((l_596.f4 & 9L) >= 18446744073709551615UL) & l_602), l_599) && l_596.f7))) >= l_599) < l_603) | 5L)) >> (uint16_t)4);
            if ((((l_596.f6 ^ l_599) <= func_30(l_599)) && (((l_604 & ((uint16_t)((*l_35) != (0UL <= __builtin_ctzl(l_596.f4))) << (uint16_t)0)) == l_599) || (*l_35))))
            { /* block id: 294 */
                int32_t **l_609 = &l_35;
                (*l_609) = &l_599;
                /* statement id: 295 */
                assert (l_35 == &l_599);
                (**l_609) = (*l_35);
            }
            else
            { /* block id: 297 */
                const uint64_t l_610 = 0x35BDD11E0BCFCA92LL;
                float **l_628 = &l_587;
                int32_t l_629 = 0x1005E6AFL;
                (**l_586) = l_610;
                (*l_35) = ((((-(uint64_t)0x8D6991E31B63B136LL) & ((l_599 || ((uint32_t)((+l_610) && ((((uint16_t)0x8D54L >> (uint16_t)14) || l_599) >= 1L)) / (uint32_t)l_617)) != (*l_35))) & (((int16_t)(!1L) >> (int16_t)9) <= l_617)) == 0xFDDF36022DEE72EELL);
                l_629 = __builtin_ffsl((l_578 < (!((uint16_t)0xF0CAL + (uint16_t)(l_599 | ((int64_t)l_617 - (int64_t)((void*)0 == l_628)))))));
                l_629 = __builtin_ffsl(((int16_t)(l_617 || __builtin_clz(l_610)) + (int16_t)(1L || (-1L))));
            }
            /* facts after branching */
            assert (l_35 == &l_602 || l_35 == &l_36 || l_35 == &l_599);
            (*l_35) = ((uint16_t)l_617 << (uint16_t)10);
        }
        else
        { /* block id: 304 */
            (**l_586) = ((void*)0 == l_634);
        }
        /* facts after branching */
        //assert (l_35 == &l_602 || l_35 == &l_36 || l_35 == dangling);
        for (l_604 = 26; (l_604 >= 19); l_604 -= 2)
        { /* block id: 309 */
            int32_t *l_639 = &l_602;
            int32_t **l_640 = &l_35;
            (*l_640) = l_639;
            /* statement id: 310 */
            assert (l_35 == &l_602);
            if (((int16_t)__builtin_clzl((**l_640)) >> (int16_t)11))
            { /* block id: 311 */
                for (l_32 = (-5); (l_32 > 7); l_32++)
                { /* block id: 314 */
                    const int32_t *l_645 = &l_36;
                    int32_t **l_646 = &l_34;
                    (**l_586) = (*l_639);
                    (*l_646) = l_645;
                    /* statement id: 316 */
                    assert (l_34 == &l_36);
                }
                (*l_640) = &l_602;
            }
            else
            { /* block id: 319 */
                uint8_t l_649 = 0xCBL;
                if (l_569)
                    goto lbl_647;
                l_650 = (-(uint64_t)l_649);
            }
        }
        (**l_659) = (__builtin_ctzl((((((uint32_t)(l_653 == &l_654) % (uint32_t)((uint32_t)l_596.f3 - (uint32_t)l_650)) > (l_596.f4 | ((int16_t)(((l_659 == (void*)0) | (func_75(func_80(l_660, l_660.f0), l_661, l_596.f2, l_662) <= l_596.f6)) < l_596.f1) - (int16_t)l_660.f1))) | l_660.f0) == 0xF59EA7C1L)) != 0x1.2p+1);
    }
    /* facts after branching */
    assert (l_34 == &l_36 || l_34 == 0);
    //assert (l_35 == &l_36 || l_35 == dangling);
    return l_664;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_30(float  p_31)
{ /* block id: 37 */
    const uint32_t l_33 = 0x18E50348L;
    return l_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_37(int32_t  p_38, uint32_t  p_39)
{ /* block id: 40 */
    int32_t l_47 = (-1L);
    int32_t *l_46 = &l_47;
    int32_t l_544 = 0x8C7CDE39L;
    if ((((int16_t)((int16_t)(((uint16_t)((l_46 == &l_47) > (&l_47 == &l_47)) - (uint16_t)((4294967295UL <= ((int32_t)((void*)0 == &l_47) - (int32_t)(&l_47 != &l_47))) | p_38)) | 0xF3922CBDL) << (int16_t)13) + (int16_t)65527UL) & 0xE16511C25C5395F8LL))
    { /* block id: 41 */
        return p_38;
    }
    else
    { /* block id: 43 */
        int32_t *l_53 = &l_47;
        float l_156 = 0x9.Ep-1;
        const int32_t l_510 = 0x223CCDCFL;
        float *l_525 = &l_156;
        for (p_38 = 19; (p_38 >= 14); --p_38)
        { /* block id: 46 */
            int32_t **l_52 = (void*)0;
            int32_t l_54 = (-3L);
            union U1 l_83 = {-10L};
            union U1 **l_520 = (void*)0;
            const union U1 **l_521 = (void*)0;
            union U1 *l_523 = &l_83;
            union U1 **l_522 = &l_523;
            float *l_524 = &l_156;
            l_53 = (void*)0;
            /* statement id: 47 */
            assert (l_53 == 0);
            (*l_46) = (1L < (0x54BA4FDAL ^ l_54));
            (*l_522) = func_55((func_61(((uint64_t)((*l_46) == 1L) % (uint64_t)p_39), func_68(p_38, (__builtin_popcount(((int16_t)func_75(func_80(l_83, func_84(func_87(&l_47), &l_53)), l_52, p_39, p_38) >> (int16_t)(*l_46))) & p_38), &l_53, p_39), &l_47, p_38) <= (*l_46)), p_39, p_39, l_510, l_510);
            /* statement id: 270 */
            assert (l_523 == 0);
            (*l_524) = p_39;
        }
        /* facts after for loop */
        assert (l_53 == 0 || l_53 == &l_47);
        (*l_525) = 0x3.EFE373p+72;
    }
    (*l_46) = (p_39 & (p_38 && (((uint32_t)((int16_t)((uint16_t)p_38 >> (uint16_t)10) - (int16_t)((int16_t)__builtin_bswap32((*l_46)) >> (int16_t)14)) / (uint32_t)((((*l_46) != ((uint32_t)(*l_46) / (uint32_t)((~(((uint16_t)(*l_46) << (uint16_t)(+((int16_t)(((2UL >= (*l_46)) >= p_38) ^ 0x128780C7L) >> (int16_t)(*l_46)))) <= l_544)) && 1L))) != p_38) | p_38)) != 7L)));
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_55(uint8_t  p_56, const float  p_57, uint32_t  p_58, const float  p_59, int16_t  p_60)
{ /* block id: 264 */
    float l_512 = 0x5.4p-1;
    float *l_511 = &l_512;
    int32_t l_513 = (-3L);
    int32_t *l_514 = &l_513;
    int32_t **l_517 = (void*)0;
    int32_t ***l_516 = &l_517;
    int32_t ****l_515 = &l_516;
    uint32_t l_518 = 0x307DE228L;
    union U1 *l_519 = (void*)0;
    (*l_511) = (-0x10.8p+1);
    l_513 = 6L;
    (*l_514) = __builtin_ctzll(p_58);
    l_518 = (l_515 == (void*)0);
    return l_519;
    /* statement id: 269 */
    //assert (func_55_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_61(uint64_t  p_62, union U1 * p_63, int32_t * p_64, uint16_t  p_65)
{ /* block id: 238 */
    const uint32_t l_473 = 6UL;
    int32_t **l_474 = (void*)0;
    const int32_t **l_506 = (void*)0;
    int32_t l_509 = (-10L);
    int32_t *l_508 = &l_509;
    int32_t **l_507 = &l_508;
    for (p_65 = 0; (p_65 > 52); p_65 += 2)
    { /* block id: 241 */
        union U1 l_466 = {-5L};
        union U1 *l_465 = &l_466;
        union U1 **l_464 = &l_465;
        const int32_t l_493 = 0x4F576CC4L;
        int32_t l_505 = 0L;
        const int32_t *l_504 = &l_505;
        (*l_464) = p_63;
        /* statement id: 242 */
        assert (l_465 == 0);
        for (l_466.f0 = (-30); (l_466.f0 == 10); l_466.f0 += 5)
        { /* block id: 245 */
            int32_t l_475 = (-8L);
            if (((uint64_t)((int64_t)(l_473 && (func_75(l_474, l_474, l_475, (+(*p_64))) > ((((int64_t)(p_62 || (((uint64_t)1UL - (uint64_t)((int16_t)((uint16_t)l_466.f2 / (uint16_t)p_62) / (int16_t)p_65)) || 7UL)) - (int64_t)(-10L)) & p_62) | p_62))) + (int64_t)p_62) - (uint64_t)l_466.f2))
            { /* block id: 246 */
                int32_t *l_486 = &l_466.f0;
                int32_t **l_485 = &l_486;
                (*l_485) = p_64;
                /* statement id: 247 */
                //assert (l_486 == &l_47);
            }
            else
            { /* block id: 248 */
                if (__builtin_parityl(((uint16_t)l_475 << (uint16_t)((uint32_t)l_475 + (uint32_t)(l_493 <= ((18446744073709551615UL ^ p_65) > ((uint64_t)((uint16_t)p_62 >> (uint16_t)__builtin_bswap64(((int16_t)((uint16_t)((int16_t)l_466.f2 / (int16_t)((__builtin_ffsll(p_65) == p_62) & (-1L))) - (uint16_t)l_466.f0) << (int16_t)5))) % (uint64_t)l_475)))))))
                { /* block id: 249 */
                    if (l_475)
                        break;
                }
                else
                { /* block id: 251 */
                    if ((*p_64))
                        break;
                }
                if ((*p_64))
                    continue;
                if ((*p_64))
                    continue;
            }
            l_504 = &l_493;
            /* statement id: 257 */
            assert (l_504 == &l_493);
            return p_62;
        }
        return p_65;
    }
    (*l_507) = p_64;
    /* statement id: 262 */
    //assert (l_508 == &l_47);
    return p_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1 * func_68(int64_t  p_69, const int32_t  p_70, int32_t ** p_71, int16_t  p_72)
{ /* block id: 84 */
    uint32_t l_161 = 0xB4CE563FL;
    uint32_t l_165 = 18446744073709551606UL;
    float l_174 = (-0x9.6p-1);
    const float *l_173 = &l_174;
    float *l_175 = (void*)0;
    struct S0 *l_186 = (void*)0;
    union U1 l_209 = {8L};
    union U1 *l_208 = &l_209;
    int32_t *l_239 = (void*)0;
    int32_t **l_238 = &l_239;
    int32_t ***l_237 = &l_238;
    int32_t ****l_236 = &l_237;
    union U1 *l_249 = &l_209;
    const int32_t *l_265 = &l_209.f0;
    union U1 *l_266 = &l_209;
    union U1 *l_267 = &l_209;
    union U1 *l_269 = &l_209;
    union U1 *l_270 = (void*)0;
    uint8_t l_388 = 0x45L;
    union U1 *l_395 = &l_209;
    union U1 *l_396 = &l_209;
    int32_t l_419 = 0x70DBA36EL;
    union U1 ****l_429 = (void*)0;
    union U1 *l_459 = &l_209;
    union U1 *l_460 = &l_209;
    union U1 *l_461 = (void*)0;
lbl_294:
    (*p_71) = (*p_71);
    if (((uint64_t)((int64_t)((0x29EE1F0013D6AA34LL | l_161) < (+p_72)) + (int64_t)((int64_t)(0x43D31FC3C61D2E95LL | l_161) % (int64_t)l_165)) - (uint64_t)(((l_165 ^ (((l_165 > ((uint64_t)(+(((int64_t)((int16_t)(l_173 != l_175) - (int16_t)p_72) - (int64_t)p_70) ^ 8L)) - (uint64_t)l_165)) && 0x564AF7E4L) | l_161)) & l_165) | 65535UL)))
    { /* block id: 86 */
        const int32_t l_183 = 0x7742FE60L;
        const int32_t *l_182 = &l_183;
        uint32_t l_222 = 0x8C29A95CL;
        union U1 *l_242 = &l_209;
        union U1 *l_245 = &l_209;
        struct S0 **l_281 = &l_186;
        int32_t l_283 = (-6L);
        uint32_t l_330 = 0x6D6BBC8EL;
        int32_t ** const l_347 = &l_239;
        union U1 *l_398 = &l_209;
        int32_t ****l_418 = &l_237;
        uint16_t l_421 = 0xE398L;
        struct S0 **l_423 = &l_186;
        for (l_165 = 9; (l_165 != 57); ++l_165)
        { /* block id: 89 */
            const int32_t l_181 = (-7L);
            const int32_t *l_180 = &l_181;
            union U1 l_207 = {0L};
            union U1 *l_206 = &l_207;
            float l_219 = 0x0.2p-1;
            const int64_t l_220 = 0xD9DD1BAEC03ACE25LL;
            int32_t *l_232 = (void*)0;
            int32_t **l_231 = &l_232;
            int32_t *** const l_230 = &l_231;
            union U1 *l_246 = &l_209;
            union U1 *l_248 = &l_207;
            union U1 *l_250 = (void*)0;
            union U1 *l_268 = &l_207;
            for (l_161 = (-27); (l_161 != 13); ++l_161)
            { /* block id: 92 */
                int16_t l_192 = 0xF030L;
                int32_t ** const l_203 = (void*)0;
                int32_t *l_223 = &l_207.f0;
                union U1 l_240 = {-5L};
                l_182 = l_180;
                /* statement id: 93 */
                assert (l_182 == &l_181);
                for (p_69 = (-30); (p_69 < (-10)); p_69++)
                { /* block id: 96 */
                    struct S0 **l_187 = &l_186;
                    int32_t * const **l_189 = (void*)0;
                    int16_t l_200 = 0x71BDL;
                    float *l_210 = &l_174;
                    (*l_187) = l_186;
                    if ((-(int64_t)l_165))
                    { /* block id: 98 */
                        (*p_71) = l_175;
                        if ((*l_180))
                            break;
                    }
                    else
                    { /* block id: 101 */
                        int32_t *l_197 = (void*)0;
                        int32_t l_202 = (-1L);
                        int32_t *l_201 = &l_202;
                        l_182 = &l_183;
                        /* statement id: 102 */
                        assert (l_182 == &l_183);
                        (*l_201) = ((((void*)0 == l_189) > __builtin_ia32_crc32qi(p_69, __builtin_ffsl(((p_69 <= (((p_70 < ((int16_t)l_192 << (int16_t)9)) ^ ((int16_t)((uint32_t)((((l_197 != (*p_71)) >= ((uint16_t)l_200 << (uint16_t)(*l_180))) & 0xB4CBD725CBBC646FLL) == 18446744073709551609UL) / (uint32_t)p_69) >> (int16_t)(*l_182))) || l_161)) < (*l_182))))) & p_70);
                    }
                    (*l_210) = ((__builtin_ctzll((*l_182)) == (func_84(l_203, p_71) != ((((float)((-0x1.8p+1) == (l_206 != l_208)) + (float)p_70) <= p_70) >= p_72))) <= 0x9.7CA1AEp-20);
                }
                /* facts after for loop */
                assert (l_182 == &l_183 || l_182 == &l_181);
                (*l_223) = (((uint32_t)(((uint16_t)((int64_t)((*l_180) > (((uint32_t)(__builtin_popcountl((*l_180)) == (p_72 ^ l_220)) - (uint32_t)(&l_207 != (void*)0)) | ((~0UL) == l_222))) % (int64_t)1L) << (uint16_t)p_72) == p_72) - (uint32_t)0x138890A1L) > l_192);
                if (((p_72 ^ (p_72 == (*l_182))) == l_161))
                { /* block id: 108 */
                    float l_224 = 0x0.FCFA09p-78;
                    int32_t l_241 = 0xFF2C6D67L;
                    union U1 *l_243 = &l_240;
                    union U1 *l_247 = &l_207;
                    if ((p_70 ^ ((((((uint16_t)l_161 << (uint16_t)p_69) & (((+((*l_180) ^ p_69)) >= p_70) <= p_70)) | ((uint64_t)(*l_180) % (uint64_t)(p_69 && (*l_182)))) != p_69) == (*l_182))))
                    { /* block id: 109 */
                        int32_t ***l_233 = &l_231;
                        union U1 *l_244 = &l_209;
                        l_233 = l_230;
                        l_241 = ((p_72 || ((((int16_t)p_72 >> (int16_t)((&l_233 == l_236) > func_84(func_80(l_240, p_69), p_71))) && 0xE22B5A8EEEFA9EDDLL) > l_241)) <= l_241);
                        return l_250;
                        /* statement id: 112 */
                        //assert (func_68_rv == 0);
                    }
                    else
                    { /* block id: 113 */
                        int16_t l_256 = 1L;
                        int32_t l_258 = 0xCFF9AFA6L;
                        l_258 = (!((float)p_72 / (float)((float)(0xE.FC4183p+81 == (l_256 != (-(float)(p_71 == &l_182)))) - (float)(p_72 != p_70))));
                    }
                    (*l_223) = (((int16_t)(((uint32_t)l_241 + (uint32_t)p_69) > ((1L ^ l_241) <= p_69)) << (int16_t)8) < func_75(func_80((*l_208), l_241), p_71, p_69, p_72));
                }
                else
                { /* block id: 117 */
                    union U1 *l_263 = (void*)0;
                    union U1 **l_264 = &l_263;
                    (*l_223) = ((((*p_71) != &l_183) != p_72) > 65530UL);
                    (*l_264) = l_263;
                }
            }
            /* facts after for loop */
            assert (l_182 == &l_183 || l_182 == &l_181);
            l_265 = &l_183;
            /* statement id: 122 */
            assert (l_265 == &l_183);
            return l_270;
            /* statement id: 123 */
            //assert (func_68_rv == 0);
        }
        for (l_165 = 0; (l_165 < 53); ++l_165)
        { /* block id: 127 */
            uint16_t l_282 = 6UL;
            struct S0 *l_303 = (void*)0;
            int32_t **l_311 = &l_239;
            union U1 l_312 = {0xCD7ECCB4L};
            const int16_t l_337 = 0x7274L;
            float *l_409 = &l_174;
            for (l_209.f0 = (-6); (l_209.f0 >= 15); l_209.f0 += 2)
            { /* block id: 130 */
                const int32_t l_277 = (-10L);
                struct S0 **l_280 = &l_186;
                int32_t *l_300 = &l_283;
                if (((int16_t)l_277 << (int16_t)(l_277 || ((int32_t)(l_280 == l_281) + (int32_t)l_277))))
                { /* block id: 131 */
                    l_283 = (l_282 > (l_277 < (*l_182)));
                }
                else
                { /* block id: 133 */
                    struct S0 l_287 = {0x416ECE8B49481C2CLL,-80,-8L,1L,4UL,0xE5E51F4D32C972F0LL,0x5FC9L,0x7AL};
                    struct S0 * const l_286 = &l_287;
                    int32_t l_296 = (-3L);
                    for (l_282 = 0; (l_282 <= 12); l_282 += 2)
                    { /* block id: 136 */
                        struct S0 l_289 = {0x073804CC397EF02ELL,64,0L,0x29A5E111E5CC7FC4LL,255UL,18446744073709551608UL,-2L,0xBDL};
                        struct S0 *l_288 = &l_289;
                        float *l_293 = &l_174;
                        union U1 **l_295 = &l_208;
                        l_288 = l_286;
                        /* statement id: 137 */
                        assert (l_288 == &l_287);
                        (*l_293) = (((!__builtin_ia32_crc32qi(((l_287.f5 < p_70) ^ 4294967295UL), ((((((void*)0 != &l_245) > 0x31FDL) > ((uint32_t)1UL % (uint32_t)__builtin_parityll(l_277))) == p_72) <= l_287.f4))) < l_287.f4) < l_287.f4);
                        if (l_282)
                            goto lbl_294;
                        (*l_295) = l_245;
                    }
                    if (p_72)
                        continue;
                    l_296 = __builtin_ctzl(((void*)0 == (*l_236)));
                }
                (*l_300) = ((int16_t)(-(uint64_t)(l_277 ^ (*l_182))) / (int16_t)0x1CC2L);
            }
            if ((((p_70 | (4294967295UL && ((int32_t)p_69 - (int32_t)p_70))) ^ p_69) | 0L))
            { /* block id: 147 */
                int32_t l_304 = 0x9680E614L;
                int32_t ****l_328 = &l_237;
                float *l_329 = &l_174;
                l_283 = (((((l_303 != (*l_281)) | (((l_304 & ((int16_t)((uint16_t)((uint32_t)p_70 + (uint32_t)func_30(l_304)) << (uint16_t)8) >> (int16_t)7)) || (*l_182)) > func_75(l_311, func_80(l_312, p_72), p_72, (*l_182)))) <= p_69) < 3UL) > l_304);
                for (l_283 = 27; (l_283 <= 5); l_283--)
                { /* block id: 151 */
                    l_304 = l_304;
                }
                (*l_329) = (p_72 >= ((float)((0x7.2p-1 > (*l_182)) < ((float)(((float)(((float)(+((float)l_312.f2 - (float)((((float)(&l_283 != (void*)0) + (float)p_69) != p_70) <= ((void*)0 == l_328)))) - (float)p_70) > l_304) - (float)0x0.64C152p-88) < (*l_182)) - (float)l_312.f2)) - (float)(*l_182)));
                l_330 = p_72;
            }
            else
            { /* block id: 156 */
                union U1 **l_334 = &l_242;
                int32_t l_336 = (-1L);
                union U1 *l_399 = (void*)0;
                const uint32_t l_402 = 0xF086C29BL;
                int32_t ****l_417 = &l_237;
                for (l_161 = (-8); (l_161 == 31); l_161++)
                { /* block id: 159 */
                    float l_335 = 0xC.7FF979p-15;
                    int32_t l_346 = 0xB923AB67L;
                    if (func_30(p_72))
                    { /* block id: 160 */
                        l_283 = p_69;
                    }
                    else
                    { /* block id: 162 */
                        union U1 ***l_333 = (void*)0;
                        l_334 = &l_269;
                        /* statement id: 163 */
                        assert (l_334 == &l_269);
                        l_335 = p_72;
                        if (l_336)
                            continue;
                        if (l_337)
                            break;
                    }
                    l_336 = (!((int32_t)((int16_t)__builtin_clzl(((+(((int32_t)l_346 + (int32_t)((*p_71) != (*p_71))) == p_72)) > ((9UL > func_84(l_347, func_80((*l_266), (((uint64_t)((int16_t)((uint64_t)((int16_t)l_346 % (int16_t)l_336) + (uint64_t)0L) >> (int16_t)3) % (uint64_t)0x8AEBAF2F5ABC4564LL) < p_69)))) < l_346))) << (int16_t)14) + (int32_t)4294967295UL));
                }
                /* facts after for loop */
                assert (l_334 == &l_269 || l_334 == &l_242);
                if (l_336)
                    continue;
                if ((l_336 <= (*l_182)))
                { /* block id: 171 */
                    uint32_t l_372 = 0xBB9A0AD2L;
                    union U1 *l_394 = &l_312;
                    union U1 *l_397 = &l_209;
                    if ((((l_336 < ((((int16_t)l_336 << (int16_t)6) > l_336) || 18446744073709551606UL)) != (-10L)) >= ((uint16_t)(p_70 | ((0x754639A9L ^ ((uint32_t)p_69 - (uint32_t)(((!((int16_t)(-(uint16_t)((uint16_t)((((int64_t)p_69 + (int64_t)l_336) >= l_336) < p_69) - (uint16_t)0L)) + (int16_t)l_336)) | (*l_182)) ^ l_372))) <= p_72)) / (uint16_t)p_69)))
                    { /* block id: 172 */
                        float *l_373 = (void*)0;
                        float *l_374 = &l_174;
                        int32_t l_375 = 0x1C69AD0FL;
                        (*l_374) = __builtin_parity(p_72);
                        if (l_375)
                            continue;
                        if (p_70)
                            break;
                        (*l_311) = (*l_347);
                    }
                    else
                    { /* block id: 177 */
                        int32_t l_387 = 0x4E4489FDL;
                        (***l_236) = (*p_71);
                        l_336 = (0x8298L ^ ((((uint16_t)p_69 >> (uint16_t)3) > ((uint64_t)l_372 - (uint64_t)((uint64_t)(((uint64_t)((-(uint16_t)((int32_t)l_387 + (int32_t)(l_388 | p_72))) <= ((uint16_t)65534UL << (uint16_t)12)) % (uint64_t)(((uint32_t)((((!0xE5496351L) < l_387) ^ l_372) < 0UL) - (uint32_t)l_387) & p_72)) == p_72) - (uint64_t)p_72))) == p_72));
                    }
                    (*l_334) = l_242;
                    return l_399;
                    /* statement id: 182 */
                    //assert (func_68_rv == 0);
                }
                else
                { /* block id: 183 */
                    (*l_347) = (void*)0;
                    (*l_347) = (*p_71);
                    for (l_312.f1 = 0; (l_312.f1 > (-20)); --l_312.f1)
                    { /* block id: 188 */
                        if (l_402)
                            break;
                    }
                    /* facts after for loop */
                                        (*p_71) = (*l_311);
                }
                /* facts after branching */
                                if (((0x87FC7DBDL && ((uint16_t)((int16_t)(0UL > ((p_72 >= (((int16_t)0xB631L % (int16_t)(*l_182)) > (l_409 == (void*)0))) >= (*l_182))) << (int16_t)(~(((int16_t)p_69 / (int16_t)l_402) == 4294967289UL))) << (uint16_t)4)) & 0xCADAEC62L))
                { /* block id: 193 */
                    uint32_t l_415 = 0x629CAE25L;
                    int32_t **l_416 = &l_239;
                    l_336 = (p_70 ^ ((int16_t)((l_415 <= (l_416 == (void*)0)) > (-10L)) + (int16_t)(l_417 == l_418)));
                    if (l_419)
                        continue;
                    if (p_69)
                    { /* block id: 196 */
                        uint64_t l_420 = 18446744073709551615UL;
                        int32_t l_422 = 0x51025829L;
                        (*l_409) = l_420;
                        l_421 = p_69;
                        l_422 = p_70;
                        if (l_422)
                            continue;
                    }
                    else
                    { /* block id: 201 */
                        (***l_236) = (*p_71);
                    }
                }
                else
                { /* block id: 204 */
                    (*l_409) = (l_423 == l_281);
                }
            }
            /* facts after branching */
                    }
    }
    else
    { /* block id: 209 */
        int64_t l_426 = 6L;
        float *l_427 = (void*)0;
        float *l_428 = &l_174;
        union U1 *****l_430 = (void*)0;
        union U1 ** const **l_432 = (void*)0;
        union U1 ** const ***l_431 = &l_432;
        union U1 *l_441 = &l_209;
        int32_t l_443 = 0xD8D166C1L;
        (*l_428) = ((float)l_426 + (float)(func_84(p_71, p_71) >= p_69));
        (*l_431) = l_429;
        (*l_428) = ((((float)(((float)((float)(__builtin_bswap32(l_426) == (__builtin_parityl(l_426) >= 0xC.DB3E03p+56)) / (float)((float)(p_72 > (l_441 == &l_209)) / (float)((-(float)(p_69 <= (-0x2.9p+1))) == l_443))) / (float)(-0x1.8p-1)) != p_69) + (float)p_70) == p_72) <= p_69);
    }
    if (p_69)
    { /* block id: 214 */
        union U1 **l_450 = &l_395;
        union U1 ***l_449 = &l_450;
        union U1 ****l_448 = &l_449;
        float *l_451 = &l_174;
        for (l_165 = 15; (l_165 < 14); l_165--)
        { /* block id: 217 */
            int32_t l_446 = (-1L);
            float *l_447 = &l_174;
            if (l_446)
                break;
            if (p_72)
                continue;
            (*l_447) = l_446;
            (**l_237) = (*p_71);
        }
        (*l_451) = (l_448 == (void*)0);
        (**l_237) = (*p_71);
    }
    else
    { /* block id: 225 */
        if ((*l_265))
        { /* block id: 226 */
            struct S0 l_455 = {0x692282C83A19E924LL,-42,9L,0x562FC40ECD9762B4LL,1UL,18446744073709551615UL,1L,255UL};
            const struct S0 *l_454 = &l_455;
            const struct S0 **l_453 = &l_454;
            const struct S0 ***l_452 = &l_453;
            (*l_452) = &l_186;
            /* statement id: 227 */
            assert (l_453 == &l_186);
        }
        else
        { /* block id: 228 */
            float *l_456 = &l_174;
            (*l_456) = p_72;
        }
        for (p_72 = 0; (p_72 != 21); ++p_72)
        { /* block id: 233 */
            (*l_238) = (*p_71);
        }
    }
    return l_461;
    /* statement id: 237 */
    //assert (func_68_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_75(int32_t ** p_76, int32_t ** p_77, uint32_t  p_78, uint8_t  p_79)
{ /* block id: 81 */
    const int32_t *l_155 = (void*)0;
    l_155 = l_155;
    return p_78;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_80(union U1  p_81, int64_t  p_82)
{ /* block id: 77 */
    int32_t l_152 = 0x4C7A7D0CL;
    int32_t *l_151 = &l_152;
    int32_t **l_153 = &l_151;
    int32_t **l_154 = (void*)0;
    (*l_153) = l_151;
    (*l_151) = p_81.f1;
    return l_154;
    /* statement id: 80 */
    //assert (func_80_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_84(int32_t ** const  p_85, int32_t ** p_86)
{ /* block id: 53 */
    int32_t l_108 = 1L;
    struct S0 l_120 = {18446744073709551615UL,65,0x5FC5L,0L,9UL,0xA496EB75E0BD005ALL,0x8589L,0x94L};
    struct S0 *l_119 = &l_120;
    float l_128 = 0x7.5p-1;
    float *l_127 = &l_128;
    int32_t *l_131 = &l_108;
    int32_t l_141 = 0xA9B0B690L;
    int32_t **l_147 = &l_131;
    int32_t ***l_146 = &l_147;
    int32_t l_150 = (-1L);
    for (l_108 = (-20); (l_108 >= 25); l_108 += 4)
    { /* block id: 56 */
        uint32_t l_113 = 0x4E5B049CL;
        float l_126 = 0x4.E417BDp-55;
        float *l_125 = &l_126;
        if (((uint16_t)l_113 << (uint16_t)5))
        { /* block id: 57 */
            int32_t **l_116 = (void*)0;
            int32_t ***l_115 = &l_116;
            int32_t ****l_114 = &l_115;
            (*l_114) = &p_86;
            /* statement id: 58 */
            assert (l_115 == &p_86);
        }
        else
        { /* block id: 59 */
            struct S0 l_118 = {0xAFEA3E439E4EAF16LL,-50,0xD67DL,0xC96EA311AD49712ALL,255UL,0UL,0x2AB4L,0x78L};
            struct S0 *l_117 = &l_118;
            l_119 = l_117;
            /* statement id: 60 */
            assert (l_119 == &l_118);
        }
        (*l_125) = (l_113 != (((float)l_120.f6 + (float)(((float)0x2.63B4A8p-62 - (float)0x5.0DB99Ep+59) >= l_113)) > l_113));
    }
    /* facts after for loop */
    //assert (l_119 == dangling || l_119 == &l_120);
    (*l_127) = 0xF.1AAC1Ep-81;
    (*l_131) = (__builtin_ffsl((((int32_t)0x8E6C6615L % (int32_t)l_120.f7) && 0UL)) | l_120.f5);
    if (((((int64_t)(((-(int64_t)((int16_t)func_30(((float)func_30((*l_131)) - (float)(*l_131))) << (int16_t)((uint16_t)(*l_131) - (uint16_t)(*l_131)))) | 0xF71EL) && (*l_131)) / (int64_t)6L) <= (*l_131)) != l_141))
    { /* block id: 66 */
        int16_t l_145 = (-2L);
        (*l_131) = (~((uint64_t)0xCA3FDCB736C1642DLL - (uint64_t)l_145));
    }
    else
    { /* block id: 68 */
        if (((void*)0 == l_146))
        { /* block id: 69 */
            int16_t l_148 = 0xBA82L;
            p_86 = p_85;
            /* statement id: 70 */
            //assert (p_86 == 0 || p_86 == &l_239 || p_86 == &l_53);
            l_148 = (**l_147);
        }
        else
        { /* block id: 72 */
            int64_t l_149 = (-1L);
            return l_149;
        }
        /* facts after branching */
        //assert (p_86 == 0 || p_86 == &l_239 || p_86 == &l_53);
    }
    /* facts after branching */
    //assert (p_86 == 0 || p_86 == &l_53 || p_86 == &l_239);
    return l_150;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** const  func_87(int32_t * p_88)
{ /* block id: 49 */
    uint64_t l_96 = 0xB45D954113837911LL;
    int32_t l_102 = 0xC2567801L;
    int32_t *l_101 = &l_102;
    float *l_103 = (void*)0;
    float l_105 = 0xA.DDD895p+97;
    float *l_104 = &l_105;
    int32_t ** const l_106 = &l_101;
    int32_t ** const l_107 = (void*)0;
    (*l_101) = (0x84D8BC89L && (((uint16_t)(!((uint16_t)((uint16_t)((0xBB77L < (((0xF2F7BD129AC07F4CLL >= l_96) < __builtin_ctzl(l_96)) | ((l_96 > ((int16_t)((uint16_t)l_96 + (uint16_t)l_96) << (int16_t)0)) < 1UL))) >= l_96) << (uint16_t)l_96) / (uint16_t)l_96)) << (uint16_t)2) == 0x1220L));
    (*l_104) = (*l_101);
    return l_107;
    /* statement id: 52 */
    //assert (func_87_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 167
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 48
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 37
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 33
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 16
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 6

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 202
   depth: 2, occurrence: 32
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 7, occurrence: 3
   depth: 11, occurrence: 1
   depth: 12, occurrence: 7
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 16, occurrence: 4
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 168

XXX times a variable address is taken: 150
XXX times a pointer is dereferenced on RHS: 81
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 70
breakdown:
   depth: 1, occurrence: 61
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 459

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 185
   level: 2, occurrence: 98
   level: 3, occurrence: 23
   level: 4, occurrence: 20
XXX number of pointers point to pointers: 76
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 29.2
XXX average alias set size: 1.12

XXX times a non-volatile is read: 604
XXX times a non-volatile is write: 201
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 179
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 28
   depth: 2, occurrence: 32
   depth: 3, occurrence: 28
   depth: 4, occurrence: 29
   depth: 5, occurrence: 29

XXX percentage a fresh-made variable is used: 13.8
XXX percentage an existing variable is used: 86.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

