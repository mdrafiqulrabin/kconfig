/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1504078505
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 19;
   unsigned f1 : 30;
   signed f2 : 9;
   signed f3 : 16;
   unsigned f4 : 1;
   signed f5 : 22;
   signed f6 : 29;
   const signed f7 : 28;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   float  f0;
   const int32_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   int32_t  f4;
   const int32_t  f5;
   float  f6;
   const int32_t  f7;
   const uint32_t  f8;
   signed f9 : 23;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
static uint16_t  func_42(int32_t * p_43, int32_t * p_44);
inline static int32_t * func_45(uint32_t  p_46, uint16_t  p_47, int32_t * p_48);
static struct S0 * const  func_49(int32_t * const  p_50, struct S0 * p_51, int32_t  p_52, uint16_t  p_53, struct S0  p_54);
static struct S0 * func_56(uint16_t  p_57, uint16_t  p_58, int32_t  p_59);
static uint32_t  func_64(struct S1  p_65, int32_t  p_66);
static struct S1  func_67(float * p_68, float * p_69, int32_t  p_70);
static float * func_73(struct S0  p_74, struct S0 * p_75);
inline static struct S0  func_76(const struct S1  p_77, struct S0  p_78);
static struct S0  func_80(const uint16_t  p_81, uint32_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    const uint32_t l_31 = 0xB3CF8132;
    float l_33 = 0x0.9p+1;
    float *l_32 = &l_33;
    int32_t l_35 = 2;
    int32_t *l_34 = &l_35;
    uint16_t l_317 = 0x4DB7;
    uint16_t l_318 = 0x9A27;
    int32_t *l_374 = &l_35;
    struct S1 l_401 = {0x8.AF4ADAp-54,0xCFAC8844,4294967295U,4294967289U,0x56BB3B64,0x98009BCF,-0x7.Cp-1,1,4294967291U,-2867};
    struct S1 ** const * const **l_429 = (void*)0;
    struct S1 *l_430 = &l_401;
    struct S0 l_437 = {248,14934,-15,6,0,945,13386,1038};
    struct S0 *l_436 = &l_437;
    struct S0 **l_435 = &l_436;
    float l_448 = 0xC.F369EBp+36;
    uint16_t l_481 = 65535U;
    int16_t l_493 = 0xAE37;
    uint16_t l_530 = 0U;
    (*l_32) = l_31;
    l_34 = l_32;
    /* statement id: 38 */
    assert (l_34 == &l_33);
    return l_530;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_42(int32_t * p_43, int32_t * p_44)
{ /* block id: 177 */
    int32_t l_301 = 2;
    struct S0 l_307 = {722,32612,7,85,0,942,-12079,9685};
    struct S0 *l_306 = &l_307;
    int16_t l_308 = 0;
    struct S1 l_309 = {0x3.D9BBE0p+90,1,0x18705D8A,0xD4656157,-1,-1,0x5.Bp+1,0x14903292,0x47F08E5E,2625};
    int32_t *l_315 = &l_301;
    uint32_t l_316 = 7U;
    l_301 = ((((l_301 > ((int16_t)6 >> (int16_t)6)) == (((int16_t)(l_306 == (void*)0) >> (int16_t)8) | __builtin_ctzl(l_301))) <= l_308) >= l_301);
    (*p_44) = func_64(l_309, ((~((int16_t)((int32_t)func_64(l_309, l_309.f5) % (int32_t)(l_309.f5 ^ func_64(l_309, l_301))) << (int16_t)5)) && l_307.f3));
    l_315 = l_315;
    return l_316;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_45(uint32_t  p_46, uint16_t  p_47, int32_t * p_48)
{ /* block id: 39 */
    int32_t * const l_55 = (void*)0;
    struct S0 l_61 = {352,19979,-20,-35,0,-700,-20332,13597};
    struct S0 *l_60 = &l_61;
    float l_72 = 0x2.1F9C85p+28;
    float *l_71 = &l_72;
    const struct S1 l_79 = {0x1.3p+1,0x040D4F66,4294967288U,1U,0x2E55FDCF,0x1F6B071C,0xB.04CDE8p+29,0x5D465C30,4294967291U,-2587};
    struct S0 **l_297 = &l_60;
    int32_t l_300 = 0;
    int32_t *l_299 = &l_300;
    int32_t **l_298 = &l_299;
    (*l_297) = func_49(l_55, func_56((p_47 == (l_60 == (void*)0)), p_46, (((int16_t)((func_64(func_67(l_71, func_73(func_76(l_79, func_80(p_46, (((uint32_t)(l_79.f3 >= (*p_48)) + (uint32_t)l_61.f0) || 9))), &l_61), p_46), p_46) <= 0x6D5C7E7E) ^ 0) % (int16_t)2) != 0xCBE9)), (*p_48), l_79.f7, (*l_60));
    /* statement id: 173 */
    assert (l_60 == 0);
    (*l_298) = func_73(l_61, (*l_297));
    /* statement id: 174 */
    assert (l_299 == 0);
    (*l_298) = p_48;
    /* statement id: 175 */
    //assert (l_299 == &l_35 || l_299 == &l_364 || l_299 == &l_33);
    return p_48;
    /* statement id: 176 */
    //assert (func_45_rv == &l_35 || func_45_rv == &l_364 || func_45_rv == &l_33);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * const  func_49(int32_t * const  p_50, struct S0 * p_51, int32_t  p_52, uint16_t  p_53, struct S0  p_54)
{ /* block id: 160 */
    int32_t l_271 = 1;
    int32_t ***l_272 = (void*)0;
    int32_t l_274 = 0x33A07E61;
    int32_t *l_273 = &l_274;
    struct S1 l_284 = {-0x7.7p-1,0,0x001CB27D,2U,1,8,-0x9.Dp-1,0x9B1B65E9,5U,-828};
    struct S0 l_289 = {415,32078,-14,26,0,518,-4224,-10896};
    struct S0 * const l_288 = &l_289;
    struct S0 * const l_290 = &l_289;
    struct S0 * const l_291 = &l_289;
    struct S0 * const l_292 = &l_289;
    struct S0 * const l_293 = &l_289;
    struct S0 * const l_294 = &l_289;
    struct S0 * const l_295 = &l_289;
    struct S0 * const l_296 = (void*)0;
    (*l_273) = __builtin_clzll(((int32_t)(((uint16_t)((uint16_t)l_271 - (uint16_t)l_271) << (uint16_t)5) | l_271) + (int32_t)(l_272 == (void*)0)));
    for (l_271 = 0; (l_271 == (-26)); l_271--)
    { /* block id: 164 */
        uint32_t l_279 = 1U;
        for (l_274 = 0; (l_274 > 12); l_274++)
        { /* block id: 167 */
            float l_280 = 0x8.88F8E8p+6;
            float l_281 = (-0x6.6p-1);
            float *l_287 = &l_280;
            (*l_287) = ((l_279 == ((l_280 < (l_281 < (((float)(p_54.f7 < func_64(l_284, ((int32_t)(p_54.f1 > __builtin_ffs(p_54.f7)) + (int32_t)l_279))) + (float)0x1.3p-1) < l_279))) > 0x8.B0A0F0p-4)) != 0x1.3p-1);
            if (l_279)
                break;
        }
    }
    return l_296;
    /* statement id: 172 */
    //assert (func_49_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_56(uint16_t  p_57, uint16_t  p_58, int32_t  p_59)
{ /* block id: 157 */
    int32_t *l_261 = (void*)0;
    int32_t **l_260 = &l_261;
    struct S0 l_263 = {383,15536,15,203,0,1791,-6470,-13552};
    struct S0 *l_262 = &l_263;
    struct S0 *l_264 = (void*)0;
    (*l_260) = &p_59;
    /* statement id: 158 */
    assert (l_261 == &p_59);
    return l_264;
    /* statement id: 159 */
    //assert (func_56_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_64(struct S1  p_65, int32_t  p_66)
{ /* block id: 154 */
    int32_t l_257 = 0x15459EB2;
    int32_t *l_256 = &l_257;
    int32_t **l_255 = &l_256;
    float l_259 = (-0x4.Ep+1);
    float *l_258 = &l_259;
    (*l_258) = ((-0x1.3p+1) == ((l_255 != &l_256) < 0xA.2DFBD6p-72));
    return p_65.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_67(float * p_68, float * p_69, int32_t  p_70)
{ /* block id: 140 */
    struct S1 * const l_231 = (void*)0;
    struct S1 l_234 = {-0x2.4p-1,0x4161C9AC,0x293EDD8F,4294967288U,0x6764A772,0,0xA.06CC4Ap-94,-1,0U,80};
    struct S1 *l_233 = &l_234;
    struct S1 **l_232 = &l_233;
    (*p_68) = ((*p_68) != ((float)((float)(*p_68) + (float)0x5.29661Ap-8) - (float)(0x1.5p-1 != 0x1.968E6Cp-97)));
    (*l_232) = l_231;
    /* statement id: 142 */
    assert (l_233 == 0);
    for (l_234.f2 = (-8); (l_234.f2 >= 20); l_234.f2 += 3)
    { /* block id: 145 */
        uint32_t l_241 = 0x653981A4;
        struct S1 l_252 = {0xB.2D2773p+48,0x8BA22E2F,0xD0092667,0x26E32850,0xD9A1DD2A,-8,0x0.Ep+1,0x5FBA784E,0xF444ABC4,-1498};
        if (((((int32_t)(((uint32_t)l_241 % (uint32_t)p_70) >= (+(0x6DEBD74A < (((int16_t)(~p_70) - (int16_t)((uint32_t)(((uint16_t)l_241 >> (uint16_t)10) <= (((0 > (4294967295U > (0xC6A0BBF4 != ((uint16_t)l_234.f8 >> (uint16_t)p_70)))) > 0x0B6BBA22) & p_70)) + (uint32_t)1U)) == l_234.f8)))) - (int32_t)l_234.f8) != p_70) > (-3)))
        { /* block id: 146 */
            return l_252;
        }
        else
        { /* block id: 148 */
            struct S1 ***l_253 = &l_232;
            struct S1 ****l_254 = &l_253;
            (*l_254) = l_253;
            if (p_70)
                continue;
        }
    }
    return l_234;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_73(struct S0  p_74, struct S0 * p_75)
{ /* block id: 45 */
    int32_t l_90 = (-2);
    int32_t l_92 = (-5);
    int32_t *l_91 = &l_92;
    int32_t *l_114 = &l_92;
    float *l_156 = (void*)0;
    float l_204 = 0x8.B12384p-40;
    float *l_203 = &l_204;
    float *l_206 = &l_204;
    float *l_210 = &l_204;
    struct S1 l_220 = {0x1.5p-1,-2,0U,0x14CF4170,0xD98822D3,0x8E9FEB48,0x1.FF9ED6p-61,1,0xA1571C5A,675};
    struct S1 *l_219 = &l_220;
    float *l_224 = &l_220.f0;
    float *l_225 = &l_220.f6;
    float *l_226 = (void*)0;
    if ((-(uint32_t)(l_90 || p_74.f7)))
    { /* block id: 46 */
        int32_t *l_93 = &l_92;
        int32_t l_102 = (-5);
        int16_t l_103 = 1;
        float l_108 = 0x5.335DC6p-50;
        float *l_107 = &l_108;
        float *l_109 = (void*)0;
        struct S1 *l_152 = (void*)0;
        float **l_159 = &l_107;
        l_93 = l_91;
        if (((uint16_t)((((*l_93) | (0xF5C31AFC <= (0x2F8F & (((((uint16_t)p_74.f4 - (uint16_t)p_74.f7) >= (p_74.f4 < p_74.f7)) == ((uint16_t)0xC24A - (uint16_t)(((uint16_t)l_102 << (uint16_t)15) | (*l_91)))) && p_74.f2)))) & 7U) || l_103) << (uint16_t)(*l_91)))
        { /* block id: 48 */
            int16_t l_104 = 0x41CA;
            (*l_91) = ((p_74.f6 < p_74.f6) == (0x6C82 | __builtin_popcount(l_104)));
        }
        else
        { /* block id: 50 */
            float l_106 = 0x0.Ap+1;
            float *l_105 = &l_106;
            return l_109;
            /* statement id: 51 */
            //assert (func_73_rv == 0);
        }
        if (__builtin_ffsll(p_74.f5))
        { /* block id: 53 */
            float l_111 = 0x2.BB0BE5p-90;
            int32_t *l_121 = &l_102;
lbl_126:
            (*l_107) = ((-0x1.Bp+1) < (p_74.f7 == ((+((*l_93) != 0x1.4p+1)) >= p_74.f3)));
            if ((*l_91))
            { /* block id: 55 */
                int32_t **l_124 = &l_93;
                int16_t l_125 = (-1);
                const uint32_t l_149 = 0xFFA464F1;
                struct S1 l_155 = {0x7.188A16p-8,0x6A680CA0,0x949183CB,0xD9AA0F79,0,-7,0x1.8FE639p-90,0x19F66274,0U,-1351};
                struct S1 *l_154 = &l_155;
                if ((*l_91))
                { /* block id: 56 */
                    int32_t *l_116 = &l_92;
                    for (l_102 = 0; (l_102 >= 7); l_102 += 1)
                    { /* block id: 59 */
                        int32_t **l_115 = (void*)0;
                        l_116 = l_114;
                        (*l_93) = p_74.f5;
                    }
                }
                else
                { /* block id: 63 */
                    int32_t *l_119 = &l_102;
                    for (l_103 = (-20); (l_103 != 16); l_103 += 9)
                    { /* block id: 66 */
                        int32_t *l_120 = &l_102;
                        int32_t **l_122 = (void*)0;
                        int32_t **l_123 = &l_119;
                        l_120 = l_119;
                        (*l_123) = l_121;
                    }
                    (*l_119) = (l_124 != l_124);
                }
                if ((__builtin_bswap32(l_125) ^ (__builtin_bswap32(p_74.f1) >= 0x3854)))
                { /* block id: 72 */
                    int32_t l_128 = 0xAF3587EA;
                    if (l_125)
                        goto lbl_126;
                    (*l_107) = ((+l_128) > (((*l_124) != (*l_124)) != (*l_121)));
                }
                else
                { /* block id: 75 */
                    int32_t l_144 = 0x204CE78B;
                    for (l_102 = (-8); (l_102 >= (-24)); --l_102)
                    { /* block id: 78 */
                        struct S0 l_134 = {612,640,-5,217,0,-1657,-17454,-12533};
                        struct S0 *l_133 = &l_134;
                        struct S0 **l_132 = &l_133;
                        struct S0 ***l_131 = &l_132;
                        int32_t *l_135 = &l_92;
                        (*l_131) = &p_75;
                        /* statement id: 79 */
                        assert (l_132 == &p_75);
                        (*l_124) = l_135;
                        (*l_107) = ((((float)((float)__builtin_parityll(p_74.f5) + (float)(*l_93)) - (float)(0xE.861EEEp-48 > (+(((+0x0.9p+1) != ((float)(0xC.4AAA59p+70 == l_144) - (float)((float)(((float)(p_74.f1 != (*l_93)) - (float)(*l_93)) < (*l_121)) + (float)0x7.B70BD8p-10))) >= p_74.f0)))) < 0x7.41A9C4p+92) > l_149);
                    }
                }
                for (l_102 = (-1); (l_102 >= 8); ++l_102)
                { /* block id: 86 */
                    struct S1 **l_153 = (void*)0;
                    l_154 = l_152;
                    /* statement id: 87 */
                    assert (l_154 == 0);
                    l_121 = &l_102;
                    (**l_124) = (*l_121);
                    if ((**l_124))
                        break;
                }
                /* facts after for loop */
                assert (l_154 == 0 || l_154 == &l_155);
            }
            else
            { /* block id: 92 */
                return l_156;
                /* statement id: 93 */
                //assert (func_73_rv == 0);
            }
            l_91 = (void*)0;
            /* statement id: 95 */
            assert (l_91 == 0);
            for (l_103 = 0; (l_103 >= 6); l_103 += 7)
            { /* block id: 98 */
                float ***l_160 = (void*)0;
                float ***l_161 = (void*)0;
                float ***l_162 = &l_159;
                int32_t *l_163 = (void*)0;
                int32_t **l_164 = &l_91;
                (*l_162) = l_159;
                (**l_159) = p_74.f6;
                (*l_164) = l_163;
                /* statement id: 101 */
                assert (l_91 == 0);
                for (l_90 = 0; (l_90 == 6); l_90 += 7)
                { /* block id: 104 */
                    const uint32_t l_169 = 0x52912ABF;
                    float *l_179 = &l_111;
                    p_74.f5 = (-1);
                    if ((0xF14FE5D6 <= (*l_93)))
                    { /* block id: 106 */
                        int32_t l_170 = (-6);
                        int32_t l_172 = (-1);
                        float *l_180 = &l_111;
                        float *l_181 = (void*)0;
                        l_172 = ((float)(l_169 == ((((p_74.f5 == (*l_121)) != (0xF.3489FCp-41 <= l_170)) <= 0x1.0p+1) > (+0x6.253C71p-16))) + (float)0x1.0p+1);
                        (*l_107) = ((float)((float)(0x0.4D8994p+29 != 0x6.3E80CAp-64) + (float)__builtin_clz((((*l_114) != l_169) < ((uint32_t)p_74.f0 - (uint32_t)p_74.f7)))) + (float)l_170);
                        return l_181;
                        /* statement id: 109 */
                        //assert (func_73_rv == 0);
                    }
                    else
                    { /* block id: 110 */
                        int32_t *l_182 = &l_102;
                        if ((*l_121))
                            break;
                        (*l_179) = p_74.f5;
                        (*l_164) = l_182;
                        /* statement id: 113 */
                        assert (l_91 == &l_102);
                    }
                    /* facts after branching */
                    assert (l_91 == &l_102);
                }
                /* facts after for loop */
                assert (l_91 == &l_102 || l_91 == 0);
            }
            /* facts after for loop */
            assert (l_91 == &l_102 || l_91 == 0);
        }
        else
        { /* block id: 117 */
            return l_156;
            /* statement id: 118 */
            //assert (func_73_rv == 0);
        }
        /* facts after branching */
        assert (l_91 == &l_102 || l_91 == 0);
        for (l_90 = (-24); (l_90 < 19); l_90++)
        { /* block id: 122 */
            uint32_t l_187 = 1U;
            struct S1 **l_192 = &l_152;
            int32_t ***l_193 = (void*)0;
            int32_t ****l_194 = (void*)0;
            int32_t ****l_195 = &l_193;
            (*l_114) = (4294967292U ^ p_74.f3);
            (*l_93) = ((uint16_t)l_187 + (uint16_t)(((int16_t)p_74.f4 + (int16_t)l_187) && ((&l_102 != &l_92) <= ((uint16_t)(l_192 != l_192) + (uint16_t)((*l_93) <= p_74.f0)))));
            (*l_195) = l_193;
        }
    }
    else
    { /* block id: 127 */
        int16_t l_199 = 1;
        float *l_205 = &l_204;
        float *l_207 = &l_204;
        float *l_208 = &l_204;
        float *l_209 = &l_204;
        float *l_211 = (void*)0;
        int32_t l_217 = 1;
        struct S1 l_222 = {0x5.2p+1,1,0xBE9D1110,0xA14F9FC2,-1,0xE879045E,0x0.9p+1,0xA8856AFF,0x7C1CD0E7,-920};
        struct S1 *l_221 = &l_222;
        if ((0xF3710615 == (!(0xB74624C0 < (l_199 > p_74.f0)))))
        { /* block id: 128 */
            float l_201 = (-0x1.4p-1);
            float *l_200 = &l_201;
            float *l_202 = &l_201;
            return l_211;
            /* statement id: 129 */
            //assert (func_73_rv == 0);
        }
        else
        { /* block id: 130 */
            float *l_216 = &l_204;
            int32_t *l_218 = (void*)0;
            l_217 = ((int16_t)(((int16_t)(l_211 != l_216) << (int16_t)15) == p_74.f7) + (int16_t)p_74.f1);
            l_218 = l_216;
            /* statement id: 132 */
            assert (l_218 == &l_204);
        }
        if (p_74.f6)
            goto lbl_223;
        l_221 = l_219;
        /* statement id: 134 */
        assert (l_221 == &l_220);
    }
    /* facts after branching */
    //assert (l_91 == &l_92 || l_91 == dangling || l_91 == 0);
lbl_223:
    (*l_114) = p_74.f5;
    l_114 = &l_92;
    return l_226;
    /* statement id: 139 */
    //assert (func_73_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_76(const struct S1  p_77, struct S0  p_78)
{ /* block id: 43 */
    struct S0 l_88 = {223,28235,-8,-104,0,-1367,-8453,-11418};
    return l_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_80(const uint16_t  p_81, uint32_t  p_82)
{ /* block id: 40 */
    struct S0 *l_86 = (void*)0;
    struct S0 **l_85 = &l_86;
    struct S0 l_87 = {297,14905,-13,110,0,-1596,-1837,1063};
    l_85 = l_85;
    return l_87;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 167
   depth: 1, occurrence: 13
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 50
breakdown:
   indirect level: 0, occurrence: 13
   indirect level: 1, occurrence: 26
   indirect level: 2, occurrence: 5
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 1
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 6
breakdown:
   indirect level: 0, occurrence: 6
XXX times a bitfields struct's address is taken: 27
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 47

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 15
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 5
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 18, occurrence: 1
   depth: 29, occurrence: 1

XXX total number of pointers: 159

XXX times a variable address is taken: 138
XXX times a pointer is dereferenced on RHS: 89
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 75
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 339

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 973
   level: 2, occurrence: 102
   level: 3, occurrence: 3
   level: 4, occurrence: 1
XXX number of pointers point to pointers: 60
XXX number of pointers point to scalars: 64
XXX number of pointers point to structs: 35
XXX percent of pointers has null in alias set: 34.6
XXX average alias set size: 1.29

XXX times a non-volatile is read: 528
XXX times a non-volatile is write: 204
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 4

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 9
   depth: 2, occurrence: 18
   depth: 3, occurrence: 8
   depth: 4, occurrence: 12
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

