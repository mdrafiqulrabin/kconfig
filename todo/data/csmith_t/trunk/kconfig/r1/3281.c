/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2772838583
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 26;
   signed f1 : 9;
   unsigned f2 : 8;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int32_t  f0;
   signed f1 : 4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_5 = (-1);
static int16_t g_31 = 0xB151;
static struct S0 g_100 = {4315,16,3};
static int32_t g_214 = 4;
static struct S1 g_218 = {0,-1};
static int32_t g_225 = 0x5E56E321;
static struct S0 g_252 = {7754,9,3};
static int32_t g_341 = 0x94A56F00;
static struct S1 g_365 = {0x4712241E,-2};
static struct S0 g_456 = {2178,8,10};
static struct S0 g_616 = {6527,-4,7};


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_26(void);
static int32_t  func_64(int16_t  p_65, struct S1  p_66, uint16_t  p_67, int32_t  p_68);
static int32_t  func_72(int16_t  p_73, int16_t  p_74);
static uint32_t  func_75(int16_t  p_76, int32_t  p_77, uint32_t  p_78, uint16_t  p_79);
static int32_t  func_86(struct S1  p_87);
static struct S1  func_88(struct S0  p_89);
static struct S0  func_90(struct S1  p_91, struct S1  p_92);
static int32_t  func_98(struct S0  p_99);
static int16_t  func_101(int32_t  p_102, int32_t  p_103);
static int32_t  func_104(uint32_t  p_105, struct S1  p_106, struct S1  p_107, int32_t  p_108);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_31 g_100 g_214 g_225 g_218.f0 g_218.f1 g_218 g_252.f0 g_252.f1 g_252.f2 g_252 g_341 g_365 g_456 g_616
 * writes: g_5 g_31 g_100 g_214 g_218 g_252 g_225 g_456 g_341 g_365.f0 g_365.f1 g_365 g_616
 */
static uint32_t  func_26(void)
{ /* block id: 36 */
    int32_t l_29 = 0x83648BD9;
    struct S1 l_297 = {-1,-0};
    struct S0 l_645 = {6244,2,2};
    struct S1 l_715 = {-1,0};
    uint32_t l_747 = 0xD078B47E;
    uint32_t l_766 = 0xDC5D2359;
    int32_t l_780 = (-2);
    for (g_5 = 0; (g_5 >= (-11)); g_5 -= 7)
    { /* block id: 39 */
        uint16_t l_30 = 65532U;
        uint32_t l_60 = 4U;
        int16_t l_61 = 0;
        g_31 = ((g_5 != l_29) && l_30);
        l_29 = ((uint32_t)(l_30 & (g_5 != ((((uint16_t)(-(uint16_t)(g_31 != ((uint16_t)(((uint16_t)0x922A + (uint16_t)(!((int16_t)(-(int16_t)((-7) != ((int32_t)((uint16_t)((int16_t)(((uint16_t)(0x3E2E1665 < (-(int16_t)(0xFD8B == ((uint16_t)((uint32_t)1U - (uint32_t)((uint16_t)0xD2BB << (uint16_t)g_5)) % (uint16_t)(-1))))) << (uint16_t)g_31) >= l_29) << (int16_t)l_60) >> (uint16_t)g_5) + (int32_t)g_5))) + (int16_t)l_61))) > g_31) >> (uint16_t)7))) + (uint16_t)l_60) >= 0x389E7675) | l_61))) + (uint32_t)l_29);
    }
    for (l_29 = 0; (l_29 != (-28)); l_29 -= 7)
    { /* block id: 45 */
        uint32_t l_290 = 0U;
        uint32_t l_623 = 0x8122E100;
        struct S1 l_624 = {0x2D405FEC,-0};
        uint16_t l_625 = 9U;
        int16_t l_627 = 0;
        uint32_t l_642 = 4294967295U;
        uint16_t l_765 = 65530U;
        uint32_t l_767 = 0xC8EE22A4;
        l_297.f1 = func_64((((int16_t)(-(int16_t)(func_72(g_5, g_31) >= (((uint32_t)func_101(l_290, ((((uint16_t)(((int16_t)0xC324 << (int16_t)l_29) || l_290) % (uint16_t)((uint32_t)(func_101(l_29, g_5) <= 0xB50A315F) + (uint32_t)l_29)) && 0x1092) & l_290)) - (uint32_t)g_5) || 0x5BDF))) % (int16_t)l_290) > 4U), l_297, l_297.f0, l_29);
        if (((l_297.f0 || ((0xD2D0972F & (4294967286U <= ((int16_t)((1 & (((int16_t)(g_341 || ((((int16_t)(g_365.f1 <= ((l_623 & l_297.f1) || func_86(l_624))) << (int16_t)6) && l_625) != 0x6F1327C7)) + (int16_t)l_624.f0) < g_100.f0)) > 0U) % (int16_t)g_456.f2))) != g_252.f1)) == 0xCD4F23D3))
        { /* block id: 367 */
            uint32_t l_626 = 0x10497F24;
            struct S1 l_641 = {0x472BA82D,3};
            int16_t l_681 = 1;
            struct S0 l_771 = {2086,-20,0};
            l_297.f1 = (((65531U <= l_626) >= 0x44BB) > l_627);
            if (((int16_t)func_98(func_90(g_365, g_218)) >> (int16_t)8))
            { /* block id: 369 */
                uint16_t l_630 = 0x250C;
                int32_t l_635 = 0x096B5A8A;
                struct S0 l_649 = {6306,-11,7};
                struct S1 l_658 = {6,-0};
                int32_t l_664 = 0xFA50F087;
                g_365.f0 = l_630;
                l_635 = ((int16_t)(((int32_t)0xC59AD477 % (int32_t)0x9E77E910) <= l_627) << (int16_t)12);
                if ((((~((l_635 && 1U) == ((int32_t)g_252.f2 + (int32_t)g_5))) >= (0x2C50 <= (func_104((((((int16_t)g_218.f1 << (int16_t)0) != 0xFF43) | l_290) || ((l_29 ^ 0x0F989D59) >= 4294967295U)), l_624, l_641, g_252.f1) & l_642))) | 4294967295U))
                { /* block id: 372 */
                    uint32_t l_646 = 4294967286U;
                    for (g_218.f0 = (-11); (g_218.f0 != 29); g_218.f0 += 2)
                    { /* block id: 375 */
                        l_645 = g_100;
                    }
                    if (((__builtin_ctz(l_646) == (((func_75(g_341, l_646, l_641.f0, ((4294967291U | (g_252.f2 != (g_218.f0 == (0xEFCE818B > l_626)))) == 0xFEEAED3E)) != l_625) || 4294967295U) & l_646)) > g_365.f1))
                    { /* block id: 378 */
                        struct S1 l_647 = {1,2};
                        struct S0 l_648 = {3437,15,10};
                        l_648 = func_90(l_647, func_88(func_90(func_88(g_100), g_365)));
                        if (g_616.f2)
                            continue;
                    }
                    else
                    { /* block id: 381 */
                        g_616 = l_649;
                    }
                    g_225 = (-1);
                    if (((uint16_t)((uint16_t)(g_616.f1 > ((uint32_t)(!(~g_365.f0)) + (uint32_t)(l_624.f1 > g_5))) << (uint16_t)11) >> (uint16_t)(l_646 != (func_104(l_297.f0, g_365, l_658, g_252.f2) < g_252.f2))))
                    { /* block id: 385 */
                        return g_100.f1;
                    }
                    else
                    { /* block id: 387 */
                        int32_t l_659 = (-1);
                        if (g_456.f1)
                            break;
                        g_100.f1 = g_100.f1;
                        return l_659;
                    }
                }
                else
                { /* block id: 392 */
                    struct S1 l_661 = {0x91F970A8,-2};
                    int32_t l_680 = (-1);
                    l_624.f1 = (-(uint16_t)g_252.f2);
                    if (g_214)
                        break;
                    l_661 = g_218;
                    if (l_626)
                    { /* block id: 396 */
                        uint32_t l_665 = 4294967295U;
                        l_664 = ((int16_t)l_297.f1 % (int16_t)l_297.f0);
                        l_624.f0 = (l_665 <= ((int32_t)((uint16_t)__builtin_popcountl(g_225) - (uint16_t)((~(-(uint32_t)(((g_341 != (g_100.f0 != ((0xC148C86C > (((int32_t)(-(uint32_t)g_214) + (int32_t)0xB65666A6) > l_658.f0)) || l_626))) <= g_456.f0) ^ l_649.f1))) != l_661.f0)) % (int32_t)g_616.f0));
                        l_681 = ((((__builtin_ctzll((g_252.f0 ^ g_100.f1)) & ((uint32_t)((int16_t)(g_365.f1 & ((-3) | (((((-(uint32_t)l_658.f0) != (func_101(l_665, ((l_665 & ((l_665 == l_665) > g_252.f2)) && g_214)) || g_225)) && 0x489F) != l_680) == 0U))) >> (int16_t)l_661.f0) - (uint32_t)l_625)) >= g_616.f2) <= 0x6132A060) == l_290);
                    }
                    else
                    { /* block id: 400 */
                        l_661.f0 = l_661.f0;
                    }
                }
                for (l_626 = 0; (l_626 != 48); l_626 += 4)
                { /* block id: 406 */
                    uint32_t l_690 = 0xA496D26E;
                    for (g_365.f0 = 0; (g_365.f0 >= (-4)); g_365.f0 -= 1)
                    { /* block id: 409 */
                        l_641.f1 = ((func_86(g_365) == ((uint16_t)((uint32_t)l_690 + (uint32_t)((int16_t)(l_626 == __builtin_popcountll(((int16_t)g_616.f2 << (int16_t)(__builtin_ia32_crc32qi(l_641.f0, ((int16_t)((uint32_t)(5 < 65534U) - (uint32_t)l_649.f0) << (int16_t)3)) != g_252.f2)))) + (int16_t)l_645.f1)) >> (uint16_t)l_690)) > g_100.f0);
                        g_365.f1 = 0xF2895640;
                        g_456.f1 = (g_252.f2 < (((uint16_t)0U >> (uint16_t)12) | g_100.f2));
                        if (g_456.f0)
                            break;
                    }
                    l_641.f0 = g_341;
                    l_297.f0 = ((uint16_t)((-(int16_t)(((int32_t)g_616.f2 % (int32_t)l_641.f0) != ((uint16_t)((uint32_t)l_630 - (uint32_t)g_365.f0) >> (uint16_t)__builtin_bswap64((l_649.f1 == (func_75(g_616.f2, ((uint32_t)l_290 % (uint32_t)g_100.f2), (~__builtin_parityll((((0x1F37 == g_218.f1) & 0xA57E) & l_690))), l_624.f0) & l_624.f0)))))) == 0x16449315) - (uint16_t)l_642);
                }
            }
            else
            { /* block id: 418 */
                int16_t l_716 = 1;
                int16_t l_727 = 0xF34A;
                struct S1 l_738 = {0,-3};
                struct S0 l_748 = {3072,2,0};
                for (g_218.f0 = 0; (g_218.f0 > (-22)); g_218.f0 -= 1)
                { /* block id: 421 */
                    l_624 = l_715;
                }
                g_365.f0 = l_716;
                if ((1 != (((((uint16_t)((l_716 <= (l_625 & ((uint16_t)65534U + (uint16_t)(func_98(l_645) <= ((uint32_t)0x439D89A8 % (uint32_t)l_297.f1))))) | g_214) % (uint16_t)4U) == l_645.f1) | g_252.f2) & 0xBAE08723)))
                { /* block id: 425 */
                    uint32_t l_741 = 0xD83F1305;
                    struct S0 l_749 = {4386,2,5};
                    if (((g_616.f0 != g_214) != ((uint16_t)65535U << (uint16_t)g_5)))
                    { /* block id: 426 */
                        l_624.f0 = (((g_616.f2 > ((func_98(g_252) | (((int32_t)func_86(l_624) % (int32_t)(0x10E1 & __builtin_clz(((l_715.f1 || 1U) <= l_727)))) < 65531U)) == g_456.f2)) ^ g_5) & l_727);
                        g_456.f1 = (((uint16_t)(__builtin_ffs(((int16_t)((int32_t)g_456.f1 + (int32_t)func_104(((int32_t)l_645.f2 % (int32_t)((int16_t)g_31 >> (int16_t)4)), l_738, g_218, l_627)) >> (int16_t)12)) & l_623) >> (uint16_t)l_645.f0) > g_341);
                        g_225 = g_616.f1;
                        g_218.f1 = (l_623 | g_214);
                    }
                    else
                    { /* block id: 431 */
                        int32_t l_746 = 0x9F3EDF89;
                        g_456.f1 = ((((uint16_t)l_741 >> (uint16_t)((int16_t)(((uint16_t)(4294967294U ^ 7U) % (uint16_t)(((l_746 & ((g_214 || __builtin_bswap32(g_365.f0)) | (l_738.f0 > (g_616.f0 && l_681)))) ^ l_747) && l_741)) != l_715.f1) << (int16_t)l_625)) < l_624.f1) || l_642);
                        if (g_100.f1)
                            break;
                        l_748 = g_456;
                        if (l_29)
                            continue;
                    }
                    l_749 = l_748;
                    l_624.f1 = l_626;
                }
                else
                { /* block id: 439 */
                    struct S1 l_770 = {0x6A40415E,2};
                    struct S0 l_772 = {2313,21,14};
                    for (g_31 = 0; (g_31 < 10); g_31 += 6)
                    { /* block id: 442 */
                        uint16_t l_759 = 0x7507;
                        g_100.f1 = ((int16_t)((uint16_t)(((0x4794C94E & g_218.f0) | (((~((int16_t)l_759 >> (int16_t)4)) || ((int16_t)((((uint16_t)((0x6B21 == (!g_100.f0)) | (g_5 ^ (-6))) % (uint16_t)func_101(g_456.f1, g_225)) & l_765) <= (-5)) << (int16_t)l_759)) ^ l_759)) || l_766) - (uint16_t)(-3)) << (int16_t)l_759);
                        l_767 = g_100.f2;
                        g_616.f1 = 1;
                    }
                    for (g_214 = 0; (g_214 == 13); g_214 += 1)
                    { /* block id: 449 */
                        l_771 = func_90(l_770, g_218);
                        l_645 = l_772;
                    }
                }
                for (l_297.f0 = 0; (l_297.f0 >= (-3)); l_297.f0 -= 3)
                { /* block id: 456 */
                    l_645 = func_90(g_365, g_365);
                }
            }
        }
        else
        { /* block id: 460 */
            uint16_t l_779 = 0xBE9B;
            l_624.f1 = g_100.f2;
            l_624.f0 = ((uint32_t)(l_747 & ((uint16_t)g_456.f0 + (uint16_t)g_225)) - (uint32_t)l_29);
            l_780 = l_779;
            g_616.f1 = g_218.f1;
        }
    }
    return l_297.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_252 g_218 g_225 g_31 g_5 g_100 g_214 g_341 g_365 g_456 g_616
 * writes: g_252 g_218 g_31 g_100 g_214 g_225 g_5 g_456 g_341 g_365.f0 g_365.f1 g_365
 */
static int32_t  func_64(int16_t  p_65, struct S1  p_66, uint16_t  p_67, int32_t  p_68)
{ /* block id: 180 */
    struct S1 l_298 = {-3,1};
    struct S0 l_364 = {107,2,0};
    int32_t l_388 = 0xFAFA0813;
    int32_t l_391 = 0x537D9901;
    uint32_t l_436 = 4294967293U;
    int32_t l_599 = (-6);
    uint16_t l_603 = 9U;
    g_252 = g_252;
    l_298 = g_218;
    if (l_298.f1)
    { /* block id: 183 */
        l_298 = p_66;
    }
    else
    { /* block id: 185 */
        struct S1 l_299 = {0x9F9E0A39,-1};
        int16_t l_318 = 0x12E7;
        if (l_298.f0)
        { /* block id: 186 */
            l_299 = p_66;
        }
        else
        { /* block id: 188 */
            int16_t l_313 = 0x7CBE;
            int32_t l_394 = 0x38924129;
            if (((int16_t)(0U <= (((((((func_72(g_225, (~(!((-1) < (((int32_t)g_31 + (int32_t)(((uint16_t)1U % (uint16_t)((int16_t)(p_68 || g_252.f2) % (int16_t)((uint16_t)((!func_86(g_218)) <= 0x1731C5F3) - (uint16_t)p_66.f1))) != 0xD68A)) <= p_66.f1))))) ^ 0xEF5BE23E) != l_298.f1) | g_5) & l_298.f0) & l_313) != g_225) >= g_5)) >> (int16_t)8))
            { /* block id: 189 */
                uint16_t l_323 = 0x36FD;
                for (l_299.f0 = (-16); (l_299.f0 == 19); l_299.f0 += 1)
                { /* block id: 192 */
                    uint16_t l_329 = 0xE533;
                    g_218.f0 = (((int16_t)(l_318 >= p_66.f1) - (int16_t)g_252.f1) >= (0U >= (((uint16_t)(((uint16_t)g_252.f1 - (uint16_t)l_323) | (p_67 || ((!(((int16_t)g_5 >> (int16_t)((uint16_t)(g_218.f0 & g_252.f0) + (uint16_t)4U)) || l_329)) ^ g_218.f0))) + (uint16_t)0xD1EB) & l_298.f0)));
                    g_100.f1 = ((l_299.f1 ^ ((g_218.f1 | ((l_323 || (!(((int16_t)((uint16_t)__builtin_parityl(((p_66.f1 <= ((int16_t)g_225 >> (int16_t)__builtin_clzl((0x02FA658F >= p_65)))) >= ((int16_t)((uint32_t)p_67 % (uint32_t)l_329) << (int16_t)14))) + (uint16_t)g_31) >> (int16_t)l_323) != 0x272B))) | 0x55E2D799)) >= g_341)) | p_68);
                }
            }
            else
            { /* block id: 196 */
                uint32_t l_345 = 0x24F58DC4;
                struct S0 l_348 = {1177,-0,9};
                p_66.f1 = ((l_313 != (p_66.f0 | (g_100.f1 == ((l_318 == ((uint32_t)(__builtin_clz((((func_101(p_66.f0, (-(int32_t)l_299.f1)) == g_225) ^ (func_101(((((l_345 > g_341) & p_66.f0) || l_345) && l_299.f1), g_218.f0) <= g_100.f0)) | l_318)) | g_100.f0) - (uint32_t)0xF54725BD)) != g_252.f0)))) | p_66.f1);
                for (p_68 = 0; (p_68 < (-29)); p_68 -= 3)
                { /* block id: 200 */
                    uint32_t l_359 = 1U;
                    l_299 = func_88(l_348);
                    if (g_31)
                        break;
                    g_225 = ((uint16_t)__builtin_ffsll((p_66.f1 && (~g_218.f1))) << (uint16_t)4);
                    if (((g_341 ^ (0xB4783C93 < ((l_298.f1 ^ l_313) & p_65))) ^ p_67))
                    { /* block id: 204 */
                        int32_t l_358 = 6;
                        p_66.f1 = (p_65 <= (p_65 > ((0xC49AF966 & ((uint32_t)l_348.f1 - (uint32_t)(g_100.f1 & (((int16_t)((((func_101((((0x3903 || (((uint16_t)(0 || p_66.f0) - (uint16_t)g_31) >= p_68)) != g_5) >= l_313), g_252.f1) & (-9)) > p_65) || 0x616A) < p_65) << (int16_t)l_313) == l_358)))) | (-1))));
                        l_359 = l_358;
                        g_252.f1 = p_65;
                        if (g_100.f1)
                            continue;
                    }
                    else
                    { /* block id: 209 */
                        return g_31;
                    }
                }
            }
            if (((int16_t)(l_298.f0 & (0x1DC0 > l_299.f1)) % (int16_t)(l_313 | (((((((uint16_t)func_98(func_90(func_88(l_364), g_365)) << (uint16_t)2) < g_341) ^ g_225) >= g_365.f0) != p_65) < p_67))))
            { /* block id: 214 */
                g_5 = l_313;
            }
            else
            { /* block id: 216 */
                uint32_t l_371 = 2U;
                if (((uint16_t)(__builtin_parityl(l_313) | (-(uint32_t)(g_252.f1 != ((uint16_t)(l_371 & (0x39CE < g_218.f1)) % (uint16_t)__builtin_ffsl(p_67))))) % (uint16_t)((uint16_t)((((uint16_t)0xFE9F >> (uint16_t)l_299.f0) >= l_299.f0) != p_65) + (uint16_t)g_5)))
                { /* block id: 217 */
                    p_66.f1 = p_65;
                }
                else
                { /* block id: 219 */
                    int32_t l_385 = 0x1D08208A;
                    for (l_313 = (-9); (l_313 < 1); l_313 += 1)
                    { /* block id: 222 */
                        uint32_t l_389 = 8U;
                        g_225 = (((uint16_t)p_68 % (uint16_t)l_371) >= (__builtin_ctz(((int32_t)(p_66.f0 || ((int16_t)(~l_385) - (int16_t)(((uint16_t)(l_388 >= (0xB9AE == (2U ^ p_67))) << (uint16_t)9) == 7U))) % (int32_t)l_389)) <= 65532U));
                        p_66 = g_365;
                    }
                }
                l_394 = (!(p_66.f0 <= ((func_104(l_391, l_299, p_66, g_252.f1) < (((int16_t)g_341 << (int16_t)g_252.f2) != (((g_252.f1 < g_214) < (-8)) == l_371))) | l_313)));
            }
        }
    }
    if (g_252.f1)
    { /* block id: 231 */
        int32_t l_399 = 0;
        p_66.f1 = (((uint16_t)((uint32_t)(l_399 && (((int16_t)func_101(g_218.f1, ((int16_t)((uint32_t)(((uint16_t)((uint16_t)(p_68 && g_252.f2) - (uint16_t)l_399) + (uint16_t)__builtin_ctz(l_388)) ^ (p_68 == p_67)) - (uint32_t)p_66.f0) << (int16_t)14)) % (int16_t)l_399) & 0xDEFD)) + (uint32_t)p_68) - (uint16_t)g_218.f0) || (-1));
        p_66.f1 = ((func_104(l_364.f2, p_66, g_218, ((int32_t)0x0589027F + (int32_t)__builtin_bswap32((((int32_t)(((!(((uint16_t)p_66.f1 % (uint16_t)__builtin_popcount(__builtin_bswap64(g_252.f2))) <= __builtin_ia32_crc32qi(((int16_t)g_5 >> (int16_t)l_399), g_252.f1))) != l_388) != 0x6A68) % (int32_t)g_252.f1) > p_67)))) != g_252.f0) | l_364.f1);
        for (l_391 = (-2); (l_391 > 20); l_391 += 2)
        { /* block id: 236 */
            int32_t l_428 = (-3);
            int32_t l_451 = 0xC2C94C3D;
            struct S1 l_455 = {0x53CE2ACE,1};
            uint32_t l_505 = 0x0EBDDD4B;
            if ((((((int16_t)l_399 % (int16_t)((uint16_t)(p_66.f1 && g_214) - (uint16_t)(((~(((((l_364.f2 != (((int16_t)l_428 >> (int16_t)(g_365.f0 <= (!(l_428 & ((uint16_t)((uint16_t)((int32_t)((((__builtin_popcountl(p_66.f0) < p_66.f0) && g_218.f0) || 0x29E8) > l_428) - (int32_t)g_100.f2) << (uint16_t)p_67) << (uint16_t)g_365.f1))))) != 4294967295U)) | l_399) > p_66.f1) < g_365.f0) >= l_436)) && (-1)) > g_365.f0))) & 0x64B9D06E) >= g_5) & 0xF0BCF0CC))
            { /* block id: 237 */
                int32_t l_447 = (-1);
                struct S0 l_454 = {1256,19,15};
                g_5 = ((__builtin_clzl(((((((((int16_t)g_218.f0 >> (int16_t)13) > g_5) || ((g_100.f2 ^ ((int16_t)(-(uint32_t)0x8F848041) << (int16_t)9)) >= (((-(uint16_t)(0xC967DBF7 && 5U)) <= ((int16_t)((uint32_t)l_447 - (uint32_t)(~((((int16_t)l_451 - (int16_t)((uint16_t)l_447 << (uint16_t)l_447)) <= g_218.f1) ^ g_100.f2))) << (int16_t)9)) && p_65))) ^ p_66.f0) || 9U) && p_66.f0) || g_252.f2)) <= p_65) && p_67);
                p_66.f1 = p_67;
                p_66 = func_88(func_90(p_66, func_88(l_454)));
            }
            else
            { /* block id: 241 */
                int16_t l_468 = (-1);
                struct S0 l_476 = {7506,8,3};
                struct S1 l_491 = {0x97F19F9E,0};
                p_66 = func_88(func_90(l_455, func_88(g_456)));
                if (g_456.f0)
                    continue;
                for (p_67 = 0; (p_67 == 29); p_67 += 5)
                { /* block id: 246 */
                    int16_t l_485 = 5;
                    struct S1 l_488 = {0,-2};
                    for (g_31 = 0; (g_31 >= (-29)); g_31 -= 1)
                    { /* block id: 249 */
                        p_66.f0 = (-(uint16_t)(!func_101((((uint32_t)((int16_t)(-(int16_t)p_66.f1) << (int16_t)12) + (uint32_t)((p_66.f0 == l_468) & ((uint16_t)(-(int16_t)((func_101(p_65, p_67) || 0x83E90400) > ((int32_t)((int16_t)((p_67 <= l_468) != (-1)) << (int16_t)g_100.f2) - (int32_t)1U))) >> (uint16_t)g_31))) ^ 0xC5AE53D3), l_399)));
                        g_456 = l_476;
                        g_225 = ((uint32_t)0U % (uint32_t)(((int16_t)(((uint16_t)g_456.f2 % (uint16_t)__builtin_clzll(((int16_t)(p_68 < ((65535U == ((((p_66.f1 >= (__builtin_parityll(p_66.f0) > func_86(g_365))) < g_100.f1) ^ g_31) & 0xE8091654)) ^ g_456.f0)) >> (int16_t)p_66.f1))) && g_214) << (int16_t)p_67) && l_298.f1));
                        l_485 = p_66.f1;
                    }
                    if (p_68)
                        continue;
                    if ((((int16_t)__builtin_clzll((l_298.f0 != g_456.f2)) >> (int16_t)((p_66.f1 | 4294967287U) != g_218.f1)) & 0x2033496D))
                    { /* block id: 256 */
                        struct S0 l_489 = {1650,19,12};
                        l_488 = func_88(func_90(p_66, g_365));
                        if (g_252.f2)
                            break;
                        p_66 = func_88(l_489);
                        if (g_456.f0)
                            break;
                    }
                    else
                    { /* block id: 261 */
                        struct S1 l_490 = {0xE321A14B,-1};
                        g_100.f1 = g_100.f2;
                        if (p_68)
                            continue;
                        p_66 = l_490;
                    }
                    if (func_98(func_90(l_455, g_218)))
                    { /* block id: 266 */
                        g_456.f1 = 0xADF63481;
                    }
                    else
                    { /* block id: 268 */
                        l_364 = func_90(g_365, l_491);
                        if (g_100.f1)
                            break;
                    }
                }
                p_66.f0 = (((int16_t)func_75(((uint16_t)((uint16_t)((int16_t)(p_66.f0 >= __builtin_clz((func_75(l_399, (((uint32_t)l_388 + (uint32_t)(~((((uint16_t)__builtin_ffs(l_505) << (uint16_t)12) | p_68) == (1 & (((uint16_t)p_66.f1 - (uint16_t)(((uint16_t)p_65 >> (uint16_t)11) || l_364.f0)) >= l_364.f0))))) | 0xE447), p_65, g_365.f1) >= 7))) << (int16_t)g_218.f1) >> (uint16_t)g_456.f0) << (uint16_t)l_399), p_65, g_252.f1, p_66.f1) << (int16_t)5) == (-3));
            }
        }
    }
    else
    { /* block id: 276 */
        int32_t l_512 = 0;
        struct S0 l_614 = {6075,-16,8};
        g_218.f0 = ((65528U == ((((((uint32_t)(__builtin_ffsl(g_252.f1) != ((g_100.f0 | (((((g_252.f1 <= p_68) ^ ((p_68 ^ (p_66.f0 | 1)) >= 0U)) >= p_66.f0) || 0x666A) && p_67)) && 1U)) % (uint32_t)p_68) || g_214) && g_100.f1) < l_512) ^ 0x196C)) == 0x3B7330BC);
        if (l_512)
        { /* block id: 278 */
            uint32_t l_525 = 1U;
            struct S0 l_549 = {937,-7,12};
            l_298.f0 = p_67;
            if (((uint16_t)((g_31 <= (p_66.f0 && (((int32_t)p_68 - (int32_t)((0U > ((p_65 != ((uint16_t)((uint32_t)4294967290U % (uint32_t)p_66.f1) - (uint16_t)0xDEEA)) >= 0x48359DC1)) || 0xC9C7FB1C)) < g_100.f0))) < g_456.f1) + (uint16_t)0xFDE5))
            { /* block id: 280 */
                uint32_t l_545 = 4U;
                struct S0 l_548 = {1361,2,0};
                for (g_341 = (-26); (g_341 == (-22)); g_341 += 1)
                { /* block id: 283 */
                    uint32_t l_528 = 4294967286U;
                    l_525 = ((int16_t)1 << (int16_t)4);
                    for (g_365.f0 = 0; (g_365.f0 != 25); g_365.f0 += 5)
                    { /* block id: 287 */
                        uint32_t l_544 = 0x453B229A;
                        if (p_66.f1)
                            break;
                        if (l_528)
                            break;
                        g_365.f1 = (((int16_t)((int32_t)(l_512 ^ 0xF631C8AD) + (int32_t)(((int16_t)((-(int32_t)((((((uint16_t)g_456.f2 >> (uint16_t)(((int16_t)l_525 << (int16_t)l_525) < (((l_512 >= ((uint32_t)((uint16_t)1U >> (uint16_t)((p_67 >= l_512) < p_66.f0)) + (uint32_t)4294967292U)) ^ l_525) || 1))) & 7) | (-1)) <= l_544) & g_31)) && l_528) << (int16_t)p_66.f0) >= 0x961E)) + (int16_t)0x225B) >= l_545);
                        p_66.f0 = ((uint16_t)p_66.f1 << (uint16_t)l_545);
                    }
                    l_549 = l_548;
                }
                for (p_66.f0 = 0; (p_66.f0 >= (-20)); p_66.f0 -= 7)
                { /* block id: 297 */
                    g_252 = g_100;
                    l_298 = l_298;
                    g_365 = func_88(g_456);
                }
                if (p_66.f1)
                { /* block id: 302 */
                    return p_66.f0;
                }
                else
                { /* block id: 304 */
                    l_549 = func_90(g_365, g_218);
                    for (l_436 = 4; (l_436 == 13); l_436 += 1)
                    { /* block id: 308 */
                        if (p_65)
                            break;
                        if (l_545)
                            break;
                        if (g_252.f0)
                            break;
                    }
                    g_252.f1 = (g_100.f0 >= l_549.f1);
                    p_66.f1 = (-(uint16_t)0xAEFE);
                }
                l_549.f1 = ((((((int32_t)(g_218.f0 || p_65) - (int32_t)((int16_t)((__builtin_clzl(((-1) >= (__builtin_clzll(p_65) | (((uint32_t)g_365.f1 % (uint32_t)l_298.f1) <= (65532U > (l_549.f0 <= l_512)))))) < p_66.f0) != 65535U) - (int16_t)l_548.f2)) | l_548.f1) == 0) <= 0x3B456384) > 0xFF075A1F);
            }
            else
            { /* block id: 317 */
                int16_t l_569 = 0;
                for (g_365.f0 = 0; (g_365.f0 < (-25)); g_365.f0 -= 1)
                { /* block id: 320 */
                    struct S0 l_571 = {7645,-0,10};
                    for (l_512 = 0; (l_512 == (-8)); l_512 -= 3)
                    { /* block id: 323 */
                        l_549 = func_90(func_88(g_100), p_66);
                    }
                    if (((uint32_t)__builtin_ctzl(((int16_t)g_456.f2 - (int16_t)l_569)) + (uint32_t)g_341))
                    { /* block id: 326 */
                        g_5 = l_569;
                    }
                    else
                    { /* block id: 328 */
                        struct S0 l_570 = {6815,6,3};
                        l_571 = l_570;
                    }
                    return g_456.f2;
                }
                return p_65;
            }
        }
        else
        { /* block id: 335 */
            uint32_t l_572 = 0xBBEB22E9;
            l_298 = g_218;
            l_298.f1 = l_572;
        }
        p_66.f0 = __builtin_ctz(((((l_512 != (((int16_t)(l_364.f1 <= (g_214 | ((int32_t)(l_512 > ((uint16_t)l_512 << (uint16_t)4)) % (int32_t)__builtin_ffsl((((p_66.f1 != (((func_101((p_68 <= ((uint32_t)(((int16_t)(func_98(l_364) > 4294967295U) << (int16_t)8) != p_66.f0) % (uint32_t)l_512)), p_66.f0) && l_388) && l_364.f2) > 0x3F32)) == p_66.f0) | (-9)))))) % (int16_t)g_252.f2) || p_66.f0)) < 0xBE90F7FB) ^ g_214) < 0U));
        if (((int16_t)l_512 >> (int16_t)((uint16_t)((((int16_t)(((0 <= (((int16_t)p_67 + (int16_t)((0xFE0B != (p_68 == (((int16_t)(-2) << (int16_t)(((g_218.f0 == (l_364.f1 < ((l_512 || l_298.f1) == l_512))) >= 1) == 1U)) ^ g_365.f1))) >= p_67)) & 0xB1A47F8B)) ^ 0x9E24) == g_252.f1) >> (int16_t)g_100.f0) != 5U) && p_67) - (uint16_t)g_456.f1)))
        { /* block id: 340 */
            uint32_t l_606 = 5U;
            for (l_391 = 0; (l_391 != (-8)); l_391 -= 2)
            { /* block id: 343 */
                int32_t l_600 = (-1);
                struct S0 l_615 = {553,13,10};
                if ((p_65 > (((((1U < __builtin_parityll(l_512)) | ((((int16_t)g_100.f1 << (int16_t)l_512) > ((uint16_t)g_252.f0 >> (uint16_t)((((-1) != l_298.f0) != l_599) <= 0xDF06C3CC))) >= 0x17AC22A4)) > g_218.f0) == l_600) != g_100.f2)))
                { /* block id: 344 */
                    struct S1 l_601 = {1,2};
                    l_601 = p_66;
                    if (p_67)
                        continue;
                    return g_100.f1;
                }
                else
                { /* block id: 348 */
                    int32_t l_607 = 1;
                    if ((g_100.f0 >= l_600))
                    { /* block id: 349 */
                        struct S0 l_602 = {6664,14,6};
                        g_365 = p_66;
                        l_602 = g_456;
                        return l_603;
                    }
                    else
                    { /* block id: 353 */
                        p_66.f0 = (((uint16_t)((func_75(l_606, (func_72((l_607 || ((int32_t)(0xD47651B4 ^ (((((func_72((4U == ((int16_t)((uint16_t)(func_98(func_90(g_365, func_88(l_614))) != g_456.f1) % (uint16_t)p_66.f1) >> (int16_t)8)), p_66.f0) <= 0) >= l_512) && p_65) || 65535U) || g_100.f2)) % (int32_t)g_456.f2)), p_66.f0) > p_67), g_456.f0, g_365.f0) < g_341) != (-1)) - (uint16_t)0x8DFF) & p_67);
                        p_66 = func_88(g_100);
                        l_614 = l_614;
                    }
                }
                l_615 = g_456;
            }
        }
        else
        { /* block id: 361 */
            l_614 = g_616;
        }
    }
    return l_298.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_100 g_31 g_214 g_225 g_218.f0 g_218.f1 g_218 g_252.f0 g_252.f1 g_252.f2
 * writes: g_31 g_100 g_214 g_218 g_252
 */
static int32_t  func_72(int16_t  p_73, int16_t  p_74)
{ /* block id: 46 */
    int32_t l_81 = 0x84BB8686;
    struct S1 l_93 = {0x453288EE,1};
    l_93.f1 = ((func_75((!l_81), ((uint16_t)(((uint32_t)__builtin_ctzll(p_73) % (uint32_t)func_86(func_88(func_90(l_93, l_93)))) || (__builtin_popcount(l_81) | p_73)) - (uint16_t)g_225), g_5, l_81) != g_225) != 8U);
    return g_252.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_218 g_5 g_100 g_31
 * writes: g_31 g_100
 */
static uint32_t  func_75(int16_t  p_76, int32_t  p_77, uint32_t  p_78, uint16_t  p_79)
{ /* block id: 174 */
    struct S0 l_287 = {603,18,14};
    l_287 = func_90(g_218, g_218);
    l_287.f1 = (-1);
    return l_287.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_218
 * writes: g_218
 */
static int32_t  func_86(struct S1  p_87)
{ /* block id: 171 */
    g_218 = g_218;
    return p_87.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_100.f1 g_5 g_100.f0 g_31 g_100.f2 g_100 g_214 g_225 g_218.f0 g_218.f1 g_218 g_252.f0 g_252.f1
 * writes: g_31 g_100 g_214 g_218 g_252
 */
static struct S1  func_88(struct S0  p_89)
{ /* block id: 120 */
    uint16_t l_206 = 0U;
    struct S1 l_217 = {0x1DC5D4B5,1};
    uint32_t l_219 = 0xAB573FC3;
    int16_t l_226 = 0x78A9;
    uint16_t l_236 = 6U;
    p_89.f1 = ((int16_t)(((uint16_t)((g_100.f1 == ((0x4F3A628D < func_101(p_89.f1, p_89.f2)) ^ ((int32_t)l_206 + (int32_t)(1 != ((uint16_t)(l_206 ^ __builtin_popcount(g_5)) << (uint16_t)g_100.f1))))) >= l_206) << (uint16_t)2) ^ l_206) + (int16_t)p_89.f0);
    g_214 = ((uint16_t)(0xCF98005E == 2) << (uint16_t)__builtin_ia32_crc32qi(((~(((((uint16_t)func_98(p_89) % (uint16_t)0xFAE4) & p_89.f0) && (p_89.f2 > g_5)) && l_206)) ^ 0x6C3B), g_5));
    for (g_214 = 0; (g_214 < 19); g_214 += 3)
    { /* block id: 125 */
        uint32_t l_231 = 0x99461F97;
        int32_t l_237 = 0xB27ABAB6;
        g_218 = l_217;
        if (l_219)
        { /* block id: 127 */
            uint32_t l_222 = 0x9DD07A39;
            p_89.f1 = (((int32_t)l_222 - (int32_t)((p_89.f2 <= ((int32_t)g_225 + (int32_t)l_226)) >= (((int16_t)((int16_t)g_218.f0 >> (int16_t)9) << (int16_t)14) != ((l_217.f0 & l_231) || ((int16_t)((int16_t)((g_214 || (g_218.f1 || l_236)) ^ g_5) >> (int16_t)l_231) >> (int16_t)l_222))))) & p_89.f1);
            l_237 = p_89.f0;
            p_89 = func_90(g_218, g_218);
        }
        else
        { /* block id: 131 */
            return g_218;
        }
        if ((0xC2FD & (g_100.f0 > g_214)))
        { /* block id: 134 */
            uint32_t l_238 = 0x03912959;
            if (l_238)
                break;
            return l_217;
        }
        else
        { /* block id: 137 */
            uint16_t l_243 = 0U;
            int32_t l_250 = (-4);
            struct S1 l_251 = {0x18DDF385,-3};
            l_250 = ((((uint16_t)(g_100.f1 > (((int32_t)(l_243 && (l_243 | ((uint32_t)((int16_t)(((4294967291U >= (1 <= (p_89.f0 == (l_231 & (((p_89.f1 ^ (p_89.f0 && l_226)) == (-8)) ^ g_5))))) >= p_89.f0) || 0x59F9) << (int16_t)15) + (uint32_t)4294967286U))) % (int32_t)g_218.f0) && 1U)) << (uint16_t)l_226) <= p_89.f0) <= l_236);
            g_252 = func_90(g_218, l_251);
            g_218.f0 = g_252.f0;
        }
    }
    for (l_206 = 21; (l_206 >= 4); l_206 -= 1)
    { /* block id: 145 */
        int16_t l_266 = (-1);
        struct S1 l_285 = {0,-1};
        for (l_217.f0 = 0; (l_217.f0 == 10); l_217.f0 += 1)
        { /* block id: 148 */
            uint32_t l_263 = 0U;
            int32_t l_284 = (-1);
            if ((((((uint16_t)(p_89.f1 <= (-10)) - (uint16_t)(0U > (((g_31 | (0xCAAA && (((((-1) && ((((int32_t)l_263 - (int32_t)g_225) || __builtin_ctz(((((uint16_t)0xA27D + (uint16_t)0x3D24) != l_263) & (-1)))) > (-1))) > g_5) | g_252.f1) == 0x10DC))) <= l_266) == 0))) ^ g_225) < l_266) < p_89.f1))
            { /* block id: 149 */
                struct S1 l_271 = {0x8BCB9B15,-3};
                for (l_263 = 0; (l_263 >= 32); l_263 += 3)
                { /* block id: 152 */
                    l_217.f1 = (((uint16_t)func_104(g_5, g_218, l_271, p_89.f0) - (uint16_t)p_89.f1) ^ l_217.f0);
                    p_89.f1 = 0x6DD29B11;
                }
                p_89.f1 = ((0x856281AE & (g_214 ^ (l_271.f1 || ((int16_t)((-(uint16_t)((__builtin_parityl((~l_236)) >= (!((uint16_t)((int16_t)p_89.f0 + (int16_t)(0x695775BB == (((p_89.f0 != 0x43B7) != p_89.f2) == p_89.f0))) % (uint16_t)0x5B92))) < 7U)) && g_218.f0) >> (int16_t)4)))) || 0x12390A75);
                for (g_31 = 0; (g_31 > 21); g_31 += 1)
                { /* block id: 159 */
                    g_100 = p_89;
                    g_218 = g_218;
                }
            }
            else
            { /* block id: 163 */
                uint32_t l_283 = 0x3D82C601;
                int32_t l_286 = 1;
                l_283 = p_89.f1;
                l_284 = 3;
                l_286 = func_104((func_98(func_90(l_217, g_218)) != l_219), g_218, l_285, p_89.f1);
            }
        }
    }
    return g_218;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_100 g_31
 * writes: g_31 g_100
 */
static struct S0  func_90(struct S1  p_91, struct S1  p_92)
{ /* block id: 47 */
    int16_t l_188 = 0x00A9;
    uint32_t l_193 = 1U;
    uint32_t l_198 = 0x1F38F8E0;
    struct S0 l_199 = {3478,14,9};
    p_91.f1 = ((g_5 ^ ((((uint16_t)0U - (uint16_t)p_91.f0) > ((int32_t)func_98(g_100) % (int32_t)g_5)) != ((int32_t)(l_188 != ((g_5 | p_91.f0) & 0x1D2AFC0B)) % (int32_t)p_92.f0))) != p_91.f1);
    p_92.f0 = (l_188 | (((((int16_t)(func_98(g_100) & p_91.f0) << (int16_t)((((((-10) | (((int16_t)l_193 % (int16_t)(__builtin_ffs(((g_5 & p_92.f1) & (((uint32_t)((uint16_t)0x06E7 % (uint16_t)g_5) - (uint32_t)0xAE134941) >= l_198))) & l_198)) & l_193)) > l_198) || g_5) < l_193) || p_92.f1)) >= l_188) && 4294967290U) != 5U));
    return l_199;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_100.f0 g_100.f1 g_31 g_100.f2 g_100
 * writes: g_31 g_100
 */
static int32_t  func_98(struct S0  p_99)
{ /* block id: 48 */
    struct S1 l_109 = {-10,-3};
    int32_t l_112 = (-1);
    p_99.f1 = (func_101(g_5, func_104(g_5, l_109, l_109, (p_99.f0 ^ (g_100.f0 || (((int32_t)(g_100.f1 > l_109.f0) - (int32_t)l_112) >= g_100.f0))))) >= g_5);
    g_100.f1 = ((l_109.f0 | (!p_99.f1)) && (((__builtin_parityl((((((int32_t)(0x4046 == l_109.f1) % (int32_t)((int16_t)((-(uint32_t)p_99.f0) ^ ((int16_t)0 << (int16_t)12)) << (int16_t)(-(uint16_t)g_31))) >= ((g_31 | 4294967295U) | g_100.f2)) == 1) == g_100.f2)) ^ 0) != 0) != g_31));
    return g_100.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_101(int32_t  p_102, int32_t  p_103)
{ /* block id: 112 */
    uint32_t l_174 = 0x3F436BBB;
    return l_174;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_31 g_100.f1 g_100.f0 g_100.f2 g_100
 * writes: g_31 g_100
 */
static int32_t  func_104(uint32_t  p_105, struct S1  p_106, struct S1  p_107, int32_t  p_108)
{ /* block id: 49 */
    uint16_t l_113 = 65535U;
    int16_t l_130 = 0x8580;
    uint16_t l_137 = 4U;
    struct S0 l_167 = {4074,15,11};
    if (l_113)
    { /* block id: 50 */
        int32_t l_129 = 0xFB047B2A;
        struct S0 l_168 = {8062,-4,10};
        for (l_113 = 10; (l_113 != 40); l_113 += 1)
        { /* block id: 53 */
            int16_t l_128 = 0x9A72;
            if (p_107.f1)
                break;
            l_130 = ((uint16_t)((g_5 != l_113) | (65535U > __builtin_ctzll(((1U <= ((uint16_t)l_113 << (uint16_t)((uint16_t)((uint16_t)((uint16_t)p_107.f0 >> (uint16_t)12) - (uint16_t)(g_31 != ((g_100.f1 ^ (((int16_t)p_106.f0 % (int16_t)p_108) || 4U)) || 0x7241AB08))) >> (uint16_t)l_128))) || 0x23B9C033)))) % (uint16_t)l_129);
        }
        if (((uint16_t)(((uint16_t)p_106.f0 << (uint16_t)((((uint16_t)l_137 >> (uint16_t)__builtin_ctzl((((((int16_t)((((uint16_t)(p_108 & (((((p_105 == g_5) < ((uint16_t)(l_130 || p_108) % (uint16_t)0xDD07)) < ((~((int32_t)0xDC29D91F % (int32_t)p_108)) & g_100.f0)) && l_129) || (-1))) % (uint16_t)3U) ^ p_105) >= g_100.f1) % (int16_t)l_129) <= 0x7AC8E616) >= l_137) ^ 0x06802A6C))) != g_5) & 0xBB29333D)) | 1U) + (uint16_t)0U))
        { /* block id: 57 */
            p_107.f0 = __builtin_bswap64(g_100.f2);
        }
        else
        { /* block id: 59 */
            if (p_106.f1)
            { /* block id: 60 */
                uint16_t l_147 = 0x1476;
                l_147 = p_107.f0;
            }
            else
            { /* block id: 62 */
                int32_t l_148 = (-1);
                l_148 = p_105;
                l_129 = (p_106.f0 != ((int16_t)g_5 - (int16_t)l_130));
            }
        }
        for (l_113 = 20; (l_113 < 8); l_113 -= 1)
        { /* block id: 69 */
            uint32_t l_159 = 0U;
            uint16_t l_160 = 0U;
            p_107.f1 = (((int16_t)(((p_108 >= p_107.f1) && ((uint16_t)(0x187DA113 && 4294967295U) + (uint16_t)p_107.f0)) | ((uint16_t)(0x60D964AF < __builtin_bswap32(l_159)) << (uint16_t)10)) << (int16_t)0) | (4294967294U > g_31));
            l_160 = g_5;
        }
        if (p_105)
        { /* block id: 73 */
            struct S0 l_171 = {2015,11,4};
            for (g_31 = 0; (g_31 != (-8)); g_31 -= 1)
            { /* block id: 76 */
                struct S0 l_163 = {997,-20,14};
                g_100 = l_163;
                for (p_107.f0 = (-1); (p_107.f0 != 14); p_107.f0 += 5)
                { /* block id: 80 */
                    if ((l_137 < p_107.f1))
                    { /* block id: 81 */
                        struct S0 l_166 = {6593,21,8};
                        p_107.f1 = (__builtin_clzll(p_106.f0) && (p_106.f0 ^ p_107.f0));
                        g_100 = l_166;
                        return p_105;
                    }
                    else
                    { /* block id: 85 */
                        if (l_129)
                            break;
                    }
                    l_168 = l_167;
                    for (l_130 = (-5); (l_130 != 21); l_130 += 1)
                    { /* block id: 91 */
                        return p_106.f1;
                    }
                }
                g_100 = l_171;
                p_106.f0 = l_168.f1;
            }
            g_100.f1 = 1;
        }
        else
        { /* block id: 99 */
            for (l_130 = (-11); (l_130 > 3); l_130 += 1)
            { /* block id: 102 */
                g_100 = g_100;
                return g_31;
            }
            g_100 = g_100;
        }
    }
    else
    { /* block id: 108 */
        return p_108;
    }
    return l_167.f1;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc(g_100.f0, "g_100.f0", print_hash_value);
    transparent_crc(g_100.f1, "g_100.f1", print_hash_value);
    transparent_crc(g_100.f2, "g_100.f2", print_hash_value);
    transparent_crc(g_214, "g_214", print_hash_value);
    transparent_crc(g_218.f0, "g_218.f0", print_hash_value);
    transparent_crc(g_218.f1, "g_218.f1", print_hash_value);
    transparent_crc(g_225, "g_225", print_hash_value);
    transparent_crc(g_252.f0, "g_252.f0", print_hash_value);
    transparent_crc(g_252.f1, "g_252.f1", print_hash_value);
    transparent_crc(g_252.f2, "g_252.f2", print_hash_value);
    transparent_crc(g_341, "g_341", print_hash_value);
    transparent_crc(g_365.f0, "g_365.f0", print_hash_value);
    transparent_crc(g_365.f1, "g_365.f1", print_hash_value);
    transparent_crc(g_456.f0, "g_456.f0", print_hash_value);
    transparent_crc(g_456.f1, "g_456.f1", print_hash_value);
    transparent_crc(g_456.f2, "g_456.f2", print_hash_value);
    transparent_crc(g_616.f0, "g_616.f0", print_hash_value);
    transparent_crc(g_616.f1, "g_616.f1", print_hash_value);
    transparent_crc(g_616.f2, "g_616.f2", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 103
   depth: 1, occurrence: 54
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 54
breakdown:
   indirect level: 0, occurrence: 54
XXX full-bitfields structs in the program: 30
breakdown:
   indirect level: 0, occurrence: 30
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 51
XXX times a bitfields struct on RHS: 108
XXX times a single bitfield on LHS: 43
XXX times a single bitfield on RHS: 237

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 274
   depth: 2, occurrence: 45
   depth: 3, occurrence: 10
   depth: 4, occurrence: 11
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 9, occurrence: 1
   depth: 12, occurrence: 4
   depth: 13, occurrence: 7
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 5
   depth: 17, occurrence: 5
   depth: 18, occurrence: 5
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 21, occurrence: 2
   depth: 22, occurrence: 7
   depth: 23, occurrence: 3
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 2
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 887
XXX times a non-volatile is write: 177
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 257
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 22
   depth: 2, occurrence: 36
   depth: 3, occurrence: 44
   depth: 4, occurrence: 55
   depth: 5, occurrence: 71

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

