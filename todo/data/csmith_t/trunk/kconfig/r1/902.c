/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1866071831
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 10;
   unsigned f1 : 25;
   float  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const int8_t  func_1(void);
inline static int8_t  func_13(int32_t  p_14, int8_t  p_15, uint32_t  p_16);
static int32_t  func_19(uint64_t  p_20);
inline static struct S0  func_28(int32_t  p_29);
static int32_t * const  func_32(int32_t  p_33, float  p_34, int32_t * p_35);
static int32_t * func_43(int32_t ** p_44, uint32_t  p_45, int32_t ** p_46);
static int32_t ** func_47(int32_t  p_48, int32_t * p_49, uint32_t  p_50, int32_t ** p_51);
static int32_t * func_69(int32_t ** p_70, int32_t  p_71, const int32_t * p_72, int32_t  p_73);
inline static int32_t  func_74(int32_t ** p_75, int32_t ** p_76, const int32_t ** p_77, int8_t  p_78, int32_t * p_79);
static int32_t ** func_80(int32_t  p_81, int64_t  p_82, int8_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int8_t  func_1(void)
{ /* block id: 0 */
    int64_t l_6 = 0x6DD8D13034D00693LL;
    uint32_t l_25 = 1UL;
    float l_711 = 0x7.Ep-1;
    struct S0 l_739 = {22,2783,0x1.0p+1};
    struct S0 * const l_738 = &l_739;
    const struct S0 **l_750 = (void*)0;
    const struct S0 ***l_749 = &l_750;
    struct S0 *l_755 = &l_739;
    float *l_756 = &l_739.f2;
    int32_t l_757 = 0xE3C3C47BL;
    struct S0 ****l_759 = (void*)0;
    struct S0 *****l_758 = &l_759;
    if ((safe_lshift_func_int16_t_s_s(0x85C6L, (safe_rshift_func_uint8_t_u_s((l_6 <= 0x323DL), (safe_sub_func_uint32_t_u_u(5UL, (l_6 | ((((safe_div_func_uint16_t_u_u((safe_div_func_int8_t_s_s(func_13(l_6, ((safe_sub_func_int32_t_s_s(func_19(((safe_add_func_int32_t_s_s((l_6 >= (safe_lshift_func_int16_t_s_u((-1L), 8))), (l_25 == l_6))) < l_6)), l_25)) ^ l_6), l_6), l_6)), l_6)) != 0x003011F35FBADEB3LL) | l_6) < l_25)))))))))
    { /* block id: 366 */
        int32_t l_712[8][8] = {{0x53D4A66DL,0x75F29847L,0xB73D9C54L,(-10L),5L,(-1L),0x03DF082DL,(-6L)},{0x03DF082DL,(-7L),0xB73D9C54L,0xF5AA87ACL,0xF5AA87ACL,0xB73D9C54L,(-7L),0x03DF082DL},{5L,(-7L),0x53D4A66DL,(-1L),9L,0x75F29847L,(-6L),0xB73D9C54L},{0x1964A922L,(-10L),9L,0x20B86204L,(-1L),0x75F29847L,(-1L),0x20B86204L},{(-7L),(-7L),(-7L),0x53D4A66DL,0x75F29847L,0xB73D9C54L,(-10L),5L},{0x20B86204L,(-7L),(-1L),(-6L),0x1964A922L,(-1L),(-10L),(-10L)},{(-1L),(-10L),0x53D4A66DL,0x53D4A66DL,(-10L),(-1L),0xB73D9C54L,(-6L)},{5L,(-6L),0xCBC936BAL,0xB73D9C54L,0x03DF082DL,(-7L),0xF5AA87ACL,(-1L)}};
        int32_t l_714 = 0L;
        int32_t *l_713 = &l_714;
        int32_t **l_717 = &l_713;
        int32_t ***l_716 = &l_717;
        int i, j;
        for (l_25 = 0; l_25 < 8; l_25 += 1)
        {
            for (l_6 = 0; l_6 < 8; l_6 += 1)
            {
                l_712[l_25][l_6] = (-1L);
            }
        }
        if (l_712[2][6])
        { /* block id: 368 */
            int32_t **l_715 = &l_713;
            (*l_715) = l_713;
        }
        else
        { /* block id: 370 */
            int32_t ****l_718 = &l_716;
            (*l_718) = l_716;
        }
    }
    else
    { /* block id: 373 */
        int32_t l_728 = 0xA656B2C9L;
        if ((safe_div_func_int64_t_s_s(0xD1F67B3170294C4FLL, l_6)))
        { /* block id: 374 */
            int32_t *l_733 = &l_728;
            int32_t **l_732 = &l_733;
            int32_t ***l_731 = &l_732;
            for (l_25 = 0; (l_25 >= 23); ++l_25)
            { /* block id: 377 */
                int32_t *l_725 = (void*)0;
                int32_t **l_724[4][2] = {{&l_725,&l_725},{&l_725,&l_725},{&l_725,&l_725},{&l_725,&l_725}};
                int32_t ** const *l_723[9][10] = {{&l_724[2][0],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[2][0],&l_724[2][0],&l_724[0][1]},{&l_724[2][0],&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[2][0],(void*)0,(void*)0,&l_724[2][0],&l_724[0][1]},{&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[2][0],(void*)0,(void*)0,&l_724[2][0],&l_724[0][1],&l_724[0][1]},{&l_724[0][1],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[2][0],&l_724[2][0],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[0][1]},{&l_724[2][0],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[2][0],&l_724[2][0],&l_724[0][1]},{&l_724[2][0],&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[2][0],(void*)0,(void*)0,&l_724[2][0],&l_724[0][1]},{&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[0][1],&l_724[2][0],(void*)0,(void*)0,&l_724[2][0],&l_724[0][1],&l_724[0][1]},{&l_724[0][1],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[2][0],&l_724[2][0],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[0][1]},{&l_724[2][0],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[0][1],(void*)0,&l_724[0][1],&l_724[2][0],&l_724[2][0],&l_724[0][1]}};
                int32_t ** const **l_726 = &l_723[8][6];
                struct S0 * const ****l_727 = (void*)0;
                int i, j;
                (*l_726) = l_723[8][6];
            }
        }
        else
        { /* block id: 381 */
            struct S0 *l_741 = (void*)0;
            struct S0 **l_740[8];
            struct S0 **l_742 = &l_741;
            int32_t *l_744 = &l_728;
            int32_t **l_743 = &l_744;
            int i;
            for (i = 0; i < 8; i++)
                l_740[i] = &l_741;
            (*l_742) = l_738;
            /* statement id: 382 */
            assert (l_741 == &l_739);
            (*l_743) = &l_728;
        }
    }
    (*l_756) = (safe_add_func_float_f_f((safe_sub_func_float_f_f((l_749 == &l_750), (l_6 == (-0x1.Bp-1)))), ((((0x1.Fp+1 == 0x7.F4E950p+70) > ((safe_div_func_float_f_f(((0x3.Bp-1 == ((((safe_sub_func_float_f_f((l_755 != (void*)0), 0x0.8p+1)) <= l_25) != l_739.f0) != l_739.f1)) <= l_25), 0xC.9EC040p-21)) == 0x0.7p+1)) < 0x1.E5DFBDp-80) >= l_6)));
    l_757 = l_739.f0;
    l_758 = l_758;
    return l_739.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_13(int32_t  p_14, int8_t  p_15, uint32_t  p_16)
{ /* block id: 3 */
    uint32_t l_27 = 1UL;
    struct S0 l_337 = {10,834,-0x4.9p-1};
    float l_342 = 0x5.FBD8EDp-16;
    int32_t l_369 = 0x6E164174L;
    int32_t *l_368 = &l_369;
    uint8_t l_394 = 255UL;
    struct S0 *l_428 = &l_337;
    struct S0 **l_427[4];
    struct S0 ***l_426 = &l_427[0];
    struct S0 ****l_629 = &l_426;
    struct S0 *****l_628 = &l_629;
    int32_t ****l_644 = (void*)0;
    int64_t l_687 = 1L;
    int16_t l_689 = (-1L);
    const uint32_t l_708[4] = {4294967288UL,4294967288UL,4294967288UL,4294967288UL};
    int i;
    for (i = 0; i < 4; i++)
        l_427[i] = &l_428;
    if (func_19(l_27))
    { /* block id: 4 */
        uint32_t l_343 = 0x1502E58EL;
        struct S0 *l_360 = &l_337;
        struct S0 * const * const l_359 = &l_360;
        int32_t **l_370 = &l_368;
        float *l_374 = (void*)0;
        struct S0 **l_397 = &l_360;
        struct S0 ***l_396 = &l_397;
        struct S0 ****l_395 = &l_396;
        uint32_t l_408[7];
        int64_t l_469 = 5L;
        int i;
        for (i = 0; i < 7; i++)
            l_408[i] = 1UL;
        l_337 = func_28(p_14);
        for (p_15 = 0; (p_15 <= (-10)); --p_15)
        { /* block id: 141 */
            struct S0 ***l_352 = (void*)0;
            struct S0 ****l_351[7];
            struct S0 *****l_350 = &l_351[5];
            int32_t l_361 = 0x9B6448E5L;
            float l_404 = 0xE.E438D2p+8;
            uint8_t l_472 = 4UL;
            int32_t **l_475[10][10][2] = {{{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368}},{{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368}},{{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368}},{{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,(void*)0},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368}},{{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,(void*)0},{&l_368,&l_368},{&l_368,(void*)0}},{{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368}},{{&l_368,(void*)0},{&l_368,&l_368},{&l_368,(void*)0},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368}},{{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,(void*)0},{&l_368,&l_368},{&l_368,(void*)0},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368}},{{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,(void*)0},{&l_368,&l_368},{&l_368,(void*)0},{&l_368,&l_368}},{{(void*)0,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{&l_368,&l_368},{(void*)0,&l_368},{&l_368,(void*)0}}};
            int i, j, k;
            for (i = 0; i < 7; i++)
                l_351[i] = &l_352;
            if ((safe_rshift_func_uint16_t_u_s(l_343, 11)))
            { /* block id: 142 */
                const uint32_t l_362 = 0UL;
                int32_t **l_371 = (void*)0;
                int32_t *l_402 = &l_369;
                int32_t l_403[10] = {0L,0L,0L,0L,0L,0L,0L,0L,0L,0L};
                uint32_t l_420 = 7UL;
                float *l_421 = &l_404;
                int i;
                if ((((((((safe_rshift_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u((safe_div_func_int32_t_s_s(p_16, ((p_14 ^ (l_343 > p_16)) | ((void*)0 == l_350)))), (((void*)0 == &l_351[5]) == ((safe_mod_func_int8_t_s_s((safe_rshift_func_int8_t_s_u((l_359 != (void*)0), p_16)), 0xEFL)) != 9UL)))) < l_343), 10)) && p_16) < l_361) || l_362) >= (-7L)) == (-4L)) || l_337.f0))
                { /* block id: 143 */
                    int32_t *l_365 = &l_361;
                    for (p_14 = (-22); (p_14 < (-3)); p_14++)
                    { /* block id: 146 */
                        const int32_t *l_367[9][1] = {{&l_361},{&l_361},{&l_361},{&l_361},{&l_361},{&l_361},{&l_361},{&l_361},{&l_361}};
                        const int32_t **l_366[10] = {&l_367[7][0],&l_367[6][0],&l_367[7][0],&l_367[6][0],&l_367[7][0],&l_367[6][0],&l_367[7][0],&l_367[6][0],&l_367[7][0],&l_367[6][0]};
                        struct S0 * const l_383 = &l_337;
                        int i, j;
                        l_368 = l_365;
                        /* statement id: 147 */
                        assert (l_368 == &l_361);
                        (*l_370) = func_69(l_370, l_361, &l_361, p_14);
                        (*l_383) = func_28((safe_add_func_int64_t_s_s((((((l_374 == (void*)0) < (safe_add_func_uint64_t_u_u((((safe_lshift_func_uint8_t_u_s(p_15, 2)) > ((safe_mod_func_int64_t_s_s(((safe_add_func_uint16_t_u_u(((void*)0 == l_383), (safe_div_func_uint8_t_u_u((((safe_sub_func_int32_t_s_s((safe_sub_func_uint8_t_u_u(l_362, (((**l_370) && l_361) | (safe_add_func_int16_t_s_s((safe_add_func_uint64_t_u_u(((0x1CL < p_15) & p_15), (*l_368))), p_15))))), p_15)) <= l_394) <= p_16), l_361)))) & (**l_370)), p_15)) >= (*l_365))) | p_14), 0x83FABB2636098FC4LL))) < (*l_368)) ^ 3L) > 0x14L), 0xAB22C986EB8B460CLL)));
                        (*l_350) = l_395;
                    }
                    /* facts after for loop */
                    assert (l_368 == &l_361 || l_368 == &p_14 || l_368 == &l_369);
                    //assert (l_351[0] == &l_396 || l_351[0] == &l_352);
                }
                else
                { /* block id: 152 */
                    const int32_t l_399 = 0x5D2AD8E0L;
                    if ((~p_16))
                    { /* block id: 153 */
                        if ((**l_370))
                            break;
                    }
                    else
                    { /* block id: 155 */
                        float *l_400[8];
                        int32_t l_401[7];
                        int i;
                        for (i = 0; i < 8; i++)
                            l_400[i] = &l_337.f2;
                        for (i = 0; i < 7; i++)
                            l_401[i] = 0x99B518B7L;
                        if (p_15)
                            break;
                        l_401[6] = l_399;
                        (**l_397) = l_337;
                    }
                    l_402 = &l_361;
                    /* statement id: 160 */
                    assert (l_402 == &l_361);
                    if (l_403[6])
                        break;
                    return p_15;
                }
                /* facts after branching */
                assert (l_368 == &l_361 || l_368 == &p_14 || l_368 == &l_369);
                //assert (l_351[0] == &l_396 || l_351[0] == &l_352);
                (*l_421) = (((+((0x9.87BE30p+33 < ((safe_div_func_float_f_f((p_14 > l_408[5]), p_16)) != (*l_368))) == (safe_div_func_float_f_f((p_15 != ((+(safe_add_func_float_f_f(((**l_370) < (((safe_div_func_float_f_f((p_15 != (safe_div_func_float_f_f((((safe_sub_func_float_f_f(l_420, p_15)) < p_14) >= (*l_368)), (*l_368)))), 0x0.Fp-1)) <= (-0x6.Cp-1)) > l_361)), 0x9.9p-1))) != 0x5.8p-1)), l_361)))) != 0x5.524279p-33) > (**l_370));
                (*l_368) = 0x18D794A1L;
            }
            else
            { /* block id: 166 */
                uint16_t l_422 = 0xC322L;
                for (l_369 = 5; (l_369 >= 1); l_369 -= 1)
                { /* block id: 169 */
                    return p_14;
                }
                if (p_14)
                    break;
                if (l_422)
                    break;
                if (p_14)
                    continue;
            }
            /* facts after branching */
            assert (l_368 == &l_361 || l_368 == &p_14 || l_368 == &l_369);
            //assert (l_351[0] == &l_396 || l_351[0] == &l_352);
            for (l_361 = 28; (l_361 != 28); l_361 = safe_add_func_uint8_t_u_u(l_361, 1))
            { /* block id: 178 */
                int32_t l_425 = 0xB8D9610CL;
                struct S0 ***l_429 = &l_427[0];
                float *l_441 = &l_404;
                int32_t **l_454 = &l_368;
                int32_t l_457 = (-9L);
                if (l_425)
                    break;
            }
            if ((p_16 == ((void*)0 != (*l_370))))
            { /* block id: 203 */
                float *l_497 = &l_404;
                for (l_369 = 0; (l_369 < (-5)); l_369 = safe_sub_func_uint8_t_u_u(l_369, 3))
                { /* block id: 206 */
                    return p_14;
                }
                if (p_16)
                { /* block id: 209 */
                    int16_t l_489 = 0xBE72L;
                    uint32_t l_490 = 1UL;
                    (*l_370) = &p_14;
                    /* statement id: 210 */
                    assert (l_368 == &p_14);
                    (*l_497) = (safe_div_func_float_f_f(0x1.7p+1, (((void*)0 == (**l_395)) <= (((p_14 > ((((safe_div_func_float_f_f((safe_div_func_float_f_f(p_16, ((-0x7.3p-1) > l_490))), ((l_374 == l_497) == (**l_370)))) >= p_14) >= p_16) == (*l_368))) > p_15) < p_15))));
                    (*l_370) = &p_14;
                    if (l_489)
                        continue;
                }
                else
                { /* block id: 214 */
                    (*l_370) = &p_14;
                    /* statement id: 215 */
                    assert (l_368 == &p_14);
                    for (l_469 = (-25); (l_469 == (-12)); l_469 = safe_add_func_uint64_t_u_u(l_469, 8))
                    { /* block id: 218 */
                        int32_t l_500 = 0xD4097EC3L;
                        if (l_500)
                            break;
                    }
                }
                /* facts after branching */
                assert (l_368 == &p_14);
            }
            else
            { /* block id: 222 */
                int32_t **l_503[8] = {&l_368,(void*)0,&l_368,(void*)0,&l_368,(void*)0,&l_368,(void*)0};
                int16_t l_505 = 0x2E4DL;
                int i;
                for (p_16 = 0; (p_16 <= 35); ++p_16)
                { /* block id: 225 */
                    float *l_504[10][10] = {{&l_337.f2,&l_342,&l_342,(void*)0,&l_342,&l_342,&l_337.f2,&l_337.f2,&l_342,&l_342},{&l_342,&l_337.f2,&l_337.f2,&l_342,&l_342,(void*)0,&l_342,&l_342,&l_337.f2,&l_337.f2},{&l_342,&l_337.f2,&l_337.f2,&l_342,&l_342,&l_342,&l_337.f2,(void*)0,&l_337.f2,&l_342},{&l_337.f2,&l_337.f2,&l_342,&l_337.f2,&l_337.f2,&l_342,&l_337.f2,(void*)0,&l_337.f2,&l_342},{(void*)0,(void*)0,&l_342,(void*)0,&l_342,(void*)0,&l_342,(void*)0,(void*)0,&l_342},{&l_337.f2,(void*)0,&l_337.f2,&l_342,&l_337.f2,&l_337.f2,&l_342,&l_337.f2,&l_337.f2,&l_342},{&l_337.f2,(void*)0,&l_337.f2,&l_342,&l_342,&l_342,&l_337.f2,(void*)0,(void*)0,(void*)0},{&l_337.f2,&l_337.f2,(void*)0,(void*)0,(void*)0,&l_337.f2,&l_337.f2,(void*)0,&l_337.f2,(void*)0},{&l_337.f2,(void*)0,&l_337.f2,&l_337.f2,(void*)0,(void*)0,(void*)0,&l_337.f2,&l_337.f2,(void*)0},{(void*)0,(void*)0,&l_337.f2,&l_342,&l_342,&l_342,&l_337.f2,(void*)0,&l_337.f2,&l_342}};
                    int i, j;
                    (*l_370) = &p_14;
                    /* statement id: 226 */
                    assert (l_368 == &p_14);
                    l_505 = 0x1.8p+1;
                    (**l_370) = (&p_14 != &p_14);
                }
                return p_14;
            }
            /* facts after branching */
            assert (l_368 == &p_14);
        }
        /* facts after for loop */
        assert (l_368 == &p_14 || l_368 == &l_369);
    }
    else
    { /* block id: 233 */
        uint16_t l_525 = 65534UL;
        uint32_t l_535 = 0xAFBAB128L;
        float l_564 = 0xD.D1F72Fp+81;
        const int32_t *l_578[10] = {&l_369,&l_369,&l_369,&l_369,&l_369,&l_369,&l_369,&l_369,&l_369,&l_369};
        const int32_t **l_577[6];
        struct S0 l_579 = {25,4828,0x6.65672Ep+38};
        struct S0 *l_623 = &l_337;
        int64_t l_641 = 0x31B3B59E56DAF904LL;
        int32_t *****l_655[4];
        int32_t l_690[2][2] = {{3L,3L},{3L,3L}};
        int i, j;
        for (i = 0; i < 6; i++)
            l_577[i] = &l_578[0];
        for (i = 0; i < 4; i++)
            l_655[i] = &l_644;
        for (l_27 = 0; (l_27 <= 3); l_27 += 1)
        { /* block id: 236 */
            int32_t l_506 = 0x8BBBDEEAL;
            struct S0 *l_530[6][5][8] = {{{&l_337,(void*)0,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,(void*)0,&l_337,&l_337,(void*)0,&l_337,(void*)0,&l_337}},{{(void*)0,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337,&l_337},{&l_337,(void*)0,&l_337,(void*)0,&l_337,&l_337,&l_337,&l_337},{&l_337,(void*)0,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,(void*)0,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337}},{{&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337,&l_337,&l_337},{(void*)0,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337}},{{(void*)0,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,(void*)0},{&l_337,(void*)0,&l_337,&l_337,&l_337,&l_337,(void*)0,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,(void*)0,(void*)0,&l_337,(void*)0,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337,&l_337}},{{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{(void*)0,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337}},{{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337},{&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,&l_337,(void*)0},{&l_337,&l_337,&l_337,&l_337,&l_337,(void*)0,&l_337,&l_337},{&l_337,(void*)0,(void*)0,&l_337,&l_337,(void*)0,&l_337,(void*)0}}};
            int32_t *l_554[4][6] = {{&l_506,&l_506,&l_506,&l_369,&l_506,&l_506},{(void*)0,&l_506,&l_506,(void*)0,&l_506,&l_369},{&l_369,(void*)0,&l_506,(void*)0,&l_369,&l_369},{(void*)0,&l_369,&l_369,&l_369,&l_369,(void*)0}};
            struct S0 *** const *l_572 = &l_426;
            uint32_t l_660 = 0UL;
            int i, j, k;
        }
        if ((safe_add_func_uint8_t_u_u((p_14 && ((**l_629) != &l_623)), (safe_sub_func_int16_t_s_s((safe_mod_func_int16_t_s_s((safe_sub_func_int64_t_s_s(((p_16 < (safe_lshift_func_int8_t_s_s((&l_579 != &l_579), 1))) ^ (safe_add_func_uint64_t_u_u((safe_sub_func_uint32_t_u_u(p_16, (p_14 < (safe_sub_func_int64_t_s_s((0x0E56D7A59D0FFDAALL < 0xE18D10A7D284121ELL), p_15))))), p_15))), l_708[3])), p_15)), p_14)))))
        { /* block id: 358 */
            int32_t *l_709 = &l_690[0][0];
            l_709 = l_709;
        }
        else
        { /* block id: 360 */
            struct S0 **l_710 = &l_428;
            (*l_368) = (l_710 == &l_623);
        }
    }
    /* facts after branching */
    assert (l_368 == &p_14 || l_368 == &l_369);
    for (l_27 = 0; l_27 < 4; l_27 += 1)
    {
        l_427[l_27] = &l_428;
    }
    return p_16;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_19(uint64_t  p_20)
{ /* block id: 1 */
    int16_t l_26 = (-4L);
    return l_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_28(int32_t  p_29)
{ /* block id: 5 */
    float l_36 = 0xD.C51938p-58;
    int32_t l_221 = 0L;
    int32_t * const l_220 = &l_221;
    int32_t *l_224 = &l_221;
    struct S0 l_226 = {29,943,0x2.E24B3Dp-99};
    const struct S0 *l_234 = &l_226;
    const struct S0 ** const l_233[8] = {&l_234,(void*)0,&l_234,(void*)0,&l_234,(void*)0,&l_234,(void*)0};
    const struct S0 ** const *l_232 = &l_233[6];
    const struct S0 ** const l_237 = &l_234;
    const struct S0 ** const *l_236 = &l_237;
    float l_261 = 0x2.2FCB7Dp+19;
    int64_t l_279 = (-8L);
    struct S0 *l_316 = &l_226;
    struct S0 **l_315 = &l_316;
    struct S0 ***l_314 = &l_315;
    uint64_t l_317 = 0xD16942DBF3DB5F00LL;
    struct S0 ****l_332 = &l_314;
    const int32_t *l_334 = &l_221;
    const int32_t **l_333[1][10] = {{(void*)0,(void*)0,&l_334,(void*)0,&l_334,(void*)0,(void*)0,&l_334,(void*)0,&l_334}};
    int32_t *l_335 = (void*)0;
    struct S0 l_336[5][1][7] = {{{{13,3410,0xC.BEEDE6p+75},{13,3410,0xC.BEEDE6p+75},{26,4245,0x9.6p-1},{17,5505,0x0.5p-1},{21,926,0x0.5DB891p+28},{25,433,0x2.0p-1},{13,3410,0xC.BEEDE6p+75}}},{{{13,3410,0xC.BEEDE6p+75},{22,5164,0x3.FE2E7Cp+82},{21,1582,-0x6.Cp+1},{10,1935,-0x1.Ep-1},{26,4245,0x9.6p-1},{26,4245,0x9.6p-1},{10,1935,-0x1.Ep-1}}},{{{13,5014,0x9.2F704Fp+77},{6,5437,0x5.Fp+1},{13,5014,0x9.2F704Fp+77},{31,1357,-0x1.6p-1},{10,1935,-0x1.Ep-1},{13,5014,0x9.2F704Fp+77},{25,433,0x2.0p-1}}},{{{10,1935,-0x1.Ep-1},{6,5437,0x5.Fp+1},{18,4523,0x0.9p-1},{11,3280,0x3.C1A4F4p-68},{6,5437,0x5.Fp+1},{18,70,0x1.552CEBp-48},{6,5437,0x5.Fp+1}}},{{{21,1582,-0x6.Cp+1},{31,1357,-0x1.6p-1},{31,1357,-0x1.6p-1},{21,1582,-0x6.Cp+1},{25,433,0x2.0p-1},{13,5014,0x9.2F704Fp+77},{10,1935,-0x1.Ep-1}}}};
    int i, j, k;
    for (p_29 = 18; (p_29 < (-27)); p_29 = safe_sub_func_int32_t_s_s(p_29, 6))
    { /* block id: 8 */
        uint8_t l_37 = 0x31L;
        int32_t l_39 = (-1L);
        int32_t *l_38 = &l_39;
        int32_t **l_222[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        int32_t **l_223[6][6];
        struct S0 *l_247 = (void*)0;
        const struct S0 **l_253 = &l_234;
        const struct S0 ***l_252 = &l_253;
        const struct S0 ****l_251 = &l_252;
        const struct S0 *****l_250 = &l_251;
        struct S0 l_258 = {20,3897,-0x1.Cp-1};
        struct S0 l_280 = {23,2668,-0x5.Dp+1};
        int i, j;
        for (i = 0; i < 6; i++)
        {
            for (j = 0; j < 6; j++)
                l_223[i][j] = &l_38;
        }
        l_38 = func_32(p_29, l_37, l_38);
        /* statement id: 61 */
        assert (l_38 == 0);
        l_224 = l_220;
        if ((safe_unary_minus_func_uint16_t_u((*l_220))))
        { /* block id: 63 */
            (*l_224) = 1L;
        }
        else
        { /* block id: 65 */
            return l_226;
        }
    }
    l_335 = &l_221;
    /* statement id: 136 */
    assert (l_335 == &l_221);
    return l_336[1][0][5];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_32(int32_t  p_33, float  p_34, int32_t * p_35)
{ /* block id: 9 */
    int32_t l_42 = 0x658069D1L;
    int32_t *l_41 = &l_42;
    int32_t **l_40 = &l_41;
    int32_t *l_60 = &l_42;
    int32_t * const l_205 = &l_42;
    int32_t * const l_206[4] = {&l_42,&l_42,&l_42,&l_42};
    int32_t * const l_207 = &l_42;
    int32_t * const l_208 = &l_42;
    int32_t * const l_209[4] = {&l_42,&l_42,&l_42,&l_42};
    int32_t * const l_210 = &l_42;
    int32_t * const l_211 = &l_42;
    int32_t * const l_212 = &l_42;
    int32_t * const l_213 = &l_42;
    int32_t * const l_214 = &l_42;
    int32_t * const l_215 = &l_42;
    int32_t * const l_216 = &l_42;
    int32_t * const l_217 = &l_42;
    int32_t * const l_218[10][1][4] = {{{&l_42,&l_42,&l_42,&l_42}},{{&l_42,&l_42,&l_42,&l_42}},{{(void*)0,&l_42,&l_42,&l_42}},{{&l_42,&l_42,&l_42,&l_42}},{{&l_42,&l_42,&l_42,&l_42}},{{&l_42,(void*)0,&l_42,(void*)0}},{{(void*)0,&l_42,&l_42,(void*)0}},{{&l_42,(void*)0,&l_42,&l_42}},{{&l_42,&l_42,&l_42,&l_42}},{{&l_42,&l_42,&l_42,&l_42}}};
    int32_t * const l_219 = (void*)0;
    int i, j, k;
    (*l_40) = (void*)0;
    /* statement id: 10 */
    assert (l_41 == 0);
    (*l_40) = func_43(func_47((((safe_add_func_uint8_t_u_u(((((*p_35) != ((safe_rshift_func_int16_t_s_s(p_33, 8)) == ((void*)0 != &p_35))) > 0x67L) & (func_19(l_42) ^ (safe_div_func_uint32_t_u_u((((p_33 > (safe_rshift_func_uint16_t_u_u((((((65529UL || 0xCF74L) == (-1L)) < p_33) > p_33) != 0x100FL), p_33))) ^ p_33) < 4294967291UL), p_33)))), 0UL)) | p_33) | p_33), l_60, p_33, &l_60), p_33, &l_60);
    /* statement id: 59 */
    assert (l_41 == &l_42);
    return l_219;
    /* statement id: 60 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_43(int32_t ** p_44, uint32_t  p_45, int32_t ** p_46)
{ /* block id: 16 */
    int32_t *l_68 = (void*)0;
    int32_t l_84[6] = {0x4C80454FL,0x6E92ECD4L,0x4C80454FL,0x4C80454FL,0x6E92ECD4L,0x4C80454FL};
    int32_t **l_98 = &l_68;
    const int32_t *l_100 = &l_84[3];
    const int32_t **l_99 = &l_100;
    struct S0 l_198 = {30,4282,0x3.25E56Ep+34};
    struct S0 *l_197 = &l_198;
    const uint64_t l_203 = 0UL;
    int i;
    l_68 = (void*)0;
    (*l_98) = func_69(&l_68, func_74(func_80(l_84[4], p_45, p_45), l_98, l_99, (safe_rshift_func_uint16_t_u_s(p_45, 5)), (*p_46)), (*l_98), p_45);
    /* statement id: 46 */
    //assert (l_100 == dangling || (l_100 >= &l_84[0] && l_100 <= &l_84[5]));
    if (((*l_98) == (*l_98)))
    { /* block id: 47 */
        struct S0 l_196 = {7,5393,0x9.1796B5p+27};
        const struct S0 *l_195[10][9][2] = {{{&l_196,&l_196},{&l_196,(void*)0},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,(void*)0},{(void*)0,(void*)0},{&l_196,&l_196}},{{&l_196,&l_196},{&l_196,&l_196},{&l_196,(void*)0},{&l_196,(void*)0},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,(void*)0},{&l_196,(void*)0},{&l_196,&l_196}},{{&l_196,&l_196},{&l_196,&l_196},{&l_196,(void*)0},{(void*)0,(void*)0},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,(void*)0}},{{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,(void*)0},{(void*)0,(void*)0},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196}},{{&l_196,(void*)0},{&l_196,(void*)0},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,(void*)0},{&l_196,(void*)0},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196}},{{&l_196,(void*)0},{(void*)0,(void*)0},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{&l_196,&l_196},{(void*)0,(void*)0},{&l_196,&l_196}},{{(void*)0,&l_196},{(void*)0,&l_196},{&l_196,&l_196},{&l_196,&l_196},{(void*)0,(void*)0},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,&l_196},{&l_196,&l_196}},{{(void*)0,&l_196},{(void*)0,&l_196},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,(void*)0},{(void*)0,&l_196},{&l_196,&l_196}},{{&l_196,&l_196},{(void*)0,&l_196},{(void*)0,&l_196},{&l_196,(void*)0},{(void*)0,&l_196},{(void*)0,(void*)0},{&l_196,&l_196},{(void*)0,&l_196},{(void*)0,&l_196}},{{&l_196,&l_196},{&l_196,&l_196},{(void*)0,(void*)0},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,&l_196},{&l_196,&l_196},{(void*)0,&l_196},{(void*)0,&l_196}}};
        int i, j, k;
        (**p_46) = (safe_sub_func_int16_t_s_s((((p_45 || (l_195[7][6][1] == l_197)) & 0x0FB132EDL) && p_45), (safe_unary_minus_func_int16_t_s(((((safe_mod_func_int64_t_s_s(((&l_196 != (void*)0) > p_45), (safe_unary_minus_func_uint64_t_u(((((p_45 ^ l_203) | 0x964D273EL) & 0xDC16L) || l_196.f0))))) == 7UL) == p_45) && l_196.f1)))));
        (*l_197) = (*l_197);
    }
    else
    { /* block id: 50 */
        int32_t l_204[6][2] = {{0L,1L},{0L,1L},{0L,1L},{0L,1L},{0L,1L},{0L,1L}};
        int i, j;
        for (p_45 = 0; (p_45 <= 5); p_45 += 1)
        { /* block id: 53 */
            int i;
            l_204[1][1] = l_84[p_45];
        }
        (*l_98) = (*p_46);
        /* statement id: 56 */
        //assert (l_68 == &l_42);
    }
    /* facts after branching */
    //assert (l_68 == &l_42 || l_68 == 0);
    return (*p_46);
    /* statement id: 58 */
    //assert (func_43_rv == &l_42);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_47(int32_t  p_48, int32_t * p_49, uint32_t  p_50, int32_t ** p_51)
{ /* block id: 11 */
    int32_t l_66 = (-2L);
    int32_t *l_65[1][7][6] = {{{(void*)0,&l_66,&l_66,&l_66,&l_66,&l_66},{&l_66,&l_66,&l_66,&l_66,&l_66,&l_66},{&l_66,&l_66,&l_66,&l_66,&l_66,&l_66},{(void*)0,&l_66,(void*)0,&l_66,&l_66,&l_66},{&l_66,&l_66,(void*)0,&l_66,&l_66,&l_66},{&l_66,&l_66,&l_66,&l_66,&l_66,&l_66},{&l_66,&l_66,&l_66,&l_66,&l_66,&l_66}}};
    int32_t **l_64 = &l_65[0][2][4];
    int32_t **l_67 = (void*)0;
    int i, j, k;
    return l_67;
    /* statement id: 15 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int32_t ** p_70, int32_t  p_71, const int32_t * p_72, int32_t  p_73)
{ /* block id: 43 */
    struct S0 l_188 = {31,2299,0x9.131220p+54};
    struct S0 *l_187 = &l_188;
    struct S0 **l_189 = &l_187;
    int32_t l_191 = 0xFAE44959L;
    int32_t *l_190 = &l_191;
    int32_t *l_192 = &l_191;
    (*l_189) = l_187;
    return (*p_70);
    /* statement id: 45 */
    //assert (func_69_rv == 0 || func_69_rv == &l_361);
}


/* ------------------------------------------ */
/* 
 * reads : l_42
 * writes: l_42
 */
inline static int32_t  func_74(int32_t ** p_75, int32_t ** p_76, const int32_t ** p_77, int8_t  p_78, int32_t * p_79)
{ /* block id: 21 */
    int32_t l_104 = 0xC7241AB0L;
    int32_t *l_103[3];
    uint64_t l_109 = 0x353B37858094BF1CLL;
    int16_t l_133 = 0xC29DL;
    uint32_t l_138 = 0xD7C4E94CL;
    const uint64_t l_139 = 0x180ABA0674BD75D9LL;
    uint32_t l_140[6][10][4] = {{{18446744073709551614UL,0xCE632A9BL,0xAFFB0DC2L,0x8A31BD4AL},{0x1D218BD4L,0xCE632A9BL,0x1D218BD4L,0x1858A7F6L},{0x46CA2038L,0xAC9A06BDL,0x68F2713CL,18446744073709551615UL},{18446744073709551615UL,0x8A31BD4AL,18446744073709551614UL,0xAC9A06BDL},{0x94BBC9C3L,0xA7083D25L,18446744073709551614UL,0x36BBB4AFL},{18446744073709551615UL,0x1858A7F6L,0x68F2713CL,0xC832F20CL},{0x46CA2038L,0x284727EFL,0x1D218BD4L,1UL},{0x1D218BD4L,1UL,0xAFFB0DC2L,1UL},{18446744073709551614UL,0x284727EFL,0x1E864F27L,0xC832F20CL},{0UL,0x1858A7F6L,0xF0FF9CC6L,0x36BBB4AFL}},{{0x1E864F27L,0xA7083D25L,0x4D05B2ABL,0xAC9A06BDL},{0x1E864F27L,0x8A31BD4AL,0xF0FF9CC6L,18446744073709551615UL},{0UL,0xAC9A06BDL,0x1E864F27L,0x1858A7F6L},{18446744073709551614UL,0xCE632A9BL,0xAFFB0DC2L,0x8A31BD4AL},{0x1D218BD4L,0xCE632A9BL,0x1D218BD4L,0x284727EFL},{18446744073709551615UL,0xA7083D25L,0xAFFB0DC2L,0x1858A7F6L},{1UL,1UL,0x94BBC9C3L,0xA7083D25L},{0x1E864F27L,0x36BBB4AFL,0x94BBC9C3L,0x8A31BD4AL},{1UL,0x284727EFL,0xAFFB0DC2L,0xAC9A06BDL},{18446744073709551615UL,0x35E1D1A9L,0x4D05B2ABL,0xCE632A9BL}},{{0x4D05B2ABL,0xCE632A9BL,0UL,0xCE632A9BL},{0x94BBC9C3L,0x35E1D1A9L,0xF0FF9CC6L,0xAC9A06BDL},{0x1D218BD4L,0x284727EFL,0x46CA2038L,0x8A31BD4AL},{0xF0FF9CC6L,0x36BBB4AFL,18446744073709551614UL,0xA7083D25L},{0xF0FF9CC6L,1UL,0x46CA2038L,0x1858A7F6L},{0x1D218BD4L,0xA7083D25L,0xF0FF9CC6L,0x284727EFL},{0x94BBC9C3L,18446744073709551615UL,0UL,1UL},{0x4D05B2ABL,18446744073709551615UL,0x4D05B2ABL,0x284727EFL},{18446744073709551615UL,0xA7083D25L,0xAFFB0DC2L,0x1858A7F6L},{1UL,1UL,0x94BBC9C3L,0xA7083D25L}},{{0x1E864F27L,0x36BBB4AFL,0x94BBC9C3L,0x8A31BD4AL},{1UL,0x284727EFL,0xAFFB0DC2L,0xAC9A06BDL},{18446744073709551615UL,0x35E1D1A9L,0x4D05B2ABL,0xCE632A9BL},{0x4D05B2ABL,0xCE632A9BL,0UL,0xCE632A9BL},{0x94BBC9C3L,0x35E1D1A9L,0xF0FF9CC6L,0xAC9A06BDL},{0x1D218BD4L,0x284727EFL,0x46CA2038L,0x8A31BD4AL},{0xF0FF9CC6L,0x36BBB4AFL,18446744073709551614UL,0xA7083D25L},{0xF0FF9CC6L,1UL,0x46CA2038L,0x1858A7F6L},{0x1D218BD4L,0xA7083D25L,0xF0FF9CC6L,0x284727EFL},{0x94BBC9C3L,18446744073709551615UL,0UL,1UL}},{{0x4D05B2ABL,18446744073709551615UL,0x4D05B2ABL,0x284727EFL},{18446744073709551615UL,0xA7083D25L,0xAFFB0DC2L,0x1858A7F6L},{1UL,1UL,0x94BBC9C3L,0xA7083D25L},{0x1E864F27L,0x36BBB4AFL,0x94BBC9C3L,0x8A31BD4AL},{1UL,0x284727EFL,0xAFFB0DC2L,0xAC9A06BDL},{18446744073709551615UL,0x35E1D1A9L,0x4D05B2ABL,0xCE632A9BL},{0x4D05B2ABL,0xCE632A9BL,0UL,0xCE632A9BL},{0x94BBC9C3L,0x35E1D1A9L,0xF0FF9CC6L,0xAC9A06BDL},{0x1D218BD4L,0x284727EFL,0x46CA2038L,0x8A31BD4AL},{0xF0FF9CC6L,0x36BBB4AFL,18446744073709551614UL,0xA7083D25L}},{{0xF0FF9CC6L,1UL,0x46CA2038L,0x1858A7F6L},{0x1D218BD4L,0xA7083D25L,0xF0FF9CC6L,0x284727EFL},{0x94BBC9C3L,18446744073709551615UL,0UL,1UL},{0x4D05B2ABL,18446744073709551615UL,0x4D05B2ABL,0x284727EFL},{18446744073709551615UL,0xA7083D25L,0xAFFB0DC2L,0x1858A7F6L},{1UL,1UL,0x94BBC9C3L,0xA7083D25L},{0x1E864F27L,0x36BBB4AFL,0x94BBC9C3L,0x8A31BD4AL},{1UL,0x284727EFL,0xAFFB0DC2L,0xAC9A06BDL},{18446744073709551615UL,0x35E1D1A9L,0x4D05B2ABL,0xCE632A9BL},{0x4D05B2ABL,0xCE632A9BL,0UL,0xCE632A9BL}}};
    const struct S0 l_182[3] = {{8,931,0xA.81A23Fp-56},{8,931,0xA.81A23Fp-56},{8,931,0xA.81A23Fp-56}};
    float l_185 = 0x1.Ap+1;
    uint64_t l_186 = 2UL;
    int i, j, k;
    for (i = 0; i < 3; i++)
        l_103[i] = &l_104;
    (*p_79) = ((l_103[1] == (void*)0) == ((safe_lshift_func_int16_t_s_s((safe_div_func_int16_t_s_s(p_78, l_109)), 12)) <= (p_78 & p_78)));
    if ((safe_mod_func_int8_t_s_s((safe_rshift_func_uint16_t_u_u(p_78, (safe_unary_minus_func_int64_t_s(p_78)))), (safe_add_func_uint8_t_u_u((((((((safe_div_func_int64_t_s_s((2UL == (0xA2L || (0x8DAFL ^ (safe_add_func_int8_t_s_s((safe_rshift_func_uint16_t_u_s((((0xC8B9L && ((safe_rshift_func_uint8_t_u_s(((safe_sub_func_uint8_t_u_u((safe_div_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(l_133, (safe_sub_func_int16_t_s_s((safe_lshift_func_uint8_t_u_u(p_78, (l_138 | p_78))), p_78)))), 2UL)), p_78)) <= 0x70L), p_78)) > p_78)) || p_78) != p_78), p_78)), p_78))))), p_78)) == l_139) != p_78) >= 0x9D47723EL) <= l_140[0][3][1]) > p_78) & 0xD31CL), 0x0EL)))))
    { /* block id: 23 */
        for (l_109 = (-1); (l_109 <= 40); ++l_109)
        { /* block id: 26 */
            struct S0 l_143 = {17,4815,-0x7.8p+1};
            struct S0 *l_144 = &l_143;
            (*l_144) = l_143;
            (*p_77) = &l_104;
            /* statement id: 28 */
            //assert (l_100 == &l_104);
        }
        /* facts after for loop */
        //assert (l_100 == &l_104 || (l_100 >= &l_84[0] && l_100 <= &l_84[5]));
    }
    else
    { /* block id: 30 */
        int32_t l_147 = (-8L);
        struct S0 l_183 = {12,2391,0x9.9FD2C4p-93};
        if ((safe_sub_func_int16_t_s_s(((l_147 < (((safe_sub_func_uint64_t_u_u(((l_147 & ((safe_mod_func_int32_t_s_s(l_147, (0x0D4FL & (l_147 < ((safe_div_func_int8_t_s_s(p_78, (+((((p_78 >= ((p_78 || (safe_add_func_uint8_t_u_u((safe_mod_func_int64_t_s_s((safe_add_func_int64_t_s_s(p_78, p_78)), p_78)), l_147))) < (-1L))) & 5L) <= 18446744073709551615UL) ^ 0UL)))) && p_78))))) && (*p_79))) & p_78), p_78)) & 3L) <= 0x9E36F560471CC743LL)) <= 1UL), p_78)))
        { /* block id: 31 */
            uint64_t l_175 = 0x968B3883621335F7LL;
            if ((safe_add_func_int16_t_s_s((safe_lshift_func_int8_t_s_s((safe_sub_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_u((safe_add_func_int16_t_s_s(((&l_103[1] == (void*)0) | (safe_rshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_u(l_175, 10)), 13))), ((~0L) >= ((~(0x0FAFL > (((safe_sub_func_uint32_t_u_u((p_78 | (!p_78)), (0x2BD8L & (~((p_78 ^ l_175) != (-1L)))))) != p_78) != l_147))) != p_78)))), 14)), (-1L))), p_78)), p_78)))
            { /* block id: 32 */
                return l_147;
            }
            else
            { /* block id: 34 */
                uint32_t l_184 = 7UL;
                l_183 = l_182[0];
                return l_184;
            }
        }
        else
        { /* block id: 38 */
            (*p_79) = l_183.f1;
        }
    }
    /* facts after branching */
    //assert (l_100 == &l_104 || (l_100 >= &l_84[0] && l_100 <= &l_84[5]));
    return l_186;
    /* statement id: 42 */
    //assert (l_100 == dangling || (l_100 >= &l_84[0] && l_100 <= &l_84[5]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_80(int32_t  p_81, int64_t  p_82, int8_t  p_83)
{ /* block id: 18 */
    int32_t l_86 = 0x05F77832L;
    int32_t *l_94[8][2][5] = {{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_86,&l_86,&l_86,&l_86,&l_86}}};
    int32_t **l_93 = &l_94[1][0][4];
    int32_t **l_95[9][2] = {{(void*)0,&l_94[2][1][2]},{(void*)0,(void*)0},{&l_94[2][1][2],(void*)0},{(void*)0,&l_94[2][1][2]},{(void*)0,(void*)0},{&l_94[2][1][2],(void*)0},{(void*)0,&l_94[2][1][2]},{(void*)0,(void*)0},{&l_94[2][1][2],(void*)0}};
    int32_t **l_96 = &l_94[1][0][4];
    int32_t **l_97 = (void*)0;
    int i, j, k;
    l_86 = (((!l_86) < (!(0x4.Cp-1 == (safe_add_func_float_f_f(p_81, (safe_sub_func_float_f_f(((&l_86 != &l_86) > (p_81 == (((-((&l_86 != &l_86) < (p_82 < 0x1.7p-1))) > l_86) >= 0xF.7CD62Fp+59))), p_81))))))) >= (-0x1.Ep-1));
    return l_97;
    /* statement id: 20 */
    //assert (func_80_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 189
   depth: 1, occurrence: 15
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 52
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 12
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 9
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 123
XXX times a bitfields struct on LHS: 5
XXX times a bitfields struct on RHS: 20
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 11

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 110
   depth: 2, occurrence: 19
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1

XXX total number of pointers: 190

XXX times a variable address is taken: 456
XXX times a pointer is dereferenced on RHS: 75
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 20
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 62
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 5
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 19
XXX times a pointer is qualified to be dereferenced: 851

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 160
   level: 2, occurrence: 50
   level: 3, occurrence: 27
   level: 4, occurrence: 11
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 98
XXX number of pointers point to scalars: 73
XXX number of pointers point to structs: 19
XXX percent of pointers has null in alias set: 30.5
XXX average alias set size: 1.33

XXX times a non-volatile is read: 769
XXX times a non-volatile is write: 223
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 101
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 16
   depth: 2, occurrence: 17
   depth: 3, occurrence: 16
   depth: 4, occurrence: 16
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 15.6
XXX percentage an existing variable is used: 84.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

