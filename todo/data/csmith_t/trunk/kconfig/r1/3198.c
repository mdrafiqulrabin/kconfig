/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3024759165
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int64_t  f0;
   uint32_t  f1;
   int32_t  f2;
   int32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static float  func_30(void);
static int32_t * func_34(int32_t * p_35, uint32_t  p_36, uint32_t  p_37, uint32_t  p_38, float  p_39);
static const float  func_41(int64_t  p_42);
inline static int32_t * func_48(int32_t * p_49, int32_t  p_50, int32_t * const  p_51, int32_t  p_52);
inline static int32_t * const  func_56(int32_t  p_57, uint8_t  p_58, int32_t  p_59, const int32_t * p_60);
inline static float  func_69(int32_t * p_70, uint32_t  p_71, const float  p_72, union U0  p_73);
static float  func_74(uint32_t  p_75, int32_t  p_76, int32_t * p_77, int32_t * p_78);
inline static const uint64_t  func_81(int32_t * p_82, const float  p_83);
inline static int32_t * func_89(int32_t * p_90, int32_t * p_91, int64_t  p_92, int32_t * p_93, union U0  p_94);
static int16_t  func_96(int32_t * p_97);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 2L;
    int32_t *l_259 = (void*)0;
    union U0 l_296 = {0xD481397AC89E3CC8LL};
    uint64_t l_302 = 0UL;
    int32_t ***l_307 = (void*)0;
    int32_t ****l_306 = &l_307;
    int32_t *l_310 = &l_31;
    uint32_t l_321 = 18446744073709551615UL;
    for (l_31 = 0; (l_31 >= 22); l_31 += 3)
    { /* block id: 39 */
        int64_t l_40 = 0x80643B8A277EBD00LL;
        int32_t *l_248 = &l_31;
        int32_t **l_247 = &l_248;
        int32_t **l_274 = &l_248;
        int32_t *l_297 = &l_296.f2;
        (*l_247) = func_34(&l_31, __builtin_ffsl(l_40), l_40, l_40, l_40);
        for (l_40 = (-9); (l_40 > 10); l_40++)
        { /* block id: 150 */
            float *l_251 = (void*)0;
            float *l_252 = (void*)0;
            float l_254 = 0x0.4p+1;
            float *l_253 = &l_254;
            (*l_253) = 0xC.25F419p-54;
            return l_31;
        }
        (*l_247) = (*l_247);
        if (((uint16_t)((uint16_t)(**l_247) << (uint16_t)(*l_248)) >> (uint16_t)12))
        { /* block id: 155 */
            int32_t *l_262 = (void*)0;
            (*l_247) = l_262;
            /* statement id: 156 */
            assert (l_248 == 0);
        }
        else
        { /* block id: 157 */
            int32_t l_263 = 1L;
            float *l_264 = (void*)0;
            float l_266 = 0x0.6p-1;
            float *l_265 = &l_266;
            int32_t l_279 = 0xEC49320DL;
            int32_t *l_299 = &l_296.f2;
            int32_t ****l_313 = &l_307;
            (*l_265) = l_263;
            if (l_263)
            { /* block id: 159 */
                int16_t l_271 = 0x02C6L;
                int32_t *l_280 = &l_279;
                if (((uint16_t)(((int16_t)((((void*)0 == l_248) || l_271) > ((uint64_t)((l_274 == (void*)0) | ((int16_t)(l_31 <= ((int64_t)1L + (int64_t)((*l_248) != ((**l_247) == l_271)))) << (int16_t)l_279)) % (uint64_t)l_263)) >> (int16_t)15) && l_271) / (uint16_t)65527UL))
                { /* block id: 160 */
                    int32_t *l_281 = &l_279;
                    (*l_274) = l_280;
                    /* statement id: 161 */
                    assert (l_248 == &l_279);
                    l_280 = l_281;
                }
                else
                { /* block id: 163 */
                    for (l_279 = 0; (l_279 <= 25); l_279 += 3)
                    { /* block id: 166 */
                        int32_t *l_284 = &l_31;
                        int32_t l_286 = 9L;
                        int32_t *l_285 = &l_286;
                        (*l_247) = l_280;
                        /* statement id: 167 */
                        assert (l_248 == &l_279);
                        (*l_285) = func_81(l_284, l_263);
                    }
                    /* facts after for loop */
                    assert (l_248 == &l_279 || l_248 == &l_31);
                }
                /* facts after branching */
                assert (l_248 == &l_279 || l_248 == &l_31);
            }
            else
            { /* block id: 171 */
                int32_t *l_287 = &l_279;
                int32_t l_298 = 1L;
                (*l_287) = (*l_248);
                for (l_263 = (-3); (l_263 == 18); ++l_263)
                { /* block id: 175 */
                    int16_t l_290 = (-1L);
                    int32_t *l_291 = &l_279;
                    union U0 l_303 = {-7L};
                    l_299 = func_89((*l_247), l_297, l_298, l_291, l_296);
                    /* statement id: 176 */
                    assert (l_299 == &l_279);
                    (*l_247) = func_89(func_34(func_34((*l_247), l_31, ((__builtin_parityll((*l_299)) | 1L) ^ (-9L)), (**l_247), ((float)l_302 / (float)((**l_247) > 0x0.Cp-1))), (*l_299), (*l_287), (*l_297), (*l_291)), l_287, (*l_287), l_291, l_303);
                    /* statement id: 177 */
                    assert (l_248 == &l_279);
                }
                /* facts after for loop */
                assert (l_248 == &l_279 || l_248 == &l_31);
                assert (l_299 == &l_279 || l_299 == &l_296.f2);
                (*l_247) = l_287;
                /* statement id: 179 */
                assert (l_248 == &l_279);
            }
            /* facts after branching */
            assert (l_248 == &l_279 || l_248 == &l_31);
            assert (l_299 == &l_279 || l_299 == &l_296.f2);
            for (l_296.f0 = (-22); (l_296.f0 == 22); l_296.f0++)
            { /* block id: 183 */
                int32_t *****l_314 = &l_306;
                int32_t l_320 = 0L;
                (*l_314) = l_313;
                for (l_40 = 0; (l_40 == (-4)); l_40 -= 7)
                { /* block id: 187 */
                    uint16_t l_319 = 0x4528L;
                    (*l_265) = ((float)l_319 + (float)(*l_299));
                }
                l_320 = (**l_274);
            }
        }
        /* facts after branching */
        //assert (l_248 == dangling || l_248 == &l_31 || l_248 == 0);
    }
    return l_321;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(int32_t * p_35, uint32_t  p_36, uint32_t  p_37, uint32_t  p_38, float  p_39)
{ /* block id: 40 */
    const int64_t l_47 = 0xB441791E6E40424BLL;
    uint32_t l_244 = 0x4DA1E438L;
    int32_t l_246 = 0x9D56FFF8L;
    int32_t *l_245 = &l_246;
    l_244 = (func_41(((int16_t)((uint16_t)l_47 + (uint16_t)l_47) >> (int16_t)4)) == (-0x4.Fp-1));
    return p_35;
    /* statement id: 146 */
    //assert (func_34_rv == &l_31 || func_34_rv == &l_279);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const float  func_41(int64_t  p_42)
{ /* block id: 41 */
    int32_t l_54 = 0L;
    int32_t *l_53 = &l_54;
    float l_55 = (-0x1.0p+1);
    uint32_t l_61 = 0xCA3C47AAL;
    const int32_t *l_151 = &l_54;
    const int32_t **l_150 = &l_151;
    float *l_153 = &l_55;
    float **l_152 = &l_153;
    float ***l_154 = &l_152;
    (*l_150) = func_48(l_53, (*l_53), func_56(p_42, l_61, p_42, &l_54), p_42);
    (*l_154) = l_152;
    if ((4UL != (((int32_t)((int16_t)1L << (int16_t)(((uint64_t)(func_96(&l_54) != (65534UL | 0xD4D5L)) - (uint64_t)((int64_t)((int16_t)(&l_152 == (void*)0) - (int16_t)((int16_t)((uint16_t)((*l_154) != (*l_154)) / (uint16_t)p_42) - (int16_t)0x2EDFL)) / (int64_t)(*l_53))) != p_42)) - (int32_t)0xFF48D525L) != p_42)))
    { /* block id: 92 */
        int32_t *l_173 = &l_54;
        union U0 *l_175 = (void*)0;
        union U0 **l_176 = &l_175;
        uint32_t l_187 = 0xEE2B1DE1L;
        int32_t l_188 = 0x8F2FF10FL;
        int32_t l_189 = 0x6A62F802L;
        int32_t l_190 = 0x68717530L;
        union U0 * const *l_211 = &l_175;
        union U0 * const **l_210 = &l_211;
        for (l_61 = 0; (l_61 <= 35); ++l_61)
        { /* block id: 95 */
            int32_t *l_174 = &l_54;
            for (p_42 = 0; (p_42 == 27); p_42++)
            { /* block id: 98 */
                l_174 = l_173;
                (*l_173) = (**l_150);
            }
            if ((*l_174))
                break;
            (*l_150) = l_173;
        }
        (*l_176) = l_175;
        if (((int32_t)((((uint16_t)((int64_t)((uint16_t)(*l_151) >> (uint16_t)p_42) % (int64_t)((int16_t)((l_187 <= l_188) & 0x64DAL) + (int16_t)(__builtin_ia32_crc32qi((*l_151), (*l_173)) <= ((((*l_173) != 0x2604F267A080896FLL) || p_42) || 1UL)))) / (uint16_t)l_189) & 0L) ^ p_42) + (int32_t)p_42))
        { /* block id: 106 */
            uint16_t l_191 = 0x7596L;
            int32_t **l_207 = &l_173;
            union U0 * const *l_209 = &l_175;
            union U0 * const **l_208 = &l_209;
            (*l_207) = func_56(l_190, ((l_191 | p_42) && (+((((__builtin_parityl(((int32_t)((uint16_t)((uint16_t)((int16_t)(p_42 || 18446744073709551610UL) << (int16_t)((int16_t)1L << (int16_t)12)) >> (uint16_t)7) / (uint16_t)__builtin_clzl((((uint16_t)(*l_151) << (uint16_t)5) == ((int64_t)0xFA8D9A8E3B28269CLL % (int64_t)0x43CD125F292E6882LL)))) / (int32_t)1UL)) != 65535UL) < 0x0EE195F76F4719CELL) <= 0x1DBC530126A6CC7BLL) ^ l_191))), p_42, &l_190);
            /* statement id: 107 */
            assert (l_173 == 0);
            (*l_53) = (*l_53);
            l_210 = l_208;
            /* statement id: 109 */
            assert (l_210 == &l_209);
            for (l_189 = 16; (l_189 != 3); l_189 -= 1)
            { /* block id: 112 */
                uint16_t l_225 = 1UL;
                int32_t *l_238 = (void*)0;
                (*l_210) = (*l_208);
            }
        }
        else
        { /* block id: 131 */
            (*l_154) = (*l_154);
            (*l_150) = (*l_150);
        }
        /* facts after branching */
        assert (l_173 == &l_54 || l_173 == 0);
        //assert (l_210 == &l_211 || l_210 == dangling);
        (*l_150) = (void*)0;
        /* statement id: 135 */
        assert (l_151 == 0);
    }
    else
    { /* block id: 136 */
        int32_t l_240 = 0xDD06A0EAL;
        int32_t ***l_241 = (void*)0;
        const int32_t *l_242 = &l_54;
        (***l_154) = l_240;
        if ((l_241 != (void*)0))
        { /* block id: 138 */
            l_242 = (*l_150);
        }
        else
        { /* block id: 140 */
            int32_t *l_243 = &l_54;
            (*l_150) = l_243;
        }
    }
    /* facts after branching */
    assert (l_151 == &l_54 || l_151 == 0);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_48(int32_t * p_49, int32_t  p_50, int32_t * const  p_51, int32_t  p_52)
{ /* block id: 49 */
    int32_t *l_66 = (void*)0;
    union U0 l_147 = {1L};
    l_66 = p_49;
    /* statement id: 50 */
    //assert (l_66 == &l_54);
    (*l_66) = ((__builtin_ctz(p_52) > (p_52 == ((void*)0 == l_66))) != ((float)0x5.5p-1 + (float)func_69(p_49, (*l_66), func_74(((uint64_t)func_81(l_66, (*l_66)) + (uint64_t)0x80219EAC3B263C45LL), p_52, l_66, p_49), l_147)));
    return p_49;
    /* statement id: 89 */
    //assert (func_48_rv == &l_54);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const  func_56(int32_t  p_57, uint8_t  p_58, int32_t  p_59, const int32_t * p_60)
{ /* block id: 42 */
    int32_t * const l_65 = (void*)0;
    for (p_59 = 0; (p_59 > 5); p_59 += 6)
    { /* block id: 45 */
        int32_t *l_64 = (void*)0;
        l_64 = &p_57;
        /* statement id: 46 */
        assert (l_64 == &p_57);
    }
    return l_65;
    /* statement id: 48 */
    //assert (func_56_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_69(int32_t * p_70, uint32_t  p_71, const float  p_72, union U0  p_73)
{ /* block id: 85 */
    int32_t *l_148 = (void*)0;
    int32_t **l_149 = &l_148;
    (*l_149) = l_148;
    return p_73.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_74(uint32_t  p_75, int32_t  p_76, int32_t * p_77, int32_t * p_78)
{ /* block id: 81 */
    int32_t l_144 = 0L;
    int32_t *l_143 = &l_144;
    float l_146 = 0x1.8EC64Ap-23;
    float *l_145 = &l_146;
    (*l_143) = 0L;
    (*l_145) = 0x7.Bp+1;
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads : l_54 l_31
 * writes:
 */
inline static const uint64_t  func_81(int32_t * p_82, const float  p_83)
{ /* block id: 51 */
    int16_t l_84 = 0xD983L;
    int32_t l_86 = 0x64F5774DL;
    int32_t *l_85 = &l_86;
    float l_132 = 0x9.Dp+1;
    float *l_131 = &l_132;
    float * const l_135 = (void*)0;
    const int64_t l_142 = 0xBB8A93D2D6DA1B12LL;
    (*l_85) = (l_84 < l_84);
    for (l_84 = 0; (l_84 != (-10)); l_84 -= 5)
    { /* block id: 55 */
        int32_t *l_95 = (void*)0;
        union U0 l_109 = {-7L};
        int32_t **l_129 = (void*)0;
        int32_t **l_130 = &l_85;
        (*l_130) = func_89(p_82, p_82, ((((void*)0 != l_95) || func_96(p_82)) != (((int16_t)((*l_85) != ((uint16_t)((func_96(p_82) == 0x7C7BD553F327E0E8LL) <= (*l_85)) << (uint16_t)3)) << (int16_t)15) >= (*l_85))), &l_86, l_109);
    }
    (*l_131) = p_83;
    if (((uint32_t)((void*)0 == l_135) - (uint32_t)__builtin_ctzl(((*l_85) & (*l_85)))))
    { /* block id: 69 */
        int32_t **l_138 = &l_85;
        for (l_86 = 0; (l_86 == 8); l_86 += 4)
        { /* block id: 72 */
            if ((*p_82))
                break;
        }
        (*l_138) = &l_86;
    }
    else
    { /* block id: 76 */
        int32_t *l_139 = &l_86;
        int32_t **l_140 = &l_85;
        const uint32_t l_141 = 18446744073709551613UL;
        (*l_140) = l_139;
        return l_141;
    }
    return l_142;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_89(int32_t * p_90, int32_t * p_91, int64_t  p_92, int32_t * p_93, union U0  p_94)
{ /* block id: 60 */
    int32_t l_115 = (-3L);
    int32_t *l_114 = &l_115;
    int32_t **l_122 = &l_114;
    int32_t * const *l_125 = &l_114;
    int32_t * const **l_124 = &l_125;
    int32_t * const ***l_123 = &l_124;
    int32_t *l_128 = (void*)0;
    (*l_122) = func_56(((uint16_t)((int16_t)(l_114 != p_93) << (int16_t)6) % (uint16_t)((uint64_t)(*l_114) % (uint64_t)((((p_94.f2 != ((uint32_t)((uint64_t)(func_96(p_93) ^ ((void*)0 == p_91)) - (uint64_t)p_94.f3) / (uint32_t)(*l_114))) < (*l_114)) != (*l_114)) || p_94.f1))), p_94.f3, p_94.f2, p_93);
    /* statement id: 61 */
    assert (l_114 == 0);
    (*l_123) = &l_122;
    /* statement id: 62 */
    assert (l_124 == &l_122);
    (*p_93) = ((uint16_t)p_94.f3 >> (uint16_t)14);
    (*l_122) = l_128;
    return p_93;
    /* statement id: 65 */
    //assert (func_89_rv == &l_86 || func_89_rv == &l_279);
}


/* ------------------------------------------ */
/* 
 * reads : l_54 l_86 l_31 l_279
 * writes:
 */
static int16_t  func_96(int32_t * p_97)
{ /* block id: 56 */
    float l_101 = 0x3.51060Fp+45;
    int32_t l_102 = 0xBD639B6AL;
    int32_t *l_103 = &l_102;
    uint32_t l_104 = 0xB35667B2L;
    (*l_103) = (!((uint16_t)__builtin_popcount(l_102) >> (uint16_t)4));
    (*l_103) = (*p_97);
    return l_104;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 79
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 16
   depth: 3, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 85

XXX times a variable address is taken: 66
XXX times a pointer is dereferenced on RHS: 58
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 6
XXX times a pointer is dereferenced on LHS: 50
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 1
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 11
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 2
XXX times a pointer is qualified to be dereferenced: 253

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 221
   level: 2, occurrence: 20
   level: 3, occurrence: 5
   level: 4, occurrence: 5
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.1
XXX average alias set size: 1.34

XXX times a non-volatile is read: 315
XXX times a non-volatile is write: 125
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 16
   depth: 2, occurrence: 18
   depth: 3, occurrence: 10
   depth: 4, occurrence: 6
   depth: 5, occurrence: 2

XXX percentage a fresh-made variable is used: 20
XXX percentage an existing variable is used: 80
********************* end of statistics **********************/

