/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2644796579
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 16;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_11 = 0x4351CDCB;
static struct S0 g_63 = {11};
static int16_t g_66 = 0;
static uint32_t g_103 = 0x47F69394;
static uint32_t g_122 = 1U;
static int16_t g_132 = 0;
static int32_t g_136 = 4;
static struct S0 g_144 = {-54};
static uint32_t g_216 = 0x813D15A9;
static struct S0 g_402 = {230};
static int32_t g_511 = 0x50C91945;


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_31(void);
static uint32_t  func_37(int32_t  p_38, int16_t  p_39, struct S0  p_40);
static int32_t  func_45(uint16_t  p_46);
static int16_t  func_51(int16_t  p_52, int32_t  p_53, int16_t  p_54, uint32_t  p_55);
static uint32_t  func_58(struct S0  p_59, uint32_t  p_60, uint32_t  p_61, uint32_t  p_62);
static int16_t  func_64(int16_t  p_65);
static int16_t  func_72(struct S0  p_73, uint32_t  p_74, int16_t  p_75, int32_t  p_76);
static struct S0  func_77(struct S0  p_78);
static struct S0  func_79(uint32_t  p_80, struct S0  p_81, int16_t  p_82, int32_t  p_83, uint32_t  p_84);
static struct S0  func_85(int32_t  p_86, uint32_t  p_87, int32_t  p_88);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_11 g_63 g_66 g_103 g_136 g_132 g_122 g_144.f0 g_216 g_144 g_402 g_511
 * writes: g_66 g_103 g_122 g_132 g_144 g_136 g_216 g_402 g_63.f0 g_511 g_63
 */
static uint32_t  func_31(void)
{ /* block id: 36 */
    int16_t l_34 = 1;
    int32_t l_35 = 0xAB1D6A56;
    uint32_t l_36 = 0U;
    uint16_t l_47 = 65535U;
    int32_t l_478 = (-8);
    struct S0 l_479 = {-111};
    uint16_t l_566 = 1U;
    int32_t l_575 = 1;
    l_35 = ((int32_t)(l_34 <= g_11) % (int32_t)4294967295U);
    l_36 = (-1);
    l_478 = (func_37(((((int16_t)9 >> (int16_t)12) >= ((l_35 ^ l_34) & ((0x082B & (func_45(l_47) >= l_35)) == ((((int16_t)((__builtin_popcount((0x9C72 > func_51(((uint32_t)g_11 - (uint32_t)l_478), g_11, g_11, g_11))) ^ g_11) >= g_11) >> (int16_t)13) <= l_47) ^ g_11)))) < l_478), g_11, l_479) | 0x91ADDB15);
    if (((int16_t)l_478 - (int16_t)g_66))
    { /* block id: 296 */
        int16_t l_482 = 0x62B5;
        int32_t l_485 = 3;
        l_478 = g_144.f0;
        l_485 = func_51(l_482, (((l_482 >= ((4294967293U >= g_103) >= (~(!g_402.f0)))) < ((0x626E && ((g_103 || 4U) | 0x3A076FDE)) ^ g_136)) | l_482), g_66, g_136);
        return l_34;
    }
    else
    { /* block id: 300 */
        uint16_t l_489 = 1U;
        uint32_t l_512 = 0U;
        int16_t l_541 = 0xAD27;
        struct S0 l_567 = {-76};
        int32_t l_574 = 7;
        uint32_t l_576 = 0xF2052E56;
        for (l_34 = (-9); (l_34 < (-9)); l_34 += 1)
        { /* block id: 303 */
            l_478 = (-(uint32_t)(0U & l_36));
            g_144.f0 = l_489;
        }
        for (l_47 = 0; (l_47 != 32); l_47 += 1)
        { /* block id: 309 */
            uint16_t l_496 = 65528U;
            uint16_t l_516 = 0x5E69;
            struct S0 l_527 = {-187};
            int32_t l_563 = 4;
            if (g_66)
            { /* block id: 310 */
                return g_402.f0;
            }
            else
            { /* block id: 312 */
                int32_t l_495 = 0xAFCDE24B;
                for (l_478 = (-25); (l_478 != (-5)); l_478 += 1)
                { /* block id: 315 */
                    uint16_t l_494 = 0x1DE3;
                    g_402 = func_77(g_402);
                    l_495 = l_494;
                }
            }
            if ((func_58(g_63, l_496, g_66, g_144.f0) || (((int32_t)0 % (int32_t)g_103) ^ func_51(g_216, l_489, l_489, g_136))))
            { /* block id: 320 */
                uint16_t l_508 = 0x79A4;
                int32_t l_513 = (-2);
                l_513 = ((((uint16_t)((uint16_t)l_489 << (uint16_t)14) % (uint16_t)g_132) >= (((!((9 | ((int16_t)0xF431 % (int16_t)((int16_t)l_508 >> (int16_t)(g_136 != l_478)))) > (((uint16_t)((1 > ((__builtin_ctzl(((((((((((-1) ^ g_511) > g_103) & 0xF9D1) > 0x274A17F9) <= l_512) > 0x66B2) <= g_11) || 0x6DCDDF07) || l_508)) >= l_496) < l_512)) == l_496) % (uint16_t)0x8828) && 0x9B82))) == 0xDE27) || l_489)) & l_496);
            }
            else
            { /* block id: 322 */
                uint32_t l_528 = 0x47072663;
                for (g_511 = (-13); (g_511 <= 7); g_511 += 9)
                { /* block id: 325 */
                    int32_t l_539 = 0;
                    int32_t l_551 = (-5);
                    if (l_496)
                        break;
                    l_478 = ((l_35 > l_496) < l_516);
                    g_63.f0 = ((int16_t)((((((g_136 <= 0x4141430C) >= ((int16_t)g_103 >> (int16_t)13)) == g_63.f0) >= ((int16_t)g_11 << (int16_t)(g_66 ^ (g_402.f0 >= (((0x9E33 == (((uint16_t)((uint16_t)(func_37((0x3CF5190F || (-1)), g_511, l_527) < l_528) - (uint16_t)0x2851) >> (uint16_t)g_136) ^ 3U)) >= 2U) <= 0x708A))))) > 9U) ^ l_489) << (int16_t)4);
                    if ((6 & ((int32_t)0 + (int32_t)(g_511 | 0x4042))))
                    { /* block id: 329 */
                        int16_t l_550 = 0xE345;
                        if (g_144.f0)
                            break;
                        l_541 = ((int16_t)(((int16_t)0xB55F << (int16_t)4) != ((l_489 && 0) || ((int32_t)(4294967290U > ((g_132 && (((int32_t)l_539 - (int32_t)g_11) ^ 0x9A606DFF)) & (!((65535U ^ 8U) == l_512)))) + (int32_t)g_402.f0))) - (int16_t)g_11);
                        g_402.f0 = (g_216 && 0x5C68B403);
                        l_551 = func_64((((int16_t)((int16_t)g_66 - (int16_t)((int16_t)l_496 << (int16_t)5)) % (int16_t)(l_528 ^ ((uint16_t)g_66 + (uint16_t)(__builtin_bswap64(g_132) && (func_37((0x17AE839D != 0x96AFF191), (l_550 | g_11), g_402) == (-1)))))) && 65535U));
                    }
                    else
                    { /* block id: 334 */
                        uint32_t l_552 = 0x09849912;
                        l_552 = (g_144.f0 | (l_34 >= 0x00796485));
                        g_402 = func_85(func_58(l_527, (0x923E125C < (g_136 != (0U >= (l_36 == (((int16_t)((int16_t)((int16_t)((uint16_t)l_551 + (uint16_t)((((int16_t)(l_563 || func_72(func_85(l_541, g_216, g_122), g_144.f0, l_552, l_541)) << (int16_t)14) > l_539) <= l_512)) >> (int16_t)15) << (int16_t)l_512) % (int16_t)g_122) <= g_122))))), l_479.f0, l_551), g_511, g_136);
                    }
                }
                g_63 = func_85(((4294967290U > (func_45(__builtin_bswap32(l_563)) && (g_136 == ((int16_t)func_72(g_63, g_402.f0, l_528, l_35) + (int16_t)g_132)))) <= l_512), l_566, l_528);
                return l_563;
            }
            l_567 = l_567;
            g_144.f0 = g_132;
        }
        g_144.f0 = ((func_37(((g_122 <= ((int16_t)(g_216 & ((0x7572AA4D <= (((uint16_t)((((int16_t)l_574 - (int16_t)l_575) > g_11) == (g_132 & l_574)) >> (uint16_t)5) | (((l_35 == l_576) > l_36) < l_478))) == l_478)) >> (int16_t)g_132)) >= 1), g_216, l_567) || g_66) | l_512);
        g_144 = g_144;
    }
    return g_144.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_37(int32_t  p_38, int16_t  p_39, struct S0  p_40)
{ /* block id: 293 */
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_11 g_63 g_66 g_103 g_136 g_132 g_122 g_144.f0 g_216 g_144 g_402
 * writes: g_66 g_103 g_122 g_132 g_144 g_136 g_216 g_402 g_63.f0
 */
static int32_t  func_45(uint16_t  p_46)
{ /* block id: 39 */
    uint32_t l_48 = 1U;
    int32_t l_49 = 0xC935CB51;
    uint16_t l_452 = 0U;
    struct S0 l_466 = {-13};
    l_49 = l_48;
    l_49 = (((__builtin_ia32_crc32qi((~(g_11 != ((__builtin_popcountl(((p_46 < func_51(((uint32_t)(p_46 >= func_58(g_63, (0xCFE9 & func_64(g_63.f0)), p_46, g_11)) % (uint32_t)p_46), g_11, g_11, l_49)) == 0xED60)) == 0xF6CC) & l_48))), g_63.f0) | p_46) != 0x433A4AB1) < g_63.f0);
    for (g_132 = 13; (g_132 == (-14)); g_132 -= 1)
    { /* block id: 282 */
        uint32_t l_455 = 8U;
        l_49 = p_46;
        l_49 = (((((func_51(((int16_t)func_51(((((uint16_t)(l_452 ^ g_66) >> (uint16_t)(0x0130 >= (((uint16_t)l_455 << (uint16_t)13) || (p_46 >= ((uint32_t)(__builtin_popcountll(p_46) || ((int16_t)l_452 << (int16_t)((int16_t)(g_66 < l_455) >> (int16_t)5))) - (uint32_t)l_455))))) != l_455) && 0x943B92CE), l_49, p_46, g_122) % (int16_t)p_46), g_136, p_46, l_455) ^ 65535U) <= 0xA2865CCB) != 0) > 0) ^ p_46);
    }
    for (l_49 = (-11); (l_49 < (-3)); l_49 += 2)
    { /* block id: 288 */
        int32_t l_473 = 0x6BA82F9B;
        g_63.f0 = ((uint16_t)1U - (uint16_t)p_46);
        l_466.f0 = (p_46 == func_72(func_77(l_466), g_216, p_46, ((!((((((((p_46 ^ ((uint32_t)0x539550EE + (uint32_t)((int16_t)(p_46 ^ (!((0x32903D48 > l_48) > g_402.f0))) % (int16_t)p_46))) != p_46) > l_473) ^ 0xCD5688CF) != g_63.f0) <= g_122) ^ l_48) < 0x9686)) ^ 0xBCDFE71D)));
    }
    return p_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_11
 * writes:
 */
static int16_t  func_51(int16_t  p_52, int32_t  p_53, int16_t  p_54, uint32_t  p_55)
{ /* block id: 277 */
    return g_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_144 g_66 g_103 g_11 g_63.f0 g_136 g_132 g_63
 * writes: g_103 g_122 g_132
 */
static uint32_t  func_58(struct S0  p_59, uint32_t  p_60, uint32_t  p_61, uint32_t  p_62)
{ /* block id: 273 */
    struct S0 l_440 = {-59};
    int32_t l_441 = (-1);
    struct S0 l_442 = {-112};
    uint32_t l_445 = 4294967293U;
    l_440 = g_144;
    p_59 = func_79(l_441, l_442, ((uint16_t)p_60 % (uint16_t)p_61), (((((l_440.f0 || l_441) && l_445) || (g_66 | p_62)) > 2U) > g_144.f0), l_445);
    return l_440.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_63.f0 g_11 g_66 g_103 g_136 g_132 g_63 g_122 g_144.f0 g_216 g_144 g_402
 * writes: g_66 g_103 g_122 g_132 g_144 g_136 g_216 g_402
 */
static int16_t  func_64(int16_t  p_65)
{ /* block id: 41 */
    int16_t l_71 = (-1);
    int32_t l_205 = 0x9AB21B83;
    struct S0 l_206 = {151};
    uint32_t l_209 = 5U;
    int32_t l_303 = (-1);
    int32_t l_370 = 0xBA54FB76;
    uint32_t l_385 = 0x7893A2BE;
    int16_t l_389 = 0;
    uint32_t l_393 = 0U;
    uint32_t l_437 = 4294967295U;
    g_66 = p_65;
    if (((uint16_t)((65526U < (((((((int32_t)(l_71 ^ func_72(func_77(func_79(g_63.f0, func_85(l_71, p_65, ((uint16_t)__builtin_ctz(l_71) % (uint16_t)g_11)), p_65, g_11, l_71)), g_11, g_11, g_11)) % (int32_t)g_63.f0) & l_71) <= g_63.f0) || 65535U) <= 0xF591B348) <= p_65)) >= p_65) >> (uint16_t)5))
    { /* block id: 120 */
        g_144.f0 = g_144.f0;
    }
    else
    { /* block id: 122 */
        int32_t l_199 = 0x01BE7251;
        int32_t l_213 = 9;
        if (p_65)
        { /* block id: 123 */
            uint32_t l_204 = 0U;
            int32_t l_210 = 0x478F368B;
            l_205 = ((((int32_t)(((p_65 != (((((g_132 > (((l_199 >= g_122) != (p_65 & 0xEA04)) > ((int16_t)((uint32_t)g_66 % (uint32_t)0x42BC8F80) << (int16_t)15))) <= ((l_204 && p_65) != g_136)) >= g_144.f0) ^ l_204) > g_132)) | p_65) > g_66) - (int32_t)4294967286U) <= l_71) && l_71);
            g_144.f0 = p_65;
            l_210 = (p_65 == ((l_205 || ((((func_72(l_206, func_72(l_206, l_199, g_136, (((int16_t)g_144.f0 - (int16_t)p_65) != __builtin_ffsl((l_209 > 0xE09FDA15)))), p_65, g_103) >= 1) && g_122) >= g_132) > l_199)) | p_65));
            l_213 = (g_144.f0 || ((int16_t)l_209 >> (int16_t)8));
        }
        else
        { /* block id: 128 */
            uint32_t l_219 = 0x91A48057;
            for (l_199 = 0; (l_199 < 8); l_199 += 1)
            { /* block id: 131 */
                struct S0 l_222 = {0};
                g_216 = p_65;
                for (g_122 = (-10); (g_122 != 60); g_122 += 1)
                { /* block id: 135 */
                    l_206.f0 = (l_219 && (g_122 && l_71));
                    g_144.f0 = l_71;
                    for (l_209 = 16; (l_209 >= 12); l_209 -= 3)
                    { /* block id: 140 */
                        l_222 = l_206;
                    }
                }
            }
        }
        l_206.f0 = (0xAB12DF45 != g_11);
        return l_199;
    }
    if (((~0xC7CCF952) == (g_136 == (!((uint16_t)(!((((func_72(l_206, ((p_65 > (func_72(l_206, l_71, ((uint16_t)(4294967289U && (((int16_t)((int16_t)(((int16_t)(-1) << (int16_t)14) | (p_65 >= 0)) << (int16_t)g_132) - (int16_t)p_65) ^ l_209)) >> (uint16_t)14), p_65) <= l_71)) & l_209), p_65, p_65) || 0xA5B556FB) >= l_71) <= p_65) > l_205)) - (uint16_t)0x4B05)))))
    { /* block id: 149 */
        int32_t l_244 = 0;
        int32_t l_256 = (-1);
        int16_t l_257 = 0xCE79;
        int16_t l_258 = 0x14B7;
        struct S0 l_272 = {251};
        g_144.f0 = (((uint16_t)0x02F1 % (uint16_t)((int16_t)(1 == (l_71 >= (((((-2) < ((int32_t)(((l_244 <= (((int16_t)((p_65 || ((uint16_t)0U << (uint16_t)((uint32_t)((int16_t)(-(uint16_t)__builtin_parity(((((uint16_t)(g_136 != p_65) + (uint16_t)0x3F8A) != p_65) ^ 4294967295U))) % (int16_t)p_65) - (uint32_t)p_65))) & p_65) + (int16_t)0x32F3) & g_132)) < p_65) > l_205) - (int32_t)l_256)) > l_244) & g_63.f0) == p_65))) - (int16_t)l_257)) == 1U);
        l_258 = p_65;
        for (l_71 = 0; (l_71 < 16); l_71 += 3)
        { /* block id: 154 */
            struct S0 l_273 = {11};
            g_144 = g_63;
            for (l_209 = 15; (l_209 != 1); l_209 -= 1)
            { /* block id: 158 */
                uint32_t l_269 = 4294967291U;
                for (g_132 = (-29); (g_132 < (-30)); g_132 -= 7)
                { /* block id: 161 */
                    l_205 = __builtin_bswap64(g_216);
                    l_273 = func_85((((int32_t)((((uint16_t)l_269 << (uint16_t)5) & ((int16_t)(((0xC1EE57A3 || (-1)) & p_65) & (l_257 | l_206.f0)) >> (int16_t)5)) || func_72(l_272, g_136, g_103, g_11)) + (int32_t)4294967295U) >= 0x31EF28FA), g_122, p_65);
                }
                for (p_65 = 0; (p_65 > 10); p_65 += 1)
                { /* block id: 167 */
                    for (l_256 = (-17); (l_256 >= (-4)); l_256 += 1)
                    { /* block id: 170 */
                        uint32_t l_282 = 5U;
                        g_144.f0 = p_65;
                        g_144.f0 = ((((uint16_t)((g_63.f0 == ((0x5F8E > ((int16_t)2 + (int16_t)0x10C4)) > l_282)) != 1) + (uint16_t)((uint16_t)(((l_282 <= l_209) <= (p_65 | p_65)) && 0x662FD861) << (uint16_t)5)) != 1) <= p_65);
                    }
                    return g_216;
                }
                if (g_132)
                    continue;
                if (p_65)
                    break;
            }
            for (g_103 = 20; (g_103 >= 53); g_103 += 1)
            { /* block id: 181 */
                struct S0 l_287 = {-122};
                g_144 = l_287;
                g_144.f0 = (p_65 || l_272.f0);
                l_205 = 0xF81FE05B;
            }
            l_273.f0 = l_258;
        }
    }
    else
    { /* block id: 188 */
        int32_t l_290 = (-7);
        struct S0 l_291 = {86};
        uint16_t l_311 = 4U;
        for (l_209 = (-11); (l_209 >= 33); l_209 += 4)
        { /* block id: 191 */
            int16_t l_300 = 0x523E;
            struct S0 l_304 = {161};
            g_144 = l_206;
            l_304 = func_79(l_290, l_291, ((int16_t)(((-1) == g_11) ^ func_72(l_291, (((int16_t)l_291.f0 << (int16_t)(((uint32_t)((int16_t)l_300 << (int16_t)(l_300 == ((int16_t)(0x1D29F471 | l_209) >> (int16_t)8))) + (uint32_t)l_290) == 8U)) | p_65), l_303, l_291.f0)) + (int16_t)0x1945), g_136, p_65);
        }
        if ((((p_65 == g_216) ^ ((uint16_t)((g_122 & ((__builtin_bswap32(g_136) == ((int16_t)(g_63.f0 < __builtin_ffsl(((int32_t)((g_66 < 1) <= func_72(l_291, l_206.f0, l_311, l_206.f0)) % (int32_t)p_65))) << (int16_t)p_65)) < 1U)) == p_65) >> (uint16_t)p_65)) != g_11))
        { /* block id: 195 */
            uint16_t l_323 = 0xAB58;
            struct S0 l_326 = {-154};
            l_291 = func_77(g_144);
            for (l_311 = 0; (l_311 == 41); l_311 += 1)
            { /* block id: 199 */
                int32_t l_320 = 1;
                int32_t l_384 = 3;
                int32_t l_388 = (-9);
                if ((((((int32_t)l_71 % (int32_t)((int16_t)(g_136 ^ l_291.f0) << (int16_t)(((int32_t)7 % (int32_t)(g_66 | 0x2D52900F)) == p_65))) != func_72(func_85(l_320, ((int16_t)l_323 << (int16_t)10), g_122), g_136, l_320, g_122)) != p_65) < 2))
                { /* block id: 200 */
                    struct S0 l_328 = {153};
                    g_144.f0 = ((int32_t)g_103 - (int32_t)p_65);
                    l_326 = l_326;
                    l_328 = func_79(p_65, l_326, ((g_136 < (~(p_65 | func_72(l_326, g_66, p_65, g_216)))) >= 0xDA1DA1CF), g_132, g_66);
                    if (p_65)
                        continue;
                }
                else
                { /* block id: 205 */
                    int32_t l_353 = (-3);
                    for (p_65 = 0; (p_65 == (-17)); p_65 -= 1)
                    { /* block id: 208 */
                        struct S0 l_342 = {46};
                        g_144.f0 = ((uint32_t)l_290 - (uint32_t)((int16_t)(~((-(uint16_t)(!((uint16_t)((int32_t)((-1) != l_320) + (int32_t)3) << (uint16_t)(g_216 || 0)))) < (func_72(l_342, ((g_216 & l_323) >= l_342.f0), g_216, p_65) < 0x638F))) - (int16_t)0x4F99));
                        l_326.f0 = (((int16_t)l_320 % (int16_t)(l_320 || (((((int32_t)((int32_t)l_342.f0 - (int32_t)((int16_t)g_11 << (int16_t)11)) + (int32_t)(0U >= ((int32_t)l_353 % (int32_t)(g_122 || ((!((uint16_t)__builtin_parityll(p_65) >> (uint16_t)g_63.f0)) != 0x0EF1))))) ^ p_65) >= g_11) < p_65))) ^ g_11);
                    }
                    if (g_103)
                        break;
                    if ((((int32_t)l_320 - (int32_t)p_65) > ((-1) >= 4294967291U)))
                    { /* block id: 213 */
                        uint32_t l_359 = 0U;
                        l_359 = 0xE6835EB3;
                        l_291 = l_291;
                        l_384 = ((uint16_t)((((uint32_t)((int32_t)(p_65 == 0) % (int32_t)((uint16_t)((int32_t)l_323 + (int32_t)l_370) + (uint16_t)((int16_t)1 - (int16_t)(-(int32_t)((int32_t)((uint16_t)((0x056A | (g_11 && ((int16_t)l_320 % (int16_t)((uint16_t)((((uint16_t)l_359 >> (uint16_t)13) > 4294967289U) | l_359) + (uint16_t)g_122)))) && 4294967293U) % (uint16_t)l_205) % (int32_t)0x26959F01))))) + (uint32_t)0xDECB9D67) ^ l_311) == 0xBC4FD47F) % (uint16_t)g_216);
                    }
                    else
                    { /* block id: 217 */
                        l_205 = ((l_384 | p_65) ^ g_216);
                    }
                }
                l_206.f0 = p_65;
                g_144.f0 = p_65;
                l_389 = func_72(func_79(func_72(g_63, l_326.f0, ((((__builtin_clzll(p_65) > l_385) < p_65) || (((g_136 > ((uint16_t)l_384 >> (uint16_t)9)) == ((l_311 != l_320) < l_388)) & l_320)) || g_144.f0), p_65), l_326, g_132, g_103, g_144.f0), g_11, g_216, g_216);
            }
        }
        else
        { /* block id: 225 */
            uint32_t l_390 = 0xD74FEB74;
            int32_t l_396 = 0;
            struct S0 l_400 = {-73};
            if ((((l_390 != l_370) || ((uint16_t)l_393 >> (uint16_t)p_65)) < ((g_122 < func_72(l_291, l_370, l_390, p_65)) == p_65)))
            { /* block id: 226 */
                for (l_71 = 0; (l_71 != 4); l_71 += 4)
                { /* block id: 229 */
                    l_396 = __builtin_ffsl(((p_65 & g_216) || p_65));
                    for (g_66 = 18; (g_66 != (-20)); g_66 -= 1)
                    { /* block id: 233 */
                        uint32_t l_399 = 0xAB3579C4;
                        struct S0 l_401 = {107};
                        l_399 = (-8);
                        if (p_65)
                            break;
                        l_291.f0 = 0x3AD0F182;
                        l_401 = l_400;
                    }
                    if (g_216)
                        continue;
                    g_402 = func_77(l_291);
                }
            }
            else
            { /* block id: 242 */
                struct S0 l_405 = {172};
                l_291 = func_79(__builtin_clzll(((l_291.f0 && p_65) == l_311)), l_206, l_400.f0, ((uint16_t)(g_66 < (((__builtin_ffsl(p_65) || 0x70CC) > p_65) >= p_65)) >> (uint16_t)p_65), l_390);
                g_402.f0 = (g_66 != l_291.f0);
                g_402 = func_77(l_405);
            }
            for (l_303 = 0; (l_303 <= 23); l_303 += 6)
            { /* block id: 249 */
                int32_t l_408 = 2;
                int32_t l_427 = 5;
                g_402 = g_402;
                if (l_408)
                { /* block id: 251 */
                    return g_132;
                }
                else
                { /* block id: 253 */
                    struct S0 l_411 = {-231};
                    if (((uint32_t)l_400.f0 % (uint32_t)g_103))
                    { /* block id: 254 */
                        l_411 = g_144;
                        if (p_65)
                            continue;
                        l_411.f0 = ((l_393 && func_72(g_402, l_291.f0, p_65, (((uint32_t)l_411.f0 + (uint32_t)2) <= ((int16_t)((int32_t)func_72(g_144, (!((uint16_t)l_400.f0 >> (uint16_t)2)), ((uint16_t)((uint16_t)((uint16_t)0x7D0D - (uint16_t)65529U) << (uint16_t)g_122) + (uint16_t)0x49F8), p_65) + (int32_t)g_122) % (int16_t)g_144.f0)))) || g_122);
                    }
                    else
                    { /* block id: 258 */
                        l_396 = p_65;
                        g_144 = func_85(g_216, l_396, ((p_65 <= (p_65 > __builtin_popcountll(g_103))) == p_65));
                        l_400.f0 = func_72(l_400, g_122, l_427, (p_65 | (-4)));
                        l_427 = (((((4U == (func_72(l_400, l_370, ((int32_t)((int16_t)(((-3) && ((0x692138E5 <= (!p_65)) >= l_427)) ^ (~(!(l_390 > g_122)))) << (int16_t)13) + (int32_t)1), l_427) == g_216)) <= p_65) != g_216) < g_66) ^ (-1));
                    }
                    if (g_144.f0)
                        continue;
                    l_396 = ((uint16_t)l_437 >> (uint16_t)((int16_t)((p_65 | g_144.f0) != (-9)) << (int16_t)6));
                }
                g_402.f0 = p_65;
            }
        }
        l_291.f0 = (p_65 > p_65);
    }
    return g_136;
}


/* ------------------------------------------ */
/* 
 * reads : g_66
 * writes:
 */
static int16_t  func_72(struct S0  p_73, uint32_t  p_74, int16_t  p_75, int32_t  p_76)
{ /* block id: 118 */
    return g_66;
}


/* ------------------------------------------ */
/* 
 * reads : g_136 g_63 g_132 g_103 g_122 g_11 g_66 g_144.f0
 * writes: g_144 g_132 g_103 g_136 g_66
 */
static struct S0  func_77(struct S0  p_78)
{ /* block id: 66 */
    int32_t l_143 = 0xF6034A10;
    struct S0 l_165 = {-116};
    p_78.f0 = (p_78.f0 < g_136);
    if (l_143)
    { /* block id: 68 */
        uint16_t l_161 = 0x9568;
        struct S0 l_166 = {-42};
        g_144 = g_63;
        for (g_132 = 0; (g_132 > 11); g_132 += 1)
        { /* block id: 72 */
            uint16_t l_158 = 0xBF4A;
            int16_t l_160 = 3;
            p_78.f0 = ((int16_t)0x26FE >> (int16_t)0);
            if (l_143)
                break;
            if (g_136)
            { /* block id: 75 */
                uint16_t l_162 = 0U;
                for (g_103 = 0; (g_103 >= 46); g_103 += 4)
                { /* block id: 78 */
                    int32_t l_159 = 0xA2031C69;
                    if (((uint16_t)65535U << (uint16_t)((uint32_t)(!((g_136 != (((p_78.f0 | ((uint16_t)((l_158 <= g_136) | (g_122 & g_11)) - (uint16_t)g_63.f0)) >= l_159) && 65527U)) || 2)) + (uint32_t)1)))
                    { /* block id: 79 */
                        uint32_t l_163 = 0U;
                        int32_t l_164 = 0;
                        l_164 = (((0x50DA8AEF == l_160) == (l_161 != l_162)) ^ ((__builtin_bswap32(((l_163 == (0U && 0x421C)) >= g_122)) && 0xCC42) | (-1)));
                        p_78 = l_165;
                    }
                    else
                    { /* block id: 82 */
                        g_144 = g_63;
                        if (g_122)
                            continue;
                        g_144 = l_166;
                    }
                }
                return g_63;
            }
            else
            { /* block id: 89 */
                if (g_66)
                    break;
            }
            g_144 = func_85(((((int16_t)g_144.f0 + (int16_t)(g_136 > p_78.f0)) == ((g_11 ^ l_158) | g_11)) <= (-9)), p_78.f0, l_166.f0);
        }
    }
    else
    { /* block id: 94 */
        l_165.f0 = g_122;
        g_144.f0 = (-5);
        p_78 = l_165;
        p_78 = p_78;
    }
    for (g_136 = 0; (g_136 < (-14)); g_136 -= 1)
    { /* block id: 102 */
        int32_t l_187 = 1;
        int32_t l_195 = 0x1E098A53;
        for (g_66 = 6; (g_66 >= (-29)); g_66 -= 3)
        { /* block id: 105 */
            uint32_t l_186 = 0xBAD65AA8;
            struct S0 l_188 = {62};
            p_78.f0 = ((((int16_t)p_78.f0 << (int16_t)7) || (p_78.f0 ^ 3)) <= ((!((uint32_t)__builtin_clz((((int16_t)(-1) >> (int16_t)0) != l_165.f0)) + (uint32_t)p_78.f0)) > ((((int32_t)(((int16_t)l_186 >> (int16_t)12) == g_132) + (int32_t)l_187) && 0) && 65535U)));
            g_144 = l_188;
            l_195 = (((int16_t)l_186 << (int16_t)15) & ((int16_t)p_78.f0 + (int16_t)((int32_t)__builtin_bswap64(p_78.f0) % (int32_t)l_165.f0)));
            if (p_78.f0)
            { /* block id: 109 */
                int16_t l_196 = 0x9980;
                if (l_196)
                    break;
                g_144 = p_78;
            }
            else
            { /* block id: 112 */
                g_144.f0 = g_63.f0;
            }
        }
    }
    return l_165;
}


/* ------------------------------------------ */
/* 
 * reads : g_103 g_11 g_66 g_63.f0 g_136 g_132 g_63
 * writes: g_103 g_122 g_132
 */
static struct S0  func_79(uint32_t  p_80, struct S0  p_81, int16_t  p_82, int32_t  p_83, uint32_t  p_84)
{ /* block id: 48 */
    int32_t l_119 = 0xCF3BB3A5;
    int32_t l_125 = 0x1DF76934;
    for (g_103 = 0; (g_103 <= 46); g_103 += 5)
    { /* block id: 51 */
        uint32_t l_112 = 0x8F2C1609;
        g_122 = (!((5U ^ ((uint32_t)((uint32_t)(g_103 < 0xA47C) + (uint32_t)(l_112 || ((uint16_t)((uint16_t)((((((((int32_t)l_119 % (int32_t)g_11) ^ ((g_103 >= ((int16_t)g_103 >> (int16_t)g_66)) || g_66)) <= g_11) && l_112) ^ 0x099F) | 65529U) > l_119) << (uint16_t)p_80) - (uint16_t)0x0CE4))) + (uint32_t)l_119)) > l_119));
        if (l_119)
            continue;
        if (l_112)
            continue;
    }
    for (l_119 = (-18); (l_119 != 16); l_119 += 1)
    { /* block id: 58 */
        p_81.f0 = p_83;
        l_125 = p_80;
        g_132 = ((l_119 == (((int16_t)g_11 % (int16_t)p_80) < g_103)) == (__builtin_ia32_crc32qi(l_125, (((uint16_t)(g_11 >= g_63.f0) % (uint16_t)p_83) > (p_81.f0 ^ p_80))) >= 0));
        if (g_11)
            break;
    }
    l_119 = (((uint16_t)(~g_136) + (uint16_t)g_66) | (((int16_t)__builtin_ffsl(l_125) << (int16_t)((-1) | ((uint16_t)((uint32_t)p_84 + (uint32_t)g_132) >> (uint16_t)g_11))) || 0xAECC));
    return g_63;
}


/* ------------------------------------------ */
/* 
 * reads : g_66 g_63.f0 g_11
 * writes: g_103
 */
static struct S0  func_85(int32_t  p_86, uint32_t  p_87, int32_t  p_88)
{ /* block id: 43 */
    uint32_t l_102 = 9U;
    struct S0 l_104 = {193};
    p_88 = p_88;
    p_88 = ((!((((((uint16_t)p_88 >> (uint16_t)14) >= p_88) < (((int16_t)(0xB2563844 > (((uint32_t)p_87 % (uint32_t)g_66) != ((__builtin_parityl((((((int32_t)(((int16_t)p_86 << (int16_t)g_63.f0) || g_66) + (int32_t)(l_102 >= p_88)) || g_63.f0) <= g_66) != 1U)) < p_87) < l_102))) >> (int16_t)g_66) != 0x0FB2EC16)) == l_102) ^ p_88)) ^ p_86);
    g_103 = 0x6E2FE0F9;
    return l_104;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    transparent_crc(g_11, "g_11", print_hash_value);
    transparent_crc(g_63.f0, "g_63.f0", print_hash_value);
    transparent_crc(g_66, "g_66", print_hash_value);
    transparent_crc(g_103, "g_103", print_hash_value);
    transparent_crc(g_122, "g_122", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_136, "g_136", print_hash_value);
    transparent_crc(g_144.f0, "g_144.f0", print_hash_value);
    transparent_crc(g_216, "g_216", print_hash_value);
    transparent_crc(g_402.f0, "g_402.f0", print_hash_value);
    transparent_crc(g_511, "g_511", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 101
   depth: 1, occurrence: 27
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 27
XXX full-bitfields structs in the program: 27
breakdown:
   indirect level: 0, occurrence: 27
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 33
XXX times a bitfields struct on RHS: 57
XXX times a single bitfield on LHS: 35
XXX times a single bitfield on RHS: 74

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 200
   depth: 2, occurrence: 44
   depth: 3, occurrence: 6
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 4
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 3
   depth: 27, occurrence: 1
   depth: 28, occurrence: 2
   depth: 29, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 690
XXX times a non-volatile is write: 137
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 188
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 35
   depth: 2, occurrence: 29
   depth: 3, occurrence: 32
   depth: 4, occurrence: 29
   depth: 5, occurrence: 31

XXX percentage a fresh-made variable is used: 16.5
XXX percentage an existing variable is used: 83.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

