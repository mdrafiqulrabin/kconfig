/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      596634120
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
   int16_t  f1;
   uint16_t  f2;
   const int16_t  f3;
   const int32_t  f4;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_32(void);
static const int32_t * func_36(int32_t * p_37, uint32_t  p_38, int32_t * p_39, int64_t  p_40, int32_t * const * p_41);
inline static int32_t * func_42(int32_t * const * p_43);
inline static int32_t * func_47(int32_t ** const  p_48, uint32_t  p_49, uint16_t  p_50, int32_t * p_51);
inline static int32_t ** func_52(int32_t  p_53);
inline static uint16_t  func_59(uint32_t  p_60, uint8_t  p_61, float  p_62, uint16_t  p_63, int32_t  p_64);
static uint16_t  func_82(struct S0  p_83, uint8_t  p_84, uint16_t  p_85);
static struct S0  func_86(uint32_t  p_87, int16_t  p_88, int64_t  p_89, int32_t ** p_90);
static uint32_t  func_94(int32_t  p_95);
static int32_t * func_97(int32_t ** p_98, int32_t * p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_32(void)
{ /* block id: 36 */
    int32_t l_34 = (-6L);
    int32_t *l_33 = &l_34;
    int32_t **l_35 = &l_33;
    int32_t l_318 = 7L;
    int32_t **l_671 = &l_33;
    int32_t **l_672 = (void*)0;
    struct S0 l_673 = {0x33333A8FL,0xCDA6L,0x971AL,0x0B60L,0xE002BA7AL};
    (*l_35) = l_33;
    (*l_671) = func_36(func_42(&l_33), l_318, (*l_35), l_318, &l_33);
    (*l_33) = (**l_671);
    (*l_671) = (*l_35);
    return l_673;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_36(int32_t * p_37, uint32_t  p_38, int32_t * p_39, int64_t  p_40, int32_t * const * p_41)
{ /* block id: 241 */
    int16_t l_323 = 0x87F7L;
    struct S0 l_330 = {18446744073709551606UL,3L,0x7264L,0xA596L,0x93FC5627L};
    struct S0 *l_329 = &l_330;
    struct S0 **l_328 = &l_329;
    struct S0 ***l_327 = &l_328;
    struct S0 ****l_326 = &l_327;
    float l_333 = 0x5.5B31BBp-22;
    int32_t l_357 = 0x6738FE24L;
    int32_t ****l_405 = (void*)0;
    int32_t *l_441 = &l_357;
    int32_t **l_440 = &l_441;
    int32_t * const *l_443 = &l_441;
    int16_t l_468 = 0xEABFL;
    uint32_t l_499 = 0UL;
    float *l_547 = &l_333;
    uint8_t l_638 = 0x59L;
    (*p_39) = ((int64_t)((int64_t)l_323 + (int64_t)((uint16_t)(__builtin_bswap64(l_323) < (l_326 == &l_327)) << (uint16_t)(__builtin_parity(((l_330.f4 | p_40) && (l_330.f3 && ((*l_326) != (void*)0)))) >= p_40))) / (int64_t)p_38);
    for (p_38 = (-1); (p_38 < 3); p_38 += 6)
    { /* block id: 245 */
        uint8_t l_362 = 249UL;
        struct S0 ***l_374 = (void*)0;
        if ((*p_39))
        { /* block id: 246 */
            uint8_t l_342 = 255UL;
            int32_t l_344 = (-1L);
            int32_t *l_343 = &l_344;
            for (l_323 = (-13); (l_323 >= (-11)); l_323 += 2)
            { /* block id: 249 */
                int32_t ***** const l_355 = (void*)0;
                float *l_371 = &l_333;
                if ((*p_39))
                    break;
                for (p_40 = 27; (p_40 > 0); p_40 -= 8)
                { /* block id: 253 */
                    float *l_340 = (void*)0;
                    int32_t l_341 = (-1L);
                    l_341 = l_323;
                    if (l_342)
                    { /* block id: 255 */
                        int32_t **l_345 = (void*)0;
                        const int32_t *l_347 = &l_344;
                        const int32_t **l_346 = &l_347;
                        float *l_354 = (void*)0;
                        int32_t **l_356 = &l_343;
                        (*l_346) = l_343;
                        /* statement id: 256 */
                        //assert (l_347 == &l_344 || l_347 == &l_34);
                        (*p_39) = (0xD293EE43L > ((uint16_t)((uint16_t)func_94(((int16_t)1L / (int16_t)p_38)) << (uint16_t)8) << (uint16_t)10));
                        (*l_343) = l_323;
                        (*l_356) = (*p_41);
                        /* statement id: 259 */
                        //assert (l_343 == &l_34);
                    }
                    else
                    { /* block id: 260 */
                        (**p_41) = 1L;
                        l_357 = l_330.f0;
                        (*l_343) = ((uint64_t)(((__builtin_ia32_crc32qi(p_38, ((l_341 <= 0xF00CC574L) != ((int16_t)p_40 >> (int16_t)l_362))) >= ((((p_38 == ((uint64_t)(p_38 || 18446744073709551610UL) + (uint64_t)0x8FC74D14176D2BC9LL)) <= p_38) > l_323) <= p_38)) < p_40) <= 1UL) % (uint64_t)l_362);
                        (*p_39) = ((uint64_t)(__builtin_clz(p_38) && (*l_343)) % (uint64_t)((uint16_t)((*l_343) || 0x24B3L) - (uint16_t)p_38));
                    }
                }
                (*l_371) = ((float)l_330.f1 / (float)p_40);
            }
            /* facts after for loop */
            //assert (l_343 == &l_344 || l_343 == &l_34);
        }
        else
        { /* block id: 269 */
            int32_t *l_380 = (void*)0;
            int32_t **l_379 = &l_380;
            (**p_41) = ((l_357 > ((int64_t)1L - (int64_t)(l_374 == (void*)0))) | ((uint16_t)p_38 >> (uint16_t)((((uint16_t)__builtin_ctzl(p_40) >> (uint16_t)6) & p_40) > ((l_330.f2 | p_40) == 1L))));
            (*l_379) = (void*)0;
        }
    }
    for (l_330.f0 = 0; (l_330.f0 != 6); ++l_330.f0)
    { /* block id: 276 */
        const int16_t l_383 = 1L;
        struct S0 *l_416 = &l_330;
        int32_t *****l_429 = (void*)0;
        struct S0 *** const l_455 = (void*)0;
        float *l_482 = &l_333;
        (*p_39) = (l_383 | (**p_41));
        if (((uint64_t)((65527UL > ((p_38 < ((-(uint64_t)(!(l_357 & ((p_40 < (l_330.f2 && l_383)) >= 0L)))) <= (**p_41))) < ((int16_t)(p_40 != (*p_39)) >> (int16_t)l_330.f0))) > p_40) - (uint64_t)l_330.f0))
        { /* block id: 278 */
            int32_t *l_391 = &l_357;
            int32_t **l_390 = &l_391;
            (*l_390) = (void*)0;
            /* statement id: 279 */
            assert (l_391 == 0);
        }
        else
        { /* block id: 280 */
            const uint32_t l_396 = 4294967294UL;
            float *l_397 = (void*)0;
            float *l_398 = &l_333;
            (*l_398) = ((((float)l_383 / (float)l_383) != l_330.f4) > ((float)((-0x1.8p+1) != p_40) + (float)l_396));
            return p_39;
            /* statement id: 282 */
            //assert (func_36_rv == &l_34);
        }
        for (l_330.f2 = (-26); (l_330.f2 < 6); l_330.f2++)
        { /* block id: 286 */
            float *l_401 = &l_333;
            int32_t l_403 = 0x495FA754L;
            int16_t l_407 = 0xC104L;
            int32_t *****l_430 = (void*)0;
            struct S0 * const *l_446 = &l_329;
            uint64_t l_447 = 0UL;
            struct S0 ***l_456 = &l_328;
            int32_t *** const *l_481 = (void*)0;
            (*l_401) = (-0x7.5p-1);
        }
        (*l_482) = 0x1.3p-1;
    }
    for (l_330.f0 = 0; (l_330.f0 > 58); l_330.f0++)
    { /* block id: 344 */
        int32_t * const *l_488 = &l_441;
        int32_t l_492 = 6L;
        struct S0 *l_495 = &l_330;
        uint64_t l_511 = 0x68C037808A29CE08LL;
        int32_t *l_532 = &l_357;
        int32_t l_561 = 0L;
        int32_t ***l_637 = &l_440;
        const uint16_t l_660 = 1UL;
        struct S0 ***l_663 = &l_328;
        for (l_330.f1 = 13; (l_330.f1 > (-19)); l_330.f1 -= 1)
        { /* block id: 347 */
            int32_t * const *l_487 = &l_441;
        }
    }
    return p_39;
    /* statement id: 433 */
    //assert (func_36_rv == &l_34);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_42(int32_t * const * p_43)
{ /* block id: 38 */
    int32_t l_44 = 0x2E809B4AL;
    int32_t *l_242 = &l_44;
    struct S0 *l_247 = (void*)0;
    struct S0 **l_246 = &l_247;
    int32_t *l_304 = &l_44;
    int32_t *l_306 = (void*)0;
    int32_t **l_314 = &l_306;
    int32_t *l_315 = &l_44;
    int32_t *l_316 = &l_44;
    int32_t *l_317 = (void*)0;
    for (l_44 = 0; (l_44 <= 5); l_44++)
    { /* block id: 41 */
        int32_t *l_67 = (void*)0;
        int32_t l_71 = 0x7519BA60L;
        uint8_t l_78 = 247UL;
        int32_t **l_241 = &l_67;
        int32_t ***l_244 = &l_241;
        int32_t **** const l_243 = &l_244;
        int32_t l_245 = (-8L);
        uint8_t l_293 = 1UL;
        (*l_241) = func_47(func_52(l_44), l_44, func_59(((int16_t)(l_67 != (*p_43)) / (int16_t)((!(((uint64_t)l_71 + (uint64_t)((((uint16_t)(((uint16_t)(&l_44 != (void*)0) - (uint16_t)(((int64_t)l_44 + (int64_t)l_71) & l_44)) != l_78) / (uint16_t)l_44) < l_44) < (-1L))) > l_44)) || (-6L))), l_44, l_44, l_78, l_44), &l_71);
        (*l_241) = l_242;
        /* statement id: 181 */
        assert (l_67 == &l_44);
        if ((((((void*)0 != l_243) | (**l_241)) && (****l_243)) != ((l_245 & 0x65FAL) || ((l_246 != (void*)0) >= ((((((uint16_t)(&p_43 != &p_43) % (uint16_t)(*l_242)) <= 0x4327L) | (****l_243)) == 0x9664FB15D496808DLL) && (-1L))))))
        { /* block id: 182 */
            const float l_250 = 0x1.3p-1;
            if ((**p_43))
                break;
        }
        else
        { /* block id: 184 */
            uint16_t l_265 = 0xAB9AL;
            int32_t *l_302 = &l_44;
            if (((*l_246) != (void*)0))
            { /* block id: 185 */
                int32_t *l_251 = &l_71;
                struct S0 l_256 = {0x4D158891L,1L,6UL,0xD1DDL,0xB939D7BCL};
                (**l_244) = l_251;
                /* statement id: 186 */
                assert (l_67 == &l_71);
                for (l_78 = 11; (l_78 <= 42); l_78 += 1)
                { /* block id: 189 */
                    uint16_t l_257 = 0x6A24L;
                    struct S0 * const *l_272 = &l_247;
                    int32_t l_275 = 0xE576FCFDL;
                    float l_281 = 0x5.5CF964p+83;
                    float *l_280 = &l_281;
                }
                (***l_244) = ((*p_43) != l_251);
            }
            else
            { /* block id: 208 */
                struct S0 l_290 = {3UL,0x970FL,0x2532L,1L,-1L};
                int32_t *l_303 = &l_245;
                for (l_245 = 29; (l_245 != (-28)); --l_245)
                { /* block id: 211 */
                    uint32_t l_294 = 0x35E5902AL;
                    float l_296 = 0x1.470223p+85;
                    float *l_295 = &l_296;
                    (*l_295) = ((float)(0xE.C9DB44p-59 <= (0x9.BBA556p-89 >= ((float)l_265 + (float)0x0.189FC5p-53))) - (float)((float)func_82(func_86(func_82(l_290, l_265, (4294967295UL != (((int32_t)(((*l_242) == l_290.f4) != l_290.f2) % (int32_t)l_293) & l_294))), l_265, l_290.f0, &l_242), l_294, (**l_241)) + (float)l_294));
                    for (l_293 = 5; (l_293 == 39); l_293++)
                    { /* block id: 215 */
                        (**p_43) = (&l_44 == (*p_43));
                        (*l_295) = 0x0.6p-1;
                    }
                }
                for (l_71 = (-22); (l_71 > (-17)); l_71++)
                { /* block id: 222 */
                    int32_t **l_301 = &l_67;
                    int32_t *l_305 = &l_44;
                    if ((**p_43))
                        break;
                    (*l_301) = (*p_43);
                    /* statement id: 224 */
                    //assert (l_67 == &l_34 || l_67 == &l_403 || l_67 == &l_357);
                    return l_306;
                    /* statement id: 225 */
                    //assert (func_42_rv == 0);
                }
                for (l_293 = (-15); (l_293 <= 20); l_293 += 8)
                { /* block id: 229 */
                    int64_t l_309 = (-1L);
                    float l_311 = 0x3.05B929p-47;
                    float *l_310 = &l_311;
                    (**l_244) = (void*)0;
                    /* statement id: 230 */
                    assert (l_67 == 0);
                    (*l_310) = l_309;
                    (**p_43) = ((uint16_t)(((**l_243) != &l_302) | 0x9A5CL) + (uint16_t)(*l_303));
                    (*l_310) = 0x1.EA0C12p-28;
                }
                /* facts after for loop */
                assert (l_67 == 0 || l_67 == &l_44);
            }
            /* facts after branching */
            assert (l_67 == 0 || l_67 == &l_44 || l_67 == &l_71);
        }
        /* facts after branching */
        assert (l_67 == 0 || l_67 == &l_44 || l_67 == &l_71);
    }
    l_306 = func_97(&l_304, &l_44);
    /* statement id: 238 */
    assert (l_306 == &l_44);
    (*l_314) = &l_44;
    return l_317;
    /* statement id: 240 */
    //assert (func_42_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_47(int32_t ** const  p_48, uint32_t  p_49, uint16_t  p_50, int32_t * p_51)
{ /* block id: 178 */
    int32_t *l_240 = (void*)0;
    return l_240;
    /* statement id: 179 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_52(int32_t  p_53)
{ /* block id: 42 */
    int32_t l_55 = 0x17B38E51L;
    int32_t *l_54 = &l_55;
    int32_t **l_56 = &l_54;
    int32_t **l_57 = &l_54;
    int32_t **l_58 = (void*)0;
    (*l_54) = (__builtin_popcountl(p_53) | (l_54 == &l_55));
    return l_58;
    /* statement id: 44 */
    //assert (func_52_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_59(uint32_t  p_60, uint8_t  p_61, float  p_62, uint16_t  p_63, int32_t  p_64)
{ /* block id: 45 */
    uint32_t l_79 = 4294967295UL;
    int32_t **l_91 = (void*)0;
    int32_t * const * const ***l_167 = (void*)0;
    float l_235 = 0xA.AC00ABp+4;
    float *l_234 = &l_235;
    int32_t l_238 = 0x0F77C65BL;
    int32_t *l_237 = &l_238;
    int32_t **l_236 = &l_237;
    int32_t **l_239 = &l_237;
    p_64 = (l_79 < (((uint16_t)func_82(func_86(l_79, l_79, l_79, l_91), p_64, ((void*)0 != l_167)) + (uint16_t)p_63) <= (-9L)));
    (*l_234) = (0xB.AD60D6p+34 >= p_61);
    (*l_236) = l_234;
    /* statement id: 175 */
    assert (l_237 == &l_235);
    (**l_236) = (&l_237 == l_239);
    return p_64;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_82(struct S0  p_83, uint8_t  p_84, uint16_t  p_85)
{ /* block id: 114 */
    struct S0 **l_168 = (void*)0;
    struct S0 l_170 = {0x7D319CEEL,-3L,0x7568L,0x23FBL,0x5D134699L};
    struct S0 *l_169 = &l_170;
    int32_t l_192 = 0x2AF93AE5L;
    int32_t *l_191 = &l_192;
    int32_t ***l_211 = (void*)0;
    int32_t ****l_210 = &l_211;
    int32_t *****l_209 = &l_210;
    int32_t l_225 = 1L;
lbl_226:
    l_169 = &p_83;
    /* statement id: 115 */
    assert (l_169 == &p_83);
    if (func_94(p_83.f1))
    { /* block id: 116 */
        float *l_171 = (void*)0;
        float l_173 = 0xE.0EE989p+58;
        float *l_172 = &l_173;
        int32_t l_174 = 0x2DC1848BL;
        int32_t *l_190 = &l_174;
        int32_t **l_189 = &l_190;
        int32_t ** const ** const l_207 = (void*)0;
        int32_t ** const ** const *l_206 = &l_207;
        struct S0 **l_213 = &l_169;
        (*l_172) = __builtin_ffs(p_85);
        if (l_174)
        { /* block id: 118 */
            (*l_172) = __builtin_parity(p_84);
        }
        else
        { /* block id: 120 */
            int64_t l_193 = 0xE5908BEF20378A6BLL;
            int32_t ** const **l_202 = (void*)0;
            int32_t ** const ***l_201 = &l_202;
            struct S0 * const ***l_215 = (void*)0;
            struct S0 ***l_217 = &l_168;
            struct S0 ****l_216 = &l_217;
            if ((0x1DE9004F71531938LL > ((uint16_t)(65533UL >= (-8L)) + (uint16_t)(__builtin_popcountl(p_83.f3) ^ ((uint64_t)p_85 / (uint64_t)l_170.f3)))))
            { /* block id: 121 */
                uint32_t l_179 = 0x1ACFDDCEL;
                (*l_172) = l_179;
                if (l_170.f1)
                { /* block id: 123 */
                    if (((uint16_t)((uint16_t)1UL << (uint16_t)l_170.f0) << (uint16_t)12))
                    { /* block id: 124 */
                        return l_179;
                    }
                    else
                    { /* block id: 126 */
                        int32_t * const l_184 = (void*)0;
                        int32_t *l_186 = &l_174;
                        int32_t **l_185 = &l_186;
                        (*l_185) = l_184;
                        /* statement id: 127 */
                        assert (l_186 == 0);
                    }
                }
                else
                { /* block id: 129 */
                    for (l_170.f0 = 28; (l_170.f0 < 39); l_170.f0++)
                    { /* block id: 132 */
                        (*l_172) = 0x5.A66786p-87;
                    }
                }
            }
            else
            { /* block id: 136 */
                return p_83.f4;
            }
            (*l_189) = func_97(l_189, func_97(&l_190, &l_192));
            if (l_193)
            { /* block id: 140 */
                uint8_t l_194 = 0xCEL;
                int32_t ***l_205 = &l_189;
                int32_t ****l_204 = &l_205;
                int32_t *****l_203 = &l_204;
                (*l_172) = l_194;
                for (l_170.f2 = (-3); (l_170.f2 > 1); ++l_170.f2)
                { /* block id: 144 */
                    (*l_191) = ((((uint16_t)(__builtin_clz((4294967295UL != p_83.f4)) && p_83.f3) % (uint16_t)((uint16_t)(l_201 == l_203) - (uint16_t)(__builtin_parityl(p_83.f3) < ((void*)0 == l_206)))) != (-1L)) | p_83.f1);
                    (*l_191) = (((((*l_191) != ((*l_190) != 0x8.4p-1)) > 0x4.6p-1) == p_83.f4) == 0x5.E436F8p+8);
                }
            }
            else
            { /* block id: 148 */
                int32_t ***l_212 = &l_189;
                struct S0 ***l_214 = &l_168;
                (*l_190) = (-(uint32_t)(&l_202 != l_209));
                (*l_190) = (&l_189 != l_212);
                l_201 = (void*)0;
                /* statement id: 151 */
                assert (l_201 == 0);
                (*l_214) = l_213;
                /* statement id: 152 */
                assert (l_168 == &l_169);
            }
            /* facts after branching */
            assert (l_168 == &l_169 || l_168 == 0);
            assert (l_201 == 0 || l_201 == &l_202);
            (*l_216) = &l_168;
        }
        /* facts after branching */
        assert (l_168 == &l_169 || l_168 == 0);
        return p_83.f3;
    }
    else
    { /* block id: 157 */
        struct S0 * const *l_224 = &l_169;
        struct S0 * const **l_223 = &l_224;
        int32_t *l_233 = &l_192;
        if (((int16_t)(0xAB9BL >= (((int32_t)(func_94(p_83.f0) ^ ((-(uint16_t)(p_83.f1 != p_84)) ^ __builtin_popcount(__builtin_bswap32(((l_223 == &l_168) <= p_83.f2))))) / (int32_t)p_83.f2) ^ l_225)) << (int16_t)7))
        { /* block id: 158 */
            (*l_223) = (void*)0;
            /* statement id: 159 */
            assert (l_224 == 0);
            if (p_85)
                goto lbl_226;
        }
        else
        { /* block id: 161 */
            for (p_83.f0 = 1; (p_83.f0 > 3); p_83.f0++)
            { /* block id: 164 */
                int64_t l_229 = 0x3B09B231F37C5CFFLL;
                uint32_t l_230 = 4294967292UL;
                float l_232 = (-0x9.Fp+1);
                float *l_231 = &l_232;
                l_230 = l_229;
                if (p_83.f4)
                    continue;
                (*l_231) = func_94(l_230);
            }
        }
        /* facts after branching */
        assert (l_224 == &l_169 || l_224 == 0);
        l_233 = l_233;
    }
    return p_83.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_86(uint32_t  p_87, int16_t  p_88, int64_t  p_89, int32_t ** p_90)
{ /* block id: 46 */
    uint32_t l_96 = 0UL;
    struct S0 l_113 = {0x75669BA9L,0xDD06L,6UL,0L,0L};
    float *l_120 = (void*)0;
    float *l_121 = (void*)0;
    int32_t l_122 = 1L;
    int32_t *l_154 = &l_122;
    int32_t **l_165 = &l_154;
    int32_t ***l_164 = &l_165;
    int32_t ****l_166 = &l_164;
    for (p_87 = 0; (p_87 == 5); p_87 += 6)
    { /* block id: 49 */
        int32_t l_112 = 0x2E6445A0L;
        int32_t *l_111 = &l_112;
        (*l_111) = (func_94(l_96) == l_96);
        return l_113;
    }
    l_122 = ((float)(((((p_88 <= func_94((p_87 & 4294967295UL))) != func_94((((int16_t)(((p_89 || (l_96 ^ l_113.f2)) > ((((uint16_t)(p_87 && p_88) / (uint16_t)l_113.f4) <= p_87) && p_89)) <= 0x3046L) << (int16_t)9) == l_113.f4))) != l_113.f1) == (-0x6.Fp-1)) > 0x8.A0A773p-23) + (float)p_89);
    if ((8L != p_88))
    { /* block id: 61 */
        int32_t *l_123 = (void*)0;
        int32_t *l_124 = (void*)0;
        int32_t *l_125 = &l_122;
        struct S0 l_153 = {0xA8116371L,0x01FBL,0x2FD5L,-1L,0x8E8ED7A3L};
        (*l_125) = (0x772B8ADFL & p_88);
        for (p_88 = 17; (p_88 <= (-8)); p_88 -= 3)
        { /* block id: 65 */
            int32_t l_150 = 0x4FFC8C37L;
            int32_t *l_159 = &l_150;
            int32_t **l_160 = &l_159;
        }
    }
    else
    { /* block id: 108 */
        uint64_t l_163 = 0xAD7DE1A35A1EF979LL;
        (*l_154) = p_89;
        (*l_154) = ((uint16_t)((l_163 >= __builtin_ffsll(p_88)) <= (*l_154)) << (uint16_t)11);
    }
    (*l_166) = l_164;
    return l_113;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_94(int32_t  p_95)
{ /* block id: 50 */
    int32_t *l_101 = (void*)0;
    int32_t **l_100 = &l_101;
    (*l_100) = func_97(l_100, (*l_100));
    return p_95;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_97(int32_t ** p_98, int32_t * p_99)
{ /* block id: 51 */
    uint32_t l_104 = 0x74CA6A66L;
    int32_t l_108 = 1L;
    int32_t *l_107 = &l_108;
    int32_t * const *l_106 = &l_107;
    float l_110 = 0x3.5C685Bp-87;
    float *l_109 = &l_110;
    (*p_98) = (*p_98);
    (*l_109) = (((float)l_104 + (float)((+l_104) < (l_106 == (void*)0))) <= ((*l_107) == (*l_107)));
    return (*p_98);
    /* statement id: 54 */
    //assert (func_97_rv == 0 || func_97_rv == &l_150 || func_97_rv == &l_122 || func_97_rv == &l_174 || func_97_rv == &l_71 || func_97_rv == &l_44 || func_97_rv == &l_357);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 168
   depth: 1, occurrence: 9
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 131
   depth: 2, occurrence: 33
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 5
   depth: 7, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 24, occurrence: 1

XXX total number of pointers: 199

XXX times a variable address is taken: 194
XXX times a pointer is dereferenced on RHS: 106
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 33
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 120
breakdown:
   depth: 1, occurrence: 101
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 17
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 567

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 321
   level: 2, occurrence: 132
   level: 3, occurrence: 11
   level: 4, occurrence: 18
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 121
XXX number of pointers point to scalars: 72
XXX number of pointers point to structs: 6
XXX percent of pointers has null in alias set: 30.2
XXX average alias set size: 1.28

XXX times a non-volatile is read: 793
XXX times a non-volatile is write: 314
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 6

XXX stmts: 121
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 20
   depth: 2, occurrence: 17
   depth: 3, occurrence: 21
   depth: 4, occurrence: 15
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
********************* end of statistics **********************/

