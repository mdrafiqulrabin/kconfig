/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      4220553085
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
   float  f1;
   uint64_t  f2;
   uint8_t  f3;
   float  f4;
   float  f5;
   float  f6;
   unsigned f7 : 12;
   float  f8;
   uint8_t  f9;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S1 {
   uint16_t  f0;
   const uint64_t  f1;
   int16_t  f2;
   const uint64_t  f3;
   const int64_t  f4;
   uint32_t  f5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_36(void);
static int32_t * const  func_37(int32_t * p_38, uint64_t  p_39, struct S1  p_40);
static int32_t * func_41(int32_t * p_42, int64_t  p_43, int32_t * p_44);
static int32_t * func_45(int32_t * p_46, int32_t * p_47, float  p_48, uint16_t  p_49, int32_t * p_50);
inline static int32_t * func_53(float  p_54, uint8_t  p_55, int64_t  p_56, const int16_t  p_57);
static int64_t  func_58(struct S0  p_59, uint64_t  p_60, int32_t  p_61, int32_t * p_62);
inline static struct S0  func_63(int32_t * p_64, const int16_t  p_65, int32_t * p_66, int32_t * p_67, int32_t * p_68);
inline static int32_t * func_69(int32_t  p_70, int16_t  p_71, uint64_t  p_72, struct S0  p_73);
inline static int32_t  func_74(uint8_t  p_75, const uint32_t  p_76, uint32_t  p_77);
static const int64_t  func_78(int16_t  p_79, int32_t * p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_36(void)
{ /* block id: 36 */
    int32_t l_52 = (-1L);
    int32_t *l_51 = &l_52;
    struct S0 l_291 = {65535UL,0x7.F5BE6Ep+94,0UL,0x09L,-0x1.Bp+1,0x6.68CE29p-67,-0x5.8p+1,23,0x5.A4EBD6p+6,250UL};
    struct S1 l_693 = {0UL,0xCDB9D8B73CA6ED4FLL,4L,0xE3C2E9C2DD2A3A13LL,0xE309354FD219CBC3LL,0xFD7CD2C4L};
    int32_t **l_818 = &l_51;
    int32_t l_819 = 0x66C14464L;
    (*l_818) = func_37(func_41(func_45(l_51, func_53(((*l_51) <= ((void*)0 == &l_52)), ((func_58(func_63(func_69(func_74((*l_51), (*l_51), (0x35BD639B6AF4A9B8LL != func_78(((-(uint16_t)(-(int32_t)0x162A9717L)) == (*l_51)), &l_52))), (*l_51), (*l_51), l_291), (*l_51), &l_52, &l_52, &l_52), (*l_51), (*l_51), &l_52) < (*l_51)) != 0xC43891058FFB4F1BLL), (*l_51), (*l_51)), (*l_51), (*l_51), &l_52), (*l_51), &l_52), l_291.f2, l_693);
    /* statement id: 524 */
    assert (l_51 == 0 || l_51 == &l_52);
    return l_819;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_37(int32_t * p_38, uint64_t  p_39, struct S1  p_40)
{ /* block id: 452 */
    int32_t l_714 = 0xF2689D7FL;
    struct S1 l_718 = {1UL,0UL,0xC842L,0x3E10B511061AC669LL,-10L,4294967293UL};
    struct S1 *l_717 = &l_718;
    struct S1 **l_716 = &l_717;
    struct S1 ***l_715 = &l_716;
    struct S1 ****l_719 = &l_715;
    struct S1 ***l_753 = &l_716;
    float l_762 = (-0x1.1p-1);
    float *l_761 = &l_762;
    uint8_t l_765 = 7UL;
lbl_808:
    if ((0x00577038L > p_40.f5))
    { /* block id: 453 */
        return p_38;
        /* statement id: 454 */
        //assert (func_37_rv == 0 || func_37_rv == &l_52);
    }
    else
    { /* block id: 455 */
        struct S0 * const **l_698 = (void*)0;
        struct S0 * const ***l_697 = &l_698;
        struct S0 * const ****l_696 = &l_697;
        int32_t l_699 = 0xA07B1BF2L;
        int32_t **l_700 = (void*)0;
        int32_t *l_702 = &l_699;
        int32_t **l_701 = &l_702;
        l_699 = ((float)0x1.7p+1 / (float)((void*)0 == l_696));
        (*l_701) = &l_699;
    }
    for (p_40.f2 = 0; (p_40.f2 < 23); p_40.f2 += 8)
    { /* block id: 461 */
        for (p_40.f0 = 0; (p_40.f0 >= 21); p_40.f0 += 7)
        { /* block id: 464 */
            float *l_708 = (void*)0;
            int32_t l_709 = 8L;
            float *l_711 = (void*)0;
            float l_713 = 0x7.7D715Ap+24;
            float *l_712 = &l_713;
            l_709 = (0x0.2p+1 < (+p_40.f2));
            (*l_712) = (!0xB.46CB17p-30);
        }
        if (l_714)
            continue;
        return p_38;
        /* statement id: 469 */
        //assert (func_37_rv == 0 || func_37_rv == &l_52);
    }
    (*l_719) = l_715;
    for (p_40.f2 = 1; (p_40.f2 >= (-29)); p_40.f2 -= 5)
    { /* block id: 474 */
        float l_735 = 0x6.E68BCBp+39;
        const int32_t l_742 = 0xA7D873FEL;
        const struct S0 l_749 = {65535UL,0x1.Cp+1,0xA4D6528F24AA75FALL,0x2EL,0x1.6p+1,0x0.1p+1,0x1.Bp-1,16,0x2.5FDD37p+9,0x34L};
        struct S1 **** const l_777 = (void*)0;
        struct S1 *****l_817 = &l_719;
        if ((~((uint64_t)((uint32_t)(((int64_t)(0x19AC641B2660CDF9LL != ((int16_t)((uint16_t)(0xCA1AD2A76362C195LL < 18446744073709551615UL) << (uint16_t)1) + (int16_t)((4UL == ((__builtin_parity((p_40.f4 ^ (p_40.f1 != (((int64_t)((int16_t)p_39 << (int16_t)p_40.f4) % (int64_t)(0xAAECDBF6F96BE8E4LL ^ l_742)) > p_40.f4)))) | p_40.f5) < p_40.f4)) == l_718.f4))) % (int64_t)0xB6EC193A38054BF1LL) >= l_714) + (uint32_t)l_742) - (uint64_t)l_718.f3)))
        { /* block id: 475 */
            const struct S0 **l_748 = (void*)0;
            const struct S0 ***l_747 = &l_748;
            const struct S0 ****l_746 = &l_747;
            const struct S0 **** const *l_745 = &l_746;
            for (l_718.f0 = (-11); (l_718.f0 == 59); l_718.f0++)
            { /* block id: 478 */
                struct S0 l_751 = {2UL,0xD.3A7EF0p-97,1UL,8UL,-0x4.3p-1,0x1.Cp-1,-0x6.6p-1,31,0x1.2p-1,250UL};
                struct S0 *l_750 = &l_751;
                float *l_752 = &l_751.f1;
                l_745 = (void*)0;
                /* statement id: 479 */
                assert (l_745 == 0);
                (*l_750) = l_749;
                (*l_752) = l_749.f3;
            }
            /* facts after for loop */
            assert (l_745 == 0 || l_745 == &l_746);
            (*l_716) = (***l_719);
            (*l_719) = l_753;
        }
        else
        { /* block id: 485 */
            uint64_t l_756 = 0xAC22771E8A1C8820LL;
            int32_t *l_766 = &l_714;
            uint64_t l_778 = 0x862C4C76081D6147LL;
            (*l_766) = (0x493EL & (((l_756 <= l_749.f7) ^ 0UL) && (((int16_t)(((int16_t)((((__builtin_ia32_crc32qi(l_756, (((void*)0 != l_761) <= ((uint64_t)p_40.f1 % (uint64_t)l_765))) && l_718.f5) < l_749.f0) <= l_756) | 0x8AC5L) % (int16_t)p_40.f2) != p_40.f0) - (int16_t)p_40.f2) < l_756)));
            if ((((int16_t)((uint16_t)((uint64_t)((((uint32_t)l_742 % (uint32_t)((int16_t)(*l_766) << (int16_t)8)) & l_749.f9) != (((void*)0 != l_777) <= (l_778 != 0x5FBE0D60L))) % (uint64_t)((int16_t)p_40.f3 << (int16_t)((uint64_t)8UL / (uint64_t)0x40D7EA800FB706BFLL))) << (uint16_t)12) << (int16_t)l_749.f2) && l_749.f0))
            { /* block id: 487 */
                if (p_39)
                { /* block id: 488 */
                    struct S0 l_783 = {0xC5A0L,0x2.7BE5AFp+12,1UL,0x98L,0x3.Ep-1,0x3.2p+1,-0x5.7p+1,50,-0x1.0p+1,249UL};
                    int16_t l_786 = 0xBA35L;
                    l_783 = l_749;
                    (*l_766) = ((int16_t)l_786 << (int16_t)7);
                }
                else
                { /* block id: 491 */
                    (*l_766) = (*l_766);
                }
            }
            else
            { /* block id: 494 */
                const uint64_t l_791 = 18446744073709551615UL;
                if (((uint16_t)__builtin_ctzl(((void*)0 != p_38)) >> (uint16_t)((uint64_t)0x9886436A3BDA736ELL + (uint64_t)p_40.f3)))
                { /* block id: 495 */
                    const int32_t l_801 = 0x75E0D257L;
                    struct S0 l_806 = {0x661FL,0x1.8p+1,5UL,9UL,0xC.0CA385p-95,0x8.1p-1,0x8.340267p-18,5,-0x5.3p+1,0xC1L};
                    if ((func_74((*l_766), l_791, p_40.f0) != ((l_791 | (p_40.f3 == ((((int16_t)(-1L) >> (int16_t)p_39) || l_718.f3) == p_40.f3))) & 0x1E34445434044754LL)))
                    { /* block id: 496 */
                        int32_t l_800 = 0L;
                        struct S0 l_804 = {65535UL,0x5.6E2030p-53,18446744073709551615UL,0x7EL,-0x1.Ap+1,0x0.Fp-1,0x4.868F7Ap+61,10,0x4.Ap-1,0x00L};
                        int32_t **l_805 = &l_766;
                        (*l_805) = func_41(func_69((4L ^ l_718.f3), p_40.f3, ((uint16_t)((uint16_t)l_800 >> (uint16_t)(l_801 != (p_40.f3 < (((uint32_t)((void*)0 == l_777) % (uint32_t)(*l_766)) == p_40.f2)))) % (uint16_t)l_801), l_804), (*l_766), &l_800);
                        /* statement id: 497 */
                        assert (l_766 == &l_800 || l_766 == 0);
                        if (l_791)
                            continue;
                        if (l_801)
                            continue;
                        l_806 = func_63((*l_805), l_749.f3, p_38, p_38, p_38);
                    }
                    else
                    { /* block id: 501 */
                        int32_t **l_807 = &l_766;
                        (*l_766) = l_718.f0;
                        (*l_807) = &l_714;
                    }
                    /* facts after branching */
                    //assert (l_766 == &l_714 || l_766 == dangling || l_766 == 0);
                }
                else
                { /* block id: 505 */
                    if (p_40.f5)
                        goto lbl_808;
                }
                /* facts after branching */
                //assert (l_766 == &l_714 || l_766 == dangling || l_766 == 0);
            }
            /* facts after branching */
            //assert (l_766 == &l_714 || l_766 == dangling || l_766 == 0);
            for (l_718.f0 = 0; (l_718.f0 != 59); l_718.f0++)
            { /* block id: 511 */
                struct S1 ***** const l_816 = &l_719;
                for (l_718.f2 = 0; (l_718.f2 >= 8); ++l_718.f2)
                { /* block id: 514 */
                    int32_t *l_813 = (void*)0;
                    int32_t *l_814 = (void*)0;
                    int32_t *l_815 = &l_714;
                    (*l_815) = p_39;
                    if (l_749.f3)
                        continue;
                    (*l_761) = p_40.f2;
                    l_817 = l_816;
                }
            }
        }
    }
    return p_38;
    /* statement id: 523 */
    //assert (func_37_rv == 0 || func_37_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(int32_t * p_42, int64_t  p_43, int32_t * p_44)
{ /* block id: 414 */
    float l_644 = 0x4.0p+1;
    int32_t l_645 = (-1L);
    struct S0 *l_652 = (void*)0;
    struct S0 **l_651 = &l_652;
    struct S0 ***l_650 = &l_651;
    struct S0 ****l_649 = &l_650;
    float *l_676 = &l_644;
    struct S0 ** const ***l_689 = (void*)0;
    if ((*p_44))
    { /* block id: 415 */
        uint16_t l_648 = 0UL;
        int32_t *l_657 = &l_645;
        (*p_44) = (0UL != ((((uint64_t)(((int16_t)((((int32_t)(*p_44) - (int32_t)(*p_44)) > ((int16_t)(((9L >= l_645) && __builtin_ffsl((l_645 && (((l_648 ^ (l_649 == (void*)0)) & 0UL) || l_645)))) != p_43) >> (int16_t)12)) | 0xCFCD2A52B24F0E5ALL) - (int16_t)(-6L)) > (-4L)) - (uint64_t)p_43) > p_43) || l_648));
        for (l_648 = 0; (l_648 != 15); l_648++)
        { /* block id: 419 */
            int32_t *l_656 = &l_645;
            int32_t **l_655 = &l_656;
            (*l_655) = &l_645;
            return p_42;
            /* statement id: 421 */
            //assert (func_41_rv == 0 || func_41_rv == &l_52);
        }
        p_42 = p_42;
        for (l_645 = (-7); (l_645 != (-30)); l_645--)
        { /* block id: 426 */
            (*p_44) = l_645;
        }
    }
    else
    { /* block id: 429 */
        float *l_660 = &l_644;
        int32_t l_663 = 9L;
        struct S0 l_669 = {0xC45CL,-0x1.Ap+1,1UL,5UL,-0x1.8p+1,0x9.9249F6p-71,0xB.D6ABD2p-38,2,0x1.7p-1,250UL};
        struct S0 *l_668 = &l_669;
        (*l_660) = (-0x1.Dp+1);
        (*l_660) = (((float)__builtin_ctz((((*p_44) && (l_663 && (((uint64_t)p_43 % (uint64_t)((p_43 >= l_645) & (&l_649 == (void*)0))) > (((uint16_t)(l_645 | ((void*)0 == l_668)) / (uint16_t)0x0731L) != 18446744073709551615UL)))) ^ 4L)) / (float)l_669.f9) != l_645);
        return p_42;
        /* statement id: 432 */
        //assert (func_41_rv == 0 || func_41_rv == &l_52);
    }
    (*l_676) = (((float)((float)p_43 + (float)(((float)0xB.D86AF9p-36 + (float)0x2.95CAF7p+99) >= p_43)) / (float)(l_645 != l_645)) == (l_645 < func_74(((**l_649) != (void*)0), l_645, l_645)));
    if (l_645)
    { /* block id: 435 */
        int32_t l_685 = (-9L);
        int32_t *l_691 = &l_645;
        int32_t *l_692 = &l_685;
        for (p_43 = (-12); (p_43 >= 7); p_43 += 5)
        { /* block id: 438 */
            struct S0 l_684 = {0x28A3L,-0x1.5p+1,0UL,1UL,0x3.83EEAEp+16,0x6.E79F23p-2,0x3.70BD62p-26,53,0x1.7C6BEAp+63,0xDFL};
            struct S0 * const **l_687 = (void*)0;
            int32_t *l_690 = &l_685;
            for (l_645 = 0; (l_645 < (-7)); --l_645)
            { /* block id: 441 */
                uint32_t l_683 = 0xACFE1940L;
                int32_t *l_686 = &l_685;
                int32_t **l_688 = &l_686;
                (*p_44) = ((uint16_t)(l_683 <= func_58(l_684, l_685, (func_78(l_684.f9, l_686) || (l_687 == (void*)0)), p_42)) >> (uint16_t)2);
                (*l_688) = p_44;
                /* statement id: 443 */
                //assert (l_686 == &l_52 || l_686 == &l_800);
                l_689 = (void*)0;
            }
            return p_44;
            /* statement id: 446 */
            //assert (func_41_rv == &l_52 || func_41_rv == &l_800);
        }
    }
    else
    { /* block id: 448 */
        return p_42;
        /* statement id: 449 */
        //assert (func_41_rv == 0 || func_41_rv == &l_52);
    }
    return p_42;
    /* statement id: 451 */
    //assert (func_41_rv == 0 || func_41_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_45(int32_t * p_46, int32_t * p_47, float  p_48, uint16_t  p_49, int32_t * p_50)
{ /* block id: 339 */
    uint8_t l_506 = 0UL;
    struct S0 l_515 = {65532UL,0x7.BBE403p-51,0x8321351DA7BA3E6CLL,0x87L,0x8.5117FFp+98,0xE.23FFA1p+49,0xF.27A88Ap-8,33,0xB.C2D91Ap-68,255UL};
    int32_t l_539 = 0x8208C4B3L;
    int32_t *l_538 = &l_539;
    const float l_585 = 0x0.F7E90Fp-9;
    struct S0 **** const l_628 = (void*)0;
    if (l_506)
    { /* block id: 340 */
        int32_t l_509 = (-1L);
        int32_t *l_508 = &l_509;
        int32_t **l_507 = &l_508;
        struct S0 l_511 = {9UL,0xB.BE9ACBp+74,18446744073709551615UL,0UL,0x0.0p+1,0x7.8C1AACp-94,0x8.AAAFE8p-94,39,0x9.0DA36Bp+31,0x48L};
        struct S0 *l_510 = &l_511;
        struct S0 **l_512 = &l_510;
        struct S0 ****l_514 = (void*)0;
        struct S0 **** const *l_513 = &l_514;
        (*l_507) = p_47;
        /* statement id: 341 */
        assert (l_508 == 0);
        (*l_512) = l_510;
        if ((l_513 == &l_514))
        { /* block id: 343 */
            struct S0 l_516 = {0xB42AL,0x8.91498Dp+32,1UL,0xABL,-0x1.1p-1,0x9.63BD92p+81,-0x4.8p+1,62,0x5.FFD919p+55,0xA3L};
            l_516 = l_515;
        }
        else
        { /* block id: 345 */
            struct S0 ***l_523 = &l_512;
            struct S0 * const *l_532 = (void*)0;
            struct S0 * const **l_531 = &l_532;
            struct S0 * const ***l_530 = &l_531;
            int32_t l_537 = (-8L);
            int32_t *l_568 = &l_537;
            struct S1 l_570 = {5UL,5UL,0x0AA9L,18446744073709551609UL,0x456494F168A38C58LL,5UL};
            const struct S1 *l_569 = &l_570;
            if ((((int16_t)(((*l_513) != (void*)0) < p_49) << (int16_t)((int16_t)((int32_t)(l_523 == (void*)0) - (int32_t)0x225A4937L) << (int16_t)4)) & p_49))
            { /* block id: 346 */
                uint32_t l_533 = 0UL;
                struct S0 *****l_534 = &l_514;
                int32_t *l_564 = &l_509;
                if ((((*p_46) >= (((((int16_t)(((((int32_t)0L + (int32_t)(((void*)0 != l_530) || l_533)) && (((&l_530 == l_534) ^ ((p_49 != func_74(((uint16_t)l_533 >> (uint16_t)9), l_515.f0, l_533)) || l_537)) != p_49)) > 0L) >= 0x0F5FL) + (int16_t)0x6842L) <= l_515.f3) > 0xF7A7L) >= l_537)) && l_533))
                { /* block id: 347 */
                    struct S0 ****l_540 = &l_523;
                    const uint64_t l_544 = 0x58D7FDB63F0B84F3LL;
                    if ((*p_46))
                    { /* block id: 348 */
                        int32_t l_543 = (-1L);
                        (***l_523) = func_63(l_538, (&l_523 != l_540), p_50, func_53(p_49, p_49, ((uint32_t)((((*p_46) >= l_543) == p_49) ^ l_543) + (uint32_t)0xF8DE7480L), l_544), p_47);
                        (*l_507) = p_46;
                        /* statement id: 350 */
                        //assert (l_508 == &l_52);
                    }
                    else
                    { /* block id: 351 */
                        float *l_545 = (void*)0;
                        float *l_546 = &l_515.f5;
                        (*l_507) = p_50;
                        /* statement id: 352 */
                        //assert (l_508 == &l_52);
                        (*l_546) = (*l_538);
                    }
                    /* facts after branching */
                    //assert (l_508 == &l_52);
                    return p_46;
                    /* statement id: 355 */
                    //assert (func_45_rv == &l_52);
                }
                else
                { /* block id: 356 */
                    float l_549 = (-0x10.Ep+1);
                    struct S0 l_556 = {0xD95AL,0xA.54F2EAp+10,0x251BB5A0DF20E0BDLL,4UL,0x7.1p-1,0x8.Cp+1,0x6.Dp+1,36,-0x4.5p+1,1UL};
                    int32_t *l_557 = &l_509;
                    (*l_510) = l_515;
                    for (l_506 = 25; (l_506 >= 14); l_506 -= 5)
                    { /* block id: 360 */
                        const int64_t l_554 = 1L;
                        struct S0 l_555 = {1UL,0xA.8FDC3Ap-14,4UL,0xE8L,0xB.69DBC4p+46,-0x6.6p+1,0x9.Dp+1,58,0xC.31D36Fp+63,0UL};
                        p_46 = func_53((0x0.Ap+1 != l_549), (0x3E34C17BL | l_537), ((-10L) | ((uint16_t)l_537 >> (uint16_t)((int16_t)p_49 << (int16_t)4))), l_554);
                        /* statement id: 361 */
                        assert (p_46 == 0);
                        l_556 = l_555;
                        (*l_507) = l_557;
                        /* statement id: 363 */
                        assert (l_508 == &l_509);
                        if ((*l_557))
                            continue;
                    }
                    /* facts after for loop */
                    //assert (p_46 == 0 || p_46 == &l_52);
                    assert (l_508 == &l_509 || l_508 == 0);
                    (***l_523) = func_63(func_69((((void*)0 == l_538) <= (0xE857C9BE4EBF25B3LL ^ 0x9B28AA653F8B12B9LL)), (((int16_t)l_537 / (int16_t)((int64_t)(l_538 == (void*)0) + (int64_t)p_49)) || (((uint16_t)p_49 / (uint16_t)p_49) || p_49)), p_49, (***l_523)), (*l_557), p_46, l_557, l_564);
                    for (p_49 = 0; (p_49 > 7); p_49 += 6)
                    { /* block id: 369 */
                        uint32_t l_567 = 2UL;
                        if (l_567)
                            break;
                    }
                }
                /* facts after branching */
                //assert (p_46 == 0 || p_46 == &l_52);
                assert (l_508 == &l_509 || l_508 == 0);
                l_568 = p_47;
                /* statement id: 373 */
                assert (l_568 == 0);
                p_47 = &l_537;
                /* statement id: 374 */
                assert (p_47 == &l_537);
            }
            else
            { /* block id: 375 */
                struct S1 l_572 = {1UL,0xD39C165C92EA1B3FLL,1L,0xC53F2A7716E1B50ELL,0L,0x565FFE43L};
                const struct S1 *l_571 = &l_572;
                int32_t l_579 = (-3L);
                int32_t *l_590 = (void*)0;
                struct S0 ****l_595 = &l_523;
                float l_604 = 0x2.28E1A3p-93;
                int32_t *l_607 = &l_509;
                l_571 = l_569;
                /* statement id: 376 */
                assert (l_571 == &l_570);
                if (((int64_t)(p_49 ^ (((((int16_t)l_579 / (int16_t)p_49) == (((uint32_t)(*l_568) - (uint32_t)((*l_568) >= 0xCB8E8BF1L)) > (*l_568))) >= func_78(p_49, &l_579)) <= l_572.f4)) - (int64_t)(*l_568)))
                { /* block id: 377 */
                    uint64_t l_582 = 0x18AB85FEBFD8B398LL;
                    struct S0 l_589 = {1UL,-0x1.0p+1,9UL,251UL,-0x8.4p-1,0xB.2C2EB5p+11,0x9.7268C1p-80,17,0x4.4D13D7p+27,248UL};
                    p_50 = func_53(l_582, (l_579 < (-1L)), ((int16_t)0x5D2BL << (int16_t)5), p_49);
                    /* statement id: 378 */
                    assert (p_50 == 0);
                    if ((l_582 && ((int16_t)(-(int64_t)p_49) << (int16_t)0)))
                    { /* block id: 379 */
                        l_589 = l_515;
                        (*l_507) = (void*)0;
                    }
                    else
                    { /* block id: 382 */
                        (*l_510) = func_63(&l_579, l_579, p_46, (*l_507), p_47);
                        (*l_530) = (void*)0;
                        /* statement id: 384 */
                        assert (l_531 == 0);
                    }
                    /* facts after branching */
                    assert (l_531 == 0 || l_531 == &l_532);
                    return l_590;
                    /* statement id: 386 */
                    //assert (func_45_rv == 0);
                }
                else
                { /* block id: 387 */
                    uint16_t l_596 = 65530UL;
                    float *l_603 = &l_515.f4;
                    int32_t *l_605 = &l_579;
                    int32_t l_606 = 0xCDC15962L;
                    (*l_507) = func_53((((float)(((((float)((void*)0 != l_595) / (float)l_596) <= ((float)((*l_568) > (!func_74(p_49, (p_49 == (((int16_t)p_49 >> (int16_t)(-(int16_t)(((p_49 != ((void*)0 == l_590)) == l_596) != l_596))) <= p_49)), p_49))) + (float)0x5.F53759p+64)) <= 0x4.4FCBA5p+82) < p_49) / (float)(*l_568)) < (*l_568)), (*l_568), p_49, p_49);
                    if (func_58(func_63(p_47, (((*l_568) >= (l_603 != l_568)) & ((*l_568) >= 0UL)), func_69(p_49, p_49, (*l_568), (****l_595)), l_605, p_47), l_606, (*l_605), &l_537))
                    { /* block id: 389 */
                        int32_t l_610 = 0xF8248C35L;
                        (****l_595) = func_63(l_607, ((void*)0 == l_603), p_47, (*l_507), func_69(((~(!p_49)) && l_610), ((void*)0 != p_47), p_49, l_515));
                    }
                    else
                    { /* block id: 391 */
                        (*l_507) = p_47;
                        return p_46;
                        /* statement id: 393 */
                        //assert (func_45_rv == &l_52);
                    }
                    for (l_511.f0 = 0; (l_511.f0 == 39); l_511.f0 += 5)
                    { /* block id: 397 */
                        (*l_603) = 0x5.BF2300p+0;
                    }
                }
            }
            /* facts after branching */
            //assert (p_46 == 0 || p_46 == &l_52);
            assert (p_47 == 0 || p_47 == &l_537);
            assert (l_508 == &l_509 || l_508 == 0);
            assert (l_568 == &l_537 || l_568 == 0);
        }
        /* facts after branching */
        //assert (p_46 == 0 || p_46 == &l_52);
        //assert (p_47 == 0 || p_47 == dangling);
        assert (l_508 == &l_509 || l_508 == 0);
    }
    else
    { /* block id: 403 */
        int32_t l_627 = (-1L);
        struct S0 l_635 = {0UL,0x1.5p+1,0x1557EF004AE97488LL,0xF5L,0x2.89296Fp-23,0x1.Bp-1,-0x2.7p+1,40,0x4.DC0BA7p-7,0x6AL};
        for (l_539 = 0; (l_539 < 2); ++l_539)
        { /* block id: 406 */
            int32_t l_623 = 1L;
            struct S0 *l_630 = &l_515;
            struct S0 **l_629 = &l_630;
            int32_t l_631 = 6L;
            int32_t **l_632 = &l_538;
        }
        (*l_538) = ((uint64_t)(*l_538) + (uint64_t)func_58(l_635, (1L < p_49), (*p_50), &l_539));
    }
    /* facts after branching */
    //assert (p_46 == 0 || p_46 == &l_52);
    //assert (p_47 == 0 || p_47 == dangling);
    return p_46;
    /* statement id: 413 */
    //assert (func_45_rv == 0 || func_45_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_53(float  p_54, uint8_t  p_55, int64_t  p_56, const int16_t  p_57)
{ /* block id: 329 */
    float l_493 = (-0x1.Fp+1);
    float *l_492 = &l_493;
    int32_t **l_494 = (void*)0;
    int32_t l_497 = 0L;
    int32_t *l_496 = &l_497;
    int32_t **l_495 = &l_496;
    int32_t *l_501 = &l_497;
    int32_t *l_502 = &l_497;
    int32_t *l_503 = &l_497;
    int32_t *l_504 = &l_497;
    int32_t *l_505 = (void*)0;
    (*l_492) = 0x1.EADC0Ep+78;
    (*l_495) = l_492;
    /* statement id: 331 */
    assert (l_496 == &l_493);
    for (p_56 = (-28); (p_56 >= 14); ++p_56)
    { /* block id: 334 */
        int32_t *l_500 = &l_497;
        l_500 = l_500;
        (**l_495) = p_57;
    }
    return l_505;
    /* statement id: 338 */
    //assert (func_53_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_58(struct S0  p_59, uint64_t  p_60, int32_t  p_61, int32_t * p_62)
{ /* block id: 209 */
    float l_309 = 0xC.90D848p-86;
    int32_t l_310 = 0xF4D41489L;
    struct S0 l_333 = {65526UL,0xD.18288Cp+38,0x55007D63D2776EE0LL,0UL,0x1.0p+1,0x4.3D8227p-18,0x1.ECC204p+35,28,0x1.Cp-1,0x87L};
    struct S0 *l_332 = &l_333;
    int64_t l_356 = 2L;
    uint16_t l_361 = 0xD721L;
    int32_t l_369 = 6L;
    struct S1 l_375 = {0xAA05L,0xFD55D3DFACCE92ACLL,0x2A0CL,0xF3E973057089537BLL,0xFEE0FE5EFB6F7C99LL,0UL};
    const struct S1 *l_374 = &l_375;
    uint8_t l_394 = 247UL;
    struct S1 *l_402 = (void*)0;
    struct S0 * const *l_426 = &l_332;
    struct S0 * const **l_425 = &l_426;
    const uint8_t l_443 = 1UL;
    int32_t *l_485 = &l_310;
    int64_t l_487 = 0L;
    int32_t **l_488 = (void*)0;
    int32_t **l_489 = (void*)0;
    int32_t **l_490 = (void*)0;
    int32_t **l_491 = &l_485;
    for (p_59.f0 = 0; (p_59.f0 >= 36); ++p_59.f0)
    { /* block id: 212 */
        int32_t *l_312 = (void*)0;
        struct S0 l_320 = {0x50C6L,0x1.9p-1,0x7DEDD072930EC5A8LL,0UL,0x0.Fp-1,0xF.05B71Cp-49,0xB.0A635Bp+31,46,0xD.D93C50p+98,0x2FL};
        struct S0 * const l_319 = &l_320;
        struct S0 * const *l_318 = &l_319;
        struct S0 * const **l_317 = &l_318;
        struct S1 * const l_376 = &l_375;
        uint64_t l_411 = 0xB3169DF3D125E4FDLL;
        uint8_t l_466 = 5UL;
        int32_t *l_467 = &l_310;
        struct S1 l_479 = {2UL,0x4D308D291AE296D7LL,2L,0xA2D8EEE6A24BC57ALL,-1L,7UL};
        struct S1 *l_478 = &l_479;
        float *l_486 = &l_320.f8;
    }
    (*l_332) = p_59;
    (*l_491) = func_69(p_59.f0, (*l_485), ((&l_425 == &l_425) ^ (l_487 & 0xB62525DAL)), (***l_425));
    /* statement id: 327 */
    assert (l_485 == 0);
    return p_59.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_63(int32_t * p_64, const int16_t  p_65, int32_t * p_66, int32_t * p_67, int32_t * p_68)
{ /* block id: 204 */
    struct S0 l_302 = {1UL,0x9.0p+1,0xB45DCA988B8C5FC2LL,1UL,0x5.CBC306p-99,-0x8.0p+1,0xB.596460p+56,37,-0x10.5p+1,0x18L};
    struct S0 *l_303 = &l_302;
    struct S0 **l_304 = &l_303;
    float *l_305 = &l_302.f1;
    struct S0 l_306 = {0x61FFL,0x8.3DBD07p-95,0xD9E19FCC6670F88BLL,0xB8L,0x1.Bp-1,-0x1.2p-1,0xD.046E8Ep+66,45,0x8.2p+1,1UL};
    (*l_303) = l_302;
    (*l_304) = &l_302;
    (*l_305) = (p_65 <= (l_302.f9 < p_65));
    return l_306;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_69(int32_t  p_70, int16_t  p_71, uint64_t  p_72, struct S0  p_73)
{ /* block id: 200 */
    int32_t l_293 = 0L;
    int32_t *l_292 = &l_293;
    int32_t **l_294 = &l_292;
    int32_t *l_295 = &l_293;
    int32_t *l_296 = &l_293;
    int32_t *l_297 = &l_293;
    int32_t *l_298 = &l_293;
    int32_t *l_299 = &l_293;
    int32_t *l_300 = &l_293;
    int32_t *l_301 = (void*)0;
    (*l_294) = l_292;
    (*l_294) = (*l_294);
    return l_301;
    /* statement id: 203 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_74(uint8_t  p_75, const uint32_t  p_76, uint32_t  p_77)
{ /* block id: 43 */
    uint32_t l_97 = 1UL;
    int32_t l_101 = 8L;
    int32_t * const l_100 = &l_101;
    const int32_t *l_108 = &l_101;
    int32_t l_126 = 0x9AD14953L;
    const struct S0 l_152 = {0xDC2EL,0xC.92D9D7p+76,0x814F6C7F956F5242LL,0x3DL,0xE.A8D9A8p+59,0x3.8269CFp+46,0x9.D125F2p+72,62,-0x2.2p-1,247UL};
    struct S0 *l_179 = (void*)0;
    struct S0 **l_178 = &l_179;
    struct S0 * const *l_206 = &l_179;
    struct S0 ***l_257 = &l_178;
    if (l_97)
    { /* block id: 44 */
        int16_t l_123 = 0xA80DL;
lbl_128:
        for (l_97 = 0; (l_97 > 55); l_97 += 1)
        { /* block id: 47 */
            int32_t *l_106 = &l_101;
            int32_t l_116 = (-10L);
            int64_t l_127 = (-1L);
            if (l_97)
            { /* block id: 48 */
                int32_t *l_103 = &l_101;
                int32_t **l_102 = &l_103;
                (*l_102) = l_100;
                (**l_102) = (!(p_76 && ((__builtin_parity(p_77) || (__builtin_ffs(p_77) < func_78(((**l_102) && (**l_102)), (*l_102)))) == 0L)));
            }
            else
            { /* block id: 51 */
                uint32_t l_105 = 1UL;
                int32_t **l_107 = &l_106;
                if (l_105)
                    break;
                (*l_107) = l_106;
                if ((*l_100))
                    break;
            }
            l_108 = (void*)0;
            /* statement id: 56 */
            assert (l_108 == 0);
            for (p_75 = 0; (p_75 != 36); p_75 += 9)
            { /* block id: 59 */
                int32_t **l_111 = &l_106;
                int32_t l_122 = 0x08823B97L;
                (*l_111) = l_106;
                for (p_77 = (-13); (p_77 < 45); p_77++)
                { /* block id: 63 */
                    for (l_101 = 0; (l_101 != (-14)); l_101--)
                    { /* block id: 66 */
                        int64_t l_121 = 1L;
                        float l_125 = 0x0.7p+1;
                        float *l_124 = &l_125;
                        l_116 = (0x2C12L || p_75);
                        (*l_111) = &l_116;
                        /* statement id: 68 */
                        assert (l_106 == &l_116);
                        (*l_124) = (((((float)p_75 - (float)(*l_106)) != 0xE.E6A7F8p-61) != 0x0.Bp-1) >= ((float)((p_75 >= (l_121 <= __builtin_bswap32((l_122 ^ (0xDC457790L <= ((((p_76 != (*l_100)) & (**l_111)) <= (*l_100)) | 0xE36C8546L)))))) == l_123) + (float)0x0.Fp+1));
                        (**l_111) = (__builtin_popcountll(l_126) <= __builtin_bswap32((**l_111)));
                    }
                }
                if ((*l_100))
                    break;
                if (l_127)
                    continue;
            }
            /* facts after for loop */
            assert (l_106 == &l_116 || l_106 == &l_101);
        }
        (*l_100) = ((__builtin_clzl(((*l_100) >= (p_75 | l_123))) ^ p_77) < p_77);
        if (l_97)
            goto lbl_128;
    }
    else
    { /* block id: 79 */
        int32_t *l_129 = (void*)0;
        struct S0 l_130 = {65535UL,0xB.57FEC6p-75,0x0D4880774EDE3B14LL,0x25L,0x3.78D8C4p-90,0x1.180BEBp+14,-0x1.6p+1,43,0x1.B75AD7p+40,0x28L};
        struct S0 *l_131 = &l_130;
        l_129 = &l_101;
        /* statement id: 80 */
        assert (l_129 == &l_101);
lbl_137:
        (*l_131) = l_130;
        if ((l_108 == l_100))
        { /* block id: 82 */
            int32_t *l_139 = &l_101;
            int32_t *l_140 = &l_101;
            struct S0 l_160 = {0x8C9EL,-0x8.1p+1,0x2F923AD0E7527B81LL,0UL,0x9.1B57B9p-64,-0x1.1p+1,0x1.8p+1,3,-0x2.Cp-1,0xECL};
            float *l_187 = &l_130.f4;
            for (l_126 = 0; (l_126 == (-14)); l_126 -= 3)
            { /* block id: 85 */
                uint8_t l_138 = 9UL;
                struct S0 **l_141 = (void*)0;
                int32_t l_150 = 0xF67225D3L;
                for (p_77 = 12; (p_77 < 57); p_77 += 1)
                { /* block id: 88 */
                    int32_t **l_136 = &l_129;
                    (*l_136) = (void*)0;
                    /* statement id: 89 */
                    assert (l_129 == 0);
                    (*l_136) = &l_101;
                    /* statement id: 90 */
                    assert (l_129 == &l_101);
                    if (l_130.f3)
                        goto lbl_137;
                }
                if (l_138)
                { /* block id: 93 */
                    l_140 = l_139;
                }
                else
                { /* block id: 95 */
                    struct S0 **l_142 = &l_131;
                    int32_t l_151 = (-4L);
                    l_142 = l_141;
                    /* statement id: 96 */
                    assert (l_142 == 0);
                    if (p_77)
                    { /* block id: 97 */
                        float l_143 = 0x0.7p+1;
                        return p_76;
                    }
                    else
                    { /* block id: 99 */
                        (*l_139) = ((__builtin_ffs(((uint16_t)((uint16_t)p_75 >> (uint16_t)8) << (uint16_t)4)) || ((uint16_t)((&l_101 == (void*)0) <= l_150) / (uint16_t)(*l_139))) & ((*l_129) && l_151));
                    }
                }
                (*l_131) = l_152;
            }
            for (l_101 = 0; (l_101 > 17); l_101 += 1)
            { /* block id: 107 */
                int32_t **l_155 = &l_140;
                (*l_155) = (void*)0;
                /* statement id: 108 */
                assert (l_140 == 0);
            }
            /* facts after for loop */
            assert (l_140 == 0 || l_140 == &l_101);
            for (l_101 = 10; (l_101 < 29); l_101++)
            { /* block id: 112 */
                int32_t l_165 = 0x50BD7AEAL;
                int32_t **l_169 = &l_140;
                if (p_76)
                    break;
                for (l_126 = 2; (l_126 >= (-12)); l_126 -= 1)
                { /* block id: 116 */
                    int32_t l_163 = (-1L);
                    int32_t *l_168 = &l_165;
                    (*l_131) = l_160;
                    for (p_75 = 0; (p_75 != 42); ++p_75)
                    { /* block id: 120 */
                        float *l_166 = (void*)0;
                        float *l_167 = &l_130.f1;
                        (*l_167) = (l_163 != ((((+((*l_139) > (-0x8.Fp-1))) > l_165) == (-0x1.8p-1)) != (-0x1.5p-1)));
                        (*l_167) = p_76;
                        if (l_160.f9)
                            goto lbl_137;
                        l_168 = l_139;
                        /* statement id: 124 */
                        assert (l_168 == &l_101);
                    }
                    /* facts after for loop */
                    assert (l_168 == &l_101 || l_168 == &l_165);
                }
                (*l_169) = &l_165;
                /* statement id: 127 */
                assert (l_140 == &l_165);
            }
            /* facts after for loop */
            //assert (l_140 == dangling || l_140 == 0 || l_140 == &l_101);
            (*l_187) = ((float)(*l_139) / (float)((float)((*l_139) >= (((float)((float)(((void*)0 == l_178) >= ((float)((*l_108) != ((float)0xB.DE130Cp+47 / (float)(*l_129))) / (float)(*l_129))) / (float)((float)(+((*l_108) <= p_77)) - (float)p_75)) + (float)p_77) != p_76)) / (float)(*l_129)));
        }
        else
        { /* block id: 130 */
            int32_t *l_188 = (void*)0;
            int32_t **l_189 = &l_188;
            if (p_77)
                goto lbl_137;
            (*l_189) = l_188;
            (*l_189) = &l_101;
            /* statement id: 133 */
            assert (l_188 == &l_101);
        }
    }
    /* facts after branching */
    assert (l_108 == 0 || l_108 == &l_101);
    if (((int64_t)(0UL <= p_76) + (int64_t)((p_76 ^ p_77) >= func_78(p_76, &l_101))))
    { /* block id: 136 */
        int32_t *l_195 = &l_101;
        int32_t ** const l_194 = &l_195;
        struct S0 l_207 = {1UL,0x2.E17E32p-26,2UL,1UL,-0x1.6p-1,0x0.5p-1,-0x3.9p-1,26,0x3.D09630p+45,0xD4L};
        int16_t l_254 = 0xDDACL;
        (*l_100) = (-0x8.1p-1);
        if (((*l_100) < (*l_100)))
        { /* block id: 138 */
            struct S0 * const *l_205 = &l_179;
            int32_t l_214 = (-5L);
            uint16_t l_225 = 0xDCECL;
            uint8_t l_227 = 0x36L;
            int32_t **l_237 = (void*)0;
            uint16_t l_262 = 1UL;
            for (p_77 = 0; (p_77 == 56); p_77++)
            { /* block id: 141 */
                struct S0 l_211 = {0x1EA2L,-0x1.Bp-1,0xE8C66258E059B896LL,0x5FL,0x3.Fp+1,0x0.733A30p-80,0xE.F77066p+6,21,0x0.Fp-1,0x65L};
                int32_t *l_226 = &l_101;
                if ((l_194 == (void*)0))
                { /* block id: 142 */
                    float l_204 = 0x0.4p-1;
                    float *l_203 = &l_204;
                    (*l_203) = ((float)((float)(+p_76) - (float)((float)0x6.0p-1 + (float)(**l_194))) / (float)(p_75 == (-0x5.9p-1)));
                }
                else
                { /* block id: 144 */
                    struct S0 *l_208 = &l_207;
                    l_206 = l_205;
                    (*l_208) = l_207;
                    (*l_194) = &l_101;
                    for (l_101 = 12; (l_101 <= (-1)); l_101--)
                    { /* block id: 150 */
                        int32_t *l_213 = &l_101;
                        l_211 = (*l_208);
                        l_214 = ((-0x7.Ap-1) != ((p_77 != (p_76 != p_77)) == (__builtin_ffsl((!func_78(__builtin_parity(p_76), l_213))) >= 0xA.3360A1p-48)));
                    }
                }
                l_227 = ((uint64_t)((uint16_t)(0x3BE11BCF49901D41LL <= (((uint32_t)(p_76 != p_76) + (uint32_t)l_211.f0) && ((int16_t)0x89F4L + (int16_t)((p_77 > 0UL) != (func_78(l_225, l_226) > 0xC2A3F75AL))))) << (uint16_t)6) - (uint64_t)(**l_194));
            }
            if (p_76)
            { /* block id: 157 */
                return p_75;
            }
            else
            { /* block id: 159 */
                int32_t **l_236 = (void*)0;
                int32_t *l_258 = &l_101;
                for (p_75 = 0; (p_75 == 14); p_75++)
                { /* block id: 162 */
                    int32_t *l_243 = &l_101;
                    struct S0 l_244 = {65529UL,0x3.7E2202p-42,4UL,4UL,-0x7.2p+1,0x9.75FA8Bp-52,0x8.22B19Bp-58,16,0x7.A480CBp-60,0UL};
                    struct S0 ***l_256 = &l_178;
                    if (((uint16_t)((int16_t)((((uint64_t)((func_78((l_236 == l_237), &l_101) == ((uint64_t)((*l_100) != (((int32_t)1L + (int32_t)p_76) > (**l_194))) + (uint64_t)func_78((~__builtin_clzll(((-1L) || 0xD539769A4CD6723ALL))), l_243))) || p_76) % (uint64_t)p_76) | p_76) <= (*l_100)) - (int16_t)(*l_243)) % (uint16_t)(*l_195)))
                    { /* block id: 163 */
                        struct S0 *l_245 = &l_244;
                        (*l_245) = l_244;
                    }
                    else
                    { /* block id: 165 */
                        (*l_194) = (void*)0;
                        /* statement id: 166 */
                        assert (l_195 == 0);
                        (*l_243) = (p_76 < 0x03AABBA4L);
                        (*l_194) = &l_101;
                        /* statement id: 168 */
                        assert (l_195 == &l_101);
                        (*l_194) = &l_101;
                    }
                    (*l_100) = (func_78((((~(*l_195)) || ((uint64_t)0UL % (uint64_t)func_78(p_76, &l_101))) == ((int64_t)((*l_243) | ((!(p_75 > p_77)) & l_214)) + (int64_t)p_76)), l_243) & l_254);
                    if (p_77)
                    { /* block id: 172 */
                        struct S0 l_255 = {1UL,0xD.24C40Ap+77,18446744073709551615UL,5UL,0x1.7p+1,-0x9.Ap-1,0x6.Ap+1,38,0x8.293638p-51,0xB8L};
                        l_255 = l_207;
                    }
                    else
                    { /* block id: 174 */
                        int32_t *l_259 = (void*)0;
                        if ((*l_243))
                            break;
                        l_257 = l_256;
                        l_259 = l_258;
                        /* statement id: 177 */
                        assert (l_259 == &l_101);
                        if (p_75)
                            break;
                    }
                    (*l_243) = ((int32_t)0L - (int32_t)l_262);
                }
            }
            (*l_195) = ((uint32_t)4294967294UL + (uint32_t)((*l_195) & (((int16_t)(+((int64_t)((__builtin_parityll((*l_195)) || ((4294967295UL || ((*l_100) || (p_76 != (*l_195)))) >= ((uint16_t)(-(uint32_t)(p_76 | p_76)) - (uint16_t)0L))) == (-5L)) + (int64_t)(*l_195))) + (int16_t)(*l_195)) > (*l_100))));
            l_237 = &l_195;
            /* statement id: 184 */
            assert (l_237 == &l_195);
        }
        else
        { /* block id: 185 */
            int16_t l_275 = 0xDE92L;
            return l_275;
        }
    }
    else
    { /* block id: 188 */
        int32_t *l_276 = &l_101;
        struct S0 l_283 = {0xD4F0L,-0x1.Cp-1,18446744073709551615UL,9UL,-0x10.1p+1,0x0.Ep-1,0x9.E26377p-40,53,0xD.FDE0CAp+32,0UL};
        struct S0 *l_282 = &l_283;
lbl_281:
        l_276 = &l_101;
        for (l_126 = (-26); (l_126 >= (-17)); l_126++)
        { /* block id: 192 */
            int32_t *l_279 = &l_101;
            int32_t **l_280 = &l_279;
            float *l_290 = &l_283.f4;
            (*l_280) = l_279;
            if (l_126)
                goto lbl_281;
            (*l_178) = l_282;
            /* statement id: 195 */
            assert (l_179 == &l_283);
            (*l_290) = (((((float)(*l_100) / (float)(((-0x1.Fp+1) > (p_77 != (func_78(p_77, (*l_280)) < ((float)((float)(0x1.8p-1 <= (**l_280)) - (float)(*l_279)) / (float)0x0.Bp-1)))) <= p_77)) < 0xB.047EB3p-57) != p_77) > (*l_100));
        }
    }
    /* facts after branching */
    //assert (l_179 == dangling || l_179 == 0);
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int64_t  func_78(int16_t  p_79, int32_t * p_80)
{ /* block id: 37 */
    struct S0 l_83 = {0x81CFL,0x0.Bp-1,0x849EC59C4D355714LL,0x8AL,0x0.Dp+1,0x5.5p+1,-0x1.Dp+1,10,0x1.Cp+1,3UL};
    struct S0 *l_84 = (void*)0;
    struct S0 *l_85 = &l_83;
    int32_t l_92 = 0x1B61232CL;
    int32_t *l_93 = (void*)0;
    int32_t l_95 = (-1L);
    int32_t *l_94 = &l_95;
lbl_96:
    (*l_85) = l_83;
    (*l_85) = (*l_85);
    (*l_94) = (((&l_83 == (void*)0) >= (((uint64_t)(((int64_t)((uint16_t)((65535UL != (__builtin_clz(((void*)0 == &l_83)) < 1UL)) | l_92) >> (uint16_t)((l_83.f3 ^ l_83.f0) & p_79)) - (int64_t)18446744073709551615UL) == p_79) / (uint64_t)0x8D1E6FA5B36276A2LL) && l_83.f9)) < p_79);
    if (p_79)
        goto lbl_96;
    return p_79;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_36();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 200
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 53
breakdown:
   indirect level: 0, occurrence: 23
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 8
   indirect level: 4, occurrence: 7
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 19
XXX times a bitfields struct on LHS: 7
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 12

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 259
   depth: 2, occurrence: 40
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 4
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 4
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 4
   depth: 18, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 2
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 225

XXX times a variable address is taken: 228
XXX times a pointer is dereferenced on RHS: 130
breakdown:
   depth: 1, occurrence: 115
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 121
breakdown:
   depth: 1, occurrence: 111
   depth: 2, occurrence: 6
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 35
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 637

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 350
   level: 2, occurrence: 45
   level: 3, occurrence: 11
   level: 4, occurrence: 2
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 95
XXX number of pointers point to scalars: 104
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 32.4
XXX average alias set size: 1.34

XXX times a non-volatile is read: 898
XXX times a non-volatile is write: 339
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 7

XXX stmts: 221
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 33
   depth: 2, occurrence: 34
   depth: 3, occurrence: 34
   depth: 4, occurrence: 39
   depth: 5, occurrence: 45

XXX percentage a fresh-made variable is used: 19
XXX percentage an existing variable is used: 81
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

