/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1024909896
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint16_t  f0;
   int8_t  f1;
   const int32_t  f2;
   int32_t  f3;
   int32_t  f4;
   uint32_t  f5;
   const int8_t  f6;
   const int32_t  f7;
   int32_t  f8;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static int16_t  func_4(int32_t  p_5, uint16_t  p_6, struct S0  p_7, const uint32_t  p_8, uint32_t  p_9);
static uint16_t  func_13(int32_t  p_14);
inline static int16_t  func_25(uint8_t  p_26, struct S0  p_27, uint32_t  p_28, uint16_t  p_29, uint16_t  p_30);
static uint32_t  func_32(struct S0  p_33, int8_t  p_34);
inline static int32_t  func_36(const int32_t  p_37, uint32_t  p_38);
inline static int32_t  func_40(int8_t  p_41, int16_t  p_42, int8_t  p_43, int32_t  p_44, int32_t  p_45);
static int16_t  func_48(struct S0  p_49, int16_t  p_50);
static struct S0  func_51(uint32_t  p_52, struct S0  p_53, uint32_t  p_54, uint32_t  p_55, uint32_t  p_56);
static uint32_t  func_59(int32_t  p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_10 = 249U;
    struct S0 l_31 = {0x2E80,0xB4,0xF7BDD484,0x7374FD52,0x80335900,0x0881DDA8,0xB8,0x46B51F0E,0x2F37FC03};
    int8_t l_35 = 1;
    uint16_t l_511 = 0U;
    int32_t *l_517 = &l_31.f4;
    int32_t **l_518 = &l_517;
    int32_t l_519 = 0x9D1EB9EB;
    (*l_517) = (safe_add_func_int16_t_s_s(func_4(l_10, (safe_lshift_func_int8_t_s_s((l_10 | (func_13((safe_add_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(l_10, (safe_sub_func_uint32_t_u_u(l_10, (safe_lshift_func_int16_t_s_u((safe_sub_func_uint16_t_u_u(l_10, func_25(l_10, l_31, func_32(l_31, (((l_31.f8 <= 0x3D73C12D) | l_35) || 0x51)), l_31.f4, l_31.f4))), l_31.f2)))))), l_31.f8))) && l_31.f8)), 2)), l_31, l_31.f0, l_511), l_31.f6));
    (*l_518) = l_517;
    (*l_518) = (*l_518);
    return l_519;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_4(int32_t  p_5, uint16_t  p_6, struct S0  p_7, const uint32_t  p_8, uint32_t  p_9)
{ /* block id: 230 */
    struct S0 * const l_512 = (void*)0;
    struct S0 l_515 = {0x8BAA,0x01,0x12309B60,0,0x293E5168,0xC2BDD61A,-8,-3,4};
    struct S0 *l_514 = &l_515;
    struct S0 **l_513 = &l_514;
    struct S0 ***l_516 = &l_513;
    (*l_513) = l_512;
    /* statement id: 231 */
    assert (l_514 == 0);
    (*l_516) = &l_514;
    return l_515.f7;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_13(int32_t  p_14)
{ /* block id: 205 */
    struct S0 l_481 = {65531U,1,0x9DD3CF3D,0x5743C387,0,4294967287U,0xFB,0,-6};
    struct S0 *l_480 = &l_481;
    struct S0 ****l_482 = (void*)0;
    struct S0 ** const *l_485 = (void*)0;
    struct S0 ** const **l_484 = &l_485;
    struct S0 ** const ***l_483 = &l_484;
    struct S0 **l_490 = &l_480;
    int32_t *l_509 = &l_481.f4;
    int32_t **l_510 = &l_509;
    l_480 = l_480;
    (*l_483) = l_482;
    /* statement id: 207 */
    assert (l_484 == 0);
    if ((p_14 & (safe_add_func_uint16_t_u_u(((safe_lshift_func_int16_t_s_u(((void*)0 != l_490), 10)) | ((safe_add_func_uint8_t_u_u((p_14 != (((l_481.f0 | (0x0CD57975 | l_481.f8)) > (-1)) && (-10))), p_14)) < p_14)), p_14))))
    { /* block id: 208 */
        int32_t l_495 = 0xAA4A9C5D;
        for (l_481.f0 = 0; (l_481.f0 >= 12); l_481.f0 = safe_add_func_int32_t_s_s(l_481.f0, 1))
        { /* block id: 211 */
            int32_t *l_496 = (void*)0;
            if (l_495)
                break;
            l_495 = p_14;
        }
    }
    else
    { /* block id: 215 */
        int32_t * const l_497 = &l_481.f4;
        struct S0 * const l_500 = &l_481;
        struct S0 l_508 = {65534U,-1,-10,0xCA323F51,0,0xD637567B,0x45,-9,0x1ABF67B7};
        struct S0 *l_507 = &l_508;
        if (p_14)
        { /* block id: 216 */
            int32_t *l_499 = &l_481.f4;
            int32_t **l_498 = &l_499;
            struct S0 **l_501 = &l_480;
            (*l_498) = l_497;
            (*l_501) = l_500;
            for (l_481.f0 = 0; (l_481.f0 < 11); l_481.f0 = safe_add_func_int16_t_s_s(l_481.f0, 1))
            { /* block id: 221 */
                (**l_498) = (l_481.f1 == (!(0x5F23333D > ((safe_div_func_int8_t_s_s(l_481.f7, p_14)) >= 0x62))));
            }
        }
        else
        { /* block id: 224 */
            l_507 = (*l_490);
            /* statement id: 225 */
            assert (l_507 == &l_481);
        }
        /* facts after branching */
        assert (l_507 == &l_481 || l_507 == &l_508);
    }
    (*l_510) = l_509;
    return p_14;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_25(uint8_t  p_26, struct S0  p_27, uint32_t  p_28, uint16_t  p_29, uint16_t  p_30)
{ /* block id: 196 */
    struct S0 l_463 = {0x3F35,0xC0,7,0,0x2B02CEDE,4294967295U,2,0x645BF232,0xA27A8972};
    struct S0 *l_462 = &l_463;
    struct S0 **l_461 = &l_462;
    int32_t l_478 = 0x4603DDFA;
    uint32_t l_479 = 4294967295U;
    for (p_28 = 20; (p_28 == 54); ++p_28)
    { /* block id: 199 */
        int32_t *l_458 = (void*)0;
        int32_t l_460 = (-6);
        int32_t *l_459 = &l_460;
        struct S0 ***l_464 = &l_461;
        (*l_459) = p_27.f7;
        (*l_464) = l_461;
        (*l_459) = ((((((((safe_mod_func_uint16_t_u_u(0x44C8, (safe_lshift_func_int8_t_s_s((((safe_sub_func_uint32_t_u_u(p_27.f1, ((void*)0 != (**l_464)))) | (-1)) > (p_30 == ((0x14 <= (!(safe_add_func_uint32_t_u_u((*l_459), (safe_rshift_func_uint16_t_u_u(l_463.f7, p_27.f6)))))) > 0x0A))), 6)))) & 0U) ^ (-5)) >= l_463.f3) | p_27.f3) != p_27.f4) == l_478) || 0xB358);
    }
    return l_479;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_32(struct S0  p_33, int8_t  p_34)
{ /* block id: 1 */
    const uint32_t l_39 = 1U;
    int32_t l_455 = 0x97466312;
    l_455 = func_36(l_39, p_33.f8);
    return l_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_36(const int32_t  p_37, uint32_t  p_38)
{ /* block id: 2 */
    int16_t l_57 = (-4);
    struct S0 l_58 = {65535U,-8,0x47B1D005,0x67A065BB,0x97C2923F,4294967286U,0x5C,0,0x9CF48B05};
    int32_t *l_113 = &l_58.f4;
    int32_t ** const l_112 = &l_113;
    int32_t ** const *l_111 = &l_112;
    int32_t *l_454 = &l_58.f4;
    (**l_112) = func_40(((safe_add_func_int16_t_s_s(func_48(func_51(l_57, l_58, func_59(l_57), (safe_unary_minus_func_uint32_t_u((((((safe_add_func_int8_t_s_s(((void*)0 == l_111), ((0xE2 ^ (~(safe_add_func_int32_t_s_s(((-3) && p_37), p_38)))) ^ 0x7432CFE0))) > p_38) || 0x56265DC7) <= 0x318F) && p_38))), (*l_113)), p_38), 0U)) || (*l_113)), (*l_113), (*l_113), p_37, (*l_113));
    if ((safe_lshift_func_int8_t_s_s(0x29, 4)))
    { /* block id: 179 */
        int32_t *l_423 = &l_58.f4;
        struct S0 *l_426 = &l_58;
        (*l_112) = l_423;
        (*l_112) = (void*)0;
        /* statement id: 181 */
        assert (l_113 == 0);
        (*l_423) = (p_38 ^ (((safe_rshift_func_uint16_t_u_u(((void*)0 == l_426), p_37)) > (safe_sub_func_uint16_t_u_u(((*l_423) >= (safe_sub_func_int32_t_s_s((safe_sub_func_uint8_t_u_u((~0x77), (safe_div_func_uint16_t_u_u(((0xC3 || ((9U & ((safe_mod_func_int16_t_s_s((0x171C3BC4 <= (*l_423)), (*l_423))) > (*l_423))) & 1U)) >= p_37), p_37)))), p_38))), (-1)))) == (*l_423)));
        for (l_58.f8 = 0; (l_58.f8 >= (-17)); l_58.f8 = safe_sub_func_uint16_t_u_u(l_58.f8, 1))
        { /* block id: 185 */
            return p_38;
        }
    }
    else
    { /* block id: 188 */
        const struct S0 **l_443 = (void*)0;
        const struct S0 ***l_442 = &l_443;
        int32_t ***l_446 = (void*)0;
        int32_t ****l_445 = &l_446;
        int32_t *****l_444 = &l_445;
        (*l_113) = (((safe_mod_func_int16_t_s_s((((l_442 == &l_443) < p_38) < ((((void*)0 == l_444) ^ (((p_37 != (safe_mod_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s(((safe_unary_minus_func_uint8_t_u((p_37 || (safe_div_func_int32_t_s_s(((***l_111) != p_38), (**l_112)))))) != p_38), p_38)), 0xCB6A))) == 0) == 0xEC185808)) > p_38)), p_37)) >= 6U) ^ p_38);
        return p_37;
    }
    /* facts after branching */
    assert (l_113 == 0);
    (*l_454) = 5;
    return p_37;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_40(int8_t  p_41, int16_t  p_42, int8_t  p_43, int32_t  p_44, int32_t  p_45)
{ /* block id: 52 */
    int32_t l_137 = 0;
    int32_t *l_136 = &l_137;
    int32_t **l_135 = &l_136;
    int32_t ***l_134 = &l_135;
    struct S0 l_140 = {0x6B58,-1,0xE88EED36,0xFFC8C377,-10,0U,0xA3,0xF9C57FF4,0x755EC10F};
    struct S0 *l_139 = &l_140;
    struct S0 **l_138 = &l_139;
    const int32_t * const ** const **l_220 = (void*)0;
    int8_t l_304 = 0x9B;
    uint32_t l_385 = 1U;
    const int32_t l_412 = 2;
    struct S0 ***l_414 = &l_138;
    struct S0 ****l_413 = &l_414;
    int32_t ****l_420 = (void*)0;
    int32_t **** const *l_419 = &l_420;
    if ((l_134 == (void*)0))
    { /* block id: 53 */
        struct S0 **l_141 = &l_139;
        int32_t **l_142 = &l_136;
        int32_t * const l_171 = &l_140.f4;
        int32_t ****l_262 = &l_134;
        int32_t *****l_261 = &l_262;
        uint32_t l_277 = 0U;
        int8_t l_322 = 0x17;
        int32_t l_373 = (-1);
        (***l_134) = (0 > (l_138 != l_141));
        if (((l_142 != (void*)0) & (((((void*)0 == &l_134) > (p_43 <= p_44)) != ((p_41 | (safe_sub_func_int32_t_s_s((((void*)0 == &l_135) && (**l_142)), 8))) <= p_41)) > p_44)))
        { /* block id: 55 */
            uint8_t l_157 = 1U;
            (**l_142) = (safe_add_func_uint8_t_u_u((0x23 > (~(!p_44))), (**l_142)));
            (**l_142) = ((safe_div_func_uint8_t_u_u((safe_sub_func_int8_t_s_s(((((&l_135 == (void*)0) ^ (((((***l_134) < (p_45 <= ((!(safe_unary_minus_func_int8_t_s((**l_142)))) != ((((**l_135) ^ (safe_sub_func_uint32_t_u_u(p_45, l_157))) != (l_157 | 7U)) | l_157)))) | l_157) && l_157) <= p_41)) < p_43) <= p_43), 255U)), 255U)) ^ (***l_134));
            (*l_136) = (*l_136);
            (***l_134) = ((safe_mod_func_uint8_t_u_u(l_157, (safe_div_func_int32_t_s_s(((p_41 || (l_157 && (safe_sub_func_uint16_t_u_u(((safe_sub_func_int8_t_s_s(((((**l_142) >= ((safe_sub_func_int8_t_s_s(p_45, (safe_sub_func_int8_t_s_s(p_41, ((*l_136) < (~(**l_135))))))) < 1U)) != 4U) <= (***l_134)), 0xF1)) & (**l_142)), (***l_134))))) < (**l_135)), p_42)))) >= l_157);
        }
        else
        { /* block id: 60 */
            (***l_134) = ((***l_134) == (***l_134));
lbl_174:
            (*l_142) = l_171;
            /* statement id: 62 */
            assert (l_136 == &l_140.f4);
            for (p_41 = (-12); (p_41 == (-1)); p_41 = safe_add_func_uint8_t_u_u(p_41, 1))
            { /* block id: 65 */
                if (p_42)
                    goto lbl_174;
            }
        }
        /* facts after branching */
        assert (l_136 == &l_140.f4 || l_136 == &l_137);
        if ((safe_rshift_func_int8_t_s_u((4294967290U && p_43), 2)))
        { /* block id: 69 */
            int32_t *l_193 = &l_140.f4;
            int32_t ***l_197 = (void*)0;
            struct S0 * const *l_230 = (void*)0;
            int32_t *****l_263 = &l_262;
            for (l_140.f1 = 0; (l_140.f1 >= (-16)); l_140.f1--)
            { /* block id: 72 */
                int32_t l_179 = 0xA6B184C1;
                int32_t **l_184 = &l_136;
                (**l_184) = (l_179 ^ (safe_rshift_func_int8_t_s_u((p_44 == (p_41 | ((&l_171 != l_184) >= (((safe_mod_func_int8_t_s_s((((*l_142) != (void*)0) & (safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((-1), (safe_mod_func_uint32_t_u_u((((**l_184) == 0x83A99FBD) <= 1U), p_41)))), 1))), 0xBB)) != p_45) > 0)))), 3)));
                if ((((p_42 ^ p_41) || 0) ^ (*l_171)))
                { /* block id: 74 */
                    return p_41;
                }
                else
                { /* block id: 76 */
                    int32_t *l_194 = &l_137;
                    (**l_134) = &p_45;
                    /* statement id: 77 */
                    assert (l_136 == &p_45);
                    l_194 = l_193;
                    /* statement id: 78 */
                    assert (l_194 == &l_140.f4);
                    return p_45;
                }
            }
            (**l_134) = &p_44;
            /* statement id: 82 */
            assert (l_136 == &p_44);
            if ((safe_mod_func_int16_t_s_s((((l_197 == l_197) || (&l_142 != &l_135)) | (((&l_134 != (void*)0) & (&l_171 != &l_171)) || (*l_193))), p_44)))
            { /* block id: 83 */
                int32_t *l_214 = &l_140.f4;
                const int32_t *l_244 = &l_140.f4;
                const int32_t **l_243 = &l_244;
                const int32_t ***l_242 = &l_243;
                const int32_t ****l_241 = &l_242;
                const int32_t *****l_240 = &l_241;
                (*l_142) = (*l_135);
                if (p_44)
                { /* block id: 85 */
                    (*l_193) = (((**l_142) != p_44) && p_43);
                    for (p_44 = 0; (p_44 > (-29)); p_44--)
                    { /* block id: 89 */
                        (*l_135) = (*l_142);
                    }
                }
                else
                { /* block id: 92 */
                    int32_t l_202 = (-1);
                    struct S0 * const *l_211 = &l_139;
                    const int32_t * const l_219 = &l_137;
                    const int32_t * const *l_218 = &l_219;
                    const int32_t * const **l_217 = &l_218;
                    const int32_t * const ** const *l_216 = &l_217;
                    const int32_t * const ** const **l_215 = &l_216;
                    if ((((safe_rshift_func_uint8_t_u_s(l_202, (safe_add_func_uint8_t_u_u((safe_div_func_uint8_t_u_u(p_43, (safe_lshift_func_uint16_t_u_s(((((((safe_lshift_func_uint8_t_u_s((((l_211 != l_141) & ((l_197 != &l_142) < ((*l_134) == (void*)0))) & (safe_add_func_uint32_t_u_u(((***l_134) == (-2)), p_41))), (***l_134))) ^ p_42) == 0x33) <= 0U) > 0x38) < (**l_142)), 7)))), (*l_171))))) != p_42) <= 0x6AD60D6B))
                    { /* block id: 93 */
                        (*l_135) = l_214;
                        /* statement id: 94 */
                        assert (l_136 == &l_140.f4);
                        if (l_140.f1)
                            goto lbl_221;
                        l_220 = l_215;
                        /* statement id: 95 */
                        assert (l_220 == &l_216);
                    }
                    else
                    { /* block id: 96 */
lbl_221:
                        (*l_135) = (**l_134);
                        if (p_42)
                            goto lbl_174;
                        (**l_134) = &p_44;
                        /* statement id: 100 */
                        assert (l_136 == &p_44);
                        p_44 = p_41;
                    }
                    /* facts after branching */
                    assert (l_136 == &p_44 || l_136 == &l_140.f4);
                    assert (l_220 == 0 || l_220 == &l_216);
                    for (p_43 = 0; (p_43 <= (-29)); p_43 = safe_sub_func_int8_t_s_s(p_43, 1))
                    { /* block id: 105 */
                        (**l_134) = (void*)0;
                        /* statement id: 106 */
                        assert (l_136 == 0);
                    }
                    /* facts after for loop */
                    assert (l_136 == 0 || l_136 == &p_44 || l_136 == &l_140.f4);
                    (*l_193) = ((safe_lshift_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_s((*l_214), 0)), 0)) > ((l_230 == &l_139) <= (safe_lshift_func_int8_t_s_s(((((p_43 < (*l_171)) != ((****l_216) == (safe_mod_func_uint32_t_u_u((safe_mod_func_uint8_t_u_u(((((!(****l_216)) <= ((void*)0 != l_240)) != 0x3B49) != (****l_216)), (-6))), p_45)))) < 0) || (*l_214)), 3)))), (**l_218))) && p_43);
                    (*l_214) = (safe_sub_func_int16_t_s_s(p_42, (((0U != p_41) & (safe_sub_func_int8_t_s_s(p_42, (safe_mod_func_uint8_t_u_u(p_44, p_42))))) < ((*l_141) != (*l_211)))));
                }
                /* facts after branching */
                assert (l_136 == 0 || l_136 == &p_44 || l_136 == &l_140.f4);
                //assert (l_220 == 0 || l_220 == dangling);
                p_44 = (0x58 || (((0x8F >= ((p_44 ^ ((safe_add_func_uint16_t_u_u(p_42, (~(safe_rshift_func_uint16_t_u_s((safe_add_func_int8_t_s_s((*l_171), (safe_add_func_uint32_t_u_u(((p_41 != ((safe_unary_minus_func_uint8_t_u((0 != (((((l_261 == l_263) >= p_44) <= (*l_193)) > 0) >= (-9))))) <= (*l_193))) <= (*l_193)), (*l_244))))), (*l_193)))))) <= 255U)) < p_43)) >= 65527U) & 0xDD72962D));
            }
            else
            { /* block id: 112 */
                uint32_t l_271 = 0U;
                (****l_261) = (****l_263);
                (*l_136) = ((*****l_263) && (safe_div_func_int16_t_s_s((-1), (safe_lshift_func_uint16_t_u_s(((*****l_263) & (safe_add_func_int8_t_s_s((0x33990AE0 ^ (safe_unary_minus_func_uint8_t_u(0U))), ((*l_262) != (**l_263))))), (l_271 || (safe_sub_func_int8_t_s_s(((safe_div_func_uint8_t_u_u(((!(*l_193)) || p_44), p_43)) | 0x56), l_277))))))));
            }
            /* facts after branching */
            assert (l_136 == 0 || l_136 == &p_44 || l_136 == &l_140.f4);
            //assert (l_220 == 0 || l_220 == dangling);
        }
        else
        { /* block id: 116 */
            struct S0 * const *l_280 = &l_139;
            int32_t l_290 = 0;
            int32_t ***l_298 = &l_142;
            for (l_277 = 0; (l_277 >= 42); ++l_277)
            { /* block id: 119 */
                const struct S0 *l_283 = &l_140;
                const struct S0 **l_282 = &l_283;
                const struct S0 ***l_281 = &l_282;
                int32_t l_291 = (-3);
                int32_t * const *l_295 = (void*)0;
                int32_t * const ** const l_294 = &l_295;
                int32_t *l_319 = &l_290;
                (*l_281) = l_280;
                /* statement id: 120 */
                assert (l_282 == &l_139);
            }
        }
        /* facts after branching */
        assert (l_136 == &l_140.f4 || l_136 == &l_137 || l_136 == 0 || l_136 == &p_44);
        //assert (l_220 == 0 || l_220 == dangling);
        for (l_277 = 11; (l_277 > 1); l_277 = safe_sub_func_uint32_t_u_u(l_277, 1))
        { /* block id: 157 */
            const uint32_t l_382 = 5U;
            (*l_142) = (void*)0;
            /* statement id: 158 */
            assert (l_136 == 0);
            (*l_171) = ((!1) == (safe_mod_func_uint8_t_u_u((safe_add_func_int8_t_s_s((~l_382), (0xD2BC ^ (0x55A2 == l_385)))), p_41)));
        }
    }
    else
    { /* block id: 161 */
        int32_t ***l_397 = &l_135;
        int32_t **** const l_406 = &l_134;
        int32_t **** const *l_405 = &l_406;
        int16_t l_411 = (-1);
        if ((safe_rshift_func_uint8_t_u_s((safe_div_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u(((safe_unary_minus_func_uint8_t_u((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s(((l_397 == l_397) ^ (0x262E621D ^ (safe_rshift_func_int8_t_s_u(((***l_397) != (((!(((safe_sub_func_uint8_t_u_u((***l_134), (p_41 || (safe_div_func_uint16_t_u_u((((l_405 == (void*)0) <= ((safe_add_func_int8_t_s_s((safe_div_func_uint8_t_u_u((p_44 ^ p_44), p_41)), p_41)) != p_44)) < l_411), 0x5B98))))) | 0xF909D75B) < (-1))) & p_41) & l_412)), 7)))), p_42)), (***l_134))))) > 0x6D5B2996), (*l_136))), 5)), p_43)))
        { /* block id: 162 */
            struct S0 *****l_415 = &l_413;
            int32_t *l_418 = &l_140.f4;
            (*l_415) = l_413;
            for (l_140.f3 = 0; (l_140.f3 == 22); l_140.f3 = safe_add_func_uint16_t_u_u(l_140.f3, 9))
            { /* block id: 166 */
                return p_41;
            }
            (**l_134) = l_418;
            /* statement id: 169 */
            assert (l_136 == &l_140.f4);
        }
        else
        { /* block id: 170 */
            l_419 = &l_406;
            /* statement id: 171 */
            assert (l_419 == &l_406);
        }
        /* facts after branching */
        assert (l_136 == &l_137 || l_136 == &l_140.f4);
        assert (l_419 == &l_406 || l_419 == &l_420);
    }
    /* facts after branching */
    assert (l_136 == &l_140.f4 || l_136 == &l_137 || l_136 == 0 || l_136 == &p_44);
    //assert (l_220 == 0 || l_220 == dangling);
    //assert (l_419 == dangling || l_419 == &l_420);
    l_134 = &l_135;
    (***l_413) = (**l_414);
    (*l_138) = (*l_138);
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_48(struct S0  p_49, int16_t  p_50)
{ /* block id: 47 */
    const struct S0 *l_130 = (void*)0;
    const struct S0 **l_129 = &l_130;
    int32_t l_132 = 0;
    int32_t *l_131 = &l_132;
    int32_t **l_133 = &l_131;
    (*l_129) = &p_49;
    /* statement id: 48 */
    assert (l_130 == &p_49);
    (*l_133) = l_131;
    (**l_133) = ((&l_133 == &l_133) || (&l_130 == &l_130));
    return p_49.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_51(uint32_t  p_52, struct S0  p_53, uint32_t  p_54, uint32_t  p_55, uint32_t  p_56)
{ /* block id: 30 */
    int32_t l_125 = 0x2E8431F4;
    int32_t *l_124 = &l_125;
    int32_t **l_123 = &l_124;
    for (p_53.f8 = 0; (p_53.f8 < (-25)); p_53.f8--)
    { /* block id: 33 */
        for (p_53.f1 = 0; (p_53.f1 == (-7)); p_53.f1 = safe_sub_func_uint8_t_u_u(p_53.f1, 2))
        { /* block id: 36 */
            int32_t *l_121 = (void*)0;
            int32_t **l_122 = &l_121;
            (*l_122) = l_121;
            l_122 = l_123;
            /* statement id: 38 */
            assert (l_122 == &l_124);
        }
    }
    for (p_53.f1 = 0; (p_53.f1 < 11); p_53.f1 = safe_add_func_int16_t_s_s(p_53.f1, 6))
    { /* block id: 43 */
        struct S0 l_128 = {1U,0xCD,0xB2F8DC5A,0,0xAF5047EB,4294967287U,-1,-3,0x10A37157};
        return l_128;
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_59(int32_t  p_60)
{ /* block id: 3 */
    uint8_t l_61 = 0x6E;
    int32_t l_94 = (-5);
    int32_t *l_93 = &l_94;
    int32_t ***l_106 = (void*)0;
    if ((l_61 <= ((safe_div_func_uint16_t_u_u((safe_sub_func_int8_t_s_s((p_60 > (safe_div_func_int16_t_s_s((safe_unary_minus_func_int16_t_s((safe_lshift_func_int16_t_s_u(l_61, 9)))), (safe_sub_func_uint16_t_u_u(l_61, (-8)))))), ((p_60 < ((safe_lshift_func_int8_t_s_s(((p_60 >= (safe_rshift_func_uint8_t_u_s(((safe_lshift_func_int16_t_s_u((safe_rshift_func_int8_t_s_u((((safe_mod_func_uint16_t_u_u((7 == ((-1) <= l_61)), l_61)) ^ p_60) >= 0xFB), l_61)), p_60)) != l_61), l_61))) | 4), 1)) >= 0xCA6A6683)) >= (-1)))), 1)) && p_60)))
    { /* block id: 4 */
        int32_t l_85 = 0x27840302;
        int32_t l_87 = 0x07F58E95;
        int32_t *l_86 = &l_87;
        int32_t **l_88 = &l_86;
        l_85 = (1 >= (safe_lshift_func_uint8_t_u_u(0x37, 3)));
        (*l_88) = l_86;
    }
    else
    { /* block id: 7 */
        int32_t l_90 = (-8);
        int32_t *l_89 = &l_90;
        int32_t **l_95 = &l_89;
        (*l_89) = 0x6445A0AE;
        (*l_89) = (safe_div_func_int8_t_s_s(l_61, p_60));
        (*l_95) = l_93;
        /* statement id: 10 */
        assert (l_89 == &l_94);
        (*l_95) = (void*)0;
        /* statement id: 11 */
        assert (l_89 == 0);
    }
    for (p_60 = (-21); (p_60 == 16); p_60 = safe_add_func_int16_t_s_s(p_60, 1))
    { /* block id: 15 */
        int32_t *l_102 = (void*)0;
        int32_t l_104 = (-5);
        int32_t **l_105 = &l_93;
        int32_t ****l_107 = &l_106;
        for (l_94 = 0; (l_94 != 2); ++l_94)
        { /* block id: 18 */
            int32_t l_101 = 0xBA0E3889;
            int32_t *l_100 = &l_101;
            int32_t **l_103 = &l_102;
            (*l_100) = 3;
            (*l_103) = l_102;
            (*l_100) = (*l_100);
            l_104 = p_60;
        }
    }
    (*l_93) = (*l_93);
    return p_60;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 79
   depth: 1, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 26
breakdown:
   depth: 1, occurrence: 146
   depth: 2, occurrence: 20
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 24, occurrence: 1
   depth: 26, occurrence: 3

XXX total number of pointers: 107

XXX times a variable address is taken: 119
XXX times a pointer is dereferenced on RHS: 106
breakdown:
   depth: 1, occurrence: 50
   depth: 2, occurrence: 26
   depth: 3, occurrence: 24
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 71
breakdown:
   depth: 1, occurrence: 51
   depth: 2, occurrence: 12
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 19
XXX times a pointer is compared with address of another variable: 9
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 268

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 117
   level: 2, occurrence: 53
   level: 3, occurrence: 44
   level: 4, occurrence: 7
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 69
XXX number of pointers point to scalars: 28
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 19.6
XXX average alias set size: 1.17

XXX times a non-volatile is read: 622
XXX times a non-volatile is write: 206
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 121
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 25
   depth: 2, occurrence: 30
   depth: 3, occurrence: 11
   depth: 4, occurrence: 10
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
********************* end of statistics **********************/

