/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      4092866834
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 23;
   unsigned f1 : 16;
   unsigned f2 : 18;
   unsigned f3 : 22;
};

union U1 {
   uint32_t  f0;
   signed f1 : 25;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 0x020BD2AB;
static uint16_t g_19 = 0x8039;
static int32_t g_59 = 0x5285B5F7;
static int32_t *g_58 = &g_59;
static struct S0 g_77[3] = {{1375,55,319,11},{1375,55,319,11},{1375,55,319,11}};
static union U1 g_80 = {0x2358CEDF};
static uint8_t g_90 = 0x66;
static const struct S0 *g_105 = &g_77[2];
static uint8_t g_143 = 0xE2;
static int32_t g_190 = 0xF156DC98;
static struct S0 g_229 = {2830,141,478,400};
static union U1 g_230[2][7] = {{{0U},{0x5113CCDA},{0U},{0xAB0D6962},{0xAB0D6962},{0U},{0x5113CCDA}},{{0xAB0D6962},{0x5113CCDA},{4294967295U},{4294967295U},{0x5113CCDA},{0xAB0D6962},{0x5113CCDA}}};
static int32_t ***g_237 = (void*)0;
static int32_t *** const *g_255 = &g_237;
static int32_t ****g_446 = &g_237;
static int32_t *****g_445 = &g_446;
static union U1 *g_461 = &g_230[1][1];
static union U1 **g_460 = &g_461;
static struct S0 *****g_499 = (void*)0;
static struct S0 *g_557 = &g_77[2];
static struct S0 **g_556 = &g_557;
static struct S0 ***g_555 = &g_556;
static uint8_t g_574[6][5][5] = {{{7U,0x60,255U,3U,248U},{0U,0x54,0U,0xA4,0xC5},{0U,0x29,1U,7U,0U},{7U,4U,0xBA,4U,7U},{4U,255U,0xFC,0xB1,0x64}},{{0xBA,1U,252U,0x10,0xA4},{0x9E,0U,0xA4,0xD1,0xB1},{0U,0x19,2U,252U,4U},{0xB1,0U,0xF8,0x54,246U},{0xF8,255U,4U,0x10,0xFC}},{{4U,0xBA,0xB8,0x10,0U},{3U,0xCF,4U,0x54,0x54},{255U,0xFE,255U,252U,3U},{248U,0xB8,0x6E,0xD1,0xCF},{0x60,2U,0x9E,0x19,0xB8}},{{255U,0xAD,0x6E,0xCF,0xEA},{252U,0xEA,255U,1U,0U},{7U,0xC0,4U,4U,0xF8},{0xFC,255U,0xB8,0xAD,252U},{0xFE,255U,4U,0xB8,0x64}},{{0xA4,0xC0,0xF8,0xF8,0xC0},{0xB8,0xEA,2U,0xBA,1U},{0U,0xAD,0xA4,3U,4U},{0x10,2U,1U,0xB1,0x6E},{0U,0xB8,0x54,0x60,1U}},{{0xB8,0xFE,0xEA,0xFC,4U},{0xA4,0xCF,0xBA,248U,0x19},{0xFE,0xBA,0xF6,0xC5,0x19},{0xFC,255U,0xD1,0U,4U},{7U,0U,0U,7U,1U}}};
static struct S0 ** const *g_615 = &g_556;
static struct S0 ** const **g_614 = &g_615;
static struct S0 ** const ***g_613 = &g_614;
static int32_t *g_670 = &g_59;
static const int32_t *g_677 = &g_59;


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static const struct S0  func_2(int32_t  p_3, const uint32_t  p_4);
inline static uint32_t  func_6(int16_t  p_7);
static uint32_t  func_8(const uint32_t  p_9, int32_t  p_10, union U1  p_11);
static union U1  func_13(uint32_t  p_14, int32_t  p_15, int32_t  p_16, int32_t  p_17, int16_t  p_18);
inline static struct S0  func_25(struct S0  p_26, struct S0  p_27, union U1  p_28);
inline static struct S0  func_29(int16_t  p_30);
inline static struct S0  func_32(uint32_t  p_33, int8_t  p_34, int32_t  p_35, const uint16_t  p_36, int8_t  p_37);
static uint8_t  func_38(const struct S0  p_39, int8_t  p_40, int8_t  p_41, int8_t  p_42);
inline static int16_t  func_50(uint16_t  p_51, int32_t  p_52, uint16_t  p_53, int32_t  p_54, int32_t  p_55);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_12 = 0xB969;
    uint8_t l_20 = 255U;
    struct S0 l_799 = {1137,189,398,65};
    int32_t *l_803 = &g_59;
    const struct S0 ****l_809 = (void*)0;
    union U1 **l_830 = &g_461;
    const union U1 *l_832[7] = {&g_230[1][2],&g_230[0][3],&g_230[0][3],&g_230[1][2],&g_230[0][3],&g_230[0][3],&g_230[1][2]};
    const union U1 ** const l_831[6] = {&l_832[3],&l_832[3],&l_832[3],&l_832[3],&l_832[3],&l_832[3]};
    int32_t l_844[8];
    int i;
    for (i = 0; i < 8; i = i + 1)
        l_844[i] = 0x67FFC54B;
    return l_844[3];
}


/* ------------------------------------------ */
/* 
 * reads : g_230.f1 g_77.f3 g_59 g_229.f1 g_556 g_557 g_460 g_80.f0 g_77 g_237 g_5 g_190 g_230.f0 g_670 g_80.f1 g_446 g_143 g_19 g_614 g_615 g_555 g_90 g_229.f2 g_229.f0
 * writes: g_5 g_77 g_59 g_80.f0 g_461 g_557 g_190 g_90 g_58 g_677 g_19 g_143
 */
static const struct S0  func_2(int32_t  p_3, const uint32_t  p_4)
{ /* block id: 506 */
    uint32_t l_625[10] = {0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B,0xD0B7965B};
    struct S0 *l_636[6];
    int32_t *l_643[3][10][6] = {{{&g_190,&g_59,(void*)0,&g_190,&g_59,&g_190},{&g_190,&g_59,&g_59,&g_190,&g_190,&g_59},{&g_59,&g_59,(void*)0,&g_59,(void*)0,&g_59},{&g_190,&g_59,&g_190,(void*)0,&g_59,&g_59},{&g_59,&g_59,&g_59,&g_59,&g_59,&g_59},{&g_59,&g_59,&g_190,&g_190,&g_59,&g_190},{&g_59,&g_190,&g_190,&g_190,&g_59,(void*)0},{&g_59,&g_59,&g_190,&g_59,&g_59,&g_59},{&g_190,&g_59,&g_190,&g_190,&g_190,&g_59},{&g_59,&g_190,&g_59,&g_190,&g_59,&g_190}},{{&g_59,&g_190,&g_59,&g_190,(void*)0,&g_190},{(void*)0,&g_59,&g_190,&g_59,&g_190,&g_59},{&g_59,&g_190,&g_59,&g_59,&g_59,&g_190},{&g_190,&g_190,(void*)0,&g_59,&g_59,(void*)0},{&g_190,&g_190,&g_190,&g_59,&g_190,&g_59},{&g_190,&g_59,&g_59,&g_59,&g_59,&g_59},{&g_59,&g_190,&g_59,&g_59,&g_59,(void*)0},{(void*)0,&g_59,&g_190,&g_190,&g_190,&g_59},{&g_59,&g_190,(void*)0,&g_190,&g_59,(void*)0},{&g_59,(void*)0,&g_59,&g_190,&g_190,&g_59}},{{&g_190,&g_190,&g_59,&g_190,(void*)0,&g_59},{&g_190,&g_59,&g_59,(void*)0,&g_59,&g_59},{&g_190,&g_190,&g_59,(void*)0,&g_190,&g_59},{&g_190,(void*)0,&g_59,&g_59,&g_59,&g_59},{&g_59,&g_59,&g_59,&g_59,&g_59,(void*)0},{(void*)0,&g_190,(void*)0,&g_190,&g_59,&g_59},{&g_59,&g_190,&g_190,&g_59,&g_59,(void*)0},{&g_190,&g_59,&g_59,&g_59,&g_59,&g_59},{&g_59,&g_59,&g_59,&g_59,(void*)0,&g_59},{&g_190,&g_190,&g_190,&g_59,&g_190,(void*)0}}};
    const struct S0 l_652 = {-624,103,216,1941};
    int32_t **l_693 = &g_58;
    int32_t l_695 = 1;
    int32_t **** const *l_703 = &g_446;
    struct S0 ****l_715 = (void*)0;
    struct S0 *****l_714[8];
    uint16_t l_719 = 0xA832;
    const union U1 **l_736 = (void*)0;
    int32_t **l_767 = &l_643[0][7][4];
    uint16_t l_784[6][10] = {{8U,1U,0U,65535U,1U,0x07BB,1U,65535U,0U,1U},{8U,0x4216,0xD798,65535U,0x4216,0xC78D,1U,0xD798,0xD798,1U},{0xC78D,1U,0xD798,0xD798,1U,0xC78D,0x4216,65535U,0xD798,0x4216},{8U,1U,0U,65535U,1U,0x07BB,1U,65535U,0U,1U},{8U,0x4216,0xD798,65535U,0x4216,0xC78D,1U,0xD798,0xD798,1U},{0xC78D,1U,0xD798,0xD798,1U,0xC78D,0x4216,0x4216,0U,0x25CD}};
    const struct S0 l_798 = {1689,42,316,874};
    int i, j, k;
    for (i = 0; i < 6; i = i + 1)
        l_636[i] = (void*)0;
    for (i = 0; i < 8; i = i + 1)
        l_714[i] = &l_715;
    if (((safe_lshift_func_uint16_t_u_s((safe_lshift_func_uint8_t_u_s((((((1 | l_625[6]) == 0x677A) && (safe_add_func_uint8_t_u_u(g_230[0][6].f1, (safe_mod_func_uint32_t_u_u(g_77[2].f3, (safe_lshift_func_uint8_t_u_u(((safe_sub_func_int32_t_s_s(l_625[6], ((safe_rshift_func_uint16_t_u_s(((void*)0 == l_636[5]), (p_3 == (-10)))) && p_4))) <= g_59), 5))))))) ^ g_229.f1) <= 0x9F73), 7)), 15)) || 0x390956B0))
    { /* block id: 507 */
lbl_657:
        for (g_5 = (-5); (g_5 >= 10); g_5 = safe_add_func_int16_t_s_s(g_5, 7))
        { /* block id: 510 */
            int32_t *l_639 = &g_59;
            l_639 = &p_3;
            /* statement id: 511 */
            assert (l_639 == &p_3);
            if ((*l_639))
                break;
        }
    }
    else
    { /* block id: 514 */
        int32_t **l_640 = &g_58;
        struct S0 * const ****l_641 = (void*)0;
        struct S0 l_654[8][1] = {{{-171,176,281,465}},{{1223,57,408,1476}},{{-171,176,281,465}},{{1223,57,408,1476}},{{-171,176,281,465}},{{1223,57,408,1476}},{{-171,176,281,465}},{{1223,57,408,1476}}};
        union U1 l_655[9] = {{0x249E53E7},{0x249E53E7},{0x249E53E7},{0x249E53E7},{0x249E53E7},{0x249E53E7},{0x249E53E7},{0x249E53E7},{0x249E53E7}};
        int32_t l_694 = (-6);
        int32_t l_717 = 0xEB92E389;
        int i, j;
        p_3 = (((0x0703D941 && ((p_3 != (l_636[5] != (void*)0)) <= p_3)) != ((((void*)0 != l_640) ^ ((void*)0 == l_641)) >= l_625[0])) != l_625[8]);
        if (l_625[6])
        { /* block id: 516 */
            struct S0 l_642 = {1399,73,225,811};
            struct S0 ***l_646 = &g_556;
            const int32_t *l_675[9][7][2] = {{{(void*)0,(void*)0},{&g_59,&g_190},{&g_59,(void*)0},{(void*)0,&g_190},{(void*)0,(void*)0},{(void*)0,(void*)0},{&g_190,&g_59}},{{&g_59,&g_190},{(void*)0,&g_190},{&g_190,&g_190},{(void*)0,&g_190},{&g_59,&g_59},{&g_190,(void*)0},{(void*)0,(void*)0}},{{(void*)0,&g_190},{(void*)0,(void*)0},{&g_59,&g_190},{&g_59,(void*)0},{(void*)0,&g_190},{(void*)0,(void*)0},{(void*)0,(void*)0}},{{&g_190,&g_59},{&g_59,&g_190},{(void*)0,&g_190},{&g_190,&g_190},{(void*)0,&g_190},{&g_59,&g_59},{&g_190,(void*)0}},{{(void*)0,(void*)0},{(void*)0,&g_190},{(void*)0,(void*)0},{&g_59,&g_190},{&g_59,(void*)0},{(void*)0,&g_190},{(void*)0,(void*)0}},{{(void*)0,(void*)0},{&g_190,&g_59},{&g_59,&g_190},{(void*)0,&g_190},{&g_190,&g_190},{(void*)0,&g_190},{&g_59,&g_59}},{{&g_190,(void*)0},{(void*)0,(void*)0},{(void*)0,&g_190},{(void*)0,(void*)0},{&g_59,&g_190},{&g_59,(void*)0},{(void*)0,&g_190}},{{(void*)0,(void*)0},{(void*)0,(void*)0},{&g_190,&g_59},{&g_59,&g_190},{(void*)0,&g_190},{&g_190,&g_190},{(void*)0,&g_190}},{{&g_59,&g_59},{&g_190,(void*)0},{(void*)0,(void*)0},{(void*)0,&g_190},{(void*)0,(void*)0},{&g_59,&g_190},{&g_59,(void*)0}}};
            const int32_t **l_676[10][10][2] = {{{&l_675[2][4][1],&l_675[4][0][1]},{&l_675[2][4][1],&l_675[5][6][1]},{&l_675[4][6][0],(void*)0},{&l_675[5][6][1],&l_675[5][6][1]},{(void*)0,&l_675[7][6][0]},{&l_675[7][5][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[2][4][1]},{&l_675[2][5][0],(void*)0}},{{&l_675[7][6][0],(void*)0},{&l_675[5][6][1],&l_675[2][3][0]},{(void*)0,&l_675[2][3][0]},{&l_675[5][6][1],(void*)0},{&l_675[7][6][0],(void*)0},{&l_675[2][5][0],&l_675[2][4][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[7][5][1],&l_675[7][6][0]}},{{(void*)0,&l_675[5][6][1]},{&l_675[5][6][1],(void*)0},{&l_675[4][6][0],&l_675[2][5][0]},{&l_675[7][5][1],&l_675[4][6][0]},{&l_675[7][5][1],&l_675[2][5][0]},{&l_675[4][5][0],&l_675[5][6][1]},{&l_675[2][5][0],&l_675[2][3][0]},{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[4][1][0]},{&l_675[4][1][0],&l_675[5][6][1]}},{{(void*)0,&l_675[4][0][1]},{&l_675[5][6][1],&l_675[7][5][1]},{&l_675[2][4][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[2][4][1],&l_675[7][5][1]},{&l_675[5][6][1],&l_675[4][0][1]}},{{(void*)0,&l_675[5][6][1]},{&l_675[4][1][0],&l_675[4][1][0]},{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[2][3][0]},{&l_675[2][5][0],&l_675[5][6][1]},{&l_675[4][5][0],&l_675[2][5][0]},{&l_675[7][5][1],&l_675[4][6][0]},{&l_675[7][5][1],&l_675[2][5][0]},{&l_675[4][5][0],&l_675[5][6][1]},{&l_675[2][5][0],&l_675[2][3][0]}},{{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[4][1][0]},{&l_675[4][1][0],&l_675[5][6][1]},{(void*)0,&l_675[4][0][1]},{&l_675[5][6][1],&l_675[7][5][1]},{&l_675[2][4][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]}},{{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[2][4][1],&l_675[7][5][1]},{&l_675[5][6][1],&l_675[4][0][1]},{(void*)0,&l_675[5][6][1]},{&l_675[4][1][0],&l_675[4][1][0]},{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[2][3][0]},{&l_675[2][5][0],&l_675[5][6][1]},{&l_675[4][5][0],&l_675[2][5][0]},{&l_675[7][5][1],&l_675[4][6][0]}},{{&l_675[7][5][1],&l_675[2][5][0]},{&l_675[4][5][0],&l_675[5][6][1]},{&l_675[2][5][0],&l_675[2][3][0]},{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[4][1][0]},{&l_675[4][1][0],&l_675[5][6][1]},{(void*)0,&l_675[4][0][1]},{&l_675[5][6][1],&l_675[7][5][1]},{&l_675[2][4][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]}},{{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[5][6][1],&l_675[5][6][1]},{&l_675[2][4][1],&l_675[7][5][1]},{&l_675[5][6][1],&l_675[4][0][1]},{(void*)0,&l_675[5][6][1]},{&l_675[4][1][0],&l_675[4][1][0]},{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[2][3][0]}},{{&l_675[2][5][0],&l_675[5][6][1]},{&l_675[4][5][0],&l_675[2][5][0]},{&l_675[7][5][1],&l_675[4][6][0]},{&l_675[7][5][1],&l_675[2][5][0]},{&l_675[4][5][0],&l_675[5][6][1]},{&l_675[2][5][0],&l_675[2][3][0]},{(void*)0,&l_675[5][6][1]},{(void*)0,&l_675[4][1][0]},{&l_675[4][1][0],&l_675[5][6][1]},{(void*)0,&l_675[4][0][1]}}};
            int i, j, k;
            (**g_556) = l_642;
lbl_674:
            for (g_59 = 9; (g_59 >= 2); g_59 -= 1)
            { /* block id: 520 */
                union U1 l_651 = {4294967293U};
                struct S0 l_653 = {848,93,5,251};
                if (((0xE1D2 > ((255U >= l_642.f3) & 0xDFE2)) >= p_3))
                { /* block id: 521 */
                    if (p_4)
                        break;
                    p_3 = p_4;
                }
                else
                { /* block id: 524 */
                    int32_t *l_644 = &g_190;
                    int32_t ***** const l_645 = &g_446;
                    for (g_80.f0 = 0; (g_80.f0 <= 2); g_80.f0 += 1)
                    { /* block id: 527 */
                        (*g_460) = &g_80;
                        /* statement id: 528 */
                        assert (g_461 == &g_80);
                    }
                    l_644 = l_643[0][7][4];
                    /* statement id: 530 */
                    assert (l_644 == 0 || l_644 == &g_59 || l_644 == &g_190);
                    p_3 = (&g_446 == l_645);
                }
                for (g_80.f0 = 0; (g_80.f0 <= 2); g_80.f0 += 1)
                { /* block id: 535 */
                    struct S0 ***l_647 = &g_556;
                    int32_t *l_648 = &g_190;
                    struct S0 l_650 = {-2237,177,437,116};
                    struct S0 l_656 = {-2657,0,117,1373};
                    if ((l_646 != l_647))
                    { /* block id: 536 */
                        l_642.f0 = (-1);
                    }
                    else
                    { /* block id: 538 */
                        int8_t l_649[7][5][2] = {{{0x3C,0x55},{3,0x55},{0x3C,3},{0x08,0x08},{0x08,3}},{{0x3C,0x55},{3,0x55},{0x3C,3},{0x08,0x08},{0x08,3}},{{0x3C,0x55},{3,0x55},{0x3C,3},{0x08,0x08},{0x08,3}},{{0x3C,0x55},{3,0x55},{0x3C,3},{3,3},{3,0x3C}},{{(-7),0x08},{0x3C,0x08},{(-7),0x3C},{3,3},{3,0x3C}},{{(-7),0x08},{0x3C,0x08},{(-7),0x3C},{3,3},{3,0x3C}},{{(-7),0x08},{0x3C,0x08},{(-7),0x3C},{3,3},{3,0x3C}}};
                        int i, j, k;
                        (**l_647) = (void*)0;
                        /* statement id: 539 */
                        assert (g_557 == 0);
                        l_648 = &p_3;
                        /* statement id: 540 */
                        assert (l_648 == &p_3);
                        if (l_649[1][3][0])
                            continue;
                    }
                    /* facts after branching */
                    assert (l_648 == &p_3 || l_648 == &g_190);
                    for (g_190 = 8; (g_190 >= 0); g_190 -= 1)
                    { /* block id: 545 */
                        int i;
                        l_642 = func_25(g_77[g_80.f0], l_650, l_651);
                        l_653 = l_652;
                        l_656 = func_25(l_654[4][0], g_77[g_80.f0], l_655[3]);
                        l_653 = g_77[g_80.f0];
                    }
                    if (p_4)
                    { /* block id: 551 */
                        (*l_640) = (void*)0;
                        /* statement id: 552 */
                        assert (g_58 == 0);
                        (*l_640) = &p_3;
                        /* statement id: 553 */
                        assert (g_58 == &p_3);
                        if (g_5)
                            goto lbl_657;
                    }
                    else
                    { /* block id: 555 */
                        if ((*l_648))
                            break;
                        return l_653;
                        /* statement id: 557 */
                        //assert (g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
                    }
                    /* facts after branching */
                    assert (g_58 == &p_3);
                    if ((safe_lshift_func_int8_t_s_u((((p_3 <= ((((p_4 < ((safe_sub_func_uint32_t_u_u(((safe_rshift_func_int16_t_s_s(0x9F82, (l_646 != (void*)0))) != (((l_642.f3 | (65535U | (safe_rshift_func_uint8_t_u_s(g_190, (safe_add_func_uint32_t_u_u((p_4 & p_4), g_230[0][6].f0)))))) & 2) || p_3)), (-5))) && 0xF53C)) && p_3) > p_3) > 0x8B6C13B0)) | l_642.f1) < p_3), 0)))
                    { /* block id: 559 */
                        (*l_640) = g_670;
                        /* statement id: 560 */
                        assert (g_58 == &g_59);
                    }
                    else
                    { /* block id: 561 */
                        const int32_t * const l_671 = &g_59;
                        const int32_t *l_672 = (void*)0;
                        const struct S0 l_673 = {808,194,434,306};
                        l_672 = l_671;
                        /* statement id: 562 */
                        assert (l_672 == &g_59);
                        if (l_652.f0)
                            goto lbl_674;
                        return l_673;
                        /* statement id: 563 */
                        //assert (g_58 == dangling);
                    }
                    /* facts after branching */
                    assert (g_58 == &g_59);
                }
            }
            g_677 = l_675[5][6][1];
            /* statement id: 568 */
            assert (g_677 == 0 || g_677 == &g_190 || g_677 == &g_59);
        }
        else
        { /* block id: 569 */
            int32_t *****l_702 = &g_446;
            (*g_670) = ((safe_add_func_int32_t_s_s(((void*)0 != l_643[0][8][5]), ((safe_sub_func_uint8_t_u_u((0x6C && (((-9) > (+((-2) == (safe_mod_func_int16_t_s_s((safe_sub_func_int8_t_s_s((((safe_sub_func_int16_t_s_s((safe_lshift_func_uint8_t_u_u(0U, 3)), (safe_mod_func_uint8_t_u_u((l_693 == l_640), g_190)))) >= l_694) == 0xAF865F43), 0x52)), 0xD5DD))))) <= g_80.f1)), l_695)) || 0xD5))) == (*g_670));
            for (l_695 = 0; (l_695 <= 5); l_695 += 1)
            { /* block id: 573 */
                uint32_t l_716 = 2U;
                (*g_670) = ((safe_sub_func_uint16_t_u_u(p_3, (((safe_lshift_func_uint16_t_u_s((safe_rshift_func_int8_t_s_u((g_77[2].f2 >= ((((l_702 == l_703) > (safe_mod_func_uint16_t_u_u((safe_add_func_int8_t_s_s(((*l_702) == (*l_702)), (((safe_rshift_func_int16_t_s_s((safe_lshift_func_uint8_t_u_u((p_3 || p_4), (safe_lshift_func_int16_t_s_s(((void*)0 != l_714[0]), p_3)))), l_716)) | 0x8A) < g_143))), 6))) != 0x9BBA4D87) || 0x52)), g_77[2].f2)), 2)) || p_3) ^ l_717))) != 1U);
                (*g_670) = p_4;
                (*l_640) = &p_3;
                /* statement id: 576 */
                assert (g_58 == &p_3);
                for (g_19 = 0; (g_19 <= 5); g_19 += 1)
                { /* block id: 579 */
                    int32_t l_718 = 0xBBF183BA;
                    const struct S0 l_720 = {-1692,63,202,1780};
                    if (l_718)
                        break;
                    if (l_719)
                        continue;
                    for (g_5 = 0; (g_5 <= 5); g_5 += 1)
                    { /* block id: 584 */
                        int i;
                        l_636[g_5] = (***g_614);
                        /* statement id: 585 */
                        //assert ((l_636[0] >= &g_77[0] && l_636[0] <= &g_77[2]) || l_636[0] == 0);
                        return l_720;
                        /* statement id: 586 */
                        //assert (g_58 == dangling);
                    }
                    if (p_3)
                        continue;
                }
            }
            /* facts after for loop */
            //assert (g_58 == &p_3 || g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
            (***g_555) = (*g_557);
        }
        /* facts after branching */
        //assert (g_58 == &p_3 || g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
        //assert (g_461 == &g_80 || g_461 == dangling || (g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
        assert (g_557 == 0 || (g_557 >= &g_77[0] && g_557 <= &g_77[2]));
        assert (g_677 == 0 || g_677 == &g_190 || g_677 == &g_59);
        for (l_719 = 0; (l_719 >= 49); ++l_719)
        { /* block id: 595 */
            union U1 *l_731 = &g_230[0][6];
            uint32_t l_742 = 0x3B13C559;
            for (g_143 = 0; (g_143 <= 2); g_143 += 1)
            { /* block id: 598 */
                int32_t * const ****l_734 = (void*)0;
                int32_t l_743 = 0x22032559;
                struct S0 **l_759 = &l_636[5];
                struct S0 l_764 = {2525,102,117,401};
                for (g_59 = 2; (g_59 >= 0); g_59 -= 1)
                { /* block id: 601 */
                    uint8_t l_737[2];
                    int32_t *l_741[1];
                    int32_t *l_749[10] = {&l_743,&l_695,&l_743,&l_743,&l_695,&l_743,&l_743,&l_695,&l_743,&l_743};
                    int i;
                    for (i = 0; i < 2; i = i + 1)
                        l_737[i] = 0x79;
                    for (i = 0; i < 1; i = i + 1)
                        l_741[i] = &g_59;
                    if (((~(~(safe_mod_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_u((l_731 == (void*)0), (safe_rshift_func_int16_t_s_u((l_734 == l_703), ((~0x44933A33) && (l_736 == &g_461)))))) <= g_77[2].f2), l_737[1])), g_80.f0)))) || p_4))
                    { /* block id: 602 */
                        int i, j, k;
                        l_743 = (((0 & (p_4 & (p_3 <= ((p_4 && (safe_sub_func_uint32_t_u_u((((void*)0 != &g_255) > 3), ((~((l_741[0] != (void*)0) < (*g_670))) | p_4)))) && l_742)))) | g_143) & l_742);
                    }
                    else
                    { /* block id: 604 */
                        int32_t *l_746 = &g_59;
                        int i, j, k;
                        l_655[3].f1 = (safe_rshift_func_int8_t_s_s(g_59, p_3));
                        l_643[g_143][(g_59 + 5)][g_143] = l_746;
                    }
                    for (p_3 = (-14); (p_3 > (-22)); p_3 = safe_sub_func_uint8_t_u_u(p_3, 5))
                    { /* block id: 610 */
                        const struct S0 l_750 = {-2888,223,364,1254};
                        l_749[7] = l_741[0];
                        /* statement id: 611 */
                        //assert (l_749[0] == &g_59 || l_749[0] == &l_695 || l_749[0] == &l_743);
                        return l_750;
                        /* statement id: 612 */
                        //assert (g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
                    }
                }
                if (l_742)
                { /* block id: 615 */
                    struct S0 **l_760 = &l_636[5];
                    int32_t l_761 = (-7);
                    const uint16_t l_762 = 0xD601;
                    for (l_742 = (-22); (l_742 >= 58); ++l_742)
                    { /* block id: 618 */
                        if (p_4)
                            break;
                    }
                    (*g_670) = ((safe_add_func_int32_t_s_s((safe_lshift_func_int8_t_s_u(((*g_670) | (0x1E <= (safe_sub_func_int32_t_s_s((g_90 != l_742), ((l_759 == l_760) & (((void*)0 != &g_255) & p_4)))))), l_761)), l_762)) ^ g_229.f2);
                }
                else
                { /* block id: 622 */
                    uint16_t l_763[7];
                    int i;
                    for (i = 0; i < 7; i = i + 1)
                        l_763[i] = 0xC3DB;
                    if (l_763[0])
                        break;
                }
                l_764 = l_654[4][0];
                p_3 = ((l_742 >= p_3) && (safe_rshift_func_int8_t_s_s((l_767 == (void*)0), 1)));
            }
        }
        /* facts after for loop */
            }
    /* facts after branching */
    //assert (g_58 == &p_3 || g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
    //assert (g_461 == &g_80 || g_461 == dangling || (g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
    assert (g_557 == 0 || (g_557 >= &g_77[0] && g_557 <= &g_77[2]));
    assert (g_677 == 0 || g_677 == &g_190 || g_677 == &g_59);
    for (l_719 = 9; (l_719 >= 50); l_719 = safe_add_func_uint32_t_u_u(l_719, 6))
    { /* block id: 632 */
        uint32_t l_774 = 0U;
        int32_t l_775[8][2];
        const struct S0 **l_782 = &g_105;
        int16_t l_783 = 0x2F9D;
        struct S0 l_788 = {274,152,213,1940};
        int i, j;
        for (i = 0; i < 8; i = i + 1)
        {
            for (j = 0; j < 2; j = j + 1)
                l_775[i][j] = 0;
        }
        (*g_670) = ((safe_sub_func_uint16_t_u_u(0x86E2, ((((safe_lshift_func_uint8_t_u_u(3U, 0)) && (l_774 == 0x0EA5)) > l_775[6][1]) >= ((((((safe_add_func_uint8_t_u_u((safe_add_func_uint8_t_u_u((p_4 > (((l_775[4][0] != l_775[6][1]) <= (((((((safe_rshift_func_int8_t_s_s(((*g_555) != l_782), 7)) <= l_775[6][1]) <= l_774) && 65526U) == p_3) > (-6)) && l_775[6][1])) || 0)), g_229.f2)), l_783)) >= 0x8D48) > l_783) & 1) || l_784[1][0]) <= l_774)))) > p_4);
        for (l_783 = 29; (l_783 != 8); --l_783)
        { /* block id: 636 */
            const struct S0 l_787 = {1495,58,94,864};
            struct S0 **l_797 = (void*)0;
            l_788 = l_787;
            p_3 = 0x79D64551;
            (*g_670) = ((safe_mod_func_int8_t_s_s(((l_788.f1 || g_230[0][6].f0) ^ (safe_mod_func_uint8_t_u_u((6U > (safe_rshift_func_int8_t_s_u(((safe_add_func_int32_t_s_s(0x7A1F1704, (((*g_670) <= (l_788.f1 ^ ((g_19 && ((((void*)0 != l_797) > 0xD8) == g_229.f0)) ^ p_4))) < p_4))) > g_77[2].f3), 6))), 0x32))), l_775[6][1])) != p_4);
        }
        (*l_693) = &p_3;
        /* statement id: 641 */
        assert (g_58 == &p_3);
    }
    return l_798;
    /* statement id: 643 */
    //assert (g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
}


/* ------------------------------------------ */
/* 
 * reads : g_229.f1 g_229.f2 g_574 g_229.f0 g_59 g_80.f1 g_5 g_143 g_90 g_77.f3 g_190 g_77.f1 g_77 g_237 g_557 g_446 g_460 g_556 g_230.f0 g_80.f0 g_19
 * writes: g_59 g_190 g_90 g_77 g_58 g_461 g_613
 */
inline static uint32_t  func_6(int16_t  p_7)
{ /* block id: 452 */
    int32_t *l_565[10][5][5] = {{{&g_59,&g_190,&g_190,&g_190,(void*)0},{&g_59,&g_59,&g_190,&g_190,(void*)0},{&g_59,&g_190,&g_190,&g_59,&g_59},{&g_190,&g_59,(void*)0,&g_59,(void*)0},{(void*)0,&g_59,&g_190,&g_59,&g_59}},{{(void*)0,&g_190,&g_190,&g_190,(void*)0},{(void*)0,(void*)0,&g_190,&g_190,&g_190},{(void*)0,(void*)0,&g_190,(void*)0,(void*)0},{&g_190,&g_190,&g_59,(void*)0,&g_190},{&g_59,&g_59,(void*)0,&g_59,&g_59}},{{&g_59,(void*)0,&g_59,&g_190,&g_190},{&g_59,&g_190,&g_190,&g_59,&g_59},{&g_59,&g_59,(void*)0,(void*)0,&g_190},{&g_59,&g_190,&g_59,&g_59,&g_59},{&g_190,&g_190,&g_59,(void*)0,&g_190}},{{&g_190,&g_190,&g_190,&g_59,&g_190},{&g_190,(void*)0,(void*)0,&g_190,(void*)0},{(void*)0,&g_190,&g_59,&g_59,&g_190},{&g_190,&g_59,(void*)0,(void*)0,&g_59},{&g_59,(void*)0,&g_59,(void*)0,&g_190}},{{&g_59,&g_59,&g_59,&g_190,&g_59},{(void*)0,&g_59,&g_190,&g_190,(void*)0},{&g_190,&g_59,(void*)0,&g_59,&g_190},{&g_59,&g_59,&g_59,&g_59,&g_190},{&g_190,(void*)0,&g_190,&g_59,(void*)0}},{{&g_59,&g_59,&g_59,&g_190,&g_190},{&g_190,&g_190,&g_59,&g_190,(void*)0},{&g_59,(void*)0,&g_190,(void*)0,&g_59},{&g_59,&g_190,(void*)0,&g_190,&g_59},{&g_59,&g_190,(void*)0,&g_190,&g_190}},{{&g_190,&g_59,&g_190,(void*)0,&g_59},{(void*)0,&g_190,&g_59,&g_190,&g_59},{&g_59,&g_190,&g_190,&g_190,(void*)0},{&g_59,&g_59,(void*)0,&g_59,&g_59},{(void*)0,&g_190,&g_190,(void*)0,&g_190}},{{&g_59,(void*)0,&g_190,&g_190,&g_190},{&g_190,&g_190,&g_190,&g_59,&g_59},{&g_59,&g_59,&g_190,&g_190,&g_190},{(void*)0,&g_190,&g_190,(void*)0,&g_190},{&g_59,&g_59,&g_190,&g_59,(void*)0}},{{&g_59,&g_190,&g_190,&g_190,&g_59},{&g_59,&g_190,&g_190,&g_59,&g_190},{&g_190,&g_59,(void*)0,&g_59,&g_59},{&g_190,&g_190,&g_190,&g_190,&g_190},{&g_190,(void*)0,&g_59,&g_59,&g_190}},{{&g_59,&g_59,&g_190,&g_190,(void*)0},{&g_59,&g_190,(void*)0,(void*)0,&g_190},{&g_59,(void*)0,&g_190,&g_190,&g_190},{&g_190,(void*)0,&g_59,&g_190,&g_59},{&g_190,&g_59,&g_59,&g_190,&g_190}}};
    int32_t l_568 = 0xA0F8008E;
    struct S0 l_589[3][1] = {{{1006,96,0,2044}},{{1006,96,0,2044}},{{1006,96,0,2044}}};
    uint8_t l_599[6];
    uint32_t l_607 = 0x252B1399;
    uint8_t l_609 = 0xA3;
    uint16_t l_618 = 0x23A6;
    int i, j, k;
    for (i = 0; i < 6; i = i + 1)
        l_599[i] = 0x49;
    l_565[9][3][3] = l_565[9][3][3];
    if (p_7)
    { /* block id: 454 */
        int8_t l_569[5][10] = {{0,7,0,0,7,0,9,9,0,7},{7,0,0,7,0,9,9,0,7,0},{7,7,9,0,0,0,0,9,7,7},{0,0,9,7,7,9,0,0,0,0},{0,7,0,0,7,0,9,9,0,7}};
        int32_t l_587 = (-4);
        int32_t **l_594 = &g_58;
        int32_t ***l_593 = &l_594;
        int8_t l_602 = (-1);
        struct S0 ***l_608 = &g_556;
        struct S0 ** const **l_612 = (void*)0;
        struct S0 ** const ***l_611 = &l_612;
        int i, j;
        if ((safe_add_func_uint8_t_u_u(p_7, (((((l_568 != 0xDAB27499) ^ ((0x97 > p_7) && 0x39B336FE)) <= l_569[2][8]) >= (p_7 && ((safe_sub_func_uint32_t_u_u((((safe_add_func_int8_t_s_s((g_229.f1 == 0x949D), 0xB7)) ^ 1) >= 0x8D07), g_229.f2)) != g_574[2][2][3]))) ^ g_229.f0))))
        { /* block id: 455 */
            const int8_t l_580 = 0;
            int32_t *l_592 = &g_190;
            for (g_59 = 1; (g_59 <= 4); g_59 += 1)
            { /* block id: 458 */
                uint16_t l_577 = 0x3C05;
                struct S0 l_595 = {1877,127,169,1239};
                l_587 = (safe_rshift_func_uint8_t_u_s(l_577, ((((safe_lshift_func_uint16_t_u_s(((0x36 ^ g_80.f1) != ((g_80.f1 | l_580) & g_574[0][2][2])), 12)) == (safe_add_func_uint8_t_u_u(0x23, ((safe_add_func_uint16_t_u_u((safe_add_func_uint8_t_u_u((p_7 != ((0xB5 < p_7) >= g_5)), (-4))), 0xB992)) > p_7)))) == l_580) ^ p_7)));
                for (l_587 = 0; (l_587 <= 4); l_587 += 1)
                { /* block id: 462 */
                    int32_t * const l_588 = (void*)0;
                    union U1 l_590[6] = {{4294967293U},{4294967293U},{4294967293U},{4294967293U},{4294967293U},{4294967293U}};
                    int i;
                    l_565[9][3][3] = l_588;
                    (*g_557) = func_25(func_32(((g_143 & (p_7 != (0x6979 && 8))) == 0xB2), g_229.f1, p_7, l_587, p_7), l_589[1][0], l_590[0]);
                    for (l_577 = 0; (l_577 <= 4); l_577 += 1)
                    { /* block id: 467 */
                        int32_t *l_591[3];
                        int i;
                        for (i = 0; i < 3; i = i + 1)
                            l_591[i] = &g_59;
                        (*l_592) = ((l_591[0] != l_592) > (0xADC5 > (((*g_446) == l_593) ^ 0xFEF917AC)));
                        (**l_593) = l_592;
                        /* statement id: 469 */
                        assert (g_58 == &g_190);
                    }
                    for (l_568 = 4; (l_568 >= 1); l_568 -= 1)
                    { /* block id: 473 */
                        (*g_460) = &l_590[4];
                        /* statement id: 474 */
                        assert ((g_461 >= &l_590[0] && g_461 <= &l_590[5]));
                        (*l_594) = l_592;
                        /* statement id: 475 */
                        assert (g_58 == &g_190);
                        (**l_593) = l_592;
                        (**g_556) = l_595;
                    }
                    /* facts after for loop */
                    //assert ((g_461 >= &l_590[0] && g_461 <= &l_590[5]) || g_461 == dangling || (g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
                }
            }
            /* facts after for loop */
            //assert (g_58 == &g_190 || g_58 == dangling || g_58 == &g_59);
            //assert (g_461 == dangling || (g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
        }
        else
        { /* block id: 481 */
            for (l_587 = (-24); (l_587 < 5); l_587 = safe_add_func_int32_t_s_s(l_587, 1))
            { /* block id: 484 */
                const int16_t l_598 = (-1);
                l_599[5] = l_598;
            }
        }
        /* facts after branching */
        //assert (g_58 == &g_190 || g_58 == dangling || g_58 == &g_59);
        //assert (g_461 == dangling || (g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
        for (p_7 = 0; (p_7 >= (-28)); p_7 = safe_sub_func_int32_t_s_s(p_7, 6))
        { /* block id: 490 */
            uint32_t l_610 = 0xC0C06F63;
            if (l_602)
                break;
            (**g_556) = func_32((((0x9374 > (g_77[2].f3 & ((safe_sub_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s((l_607 && (0x2024 & p_7)), 7)) & g_230[0][6].f0), 0)) > (65532U <= (l_608 != (void*)0))))) | g_80.f0) > l_609), l_610, l_610, g_229.f1, g_229.f1);
        }
        g_613 = l_611;
        /* statement id: 494 */
        assert (g_613 == &l_612);
        return g_19;
        /* statement id: 495 */
        //assert (g_613 == dangling);
    }
    else
    { /* block id: 496 */
        l_565[9][3][3] = l_565[6][2][0];
    }
    for (g_59 = 0; (g_59 > 3); ++g_59)
    { /* block id: 501 */
        int32_t *l_619[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
        int32_t **l_620 = &g_58;
        int i;
        if (l_618)
            break;
        (*l_620) = l_619[1];
        /* statement id: 503 */
        assert (g_58 == &g_190 || g_58 == 0);
    }
    /* facts after for loop */
    //assert (g_58 == &g_190 || g_58 == 0 || g_58 == dangling || g_58 == &g_59);
    return g_574[2][2][3];
}


/* ------------------------------------------ */
/* 
 * reads : g_229.f1
 * writes:
 */
static uint32_t  func_8(const uint32_t  p_9, int32_t  p_10, union U1  p_11)
{ /* block id: 450 */
    return g_229.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_229.f2 g_229.f0 g_229.f1 g_229.f3 g_58 g_59 g_77.f2 g_230.f0 g_90 g_77.f3 g_143 g_190 g_77.f1 g_77 g_5 g_255 g_237 g_80 g_80.f0 g_80.f1 g_230 g_105 g_19 g_460 g_446 g_499 g_461 g_555
 * writes: g_58 g_59 g_190 g_229 g_105 g_77 g_90 g_445 g_80.f0 g_19 g_461 g_143
 */
static union U1  func_13(uint32_t  p_14, int32_t  p_15, int32_t  p_16, int32_t  p_17, int16_t  p_18)
{ /* block id: 1 */
    int8_t l_266 = 1;
    int32_t l_269 = 0xC4433856;
    union U1 *l_292 = &g_230[0][6];
    int16_t l_300 = 0x470D;
    struct S0 *l_326 = (void*)0;
    const struct S0 l_359 = {1049,105,56,1112};
    int32_t * const *l_371 = &g_58;
    int32_t * const **l_370 = &l_371;
    int32_t * const ***l_369 = &l_370;
    int32_t * const ****l_368 = &l_369;
    uint32_t l_397[4];
    int32_t l_403[9][2] = {{0xB07C44A1,(-6)},{0xB07C44A1,0xB07C44A1},{(-6),0xB07C44A1},{0xB07C44A1,(-6)},{0xB07C44A1,0xB07C44A1},{(-6),0xB07C44A1},{0xB07C44A1,(-6)},{0xB07C44A1,0xB07C44A1},{(-6),0xB07C44A1}};
    int32_t * const l_420 = &g_59;
    union U1 *l_467 = (void*)0;
    struct S0 **l_480 = &l_326;
    struct S0 ***l_479 = &l_480;
    struct S0 ****l_478[8] = {&l_479,&l_479,&l_479,&l_479,&l_479,&l_479,&l_479,(void*)0};
    struct S0 *****l_477 = &l_478[0];
    int32_t *l_514 = &g_59;
    struct S0 * const *l_530 = (void*)0;
    struct S0 * const **l_529 = &l_530;
    int i, j;
    for (i = 0; i < 4; i = i + 1)
        l_397[i] = 0x810E5A72;
    if (p_14)
    { /* block id: 2 */
        int32_t *** const *l_253[4][3] = {{(void*)0,&g_237,&g_237},{&g_237,(void*)0,&g_237},{(void*)0,(void*)0,(void*)0},{&g_237,&g_237,&g_237}};
        struct S0 *l_273 = &g_77[2];
        struct S0 **l_272 = &l_273;
        int i, j;
        for (p_16 = 0; (p_16 < 5); ++p_16)
        { /* block id: 5 */
            int32_t * const *l_259 = &g_58;
            int32_t * const **l_258 = &l_259;
            int32_t * const ***l_257 = &l_258;
            int32_t * const ****l_256 = &l_257;
            for (p_15 = 26; (p_15 >= (-24)); p_15 = safe_sub_func_int8_t_s_s(p_15, 6))
            { /* block id: 8 */
                int32_t l_31 = 0;
                struct S0 *l_243 = &g_77[2];
                int32_t *l_244 = &g_59;
            }
        }
        g_58 = &p_16;
        /* statement id: 186 */
        assert (g_58 == &p_16);
    }
    else
    { /* block id: 187 */
        const int32_t l_275 = 8;
        int32_t *l_316[2][6][4] = {{{&g_59,&l_269,&g_190,&l_269},{&l_269,&l_269,&g_190,&l_269},{&g_190,&l_269,&g_190,&g_190},{(void*)0,(void*)0,&g_190,&g_59},{(void*)0,&l_269,&g_190,(void*)0},{&g_190,&g_59,&g_190,&g_190}},{{&l_269,&g_59,&g_190,(void*)0},{&g_59,&l_269,&l_269,&g_59},{&g_190,(void*)0,&l_269,&g_190},{&g_59,&l_269,&g_190,&l_269},{&l_269,&l_269,&g_190,&l_269},{&g_190,&l_269,&g_190,&g_190}}};
        struct S0 * const *l_377 = (void*)0;
        union U1 l_414 = {0xADE9F822};
        struct S0 **l_435 = (void*)0;
        struct S0 ***l_434 = &l_435;
        struct S0 ****l_433[10] = {&l_434,&l_434,&l_434,&l_434,&l_434,&l_434,&l_434,&l_434,&l_434,&l_434};
        int32_t **l_496 = (void*)0;
        int32_t ***l_495 = &l_496;
        const int32_t * const l_502 = &l_269;
        int i, j, k;
        if (l_266)
        { /* block id: 188 */
            uint32_t l_293[2];
            int8_t l_308[6];
            struct S0 l_315 = {-2339,252,134,124};
            int32_t * const *l_325 = (void*)0;
            int32_t * const **l_324 = &l_325;
            int i;
            for (i = 0; i < 2; i = i + 1)
                l_293[i] = 0x293A9199;
            for (i = 0; i < 6; i = i + 1)
                l_308[i] = 5;
lbl_310:
            (*g_58) = ((((l_275 >= (((~l_269) || (safe_mod_func_uint8_t_u_u(p_17, ((safe_sub_func_int8_t_s_s((safe_add_func_uint32_t_u_u(((safe_sub_func_uint32_t_u_u((g_229.f2 & (((safe_add_func_uint8_t_u_u((((l_275 <= 0x7C460DB7) & l_266) ^ (((safe_add_func_uint8_t_u_u(((+(((l_269 && ((void*)0 == l_292)) != p_15) != (-10))) & 0), g_229.f2)) == p_16) < g_229.f0)), g_229.f1)) <= l_293[1]) != g_229.f3)), l_275)) | p_14), p_14)), (-1))) ^ 0)))) || 0xEDAE)) >= l_266) >= 1) == l_275);
            for (p_14 = (-13); (p_14 > 56); p_14 = safe_add_func_uint8_t_u_u(p_14, 2))
            { /* block id: 192 */
                const int8_t l_303 = 0x6C;
                struct S0 *l_309 = &g_229;
                (*l_309) = func_32(l_266, ((1U <= (safe_rshift_func_int8_t_s_s(0x9B, (p_15 <= (safe_rshift_func_uint16_t_u_u(l_266, (((l_300 & ((((((safe_sub_func_uint8_t_u_u(l_303, ((((*g_58) != (safe_sub_func_int8_t_s_s(((safe_add_func_uint16_t_u_u(((0x8FB9EDC9 >= 4294967295U) < (*g_58)), l_275)) < 0xEC), p_18))) || 4) ^ p_14))) | l_303) != g_77[2].f2) != 1U) & p_18) > g_230[0][6].f0)) < (-1)) <= p_15))))))) <= 0x19CC), l_308[0], l_275, l_266);
                (*g_58) = l_275;
                if (g_59)
                    goto lbl_310;
            }
            if ((*g_58))
            { /* block id: 197 */
                int32_t *l_317 = (void*)0;
                for (p_15 = 0; (p_15 != 18); p_15 = safe_add_func_int16_t_s_s(p_15, 9))
                { /* block id: 200 */
                    for (p_14 = 3; (p_14 > 37); ++p_14)
                    { /* block id: 203 */
                    }
                }
            }
            else
            { /* block id: 208 */
                const uint8_t l_323 = 0U;
                (*g_58) = (((safe_rshift_func_int8_t_s_u((1U < ((~0xBDF9) == (safe_rshift_func_uint16_t_u_s((p_15 <= ((l_323 | g_5) < ((*g_255) != l_324))), 1)))), g_77[2].f3)) || ((void*)0 != l_326)) != l_323);
            }
        }
        else
        { /* block id: 211 */
            struct S0 *l_327 = &g_77[2];
            struct S0 **l_328 = &l_327;
            int32_t **l_337 = (void*)0;
            uint16_t l_372[4];
            union U1 *l_438[5][2][1] = {{{&g_230[0][6]},{&g_80}},{{&g_230[0][6]},{&g_80}},{{&g_230[0][6]},{&g_80}},{{&g_230[0][6]},{&g_80}},{{&g_230[0][6]},{&g_80}}};
            int32_t * const l_439 = (void*)0;
            int32_t *l_442 = (void*)0;
            int i, j, k;
            for (i = 0; i < 4; i = i + 1)
                l_372[i] = 65535U;
lbl_375:
            (*l_328) = l_327;
            if (p_16)
            { /* block id: 213 */
                int32_t ****l_339 = &g_237;
                int32_t *****l_338 = &l_339;
                if ((safe_rshift_func_uint8_t_u_u((safe_sub_func_uint16_t_u_u(g_230[0][6].f0, p_15)), (safe_lshift_func_int8_t_s_u((((safe_add_func_int8_t_s_s((&g_58 != l_337), (&g_255 == l_338))) || (safe_add_func_uint32_t_u_u((0x6899F1E4 == 0xB41A43FA), g_143))) < 0x1D875F6C), 7)))))
                { /* block id: 214 */
                    int32_t *l_342 = &l_269;
                    int32_t **l_343 = (void*)0;
                    l_316[1][5][1] = l_342;
                    return g_80;
                    /* statement id: 216 */
                                    }
                else
                { /* block id: 217 */
                    int8_t l_344 = (-9);
                    for (p_18 = 0; (p_18 <= 1); p_18 += 1)
                    { /* block id: 220 */
                        if (l_344)
                            break;
                        (*l_328) = &g_229;
                        /* statement id: 222 */
                        assert (l_327 == &g_229);
                    }
                }
            }
            else
            { /* block id: 225 */
                const int32_t l_357 = 4;
                int32_t ****l_389 = (void*)0;
                struct S0 l_413[1][8][1] = {{{{142,40,283,24}},{{-680,174,392,1617}},{{142,40,283,24}},{{-680,174,392,1617}},{{142,40,283,24}},{{-680,174,392,1617}},{{142,40,283,24}},{{-680,174,392,1617}}}};
                const int32_t *l_422 = &g_190;
                union U1 *l_443 = &g_230[1][6];
                int32_t **l_448 = &l_442;
                int i, j, k;
                if ((g_80.f0 == (((safe_rshift_func_int8_t_s_u((!((safe_mod_func_int16_t_s_s((((safe_add_func_uint16_t_u_u(((((0 <= ((0U && (&l_316[1][3][2] != (void*)0)) ^ (((&g_80 == (void*)0) > (safe_rshift_func_int8_t_s_s(((!((((safe_mod_func_int32_t_s_s((0U & (0x3372 > l_266)), 0x1C12E972)) | 0xD564) <= 0xF52D) ^ p_14)) > 255U), 7))) ^ l_357))) | l_300) | p_16) < g_230[0][6].f0), 0x4F16)) > 0x00) < 65535U), g_229.f1)) ^ (-1))), 2)) & 0x6D) | (-1))))
                { /* block id: 226 */
                    const uint8_t l_358 = 249U;
                    int32_t l_373 = (-4);
                    int32_t **l_382 = &g_58;
                    if (l_358)
                    { /* block id: 227 */
                        (*g_58) = (-1);
                        (*l_328) = &g_229;
                        /* statement id: 229 */
                        assert (l_327 == &g_229);
                        (*l_327) = l_359;
                    }
                    else
                    { /* block id: 231 */
                        uint8_t l_360 = 0x20;
                        l_360 = p_16;
                        if (l_269)
                            goto lbl_381;
                    }
lbl_381:
                    if ((*g_58))
                    { /* block id: 234 */
                        int32_t l_374 = 0x6979E7A4;
                        (*g_58) = ((+l_358) != ((safe_add_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(((((((((safe_lshift_func_uint8_t_u_s(0xAF, ((&g_105 != &l_326) > ((((l_357 < (((l_368 == &g_255) <= p_16) | (p_16 >= g_80.f1))) <= 1) >= 0U) || p_16)))) < p_15) > l_357) > l_372[1]) < 2) & 0) | l_373) || (-1)), 13)), p_14)) < l_374));
                    }
                    else
                    { /* block id: 236 */
                        const struct S0 **l_380 = &g_105;
                        if (l_358)
                            goto lbl_375;
                        (*****l_368) = (((~(l_377 != &l_326)) != ((safe_rshift_func_int16_t_s_u(g_77[2].f2, 5)) & 4U)) <= (&g_59 != (void*)0));
                        (*l_380) = &l_359;
                        /* statement id: 239 */
                        assert (g_105 == &l_359);
                    }
                    /* facts after branching */
                    assert (g_105 == &l_359 || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                    (*l_382) = (void*)0;
                    /* statement id: 242 */
                    assert (g_58 == 0);
                }
                else
                { /* block id: 243 */
                    int32_t l_390 = 0x758EF842;
                    union U1 l_391 = {4294967294U};
                    (***l_370) = (safe_rshift_func_uint8_t_u_u(((((((*g_255) != (*g_255)) > (safe_sub_func_int16_t_s_s((p_16 || 3U), 0U))) > (p_15 <= (((void*)0 != l_389) >= p_18))) && p_14) >= p_14), l_390));
                    for (l_269 = 0; (l_269 <= 3); l_269 += 1)
                    { /* block id: 247 */
                        return l_391;
                        /* statement id: 248 */
                                            }
                    return (*l_292);
                    /* statement id: 250 */
                                    }
                /* facts after branching */
                assert (g_58 == 0);
                assert (g_105 == &l_359 || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
lbl_419:
                for (p_18 = (-20); (p_18 >= (-3)); p_18 = safe_add_func_uint16_t_u_u(p_18, 1))
                { /* block id: 254 */
                    int32_t **l_394[1][6];
                    int32_t **l_395 = &g_58;
                    struct S0 l_396 = {1769,14,353,649};
                    int i, j;
                    for (i = 0; i < 1; i = i + 1)
                    {
                        for (j = 0; j < 6; j = j + 1)
                            l_394[i][j] = &l_316[1][0][1];
                    }
                    (*l_395) = (***l_369);
                    for (p_14 = 0; (p_14 <= 1); p_14 += 1)
                    { /* block id: 258 */
                        int32_t *l_408 = &g_190;
                        (*l_327) = l_396;
                        if (l_397[0])
                            break;
                        p_16 = (safe_unary_minus_func_uint32_t_u(((safe_lshift_func_uint16_t_u_u((0x750183FA < ((safe_sub_func_uint16_t_u_u(l_403[4][0], (~(~p_14)))) != (((safe_lshift_func_uint8_t_u_u((((((void*)0 == l_408) ^ 0xC5) && 0xBFF9) > 1U), 3)) > 9) == g_77[2].f2))), 2)) || 0x5C)));
                        p_16 = (g_229.f1 || (p_14 >= (g_80.f0 || ((safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(g_59, 13)), p_14)) & p_16))));
                    }
                    (*l_327) = func_25(l_413[0][7][0], l_396, l_414);
                }
                if ((((safe_rshift_func_int16_t_s_s(g_143, 14)) >= g_77[2].f0) <= (&l_316[0][0][2] != &g_58)))
                { /* block id: 266 */
                    const int32_t **l_423 = &l_422;
                    for (g_90 = (-14); (g_90 != 7); g_90 = safe_add_func_uint16_t_u_u(g_90, 3))
                    { /* block id: 269 */
                        int32_t **l_421 = &l_316[0][2][3];
                        if (g_90)
                            goto lbl_419;
                        (*l_421) = l_420;
                    }
                    (*l_423) = l_422;
                    for (l_266 = 3; (l_266 >= 0); l_266 -= 1)
                    { /* block id: 276 */
                        struct S0 * const **l_425 = &l_377;
                        struct S0 * const ***l_424 = &l_425;
                        int i;
                        (*l_423) = &p_16;
                        /* statement id: 277 */
                        assert (l_422 == &p_16);
                        if (l_397[l_266])
                            break;
                        (*l_424) = &l_377;
                        if (l_372[1])
                            break;
                    }
                    /* facts after for loop */
                    assert (l_422 == &p_16 || l_422 == &g_190);
                }
                else
                { /* block id: 282 */
                    for (p_14 = (-10); (p_14 != 15); p_14 = safe_add_func_int8_t_s_s(p_14, 1))
                    { /* block id: 285 */
                        struct S0 l_428 = {1889,154,463,1926};
                        int32_t **l_440[10][10][2] = {{{&g_58,(void*)0},{&g_58,&l_316[1][5][1]},{&g_58,&l_316[1][5][1]},{&l_316[1][5][2],&l_316[1][1][1]},{&g_58,&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][2][0]},{&l_316[1][5][1],&g_58},{&g_58,&g_58},{&l_316[1][5][1],&l_316[1][2][0]}},{{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]},{&g_58,&l_316[1][1][1]},{&l_316[1][5][2],&l_316[1][5][1]},{&g_58,&l_316[1][5][1]},{&g_58,(void*)0},{&g_58,&l_316[1][5][3]},{&l_316[1][4][1],&g_58},{&l_316[1][5][0],&l_316[0][4][1]},{&l_316[1][5][3],(void*)0}},{{&l_316[1][5][1],&g_58},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&g_58},{&l_316[1][2][0],&l_316[1][5][1]},{&l_316[1][5][1],&g_58},{&l_316[1][5][1],(void*)0},{&l_316[1][4][2],&g_58},{&l_316[1][5][0],&l_316[1][4][1]},{&g_58,&l_316[1][5][3]},{&l_316[1][4][1],&g_58}},{{&g_58,&l_316[0][2][0]},{(void*)0,&l_316[1][5][1]},{(void*)0,&g_58},{&g_58,&l_316[1][5][2]},{(void*)0,&l_316[1][5][1]},{&l_316[0][2][0],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&g_58},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]}},{{(void*)0,&l_316[1][5][1]},{&g_58,&g_58},{&l_316[1][5][2],&l_316[0][2][1]},{(void*)0,&l_316[1][5][1]},{&l_316[1][5][1],&g_58},{&g_58,&l_316[1][4][2]},{&g_58,&g_58},{(void*)0,&g_58},{&l_316[1][5][3],&g_58},{&l_316[1][5][1],&g_58}},{{&g_58,&g_58},{(void*)0,&l_316[1][5][1]},{(void*)0,&g_58},{(void*)0,&l_316[1][5][1]},{&g_58,&l_316[1][0][0]},{&l_316[1][5][1],&l_316[1][5][1]},{(void*)0,&l_316[1][5][1]},{&l_316[1][5][1],&g_58},{&g_58,&l_316[0][4][1]},{(void*)0,&g_58}},{{&l_316[1][5][2],(void*)0},{&l_316[0][2][1],&g_58},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][4][2],&l_316[0][4][0]},{&g_58,(void*)0},{&l_316[1][5][1],&g_58},{(void*)0,(void*)0},{&l_316[1][5][1],(void*)0},{&l_316[1][5][1],&l_316[1][2][0]},{&l_316[1][4][2],&l_316[0][0][1]}},{{(void*)0,&g_58},{&l_316[0][0][0],&g_58},{&l_316[1][5][2],&l_316[1][5][1]},{&g_58,&l_316[0][4][1]},{&l_316[1][4][1],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]},{&g_58,&l_316[1][5][2]},{&g_58,&l_316[1][0][2]},{&l_316[1][5][1],&g_58}},{{&g_58,&l_316[1][4][1]},{(void*)0,&l_316[0][3][2]},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[0][3][2],&l_316[1][5][2]},{&l_316[1][5][1],&g_58},{&l_316[1][5][1],&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][5][1]},{&g_58,&g_58},{&g_58,&g_58},{&l_316[1][0][0],&g_58}},{{&l_316[0][2][1],&g_58},{(void*)0,&l_316[1][5][1]},{&l_316[1][5][1],&l_316[1][2][0]},{&g_58,&g_58},{&l_316[1][5][1],&g_58},{&l_316[0][2][3],&g_58},{&l_316[1][5][1],&g_58},{&g_58,&l_316[1][2][0]},{&l_316[1][5][1],&l_316[1][5][1]},{(void*)0,&g_58}}};
                        int32_t **l_441 = (void*)0;
                        int i, j, k;
                        (**l_328) = (*g_105);
                        g_77[2] = l_428;
                        (**l_328) = func_32(g_59, ((safe_mod_func_uint16_t_u_u(((g_77[2].f1 ^ ((((l_428.f3 && g_19) | (safe_rshift_func_int16_t_s_s((((l_433[3] == (void*)0) <= ((safe_add_func_uint16_t_u_u(((l_438[1][1][0] == (void*)0) <= 0), g_5)) == g_229.f2)) > p_14), 10))) == g_230[0][6].f0) == g_77[2].f3)) <= (-1)), g_5)) >= 0x06F5), p_18, g_80.f0, p_17);
                        l_442 = l_439;
                    }
                    if (p_18)
                    { /* block id: 291 */
                        union U1 **l_444 = &l_443;
                        (*l_444) = l_443;
                        g_445 = (void*)0;
                        /* statement id: 293 */
                        assert (g_445 == 0);
                        if (p_15)
                            goto lbl_419;
                    }
                    else
                    { /* block id: 295 */
                        int32_t *l_447[2];
                        int i;
                        for (i = 0; i < 2; i = i + 1)
                            l_447[i] = &g_190;
                        (**l_328) = (*g_105);
                        l_447[0] = &p_16;
                        /* statement id: 297 */
                        //assert (l_447[0] == &p_16 || l_447[0] == &g_190);
                    }
                }
                /* facts after branching */
                assert (l_422 == &p_16 || l_422 == &g_190);
                (*l_448) = (***l_369);
            }
            /* facts after branching */
            assert (g_58 == 0 || g_58 == &g_59);
            assert (g_105 == &l_359 || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
            assert (g_445 == &g_446 || g_445 == 0);
            g_58 = &p_16;
            /* statement id: 302 */
            assert (g_58 == &p_16);
            for (l_266 = 0; (l_266 >= 0); l_266 -= 1)
            { /* block id: 305 */
                union U1 **l_449 = &l_438[3][1][0];
                const int16_t l_462 = 0x0EC5;
                int32_t ****l_465 = &g_237;
                struct S0 ***l_481 = (void*)0;
                int32_t *l_482 = &g_59;
                (*l_449) = (void*)0;
                for (g_90 = 0; (g_90 <= 2); g_90 += 1)
                { /* block id: 309 */
                    int32_t *l_450[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                    int i;
                    for (g_59 = 0; (g_59 >= 0); g_59 -= 1)
                    { /* block id: 312 */
                        if ((*g_58))
                            break;
                        return l_414;
                        /* statement id: 314 */
                        //assert (g_58 == dangling);
                        //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                                            }
                    for (g_80.f0 = 0; (g_80.f0 <= 2); g_80.f0 += 1)
                    { /* block id: 318 */
                        uint16_t l_453 = 0x463B;
                        int i;
                        l_450[3] = l_450[0];
                        g_77[g_90] = func_32(((0x586F < (((((((safe_sub_func_int32_t_s_s((-3), (l_453 == ((safe_sub_func_uint32_t_u_u(g_77[2].f1, ((((safe_add_func_int8_t_s_s(((0xCB0F2803 | g_229.f3) & ((safe_sub_func_uint32_t_u_u(g_77[2].f2, (g_460 == (void*)0))) | (-5))), p_17)) != (-4)) >= 9) & p_15))) < 65535U)))) < g_77[2].f1) | p_18) && l_462) != p_14) && g_77[2].f0) | 8)) | p_16), g_229.f2, g_229.f3, l_453, (*l_420));
                        g_77[(l_266 + 1)] = g_77[g_80.f0];
                        (**l_371) = 0x85493222;
                    }
                }
                for (g_19 = 0; (g_19 <= 2); g_19 += 1)
                { /* block id: 327 */
                    struct S0 *** const *l_464 = &l_434;
                    struct S0 *** const **l_463 = &l_464;
                    int i;
                    (*l_463) = (void*)0;
                    /* statement id: 328 */
                    assert (l_464 == 0);
                    if (l_372[(g_19 + 1)])
                    { /* block id: 329 */
                        int32_t *****l_466[8][2][5] = {{{&l_465,(void*)0,&g_446,(void*)0,&g_446},{&g_446,&l_465,&l_465,&l_465,&l_465}},{{&l_465,&g_446,&g_446,(void*)0,&l_465},{(void*)0,&l_465,&g_446,&l_465,&g_446}},{{&g_446,&l_465,&g_446,(void*)0,(void*)0},{(void*)0,&g_446,(void*)0,&g_446,&l_465}},{{&l_465,&g_446,(void*)0,&g_446,&l_465},{&g_446,&l_465,(void*)0,&g_446,&l_465}},{{&l_465,&l_465,(void*)0,&l_465,&l_465},{&l_465,&g_446,(void*)0,&l_465,&g_446}},{{(void*)0,&l_465,&g_446,&g_446,&g_446},{(void*)0,(void*)0,&g_446,&g_446,&g_446}},{{&g_446,&g_446,&g_446,&g_446,&l_465},{&g_446,&g_446,&l_465,(void*)0,&l_465}},{{(void*)0,&g_446,&g_446,&l_465,&l_465},{(void*)0,&g_446,&g_446,(void*)0,&l_465}}};
                        int i, j, k;
                        l_465 = l_465;
                        (*g_460) = l_467;
                        /* statement id: 331 */
                        assert (g_461 == 0);
                    }
                    else
                    { /* block id: 332 */
                        int32_t *l_468 = &g_59;
                        int32_t **l_469 = &l_316[0][3][1];
                        int i;
                        (*l_469) = l_468;
                        (****l_369) = ((0U | l_372[(l_266 + 3)]) == (((~(1 & (0x95 >= ((safe_lshift_func_uint16_t_u_u((((p_14 <= (g_80.f1 > (l_465 == (void*)0))) | p_14) && 0x4D), 5)) >= p_14)))) | g_143) <= 2U));
                    }
                    l_442 = &p_16;
                    /* statement id: 336 */
                    assert (l_442 == &p_16);
                    for (l_414.f0 = 0; (l_414.f0 <= 3); l_414.f0 += 1)
                    { /* block id: 339 */
                        l_477 = (void*)0;
                        /* statement id: 340 */
                        assert (l_477 == 0);
                    }
                }
                for (l_300 = 0; (l_300 <= 0); l_300 += 1)
                { /* block id: 345 */
                    return (*l_292);
                    /* statement id: 346 */
                    //assert (g_58 == dangling);
                    //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                                    }
                for (l_414.f0 = 0; (l_414.f0 <= 2); l_414.f0 += 1)
                { /* block id: 350 */
                    int32_t **l_483 = &g_58;
                    l_481 = l_481;
                    g_58 = l_482;
                    /* statement id: 352 */
                    assert (g_58 == &g_59);
                    (*l_483) = &p_16;
                    /* statement id: 353 */
                    assert (g_58 == &p_16);
                    for (p_16 = 0; (p_16 <= 0); p_16 += 1)
                    { /* block id: 356 */
                        if (p_14)
                            break;
                        (*l_482) = ((void*)0 != &l_483);
                    }
                }
            }
            /* facts after for loop */
            //assert (l_438[0][0][0] == 0 || l_438[0][0][0] == &g_80 || l_438[0][0][0] == &l_414 || (l_438[0][0][0] >= &g_230[0][0] && l_438[0][0][0] <= &g_230[1][6]));
            assert (l_442 == &p_16 || l_442 == 0);
            assert ((g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
            assert (l_477 == 0 || (l_477 >= &l_478[0] && l_477 <= &l_478[7]));
        }
        /* facts after branching */
        assert (g_58 == &p_16 || g_58 == &g_59);
        assert (g_105 == &l_359 || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
        assert (g_445 == &g_446 || g_445 == 0);
        assert ((g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
        assert (l_477 == 0 || (l_477 >= &l_478[0] && l_477 <= &l_478[7]));
        for (l_266 = 8; (l_266 >= 3); l_266 -= 1)
        { /* block id: 365 */
            int32_t l_486[8][8] = {{0xD5225C5E,0xD5225C5E,0xD5225C5E,0x1738F0D1,3,0x1738F0D1,0xD5225C5E,(-1)},{(-1),0,0xDA1F4D01,0xD5225C5E,0xD5225C5E,0xDA1F4D01,0,(-1)},{0,0x6633D5E6,(-1),0x1738F0D1,(-1),0x6633D5E6,0,0},{0x6633D5E6,0x1738F0D1,0xDA1F4D01,0xDA1F4D01,0x1738F0D1,0x6633D5E6,0xD5225C5E,0x6633D5E6},{0x1738F0D1,0x6633D5E6,0xD5225C5E,0x6633D5E6,0x1738F0D1,0xDA1F4D01,0xDA1F4D01,0x1738F0D1},{0x6633D5E6,0,0,0x6633D5E6,(-1),0x1738F0D1,(-1),0x6633D5E6},{0,(-1),0,0xDA1F4D01,0xD5225C5E,0xD5225C5E,0xDA1F4D01,0},{(-1),(-1),0xD5225C5E,0x1738F0D1,3,0x1738F0D1,0xD5225C5E,(-1)}};
            int32_t *l_511[6][3] = {{&l_269,(void*)0,&g_59},{&g_59,(void*)0,(void*)0},{&l_486[7][7],(void*)0,&g_190},{&l_269,(void*)0,&g_59},{&g_59,(void*)0,(void*)0},{&l_486[7][7],(void*)0,&g_190}};
            uint16_t l_535 = 6U;
            int i, j;
            (***l_370) = ((g_229.f3 < ((((**l_371) < (((safe_mod_func_uint32_t_u_u((&l_433[l_266] != &l_433[7]), l_486[6][3])) == 0x93) != (((safe_add_func_uint32_t_u_u(p_18, (safe_rshift_func_uint8_t_u_s(((safe_lshift_func_int16_t_s_u(((&l_478[6] != &l_433[1]) > p_16), 9)) || g_77[2].f1), 0)))) >= g_229.f0) & g_229.f2))) > 0xFEF8A76C) & 0xFBDB7843)) != l_486[4][7]);
            if ((((void*)0 == &l_292) >= ((safe_lshift_func_uint16_t_u_u((((*g_446) == l_495) == ((safe_sub_func_uint16_t_u_u(g_5, (-1))) != (&l_433[l_266] != g_499))), ((((l_486[6][3] >= p_15) > 0x3870) != 0x9BCB) | g_77[2].f2))) > p_18)))
            { /* block id: 367 */
                uint8_t l_501 = 0x20;
                int32_t l_506 = 0xDEBB60FE;
                struct S0 l_507[5] = {{-1445,136,179,1462},{-1445,136,179,1462},{-1445,136,179,1462},{-1445,136,179,1462},{-1445,136,179,1462}};
                union U1 l_510 = {1U};
                int i;
                if ((safe_unary_minus_func_int32_t_s(l_501)))
                { /* block id: 368 */
                    struct S0 l_509 = {153,0,137,122};
                    for (l_501 = 0; (l_501 <= 1); l_501 += 1)
                    { /* block id: 371 */
                        const int32_t *l_504 = &l_486[6][3];
                        const int32_t **l_503 = &l_504;
                        (*l_503) = l_502;
                        /* statement id: 372 */
                        assert (l_504 == &l_269);
                    }
                    for (g_190 = 1; (g_190 >= 0); g_190 -= 1)
                    { /* block id: 376 */
                        int32_t *l_508 = &l_486[1][4];
                        l_506 = (+p_14);
                        l_507[1] = (*g_105);
                        l_508 = &p_16;
                        /* statement id: 379 */
                        assert (l_508 == &p_16);
                    }
                    l_509 = (*g_105);
                }
                else
                { /* block id: 382 */
                    if (p_15)
                        break;
                    return l_510;
                    /* statement id: 384 */
                    //assert (g_58 == dangling || g_58 == &g_59);
                    //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                                    }
                l_511[1][0] = &l_506;
                /* statement id: 386 */
                //assert (l_511[0][0] == &l_506 || l_511[0][0] == &g_59 || l_511[0][0] == 0 || l_511[0][0] == &l_269 || l_511[0][0] == &g_190 || (l_511[0][0] >= &l_486[0][0] && l_511[0][0] <= &l_486[7][7]));
                for (g_143 = 0; (g_143 <= 1); g_143 += 1)
                { /* block id: 389 */
                    int32_t *l_512 = &l_269;
                    (*g_460) = (*g_460);
                    for (p_15 = 0; (p_15 <= 1); p_15 += 1)
                    { /* block id: 393 */
                        l_512 = &l_486[6][3];
                        /* statement id: 394 */
                        assert ((l_512 >= &l_486[0][0] && l_512 <= &l_486[7][7]));
                    }
                    /* facts after for loop */
                    assert ((l_512 >= &l_486[0][0] && l_512 <= &l_486[7][7]) || l_512 == &l_269);
                    (*****l_368) = (safe_unary_minus_func_int16_t_s((&p_16 == l_514)));
                }
            }
            else
            { /* block id: 398 */
                const int32_t *l_517[2][5][4] = {{{(void*)0,(void*)0,&g_190,&l_486[2][2]},{(void*)0,&l_486[6][3],&l_486[6][3],(void*)0},{&g_59,&l_486[2][2],&g_59,&l_486[6][3]},{&g_190,&l_486[2][2],&g_190,(void*)0},{&l_486[2][2],&l_486[6][3],&l_486[6][3],&l_486[2][2]}},{{&g_59,(void*)0,&l_486[6][3],&l_486[6][3]},{&l_486[2][2],&g_190,&g_190,&g_190},{&g_190,&l_486[6][3],&g_59,&g_190},{&g_59,&g_190,&l_486[6][3],&l_486[6][3]},{(void*)0,(void*)0,&g_190,&l_486[2][2]}}};
                int i, j, k;
                (*****l_368) = (((safe_rshift_func_uint8_t_u_u(p_17, 1)) ^ 0x5F45458B) | (****l_369));
                for (l_414.f0 = 0; (l_414.f0 <= 1); l_414.f0 += 1)
                { /* block id: 402 */
                    uint8_t l_540 = 246U;
                    for (l_300 = 1; (l_300 >= 0); l_300 -= 1)
                    { /* block id: 405 */
                        const int32_t **l_518 = &l_517[0][2][0];
                        int32_t **l_519 = (void*)0;
                        int32_t **l_520 = (void*)0;
                        int32_t **l_521 = &l_316[0][3][1];
                        int32_t l_534 = 0x7F447214;
                        struct S0 l_541 = {1711,32,209,1190};
                        (*l_518) = l_517[1][1][0];
                    }
                }
            }
            /* facts after branching */
            //assert (l_511[0][0] == dangling || l_511[0][0] == &g_59 || l_511[0][0] == 0 || l_511[0][0] == &l_269 || l_511[0][0] == &g_190 || (l_511[0][0] >= &l_486[0][0] && l_511[0][0] <= &l_486[7][7]));
            for (p_16 = 0; (p_16 <= 1); p_16 += 1)
            { /* block id: 414 */
                int16_t l_544 = 0x1428;
                struct S0 ***l_558 = &l_435;
                for (p_18 = 0; (p_18 <= 1); p_18 += 1)
                { /* block id: 417 */
                    const union U1 **l_542 = (void*)0;
                    if (((l_542 == (void*)0) || g_143))
                    { /* block id: 418 */
                        (*l_420) = (~g_229.f0);
                        if (l_544)
                            continue;
                    }
                    else
                    { /* block id: 421 */
                        g_77[2] = func_29((*l_514));
                        /* statement id: 422 */
                        //assert (g_58 == &p_16 || g_58 == &g_59 || g_58 == dangling);
                        //assert (g_105 == dangling || g_105 == &l_359 || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                        return g_230[0][6];
                        /* statement id: 423 */
                        //assert (g_58 == &g_59 || g_58 == dangling);
                        //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                                            }
                    if ((****l_369))
                        continue;
                }
                (*l_420) = (((((*l_502) < (safe_sub_func_uint16_t_u_u(((safe_mod_func_int8_t_s_s(p_14, ((((((g_19 && (safe_lshift_func_int16_t_s_u((((p_17 && ((safe_mod_func_int32_t_s_s(l_544, ((safe_add_func_uint16_t_u_u((g_555 != l_558), (safe_rshift_func_int8_t_s_u((safe_mod_func_uint16_t_u_u(((*l_558) == (void*)0), 0x7635)), g_229.f2)))) & (*l_502)))) || g_80.f0)) >= p_18) < p_18), 12))) & p_18) ^ p_16) >= l_544) < 9U) && p_16))) && l_544), g_229.f3))) ^ 7U) && 0x6F) <= 0x00);
                for (l_269 = 0; (l_269 <= 7); l_269 += 1)
                { /* block id: 430 */
                    int i, j;
                    g_77[(p_16 + 1)] = g_77[(p_16 + 1)];
                    for (l_414.f0 = 0; (l_414.f0 <= 2); l_414.f0 += 1)
                    { /* block id: 434 */
                        int i, j;
                        l_511[(l_414.f0 + 1)][l_414.f0] = &p_16;
                        if ((*l_502))
                            break;
                    }
                    l_511[1][0] = &p_16;
                    l_486[(p_16 + 6)][(p_16 + 3)] = (0x06D4E712 >= (+0x73));
                }
                for (l_535 = 0; (l_535 <= 1); l_535 += 1)
                { /* block id: 443 */
                    union U1 l_564 = {1U};
                    return l_564;
                    /* statement id: 444 */
                    //assert (g_58 == dangling || g_58 == &g_59);
                    //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
                                    }
            }
            /* facts after for loop */
            //assert (l_511[0][0] == &p_16 || l_511[0][0] == dangling || l_511[0][0] == &g_59 || l_511[0][0] == 0 || l_511[0][0] == &l_269 || l_511[0][0] == &g_190 || (l_511[0][0] >= &l_486[0][0] && l_511[0][0] <= &l_486[7][7]));
        }
    }
    /* facts after branching */
    assert (g_58 == &p_16 || g_58 == &g_59);
    assert (g_105 == &l_359 || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
    assert (g_445 == &g_446 || g_445 == 0);
    assert ((g_461 >= &g_230[0][0] && g_461 <= &g_230[1][6]) || g_461 == 0);
    assert (l_477 == 0 || (l_477 >= &l_478[0] && l_477 <= &l_478[7]));
    return (*l_292);
    /* statement id: 449 */
    //assert (g_58 == dangling || g_58 == &g_59);
    //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]));
    }


/* ------------------------------------------ */
/* 
 * reads : g_90 g_77.f0 g_237 g_229.f1
 * writes: g_90
 */
inline static struct S0  func_25(struct S0  p_26, struct S0  p_27, union U1  p_28)
{ /* block id: 155 */
    int32_t **l_241 = &g_58;
    int32_t ***l_240 = &l_241;
    struct S0 l_242[7] = {{-118,161,126,1273},{-118,161,126,1273},{-118,161,126,1273},{-118,161,126,1273},{-118,161,126,1273},{-118,161,126,1273},{-118,161,126,1273}};
    int i;
    for (g_90 = 0; (g_90 < 24); g_90 = safe_add_func_uint16_t_u_u(g_90, 5))
    { /* block id: 158 */
        p_26.f0 = (((safe_sub_func_uint32_t_u_u(g_77[2].f0, (((((void*)0 != g_237) > (safe_add_func_int32_t_s_s(((l_240 != g_237) | g_229.f1), g_229.f1))) ^ p_28.f1) | (g_229.f1 != p_26.f2)))) == 1) & 0x6FB7C800);
    }
    return l_242[0];
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_19 g_59 g_77 g_90 g_80.f0 g_80.f1 g_105 g_143 g_190
 * writes: g_58 g_59 g_77 g_105 g_80.f0 g_19 g_90 g_143 g_190
 */
inline static struct S0  func_29(int16_t  p_30)
{ /* block id: 9 */
    const struct S0 l_43 = {-1682,185,332,196};
    struct S0 *l_228 = &g_77[2];
    (*l_228) = func_32(((((p_30 > func_38(l_43, p_30, ((p_30 <= (safe_sub_func_uint8_t_u_u(0U, 0))) & ((((l_43.f2 || ((safe_add_func_int16_t_s_s(func_50(g_5, (g_19 | 4U), g_5, g_19, g_19), l_43.f0)) ^ l_43.f0)) | g_59) & l_43.f3) == g_59)), p_30)) != p_30) & l_43.f3) ^ g_5), l_43.f3, l_43.f0, g_5, p_30);
    /* statement id: 153 */
    //assert (g_58 == &g_59 || g_58 == dangling || g_58 == &p_16);
    //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == &l_359);
    return (*l_228);
}


/* ------------------------------------------ */
/* 
 * reads : g_90 g_77.f3 g_143 g_190 g_77.f1 g_77
 * writes: g_190
 */
inline static struct S0  func_32(uint32_t  p_33, int8_t  p_34, int32_t  p_35, const uint16_t  p_36, int8_t  p_37)
{ /* block id: 150 */
    struct S0 *l_211[8][7] = {{&g_77[2],(void*)0,&g_77[1],(void*)0,(void*)0,&g_77[1],(void*)0},{&g_77[2],&g_77[2],(void*)0,&g_77[2],&g_77[2],&g_77[2],(void*)0},{(void*)0,(void*)0,&g_77[1],(void*)0,&g_77[2],&g_77[2],(void*)0},{&g_77[2],(void*)0,&g_77[2],&g_77[2],&g_77[2],(void*)0,&g_77[2]},{(void*)0,(void*)0,(void*)0,(void*)0,&g_77[2],&g_77[1],&g_77[1]},{&g_77[2],(void*)0,(void*)0,(void*)0,&g_77[2],(void*)0,(void*)0},{&g_77[2],(void*)0,(void*)0,(void*)0,(void*)0,&g_77[2],&g_77[1]},{&g_77[2],&g_77[2],&g_77[2],(void*)0,&g_77[2],&g_77[2],&g_77[2]}};
    int32_t l_223 = 0xB20A8510;
    int32_t l_226 = 0;
    int32_t *l_227 = &g_190;
    int i, j;
    (*l_227) = (safe_add_func_int8_t_s_s(((((9U ^ (l_211[6][0] == &g_77[2])) == ((safe_rshift_func_int16_t_s_s(((safe_lshift_func_uint8_t_u_u(((!((safe_mod_func_uint8_t_u_u((safe_add_func_int16_t_s_s((safe_lshift_func_int16_t_s_u((p_34 & ((-6) < (l_223 != (g_90 == ((((safe_mod_func_uint32_t_u_u((g_77[2].f3 | ((((g_143 || g_143) != p_34) != l_226) >= g_190)), p_37)) ^ l_226) <= g_190) & p_37))))), l_226)), g_77[2].f1)), p_35)) != l_226)) | p_37), g_190)) > l_223), 4)) ^ l_226)) < l_226) ^ 0x456B), g_77[2].f1));
    return g_77[2];
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_59 g_77 g_90 g_19 g_80.f0 g_80.f1 g_105 g_143 g_190 l_359
 * writes: g_59 g_77 g_105 g_80.f0 g_19 g_90 g_143 g_190
 */
static uint8_t  func_38(const struct S0  p_39, int8_t  p_40, int8_t  p_41, int8_t  p_42)
{ /* block id: 14 */
    uint32_t l_61[2];
    int32_t *l_74 = (void*)0;
    int32_t l_168 = 0x61776ED3;
    uint8_t l_208 = 0x6F;
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_61[i] = 4294967289U;
lbl_186:
    for (p_42 = 0; (p_42 <= 1); p_42 += 1)
    { /* block id: 17 */
        int32_t l_62 = 0x07B88C8E;
        union U1 *l_79 = &g_80;
        uint16_t l_96 = 0x5F4D;
        struct S0 l_106 = {365,235,54,568};
        int i;
        l_62 = l_61[p_42];
        if (g_5)
            continue;
        if (((2 > (g_59 & ((g_5 <= (safe_mod_func_int32_t_s_s(((safe_rshift_func_int8_t_s_u((!g_5), 6)) & (safe_lshift_func_uint16_t_u_u((safe_lshift_func_int8_t_s_u(((&g_59 != &l_62) <= (247U >= (-1))), (safe_sub_func_uint32_t_u_u(g_5, 0x9FBD0585)))), 8))), l_61[0]))) == p_41))) < g_59))
        { /* block id: 20 */
            int32_t *l_82[2][4][10] = {{{&l_62,(void*)0,&l_62,&l_62,&l_62,&l_62,&g_59,&g_59,&g_59,&l_62},{(void*)0,(void*)0,&l_62,(void*)0,(void*)0,&l_62,&l_62,(void*)0,(void*)0,&l_62},{&g_59,&g_59,&l_62,(void*)0,&g_59,(void*)0,&l_62,&g_59,&g_59,&l_62},{(void*)0,(void*)0,&l_62,&l_62,(void*)0,(void*)0,&l_62,(void*)0,(void*)0,&l_62}},{{&g_59,&g_59,&g_59,&l_62,&l_62,&l_62,&l_62,&g_59,&g_59,&g_59},{&g_59,(void*)0,&g_59,(void*)0,&g_59,(void*)0,&g_59,&g_59,(void*)0,&g_59},{(void*)0,&g_59,&g_59,(void*)0,&g_59,(void*)0,&g_59,(void*)0,&g_59,&g_59},{&g_59,&g_59,&l_62,&l_62,&l_62,&l_62,&g_59,&g_59,&g_59,&l_62}}};
            int16_t l_85 = (-5);
            struct S0 l_158[8] = {{2404,157,37,1723},{2404,157,37,1723},{2404,157,37,1723},{2404,157,37,1723},{2404,157,37,1723},{2404,157,37,1723},{2404,157,37,1723},{2404,157,37,1723}};
            int i, j, k;
            if (((void*)0 == l_74))
            { /* block id: 21 */
                int32_t l_86 = (-6);
                if (g_59)
                { /* block id: 22 */
                    if (p_42)
                        break;
                    if (p_39.f0)
                        continue;
                    if (p_39.f3)
                        break;
                    for (p_41 = 0; (p_41 <= 1); p_41 += 1)
                    { /* block id: 28 */
                        int32_t **l_75 = (void*)0;
                        int32_t **l_76 = &l_74;
                        struct S0 *l_78 = &g_77[2];
                        union U1 *l_81 = (void*)0;
                        (*l_76) = &g_59;
                        /* statement id: 29 */
                        assert (l_74 == &g_59);
                        (*l_74) = (&g_59 == &g_59);
                        (*l_78) = g_77[2];
                        l_81 = l_79;
                        /* statement id: 32 */
                        assert (l_81 == &g_80);
                    }
                }
                else
                { /* block id: 34 */
                    for (g_59 = 1; (g_59 >= 0); g_59 -= 1)
                    { /* block id: 37 */
                        int32_t **l_87 = &l_82[1][2][4];
                        int i;
                        l_82[1][3][4] = l_74;
                        l_86 = (((((0U || l_61[g_59]) ^ (&g_59 == (void*)0)) > ((void*)0 != &g_77[p_42])) != ((&g_77[p_42] == (void*)0) < (((safe_lshift_func_uint16_t_u_u(p_39.f3, p_39.f1)) >= g_5) | l_85))) > g_77[p_42].f0);
                        (*l_87) = &l_62;
                    }
                }
            }
            else
            { /* block id: 43 */
                int32_t *l_88 = (void*)0;
                int32_t **l_89 = &l_88;
                struct S0 *l_104 = &g_77[2];
                uint16_t l_165 = 0x2DEC;
                (*l_89) = l_88;
                if (g_90)
                { /* block id: 45 */
                    int32_t l_99 = 3;
                    int32_t l_100 = 4;
                    l_100 = ((((safe_mod_func_uint8_t_u_u((0x64 < (((g_77[2].f1 != (((void*)0 != &g_80) != (0xC79EC616 & (!((0U | (g_90 != (l_96 || ((safe_mod_func_uint16_t_u_u(l_96, 0x7D50)) == (-1))))) | 3))))) || g_77[2].f1) >= g_90)), g_77[2].f1)) > g_19) <= p_39.f0) < l_99);
                }
                else
                { /* block id: 47 */
                    struct S0 *l_125 = &g_77[2];
                    int32_t l_126 = 0;
                    if ((255U && (~((safe_add_func_int8_t_s_s(((p_40 | ((void*)0 == l_104)) || ((248U & (((g_77[2].f0 | g_80.f0) || (l_96 != 0x4F023CA6)) >= p_39.f1)) <= p_39.f1)), g_19)) == 249U))))
                    { /* block id: 48 */
                        g_105 = &p_39;
                        /* statement id: 49 */
                        assert (g_105 == &p_39);
                        if (p_40)
                            continue;
                        l_106 = p_39;
                    }
                    else
                    { /* block id: 52 */
                        if (p_42)
                            break;
                    }
                    if (((((safe_lshift_func_uint16_t_u_s(((safe_sub_func_int16_t_s_s(((1 | (safe_sub_func_uint8_t_u_u(g_80.f0, (((void*)0 != &g_77[1]) <= 0U)))) < 0xAA53), p_39.f0)) & ((g_77[2].f0 != (((safe_sub_func_uint32_t_u_u(((safe_lshift_func_int16_t_s_u((safe_lshift_func_int16_t_s_s(((&g_58 != (void*)0) != 0xEA), g_90)), g_77[2].f3)) < p_40), (-1))) | l_106.f2) || p_39.f2)) && p_39.f3)), g_77[2].f1)) & 0x20) && 0x90) & p_41))
                    { /* block id: 55 */
                        union U1 * const l_129 = (void*)0;
                        l_106.f0 = (((void*)0 != &p_39) & (p_39.f1 || ((safe_mod_func_uint16_t_u_u(((*l_89) == (void*)0), 0xE6F6)) == ((safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u((&g_77[2] == l_125), 10)), 3)) < l_126))));
                        l_126 = (0x4FA4222F > ((safe_mod_func_uint16_t_u_u(((void*)0 != l_129), g_90)) > (((((void*)0 == &g_77[0]) || ((safe_unary_minus_func_uint16_t_u((safe_rshift_func_int8_t_s_u(((safe_sub_func_int8_t_s_s((safe_rshift_func_int16_t_s_u(((!(safe_lshift_func_uint16_t_u_u(((g_77[2].f0 > g_77[2].f0) | (p_42 | 0xB0)), 14))) >= 1), 15)), g_5)) != p_41), g_80.f1)))) || g_90)) == p_40) <= 255U)));
                        (*l_104) = (*g_105);
                    }
                    else
                    { /* block id: 59 */
                        (*l_89) = &l_126;
                        /* statement id: 60 */
                        assert (l_88 == &l_126);
                        return g_90;
                        /* statement id: 61 */
                        //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == &l_359);
                    }
                }
                if ((~(safe_lshift_func_int16_t_s_s(g_143, ((((safe_unary_minus_func_int16_t_s((((safe_rshift_func_uint16_t_u_s(g_5, (!p_40))) <= (((safe_sub_func_int8_t_s_s((safe_sub_func_uint8_t_u_u((p_40 && ((safe_rshift_func_int8_t_s_s((safe_lshift_func_int16_t_s_s((safe_mod_func_int32_t_s_s(0x3EA23270, (((((p_39.f1 & (g_19 <= (0U & g_143))) != g_5) ^ g_90) | p_42) | 0xD8F8))), g_77[2].f1)), p_42)) >= g_77[2].f2)), g_77[2].f2)), 0)) <= 6) && 4294967295U)) < 0xBA))) >= p_39.f2) <= 255U) >= 0xAD)))))
                { /* block id: 64 */
                    uint16_t l_176[6][6][4] = {{{0x9D23,0x8763,2U,0x89C8},{0x0890,0x1C39,65529U,0x1C39},{0x1C39,2U,0x9D23,0x1C39},{0x9D23,0x1C39,0x89C8,0x89C8},{0x8763,0x8763,65529U,0x0890},{0x8763,2U,0x89C8,0x8763}},{{0x9D23,0x0890,0x9D23,0x89C8},{0x1C39,0x0890,65529U,0x8763},{0x0890,2U,2U,0x0890},{0x9D23,0x8763,2U,0x89C8},{0x0890,0x1C39,65529U,0x1C39},{0x1C39,2U,0x9D23,0x1C39}},{{0x9D23,0x1C39,0x89C8,0x89C8},{0x8763,0x8763,65529U,0x0890},{0x8763,2U,0x89C8,0x8763},{0x9D23,0x0890,0x9D23,0x89C8},{0x1C39,0x0890,65529U,0x8763},{0x0890,2U,2U,0x0890}},{{0x9D23,0x8763,2U,0x89C8},{0x0890,0x1C39,65529U,0x1C39},{0x1C39,2U,0x9D23,0x1C39},{0x9D23,0x1C39,0x89C8,0x89C8},{0x8763,0x8763,65529U,0x0890},{0x8763,2U,0x89C8,0x8763}},{{0x9D23,0x0890,0x9D23,0x89C8},{0x1C39,0x0890,65529U,0x8763},{0x0890,65529U,65529U,2U},{0xE54D,0x9D23,65529U,0x4987},{2U,0x89C8,0x8763,0x89C8},{0x89C8,65529U,0xE54D,0x89C8}},{{0xE54D,0x89C8,0x4987,0x4987},{0x9D23,0x9D23,0x8763,2U},{0x9D23,65529U,0x4987,0x9D23},{0xE54D,2U,0xE54D,0x4987},{0x89C8,2U,0x8763,0x9D23},{2U,65529U,65529U,2U}}};
                    int i, j, k;
                    if (p_39.f2)
                    { /* block id: 65 */
                        (*l_89) = &l_62;
                        /* statement id: 66 */
                        assert (l_88 == &l_62);
                        l_74 = &g_59;
                        /* statement id: 67 */
                        assert (l_74 == &g_59);
                        (*l_89) = &l_62;
                        (*l_89) = (*l_89);
                    }
                    else
                    { /* block id: 70 */
                        union U1 *l_175 = &g_80;
                        g_77[2] = l_158[1];
                        g_77[0] = l_106;
                        l_168 = ((safe_add_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_u(0xBC84, 0)), (g_77[2].f0 & (g_90 <= (safe_add_func_uint8_t_u_u((((0xE4 | (-1)) | l_165) < g_143), (safe_lshift_func_uint16_t_u_s(65535U, (0x9CC6 < 3))))))))) == p_39.f0);
                        l_176[2][5][1] = (((safe_lshift_func_int16_t_s_s(p_40, (&l_88 != (void*)0))) || 1) | (((safe_rshift_func_int8_t_s_u((l_96 < 0xE6A80779), l_106.f2)) != ((l_175 != (void*)0) | g_90)) <= p_39.f3));
                    }
                    /* facts after branching */
                    assert (l_88 == 0 || l_88 == &l_62);
                    for (l_96 = 0; (l_96 <= 1); l_96 += 1)
                    { /* block id: 78 */
                        int32_t l_179[10][4][6] = {{{0x3F6EE530,1,0xF27FFFBB,0x0097F2B5,0x30C1190E,0x466ADE75},{0x3F6EE530,(-1),(-8),0x466ADE75,(-1),8},{0x3F6EE530,(-4),0x466ADE75,0x0097F2B5,0,(-8)},{0x3F6EE530,0x30C1190E,0xF27FFFBB,0x466ADE75,0x30C1190E,0x0097F2B5}},{{0x3F6EE530,(-1),(-8),0x0097F2B5,(-1),0xF27FFFBB},{0x3F6EE530,0,0x466ADE75,0x466ADE75,0,0x3F6EE530},{0x3F6EE530,1,0xF27FFFBB,0x0097F2B5,0x30C1190E,0x466ADE75},{0x3F6EE530,(-1),(-8),0x466ADE75,(-1),8}},{{0x3F6EE530,(-4),0x466ADE75,0x0097F2B5,0,(-8)},{0x3F6EE530,0x30C1190E,0xF27FFFBB,0x466ADE75,0x30C1190E,0x0097F2B5},{0x3F6EE530,(-1),(-8),0x0097F2B5,(-1),0xF27FFFBB},{0x3F6EE530,0,0x466ADE75,0x466ADE75,0,0x3F6EE530}},{{0x3F6EE530,1,0xF27FFFBB,0x0097F2B5,0x30C1190E,0x466ADE75},{0x3F6EE530,(-1),(-8),0x466ADE75,(-1),8},{0x3F6EE530,(-4),0x466ADE75,0x0097F2B5,0,(-8)},{0x3F6EE530,0x30C1190E,0xF27FFFBB,0x466ADE75,0x30C1190E,0x0097F2B5}},{{0x3F6EE530,(-1),(-8),0x0097F2B5,(-1),0xF27FFFBB},{0x3F6EE530,0,0x466ADE75,0x466ADE75,0,0x3F6EE530},{0x3F6EE530,1,0xF27FFFBB,0x0097F2B5,0x30C1190E,0x466ADE75},{0x3F6EE530,(-1),(-8),0x466ADE75,(-1),8}},{{0x3F6EE530,(-4),0x466ADE75,0x0097F2B5,0,(-8)},{0x3F6EE530,0x30C1190E,0xF27FFFBB,0x466ADE75,0x30C1190E,0x0097F2B5},{0x3F6EE530,(-1),(-8),0x0097F2B5,(-1),0xF27FFFBB},{0x3F6EE530,0,0x466ADE75,0x466ADE75,0,0x3F6EE530}},{{0x3F6EE530,1,0xF27FFFBB,0x0097F2B5,0x30C1190E,0x466ADE75},{0x3F6EE530,(-1),0x50FF4D6F,1,8,4},{(-9),0x466ADE75,1,(-3),0x0097F2B5,0x50FF4D6F},{(-9),0x3F6EE530,(-1),1,0x3F6EE530,(-3)}},{{(-9),0xF27FFFBB,0x50FF4D6F,(-3),8,(-1)},{(-9),0x0097F2B5,1,1,0x0097F2B5,(-9)},{(-9),(-8),(-1),(-3),0x3F6EE530,1},{(-9),8,0x50FF4D6F,1,8,4}},{{(-9),0x466ADE75,1,(-3),0x0097F2B5,0x50FF4D6F},{(-9),0x3F6EE530,(-1),1,0x3F6EE530,(-3)},{(-9),0xF27FFFBB,0x50FF4D6F,(-3),8,(-1)},{(-9),0x0097F2B5,1,1,0x0097F2B5,(-9)}},{{(-9),(-8),(-1),(-3),0x3F6EE530,1},{(-9),8,0x50FF4D6F,1,8,4},{(-9),0x466ADE75,1,(-3),0x0097F2B5,0x50FF4D6F},{(-9),0x3F6EE530,(-1),1,0x3F6EE530,(-3)}}};
                        int i, j, k;
                        l_106.f0 = (((safe_rshift_func_int16_t_s_u(p_39.f3, g_77[2].f1)) && (g_90 < p_39.f2)) | l_179[7][2][2]);
                        (*l_89) = &g_59;
                        /* statement id: 80 */
                        assert (l_88 == &g_59);
                    }
                    /* facts after for loop */
                    assert (l_88 == &g_59 || l_88 == 0 || l_88 == &l_62);
                }
                else
                { /* block id: 82 */
                    if (g_80.f1)
                        break;
                    (*l_104) = (*g_105);
                }
                /* facts after branching */
                assert (l_88 == &g_59 || l_88 == 0 || l_88 == &l_62);
            }
            return g_77[2].f2;
            /* statement id: 87 */
            //assert ((g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == dangling || g_105 == &l_359);
        }
        else
        { /* block id: 88 */
            int8_t l_184 = 0;
            uint8_t l_185[3];
            int i;
            for (i = 0; i < 3; i = i + 1)
                l_185[i] = 0x20;
            if ((((((((safe_mod_func_int8_t_s_s((((g_80.f1 != (0x7A3B2D89 & (5 >= 0x8CE4A9CA))) == 0) && (((safe_add_func_int16_t_s_s(0, p_39.f3)) <= (((&g_77[2] == &p_39) == 0x02) != 0xD5A0D50F)) | (-1))), 0x37)) && 4) || l_184) || l_185[2]) != g_77[2].f0) | g_5) | g_59))
            { /* block id: 89 */
                if (p_39.f3)
                    break;
            }
            else
            { /* block id: 91 */
                return g_77[2].f1;
                /* statement id: 92 */
                //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == &l_359);
            }
            if (p_41)
                goto lbl_186;
        }
    }
    for (p_40 = 0; (p_40 <= 1); p_40 += 1)
    { /* block id: 99 */
        int32_t **l_188[6][3] = {{&l_74,&l_74,&l_74},{&l_74,&l_74,&l_74},{&l_74,&l_74,&l_74},{&l_74,&l_74,&l_74},{&l_74,&l_74,&l_74},{&l_74,&l_74,&l_74}};
        int32_t ***l_187 = &l_188[0][2];
        union U1 *l_193[4] = {&g_80,&g_80,&g_80,&g_80};
        int32_t l_202 = 0x23BB9FAC;
        int i, j;
        (*l_187) = &l_74;
        for (g_80.f0 = 0; (g_80.f0 <= 1); g_80.f0 += 1)
        { /* block id: 103 */
            int i;
            return l_61[g_80.f0];
            /* statement id: 104 */
            //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == &l_359);
        }
        for (g_19 = 0; (g_19 <= 2); g_19 += 1)
        { /* block id: 108 */
            uint16_t l_204 = 0U;
            const int32_t *l_207 = &g_190;
            const int32_t * const *l_206 = &l_207;
            const int32_t * const * const * const l_205 = &l_206;
            int i;
            for (g_90 = 0; (g_90 <= 1); g_90 += 1)
            { /* block id: 111 */
                int32_t l_203 = 0xCF209D36;
                (**l_187) = &g_59;
                /* statement id: 112 */
                assert (l_74 == &g_59);
                for (g_143 = 0; (g_143 <= 2); g_143 += 1)
                { /* block id: 115 */
                    int32_t *l_191 = (void*)0;
                    uint16_t l_200 = 4U;
                    for (p_42 = 0; (p_42 <= 1); p_42 += 1)
                    { /* block id: 118 */
                        int32_t *l_189 = (void*)0;
                        int32_t *l_192[4];
                        int i;
                        for (i = 0; i < 4; i = i + 1)
                            l_192[i] = &g_59;
                        (**l_187) = l_189;
                        /* statement id: 119 */
                        assert (l_74 == 0);
                        if (g_190)
                            break;
                        if (p_39.f1)
                            goto lbl_186;
                        l_192[1] = l_191;
                        /* statement id: 122 */
                        //assert (l_192[0] == 0 || l_192[0] == &g_59);
                    }
                    for (g_190 = 0; (g_190 <= 2); g_190 += 1)
                    { /* block id: 126 */
                        (**l_187) = &g_59;
                        /* statement id: 127 */
                        assert (l_74 == &g_59);
                        if (g_59)
                            goto lbl_186;
                    }
                    if (((void*)0 != l_193[1]))
                    { /* block id: 130 */
                        int8_t l_197 = 0x6C;
                        int32_t l_201 = 1;
                        int i, j;
                        if (p_39.f0)
                            goto lbl_186;
                        l_201 = ((safe_unary_minus_func_int8_t_s(((safe_add_func_uint16_t_u_u(((g_190 > l_197) != (((&g_59 == &g_59) | 0) | (!1U))), (((p_39.f0 | (((((~(-1)) <= p_39.f1) > g_19) | 0x1F) | l_200)) > (-7)) || p_42))) <= 0xF107A54B))) >= p_39.f1);
                        (**l_187) = (void*)0;
                        /* statement id: 133 */
                        assert (l_74 == 0);
                    }
                    else
                    { /* block id: 134 */
                        return l_202;
                        /* statement id: 135 */
                        //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == &l_359);
                    }
                    /* facts after branching */
                    assert (l_74 == 0);
                    for (l_168 = 0; (l_168 <= 1); l_168 += 1)
                    { /* block id: 139 */
                        int i;
                        l_203 = (&g_77[g_143] != (void*)0);
                    }
                }
                /* facts after for loop */
                assert (l_74 == 0 || l_74 == &g_59);
            }
            g_190 = (l_204 || ((void*)0 == l_205));
            g_77[(p_40 + 1)] = g_77[g_19];
            g_59 = ((&g_58 == &l_74) <= (0x5C != (&p_39 != &g_77[2])));
        }
    }
    return l_208;
    /* statement id: 149 */
    //assert (g_105 == dangling || (g_105 >= &g_77[0] && g_105 <= &g_77[2]) || g_105 == &l_359);
}


/* ------------------------------------------ */
/* 
 * reads : g_59
 * writes: g_58
 */
inline static int16_t  func_50(uint16_t  p_51, int32_t  p_52, uint16_t  p_53, int32_t  p_54, int32_t  p_55)
{ /* block id: 10 */
    int32_t *l_57 = (void*)0;
    int32_t **l_56[5];
    int32_t *l_60 = &g_59;
    int i;
    for (i = 0; i < 5; i = i + 1)
        l_56[i] = &l_57;
    g_58 = &p_55;
    /* statement id: 11 */
    assert (g_58 == &p_55);
    l_60 = &g_59;
    return g_59;
    /* statement id: 13 */
    //assert (g_58 == dangling);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_19, "g_19", print_hash_value);
    transparent_crc(g_59, "g_59", print_hash_value);
    for (i = 0; i < 3; i = i + 1)
    {
        transparent_crc(g_77[i].f0, "g_77[i].f0", print_hash_value);
        transparent_crc(g_77[i].f1, "g_77[i].f1", print_hash_value);
        transparent_crc(g_77[i].f2, "g_77[i].f2", print_hash_value);
        transparent_crc(g_77[i].f3, "g_77[i].f3", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_80.f0, "g_80.f0", print_hash_value);
    transparent_crc(g_80.f1, "g_80.f1", print_hash_value);
    transparent_crc(g_90, "g_90", print_hash_value);
    transparent_crc(g_143, "g_143", print_hash_value);
    transparent_crc(g_190, "g_190", print_hash_value);
    transparent_crc(g_229.f0, "g_229.f0", print_hash_value);
    transparent_crc(g_229.f1, "g_229.f1", print_hash_value);
    transparent_crc(g_229.f2, "g_229.f2", print_hash_value);
    transparent_crc(g_229.f3, "g_229.f3", print_hash_value);
    for (i = 0; i < 2; i = i + 1)
    {
        for (j = 0; j < 7; j = j + 1)
        {
            transparent_crc(g_230[i][j].f0, "g_230[i][j].f0", print_hash_value);
            transparent_crc(g_230[i][j].f1, "g_230[i][j].f1", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 6; i = i + 1)
    {
        for (j = 0; j < 5; j = j + 1)
        {
            for (k = 0; k < 5; k = k + 1)
            {
                transparent_crc(g_574[i][j][k], "g_574[i][j][k]", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 211
   depth: 1, occurrence: 30
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 83
breakdown:
   indirect level: 0, occurrence: 38
   indirect level: 1, occurrence: 17
   indirect level: 2, occurrence: 12
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 6
XXX full-bitfields structs in the program: 30
breakdown:
   indirect level: 0, occurrence: 30
XXX times a bitfields struct's address is taken: 56
XXX times a bitfields struct on LHS: 20
XXX times a bitfields struct on RHS: 63
XXX times a single bitfield on LHS: 5
XXX times a single bitfield on RHS: 136

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 367
   depth: 2, occurrence: 79
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 11, occurrence: 5
   depth: 12, occurrence: 5
   depth: 13, occurrence: 4
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 6
   depth: 19, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 28, occurrence: 3
   depth: 29, occurrence: 2

XXX total number of pointers: 184

XXX times a variable address is taken: 545
XXX times a pointer is dereferenced on RHS: 57
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 1
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 92
breakdown:
   depth: 1, occurrence: 71
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 49
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 22
XXX times a pointer is qualified to be dereferenced: 1157

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 329
   level: 2, occurrence: 90
   level: 3, occurrence: 95
   level: 4, occurrence: 68
   level: 5, occurrence: 18
XXX number of pointers point to pointers: 109
XXX number of pointers point to scalars: 50
XXX number of pointers point to structs: 13
XXX percent of pointers has null in alias set: 35.9
XXX average alias set size: 1.45

XXX times a non-volatile is read: 909
XXX times a non-volatile is write: 380
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 9

XXX stmts: 337
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 23
   depth: 1, occurrence: 25
   depth: 2, occurrence: 36
   depth: 3, occurrence: 45
   depth: 4, occurrence: 83
   depth: 5, occurrence: 125

XXX percentage a fresh-made variable is used: 19.1
XXX percentage an existing variable is used: 80.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

