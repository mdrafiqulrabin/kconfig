/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      1856633828
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 8;
   uint32_t  f1;
   uint16_t  f2;
   signed f3 : 4;
   signed f4 : 11;
   unsigned : 0;
   unsigned f5 : 22;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = (-1);
static int32_t g_8 = 0x40194DDB;
static struct S0 g_56 = {1,0x4ACA62E2,0xA8AC,1,-40,230};
static int16_t g_296 = (-1);
static int32_t g_375 = 9;
static struct S0 g_614 = {4,4294967294U,0x6FF0,-0,-44,109};


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_25(void);
static int32_t  func_26(uint32_t  p_27, uint16_t  p_28, uint32_t  p_29, int16_t  p_30);
static uint16_t  func_32(int32_t  p_33, int32_t  p_34, uint32_t  p_35, int32_t  p_36);
static int16_t  func_39(int16_t  p_40);
static int16_t  func_46(uint32_t  p_47, uint32_t  p_48, int32_t  p_49);
static uint16_t  func_52(int32_t  p_53, uint32_t  p_54, struct S0  p_55);
static uint32_t  func_62(uint16_t  p_63);
static uint32_t  func_65(uint32_t  p_66);
static uint16_t  func_70(uint32_t  p_71, uint16_t  p_72, int32_t  p_73);
static int16_t  func_74(uint32_t  p_75, int32_t  p_76);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_56 g_8 g_296 g_375 g_614
 * writes: g_56.f4 g_56.f3 g_8 g_56 g_296 g_375 g_614
 */
static struct S0  func_25(void)
{ /* block id: 36 */
    uint16_t l_31 = 0x6C19;
    int32_t l_574 = 0x8CBE8B22;
    struct S0 l_576 = {6,4294967295U,65533U,0,30,601};
    uint32_t l_617 = 0U;
    l_574 = func_26((((__builtin_popcountll(g_3) & l_31) > func_32(l_31, g_3, (g_3 & (((int16_t)func_39(g_3) << (int16_t)15) ^ (((g_3 ^ l_31) & 0x4C54422E) != l_31))), l_31)) > g_3), g_3, l_31, l_31);
    if (l_574)
    { /* block id: 304 */
        struct S0 l_575 = {10,0xAB4AA508,65535U,2,-42,1524};
        g_56 = l_575;
        g_56 = l_576;
    }
    else
    { /* block id: 307 */
        int16_t l_600 = (-1);
        uint32_t l_601 = 0x6A4278E4;
        uint32_t l_610 = 0x7D4CA4C9;
        struct S0 l_616 = {7,0xE4B953B5,65533U,-1,8,695};
        if (g_56.f0)
        { /* block id: 308 */
            for (l_574 = 23; (l_574 < 2); l_574 -= 1)
            { /* block id: 311 */
                return g_56;
            }
        }
        else
        { /* block id: 314 */
            int32_t l_599 = 0;
            int32_t l_611 = (-9);
            for (l_31 = 21; (l_31 != 3); l_31 -= 1)
            { /* block id: 317 */
                uint32_t l_598 = 0x0EA40626;
                l_601 = ((int16_t)((uint16_t)(((int16_t)((uint16_t)((func_32(g_8, (((int16_t)((int16_t)g_375 % (int16_t)0xE72D) << (int16_t)(((uint16_t)((!0U) >= ((g_3 < (((int32_t)l_598 - (int32_t)l_599) < g_56.f5)) > func_46(l_600, g_56.f1, g_56.f1))) % (uint16_t)0xE0B5) >= 0x5AED1652)) || l_600), g_56.f0, g_375) | g_3) == g_296) >> (uint16_t)l_598) % (int16_t)0xF209) != 0x0B09) + (uint16_t)l_576.f1) >> (int16_t)6);
                g_56.f3 = (l_599 <= l_600);
                l_611 = (((uint16_t)g_8 % (uint16_t)((int16_t)__builtin_ffs(l_601) + (int16_t)((l_598 || (((((int16_t)((l_598 > (g_56.f3 | func_46(((int32_t)(g_56.f1 == (g_56.f4 != func_70(l_598, l_601, l_598))) + (int32_t)l_600), g_56.f4, g_296))) | (-1)) >> (int16_t)g_56.f3) >= l_598) <= 0xC34C) & 1U)) != l_610))) & g_8);
                for (g_56.f1 = 17; (g_56.f1 < 54); g_56.f1 += 1)
                { /* block id: 323 */
                    uint16_t l_615 = 0xE5AA;
                    g_614 = g_56;
                    l_615 = 0xB681C13A;
                    l_616 = g_614;
                    if (l_610)
                        break;
                }
            }
            g_56.f4 = g_614.f5;
        }
        g_375 = g_56.f3;
        g_56 = g_56;
        l_616.f3 = l_617;
    }
    for (l_574 = 0; (l_574 != (-2)); l_574 -= 1)
    { /* block id: 338 */
        uint32_t l_622 = 0x2665DA68;
        int32_t l_623 = 0;
        for (g_614.f2 = (-21); (g_614.f2 > 29); g_614.f2 += 1)
        { /* block id: 341 */
            l_623 = (g_614.f3 < (0x805F == __builtin_popcountll((((__builtin_ctz(g_614.f5) | ((l_622 <= 1U) != 4294967295U)) && (__builtin_ctz(((g_614.f3 != (7U > l_576.f2)) < 0xCDA8)) == g_614.f0)) | 0x51CF))));
        }
        g_614.f4 = g_614.f3;
    }
    g_614 = l_576;
    return g_56;
}


/* ------------------------------------------ */
/* 
 * reads : g_296 g_56.f5 g_56.f4 g_8 g_56.f0 g_3 g_56.f1 g_56.f2 g_56.f3 g_56 g_375
 * writes: g_56.f3 g_8 g_56 g_296 g_375
 */
static int32_t  func_26(uint32_t  p_27, uint16_t  p_28, uint32_t  p_29, int16_t  p_30)
{ /* block id: 264 */
    int16_t l_501 = (-1);
    uint32_t l_513 = 4294967295U;
    struct S0 l_538 = {7,1U,0x5657,2,7,509};
    int32_t l_547 = 0x2DB48A85;
    int32_t l_572 = 0xCB83D582;
    g_56.f3 = l_501;
    if ((func_74(g_296, (g_56.f5 || (-(uint32_t)p_29))) & (g_296 & (l_501 & __builtin_popcountl(p_29)))))
    { /* block id: 266 */
        uint16_t l_515 = 1U;
        struct S0 l_520 = {12,0xB71EDB14,65535U,2,-3,289};
        g_56.f4 = 0xCDD7182D;
        if (g_56.f3)
        { /* block id: 268 */
            uint32_t l_503 = 0xEF6109D3;
            int32_t l_514 = (-3);
            l_503 = ((-1) == func_62(g_56.f0));
            g_56.f3 = ((g_56.f0 > (p_28 == p_27)) >= (((func_70((((-(int32_t)((int16_t)((uint16_t)((int16_t)(((0x327F ^ ((uint32_t)func_70(l_513, (((0x3029 <= __builtin_bswap64(l_513)) != g_8) || l_501), l_503) % (uint32_t)g_56.f1)) == 1) >= g_375) << (int16_t)0) << (uint16_t)p_27) >> (int16_t)p_28)) >= (-4)) == 0xA00AC11C), l_513, g_296) != 0x27CDC5DF) > l_514) != 0x677E));
            l_514 = __builtin_ia32_crc32qi(g_56.f2, l_515);
        }
        else
        { /* block id: 272 */
            int32_t l_518 = 0x982659E2;
            struct S0 l_519 = {8,0x54F028AA,0x1CA3,-0,31,915};
            l_518 = ((int32_t)l_515 % (int32_t)g_296);
            l_520 = l_519;
            l_519 = l_519;
        }
        if (p_28)
        { /* block id: 277 */
            uint32_t l_537 = 0x272AAFEE;
            int16_t l_544 = (-1);
            uint16_t l_546 = 65535U;
            g_375 = (-9);
            g_56.f4 = l_501;
            for (l_501 = 0; (l_501 <= (-27)); l_501 -= 1)
            { /* block id: 282 */
                uint32_t l_531 = 4294967295U;
                int32_t l_534 = (-1);
                if (((int32_t)(((int16_t)(((int16_t)(__builtin_parityl(((int32_t)l_531 - (int32_t)((((((int16_t)(p_27 | ((func_65(p_29) <= 0xE9A23020) & ((p_27 >= ((l_534 > (-7)) || ((int32_t)(p_29 <= p_29) % (int32_t)0x65FE5795))) | 4294967286U))) % (int16_t)l_501) < g_3) != 0U) ^ p_28) != l_537))) ^ 4294967291U) << (int16_t)4) < 0) + (int16_t)g_296) && g_375) + (int32_t)(-10)))
                { /* block id: 283 */
                    int16_t l_539 = 0;
                    l_520.f3 = (8 ^ (g_56.f3 <= 0xA9E23ADA));
                    l_538 = l_520;
                    l_538.f4 = __builtin_ia32_crc32qi(g_56.f0, func_70(g_8, l_537, (p_30 >= (l_539 != ((int16_t)l_538.f5 >> (int16_t)((uint16_t)((((((g_56.f4 | p_28) != 0xABEA) != g_56.f2) | p_30) >= l_534) == g_56.f3) - (uint16_t)l_544))))));
                }
                else
                { /* block id: 287 */
                    struct S0 l_545 = {8,4U,0xA2D1,-0,32,1988};
                    l_538 = l_545;
                    if (l_546)
                        continue;
                }
            }
        }
        else
        { /* block id: 292 */
            int32_t l_552 = 0xA9450F15;
            struct S0 l_564 = {1,0x8FF8E282,0x61E0,-3,-21,1764};
            l_520.f3 = l_547;
            l_520.f3 = ((int16_t)((int16_t)(l_552 && __builtin_clzll((-(int16_t)(((uint32_t)g_375 + (uint32_t)func_74(p_28, (((uint32_t)func_65(p_28) + (uint32_t)0xB7678D84) != ((((int32_t)l_501 % (int32_t)p_28) != (((int32_t)0x4996A10D + (int32_t)p_27) & p_28)) != 0xF80B)))) & g_375)))) % (int16_t)p_29) << (int16_t)7);
            l_564 = g_56;
        }
    }
    else
    { /* block id: 297 */
        uint16_t l_567 = 1U;
        uint32_t l_571 = 4U;
        int32_t l_573 = 1;
        l_573 = ((uint32_t)l_547 + (uint32_t)__builtin_bswap64((((p_30 > g_56.f1) > (((__builtin_popcount(p_28) > 0xC110) <= (p_29 >= (l_567 && (((uint16_t)(((((!p_27) & l_567) || l_571) || l_572) > g_56.f3) % (uint16_t)l_567) | l_571)))) | p_27)) | 1)));
        g_56.f4 = 0;
        l_572 = ((-5) >= l_538.f1);
    }
    return p_27;
}


/* ------------------------------------------ */
/* 
 * reads : g_296 g_8 g_56.f3 g_3 g_56.f1 g_56.f4 g_56.f5 g_56.f0 g_56.f2 g_375
 * writes: g_56.f3 g_8 g_56
 */
static uint16_t  func_32(int32_t  p_33, int32_t  p_34, uint32_t  p_35, int32_t  p_36)
{ /* block id: 260 */
    uint32_t l_494 = 0xA8B92343;
    uint16_t l_499 = 0xB91C;
    int32_t l_500 = 0;
    l_500 = (((((uint16_t)(p_35 && (((uint16_t)(((int16_t)(l_494 >= ((int16_t)(0x424E && func_74(g_296, func_70((((((((0xF05CBE08 != (l_494 & g_296)) != ((uint16_t)l_494 + (uint16_t)(g_8 != 1U))) < g_56.f3) == g_3) || p_36) >= l_494) < g_56.f3), l_499, l_499))) % (int16_t)p_36)) % (int16_t)l_499) | g_375) % (uint16_t)g_375) | p_35)) << (uint16_t)l_494) <= g_375) >= l_494) <= p_36);
    p_33 = g_375;
    return l_499;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_56 g_8 g_296 g_375
 * writes: g_56.f4 g_56.f3 g_8 g_56 g_296 g_375
 */
static int16_t  func_39(int16_t  p_40)
{ /* block id: 37 */
    int32_t l_43 = 0x4C38D679;
    int32_t l_464 = 1;
    struct S0 l_467 = {9,0x51BEF540,1U,0,5,123};
    l_464 = ((g_3 == (((int32_t)(g_3 < __builtin_ffs(p_40)) + (int32_t)g_3) | ((g_3 <= l_43) & (((int16_t)(func_46((((uint16_t)func_52(((0x987C837E && 0) && p_40), l_43, g_56) % (uint16_t)p_40) > g_3), l_43, l_43) && 0) % (int16_t)g_3) != 7)))) == 0x0C1E);
    for (p_40 = 2; (p_40 != 1); p_40 -= 1)
    { /* block id: 245 */
        uint32_t l_468 = 0x4E785703;
        l_467 = l_467;
        if (g_56.f2)
            break;
        l_467.f4 = (func_74(l_43, g_8) || l_468);
    }
    for (l_467.f1 = (-30); (l_467.f1 > 35); l_467.f1 += 1)
    { /* block id: 252 */
        uint16_t l_477 = 65535U;
        if (((int16_t)g_56.f3 >> (int16_t)((uint32_t)((int16_t)(l_477 > p_40) - (int16_t)((uint16_t)g_56.f3 % (uint16_t)g_56.f1)) - (uint32_t)(0xBF27 != 0x0000))))
        { /* block id: 253 */
            uint32_t l_480 = 0xF2E4CC14;
            g_375 = ((0x4B4503A5 >= ((l_480 < ((int16_t)(__builtin_bswap64((-(int32_t)(p_40 || p_40))) ^ ((uint32_t)p_40 + (uint32_t)((int16_t)(g_56.f2 ^ (l_464 || p_40)) << (int16_t)5))) << (int16_t)p_40)) ^ g_56.f0)) || l_480);
        }
        else
        { /* block id: 255 */
            g_56.f3 = l_477;
        }
    }
    return p_40;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_46(uint32_t  p_47, uint32_t  p_48, int32_t  p_49)
{ /* block id: 240 */
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_56.f4 g_56.f5 g_8 g_56.f0 g_56.f1 g_56.f2 g_56.f3 g_56 g_296 g_375
 * writes: g_56.f4 g_56.f3 g_8 g_56 g_296 g_375
 */
static uint16_t  func_52(int32_t  p_53, uint32_t  p_54, struct S0  p_55)
{ /* block id: 38 */
    int16_t l_61 = 3;
    int32_t l_69 = 0;
    g_56.f4 = ((int16_t)p_55.f2 >> (int16_t)(4294967289U == __builtin_ffs(((int16_t)l_61 >> (int16_t)5))));
    if (p_55.f5)
    { /* block id: 40 */
        uint32_t l_64 = 4294967294U;
        int16_t l_421 = 0xA6D4;
        int32_t l_422 = 0x7F623BDB;
        p_55.f4 = (func_62((l_64 >= func_65((((((0x0EC3 | l_64) && ((int16_t)(-1) << (int16_t)l_69)) != func_70((func_74(p_55.f4, __builtin_ffsll(g_56.f4)) | 7U), l_69, g_3)) ^ p_55.f4) != 0xEC38D991)))) < p_55.f0);
        for (l_61 = (-13); (l_61 == 28); l_61 += 1)
        { /* block id: 203 */
            int16_t l_404 = 0xF26E;
            struct S0 l_423 = {5,0xB9D9CDE3,0x808E,0,-12,1586};
            if (((int32_t)__builtin_bswap64((((~((uint32_t)func_74(l_404, (g_56.f3 < ((((uint16_t)(((uint32_t)((uint16_t)p_55.f3 >> (uint16_t)5) + (uint32_t)((int16_t)0x0695 << (int16_t)0)) > p_55.f4) << (uint16_t)14) & ((-(uint16_t)g_8) | (p_53 && (__builtin_ffsl(l_404) ^ l_69)))) && 65531U))) % (uint32_t)p_55.f2)) == g_375) & p_55.f5)) + (int32_t)p_54))
            { /* block id: 204 */
                for (g_296 = 29; (g_296 <= 7); g_296 -= 2)
                { /* block id: 207 */
                    p_55.f4 = p_54;
                    l_421 = (((int16_t)(0x73E8F51A < ((func_74(l_69, p_55.f3) > (p_55.f5 <= (0x08E882E9 | ((g_296 && g_296) > ((-(int32_t)p_55.f3) < p_55.f2))))) | 0xEF2F)) << (int16_t)9) > 1);
                    l_422 = g_56.f0;
                    if (l_404)
                        continue;
                }
            }
            else
            { /* block id: 213 */
                p_55.f4 = g_56.f5;
                p_55 = l_423;
                g_56.f4 = ((uint16_t)p_55.f5 >> (uint16_t)((uint32_t)0x96242BDF - (uint32_t)0xD6B1C4B5));
                p_55 = p_55;
            }
            return l_423.f1;
        }
    }
    else
    { /* block id: 221 */
        uint32_t l_428 = 7U;
        l_69 = l_428;
        p_55.f3 = func_62(((int32_t)((uint16_t)(0 >= 65535U) << (uint16_t)0) % (int32_t)(g_3 && (((((int16_t)p_55.f3 - (int16_t)p_55.f1) == ((uint16_t)(l_61 <= ((uint16_t)((int32_t)p_55.f0 - (int32_t)(((int32_t)l_69 - (int32_t)0) >= p_55.f1)) - (uint16_t)0xBCE6)) << (uint16_t)10)) <= p_55.f3) <= 0U))));
    }
    for (p_54 = 0; (p_54 <= 21); p_54 += 6)
    { /* block id: 227 */
        int32_t l_457 = 0x6D504542;
        int16_t l_462 = (-3);
        for (p_55.f1 = 0; (p_55.f1 >= 14); p_55.f1 += 7)
        { /* block id: 230 */
            int32_t l_458 = (-4);
            if (((uint16_t)__builtin_clz(((int16_t)((int16_t)(((((g_8 == p_55.f2) && (g_8 || (func_65(l_457) == l_458))) & (((int16_t)5 << (int16_t)p_55.f5) > ((((((-(uint16_t)g_8) || 0x975F) < l_457) != g_296) ^ 1) <= 65535U))) == 0x1FD518D7) | l_462) >> (int16_t)0) << (int16_t)p_55.f4)) << (uint16_t)l_462))
            { /* block id: 231 */
                uint32_t l_463 = 4294967289U;
                g_56 = p_55;
                l_463 = g_56.f3;
            }
            else
            { /* block id: 234 */
                if (g_56.f3)
                    break;
            }
        }
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_56.f0 g_56.f1 g_296 g_56.f5 g_8 g_56.f2 g_56.f3 g_56.f4 g_56 g_375
 * writes: g_296 g_56.f3 g_8 g_56 g_375
 */
static uint32_t  func_62(uint16_t  p_63)
{ /* block id: 157 */
    uint32_t l_286 = 0x9B798C47;
    int32_t l_295 = 0xDF74A3EB;
    int32_t l_341 = 0x57BD719E;
    struct S0 l_360 = {15,4294967292U,65535U,2,-37,1454};
    uint16_t l_396 = 0x5375;
    if ((65527U ^ ((int32_t)0xE811AC5B % (int32_t)((((~((uint32_t)((__builtin_clz(l_286) | ((int16_t)(((uint16_t)((int32_t)((int32_t)func_70(l_295, l_295, (p_63 <= g_56.f0)) + (int32_t)p_63) % (int32_t)1U) << (uint16_t)l_295) | l_295) % (int16_t)g_296)) == g_56.f0) % (uint32_t)4294967295U)) ^ p_63) == g_56.f5) && g_56.f5))))
    { /* block id: 158 */
        uint32_t l_297 = 4294967295U;
        int16_t l_298 = 1;
        int16_t l_316 = (-7);
        int32_t l_317 = 0x7751AF70;
        int32_t l_334 = (-1);
        uint32_t l_337 = 0xFE5DA076;
        struct S0 l_357 = {11,3U,0x669C,3,-5,1611};
        l_297 = 0x32F5110C;
        if (((0x4DD2CD39 | ((-7) | l_298)) ^ (((uint16_t)(((int16_t)(~(0x44B9 != p_63)) << (int16_t)4) ^ (p_63 <= g_8)) >> (uint16_t)(((g_56.f2 == p_63) && l_298) != (-2))) != g_56.f2)))
        { /* block id: 160 */
            return p_63;
        }
        else
        { /* block id: 162 */
            uint16_t l_306 = 3U;
            int32_t l_327 = 0x831F2CF1;
            for (g_296 = (-29); (g_296 != (-29)); g_296 += 6)
            { /* block id: 165 */
                uint16_t l_318 = 0x8CC0;
                int32_t l_326 = 7;
                l_317 = (l_306 < ((((int32_t)(g_8 > ((uint16_t)g_56.f3 >> (uint16_t)2)) - (int32_t)l_306) || (((uint16_t)p_63 - (uint16_t)1U) | p_63)) || ((((int16_t)(-(int16_t)g_56.f5) - (int16_t)l_316) || 0xC8B3) >= g_56.f0)));
                l_326 = (((l_297 || l_318) == g_3) ^ ((int16_t)(-(uint16_t)((int32_t)(1 ^ (l_306 | ((__builtin_ffsl(l_286) <= (g_56.f0 | ((!((~(l_297 && p_63)) != g_56.f5)) & (-9)))) > 65532U))) - (int32_t)g_56.f4)) % (int16_t)l_318));
                g_56.f3 = p_63;
                l_327 = p_63;
            }
            l_317 = l_286;
            l_334 = (((int16_t)(((int16_t)(g_56.f4 || (p_63 != l_306)) % (int16_t)2U) == (-1)) >> (int16_t)4) == __builtin_ffsl(((int16_t)l_327 >> (int16_t)9)));
            l_334 = ((int32_t)(((l_337 || ((int16_t)(p_63 || (((65535U && func_74((-(int16_t)func_74((l_341 >= ((int32_t)((int16_t)(-7) << (int16_t)(((0x85A6 && ((uint16_t)0U << (uint16_t)(((int16_t)(((uint16_t)(-(int16_t)((((uint32_t)(0x7635 & (((uint32_t)(0x444C & p_63) + (uint32_t)l_306) != 0x8F1FDF21)) - (uint32_t)l_317) | p_63) != 1)) >> (uint16_t)p_63) | p_63) << (int16_t)2) ^ 0x6798))) < g_56.f0) & 0x654F)) - (int32_t)0xE3A921E9)), p_63)), l_306)) != g_296) | g_296)) - (int16_t)p_63)) >= 1) | 1U) - (int32_t)l_327);
        }
        l_357 = g_56;
        g_56 = l_357;
    }
    else
    { /* block id: 177 */
        int32_t l_358 = (-3);
        struct S0 l_359 = {9,2U,0x8648,-1,-5,1060};
        l_358 = g_56.f5;
        l_359 = l_359;
        l_359 = l_360;
        if (g_296)
        { /* block id: 181 */
            int16_t l_381 = (-8);
            int32_t l_395 = 0x583856E5;
            for (l_295 = 0; (l_295 == (-22)); l_295 -= 9)
            { /* block id: 184 */
                uint32_t l_374 = 0xBD6C7DC5;
                g_375 = ((int16_t)(0x8C78 | ((uint16_t)(((int16_t)((int32_t)(g_56.f5 == (((((int16_t)(1 <= 0xCA38) + (int16_t)((0x372EC936 > p_63) | (((__builtin_ffsll(g_56.f2) >= func_70(((-(int16_t)g_56.f5) ^ l_286), p_63, l_359.f5)) > 0x12FE) >= p_63))) | g_296) >= g_8) ^ l_360.f5)) % (int32_t)p_63) >> (int16_t)l_374) | l_359.f3) >> (uint16_t)1)) << (int16_t)l_360.f0);
            }
            l_295 = ((!(((uint16_t)((uint16_t)func_70(g_375, g_56.f3, l_360.f0) >> (uint16_t)3) << (uint16_t)9) > g_56.f5)) && l_381);
            if (((~l_359.f1) ^ 0x3A2674D3))
            { /* block id: 188 */
                uint32_t l_385 = 4294967294U;
                l_295 = (((int16_t)l_385 >> (int16_t)0) || ((uint32_t)(((uint16_t)l_359.f1 << (uint16_t)l_381) || l_385) + (uint32_t)l_360.f2));
            }
            else
            { /* block id: 190 */
                l_395 = ((((((g_375 >= 0xD29A96D1) && (((func_65(((uint16_t)p_63 << (uint16_t)14)) ^ ((int16_t)p_63 % (int16_t)(g_296 ^ ((-1) && l_381)))) | (~((p_63 != 1U) && g_375))) ^ (-8))) ^ 0x33A5) <= p_63) && p_63) && g_56.f1);
                g_56.f4 = 4;
            }
        }
        else
        { /* block id: 194 */
            return l_396;
        }
    }
    l_360 = l_360;
    return l_360.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_56 g_8
 * writes: g_56
 */
static uint32_t  func_65(uint32_t  p_66)
{ /* block id: 142 */
    struct S0 l_276 = {13,0xEF91F784,65532U,-0,33,482};
    uint32_t l_277 = 0U;
    l_276 = l_276;
    l_277 = (l_276.f4 > p_66);
    l_276.f3 = 0xE39112D3;
    if ((l_276.f1 <= l_276.f0))
    { /* block id: 146 */
        struct S0 l_280 = {13,0xC72399D5,4U,2,41,1477};
        for (p_66 = 0; (p_66 >= 50); p_66 += 1)
        { /* block id: 149 */
            g_56 = l_280;
            g_56 = g_56;
        }
    }
    else
    { /* block id: 153 */
        l_276 = g_56;
    }
    return g_8;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f1
 * writes:
 */
static uint16_t  func_70(uint32_t  p_71, uint16_t  p_72, int32_t  p_73)
{ /* block id: 140 */
    return g_56.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_56.f4 g_56.f5 g_8 g_56.f0 g_3 g_56.f1 g_56.f2 g_56.f3
 * writes: g_56.f3 g_8 g_56
 */
static int16_t  func_74(uint32_t  p_75, int32_t  p_76)
{ /* block id: 41 */
    int32_t l_80 = 0x5FBD7B92;
    int32_t l_137 = 1;
    int16_t l_149 = 4;
    int16_t l_151 = 0x109A;
    struct S0 l_198 = {12,0U,0x3601,1,-17,919};
    int16_t l_275 = 5;
    g_56.f3 = (-2);
    for (p_76 = 0; (p_76 >= (-29)); p_76 -= 8)
    { /* block id: 45 */
        int16_t l_79 = 0x690D;
        int32_t l_88 = 0xEC5F6624;
        struct S0 l_97 = {1,0x04BE3C25,0x47F8,-3,29,117};
        l_80 = l_79;
        if (((((8 > (((((int32_t)((uint32_t)(((l_80 < ((__builtin_ia32_crc32qi((0xD1E9 && g_56.f4), (-(int16_t)((((uint32_t)p_75 % (uint32_t)(g_56.f5 && ((__builtin_ffsll(g_8) < 0xA050) > l_80))) & (-10)) > g_56.f0))) < l_79) >= l_79)) & p_75) != p_75) + (uint32_t)0x0CB415C8) + (int32_t)l_80) ^ (-10)) != 1U) < l_88)) >= g_56.f1) >= p_76) < l_80))
        { /* block id: 47 */
            int16_t l_118 = 0x10CD;
            for (g_8 = 8; (g_8 != (-22)); g_8 -= 6)
            { /* block id: 50 */
                uint16_t l_92 = 3U;
                int32_t l_95 = (-10);
                if (p_75)
                { /* block id: 51 */
                    int16_t l_96 = 2;
                    int32_t l_98 = 0x2FBF9108;
                    struct S0 l_99 = {7,0x594313D3,0x1830,3,-10,270};
                    if (p_75)
                    { /* block id: 52 */
                        l_95 = (!((l_92 < 65529U) >= ((uint32_t)(l_80 == 0x4EA18A5A) % (uint32_t)p_75)));
                        l_95 = (p_76 > l_96);
                    }
                    else
                    { /* block id: 55 */
                        g_56 = l_97;
                        l_98 = (-1);
                    }
                    l_97.f3 = g_56.f4;
                    g_56 = l_99;
                    g_56.f4 = (((((uint32_t)4294967294U % (uint32_t)0x65D423D3) != 0) & l_97.f4) == (l_92 & p_75));
                }
                else
                { /* block id: 62 */
                    int32_t l_106 = 0xA17DA69E;
                    for (l_79 = 0; (l_79 == 3); l_79 += 8)
                    { /* block id: 65 */
                        if (p_75)
                            break;
                        l_106 = ((int16_t)0x6818 >> (int16_t)9);
                    }
                }
                for (l_92 = 29; (l_92 == 57); l_92 += 1)
                { /* block id: 72 */
                    uint32_t l_114 = 0xBD3B10D6;
                    l_95 = ((int32_t)((uint32_t)(!l_114) % (uint32_t)(((((!g_8) < ((int16_t)g_56.f1 << (int16_t)l_118)) && p_76) <= l_79) | g_56.f4)) + (int32_t)g_8);
                    for (l_97.f1 = (-30); (l_97.f1 == 6); l_97.f1 += 1)
                    { /* block id: 76 */
                        int32_t l_131 = 0xB8F8F025;
                        int32_t l_132 = 0;
                        g_56.f4 = ((((uint16_t)p_76 << (uint16_t)1) < ((((((((int32_t)g_56.f1 - (int32_t)g_8) || (l_80 ^ ((0x6C4584B3 < (((int32_t)((((uint16_t)((int16_t)(g_56.f2 >= (l_114 | 0x193D)) << (int16_t)10) * (uint16_t)((l_92 > l_88) <= l_92)) < g_56.f1) != g_56.f4) + (int32_t)l_92) == 0x13A7)) && 1U))) && 1) == g_56.f0) || p_76) && p_76) == 0x028DF646)) != g_3);
                        if (l_131)
                            break;
                        if (g_56.f3)
                            break;
                        l_132 = g_56.f2;
                    }
                }
            }
            l_137 = ((uint32_t)(1 >= ((uint16_t)g_56.f3 >> (uint16_t)2)) + (uint32_t)(l_80 == g_56.f1));
        }
        else
        { /* block id: 85 */
            int16_t l_148 = 0xC7F7;
            for (g_56.f1 = 17; (g_56.f1 > 22); g_56.f1 += 9)
            { /* block id: 88 */
                uint16_t l_150 = 0xA4AD;
                int32_t l_152 = 0xCA3772BF;
                l_152 = (((1 >= ((6 || ((uint16_t)((((int16_t)(4294967295U ^ (((p_76 & p_76) > (((uint16_t)(l_148 & (((g_56.f2 <= (((l_97.f0 == (((g_56.f1 > 0U) & 0x0C60) || 0)) <= 0x17B4) || 9U)) || (-3)) >= l_149)) >> (uint16_t)g_8) < p_75)) || p_75)) >> (int16_t)g_8) <= g_56.f5) | l_150) << (uint16_t)g_56.f5)) >= l_151)) > p_76) & g_56.f1);
            }
            g_56.f4 = ((uint16_t)(((uint32_t)((((uint16_t)(((g_56.f3 & (((int16_t)(-(int16_t)p_76) >> (int16_t)11) >= ((uint16_t)((uint32_t)0xC5061D60 - (uint32_t)((__builtin_clzll((0 <= ((int32_t)((int16_t)((uint32_t)((uint16_t)l_151 % (uint16_t)l_137) % (uint32_t)8) << (int16_t)10) % (int32_t)((int16_t)((int16_t)g_56.f4 >> (int16_t)((int16_t)(((int32_t)1 + (int32_t)0x57C3C58E) == g_8) % (int16_t)0x5930)) - (int16_t)p_76)))) < 0x5BA6) || p_75)) % (uint16_t)7))) > g_56.f4) <= g_56.f3) >> (uint16_t)12) && g_3) <= p_76) % (uint32_t)g_8) > 1U) >> (uint16_t)g_56.f0);
        }
        g_56.f4 = 1;
        if (p_75)
            continue;
    }
    if (__builtin_popcountll((g_56.f2 <= ((((int32_t)(0xFAB2E08F > ((g_56.f1 == __builtin_clz(l_151)) > (p_76 | ((int32_t)((uint16_t)g_8 >> (uint16_t)((int16_t)(((uint32_t)((int16_t)(__builtin_ffsll((((uint32_t)(g_8 > ((((uint32_t)(1 & 0x51CA7944) % (uint32_t)g_8) > p_75) <= l_149)) % (uint32_t)p_76) | l_149)) | 0xA68A6C42) + (int16_t)0x851E) - (uint32_t)4294967293U) || p_75) << (int16_t)g_56.f4)) % (int32_t)g_56.f1)))) % (int32_t)p_76) >= l_151) > p_75))))
    { /* block id: 96 */
        struct S0 l_199 = {1,0x33D140ED,0x186F,-0,29,32};
        g_56.f4 = g_3;
        l_199 = l_198;
        for (l_151 = 0; (l_151 >= 28); l_151 += 1)
        { /* block id: 101 */
            int32_t l_232 = 0x463068F1;
            uint32_t l_240 = 2U;
            struct S0 l_263 = {1,5U,0U,-1,26,218};
            for (p_75 = (-26); (p_75 >= 25); p_75 += 9)
            { /* block id: 104 */
                uint32_t l_204 = 0x9BE9E0A6;
                int32_t l_226 = 6;
                l_204 = p_76;
                if ((!((((int16_t)(((uint16_t)(((int32_t)((uint16_t)p_76 >> (uint16_t)10) - (int32_t)((int16_t)g_56.f1 << (int16_t)2)) ^ ((int16_t)((0xD743 ^ g_56.f1) && g_56.f3) << (int16_t)((((uint16_t)p_76 + (uint16_t)((int16_t)p_76 - (int16_t)((((l_198.f3 || ((g_3 != l_204) != 4294967286U)) == 0xE38A5526) && g_8) == g_8))) > p_75) != l_204))) - (uint16_t)65533U) && p_75) + (int16_t)65535U) && 0xB04F0948) >= l_80)))
                { /* block id: 106 */
                    uint16_t l_225 = 1U;
                    int32_t l_247 = 0xECA28C0A;
                    l_226 = ((g_56.f0 != 5U) && (!((int32_t)l_225 - (int32_t)p_75)));
                    g_56.f3 = (g_8 & (((__builtin_clzl(g_56.f5) < 0) || ((!(g_56.f3 ^ g_56.f4)) && ((g_56.f0 != (((p_76 == (((p_75 > g_56.f0) < (-1)) == g_8)) > 1U) >= g_56.f4)) & g_56.f5))) > 0x82D2));
                    for (l_199.f1 = 0; (l_199.f1 > 53); l_199.f1 += 1)
                    { /* block id: 111 */
                        int32_t l_237 = 0x3D589764;
                        l_232 = ((g_56.f3 | 0) ^ ((uint16_t)g_56.f2 >> (uint16_t)7));
                        l_247 = (p_75 || ((uint16_t)l_199.f1 << (uint16_t)((int16_t)l_237 + (int16_t)(((int16_t)((l_240 | (((int16_t)(((uint32_t)g_3 - (uint32_t)l_225) || l_240) - (int16_t)((int16_t)__builtin_ia32_crc32qi(((l_240 | (-6)) ^ g_56.f1), l_199.f3) << (int16_t)l_204)) >= l_232)) ^ g_56.f5) % (int16_t)2) < 0x0275))));
                    }
                }
                else
                { /* block id: 115 */
                    int16_t l_256 = 0;
                    for (g_56.f2 = 12; (g_56.f2 >= 56); g_56.f2 += 4)
                    { /* block id: 118 */
                        if (p_75)
                            break;
                        l_256 = (g_56.f1 && ((uint32_t)((g_56.f5 != 0x9EE9) == (((int16_t)3 >> (int16_t)9) & (p_76 & ((uint16_t)(l_199.f5 || 0xCBD32DF4) << (uint16_t)3)))) - (uint32_t)g_56.f5));
                        return l_226;
                    }
                    for (l_199.f2 = 0; (l_199.f2 == 7); l_199.f2 += 1)
                    { /* block id: 125 */
                        return g_3;
                    }
                    l_232 = (g_8 == 0x2739A248);
                }
                l_198.f4 = (((int16_t)(((uint16_t)(g_56.f3 || g_56.f1) << (uint16_t)8) != l_199.f0) >> (int16_t)3) <= 0x17AF234C);
                if (p_75)
                    continue;
            }
            g_56 = l_263;
        }
    }
    else
    { /* block id: 135 */
        struct S0 l_264 = {4,1U,0x8F4A,0,-27,1801};
        int16_t l_269 = 0x5513;
        l_264 = l_198;
        l_137 = ((int16_t)0x49A0 << (int16_t)((((((0 ^ (__builtin_parityll(l_264.f5) >= (g_56.f4 & l_198.f2))) | ((((int16_t)l_269 << (int16_t)7) <= (-(int32_t)(((((((__builtin_parity(((uint16_t)(l_264.f2 && (((uint32_t)0x91239367 + (uint32_t)g_56.f5) & l_275)) << (uint16_t)13)) == (-1)) ^ g_56.f5) & l_198.f4) ^ l_264.f4) == 0x7166874D) > 0U) < l_264.f2))) != g_8)) == g_56.f4) <= g_56.f4) == 0x584FAC85) >= 0x5D75124B));
    }
    return l_151;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_25();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_8, "g_8", print_hash_value);
    transparent_crc(g_56.f0, "g_56.f0", print_hash_value);
    transparent_crc(g_56.f1, "g_56.f1", print_hash_value);
    transparent_crc(g_56.f2, "g_56.f2", print_hash_value);
    transparent_crc(g_56.f3, "g_56.f3", print_hash_value);
    transparent_crc(g_56.f4, "g_56.f4", print_hash_value);
    transparent_crc(g_56.f5, "g_56.f5", print_hash_value);
    transparent_crc(g_296, "g_296", print_hash_value);
    transparent_crc(g_375, "g_375", print_hash_value);
    transparent_crc(g_614.f0, "g_614.f0", print_hash_value);
    transparent_crc(g_614.f1, "g_614.f1", print_hash_value);
    transparent_crc(g_614.f2, "g_614.f2", print_hash_value);
    transparent_crc(g_614.f3, "g_614.f3", print_hash_value);
    transparent_crc(g_614.f4, "g_614.f4", print_hash_value);
    transparent_crc(g_614.f5, "g_614.f5", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 104
   depth: 1, occurrence: 23
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 23
breakdown:
   indirect level: 0, occurrence: 23
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 29
XXX times a bitfields struct on RHS: 32
XXX times a single bitfield on LHS: 33
XXX times a single bitfield on RHS: 120

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 208
   depth: 2, occurrence: 35
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 3
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 2
   depth: 25, occurrence: 2
   depth: 26, occurrence: 4
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 637
XXX times a non-volatile is write: 137
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 184
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 42
   depth: 2, occurrence: 38
   depth: 3, occurrence: 29
   depth: 4, occurrence: 26
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

