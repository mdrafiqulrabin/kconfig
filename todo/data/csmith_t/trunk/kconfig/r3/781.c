/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3216394503
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 2;
   uint16_t  f1;
   const unsigned f2 : 16;
   unsigned f3 : 27;
   uint16_t  f4;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   signed f0 : 17;
   uint32_t  f1;
   const unsigned f2 : 30;
   unsigned f3 : 8;
   signed f4 : 21;
   struct S0  f5;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_32(void);
inline static uint16_t  func_39(int32_t  p_40, int16_t  p_41, int32_t  p_42, struct S1  p_43);
static uint16_t  func_46(int16_t  p_47, struct S1  p_48, struct S0  p_49);
static struct S1  func_50(uint16_t  p_51, uint32_t  p_52, int32_t  p_53);
static int32_t  func_57(int32_t  p_58, int32_t  p_59, int32_t  p_60);
static int32_t  func_68(struct S0  p_69, uint16_t  p_70, int32_t ** const  p_71, uint16_t  p_72, const uint16_t  p_73);
static int32_t ** func_75(const int32_t ** p_76, int32_t * p_77, const int32_t * p_78);
static const int32_t ** func_79(const uint32_t  p_80, int32_t ** p_81, int32_t * p_82);
static int32_t ** func_83(int16_t  p_84, int32_t * p_85, int32_t ** p_86);
inline static float  func_95(int32_t  p_96);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_32(void)
{ /* block id: 36 */
    const int32_t l_33 = 0xDD7582BA;
    int32_t l_1101 = 0x93151B55;
    int32_t *l_1100 = &l_1101;
    int32_t **l_1099 = &l_1100;
    struct S1 l_1130 = {-86,1U,15184,3,498,{-0,0x5A67,108,324,0xAC8C}};
    struct S1 *l_1143 = &l_1130;
    struct S1 **l_1142 = &l_1143;
    struct S1 ***l_1141 = &l_1142;
    struct S1 ****l_1140 = &l_1141;
    struct S0 *****l_1160 = (void*)0;
    int32_t *l_1179 = &l_1101;
    int16_t l_1209 = 0;
    struct S1 l_1222 = {-228,4294967292U,22840,10,807,{0,0xB7F5,202,7302,0x0A5F}};
    if (l_33)
    { /* block id: 37 */
        int32_t l_38 = 1;
        struct S0 l_828 = {1,0xEC21,186,10665,5U};
        struct S1 l_832 = {86,1U,6688,14,458,{-0,65535U,101,2221,0x9326}};
        int32_t l_1054 = 0xAB677147;
        int32_t *l_1053 = &l_1054;
        (*l_1053) = (((int16_t)((int16_t)l_33 >> (int16_t)l_38) >> (int16_t)2) >= func_39(l_38, (((uint16_t)(func_46(l_38, func_50(l_38, (!((int16_t)(func_57((l_38 ^ l_38), l_33, (~(l_33 < l_38))) && (-2)) << (int16_t)2)), l_38), l_828) >= l_33) << (uint16_t)8) == l_828.f1), l_828.f2, l_832));
    }
    else
    { /* block id: 592 */
        int32_t l_1059 = (-3);
        int32_t l_1061 = 0x6F446BEB;
        struct S1 l_1062 = {-117,4294967294U,23705,4,-1121,{-0,0xBE6A,3,5594,0U}};
        int32_t *l_1063 = &l_1059;
        uint32_t l_1070 = 4U;
        int16_t l_1077 = 0x66CD;
        const struct S0 *l_1092 = &l_1062.f5;
        const struct S0 **l_1091 = &l_1092;
        const struct S0 ***l_1090 = &l_1091;
        const struct S0 **** const l_1089 = &l_1090;
        const struct S0 **** const *l_1088 = &l_1089;
        float l_1114 = 0xB.80FCDAp-66;
        float l_1129 = 0x0.1p-1;
        uint32_t l_1145 = 4294967292U;
        struct S0 *l_1165 = &l_1062.f5;
        struct S0 **l_1164 = &l_1165;
        struct S0 ***l_1163 = &l_1164;
        struct S0 ****l_1162 = &l_1163;
        struct S0 *****l_1161 = &l_1162;
        struct S1 ****l_1172 = &l_1141;
lbl_1111:
        (*l_1063) = func_39(((int16_t)l_33 << (int16_t)((uint32_t)l_1059 + (uint32_t)(((+65535U) | __builtin_clzl(l_33)) == l_1059))), l_1061, l_1061, l_1062);
        (*l_1063) = (__builtin_parity((((uint16_t)((int16_t)(*l_1063) - (int16_t)l_33) << (uint16_t)((int32_t)l_1070 - (int32_t)((int16_t)((0x1A697976 <= ((uint16_t)(0xB76A != l_33) << (uint16_t)((int16_t)__builtin_ctz((*l_1063)) >> (int16_t)(*l_1063)))) == l_1077) >> (int16_t)0))) >= 0xD29A0F99)) || (*l_1063));
        if (((int16_t)((int16_t)(+(+l_33)) - (int16_t)((uint32_t)l_33 % (uint32_t)l_33)) << (int16_t)((((int32_t)(l_1088 != (void*)0) - (int32_t)(+(-1))) && ((*l_1063) > 4294967295U)) == ((int32_t)(l_33 != l_33) + (int32_t)(*l_1063)))))
        { /* block id: 595 */
            uint32_t l_1096 = 4294967295U;
            struct S1 l_1097 = {-360,4294967295U,3078,6,827,{0,1U,14,9806,0xCCE3}};
            (*l_1063) = __builtin_bswap32(l_1096);
            return l_1097;
        }
        else
        { /* block id: 598 */
            uint32_t l_1098 = 8U;
            uint16_t l_1106 = 9U;
            struct S1 **l_1109 = (void*)0;
            struct S1 ***l_1108 = &l_1109;
            struct S1 ****l_1107 = &l_1108;
            float l_1113 = 0x1.Dp+1;
            float *l_1119 = (void*)0;
            float *l_1120 = (void*)0;
            float *l_1121 = &l_1113;
            if (((l_33 == ((l_1098 && (((&l_1063 != l_1099) | l_1098) | ((4294967287U <= (**l_1099)) ^ ((int16_t)(**l_1099) >> (int16_t)4)))) ^ ((((int16_t)__builtin_ffs(l_1106) >> (int16_t)8) != (*l_1100)) ^ (*l_1100)))) | (*l_1063)))
            { /* block id: 599 */
                struct S1 *****l_1110 = &l_1107;
                (*l_1110) = l_1107;
                if (l_1062.f5.f4)
                    goto lbl_1111;
                (*l_1099) = &l_1059;
                /* statement id: 602 */
                assert (l_1100 == &l_1059);
            }
            else
            { /* block id: 603 */
                int32_t *l_1112 = &l_1061;
                float *l_1117 = &l_1113;
                int32_t *l_1118 = &l_1101;
                (*l_1099) = l_1112;
                /* statement id: 604 */
                assert (l_1100 == &l_1061);
                (*l_1063) = ((*l_1112) == 4);
                (*l_1117) = ((float)func_95((**l_1099)) + (float)l_1098);
                l_1118 = (*l_1099);
                /* statement id: 607 */
                assert (l_1118 == &l_1061);
            }
            /* facts after branching */
            assert (l_1100 == &l_1061 || l_1100 == &l_1059);
            (*l_1121) = (*l_1063);
            for (l_1062.f5.f1 = 0; (l_1062.f5.f1 >= 26); l_1062.f5.f1 += 1)
            { /* block id: 612 */
                int16_t l_1128 = 0x8678;
                int32_t l_1137 = 0x529291BF;
                int32_t *l_1138 = &l_1061;
                struct S1 ****l_1169 = &l_1141;
                struct S1 * const ****l_1173 = (void*)0;
                struct S1 *****l_1174 = &l_1169;
            }
        }
        /* facts after branching */
        assert (l_1100 == &l_1061 || l_1100 == &l_1059);
        (*l_1099) = (void*)0;
        /* statement id: 664 */
        assert (l_1100 == 0);
    }
    /* facts after branching */
    assert (l_1100 == 0 || l_1100 == &l_1101);
    for (l_1130.f1 = (-7); (l_1130.f1 < 4); l_1130.f1 += 1)
    { /* block id: 668 */
        int32_t l_1189 = 0xF392A2F5;
        struct S1 *l_1193 = &l_1130;
        int32_t l_1195 = 4;
        struct S0 l_1210 = {0,0xAB39,193,2491,0x528A};
        float *l_1211 = (void*)0;
        float *l_1212 = (void*)0;
        struct S0 *l_1216 = &l_1210;
        struct S0 **l_1215 = &l_1216;
        for (l_1130.f5.f1 = 0; (l_1130.f5.f1 > 18); l_1130.f5.f1++)
        { /* block id: 671 */
            float l_1190 = (-0x1.9p+1);
            const int32_t l_1191 = 0x2B170230;
            struct S0 * const l_1192 = &l_1130.f5;
            int16_t l_1194 = 0x3E35;
            if ((*l_1179))
                break;
            l_1195 = (l_1189 & (l_1189 == (((((l_1191 == ((1 | l_1189) < l_1191)) || ((void*)0 == l_1192)) >= ((**l_1141) == l_1193)) & l_1189) || l_1194)));
        }
        (*l_1179) = func_46((!1), func_50((func_68(l_1130.f5, (((0x41CB & (((((((uint16_t)(-(int16_t)(((uint16_t)l_1189 >> (uint16_t)8) & ((uint32_t)4294967289U + (uint32_t)((uint32_t)((~((int16_t)((((*l_1179) > 1) ^ (*l_1179)) && __builtin_bswap32(l_1195)) % (int16_t)l_1195)) ^ l_1189) - (uint32_t)0x87E83C52)))) - (uint16_t)l_1195) < 0x261F) & l_1209) >= 4294967286U) == 65533U) | l_1189)) || 0x37B6) <= l_1195), &l_1100, l_1189, l_1195) <= 0xDA314F0F), l_1195, l_1189), l_1210);
        for (l_1101 = 0; (l_1101 <= 20); l_1101++)
        { /* block id: 678 */
            struct S0 **l_1217 = &l_1216;
            int32_t l_1218 = (-1);
            int32_t *l_1219 = &l_1189;
            l_1217 = l_1215;
            (*l_1219) = l_1218;
            if (l_1210.f3)
            { /* block id: 681 */
                int32_t *l_1220 = &l_1218;
                l_1220 = l_1220;
            }
            else
            { /* block id: 683 */
                int32_t l_1221 = 1;
                (*l_1219) = __builtin_popcountl(l_1221);
            }
        }
    }
    return l_1222;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_39(int32_t  p_40, int16_t  p_41, int32_t  p_42, struct S1  p_43)
{ /* block id: 466 */
    int32_t l_835 = 0x84897C67;
    int32_t *l_834 = &l_835;
    int32_t **l_833 = &l_834;
    struct S0 l_841 = {-0,65535U,6,4861,0xA688};
    struct S0 *l_840 = &l_841;
    struct S1 l_868 = {297,0xFB2EAC16,2891,9,545,{-0,0x44BC,46,673,0xA625}};
    float l_953 = 0x8.Dp-1;
    struct S0 ** const ***l_995 = (void*)0;
    int32_t *****l_1003 = (void*)0;
    int32_t l_1009 = 1;
    struct S1 * const * const **l_1024 = (void*)0;
    struct S1 * const * const ***l_1023 = &l_1024;
    struct S0 **l_1048 = &l_840;
    struct S0 ***l_1047 = &l_1048;
    struct S0 ****l_1046 = &l_1047;
    (*l_833) = &p_40;
    /* statement id: 467 */
    assert (l_834 == &p_40);
    if ((p_43.f4 >= (__builtin_ctzll(p_40) || (p_43.f5.f1 == (((int16_t)__builtin_parity((*l_834)) - (int16_t)8U) | ((__builtin_popcount(__builtin_popcount(((uint16_t)(*l_834) >> (uint16_t)12))) & (*l_834)) == (**l_833)))))))
    { /* block id: 468 */
        int32_t ***l_844 = &l_833;
        int32_t **** const l_843 = &l_844;
        struct S0 l_869 = {0,0xFD8F,37,3869,65533U};
        struct S0 **l_895 = &l_840;
        struct S1 l_904 = {-98,0U,5544,4,805,{-1,1U,10,5653,65531U}};
        struct S1 *l_903 = &l_904;
        struct S1 **l_913 = &l_903;
        struct S1 ** const *l_912 = &l_913;
        uint16_t l_941 = 0x385E;
        float *l_991 = &l_953;
        int16_t l_992 = 1;
        if (p_43.f5.f4)
        { /* block id: 469 */
            struct S0 **l_842 = &l_840;
            int32_t ** const *l_846 = (void*)0;
            int32_t ** const **l_845 = &l_846;
            int32_t l_851 = 1;
            const int32_t l_863 = 0;
            (*l_842) = l_840;
            (*l_833) = (*l_833);
            (****l_843) = ((0xB92EB2A7 > ((l_843 != l_845) & ((((int32_t)((((int16_t)l_851 % (int16_t)(**l_833)) && ((*l_834) < (((int16_t)((int16_t)((int16_t)p_43.f4 << (int16_t)(-(uint32_t)((uint16_t)((int16_t)((*l_844) == (**l_843)) - (int16_t)p_43.f4) >> (uint16_t)p_43.f1))) % (int16_t)l_863) << (int16_t)12) || p_43.f0))) >= (*l_834)) % (int32_t)(***l_844)) != (**l_833)) != p_43.f3))) < p_43.f4);
        }
        else
        { /* block id: 473 */
            int32_t ** const l_870 = &l_834;
            const struct S1 *l_905 = (void*)0;
            struct S0 l_924 = {1,65530U,80,5632,6U};
            int32_t l_929 = 0;
            struct S1 *****l_938 = (void*)0;
            struct S0 ***l_972 = &l_895;
            struct S0 ****l_971 = &l_972;
            if (((((uint16_t)(p_43.f3 ^ ((uint16_t)65526U << (uint16_t)(0x4B4C || 1U))) >> (uint16_t)9) < (func_46((***l_844), l_868, l_869) || (__builtin_popcountll(((*l_844) != l_870)) > 0x752383E9))) == (-9)))
            { /* block id: 474 */
                const int16_t l_874 = 0x2BB5;
                int32_t **l_883 = &l_834;
                struct S0 **l_894 = &l_840;
                if ((p_43.f1 > (((0 >= __builtin_ffsl((((((int32_t)(!func_68((*l_840), (**l_870), &l_834, p_43.f0, (0xFAF0B633 >= l_874))) - (int32_t)(**l_870)) && p_43.f5.f2) && p_43.f4) != p_43.f5.f3))) && (**l_870)) || p_43.f2)))
                { /* block id: 475 */
                    uint16_t l_879 = 0x7BBD;
                    struct S1 **l_906 = &l_903;
                    struct S1 ***l_910 = &l_906;
                    struct S1 ****l_909 = &l_910;
                    if ((**l_870))
                    { /* block id: 476 */
                        struct S1 *l_876 = &l_868;
                        struct S1 **l_875 = &l_876;
                        float l_882 = 0xB.576157p+27;
                        float *l_881 = &l_882;
                        int32_t l_888 = 0xB36136FF;
                        (*l_875) = (void*)0;
                        /* statement id: 477 */
                        assert (l_876 == 0);
                        (*l_881) = (((float)0xD.DEAA2Cp-98 - (float)l_879) >= (!0x2.1CBB04p-51));
                        (*l_844) = l_883;
                        (*l_881) = (((float)__builtin_ffsll(p_43.f5.f0) - (float)(**l_870)) != ((float)(((l_888 >= ((((0x6.Dp+1 >= ((((l_888 < (((float)(***l_844) - (float)((-0x1.6p+1) == 0x1.324FD0p+73)) <= l_888)) > p_43.f0) >= l_879) >= (-0x1.Bp+1))) == p_43.f5.f4) != 0x9.B08FF4p-49) < 0x7.FB3C0Ep+70)) < p_43.f2) < (**l_883)) + (float)l_888));
                    }
                    else
                    { /* block id: 481 */
                        int32_t *l_891 = (void*)0;
                        float l_902 = (-0x3.Ep+1);
                        l_891 = (*l_833);
                        /* statement id: 482 */
                        assert (l_891 == &p_40);
                        (*l_834) = (((int16_t)(func_57((l_894 != l_895), p_43.f5.f4, (((((((int16_t)p_43.f5.f3 + (int16_t)(((uint16_t)((uint16_t)0xD383 % (uint16_t)0x0B4A) >> (uint16_t)((**l_870) | p_41)) < ((**l_883) > p_43.f5.f3))) >= p_43.f5.f0) != p_41) < (***l_844)) > 0x8B67) & 1U)) && (****l_843)) << (int16_t)p_43.f5.f2) ^ (*l_834));
                        l_903 = &p_43;
                        /* statement id: 484 */
                        assert (l_903 == &p_43);
                        (*l_833) = (*l_870);
                    }
                    /* facts after branching */
                    assert (l_903 == &p_43 || l_903 == &l_904);
                    (*l_906) = l_905;
                    /* statement id: 487 */
                    assert (l_903 == 0);
                    for (p_43.f5.f1 = (-26); (p_43.f5.f1 > 54); ++p_43.f5.f1)
                    { /* block id: 490 */
                        struct S1 *****l_911 = &l_909;
                        struct S1 ****l_914 = &l_910;
                        (*l_911) = l_909;
                        (*l_914) = l_912;
                        /* statement id: 492 */
                        assert (l_910 == &l_913);
                        (***l_844) = func_57((0U ^ ((int16_t)((int16_t)p_43.f3 >> (int16_t)8) >> (int16_t)6)), p_40, ((int32_t)((p_43.f0 < (p_41 <= (~((int16_t)0x6ED0 - (int16_t)p_43.f1)))) <= (5 == ((func_68(l_924, p_43.f2, &l_834, l_879, p_43.f5.f1) <= p_43.f5.f3) | (***l_844)))) % (int32_t)(****l_843)));
                    }
                    /* facts after for loop */
                    assert (l_910 == &l_913 || l_910 == &l_906);
                }
                else
                { /* block id: 495 */
                    for (p_41 = 0; (p_41 <= 29); ++p_41)
                    { /* block id: 498 */
                        float l_928 = 0x0.5p-1;
                        float *l_927 = &l_928;
                        if ((**l_870))
                            break;
                        (*l_927) = (**l_870);
                    }
                    return p_43.f5.f0;
                }
                /* facts after branching */
                assert (l_903 == 0);
                if ((***l_844))
                { /* block id: 504 */
                    return l_929;
                }
                else
                { /* block id: 506 */
                    float l_935 = (-0x1.5p+1);
                    for (l_904.f5.f4 = 0; (l_904.f5.f4 < 53); ++l_904.f5.f4)
                    { /* block id: 509 */
                        float *l_936 = &l_935;
                        struct S0 *l_937 = &l_868.f5;
                        (*l_936) = ((float)((p_43.f5.f0 > (((*l_870) == &p_40) == (**l_883))) <= (p_43.f3 >= (***l_844))) + (float)(-(float)l_935));
                        (**l_844) = (*l_883);
                        (*l_895) = l_937;
                        /* statement id: 512 */
                        assert (l_840 == &l_868.f5);
                        (****l_843) = (0xD9850256 < ((void*)0 == l_938));
                    }
                    /* facts after for loop */
                    assert (l_840 == &l_868.f5 || l_840 == &l_841);
                    (**l_844) = (*l_870);
                    (**l_883) = ((uint16_t)0x7189 >> (uint16_t)(func_57(p_43.f5.f2, p_43.f5.f0, p_43.f2) & ((l_941 >= (**l_870)) < (((((p_43.f5.f4 >= p_43.f4) != p_43.f1) > p_42) == 65530U) != 0x1D03512C))));
                    (**l_844) = (*l_870);
                }
                /* facts after branching */
                assert (l_840 == &l_868.f5 || l_840 == &l_841);
                (*l_870) = (***l_843);
            }
            else
            { /* block id: 520 */
                struct S0 l_950 = {1,65533U,129,486,0x724C};
                if ((((int16_t)((***l_844) | (**l_833)) >> (int16_t)14) && p_43.f0))
                { /* block id: 521 */
                    int16_t l_944 = (-2);
                    struct S0 ***l_970 = (void*)0;
                    struct S0 ****l_969 = &l_970;
                    l_944 = 0x7243BE47;
                    if (l_944)
                    { /* block id: 523 */
                        uint32_t l_947 = 0x3B7A6B01;
                        float *l_954 = (void*)0;
                        float *l_955 = &l_953;
                        (***l_843) = &p_40;
                        if (l_868.f5.f0)
                            goto lbl_956;
lbl_956:
                        (*l_955) = (func_57(l_944, ((uint16_t)(l_947 != (p_43.f5.f4 ^ __builtin_clz((**l_833)))) << (uint16_t)0), func_57(l_944, l_947, ((int16_t)(func_68(l_950, (((uint16_t)p_43.f5.f3 - (uint16_t)l_947) <= (***l_844)), &l_834, l_950.f2, p_43.f5.f4) >= (****l_843)) >> (int16_t)2))) > p_43.f4);
                        (***l_843) = &p_40;
                        (****l_843) = (((uint32_t)0x512BFE29 + (uint32_t)(p_43.f4 > ((l_947 || (((uint16_t)((p_43.f5.f3 > ((*l_834) != p_43.f4)) != ((0x7A087525 < __builtin_ctz(func_57(((**l_870) && l_950.f1), l_944, p_43.f2))) != l_947)) + (uint16_t)p_43.f1) <= l_947)) < 0x2F89))) <= p_43.f1);
                    }
                    else
                    { /* block id: 529 */
                        (***l_844) = (((***l_844) == (p_43.f5.f2 > (9 != (l_950.f2 <= ((**l_870) != l_944))))) & ((int32_t)(l_969 == l_971) + (int32_t)((uint32_t)((int16_t)p_40 % (int16_t)p_43.f0) - (uint32_t)0x6717F805)));
                    }
                    p_43.f0 = (p_40 <= p_40);
                    for (p_42 = 0; (p_42 <= (-21)); p_42--)
                    { /* block id: 535 */
                        struct S0 *l_981 = &l_841;
                        (*l_834) = ((int16_t)p_43.f3 << (int16_t)10);
                        (***l_971) = l_981;
                    }
                }
                else
                { /* block id: 539 */
                    int16_t l_982 = (-9);
                    struct S0 ** const **l_994 = (void*)0;
                    struct S0 ** const ***l_993 = &l_994;
                    (*l_913) = (**l_912);
                    if ((((l_982 == (*l_834)) && ((uint16_t)((uint32_t)0xD9DCF642 % (uint32_t)3) + (uint16_t)((int32_t)p_43.f5.f1 - (int32_t)__builtin_popcountl(((uint16_t)(func_57(l_982, (l_991 == (void*)0), p_43.f1) || 1) << (uint16_t)11))))) == l_992))
                    { /* block id: 541 */
                        l_995 = l_993;
                        /* statement id: 542 */
                        assert (l_995 == &l_994);
                        (***l_843) = &p_40;
                    }
                    else
                    { /* block id: 544 */
                        (*l_991) = 0x0.0p-1;
                        (*l_991) = (0x7.452FAAp+72 < __builtin_ctz((((int32_t)((**l_912) == &p_43) % (int32_t)((+(((uint16_t)l_982 << (uint16_t)11) > __builtin_clzl(__builtin_ffsll((**l_870))))) ^ l_950.f0)) > p_43.f5.f2)));
                    }
                    /* facts after branching */
                    assert (l_995 == 0 || l_995 == &l_994);
                    return p_43.f2;
                }
            }
            /* facts after branching */
            assert (l_840 == &l_868.f5 || l_840 == &l_841);
            assert (l_903 == &l_904 || l_903 == 0);
            (*l_870) = (*l_870);
            for (l_904.f5.f1 = 11; (l_904.f5.f1 != 52); ++l_904.f5.f1)
            { /* block id: 554 */
                const int32_t *l_1020 = &l_929;
                const int32_t **l_1019 = &l_1020;
                if ((0xB92F && 0x2DAC))
                { /* block id: 555 */
                    int16_t l_1006 = 1;
                    (**l_844) = &p_40;
                    (***l_971) = &l_841;
                    /* statement id: 557 */
                    assert (l_840 == &l_841);
                    (*l_834) = (l_1003 != l_1003);
                    (*l_991) = (0x3.6D1508p-81 != func_46(func_46(((void*)0 == &l_870), func_50((*l_834), p_43.f0, (p_42 != func_57(((int16_t)__builtin_ctzl((((**l_844) == (void*)0) & l_1006)) >> (int16_t)(***l_844)), (***l_844), (**l_870)))), (**l_895)), p_43, (****l_971)));
                }
                else
                { /* block id: 560 */
                    for (l_904.f1 = 0; (l_904.f1 < 18); l_904.f1 += 2)
                    { /* block id: 563 */
                        uint32_t l_1018 = 1U;
                        const int32_t *l_1021 = (void*)0;
                        int32_t ***l_1022 = &l_833;
                    }
                    (*l_991) = p_43.f3;
                }
                (***l_971) = (**l_972);
                (**l_844) = &p_40;
                return p_43.f0;
            }
            (*l_991) = (****l_843);
        }
        /* facts after branching */
        assert (l_840 == &l_868.f5 || l_840 == &l_841);
        assert (l_903 == &l_904 || l_903 == 0);
    }
    else
    { /* block id: 576 */
        uint16_t l_1027 = 0xC8F7;
        float *l_1032 = &l_953;
        (*l_1032) = ((l_1023 == (void*)0) <= ((float)(func_57(l_1027, ((int16_t)l_1027 << (int16_t)(*l_834)), p_40) > (*l_834)) + (float)((float)l_1027 - (float)l_1027)));
    }
    /* facts after branching */
    assert (l_840 == &l_868.f5 || l_840 == &l_841);
    for (l_841.f4 = 0; (l_841.f4 > 47); l_841.f4 += 5)
    { /* block id: 581 */
        struct S0 *l_1035 = &l_841;
        struct S0 **l_1036 = &l_1035;
        struct S1 *l_1042 = (void*)0;
        struct S1 **l_1041 = &l_1042;
        struct S1 ***l_1045 = &l_1041;
        struct S1 ****l_1044 = &l_1045;
        struct S0 ** const *l_1050 = &l_1036;
        struct S0 ** const **l_1049 = &l_1050;
        int32_t l_1051 = 1;
        (*l_1036) = l_1035;
        for (l_868.f5.f1 = 0; (l_868.f5.f1 > 14); l_868.f5.f1++)
        { /* block id: 585 */
            struct S1 **l_1043 = &l_1042;
            float *l_1052 = &l_953;
            (*l_1052) = ((p_43.f5.f4 == ((0x4.525174p+6 > (p_43.f5.f1 > (((float)p_43.f5.f2 + (float)((((((l_1041 != l_1043) == ((l_1044 == (*l_1023)) >= (l_1046 == l_1049))) == 0x7.0B7603p-24) < 0x0.2p+1) != l_1051) != p_43.f5.f1)) >= (**l_833)))) != l_1051)) >= p_43.f5.f1);
        }
    }
    (*l_833) = (void*)0;
    /* statement id: 589 */
    assert (l_834 == 0);
    return p_43.f5.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_46(int16_t  p_47, struct S1  p_48, struct S0  p_49)
{ /* block id: 463 */
    uint16_t l_829 = 0x514D;
    int32_t l_831 = 5;
    int32_t *l_830 = &l_831;
    (*l_830) = (l_829 < p_48.f3);
    return p_48.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_50(uint16_t  p_51, uint32_t  p_52, int32_t  p_53)
{ /* block id: 431 */
    int32_t **l_759 = (void*)0;
    int32_t **l_760 = (void*)0;
    int32_t *l_762 = (void*)0;
    int32_t **l_761 = &l_762;
    struct S0 *l_768 = (void*)0;
    struct S0 **l_767 = &l_768;
    struct S0 ***l_766 = &l_767;
    struct S0 ****l_765 = &l_766;
    int32_t ***l_775 = &l_761;
    int32_t ****l_774 = &l_775;
    int32_t *****l_773 = &l_774;
    struct S0 l_776 = {-1,65531U,241,9151,1U};
    int32_t l_782 = 0x7DE47684;
    struct S1 *l_793 = (void*)0;
    struct S1 **l_792 = &l_793;
    struct S1 ***l_791 = &l_792;
    struct S1 ****l_790 = &l_791;
    struct S1 **** const *l_789 = &l_790;
    const struct S0 l_798 = {1,1U,138,3570,0xB1A7};
    const struct S0 *l_797 = &l_798;
    struct S1 l_827 = {-135,0xE8D0B73F,2637,12,761,{1,65535U,226,8068,65535U}};
    (*l_761) = &p_53;
    /* statement id: 432 */
    assert (l_762 == &p_53);
    (***l_775) = ((uint16_t)(p_52 > (l_765 != &l_766)) >> (uint16_t)(((int16_t)((((0U ^ ((int16_t)p_53 - (int16_t)__builtin_parity(p_51))) ^ ((l_773 == &l_774) <= 0xEF453AE2)) < 0x971F820E) | 0x041E) + (int16_t)0xE2B4) >= (*****l_773)));
lbl_826:
    if (func_57(p_53, p_51, (func_68(l_776, ((uint32_t)((**l_773) != (void*)0) - (uint32_t)(***l_775)), (**l_774), (*****l_773), (*l_762)) | (**l_761))))
    { /* block id: 434 */
        int16_t l_781 = 0x5C0A;
        int32_t *l_799 = (void*)0;
lbl_800:
        if ((((((int32_t)l_781 % (int32_t)(l_782 | ((((uint16_t)0U >> (uint16_t)((((int16_t)(((p_51 > p_51) != (0xE027 ^ p_52)) & ((uint16_t)(4294967286U ^ (-1)) + (uint16_t)6)) << (int16_t)12) || l_781) && p_52)) < p_52) > l_781))) != (**l_761)) & l_781) && 4294967288U))
        { /* block id: 435 */
            struct S1 **** const *l_794 = (void*)0;
            struct S1 l_795 = {-268,0x20901C5E,16950,13,1410,{1,0x9864,138,3173,0x023E}};
            l_794 = l_789;
            /* statement id: 436 */
            assert (l_794 == &l_790);
            return l_795;
        }
        else
        { /* block id: 438 */
            const struct S0 *l_796 = &l_776;
            l_797 = l_796;
            /* statement id: 439 */
            assert (l_797 == &l_776);
            if (p_52)
                goto lbl_826;
        }
        /* facts after branching */
        assert (l_797 == &l_776);
        l_799 = (void*)0;
        if (l_776.f2)
            goto lbl_800;
    }
    else
    { /* block id: 443 */
        uint16_t l_803 = 65535U;
        struct S1 l_810 = {170,4294967293U,8419,8,-20,{-1,0x8AA3,74,10998,0x75BE}};
        struct S0 **l_821 = &l_768;
        (**l_775) = (**l_775);
        if (((((uint16_t)p_53 + (uint16_t)l_803) ^ (*****l_773)) ^ ((int16_t)((void*)0 == (**l_765)) + (int16_t)((**l_765) != (*l_766)))))
        { /* block id: 445 */
            int32_t l_807 = 0xEA76C295;
            int32_t *l_806 = &l_807;
            float l_809 = (-0x1.Cp+1);
            float *l_808 = &l_809;
            l_806 = l_806;
            (*l_808) = l_803;
        }
        else
        { /* block id: 448 */
            return l_810;
        }
        for (l_776.f1 = 0; (l_776.f1 >= 32); l_776.f1 += 5)
        { /* block id: 453 */
            uint32_t l_813 = 0xE05505A8;
            float l_825 = 0x0.6p+1;
            float *l_824 = &l_825;
            (****l_774) = 0;
            if (l_810.f5.f3)
                goto lbl_826;
            (*l_824) = (l_813 >= ((float)p_52 - (float)(((float)__builtin_bswap32(p_53) + (float)l_810.f3) == __builtin_popcountl(((int32_t)(~__builtin_ctzl(((**l_765) != l_821))) % (int32_t)(-(uint32_t)(~0x5D78)))))));
            (**l_775) = &p_53;
        }
    }
    (****l_773) = (***l_774);
    return l_827;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_57(int32_t  p_58, int32_t  p_59, int32_t  p_60)
{ /* block id: 38 */
    const int32_t l_64 = 1;
    const int32_t *l_63 = &l_64;
    const int32_t **l_62 = &l_63;
    int32_t l_66 = 0x46114AC9;
    struct S0 l_74 = {0,6U,240,6917,0x262C};
    int32_t *l_88 = &l_66;
    int32_t **l_87 = &l_88;
    const int32_t *l_604 = &l_66;
    int32_t *l_758 = &l_66;
    (*l_62) = (void*)0;
    /* statement id: 39 */
    assert (l_63 == 0);
    l_66 = (+0x3.Cp+1);
    if (((((((((-(uint32_t)p_59) != func_68(l_74, (&l_63 != &l_63), func_75(func_79((&l_63 == &l_63), func_83(p_59, &l_66, l_87), (*l_87)), (*l_87), l_604), p_60, p_58)) == p_58) == 0U) > p_60) > 0x02123E1A) || p_58) == 0))
    { /* block id: 381 */
        (*l_87) = &p_58;
        /* statement id: 382 */
        assert (l_88 == &p_58);
        (*l_62) = &p_58;
        /* statement id: 383 */
        assert (l_63 == &p_58);
        (*l_88) = p_59;
        return p_59;
    }
    else
    { /* block id: 386 */
        int16_t l_691 = (-10);
        int32_t l_713 = 0;
        int32_t ** const l_726 = &l_88;
        struct S0 l_743 = {0,0x4A55,140,6064,1U};
        struct S1 **l_745 = (void*)0;
        uint32_t l_750 = 0x4E2C6746;
        struct S1 ***l_752 = &l_745;
        struct S1 ****l_751 = &l_752;
        for (p_58 = (-28); (p_58 < 1); p_58 += 1)
        { /* block id: 389 */
            struct S0 *l_683 = &l_74;
            struct S0 **l_682 = &l_683;
            struct S0 ***l_681 = &l_682;
            int32_t l_687 = 0xBF2B9FAB;
            const struct S1 ***l_698 = (void*)0;
            int16_t l_706 = 0x7E9A;
            for (l_74.f1 = 0; (l_74.f1 < 23); ++l_74.f1)
            { /* block id: 392 */
                int32_t l_675 = 0x3B9761D4;
                for (l_74.f4 = (-11); (l_74.f4 == 9); l_74.f4 += 2)
                { /* block id: 395 */
                    struct S0 *l_680 = &l_74;
                    struct S0 **l_679 = &l_680;
                    struct S0 ***l_678 = &l_679;
                    const int32_t l_686 = 0x7DA3E7CD;
                    const int32_t l_688 = 0xF3CB65B7;
                    float l_690 = 0xA.4306BCp-16;
                    float *l_689 = &l_690;
                    (*l_689) = ((float)p_59 + (float)((((((((float)((func_95(l_675) > 0x6.48BA2Dp-40) >= ((((float)((((((-0x10.Bp-1) <= p_58) >= (l_678 == l_681)) == ((float)l_686 - (float)p_58)) < (-0x1.Dp+1)) >= p_58) + (float)l_687) == p_58) < 0x5.4E6CF9p+20)) - (float)p_58) != 0x8.77EC3Dp+45) <= l_686) <= p_59) != (-0x7.Ep+1)) < p_59) <= l_688));
                }
            }
            (**l_87) = l_687;
            if ((l_691 < ((int16_t)((uint16_t)((uint16_t)(l_698 != l_698) - (uint16_t)((int16_t)((((*l_88) > (((int16_t)(0 && (((-(uint32_t)((int16_t)p_59 >> (int16_t)11)) < 0xAAE1EDD3) < (l_691 >= ((0x8375 < (-1)) <= 1U)))) + (int16_t)(*l_604)) & p_58)) & p_60) | p_59) + (int16_t)l_706)) >> (uint16_t)2) << (int16_t)13)))
            { /* block id: 400 */
                int16_t l_709 = 0x4DF3;
                int32_t l_725 = (-3);
                for (p_59 = 0; (p_59 > (-19)); --p_59)
                { /* block id: 403 */
                    const int16_t l_710 = 4;
                    float l_721 = 0x0.CA34DFp+32;
                    float *l_720 = &l_721;
                    int32_t l_722 = 0x776CF44E;
                    (*l_720) = (l_709 < (((l_710 <= l_710) > p_58) > ((p_59 > (((float)l_713 - (float)((float)func_95((*l_88)) - (float)__builtin_ffs(((int16_t)(((int16_t)l_706 << (int16_t)7) != p_59) >> (int16_t)15)))) <= (-0x5.Fp-1))) == l_691)));
                    l_722 = (p_59 > (-0x1.Fp-1));
                    for (l_691 = (-20); (l_691 <= 28); l_691++)
                    { /* block id: 408 */
                        l_725 = l_709;
                        if (l_687)
                            break;
                    }
                }
            }
            else
            { /* block id: 413 */
                int32_t l_729 = (-2);
                struct S0 l_736 = {-0,0x3672,189,4350,1U};
                (**l_87) = func_68((*l_683), p_60, l_726, (*l_88), p_60);
                (**l_726) = 0xC.46500Fp-52;
                (**l_726) = ((((int32_t)l_729 + (int32_t)(__builtin_ffs((**l_726)) | ((uint16_t)(((uint32_t)0xFBC524AC - (uint32_t)(((**l_726) && (((uint32_t)func_68(l_736, p_58, &l_88, p_60, p_60) - (uint32_t)1U) | p_59)) | p_60)) ^ (*l_604)) << (uint16_t)2))) ^ (**l_726)) < 0xCB5AAAA6);
                (*l_62) = &p_58;
                /* statement id: 417 */
                assert (l_63 == &p_58);
            }
            for (p_59 = 0; (p_59 <= (-8)); p_59 -= 3)
            { /* block id: 421 */
                int32_t ** const l_744 = &l_88;
                struct S1 *****l_753 = (void*)0;
                struct S1 * const *l_757 = (void*)0;
                struct S1 * const **l_756 = &l_757;
                struct S1 * const ***l_755 = &l_756;
                struct S1 * const ****l_754 = &l_755;
                (*l_88) = ((uint16_t)((uint32_t)(func_68(l_743, p_58, l_744, (((l_745 != (void*)0) || (((uint16_t)p_60 << (uint16_t)15) & ((0U || ((int16_t)(p_58 != func_68(l_743, p_59, &l_88, l_750, (**l_87))) % (int16_t)p_59)) && p_60))) >= 0U), (**l_726)) && 1U) - (uint32_t)4294967291U) % (uint16_t)p_58);
                (*l_754) = l_751;
                /* statement id: 423 */
                assert (l_755 == &l_752);
                if ((**l_87))
                    break;
            }
        }
        /* facts after for loop */
        assert (l_63 == &p_58 || l_63 == 0);
        (*l_62) = (*l_62);
        (*l_87) = l_758;
    }
    /* facts after branching */
    assert (l_63 == &p_58 || l_63 == 0);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_68(struct S0  p_69, uint16_t  p_70, int32_t ** const  p_71, uint16_t  p_72, const uint16_t  p_73)
{ /* block id: 378 */
    int32_t l_661 = (-1);
    float *l_662 = (void*)0;
    float l_664 = 0x8.Fp+1;
    float *l_663 = &l_664;
    (*l_663) = l_661;
    return l_661;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_75(const int32_t ** p_76, int32_t * p_77, const int32_t * p_78)
{ /* block id: 351 */
    int32_t l_605 = 1;
    struct S0 *****l_608 = (void*)0;
    int32_t *l_648 = &l_605;
    int32_t **l_647 = &l_648;
    int32_t ***l_646 = &l_647;
    int32_t ****l_645 = &l_646;
    int32_t **l_659 = &l_648;
    int32_t **l_660 = (void*)0;
    for (l_605 = 24; (l_605 >= (-6)); l_605--)
    { /* block id: 354 */
        struct S1 ****l_628 = (void*)0;
        int32_t l_642 = (-8);
        struct S0 *l_651 = (void*)0;
        struct S0 **l_650 = &l_651;
        struct S0 ***l_649 = &l_650;
        struct S0 ****l_652 = (void*)0;
        struct S0 ** const *l_654 = &l_650;
        struct S0 ** const **l_653 = &l_654;
        struct S1 l_656 = {-170,0x1700FE04,25080,5,526,{-1,0xB3E8,64,1319,0x6382}};
        struct S1 * const l_655 = &l_656;
        struct S1 *l_658 = &l_656;
        struct S1 **l_657 = &l_658;
        if ((l_608 != (void*)0))
        { /* block id: 355 */
            int32_t l_609 = (-1);
            struct S1 l_615 = {-110,0x1C2F4870,6612,13,1202,{-0,0U,22,7170,4U}};
            struct S1 *l_614 = &l_615;
            struct S1 **l_613 = &l_614;
            struct S1 ***l_612 = &l_613;
            int32_t *l_632 = (void*)0;
            int32_t **l_631 = &l_632;
            struct S1 *l_633 = (void*)0;
            for (l_609 = 0; (l_609 <= 17); l_609++)
            { /* block id: 358 */
                struct S1 ****l_616 = &l_612;
                (*l_616) = l_612;
                for (l_615.f5.f1 = 0; (l_615.f5.f1 == 27); l_615.f5.f1 += 7)
                { /* block id: 362 */
                    int16_t l_623 = (-5);
                    (*p_77) = (((void*)0 == &p_76) < ((uint16_t)((int16_t)l_623 << (int16_t)(((uint16_t)((int16_t)(l_628 != &l_612) << (int16_t)l_605) >> (uint16_t)l_623) != (((int32_t)(*p_78) + (int32_t)l_605) >= 0x3779))) + (uint16_t)0xCE73));
                }
            }
            (*l_631) = &l_609;
            /* statement id: 366 */
            assert (l_632 == &l_609);
            (*l_613) = l_633;
            /* statement id: 367 */
            assert (l_614 == 0);
            (*l_632) = l_605;
        }
        else
        { /* block id: 369 */
            int32_t *l_635 = &l_605;
            int32_t **l_634 = &l_635;
            const struct S0 l_644 = {1,0x868F,100,2522,0U};
            const struct S0 *l_643 = &l_644;
            (*l_634) = &l_605;
            l_642 = ((uint32_t)(*l_635) + (uint32_t)((int16_t)(l_605 <= __builtin_clz(l_605)) - (int16_t)(((l_642 <= (l_643 != &l_644)) != ((void*)0 != l_645)) <= l_642)));
            (*p_77) = (**l_647);
        }
        (*l_653) = l_649;
        (*l_657) = l_655;
    }
    return l_660;
    /* statement id: 377 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t ** func_79(const uint32_t  p_80, int32_t ** p_81, int32_t * p_82)
{ /* block id: 52 */
    int32_t l_105 = 0x517126B2;
    const int32_t *l_112 = &l_105;
    const int32_t **l_111 = &l_112;
    const int32_t **l_122 = &l_112;
    const int32_t **l_123 = &l_112;
    const int32_t **l_124 = &l_112;
    int32_t l_153 = 7;
    int32_t *l_172 = &l_105;
    int32_t **l_171 = &l_172;
    int32_t ***l_170 = &l_171;
    int32_t **** const l_169 = &l_170;
    const int16_t l_177 = 0x6881;
    const int32_t **l_197 = &l_112;
    struct S1 l_217 = {140,4294967291U,26060,1,-1379,{1,6U,166,7632,0x0963}};
    struct S1 *l_216 = &l_217;
    uint32_t l_272 = 6U;
    const int32_t **l_297 = (void*)0;
    const int32_t ***l_321 = &l_197;
    struct S0 *l_337 = &l_217.f5;
    const int32_t **l_350 = &l_112;
    const int32_t **l_351 = &l_112;
    const int32_t **l_356 = &l_112;
    int32_t l_434 = (-3);
    struct S0 **l_526 = &l_337;
    struct S0 ***l_525 = &l_526;
    struct S0 ****l_524 = &l_525;
    struct S0 *****l_523 = &l_524;
    const int32_t **l_602 = &l_112;
    const int32_t **l_603 = (void*)0;
    return l_603;
    /* statement id: 350 */
    //assert (func_79_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_83(int16_t  p_84, int32_t * p_85, int32_t ** p_86)
{ /* block id: 41 */
    int32_t l_91 = 0x218D362E;
    float l_99 = 0xA.5D9662p-35;
    float *l_98 = &l_99;
    int32_t *l_101 = (void*)0;
    int32_t **l_100 = &l_101;
    int32_t **l_102 = &l_101;
    int32_t **l_103 = &l_101;
    int32_t **l_104 = (void*)0;
    for (p_84 = 20; (p_84 <= (-5)); p_84--)
    { /* block id: 44 */
        struct S1 l_94 = {-211,1U,5778,5,-412,{1,65527U,62,9531,65535U}};
        struct S1 *l_93 = &l_94;
        struct S1 **l_92 = &l_93;
        l_91 = (*p_85);
        (*l_92) = (void*)0;
        /* statement id: 46 */
        assert (l_93 == 0);
    }
    (*l_98) = func_95(l_91);
    return l_104;
    /* statement id: 51 */
    //assert (func_83_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_95(int32_t  p_96)
{ /* block id: 48 */
    int32_t l_97 = 0xE6827465;
    return l_97;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_32();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 331
   depth: 1, occurrence: 9
   depth: 2, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 2
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 94
breakdown:
   indirect level: 0, occurrence: 20
   indirect level: 1, occurrence: 24
   indirect level: 2, occurrence: 13
   indirect level: 3, occurrence: 8
   indirect level: 4, occurrence: 14
   indirect level: 5, occurrence: 15
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 36
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 38
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 56

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 224
   depth: 2, occurrence: 34
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 10, occurrence: 4
   depth: 11, occurrence: 4
   depth: 12, occurrence: 2
   depth: 13, occurrence: 2
   depth: 14, occurrence: 4
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 374

XXX times a variable address is taken: 356
XXX times a pointer is dereferenced on RHS: 256
breakdown:
   depth: 1, occurrence: 118
   depth: 2, occurrence: 107
   depth: 3, occurrence: 20
   depth: 4, occurrence: 8
   depth: 5, occurrence: 3
XXX times a pointer is dereferenced on LHS: 203
breakdown:
   depth: 1, occurrence: 165
   depth: 2, occurrence: 18
   depth: 3, occurrence: 10
   depth: 4, occurrence: 10
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 21
XXX times a pointer is compared with another pointer: 20
XXX times a pointer is qualified to be dereferenced: 922

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 399
   level: 2, occurrence: 199
   level: 3, occurrence: 42
   level: 4, occurrence: 39
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 243
XXX number of pointers point to scalars: 92
XXX number of pointers point to structs: 39
XXX percent of pointers has null in alias set: 23
XXX average alias set size: 1.13

XXX times a non-volatile is read: 1543
XXX times a non-volatile is write: 570
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 5

XXX stmts: 185
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 30
   depth: 2, occurrence: 40
   depth: 3, occurrence: 28
   depth: 4, occurrence: 28
   depth: 5, occurrence: 31

XXX percentage a fresh-made variable is used: 15.2
XXX percentage an existing variable is used: 84.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

