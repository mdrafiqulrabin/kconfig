/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2019363307
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   int16_t  f1;
   uint32_t  f2;
   uint32_t  f3;
   uint32_t  f4;
};

union U1 {
   uint32_t  f0;
   uint16_t  f1;
   uint16_t  f2;
   signed f3 : 2;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_6 = 0x3D2D672A;
static int16_t g_132 = 0x9AAC;
static struct S0 g_135 = {0x5444,1,4294967291U,0x7223651B,0x0E570C89};
static uint16_t g_136 = 65535U;
static int32_t g_169 = 0x672FDCC5;
static uint32_t g_177 = 4294967295U;
static int32_t g_195 = 0xBA490677;
static union U1 g_208 = {0U};
static uint32_t g_283 = 0x3DF1D13F;
static int32_t g_563 = 0x0CC3882F;
static union U1 g_564 = {0x84B470FF};
static struct S0 g_574 = {0,0,0x4F648BA4,4294967288U,0xD4B4474A};
static uint32_t g_611 = 0x6DABD693;


/* --- FORWARD DECLARATIONS --- */
static union U1  func_26(void);
static uint16_t  func_37(int32_t  p_38, int32_t  p_39);
static int32_t  func_43(uint16_t  p_44, int16_t  p_45, union U1  p_46, union U1  p_47, uint32_t  p_48);
static uint32_t  func_57(struct S0  p_58, uint32_t  p_59);
static struct S0  func_60(uint32_t  p_61, uint32_t  p_62, int32_t  p_63, uint16_t  p_64);
static uint32_t  func_65(struct S0  p_66, int32_t  p_67, uint32_t  p_68, int16_t  p_69);
static int16_t  func_77(struct S0  p_78, uint16_t  p_79, int32_t  p_80);
static struct S0  func_81(uint32_t  p_82, int16_t  p_83, uint16_t  p_84, uint16_t  p_85, uint32_t  p_86);
static int16_t  func_89(union U1  p_90, union U1  p_91, union U1  p_92, uint32_t  p_93);
static union U1  func_95(int32_t  p_96, uint32_t  p_97, int32_t  p_98);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_135.f2 g_135.f4 g_135.f3 g_135.f1 g_132 g_135 g_136 g_169 g_208 g_283 g_208.f1 g_177 g_195 g_208.f2 g_208.f3 g_563 g_564.f2 g_564.f3 g_574.f2 g_611 g_564.f0 g_574.f4 g_574.f3 g_574.f1
 * writes: g_132 g_135 g_136 g_169 g_177 g_195 g_208.f1 g_208.f3 g_208.f2 g_574 g_564.f3
 */
static union U1  func_26(void)
{ /* block id: 36 */
    uint32_t l_27 = 1U;
    int32_t l_28 = 8;
    int16_t l_40 = 0x0CD9;
    uint16_t l_635 = 8U;
    union U1 l_647 = {0xE5A85E44};
    struct S0 l_659 = {0x858B,0xAFE8,4294967295U,0xCCF1ED32,0x698B40CA};
    l_28 = l_27;
    if (((int16_t)(g_6 < (l_28 != ((uint32_t)4294967295U + (uint32_t)((uint16_t)(((uint16_t)((func_37(l_40, (~g_6)) <= (l_27 || (g_283 ^ ((int32_t)(l_27 || l_28) - (int32_t)g_611)))) <= l_27) << (uint16_t)0) & 0) + (uint16_t)g_283)))) >> (int16_t)14))
    { /* block id: 315 */
        union U1 l_631 = {4294967287U};
        return l_631;
    }
    else
    { /* block id: 317 */
        int16_t l_636 = 0x9037;
        union U1 l_641 = {0U};
        union U1 l_648 = {7U};
        uint32_t l_669 = 4294967289U;
        int32_t l_683 = (-5);
        struct S0 l_693 = {1,-8,2U,0xE91FF2FD,9U};
        for (g_169 = (-12); (g_169 > 26); g_169 += 9)
        { /* block id: 320 */
            int32_t l_634 = 0x88A5C559;
            g_195 = g_574.f2;
        }
        if ((-(uint32_t)(0x3DB2 != (l_635 ^ ((int32_t)l_636 + (int32_t)((g_283 || (g_136 >= (l_28 >= ((uint16_t)0U << (uint16_t)2)))) != (func_89(l_647, l_648, l_648, l_648.f3) & l_635)))))))
        { /* block id: 323 */
            int16_t l_651 = (-1);
            uint16_t l_654 = 1U;
            struct S0 l_658 = {2,0,0x6C8B4747,0x39C1E188,3U};
            int32_t l_660 = (-6);
            g_135 = func_60(g_574.f4, ((((uint16_t)l_651 << (uint16_t)3) | (l_647.f2 != l_648.f2)) <= l_651), g_135.f3, g_6);
            if ((65531U & ((int32_t)g_135.f4 % (int32_t)(0x7D2E75FB & l_636))))
            { /* block id: 325 */
                int16_t l_655 = 0;
                l_655 = l_654;
            }
            else
            { /* block id: 327 */
                uint16_t l_680 = 1U;
                for (g_574.f3 = 0; (g_574.f3 <= 3); g_574.f3 += 1)
                { /* block id: 330 */
                    l_659 = l_658;
                }
                l_28 = l_658.f0;
                l_660 = 0x942E9EA7;
                g_574 = func_60((0x5B35 <= ((((((uint32_t)((int16_t)((((uint16_t)(l_669 == ((int32_t)((uint16_t)0U << (uint16_t)((!(!(((uint16_t)0x3E4A << (uint16_t)l_658.f2) > ((int16_t)((4294967286U || l_680) != ((int32_t)g_135.f0 + (int32_t)(4294967295U > g_135.f1))) << (int16_t)11)))) == l_680)) - (int32_t)0)) >> (uint16_t)g_135.f4) && 0x3857) ^ g_564.f3) >> (int16_t)g_208.f3) + (uint32_t)l_658.f4) < 65531U) == l_680) || g_574.f3) == l_654)), g_564.f3, g_135.f1, l_683);
            }
            return l_648;
        }
        else
        { /* block id: 338 */
            int32_t l_684 = (-1);
            g_195 = func_57(l_659, (l_684 < g_195));
            l_647.f3 = l_648.f3;
        }
        l_648.f3 = (g_574.f3 | ((uint32_t)l_641.f2 - (uint32_t)l_648.f3));
        l_693 = func_81(g_135.f4, l_641.f1, (l_659.f3 <= g_611), g_169, g_135.f0);
    }
    l_647.f3 = g_574.f1;
    return l_647;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_135.f2 g_135.f4 g_135.f3 g_135.f1 g_132 g_135 g_136 g_169 g_208 g_283 g_208.f1 g_177 g_195 g_208.f2 g_208.f3 g_563 g_564.f2 g_564.f3 g_574.f2 g_611 g_564.f0
 * writes: g_132 g_135 g_136 g_169 g_177 g_195 g_208.f1 g_208.f3 g_208.f2 g_574 g_564.f3
 */
static uint16_t  func_37(int32_t  p_38, int32_t  p_39)
{ /* block id: 38 */
    uint16_t l_42 = 65532U;
    union U1 l_433 = {0xF9C56E4C};
    int32_t l_447 = 0x3A9EEF86;
    struct S0 l_468 = {-8,0xDEE2,8U,0xC474838F,4294967293U};
    uint16_t l_507 = 1U;
    int32_t l_566 = 0x69366429;
    int16_t l_580 = (-1);
    uint32_t l_620 = 1U;
    int32_t l_628 = 0x8B243DF2;
    if (l_42)
    { /* block id: 39 */
        uint32_t l_56 = 0xA70A1EE3;
        struct S0 l_70 = {1,-2,0x1837DEF5,0x9BA4AEFC,4294967294U};
        union U1 l_94 = {1U};
        int32_t l_439 = 9;
        int16_t l_448 = 1;
        uint32_t l_500 = 1U;
        uint32_t l_533 = 0x8486F6E2;
        uint16_t l_541 = 0x84AD;
        int32_t l_565 = 0x38AE903E;
        int16_t l_578 = 0x45CA;
        if (func_43((~((int32_t)g_6 + (int32_t)((((int16_t)((uint16_t)((((l_56 ^ (1 < func_57(func_60(func_65(l_70, ((((uint16_t)(((uint32_t)4294967286U - (uint32_t)(((int16_t)func_77(func_81((((((((int16_t)func_89(l_94, func_95(l_42, ((int32_t)((uint16_t)p_38 >> (uint16_t)((int16_t)((int16_t)(l_42 ^ 0x9A7C888B) >> (int16_t)g_6) << (int16_t)14)) % (int32_t)1U), g_6), l_94, p_39) + (int16_t)l_94.f2) <= p_39) < g_283) ^ g_208.f1) < 0) != p_38), g_283, p_38, g_6, l_42), p_39, p_39) - (int16_t)l_42) > g_283)) & g_283) >> (uint16_t)g_6) ^ p_38) || g_177), g_283, l_42), l_94.f3, p_39, p_38), g_283))) < g_283) ^ p_39) ^ g_283) << (uint16_t)g_283) + (int16_t)p_39) || g_177) >= g_6))), l_70.f0, l_94, l_94, p_39))
        { /* block id: 196 */
            return g_169;
        }
        else
        { /* block id: 198 */
            uint16_t l_422 = 0xEE43;
            struct S0 l_432 = {-1,0,0x4BE4A733,0x86779688,4294967295U};
            for (g_135.f2 = 0; (g_135.f2 == 48); g_135.f2 += 1)
            { /* block id: 201 */
                if (l_422)
                    break;
                return p_39;
            }
            p_38 = (__builtin_parityll(p_38) && ((uint16_t)func_89(func_95((((func_65(l_70, l_70.f2, (!((uint16_t)((-1) != (l_94.f0 ^ ((((uint32_t)__builtin_parity(l_42) + (uint32_t)(((uint32_t)func_57(l_432, g_169) - (uint32_t)g_195) && p_38)) & 0x6A5D62FF) < p_38))) % (uint16_t)0x3111)), l_42) && g_136) > l_432.f3) > 0x97CE6600), g_132, l_42), g_208, l_433, p_39) - (uint16_t)1));
            g_195 = __builtin_popcount(((int32_t)0x14B29B03 % (int32_t)func_77(g_135, l_433.f1, (__builtin_clzl((((g_135.f0 == __builtin_ctz((~(1U > g_177)))) == (-2)) & ((int16_t)l_439 + (int16_t)0xF49C))) & l_70.f0))));
            for (l_70.f4 = (-8); (l_70.f4 >= 55); l_70.f4 += 1)
            { /* block id: 209 */
                for (l_422 = 0; (l_422 == 34); l_422 += 9)
                { /* block id: 212 */
                    g_195 = p_38;
                }
            }
        }
        if ((((int32_t)l_433.f0 + (int32_t)(-(uint16_t)l_447)) != l_433.f1))
        { /* block id: 217 */
            uint16_t l_461 = 0x7B32;
            int32_t l_489 = 0;
            int32_t l_490 = 0x6EC2F027;
            struct S0 l_501 = {0x27F1,0x56DC,0x6E57411B,4294967295U,0xAE903182};
            for (g_208.f2 = 0; (g_208.f2 < 26); g_208.f2 += 1)
            { /* block id: 220 */
                uint16_t l_474 = 0xD0C0;
                struct S0 l_491 = {1,-1,0x0EBD9503,0x42027B56,4294967289U};
                int16_t l_520 = 0x0F61;
            }
        }
        else
        { /* block id: 253 */
            uint32_t l_526 = 0xB5DCF8F3;
            uint16_t l_545 = 0xF9B7;
            if (g_177)
            { /* block id: 254 */
                uint16_t l_540 = 0U;
                g_195 = 0;
                for (l_468.f3 = 0; (l_468.f3 > 56); l_468.f3 += 5)
                { /* block id: 258 */
                    int32_t l_525 = 0x0395D43A;
                    l_433.f3 = (__builtin_parity(l_525) < (l_526 | g_135.f3));
                }
                for (l_468.f1 = 0; (l_468.f1 == (-3)); l_468.f1 -= 1)
                { /* block id: 263 */
                    if (g_208.f3)
                        break;
                }
                l_439 = (((uint32_t)g_135.f4 - (uint32_t)((((uint16_t)0x74C0 - (uint16_t)(g_169 < ((l_533 < ((((uint16_t)((((uint16_t)((uint16_t)(func_65(l_468, l_447, l_540, __builtin_clzl(g_169)) & l_541) >> (uint16_t)13) % (uint16_t)g_177) ^ g_135.f4) ^ l_526) + (uint16_t)g_177) | 0xEA4A) ^ p_39)) != g_135.f4))) != p_38) > g_135.f3)) ^ l_540);
            }
            else
            { /* block id: 267 */
                uint32_t l_546 = 4U;
                l_94.f3 = (3U & ((l_526 != 0x0F51) == (g_135.f1 < (p_38 >= ((uint32_t)(-(uint16_t)g_135.f1) - (uint32_t)(l_545 | l_545))))));
                l_70 = func_60(l_546, func_77(func_81(l_468.f2, ((uint32_t)l_468.f2 - (uint32_t)(l_433.f3 == ((int32_t)0xA105BE2C + (int32_t)((int16_t)__builtin_parity((g_6 >= ((uint16_t)p_38 % (uint16_t)g_6))) << (int16_t)g_169)))), g_177, g_6, g_135.f4), p_39, p_39), g_132, g_132);
            }
            g_208.f3 = 0x4D8F7091;
            p_38 = l_56;
        }
        if (((int16_t)__builtin_parityl(((((((uint16_t)0x2569 + (uint16_t)(((l_468.f1 < ((int32_t)(l_56 && ((uint16_t)l_447 << (uint16_t)g_6)) + (int32_t)g_132)) <= 0U) && g_195)) & l_565) && g_563) | g_135.f2) & g_563)) >> (int16_t)0))
        { /* block id: 274 */
            g_135 = g_135;
        }
        else
        { /* block id: 276 */
            l_433.f3 = 0xE3B456FD;
            l_566 = g_136;
        }
        for (l_70.f4 = 0; (l_70.f4 == 8); l_70.f4 += 1)
        { /* block id: 282 */
            uint32_t l_572 = 1U;
            int16_t l_573 = 3;
            int32_t l_575 = 1;
            int32_t l_579 = 1;
            uint32_t l_597 = 4294967295U;
            if (((uint16_t)(~(p_38 == l_572)) >> (uint16_t)8))
            { /* block id: 283 */
                g_574 = func_81(g_135.f1, l_573, g_564.f2, l_433.f3, p_38);
            }
            else
            { /* block id: 285 */
                uint16_t l_599 = 1U;
                struct S0 l_600 = {0x7D92,2,0U,4U,4294967295U};
                l_575 = 0x0F30A380;
                if (p_39)
                    break;
                for (g_135.f0 = 0; (g_135.f0 != 0); g_135.f0 += 4)
                { /* block id: 290 */
                    int16_t l_598 = 6;
                    if (g_135.f0)
                    { /* block id: 291 */
                        l_578 = p_39;
                        return g_135.f4;
                    }
                    else
                    { /* block id: 294 */
                        uint32_t l_586 = 1U;
                        l_433.f3 = l_579;
                        p_39 = (l_580 <= 6U);
                        if (p_39)
                            continue;
                        g_564.f3 = (((int32_t)((((int16_t)(~(0x0029 && l_586)) % (int16_t)p_39) >= ((int16_t)p_38 % (int16_t)(((int16_t)((int16_t)g_177 + (int16_t)(0x13F73EAE == (p_38 == (((int32_t)(((int16_t)((g_564.f3 & p_39) || p_39) >> (int16_t)l_597) & 0xA705) + (int32_t)g_135.f4) && 0xD8DC48BA)))) << (int16_t)l_598) || g_195))) || p_38) + (int32_t)l_599) ^ 0xAA6057FF);
                    }
                    l_600 = g_135;
                    p_38 = ((int16_t)0 << (int16_t)((((uint32_t)(~((uint16_t)(g_574.f2 > (func_65(func_60((1U < p_38), (-(int16_t)g_169), g_135.f0, ((int32_t)g_611 + (int32_t)p_38)), p_38, l_598, g_574.f2) >= 4294967288U)) << (uint16_t)l_575)) % (uint32_t)p_39) >= 65535U) > p_39));
                    p_39 = (((g_195 < (!(1U >= ((uint16_t)g_177 << (uint16_t)g_195)))) < g_135.f1) | l_447);
                }
                return g_135.f3;
            }
            if (p_39)
                continue;
        }
    }
    else
    { /* block id: 308 */
        g_208.f3 = __builtin_ffs(((int16_t)(((0xBF98 <= g_208.f1) && 1U) ^ (l_468.f3 ^ __builtin_bswap32(p_38))) + (int16_t)g_564.f2));
        g_574 = func_60((!p_39), ((uint16_t)g_135.f4 << (uint16_t)8), p_39, p_39);
    }
    l_468 = func_60(g_564.f2, l_620, (g_611 || l_566), ((-1) != (!((((uint16_t)((int32_t)(0x82272048 >= (4294967289U && (((0x9C64 & 0x06D0) | 0x56D2) >= 0x73064325))) % (int32_t)g_574.f2) << (uint16_t)11) >= l_628) != g_564.f0))));
    p_39 = ((0xBE37BB82 > p_38) | p_39);
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads : g_195 g_169 g_135.f2
 * writes: g_195 g_208.f3
 */
static int32_t  func_43(uint16_t  p_44, int16_t  p_45, union U1  p_46, union U1  p_47, uint32_t  p_48)
{ /* block id: 185 */
    uint32_t l_385 = 0x45C3CAEE;
    uint32_t l_398 = 0x43EF79BD;
    struct S0 l_399 = {2,-1,0xD10F8B98,0xEFF8BAF2,0xFB55635C};
    uint16_t l_400 = 65535U;
    struct S0 l_418 = {0x2518,-1,8U,0x77B43894,4294967295U};
    g_208.f3 = ((int32_t)((((int16_t)l_385 >> (int16_t)(((int32_t)((int16_t)(7U == (p_46.f0 <= ((uint16_t)((uint16_t)l_385 >> (uint16_t)9) + (uint16_t)((uint32_t)((uint32_t)__builtin_bswap32(l_398) - (uint32_t)((func_65(l_399, p_47.f3, l_385, g_195) && p_45) >= g_169)) + (uint32_t)p_46.f1)))) << (int16_t)g_135.f2) - (int32_t)0x5D49D633) < p_47.f2)) && l_399.f3) & 0xAE77) + (int32_t)l_400);
    for (l_399.f2 = (-25); (l_399.f2 != 45); l_399.f2 += 1)
    { /* block id: 189 */
        int32_t l_405 = 0xCE1E51FC;
        uint32_t l_417 = 0x2B65A340;
    }
    g_208.f3 = (~l_418.f2);
    return l_418.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_135.f1 g_135
 * writes: g_135
 */
static uint32_t  func_57(struct S0  p_58, uint32_t  p_59)
{ /* block id: 181 */
    uint32_t l_378 = 0x5D0225BC;
    int32_t l_379 = 1;
    int32_t l_380 = 0x9771C00C;
    l_380 = (((int16_t)(((p_58.f3 < ((0 | (l_378 && (l_379 > l_380))) >= (p_58.f1 != p_58.f4))) <= (l_380 && g_135.f1)) > 0x8D5531B2) % (int16_t)1) & 2U);
    g_135 = g_135;
    return l_380;
}


/* ------------------------------------------ */
/* 
 * reads : g_132 g_6 g_135.f2 g_177 g_135
 * writes: g_208.f3
 */
static struct S0  func_60(uint32_t  p_61, uint32_t  p_62, int32_t  p_63, uint16_t  p_64)
{ /* block id: 178 */
    int32_t l_353 = 0xD2AFDE5E;
    uint32_t l_375 = 0xD104157A;
    g_208.f3 = (!(((uint32_t)(l_353 & __builtin_ctzll((((uint16_t)((uint16_t)(((uint16_t)((uint16_t)(~p_63) % (uint16_t)((int16_t)((int32_t)0xF92BECF8 + (int32_t)((0 <= (((1U == (((((((0x3FBA52BC != ((uint16_t)((l_353 <= (((int16_t)0xBCF1 >> (int16_t)9) <= (((uint16_t)(l_375 && g_132) >> (uint16_t)p_61) && g_6))) < l_375) % (uint16_t)0xA293)) && l_353) & g_135.f2) == l_353) <= l_353) > p_63) <= 0xD3457CD9)) >= l_353) <= p_63)) >= 4294967295U)) + (int16_t)g_177)) << (uint16_t)g_132) < (-1)) - (uint16_t)l_375) >> (uint16_t)13) | l_375))) + (uint32_t)0x16BFC259) >= 0));
    return g_135;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_195
 */
static uint32_t  func_65(struct S0  p_66, int32_t  p_67, uint32_t  p_68, int16_t  p_69)
{ /* block id: 175 */
    uint32_t l_349 = 4294967295U;
    g_195 = ((uint16_t)(0x7EF37E61 ^ ((int16_t)l_349 + (int16_t)p_67)) >> (uint16_t)(p_66.f2 <= (-5)));
    return p_66.f4;
}


/* ------------------------------------------ */
/* 
 * reads : g_135.f4 g_135.f2
 * writes:
 */
static int16_t  func_77(struct S0  p_78, uint16_t  p_79, int32_t  p_80)
{ /* block id: 171 */
    int16_t l_327 = (-9);
    int32_t l_343 = 1;
    int32_t l_344 = 1;
    l_344 = ((((p_78.f0 ^ ((int16_t)((int16_t)((uint16_t)(-(uint32_t)p_78.f2) >> (uint16_t)p_78.f3) << (int16_t)((int16_t)l_327 << (int16_t)((!((((uint32_t)((l_327 | ((int16_t)((g_135.f4 < (g_135.f4 < ((uint32_t)(((int16_t)((uint16_t)((uint16_t)p_78.f3 % (uint16_t)l_327) >> (uint16_t)3) << (int16_t)l_327) && l_327) - (uint32_t)1))) | 0x216750B1) >> (int16_t)l_343)) >= g_135.f4) % (uint32_t)l_343) | p_78.f1) == 0x6245629C)) <= 1U))) + (int16_t)l_343)) | 0) > l_327) & (-3));
    l_344 = g_135.f2;
    return p_78.f3;
}


/* ------------------------------------------ */
/* 
 * reads : g_208.f1 g_135
 * writes: g_208.f1 g_135
 */
static struct S0  func_81(uint32_t  p_82, int16_t  p_83, uint16_t  p_84, uint16_t  p_85, uint32_t  p_86)
{ /* block id: 119 */
    union U1 l_296 = {1U};
    struct S0 l_301 = {0,-5,4294967292U,0xB91921AB,4294967295U};
    struct S0 l_317 = {0x6EFE,0x41CE,0x969E6188,0x7C297B86,0U};
    for (p_85 = 0; (p_85 >= 2); p_85 += 1)
    { /* block id: 122 */
        union U1 l_290 = {0x7FE89498};
        for (g_208.f1 = (-10); (g_208.f1 <= 18); g_208.f1 += 1)
        { /* block id: 125 */
            uint32_t l_297 = 0xB89557B5;
            struct S0 l_300 = {-6,0x0121,0U,0x33CC21D2,0x73083378};
            g_135 = g_135;
            for (p_83 = 0; (p_83 < (-6)); p_83 -= 3)
            { /* block id: 129 */
                union U1 l_295 = {0U};
            }
        }
        return l_301;
    }
    l_296.f3 = g_135.f2;
    for (l_301.f2 = (-26); (l_301.f2 > 47); l_301.f2 += 1)
    { /* block id: 164 */
        g_135 = l_301;
        l_296.f3 = ((g_135.f0 || 4294967293U) && p_83);
        l_296.f3 = l_301.f0;
        if (p_83)
            continue;
    }
    return l_317;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_135.f2
 * writes: g_195
 */
static int16_t  func_89(union U1  p_90, union U1  p_91, union U1  p_92, uint32_t  p_93)
{ /* block id: 115 */
    uint32_t l_281 = 0x1379AC75;
    int32_t l_282 = 0x97E8B93D;
    l_282 = ((int16_t)(((int32_t)0xAF67E15F + (int32_t)(-5)) | l_281) % (int16_t)l_281);
    g_195 = (p_92.f2 | g_6);
    return g_135.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_135.f2 g_135.f4 g_135.f3 g_135.f1 g_132 g_135 g_136 g_169 g_208
 * writes: g_132 g_135 g_136 g_169 g_177 g_195
 */
static union U1  func_95(int32_t  p_96, uint32_t  p_97, int32_t  p_98)
{ /* block id: 40 */
    uint16_t l_109 = 0x89C2;
    int32_t l_121 = 0xEFD82B3C;
    int32_t l_192 = (-9);
    p_98 = (((uint16_t)(4294967293U != (l_109 > ((int16_t)l_109 << (int16_t)p_97))) + (uint16_t)((int16_t)((int32_t)(p_98 <= (g_6 & g_6)) % (int32_t)0x8C043881) - (int16_t)((((~0x5A1655ED) & 0x451E) >= 0x629925D9) >= 4U))) | p_97);
    if ((g_6 == (g_6 == (p_97 < g_6))))
    { /* block id: 42 */
        uint16_t l_151 = 4U;
        int32_t l_165 = 0x42614109;
        struct S0 l_170 = {0x35BA,0x4518,0x71077703,6U,0x941ECE23};
        struct S0 l_173 = {0,0xF937,0xBA5FEA88,0xA45BD764,4294967295U};
        for (p_98 = 0; (p_98 > 3); p_98 += 1)
        { /* block id: 45 */
            int32_t l_131 = 0;
            int32_t l_133 = (-6);
            struct S0 l_159 = {0,0x7E4A,8U,0x31A92BC7,5U};
            if (p_96)
            { /* block id: 46 */
                struct S0 l_134 = {0x67D0,0xC541,0xD86053C1,0xB3F584DD,1U};
                g_132 = (((int16_t)p_98 << (int16_t)(l_121 && ((int16_t)g_6 + (int16_t)(4294967288U < (-(uint16_t)(((int16_t)(((uint16_t)(g_6 & (g_6 > p_97)) >> (uint16_t)12) && ((int16_t)4 - (int16_t)p_96)) << (int16_t)g_6) > l_131)))))) & g_6);
                l_133 = 0x81B78F42;
                g_135 = l_134;
                g_136 = (p_97 != g_135.f2);
            }
            else
            { /* block id: 51 */
                union U1 l_160 = {0xD0EF1DBD};
                struct S0 l_175 = {0x0BFB,0x3364,0xC4C281E2,0x56953674,9U};
                if (((uint16_t)l_109 << (uint16_t)(g_135.f4 | ((uint16_t)((int16_t)((int16_t)p_96 + (int16_t)g_135.f3) - (int16_t)((uint16_t)0x42C1 - (uint16_t)(p_96 > (((int32_t)(((int16_t)(l_151 | (0 >= ((uint16_t)((l_151 < 0U) != 0xED4F) >> (uint16_t)11))) << (int16_t)11) && 0xAE7F845C) - (int32_t)g_135.f1) >= g_135.f3)))) + (uint16_t)0x5F81))))
                { /* block id: 52 */
                    for (l_131 = 0; (l_131 == 27); l_131 += 6)
                    { /* block id: 55 */
                        union U1 l_158 = {0U};
                        return l_158;
                    }
                    l_133 = g_132;
                    l_159 = l_159;
                    l_159 = g_135;
                }
                else
                { /* block id: 61 */
                    int32_t l_162 = 0xE4FDE8E7;
                    struct S0 l_176 = {-1,9,1U,4294967295U,0x0D5DEC9E};
                    if ((l_109 | g_136))
                    { /* block id: 62 */
                        return l_160;
                    }
                    else
                    { /* block id: 64 */
                        l_162 = __builtin_bswap32((-(uint16_t)p_97));
                    }
                    if (p_96)
                    { /* block id: 67 */
                        int32_t l_168 = 0x50ADD41A;
                        g_169 = ((uint32_t)l_165 - (uint32_t)((((0xE2EA < (g_136 < p_97)) >= p_98) | ((int16_t)g_135.f2 - (int16_t)l_168)) && g_132));
                        if (g_135.f2)
                            continue;
                        g_135 = l_170;
                        if (p_98)
                            break;
                    }
                    else
                    { /* block id: 72 */
                        int16_t l_171 = 0xD215;
                        int32_t l_172 = 0xAA9519D3;
                        struct S0 l_174 = {0,1,0U,0xE3ED1035,0x0CCA696F};
                        l_160.f3 = ((1 | l_171) && 4294967295U);
                        l_172 = (g_132 & p_96);
                        l_174 = l_173;
                    }
                    l_176 = l_175;
                }
                g_177 = p_97;
                l_175 = l_175;
            }
            l_192 = ((p_97 & ((((((int16_t)(((uint16_t)6U >> (uint16_t)(l_109 <= ((int16_t)((int16_t)(((uint16_t)((uint32_t)1U % (uint32_t)l_121) << (uint16_t)15) < g_135.f1) + (int16_t)(p_96 != ((int16_t)p_96 >> (int16_t)14))) - (int16_t)p_96))) <= 0xAFDF5218) >> (int16_t)g_135.f4) != g_136) != l_159.f4) > p_96) ^ 0x0297)) && g_135.f2);
            g_195 = ((g_169 && (l_192 && g_136)) > ((int16_t)0 >> (int16_t)p_98));
        }
    }
    else
    { /* block id: 85 */
        int32_t l_239 = 0;
        int16_t l_251 = (-1);
        uint32_t l_272 = 0xFE489FF0;
        union U1 l_276 = {0xB63D1979};
        for (g_132 = 0; (g_132 >= (-13)); g_132 -= 1)
        { /* block id: 88 */
            uint16_t l_209 = 0x3AD3;
            int32_t l_240 = (-6);
            struct S0 l_273 = {0x014A,0xF549,0U,0xA12BF3FE,0x99F4FE02};
            p_98 = p_98;
        }
        p_98 = ((int16_t)l_272 % (int16_t)0x2286);
        return l_276;
    }
    return g_208;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_135.f0, "g_135.f0", print_hash_value);
    transparent_crc(g_135.f1, "g_135.f1", print_hash_value);
    transparent_crc(g_135.f2, "g_135.f2", print_hash_value);
    transparent_crc(g_135.f3, "g_135.f3", print_hash_value);
    transparent_crc(g_135.f4, "g_135.f4", print_hash_value);
    transparent_crc(g_136, "g_136", print_hash_value);
    transparent_crc(g_169, "g_169", print_hash_value);
    transparent_crc(g_177, "g_177", print_hash_value);
    transparent_crc(g_195, "g_195", print_hash_value);
    transparent_crc(g_283, "g_283", print_hash_value);
    transparent_crc(g_563, "g_563", print_hash_value);
    transparent_crc(g_564.f3, "g_564.f3", print_hash_value);
    transparent_crc(g_574.f0, "g_574.f0", print_hash_value);
    transparent_crc(g_574.f1, "g_574.f1", print_hash_value);
    transparent_crc(g_574.f2, "g_574.f2", print_hash_value);
    transparent_crc(g_574.f3, "g_574.f3", print_hash_value);
    transparent_crc(g_574.f4, "g_574.f4", print_hash_value);
    transparent_crc(g_611, "g_611", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 115
   depth: 1, occurrence: 27
XXX total union variables: 14

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 14
breakdown:
   indirect level: 0, occurrence: 14
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 35
XXX times a single bitfield on LHS: 21
XXX times a single bitfield on RHS: 19

XXX max expression depth: 59
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 25
   depth: 3, occurrence: 6
   depth: 4, occurrence: 5
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 26, occurrence: 1
   depth: 29, occurrence: 1
   depth: 33, occurrence: 1
   depth: 59, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 712
XXX times a non-volatile is write: 130
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 136
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 21
   depth: 2, occurrence: 26
   depth: 3, occurrence: 26
   depth: 4, occurrence: 15
   depth: 5, occurrence: 16

XXX percentage a fresh-made variable is used: 17.8
XXX percentage an existing variable is used: 82.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

