/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3137492052
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   signed f0 : 24;
};
#pragma pack(pop)

union U1 {
   int16_t  f0;
   uint32_t  f1;
   uint16_t  f2;
   unsigned f3 : 3;
   int32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static const int32_t  func_27(void);
static struct S0 * func_34(struct S0 * p_35);
static struct S0 * func_36(uint16_t  p_37);
static const int32_t * func_47(int32_t  p_48, union U1  p_49, uint8_t  p_50, int32_t * p_51);
static union U1  func_53(const union U1  p_54, uint32_t  p_55, uint32_t  p_56);
inline static const union U1  func_57(uint32_t  p_58, int32_t  p_59, uint16_t  p_60, const float  p_61);
static uint64_t  func_67(struct S0 * p_68, struct S0 * p_69);
static struct S0 * func_72(int32_t * p_73, int64_t  p_74, const struct S0 * p_75);
inline static const uint16_t  func_88(uint32_t  p_89, int16_t  p_90, struct S0 * p_91, uint16_t  p_92);
static struct S0 * func_93(uint8_t  p_94, uint32_t  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28 = (-4L);
    int32_t l_456 = 0x90F11FDCL;
    union U1 ***l_457 = (void*)0;
    struct S0 l_465 = {-1990};
    struct S0 *l_464 = &l_465;
    int64_t l_518 = 1L;
    uint32_t l_546 = 4294967287UL;
    uint16_t l_588 = 0x22E4L;
    int32_t *l_617 = (void*)0;
    int32_t l_618 = 0x2F437F50L;
    for (l_28 = 25; (l_28 < 0); --l_28)
    { /* block id: 39 */
        int32_t l_31 = 0xDFAD5BEFL;
        uint32_t l_33 = 18446744073709551610UL;
        struct S0 l_39 = {-112};
        struct S0 *l_38 = &l_39;
        int32_t *l_454 = (void*)0;
        int32_t ** const l_453 = &l_454;
        int32_t ** const *l_452 = &l_453;
        union U1 l_468 = {5L};
        const struct S0 ****l_512 = (void*)0;
        const struct S0 *****l_511 = &l_512;
        const uint8_t l_523 = 255UL;
        struct S0 l_529 = {-428};
        if (((l_31 <= (-1L)) && l_31))
        { /* block id: 40 */
            struct S0 *l_442 = &l_39;
            int32_t l_455 = 0xBC1A27FFL;
            union U1 l_463 = {0L};
            union U1 *l_462 = &l_463;
            union U1 * const *l_461 = &l_462;
            int32_t l_494 = (-10L);
            float l_503 = 0x3.E1AD20p-31;
            float *l_502 = &l_503;
            float **l_501 = &l_502;
            union U1 ****l_506 = &l_457;
            const struct S0 *****l_513 = &l_512;
            uint64_t l_524 = 0x3551652D02CCC271LL;
            if (((!l_33) ^ l_28))
            { /* block id: 41 */
                struct S0 *l_40 = &l_39;
                int32_t l_447 = 0x7D9147CCL;
                int32_t *l_478 = &l_455;
                l_442 = func_34(func_36((l_38 != l_40)));
                /* statement id: 245 */
                assert (l_442 == 0);
                l_456 = ((int16_t)(((int32_t)l_447 + (int32_t)((int64_t)(l_28 != (__builtin_ffs(((l_447 && ((int16_t)(l_452 != &l_453) << (int16_t)l_455)) == (l_28 > l_455))) <= 4294967295UL)) % (int64_t)l_455)) <= 18446744073709551615UL) >> (int16_t)1);
                l_457 = l_457;
                if (func_88((~0x6C08L), ((uint16_t)(((l_461 != (void*)0) >= l_456) <= l_456) >> (uint16_t)6), l_464, l_28))
                { /* block id: 248 */
                    int32_t l_466 = 0L;
                    const int32_t **l_469 = (void*)0;
                    int32_t **l_470 = &l_454;
                    int32_t *l_471 = (void*)0;
                    int32_t *l_472 = &l_31;
                    (*l_470) = func_47((l_466 & (+l_28)), l_468, l_463.f2, (**l_452));
                    (*l_472) = __builtin_parityl(l_455);
                    for (l_463.f1 = (-18); (l_463.f1 > 20); l_463.f1 += 2)
                    { /* block id: 253 */
                        (**l_452) = &l_447;
                        /* statement id: 254 */
                        assert (l_454 == &l_447);
                        if (l_463.f1)
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_454 == &l_447 || l_454 == 0);
                                        for (l_463.f2 = (-6); (l_463.f2 >= 14); ++l_463.f2)
                    { /* block id: 259 */
                        const int64_t l_477 = 6L;
                        if (l_463.f0)
                            break;
                        return l_477;
                    }
                    /* facts after for loop */
                                    }
                else
                { /* block id: 263 */
                    uint64_t l_482 = 0xEDEE33AE435E4F54LL;
                    const uint8_t l_483 = 1UL;
                    int32_t l_485 = 0L;
                    union U1 l_486 = {1L};
                    const int32_t *l_487 = &l_485;
                    struct S0 *l_490 = (void*)0;
                    uint32_t l_491 = 0x80EF4468L;
                    int32_t **l_508 = (void*)0;
                    int32_t **l_509 = &l_454;
                    l_478 = &l_447;
                    /* statement id: 264 */
                    assert (l_478 == &l_447);
                    for (l_456 = (-10); (l_456 < 22); l_456++)
                    { /* block id: 267 */
                        struct S0 **l_481 = &l_40;
                        (*l_481) = &l_39;
                        l_482 = (*l_478);
                        return l_483;
                    }
                    if (func_88(l_482, l_463.f0, &l_465, l_463.f0))
                    { /* block id: 272 */
                        uint32_t l_484 = 4UL;
                        (**l_452) = (*l_453);
                        l_485 = l_484;
                        l_487 = func_47((*l_478), l_486, l_28, &l_456);
                        /* statement id: 275 */
                        assert (l_487 == 0);
                    }
                    else
                    { /* block id: 276 */
                        float l_496 = 0xB.7730FFp+38;
                        float *l_495 = &l_496;
                        (*l_495) = ((float)func_88((*l_487), (*l_478), l_490, (*l_478)) / (float)((l_491 != ((float)func_67(&l_39, l_40) - (float)(-0x1.Bp-1))) < l_494));
                        if ((*l_478))
                            continue;
                    }
                    /* facts after branching */
                    assert (l_487 == &l_485 || l_487 == 0);
                    (*l_509) = func_47(((int16_t)__builtin_bswap64(((uint64_t)((void*)0 == l_501) % (uint64_t)(-1L))) / (int16_t)((int16_t)l_456 + (int16_t)(((void*)0 == l_506) || (l_28 < (!l_465.f0))))), (**l_461), l_455, &l_455);
                }
                /* facts after branching */
                assert (l_454 == &l_447 || l_454 == 0);
                                assert (l_478 == &l_447 || l_478 == &l_455);
            }
            else
            { /* block id: 282 */
                const int16_t l_510 = (-1L);
                return l_510;
            }
            /* facts after branching */
            assert (l_442 == 0);
            //assert (l_454 == dangling || l_454 == 0);
                        l_513 = l_511;
            if (((uint16_t)(((uint64_t)l_518 + (uint64_t)((uint32_t)(&l_468 != &l_468) / (uint32_t)0xE0CDC916L)) | ((uint64_t)l_523 - (uint64_t)(l_518 ^ (((l_524 != __builtin_popcountl(l_494)) == l_524) <= l_456)))) >> (uint16_t)6))
            { /* block id: 286 */
                (**l_452) = &l_456;
                /* statement id: 287 */
                assert (l_454 == &l_456);
            }
            else
            { /* block id: 288 */
                uint8_t l_532 = 0x16L;
                struct S0 *l_565 = &l_465;
                for (l_463.f4 = 0; (l_463.f4 >= 23); l_463.f4 += 1)
                { /* block id: 291 */
                    uint64_t l_535 = 0xD7D271EA74E1D7CELL;
                    struct S0 *l_547 = (void*)0;
                    struct S0 **l_556 = (void*)0;
                    struct S0 ***l_555 = &l_556;
                    struct S0 ****l_554 = &l_555;
                    uint64_t l_557 = 7UL;
                    l_455 = l_463.f2;
                    for (l_468.f4 = 0; (l_468.f4 >= (-19)); l_468.f4 -= 4)
                    { /* block id: 295 */
                        const uint8_t l_548 = 251UL;
                        int32_t *l_549 = &l_31;
                        struct S0 **l_552 = &l_38;
                        struct S0 ***l_551 = &l_552;
                        struct S0 ****l_550 = &l_551;
                        struct S0 *****l_553 = (void*)0;
                        (*l_464) = l_529;
                        (*l_549) = ((uint16_t)func_88(l_532, (((int64_t)l_535 + (int64_t)((uint64_t)l_28 % (uint64_t)((+(9UL ^ l_455)) || ((uint16_t)(-(uint16_t)func_88(((int16_t)(l_463.f1 ^ (((uint16_t)65533UL - (uint16_t)l_546) | (l_532 | l_532))) + (int16_t)0xFC0DL), l_532, l_547, l_463.f3)) - (uint16_t)l_548)))) && 0x9FB7L), &l_465, l_494) << (uint16_t)l_463.f1);
                        l_554 = l_550;
                        /* statement id: 298 */
                        assert (l_554 == &l_551);
                        (*l_502) = __builtin_popcountl(l_557);
                    }
                    /* facts after for loop */
                                        //assert (l_554 == dangling || l_554 == &l_555);
                    if (l_535)
                        break;
                    if ((l_463.f3 != ((uint16_t)(l_463.f1 && ((((int32_t)func_67(l_442, &l_465) + (int32_t)func_88(((~0L) | (((!(+l_532)) != ((l_535 && l_532) >= l_494)) && l_557)), l_535, l_565, l_28)) ^ l_455) && 1L)) - (uint16_t)l_532)))
                    { /* block id: 302 */
                        (*l_502) = ((float)((float)(-0x3.Ep-1) / (float)(l_532 > (((float)((-(float)((l_532 >= l_463.f1) > ((float)func_67(l_565, &l_39) + (float)(l_463.f1 >= l_535)))) != (-0x3.Ap+1)) + (float)l_532) >= l_456))) / (float)0x0.8p-1);
                    }
                    else
                    { /* block id: 304 */
                        int32_t *l_584 = &l_455;
                        (*l_584) = ((__builtin_popcountll(l_494) || ((uint16_t)(!func_67(&l_465, l_565)) >> (uint16_t)(((uint32_t)l_532 % (uint32_t)(l_546 || ((uint16_t)0x2E95L + (uint16_t)((uint32_t)l_532 % (uint32_t)(-8L))))) >= 1UL))) == l_465.f0);
                        return l_518;
                    }
                }
                /* facts after for loop */
                                (*l_453) = (void*)0;
                /* statement id: 309 */
                assert (l_454 == 0);
            }
            /* facts after branching */
            assert (l_454 == 0 || l_454 == &l_456);
            for (l_463.f2 = 0; (l_463.f2 >= 10); l_463.f2++)
            { /* block id: 313 */
                int16_t l_587 = (-1L);
                uint8_t l_600 = 0x9CL;
                int32_t *l_601 = (void*)0;
                int32_t **l_602 = &l_454;
                (**l_452) = &l_456;
                /* statement id: 314 */
                assert (l_454 == &l_456);
                (*l_453) = (void*)0;
                /* statement id: 315 */
                assert (l_454 == 0);
                if (l_587)
                    break;
                (*l_602) = func_47(l_588, func_57(l_456, ((int32_t)l_463.f0 % (int32_t)((((((uint16_t)((uint64_t)(l_546 == (((uint16_t)l_465.f0 - (uint16_t)l_587) != ((l_518 > (!((uint32_t)0xB7B4221DL + (uint32_t)l_28))) > l_455))) % (uint64_t)l_600) % (uint16_t)65535UL) ^ 0xD86730176DA533F5LL) | 1UL) ^ l_588) | l_600)), l_494, l_456), l_587, l_601);
            }
        }
        else
        { /* block id: 319 */
            float l_605 = 0xB.5F3E84p-57;
            int32_t l_611 = 0xC23C6D60L;
            for (l_468.f1 = (-7); (l_468.f1 > 49); l_468.f1 += 1)
            { /* block id: 322 */
                int32_t *l_606 = &l_31;
                (*l_606) = (l_456 || l_465.f0);
            }
            /* facts after for loop */
                        for (l_33 = 8; (l_33 != 44); l_33 += 1)
            { /* block id: 327 */
                int32_t *l_612 = &l_456;
                if (l_546)
                    break;
                (*l_38) = (*l_464);
                (*l_612) = ((uint64_t)l_588 - (uint64_t)l_611);
            }
        }
        /* facts after branching */
        assert (l_454 == 0 || l_454 == &l_456);
    }
    l_618 = (l_546 & (l_28 | ((uint32_t)((uint64_t)func_67(&l_465, &l_465) + (uint64_t)(l_518 != l_465.f0)) + (uint32_t)0xD23AF9D7L)));
    (*l_464) = (*l_464);
    return l_588;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_34(struct S0 * p_35)
{ /* block id: 236 */
    int32_t l_430 = 1L;
    uint8_t l_437 = 1UL;
    int32_t *l_438 = &l_430;
    int32_t **l_439 = &l_438;
    struct S0 l_441 = {-3511};
    struct S0 *l_440 = &l_441;
    for (l_430 = 0; (l_430 <= (-28)); --l_430)
    { /* block id: 239 */
        float l_434 = (-0x5.3p-1);
        float *l_433 = &l_434;
        (*l_433) = l_430;
    }
    (*l_438) = ((uint16_t)l_430 % (uint16_t)l_437);
    (*l_439) = &l_430;
    return p_35;
    /* statement id: 244 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_36(uint16_t  p_37)
{ /* block id: 42 */
    int16_t l_52 = 0xFAD7L;
    struct S0 l_71 = {-281};
    struct S0 *l_70 = &l_71;
    int32_t l_77 = 0L;
    int32_t *l_76 = &l_77;
    uint32_t l_205 = 0x7CE49567L;
    const union U1 * const **l_417 = (void*)0;
    union U1 l_422 = {0xA431L};
    union U1 *l_421 = &l_422;
    union U1 **l_420 = &l_421;
    union U1 ***l_419 = &l_420;
    union U1 ****l_418 = &l_419;
    struct S0 *l_423 = &l_71;
    struct S0 *l_424 = &l_71;
    struct S0 *l_425 = &l_71;
    struct S0 *l_426 = &l_71;
    struct S0 *l_427 = &l_71;
    struct S0 *l_428 = &l_71;
    struct S0 *l_429 = (void*)0;
    for (p_37 = 0; (p_37 > 25); p_37 += 6)
    { /* block id: 45 */
        int32_t **l_43 = (void*)0;
        int32_t l_46 = (-1L);
        int32_t *l_45 = &l_46;
        int32_t **l_44 = &l_45;
        const struct S0 *l_80 = (void*)0;
        const int32_t l_206 = 0xFD558AF5L;
        float l_312 = 0x0.8p-1;
        const int32_t *l_416 = &l_206;
        const int32_t **l_415 = &l_416;
        (*l_44) = (void*)0;
        /* statement id: 46 */
        assert (l_45 == 0);
        (*l_415) = func_47(l_52, func_53(func_57(((int16_t)((uint16_t)(-(uint64_t)func_67(l_70, func_72(l_76, ((uint16_t)((void*)0 == &l_45) << (uint16_t)10), l_80))) - (uint16_t)((uint16_t)(((((int32_t)((l_71.f0 ^ p_37) || 0L) / (int32_t)p_37) > (-1L)) ^ 0x6AE0A1952B13B08BLL) || p_37) >> (uint16_t)7)) / (int16_t)p_37), l_205, p_37, l_206), p_37, p_37), p_37, l_76);
        /* statement id: 231 */
        assert (l_416 == 0);
        if (p_37)
            break;
    }
    (*l_418) = l_417;
    /* statement id: 234 */
    assert (l_419 == 0);
    return l_429;
    /* statement id: 235 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t * func_47(int32_t  p_48, union U1  p_49, uint8_t  p_50, int32_t * p_51)
{ /* block id: 175 */
    const int64_t l_314 = 0xD1CF811F13ED7A34LL;
    struct S0 l_317 = {-120};
    int32_t l_339 = 0xAF8C5385L;
    int32_t *l_338 = &l_339;
    struct S0 **l_354 = (void*)0;
    union U1 *l_387 = (void*)0;
    const int32_t *l_404 = (void*)0;
    int32_t **l_410 = &l_338;
    int32_t ***l_409 = &l_410;
    uint32_t l_411 = 18446744073709551608UL;
    const int32_t *l_414 = (void*)0;
    if ((l_314 || (p_49.f0 || (((-(int16_t)l_314) | (((&p_51 != (void*)0) <= (+p_49.f0)) && p_50)) ^ (p_49.f0 == p_48)))))
    { /* block id: 176 */
        struct S0 *l_318 = (void*)0;
        struct S0 *l_319 = &l_317;
        (*l_319) = l_317;
    }
    else
    { /* block id: 178 */
        const uint8_t l_322 = 255UL;
        struct S0 *l_359 = &l_317;
        struct S0 **l_358 = &l_359;
        int16_t l_362 = (-1L);
        float ****l_372 = (void*)0;
        float *****l_371 = &l_372;
        int32_t *l_385 = &l_339;
        int32_t **l_408 = &l_338;
        int32_t ***l_407 = &l_408;
        float l_413 = 0x1.6p-1;
        float *l_412 = &l_413;
        for (p_49.f1 = 7; (p_49.f1 > 44); p_49.f1++)
        { /* block id: 181 */
            int16_t l_327 = 1L;
            struct S0 *l_353 = &l_317;
            struct S0 ** const l_352 = &l_353;
            float ** const ** const l_374 = (void*)0;
            float ** const ** const * const l_373 = &l_374;
            int32_t l_378 = 1L;
            union U1 l_393 = {1L};
            union U1 *l_392 = &l_393;
            if (l_322)
                break;
        }
        /* facts after for loop */
                (*l_412) = ((((float)(func_67((*l_358), (*l_358)) >= (*l_385)) - (float)(0x0.8p-1 > (*l_385))) >= (*l_385)) > func_88((l_407 != l_409), (***l_407), (*l_358), l_411));
    }
    return l_414;
    /* statement id: 230 */
    //assert (func_47_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_53(const union U1  p_54, uint32_t  p_55, uint32_t  p_56)
{ /* block id: 173 */
    union U1 l_313 = {0x0847L};
    return l_313;
    /* statement id: 174 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const union U1  func_57(uint32_t  p_58, int32_t  p_59, uint16_t  p_60, const float  p_61)
{ /* block id: 110 */
    uint16_t l_212 = 0xE460L;
    int32_t l_215 = 6L;
    int32_t *l_214 = &l_215;
    int32_t **l_213 = &l_214;
    float *l_216 = (void*)0;
    int16_t l_217 = 0x6255L;
    struct S0 l_225 = {-3922};
    struct S0 *l_224 = &l_225;
    int64_t l_230 = 1L;
    const union U1 l_311 = {0xFC27L};
    for (p_58 = 0; (p_58 >= 6); p_58++)
    { /* block id: 113 */
        int32_t l_209 = 0x0B7C7C06L;
        l_209 = func_88(l_209, __builtin_ctz((p_60 > __builtin_popcountll(p_58))), func_93(((int16_t)((1UL || (l_209 | p_58)) | ((p_60 < 0x3DCF354AL) ^ l_212)) % (int16_t)l_209), l_212), p_60);
    }
    (*l_213) = (void*)0;
    /* statement id: 116 */
    assert (l_214 == 0);
    if (((l_216 == (void*)0) > (l_217 | ((((uint16_t)(((int16_t)((((int16_t)func_67(l_224, &l_225) - (int16_t)func_88(p_58, ((int16_t)((((int16_t)((*l_213) != (*l_213)) << (int16_t)15) < l_230) != p_58) >> (int16_t)4), &l_225, p_58)) | p_60) != p_60) / (int16_t)3L) < p_59) << (uint16_t)2) || 8UL) ^ p_60))))
    { /* block id: 117 */
        struct S0 *l_233 = &l_225;
        int32_t l_234 = 1L;
        l_215 = ((uint64_t)__builtin_ffs(func_88(__builtin_bswap32(p_58), p_60, &l_225, (func_88(p_60, p_60, l_233, p_60) < l_234))) + (uint64_t)l_217);
    }
    else
    { /* block id: 119 */
        uint8_t l_239 = 0x38L;
        int32_t ***l_244 = &l_213;
        int32_t *l_245 = &l_215;
        float **l_273 = &l_216;
        uint32_t l_277 = 0xCB9365FCL;
        float ***l_299 = (void*)0;
        float ****l_298 = &l_299;
        (*l_245) = ((uint16_t)((uint16_t)p_59 - (uint16_t)l_239) % (uint16_t)((int16_t)((uint64_t)p_58 % (uint64_t)p_58) + (int16_t)(((void*)0 == l_244) <= (l_217 & l_239))));
        (**l_244) = (*l_213);
        for (p_59 = 11; (p_59 > 29); p_59 += 2)
        { /* block id: 124 */
            int32_t *l_248 = &l_215;
            struct S0 **l_251 = &l_224;
            int32_t l_264 = (-10L);
            float **l_274 = &l_216;
            float *l_310 = (void*)0;
            (*l_245) = (-1L);
            if ((((p_59 < (p_58 & ((**l_244) == l_248))) <= (((((uint16_t)((0x1F75EF2AL > p_58) == (&l_224 == l_251)) / (uint16_t)(p_58 & p_60)) >= (*l_245)) | p_59) | p_60)) > p_58))
            { /* block id: 126 */
                float **l_254 = &l_216;
                int32_t l_263 = 0x83223A29L;
                if (func_88((((((uint32_t)4294967287UL % (uint32_t)((*l_245) || (((void*)0 != l_254) == ((int16_t)(0x9869L >= func_88(((int16_t)(*l_248) - (int16_t)((int16_t)((&l_225 != (void*)0) != ((void*)0 == (*l_244))) >> (int16_t)l_263)), l_264, (*l_251), p_60)) >> (int16_t)11)))) ^ 0xA83D7FC5022FEA0ELL) <= l_230) && p_60), (*l_248), (*l_251), p_59))
                { /* block id: 127 */
                    float l_265 = 0xC.4F4898p-55;
                    int32_t l_266 = (-1L);
                    (*l_248) = l_266;
                    if (p_58)
                        continue;
                    (**l_244) = &l_263;
                    /* statement id: 130 */
                    assert (l_214 == &l_263);
                }
                else
                { /* block id: 131 */
                    (*l_213) = (*l_213);
                    (*l_213) = l_248;
                    /* statement id: 133 */
                    assert (l_214 == &l_215);
                    (**l_213) = (((p_58 && ((int64_t)p_60 / (int64_t)0x0BCE341315DE78DBLL)) == (&l_254 == &l_254)) >= ((int16_t)((int16_t)0L - (int16_t)(l_273 == l_274)) % (int16_t)(**l_213)));
                    if (p_59)
                        continue;
                }
                /* facts after branching */
                assert (l_214 == &l_215 || l_214 == &l_263);
                if (p_60)
                    break;
                //assert (l_214 == &l_215 || l_214 == dangling);
            }
            else
            { /* block id: 138 */
                int16_t l_278 = 0xCE7FL;
                float **l_295 = &l_216;
                const int32_t *l_296 = (void*)0;
                struct S0 l_309 = {-2918};
                if (((uint64_t)(func_67(func_93((l_273 == l_274), l_277), &l_225) && (&l_213 != (void*)0)) % (uint64_t)((l_278 ^ l_278) & 1UL)))
                { /* block id: 139 */
                    int32_t *l_279 = &l_215;
                    (**l_244) = l_279;
                    /* statement id: 140 */
                    assert (l_214 == &l_215);
                    for (l_278 = (-8); (l_278 <= 13); l_278 += 4)
                    { /* block id: 143 */
                        int32_t *l_282 = &l_215;
                        (*l_213) = l_282;
                    }
                    if (((uint16_t)func_88(((uint16_t)(p_59 != ((*l_214) <= ((int64_t)0x781C0EB34223EEF5LL / (int64_t)l_278))) / (uint16_t)((uint16_t)((int64_t)(0UL & ((int16_t)(*l_214) >> (int16_t)p_59)) + (int64_t)(l_295 != &l_216)) << (uint16_t)(*l_248))), (***l_244), &l_225, (*l_279)) >> (uint16_t)(***l_244)))
                    { /* block id: 146 */
                        int32_t **l_297 = &l_279;
                        (*l_297) = l_296;
                        /* statement id: 147 */
                        assert (l_279 == 0);
                        (**l_244) = l_279;
                        /* statement id: 148 */
                        assert (l_214 == 0);
                        (**l_244) = (**l_244);
                        (*l_248) = __builtin_popcountl(p_60);
                    }
                    else
                    { /* block id: 151 */
                        float *****l_300 = (void*)0;
                        float *****l_301 = &l_298;
                        (*l_301) = l_298;
                        (*l_213) = l_279;
                    }
                    /* facts after branching */
                    assert (l_214 == &l_215 || l_214 == 0);
                    assert (l_279 == &l_215 || l_279 == 0);
                }
                else
                { /* block id: 155 */
                    float l_303 = 0x4.B400A9p+20;
                    float *l_302 = &l_303;
                    struct S0 *l_307 = &l_225;
                    (*l_302) = p_59;
                    if ((((int64_t)(-9L) - (int64_t)(-1L)) > 0L))
                    { /* block id: 157 */
                        int32_t *l_306 = &l_215;
                        struct S0 *l_308 = &l_225;
                        (**l_244) = l_306;
                        /* statement id: 158 */
                        assert (l_214 == &l_215);
                        l_308 = l_307;
                    }
                    else
                    { /* block id: 160 */
                        (*l_302) = 0x5.Fp-1;
                        (**l_251) = l_309;
                    }
                    if (p_58)
                        break;
                    (*l_302) = __builtin_ffsl((l_310 != l_214));
                }
            }
            /* facts after branching */
            //assert (l_214 == &l_215 || l_214 == 0 || l_214 == dangling);
            (**l_244) = l_310;
            /* statement id: 168 */
            assert (l_214 == 0);
        }
        /* facts after for loop */
        //assert (l_214 == &l_215 || l_214 == dangling || l_214 == 0);
        (*l_213) = l_245;
        /* statement id: 170 */
        assert (l_214 == &l_215);
    }
    /* facts after branching */
    assert (l_214 == &l_215 || l_214 == 0);
    return l_311;
    /* statement id: 172 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_67(struct S0 * p_68, struct S0 * p_69)
{ /* block id: 108 */
    uint32_t l_200 = 0x450317E3L;
    return l_200;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_72(int32_t * p_73, int64_t  p_74, const struct S0 * p_75)
{ /* block id: 47 */
    int32_t l_83 = (-8L);
    uint16_t l_96 = 5UL;
    struct S0 l_126 = {-516};
    struct S0 *l_189 = &l_126;
    struct S0 **l_188 = &l_189;
    struct S0 *l_199 = (void*)0;
    if ((1UL || ((int32_t)(*p_73) + (int32_t)(l_83 | ((int16_t)0x6798L << (int16_t)((uint16_t)func_88(p_74, l_83, func_93(l_83, l_96), l_96) << (uint16_t)p_74))))))
    { /* block id: 57 */
        struct S0 *l_127 = &l_126;
        int32_t *l_132 = &l_83;
        int32_t **l_131 = &l_132;
        float l_166 = 0x1.5p-1;
        uint64_t l_169 = 0xFE182C0C4DA8BF39LL;
        (*l_127) = l_126;
        if ((*p_73))
        { /* block id: 59 */
            int32_t *l_129 = &l_83;
            int32_t **l_128 = &l_129;
            struct S0 *l_130 = (void*)0;
            (*l_128) = p_73;
            /* statement id: 60 */
            //assert (l_129 == &l_77 || l_129 == &l_339);
            return l_130;
            /* statement id: 61 */
            //assert (func_72_rv == 0);
        }
        else
        { /* block id: 62 */
            float **l_138 = (void*)0;
            int32_t *l_150 = &l_83;
            if ((p_73 == &l_83))
            { /* block id: 63 */
                int32_t ***l_133 = (void*)0;
                const int32_t * const *l_135 = (void*)0;
                const int32_t * const **l_134 = &l_135;
                (*l_134) = l_131;
                /* statement id: 64 */
                assert (l_135 == &l_132);
            }
            else
            { /* block id: 65 */
                (*l_131) = p_73;
                /* statement id: 66 */
                //assert (l_132 == &l_77 || l_132 == &l_339);
            }
            /* facts after branching */
            //assert (l_132 == &l_77 || l_132 == &l_83 || l_132 == &l_339);
            for (l_96 = 0; (l_96 > 18); l_96 += 3)
            { /* block id: 70 */
                const float l_142 = 0x0.5p-1;
                const float *l_141 = &l_142;
                const float **l_140 = &l_141;
                const float ***l_139 = &l_140;
                int32_t l_143 = (-3L);
                (*l_139) = l_138;
                /* statement id: 71 */
                assert (l_140 == 0);
                if (l_143)
                    continue;
            }
            for (l_83 = 0; (l_83 >= 17); ++l_83)
            { /* block id: 76 */
                struct S0 *l_149 = (void*)0;
                for (p_74 = 0; (p_74 <= (-3)); --p_74)
                { /* block id: 79 */
                    struct S0 l_148 = {626};
                    (*l_127) = l_148;
                    return l_149;
                    /* statement id: 81 */
                    //assert (func_72_rv == 0);
                }
            }
            (*l_131) = l_150;
            /* statement id: 84 */
            assert (l_132 == &l_83);
        }
        l_126.f0 = ((((((int64_t)((p_73 != (void*)0) & p_74) / (int64_t)(-(int16_t)((int64_t)l_83 % (int64_t)p_74))) <= (**l_131)) && ((((**l_131) | l_126.f0) == 0x86FCL) <= (*p_73))) | (**l_131)) < l_126.f0);
        (**l_131) = ((uint64_t)((*l_132) > (p_74 >= (((uint16_t)(__builtin_ffsll(((int32_t)((int16_t)((l_83 | ((uint16_t)__builtin_clzl(p_74) >> (uint16_t)(**l_131))) ^ func_88(p_74, ((uint32_t)0xF52E1657L + (uint32_t)0x82E29568L), l_127, p_74)) % (int16_t)p_74) - (int32_t)0xB882180DL)) ^ 0xB398L) >> (uint16_t)p_74) < l_169))) + (uint64_t)0UL);
    }
    else
    { /* block id: 88 */
        float l_173 = 0x9.EE43C4p+73;
        float * const l_172 = &l_173;
        int32_t l_178 = 0x0C446B92L;
        l_178 = ((p_74 != ((float)((((void*)0 != l_172) == ((float)p_74 / (float)((float)p_74 + (float)l_178))) < l_126.f0) - (float)p_74)) < l_96);
        for (l_178 = (-23); (l_178 != 22); ++l_178)
        { /* block id: 92 */
            const struct S0 *l_182 = &l_126;
            const struct S0 **l_181 = &l_182;
            l_181 = &p_75;
            /* statement id: 93 */
            assert (l_181 == &p_75);
        }
    }
    (*p_73) = ((int64_t)func_88(((uint64_t)l_126.f0 - (uint64_t)(0x915BDED785604A18LL <= p_74)), l_96, func_93((+(l_83 & (&p_75 == l_188))), l_96), p_74) % (int64_t)p_74);
    for (l_83 = 27; (l_83 > (-10)); l_83 -= 1)
    { /* block id: 99 */
        int32_t *l_193 = &l_83;
        int32_t **l_192 = &l_193;
        struct S0 *l_197 = &l_126;
        struct S0 *l_198 = (void*)0;
        (*l_192) = p_73;
        /* statement id: 100 */
        //assert (l_193 == &l_77 || l_193 == &l_339);
        for (p_74 = (-6); (p_74 > 6); p_74 += 8)
        { /* block id: 103 */
            struct S0 *l_196 = &l_126;
            return l_198;
            /* statement id: 104 */
            //assert (func_72_rv == 0);
        }
    }
    return l_199;
    /* statement id: 107 */
    //assert (func_72_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint16_t  func_88(uint32_t  p_89, int16_t  p_90, struct S0 * p_91, uint16_t  p_92)
{ /* block id: 54 */
    int32_t l_118 = 0xFA45FE6EL;
    int32_t l_123 = (-8L);
    int32_t l_125 = 0xF5961936L;
    int32_t *l_124 = &l_125;
    (*l_124) = ((float)(l_118 >= p_90) - (float)((float)((((float)l_123 / (float)((void*)0 == l_124)) > p_90) >= ((p_89 <= p_89) >= (&l_124 != &l_124))) + (float)(*l_124)));
    return p_89;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_93(uint8_t  p_94, uint32_t  p_95)
{ /* block id: 48 */
    int32_t l_98 = 3L;
    int32_t *l_97 = &l_98;
    int32_t **l_99 = &l_97;
    float *l_100 = (void*)0;
    float *l_101 = (void*)0;
    float l_103 = 0x1.28C4F4p+64;
    float *l_102 = &l_103;
    struct S0 *l_106 = (void*)0;
    float *l_113 = &l_103;
    (*l_99) = l_97;
    (*l_102) = __builtin_popcountl(p_95);
    (*l_102) = p_94;
    (**l_99) = (((int16_t)__builtin_clz((l_106 == (void*)0)) - (int16_t)((int32_t)(*l_97) + (int32_t)((((**l_99) >= (((int32_t)(((uint32_t)((void*)0 == l_113) % (uint32_t)((int64_t)(**l_99) % (int64_t)(*l_97))) & 1L) % (int32_t)(**l_99)) >= (**l_99))) && p_94) ^ 0x1E225179L))) != p_95);
    return l_106;
    /* statement id: 53 */
    //assert (func_93_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 164
   depth: 1, occurrence: 5
XXX total union variables: 4

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 58
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 33
   indirect level: 2, occurrence: 8
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 47
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 21

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 170
   depth: 2, occurrence: 30
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 4
   depth: 11, occurrence: 3
   depth: 12, occurrence: 5
   depth: 13, occurrence: 5
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 2
   depth: 28, occurrence: 1

XXX total number of pointers: 183

XXX times a variable address is taken: 174
XXX times a pointer is dereferenced on RHS: 65
breakdown:
   depth: 1, occurrence: 48
   depth: 2, occurrence: 14
   depth: 3, occurrence: 3
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 15
XXX times a pointer is compared with null: 16
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 361

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 275
   level: 2, occurrence: 87
   level: 3, occurrence: 31
   level: 4, occurrence: 1
   level: 5, occurrence: 3
XXX number of pointers point to pointers: 81
XXX number of pointers point to scalars: 53
XXX number of pointers point to structs: 44
XXX percent of pointers has null in alias set: 36.1
XXX average alias set size: 1.2

XXX times a non-volatile is read: 637
XXX times a non-volatile is write: 227
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 152
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 22
   depth: 2, occurrence: 18
   depth: 3, occurrence: 24
   depth: 4, occurrence: 28
   depth: 5, occurrence: 30

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

