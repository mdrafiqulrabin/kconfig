/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      974245524
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
   int16_t  f1;
   unsigned f2 : 16;
   uint32_t  f3;
   int16_t  f4;
};

union U1 {
   const uint32_t  f0;
};

union U2 {
   const uint32_t  f0;
   unsigned f1 : 13;
   int32_t  f2;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_33(void);
static float  func_37(int16_t  p_38, int32_t  p_39);
static union U2 * func_56(union U1  p_57, int32_t  p_58, union U1  p_59);
inline static union U2 * func_64(union U2 * p_65, uint32_t  p_66, uint16_t  p_67, union U2 * p_68);
inline static uint32_t  func_81(int16_t  p_82, union U2 * p_83, int32_t * p_84, const int32_t * p_85);
static union U2 * func_86(uint32_t  p_87);
inline static int32_t * func_89(float  p_90, const union U2 * p_91, int32_t ** p_92, int32_t  p_93);
inline static int32_t *** func_104(int16_t  p_105, float  p_106);
static const int16_t  func_109(uint32_t  p_110, uint32_t  p_111, union U2  p_112);
static uint32_t  func_114(int32_t *** p_115, uint32_t  p_116, int32_t ** p_117);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_33(void)
{ /* block id: 36 */
    int32_t l_35 = 0xA9BCA7B5;
    int32_t *l_34 = &l_35;
    int32_t **l_36 = &l_34;
    int32_t l_40 = 0x20DD93BA;
    uint16_t l_45 = 65528U;
    int16_t l_48 = 3;
    float *l_361 = (void*)0;
    float l_363 = 0xF.E0678Fp-35;
    float *l_362 = &l_363;
    (*l_36) = l_34;
    (*l_36) = (void*)0;
    /* statement id: 38 */
    assert (l_34 == 0);
    (*l_362) = func_37(l_35, (l_40 != (((uint16_t)(((uint32_t)l_45 % (uint32_t)((uint32_t)l_48 + (uint32_t)((uint16_t)l_35 + (uint16_t)((int32_t)((*l_36) != (*l_36)) - (int32_t)(l_40 || ((int16_t)((*l_36) != (void*)0) - (int16_t)0U)))))) && l_48) % (uint16_t)l_45) && 0xF54A)));
    return l_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_37(int16_t  p_38, int32_t  p_39)
{ /* block id: 39 */
    int32_t l_55 = (-5);
    union U1 l_63 = {0xF6679856};
    union U2 l_337 = {6U};
    const union U2 *l_336 = &l_337;
    int32_t **l_338 = (void*)0;
    union U0 l_344 = {6U};
    union U0 *l_343 = &l_344;
    if (l_55)
    { /* block id: 40 */
        union U1 l_60 = {0xB6F2BA10};
        union U2 l_330 = {4294967290U};
        union U2 *l_329 = &l_330;
        union U2 **l_328 = &l_329;
        union U0 l_332 = {6U};
        union U0 *l_331 = &l_332;
        int32_t *l_342 = &l_330.f2;
        uint16_t l_348 = 0xDDD1;
        (*l_328) = func_56(l_60, ((uint16_t)0U - (uint16_t)(0xEA6AE202 && l_60.f0)), l_63);
        /* statement id: 160 */
        assert (l_329 == 0);
        if (((void*)0 != l_331))
        { /* block id: 161 */
            int32_t l_335 = 0xD9AC3D86;
            int32_t *l_339 = &l_55;
            int32_t **l_340 = (void*)0;
            int32_t **l_341 = &l_339;
            const union U0 **l_345 = (void*)0;
            const union U0 *l_347 = &l_344;
            const union U0 **l_346 = &l_347;
            (*l_341) = l_339;
            (*l_341) = l_342;
            /* statement id: 163 */
            assert (l_339 == &l_330.f2);
            (*l_346) = l_343;
            (*l_346) = (*l_346);
        }
        else
        { /* block id: 166 */
            int32_t *l_351 = &l_55;
            int32_t **l_352 = &l_351;
            if (p_38)
            { /* block id: 167 */
                float l_350 = 0x0.8p+1;
                float *l_349 = &l_350;
                (*l_349) = l_348;
            }
            else
            { /* block id: 169 */
                (*l_328) = (void*)0;
            }
            (*l_352) = l_351;
        }
    }
    else
    { /* block id: 174 */
        uint32_t l_353 = 0xF4B73F3D;
        int16_t l_354 = 4;
        l_354 = (p_38 & (0x3C0D ^ (l_353 > (&l_337 == (void*)0))));
        return p_39;
    }
    if (((&l_337 != &l_337) ^ p_39))
    { /* block id: 178 */
        union U1 *l_355 = &l_63;
        int32_t *l_356 = &l_337.f2;
        int32_t **l_357 = &l_356;
        l_355 = l_355;
        (*l_357) = l_356;
        return p_39;
    }
    else
    { /* block id: 182 */
        float l_360 = 0x0.CEEA62p-35;
        for (l_55 = 16; (l_55 > 12); l_55--)
        { /* block id: 185 */
            return l_360;
        }
        return p_38;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_56(union U1  p_57, int32_t  p_58, union U1  p_59)
{ /* block id: 41 */
    union U2 l_70 = {4294967293U};
    union U2 *l_69 = &l_70;
    float l_73 = 0x6.FF74B7p+35;
    float l_76 = 0xF.292628p+8;
    union U2 **l_320 = &l_69;
    union U2 *l_321 = &l_70;
    union U2 *l_322 = &l_70;
    union U2 *l_323 = &l_70;
    union U2 *l_324 = &l_70;
    union U2 *l_325 = &l_70;
    union U2 *l_326 = &l_70;
    union U2 *l_327 = (void*)0;
    (*l_320) = func_64(l_69, __builtin_bswap64((0x0546 || (__builtin_popcountl(((int16_t)l_70.f0 + (int16_t)0x18CE)) ^ (p_58 || ((((int32_t)p_57.f0 + (int32_t)p_57.f0) < ((&l_70 != (void*)0) >= 1U)) < 0xCC42))))), p_57.f0, &l_70);
    return l_327;
    /* statement id: 159 */
    //assert (func_56_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2 * func_64(union U2 * p_65, uint32_t  p_66, uint16_t  p_67, union U2 * p_68)
{ /* block id: 42 */
    int16_t l_88 = 0x97E6;
    int32_t l_217 = 1;
    int32_t *l_216 = &l_217;
    union U2 l_241 = {4294967288U};
    union U0 l_246 = {0U};
    const union U0 *l_245 = &l_246;
    const union U0 **l_244 = &l_245;
    const union U0 *l_261 = &l_246;
    int32_t *l_294 = &l_217;
    int16_t l_302 = 0x0C69;
    int32_t **l_317 = &l_216;
    int32_t ***l_316 = &l_317;
    for (p_67 = 0; (p_67 < 13); p_67 += 3)
    { /* block id: 45 */
        int32_t *l_215 = (void*)0;
        int32_t **l_214 = &l_215;
        int32_t l_218 = 0x415C7811;
        const uint32_t l_222 = 1U;
        (*l_216) = ((uint32_t)func_81(p_66, func_86(l_88), l_216, func_89((p_66 <= p_66), p_68, &l_216, p_67)) + (uint32_t)0x1B8A4D6D);
        if ((l_218 <= 0x76D05891))
        { /* block id: 100 */
            uint32_t l_221 = 6U;
            (*l_214) = func_89((((float)((void*)0 == l_216) - (float)p_67) < (0xC.C93F04p+90 >= 0xD.FACA1Cp-8)), func_86((p_66 <= p_67)), &l_216, l_221);
            /* statement id: 101 */
            assert (l_215 == &l_217);
        }
        else
        { /* block id: 102 */
            uint32_t l_223 = 0U;
            union U2 l_242 = {4294967287U};
            int32_t *l_243 = &l_217;
            union U2 *l_256 = &l_242;
            if (l_222)
                break;
            l_223 = (*l_216);
            if (((uint16_t)0x2A89 - (uint16_t)l_223))
            { /* block id: 105 */
                float l_235 = 0x6.4191B5p-17;
                int32_t l_251 = 1;
                for (p_66 = 0; (p_66 < 45); ++p_66)
                { /* block id: 108 */
                    const uint16_t l_228 = 6U;
                    int16_t l_231 = 1;
                    int32_t *l_252 = &l_251;
                    if (l_228)
                    { /* block id: 109 */
                        uint32_t l_240 = 3U;
                        (*l_216) = ((int32_t)((__builtin_clz(l_231) >= (~1U)) & ((uint16_t)p_67 << (uint16_t)(((int16_t)(((((int32_t)func_109(l_240, func_109(l_223, p_66, l_241), l_242) + (int32_t)(-8)) < l_228) & 0xB560) <= 0x8CD386D9) >> (int16_t)14) >= 0xD39FB383))) + (int32_t)8U);
                        l_243 = &l_217;
                        (*l_216) = 0x3.DBDEA8p-95;
                    }
                    else
                    { /* block id: 113 */
                        union U0 *l_249 = &l_246;
                        union U0 **l_248 = &l_249;
                        union U0 ***l_247 = &l_248;
                        int32_t l_250 = (-6);
                        (*l_247) = l_244;
                        /* statement id: 114 */
                        assert (l_248 == &l_245);
                        (*l_243) = (l_250 >= (l_251 | 0x6519));
                    }
                    (*l_214) = l_252;
                    /* statement id: 117 */
                    assert (l_215 == &l_251);
                }
                /* facts after for loop */
                assert (l_215 == &l_251 || l_215 == 0);
            }
            else
            { /* block id: 119 */
                union U2 *l_255 = &l_242;
                float l_258 = 0x1.8p+1;
                float *l_257 = &l_258;
                union U0 *l_260 = &l_246;
                union U0 * const *l_259 = &l_260;
                (*l_257) = ((float)0x9.B1A2CDp-55 - (float)(l_255 == l_256));
                l_259 = l_259;
            }
            /* facts after branching */
            //assert (l_215 == dangling || l_215 == 0);
            (*l_244) = l_261;
        }
        /* facts after branching */
        //assert (l_215 == dangling || l_215 == 0 || l_215 == &l_217);
    }
    if (__builtin_ffs(((&l_241 == p_68) <= p_66)))
    { /* block id: 126 */
        uint32_t l_267 = 0xF737D9CE;
        int32_t **l_271 = &l_216;
        int32_t ***l_270 = &l_271;
        float l_288 = 0x0.02AD85p+78;
        for (l_88 = 0; (l_88 >= (-1)); --l_88)
        { /* block id: 129 */
            const uint32_t l_264 = 0x0F9DADCB;
            union U0 *l_291 = &l_246;
            int32_t *l_296 = &l_241.f2;
            if ((((p_67 ^ 0xAAB8839A) && l_264) || (l_264 >= ((int32_t)(l_267 ^ __builtin_parity((*l_216))) % (int32_t)p_66))))
            { /* block id: 130 */
                uint32_t l_292 = 0U;
                union U0 **l_298 = &l_291;
                const union U0 ***l_299 = &l_244;
                if (l_264)
                { /* block id: 131 */
                    int32_t l_272 = 0xB2B50047;
                    float *l_297 = &l_288;
                    if (((int16_t)func_109((l_267 ^ func_114(l_270, l_272, (*l_270))), l_264, (*p_65)) << (int16_t)1))
                    { /* block id: 132 */
                        (***l_270) = ((uint32_t)0U % (uint32_t)l_264);
                        (*l_271) = &l_217;
                    }
                    else
                    { /* block id: 135 */
                        float *l_293 = &l_288;
                        (*l_293) = ((float)((float)(((+((float)func_109((((int16_t)((0xD6BA == (**l_271)) != ((uint16_t)(***l_270) - (uint16_t)(l_264 || (((uint32_t)p_66 - (uint32_t)(l_264 || (l_272 && l_272))) <= ((((((int16_t)((void*)0 != l_291) - (int16_t)p_66) || l_292) && (*l_216)) | 0xD96B) | p_67))))) >> (int16_t)8) ^ 4294967295U), p_66, (*p_65)) - (float)p_66)) == 0xB.CF794Cp-89) < l_292) + (float)p_66) - (float)p_66);
                        (*l_216) = (p_66 < (__builtin_popcountll(p_67) > (*l_216)));
                        if (p_67)
                            break;
                        (*l_271) = l_294;
                    }
                    (*l_297) = ((!((-0x1.8p-1) > ((**l_270) == l_296))) < p_66);
                }
                else
                { /* block id: 142 */
                    (**l_271) = (*l_294);
                }
                (**l_270) = &l_217;
                (*l_299) = l_298;
                /* statement id: 146 */
                assert (l_244 == &l_291);
            }
            else
            { /* block id: 147 */
                (***l_270) = (((uint16_t)(&l_296 != (void*)0) >> (uint16_t)__builtin_bswap64(func_81(__builtin_ctzl(l_302), &l_241, (**l_270), (**l_270)))) == 8U);
            }
            /* facts after branching */
            //assert (l_244 == &l_245 || l_244 == dangling || l_244 == &l_291);
        }
        /* facts after for loop */
        //assert (l_244 == &l_245 || l_244 == dangling);
        (**l_270) = &l_217;
        (*l_294) = ((uint32_t)(((((((uint16_t)(__builtin_ctzl((0x08B0 == ((int16_t)(&l_241 == (void*)0) << (int16_t)11))) && (p_66 && (5U > func_81(((*l_294) | (1 != (((**l_271) && p_66) & (*l_216)))), p_65, (**l_270), &l_217)))) + (uint16_t)p_67) > 0xD47C3267) == p_67) & 0x22F2) > p_67) == p_67) % (uint32_t)p_67);
    }
    else
    { /* block id: 153 */
        uint16_t l_315 = 65535U;
        union U2 *l_319 = &l_241;
        union U2 **l_318 = &l_319;
        (**l_317) = __builtin_clz(((p_66 || ((int16_t)p_66 >> (int16_t)14)) <= ((int16_t)((*l_216) ^ 0x7C08B2C5) % (int16_t)((int16_t)p_66 << (int16_t)(l_315 > ((void*)0 == l_316))))));
        (*l_318) = &l_241;
    }
    /* facts after branching */
    //assert (l_244 == &l_245 || l_244 == dangling);
    return p_65;
    /* statement id: 157 */
    //assert (func_64_rv == &l_70);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_81(int16_t  p_82, union U2 * p_83, int32_t * p_84, const int32_t * p_85)
{ /* block id: 96 */
    (*p_84) = (*p_84);
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 * func_86(uint32_t  p_87)
{ /* block id: 46 */
    const union U2 l_95 = {0x0F898D4E};
    const union U2 *l_94 = &l_95;
    int32_t l_98 = 0x22C1E978;
    int32_t *l_97 = &l_98;
    int32_t **l_96 = &l_97;
    float l_199 = (-0x5.9p+1);
    float *l_198 = &l_199;
    union U2 l_201 = {0x4CF6FCF6};
    union U2 *l_200 = &l_201;
    union U2 *l_202 = &l_201;
    union U2 *l_203 = &l_201;
    union U2 *l_204 = &l_201;
    union U2 *l_205 = &l_201;
    union U2 *l_206 = &l_201;
    union U2 *l_207 = &l_201;
    union U2 *l_208 = &l_201;
    union U2 *l_209 = &l_201;
    union U2 *l_210 = &l_201;
    union U2 *l_211 = &l_201;
    union U2 *l_212 = &l_201;
    union U2 *l_213 = (void*)0;
    (*l_96) = func_89(__builtin_clz(p_87), l_94, l_96, p_87);
    (*l_198) = ((((float)((((float)(**l_96) + (float)p_87) > (0x2.EEAC9Fp-33 != ((__builtin_parity((**l_96)) < ((__builtin_popcountll(((uint32_t)0x51B912C0 - (uint32_t)((uint32_t)0x15A1FB0D - (uint32_t)((**l_96) != (-10))))) >= (*l_97)) >= p_87)) != (**l_96)))) >= p_87) + (float)(*l_97)) > 0x5.6CAEA2p-99) < (-0x1.Fp-1));
    (*l_97) = ((**l_96) || p_87);
    return l_213;
    /* statement id: 95 */
    //assert (func_86_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_89(float  p_90, const union U2 * p_91, int32_t ** p_92, int32_t  p_93)
{ /* block id: 47 */
    int32_t l_101 = 0;
    int32_t *l_100 = &l_101;
    int32_t * const *l_99 = &l_100;
    int32_t l_113 = (-1);
    int32_t **l_189 = &l_100;
    l_99 = l_99;
    for (p_93 = 14; (p_93 < (-8)); --p_93)
    { /* block id: 51 */
        int32_t **l_119 = &l_100;
        int32_t ***l_118 = &l_119;
        union U2 l_132 = {4294967290U};
        (**l_99) = ((**l_99) == (**l_99));
        if ((**p_92))
            break;
        l_118 = func_104(((0xE450DE0B & ((int16_t)func_109(l_113, func_114(l_118, (*l_100), p_92), l_132) + (int16_t)(((int32_t)p_93 + (int32_t)(***l_118)) >= p_93))) != p_93), p_93);
        /* statement id: 88 */
        assert (l_118 == 0);
    }
    (*l_189) = (*l_99);
    return (*p_92);
    /* statement id: 91 */
    //assert (func_89_rv == &l_98 || func_89_rv == &l_217);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t *** func_104(int16_t  p_105, float  p_106)
{ /* block id: 61 */
    int32_t l_151 = 0xF1A457CE;
    union U2 l_152 = {4294967290U};
    union U2 l_155 = {1U};
    float l_157 = 0x0.394C47p-83;
    float *l_156 = &l_157;
    int32_t ***l_158 = (void*)0;
    uint16_t l_165 = 9U;
    int32_t *l_168 = &l_151;
    union U2 l_179 = {4294967295U};
    (*l_156) = ((float)p_105 - (float)((float)p_105 + (float)func_109(func_109(l_151, l_151, l_152), (((((uint16_t)65532U >> (uint16_t)10) <= (l_152.f0 >= ((p_105 & l_152.f0) | p_105))) >= l_151) <= l_152.f2), l_155)));
    if ((l_158 == (void*)0))
    { /* block id: 63 */
        union U2 *l_161 = &l_155;
        int32_t l_164 = (-9);
        union U0 l_167 = {0x4F87};
        union U0 *l_166 = &l_167;
        int32_t **l_170 = &l_168;
        int32_t ***l_169 = &l_170;
        if (((uint16_t)((((void*)0 != l_161) < (p_105 >= ((uint16_t)l_164 << (uint16_t)l_165))) == (-1)) << (uint16_t)14))
        { /* block id: 64 */
            int32_t ***l_171 = &l_170;
            l_166 = l_166;
            l_168 = l_168;
            return l_158;
            /* statement id: 67 */
            //assert (func_104_rv == 0);
        }
        else
        { /* block id: 68 */
            (*l_156) = p_106;
        }
        return l_158;
        /* statement id: 71 */
        //assert (func_104_rv == 0);
    }
    else
    { /* block id: 72 */
        int32_t l_176 = (-5);
        int32_t **l_183 = &l_168;
        int32_t ***l_182 = &l_183;
        for (l_151 = 0; (l_151 < (-29)); l_151 -= 8)
        { /* block id: 75 */
            int32_t *l_174 = &l_151;
            int32_t **l_175 = &l_174;
            (*l_175) = l_174;
        }
lbl_188:
        (*l_156) = p_105;
        if (((l_176 | ((uint16_t)((((p_105 > l_176) & l_176) && func_109(l_176, l_176, l_179)) == ((*l_168) <= (*l_168))) << (uint16_t)12)) >= p_105))
        { /* block id: 79 */
            int32_t **l_181 = (void*)0;
            int32_t ***l_180 = &l_181;
            return l_158;
            /* statement id: 80 */
            //assert (func_104_rv == 0);
        }
        else
        { /* block id: 81 */
            uint16_t l_186 = 0xC57E;
            (*l_168) = ((p_105 <= (((uint16_t)((l_186 <= p_105) | (+p_105)) + (uint16_t)__builtin_parityll((***l_182))) == 0xA35B9869)) >= p_105);
            if (l_155.f1)
                goto lbl_188;
            (**l_183) = l_186;
        }
    }
    return l_158;
    /* statement id: 87 */
    //assert (func_104_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_109(uint32_t  p_110, uint32_t  p_111, union U2  p_112)
{ /* block id: 58 */
    uint32_t l_135 = 5U;
    int32_t *l_138 = (void*)0;
    int32_t **l_137 = &l_138;
    int32_t ***l_136 = &l_137;
    int32_t l_141 = 1;
    const int16_t l_144 = (-3);
    p_112.f2 = ((int16_t)(l_135 >= (l_141 >= 0xB87A)) - (int16_t)((uint32_t)p_112.f1 + (uint32_t)((*l_137) != (*l_137))));
    /* statement id: 59 */
        return l_144;
}


/* ------------------------------------------ */
/* 
 * reads : l_97 l_98 l_216 l_217
 * writes: l_98 l_217
 */
static uint32_t  func_114(int32_t *** p_115, uint32_t  p_116, int32_t ** p_117)
{ /* block id: 54 */
    int32_t l_120 = 0xEE5324E3;
    (**p_117) = l_120;
    (**p_117) = (p_116 || ((((uint32_t)p_116 + (uint32_t)(l_120 <= ((uint16_t)((((p_116 > (l_120 == ((uint16_t)l_120 - (uint16_t)(p_116 < (+(((uint32_t)((int32_t)(**p_117) + (int32_t)(***p_115)) - (uint32_t)4294967295U) == (***p_115))))))) || p_116) == (***p_115)) >= l_120) - (uint16_t)p_116))) <= l_120) < l_120));
    return l_120;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 120
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 40
breakdown:
   indirect level: 0, occurrence: 6
   indirect level: 1, occurrence: 31
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 44
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 24
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 13
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 112

XXX times a variable address is taken: 108
XXX times a pointer is dereferenced on RHS: 47
breakdown:
   depth: 1, occurrence: 26
   depth: 2, occurrence: 15
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 50
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 8
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 290

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 99
   level: 2, occurrence: 67
   level: 3, occurrence: 21
XXX number of pointers point to pointers: 40
XXX number of pointers point to scalars: 27
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 15.2
XXX average alias set size: 1.14

XXX times a non-volatile is read: 390
XXX times a non-volatile is write: 128
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 24
   depth: 2, occurrence: 22
   depth: 3, occurrence: 9
   depth: 4, occurrence: 5
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 17.2
XXX percentage an existing variable is used: 82.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

