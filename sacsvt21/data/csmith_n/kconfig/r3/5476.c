/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1566154697
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint64_t  func_31(void);
static int32_t  func_44(uint8_t  p_45, int32_t  p_46, uint32_t  p_47);
inline static uint64_t  func_60(uint8_t  p_61, int32_t * p_62, int32_t * p_63);
static int32_t * func_75(uint16_t  p_76, uint8_t  p_77, int32_t  p_78, int32_t ** p_79, int16_t  p_80);
inline static int64_t  func_91(int32_t ** p_92, uint16_t  p_93, const int16_t  p_94, uint8_t  p_95);
inline static int32_t * func_105(uint8_t  p_106, const int32_t * p_107, int32_t  p_108);
static const uint32_t  func_110(int32_t ** p_111);
inline static int32_t ** func_112(int32_t * p_113, float  p_114, int32_t ** p_115);
static int32_t ** func_117(uint32_t  p_118, const int32_t ** p_119, int16_t  p_120, const float * p_121, const uint8_t  p_122);
inline static const int16_t  func_150(int32_t  p_151, int32_t  p_152, float * p_153, const float  p_154);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_31(void)
{ /* block id: 36 */
    int32_t l_32 = 0x3061ECE3L;
    int32_t *l_97 = &l_32;
    int32_t **l_96 = &l_97;
    const int16_t l_423 = 0x30C3L;
    int16_t l_428 = (-1L);
    for (l_32 = 0; (l_32 <= (-1)); l_32 -= 7)
    { /* block id: 39 */
        uint32_t l_35 = 4294967295UL;
        if (l_35)
            break;
    }
    for (l_32 = 27; (l_32 == 21); l_32 -= 3)
    { /* block id: 44 */
        int16_t l_38 = 2L;
        uint32_t l_98 = 18446744073709551615UL;
        int32_t **l_116 = &l_97;
        const uint64_t l_133 = 18446744073709551611UL;
        const int32_t *l_135 = &l_32;
        const int32_t **l_134 = &l_135;
        if (l_38)
            break;
        for (l_38 = 0; (l_38 < 28); ++l_38)
        { /* block id: 48 */
            int32_t l_41 = 0x5DC1B6EAL;
            int32_t *l_84 = &l_41;
            int32_t **l_83 = &l_84;
            for (l_41 = 0; (l_41 < (-19)); l_41 -= 4)
            { /* block id: 51 */
                uint32_t l_48 = 0x29A275FFL;
                int32_t *l_50 = (void*)0;
                int32_t l_52 = 1L;
                int32_t *l_51 = &l_52;
                float l_74 = (-0x1.Cp-1);
                float *l_73 = &l_74;
                if (l_38)
                    break;
                (*l_51) = func_44(l_32, l_48, l_41);
                (*l_73) = ((-(float)__builtin_ia32_crc32qi(((int64_t)((int64_t)((void*)0 == &l_52) - (int64_t)((uint16_t)0x289AL / (uint16_t)((&l_32 != (void*)0) & l_32))) % (int64_t)func_60((&l_41 == &l_52), &l_41, &l_32)), l_32)) == 0x4.0277EDp-70);
            }
        }
    }
    return l_428;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_44(uint8_t  p_45, int32_t  p_46, uint32_t  p_47)
{ /* block id: 53 */
    int32_t l_49 = (-1L);
    return l_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_60(uint8_t  p_61, int32_t * p_62, int32_t * p_63)
{ /* block id: 56 */
    int32_t l_66 = 0x93CC9D6CL;
    int32_t *l_65 = &l_66;
    int32_t **l_64 = &l_65;
    float l_68 = (-0x3.4p+1);
    uint8_t l_69 = 0xADL;
    float *l_70 = (void*)0;
    float *l_71 = &l_68;
    int32_t l_72 = (-4L);
    (*l_64) = (void*)0;
    /* statement id: 57 */
    assert (l_65 == 0);
    (*l_71) = ((!p_61) > (l_68 == func_44(l_66, p_61, l_69)));
    return l_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_75(uint16_t  p_76, uint8_t  p_77, int32_t  p_78, int32_t ** p_79, int16_t  p_80)
{ /* block id: 65 */
    uint64_t l_101 = 0x3A04BB84A8A623B0LL;
    float *l_102 = (void*)0;
    float l_104 = 0x9.34C5D1p+6;
    float *l_103 = &l_104;
    (*l_103) = l_101;
    return (*p_79);
    /* statement id: 67 */
    //assert (func_75_rv == &l_41 || func_75_rv == &l_185 || func_75_rv == &p_151 || func_75_rv == &l_155);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_91(int32_t ** p_92, uint16_t  p_93, const int16_t  p_94, uint8_t  p_95)
{ /* block id: 62 */
    const uint32_t l_99 = 18446744073709551615UL;
    int32_t l_100 = 0L;
    l_100 = l_99;
    return p_93;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_105(uint8_t  p_106, const int32_t * p_107, int32_t  p_108)
{ /* block id: 251 */
    float *l_424 = (void*)0;
    int32_t l_425 = 0x4D94E078L;
    int32_t *l_426 = &l_425;
    int32_t *l_427 = (void*)0;
    l_425 = p_108;
    return l_427;
    /* statement id: 253 */
    //assert (func_105_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const uint32_t  func_110(int32_t ** p_111)
{ /* block id: 248 */
    int32_t l_420 = 0L;
    int32_t *l_419 = &l_420;
    int32_t **l_421 = &l_419;
    const int64_t l_422 = 0xB37C996117DFC8C1LL;
    (*l_421) = l_419;
    return l_422;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t ** func_112(int32_t * p_113, float  p_114, int32_t ** p_115)
{ /* block id: 243 */
    int32_t **l_406 = (void*)0;
    int32_t l_409 = 0xAFD46561L;
    int32_t *l_408 = &l_409;
    int32_t **l_407 = &l_408;
    float *l_414 = (void*)0;
    float l_416 = 0xD.F62906p-88;
    float *l_415 = &l_416;
    int32_t **l_417 = &l_408;
    int32_t **l_418 = (void*)0;
    (*l_407) = (void*)0;
    /* statement id: 244 */
    assert (l_408 == 0);
    l_409 = l_409;
    (*l_415) = ((float)((float)(p_114 != (l_408 != l_408)) - (float)__builtin_bswap64(l_409)) / (float)p_114);
    return l_418;
    /* statement id: 247 */
    //assert (func_112_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_117(uint32_t  p_118, const int32_t ** p_119, int16_t  p_120, const float * p_121, const uint8_t  p_122)
{ /* block id: 70 */
    float l_149 = 0xA.5FA2FCp+94;
    float *l_148 = &l_149;
    int32_t l_155 = 0x702F8FA6L;
    float l_384 = 0x8.1B19F2p-10;
    int32_t *l_386 = &l_155;
    int32_t **l_385 = &l_386;
    int32_t ***l_389 = &l_385;
    int32_t ****l_388 = &l_389;
    int32_t *****l_387 = &l_388;
    int32_t **l_401 = &l_386;
    int32_t **l_402 = &l_386;
    int32_t **l_403 = &l_386;
    int32_t **l_404 = &l_386;
    int32_t **l_405 = (void*)0;
lbl_379:
    for (p_120 = 0; (p_120 <= (-18)); p_120 -= 6)
    { /* block id: 73 */
        float *l_161 = &l_149;
        int32_t l_378 = 0x84671B80L;
        l_378 = ((uint64_t)((uint16_t)((uint16_t)(p_120 > ((uint16_t)(((int16_t)((void*)0 != l_148) << (int16_t)10) ^ (**p_119)) + (uint16_t)func_150(l_155, ((int16_t)((((int16_t)(0x441A9D29L > ((65535UL <= (-9L)) && (~p_120))) << (int16_t)14) ^ (-7L)) <= p_122) + (int16_t)p_122), l_161, (*p_121)))) >> (uint16_t)11) >> (uint16_t)14) / (uint64_t)0xFBE3D4A7468774B2LL);
        if (p_120)
            goto lbl_379;
    }
    (*l_385) = func_75(((int16_t)((l_155 || l_155) | __builtin_clz(((uint32_t)p_122 / (uint32_t)l_155))) << (int16_t)8), l_155, l_155, l_385, (*l_386));
    (*****l_387) = (4294967295UL && ((*l_386) <= ((**l_385) == ((void*)0 != l_387))));
    for (p_118 = 9; (p_118 >= 36); ++p_118)
    { /* block id: 233 */
        int32_t *****l_398 = &l_388;
        for (p_120 = 20; (p_120 == (-11)); p_120 -= 4)
        { /* block id: 236 */
            int32_t ** const **l_397 = (void*)0;
            int32_t ** const ***l_396 = &l_397;
            int32_t ***l_399 = (void*)0;
            int32_t ***l_400 = &l_385;
            (*l_386) = 0L;
        }
    }
    return l_405;
    /* statement id: 242 */
    //assert (func_117_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_150(int32_t  p_151, int32_t  p_152, float * p_153, const float  p_154)
{ /* block id: 74 */
    int32_t l_185 = 0x51A53AF9L;
    int32_t *l_184 = &l_185;
    int32_t *l_187 = &l_185;
    int32_t **l_224 = (void*)0;
    int32_t ***l_223 = &l_224;
    int32_t ****l_222 = &l_223;
    const uint64_t l_245 = 0x24A5CBDD7E790059LL;
    float l_308 = 0x1.5p+1;
    int32_t *l_349 = &l_185;
    uint32_t l_371 = 0UL;
    for (p_151 = 0; (p_151 <= (-9)); p_151--)
    { /* block id: 77 */
        int32_t l_165 = 0x099F59CAL;
        int32_t *l_164 = &l_165;
        int32_t ***l_176 = (void*)0;
        int16_t l_218 = 7L;
        uint16_t l_227 = 7UL;
        int32_t **l_237 = &l_187;
        uint32_t l_309 = 0xE6C17682L;
        l_164 = &p_151;
        /* statement id: 78 */
        assert (l_164 == &p_151);
    }
    for (p_152 = 0; (p_152 < 22); ++p_152)
    { /* block id: 194 */
        int32_t *l_350 = &l_185;
        (*p_153) = ((float)((((float)((-0x1.Dp+1) >= (*p_153)) - (float)((float)0x1.6p-1 + (float)__builtin_clz(p_151))) != 0xF.6F64A7p+52) >= (((float)((float)func_60(p_151, l_349, l_350) + (float)(*l_349)) + (float)(*p_153)) > (*l_349))) - (float)0xE.EAA763p+52);
        for (p_151 = 0; (p_151 > (-21)); p_151--)
        { /* block id: 198 */
            int64_t l_357 = 0x7F051BE4F2420815LL;
            int32_t *l_360 = (void*)0;
            l_360 = func_75((*l_350), ((1UL == (8UL ^ (((int16_t)9L / (int16_t)((l_357 ^ ((-(int32_t)(p_151 ^ ((*l_349) <= (1UL & (+p_152))))) > 0x9462FF8BL)) && p_151)) ^ (*l_350)))) || p_152), p_151, &l_350, p_152);
            /* statement id: 199 */
            assert (l_360 == &l_185);
            for (l_357 = 0; (l_357 != 0); l_357 += 9)
            { /* block id: 202 */
                int32_t l_366 = 0L;
                for (l_185 = 0; (l_185 == 19); l_185 += 2)
                { /* block id: 205 */
                    int32_t l_367 = (-8L);
                    l_367 = ((+l_366) | p_152);
                    if (p_152)
                        continue;
                }
                (*l_360) = ((65535UL | p_152) && func_60(l_366, l_360, &l_366));
                if ((*l_350))
                    continue;
            }
        }
        if ((*l_350))
            break;
    }
    for (l_185 = 0; (l_185 > 24); l_185++)
    { /* block id: 217 */
        int64_t l_370 = 0xD9A33A07E616235ALL;
        int32_t **l_372 = (void*)0;
        const int32_t *l_374 = &l_185;
        const int32_t **l_373 = &l_374;
        (*l_373) = &p_151;
        /* statement id: 218 */
        assert (l_374 == &p_151);
    }
    for (p_151 = 12; (p_151 <= (-12)); p_151--)
    { /* block id: 222 */
        const uint16_t l_377 = 0x1FF1L;
        return l_377;
    }
    return p_151;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 107
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 20
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 15
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 11, occurrence: 1
   depth: 14, occurrence: 2
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1

XXX total number of pointers: 112

XXX times a variable address is taken: 102
XXX times a pointer is dereferenced on RHS: 96
breakdown:
   depth: 1, occurrence: 67
   depth: 2, occurrence: 28
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 44
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 1
   depth: 3, occurrence: 0
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 21
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 439

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 166
   level: 2, occurrence: 48
   level: 3, occurrence: 18
   level: 4, occurrence: 13
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 66
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 26.8
XXX average alias set size: 1.22

XXX times a non-volatile is read: 500
XXX times a non-volatile is write: 136
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 53
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 12
   depth: 2, occurrence: 4
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 15.9
XXX percentage an existing variable is used: 84.1
********************* end of statistics **********************/

