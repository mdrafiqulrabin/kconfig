/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      1263812542
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   const signed f0 : 13;
   int32_t  f1;
   signed f2 : 22;
   signed : 0;
};
#pragma pack(pop)

union U1 {
   int16_t  f0;
   uint32_t  f1;
   int16_t  f2;
   int32_t  f3;
   const int16_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_33(void);
static struct S0 * func_36(struct S0 * p_37, int16_t  p_38, struct S0 * p_39, int32_t  p_40, uint32_t  p_41);
inline static int32_t * func_54(uint16_t  p_55, int32_t * p_56, int32_t * const  p_57);
inline static int32_t * func_67(float * const  p_68, struct S0 ** p_69, struct S0 * p_70, struct S0 * p_71);
inline static float * func_72(int32_t * p_73, int32_t  p_74);
static int32_t * func_75(union U1  p_76, union U1  p_77, int32_t  p_78, int16_t  p_79);
inline static uint16_t  func_89(int32_t * p_90, uint32_t  p_91, float * p_92, const int32_t * p_93);
inline static int32_t * func_94(struct S0  p_95, struct S0  p_96);
inline static struct S0  func_98(struct S0 * p_99, float  p_100, uint32_t  p_101, union U1  p_102);
static struct S0 * func_103(int32_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_33(void)
{ /* block id: 36 */
    int16_t l_35 = 0;
    struct S0 l_43 = {8,0xB15D3E99,-1623};
    struct S0 *l_42 = &l_43;
    struct S0 **l_50 = &l_42;
    float l_53 = 0x0.D4FE93p+24;
    float *l_52 = &l_53;
    float * const l_58 = &l_53;
    int32_t l_839 = (-1);
    int32_t *l_838 = &l_839;
    uint32_t l_867 = 0x407C3976;
    if ((!l_35))
    { /* block id: 37 */
        struct S0 *l_44 = &l_43;
        int32_t l_45 = (-7);
        struct S0 **l_48 = (void*)0;
        struct S0 **l_49 = &l_44;
        (*l_49) = func_36(l_42, ((l_44 == &l_43) >= l_35), l_44, l_45, ((-10) >= l_45));
        l_50 = &l_42;
    }
    else
    { /* block id: 42 */
        int32_t l_51 = 1;
        return l_51;
    }
lbl_856:
    (*l_52) = ((void*)0 != &l_42);
    l_838 = func_54((l_58 != (void*)0), l_52, l_58);
    /* statement id: 512 */
    assert (l_838 == 0);
    for (l_43.f1 = 0; (l_43.f1 == 0); l_43.f1 += 3)
    { /* block id: 515 */
        uint32_t l_844 = 4294967291U;
        int32_t *l_853 = &l_839;
        const int32_t *l_861 = &l_839;
        const int32_t **l_860 = &l_861;
        union U1 *l_864 = (void*)0;
        for (l_35 = 0; (l_35 <= (-23)); l_35 -= 4)
        { /* block id: 518 */
            union U1 l_848 = {0xDC4C};
            union U1 *l_847 = &l_848;
            const int32_t *l_854 = &l_839;
            struct S0 ***l_859 = &l_50;
            struct S0 ****l_858 = &l_859;
            if (l_43.f0)
                break;
            if (l_844)
                break;
            for (l_839 = 19; (l_839 <= 24); l_839 += 3)
            { /* block id: 523 */
                union U1 **l_849 = (void*)0;
                union U1 **l_850 = &l_847;
                int32_t **l_855 = &l_838;
                uint32_t l_857 = 4294967295U;
                (*l_850) = l_847;
                (*l_855) = l_854;
                /* statement id: 525 */
                assert (l_838 == &l_839);
                if (l_839)
                    goto lbl_856;
                return l_857;
            }
            (*l_858) = &l_50;
        }
        l_838 = func_72(&l_839, (*l_853));
        /* statement id: 531 */
        assert (l_838 == &l_839);
        (*l_860) = l_853;
        for (l_844 = 0; (l_844 != 30); ++l_844)
        { /* block id: 535 */
            union U1 **l_865 = &l_864;
            const int32_t l_866 = 0xEBFF903F;
            (*l_865) = l_864;
            (*l_860) = &l_839;
            if (l_866)
                break;
        }
    }
    /* facts after for loop */
    assert (l_838 == &l_839 || l_838 == 0);
    return l_867;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_36(struct S0 * p_37, int16_t  p_38, struct S0 * p_39, int32_t  p_40, uint32_t  p_41)
{ /* block id: 38 */
    struct S0 l_47 = {1,-1,-1773};
    struct S0 *l_46 = &l_47;
    return p_39;
    /* statement id: 39 */
    //assert (func_36_rv == &l_43 || func_36_rv == &l_132 || func_36_rv == 0 || func_36_rv == &l_261 || func_36_rv == &l_412 || func_36_rv == &l_635 || func_36_rv == &l_569);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_54(uint16_t  p_55, int32_t * p_56, int32_t * const  p_57)
{ /* block id: 46 */
    int32_t l_61 = 0x0131B3B3;
    struct S0 l_63 = {33,1,318};
    struct S0 *l_62 = &l_63;
    const struct S0 *l_64 = &l_63;
    int32_t *l_837 = (void*)0;
    (*p_57) = ((uint16_t)l_61 >> (uint16_t)(l_62 == l_64));
    for (l_61 = 0; (l_61 <= (-21)); l_61 -= 1)
    { /* block id: 50 */
        union U1 l_80 = {0xA700};
        union U1 l_81 = {0x29F1};
        struct S0 l_97 = {-63,-2,-596};
        uint16_t l_113 = 0xA3AE;
        uint32_t l_232 = 1U;
        int32_t l_249 = 0xAE8D4C1F;
        const int32_t *l_248 = &l_249;
        int32_t *l_836 = &l_249;
        int32_t **l_835 = &l_836;
        (*l_835) = func_67(func_72(func_75(l_80, l_81, ((int16_t)(0 && ((int32_t)l_63.f2 + (int32_t)((int16_t)((((0x328D || ((-(int32_t)(func_89(func_94(l_97, func_98(func_36(&l_97, l_61, func_103(((int32_t)(~((uint16_t)(~((int16_t)(0U == p_55) >> (int16_t)l_63.f1)) << (uint16_t)0)) - (int32_t)l_113)), l_232, l_81.f2), p_55, p_55, l_80)), p_55, p_56, l_248) & (-8))) && p_55)) | 0xE75CD830) ^ 65527U) != (*l_248)) + (int16_t)l_63.f0))) << (int16_t)6), p_55), l_61), &l_62, &l_97, &l_97);
        /* statement id: 508 */
        assert (l_836 == 0);
        if ((*p_56))
            break;
    }
    return l_837;
    /* statement id: 511 */
    //assert (func_54_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_67(float * const  p_68, struct S0 ** p_69, struct S0 * p_70, struct S0 * p_71)
{ /* block id: 504 */
    float l_815 = 0x4.C04871p-5;
    float *l_816 = (void*)0;
    float *l_817 = &l_815;
    int32_t l_826 = 0x26C5374C;
    uint32_t l_829 = 0xC6E1C4F5;
    int32_t *l_833 = &l_826;
    int32_t *l_834 = (void*)0;
    (*l_817) = l_815;
    (*l_833) = ((int16_t)((uint16_t)((uint16_t)(((uint16_t)(l_826 | 65530U) - (uint16_t)((uint32_t)(l_829 > 0xD5FC) - (uint32_t)(-(uint16_t)l_826))) && (l_829 >= ((int16_t)0x81BB >> (int16_t)((l_829 && l_826) >= 0x3107FB6E)))) << (uint16_t)1) % (uint16_t)0xAFAA) >> (int16_t)11);
    return l_834;
    /* statement id: 507 */
    //assert (func_67_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_72(int32_t * p_73, int32_t  p_74)
{ /* block id: 340 */
    struct S0 l_569 = {39,0x82D73AC7,869};
    float *l_570 = (void*)0;
    int32_t l_573 = 0;
    int32_t *l_572 = &l_573;
    union U1 l_623 = {0xE891};
    uint32_t l_642 = 4294967292U;
    uint32_t l_658 = 4294967294U;
    float l_662 = 0x3.Cp+1;
    float *l_661 = &l_662;
    union U1 *l_806 = &l_623;
    union U1 **l_805 = &l_806;
    union U1 ****l_814 = (void*)0;
    if ((__builtin_ctzl((!p_74)) ^ (l_569.f1 & p_74)))
    { /* block id: 341 */
        union U1 l_571 = {-7};
        struct S0 l_618 = {-47,-1,801};
        float l_633 = (-0x3.Ep+1);
        int32_t *l_674 = &l_573;
        float *l_690 = &l_662;
        union U1 **l_708 = (void*)0;
        int16_t l_799 = 1;
        int32_t ***l_804 = (void*)0;
        int32_t **l_812 = &l_572;
        l_572 = func_75(l_571, l_571, l_571.f4, p_74);
        /* statement id: 342 */
        assert (l_572 == 0);
    }
    else
    { /* block id: 499 */
        (*l_572) = (-(int16_t)((void*)0 == &l_569));
    }
    /* facts after branching */
    assert (l_572 == &l_573 || l_572 == 0);
    p_74 = ((void*)0 != l_814);
    return p_73;
    /* statement id: 503 */
    //assert (func_72_rv == 0 || func_72_rv == &l_839);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_75(union U1  p_76, union U1  p_77, int32_t  p_78, int16_t  p_79)
{ /* block id: 203 */
    int32_t l_367 = 1;
    int32_t *l_366 = &l_367;
    int32_t **l_365 = &l_366;
    int32_t *** const l_364 = &l_365;
    union U1 l_379 = {-1};
    union U1 *l_378 = &l_379;
    union U1 ** const l_377 = &l_378;
    union U1 ** const * const l_376 = &l_377;
    struct S0 l_412 = {-7,-8,-1777};
    float *l_435 = (void*)0;
    float **l_434 = &l_435;
    uint32_t l_439 = 0x9E399D35;
    float l_460 = 0xC.1FE54Fp+19;
    int32_t *l_567 = (void*)0;
    for (p_77.f2 = 0; (p_77.f2 == (-8)); --p_77.f2)
    { /* block id: 206 */
        uint32_t l_370 = 0x70C9ECBA;
        int32_t ***l_388 = &l_365;
        struct S0 l_408 = {-81,-1,1653};
        float *l_414 = (void*)0;
        float ***l_523 = &l_434;
    }
    /* facts after for loop */
        return l_567;
    /* statement id: 339 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : l_53
 * writes: l_53
 */
inline static uint16_t  func_89(int32_t * p_90, uint32_t  p_91, float * p_92, const int32_t * p_93)
{ /* block id: 129 */
    uint32_t l_255 = 5U;
    struct S0 l_261 = {-75,0xDD49A4E4,1257};
    struct S0 *l_260 = &l_261;
    int32_t l_268 = 1;
    int32_t *l_267 = &l_268;
    int32_t **l_266 = &l_267;
    int32_t *l_272 = &l_268;
    union U1 l_287 = {-7};
    union U1 *l_286 = &l_287;
    union U1 **l_285 = &l_286;
    int16_t l_290 = 0xE897;
    int32_t ***l_295 = &l_266;
    for (p_91 = (-10); (p_91 < 54); p_91 += 2)
    { /* block id: 132 */
        int32_t l_252 = (-1);
        int32_t *l_257 = &l_252;
        int32_t **l_256 = &l_257;
        struct S0 **l_269 = (void*)0;
        const struct S0 **l_270 = (void*)0;
        struct S0 **l_271 = &l_260;
        for (l_252 = 0; (l_252 >= 9); l_252 += 5)
        { /* block id: 135 */
            return l_255;
        }
        (*l_256) = (void*)0;
        /* statement id: 138 */
        assert (l_257 == 0);
        for (l_255 = (-6); (l_255 <= 23); l_255++)
        { /* block id: 141 */
            (*l_256) = p_92;
            /* statement id: 142 */
            //assert (l_257 == &l_53 || l_257 == &l_367 || l_257 == &l_604 || l_257 == &l_662);
            return (*l_257);
        }
        (*l_271) = func_36(l_260, ((uint32_t)(((int16_t)(l_266 != &p_93) >> (int16_t)(**l_266)) != 6) % (uint32_t)(p_91 & (*p_93))), &l_261, (*p_93), p_91);
    }
lbl_334:
    (*l_266) = l_272;
    /* statement id: 147 */
    assert (l_267 == &l_268);
    if ((((((uint16_t)((int16_t)((int16_t)(((uint16_t)p_91 << (uint16_t)p_91) < ((int16_t)((int32_t)(*l_272) - (int32_t)(*l_267)) >> (int16_t)5)) + (int16_t)((*l_267) != ((((void*)0 != l_285) == ((uint32_t)(**l_266) + (uint32_t)((__builtin_clzl(((void*)0 != p_92)) & (**l_266)) ^ l_290))) == p_91))) - (int16_t)p_91) + (uint16_t)8U) > p_91) && 0x0A04) < (**l_266)))
    { /* block id: 148 */
        struct S0 l_291 = {73,1,1880};
        (*l_267) = 0x8574B2B1;
        (*l_266) = func_94((*l_260), l_291);
        /* statement id: 150 */
        assert (l_267 == 0);
        p_90 = (void*)0;
        /* statement id: 151 */
        assert (p_90 == 0);
    }
    else
    { /* block id: 152 */
        struct S0 l_303 = {-33,1,752};
        union U1 * const *l_315 = &l_286;
        float **l_331 = (void*)0;
        float ***l_330 = &l_331;
        int32_t *l_332 = &l_268;
        uint16_t l_354 = 0x75AE;
        if ((*l_267))
        { /* block id: 153 */
            int32_t ***l_294 = &l_266;
            (*p_92) = (((float)((l_294 != l_295) < ((float)(*p_92) - (float)((float)(((((float)((void*)0 == &l_260) + (float)(*p_92)) > ((*p_92) > (*p_92))) <= ((((0x0.Fp-1 < 0x4.16DD70p-52) != (*p_92)) == (***l_294)) > (***l_295))) == (***l_294)) + (float)(*p_92)))) - (float)0x8.Ep+1) <= (*p_92));
        }
        else
        { /* block id: 155 */
            int32_t ***l_310 = (void*)0;
            int32_t l_311 = 0x3BCDCC49;
            union U1 l_312 = {0x298D};
            struct S0 * const *l_321 = &l_260;
            const int32_t *l_353 = &l_311;
            (*p_92) = 0x9.7p+1;
            if ((p_91 != (*p_93)))
            { /* block id: 157 */
                int32_t **l_302 = &l_267;
                (*l_302) = p_93;
                /* statement id: 158 */
                //assert (l_267 == &l_249 || l_267 == &l_367 || l_267 == &l_392 || l_267 == &l_604 || l_267 == &l_573);
                (*l_302) = func_94(l_303, func_98(&l_303, ((float)0xC.5B9867p-12 + (float)((float)((float)(((&l_266 == l_310) < 0xA.DED8AAp+83) > (*p_92)) - (float)0x7.5B5CE6p-97) - (float)((*l_272) > l_311))), p_91, l_312));
                /* statement id: 159 */
                assert (l_267 == 0);
            }
            else
            { /* block id: 160 */
                float ***l_316 = (void*)0;
                float l_320 = 0x8.78E50Cp+59;
                float *l_319 = &l_320;
                float **l_318 = &l_319;
                float ***l_317 = &l_318;
                (*l_272) = ((int16_t)p_91 << (int16_t)((l_315 == (void*)0) == 4294967295U));
                (*l_317) = &p_92;
                /* statement id: 162 */
                assert (l_318 == &p_92);
            }
            /* facts after branching */
            assert (l_267 == &l_268 || l_267 == 0);
            l_303.f2 = (((void*)0 != l_321) <= ((int16_t)0 << (int16_t)((p_93 != (void*)0) >= 9)));
            if ((p_91 == (0x5910C011 && __builtin_parityl(l_303.f2))))
            { /* block id: 165 */
                int32_t l_333 = 0xD8505F07;
                if (((((int16_t)(&p_90 == &p_90) - (int16_t)((8 == (&l_266 == l_310)) != l_303.f0)) | ((uint32_t)((int16_t)0xBBF9 - (int16_t)(__builtin_popcountl(((void*)0 != l_330)) != 0U)) - (uint32_t)(*p_93))) | 0x7E20))
                { /* block id: 166 */
                    if ((*p_93))
                    { /* block id: 167 */
                        p_90 = l_332;
                        /* statement id: 168 */
                        assert (p_90 == &l_268);
                        (*l_332) = (*p_90);
                        p_90 = (**l_295);
                        /* statement id: 170 */
                        assert (p_90 == &l_268 || p_90 == 0);
                        return l_333;
                    }
                    else
                    { /* block id: 172 */
                        return p_91;
                    }
                }
                else
                { /* block id: 175 */
                    return p_91;
                }
            }
            else
            { /* block id: 178 */
                struct S0 l_335 = {37,0x2AEA3714,1482};
                union U1 **l_351 = (void*)0;
                if (l_290)
                    goto lbl_334;
                p_90 = func_94(l_335, (*l_260));
                /* statement id: 180 */
                assert (p_90 == 0);
                (*l_285) = (void*)0;
                /* statement id: 181 */
                assert (l_286 == 0);
                for (l_287.f2 = 0; (l_287.f2 >= 28); ++l_287.f2)
                { /* block id: 184 */
                    int32_t l_338 = 1;
                    struct S0 l_340 = {-66,2,843};
                    struct S0 *l_339 = &l_340;
                    l_338 = (*p_93);
                    l_339 = &l_303;
                    /* statement id: 186 */
                    assert (l_339 == &l_303);
                    if ((l_338 || ((int32_t)(*p_93) - (int32_t)((p_91 > ((p_91 == (((int32_t)((*l_295) != (void*)0) - (int32_t)(-(int32_t)(l_340.f2 || (((uint16_t)((int32_t)(*p_93) + (int32_t)(l_335.f0 & 4294967295U)) + (uint16_t)0x34BE) ^ (*l_272))))) > p_91)) & (*l_332))) && p_91))))
                    { /* block id: 187 */
                        int32_t **l_350 = &l_332;
                        (*l_350) = p_93;
                        /* statement id: 188 */
                        //assert (l_332 == &l_249 || l_332 == &l_367 || l_332 == &l_392 || l_332 == &l_604 || l_332 == &l_573);
                        return p_91;
                    }
                    else
                    { /* block id: 190 */
                        union U1 ***l_352 = &l_351;
                        (*l_285) = (*l_285);
                        (*l_352) = l_351;
                        l_353 = p_93;
                        /* statement id: 193 */
                        //assert (l_353 == &l_249 || l_353 == &l_367 || l_353 == &l_392 || l_353 == &l_604 || l_353 == &l_573);
                        if ((*l_353))
                            continue;
                    }
                    /* facts after branching */
                    //assert (l_353 == &l_249 || l_353 == &l_367 || l_353 == &l_392 || l_353 == &l_604 || l_353 == &l_573);
                }
                /* facts after for loop */
                                //assert (l_353 == &l_249 || l_353 == &l_311 || l_353 == &l_367 || l_353 == &l_392 || l_353 == &l_604 || l_353 == &l_573);
            }
            /* facts after branching */
            assert (p_90 == 0);
                        assert (l_286 == 0);
            //assert (l_353 == &l_249 || l_353 == &l_311 || l_353 == &l_367 || l_353 == &l_392 || l_353 == &l_604 || l_353 == &l_573);
        }
        /* facts after branching */
        assert (l_267 == &l_268 || l_267 == 0);
        assert (l_286 == 0 || l_286 == &l_287);
        (*p_92) = ((l_354 >= (((((((*p_92) < (*l_332)) != (*l_332)) <= (-(float)(((*p_92) < (*p_92)) < (*p_92)))) != ((float)((float)(*l_332) + (float)__builtin_popcount(p_91)) - (float)0xD.FD0A98p+73)) > (*l_332)) >= 0x2.8A0FC8p-67)) < (*l_332));
        l_260 = &l_303;
        /* statement id: 200 */
        assert (l_260 == &l_303);
    }
    /* facts after branching */
    //assert (l_260 == dangling || l_260 == &l_261);
    assert (l_267 == &l_268 || l_267 == 0);
    assert (l_286 == 0 || l_286 == &l_287);
    return p_91;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_94(struct S0  p_95, struct S0  p_96)
{ /* block id: 126 */
    int32_t l_244 = 0x418FD7A1;
    int32_t *l_243 = &l_244;
    int32_t **l_245 = &l_243;
    int32_t *l_246 = &l_244;
    int32_t *l_247 = (void*)0;
    (*l_245) = l_243;
    return l_247;
    /* statement id: 128 */
    //assert (func_94_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_98(struct S0 * p_99, float  p_100, uint32_t  p_101, union U1  p_102)
{ /* block id: 115 */
    float l_235 = (-0x1.Bp-1);
    int32_t l_238 = 0x0B307BF7;
    int32_t *l_237 = &l_238;
    struct S0 l_242 = {7,-1,1514};
    for (p_102.f1 = (-14); (p_102.f1 <= 27); p_102.f1 += 4)
    { /* block id: 118 */
        float *l_236 = &l_235;
        int32_t **l_239 = &l_237;
        union U1 *l_240 = (void*)0;
        union U1 **l_241 = &l_240;
        (*l_236) = l_235;
        (*l_239) = l_237;
        (*l_241) = l_240;
        (*l_236) = p_102.f1;
    }
    /* facts after for loop */
        (*l_237) = 7;
    return l_242;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_103(int32_t  p_104)
{ /* block id: 51 */
    int32_t l_114 = 0x33997603;
    int32_t l_116 = (-1);
    int32_t *l_115 = &l_116;
    struct S0 l_132 = {18,4,-1848};
    struct S0 *l_131 = &l_132;
    int32_t **l_137 = &l_115;
    int32_t ***l_136 = &l_137;
    union U1 l_143 = {0xC9EF};
    union U1 *l_142 = &l_143;
    union U1 *l_169 = &l_143;
    uint32_t l_205 = 4294967286U;
    struct S0 *l_210 = &l_132;
    struct S0 *l_212 = &l_132;
    struct S0 *l_215 = (void*)0;
    int32_t l_222 = 0xD9F3A56A;
    struct S0 *l_230 = &l_132;
    struct S0 *l_231 = (void*)0;
    if (__builtin_popcountl(l_114))
    { /* block id: 52 */
        int32_t **l_117 = &l_115;
        float l_122 = 0x1.AB1ADFp+23;
        float *l_121 = &l_122;
        float **l_120 = &l_121;
        struct S0 l_129 = {-83,1,480};
        struct S0 *l_128 = &l_129;
        const int32_t *l_141 = &l_116;
        const int32_t **l_140 = &l_141;
        const int32_t ***l_139 = &l_140;
        const int32_t ****l_138 = &l_139;
        (*l_117) = l_115;
        for (l_114 = (-5); (l_114 == (-17)); --l_114)
        { /* block id: 56 */
            float **l_123 = (void*)0;
            struct S0 *l_130 = &l_129;
            struct S0 *l_135 = (void*)0;
            l_123 = l_120;
            /* statement id: 57 */
            assert (l_123 == &l_121);
            for (l_116 = 14; (l_116 == (-28)); l_116 -= 1)
            { /* block id: 60 */
                struct S0 l_127 = {-87,0x4D75DB0C,-806};
                struct S0 *l_126 = &l_127;
                struct S0 *l_133 = &l_129;
                struct S0 *l_134 = &l_127;
                (*l_117) = (void*)0;
                /* statement id: 61 */
                assert (l_115 == 0);
                return l_135;
                /* statement id: 62 */
                //assert (func_103_rv == 0);
            }
        }
        (*l_138) = l_136;
        /* statement id: 65 */
        assert (l_139 == &l_137);
    }
    else
    { /* block id: 66 */
        union U1 **l_144 = &l_142;
        int32_t l_156 = (-4);
        struct S0 *l_172 = &l_132;
        struct S0 *l_208 = &l_132;
        (*l_144) = l_142;
        for (l_143.f0 = 0; (l_143.f0 < 4); l_143.f0 += 7)
        { /* block id: 70 */
            union U1 *l_150 = &l_143;
            int32_t l_166 = (-1);
            struct S0 *l_174 = &l_132;
            int32_t ****l_198 = (void*)0;
            int32_t *****l_197 = &l_198;
            struct S0 *l_209 = &l_132;
            struct S0 *l_213 = &l_132;
            for (l_114 = 19; (l_114 <= 9); --l_114)
            { /* block id: 73 */
                struct S0 **l_149 = &l_131;
                (*l_149) = (void*)0;
                /* statement id: 74 */
                assert (l_131 == 0);
            }
            (*l_144) = l_150;
        }
        /* facts after for loop */
        assert (l_131 == 0 || l_131 == &l_132);
        (***l_136) = ((float)(((float)((float)((((p_104 > (l_156 >= (*l_115))) <= l_222) >= p_104) >= ((float)((float)(l_156 < ((0x0.9p+1 >= ((float)(+(l_156 > p_104)) + (float)(-0x1.9p-1))) >= 0x0.1p-1)) + (float)(**l_137)) - (float)(***l_136))) + (float)0x8.8F7CF6p+23) - (float)l_156) >= 0x6.BF4707p+87) + (float)p_104);
    }
    /* facts after branching */
    assert (l_131 == 0 || l_131 == &l_132);
    return l_231;
    /* statement id: 114 */
    //assert (func_103_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 234
   depth: 1, occurrence: 15
XXX total union variables: 11

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 58
breakdown:
   indirect level: 0, occurrence: 15
   indirect level: 1, occurrence: 38
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 0
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 52
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 48
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 18

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 20
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 2
   depth: 20, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 283

XXX times a variable address is taken: 283
XXX times a pointer is dereferenced on RHS: 136
breakdown:
   depth: 1, occurrence: 82
   depth: 2, occurrence: 22
   depth: 3, occurrence: 21
   depth: 4, occurrence: 4
   depth: 5, occurrence: 7
XXX times a pointer is dereferenced on LHS: 149
breakdown:
   depth: 1, occurrence: 113
   depth: 2, occurrence: 15
   depth: 3, occurrence: 14
   depth: 4, occurrence: 7
XXX times a pointer is compared with null: 37
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 9
XXX times a pointer is qualified to be dereferenced: 505

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 697
   level: 2, occurrence: 86
   level: 3, occurrence: 89
   level: 4, occurrence: 26
   level: 5, occurrence: 20
XXX number of pointers point to pointers: 138
XXX number of pointers point to scalars: 87
XXX number of pointers point to structs: 42
XXX percent of pointers has null in alias set: 26.5
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1073
XXX times a non-volatile is write: 434
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 6

XXX stmts: 110
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 31
   depth: 2, occurrence: 19
   depth: 3, occurrence: 16
   depth: 4, occurrence: 5
   depth: 5, occurrence: 11

XXX percentage a fresh-made variable is used: 18.1
XXX percentage an existing variable is used: 81.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

