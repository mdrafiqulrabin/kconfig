/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3389797852
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 28;
};

struct S1 {
   const uint64_t  f0;
};

#pragma pack(push)
#pragma pack(1)
struct S2 {
   const signed f0 : 16;
};
#pragma pack(pop)

#pragma pack(push)
#pragma pack(1)
struct S3 {
   struct S0  f0;
   uint32_t  f1;
   int64_t  f2;
};
#pragma pack(pop)

struct S4 {
   signed f0 : 1;
   const volatile unsigned f1 : 12;
   const volatile unsigned f2 : 25;
   const volatile unsigned : 0;
   volatile signed f3 : 12;
   volatile signed f4 : 9;
   signed f5 : 12;
   const unsigned f6 : 10;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 7UL;
static int32_t g_24 = (-1L);
static int8_t g_29[5] = {0xBFL,0xBFL,0xBFL,0xBFL,0xBFL};
static int32_t g_31 = (-1L);
static int32_t * volatile g_30 = &g_31;/* VOLATILE GLOBAL g_30 */
static struct S2 g_33 = {183};
static struct S2 g_35 = {68};
static struct S2 *g_34[4] = {&g_35,&g_35,&g_35,&g_35};
static int32_t *g_69 = (void*)0;
static int32_t ** volatile g_68 = &g_69;/* VOLATILE GLOBAL g_68 */
static struct S1 g_86 = {1UL};
static volatile struct S3 g_93[3][2][6] = {{{{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{-5166},0UL,-3L},{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{-5166},0UL,-3L},{{14933},3UL,1L}},{{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{-9878},0UL,0xFCA9972037C870D1LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{-9878},0UL,0xFCA9972037C870D1LL},{{1034},0xB22E0064L,0x57BBF0BED92BB849LL}}},{{{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{-11323},0UL,0x205C6C2786FE95B7LL},{{14933},3UL,1L},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{-11323},0UL,0x205C6C2786FE95B7LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL}},{{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{-5166},0UL,-3L},{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{-5166},0UL,-3L},{{14933},3UL,1L}}},{{{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{-9878},0UL,0xFCA9972037C870D1LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{-9878},0UL,0xFCA9972037C870D1LL},{{1034},0xB22E0064L,0x57BBF0BED92BB849LL}},{{{1034},0xB22E0064L,0x57BBF0BED92BB849LL},{{-11323},0UL,0x205C6C2786FE95B7LL},{{14933},3UL,1L},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL},{{-11323},0UL,0x205C6C2786FE95B7LL},{{7892},0x52A3B4A0L,0xEC100FABB65F0DE3LL}}}};
static struct S0 g_100 = {-13234};
static struct S0 *g_102[8] = {&g_100,&g_100,&g_100,&g_100,&g_100,&g_100,&g_100,&g_100};
static struct S0 ** const  volatile g_101 = &g_102[3];/* VOLATILE GLOBAL g_101 */
static volatile uint16_t g_104 = 0xD7ADL;/* VOLATILE GLOBAL g_104 */
static volatile int32_t **g_110 = (void*)0;
static volatile int32_t ** volatile * volatile g_109 = &g_110;/* VOLATILE GLOBAL g_109 */
static volatile int32_t ** volatile * volatile * volatile g_108 = &g_109;/* VOLATILE GLOBAL g_108 */
static float g_118 = (-0x2.6p+1);
static struct S2 **g_126 = &g_34[2];
static struct S2 *** volatile g_125 = &g_126;/* VOLATILE GLOBAL g_125 */
static volatile struct S4 g_138 = {-0,51,2298,-1,-2,-61,21};/* VOLATILE GLOBAL g_138 */
static int32_t g_145 = 0xA40B5A96L;
static int32_t * const  volatile g_144[10] = {(void*)0,&g_31,(void*)0,&g_31,(void*)0,&g_31,(void*)0,&g_31,(void*)0,&g_31};
static int32_t * volatile g_146 = &g_145;/* VOLATILE GLOBAL g_146 */
static struct S0 ** volatile g_147[6][9][4] = {{{(void*)0,&g_102[3],&g_102[3],(void*)0},{&g_102[3],(void*)0,&g_102[4],&g_102[3]},{&g_102[3],&g_102[4],&g_102[3],&g_102[3]},{(void*)0,&g_102[3],&g_102[3],&g_102[3]},{&g_102[4],&g_102[4],(void*)0,&g_102[3]},{&g_102[3],(void*)0,(void*)0,(void*)0},{&g_102[4],&g_102[3],&g_102[3],(void*)0},{(void*)0,&g_102[3],&g_102[3],(void*)0},{&g_102[3],(void*)0,&g_102[4],&g_102[3]}},{{&g_102[3],&g_102[4],&g_102[3],&g_102[3]},{(void*)0,&g_102[3],&g_102[3],&g_102[3]},{&g_102[4],&g_102[4],(void*)0,&g_102[3]},{&g_102[3],(void*)0,(void*)0,(void*)0},{&g_102[4],&g_102[3],&g_102[3],(void*)0},{(void*)0,&g_102[3],&g_102[3],(void*)0},{&g_102[3],(void*)0,&g_102[4],&g_102[3]},{&g_102[3],&g_102[4],&g_102[3],&g_102[3]},{(void*)0,&g_102[3],&g_102[3],&g_102[3]}},{{&g_102[4],&g_102[4],(void*)0,&g_102[3]},{&g_102[3],(void*)0,(void*)0,(void*)0},{&g_102[4],&g_102[3],&g_102[3],(void*)0},{(void*)0,&g_102[3],&g_102[3],(void*)0},{&g_102[3],(void*)0,&g_102[4],&g_102[3]},{&g_102[3],&g_102[4],&g_102[3],&g_102[3]},{(void*)0,&g_102[3],&g_102[3],&g_102[3]},{&g_102[4],&g_102[4],(void*)0,&g_102[3]},{&g_102[3],(void*)0,(void*)0,(void*)0}},{{&g_102[4],&g_102[3],&g_102[3],(void*)0},{(void*)0,&g_102[3],&g_102[3],(void*)0},{&g_102[3],(void*)0,&g_102[4],&g_102[3]},{&g_102[3],&g_102[4],&g_102[3],&g_102[3]},{(void*)0,&g_102[3],&g_102[3],&g_102[3]},{&g_102[4],&g_102[4],(void*)0,&g_102[3]},{&g_102[3],(void*)0,(void*)0,(void*)0},{&g_102[4],&g_102[3],&g_102[3],(void*)0},{(void*)0,&g_102[3],&g_102[3],(void*)0}},{{&g_102[3],(void*)0,&g_102[4],&g_102[3]},{&g_102[3],&g_102[4],&g_102[3],&g_102[3]},{(void*)0,&g_102[3],&g_102[3],&g_102[3]},{&g_102[4],&g_102[4],(void*)0,&g_102[3]},{&g_102[3],(void*)0,(void*)0,(void*)0},{&g_102[4],&g_102[3],&g_102[3],(void*)0},{(void*)0,&g_102[3],&g_102[3],(void*)0},{&g_102[3],(void*)0,(void*)0,&g_102[3]},{&g_102[3],(void*)0,&g_102[3],(void*)0}},{{&g_102[3],&g_102[3],(void*)0,(void*)0},{(void*)0,(void*)0,&g_102[4],&g_102[3]},{&g_102[3],&g_102[3],&g_102[4],&g_102[3]},{(void*)0,&g_102[3],(void*)0,&g_102[4]},{&g_102[3],&g_102[3],&g_102[3],&g_102[3]},{&g_102[3],&g_102[3],(void*)0,&g_102[3]},{&g_102[3],(void*)0,&g_102[3],(void*)0},{&g_102[3],&g_102[3],(void*)0,(void*)0},{(void*)0,(void*)0,&g_102[4],&g_102[3]}}};
static struct S0 ** volatile g_148 = &g_102[4];/* VOLATILE GLOBAL g_148 */
static struct S4 g_150 = {-0,6,4164,29,-15,-63,27};/* VOLATILE GLOBAL g_150 */
static int32_t g_170 = 1L;
static const struct S2 *g_187[5][9][5] = {{{(void*)0,&g_35,&g_35,&g_35,&g_33},{(void*)0,(void*)0,&g_33,(void*)0,&g_35},{(void*)0,&g_35,&g_33,&g_35,&g_33},{&g_35,(void*)0,&g_33,&g_33,&g_33},{&g_33,&g_33,&g_35,&g_33,(void*)0},{(void*)0,&g_35,&g_33,&g_35,&g_33},{&g_33,&g_33,&g_35,&g_33,&g_35},{&g_33,&g_33,&g_33,&g_33,&g_35},{&g_35,&g_35,&g_33,&g_35,&g_33}},{{&g_35,&g_33,(void*)0,&g_33,(void*)0},{&g_33,&g_35,&g_33,(void*)0,&g_33},{&g_33,&g_35,&g_33,&g_35,&g_35},{&g_33,&g_33,&g_35,&g_35,&g_35},{&g_33,&g_33,(void*)0,&g_35,&g_33},{&g_35,&g_33,&g_35,(void*)0,&g_33},{&g_35,&g_33,&g_35,&g_33,&g_35},{&g_33,(void*)0,&g_33,(void*)0,&g_35},{&g_33,(void*)0,&g_35,&g_33,&g_33}},{{(void*)0,&g_33,&g_35,&g_33,&g_35},{&g_33,&g_33,&g_33,&g_35,&g_33},{&g_35,&g_35,&g_33,&g_35,&g_35},{(void*)0,(void*)0,&g_35,&g_33,&g_35},{(void*)0,&g_35,(void*)0,(void*)0,&g_33},{(void*)0,&g_33,&g_33,&g_35,&g_33},{&g_33,&g_33,&g_33,&g_33,&g_33},{(void*)0,(void*)0,&g_33,&g_33,(void*)0},{(void*)0,(void*)0,&g_35,&g_35,&g_35}},{{(void*)0,&g_33,&g_35,&g_35,(void*)0},{&g_35,&g_33,&g_33,(void*)0,&g_35},{&g_33,&g_33,(void*)0,&g_33,&g_33},{&g_35,&g_33,&g_35,&g_35,&g_33},{&g_33,&g_35,&g_35,&g_35,&g_35},{&g_33,(void*)0,&g_35,&g_33,(void*)0},{&g_35,&g_33,&g_33,&g_35,&g_33},{&g_33,&g_35,&g_33,&g_35,&g_35},{(void*)0,&g_35,(void*)0,&g_33,&g_35}},{{&g_33,&g_33,(void*)0,&g_35,&g_35},{&g_35,(void*)0,&g_33,(void*)0,&g_33},{&g_33,(void*)0,(void*)0,&g_33,&g_35},{&g_35,&g_35,&g_35,&g_33,&g_33},{&g_33,(void*)0,&g_33,&g_35,(void*)0},{&g_33,&g_33,&g_35,&g_33,&g_33},{&g_35,&g_33,(void*)0,&g_33,&g_35},{&g_35,&g_35,&g_33,(void*)0,&g_35},{&g_33,&g_35,&g_33,&g_35,&g_35}}};
static const struct S2 ** volatile g_186 = &g_187[1][6][0];/* VOLATILE GLOBAL g_186 */
static struct S2 ***g_214[9] = {(void*)0,&g_126,(void*)0,(void*)0,&g_126,(void*)0,(void*)0,&g_126,(void*)0};
static struct S2 ****g_213 = &g_214[1];
static struct S2 ***** volatile g_212 = &g_213;/* VOLATILE GLOBAL g_212 */
static struct S0 ** const  volatile *g_231[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static struct S0 ** const  volatile ** volatile g_230 = &g_231[7];/* VOLATILE GLOBAL g_230 */
static int32_t * volatile g_247 = &g_170;/* VOLATILE GLOBAL g_247 */
static struct S0 ** volatile g_265[8][4][1] = {{{(void*)0},{&g_102[3]},{&g_102[3]},{&g_102[6]}},{{&g_102[2]},{&g_102[2]},{&g_102[6]},{&g_102[3]}},{{&g_102[3]},{(void*)0},{(void*)0},{(void*)0}},{{&g_102[3]},{&g_102[3]},{&g_102[6]},{&g_102[2]}},{{&g_102[2]},{&g_102[6]},{&g_102[3]},{&g_102[3]}},{{(void*)0},{(void*)0},{(void*)0},{&g_102[3]}},{{&g_102[3]},{&g_102[6]},{&g_102[2]},{&g_102[2]}},{{&g_102[6]},{&g_102[3]},{&g_102[3]},{(void*)0}}};
static int32_t * volatile g_289 = &g_145;/* VOLATILE GLOBAL g_289 */
static int32_t ** volatile g_294[10] = {&g_69,&g_69,&g_69,&g_69,&g_69,&g_69,&g_69,&g_69,&g_69,&g_69};
static int32_t ** volatile g_295 = &g_69;/* VOLATILE GLOBAL g_295 */
static int32_t ** volatile g_300 = &g_69;/* VOLATILE GLOBAL g_300 */
static int32_t ** volatile g_313 = (void*)0;/* VOLATILE GLOBAL g_313 */
static struct S4 g_327 = {0,57,2121,-10,-18,-38,16};/* VOLATILE GLOBAL g_327 */
static int32_t ** volatile g_334 = (void*)0;/* VOLATILE GLOBAL g_334 */
static int32_t ** const  volatile g_336 = &g_69;/* VOLATILE GLOBAL g_336 */
static float * volatile g_370 = &g_118;/* VOLATILE GLOBAL g_370 */
static struct S4 * const *g_393 = (void*)0;
static struct S4 * const **g_392 = &g_393;
static struct S4 * const *** volatile g_391 = &g_392;/* VOLATILE GLOBAL g_391 */
static int32_t ** volatile g_422 = &g_69;/* VOLATILE GLOBAL g_422 */
static struct S1 *g_426[5][7][3] = {{{(void*)0,&g_86,(void*)0},{&g_86,&g_86,&g_86},{&g_86,(void*)0,&g_86},{&g_86,&g_86,&g_86},{&g_86,(void*)0,(void*)0},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86}},{{&g_86,&g_86,&g_86},{&g_86,&g_86,(void*)0},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,(void*)0,(void*)0},{&g_86,&g_86,&g_86}},{{&g_86,(void*)0,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,(void*)0,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86}},{{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{(void*)0,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86}},{{(void*)0,(void*)0,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86},{(void*)0,&g_86,&g_86},{&g_86,&g_86,&g_86},{&g_86,&g_86,&g_86}}};
static struct S1 ** volatile g_425 = &g_426[1][6][1];/* VOLATILE GLOBAL g_425 */
static int16_t g_436 = 0x4DCFL;
static struct S3 g_438[9] = {{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L},{{-14136},0x5803481BL,8L}};
static struct S4 g_446[2] = {{0,24,3191,48,-7,-38,13},{0,24,3191,48,-7,-38,13}};
static struct S1 g_470 = {0xC29BB03DCEAC51B7LL};


/* --- FORWARD DECLARATIONS --- */
inline static const int32_t  func_26(void);
static const uint16_t  func_36(int32_t * p_37, uint64_t  p_38, float  p_39, uint32_t  p_40);
static uint32_t  func_45(uint32_t  p_46, const int32_t  p_47, int32_t * p_48);
static int32_t * func_49(uint8_t  p_50, int64_t  p_51, uint32_t  p_52, const int8_t  p_53);
static struct S2 * func_56(struct S3  p_57, uint8_t  p_58);
inline static struct S3  func_59(struct S2 * p_60, struct S2 * p_61, const struct S2 * p_62);
static struct S2 * func_63(const struct S3  p_64);
static struct S3  func_65(uint64_t  p_66, uint64_t  p_67);
inline static uint32_t  func_72(int32_t ** p_73, struct S1  p_74, const int32_t  p_75, int64_t  p_76);
inline static int32_t  func_81(uint8_t  p_82, const int32_t  p_83, int32_t  p_84, uint16_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_24 g_3 g_29 g_30 g_31 g_33.f0 g_68 g_35.f0 g_86 g_93 g_101 g_104 g_108 g_125 g_102 g_100 g_138 g_146 g_148 g_126 g_34 g_150.f0 g_170 g_230 g_33 g_145 g_247 g_150.f4 g_150.f5 g_150.f3 g_150.f2 g_289 g_295 g_300 g_150.f1 g_69 g_327 g_109 g_110 g_336 g_186 g_118 g_370 g_391 g_422 g_425 g_436 g_35 g_446 g_470 g_438.f0.f0 g_438.f1 g_426
 * writes: g_24 g_3 g_31 g_34 g_69 g_102 g_118 g_126 g_145 g_170 g_231 g_93 g_187 g_392 g_426 g_438 g_436
 */
inline static const int32_t  func_26(void)
{ /* block id: 36 */
    int64_t l_54[8] = {0x674643A64E785C2FLL,0x674643A64E785C2FLL,0x674643A64E785C2FLL,0x674643A64E785C2FLL,0x674643A64E785C2FLL,0x674643A64E785C2FLL,0x674643A64E785C2FLL,0x674643A64E785C2FLL};
    struct S4 *l_462 = &g_446[0];
    int32_t **l_469 = &g_69;
    uint8_t l_510 = 3UL;
    struct S2 l_518 = {-249};
    int64_t l_547 = 0x995988F2214F5442LL;
    struct S1 *l_548[5] = {&g_470,&g_470,&g_470,&g_470,&g_470};
    struct S1 l_575 = {18446744073709551613UL};
    struct S1 l_576 = {0xA3BD125AAB718662LL};
    struct S3 l_577 = {{10349},0x9B98DB5BL,0x0903C9904E6FF37CLL};
    struct S3 *l_578 = &g_438[7];
    int i;
    for (g_24 = (-19); (g_24 <= (-16)); g_24 = safe_add_func_int64_t_s_s(g_24, 5))
    { /* block id: 39 */
        struct S2 *l_32 = &g_33;
        int32_t l_430 = 0x7138A263L;
        const struct S2 * const *l_449[1][6] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
        const struct S2 * const **l_448[9][10][2] = {{{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]}},{{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]}},{{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]}},{{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]}},{{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]}},{{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][3]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]}},{{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]}},{{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]}},{{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]},{&l_449[0][2],&l_449[0][2]},{&l_449[0][3],&l_449[0][2]},{&l_449[0][2],&l_449[0][3]}}};
        int8_t l_526 = 0xE8L;
        struct S4 *l_546[7][6] = {{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]},{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]},{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]},{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]},{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]},{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]},{&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0],&g_446[0]}};
        uint64_t l_574 = 4UL;
        int i, j, k;
        for (g_3 = 0; (g_3 <= 4); g_3 += 1)
        { /* block id: 42 */
            int32_t *l_41 = &g_31;
            uint32_t l_55 = 0x63CFEBDAL;
            struct S2 *l_439 = &g_35;
            struct S0 l_463 = {4974};
            struct S0 l_477 = {-13665};
            struct S3 l_527 = {{-11613},0x6FBAD27DL,0xFF8DDA350E272AB7LL};
            int i;
            (*g_30) = g_29[g_3];
            g_34[2] = l_32;
            (*l_41) = ((1UL | func_36(l_41, (safe_div_func_uint32_t_u_u(1UL, ((!__builtin_bswap32(func_45(((void*)0 == &g_35), (*l_41), func_49(l_54[4], ((l_55 , func_56(func_59(func_63(func_65(g_33.f0, g_29[0])), l_32, l_32), (*l_41))) == (void*)0), l_54[4], g_35.f0)))) ^ g_327.f0))), g_150.f5, l_430)) > l_54[6]);
            /* statement id: 294 */
            assert (g_69 == &g_170 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_31);
            for (l_55 = 0; (l_55 <= 3); l_55 += 1)
            { /* block id: 297 */
                int32_t **l_434 = &l_41;
                struct S1 l_435 = {0UL};
                struct S3 * const l_437 = &g_438[7];
                struct S0 l_464 = {-6487};
                int64_t l_474 = 4L;
                if (((0xD1L & g_3) , (safe_lshift_func_int8_t_s_s(func_72(l_434, l_435, ((g_436 < l_54[4]) > (((func_45(g_138.f0, g_327.f6, l_41) , l_437) == l_437) < (*l_41))), g_33.f0), 3))))
                { /* block id: 298 */
                    struct S0 **l_442 = (void*)0;
                    struct S0 ***l_441 = &l_442;
                    struct S0 ****l_440 = &l_441;
                    struct S0 ** const * const l_444 = &l_442;
                    struct S0 ** const * const *l_443 = &l_444;
                    struct S2 *l_445 = &g_35;
                    struct S2 ***l_447[6] = {&g_126,&g_126,&g_126,&g_126,&g_126,&g_126};
                    const int32_t l_456 = 1L;
                    int i;
                    (*l_437) = func_59(l_439, ((l_440 != l_443) , l_445), func_56(g_93[0][0][0], (*l_41)));
                    /* statement id: 299 */
                    //assert (g_69 == &g_31 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145);
                    (*l_41) = (2UL < (((g_446[0] , g_93[0][0][0].f2) ^ (l_447[5] != l_448[8][4][1])) <= (safe_rshift_func_int16_t_s_s((safe_mul_func_int16_t_s_s((safe_add_func_int16_t_s_s(l_456, g_29[0])), l_430)), 13))));
                }
                else
                { /* block id: 301 */
                    int64_t l_459 = 0x97046417AEE23EC0LL;
                    struct S4 **l_468 = &l_462;
                    struct S4 ***l_467 = &l_468;
                    int16_t l_473 = 0x4966L;
                    struct S0 l_486[8] = {{14007},{14007},{14007},{14007},{14007},{14007},{14007},{14007}};
                    uint64_t l_507 = 0UL;
                    int i;
                    l_464 = ((safe_sub_func_uint8_t_u_u(((((l_459 & g_327.f1) || (*l_41)) == g_24) , (safe_lshift_func_uint8_t_u_s((l_462 != (void*)0), g_327.f3))), ((0xDBL >= l_430) , (*l_41)))) , l_463);
                    for (g_145 = 3; (g_145 >= 0); g_145 -= 1)
                    { /* block id: 305 */
                        struct S3 *l_476 = (void*)0;
                        struct S3 **l_475 = &l_476;
                        struct S0 *l_478 = &l_464;
                        (*g_422) = l_41;
                        /* statement id: 306 */
                        assert (g_69 == &g_118 || g_69 == &g_31);
                        (*l_41) = (g_446[0].f0 ^ ((g_31 > ((safe_add_func_uint16_t_u_u(((((void*)0 != l_467) > (func_72(l_469, g_470, (safe_div_func_uint64_t_u_u(func_81(l_473, l_430, (l_430 | g_29[2]), g_150.f5), l_430)), (**l_434)) | 0UL)) && g_446[0].f1), g_446[0].f0)) == 1UL)) != l_474));
                        /* statement id: 307 */
                        //assert (g_69 == dangling);
                        (*l_475) = (void*)0;
                        (*l_478) = l_477;
                    }
                    /* facts after for loop */
                    //assert (g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_31);
                    for (g_31 = 3; (g_31 >= 0); g_31 -= 1)
                    { /* block id: 313 */
                        uint16_t l_490 = 0xBD71L;
                        struct S1 l_504 = {0x78B4415FABF194AELL};
                        l_507 = (safe_div_func_uint8_t_u_u((~((safe_mul_func_uint8_t_u_u((safe_sub_func_int32_t_s_s((l_486[0] , ((!(safe_lshift_func_int8_t_s_s(l_490, g_86.f0))) | (safe_lshift_func_uint8_t_u_u((safe_sub_func_uint64_t_u_u(func_81(((safe_lshift_func_uint16_t_u_u((__builtin_parityll((!l_473)) >= l_490), (((l_459 || (safe_rshift_func_uint8_t_u_s((safe_lshift_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((l_504 , (safe_sub_func_int64_t_s_s(((l_430 , l_504.f0) & g_150.f1), (*l_41)))), g_446[0].f5)), 15)), (**l_434)))) | l_504.f0) >= (**l_434)))) | (*l_41)), l_430, (**l_434), g_33.f0), 0x6CAA6866BF250873LL)), l_486[0].f0)))), l_430)), l_486[0].f0)) <= g_327.f5)), g_446[0].f6));
                        /* statement id: 314 */
                        //assert (g_69 == dangling);
                        (*l_469) = &l_430;
                        /* statement id: 315 */
                        assert (g_69 == &l_430);
                        (*g_146) = (safe_mod_func_uint8_t_u_u((**l_434), 0x18L));
                    }
                    /* facts after for loop */
                    //assert (g_69 == &l_430 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_31);
                    if ((*g_289))
                        break;
                }
                /* facts after branching */
                //assert (g_69 == &l_430 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_31);
                if (l_510)
                { /* block id: 320 */
                    for (l_474 = 3; (l_474 >= 0); l_474 -= 1)
                    { /* block id: 323 */
                        struct S0 **l_511 = &g_102[3];
                        float *l_519 = &g_118;
                        (*l_511) = (*g_148);
                        (*l_519) = ((+(safe_sub_func_float_f_f((0x8.9D21E0p+34 > (safe_sub_func_float_f_f((-(**l_434)), (l_518 , (*g_370))))), l_430))) >= g_170);
                        (*l_434) = l_519;
                        /* statement id: 326 */
                        assert (l_41 == &g_118);
                    }
                }
                else
                { /* block id: 328 */
                    (*g_370) = (safe_mul_func_float_f_f(l_430, ((safe_lshift_func_uint8_t_u_s((*l_41), 5)) , 0x0.Ap-1)));
                    (*l_469) = (*l_434);
                    /* statement id: 330 */
                    assert (g_69 == &g_118 || g_69 == &g_31);
                }
                /* facts after branching */
                //assert (g_69 == &g_118 || g_69 == &g_31 || g_69 == &l_430 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145);
                (**l_434) = ((((((safe_mul_func_int8_t_s_s(g_31, __builtin_clzll((*l_41)))) != (l_526 & (l_527 , __builtin_clzl(((g_446[0].f0 , __builtin_parityll(g_446[0].f3)) > (safe_sub_func_uint16_t_u_u(g_446[0].f6, g_470.f0))))))) == l_526) == (*l_41)) , 9UL) <= g_438[7].f0.f0);
            }
            /* facts after for loop */
            //assert (g_69 == &g_118 || g_69 == &g_31 || g_69 == &l_430 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145);
            assert (l_41 == &g_118 || l_41 == &g_31);
        }
        /* facts after for loop */
        //assert (g_69 == &g_118 || g_69 == &g_31 || g_69 == &l_430 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145);
        for (g_436 = 0; (g_436 > 22); g_436 = safe_add_func_uint32_t_u_u(g_436, 1))
        { /* block id: 337 */
            uint64_t l_534 = 0x8FD4153DC0A3C165LL;
            struct S2 **** const l_544[7][5] = {{&g_214[1],&g_214[8],&g_214[2],&g_214[2],&g_214[8]},{&g_214[1],&g_214[3],&g_214[2],&g_214[3],&g_214[3]},{&g_214[3],&g_214[1],&g_214[3],&g_214[2],&g_214[3]},{&g_214[8],&g_214[1],&g_214[3],&g_214[1],&g_214[8]},{&g_214[3],&g_214[1],&g_214[1],&g_214[8],&g_214[1]},{&g_214[1],&g_214[1],&g_214[3],&g_214[8],&g_214[1]},{&g_214[1],&g_214[3],&g_214[3],&g_214[1],&g_214[1]}};
            const struct S4 *l_545 = &g_327;
            int32_t *l_552 = &l_430;
            float *l_564 = (void*)0;
            float *l_565 = &g_118;
            struct S3 *l_573 = &g_438[7];
            int i, j;
            if ((safe_sub_func_uint64_t_u_u((1L != l_534), ((safe_mul_func_uint8_t_u_u(__builtin_popcountl((safe_div_func_uint8_t_u_u(l_430, 0x2BL))), (safe_rshift_func_uint16_t_u_s((l_526 | (~((((safe_rshift_func_int16_t_s_u(((void*)0 != l_544[4][4]), 7)) , l_545) == l_546[2][2]) >= l_430))), l_534)))) | 0xA522300FC23C7B04LL))))
            { /* block id: 338 */
                const uint64_t l_554 = 0x2DFF2899232DE515LL;
                (*l_469) = func_49(g_150.f3, l_547, g_3, g_438[7].f1);
                /* statement id: 339 */
                assert (g_69 == 0 || g_69 == &g_145 || g_69 == &g_170 || g_69 == &g_31);
                if (l_526)
                { /* block id: 340 */
                    l_548[3] = (*g_425);
                    for (l_526 = 0; (l_526 >= 17); l_526 = safe_add_func_int32_t_s_s(l_526, 2))
                    { /* block id: 344 */
                        int64_t l_551 = 4L;
                        (*l_469) = (void*)0;
                        /* statement id: 345 */
                        assert (g_69 == 0);
                        if (l_551)
                            continue;
                        (*l_469) = (void*)0;
                        (*l_469) = l_552;
                        /* statement id: 348 */
                        assert (g_69 == &l_430);
                    }
                    /* facts after for loop */
                    assert (g_69 == &l_430 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_170 || g_69 == &g_31);
                }
                else
                { /* block id: 350 */
                    int64_t l_553[10][4] = {{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L},{0xC5A70D264D60C7CFLL,4L,0xC5A70D264D60C7CFLL,4L}};
                    int i, j;
                    if ((*l_552))
                    { /* block id: 351 */
                        if (l_553[1][3])
                            break;
                        return l_554;
                    }
                    else
                    { /* block id: 354 */
                        float *l_555 = &g_118;
                        (*l_555) = 0x0.9p+1;
                    }
                }
                /* facts after branching */
                assert (g_69 == &l_430 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_170 || g_69 == &g_31);
                (*g_370) = 0x1.3p-1;
                for (g_170 = (-29); (g_170 == 27); g_170 = safe_add_func_int32_t_s_s(g_170, 6))
                { /* block id: 361 */
                    const uint32_t l_563 = 0xC535D38BL;
                    for (l_526 = 0; (l_526 != 23); l_526++)
                    { /* block id: 364 */
                        const uint64_t l_560[2][1][5] = {{{18446744073709551606UL,0x06EC776B19953FFBLL,18446744073709551606UL,18446744073709551606UL,0x06EC776B19953FFBLL}},{{0x06EC776B19953FFBLL,18446744073709551606UL,18446744073709551606UL,0x06EC776B19953FFBLL,18446744073709551606UL}}};
                        volatile struct S3 *l_562 = &g_93[0][0][0];
                        volatile struct S3 **l_561 = &l_562;
                        int i, j, k;
                        (*l_469) = (*g_300);
                        if (l_560[0][0][2])
                            continue;
                        (*l_561) = &g_93[0][0][0];
                        return l_563;
                        /* statement id: 368 */
                        //assert (g_69 == dangling || g_69 == 0 || g_69 == &g_145 || g_69 == &g_170 || g_69 == &g_31);
                    }
                }
            }
            else
            { /* block id: 371 */
                (*l_469) = &l_430;
                /* statement id: 372 */
                assert (g_69 == &l_430);
            }
            /* facts after branching */
            assert (g_69 == &l_430 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_170 || g_69 == &g_31);
            (*l_565) = (*g_370);
            (*l_552) = (((*g_425) == ((((!(safe_mod_func_int8_t_s_s((-2L), (safe_mul_func_int16_t_s_s(l_430, (safe_add_func_uint8_t_u_u((*l_552), ((((g_170 , l_573) == &g_438[7]) > ((*l_552) >= (*l_552))) , 255UL)))))))) & 18446744073709551615UL) >= l_574) , (void*)0)) ^ l_430);
        }
    }
    /* facts after for loop */
    //assert (g_34[0] == &g_33 || g_34[0] == &g_35);
    //assert (g_69 == &g_118 || g_69 == &g_31 || g_69 == dangling || g_69 == &g_170 || g_69 == 0 || g_69 == &g_145);
    //assert (g_392 == dangling || g_392 == &g_393);
    //assert (l_548[0] == 0 || l_548[0] == &g_86 || l_548[0] == &g_470);
    (*l_578) = ((l_575 , l_576) , l_577);
    return l_54[0];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_31
 */
static const uint16_t  func_36(int32_t * p_37, uint64_t  p_38, float  p_39, uint32_t  p_40)
{ /* block id: 291 */
    const uint64_t l_431 = 0UL;
    (*p_37) = 0x662EEB63L;
    return l_431;
}


/* ------------------------------------------ */
/* 
 * reads : g_68 g_425 g_93 g_247
 * writes: g_69 g_426 g_170
 */
static uint32_t  func_45(uint32_t  p_46, const int32_t  p_47, int32_t * p_48)
{ /* block id: 285 */
    int32_t * const l_423[3][8][2] = {{{(void*)0,&g_170},{&g_170,&g_170},{(void*)0,(void*)0},{(void*)0,&g_170},{&g_170,&g_170},{(void*)0,(void*)0},{(void*)0,&g_170},{&g_170,&g_170}},{{(void*)0,(void*)0},{(void*)0,&g_170},{&g_170,&g_170},{(void*)0,(void*)0},{(void*)0,&g_170},{&g_170,&g_170},{(void*)0,(void*)0},{(void*)0,&g_170}},{{&g_170,&g_170},{(void*)0,(void*)0},{(void*)0,&g_170},{&g_170,&g_170},{(void*)0,(void*)0},{(void*)0,&g_170},{&g_170,&g_170},{(void*)0,(void*)0}}};
    struct S1 *l_424 = &g_86;
    struct S2 *l_427[1];
    volatile struct S3 l_428 = {{11565},0xDD39F43AL,0L};/* VOLATILE GLOBAL l_428 */
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_427[i] = (void*)0;
    (*g_68) = l_423[0][2][1];
    /* statement id: 286 */
    assert (g_69 == &g_170 || g_69 == 0 || g_69 == &g_145 || g_69 == &g_31);
    (*g_425) = l_424;
    l_428 = g_93[0][1][3];
    (*g_247) = (!p_46);
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads : g_170 g_31 g_327 g_138.f6 g_108 g_109 g_110 g_336 g_101 g_102 g_148 g_125 g_126 g_34 g_186 g_138.f4 g_138.f2 g_33.f0 g_68 g_30 g_100.f0 g_150.f0 g_93 g_24 g_145 g_150.f4 g_35.f0 g_3 g_118 g_370 g_100 g_138.f1 g_391 g_86 g_422
 * writes: g_170 g_145 g_69 g_102 g_187 g_34 g_118 g_392
 */
static int32_t * func_49(uint8_t  p_50, int64_t  p_51, uint32_t  p_52, const int8_t  p_53)
{ /* block id: 203 */
    int32_t *l_312 = &g_31;
    int32_t *l_316 = &g_170;
    int8_t l_330 = 0L;
    const struct S3 l_337 = {{-7942},0xD0F93ABBL,3L};
    const int16_t l_346 = 9L;
    uint64_t l_348 = 8UL;
    struct S1 l_382 = {18446744073709551615UL};
    struct S2 l_413 = {-43};
lbl_350:
    for (g_170 = (-3); (g_170 < (-13)); g_170 = safe_sub_func_int16_t_s_s(g_170, 1))
    { /* block id: 206 */
        int32_t **l_314[3];
        int32_t *l_315 = &g_145;
        int i;
        for (i = 0; i < 3; i++)
            l_314[i] = &l_312;
        l_315 = l_312;
        /* statement id: 207 */
        assert (l_315 == &g_170 || l_315 == &g_31);
    }
    (*l_316) = 0L;
    if ((safe_rshift_func_int16_t_s_s((safe_mul_func_uint8_t_u_u(((safe_sub_func_uint32_t_u_u((safe_div_func_uint32_t_u_u((*l_312), (safe_lshift_func_uint16_t_u_u(((((-1L) >= (g_327 , g_138.f6)) , (safe_sub_func_int8_t_s_s(l_330, ((void*)0 != (**g_108))))) ^ (p_51 > (*l_316))), 8)))), p_50)) != p_50), p_52)), 11)))
    { /* block id: 210 */
        uint32_t l_331 = 0xF7DE83CDL;
        struct S3 l_349[5][6][8] = {{{{{14490},0xEFF61B5CL,-1L},{{9674},0xE44AAF06L,0x9D71EDCD745B0FD3LL},{{-14052},0x76129431L,-1L},{{6151},0xB7A5CB41L,0xA043479AC902462ELL},{{-14052},0x76129431L,-1L},{{9674},0xE44AAF06L,0x9D71EDCD745B0FD3LL},{{14490},0xEFF61B5CL,-1L},{{1697},0x0529A7F6L,0x78300466A71E6CCELL}},{{{-14594},0x27D8071DL,0xC7E64A294E479D4ELL},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{15019},0xB8D4C38BL,0x94ED0EE743CE0F5DLL},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{1697},0x0529A7F6L,0x78300466A71E6CCELL},{{13245},4294967288UL,1L},{{-9350},0x948C1EE8L,0L}},{{{-333},4294967295UL,0xAFD24010D5A0BD07LL},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{284},0x5C99ABEBL,0x5CEC5E8B7BA38162LL},{{-9301},1UL,0x87B82D645F78BC29LL},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{5009},4294967293UL,1L},{{-9609},0xB4C4A82BL,0xE37A365199B7FE03LL},{{6151},0xB7A5CB41L,0xA043479AC902462ELL}},{{{-14594},0x27D8071DL,0xC7E64A294E479D4ELL},{{6151},0xB7A5CB41L,0xA043479AC902462ELL},{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{-9350},0x948C1EE8L,0L},{{-14052},0x76129431L,-1L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{3442},8UL,0x33A935475D525E5ELL}},{{{14490},0xEFF61B5CL,-1L},{{-9332},4UL,0x79C26755BE2AC025LL},{{-5241},1UL,0L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-389},4UL,1L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-5241},1UL,0L},{{-9332},4UL,0x79C26755BE2AC025LL}},{{{-3318},0x75D45A3CL,0x206CAF53FA4B1D6FLL},{{6151},0xB7A5CB41L,0xA043479AC902462ELL},{{7516},4294967288UL,-6L},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL},{{-14594},0x27D8071DL,0xC7E64A294E479D4ELL},{{5009},4294967293UL,1L},{{-14052},0x76129431L,-1L},{{8283},1UL,0L}}},{{{{16001},2UL,1L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{-3318},0x75D45A3CL,0x206CAF53FA4B1D6FLL},{{1697},0x0529A7F6L,0x78300466A71E6CCELL},{{-14052},0x76129431L,-1L},{{-9301},1UL,0x87B82D645F78BC29LL}},{{{-14052},0x76129431L,-1L},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{7516},4294967288UL,-6L},{{5009},4294967293UL,1L},{{5049},4294967295UL,-2L},{{9674},0xE44AAF06L,0x9D71EDCD745B0FD3LL},{{-5241},1UL,0L},{{-14011},0xF88D794CL,1L}},{{{5049},4294967295UL,-2L},{{9674},0xE44AAF06L,0x9D71EDCD745B0FD3LL},{{-5241},1UL,0L},{{-14011},0xF88D794CL,1L},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{-9301},1UL,0x87B82D645F78BC29LL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{-14011},0xF88D794CL,1L}},{{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{3442},8UL,0x33A935475D525E5ELL},{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{5009},4294967293UL,1L},{{13245},4294967288UL,1L},{{-9332},4UL,0x79C26755BE2AC025LL},{{-9609},0xB4C4A82BL,0xE37A365199B7FE03LL},{{-9301},1UL,0x87B82D645F78BC29LL}},{{{11623},0x3AF5D0D1L,0x94D5D57F93FD72EFLL},{{-8430},4294967295UL,0x771B17EABBAE327DLL},{{284},0x5C99ABEBL,0x5CEC5E8B7BA38162LL},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{-5241},1UL,0L},{{-6518},0xD49372ABL,0x182B63C7F4124107LL},{{13245},4294967288UL,1L},{{8283},1UL,0L}},{{{11623},0x3AF5D0D1L,0x94D5D57F93FD72EFLL},{{-2085},0UL,0xA53A14165B2EF04DLL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL},{{13245},4294967288UL,1L},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{14490},0xEFF61B5CL,-1L},{{-9332},4UL,0x79C26755BE2AC025LL}}},{{{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{-9350},0x948C1EE8L,0L},{{-14052},0x76129431L,-1L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{3442},8UL,0x33A935475D525E5ELL},{{16001},2UL,1L},{{3442},8UL,0x33A935475D525E5ELL}},{{{5049},4294967295UL,-2L},{{-9350},0x948C1EE8L,0L},{{14490},0xEFF61B5CL,-1L},{{-9350},0x948C1EE8L,0L},{{5049},4294967295UL,-2L},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{11623},0x3AF5D0D1L,0x94D5D57F93FD72EFLL},{{6151},0xB7A5CB41L,0xA043479AC902462ELL}},{{{-14052},0x76129431L,-1L},{{-2085},0UL,0xA53A14165B2EF04DLL},{{5049},4294967295UL,-2L},{{-9301},1UL,0x87B82D645F78BC29LL},{{-3318},0x75D45A3CL,0x206CAF53FA4B1D6FLL},{{-6518},0xD49372ABL,0x182B63C7F4124107LL},{{-389},4UL,1L},{{-9350},0x948C1EE8L,0L}},{{{16001},2UL,1L},{{-2085},0UL,0xA53A14165B2EF04DLL},{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{9674},0xE44AAF06L,0x9D71EDCD745B0FD3LL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{-9350},0x948C1EE8L,0L},{{-3318},0x75D45A3CL,0x206CAF53FA4B1D6FLL},{{5009},4294967293UL,1L}},{{{284},0x5C99ABEBL,0x5CEC5E8B7BA38162LL},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-333},4294967295UL,0xAFD24010D5A0BD07LL},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL},{{-14052},0x76129431L,-1L},{{15019},0xB8D4C38BL,0x94ED0EE743CE0F5DLL},{{-389},4UL,1L},{{-14011},0xF88D794CL,1L}},{{{-333},4294967295UL,0xAFD24010D5A0BD07LL},{{-6518},0xD49372ABL,0x182B63C7F4124107LL},{{14490},0xEFF61B5CL,-1L},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL},{{14490},0xEFF61B5CL,-1L},{{-6518},0xD49372ABL,0x182B63C7F4124107LL},{{-333},4294967295UL,0xAFD24010D5A0BD07LL},{{5009},4294967293UL,1L}}},{{{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{-14011},0xF88D794CL,1L},{{-5241},1UL,0L},{{9674},0xE44AAF06L,0x9D71EDCD745B0FD3LL},{{5049},4294967295UL,-2L},{{5009},4294967293UL,1L},{{7516},4294967288UL,-6L},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL}},{{{11623},0x3AF5D0D1L,0x94D5D57F93FD72EFLL},{{-9332},4UL,0x79C26755BE2AC025LL},{{-14594},0x27D8071DL,0xC7E64A294E479D4ELL},{{15019},0xB8D4C38BL,0x94ED0EE743CE0F5DLL},{{5049},4294967295UL,-2L},{{-8430},4294967295UL,0x771B17EABBAE327DLL},{{16001},2UL,1L},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL}},{{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL},{{13245},4294967288UL,1L},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{14490},0xEFF61B5CL,-1L},{{-9332},4UL,0x79C26755BE2AC025LL},{{-5241},1UL,0L},{{3877},0xF412A1E5L,0x621A295A454E6242LL}},{{{-333},4294967295UL,0xAFD24010D5A0BD07LL},{{-9350},0x948C1EE8L,0L},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{-9332},4UL,0x79C26755BE2AC025LL},{{-14052},0x76129431L,-1L},{{-9332},4UL,0x79C26755BE2AC025LL},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{-9350},0x948C1EE8L,0L}},{{{284},0x5C99ABEBL,0x5CEC5E8B7BA38162LL},{{2042},0x69E9B267L,0x286EEC79FE2DEC39LL},{{-9609},0xB4C4A82BL,0xE37A365199B7FE03LL},{{1697},0x0529A7F6L,0x78300466A71E6CCELL},{{-15437},4294967295UL,0x97A130FDB2BAECEELL},{{-8430},4294967295UL,0x771B17EABBAE327DLL},{{14490},0xEFF61B5CL,-1L},{{-9301},1UL,0x87B82D645F78BC29LL}},{{{-389},4UL,1L},{{-9332},4UL,0x79C26755BE2AC025LL},{{5049},4294967295UL,-2L},{{-14011},0xF88D794CL,1L},{{284},0x5C99ABEBL,0x5CEC5E8B7BA38162LL},{{5009},4294967293UL,1L},{{14490},0xEFF61B5CL,-1L},{{15019},0xB8D4C38BL,0x94ED0EE743CE0F5DLL}}},{{{{14490},0xEFF61B5CL,-1L},{{-14011},0xF88D794CL,1L},{{-9609},0xB4C4A82BL,0xE37A365199B7FE03LL},{{-8430},4294967295UL,0x771B17EABBAE327DLL},{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{-6518},0xD49372ABL,0x182B63C7F4124107LL},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{6151},0xB7A5CB41L,0xA043479AC902462ELL}},{{{-725},0xC60E40DFL,0xCF5C3F5A57995A96LL},{{-6518},0xD49372ABL,0x182B63C7F4124107LL},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{6151},0xB7A5CB41L,0xA043479AC902462ELL},{{-5241},1UL,0L},{{15019},0xB8D4C38BL,0x94ED0EE743CE0F5DLL},{{-5241},1UL,0L},{{6151},0xB7A5CB41L,0xA043479AC902462ELL}},{{{13245},4294967288UL,1L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{13245},4294967288UL,1L},{{-8430},4294967295UL,0x771B17EABBAE327DLL},{{7516},4294967288UL,-6L},{{-9350},0x948C1EE8L,0L},{{16001},2UL,1L},{{15019},0xB8D4C38BL,0x94ED0EE743CE0F5DLL}},{{{-3318},0x75D45A3CL,0x206CAF53FA4B1D6FLL},{{-2085},0UL,0xA53A14165B2EF04DLL},{{-14594},0x27D8071DL,0xC7E64A294E479D4ELL},{{-14011},0xF88D794CL,1L},{{-1393},0x5C37B45CL,0x8BDE9DC1AA430478LL},{{3442},8UL,0x33A935475D525E5ELL},{{7516},4294967288UL,-6L},{{-9301},1UL,0x87B82D645F78BC29LL}},{{{-3318},0x75D45A3CL,0x206CAF53FA4B1D6FLL},{{8283},1UL,0L},{{-5241},1UL,0L},{{1697},0x0529A7F6L,0x78300466A71E6CCELL},{{7516},4294967288UL,-6L},{{-14011},0xF88D794CL,1L},{{-333},4294967295UL,0xAFD24010D5A0BD07LL},{{-9350},0x948C1EE8L,0L}},{{{13245},4294967288UL,1L},{{-370},0x561FC705L,0xBADFCFCD1B16B52ELL},{{14490},0xEFF61B5CL,-1L},{{-9332},4UL,0x79C26755BE2AC025LL},{{-5241},1UL,0L},{{3877},0xF412A1E5L,0x621A295A454E6242LL},{{-389},4UL,1L},{{3877},0xF412A1E5L,0x621A295A454E6242LL}}}};
        struct S1 l_351 = {0x12D965E72275C3BDLL};
        int32_t *l_372 = &g_170;
        int i, j, k;
        for (g_145 = 7; (g_145 >= 3); g_145 -= 1)
        { /* block id: 213 */
            uint16_t l_332 = 65527UL;
            struct S1 l_339 = {18446744073709551606UL};
            int32_t l_347[4];
            int i;
            for (i = 0; i < 4; i++)
                l_347[i] = 1L;
            for (p_50 = 0; (p_50 <= 3); p_50 += 1)
            { /* block id: 216 */
                int32_t * const l_333 = &g_170;
                int32_t **l_335[4][8] = {{&g_69,&l_312,&l_316,&l_312,&g_69,&g_69,&g_69,&l_312},{&g_69,&l_312,&g_69,&l_312,&g_69,&l_312,&g_69,&l_312},{&g_69,&l_312,&g_69,&l_312,&g_69,&l_312,&g_69,&l_312},{&g_69,&l_312,&l_316,&l_312,&g_69,&g_69,&g_69,&l_312}};
                int i, j;
                (*g_336) = ((l_331 || l_332) , l_333);
                /* statement id: 217 */
                assert (g_69 == &g_170);
                (*g_186) = func_63(l_337);
                for (p_51 = 3; (p_51 >= 0); p_51 -= 1)
                { /* block id: 221 */
                    return l_312;
                    /* statement id: 222 */
                    //assert (func_49_rv == &g_170 || func_49_rv == &g_31);
                }
            }
            for (g_170 = 8; (g_170 >= 2); g_170 -= 1)
            { /* block id: 227 */
                int32_t **l_338 = &l_312;
                if (p_53)
                    break;
                (*g_126) = func_63(((func_72(l_338, l_339, (((safe_div_func_int32_t_s_s(func_81((__builtin_ctz(g_138.f4) , (safe_div_func_uint16_t_u_u((g_138.f2 < (safe_sub_func_int64_t_s_s((l_346 | ((l_347[3] ^ 8UL) , l_331)), (**l_338)))), p_51))), p_50, l_348, (**l_338)), g_100.f0)) , l_349[0][3][4]) , p_53), g_150.f0) || g_31) , g_93[0][0][0]));
                /* statement id: 229 */
                //assert (g_69 == dangling);
                if (g_145)
                    goto lbl_350;
                for (l_330 = 6; (l_330 >= 0); l_330 -= 1)
                { /* block id: 233 */
                    int32_t l_354 = 6L;
                    for (l_331 = 0; (l_331 <= 3); l_331 += 1)
                    { /* block id: 236 */
                        int32_t l_357 = 0xCAA5BAC8L;
                        float *l_371 = &g_118;
                        (*g_370) = (l_351 , ((safe_div_func_float_f_f((((((l_354 , (p_53 , (safe_div_func_float_f_f((l_357 <= (safe_mul_func_float_f_f(p_51, ((safe_sub_func_float_f_f((safe_mul_func_float_f_f((p_51 , (safe_sub_func_float_f_f(((((safe_sub_func_float_f_f(((*l_312) != g_150.f4), __builtin_popcountl(((((safe_sub_func_int16_t_s_s(((((g_35.f0 & 1UL) > l_354) >= l_354) , p_50), 0x2CCAL)) <= 1L) <= 0L) >= 0x1155CD829BEC043ALL)))) != g_3) < p_51) >= p_51), l_349[0][3][4].f0.f0))), p_53)), g_118)) == 0x9.977394p+2)))), g_327.f6)))) < l_357) <= (*l_316)) >= (*l_312)) > p_53), g_35.f0)) != p_51));
                        (*g_370) = (l_371 == l_316);
                        l_354 = (-1L);
                    }
                    (*l_338) = l_372;
                    /* statement id: 241 */
                    assert (l_312 == &g_170);
                }
            }
        }
    }
    else
    { /* block id: 245 */
        struct S3 l_379 = {{1269},7UL,0x7B25B12C8D474819LL};
        int32_t *l_383 = &g_145;
        int32_t **l_421 = (void*)0;
lbl_420:
        for (p_50 = 3; (p_50 <= 9); p_50 += 1)
        { /* block id: 248 */
            struct S3 *l_380 = &l_379;
            int32_t **l_381 = &l_312;
            int64_t l_386 = 0xDDA21348D3741AECLL;
            int64_t l_387[3];
            float l_418 = 0x5.5p-1;
            int i;
            for (i = 0; i < 3; i++)
                l_387[i] = (-9L);
            (*l_316) = func_72((((safe_mod_func_uint32_t_u_u(((safe_mul_func_int8_t_s_s((safe_rshift_func_int16_t_s_s((l_379 , (l_380 != &l_337)), 4)), 0xA4L)) || p_52), func_72(l_381, l_382, (*l_316), ((((**g_148) , (-1L)) == 0x54E1C756387B3942LL) & p_52)))) != g_100.f0) , (void*)0), l_382, p_53, p_51);
            (*l_381) = (*l_381);
            l_312 = l_312;
            (*l_381) = l_383;
            /* statement id: 252 */
            assert (l_312 == &g_145);
            for (p_52 = 0; (p_52 <= 1); p_52 += 1)
            { /* block id: 255 */
                int32_t *l_384 = (void*)0;
                struct S2 l_412 = {-119};
                (*l_381) = l_312;
                (*l_381) = (*l_381);
                for (p_51 = 0; (p_51 <= 9); p_51 += 1)
                { /* block id: 260 */
                    (*l_381) = (g_35.f0 , l_384);
                    /* statement id: 261 */
                    assert (l_312 == 0);
                }
                if ((~(__builtin_parityll(g_138.f1) , l_386)))
                { /* block id: 263 */
                    return l_312;
                    /* statement id: 264 */
                    //assert (func_49_rv == 0 || func_49_rv == &g_145);
                }
                else
                { /* block id: 265 */
                    struct S4 * const l_390 = (void*)0;
                    struct S4 * const *l_389 = &l_390;
                    struct S4 * const **l_388 = &l_389;
                    (*l_316) = l_387[1];
                    for (l_379.f2 = 0; (l_379.f2 <= 1); l_379.f2 += 1)
                    { /* block id: 269 */
                        (*g_391) = l_388;
                        /* statement id: 270 */
                        assert (g_392 == &l_389);
                    }
                    /* facts after for loop */
                    //assert (g_392 == &l_389 || g_392 == dangling || g_392 == &g_393);
                }
                for (l_379.f1 = 0; (l_379.f1 <= 9); l_379.f1 += 1)
                { /* block id: 275 */
                    uint8_t l_407 = 0x63L;
                    struct S3 **l_419 = &l_380;
                    (*l_316) = (safe_sub_func_int8_t_s_s(((+(safe_rshift_func_uint8_t_u_s((((safe_div_func_int8_t_s_s((-1L), (safe_mul_func_int8_t_s_s((safe_rshift_func_uint8_t_u_u(p_53, 6)), ((safe_sub_func_float_f_f((*g_370), (__builtin_ctzll((l_407 == (safe_sub_func_int8_t_s_s(g_24, ((((safe_add_func_uint64_t_u_u((l_412 , (l_413 , __builtin_popcount((p_51 , (safe_rshift_func_uint8_t_u_u((((((safe_add_func_uint64_t_u_u(((l_407 , 0xB39CL) == 0UL), p_53)) > (*l_383)) < g_35.f0) && (*l_316)) > g_327.f6), 6)))))), p_52)) || 248UL) < (*l_383)) , (*l_383)))))) == (-0x4.0p-1)))) , g_138.f2))))) , g_170) & p_53), 7))) <= p_51), l_407));
                    (*l_419) = (g_86 , (void*)0);
                    /* statement id: 277 */
                    assert (l_380 == 0);
                }
            }
            /* facts after for loop */
            assert (l_312 == 0 || l_312 == &g_145);
            assert (l_380 == 0 || l_380 == &l_379);
            if (l_379.f0.f0)
                goto lbl_420;
        }
        (*g_422) = l_312;
        /* statement id: 282 */
        assert (g_69 == 0 || g_69 == &g_145 || g_69 == &g_170 || g_69 == &g_31);
    }
    /* facts after branching */
    assert (l_312 == 0 || l_312 == &g_145 || l_312 == &g_170 || l_312 == &g_31);
    return l_316;
    /* statement id: 284 */
    //assert (func_49_rv == &g_170);
}


/* ------------------------------------------ */
/* 
 * reads : g_138.f4 g_33.f0 g_68 g_30 g_31 g_150.f0 g_170 g_29 g_150.f3 g_150.f4 g_150.f2 g_289 g_295 g_146 g_145 g_300 g_150.f1 g_69 g_93 g_34
 * writes: g_69 g_118 g_170 g_145 g_93
 */
static struct S2 * func_56(struct S3  p_57, uint8_t  p_58)
{ /* block id: 156 */
    struct S2 **l_273 = &g_34[2];
    int32_t l_275 = 0x1840488CL;
    uint32_t l_277[2];
    float *l_278 = &g_118;
    int i;
    for (i = 0; i < 2; i++)
        l_277[i] = 0x8A7F0C48L;
    (*l_278) = (safe_div_func_float_f_f((((((-((safe_sub_func_float_f_f(((__builtin_parityl(func_81((safe_mul_func_int8_t_s_s((g_138.f4 | 0x331DL), (l_273 != l_273))), (~p_58), l_275, ((safe_unary_minus_func_uint32_t_u(p_57.f1)) && 0x5E92B72CL))) > p_57.f2) <= l_277[1]), 0x8.4p-1)) == p_57.f0.f0)) == g_150.f0) == g_170) > g_170) <= 0x1.Bp+1), g_29[2]));
    /* statement id: 157 */
    //assert (g_69 == dangling);
    (*l_278) = p_58;
    for (l_275 = (-9); (l_275 == (-23)); l_275 = safe_sub_func_uint64_t_u_u(l_275, 9))
    { /* block id: 161 */
        struct S2 **l_297[1];
        int32_t l_298 = 0x4BAB456FL;
        struct S2 *l_301[8] = {&g_33,&g_33,&g_33,&g_33,&g_33,&g_33,&g_33,&g_33};
        int i;
        for (i = 0; i < 1; i++)
            l_297[i] = (void*)0;
        for (g_170 = 0; (g_170 == 7); ++g_170)
        { /* block id: 164 */
            int32_t l_285 = 1L;
            if (p_57.f1)
            { /* block id: 165 */
                int32_t *l_288 = (void*)0;
                (*g_289) = (safe_rshift_func_uint16_t_u_u((0xBE574F6EL > (((l_285 != (g_150.f3 , (safe_add_func_int64_t_s_s(p_57.f0.f0, g_150.f4)))) || g_150.f2) >= (&g_213 == (void*)0))), 15));
                for (g_145 = 0; (g_145 < 17); ++g_145)
                { /* block id: 169 */
                    for (p_58 = 0; (p_58 == 6); ++p_58)
                    { /* block id: 172 */
                        if (p_58)
                            break;
                    }
                }
                if (l_275)
                    continue;
            }
            else
            { /* block id: 177 */
                (*g_295) = &l_275;
                /* statement id: 178 */
                assert (g_69 == &l_275);
                (*l_278) = 0x7.BA915Ap+62;
            }
            for (p_58 = 0; (p_58 <= 3); p_58 += 1)
            { /* block id: 183 */
                int32_t *l_299 = &g_145;
                const struct S0 ****l_305 = (void*)0;
                for (p_57.f1 = 0; (p_57.f1 <= 1); p_57.f1 += 1)
                { /* block id: 186 */
                    int i;
                    l_298 = ((l_277[p_57.f1] , ((+((*g_146) , l_285)) , l_273)) != l_297[0]);
                }
                (*g_300) = l_299;
                /* statement id: 189 */
                assert (g_69 == &g_145);
                for (g_145 = 0; (g_145 <= 0); g_145 += 1)
                { /* block id: 192 */
                    struct S3 l_304 = {{-2891},4294967295UL,0L};
                    int32_t *l_308 = &l_285;
                    volatile struct S3 *l_309 = &g_93[2][1][1];
                    int i;
                    (*l_308) = (((((((void*)0 != l_301[3]) , (safe_sub_func_int8_t_s_s(((l_304 , l_305) != (void*)0), (-10L)))) , __builtin_popcount(p_58)) || (safe_sub_func_int8_t_s_s(g_150.f1, p_58))) , (*g_30)) & (*g_69));
                    if ((**g_300))
                        break;
                    (*l_309) = (p_57.f0 , g_93[0][0][0]);
                }
                (*l_299) = 0x46161DA2L;
            }
        }
        /* facts after for loop */
        //assert (g_69 == &g_145 || g_69 == &l_275 || g_69 == dangling);
        return (*l_273);
        /* statement id: 200 */
        //assert (g_69 == &g_145 || g_69 == dangling);
        //assert (func_56_rv == &g_33 || func_56_rv == &g_35);
    }
    return (*l_273);
    /* statement id: 202 */
    //assert (func_56_rv == &g_33 || func_56_rv == &g_35);
}


/* ------------------------------------------ */
/* 
 * reads : g_30 g_31 g_86.f0 g_150.f0 g_100.f0 g_33.f0 g_170 g_230 g_33 g_93.f2 g_145 g_68 g_35.f0 g_3 g_86 g_24 g_93 g_101 g_104 g_108 g_29 g_125 g_102 g_100 g_138 g_146 g_247 g_150.f4 g_150.f5 g_35
 * writes: g_170 g_69 g_231 g_102 g_118 g_126 g_145
 */
inline static struct S3  func_59(struct S2 * p_60, struct S2 * p_61, const struct S2 * p_62)
{ /* block id: 91 */
    struct S4 *l_149 = &g_150;
    struct S4 **l_151 = &l_149;
    int32_t **l_154 = &g_69;
    int32_t ***l_153 = &l_154;
    int32_t ****l_152 = &l_153;
    int8_t l_159 = 0x2EL;
    uint64_t l_168 = 1UL;
    uint16_t l_169 = 0UL;
    uint32_t l_171[7] = {0UL,0xB97BFFB8L,0xB97BFFB8L,0UL,0xB97BFFB8L,0xB97BFFB8L,0UL};
    struct S2 ***l_211[3][10] = {{&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126},{&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,(void*)0},{&g_126,(void*)0,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126,&g_126}};
    struct S2 ****l_210 = &l_211[1][5];
    uint64_t l_233[4][2] = {{0x4301ED44951996ECLL,0x4301ED44951996ECLL},{0x4301ED44951996ECLL,0x4301ED44951996ECLL},{0x4301ED44951996ECLL,0x4301ED44951996ECLL},{0x4301ED44951996ECLL,0x4301ED44951996ECLL}};
    uint8_t l_238[2];
    uint32_t l_239 = 0xD4BD7B55L;
    int32_t l_240 = 0xAC1A1C62L;
    float l_244[10][7] = {{(-0x3.9p+1),0xA.F86143p-20,0x1.B14871p+73,0xD.2C4D34p-93,0x4.78D223p+58,0x4.78D223p+58,0xD.2C4D34p-93},{(-0x1.Bp-1),0x1.Fp+1,(-0x1.Bp-1),(-0x1.5p+1),0xD.2C4D34p-93,0x1.9p+1,0xB.CC7CC8p-82},{0x4.09A28Cp-86,0xB.F97953p+8,0xE.4B3009p+14,0xC.12515Fp-78,(-0x3.9p+1),0x2.E27299p+87,0x4.09A28Cp-86},{0xB.F97953p+8,0x0.686355p-88,0xB.CC7CC8p-82,0xD.2C4D34p-93,0xE.5447FFp+81,0x1.9p+1,0x1.Ep+1},{0xA.F86143p-20,0x1.Ep+1,0xE.5447FFp+81,0xA.F86143p-20,0x4.Dp-1,0x4.78D223p+58,(-0x1.5p+1)},{0x4.09A28Cp-86,0x0.Fp+1,0x1.A20392p+69,0x4.Dp-1,0x4.Dp-1,0x1.A20392p+69,0x0.Fp+1},{0x4.Dp-1,0x1.B14871p+73,0x1.9p+1,0x1.0p+1,0xE.5447FFp+81,(-0x1.5p+1),0xC.12515Fp-78},{0x1.9p+1,0x4.09A28Cp-86,(-0x1.Bp-1),0x1.B14871p+73,(-0x3.9p+1),0x0.686355p-88,0xE.5447FFp+81},{(-0x5.1p-1),0x0.Fp+1,(-0x1.Fp-1),0x1.0p+1,0xD.2C4D34p-93,0xF.8F99BDp-34,0x4.09A28Cp-86},{0x1.Ep+1,0xE.5447FFp+81,0xA.F86143p-20,0x4.Dp-1,0x4.78D223p+58,(-0x1.5p+1),(-0x5.1p-1)}};
    int32_t l_245[7][4] = {{0xC9683876L,0x13399677L,0xC9683876L,(-4L)},{9L,1L,(-4L),(-4L)},{0x13399677L,0x13399677L,0x6735DEF5L,1L},{1L,9L,0x6735DEF5L,9L},{0x13399677L,0xC9683876L,(-4L),0x6735DEF5L},{9L,0xC9683876L,0xC9683876L,9L},{0xC9683876L,9L,0x13399677L,1L}};
    uint64_t l_246[7][5][3] = {{{0x7F253EEF999C1344LL,1UL,18446744073709551615UL},{0UL,0xB8CE056BAF7A54F2LL,18446744073709551614UL},{1UL,0UL,0UL},{0xB8CE056BAF7A54F2LL,0UL,0x81140B6841CB1931LL},{0UL,0xB8CE056BAF7A54F2LL,0xE071CAB4AE8343DDLL}},{{0xA576658A4AC17C9CLL,1UL,0UL},{1UL,1UL,0UL},{0xE071CAB4AE8343DDLL,18446744073709551615UL,1UL},{18446744073709551613UL,1UL,0xC738FB73719AC969LL},{1UL,0UL,0UL}},{{0xE6E3D103FD7DE96FLL,18446744073709551613UL,0xC738FB73719AC969LL},{0UL,18446744073709551614UL,1UL},{1UL,0UL,0UL},{0x1C1F29E83EF5591ALL,0x765FA4DD6817D362LL,0UL},{18446744073709551614UL,0xC738FB73719AC969LL,0xE071CAB4AE8343DDLL}},{{0xB340D868492E97B3LL,0xE071CAB4AE8343DDLL,0x81140B6841CB1931LL},{0x440B17604BF828A1LL,1UL,0UL},{0x440B17604BF828A1LL,1UL,18446744073709551614UL},{0xB340D868492E97B3LL,0x094F27FA77813692LL,18446744073709551615UL},{18446744073709551614UL,0xE6E3D103FD7DE96FLL,0xE6E3D103FD7DE96FLL}},{{0x1C1F29E83EF5591ALL,0UL,1UL},{1UL,0UL,0xD39C3C4A1115CFEDLL},{0UL,0x628EA8F4955D7B02LL,0x9758E7D963FE579FLL},{0xE6E3D103FD7DE96FLL,0x7F253EEF999C1344LL,1UL},{1UL,0x628EA8F4955D7B02LL,0x765FA4DD6817D362LL}},{{18446744073709551613UL,0UL,1UL},{0xE071CAB4AE8343DDLL,0UL,18446744073709551613UL},{0UL,18446744073709551614UL,0xC738FB73719AC969LL},{18446744073709551615UL,1UL,1UL},{0x89AC96B20FC87E67LL,0x7F253EEF999C1344LL,0x81140B6841CB1931LL}},{{18446744073709551615UL,0xE14738CBD167041CLL,0x81140B6841CB1931LL},{0x094F27FA77813692LL,18446744073709551607UL,1UL},{0UL,0UL,0xC738FB73719AC969LL},{18446744073709551613UL,0xE071CAB4AE8343DDLL,18446744073709551613UL},{0UL,0x9758E7D963FE579FLL,0xE14738CBD167041CLL}}};
    uint8_t l_255 = 0x74L;
    int32_t l_257 = 0x34CF9F92L;
    struct S0 *l_264 = &g_100;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_238[i] = 8UL;
    (*l_151) = l_149;
    l_152 = l_152;
    if ((safe_rshift_func_int8_t_s_s(__builtin_clzll((safe_sub_func_int64_t_s_s((((*g_30) == (l_159 != ((safe_div_func_int8_t_s_s((safe_mod_func_uint32_t_u_u(((g_86.f0 && (safe_add_func_int32_t_s_s(((g_150.f0 != (safe_mul_func_int16_t_s_s(g_100.f0, ((g_33.f0 < (l_168 ^ l_159)) <= 0x62L)))) , l_169), 0x324BC148L))) || g_100.f0), g_33.f0)), g_170)) || 0xFA8CL))) > 4294967295UL), l_171[5]))), l_171[4])))
    { /* block id: 94 */
        int32_t *l_172 = &g_170;
        int32_t l_178[3][7][2] = {{{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L}},{{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L}},{{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L},{0L,0L}}};
        int32_t l_209[4][6] = {{(-2L),0x95EC821CL,(-2L),0x95EC821CL,(-2L),0x95EC821CL},{(-2L),0x95EC821CL,(-2L),0x95EC821CL,(-2L),0x95EC821CL},{(-2L),0x95EC821CL,(-2L),0x95EC821CL,(-2L),0x95EC821CL},{(-2L),0x95EC821CL,(-2L),0x95EC821CL,(-2L),0x95EC821CL}};
        int i, j, k;
        l_172 = l_172;
        for (g_170 = (-3); (g_170 > (-4)); --g_170)
        { /* block id: 98 */
            int32_t *l_175[5] = {&g_170,&g_170,&g_170,&g_170,&g_170};
            volatile struct S3 l_192 = {{-7890},2UL,0x83EEC5992523FAAALL};/* VOLATILE GLOBAL l_192 */
            uint64_t l_206[1][6][9] = {{{1UL,0x38069DB77638222FLL,1UL,0UL,0UL,1UL,0x38069DB77638222FLL,1UL,0UL},{18446744073709551612UL,0xC47B7A4D68258FFCLL,0xC47B7A4D68258FFCLL,18446744073709551612UL,0xF941D61AFEE84A3ALL,18446744073709551612UL,0xC47B7A4D68258FFCLL,0xC47B7A4D68258FFCLL,18446744073709551612UL},{0xCE4FDF005D3D94BFLL,0UL,7UL,0UL,0xCE4FDF005D3D94BFLL,0xCE4FDF005D3D94BFLL,0UL,7UL,0UL},{0xC47B7A4D68258FFCLL,0xF941D61AFEE84A3ALL,18446744073709551615UL,18446744073709551615UL,0xF941D61AFEE84A3ALL,0xC47B7A4D68258FFCLL,0xF941D61AFEE84A3ALL,18446744073709551615UL,18446744073709551615UL},{0xCE4FDF005D3D94BFLL,0xCE4FDF005D3D94BFLL,0UL,7UL,0UL,0xCE4FDF005D3D94BFLL,0xCE4FDF005D3D94BFLL,0UL,7UL},{18446744073709551612UL,0xF941D61AFEE84A3ALL,18446744073709551612UL,0xC47B7A4D68258FFCLL,0xC47B7A4D68258FFCLL,18446744073709551612UL,0xF941D61AFEE84A3ALL,18446744073709551612UL,0xC47B7A4D68258FFCLL}}};
            int i, j, k;
            (***l_152) = l_175[3];
            /* statement id: 99 */
            assert (g_69 == &g_170 || g_69 == 0);
            if (g_33.f0)
                goto lbl_232;
        }
        /* facts after for loop */
        //assert (g_69 == &g_170 || g_69 == 0 || g_69 == &g_31 || g_69 == dangling || g_69 == &g_145);
        (*l_151) = (*l_151);
    }
    else
    { /* block id: 141 */
        (*g_230) = &g_101;
lbl_232:
        (*l_154) = (void*)0;
        /* statement id: 143 */
        assert (g_69 == 0);
        (*g_247) = ((*p_62) , ((func_65(l_233[3][1], (g_93[0][0][0].f2 > ((((safe_lshift_func_uint8_t_u_u(((safe_mul_func_int8_t_s_s((l_238[1] , 1L), g_150.f0)) || l_239), (((l_240 != (safe_add_func_int16_t_s_s(((+((2UL > g_150.f0) || 0x99F62E3C097C9C5FLL)) | g_33.f0), 1L))) ^ g_145) > 0x7F1068F0A819F9FFLL))) | 0xB6L) >= g_33.f0) , l_245[5][1]))) , g_33.f0) && l_246[5][2][2]));
        /* statement id: 145 */
        //assert (g_69 == &g_31 || g_69 == dangling);
        for (l_159 = 6; (l_159 >= 0); l_159 -= 1)
        { /* block id: 148 */
            struct S4 *l_248 = (void*)0;
            int32_t l_256 = (-6L);
            (*l_151) = l_248;
            /* statement id: 149 */
            assert (l_149 == 0);
            (*g_247) = (g_93[0][0][0].f1 , (safe_div_func_uint32_t_u_u((safe_mul_func_int8_t_s_s(((((safe_add_func_int64_t_s_s(((l_255 != (g_35.f0 | l_256)) & l_256), l_256)) == (((0x9B12FEB1DDC82D95LL < l_257) > ((__builtin_bswap64((safe_lshift_func_int16_t_s_u((safe_lshift_func_uint8_t_u_u((safe_mod_func_int16_t_s_s((g_150.f4 & g_33.f0), g_3)), 0)), 15))) == l_256) , 1UL)) | 0x9F007509DA90C6BCLL)) == l_256) || g_150.f5), l_256)), 0x489C8799L)));
            for (l_168 = 0; l_168 < 7; l_168 += 1)
            {
                l_171[l_168] = 0xC9770E6CL;
            }
        }
        /* facts after for loop */
        assert (l_149 == 0 || l_149 == &g_150);
    }
    /* facts after branching */
    //assert (g_69 == &g_170 || g_69 == 0 || g_69 == &g_31 || g_69 == dangling || g_69 == &g_145);
    assert (l_149 == 0 || l_149 == &g_150);
    l_264 = (g_93[1][0][5] , l_264);
    return g_93[0][0][0];
}


/* ------------------------------------------ */
/* 
 * reads : g_101 g_102 g_148 g_125 g_126 g_34
 * writes: g_102
 */
static struct S2 * func_63(const struct S3  p_64)
{ /* block id: 88 */
    (*g_148) = (*g_101);
    return (**g_125);
    /* statement id: 90 */
    //assert (func_63_rv == &g_33 || func_63_rv == &g_35);
}


/* ------------------------------------------ */
/* 
 * reads : g_68 g_35.f0 g_3 g_86 g_24 g_33.f0 g_30 g_31 g_93 g_101 g_104 g_108 g_29 g_125 g_102 g_100 g_138 g_146
 * writes: g_69 g_102 g_118 g_126 g_145
 */
static struct S3  func_65(uint64_t  p_66, uint64_t  p_67)
{ /* block id: 45 */
    int32_t **l_77 = &g_69;
    struct S2 ** const l_123 = &g_34[1];
    (*g_68) = &g_31;
    /* statement id: 46 */
    assert (g_69 == &g_31);
    for (p_67 = 0; (p_67 != 52); p_67 = safe_add_func_uint8_t_u_u(p_67, 1))
    { /* block id: 49 */
        struct S1 l_78 = {0xE95372A7181CA8FDLL};
        uint32_t l_103 = 0xBE7CA300L;
        if (((((__builtin_popcountl(g_35.f0) >= func_72(l_77, l_78, ((safe_add_func_uint32_t_u_u((p_67 || (func_81((g_86 , p_66), p_66, (+(g_3 || g_24)), g_24) > p_66)), p_67)) , 0x07939616L), g_35.f0)) >= l_103) , g_104) != l_78.f0))
        { /* block id: 59 */
            uint64_t l_115 = 0UL;
            float *l_116 = (void*)0;
            float *l_117 = &g_118;
            (*l_117) = ((((safe_unary_minus_func_uint64_t_u(0x3D6DB513C549E5CELL)) , 0x2.6p+1) == (safe_mul_func_float_f_f(((void*)0 != g_108), ((safe_sub_func_float_f_f(p_66, __builtin_ffsll(((safe_div_func_uint32_t_u_u(((0xB2L & __builtin_popcount((0x9625A9B3L & __builtin_ctz(p_66)))) > p_67), 4294967295UL)) == g_29[4])))) != 0x5.7EFCC6p-34)))) < l_115);
        }
        else
        { /* block id: 61 */
            int32_t *l_121 = &g_31;
            for (p_66 = (-8); (p_66 >= 41); p_66++)
            { /* block id: 64 */
                int32_t *l_122 = &g_31;
                struct S2 ***l_124 = (void*)0;
                (*l_77) = l_121;
                /* statement id: 65 */
                assert (g_69 == &g_31);
                (*l_77) = l_122;
                (*g_125) = l_123;
            }
        }
    }
    /* facts after for loop */
    //assert (g_69 == &g_31 || g_69 == dangling);
    for (p_66 = 0; (p_66 <= 3); p_66 += 1)
    { /* block id: 73 */
        struct S3 l_133 = {{-15191},0x987D0CCFL,-1L};
        int32_t *l_139 = &g_31;
        int8_t l_140 = 1L;
        for (p_67 = 0; (p_67 <= 3); p_67 += 1)
        { /* block id: 76 */
            int i;
            l_133.f0.f0 = (g_29[(p_67 + 1)] , func_72(l_77, ((((p_67 , (**g_101)) , (((g_29[(p_67 + 1)] || (safe_lshift_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int8_t_s_u((l_133 , p_67), (safe_sub_func_uint64_t_u_u((((safe_mul_func_int16_t_s_s(g_29[4], ((g_138 , (-1L)) | 0xBD6C54523D0AF2EBLL))) || 0xA0E5L) , p_66), p_67)))), 11)), p_66))) >= 65526UL) , 18446744073709551615UL)) ^ 0x5B274B4BCE18E901LL) , g_86), g_29[(p_67 + 1)], g_31));
            (*l_77) = l_139;
            /* statement id: 78 */
            assert (g_69 == &g_31);
        }
        if (l_140)
        { /* block id: 80 */
            struct S3 l_141 = {{5789},0xD63BEFA0L,0xE2AC5FADB94C902CLL};
            return l_141;
        }
        else
        { /* block id: 82 */
            (*g_146) = (safe_lshift_func_uint8_t_u_s(p_67, 3));
            return l_133;
        }
    }
    return g_93[0][0][0];
}


/* ------------------------------------------ */
/* 
 * reads : g_93 g_24 g_101
 * writes: g_102
 */
inline static uint32_t  func_72(int32_t ** p_73, struct S1  p_74, const int32_t  p_75, int64_t  p_76)
{ /* block id: 55 */
    uint64_t l_97[8] = {0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL,0x7AF8E1F03B47FC81LL};
    int32_t l_98 = (-8L);
    struct S0 *l_99 = &g_100;
    int i;
    l_98 = __builtin_bswap32((!(g_93[0][0][0] , (safe_sub_func_uint32_t_u_u((+((0xD5F6L | __builtin_clzll(l_97[0])) <= ((void*)0 != p_73))), p_74.f0)))));
    (*g_101) = l_99;
    return l_97[0];
}


/* ------------------------------------------ */
/* 
 * reads : g_33.f0 g_68 g_30 g_31
 * writes: g_69
 */
inline static int32_t  func_81(uint8_t  p_82, const int32_t  p_83, int32_t  p_84, uint16_t  p_85)
{ /* block id: 50 */
    int64_t l_88 = 0xCB567DFB9DB650F8LL;
    int32_t **l_89[6][4] = {{&g_69,&g_69,&g_69,&g_69},{&g_69,&g_69,&g_69,&g_69},{&g_69,&g_69,&g_69,&g_69},{&g_69,&g_69,&g_69,&g_69},{&g_69,&g_69,&g_69,&g_69},{&g_69,&g_69,&g_69,&g_69}};
    int32_t ***l_90[7] = {&l_89[0][0],&l_89[0][0],&l_89[0][0],&l_89[0][0],&l_89[0][0],&l_89[0][0],&l_89[0][0]};
    int32_t ****l_91 = &l_90[2];
    int i, j;
    l_88 = (5L >= g_33.f0);
    (*g_68) = &p_84;
    /* statement id: 52 */
    assert (g_69 == &p_84);
    (*l_91) = l_90[0];
    return (*g_30);
    /* statement id: 54 */
    //assert (g_69 == dangling);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_24, "g_24", print_hash_value);
    for (i = 0; i < 5; i++)
    {
        transparent_crc(g_29[i], "g_29[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc(g_33.f0, "g_33.f0", print_hash_value);
    transparent_crc(g_35.f0, "g_35.f0", print_hash_value);
    transparent_crc(g_86.f0, "g_86.f0", print_hash_value);
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 2; j++)
        {
            for (k = 0; k < 6; k++)
            {
                transparent_crc(g_93[i][j][k].f0.f0, "g_93[i][j][k].f0.f0", print_hash_value);
                transparent_crc(g_93[i][j][k].f1, "g_93[i][j][k].f1", print_hash_value);
                transparent_crc(g_93[i][j][k].f2, "g_93[i][j][k].f2", print_hash_value);
                if (print_hash_value) printf("index = [%d][%d][%d]\n", i, j, k);

            }
        }
    }
    transparent_crc(g_100.f0, "g_100.f0", print_hash_value);
    transparent_crc(g_104, "g_104", print_hash_value);
    transparent_crc_bytes (&g_118, sizeof(g_118), "g_118", print_hash_value);
    transparent_crc(g_138.f0, "g_138.f0", print_hash_value);
    transparent_crc(g_138.f1, "g_138.f1", print_hash_value);
    transparent_crc(g_138.f2, "g_138.f2", print_hash_value);
    transparent_crc(g_138.f3, "g_138.f3", print_hash_value);
    transparent_crc(g_138.f4, "g_138.f4", print_hash_value);
    transparent_crc(g_138.f5, "g_138.f5", print_hash_value);
    transparent_crc(g_138.f6, "g_138.f6", print_hash_value);
    transparent_crc(g_145, "g_145", print_hash_value);
    transparent_crc(g_150.f0, "g_150.f0", print_hash_value);
    transparent_crc(g_150.f1, "g_150.f1", print_hash_value);
    transparent_crc(g_150.f2, "g_150.f2", print_hash_value);
    transparent_crc(g_150.f3, "g_150.f3", print_hash_value);
    transparent_crc(g_150.f4, "g_150.f4", print_hash_value);
    transparent_crc(g_150.f5, "g_150.f5", print_hash_value);
    transparent_crc(g_150.f6, "g_150.f6", print_hash_value);
    transparent_crc(g_170, "g_170", print_hash_value);
    transparent_crc(g_327.f0, "g_327.f0", print_hash_value);
    transparent_crc(g_327.f1, "g_327.f1", print_hash_value);
    transparent_crc(g_327.f2, "g_327.f2", print_hash_value);
    transparent_crc(g_327.f3, "g_327.f3", print_hash_value);
    transparent_crc(g_327.f4, "g_327.f4", print_hash_value);
    transparent_crc(g_327.f5, "g_327.f5", print_hash_value);
    transparent_crc(g_327.f6, "g_327.f6", print_hash_value);
    transparent_crc(g_436, "g_436", print_hash_value);
    for (i = 0; i < 9; i++)
    {
        transparent_crc(g_438[i].f0.f0, "g_438[i].f0.f0", print_hash_value);
        transparent_crc(g_438[i].f1, "g_438[i].f1", print_hash_value);
        transparent_crc(g_438[i].f2, "g_438[i].f2", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    for (i = 0; i < 2; i++)
    {
        transparent_crc(g_446[i].f0, "g_446[i].f0", print_hash_value);
        transparent_crc(g_446[i].f1, "g_446[i].f1", print_hash_value);
        transparent_crc(g_446[i].f2, "g_446[i].f2", print_hash_value);
        transparent_crc(g_446[i].f3, "g_446[i].f3", print_hash_value);
        transparent_crc(g_446[i].f4, "g_446[i].f4", print_hash_value);
        transparent_crc(g_446[i].f5, "g_446[i].f5", print_hash_value);
        transparent_crc(g_446[i].f6, "g_446[i].f6", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_470.f0, "g_470.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 129
   depth: 1, occurrence: 21
   depth: 2, occurrence: 11
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 5
XXX volatile bitfields defined in structs: 5
XXX structs with bitfields in the program: 51
breakdown:
   indirect level: 0, occurrence: 22
   indirect level: 1, occurrence: 17
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 11
breakdown:
   indirect level: 0, occurrence: 11
XXX times a bitfields struct's address is taken: 115
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 74

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 185
   depth: 2, occurrence: 44
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 2
   depth: 9, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 23, occurrence: 2
   depth: 28, occurrence: 2
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 139

XXX times a variable address is taken: 342
XXX times a pointer is dereferenced on RHS: 63
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 13
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 84
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 1
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 594

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 667
   level: 2, occurrence: 114
   level: 3, occurrence: 39
   level: 4, occurrence: 13
XXX number of pointers point to pointers: 67
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 35
XXX percent of pointers has null in alias set: 30.9
XXX average alias set size: 1.49

XXX times a non-volatile is read: 549
XXX times a non-volatile is write: 199
XXX times a volatile is read: 61
XXX    times read thru a pointer: 2
XXX times a volatile is write: 34
XXX    times written thru a pointer: 4
XXX times a volatile is available for access: 499
XXX percentage of non-volatile access: 88.7

XXX forward jumps: 2
XXX backward jumps: 1

XXX stmts: 168
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 18
   depth: 2, occurrence: 29
   depth: 3, occurrence: 32
   depth: 4, occurrence: 27
   depth: 5, occurrence: 26

XXX percentage a fresh-made variable is used: 22.7
XXX percentage an existing variable is used: 77.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

