/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2673946411
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 20;
   unsigned f1 : 27;
   const unsigned f2 : 18;
};

union U1 {
   float  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_36(void);
inline static float  func_40(uint32_t  p_41, uint16_t  p_42, int32_t  p_43, int32_t  p_44);
inline static int32_t  func_59(int16_t  p_60, uint32_t  p_61, int16_t  p_62, int16_t  p_63, int16_t  p_64);
static int32_t  func_66(uint32_t  p_67, uint16_t  p_68, uint32_t  p_69, const uint32_t  p_70, int32_t  p_71);
static uint32_t  func_72(int16_t  p_73);
inline static int32_t * func_83(union U1  p_84, float * p_85, const uint32_t  p_86, struct S0  p_87, uint16_t  p_88);
static float * func_90(float  p_91, uint32_t  p_92, int32_t  p_93, int16_t  p_94);
inline static uint32_t  func_98(union U1  p_99, float * p_100, float * p_101);
static union U1  func_102(int32_t * p_103, float * p_104, float * p_105);
inline static float * func_108(float * p_109, float  p_110, uint32_t  p_111, uint32_t  p_112, int32_t * const  p_113);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_36(void)
{ /* block id: 36 */
    int32_t l_37 = 0;
    int32_t ***l_622 = (void*)0;
    int32_t ****l_621 = &l_622;
    struct S0 l_634 = {-446,10694,224};
    struct S0 *l_633 = &l_634;
    struct S0 **l_632 = &l_633;
    struct S0 ***l_631 = &l_632;
    struct S0 ****l_630 = &l_631;
    float l_641 = (-0x3.8p+1);
    float *l_640 = &l_641;
    float ** const l_639 = &l_640;
    const uint32_t l_658 = 0xD6D1886A;
    int32_t l_678 = (-8);
    int32_t l_683 = 0;
    uint32_t l_685 = 0xCDD39037;
    uint32_t l_697 = 0U;
    uint16_t l_699 = 0xD3B4;
    union U1 l_708 = {0x4.Cp+1};
    struct S0 *l_712 = &l_634;
    int32_t *l_716 = (void*)0;
    union U1 *l_758 = &l_708;
    union U1 **l_757 = &l_758;
    union U1 *** const l_756 = &l_757;
    uint16_t l_812 = 0xCF98;
    int16_t l_847 = 0x593D;
    int32_t *l_848 = (void*)0;
    int32_t *l_849 = &l_37;
    uint32_t l_871 = 0xE1FB8854;
    if (l_37)
    { /* block id: 37 */
        uint32_t l_65 = 0x46C64E71;
        uint32_t l_613 = 0x675E34E6;
        union U1 **l_624 = (void*)0;
        int32_t l_627 = (-6);
        struct S0 ****l_629 = (void*)0;
        float l_637 = 0x2.6EDC20p+81;
        float *l_636 = &l_637;
        float **l_635 = &l_636;
        int32_t *****l_693 = (void*)0;
        int32_t *l_717 = (void*)0;
        const int32_t *l_743 = &l_37;
        const int32_t **l_742 = &l_743;
        union U1 ***l_751 = (void*)0;
        union U1 ****l_750 = &l_751;
        union U1 *****l_749 = &l_750;
        int32_t *l_807 = &l_627;
        float l_808 = 0x4.3E2C45p-33;
        float l_809 = 0xA.FE73D9p+98;
        float *l_810 = &l_809;
        int16_t l_811 = (-1);
        for (l_37 = 0; (l_37 >= (-15)); l_37 -= 8)
        { /* block id: 40 */
            uint32_t l_45 = 0x79FACD4A;
            uint32_t l_614 = 0U;
            uint32_t l_618 = 0xDBBC29D8;
            float l_620 = 0x9.7p+1;
            float *l_619 = &l_620;
            if (l_37)
                break;
            if (l_37)
                break;
            (*l_619) = ((func_40(l_45, ((((int32_t)(l_37 | ((uint16_t)(__builtin_bswap32((((((((uint16_t)(-(uint16_t)7U) << (uint16_t)4) | (((((int32_t)((uint16_t)(l_37 > (((int32_t)((func_59(l_65, (l_65 < l_45), l_45, l_37, l_37) ^ l_65) && 1) - (int32_t)l_65) | 6U)) >> (uint16_t)l_45) % (int32_t)0x88B69366) > 8) & l_45) >= 1)) | l_37) & (-1)) <= l_613) && 0x831B738C)) & 4294967287U) - (uint16_t)l_37)) + (int32_t)l_45) == l_614) <= l_45), l_65, l_37) > l_618) > l_65);
        }
        if ((l_37 || l_613))
        { /* block id: 357 */
            int32_t ****l_623 = (void*)0;
            const int32_t l_638 = 0xA2FA7052;
            struct S0 *l_643 = &l_634;
            int32_t l_657 = (-2);
            float *l_681 = (void*)0;
            int32_t *****l_694 = (void*)0;
            int32_t l_698 = 0;
            uint16_t l_718 = 3U;
            l_623 = l_621;
            /* statement id: 358 */
            assert (l_623 == &l_622);
            if (l_613)
                goto lbl_628;
lbl_628:
            l_627 = ((l_624 == l_624) > (((float)l_613 - (float)l_65) < l_65));
            (**l_635) = ((l_613 > (((l_629 == l_630) <= ((void*)0 != l_635)) == func_72((l_65 <= __builtin_ffs(l_65))))) < l_638);
            if ((l_634.f1 >= l_613))
            { /* block id: 362 */
                float ***l_642 = &l_635;
                int32_t l_646 = (-6);
                union U1 l_680 = {0x1.C58341p-7};
                int32_t *l_686 = &l_683;
                union U1 ***l_692 = &l_624;
                union U1 ****l_691 = &l_692;
                union U1 *****l_690 = &l_691;
                uint32_t l_715 = 0xA24CCCF1;
                (*l_642) = l_639;
                /* statement id: 363 */
                assert (l_635 == &l_640);
lbl_679:
                (*l_632) = l_643;
                if ((((int32_t)l_613 - (int32_t)(((l_65 != (l_646 != (((l_627 < l_65) & (((uint16_t)((uint16_t)(((((uint16_t)l_638 >> (uint16_t)8) <= ((int32_t)((uint16_t)(l_646 ^ l_627) >> (uint16_t)11) - (int32_t)l_657)) == l_658) == l_627) >> (uint16_t)l_613) >> (uint16_t)1) < 0x57CDB615)) ^ l_638))) >= l_65) == l_65)) <= l_627))
                { /* block id: 365 */
                    const float l_659 = 0x5.4p-1;
                    int32_t *l_660 = &l_37;
                    (*l_660) = l_646;
                    for (l_646 = 0; (l_646 != 1); l_646++)
                    { /* block id: 369 */
                        uint16_t l_667 = 0x7E97;
                        l_627 = __builtin_ia32_crc32qi(((uint32_t)((uint16_t)(l_627 && ((l_667 == (l_646 & (l_65 & l_667))) <= 0xDEB70D55)) << (uint16_t)((uint32_t)((uint16_t)(*l_660) + (uint16_t)((uint16_t)(l_65 < __builtin_ctzl(((uint16_t)((uint32_t)0xD7B9C64B + (uint32_t)l_678) << (uint16_t)l_646))) - (uint16_t)l_613)) - (uint32_t)0x07CCA20E)) - (uint32_t)(-3)), l_667);
                        if (l_613)
                            goto lbl_679;
                        return l_646;
                    }
                }
                else
                { /* block id: 374 */
                    int32_t *l_682 = &l_646;
                    union U1 *l_684 = &l_680;
                    union U1 ***l_689 = &l_624;
                    union U1 ****l_688 = &l_689;
                    union U1 ***** const l_687 = &l_688;
                    int32_t l_714 = 0x7239C1E1;
                    (*l_682) = (func_98(l_680, l_681, l_681) | l_646);
                    if ((((*l_682) || (((l_683 > l_65) ^ l_646) != ((void*)0 != l_684))) < ((void*)0 != &l_640)))
                    { /* block id: 376 */
                        l_686 = func_108((*l_639), l_646, l_646, l_685, &l_627);
                        /* statement id: 377 */
                        assert (l_686 == 0);
                        l_690 = l_687;
                        /* statement id: 378 */
                        assert (l_690 == &l_688);
                    }
                    else
                    { /* block id: 379 */
                        l_686 = (void*)0;
                        /* statement id: 380 */
                        assert (l_686 == 0);
                        l_694 = l_693;
                        (*l_682) = ((int16_t)func_72(l_697) << (int16_t)10);
                    }
                    /* facts after branching */
                    assert (l_686 == 0);
                    assert (l_690 == &l_691 || l_690 == &l_688);
                    if ((l_698 <= (l_634.f0 <= l_699)))
                    { /* block id: 384 */
                        l_686 = l_682;
                        /* statement id: 385 */
                        assert (l_686 == &l_646);
                    }
                    else
                    { /* block id: 386 */
                        const float l_709 = 0x1.Fp-1;
                        int32_t l_710 = (-1);
                        int32_t *l_711 = &l_678;
                        l_682 = func_108(l_681, ((float)0xF.01DE58p-49 + (float)((float)(((float)(+(l_657 == (-(float)func_98(l_708, func_83(l_708, (**l_642), (*l_682), (*l_643), l_710), (**l_642))))) + (float)l_710) != (*l_682)) + (float)l_710)), l_710, (*l_682), l_682);
                        /* statement id: 387 */
                        assert (l_682 == 0);
                        (*l_711) = 0xD2E75FB0;
                        l_643 = l_712;
                        l_714 = ((+l_714) >= 0x0.9p+1);
                    }
                    /* facts after branching */
                    assert (l_682 == 0 || l_682 == &l_646);
                    assert (l_686 == 0 || l_686 == &l_646);
                    return l_715;
                }
                l_717 = l_716;
            }
            else
            { /* block id: 395 */
                return l_718;
            }
            /* facts after branching */
            assert (l_635 == &l_640);
        }
        else
        { /* block id: 398 */
            uint16_t l_723 = 65526U;
            int32_t *l_740 = &l_683;
            union U1 *l_741 = &l_708;
            int32_t **l_745 = &l_716;
            int32_t ***l_744 = &l_745;
            struct S0 **l_787 = &l_712;
            if ((((int32_t)((int32_t)l_723 % (int32_t)0xA21E02B4) - (int32_t)__builtin_popcount(((uint16_t)((uint16_t)((uint16_t)0U - (uint16_t)(((uint16_t)((uint16_t)0x8BBE >> (uint16_t)14) << (uint16_t)((**l_630) != (void*)0)) != l_627)) - (uint16_t)(&l_717 == (void*)0)) << (uint16_t)l_723))) && 4))
            { /* block id: 399 */
                for (l_699 = 0; (l_699 != 18); l_699++)
                { /* block id: 402 */
                    return l_723;
                }
            }
            else
            { /* block id: 405 */
                float l_736 = 0xD.DE6CCBp+41;
                int32_t l_737 = 0xBFCC0BB5;
                if (((l_723 || l_723) ^ __builtin_ia32_crc32qi(l_723, l_737)))
                { /* block id: 406 */
                    return l_723;
                }
                else
                { /* block id: 408 */
                    float l_738 = 0x2.C53DA1p+18;
                    (*l_640) = l_738;
                    (**l_635) = (!(l_737 <= 0x0.Dp-1));
                }
                l_717 = l_740;
                /* statement id: 412 */
                assert (l_717 == &l_683);
                (*l_717) = l_737;
                (*l_740) = (l_741 == &l_708);
            }
            /* facts after branching */
            assert (l_717 == &l_683 || l_717 == 0);
            (*l_744) = l_742;
            /* statement id: 416 */
            assert (l_745 == &l_743);
            if ((*l_743))
            { /* block id: 417 */
                uint32_t l_746 = 0x52D35A80;
                int32_t l_747 = 0xDCEF7BBA;
                l_747 = l_746;
                (**l_639) = (***l_744);
            }
            else
            { /* block id: 420 */
                int16_t l_754 = (-10);
                union U1 ***l_755 = &l_624;
                uint32_t l_759 = 0x3B7F1A87;
                uint32_t l_767 = 0x3DF33CB5;
                int32_t l_789 = 0x35C9AF5B;
                (**l_745) = ((!((((**l_745) && ((l_749 == (void*)0) ^ ((uint16_t)((void*)0 != &l_636) - (uint16_t)func_59((l_754 < (l_754 <= l_754)), __builtin_popcountl(func_72((l_755 == l_756))), l_754, (*l_743), (**l_742))))) == 0x19B224D6) == l_759)) != 0x29ED271E);
                (*l_745) = func_90((!(((float)(((*l_740) >= ((float)((**l_745) >= ((float)((((*l_740) >= (-0x1.5p-1)) < (*l_743)) != ((0xE.DC2071p-46 > ((**l_745) > ((void*)0 == (*l_757)))) < (-0x1.0p-1))) - (float)l_754)) - (float)l_759)) != (**l_742)) - (float)0x0.3AF160p-26) > (*l_743))), l_754, l_759, l_759);
                /* statement id: 422 */
                assert (l_743 == 0);
                if (l_754)
                { /* block id: 423 */
                    int32_t l_775 = 5;
                    if (l_767)
                    { /* block id: 424 */
                        float l_777 = 0x0.9p+1;
                        struct S0 **l_788 = &l_633;
                        (*l_740) = 0x789D7B81;
                        l_789 = ((int16_t)(65535U || ((int16_t)((int32_t)((-(uint16_t)65535U) & l_775) % (int32_t)(+l_759)) << (int16_t)3)) + (int16_t)((-(uint32_t)l_759) <= ((uint32_t)(((uint16_t)0x2D43 << (uint16_t)(((uint32_t)((uint16_t)(((l_767 || 0x8665) <= (l_787 == l_788)) != l_767) % (uint16_t)l_775) + (uint32_t)1) <= 4294967291U)) && l_754) - (uint32_t)0x06706E88)));
                        (*l_745) = &l_789;
                        /* statement id: 427 */
                        assert (l_743 == &l_789);
                    }
                    else
                    { /* block id: 428 */
                        (*l_740) = ((int16_t)0 << (int16_t)13);
                    }
                    /* facts after branching */
                    assert (l_743 == 0 || l_743 == &l_789);
                }
                else
                { /* block id: 431 */
                    struct S0 * const l_792 = &l_634;
                    struct S0 l_794 = {569,3362,471};
                    struct S0 *l_793 = &l_794;
                    l_793 = l_792;
                    /* statement id: 432 */
                    assert (l_793 == &l_634);
                }
                /* facts after branching */
                assert (l_743 == 0 || l_743 == &l_789);
            }
            /* facts after branching */
            //assert (l_743 == 0 || l_743 == dangling || l_743 == &l_37);
            if ((*l_740))
            { /* block id: 435 */
                const struct S0 *l_795 = &l_634;
                struct S0 **l_796 = &l_712;
                int32_t l_797 = 0x39043E10;
                (*l_796) = l_795;
                return l_797;
            }
            else
            { /* block id: 438 */
                int32_t l_798 = 0x22E9DA0A;
                float *l_801 = &l_641;
                float l_805 = 0x9.14FED1p-41;
                if (l_798)
                { /* block id: 439 */
                    uint32_t l_799 = 1U;
                    return l_799;
                }
                else
                { /* block id: 441 */
                    union U1 l_800 = {0x4.367887p-38};
                    int32_t l_802 = (-1);
                    struct S0 ****l_803 = &l_631;
                    (*l_636) = func_98(l_800, (*l_635), l_801);
                    if (l_798)
                        goto lbl_804;
                    if (l_802)
                    { /* block id: 443 */
lbl_804:
                        (*l_740) = (l_803 != (void*)0);
                        (*l_740) = l_802;
                    }
                    else
                    { /* block id: 447 */
                        (*l_740) = (*l_740);
                    }
                }
                (*l_742) = &l_798;
                /* statement id: 451 */
                assert (l_743 == &l_798);
                (*l_636) = (l_798 <= (**l_745));
                (***l_744) = ((***l_744) >= (~(0xA0324D0C != (***l_744))));
            }
            /* facts after branching */
            //assert (l_743 == dangling);
        }
        /* facts after branching */
        assert (l_635 == &l_636 || l_635 == &l_640);
        assert (l_717 == &l_683 || l_717 == 0);
        //assert (l_743 == dangling || l_743 == &l_37);
        (*l_807) = (func_98((*l_758), func_83(func_102(func_83(func_102(l_807, (*l_635), (*l_635)), (*l_639), l_685, (****l_630), l_685), (*l_635), (*l_639)), (*l_635), l_65, (*l_633), l_634.f0), l_810) & l_811);
        if ((l_697 | l_812))
        { /* block id: 457 */
            union U1 **l_822 = &l_758;
            int32_t l_829 = 0xD40AA14D;
            for (l_613 = (-10); (l_613 >= 36); ++l_613)
            { /* block id: 460 */
                int32_t *l_820 = &l_683;
                union U1 **l_823 = &l_758;
                for (l_678 = 0; (l_678 != 16); l_678 += 8)
                { /* block id: 463 */
                    int32_t *l_821 = &l_683;
                    struct S0 *l_828 = &l_634;
                    for (l_65 = 0; (l_65 <= 7); ++l_65)
                    { /* block id: 466 */
                        int32_t *l_819 = &l_627;
                        l_820 = l_819;
                        /* statement id: 467 */
                        assert (l_820 == &l_627);
                        (**l_756) = (**l_756);
                        (*l_742) = l_821;
                        /* statement id: 469 */
                        assert (l_743 == &l_683);
                        (*l_810) = (*l_821);
                    }
                    l_823 = l_822;
                    (*l_807) = (((int16_t)(*l_820) + (int16_t)((void*)0 != l_820)) > ((int32_t)(l_828 != (**l_631)) + (int32_t)(*l_807)));
                    if (l_829)
                        continue;
                }
                /* facts after for loop */
                assert (l_820 == &l_627 || l_820 == &l_683);
            }
            /* facts after for loop */
            //assert (l_743 == &l_683 || l_743 == dangling || l_743 == &l_37);
            (**l_639) = (((***l_630) != (void*)0) == l_829);
        }
        else
        { /* block id: 478 */
            union U1 ** const l_831 = &l_758;
            int32_t l_837 = 0;
            int32_t l_843 = 0x73EFB6EB;
            (*l_810) = (!((((-0x1.2p+1) >= (((void*)0 != l_831) > (-(float)((*l_639) != (void*)0)))) == 0xA.93DDB0p+13) >= ((float)(((float)l_837 + (float)(l_693 != l_693)) <= (-0x1.9p-1)) + (float)l_837)));
            for (l_37 = 0; (l_37 != (-4)); l_37--)
            { /* block id: 482 */
                uint32_t l_842 = 1U;
                (*l_807) = ((uint16_t)(((l_837 || l_842) >= 8U) < (l_837 <= l_843)) % (uint16_t)l_837);
            }
        }
        /* facts after branching */
        //assert (l_743 == &l_683 || l_743 == dangling || l_743 == &l_37);
    }
    else
    { /* block id: 486 */
        int32_t *l_844 = (void*)0;
        int32_t *l_845 = &l_678;
        int32_t **l_846 = &l_716;
        (*l_845) = 8;
        (*l_846) = (void*)0;
        return l_847;
    }
    (*l_849) = 1;
    for (l_697 = 15; (l_697 > 44); l_697 += 1)
    { /* block id: 494 */
        union U1 * const **l_856 = (void*)0;
        union U1 * const ***l_855 = &l_856;
        union U1 * const ****l_854 = &l_855;
        int32_t l_857 = 9;
        float *l_864 = &l_641;
        uint16_t l_865 = 0x1D53;
        uint32_t l_866 = 0x8DA651EC;
        (*l_849) = ((uint32_t)((*l_849) | (*l_849)) + (uint32_t)(*l_849));
        l_854 = l_854;
        if (l_857)
        { /* block id: 497 */
            int32_t *l_858 = &l_37;
            const int32_t *l_860 = &l_37;
            const int32_t **l_859 = &l_860;
            int32_t *l_861 = &l_857;
            l_848 = l_858;
            /* statement id: 498 */
            assert (l_848 == &l_37);
            (*l_859) = &l_857;
            /* statement id: 499 */
            assert (l_860 == &l_857);
            (*l_859) = l_861;
            if (l_857)
                continue;
        }
        else
        { /* block id: 502 */
            const int32_t *l_863 = &l_857;
            const int32_t **l_862 = &l_863;
            struct S0 *l_867 = &l_634;
            (*l_862) = &l_857;
            (*l_862) = func_108(l_864, (**l_862), (func_72(l_865) < func_72(l_865)), l_857, func_108(l_864, (**l_862), l_857, (*l_863), &l_857));
            /* statement id: 504 */
            assert (l_863 == 0);
            if (l_866)
                continue;
            l_867 = l_867;
        }
        for (l_683 = (-7); (l_683 >= 24); ++l_683)
        { /* block id: 510 */
            int32_t **l_870 = &l_716;
            (*l_870) = (void*)0;
        }
    }
    /* facts after for loop */
    assert (l_848 == &l_37 || l_848 == 0);
    return l_871;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_40(uint32_t  p_41, uint16_t  p_42, int32_t  p_43, int32_t  p_44)
{ /* block id: 352 */
    int32_t l_616 = 0xDF8DF82B;
    int32_t *l_615 = &l_616;
    int32_t **l_617 = &l_615;
    (*l_617) = l_615;
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_59(int16_t  p_60, uint32_t  p_61, int16_t  p_62, int16_t  p_63, int16_t  p_64)
{ /* block id: 43 */
    union U1 l_271 = {0x9.7p+1};
    union U1 *l_270 = &l_271;
    union U1 **l_269 = &l_270;
    union U1 ***l_268 = &l_269;
    int32_t l_272 = 0x79889665;
    float *l_295 = &l_271.f0;
    float **l_294 = &l_295;
    float l_302 = 0x5.2p-1;
    const int32_t *l_341 = (void*)0;
    int32_t *l_361 = (void*)0;
    int32_t **l_367 = (void*)0;
    int32_t ** const *l_366 = &l_367;
    uint32_t l_393 = 0U;
    union U1 **l_455 = &l_270;
    union U1 **l_498 = (void*)0;
    const struct S0 **l_509 = (void*)0;
    const struct S0 ***l_508 = &l_509;
    const struct S0 ****l_507 = &l_508;
    int32_t *l_511 = &l_272;
    float *l_570 = &l_271.f0;
    uint32_t l_588 = 0x65931CC0;
    int32_t l_612 = (-1);
lbl_462:
    if (func_66(p_60, p_62, func_72(p_60), ((int16_t)0xB031 + (int16_t)(p_60 < (l_268 == &l_269))), ((((p_61 | p_64) || l_272) || (-6)) & p_63)))
    { /* block id: 149 */
        union U1 *l_285 = &l_271;
        float *l_301 = &l_271.f0;
        int32_t l_303 = (-6);
        int32_t *l_336 = &l_303;
        int32_t **l_335 = &l_336;
        if (l_272)
        { /* block id: 150 */
            for (p_63 = 10; (p_63 == 25); p_63 += 9)
            { /* block id: 153 */
                (*l_269) = l_285;
                return p_60;
            }
        }
        else
        { /* block id: 157 */
            int32_t *l_289 = &l_272;
            int32_t **l_288 = &l_289;
            int32_t ***l_287 = &l_288;
            int32_t ****l_286 = &l_287;
            float *l_293 = &l_271.f0;
            float **l_292 = &l_293;
            union U1 ****l_330 = &l_268;
            if ((((void*)0 == l_286) && ((int32_t)(p_64 & 0x9FC9) - (int32_t)p_60)))
            { /* block id: 158 */
                int16_t l_296 = 0x271B;
                (***l_287) = p_61;
                l_296 = ((l_292 != l_294) < __builtin_popcountl(p_60));
                if (p_63)
                    goto lbl_304;
lbl_304:
                (*l_295) = ((0x6.341D8Fp-82 <= ((((float)0xF.DBAD59p-85 - (float)((float)((func_72(p_64) >= 0xC.370667p+22) != (p_63 >= func_98((***l_268), l_301, func_90(l_272, p_60, p_62, l_303)))) - (float)p_63)) < p_62) >= p_63)) <= (****l_286));
                for (l_303 = 0; (l_303 == 6); l_303 += 9)
                { /* block id: 165 */
                    for (p_62 = 0; (p_62 > 25); p_62 += 4)
                    { /* block id: 168 */
                        (***l_286) = (*l_288);
                    }
                }
            }
            else
            { /* block id: 172 */
                const uint32_t l_319 = 7U;
                struct S0 **l_322 = (void*)0;
                const float *l_326 = (void*)0;
                const float **l_325 = &l_326;
                float ***l_327 = (void*)0;
                float * const **l_328 = (void*)0;
                float ***l_329 = &l_292;
                (*l_289) = ((uint32_t)((int16_t)((int16_t)((uint16_t)p_63 % (uint16_t)0x4A22) << (int16_t)0) << (int16_t)((uint16_t)l_319 + (uint16_t)((int16_t)1 - (int16_t)((((p_61 < p_60) >= p_60) < l_303) && ((void*)0 == l_322))))) + (uint32_t)p_62);
                (**l_294) = (((float)0x3.C3EA14p+42 - (float)0x7.4F9B40p+55) <= ((l_319 != 0xB.2D6D3Dp-29) > l_303));
                (**l_287) = (void*)0;
                /* statement id: 175 */
                assert (l_289 == 0);
                (*l_329) = l_325;
                /* statement id: 176 */
                assert (l_292 == &l_326);
            }
            /* facts after branching */
            assert (l_289 == 0 || l_289 == &l_272);
            //assert (l_292 == dangling || l_292 == &l_293);
            (*l_330) = (void*)0;
            /* statement id: 178 */
            assert (l_268 == 0);
            return p_63;
        }
        (**l_294) = ((float)l_272 + (float)func_98((**l_269), (*l_294), func_90(l_303, (l_272 | ((((void*)0 != &l_269) > (((l_303 != (__builtin_parity(((int16_t)((*l_268) == (*l_268)) - (int16_t)l_272)) <= l_303)) <= l_303) == 1)) > 0x9AB98327)), p_63, p_62)));
        (*l_335) = &l_303;
        (**l_335) = ((int16_t)p_63 % (int16_t)p_63);
    }
    else
    { /* block id: 184 */
        uint32_t l_344 = 4294967295U;
        int32_t **l_365 = &l_361;
        int32_t *** const l_364 = &l_365;
        struct S0 l_380 = {750,11119,304};
        float *l_381 = &l_271.f0;
        const union U1 *l_444 = &l_271;
        const union U1 **l_443 = &l_444;
        for (p_64 = 0; (p_64 < (-22)); --p_64)
        { /* block id: 187 */
            union U1 l_342 = {-0x9.Bp-1};
            float *l_343 = &l_271.f0;
            int32_t l_348 = 0x4EC487F6;
            float l_404 = 0x1.Fp-1;
            int32_t **l_436 = &l_361;
            (**l_268) = (**l_268);
            l_341 = (void*)0;
            if (func_98(l_342, (*l_294), l_343))
            { /* block id: 190 */
                float l_360 = 0x2.14B4F6p-46;
                (*l_343) = 0xB.1210BFp+92;
                if ((65535U && (l_344 < l_344)))
                { /* block id: 192 */
                    uint32_t l_345 = 1U;
                    int32_t *l_357 = &l_272;
                    if (l_345)
                        break;
                    if (p_63)
                        continue;
                    (*l_357) = (1U && ((uint16_t)(__builtin_clzl(l_348) && (((uint16_t)((((p_64 < (l_345 != (p_63 == ((uint16_t)65534U << (uint16_t)(((l_344 ^ (-6)) == l_348) && 0))))) || l_348) ^ p_63) != 1) << (uint16_t)p_63) <= 9U)) >> (uint16_t)4));
                    for (p_60 = 1; (p_60 < 13); ++p_60)
                    { /* block id: 198 */
                        (*l_357) = p_61;
                        return l_344;
                    }
                }
                else
                { /* block id: 202 */
                    if (p_63)
                        break;
                    (**l_294) = ((l_360 >= l_348) == p_63);
                    l_361 = func_90(l_344, p_63, p_62, l_344);
                    /* statement id: 205 */
                    assert (l_361 == 0);
                }
                return p_61;
            }
            else
            { /* block id: 208 */
                int32_t l_373 = 0x1265B9D3;
                union U1 **l_379 = &l_270;
                union U1 ** const l_382 = &l_270;
                (**l_364) = func_90(((float)(l_364 == l_366) + (float)(p_61 >= p_62)), (p_60 > 0x81E7944D), p_61, (p_64 <= p_60));
                /* statement id: 209 */
                assert (l_361 == 0);
                if (p_60)
                { /* block id: 210 */
                    if (p_62)
                    { /* block id: 211 */
                        return p_61;
                    }
                    else
                    { /* block id: 213 */
                        int32_t l_372 = (-10);
                        (**l_364) = &l_348;
                        /* statement id: 214 */
                        assert (l_361 == &l_348);
                        l_373 = (+((float)(0x4.76F26Cp+55 >= ((p_63 >= p_62) >= ((+0x5.B30EF9p-78) <= (((p_63 == 0x0.Ep+1) != (p_60 != 0x0.2p+1)) != (l_372 != (-0x1.8p-1)))))) + (float)l_348));
                    }
                    /* facts after branching */
                    assert (l_361 == &l_348);
                }
                else
                { /* block id: 217 */
                    float l_376 = 0x7.0p+1;
                    float **l_394 = (void*)0;
                    (**l_364) = func_108(func_108(func_83((*l_270), func_90((0xA.D31974p+4 == (((((float)p_62 + (float)((__builtin_clzl(p_64) >= l_376) <= p_60)) >= ((float)(l_379 == (*l_268)) + (float)0xC.8941EFp-24)) > 0x0.3p+1) <= l_373)), p_64, p_62, p_60), p_61, l_380, p_61), l_373, p_62, l_348, &l_373), p_60, p_63, p_63, (**l_364));
                    (**l_364) = func_108(l_381, (l_379 != l_382), p_63, l_373, (*l_365));
                    l_373 = ((float)((float)(((((float)(((float)l_373 + (float)(l_348 < ((float)__builtin_ctzll(l_348) - (float)(func_72(l_393) > 0xC.A24570p-21)))) < ((&l_343 == l_394) == p_62)) - (float)(-0x1.8p-1)) <= l_373) >= 0x2.C060ADp-93) > p_61) - (float)p_61) - (float)p_60);
                }
                /* facts after branching */
                assert (l_361 == 0 || l_361 == &l_348);
            }
            /* facts after branching */
            assert (l_361 == 0 || l_361 == &l_348);
            if (p_61)
            { /* block id: 223 */
                const struct S0 *l_396 = &l_380;
                const struct S0 **l_395 = &l_396;
                struct S0 ***l_397 = (void*)0;
                const struct S0 ***l_398 = &l_395;
                union U1 l_399 = {0x1.Cp+1};
                int32_t l_405 = (-1);
                (*l_398) = l_395;
                l_348 = ((void*)0 == &l_348);
                l_348 = ((func_98(l_399, func_83((*l_270), func_90(func_72(p_64), p_64, (p_63 != ((int32_t)__builtin_clzl(p_63) + (int32_t)((int16_t)p_63 << (int16_t)p_64))), l_348), p_63, (***l_398), p_60), (*l_294)) | l_405) <= l_405);
                for (l_393 = (-8); (l_393 > 44); l_393 += 2)
                { /* block id: 229 */
                    int32_t l_410 = (-9);
                    l_410 = ((__builtin_bswap64(l_405) && (9 || p_62)) != ((uint32_t)l_410 % (uint32_t)0x14FD7B38));
                    if (l_410)
                        break;
                    for (l_348 = 5; (l_348 != 29); l_348 += 6)
                    { /* block id: 234 */
                        union U1 *l_425 = &l_399;
                        int32_t l_426 = 0;
                        int32_t *l_427 = &l_410;
                        (*l_365) = func_108(func_90(((float)p_62 - (float)0x6.FC259Fp+99), (p_60 > ((int16_t)(p_60 ^ ((uint16_t)(((int32_t)__builtin_ctz(((p_61 && ((int32_t)l_348 - (int32_t)(l_348 < ((void*)0 == l_425)))) <= 0)) % (int32_t)p_62) ^ p_60) + (uint16_t)0x63C9)) >> (int16_t)0)), p_63, l_405), p_61, p_63, l_426, (**l_364));
                        /* statement id: 235 */
                        assert (l_361 == 0);
                        l_427 = (void*)0;
                        /* statement id: 236 */
                        assert (l_427 == 0);
                    }
                }
            }
            else
            { /* block id: 239 */
                uint16_t l_441 = 0xAEF1;
                int32_t l_450 = 0xAC54E8BC;
                if ((p_64 & 0x057BBC09))
                { /* block id: 240 */
                    struct S0 *l_428 = &l_380;
                    const struct S0 *l_430 = &l_380;
                    const struct S0 **l_429 = &l_430;
                    float *l_440 = &l_404;
                    int32_t l_442 = 0x994BD5D4;
                    (*l_429) = l_428;
                    if (((uint32_t)((int16_t)(+((void*)0 == &l_348)) - (int16_t)((0xFD5B540C <= (((l_436 != (*l_364)) & p_63) > ((~1) < __builtin_ia32_crc32qi(((1 || ((uint16_t)(func_98((**l_269), l_440, l_381) | l_441) << (uint16_t)p_60)) == l_441), l_441)))) < p_61)) - (uint32_t)l_442))
                    { /* block id: 242 */
                        float l_447 = 0xE.A5EEBCp+41;
                        (*l_365) = func_90(l_441, (l_443 != (void*)0), func_98((*l_444), l_381, l_381), l_442);
                        /* statement id: 243 */
                        assert (l_361 == 0);
                        l_450 = ((uint16_t)p_64 >> (uint16_t)13);
                    }
                    else
                    { /* block id: 245 */
                        uint32_t l_451 = 1U;
                        int32_t l_454 = 0x8D82269D;
                        l_451 = p_63;
                        l_454 = ((uint16_t)(p_62 != l_441) >> (uint16_t)p_64);
                        if (p_62)
                            continue;
                        //assert (l_361 == 0 || l_361 == dangling);
                        return p_61;
                    }
                    /* facts after branching */
                    assert (l_361 == 0);
                }
                else
                { /* block id: 251 */
                    return p_63;
                }
                /* facts after branching */
                assert (l_361 == 0);
            }
        }
        (*l_295) = (0x1.80E144p-29 < 0x7.6F4C6Ep-27);
    }
lbl_589:
    (*l_268) = l_455;
    if (p_62)
    { /* block id: 259 */
        int16_t l_456 = 0x3894;
        l_456 = p_62;
    }
    else
    { /* block id: 261 */
        const union U1 *l_457 = &l_271;
        union U1 **l_458 = (void*)0;
        union U1 **l_459 = (void*)0;
        union U1 **l_460 = (void*)0;
        union U1 **l_461 = &l_270;
        (*l_461) = l_457;
        if (p_63)
            goto lbl_462;
    }
    if ((p_60 != p_62))
    { /* block id: 265 */
        int32_t *l_463 = &l_272;
        int32_t **l_464 = &l_463;
        union U1 **l_499 = &l_270;
        union U1 ****l_518 = (void*)0;
        struct S0 l_537 = {-66,568,22};
        struct S0 *l_536 = &l_537;
        struct S0 **l_535 = &l_536;
        struct S0 ***l_534 = &l_535;
        (*l_464) = l_463;
        for (p_60 = 0; (p_60 >= 27); p_60 += 3)
        { /* block id: 269 */
            int32_t l_475 = 0x62FFCCE8;
            const int32_t **l_494 = &l_341;
            int32_t **l_506 = &l_463;
            const struct S0 ****l_510 = &l_508;
            union U1 ***l_529 = &l_499;
        }
        (*l_511) = (((p_61 && (1U < (p_61 >= (**l_464)))) ^ (((func_66(((uint32_t)((uint32_t)((**l_464) | l_588) - (uint32_t)((((*l_535) == (**l_534)) && (p_62 == (**l_464))) <= p_61)) % (uint32_t)(**l_464)), p_63, (**l_464), (*l_463), p_61) <= p_63) && (*l_463)) ^ 65534U)) != (**l_464));
        if (p_60)
            goto lbl_589;
    }
    else
    { /* block id: 346 */
        int16_t l_592 = (-7);
        struct S0 l_597 = {-710,9316,393};
        struct S0 *l_596 = &l_597;
        struct S0 ** const l_595 = &l_596;
        struct S0 ** const *l_594 = &l_595;
        l_597.f0 = ((((float)(l_592 != ((p_61 == (-(float)(l_594 == (void*)0))) == ((float)(l_597.f1 != (((((p_61 <= ((float)p_60 + (float)l_597.f2)) <= 0x0.4p+1) == l_597.f0) > p_61) == l_597.f0)) - (float)l_592))) + (float)0x0.8p-1) >= p_62) <= p_64);
        (*l_511) = (0x36AC <= ((((int16_t)((uint16_t)(1 || ((int16_t)((6 < l_597.f1) ^ ((int16_t)((p_62 < (*l_511)) == p_60) << (int16_t)p_64)) + (int16_t)(func_72((((((int32_t)l_597.f2 % (int32_t)l_612) ^ (-1)) <= l_597.f1) < p_61)) > p_62))) + (uint16_t)65535U) + (int16_t)p_63) <= p_63) & p_60));
        return p_64;
    }
    return p_61;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_66(uint32_t  p_67, uint16_t  p_68, uint32_t  p_69, const uint32_t  p_70, int32_t  p_71)
{ /* block id: 134 */
    float l_274 = 0xE.68C450p+28;
    float *l_273 = &l_274;
    int32_t l_277 = 8;
    int32_t *l_280 = &l_277;
    int32_t **l_279 = &l_280;
    (*l_273) = 0xC.BB4373p-97;
    for (p_69 = (-1); (p_69 <= 3); p_69++)
    { /* block id: 138 */
        int32_t *l_278 = &l_277;
        (*l_278) = (l_277 != (p_67 <= p_69));
        return l_277;
    }
    (*l_279) = &p_71;
    /* statement id: 142 */
    assert (l_280 == &p_71);
    for (l_277 = 25; (l_277 < 0); l_277 -= 7)
    { /* block id: 145 */
        if ((*l_280))
            break;
    }
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_72(int16_t  p_73)
{ /* block id: 44 */
    uint32_t l_80 = 4294967288U;
    float l_82 = 0x9.0p+1;
    float *l_81 = &l_82;
    union U1 l_89 = {0xC.9E6156p+53};
    struct S0 l_232 = {-913,9439,157};
    int32_t l_248 = 0;
    int32_t *l_247 = &l_248;
    float *l_255 = &l_89.f0;
    float *l_256 = (void*)0;
    float *l_257 = &l_89.f0;
    (*l_81) = ((0xD.229656p+97 >= ((((((float)((float)((float)(p_73 < (l_80 <= l_80)) + (float)l_80) + (float)((((((p_73 > l_80) == p_73) > 0x2.6F9C23p+21) <= l_80) >= (-0x1.7p-1)) != l_80)) + (float)0x5.4p-1) <= (-0x10.4p-1)) < p_73) != 0x0.5p+1) >= 0x7.47CEE5p-14)) <= p_73);
    l_247 = func_83(l_89, func_90(l_80, l_80, l_80, l_80), l_80, l_232, ((p_73 ^ (-1)) ^ l_80));
    /* statement id: 120 */
    assert (l_247 == 0);
    for (l_248 = 0; (l_248 == 28); l_248++)
    { /* block id: 123 */
        float l_251 = 0x1.9p+1;
        union U1 l_254 = {-0x1.4p-1};
        int32_t l_258 = 0x21CDB4FA;
        float *l_261 = &l_89.f0;
        float *l_262 = (void*)0;
        float *l_263 = &l_89.f0;
        float *l_264 = &l_251;
        int32_t **l_265 = &l_247;
        if (p_73)
            break;
        for (p_73 = 0; (p_73 <= (-3)); --p_73)
        { /* block id: 127 */
            return p_73;
        }
        l_232.f0 = func_98(l_254, l_255, l_256);
        (*l_265) = func_108(l_257, l_258, ((uint16_t)((((l_232.f0 <= (func_98(l_89, l_263, l_264) < l_232.f1)) <= 0x8B13) || p_73) == 0x0B003D96) + (uint16_t)0U), l_258, &l_248);
    }
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_83(union U1  p_84, float * p_85, const uint32_t  p_86, struct S0  p_87, uint16_t  p_88)
{ /* block id: 115 */
    float l_233 = 0x2.3p+1;
    int32_t l_234 = 0x5DC83D63;
    int32_t **l_237 = (void*)0;
    int32_t ***l_236 = &l_237;
    int32_t ****l_235 = &l_236;
    float l_238 = 0x0.5p+1;
    float *l_241 = (void*)0;
    float *l_242 = &l_238;
    int32_t l_244 = (-1);
    int32_t *l_245 = (void*)0;
    int32_t **l_246 = &l_245;
    (*l_242) = ((((l_233 > l_234) == ((l_235 != &l_236) > p_87.f2)) == (l_238 < (0x6.3p+1 < ((float)(p_87.f1 != p_87.f2) + (float)p_87.f0)))) != 0x1.5p-1);
    l_234 = ((__builtin_clz(p_86) >= (-9)) != (0U && ((~(p_87.f1 != p_87.f1)) | (((3U <= p_87.f0) | l_244) | p_87.f0))));
    (*l_246) = (void*)0;
    return p_85;
    /* statement id: 119 */
    //assert (func_83_rv == 0 || func_83_rv == &l_271.f0 || func_83_rv == &l_272 || func_83_rv == &l_641 || func_83_rv == &l_637);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float * func_90(float  p_91, uint32_t  p_92, int32_t  p_93, int16_t  p_94)
{ /* block id: 46 */
    uint16_t l_97 = 0x2D35;
    int32_t l_107 = 0;
    int32_t *l_106 = &l_107;
    float l_203 = 0x1.5p-1;
    float *l_202 = &l_203;
    float *l_204 = &l_203;
    float *l_222 = &l_203;
    float *l_223 = &l_203;
    union U1 l_228 = {0x1.Ap-1};
    float *l_229 = &l_228.f0;
    float *l_230 = (void*)0;
    float *l_231 = (void*)0;
    p_93 = (((uint32_t)(l_97 || (func_98(func_102(l_106, func_108(l_106, (0x4.EFF0D5p-37 > 0x1.3p+1), (*l_106), (*l_106), &l_107), l_106), l_202, l_204) == (-2))) % (uint32_t)0x0C1663C6) >= p_92);
    p_93 = (6 != (((&l_202 != &l_204) > func_98(l_228, l_229, l_230)) == (*l_106)));
    (*l_106) = p_93;
    return l_231;
    /* statement id: 114 */
    //assert (func_90_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_98(union U1  p_99, float * p_100, float * p_101)
{ /* block id: 102 */
    int32_t l_205 = (-1);
    int32_t *l_210 = (void*)0;
    int32_t **l_209 = &l_210;
    int32_t ***l_208 = &l_209;
    int32_t ****l_211 = (void*)0;
    const int32_t *l_215 = &l_205;
    const int32_t **l_214 = &l_215;
    const int32_t ***l_213 = &l_214;
    const int32_t ****l_212 = &l_213;
    int16_t l_219 = 0;
    for (l_205 = 20; (l_205 <= (-11)); --l_205)
    { /* block id: 105 */
        if (l_205)
            break;
    }
    (*l_212) = l_208;
    /* statement id: 108 */
    assert (l_213 == &l_209);
    l_205 = (((**l_214) | 0x75658741) && ((int16_t)__builtin_clz((*l_215)) >> (int16_t)(-(int16_t)(*l_215))));
    return l_219;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_102(int32_t * p_103, float * p_104, float * p_105)
{ /* block id: 50 */
    int32_t l_116 = 5;
    union U1 l_135 = {0xC.36BD20p+47};
    int32_t l_174 = 0x4B5E4FDE;
    uint32_t l_186 = 5U;
    union U1 *l_188 = &l_135;
    union U1 **l_187 = &l_188;
    union U1 l_201 = {-0x1.Ep-1};
    for (l_116 = 0; (l_116 < (-26)); l_116 -= 6)
    { /* block id: 53 */
        union U1 l_120 = {0x2.52B10Ap-41};
        union U1 *l_119 = &l_120;
        union U1 **l_121 = (void*)0;
        const union U1 *l_123 = (void*)0;
        const union U1 **l_122 = &l_123;
        int32_t l_128 = 0x92859F96;
        float *l_131 = &l_120.f0;
        const union U1 **l_189 = (void*)0;
        int32_t l_195 = 0x2ECAC6B4;
        if (l_116)
            break;
        (*l_122) = l_119;
        /* statement id: 55 */
        assert (l_123 == &l_120);
        if (((((int16_t)(l_116 | ((uint32_t)l_128 - (uint32_t)(((int16_t)(l_128 <= l_116) - (int16_t)0xCC41) & l_128))) >> (int16_t)__builtin_clzl(l_116)) <= (((void*)0 != l_131) >= l_128)) <= l_128))
        { /* block id: 56 */
            union U1 l_134 = {-0x1.3p-1};
            for (l_128 = 3; (l_128 == 12); l_128++)
            { /* block id: 59 */
                return l_134;
                /* statement id: 60 */
                            }
            if ((*p_103))
                continue;
            return l_135;
            /* statement id: 63 */
                    }
        else
        { /* block id: 64 */
            int16_t l_138 = 0;
            int32_t *l_198 = (void*)0;
            int32_t **l_197 = &l_198;
            int32_t ***l_196 = &l_197;
            float **l_200 = &l_131;
            for (l_128 = 15; (l_128 < 20); ++l_128)
            { /* block id: 67 */
                int32_t l_145 = 0x84DD3EA5;
                float l_169 = 0x7.3p-1;
                if (l_138)
                { /* block id: 68 */
                    union U1 **l_139 = &l_119;
                    union U1 ***l_140 = &l_139;
                    (*l_140) = l_139;
                    (*p_103) = 0xB78F42CB;
                }
                else
                { /* block id: 71 */
                    uint32_t l_162 = 4294967290U;
                    const union U1 ***l_167 = &l_122;
                    const int16_t l_168 = (-7);
                    int32_t *l_171 = (void*)0;
                    int32_t **l_170 = &l_171;
                    for (l_138 = 25; (l_138 < 22); --l_138)
                    { /* block id: 74 */
                        int32_t l_154 = (-2);
                        struct S0 **l_163 = (void*)0;
                        struct S0 l_166 = {-436,9077,109};
                        struct S0 *l_165 = &l_166;
                        struct S0 **l_164 = &l_165;
                        (*p_103) = ((uint16_t)l_145 << (uint16_t)((int32_t)((int16_t)((((int32_t)((l_128 && ((int16_t)(l_154 <= (((l_128 >= ((uint16_t)((int16_t)l_154 - (int16_t)0xA0B7) >> (uint16_t)l_145)) >= ((-(int32_t)(((int32_t)(l_138 | (l_128 || 4294967286U)) + (int32_t)1) & 9U)) && 1)) || l_128)) - (int16_t)l_138)) < l_162) - (int32_t)(*p_103)) > 8U) ^ 4) << (int16_t)4) + (int32_t)l_128));
                        (*l_164) = (void*)0;
                        /* statement id: 76 */
                        assert (l_165 == 0);
                        if ((*p_103))
                            continue;
                    }
                    (*p_105) = (((((void*)0 != l_167) > (l_168 >= 0x7.16E3A4p-34)) < __builtin_popcount(l_138)) <= (*p_105));
                    (*l_170) = (void*)0;
                    (*l_131) = 0x6.983FE5p+14;
                }
                l_174 = (((uint16_t)0x3D11 >> (uint16_t)l_138) != (l_145 < (l_128 <= l_128)));
                (*p_105) = (*p_105);
                if (l_145)
                { /* block id: 85 */
                    uint32_t l_182 = 0x5E917A82;
                    uint32_t l_194 = 0U;
                    for (l_145 = 0; (l_145 <= 20); l_145 += 3)
                    { /* block id: 88 */
                        float l_178 = (-0x9.Dp+1);
                        int32_t l_179 = 0x8EC91527;
                        (*p_103) = ((-(uint32_t)l_174) >= (l_145 ^ l_116));
                        if (l_179)
                            break;
                        l_195 = (((((float)l_182 - (float)(!(l_116 == ((float)l_116 - (float)l_186)))) > (l_187 == l_189)) > ((float)(*p_105) + (float)((*p_105) <= ((float)(*p_105) - (float)l_194)))) >= l_194);
                    }
                }
                else
                { /* block id: 93 */
                    int32_t ****l_199 = &l_196;
                    (*l_199) = l_196;
                    (***l_199) = p_105;
                    /* statement id: 95 */
                    //assert (l_198 == &l_107 || l_198 == &l_637 || l_198 == &l_641);
                    l_200 = &l_131;
                }
            }
            /* facts after for loop */
            //assert (l_198 == &l_107 || l_198 == 0 || l_198 == &l_637 || l_198 == &l_641);
        }
    }
    return l_201;
    /* statement id: 101 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_108(float * p_109, float  p_110, uint32_t  p_111, uint32_t  p_112, int32_t * const  p_113)
{ /* block id: 47 */
    int32_t *l_114 = (void*)0;
    int32_t **l_115 = &l_114;
    (*l_115) = l_114;
    return l_114;
    /* statement id: 49 */
    //assert (func_108_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_36();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 269
   depth: 1, occurrence: 2
XXX total union variables: 12

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 22
breakdown:
   indirect level: 0, occurrence: 2
   indirect level: 1, occurrence: 8
   indirect level: 2, occurrence: 4
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 5
XXX full-bitfields structs in the program: 2
breakdown:
   indirect level: 0, occurrence: 2
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 20

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 286
   depth: 2, occurrence: 42
   depth: 3, occurrence: 10
   depth: 4, occurrence: 4
   depth: 5, occurrence: 8
   depth: 6, occurrence: 4
   depth: 7, occurrence: 2
   depth: 8, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 4
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 4
   depth: 18, occurrence: 2
   depth: 19, occurrence: 5
   depth: 20, occurrence: 3
   depth: 21, occurrence: 3
   depth: 23, occurrence: 1
   depth: 30, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 240

XXX times a variable address is taken: 218
XXX times a pointer is dereferenced on RHS: 141
breakdown:
   depth: 1, occurrence: 84
   depth: 2, occurrence: 47
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2
XXX times a pointer is dereferenced on LHS: 120
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 23
   depth: 3, occurrence: 4
XXX times a pointer is compared with null: 29
XXX times a pointer is compared with address of another variable: 16
XXX times a pointer is compared with another pointer: 13
XXX times a pointer is qualified to be dereferenced: 738

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 372
   level: 2, occurrence: 157
   level: 3, occurrence: 73
   level: 4, occurrence: 63
XXX number of pointers point to pointers: 128
XXX number of pointers point to scalars: 87
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 27.9
XXX average alias set size: 1.32

XXX times a non-volatile is read: 1124
XXX times a non-volatile is write: 354
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 4

XXX stmts: 253
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 36
   depth: 1, occurrence: 38
   depth: 2, occurrence: 38
   depth: 3, occurrence: 49
   depth: 4, occurrence: 48
   depth: 5, occurrence: 44

XXX percentage a fresh-made variable is used: 19.5
XXX percentage an existing variable is used: 80.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

