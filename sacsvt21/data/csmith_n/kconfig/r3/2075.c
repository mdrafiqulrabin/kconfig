/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      3812612184
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int16_t  f0;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 31;
   unsigned f1 : 5;
   signed f2 : 22;
   int32_t  f3;
   uint16_t  f4;
   unsigned f5 : 16;
   unsigned f6 : 14;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 0U;
static uint32_t g_89 = 0xE2D4DC45;
static struct S0 g_90 = {0xF75F};
static struct S1 g_106 = {37171,0,-1043,0x9BBDC218,0x3D83,97,2};
static int32_t g_269 = 1;
static struct S0 g_292 = {1};
static struct S1 g_309 = {29019,4,215,-8,0xF7FB,154,101};
static int16_t g_430 = 0x700F;
static uint32_t g_481 = 0x27ED631A;
static int32_t g_569 = (-1);


/* --- FORWARD DECLARATIONS --- */
static struct S1  func_28(void);
static uint16_t  func_32(uint32_t  p_33, uint32_t  p_34);
static struct S1  func_37(uint32_t  p_38);
static uint16_t  func_46(int16_t  p_47, int32_t  p_48, int32_t  p_49, int32_t  p_50, struct S0  p_51);
static uint32_t  func_58(uint32_t  p_59, int16_t  p_60);
static uint16_t  func_72(uint16_t  p_73, uint32_t  p_74, int32_t  p_75);
static struct S0  func_81(uint32_t  p_82, uint32_t  p_83);
static int32_t  func_85(uint32_t  p_86);
static int16_t  func_94(uint32_t  p_95, uint32_t  p_96, int32_t  p_97);
static uint32_t  func_98(struct S1  p_99, uint32_t  p_100, int32_t  p_101, uint32_t  p_102, uint32_t  p_103);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_90 g_106.f0 g_89 g_106.f6 g_106.f4 g_106.f2 g_106.f5 g_106.f3 g_106.f1 g_269 g_292.f0 g_292 g_106 g_309.f4 g_309.f0 g_309.f3 g_309.f2 g_309.f5 g_309.f6 g_309.f1 g_430 g_481 g_309 g_569
 * writes: g_89 g_106 g_90.f0 g_269 g_90 g_292 g_309 g_5
 */
static struct S1  func_28(void)
{ /* block id: 36 */
    uint32_t l_29 = 0x5AC3D6C1;
    int32_t l_431 = (-1);
    uint16_t l_443 = 0U;
    uint32_t l_452 = 8U;
    int16_t l_467 = 1;
    uint16_t l_483 = 65535U;
    int32_t l_515 = 0x44FC28B5;
    uint16_t l_521 = 0xACB7;
    int32_t l_535 = 0x730CD26F;
    struct S0 l_538 = {-10};
    struct S1 l_573 = {33740,3,-1480,0xDF4BE7A1,0x7E46,2,25};
    int32_t l_585 = 0x6A834ACB;
    if ((l_29 <= g_5))
    { /* block id: 37 */
        int32_t l_35 = 0xF4DF7B14;
        struct S0 l_453 = {-1};
        int32_t l_466 = 0x699D0825;
        uint16_t l_482 = 0U;
        int16_t l_516 = 0;
        int32_t l_524 = (-1);
        int32_t l_525 = 0x13EE5482;
        struct S0 l_543 = {-4};
        l_431 = ((uint16_t)func_32(g_5, (l_35 && __builtin_clz(g_5))) - (uint16_t)((int16_t)((l_29 >= (((uint16_t)((int16_t)(((uint16_t)g_430 - (uint16_t)l_29) < ((((__builtin_ffs(g_430) < 0x45DF) | l_29) <= 0xC820) != 0x87285B82)) << (int16_t)l_35) % (uint16_t)g_430) | g_430)) == l_35) << (int16_t)2));
        l_453 = func_81((((int16_t)g_309.f6 - (int16_t)g_90.f0) || ((uint16_t)__builtin_ffs(l_35) << (uint16_t)((uint16_t)__builtin_parityll(((uint16_t)((((int16_t)l_431 + (int16_t)(!l_35)) || (l_443 < ((int16_t)(((int32_t)(((-1) && (((int16_t)((uint32_t)1U % (uint32_t)l_452) << (int16_t)g_89) ^ 1)) ^ l_431) - (int32_t)g_309.f6) && (-1)) + (int16_t)l_35))) || g_309.f6) % (uint16_t)g_309.f3)) >> (uint16_t)l_29))), l_443);
        if (((l_35 && (((((int16_t)__builtin_ia32_crc32qi(((int32_t)1 - (int32_t)l_35), l_453.f0) >> (int16_t)(((int16_t)(l_35 <= ((uint32_t)l_453.f0 - (uint32_t)((uint16_t)g_5 >> (uint16_t)7))) << (int16_t)(((uint16_t)l_35 << (uint16_t)l_466) || l_453.f0)) != l_466)) & 6) || l_467) | g_309.f4)) < g_269))
        { /* block id: 245 */
            int16_t l_474 = 0xC64A;
            int32_t l_484 = 0x18BF8B18;
            uint32_t l_487 = 4294967295U;
            struct S1 l_503 = {4935,3,1149,0xA54794A0,0U,224,111};
            uint32_t l_508 = 0U;
            struct S1 l_518 = {33549,2,-1459,0,0U,187,101};
            g_309.f2 = ((g_309.f4 <= ((((((uint16_t)((int32_t)g_309.f5 % (int32_t)((uint16_t)0x3A35 + (uint16_t)func_58(g_106.f2, (l_474 >= ((g_106.f3 | ((uint32_t)(((((__builtin_clzll(((int32_t)__builtin_bswap64((l_474 >= (g_89 && ((uint16_t)g_481 - (uint16_t)l_474)))) - (int32_t)l_474)) <= g_292.f0) <= l_467) != l_474) || 0xA946E749) && 0U) + (uint32_t)l_482)) > l_483))))) - (uint16_t)l_474) ^ l_482) == 1) & l_474) != l_484)) && g_106.f2);
            if ((1 ^ (((uint16_t)l_484 >> (uint16_t)10) & l_487)))
            { /* block id: 247 */
                struct S0 l_488 = {0x02A1};
                struct S1 l_504 = {44959,3,-1573,0x4A3F1D02,0x599E,46,50};
                l_488 = func_81(g_106.f2, g_89);
                if (g_106.f0)
                { /* block id: 249 */
                    uint32_t l_498 = 4294967287U;
                    uint32_t l_502 = 0x390281E5;
                    struct S1 l_517 = {4126,1,1187,0xC4EBD6CA,0xA1E9,218,14};
                    if (__builtin_ctzl(g_309.f3))
                    { /* block id: 250 */
                        struct S0 l_489 = {1};
                        g_292 = l_489;
                    }
                    else
                    { /* block id: 252 */
                        uint32_t l_501 = 5U;
                        g_309.f2 = g_106.f5;
                        l_502 = ((g_106.f6 >= 0x52A0BBEA) <= ((((int16_t)l_484 >> (int16_t)11) >= ((int16_t)((((((l_488.f0 == l_488.f0) || (((int16_t)l_474 - (int16_t)((((l_498 <= (((int32_t)(l_498 < ((-6) || g_309.f1)) - (int32_t)0x9844047B) >= 0)) != g_309.f4) == l_487) >= (-1))) <= 1U)) <= 0) < g_5) | 3) | l_501) << (int16_t)7)) && g_309.f4));
                        l_504 = l_503;
                    }
                    for (l_503.f4 = (-22); (l_503.f4 < 11); l_503.f4 += 1)
                    { /* block id: 259 */
                        return g_106;
                    }
                    if (((((-(uint16_t)((l_508 ^ ((g_309.f0 <= l_504.f1) || ((uint16_t)((((int16_t)((func_32(((0 && (((__builtin_ffsll(((((int32_t)g_309.f0 + (int32_t)g_269) == __builtin_popcount((l_515 & l_35))) > g_292.f0)) < 0U) > g_481) || 65535U)) && g_309.f2), g_309.f6) <= l_498) >= 0x39D8) >> (int16_t)14) && l_452) & 0x756A15EE) << (uint16_t)l_467))) && 0x121B)) < l_488.f0) != l_498) == 65535U))
                    { /* block id: 262 */
                        l_516 = (l_504.f4 & (g_269 && 0x0B300B62));
                    }
                    else
                    { /* block id: 264 */
                        l_518 = l_517;
                        g_90 = func_81(l_503.f1, g_309.f0);
                        g_106.f2 = l_515;
                    }
                    l_515 = g_292.f0;
                }
                else
                { /* block id: 270 */
                    g_309 = l_504;
                    l_524 = (((int16_t)((l_521 || __builtin_popcount(((uint32_t)__builtin_ctzl(g_481) + (uint32_t)l_504.f0))) >= l_504.f6) >> (int16_t)14) ^ g_106.f0);
                    return g_309;
                }
            }
            else
            { /* block id: 275 */
                uint32_t l_544 = 0xCDBFF98F;
                int16_t l_547 = 2;
                struct S0 l_549 = {6};
                uint32_t l_567 = 4294967292U;
                if (l_518.f5)
                { /* block id: 276 */
                    uint16_t l_532 = 0xDAC9;
                    int16_t l_551 = 0x6796;
                    int32_t l_558 = 2;
                    g_90 = g_292;
                    if (((((0xA727 | l_525) != l_431) && (((uint16_t)__builtin_bswap64((((int16_t)0x126F << (int16_t)3) >= ((uint16_t)(((0x63CC25B8 == l_532) == l_487) < ((uint32_t)(0x3BEA1271 <= (((g_309.f4 & g_309.f0) == l_532) != g_106.f6)) + (uint32_t)l_524)) + (uint16_t)g_292.f0))) << (uint16_t)g_309.f2) == 0x10D6)) <= l_535))
                    { /* block id: 278 */
                        uint32_t l_542 = 0xA4E57BA1;
                        g_309.f2 = 0x2AD7E1A4;
                        l_518 = g_309;
                        l_538 = func_81(g_481, (((int16_t)g_106.f3 >> (int16_t)6) || g_309.f1));
                        l_544 = func_46(((uint16_t)g_309.f2 * (uint16_t)0U), (~__builtin_parityll(l_542)), (g_106.f4 & (((g_309.f4 | g_309.f6) <= g_5) <= g_90.f0)), g_430, l_543);
                    }
                    else
                    { /* block id: 283 */
                        uint32_t l_548 = 0x31609210;
                        l_549 = func_81((__builtin_parity(g_106.f5) && (((int32_t)g_106.f3 + (int32_t)g_309.f5) >= __builtin_parityll(g_292.f0))), ((l_547 && 0x66E38582) != l_548));
                        l_558 = ((-(uint32_t)((((((l_551 <= l_515) > l_544) ^ g_292.f0) < ((((int32_t)l_548 + (int32_t)(l_548 <= ((uint16_t)((uint16_t)(0x20CB603B >= (((g_309.f4 < g_89) == 0U) && l_453.f0)) + (uint16_t)1) + (uint16_t)g_106.f1))) != g_481) != 0x418F)) || 0x071866DF) < l_518.f3)) <= 0x500F);
                    }
                }
                else
                { /* block id: 287 */
                    int32_t l_568 = (-10);
                    int32_t l_572 = 1;
                    l_453 = func_81(l_466, func_94(l_547, l_518.f3, ((__builtin_parity(g_309.f5) != (((int32_t)(((int32_t)(9U > l_543.f0) % (int32_t)func_58(((int32_t)((((((int32_t)g_430 - (int32_t)(1U > g_5)) <= l_567) < l_568) | l_549.f0) || l_518.f1) + (int32_t)l_567), g_89)) & g_569) + (int32_t)0xCE69AB97) < g_309.f2)) ^ g_309.f1)));
                    for (l_29 = 24; (l_29 > 1); l_29 -= 2)
                    { /* block id: 291 */
                        l_572 = (g_106.f2 != l_518.f0);
                        l_572 = g_90.f0;
                        return l_518;
                    }
                }
                l_573 = l_518;
                l_573.f2 = 0x45A96515;
            }
        }
        else
        { /* block id: 300 */
            int32_t l_576 = (-1);
            if (((uint16_t)l_576 + (uint16_t)((uint32_t)((int32_t)0x7F7BDFC5 + (int32_t)(0x1C1B63B0 == (__builtin_clzl(l_576) > g_89))) - (uint32_t)((((uint16_t)g_106.f4 - (uint16_t)((uint32_t)(0xED96941F <= ((g_309.f4 >= 8U) || l_538.f0)) % (uint32_t)l_576)) <= 0x33C9541F) == 4294967295U))))
            { /* block id: 301 */
                return g_309;
            }
            else
            { /* block id: 303 */
                l_524 = ((l_576 > 4294967294U) > (l_576 & (0x7F7B7704 | l_585)));
                g_106.f2 = 0x85283284;
            }
        }
    }
    else
    { /* block id: 308 */
        int32_t l_598 = 0x3DA0F1B8;
        struct S0 l_599 = {0x5FF2};
        struct S1 l_600 = {23127,1,-1142,-1,0xAD2F,93,121};
        l_431 = ((int16_t)g_106.f4 << (int16_t)((uint32_t)0x68CED126 % (uint32_t)__builtin_parityl(((((int16_t)((uint16_t)((int16_t)((int16_t)((4294967291U <= ((((g_269 <= l_598) & (4U & g_106.f1)) <= func_46(((g_569 && g_106.f2) || 1U), g_269, g_309.f5, l_598, l_599)) <= 0x4B62A37B)) & l_573.f3) - (int16_t)g_5) % (int16_t)l_599.f0) >> (uint16_t)7) >> (int16_t)5) != (-1)) | (-1)))));
        return l_600;
    }
    return g_309;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_90 g_106.f0 g_89 g_106.f6 g_106.f4 g_106.f2 g_106.f5 g_106.f3 g_106.f1 g_269 g_292.f0 g_292 g_106 g_309.f4 g_309.f0 g_309.f3 g_309.f2 g_309.f5 g_309.f6 g_309.f1
 * writes: g_89 g_106 g_90.f0 g_269 g_90 g_292 g_309 g_5
 */
static uint16_t  func_32(uint32_t  p_33, uint32_t  p_34)
{ /* block id: 38 */
    uint32_t l_36 = 0xFBFC75DA;
    int32_t l_357 = 1;
    struct S0 l_366 = {-10};
    struct S1 l_369 = {15223,3,860,7,0U,143,5};
    uint16_t l_385 = 0xF047;
    int16_t l_396 = 0x1A86;
    if (l_36)
    { /* block id: 39 */
        uint32_t l_310 = 0U;
        uint32_t l_340 = 0x519DD2A1;
        struct S0 l_365 = {0};
        g_309 = func_37(((((uint32_t)l_36 + (uint32_t)7) == g_5) < g_5));
        if (((((0xEB9A496B ^ l_36) == l_310) | g_309.f4) && (((((((uint32_t)((int16_t)p_33 % (int16_t)p_33) - (uint32_t)g_309.f0) && func_94(p_33, ((((int16_t)(~(l_310 <= g_309.f3)) - (int16_t)p_33) ^ g_106.f2) | l_310), l_36)) | g_309.f3) && 0U) | g_292.f0) != 0)))
        { /* block id: 163 */
            int16_t l_322 = 0x378A;
            int16_t l_323 = 0;
            int32_t l_342 = 1;
            if (((~p_34) >= g_309.f3))
            { /* block id: 164 */
                int32_t l_328 = 3;
                struct S0 l_341 = {0};
                int16_t l_364 = 0xBDF1;
                g_269 = ((-(uint16_t)0xA207) < (((int32_t)p_33 + (int32_t)4) & (((l_322 > l_323) && ((g_106.f2 != p_34) | ((int32_t)((uint16_t)func_85((7 | (0x55B7 == g_106.f0))) % (uint16_t)0xEFB0) - (int32_t)g_106.f3))) > 2)));
                l_341 = func_81(l_328, func_72(((int16_t)((uint16_t)0x7D56 << (uint16_t)12) << (int16_t)4), ((((uint32_t)l_328 + (uint32_t)(-(int32_t)(0x4E59 >= g_5))) | (g_309.f2 & ((uint32_t)(g_309.f3 <= (((int16_t)__builtin_popcount(l_340) - (int16_t)g_106.f4) != 9)) + (uint32_t)0xA37043CB))) ^ (-9)), l_36));
                l_342 = g_106.f6;
                g_309.f2 = (((int16_t)((uint16_t)(g_309.f4 & ((int16_t)((uint32_t)(l_36 <= func_72(((uint16_t)(p_34 != ((int16_t)0xD1DB >> (int16_t)11)) << (uint16_t)((uint16_t)l_357 >> (uint16_t)((uint32_t)((int32_t)p_34 % (int32_t)l_341.f0) + (uint32_t)(((l_322 & (((int32_t)(l_364 > p_34) % (int32_t)0xD3101227) & p_34)) | 8U) || 0x3462)))), g_309.f0, l_322)) % (uint32_t)p_33) << (int16_t)g_309.f5)) >> (uint16_t)p_34) << (int16_t)12) == p_34);
            }
            else
            { /* block id: 169 */
                g_309.f2 = (g_106.f6 == (g_106.f3 || p_33));
                l_342 = p_34;
                return p_34;
            }
            g_90 = l_365;
        }
        else
        { /* block id: 175 */
            l_365 = l_366;
        }
        for (g_309.f3 = 0; (g_309.f3 != 26); g_309.f3 += 1)
        { /* block id: 180 */
            if (p_33)
                break;
        }
    }
    else
    { /* block id: 183 */
        int16_t l_370 = 0x38DF;
        struct S1 l_372 = {32179,3,-1744,0,0U,157,44};
        if (func_98(l_369, l_370, p_34, g_292.f0, p_33))
        { /* block id: 184 */
            struct S1 l_371 = {16608,3,-949,0x37DBD587,0x8F40,243,27};
            l_372 = l_371;
        }
        else
        { /* block id: 186 */
            return p_33;
        }
        for (g_106.f4 = (-12); (g_106.f4 < 58); g_106.f4 += 1)
        { /* block id: 191 */
            struct S1 l_382 = {38024,3,261,0x7B897F4E,2U,106,93};
            for (p_34 = 0; (p_34 < 21); p_34 += 4)
            { /* block id: 194 */
                struct S1 l_381 = {42688,4,180,0xCEFA681B,65528U,254,58};
                for (l_369.f3 = 0; (l_369.f3 == 22); l_369.f3 += 8)
                { /* block id: 197 */
                    return g_89;
                }
                for (g_5 = 7; (g_5 <= 4); g_5 -= 7)
                { /* block id: 202 */
                    l_382 = l_381;
                }
            }
        }
    }
    if ((((uint32_t)(l_385 > ((int16_t)(p_33 & p_33) << (int16_t)((uint32_t)((((int32_t)p_33 + (int32_t)(((((((int16_t)0x3180 >> (int16_t)(g_309.f6 >= (l_385 & (l_396 > (0xDE528EB5 <= g_269))))) ^ l_366.f0) > (-6)) >= g_309.f6) || p_33) <= g_90.f0)) >= g_309.f4) | p_34) + (uint32_t)0x6EFF648C))) - (uint32_t)l_369.f3) == g_5))
    { /* block id: 208 */
        uint16_t l_404 = 0x6557;
        int32_t l_414 = 0;
        struct S0 l_419 = {6};
        for (l_357 = 0; (l_357 > 8); l_357 += 1)
        { /* block id: 211 */
            int16_t l_409 = 0xAE95;
            for (g_309.f3 = (-28); (g_309.f3 != 17); g_309.f3 += 9)
            { /* block id: 214 */
                uint32_t l_403 = 0x8DDDB469;
                int32_t l_408 = 0x19AA14C0;
                if (((int16_t)__builtin_ffsll(l_403) % (int16_t)(0x53F47ECD || func_94(p_33, (((l_404 && (((uint32_t)__builtin_popcount((p_33 && ((-(uint16_t)g_309.f3) & (((__builtin_parityll((l_408 & (func_94(l_409, g_106.f4, g_106.f5) < (-4)))) > g_309.f1) ^ l_408) && 0xC77B2505)))) + (uint32_t)0x167C5440) != 4U)) ^ g_309.f3) >= p_33), g_309.f0))))
                { /* block id: 215 */
                    for (g_292.f0 = 0; (g_292.f0 != (-28)); g_292.f0 -= 1)
                    { /* block id: 218 */
                        l_414 = ((uint32_t)p_34 % (uint32_t)p_33);
                    }
                    for (l_404 = 0; (l_404 < 4); l_404 += 8)
                    { /* block id: 223 */
                        return p_33;
                    }
                }
                else
                { /* block id: 226 */
                    l_366 = g_292;
                    for (g_269 = (-20); (g_269 == (-7)); g_269 += 9)
                    { /* block id: 230 */
                        g_90 = l_419;
                    }
                }
            }
        }
        l_369.f2 = ((p_33 | p_33) ^ l_414);
        return g_292.f0;
    }
    else
    { /* block id: 238 */
        l_369.f2 = g_309.f0;
        g_309.f2 = ((int32_t)(-8) % (int32_t)(func_85(g_269) && g_309.f1));
    }
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_90 g_106.f0 g_89 g_106.f6 g_106.f4 g_106.f2 g_106.f5 g_106.f3 g_106.f1 g_269 g_292.f0 g_292 g_106
 * writes: g_89 g_106 g_90.f0 g_269 g_90 g_292
 */
static struct S1  func_37(uint32_t  p_38)
{ /* block id: 40 */
    int32_t l_56 = 1;
    struct S0 l_299 = {0xAC0E};
    int32_t l_308 = 0xDCD4F550;
    l_308 = ((~((int16_t)0x7F28 >> (int16_t)((uint16_t)func_46(((int16_t)((uint32_t)p_38 - (uint32_t)l_56) << (int16_t)8), (~((l_56 > func_58(l_56, l_56)) <= (g_5 && ((int32_t)p_38 % (int32_t)l_56)))), l_56, g_5, l_299) % (uint16_t)l_56))) ^ p_38);
    l_299 = g_292;
    return g_106;
}


/* ------------------------------------------ */
/* 
 * reads : g_292.f0
 * writes:
 */
static uint16_t  func_46(int16_t  p_47, int32_t  p_48, int32_t  p_49, int32_t  p_50, struct S0  p_51)
{ /* block id: 155 */
    int16_t l_303 = 0x11DB;
    int32_t l_306 = 0xD75D162C;
    int32_t l_307 = 0xD279F683;
    p_49 = ((uint16_t)(!(l_303 && (4294967295U < ((int16_t)g_292.f0 << (int16_t)l_306)))) + (uint16_t)p_50);
    l_307 = l_303;
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_90 g_106.f0 g_89 g_106.f6 g_106.f4 g_106.f2 g_106.f5 g_106.f3 g_106.f1 g_269 g_292.f0
 * writes: g_89 g_106 g_90.f0 g_269 g_90 g_292
 */
static uint32_t  func_58(uint32_t  p_59, int16_t  p_60)
{ /* block id: 41 */
    int32_t l_66 = 0xCA6696B4;
    int32_t l_67 = 0x351F4A1A;
    l_67 = (~(((p_60 > ((uint16_t)(((0x1460DEEA | (0xEB6BA8A7 | (((g_5 == ((uint32_t)g_5 % (uint32_t)0x237DDC4E)) < (l_66 | __builtin_clzl(g_5))) >= l_66))) && 0x3A20) && l_66) % (uint16_t)0xBC8C)) & l_66) && g_5));
    l_67 = (((int16_t)((p_59 && ((int16_t)g_5 << (int16_t)(func_72(l_66, l_66, l_67) != (g_5 ^ (0x819F && (((-(int16_t)g_5) | 0x91F7) < g_5)))))) & l_66) % (int16_t)0x7666) >= g_5);
    for (g_292.f0 = 0; (g_292.f0 > 29); g_292.f0 += 1)
    { /* block id: 149 */
        struct S0 l_296 = {-1};
        l_296 = g_90;
        if (l_66)
            continue;
        l_67 = l_296.f0;
    }
    return l_67;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_90 g_106.f0 g_89 g_106.f6 g_106.f4 g_106.f2 g_106.f5 g_106.f3 g_106.f1 g_269
 * writes: g_89 g_106 g_90.f0 g_269 g_90 g_292
 */
static uint16_t  func_72(uint16_t  p_73, uint32_t  p_74, int32_t  p_75)
{ /* block id: 43 */
    uint32_t l_78 = 0x918CD8B1;
    struct S1 l_104 = {9651,4,-1152,0xE2F9DBC3,0x0632,132,2};
    p_75 = (((uint16_t)l_78 % (uint16_t)g_5) >= g_5);
    for (p_74 = (-2); (p_74 != 50); p_74 += 1)
    { /* block id: 47 */
        struct S0 l_91 = {6};
        if (g_5)
            break;
        l_91 = func_81(g_5, ((-(int16_t)p_75) | 0x8F8F));
    }
    g_292 = func_81(((func_85(((((p_75 ^ l_78) ^ ((int16_t)func_94((func_98(l_104, p_73, g_90.f0, l_104.f0, func_85(p_74)) > p_75), l_104.f1, l_104.f0) + (int16_t)g_5)) || g_106.f4) && g_106.f4)) || l_104.f3) == 1U), g_5);
    return g_106.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_90
 * writes: g_89
 */
static struct S0  func_81(uint32_t  p_82, uint32_t  p_83)
{ /* block id: 49 */
    uint16_t l_87 = 0xABB0;
    g_89 = func_85(l_87);
    return g_90;
}


/* ------------------------------------------ */
/* 
 * reads : g_5
 * writes:
 */
static int32_t  func_85(uint32_t  p_86)
{ /* block id: 50 */
    uint32_t l_88 = 0x6FFBA4BD;
    l_88 = p_86;
    return g_5;
}


/* ------------------------------------------ */
/* 
 * reads : g_90.f0 g_106.f0 g_89 g_5 g_106.f6 g_106.f4 g_106.f2 g_106.f5 g_106.f3 g_106.f1 g_90 g_269
 * writes: g_90.f0 g_106.f4 g_106.f2 g_106 g_89 g_269 g_90
 */
static int16_t  func_94(uint32_t  p_95, uint32_t  p_96, int32_t  p_97)
{ /* block id: 63 */
    uint32_t l_107 = 4294967291U;
    int32_t l_115 = 7;
    int32_t l_142 = 0x16B54986;
    int32_t l_232 = 0x19DA8299;
    uint16_t l_233 = 0xD56E;
    struct S0 l_237 = {5};
    uint16_t l_252 = 65535U;
    uint16_t l_256 = 0x366D;
    int32_t l_277 = 0x061EBB8F;
    struct S1 l_291 = {42287,0,1854,0xF3D4169C,0U,141,108};
    if (l_107)
    { /* block id: 64 */
        int32_t l_124 = 6;
        uint16_t l_172 = 65529U;
        struct S0 l_197 = {4};
        for (g_90.f0 = 0; (g_90.f0 >= (-6)); g_90.f0 -= 2)
        { /* block id: 67 */
            int16_t l_135 = 0;
            if (((int32_t)((int32_t)(-(int16_t)g_106.f0) % (int32_t)(((p_95 >= __builtin_bswap64(g_89)) != l_115) | ((((g_5 & (((uint16_t)(p_97 && ((int16_t)((uint16_t)0U >> (uint16_t)((int16_t)(__builtin_ctz((g_90.f0 < p_96)) <= g_106.f0) >> (int16_t)p_95)) + (int16_t)g_106.f6)) >> (uint16_t)4) && l_107)) != l_115) && p_96) >= l_124))) - (int32_t)0x885E37C3))
            { /* block id: 68 */
                for (g_106.f4 = 11; (g_106.f4 != 47); g_106.f4 += 6)
                { /* block id: 71 */
                    l_124 = 0;
                }
                g_106.f2 = (((int16_t)((uint16_t)g_106.f2 << (uint16_t)2) >> (int16_t)(((l_107 && (func_85(((uint16_t)(0x217F & ((((l_135 <= (((((((int32_t)(func_85(func_85(l_135)) <= (((g_5 | ((int16_t)func_85((((uint32_t)(g_89 && l_142) % (uint32_t)l_124) > p_96)) << (int16_t)g_106.f4)) ^ 1) || 5U)) - (int32_t)0x6F2D310D) > 0x21A4FECF) >= l_124) > g_106.f2) <= 0xEB29FA79) < 0xB1FF)) ^ l_135) || p_97) < p_95)) << (uint16_t)0)) || p_97)) | g_106.f0) ^ 5U)) && g_106.f5);
                l_124 = l_107;
            }
            else
            { /* block id: 76 */
                int32_t l_148 = (-7);
                l_148 = ((-2) || ((__builtin_ffs(p_95) || ((-1) > (((uint32_t)((uint32_t)(~0xFA41) - (uint32_t)__builtin_clzl(p_96)) - (uint32_t)0) != g_106.f3))) == 0));
            }
        }
        g_106.f2 = ((uint16_t)((uint16_t)func_85(((uint32_t)0x2F114C85 - (uint32_t)(__builtin_ctzl(g_5) | p_96))) << (uint16_t)15) + (uint16_t)(g_106.f1 & (-(int32_t)((0x57E95F64 && (func_85((!g_106.f4)) >= l_107)) ^ g_106.f5))));
        for (l_107 = 0; (l_107 != 43); l_107 += 1)
        { /* block id: 83 */
            uint16_t l_167 = 0x34E3;
            int32_t l_183 = 1;
            int32_t l_210 = (-6);
            g_106.f2 = ((int16_t)((int32_t)((int32_t)((uint16_t)p_95 % (uint16_t)__builtin_bswap64(l_124)) % (int32_t)(0x4159 || (-1))) - (int32_t)(l_124 >= ((l_167 != (2 != (((uint32_t)((uint32_t)l_172 + (uint32_t)g_106.f6) % (uint32_t)g_5) && 1))) == l_167))) + (int16_t)g_5);
            for (g_106.f4 = (-19); (g_106.f4 > 2); g_106.f4 += 6)
            { /* block id: 87 */
                uint32_t l_187 = 5U;
                int32_t l_196 = 0x292E0113;
                struct S0 l_198 = {0x3DA0};
                if (g_106.f5)
                { /* block id: 88 */
                    struct S1 l_175 = {23494,2,-938,0xEEF0ED02,1U,80,82};
                    uint32_t l_184 = 2U;
                    l_175 = l_175;
                    if (((int16_t)l_167 << (int16_t)func_85((-(uint16_t)((int32_t)((int16_t)l_183 << (int16_t)11) % (int32_t)0x786ADAD8)))))
                    { /* block id: 90 */
                        l_124 = ((l_175.f5 < 1) ^ (p_95 & func_85(l_184)));
                        l_175.f2 = ((uint16_t)(l_183 <= l_187) << (uint16_t)8);
                    }
                    else
                    { /* block id: 93 */
                        l_196 = (p_97 || (((int16_t)__builtin_ffsl(func_85(((0xE3FE ^ ((((p_96 >= g_106.f3) && ((uint16_t)8U + (uint16_t)(-6))) <= p_96) ^ ((int32_t)(((int32_t)g_106.f0 - (int32_t)g_90.f0) >= g_106.f6) - (int32_t)g_106.f5))) || g_5))) - (int16_t)0x39AD) < l_175.f6));
                        l_198 = l_197;
                        if (l_172)
                            break;
                    }
                    g_106.f2 = ((uint32_t)((int16_t)((g_89 | g_106.f5) != 0U) + (int16_t)((p_97 != g_106.f4) & l_175.f2)) % (uint32_t)p_95);
                }
                else
                { /* block id: 99 */
                    uint32_t l_217 = 0xED70B56F;
                    l_124 = (l_167 ^ p_95);
                    l_198 = g_90;
                    for (p_95 = 0; (p_95 != 9); p_95 += 9)
                    { /* block id: 104 */
                        int16_t l_222 = 0x446F;
                        l_124 = ((~__builtin_parityl(p_97)) == (p_96 & 0xCCC0));
                        if (g_106.f6)
                            break;
                        l_210 = ((uint16_t)p_96 << (uint16_t)4);
                        l_196 = ((uint16_t)1U - (uint16_t)(((65535U == (p_97 <= ((uint32_t)((((l_217 >= g_106.f0) ^ ((int16_t)(!(-(uint16_t)p_97)) >> (int16_t)11)) || (l_222 > __builtin_popcount(g_106.f0))) & 65535U) % (uint32_t)1U))) | 4294967292U) | g_5));
                    }
                }
            }
            l_197 = g_90;
        }
    }
    else
    { /* block id: 114 */
        uint16_t l_227 = 0xDB4F;
        struct S0 l_236 = {0x1FCD};
        l_233 = ((((uint16_t)((((int16_t)(4294967295U != (g_106.f6 & ((((l_227 ^ ((uint16_t)(func_85((g_106.f5 || l_115)) & g_89) << (uint16_t)g_106.f2)) | ((int16_t)(g_106.f6 ^ p_95) % (int16_t)p_96)) && l_227) == 4294967292U))) + (int16_t)l_232) || 0x6C6404DC) ^ p_97) << (uint16_t)10) && 1U) >= 0x32BB3065);
        for (p_95 = 0; (p_95 == 58); p_95 += 1)
        { /* block id: 118 */
            if (p_97)
                break;
            l_237 = l_236;
        }
        for (l_233 = (-5); (l_233 >= 22); l_233 += 1)
        { /* block id: 124 */
            uint16_t l_255 = 65530U;
            g_106.f2 = ((uint16_t)(g_106.f5 && g_89) + (uint16_t)((0 > ((int32_t)((int16_t)g_106.f4 + (int16_t)0) - (int32_t)__builtin_popcount(((int32_t)(p_96 & ((int16_t)(((int32_t)l_252 + (int32_t)((int16_t)g_106.f6 - (int16_t)p_96)) != g_89) >> (int16_t)l_227)) + (int32_t)l_255)))) | 0x49F534F0));
        }
    }
    if (((g_106.f3 <= (l_232 & l_256)) | l_142))
    { /* block id: 128 */
        struct S1 l_259 = {11337,2,708,1,65532U,241,91};
        l_115 = ((uint32_t)p_95 + (uint32_t)__builtin_ffsl(func_98(l_259, ((0U | ((4U || ((((int16_t)(((p_96 >= 0xA422) != 0U) & (l_259.f6 > ((((g_106.f6 || g_106.f6) > p_96) != 0) != g_5))) << (int16_t)13) & p_97) && l_259.f1)) || 0x7BFA6EBB)) || p_95), p_96, p_96, l_259.f0)));
        l_237 = func_81((0x844AFDE6 >= g_106.f6), l_259.f1);
        for (l_142 = 0; (l_142 < 16); l_142 += 1)
        { /* block id: 133 */
            uint32_t l_274 = 4294967295U;
            g_269 = ((uint32_t)((int16_t)(-(int16_t)p_96) >> (int16_t)2) % (uint32_t)__builtin_ctz(g_106.f1));
            l_259.f2 = __builtin_clz((((int32_t)((uint16_t)2U << (uint16_t)p_96) - (int32_t)(l_274 | (((((((uint16_t)(func_85(g_106.f0) | (g_106.f2 & l_233)) >> (uint16_t)(__builtin_parity(l_259.f1) && 0)) & l_259.f2) > l_252) < p_96) == g_106.f1) != 0xA5AF4F0E))) < 0));
        }
    }
    else
    { /* block id: 137 */
        uint32_t l_282 = 0U;
        g_90 = func_81(p_97, __builtin_parity(((l_277 & ((uint32_t)((uint16_t)(1 > l_282) >> (uint16_t)2) % (uint32_t)(g_106.f3 || g_269))) <= ((!((int32_t)(-(int16_t)((uint16_t)g_106.f5 % (uint16_t)(~(0x8092 >= (~(g_106.f2 ^ g_269)))))) + (int32_t)0x08B88E97)) == 0x4013))));
        g_106.f2 = l_282;
        return g_90.f0;
    }
    g_106 = l_291;
    return g_106.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_106
 */
static uint32_t  func_98(struct S1  p_99, uint32_t  p_100, int32_t  p_101, uint32_t  p_102, uint32_t  p_103)
{ /* block id: 57 */
    struct S1 l_105 = {44248,0,593,0xEAC2F6E5,0x19C3,85,126};
    p_99 = l_105;
    g_106 = l_105;
    l_105.f2 = 0x87676DC0;
    p_99.f2 = l_105.f0;
    return l_105.f4;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_89, "g_89", print_hash_value);
    transparent_crc(g_90.f0, "g_90.f0", print_hash_value);
    transparent_crc(g_106.f0, "g_106.f0", print_hash_value);
    transparent_crc(g_106.f1, "g_106.f1", print_hash_value);
    transparent_crc(g_106.f2, "g_106.f2", print_hash_value);
    transparent_crc(g_106.f3, "g_106.f3", print_hash_value);
    transparent_crc(g_106.f4, "g_106.f4", print_hash_value);
    transparent_crc(g_106.f5, "g_106.f5", print_hash_value);
    transparent_crc(g_106.f6, "g_106.f6", print_hash_value);
    transparent_crc(g_269, "g_269", print_hash_value);
    transparent_crc(g_292.f0, "g_292.f0", print_hash_value);
    transparent_crc(g_309.f0, "g_309.f0", print_hash_value);
    transparent_crc(g_309.f1, "g_309.f1", print_hash_value);
    transparent_crc(g_309.f2, "g_309.f2", print_hash_value);
    transparent_crc(g_309.f3, "g_309.f3", print_hash_value);
    transparent_crc(g_309.f4, "g_309.f4", print_hash_value);
    transparent_crc(g_309.f5, "g_309.f5", print_hash_value);
    transparent_crc(g_309.f6, "g_309.f6", print_hash_value);
    transparent_crc(g_430, "g_430", print_hash_value);
    transparent_crc(g_481, "g_481", print_hash_value);
    transparent_crc(g_569, "g_569", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 99
   depth: 1, occurrence: 38
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 18
breakdown:
   indirect level: 0, occurrence: 18
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 12
XXX times a bitfields struct on RHS: 21
XXX times a single bitfield on LHS: 21
XXX times a single bitfield on RHS: 104

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 165
   depth: 2, occurrence: 30
   depth: 3, occurrence: 7
   depth: 4, occurrence: 7
   depth: 5, occurrence: 6
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 2
   depth: 12, occurrence: 2
   depth: 14, occurrence: 6
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 2
   depth: 19, occurrence: 4
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 4
   depth: 24, occurrence: 2
   depth: 27, occurrence: 2
   depth: 32, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 597
XXX times a non-volatile is write: 114
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 161
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 32
   depth: 2, occurrence: 20
   depth: 3, occurrence: 23
   depth: 4, occurrence: 24
   depth: 5, occurrence: 30

XXX percentage a fresh-made variable is used: 20.4
XXX percentage an existing variable is used: 79.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

