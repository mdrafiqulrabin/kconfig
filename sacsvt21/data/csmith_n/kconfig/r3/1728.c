/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      314654684
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static int32_t * func_2(int32_t * p_3, int16_t  p_4, int32_t * p_5);
inline static int8_t  func_14(uint32_t  p_15);
static int32_t * func_18(int8_t  p_19, int32_t * p_20, int32_t  p_21);
inline static int8_t  func_22(int8_t  p_23);
static uint32_t  func_24(int32_t  p_25, int32_t * p_26, uint32_t  p_27, int32_t * const  p_28, int16_t  p_29);
static int32_t  func_36(int32_t * p_37, int32_t * p_38, int32_t  p_39, int32_t  p_40);
inline static int32_t * func_41(uint32_t  p_42);
static uint32_t  func_43(const int32_t  p_44, int32_t  p_45, int32_t * p_46);
static uint8_t  func_50(int32_t  p_51, int32_t * p_52, const uint8_t  p_53, int32_t * const  p_54);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_7 = (-6);
    int32_t *l_6 = &l_7;
    const int32_t *l_355 = &l_7;
    const int32_t **l_354 = &l_355;
    int32_t l_356 = 0x56BAF7A5;
    (*l_354) = func_2(l_6, (0x0AA39ED0 ^ ((safe_sub_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_u(((safe_div_func_int8_t_s_s(func_14((((void*)0 == &l_7) || (*l_6))), (safe_rshift_func_uint8_t_u_s((*l_6), (((*l_6) == (*l_6)) < (*l_6)))))) || (*l_6)), 4)), (*l_6))) && 0x7DF5)), &l_7);
    return l_356;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(int32_t * p_3, int16_t  p_4, int32_t * p_5)
{ /* block id: 195 */
    int32_t l_353 = (-8);
    int32_t *l_352 = &l_353;
    (*p_5) = (*p_5);
    return p_3;
    /* statement id: 197 */
    //assert (func_2_rv == &l_7);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_14(uint32_t  p_15)
{ /* block id: 1 */
    int32_t l_204 = 0x4413540F;
    int32_t *l_203 = &l_204;
    const int32_t ***l_330 = (void*)0;
    const int32_t ****l_329 = &l_330;
    const int32_t *****l_328 = &l_329;
    const uint8_t l_346 = 5U;
    int32_t *l_349 = &l_204;
lbl_314:
    for (p_15 = 11; (p_15 != 39); p_15 = safe_add_func_uint32_t_u_u(p_15, 1))
    { /* block id: 4 */
        uint16_t l_30 = 0xF903;
        int32_t l_32 = (-9);
        int32_t *l_31 = &l_32;
        int32_t **l_309 = &l_203;
        (*l_309) = func_18(func_22((p_15 < func_24(l_30, l_31, (safe_lshift_func_int16_t_s_s(1, 15)), &l_32, p_15))), l_203, p_15);
        (**l_309) = p_15;
        (*l_309) = func_18((&l_204 != &l_204), (*l_309), p_15);
    }
    for (l_204 = 0; (l_204 < (-15)); l_204 = safe_sub_func_int8_t_s_s(l_204, 1))
    { /* block id: 176 */
        uint32_t l_325 = 4294967294U;
        int32_t *l_336 = &l_204;
        int32_t l_342 = 1;
        int32_t *l_341 = &l_342;
        for (p_15 = 26; (p_15 <= 29); ++p_15)
        { /* block id: 179 */
            int32_t *** const **l_331 = (void*)0;
            int32_t l_333 = 0xD223423A;
            int32_t *l_332 = &l_333;
            if (p_15)
                goto lbl_314;
            (*l_332) = (((((4294967295U < (*l_203)) == ((5U <= ((safe_mod_func_uint16_t_u_u((((safe_lshift_func_uint8_t_u_s(((safe_div_func_int16_t_s_s((~(safe_rshift_func_uint16_t_u_u(((~(0x62A095AA <= (*l_203))) != l_325), 13))), 0x7076)) >= (safe_lshift_func_int8_t_s_u(((l_328 != l_331) != p_15), 4))), 6)) || 8U) && 1U), 4)) >= p_15)) | p_15)) || p_15) && p_15) < 0x62);
            (*l_332) = p_15;
            for (l_325 = 0; (l_325 >= 20); l_325 = safe_add_func_uint32_t_u_u(l_325, 1))
            { /* block id: 185 */
                int32_t **l_337 = (void*)0;
                int32_t **l_338 = &l_203;
                (*l_338) = l_336;
                (*l_338) = l_336;
                (*l_332) = p_15;
            }
        }
        (*l_341) = ((l_336 == l_336) || (safe_sub_func_int32_t_s_s(0x86143A58, (*l_336))));
    }
    (*l_203) = ((0xF9 > ((safe_unary_minus_func_uint16_t_u((safe_rshift_func_uint8_t_u_u(l_346, (safe_div_func_int16_t_s_s(((p_15 | (((0xCAC96838 && ((l_349 == (void*)0) ^ ((void*)0 == &l_204))) && p_15) ^ p_15)) != p_15), 0xCAB4)))))) ^ 65535U)) | 0xD389);
    return p_15;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_18(int8_t  p_19, int32_t * p_20, int32_t  p_21)
{ /* block id: 113 */
    int32_t l_208 = 0xABB6E3EA;
    int32_t *l_207 = &l_208;
    int32_t **l_206 = &l_207;
    int32_t ***l_205 = &l_206;
    int32_t *** const *l_211 = &l_205;
    int32_t *** const **l_210 = &l_211;
    uint32_t l_234 = 0xF55A1BD8;
    const uint8_t l_290 = 4U;
    if ((*p_20))
    { /* block id: 114 */
        int32_t ***l_209 = &l_206;
        const int32_t **l_233 = (void*)0;
        const int32_t ***l_232 = &l_233;
        const int32_t *** const *l_231 = &l_232;
        const int32_t *** const **l_230 = &l_231;
        int8_t l_235 = 1;
        const int32_t l_298 = 0xBD755E53;
        if ((p_19 ^ ((l_205 != l_209) >= ((void*)0 == l_210))))
        { /* block id: 115 */
            int8_t l_212 = 0x0B;
            (***l_205) = (0x358C7ECC | (l_212 & (*p_20)));
        }
        else
        { /* block id: 117 */
            int32_t ****l_251 = &l_209;
            int32_t *****l_250 = &l_251;
            int32_t l_297 = 0x80C0C3E4;
            int32_t *l_306 = &l_208;
            (**l_205) = (**l_209);
            for (l_208 = 24; (l_208 < 22); l_208--)
            { /* block id: 121 */
                int16_t l_215 = 0x623E;
                int32_t ****l_227 = &l_205;
            }
            (**l_209) = p_20;
            /* statement id: 144 */
            //assert (l_207 == &l_204);
            for (l_235 = 0; (l_235 <= (-9)); l_235 = safe_sub_func_uint16_t_u_u(l_235, 3))
            { /* block id: 147 */
            }
        }
        /* facts after branching */
        //assert (l_207 == &l_204 || l_207 == &l_208);
        (**l_209) = p_20;
        /* statement id: 164 */
        //assert (l_207 == &l_204);
        (***l_211) = (**l_205);
    }
    else
    { /* block id: 166 */
        (*l_207) = 0x935BA4CF;
    }
    /* facts after branching */
    //assert (l_207 == &l_208 || l_207 == &l_204);
    return p_20;
    /* statement id: 169 */
    //assert (func_18_rv == &l_204);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_22(int8_t  p_23)
{ /* block id: 111 */
    int32_t l_202 = 0x37DEE9CF;
    return l_202;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_24(int32_t  p_25, int32_t * p_26, uint32_t  p_27, int32_t * const  p_28, int16_t  p_29)
{ /* block id: 5 */
    uint32_t l_35 = 1U;
    int32_t l_49 = (-1);
    (*p_28) = l_35;
    (*p_28) = func_36(func_41(func_43((((safe_mod_func_int32_t_s_s(l_49, 0x5243B9C3)) > p_29) | func_50((safe_lshift_func_int16_t_s_u(0x4898, l_35)), p_26, l_49, p_28)), l_35, p_26)), p_26, l_35, l_35);
    for (p_29 = 0; (p_29 != (-11)); p_29 = safe_sub_func_uint16_t_u_u(p_29, 1))
    { /* block id: 104 */
        if ((*p_26))
            break;
        if (l_49)
            break;
        return l_49;
    }
    (*p_28) = (safe_rshift_func_uint16_t_u_s((safe_lshift_func_int8_t_s_s((safe_add_func_int16_t_s_s(l_35, (safe_rshift_func_uint8_t_u_u(3U, 1)))), 0)), p_27));
    return l_49;
}


/* ------------------------------------------ */
/* 
 * reads : l_32
 * writes: l_32
 */
static int32_t  func_36(int32_t * p_37, int32_t * p_38, int32_t  p_39, int32_t  p_40)
{ /* block id: 19 */
    uint16_t l_76 = 0x6C34;
    int32_t l_83 = 0x2DA72DF2;
    int32_t *l_82 = &l_83;
    int32_t **l_81 = &l_82;
    int32_t ***l_80 = &l_81;
    int32_t ****l_79 = &l_80;
    int32_t *****l_78 = &l_79;
    int16_t l_136 = 1;
    if (((l_76 == (safe_unary_minus_func_int16_t_s(l_76))) < ((void*)0 != l_78)))
    { /* block id: 20 */
        int32_t * const *l_103 = &l_82;
        int32_t * const **l_102 = &l_103;
        int32_t * const ***l_101 = &l_102;
        int32_t * const ****l_100 = &l_101;
        uint32_t l_123 = 1U;
        for (p_39 = 3; (p_39 > 29); p_39 = safe_add_func_uint16_t_u_u(p_39, 5))
        { /* block id: 23 */
            uint8_t l_104 = 1U;
            int32_t *l_126 = &l_83;
            int32_t ****l_144 = &l_80;
        }
    }
    else
    { /* block id: 72 */
        uint8_t l_156 = 0x5F;
        (****l_79) = (*p_38);
        for (l_76 = 0; (l_76 > 34); ++l_76)
        { /* block id: 76 */
            int8_t l_151 = 0x02;
            int32_t * const *l_179 = &l_82;
            int32_t * const **l_178 = &l_179;
            int32_t * const ***l_177 = &l_178;
            (*l_82) = (p_40 > ((((***l_80) >= (safe_lshift_func_int8_t_s_u(p_40, l_151))) != (***l_80)) > ((safe_rshift_func_uint8_t_u_u((safe_lshift_func_int16_t_s_u(l_156, ((((((safe_div_func_uint16_t_u_u((safe_rshift_func_uint8_t_u_s((safe_rshift_func_int16_t_s_u((&l_79 != (void*)0), (safe_div_func_int8_t_s_s((((safe_mod_func_int16_t_s_s(0xE10E, (*l_82))) & p_40) > 0xBE), p_39)))), p_40)), l_151)) < 0U) >= p_39) >= (**l_81)) && (***l_80)) <= 0x1B))), p_39)) || 0xF8)));
            for (l_83 = 0; (l_83 <= (-7)); l_83 = safe_sub_func_int32_t_s_s(l_83, 6))
            { /* block id: 80 */
                (**l_80) = p_38;
                /* statement id: 81 */
                //assert (l_82 == &l_32);
            }
            if (((***l_80) & (safe_div_func_uint16_t_u_u((safe_add_func_int8_t_s_s((safe_div_func_int8_t_s_s((((safe_lshift_func_uint8_t_u_u(253U, ((void*)0 != l_177))) < (****l_177)) && (safe_add_func_int16_t_s_s((((((safe_lshift_func_uint16_t_u_u(p_40, (((safe_add_func_int8_t_s_s((**l_179), ((*l_78) == (*l_78)))) || p_39) ^ 9))) || 1) || 0x1C9F68FA) >= p_39) >= l_156), p_40))), p_40)), p_40)), 0x7B95))))
            { /* block id: 83 */
                for (l_136 = (-21); (l_136 == 18); l_136 = safe_add_func_int32_t_s_s(l_136, 7))
                { /* block id: 86 */
                    return (*p_38);
                }
            }
            else
            { /* block id: 89 */
                (****l_177) = (safe_lshift_func_int16_t_s_s((1U <= p_39), 6));
                (*l_177) = (void*)0;
                /* statement id: 91 */
                assert (l_178 == 0);
                for (l_136 = 2; (l_136 > 7); ++l_136)
                { /* block id: 94 */
                    (****l_78) = p_38;
                    /* statement id: 95 */
                    //assert (l_82 == &l_32);
                }
            }
            /* facts after branching */
            assert (l_178 == 0 || l_178 == &l_179);
        }
        /* facts after for loop */
        //assert (l_82 == &l_32 || l_82 == &l_83);
    }
    /* facts after branching */
    //assert (l_82 == &l_32 || l_82 == &l_83);
    return (*p_38);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_41(uint32_t  p_42)
{ /* block id: 14 */
    int32_t l_69 = 0xFE54384F;
    int32_t *l_68 = &l_69;
    int32_t **l_73 = &l_68;
    int32_t ***l_72 = &l_73;
    int32_t ****l_71 = &l_72;
    int32_t *****l_70 = &l_71;
    int32_t *l_74 = &l_69;
    int32_t *l_75 = (void*)0;
    (*l_68) = (safe_sub_func_int8_t_s_s((l_68 == &l_69), (0xAE264689 || p_42)));
    (*l_68) = p_42;
    (*l_70) = (void*)0;
    /* statement id: 17 */
    assert (l_71 == 0);
    return l_75;
    /* statement id: 18 */
    //assert (func_41_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_43(const int32_t  p_44, int32_t  p_45, int32_t * p_46)
{ /* block id: 12 */
    int16_t l_65 = 0;
    return l_65;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_50(int32_t  p_51, int32_t * p_52, const uint8_t  p_53, int32_t * const  p_54)
{ /* block id: 7 */
    int32_t l_59 = 0;
    const int32_t *l_58 = &l_59;
    const int32_t **l_57 = &l_58;
    const int32_t * const *l_61 = &l_58;
    const int32_t * const **l_60 = &l_61;
    int32_t **l_62 = (void*)0;
    int32_t *l_64 = &l_59;
    int32_t **l_63 = &l_64;
    (*l_57) = (void*)0;
    /* statement id: 8 */
    assert (l_58 == 0);
    (*l_60) = &l_58;
    (*l_63) = (**l_60);
    /* statement id: 10 */
    assert (l_64 == 0);
    return p_51;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 59
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 22
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 5, occurrence: 3
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1

XXX total number of pointers: 79

XXX times a variable address is taken: 73
XXX times a pointer is dereferenced on RHS: 79
breakdown:
   depth: 1, occurrence: 46
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5
   depth: 4, occurrence: 11
   depth: 5, occurrence: 8
XXX times a pointer is dereferenced on LHS: 57
breakdown:
   depth: 1, occurrence: 32
   depth: 2, occurrence: 9
   depth: 3, occurrence: 3
   depth: 4, occurrence: 10
   depth: 5, occurrence: 3
XXX times a pointer is compared with null: 15
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 269

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 97
   level: 2, occurrence: 30
   level: 3, occurrence: 22
   level: 4, occurrence: 43
   level: 5, occurrence: 21
XXX number of pointers point to pointers: 46
XXX number of pointers point to scalars: 33
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 20.3
XXX average alias set size: 1.11

XXX times a non-volatile is read: 471
XXX times a non-volatile is write: 194
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 64
XXX max block depth: 4
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 15
   depth: 2, occurrence: 12
   depth: 3, occurrence: 8
   depth: 4, occurrence: 2

XXX percentage a fresh-made variable is used: 16.4
XXX percentage an existing variable is used: 83.6
********************* end of statistics **********************/

