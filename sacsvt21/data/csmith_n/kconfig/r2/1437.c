/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --uint8 --no-float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      432981376
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   int32_t  f1;
   int32_t  f2;
   int32_t  f3;
   int32_t  f4;
   int8_t  f5;
   int32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int32_t g_6 = 0x04445559;
static int32_t g_10 = (-1);
static int32_t *g_48 = &g_6;
static int32_t **g_47 = &g_48;
static struct S0 g_53[6][6] = {{{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{0xD942A26B,0x3122E3BD,0x5BDF5444,0xE3780627,0,0xBD,-10},{0x7E942FAF,0xCEB2CFB1,0x589A4582,0x0B545435,0x7D231D57,-1,-1},{0x7E942FAF,0xCEB2CFB1,0x589A4582,0x0B545435,0x7D231D57,-1,-1},{0xD942A26B,0x3122E3BD,0x5BDF5444,0xE3780627,0,0xBD,-10},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52}},{{0x686A8E7E,0x4BFCE934,0xA64A0F0C,0xED6D2303,0,1,0x236C2177},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{0x7E942FAF,0xCEB2CFB1,0x589A4582,0x0B545435,0x7D231D57,-1,-1},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{0x686A8E7E,0x4BFCE934,0xA64A0F0C,0xED6D2303,0,1,0x236C2177},{0x686A8E7E,0x4BFCE934,0xA64A0F0C,0xED6D2303,0,1,0x236C2177}},{{1,0x2AA0BDEC,0xE1EFC39F,9,1,-5,1},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{1,0x2AA0BDEC,0xE1EFC39F,9,1,-5,1},{0xD942A26B,0x3122E3BD,0x5BDF5444,0xE3780627,0,0xBD,-10},{1,0x2AA0BDEC,0xE1EFC39F,9,1,-5,1}},{{1,0x2AA0BDEC,0xE1EFC39F,9,1,-5,1},{0xD942A26B,0x3122E3BD,0x5BDF5444,0xE3780627,0,0xBD,-10},{1,0x2AA0BDEC,0xE1EFC39F,9,1,-5,1},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{1,0x2AA0BDEC,0xE1EFC39F,9,1,-5,1}},{{0x686A8E7E,0x4BFCE934,0xA64A0F0C,0xED6D2303,0,1,0x236C2177},{0x686A8E7E,0x4BFCE934,0xA64A0F0C,0xED6D2303,0,1,0x236C2177},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{0x7E942FAF,0xCEB2CFB1,0x589A4582,0x0B545435,0x7D231D57,-1,-1},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{0x686A8E7E,0x4BFCE934,0xA64A0F0C,0xED6D2303,0,1,0x236C2177}},{{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52},{0xD942A26B,0x3122E3BD,0x5BDF5444,0xE3780627,0,0xBD,-10},{0x7E942FAF,0xCEB2CFB1,0x589A4582,0x0B545435,0x7D231D57,-1,-1},{0x7E942FAF,0xCEB2CFB1,0x589A4582,0x0B545435,0x7D231D57,-1,-1},{0xD942A26B,0x3122E3BD,0x5BDF5444,0xE3780627,0,0xBD,-10},{1,0xF2059515,-1,0x1E7FF518,0x5A1EC8F9,-1,0x50187E52}}};
static const int32_t g_102 = 0x5F53E4EB;
static struct S0 g_113 = {1,-9,0x82652714,0x024A44AA,0,0xBB,0};
static struct S0 *g_121 = &g_113;
static struct S0 **g_120[5][5][5] = {{{&g_121,&g_121,(void*)0,&g_121,&g_121},{&g_121,(void*)0,&g_121,&g_121,&g_121},{&g_121,&g_121,(void*)0,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121}},{{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,(void*)0,&g_121,&g_121,&g_121}},{{&g_121,(void*)0,(void*)0,&g_121,&g_121},{&g_121,(void*)0,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121}},{{&g_121,&g_121,(void*)0,&g_121,&g_121},{&g_121,(void*)0,(void*)0,&g_121,&g_121},{&g_121,&g_121,(void*)0,&g_121,(void*)0},{&g_121,&g_121,&g_121,&g_121,(void*)0},{&g_121,&g_121,&g_121,&g_121,&g_121}},{{&g_121,&g_121,&g_121,&g_121,(void*)0},{&g_121,&g_121,&g_121,&g_121,(void*)0},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,&g_121,&g_121,&g_121,&g_121},{&g_121,(void*)0,&g_121,&g_121,&g_121}}};
static int32_t *g_136 = &g_113.f4;
static struct S0 ***g_179 = &g_120[3][4][2];
static struct S0 **** const g_178 = &g_179;
static int32_t g_352 = (-1);
static int32_t ***g_402 = &g_47;
static int32_t ****g_401 = &g_402;
static int32_t *****g_400 = &g_401;
static int32_t *g_411 = &g_53[4][2].f3;
static const int32_t **** const *g_448 = (void*)0;
static struct S0 **** const g_450[2] = {&g_179,&g_179};
static struct S0 **** const *g_449 = &g_450[0];
static const int32_t *g_507 = &g_53[4][2].f2;
static int32_t **g_558 = &g_411;
static int32_t g_620 = 0xC7625BE9;
static int32_t g_713 = 0;
static int32_t g_731 = 0;
static uint8_t g_760[4][1] = {{0xD2},{0xD2},{0xD2},{0xD2}};


/* --- FORWARD DECLARATIONS --- */
static uint8_t  func_1(void);
inline static struct S0  func_13(const uint32_t  p_14, uint16_t  p_15, const int16_t  p_16, int32_t ** p_17);
static int8_t  func_18(uint8_t  p_19, int32_t ** p_20, const uint16_t  p_21, int32_t  p_22);
static int32_t ** func_23(int32_t * p_24);
static int32_t * func_26(const int32_t * p_27, uint32_t  p_28, uint16_t  p_29, const int32_t  p_30, int8_t  p_31);
inline static int32_t * func_32(int32_t ** p_33, int8_t  p_34, uint32_t  p_35);
static int32_t ** func_36(int32_t * p_37, int8_t  p_38, int32_t  p_39, int32_t * p_40);
inline static int32_t  func_42(int32_t ** p_43, uint32_t  p_44, uint32_t  p_45, uint16_t  p_46);
inline static int16_t  func_61(int16_t  p_62, uint32_t  p_63);
inline static int8_t  func_66(uint16_t  p_67);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_47 g_10 g_53 g_48 g_102 g_113 g_120 g_121 g_178 g_179 g_136 g_402 g_620 g_507 g_401 g_400 g_352 g_558 g_411 g_760 g_713
 * writes: g_6 g_10 g_53 g_113 g_136 g_48 g_507 g_411
 */
static uint8_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_4[6] = {0x77AB,0x77AB,0x77AB,0x77AB,0x77AB,0x77AB};
    int32_t *l_5 = &g_6;
    int32_t *l_11 = &g_10;
    int32_t *l_25[10] = {&g_6,&g_10,&g_6,&g_10,&g_6,&g_10,&g_6,&g_10,&g_6,&g_10};
    const int8_t l_752 = 0;
    const int32_t l_759 = (-9);
    uint8_t l_770 = 255U;
    int i;
    (*l_5) = (safe_lshift_func_uint8_t_u_u(l_4[5], 2));
    for (g_6 = 1; (g_6 <= 5); g_6 += 1)
    { /* block id: 4 */
        const int32_t *l_7 = (void*)0;
        int32_t *l_8 = (void*)0;
        int32_t *l_9 = &g_10;
        int32_t **l_12 = &l_8;
        int i;
        (*l_9) = (l_7 != l_5);
        if (l_4[g_6])
            continue;
        (*l_12) = l_11;
        /* statement id: 7 */
        assert (l_8 == &g_10);
    }
    (*g_121) = func_13((func_18(g_6, func_23(l_25[0]), l_752, (0xE9 ^ ((safe_lshift_func_int8_t_s_s((((safe_sub_func_uint8_t_u_u(((((safe_lshift_func_int16_t_s_u(g_6, 3)) >= g_6) & (g_102 < ((l_759 > 3U) < g_760[2][0]))) < 0xED), 0xA5)) & 255U) > g_352), g_102)) <= g_620))) && g_53[4][2].f6), g_352, g_620, &l_25[0]);
    /* statement id: 656 */
    assert (g_48 == &g_6 || g_48 == 0);
    assert (g_136 == &g_113.f4 || g_136 == &g_6);
    assert ((g_411 >= &g_53[0][0].f6 && g_411 <= &g_53[5][5].f6) || g_411 == &g_6 || g_411 == 0);
    assert (g_507 == &g_113.f4 || g_507 == &g_6 || (g_507 >= &g_53[0][0].f2 && g_507 <= &g_53[5][5].f2));
    (*g_136) = ((safe_sub_func_uint16_t_u_u(g_713, (safe_rshift_func_uint8_t_u_u(g_10, (((safe_add_func_int16_t_s_s(g_6, (safe_rshift_func_uint8_t_u_s(2U, 0)))) >= 0x72) > l_770))))) <= 0xDD);
    return g_760[1][0];
}


/* ------------------------------------------ */
/* 
 * reads : g_121
 * writes: g_113
 */
inline static struct S0  func_13(const uint32_t  p_14, uint16_t  p_15, const int16_t  p_16, int32_t ** p_17)
{ /* block id: 653 */
    struct S0 l_761 = {2,0x5FB45214,-7,0x825B60F9,-1,0,0};
    (*g_121) = l_761;
    return l_761;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_18(uint8_t  p_19, int32_t ** p_20, const uint16_t  p_21, int32_t  p_22)
{ /* block id: 651 */
    return p_19;
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_6 g_10 g_53 g_48 g_102 g_113 g_120 g_121 g_178 g_179 g_136 g_402 g_620 g_507 g_401 g_400 g_352 g_558 g_411
 * writes: g_53 g_10 g_113 g_136 g_48 g_507 g_411
 */
static int32_t ** func_23(int32_t * p_24)
{ /* block id: 9 */
    uint8_t l_41[2];
    int32_t *l_194 = &g_6;
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_41[i] = 3U;
    (*g_558) = func_26(func_32(func_36(&g_10, l_41[0], func_42(g_47, (l_41[0] && l_41[0]), g_6, (safe_mod_func_uint8_t_u_u((l_41[0] | (safe_lshift_func_uint16_t_u_u(((-6) <= g_10), l_41[0]))), g_6))), l_194), (*l_194), (*l_194)), (*l_194), (*l_194), g_102, g_620);
    /* statement id: 649 */
    assert (g_48 == &g_6 || g_48 == 0);
    assert (g_136 == &g_113.f4 || g_136 == &g_6);
    assert ((g_411 >= &g_53[0][0].f6 && g_411 <= &g_53[5][5].f6) || g_411 == &g_6 || g_411 == 0);
    assert (g_507 == &g_113.f4 || g_507 == &g_6 || (g_507 >= &g_53[0][0].f2 && g_507 <= &g_53[5][5].f2));
    return (**g_401);
    /* statement id: 650 */
    //assert (func_23_rv == &g_48);
}


/* ------------------------------------------ */
/* 
 * reads : g_507 g_53.f2 g_113.f6 g_121 g_401 g_402 g_47 g_48 g_113.f0 g_53.f1 g_6 g_400 g_113.f2 g_352 g_558 g_411
 * writes: g_113 g_507 g_48 g_53.f3
 */
static int32_t * func_26(const int32_t * p_27, uint32_t  p_28, uint16_t  p_29, const int32_t  p_30, int8_t  p_31)
{ /* block id: 500 */
    int8_t l_627 = (-2);
    int32_t *l_630 = &g_113.f6;
    struct S0 l_631 = {0x4C047F88,0x5DE6F3CA,0x96A97C7D,0x0910284D,8,1,-6};
    int32_t l_656 = 0;
    int32_t *l_726 = (void*)0;
    struct S0 l_734[4] = {{0xC14B551A,0xFED57C63,-9,0x5A3D0C8A,-2,1,0x2361D774},{0xC14B551A,0xFED57C63,-9,0x5A3D0C8A,-2,1,0x2361D774},{0xC14B551A,0xFED57C63,-9,0x5A3D0C8A,-2,1,0x2361D774},{0xC14B551A,0xFED57C63,-9,0x5A3D0C8A,-2,1,0x2361D774}};
    int i;
    if (((!((safe_sub_func_uint32_t_u_u((0x21 ^ 1), ((safe_unary_minus_func_uint32_t_u(((l_627 > (safe_mod_func_int32_t_s_s((l_627 | 1U), (*g_507)))) ^ l_627))) || ((l_630 != p_27) & 0)))) && (*l_630))) & 0x0AE9E6F6))
    { /* block id: 501 */
        (*g_121) = l_631;
    }
    else
    { /* block id: 503 */
        int32_t **l_632[5][7] = {{&l_630,&l_630,&g_136,&l_630,&l_630,&g_411,&g_136},{&l_630,&l_630,&g_411,&g_411,&g_411,&g_411,&l_630},{&g_411,(void*)0,&l_630,&g_48,&l_630,&g_48,&l_630},{&g_411,&g_136,&g_48,&l_630,&g_48,&g_136,&g_411},{&l_630,&g_48,&l_630,&g_48,&l_630,(void*)0,&g_411}};
        uint32_t l_637 = 3U;
        const int32_t **l_638 = &g_507;
        int i, j;
        (*l_638) = p_27;
        /* statement id: 504 */
        assert (g_507 == &g_113.f4 || g_507 == &g_6);
        (***g_401) = (***g_401);
        if ((safe_sub_func_uint32_t_u_u((g_53[4][2].f2 == ((((!p_28) == 5U) ^ (safe_lshift_func_uint8_t_u_s(((&g_178 != &g_178) & ((((((p_30 == g_113.f0) || ((((***g_401) == (void*)0) < (*l_630)) || p_28)) | g_53[4][2].f1) != 0x14) & p_30) != 0)), p_28))) && (****g_401))), 0x14E1C3AD)))
        { /* block id: 506 */
            (****g_400) = (void*)0;
            /* statement id: 507 */
            assert (g_48 == 0);
        }
        else
        { /* block id: 508 */
            int32_t *l_650 = &g_53[4][2].f6;
            for (g_113.f0 = 0; (g_113.f0 <= 5); g_113.f0 = safe_add_func_uint16_t_u_u(g_113.f0, 1))
            { /* block id: 511 */
                for (g_113.f2 = 0; (g_113.f2 <= 1); g_113.f2 = safe_add_func_uint8_t_u_u(g_113.f2, 1))
                { /* block id: 514 */
                    for (l_637 = 0; (l_637 <= 16); l_637 = safe_add_func_int8_t_s_s(l_637, 3))
                    { /* block id: 517 */
                        (**g_558) = (g_352 ^ (p_31 | 65535U));
                        (**g_402) = (***g_401);
                        return l_650;
                        /* statement id: 520 */
                        //assert ((func_26_rv >= &g_53[0][0].f6 && func_26_rv <= &g_53[5][5].f6));
                    }
                }
            }
        }
        /* facts after branching */
        assert (g_48 == &g_6 || g_48 == 0);
    }
    /* facts after branching */
    assert (g_48 == &g_6 || g_48 == 0);
    assert (g_507 == &g_113.f4 || g_507 == &g_6 || (g_507 >= &g_53[0][0].f2 && g_507 <= &g_53[5][5].f2));
    for (p_28 = 0; (p_28 >= 16); p_28 = safe_add_func_uint32_t_u_u(p_28, 9))
    { /* block id: 528 */
        struct S0 *l_655 = &g_53[4][2];
        int32_t l_657 = 0x1558CFC5;
        int32_t l_709 = 0x7D460FB0;
        int32_t *** const *l_723 = &g_402;
        int32_t *** const **l_722 = &l_723;
        const struct S0 *l_748 = &l_631;
    }
    return (**g_402);
    /* statement id: 648 */
    //assert (func_26_rv == &g_6 || func_26_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_113.f3 g_113.f5 g_10 g_113.f1 g_47 g_48 g_53.f3 g_102 g_6 g_113.f4 g_53 g_121 g_113 g_136 g_402
 * writes: g_113.f3 g_113.f5 g_10 g_113.f1 g_113.f4 g_53 g_113 g_48
 */
inline static int32_t * func_32(int32_t ** p_33, int8_t  p_34, uint32_t  p_35)
{ /* block id: 136 */
    const struct S0 *l_204 = &g_53[0][3];
    int32_t l_227 = 0x3217EF71;
    uint32_t l_233 = 2U;
    int32_t *l_383 = (void*)0;
    int32_t ***l_387 = &g_47;
    struct S0 l_469[8][8][4] = {{{{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0xFDDD9E40,0xC2034747,0xFA24088F,0x08C92BC8,-2,0xDC,0xD74A1225},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{-10,5,0xA05E043C,0,2,-7,0x9E881589}},{{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{-1,0xEDA9BB5D,0,4,1,0xF4,0x969868C8},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97}},{{-10,-1,-6,3,-2,0x47,0x9E6469B5},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{-10,5,0xA05E043C,0,2,-7,0x9E881589},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1}},{{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}},{{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5}},{{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3}},{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{-10,5,0xA05E043C,0,2,-7,0x9E881589},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB}}},{{{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE}},{{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{0xACE1FE26,0,0xC97FF523,0x337B9BA1,-7,3,-9},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}},{{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3}},{{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{-1,0xEDA9BB5D,0,4,1,0xF4,0x969868C8},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE}},{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}}},{{{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1}},{{-10,5,0xA05E043C,0,2,-7,0x9E881589},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{-10,5,0xA05E043C,0,2,-7,0x9E881589},{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3}},{{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}},{{-10,5,0xA05E043C,0,2,-7,0x9E881589},{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1}},{{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2}}},{{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{-1,0xEDA9BB5D,0,4,1,0xF4,0x969868C8},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{-10,5,0xA05E043C,0,2,-7,0x9E881589}},{{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0xACE1FE26,0,0xC97FF523,0x337B9BA1,-7,3,-9},{-10,5,0xA05E043C,0,2,-7,0x9E881589}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2}},{{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}},{{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5}}},{{{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3}},{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{-10,5,0xA05E043C,0,2,-7,0x9E881589},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB}},{{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE}},{{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{0xACE1FE26,0,0xC97FF523,0x337B9BA1,-7,3,-9},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}}},{{{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3}},{{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{-1,0xEDA9BB5D,0,4,1,0xF4,0x969868C8},{0xD229907C,-6,0x1409476E,0x0A6F3A9C,0xC25CABDD,0x07,0xB69E34FE}},{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0xDDECCE43,0x2FE3FA74,1,-6,0,0xDF,-1}},{{-10,5,0xA05E043C,0,2,-7,0x9E881589},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{3,0x2C768674,-8,0xA710CD6E,-1,0,0xC31389CB}},{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{-10,5,0xA05E043C,0,2,-7,0x9E881589},{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3}},{{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307},{0,0x44D12640,-1,1,0xB27E62C0,0xF9,-5}}},{{{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0x5BB275C4,0,1,-8,0x8EF5486D,0x51,3},{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}},{{-10,5,0xA05E043C,0,2,-7,0x9E881589},{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1}},{{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{-1,0,9,0xF84A0A23,-1,0x4A,0xCAA78DE2}},{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0x70D5DF9C,0,0x73AF2724,1,-1,0x4C,-1},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97}},{{0xF80F2628,-2,0xD33B24E8,-9,-5,0x1A,-1},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0x9E1880AA,-3,0,0x8068A80D,2,0x45,-7},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076}},{{0x7A5547CA,0x0C866EF9,0x6B2097C0,0xC2AF8674,0xAFC8EF02,0x96,-5},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{3,0x558A1217,-7,0xF6245630,0xF2A650DD,0xBA,-10},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97}},{{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{0x0D94F229,0xFF944EB7,2,1,0x1CD03C4D,-1,0xA05FC923},{0xD96FA536,0,0xB5E015FB,2,0x3F585C68,0x13,-1},{-1,0xEDA9BB5D,0,4,1,0xF4,0x969868C8}}},{{{0xACE1FE26,0,0xC97FF523,0x337B9BA1,-7,3,-9},{-10,-1,-6,3,-2,0x47,0x9E6469B5},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97},{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36}},{{0x7A5547CA,0x0C866EF9,0x6B2097C0,0xC2AF8674,0xAFC8EF02,0x96,-5},{-1,0xEDA9BB5D,0,4,1,0xF4,0x969868C8},{0x7A5547CA,0x0C866EF9,0x6B2097C0,0xC2AF8674,0xAFC8EF02,0x96,-5},{3,0x558A1217,-7,0xF6245630,0xF2A650DD,0xBA,-10}},{{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0xACE1FE26,0,0xC97FF523,0x337B9BA1,-7,3,-9}},{{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{-10,-1,-6,3,-2,0x47,0x9E6469B5},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077}},{{0xFDDD9E40,0xC2034747,0xFA24088F,0x08C92BC8,-2,0xDC,0xD74A1225},{0xFA5E4E82,-8,0x15620A8C,0x9FACD502,0xF552F81D,0x09,0x11851A36},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97}},{{1,-3,0xD19D1906,0x7607D01D,0xAB14CE97,4,0x6800D077},{0,0xFE537ACF,4,1,0x1D07B776,0xAA,0x8E1DF076},{-8,0x5EF3C3F3,0xCA325603,0x62943B09,2,0x75,3},{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7}},{{0x879A0458,-1,0x2A13701D,0x3194642F,0,0xC7,-7},{-10,0xC2C58EDD,-1,0x86F4C1F1,0,0x00,0xD8DDA7A9},{0x7A5547CA,0x0C866EF9,0x6B2097C0,0xC2AF8674,0xAFC8EF02,0x96,-5},{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307}},{{0x7A5547CA,0x0C866EF9,0x6B2097C0,0xC2AF8674,0xAFC8EF02,0x96,-5},{0x92A40285,1,0,0x3A9FCF5B,2,0xDB,0xFCD8A307},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97},{0x2CECCD96,0x9A26BFEC,4,1,-4,3,0xC21C4D97}}}};
    int32_t l_478 = (-9);
    struct S0 *** const **l_484 = (void*)0;
    int32_t *l_485[3];
    struct S0 l_492 = {-6,-1,-1,0xFD5C8B92,-9,0x31,-1};
    struct S0 **** const l_516 = &g_179;
    uint8_t l_523[6] = {0x10,0x10,0xDF,0x10,0x10,0xDF};
    uint8_t l_525 = 255U;
    uint32_t l_526 = 0x41C93450;
    uint32_t l_573 = 0x86071C77;
    struct S0 *l_575 = (void*)0;
    int8_t l_616 = 0x0A;
    int i, j, k;
    for (i = 0; i < 3; i = i + 1)
        l_485[i] = &g_113.f6;
    for (p_34 = 5; (p_34 < 15); ++p_34)
    { /* block id: 139 */
        uint8_t l_208 = 0xFF;
        for (g_113.f3 = 1; (g_113.f3 <= 4); g_113.f3 += 1)
        { /* block id: 142 */
            for (g_113.f5 = 4; (g_113.f5 >= 1); g_113.f5 -= 1)
            { /* block id: 145 */
                uint32_t l_210[2][4] = {{4294967295U,4294967295U,4294967295U,4294967295U},{4294967295U,4294967295U,4294967295U,4294967295U}};
                int i, j;
                for (g_10 = 0; (g_10 <= 4); g_10 += 1)
                { /* block id: 148 */
                    uint16_t l_209 = 65534U;
                    int32_t l_212 = 0xB076EBF3;
                    for (g_113.f1 = 3; (g_113.f1 >= 0); g_113.f1 -= 1)
                    { /* block id: 151 */
                        int32_t *l_211[10][1] = {{&g_10},{(void*)0},{(void*)0},{&g_10},{(void*)0},{(void*)0},{&g_10},{(void*)0},{(void*)0},{&g_10}};
                        int i, j, k;
                        l_212 = (((safe_add_func_uint32_t_u_u((((p_35 != (safe_mod_func_uint32_t_u_u(((safe_sub_func_int32_t_s_s((((*g_47) != (*g_47)) & ((void*)0 != l_204)), ((&g_179 != (void*)0) != (((safe_unary_minus_func_int32_t_s(0x4A00EA68)) != (((safe_mod_func_int16_t_s_s(7, p_35)) ^ l_208) != p_35)) >= g_53[4][2].f3)))) != p_35), 0xDF4A3FD3))) > l_209) && g_102), g_113.f1)) && l_210[1][1]) & 0x6D6D);
                        return (*g_47);
                        /* statement id: 153 */
                        //assert (func_32_rv == &g_6);
                    }
                }
                if ((**g_47))
                    break;
            }
            for (g_113.f4 = 0; (g_113.f4 <= 4); g_113.f4 += 1)
            { /* block id: 160 */
                struct S0 *l_213 = &g_53[4][2];
                int i, j, k;
                for (p_35 = 1; (p_35 <= 5); p_35 += 1)
                { /* block id: 163 */
                    int i, j, k;
                    g_53[p_35][g_113.f4] = g_53[g_113.f4][p_35];
                }
                (*l_213) = (*g_121);
            }
        }
        (*g_121) = (*l_204);
        for (g_113.f3 = 0; (g_113.f3 <= 5); g_113.f3 += 1)
        { /* block id: 172 */
            int i, j;
            l_204 = &g_53[g_113.f3][g_113.f3];
            return (*p_33);
            /* statement id: 174 */
            //assert (func_32_rv == &g_113.f4 || func_32_rv == &g_6);
        }
    }
    (*g_47) = (*g_47);
    for (p_34 = 0; (p_34 <= 5); p_34 += 1)
    { /* block id: 180 */
        struct S0 *l_220 = (void*)0;
        int32_t l_234 = 0x434B96E3;
        uint32_t l_235[9][3] = {{0U,0U,5U},{0xCF694FA6,0xCF694FA6,4294967295U},{0U,0U,5U},{0xCF694FA6,0xCF694FA6,4294967295U},{0U,0U,5U},{0xCF694FA6,0xCF694FA6,4294967295U},{0U,0U,5U},{0xCF694FA6,0xCF694FA6,4294967295U},{0U,0U,5U}};
        struct S0 ****l_237 = (void*)0;
        int32_t **l_335 = &g_48;
        int32_t ***l_381[2][2];
        int32_t ****l_380[1][3][7] = {{{&l_381[0][0],(void*)0,&l_381[0][0],&l_381[0][0],&l_381[0][0],(void*)0,&l_381[0][0]},{&l_381[0][0],(void*)0,&l_381[0][0],&l_381[0][0],&l_381[0][0],(void*)0,&l_381[0][0]},{&l_381[0][0],(void*)0,&l_381[0][0],&l_381[0][0],&l_381[0][0],(void*)0,&l_381[0][0]}}};
        int32_t *l_442 = (void*)0;
        uint32_t l_464 = 4294967287U;
        const int32_t *l_506[3];
        int32_t l_543 = 0x9797E3E7;
        uint32_t l_570 = 0xA00E82AF;
        uint32_t l_572 = 8U;
        int8_t l_595 = 0x1B;
        int32_t l_597[10] = {0x44CD8904,0x44CD8904,0xC1844ECE,0x44CD8904,0x44CD8904,0xC1844ECE,0x44CD8904,0x44CD8904,0xC1844ECE,0x44CD8904};
        int i, j, k;
        for (i = 0; i < 2; i = i + 1)
        {
            for (j = 0; j < 2; j = j + 1)
                l_381[i][j] = &g_47;
        }
        for (i = 0; i < 3; i = i + 1)
            l_506[i] = &l_492.f2;
    }
    return (**g_402);
    /* statement id: 499 */
    //assert (func_32_rv == &g_6);
}


/* ------------------------------------------ */
/* 
 * reads : g_113.f3
 * writes: g_113.f3
 */
static int32_t ** func_36(int32_t * p_37, int8_t  p_38, int32_t  p_39, int32_t * p_40)
{ /* block id: 129 */
    int32_t **l_195[8];
    int i;
    for (i = 0; i < 8; i = i + 1)
        l_195[i] = &g_136;
    for (g_113.f3 = 5; (g_113.f3 >= 0); g_113.f3 -= 1)
    { /* block id: 132 */
        return l_195[7];
        /* statement id: 133 */
        //assert (func_36_rv == &g_136);
    }
    return &g_136;
    /* statement id: 135 */
    //assert (func_36_rv == &g_136);
}


/* ------------------------------------------ */
/* 
 * reads : g_53 g_47 g_48 g_6 g_102 g_113 g_120 g_121 g_178 g_179 g_10
 * writes: g_53 g_10 g_113 g_136
 */
inline static int32_t  func_42(int32_t ** p_43, uint32_t  p_44, uint32_t  p_45, uint16_t  p_46)
{ /* block id: 10 */
    struct S0 *l_54 = (void*)0;
    struct S0 *l_55 = &g_53[2][0];
    int32_t l_60 = (-9);
    (*l_55) = g_53[4][2];
    for (p_45 = 7; (p_45 >= 14); p_45 = safe_add_func_int16_t_s_s(p_45, 8))
    { /* block id: 14 */
        uint8_t l_155 = 255U;
        int32_t l_181 = 0x010FE33B;
        struct S0 *l_186 = &g_53[4][2];
        for (p_44 = 17; (p_44 <= 46); p_44 = safe_add_func_uint32_t_u_u(p_44, 7))
        { /* block id: 17 */
            int8_t l_192 = 0x5D;
            int32_t l_193 = 1;
            l_181 = ((l_60 >= func_61((safe_rshift_func_int8_t_s_s(((*g_47) != (void*)0), 1)), (func_66(g_6) < (((**p_43) >= ((safe_lshift_func_int16_t_s_s(g_6, ((0xB4B0 ^ (safe_sub_func_uint32_t_u_u((safe_add_func_uint16_t_u_u(((**p_43) && (**p_43)), 1)), 0x0C18A675))) == l_155))) && (-7))) | (-1))))) >= g_6);
            l_193 = (safe_add_func_uint32_t_u_u((((safe_add_func_int8_t_s_s((l_55 != l_186), g_113.f3)) < 1U) && l_60), ((safe_sub_func_int32_t_s_s((((safe_unary_minus_func_uint16_t_u(((safe_sub_func_uint8_t_u_u(p_46, (((void*)0 != (*g_178)) < (g_113.f4 >= g_10)))) && g_113.f1))) || (**g_47)) == l_192), g_53[4][2].f5)) < 0)));
        }
    }
    /* facts after for loop */
    assert (g_136 == &g_113.f4 || g_136 == &g_6);
    return l_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_113.f6 g_48 g_6 g_53.f5 g_47 g_53.f6 g_113.f4 g_178 g_179 g_113.f3 g_53.f1 g_113.f1
 * writes: g_113.f6
 */
inline static int16_t  func_61(int16_t  p_62, uint32_t  p_63)
{ /* block id: 117 */
    int32_t l_160 = 0x3788430C;
    int32_t *l_163 = &g_113.f6;
    const uint16_t l_172 = 0x6768;
    if ((safe_add_func_uint8_t_u_u((safe_add_func_uint32_t_u_u(l_160, (safe_sub_func_int8_t_s_s((((l_163 == l_163) || (safe_sub_func_uint8_t_u_u((((*l_163) < p_62) != (((*g_48) | (((safe_mod_func_int32_t_s_s(0x8CB1CE7F, ((safe_mod_func_int16_t_s_s((((g_53[4][2].f5 && (safe_mod_func_uint16_t_u_u((((l_163 != (*g_47)) | 246U) & g_53[4][2].f6), (*l_163)))) | p_62) < 0x13D90FEA), g_53[4][2].f6)) | p_62))) || p_63) <= g_113.f4)) >= l_172)), p_62))) <= 6), 4U)))), 0xDF)))
    { /* block id: 118 */
        struct S0 ****l_180 = &g_179;
        (*l_163) = ((p_62 | (((((0x6872 && (0x4198814D >= (safe_rshift_func_int16_t_s_s((safe_rshift_func_uint8_t_u_u(g_53[4][2].f5, 0)), (((+(g_178 == l_180)) == (((0x0C5D1EC6 && ((*g_178) == (*l_180))) < 0x7B6A1989) ^ 0U)) != g_113.f3))))) ^ p_62) > g_53[4][2].f1) != 1U) ^ 0xA216)) <= 0x40);
        return g_113.f1;
    }
    else
    { /* block id: 121 */
        return p_62;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_47 g_48 g_53.f1 g_6 g_10 g_53.f5 g_53.f2 g_102 g_113 g_120 g_121 g_53
 * writes: g_10 g_53 g_113 g_136
 */
inline static int8_t  func_66(uint16_t  p_67)
{ /* block id: 18 */
    uint8_t l_69[4];
    int32_t l_98 = 0x6F3D1338;
    int32_t l_108 = 0xCABD61F3;
    struct S0 l_127 = {1,0x28E2A20A,0x37EAFC3D,0x15252EC4,0x57C61DA5,0x14,0x98EA379F};
    struct S0 *l_134 = &g_53[1][1];
    int32_t *l_138 = (void*)0;
    int32_t **l_147 = (void*)0;
    int32_t **l_148 = &g_136;
    int i;
    for (i = 0; i < 4; i = i + 1)
        l_69[i] = 0x5D;
    if (p_67)
    { /* block id: 19 */
        int8_t l_68 = 1;
        int32_t **l_78 = &g_48;
lbl_99:
        for (g_10 = 0; g_10 < 6; g_10 += 1)
        {
            for (p_67 = 0; p_67 < 6; p_67 += 1)
            {
                struct S0 tmp = {0,0,-10,0xC44CB182,-3,0x16,-1};
                g_53[g_10][p_67] = tmp;
            }
        }
        if (l_68)
        { /* block id: 21 */
            int16_t l_81 = 0;
            struct S0 *l_86[3][4] = {{&g_53[4][2],&g_53[4][2],&g_53[4][2],&g_53[4][2]},{&g_53[4][2],&g_53[4][2],&g_53[4][2],&g_53[4][2]},{&g_53[4][2],&g_53[4][2],&g_53[4][2],&g_53[4][2]}};
            struct S0 **l_85 = &l_86[1][3];
            int i, j;
            l_69[2] = l_68;
            if (p_67)
            { /* block id: 23 */
                int32_t *l_71 = (void*)0;
                int32_t **l_70 = &l_71;
                (*l_70) = (*g_47);
                /* statement id: 24 */
                assert (l_71 == &g_6);
            }
            else
            { /* block id: 25 */
                uint8_t l_75 = 0U;
                int32_t *l_82 = &g_53[4][2].f2;
                for (g_10 = 0; g_10 < 4; g_10 += 1)
                {
                    l_69[g_10] = 1U;
                }
                (*l_82) = (safe_unary_minus_func_uint8_t_u(((0xD1 & l_68) < ((safe_rshift_func_int8_t_s_u(l_75, ((((*g_47) != (void*)0) ^ (safe_lshift_func_int16_t_s_u(((l_78 != (void*)0) > g_53[4][2].f1), ((((safe_sub_func_int16_t_s_s(p_67, p_67)) & g_6) <= l_81) < 1U)))) != 2U))) > (**l_78)))));
            }
            for (g_10 = (-29); (g_10 >= (-17)); g_10 = safe_add_func_int8_t_s_s(g_10, 3))
            { /* block id: 31 */
                struct S0 ***l_87 = &l_85;
                (*l_87) = l_85;
            }
        }
        else
        { /* block id: 34 */
            l_98 = ((p_67 && (g_53[4][2].f5 == (((p_67 < (((((safe_rshift_func_uint8_t_u_u(((safe_add_func_int16_t_s_s(p_67, (safe_mod_func_int8_t_s_s((((*l_78) != (*g_47)) && (safe_mod_func_uint8_t_u_u(l_69[3], (safe_add_func_int16_t_s_s(l_69[2], 0))))), l_69[0])))) < p_67), 7)) <= p_67) < p_67) | 0xFBC8947E) != (-1))) | 246U) || 9U))) | p_67);
            if (g_6)
                goto lbl_99;
        }
    }
    else
    { /* block id: 38 */
        int32_t *l_101 = &g_10;
        struct S0 *l_125 = &g_53[4][2];
        struct S0 l_129 = {-1,0,-3,-9,0x0A43F849,0xBF,0xE32FE6CD};
        struct S0 ***l_145 = &g_120[3][4][2];
        struct S0 ****l_144 = &l_145;
lbl_143:
        if (((safe_unary_minus_func_int16_t_s((p_67 ^ g_53[4][2].f2))) | ((&l_98 != l_101) & g_102)))
        { /* block id: 39 */
            struct S0 l_114 = {9,0x9B981B60,0xE664DD2F,0xD6CDB74E,-9,-4,0x4A4A936F};
            int32_t *l_117 = &l_114.f4;
            if ((safe_add_func_int8_t_s_s((((p_67 == 4294967293U) != (safe_add_func_uint16_t_u_u(p_67, ((**g_47) == 0x631664A1)))) | (safe_unary_minus_func_int16_t_s((0xF7B8 ^ (l_108 >= ((g_53[4][2].f2 > (safe_rshift_func_int8_t_s_u((safe_lshift_func_uint16_t_u_s(1U, 3)), 1))) == 1U)))))), 0x81)))
            { /* block id: 40 */
                l_114 = g_113;
                l_98 = (safe_sub_func_int32_t_s_s((l_117 == (*g_47)), (safe_mod_func_uint32_t_u_u((g_120[3][4][2] == &g_121), (safe_lshift_func_uint8_t_u_s((g_53[4][2].f5 & (!(*g_48))), 3))))));
            }
            else
            { /* block id: 43 */
                struct S0 *l_126 = (void*)0;
                (*l_117) = (l_125 == l_126);
            }
            if (l_127.f0)
                goto lbl_146;
        }
        else
        { /* block id: 46 */
            int32_t *l_131 = &g_53[4][2].f2;
            (*g_121) = l_127;
            for (l_98 = 0; (l_98 <= 5); l_98 += 1)
            { /* block id: 50 */
                int32_t **l_128 = &l_101;
                (*l_128) = (void*)0;
                /* statement id: 51 */
                assert (l_101 == 0);
                (*l_128) = &l_98;
                /* statement id: 52 */
                assert (l_101 == &l_98);
                (*l_128) = (*g_47);
                /* statement id: 53 */
                assert (l_101 == &g_6);
                for (l_127.f0 = 5; (l_127.f0 >= 1); l_127.f0 -= 1)
                { /* block id: 56 */
                    int32_t *l_130 = &g_53[4][2].f2;
                    int i, j;
                    g_53[l_98][l_127.f0] = l_129;
                    (*l_128) = l_101;
                    if (l_108)
                        goto lbl_143;
                    if (p_67)
                    { /* block id: 59 */
                        (*l_128) = l_130;
                        /* statement id: 60 */
                        assert ((l_101 >= &g_53[0][0].f2 && l_101 <= &g_53[5][5].f2));
                        (*l_128) = l_131;
                    }
                    else
                    { /* block id: 62 */
                        return (*l_130);
                    }
                    /* facts after branching */
                    assert ((l_101 >= &g_53[0][0].f2 && l_101 <= &g_53[5][5].f2));
                    for (p_67 = 0; (p_67 <= 3); p_67 += 1)
                    { /* block id: 67 */
                        int i;
                        (*l_101) = 0xD04652DB;
                        return l_69[p_67];
                    }
                }
                /* facts after for loop */
                assert ((l_101 >= &g_53[0][0].f2 && l_101 <= &g_53[5][5].f2) || l_101 == &g_6);
            }
            for (g_113.f3 = 4; (g_113.f3 >= 0); g_113.f3 -= 1)
            { /* block id: 75 */
                for (l_129.f4 = 1; (l_129.f4 <= 4); l_129.f4 += 1)
                { /* block id: 78 */
                    struct S0 * const l_133 = (void*)0;
                    if ((p_67 > p_67))
                    { /* block id: 79 */
                        int32_t **l_132 = &l_131;
                        (*l_132) = &l_98;
                        /* statement id: 80 */
                        assert (l_131 == &l_98);
                        l_134 = l_133;
                        /* statement id: 81 */
                        assert (l_134 == 0);
                    }
                    else
                    { /* block id: 82 */
                        struct S0 **l_135 = &l_134;
                        int32_t **l_137[7] = {(void*)0,&g_48,&g_48,(void*)0,&g_48,&g_48,(void*)0};
                        int i;
                        (*l_135) = l_133;
                        /* statement id: 83 */
                        assert (l_134 == 0);
                        g_136 = (*g_47);
                        /* statement id: 84 */
                        assert (g_136 == &g_6);
                        l_131 = &l_98;
                        /* statement id: 85 */
                        assert (l_131 == &l_98);
                    }
                    /* facts after branching */
                    assert (l_131 == &l_98);
                    assert (l_134 == 0);
                    if (p_67)
                        continue;
                    for (g_113.f4 = 0; (g_113.f4 <= 4); g_113.f4 += 1)
                    { /* block id: 90 */
                        (*l_125) = (*g_121);
                    }
                }
                for (l_127.f0 = 0; (l_127.f0 <= 3); l_127.f0 += 1)
                { /* block id: 96 */
                    l_138 = (*g_47);
                    /* statement id: 97 */
                    assert (l_138 == &g_6);
                    for (g_10 = 0; (g_10 <= 3); g_10 += 1)
                    { /* block id: 100 */
                        int i;
                        (*l_131) = (l_69[l_127.f0] >= 0x5B);
                        (*l_131) = (safe_lshift_func_int8_t_s_s(((p_67 != (p_67 == 0U)) | 1U), 0));
                    }
                }
            }
            /* facts after for loop */
            assert (l_131 == &l_98 || (l_131 >= &g_53[0][0].f2 && l_131 <= &g_53[5][5].f2));
            assert (l_134 == 0 || (l_134 >= &g_53[0][0] && l_134 <= &g_53[5][5]));
            assert (l_138 == &g_6 || l_138 == 0);
            l_129.f3 = (safe_sub_func_int8_t_s_s(p_67, p_67));
        }
        /* facts after branching */
        assert (l_134 == 0 || (l_134 >= &g_53[0][0] && l_134 <= &g_53[5][5]));
        assert (l_138 == &g_6 || l_138 == 0);
lbl_146:
        (*l_144) = &g_120[3][4][2];
        return g_113.f5;
    }
    (*l_134) = (*l_134);
    l_138 = &l_98;
    /* statement id: 114 */
    assert (l_138 == &l_98);
    (*l_148) = (*g_47);
    /* statement id: 115 */
    assert (g_136 == &g_6);
    return g_53[4][2].f5;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_6, "g_6", print_hash_value);
    transparent_crc(g_10, "g_10", print_hash_value);
    for (i = 0; i < 6; i = i + 1)
    {
        for (j = 0; j < 6; j = j + 1)
        {
            transparent_crc(g_53[i][j].f0, "g_53[i][j].f0", print_hash_value);
            transparent_crc(g_53[i][j].f1, "g_53[i][j].f1", print_hash_value);
            transparent_crc(g_53[i][j].f2, "g_53[i][j].f2", print_hash_value);
            transparent_crc(g_53[i][j].f3, "g_53[i][j].f3", print_hash_value);
            transparent_crc(g_53[i][j].f4, "g_53[i][j].f4", print_hash_value);
            transparent_crc(g_53[i][j].f5, "g_53[i][j].f5", print_hash_value);
            transparent_crc(g_53[i][j].f6, "g_53[i][j].f6", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_102, "g_102", print_hash_value);
    transparent_crc(g_113.f0, "g_113.f0", print_hash_value);
    transparent_crc(g_113.f1, "g_113.f1", print_hash_value);
    transparent_crc(g_113.f2, "g_113.f2", print_hash_value);
    transparent_crc(g_113.f3, "g_113.f3", print_hash_value);
    transparent_crc(g_113.f4, "g_113.f4", print_hash_value);
    transparent_crc(g_113.f5, "g_113.f5", print_hash_value);
    transparent_crc(g_113.f6, "g_113.f6", print_hash_value);
    transparent_crc(g_352, "g_352", print_hash_value);
    transparent_crc(g_620, "g_620", print_hash_value);
    transparent_crc(g_713, "g_713", print_hash_value);
    transparent_crc(g_731, "g_731", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
        {
            transparent_crc(g_760[i][j], "g_760[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 177
   depth: 1, occurrence: 25
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 24
breakdown:
   depth: 1, occurrence: 121
   depth: 2, occurrence: 32
   depth: 3, occurrence: 1
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 2

XXX total number of pointers: 165

XXX times a variable address is taken: 418
XXX times a pointer is dereferenced on RHS: 139
breakdown:
   depth: 1, occurrence: 104
   depth: 2, occurrence: 25
   depth: 3, occurrence: 7
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 120
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 9
   depth: 3, occurrence: 4
   depth: 4, occurrence: 8
XXX times a pointer is compared with null: 32
XXX times a pointer is compared with address of another variable: 10
XXX times a pointer is compared with another pointer: 30
XXX times a pointer is qualified to be dereferenced: 1240

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 451
   level: 2, occurrence: 172
   level: 3, occurrence: 71
   level: 4, occurrence: 68
   level: 5, occurrence: 38
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 54
XXX number of pointers point to structs: 26
XXX percent of pointers has null in alias set: 28.5
XXX average alias set size: 1.65

XXX times a non-volatile is read: 982
XXX times a non-volatile is write: 423
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 10

XXX stmts: 116
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 20
   depth: 2, occurrence: 19
   depth: 3, occurrence: 18
   depth: 4, occurrence: 13
   depth: 5, occurrence: 18

XXX percentage a fresh-made variable is used: 17.4
XXX percentage an existing variable is used: 82.6
********************* end of statistics **********************/

