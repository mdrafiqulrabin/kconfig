/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1133420944
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   unsigned f0 : 22;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
static float  func_4(int16_t  p_5);
static uint16_t  func_6(uint8_t  p_7, int16_t  p_8, uint16_t  p_9, uint64_t  p_10, int32_t  p_11);
inline static uint8_t  func_12(uint32_t  p_13);
static int64_t  func_25(uint8_t  p_26, int64_t  p_27, int64_t  p_28, int8_t  p_29);
static int32_t * func_37(int8_t  p_38);
inline static struct S0  func_40(uint32_t  p_41, const uint64_t  p_42);
inline static uint32_t  func_43(float  p_44, int32_t  p_45);
inline static float  func_48(uint64_t  p_49, int32_t  p_50, const int32_t * p_51, int32_t * p_52, const int32_t  p_53);
inline static uint64_t  func_56(int32_t * const  p_57, float  p_58);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_14 = 0xCDDDL;
    struct S0 ****l_864 = (void*)0;
    int16_t l_867[9][7][4] = {{{(-1L),0x488CL,0x488CL,(-1L)},{0x488CL,(-1L),0xB8DBL,0xC0AEL},{0x488CL,0xB8DBL,0x488CL,0xF515L},{(-1L),0xC0AEL,0xF515L,0xF515L},{0xB8DBL,0xB8DBL,0x92D5L,0xC0AEL},{0xC0AEL,(-1L),0x92D5L,(-1L)},{0xB8DBL,0x488CL,0xF515L,0x92D5L}},{{(-1L),0x488CL,0x488CL,(-1L)},{0x488CL,(-1L),0xB8DBL,0xC0AEL},{0x488CL,0xB8DBL,0x488CL,0xF515L},{(-1L),0xC0AEL,0xF515L,0xF515L},{0xB8DBL,0xB8DBL,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0xF515L,0x92D5L,0x92D5L},{0x3EE3L,0x3EE3L,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0xF515L,0x92D5L,0x92D5L},{0x3EE3L,0x3EE3L,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0xF515L,0x92D5L,0x92D5L},{0x3EE3L,0x3EE3L,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0xF515L,0x92D5L,0x92D5L},{0x3EE3L,0x3EE3L,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0xF515L,0x92D5L,0x92D5L},{0x3EE3L,0x3EE3L,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0xF515L,0x92D5L,0x92D5L},{0x3EE3L,0x3EE3L,0xB8DBL,0xF515L},{0xF515L,0x488CL,0xB8DBL,0x488CL},{0x3EE3L,0xC0AEL,0x92D5L,0xB8DBL}},{{0x488CL,0xC0AEL,0xC0AEL,0x488CL},{0xC0AEL,0x488CL,0x3EE3L,0xF515L},{0xC0AEL,0x3EE3L,0xC0AEL,0x92D5L},{0x488CL,0x92D5L,0xB8DBL,0xB8DBL},{(-1L),(-1L),0x3EE3L,0x92D5L},{0x92D5L,0xC0AEL,0x3EE3L,0xC0AEL},{(-1L),0xF515L,0xB8DBL,0x3EE3L}}};
    float l_1329 = 0x0.218082p+20;
    float *l_1328[5] = {&l_1329,&l_1329,&l_1329,&l_1329,&l_1329};
    int32_t l_1330 = 0x969EA042L;
    int i, j, k;
    l_1330 = (safe_sub_func_float_f_f(func_4((func_6(func_12(l_14), l_14, (((2L == ((safe_mod_func_int8_t_s_s((safe_add_func_int16_t_s_s(0x8B89L, (safe_rshift_func_uint8_t_u_u((l_864 != l_864), (safe_add_func_uint32_t_u_u(l_14, l_867[6][0][2])))))), l_14)) | (-1L))) < l_867[6][0][2]) & l_867[6][0][2]), l_14, l_867[2][0][2]) | 0xDCA0L)), 0xA.6F3864p+78));
    return l_1330;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_4(int16_t  p_5)
{ /* block id: 762 */
    const struct S0 ****l_1219[1][5];
    int32_t l_1220 = (-5L);
    const int32_t ** const *l_1225 = (void*)0;
    const int32_t ** const **l_1224[8][3] = {{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225},{(void*)0,&l_1225,&l_1225}};
    const int32_t ** const ***l_1223 = &l_1224[7][0];
    int32_t *l_1299 = &l_1220;
    int i, j;
    for (i = 0; i < 1; i++)
    {
        for (j = 0; j < 5; j++)
            l_1219[i][j] = (void*)0;
    }
    for (p_5 = (-10); (p_5 >= (-4)); p_5++)
    { /* block id: 765 */
        int32_t l_1198 = 0xBF16FBE4L;
        struct S0 l_1203 = {1135};
        struct S0 *l_1204 = (void*)0;
        struct S0 *l_1205 = &l_1203;
        int32_t l_1227 = 0x22DBF207L;
        int32_t *l_1282 = &l_1220;
        for (l_1198 = (-22); (l_1198 <= (-15)); l_1198 = safe_add_func_uint64_t_u_u(l_1198, 2))
        { /* block id: 768 */
            int32_t *l_1202 = &l_1198;
            int32_t **l_1201 = &l_1202;
            (*l_1201) = (void*)0;
            /* statement id: 769 */
            assert (l_1202 == 0);
        }
        (*l_1205) = l_1203;
        if ((safe_mod_func_int64_t_s_s(p_5, (safe_sub_func_uint64_t_u_u((safe_add_func_int32_t_s_s((((p_5 > (p_5 && (!(safe_mod_func_uint64_t_u_u(p_5, l_1203.f0))))) && (((0xEE523C01L || p_5) | (safe_div_func_uint8_t_u_u(((((1L | ((safe_mod_func_int32_t_s_s(((l_1219[0][1] != (void*)0) && l_1198), 0x40738BAFL)) && p_5)) != l_1220) == 0x42D413413D724932LL) < p_5), 0x24L))) >= p_5)) >= p_5), p_5)), l_1198)))))
        { /* block id: 772 */
            int32_t *l_1226 = &l_1198;
            int32_t l_1325 = 0x7C2453FDL;
            if ((safe_rshift_func_int8_t_s_s((0L ^ (l_1203.f0 != 0x6AL)), 0)))
            { /* block id: 773 */
                uint8_t l_1228[10][3][5] = {{{248UL,0xD9L,8UL,255UL,0x0DL},{0x14L,0UL,1UL,1UL,250UL},{0x0DL,0UL,0x78L,0UL,0xD9L}},{{1UL,0xE5L,0xACL,255UL,255UL},{0UL,5UL,1UL,8UL,1UL},{0x7FL,0x7FL,0xE5L,0x42L,1UL}},{{0xE4L,0x55L,255UL,0x43L,0x80L},{0xE8L,0xCDL,251UL,0x14L,0x33L},{8UL,0x55L,0UL,0x21L,0x7EL}},{{0xFCL,0x7FL,0x24L,0UL,253UL},{255UL,5UL,0x43L,0xD9L,0x4FL},{0UL,0xE5L,255UL,0xACL,0UL}},{{0x69L,0UL,0UL,0x69L,0x18L},{0xF9L,0UL,253UL,1UL,0xE8L},{0x55L,0xD9L,0x9FL,0xC8L,255UL}},{{255UL,0x38L,255UL,1UL,0xCDL},{0x7EL,255UL,247UL,0x69L,0xC8L},{0UL,0x7AL,1UL,0xACL,255UL}},{{0xADL,0x7EL,0UL,0xD9L,0x4CL},{0x50L,0x84L,0UL,0UL,0x84L},{0x80L,0x78L,0UL,0x21L,0x69L}},{{0xCDL,0xBAL,1UL,0x14L,255UL},{246UL,8UL,255UL,0x43L,248UL},{0xCDL,1UL,255UL,0x42L,0x5AL}},{{0x80L,0x0BL,0x7BL,8UL,0x9CL},{0x50L,1UL,0xBAL,255UL,0xE6L},{0xADL,1UL,0x0DL,0UL,0UL}},{{0UL,0x33L,0UL,1UL,0xE9L},{0x7EL,0x8CL,0xC8L,255UL,0x0BL},{255UL,255UL,0xBAL,254UL,255UL}}};
                int32_t *l_1229 = &l_1198;
                int i, j, k;
                l_1223 = l_1223;
                for (l_1198 = 0; (l_1198 <= 2); l_1198 += 1)
                { /* block id: 777 */
                    int i, j;
                    l_1226 = l_1226;
                    l_1226 = func_37((l_1227 || p_5));
                    /* statement id: 779 */
                    assert (l_1226 == 0);
                }
                /* facts after for loop */
                assert (l_1226 == 0 || l_1226 == &l_1198);
                (*l_1229) = (0xD82EF8A9L && l_1228[2][1][3]);
                l_1229 = &l_1198;
            }
            else
            { /* block id: 783 */
                int8_t l_1234 = 0x09L;
                int32_t *** const **l_1276 = (void*)0;
                struct S0 l_1286 = {412};
                struct S0 **l_1296 = &l_1204;
                struct S0 ***l_1295 = &l_1296;
                uint32_t l_1324[4][10] = {{0xFCA33F71L,0x4D30B0BCL,18446744073709551615UL,0x1D2C0EEFL,18446744073709551615UL,0x4D30B0BCL,0xFCA33F71L,0xFCA33F71L,0x4D30B0BCL,18446744073709551615UL},{0x4D30B0BCL,0xFCA33F71L,0xFCA33F71L,0x4D30B0BCL,18446744073709551615UL,0x1D2C0EEFL,18446744073709551615UL,0x4D30B0BCL,0xFCA33F71L,0xFCA33F71L},{18446744073709551615UL,0xFCA33F71L,0xAB624852L,0UL,0UL,0xAB624852L,0xFCA33F71L,18446744073709551615UL,0xFCA33F71L,0xAB624852L},{0x1D2C0EEFL,0x4D30B0BCL,0UL,0x4D30B0BCL,0x1D2C0EEFL,0xAB624852L,0xAB624852L,0x1D2C0EEFL,0x4D30B0BCL,0UL}};
                int i, j;
                if ((safe_mod_func_int32_t_s_s(l_1203.f0, (safe_sub_func_uint32_t_u_u(l_1234, ((safe_lshift_func_uint16_t_u_s(p_5, 9)) != 0x007C6FB7L))))))
                { /* block id: 784 */
                    struct S0 *l_1237[7][5][3] = {{{&l_1203,&l_1203,&l_1203},{&l_1203,(void*)0,&l_1203},{&l_1203,(void*)0,&l_1203},{&l_1203,(void*)0,&l_1203},{(void*)0,&l_1203,&l_1203}},{{&l_1203,(void*)0,&l_1203},{(void*)0,(void*)0,&l_1203},{&l_1203,(void*)0,(void*)0},{(void*)0,&l_1203,&l_1203},{(void*)0,&l_1203,&l_1203}},{{(void*)0,&l_1203,(void*)0},{&l_1203,(void*)0,&l_1203},{(void*)0,&l_1203,&l_1203},{&l_1203,(void*)0,&l_1203},{&l_1203,(void*)0,&l_1203}},{{&l_1203,&l_1203,&l_1203},{(void*)0,&l_1203,&l_1203},{&l_1203,(void*)0,&l_1203},{(void*)0,&l_1203,&l_1203},{(void*)0,&l_1203,&l_1203}},{{(void*)0,(void*)0,&l_1203},{&l_1203,&l_1203,(void*)0},{(void*)0,&l_1203,&l_1203},{&l_1203,(void*)0,(void*)0},{(void*)0,(void*)0,&l_1203}},{{&l_1203,&l_1203,(void*)0},{&l_1203,(void*)0,&l_1203},{&l_1203,&l_1203,&l_1203},{&l_1203,&l_1203,&l_1203},{&l_1203,&l_1203,&l_1203}},{{&l_1203,(void*)0,&l_1203},{&l_1203,(void*)0,&l_1203},{&l_1203,(void*)0,&l_1203},{(void*)0,&l_1203,&l_1203},{&l_1203,(void*)0,&l_1203}}};
                    float l_1244 = (-0x2.6p-1);
                    float *l_1243 = &l_1244;
                    int i, j, k;
                    for (l_1227 = 0; (l_1227 <= 2); l_1227 += 1)
                    { /* block id: 787 */
                        l_1237[0][1][0] = l_1237[1][1][2];
                    }
                    (*l_1243) = (safe_add_func_float_f_f((safe_sub_func_float_f_f((+0x4.5p-1), (*l_1226))), 0x6.3p+1));
                    l_1226 = (void*)0;
                    /* statement id: 791 */
                    assert (l_1226 == 0);
                }
                else
                { /* block id: 792 */
                    uint32_t l_1247[2][3] = {{8UL,8UL,8UL},{1UL,1UL,1UL}};
                    int8_t l_1252 = 0x0CL;
                    float *l_1265 = (void*)0;
                    float **l_1264 = &l_1265;
                    float ***l_1263 = &l_1264;
                    int32_t *l_1283 = &l_1220;
                    int i, j;
                    if (((safe_div_func_uint16_t_u_u(l_1247[0][2], (*l_1226))) >= (((p_5 >= (safe_lshift_func_uint16_t_u_u((*l_1226), (l_1234 >= ((safe_sub_func_int32_t_s_s(l_1252, (safe_unary_minus_func_uint64_t_u(p_5)))) || 0x31L))))) & ((0x603A6DC5L | 0xE6622D4FL) || 0x39L)) < l_1198)))
                    { /* block id: 793 */
                        const int32_t **l_1275 = (void*)0;
                        const int32_t ***l_1274 = &l_1275;
                        const int32_t **** const l_1273[10] = {&l_1274,&l_1274,&l_1274,&l_1274,&l_1274,&l_1274,&l_1274,&l_1274,&l_1274,&l_1274};
                        const int32_t **** const *l_1272[9] = {&l_1273[9],&l_1273[9],&l_1273[9],&l_1273[9],&l_1273[9],&l_1273[9],&l_1273[9],&l_1273[9],&l_1273[9]};
                        float *l_1279 = (void*)0;
                        float l_1281 = 0x1.1p+1;
                        float *l_1280 = &l_1281;
                        int i;
                        (*l_1280) = (0xE.0B4C38p+62 >= (safe_div_func_float_f_f((+(0xE.567E74p+47 < (((safe_div_func_float_f_f(((safe_add_func_float_f_f((((safe_sub_func_float_f_f((((0xC.DE389Cp+77 <= 0xA.035B1Dp+93) < (l_1263 != (void*)0)) != (safe_div_func_float_f_f(((safe_add_func_float_f_f(((safe_div_func_float_f_f(((((l_1272[3] == l_1276) != (safe_sub_func_float_f_f((p_5 != (-0x5.1p-1)), 0x0.5499E8p+87))) == p_5) != 0xC.F52574p-67), 0x1.3679DEp-20)) != p_5), p_5)) > (*l_1226)), p_5))), 0x9.74DDC8p+92)) != (*l_1226)) < l_1247[1][0]), l_1247[0][2])) == (-0x2.4p+1)), p_5)) >= 0x5.389387p+86) < l_1247[1][2]))), p_5)));
                        l_1282 = &l_1227;
                        /* statement id: 795 */
                        assert (l_1282 == &l_1227);
                        l_1282 = l_1265;
                        /* statement id: 796 */
                        assert (l_1282 == 0);
                    }
                    else
                    { /* block id: 797 */
                        (*l_1205) = func_40(p_5, (*l_1226));
                        l_1283 = l_1265;
                        /* statement id: 799 */
                        assert (l_1283 == 0);
                    }
                    /* facts after branching */
                    assert (l_1282 == &l_1220 || l_1282 == 0);
                    assert (l_1283 == 0 || l_1283 == &l_1220);
                }
                /* facts after branching */
                assert (l_1226 == &l_1198 || l_1226 == 0);
                assert (l_1282 == &l_1220 || l_1282 == 0);
                if ((safe_add_func_uint16_t_u_u(p_5, 0UL)))
                { /* block id: 802 */
                    int32_t l_1297[5] = {0L,0L,0L,0L,0L};
                    int32_t l_1298 = 0xD610D611L;
                    int32_t *l_1326 = (void*)0;
                    int32_t *l_1327 = &l_1325;
                    int i;
                    l_1286 = l_1286;
                    l_1298 = (p_5 != (((-0x9.7p-1) <= (safe_add_func_float_f_f(((((0x0.5p-1 < ((p_5 < ((safe_add_func_float_f_f(((0x2.C626D3p-73 == p_5) != (safe_div_func_float_f_f((safe_sub_func_float_f_f(p_5, (l_1295 == (void*)0))), 0x5.0p+1))), 0x4.2A2427p-59)) == p_5)) == p_5)) >= p_5) != p_5) > l_1297[2]), p_5))) != l_1297[2]));
                    l_1299 = func_37(p_5);
                    /* statement id: 805 */
                    assert (l_1299 == 0);
                    (*l_1327) = (safe_div_func_uint8_t_u_u(p_5, (safe_div_func_uint64_t_u_u((((safe_add_func_uint8_t_u_u((~((+(((((((p_5 < (~0x815BL)) > (safe_mod_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_s(((safe_add_func_uint64_t_u_u((safe_div_func_int16_t_s_s(p_5, p_5)), (~(safe_lshift_func_int16_t_s_s(((p_5 & l_1324[2][4]) < ((1UL == (0x01EEL | p_5)) <= l_1325)), 2))))) <= l_1297[2]), p_5)), 18446744073709551611UL))) & 1L) != 1UL) && p_5) ^ 0x0CL) != l_1297[2])) >= p_5)), 0UL)) != p_5) > 0L), p_5))));
                }
                else
                { /* block id: 807 */
                    (*l_1299) = p_5;
                }
                /* facts after branching */
                assert (l_1299 == &l_1220 || l_1299 == 0);
            }
            /* facts after branching */
            assert (l_1226 == 0 || l_1226 == &l_1198);
            assert (l_1282 == &l_1220 || l_1282 == 0);
            assert (l_1299 == &l_1220 || l_1299 == 0);
            return p_5;
        }
        else
        { /* block id: 812 */
            (*l_1282) = p_5;
            l_1282 = &l_1198;
            /* statement id: 814 */
            assert (l_1282 == &l_1198);
        }
        /* facts after branching */
        assert (l_1282 == &l_1198);
    }
    (*l_1299) = (-5L);
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_6(uint8_t  p_7, int16_t  p_8, uint16_t  p_9, uint64_t  p_10, int32_t  p_11)
{ /* block id: 580 */
    struct S0 l_868[5][3][8] = {{{{1113},{966},{361},{536},{1365},{1304},{1304},{1365}},{{1697},{1921},{1921},{1697},{1113},{984},{1822},{1365}},{{536},{361},{966},{1113},{794},{1113},{966},{361}}},{{{1697},{361},{1365},{966},{680},{984},{223},{223}},{{1365},{1697},{1921},{1921},{1697},{1365},{223},{794}},{{1822},{1921},{1365},{984},{966},{536},{966},{984}}},{{{966},{536},{966},{984},{1365},{1921},{1822},{794}},{{223},{1365},{1697},{1921},{1921},{1697},{1365},{223}},{{223},{984},{680},{966},{1365},{361},{1697},{361}}},{{{966},{1113},{794},{1113},{966},{361},{536},{1365}},{{1822},{984},{1113},{1304},{1697},{1697},{1304},{1113}},{{1365},{1365},{1113},{223},{680},{1921},{536},{1822}}},{{{1697},{536},{794},{1365},{794},{536},{1697},{1822}},{{536},{1921},{680},{223},{1113},{1365},{1365},{1113}},{{1304},{1697},{1697},{1304},{1113},{984},{1822},{1365}}}};
    int32_t l_901 = 0x35F55015L;
    int32_t *l_900[5];
    uint8_t l_914 = 0x0EL;
    struct S0 *l_919[10] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    struct S0 **l_918 = &l_919[4];
    struct S0 ***l_917 = &l_918;
    int32_t * const *l_927 = (void*)0;
    int32_t * const **l_926[10][6] = {{(void*)0,&l_927,&l_927,&l_927,&l_927,&l_927},{&l_927,&l_927,&l_927,&l_927,&l_927,&l_927},{&l_927,&l_927,&l_927,&l_927,&l_927,&l_927},{&l_927,&l_927,&l_927,&l_927,(void*)0,&l_927},{&l_927,&l_927,&l_927,&l_927,&l_927,&l_927},{&l_927,&l_927,&l_927,&l_927,&l_927,&l_927},{&l_927,&l_927,&l_927,&l_927,&l_927,&l_927},{&l_927,(void*)0,&l_927,&l_927,&l_927,&l_927},{&l_927,&l_927,&l_927,(void*)0,&l_927,&l_927},{(void*)0,&l_927,&l_927,&l_927,&l_927,&l_927}};
    int32_t * const ***l_925 = &l_926[8][1];
    float *l_939 = (void*)0;
    float **l_938 = &l_939;
    float ** const *l_937[6] = {&l_938,&l_938,&l_938,&l_938,&l_938,&l_938};
    uint32_t l_1059[2][7] = {{0x28DD8A2EL,0x28DD8A2EL,0x4AAC6E2DL,0x28DD8A2EL,0x28DD8A2EL,0x4AAC6E2DL,0x28DD8A2EL},{0x07E964C1L,0x4AAC6E2DL,0x4AAC6E2DL,0x07E964C1L,0x4AAC6E2DL,0x4AAC6E2DL,0x07E964C1L}};
    uint8_t l_1109[2];
    struct S0 *****l_1111 = (void*)0;
    int32_t ***l_1181 = (void*)0;
    int32_t ****l_1180 = &l_1181;
    int i, j, k;
    for (i = 0; i < 5; i++)
        l_900[i] = &l_901;
    for (i = 0; i < 2; i++)
        l_1109[i] = 2UL;
    l_868[4][1][0] = l_868[4][1][0];
lbl_997:
    for (p_8 = 2; (p_8 >= 0); p_8 -= 1)
    { /* block id: 584 */
        int64_t l_869 = 1L;
        return l_869;
    }
    for (p_8 = 17; (p_8 < 29); ++p_8)
    { /* block id: 589 */
        const float l_876 = 0x3.4p+1;
        const float *l_875 = &l_876;
        const float **l_874 = &l_875;
        struct S0 *l_889[2];
        struct S0 **l_888 = &l_889[0];
        struct S0 ***l_887 = &l_888;
        int32_t l_894 = 0L;
        const int32_t *l_947[2];
        const int32_t **l_946 = &l_947[0];
        const int32_t ***l_945 = &l_946;
        const int32_t ****l_944 = &l_945;
        int32_t l_965 = 1L;
        uint32_t l_1089 = 0x5142E6EFL;
        const int16_t l_1092 = 0xD379L;
        int i;
        for (i = 0; i < 2; i++)
            l_889[i] = &l_868[1][0][6];
        for (i = 0; i < 2; i++)
            l_947[i] = &l_901;
        for (p_7 = 0; (p_7 != 4); p_7 = safe_add_func_uint16_t_u_u(p_7, 1))
        { /* block id: 592 */
            float *l_877 = (void*)0;
            int32_t l_878 = 0xCC45018CL;
            float l_883 = 0xF.13A9F2p-23;
            struct S0 *l_886 = (void*)0;
            struct S0 **l_885 = &l_886;
            struct S0 ***l_884 = &l_885;
            int32_t *l_895 = &l_878;
            uint32_t l_898 = 0x9861F1EAL;
            int64_t l_913 = 7L;
            l_878 = (l_874 != &l_875);
            (*l_895) = (safe_add_func_uint8_t_u_u((((p_7 | (l_884 != l_887)) < (~(l_868[4][1][0].f0 || (safe_lshift_func_uint16_t_u_u(65535UL, (p_10 < l_878)))))) && l_868[4][1][0].f0), (((((safe_unary_minus_func_uint64_t_u(((((p_10 ^ 0xDB2D0C4BL) < l_894) <= l_868[4][1][0].f0) > p_9))) != p_11) && 0L) < 0x42820ACAL) ^ l_878)));
            for (l_894 = (-16); (l_894 == 24); l_894++)
            { /* block id: 597 */
                int32_t * const l_902 = (void*)0;
                int32_t **l_903 = (void*)0;
                int32_t **l_904 = &l_900[0];
                for (p_11 = 0; (p_11 <= 2); p_11 += 1)
                { /* block id: 600 */
                    if (((-1L) & 0x07L))
                    { /* block id: 601 */
                        return l_898;
                    }
                    else
                    { /* block id: 603 */
                        int32_t **l_899[9] = {&l_895,&l_895,&l_895,&l_895,&l_895,&l_895,&l_895,&l_895,&l_895};
                        int i;
                        l_900[0] = &l_894;
                    }
                }
                (*l_904) = l_902;
            }
            (*l_895) = (safe_add_func_uint64_t_u_u(0x26E4FEAD361A7A16LL, (safe_mod_func_uint32_t_u_u(4294967290UL, (safe_add_func_int16_t_s_s(p_11, (safe_lshift_func_uint8_t_u_s((0x1F7B0BD6L && (*l_895)), l_913))))))));
        }
        /* facts after for loop */
        //assert (l_900[0] == 0 || l_900[0] == &l_894 || l_900[0] == &l_901 || l_900[0] == dangling);
        if (l_914)
            break;
        //assert (l_900[0] == 0 || l_900[0] == &l_901 || l_900[0] == dangling);
        (**l_888) = func_40((l_894 < (p_10 > p_11)), p_10);
        if (((void*)0 == (**l_887)))
        { /* block id: 613 */
            int32_t **l_930 = &l_900[0];
            int32_t ***l_929 = &l_930;
            int32_t ****l_928 = &l_929;
            float * const *l_957 = &l_939;
            const uint16_t l_1025[3] = {8UL,8UL,8UL};
            int64_t l_1027 = 0xDEDBC147875D58A5LL;
            float l_1049 = 0x4.3p+1;
            int16_t l_1077[1];
            struct S0 ****l_1090 = &l_917;
            struct S0 *****l_1112 = &l_1090;
            int32_t **l_1125 = &l_900[3];
            uint32_t l_1157 = 9UL;
            int i;
            for (i = 0; i < 1; i++)
                l_1077[i] = 7L;
            if ((safe_rshift_func_uint16_t_u_u((((void*)0 == l_917) & (safe_unary_minus_func_int8_t_s((p_10 >= (((void*)0 != &l_887) && 0x4EL))))), 4)))
            { /* block id: 614 */
                float l_922 = 0x0.Bp+1;
                float *l_921 = &l_922;
                float * const *l_936[1];
                float * const **l_935 = &l_936[0];
                int32_t l_964 = 0xD1A4A34AL;
                int i;
                for (i = 0; i < 1; i++)
                    l_936[i] = &l_921;
                (*l_921) = p_10;
                if (((safe_lshift_func_int16_t_s_s(((0xF8L <= (l_925 != l_928)) > (safe_sub_func_int16_t_s_s(((safe_rshift_func_uint16_t_u_s((l_935 == l_937[0]), 3)) > (((((safe_add_func_uint64_t_u_u((((void*)0 != &l_925) & (safe_sub_func_int32_t_s_s(((((((void*)0 == &l_938) >= p_7) < p_8) > p_9) && l_894), 9UL))), 0x63100BF3AC69DF69LL)) | 0x84458C2AL) > p_8) < 0UL) <= l_894)), p_8))), 10)) || p_7))
                { /* block id: 616 */
                    int32_t ** const ***l_948 = (void*)0;
                    int32_t *****l_949 = &l_928;
                    (*l_949) = l_944;
                    /* statement id: 617 */
                    assert (l_928 == &l_945);
                    for (l_901 = (-10); (l_901 > (-16)); l_901 = safe_sub_func_uint8_t_u_u(l_901, 3))
                    { /* block id: 620 */
                        int8_t l_952 = 0xF9L;
                        l_952 = 0x76750EF6L;
                    }
                }
                else
                { /* block id: 623 */
                    int32_t l_966 = 0x6E2CF46DL;
                    (***l_935) = ((0x1.4p-1 > (safe_div_func_float_f_f(p_11, p_10))) == (((safe_div_func_float_f_f(((l_957 != (void*)0) != p_7), (safe_add_func_float_f_f((safe_add_func_float_f_f(p_9, (0x1.9F3C73p+44 < (safe_sub_func_float_f_f(((l_964 > p_10) < p_10), l_965))))), l_966)))) != l_966) >= l_966));
                }
                /* facts after branching */
                assert (l_928 == &l_929 || l_928 == &l_945);
            }
            else
            { /* block id: 626 */
                int32_t ****l_971 = (void*)0;
                int32_t l_979[10] = {1L,1L,1L,0x8E21942DL,0x8E21942DL,1L,1L,1L,0x8E21942DL,0x8E21942DL};
                struct S0 l_1050 = {1861};
                float *l_1063 = &l_1049;
                struct S0 l_1065 = {621};
                struct S0 *** const l_1083 = (void*)0;
                int i;
                for (p_11 = 0; (p_11 != 10); ++p_11)
                { /* block id: 629 */
                    int64_t l_987 = (-1L);
                    (**l_929) = func_37((safe_mod_func_uint64_t_u_u((&l_926[8][1] == l_971), ((&l_887 != (void*)0) | (0xBDL != (p_8 != (safe_mod_func_uint8_t_u_u(p_11, (p_11 ^ 7L)))))))));
                    for (l_901 = 9; (l_901 >= 1); l_901 -= 1)
                    { /* block id: 633 */
                        int64_t l_978[7][7] = {{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)},{0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL},{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)},{0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL},{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)},{0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL,0xF7C115EDC41441CBLL},{(-1L),(-1L),(-1L),(-1L),(-1L),(-1L),(-1L)}};
                        int i, j;
                        l_978[4][3] = (safe_add_func_float_f_f(p_11, 0x5.34E79Ap+25));
                        (**l_945) = &p_11;
                        /* statement id: 635 */
                        //assert (l_947[0] == &p_11 || l_947[0] == &l_901);
                        l_979[3] = 0x47E7DCCCL;
                        return p_7;
                    }
                    (***l_928) = func_37((safe_sub_func_uint8_t_u_u((safe_add_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_s((~(0xB7C22F679DC719B9LL & p_8)), ((l_987 | (****l_944)) <= 0x7DC8L))) != (safe_lshift_func_uint8_t_u_s((((l_987 & (((((((safe_sub_func_int32_t_s_s(((((safe_mod_func_int8_t_s_s((***l_945), ((!((safe_mod_func_uint8_t_u_u(6UL, p_11)) | (-1L))) && 0x02620157L))) ^ p_10) <= 3UL) > (-1L)), 0x6E21F338L)) <= 1L) | p_9) >= p_9) || 0x9C58D424L) > 18446744073709551608UL) > p_11)) || 0xA038B8A8627F7DFBLL) < 2L), p_8))), 0x5C7CL)), p_7)));
                }
                if (l_894)
                    goto lbl_997;
                //assert (l_900[0] == 0 || l_900[0] == &l_901 || l_900[0] == dangling);
                for (l_901 = (-24); (l_901 >= 14); ++l_901)
                { /* block id: 644 */
                    int32_t l_1002[9] = {0xA5D4B0CDL,0L,0xA5D4B0CDL,0L,0xA5D4B0CDL,0L,0xA5D4B0CDL,0L,0xA5D4B0CDL};
                    struct S0 *l_1044[4];
                    float ** const *l_1076[3][6][6] = {{{&l_938,&l_938,&l_938,(void*)0,&l_938,&l_938},{&l_938,&l_938,(void*)0,&l_938,(void*)0,&l_938},{&l_938,&l_938,(void*)0,&l_938,&l_938,&l_938},{&l_938,(void*)0,&l_938,(void*)0,&l_938,(void*)0},{&l_938,(void*)0,(void*)0,&l_938,&l_938,(void*)0},{&l_938,&l_938,(void*)0,&l_938,(void*)0,&l_938}},{{&l_938,&l_938,&l_938,&l_938,&l_938,(void*)0},{&l_938,&l_938,&l_938,&l_938,&l_938,&l_938},{(void*)0,&l_938,(void*)0,&l_938,&l_938,(void*)0},{&l_938,&l_938,(void*)0,&l_938,&l_938,(void*)0},{&l_938,(void*)0,&l_938,&l_938,&l_938,&l_938},{&l_938,(void*)0,(void*)0,&l_938,&l_938,&l_938}},{{(void*)0,&l_938,(void*)0,&l_938,&l_938,&l_938},{&l_938,&l_938,&l_938,&l_938,&l_938,&l_938},{&l_938,&l_938,&l_938,&l_938,&l_938,&l_938},{&l_938,(void*)0,&l_938,&l_938,&l_938,&l_938},{&l_938,(void*)0,&l_938,(void*)0,&l_938,&l_938},{&l_938,&l_938,&l_938,&l_938,&l_938,&l_938}}};
                    struct S0 ***l_1078 = &l_888;
                    int i, j, k;
                    for (i = 0; i < 4; i++)
                        l_1044[i] = &l_868[4][1][0];
                }
                l_965 = (safe_sub_func_uint16_t_u_u(((((void*)0 == l_1083) || p_9) || ((void*)0 != &l_888)), (l_1050.f0 || p_7)));
            }
            /* facts after branching */
            assert (l_928 == &l_929 || l_928 == &l_945);
            for (l_965 = 0; (l_965 >= 6); l_965++)
            { /* block id: 677 */
                int16_t l_1106 = 0xFE5DL;
            }
            if (((p_7 <= p_11) >= (safe_div_func_int16_t_s_s(p_9, (safe_add_func_uint16_t_u_u(p_10, ((safe_div_func_int64_t_s_s(((p_11 ^ (safe_div_func_int32_t_s_s(p_9, p_9))) && 0L), p_7)) < p_7)))))))
            { /* block id: 698 */
                float l_1123 = 0x0.Cp+1;
                int32_t l_1140 = 0x4C7CA6A4L;
                uint8_t l_1147 = 1UL;
                struct S0 **l_1156[5];
                int i;
                for (i = 0; i < 5; i++)
                    l_1156[i] = &l_889[1];
                if (((p_9 < ((0UL <= ((*l_946) != (void*)0)) || p_11)) != p_8))
                { /* block id: 699 */
                    const struct S0 l_1124 = {1618};
                    for (l_965 = 3; (l_965 <= 9); l_965 += 1)
                    { /* block id: 702 */
                        p_11 = p_11;
                        (**l_888) = l_1124;
                        (**l_945) = func_37((0xC4L < p_9));
                    }
                    /* facts after for loop */
                    //assert (l_947[0] == 0 || l_947[0] == &l_901);
                }
                else
                { /* block id: 707 */
                    int16_t l_1132[3][1];
                    int i, j;
                    for (i = 0; i < 3; i++)
                    {
                        for (j = 0; j < 1; j++)
                            l_1132[i][j] = (-1L);
                    }
                    (*l_946) = &p_11;
                    /* statement id: 708 */
                    //assert (l_947[0] == &p_11 || l_947[0] == &l_901);
                    (*l_929) = l_1125;
                    for (p_10 = 19; (p_10 != 11); p_10 = safe_sub_func_uint64_t_u_u(p_10, 8))
                    { /* block id: 712 */
                        struct S0 ** const *l_1135 = (void*)0;
                        struct S0 ** const **l_1134[6] = {&l_1135,&l_1135,&l_1135,&l_1135,&l_1135,&l_1135};
                        struct S0 ** const ***l_1133[10][6][4] = {{{&l_1134[2],&l_1134[5],(void*)0,&l_1134[5]},{&l_1134[0],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[2],&l_1134[1],&l_1134[5],&l_1134[5]},{&l_1134[5],(void*)0,&l_1134[2],&l_1134[0]},{(void*)0,&l_1134[5],&l_1134[5],&l_1134[0]},{&l_1134[4],&l_1134[5],&l_1134[1],&l_1134[1]}},{{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[1],&l_1134[4],&l_1134[5]},{&l_1134[5],&l_1134[2],&l_1134[5],&l_1134[2]},{&l_1134[1],&l_1134[4],&l_1134[5],&l_1134[2]},{&l_1134[5],&l_1134[2],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[1],&l_1134[0],&l_1134[5]}},{{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[1]},{&l_1134[5],&l_1134[5],(void*)0,&l_1134[0]},{&l_1134[4],&l_1134[5],&l_1134[2],&l_1134[0]},{&l_1134[5],(void*)0,&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[1],&l_1134[5],&l_1134[5]},{(void*)0,&l_1134[5],(void*)0,&l_1134[5]}},{{&l_1134[5],&l_1134[5],&l_1134[2],(void*)0},{&l_1134[0],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{(void*)0,&l_1134[0],&l_1134[5],(void*)0},{&l_1134[5],&l_1134[5],(void*)0,&l_1134[2]},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[2]}},{{&l_1134[1],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[2],&l_1134[2],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[2],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[1],&l_1134[5],&l_1134[5],(void*)0},{&l_1134[5],(void*)0,(void*)0,&l_1134[4]}},{{&l_1134[5],&l_1134[5],&l_1134[5],(void*)0},{(void*)0,&l_1134[5],&l_1134[5],&l_1134[4]},{&l_1134[5],&l_1134[5],&l_1134[5],(void*)0},{&l_1134[0],&l_1134[0],&l_1134[2],&l_1134[5]},{&l_1134[5],&l_1134[5],(void*)0,&l_1134[4]},{(void*)0,&l_1134[5],&l_1134[5],&l_1134[5]}},{{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[2],&l_1134[5]},{&l_1134[4],&l_1134[5],(void*)0,&l_1134[5]},{&l_1134[5],&l_1134[2],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[0],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[1]}},{{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[1],&l_1134[5],&l_1134[5],&l_1134[1]},{&l_1134[5],&l_1134[5],&l_1134[4],&l_1134[5]},{&l_1134[5],&l_1134[4],(void*)0,&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[2],&l_1134[1]}},{{&l_1134[2],&l_1134[5],&l_1134[5],&l_1134[5]},{(void*)0,(void*)0,&l_1134[5],&l_1134[2]},{&l_1134[5],&l_1134[0],&l_1134[1],&l_1134[5]},{&l_1134[5],&l_1134[5],&l_1134[2],&l_1134[5]},{(void*)0,&l_1134[5],&l_1134[0],(void*)0},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[2]}},{{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[4]},{(void*)0,&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[2],(void*)0,&l_1134[4],(void*)0},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[1]},{&l_1134[5],&l_1134[5],&l_1134[5],&l_1134[5]},{&l_1134[5],(void*)0,&l_1134[5],&l_1134[2]}}};
                        int i, j, k;
                        l_894 = ((safe_lshift_func_int8_t_s_u(((safe_sub_func_uint16_t_u_u((((l_1132[0][0] < (p_7 && 0xB8D2L)) || (l_1133[1][0][1] != l_1111)) | (**l_946)), (((-1L) && (safe_lshift_func_int8_t_s_s(l_1132[2][0], 7))) | ((p_10 && p_10) && 1UL)))) & l_1132[1][0]), 7)) && p_10);
                        if (p_8)
                            goto lbl_997;
                        //assert (l_900[0] == 0 || l_900[0] == &l_901 || l_900[0] == dangling);
                        (***l_944) = &p_11;
                        (*l_1112) = &l_887;
                        /* statement id: 716 */
                        assert (l_1090 == &l_887);
                    }
                    /* facts after for loop */
                    assert (l_1090 == &l_887 || l_1090 == &l_917);
                }
                /* facts after branching */
                //assert (l_947[0] == &p_11 || l_947[0] == &l_901 || l_947[0] == 0);
                assert (l_1090 == &l_887 || l_1090 == &l_917);
                for (p_7 = 14; (p_7 == 5); --p_7)
                { /* block id: 721 */
                    int64_t l_1148 = 0x6BB3EE980E1E0BB8LL;
                    if ((((p_8 || l_1140) >= (((((safe_add_func_int8_t_s_s((((*l_929) == (void*)0) || (0UL || ((p_8 | (safe_rshift_func_int8_t_s_u(((((safe_div_func_uint8_t_u_u(p_7, l_1140)) < p_7) || 0xBE58L) <= p_8), 6))) | (-7L)))), p_11)) != 0xB293L) | p_9) || l_1147) & p_7)) && 1UL))
                    { /* block id: 722 */
                        (***l_928) = &l_1140;
                        (*l_888) = (*l_888);
                    }
                    else
                    { /* block id: 725 */
                        return p_9;
                    }
                    if (l_1148)
                        break;
                }
                /* facts after for loop */
                //assert (l_900[0] == &l_1140 || l_900[0] == 0 || l_900[0] == &l_894 || l_900[0] == &l_901 || l_900[0] == dangling);
                //assert (l_947[0] == &l_1140 || l_947[0] == &p_11 || l_947[0] == &l_901 || l_947[0] == 0);
                if (((safe_rshift_func_uint8_t_u_s((~((((safe_mod_func_uint64_t_u_u(p_10, (safe_sub_func_int64_t_s_s(1L, 7UL)))) | ((((*l_887) == l_1156[4]) != l_1140) == l_1157)) >= ((safe_rshift_func_int16_t_s_s(0x4580L, 13)) != ((safe_div_func_uint32_t_u_u(((p_11 == p_7) | 9L), (-2L))) == 0xEDL))) == p_10)), 3)) & 1L))
                { /* block id: 730 */
                    float ***l_1166 = &l_938;
                    struct S0 ***l_1169 = (void*)0;
                    int32_t ***l_1170 = &l_1125;
                    l_894 = (safe_sub_func_float_f_f(p_11, (safe_div_func_float_f_f(((l_1166 == &l_957) >= (safe_sub_func_float_f_f((((void*)0 != l_1169) > (l_1170 == (*l_928))), ((0xF.CCC8CFp-54 <= (safe_sub_func_float_f_f(p_7, p_9))) < p_10)))), p_7))));
                    for (l_1089 = 0; (l_1089 == 23); ++l_1089)
                    { /* block id: 734 */
                        struct S0 l_1175 = {1859};
                        (***l_887) = l_1175;
                    }
                }
                else
                { /* block id: 737 */
                    p_11 = (safe_unary_minus_func_uint16_t_u((&l_957 != &l_874)));
                    (**l_945) = (void*)0;
                }
                if (l_965)
                    goto lbl_997;
                //assert (l_900[0] == 0 || l_900[0] == &l_901 || l_900[0] == dangling);
            }
            else
            { /* block id: 742 */
                struct S0 l_1179 = {1232};
                for (l_901 = 0; (l_901 != 6); ++l_901)
                { /* block id: 745 */
                    (*l_946) = (void*)0;
                }
                /* facts after for loop */
                //assert (l_947[0] == 0 || l_947[0] == &l_901);
                (**l_888) = l_1179;
            }
            /* facts after branching */
            //assert (l_947[0] == dangling || l_947[0] == &p_11 || l_947[0] == &l_901 || l_947[0] == 0);
            assert (l_1090 == &l_887 || l_1090 == &l_917);
            l_1180 = &l_929;
            /* statement id: 750 */
            assert (l_1180 == &l_929);
        }
        else
        { /* block id: 751 */
            int16_t l_1184[9] = {(-1L),(-3L),(-3L),(-1L),(-3L),(-3L),(-1L),(-3L),(-3L)};
            struct S0 *** const l_1191[8] = {(void*)0,&l_888,&l_888,(void*)0,&l_888,&l_888,(void*)0,&l_888};
            int i;
            for (l_965 = 0; (l_965 < 2); l_965 = safe_add_func_uint64_t_u_u(l_965, 5))
            { /* block id: 754 */
                return l_1184[5];
            }
            (*l_946) = func_37(((safe_lshift_func_int16_t_s_s((((safe_mod_func_uint32_t_u_u((****l_944), 4UL)) ^ (safe_lshift_func_uint8_t_u_s(0x67L, 1))) | ((p_11 <= (((l_1191[2] == (void*)0) <= (safe_lshift_func_int8_t_s_s((((safe_sub_func_int16_t_s_s(0xAFB5L, ((void*)0 == l_1191[2]))) != p_11) || 0xB155L), 3))) || p_7)) >= p_8)), 10)) && p_9));
            /* statement id: 757 */
            //assert (l_947[0] == 0 || l_947[0] == &l_901);
            if (l_1184[6])
                continue;
            //assert (l_900[0] == 0 || l_900[0] == &l_901 || l_900[0] == dangling);
        }
        /* facts after branching */
        //assert (l_947[0] == dangling || l_947[0] == &p_11 || l_947[0] == &l_901 || l_947[0] == 0);
    }
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_12(uint32_t  p_13)
{ /* block id: 1 */
    int64_t l_21 = (-1L);
    uint16_t l_22 = 65529UL;
    int32_t l_837 = 0xA95F48C9L;
    struct S0 l_838 = {1876};
    float ***l_850 = (void*)0;
    int32_t *l_857 = &l_837;
    for (p_13 = 0; (p_13 > 56); p_13 = safe_add_func_int16_t_s_s(p_13, 3))
    { /* block id: 4 */
        int32_t l_36 = 0L;
        struct S0 *l_839 = &l_838;
        l_837 = (safe_div_func_int32_t_s_s((safe_div_func_int8_t_s_s(l_21, l_22)), (((l_21 & (-8L)) == (((func_25((((safe_sub_func_int32_t_s_s((safe_rshift_func_int16_t_s_u(p_13, 7)), p_13)) ^ ((safe_sub_func_int16_t_s_s((l_36 < l_36), 8L)) != 0x2C4DF8E3BF118C84LL)) | 0L), p_13, l_21, p_13) != (-4L)) | 0x9CE753B2C59FA5E5LL) ^ 0L)) | l_21)));
        (*l_839) = l_838;
        return p_13;
    }
    (*l_857) = (safe_add_func_int32_t_s_s(l_837, ((p_13 ^ (l_22 && (((((((safe_rshift_func_uint8_t_u_u(0xD6L, 1)) >= (safe_mod_func_uint32_t_u_u(4294967295UL, (safe_add_func_int8_t_s_s((-1L), (safe_div_func_int64_t_s_s(((void*)0 == l_850), (safe_add_func_int8_t_s_s((safe_add_func_uint64_t_u_u(((safe_div_func_uint8_t_u_u((0xBB49L && p_13), p_13)) | p_13), l_838.f0)), p_13))))))))) & l_837) >= p_13) > p_13) > 255UL) <= 0L))) == p_13)));
    return p_13;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_25(uint8_t  p_26, int64_t  p_27, int64_t  p_28, int8_t  p_29)
{ /* block id: 5 */
    uint8_t l_39 = 0x37L;
    int32_t l_836 = 0x6883A3A3L;
    int32_t *l_835 = &l_836;
    int32_t **l_834 = &l_835;
    (*l_834) = func_37(l_39);
    /* statement id: 572 */
    assert (l_835 == 0);
    return p_26;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_37(int8_t  p_38)
{ /* block id: 6 */
    int32_t l_60 = 0x53A81F6EL;
    int32_t * const l_59[4] = {&l_60,&l_60,&l_60,&l_60};
    int8_t l_301 = 0xC5L;
    const int32_t *l_302 = (void*)0;
    int32_t *l_303 = (void*)0;
    struct S0 l_812 = {743};
    struct S0 *l_811 = &l_812;
    int8_t l_813 = 0x16L;
    float l_815 = (-0x5.9p-1);
    float *l_814 = &l_815;
    float l_827 = 0x9.8CC170p+87;
    int32_t **l_832 = &l_303;
    int32_t *l_833 = (void*)0;
    int i;
    (*l_811) = func_40(func_43((safe_div_func_float_f_f(0xF.A7AB5Bp-61, ((p_38 >= func_48(p_38, (safe_sub_func_uint16_t_u_u((((p_38 && func_56(l_59[0], p_38)) || p_38) != (((safe_mod_func_uint64_t_u_u((safe_mod_func_uint32_t_u_u(((p_38 < 0x4A71L) & p_38), p_38)), l_301)) && p_38) && p_38)), 1L)), l_302, l_303, p_38)) <= p_38))), p_38), p_38);
    (*l_814) = l_813;
    (*l_814) = (safe_div_func_float_f_f((((safe_div_func_float_f_f(((safe_sub_func_float_f_f(0x7.2p-1, (-(0x7.AF9D10p-90 < (safe_add_func_float_f_f(p_38, (safe_div_func_float_f_f((&l_59[2] == &l_302), p_38)))))))) <= l_827), (((-(0x9.91B4D8p+92 == (-(safe_add_func_float_f_f(0x6.22589Fp-26, 0x9.735333p+8))))) != p_38) > p_38))) != 0x6.C5491Cp+29) != 0xC.DF44BCp-82), 0xE.36E9C2p+42));
    (*l_832) = &l_60;
    /* statement id: 570 */
    assert (l_303 == &l_60);
    return l_833;
    /* statement id: 571 */
    //assert (func_37_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_40(uint32_t  p_41, const uint64_t  p_42)
{ /* block id: 336 */
    struct S0 l_550[7][9] = {{{1451},{689},{13},{1214},{969},{969},{1214},{13},{689}},{{969},{1942},{1324},{1767},{1803},{689},{1198},{1198},{689}},{{1767},{13},{683},{13},{1767},{1942},{1093},{1324},{1214}},{{1093},{1942},{1767},{13},{683},{13},{1767},{1942},{1093}},{{1198},{689},{1803},{1767},{1324},{1942},{969},{1942},{1324}},{{1214},{969},{969},{1214},{13},{689},{1451},{1324},{1803}},{{1198},{1324},{969},{190},{190},{969},{1324},{1198},{683}}};
    struct S0 *l_551[9];
    struct S0 l_552 = {494};
    const float l_559 = 0x1.Bp-1;
    const float *l_558 = &l_559;
    const float ** const l_557 = &l_558;
    int32_t l_585[8][6] = {{0L,0L,0x9CC59AECL,0xDB6751E6L,0xF6EA48A7L,0xF6EA48A7L},{0L,0xDB6751E6L,0xDB6751E6L,0L,0xF6EA48A7L,0x9CC59AECL},{0xF6EA48A7L,0L,0xDB6751E6L,0xDB6751E6L,0L,0xF6EA48A7L},{0xF6EA48A7L,0xDB6751E6L,0x9CC59AECL,0L,0L,0x9CC59AECL},{0L,0L,0x9CC59AECL,0xDB6751E6L,0xF6EA48A7L,0xF6EA48A7L},{0L,0xDB6751E6L,0xDB6751E6L,0L,0xF6EA48A7L,0x9CC59AECL},{0xF6EA48A7L,0L,0xDB6751E6L,0xDB6751E6L,0L,0xF6EA48A7L},{0xF6EA48A7L,0xDB6751E6L,0x9CC59AECL,0L,0L,0x9CC59AECL}};
    int32_t *l_584[1][4][9] = {{{&l_585[0][0],(void*)0,&l_585[0][0],(void*)0,(void*)0,&l_585[0][0],(void*)0,&l_585[0][0],(void*)0},{&l_585[1][3],(void*)0,&l_585[0][0],&l_585[0][0],(void*)0,&l_585[1][3],(void*)0,&l_585[1][3],(void*)0},{&l_585[1][3],(void*)0,(void*)0,&l_585[1][3],&l_585[0][0],(void*)0,&l_585[0][0],&l_585[1][3],(void*)0},{&l_585[0][0],&l_585[0][0],(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&l_585[0][0],&l_585[0][0]}}};
    int32_t *l_605 = &l_585[3][3];
    uint32_t l_656 = 4294967295UL;
    struct S0 ** const l_795 = (void*)0;
    struct S0 ** const *l_794[8][6][5] = {{{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,(void*)0},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795}},{{&l_795,&l_795,&l_795,&l_795,(void*)0},{(void*)0,(void*)0,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,(void*)0,(void*)0},{&l_795,(void*)0,&l_795,(void*)0,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795}},{{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,(void*)0,&l_795,(void*)0,&l_795},{&l_795,&l_795,&l_795,(void*)0,&l_795},{&l_795,&l_795,&l_795,&l_795,(void*)0},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795}},{{&l_795,&l_795,(void*)0,&l_795,&l_795},{(void*)0,&l_795,&l_795,&l_795,&l_795},{(void*)0,&l_795,&l_795,&l_795,&l_795},{(void*)0,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,(void*)0},{&l_795,&l_795,&l_795,&l_795,&l_795}},{{&l_795,(void*)0,(void*)0,&l_795,(void*)0},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,(void*)0,&l_795},{&l_795,&l_795,&l_795,(void*)0,(void*)0},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795}},{{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,(void*)0,&l_795,&l_795,&l_795},{(void*)0,&l_795,&l_795,&l_795,&l_795},{(void*)0,&l_795,&l_795,&l_795,(void*)0},{&l_795,(void*)0,&l_795,&l_795,(void*)0}},{{&l_795,&l_795,&l_795,(void*)0,(void*)0},{&l_795,&l_795,&l_795,(void*)0,(void*)0},{&l_795,(void*)0,&l_795,&l_795,(void*)0},{(void*)0,&l_795,&l_795,&l_795,&l_795},{(void*)0,&l_795,&l_795,&l_795,&l_795},{&l_795,(void*)0,&l_795,&l_795,&l_795}},{{(void*)0,&l_795,&l_795,(void*)0,&l_795},{(void*)0,&l_795,&l_795,&l_795,&l_795},{&l_795,(void*)0,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795},{&l_795,(void*)0,&l_795,&l_795,&l_795},{&l_795,&l_795,&l_795,&l_795,&l_795}}};
    struct S0 l_810 = {972};
    int i, j, k;
    for (i = 0; i < 9; i++)
        l_551[i] = &l_550[2][2];
    l_552 = l_550[1][8];
    return l_810;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_43(float  p_44, int32_t  p_45)
{ /* block id: 332 */
    float l_546 = 0x0.4p+1;
    float *l_545[7][5][7] = {{{&l_546,&l_546,(void*)0,&l_546,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{(void*)0,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{(void*)0,(void*)0,&l_546,&l_546,&l_546,&l_546,&l_546}},{{&l_546,(void*)0,&l_546,&l_546,(void*)0,&l_546,(void*)0},{&l_546,(void*)0,&l_546,&l_546,&l_546,(void*)0,&l_546},{(void*)0,&l_546,&l_546,&l_546,&l_546,(void*)0,&l_546},{&l_546,&l_546,&l_546,(void*)0,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,(void*)0}},{{&l_546,&l_546,&l_546,&l_546,&l_546,(void*)0,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,(void*)0,(void*)0},{&l_546,&l_546,&l_546,(void*)0,(void*)0,&l_546,&l_546}},{{&l_546,(void*)0,&l_546,&l_546,&l_546,(void*)0,&l_546},{&l_546,&l_546,&l_546,&l_546,(void*)0,&l_546,(void*)0},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,(void*)0,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,&l_546,(void*)0,&l_546,(void*)0,&l_546,(void*)0}},{{&l_546,(void*)0,(void*)0,&l_546,&l_546,&l_546,&l_546},{(void*)0,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{(void*)0,(void*)0,(void*)0,&l_546,&l_546,&l_546,(void*)0},{&l_546,&l_546,&l_546,(void*)0,&l_546,&l_546,&l_546}},{{&l_546,&l_546,&l_546,(void*)0,&l_546,&l_546,&l_546},{(void*)0,&l_546,&l_546,&l_546,&l_546,&l_546,(void*)0},{&l_546,&l_546,&l_546,&l_546,&l_546,&l_546,&l_546},{&l_546,(void*)0,&l_546,(void*)0,&l_546,&l_546,&l_546},{(void*)0,&l_546,&l_546,&l_546,(void*)0,&l_546,&l_546}},{{(void*)0,&l_546,&l_546,(void*)0,&l_546,&l_546,(void*)0},{(void*)0,&l_546,(void*)0,(void*)0,&l_546,&l_546,&l_546},{&l_546,&l_546,&l_546,&l_546,(void*)0,&l_546,(void*)0},{&l_546,(void*)0,&l_546,&l_546,&l_546,&l_546,(void*)0},{(void*)0,&l_546,(void*)0,&l_546,&l_546,&l_546,&l_546}}};
    int32_t l_548 = 0x2F64861AL;
    int32_t *l_547 = &l_548;
    int32_t **l_549 = &l_547;
    int i, j, k;
    (*l_547) = (safe_rshift_func_uint8_t_u_u(((void*)0 != l_545[0][4][2]), (&l_545[0][4][2] == &l_545[4][1][5])));
    (*l_549) = &p_45;
    /* statement id: 334 */
    assert (l_547 == &p_45);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_48(uint64_t  p_49, int32_t  p_50, const int32_t * p_51, int32_t * p_52, const int32_t  p_53)
{ /* block id: 162 */
    struct S0 l_310 = {415};
    const struct S0 *l_309 = &l_310;
    int32_t l_320 = 9L;
    int32_t *l_319 = &l_320;
    int32_t * const *l_338[10] = {&l_319,&l_319,&l_319,&l_319,&l_319,&l_319,&l_319,&l_319,&l_319,&l_319};
    int32_t * const **l_337 = &l_338[9];
    uint8_t l_391[6] = {1UL,0xEEL,0xEEL,1UL,0xEEL,0xEEL};
    float l_406[9][1][4] = {{{0x7.09F6C4p+75,(-0x1.Ap-1),0xD.F951FFp+27,0x7.09F6C4p+75}},{{0xD.F951FFp+27,0x7.09F6C4p+75,0x9.3A6EA5p+10,0x9.3A6EA5p+10}},{{(-0x3.9p+1),(-0x3.9p+1),(-0x1.Ep-1),0x1.3492D3p+54}},{{(-0x3.9p+1),(-0x1.Ap-1),0x9.3A6EA5p+10,(-0x3.9p+1)}},{{0xD.F951FFp+27,0x1.3492D3p+54,0xD.F951FFp+27,0x9.3A6EA5p+10}},{{0x7.09F6C4p+75,0x1.3492D3p+54,(-0x1.Ep-1),(-0x3.9p+1)}},{{0x1.3492D3p+54,(-0x1.Ap-1),(-0x1.Ap-1),0x1.3492D3p+54}},{{0xD.F951FFp+27,(-0x3.9p+1),(-0x1.Ap-1),0x9.3A6EA5p+10}},{{0x1.3492D3p+54,0x7.09F6C4p+75,(-0x3.9p+1),0x9.3A6EA5p+10}}};
    float *l_405 = &l_406[3][0][2];
    float **l_404[1];
    uint32_t l_408 = 4294967290UL;
    int32_t l_419 = (-4L);
    struct S0 l_422 = {1093};
    struct S0 l_430 = {932};
    const int32_t *l_490[7][4] = {{&l_320,&l_320,&l_320,&l_320},{&l_320,&l_320,&l_320,&l_320},{&l_320,&l_320,&l_320,&l_320},{&l_320,&l_320,&l_320,&l_320},{&l_320,&l_320,&l_320,&l_320},{&l_320,&l_320,&l_320,&l_320},{&l_320,&l_320,&l_320,&l_320}};
    const int32_t **l_489 = &l_490[6][1];
    struct S0 *l_512 = &l_430;
    struct S0 **l_511 = &l_512;
    struct S0 ***l_510 = &l_511;
    int8_t l_540 = 0L;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_404[i] = &l_405;
    for (p_50 = (-6); (p_50 != (-8)); --p_50)
    { /* block id: 165 */
        uint64_t l_313 = 9UL;
        int32_t *l_322 = &l_320;
        int32_t **l_336 = &l_322;
        int32_t *** const l_335 = &l_336;
        struct S0 **l_357 = (void*)0;
        struct S0 l_376 = {314};
        int64_t l_412 = 0L;
        int32_t l_471 = 6L;
    }
    for (l_320 = 22; (l_320 < (-20)); l_320 = safe_sub_func_uint32_t_u_u(l_320, 1))
    { /* block id: 275 */
        float l_477 = 0x9.C669DCp+78;
        int32_t l_481[7] = {(-1L),(-7L),(-1L),(-1L),(-7L),(-1L),(-1L)};
        int32_t l_542 = 0xE0248A9DL;
        int i;
        if ((&p_53 == (void*)0))
        { /* block id: 276 */
            uint32_t l_479 = 0xADC9CFD1L;
            struct S0 *l_495 = &l_422;
            struct S0 **l_494 = &l_495;
            int32_t *l_541[9] = {&l_481[4],&l_481[4],&l_481[4],&l_481[4],&l_481[4],&l_481[4],&l_481[4],&l_481[4],&l_481[4]};
            int i;
            for (p_50 = 0; (p_50 <= 2); p_50 = safe_add_func_int32_t_s_s(p_50, 1))
            { /* block id: 279 */
                uint8_t l_476 = 0x9EL;
                int32_t l_478 = 0x948B8E69L;
                struct S0 l_507 = {1878};
                struct S0 ***l_537 = &l_494;
                l_478 = l_476;
                if (l_479)
                { /* block id: 281 */
                    uint32_t l_480 = 0x2C46A3FAL;
                    if (l_480)
                        break;
                }
                else
                { /* block id: 283 */
                    int8_t l_485 = 7L;
                    int32_t l_486 = 0xD09BE0D3L;
                    l_481[4] = l_476;
                    l_486 = (~(safe_add_func_int64_t_s_s((l_485 & 8UL), p_53)));
                }
                if ((safe_lshift_func_int16_t_s_u(l_476, 9)))
                { /* block id: 287 */
                    l_489 = &p_51;
                    /* statement id: 288 */
                    assert (l_489 == &p_51);
                }
                else
                { /* block id: 289 */
                    int64_t l_496[5][8] = {{1L,0x6B654F81EF61D4E5LL,0x35CB5F3D0070319FLL,0x5E3FE5A805700612LL,(-1L),6L,6L,(-1L)},{1L,0xBCF8AA51B17D30F8LL,0xBCF8AA51B17D30F8LL,1L,6L,0x5E3FE5A805700612LL,0L,(-1L)},{0L,0x3F69C20DDC43A81BLL,0x5E3FE5A805700612LL,0xC5373F0FC6BAD358LL,0xBCF8AA51B17D30F8LL,0x661F5DA5AEA25472LL,(-1L),0x661F5DA5AEA25472LL},{0xD2C5EDC73D433844LL,0x3F69C20DDC43A81BLL,0L,0x3F69C20DDC43A81BLL,0xD2C5EDC73D433844LL,0x5E3FE5A805700612LL,1L,(-9L)},{0x5E3FE5A805700612LL,0xBCF8AA51B17D30F8LL,0xD2C5EDC73D433844LL,1L,0x7F0CCF32BF1DC6E4LL,6L,0x3F69C20DDC43A81BLL,0x3F69C20DDC43A81BLL}};
                    int i, j;
                    (*l_405) = 0x1.155307p-70;
                    if (((+((safe_mod_func_int16_t_s_s(((l_494 == (void*)0) | (8UL >= (((l_496[1][5] & l_481[0]) <= ((safe_sub_func_uint64_t_u_u(1UL, (safe_sub_func_uint8_t_u_u((((safe_lshift_func_uint16_t_u_s((((0x8FC810B0F55A41C6LL <= ((safe_rshift_func_int8_t_s_s((safe_rshift_func_int8_t_s_s((l_479 != l_478), 4)), l_476)) & p_50)) | p_53) == p_50), l_479)) & (-4L)) < p_49), p_50)))) || 1UL)) > l_481[2]))), l_481[4])) | l_478)) < p_53))
                    { /* block id: 291 */
                        struct S0 ***l_509 = &l_494;
                        struct S0 ****l_508[7][2] = {{&l_509,&l_509},{&l_509,&l_509},{&l_509,&l_509},{&l_509,&l_509},{&l_509,&l_509},{&l_509,&l_509},{&l_509,&l_509}};
                        int i, j;
                        (**l_494) = l_507;
                        l_510 = (void*)0;
                        /* statement id: 293 */
                        assert (l_510 == 0);
                        if ((*l_319))
                            break;
                        return p_53;
                    }
                    else
                    { /* block id: 296 */
                        (*l_489) = (void*)0;
                        (*l_489) = (void*)0;
                        (*l_512) = (**l_494);
                    }
                    if (l_479)
                        break;
                    if (p_49)
                        break;
                }
                if ((((&l_494 == (void*)0) >= ((safe_add_func_uint8_t_u_u((((safe_add_func_int64_t_s_s((((l_481[4] & (((safe_lshift_func_uint8_t_u_s((safe_div_func_uint64_t_u_u(((safe_mod_func_uint32_t_u_u((((0x3E06L == ((l_478 && p_49) > 0x36D73A02E538EF27LL)) != 0xC0FCL) && (safe_mod_func_int8_t_s_s((***l_337), 0xD6L))), 0x1B9C6BC0L)) || p_53), l_481[6])), l_479)) || 0x5CL) | p_50)) && 0UL) != p_49), l_507.f0)) != 0x8AAA3B37L) | p_53), 0x8DL)) > l_507.f0)) != p_50))
                { /* block id: 304 */
                    if (l_479)
                        break;
                    (*l_495) = (***l_510);
                    (*l_489) = &p_53;
                    (*l_489) = (void*)0;
                }
                else
                { /* block id: 309 */
                    const int32_t l_539 = 0x3B3733C0L;
                    for (l_476 = 0; (l_476 >= 39); l_476 = safe_add_func_int32_t_s_s(l_476, 1))
                    { /* block id: 312 */
                        uint64_t l_533 = 0xB37981BCEC03A269LL;
                        struct S0 *l_538 = &l_310;
                        (*l_489) = &l_478;
                        /* statement id: 313 */
                        //assert (p_51 == &l_478 || p_51 == dangling || p_51 == 0 || p_51 == &p_53);
                        //assert (l_490[0][0] == &l_478 || l_490[0][0] == dangling || l_490[0][0] == 0 || l_490[0][0] == &l_320 || l_490[0][0] == &p_53);
                        (*l_405) = (safe_add_func_float_f_f(((((safe_div_func_float_f_f((l_533 >= 0x5.8p-1), (+(safe_div_func_float_f_f((l_537 != (void*)0), 0x8.8p+1))))) <= ((l_538 != (**l_537)) < (p_53 == 0x1.0p+1))) >= (-0x1.7p-1)) != p_50), l_539));
                        if (l_507.f0)
                            break;
                        return l_476;
                    }
                    /* facts after for loop */
                    //assert (p_51 == &l_478 || p_51 == dangling || p_51 == 0 || p_51 == &p_53);
                    //assert (l_490[0][0] == &l_478 || l_490[0][0] == dangling || l_490[0][0] == 0 || l_490[0][0] == &l_320 || l_490[0][0] == &p_53);
                }
                /* facts after branching */
                //assert (p_51 == &l_478 || p_51 == dangling || p_51 == 0 || p_51 == &p_53);
                //assert (l_490[0][0] == &l_478 || l_490[0][0] == dangling || l_490[0][0] == 0 || l_490[0][0] == &l_320 || l_490[0][0] == &p_53);
            }
            /* facts after for loop */
            //assert (p_51 == dangling || p_51 == 0 || p_51 == &p_53);
            //assert (l_490[0][0] == dangling || l_490[0][0] == 0 || l_490[0][0] == &l_320 || l_490[0][0] == &p_53);
            assert ((l_489 >= &l_490[0][0] && l_489 <= &l_490[6][3]) || l_489 == &p_51);
            assert (l_510 == 0 || l_510 == &l_511);
            l_542 = (l_540 <= (&l_481[1] == l_541[6]));
            for (l_419 = 1; (l_419 <= 6); l_419 += 1)
            { /* block id: 323 */
                int i;
                l_481[l_419] = (0x7A3FL | l_481[l_419]);
            }
            return l_542;
        }
        else
        { /* block id: 327 */
            return p_53;
        }
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_56(int32_t * const  p_57, float  p_58)
{ /* block id: 7 */
    uint32_t l_61[4] = {0UL,0UL,0UL,0UL};
    int32_t l_87 = 1L;
    int32_t *l_86[3][8][8] = {{{&l_87,&l_87,&l_87,&l_87,&l_87,(void*)0,&l_87,&l_87},{(void*)0,(void*)0,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,(void*)0,&l_87,&l_87,&l_87,&l_87,&l_87,(void*)0},{&l_87,&l_87,(void*)0,&l_87,(void*)0,&l_87,&l_87,&l_87},{&l_87,(void*)0,(void*)0,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,(void*)0,&l_87,(void*)0,(void*)0}},{{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,(void*)0,&l_87,&l_87,&l_87,(void*)0,&l_87},{&l_87,&l_87,&l_87,(void*)0,&l_87,&l_87,(void*)0,&l_87},{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,(void*)0,&l_87,&l_87,&l_87},{&l_87,(void*)0,&l_87,&l_87,&l_87,(void*)0,(void*)0,&l_87},{&l_87,&l_87,&l_87,&l_87,(void*)0,&l_87,&l_87,&l_87}},{{&l_87,(void*)0,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{&l_87,(void*)0,&l_87,(void*)0,&l_87,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,&l_87,(void*)0,(void*)0,(void*)0},{&l_87,(void*)0,&l_87,&l_87,(void*)0,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,(void*)0,&l_87,&l_87,&l_87},{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87},{(void*)0,&l_87,&l_87,&l_87,&l_87,&l_87,(void*)0,(void*)0},{&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87,&l_87}}};
    struct S0 l_109 = {1858};
    uint64_t l_203 = 0xA8AF15EAAFD92582LL;
    uint32_t l_204 = 0x4FEF38ABL;
    uint16_t l_212 = 1UL;
    int16_t l_217 = 0x7383L;
    uint32_t l_218 = 0x26D7F8DAL;
    uint32_t l_219 = 0x7F72D5D3L;
    int16_t l_220 = 0x575BL;
    uint64_t l_221 = 0x2626586A66762014LL;
    int16_t l_222 = 0xFDE0L;
    int16_t l_223 = 4L;
    uint8_t l_224[2][7][6] = {{{0UL,255UL,0xF9L,0x53L,0xD4L,0x53L},{9UL,0x53L,9UL,0x4FL,0x3DL,255UL},{0x4FL,0x3DL,255UL,0UL,0xA3L,0UL},{248UL,255UL,0xA7L,0UL,0x4FL,0x4FL},{0x4FL,255UL,255UL,0x4FL,255UL,0x2FL},{9UL,248UL,0UL,0x53L,0xA7L,0xF9L},{0UL,0UL,0xD4L,0x5DL,0xA7L,0x3DL}},{{255UL,248UL,0x4FL,248UL,255UL,0x5DL},{0xD4L,255UL,255UL,0x2FL,0x4FL,0UL},{255UL,255UL,255UL,255UL,0xA3L,0UL},{0x5DL,0x3DL,255UL,255UL,0x3DL,0x5DL},{0xA3L,0x53L,0x4FL,0xA7L,0xD4L,0x3DL},{0x53L,255UL,0xD4L,0UL,0UL,0xF9L},{0x53L,0x2FL,0UL,0xA7L,0UL,0x2FL}}};
    int8_t l_225[1];
    int32_t **l_238 = &l_86[0][3][0];
    int32_t ***l_237[7][4] = {{&l_238,&l_238,&l_238,&l_238},{&l_238,&l_238,&l_238,&l_238},{&l_238,&l_238,&l_238,&l_238},{&l_238,&l_238,&l_238,&l_238},{&l_238,&l_238,&l_238,&l_238},{&l_238,&l_238,&l_238,&l_238},{&l_238,&l_238,&l_238,&l_238}};
    uint32_t l_280[9] = {0xBA16F0D4L,4294967292UL,0xBA16F0D4L,4294967292UL,0xBA16F0D4L,4294967292UL,0xBA16F0D4L,4294967292UL,0xBA16F0D4L};
    struct S0 *l_284[10][10];
    struct S0 **l_283 = &l_284[5][7];
    int8_t l_285[4];
    uint8_t l_291 = 0x54L;
    int64_t l_292 = 0x3A933DB2431B7860LL;
    int64_t l_293 = (-2L);
    int32_t l_294 = (-7L);
    int32_t l_295 = 1L;
    uint32_t l_296 = 0UL;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_225[i] = 0xCAL;
    for (i = 0; i < 10; i++)
    {
        for (j = 0; j < 10; j++)
            l_284[i][j] = &l_109;
    }
    for (i = 0; i < 4; i++)
        l_285[i] = 0x1FL;
    if (l_61[0])
    { /* block id: 8 */
        int32_t l_62[4];
        int i;
        for (i = 0; i < 4; i++)
            l_62[i] = 0L;
        for (l_62[1] = 2; (l_62[1] > 23); l_62[1]++)
        { /* block id: 11 */
            const float l_65 = 0x0.Cp-1;
            int64_t l_68 = 3L;
            l_68 = (l_65 > (l_62[1] != (safe_sub_func_float_f_f(p_58, (-0x4.3p+1)))));
        }
    }
    else
    { /* block id: 14 */
        int32_t l_69 = 0xAE88B149L;
        struct S0 *l_98 = (void*)0;
        struct S0 l_107 = {791};
        const int32_t *l_202 = (void*)0;
        const int32_t **l_201 = &l_202;
        for (l_69 = 0; (l_69 <= 3); l_69 += 1)
        { /* block id: 17 */
            struct S0 l_96 = {870};
            uint16_t l_145 = 65529UL;
            int32_t * const l_149 = &l_87;
            struct S0 *l_155 = (void*)0;
            int8_t l_181[5] = {7L,7L,7L,7L,7L};
            int32_t **l_198 = &l_86[2][5][4];
            int32_t ***l_197 = &l_198;
            int i;
            if ((safe_add_func_uint16_t_u_u((((((safe_sub_func_int16_t_s_s((+(-1L)), ((safe_rshift_func_uint16_t_u_u((((((+((safe_add_func_uint32_t_u_u((((safe_add_func_int32_t_s_s(((l_61[l_69] > ((safe_div_func_int8_t_s_s(((18446744073709551615UL | (safe_rshift_func_uint16_t_u_u(l_69, l_61[3]))) < (l_86[1][4][2] == p_57)), (safe_rshift_func_uint16_t_u_u(8UL, 11)))) == (((+(-5L)) & l_69) ^ (-1L)))) != l_69), l_69)) || 0UL) && l_61[l_69]), l_69)) != l_69)) < l_69) > l_69) == l_61[l_69]) <= 9UL), l_69)) | (-4L)))) != l_69) < 0x754B492BB7607968LL) >= (*p_57)) & 0x5AE90980L), l_61[l_69])))
            { /* block id: 18 */
                int32_t *l_95 = (void*)0;
                const int32_t *l_118 = &l_87;
                const int32_t **l_117[2];
                int32_t **l_119 = &l_86[1][4][2];
                int i;
                for (i = 0; i < 2; i++)
                    l_117[i] = &l_118;
                if (l_69)
                    break;
                for (l_87 = 3; (l_87 >= 0); l_87 -= 1)
                { /* block id: 22 */
                    int32_t l_91 = 0L;
                    int i;
                    for (l_91 = 3; (l_91 >= 0); l_91 -= 1)
                    { /* block id: 25 */
                        int i;
                        if (l_61[l_69])
                            break;
                    }
                    for (l_91 = 0; (l_91 <= 2); l_91 += 1)
                    { /* block id: 30 */
                        int32_t **l_92 = (void*)0;
                        const int32_t *l_94 = &l_87;
                        const int32_t **l_93 = &l_94;
                        struct S0 *l_97 = &l_96;
                        int i, j, k;
                        (*l_93) = p_57;
                        /* statement id: 31 */
                        //assert (l_94 == &l_60);
                        l_86[l_91][(l_91 + 3)][(l_91 + 3)] = l_95;
                        (*l_97) = l_96;
                    }
                    if (((((void*)0 == l_98) > ((((safe_add_func_uint32_t_u_u((l_98 != (void*)0), l_61[l_87])) & (((l_61[l_87] > l_69) >= (((l_69 > (safe_div_func_uint64_t_u_u((safe_rshift_func_uint8_t_u_s(0xCCL, l_61[l_87])), l_69))) ^ (*p_57)) && (-1L))) < (*p_57))) > l_91) == l_69)) <= (-10L)))
                    { /* block id: 35 */
                        struct S0 *l_108 = (void*)0;
                        float l_115[9][5] = {{0x3.6p-1,0x6.C08A2Bp-76,0x6.C08A2Bp-76,0x3.6p-1,(-0x5.6p-1)},{0x4.6CD2A5p+89,0x3.6p-1,0xB.E7E4EBp-42,0x6.Ep-1,0x6.Ep-1},{0x1.Bp-1,0x3.6p-1,0x1.Bp-1,(-0x5.6p-1),0x3.6p-1},{0x6.Ep-1,0x6.C08A2Bp-76,(-0x5.6p-1),0x6.Ep-1,(-0x5.6p-1)},{0x6.Ep-1,0x6.Ep-1,0xB.E7E4EBp-42,0x3.6p-1,0x4.6CD2A5p+89},{0x1.Bp-1,0x4.6CD2A5p+89,(-0x5.6p-1),(-0x5.6p-1),0x4.6CD2A5p+89},{0x4.6CD2A5p+89,0x6.C08A2Bp-76,0x1.Bp-1,0x4.6CD2A5p+89,(-0x5.6p-1)},{0x3.6p-1,0x4.6CD2A5p+89,0xB.E7E4EBp-42,0x4.6CD2A5p+89,0x3.6p-1},{0x1.Bp-1,0x6.Ep-1,0x6.C08A2Bp-76,(-0x5.6p-1),0x6.Ep-1}};
                        float *l_114 = &l_115[2][0];
                        int32_t **l_116 = &l_95;
                        int i, j;
                        l_109 = l_107;
                        if ((*p_57))
                            continue;
                        (*l_114) = (safe_add_func_float_f_f((safe_sub_func_float_f_f(p_58, 0xF.8AADD0p+36)), (&l_96 != l_108)));
                        (*l_116) = (void*)0;
                    }
                    else
                    { /* block id: 40 */
                        return l_107.f0;
                    }
                    (*p_57) = (*p_57);
                }
                (*l_119) = p_57;
            }
            else
            { /* block id: 46 */
                float l_120 = 0x4.8A40F9p+27;
                const int32_t l_133 = 4L;
                const float l_150 = 0x9.E733D0p-14;
                int32_t **l_187 = &l_86[0][6][3];
                if ((*p_57))
                { /* block id: 47 */
                    int32_t l_121 = 1L;
                    int32_t l_122 = 9L;
                    for (l_87 = 0; l_87 < 3; l_87 += 1)
                    {
                        for (l_121 = 0; l_121 < 8; l_121 += 1)
                        {
                            for (l_122 = 0; l_122 < 8; l_122 += 1)
                            {
                                l_86[l_87][l_121][l_122] = &l_87;
                            }
                        }
                    }
                    for (l_121 = 3; (l_121 >= 0); l_121 -= 1)
                    { /* block id: 51 */
                        int32_t * const *l_123 = (void*)0;
                        int32_t ***l_124 = (void*)0;
                        int32_t **l_126 = &l_86[1][4][2];
                        int32_t ***l_125 = &l_126;
                        (*l_125) = l_123;
                        /* statement id: 52 */
                        assert (l_126 == 0);
                        if ((*p_57))
                            continue;
                        return l_107.f0;
                    }
                    (*p_57) = (safe_rshift_func_int8_t_s_s((safe_mod_func_uint16_t_u_u((((safe_div_func_uint32_t_u_u((18446744073709551609UL < (0xAAL < l_133)), 4294967287UL)) > 0x2F44L) ^ (((-10L) && (safe_div_func_int8_t_s_s(0x6AL, (safe_lshift_func_uint16_t_u_s((safe_div_func_uint16_t_u_u(l_133, ((safe_sub_func_int8_t_s_s((safe_lshift_func_uint16_t_u_s(l_61[l_69], 8)), 0UL)) ^ (*p_57)))), l_133))))) >= l_122)), l_133)), 1));
                }
                else
                { /* block id: 57 */
                    for (l_87 = 3; (l_87 >= 0); l_87 -= 1)
                    { /* block id: 60 */
                        int32_t **l_144 = &l_86[1][4][2];
                        (*l_144) = p_57;
                        return l_69;
                    }
                }
                if (((l_96.f0 <= l_145) >= (~((((l_107.f0 == ((safe_div_func_int16_t_s_s(9L, l_61[l_69])) == (l_149 == &l_133))) | l_133) & l_133) & (-2L)))))
                { /* block id: 65 */
                    uint64_t l_172 = 0x40C6877B01F99661LL;
                    if (((safe_rshift_func_int8_t_s_s((safe_sub_func_uint16_t_u_u(((((void*)0 == l_155) <= ((safe_add_func_uint64_t_u_u((safe_sub_func_int16_t_s_s(1L, (0x05428794L > (((safe_sub_func_uint32_t_u_u(((~(*l_149)) | (safe_sub_func_uint64_t_u_u(0x9EDED60BA8BA3176LL, (((*p_57) == ((safe_lshift_func_int16_t_s_u((safe_lshift_func_uint8_t_u_s((((safe_lshift_func_uint8_t_u_u(((+l_107.f0) > (-7L)), 4)) && l_172) | 1UL), 5)), l_172)) != 0UL)) < l_172)))), l_172)) >= l_133) & (*p_57))))), l_172)) > (*l_149))) ^ l_107.f0), 8UL)), 7)) >= l_172))
                    { /* block id: 66 */
                        uint8_t l_180[3];
                        int i;
                        for (i = 0; i < 3; i++)
                            l_180[i] = 252UL;
                        (*p_57) = (safe_unary_minus_func_int16_t_s((l_69 <= ((&l_109 == (void*)0) < (0x37L ^ ((safe_sub_func_int32_t_s_s(7L, (!((safe_lshift_func_int16_t_s_s(((-8L) && ((((safe_unary_minus_func_uint64_t_u(18446744073709551614UL)) || 0x56B4L) >= ((p_57 != &l_133) ^ l_180[0])) & l_107.f0)), l_181[2])) >= l_107.f0)))) ^ (*l_149)))))));
                        (*l_149) = ((4294967295UL > l_133) != l_180[0]);
                        (*p_57) = 1L;
                    }
                    else
                    { /* block id: 70 */
                        int8_t l_182 = 2L;
                        int8_t l_183 = 0x89L;
                        const int32_t *l_185 = (void*)0;
                        const int32_t **l_184[1];
                        int32_t **l_186 = &l_86[1][0][1];
                        int i;
                        for (i = 0; i < 1; i++)
                            l_184[i] = &l_185;
                        if (l_182)
                            break;
                        if (l_183)
                            continue;
                        (*l_186) = l_149;
                    }
                    l_109 = l_109;
                    if (((&p_57 == l_187) | (safe_sub_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((((0xE1L == 0x8DL) != (l_149 == (void*)0)) && l_172), ((safe_sub_func_int64_t_s_s(((safe_div_func_uint32_t_u_u(6UL, (~((l_197 != &l_198) < 0x5444549CL)))) | 65535UL), l_69)) | l_107.f0))), (*l_149)))))
                    { /* block id: 76 */
                        return l_69;
                    }
                    else
                    { /* block id: 78 */
                        float *l_199 = &l_120;
                        int32_t **l_200 = (void*)0;
                        (*l_199) = 0xE.B96844p+89;
                        (*l_149) = ((-0x4.8p+1) < ((p_58 == (p_58 != 0x0.9p-1)) < ((p_58 < ((0x8.911B31p+36 > (0x5.Bp-1 != ((l_200 != l_201) != p_58))) >= 0x5.Ep-1)) <= l_172)));
                    }
                    if (l_203)
                        continue;
                }
                else
                { /* block id: 83 */
                    for (l_87 = 0; (l_87 <= 3); l_87 += 1)
                    { /* block id: 86 */
                        if ((*p_57))
                            break;
                        return l_69;
                    }
                }
            }
        }
        /* facts after for loop */
        //assert (l_86[0][0][0] == &l_60 || l_86[0][0][0] == 0 || l_86[0][0][0] == &l_87);
        (*l_201) = &l_87;
        /* statement id: 93 */
        assert (l_202 == &l_87);
    }
    /* facts after branching */
    //assert (l_86[0][0][0] == &l_60 || l_86[0][0][0] == 0 || l_86[0][0][0] == &l_87);
    if (((l_204 >= ((safe_unary_minus_func_int8_t_s((safe_add_func_int64_t_s_s((safe_lshift_func_int8_t_s_u(((l_212 < (-9L)) == (p_57 != (void*)0)), ((((*p_57) <= ((((((void*)0 == &l_87) & (safe_add_func_int64_t_s_s((l_217 == l_218), l_219))) != l_220) == l_221) > 1L)) > l_222) && (*p_57)))), l_223)))) || l_224[1][4][1])) != l_225[0]))
    { /* block id: 95 */
        struct S0 l_226 = {1365};
        struct S0 *l_227 = &l_109;
        (*l_227) = l_226;
        return l_226.f0;
    }
    else
    { /* block id: 98 */
        struct S0 * const l_228 = &l_109;
        int32_t l_239[6][9] = {{(-1L),0x534BA0CDL,0x678C4744L,0x678C4744L,0x534BA0CDL,(-1L),(-1L),(-1L),0x534BA0CDL},{(-1L),0x28E5AF4EL,0x28E5AF4EL,(-1L),0x76FED915L,0x534BA0CDL,0x76FED915L,(-1L),0x28E5AF4EL},{0x76FED915L,0x76FED915L,(-1L),0x534BA0CDL,0xCB4F3F16L,0x534BA0CDL,(-1L),0x76FED915L,0x76FED915L},{0x28E5AF4EL,(-1L),0x76FED915L,0x534BA0CDL,0x76FED915L,(-1L),0x28E5AF4EL,0x28E5AF4EL,(-1L)},{0x534BA0CDL,(-1L),(-1L),(-1L),0x534BA0CDL,0x678C4744L,0x678C4744L,0x534BA0CDL,(-1L)},{0x28E5AF4EL,0x76FED915L,0x28E5AF4EL,0x678C4744L,(-1L),(-1L),0x678C4744L,0x28E5AF4EL,0x76FED915L}};
        struct S0 *l_257 = (void*)0;
        int32_t **l_262 = &l_86[1][4][2];
        struct S0 **l_278 = &l_257;
        struct S0 ***l_277 = &l_278;
        int i, j;
        for (l_203 = 0; l_203 < 4; l_203 += 1)
        {
            l_61[l_203] = 5UL;
        }
        if ((l_228 == &l_109))
        { /* block id: 100 */
            int8_t l_234 = 3L;
            int32_t *l_235 = &l_87;
            const struct S0 l_236 = {915};
            int32_t **l_240 = &l_86[1][4][2];
            for (l_212 = 0; (l_212 >= 11); l_212 = safe_add_func_int32_t_s_s(l_212, 2))
            { /* block id: 103 */
                for (l_219 = 17; (l_219 < 31); ++l_219)
                { /* block id: 106 */
                    int32_t **l_233 = &l_86[1][4][2];
                    (*l_233) = &l_87;
                    if (l_234)
                        continue;
                    l_235 = (void*)0;
                    /* statement id: 109 */
                    assert (l_235 == 0);
                }
                if (l_234)
                    goto lbl_247;
            }
            /* facts after for loop */
            assert (l_235 == 0 || l_235 == &l_87);
            (*l_228) = l_236;
            (*p_57) = (((l_235 == &l_87) | 0UL) & (((void*)0 != l_237[0][2]) <= l_239[3][6]));
            (*l_240) = p_57;
        }
        else
        { /* block id: 115 */
lbl_247:
            for (l_203 = 10; (l_203 > 46); l_203 = safe_add_func_uint8_t_u_u(l_203, 2))
            { /* block id: 118 */
                int8_t l_245 = 1L;
                for (l_218 = 21; (l_218 == 28); ++l_218)
                { /* block id: 121 */
                    int32_t *l_246 = &l_87;
                    if (l_245)
                        break;
                    (*l_238) = l_246;
                }
            }
            for (l_221 = 14; (l_221 <= 10); l_221 = safe_sub_func_uint16_t_u_u(l_221, 2))
            { /* block id: 129 */
                const struct S0 *l_258 = &l_109;
                int32_t l_261[3][9][6] = {{{1L,0x82F85C99L,0xC977F8B9L,0x78231FD8L,0L,0xBB4E383DL},{0L,0xEB3F9A5FL,0xBBD370A9L,0x34F88857L,0xB5E6DA35L,8L},{1L,0xFF9D7EAAL,0x8348DC13L,(-9L),(-9L),0x8348DC13L},{0L,0L,7L,0xBB4E383DL,0x6E25318AL,0xE30379E3L},{0x51242CBDL,1L,0x53EDEECBL,0x0F9319D2L,0L,7L},{(-3L),0x51242CBDL,0x53EDEECBL,(-5L),0L,0xE30379E3L},{0x00968CA8L,(-5L),7L,0x3854A16AL,0xB7618F1FL,0x8348DC13L},{0x3854A16AL,0xB7618F1FL,0x8348DC13L,0xB24F8A20L,0xD61C98CFL,8L},{1L,0xBAC577DDL,0xBBD370A9L,0x25A6B154L,1L,0x53EDEECBL}},{{1L,0x00968CA8L,7L,0xC977F8B9L,1L,0xBF77952CL},{0L,0x068DE9F7L,0xBBD370A9L,0x7D0813B3L,0xC99C1923L,0xC977F8B9L},{0L,(-1L),(-9L),0x3854A16AL,0xFF9D7EAAL,0xC99C1923L},{(-9L),0xB5E6DA35L,(-3L),1L,0x82F85C99L,1L},{0x00968CA8L,0x3854A16AL,0x7D0813B3L,0xBAC577DDL,0x8348DC13L,0L},{0xC99C1923L,0x82F85C99L,0x56052777L,(-9L),0x56052777L,0x82F85C99L},{1L,0xBF77952CL,1L,0x8B01E69FL,(-9L),0L},{(-4L),0x302581F7L,(-9L),(-5L),(-9L),1L},{0xBAC577DDL,0x302581F7L,(-1L),(-5L),(-9L),8L}},{{0x464EB96BL,0xBF77952CL,0xFF9D7EAAL,(-9L),0x56052777L,(-3L)},{8L,0x82F85C99L,(-4L),(-9L),0x8348DC13L,(-1L)},{(-1L),0x3854A16AL,0xBF77952CL,0x302581F7L,0x82F85C99L,0xB5E6DA35L},{1L,0xB5E6DA35L,0x8B01E69FL,0x00968CA8L,0xFF9D7EAAL,0x1F16EABEL},{0x302581F7L,(-1L),0x464EB96BL,(-4L),0xC99C1923L,(-9L)},{0L,0x068DE9F7L,0x0F9319D2L,1L,1L,1L},{0L,0x00968CA8L,0x302581F7L,(-1L),1L,0L},{1L,(-10L),0xB24F8A20L,0L,0x302581F7L,0xAF282634L},{0x6E25318AL,0xBAC577DDL,0xBB4E383DL,0xBB4E383DL,0xBAC577DDL,0x6E25318AL}}};
                int i, j, k;
                (*p_57) = (l_239[3][6] & l_239[3][7]);
                for (l_222 = 0; (l_222 == 6); ++l_222)
                { /* block id: 133 */
                    float l_264 = 0x9.DD2014p-3;
                    float *l_263 = &l_264;
                    for (l_87 = 1; (l_87 == 13); l_87++)
                    { /* block id: 136 */
                        struct S0 *l_256 = &l_109;
                        struct S0 **l_255 = &l_256;
                        struct S0 ***l_254 = &l_255;
                        if ((*p_57))
                            break;
                        (*l_254) = &l_228;
                        /* statement id: 138 */
                        assert (l_255 == &l_228);
                    }
                    if ((*p_57))
                        continue;
                    (*l_263) = (((0x2.22219Ap-87 == (l_257 == l_258)) < ((p_58 < (p_58 != (safe_add_func_float_f_f(l_261[1][4][1], (((l_262 == (void*)0) >= p_58) <= p_58))))) >= (-0x1.9p+1))) >= l_261[1][4][1]);
                }
            }
            (*l_228) = (*l_228);
        }
        for (l_219 = 0; (l_219 > 40); ++l_219)
        { /* block id: 148 */
            struct S0 **l_267 = &l_257;
            int32_t l_274 = 0L;
            struct S0 l_279 = {1563};
            (*l_267) = (void*)0;
            l_109 = l_109;
            if (((((((safe_rshift_func_uint16_t_u_u((safe_div_func_int8_t_s_s((l_274 || ((safe_lshift_func_uint8_t_u_s(l_239[3][6], ((void*)0 == l_86[1][3][1]))) > l_239[3][6])), 0xDDL)), 15)) != (l_277 != &l_278)) >= 0xB3445A74A0215C44LL) < l_274) & 5UL) || 0xAF38L))
            { /* block id: 151 */
                l_274 = p_58;
                return l_274;
            }
            else
            { /* block id: 154 */
                (*l_262) = (*l_238);
            }
            (*l_228) = l_279;
        }
    }
    (*p_57) = ((l_280[2] < (((safe_lshift_func_uint16_t_u_u((l_283 == &l_284[5][7]), 5)) == l_285[2]) ^ (+(((*l_238) == (void*)0) >= (((safe_add_func_int64_t_s_s((0L > (safe_lshift_func_uint16_t_u_u((l_291 & (((p_57 == (void*)0) > 0xF350D279C502A78DLL) == l_292)), l_293))), l_294)) && 0xD963D65F5B507F08LL) != l_295))))) && 0x296C2EF9L);
    return l_296;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 267
   depth: 1, occurrence: 47
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 90
breakdown:
   indirect level: 0, occurrence: 47
   indirect level: 1, occurrence: 14
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 15
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 3
XXX full-bitfields structs in the program: 47
breakdown:
   indirect level: 0, occurrence: 47
XXX times a bitfields struct's address is taken: 58
XXX times a bitfields struct on LHS: 22
XXX times a bitfields struct on RHS: 61
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 28

XXX max expression depth: 29
breakdown:
   depth: 1, occurrence: 263
   depth: 2, occurrence: 56
   depth: 3, occurrence: 7
   depth: 4, occurrence: 4
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 2
   depth: 10, occurrence: 3
   depth: 12, occurrence: 5
   depth: 13, occurrence: 1
   depth: 15, occurrence: 5
   depth: 16, occurrence: 1
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 23, occurrence: 2
   depth: 24, occurrence: 1
   depth: 25, occurrence: 3
   depth: 27, occurrence: 2
   depth: 29, occurrence: 1

XXX total number of pointers: 285

XXX times a variable address is taken: 677
XXX times a pointer is dereferenced on RHS: 91
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 11
   depth: 3, occurrence: 15
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 134
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 15
   depth: 3, occurrence: 16
XXX times a pointer is compared with null: 58
XXX times a pointer is compared with address of another variable: 25
XXX times a pointer is compared with another pointer: 18
XXX times a pointer is qualified to be dereferenced: 1356

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 308
   level: 2, occurrence: 97
   level: 3, occurrence: 90
   level: 4, occurrence: 56
   level: 5, occurrence: 5
XXX number of pointers point to pointers: 170
XXX number of pointers point to scalars: 82
XXX number of pointers point to structs: 33
XXX percent of pointers has null in alias set: 34
XXX average alias set size: 1.31

XXX times a non-volatile is read: 1223
XXX times a non-volatile is write: 499
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 8

XXX stmts: 249
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 20
   depth: 2, occurrence: 34
   depth: 3, occurrence: 39
   depth: 4, occurrence: 63
   depth: 5, occurrence: 62

XXX percentage a fresh-made variable is used: 17.4
XXX percentage an existing variable is used: 82.6
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

