/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1748847960
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const uint64_t  f0;
   signed f1 : 7;
   const signed f2 : 31;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int32_t  f0;
   int16_t  f1;
   struct S0  f2;
   int16_t  f3;
   const int8_t  f4;
   uint64_t  f5;
   float  f6;
   signed f7 : 6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static float  func_7(uint32_t  p_8);
static uint32_t  func_9(int8_t  p_10, uint32_t  p_11, int32_t  p_12, struct S1  p_13, int32_t  p_14);
inline static int32_t  func_34(struct S1  p_35, struct S1 * const  p_36, struct S1  p_37, float * p_38, uint32_t  p_39);
static struct S1  func_41(uint8_t  p_42, uint32_t  p_43, int32_t  p_44);
inline static uint8_t  func_45(struct S1 * p_46, uint16_t  p_47, struct S1 * p_48, uint8_t  p_49, uint32_t  p_50);
inline static struct S1 * func_51(uint32_t  p_52, uint32_t  p_53, const struct S1 * p_54, struct S1  p_55, uint32_t  p_56);
inline static const struct S1 * func_59(const struct S0  p_60, uint64_t  p_61);
static const struct S0  func_62(struct S1 ** p_63);
static struct S1 ** func_64(float * p_65, struct S1 ** p_66);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int8_t l_4 = 0L;
    uint32_t l_15 = 4294967294UL;
    struct S1 l_16 = {0x4F5AC3D6L,0x1DFEL,{0x36BE856DFC9B996ALL,-1,28960},0x335CL,8L,6UL,0x4.101EB6p+39,0};
    int32_t * const l_1467 = &l_16.f0;
    int32_t *l_1469[9] = {&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0};
    int32_t **l_1468[6][9][1] = {{{&l_1469[1]},{(void*)0},{(void*)0},{&l_1469[5]},{&l_1469[0]},{(void*)0},{&l_1469[0]},{(void*)0},{&l_1469[0]}},{{&l_1469[5]},{(void*)0},{(void*)0},{&l_1469[1]},{(void*)0},{(void*)0},{&l_1469[5]},{&l_1469[0]},{(void*)0}},{{&l_1469[0]},{(void*)0},{&l_1469[0]},{&l_1469[5]},{(void*)0},{(void*)0},{&l_1469[1]},{(void*)0},{(void*)0}},{{&l_1469[5]},{&l_1469[0]},{(void*)0},{&l_1469[0]},{(void*)0},{&l_1469[0]},{&l_1469[5]},{(void*)0},{(void*)0}},{{&l_1469[1]},{&l_1469[5]},{&l_1469[0]},{&l_1469[4]},{&l_1469[1]},{&l_1469[5]},{&l_1469[0]},{&l_1469[5]},{&l_1469[1]}},{{&l_1469[4]},{&l_1469[0]},{&l_1469[5]},{&l_1469[7]},{&l_1469[5]},{&l_1469[0]},{&l_1469[4]},{&l_1469[1]},{&l_1469[5]}}};
    int32_t **l_1470 = &l_1469[2];
    uint32_t l_1487 = 4294967295UL;
    float l_1488[4];
    uint8_t l_1545 = 0x2DL;
    int8_t l_1565 = 0L;
    struct S0 *l_1598 = &l_16.f2;
    struct S0 **l_1597 = &l_1598;
    uint16_t l_1604 = 1UL;
    struct S1 *l_1625 = (void*)0;
    struct S1 **l_1624 = &l_1625;
    int32_t *l_1653[3][8] = {{&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0},{&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0},{&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0,&l_16.f0}};
    struct S1 ***l_1663 = (void*)0;
    struct S1 **** const l_1662 = &l_1663;
    struct S1 ****l_1664 = (void*)0;
    int32_t l_1686[2];
    uint32_t l_1689 = 18446744073709551615UL;
    int i, j, k;
    for (i = 0; i < 4; i++)
        l_1488[i] = 0x1.3p-1;
    for (i = 0; i < 2; i++)
        l_1686[i] = 0xE812A2D2L;
lbl_1558:
    l_16.f7 = (((safe_div_func_float_f_f((l_4 != (l_4 >= l_4)), (safe_div_func_float_f_f(func_7(func_9(l_15, l_4, l_15, l_16, (safe_mul_func_uint8_t_u_u(l_16.f0, (((-1L) == 0xF3L) & l_4))))), l_15)))) != l_16.f3) == l_16.f3);
    (*l_1470) = l_1467;
    for (l_15 = 0; (l_15 != 21); l_15 = safe_add_func_int32_t_s_s(l_15, 7))
    { /* block id: 772 */
        uint32_t l_1477 = 0x0FF7EFBBL;
        struct S1 *l_1493 = &l_16;
        int32_t l_1504[1];
        uint64_t l_1505[1][8][7] = {{{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL},{0x8D97434D7BC4CC01LL,18446744073709551615UL,0x00E2E272102C5D8FLL,6UL,6UL,0x00E2E272102C5D8FLL,18446744073709551615UL}}};
        float *l_1516 = &l_1488[3];
        int8_t l_1591 = 9L;
        const int32_t l_1594 = (-2L);
        struct S0 *l_1631 = &l_16.f2;
        int32_t **l_1638 = &l_1469[6];
        uint8_t l_1654[6];
        uint32_t l_1672 = 0x72E7B567L;
        int32_t l_1677[4][2][5] = {{{2L,0x470FAC3AL,0L,0x9044581CL,0L},{(-3L),(-3L),0x470FAC3AL,0x0B6F9673L,0L}},{{2L,0L,(-4L),0x0B6F9673L,0x0B6F9673L},{0x0B6F9673L,0x7E2912A9L,0x0B6F9673L,0x9044581CL,0x7FDF7279L}},{{(-4L),0L,2L,0x0D9067E1L,0x7FDF7279L},{0x470FAC3AL,(-3L),(-3L),0x470FAC3AL,0x0B6F9673L}},{{0L,0x470FAC3AL,2L,0x7FDF7279L,0L},{0L,2L,0x0B6F9673L,2L,0L}}};
        struct S0 ****l_1685 = (void*)0;
        int i, j, k;
        for (i = 0; i < 1; i++)
            l_1504[i] = 3L;
        for (i = 0; i < 6; i++)
            l_1654[i] = 1UL;
        for (l_16.f0 = 0; l_16.f0 < 6; l_16.f0 += 1)
        {
            for (l_16.f3 = 0; l_16.f3 < 9; l_16.f3 += 1)
            {
                for (l_4 = 0; l_4 < 1; l_4 += 1)
                {
                    l_1468[l_16.f0][l_16.f3][l_4] = &l_1469[4];
                }
            }
        }
        if ((safe_sub_func_uint16_t_u_u(((safe_lshift_func_uint8_t_u_u((l_1477 != 0xEAC2L), (safe_sub_func_uint32_t_u_u((*l_1467), l_1477)))) != 65532UL), (safe_lshift_func_uint8_t_u_u(l_1477, ((!(safe_lshift_func_int16_t_s_s(((safe_mod_func_uint32_t_u_u(((*l_1467) | (((((((l_1477 > (((l_1487 != 65534UL) == (*l_1467)) > 0L)) <= 0x79L) & l_1477) > l_1477) && 0x77L) == (*l_1467)) != l_1477)), 4294967295UL)) < (*l_1467)), 11))) < 4294967286UL))))))
        { /* block id: 774 */
            const int16_t l_1489[1] = {0x19FCL};
            uint16_t l_1547 = 0x9575L;
            int32_t ***l_1605[5] = {&l_1468[4][8][0],&l_1468[4][8][0],&l_1468[4][8][0],&l_1468[4][8][0],&l_1468[4][8][0]};
            const uint32_t l_1623 = 0UL;
            int i;
            if (l_1489[0])
                break;
            for (l_16.f3 = 0; (l_16.f3 != 12); ++l_16.f3)
            { /* block id: 778 */
                int32_t *l_1492 = &l_16.f0;
                int32_t *** const l_1553 = &l_1470;
                int32_t l_1556[5];
                int i;
                for (i = 0; i < 5; i++)
                    l_1556[i] = 0xC33DFE7DL;
                for (l_16.f5 = 0; (l_16.f5 <= 3); l_16.f5 += 1)
                { /* block id: 781 */
                    struct S1 **l_1494[8][1] = {{(void*)0},{&l_1493},{(void*)0},{&l_1493},{(void*)0},{&l_1493},{(void*)0},{&l_1493}};
                    int32_t l_1501 = 0x47F3131FL;
                    int i, j;
                    (*l_1470) = l_1492;
                    l_1493 = l_1493;
                    if (l_1489[0])
                        continue;
                    l_1488[l_16.f5] = (safe_div_func_float_f_f(0xF.32B949p+34, (safe_mul_func_float_f_f(((safe_sub_func_float_f_f((l_1501 >= ((safe_sub_func_float_f_f(l_1489[0], 0x5.550896p-88)) > l_1504[0])), (l_1505[0][2][6] == l_1477))) != (safe_mul_func_float_f_f((-0x1.8p-1), (safe_add_func_float_f_f(l_1489[0], l_1504[0]))))), l_1489[0]))));
                }
                for (l_1487 = 0; (l_1487 <= 0); l_1487 += 1)
                { /* block id: 789 */
                    int32_t l_1546 = 0xD6BA2EB3L;
                    const uint32_t l_1555[3] = {0xD9FA0BBEL,0xD9FA0BBEL,0xD9FA0BBEL};
                    struct S0 ***l_1557 = (void*)0;
                    int i;
                    (*l_1492) = (+(~((l_1504[l_1487] || (safe_lshift_func_int16_t_s_s(l_1504[l_1487], 3))) > ((safe_add_func_int16_t_s_s((l_1493 != (void*)0), (l_1469[(l_1487 + 6)] != l_1516))) >= 0x43C8F5A3L))));
                    l_1469[(l_1487 + 6)] = l_1469[(l_1487 + 6)];
                    if ((safe_mod_func_int8_t_s_s((l_1489[0] & (((((*l_1467) == (safe_sub_func_int64_t_s_s((safe_add_func_int16_t_s_s(((safe_div_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((safe_sub_func_uint32_t_u_u((safe_lshift_func_int8_t_s_u(((l_1516 == l_1516) > (safe_rshift_func_int8_t_s_u(((safe_div_func_int64_t_s_s(0L, l_1504[0])) || ((safe_mul_func_int16_t_s_s((((l_1489[0] ^ ((safe_div_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((*l_1467), ((l_1489[0] && l_1505[0][2][6]) | 0x0272L))), l_1545)) & l_1546)) == l_1504[0]) < l_1504[0]), 0x276FL)) == (*l_1467))), l_1504[0]))), 2)), l_1505[0][6][5])), l_1477)), l_1489[0])) >= l_1489[0]), l_1547)), 0xBFE460FF3042D6D9LL))) && (*l_1492)) && l_1489[0]) < l_1489[0])), l_1504[0])))
                    { /* block id: 792 */
                        uint8_t l_1550[9][2] = {{0UL,0x61L},{0UL,0UL},{0UL,0x61L},{0UL,0UL},{0UL,0x61L},{0UL,0UL},{0UL,0x61L},{0UL,0UL},{0UL,0x61L}};
                        const int32_t l_1554 = (-1L);
                        int i, j;
                        (*l_1467) = ((safe_rshift_func_uint8_t_u_s((l_1489[0] && ((((l_1550[3][0] && (l_1477 & (*l_1492))) > ((((*l_1492) & (safe_add_func_int16_t_s_s((((void*)0 == l_1553) | l_1554), ((*l_1467) & (*l_1492))))) == l_1555[1]) ^ 0xA9B23A72CC347CA7LL)) || l_1505[0][2][6]) ^ l_1489[0])), l_1505[0][6][1])) <= l_1556[1]);
                        l_1557 = l_1557;
                    }
                    else
                    { /* block id: 795 */
                        int i;
                        l_1469[(l_1487 + 5)] = (void*)0;
                        if (l_4)
                            goto lbl_1558;
                        return l_1505[0][0][4];
                    }
                    for (l_1477 = 0; (l_1477 <= 0); l_1477 += 1)
                    { /* block id: 802 */
                        if (l_1489[0])
                            break;
                    }
                }
            }
            if ((((safe_sub_func_uint64_t_u_u((safe_unary_minus_func_uint16_t_u((safe_lshift_func_uint16_t_u_s((~(-1L)), 13)))), l_1489[0])) | l_1489[0]) < l_1477))
            { /* block id: 807 */
                uint8_t l_1582 = 0x66L;
                int32_t *l_1603[9];
                const int8_t l_1617 = (-1L);
                struct S0 *** const l_1620 = &l_1597;
                struct S0 *** const * const l_1619 = &l_1620;
                struct S0 *** const * const *l_1618 = &l_1619;
                int16_t l_1626 = (-9L);
                uint32_t l_1627 = 4294967287UL;
                int i;
                for (i = 0; i < 9; i++)
                    l_1603[i] = &l_16.f0;
                (*l_1516) = l_1565;
                if ((safe_div_func_int16_t_s_s(((+(safe_add_func_int32_t_s_s(((((safe_mod_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((safe_lshift_func_int8_t_s_u((safe_mod_func_uint16_t_u_u(((l_1489[0] ^ ((safe_lshift_func_int16_t_s_u((+((l_1582 || (safe_mod_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s(l_1489[0], 5)), (safe_mod_func_int64_t_s_s((safe_mod_func_uint16_t_u_u((l_1591 ^ (safe_div_func_uint8_t_u_u((l_1594 && (safe_mul_func_int16_t_s_s((*l_1467), ((void*)0 != l_1597)))), l_1504[0]))), 0x7B9EL)), 5L))))) != l_1504[0])), l_1582)) | l_1489[0])) && l_1505[0][4][4]), l_1582)), 5)), 1)), 65535UL)) >= l_1582) != l_1582) > l_1582), 0UL))) ^ l_1582), 0x1136L)))
                { /* block id: 809 */
                    const struct S1 *l_1600[8][6][5] = {{{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,(void*)0,&l_16,&l_16}},{{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,(void*)0,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16}},{{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,(void*)0,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16}},{{&l_16,&l_16,(void*)0,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,(void*)0,&l_16,&l_16}},{{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,(void*)0,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16}},{{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,(void*)0,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16}},{{&l_16,&l_16,(void*)0,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{(void*)0,&l_16,(void*)0,&l_16,&l_16}},{{(void*)0,&l_16,&l_16,(void*)0,&l_16},{(void*)0,(void*)0,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,&l_16,&l_16,&l_16,&l_16},{&l_16,(void*)0,&l_16,&l_16,(void*)0}}};
                    const struct S1 **l_1599 = &l_1600[1][3][4];
                    int i, j, k;
                    if (l_1582)
                        break;
                    (*l_1599) = &l_16;
                    for (l_1547 = 0; (l_1547 < 10); l_1547 = safe_add_func_int32_t_s_s(l_1547, 5))
                    { /* block id: 814 */
                        if (l_16.f4)
                            goto lbl_1558;
                        l_1603[1] = l_1603[4];
                    }
                }
                else
                { /* block id: 818 */
                    (*l_1470) = (*l_1470);
                    if (l_1604)
                        break;
                    if (((((void*)0 != l_1605[2]) == (l_1504[0] == 0UL)) || 0xD19FL))
                    { /* block id: 821 */
                        return l_1594;
                    }
                    else
                    { /* block id: 823 */
                        uint64_t l_1606 = 5UL;
                        l_1606 = (-3L);
                        if (l_1504[0])
                            break;
                    }
                    for (l_1547 = 16; (l_1547 >= 43); l_1547 = safe_add_func_int64_t_s_s(l_1547, 1))
                    { /* block id: 829 */
                        return l_1594;
                    }
                }
                (*l_1467) = (+(safe_div_func_int8_t_s_s(((l_1505[0][3][0] & (((0UL != (safe_lshift_func_uint8_t_u_u((+(safe_rshift_func_uint8_t_u_s(l_1617, ((l_1618 != (void*)0) != (safe_add_func_uint64_t_u_u((l_1623 > (l_1477 == l_1505[0][2][6])), ((l_1624 != &l_1625) && (*l_1467)))))))), l_1626))) || l_1594) <= 65529UL)) == (-8L)), l_1627)));
            }
            else
            { /* block id: 834 */
                int32_t *l_1628 = (void*)0;
                l_1628 = l_1516;
                /* statement id: 835 */
                assert ((l_1628 >= &l_1488[0] && l_1628 <= &l_1488[3]));
            }
            if (l_1591)
                continue;
        }
        else
        { /* block id: 838 */
            float l_1632[5][2] = {{(-0x5.7p-1),(-0x5.7p-1)},{(-0x5.7p-1),(-0x5.7p-1)},{(-0x5.7p-1),(-0x5.7p-1)},{(-0x5.7p-1),(-0x5.7p-1)},{(-0x5.7p-1),(-0x5.7p-1)}};
            int32_t l_1643 = 0x100BD8EEL;
            int i, j;
            for (l_1545 = 12; (l_1545 != 12); l_1545 = safe_add_func_uint8_t_u_u(l_1545, 7))
            { /* block id: 841 */
                (*l_1597) = l_1631;
                if (l_1504[0])
                    break;
                (*l_1467) = ((0UL ^ 0xF8L) & 0xEDL);
                (*l_1516) = l_1504[0];
            }
            for (l_16.f0 = (-26); (l_16.f0 > 24); l_16.f0 = safe_add_func_uint32_t_u_u(l_16.f0, 2))
            { /* block id: 849 */
                float * const *l_1637 = &l_1516;
                float *l_1642 = &l_1488[3];
                int32_t l_1644 = 0xC96A70B3L;
                struct S0 *** const l_1646 = &l_1597;
                struct S0 *** const *l_1645 = &l_1646;
                struct S0 ***l_1649 = &l_1597;
                struct S0 ****l_1648 = &l_1649;
                struct S0 *****l_1647 = &l_1648;
                int32_t *l_1650 = (void*)0;
                if ((safe_sub_func_int64_t_s_s(((void*)0 != l_1637), (&l_1467 == l_1638))))
                { /* block id: 850 */
                    const int32_t l_1641 = 0x8C2CE5FDL;
                    for (l_16.f5 = 17; (l_16.f5 <= 54); l_16.f5++)
                    { /* block id: 853 */
                        if (l_1641)
                            break;
                    }
                    l_1643 = ((l_1642 != l_1516) == 0UL);
                }
                else
                { /* block id: 857 */
                    return l_1644;
                }
                (*l_1647) = l_1645;
                /* statement id: 860 */
                assert (l_1648 == &l_1646);
                l_1650 = &l_1644;
                /* statement id: 861 */
                assert (l_1650 == &l_1644);
            }
        }
        for (l_16.f5 = 0; (l_16.f5 != 0); l_16.f5 = safe_add_func_uint16_t_u_u(l_16.f5, 8))
        { /* block id: 866 */
            int64_t l_1659 = 0x9EC44EF5F8D1FC71LL;
            int32_t *** const *l_1661 = (void*)0;
            int32_t *** const **l_1660 = &l_1661;
            l_1653[0][4] = (*l_1638);
            (*l_1638) = (*l_1638);
            (*l_1516) = ((((l_1654[1] > ((-0x1.0p+1) < 0x0.Ap-1)) == (safe_sub_func_float_f_f((safe_div_func_float_f_f(0x1.493073p+45, 0x1.Fp+1)), (((0x5.02D58Cp+64 >= l_1659) < (0xE.002298p-79 != l_1659)) > 0x3.63B6ADp+59)))) != 0x0.6p+1) == 0xC.E39E2Fp+73);
            for (l_16.f1 = 8; (l_16.f1 >= 3); l_16.f1 -= 1)
            { /* block id: 872 */
                int16_t l_1669 = (-2L);
                int32_t * const l_1670 = &l_16.f0;
                uint32_t l_1675 = 0xCD942472L;
                int32_t l_1676[7][2] = {{0x2462C207L,0xF4FAC7CEL},{0x7D94B69FL,0xF4FAC7CEL},{0x2462C207L,0x7D94B69FL},{5L,5L},{5L,0x7D94B69FL},{0x2462C207L,0xF4FAC7CEL},{0x7D94B69FL,0xF4FAC7CEL}};
                float ****l_1679 = (void*)0;
                float *****l_1678[6][4] = {{&l_1679,&l_1679,&l_1679,&l_1679},{&l_1679,&l_1679,&l_1679,&l_1679},{&l_1679,&l_1679,&l_1679,&l_1679},{&l_1679,&l_1679,&l_1679,&l_1679},{&l_1679,&l_1679,&l_1679,&l_1679},{&l_1679,&l_1679,&l_1679,&l_1679}};
                int32_t **l_1688 = &l_1469[0];
                int i, j;
                for (l_1565 = 2; (l_1565 >= 0); l_1565 -= 1)
                { /* block id: 875 */
                    l_1660 = (void*)0;
                    /* statement id: 876 */
                    assert (l_1660 == 0);
                    l_1664 = l_1662;
                    /* statement id: 877 */
                    assert (l_1664 == &l_1663);
                }
                if ((safe_rshift_func_uint8_t_u_u(1UL, (safe_div_func_uint32_t_u_u(l_1669, (*l_1467))))))
                { /* block id: 879 */
                    int i;
                    for (l_1487 = 0; (l_1487 <= 2); l_1487 += 1)
                    { /* block id: 882 */
                        int i;
                        return l_1654[l_1487];
                    }
                    l_1469[l_16.f1] = (*l_1638);
                }
                else
                { /* block id: 886 */
                    int32_t **l_1671 = &l_1653[0][4];
                    int32_t l_1687 = 0L;
                    (*l_1671) = l_1670;
                    for (l_1591 = 2; (l_1591 >= 0); l_1591 -= 1)
                    { /* block id: 890 */
                        int64_t l_1674 = (-1L);
                        int i, j;
                        if (l_1672)
                            break;
                        l_1653[l_1591][(l_1591 + 3)] = (*l_1470);
                        l_1675 = ((!l_1674) || 0x12L);
                    }
                    if (l_1477)
                    { /* block id: 895 */
                        return l_1676[1][0];
                    }
                    else
                    { /* block id: 897 */
                        (*l_1671) = (*l_1638);
                        (*l_1670) = l_1677[2][1][3];
                    }
                    (*l_1516) = (((l_1672 != (l_1678[2][1] == &l_1679)) == (((safe_div_func_float_f_f((safe_sub_func_float_f_f(((-0x8.Ap+1) <= (0xC.2EFC18p+86 < ((((-0x3.780DF4p-4) != (*l_1670)) != (((l_1685 == (void*)0) < (*l_1670)) == 0x1.Fp+1)) > (*l_1670)))), 0xF.E992E4p+71)), (*l_1670))) == (*l_1670)) >= l_1686[1])) == l_1687);
                }
                (*l_1688) = l_1670;
            }
            /* facts after for loop */
            assert (l_1660 == 0 || l_1660 == &l_1661);
        }
    }
    (*l_1467) = (*l_1467);
    return l_1689;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_7(uint32_t  p_8)
{ /* block id: 765 */
    int32_t l_1465[9][6][4] = {{{0xF9EAF672L,0x303DAB33L,0x6E51A541L,0xF7B7250AL},{0x20A50E67L,9L,1L,0x628CA148L},{4L,1L,0x1C45F396L,0xF9EAF672L},{0xF7B7250AL,0x0CD4D802L,0x3FFE677EL,(-6L)},{0xFE3FA8ABL,0L,0xA8717932L,0xA8717932L},{8L,8L,1L,0L}},{{0xA8717932L,0x8721CD9EL,(-1L),0L},{0xD1C69802L,9L,(-1L),(-1L)},{0xF7E151EFL,9L,0L,0L},{9L,0x8721CD9EL,0L,0L},{0x3C0162F8L,8L,0xF7E151EFL,0xA8717932L},{0x3FFE677EL,0L,0x6E686B83L,(-6L)}},{{1L,0x0CD4D802L,0xE710A6A1L,0xF9EAF672L},{0xB213ED17L,1L,0x3C0162F8L,0x628CA148L},{0L,9L,0x773B5281L,0xF7B7250AL},{(-10L),0x303DAB33L,(-10L),0L},{0x6E686B83L,0xF62D5150L,8L,0L},{0x8721CD9EL,0x628CA148L,0x69281CFCL,0xF62D5150L}},{{9L,0x773F5EABL,0x69281CFCL,4L},{0x8721CD9EL,0x3FFE677EL,8L,0xE710A6A1L},{0x6E686B83L,0xFE3FA8ABL,(-10L),0xCECF514AL},{(-10L),0xCECF514AL,0x773B5281L,0x69281CFCL},{0L,0x6E686B83L,0x3C0162F8L,0xFE3FA8ABL},{0xB213ED17L,0L,0xE710A6A1L,0x6E51A541L}},{{1L,0xB213ED17L,0x6E686B83L,0x303DAB33L},{0x3FFE677EL,0xF7E151EFL,0xF7E151EFL,0x3FFE677EL},{0x3C0162F8L,0L,0L,0x6E686B83L},{9L,4L,0L,0x20A50E67L},{0x3FFE677EL,9L,0xA8717932L,0xE710A6A1L},{1L,9L,0x20A50E67L,0L}},{{0L,0x69281CFCL,0xCFFBE94FL,0xD1C69802L},{1L,0x3FFE677EL,0L,0x6E686B83L},{0x6E51A541L,0x773B5281L,0xD1C69802L,(-1L)},{4L,0xDB521E84L,(-6L),0x6E51A541L},{9L,0L,0x0CD4D802L,0L},{0xE710A6A1L,0x628CA148L,(-1L),0x628CA148L}},{{0x773F5EABL,0x6E51A541L,0x628CA148L,0x3C0162F8L},{0x3C0162F8L,0xD1C69802L,0x6E686B83L,9L},{0xA8717932L,0xCECF514AL,0x69281CFCL,0xF7B7250AL},{0xA8717932L,0x1C45F396L,0x6E686B83L,0x8721CD9EL},{0x3C0162F8L,0xF7B7250AL,0x628CA148L,0xB213ED17L},{0x773F5EABL,0x6E686B83L,(-1L),4L}},{{0xE710A6A1L,(-1L),0x0CD4D802L,0x1C45F396L},{9L,0x0CD4D802L,(-6L),0x773F5EABL},{4L,(-10L),0xD1C69802L,0xF7E151EFL},{0x6E51A541L,0x8721CD9EL,0L,0L},{1L,1L,0xCFFBE94FL,0x31183A67L},{0L,0xFE3FA8ABL,0x20A50E67L,0x69281CFCL}},{{1L,0xF62D5150L,0xA8717932L,0x20A50E67L},{0x3FFE677EL,0xF62D5150L,0x8721CD9EL,0x69281CFCL},{0xF62D5150L,0xFE3FA8ABL,0xDB521E84L,0x31183A67L},{0L,1L,0x3FFE677EL,0L},{0xD1C69802L,0x8721CD9EL,0L,0xF7E151EFL},{0xCFFBE94FL,(-10L),0x3C0162F8L,0x773F5EABL}}};
    int32_t *l_1466 = &l_1465[2][5][3];
    int i, j, k;
    (*l_1466) = l_1465[4][3][3];
    return p_8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_9(int8_t  p_10, uint32_t  p_11, int32_t  p_12, struct S1  p_13, int32_t  p_14)
{ /* block id: 1 */
    struct S1 l_21[2] = {{1L,-1L,{0xD7F285F402BE2FF5LL,1,-45255},0x57B1L,6L,0x2C298C245E320525LL,0x7.E4DDBBp+99,-2},{1L,-1L,{0xD7F285F402BE2FF5LL,1,-45255},0x57B1L,6L,0x2C298C245E320525LL,0x7.E4DDBBp+99,-2}};
    struct S1 *l_20 = &l_21[0];
    struct S1 **l_19 = &l_20;
    uint16_t l_197 = 65535UL;
    float **l_1433[4];
    int32_t *l_1460[9][10][2] = {{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,(void*)0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,(void*)0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,(void*)0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,(void*)0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,(void*)0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0}},{{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,&l_21[0].f0},{&l_21[0].f0,(void*)0},{&l_21[0].f0,&l_21[0].f0},{(void*)0,&l_21[0].f0},{&l_21[0].f0,(void*)0}}};
    int32_t **l_1459 = &l_1460[2][1][0];
    int32_t l_1464 = 0L;
    int i, j, k;
    for (i = 0; i < 4; i++)
        l_1433[i] = (void*)0;
    (*l_19) = &p_13;
    /* statement id: 2 */
    assert (l_20 == &p_13);
    for (p_12 = 0; (p_12 > (-20)); p_12 = safe_sub_func_uint32_t_u_u(p_12, 1))
    { /* block id: 5 */
        float *l_67[8];
        int32_t l_91 = 0x278982BFL;
        const int32_t *l_1462 = &l_91;
        int i;
        for (i = 0; i < 8; i++)
            l_67[i] = (void*)0;
        for (p_14 = (-9); (p_14 >= 18); p_14 = safe_add_func_int32_t_s_s(p_14, 8))
        { /* block id: 8 */
            struct S1 *l_26 = &l_21[0];
            float *l_27 = &l_21[0].f6;
            (*l_27) = ((void*)0 == l_26);
        }
        l_21[0].f0 = l_21[0].f4;
        if (p_13.f2.f1)
        { /* block id: 12 */
            int32_t l_58 = 0x19FDEE13L;
            struct S1 **l_68 = &l_20;
            float ***l_1434 = &l_1433[1];
            for (p_14 = 4; (p_14 > 13); p_14 = safe_add_func_uint16_t_u_u(p_14, 9))
            { /* block id: 15 */
                struct S1 * const l_40 = &l_21[0];
                struct S1 *l_196 = &l_21[0];
                int32_t l_198 = 0x960F0752L;
                float *l_429 = &l_21[0].f6;
                for (p_13.f3 = 0; (p_13.f3 == (-3)); p_13.f3 = safe_sub_func_uint8_t_u_u(p_13.f3, 6))
                { /* block id: 18 */
                    for (p_10 = 0; (p_10 != (-3)); p_10--)
                    { /* block id: 21 */
                        int32_t l_57 = 0x746A6ECCL;
                        int32_t *l_1419 = &l_198;
                        (*l_1419) = func_34(p_13, l_40, func_41((func_45(func_51(l_57, l_58, func_59(func_62(func_64(l_67[5], l_68)), (safe_add_func_int32_t_s_s(1L, l_91))), p_13, l_57), l_57, l_196, l_197, l_198) >= l_58), p_13.f1, p_13.f2.f2), l_429, p_13.f5);
                    }
                    for (l_197 = (-28); (l_197 >= 6); ++l_197)
                    { /* block id: 736 */
                        int8_t l_1430 = 0x06L;
                        struct S0 *l_1431 = &l_21[0].f2;
                        int32_t *l_1432 = &l_58;
                        (*l_1432) = ((0L < p_13.f1) != (safe_rshift_func_int8_t_s_s((((((l_91 >= 18446744073709551613UL) | (safe_sub_func_uint64_t_u_u((safe_div_func_uint32_t_u_u((0xB89BL >= p_12), (((safe_lshift_func_uint8_t_u_s(0xC7L, 6)) || l_1430) ^ ((void*)0 != l_1431)))), 0UL))) <= l_21[0].f2.f1) || p_10) || l_58), 2)));
                        return l_91;
                    }
                }
            }
            (*l_1434) = l_1433[1];
        }
        else
        { /* block id: 743 */
            const struct S1 *l_1437 = &l_21[0];
            const struct S1 **l_1436 = &l_1437;
            const struct S1 ***l_1435 = &l_1436;
            int32_t * const **l_1444 = (void*)0;
            int8_t l_1448 = 1L;
            int32_t *l_1453 = &l_21[0].f0;
            l_1435 = l_1435;
            (*l_1453) = ((((safe_sub_func_uint8_t_u_u(((safe_div_func_uint32_t_u_u(((void*)0 == l_1444), p_14)) ^ (~(safe_add_func_uint16_t_u_u(l_1448, 0UL)))), (((safe_mul_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(p_11, 15)), p_13.f2.f2)) == 1UL) ^ 0x9D98L))) ^ 0UL) >= l_91) ^ p_13.f2.f0);
        }
        for (l_91 = 12; (l_91 >= (-22)); l_91 = safe_sub_func_int8_t_s_s(l_91, 3))
        { /* block id: 749 */
            int32_t **l_1461 = &l_1460[2][1][0];
            int32_t **l_1463 = &l_1460[2][1][0];
            for (p_13.f5 = 0; (p_13.f5 <= 3); p_13.f5 += 1)
            { /* block id: 752 */
                int32_t *l_1456 = &l_21[0].f0;
                l_1456 = &l_91;
                /* statement id: 753 */
                assert (l_1456 == &l_91);
                return l_91;
            }
            for (p_10 = (-2); (p_10 > 28); ++p_10)
            { /* block id: 758 */
                l_1461 = l_1459;
            }
            (*l_1463) = l_1462;
        }
        /* facts after for loop */
        //assert (l_1460[0][0][0] == &l_91 || (l_1460[0][0][0] >= &l_21[0].f0 && l_1460[0][0][0] <= &l_21[1].f0) || l_1460[0][0][0] == 0 || l_1460[0][0][0] == dangling);
    }
    /* facts after for loop */
    //assert (l_1460[0][0][0] == dangling || (l_1460[0][0][0] >= &l_21[0].f0 && l_1460[0][0][0] <= &l_21[1].f0) || l_1460[0][0][0] == 0);
    return l_1464;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_34(struct S1  p_35, struct S1 * const  p_36, struct S1  p_37, float * p_38, uint32_t  p_39)
{ /* block id: 220 */
    uint32_t l_430 = 18446744073709551615UL;
    struct S0 **l_487[5];
    struct S0 *** const l_486 = &l_487[2];
    struct S0 *** const *l_485[7];
    struct S0 *** const **l_484[4][9] = {{&l_485[5],&l_485[5],&l_485[5],(void*)0,&l_485[5],&l_485[5],&l_485[5],&l_485[5],(void*)0},{&l_485[0],&l_485[5],&l_485[0],(void*)0,(void*)0,&l_485[0],&l_485[5],&l_485[0],(void*)0},{&l_485[5],&l_485[5],&l_485[5],&l_485[5],&l_485[4],&l_485[5],&l_485[5],&l_485[5],&l_485[5]},{&l_485[5],(void*)0,&l_485[5],(void*)0,&l_485[5],&l_485[5],(void*)0,&l_485[5],(void*)0}};
    int32_t l_517 = 0xE84E6DCCL;
    const struct S1 l_523 = {0L,0x6860L,{0UL,-2,2349},-7L,0L,0xC17438A579C30704LL,-0x1.0p-1,7};
    const struct S1 *l_522[7][10][2] = {{{&l_523,(void*)0},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523}},{{(void*)0,&l_523},{&l_523,(void*)0},{&l_523,&l_523},{&l_523,(void*)0},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{&l_523,&l_523}},{{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,(void*)0},{&l_523,&l_523},{&l_523,(void*)0},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523}},{{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,(void*)0},{&l_523,(void*)0},{&l_523,(void*)0}},{{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{(void*)0,&l_523}},{{&l_523,(void*)0},{&l_523,(void*)0},{&l_523,(void*)0},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523},{&l_523,&l_523}},{{&l_523,&l_523},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,(void*)0},{&l_523,(void*)0},{&l_523,(void*)0},{&l_523,&l_523},{(void*)0,&l_523},{&l_523,&l_523},{&l_523,&l_523}}};
    int32_t l_573 = 0xA76938A6L;
    int32_t *l_572 = &l_573;
    int8_t l_666 = 0L;
    int16_t l_699 = 0L;
    float l_715 = 0x1.7p-1;
    float *l_714 = &l_715;
    float **l_713 = &l_714;
    uint16_t l_847 = 0xE00EL;
    uint64_t l_953 = 18446744073709551615UL;
    struct S0 l_1159 = {0x2C77965E26D8A0A7LL,2,-14040};
    struct S0 *l_1158 = &l_1159;
    struct S0 l_1161[4] = {{18446744073709551613UL,-6,-24449},{18446744073709551613UL,-6,-24449},{18446744073709551613UL,-6,-24449},{18446744073709551613UL,-6,-24449}};
    struct S0 *l_1160 = &l_1161[3];
    int32_t *l_1162 = (void*)0;
    int32_t *l_1163[4];
    struct S1 l_1206 = {0x4D3DE977L,0L,{3UL,-5,-41235},-4L,0x6DL,2UL,0x0.8p+1,-2};
    struct S1 *l_1205[3];
    struct S1 **l_1204 = &l_1205[0];
    struct S1 ***l_1203 = &l_1204;
    int32_t **l_1236[6] = {&l_1163[0],&l_1163[0],&l_1163[0],&l_1163[0],&l_1163[0],&l_1163[0]};
    int32_t ***l_1235 = &l_1236[0];
    int32_t ****l_1234 = &l_1235;
    struct S1 ****l_1258 = &l_1203;
    uint8_t l_1356 = 0x01L;
    int i, j, k;
    for (i = 0; i < 5; i++)
        l_487[i] = (void*)0;
    for (i = 0; i < 7; i++)
        l_485[i] = &l_486;
    for (i = 0; i < 4; i++)
        l_1163[i] = &l_573;
    for (i = 0; i < 3; i++)
        l_1205[i] = &l_1206;
    if (l_430)
    { /* block id: 221 */
        uint32_t l_451 = 0xB04C0E27L;
        uint64_t l_518 = 0x6CCF4F49C8ED1472LL;
        struct S0 ***l_521 = &l_487[1];
        struct S0 ****l_520 = &l_521;
        struct S0 *****l_519 = &l_520;
        struct S1 l_524 = {4L,0xDB33L,{0UL,-10,40978},0xEDCDL,0xD5L,0xF2F067BEC60F63CCLL,0xE.B84161p-89,-2};
        int32_t *l_544 = &l_524.f0;
        int32_t * const *l_543 = &l_544;
        int64_t l_559[1][7][10] = {{{(-1L),0x430AFE179C9CC418LL,9L,9L,0x430AFE179C9CC418LL,(-1L),0xF3A545B3E25D42C2LL,6L,(-6L),6L},{0x411087EC5F8097B7LL,9L,(-6L),0x79746DD20CB603B0LL,(-6L),9L,0x411087EC5F8097B7LL,0xF3A545B3E25D42C2LL,4L,4L},{0x411087EC5F8097B7LL,4L,(-1L),0L,0L,(-1L),4L,0x411087EC5F8097B7LL,0x430AFE179C9CC418LL,0xF3A545B3E25D42C2LL},{(-1L),4L,0x411087EC5F8097B7LL,0x430AFE179C9CC418LL,0xF3A545B3E25D42C2LL,0x430AFE179C9CC418LL,0x411087EC5F8097B7LL,4L,(-1L),0L},{(-6L),9L,0x411087EC5F8097B7LL,0xF3A545B3E25D42C2LL,4L,4L,0xF3A545B3E25D42C2LL,0x411087EC5F8097B7LL,9L,(-6L)},{9L,0x430AFE179C9CC418LL,(-1L),0xF3A545B3E25D42C2LL,6L,(-6L),6L,0xF3A545B3E25D42C2LL,(-1L),0x430AFE179C9CC418LL},{0L,0x411087EC5F8097B7LL,(-6L),0x430AFE179C9CC418LL,6L,0x79746DD20CB603B0LL,0x79746DD20CB603B0LL,6L,0x430AFE179C9CC418LL,(-6L)}}};
        float *****l_708 = (void*)0;
        int32_t l_808[10] = {0xAE9F1726L,0xF98345A5L,0xFCA9363FL,0xFCA9363FL,0xF98345A5L,0xAE9F1726L,0xF98345A5L,0xFCA9363FL,0xFCA9363FL,0xF98345A5L};
        uint8_t l_878 = 251UL;
        const struct S1 **l_898 = (void*)0;
        const struct S1 ***l_897 = &l_898;
        const struct S1 ****l_896 = &l_897;
        int i, j, k;
lbl_558:
        for (p_35.f5 = (-28); (p_35.f5 == 4); p_35.f5 = safe_add_func_int32_t_s_s(p_35.f5, 5))
        { /* block id: 224 */
            int16_t l_438 = 0L;
            float l_476 = 0xD.84A3F1p+60;
            float *l_475 = &l_476;
            float **l_474 = &l_475;
            float ** const * const l_473 = &l_474;
            float ** const * const *l_472[2][4] = {{(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0}};
            int i, j;
        }
        if ((safe_add_func_uint16_t_u_u((((((0x6A15EEDD2B8BD812LL > p_37.f5) && p_35.f0) <= (safe_sub_func_int64_t_s_s((l_430 == (p_35.f1 > ((safe_mod_func_int64_t_s_s((safe_add_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(((safe_mod_func_uint32_t_u_u((((safe_lshift_func_int16_t_s_s(l_430, 11)) <= (safe_add_func_uint16_t_u_u((safe_mod_func_uint64_t_u_u((safe_mod_func_uint8_t_u_u((+(p_35.f3 ^ l_451)), (((safe_rshift_func_int8_t_s_s(0L, p_35.f0)) < l_430) | 0x4BL))), 0xC1FFC74E96E200CBLL)), p_35.f4))) | l_430), 0xA998834DL)) != l_451), l_517)), p_37.f2.f2)), l_430)) <= 247UL))), l_518))) < l_518) == l_451), l_451)))
        { /* block id: 243 */
            int64_t l_525 = 0x0550F2087BEF1ED8LL;
            struct S0 *l_540[9] = {&l_524.f2,&l_524.f2,&l_524.f2,&l_524.f2,&l_524.f2,&l_524.f2,&l_524.f2,&l_524.f2,&l_524.f2};
            int32_t *l_555 = &l_524.f0;
            const float *l_596 = &l_524.f6;
            const float **l_595 = &l_596;
            struct S0 ** const *l_601[5];
            struct S0 ** const **l_600 = &l_601[1];
            struct S0 ** const ***l_599 = &l_600;
            uint32_t l_602[1];
            uint32_t l_603 = 18446744073709551615UL;
            uint32_t l_615[1][10][2] = {{{4294967295UL,6UL},{4294967295UL,6UL},{0UL,6UL},{6UL,0UL},{6UL,6UL},{0UL,6UL},{6UL,0UL},{6UL,6UL},{0UL,6UL},{6UL,0UL}}};
            uint8_t l_619 = 0x6BL;
            float *l_628 = &l_524.f6;
            float **l_627 = &l_628;
            float ***l_626 = &l_627;
            float ****l_625 = &l_626;
            float *****l_624 = &l_625;
            uint64_t l_648 = 0x2B08DBDC7C9CCF94LL;
            int32_t l_649 = 0x571FFC8FL;
            float ****l_657 = &l_626;
            float * const ***l_658 = (void*)0;
            struct S0 **l_665[9][2] = {{&l_540[6],&l_540[6]},{&l_540[3],&l_540[6]},{&l_540[6],&l_540[3]},{&l_540[6],&l_540[6]},{&l_540[3],&l_540[6]},{&l_540[6],&l_540[3]},{&l_540[6],&l_540[6]},{&l_540[3],&l_540[6]},{&l_540[6],&l_540[3]}};
            int32_t l_667 = (-10L);
            struct S0 **l_680 = (void*)0;
            struct S0 ****l_681 = &l_521;
            uint16_t l_684 = 0xDBB1L;
            int i, j, k;
            for (i = 0; i < 5; i++)
                l_601[i] = &l_487[2];
            for (i = 0; i < 1; i++)
                l_602[i] = 0x4ACB6692L;
lbl_562:
            l_522[4][1][0] = func_51(l_451, (l_519 == (void*)0), l_522[4][1][0], l_524, l_525);
            (*p_38) = (0x6.C00929p+98 <= (+(safe_mul_func_float_f_f((-(l_523.f3 < (*p_38))), (safe_mul_func_float_f_f((safe_sub_func_float_f_f(l_523.f4, (safe_div_func_float_f_f((safe_mul_func_float_f_f(0x2.Dp-1, (safe_mul_func_float_f_f(l_523.f5, ((((*p_38) > (l_540[1] == l_540[1])) != l_518) <= (*p_38)))))), 0x5.Ap+1)))), 0xC.FDA103p-85))))));
            if (p_35.f2.f2)
            { /* block id: 246 */
                float l_557 = 0x1.Bp-1;
                int32_t l_561 = 1L;
                struct S0 ****l_564[6][5] = {{&l_521,&l_521,&l_521,&l_521,(void*)0},{(void*)0,&l_521,&l_521,&l_521,&l_521},{(void*)0,&l_521,&l_521,&l_521,&l_521},{&l_521,(void*)0,&l_521,&l_521,&l_521},{&l_521,&l_521,&l_521,&l_521,&l_521},{&l_521,(void*)0,(void*)0,&l_521,(void*)0}};
                int i, j;
                for (l_451 = 0; (l_451 <= 1); l_451 += 1)
                { /* block id: 249 */
                    uint16_t l_556 = 0xC5A4L;
                    if (l_524.f4)
                        break;
                    if (((p_35.f2.f0 & 0x96AF4251CAB270CELL) && (l_523.f2.f1 | (safe_div_func_int8_t_s_s((((void*)0 != l_543) < (safe_add_func_int64_t_s_s(((safe_rshift_func_int16_t_s_u((*l_544), (safe_mod_func_uint16_t_u_u(((p_37.f2.f1 && ((safe_sub_func_int16_t_s_s((0x5A9A6146L >= (safe_mod_func_int64_t_s_s(((void*)0 != l_555), 0x66E385824E1A11DBLL))), 0xB718L)) || l_556)) & 65531UL), (*l_544))))) > 9UL), l_556))), p_35.f1)))))
                    { /* block id: 251 */
                        return p_35.f1;
                    }
                    else
                    { /* block id: 253 */
                        if (l_524.f4)
                            goto lbl_558;
                    }
                    for (p_35.f0 = 1; (p_35.f0 >= 0); p_35.f0 -= 1)
                    { /* block id: 258 */
                        int32_t **l_560 = &l_555;
                        (*p_38) = 0x1.6p+1;
                    }
                    (*p_38) = l_561;
                    for (p_37.f5 = 0; (p_37.f5 <= 1); p_37.f5 += 1)
                    { /* block id: 266 */
                        if (l_430)
                            goto lbl_562;
                    }
                }
                if ((~(l_564[0][0] != (*l_519))))
                { /* block id: 270 */
                    int32_t **l_567 = &l_555;
                    for (p_37.f3 = 0; (p_37.f3 != 28); p_37.f3 = safe_add_func_uint8_t_u_u(p_37.f3, 1))
                    { /* block id: 273 */
                        return l_523.f0;
                    }
                    (*l_567) = p_38;
                    /* statement id: 276 */
                    //assert ((l_555 >= &l_21[0].f6 && l_555 <= &l_21[1].f6));
                }
                else
                { /* block id: 277 */
                    int32_t *l_570 = (void*)0;
                    struct S1 *l_579[6][6][1] = {{{&l_524},{&l_524},{&l_524},{&l_524},{&l_524},{&l_524}},{{&l_524},{&l_524},{&l_524},{&l_524},{&l_524},{&l_524}},{{&l_524},{&l_524},{&l_524},{&l_524},{&l_524},{&l_524}},{{&l_524},{&l_524},{&l_524},{&l_524},{&l_524},{&l_524}},{{&l_524},{&l_524},{&l_524},{&l_524},{&l_524},{&l_524}},{{&l_524},{&l_524},{&l_524},{&l_524},{&l_524},{&l_524}}};
                    int i, j, k;
                    for (l_524.f0 = (-30); (l_524.f0 > (-15)); l_524.f0 = safe_add_func_int8_t_s_s(l_524.f0, 4))
                    { /* block id: 280 */
                        int32_t **l_571[1][8] = {{&l_555,&l_555,&l_570,&l_555,&l_555,&l_570,&l_555,&l_555}};
                        int i, j;
                        (*p_38) = 0x1.6p+1;
                        l_572 = l_570;
                        /* statement id: 282 */
                        assert (l_572 == 0);
                        l_561 = (*l_555);
                        if (l_561)
                            break;
                    }
                    /* facts after for loop */
                    //assert (l_572 == 0 || (l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6) || l_572 == &l_573);
                    (*p_38) = (((safe_div_func_float_f_f((((void*)0 == &p_38) != (safe_add_func_float_f_f((((((!(l_579[0][1][0] != (void*)0)) == (*p_38)) < l_561) <= (0xA.F447DEp+96 <= ((((safe_sub_func_float_f_f((((*l_544) == (*l_555)) > 0xC.EBF36Bp-47), l_561)) >= (**l_543)) <= 0x1.7p+1) < 0xB.97C236p-50))) != (*p_38)), l_561))), (*p_38))) > (*l_544)) > (*p_38));
                    return l_561;
                }
                /* facts after branching */
                //assert ((l_555 >= &l_21[0].f6 && l_555 <= &l_21[1].f6));
                for (l_525 = 0; (l_525 <= 1); l_525 += 1)
                { /* block id: 291 */
                    const struct S0 *l_585 = &l_524.f2;
                    l_572 = p_38;
                    /* statement id: 292 */
                    //assert ((l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
                    if (l_523.f3)
                        goto lbl_588;
                    for (p_37.f0 = 1; (p_37.f0 >= 0); p_37.f0 -= 1)
                    { /* block id: 295 */
                        struct S0 *l_584 = &l_524.f2;
                        (*l_572) = ((safe_rshift_func_int16_t_s_s((l_584 == l_585), 14)) != l_561);
                        (*l_572) = ((*l_544) != p_37.f2.f1);
                    }
                }
            }
            else
            { /* block id: 300 */
lbl_588:
                for (p_35.f5 = (-28); (p_35.f5 == 21); ++p_35.f5)
                { /* block id: 303 */
                    return p_39;
                }
                if (((((~((**l_543) < (safe_rshift_func_int16_t_s_u((0x6AL || (~3UL)), (safe_rshift_func_int16_t_s_s((*l_544), 6)))))) && (((&p_38 == l_595) > p_35.f0) ^ (p_35.f0 <= (safe_add_func_uint64_t_u_u((&l_485[5] != l_599), p_37.f1))))) != l_602[0]) & l_603))
                { /* block id: 307 */
                    uint32_t l_616 = 0x869FFA67L;
                    float *****l_629 = &l_625;
                    if ((p_37.f3 & 1UL))
                    { /* block id: 308 */
                        int64_t l_613 = (-3L);
                        if (l_523.f3)
                            goto lbl_562;
                        (*p_38) = (safe_mul_func_float_f_f((safe_sub_func_float_f_f(0x0.4p-1, (-(safe_div_func_float_f_f(((**l_543) < ((safe_add_func_float_f_f((l_613 <= (0xE.AEEC9Dp+87 > (0x0.E33C89p-19 > (*p_38)))), (!(*p_38)))) > (((l_615[0][8][1] != (*p_38)) < l_616) < (**l_543)))), 0x0.8p+1))))), 0x4.0E2CB6p+16));
                    }
                    else
                    { /* block id: 311 */
                        uint8_t l_647 = 3UL;
                        int32_t **l_650 = &l_572;
                        (**l_543) = (safe_rshift_func_uint16_t_u_u(l_619, ((safe_mod_func_int64_t_s_s((safe_mul_func_uint8_t_u_u((((l_624 == l_629) | 0x79373BE7L) & ((safe_add_func_uint8_t_u_u(((safe_mul_func_uint16_t_u_u(p_35.f4, ((((((safe_add_func_int32_t_s_s(((safe_rshift_func_int16_t_s_u((~(safe_lshift_func_uint8_t_u_s(((*l_572) | (((*l_572) >= (safe_div_func_uint64_t_u_u((((safe_lshift_func_uint16_t_u_u((*l_544), (l_647 && 0x6AL))) <= l_616) && p_37.f0), p_37.f1))) < (*l_555))), 0))), 8)) > p_35.f2.f1), l_648)) < l_647) >= l_649) >= (*l_555)) | p_37.f4) || l_647))) >= p_37.f4), 0xCBL)) ^ 0x94AB10429B1DE252LL)), 255UL)), p_37.f0)) & 5L)));
                        (*l_555) = p_37.f7;
                        (*l_650) = p_38;
                        /* statement id: 314 */
                        //assert ((l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
                        (*l_600) = (void*)0;
                        /* statement id: 315 */
                        //assert (l_601[0] == 0 || (l_601[0] >= &l_487[0] && l_601[0] <= &l_487[4]));
                    }
                    /* facts after branching */
                    //assert (l_601[0] == 0 || (l_601[0] >= &l_487[0] && l_601[0] <= &l_487[4]));
                    for (p_37.f0 = 0; (p_37.f0 == (-6)); p_37.f0 = safe_sub_func_int8_t_s_s(p_37.f0, 4))
                    { /* block id: 319 */
                        int32_t **l_653 = &l_544;
                        (*l_653) = (void*)0;
                        /* statement id: 320 */
                        assert (l_544 == 0);
                    }
                    /* facts after for loop */
                    assert (l_544 == 0 || l_544 == &l_524.f0);
                    (****l_657) = ((safe_div_func_float_f_f(((0x2.FAF08Ap+98 != ((-(l_657 == l_658)) != ((safe_add_func_float_f_f((((((*l_572) < (*p_38)) == (*l_555)) == (safe_sub_func_float_f_f((safe_mul_func_float_f_f((((void*)0 == l_665[2][0]) == l_666), l_667)), (-0x1.8p+1)))) <= 0x7.Cp-1), 0x0.2p+1)) <= (*p_38)))) > (*p_38)), (*p_38))) > (-0x8.Cp+1));
                }
                else
                { /* block id: 323 */
                    const float l_685 = 0x8.492064p-42;
                    for (l_517 = 0; (l_517 >= 4); l_517++)
                    { /* block id: 326 */
                        (***l_626) = (-0x5.Cp-1);
                        (**l_543) = (*l_555);
                    }
                    for (l_524.f1 = 0; (l_524.f1 == 22); l_524.f1++)
                    { /* block id: 332 */
                        (**l_543) = ((p_37.f0 == (safe_mod_func_uint16_t_u_u(((safe_rshift_func_uint8_t_u_u(254UL, ((safe_div_func_int32_t_s_s((((((safe_add_func_uint32_t_u_u(((void*)0 != l_680), ((*l_599) != l_681))) <= (p_37.f2.f0 == (safe_unary_minus_func_uint16_t_u((*l_572))))) < ((+(0xF7B7E6508FADB2A0LL & 0x0F0950F3F57A4AA7LL)) == l_684)) < p_35.f7) | 0xAEDBL), (*l_555))) > (*l_544)))) & p_37.f3), (*l_555)))) == 0x0A37516A470DBA1FLL);
                    }
                }
                /* facts after branching */
                assert (l_544 == 0 || l_544 == &l_524.f0);
                //assert (l_601[0] == 0 || (l_601[0] >= &l_487[0] && l_601[0] <= &l_487[4]));
            }
            /* facts after branching */
            assert (l_544 == 0 || l_544 == &l_524.f0);
            //assert (l_601[0] == 0 || (l_601[0] >= &l_487[0] && l_601[0] <= &l_487[4]));
            for (l_684 = 0; (l_684 == 41); l_684++)
            { /* block id: 339 */
                float l_706 = 0x1.0p-1;
                int32_t l_707 = 0L;
                struct S1 **l_746 = (void*)0;
                int32_t **l_812 = &l_555;
                float * const *l_820 = &l_628;
                float * const **l_819 = &l_820;
                if (((safe_mod_func_int64_t_s_s((~(safe_unary_minus_func_uint16_t_u(((safe_div_func_int32_t_s_s(((*l_599) != (*l_599)), (safe_mul_func_uint16_t_u_u((((safe_mul_func_int8_t_s_s((~(0UL && ((l_699 <= ((0xF0L | (0xABF8FBF6L < (((safe_add_func_uint64_t_u_u(((safe_mul_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u(4294967295UL, 0x723C1EC7L)), ((((p_37.f2.f2 ^ p_37.f2.f1) <= p_35.f4) >= 0x867D08A5304A824CLL) && 0x33843B2AB127AD8ELL))) >= (*l_572)), 0x239331E9EA60D25ALL)) != 0x80D72F90DE4CAEAALL) || p_37.f3))) != l_707)) > 0x66L))), (*l_555))) || 0x99A88A0F4EBAFB63LL) < 0L), (*l_572))))) >= 0x59B238248036C46FLL)))), p_35.f7)) != 0x85DBAB2EL))
                { /* block id: 340 */
                    float *****l_709 = &l_625;
                    for (l_525 = 0; (l_525 <= 0); l_525 += 1)
                    { /* block id: 343 */
                        uint32_t l_735 = 0x38ECF030L;
                        l_709 = l_708;
                        /* statement id: 344 */
                        assert (l_709 == 0);
                        (*l_572) = (safe_mul_func_uint8_t_u_u(((((~(&p_38 != l_713)) > ((((safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_u((safe_sub_func_int16_t_s_s((+(((*l_555) <= (((safe_div_func_uint64_t_u_u((safe_unary_minus_func_uint16_t_u((safe_mod_func_uint8_t_u_u(((safe_rshift_func_int16_t_s_s((((!((safe_mul_func_int16_t_s_s((((safe_mod_func_int32_t_s_s(l_735, p_35.f2.f1)) > (safe_mul_func_int8_t_s_s((safe_add_func_int8_t_s_s((p_38 == (void*)0), (safe_lshift_func_uint8_t_u_s((safe_div_func_int32_t_s_s((+0x7CL), p_37.f1)), 0)))), l_735))) <= p_37.f7), 0xFE9AL)) | (*l_572))) <= l_735) > (*l_555)), p_37.f2.f2)) > p_35.f1), p_35.f3)))), 0xDFB0D941AD4F1F5FLL)) >= p_37.f3) < (*l_555))) ^ l_707)), 6L)), 13)), (-6L))) < 0x7719L) >= (-3L)) <= 0x52542484L)) > p_35.f7) ^ 0x1CL), p_35.f3));
                        (*l_555) = 5L;
                        if (p_37.f7)
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_709 == 0 || l_709 == &l_625);
                    for (l_517 = 6; (l_517 >= 0); l_517 -= 1)
                    { /* block id: 351 */
                        uint8_t l_745 = 0xDDL;
                        if (p_35.f4)
                            break;
                        return l_745;
                    }
                    for (l_649 = 2; (l_649 <= 8); l_649 += 1)
                    { /* block id: 357 */
                        struct S1 ***l_747 = &l_746;
                        (*l_747) = func_64(p_38, l_746);
                        if (p_35.f4)
                            continue;
                    }
                }
                else
                { /* block id: 361 */
                    for (l_430 = 0; (l_430 <= 3); l_430 += 1)
                    { /* block id: 364 */
                        int i, j;
                        l_681 = (*l_519);
                    }
                }
                for (p_37.f1 = 0; (p_37.f1 <= 0); p_37.f1 += 1)
                { /* block id: 370 */
                    int32_t **l_791 = &l_555;
                    struct S0 *l_809 = &l_524.f2;
                    int i;
                    (****l_657) = (safe_mul_func_float_f_f((safe_add_func_float_f_f(((safe_sub_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_div_func_float_f_f(((safe_mul_func_float_f_f(l_602[p_37.f1], ((safe_add_func_float_f_f((safe_add_func_float_f_f(0x0.AA126Fp+99, ((safe_add_func_float_f_f((0x4.436679p-28 > (-0x1.0p-1)), l_602[p_37.f1])) < ((l_602[p_37.f1] != ((safe_add_func_float_f_f(((*p_38) <= (safe_mul_func_float_f_f(((*p_38) == (safe_sub_func_float_f_f((((safe_add_func_float_f_f((safe_div_func_float_f_f((safe_div_func_float_f_f((-(safe_add_func_float_f_f(l_707, (*p_38)))), l_707)), l_602[p_37.f1])), (*p_38))) >= (*p_38)) != (*p_38)), (*l_572)))), (*l_572)))), (-0x5.1p-1))) == 0xB.E8DED2p-56)) <= (*l_555))))), (-0x7.7p-1))) < (*p_38)))) <= (*p_38)), (*l_555))), 0x7.08106Dp+59)), (-0x1.4p-1))), l_602[p_37.f1])), 0x5.45F874p+73)) >= (*l_555)), (*l_555))), (-0x1.Ep-1)));
                    if (((p_37.f2.f2 && (*l_572)) >= (((safe_div_func_int64_t_s_s((safe_mul_func_uint16_t_u_u((&p_35 != &p_35), (safe_div_func_int32_t_s_s(((void*)0 != l_791), (**l_791))))), (safe_add_func_uint8_t_u_u((safe_unary_minus_func_uint32_t_u(l_707)), ((**l_519) == (**l_519)))))) == p_37.f1) == p_39)))
                    { /* block id: 372 */
                        (*l_555) = (safe_add_func_int8_t_s_s((*l_555), (((safe_rshift_func_int8_t_s_u((8L & ((safe_mod_func_int16_t_s_s(((p_37.f7 != (safe_sub_func_uint32_t_u_u(p_37.f2.f1, p_37.f2.f2))) == (safe_div_func_int16_t_s_s((safe_div_func_uint16_t_u_u((**l_791), l_707)), p_35.f2.f0))), (+(8L < (*l_572))))) | p_37.f1)), p_35.f2.f0)) == (**l_791)) & 0x87L)));
                    }
                    else
                    { /* block id: 374 */
                        struct S0 l_811 = {0x6D39E8EAE525FB52LL,-2,39748};
                        struct S0 *l_810 = &l_811;
                        if (l_808[8])
                            break;
                        l_810 = l_809;
                        /* statement id: 376 */
                        assert (l_810 == &l_524.f2);
                        return l_811.f1;
                    }
                    (***l_626) = (-0x1.7p-1);
                    for (p_35.f3 = 0; (p_35.f3 <= 0); p_35.f3 += 1)
                    { /* block id: 382 */
                        return p_37.f7;
                    }
                }
                (*l_812) = p_38;
                /* statement id: 386 */
                //assert ((l_555 >= &l_21[0].f6 && l_555 <= &l_21[1].f6));
                for (p_37.f5 = 0; (p_37.f5 <= 4); p_37.f5 += 1)
                { /* block id: 389 */
                    int32_t l_827 = 0L;
                    int i;
                    (*l_555) = ((((safe_rshift_func_uint8_t_u_s(((safe_rshift_func_int8_t_s_u(0x74L, (p_35.f3 && (&p_36 != &l_522[4][1][0])))) < (*l_555)), 7)) <= (l_487[p_37.f5] == l_487[p_37.f5])) < ((void*)0 != l_819)) != 0xA7L);
                    (*l_572) = ((safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_u(p_35.f3, ((safe_div_func_uint32_t_u_u(p_37.f4, p_35.f4)) ^ p_37.f4))), (*l_572))) && ((l_827 & (*l_572)) > (safe_div_func_uint8_t_u_u((*l_572), ((safe_mul_func_uint8_t_u_u((p_37.f1 <= p_37.f3), p_37.f3)) & 0xE0L)))));
                    if (l_827)
                        continue;
                    (*l_555) = (safe_mul_func_uint8_t_u_u((((safe_mul_func_uint16_t_u_u((p_39 < 255UL), (0xD9EAL == ((safe_unary_minus_func_uint64_t_u(p_37.f2.f1)) != (safe_sub_func_int64_t_s_s((safe_mod_func_uint64_t_u_u(((safe_sub_func_uint64_t_u_u(((safe_div_func_uint16_t_u_u((((4UL | p_37.f2.f2) >= ((**l_624) == (void*)0)) | (safe_mod_func_uint64_t_u_u((((void*)0 == &p_36) ^ p_35.f0), (*l_555)))), 1UL)) ^ p_37.f2.f0), 0xAA9D2AA6FFE8300ALL)) != (*l_555)), 18446744073709551606UL)), (*l_572))))))) | p_35.f0) | l_847), p_37.f2.f2));
                }
            }
        }
        else
        { /* block id: 396 */
            uint16_t l_877[10][7] = {{0x7F50L,0x6904L,0xD260L,0x6904L,0x7F50L,8UL,0xD260L},{65535UL,0x6239L,65530UL,0xA122L,0x5CDEL,1UL,7UL},{0UL,0xD1E3L,9UL,8UL,9UL,0xD1E3L,0UL},{65535UL,0xA122L,7UL,0x5CDEL,0x6239L,65533UL,65530UL},{0x7F50L,0xD1E3L,5UL,0x43E3L,0x7F50L,0x43E3L,5UL},{0x6239L,0x6239L,7UL,65530UL,65535UL,1UL,0xA122L},{9UL,0x6904L,9UL,0x43E3L,0UL,0x6904L,0UL},{0x5CDEL,65530UL,65530UL,0x5CDEL,65535UL,7UL,65533UL},{0x7F50L,8UL,0xD260L,8UL,0x7F50L,0x6904L,0xD260L},{1UL,0x6239L,0xA122L,0xA122L,0x6239L,1UL,65533UL}};
            int32_t * const l_883 = &l_808[8];
            struct S1 ****l_899 = (void*)0;
            float *** const l_938 = &l_713;
            float *** const *l_937 = &l_938;
            float *** const **l_936[7] = {&l_937,&l_937,&l_937,&l_937,&l_937,&l_937,&l_937};
            struct S0 ****l_952 = &l_521;
            int i, j;
            for (l_666 = (-12); (l_666 > 7); ++l_666)
            { /* block id: 399 */
                int32_t l_876[10] = {(-1L),1L,0x9A2329BFL,1L,(-1L),1L,0x39A4072BL,0xDAD375EAL,0x39A4072BL,1L};
                struct S1 **l_889 = (void*)0;
                struct S1 ***l_888[8] = {&l_889,&l_889,&l_889,&l_889,&l_889,&l_889,&l_889,&l_889};
                struct S1 ****l_890 = &l_888[2];
                int i;
                for (p_35.f0 = 0; (p_35.f0 > 15); p_35.f0 = safe_add_func_int8_t_s_s(p_35.f0, 5))
                { /* block id: 402 */
                    int32_t *l_880 = &l_876[0];
                    float ***l_882 = &l_713;
                    for (p_37.f5 = (-7); (p_37.f5 < 28); p_37.f5 = safe_add_func_uint32_t_u_u(p_37.f5, 1))
                    { /* block id: 405 */
                        uint64_t l_871 = 5UL;
                        int32_t **l_879[3];
                        int i;
                        for (i = 0; i < 3; i++)
                            l_879[i] = (void*)0;
                        (**l_543) = (safe_mod_func_uint64_t_u_u((!9UL), (safe_mod_func_uint64_t_u_u(p_37.f4, (safe_div_func_uint8_t_u_u(((((safe_div_func_int32_t_s_s(((safe_lshift_func_uint8_t_u_s((((void*)0 != p_38) > (safe_sub_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(((safe_rshift_func_int16_t_s_s((l_871 < (safe_rshift_func_uint16_t_u_s((*l_572), (safe_rshift_func_int8_t_s_s((p_35.f7 | (**l_543)), 3))))), l_871)) || 1UL), 14)), l_871))), 6)) != 0xF4L), p_37.f5)) != l_876[1]) == l_876[1]) || l_877[7][0]), p_37.f7))))));
                        if (l_878)
                            continue;
                        l_880 = (void*)0;
                        /* statement id: 408 */
                        assert (l_880 == 0);
                    }
                    /* facts after for loop */
                    assert (l_880 == 0 || (l_880 >= &l_876[0] && l_880 <= &l_876[9]));
                    (**l_543) = p_37.f3;
                    for (p_39 = 0; (p_39 <= 1); p_39 += 1)
                    { /* block id: 413 */
                        float ***l_881 = &l_713;
                        int32_t **l_884 = (void*)0;
                        int32_t **l_885 = &l_572;
                        int i;
                        (**l_713) = (l_881 == l_882);
                        if (l_876[(p_39 + 7)])
                            continue;
                        (*l_885) = l_883;
                        /* statement id: 416 */
                        assert ((l_572 >= &l_808[0] && l_572 <= &l_808[9]));
                        (**l_543) = (safe_sub_func_uint8_t_u_u((**l_885), p_35.f2.f1));
                    }
                }
                (*l_890) = l_888[2];
            }
            /* facts after for loop */
            //assert ((l_572 >= &l_808[0] && l_572 <= &l_808[9]) || l_572 == &l_573 || (l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
            for (l_878 = 0; (l_878 <= 6); l_878 += 1)
            { /* block id: 424 */
                const int32_t *l_892 = (void*)0;
                const int32_t **l_891 = &l_892;
                int32_t **l_895 = &l_544;
                int32_t ***l_894 = &l_895;
                int32_t ****l_893 = &l_894;
                struct S1 *l_922 = (void*)0;
                struct S1 **l_921 = &l_922;
                struct S1 ***l_920[5];
                struct S1 ****l_919 = &l_920[4];
                float ***l_933 = &l_713;
                struct S0 ***l_942 = &l_487[2];
                uint32_t l_970 = 0xD3A07160L;
                int8_t l_982 = 0L;
                int i;
                for (i = 0; i < 5; i++)
                    l_920[i] = &l_921;
                (*l_891) = p_38;
                /* statement id: 425 */
                //assert ((l_892 >= &l_21[0].f6 && l_892 <= &l_21[1].f6));
                (*l_893) = &l_891;
                /* statement id: 426 */
                assert (l_894 == &l_891);
            }
        }
        /* facts after branching */
        assert (l_544 == 0 || l_544 == &l_524.f0);
        //assert ((l_572 >= &l_808[0] && l_572 <= &l_808[9]) || l_572 == &l_573 || (l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
    }
    else
    { /* block id: 489 */
        int8_t l_1042[9];
        struct S0 l_1112 = {0xDB0DFAA057F91612LL,-2,-35829};
        struct S0 *l_1111 = &l_1112;
        int32_t *l_1120 = (void*)0;
        int i;
        for (i = 0; i < 9; i++)
            l_1042[i] = 0x41L;
        for (p_37.f0 = 0; (p_37.f0 <= (-26)); --p_37.f0)
        { /* block id: 492 */
            int64_t l_1039 = 0x7AF1175B05845710LL;
            return l_1039;
        }
lbl_1137:
        if ((((safe_mod_func_int16_t_s_s(p_37.f2.f2, (l_1042[5] ^ (safe_add_func_uint32_t_u_u(p_37.f4, p_37.f2.f0))))) != (!l_1042[5])) ^ l_1042[5]))
        { /* block id: 495 */
            int32_t *l_1052 = &l_573;
            float *** const l_1063 = (void*)0;
            float *** const *l_1062 = &l_1063;
            float *** const **l_1061 = &l_1062;
            int32_t * const *l_1089[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
            int32_t * const **l_1088 = &l_1089[0];
            int32_t * const ***l_1087 = &l_1088;
            int i;
            for (l_430 = 15; (l_430 == 54); ++l_430)
            { /* block id: 498 */
                float ***l_1060[5][2];
                float *** const *l_1059 = &l_1060[1][0];
                float *** const **l_1058 = &l_1059;
                int32_t l_1072 = (-3L);
                int i, j;
                for (i = 0; i < 5; i++)
                {
                    for (j = 0; j < 2; j++)
                        l_1060[i][j] = (void*)0;
                }
                (*p_38) = 0x2.4p+1;
                for (p_39 = 13; (p_39 < 35); p_39 = safe_add_func_uint32_t_u_u(p_39, 3))
                { /* block id: 502 */
                    if (p_35.f7)
                        break;
                }
                for (l_666 = (-19); (l_666 < (-15)); l_666++)
                { /* block id: 519 */
                    l_1061 = l_1058;
                    /* statement id: 520 */
                    assert (l_1061 == &l_1059);
                    for (p_35.f0 = 29; (p_35.f0 == (-6)); p_35.f0--)
                    { /* block id: 523 */
                        uint32_t l_1090[7] = {1UL,18446744073709551608UL,1UL,1UL,18446744073709551608UL,1UL,1UL};
                        int i;
                        (*l_572) = (safe_sub_func_float_f_f((-0x10.Dp+1), (safe_add_func_float_f_f(((safe_mul_func_float_f_f(l_1072, 0x1.Ap+1)) == (safe_mul_func_float_f_f((safe_add_func_float_f_f(((safe_mul_func_float_f_f(((*p_38) == (safe_add_func_float_f_f(((*p_38) != (-0x3.8p+1)), (safe_mul_func_float_f_f((safe_sub_func_float_f_f((safe_div_func_float_f_f(((void*)0 != l_1087), (*p_38))), 0x5.B3E011p+67)), (*p_38)))))), 0xE.BD168Ep-97)) < (*p_38)), 0x0.7p+1)), l_1090[0]))), l_1042[5]))));
                    }
                }
                /* facts after for loop */
                //assert (l_1061 == &l_1059 || l_1061 == dangling || l_1061 == &l_1062);
            }
            /* facts after for loop */
            //assert (l_1061 == dangling || l_1061 == &l_1062);
        }
        else
        { /* block id: 528 */
            int32_t *l_1091 = &l_573;
            int32_t **l_1092 = &l_572;
            (*l_1092) = l_1091;
        }
        if ((p_35.f7 || (l_1042[5] != p_37.f4)))
        { /* block id: 531 */
            float ****l_1110 = (void*)0;
            float *****l_1109 = &l_1110;
            const int32_t l_1113 = 0x5324DBF3L;
            int32_t l_1114 = 0xFE581335L;
            struct S0 ***l_1132 = &l_487[3];
            struct S0 ****l_1131[3][7] = {{&l_1132,&l_1132,&l_1132,&l_1132,&l_1132,&l_1132,&l_1132},{&l_1132,&l_1132,&l_1132,&l_1132,&l_1132,&l_1132,&l_1132},{&l_1132,&l_1132,&l_1132,&l_1132,&l_1132,&l_1132,&l_1132}};
            struct S0 *****l_1130 = &l_1131[1][2];
            const int32_t l_1134 = 0xFB69E4CAL;
            int i, j;
            if ((safe_add_func_int32_t_s_s((*l_572), (safe_sub_func_uint32_t_u_u((0x0AD8F698E28B7EE4LL & (safe_add_func_int16_t_s_s(((safe_sub_func_uint8_t_u_u(((safe_div_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_u((*l_572), 0)), l_1042[5])) != (safe_rshift_func_int8_t_s_s((p_37.f2.f1 != (((safe_mul_func_int64_t_s_s(((void*)0 != l_1109), ((void*)0 != l_1111))) > p_35.f3) != p_37.f0)), 0))), l_1113)) == 0x5F9A1D05L), l_1113))), l_1114)))))
            { /* block id: 532 */
                int32_t **l_1115 = &l_572;
                struct S0 *** const **l_1129 = &l_485[6];
                (*l_1115) = p_38;
                /* statement id: 533 */
                //assert ((l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
                (*p_38) = (safe_add_func_float_f_f((safe_sub_func_float_f_f((0xD.A4C00Bp-27 > ((&l_573 == l_1120) == (-0x1.3p+1))), (safe_add_func_float_f_f((safe_div_func_float_f_f(0x9.BBBF4Dp-78, (*l_572))), ((p_38 != &l_573) > (0x0.2p-1 == (*l_572))))))), 0x4.3p+1));
                (*l_1115) = p_38;
                (*l_572) = (safe_sub_func_uint8_t_u_u((safe_sub_func_uint64_t_u_u((*l_572), p_35.f2.f1)), (l_1129 != l_1130)));
            }
            else
            { /* block id: 537 */
                int32_t l_1136[4][3];
                struct S1 *l_1141 = (void*)0;
                int i, j;
                for (i = 0; i < 4; i++)
                {
                    for (j = 0; j < 3; j++)
                        l_1136[i][j] = 0xA15CCFF8L;
                }
                if (p_35.f1)
                { /* block id: 538 */
                    int32_t **l_1133 = &l_1120;
                    (*l_1133) = p_38;
                    /* statement id: 539 */
                    //assert ((l_1120 >= &l_21[0].f6 && l_1120 <= &l_21[1].f6));
                }
                else
                { /* block id: 540 */
                    int16_t l_1145 = 0xC4A7L;
                    if (l_1134)
                    { /* block id: 541 */
                        uint8_t l_1135 = 0x00L;
                        l_1135 = p_37.f5;
                        return l_1136[1][1];
                    }
                    else
                    { /* block id: 544 */
                        struct S1 l_1140 = {0xAB280E85L,0xCB9CL,{18446744073709551615UL,7,-45935},0L,0x46L,0UL,-0x7.Ap+1,-5};
                        struct S1 *l_1139 = &l_1140;
                        struct S1 **l_1138[4] = {&l_1139,&l_1139,&l_1139,&l_1139};
                        int32_t **l_1142[1][10][1] = {{{&l_1120},{&l_1120},{&l_1120},{&l_1120},{&l_1120},{&l_1120},{&l_1120},{&l_1120},{&l_1120},{&l_1120}}};
                        int i, j, k;
                        if (p_39)
                            goto lbl_1137;
                        l_1141 = &p_35;
                        /* statement id: 546 */
                        assert (l_1141 == &p_35);
                        l_1120 = (void*)0;
                    }
                    /* facts after branching */
                    assert (l_1141 == &p_35);
                    for (p_37.f3 = 0; (p_37.f3 != 26); ++p_37.f3)
                    { /* block id: 551 */
                        (*l_714) = l_1145;
                        return l_1136[0][2];
                    }
                    (*l_572) = p_35.f7;
                    return p_37.f5;
                }
                /* facts after branching */
                //assert ((l_1120 >= &l_21[0].f6 && l_1120 <= &l_21[1].f6));
            }
            /* facts after branching */
            //assert (l_572 == &l_573 || (l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
            //assert ((l_1120 >= &l_21[0].f6 && l_1120 <= &l_21[1].f6) || l_1120 == 0);
        }
        else
        { /* block id: 559 */
            int32_t **l_1146 = &l_1120;
            float **l_1157 = &l_714;
            (*l_1146) = p_38;
            /* statement id: 560 */
            //assert ((l_1120 >= &l_21[0].f6 && l_1120 <= &l_21[1].f6));
            for (p_37.f1 = (-6); (p_37.f1 <= (-4)); p_37.f1 = safe_add_func_uint8_t_u_u(p_37.f1, 5))
            { /* block id: 563 */
                int16_t l_1153[3][8][4] = {{{(-1L),(-1L),0xEDDBL,0xEDDBL},{0x07CCL,0x07CCL,(-1L),(-1L)},{(-1L),(-1L),(-1L),(-1L)},{0x07CCL,0x82E7L,0xEDDBL,(-1L)},{(-1L),0x82E7L,0x82E7L,(-1L)},{0x82E7L,(-1L),0x07CCL,(-1L)},{0x82E7L,0x07CCL,0x82E7L,0xEDDBL},{(-1L),(-1L),0xEDDBL,0xEDDBL}},{{0x07CCL,0x07CCL,(-1L),(-1L)},{(-1L),(-1L),(-1L),(-1L)},{0x07CCL,0x82E7L,0xEDDBL,(-1L)},{(-1L),0x82E7L,0x82E7L,(-1L)},{0x82E7L,(-1L),0x07CCL,(-1L)},{0x82E7L,0x07CCL,0x82E7L,0xEDDBL},{(-1L),(-1L),0xEDDBL,0xEDDBL},{0x07CCL,0x07CCL,(-1L),(-1L)}},{{(-1L),(-1L),(-1L),(-1L)},{0x07CCL,0x82E7L,0xEDDBL,(-1L)},{(-1L),0x82E7L,0x82E7L,(-1L)},{0x82E7L,(-1L),0x07CCL,(-1L)},{0x82E7L,0x07CCL,0x82E7L,0xEDDBL},{(-1L),(-1L),0xEDDBL,0xEDDBL},{0x07CCL,0x07CCL,(-1L),(-1L)},{(-1L),(-1L),(-1L),(-1L)}}};
                float ** const l_1156 = &l_714;
                int i, j, k;
                (*l_1146) = l_1120;
                (**l_1156) = (0x8.71248Ap-49 <= ((safe_mul_func_float_f_f((((*l_1120) < (0x8.4p-1 >= (safe_add_func_float_f_f(l_1153[2][0][3], (0x0.Ep-1 > ((((**l_1146) < ((safe_sub_func_float_f_f((l_1156 != l_1157), (*p_38))) < (*p_38))) <= (**l_1146)) <= (*p_38))))))) <= (*p_38)), (*p_38))) == 0xC.189DCBp-15));
            }
            (*l_1146) = &l_573;
            /* statement id: 567 */
            assert (l_1120 == &l_573);
        }
        /* facts after branching */
        //assert (l_572 == &l_573 || (l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
        //assert (l_1120 == &l_573 || (l_1120 >= &l_21[0].f6 && l_1120 <= &l_21[1].f6) || l_1120 == 0);
    }
    /* facts after branching */
    //assert (l_572 == dangling || l_572 == &l_573 || (l_572 >= &l_21[0].f6 && l_572 <= &l_21[1].f6));
    l_1160 = l_1158;
    /* statement id: 570 */
    assert (l_1160 == &l_1159);
    p_35.f2.f1 = p_35.f2.f0;
    for (p_37.f3 = 3; (p_37.f3 >= 0); p_37.f3 -= 1)
    { /* block id: 574 */
        uint64_t l_1164 = 0xD5A0D77AB9605D25LL;
        struct S0 ***l_1168[1][3][6] = {{{&l_487[2],&l_487[2],&l_487[2],&l_487[2],&l_487[2],&l_487[2]},{&l_487[2],&l_487[2],&l_487[2],&l_487[2],&l_487[2],&l_487[2]},{&l_487[2],&l_487[2],&l_487[2],&l_487[2],&l_487[2],&l_487[2]}}};
        int32_t **l_1199 = (void*)0;
        int32_t *** const l_1198 = &l_1199;
        int32_t ***l_1200 = &l_1199;
        struct S1 ***l_1238 = &l_1204;
        uint8_t l_1260 = 3UL;
        struct S1 ** const ***l_1315 = (void*)0;
        int32_t *l_1327[1][7][4];
        float l_1355 = 0x9.0FB562p+73;
        float l_1378 = (-0x1.7p+1);
        int i, j, k;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 7; j++)
            {
                for (k = 0; k < 4; k++)
                    l_1327[i][j][k] = &l_1206.f0;
            }
        }
        for (l_699 = 0; (l_699 <= 3); l_699 += 1)
        { /* block id: 577 */
            int32_t *l_1165 = (void*)0;
            int32_t **l_1166 = (void*)0;
            int32_t **l_1167 = &l_1163[1];
            if (l_1164)
                break;
            (*l_1167) = l_1165;
            for (p_35.f3 = 6; (p_35.f3 >= 2); p_35.f3 -= 1)
            { /* block id: 582 */
                int32_t l_1172[1];
                int i, j;
                for (i = 0; i < 1; i++)
                    l_1172[i] = 0x92B45852L;
                p_35.f0 = (p_37.f0 == (l_1168[0][1][2] == l_1168[0][2][4]));
                for (p_35.f1 = 3; (p_35.f1 >= 0); p_35.f1 -= 1)
                { /* block id: 586 */
                    int32_t *l_1169 = &l_573;
                    if (p_35.f4)
                        break;
                    (*l_1167) = l_1169;
                }
                p_35.f2.f1 = (safe_sub_func_int8_t_s_s(l_1164, l_1172[0]));
            }
        }
    }
    /* facts after for loop */
    //assert (l_1163[0] == 0 || l_1163[0] == &l_573);
    return p_35.f2.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1  func_41(uint8_t  p_42, uint32_t  p_43, int32_t  p_44)
{ /* block id: 200 */
    int32_t l_381[3][1];
    int32_t *l_380 = &l_381[1][0];
    struct S0 **l_391[7];
    struct S0 ***l_390[9] = {&l_391[1],&l_391[1],&l_391[1],&l_391[1],&l_391[1],&l_391[1],&l_391[1],&l_391[1],&l_391[1]};
    struct S1 *l_425 = (void*)0;
    struct S1 **l_424 = &l_425;
    struct S1 l_428 = {4L,6L,{0x77A6F6C273DC26DDLL,-7,-12152},0x9F92L,1L,18446744073709551608UL,0x3.Bp+1,7};
    int i, j;
    for (i = 0; i < 3; i++)
    {
        for (j = 0; j < 1; j++)
            l_381[i][j] = 0xD22A20EBL;
    }
    for (i = 0; i < 7; i++)
        l_391[i] = (void*)0;
    for (p_42 = (-10); (p_42 != 48); p_42 = safe_add_func_uint64_t_u_u(p_42, 1))
    { /* block id: 203 */
        int8_t l_365 = 0x22L;
        float l_376 = 0x6.7p+1;
        int32_t l_379 = 0x3D7F307CL;
        int32_t *l_378 = &l_379;
        int32_t **l_377[3][7][9] = {{{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378}},{{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378},{&l_378,(void*)0,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378},{&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378,&l_378,&l_378,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,&l_378,&l_378},{&l_378,(void*)0,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,&l_378,&l_378}},{{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378},{&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,&l_378,(void*)0,&l_378}}};
        int i, j, k;
        if ((safe_mul_func_uint8_t_u_u(p_44, (safe_add_func_uint64_t_u_u(18446744073709551607UL, l_365)))))
        { /* block id: 204 */
            const int32_t l_368 = 0x45DF1FDCL;
            const int32_t *l_367 = &l_368;
            const int32_t **l_366 = &l_367;
            (*l_366) = (void*)0;
            /* statement id: 205 */
            assert (l_367 == 0);
        }
        else
        { /* block id: 206 */
            uint64_t l_373 = 0x693ED229A9F4B684LL;
            int32_t l_375 = (-10L);
            int32_t *l_374[10] = {&l_375,&l_375,&l_375,&l_375,&l_375,&l_375,&l_375,&l_375,&l_375,&l_375};
            int i;
            p_44 = (safe_sub_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s(0x7285L, l_373)), 0x22L));
        }
        l_380 = (void*)0;
        /* statement id: 209 */
        assert (l_380 == 0);
        l_380 = &l_381[1][0];
        /* statement id: 210 */
        assert ((l_380 >= &l_381[0][0] && l_380 <= &l_381[2][0]));
    }
    for (p_42 = 1; (p_42 == 17); ++p_42)
    { /* block id: 214 */
        struct S0 l_389 = {18446744073709551608UL,10,-41401};
        struct S0 *l_388 = &l_389;
        struct S0 **l_387 = &l_388;
        struct S0 ***l_386 = &l_387;
        uint64_t l_398[3];
        float l_399 = 0x9.3E4CD2p+68;
        int64_t l_400 = 1L;
        const float *l_408 = &l_399;
        const float **l_407[8] = {&l_408,&l_408,&l_408,&l_408,&l_408,&l_408,&l_408,&l_408};
        struct S1 * const *l_426 = &l_425;
        float *l_427[3];
        int i;
        for (i = 0; i < 3; i++)
            l_398[i] = 18446744073709551607UL;
        for (i = 0; i < 3; i++)
            l_427[i] = &l_399;
        (*l_380) = ((safe_sub_func_uint8_t_u_u(((void*)0 == l_380), (((l_386 != l_390[2]) != ((*l_380) <= (4294967295UL <= ((safe_mod_func_uint32_t_u_u((p_44 != ((safe_div_func_int16_t_s_s(p_42, ((((safe_mod_func_uint32_t_u_u((((*l_380) && (*l_380)) & p_42), l_398[1])) && 0x2131L) > p_43) ^ p_43))) | (-1L))), l_398[1])) > p_42)))) ^ 0x6657B7ADCC200F24LL))) > l_400);
        (*l_380) = (l_398[1] != ((safe_add_func_float_f_f((safe_add_func_float_f_f((l_400 <= (*l_380)), (-0x3.Dp-1))), ((((p_42 < (safe_mul_func_float_f_f((((void*)0 != l_407[4]) == ((safe_sub_func_float_f_f((((((safe_sub_func_float_f_f(((-((safe_mul_func_float_f_f(((safe_mul_func_float_f_f((safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_mul_func_float_f_f(l_389.f0, (l_424 == l_426))), p_42)), p_43)), (*l_380))) < 0x1.2p+1), (*l_380))) <= p_44)) != l_389.f2), l_389.f1)) <= 0x7.DDAF82p-66) != 0x0.Cp-1) >= (*l_380)) >= p_43), l_389.f0)) != p_44)), p_42))) <= (*l_380)) > 0xA.0C00E2p+12) > 0x0.Fp+1))) <= (-0x2.5p-1)));
        if ((*l_380))
            break;
    }
    return l_428;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_45(struct S1 * p_46, uint16_t  p_47, struct S1 * p_48, uint8_t  p_49, uint32_t  p_50)
{ /* block id: 131 */
    float l_203 = 0x5.250DD0p+19;
    float *l_202 = &l_203;
    float **l_201 = &l_202;
    int32_t l_231 = 0x116458D0L;
    int32_t *l_230[2][9] = {{(void*)0,&l_231,(void*)0,(void*)0,&l_231,(void*)0,(void*)0,&l_231,(void*)0},{(void*)0,&l_231,(void*)0,(void*)0,&l_231,(void*)0,(void*)0,&l_231,(void*)0}};
    int32_t **l_229 = &l_230[0][6];
    struct S0 l_261 = {1UL,-9,12410};
    struct S0 *l_260 = &l_261;
    struct S0 ** const l_259 = &l_260;
    struct S0 ** const *l_258 = &l_259;
    float *l_277[4];
    uint32_t l_321 = 0x7CA8C6D9L;
    int i, j;
    for (i = 0; i < 4; i++)
        l_277[i] = &l_203;
    for (p_49 = 0; (p_49 >= 33); p_49++)
    { /* block id: 134 */
        float ***l_204 = &l_201;
        struct S0 l_208 = {0xDD8B250B62747BD2LL,2,-11295};
        struct S0 * const l_207 = &l_208;
        struct S0 * const *l_206[6] = {&l_207,&l_207,&l_207,&l_207,&l_207,&l_207};
        struct S0 * const **l_205[4][8][2] = {{{&l_206[3],&l_206[5]},{&l_206[5],(void*)0},{&l_206[5],&l_206[2]},{&l_206[2],&l_206[5]},{(void*)0,&l_206[5]},{&l_206[5],&l_206[5]},{&l_206[5],&l_206[1]},{&l_206[5],&l_206[5]}},{{&l_206[5],(void*)0},{&l_206[2],&l_206[5]},{&l_206[5],&l_206[5]},{&l_206[5],&l_206[5]},{(void*)0,&l_206[5]},{&l_206[5],&l_206[5]},{&l_206[5],&l_206[5]},{&l_206[2],(void*)0}},{{&l_206[5],&l_206[5]},{&l_206[5],&l_206[1]},{&l_206[5],&l_206[5]},{&l_206[5],&l_206[5]},{(void*)0,&l_206[5]},{&l_206[2],&l_206[2]},{&l_206[5],(void*)0},{&l_206[5],&l_206[5]}},{{&l_206[3],&l_206[5]},{&l_206[5],&l_206[3]},{&l_206[5],&l_206[3]},{&l_206[5],&l_206[3]},{&l_206[5],&l_206[5]},{&l_206[3],&l_206[5]},{&l_206[5],(void*)0},{&l_206[5],&l_206[2]}}};
        struct S0 *l_212 = &l_208;
        struct S0 **l_211[9] = {&l_212,&l_212,&l_212,&l_212,&l_212,&l_212,&l_212,&l_212,&l_212};
        struct S0 ***l_210 = &l_211[2];
        struct S0 ****l_209 = &l_210;
        const int32_t *l_240 = &l_231;
        int i, j, k;
        (*l_204) = l_201;
        (*l_209) = l_205[0][3][0];
        /* statement id: 136 */
        assert (l_210 == 0 || (l_210 >= &l_206[0] && l_210 <= &l_206[5]));
        for (p_47 = 0; (p_47 == 38); p_47 = safe_add_func_uint32_t_u_u(p_47, 8))
        { /* block id: 139 */
            struct S0 *****l_217 = (void*)0;
            const int32_t l_218 = 6L;
            int32_t **l_225 = (void*)0;
            const float *l_233 = &l_203;
            const float **l_232[8] = {&l_233,&l_233,&l_233,&l_233,&l_233,&l_233,&l_233,&l_233};
            struct S0 ** const *l_237 = &l_211[5];
            struct S0 ** const **l_236 = &l_237;
            struct S0 ** const ***l_235[6][8] = {{&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236},{&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236},{&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236},{&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236},{&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236},{&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236,&l_236}};
            struct S0 * const ****l_238 = (void*)0;
            struct S0 *****l_239 = &l_209;
            int32_t **l_241 = &l_230[1][7];
            int i, j;
            for (p_50 = (-3); (p_50 >= 57); p_50 = safe_add_func_int16_t_s_s(p_50, 6))
            { /* block id: 142 */
                float ***l_224 = &l_201;
                int32_t l_234 = 0xE037B79DL;
                l_208.f1 = (((void*)0 == l_217) < l_218);
                l_208.f1 = (!((safe_lshift_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u((((l_204 != l_224) < ((void*)0 != l_225)) != (+p_47)), (safe_lshift_func_int8_t_s_s(((void*)0 != l_229), 2)))), 1)) > ((l_232[0] == (*l_204)) ^ p_49)));
                l_234 = (-7L);
            }
            (*l_239) = &l_205[1][2][1];
            /* statement id: 147 */
            assert ((l_209 >= &l_205[0][0][0] && l_209 <= &l_205[3][7][1]));
            (*l_241) = l_240;
        }
        /* facts after for loop */
        assert ((l_209 >= &l_205[0][0][0] && l_209 <= &l_205[3][7][1]) || l_209 == &l_210);
        l_208.f1 = (((safe_sub_func_uint64_t_u_u(((~(p_47 || (0x8E46L && p_50))) | (((*l_240) ^ (safe_mul_func_uint16_t_u_u(p_49, (*l_240)))) || p_50)), p_49)) < (safe_mul_func_uint8_t_u_u((safe_add_func_uint16_t_u_u(p_47, (-6L))), (*l_240)))) ^ 18446744073709551612UL);
    }
    for (l_231 = (-29); (l_231 >= (-26)); ++l_231)
    { /* block id: 154 */
        int32_t *l_253 = (void*)0;
        (*l_229) = l_253;
        (**l_201) = p_49;
        l_253 = (*l_229);
        /* statement id: 157 */
        assert (l_253 == &l_231 || l_253 == 0);
    }
    for (p_50 = 0; (p_50 >= 56); ++p_50)
    { /* block id: 161 */
        int32_t * const l_266 = &l_231;
        float **l_286 = (void*)0;
        if ((safe_mod_func_int16_t_s_s((l_258 == &l_259), (safe_div_func_uint64_t_u_u(((safe_mul_func_int8_t_s_s(((((((void*)0 == &l_201) <= p_50) || p_49) != ((void*)0 != l_266)) && 0x7DL), p_50)) >= p_50), p_47)))))
        { /* block id: 162 */
            int32_t *l_267 = &l_231;
            (*l_229) = l_267;
            (*l_267) = p_47;
            if ((*l_267))
                continue;
        }
        else
        { /* block id: 166 */
            int32_t l_268 = 0x0DDB33CEL;
            const uint64_t l_290 = 0xB2EEEA668F69760BLL;
            uint64_t l_337[2];
            int i;
            for (i = 0; i < 2; i++)
                l_337[i] = 18446744073709551615UL;
            (*l_266) = l_268;
            if ((((l_268 > (!((*l_266) < p_47))) != (0L ^ (((0xA2L == ((safe_mod_func_int8_t_s_s((safe_mod_func_int64_t_s_s(l_268, ((p_50 == ((!((void*)0 != l_277[1])) <= p_49)) ^ p_49))), p_49)) != (*l_266))) != l_268) || p_50))) < 0UL))
            { /* block id: 168 */
                int16_t l_280[8][6][4] = {{{9L,0xDCECL,0x8AABL,(-7L)},{9L,0x8AABL,0x8AABL,9L},{9L,0x72D7L,0x417AL,(-1L)},{(-9L),0x946EL,(-1L),0x7379L},{(-1L),0x7379L,(-9L),0x7379L},{0x8AABL,0x946EL,0xDCECL,(-1L)}},{{0xF687L,0x72D7L,0x7379L,9L},{0xDCECL,0x8AABL,0x8AABL,0x8AABL},{0x7379L,0x7379L,(-9L),0x72D7L},{(-1L),0x8AABL,0x7379L,0x946EL},{9L,9L,0xF687L,0x7379L},{(-7L),9L,(-7L),0x946EL}},{{9L,0x8AABL,(-9L),0x72D7L},{0x72D7L,0x7379L,9L,0x8AABL},{0xDCECL,9L,9L,0xDCECL},{0x72D7L,0x946EL,(-9L),(-7L)},{9L,0x417AL,(-7L),(-9L)},{(-7L),(-9L),0xF687L,(-9L)}},{{9L,0x417AL,0x7379L,(-7L)},{(-1L),0x946EL,(-9L),0xDCECL},{0x7379L,9L,0x8AABL,0x8AABL},{0x7379L,0x7379L,(-9L),0x72D7L},{(-1L),0x8AABL,0x7379L,0x946EL},{9L,9L,0xF687L,0x7379L}},{{(-7L),9L,(-7L),0x946EL},{9L,0x8AABL,(-9L),0x72D7L},{0x72D7L,0x7379L,9L,0x8AABL},{0xDCECL,9L,9L,0xDCECL},{0x72D7L,0x946EL,(-9L),(-7L)},{9L,0x417AL,(-7L),(-9L)}},{{(-7L),(-9L),0xF687L,(-9L)},{9L,0x417AL,0x7379L,(-7L)},{(-1L),0x946EL,(-9L),0xDCECL},{0x7379L,9L,0x8AABL,0x8AABL},{0x7379L,0x7379L,(-9L),0x72D7L},{(-1L),0x8AABL,0x7379L,0x946EL}},{{9L,9L,0xF687L,0x7379L},{(-7L),9L,(-7L),0x946EL},{9L,0x8AABL,(-9L),0x72D7L},{0x72D7L,0x7379L,9L,0x8AABL},{0xDCECL,9L,9L,0xDCECL},{0x72D7L,0x946EL,(-9L),(-7L)}},{{9L,0x417AL,(-7L),(-9L)},{(-7L),(-9L),0xF687L,(-9L)},{9L,0x417AL,0x7379L,(-7L)},{(-1L),0x946EL,(-9L),0xDCECL},{0x7379L,9L,0x8AABL,0x8AABL},{0x7379L,0x7379L,(-9L),0x72D7L}}};
                int32_t **l_310 = &l_230[0][6];
                int i, j, k;
                if (((safe_mul_func_int16_t_s_s(((((p_50 || (((0x09A3L | (0xF95F1330DE8FBF34LL > (((l_280[4][2][2] && (safe_lshift_func_int8_t_s_s(p_49, 4))) == (+(p_50 < (l_286 != l_286)))) == (+(safe_mul_func_int8_t_s_s(p_49, l_268)))))) <= (*l_266)) > 0xB8L)) >= (*l_266)) ^ l_290) || l_268), 1L)) > p_50))
                { /* block id: 169 */
                    float ****l_311 = (void*)0;
                    int32_t l_330 = 3L;
                    for (p_49 = 19; (p_49 <= 58); p_49 = safe_add_func_int32_t_s_s(p_49, 2))
                    { /* block id: 172 */
                        struct S0 **l_300 = &l_260;
                        struct S0 ***l_299 = &l_300;
                        struct S0 ****l_298 = &l_299;
                        struct S0 *****l_297 = &l_298;
                        float *****l_312 = &l_311;
                        (*l_266) = (safe_sub_func_uint8_t_u_u((9L ^ (safe_lshift_func_uint8_t_u_s((*l_266), ((l_297 == &l_298) & ((safe_mod_func_int32_t_s_s((safe_mod_func_uint64_t_u_u((!p_49), 0xC06B8AFC5FDFF8A2LL)), (safe_lshift_func_int16_t_s_s((((0xBAA07DB0L != (((safe_lshift_func_uint8_t_u_u((*l_266), (&l_266 != l_310))) && p_50) == p_49)) < p_49) | 0x2E56490D080C8F7ELL), 2)))) & p_50))))), 0L));
                        (*l_312) = l_311;
                        (*l_310) = (*l_310);
                        (*l_310) = &l_268;
                    }
                    /* facts after for loop */
                    //assert (l_230[0][0] == &l_268 || l_230[0][0] == &l_231 || l_230[0][0] == 0);
                    if ((safe_mul_func_int16_t_s_s((0x6EFF648C51254CA7LL != (safe_add_func_int32_t_s_s((safe_lshift_func_int8_t_s_s((safe_mod_func_int16_t_s_s(l_321, (safe_sub_func_int64_t_s_s(((safe_div_func_int64_t_s_s((((p_47 ^ (((0x166EDB2B0423C186LL && ((((safe_lshift_func_int16_t_s_s((safe_sub_func_int8_t_s_s(l_330, l_330)), (safe_mod_func_uint64_t_u_u((safe_add_func_int16_t_s_s(p_47, (safe_mul_func_int8_t_s_s(l_330, p_50)))), 0x041D87F689F1D76BLL)))) | l_330) && p_49) || 18446744073709551615UL)) != (-1L)) <= 0xE385F3E3L)) & (*l_266)) & p_50), p_49)) >= l_337[0]), 0x1A930AC77B25053CLL)))), p_49)), l_330))), p_47)))
                    { /* block id: 178 */
                        return l_330;
                    }
                    else
                    { /* block id: 180 */
                        return l_330;
                    }
                }
                else
                { /* block id: 183 */
                    uint64_t l_340 = 0x309ED0CE8B5572DALL;
                    (*l_310) = (*l_310);
                    if (p_50)
                        break;
                    for (l_321 = (-30); (l_321 < 30); ++l_321)
                    { /* block id: 188 */
                        uint64_t l_347 = 0xCC1155B47B51DFCBLL;
                        (**l_201) = (l_340 < (-(safe_sub_func_float_f_f((-l_337[0]), ((((safe_add_func_float_f_f(((l_347 < (-0x7.Bp-1)) < (safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_mul_func_float_f_f((((*l_266) >= p_49) != l_337[0]), (safe_add_func_float_f_f(0x9.A1DFCFp+42, (safe_div_func_float_f_f((+p_47), p_50)))))), p_47)), p_49))), p_50)) <= l_337[0]) >= p_47) > 0x0.Dp-1)))));
                    }
                    (*l_310) = (*l_229);
                }
                return l_337[0];
            }
            else
            { /* block id: 194 */
                (*l_229) = (*l_229);
            }
        }
    }
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1 * func_51(uint32_t  p_52, uint32_t  p_53, const struct S1 * p_54, struct S1  p_55, uint32_t  p_56)
{ /* block id: 128 */
    struct S1 l_186 = {0x622F4865L,7L,{0xD7C05EB8092810F8LL,8,7355},0x53A1L,0xBAL,18446744073709551615UL,-0x1.7p+1,0};
    struct S1 *l_185 = &l_186;
    struct S1 *l_187 = &l_186;
    struct S1 *l_188 = &l_186;
    struct S1 *l_189 = &l_186;
    struct S1 *l_190 = &l_186;
    struct S1 *l_191[8][3] = {{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186},{&l_186,&l_186,&l_186}};
    struct S1 *l_192 = &l_186;
    struct S1 *l_193 = &l_186;
    struct S1 *l_194 = &l_186;
    struct S1 *l_195 = (void*)0;
    int i, j;
    l_185 = l_185;
    return l_195;
    /* statement id: 130 */
    //assert (func_51_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const struct S1 * func_59(const struct S0  p_60, uint64_t  p_61)
{ /* block id: 42 */
    int32_t l_108 = 8L;
    int32_t *l_107[9] = {&l_108,&l_108,&l_108,&l_108,&l_108,&l_108,&l_108,&l_108,&l_108};
    int32_t **l_106 = &l_107[4];
    float l_166[5] = {0x1.F72D6Ap-35,0x1.F72D6Ap-35,0x1.F72D6Ap-35,0x1.F72D6Ap-35,0x1.F72D6Ap-35};
    float *l_165 = &l_166[2];
    float **l_164 = &l_165;
    struct S1 l_183 = {0x915EF4D6L,0x3875L,{0x5C9793804D9622DCLL,-9,-10712},1L,0x8FL,2UL,-0x9.Ap-1,-7};
    struct S1 *l_182 = &l_183;
    const struct S1 *l_184 = (void*)0;
    int i;
    for (p_61 = 17; (p_61 >= 45); p_61 = safe_add_func_int32_t_s_s(p_61, 4))
    { /* block id: 45 */
        uint8_t l_96 = 0x68L;
        int32_t l_105 = 0L;
        int32_t *l_104 = &l_105;
        int32_t * const * const l_103 = &l_104;
        const struct S1 *l_132 = (void*)0;
        int32_t **l_156 = (void*)0;
        int32_t **l_157 = &l_107[3];
    }
    for (p_61 = 0; (p_61 <= 8); p_61 += 1)
    { /* block id: 93 */
        int16_t l_173 = 0xA95CL;
        int32_t l_174 = 3L;
        struct S1 l_180[4][4] = {{{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1},{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1}},{{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1},{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1}},{{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1},{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1}},{{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1},{0xD69E2DA4L,3L,{3UL,1,26014},1L,0xB0L,0x895242DE1A71A369LL,0x0.Ep+1,-7},{0x28952072L,0x0B3DL,{0x23124B1641BD3BCBLL,-6,-30530},0x8ED0L,-1L,3UL,0x2.CDFA42p+89,-1}}};
        const struct S1 *l_179 = &l_180[3][3];
        int i, j;
        for (l_108 = 8; (l_108 >= 3); l_108 -= 1)
        { /* block id: 96 */
            int32_t l_158 = (-1L);
            for (l_158 = 3; (l_158 <= 8); l_158 += 1)
            { /* block id: 99 */
                int32_t l_159 = 1L;
                int i;
                if (l_159)
                    break;
                for (l_159 = 14; (l_159 != (-8)); l_159 = safe_sub_func_int64_t_s_s(l_159, 1))
                { /* block id: 103 */
                    struct S1 l_163[8][10] = {{{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1}},{{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,-8L,{0UL,-5,-7400},2L,-1L,18446744073709551615UL,0x3.DF78E1p-55,-4},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{0x72706E00L,9L,{0x9F58EA2508C1DB4CLL,4,-21729},0x42F3L,-1L,0x1B26D052D8D885D1LL,0x1.95D16Dp+29,-0},{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,-8L,{0UL,-5,-7400},2L,-1L,18446744073709551615UL,0x3.DF78E1p-55,-4},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3}},{{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3}},{{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1}},{{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{0x5E85E3D3L,0xF892L,{0x54D7D783D8B82488LL,3,5646},0x69D0L,0x33L,0x59E8EBB9B1E83F6ALL,0xE.E87FF4p-15,-3},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{0x72706E00L,9L,{0x9F58EA2508C1DB4CLL,4,-21729},0x42F3L,-1L,0x1B26D052D8D885D1LL,0x1.95D16Dp+29,-0},{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{0x5E85E3D3L,0xF892L,{0x54D7D783D8B82488LL,3,5646},0x69D0L,0x33L,0x59E8EBB9B1E83F6ALL,0xE.E87FF4p-15,-3},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3}},{{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-6L,0x1ED2L,{1UL,-5,-36872},3L,0xB2L,0x9E97AACED721E8A3LL,0x2.819DA8p-24,-1},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3}},{{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-6L,-2L,{0x0315540926198889LL,-0,-37928},-1L,-2L,18446744073709551615UL,0xA.3A45DBp+76,2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-1L,0xE05EL,{0x5677DB30F1BED506LL,4,43931},0xD2D3L,0x70L,18446744073709551615UL,0x6.7FAE0Ap+80,-2},{0xB56FAF53L,0L,{0UL,-2,-11175},0xA012L,-6L,18446744073709551615UL,-0x2.Dp+1,1}},{{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,-8L,{0UL,-5,-7400},2L,-1L,18446744073709551615UL,0x3.DF78E1p-55,-4},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{0x72706E00L,9L,{0x9F58EA2508C1DB4CLL,4,-21729},0x42F3L,-1L,0x1B26D052D8D885D1LL,0x1.95D16Dp+29,-0},{0x443C5982L,0L,{1UL,-5,8306},-9L,0xD0L,0xF5F8C25799EF2C49LL,0xD.28BAAFp+0,2},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3},{-6L,-8L,{0UL,-5,-7400},2L,-1L,18446744073709551615UL,0x3.DF78E1p-55,-4},{1L,1L,{0xC44576A339AD12C7LL,-8,8997},-1L,1L,0x1399F0944A3940A6LL,0x0.4p-1,-3}}};
                    const struct S1 *l_162 = &l_163[6][7];
                    float ***l_167 = &l_164;
                    int i, j;
                    l_162 = (void*)0;
                    /* statement id: 104 */
                    assert (l_162 == 0);
                    (*l_167) = l_164;
                }
            }
            for (l_158 = (-18); (l_158 == (-11)); l_158 = safe_add_func_int64_t_s_s(l_158, 1))
            { /* block id: 110 */
                int32_t *l_170 = &l_158;
                (*l_106) = l_170;
            }
            /* facts after for loop */
            //assert (l_107[0] == &l_158 || l_107[0] == &l_108 || l_107[0] == dangling);
            l_174 = (safe_add_func_int64_t_s_s(l_173, (l_173 | p_60.f1)));
        }
        l_182 = &l_180[3][2];
        /* statement id: 125 */
        assert ((l_182 >= &l_180[0][0] && l_182 <= &l_180[3][3]));
    }
    /* facts after for loop */
    //assert (l_107[0] == dangling || l_107[0] == &l_108);
    //assert (l_182 == dangling || l_182 == &l_183);
    return l_184;
    /* statement id: 127 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const struct S0  func_62(struct S1 ** p_63)
{ /* block id: 40 */
    const struct S0 l_88 = {18446744073709551606UL,8,34177};
    return l_88;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S1 ** func_64(float * p_65, struct S1 ** p_66)
{ /* block id: 22 */
    int32_t l_69[5];
    int32_t l_70[6][5] = {{(-8L),6L,6L,(-8L),0xF1DDE4E4L},{0x4DC47558L,(-8L),(-6L),3L,3L},{0x6586993EL,(-8L),0x6586993EL,0xF1DDE4E4L,(-8L)},{3L,6L,0xF1DDE4E4L,3L,0xF1DDE4E4L},{3L,3L,(-6L),(-8L),0x4DC47558L},{0x6586993EL,0x4DC47558L,0xF1DDE4E4L,0xF1DDE4E4L,0x4DC47558L}};
    struct S1 l_87 = {0L,0x6DEAL,{0UL,7,10065},-1L,0x77L,0xC5754D5C1110172CLL,0x5.7p+1,-6};
    struct S1 *l_86 = &l_87;
    struct S1 **l_85 = &l_86;
    int i, j;
    for (i = 0; i < 5; i++)
        l_69[i] = 0x1120EAC2L;
    for (l_70[5][3] = 1; (l_70[5][3] <= 4); l_70[5][3] += 1)
    { /* block id: 25 */
        int32_t l_71 = 0x312ED856L;
        for (l_71 = 0; (l_71 <= 4); l_71 += 1)
        { /* block id: 28 */
            int32_t *l_72 = &l_70[5][3];
            int32_t **l_73 = &l_72;
            struct S0 l_75 = {0xDC049D9BB22B282FLL,-5,26080};
            const struct S0 *l_74 = &l_75;
            struct S0 *l_77 = &l_75;
            struct S0 **l_76 = &l_77;
            (*l_73) = l_72;
            (*l_76) = l_74;
            (*l_73) = p_65;
            /* statement id: 31 */
            //assert (l_72 == 0 || (l_72 >= &l_21[0].f6 && l_72 <= &l_21[1].f6));
        }
    }
    if (l_70[5][4])
    { /* block id: 34 */
        struct S0 * const l_80 = (void*)0;
        struct S0 * const *l_79 = &l_80;
        struct S0 * const **l_78 = &l_79;
        struct S0 **l_83 = (void*)0;
        struct S0 ***l_82 = &l_83;
        struct S0 ****l_81 = &l_82;
        (*l_81) = l_78;
        /* statement id: 35 */
        assert (l_82 == &l_79);
    }
    else
    { /* block id: 36 */
        int32_t *l_84 = &l_70[5][1];
        l_84 = l_84;
    }
    return p_66;
    /* statement id: 39 */
    //assert (func_64_rv == &l_20 || func_64_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 351
   depth: 1, occurrence: 1
   depth: 2, occurrence: 3
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 99
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 38
   indirect level: 2, occurrence: 13
   indirect level: 3, occurrence: 15
   indirect level: 4, occurrence: 15
   indirect level: 5, occurrence: 14
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 97
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 36
XXX times a single bitfield on LHS: 13
XXX times a single bitfield on RHS: 88

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 337
   depth: 2, occurrence: 85
   depth: 3, occurrence: 10
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 6
   depth: 13, occurrence: 3
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 7
   depth: 17, occurrence: 4
   depth: 18, occurrence: 3
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 26, occurrence: 4
   depth: 29, occurrence: 3
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 392

XXX times a variable address is taken: 809
XXX times a pointer is dereferenced on RHS: 233
breakdown:
   depth: 1, occurrence: 207
   depth: 2, occurrence: 20
   depth: 3, occurrence: 6
XXX times a pointer is dereferenced on LHS: 152
breakdown:
   depth: 1, occurrence: 124
   depth: 2, occurrence: 20
   depth: 3, occurrence: 3
   depth: 4, occurrence: 5
XXX times a pointer is compared with null: 66
XXX times a pointer is compared with address of another variable: 23
XXX times a pointer is compared with another pointer: 33
XXX times a pointer is qualified to be dereferenced: 1154

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 506
   level: 2, occurrence: 137
   level: 3, occurrence: 44
   level: 4, occurrence: 14
XXX number of pointers point to pointers: 250
XXX number of pointers point to scalars: 79
XXX number of pointers point to structs: 63
XXX percent of pointers has null in alias set: 27
XXX average alias set size: 1.27

XXX times a non-volatile is read: 1623
XXX times a non-volatile is write: 543
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 7

XXX stmts: 328
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 32
   depth: 2, occurrence: 50
   depth: 3, occurrence: 55
   depth: 4, occurrence: 80
   depth: 5, occurrence: 80

XXX percentage a fresh-made variable is used: 21.2
XXX percentage an existing variable is used: 78.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

