/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2470565160
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 2;
   signed f1 : 15;
   unsigned f2 : 21;
   unsigned f3 : 13;
   signed f4 : 8;
   signed f5 : 31;
   unsigned f6 : 1;
};

union U1 {
   const uint32_t  f0;
   const unsigned f1 : 18;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static uint16_t  func_31(void);
inline static int32_t * func_32(int32_t * p_33, uint8_t  p_34, int32_t * p_35);
static int32_t * func_36(int32_t  p_37, float  p_38, int64_t  p_39, uint32_t  p_40);
inline static uint16_t  func_44(int32_t * p_45, uint32_t  p_46, int32_t * const  p_47);
inline static int32_t * func_48(int32_t * p_49, int32_t  p_50);
inline static int32_t  func_57(const int16_t  p_58, const float  p_59, int32_t * p_60, int32_t * p_61);
inline static float  func_64(union U1  p_65, int32_t * p_66, int32_t * p_67);
static int32_t * func_69(int32_t  p_70, int32_t * p_71, int32_t  p_72, int32_t * const  p_73, uint8_t  p_74);
inline static struct S0 * func_77(const int32_t * p_78, uint64_t  p_79, int32_t * p_80, int32_t * p_81);
static uint16_t  func_86(int32_t * p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_31(void)
{ /* block id: 36 */
    int32_t l_41 = 9L;
    int32_t l_52 = 0x1636717BL;
    int32_t *l_51 = &l_52;
    int64_t l_203 = 0x04C175E38545A47ALL;
    float l_210 = (-0x1.7p+1);
    uint16_t l_211 = 65533UL;
    int32_t **l_225 = &l_51;
    uint16_t l_241 = 0xFBE2L;
    uint32_t l_255 = 0xA9ADD83BL;
    uint32_t l_259 = 1UL;
    int32_t l_260 = 0x2ECD07D7L;
    int64_t l_336 = 0xA66112EBCB51DA38LL;
    (*l_225) = func_32(func_36(((0x58F5537C57F39CEELL & l_41) || __builtin_ffsl(((uint16_t)0x2803L / (uint16_t)((__builtin_clzl(l_41) >= l_41) & func_44(func_48(l_51, (*l_51)), l_203, l_51))))), l_41, l_211, l_41), l_211, l_51);
    /* statement id: 118 */
    assert (l_51 == 0);
    if (((18446744073709551608UL <= __builtin_ffs(l_41)) & (-4L)))
    { /* block id: 119 */
        int32_t l_234 = (-5L);
        int32_t *l_242 = &l_234;
        (*l_242) = ((((uint64_t)l_41 - (uint64_t)(((uint16_t)0x9602L + (uint16_t)l_52) >= ((uint32_t)l_203 + (uint32_t)(((uint16_t)0x7F40L << (uint16_t)15) && l_234)))) <= (((uint16_t)((uint32_t)__builtin_parityll(l_211) % (uint32_t)((uint64_t)(l_234 || l_241) + (uint64_t)l_52)) + (uint16_t)l_234) || l_241)) | l_234);
    }
    else
    { /* block id: 121 */
        struct S0 l_252 = {1,-158,1409,11,7,17900,0};
        struct S0 *l_251 = &l_252;
        struct S0 **l_250 = &l_251;
        struct S0 ***l_249 = &l_250;
        int32_t *l_256 = &l_52;
        float *l_261 = &l_210;
        float **l_330 = &l_261;
        float ***l_329 = &l_330;
        float ****l_328 = &l_329;
lbl_313:
        for (l_41 = (-9); (l_41 == (-22)); l_41 -= 1)
        { /* block id: 124 */
            struct S0 l_248 = {1,-21,110,16,5,41495,0};
            struct S0 *l_247 = &l_248;
            struct S0 **l_246 = &l_247;
            struct S0 ***l_245 = &l_246;
            l_249 = l_245;
            /* statement id: 125 */
            assert (l_249 == &l_246);
        }
        (*l_261) = (((((float)((l_255 == l_252.f1) != (0x5.0A931Dp-38 != (func_86(l_256) >= (*l_256)))) + (float)((float)((void*)0 == (*l_250)) + (float)(*l_256))) < (*l_256)) < l_259) <= l_260);
        for (l_260 = 0; (l_260 > (-17)); --l_260)
        { /* block id: 130 */
            int32_t l_274 = (-2L);
            struct S0 ** const l_291 = &l_251;
            float ****l_331 = (void*)0;
            float *****l_333 = (void*)0;
            for (l_52 = (-7); (l_52 >= 19); l_52++)
            { /* block id: 133 */
                struct S0 ***l_277 = &l_250;
                int32_t l_278 = (-3L);
                struct S0 *l_332 = (void*)0;
                if (((int16_t)(((((((!(*l_256)) | ((int16_t)((*l_256) || (*l_256)) << (int16_t)11)) > (((!(*l_256)) < l_274) & 0UL)) == l_274) >= (((int16_t)(*l_256) >> (int16_t)__builtin_ffsll(__builtin_ctz(((l_277 != &l_250) > 0xED5EL)))) > (*l_256))) != l_278) <= l_278) >> (int16_t)l_274))
                { /* block id: 134 */
                    int32_t l_282 = 4L;
                    struct S0 **l_292 = &l_251;
                    int32_t *l_293 = (void*)0;
                    (*l_225) = &l_278;
                    /* statement id: 135 */
                    assert (l_51 == &l_278);
                    (*l_225) = func_36(((int32_t)(l_278 && 9UL) % (int32_t)(((~l_282) ^ ((*l_256) && __builtin_popcountl(l_278))) && ((uint16_t)65531UL << (uint16_t)13))), (-(float)(!((float)__builtin_popcount(((int16_t)(**l_225) / (int16_t)(*l_51))) / (float)0x1.Cp-1))), (*l_51), l_282);
                    /* statement id: 136 */
                    assert (l_51 == 0);
                    if ((l_291 != l_292))
                    { /* block id: 137 */
                        (*l_261) = __builtin_clzll(l_278);
                        l_293 = (void*)0;
                        l_274 = (((*l_225) != (void*)0) & (~(l_261 != (void*)0)));
                        if (l_274)
                            continue;
                    }
                    else
                    { /* block id: 142 */
                        uint32_t l_299 = 4294967295UL;
                        l_282 = ((uint32_t)(l_274 >= 0xC0EDF71B5F48D630LL) - (uint32_t)((uint16_t)l_299 << (uint16_t)1));
                        return l_278;
                    }
                    for (l_211 = 0; (l_211 >= 30); l_211 += 8)
                    { /* block id: 148 */
                        float * const *l_303 = &l_261;
                        float * const **l_302 = &l_303;
                        (*l_251) = (**l_291);
                        (*l_302) = &l_261;
                    }
                }
                else
                { /* block id: 152 */
                    uint32_t l_308 = 0x01ADFF82L;
                    uint32_t l_325 = 18446744073709551615UL;
                    if (((int64_t)((uint64_t)(*l_256) % (uint64_t)l_308) % (int64_t)((*l_256) & 0x5540F05B92934A2FLL)))
                    { /* block id: 153 */
                        float **l_310 = &l_261;
                        float *** const l_309 = &l_310;
                        float ** const *l_312 = &l_310;
                        float ** const **l_311 = &l_312;
                        (*l_311) = l_309;
                        if (l_260)
                            goto lbl_313;
                    }
                    else
                    { /* block id: 156 */
                        const int32_t l_314 = (-1L);
                        if (l_314)
                            break;
                        (*l_261) = ((float)((*l_256) < ((*l_256) == (((*l_256) < ((float)((__builtin_parityl(((l_314 ^ ((int16_t)func_44(l_261, l_308, &l_274) >> (int16_t)2)) || ((((uint32_t)(((((int32_t)func_44((*l_225), l_278, &l_278) / (int32_t)0x2A67AD85L) & l_278) <= (*l_256)) || (*l_256)) + (uint32_t)0x15CB5FD5L) != l_325) < 0x35AF17E0L))) == (*l_256)) == l_274) + (float)0x8.45C7DDp+1)) != (*l_256)))) - (float)l_278);
                    }
                }
                if (((int64_t)(-9L) - (int64_t)(((l_328 == l_331) && (*l_256)) != func_86(&l_274))))
                { /* block id: 161 */
                    (*l_225) = l_261;
                    /* statement id: 162 */
                    assert (l_51 == &l_210);
                    (***l_329) = ((**l_277) != l_332);
                    l_333 = &l_328;
                    /* statement id: 164 */
                    assert (l_333 == &l_328);
                }
                else
                { /* block id: 165 */
                    for (l_203 = (-8); (l_203 <= (-28)); l_203 -= 3)
                    { /* block id: 168 */
                        (*l_291) = (void*)0;
                        /* statement id: 169 */
                        assert (l_251 == 0);
                    }
                    /* facts after for loop */
                    assert (l_251 == 0 || l_251 == &l_252);
                    return l_278;
                }
                /* facts after branching */
                assert (l_51 == &l_210);
                assert (l_333 == &l_328);
            }
            /* facts after for loop */
            assert (l_333 == &l_328 || l_333 == 0);
            (*l_256) = l_274;
        }
    }
    /* facts after branching */
    assert (l_51 == &l_210 || l_51 == 0);
    return l_336;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_32(int32_t * p_33, uint8_t  p_34, int32_t * p_35)
{ /* block id: 116 */
    return p_33;
    /* statement id: 117 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(int32_t  p_37, float  p_38, int64_t  p_39, uint32_t  p_40)
{ /* block id: 111 */
    int32_t l_213 = 0xB0FEA248L;
    int32_t *l_212 = &l_213;
    int32_t **l_214 = &l_212;
    int32_t *l_216 = &l_213;
    int32_t *l_217 = &l_213;
    int32_t *l_218 = &l_213;
    int32_t *l_219 = &l_213;
    int32_t *l_220 = &l_213;
    int32_t *l_221 = &l_213;
    int32_t *l_222 = &l_213;
    int32_t *l_223 = &l_213;
    int32_t *l_224 = (void*)0;
lbl_215:
    (*l_212) = p_40;
    (*l_214) = &l_213;
    if (p_40)
        goto lbl_215;
    return l_224;
    /* statement id: 115 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_44(int32_t * p_45, uint32_t  p_46, int32_t * const  p_47)
{ /* block id: 108 */
    const struct S0 *l_205 = (void*)0;
    const struct S0 **l_204 = &l_205;
    float *l_206 = (void*)0;
    float l_208 = 0x1.6p+1;
    float *l_207 = &l_208;
    int32_t l_209 = 3L;
    (*l_207) = ((void*)0 == l_204);
    return l_209;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_48(int32_t * p_49, int32_t  p_50)
{ /* block id: 37 */
    int32_t l_56 = (-10L);
    int32_t *l_55 = &l_56;
    union U1 l_68 = {0x48C0C84AL};
    int32_t **l_202 = &l_55;
    (*l_55) = __builtin_parityll(((uint16_t)(l_55 == p_49) >> (uint16_t)(func_57((*l_55), ((*l_55) >= (((-0x3.0p+1) != ((((float)((((*l_55) == (*l_55)) != func_64(l_68, func_69(((*l_55) <= 1L), p_49, (*l_55), p_49, (*l_55)), &l_56)) != 0xB.12900Ep-34) + (float)0x1.BF4B6Fp+14) >= (-0x6.Dp+1)) == p_50)) > p_50)), &l_56, p_49) & 3UL)));
    (*l_202) = &l_56;
    return p_49;
    /* statement id: 107 */
    //assert (func_48_rv == &l_52);
}


/* ------------------------------------------ */
/* 
 * reads : l_52
 * writes: l_52
 */
inline static int32_t  func_57(const int16_t  p_58, const float  p_59, int32_t * p_60, int32_t * p_61)
{ /* block id: 74 */
    int32_t l_140 = 0x80E56630L;
    int32_t *l_139 = &l_140;
    int32_t **l_138 = &l_139;
    float l_142 = (-0x3.Fp-1);
    float *l_141 = &l_142;
    float *l_155 = &l_142;
    int32_t *l_168 = &l_140;
    uint16_t l_169 = 65535UL;
    int32_t *l_179 = &l_140;
    const uint32_t l_184 = 0x6F7C90A9L;
    const struct S0 l_191 = {1,53,728,63,-6,-25710,0};
    const struct S0 *l_190 = &l_191;
    const struct S0 **l_189 = &l_190;
    (*l_138) = p_60;
    /* statement id: 75 */
    //assert (l_139 == &l_56);
    (*l_141) = p_59;
    (*p_61) = (((((uint32_t)((uint64_t)(*l_139) + (uint64_t)func_86(p_61)) + (uint32_t)(p_58 ^ 0xA1ECA9F70EF1A537LL)) ^ (0xBB75L | (((0xE2A5121EL <= (*l_139)) >= (*l_139)) || (*p_61)))) == 0xA96B581468E88EEDLL) < (*l_139));
    if ((*p_60))
    { /* block id: 78 */
        float l_150 = 0x0.D7A3FEp+6;
        const int32_t l_151 = 6L;
        int32_t * const l_156 = &l_140;
        struct S0 **l_159 = (void*)0;
        int32_t *l_170 = &l_140;
        if ((*p_61))
        { /* block id: 79 */
            uint64_t l_147 = 18446744073709551615UL;
            (**l_138) = (**l_138);
            (**l_138) = l_147;
        }
        else
        { /* block id: 82 */
            const float l_154 = 0x0.5p-1;
            (*l_138) = func_69((*p_61), (*l_138), ((int32_t)((*l_139) & (((p_58 == (0xE9995DD1L >= l_151)) || ((uint64_t)p_58 % (uint64_t)(**l_138))) < ((void*)0 == l_155))) - (int32_t)p_58), l_156, p_58);
            /* statement id: 83 */
            assert (l_139 == 0);
        }
        /* facts after branching */
        //assert (l_139 == 0 || l_139 == &l_56);
        if (l_151)
            goto lbl_160;
lbl_160:
        (*p_61) = (0xAF8AL | ((*l_156) > ((uint64_t)((void*)0 == l_159) / (uint64_t)l_140)));
lbl_178:
        (*l_156) = (+(&p_61 != &l_139));
        for (l_140 = (-21); (l_140 <= (-20)); ++l_140)
        { /* block id: 90 */
            uint32_t l_166 = 0x696208B9L;
            float *l_167 = &l_142;
            uint64_t l_177 = 7UL;
            (*l_167) = ((float)(((p_58 >= (l_166 >= 0x8.51E9D5p+14)) <= ((void*)0 == l_167)) == (((func_86(func_69((func_86(p_61) < 6L), l_168, l_166, p_61, p_58)) > (-0x5.0p+1)) != l_169) > p_59)) / (float)0xB.12F4ECp-1);
            if (l_166)
            { /* block id: 92 */
                struct S0 **l_175 = (void*)0;
                int32_t * const l_176 = &l_140;
                (*l_138) = func_69((*l_156), func_69((*l_168), l_170, ((uint64_t)p_58 % (uint64_t)((uint32_t)(*l_168) - (uint32_t)(l_175 != l_159))), (*l_138), (*l_156)), p_58, l_176, l_177);
                /* statement id: 93 */
                assert (l_139 == 0);
                (*l_138) = p_60;
                /* statement id: 94 */
                //assert (l_139 == &l_56);
            }
            else
            { /* block id: 95 */
                if (l_177)
                    goto lbl_178;
                (*l_138) = p_60;
                /* statement id: 97 */
                //assert (l_139 == &l_56);
            }
            /* facts after branching */
            //assert (l_139 == &l_56);
        }
    }
    else
    { /* block id: 100 */
        uint16_t l_185 = 0x1F3FL;
        int32_t *l_188 = &l_140;
        (*l_138) = func_69((*l_168), l_179, (**l_138), func_69((((((uint16_t)(p_58 && ((uint16_t)((l_184 ^ (l_185 != ((uint64_t)__builtin_popcount((*l_168)) % (uint64_t)p_58))) != l_185) >> (uint16_t)l_185)) + (uint16_t)p_58) != l_185) == 0xD59F51D59E5908BELL) | 0x0378L), l_188, (*l_139), p_60, (*l_188)), (*l_179));
        /* statement id: 101 */
        assert (l_139 == 0);
        (*p_61) = func_86(func_69((l_189 != &l_190), func_69(((((p_58 ^ ((uint16_t)(*l_188) << (uint16_t)(__builtin_parityl((((uint16_t)(*l_179) - (uint16_t)(*l_188)) <= ((uint16_t)(*l_168) >> (uint16_t)3))) < ((int16_t)(((uint16_t)((void*)0 != l_188) % (uint16_t)8L) || p_58) << (int16_t)p_58)))) < (*p_60)) <= p_58) | (*l_188)), p_61, p_58, p_60, (*l_188)), p_58, p_61, (*l_188)));
    }
    /* facts after branching */
    //assert (l_139 == 0 || l_139 == &l_56);
    return (*p_61);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_64(union U1  p_65, int32_t * p_66, int32_t * p_67)
{ /* block id: 67 */
    int32_t l_133 = 0x431F4830L;
    for (l_133 = 0; (l_133 != 12); l_133 += 4)
    { /* block id: 70 */
        struct S0 l_136 = {0,171,736,41,-2,28024,0};
        struct S0 *l_137 = (void*)0;
        l_136 = l_136;
    }
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_69(int32_t  p_70, int32_t * p_71, int32_t  p_72, int32_t * const  p_73, uint8_t  p_74)
{ /* block id: 38 */
    int32_t l_83 = 0xEABF554CL;
    const int32_t *l_82 = &l_83;
    int32_t l_98 = 0xBC4638B1L;
    struct S0 l_124 = {0,-81,609,25,3,-32258,0};
    struct S0 *l_128 = &l_124;
    int32_t *l_129 = &l_83;
    int32_t *l_130 = &l_83;
    int32_t *l_131 = &l_83;
    int32_t *l_132 = (void*)0;
    for (p_74 = 8; (p_74 > 50); p_74 += 1)
    { /* block id: 41 */
        int32_t *l_88 = &l_83;
        struct S0 l_118 = {0,4,1182,11,0,40033,0};
        struct S0 *l_117 = &l_118;
        struct S0 **l_116 = &l_117;
        (*l_116) = func_77(l_82, __builtin_popcount(((uint16_t)func_86(l_88) - (uint16_t)(((*l_88) || (((int32_t)(4L == p_70) - (int32_t)((!((((&l_88 != &l_88) > (p_72 ^ (*l_88))) < 4294967287UL) != p_72)) || 0x9C36DE1F29A3A768LL)) || l_98)) | 0x879CFD24L))), l_88, &l_83);
        /* statement id: 50 */
        assert (l_117 == 0);
        (*l_88) = (*l_82);
        for (p_72 = 0; (p_72 < 9); p_72 += 1)
        { /* block id: 54 */
            int32_t **l_121 = &l_88;
            (*l_121) = &p_70;
            /* statement id: 55 */
            assert (l_88 == &p_70);
        }
        /* facts after for loop */
        assert (l_88 == &p_70 || l_88 == &l_83);
    }
    if ((*l_82))
    { /* block id: 58 */
        int32_t *l_123 = &l_83;
        int32_t **l_122 = &l_123;
        struct S0 *l_125 = &l_124;
        (*l_122) = &p_70;
        /* statement id: 59 */
        assert (l_123 == &p_70);
        (*l_122) = (*l_122);
        (*l_125) = l_124;
    }
    else
    { /* block id: 62 */
        int32_t *l_127 = &l_83;
        int32_t **l_126 = &l_127;
        (*l_126) = (void*)0;
        /* statement id: 63 */
        assert (l_127 == 0);
    }
    (*l_128) = l_124;
    return l_132;
    /* statement id: 66 */
    //assert (func_69_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 * func_77(const int32_t * p_78, uint64_t  p_79, int32_t * p_80, int32_t * p_81)
{ /* block id: 45 */
    int32_t l_100 = 0x9CE79000L;
    int32_t *l_99 = &l_100;
    int32_t **l_101 = &l_99;
    int64_t l_104 = 0x350090E7AF82577CLL;
    struct S0 l_109 = {0,139,473,35,-4,22979,0};
    struct S0 *l_110 = &l_109;
    struct S0 *l_111 = &l_109;
    struct S0 *l_112 = &l_109;
    struct S0 *l_113 = &l_109;
    struct S0 *l_114 = &l_109;
    struct S0 *l_115 = (void*)0;
    (*l_101) = l_99;
    (*p_80) = ((uint64_t)((**l_101) ^ (((l_104 < p_79) == __builtin_ctz((**l_101))) < (**l_101))) + (uint64_t)(4294967292UL ^ ((int64_t)((uint32_t)(*l_99) + (uint32_t)p_79) + (int64_t)4UL)));
    l_109 = l_109;
    return l_115;
    /* statement id: 49 */
    //assert (func_77_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_86(int32_t * p_87)
{ /* block id: 42 */
    int32_t l_90 = 0xD78BEA8EL;
    int32_t *l_89 = &l_90;
    int32_t **l_91 = (void*)0;
    int32_t **l_92 = (void*)0;
    int32_t **l_93 = &l_89;
    uint16_t l_94 = 65533UL;
    (*l_93) = l_89;
    return l_94;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 91
   depth: 1, occurrence: 3
XXX total union variables: 1

XXX non-zero bitfields defined in structs: 8
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 20
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 3
XXX full-bitfields structs in the program: 3
breakdown:
   indirect level: 0, occurrence: 3
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 2
XXX times a bitfields struct on RHS: 9
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 1

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 14
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2

XXX total number of pointers: 105

XXX times a variable address is taken: 92
XXX times a pointer is dereferenced on RHS: 78
breakdown:
   depth: 1, occurrence: 69
   depth: 2, occurrence: 9
XXX times a pointer is dereferenced on LHS: 44
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 2
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 8
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 383

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 281
   level: 2, occurrence: 34
   level: 3, occurrence: 2
XXX number of pointers point to pointers: 34
XXX number of pointers point to scalars: 55
XXX number of pointers point to structs: 16
XXX percent of pointers has null in alias set: 26.7
XXX average alias set size: 1.2

XXX times a non-volatile is read: 375
XXX times a non-volatile is write: 108
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 3

XXX stmts: 87
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 19
   depth: 2, occurrence: 9
   depth: 3, occurrence: 6
   depth: 4, occurrence: 10
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 14.1
XXX percentage an existing variable is used: 85.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

