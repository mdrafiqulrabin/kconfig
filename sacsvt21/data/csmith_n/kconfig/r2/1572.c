/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2285756952
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
inline static const int32_t * func_2(int8_t  p_3, uint64_t  p_4);
static int32_t * const  func_20(int32_t ** p_21, int16_t  p_22, uint32_t  p_23);
static int32_t ** func_24(int32_t  p_25, uint32_t  p_26, struct S0  p_27);
inline static int32_t  func_28(int32_t * p_29, int8_t  p_30, uint32_t  p_31);
inline static int32_t * func_32(struct S0  p_33, int64_t  p_34, const uint32_t  p_35, const int32_t * p_36);
static struct S0  func_37(uint32_t  p_38, struct S0  p_39);
static int32_t * func_46(struct S0  p_47, int32_t * p_48, float * const  p_49, uint16_t  p_50, int64_t  p_51);
inline static float * func_52(int32_t ** p_53, uint16_t  p_54, float * p_55, uint8_t  p_56, int32_t ** p_57);
inline static float * func_58(float * p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_5 = 0xADE2L;
    int32_t l_1187 = 0x7FE1D8E4L;
    int32_t *l_1186 = &l_1187;
    int32_t **l_1185[9];
    const int32_t *l_1188 = &l_1187;
    uint64_t l_1189[9] = {8UL,18446744073709551615UL,8UL,8UL,18446744073709551615UL,8UL,8UL,18446744073709551615UL,8UL};
    int i;
    for (i = 0; i < 9; i++)
        l_1185[i] = &l_1186;
    l_1188 = func_2(l_5, l_5);
    /* statement id: 595 */
    assert (l_1188 == 0);
    return l_1189[3];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_2(int8_t  p_3, uint64_t  p_4)
{ /* block id: 1 */
    int32_t l_12 = (-10L);
    const int32_t *l_11[4];
    int64_t l_15 = 0xBB4F5AC3D6C1DFE9LL;
    float * const ****l_1070 = (void*)0;
    float l_1083 = 0x0.7p+1;
    struct S0 l_1132[2] = {{6465},{6465}};
    struct S0 *l_1131 = &l_1132[1];
    struct S0 **l_1130[7] = {&l_1131,&l_1131,&l_1131,&l_1131,&l_1131,&l_1131,&l_1131};
    uint32_t l_1157 = 1UL;
    const int32_t *l_1164 = &l_12;
    const int32_t *l_1165 = &l_12;
    const int32_t *l_1166 = &l_12;
    const int32_t *l_1168 = &l_12;
    const int32_t *l_1169[2];
    uint16_t l_1178 = 0x2B2FL;
    const int32_t *l_1183[6] = {&l_12,&l_12,&l_12,&l_12,&l_12,&l_12};
    const int32_t *l_1184 = (void*)0;
    int i;
    for (i = 0; i < 4; i++)
        l_11[i] = &l_12;
    for (i = 0; i < 2; i++)
        l_1169[i] = &l_12;
    for (p_4 = 0; (p_4 < 23); ++p_4)
    { /* block id: 4 */
        int32_t l_10[10][5] = {{0x7963BA20L,0x4C000111L,2L,2L,0x4C000111L},{0x4C000111L,7L,0x7963BA20L,0x4C000111L,2L},{0x61E3FF14L,0x4C000111L,0xE649F6D4L,0x4C000111L,0x61E3FF14L},{0x7963BA20L,1L,7L,2L,1L},{0x61E3FF14L,7L,0xE649F6D4L,7L,0xB4C8F0D0L},{2L,7L,1L,0x7963BA20L,0x7963BA20L},{0x39BA095AL,7L,0x39BA095AL,0xB4C8F0D0L,7L},{0x7963BA20L,0xE649F6D4L,0xB4C8F0D0L,0x7963BA20L,0xB4C8F0D0L},{0x7963BA20L,0x7963BA20L,1L,7L,2L},{0x39BA095AL,2L,0xB4C8F0D0L,0xB4C8F0D0L,2L}};
        int32_t *l_9 = &l_10[6][2];
        int32_t **l_8 = &l_9;
        const int32_t *l_13[5] = {&l_12,&l_12,&l_12,&l_12,&l_12};
        const int32_t *l_14 = (void*)0;
        int i, j;
        (*l_8) = (void*)0;
        /* statement id: 5 */
        assert (l_9 == 0);
        return l_14;
        /* statement id: 6 */
        //assert (func_2_rv == 0);
    }
    if ((p_4 >= l_15))
    { /* block id: 8 */
        struct S0 l_40 = {-6343};
        int32_t *l_1061 = (void*)0;
        uint64_t l_1062[2][4] = {{0xCAEA57962160C3CDLL,0xCAEA57962160C3CDLL,0UL,0xCAEA57962160C3CDLL},{0xCAEA57962160C3CDLL,0xA1381E17F072368FLL,0xA1381E17F072368FLL,0xCAEA57962160C3CDLL}};
        float l_1069 = 0x7.7p+1;
        float * const l_1068 = &l_1069;
        float * const *l_1067 = &l_1068;
        float * const **l_1066 = &l_1067;
        float * const ***l_1065 = &l_1066;
        float * const ****l_1064 = &l_1065;
        int32_t **l_1118[3];
        int32_t ***l_1117 = &l_1118[0];
        struct S0 **l_1125 = (void*)0;
        struct S0 ***l_1124 = &l_1125;
        struct S0 ****l_1123[1][3];
        struct S0 *****l_1122[2][4][10] = {{{&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0},{&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0},{&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0},{&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0}},{{&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0},{&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0},{&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0},{&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0,(void*)0,(void*)0,&l_1123[0][0],(void*)0,&l_1123[0][0],(void*)0}}};
        const int32_t *l_1139 = (void*)0;
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_1118[i] = &l_1061;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 3; j++)
                l_1123[i][j] = &l_1124;
        }
        for (l_15 = (-22); (l_15 < (-1)); l_15 = safe_add_func_uint32_t_u_u(l_15, 7))
        { /* block id: 11 */
            struct S0 * const *l_789 = (void*)0;
            int32_t l_790 = (-1L);
            const int32_t *l_791 = &l_12;
            int32_t *l_1063 = &l_12;
            for (p_4 = 9; (p_4 < 30); p_4 = safe_add_func_int16_t_s_s(p_4, 7))
            { /* block id: 14 */
                struct S0 l_811 = {1707};
                int32_t *l_1059 = &l_790;
                int32_t **l_1058[8] = {&l_1059,&l_1059,&l_1059,&l_1059,&l_1059,&l_1059,&l_1059,&l_1059};
                int32_t **l_1060[5] = {&l_1059,&l_1059,&l_1059,&l_1059,&l_1059};
                int i;
                l_1061 = func_20(func_24(func_28(func_32(func_37(p_4, l_40), p_3, (((0xCBDCF325L < 0x7D033CE0L) != ((l_789 != (void*)0) ^ (l_790 & p_4))) | p_3), l_791), p_3, p_3), (*l_791), l_811), (*l_791), p_4);
            }
            (*l_1063) = l_1062[1][2];
        }
        l_1070 = l_1064;
        /* statement id: 554 */
        assert (l_1070 == &l_1065);
        if (((safe_lshift_func_uint8_t_u_s((0x787AC0B5193A20E7LL || (p_3 && p_3)), 6)) || (p_4 == (((((1L || ((safe_lshift_func_int16_t_s_s(((((safe_sub_func_uint8_t_u_u((safe_add_func_uint64_t_u_u((((*l_1070) == (*l_1070)) != ((void*)0 != &l_1065)), 0x524BE2F53E87D0F2LL)), p_4)) <= l_1062[1][2]) != 0xA6BDB0F4F16D7877LL) | p_4), 12)) < 0L)) & 0L) < p_3) || p_4) & 18446744073709551607UL))))
        { /* block id: 555 */
            struct S0 *l_1084 = &l_40;
            struct S0 **l_1085 = &l_1084;
            int32_t **l_1086[6];
            int i;
            for (i = 0; i < 6; i++)
                l_1086[i] = &l_1061;
            (*l_1085) = l_1084;
            l_11[3] = &l_12;
        }
        else
        { /* block id: 558 */
            int32_t l_1095 = (-1L);
            float *l_1101 = &l_1083;
            struct S0 l_1116 = {-3194};
            struct S0 ** const l_1129 = (void*)0;
            uint64_t l_1138 = 1UL;
            for (l_15 = 0; (l_15 > 4); l_15 = safe_add_func_int8_t_s_s(l_15, 4))
            { /* block id: 561 */
                float *l_1100 = (void*)0;
                int32_t l_1115 = 0xE2622323L;
                int32_t ***l_1119 = &l_1118[0];
                struct S0 l_1121 = {-2903};
                struct S0 ** const *l_1128 = (void*)0;
                struct S0 ** const **l_1127[4][9];
                struct S0 ** const ***l_1126[2];
                int i, j;
                for (i = 0; i < 4; i++)
                {
                    for (j = 0; j < 9; j++)
                        l_1127[i][j] = &l_1128;
                }
                for (i = 0; i < 2; i++)
                    l_1126[i] = &l_1127[0][4];
                if ((safe_div_func_int32_t_s_s((5UL > (6UL < 3UL)), (safe_sub_func_int8_t_s_s((l_1095 != (p_3 ^ (l_1095 > (safe_sub_func_int64_t_s_s(p_3, (p_4 && (((safe_lshift_func_uint16_t_u_s((l_1100 != l_1101), 8)) ^ 1L) & p_3))))))), l_1062[1][2])))))
                { /* block id: 562 */
                    const int32_t **l_1102 = (void*)0;
                    const int32_t **l_1103 = &l_11[2];
                    for (p_3 = 0; p_3 < 2; p_3 += 1)
                    {
                        for (l_1095 = 0; l_1095 < 4; l_1095 += 1)
                        {
                            l_1062[p_3][l_1095] = 0x8D49309AC1F38666LL;
                        }
                    }
                    (*l_1103) = (void*)0;
                    /* statement id: 564 */
                    //assert (l_11[0] == 0 || l_11[0] == &l_12);
                }
                else
                { /* block id: 565 */
                    float **l_1109 = &l_1101;
                    float ***l_1108 = &l_1109;
                    int32_t l_1114 = 0xBA446DB3L;
                    struct S0 *l_1120[7][2] = {{&l_40,&l_40},{&l_40,&l_40},{&l_40,&l_40},{&l_40,&l_40},{&l_40,&l_40},{&l_40,&l_40},{&l_40,&l_40}};
                    int i, j;
                    l_40 = func_37((safe_rshift_func_int8_t_s_u((safe_div_func_int64_t_s_s(p_3, (((*l_1065) == l_1108) | ((safe_sub_func_int8_t_s_s(2L, l_1114)) ^ ((((((((****l_1070) != (****l_1064)) | ((void*)0 == l_1070)) == (-8L)) | 0xC16A51F2F26E7B71LL) < l_1115) != l_1095) > p_4))))), 5)), l_1116);
                    l_1115 = (l_1117 != l_1119);
                    l_1121 = func_37(l_1116.f0, l_40);
                }
                /* facts after branching */
                //assert (l_11[0] == 0 || l_11[0] == &l_12);
                l_1115 = ((l_1122[0][0][3] != l_1126[1]) <= ((((((l_1129 != l_1130[5]) ^ (p_3 < 0x39L)) & (safe_rshift_func_int16_t_s_u((+(safe_add_func_int16_t_s_s((p_4 ^ 0x399F07E98B737396LL), 5UL))), 0))) < 1UL) <= l_1138) >= l_1095));
                return l_1139;
                /* statement id: 571 */
                //assert (func_2_rv == 0);
            }
        }
        (*****l_1064) = p_3;
    }
    else
    { /* block id: 575 */
        int32_t *l_1140 = &l_12;
        int64_t l_1156 = (-7L);
        const int32_t *l_1170 = (void*)0;
        float *l_1171 = &l_1083;
        (*l_1140) = (l_1070 != l_1070);
        for (p_4 = 0; (p_4 <= 3); p_4 += 1)
        { /* block id: 579 */
            int16_t l_1141 = 0xC2A9L;
            struct S0 l_1159 = {3393};
            int32_t *l_1160 = &l_12;
            int32_t **l_1161 = &l_1160;
            const int32_t *l_1162 = &l_12;
            const int32_t *l_1163 = &l_12;
            const int32_t *l_1167 = &l_12;
            int i;
            for (l_12 = 1; (l_12 >= 0); l_12 -= 1)
            { /* block id: 582 */
                float *l_1158[2];
                int i;
                for (i = 0; i < 2; i++)
                    l_1158[i] = &l_1083;
                if (l_1141)
                    break;
                l_1132[1].f0 = ((0x3.5B05E3p+72 >= (safe_div_func_float_f_f(((void*)0 == l_1130[(l_12 + 1)]), (0x0.7D3168p+28 >= (safe_div_func_float_f_f((safe_div_func_float_f_f(((0x5.0FEF83p-33 != (safe_div_func_float_f_f((((*l_1140) == (((((safe_add_func_float_f_f((safe_sub_func_float_f_f(((((((void*)0 == l_11[p_4]) != (safe_sub_func_float_f_f(0x9.6E36D3p-6, (*l_1140)))) == (*l_1140)) == l_1141) <= p_4), 0x3.C21320p-20)), (*l_1140))) != l_1156) != p_4) != l_1157) < p_4)) == p_3), 0x6.Cp+1))) != p_3), 0x7.AC1B11p-23)), (-0x9.6p+1))))))) < (*l_1140));
            }
            (*l_1131) = l_1159;
            (*l_1161) = l_1160;
            return l_1170;
            /* statement id: 588 */
            //assert (func_2_rv == 0);
        }
        (*l_1171) = p_4;
    }
    /* facts after branching */
    //assert (l_1070 == 0 || l_1070 == dangling);
    (*l_1131) = func_37(((safe_rshift_func_uint16_t_u_u((safe_add_func_int64_t_s_s(0x742D5B1DE9C24AB8LL, (safe_add_func_uint32_t_u_u((l_1178 <= p_4), (safe_mod_func_int32_t_s_s(p_3, (safe_rshift_func_int8_t_s_s(((*l_1168) <= 0x014FL), 3)))))))), 9)) & (((p_4 <= 0x07D5E0A3L) == ((&l_12 != &l_12) <= p_3)) < p_4)), (*l_1131));
    (*l_1131) = func_37((&l_1168 != &l_1169[0]), (*l_1131));
    return l_1184;
    /* statement id: 594 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_20(int32_t ** p_21, int16_t  p_22, uint32_t  p_23)
{ /* block id: 460 */
    int32_t l_840[4][3] = {{(-1L),1L,1L},{0x10AEBB1AL,0xBF87B359L,0xBF87B359L},{(-1L),1L,1L},{0x10AEBB1AL,0xBF87B359L,0xBF87B359L}};
    struct S0 **l_851 = (void*)0;
    struct S0 ** const **l_863 = (void*)0;
    int32_t *l_872 = &l_840[2][2];
    int32_t **l_871 = &l_872;
    int32_t ***l_870 = &l_871;
    int32_t ****l_869 = &l_870;
    uint64_t l_900 = 0xB9A48A82FD47C4F9LL;
    int32_t * const l_933 = &l_840[1][0];
    int32_t * const l_946 = &l_840[1][0];
    uint8_t l_979 = 0x78L;
    struct S0 l_983 = {3376};
    uint16_t l_997 = 0x3251L;
    const uint64_t l_998[4] = {7UL,7UL,7UL,7UL};
    int32_t * const l_1049 = &l_840[3][1];
    int32_t *l_1055[2];
    int32_t * const l_1057 = (void*)0;
    int i, j;
    for (i = 0; i < 2; i++)
        l_1055[i] = &l_840[1][0];
    for (p_23 = 0; (p_23 <= 2); p_23 += 1)
    { /* block id: 463 */
        int32_t *l_843 = &l_840[2][1];
        const float *l_853 = (void*)0;
        const float **l_852 = &l_853;
        int32_t ** const *l_874 = (void*)0;
        int32_t ** const **l_873[3];
        int32_t l_911 = (-1L);
        float l_930 = (-0x1.9p+1);
        int32_t * const l_947 = (void*)0;
        struct S0 ****l_955 = (void*)0;
        struct S0 ***l_957 = (void*)0;
        struct S0 ****l_956[1][1][1];
        float **l_986 = (void*)0;
        float ***l_985[1][10][3] = {{{&l_986,&l_986,&l_986},{&l_986,&l_986,(void*)0},{&l_986,&l_986,&l_986},{&l_986,&l_986,&l_986},{&l_986,&l_986,(void*)0},{&l_986,&l_986,&l_986},{&l_986,&l_986,&l_986},{&l_986,&l_986,&l_986},{&l_986,&l_986,(void*)0},{(void*)0,&l_986,&l_986}}};
        float ****l_984 = &l_985[0][4][2];
        int32_t * const l_1045 = &l_840[1][2];
        int32_t * const l_1048[9][4][7] = {{{&l_840[2][2],&l_840[0][2],&l_840[0][1],&l_840[3][0],&l_840[3][2],&l_840[1][0],&l_840[2][2]},{&l_840[2][0],&l_840[1][1],(void*)0,&l_840[2][2],&l_840[3][2],&l_840[0][2],&l_840[1][2]},{&l_840[1][1],&l_840[2][0],&l_840[0][2],&l_840[3][2],&l_840[3][1],&l_840[1][2],&l_840[1][2]},{&l_840[1][2],(void*)0,&l_840[0][1],(void*)0,&l_840[1][2],&l_840[2][0],&l_840[2][2]}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,&l_840[2][0],&l_840[2][1]},{&l_840[0][2],&l_840[3][1],(void*)0,&l_840[1][0],&l_840[2][1],&l_840[0][2],&l_840[3][0]},{&l_840[0][2],&l_840[2][0],&l_840[1][1],&l_840[3][1],&l_840[2][2],(void*)0,&l_840[3][2]},{(void*)0,&l_840[0][0],&l_840[1][2],&l_840[2][0],&l_840[1][1],&l_840[2][0],&l_840[1][2]}},{{(void*)0,(void*)0,&l_840[3][0],&l_840[2][2],&l_840[3][2],&l_840[0][0],&l_840[2][2]},{&l_840[1][2],&l_840[1][0],&l_840[3][1],&l_840[0][1],&l_840[1][2],&l_840[3][2],&l_840[3][1]},{&l_840[3][0],&l_840[0][0],&l_840[2][0],(void*)0,&l_840[3][2],(void*)0,(void*)0},{(void*)0,&l_840[3][0],&l_840[2][2],(void*)0,&l_840[1][1],&l_840[0][2],(void*)0}},{{&l_840[2][2],&l_840[1][2],&l_840[1][0],&l_840[2][0],&l_840[2][2],&l_840[2][1],&l_840[0][2]},{(void*)0,&l_840[2][0],&l_840[1][0],&l_840[2][0],&l_840[2][1],&l_840[3][2],&l_840[0][2]},{(void*)0,(void*)0,&l_840[1][2],&l_840[1][0],(void*)0,&l_840[0][0],&l_840[3][1]},{&l_840[1][0],&l_840[0][1],&l_840[1][1],&l_840[2][1],&l_840[1][2],(void*)0,&l_840[2][1]}},{{&l_840[1][2],&l_840[1][2],&l_840[1][0],&l_840[1][0],&l_840[3][1],(void*)0,&l_840[1][0]},{&l_840[1][2],&l_840[0][0],&l_840[1][0],&l_840[1][2],&l_840[3][2],&l_840[3][0],&l_840[2][2]},{&l_840[0][2],&l_840[2][2],&l_840[1][1],(void*)0,&l_840[3][2],&l_840[2][2],&l_840[1][0]},{&l_840[1][0],&l_840[0][0],&l_840[1][2],&l_840[3][1],&l_840[0][2],(void*)0,(void*)0}},{{(void*)0,&l_840[2][2],&l_840[1][0],(void*)0,&l_840[0][0],&l_840[3][1],&l_840[0][2]},{&l_840[0][0],(void*)0,&l_840[1][0],&l_840[1][1],&l_840[1][1],&l_840[1][2],&l_840[1][2]},{&l_840[0][1],&l_840[2][0],&l_840[2][2],&l_840[2][0],&l_840[0][1],(void*)0,&l_840[3][2]},{&l_840[2][1],&l_840[3][2],&l_840[2][0],&l_840[1][0],(void*)0,&l_840[1][1],&l_840[0][0]}},{{&l_840[3][2],&l_840[1][2],&l_840[3][1],&l_840[1][2],&l_840[2][0],&l_840[2][1],&l_840[2][0]},{&l_840[2][1],&l_840[1][0],&l_840[3][0],&l_840[1][1],(void*)0,&l_840[3][1],&l_840[1][2]},{&l_840[0][1],&l_840[3][2],&l_840[1][2],(void*)0,&l_840[1][2],&l_840[0][2],&l_840[2][2]},{&l_840[0][1],&l_840[2][1],&l_840[3][2],&l_840[2][1],&l_840[0][2],(void*)0,&l_840[3][0]}},{{&l_840[3][0],&l_840[2][2],&l_840[1][1],&l_840[3][1],&l_840[1][2],(void*)0,&l_840[2][2]},{&l_840[0][2],&l_840[0][0],&l_840[2][2],&l_840[1][0],&l_840[0][2],&l_840[3][0],(void*)0},{&l_840[2][2],&l_840[1][0],&l_840[3][0],(void*)0,&l_840[1][2],&l_840[3][2],&l_840[2][0]},{&l_840[3][1],&l_840[0][0],(void*)0,&l_840[0][2],&l_840[3][0],&l_840[3][2],&l_840[3][1]}},{{&l_840[1][0],(void*)0,&l_840[0][0],&l_840[3][1],&l_840[1][0],&l_840[3][0],&l_840[3][0]},{&l_840[1][1],&l_840[3][0],&l_840[0][0],&l_840[0][2],&l_840[3][1],(void*)0,&l_840[1][0]},{&l_840[1][0],&l_840[2][2],&l_840[3][0],&l_840[1][2],&l_840[1][0],(void*)0,(void*)0},{&l_840[2][1],&l_840[1][2],&l_840[0][0],&l_840[1][0],&l_840[3][0],&l_840[0][2],(void*)0}}};
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_873[i] = &l_874;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 1; j++)
            {
                for (k = 0; k < 1; k++)
                    l_956[i][j][k] = &l_957;
            }
        }
        for (p_22 = 0; (p_22 <= 2); p_22 += 1)
        { /* block id: 466 */
            int32_t *l_842 = &l_840[2][2];
            int32_t **l_841 = &l_842;
            float l_855 = 0x8.42E274p-82;
            float *l_854 = &l_855;
            int i, j;
            (*l_841) = (void*)0;
            /* statement id: 467 */
            assert (l_842 == 0);
            l_843 = l_843;
            (*l_854) = (safe_sub_func_float_f_f((safe_add_func_float_f_f(((((!l_840[3][2]) == l_840[0][1]) > (safe_div_func_float_f_f(((l_851 != (void*)0) <= ((void*)0 == l_843)), (p_22 <= (*l_843))))) >= (((void*)0 == l_852) >= p_23)), (*l_843))), 0x8.A3C5C0p-40));
            if (p_22)
                goto lbl_1056;
        }
        (*l_872) = (((safe_mod_func_int32_t_s_s(((+65534UL) && (7UL == (safe_add_func_uint32_t_u_u((safe_lshift_func_int16_t_s_s(((void*)0 == l_863), 14)), p_22)))), (safe_div_func_int16_t_s_s(((((+(safe_rshift_func_uint8_t_u_u(((l_869 != l_873[2]) | (**l_871)), 3))) || (safe_lshift_func_int8_t_s_s(0xACL, 0))) >= 0x1EL) && (*l_872)), (*l_843))))) | p_23) > p_22);
        for (p_22 = 0; (p_22 <= 2); p_22 += 1)
        { /* block id: 474 */
            uint16_t l_901 = 0xEFECL;
            const int32_t **l_920 = (void*)0;
            float *l_961 = &l_930;
            float **l_960 = &l_961;
            struct S0 l_992 = {-4549};
            struct S0 * const **l_1025 = (void*)0;
            int32_t * const l_1047 = &l_840[1][2];
            int i, j;
        }
    }
lbl_1056:
    l_1055[0] = (**l_870);
    (*l_871) = (**l_870);
    return l_1057;
    /* statement id: 549 */
    //assert (func_20_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_24(int32_t  p_25, uint32_t  p_26, struct S0  p_27)
{ /* block id: 448 */
    float l_821 = (-0x1.6p-1);
    int32_t l_826[4][4][7] = {{{(-1L),(-1L),(-1L),(-1L),0xC5353AFAL,1L,1L},{0xC58D3D2AL,(-1L),(-7L),(-1L),0xC58D3D2AL,(-1L),(-7L)},{0xC5353AFAL,(-1L),(-1L),(-1L),(-1L),0xC5353AFAL,1L},{0xD49D5A12L,(-6L),0xD49D5A12L,(-1L),0xD49D5A12L,(-6L),0xD49D5A12L}},{{0xC5353AFAL,(-1L),1L,(-1L),(-1L),1L,(-1L)},{0xC58D3D2AL,(-6L),(-7L),(-6L),0xC58D3D2AL,(-6L),(-7L)},{(-1L),(-1L),1L,(-1L),0xC5353AFAL,0xC5353AFAL,(-1L)},{0xD49D5A12L,(-1L),0xD49D5A12L,(-6L),0xD49D5A12L,(-1L),0xD49D5A12L}},{{(-1L),(-1L),(-1L),(-1L),0xC5353AFAL,1L,1L},{0xC58D3D2AL,(-1L),(-7L),(-1L),0xC58D3D2AL,(-1L),(-7L)},{0xC5353AFAL,(-1L),(-1L),(-1L),(-1L),0xC5353AFAL,1L},{0xD49D5A12L,(-6L),0xD49D5A12L,(-1L),0xD49D5A12L,(-6L),0xD49D5A12L}},{{0xC5353AFAL,(-1L),1L,(-1L),(-1L),1L,(-1L)},{0xC58D3D2AL,(-6L),(-7L),(-6L),0xC58D3D2AL,(-6L),(-7L)},{(-1L),(-1L),1L,(-1L),0xC5353AFAL,0xC5353AFAL,(-1L)},{0xD49D5A12L,(-1L),0xD49D5A12L,(-6L),0xD49D5A12L,(-1L),0xD49D5A12L}}};
    int32_t *l_825 = &l_826[3][0][0];
    int32_t ** const l_824 = &l_825;
    int32_t **l_839 = (void*)0;
    int i, j, k;
    for (p_26 = 0; (p_26 > 41); ++p_26)
    { /* block id: 451 */
        float l_816[5][10][4] = {{{(-0x1.Ep+1),0x0.0p-1,0x3.5p-1,0x2.112F88p+74},{0xB.C13A8Ep-70,0xC.2C970Fp-14,0xB.C13A8Ep-70,(-0x5.Bp+1)},{0x6.996C45p+82,0x5.FA6A8Fp-43,0x5.Bp-1,0xE.31B656p-37},{0x0.0p-1,0x1.Fp+1,0x0.Dp+1,(-0x5.Bp+1)},{0x5.Bp-1,0x3.5p-1,0x0.Dp+1,(-0x9.9p+1)},{0xC.2C970Fp-14,0x5.Bp-1,0x5.551E88p+82,0x0.9p-1},{0xB.C13A8Ep-70,0x0.6p+1,0xE.0FCC9Bp+83,0xE.0FCC9Bp+83},{0xE.0FCC9Bp+83,0xE.0FCC9Bp+83,0x0.6p+1,0xB.C13A8Ep-70},{0x0.9p-1,0x5.551E88p+82,0x5.Bp-1,0xC.2C970Fp-14},{(-0x9.9p+1),0x0.Dp+1,0x3.5p-1,0x5.Bp-1}},{{(-0x5.Bp+1),0x0.Dp+1,0x6.996C45p+82,0xC.2C970Fp-14},{0x0.Dp+1,0x5.551E88p+82,(-0x5.Bp+1),0xB.C13A8Ep-70},{(-0x1.Ap-1),0xE.0FCC9Bp+83,0x0.3p+1,0xE.0FCC9Bp+83},{0x0.8p+1,0x0.6p+1,0xC.2C970Fp-14,0x0.9p-1},{0x5.FA6A8Fp-43,0x5.Bp-1,0xE.31B656p-37,(-0x9.9p+1)},{0x0.3p+1,0x3.5p-1,0x0.7p+1,(-0x5.Bp+1)},{0x0.3p+1,0x6.996C45p+82,0xE.31B656p-37,0x0.Dp+1},{0x5.FA6A8Fp-43,(-0x5.Bp+1),0xC.2C970Fp-14,(-0x1.Ap-1)},{0x0.8p+1,0x0.3p+1,0x0.3p+1,0x0.8p+1},{(-0x1.Ap-1),0xC.2C970Fp-14,(-0x5.Bp+1),0x5.FA6A8Fp-43}},{{0x0.Dp+1,0xE.31B656p-37,0x6.996C45p+82,0x0.3p+1},{(-0x5.Bp+1),0x0.7p+1,0x3.5p-1,0x0.3p+1},{(-0x9.9p+1),0xE.31B656p-37,0x5.Bp-1,0x5.FA6A8Fp-43},{0x0.9p-1,0xC.2C970Fp-14,0x0.6p+1,0x0.8p+1},{0xE.0FCC9Bp+83,0x0.3p+1,0xE.0FCC9Bp+83,(-0x1.Ap-1)},{0xB.C13A8Ep-70,(-0x5.Bp+1),0x5.551E88p+82,0x0.Dp+1},{0xC.2C970Fp-14,0x6.996C45p+82,0x0.Dp+1,(-0x5.Bp+1)},{0x5.Bp-1,0x3.5p-1,0x0.Dp+1,(-0x9.9p+1)},{0xC.2C970Fp-14,0x5.Bp-1,0x5.551E88p+82,0x0.9p-1},{0xB.C13A8Ep-70,0x0.6p+1,0xE.0FCC9Bp+83,0xE.0FCC9Bp+83}},{{0xE.0FCC9Bp+83,0xE.0FCC9Bp+83,0x0.6p+1,0xB.C13A8Ep-70},{0x0.9p-1,0x5.551E88p+82,0x5.Bp-1,0xC.2C970Fp-14},{(-0x9.9p+1),0x0.Dp+1,0x3.5p-1,0x5.Bp-1},{(-0x5.Bp+1),0x0.Dp+1,0x6.996C45p+82,0xC.2C970Fp-14},{0x0.Dp+1,0x5.551E88p+82,(-0x5.Bp+1),0xB.C13A8Ep-70},{(-0x1.Ap-1),0xE.0FCC9Bp+83,0x0.3p+1,0xE.0FCC9Bp+83},{0x0.8p+1,0x0.6p+1,0xC.2C970Fp-14,0x0.9p-1},{0x5.FA6A8Fp-43,0x5.Bp-1,0xE.31B656p-37,(-0x9.9p+1)},{0x0.3p+1,0x3.5p-1,0x0.7p+1,(-0x5.Bp+1)},{0x0.3p+1,0x6.996C45p+82,0xE.31B656p-37,0x0.Dp+1}},{{0x5.FA6A8Fp-43,(-0x5.Bp+1),0xC.2C970Fp-14,(-0x1.Ap-1)},{0x0.8p+1,0x0.3p+1,0x0.3p+1,0x0.8p+1},{(-0x1.Ap-1),0xC.2C970Fp-14,(-0x5.Bp+1),0x5.FA6A8Fp-43},{0x0.Dp+1,0xE.31B656p-37,0x6.996C45p+82,0x0.3p+1},{(-0x5.Bp+1),0x0.7p+1,0x3.5p-1,0x0.3p+1},{(-0x9.9p+1),0xE.31B656p-37,0x5.Bp-1,0x5.FA6A8Fp-43},{0x0.9p-1,0xC.2C970Fp-14,0x0.6p+1,0x0.8p+1},{0xE.0FCC9Bp+83,0x0.3p+1,0xE.0FCC9Bp+83,(-0x1.Ap-1)},{0xB.C13A8Ep-70,(-0x5.Bp+1),0x5.551E88p+82,0x0.Dp+1},{0xC.2C970Fp-14,0x6.996C45p+82,0x0.Dp+1,(-0x5.Bp+1)}}};
        int32_t l_833 = 0xA165EB98L;
        float *l_834 = &l_821;
        int i, j, k;
        (*l_834) = (safe_sub_func_float_f_f(0x2.FE52DCp+8, (l_816[0][3][3] != (((safe_sub_func_float_f_f(((safe_sub_func_float_f_f(((l_821 == ((((safe_sub_func_float_f_f(((l_824 == (void*)0) >= (0x0.8609B4p-93 != 0x8.Ep+1)), (*l_825))) > ((safe_add_func_float_f_f(((((safe_div_func_float_f_f((safe_div_func_float_f_f((**l_824), p_27.f0)), l_833)) <= l_833) >= p_25) > p_25), p_27.f0)) > (**l_824))) <= (**l_824)) == (**l_824))) < (*l_825)), 0xF.97FD8Cp+92)) < 0x2.F7DF5Ep+0), 0x9.94F781p+56)) == p_27.f0) <= 0x0.3C4892p-75))));
    }
    for (p_25 = 0; (p_25 == 19); p_25 = safe_add_func_int16_t_s_s(p_25, 3))
    { /* block id: 456 */
        struct S0 l_837 = {-2700};
        int32_t *l_838 = &l_826[3][0][0];
        (*l_824) = func_46(l_837, l_838, l_838, (*l_838), ((-1L) & (p_25 >= p_25)));
    }
    return l_839;
    /* statement id: 459 */
    //assert (func_24_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_28(int32_t * p_29, int8_t  p_30, uint32_t  p_31)
{ /* block id: 439 */
    struct S0 l_802 = {-1933};
    struct S0 *l_801 = &l_802;
    int32_t **l_810 = (void*)0;
    for (p_30 = 9; (p_30 != 15); p_30++)
    { /* block id: 442 */
        struct S0 **l_803 = (void*)0;
        struct S0 **l_804 = &l_801;
        float l_806 = 0x1.758417p-80;
        float *l_805 = &l_806;
        int32_t l_809 = 0L;
        int32_t *l_808[1];
        int32_t **l_807 = &l_808[0];
        int i;
        for (i = 0; i < 1; i++)
            l_808[i] = &l_809;
        (*l_804) = l_801;
        (*l_805) = p_31;
        l_810 = l_807;
        /* statement id: 445 */
        assert ((l_810 >= &l_808[0] && l_810 <= &l_808[0]));
    }
    /* facts after for loop */
    //assert (l_810 == dangling || l_810 == 0);
    return p_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_32(struct S0  p_33, int64_t  p_34, const uint32_t  p_35, const int32_t * p_36)
{ /* block id: 436 */
    int32_t *l_794 = (void*)0;
    int32_t **l_793 = &l_794;
    int32_t ***l_792 = &l_793;
    int32_t ****l_795 = &l_792;
    int32_t l_797 = 0x5F01CFA5L;
    int32_t *l_796 = &l_797;
    int32_t *l_798 = (void*)0;
    (*l_795) = l_792;
    return l_798;
    /* statement id: 438 */
    //assert (func_32_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_37(uint32_t  p_38, struct S0  p_39)
{ /* block id: 15 */
    int32_t l_43 = 0x285F402BL;
    int32_t *l_42 = &l_43;
    int32_t **l_41 = &l_42;
    float l_45 = 0x0.2p+1;
    float *l_44 = &l_45;
    float *l_60 = (void*)0;
    float l_745 = 0xF.BC3E05p-51;
    int32_t l_746 = 0x253B93B8L;
    int32_t ****l_766[5];
    int32_t ***l_780 = (void*)0;
    struct S0 l_788 = {2387};
    int i;
    for (i = 0; i < 5; i++)
        l_766[i] = (void*)0;
    (*l_44) = (l_41 != &l_42);
    (*l_41) = func_46(p_39, (*l_41), func_52(&l_42, (*l_42), func_58(l_60), (**l_41), &l_42), p_38, l_746);
    for (p_38 = 0; (p_38 <= 29); p_38 = safe_add_func_uint8_t_u_u(p_38, 3))
    { /* block id: 408 */
        int32_t * const l_776[10] = {&l_746,&l_746,&l_746,&l_43,&l_746,&l_746,&l_746,&l_43,&l_746,&l_43};
        int32_t **l_784 = &l_42;
        int32_t ****l_787[3];
        int i;
        for (i = 0; i < 3; i++)
            l_787[i] = &l_780;
        if ((safe_rshift_func_int16_t_s_u((0UL & (safe_rshift_func_int8_t_s_s((-1L), 0))), 11)))
        { /* block id: 409 */
            (*l_44) = (0xC.BB9650p+26 < (safe_div_func_float_f_f(((void*)0 != l_766[1]), (safe_div_func_float_f_f((safe_div_func_float_f_f(p_38, p_39.f0)), 0x6.Bp-1)))));
            for (l_43 = 7; (l_43 == 14); ++l_43)
            { /* block id: 413 */
                uint64_t l_773 = 4UL;
                if (((0x2A6BL <= 0xE4C3L) < (l_773 == l_773)))
                { /* block id: 414 */
                    return p_39;
                }
                else
                { /* block id: 416 */
                    for (l_746 = 0; (l_746 >= (-10)); l_746 = safe_sub_func_int16_t_s_s(l_746, 3))
                    { /* block id: 419 */
                        if (p_38)
                            break;
                    }
                }
            }
        }
        else
        { /* block id: 424 */
            int32_t **l_777 = &l_42;
            (*l_777) = l_776[3];
        }
    }
    /* facts after for loop */
    assert (l_42 == &l_746 || l_42 == &l_43);
    return l_788;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(struct S0  p_47, int32_t * p_48, float * const  p_49, uint16_t  p_50, int64_t  p_51)
{ /* block id: 392 */
    float *l_754 = (void*)0;
    for (p_51 = 26; (p_51 != 3); p_51--)
    { /* block id: 395 */
        struct S0 l_750 = {-3328};
        struct S0 *l_749 = &l_750;
        struct S0 **l_751 = &l_749;
        int32_t l_757 = 6L;
        int32_t *l_756 = &l_757;
        (*l_751) = l_749;
        for (p_50 = 0; (p_50 == 32); p_50 = safe_add_func_uint16_t_u_u(p_50, 7))
        { /* block id: 399 */
            int32_t **l_755[5];
            int i;
            for (i = 0; i < 5; i++)
                l_755[i] = (void*)0;
            (*p_48) = (*p_48);
            l_756 = func_58(l_754);
            /* statement id: 401 */
            assert (l_756 == 0);
        }
        /* facts after for loop */
        assert (l_756 == 0 || l_756 == &l_757);
    }
    return p_48;
    /* statement id: 404 */
    //assert (func_46_rv == &l_43 || (func_46_rv >= &l_826[0][0][0] && func_46_rv <= &l_826[3][3][6]) || (func_46_rv >= &l_840[0][0] && func_46_rv <= &l_840[3][2]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_52(int32_t ** p_53, uint16_t  p_54, float * p_55, uint8_t  p_56, int32_t ** p_57)
{ /* block id: 380 */
    int8_t l_706 = 0x81L;
    float *l_707 = (void*)0;
    float l_709[8];
    float *l_708 = &l_709[0];
    struct S0 l_711[3][4] = {{{8029},{8029},{8029},{8029}},{{8029},{8029},{8029},{8029}},{{8029},{8029},{8029},{8029}}};
    struct S0 *l_710 = &l_711[2][3];
    const struct S0 *l_713 = &l_711[0][3];
    const struct S0 **l_712 = &l_713;
    struct S0 ****l_722[4];
    float l_726 = 0x1.4p-1;
    int32_t l_744 = 0xA2F64F39L;
    int32_t *l_743 = &l_744;
    int i, j;
    for (i = 0; i < 8; i++)
        l_709[i] = 0x8.90545Fp+92;
    for (i = 0; i < 4; i++)
        l_722[i] = (void*)0;
lbl_740:
    (*l_708) = l_706;
    (*l_712) = l_710;
    if ((safe_mod_func_int16_t_s_s(((p_54 > (safe_sub_func_int64_t_s_s(((safe_mod_func_int8_t_s_s((((**p_57) && (**p_53)) <= (safe_lshift_func_int8_t_s_s((p_56 < ((l_722[0] == l_722[3]) || (safe_sub_func_int16_t_s_s(p_56, ((+(p_57 == p_57)) != 65526UL))))), 6))), l_711[2][3].f0)) < l_706), l_706))) == l_711[2][3].f0), 0xA193L)))
    { /* block id: 383 */
        uint32_t l_731 = 0xA3D9A6E6L;
        float *l_736 = (void*)0;
        uint64_t l_739 = 0UL;
        (**p_53) = (p_56 <= (((safe_div_func_uint32_t_u_u((safe_lshift_func_int8_t_s_s(((l_731 > 1L) && (safe_lshift_func_uint16_t_u_s((l_731 >= l_706), (safe_div_func_int32_t_s_s(((p_55 == l_736) > (safe_add_func_int64_t_s_s((((-10L) & 3L) <= l_739), l_706))), l_706))))), 1)), l_739)) == (**p_57)) < l_731));
        if (p_56)
            goto lbl_740;
        (*l_710) = (*l_710);
    }
    else
    { /* block id: 387 */
        int32_t *l_742 = (void*)0;
        int32_t **l_741[9][7] = {{(void*)0,&l_742,&l_742,&l_742,&l_742,&l_742,&l_742},{&l_742,(void*)0,&l_742,&l_742,&l_742,&l_742,(void*)0},{&l_742,(void*)0,&l_742,&l_742,(void*)0,&l_742,&l_742},{(void*)0,&l_742,&l_742,(void*)0,&l_742,&l_742,&l_742},{&l_742,(void*)0,&l_742,&l_742,&l_742,&l_742,&l_742},{&l_742,&l_742,&l_742,&l_742,&l_742,&l_742,&l_742},{&l_742,&l_742,(void*)0,&l_742,&l_742,(void*)0,&l_742},{&l_742,(void*)0,&l_742,&l_742,(void*)0,&l_742,&l_742},{&l_742,&l_742,&l_742,&l_742,&l_742,&l_742,&l_742}};
        int i, j;
        l_743 = func_58(p_55);
        /* statement id: 388 */
        //assert (l_743 == 0 || (l_743 >= &l_840[0][0] && l_743 <= &l_840[3][2]));
        l_743 = (*p_57);
        /* statement id: 389 */
        //assert (l_743 == &l_43 || l_743 == &l_746 || (l_743 >= &l_840[0][0] && l_743 <= &l_840[3][2]));
    }
    /* facts after branching */
    //assert (l_743 == &l_43 || l_743 == &l_744 || l_743 == &l_746 || (l_743 >= &l_840[0][0] && l_743 <= &l_840[3][2]));
    return p_55;
    /* statement id: 391 */
    //assert (func_52_rv == 0 || (func_52_rv >= &l_840[0][0] && func_52_rv <= &l_840[3][2]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float * func_58(float * p_59)
{ /* block id: 17 */
    int32_t l_61 = 1L;
    struct S0 l_67[8][2] = {{{2794},{6183}},{{-4011},{-4011}},{{6183},{2794}},{{7640},{2794}},{{6183},{-4011}},{{-4011},{6183}},{{2794},{7640}},{{2794},{6183}}};
    int32_t l_76 = 0xC038D03DL;
    int32_t *l_75 = &l_76;
    int32_t **l_92 = &l_75;
    int32_t ***l_91 = &l_92;
    float *l_136 = (void*)0;
    int32_t l_181[2][5] = {{2L,2L,2L,2L,2L},{0x0E7157E9L,0x0E7157E9L,0x0E7157E9L,0x0E7157E9L,0x0E7157E9L}};
    const int32_t l_184[3][2][8] = {{{(-8L),0xDC2A9FDAL,0x8D0BA58DL,0xA995AD63L,(-9L),(-6L),(-9L),0xA995AD63L},{0x6330F894L,0xDC2A9FDAL,0x6330F894L,(-6L),(-8L),0xE786ADADL,(-9L),0xE786ADADL}},{{0x0EC63AA8L,(-6L),0x8D0BA58DL,(-6L),0x0EC63AA8L,0L,(-8L),0xA995AD63L},{0x0EC63AA8L,0L,(-8L),0xA995AD63L,(-8L),0L,0x0EC63AA8L,(-6L)}},{{0x6330F894L,(-6L),(-8L),0xE786ADADL,(-9L),0xE786ADADL,(-8L),(-6L)},{(-8L),0xDC2A9FDAL,0x8D0BA58DL,0xA995AD63L,(-9L),(-6L),(-9L),0xA995AD63L}}};
    const struct S0 *l_268 = &l_67[5][1];
    const struct S0 * const *l_267 = &l_268;
    uint32_t l_315 = 1UL;
    int16_t l_367 = (-1L);
    int8_t l_390 = 0x21L;
    uint16_t l_430 = 1UL;
    struct S0 ***l_511 = (void*)0;
    uint32_t l_525[9] = {0x7F9EC9A9L,1UL,0x7F9EC9A9L,1UL,0x7F9EC9A9L,1UL,0x7F9EC9A9L,1UL,0x7F9EC9A9L};
    uint32_t l_560 = 18446744073709551614UL;
    int16_t l_600 = (-8L);
    float ***l_601 = (void*)0;
    int32_t l_659 = 4L;
    struct S0 ****l_704 = (void*)0;
    const struct S0 * const **l_705 = &l_267;
    int i, j, k;
lbl_613:
    for (l_61 = 0; (l_61 != 0); l_61 = safe_add_func_int32_t_s_s(l_61, 4))
    { /* block id: 20 */
        int32_t l_64 = (-1L);
        float *l_88 = (void*)0;
        int32_t l_103 = (-3L);
        struct S0 *l_139 = &l_67[6][0];
        float l_313 = 0x1.6p+1;
        int32_t *l_323 = &l_103;
        for (l_64 = (-1); (l_64 > (-25)); l_64 = safe_sub_func_int16_t_s_s(l_64, 1))
        { /* block id: 23 */
            int32_t l_68 = 0x14EFC710L;
            int32_t **l_74 = (void*)0;
            uint8_t l_114 = 0UL;
            struct S0 l_148 = {-3891};
            for (l_68 = 1; (l_68 >= 0); l_68 -= 1)
            { /* block id: 26 */
                int32_t *l_70 = &l_68;
                int32_t **l_69 = &l_70;
                const int32_t **l_72 = (void*)0;
                const int32_t ***l_71[10] = {&l_72,&l_72,&l_72,&l_72,&l_72,&l_72,&l_72,&l_72,&l_72,&l_72};
                int32_t ***l_73[9][9][1] = {{{&l_69},{&l_69},{(void*)0},{&l_69},{&l_69},{(void*)0},{&l_69},{&l_69},{(void*)0}},{{&l_69},{&l_69},{(void*)0},{&l_69},{&l_69},{(void*)0},{&l_69},{&l_69},{(void*)0}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}},{{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69},{(void*)0},{(void*)0},{&l_69}}};
                int i, j, k;
                l_67[l_68][l_68] = l_67[(l_68 + 5)][l_68];
                l_74 = l_69;
                /* statement id: 28 */
                assert (l_74 == &l_70);
                l_75 = p_59;
                /* statement id: 29 */
                //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
            }
            /* facts after for loop */
            //assert (l_74 == dangling || l_74 == 0);
            for (l_76 = 1; (l_76 >= 0); l_76 -= 1)
            { /* block id: 33 */
                uint64_t l_89[9][1] = {{9UL},{0x26DA6125F89738BBLL},{9UL},{0x26DA6125F89738BBLL},{9UL},{0x26DA6125F89738BBLL},{9UL},{0x26DA6125F89738BBLL},{9UL}};
                int32_t l_93 = 0xD061DAE5L;
                int32_t ***l_119 = &l_92;
                int32_t l_120 = 0L;
                float l_122 = 0x1.7p+1;
                float *l_121 = &l_122;
                int i, j;
                for (l_68 = 1; (l_68 >= 0); l_68 -= 1)
                { /* block id: 36 */
                    int32_t l_77 = 0x497A847EL;
                    int32_t l_90 = 0xE83987EDL;
                    for (l_77 = 1; (l_77 >= 0); l_77 -= 1)
                    { /* block id: 39 */
                        int32_t **l_78 = &l_75;
                        struct S0 *l_80 = &l_67[3][0];
                        struct S0 **l_79 = &l_80;
                        int32_t **l_87 = &l_75;
                        int i, j;
                        (*l_78) = p_59;
                        /* statement id: 40 */
                        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                        (*l_79) = &l_67[(l_76 + 5)][l_68];
                        l_90 = (l_64 >= (safe_div_func_float_f_f((((safe_sub_func_float_f_f(l_67[(l_76 + 5)][l_68].f0, 0x4.2260F1p-77)) >= (((void*)0 == &l_67[(l_76 + 5)][l_77]) >= l_64)) < (safe_sub_func_float_f_f((l_87 == (void*)0), ((void*)0 == l_88)))), l_89[7][0])));
                    }
                    l_93 = (l_68 > (((l_91 == &l_74) && l_64) <= l_68));
                    l_103 = ((+((!(safe_lshift_func_uint16_t_u_s(((void*)0 != p_59), 13))) || (((l_89[7][0] & ((l_89[7][0] && ((safe_lshift_func_int8_t_s_s((p_59 == (void*)0), (((safe_div_func_uint16_t_u_u(0x9C35L, (+(p_59 != (void*)0)))) > 0xE4E4C4DCL) <= l_68))) < 0x6586993EB33379BBLL)) ^ l_90)) ^ l_89[8][0]) >= l_64))) != 0x5AEF2735L);
                }
                (*l_121) = (safe_div_func_float_f_f(l_68, (((safe_sub_func_float_f_f(0xE.FFB082p+10, 0x7.CE6FA9p-72)) != (safe_sub_func_float_f_f(l_103, (safe_div_func_float_f_f(((0x0.Cp+1 >= ((safe_div_func_float_f_f(l_114, (safe_sub_func_float_f_f((safe_div_func_float_f_f((l_64 > (((-0x1.Dp-1) == ((void*)0 == l_119)) < l_64)), l_103)), l_68)))) <= l_120)) < 0x4.Fp+1), l_89[7][0]))))) != l_103)));
                if (((void*)0 == p_59))
                { /* block id: 48 */
                    int32_t *l_123[2];
                    int i;
                    for (i = 0; i < 2; i++)
                        l_123[i] = &l_103;
                    l_123[1] = &l_64;
                    /* statement id: 49 */
                    //assert (l_123[0] == &l_64 || l_123[0] == &l_103);
                }
                else
                { /* block id: 50 */
                    l_68 = 0xDFF4590BL;
                }
                for (l_68 = 1; (l_68 >= 0); l_68 -= 1)
                { /* block id: 55 */
                    int32_t l_134 = 0xA10FB8DAL;
                    if ((((safe_rshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s(l_89[0][0], 0xB808L)), 6)) | ((-1L) || (safe_unary_minus_func_uint64_t_u((safe_add_func_uint8_t_u_u(0xCFL, (safe_unary_minus_func_uint16_t_u(0x9543L)))))))) != (safe_mod_func_int16_t_s_s(l_103, l_134))))
                    { /* block id: 56 */
                        (**l_119) = p_59;
                        /* statement id: 57 */
                        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                        if (l_93)
                            continue;
                    }
                    else
                    { /* block id: 59 */
                        float l_135 = 0x0.5p+1;
                        if (l_134)
                            break;
                    }
                    return l_136;
                    /* statement id: 62 */
                    //assert (func_58_rv == 0);
                }
            }
            for (l_76 = (-1); (l_76 < (-15)); --l_76)
            { /* block id: 67 */
                struct S0 **l_140 = &l_139;
                int32_t ***l_152 = &l_92;
                struct S0 *l_185[4][3][2] = {{{(void*)0,&l_67[2][1]},{&l_67[2][1],(void*)0},{&l_148,&l_67[7][0]}},{{&l_148,(void*)0},{&l_67[2][1],&l_67[2][1]},{(void*)0,&l_148}},{{&l_67[7][0],&l_148},{(void*)0,&l_67[2][1]},{&l_67[2][1],(void*)0}},{{&l_148,&l_67[7][0]},{&l_148,(void*)0},{&l_67[2][1],&l_67[2][1]}}};
                int i, j, k;
                (*l_140) = l_139;
                (*l_92) = &l_103;
                /* statement id: 69 */
                assert (l_75 == &l_103);
                if (((safe_rshift_func_uint16_t_u_s((+((l_140 != (void*)0) | (0x731B53E36E8D0335LL || ((((***l_91) | (safe_lshift_func_uint8_t_u_u(((2UL && l_103) >= l_64), (p_59 == p_59)))) & 0x3D76L) == 0x95L)))), 2)) ^ (**l_92)))
                { /* block id: 70 */
                    (**l_140) = l_148;
                    return l_88;
                    /* statement id: 72 */
                    //assert (func_58_rv == 0);
                }
                else
                { /* block id: 73 */
                    int32_t ***l_151 = &l_74;
                    int32_t l_182 = 0xCF268A7AL;
                    for (l_68 = 1; (l_68 >= 0); l_68 -= 1)
                    { /* block id: 76 */
                        int32_t l_174 = 0xF5B91466L;
                        int64_t l_183[2][6][3] = {{{(-5L),(-1L),(-1L)},{0xD17D95D16D180367LL,(-1L),0x1821A72EEF0ED02CLL},{0x91451F1CBD15FE66LL,0x91451F1CBD15FE66LL,(-1L)},{1L,1L,1L},{0x91451F1CBD15FE66LL,(-1L),(-1L)},{0xD17D95D16D180367LL,1L,0x1821A72EEF0ED02CLL}},{{(-5L),0x91451F1CBD15FE66LL,(-1L)},{1L,(-1L),1L},{(-5L),(-1L),(-1L)},{0xD17D95D16D180367LL,(-1L),0x1821A72EEF0ED02CLL},{0x91451F1CBD15FE66LL,0x91451F1CBD15FE66LL,(-1L)},{1L,1L,1L}}};
                        int i, j, k;
                        if (l_64)
                            break;
                        if (l_64)
                            break;
                        (**l_91) = p_59;
                        /* statement id: 79 */
                        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                        l_103 = (0xC.A0BC11p+39 > (safe_add_func_float_f_f((l_151 != l_152), ((((safe_div_func_float_f_f(l_103, (!(safe_add_func_float_f_f((-l_103), 0x1.177FA4p+44))))) == (+((safe_sub_func_float_f_f((((safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_div_func_float_f_f((safe_add_func_float_f_f((((safe_sub_func_float_f_f((safe_div_func_float_f_f((l_174 >= l_174), (safe_add_func_float_f_f((safe_add_func_float_f_f((((safe_add_func_float_f_f(l_181[0][0], 0x1.8p+1)) > l_174) <= l_64), (-0x5.0p-1))), l_64)))), l_182)) == (-0x1.5p+1)) == 0x1.9p-1), l_103)), 0x9.539415p-72)), (-0x1.3p-1))) > 0xA.0517B6p-52), 0x8.8p-1)) >= l_174) != 0x0.4p-1), l_183[0][4][1])) <= l_103))) > l_184[2][0][4]) <= l_174))));
                    }
                    /* facts after for loop */
                    //assert (l_75 == 0 || l_75 == &l_103 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                    for (l_68 = 1; (l_68 >= 0); l_68 -= 1)
                    { /* block id: 84 */
                        (*l_139) = l_148;
                    }
                    (*l_140) = l_185[3][0][0];
                    /* statement id: 87 */
                    assert (l_139 == &l_148 || (l_139 >= &l_67[0][0] && l_139 <= &l_67[7][1]) || l_139 == 0);
                    return p_59;
                    /* statement id: 88 */
                    //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                }
            }
        }
        (*l_92) = p_59;
        /* statement id: 92 */
        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
        if ((safe_div_func_int32_t_s_s(0xECE3592EL, l_103)))
        { /* block id: 93 */
            uint8_t l_188 = 255UL;
            struct S0 l_197[8][8][4] = {{{{94},{-3794},{2411},{2466}},{{5385},{4461},{-3080},{-3794}},{{912},{2406},{-7418},{-3654}},{{2074},{3029},{2411},{-7103}},{{-22},{3755},{4343},{-22}},{{-3328},{94},{5276},{7812}},{{-590},{-6350},{-2167},{-7047}},{{94},{-2171},{-5669},{-7704}}},{{{5276},{2074},{1559},{7812}},{{-5100},{2406},{-3301},{2406}},{{5385},{3755},{4548},{1590}},{{-7610},{-590},{4343},{-3654}},{{3029},{-22},{1938},{-5100}},{{3029},{4461},{4343},{-7047}},{{-7610},{-5100},{1633},{-2724}},{{7244},{2110},{2074},{4548}}},{{{-5669},{-2167},{1938},{3755}},{{3650},{912},{-3301},{-716}},{{3755},{7812},{-116},{4343}},{{7812},{-2167},{3650},{-161}},{{-7918},{7244},{-7929},{-2724}},{{-3328},{4548},{2333},{1559}},{{3189},{-6783},{-716},{4548}},{{2751},{3755},{2051},{-5964}}},{{{7244},{-2171},{2333},{5276}},{{3755},{-6424},{-6424},{3755}},{{-7918},{-3328},{-6783},{466}},{{-2171},{7244},{-116},{-7418}},{{4343},{2411},{1633},{-7418}},{{3650},{7244},{-716},{466}},{{4548},{-3328},{2074},{3755}},{{3189},{-6424},{-2724},{5276}}},{{{4955},{-2171},{-7918},{-5964}},{{7812},{3755},{7759},{4548}},{{-2171},{-6783},{-6424},{1559}},{{4955},{4548},{-3301},{-2724}},{{2110},{7244},{2074},{-161}},{{-161},{-2167},{2051},{4343}},{{3650},{7812},{-2724},{-716}},{{-3328},{912},{-116},{3755}}},{{{912},{-2167},{2},{4548}},{{-7918},{2110},{-7918},{-2724}},{{4343},{-5669},{2333},{-3080}},{{2110},{-6783},{1938},{-5669}},{{2751},{-3328},{1938},{-5964}},{{2110},{7812},{2333},{-2960}},{{4343},{-6424},{-7918},{4343}},{{-7918},{4343},{2},{466}}},{{{912},{3189},{-116},{1559}},{{-3328},{2411},{-2724},{-3080}},{{3650},{2110},{2051},{466}},{{-161},{3755},{2074},{-3328}},{{2110},{-6424},{-3301},{4461}},{{4955},{912},{-6424},{-5964}},{{-2171},{4343},{7759},{-161}},{{7812},{-6783},{-7918},{-7418}}},{{{4955},{-161},{-2724},{-2724}},{{3189},{3189},{2074},{-5669}},{{4548},{-2167},{-716},{-3328}},{{3650},{-2171},{1633},{-716}},{{4343},{-2171},{-116},{-3328}},{{-2171},{-2167},{-6783},{-5669}},{{-7918},{-7419},{-7047},{-6350}},{{-6424},{-2724},{5276},{-716}}}};
            float l_285 = 0xF.32A7BFp+60;
            float *l_284 = &l_285;
            int32_t **l_321[7] = {&l_75,&l_75,&l_75,&l_75,&l_75,&l_75,&l_75};
            int i, j, k;
            (**l_91) = (*l_92);
            (**l_91) = &l_64;
            /* statement id: 95 */
            assert (l_75 == &l_64);
            if ((l_188 == (~(safe_rshift_func_uint8_t_u_s((((!0x1B15C3DAL) & (**l_92)) > (0xB0DCD2CF262FDF43LL & (safe_add_func_int32_t_s_s((**l_92), ((***l_91) ^ ((void*)0 == &l_139)))))), 7)))))
            { /* block id: 96 */
                struct S0 l_198 = {806};
                l_198 = l_197[6][2][3];
            }
            else
            { /* block id: 98 */
                float l_201 = 0x8.EB1AB0p+64;
                struct S0 *l_217[2];
                int32_t l_219[3];
                float *l_256 = &l_201;
                int i;
                for (i = 0; i < 2; i++)
                    l_217[i] = &l_197[6][2][3];
                for (i = 0; i < 3; i++)
                    l_219[i] = 0xFA829B7CL;
                if (((((safe_sub_func_int32_t_s_s(l_197[6][2][3].f0, (((+(safe_lshift_func_int8_t_s_u((safe_lshift_func_int8_t_s_u(((-1L) || (safe_div_func_int32_t_s_s(0x4D7D783DL, (safe_rshift_func_uint8_t_u_u(((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int8_t_s_s((&l_67[5][0] == &l_197[6][2][3]), 4)), 3)) >= (0L != ((void*)0 == l_217[1]))), (+l_64)))))), 5)), 4))) ^ l_188) || l_219[2]))) & l_219[2]) != l_103) > (***l_91)))
                { /* block id: 99 */
                    float l_243[4];
                    int32_t * const *l_246 = &l_75;
                    int i;
                    for (i = 0; i < 4; i++)
                        l_243[i] = (-0x1.3p+1);
                    for (l_103 = 0; (l_103 == (-5)); l_103 = safe_sub_func_uint16_t_u_u(l_103, 2))
                    { /* block id: 102 */
                        float l_226[4];
                        int32_t l_242 = 0xCE0736A6L;
                        int i;
                        for (i = 0; i < 4; i++)
                            l_226[i] = (-0x1.Dp-1);
                        (**l_92) = (safe_lshift_func_int16_t_s_s(l_103, ((safe_mod_func_uint8_t_u_u(l_219[2], l_219[2])) | (safe_div_func_int32_t_s_s((safe_mod_func_int32_t_s_s((safe_add_func_int8_t_s_s((p_59 != p_59), (safe_rshift_func_int8_t_s_s(0xCFL, 4)))), (safe_mod_func_int32_t_s_s((((l_197[6][2][3].f0 > (+((**l_92) < (((safe_lshift_func_uint16_t_u_u((l_103 == l_242), 4)) & (-7L)) > l_219[2])))) < 0x5C46L) <= l_64), (**l_92))))), 0x8ABC683EL)))));
                        return p_59;
                        /* statement id: 104 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                    for (l_188 = 0; (l_188 <= 43); l_188++)
                    { /* block id: 108 */
                        uint16_t l_255 = 0x0DCBL;
                        struct S0 ** const l_269 = &l_217[1];
                        float *l_270 = &l_243[2];
                        int32_t **l_276 = (void*)0;
                        l_197[6][2][3].f0 = ((void*)0 != l_246);
                        (*l_92) = (*l_246);
                        (*l_256) = (((-(((!(((safe_sub_func_float_f_f((((safe_add_func_float_f_f(((safe_div_func_float_f_f((***l_91), l_255)) >= (l_256 != p_59)), ((safe_add_func_float_f_f((safe_div_func_float_f_f((-0x9.9p+1), (safe_add_func_float_f_f((safe_sub_func_float_f_f(0x1.7p-1, (safe_add_func_float_f_f(0x8.5p+1, (l_267 != l_269))))), l_197[6][2][3].f0)))), l_197[6][2][3].f0)) < l_103))) > l_255) == 0xA.390666p+58), 0xF.6458F5p-54)) == 0x7.2D0B3Dp+19) >= l_255)) > l_103) <= l_219[2])) >= 0x2.CDFA42p-13) < l_255);
                        (***l_91) = (((l_270 == (void*)0) ^ 0x18L) ^ (safe_mod_func_uint32_t_u_u((safe_sub_func_int32_t_s_s(((!4294967287UL) < 0x6830DA417DDE3D06LL), (l_246 != l_276))), (safe_unary_minus_func_uint32_t_u(l_219[1])))));
                    }
                }
                else
                { /* block id: 114 */
                    for (l_188 = (-9); (l_188 == 34); l_188 = safe_add_func_uint16_t_u_u(l_188, 3))
                    { /* block id: 117 */
                        return p_59;
                        /* statement id: 118 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                    (**l_91) = (*l_92);
                }
                (*l_92) = p_59;
                /* statement id: 122 */
                //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                for (l_76 = 0; (l_76 <= 2); l_76 += 1)
                { /* block id: 125 */
                    float l_283 = 0x0.0p+1;
                    int32_t l_294 = (-6L);
                    uint16_t l_314 = 0xCD8EL;
                    int16_t l_320[2];
                    int i;
                    for (i = 0; i < 2; i++)
                        l_320[i] = 0x972EL;
                    l_219[l_76] = (0L != (safe_mod_func_uint16_t_u_u(((~((l_103 < l_103) || (p_59 != l_284))) && (4L ^ (safe_lshift_func_int8_t_s_u((safe_rshift_func_int16_t_s_s(l_103, 3)), (254UL >= (safe_div_func_int8_t_s_s((safe_add_func_int64_t_s_s(0xDE1195C0E044A459LL, l_219[2])), 0x96L))))))), l_294)));
                    for (l_103 = 2; (l_103 >= 0); l_103 -= 1)
                    { /* block id: 129 */
                        const struct S0 *l_316 = &l_197[2][2][3];
                        int i;
                        l_219[l_76] = (safe_lshift_func_uint16_t_u_s(((safe_div_func_uint16_t_u_u(l_219[l_76], ((safe_add_func_int32_t_s_s((safe_rshift_func_uint8_t_u_u(l_219[l_76], 0)), (~l_219[2]))) || l_219[l_76]))) | (l_219[2] & (safe_mod_func_uint32_t_u_u((safe_add_func_uint32_t_u_u(1UL, (0UL == ((0xC1B368D3L || ((!((safe_add_func_uint32_t_u_u(l_188, 0xE98F465CL)) && l_314)) > l_219[0])) != (-1L))))), l_197[6][2][3].f0)))), l_315));
                        l_316 = (void*)0;
                        /* statement id: 131 */
                        assert (l_316 == 0);
                        l_219[2] = (l_188 != (safe_sub_func_int16_t_s_s((+l_320[1]), (0xDCF4C4EFF3E88C3CLL || l_320[1]))));
                        (*l_139) = l_197[6][2][3];
                    }
                }
                (*l_91) = l_321[6];
            }
            /* facts after branching */
            //assert (l_75 == 0 || l_75 == &l_64 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
        }
        else
        { /* block id: 138 */
            int32_t *l_322 = &l_76;
            for (l_315 = 0; l_315 < 2; l_315 += 1)
            {
                for (l_76 = 0; l_76 < 5; l_76 += 1)
                {
                    l_181[l_315][l_76] = 0x71DD7EC6L;
                }
            }
            l_323 = l_322;
            /* statement id: 140 */
            assert (l_323 == &l_76);
            (*l_92) = &l_103;
            /* statement id: 141 */
            assert (l_75 == &l_103);
            (**l_91) = (*l_92);
        }
        /* facts after branching */
        //assert (l_75 == &l_103 || l_75 == 0 || l_75 == &l_64 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
        assert (l_323 == &l_76 || l_323 == &l_103);
        (**l_91) = (**l_91);
    }
lbl_513:
    for (l_61 = 0; (l_61 == (-30)); --l_61)
    { /* block id: 148 */
        float l_327 = 0xC.E18812p+40;
        int32_t l_328 = 0xE14E27A1L;
        for (l_315 = 0; (l_315 <= 1); l_315 += 1)
        { /* block id: 151 */
            struct S0 *l_326 = &l_67[1][1];
            int i, j;
            (*l_326) = l_67[(l_315 + 6)][l_315];
        }
        l_328 = (l_328 > ((l_328 != 0x3BL) && ((!(safe_add_func_int8_t_s_s((l_328 <= l_328), (l_328 ^ l_328)))) & (l_328 > (!(((l_328 >= (-1L)) >= l_328) && l_328))))));
    }
    if ((safe_lshift_func_int8_t_s_u((safe_rshift_func_int8_t_s_s((l_184[2][0][4] > ((((void*)0 == (*l_267)) | ((&l_92 == (void*)0) != (&l_268 == &l_268))) >= l_181[0][3])), 6)), 2)))
    { /* block id: 156 */
        int32_t ***l_341 = &l_92;
        int32_t l_348 = 1L;
        int8_t l_351 = 1L;
        int32_t l_354[1][3];
        uint32_t l_383[9] = {0x86E1F5E1L,0UL,0x86E1F5E1L,0x86E1F5E1L,0UL,0x86E1F5E1L,0x86E1F5E1L,0UL,0x86E1F5E1L};
        struct S0 *l_399 = &l_67[1][0];
        float l_416 = (-0x1.Cp-1);
        float *l_415 = &l_416;
        int64_t l_451 = (-2L);
        int16_t l_488 = (-1L);
        int64_t l_520[7][7][5] = {{{0x1212F90AC3D2FF1BLL,0xD1233714A2C60234LL,0x3D9831F8AEBA5A67LL,(-1L),(-5L)},{0x711216D08B1A76D8LL,0L,0x1212F90AC3D2FF1BLL,8L,0x667E6C489C0ED1A0LL},{0x51EC8FE551804D68LL,0x4D93E94A5BC5E591LL,0xAD3C1E511F28703ELL,0xC5413F15AACC03ACLL,0xC5413F15AACC03ACLL},{0xA813A1359E93B6C1LL,0x711216D08B1A76D8LL,0xA813A1359E93B6C1LL,0L,0x71A94A4F0EC56878LL},{0x4D93E94A5BC5E591LL,(-6L),0x1944FC28B50E8AC8LL,0x711216D08B1A76D8LL,1L},{0x51EC8FE551804D68LL,0xFC74E96E200CB1E2LL,0x8BD8121BC739653BLL,0xD1233714A2C60234LL,0L},{2L,0xC5413F15AACC03ACLL,0x1944FC28B50E8AC8LL,1L,8L}},{{1L,0x1212F90AC3D2FF1BLL,0xA813A1359E93B6C1LL,0x36AAF7C67319C4EBLL,0x1944FC28B50E8AC8LL},{(-5L),0x71A94A4F0EC56878LL,0xAD3C1E511F28703ELL,0x81DB7756A15EEDD2LL,0L},{0x0F1E4962F4354815LL,0x81DB7756A15EEDD2LL,0x1212F90AC3D2FF1BLL,1L,9L},{0x0890295D12115896LL,0x1A1E9AED675A7E47LL,0x3D9831F8AEBA5A67LL,0x51EC8FE551804D68LL,0x1A1E9AED675A7E47LL},{0L,1L,0x21039D80E3966BF4LL,0x51EC8FE551804D68LL,0xC5413F15AACC03ACLL},{0L,0xC5413F15AACC03ACLL,0x0B62B6FBF9409E84LL,1L,0x81DB7756A15EEDD2LL},{0x36AAF7C67319C4EBLL,0x11ACE0F4FEEDF33DLL,1L,0x81DB7756A15EEDD2LL,0L}},{{0x9E201509AACC8931LL,0x36AAF7C67319C4EBLL,(-9L),0x36AAF7C67319C4EBLL,0x9E201509AACC8931LL},{1L,0x711216D08B1A76D8LL,0L,1L,1L},{0x0890295D12115896LL,0xA813A1359E93B6C1LL,1L,0xD1233714A2C60234LL,0x0F1E4962F4354815LL},{(-1L),0x9E201509AACC8931LL,0xB09EF1ECBDFCB6BELL,0x711216D08B1A76D8LL,1L},{0L,0xD1233714A2C60234LL,1L,0L,0x9E201509AACC8931LL},{1L,1L,0x3D9831F8AEBA5A67LL,0xC5413F15AACC03ACLL,0L},{0x711216D08B1A76D8LL,0x9E201509AACC8931LL,(-1L),8L,0x81DB7756A15EEDD2LL}},{{0x3D9831F8AEBA5A67LL,0x4D93E94A5BC5E591LL,0x11ACE0F4FEEDF33DLL,(-1L),0xC5413F15AACC03ACLL},{0x4D93E94A5BC5E591LL,2L,0xA813A1359E93B6C1LL,(-5L),0x1A1E9AED675A7E47LL},{0x4D93E94A5BC5E591LL,0x36AAF7C67319C4EBLL,(-6L),0x711216D08B1A76D8LL,9L},{0x3D9831F8AEBA5A67LL,0xFC74E96E200CB1E2LL,0L,1L,0L},{0x711216D08B1A76D8LL,(-1L),0x1944FC28B50E8AC8LL,9L,0x1944FC28B50E8AC8LL},{1L,1L,0xBBEE20119565B0B3LL,0x36AAF7C67319C4EBLL,8L},{0L,0x71A94A4F0EC56878LL,0x11ACE0F4FEEDF33DLL,0x667E6C489C0ED1A0LL,0L}},{{(-1L),0x667E6C489C0ED1A0LL,0x1212F90AC3D2FF1BLL,0x0890295D12115896LL,1L},{0x0890295D12115896LL,0x71A94A4F0EC56878LL,(-2L),0x51EC8FE551804D68LL,0x71A94A4F0EC56878LL},{1L,1L,1L,0x3D9831F8AEBA5A67LL,0xC5413F15AACC03ACLL},{0x9E201509AACC8931LL,(-1L),0x0B62B6FBF9409E84LL,0x0890295D12115896LL,0x667E6C489C0ED1A0LL},{0x36AAF7C67319C4EBLL,0xFC74E96E200CB1E2LL,0x5EA165C4EDAE71FCLL,0x81DB7756A15EEDD2LL,(-5L)},{0L,0x36AAF7C67319C4EBLL,0L,0x21039D80E3966BF4LL,(-6L)},{(-1L),0xAD3C1E511F28703ELL,0xBBEE20119565B0B3LL,0x3D9831F8AEBA5A67LL,0x20E602DE46391FA4LL}},{{1L,1L,0x51EC8FE551804D68LL,0x1212F90AC3D2FF1BLL,0xE8DE9C3CC93BDCDDLL},{0xC7F3EB5AF86F4B8ELL,(-6L),1L,0xAD3C1E511F28703ELL,0x0F1E4962F4354815LL},{0xA813A1359E93B6C1LL,(-1L),(-1L),0xA813A1359E93B6C1LL,8L},{0x0F1E4962F4354815LL,0x1212F90AC3D2FF1BLL,(-5L),0x1944FC28B50E8AC8LL,0xA813A1359E93B6C1LL},{0xAD3C1E511F28703ELL,(-6L),0x20E602DE46391FA4LL,0x8BD8121BC739653BLL,0x0B62B6FBF9409E84LL},{0L,0xC75E86B153D8A287LL,(-1L),0x1944FC28B50E8AC8LL,(-6L)},{1L,0x11ACE0F4FEEDF33DLL,0L,0xA813A1359E93B6C1LL,0x667E6C489C0ED1A0LL}},{{0xC75E86B153D8A287LL,1L,0x8BD8121BC739653BLL,0xAD3C1E511F28703ELL,0x3D9831F8AEBA5A67LL},{0L,(-1L),8L,0x1212F90AC3D2FF1BLL,0x1D2784A4188C3755LL},{0x11ACE0F4FEEDF33DLL,0x1944FC28B50E8AC8LL,0x9E201509AACC8931LL,0x3D9831F8AEBA5A67LL,0L},{0x20E602DE46391FA4LL,0x0F1E4962F4354815LL,0xC75E86B153D8A287LL,0x21039D80E3966BF4LL,0L},{0xA813A1359E93B6C1LL,(-3L),(-1L),0x0B62B6FBF9409E84LL,0x1D2784A4188C3755LL},{0xE8DE9C3CC93BDCDDLL,0x0B62B6FBF9409E84LL,(-1L),1L,0x3D9831F8AEBA5A67LL},{0x5EA165C4EDAE71FCLL,0x667E6C489C0ED1A0LL,(-9L),(-9L),0x667E6C489C0ED1A0LL}}};
        float **l_565 = &l_136;
        float ***l_564 = &l_565;
        struct S0 l_593[2][4][4] = {{{{6079},{6079},{6079},{6079}},{{6079},{6079},{6079},{6079}},{{6079},{6079},{6079},{6079}},{{6079},{6079},{6079},{6079}}},{{{6079},{6079},{6079},{6079}},{{6079},{6079},{6079},{6079}},{{6079},{6079},{6079},{6079}},{{6079},{6079},{6079},{6079}}}};
        float *l_615 = &l_416;
        int32_t l_660 = 0L;
        uint64_t l_697[7][1];
        int i, j, k;
        for (i = 0; i < 1; i++)
        {
            for (j = 0; j < 3; j++)
                l_354[i][j] = 0xD79ECDA7L;
        }
        for (i = 0; i < 7; i++)
        {
            for (j = 0; j < 1; j++)
                l_697[i][j] = 0x8769C75D746C9046LL;
        }
        if (((safe_lshift_func_int16_t_s_u((safe_lshift_func_uint8_t_u_s(((void*)0 != l_341), (safe_sub_func_uint16_t_u_u((((safe_div_func_uint32_t_u_u(((safe_lshift_func_int16_t_s_s(((l_348 == ((l_348 | ((safe_lshift_func_int8_t_s_u(l_351, 0)) == (safe_rshift_func_uint8_t_u_u(((l_351 && ((&l_92 == l_341) | (l_348 == (-9L)))) != l_351), l_351)))) <= 0x3D675C65L)) || l_351), 13)) ^ l_348), 0x37B79DADL)) || l_351) | l_351), l_351)))), 10)) && l_354[0][2]))
        { /* block id: 157 */
            uint8_t l_357[3][6][3] = {{{0xB7L,0UL,251UL},{0UL,0UL,255UL},{0xBEL,0UL,0UL},{255UL,0x25L,0xB0L},{0xBEL,0x6AL,0xBEL},{0UL,255UL,0xB0L}},{{0xB7L,0xB7L,0UL},{255UL,255UL,255UL},{0UL,0x6AL,251UL},{255UL,0x25L,255UL},{0xB7L,0UL,251UL},{0UL,0UL,255UL}},{{0xBEL,0UL,0UL},{255UL,0x25L,0xB0L},{0xBEL,0x6AL,0xBEL},{0UL,255UL,0xB0L},{0xB7L,0xB7L,0UL},{255UL,255UL,255UL}}};
            int32_t **l_358[8] = {&l_75,&l_75,&l_75,&l_75,&l_75,&l_75,&l_75,&l_75};
            int64_t l_391 = (-1L);
            float l_394 = 0x2.0p+1;
            const struct S0 *l_412 = &l_67[1][0];
            int32_t l_429 = 0x6EFF648CL;
            struct S0 l_445 = {3903};
            uint64_t l_487 = 18446744073709551615UL;
            int i, j, k;
            (**l_91) = p_59;
            /* statement id: 158 */
            //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
        }
        else
        { /* block id: 255 */
            int32_t l_512 = 1L;
            int32_t *l_530[3];
            struct S0 ****l_551 = &l_511;
            const uint8_t l_552[5] = {248UL,248UL,248UL,248UL,248UL};
            float ***l_579 = &l_565;
            int32_t l_591 = 0xF9189EABL;
            const uint32_t l_661 = 1UL;
            uint32_t l_662 = 0x8248036CL;
            int i;
            for (i = 0; i < 3; i++)
                l_530[i] = &l_348;
            for (l_390 = (-15); (l_390 == 8); l_390++)
            { /* block id: 258 */
                struct S0 **l_505 = (void*)0;
                struct S0 **l_506 = &l_399;
                int32_t l_516 = (-5L);
                struct S0 l_528 = {-343};
                (*l_506) = l_399;
                for (l_351 = (-21); (l_351 != 23); l_351 = safe_add_func_uint32_t_u_u(l_351, 1))
                { /* block id: 262 */
                    struct S0 ***l_510 = &l_505;
                    struct S0 ****l_509[9][5][5] = {{{&l_510,&l_510,(void*)0,&l_510,&l_510},{&l_510,(void*)0,&l_510,&l_510,&l_510},{(void*)0,&l_510,&l_510,&l_510,&l_510},{(void*)0,&l_510,&l_510,(void*)0,&l_510},{(void*)0,(void*)0,(void*)0,&l_510,&l_510}},{{(void*)0,&l_510,&l_510,(void*)0,(void*)0},{(void*)0,&l_510,&l_510,&l_510,&l_510},{&l_510,(void*)0,&l_510,(void*)0,(void*)0},{&l_510,&l_510,(void*)0,&l_510,&l_510},{&l_510,&l_510,(void*)0,&l_510,(void*)0}},{{&l_510,&l_510,&l_510,&l_510,&l_510},{(void*)0,&l_510,&l_510,&l_510,&l_510},{&l_510,(void*)0,&l_510,&l_510,&l_510},{&l_510,&l_510,(void*)0,(void*)0,&l_510},{&l_510,&l_510,&l_510,&l_510,&l_510}},{{(void*)0,&l_510,(void*)0,&l_510,&l_510},{(void*)0,&l_510,&l_510,&l_510,(void*)0},{&l_510,(void*)0,&l_510,&l_510,&l_510},{&l_510,&l_510,&l_510,(void*)0,&l_510},{&l_510,&l_510,&l_510,(void*)0,&l_510}},{{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_510,&l_510,&l_510,&l_510,&l_510},{&l_510,&l_510,&l_510,&l_510,&l_510},{&l_510,&l_510,&l_510,(void*)0,&l_510},{&l_510,&l_510,(void*)0,(void*)0,&l_510}},{{(void*)0,&l_510,&l_510,(void*)0,&l_510},{(void*)0,(void*)0,(void*)0,&l_510,&l_510},{(void*)0,(void*)0,&l_510,&l_510,(void*)0},{(void*)0,(void*)0,&l_510,&l_510,&l_510},{&l_510,(void*)0,&l_510,&l_510,(void*)0}},{{&l_510,(void*)0,(void*)0,(void*)0,&l_510},{&l_510,(void*)0,&l_510,&l_510,(void*)0},{&l_510,&l_510,&l_510,&l_510,&l_510},{&l_510,&l_510,&l_510,&l_510,&l_510},{&l_510,&l_510,&l_510,&l_510,&l_510}},{{&l_510,&l_510,(void*)0,&l_510,&l_510},{(void*)0,&l_510,&l_510,(void*)0,&l_510},{(void*)0,(void*)0,(void*)0,&l_510,&l_510},{(void*)0,&l_510,&l_510,(void*)0,(void*)0},{(void*)0,&l_510,&l_510,&l_510,&l_510}},{{&l_510,(void*)0,&l_510,(void*)0,(void*)0},{&l_510,(void*)0,&l_510,&l_510,(void*)0},{(void*)0,&l_510,&l_510,(void*)0,&l_510},{(void*)0,(void*)0,&l_510,&l_510,(void*)0},{&l_510,(void*)0,&l_510,&l_510,&l_510}}};
                    float *l_519 = &l_416;
                    int32_t l_526 = (-1L);
                    uint16_t l_527 = 0x540DL;
                    int i, j, k;
                    l_511 = &l_506;
                    /* statement id: 263 */
                    assert (l_511 == &l_506);
                    if (l_512)
                        break;
                    if (l_315)
                        goto lbl_513;
                    //assert (l_511 == dangling);
                    (*l_519) = (((((safe_div_func_float_f_f(l_516, ((safe_div_func_float_f_f(((l_519 == (void*)0) < ((l_520[6][5][2] == ((-0x10.Dp+1) == (safe_sub_func_float_f_f(((safe_div_func_float_f_f(((void*)0 != p_59), l_512)) <= (l_525[0] < l_512)), l_526)))) >= (-0x1.Bp-1))), l_526)) == (-0x1.9p+1)))) != 0x0.Ap+1) <= l_354[0][2]) >= 0x5.A1F2D7p-8) < l_527);
                }
                /* facts after for loop */
                //assert (l_511 == &l_506 || l_511 == dangling || l_511 == 0);
                (*l_399) = l_528;
            }
lbl_569:
            l_348 = (l_348 <= (!0xB9B0D8874411FA72LL));
            if ((+((void*)0 == p_59)))
            { /* block id: 271 */
                const uint32_t l_540 = 0x8C08B6E8L;
                int32_t *l_548 = &l_512;
                int32_t ***l_563 = (void*)0;
                struct S0 l_566[6] = {{4729},{-6103},{-6103},{4729},{-6103},{-6103}};
                struct S0 l_567[4] = {{2567},{2567},{2567},{2567}};
                uint32_t l_590 = 4294967292UL;
                const uint8_t l_629[4] = {255UL,255UL,255UL,255UL};
                struct S0 *** const *l_640 = &l_511;
                struct S0 *** const **l_639 = &l_640;
                int i;
                if (((safe_sub_func_uint16_t_u_u((safe_lshift_func_uint8_t_u_s((safe_lshift_func_uint16_t_u_u((((safe_div_func_uint32_t_u_u(l_540, l_540)) <= 0x127158A5L) == (l_354[0][1] == (safe_div_func_int16_t_s_s((l_540 != ((safe_add_func_int16_t_s_s(l_540, (+0xFAC6L))) <= (((void*)0 == l_548) & l_525[7]))), (*l_548))))), 5)), 2)), (*l_548))) && 0UL))
                { /* block id: 272 */
                    int8_t l_553[6][2][5] = {{{(-1L),(-1L),0x25L,(-1L),(-1L)},{0xF2L,(-1L),0xF2L,0xF2L,(-1L)}},{{(-1L),0xF2L,0xF2L,(-1L),0xF2L},{(-1L),(-1L),0x25L,(-1L),(-1L)}},{{0xF2L,(-1L),0xF2L,0xF2L,(-1L)},{(-1L),0xF2L,0xF2L,(-1L),0xF2L}},{{(-1L),(-1L),0x25L,(-1L),(-1L)},{0xF2L,(-1L),0xF2L,0xF2L,(-1L)}},{{(-1L),0xF2L,0xF2L,(-1L),0xF2L},{(-1L),(-1L),0x25L,(-1L),(-1L)}},{{0xF2L,(-1L),0xF2L,0xF2L,(-1L)},{(-1L),0xF2L,0xF2L,(-1L),0xF2L}}};
                    int32_t *l_561 = &l_61;
                    int i, j, k;
                    if (((((*l_548) > (safe_sub_func_int64_t_s_s((&l_511 == l_551), ((((void*)0 == &p_59) != l_552[1]) > (l_553[1][0][0] > (safe_add_func_int64_t_s_s(((safe_div_func_int32_t_s_s((safe_sub_func_int64_t_s_s((&l_530[1] == &l_530[0]), 0xE8849ED3211514C0LL)), l_553[1][0][0])) | (*l_548)), l_553[1][0][0]))))))) || l_560) || l_315))
                    { /* block id: 273 */
                        (**l_91) = l_561;
                        /* statement id: 274 */
                        assert (l_75 == &l_61);
                    }
                    else
                    { /* block id: 275 */
                        int32_t ****l_562[1];
                        int i;
                        for (i = 0; i < 1; i++)
                            l_562[i] = &l_341;
                        (**l_91) = p_59;
                        /* statement id: 276 */
                        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                        l_563 = l_341;
                        /* statement id: 277 */
                        assert (l_563 == &l_92);
                        (*l_92) = p_59;
                    }
                    /* facts after branching */
                    //assert (l_75 == 0 || l_75 == &l_61 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                    assert (l_563 == &l_92 || l_563 == 0);
                    for (l_367 = 3; (l_367 <= 8); l_367 += 1)
                    { /* block id: 282 */
                        int i;
                        (*l_561) = (l_564 == (void*)0);
                        if (l_383[l_367])
                            continue;
                        (*l_548) = l_383[l_367];
                    }
                }
                else
                { /* block id: 287 */
                    float *l_568 = &l_416;
                    for (l_61 = 1; (l_61 >= 0); l_61 -= 1)
                    { /* block id: 290 */
                        l_567[3] = l_566[3];
                        (*l_399) = (*l_268);
                        return p_59;
                        /* statement id: 293 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                    for (l_351 = 8; (l_351 >= 0); l_351 -= 1)
                    { /* block id: 297 */
                        return p_59;
                        /* statement id: 298 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                }
                /* facts after branching */
                assert (l_563 == &l_92 || l_563 == 0);
                if (l_367)
                    goto lbl_569;
                for (l_512 = 0; (l_512 <= 1); l_512 += 1)
                { /* block id: 304 */
                    uint8_t l_570[2][5][4] = {{{255UL,0x0FL,253UL,5UL},{0x09L,0x0FL,0x0FL,0x09L},{0x0FL,0x09L,255UL,0x92L},{0x0FL,255UL,0x0FL,253UL},{0x09L,0x92L,253UL,253UL}},{{255UL,255UL,5UL,0x92L},{0x92L,0x09L,5UL,0x09L},{255UL,0x0FL,253UL,5UL},{0x09L,0x0FL,0x0FL,0x09L},{0x0FL,0x09L,255UL,0x92L}}};
                    int32_t l_592 = 9L;
                    int i, j, k;
                    if (l_570[0][1][2])
                        break;
                    l_592 = ((((*l_548) < ((0x496E7423A7828EE9LL ^ 1UL) && (p_59 == (void*)0))) && (safe_lshift_func_int8_t_s_s(((((safe_add_func_int16_t_s_s(4L, (((((safe_lshift_func_int16_t_s_u(((((void*)0 == l_579) < ((safe_mod_func_int8_t_s_s(((((safe_rshift_func_uint8_t_u_u((safe_mod_func_int16_t_s_s(((safe_sub_func_uint64_t_u_u((safe_div_func_int8_t_s_s(((&l_530[0] != (void*)0) < 0x6B91523CL), l_570[0][1][2])), l_590)) > l_570[0][1][2]), l_354[0][2])), 3)) <= 6UL) & 4294967291UL) | (*l_548)), l_570[0][3][0])) && 18446744073709551606UL)) < (*l_548)), (*l_548))) || 65535UL) > l_383[2]) & l_520[6][5][2]) || l_591))) | l_570[1][2][2]) == 0xF1L) >= l_181[0][2]), 1))) >= l_570[0][1][2]);
                    (*l_415) = (-0x7.Cp+1);
                    (**l_91) = p_59;
                    /* statement id: 308 */
                    //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                    for (l_351 = 1; (l_351 >= 0); l_351 -= 1)
                    { /* block id: 311 */
                        int i, j;
                        l_76 = 0x269807B1L;
                        l_67[(l_351 + 2)][l_351] = l_593[0][2][0];
                        l_530[0] = (void*)0;
                        /* statement id: 314 */
                        //assert (l_530[0] == 0 || l_530[0] == &l_348);
                        return l_75;
                        /* statement id: 315 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                }
                if ((((l_351 && ((*l_548) & (((*l_548) < (*l_548)) > 0xC9DEA17399357E33LL))) >= (safe_rshift_func_uint8_t_u_s(((*l_548) || ((safe_div_func_uint16_t_u_u(((safe_add_func_int32_t_s_s(0x4869FFA6L, l_451)) <= 5L), l_600)) == 7UL)), 2))) < (*l_548)))
                { /* block id: 318 */
                    int32_t **l_612[6][9][4] = {{{&l_530[0],&l_530[2],&l_530[1],&l_530[0]},{&l_75,&l_548,&l_75,(void*)0},{&l_548,&l_548,&l_548,&l_75},{&l_530[2],&l_530[0],&l_530[1],&l_530[0]},{&l_548,&l_530[0],&l_530[0],(void*)0},{&l_530[1],&l_75,&l_548,&l_530[1]},{&l_530[1],&l_75,&l_548,&l_548},{&l_548,(void*)0,&l_530[1],&l_530[2]},{&l_75,&l_548,&l_530[1],&l_530[1]}},{{&l_548,(void*)0,&l_548,&l_548},{&l_530[0],(void*)0,&l_548,&l_75},{&l_75,&l_530[1],&l_75,&l_530[1]},{&l_548,&l_548,&l_75,(void*)0},{&l_548,&l_548,&l_530[1],&l_548},{&l_75,&l_75,&l_75,&l_75},{&l_530[0],&l_530[1],&l_75,&l_530[1]},{&l_548,&l_548,&l_75,&l_530[0]},{&l_530[2],&l_548,&l_548,&l_530[1]}},{{(void*)0,(void*)0,&l_530[0],&l_530[0]},{(void*)0,&l_75,&l_548,&l_530[1]},{&l_530[2],&l_530[0],&l_75,(void*)0},{&l_548,&l_530[1],&l_75,&l_530[1]},{&l_530[0],&l_75,&l_75,&l_548},{&l_530[0],&l_530[0],&l_548,&l_548},{&l_530[1],&l_530[0],&l_548,&l_548},{&l_75,&l_75,&l_530[1],(void*)0},{&l_530[0],&l_548,&l_548,&l_548}},{{&l_75,(void*)0,&l_530[1],&l_548},{&l_548,&l_530[0],&l_548,&l_530[0]},{&l_548,&l_530[0],(void*)0,&l_530[0]},{&l_530[1],&l_75,&l_530[0],&l_530[0]},{&l_548,(void*)0,&l_75,&l_75},{&l_548,&l_530[2],&l_75,&l_75},{&l_548,&l_530[1],&l_530[0],&l_530[1]},{&l_530[0],&l_548,&l_530[1],&l_530[1]},{&l_548,&l_548,(void*)0,&l_530[0]}},{{&l_548,&l_548,(void*)0,&l_530[0]},{&l_548,&l_548,(void*)0,&l_530[0]},{(void*)0,&l_530[1],&l_530[1],&l_548},{&l_75,&l_548,&l_530[0],(void*)0},{&l_530[2],&l_548,&l_548,&l_548},{(void*)0,&l_548,&l_548,&l_530[0]},{&l_548,&l_530[0],&l_530[0],&l_548},{&l_75,&l_548,(void*)0,&l_548},{&l_548,&l_548,&l_548,&l_75}},{{&l_75,&l_530[2],&l_530[1],&l_75},{&l_530[0],&l_548,(void*)0,&l_548},{&l_530[0],&l_548,(void*)0,&l_548},{&l_530[1],&l_530[0],&l_530[0],&l_530[0]},{&l_530[0],&l_548,&l_530[0],&l_548},{(void*)0,&l_548,&l_530[0],(void*)0},{&l_530[0],&l_548,&l_548,&l_548},{&l_530[1],&l_530[1],&l_530[2],&l_530[0]},{&l_548,&l_548,&l_548,&l_530[0]}}};
                    float *l_616 = &l_416;
                    int i, j, k;
                    if ((((void*)0 == l_601) || (safe_add_func_uint16_t_u_u((safe_sub_func_uint8_t_u_u(((safe_rshift_func_uint8_t_u_s((safe_mod_func_int8_t_s_s((((*l_548) ^ ((safe_add_func_int32_t_s_s(0L, ((void*)0 == l_612[2][6][0]))) < (*l_548))) ^ (*l_548)), 0x9CL)), (*l_548))) >= l_76), 0xBCL)), l_354[0][1]))))
                    { /* block id: 319 */
                        if (l_560)
                            goto lbl_613;
                        l_551 = &l_511;
                        (**l_91) = p_59;
                        /* statement id: 322 */
                        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                    }
                    else
                    { /* block id: 323 */
                        int32_t *l_614 = &l_61;
                        (**l_341) = p_59;
                        /* statement id: 324 */
                        //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                        (**l_341) = l_614;
                        /* statement id: 325 */
                        assert (l_75 == &l_61);
                        return p_59;
                        /* statement id: 326 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                    /* facts after branching */
                    //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                    return p_59;
                    /* statement id: 328 */
                    //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                }
                else
                { /* block id: 329 */
                    int64_t l_623 = 0x660DD4A891C6EBD8LL;
                    struct S0 l_636[1] = {{-1274}};
                    int32_t *l_642 = &l_76;
                    uint64_t l_643 = 6UL;
                    int i;
                    (*l_548) = (safe_mod_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((((void*)0 != l_563) > (((safe_sub_func_uint8_t_u_u(((*l_548) & l_623), (safe_add_func_int8_t_s_s((((!((safe_sub_func_uint64_t_u_u(l_629[2], ((safe_add_func_uint8_t_u_u((safe_add_func_int8_t_s_s((safe_rshift_func_uint8_t_u_u(0x1CL, 6)), ((*l_548) <= (&l_267 != &l_267)))), l_623)) && l_623))) == 0UL)) < l_623) | (*l_548)), (*l_548))))) ^ (*l_548)) >= (*l_548))), l_623)), l_623));
                    if ((*l_548))
                    { /* block id: 331 */
                        struct S0 *** const *l_638 = &l_511;
                        struct S0 *** const ** const l_637[9][9] = {{&l_638,(void*)0,&l_638,&l_638,&l_638,&l_638,&l_638,&l_638,(void*)0},{(void*)0,&l_638,&l_638,&l_638,&l_638,&l_638,&l_638,(void*)0,&l_638},{(void*)0,&l_638,&l_638,&l_638,&l_638,(void*)0,&l_638,(void*)0,&l_638},{(void*)0,&l_638,&l_638,&l_638,(void*)0,&l_638,(void*)0,&l_638,&l_638},{(void*)0,(void*)0,(void*)0,&l_638,(void*)0,&l_638,(void*)0,(void*)0,(void*)0},{&l_638,&l_638,(void*)0,&l_638,(void*)0,&l_638,&l_638,&l_638,&l_638},{&l_638,&l_638,(void*)0,&l_638,&l_638,&l_638,&l_638,&l_638,&l_638},{&l_638,(void*)0,&l_638,&l_638,(void*)0,(void*)0,&l_638,&l_638,(void*)0},{(void*)0,&l_638,&l_638,(void*)0,(void*)0,&l_638,&l_638,(void*)0,&l_638}};
                        int i, j;
                        (*l_399) = l_636[0];
                        if (l_512)
                            goto lbl_641;
lbl_641:
                        l_639 = l_637[8][5];
                        /* statement id: 333 */
                        assert (l_639 == &l_638 || l_639 == 0);
                        l_636[0] = (*l_268);
                        (**l_341) = l_642;
                        /* statement id: 336 */
                        assert (l_75 == &l_76);
                    }
                    else
                    { /* block id: 337 */
                        l_348 = l_643;
                    }
                    /* facts after branching */
                    //assert (l_639 == &l_640 || l_639 == dangling || l_639 == 0);
                }
                /* facts after branching */
                //assert (l_639 == &l_640 || l_639 == dangling || l_639 == 0);
            }
            else
            { /* block id: 341 */
                uint8_t l_652 = 0x0EL;
                (*l_415) = (0x1.Ap+1 != (((-0x2.6p+1) > ((safe_div_func_float_f_f((-0x7.8p-1), (safe_sub_func_float_f_f((((safe_sub_func_float_f_f((safe_add_func_float_f_f(((0xF.0903CBp-23 <= ((l_652 >= (safe_div_func_float_f_f((0x0.Cp-1 < l_488), ((l_652 < (safe_div_func_float_f_f(((safe_add_func_float_f_f(((l_652 == 0x0.5p-1) != l_652), (-0x1.9p-1))) < l_659), l_660))) < l_652)))) <= l_652)) <= l_652), l_661)), 0x2.D96BFDp+77)) == l_652) != (-0x1.6p+1)), l_652)))) != l_662)) <= l_383[2]));
                (**l_91) = p_59;
                /* statement id: 343 */
                //assert (l_75 == 0 || (l_75 >= &l_840[0][0] && l_75 <= &l_840[3][2]));
                for (l_76 = (-11); (l_76 > (-16)); l_76--)
                { /* block id: 346 */
                    for (l_560 = 1; (l_560 <= 8); l_560 += 1)
                    { /* block id: 349 */
                        (**l_91) = p_59;
                        (**l_341) = p_59;
                    }
                    (**l_91) = (**l_341);
                    if (l_652)
                        break;
                    for (l_451 = 0; (l_451 <= 1); l_451 += 1)
                    { /* block id: 357 */
                        return p_59;
                        /* statement id: 358 */
                        //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
                    }
                }
                for (l_660 = 0; (l_660 >= 11); l_660++)
                { /* block id: 363 */
                    const int32_t l_678 = 0L;
                    float l_680[1];
                    int32_t l_683 = 0x9879306DL;
                    float ** const *l_698[6];
                    int i;
                    for (i = 0; i < 1; i++)
                        l_680[i] = 0x3.995A0Cp-73;
                    for (i = 0; i < 6; i++)
                        l_698[i] = &l_565;
                    if (((void*)0 != p_59))
                    { /* block id: 364 */
                        uint32_t l_679 = 0xAF444A96L;
                        l_683 = (safe_add_func_float_f_f((0x7.992C38p+43 == (safe_add_func_float_f_f(l_652, (safe_div_func_float_f_f(0x1.Ap-1, (0x4.DDA1FEp+38 > (+(safe_add_func_float_f_f((safe_div_func_float_f_f((-0x1.Ap-1), l_678)), l_679))))))))), (l_680[0] <= (safe_sub_func_float_f_f(l_679, l_678)))));
                        (*l_415) = (((l_683 != (((l_683 == ((safe_add_func_float_f_f((((((l_652 <= (safe_sub_func_float_f_f(((safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_div_func_float_f_f((((-0x3.Dp+1) == (((!(((safe_div_func_float_f_f(l_679, (((((**l_579) == (void*)0) >= (l_652 > l_678)) > 0x1.5p+1) < 0x5.Ep+1))) != l_679) != 0x0.53FE26p-45)) >= l_697[3][0]) <= l_683)) > l_679), 0x5.8p+1)), l_679)), l_488)) <= l_652), 0x1.4p+1))) > l_488) >= l_679) >= 0x6.9FC66Cp-88) >= 0x1.E0970Ep-89), l_652)) <= l_679)) == 0xF.DF5154p-32) == l_652)) <= l_652) == 0x4.60A22Fp+24);
                        l_76 = ((void*)0 != l_698[2]);
                    }
                    else
                    { /* block id: 368 */
                        const struct S0 l_699 = {8020};
                        (*l_399) = l_699;
                    }
                }
            }
        }
    }
    else
    { /* block id: 374 */
        uint8_t l_700 = 255UL;
        int32_t *l_701 = &l_76;
        struct S0 l_702 = {6844};
        struct S0 *l_703 = &l_702;
        (*l_701) = (l_700 == 0xBE390C220121B0BDLL);
        (*l_703) = l_702;
    }
    l_705 = &l_267;
    return p_59;
    /* statement id: 379 */
    //assert (func_58_rv == 0 || (func_58_rv >= &l_840[0][0] && func_58_rv <= &l_840[3][2]));
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 289
   depth: 1, occurrence: 27
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 62
breakdown:
   indirect level: 0, occurrence: 27
   indirect level: 1, occurrence: 11
   indirect level: 2, occurrence: 7
   indirect level: 3, occurrence: 7
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 27
breakdown:
   indirect level: 0, occurrence: 27
XXX times a bitfields struct's address is taken: 26
XXX times a bitfields struct on LHS: 13
XXX times a bitfields struct on RHS: 37
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 14

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 259
   depth: 2, occurrence: 60
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 6
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 4
   depth: 17, occurrence: 4
   depth: 18, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 275

XXX times a variable address is taken: 616
XXX times a pointer is dereferenced on RHS: 127
breakdown:
   depth: 1, occurrence: 76
   depth: 2, occurrence: 32
   depth: 3, occurrence: 12
   depth: 4, occurrence: 7
XXX times a pointer is dereferenced on LHS: 114
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 33
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 49
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 29
XXX times a pointer is qualified to be dereferenced: 1631

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 551
   level: 2, occurrence: 311
   level: 3, occurrence: 227
   level: 4, occurrence: 14
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 135
XXX number of pointers point to scalars: 122
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 34.9
XXX average alias set size: 1.29

XXX times a non-volatile is read: 1148
XXX times a non-volatile is write: 398
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 238
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 34
   depth: 2, occurrence: 33
   depth: 3, occurrence: 33
   depth: 4, occurrence: 48
   depth: 5, occurrence: 57

XXX percentage a fresh-made variable is used: 13.7
XXX percentage an existing variable is used: 86.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

