/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      2127775004
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 28;
   signed f1 : 1;
   uint32_t  f2;
   unsigned f3 : 23;
   signed : 0;
   signed f4 : 12;
   uint16_t  f5;
   signed f6 : 1;
   signed f7 : 4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_29(void);
static int32_t  func_34(struct S0  p_35);
static struct S0  func_37(uint16_t  p_38);
static int16_t  func_49(uint32_t  p_50, int16_t  p_51, int32_t  p_52);
static struct S0  func_57(struct S0  p_58, uint32_t  p_59, int16_t  p_60, uint32_t  p_61);
static int32_t  func_67(uint16_t  p_68, struct S0  p_69, int32_t  p_70, uint32_t  p_71, int16_t  p_72);
static struct S0  func_73(int32_t  p_74, uint32_t  p_75);
inline static uint32_t  func_78(int32_t  p_79, int16_t  p_80);
inline static struct S0  func_91(int32_t  p_92, uint32_t  p_93, struct S0  p_94, struct S0  p_95);
static struct S0  func_96(int32_t  p_97, int32_t  p_98, int32_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_29(void)
{ /* block id: 36 */
    uint32_t l_30 = 4U;
    int32_t l_31 = 0x9F23E525;
    struct S0 l_36 = {-14746,0,0xF4A7D2AE,2040,-5,0x1A09,0,1};
    int32_t l_439 = 0x50938F23;
    int32_t l_454 = 8;
    struct S0 l_456 = {-4352,0,0x7DF4D302,1491,20,0x59BA,-0,2};
    struct S0 l_463 = {3798,-0,0x65AEF696,413,11,1U,-0,1};
    l_31 = __builtin_ctzll(l_30);
    if ((l_36.f7 = ((int16_t)(l_30 && (((func_34(l_36) ^ ((l_36.f3 , ((int16_t)(((((uint32_t)l_36.f4 + (uint32_t)(l_31 &= l_36.f3)) != (((int16_t)((~l_36.f0) != func_78((func_78(l_36.f4, ((l_439 = (__builtin_ctzll((__builtin_ctzll(l_36.f3) , 0U)) , l_36.f6)) & l_36.f5)) , 0x0E2166E6), l_36.f4)) * (int16_t)0U) < l_36.f5)) , l_31) || 9) * (int16_t)l_36.f4)) == l_36.f0)) == l_30) , l_36.f0)) - (int16_t)l_36.f0)))
    { /* block id: 228 */
        int32_t l_442 = (-1);
        int32_t l_443 = 0x1F945CB3;
        uint32_t l_453 = 4294967293U;
        int32_t l_455 = 0x1D417EBA;
        struct S0 l_457 = {-8012,-0,4294967287U,2582,30,0x8EF9,0,0};
        l_36.f1 = l_439;
        l_457 = func_91((l_455 = ((uint16_t)(l_443 &= (l_442 , (l_36.f1 = 5U))) >> (uint16_t)(((uint16_t)(!0x5CE0F95C) + (uint16_t)(l_442 ^ l_31)) == ((uint32_t)(l_36.f3 , ((uint16_t)func_49(((func_78(((uint16_t)l_453 - (uint16_t)__builtin_clzll(l_36.f4)), l_453) > l_453) , l_36.f5), l_453, l_453) * (uint16_t)l_30)) + (uint32_t)l_454)))), l_36.f0, l_456, l_457);
        l_457 = func_37((l_457.f6 < (func_67((l_456.f6 = ((uint16_t)(l_439 <= (l_457.f6 ^ 1)) % (uint16_t)(l_457.f7 || (!((int16_t)(func_34(l_463) == l_457.f1) - (int16_t)((((uint16_t)(l_457.f0 , l_454) << (uint16_t)l_463.f2) >= 0x5BC4) > l_457.f1)))))), l_463, l_456.f1, l_463.f0, l_36.f1) , 4294967287U)));
        for (l_443 = 15; (l_443 <= 28); l_443 += 1)
        { /* block id: 238 */
            uint32_t l_468 = 0U;
            uint32_t l_469 = 4294967295U;
            int32_t l_474 = 1;
            l_36.f4 = ((func_73(l_36.f7, l_468) , l_469) | (l_36.f7 , ((l_457 , ((((uint16_t)((int16_t)(l_453 == l_469) * (int16_t)__builtin_parity((l_456.f6 = ((((((l_468 <= l_36.f2) <= 0U) , l_36.f3) , l_455) >= l_474) ^ l_463.f0)))) * (uint16_t)0xABE5) || l_457.f2) <= l_456.f0)) | 0)));
            return l_439;
        }
    }
    else
    { /* block id: 243 */
        struct S0 l_475 = {13227,0,4294967294U,2444,-31,0x241A,-0,-0};
        l_463 = ((l_475 , 1) , l_475);
    }
    return l_463.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_34(struct S0  p_35)
{ /* block id: 38 */
    uint16_t l_45 = 0U;
    int32_t l_46 = 0;
    int16_t l_55 = 0xC334;
    struct S0 l_431 = {-15615,0,0x212E763A,1868,1,0U,0,1};
    l_431 = func_37((((uint32_t)((uint16_t)((uint16_t)(((l_45 , l_46) & (l_46 , ((int16_t)func_49(__builtin_parity(p_35.f4), l_45, l_45) * (int16_t)1))) == l_55) - (uint16_t)0x61FA) << (uint16_t)l_46) + (uint32_t)l_55) >= l_55));
    return p_35.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_37(uint16_t  p_38)
{ /* block id: 42 */
    uint16_t l_56 = 0x98A5;
    struct S0 l_62 = {8931,0,0xE95372A7,2401,24,0xA8FD,0,-3};
    int32_t l_85 = 0x870D1841;
    int32_t l_171 = 1;
    int32_t l_192 = 0x912BC1F6;
    uint16_t l_215 = 65535U;
    uint32_t l_268 = 4294967295U;
    int32_t l_338 = 0x996C2E0F;
    uint16_t l_364 = 0x5BE2;
    uint32_t l_390 = 0x6CF501CB;
    int32_t l_398 = (-8);
    int32_t l_425 = 1;
    if ((l_56 , (func_57(l_62, (l_192 |= (l_62.f7 , ((int16_t)(-1) >> (int16_t)((((int16_t)l_62.f6 >> (int16_t)10) || func_67(l_56, func_73(((uint16_t)(l_171 = __builtin_parity(func_78((l_62.f5 > ((int16_t)p_38 >> (int16_t)(l_85 = ((((((((uint16_t)p_38 << (uint16_t)l_62.f7) & (-8)) || p_38) || p_38) || p_38) < l_62.f5) ^ 0x55FCA997)))), l_56))) << (uint16_t)p_38), p_38), l_62.f3, l_62.f2, p_38)) != l_62.f2)))), p_38, l_62.f4) , l_62.f7)))
    { /* block id: 108 */
        uint16_t l_216 = 65534U;
        int32_t l_226 = 0xFDFA3877;
        struct S0 l_228 = {-6950,0,4294967289U,753,-42,0x059A,0,-3};
        uint32_t l_249 = 0x31D1B604;
        int32_t l_310 = (-1);
        int16_t l_371 = 0xC510;
        struct S0 l_424 = {-5296,-0,0x5A258CD0,1329,53,1U,-0,-2};
        l_216 = (0xBB20 | ((int32_t)l_215 - (int32_t)0x6A00AF91));
        for (l_85 = 14; (l_85 == (-26)); l_85 -= 1)
        { /* block id: 112 */
            uint16_t l_223 = 0U;
            int32_t l_227 = 0xC6CF8349;
            struct S0 l_229 = {-11946,-0,8U,1735,-43,0x35BA,0,-3};
            int32_t l_339 = (-1);
            uint32_t l_340 = 0xE66A94C7;
            int16_t l_384 = 4;
            l_227 = (p_38 , ((int16_t)(p_38 >= (l_215 <= ((int16_t)l_223 - (int16_t)(p_38 , (l_226 = ((uint32_t)p_38 % (uint32_t)p_38)))))) * (int16_t)p_38));
            if ((l_226 = p_38))
            { /* block id: 116 */
                uint32_t l_232 = 4294967295U;
                int32_t l_241 = 1;
                int32_t l_282 = 0x9C87993F;
                struct S0 l_297 = {-7685,0,4294967286U,1101,-51,0x5BC2,-0,-3};
                if ((l_227 ^= 0xB3240AD2))
                { /* block id: 118 */
                    int32_t l_242 = 1;
                    struct S0 l_243 = {-13128,-0,0xDF1EA78D,498,-2,1U,0,-2};
                    l_229 = l_228;
                    l_241 = __builtin_bswap32((((l_243.f7 = ((func_67(((uint16_t)(l_232 = 0x4324) << (uint16_t)7), (((__builtin_popcountl((0xA6ECE732 && (((int32_t)(l_228 , (((uint16_t)(1 == (l_229.f4 ^= l_228.f0)) - (uint16_t)((uint16_t)p_38 << (uint16_t)(l_62.f4 = ((((uint16_t)(((__builtin_ctz(l_62.f7) > func_67(l_241, l_62, p_38, l_228.f2, l_242)) , l_228) , 0x85EF) + (uint16_t)p_38) , 0x34D6) <= l_241)))) , p_38)) + (int32_t)l_228.f6) <= p_38))) , l_241) & 65535U) , l_243), p_38, p_38, p_38) | l_228.f0) > l_229.f7)) ^ l_241) , l_223));
                    return l_243;
                }
                else
                { /* block id: 126 */
                    uint32_t l_248 = 0x0A819F9F;
                    int32_t l_272 = 0xA1B20B8C;
                    int32_t l_273 = (-1);
                    int32_t l_274 = 0;
                    int32_t l_275 = (-1);
                    struct S0 l_305 = {-15340,-0,0x27F55DE8,2410,27,0U,-0,2};
                    if ((1 < ((l_232 && ((int16_t)((((int16_t)l_248 << (int16_t)2) < (l_228.f2 >= (((l_249 , 0x3C3DD7BF) || (l_192 = l_229.f1)) || (0xBE46 > ((int16_t)((p_38 | p_38) && p_38) * (int16_t)p_38))))) , l_249) % (int16_t)p_38)) != 0x841CB193)))
                    { /* block id: 128 */
                        uint32_t l_253 = 0xD7B02921;
                        int32_t l_271 = (-1);
                        l_253 ^= ((~p_38) || (0 & l_248));
                        l_275 &= (l_274 = ((int16_t)(func_78((((uint16_t)((int16_t)(((((((p_38 != ((l_216 > (((l_241 = (l_228 , ((int16_t)p_38 << (int16_t)12))) > ((uint16_t)(l_273 = ((uint16_t)((l_272 ^= (l_228 , (((int32_t)__builtin_popcount((l_268 < (l_271 = (((p_38 | (l_232 , ((int16_t)p_38 << (int16_t)11))) || p_38) || p_38)))) - (int32_t)p_38) < 1U))) != p_38) + (uint16_t)0x244A)) % (uint16_t)l_253)) , p_38)) <= l_248)) >= p_38) < l_253) | 0xBD1B2AB0) , 0x0CF9A2BB) > 0xEA64F363) & p_38) << (int16_t)14) >> (uint16_t)p_38) , p_38), l_227) ^ l_248) >> (int16_t)7));
                    }
                    else
                    { /* block id: 136 */
                        l_282 = (((int32_t)p_38 - (int32_t)(((uint16_t)(p_38 , 7U) + (uint16_t)(func_67(p_38, (l_228 , l_228), (l_241 = p_38), (((((uint16_t)p_38 + (uint16_t)(func_49(l_232, l_248, p_38) && 0x2EA6)) >= p_38) , p_38) | 0x007509DA), p_38) | l_229.f2)) , l_228.f5)) && 1);
                        l_274 = ((int16_t)p_38 + (int16_t)(l_192 , (l_229.f4 = 65535U)));
                        l_227 = ((((int32_t)p_38 % (int32_t)(l_229.f1 ^= (__builtin_clzll((l_62.f6 = (((int16_t)((int16_t)__builtin_ctz(((uint32_t)(((l_229.f0 = l_232) | (l_282 = ((int16_t)p_38 * (int16_t)l_228.f5))) > ((l_297.f7 = (((int16_t)p_38 - (int16_t)(__builtin_popcount((l_297 , (p_38 ^ ((((((uint16_t)(l_297.f6 = (((int16_t)(l_62.f1 = func_78((p_38 && func_67((-(uint32_t)(((int16_t)l_272 << (int16_t)l_297.f6) & p_38)), l_305, p_38, l_62.f6, p_38)), l_248)) >> (int16_t)14) , p_38)) * (uint16_t)p_38) >= p_38) , 0xEF4640E2) ^ l_241) , l_272)))) | p_38)) | 3)) >= 0x8A00)) % (uint32_t)p_38)) << (int16_t)p_38) >> (int16_t)l_85) , 0xDFF3299ABA915A7FLL))) , 4294967293U))) == l_62.f7) < p_38);
                        if (l_229.f7)
                            break;
                    }
                }
                l_62.f4 = (p_38 , (((func_78(l_62.f0, ((int16_t)(((int16_t)((l_228 = (l_297 = l_228)) , l_310) << (int16_t)6) ^ (((int16_t)(l_229.f0 = 6) >> (int16_t)(p_38 = (((l_62.f7 = ((-1) != 0x5B34151B)) > ((p_38 | (l_282 != p_38)) , p_38)) , 65530U))) , p_38)) * (int16_t)l_241)) && l_227) < l_229.f5) <= l_229.f5));
            }
            else
            { /* block id: 158 */
                uint32_t l_329 = 0x876800FB;
                int32_t l_330 = 1;
                int32_t l_331 = 2;
                struct S0 l_353 = {-7974,0,4294967289U,1085,-19,0xAD19,0,0};
                struct S0 l_421 = {-6763,0,0xBD036475,2734,-47,65535U,0,2};
                if ((func_49((((uint32_t)((int16_t)((((int32_t)((uint32_t)((uint16_t)((((((l_229.f0 = (l_228.f4 |= (((p_38 = p_38) , 0xF05E) < ((uint16_t)l_226 << (uint16_t)((int32_t)l_229.f1 + (int32_t)((int16_t)((((l_339 ^= (__builtin_parity((((l_329 & l_229.f7) , (l_331 |= (l_330 = l_229.f4))) != (l_228.f0 |= (~(((l_227 &= ((uint16_t)(~((l_229.f6 , (((uint16_t)(((0x6ABC || l_228.f1) || 1) && l_85) >> (uint16_t)l_62.f3) <= 65534U)) == l_62.f2)) + (uint16_t)l_229.f0)) & l_329) != l_62.f3))))) <= l_338)) & l_228.f2) , l_229.f6) , 0xE83C) - (int16_t)l_310)))))) && 1U) | 0) >= l_228.f6) > l_228.f1) < l_229.f6) << (uint16_t)l_223) + (uint32_t)l_223) % (int32_t)l_249) & l_229.f3) || p_38) * (int16_t)l_329) - (uint32_t)l_329) ^ l_229.f7), l_329, l_62.f0) < 0x2525))
                { /* block id: 167 */
                    uint32_t l_347 = 0U;
                    struct S0 l_352 = {8710,0,1U,2460,25,65527U,0,-0};
                    l_229.f0 = ((l_331 = l_340) && __builtin_parityll(__builtin_ffsll(p_38)));
                    l_353 = func_91(p_38, ((int32_t)((int16_t)(((l_338 ^= ((int16_t)((65534U <= (((l_347 && func_49(p_38, ((l_229.f4 & p_38) , l_347), ((int32_t)l_228.f3 % (int32_t)((uint16_t)l_268 >> (uint16_t)4)))) , l_229.f3) & 0x33FA)) || l_192) % (int16_t)l_330)) != 1U) && l_228.f7) - (int16_t)l_331) % (int32_t)l_331), l_62, l_352);
                    for (l_353.f5 = 2; (l_353.f5 <= 48); l_353.f5 += 1)
                    { /* block id: 174 */
                        int16_t l_356 = 0x3876;
                        l_62.f7 &= l_353.f3;
                        if (l_356)
                            break;
                        l_229 = func_73(l_229.f1, p_38);
                    }
                    l_229.f1 = ((uint16_t)l_229.f1 << (uint16_t)((uint16_t)l_329 >> (uint16_t)l_352.f3));
                }
                else
                { /* block id: 180 */
                    int32_t l_365 = 0xBD92167C;
                    struct S0 l_368 = {12659,-0,0x65B2EF04,2493,41,65527U,-0,-0};
                    uint16_t l_400 = 65535U;
                    l_228 = func_91((l_353.f1 , l_192), (!(((int16_t)(l_364 <= l_365) >> (int16_t)((int16_t)(l_62.f6 = 0xC3F5) % (int16_t)l_227)) | (p_38 = l_228.f7))), l_368, l_229);
                    if ((((int32_t)(l_268 > l_371) - (int32_t)(((l_228.f7 = (l_353.f3 < ((p_38 | ((int16_t)(l_330 = p_38) - (int16_t)(p_38 | (p_38 != (((int32_t)(l_62.f6 = func_67(p_38, l_368, l_310, l_340, l_331)) % (int32_t)l_368.f4) & p_38))))) == 0U))) || l_229.f1) < l_331)) > l_331))
                    { /* block id: 187 */
                        uint32_t l_376 = 0x59E41F57;
                        int32_t l_377 = 9;
                        uint32_t l_385 = 0U;
                        struct S0 l_388 = {-7426,0,4U,2374,46,65533U,-0,2};
                        l_377 = l_376;
                        l_229.f4 = (((int16_t)((0U & ((func_78((l_377 &= ((int32_t)((uint32_t)(l_384 != (p_38 > l_353.f2)) + (uint32_t)0x7E64A294) % (int32_t)(l_385 |= p_38))), l_353.f3) != (((int16_t)((func_67(((p_38 < p_38) , p_38), l_388, l_56, l_368.f7, l_216) ^ l_228.f7) , p_38) << (int16_t)p_38) || p_38)) == p_38)) && 0xA7D39667) % (int16_t)65535U) ^ l_353.f7);
                        l_228.f1 = (!p_38);
                    }
                    else
                    { /* block id: 193 */
                        uint16_t l_393 = 8U;
                        struct S0 l_401 = {12885,-0,0xAA5BAC8D,2842,-38,0x841F,0,0};
                        if (l_390)
                            break;
                        l_62.f6 = ((int16_t)__builtin_ffsl(__builtin_popcount(p_38)) - (int16_t)(((((((l_338 = p_38) > (l_393 >= (((uint16_t)p_38 * (uint16_t)(((int16_t)l_368.f1 * (int16_t)(0xDEF4 && (p_38 | p_38))) <= 4294967288U)) > p_38))) < 65535U) != (-6)) | (-7)) || l_249) >= 0U));
                        l_401 = func_96((((l_330 = (l_338 = 4294967287U)) && ((l_398 == p_38) , p_38)) > l_228.f4), __builtin_parityl(l_227), (0xA31A > ((((~l_400) || l_227) , l_228.f2) , l_364)));
                    }
                    l_421 = func_73(((0x3CE176B3 != __builtin_popcountl((l_398 |= ((int16_t)p_38 << (int16_t)((int16_t)(((((uint32_t)((func_67((l_228.f2 < (((uint16_t)(((((uint16_t)p_38 + (uint16_t)(__builtin_clzl((((uint16_t)((~((((uint32_t)0x88D00478 % (uint32_t)((((uint16_t)0x15F8 * (uint16_t)p_38) == (((uint16_t)(((l_368.f4 = 1U) ^ 0xB822800B) & 4294967287U) * (uint16_t)l_329) ^ 0x2C8D4748)) , l_85)) && p_38) || 0x670A)) || 0x4AA381EE) << (uint16_t)8) | l_368.f2)) , l_228.f1)) | p_38) ^ p_38) , l_216) << (uint16_t)6) == 0x100EEA3E)), l_229, p_38, l_62.f4, l_368.f5) == (-1)) || p_38) % (uint32_t)0xE502F8B6) , 0) || p_38) || l_229.f5) * (int16_t)p_38))))) < (-1)), p_38);
                }
                l_421.f0 = p_38;
                return l_228;
            }
        }
        l_228 = func_91(p_38, (func_96(((p_38 , p_38) | ((uint32_t)((func_67(l_62.f4, func_57(func_73((l_228.f1 = __builtin_clzll(p_38)), p_38), l_398, p_38, p_38), l_62.f3, p_38, p_38) >= p_38) & 0x41AECE32) % (uint32_t)p_38)), p_38, l_215) , 4294967288U), l_424, l_424);
        l_62.f1 = (l_62.f7 <= (l_310 |= 1U));
    }
    else
    { /* block id: 213 */
        int16_t l_426 = 8;
        int32_t l_427 = 0xC06C6AB1;
        struct S0 l_428 = {11737,0,9U,32,56,65535U,0,-2};
        l_427 |= ((l_426 |= (p_38 , (l_425 , l_171))) > 0x67E0);
        l_62 = l_428;
    }
    l_62 = l_62;
    l_85 |= ((l_62.f4 = l_56) >= p_38);
    l_62.f1 = ((uint16_t)p_38 >> (uint16_t)l_398);
    return l_62;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_49(uint32_t  p_50, int16_t  p_51, int32_t  p_52)
{ /* block id: 39 */
    int32_t l_53 = 0xEAE26468;
    int32_t l_54 = 0x213AABDC;
    l_54 = l_53;
    return p_51;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_57(struct S0  p_58, uint32_t  p_59, int16_t  p_60, uint32_t  p_61)
{ /* block id: 92 */
    uint32_t l_197 = 1U;
    int32_t l_200 = 0xD46ABB7C;
    int32_t l_201 = 0;
    struct S0 l_211 = {8463,0,1U,580,41,0x0ACF,0,3};
    p_58.f4 = p_58.f5;
    p_58.f6 ^= ((p_58.f5 <= (((int16_t)0 << (int16_t)11) > ((uint16_t)(l_201 = (l_200 = ((((p_58.f5 && p_58.f2) & l_197) , 0xDE1C9599) > (p_58.f0 | ((l_197 , (((uint16_t)(p_58.f5 < 0x617F3B7B) + (uint16_t)p_58.f1) || 0x1FC836E9)) , 65535U))))) << (uint16_t)0))) < 0x7EA1);
    for (p_60 = 6; (p_60 <= (-19)); p_60 -= 1)
    { /* block id: 99 */
        int32_t l_207 = 1;
        int32_t l_210 = (-1);
        struct S0 l_212 = {-10360,0,0x9EF1CF84,2660,62,65535U,0,3};
        p_58.f1 = (((uint16_t)((p_58.f3 == (-(uint16_t)((p_58.f4 , __builtin_popcountll((p_58.f3 && __builtin_clzl(((l_207 = 0x93F941D6) , ((int16_t)(((65533U < 0x4B7A) & p_58.f4) > (l_200 = p_60)) * (int16_t)(l_207 = l_207))))))) <= p_58.f7))) , l_201) << (uint16_t)l_201) != l_210);
        l_212 = l_211;
        l_212 = p_58;
    }
    return l_211;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_67(uint16_t  p_68, struct S0  p_69, int32_t  p_70, uint32_t  p_71, int16_t  p_72)
{ /* block id: 86 */
    int16_t l_186 = 0xA4E1;
    uint16_t l_190 = 0xFC46;
    int32_t l_191 = 0x523DC5B1;
    p_69.f4 = __builtin_clzl(((uint32_t)(((((int16_t)func_78(p_69.f2, (-(uint32_t)(l_186 ^ (l_191 &= ((int32_t)(l_190 = (-(int32_t)p_71)) - (int32_t)__builtin_clzl((p_69.f0 , p_69.f3))))))) << (int16_t)((((0x722CCF1A && l_186) | l_186) != 1U) ^ l_186)) <= l_186) && 0x1DA3A345) , l_191) - (uint32_t)l_186));
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_73(int32_t  p_74, uint32_t  p_75)
{ /* block id: 78 */
    struct S0 l_176 = {-5698,-0,1U,695,61,0x01FF,0,0};
    for (p_74 = 15; (p_74 >= 17); p_74 += 1)
    { /* block id: 81 */
        if (p_74)
            break;
    }
    p_74 &= (p_75 < ((int16_t)func_49(p_75, (l_176 , (p_75 & l_176.f6)), ((__builtin_clzll(((((int16_t)l_176.f5 << (int16_t)1) < ((uint16_t)1U - (uint16_t)p_75)) >= (((((l_176.f7 , 0xD4D9) <= 0xA790) <= 0xFE8C) != p_75) ^ p_75))) < 6U) <= l_176.f5)) << (int16_t)6));
    return l_176;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_78(int32_t  p_79, int16_t  p_80)
{ /* block id: 44 */
    int16_t l_88 = (-1);
    struct S0 l_117 = {-989,-0,4294967295U,2415,60,5U,-0,-2};
    if (((uint16_t)p_79 * (uint16_t)l_88))
    { /* block id: 45 */
        return l_88;
    }
    else
    { /* block id: 47 */
        struct S0 l_137 = {-12191,0,0x64895FD5,1142,0,0x493B,0,2};
        for (p_79 = 0; (p_79 != (-19)); p_79 -= 1)
        { /* block id: 50 */
            int32_t l_100 = 0xDB43F150;
            struct S0 l_128 = {8796,-0,4294967287U,1981,25,65533U,0,-0};
            l_128 = func_91((1U == p_79), p_80, func_96(p_79, (l_100 &= p_79), l_88), l_117);
            l_137.f6 = (((uint16_t)((uint32_t)((int16_t)((int32_t)(l_137 , (!((uint16_t)((uint16_t)((uint16_t)3U * (uint16_t)((-(int32_t)p_80) > (-(uint16_t)(((uint32_t)((uint32_t)(((int16_t)0x7D33 << (int16_t)(((uint16_t)(((l_117 , ((uint16_t)0x9ECA * (uint16_t)(l_137.f5 | (((l_117 , p_80) | l_117.f6) | l_117.f4)))) , 0x9008) < l_117.f2) << (uint16_t)p_79) && 0x3E3A335C)) | p_80) + (uint32_t)l_128.f3) + (uint32_t)l_128.f6) >= 0xC38B1D14)))) >> (uint16_t)2) + (uint16_t)l_137.f1))) % (int32_t)p_79) >> (int16_t)l_128.f3) % (uint32_t)l_137.f6) * (uint16_t)l_137.f4) == 0x40FA7CF2);
            l_117.f4 |= (__builtin_parityll(l_137.f2) == ((uint32_t)(l_128.f2 >= ((uint16_t)((int16_t)l_128.f6 * (int16_t)((int32_t)((uint16_t)(((uint16_t)func_49((((uint32_t)0xDFD280BC % (uint32_t)0xB374F054) , (p_80 , l_117.f2)), l_128.f2, l_117.f3) * (uint16_t)p_80) , p_80) * (uint16_t)l_117.f0) + (int32_t)l_137.f7)) >> (uint16_t)p_80)) + (uint32_t)l_137.f0));
            if (p_79)
                continue;
        }
        return p_80;
    }
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_91(int32_t  p_92, uint32_t  p_93, struct S0  p_94, struct S0  p_95)
{ /* block id: 61 */
    int16_t l_118 = 0;
    int32_t l_125 = 4;
    int32_t l_126 = 0;
    struct S0 l_127 = {1920,0,4294967295U,35,-6,65535U,0,1};
    p_94.f7 = p_94.f6;
    p_95.f1 = p_95.f7;
    p_95.f4 ^= l_118;
    l_126 = (((func_49(((l_118 & ((int16_t)__builtin_clz(p_94.f7) * (int16_t)((uint16_t)(l_118 && ((((int16_t)((p_95.f2 = p_95.f5) >= p_95.f1) << (int16_t)9) | 0U) , (l_125 ^= (-1)))) >> (uint16_t)(((func_49((p_93 = __builtin_ctzll(l_118)), l_118, p_94.f7) ^ l_118) || p_95.f7) & l_118)))) || 0), p_94.f6, p_94.f0) < l_118) == (-9)) , 9);
    return l_127;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_96(int32_t  p_97, int32_t  p_98, int32_t  p_99)
{ /* block id: 52 */
    uint16_t l_103 = 65529U;
    int32_t l_104 = 0x275A216B;
    int32_t l_105 = 0;
    int32_t l_109 = 0x6D9AC2FE;
    int32_t l_112 = 0x41F2E98D;
    int32_t l_115 = 0x89BD50C8;
    struct S0 l_116 = {11107,0,4294967292U,530,-40,1U,-0,-2};
    l_105 = ((int32_t)(func_49(l_103, (l_104 |= p_99), l_103) ^ l_103) + (int32_t)0xC549E5CE);
    p_98 ^= (p_99 || (((int16_t)(((p_99 & (l_104 &= (p_97 , l_105))) , (l_104 >= (-(uint32_t)(l_109 = (l_105 = 0x26D39625))))) ^ (((uint16_t)(l_112 = p_97) * (uint16_t)((p_99 == ((uint16_t)(l_103 == 0xF0D96589) + (uint16_t)l_103)) && p_97)) == l_115)) << (int16_t)1) || l_103));
    return l_116;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 89
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 7
XXX zero bitfields defined in structs: 1
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 28
breakdown:
   indirect level: 0, occurrence: 28
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 18
XXX times a bitfields struct on RHS: 46
XXX times a single bitfield on LHS: 46
XXX times a single bitfield on RHS: 120

XXX max expression depth: 49
breakdown:
   depth: 1, occurrence: 88
   depth: 2, occurrence: 11
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 2
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 2
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 2
   depth: 30, occurrence: 1
   depth: 35, occurrence: 1
   depth: 39, occurrence: 1
   depth: 40, occurrence: 1
   depth: 43, occurrence: 1
   depth: 45, occurrence: 1
   depth: 49, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 555
XXX times a non-volatile is write: 140
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 87
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 18
   depth: 2, occurrence: 8
   depth: 3, occurrence: 5
   depth: 4, occurrence: 11
   depth: 5, occurrence: 15

XXX percentage a fresh-made variable is used: 17.1
XXX percentage an existing variable is used: 82.9
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

