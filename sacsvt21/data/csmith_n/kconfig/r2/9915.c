/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      4065658584
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 26;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int8_t  func_1(void);
inline static struct S0  func_7(int32_t  p_8, const int32_t * p_9);
static uint8_t  func_10(int32_t ** p_11, int32_t * const  p_12, int64_t  p_13, int32_t * const * p_14);
static int32_t ** func_17(struct S0  p_18);
inline static struct S0  func_27(int32_t * const  p_28, struct S0  p_29, int32_t  p_30);
inline static int32_t * const  func_31(uint32_t  p_32, int32_t ** p_33, const int32_t  p_34);
static int8_t  func_43(uint64_t  p_44, int64_t  p_45);
inline static const uint8_t  func_47(uint64_t  p_48, uint16_t  p_49, int32_t  p_50);
inline static const uint8_t  func_51(uint32_t  p_52);
static struct S0  func_55(int32_t ** p_56);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_1(void)
{ /* block id: 0 */
    int8_t l_2 = 0x69L;
    int32_t * const l_3 = (void*)0;
    int32_t l_16 = (-2L);
    int32_t * const l_15 = &l_16;
    struct S0 l_19 = {-4969};
    int8_t l_1682 = 0L;
    if (l_2)
    { /* block id: 1 */
        int32_t l_6 = (-1L);
        int32_t *l_5 = &l_6;
        int32_t **l_4 = &l_5;
        struct S0 *l_1680 = &l_19;
        (*l_4) = l_3;
        /* statement id: 2 */
        assert (l_5 == 0);
        (*l_1680) = func_7((((void*)0 != &l_5) >= func_10(&l_5, l_15, ((*l_15) ^ ((void*)0 == &l_3)), func_17(l_19))), &l_6);
        /* statement id: 834 */
        //assert (l_5 == dangling || l_5 == 0);
        (*l_4) = &l_16;
        /* statement id: 835 */
        assert (l_5 == &l_16);
    }
    else
    { /* block id: 836 */
        int64_t l_1681 = 0x17833A5B94A11484LL;
        return l_1681;
    }
    return l_1682;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_7(int32_t  p_8, const int32_t * p_9)
{ /* block id: 559 */
    float ****l_1152[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int32_t l_1188[7];
    int32_t *l_1217 = &l_1188[6];
    int32_t **l_1216 = &l_1217;
    int32_t ***l_1215 = &l_1216;
    struct S0 *** const l_1261 = (void*)0;
    struct S0 *** const *l_1260 = &l_1261;
    struct S0 *** const **l_1259[7][4][6] = {{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}},{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}},{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}},{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}},{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}},{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}},{{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,(void*)0,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260},{&l_1260,&l_1260,&l_1260,&l_1260,&l_1260,&l_1260}}};
    struct S0 l_1490 = {5432};
    uint16_t l_1512[8] = {0x00A4L,0UL,0UL,0x00A4L,0UL,0UL,0x00A4L,0UL};
    uint32_t l_1547 = 0UL;
    const struct S0 ***l_1674 = (void*)0;
    const struct S0 ****l_1673 = &l_1674;
    struct S0 *l_1678 = (void*)0;
    struct S0 **l_1677 = &l_1678;
    struct S0 ***l_1676 = &l_1677;
    struct S0 ****l_1675 = &l_1676;
    struct S0 l_1679 = {7517};
    int i, j, k;
    for (i = 0; i < 7; i++)
        l_1188[i] = (-1L);
    if (((void*)0 == l_1152[2]))
    { /* block id: 560 */
        int32_t l_1166[3][5] = {{0xD6B111BBL,0xD6B111BBL,(-4L),0xD6B111BBL,0xD6B111BBL},{0x3F151C09L,0xD6B111BBL,0x3F151C09L,0x3F151C09L,0xD6B111BBL},{0xD6B111BBL,0x3F151C09L,0x3F151C09L,0xD6B111BBL,0x3F151C09L}};
        float l_1176[7][10] = {{0x6.Ap+1,0xD.C2A355p+18,0x0.C3CD32p+44,0xF.B3059Dp-38,0xE.166FBBp-23,0xF.B3059Dp-38,0x0.C3CD32p+44,0xD.C2A355p+18,0x6.Ap+1,0xB.FC38DDp-59},{0x2.EA5796p-86,(-0x6.Fp-1),0x0.C3CD32p+44,0xE.166FBBp-23,0xD.C2A355p+18,0xD.C2A355p+18,0xE.166FBBp-23,0x0.C3CD32p+44,(-0x6.Fp-1),0x2.EA5796p-86},{(-0x6.Fp-1),0xF.B3059Dp-38,0x6.Ap+1,0xE.166FBBp-23,0x0.Ep-1,0x2.EA5796p-86,0x0.Ep-1,0xE.166FBBp-23,0x6.Ap+1,0xF.B3059Dp-38},{0xB.FC38DDp-59,0x0.C3CD32p+44,0x2.EA5796p-86,0xF.B3059Dp-38,0x0.Ep-1,0x4.8p+1,0x4.8p+1,0x0.Ep-1,0xF.B3059Dp-38,0x2.EA5796p-86},{0x0.Ep-1,0x4.8p+1,0x0.Ep-1,0xF.B3059Dp-38,0x2.EA5796p-86,0x0.C3CD32p+44,0xB.FC38DDp-59,0x0.C3CD32p+44,0x2.EA5796p-86,0xF.B3059Dp-38},{0xF.B3059Dp-38,0xE.166FBBp-23,0xF.B3059Dp-38,0x0.C3CD32p+44,0xD.C2A355p+18,0x6.Ap+1,0xB.FC38DDp-59,0xB.FC38DDp-59,0x6.Ap+1,0xD.C2A355p+18},{0x0.Ep-1,0x4.8p+1,0x4.8p+1,0x0.Ep-1,0xF.B3059Dp-38,0x2.EA5796p-86,0x0.C3CD32p+44,0xB.FC38DDp-59,0x0.C3CD32p+44,0x2.EA5796p-86}};
        float *l_1175 = &l_1176[3][0];
        float **l_1174 = &l_1175;
        struct S0 l_1194 = {7854};
        int32_t l_1218 = 0xF2240BCBL;
        int32_t *****l_1220 = (void*)0;
        int32_t ****l_1224 = &l_1215;
        struct S0 ****l_1240 = (void*)0;
        struct S0 *****l_1239 = &l_1240;
        float ** const ***l_1287 = (void*)0;
        struct S0 *l_1382 = &l_1194;
        struct S0 * const *l_1381 = &l_1382;
        int32_t l_1432[2][8] = {{0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL},{0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL,0x559B213EL}};
        int i, j;
        for (p_8 = 0; (p_8 < (-11)); p_8--)
        { /* block id: 563 */
            int32_t l_1156 = 0x95862A23L;
            int32_t *l_1155[10] = {&l_1156,&l_1156,&l_1156,&l_1156,&l_1156,&l_1156,&l_1156,&l_1156,&l_1156,&l_1156};
            int32_t **l_1157 = &l_1155[3];
            struct S0 l_1158 = {4710};
            float ** const l_1177 = (void*)0;
            int i;
            (*l_1157) = l_1155[3];
            l_1158 = l_1158;
            for (l_1156 = 0; (l_1156 >= (-5)); --l_1156)
            { /* block id: 568 */
                float *****l_1161[9] = {&l_1152[4],&l_1152[4],&l_1152[3],&l_1152[4],&l_1152[4],&l_1152[3],&l_1152[4],&l_1152[4],&l_1152[3]};
                struct S0 l_1189 = {-7914};
                struct S0 *l_1190 = (void*)0;
                struct S0 *l_1191[1][4] = {{(void*)0,(void*)0,(void*)0,(void*)0}};
                int i, j;
                l_1161[3] = l_1161[3];
                (*l_1157) = &p_8;
                (*l_1175) = ((safe_sub_func_float_f_f(((safe_mul_func_float_f_f(l_1166[1][1], (safe_sub_func_float_f_f((p_8 != (safe_sub_func_float_f_f((safe_add_func_float_f_f(p_8, (+(l_1174 != l_1177)))), (safe_sub_func_float_f_f((((safe_sub_func_float_f_f(l_1166[2][1], (safe_sub_func_float_f_f((safe_div_func_float_f_f(0x1.8p+1, (**l_1157))), ((safe_add_func_float_f_f(p_8, p_8)) != p_8))))) <= p_8) == l_1166[1][1]), l_1188[6]))))), p_8)))) > l_1166[1][1]), l_1188[3])) != 0xE.88E612p-43);
                l_1158 = l_1189;
            }
            /* facts after for loop */
            //assert (l_1155[0] == &p_8 || l_1155[0] == &l_1156);
        }
        if ((p_9 != (*l_1174)))
        { /* block id: 575 */
            int32_t l_1205 = 0x3BF4436AL;
            struct S0 *l_1234 = &l_1194;
            struct S0 **l_1233 = &l_1234;
            struct S0 ***l_1232 = &l_1233;
            struct S0 ****l_1231[1][7];
            struct S0 *****l_1230[4][3] = {{&l_1231[0][0],&l_1231[0][6],&l_1231[0][6]},{&l_1231[0][2],(void*)0,(void*)0},{&l_1231[0][0],&l_1231[0][6],&l_1231[0][6]},{&l_1231[0][2],(void*)0,(void*)0}};
            int32_t *l_1243 = (void*)0;
            float ***l_1311 = (void*)0;
            float ****l_1310[7] = {(void*)0,&l_1311,&l_1311,(void*)0,&l_1311,&l_1311,(void*)0};
            struct S0 *l_1375[6] = {&l_1194,&l_1194,&l_1194,&l_1194,&l_1194,&l_1194};
            float l_1439 = 0x2.0D8D85p-55;
            float **l_1454 = &l_1175;
            int i, j;
            for (i = 0; i < 1; i++)
            {
                for (j = 0; j < 7; j++)
                    l_1231[i][j] = &l_1232;
            }
            if ((*p_9))
            { /* block id: 576 */
                int32_t *l_1193 = (void*)0;
                int32_t **l_1192 = &l_1193;
                struct S0 *l_1195 = &l_1194;
                (*l_1192) = &p_8;
                /* statement id: 577 */
                assert (l_1193 == &p_8);
                (*l_1195) = l_1194;
            }
            else
            { /* block id: 579 */
                float **l_1212 = &l_1175;
                int32_t **l_1219[6][7][1] = {{{(void*)0},{&l_1217},{&l_1217},{(void*)0},{&l_1217},{&l_1217},{(void*)0}},{{&l_1217},{&l_1217},{(void*)0},{&l_1217},{&l_1217},{(void*)0},{&l_1217}},{{&l_1217},{(void*)0},{&l_1217},{&l_1217},{(void*)0},{&l_1217},{&l_1217}},{{(void*)0},{&l_1217},{&l_1217},{(void*)0},{&l_1217},{&l_1217},{(void*)0}},{{&l_1217},{&l_1217},{(void*)0},{&l_1217},{&l_1217},{(void*)0},{&l_1217}},{{&l_1217},{(void*)0},{&l_1217},{&l_1217},{(void*)0},{&l_1217},{&l_1217}}};
                int32_t l_1221[5][5] = {{0xA16B24BAL,0xA16B24BAL,0xA16B24BAL,0xA16B24BAL,0xA16B24BAL},{0x35847152L,0x35847152L,0x35847152L,0x35847152L,0x35847152L},{0xA16B24BAL,0xA16B24BAL,0xA16B24BAL,0xA16B24BAL,0xA16B24BAL},{0x35847152L,0x35847152L,0x35847152L,0x35847152L,0x35847152L},{0xA16B24BAL,0xA16B24BAL,0xA16B24BAL,0xA16B24BAL,0xA16B24BAL}};
                int i, j, k;
                if (((safe_div_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((~l_1166[1][2]), 1)), 0x33C7L)) != (((safe_mod_func_uint16_t_u_u((safe_lshift_func_uint8_t_u_s(l_1205, (((p_8 > (safe_lshift_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u(p_8, ((safe_mul_func_uint8_t_u_u(p_8, (l_1212 == (void*)0))) == ((safe_mod_func_int64_t_s_s((p_8 || 0xB86AEBBB857DAD3ALL), (-1L))) > 0x3D05L)))) | l_1166[1][2]), p_8))) ^ l_1205) | l_1205))), l_1188[6])) <= p_8) || 0x74BCE5693E62A3BALL)))
                { /* block id: 580 */
                    for (l_1205 = 0; l_1205 < 7; l_1205 += 1)
                    {
                        for (p_8 = 0; p_8 < 10; p_8 += 1)
                        {
                            l_1176[l_1205][p_8] = 0x0.0p-1;
                        }
                    }
                    p_8 = (l_1215 != (void*)0);
                }
                else
                { /* block id: 583 */
                    (*l_1216) = &p_8;
                    /* statement id: 584 */
                    assert (l_1217 == &p_8);
                }
                /* facts after branching */
                assert (l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
                l_1221[2][3] = ((void*)0 == l_1220);
                (**l_1212) = l_1205;
            }
            /* facts after branching */
            assert (l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
            if ((((-4L) | 0UL) != ((safe_mod_func_uint64_t_u_u(p_8, ((l_1224 != (void*)0) & (safe_mod_func_int16_t_s_s(((p_8 && (((*p_9) <= (*p_9)) >= (*p_9))) & l_1205), (****l_1224)))))) == p_8)))
            { /* block id: 589 */
                int32_t **l_1227 = (void*)0;
                struct S0 ***l_1280 = &l_1233;
                int16_t l_1281 = 0x03A8L;
                int32_t *l_1283[9];
                struct S0 l_1284 = {3286};
                float ** const *l_1290[2];
                float ** const **l_1289 = &l_1290[0];
                float ** const ***l_1288 = &l_1289;
                struct S0 ** const *l_1291 = &l_1233;
                uint32_t l_1298 = 0x96851165L;
                uint32_t l_1313 = 0xEA1A7D57L;
                struct S0 *****l_1316 = &l_1231[0][0];
                int32_t *l_1323 = &l_1188[6];
                struct S0 *****l_1328 = &l_1231[0][1];
                struct S0 ***** const l_1333 = (void*)0;
                int64_t l_1336 = 0xB78C4697CCD8E754LL;
                int i;
                for (i = 0; i < 9; i++)
                    l_1283[i] = &l_1166[2][2];
                for (i = 0; i < 2; i++)
                    l_1290[i] = &l_1174;
                l_1243 = &p_8;
                /* statement id: 590 */
                assert (l_1243 == &p_8);
                if (((((~((safe_mod_func_int32_t_s_s(((0xE5BD29A7L & (safe_mod_func_uint8_t_u_u(((&l_1240 == &l_1231[0][0]) != 9UL), (safe_add_func_uint8_t_u_u(p_8, (safe_mul_func_uint8_t_u_u(((safe_mod_func_uint64_t_u_u((0x7BD2L && (((**l_1216) && (**l_1216)) == (0x113CL && p_8))), p_8)) && (*l_1217)), (*l_1243)))))))) ^ p_8), (*l_1243))) ^ (*l_1243))) | p_8) >= 65527UL) < (**l_1216)))
                { /* block id: 591 */
                    (*l_1243) = (safe_div_func_int64_t_s_s((-1L), (safe_mod_func_int64_t_s_s(0xE9FC04F6D772FDB6LL, p_8))));
                    (*l_1216) = (*l_1216);
                }
                else
                { /* block id: 594 */
                    for (l_1218 = 2; (l_1218 <= 6); l_1218 += 1)
                    { /* block id: 597 */
                        (***l_1224) = &p_8;
                        /* statement id: 598 */
                        assert (l_1217 == &p_8);
                        if (l_1194.f0)
                            goto lbl_1282;
                    }
                }
lbl_1367:
                p_9 = &p_8;
                /* statement id: 601 */
                assert (p_9 == &p_8);
                if (((((((void*)0 != l_1259[0][3][1]) != (p_8 >= (safe_mul_func_int8_t_s_s((((*l_1243) >= ((safe_add_func_int16_t_s_s((safe_div_func_uint8_t_u_u((safe_rshift_func_int8_t_s_s((((safe_lshift_func_uint8_t_u_s((safe_mod_func_uint32_t_u_u((safe_add_func_uint32_t_u_u(((safe_mul_func_int16_t_s_s(0x14E1L, 0x3A21L)) && (((void*)0 == l_1280) & (*l_1243))), 0x6D399545L)), (****l_1224))), 5)) | (*p_9)) ^ 0x91FA360BL), p_8)), (***l_1215))), p_8)) >= (*p_9))) | (**l_1216)), (**l_1216))))) | p_8) > l_1281) & p_8))
                { /* block id: 602 */
                    if ((*l_1217))
                    { /* block id: 603 */
lbl_1282:
                        (*l_1216) = &p_8;
                        /* statement id: 604 */
                        assert (l_1217 == &p_8);
                        p_9 = &p_8;
                        /* statement id: 606 */
                        assert (p_9 == &p_8);
                        l_1283[6] = (void*)0;
                        /* statement id: 607 */
                        //assert (l_1283[0] == 0 || (l_1283[0] >= &l_1166[0][0] && l_1283[0] <= &l_1166[2][4]));
                    }
                    else
                    { /* block id: 608 */
                        return l_1284;
                    }
                    /* facts after branching */
                    assert (l_1217 == &p_8);
                    //assert (l_1283[0] == 0 || (l_1283[0] >= &l_1166[0][0] && l_1283[0] <= &l_1166[2][4]));
                    (**l_1233) = (***l_1280);
                    for (p_8 = 25; (p_8 <= (-16)); p_8 = safe_sub_func_uint32_t_u_u(p_8, 5))
                    { /* block id: 614 */
                        l_1288 = l_1287;
                        /* statement id: 615 */
                        assert (l_1288 == 0);
                        if ((*p_9))
                            continue;
                    }
                    /* facts after for loop */
                    assert (l_1288 == 0 || l_1288 == &l_1289);
lbl_1345:
                    if (((l_1243 != (void*)0) && (l_1291 == (void*)0)))
                    { /* block id: 618 */
                        const struct S0 l_1292 = {4581};
                        int32_t l_1312 = 1L;
                        int32_t **l_1314[3][9] = {{&l_1217,&l_1217,&l_1283[6],&l_1283[6],&l_1283[1],&l_1283[6],&l_1283[1],&l_1283[6],&l_1283[6]},{&l_1217,&l_1217,&l_1283[6],&l_1283[6],&l_1283[1],&l_1283[6],&l_1283[1],&l_1283[6],&l_1283[6]},{&l_1217,&l_1217,&l_1283[6],&l_1283[6],&l_1283[1],&l_1283[6],&l_1283[1],&l_1283[6],&l_1283[6]}};
                        int32_t **l_1315 = &l_1283[2];
                        int i, j;
                        p_9 = (void*)0;
                        /* statement id: 619 */
                        assert (p_9 == 0);
                        if (l_1284.f0)
                            goto lbl_1293;
lbl_1293:
                        (***l_1232) = l_1292;
                        (*l_1243) = (safe_lshift_func_int8_t_s_u((safe_rshift_func_uint16_t_u_s(l_1298, p_8)), 6));
                        (*l_1315) = func_31(((~(safe_lshift_func_uint16_t_u_u(0x9D26L, 11))) != ((((****l_1224) >= ((-5L) > ((((safe_sub_func_uint16_t_u_u(((safe_sub_func_int8_t_s_s((0x8AA7D945E274D418LL && (l_1292.f0 != (0x3146L <= (safe_div_func_uint8_t_u_u((((((*l_1243) >= ((void*)0 == l_1310[6])) != l_1312) != l_1292.f0) > 0x5101L), l_1312))))), (*l_1243))) > p_8), p_8)) > p_8) | (*l_1217)) > l_1313))) | p_8) && (**l_1216))), (*l_1215), p_8);
                        /* statement id: 623 */
                        //assert (l_1283[0] == &p_8 || (l_1283[0] >= &l_1188[0] && l_1283[0] <= &l_1188[6]) || l_1283[0] == 0 || (l_1283[0] >= &l_1166[0][0] && l_1283[0] <= &l_1166[2][4]));
                    }
                    else
                    { /* block id: 624 */
                        int32_t *l_1324 = &l_1188[5];
                        int32_t **l_1325 = &l_1324;
                        (**l_1215) = (void*)0;
                        /* statement id: 625 */
                        assert (l_1217 == 0);
                        (*l_1325) = func_31((((void*)0 != l_1316) < (((safe_rshift_func_int8_t_s_s((p_8 <= (safe_add_func_uint32_t_u_u((p_9 == p_9), (*p_9)))), (((safe_add_func_uint32_t_u_u((l_1323 == l_1324), 0x84B7CFE3L)) ^ (*l_1323)) ^ (*l_1243)))) < (*p_9)) > (-8L))), &l_1324, (*p_9));
                        (***l_1224) = (**l_1215);
                        l_1336 = ((safe_sub_func_float_f_f((l_1328 != (void*)0), (((void*)0 != &p_8) < 0x1.Cp+1))) != (safe_mul_func_float_f_f((safe_div_func_float_f_f((((void*)0 != l_1333) > (safe_sub_func_float_f_f(p_8, 0x0.6p+1))), p_8)), p_8)));
                    }
                    /* facts after branching */
                    assert (p_9 == &p_8 || p_9 == 0);
                    assert (l_1217 == 0 || l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
                    //assert (l_1283[0] == &p_8 || (l_1283[0] >= &l_1188[0] && l_1283[0] <= &l_1188[6]) || l_1283[0] == 0 || (l_1283[0] >= &l_1166[0][0] && l_1283[0] <= &l_1166[2][4]));
                }
                else
                { /* block id: 630 */
                    uint64_t l_1338 = 0x1AF1FFA571248708LL;
                    struct S0 ***l_1344 = (void*)0;
                    float ***l_1360 = &l_1174;
                    if (((~(1L ^ (l_1338 != (safe_lshift_func_uint8_t_u_u(((248UL | 0x01L) | (safe_rshift_func_int16_t_s_s((*l_1217), 1))), 6))))) || (+((*l_1260) != l_1344))))
                    { /* block id: 631 */
                        struct S0 **l_1346 = &l_1234;
                        if (l_1205)
                            goto lbl_1345;
                        (****l_1224) = (0x5C4FC67A41431BC4LL < (((*l_1232) == l_1346) | p_8));
                        if (p_8)
                            goto lbl_1347;
lbl_1347:
                        (*l_1216) = &p_8;
                        /* statement id: 634 */
                        assert (l_1217 == &p_8);
                        (***l_1232) = (*****l_1316);
                    }
                    else
                    { /* block id: 637 */
                        struct S0 *l_1348[6][5] = {{&l_1194,&l_1194,&l_1194,&l_1194,&l_1194},{&l_1284,&l_1284,&l_1284,&l_1284,&l_1284},{&l_1194,&l_1194,&l_1194,&l_1194,&l_1194},{&l_1284,&l_1284,&l_1284,&l_1284,&l_1284},{&l_1194,&l_1194,&l_1194,&l_1194,&l_1194},{&l_1284,&l_1284,&l_1284,&l_1284,&l_1284}};
                        int32_t **l_1361 = &l_1243;
                        struct S0 ****l_1364[7];
                        int i, j;
                        for (i = 0; i < 7; i++)
                            l_1364[i] = (void*)0;
                        (*l_1233) = l_1348[5][2];
                        (*l_1361) = func_31((&p_8 == &p_8), &l_1243, (safe_mul_func_int8_t_s_s((safe_lshift_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u(0x4221L, (&l_1348[5][4] == (void*)0))), 5)), (safe_add_func_uint8_t_u_u(p_8, (0UL <= (safe_sub_func_uint16_t_u_u((~((void*)0 == l_1360)), p_8))))))));
                        if (l_1194.f0)
                            goto lbl_1366;
lbl_1366:
                        (**l_1361) = (safe_mul_func_float_f_f((0x1.885077p+80 >= (&l_1344 == l_1364[6])), (l_1338 >= (+((void*)0 == (***l_1289))))));
                        (***l_1224) = (*l_1361);
                        /* statement id: 642 */
                        assert (l_1217 == &p_8);
                    }
                    /* facts after branching */
                    assert (l_1217 == &p_8);
                    if (l_1313)
                        goto lbl_1367;
                }
                /* facts after branching */
                assert (p_9 == &p_8 || p_9 == 0);
                assert (l_1217 == 0 || l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
                //assert (l_1283[0] == &p_8 || (l_1283[0] >= &l_1188[0] && l_1283[0] <= &l_1188[6]) || l_1283[0] == 0 || (l_1283[0] >= &l_1166[0][0] && l_1283[0] <= &l_1166[2][4]));
                assert (l_1288 == 0 || l_1288 == &l_1289);
            }
            else
            { /* block id: 646 */
                l_1259[3][0][2] = &l_1260;
            }
            /* facts after branching */
            //assert (p_9 == &l_6 || p_9 == &p_8 || p_9 == 0);
            assert (l_1217 == 0 || l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
            //assert (l_1234 == dangling || l_1234 == &l_1194);
            assert (l_1243 == 0 || l_1243 == &p_8);
            if (p_8)
            { /* block id: 649 */
                struct S0 l_1370 = {7021};
                struct S0 ** const l_1380 = &l_1375[5];
                const float ****l_1403[4];
                int32_t ***l_1409 = &l_1216;
                uint64_t l_1410 = 0UL;
                struct S0 **l_1445 = &l_1234;
                int i;
                for (i = 0; i < 4; i++)
                    l_1403[i] = (void*)0;
                if (p_8)
                { /* block id: 650 */
                    struct S0 l_1371 = {5640};
                    for (l_1205 = (-27); (l_1205 == (-23)); l_1205 = safe_add_func_uint32_t_u_u(l_1205, 2))
                    { /* block id: 653 */
                        p_9 = (void*)0;
                        /* statement id: 654 */
                        assert (p_9 == 0);
                    }
                    if (l_1194.f0)
                        goto lbl_1372;
lbl_1372:
                    l_1371 = l_1370;
                    l_1370 = l_1370;
                }
                else
                { /* block id: 659 */
                    struct S0 l_1376 = {-5035};
                    for (p_8 = 0; (p_8 >= (-7)); --p_8)
                    { /* block id: 662 */
                        (*l_1233) = l_1375[5];
                        /* statement id: 663 */
                        assert (l_1234 == &l_1194);
                    }
                    return l_1376;
                }
                for (l_1205 = 0; (l_1205 <= (-29)); --l_1205)
                { /* block id: 669 */
                    int32_t **l_1379 = &l_1243;
                    float ****l_1394 = &l_1311;
                    struct S0 **l_1444[8][3] = {{&l_1234,&l_1234,&l_1234},{&l_1382,&l_1234,&l_1382},{&l_1234,&l_1234,&l_1234},{&l_1382,&l_1234,&l_1382},{&l_1234,&l_1234,&l_1234},{&l_1382,&l_1234,&l_1382},{&l_1234,&l_1234,&l_1234},{&l_1382,&l_1234,&l_1382}};
                    int i, j;
                    (*l_1379) = func_31(l_1370.f0, &l_1243, p_8);
                    if (((l_1380 == l_1381) && (safe_mul_func_int16_t_s_s((safe_div_func_uint64_t_u_u(((~p_8) > p_8), ((~65535UL) ^ (l_1370.f0 | (safe_div_func_uint64_t_u_u(l_1370.f0, (safe_unary_minus_func_uint16_t_u((safe_mul_func_int16_t_s_s((l_1394 != (void*)0), p_8)))))))))), p_8))))
                    { /* block id: 671 */
                        int32_t **l_1408 = &l_1217;
                        (*l_1408) = func_31(((~(safe_unary_minus_func_uint8_t_u(((l_1370.f0 <= (p_8 && (safe_lshift_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s(p_8, 14)), 4)))) > (safe_mul_func_int16_t_s_s((l_1394 != l_1403[3]), (safe_add_func_uint64_t_u_u((safe_mod_func_int32_t_s_s((-8L), ((l_1370.f0 < (((p_8 | 0x52L) > p_8) > l_1370.f0)) | p_8))), p_8)))))))) || 65532UL), l_1379, l_1370.f0);
                        /* statement id: 672 */
                        assert (l_1217 == 0 || l_1217 == &p_8);
                        (**l_1381) = func_55(func_17(func_55(&l_1243)));
                        (**l_1381) = func_55(func_17(func_55((**l_1224))));
                        l_1410 = (l_1409 != (void*)0);
                    }
                    else
                    { /* block id: 676 */
                        struct S0 **l_1417 = (void*)0;
                        int32_t *l_1418[2];
                        int i;
                        for (i = 0; i < 2; i++)
                            l_1418[i] = &l_1166[1][1];
                        p_8 = (safe_rshift_func_uint16_t_u_u((safe_add_func_uint64_t_u_u(p_8, ((safe_add_func_int64_t_s_s(p_8, ((2L < ((*l_1409) != (void*)0)) || (p_8 >= ((void*)0 != l_1417))))) >= ((l_1243 != &p_8) | p_8)))), 11));
                        (**l_1380) = func_27((*l_1379), func_55((**l_1224)), p_8);
                        (*l_1175) = ((safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f(((0x1.EE56BBp+96 == (!(((-0x1.7p-1) == (safe_div_func_float_f_f((safe_add_func_float_f_f(l_1432[0][5], (safe_add_func_float_f_f(((*l_1394) == (*l_1394)), (safe_sub_func_float_f_f((safe_add_func_float_f_f(p_8, l_1439)), (p_8 == ((-(safe_div_func_float_f_f(p_8, p_8))) >= p_8)))))))), p_8))) != 0xB.C16DF7p-78))) >= p_8), p_8)), p_8)), p_8)), p_8)) < (-0x1.0p+1));
                    }
                    if (p_8)
                    { /* block id: 681 */
                        int32_t *l_1443[2];
                        int i;
                        for (i = 0; i < 2; i++)
                            l_1443[i] = &l_1188[2];
                        p_8 = (&p_9 != (void*)0);
                        l_1445 = l_1444[3][0];
                    }
                    else
                    { /* block id: 684 */
                        int32_t **l_1446 = (void*)0;
                        int32_t **l_1447 = &l_1217;
                        (*l_1447) = func_31(p_8, &l_1243, p_8);
                        /* statement id: 685 */
                        assert (l_1217 == 0 || l_1217 == &p_8);
                    }
                }
                /* facts after for loop */
                assert (l_1445 == &l_1382 || l_1445 == &l_1234);
                for (l_1410 = 0; (l_1410 == 53); l_1410 = safe_add_func_int8_t_s_s(l_1410, 9))
                { /* block id: 690 */
                    struct S0 **l_1450 = &l_1382;
                    for (l_1205 = 0; (l_1205 <= 0); l_1205 += 1)
                    { /* block id: 693 */
                        int i, j;
                        l_1450 = (void*)0;
                        /* statement id: 694 */
                        assert (l_1450 == 0);
                        p_9 = &p_8;
                        /* statement id: 695 */
                        assert (p_9 == &p_8);
                    }
                    /* facts after for loop */
                    assert (l_1450 == 0 || l_1450 == &l_1382);
                    (***l_1224) = (**l_1409);
                }
                for (l_1218 = (-18); (l_1218 > (-6)); ++l_1218)
                { /* block id: 701 */
                    (**l_1380) = func_55((*l_1409));
                }
            }
            else
            { /* block id: 704 */
                int32_t *l_1453 = &l_1188[2];
                struct S0 l_1485 = {6216};
                (***l_1224) = l_1453;
                /* statement id: 705 */
                assert ((l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
                l_1174 = l_1454;
                for (l_1205 = 1; (l_1205 <= 6); l_1205 += 1)
                { /* block id: 709 */
                    uint64_t l_1459 = 0x2AF4FB7E30B035C1LL;
                    if ((safe_sub_func_int32_t_s_s(((safe_mod_func_int32_t_s_s(l_1459, (safe_lshift_func_int8_t_s_s((safe_mod_func_int64_t_s_s((((void*)0 == &l_1240) || l_1459), (safe_add_func_uint8_t_u_u(l_1459, ((&l_1216 != (void*)0) && ((safe_mul_func_int16_t_s_s(((p_8 > (safe_unary_minus_func_uint8_t_u(0UL))) != (*l_1217)), p_8)) >= p_8)))))), p_8)))) && p_8), 0xABE90465L)))
                    { /* block id: 710 */
                        uint32_t l_1484[10] = {0xB949F5D9L,0UL,0xB949F5D9L,1UL,1UL,0xB949F5D9L,0UL,0xB949F5D9L,1UL,1UL};
                        int i;
                        (**l_1381) = func_27(func_31(((safe_mod_func_int32_t_s_s(0xE48610BBL, ((((((p_8 < ((safe_div_func_uint64_t_u_u(((safe_mul_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint8_t_u_u(0x59L, 2)), (((((~(safe_rshift_func_int8_t_s_u((-1L), (*l_1453)))) != 0xF157L) && (safe_sub_func_int64_t_s_s(((((l_1459 | p_8) != (0xEA6DC8EDL ^ (-1L))) || l_1484[0]) != l_1484[0]), (*l_1453)))) < (*l_1453)) ^ p_8))) != 7UL), p_8)) != (**l_1216)), (*l_1453))) > 3L)) < 0x96538414A07E854ELL) & (-5L)) && (****l_1224)) || 0UL) || p_8))) <= p_8), &l_1243, p_8), l_1485, p_8);
                    }
                    else
                    { /* block id: 712 */
                        (***l_1224) = &p_8;
                        /* statement id: 713 */
                        assert (l_1217 == &p_8);
                        (*l_1382) = (**l_1381);
                    }
                    if ((*l_1453))
                        break;
                    for (p_8 = 4; (p_8 >= 0); p_8 -= 1)
                    { /* block id: 719 */
                        struct S0 l_1486 = {-3245};
                        l_1486 = (*l_1382);
                        (*l_1453) = l_1459;
                    }
                }
                /* facts after for loop */
                assert (l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
                (**l_1215) = l_1243;
                /* statement id: 724 */
                assert (l_1217 == 0 || l_1217 == &p_8);
            }
            p_8 = l_1205;
        }
        else
        { /* block id: 727 */
            uint16_t l_1487 = 0x9333L;
            int32_t l_1526 = 0xF94318DFL;
            float *l_1530 = (void*)0;
            struct S0 l_1569 = {2938};
            const uint32_t l_1613 = 0x0098169AL;
            const int32_t *l_1626 = &l_1432[0][4];
            if ((p_8 && l_1487))
            { /* block id: 728 */
                uint32_t l_1522 = 0UL;
                int32_t l_1550 = 0x1A149142L;
                for (p_8 = 0; (p_8 > 20); ++p_8)
                { /* block id: 731 */
                    return l_1490;
                }
                (**l_1174) = l_1487;
                for (p_8 = 1; (p_8 >= 0); p_8 -= 1)
                { /* block id: 737 */
                    int32_t l_1495[4][3] = {{3L,(-1L),3L},{0xE711A0D9L,(-1L),0xB9C16A15L},{0xE711A0D9L,0xE711A0D9L,(-1L)},{3L,(-1L),(-1L)}};
                    float ***l_1544 = (void*)0;
                    float ****l_1543[7][9][2] = {{{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,&l_1544},{(void*)0,(void*)0},{(void*)0,&l_1544},{&l_1544,(void*)0}},{{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{&l_1544,&l_1544}},{{&l_1544,(void*)0},{(void*)0,(void*)0},{(void*)0,&l_1544},{&l_1544,&l_1544},{(void*)0,(void*)0},{(void*)0,(void*)0},{&l_1544,&l_1544},{&l_1544,(void*)0},{(void*)0,(void*)0}},{{(void*)0,(void*)0},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,&l_1544},{(void*)0,(void*)0}},{{(void*)0,&l_1544},{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,(void*)0},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,(void*)0},{(void*)0,(void*)0}},{{(void*)0,(void*)0},{&l_1544,&l_1544},{&l_1544,(void*)0},{(void*)0,(void*)0},{(void*)0,&l_1544},{&l_1544,&l_1544},{(void*)0,(void*)0},{(void*)0,(void*)0},{&l_1544,&l_1544}},{{&l_1544,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,&l_1544},{&l_1544,&l_1544},{(void*)0,&l_1544},{&l_1544,(void*)0}}};
                    int i, j, k;
                    p_9 = &p_8;
                    /* statement id: 738 */
                    assert (p_9 == &p_8);
                }
                /* facts after for loop */
                //assert (p_9 == &p_8 || p_9 == &l_6);
            }
            else
            { /* block id: 761 */
                float ***** const l_1574 = &l_1152[1];
                const int32_t l_1579 = 0xFF997280L;
                struct S0 *l_1590[9][4][1] = {{{&l_1490},{(void*)0},{&l_1194},{(void*)0}},{{&l_1194},{(void*)0},{&l_1490},{&l_1490}},{{(void*)0},{&l_1194},{(void*)0},{&l_1194}},{{(void*)0},{&l_1490},{&l_1490},{(void*)0}},{{&l_1194},{(void*)0},{&l_1194},{(void*)0}},{{&l_1490},{&l_1490},{(void*)0},{&l_1194}},{{(void*)0},{&l_1194},{(void*)0},{&l_1490}},{{&l_1490},{(void*)0},{&l_1194},{(void*)0}},{{&l_1194},{(void*)0},{&l_1490},{&l_1490}}};
                int32_t **l_1604[7] = {&l_1217,&l_1217,&l_1217,&l_1217,&l_1217,&l_1217,&l_1217};
                int i, j, k;
                for (l_1526 = (-1); (l_1526 >= (-11)); l_1526 = safe_sub_func_uint32_t_u_u(l_1526, 1))
                { /* block id: 764 */
                    (*l_1216) = &p_8;
                    /* statement id: 765 */
                    assert (l_1217 == &p_8);
                }
                /* facts after for loop */
                assert (l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
                l_1569 = func_55((*l_1215));
                (****l_1224) = p_8;
                for (l_1526 = 0; (l_1526 <= 6); l_1526 += 1)
                { /* block id: 771 */
                    uint64_t l_1573 = 0UL;
                    const int32_t *l_1606[8][6][5] = {{{&l_1432[0][5],&l_1432[0][5],&l_1188[1],&l_1218,&l_1188[1]},{&l_1579,(void*)0,(void*)0,(void*)0,&l_1218},{(void*)0,&l_1188[0],&l_1218,&l_1218,(void*)0},{(void*)0,&l_1166[0][1],(void*)0,(void*)0,&l_1218},{&l_1432[0][5],&l_1188[0],&l_1188[1],(void*)0,&l_1188[1]},{(void*)0,(void*)0,&l_1432[0][5],(void*)0,&l_1218}},{{(void*)0,&l_1432[0][5],&l_1218,(void*)0,(void*)0},{&l_1579,&l_1166[0][1],&l_1432[0][5],(void*)0,&l_1218},{&l_1432[0][5],&l_1432[0][5],&l_1188[1],&l_1218,&l_1188[1]},{&l_1579,(void*)0,(void*)0,(void*)0,&l_1218},{(void*)0,&l_1188[0],&l_1218,&l_1218,(void*)0},{(void*)0,&l_1166[0][1],(void*)0,(void*)0,&l_1218}},{{&l_1432[0][5],&l_1188[0],&l_1188[1],(void*)0,&l_1188[1]},{(void*)0,(void*)0,&l_1432[0][5],(void*)0,&l_1218},{(void*)0,&l_1432[0][5],&l_1218,(void*)0,(void*)0},{&l_1579,&l_1166[0][1],&l_1432[0][5],(void*)0,&l_1218},{&l_1432[0][5],&l_1432[0][5],&l_1188[1],&l_1218,&l_1188[1]},{&l_1579,(void*)0,(void*)0,(void*)0,&l_1218}},{{(void*)0,&l_1188[0],&l_1218,&l_1218,(void*)0},{(void*)0,&l_1166[0][1],(void*)0,(void*)0,&l_1218},{&l_1432[0][5],&l_1188[0],&l_1188[1],(void*)0,&l_1188[1]},{(void*)0,(void*)0,&l_1432[0][5],(void*)0,&l_1218},{(void*)0,&l_1432[0][5],&l_1218,(void*)0,(void*)0},{&l_1579,&l_1166[0][1],&l_1432[0][5],(void*)0,&l_1218}},{{&l_1432[0][5],&l_1432[0][5],&l_1188[1],&l_1218,&l_1188[1]},{&l_1579,(void*)0,(void*)0,(void*)0,&l_1218},{(void*)0,&l_1188[0],&l_1218,&l_1218,(void*)0},{(void*)0,&l_1166[0][1],(void*)0,(void*)0,&l_1218},{&l_1188[1],(void*)0,&l_1526,&l_1432[0][5],&l_1526},{&l_1218,&l_1218,&l_1166[2][0],&l_1432[0][7],&l_1166[1][1]}},{{(void*)0,&l_1166[1][1],(void*)0,&l_1432[0][5],&l_1188[6]},{&l_1218,(void*)0,&l_1166[2][0],&l_1188[6],&l_1579},{&l_1188[1],&l_1166[1][1],&l_1526,&l_1188[6],&l_1526},{&l_1218,&l_1218,&l_1432[0][5],&l_1432[0][7],&l_1579},{(void*)0,(void*)0,(void*)0,&l_1188[6],&l_1188[6]},{&l_1218,(void*)0,&l_1432[0][5],&l_1188[6],&l_1166[1][1]}},{{&l_1188[1],(void*)0,&l_1526,&l_1432[0][5],&l_1526},{&l_1218,&l_1218,&l_1166[2][0],&l_1432[0][7],&l_1166[1][1]},{(void*)0,&l_1166[1][1],(void*)0,&l_1432[0][5],&l_1188[6]},{&l_1218,(void*)0,&l_1166[2][0],&l_1188[6],&l_1579},{&l_1188[1],&l_1166[1][1],&l_1526,&l_1188[6],&l_1526},{&l_1218,&l_1218,&l_1432[0][5],&l_1432[0][7],&l_1579}},{{(void*)0,(void*)0,(void*)0,&l_1188[6],&l_1188[6]},{&l_1218,(void*)0,&l_1432[0][5],&l_1188[6],&l_1166[1][1]},{&l_1188[1],(void*)0,&l_1526,&l_1432[0][5],&l_1526},{&l_1218,&l_1218,&l_1166[2][0],&l_1432[0][7],&l_1166[1][1]},{(void*)0,&l_1166[1][1],(void*)0,&l_1432[0][5],&l_1188[6]},{&l_1218,(void*)0,&l_1166[2][0],&l_1188[6],&l_1579}}};
                    struct S0 l_1608 = {-4434};
                    int i, j, k;
                }
            }
            /* facts after branching */
            //assert (p_9 == &p_8 || p_9 == &l_6);
            assert (l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
            for (l_1487 = 0; (l_1487 < 27); l_1487++)
            { /* block id: 797 */
                struct S0 l_1612[7] = {{440},{440},{440},{440},{440},{440},{440}};
                int32_t **l_1627 = &l_1217;
                int i;
                if ((*p_9))
                    break;
                (***l_1224) = &p_8;
                /* statement id: 799 */
                assert (l_1217 == &p_8);
                if ((*p_9))
                { /* block id: 800 */
                    struct S0 l_1616[5] = {{5976},{5976},{5976},{5976},{5976}};
                    int i;
                    for (l_1526 = (-6); (l_1526 <= (-13)); l_1526 = safe_sub_func_int16_t_s_s(l_1526, 5))
                    { /* block id: 803 */
                        l_1616[4] = l_1616[4];
                        return l_1616[4];
                    }
                }
                else
                { /* block id: 807 */
                    struct S0 l_1617[7][3] = {{{-1957},{450},{-4414}},{{-1957},{6550},{-771}},{{-1957},{-7469},{-1957}},{{-1957},{450},{-4414}},{{-1957},{6550},{-771}},{{-1957},{-7469},{-1957}},{{-1957},{450},{-4414}}};
                    int i, j;
                    if (l_1612[3].f0)
                    { /* block id: 808 */
                        if ((*p_9))
                            break;
                        (***l_1224) = &p_8;
                    }
                    else
                    { /* block id: 811 */
                        return l_1617[0][1];
                    }
                    (**l_1381) = func_27(&p_8, l_1612[3], (((l_1287 == l_1287) <= ((safe_rshift_func_int16_t_s_s((safe_lshift_func_uint8_t_u_u((safe_sub_func_uint8_t_u_u((l_1612[3].f0 > ((safe_mod_func_int64_t_s_s(0xD7A69FA0A3CF369CLL, p_8)) != ((***l_1215) | 0xBCD17E081828C9EFLL))), l_1526)), p_8)), 9)) || l_1612[3].f0)) < (*l_1217)));
                }
                (*l_1627) = l_1626;
                /* statement id: 816 */
                assert ((l_1217 >= &l_1432[0][0] && l_1217 <= &l_1432[1][7]));
            }
            /* facts after for loop */
            assert ((l_1217 >= &l_1432[0][0] && l_1217 <= &l_1432[1][7]) || l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]));
            (*l_1382) = func_55((**l_1224));
        }
        /* facts after branching */
        //assert (p_9 == &l_6 || p_9 == &p_8 || p_9 == 0);
        assert ((l_1217 >= &l_1432[0][0] && l_1217 <= &l_1432[1][7]) || l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]) || l_1217 == 0);
        (*l_1382) = (*l_1382);
    }
    else
    { /* block id: 821 */
        float *****l_1639[9][4][7] = {{{(void*)0,(void*)0,&l_1152[1],&l_1152[1],&l_1152[2],(void*)0,&l_1152[0]},{&l_1152[1],&l_1152[2],&l_1152[2],&l_1152[2],&l_1152[2],(void*)0,&l_1152[2]},{(void*)0,(void*)0,&l_1152[4],&l_1152[1],&l_1152[3],&l_1152[2],&l_1152[2]},{&l_1152[4],(void*)0,&l_1152[1],&l_1152[1],&l_1152[2],&l_1152[2],(void*)0}},{{&l_1152[2],&l_1152[4],&l_1152[2],(void*)0,&l_1152[2],(void*)0,&l_1152[2]},{&l_1152[0],(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&l_1152[2],&l_1152[4],&l_1152[2],&l_1152[4],&l_1152[0],&l_1152[2],&l_1152[2]},{&l_1152[1],&l_1152[1],&l_1152[4],(void*)0,&l_1152[2],&l_1152[2],&l_1152[0]}},{{&l_1152[4],&l_1152[0],&l_1152[2],&l_1152[2],(void*)0,(void*)0,&l_1152[4]},{&l_1152[0],(void*)0,(void*)0,&l_1152[2],&l_1152[1],(void*)0,&l_1152[2]},{&l_1152[3],(void*)0,&l_1152[0],(void*)0,&l_1152[2],&l_1152[2],&l_1152[2]},{&l_1152[0],&l_1152[4],&l_1152[4],&l_1152[4],(void*)0,&l_1152[2],(void*)0}},{{&l_1152[2],&l_1152[2],(void*)0,&l_1152[0],&l_1152[3],&l_1152[1],&l_1152[2]},{&l_1152[1],&l_1152[3],&l_1152[0],&l_1152[2],(void*)0,&l_1152[2],&l_1152[2]},{&l_1152[2],&l_1152[2],&l_1152[0],&l_1152[0],&l_1152[2],&l_1152[2],&l_1152[2]},{&l_1152[4],&l_1152[2],(void*)0,&l_1152[4],&l_1152[4],&l_1152[4],&l_1152[2]}},{{&l_1152[1],&l_1152[1],&l_1152[4],(void*)0,&l_1152[2],&l_1152[4],(void*)0},{&l_1152[2],&l_1152[2],&l_1152[0],&l_1152[4],&l_1152[2],&l_1152[4],&l_1152[2]},{(void*)0,&l_1152[2],(void*)0,(void*)0,&l_1152[2],(void*)0,&l_1152[3]},{&l_1152[2],&l_1152[1],&l_1152[2],&l_1152[2],&l_1152[1],&l_1152[2],(void*)0}},{{&l_1152[4],(void*)0,&l_1152[2],&l_1152[2],&l_1152[2],&l_1152[4],&l_1152[0]},{&l_1152[0],&l_1152[1],&l_1152[3],&l_1152[4],&l_1152[4],&l_1152[2],(void*)0},{&l_1152[2],&l_1152[2],&l_1152[0],&l_1152[4],&l_1152[2],&l_1152[1],&l_1152[2]},{&l_1152[2],&l_1152[2],&l_1152[1],&l_1152[2],(void*)0,&l_1152[1],&l_1152[2]}},{{&l_1152[2],&l_1152[1],&l_1152[2],(void*)0,&l_1152[4],&l_1152[2],&l_1152[0]},{&l_1152[0],&l_1152[2],&l_1152[2],&l_1152[2],&l_1152[4],&l_1152[2],(void*)0},{(void*)0,&l_1152[2],&l_1152[2],(void*)0,&l_1152[4],&l_1152[2],&l_1152[3]},{(void*)0,&l_1152[3],&l_1152[4],&l_1152[2],&l_1152[2],(void*)0,&l_1152[2]}},{{&l_1152[0],&l_1152[2],&l_1152[2],&l_1152[3],&l_1152[2],(void*)0,&l_1152[4]},{&l_1152[2],&l_1152[4],&l_1152[2],&l_1152[2],&l_1152[0],&l_1152[2],&l_1152[1]},{&l_1152[2],(void*)0,&l_1152[2],&l_1152[0],&l_1152[2],&l_1152[1],&l_1152[2]},{&l_1152[2],(void*)0,(void*)0,&l_1152[2],&l_1152[0],(void*)0,&l_1152[4]}},{{&l_1152[0],&l_1152[2],(void*)0,&l_1152[4],(void*)0,&l_1152[1],&l_1152[0]},{&l_1152[4],(void*)0,&l_1152[2],&l_1152[2],&l_1152[0],&l_1152[2],&l_1152[4]},{&l_1152[2],&l_1152[2],(void*)0,&l_1152[2],(void*)0,&l_1152[4],&l_1152[2]},{(void*)0,&l_1152[3],&l_1152[2],&l_1152[2],&l_1152[2],(void*)0,&l_1152[4]}}};
        uint16_t l_1653 = 65530UL;
        int32_t **l_1654 = &l_1217;
        struct S0 l_1656 = {2065};
        uint8_t l_1664 = 250UL;
        int i, j, k;
        for (p_8 = 0; (p_8 > (-8)); --p_8)
        { /* block id: 824 */
            uint32_t l_1638 = 0x61142D81L;
            int32_t **l_1655[3];
            float * const **l_1671 = (void*)0;
            float * const ***l_1670 = &l_1671;
            float * const ****l_1669 = &l_1670;
            struct S0 l_1672 = {-8048};
            int i;
            for (i = 0; i < 3; i++)
                l_1655[i] = &l_1217;
            p_9 = func_31((safe_lshift_func_int8_t_s_s(((((((*l_1217) || ((safe_lshift_func_int8_t_s_u(((((safe_mul_func_int8_t_s_s(l_1638, 255UL)) | (l_1639[5][2][1] == l_1639[6][2][1])) || (safe_unary_minus_func_uint8_t_u(0x12L))) ^ ((safe_lshift_func_uint16_t_u_u(l_1638, 1)) > (((safe_sub_func_uint8_t_u_u(((safe_lshift_func_int8_t_s_u((safe_mod_func_int16_t_s_s((((((safe_div_func_int64_t_s_s((((safe_sub_func_int64_t_s_s((((8UL == 0x961ED5DC206353E9LL) != (***l_1215)) ^ l_1638), p_8)) || l_1638) | (*l_1217)), l_1653)) == l_1638) != 0xEFBD3FD1L) < p_8) | p_8), p_8)), l_1638)) || p_8), 0x9BL)) < (***l_1215)) ^ p_8))), 0)) && (*l_1217))) > l_1653) | 0x86L) >= 0xFBL) ^ p_8), 1)), l_1654, (*p_9));
            /* statement id: 825 */
            assert ((p_9 >= &l_1188[0] && p_9 <= &l_1188[6]));
            l_1672 = func_27((*l_1654), l_1656, (safe_lshift_func_uint16_t_u_u((safe_rshift_func_int8_t_s_s((((~4294967288UL) || (safe_lshift_func_int16_t_s_s((**l_1216), 8))) | (l_1664 == (safe_mod_func_int16_t_s_s(((((safe_sub_func_int32_t_s_s((*p_9), (p_8 == 1UL))) < ((void*)0 != l_1669)) == (**l_1654)) | 0xE74F4B88CD7F5AC9LL), (**l_1654))))), 0)), 5)));
        }
        /* facts after for loop */
        //assert ((p_9 >= &l_1188[0] && p_9 <= &l_1188[6]) || p_9 == &l_6);
        (**l_1215) = &p_8;
        /* statement id: 828 */
        assert (l_1217 == &p_8);
        l_1656 = func_27((*l_1216), l_1656, p_8);
    }
    /* facts after branching */
    //assert ((p_9 >= &l_1188[0] && p_9 <= &l_1188[6]) || p_9 == &l_6 || p_9 == &p_8 || p_9 == 0);
    //assert (l_1217 == dangling || l_1217 == &p_8 || (l_1217 >= &l_1188[0] && l_1217 <= &l_1188[6]) || l_1217 == 0);
    (**l_1215) = &p_8;
    /* statement id: 831 */
    assert (l_1217 == &p_8);
    (**l_1216) = (l_1673 == l_1675);
    return l_1679;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_10(int32_t ** p_11, int32_t * const  p_12, int64_t  p_13, int32_t * const * p_14)
{ /* block id: 6 */
    uint8_t l_40 = 0UL;
    struct S0 l_1045 = {-2141};
    int32_t l_1051 = 0x5074FBEEL;
    int32_t *l_1050 = &l_1051;
    uint64_t l_1052[3][10][7] = {{{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL},{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL},{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL},{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL},{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL}},{{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL},{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL},{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL},{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL},{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL}},{{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL},{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL},{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL},{0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL},{0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL,0xC376D75767A1C0D4LL,0x1B713B4FAAA6AC5ALL},{0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL,0x16B177AD30ED89BFLL,0x5884121F058BCB91LL,0x5884121F058BCB91LL,0x16B177AD30ED89BFLL},{0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL,0xC376D75767A1C0D4LL,0xC0380B3B49992AF0LL}}};
    float l_1130 = 0xD.463980p+56;
    float *l_1129 = &l_1130;
    float ** const l_1128 = &l_1129;
    float ** const *l_1127[3][6][7] = {{{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,(void*)0,(void*)0,(void*)0,&l_1128,(void*)0,(void*)0},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,(void*)0,&l_1128,(void*)0,&l_1128,&l_1128}},{{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,(void*)0,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,(void*)0,&l_1128,&l_1128,(void*)0},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,(void*)0,(void*)0,(void*)0,&l_1128,&l_1128}},{{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,(void*)0,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,(void*)0,(void*)0,&l_1128,&l_1128,(void*)0},{&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128,&l_1128},{&l_1128,&l_1128,&l_1128,&l_1128,(void*)0,(void*)0,&l_1128}}};
    float ** const **l_1126 = &l_1127[1][1][1];
    float ** const ***l_1125 = &l_1126;
    int32_t l_1142 = 0xAE9998DFL;
    const struct S0 **l_1149[6];
    const struct S0 ***l_1148 = &l_1149[4];
    const struct S0 ****l_1147 = &l_1148;
    const struct S0 *****l_1146 = &l_1147;
    int i, j, k;
    for (i = 0; i < 6; i++)
        l_1149[i] = (void*)0;
    for (p_13 = 0; (p_13 >= 23); ++p_13)
    { /* block id: 9 */
        int32_t l_39 = 0x5205300CL;
        struct S0 l_1031[5] = {{-302},{-302},{-302},{-302},{-302}};
        struct S0 *l_1044[7] = {&l_1031[3],&l_1031[3],&l_1031[3],&l_1031[3],&l_1031[3],&l_1031[3],&l_1031[3]};
        int32_t **l_1077[10] = {&l_1050,&l_1050,&l_1050,&l_1050,&l_1050,&l_1050,&l_1050,&l_1050,&l_1050,&l_1050};
        float ***l_1090 = (void*)0;
        float ****l_1089[6][9] = {{&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090},{&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090},{&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,&l_1090,(void*)0,&l_1090,&l_1090},{&l_1090,(void*)0,&l_1090,&l_1090,&l_1090,&l_1090,(void*)0,&l_1090,&l_1090},{&l_1090,(void*)0,&l_1090,&l_1090,&l_1090,&l_1090,(void*)0,&l_1090,&l_1090},{&l_1090,(void*)0,&l_1090,&l_1090,&l_1090,&l_1090,(void*)0,&l_1090,&l_1090}};
        uint32_t l_1141 = 0xA5ABCDE6L;
        int i, j;
        l_1045 = func_27(func_31((safe_mul_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(l_39, ((l_40 > (safe_div_func_int8_t_s_s(func_43(p_13, (!func_47((1UL <= func_51(p_13)), (!(p_13 <= (~p_13))), (safe_rshift_func_uint16_t_u_u(p_13, p_13))))), 7UL))) | l_39))), p_13)), p_11, l_39), l_1031[3], l_40);
        l_1045 = func_27(func_31((safe_unary_minus_func_uint16_t_u((~((((((safe_mul_func_uint8_t_u_u(l_39, l_1045.f0)) || ((void*)0 == l_1050)) < (l_1052[1][7][4] || ((((safe_mod_func_uint32_t_u_u((p_13 && (safe_mul_func_uint16_t_u_u((p_13 & (safe_mul_func_int16_t_s_s(l_39, (safe_rshift_func_int16_t_s_u((safe_rshift_func_uint8_t_u_s((safe_add_func_uint64_t_u_u((safe_mul_func_int8_t_s_s((safe_lshift_func_uint8_t_u_s((((*p_12) < (*p_12)) != (*l_1050)), 5)), l_1031[3].f0)), (-7L))), 2)), 14))))), p_13))), 1L)) == p_13) | (*l_1050)) ^ 0UL))) != l_39) < p_13) & (*l_1050))))), &l_1050, (*p_12)), l_1045, p_13);
        if (l_1031[3].f0)
        { /* block id: 496 */
            int32_t *l_1078 = &l_1051;
            for (l_1051 = 22; (l_1051 >= 20); l_1051 = safe_sub_func_uint32_t_u_u(l_1051, 1))
            { /* block id: 499 */
                const struct S0 ** const *** const l_1071 = (void*)0;
                const struct S0 *l_1076[3][4][1] = {{{(void*)0},{(void*)0},{&l_1031[3]},{(void*)0}},{{(void*)0},{&l_1031[3]},{(void*)0},{(void*)0}},{{&l_1031[3]},{(void*)0},{(void*)0},{&l_1031[3]}}};
                const struct S0 **l_1075[2];
                const struct S0 ** const *l_1074 = &l_1075[0];
                const struct S0 ** const **l_1073 = &l_1074;
                const struct S0 ** const ***l_1072 = &l_1073;
                int i, j, k;
                for (i = 0; i < 2; i++)
                    l_1075[i] = &l_1076[2][2][0];
                for (l_40 = 0; (l_40 <= 4); l_40 += 1)
                { /* block id: 502 */
                    return p_13;
                    /* statement id: 503 */
                    //assert (l_5 == dangling || l_5 == 0);
                }
                l_1072 = l_1071;
                /* statement id: 505 */
                assert (l_1072 == 0);
                (*p_11) = (void*)0;
                /* statement id: 506 */
                //assert (l_5 == 0);
            }
            l_1078 = func_31(p_13, l_1077[3], (*p_12));
            l_1078 = &l_1051;
            for (l_39 = 0; (l_39 < 23); l_39 = safe_add_func_int32_t_s_s(l_39, 1))
            { /* block id: 512 */
                if ((*p_12))
                    break;
            }
        }
        else
        { /* block id: 515 */
            int32_t *l_1081 = &l_1051;
            struct S0 l_1088 = {4241};
            float ****l_1091[9] = {(void*)0,(void*)0,&l_1090,(void*)0,(void*)0,&l_1090,(void*)0,(void*)0,&l_1090};
            struct S0 **l_1103[10];
            float l_1143 = 0x7.D95DFFp-1;
            int i;
            for (i = 0; i < 10; i++)
                l_1103[i] = &l_1044[0];
            (*p_11) = l_1081;
            /* statement id: 516 */
            //assert (l_5 == &l_1051);
            for (l_1051 = (-17); (l_1051 < 3); l_1051++)
            { /* block id: 519 */
                uint16_t l_1084 = 0xDD1CL;
                struct S0 l_1099 = {4072};
                const float *l_1119 = (void*)0;
                const float **l_1118 = &l_1119;
                if (l_1084)
                { /* block id: 520 */
                    struct S0 l_1087[2][1] = {{{-752}},{{-752}}};
                    int32_t *l_1094 = &l_1051;
                    struct S0 **l_1102 = &l_1044[0];
                    int i, j;
                    for (l_40 = (-13); (l_40 >= 24); ++l_40)
                    { /* block id: 523 */
                        l_1088 = l_1087[1][0];
                        l_1091[6] = l_1089[5][5];
                    }
                    for (l_40 = (-14); (l_40 == 2); l_40++)
                    { /* block id: 529 */
                        struct S0 l_1095 = {2322};
                        l_1087[1][0].f0 = p_13;
                        (*p_11) = l_1094;
                        l_1095 = l_1095;
                    }
                    if ((safe_mul_func_int16_t_s_s((safe_unary_minus_func_uint32_t_u((*l_1050))), 0xBE81L)))
                    { /* block id: 534 */
                        l_1088 = l_1099;
                    }
                    else
                    { /* block id: 536 */
                        uint16_t l_1104[5];
                        int32_t **l_1113 = &l_1094;
                        int i;
                        for (i = 0; i < 5; i++)
                            l_1104[i] = 0UL;
                        (*l_1113) = func_31((4294967295UL | ((safe_div_func_uint64_t_u_u((((l_1102 == l_1103[6]) || l_1104[3]) != ((((0x67A423C6L < (safe_rshift_func_int16_t_s_s(p_13, 0))) & p_13) | (p_13 != ((safe_mod_func_uint16_t_u_u((((safe_rshift_func_int16_t_s_s(1L, p_13)) == l_1104[4]) == (**p_11)), 65527UL)) == p_13))) != 1UL)), l_1099.f0)) && p_13)), p_11, (*p_12));
                    }
                    if ((+(+0xD0L)))
                    { /* block id: 539 */
                        if ((*p_12))
                            break;
                    }
                    else
                    { /* block id: 541 */
                        l_1045.f0 = (*l_1050);
                    }
                }
                else
                { /* block id: 544 */
                    uint8_t l_1131 = 0UL;
                    (*l_1129) = ((((safe_mul_func_float_f_f(((void*)0 == l_1118), (+(safe_add_func_float_f_f(((safe_add_func_float_f_f((0x0.2p-1 != (l_1125 == (void*)0)), l_1131)) <= 0x5.184FC5p-65), ((((safe_mul_func_float_f_f((safe_mul_func_float_f_f((-0x0.5BB2E5p-7), (safe_mul_func_float_f_f(((((((safe_add_func_float_f_f((*l_1081), (*l_1050))) >= p_13) > l_1084) == p_13) <= l_1131) != p_13), (*l_1050))))), (-0x1.3p+1))) == 0x9.E97736p-89) != 0x1.2p+1) < (*l_1081))))))) <= p_13) > p_13) >= (-0x5.8p-1));
                    l_1141 = 4L;
                }
                l_1099 = func_27(&l_1051, l_1099, ((((p_13 <= (l_1142 && p_13)) && (*p_12)) || (*l_1050)) < 0xF3L));
            }
        }
        for (l_39 = 0; (l_39 > 18); ++l_39)
        { /* block id: 553 */
            const struct S0 *****l_1150 = &l_1147;
            int32_t l_1151 = 0x25DF67ECL;
            l_1150 = l_1146;
            if (l_1151)
                continue;
        }
    }
    /* facts after for loop */
    //assert (l_5 == &l_1051 || l_5 == 0);
    return p_13;
    /* statement id: 558 */
    //assert (l_5 == dangling || l_5 == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_17(struct S0  p_18)
{ /* block id: 3 */
    uint8_t l_20 = 0UL;
    int32_t *l_22 = (void*)0;
    int32_t **l_21 = &l_22;
    int32_t **l_23 = &l_22;
    int32_t **l_24 = (void*)0;
    l_20 = p_18.f0;
    return l_24;
    /* statement id: 5 */
    //assert (func_17_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_27(int32_t * const  p_28, struct S0  p_29, int32_t  p_30)
{ /* block id: 484 */
    uint32_t l_1034 = 0x5D359645L;
    int32_t l_1035 = (-1L);
    float ****l_1037 = (void*)0;
    float *****l_1036[9][6] = {{&l_1037,&l_1037,&l_1037,&l_1037,&l_1037,&l_1037},{(void*)0,&l_1037,(void*)0,&l_1037,&l_1037,&l_1037},{&l_1037,&l_1037,&l_1037,&l_1037,&l_1037,&l_1037},{(void*)0,&l_1037,(void*)0,&l_1037,&l_1037,&l_1037},{&l_1037,&l_1037,&l_1037,&l_1037,&l_1037,&l_1037},{(void*)0,&l_1037,(void*)0,&l_1037,&l_1037,&l_1037},{&l_1037,&l_1037,&l_1037,&l_1037,&l_1037,&l_1037},{(void*)0,&l_1037,(void*)0,&l_1037,&l_1037,&l_1037},{&l_1037,&l_1037,&l_1037,&l_1037,&l_1037,&l_1037}};
    struct S0 l_1043 = {4782};
    struct S0 *l_1042 = &l_1043;
    struct S0 **l_1041 = &l_1042;
    int i, j;
    l_1035 = (safe_add_func_int8_t_s_s(l_1034, l_1034));
    l_1036[0][1] = l_1036[1][1];
    for (l_1034 = (-5); (l_1034 > 28); ++l_1034)
    { /* block id: 489 */
        struct S0 l_1040 = {5134};
        return l_1040;
    }
    (*l_1041) = &p_29;
    /* statement id: 492 */
    assert (l_1042 == &p_29);
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads : l_5
 * writes:
 */
inline static int32_t * const  func_31(uint32_t  p_32, int32_t ** p_33, const int32_t  p_34)
{ /* block id: 481 */
    int32_t l_1030 = 0x8C50F167L;
    int32_t *l_1029 = &l_1030;
    l_1029 = (*p_33);
    /* statement id: 482 */
    //assert (l_1029 == 0 || l_1029 == &l_1051 || l_1029 == &p_8 || (l_1029 >= &l_1188[0] && l_1029 <= &l_1188[6]));
    return (*p_33);
    /* statement id: 483 */
    //assert (func_31_rv == 0 || func_31_rv == &l_1051 || func_31_rv == &p_8 || (func_31_rv >= &l_1188[0] && func_31_rv <= &l_1188[6]));
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_43(uint64_t  p_44, int64_t  p_45)
{ /* block id: 258 */
    uint16_t l_616 = 6UL;
    int64_t l_643 = 0L;
    uint8_t l_644[3][2][7] = {{{0UL,3UL,0UL,255UL,0x48L,255UL,0UL},{5UL,5UL,0xC1L,5UL,5UL,0xC1L,5UL}},{{0x48L,255UL,0UL,3UL,0UL,255UL,0x48L},{0x03L,5UL,0x03L,0x03L,5UL,0x03L,0x03L}},{{0x48L,3UL,1UL,3UL,0x48L,1UL,0x48L},{5UL,0x03L,0x03L,5UL,0x03L,0x03L,5UL}}};
    int32_t **l_648 = (void*)0;
    int32_t l_658[3][8][8] = {{{0L,2L,(-3L),1L,1L,(-3L),2L,0L},{2L,2L,0L,(-5L),0L,2L,2L,2L},{2L,(-5L),(-3L),(-3L),(-5L),2L,1L,2L},{(-5L),2L,1L,2L,(-5L),(-3L),(-3L),(-5L)},{2L,2L,2L,2L,0L,(-3L),0x571FFC8FL,2L},{(-5L),0x571FFC8FL,(-5L),1L,0L,0L,1L,(-5L)},{0x571FFC8FL,0x571FFC8FL,0L,(-3L),2L,(-3L),0L,0x571FFC8FL},{0x571FFC8FL,(-5L),1L,0L,0L,1L,(-5L),0x571FFC8FL}},{{(-5L),2L,0x571FFC8FL,(-3L),0x571FFC8FL,2L,(-5L),(-5L)},{2L,(-3L),1L,1L,(-3L),2L,0L,2L},{(-3L),2L,0L,2L,(-3L),1L,1L,(-3L)},{2L,(-5L),(-5L),2L,0x571FFC8FL,(-3L),0x571FFC8FL,2L},{(-5L),0x571FFC8FL,(-5L),1L,0L,0L,1L,(-5L)},{0x571FFC8FL,0x571FFC8FL,0L,(-3L),2L,(-3L),0L,0x571FFC8FL},{0x571FFC8FL,(-5L),1L,0L,0L,1L,(-5L),0x571FFC8FL},{(-5L),2L,0x571FFC8FL,(-3L),0x571FFC8FL,2L,(-5L),(-5L)}},{{2L,(-3L),1L,1L,(-3L),2L,0L,2L},{(-3L),2L,0L,2L,(-3L),1L,1L,(-3L)},{2L,(-5L),(-5L),2L,0x571FFC8FL,(-3L),0x571FFC8FL,2L},{(-5L),0x571FFC8FL,(-5L),1L,0L,0L,1L,(-5L)},{0x571FFC8FL,0x571FFC8FL,0L,(-3L),2L,(-3L),0L,0x571FFC8FL},{0x571FFC8FL,(-5L),1L,0L,0L,1L,(-5L),0x571FFC8FL},{(-5L),2L,0x571FFC8FL,(-3L),0x571FFC8FL,2L,(-5L),(-5L)},{2L,(-3L),1L,1L,(-3L),2L,0L,2L}}};
    struct S0 l_685 = {262};
    struct S0 *l_684 = &l_685;
    int32_t ***l_703 = &l_648;
    int32_t ****l_702[7];
    int64_t l_829 = 0xFBF31C479956CC8BLL;
    uint32_t l_830 = 0UL;
    int32_t *l_832[2][1][10] = {{{(void*)0,&l_658[0][7][4],(void*)0,&l_658[0][7][4],(void*)0,&l_658[0][7][4],(void*)0,&l_658[0][7][4],(void*)0,&l_658[0][7][4]}},{{&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4]}}};
    uint64_t l_857[10][6][4] = {{{0xDDE8BE5ECFBEB2E0LL,18446744073709551615UL,0xAE9E3DE8B0C46922LL,0xAE9E3DE8B0C46922LL},{18446744073709551606UL,18446744073709551606UL,8UL,0x4DFC658F677D459CLL},{0xE45CDECEC090FD26LL,7UL,0x8C0D73B670D85F01LL,0x7947BC613D382D92LL},{0xE84D669DA42E79C2LL,0x53F007C1C0267AC3LL,0x3B67D412846055A4LL,0x8C0D73B670D85F01LL},{8UL,0x488992270FCC9BEELL,0xE45CDECEC090FD26LL,0x2144BAA014E2C970LL},{0x488992270FCC9BEELL,6UL,1UL,0xFA54120BD37EFCD5LL}},{{0x24A557D3B0E98A98LL,0xC64C60B88D6FFA38LL,0xBDCF3259B7D033CELL,1UL},{0x706811F2B0B246E0LL,0xAE9E3DE8B0C46922LL,0UL,0xA8F5E395B898AA5FLL},{0x609B1F1A9F082624LL,5UL,0xA100BF51782F000DLL,1UL},{0xFA54120BD37EFCD5LL,0xA112F88271138A71LL,18446744073709551615UL,0x53F007C1C0267AC3LL},{0xAAC5FF70F32B3B63LL,0x24A557D3B0E98A98LL,1UL,0xBCE68F8E5A8FD535LL},{8UL,18446744073709551610UL,0x24A557D3B0E98A98LL,0x706811F2B0B246E0LL}},{{0xBDCF3259B7D033CELL,0xD152B5915266BB7FLL,5UL,0xFA54120BD37EFCD5LL},{0x4DFC658F677D459CLL,0UL,0x488992270FCC9BEELL,8UL},{18446744073709551613UL,18446744073709551615UL,0UL,1UL},{0xD71DE4F4FFDAF288LL,0x609B1F1A9F082624LL,0xA100BF51782F000DLL,0xAE9E3DE8B0C46922LL},{18446744073709551615UL,6UL,1UL,8UL},{5UL,0xBDCF3259B7D033CELL,0xE8056A8F8FBA7250LL,18446744073709551606UL}},{{0x706811F2B0B246E0LL,18446744073709551610UL,0x4DFC658F677D459CLL,18446744073709551614UL},{0x488992270FCC9BEELL,0x706811F2B0B246E0LL,0xAAC5FF70F32B3B63LL,1UL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL,0x8C0D73B670D85F01LL},{18446744073709551613UL,2UL,1UL,0xA8F5E395B898AA5FLL},{1UL,18446744073709551615UL,18446744073709551606UL,2UL},{0x3BC8A551E8852651LL,0xD152B5915266BB7FLL,18446744073709551606UL,8UL}},{{1UL,0x89842AB500DC684ELL,1UL,18446744073709551608UL},{18446744073709551613UL,0x488992270FCC9BEELL,18446744073709551615UL,0x904C5837D2F74897LL},{18446744073709551615UL,0x904C5837D2F74897LL,0xAAC5FF70F32B3B63LL,0xAE9E3DE8B0C46922LL},{0x488992270FCC9BEELL,0UL,0x4DFC658F677D459CLL,0UL},{0x706811F2B0B246E0LL,0x3BC8A551E8852651LL,0xE8056A8F8FBA7250LL,1UL},{5UL,18446744073709551615UL,1UL,0xBAEEDB53D4E68237LL}},{{18446744073709551615UL,0x706811F2B0B246E0LL,0xA100BF51782F000DLL,0x53F007C1C0267AC3LL},{0xD71DE4F4FFDAF288LL,0x5841711A6D2DDFCDLL,0UL,0x05F96895D4C62396LL},{18446744073709551613UL,0x24A557D3B0E98A98LL,0x488992270FCC9BEELL,18446744073709551614UL},{0x4DFC658F677D459CLL,0x2144BAA014E2C970LL,5UL,2UL},{0xBDCF3259B7D033CELL,0xC64C60B88D6FFA38LL,0x24A557D3B0E98A98LL,0UL},{8UL,18446744073709551615UL,1UL,8UL}},{{0xAAC5FF70F32B3B63LL,0x609B1F1A9F082624LL,18446744073709551615UL,18446744073709551615UL},{0xFA54120BD37EFCD5LL,0x904C5837D2F74897LL,0xA100BF51782F000DLL,0x2144BAA014E2C970LL},{0x609B1F1A9F082624LL,0x89842AB500DC684ELL,0UL,18446744073709551615UL},{0x706811F2B0B246E0LL,0xBDCF3259B7D033CELL,0xBDCF3259B7D033CELL,0x706811F2B0B246E0LL},{0x24A557D3B0E98A98LL,0x2144BAA014E2C970LL,1UL,0xBAEEDB53D4E68237LL},{0x488992270FCC9BEELL,5UL,0xE45CDECEC090FD26LL,0x8C0D73B670D85F01LL}},{{8UL,0x94BD452C2C088614LL,0UL,0x8C0D73B670D85F01LL},{0xAAC5FF70F32B3B63LL,5UL,0UL,0xBAEEDB53D4E68237LL},{0x3B67D412846055A4LL,0x2144BAA014E2C970LL,18446744073709551606UL,0x706811F2B0B246E0LL},{0xC64C60B88D6FFA38LL,0xBDCF3259B7D033CELL,1UL,18446744073709551615UL},{8UL,0x89842AB500DC684ELL,0x488992270FCC9BEELL,0x2144BAA014E2C970LL},{0xE45CDECEC090FD26LL,0x904C5837D2F74897LL,0xD71DE4F4FFDAF288LL,18446744073709551615UL}},{{18446744073709551615UL,0x609B1F1A9F082624LL,0xE45CDECEC090FD26LL,8UL},{0x904C5837D2F74897LL,18446744073709551615UL,0UL,0UL},{5UL,0xC64C60B88D6FFA38LL,18446744073709551615UL,2UL},{2UL,0x2144BAA014E2C970LL,1UL,0x89842AB500DC684ELL},{0x93DEBF33D6B8D8E1LL,0x3BC8A551E8852651LL,1UL,0x609B1F1A9F082624LL},{18446744073709551610UL,0xBAEEDB53D4E68237LL,0xAE9E3DE8B0C46922LL,0x488992270FCC9BEELL}},{{0x3B67D412846055A4LL,0xBDCF3259B7D033CELL,0x93DEBF33D6B8D8E1LL,18446744073709551606UL},{0xFA54120BD37EFCD5LL,0xFECE996C4569E5F4LL,0x3BC8A551E8852651LL,18446744073709551615UL},{0UL,0x8C0D73B670D85F01LL,18446744073709551615UL,18446744073709551608UL},{0x7947BC613D382D92LL,0xDDE8BE5ECFBEB2E0LL,18446744073709551615UL,1UL},{0UL,0x5841711A6D2DDFCDLL,18446744073709551615UL,0x5841711A6D2DDFCDLL},{0xBF36417F505A122ELL,0x94BD452C2C088614LL,1UL,5UL}}};
    int32_t *****l_885 = &l_702[6];
    struct S0 **l_959 = &l_684;
    struct S0 ***l_958[9];
    struct S0 ****l_957 = &l_958[5];
    struct S0 **l_1008 = &l_684;
    uint64_t l_1009 = 0x00BD590771587341LL;
    int i, j, k;
    for (i = 0; i < 7; i++)
        l_702[i] = &l_703;
    for (i = 0; i < 9; i++)
        l_958[i] = &l_959;
    if (l_616)
    { /* block id: 259 */
        uint64_t l_636 = 0UL;
        const float l_640 = 0x3.Ap-1;
        const float *l_639 = &l_640;
        const float **l_638 = &l_639;
        const float ***l_637 = &l_638;
        const int32_t ** const *l_669 = (void*)0;
        struct S0 ***l_686 = (void*)0;
        int32_t l_706 = (-1L);
        int32_t *****l_751 = &l_702[4];
        const struct S0 l_776 = {1521};
        int32_t *l_800 = &l_706;
        uint32_t l_852[3][1];
        uint8_t l_897[3][6];
        const struct S0 *l_1016[10][7][3] = {{{&l_685,&l_776,&l_776},{&l_685,(void*)0,(void*)0},{&l_776,&l_776,&l_685},{&l_685,&l_776,(void*)0},{(void*)0,(void*)0,&l_685},{(void*)0,&l_776,&l_776},{&l_776,&l_776,(void*)0}},{{&l_685,(void*)0,&l_776},{&l_685,&l_776,&l_685},{(void*)0,&l_776,&l_776},{&l_685,(void*)0,&l_685},{&l_685,&l_776,&l_685},{&l_776,&l_776,(void*)0},{&l_685,(void*)0,&l_776}},{{&l_776,&l_776,&l_685},{(void*)0,&l_776,&l_776},{&l_776,(void*)0,&l_776},{&l_685,&l_776,&l_776},{&l_685,&l_776,&l_776},{&l_685,(void*)0,(void*)0},{&l_776,&l_776,&l_685}},{{&l_685,&l_776,(void*)0},{(void*)0,(void*)0,&l_685},{(void*)0,&l_776,&l_776},{&l_776,&l_776,(void*)0},{&l_685,(void*)0,&l_776},{&l_685,&l_776,&l_685},{(void*)0,&l_776,&l_776}},{{&l_685,(void*)0,&l_685},{&l_685,&l_776,&l_685},{&l_776,&l_776,(void*)0},{&l_685,(void*)0,&l_776},{&l_776,&l_776,&l_685},{(void*)0,&l_776,&l_776},{&l_776,(void*)0,&l_776}},{{&l_685,&l_776,&l_776},{&l_685,&l_776,&l_776},{&l_685,(void*)0,(void*)0},{&l_776,&l_776,&l_685},{&l_685,&l_776,(void*)0},{(void*)0,(void*)0,&l_685},{(void*)0,&l_776,&l_776}},{{&l_776,&l_776,(void*)0},{&l_685,(void*)0,&l_776},{&l_685,&l_776,&l_685},{(void*)0,&l_776,&l_776},{&l_685,(void*)0,&l_685},{&l_685,&l_776,&l_685},{&l_776,&l_776,(void*)0}},{{&l_685,(void*)0,&l_776},{&l_776,&l_776,&l_685},{(void*)0,&l_776,&l_776},{&l_776,&l_685,(void*)0},{&l_776,(void*)0,&l_685},{(void*)0,(void*)0,(void*)0},{&l_776,(void*)0,(void*)0}},{{&l_685,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0},{&l_685,&l_685,&l_685},{&l_776,(void*)0,&l_776},{&l_776,(void*)0,&l_776},{&l_685,(void*)0,&l_776},{&l_685,(void*)0,&l_685}},{{&l_776,(void*)0,(void*)0},{&l_685,&l_685,&l_776},{(void*)0,(void*)0,&l_685},{(void*)0,(void*)0,&l_685},{&l_776,(void*)0,&l_776},{&l_776,(void*)0,(void*)0},{&l_776,(void*)0,&l_776}}};
        const struct S0 ** const l_1015 = &l_1016[4][1][0];
        int i, j, k;
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 1; j++)
                l_852[i][j] = 0x06BF7B63L;
        }
        for (i = 0; i < 3; i++)
        {
            for (j = 0; j < 6; j++)
                l_897[i][j] = 0xE2L;
        }
    }
    else
    { /* block id: 460 */
        int32_t *l_1020 = &l_658[0][7][4];
        for (l_616 = 0; (l_616 <= 42); l_616 = safe_add_func_uint8_t_u_u(l_616, 2))
        { /* block id: 463 */
            int32_t *l_1021 = &l_658[0][7][4];
            l_1021 = l_1020;
        }
        l_1020 = l_1020;
    }
    for (l_643 = (-20); (l_643 > (-3)); l_643 = safe_add_func_uint64_t_u_u(l_643, 1))
    { /* block id: 470 */
        int32_t * const l_1024 = (void*)0;
        uint8_t l_1026 = 0x0DL;
        int32_t l_1027 = (-1L);
        int32_t *l_1028[9][8][3] = {{{&l_658[0][7][4],&l_1027,(void*)0},{&l_658[1][0][0],&l_658[1][3][4],&l_1027},{&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4]},{(void*)0,(void*)0,&l_1027},{(void*)0,&l_658[0][7][4],&l_658[0][7][4]},{&l_1027,&l_658[0][7][4],&l_1027},{&l_1027,&l_1027,(void*)0},{&l_658[0][7][4],&l_658[0][7][4],&l_658[1][6][5]}},{{&l_658[1][4][7],&l_658[2][4][0],&l_658[0][7][4]},{&l_658[1][3][2],&l_658[0][7][4],&l_658[0][7][4]},{&l_658[1][4][7],&l_658[1][0][0],&l_1027},{&l_658[0][7][4],&l_658[0][5][2],&l_1027},{&l_1027,&l_658[0][5][4],&l_658[1][3][4]},{&l_1027,&l_658[0][7][4],&l_658[1][4][7]},{(void*)0,&l_658[0][7][4],&l_658[2][4][0]},{(void*)0,&l_658[1][7][5],&l_658[0][7][4]}},{{&l_658[0][7][4],(void*)0,&l_658[2][6][0]},{&l_658[1][0][0],&l_1027,&l_658[1][1][7]},{&l_658[0][7][4],&l_658[0][1][3],&l_658[1][6][7]},{(void*)0,(void*)0,&l_1027},{&l_658[1][3][4],&l_658[0][7][4],&l_658[1][0][0]},{&l_1027,&l_1027,&l_658[2][4][0]},{(void*)0,&l_1027,&l_1027},{&l_658[0][5][2],&l_658[0][7][4],&l_658[0][7][4]}},{{&l_1027,(void*)0,&l_658[0][7][4]},{(void*)0,&l_658[0][1][3],&l_658[0][7][4]},{&l_658[1][6][5],&l_1027,&l_1027},{&l_1027,(void*)0,&l_1027},{&l_658[0][7][4],&l_658[1][7][5],&l_658[1][6][5]},{(void*)0,&l_658[0][7][4],&l_658[1][6][7]},{&l_658[0][7][4],&l_658[0][7][4],&l_658[2][6][0]},{&l_658[0][5][4],&l_658[0][5][4],&l_658[0][7][4]}},{{&l_1027,&l_658[0][5][2],&l_658[0][7][4]},{&l_658[2][4][0],&l_658[1][0][0],(void*)0},{&l_1027,&l_658[0][7][4],&l_658[0][5][4]},{&l_1027,&l_658[2][4][0],(void*)0},{(void*)0,&l_658[0][7][4],&l_658[0][7][4]},{&l_658[0][7][4],&l_1027,&l_658[0][7][4]},{&l_1027,&l_658[0][7][4],&l_658[2][6][0]},{&l_658[0][7][4],&l_658[0][7][4],&l_658[1][6][7]}},{{&l_658[2][4][0],(void*)0,&l_658[1][6][5]},{(void*)0,&l_658[0][7][4],&l_1027},{&l_658[0][7][4],&l_658[1][3][4],&l_1027},{&l_658[1][4][7],&l_1027,&l_658[0][7][4]},{&l_658[1][0][3],&l_658[0][7][4],&l_658[0][7][4]},{&l_658[1][0][0],&l_658[0][5][4],&l_658[0][7][4]},{&l_658[1][7][5],&l_658[2][0][2],&l_658[1][1][7]},{&l_658[0][7][4],&l_1027,&l_658[0][7][4]}},{{&l_658[0][7][4],&l_1027,&l_658[0][7][4]},{&l_658[1][7][5],&l_1027,&l_658[0][7][4]},{&l_658[0][7][4],&l_658[0][5][2],&l_658[2][6][0]},{&l_658[2][0][2],(void*)0,&l_1027},{&l_658[1][4][5],&l_658[0][7][4],&l_1027},{(void*)0,&l_658[1][3][2],&l_658[0][7][4]},{&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4]},{&l_658[0][7][4],&l_658[1][3][4],&l_658[1][4][5]}},{{&l_658[1][3][4],&l_1027,&l_1027},{(void*)0,&l_658[0][7][4],&l_658[1][1][7]},{&l_658[0][7][4],(void*)0,&l_658[0][7][4]},{&l_1027,&l_1027,&l_658[0][5][4]},{&l_658[1][7][5],&l_658[0][7][4],&l_658[0][7][4]},{&l_658[1][3][2],&l_1027,&l_658[0][7][4]},{&l_658[0][7][4],(void*)0,&l_1027},{&l_658[1][6][5],&l_658[0][7][4],&l_658[0][7][4]}},{{&l_658[0][7][4],&l_1027,&l_658[0][7][4]},{&l_658[1][6][7],&l_658[1][3][4],&l_658[0][7][4]},{&l_658[0][7][4],&l_658[0][7][4],(void*)0},{&l_658[1][3][4],&l_658[1][3][2],(void*)0},{&l_658[0][7][4],&l_658[0][7][4],&l_658[0][7][4]},{&l_658[0][7][4],(void*)0,&l_658[0][7][4]},{&l_1027,&l_658[0][5][2],&l_658[1][3][2]},{(void*)0,&l_1027,&l_658[0][7][4]}}};
        int i, j, k;
        for (l_1009 = 0; (l_1009 <= 8); l_1009 += 1)
        { /* block id: 473 */
            int32_t **l_1025 = &l_832[1][0][5];
            (*l_1025) = l_1024;
        }
        l_1027 = l_1026;
        l_1028[6][4][0] = &l_1027;
        (***l_885) = (void*)0;
    }
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint8_t  func_47(uint64_t  p_48, uint16_t  p_49, int32_t  p_50)
{ /* block id: 222 */
    int32_t l_565 = 0L;
    const float ****l_569 = (void*)0;
    struct S0 *** const l_573 = (void*)0;
    struct S0 *** const *l_572 = &l_573;
    int32_t *l_574 = &l_565;
    int64_t l_596 = (-1L);
    int32_t **l_615 = &l_574;
    (*l_574) = (safe_add_func_int32_t_s_s((safe_mul_func_uint8_t_u_u(((0x7BL <= (p_49 ^ l_565)) || ((safe_div_func_uint16_t_u_u((0x2A6AC009L & (!(l_569 == (void*)0))), l_565)) ^ (safe_rshift_func_uint8_t_u_s((l_572 == &l_573), p_49)))), p_50)), 0x96608AE7L));
lbl_613:
    (*l_574) = (safe_mul_func_uint8_t_u_u((~0x38L), p_50));
    for (p_48 = 0; (p_48 <= 21); p_48++)
    { /* block id: 227 */
        const struct S0 l_603[3] = {{5480},{5480},{5480}};
        const struct S0 *l_602[1];
        const struct S0 **l_601 = &l_602[0];
        const int32_t *****l_604 = (void*)0;
        int32_t l_608 = 0x37144B47L;
        int i;
        for (i = 0; i < 1; i++)
            l_602[i] = &l_603[2];
        for (p_49 = 0; (p_49 <= 24); ++p_49)
        { /* block id: 230 */
            struct S0 *l_585 = (void*)0;
            int32_t l_605 = 0xCC5A4AFAL;
            uint32_t l_606 = 0x64DF0AA5L;
            float *l_607 = (void*)0;
            int32_t **l_609 = (void*)0;
            int32_t **l_610 = &l_574;
            l_608 = (safe_add_func_float_f_f((*l_574), (((((((!((l_585 != (void*)0) < ((safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_add_func_float_f_f((-0x1.6p-1), ((safe_div_func_float_f_f(((l_596 <= (safe_sub_func_float_f_f((safe_add_func_float_f_f(0xB.149F11p-28, ((void*)0 == l_601))), (l_604 == (void*)0)))) <= (-0x1.1p+1)), l_605)) == (-0x5.2p+1)))), (-0x5.Dp-1))), l_605)), (-0x1.Ap-1))) > p_48))) >= p_48) <= p_50) != l_606) == (*l_574)) == (*l_574)) <= 0xF.3CEE95p-8)));
            (*l_610) = &l_565;
            /* statement id: 232 */
            assert (l_574 == &l_565);
            for (l_606 = 0; (l_606 <= 0); l_606 += 1)
            { /* block id: 235 */
                int32_t *l_612 = &l_605;
                for (l_605 = 0; (l_605 <= 0); l_605 += 1)
                { /* block id: 238 */
                    for (l_565 = 0; (l_565 <= 0); l_565 += 1)
                    { /* block id: 241 */
                        int16_t l_611[5][5];
                        int i, j;
                        for (i = 0; i < 5; i++)
                        {
                            for (j = 0; j < 5; j++)
                                l_611[i][j] = (-1L);
                        }
                        l_608 = l_611[2][0];
                        l_602[l_565] = (void*)0;
                        /* statement id: 243 */
                        //assert (l_602[0] == 0 || (l_602[0] >= &l_603[0] && l_602[0] <= &l_603[2]));
                        return l_611[3][1];
                    }
                    if ((l_612 != (void*)0))
                    { /* block id: 246 */
                        if (p_49)
                            goto lbl_613;
                        (*l_610) = &p_50;
                        /* statement id: 248 */
                        assert (l_574 == &p_50);
                    }
                    else
                    { /* block id: 249 */
                        int32_t *l_614 = &l_565;
                        (*l_610) = l_614;
                        /* statement id: 250 */
                        assert (l_574 == &l_565);
                    }
                }
            }
            /* facts after for loop */
            assert (l_574 == &l_565 || l_574 == &p_50);
        }
    }
    (*l_615) = &l_565;
    /* statement id: 256 */
    assert (l_574 == &l_565);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint8_t  func_51(uint32_t  p_52)
{ /* block id: 10 */
    int32_t l_59 = 0L;
    int32_t *l_58 = &l_59;
    int32_t **l_57[4][3][9] = {{{&l_58,&l_58,&l_58,(void*)0,&l_58,&l_58,&l_58,&l_58,&l_58},{(void*)0,&l_58,&l_58,(void*)0,&l_58,&l_58,(void*)0,(void*)0,&l_58},{(void*)0,&l_58,&l_58,&l_58,&l_58,&l_58,&l_58,&l_58,(void*)0}},{{&l_58,(void*)0,&l_58,&l_58,&l_58,(void*)0,&l_58,(void*)0,&l_58},{&l_58,(void*)0,&l_58,&l_58,&l_58,(void*)0,&l_58,(void*)0,&l_58},{&l_58,&l_58,&l_58,&l_58,(void*)0,&l_58,&l_58,&l_58,&l_58}},{{&l_58,&l_58,&l_58,&l_58,(void*)0,&l_58,&l_58,&l_58,(void*)0},{(void*)0,&l_58,&l_58,&l_58,&l_58,&l_58,&l_58,&l_58,&l_58},{&l_58,(void*)0,&l_58,&l_58,&l_58,&l_58,&l_58,(void*)0,&l_58}},{{&l_58,&l_58,&l_58,&l_58,&l_58,(void*)0,(void*)0,(void*)0,(void*)0},{&l_58,&l_58,&l_58,&l_58,&l_58,&l_58,(void*)0,&l_58,&l_58},{&l_58,&l_58,&l_58,&l_58,(void*)0,&l_58,&l_58,&l_58,&l_58}}};
    struct S0 l_552[2][10][7] = {{{{1418},{-1797},{7902},{-183},{7902},{600},{-857}},{{-7402},{-6910},{-165},{-6833},{2455},{7613},{2602}},{{1266},{-183},{7994},{3088},{5066},{1447},{7850}},{{-6727},{2602},{-165},{-6727},{5553},{-699},{5328}},{{-2739},{-1569},{7902},{7902},{-1569},{-2739},{-4981}},{{-4407},{489},{1732},{2455},{-6910},{1732},{-6727}},{{-1569},{-4981},{7645},{5066},{7902},{-6718},{5066}},{{-699},{489},{-7402},{5553},{5328},{2602},{2602}},{{415},{-1569},{1447},{-1569},{415},{7994},{1266}},{{2924},{2602},{5553},{-6910},{-6833},{2735},{2924}}},{{{3243},{-183},{-4981},{7902},{1266},{764},{600}},{{2924},{-6910},{2396},{5328},{490},{1732},{490}},{{415},{600},{600},{415},{764},{3243},{3088}},{{-699},{7044},{7613},{-6833},{7044},{757},{2735}},{{-1569},{-1797},{1447},{1266},{-857},{1447},{3088}},{{-4407},{2735},{-699},{490},{-6833},{-6833},{490}},{{-2739},{415},{-2739},{764},{-1797},{576},{600}},{{-6727},{-4407},{1732},{7044},{489},{2396},{2924}},{{1266},{600},{-6718},{-857},{7902},{576},{1266}},{{-7402},{2455},{2602},{-6833},{2924},{-6833},{2602}}}};
    int i, j, k;
    for (p_52 = 0; (p_52 == 8); p_52 = safe_add_func_uint64_t_u_u(p_52, 4))
    { /* block id: 13 */
        struct S0 l_551 = {4342};
        struct S0 *l_550[7] = {&l_551,&l_551,&l_551,&l_551,&l_551,&l_551,&l_551};
        float l_556 = 0x7.Cp+1;
        float *l_555 = &l_556;
        int i;
        l_552[1][1][5] = func_55(l_57[3][2][0]);
        if (p_52)
            break;
        if (p_52)
            continue;
        (*l_555) = (safe_sub_func_float_f_f((l_551.f0 > 0xC.136F0Ep+79), l_551.f0));
    }
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_55(int32_t ** p_56)
{ /* block id: 14 */
    int32_t l_60 = 0xD1A932DAL;
    uint64_t l_71[7];
    int32_t l_72 = 0x89098934L;
    int32_t *l_155[3];
    int32_t ** const l_154 = &l_155[1];
    uint32_t l_178 = 18446744073709551615UL;
    int32_t **l_182 = &l_155[1];
    int32_t ***l_181 = &l_182;
    int32_t *** const *l_180 = &l_181;
    int32_t *** const **l_179 = &l_180;
    uint32_t l_183 = 4294967295UL;
    const uint32_t l_186 = 0xA4866C57L;
    uint16_t l_191 = 8UL;
    uint16_t l_192 = 9UL;
    uint32_t l_193[2][6];
    uint16_t l_195 = 0x819DL;
    uint64_t l_198 = 1UL;
    struct S0 l_229 = {5469};
    struct S0 *l_228 = &l_229;
    struct S0 **l_227 = &l_228;
    int32_t *l_369 = (void*)0;
    int16_t l_434 = 1L;
    int32_t *l_462[5] = {&l_60,&l_60,&l_60,&l_60,&l_60};
    struct S0 l_549 = {-2515};
    int i, j;
    for (i = 0; i < 7; i++)
        l_71[i] = 0x2E8824086237DDC4LL;
    for (i = 0; i < 3; i++)
        l_155[i] = (void*)0;
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 6; j++)
            l_193[i][j] = 1UL;
    }
lbl_542:
    for (l_60 = (-3); (l_60 >= 13); l_60++)
    { /* block id: 17 */
        uint32_t l_63 = 5UL;
        uint32_t l_68 = 0x8B1460DEL;
        uint32_t l_91[6];
        int8_t l_92[10];
        int32_t *l_93[3][7][10] = {{{&l_60,(void*)0,&l_72,&l_72,&l_60,&l_60,&l_60,&l_72,&l_72,&l_72},{&l_72,(void*)0,&l_60,&l_72,(void*)0,&l_60,&l_72,&l_72,&l_72,&l_60},{&l_72,&l_72,(void*)0,&l_72,&l_60,&l_60,&l_60,&l_72,&l_72,&l_72},{&l_72,(void*)0,&l_72,&l_72,&l_72,&l_72,(void*)0,&l_72,&l_72,(void*)0},{&l_72,&l_60,&l_60,&l_60,(void*)0,&l_60,&l_72,(void*)0,&l_72,&l_72},{&l_60,(void*)0,&l_60,(void*)0,&l_60,(void*)0,&l_60,&l_60,&l_60,(void*)0},{&l_60,(void*)0,&l_60,(void*)0,&l_60,&l_60,&l_72,(void*)0,&l_72,&l_60}},{{(void*)0,&l_60,&l_72,&l_60,(void*)0,(void*)0,&l_60,&l_72,(void*)0,&l_72},{&l_72,&l_60,&l_72,&l_72,(void*)0,&l_60,(void*)0,&l_72,&l_72,&l_60},{&l_72,(void*)0,&l_72,&l_72,&l_60,&l_72,&l_72,&l_60,&l_60,&l_72},{&l_72,(void*)0,&l_72,&l_60,(void*)0,&l_72,&l_72,&l_60,&l_60,&l_60},{&l_72,(void*)0,&l_72,&l_60,&l_60,&l_60,&l_72,(void*)0,&l_72,&l_60},{&l_72,&l_72,&l_72,&l_60,(void*)0,(void*)0,(void*)0,&l_60,(void*)0,&l_72},{(void*)0,&l_60,(void*)0,&l_72,&l_72,&l_60,&l_60,&l_60,&l_60,&l_72}},{{&l_60,(void*)0,(void*)0,&l_60,&l_72,(void*)0,&l_72,&l_72,(void*)0,&l_72},{&l_60,&l_60,&l_72,&l_60,&l_72,&l_60,(void*)0,&l_72,(void*)0,&l_60},{(void*)0,&l_60,(void*)0,&l_60,(void*)0,&l_60,(void*)0,&l_60,&l_60,&l_72},{&l_60,&l_60,(void*)0,&l_72,(void*)0,&l_60,(void*)0,&l_60,(void*)0,(void*)0},{&l_72,&l_60,(void*)0,&l_60,&l_72,(void*)0,&l_60,&l_72,&l_72,&l_72},{&l_72,(void*)0,&l_60,&l_60,&l_60,(void*)0,&l_72,(void*)0,&l_60,&l_72},{(void*)0,&l_72,(void*)0,&l_60,&l_72,&l_72,&l_72,&l_60,&l_60,(void*)0}}};
        int32_t l_143 = 0x321B6B7DL;
        int32_t **l_167 = &l_93[1][3][8];
        int32_t ***l_166 = &l_167;
        int32_t ****l_165 = &l_166;
        int i, j, k;
        for (i = 0; i < 6; i++)
            l_91[i] = 0xB934CEB0L;
        for (i = 0; i < 10; i++)
            l_92[i] = 0x61L;
        if (l_63)
            break;
        l_72 = (((((safe_sub_func_uint8_t_u_u((safe_mul_func_uint8_t_u_u(l_63, (p_56 != (void*)0))), l_60)) <= l_68) != l_68) && 0x5493A50EB6BA8A7ELL) || (safe_sub_func_int8_t_s_s(l_60, (0x0F19L && l_71[5]))));
        l_72 = ((((safe_div_func_uint16_t_u_u((&l_72 != &l_72), (safe_mul_func_uint8_t_u_u((safe_sub_func_int64_t_s_s(((!(((safe_rshift_func_uint16_t_u_u(((safe_lshift_func_uint16_t_u_u((safe_div_func_int64_t_s_s(((safe_mod_func_uint64_t_u_u((&l_60 != &l_60), (~(&l_72 == (void*)0)))) >= (safe_rshift_func_int16_t_s_u(((l_68 ^ (l_68 > (l_71[3] > l_91[2]))) == l_91[4]), l_91[2]))), l_71[5])), 15)) <= l_60), 7)) & 0x640DD146F18880ABLL) && l_71[0])) & l_68), 0UL)), l_68)))) <= l_71[0]) <= l_92[8]) | l_68);
        if ((l_93[1][5][3] != l_93[0][2][5]))
        { /* block id: 21 */
            l_93[1][3][8] = &l_72;
        }
        else
        { /* block id: 23 */
            uint32_t l_112[8] = {1UL,1UL,0x717E41ABL,1UL,1UL,0x717E41ABL,1UL,1UL};
            uint8_t l_137 = 249UL;
            int32_t l_156 = 2L;
            float *l_159[1];
            int8_t l_160[2];
            int32_t **l_163 = &l_93[1][3][8];
            int32_t ***l_162 = &l_163;
            int32_t ****l_161 = &l_162;
            int i;
            for (i = 0; i < 1; i++)
                l_159[i] = (void*)0;
            for (i = 0; i < 2; i++)
                l_160[i] = 1L;
            for (l_63 = 0; (l_63 > 31); ++l_63)
            { /* block id: 26 */
                uint32_t l_96[6][10][3] = {{{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL}},{{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL}},{{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL}},{{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL}},{{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL}},{{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL},{0x115B503AL,0x115B503AL,0x115B503AL},{18446744073709551615UL,18446744073709551615UL,18446744073709551615UL}}};
                int32_t *l_97 = &l_72;
                int32_t **l_98 = &l_93[1][3][8];
                int32_t l_125 = 0xABA4BFF0L;
                int32_t **l_127 = &l_93[1][3][8];
                int32_t *** const l_153 = &l_98;
                int i, j, k;
                l_96[4][9][2] = (-9L);
                (*l_98) = l_97;
                for (l_68 = 0; (l_68 <= 2); l_68 += 1)
                { /* block id: 31 */
                    struct S0 l_126 = {459};
                    int32_t *****l_164[10] = {&l_161,&l_161,&l_161,(void*)0,&l_161,&l_161,&l_161,&l_161,(void*)0,&l_161};
                    struct S0 *l_168 = &l_126;
                    int i, j, k;
                    if ((l_91[l_68] < (safe_lshift_func_uint8_t_u_u(l_91[l_68], ((safe_mul_func_uint16_t_u_u((safe_add_func_uint16_t_u_u(((&l_93[l_68][(l_68 + 2)][(l_68 + 3)] != &l_93[0][1][5]) || (safe_mod_func_int8_t_s_s((safe_lshift_func_int16_t_s_s(((~(safe_rshift_func_int8_t_s_s(l_112[1], (~(safe_rshift_func_int8_t_s_u((safe_mul_func_uint8_t_u_u(((!(safe_div_func_uint64_t_u_u((l_112[1] != 0x9852L), (safe_sub_func_int8_t_s_s(l_112[7], (safe_sub_func_uint16_t_u_u(((0x41L <= l_112[1]) || 0L), 0L))))))) == 0x1A1E6DEAED54F57ELL), 0L)), (*l_97))))))) | l_91[l_68]), 13)), (-8L)))), l_72)), 1UL)) & l_125)))))
                    { /* block id: 32 */
                        return l_126;
                    }
                    else
                    { /* block id: 34 */
                        const int32_t *l_138 = &l_60;
                        float l_145 = (-0x8.8p+1);
                        float *l_144 = &l_145;
                        int32_t ***l_146 = &l_98;
                        (*l_144) = ((l_127 != (void*)0) == (safe_add_func_float_f_f(((((safe_sub_func_float_f_f((-(safe_mul_func_float_f_f((safe_add_func_float_f_f((l_137 > (((void*)0 != l_138) > ((((((((((safe_add_func_float_f_f((((+(+l_143)) <= (l_138 == (void*)0)) == 0xB.A5B5AAp-49), (*l_138))) > l_71[1]) >= l_137) != l_126.f0) <= 0x8.25D924p-83) <= (*l_138)) > l_60) <= 0x1.Ap+1) <= l_71[6]) > l_112[1]))), (*l_138))), (*l_97)))), l_71[2])) >= l_60) == 0x2.72C0FFp+71) >= (*l_138)), 0x8.D64987p-9)));
                        (*l_146) = p_56;
                        /* statement id: 36 */
                        //assert (l_98 == 0 || l_98 == &l_58 || l_98 == &l_806 || l_98 == &l_800 || l_98 == &l_5 || l_98 == &l_1243 || l_98 == &l_1217);
                        l_156 = (safe_mul_func_int16_t_s_s((safe_mul_func_uint8_t_u_u(((((((safe_mul_func_uint16_t_u_u((((l_71[5] ^ l_112[1]) ^ (-1L)) > (l_153 != (void*)0)), l_112[1])) && (p_56 == l_154)) < (*l_138)) && l_137) && (*l_138)) < (-1L)), 0x84L)), (*l_97)));
                    }
                    /* facts after branching */
                    //assert (l_98 == 0 || l_98 == &l_58 || l_98 == &l_806 || l_98 == &l_800 || l_98 == &l_5 || l_98 == &l_1243 || l_98 == &l_1217);
                    l_160[0] = (safe_add_func_float_f_f((-0x5.7p-1), (l_97 == l_159[0])));
                    l_165 = l_161;
                    /* statement id: 40 */
                    assert (l_165 == &l_162);
                    (*l_168) = l_126;
                }
                /* facts after for loop */
                //assert (l_98 == 0 || l_98 == &l_58 || (l_98 >= &l_93[0][0][0] && l_98 <= &l_93[2][6][9]) || l_98 == &l_806 || l_98 == &l_800 || l_98 == &l_5 || l_98 == &l_1243 || l_98 == &l_1217);
                for (l_143 = (-22); (l_143 < 25); l_143++)
                { /* block id: 45 */
                    if ((*l_97))
                    { /* block id: 46 */
                        struct S0 l_171 = {-7685};
                        struct S0 *l_172 = &l_171;
                        int32_t *l_173 = &l_72;
                        (*l_172) = l_171;
                        (**l_162) = l_173;
                    }
                    else
                    { /* block id: 49 */
                        int8_t l_174 = 2L;
                        int32_t l_175 = 0x4843688BL;
                        l_175 = l_174;
                        (***l_161) = (void*)0;
                    }
                }
            }
            /* facts after for loop */
            assert (l_165 == &l_162 || l_165 == &l_166);
        }
        /* facts after branching */
        //assert (l_165 == dangling || l_165 == &l_166);
    }
    l_183 = (safe_sub_func_uint16_t_u_u((l_178 == 6UL), (l_179 == &l_180)));
    if ((safe_rshift_func_int16_t_s_u((l_186 & (safe_sub_func_int8_t_s_s(((safe_rshift_func_uint16_t_u_s(l_191, l_192)) > l_193[0][5]), (safe_unary_minus_func_int32_t_s(l_195))))), 8)))
    { /* block id: 58 */
        int32_t l_197 = (-1L);
        int32_t ****l_201 = &l_181;
        struct S0 **l_242 = &l_228;
        const struct S0 *l_312 = &l_229;
        float l_315 = 0x1.3p+1;
        float *l_314 = &l_315;
        float **l_313[6][10][4] = {{{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,(void*)0},{&l_314,(void*)0,(void*)0,(void*)0},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314}},{{(void*)0,&l_314,&l_314,&l_314},{&l_314,(void*)0,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{(void*)0,&l_314,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,(void*)0},{&l_314,&l_314,&l_314,(void*)0}},{{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,(void*)0,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314}},{{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314},{(void*)0,&l_314,&l_314,&l_314},{&l_314,(void*)0,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314}},{{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{(void*)0,&l_314,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,(void*)0},{&l_314,&l_314,&l_314,(void*)0},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314}},{{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314},{&l_314,&l_314,(void*)0,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,(void*)0,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,&l_314,&l_314},{&l_314,&l_314,(void*)0,&l_314}}};
        int i, j, k;
        l_198 = (!(0x72L <= l_197));
        for (l_197 = 0; (l_197 <= 1); l_197 += 1)
        { /* block id: 62 */
            struct S0 **l_230 = &l_228;
            int32_t l_304 = 1L;
            int i;
            if ((1L | (0xDA69L ^ (0x4D08L != ((((void*)0 == l_201) & ((safe_sub_func_uint8_t_u_u(0xBBL, 0x4FL)) != ((l_71[(l_197 + 5)] != l_71[(l_197 + 5)]) & 0xD9L))) && l_71[(l_197 + 5)])))))
            { /* block id: 63 */
                int32_t l_208 = 0L;
                struct S0 ***l_239 = (void*)0;
                int32_t *****l_252[4][3] = {{&l_201,&l_201,&l_201},{&l_201,&l_201,&l_201},{&l_201,&l_201,&l_201},{&l_201,&l_201,&l_201}};
                struct S0 l_260 = {6288};
                int i, j;
                if ((((safe_mod_func_int32_t_s_s((safe_mul_func_uint8_t_u_u((l_208 > ((((void*)0 == l_155[2]) == (safe_add_func_int8_t_s_s(l_197, (((((safe_mul_func_int16_t_s_s((safe_add_func_uint32_t_u_u(((safe_add_func_uint8_t_u_u(l_208, (((safe_sub_func_uint32_t_u_u((safe_mul_func_int8_t_s_s((safe_rshift_func_int16_t_s_s(l_71[(l_197 + 5)], 13)), ((l_71[(l_197 + 5)] == (((((safe_div_func_int8_t_s_s((l_197 && (safe_div_func_int16_t_s_s(l_71[(l_197 + 5)], 0x86E0L))), l_208)) & l_71[(l_197 + 5)]) > l_71[(l_197 + 5)]) == (-4L)) ^ l_208)) == 0UL))), 0x0B3D7231L)) || l_208) != l_197))) ^ l_208), 0x38ED05F3L)), l_71[(l_197 + 5)])) ^ l_71[(l_197 + 5)]) || l_71[(l_197 + 5)]) || l_71[(l_197 + 5)]) >= l_71[(l_197 + 5)])))) | l_208)), 0L)), l_208)) || l_197) || 0x5242L))
                { /* block id: 64 */
                    int32_t **l_232[1][2][10] = {{{&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0]},{&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0],&l_155[0]}}};
                    float l_253[2];
                    int i, j, k;
                    for (i = 0; i < 2; i++)
                        l_253[i] = 0x1.Dp+1;
                    for (l_72 = 0; (l_72 <= 6); l_72 += 1)
                    { /* block id: 67 */
                        struct S0 ***l_231[3][2] = {{&l_227,&l_227},{&l_227,&l_227},{&l_227,&l_227}};
                        int i, j;
                        l_230 = l_227;
                        l_227 = (void*)0;
                        /* statement id: 69 */
                        assert (l_227 == 0);
                        (**l_201) = l_232[0][1][1];
                    }
                    /* facts after for loop */
                    assert (l_182 == 0 || (l_182 >= &l_155[0] && l_182 <= &l_155[2]));
                    assert (l_227 == 0 || l_227 == &l_228);
                    assert (l_230 == 0 || l_230 == &l_228);
                    if (((0L && (safe_sub_func_int64_t_s_s(0L, (((safe_div_func_int32_t_s_s((((l_197 > (8L < (3L == (safe_lshift_func_int8_t_s_u((&l_227 == l_239), 1))))) == (safe_rshift_func_uint8_t_u_u((0x95C0E044L < (((void*)0 != l_242) | 0xDEA13161F875ADBALL)), l_71[(l_197 + 5)]))) || l_71[(l_197 + 5)]), l_208)) || l_208) < 0x0843L)))) || l_208))
                    { /* block id: 72 */
                        struct S0 l_243 = {-5688};
                        return l_243;
                    }
                    else
                    { /* block id: 74 */
                        uint64_t l_254 = 0x53A13BA321D59750LL;
                        float *l_259 = &l_253[0];
                        (*l_259) = ((safe_sub_func_float_f_f((safe_add_func_float_f_f(((safe_mul_func_float_f_f((safe_add_func_float_f_f((0xD.36DCFDp-85 > ((void*)0 != l_252[2][0])), l_253[0])), (-0x3.Cp-1))) < (l_71[(l_197 + 5)] != l_254)), ((safe_sub_func_float_f_f((safe_mul_func_float_f_f(l_71[(l_197 + 5)], (p_56 == p_56))), l_254)) != l_254))), l_71[(l_197 + 5)])) > (-0x2.Fp-1));
                        (*l_259) = l_254;
                        return l_260;
                    }
                }
                else
                { /* block id: 79 */
                    struct S0 l_262 = {-6517};
                    if (l_71[(l_197 + 5)])
                    { /* block id: 80 */
                        struct S0 l_261[4] = {{5173},{5173},{5173},{5173}};
                        int i;
                        return l_261[3];
                    }
                    else
                    { /* block id: 82 */
                        return l_262;
                    }
                }
            }
            else
            { /* block id: 86 */
                struct S0 l_263 = {-6193};
                for (l_178 = 0; (l_178 <= 1); l_178 += 1)
                { /* block id: 89 */
                    return l_263;
                }
                if ((safe_sub_func_int16_t_s_s((safe_mod_func_uint64_t_u_u(0xF7C5DDF7B942CA0ALL, ((l_71[(l_197 + 5)] < (safe_sub_func_int64_t_s_s((safe_sub_func_int32_t_s_s((-5L), (safe_add_func_uint64_t_u_u((((safe_mul_func_int16_t_s_s(0x27A1L, (safe_lshift_func_int16_t_s_s((safe_sub_func_int8_t_s_s((-1L), (safe_add_func_int32_t_s_s(((safe_mul_func_int8_t_s_s((l_263.f0 || (0x2AL != (safe_mul_func_int8_t_s_s(((safe_add_func_uint8_t_u_u((l_71[(l_197 + 5)] && ((((&l_180 == &l_201) > l_263.f0) & l_71[(l_197 + 5)]) == l_263.f0)), 0xD4L)) && l_263.f0), l_263.f0)))), l_263.f0)) || l_71[(l_197 + 5)]), l_263.f0)))), 7)))) ^ l_71[(l_197 + 5)]) || 0xFBA5L), 9UL)))), l_263.f0))) ^ 5UL))), (-1L))))
                { /* block id: 92 */
                    uint16_t l_300 = 0x9EAFL;
                    int32_t l_309 = 0x1A918C55L;
                    if (l_263.f0)
                    { /* block id: 93 */
                        uint32_t l_303 = 4294967295UL;
                        float *l_306 = (void*)0;
                        float l_308 = 0x8.53CD41p+96;
                        float *l_307[4] = {&l_308,&l_308,&l_308,&l_308};
                        int i;
                        l_304 = (!(safe_mul_func_uint8_t_u_u((safe_mod_func_uint32_t_u_u((safe_div_func_int8_t_s_s((safe_div_func_int16_t_s_s(l_71[(l_197 + 5)], l_263.f0)), (((l_71[(l_197 + 5)] ^ 0xC713L) ^ (safe_unary_minus_func_uint64_t_u((safe_lshift_func_uint16_t_u_s(l_263.f0, (0xDC0335DBL > (0x95L && l_300))))))) && (safe_add_func_uint32_t_u_u((l_303 <= l_263.f0), l_263.f0))))), l_303)), 0x93L)));
                        l_309 = (-l_300);
                    }
                    else
                    { /* block id: 96 */
                        const struct S0 *l_310[10] = {(void*)0,&l_263,(void*)0,(void*)0,&l_263,(void*)0,&l_263,(void*)0,(void*)0,&l_263};
                        const struct S0 **l_311[6][4] = {{&l_310[3],&l_310[4],&l_310[1],&l_310[1]},{&l_310[2],&l_310[2],&l_310[3],&l_310[1]},{&l_310[2],&l_310[4],&l_310[2],&l_310[3]},{&l_310[2],&l_310[3],&l_310[3],&l_310[2]},{&l_310[2],&l_310[3],&l_310[1],&l_310[3]},{&l_310[3],&l_310[4],&l_310[1],&l_310[1]}};
                        float ***l_316 = &l_313[3][2][2];
                        int i, j;
                        l_312 = l_310[1];
                        /* statement id: 97 */
                        assert (l_312 == &l_263 || l_312 == 0 || l_312 == &l_229);
                        if (l_304)
                            continue;
                        //assert (l_312 == dangling || l_312 == 0 || l_312 == &l_229);
                        (*l_316) = l_313[4][7][1];
                        (**l_230) = (**l_230);
                    }
                    /* facts after branching */
                    //assert (l_312 == &l_263 || l_312 == 0 || l_312 == &l_229 || l_312 == dangling);
                }
                else
                { /* block id: 102 */
                    struct S0 l_317 = {6136};
                    return l_317;
                }
                /* facts after branching */
                //assert (l_312 == &l_263 || l_312 == 0 || l_312 == &l_229 || l_312 == dangling);
            }
            for (l_178 = 0; (l_178 <= 1); l_178 += 1)
            { /* block id: 108 */
                struct S0 l_318 = {-5272};
                (****l_179) = (*l_154);
                return l_318;
            }
        }
        /* facts after for loop */
        //assert (l_312 == dangling || l_312 == 0 || l_312 == &l_229);
        for (l_192 = 1; (l_192 < 27); l_192 = safe_add_func_uint16_t_u_u(l_192, 8))
        { /* block id: 115 */
            uint32_t l_321 = 18446744073709551615UL;
            struct S0 l_340 = {-5936};
            struct S0 * const * const l_349 = &l_228;
            struct S0 * const * const *l_348 = &l_349;
            int32_t *l_370 = &l_72;
            if (l_321)
            { /* block id: 116 */
                const int8_t l_332 = 0L;
                l_313[4][7][1] = &l_314;
                if (l_321)
                    continue;
                for (l_195 = (-6); (l_195 > 27); l_195 = safe_add_func_int16_t_s_s(l_195, 1))
                { /* block id: 121 */
                    float l_327[2];
                    int32_t ** const l_335 = &l_155[2];
                    int32_t l_336 = 0x0006055EL;
                    int i;
                    for (i = 0; i < 2; i++)
                        l_327[i] = 0xE.C59C9Fp+75;
                    (*l_314) = (safe_div_func_float_f_f((((+(l_327[1] <= (-(-((0x5.Cp+1 < (((((((void*)0 != (*l_180)) != (safe_sub_func_float_f_f(0x5.3p+1, l_332))) >= 0x0.9p+1) <= (safe_div_func_float_f_f((l_335 == p_56), 0x6.769757p+61))) != l_197) == l_321)) >= l_321))))) == l_332) <= l_336), l_197));
                    if (l_332)
                        continue;
                    (*l_314) = 0x2.CE6465p+7;
                    for (l_183 = 0; (l_183 >= 51); ++l_183)
                    { /* block id: 127 */
                        struct S0 l_339 = {-2551};
                        return l_339;
                    }
                }
            }
            else
            { /* block id: 131 */
                return l_340;
            }
        }
    }
    else
    { /* block id: 164 */
        float *l_396 = (void*)0;
        float **l_395[10] = {&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396,&l_396};
        float ***l_394 = &l_395[2];
        uint32_t l_400 = 1UL;
        int32_t ** const ***l_408 = (void*)0;
        int32_t l_493 = 0x90B5BDC0L;
        struct S0 ** const *l_519 = &l_227;
        int i;
        for (l_192 = 0; (l_192 >= 6); l_192 = safe_add_func_int32_t_s_s(l_192, 1))
        { /* block id: 167 */
            float ****l_397 = &l_394;
            int32_t l_433 = (-1L);
            int32_t ****l_452 = &l_181;
            int32_t *****l_451 = &l_452;
            uint16_t l_460 = 3UL;
            int16_t l_461[7] = {0x9B04L,0x9B04L,(-1L),0x9B04L,0x9B04L,(-1L),0x9B04L};
            uint16_t l_473 = 2UL;
            struct S0 *l_521 = &l_229;
            int32_t l_526 = 1L;
            struct S0 ****l_547 = (void*)0;
            struct S0 *****l_546[10][3] = {{&l_547,&l_547,&l_547},{(void*)0,(void*)0,(void*)0},{&l_547,&l_547,&l_547},{&l_547,(void*)0,&l_547},{&l_547,&l_547,&l_547},{&l_547,&l_547,&l_547},{&l_547,&l_547,&l_547},{&l_547,&l_547,(void*)0},{&l_547,&l_547,&l_547},{&l_547,&l_547,&l_547}};
            int i, j;
            (*l_397) = l_394;
            for (l_72 = 13; (l_72 != 0); --l_72)
            { /* block id: 171 */
                uint32_t l_409[9] = {4UL,2UL,4UL,2UL,4UL,2UL,4UL,2UL,4UL};
                uint8_t l_459 = 0xABL;
                struct S0 l_496 = {6575};
                const uint64_t l_499 = 0x90AEB04C0E27DA52LL;
                int32_t **l_502 = &l_462[4];
                struct S0 ***l_520 = &l_227;
                int i;
                if (l_400)
                    break;
                l_434 = (safe_sub_func_float_f_f(((-(safe_div_func_float_f_f(((void*)0 != (*l_227)), (safe_add_func_float_f_f((l_408 == &l_180), (l_409[5] > (safe_add_func_float_f_f((safe_add_func_float_f_f((0x0.3p+1 >= (safe_sub_func_float_f_f((safe_sub_func_float_f_f((safe_add_func_float_f_f((safe_div_func_float_f_f(((+(safe_sub_func_float_f_f((safe_sub_func_float_f_f((0xB.25053Cp+67 != ((safe_sub_func_float_f_f((l_409[5] > ((safe_sub_func_float_f_f((((((safe_mul_func_float_f_f(l_433, (-0x1.Ep-1))) < l_400) > 0x1.3p+1) <= l_400) < 0xB.6FA15Bp-27), l_433)) < l_400)), 0xB.B51DFCp+91)) >= l_433)), 0xB.04A5D0p+11)), l_433))) < l_433), l_400)), l_409[5])), 0x2.3486B5p-40)), (-0x5.Ep-1)))), 0xB.783FFCp+66)), l_433)))))))) == 0x2.73A780p-84), 0xD.E7D4B7p-93));
                if (((((safe_sub_func_int16_t_s_s((safe_mul_func_int8_t_s_s((safe_sub_func_int32_t_s_s(l_409[6], ((safe_mul_func_int8_t_s_s(((safe_div_func_int64_t_s_s((safe_mul_func_uint16_t_u_u(l_400, l_433)), (safe_add_func_int64_t_s_s(l_400, (((((safe_sub_func_int32_t_s_s((l_400 >= (l_451 != &l_452)), (safe_rshift_func_uint8_t_u_s((safe_div_func_int8_t_s_s((4294967288UL == (safe_mul_func_uint16_t_u_u((((-1L) <= l_409[7]) ^ l_409[5]), l_459))), l_459)), 7)))) && 0x2EA7C4602C31B24DLL) | l_433) || l_460) ^ l_459))))) || l_409[6]), l_460)) ^ l_400))), l_400)), l_461[4])) | l_409[5]) <= l_433) | l_409[5]))
                { /* block id: 174 */
                    const float l_472 = 0x0.Cp-1;
                    int32_t l_476[6] = {0xF0C64A28L,0xF0C64A28L,0xF0C64A28L,0xF0C64A28L,0xF0C64A28L,0xF0C64A28L};
                    int8_t l_491[4][8] = {{8L,0x57L,0x57L,8L,8L,0x57L,0x57L,8L},{8L,0x57L,0x57L,8L,8L,0x57L,0x57L,8L},{8L,0x57L,0x57L,8L,8L,0x57L,0x57L,8L},{8L,0x57L,0x57L,8L,8L,0x57L,0x57L,8L}};
                    uint64_t l_492 = 0x23C52B2F41BC76C5LL;
                    int i, j;
                    if (l_409[5])
                    { /* block id: 175 */
                        int32_t * const l_463[8][10][3] = {{{&l_433,&l_433,&l_433},{&l_433,&l_433,&l_60},{&l_60,&l_433,&l_72},{&l_72,(void*)0,&l_72},{&l_72,&l_72,(void*)0},{(void*)0,(void*)0,&l_72},{&l_60,&l_60,&l_60},{&l_60,(void*)0,&l_72},{&l_72,&l_60,&l_60},{(void*)0,(void*)0,&l_72}},{{&l_433,(void*)0,(void*)0},{&l_72,&l_72,&l_72},{&l_433,&l_433,&l_72},{&l_72,&l_72,&l_60},{&l_60,(void*)0,&l_433},{&l_72,(void*)0,&l_433},{&l_433,&l_60,&l_72},{&l_72,(void*)0,(void*)0},{&l_433,&l_60,&l_433},{(void*)0,&l_433,&l_72}},{{&l_72,&l_60,&l_60},{&l_60,&l_433,&l_433},{&l_60,&l_60,&l_60},{(void*)0,(void*)0,(void*)0},{&l_72,&l_60,&l_433},{&l_72,(void*)0,&l_433},{&l_60,(void*)0,&l_60},{&l_433,&l_72,&l_433},{&l_433,&l_433,&l_433},{&l_433,&l_72,(void*)0}},{{(void*)0,(void*)0,&l_60},{&l_72,(void*)0,&l_433},{(void*)0,&l_60,&l_60},{(void*)0,(void*)0,&l_72},{(void*)0,&l_60,&l_433},{&l_72,(void*)0,(void*)0},{(void*)0,&l_72,&l_72},{&l_433,(void*)0,&l_433},{&l_433,&l_433,&l_433},{&l_433,&l_433,&l_60}},{{&l_60,&l_433,&l_72},{&l_72,(void*)0,&l_72},{&l_72,&l_72,(void*)0},{(void*)0,(void*)0,&l_72},{&l_60,&l_60,&l_60},{&l_60,(void*)0,&l_72},{&l_72,&l_60,&l_60},{(void*)0,(void*)0,&l_72},{&l_433,(void*)0,(void*)0},{&l_72,&l_72,&l_72}},{{&l_433,&l_433,&l_72},{&l_72,&l_72,&l_60},{&l_60,(void*)0,&l_433},{&l_72,(void*)0,&l_433},{&l_433,&l_60,&l_72},{&l_72,(void*)0,(void*)0},{&l_433,&l_60,&l_433},{(void*)0,&l_60,&l_60},{&l_60,&l_60,&l_72},{&l_433,&l_60,(void*)0}},{{&l_60,(void*)0,&l_433},{&l_60,&l_60,&l_72},{&l_60,&l_60,&l_433},{&l_60,(void*)0,&l_72},{&l_60,&l_433,&l_60},{&l_72,&l_60,&l_72},{&l_72,&l_433,&l_433},{&l_60,&l_72,&l_72},{(void*)0,(void*)0,&l_433},{&l_433,(void*)0,(void*)0}},{{(void*)0,&l_60,&l_72},{&l_72,&l_433,&l_60},{(void*)0,&l_433,&l_60},{&l_433,&l_60,(void*)0},{(void*)0,&l_60,&l_72},{&l_60,&l_72,&l_72},{&l_72,&l_60,&l_60},{&l_72,&l_72,&l_433},{&l_60,&l_60,&l_433},{&l_60,&l_72,&l_433}}};
                        const float *l_475 = &l_472;
                        const float **l_474 = &l_475;
                        int i, j, k;
                        l_493 = ((l_462[1] != l_463[2][9][2]) || (safe_rshift_func_uint8_t_u_u(((safe_rshift_func_uint16_t_u_u((safe_add_func_uint16_t_u_u((safe_sub_func_uint64_t_u_u(0xF983E7520BA3940CLL, l_473)), ((void*)0 != l_474))), l_476[1])) > (safe_div_func_int8_t_s_s((safe_add_func_int64_t_s_s(((safe_rshift_func_uint16_t_u_u(((safe_add_func_uint8_t_u_u((((safe_mul_func_int8_t_s_s((safe_add_func_uint64_t_u_u(((safe_div_func_int16_t_s_s((1L ^ l_476[1]), 0x3732L)) && l_409[6]), l_400)), l_491[3][2])) < l_491[3][2]) > l_491[0][4]), 2UL)) > l_476[1]), l_492)) | l_409[2]), 18446744073709551615UL)), l_409[1]))), 0)));
                        if (l_476[1])
                            break;
                        (****l_179) = (void*)0;
                    }
                    else
                    { /* block id: 179 */
                        struct S0 l_494 = {296};
                        int32_t *l_495 = &l_476[1];
                        (**l_227) = l_494;
                        (****l_179) = l_495;
                        /* statement id: 181 */
                        //assert ((l_155[0] >= &l_476[0] && l_155[0] <= &l_476[5]) || l_155[0] == 0);
                        (**l_452) = func_17(l_494);
                        /* statement id: 182 */
                        assert (l_182 == 0);
                        return l_496;
                    }
                    l_433 = 0x3ABD6275L;
                    if ((safe_sub_func_int8_t_s_s(l_499, ((safe_sub_func_int32_t_s_s(l_491[3][3], (0x81F6AEB963E05A45LL != 3L))) > (((((void*)0 != l_502) && (l_476[1] & (((void*)0 == &l_180) > (**l_502)))) ^ 0L) & 0UL)))))
                    { /* block id: 186 */
                        int32_t l_516[6];
                        int i;
                        for (i = 0; i < 6; i++)
                            l_516[i] = 0L;
                        if (l_400)
                            break;
                        if ((**l_502))
                            continue;
                        l_476[1] = (safe_sub_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f(((safe_mul_func_float_f_f((safe_mul_func_float_f_f((!l_516[4]), l_516[4])), ((0x3.1p-1 == ((safe_div_func_float_f_f((l_519 != l_520), l_461[6])) <= (**l_502))) <= l_476[1]))) == (0x1.Cp-1 <= (-0x9.9p+1))), 0x3.ED7927p+42)), 0x8.1CF854p-49)), 0x3.Dp+1));
                    }
                    else
                    { /* block id: 190 */
                        (*l_154) = (****l_179);
                        (*l_227) = l_521;
                        l_476[1] = ((**l_502) <= ((void*)0 == (*l_227)));
                        l_476[3] = (safe_rshift_func_uint8_t_u_s((safe_mul_func_uint16_t_u_u(l_526, l_491[3][2])), 4));
                    }
                }
                else
                { /* block id: 196 */
                    int16_t l_530 = 0x1212L;
                    struct S0 ***l_540 = (void*)0;
                    for (l_195 = (-11); (l_195 != 21); l_195++)
                    { /* block id: 199 */
                        int32_t *** const **l_529 = &l_180;
                        int32_t l_541 = 0L;
                        l_529 = &l_180;
                        l_541 = (((-0x9.1p+1) >= l_530) <= (safe_mul_func_float_f_f(((safe_sub_func_float_f_f((**l_502), (safe_sub_func_float_f_f(((**l_529) != &p_56), 0xC.E0851Ep+80)))) == 0x6.51804Dp+89), (((+(((safe_mul_func_float_f_f(((void*)0 == l_540), l_530)) != l_530) > 0x6.471121p-92)) != 0x1.Ap-1) > (**l_502)))));
                    }
                    if (l_186)
                        goto lbl_542;
                    for (l_198 = 7; (l_198 <= 5); l_198 = safe_sub_func_uint32_t_u_u(l_198, 2))
                    { /* block id: 206 */
                        float l_545 = 0x7.E9AED6p+97;
                        struct S0 *****l_548 = (void*)0;
                        l_493 = l_493;
                        if (l_530)
                            break;
                        l_548 = l_546[2][1];
                        /* statement id: 209 */
                        assert (l_548 == 0 || l_548 == &l_547);
                    }
                }
            }
        }
    }
    return l_549;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 334
   depth: 1, occurrence: 53
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 116
breakdown:
   indirect level: 0, occurrence: 53
   indirect level: 1, occurrence: 13
   indirect level: 2, occurrence: 20
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 14
XXX full-bitfields structs in the program: 53
breakdown:
   indirect level: 0, occurrence: 53
XXX times a bitfields struct's address is taken: 80
XXX times a bitfields struct on LHS: 20
XXX times a bitfields struct on RHS: 66
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 45

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 367
   depth: 2, occurrence: 71
   depth: 3, occurrence: 6
   depth: 4, occurrence: 9
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 9, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 5
   depth: 13, occurrence: 3
   depth: 14, occurrence: 3
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 2
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 1
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 3
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 348

XXX times a variable address is taken: 1042
XXX times a pointer is dereferenced on RHS: 190
breakdown:
   depth: 1, occurrence: 134
   depth: 2, occurrence: 35
   depth: 3, occurrence: 10
   depth: 4, occurrence: 9
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 146
breakdown:
   depth: 1, occurrence: 97
   depth: 2, occurrence: 26
   depth: 3, occurrence: 16
   depth: 4, occurrence: 7
XXX times a pointer is compared with null: 87
XXX times a pointer is compared with address of another variable: 20
XXX times a pointer is compared with another pointer: 35
XXX times a pointer is qualified to be dereferenced: 2142

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1223
   level: 2, occurrence: 477
   level: 3, occurrence: 126
   level: 4, occurrence: 227
   level: 5, occurrence: 73
XXX number of pointers point to pointers: 230
XXX number of pointers point to scalars: 86
XXX number of pointers point to structs: 32
XXX percent of pointers has null in alias set: 36.5
XXX average alias set size: 1.39

XXX times a non-volatile is read: 1608
XXX times a non-volatile is write: 571
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 6
XXX backward jumps: 7

XXX stmts: 325
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 34
   depth: 2, occurrence: 32
   depth: 3, occurrence: 56
   depth: 4, occurrence: 63
   depth: 5, occurrence: 109

XXX percentage a fresh-made variable is used: 16.8
XXX percentage an existing variable is used: 83.2
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

