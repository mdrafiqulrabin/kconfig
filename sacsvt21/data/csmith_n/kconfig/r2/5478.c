/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2037362504
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint16_t  func_1(void);
static uint16_t  func_6(int32_t * const  p_7, int32_t * p_8, int32_t  p_9, int32_t * p_10);
static int32_t * func_13(int32_t * p_14, uint32_t  p_15, uint32_t  p_16);
static int32_t * func_17(uint32_t  p_18, uint16_t  p_19, uint16_t  p_20);
static int32_t  func_33(int32_t  p_34, uint16_t  p_35, int32_t ** p_36);
static int32_t ** func_38(int8_t  p_39);
static int8_t  func_40(const int8_t  p_41, int32_t  p_42, int32_t * const * p_43, int16_t  p_44, uint32_t  p_45);
static uint32_t  func_46(uint32_t  p_47, int8_t  p_48, int32_t * p_49, int16_t  p_50);
static uint16_t  func_57(int32_t ** p_58, int32_t  p_59);
static int32_t * const  func_60(int32_t  p_61, int16_t  p_62, uint16_t  p_63, const int32_t * p_64, int32_t  p_65);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_1(void)
{ /* block id: 0 */
    int32_t l_3 = (-1L);
    int32_t *l_2 = &l_3;
    uint32_t l_26 = 8UL;
    int16_t l_27 = 1L;
    int32_t **l_752 = (void*)0;
    int32_t **l_753 = &l_2;
    int8_t l_754 = 0xFCL;
    (*l_2) = 0xFF0EA75CL;
    (*l_2) = (safe_sub_func_uint32_t_u_u((((*l_2) < ((*l_2) <= func_6(&l_3, &l_3, (safe_rshift_func_int16_t_s_u(((*l_2) >= (&l_3 == &l_3)), (*l_2))), func_13(func_17((~(safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_u(((0xB5E4L > 0x61BEL) < (*l_2)), l_26)), l_27))), (*l_2), (*l_2)), (*l_2), (*l_2))))) & (*l_2)), (*l_2)));
    (*l_753) = &l_3;
    return l_754;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_6(int32_t * const  p_7, int32_t * p_8, int32_t  p_9, int32_t * p_10)
{ /* block id: 286 */
    uint32_t l_726 = 0x737B94CFL;
    int32_t l_728 = 0x09B21890L;
    int32_t *l_727 = &l_728;
    (*l_727) = (safe_add_func_uint16_t_u_u(0UL, l_726));
lbl_751:
    p_8 = p_10;
    /* statement id: 288 */
    assert (p_8 == 0);
    for (l_726 = (-8); (l_726 != 30); ++l_726)
    { /* block id: 291 */
        uint16_t l_741 = 0x1B05L;
        int32_t *l_749 = (void*)0;
        int32_t **l_750 = &l_749;
        p_10 = l_749;
        (*l_750) = (void*)0;
        if (l_726)
            goto lbl_751;
    }
    return p_9;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_13(int32_t * p_14, uint32_t  p_15, uint32_t  p_16)
{ /* block id: 276 */
    int32_t l_694 = 0xB184AA89L;
    int32_t *l_702 = &l_694;
    int32_t **l_701 = &l_702;
    int32_t ***l_700 = &l_701;
    int32_t ****l_699 = &l_700;
    int32_t l_703 = 0x356B8C0FL;
    int32_t **l_704 = &l_702;
    int32_t *l_723 = &l_694;
    (*l_704) = func_60(((safe_rshift_func_uint16_t_u_u(((((((0L <= (((safe_lshift_func_uint16_t_u_u(l_694, 9)) == 0x3544L) || ((safe_rshift_func_int16_t_s_s(((-2L) < p_16), 7)) < p_15))) > ((l_694 != (l_694 ^ (safe_rshift_func_uint16_t_u_u((l_699 != (void*)0), p_15)))) && p_16)) | 0UL) & p_15) >= l_703) < 9L), (****l_699))) < (*l_702)), (****l_699), (*l_702), (*l_701), p_15);
    /* statement id: 277 */
    assert (l_702 == 0);
    if ((((!(~(~p_15))) <= ((-1L) | (1L != (p_16 || (safe_lshift_func_uint16_t_u_u((((0x0B44L && (~(((safe_add_func_int16_t_s_s((((**l_699) != (void*)0) & ((safe_rshift_func_uint16_t_u_u(((void*)0 != (*l_699)), p_16)) >= p_15)), p_16)) ^ 0xB486L) >= p_15))) || 0x1B23FF94L) || 0xF12CA690L), 0)))))) <= p_15))
    { /* block id: 278 */
        (**l_700) = p_14;
    }
    else
    { /* block id: 280 */
        uint16_t l_719 = 0UL;
        int32_t l_722 = 9L;
        l_722 = (safe_sub_func_int32_t_s_s((((((p_16 <= 0x626DAD73L) && ((((p_15 && (0L > (p_15 || (safe_mod_func_int32_t_s_s((l_719 >= (safe_rshift_func_int16_t_s_u(((p_15 & p_15) ^ p_15), 4))), l_719))))) != p_15) ^ p_16) <= p_15)) >= 0xC7B11B85L) > l_719) ^ 0xBF4323FAL), l_719));
    }
    (*l_704) = (*l_701);
    (*l_723) = (-1L);
    return p_14;
    /* statement id: 285 */
    //assert (func_13_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_17(uint32_t  p_18, uint16_t  p_19, uint16_t  p_20)
{ /* block id: 2 */
    int32_t l_30 = 0x374FD522L;
    int32_t *l_29 = &l_30;
    int32_t **l_28 = &l_29;
    int32_t ****l_231 = (void*)0;
    int32_t *****l_230 = &l_231;
    int32_t l_234 = 0xB5B7701AL;
    int16_t l_309 = (-1L);
    int32_t *l_321 = &l_234;
    int32_t *l_349 = &l_30;
    int32_t *l_352 = &l_234;
    int32_t *l_353 = &l_234;
    int32_t *l_354 = &l_234;
    int32_t *l_356 = &l_30;
    int32_t *l_416 = &l_30;
    int32_t *l_421 = (void*)0;
    int32_t *l_462 = &l_30;
    int32_t *l_494 = &l_30;
    int32_t *l_495 = &l_30;
    int32_t *l_497 = &l_234;
    int32_t *l_499 = &l_234;
    int32_t *l_500 = &l_30;
    int32_t ***l_530 = &l_28;
    int16_t l_550 = (-5L);
    uint32_t l_568 = 0UL;
    int32_t ***l_572 = &l_28;
    int32_t *****l_591 = &l_231;
    int32_t *l_614 = (void*)0;
    int32_t *** const * const l_616 = &l_572;
    int32_t *** const * const *l_615 = &l_616;
    int32_t *l_631 = &l_30;
    int32_t *l_637 = &l_30;
    int32_t *l_638 = (void*)0;
    int32_t *l_687 = (void*)0;
    (*l_28) = (void*)0;
    /* statement id: 3 */
    assert (l_29 == 0);
    return l_687;
    /* statement id: 275 */
    //assert (func_17_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_33(int32_t  p_34, uint16_t  p_35, int32_t ** p_36)
{ /* block id: 73 */
    int8_t l_198 = 0x2CL;
    int32_t l_202 = 0x144B6F7AL;
    int32_t *l_201 = &l_202;
    (*l_201) = (safe_sub_func_int32_t_s_s(l_198, (safe_mod_func_int16_t_s_s((1L < (((void*)0 == p_36) != 0xBBAD3B4EL)), p_35))));
    (*l_201) = (safe_mod_func_uint16_t_u_u(p_34, (*l_201)));
    (*l_201) = (p_36 == p_36);
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_38(int8_t  p_39)
{ /* block id: 52 */
    int32_t l_136 = 1L;
    int32_t *l_135 = &l_136;
    int32_t **l_134 = &l_135;
    int32_t ***l_133 = &l_134;
    int32_t ****l_132 = &l_133;
    uint32_t l_183 = 4294967286UL;
    int32_t ***l_187 = &l_134;
    int32_t **l_194 = &l_135;
    int32_t **l_195 = (void*)0;
    if ((p_39 ^ (l_132 != (void*)0)))
    { /* block id: 53 */
        uint32_t l_139 = 0xC5D866FAL;
        int32_t **l_184 = &l_135;
        if ((**l_134))
        { /* block id: 54 */
            uint32_t l_137 = 0x93E3F5A7L;
            int32_t *****l_138 = &l_132;
            l_137 = 0L;
            (*l_138) = &l_133;
            (*l_134) = (****l_138);
            (****l_132) = ((((p_39 != (**l_134)) > (((l_139 && (safe_mod_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(((!p_39) ^ (l_138 == &l_132)), ((((safe_mod_func_int16_t_s_s((((((void*)0 == &l_133) > (safe_rshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((((((safe_sub_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(p_39, 15)), 65532UL)) != l_139) ^ (**l_134)) <= p_39) ^ p_39), p_39)), p_39))) ^ 65535UL) && p_39), (*****l_138))) > p_39) == l_139) ^ p_39))), (*l_135)))) <= l_139) && l_139)) & 0x3ECDL) != p_39);
        }
        else
        { /* block id: 59 */
            int32_t *l_155 = &l_136;
            (***l_132) = l_155;
        }
        (*l_135) = (!(*l_135));
        (*l_184) = func_60(l_139, (&l_132 != (void*)0), p_39, (*l_134), (((((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((safe_mod_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_s((safe_mod_func_uint32_t_u_u((safe_sub_func_int16_t_s_s(((0UL & (****l_132)) > (safe_add_func_int16_t_s_s(((safe_add_func_int16_t_s_s((safe_sub_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u((((safe_sub_func_int16_t_s_s((safe_add_func_int32_t_s_s((((safe_mod_func_uint16_t_u_u(p_39, p_39)) > 0xE0EE989EL) ^ 0UL), (*l_135))), (-9L))) ^ (****l_132)) > l_183), 0)), 0L)), p_39)) == (**l_134)), p_39))), p_39)), l_139)), l_139)), p_39)) > p_39), p_39)), 6L)) || l_139) == p_39) > 0x2A01L) ^ l_139));
        /* statement id: 63 */
        assert (l_135 == 0);
    }
    else
    { /* block id: 64 */
        int32_t l_188 = 0L;
        int32_t *l_193 = &l_136;
        for (l_183 = 6; (l_183 <= 2); l_183 = safe_sub_func_uint16_t_u_u(l_183, 7))
        { /* block id: 67 */
            l_193 = func_60((l_187 == (void*)0), p_39, ((0x9435L > (((&l_133 != &l_187) | l_188) != ((safe_add_func_int32_t_s_s((p_39 && (((((safe_sub_func_uint32_t_u_u(0xDA50500DL, 4294967295UL)) < 0x5908L) > p_39) || p_39) ^ p_39)), 0x41A2CE7FL)) || p_39))) && 4294967295UL), &l_188, p_39);
            /* statement id: 68 */
            assert (l_193 == 0);
            (**l_133) = (*l_134);
        }
        /* facts after for loop */
        assert (l_193 == 0 || l_193 == &l_136);
    }
    /* facts after branching */
    assert (l_135 == &l_136 || l_135 == 0);
    return l_195;
    /* statement id: 72 */
    //assert (func_38_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_40(const int8_t  p_41, int32_t  p_42, int32_t * const * p_43, int16_t  p_44, uint32_t  p_45)
{ /* block id: 39 */
    int32_t l_106 = 0xF3046699L;
    int32_t *l_105 = &l_106;
    int32_t **l_104 = &l_105;
    int32_t l_109 = 0x8C46E721L;
    int32_t ***l_124 = (void*)0;
    int32_t ****l_123 = &l_124;
    (*l_104) = (*p_43);
    /* statement id: 40 */
    //assert (l_105 == 0 || l_105 == &l_30);
    if (((safe_lshift_func_int16_t_s_u((l_109 > ((((safe_rshift_func_int16_t_s_s((safe_add_func_int32_t_s_s((safe_sub_func_int32_t_s_s(0xEA0260ADL, (p_45 > ((~(p_42 && (safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((65535UL ^ p_41), (safe_add_func_int16_t_s_s(p_44, (-1L))))), (l_123 != (void*)0))))) | 0x8A6F1982L)))), p_45)), p_45)) != 0UL) && p_42) < l_106)), 13)) >= 0UL))
    { /* block id: 41 */
        uint16_t l_127 = 65531UL;
        int32_t *l_130 = &l_106;
        for (l_109 = 17; (l_109 >= (-26)); l_109 = safe_sub_func_uint16_t_u_u(l_109, 7))
        { /* block id: 44 */
            int32_t *l_128 = (void*)0;
            int32_t *l_129 = &l_106;
            (*l_129) = (l_127 >= l_127);
        }
        (*l_104) = l_130;
        /* statement id: 47 */
        assert (l_105 == &l_106);
    }
    else
    { /* block id: 48 */
        int16_t l_131 = (-1L);
        return l_131;
    }
    /* facts after branching */
    assert (l_105 == &l_106);
    return p_44;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_46(uint32_t  p_47, int8_t  p_48, int32_t * p_49, int16_t  p_50)
{ /* block id: 17 */
    int8_t l_89 = 0x3FL;
    int32_t *l_95 = (void*)0;
    int32_t **l_94 = &l_95;
    int32_t ***l_93 = &l_94;
    int32_t ** const *l_101 = &l_94;
    int32_t ** const **l_100 = &l_101;
    int32_t ** const ***l_99 = &l_100;
    for (p_47 = 0; (p_47 <= 54); p_47 = safe_add_func_int16_t_s_s(p_47, 1))
    { /* block id: 20 */
        uint32_t l_90 = 0x669BA90DL;
        int32_t **l_92 = (void*)0;
        int32_t ***l_91 = &l_92;
        const int32_t l_97 = (-1L);
        const int32_t *l_96 = &l_97;
        int32_t **l_98 = &l_95;
        for (p_48 = 0; (p_48 < (-27)); p_48 = safe_sub_func_uint16_t_u_u(p_48, 3))
        { /* block id: 23 */
            int16_t l_88 = 0xC6B6L;
            if (l_88)
                break;
            (*p_49) = ((0x40302764L ^ (l_88 < (l_89 == p_47))) ^ (*p_49));
        }
        (*l_98) = func_60(l_89, l_90, (l_91 == l_93), l_96, p_50);
        if ((*p_49))
            break;
    }
    (*l_99) = &l_93;
    /* statement id: 30 */
    assert (l_100 == &l_93);
    (*p_49) = (0L | 0xBA474122L);
    for (p_47 = (-1); (p_47 > 57); p_47 = safe_add_func_int16_t_s_s(p_47, 3))
    { /* block id: 34 */
        p_49 = (void*)0;
        /* statement id: 35 */
        assert (p_49 == 0);
        return p_47;
    }
    return p_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_57(int32_t ** p_58, int32_t  p_59)
{ /* block id: 7 */
    int32_t l_66 = 2L;
    int32_t *l_81 = &l_66;
    int32_t **l_80 = &l_81;
    int32_t *l_82 = &l_66;
    (*l_80) = func_60(l_66, l_66, p_59, &l_66, p_59);
    /* statement id: 14 */
    assert (l_81 == 0);
    (*l_82) = p_59;
    return p_59;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_60(int32_t  p_61, int16_t  p_62, uint16_t  p_63, const int32_t * p_64, int32_t  p_65)
{ /* block id: 8 */
    int32_t *l_68 = (void*)0;
    int32_t **l_67 = &l_68;
    int32_t ***l_70 = &l_67;
    int32_t ****l_69 = &l_70;
    int32_t l_75 = (-1L);
    int32_t * const l_74 = &l_75;
    int32_t * const l_76 = &l_75;
    int32_t * const l_77 = &l_75;
    int32_t * const l_78 = &l_75;
    int32_t * const l_79 = (void*)0;
    (*l_67) = &p_61;
    /* statement id: 9 */
    assert (l_68 == &p_61);
    (*l_69) = &l_67;
    (**l_67) = (((((~(((p_63 < (((*p_64) == (0x1810L && 0UL)) < (&p_64 == (void*)0))) > p_63) & ((((****l_69) || ((***l_70) >= (**l_67))) > p_61) == (*l_68)))) & 0x8B058B50L) ^ (**l_67)) >= (****l_69)) > p_62);
    (*l_67) = &p_61;
    return l_79;
    /* statement id: 13 */
    //assert (func_60_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 181
XXX total union variables: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 3
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 184

XXX times a variable address is taken: 197
XXX times a pointer is dereferenced on RHS: 138
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 24
   depth: 3, occurrence: 9
   depth: 4, occurrence: 13
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 95
breakdown:
   depth: 1, occurrence: 70
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7
   depth: 4, occurrence: 1
   depth: 5, occurrence: 1
XXX times a pointer is compared with null: 33
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 15
XXX times a pointer is qualified to be dereferenced: 1481

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 305
   level: 2, occurrence: 127
   level: 3, occurrence: 88
   level: 4, occurrence: 87
   level: 5, occurrence: 28
XXX number of pointers point to pointers: 82
XXX number of pointers point to scalars: 102
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 23.9
XXX average alias set size: 1.17

XXX times a non-volatile is read: 876
XXX times a non-volatile is write: 264
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 6

XXX stmts: 64
XXX max block depth: 2
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 17
   depth: 2, occurrence: 10

XXX percentage a fresh-made variable is used: 8.16
XXX percentage an existing variable is used: 91.8
********************* end of statistics **********************/

