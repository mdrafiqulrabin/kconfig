/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      2725346776
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int32_t  f0;
   signed f1 : 7;
   uint32_t  f2;
   const uint32_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_30(void);
inline static uint64_t  func_35(uint16_t  p_36, uint16_t  p_37, const uint32_t  p_38, uint32_t  p_39);
static int32_t  func_46(uint32_t  p_47);
inline static int32_t * func_50(float  p_51, int16_t  p_52, const int32_t * p_53);
static uint64_t  func_58(union U0  p_59);
inline static union U0  func_60(int32_t  p_61, const int32_t * const  p_62);
inline static int32_t * const * func_81(int32_t * p_82, int64_t  p_83, int32_t  p_84, int16_t  p_85);
inline static int32_t * func_86(float  p_87, const int32_t ** p_88);
static const int32_t ** func_90(int32_t * p_91, int32_t * const  p_92, int32_t ** p_93, int32_t * p_94, const int32_t * p_95);
inline static int32_t * func_96(uint32_t  p_97, int32_t  p_98, uint32_t  p_99);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_30(void)
{ /* block id: 36 */
    uint32_t l_31 = 4294967295UL;
    float l_669 = 0x1.7p-1;
    float *l_668 = &l_669;
    float *l_670 = &l_669;
    int64_t l_671 = 0x754253CF6CDC54B0LL;
    float l_672 = 0x3.D94295p-9;
    uint32_t l_673 = 18446744073709551615UL;
    int32_t *l_674 = (void*)0;
    int32_t l_675 = 0x13D1EC19L;
    float l_680 = 0x6.Ep-1;
    float *l_683 = &l_669;
    float *l_684 = (void*)0;
    float *l_688 = &l_672;
    float *l_689 = &l_672;
    uint64_t l_698 = 18446744073709551608UL;
    uint16_t l_699 = 0xD6C0L;
    float l_700 = (-0x1.7p+1);
    int32_t *l_701 = &l_675;
    uint32_t l_702 = 0x75DA5036L;
    if ((l_31 == 0UL))
    { /* block id: 37 */
        return l_31;
    }
    else
    { /* block id: 39 */
        uint32_t l_34 = 0x35C0DE45L;
        uint64_t l_651 = 0x7158A5C257B2B4FCLL;
        int32_t l_652 = 0x719E0550L;
        l_652 = (((uint64_t)(1UL > 0xC3D6C1DFE936BE85LL) + (uint64_t)(l_34 && (func_35(l_34, ((int16_t)((int64_t)l_31 - (int64_t)l_34) - (int16_t)l_31), (((uint16_t)l_31 >> (uint16_t)10) ^ l_34), l_34) <= l_31))) >= l_651);
    }
    l_675 = ((((int16_t)l_31 >> (int16_t)((uint16_t)((uint16_t)(!(l_31 && l_31)) + (uint16_t)(l_31 <= ((int16_t)(((l_31 == ((int64_t)0L % (int64_t)func_35(((uint32_t)((l_31 ^ l_31) & (l_668 != l_670)) / (uint32_t)l_671), l_31, l_671, l_671))) && l_671) <= l_31) - (int16_t)l_673))) >> (uint16_t)1)) && l_671) ^ l_671);
    (*l_701) = ((((int32_t)((uint32_t)l_671 % (uint32_t)((uint16_t)(l_683 != l_684) - (uint16_t)(+((((int64_t)(l_688 != l_689) - (int64_t)((l_31 && ((uint32_t)(((uint64_t)0UL + (uint64_t)(0x7347A7D29C3FC888LL || ((int32_t)((uint16_t)func_35(l_671, l_698, l_671, l_673) >> (uint16_t)l_31) + (int32_t)l_675))) >= 0x4060L) + (uint32_t)l_671)) >= l_699)) == l_698) & l_675)))) + (int32_t)(-8L)) || l_671) ^ (-3L));
    return l_702;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_35(uint16_t  p_36, uint16_t  p_37, const uint32_t  p_38, uint32_t  p_39)
{ /* block id: 40 */
    int32_t l_48 = 0x38299FA9L;
    int32_t l_401 = 0x06ED0E04L;
    const int32_t *l_400 = &l_401;
    union U0 *l_449 = (void*)0;
    union U0 **l_448 = &l_449;
    union U0 ***l_447 = &l_448;
    union U0 ****l_539 = (void*)0;
    union U0 *****l_538 = &l_539;
    int32_t l_571 = (-8L);
    uint32_t l_648 = 9UL;
    if (func_46(l_48))
    { /* block id: 43 */
        float l_63 = 0x8.78CD90p-27;
        const int32_t l_65 = 1L;
        const int32_t * const l_64 = &l_65;
        int32_t *l_406 = &l_401;
        int32_t **l_405 = &l_406;
        union U0 l_413 = {-2L};
        const union U0 *l_412 = &l_413;
        const int32_t **l_458 = &l_400;
        (*l_405) = func_50(p_39, (((uint32_t)(((((uint32_t)(1L & func_58(func_60(p_37, l_64))) % (uint32_t)((uint64_t)p_36 + (uint64_t)((int16_t)(*l_64) / (int16_t)((uint16_t)(((((int64_t)(*l_64) / (int64_t)p_39) < p_37) || 4UL) ^ p_39) >> (uint16_t)p_36)))) <= 0xDFDF0037L) == p_38) >= 0x7F2C3C599F4A2D3DLL) / (uint32_t)4294967295UL) == p_38), l_400);
        /* statement id: 181 */
        assert (l_406 == 0);
        l_401 = ((p_36 == ((p_37 != (((1L < p_36) < 0x288D38B6L) ^ (((uint32_t)p_39 % (uint32_t)p_36) != (((((0x37043CBFL & (-3L)) != 0xF733L) && (-1L)) == p_37) && p_36)))) | 5UL)) < p_37);
        l_400 = func_96((+(&l_406 != (void*)0)), p_37, p_39);
        /* statement id: 183 */
        assert (l_400 == 0);
        for (l_401 = 0; (l_401 <= 12); l_401 += 1)
        { /* block id: 186 */
            union U0 *l_415 = &l_413;
            union U0 **l_414 = &l_415;
            int32_t l_420 = 1L;
            uint16_t l_431 = 0x0122L;
            int64_t l_452 = 0xA939F94B34C819D0LL;
            uint32_t l_463 = 0xEAAE5C66L;
            const int32_t *l_466 = (void*)0;
            (*l_414) = l_412;
            for (l_413.f2 = (-20); (l_413.f2 < 19); l_413.f2++)
            { /* block id: 190 */
                union U0 *l_422 = &l_413;
                int32_t l_439 = (-1L);
                uint32_t l_446 = 0x5FBCA4FFL;
                for (p_37 = 5; (p_37 == 33); p_37 += 1)
                { /* block id: 193 */
                    float *l_421 = &l_63;
                    int32_t l_425 = 0x1FC920DFL;
                    int32_t *l_426 = &l_420;
                    (*l_421) = __builtin_bswap32(l_420);
                    (*l_414) = l_422;
                    for (p_36 = 0; (p_36 < 10); p_36 += 5)
                    { /* block id: 198 */
                        if (l_420)
                            break;
                    }
                    (*l_426) = l_425;
                }
                if (((uint16_t)((uint64_t)(3UL & p_36) + (uint64_t)(l_431 > func_58((*l_415)))) % (uint16_t)(+((((uint64_t)((((uint64_t)p_37 + (uint64_t)((int32_t)l_48 % (int32_t)l_439)) || __builtin_ffsl(((((0x0484L & p_36) >= (-6L)) && 0x78FE824BA8217980LL) != p_39))) != l_431) % (uint64_t)p_38) > 0UL) || l_431))))
                { /* block id: 203 */
                    float *l_440 = &l_63;
                    int32_t l_456 = (-1L);
                    (*l_440) = l_431;
                    (*l_405) = func_96(p_37, ((+l_439) != ((int16_t)(p_38 < 0xCA984D77968AAB93LL) << (int16_t)15)), p_36);
                    (*l_405) = &l_401;
                    /* statement id: 206 */
                    assert (l_406 == &l_401);
                    for (p_37 = 0; (p_37 >= 41); p_37 += 2)
                    { /* block id: 209 */
                        uint16_t l_455 = 0xCEFAL;
                        int32_t *l_457 = (void*)0;
                        (*l_440) = (((p_36 < ((l_446 == (&l_414 == l_447)) == 0x9.02C0CEp+40)) > p_37) > ((float)(l_452 != (((float)(l_455 >= p_37) / (float)l_452) <= 0x1.6p+1)) + (float)0x0.0p-1));
                        if (l_456)
                            break;
                        (*l_405) = l_457;
                        /* statement id: 212 */
                        assert (l_406 == 0);
                        l_400 = (void*)0;
                    }
                    /* facts after for loop */
                    assert (l_406 == 0 || l_406 == &l_401);
                }
                else
                { /* block id: 215 */
                    int32_t *l_459 = &l_420;
                    (*l_405) = &l_420;
                    /* statement id: 216 */
                    assert (l_406 == &l_420);
                    (*l_405) = func_86(p_39, l_458);
                    /* statement id: 217 */
                    assert (l_406 == 0);
                    (*l_459) = p_36;
                }
                /* facts after branching */
                assert (l_406 == 0 || l_406 == &l_401);
                (*l_405) = func_50(((float)func_58((*l_422)) - (float)p_39), l_439, &l_401);
                /* statement id: 220 */
                assert (l_406 == 0);
                if (p_39)
                    break;
            }
            /* facts after for loop */
                        (*l_458) = func_50((((+((p_37 != l_463) >= (((float)(0x1.19381Fp+69 != p_36) + (float)l_401) > 0x9.72C889p-80))) >= __builtin_ctzl(l_452)) == l_452), p_38, l_466);
            return p_38;
        }
    }
    else
    { /* block id: 226 */
        uint32_t l_467 = 0xDDBB3080L;
        float l_471 = 0x0.5p-1;
        float *l_470 = &l_471;
        union U0 l_474 = {1L};
        const union U0 *l_473 = &l_474;
        const union U0 **l_472 = &l_473;
        uint16_t l_559 = 1UL;
        (*l_470) = (p_39 <= (((((-0x2.8p+1) >= (&l_447 != (void*)0)) <= (l_467 < ((((l_467 != (((float)((void*)0 == l_470) - (float)(l_472 == &l_473)) != (*l_400))) >= (-0x1.Bp-1)) == p_36) < (*l_400)))) <= 0xE.053F47p+91) == (-0x1.Ap+1)));
        l_401 = (l_474.f1 && p_38);
        if (p_39)
        { /* block id: 229 */
            int16_t l_478 = (-1L);
            int32_t l_484 = 8L;
            int32_t *l_486 = &l_474.f0;
            int32_t ** const l_485 = &l_486;
            uint64_t l_501 = 0x0FBFB27927304A5DLL;
            uint32_t l_534 = 0x4E999821L;
            int32_t *l_614 = &l_474.f0;
            uint8_t l_626 = 255UL;
        }
        else
        { /* block id: 318 */
            l_571 = ((int16_t)((int64_t)__builtin_ctz(l_474.f0) - (int64_t)((int16_t)p_38 << (int16_t)12)) % (int16_t)p_39);
        }
    }
    /* facts after branching */
    assert (l_400 == &l_401 || l_400 == 0);
    l_401 = p_38;
    for (l_401 = 1; (l_401 >= 18); l_401 += 2)
    { /* block id: 325 */
        int32_t **l_644 = (void*)0;
        int32_t *l_646 = (void*)0;
        int32_t **l_645 = &l_646;
        (*l_645) = func_86((0x7.05B6C1p+27 >= (-0x5.7p-1)), &l_400);
        l_571 = (((-(uint32_t)l_648) ^ ((-6L) && p_37)) || (((p_36 & p_38) & (p_38 > p_37)) < (1UL | p_37)));
    }
    l_401 = ((float)p_36 / (float)p_39);
    return p_36;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_46(uint32_t  p_47)
{ /* block id: 41 */
    float l_49 = 0xA.477A14p+41;
    return p_47;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_50(float  p_51, int16_t  p_52, const int32_t * p_53)
{ /* block id: 179 */
    int32_t l_403 = 1L;
    int32_t *l_402 = &l_403;
    int32_t *l_404 = (void*)0;
    return l_404;
    /* statement id: 180 */
    //assert (func_50_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint64_t  func_58(union U0  p_59)
{ /* block id: 176 */
    int32_t l_390 = 0x7116458DL;
    int32_t *l_389 = &l_390;
    int32_t **l_391 = &l_389;
    (*l_391) = l_389;
    return p_59.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U0  func_60(int32_t  p_61, const int32_t * const  p_62)
{ /* block id: 44 */
    int32_t l_66 = (-1L);
    int32_t l_78 = 0xA929EFCFL;
    int32_t *l_77 = &l_78;
    union U0 ***l_223 = (void*)0;
    union U0 l_388 = {3L};
    (*l_77) = ((l_66 ^ ((((int32_t)(((uint16_t)(((int32_t)((uint16_t)l_66 - (uint16_t)(1L && p_61)) - (int32_t)(((l_66 != l_66) && ((p_61 && ((-2L) & l_66)) > l_66)) == p_61)) | 0x4ECA6696B4954824LL) << (uint16_t)15) | 4UL) % (int32_t)l_66) | l_66) || p_61)) > p_61);
    for (p_61 = 0; (p_61 > 2); ++p_61)
    { /* block id: 48 */
        uint32_t l_89 = 18446744073709551613UL;
        const int32_t *l_224 = (void*)0;
        int32_t **l_386 = &l_77;
        int32_t ***l_385 = &l_386;
        union U0 l_387 = {-1L};
        (*l_385) = func_81(func_86(l_89, func_90(func_96((*l_77), p_61, p_61), func_96(((uint16_t)((~((uint64_t)(((uint16_t)((int64_t)func_46(p_61) + (int64_t)((uint16_t)__builtin_ctzl((l_223 == (void*)0)) << (uint16_t)12)) / (uint16_t)(*l_77)) > 0x264CL) / (uint64_t)l_89)) <= p_61) >> (uint16_t)p_61), p_61, p_61), &l_77, &l_78, l_224)), l_78, l_66, l_66);
        /* statement id: 172 */
        assert (l_77 == 0);
        assert (l_386 == 0);
        return l_387;
        /* statement id: 173 */
            }
    return l_388;
    /* statement id: 175 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * const * func_81(int32_t * p_82, int64_t  p_83, int32_t  p_84, int16_t  p_85)
{ /* block id: 109 */
    int32_t l_255 = 0x44D09D3CL;
    uint32_t l_256 = 0x16D91DA8L;
    const int32_t **l_279 = (void*)0;
    union U0 l_295 = {1L};
    union U0 *l_294 = &l_295;
    union U0 **l_293 = &l_294;
    int64_t l_363 = 0L;
    int16_t l_375 = 0L;
    int32_t l_380 = 1L;
    int32_t * const l_379 = &l_380;
    int32_t * const *l_378 = &l_379;
    int32_t * const *l_381 = &l_379;
    int32_t * const *l_382 = &l_379;
    int32_t * const *l_383 = &l_379;
    int32_t * const *l_384 = (void*)0;
    for (p_84 = 21; (p_84 > (-4)); p_84 -= 8)
    { /* block id: 112 */
        union U0 *l_251 = (void*)0;
        union U0 **l_250 = &l_251;
        union U0 ** const l_252 = &l_251;
        const int32_t l_276 = 0x5C22D9D8L;
        int32_t l_300 = 0xED7BFA6EL;
        int64_t l_311 = 0xE7C32A7BFF7CC213LL;
        union U0 ***l_331 = &l_293;
        union U0 ****l_330 = &l_331;
        int32_t *l_356 = &l_300;
        int32_t * const *l_355 = &l_356;
        uint64_t l_358 = 0x0F0752AFE84FE09BLL;
        int16_t l_362 = 1L;
        const int32_t *l_365 = &l_276;
        const int32_t **l_364 = &l_365;
        int32_t **l_366 = &l_356;
        float l_377 = (-0x3.2p+1);
        float *l_376 = &l_377;
        if (((((int64_t)((int16_t)(-1L) << (int16_t)10) % (int64_t)p_84) ^ (((uint16_t)func_46((-(uint16_t)(((__builtin_clz(p_84) & ((int16_t)(l_250 == l_252) >> (int16_t)(((0x83F6A43E87FF4ED3LL ^ (p_85 >= ((uint16_t)(&l_250 != &l_250) >> (uint16_t)2))) ^ p_84) || l_255))) && l_255) & p_83))) % (uint16_t)l_255) < l_256)) == 18446744073709551614UL))
        { /* block id: 113 */
            uint32_t l_259 = 0x97AACED7L;
            uint32_t l_278 = 0xC59D0019L;
            float l_302 = 0x0.7p-1;
            float *l_301 = &l_302;
            if (l_256)
            { /* block id: 114 */
                for (p_85 = 0; (p_85 < (-6)); --p_85)
                { /* block id: 117 */
                    int32_t l_261 = 0x94EBA6C6L;
                    int32_t *l_260 = &l_261;
                    (*l_260) = ((l_259 == p_83) | p_85);
                    if (l_259)
                        break;
                }
            }
            else
            { /* block id: 121 */
                union U0 **l_273 = &l_251;
                int32_t l_296 = 0x124B1641L;
                for (l_256 = 3; (l_256 < 29); l_256 += 1)
                { /* block id: 124 */
                    int32_t l_264 = 0xE0181DA6L;
                    int32_t *l_281 = &l_264;
                    int32_t **l_280 = &l_281;
                    uint32_t l_288 = 0xCFC5F2DEL;
                    uint8_t l_297 = 6UL;
                    p_82 = &p_84;
                    /* statement id: 125 */
                    assert (p_82 == &p_84);
                    (*l_280) = func_86((((l_264 > (((float)(((float)((float)(((float)((l_273 == (void*)0) < 0x0.4p+1) + (float)l_259) <= (l_264 >= ((float)l_276 - (float)0x1.8p-1))) / (float)(((+(l_255 > p_85)) >= l_259) > l_259)) / (float)0x1.Ap-1) != p_85) + (float)l_259) <= p_85)) <= l_276) != l_278), l_279);
                    /* statement id: 126 */
                    assert (l_281 == 0);
                    l_295.f1 = ((uint32_t)(__builtin_bswap32(((int16_t)(((int16_t)l_288 << (int16_t)(((!(-2L)) || ((uint64_t)0x09E64E212550B3B6LL / (uint64_t)l_278)) != ((__builtin_popcountl((((-(uint32_t)0x4136D5DCL) && (((((void*)0 != l_293) >= func_46(l_296)) && l_296) || p_83)) | p_84)) | 0x29B9L) & 65532UL))) >= 0x62E55FA1EA543894LL) + (int16_t)p_84)) && l_297) - (uint32_t)(*p_82));
                }
                for (l_255 = 3; (l_255 <= 22); ++l_255)
                { /* block id: 131 */
                    l_300 = l_278;
                }
            }
            (*l_301) = (&p_84 == &p_84);
            for (l_278 = 0; (l_278 >= 60); l_278++)
            { /* block id: 138 */
                uint16_t l_307 = 0x2C39L;
                const float *l_310 = &l_302;
                const int32_t *l_327 = &l_300;
                int32_t *l_354 = (void*)0;
                int32_t **l_353 = &l_354;
                for (l_300 = 3; (l_300 >= 2); l_300 -= 5)
                { /* block id: 141 */
                    p_82 = (void*)0;
                    /* statement id: 142 */
                    assert (p_82 == 0);
                }
                if ((l_307 >= ((uint32_t)((((l_310 != p_82) || p_83) | ((l_278 >= func_46(__builtin_ctzl(__builtin_ctzl(l_311)))) == p_84)) && p_84) - (uint32_t)p_84)))
                { /* block id: 144 */
                    int32_t *l_313 = &l_300;
                    int32_t **l_312 = &l_313;
                    int32_t *l_314 = &l_300;
                    (*l_312) = &p_84;
                    /* statement id: 145 */
                    assert (l_313 == &p_84);
                    (*l_314) = p_85;
                }
                else
                { /* block id: 147 */
                    uint16_t l_317 = 3UL;
                    int32_t *l_318 = (void*)0;
                    int32_t *l_319 = &l_295.f0;
                    union U0 ** const l_320 = &l_251;
                    (*l_319) = ((int16_t)(-1L) - (int16_t)l_317);
                    /* statement id: 148 */
                                        if (l_307)
                        continue;
                    l_318 = &p_84;
                    /* statement id: 150 */
                    assert (l_318 == &p_84);
                    if ((l_320 == l_320))
                    { /* block id: 151 */
                        int32_t l_326 = (-1L);
                        (*l_319) = (((+((uint16_t)__builtin_parityl(((uint64_t)((*l_319) ^ 65535UL) - (uint64_t)(l_307 <= l_278))) / (uint16_t)__builtin_bswap32(l_276))) == p_85) <= l_326);
                        l_327 = &l_276;
                        /* statement id: 153 */
                        assert (l_327 == &l_276);
                        if (p_85)
                            continue;
                    }
                    else
                    { /* block id: 155 */
                        union U0 ***l_329 = &l_250;
                        union U0 ****l_328 = &l_329;
                        int32_t l_332 = (-1L);
                        (*l_301) = ((l_328 == l_330) >= 0x0.50AABCp-79);
                        (*l_319) = l_332;
                        (*l_301) = (-0x5.7p-1);
                        (*l_301) = ((float)(((0x8.EFF3E8p-16 > (l_276 >= p_83)) != ((float)func_46(__builtin_ffsll(((int64_t)((int64_t)0x1BC2A71DD7EC65E0LL / (int64_t)(((int64_t)p_85 + (int64_t)((uint32_t)((int16_t)(p_83 >= ((int16_t)func_46((((int16_t)p_85 % (int16_t)((uint32_t)__builtin_popcount(p_85) / (uint32_t)p_84)) && 0x5DE6L)) + (int16_t)l_300)) >> (int16_t)p_85) / (uint32_t)9UL)) | 0xAB3DL)) + (int64_t)p_85))) + (float)p_84)) > p_84) - (float)(*l_327));
                    }
                    /* facts after branching */
                    assert (l_327 == &l_300 || l_327 == &l_276);
                }
                /* facts after branching */
                assert (l_327 == &l_300 || l_327 == &l_276);
                (*l_353) = &p_84;
                /* statement id: 162 */
                assert (l_354 == &p_84);
            }
        }
        else
        { /* block id: 164 */
            int32_t * const *l_357 = (void*)0;
            return l_357;
            /* statement id: 165 */
            //assert (func_81_rv == 0);
        }
        (*l_364) = func_86((l_358 == ((!((float)l_362 - (float)l_363)) <= (&l_293 != (*l_330)))), l_364);
        /* statement id: 167 */
        assert (l_365 == 0);
        (*l_366) = (*l_355);
        (*l_376) = (p_84 < ((-(float)(((float)0x2.7F72F9p+81 - (float)((float)p_84 - (float)(+func_46(p_85)))) >= (p_84 <= (*l_356)))) != ((float)((p_83 != p_85) == l_375) - (float)(**l_366))));
    }
    /* facts after for loop */
    assert (p_82 == &p_84 || p_82 == 0);
        return l_384;
    /* statement id: 171 */
    //assert (func_81_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_86(float  p_87, const int32_t ** p_88)
{ /* block id: 106 */
    uint64_t l_233 = 0x2D32AF4CE8BB6BBBLL;
    int32_t l_235 = 0x7CEF4F58L;
    int32_t *l_234 = &l_235;
    int32_t *l_236 = &l_235;
    int32_t *l_237 = &l_235;
    int32_t *l_238 = (void*)0;
    l_233 = 0x7FAE0A69L;
    return l_238;
    /* statement id: 108 */
    //assert (func_86_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int32_t ** func_90(int32_t * p_91, int32_t * const  p_92, int32_t ** p_93, int32_t * p_94, const int32_t * p_95)
{ /* block id: 101 */
    uint32_t l_225 = 0x6C77FDBCL;
    union U0 l_229 = {-8L};
    union U0 *l_228 = &l_229;
    union U0 **l_227 = &l_228;
    union U0 ***l_226 = &l_227;
    int32_t *l_230 = &l_229.f0;
    uint8_t l_231 = 0xDBL;
    const int32_t **l_232 = (void*)0;
    (*p_93) = func_96(l_225, ((l_225 > (l_225 && 0x339AD12C72D12529LL)) == l_225), ((void*)0 == l_226));
    /* statement id: 102 */
    //assert (l_77 == 0);
    l_230 = (*p_93);
    /* statement id: 103 */
    assert (l_230 == 0);
    l_230 = func_96(__builtin_parity(l_231), l_229.f1, l_231);
    return l_232;
    /* statement id: 105 */
    //assert (func_90_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_96(uint32_t  p_97, int32_t  p_98, uint32_t  p_99)
{ /* block id: 49 */
    int32_t l_113 = (-2L);
    int32_t l_116 = 0x9E2D4DC4L;
    int32_t *l_115 = &l_116;
    int32_t **l_114 = &l_115;
    uint16_t l_119 = 0x6F27L;
    union U0 l_128 = {0xAF0C8B8AL};
    union U0 *l_127 = &l_128;
    union U0 **l_126 = &l_127;
    int32_t *l_134 = &l_116;
    int32_t *l_135 = (void*)0;
    int32_t *l_181 = &l_128.f0;
    int32_t *l_211 = (void*)0;
    for (p_99 = 0; (p_99 > 36); ++p_99)
    { /* block id: 52 */
        union U0 *l_102 = (void*)0;
        union U0 **l_103 = (void*)0;
        union U0 **l_104 = (void*)0;
        int32_t l_108 = 0xC3517D3EL;
        int32_t * const l_107 = &l_108;
        int32_t *l_130 = &l_108;
        int16_t l_171 = 0xFF72L;
        int32_t *l_179 = &l_128.f0;
        int32_t *l_182 = &l_108;
        int32_t *l_183 = &l_116;
        l_102 = l_102;
    }
    (**l_114) = ((0xD052D8D885D17D95LL || (((p_98 & ((int16_t)(p_98 > (**l_114)) << (int16_t)1)) >= (p_99 | __builtin_ia32_crc32qi(p_98, ((void*)0 == &l_126)))) == p_99)) && 0L);
    return l_211;
    /* statement id: 100 */
    //assert (func_96_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 171
XXX total union variables: 5

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 3
   indirect level: 2, occurrence: 9
   indirect level: 3, occurrence: 3
   indirect level: 4, occurrence: 3
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 7
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 1
XXX times a single bitfield on RHS: 7

XXX max expression depth: 28
breakdown:
   depth: 1, occurrence: 105
   depth: 2, occurrence: 22
   depth: 3, occurrence: 3
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 4
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 28, occurrence: 1

XXX total number of pointers: 158

XXX times a variable address is taken: 154
XXX times a pointer is dereferenced on RHS: 55
breakdown:
   depth: 1, occurrence: 47
   depth: 2, occurrence: 7
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 85
breakdown:
   depth: 1, occurrence: 79
   depth: 2, occurrence: 4
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 11
XXX times a pointer is qualified to be dereferenced: 353

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 170
   level: 2, occurrence: 35
   level: 3, occurrence: 1
   level: 4, occurrence: 2
XXX number of pointers point to pointers: 65
XXX number of pointers point to scalars: 83
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 29.1
XXX average alias set size: 1.16

XXX times a non-volatile is read: 654
XXX times a non-volatile is write: 224
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 100
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 18
   depth: 2, occurrence: 9
   depth: 3, occurrence: 10
   depth: 4, occurrence: 24
   depth: 5, occurrence: 12

XXX percentage a fresh-made variable is used: 14.9
XXX percentage an existing variable is used: 85.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

