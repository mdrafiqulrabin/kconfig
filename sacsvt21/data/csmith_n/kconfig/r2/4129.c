/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      801660936
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   uint32_t  f0;
};
#pragma pack(pop)

struct S1 {
   unsigned f0 : 10;
   volatile signed f1 : 6;
   unsigned f2 : 1;
   unsigned f3 : 31;
   unsigned f4 : 8;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_3 = (-1L);
static volatile int32_t g_30 = 0xD373EE76L;/* VOLATILE GLOBAL g_30 */
static volatile int32_t g_31 = 0xA4C924B5L;/* VOLATILE GLOBAL g_31 */
static volatile int32_t g_32 = 0x45714FFDL;/* VOLATILE GLOBAL g_32 */
static volatile int32_t g_33 = (-10L);/* VOLATILE GLOBAL g_33 */
static int32_t g_34 = 0x45799333L;
static int32_t * volatile g_56 = &g_34;/* VOLATILE GLOBAL g_56 */
static int32_t * volatile *g_55 = &g_56;
static int32_t * volatile **g_54 = &g_55;
static struct S1 g_60 = {12,-5,0,26090,1};/* VOLATILE GLOBAL g_60 */
static struct S1 g_61 = {6,-4,0,6922,10};/* VOLATILE GLOBAL g_61 */
static float g_64 = 0x4.63964Ep+15;
static int32_t *g_96[6] = {&g_34,&g_34,&g_34,&g_34,&g_34,&g_34};
static int32_t **g_95 = &g_96[2];
static int32_t *g_126 = (void*)0;
static float g_132 = (-0x1.6p-1);
static int32_t g_152[7][5] = {{0xB2F8DC5AL,0xB2F8DC5AL,0x8307115AL,0x8307115AL,0xB2F8DC5AL},{(-7L),0x8205C77FL,(-7L),0x8205C77FL,(-7L)},{0xB2F8DC5AL,0x8307115AL,0x8307115AL,0xB2F8DC5AL,0xB2F8DC5AL},{0xBD03F0CDL,0x8205C77FL,0xBD03F0CDL,0x8205C77FL,0xBD03F0CDL},{0xB2F8DC5AL,0xB2F8DC5AL,0x8307115AL,0x8307115AL,0xB2F8DC5AL},{(-7L),0x8205C77FL,(-7L),0x8205C77FL,(-7L)},{0xB2F8DC5AL,0x8307115AL,0x8307115AL,0xB2F8DC5AL,0xB2F8DC5AL}};
static int32_t * volatile g_151[3] = {&g_152[5][4],&g_152[5][4],&g_152[5][4]};
static struct S1 * volatile g_162 = &g_61;/* VOLATILE GLOBAL g_162 */
static int32_t ** const * const g_172[5][7] = {{&g_95,&g_95,&g_95,&g_95,(void*)0,&g_95,(void*)0},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,(void*)0,&g_95,&g_95,(void*)0,(void*)0,&g_95},{&g_95,(void*)0,&g_95,&g_95,&g_95,(void*)0,&g_95},{&g_95,(void*)0,(void*)0,&g_95,&g_95,(void*)0,&g_95}};
static int32_t ** const * const *g_171[2] = {&g_172[1][2],&g_172[1][2]};
static volatile struct S1 g_197[2] = {{16,-0,0,26255,1},{16,-0,0,26255,1}};
static const struct S1 g_201 = {3,-0,0,3297,8};/* VOLATILE GLOBAL g_201 */
static int32_t * volatile g_214 = &g_152[1][1];/* VOLATILE GLOBAL g_214 */
static struct S0 g_217 = {0x4FA59ADAL};
static struct S0 * volatile g_216 = &g_217;/* VOLATILE GLOBAL g_216 */
static int32_t * volatile g_228 = &g_152[5][4];/* VOLATILE GLOBAL g_228 */
static int32_t g_243 = 0x0ABAC2E1L;
static const struct S1 g_321 = {1,2,0,21003,8};/* VOLATILE GLOBAL g_321 */
static const struct S1 *g_320 = &g_321;
static int32_t ** const *g_328 = &g_95;
static int32_t *** volatile g_329 = &g_95;/* VOLATILE GLOBAL g_329 */
static int32_t * volatile g_339[2] = {&g_152[5][4],&g_152[5][4]};
static int32_t * volatile g_340 = &g_152[5][4];/* VOLATILE GLOBAL g_340 */
static volatile struct S0 g_385 = {5UL};/* VOLATILE GLOBAL g_385 */
static volatile struct S0 * volatile g_384 = &g_385;/* VOLATILE GLOBAL g_384 */
static float * volatile g_388 = &g_64;/* VOLATILE GLOBAL g_388 */
static float * volatile g_402[8] = {&g_132,&g_132,&g_132,&g_132,&g_132,&g_132,&g_132,&g_132};
static struct S1 g_433 = {24,-6,0,44083,3};/* VOLATILE GLOBAL g_433 */
static int32_t ***g_450[7][6][6] = {{{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95}},{{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,(void*)0,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,(void*)0,&g_95,&g_95,&g_95,&g_95}},{{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95}},{{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,(void*)0,&g_95}},{{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95},{&g_95,&g_95,(void*)0,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,(void*)0},{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95},{&g_95,&g_95,(void*)0,&g_95,&g_95,&g_95}},{{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95}},{{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95},{&g_95,&g_95,&g_95,&g_95,&g_95,&g_95},{&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95},{&g_95,&g_95,(void*)0,&g_95,&g_95,&g_95}}};
static int32_t ****g_449 = &g_450[0][1][1];
static int32_t *****g_448 = &g_449;
static const int32_t *g_453 = &g_152[0][3];
static const int32_t * const *g_452 = &g_453;
static const int32_t * const **g_451 = &g_452;
static float * volatile g_455 = &g_132;/* VOLATILE GLOBAL g_455 */


/* --- FORWARD DECLARATIONS --- */
inline static uint64_t  func_28(void);
static int32_t * const  func_35(int32_t  p_36);
inline static int32_t  func_37(uint64_t  p_38, const uint16_t  p_39, uint16_t  p_40, uint8_t  p_41, int32_t  p_42);
inline static int32_t ** func_44(int64_t  p_45, int32_t * p_46, uint32_t  p_47, int16_t  p_48, int8_t  p_49);
static int64_t  func_50(int16_t  p_51);
inline static struct S1  func_57(int32_t * p_58);
static uint16_t  func_68(int32_t * p_69, uint16_t  p_70, int32_t  p_71);
inline static int32_t * func_72(int32_t  p_73, float  p_74, int32_t * p_75, int32_t ** p_76, int32_t ** const  p_77);
static uint8_t  func_79(int32_t  p_80);
static int32_t  func_83(int32_t * p_84, const int32_t * const ** p_85, int32_t  p_86, int32_t ** p_87);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_329 g_95 g_96 g_451 g_60.f2 g_126 g_201.f3 g_455
 * writes: g_3 g_34 g_448 g_96 g_452 g_126 g_132
 */
inline static uint64_t  func_28(void)
{ /* block id: 36 */
    uint16_t l_29[7] = {0x874BL,0x874BL,0x874BL,0x874BL,0x874BL,0x874BL,0x874BL};
    int32_t **l_454 = &g_126;
    int i;
    for (g_3 = 2; (g_3 <= 6); g_3 += 1)
    { /* block id: 39 */
        int32_t *l_442 = (void*)0;
        int64_t l_445 = 0L;
        int32_t *****l_447 = (void*)0;
        for (g_34 = 0; (g_34 <= 6); g_34 += 1)
        { /* block id: 42 */
            int i;
        }
        g_448 = l_447;
        /* statement id: 277 */
        assert (g_448 == 0);
        if (l_29[5])
            break;
    }
    /* facts after for loop */
    assert (g_448 == 0 || g_448 == &g_449);
    (*g_455) = (&g_197[0] != ((func_83((**g_329), g_451, g_60.f2, l_454) < g_201.f3) , &g_433));
    /* statement id: 280 */
    assert (g_126 == &g_3);
    assert (g_452 == 0 || g_452 == &g_453);
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_34 g_31 g_3 g_60 g_55 g_56 g_95 g_96 g_126 g_132 g_329 g_321.f0 g_152 g_388 g_64 g_61.f3 g_321.f3 g_61.f4 g_433
 * writes: g_54 g_61 g_64 g_96 g_132 g_328 g_95 g_56 g_126 g_151 g_152
 */
static int32_t * const  func_35(int32_t  p_36)
{ /* block id: 43 */
    uint32_t l_43 = 0xAF7BDD48L;
    const int32_t *l_334 = &g_152[1][0];
    const int32_t **l_333 = &l_334;
    const int32_t ***l_332 = &l_333;
    int32_t * const l_353 = (void*)0;
    uint16_t l_364 = 0x5A75L;
    int32_t *l_367[10];
    int32_t *l_374 = &g_152[6][1];
    struct S0 l_392 = {0UL};
    int i;
    for (i = 0; i < 10; i++)
        l_367[i] = &g_152[5][4];
    if (func_37(g_34, g_31, g_3, g_3, l_43))
    { /* block id: 188 */
        int32_t **l_335 = &g_96[2];
        int32_t ** const l_336 = (void*)0;
        int32_t *l_371 = (void*)0;
        const int32_t * const *l_373 = &l_334;
        const int32_t * const **l_372 = &l_373;
        p_36 = __builtin_ffsll(l_43);
    }
    else
    { /* block id: 248 */
        int32_t l_391 = 1L;
        struct S0 *l_394[4][8] = {{(void*)0,&g_217,&l_392,(void*)0,&l_392,&g_217,&g_217,&g_217},{&l_392,&l_392,(void*)0,(void*)0,&l_392,&l_392,(void*)0,&l_392},{(void*)0,(void*)0,&l_392,&g_217,&l_392,&l_392,&l_392,&l_392},{&l_392,&g_217,&l_392,&g_217,&l_392,&l_392,&g_217,&l_392}};
        struct S0 ** const l_393[8][6][5] = {{{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[1][7]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[2][0],(void*)0},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[1][7],(void*)0},{&l_394[1][6],&l_394[2][0],&l_394[2][0],&l_394[0][0],&l_394[2][0]},{&l_394[2][0],&l_394[2][0],&l_394[2][2],(void*)0,&l_394[2][1]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],(void*)0,&l_394[3][5]}},{{&l_394[2][0],&l_394[0][0],&l_394[2][0],&l_394[0][0],&l_394[2][0]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[1][7],&l_394[2][2]},{(void*)0,&l_394[2][0],&l_394[2][0],(void*)0,&l_394[2][1]},{&l_394[1][7],&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[2][0]},{(void*)0,(void*)0,&l_394[1][6],&l_394[2][0],&l_394[2][0]},{&l_394[2][0],&l_394[2][2],&l_394[2][0],&l_394[3][4],&l_394[2][0]}},{{&l_394[1][6],&l_394[2][0],&l_394[2][0],(void*)0,&l_394[2][0]},{&l_394[1][6],&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[2][0]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[2][1],&l_394[1][6]},{(void*)0,&l_394[2][0],(void*)0,(void*)0,&l_394[2][0]},{&l_394[1][7],&l_394[3][4],&l_394[2][0],(void*)0,&l_394[3][5]},{&l_394[2][0],&l_394[2][0],&l_394[3][4],&l_394[2][0],&l_394[0][0]}},{{&l_394[2][0],&l_394[2][0],&l_394[2][2],&l_394[2][0],&l_394[3][4]},{&l_394[2][0],&l_394[2][0],(void*)0,&l_394[2][0],&l_394[1][4]},{&l_394[2][0],&l_394[2][0],(void*)0,&l_394[2][0],(void*)0},{&l_394[3][4],&l_394[2][2],&l_394[2][2],&l_394[3][4],&l_394[2][0]},{&l_394[2][0],(void*)0,&l_394[3][4],&l_394[2][1],&l_394[1][7]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[3][5],(void*)0}},{{(void*)0,&l_394[2][1],(void*)0,&l_394[2][1],&l_394[3][4]},{&l_394[0][0],&l_394[2][0],&l_394[2][0],&l_394[3][4],&l_394[3][5]},{(void*)0,(void*)0,&l_394[2][0],&l_394[2][0],&l_394[2][0]},{&l_394[2][1],&l_394[0][0],&l_394[2][0],&l_394[2][0],&l_394[2][0]},{&l_394[2][0],&l_394[3][5],&l_394[2][0],&l_394[2][0],&l_394[3][5]},{&l_394[2][0],&l_394[2][0],&l_394[1][6],&l_394[2][0],&l_394[3][4]}},{{&l_394[2][0],&l_394[2][0],&l_394[2][0],(void*)0,(void*)0},{&l_394[2][0],&l_394[2][1],&l_394[2][0],(void*)0,&l_394[1][7]},{&l_394[2][0],&l_394[2][1],&l_394[2][0],&l_394[2][1],&l_394[2][0]},{&l_394[2][0],&l_394[3][5],&l_394[2][0],&l_394[2][0],(void*)0},{&l_394[2][0],&l_394[2][0],&l_394[2][0],(void*)0,&l_394[1][4]},{&l_394[2][1],&l_394[2][0],&l_394[2][0],&l_394[3][4],&l_394[3][4]}},{{(void*)0,&l_394[3][5],(void*)0,&l_394[2][0],&l_394[0][0]},{&l_394[0][0],&l_394[2][1],&l_394[3][5],&l_394[2][0],&l_394[3][5]},{(void*)0,&l_394[2][1],&l_394[2][0],(void*)0,&l_394[2][0]},{&l_394[2][0],&l_394[2][0],&l_394[3][5],&l_394[3][5],&l_394[1][6]},{&l_394[2][0],&l_394[2][0],(void*)0,(void*)0,&l_394[2][0]},{&l_394[3][4],&l_394[3][5],&l_394[2][0],&l_394[2][0],&l_394[2][0]}},{{&l_394[2][0],&l_394[0][0],&l_394[2][0],&l_394[2][0],&l_394[2][0]},{&l_394[2][0],(void*)0,&l_394[2][0],(void*)0,&l_394[2][0]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[3][5],&l_394[2][0]},{&l_394[2][0],&l_394[2][1],&l_394[2][0],(void*)0,&l_394[2][1]},{&l_394[1][7],&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[2][0]},{&l_394[2][0],&l_394[2][0],&l_394[2][0],&l_394[3][5],(void*)0}}};
        int32_t **l_397 = &l_374;
        int i, j, k;
        if ((l_391 & ((l_392 , p_36) > (g_321.f0 == (g_152[5][4] ^ ((__builtin_ctz(((void*)0 != l_393[5][5][3])) , ((void*)0 == &g_385)) || (**l_333)))))))
        { /* block id: 249 */
            float l_396[1][3];
            int32_t ** const l_398 = &l_374;
            int32_t **l_421[4][6][3] = {{{&g_96[2],&g_96[2],&l_367[8]},{&l_367[8],&g_96[2],(void*)0},{&g_126,(void*)0,(void*)0},{(void*)0,&l_367[8],(void*)0},{(void*)0,(void*)0,&l_367[8]},{&g_126,(void*)0,&l_374}},{{&l_367[8],&g_96[2],&g_126},{&g_96[2],(void*)0,&g_96[2]},{&g_96[2],(void*)0,&g_96[2]},{(void*)0,&l_367[8],&g_96[2]},{(void*)0,(void*)0,&g_96[2]},{&g_96[2],&g_96[2],&g_126}},{{&l_367[8],&g_96[2],&l_374},{&g_96[2],&g_96[1],&l_367[8]},{(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0},{&g_96[2],&g_96[1],(void*)0},{&g_96[2],&g_96[2],&l_367[8]}},{{&l_367[8],&g_96[2],(void*)0},{&g_126,(void*)0,(void*)0},{(void*)0,&l_367[8],(void*)0},{(void*)0,(void*)0,&l_367[8]},{&g_126,(void*)0,&l_374},{&l_367[8],&g_96[2],&g_126}}};
            int i, j, k;
            for (i = 0; i < 1; i++)
            {
                for (j = 0; j < 3; j++)
                    l_396[i][j] = 0x5.0p+1;
            }
            (*g_55) = func_72((p_36 == p_36), ((-0x1.3p-1) > (*g_388)), (*g_95), ((+p_36) , l_397), l_398);
            /* statement id: 250 */
            assert (g_56 == 0);
            if (p_36)
            { /* block id: 251 */
                int16_t l_401 = 0L;
                int32_t l_403 = 0x513D3453L;
                int32_t ***l_408 = &g_95;
                const int32_t * const **l_420 = (void*)0;
                int32_t ****l_425 = &l_408;
                int32_t *****l_424 = &l_425;
                const int32_t ****l_428 = &l_332;
                const int32_t *****l_427 = &l_428;
                if (p_36)
                { /* block id: 252 */
                    uint32_t l_418 = 7UL;
                    int32_t *l_419[5][7] = {{&g_3,&g_34,&g_3,&g_3,&g_34,&g_3,&l_403},{&g_34,&l_403,&g_3,&g_3,&g_34,&g_152[3][0],&g_3},{(void*)0,&g_3,&l_403,&l_403,&l_403,&l_403,&l_403},{&l_403,&l_403,&g_3,&g_3,&g_3,&g_152[3][2],&l_403},{&l_403,&g_34,&g_3,&l_403,&l_403,&g_3,&g_3}};
                    int32_t *****l_426 = &l_425;
                    int i, j;
                    l_403 = (func_79(((p_36 & p_36) ^ g_321.f0)) > func_50((+((+g_61.f3) || (l_401 & g_321.f3)))));
                    /* statement id: 253 */
                    assert (g_126 == &g_3 || g_126 == 0);
                    for (l_401 = 0; (l_401 <= 1); l_401 += 1)
                    { /* block id: 256 */
                        int32_t ***l_407[7];
                        uint32_t l_422 = 0UL;
                        float *l_423 = &g_64;
                        int i;
                        for (i = 0; i < 7; i++)
                            l_407[i] = &l_397;
                        g_151[l_401] = (void*)0;
                        /* statement id: 257 */
                        //assert (g_151[0] == 0 || (g_151[0] >= &g_152[0][0] && g_151[0] <= &g_152[6][4]));
                        (*l_423) = ((safe_sub_func_float_f_f((((g_61.f4 == (0UL >= (g_61.f4 | p_36))) , p_36) != (-0x6.Ap-1)), l_422)) <= (*l_374));
                        l_426 = l_424;
                        return (****l_424);
                        /* statement id: 260 */
                        //assert (func_35_rv == &g_3 || func_35_rv == 0);
                    }
                }
                else
                { /* block id: 262 */
                    (**l_398) = p_36;
                }
                /* facts after branching */
                assert (g_126 == &g_3 || g_126 == 0);
                (*l_427) = &l_332;
            }
            else
            { /* block id: 266 */
                uint8_t l_440 = 1UL;
                int32_t *l_441 = &g_152[3][3];
                (*l_333) = func_72((**l_397), ((safe_div_func_float_f_f((safe_div_func_float_f_f((g_433 , (-0x1.7p-1)), (**l_397))), (safe_div_func_float_f_f(__builtin_bswap64(p_36), (-0x1.Ap-1))))) == (safe_add_func_float_f_f((safe_add_func_float_f_f(((p_36 != l_440) , (-0x5.6p+1)), p_36)), g_61.f3))), l_441, &g_96[2], l_397);
                /* statement id: 267 */
                assert (l_334 == 0);
            }
            /* facts after branching */
            assert (g_126 == &g_3 || g_126 == 0);
            assert (l_334 == 0 || (l_334 >= &g_152[0][0] && l_334 <= &g_152[6][4]));
        }
        else
        { /* block id: 269 */
            (**l_332) = (*g_95);
            /* statement id: 270 */
            assert (l_334 == 0);
        }
        /* facts after branching */
        assert (g_56 == &g_34 || g_56 == 0);
        assert (g_126 == &g_3 || g_126 == 0);
        assert (l_334 == 0 || (l_334 >= &g_152[0][0] && l_334 <= &g_152[6][4]));
    }
    /* facts after branching */
    assert (g_56 == &g_34 || g_56 == 0);
    assert (g_54 == 0);
    //assert (g_96[0] == &g_3 || g_96[0] == &g_34);
    assert (g_95 == &g_126);
    assert (g_126 == &g_3 || g_126 == 0);
    //assert (g_328 == dangling || g_328 == &g_95);
    assert (l_334 == 0 || (l_334 >= &g_152[0][0] && l_334 <= &g_152[6][4]));
    return l_367[7];
    /* statement id: 273 */
    //assert ((func_35_rv >= &g_152[0][0] && func_35_rv <= &g_152[6][4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_60 g_55 g_56 g_95 g_96 g_126 g_132 g_34 g_329
 * writes: g_54 g_61 g_64 g_96 g_132 g_328 g_95
 */
inline static int32_t  func_37(uint64_t  p_38, const uint16_t  p_39, uint16_t  p_40, uint8_t  p_41, int32_t  p_42)
{ /* block id: 44 */
    int32_t *l_65 = &g_3;
    int8_t l_78 = 0xE8L;
    (*g_329) = func_44(func_50(g_3), l_65, p_40, (safe_sub_func_uint16_t_u_u(p_42, func_68(func_72((l_78 & ((l_65 != l_65) & func_79(p_39))), (*l_65), l_65, &l_65, &g_126), g_60.f0, p_39))), p_41);
    /* statement id: 186 */
    assert (g_54 == 0);
    //assert (g_96[0] == &g_3 || g_96[0] == &g_34);
    assert (g_95 == &g_126);
    //assert (g_328 == dangling || g_328 == &g_95);
    return p_42;
}


/* ------------------------------------------ */
/* 
 * reads : g_60.f2 g_95 g_96 g_3 g_34
 * writes: g_96 g_328 g_126
 */
inline static int32_t ** func_44(int64_t  p_45, int32_t * p_46, uint32_t  p_47, int16_t  p_48, int8_t  p_49)
{ /* block id: 79 */
    int16_t l_153[1][9][9] = {{{0L,0L,0xD6BFL,(-1L),2L,(-1L),(-1L),0xE780L,0x0D49L},{1L,0L,0xE780L,0L,2L,2L,0L,0xE780L,0L},{(-1L),0L,0L,1L,2L,0L,1L,0xE780L,0x7282L},{0L,0L,0xD6BFL,(-1L),2L,(-1L),(-1L),0xE780L,0x0D49L},{1L,0L,0xE780L,0L,2L,2L,0L,0xE780L,0L},{(-1L),0L,0L,1L,2L,0L,1L,0xE780L,0x7282L},{0L,0L,0xD6BFL,(-1L),2L,(-1L),(-1L),0xE780L,0x0D49L},{1L,0L,0xE780L,0L,2L,2L,0L,0xE780L,0L},{(-1L),0L,0L,1L,2L,0L,0L,(-8L),0xA393L}}};
    int32_t **l_173 = &g_126;
    float *l_198 = &g_64;
    float l_205[2][6] = {{(-0x3.2p-1),0x2.30EE1Ap-97,0x2.30EE1Ap-97,(-0x3.2p-1),0x2.30EE1Ap-97,0x2.30EE1Ap-97},{(-0x3.2p-1),0x2.30EE1Ap-97,0x2.30EE1Ap-97,(-0x3.2p-1),0x2.30EE1Ap-97,0x2.30EE1Ap-97}};
    struct S0 l_215 = {0UL};
    struct S1 *l_223 = &g_61;
    int32_t l_257 = 0xE4CC4E5DL;
    uint16_t l_309 = 1UL;
    int32_t ** const l_322 = &g_96[4];
    int i, j, k;
    l_153[0][7][4] = (safe_lshift_func_int8_t_s_u((p_49 > g_60.f2), 6));
    (*g_95) = p_46;
    /* statement id: 81 */
    assert (g_126 == 0 || (g_126 >= &g_152[0][0] && g_126 <= &g_152[6][4]));
    for (p_49 = 8; (p_49 >= (-1)); p_49 = safe_sub_func_uint16_t_u_u(p_49, 1))
    { /* block id: 84 */
        int32_t ** const *l_169 = (void*)0;
        int32_t ** const * const *l_168 = &l_169;
        float *l_199 = &g_64;
        struct S1 *l_213 = &g_61;
        const uint8_t l_244 = 0x31L;
        int32_t **l_260 = &g_96[2];
        const struct S0 *l_274 = &l_215;
        int32_t *l_278 = &g_152[5][4];
    }
    for (l_309 = 0; (l_309 < 24); l_309++)
    { /* block id: 181 */
        int32_t *l_325 = &l_257;
        int32_t ** const *l_327 = &l_322;
        int32_t ** const **l_326[1][4][5] = {{{&l_327,&l_327,&l_327,&l_327,&l_327},{&l_327,&l_327,&l_327,&l_327,&l_327},{&l_327,&l_327,&l_327,&l_327,&l_327},{&l_327,&l_327,&l_327,&l_327,&l_327}}};
        int i, j, k;
        (*l_325) = (**l_322);
        g_328 = &l_322;
        /* statement id: 183 */
        assert (g_328 == &l_322);
    }
    /* facts after for loop */
    //assert (g_328 == &l_322 || g_328 == &g_95 || g_328 == dangling);
    return &g_126;
    /* statement id: 185 */
    //assert (g_328 == dangling || g_328 == &g_95);
    //assert (func_44_rv == &g_126);
}


/* ------------------------------------------ */
/* 
 * reads : g_60 g_55 g_56 g_3
 * writes: g_54 g_61 g_64
 */
static int64_t  func_50(int16_t  p_51)
{ /* block id: 45 */
    uint8_t l_53 = 0UL;
    int32_t *l_59 = &g_34;
    float *l_63 = &g_64;
    g_54 = ((!(l_53 || p_51)) , (void*)0);
    /* statement id: 46 */
    assert (g_54 == 0);
    g_61 = func_57(l_59);
    (*l_63) = (+((*g_55) == l_59));
    return g_3;
}


/* ------------------------------------------ */
/* 
 * reads : g_60
 * writes:
 */
inline static struct S1  func_57(int32_t * p_58)
{ /* block id: 47 */
    return g_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_132 g_60.f3 g_34 g_60.f0
 * writes: g_132
 */
static uint16_t  func_68(int32_t * p_69, uint16_t  p_70, int32_t  p_71)
{ /* block id: 76 */
    const int32_t *l_143 = &g_3;
    const int32_t * const *l_142[3][8] = {{&l_143,&l_143,&l_143,&l_143,&l_143,&l_143,&l_143,&l_143},{(void*)0,&l_143,&l_143,(void*)0,&l_143,(void*)0,&l_143,&l_143},{&l_143,&l_143,&l_143,&l_143,&l_143,&l_143,&l_143,&l_143}};
    float *l_146 = (void*)0;
    float *l_147 = (void*)0;
    float *l_148 = &g_132;
    int i, j;
    (*l_148) = ((!((safe_div_func_float_f_f((safe_div_func_float_f_f(((__builtin_ffs(((void*)0 == p_69)) >= (g_132 != (((safe_mul_func_float_f_f(((safe_mul_func_float_f_f(0x1.8p-1, g_60.f3)) >= ((((void*)0 != l_142[0][3]) , (((safe_add_func_int32_t_s_s((p_70 , (*p_69)), (*p_69))) | p_70) , (void*)0)) == &p_69)), 0x2.E06C79p-75)) == g_60.f0) == p_71))) > p_71), p_71)), (-0x1.Dp-1))) >= g_34)) <= g_3);
    return p_70;
}


/* ------------------------------------------ */
/* 
 * reads : g_60.f0 g_95 g_96 g_126
 * writes: g_132
 */
inline static int32_t * func_72(int32_t  p_73, float  p_74, int32_t * p_75, int32_t ** p_76, int32_t ** const  p_77)
{ /* block id: 69 */
    for (p_73 = 18; (p_73 <= (-15)); --p_73)
    { /* block id: 72 */
        float *l_131 = &g_132;
        (*l_131) = g_60.f0;
    }
    return (*g_95);
    /* statement id: 75 */
    //assert (func_72_rv == &g_3 || func_72_rv == &g_34 || func_72_rv == 0 || (func_72_rv >= &g_152[0][0] && func_72_rv <= &g_152[6][4]));
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_60.f0 g_60.f3 g_95 g_60.f2 g_96 g_126
 * writes: g_96 g_126
 */
static uint8_t  func_79(int32_t  p_80)
{ /* block id: 52 */
    int32_t *l_88 = &g_3;
    const int32_t * const *l_90 = (void*)0;
    const int32_t * const **l_89 = &l_90;
    if ((safe_sub_func_uint16_t_u_u(0x1810L, (func_83(l_88, l_89, (safe_add_func_int32_t_s_s(((safe_sub_func_int64_t_s_s((((*l_88) , g_60.f0) >= 0x06L), ((g_60.f3 < ((l_88 == l_88) <= g_3)) , g_60.f3))) ^ g_60.f3), g_60.f0)), g_95) <= p_80))))
    { /* block id: 64 */
        return p_80;
    }
    else
    { /* block id: 66 */
        return p_80;
    }
}


/* ------------------------------------------ */
/* 
 * reads : g_60.f2 g_95 g_96 g_126 g_3
 * writes: g_96 g_126 g_452
 */
static int32_t  func_83(int32_t * p_84, const int32_t * const ** p_85, int32_t  p_86, int32_t ** p_87)
{ /* block id: 53 */
    uint32_t l_107 = 0UL;
    uint16_t l_110 = 65535UL;
    int32_t *l_128 = &g_3;
    for (p_86 = 0; (p_86 != 5); p_86++)
    { /* block id: 56 */
        uint32_t l_127 = 0x4BB8EBACL;
        l_127 = ((safe_sub_func_float_f_f(((safe_mod_func_int8_t_s_s((safe_rshift_func_int16_t_s_s(g_60.f2, 5)), (safe_lshift_func_uint16_t_u_u(l_107, ((((l_107 | ((safe_rshift_func_uint16_t_u_u((((l_110 | (safe_unary_minus_func_int32_t_s((safe_add_func_uint8_t_u_u((safe_div_func_int16_t_s_s(((safe_mul_func_int8_t_s_s((safe_lshift_func_uint8_t_u_u(((~(~p_86)) && ((void*)0 != (*g_95))), 7)), (safe_rshift_func_uint8_t_u_u(l_110, 0)))) , (safe_mul_func_int16_t_s_s(((p_86 , g_126) == (*g_95)), p_86))), 0x80F5L)), (-7L)))))) , (*g_95)) != (void*)0), p_86)) || p_86)) <= l_107) | 0x669BA90DL) >= l_107))))) , p_86), p_86)) >= 0x1.9p+1);
        for (l_127 = 0; l_127 < 6; l_127 += 1)
        {
            g_96[l_127] = &g_34;
        }
        if (l_127)
            continue;
        (*p_85) = (void*)0;
    }
    (*p_87) = l_128;
    return (*l_128);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_30, "g_30", print_hash_value);
    transparent_crc(g_31, "g_31", print_hash_value);
    transparent_crc(g_32, "g_32", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_34, "g_34", print_hash_value);
    transparent_crc(g_60.f0, "g_60.f0", print_hash_value);
    transparent_crc(g_60.f1, "g_60.f1", print_hash_value);
    transparent_crc(g_60.f2, "g_60.f2", print_hash_value);
    transparent_crc(g_60.f3, "g_60.f3", print_hash_value);
    transparent_crc(g_60.f4, "g_60.f4", print_hash_value);
    transparent_crc(g_61.f0, "g_61.f0", print_hash_value);
    transparent_crc(g_61.f1, "g_61.f1", print_hash_value);
    transparent_crc(g_61.f2, "g_61.f2", print_hash_value);
    transparent_crc(g_61.f3, "g_61.f3", print_hash_value);
    transparent_crc(g_61.f4, "g_61.f4", print_hash_value);
    transparent_crc_bytes (&g_64, sizeof(g_64), "g_64", print_hash_value);
    transparent_crc_bytes (&g_132, sizeof(g_132), "g_132", print_hash_value);
    for (i = 0; i < 7; i++)
    {
        for (j = 0; j < 5; j++)
        {
            transparent_crc(g_152[i][j], "g_152[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    for (i = 0; i < 2; i++)
    {
        transparent_crc(g_197[i].f0, "g_197[i].f0", print_hash_value);
        transparent_crc(g_197[i].f1, "g_197[i].f1", print_hash_value);
        transparent_crc(g_197[i].f2, "g_197[i].f2", print_hash_value);
        transparent_crc(g_197[i].f3, "g_197[i].f3", print_hash_value);
        transparent_crc(g_197[i].f4, "g_197[i].f4", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_201.f0, "g_201.f0", print_hash_value);
    transparent_crc(g_201.f1, "g_201.f1", print_hash_value);
    transparent_crc(g_201.f2, "g_201.f2", print_hash_value);
    transparent_crc(g_201.f3, "g_201.f3", print_hash_value);
    transparent_crc(g_201.f4, "g_201.f4", print_hash_value);
    transparent_crc(g_217.f0, "g_217.f0", print_hash_value);
    transparent_crc(g_243, "g_243", print_hash_value);
    transparent_crc(g_321.f0, "g_321.f0", print_hash_value);
    transparent_crc(g_321.f1, "g_321.f1", print_hash_value);
    transparent_crc(g_321.f2, "g_321.f2", print_hash_value);
    transparent_crc(g_321.f3, "g_321.f3", print_hash_value);
    transparent_crc(g_321.f4, "g_321.f4", print_hash_value);
    transparent_crc(g_385.f0, "g_385.f0", print_hash_value);
    transparent_crc(g_433.f0, "g_433.f0", print_hash_value);
    transparent_crc(g_433.f1, "g_433.f1", print_hash_value);
    transparent_crc(g_433.f2, "g_433.f2", print_hash_value);
    transparent_crc(g_433.f3, "g_433.f3", print_hash_value);
    transparent_crc(g_433.f4, "g_433.f4", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 108
   depth: 1, occurrence: 6
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 9
breakdown:
   indirect level: 0, occurrence: 4
   indirect level: 1, occurrence: 5
XXX full-bitfields structs in the program: 4
breakdown:
   indirect level: 0, occurrence: 4
XXX times a bitfields struct's address is taken: 13
XXX times a bitfields struct on LHS: 1
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 51

XXX max expression depth: 27
breakdown:
   depth: 1, occurrence: 54
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 6, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 16, occurrence: 2
   depth: 20, occurrence: 1
   depth: 22, occurrence: 1
   depth: 27, occurrence: 1

XXX total number of pointers: 113

XXX times a variable address is taken: 310
XXX times a pointer is dereferenced on RHS: 58
breakdown:
   depth: 1, occurrence: 42
   depth: 2, occurrence: 15
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 43
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 3
XXX times a pointer is compared with null: 13
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 544

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 211
   level: 2, occurrence: 68
   level: 3, occurrence: 4
   level: 4, occurrence: 11
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 56
XXX number of pointers point to scalars: 46
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 34.5
XXX average alias set size: 1.6

XXX times a non-volatile is read: 498
XXX times a non-volatile is write: 116
XXX times a volatile is read: 29
XXX    times read thru a pointer: 3
XXX times a volatile is write: 17
XXX    times written thru a pointer: 6
XXX times a volatile is available for access: 280
XXX percentage of non-volatile access: 93

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 52
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 25
   depth: 1, occurrence: 14
   depth: 2, occurrence: 3
   depth: 3, occurrence: 3
   depth: 4, occurrence: 3
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 18.3
XXX percentage an existing variable is used: 81.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

