/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1956653276
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_1(void);
static int32_t * func_5(uint32_t  p_6, uint32_t  p_7);
static int16_t  func_9(uint32_t  p_10, int32_t * p_11);
static int32_t * func_15(uint32_t  p_16, int32_t ** p_17, int32_t ** p_18, uint16_t  p_19);
static uint32_t  func_20(int32_t * const  p_21, uint32_t  p_22, uint16_t  p_23, int8_t  p_24, int32_t * p_25);
static int32_t * const  func_26(uint32_t  p_27);
static uint32_t  func_28(int32_t  p_29, int32_t ** p_30);
static int32_t * func_34(int32_t  p_35, int32_t  p_36, int16_t  p_37);
static int32_t  func_40(uint32_t  p_41, uint16_t  p_42, uint32_t  p_43, int32_t  p_44);
static uint32_t  func_47(uint32_t  p_48, int16_t  p_49);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_1(void)
{ /* block id: 0 */
    int32_t *l_2 = (void*)0;
    int32_t **l_3 = (void*)0;
    int32_t **l_4 = &l_2;
    int32_t l_8 = (-4L);
    uint16_t l_177 = 0xA3A3L;
    int16_t l_218 = 0x8775L;
    (*l_4) = l_2;
    (*l_4) = func_5((l_8 | func_9((((((~0xF5D870A3L) & l_8) ^ 65532UL) != l_8) || (safe_add_func_int32_t_s_s((l_8 ^ l_8), l_8))), func_15(func_20(func_26(func_28(((*l_4) == (*l_4)), &l_2)), l_8, l_8, l_8, &l_8), l_3, l_3, l_177))), l_218);
    (*l_4) = (*l_4);
    return l_8;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_5(uint32_t  p_6, uint32_t  p_7)
{ /* block id: 78 */
    int32_t l_220 = 0xBCD83B64L;
    int32_t *l_219 = &l_220;
    int32_t *l_221 = &l_220;
    int32_t *l_222 = &l_220;
    int32_t *l_223 = &l_220;
    int32_t *l_224 = (void*)0;
    l_219 = l_219;
    (*l_219) = p_7;
    return l_224;
    /* statement id: 81 */
    //assert (func_5_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_9(uint32_t  p_10, int32_t * p_11)
{ /* block id: 75 */
    int32_t l_217 = 0x05243415L;
    int32_t *l_216 = &l_217;
    int32_t **l_215 = &l_216;
    l_215 = l_215;
    return p_10;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_15(uint32_t  p_16, int32_t ** p_17, int32_t ** p_18, uint16_t  p_19)
{ /* block id: 61 */
    const uint32_t l_186 = 18446744073709551610UL;
    int32_t *l_194 = (void*)0;
    int32_t **l_193 = &l_194;
    int32_t ***l_192 = &l_193;
    int32_t l_197 = 0x5992523FL;
    const uint32_t l_198 = 0UL;
    int32_t l_205 = 0x3EF12D64L;
    int32_t *l_204 = &l_205;
    int32_t *l_206 = (void*)0;
    const int32_t *l_209 = &l_205;
    int32_t *l_212 = &l_205;
    int32_t *l_213 = &l_205;
    int32_t *l_214 = (void*)0;
    if ((safe_add_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(0x6D48L, (safe_rshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((l_186 > (safe_add_func_uint32_t_u_u((safe_unary_minus_func_int32_t_s(((p_19 & (safe_lshift_func_int16_t_s_s((p_19 > (((p_16 == (((void*)0 != l_192) | (safe_add_func_int16_t_s_s(((*l_192) != (void*)0), 7L)))) || l_197) > l_198)), p_16))) ^ 0x4B02CD46L))), 0xC243BE05L))), 0)), p_16)))), 0x9448L)))
    { /* block id: 62 */
        int32_t *** const *l_203 = &l_192;
        for (l_197 = (-1); (l_197 > 10); l_197 = safe_add_func_int16_t_s_s(l_197, 4))
        { /* block id: 65 */
            int32_t l_202 = 0x70074BB8L;
            int32_t *l_201 = &l_202;
            (**l_192) = l_201;
            /* statement id: 66 */
            assert (l_194 == &l_202);
            (****l_203) = (l_203 != &l_192);
        }
        /* facts after for loop */
        //assert (l_194 == dangling || l_194 == 0);
        return l_206;
        /* statement id: 69 */
        //assert (func_15_rv == 0);
    }
    else
    { /* block id: 70 */
        int32_t *l_210 = &l_205;
        int32_t *l_211 = &l_205;
        (*l_204) = 0L;
        (*l_211) = (((0xB72A3349L && p_19) < (p_16 | (((safe_rshift_func_uint16_t_u_s(((*l_204) <= (((l_209 == l_210) ^ ((void*)0 != (*l_192))) ^ (((l_211 == l_211) != 0x7D8B5B9DL) > (*l_204)))), 2)) > p_19) != (*l_211)))) != (-10L));
    }
    return l_214;
    /* statement id: 74 */
    //assert (func_15_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_20(int32_t * const  p_21, uint32_t  p_22, uint16_t  p_23, int8_t  p_24, int32_t * p_25)
{ /* block id: 30 */
    int32_t l_116 = 0x5F25790EL;
    int32_t *l_115 = &l_116;
    int32_t **l_114 = &l_115;
    int32_t ***l_113 = &l_114;
    int32_t *l_122 = &l_116;
    uint32_t l_172 = 8UL;
    if ((((p_24 < (l_113 == &l_114)) || (1L | (((p_22 <= ((p_21 == (*l_114)) | (safe_rshift_func_int16_t_s_u(((!(&p_25 != (*l_113))) ^ (***l_113)), (*l_115))))) >= (-4L)) | (**l_114)))) != (**l_114)))
    { /* block id: 31 */
        int32_t *l_120 = &l_116;
        int32_t **** const l_121 = &l_113;
        uint16_t l_138 = 0x5B67L;
        int32_t *l_149 = &l_116;
        int8_t l_163 = 0xC7L;
        (*l_114) = l_120;
        (***l_113) = (-1L);
        if (((((l_121 == &l_113) || ((***l_121) != l_122)) && p_22) == ((((****l_121) <= (((((void*)0 == (**l_113)) < (*l_120)) ^ (****l_121)) >= 1UL)) & p_22) >= 0xE69A2289L)))
        { /* block id: 34 */
            int16_t l_130 = 0x6326L;
            int32_t ***l_145 = &l_114;
            (***l_113) = ((****l_121) & (safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u(p_24, 9)), (safe_add_func_int32_t_s_s((~l_130), ((****l_121) & ((-1L) != ((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(((~(((p_22 || l_138) >= (safe_mod_func_int32_t_s_s((1UL != ((((safe_sub_func_int32_t_s_s(((((safe_rshift_func_int16_t_s_s(9L, 3)) < 0x19F0L) == l_130) > (*p_25)), (***l_113))) ^ p_24) <= l_130) < (*l_120))), l_130))) > 0x931FL)) ^ (*l_120)), p_23)), 1)), 7)) < (****l_121)))))))));
            (***l_121) = p_25;
            /* statement id: 36 */
            //assert (l_115 == &l_8);
            p_25 = (***l_121);
            (*l_149) = ((l_145 == l_145) >= (0xEA3A5B7FL ^ (((!(l_121 != l_121)) || (((safe_lshift_func_uint16_t_u_s((***l_145), 0)) || (p_21 != l_149)) < (~(safe_mod_func_int32_t_s_s((((***l_145) >= 0x17623E6EL) > p_22), 5UL))))) < p_23)));
        }
        else
        { /* block id: 39 */
            int32_t ****l_159 = &l_113;
            for (l_116 = (-17); (l_116 >= (-21)); l_116 = safe_sub_func_uint16_t_u_u(l_116, 1))
            { /* block id: 42 */
                int32_t l_156 = (-7L);
                int32_t *l_155 = &l_156;
                (*l_155) = (*p_25);
                (*l_155) = (safe_lshift_func_int16_t_s_s((*l_115), ((((void*)0 != l_159) || (-1L)) < (0x6F90L != (((((!((p_24 == (*p_25)) > (((safe_lshift_func_int16_t_s_s(0L, 11)) && 0xFF2045DDL) > l_163))) || p_24) ^ (*l_115)) == 5L) | p_24)))));
            }
        }
        /* facts after branching */
        //assert (l_115 == &l_116 || l_115 == &l_8);
    }
    else
    { /* block id: 47 */
        int8_t l_166 = 0xC6L;
        int32_t ****l_168 = (void*)0;
        int32_t ****l_169 = &l_113;
lbl_167:
        for (p_24 = 0; (p_24 < 27); p_24 = safe_add_func_int16_t_s_s(p_24, 1))
        { /* block id: 50 */
            (**l_113) = p_25;
            /* statement id: 51 */
            //assert (l_115 == &l_8);
            if (p_23)
                goto lbl_167;
            return l_166;
        }
        (*l_169) = &l_114;
        return p_23;
    }
    /* facts after branching */
    //assert (l_115 == &l_116 || l_115 == &l_8);
    p_25 = (**l_113);
    /* statement id: 58 */
    //assert (p_25 == &l_116 || p_25 == &l_8);
    (*l_122) = ((***l_113) || ((*p_25) <= (((safe_lshift_func_int16_t_s_s((l_172 >= (*l_115)), p_23)) ^ ((***l_113) ^ ((safe_sub_func_uint16_t_u_u((*l_115), p_23)) < ((&l_114 != (void*)0) >= 1L)))) > (-1L))));
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_26(uint32_t  p_27)
{ /* block id: 19 */
    uint16_t l_85 = 65535UL;
    int32_t l_92 = 0x58DD5D93L;
    int32_t *l_91 = &l_92;
    int32_t **l_90 = &l_91;
    int32_t l_93 = (-1L);
    const int32_t l_100 = 0xE889C39DL;
    int32_t * const l_104 = (void*)0;
    int32_t * const l_105 = &l_92;
    int32_t * const l_106 = &l_92;
    int32_t * const l_107 = &l_92;
    int32_t * const l_108 = &l_92;
    int32_t * const l_109 = &l_92;
    int32_t * const l_110 = &l_92;
    int32_t * const l_111 = &l_92;
    int32_t * const l_112 = (void*)0;
    (*l_91) = (safe_mod_func_int16_t_s_s(l_85, ((safe_add_func_int32_t_s_s((safe_mod_func_int32_t_s_s(p_27, ((l_90 == &l_91) ^ 4294967295UL))), l_93)) ^ (safe_lshift_func_int16_t_s_s(((**l_90) | (safe_rshift_func_int16_t_s_s((safe_sub_func_uint16_t_u_u(p_27, p_27)), 15))), l_100)))));
    for (l_85 = 0; (l_85 <= 17); l_85 = safe_add_func_int32_t_s_s(l_85, 1))
    { /* block id: 23 */
        int32_t l_103 = 0xF5D7AD18L;
        if (l_103)
            break;
        (*l_90) = (*l_90);
        if ((*l_91))
            continue;
        return l_104;
        /* statement id: 27 */
        //assert (func_26_rv == 0);
    }
    return l_112;
    /* statement id: 29 */
    //assert (func_26_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_28(int32_t  p_29, int32_t ** p_30)
{ /* block id: 2 */
    int32_t **l_33 = (void*)0;
    int32_t ***l_32 = &l_33;
    int32_t ****l_31 = &l_32;
    int32_t l_67 = (-1L);
    (*l_31) = &p_30;
    /* statement id: 3 */
    assert (l_32 == &p_30);
    (***l_31) = func_34(p_29, ((safe_mod_func_int16_t_s_s(((func_40(p_29, (((safe_add_func_int16_t_s_s((((void*)0 != &l_32) <= func_47(p_29, p_29)), (safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_u(p_29, ((safe_rshift_func_int16_t_s_s(p_29, p_29)) && p_29))), 10)), 10)))) >= p_29) & p_29), l_67, p_29) >= p_29) == p_29), p_29)) | p_29), l_67);
    return p_29;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(int32_t  p_35, int32_t  p_36, int16_t  p_37)
{ /* block id: 12 */
    int32_t l_69 = (-1L);
    int32_t *l_68 = &l_69;
    int32_t **l_70 = &l_68;
    int32_t *l_71 = &l_69;
    int32_t ***l_76 = (void*)0;
    int32_t ****l_75 = &l_76;
    int32_t *l_77 = &l_69;
    int32_t *l_78 = &l_69;
    int32_t *l_79 = &l_69;
    int32_t *l_80 = &l_69;
    int32_t *l_81 = &l_69;
    int32_t *l_82 = (void*)0;
    (*l_70) = l_68;
    (*l_70) = l_71;
    (*l_71) = (!(safe_mod_func_int32_t_s_s(((void*)0 != l_75), p_37)));
    return l_82;
    /* statement id: 16 */
    //assert (func_34_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_40(uint32_t  p_41, uint16_t  p_42, uint32_t  p_43, int32_t  p_44)
{ /* block id: 10 */
    return p_41;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_47(uint32_t  p_48, int16_t  p_49)
{ /* block id: 4 */
    int32_t l_51 = 0xF4AEDF2FL;
    int32_t *l_50 = &l_51;
    int32_t **l_52 = &l_50;
    int32_t * const l_57 = &l_51;
    (*l_52) = l_50;
    (**l_52) = (**l_52);
    (**l_52) = ((safe_add_func_uint32_t_u_u(((safe_add_func_int16_t_s_s((65533UL & 0x10C3L), (((((l_57 == (*l_52)) != (p_48 <= p_48)) | ((~(**l_52)) | (((0xC0838563L <= ((*l_52) != (void*)0)) && (*l_50)) >= 1L))) >= (*l_57)) != p_49))) >= 4294967295UL), (*l_57))) == (*l_50));
    (*l_52) = (*l_52);
    return p_48;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 62
XXX total union variables: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 5
   depth: 3, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 2

XXX total number of pointers: 73

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 51
breakdown:
   depth: 1, occurrence: 31
   depth: 2, occurrence: 7
   depth: 3, occurrence: 8
   depth: 4, occurrence: 5
XXX times a pointer is dereferenced on LHS: 29
breakdown:
   depth: 1, occurrence: 20
   depth: 2, occurrence: 4
   depth: 3, occurrence: 4
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 8
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 609

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 62
   level: 2, occurrence: 32
   level: 3, occurrence: 24
   level: 4, occurrence: 16
XXX number of pointers point to pointers: 24
XXX number of pointers point to scalars: 49
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.4
XXX average alias set size: 1.05

XXX times a non-volatile is read: 281
XXX times a non-volatile is write: 81
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 0

XXX stmts: 57
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 14
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2

XXX percentage a fresh-made variable is used: 7.59
XXX percentage an existing variable is used: 92.4
********************* end of statistics **********************/

