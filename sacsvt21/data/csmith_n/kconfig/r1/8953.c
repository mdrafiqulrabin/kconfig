/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --uint8 --float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1223983864
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 10;
};

/* --- GLOBAL VARIABLES --- */
static uint8_t g_3 = 0UL;
static int32_t g_67 = 0x315BFEB1L;
static struct S0 g_109 = {-21};
static int32_t *g_113 = (void*)0;
static int32_t g_132 = 0x9AB2FCBAL;
static int32_t * volatile g_131[4] = {&g_132,&g_132,&g_132,&g_132};
static int32_t * volatile g_156 = &g_132;/* VOLATILE GLOBAL g_156 */
static int16_t g_166 = (-1L);
static int32_t * volatile g_175 = &g_132;/* VOLATILE GLOBAL g_175 */
static int32_t ** volatile g_199[6] = {&g_113,&g_113,&g_113,&g_113,&g_113,&g_113};
static struct S0 *g_204[2][9] = {{&g_109,&g_109,(void*)0,&g_109,&g_109,(void*)0,&g_109,&g_109,(void*)0},{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109}};
static struct S0 **g_203 = &g_204[0][1];
static struct S0 *** volatile g_202[9][1][6] = {{{(void*)0,(void*)0,&g_203,(void*)0,&g_203,&g_203}},{{(void*)0,&g_203,&g_203,&g_203,(void*)0,&g_203}},{{&g_203,(void*)0,&g_203,(void*)0,(void*)0,&g_203}},{{&g_203,&g_203,(void*)0,&g_203,(void*)0,(void*)0}},{{&g_203,(void*)0,(void*)0,(void*)0,&g_203,(void*)0}},{{(void*)0,&g_203,(void*)0,&g_203,&g_203,(void*)0}},{{&g_203,&g_203,(void*)0,&g_203,(void*)0,(void*)0}},{{&g_203,(void*)0,(void*)0,(void*)0,&g_203,(void*)0}},{{(void*)0,&g_203,(void*)0,&g_203,&g_203,(void*)0}}};
static struct S0 *** volatile g_205 = &g_203;/* VOLATILE GLOBAL g_205 */
static uint64_t g_215 = 0x209CF466BE125798LL;
static float g_241 = 0x0.C314D7p+28;
static float * volatile g_240[5][5] = {{&g_241,&g_241,&g_241,&g_241,&g_241},{&g_241,&g_241,&g_241,&g_241,&g_241},{&g_241,&g_241,&g_241,&g_241,&g_241},{&g_241,&g_241,&g_241,&g_241,&g_241},{&g_241,&g_241,&g_241,&g_241,&g_241}};
static float * volatile g_242 = &g_241;/* VOLATILE GLOBAL g_242 */
static int32_t ** volatile g_263[7] = {&g_113,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113};
static int32_t ** volatile g_264 = (void*)0;/* VOLATILE GLOBAL g_264 */
static volatile int32_t g_286 = 5L;/* VOLATILE GLOBAL g_286 */
static volatile int32_t * volatile g_285 = &g_286;/* VOLATILE GLOBAL g_285 */
static volatile int32_t * volatile * volatile g_287 = (void*)0;/* VOLATILE GLOBAL g_287 */
static volatile int32_t * volatile * volatile g_288 = &g_285;/* VOLATILE GLOBAL g_288 */
static int32_t ** volatile g_325 = &g_113;/* VOLATILE GLOBAL g_325 */
static struct S0 ***g_330[4][9] = {{(void*)0,(void*)0,&g_203,(void*)0,(void*)0,(void*)0,&g_203,(void*)0,(void*)0},{&g_203,&g_203,(void*)0,(void*)0,(void*)0,&g_203,&g_203,&g_203,&g_203},{(void*)0,&g_203,&g_203,&g_203,(void*)0,(void*)0,(void*)0,(void*)0,&g_203},{&g_203,(void*)0,&g_203,(void*)0,&g_203,&g_203,(void*)0,&g_203,(void*)0}};
static struct S0 ****g_329 = &g_330[1][4];
static struct S0 ***** volatile g_328[10] = {&g_329,(void*)0,&g_329,&g_329,(void*)0,&g_329,&g_329,(void*)0,&g_329,&g_329};
static uint32_t g_370 = 0UL;
static struct S0 ***** volatile g_372 = (void*)0;/* VOLATILE GLOBAL g_372 */
static struct S0 ***** volatile g_373 = &g_329;/* VOLATILE GLOBAL g_373 */
static float * volatile g_379 = (void*)0;/* VOLATILE GLOBAL g_379 */
static struct S0 * volatile g_383 = (void*)0;/* VOLATILE GLOBAL g_383 */
static float * volatile g_403 = &g_241;/* VOLATILE GLOBAL g_403 */
static int32_t ** volatile g_464 = (void*)0;/* VOLATILE GLOBAL g_464 */
static struct S0 * volatile g_468 = &g_109;/* VOLATILE GLOBAL g_468 */
static int32_t ** volatile g_530 = &g_113;/* VOLATILE GLOBAL g_530 */
static int32_t ** volatile g_540[8] = {&g_113,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113};
static int32_t g_598 = (-1L);
static int32_t ** volatile g_613[4][5][1] = {{{&g_113},{&g_113},{&g_113},{&g_113},{&g_113}},{{&g_113},{(void*)0},{&g_113},{(void*)0},{&g_113}},{{&g_113},{&g_113},{&g_113},{&g_113},{&g_113}},{{&g_113},{(void*)0},{&g_113},{(void*)0},{&g_113}}};
static const int32_t * const  volatile g_619 = (void*)0;/* VOLATILE GLOBAL g_619 */
static const int32_t * const  volatile * volatile g_618 = &g_619;/* VOLATILE GLOBAL g_618 */
static const int32_t * const  volatile * volatile *g_617 = &g_618;
static const int32_t * const  volatile * volatile * volatile *g_616 = &g_617;
static const int32_t * volatile g_627 = (void*)0;/* VOLATILE GLOBAL g_627 */
static const int32_t * volatile * volatile g_626 = &g_627;/* VOLATILE GLOBAL g_626 */
static float *g_644 = &g_241;
static float **g_643 = &g_644;
static const int32_t *g_673[10] = {&g_132,&g_598,&g_598,&g_132,&g_598,&g_598,&g_132,&g_598,&g_598,&g_132};
static const int32_t ** volatile g_672 = &g_673[6];/* VOLATILE GLOBAL g_672 */
static struct S0 ***** volatile g_706 = &g_329;/* VOLATILE GLOBAL g_706 */
static const int32_t ** volatile g_735 = &g_673[6];/* VOLATILE GLOBAL g_735 */
static int32_t g_736[6] = {0x368ADBAEL,0x368ADBAEL,0x368ADBAEL,0x368ADBAEL,0x368ADBAEL,0x368ADBAEL};
static struct S0 ** volatile g_745 = &g_204[1][0];/* VOLATILE GLOBAL g_745 */
static volatile uint64_t g_750 = 18446744073709551613UL;/* VOLATILE GLOBAL g_750 */
static volatile float * volatile **g_753 = (void*)0;
static volatile float * volatile ** volatile *g_752 = &g_753;
static int32_t * volatile g_756 = &g_736[0];/* VOLATILE GLOBAL g_756 */
static int32_t **g_783 = &g_113;
static int32_t ***g_782 = &g_783;
static int32_t **** volatile g_781 = &g_782;/* VOLATILE GLOBAL g_781 */
static struct S0 * volatile g_793 = &g_109;/* VOLATILE GLOBAL g_793 */
static const int32_t ** volatile g_794 = (void*)0;/* VOLATILE GLOBAL g_794 */
static const struct S0 * const g_809 = &g_109;
static const struct S0 * const *g_808 = &g_809;
static const struct S0 * const **g_807 = &g_808;
static const struct S0 * const ***g_806 = &g_807;
static const struct S0 * const *** const *g_805 = &g_806;
static const int32_t * volatile * volatile g_836[4][10] = {{&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627},{&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627},{&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627},{&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627,&g_627}};
static const int32_t * volatile * volatile g_837[1] = {&g_673[0]};
static const int32_t * volatile * volatile g_838 = &g_673[6];/* VOLATILE GLOBAL g_838 */
static const int32_t ** volatile g_877 = &g_673[6];/* VOLATILE GLOBAL g_877 */
static struct S0 g_884 = {-14};
static int32_t * volatile g_920 = &g_736[0];/* VOLATILE GLOBAL g_920 */


/* --- FORWARD DECLARATIONS --- */
inline static int64_t  func_28(void);
inline static int32_t * func_29(int32_t  p_30, int32_t * p_31);
inline static int32_t  func_32(uint32_t  p_33, int8_t  p_34, int32_t * p_35, uint32_t  p_36);
inline static int32_t  func_45(uint32_t  p_46, int32_t * p_47, int32_t * p_48, uint64_t  p_49);
inline static uint16_t  func_52(uint64_t  p_53, struct S0  p_54, struct S0  p_55, int32_t * p_56, uint32_t  p_57);
inline static int64_t  func_60(const int32_t * p_61, const struct S0  p_62);
static const struct S0  func_64(const int32_t  p_65);
inline static int32_t * func_73(int32_t * p_74);
inline static int32_t * func_75(uint8_t  p_76);
inline static uint32_t  func_79(const uint32_t  p_80, struct S0  p_81, int32_t  p_82, uint32_t  p_83);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_67 g_109.f0 g_132 g_156 g_175 g_166 g_205 g_215 g_242 g_203 g_109 g_598 g_403 g_241 g_370 g_286 g_617 g_618 g_619 g_672 g_644 g_373 g_329 g_330 g_530 g_113 g_673 g_706 g_468 g_643 g_285 g_735 g_736 g_745 g_750 g_131 g_752 g_756 g_781 g_783 g_325 g_793 g_807 g_808 g_809 g_288 g_616 g_838 g_877 g_884 g_920
 * writes: g_67 g_109 g_113 g_132 g_166 g_203 g_241 g_215 g_204 g_643 g_673 g_598 g_329 g_131 g_370 g_752 g_736 g_328 g_782 g_330 g_805 g_627
 */
inline static int64_t  func_28(void)
{ /* block id: 36 */
    const int32_t *l_63 = (void*)0;
    int32_t *l_66[1];
    uint32_t l_68 = 4294967295UL;
    struct S0 l_826 = {-10};
    const int16_t l_881 = (-7L);
    int32_t ****l_941 = &g_782;
    int32_t *****l_940 = &l_941;
    uint32_t l_946 = 18446744073709551613UL;
    const int32_t *l_947 = &g_132;
    const struct S0 l_948 = {-23};
    const uint64_t l_955 = 0x26D757B8621C11CALL;
    int i;
    for (i = 0; i < 1; i++)
        l_66[i] = &g_67;
    l_66[0] = func_29(func_32(g_3, (((safe_div_func_int8_t_s_s((safe_sub_func_uint32_t_u_u(((g_3 , ((g_3 < g_3) , (safe_mod_func_uint32_t_u_u(4294967295UL, (safe_mul_func_int16_t_s_s(((func_45(((safe_add_func_uint16_t_u_u(func_52((safe_div_func_uint32_t_u_u((func_60(l_63, func_64((((((void*)0 != l_66[0]) || (0xF7398071L != l_68)) | g_3) , 0xACA8B146L))) | g_3), g_3)), l_826, l_826, l_66[0], g_3), g_3)) , g_736[2]), l_66[0], l_66[0], g_3) != 0UL) & g_3), 0x466FL)))))) , 0UL), g_3)), (-9L))) <= g_3) < l_881), g_644, g_3), l_66[0]);
    /* statement id: 703 */
    //assert ((l_66[0] >= &g_736[0] && l_66[0] <= &g_736[5]) || l_66[0] == &g_67);
    //assert (g_131[0] == &g_67 || g_131[0] == &g_132);
    //assert (g_203 == dangling || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
    //assert (g_643 == dangling || g_643 == &g_644);
    //assert (g_673[0] == 0 || g_673[0] == dangling || g_673[0] == &g_132 || g_673[0] == &g_598 || g_673[0] == &g_67);
    assert (g_782 == 0 || g_782 == &g_783);
    //assert (g_805 == dangling || g_805 == &g_806);
    (*g_783) = l_66[0];
    /* statement id: 704 */
    assert ((g_113 >= &g_736[0] && g_113 <= &g_736[5]) || g_113 == &g_67);
    l_66[0] = (void*)0;
    /* statement id: 705 */
    //assert (l_66[0] == 0 || (l_66[0] >= &g_736[0] && l_66[0] <= &g_736[5]) || l_66[0] == &g_67);
    (*g_156) = ((safe_add_func_int16_t_s_s(((safe_mod_func_int8_t_s_s((l_940 == &g_616), ((safe_sub_func_int64_t_s_s((((safe_lshift_func_int8_t_s_u(l_946, func_60(l_947, l_948))) == (safe_rshift_func_int16_t_s_u(1L, ((7UL ^ (safe_rshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s(g_884.f0, l_955)), 3))) , g_884.f0)))) ^ (-1L)), g_884.f0)) , 6UL))) , 1L), g_3)) == g_884.f0);
    /* statement id: 706 */
    //assert (g_113 == &g_67 || g_113 == dangling || g_113 == 0 || (g_113 >= &g_736[0] && g_113 <= &g_736[5]));
    return g_598;
}


/* ------------------------------------------ */
/* 
 * reads : g_920 g_750 g_113 g_736 g_884.f0 g_109.f0 g_215 g_598 g_67 g_808 g_809 g_109 g_783 g_616 g_617 g_618 g_619 g_3 g_838 g_132 g_877 g_403 g_241 g_644
 * writes: g_113 g_67 g_673 g_166 g_736 g_109 g_132 g_131 g_241
 */
inline static int32_t * func_29(int32_t  p_30, int32_t * p_31)
{ /* block id: 699 */
    uint32_t l_911 = 4294967295UL;
    struct S0 l_918 = {16};
    int32_t *l_919 = &g_598;
    int32_t * volatile *l_921 = &g_113;
    int32_t *l_934 = &g_598;
    int32_t *l_935 = &g_736[0];
    (*l_921) = g_920;
    /* statement id: 700 */
    assert ((g_113 >= &g_736[0] && g_113 <= &g_736[5]));
    p_31 = func_75(func_52(((-1L) && (safe_rshift_func_int8_t_s_s((g_750 , (((**l_921) & (safe_div_func_uint16_t_u_u((safe_sub_func_uint16_t_u_u(((safe_add_func_int16_t_s_s((((safe_rshift_func_uint16_t_u_u(g_884.f0, 0)) , 0x5F14L) && g_109.f0), ((((__builtin_bswap32((safe_div_func_uint16_t_u_u((func_45((**l_921), l_919, l_934, p_30) == g_215), g_736[0]))) , 0x41E856F5L) ^ p_30) , (*l_919)) && g_67))) >= (-1L)), 0x77A2L)), g_215))) & (**l_921))), 2))), l_918, (**g_808), p_31, g_598));
    /* statement id: 701 */
    assert (g_113 == 0);
    return l_935;
    /* statement id: 702 */
    //assert ((func_29_rv >= &g_736[0] && func_29_rv <= &g_736[5]));
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_809 g_109 g_884 g_370 g_783 g_616 g_617 g_618 g_619 g_736 g_838 g_598 g_132 g_877 g_403 g_241 g_644 g_215
 * writes: g_113 g_598 g_673 g_166 g_736 g_67 g_109 g_132 g_131 g_241
 */
inline static int32_t  func_32(uint32_t  p_33, int8_t  p_34, int32_t * p_35, uint32_t  p_36)
{ /* block id: 695 */
    int32_t *l_885 = &g_598;
    float * const *l_894 = &g_644;
    int32_t l_895 = 0x5D1E200CL;
    struct S0 *****l_896[7] = {&g_329,&g_329,&g_329,&g_329,&g_329,&g_329,&g_329};
    int i;
    (*g_644) = __builtin_ctzl(((func_52(g_3, (*g_809), g_884, l_885, g_370) != (((safe_mul_func_float_f_f((((safe_div_func_uint32_t_u_u((((safe_rshift_func_uint16_t_u_s(((((((((safe_mul_func_int16_t_s_s((-3L), g_370)) ^ g_884.f0) < 2UL) , l_894) != &g_644) == g_370) <= p_36) >= 0xF24BL), 10)) , l_895) == (-1L)), p_33)) , g_3) == (-0x2.8p-1)), p_33)) < g_370) < p_34)) , p_36));
    l_896[0] = &g_329;
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_45(uint32_t  p_46, int32_t * p_47, int32_t * p_48, uint64_t  p_49)
{ /* block id: 692 */
    struct S0 l_880[9][7][1] = {{{{0}},{{6}},{{2}},{{22}},{{25}},{{-31}},{{-19}}},{{{5}},{{-9}},{{-27}},{{-21}},{{27}},{{-21}},{{-27}}},{{{-9}},{{5}},{{-19}},{{-31}},{{25}},{{22}},{{2}}},{{{6}},{{0}},{{1}},{{31}},{{1}},{{0}},{{6}}},{{{2}},{{22}},{{25}},{{-31}},{{-19}},{{5}},{{-9}}},{{{-27}},{{-21}},{{27}},{{-21}},{{-27}},{{-9}},{{5}}},{{{-19}},{{-31}},{{25}},{{22}},{{2}},{{6}},{{0}}},{{{1}},{{31}},{{1}},{{0}},{{6}},{{2}},{{22}}},{{{25}},{{-31}},{{-19}},{{5}},{{-9}},{{-27}},{{-21}}}};
    int i, j, k;
    l_880[7][2][0] = l_880[4][6][0];
    return l_880[4][6][0].f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_783 g_616 g_617 g_618 g_619 g_3 g_736 g_838 g_67 g_109 g_132 g_598 g_877 g_403 g_241 g_644 g_215
 * writes: g_113 g_67 g_673 g_166 g_736 g_109 g_132 g_131 g_241 g_598
 */
inline static uint16_t  func_52(uint64_t  p_53, struct S0  p_54, struct S0  p_55, int32_t * p_56, uint32_t  p_57)
{ /* block id: 641 */
    int32_t *l_827 = (void*)0;
    const float *l_852 = (void*)0;
    const float **l_851 = &l_852;
    struct S0 l_874 = {-20};
lbl_839:
    (*g_783) = l_827;
    /* statement id: 642 */
    assert (g_113 == 0);
    (*p_56) = ((void*)0 == p_56);
    for (p_53 = 0; (p_53 <= 3); p_53 += 1)
    { /* block id: 646 */
        const int32_t * volatile l_828 = &g_67;/* VOLATILE GLOBAL l_828 */
        int32_t *l_835[5];
        float l_859 = 0x0.848B04p-32;
        int i;
        for (i = 0; i < 5; i++)
            l_835[i] = &g_736[4];
        l_828 = (***g_616);
        /* statement id: 647 */
        assert (l_828 == 0);
        for (p_57 = 0; (p_57 <= 3); p_57 += 1)
        { /* block id: 650 */
            float l_832[9][6][4] = {{{0x4.Bp+1,0xC.D1E338p+14,0x6.EBF33Dp+49,0xA.6DC2CBp+53},{(-0x1.Cp+1),0x6.5p+1,0x6.B53D4Ep-33,0x3.838DADp-68},{(-0x1.Cp+1),0xA.072BE9p+96,0x6.EBF33Dp+49,0x0.1p-1},{0x4.Bp+1,0x3.838DADp-68,0xC.D1E338p+14,0xD.AD20C6p-48},{0x0.7p-1,0x9.E120C5p-31,0x3.E55D74p+23,0x9.B55DF9p+96},{0x3.7CBDCFp-67,0x6.EBF33Dp+49,0x9.B55DF9p+96,0x5.E6B926p-3}},{{0x3.D8F40Bp-72,0x3.7CBDCFp-67,0x3.7CBDCFp-67,0x3.D8F40Bp-72},{0x6.895D4Cp+50,0x6.Dp-1,0xF.48979Bp+99,0xE.CE45CDp-98},{0x4.5A122Ep+72,(-0x3.Cp-1),0x6.5p+1,0xE.E04414p+62},{0x0.1p-1,0x9.B55DF9p+96,0x3.D8F40Bp-72,0xE.E04414p+62},{0x6.090FD2p+12,(-0x3.Cp-1),0x0.7p-1,0xE.CE45CDp-98},{0x9.E120C5p-31,0x6.Dp-1,0x0.1p-1,0x3.D8F40Bp-72}},{{0x1.7p-1,0x3.7CBDCFp-67,(-0x9.Bp+1),0x5.E6B926p-3},{0x3.838DADp-68,0x6.EBF33Dp+49,0x6.Dp-1,0x9.B55DF9p+96},{0x8.CABF98p-83,0x9.E120C5p-31,0x8.CABF98p-83,0xD.AD20C6p-48},{0x3.E55D74p+23,0x3.838DADp-68,0x9.E120C5p-31,0x0.1p-1},{0xA.6DC2CBp+53,0xA.072BE9p+96,0x5.E6B926p-3,0x3.838DADp-68},{0xF.48979Bp+99,0x6.5p+1,0x5.E6B926p-3,0xA.6DC2CBp+53}},{{0xA.6DC2CBp+53,0xC.D1E338p+14,0x9.E120C5p-31,0x4.5A122Ep+72},{0x3.E55D74p+23,0x6.090FD2p+12,0x8.CABF98p-83,(-0x1.Cp+1)},{0x8.CABF98p-83,(-0x1.Cp+1),0x6.Dp-1,0xC.D1E338p+14},{0x3.838DADp-68,0xF.48979Bp+99,(-0x9.Bp+1),(-0x9.Bp+1)},{0x1.7p-1,0x1.7p-1,0x0.1p-1,0x6.090FD2p+12},{0x9.E120C5p-31,0xD.AD20C6p-48,0x0.7p-1,0x6.Dp-1}},{{0x6.090FD2p+12,0x4.5A122Ep+72,0x3.D8F40Bp-72,0x0.7p-1},{0x0.1p-1,0x4.5A122Ep+72,0x6.5p+1,0x6.Dp-1},{0x4.5A122Ep+72,0xD.AD20C6p-48,0xF.48979Bp+99,0x6.090FD2p+12},{0x6.895D4Cp+50,0x1.7p-1,0x3.7CBDCFp-67,(-0x9.Bp+1)},{0x3.7CBDCFp-67,(-0x9.Bp+1),0x5.E6B926p-3,0xE.E04414p+62},{(-0x3.Cp-1),0xF.48979Bp+99,0x6.EBF33Dp+49,0xF.48979Bp+99}},{{0xD.4C5837p-88,0x4.Bp+1,0xE.E04414p+62,0x9.B55DF9p+96},{0x0.1p-1,0xE.E04414p+62,0x4.5A122Ep+72,0xE.CE45CDp-98},{0xF.48979Bp+99,0x9.E120C5p-31,0x6.090FD2p+12,(-0x1.Cp+1)},{0xF.48979Bp+99,0xD.AD20C6p-48,0x4.5A122Ep+72,0x1.7p-1},{0x0.1p-1,(-0x1.Cp+1),0xE.E04414p+62,0x6.5p+1},{0xD.4C5837p-88,0x3.D8F40Bp-72,0x6.EBF33Dp+49,0x5.E6B926p-3}},{{(-0x3.Cp-1),0x4.5A122Ep+72,0x5.E6B926p-3,0x6.B53D4Ep-33},{0x3.7CBDCFp-67,(-0x3.Cp-1),(-0x3.Cp-1),0x3.7CBDCFp-67},{0xC.D1E338p+14,0x6.895D4Cp+50,(-0x9.Bp+1),0x3.838DADp-68},{0x9.B55DF9p+96,0x3.E55D74p+23,0x9.E120C5p-31,0x0.7p-1},{0x1.7p-1,0x5.E6B926p-3,0x3.7CBDCFp-67,0x0.7p-1},{0x4.Bp+1,0x3.E55D74p+23,0xD.4C5837p-88,0x3.838DADp-68}},{{0x3.D8F40Bp-72,0x6.895D4Cp+50,0x1.7p-1,0x3.7CBDCFp-67},{0x9.Bp+1,(-0x3.Cp-1),0x6.Dp-1,0x6.B53D4Ep-33},{(-0x1.Cp+1),0x4.5A122Ep+72,0x6.895D4Cp+50,0x5.E6B926p-3},{0xA.6DC2CBp+53,0x3.D8F40Bp-72,0xA.6DC2CBp+53,0x6.5p+1},{0x6.EBF33Dp+49,(-0x1.Cp+1),0x3.D8F40Bp-72,0x1.7p-1},{0xE.CE45CDp-98,0xD.AD20C6p-48,0x6.B53D4Ep-33,(-0x1.Cp+1)}},{{(-0x9.Bp+1),0x9.E120C5p-31,0x6.B53D4Ep-33,0xE.CE45CDp-98},{0xE.CE45CDp-98,0xE.E04414p+62,0x3.D8F40Bp-72,0x9.B55DF9p+96},{0x6.EBF33Dp+49,0x4.Bp+1,0xA.6DC2CBp+53,0xF.48979Bp+99},{0xA.6DC2CBp+53,0xF.48979Bp+99,0x6.895D4Cp+50,0xE.E04414p+62},{(-0x1.Cp+1),(-0x9.Bp+1),0x6.Dp-1,0x6.Dp-1},{0x9.Bp+1,0x9.Bp+1,0x1.7p-1,0x4.Bp+1}}};
            int8_t l_833 = 0xE3L;
            int32_t *l_834 = &g_736[0];
            struct S0 l_848[6] = {{-16},{-16},{-16},{-16},{-16},{-16}};
            int16_t l_870 = 0x112DL;
            struct S0 *****l_871 = &g_329;
            int16_t l_872 = (-10L);
            int i, j, k;
            if ((p_57 , (+(p_57 <= ((safe_mul_func_int16_t_s_s(p_55.f0, (((l_833 >= ((g_3 , l_834) == p_56)) , (*l_834)) , (*l_834)))) <= 18446744073709551615UL)))))
            { /* block id: 651 */
                int i;
                g_673[(p_53 + 3)] = ((*l_834) , l_827);
                (*g_838) = (*g_618);
                if ((*p_56))
                    break;
            }
            else
            { /* block id: 655 */
                uint64_t l_856 = 0x51E885265154DFC6LL;
                if ((*p_56))
                    break;
                for (g_166 = 3; (g_166 >= 0); g_166 -= 1)
                { /* block id: 659 */
                    float **l_850[2];
                    int i;
                    for (i = 0; i < 2; i++)
                        l_850[i] = &g_644;
                    (*l_834) = (*p_56);
                    if (p_57)
                        goto lbl_839;
                    g_673[(p_53 + 6)] = func_75((0x19L || 0x10L));
                    for (g_132 = 0; (g_132 <= 3); g_132 += 1)
                    { /* block id: 665 */
                        int32_t l_849 = 0xEB2E0E60L;
                        int i, j;
                        g_131[g_132] = func_75((((p_53 , ((safe_mul_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u(p_55.f0, p_53)) < (l_848[3] , l_849)), 11)), p_57)) && (l_850[0] != l_851))) > (*l_834)) != p_55.f0));
                    }
                }
                if ((*l_834))
                    continue;
                if ((safe_div_func_uint16_t_u_u((((*l_834) >= ((-0x1.6p-1) >= (-p_57))) , ((((-1L) > ((l_856 , (0xC7L ^ ((-1L) == 0x716FECE9L))) && (((safe_sub_func_int64_t_s_s(p_54.f0, l_856)) || p_53) == 0xAA1EC64CL))) & (*p_56)) >= p_57)), l_856)))
                { /* block id: 670 */
                    l_835[2] = p_56;
                }
                else
                { /* block id: 672 */
                    uint32_t l_860 = 0xA15072F6L;
                    uint8_t l_861 = 5UL;
                    struct S0 *l_873[8][2][2];
                    int i, j, k;
                    for (i = 0; i < 8; i++)
                    {
                        for (j = 0; j < 2; j++)
                        {
                            for (k = 0; k < 2; k++)
                                l_873[i][j][k] = &g_109;
                        }
                    }
                    for (l_833 = 3; (l_833 >= 0); l_833 -= 1)
                    { /* block id: 675 */
                        if (l_860)
                            break;
                        return g_598;
                    }
                    l_874 = p_54;
                }
            }
        }
        /* facts after for loop */
        //assert (l_835[0] == &g_67 || (l_835[0] >= &g_736[0] && l_835[0] <= &g_736[5]) || l_835[0] == &g_598);
    }
    for (g_132 = 0; (g_132 >= 18); g_132 = safe_add_func_int8_t_s_s(g_132, 3))
    { /* block id: 686 */
        uint32_t l_878 = 0x5E9C25DFL;
        int32_t l_879 = 0x79FE77BFL;
        (*g_877) = l_852;
        l_879 = l_878;
        (*g_644) = (*g_403);
    }
    return g_215;
}


/* ------------------------------------------ */
/* 
 * reads : g_215 g_598 g_166 g_750 g_644 g_131 g_132 g_752 g_756 g_3 g_736 g_241 g_370 g_67 g_781 g_109 g_783 g_735 g_329 g_156 g_325 g_793 g_113 g_807 g_808 g_809 g_618 g_619 g_288 g_285 g_286
 * writes: g_215 g_598 g_166 g_241 g_131 g_132 g_752 g_736 g_113 g_370 g_67 g_328 g_673 g_782 g_109 g_330 g_805 g_627
 */
inline static int64_t  func_60(const int32_t * p_61, const struct S0  p_62)
{ /* block id: 508 */
    float l_766 = (-0x6.Fp+1);
    int32_t ***l_780 = (void*)0;
    int32_t l_799 = 0x8FA0CE26L;
    for (g_215 = (-17); (g_215 <= 27); g_215 = safe_add_func_int8_t_s_s(g_215, 5))
    { /* block id: 511 */
        const int32_t l_751 = 0x15F2B1AFL;
        uint16_t l_819 = 65532UL;
        int32_t *l_821 = &g_736[3];
        for (g_598 = 0; (g_598 == (-20)); --g_598)
        { /* block id: 514 */
            uint64_t l_765 = 0x6D3DF8DFA9657719LL;
            int32_t *l_767 = (void*)0;
            struct S0 l_770 = {-1};
            for (g_166 = 3; (g_166 >= 0); g_166 -= 1)
            { /* block id: 517 */
                int i;
                (*g_644) = (g_750 , l_751);
                g_131[g_166] = g_131[g_166];
                for (g_132 = 3; (g_132 >= 0); g_132 -= 1)
                { /* block id: 522 */
                    volatile float * volatile ** volatile **l_754 = &g_752;
                    int32_t l_755 = 4L;
                    struct S0 l_769 = {23};
                    (*l_754) = g_752;
                    if (l_755)
                        break;
                    for (l_755 = 4; (l_755 >= 0); l_755 -= 1)
                    { /* block id: 527 */
                        (*g_756) = (p_62.f0 || g_132);
                    }
                    if ((safe_rshift_func_int8_t_s_u((safe_lshift_func_int8_t_s_s((__builtin_ffsll((safe_mod_func_int64_t_s_s(__builtin_parity(l_755), ((safe_sub_func_uint32_t_u_u(g_3, l_765)) , (g_736[0] , g_215))))) | 0x29L), 5)), 5)))
                    { /* block id: 530 */
                        return g_736[1];
                    }
                    else
                    { /* block id: 532 */
                        int32_t **l_768 = &g_113;
                        int i, j;
                        (*l_768) = l_767;
                        /* statement id: 533 */
                        assert (g_113 == 0);
                        if (p_62.f0)
                            continue;
                        l_755 = (*g_644);
                        l_770 = l_769;
                    }
                    /* facts after branching */
                    assert (g_113 == 0);
                }
            }
            for (g_166 = (-9); (g_166 > 20); g_166++)
            { /* block id: 542 */
                return p_62.f0;
            }
        }
        for (g_370 = 0; (g_370 > 5); g_370 = safe_add_func_int64_t_s_s(g_370, 1))
        { /* block id: 548 */
            uint32_t l_798 = 9UL;
            const struct S0 *l_804[2][2][9] = {{{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109},{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109}},{{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109},{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109,&g_109}}};
            const struct S0 * const *l_803[4][9][6] = {{{&l_804[1][0][4],&l_804[1][0][1],(void*)0,(void*)0,&l_804[1][0][1],&l_804[1][0][4]},{(void*)0,&l_804[1][0][1],&l_804[1][0][4],&l_804[1][0][5],&l_804[1][0][5],&l_804[0][1][4]},{&l_804[0][1][4],&l_804[1][0][5],&l_804[0][0][7],&l_804[1][0][5],(void*)0,&l_804[1][0][5]},{&l_804[0][1][4],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][5],&l_804[0][0][4],&l_804[0][0][1]},{(void*)0,&l_804[1][0][5],(void*)0,(void*)0,(void*)0,&l_804[0][0][1]},{&l_804[1][0][4],&l_804[0][0][4],&l_804[1][0][5],&l_804[1][0][5],&l_804[0][0][0],&l_804[1][0][5]},{&l_804[0][0][7],&l_804[1][0][5],&l_804[0][0][7],&l_804[1][0][5],&l_804[0][0][0],&l_804[0][1][4]},{&l_804[1][0][5],&l_804[0][0][4],&l_804[1][0][4],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][1][7]},{(void*)0,&l_804[1][0][5],&l_804[0][0][2],&l_804[1][0][5],&l_804[0][1][4],&l_804[1][0][5]}},{{&l_804[1][0][5],(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][4],&l_804[0][0][2]},{&l_804[1][0][5],&l_804[0][1][7],(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][5]},{&l_804[1][1][7],(void*)0,&l_804[0][0][2],&l_804[0][0][2],(void*)0,&l_804[1][1][7]},{&l_804[0][0][2],(void*)0,&l_804[1][1][7],&l_804[1][0][5],&l_804[1][0][5],(void*)0},{(void*)0,&l_804[0][1][7],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][4],(void*)0},{(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][5],&l_804[0][1][4],&l_804[1][1][4]},{&l_804[0][0][2],&l_804[1][0][5],(void*)0,&l_804[0][0][2],&l_804[1][0][5],&l_804[1][1][4]},{&l_804[1][1][7],&l_804[0][1][4],&l_804[1][0][5],(void*)0,&l_804[0][0][1],(void*)0},{&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][5],&l_804[0][0][1],(void*)0}},{{&l_804[1][0][5],&l_804[0][1][4],&l_804[1][1][7],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][1][7]},{(void*)0,&l_804[1][0][5],&l_804[0][0][2],&l_804[1][0][5],&l_804[0][1][4],&l_804[1][0][5]},{&l_804[1][0][5],(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][4],&l_804[0][0][2]},{&l_804[1][0][5],&l_804[0][1][7],(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][5]},{&l_804[1][1][7],(void*)0,&l_804[0][0][2],&l_804[0][0][2],(void*)0,&l_804[1][1][7]},{&l_804[0][0][2],(void*)0,&l_804[1][1][7],&l_804[1][0][5],&l_804[1][0][5],(void*)0},{(void*)0,&l_804[0][1][7],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][4],(void*)0},{(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][5],&l_804[0][1][4],&l_804[1][1][4]},{&l_804[0][0][2],&l_804[1][0][5],(void*)0,&l_804[0][0][2],&l_804[1][0][5],&l_804[1][1][4]}},{{&l_804[1][1][7],&l_804[0][1][4],&l_804[1][0][5],(void*)0,&l_804[0][0][1],(void*)0},{&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][5],&l_804[0][0][1],(void*)0},{&l_804[1][0][5],&l_804[0][1][4],&l_804[1][1][7],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][1][7]},{(void*)0,&l_804[1][0][5],&l_804[0][0][2],&l_804[1][0][5],&l_804[0][1][4],&l_804[1][0][5]},{&l_804[1][0][5],(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][4],&l_804[0][0][2]},{&l_804[1][0][5],&l_804[0][1][7],(void*)0,(void*)0,&l_804[1][0][5],&l_804[1][0][5]},{&l_804[1][1][7],(void*)0,&l_804[0][0][2],&l_804[0][0][2],(void*)0,&l_804[1][1][7]},{&l_804[0][0][2],(void*)0,&l_804[1][1][7],&l_804[1][0][5],&l_804[1][0][5],(void*)0},{(void*)0,&l_804[0][1][7],&l_804[1][0][5],&l_804[1][0][5],&l_804[1][0][4],(void*)0}}};
            const struct S0 * const **l_802 = &l_803[3][5][3];
            const struct S0 * const *** const l_801 = &l_802;
            const struct S0 * const *** const *l_800[4];
            int i, j, k;
            for (i = 0; i < 4; i++)
                l_800[i] = &l_801;
            if ((safe_rshift_func_uint16_t_u_s(g_736[0], (safe_lshift_func_uint8_t_u_s(g_370, 5)))))
            { /* block id: 549 */
                int32_t *l_786 = &g_67;
                for (g_67 = 6; (g_67 >= 0); g_67 -= 1)
                { /* block id: 552 */
                    int32_t *l_779 = &g_132;
                    for (g_132 = 9; (g_132 >= 0); g_132 -= 1)
                    { /* block id: 555 */
                        int i;
                        g_328[4] = (void*)0;
                        g_673[(g_67 + 1)] = l_779;
                        (*g_781) = l_780;
                        /* statement id: 558 */
                        assert (g_782 == 0);
                    }
                }
                (*g_783) = func_75(g_598);
                /* statement id: 561 */
                assert (g_113 == &g_67);
                for (g_598 = 9; (g_598 == 28); g_598 = safe_add_func_int32_t_s_s(g_598, 4))
                { /* block id: 564 */
                    if ((g_215 || p_62.f0))
                    { /* block id: 565 */
                        p_61 = l_786;
                        /* statement id: 566 */
                        assert (p_61 == &g_67);
                    }
                    else
                    { /* block id: 567 */
                        uint32_t l_787 = 0xECBFB99FL;
                        l_787 = (p_62.f0 < p_62.f0);
                        (*g_735) = p_61;
                        (*g_644) = __builtin_bswap64((*l_786));
                        (*g_329) = (void*)0;
                    }
                }
            }
            else
            { /* block id: 574 */
                const int32_t l_790[5][8][3] = {{{(-2L),0xBDE30487L,0L},{0x7FCFC596L,0xFF7607CAL,0x80B027EAL},{(-6L),0x27EDBD6FL,0xD090545FL},{0xFF7607CAL,0xFF7607CAL,(-1L)},{0xB39A7DE6L,0xBDE30487L,(-1L)},{0x3471B744L,(-1L),(-6L)},{0L,0L,0L},{0L,0x7FCFC596L,0L}},{{0xB7156BFFL,(-1L),0xD090545FL},{(-6L),(-1L),0x3471B744L},{0xC598B081L,0xB5DFC049L,(-2L)},{0xFF7607CAL,0L,0L},{0xC598B081L,(-1L),0x27EDBD6FL},{(-6L),0x80B027EAL,(-1L)},{0xB7156BFFL,0x27EDBD6FL,0xC598B081L},{0L,0x3471B744L,(-5L)}},{{0x27EDBD6FL,0x27EDBD6FL,0xB39A7DE6L},{0x7FCFC596L,0x80B027EAL,0xC9483D83L},{0xB5DFC049L,(-1L),0xBDE30487L},{(-1L),0L,0x80B027EAL},{0xBDE30487L,0xB5DFC049L,0xBDE30487L},{0x3225B47DL,(-1L),0xC9483D83L},{(-6L),(-1L),0xB39A7DE6L},{0L,0x7FCFC596L,(-5L)}},{{0L,0xC598B081L,0xC598B081L},{0L,0xF771E92DL,(-1L)},{(-6L),0L,0x27EDBD6FL},{0x3225B47DL,(-1L),0L},{0xBDE30487L,0xB39A7DE6L,(-2L)},{(-1L),(-1L),0x3471B744L},{0xB5DFC049L,0L,0xD090545FL},{0x7FCFC596L,0xF771E92DL,0L}},{{0x27EDBD6FL,0xC598B081L,0L},{0L,0x7FCFC596L,0L},{0xB7156BFFL,(-1L),0xD090545FL},{(-6L),(-1L),0x3471B744L},{0xC598B081L,0xB5DFC049L,(-2L)},{0xFF7607CAL,0L,0L},{0xC598B081L,(-1L),0x27EDBD6FL},{(-6L),0x80B027EAL,(-1L)}}};
                int i, j, k;
                if ((*g_156))
                { /* block id: 575 */
                    for (g_598 = (-24); (g_598 < 18); g_598++)
                    { /* block id: 578 */
                        return g_3;
                    }
                    if (l_790[0][6][2])
                        continue;
                }
                else
                { /* block id: 582 */
                    const int32_t **l_795 = &g_673[4];
                    (*g_325) = func_75(((&p_62 == &p_62) == l_790[2][0][1]));
                    /* statement id: 583 */
                    assert (g_113 == &g_67);
                    for (g_67 = 0; (g_67 > 28); ++g_67)
                    { /* block id: 586 */
                        (*g_644) = (-0x7.2p+1);
                        return l_751;
                    }
                    (*g_793) = p_62;
                    (*l_795) = p_61;
                }
                if (l_751)
                { /* block id: 593 */
                    int8_t l_796 = 0x9EL;
                    (*g_783) = func_75(p_62.f0);
                    /* statement id: 594 */
                    assert (g_113 == &g_67);
                    if (l_796)
                        break;
                }
                else
                { /* block id: 596 */
                    int32_t l_797 = (-1L);
                    return l_797;
                }
                /* facts after branching */
                assert (g_113 == &g_67);
                for (g_67 = 5; (g_67 >= 0); g_67 -= 1)
                { /* block id: 601 */
                    int i;
                    if (l_798)
                    { /* block id: 602 */
                        return l_798;
                    }
                    else
                    { /* block id: 604 */
                        return l_798;
                    }
                }
            }
            /* facts after branching */
            assert (g_113 == &g_67);
            if (((4294967290UL == 0x66AE9F17L) < p_62.f0))
            { /* block id: 609 */
                uint64_t l_814 = 18446744073709551610UL;
                int32_t l_818 = (-3L);
                struct S0 l_820 = {4};
                struct S0 l_822[6][7][6] = {{{{9},{21},{-6},{9},{2},{18}},{{21},{-28},{20},{20},{-28},{21}},{{15},{21},{-2},{2},{12},{21}},{{18},{26},{-23},{-1},{25},{-25}},{{18},{-9},{-1},{2},{27},{-21}},{{15},{12},{26},{20},{-6},{0}},{{21},{25},{-8},{9},{-9},{2}}},{{{9},{21},{25},{21},{9},{18}},{{2},{2},{-23},{-25},{-28},{2}},{{31},{-13},{18},{2},{-24},{2}},{{12},{15},{-23},{25},{-6},{18}},{{-24},{-9},{25},{11},{-15},{2}},{{15},{-24},{-8},{-23},{0},{0}},{{2},{26},{26},{2},{-9},{-21}}},{{{-21},{-13},{-1},{21},{2},{-25}},{{21},{-23},{-1},{25},{-25},{26}},{{-21},{15},{-15},{21},{-3},{31}},{{27},{-21},{25},{18},{-24},{-6}},{{-22},{-24},{18},{20},{21},{20}},{{11},{-3},{11},{-1},{18},{-2}},{{26},{2},{-21},{25},{-24},{-23}}},{{{-25},{15},{-9},{25},{18},{-1}},{{26},{-25},{25},{-1},{-23},{26}},{{11},{31},{-24},{20},{-3},{-8}},{{-22},{9},{25},{18},{18},{25}},{{27},{27},{18},{21},{2},{-23}},{{-21},{-3},{-28},{25},{12},{18}},{{26},{-21},{-28},{31},{27},{-23}}},{{{20},{31},{18},{-8},{18},{25}},{{-8},{18},{25},{-1},{-25},{-8}},{{2},{26},{-24},{21},{-24},{26}},{{-24},{9},{25},{-9},{12},{-1}},{{27},{-24},{-9},{-25},{21},{-23}},{{11},{-24},{-21},{25},{12},{-2}},{{-8},{9},{11},{31},{-24},{20}}},{{{-23},{26},{18},{25},{-25},{-6}},{{31},{18},{25},{25},{18},{31}},{{2},{31},{-15},{-25},{27},{26}},{{-22},{-21},{-1},{-2},{12},{25}},{{-22},{-3},{-2},{-25},{2},{20}},{{2},{27},{-21},{25},{18},{-24}},{{31},{9},{-28},{25},{-3},{-25}}}};
                const int32_t * volatile *l_825 = &g_627;
                int i, j, k;
                if ((l_751 < l_799))
                { /* block id: 610 */
                    for (g_132 = 1; (g_132 <= 4); g_132 += 1)
                    { /* block id: 613 */
                        g_805 = l_800[3];
                        /* statement id: 614 */
                        assert (g_805 == &l_801);
                    }
                    /* facts after for loop */
                    //assert (g_805 == &l_801 || g_805 == dangling || g_805 == &g_806);
                    for (g_132 = 0; (g_132 > (-7)); g_132 = safe_sub_func_int64_t_s_s(g_132, 1))
                    { /* block id: 618 */
                        int32_t * const l_812 = &g_736[0];
                        int32_t **l_813 = &g_113;
                        (*l_813) = l_812;
                        /* statement id: 619 */
                        assert ((g_113 >= &g_736[0] && g_113 <= &g_736[5]));
                        if (l_814)
                            break;
                        l_818 = (p_62 , ((p_62.f0 > (p_62.f0 >= (g_166 >= (safe_rshift_func_int16_t_s_u(p_62.f0, 11))))) < (g_67 , (+g_736[0]))));
                        l_819 = (**g_783);
                    }
                    /* facts after for loop */
                    assert ((g_113 >= &g_736[0] && g_113 <= &g_736[5]) || g_113 == &g_67);
                    (*g_783) = (l_814 , &l_818);
                    /* statement id: 624 */
                    assert (g_113 == &l_818);
                }
                else
                { /* block id: 625 */
                    struct S0 l_823 = {-26};
                    l_820 = (***g_807);
                    l_821 = (*g_325);
                    /* statement id: 627 */
                    assert (l_821 == &g_67);
                    l_823 = l_822[3][2][5];
                }
                /* facts after branching */
                assert (g_113 == &g_67 || g_113 == &l_818);
                //assert (g_805 == &l_801 || g_805 == dangling || g_805 == &g_806);
                (*l_825) = ((p_62.f0 > (0xE8300AF3L || (+((void*)0 != &g_617)))) , (*g_618));
                (*g_113) = (*g_156);
                if (p_62.f0)
                    break;
                //assert (g_113 == &g_67 || g_113 == dangling);
                //assert (g_805 == dangling || g_805 == &g_806);
            }
            else
            { /* block id: 633 */
                l_800[1] = (void*)0;
                /* statement id: 634 */
                //assert (l_800[0] == 0 || l_800[0] == &l_801);
            }
            /* facts after branching */
            //assert (g_113 == &g_67 || g_113 == dangling);
            //assert (g_805 == &l_801 || g_805 == dangling || g_805 == &g_806);
            //assert (l_800[0] == 0 || l_800[0] == &l_801);
        }
        /* facts after for loop */
        //assert (g_113 == &g_67 || g_113 == dangling || g_113 == 0 || (g_113 >= &g_736[0] && g_113 <= &g_736[5]));
        assert (p_61 == 0 || p_61 == &g_67 || p_61 == &g_132);
        assert (l_821 == &g_67 || (l_821 >= &g_736[0] && l_821 <= &g_736[5]));
        if ((**g_288))
            break;
        return p_62.f0;
    }
    /* facts after for loop */
    //assert (g_113 == &g_67 || g_113 == dangling || g_113 == 0 || (g_113 >= &g_736[0] && g_113 <= &g_736[5]));
    assert (p_61 == 0 || p_61 == &g_67 || p_61 == &g_132);
    return p_62.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_67 g_109.f0 g_132 g_156 g_175 g_166 g_205 g_215 g_242 g_203 g_109 g_598 g_403 g_241 g_370 g_286 g_617 g_618 g_619 g_672 g_644 g_373 g_329 g_330 g_530 g_113 g_673 g_706 g_468 g_643 g_285 g_735 g_736 g_745
 * writes: g_67 g_109 g_113 g_132 g_166 g_203 g_241 g_215 g_204 g_643 g_673 g_598 g_329 g_131 g_370
 */
static const struct S0  func_64(const int32_t  p_65)
{ /* block id: 37 */
    uint32_t l_629[10] = {0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL,0x71C1B63BL};
    int32_t *l_632 = &g_598;
    float *l_642 = &g_241;
    float ** const l_641 = &l_642;
    struct S0 l_693 = {-21};
    struct S0 ****l_705 = &g_330[2][1];
    const int32_t *l_707 = (void*)0;
    uint32_t l_714[5][1][4];
    int i, j, k;
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 1; j++)
        {
            for (k = 0; k < 4; k++)
                l_714[i][j][k] = 18446744073709551615UL;
        }
    }
    if (((((g_3 && (safe_lshift_func_int8_t_s_s(1L, ((safe_mod_func_uint32_t_u_u((((g_3 && (&p_65 != (p_65 , &p_65))) , func_73(&g_67)) == (g_598 , &g_598)), l_629[6])) == p_65)))) < l_629[3]) ^ g_3) && 0xCC4AL))
    { /* block id: 402 */
        struct S0 * const *l_638 = (void*)0;
        int32_t l_640[7] = {0x1F56A834L,0x1F56A834L,0x1F56A834L,0x1F56A834L,0x1F56A834L,0x1F56A834L,0x1F56A834L};
        int i;
        for (g_215 = 0; (g_215 != 20); g_215 = safe_add_func_uint32_t_u_u(g_215, 1))
        { /* block id: 405 */
            int32_t *l_633 = &g_67;
            struct S0 **l_639 = &g_204[0][1];
            const struct S0 l_645 = {15};
            l_633 = l_632;
            /* statement id: 406 */
            assert (l_633 == &g_598);
            if (((p_65 | ((safe_add_func_uint32_t_u_u(((((safe_lshift_func_uint16_t_u_s(p_65, ((p_65 > ((((*l_633) > (*g_403)) , (l_638 == l_639)) | l_640[0])) < (0xF3185283L >= 0x2C4EECA3L)))) > p_65) >= l_640[3]) || g_109.f0), 0x68CED126L)) ^ g_370)) <= p_65))
            { /* block id: 407 */
                g_643 = l_641;
                /* statement id: 408 */
                assert (g_643 == &l_642);
                return l_645;
                /* statement id: 409 */
                //assert (g_643 == dangling);
            }
            else
            { /* block id: 410 */
                const struct S0 l_646 = {25};
                return l_646;
            }
        }
    }
    else
    { /* block id: 414 */
        const uint64_t l_654 = 18446744073709551606UL;
        int32_t ***** const l_687 = (void*)0;
        const struct S0 l_709 = {-10};
lbl_737:
        for (g_166 = 0; (g_166 <= (-22)); g_166 = safe_sub_func_int8_t_s_s(g_166, 1))
        { /* block id: 417 */
            const int32_t * volatile l_653 = &g_132;/* VOLATILE GLOBAL l_653 */
            const struct S0 l_657 = {14};
            struct S0 ***l_690 = &g_203;
            if ((safe_div_func_uint16_t_u_u(p_65, g_286)))
            { /* block id: 418 */
                uint32_t l_651 = 2UL;
                const int32_t * volatile *l_652 = (void*)0;
                if (l_651)
                    break;
                l_653 = (**g_617);
                /* statement id: 420 */
                assert (l_653 == 0);
                if (l_654)
                { /* block id: 421 */
                    for (g_132 = 0; (g_132 <= 22); ++g_132)
                    { /* block id: 424 */
                        return l_657;
                        /* statement id: 425 */
                        //assert (g_673[0] == dangling || g_673[0] == &g_132 || g_673[0] == &g_598 || g_673[0] == &g_67);
                    }
                }
                else
                { /* block id: 427 */
                    int8_t l_674 = (-1L);
                    int32_t ***l_678 = (void*)0;
                    (*l_642) = (safe_sub_func_float_f_f((safe_add_func_float_f_f((((+(safe_add_func_float_f_f((safe_add_func_float_f_f(p_65, (!(p_65 > (*g_403))))), (*l_632)))) != (safe_mul_func_float_f_f(((*l_632) != p_65), l_654))) <= (*l_632)), (safe_add_func_float_f_f(0x8.3p+1, p_65)))), (*l_632)));
                    for (g_215 = 0; (g_215 <= 1); g_215 += 1)
                    { /* block id: 431 */
                        float l_677 = 0x3.1B85EFp-60;
                        (*g_672) = &p_65;
                        (*l_632) = l_674;
                        (*g_644) = (((safe_div_func_int16_t_s_s(g_166, g_109.f0)) & g_3) , (((((void*)0 != &p_65) < p_65) > ((l_678 == &l_652) , ((safe_div_func_float_f_f((p_65 != (-0x7.Dp+1)), 0x1.Cp+1)) != (-0x5.7p-1)))) >= p_65));
                    }
                }
                (*l_642) = ((**g_373) != (((((*l_632) , (safe_lshift_func_int16_t_s_u(((*g_329) == (*g_329)), ((safe_mod_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u(((0xB894L | (l_687 == (void*)0)) , 0xF5DAL), (safe_sub_func_int16_t_s_s(g_598, p_65)))), p_65)) | 0x401FL)))) || g_132) ^ l_651) , l_690));
            }
            else
            { /* block id: 438 */
                const int32_t **l_691 = &g_673[3];
                (*l_691) = &p_65;
            }
            /* facts after branching */
            assert (l_653 == &g_132 || l_653 == 0);
        }
        l_632 = l_642;
        /* statement id: 442 */
        assert (l_632 == &g_241);
        if ((safe_unary_minus_func_uint16_t_u((l_693 , (__builtin_parityll(p_65) | (safe_rshift_func_int16_t_s_s((*l_632), 15)))))))
        { /* block id: 443 */
            struct S0 *l_696 = (void*)0;
            struct S0 **l_697 = &l_696;
            (*l_697) = l_696;
            for (g_215 = 0; (g_215 > 25); ++g_215)
            { /* block id: 447 */
                int32_t **l_700 = &l_632;
                (*l_700) = (*g_530);
                /* statement id: 448 */
                assert (l_632 == 0 || l_632 == &g_67);
                if ((**g_672))
                    continue;
                for (g_67 = 12; (g_67 >= 21); ++g_67)
                { /* block id: 452 */
                    const int32_t **l_703 = &g_673[6];
                    struct S0 l_704 = {6};
                    (*l_703) = &p_65;
                    (*l_697) = (void*)0;
                    (*g_706) = (l_704 , l_705);
                }
            }
            /* facts after for loop */
            assert (l_632 == 0 || l_632 == &g_67 || l_632 == &g_241);
            (*l_642) = p_65;
            l_707 = &p_65;
            /* statement id: 459 */
            assert (l_707 == &p_65);
        }
        else
        { /* block id: 460 */
            int8_t l_734 = 0L;
            int32_t l_743 = (-1L);
            for (g_598 = 0; (g_598 <= 6); g_598 += 1)
            { /* block id: 463 */
                int32_t *l_708 = &g_132;
                float ***l_738 = &g_643;
                struct S0 *l_744 = &g_109;
                for (g_215 = 0; (g_215 <= 3); g_215 += 1)
                { /* block id: 466 */
                    int i;
                    g_131[g_215] = l_708;
                    if (p_65)
                        continue;
                    for (g_370 = 2; (g_370 <= 6); g_370 += 1)
                    { /* block id: 471 */
                        l_693 = (*g_468);
                    }
                    for (g_132 = 0; (g_132 <= 6); g_132 += 1)
                    { /* block id: 476 */
                        (**g_643) = (*g_644);
                        return l_709;
                        /* statement id: 478 */
                        //assert (g_673[0] == dangling || g_673[0] == &g_132 || g_673[0] == &g_598 || g_673[0] == &g_67);
                    }
                }
                for (g_166 = 3; (g_166 >= 0); g_166 -= 1)
                { /* block id: 483 */
                    struct S0 l_710[2] = {{-3},{-3}};
                    int i;
                    if ((&l_709 == &l_693))
                    { /* block id: 484 */
                        return l_709;
                        /* statement id: 485 */
                        //assert (g_673[0] == dangling || g_673[0] == &g_132 || g_673[0] == &g_598 || g_673[0] == &g_67);
                    }
                    else
                    { /* block id: 486 */
                        struct S0 l_711[9][5][5] = {{{{-22},{-19},{-9},{-10},{-19}},{{31},{-9},{-24},{-9},{31}},{{-19},{-18},{-24},{27},{-9}},{{-19},{-9},{-10},{-19},{-19}},{{27},{28},{27},{-18},{-9}}},{{{31},{-19},{-9},{-18},{27}},{{-9},{-10},{-19},{-19},{-10}},{{-10},{-2},{-9},{27},{-24}},{{28},{-2},{27},{19},{-22}},{{-1},{-10},{-10},{-1},{19}}},{{{28},{-19},{-24},{-19},{19}},{{-10},{28},{-22},{-9},{-22}},{{-9},{-9},{19},{-19},{-24}},{{31},{-18},{19},{-1},{-10}},{{27},{19},{-22},{19},{27}}},{{{-19},{-18},{-24},{27},{-9}},{{-19},{-9},{-10},{-19},{-19}},{{27},{28},{27},{-18},{-9}},{{31},{-19},{-9},{-18},{27}},{{-9},{-10},{-19},{-19},{-10}}},{{{-10},{-2},{-9},{27},{-24}},{{28},{-2},{27},{19},{-22}},{{-1},{-10},{-10},{-1},{19}},{{28},{-19},{-24},{-19},{19}},{{-10},{28},{-22},{-9},{-22}}},{{{-9},{-9},{19},{-19},{-24}},{{31},{-18},{19},{-1},{-10}},{{27},{19},{-22},{19},{27}},{{-19},{-18},{-24},{27},{-9}},{{-19},{-9},{-10},{-19},{-19}}},{{{27},{28},{27},{-18},{-9}},{{31},{-19},{-9},{-18},{27}},{{-9},{-10},{-19},{-19},{-10}},{{-10},{-2},{-9},{27},{-24}},{{28},{-2},{27},{19},{-22}}},{{{-1},{-10},{-10},{-1},{19}},{{28},{-19},{-24},{-19},{19}},{{-10},{28},{-22},{-9},{-22}},{{-9},{-9},{19},{-19},{-24}},{{31},{-18},{19},{-1},{-10}}},{{{27},{28},{31},{28},{-19}},{{-18},{-2},{-22},{-19},{19}},{{-18},{19},{-1},{-10},{-10}},{{-19},{-19},{-19},{-2},{19}},{{27},{-10},{19},{-2},{-19}}}};
                        int i, j, k;
                        (*l_632) = (*g_285);
                        g_131[g_166] = func_75(p_65);
                        if (p_65)
                            continue;
                        l_711[0][4][1] = l_710[1];
                    }
                    (*l_632) = ((safe_div_func_uint32_t_u_u(((l_714[1][0][3] | ((g_67 != (safe_add_func_uint64_t_u_u((safe_rshift_func_uint16_t_u_s(g_598, (safe_div_func_int64_t_s_s((~(((safe_rshift_func_int16_t_s_u(p_65, ((safe_mul_func_int8_t_s_s(((((safe_mul_func_int8_t_s_s((safe_add_func_int64_t_s_s(((safe_rshift_func_uint8_t_u_u(p_65, 7)) >= p_65), ((void*)0 != &g_617))), (safe_lshift_func_int16_t_s_s((((2UL >= 3UL) == l_734) == 5UL), p_65)))) != p_65) || 0x680DL) > p_65), 0xCAL)) & 18446744073709551610UL))) > 0x59L) , g_166)), p_65)))), g_132))) , p_65)) && g_370), 1L)) >= g_598);
                    (*g_735) = &p_65;
                    if (((__builtin_parityll(g_736[0]) , func_75(g_215)) == (void*)0))
                    { /* block id: 494 */
                        if ((*l_632))
                            break;
                        if (g_370)
                            goto lbl_737;
                        l_738 = (void*)0;
                        /* statement id: 497 */
                        assert (l_738 == 0);
                        (*l_708) = (safe_rshift_func_int8_t_s_s((safe_mod_func_int8_t_s_s(g_109.f0, l_743)), p_65));
                    }
                    else
                    { /* block id: 499 */
                        (*l_642) = (*l_708);
                        (*g_745) = l_744;
                    }
                }
                /* facts after for loop */
                assert (l_738 == &g_643 || l_738 == 0);
            }
        }
        /* facts after branching */
        assert (l_632 == 0 || l_632 == &g_67 || l_632 == &g_241);
        assert (l_707 == 0 || l_707 == &p_65);
    }
    /* facts after branching */
    assert (g_113 == 0 || g_113 == &g_67);
    //assert (g_131[0] == &g_67 || g_131[0] == &g_132);
    //assert (g_203 == dangling || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
    assert (l_632 == 0 || l_632 == &g_67 || l_632 == &g_241 || l_632 == &g_598);
    //assert (g_673[0] == &p_65 || g_673[0] == &g_132 || g_673[0] == &g_598 || g_673[0] == &g_67);
    assert (l_707 == 0 || l_707 == &p_65);
    return l_693;
    /* statement id: 507 */
    //assert (g_673[0] == dangling || g_673[0] == &g_132 || g_673[0] == &g_598 || g_673[0] == &g_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_67 g_109.f0 g_132 g_156 g_175 g_166 g_205 g_215 g_242 g_203 g_109
 * writes: g_67 g_109 g_113 g_132 g_166 g_203 g_241 g_215 g_204
 */
inline static int32_t * func_73(int32_t * p_74)
{ /* block id: 38 */
    struct S0 l_84 = {-30};
    int32_t l_94 = (-1L);
    float *l_404 = &g_241;
    struct S0 **l_433 = &g_204[0][3];
    struct S0 ****l_471[2];
    const uint16_t l_485 = 0UL;
    int32_t l_510 = 0x7BD81F6AL;
    int32_t *l_562 = &g_132;
    uint32_t l_571 = 0xAD7E1A42L;
    int32_t l_605 = 0x423A7828L;
    uint64_t l_612 = 0x447322CEEC352537LL;
    int i;
    for (i = 0; i < 2; i++)
        l_471[i] = &g_330[1][4];
    if (g_3)
    { /* block id: 39 */
        uint8_t l_85 = 0x50L;
        int32_t **l_387 = &g_113;
        (*l_387) = func_75((safe_rshift_func_uint16_t_u_s((((((func_79(g_67, l_84, l_85, (g_3 == (safe_lshift_func_uint16_t_u_u((safe_add_func_uint8_t_u_u(g_3, (safe_lshift_func_uint16_t_u_u((((safe_rshift_func_int8_t_s_u((0x56L | (l_84 , g_67)), (((l_84.f0 , l_85) >= l_94) , 251UL))) , &g_67) != &l_94), 10)))), g_3)))) != g_3) > l_94) == l_85) >= 0xF6L) > l_85), g_3)));
        /* statement id: 227 */
        assert (g_113 == &g_67);
        //assert (g_203 == dangling || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
    }
    else
    { /* block id: 228 */
        int32_t l_388 = 0L;
        struct S0 l_389 = {16};
        struct S0 **l_432 = &g_204[0][1];
        struct S0 ****l_517 = &g_330[0][8];
        struct S0 l_610 = {22};
    }
    /* facts after branching */
    assert (g_113 == 0 || g_113 == &g_67);
    //assert (g_203 == dangling || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
    return p_74;
    /* statement id: 401 */
    //assert (func_73_rv == &g_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_109
 * writes: g_67 g_109
 */
inline static int32_t * func_75(uint8_t  p_76)
{ /* block id: 154 */
    uint32_t l_258[5][4][9] = {{{0x38292736L,0xD06CCA62L,18446744073709551607UL,2UL,0xD06CCA62L,0x05484D78L,7UL,0UL,5UL},{0xDE5451DFL,2UL,0x3699C2EDL,0x42DE1A71L,0xD06CCA62L,18446744073709551608UL,0x42DE1A71L,0x65D61E19L,0x12C39B06L},{0xD06CCA62L,0x6EBB1182L,0x05484D78L,18446744073709551615UL,0xD15D3D01L,0x12C39B06L,7UL,7UL,0x12C39B06L},{18446744073709551615UL,0x65D61E19L,18446744073709551615UL,0x65D61E19L,18446744073709551615UL,18446744073709551607UL,0x6DFE7475L,0x38292736L,5UL}},{{0x6DFE7475L,0x6EBB1182L,18446744073709551615UL,0x65D61E19L,0UL,0x3699C2EDL,18446744073709551615UL,0x6EBB1182L,0x23B1B58FL},{7UL,2UL,3UL,18446744073709551615UL,0x38292736L,18446744073709551607UL,0xD06CCA62L,0x6EBB1182L,0x05484D78L},{0x42DE1A71L,0xD06CCA62L,18446744073709551608UL,0x42DE1A71L,0x65D61E19L,0x12C39B06L,0xDE5451DFL,0x38292736L,3UL},{7UL,0x38292736L,18446744073709551608UL,2UL,2UL,18446744073709551608UL,0x38292736L,7UL,18446744073709551615UL}},{{0x6DFE7475L,2UL,3UL,7UL,0x65D61E19L,0x05484D78L,0x38292736L,0x65D61E19L,0xA9337A33L},{18446744073709551615UL,0x6DFE7475L,18446744073709551615UL,2UL,0x38292736L,18446744073709551607UL,0xDE5451DFL,0UL,18446744073709551615UL},{0xD06CCA62L,0x6DFE7475L,18446744073709551615UL,0x38292736L,0UL,0x23B1B58FL,0xD06CCA62L,0xDE5451DFL,3UL},{0xDE5451DFL,2UL,0x05484D78L,2UL,18446744073709551615UL,0x23B1B58FL,18446744073709551615UL,2UL,0x05484D78L}},{{0x38292736L,0x38292736L,0x3699C2EDL,7UL,0xD15D3D01L,18446744073709551607UL,0x6DFE7475L,0xDE5451DFL,0x23B1B58FL},{0x38292736L,0xD06CCA62L,18446744073709551607UL,2UL,0xD06CCA62L,0x05484D78L,7UL,0UL,5UL},{0xDE5451DFL,2UL,0x3699C2EDL,0x42DE1A71L,0xD06CCA62L,18446744073709551608UL,0x42DE1A71L,0x65D61E19L,0x12C39B06L},{0xD06CCA62L,0x6EBB1182L,0x05484D78L,18446744073709551615UL,0xD15D3D01L,0x12C39B06L,7UL,7UL,0x12C39B06L}},{{18446744073709551615UL,0x65D61E19L,18446744073709551615UL,0x65D61E19L,18446744073709551615UL,18446744073709551607UL,0x6DFE7475L,0x38292736L,5UL},{0x6DFE7475L,0x6EBB1182L,18446744073709551615UL,0x65D61E19L,0UL,0x3699C2EDL,18446744073709551615UL,0x6EBB1182L,0x23B1B58FL},{7UL,2UL,3UL,18446744073709551615UL,0x38292736L,0xD15D3D01L,0x22DA0C80L,0xB9F2B803L,0x65D61E19L},{18446744073709551609UL,0x22DA0C80L,0x42DE1A71L,18446744073709551609UL,0x363F8675L,0x6EBB1182L,0xDA417DDEL,0UL,0UL}}};
    const struct S0 *l_315 = &g_109;
    int32_t l_324 = 0x69C53B77L;
    int32_t **l_366 = &g_113;
    struct S0 *l_384 = &g_109;
    int32_t *l_385[4][8][6] = {{{&l_324,&g_67,&g_67,&g_67,(void*)0,&l_324},{&g_67,(void*)0,&l_324,&g_132,&l_324,&l_324},{(void*)0,(void*)0,&l_324,&l_324,(void*)0,(void*)0},{(void*)0,&g_67,&l_324,(void*)0,&g_132,&g_67},{&l_324,&l_324,&l_324,&g_132,&g_132,&g_132},{&l_324,(void*)0,&g_132,(void*)0,&l_324,&g_132},{(void*)0,&g_132,&g_132,&l_324,&g_132,&l_324},{(void*)0,&g_67,&g_132,&g_132,&l_324,&l_324}},{{&g_67,&g_132,&g_132,&g_67,&l_324,&g_132},{&l_324,&g_67,&g_132,&g_67,(void*)0,&g_132},{&g_132,(void*)0,&l_324,&g_67,(void*)0,&g_67},{&l_324,&g_67,&l_324,&l_324,&l_324,(void*)0},{&g_132,&g_132,&l_324,&g_132,&l_324,&l_324},{&g_67,&g_67,&l_324,&g_132,&g_132,&l_324},{&g_132,&g_132,&g_67,&l_324,&l_324,&l_324},{&l_324,(void*)0,&g_132,&g_67,&g_132,&g_67}},{{&g_132,&l_324,&g_132,&g_67,&g_132,&l_324},{&l_324,&g_67,&g_67,&g_67,(void*)0,&l_324},{&g_67,(void*)0,&l_324,&g_132,&l_324,&l_324},{(void*)0,(void*)0,&l_324,&l_324,(void*)0,(void*)0},{(void*)0,&g_67,&l_324,(void*)0,&g_132,&g_67},{&l_324,&l_324,&l_324,&g_132,&g_132,&g_132},{&l_324,(void*)0,&g_132,(void*)0,&l_324,&g_132},{(void*)0,&g_132,&g_132,&l_324,&g_132,&l_324}},{{(void*)0,&g_67,&g_132,&g_132,&l_324,&l_324},{&g_67,&g_132,&g_132,&g_67,&l_324,&g_132},{&l_324,&g_67,&g_132,&g_67,(void*)0,&g_132},{&g_132,(void*)0,&l_324,&g_67,(void*)0,&g_67},{&l_324,&g_67,&l_324,&l_324,&l_324,(void*)0},{&g_132,&g_132,&l_324,&l_324,&l_324,&g_67},{&g_67,(void*)0,(void*)0,&l_324,&l_324,(void*)0},{&g_132,&g_132,&g_67,(void*)0,&l_324,&l_324}}};
    int32_t *l_386 = &g_67;
    int i, j, k;
    for (g_67 = 6; (g_67 < 26); ++g_67)
    { /* block id: 157 */
        struct S0 l_251[3] = {{-26},{-26},{-26}};
        int32_t *l_266 = &g_132;
        struct S0 ****l_371 = &g_330[1][4];
        int32_t *l_376[10] = {&g_132,&g_132,&g_132,&g_132,&g_132,&g_132,&g_132,&g_132,&g_132,&g_132};
        const uint32_t l_378 = 0UL;
        float *l_380 = &g_241;
        struct S0 *l_381[8][1][6] = {{{&l_251[2],&l_251[2],&g_109,&g_109,&l_251[2],&l_251[2]}},{{&g_109,&l_251[2],&g_109,&l_251[2],&g_109,&l_251[2]}},{{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109}},{{&g_109,&g_109,&g_109,&l_251[2],&l_251[2],&l_251[2]}},{{&g_109,&g_109,&g_109,&g_109,&g_109,&g_109}},{{&l_251[2],&g_109,&g_109,&l_251[2],&g_109,&l_251[2]}},{{&l_251[2],&l_251[2],&g_109,&l_251[2],&l_251[2],&g_109}},{{&l_251[2],&l_251[2],&g_109,&g_109,&l_251[2],&l_251[2]}}};
        struct S0 **l_382[5] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
        int i, j, k;
    }
    (*l_384) = (*l_315);
    return l_386;
    /* statement id: 226 */
    //assert (func_75_rv == &g_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_67 g_3 g_109.f0 g_132 g_156 g_175 g_166 g_205 g_215 g_242 g_203 g_109
 * writes: g_67 g_109 g_113 g_132 g_166 g_203 g_241 g_215 g_204
 */
inline static uint32_t  func_79(const uint32_t  p_80, struct S0  p_81, int32_t  p_82, uint32_t  p_83)
{ /* block id: 40 */
    uint16_t l_95[3];
    struct S0 *l_140 = &g_109;
    struct S0 * const *l_139[2];
    float l_157[5][5][10] = {{{0x2.06065Fp-14,0xE.3A3813p+98,0xF.99C725p+95,0xC.A41F08p+19,0xB.BA722Ep+25,(-0x10.1p+1),0xE.3A3813p+98,0x7.77EAAEp-76,0x1.5p-1,0x1.Bp+1},{0xF.77404Bp+80,0x0.C586F4p+29,0xF.99C725p+95,0xB.BA722Ep+25,0x1.Ap-1,0x7.77EAAEp-76,0x0.C586F4p+29,0x7.77EAAEp-76,0x1.Ap-1,0xB.BA722Ep+25},{0xF.99C725p+95,0xB.4DF77Cp-41,0xF.99C725p+95,0x1.5p-1,0xC.A41F08p+19,0x2.06065Fp-14,0xB.4DF77Cp-41,0x7.77EAAEp-76,0x1.Bp+1,0x1.Ap-1},{(-0x10.1p+1),0x0.Ap+1,0xF.99C725p+95,0x1.Ap-1,0x1.5p-1,0xF.77404Bp+80,0x0.Ap+1,0x7.77EAAEp-76,0xC.A41F08p+19,0xC.A41F08p+19},{0x7.77EAAEp-76,0x9.E86370p-69,0xF.99C725p+95,0x1.Bp+1,0x1.Bp+1,0xF.99C725p+95,0x9.E86370p-69,0x7.77EAAEp-76,0xB.BA722Ep+25,0x1.5p-1}},{{0x2.06065Fp-14,0xE.3A3813p+98,0xF.99C725p+95,0xC.A41F08p+19,0xB.BA722Ep+25,(-0x10.1p+1),0xE.3A3813p+98,0x7.77EAAEp-76,0x1.5p-1,0x1.Bp+1},{0xF.77404Bp+80,0x0.C586F4p+29,0xF.99C725p+95,0xB.BA722Ep+25,0x1.Ap-1,0x7.77EAAEp-76,0x0.C586F4p+29,0x7.77EAAEp-76,0x1.Ap-1,0xB.BA722Ep+25},{0xF.99C725p+95,0xB.4DF77Cp-41,0xF.99C725p+95,0x1.5p-1,0xC.A41F08p+19,0x2.06065Fp-14,0xB.4DF77Cp-41,0x7.77EAAEp-76,0x1.Bp+1,0x1.Ap-1},{(-0x10.1p+1),0x0.Ap+1,0xF.99C725p+95,0x1.Ap-1,0x1.5p-1,0xF.77404Bp+80,0x0.Ap+1,0x7.77EAAEp-76,0xC.A41F08p+19,0xC.A41F08p+19},{0x7.77EAAEp-76,0x9.E86370p-69,0xF.99C725p+95,0x1.Bp+1,0x1.Bp+1,0xF.99C725p+95,0x9.E86370p-69,0x7.77EAAEp-76,0xB.BA722Ep+25,0x1.5p-1}},{{0x2.06065Fp-14,0xE.3A3813p+98,0xF.99C725p+95,0xC.A41F08p+19,0xB.BA722Ep+25,(-0x10.1p+1),0xE.3A3813p+98,0x7.77EAAEp-76,0x1.5p-1,0x1.Bp+1},{0xA.6B1FF0p-45,0x1.2p+1,(-0x1.3p+1),0xF.77404Bp+80,0x2.06065Fp-14,0x6.996BB9p+70,0x1.2p+1,0x6.996BB9p+70,0x2.06065Fp-14,0xF.77404Bp+80},{(-0x1.3p+1),(-0x1.9p-1),(-0x1.3p+1),(-0x10.1p+1),0x7.77EAAEp-76,0x4.0ACBBFp+84,(-0x1.9p-1),0x6.996BB9p+70,0xF.99C725p+95,0x2.06065Fp-14},{0xD.335754p-40,0x9.8p+1,(-0x1.3p+1),0x2.06065Fp-14,(-0x10.1p+1),0xA.6B1FF0p-45,0x9.8p+1,0x6.996BB9p+70,0x7.77EAAEp-76,0x7.77EAAEp-76},{0x6.996BB9p+70,0xA.1D5598p+97,(-0x1.3p+1),0xF.99C725p+95,0xF.99C725p+95,(-0x1.3p+1),0xA.1D5598p+97,0x6.996BB9p+70,0xF.77404Bp+80,(-0x10.1p+1)}},{{0x4.0ACBBFp+84,(-0x1.9p-1),(-0x1.3p+1),0x7.77EAAEp-76,0xF.77404Bp+80,0xD.335754p-40,(-0x1.9p-1),0x6.996BB9p+70,(-0x10.1p+1),0xF.99C725p+95},{0xA.6B1FF0p-45,0x1.2p+1,(-0x1.3p+1),0xF.77404Bp+80,0x2.06065Fp-14,0x6.996BB9p+70,0x1.2p+1,0x6.996BB9p+70,0x2.06065Fp-14,0xF.77404Bp+80},{(-0x1.3p+1),(-0x1.9p-1),(-0x1.3p+1),(-0x10.1p+1),0x7.77EAAEp-76,0x4.0ACBBFp+84,(-0x1.9p-1),0x6.996BB9p+70,0xF.99C725p+95,0x2.06065Fp-14},{0xD.335754p-40,0x9.8p+1,(-0x1.3p+1),0x2.06065Fp-14,(-0x10.1p+1),0xA.6B1FF0p-45,0x9.8p+1,0x6.996BB9p+70,0x7.77EAAEp-76,0x7.77EAAEp-76},{0x6.996BB9p+70,0xA.1D5598p+97,(-0x1.3p+1),0xF.99C725p+95,0xF.99C725p+95,(-0x1.3p+1),0xA.1D5598p+97,0x6.996BB9p+70,0xF.77404Bp+80,(-0x10.1p+1)}},{{0x4.0ACBBFp+84,(-0x1.9p-1),(-0x1.3p+1),0x7.77EAAEp-76,0xF.77404Bp+80,0xD.335754p-40,(-0x1.9p-1),0x6.996BB9p+70,(-0x10.1p+1),0xF.99C725p+95},{0xA.6B1FF0p-45,0x1.2p+1,(-0x1.3p+1),0xF.77404Bp+80,0x2.06065Fp-14,0x6.996BB9p+70,0x1.2p+1,0x6.996BB9p+70,0x2.06065Fp-14,0xF.77404Bp+80},{(-0x1.3p+1),(-0x1.9p-1),(-0x1.3p+1),(-0x10.1p+1),0x7.77EAAEp-76,0x4.0ACBBFp+84,(-0x1.9p-1),0x6.996BB9p+70,0xF.99C725p+95,0x2.06065Fp-14},{0xD.335754p-40,0x9.8p+1,(-0x1.3p+1),0x2.06065Fp-14,(-0x10.1p+1),0xA.6B1FF0p-45,0x9.8p+1,0x6.996BB9p+70,0x7.77EAAEp-76,0x7.77EAAEp-76},{0x6.996BB9p+70,0xA.1D5598p+97,(-0x1.3p+1),0xF.99C725p+95,0xF.99C725p+95,(-0x1.3p+1),0xA.1D5598p+97,0x6.996BB9p+70,0xF.77404Bp+80,(-0x10.1p+1)}}};
    int32_t * const *l_187[9][4][7] = {{{&g_113,(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113},{&g_113,&g_113,(void*)0,&g_113,(void*)0,&g_113,(void*)0},{&g_113,(void*)0,&g_113,(void*)0,&g_113,(void*)0,&g_113},{(void*)0,(void*)0,&g_113,&g_113,(void*)0,(void*)0,(void*)0}},{{(void*)0,&g_113,&g_113,(void*)0,&g_113,&g_113,&g_113},{&g_113,&g_113,(void*)0,&g_113,&g_113,(void*)0,&g_113},{&g_113,&g_113,&g_113,&g_113,(void*)0,&g_113,&g_113},{&g_113,(void*)0,(void*)0,(void*)0,&g_113,&g_113,(void*)0}},{{&g_113,(void*)0,&g_113,&g_113,&g_113,(void*)0,(void*)0},{(void*)0,&g_113,&g_113,&g_113,(void*)0,&g_113,&g_113},{(void*)0,(void*)0,&g_113,(void*)0,(void*)0,(void*)0,&g_113},{(void*)0,(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113}},{{(void*)0,&g_113,&g_113,(void*)0,&g_113,&g_113,(void*)0},{(void*)0,&g_113,&g_113,&g_113,(void*)0,(void*)0,&g_113},{(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113},{(void*)0,(void*)0,&g_113,(void*)0,(void*)0,(void*)0,&g_113}},{{&g_113,&g_113,&g_113,&g_113,&g_113,(void*)0,&g_113},{&g_113,&g_113,&g_113,&g_113,(void*)0,&g_113,(void*)0},{&g_113,(void*)0,&g_113,(void*)0,&g_113,&g_113,&g_113},{&g_113,(void*)0,&g_113,&g_113,(void*)0,(void*)0,(void*)0}},{{(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113},{(void*)0,&g_113,(void*)0,&g_113,&g_113,(void*)0,&g_113},{&g_113,&g_113,&g_113,&g_113,(void*)0,&g_113,&g_113},{&g_113,(void*)0,(void*)0,(void*)0,(void*)0,&g_113,&g_113}},{{&g_113,(void*)0,&g_113,&g_113,&g_113,(void*)0,(void*)0},{(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113},{(void*)0,&g_113,&g_113,&g_113,(void*)0,(void*)0,&g_113},{(void*)0,(void*)0,(void*)0,&g_113,&g_113,&g_113,&g_113}},{{(void*)0,&g_113,&g_113,(void*)0,&g_113,&g_113,(void*)0},{(void*)0,&g_113,&g_113,&g_113,(void*)0,(void*)0,(void*)0},{(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113,&g_113},{(void*)0,(void*)0,&g_113,(void*)0,(void*)0,(void*)0,&g_113}},{{&g_113,(void*)0,&g_113,&g_113,&g_113,&g_113,&g_113},{&g_113,&g_113,(void*)0,&g_113,(void*)0,&g_113,(void*)0},{&g_113,(void*)0,&g_113,(void*)0,&g_113,(void*)0,&g_113},{(void*)0,(void*)0,&g_113,&g_113,(void*)0,(void*)0,(void*)0}}};
    int32_t l_190[5][4][1] = {{{(-1L)},{0x3325B3C6L},{(-1L)},{(-1L)}},{{0x3325B3C6L},{(-1L)},{1L},{0x3325B3C6L}},{{1L},{(-1L)},{0x3325B3C6L},{(-1L)}},{{(-1L)},{0x3325B3C6L},{(-1L)},{1L}},{{0x3325B3C6L},{1L},{(-1L)},{0x3325B3C6L}}};
    int32_t *l_211 = &g_132;
    int32_t *l_221[2];
    int i, j, k;
    for (i = 0; i < 3; i++)
        l_95[i] = 65535UL;
    for (i = 0; i < 2; i++)
        l_139[i] = &l_140;
    for (i = 0; i < 2; i++)
        l_221[i] = &g_132;
    for (p_83 = 0; (p_83 <= 2); p_83 += 1)
    { /* block id: 43 */
        int32_t *l_96 = &g_67;
        int32_t **l_97 = &l_96;
        (*l_97) = l_96;
    }
    for (g_67 = 19; (g_67 < 22); g_67 = safe_add_func_uint16_t_u_u(g_67, 6))
    { /* block id: 48 */
        int32_t *l_107 = &g_67;
        struct S0 l_143 = {1};
        int32_t l_165 = 0x34686610L;
        struct S0 **l_191 = &l_140;
        if (((((safe_mul_func_int16_t_s_s(g_67, l_95[2])) > g_67) | ((p_80 < (~(safe_mod_func_int64_t_s_s((safe_add_func_uint32_t_u_u(l_95[1], 4294967286UL)), g_67)))) && p_80)) & ((void*)0 == l_107)))
        { /* block id: 49 */
            int32_t l_124 = 0x1DDE4E4CL;
            struct S0 * const *l_192 = &l_140;
            int32_t *l_200 = &g_132;
            if (g_3)
            { /* block id: 50 */
                const int32_t l_110 = 0x3D91D694L;
                if (g_3)
                { /* block id: 51 */
                    struct S0 *l_108 = &g_109;
                    int32_t l_138 = (-1L);
                    (*l_108) = p_81;
                    if (l_110)
                        continue;
                    for (p_83 = 0; (p_83 < 43); p_83 = safe_add_func_uint32_t_u_u(p_83, 9))
                    { /* block id: 56 */
                        int32_t *l_133 = &l_124;
                        g_113 = &g_67;
                        /* statement id: 57 */
                        assert (g_113 == &g_67);
                        (*l_133) = (safe_mod_func_uint64_t_u_u(__builtin_ctzl(((g_67 , (safe_sub_func_int16_t_s_s((-8L), (safe_mod_func_int8_t_s_s(((safe_rshift_func_int16_t_s_s((((safe_add_func_uint8_t_u_u(l_124, ((((safe_div_func_float_f_f(p_83, (__builtin_ia32_crc32qi(((p_82 >= ((p_82 ^ (0xCEE11437717E41ABLL < (0xD9L <= l_95[2]))) & g_109.f0)) , 4294967294UL), l_124) > l_95[0]))) != p_82) , g_67) || 0UL))) , (void*)0) != &p_82), 0)) , g_109.f0), 0x57L))))) & 0x8AE8L)), p_81.f0));
                        (*l_133) = ((*l_133) != (safe_mod_func_int16_t_s_s((((__builtin_ffs(l_110) > ((safe_sub_func_int64_t_s_s(((g_3 , 8L) | p_83), l_110)) , (&p_81 == (void*)0))) & l_138) ^ (*l_133)), g_109.f0)));
                        if (p_80)
                            continue;
                    }
                    /* facts after for loop */
                    assert (g_113 == &g_67 || g_113 == &p_82 || g_113 == 0);
                }
                else
                { /* block id: 62 */
                    struct S0 * const **l_141 = &l_139[1];
                    (*l_141) = l_139[1];
                    if ((~l_124))
                    { /* block id: 64 */
                        (***l_141) = l_143;
                    }
                    else
                    { /* block id: 66 */
                        int64_t l_144 = 0L;
                        return l_144;
                        /* statement id: 67 */
                        //assert (g_113 == dangling || g_113 == 0);
                    }
                }
                /* facts after branching */
                assert (g_113 == &g_67 || g_113 == &p_82 || g_113 == 0);
            }
            else
            { /* block id: 70 */
                uint8_t l_149 = 0x06L;
                for (l_124 = 0; (l_124 <= 2); l_124 += 1)
                { /* block id: 73 */
                    if (p_81.f0)
                        break;
                    return g_132;
                    /* statement id: 75 */
                    //assert (g_113 == dangling || g_113 == 0);
                }
                if (l_95[0])
                { /* block id: 77 */
                    uint32_t l_152 = 0x37417BD2L;
                    const int32_t *l_154 = &g_67;
                    if (((safe_add_func_int32_t_s_s((__builtin_parityl(g_109.f0) != (&l_140 == (void*)0)), (safe_rshift_func_uint16_t_u_s((p_81 , l_149), 12)))) > (safe_add_func_int8_t_s_s(l_152, (!p_81.f0)))))
                    { /* block id: 78 */
                        const int32_t **l_155 = &l_154;
                        int32_t *l_158[2][6][3] = {{{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0}},{{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0},{&g_132,&g_132,(void*)0}}};
                        int i, j, k;
                        (*l_155) = (((l_149 , g_109.f0) & (-10L)) , l_154);
                        (*g_156) = l_124;
                        p_82 = (*l_107);
                        g_166 = (safe_div_func_float_f_f(p_82, ((safe_div_func_float_f_f(((safe_mul_func_float_f_f(0x5.Cp-1, (g_132 , (g_3 == l_95[1])))) < (*l_107)), (((l_95[0] != p_81.f0) != l_95[0]) >= l_165))) == 0x2.Ap-1)));
                    }
                    else
                    { /* block id: 83 */
                        int8_t l_171 = 0x39L;
                        (*g_175) = (((safe_mod_func_int64_t_s_s((safe_mul_func_uint16_t_u_u((*l_107), ((p_82 != (l_171 , l_95[2])) , (safe_sub_func_int32_t_s_s(((__builtin_clz(l_171) != p_80) ^ (((safe_unary_minus_func_uint8_t_u((*l_107))) , (l_149 & 0xCD6CAE52F1CB2A3ALL)) > p_81.f0)), l_95[1]))))), 0xD579426CD91451F1LL)) , (-3L)) , (*l_107));
                        if (l_149)
                            break;
                    }
                }
                else
                { /* block id: 87 */
                    uint8_t l_195 = 255UL;
                    (*g_156) = (l_124 != (safe_mul_func_uint8_t_u_u(g_166, g_67)));
                    p_81.f0 = (((((safe_mod_func_int64_t_s_s(0x271B26D052D8D885LL, g_132)) && (((((*l_107) , (+(p_83 || (safe_lshift_func_int8_t_s_u((g_3 == (safe_lshift_func_uint16_t_u_s((safe_mul_func_uint16_t_u_u((p_83 || ((void*)0 == l_187[3][1][2])), ((safe_div_func_uint16_t_u_u(l_190[0][1][0], g_109.f0)) >= p_80))), 1))), 6))))) , l_191) == l_192) && 1UL)) & p_82) || p_83) , (*g_175));
                    if ((*l_107))
                    { /* block id: 90 */
                        if (p_83)
                            break;
                        return g_3;
                        /* statement id: 92 */
                        //assert (g_113 == dangling || g_113 == 0);
                    }
                    else
                    { /* block id: 93 */
                        float *l_196 = &l_157[0][2][9];
                        (*l_196) = (safe_div_func_float_f_f(l_195, 0x1.3DA0F2p-88));
                        (*l_140) = p_81;
                    }
                }
                for (l_165 = (-26); (l_165 <= 29); ++l_165)
                { /* block id: 100 */
                    (*l_191) = &g_109;
                    l_200 = &g_132;
                    for (l_124 = 0; (l_124 <= 3); l_124 += 1)
                    { /* block id: 105 */
                        int32_t *l_201 = &g_132;
                        int32_t **l_210[5][6][5] = {{{(void*)0,(void*)0,&l_200,&l_107,&l_201},{&l_201,(void*)0,&l_107,&g_113,(void*)0},{&l_201,&g_113,&g_113,&l_200,&g_113},{&g_113,&l_200,&l_201,&l_107,&g_113},{&l_200,(void*)0,(void*)0,&l_107,(void*)0},{&l_201,&l_107,&l_201,(void*)0,&l_201}},{{&l_200,&l_200,&l_200,(void*)0,&l_107},{&l_201,&l_200,&l_201,(void*)0,&g_113},{&l_107,(void*)0,&l_107,&l_107,&g_113},{&g_113,&l_200,&g_113,&l_200,(void*)0},{&l_201,&l_200,&l_107,&l_107,&l_200},{&l_200,&l_107,&l_107,(void*)0,(void*)0}},{{&l_107,(void*)0,&l_201,&l_107,&l_200},{&l_200,&l_200,&l_201,&l_107,&l_107},{(void*)0,&g_113,&l_201,(void*)0,&l_200},{(void*)0,(void*)0,&l_107,&l_107,(void*)0},{&g_113,(void*)0,&l_107,&l_200,&l_201},{&l_201,&l_200,(void*)0,&l_107,(void*)0}},{{&l_200,&l_201,(void*)0,(void*)0,&l_107},{&l_201,(void*)0,&l_201,(void*)0,&l_201},{&g_113,&l_201,&g_113,(void*)0,&l_107},{(void*)0,&l_201,&g_113,&l_107,&g_113},{(void*)0,(void*)0,&l_200,&l_107,(void*)0},{&l_200,&l_201,&l_200,&l_200,&l_107}},{{&l_107,&g_113,&g_113,&g_113,&l_200},{&l_107,(void*)0,&g_113,(void*)0,&l_107},{(void*)0,&l_200,&l_107,&l_107,&l_107},{&l_107,&g_113,&l_200,&g_113,(void*)0},{&l_201,(void*)0,&l_107,&l_200,&l_107},{&l_200,&g_113,&l_200,(void*)0,&l_107}}};
                        int i, j, k;
                        (*g_175) = (*g_175);
                        l_201 = &p_82;
                        /* statement id: 107 */
                        assert (l_201 == &p_82);
                        (*g_205) = &l_140;
                        /* statement id: 108 */
                        assert (g_203 == &l_140);
                        l_211 = ((*l_201) , ((safe_sub_func_int8_t_s_s((g_3 == (p_82 <= g_132)), g_3)) , (void*)0));
                        /* statement id: 109 */
                        assert (l_211 == 0);
                    }
                    p_81 = p_81;
                }
                /* facts after for loop */
                assert (g_203 == &l_140 || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
                assert (l_211 == 0 || l_211 == &g_132);
                for (l_165 = 0; l_165 < 5; l_165 += 1)
                {
                    for (l_124 = 0; l_124 < 4; l_124 += 1)
                    {
                        for (p_83 = 0; p_83 < 1; p_83 += 1)
                        {
                            l_190[l_165][l_124][p_83] = 0x35F8E2DFL;
                        }
                    }
                }
            }
            /* facts after branching */
            assert (g_113 == &g_67 || g_113 == &p_82 || g_113 == 0);
            assert (g_203 == &l_140 || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
            assert (l_211 == 0 || l_211 == &g_132);
            return p_80;
            /* statement id: 115 */
            //assert (g_113 == &g_67 || g_113 == dangling || g_113 == 0);
            //assert (g_203 == dangling || (g_203 >= &g_204[0][0] && g_203 <= &g_204[1][8]));
        }
        else
        { /* block id: 116 */
            const int16_t l_220 = 1L;
            int32_t **l_222 = &g_113;
            (*l_211) = ((~((((((g_3 > g_132) <= 9L) , (((safe_mul_func_uint16_t_u_u(1UL, g_215)) , (void*)0) == &l_211)) , (safe_add_func_uint8_t_u_u(g_109.f0, __builtin_parity((safe_add_func_int32_t_s_s((*l_107), l_220)))))) || (*l_211)) & g_67)) , (*l_107));
            (*l_222) = l_221[0];
            /* statement id: 118 */
            assert (g_113 == &g_132);
            (*l_222) = (void*)0;
            /* statement id: 119 */
            assert (g_113 == 0);
            for (l_165 = 0; (l_165 == (-7)); --l_165)
            { /* block id: 122 */
                (*l_211) = (safe_rshift_func_uint16_t_u_s(0x8299L, 14));
                (*l_222) = &p_82;
                /* statement id: 124 */
                assert (g_113 == &p_82);
            }
            /* facts after for loop */
            assert (g_113 == &p_82 || g_113 == 0);
        }
        (*g_242) = (safe_sub_func_float_f_f(__builtin_parityll((safe_unary_minus_func_uint8_t_u(g_3))), (((-0x1.6p+1) == g_109.f0) < (safe_div_func_float_f_f(p_82, (safe_mul_func_float_f_f(((safe_sub_func_float_f_f(((safe_sub_func_float_f_f((safe_add_func_float_f_f((g_67 >= (((*l_107) != (-0x6.4p-1)) < __builtin_popcountll(g_166))), p_82)), (-0x1.9p-1))) < p_82), p_81.f0)) > 0xA.22D9D8p+96), 0x1.ED5A70p+79)))))));
        for (p_83 = 0; (p_83 <= 1); p_83 += 1)
        { /* block id: 130 */
            if ((*l_107))
                break;
        }
        for (g_215 = 1; (g_215 <= 5); g_215 += 1)
        { /* block id: 135 */
            (*g_203) = (void*)0;
            for (l_165 = 1; (l_165 <= 5); l_165 += 1)
            { /* block id: 139 */
                (*l_140) = (**l_191);
                return g_132;
                /* statement id: 141 */
                //assert (g_113 == dangling || g_113 == 0);
            }
        }
    }
    /* facts after for loop */
    assert (g_113 == &p_82 || g_113 == 0);
    (*l_211) = (*g_156);
    for (g_215 = 11; (g_215 <= 30); g_215++)
    { /* block id: 148 */
        struct S0 l_245 = {-20};
        int32_t **l_246 = &g_113;
        l_245 = (*l_140);
        (*l_246) = (void*)0;
        /* statement id: 150 */
        assert (g_113 == 0);
        return g_109.f0;
    }
    return p_82;
    /* statement id: 153 */
    //assert (g_113 == dangling || g_113 == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int i, j, k;
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_67, "g_67", print_hash_value);
    transparent_crc(g_109.f0, "g_109.f0", print_hash_value);
    transparent_crc(g_132, "g_132", print_hash_value);
    transparent_crc(g_166, "g_166", print_hash_value);
    transparent_crc(g_215, "g_215", print_hash_value);
    transparent_crc_bytes (&g_241, sizeof(g_241), "g_241", print_hash_value);
    transparent_crc(g_286, "g_286", print_hash_value);
    transparent_crc(g_370, "g_370", print_hash_value);
    transparent_crc(g_598, "g_598", print_hash_value);
    for (i = 0; i < 6; i++)
    {
        transparent_crc(g_736[i], "g_736[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_750, "g_750", print_hash_value);
    transparent_crc(g_884.f0, "g_884.f0", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 192
   depth: 1, occurrence: 42
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 76
breakdown:
   indirect level: 0, occurrence: 42
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 12
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 10
   indirect level: 5, occurrence: 4
XXX full-bitfields structs in the program: 42
breakdown:
   indirect level: 0, occurrence: 42
XXX times a bitfields struct's address is taken: 35
XXX times a bitfields struct on LHS: 17
XXX times a bitfields struct on RHS: 57
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 86

XXX max expression depth: 40
breakdown:
   depth: 1, occurrence: 265
   depth: 2, occurrence: 61
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 3
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1
   depth: 40, occurrence: 1

XXX total number of pointers: 216

XXX times a variable address is taken: 398
XXX times a pointer is dereferenced on RHS: 106
breakdown:
   depth: 1, occurrence: 92
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
XXX times a pointer is dereferenced on LHS: 123
breakdown:
   depth: 1, occurrence: 119
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 18
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 957

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1197
   level: 2, occurrence: 68
   level: 3, occurrence: 45
   level: 4, occurrence: 38
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 122
XXX number of pointers point to scalars: 76
XXX number of pointers point to structs: 18
XXX percent of pointers has null in alias set: 27.8
XXX average alias set size: 1.34

XXX times a non-volatile is read: 950
XXX times a non-volatile is write: 352
XXX times a volatile is read: 62
XXX    times read thru a pointer: 18
XXX times a volatile is write: 38
XXX    times written thru a pointer: 5
XXX times a volatile is available for access: 543
XXX percentage of non-volatile access: 92.9

XXX forward jumps: 0
XXX backward jumps: 5

XXX stmts: 243
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 22
   depth: 2, occurrence: 22
   depth: 3, occurrence: 44
   depth: 4, occurrence: 58
   depth: 5, occurrence: 65

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

