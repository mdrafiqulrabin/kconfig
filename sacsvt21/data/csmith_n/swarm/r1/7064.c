/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --uint8 --float --no-math64 --no-inline-function --no-muls --safe-math --packed-struct --paranoid --pointers --no-structs --no-unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      2636262990
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
static int16_t  func_6(int32_t  p_7);
static uint32_t  func_14(int32_t  p_15, int32_t  p_16);
static int32_t  func_21(uint32_t  p_22);
static uint32_t  func_23(uint32_t  p_24);
static int32_t * func_25(uint16_t  p_26, uint8_t  p_27, const uint16_t  p_28, int32_t * p_29, uint32_t  p_30);
static uint16_t  func_31(int32_t * p_32, int16_t  p_33);
static int32_t * func_34(int32_t * p_35, uint8_t  p_36, int32_t * p_37, uint16_t  p_38, int32_t * p_39);
static int32_t  func_42(int32_t * p_43, int32_t * p_44, int32_t * p_45);
static int32_t * func_46(int32_t * p_47, int32_t  p_48);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    int32_t l_2 = 4;
    float l_205 = 0x3.BAEACEp-81;
    int32_t l_208 = 0;
    for (l_2 = (-7); (l_2 <= 11); l_2 = safe_add_func_int16_t_s_s(l_2, 4))
    { /* block id: 3 */
        int16_t l_5[9] = {0xD15D,0xD15D,0xD15D,0xD15D,0xD15D,0xD15D,0xD15D,0xD15D,0xD15D};
        int16_t l_206 = 4;
        int32_t l_212[10] = {0xFA35CBEA,(-1),0xFA35CBEA,0xFA35CBEA,(-1),0xFA35CBEA,0xFA35CBEA,(-1),0xFA35CBEA,0xFA35CBEA};
        int32_t *l_211 = &l_212[3];
        int i;
        (*l_211) = (((l_5[4] || l_2) >= func_6(((safe_mod_func_uint8_t_u_u(((safe_div_func_uint32_t_u_u((safe_div_func_int16_t_s_s(((func_14((safe_rshift_func_int16_t_s_s((safe_sub_func_uint32_t_u_u(0xFEB9E9D6, func_21(func_23(l_5[7])))), (safe_unary_minus_func_int32_t_s(l_5[5])))), l_206) & l_206) & l_5[8]), 65535U)), l_5[4])) < l_208), l_2)) && l_206))) >= l_2);
    }
    return l_208;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_6(int32_t  p_7)
{ /* block id: 110 */
    float l_209[7][5] = {{0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35},{0x0.1p-1,0x0.1p-1,0x0.1p-1,0x0.1p-1,0x0.1p-1},{0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35},{0x0.1p-1,0x0.1p-1,0x0.1p-1,0x0.1p-1,0x0.1p-1},{0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35},{0x0.1p-1,0x0.1p-1,0x0.1p-1,0x0.1p-1,0x0.1p-1},{0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35,0xC.645F29p-35}};
    int32_t l_210[9][2][7];
    int i, j, k;
    for (i = 0; i < 9; i = i + 1)
    {
        for (j = 0; j < 2; j = j + 1)
        {
            for (k = 0; k < 7; k = k + 1)
                l_210[i][j][k] = (-2);
        }
    }
    for (p_7 = 0; p_7 < 7; p_7 += 1)
    {
        for (l_210[7][1][3] = 0; l_210[7][1][3] < 5; l_210[7][1][3] += 1)
        {
            l_209[p_7][l_210[7][1][3]] = 0xF.5DDE06p-78;
        }
    }
    return l_210[7][1][3];
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_14(int32_t  p_15, int32_t  p_16)
{ /* block id: 108 */
    uint16_t l_207 = 0x47FD;
    return l_207;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_21(uint32_t  p_22)
{ /* block id: 105 */
    int32_t l_202 = 0xF7DCBD80;
    int32_t *l_201 = &l_202;
    int32_t **l_203 = &l_201;
    (*l_203) = l_201;
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_23(uint32_t  p_24)
{ /* block id: 4 */
    int32_t l_41 = 0xC39D5B61;
    int32_t *l_40 = &l_41;
    const int32_t *l_49 = &l_41;
    int32_t l_111 = 0x914032C2;
    const uint8_t l_190 = 255U;
    int32_t **l_199 = (void*)0;
    int32_t **l_200 = &l_40;
    (*l_200) = func_25(func_31(func_34(l_40, p_24, &l_41, (((*l_40) < func_42(func_46(&l_41, (&l_41 == l_49)), &l_41, &l_41)) & l_111), &l_41), (*l_40)), p_24, l_190, &l_41, (*l_49));
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_25(uint16_t  p_26, uint8_t  p_27, const uint16_t  p_28, int32_t * p_29, uint32_t  p_30)
{ /* block id: 87 */
    int32_t **l_191 = (void*)0;
    int32_t l_194 = 0xD21332A2;
lbl_198:
    l_191 = (void*)0;
    for (p_30 = 12; (p_30 >= 22); p_30 = safe_add_func_int16_t_s_s(p_30, 3))
    { /* block id: 91 */
        int32_t l_197[1];
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_197[i] = 0x37F1D822;
        l_194 = p_27;
        for (p_26 = 0; (p_26 < 26); p_26 = safe_add_func_uint32_t_u_u(p_26, 1))
        { /* block id: 95 */
            return p_29;
            /* statement id: 96 */
            //assert (func_25_rv == &l_41);
        }
        for (l_194 = 0; l_194 < 1; l_194 += 1)
        {
            l_197[l_194] = 4;
        }
        return p_29;
        /* statement id: 99 */
        //assert (func_25_rv == &l_41);
    }
    if (p_27)
        goto lbl_198;
    return p_29;
    /* statement id: 102 */
    //assert (func_25_rv == &l_41);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_31(int32_t * p_32, int16_t  p_33)
{ /* block id: 76 */
    float *l_178 = (void*)0;
    float l_180[6] = {0xB.FB3CCEp-76,0x2.C9179Ap+65,0xB.FB3CCEp-76,0xB.FB3CCEp-76,0x2.C9179Ap+65,0xB.FB3CCEp-76};
    float *l_179[9][7] = {{(void*)0,&l_180[5],&l_180[5],(void*)0,(void*)0,&l_180[5],&l_180[5]},{(void*)0,&l_180[5],(void*)0,&l_180[5],(void*)0,&l_180[5],(void*)0},{(void*)0,(void*)0,&l_180[5],&l_180[5],(void*)0,(void*)0,&l_180[5]},{&l_180[3],&l_180[5],&l_180[3],&l_180[5],&l_180[3],&l_180[5],&l_180[3]},{(void*)0,&l_180[5],&l_180[5],(void*)0,(void*)0,&l_180[5],&l_180[5]},{(void*)0,&l_180[5],(void*)0,&l_180[5],(void*)0,&l_180[5],(void*)0},{(void*)0,(void*)0,&l_180[5],&l_180[5],(void*)0,(void*)0,&l_180[5]},{&l_180[3],&l_180[5],&l_180[3],&l_180[5],&l_180[3],&l_180[5],&l_180[3]},{(void*)0,&l_180[5],&l_180[5],(void*)0,(void*)0,&l_180[5],&l_180[5]}};
    int32_t l_181 = 0x4B72DBC9;
    int32_t *l_187 = &l_181;
    int32_t *l_188[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int32_t **l_189 = &l_187;
    int i, j;
    l_181 = p_33;
    if (p_33)
        goto lbl_186;
lbl_186:
    for (l_181 = 0; (l_181 > 24); l_181 = safe_add_func_uint16_t_u_u(l_181, 1))
    { /* block id: 80 */
        int32_t *l_185 = &l_181;
        int32_t **l_184 = &l_185;
        (*l_184) = p_32;
        /* statement id: 81 */
        //assert (l_185 == &l_41);
    }
    l_187 = p_32;
    /* statement id: 84 */
    //assert (l_187 == &l_41);
    (*l_189) = l_188[2];
    /* statement id: 85 */
    assert (l_187 == 0 || l_187 == &l_181);
    return p_33;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_34(int32_t * p_35, uint8_t  p_36, int32_t * p_37, uint16_t  p_38, int32_t * p_39)
{ /* block id: 50 */
    int32_t l_117 = 0xCDBA6A34;
    int32_t *l_116 = &l_117;
    int32_t **l_115 = &l_116;
    int32_t ***l_114[6][10][4] = {{{(void*)0,&l_115,&l_115,(void*)0},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{(void*)0,&l_115,(void*)0,&l_115},{(void*)0,&l_115,&l_115,(void*)0},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{(void*)0,&l_115,(void*)0,&l_115}},{{(void*)0,&l_115,&l_115,(void*)0},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{(void*)0,&l_115,(void*)0,&l_115},{(void*)0,&l_115,&l_115,(void*)0},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{(void*)0,&l_115,(void*)0,&l_115}},{{(void*)0,&l_115,&l_115,(void*)0},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{&l_115,&l_115,&l_115,&l_115},{(void*)0,&l_115,(void*)0,&l_115},{(void*)0,&l_115,&l_115,(void*)0},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0}},{{&l_115,(void*)0,(void*)0,&l_115},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0},{&l_115,(void*)0,(void*)0,&l_115},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0}},{{&l_115,(void*)0,(void*)0,&l_115},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0},{&l_115,(void*)0,(void*)0,&l_115},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0}},{{&l_115,(void*)0,(void*)0,&l_115},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0},{&l_115,(void*)0,(void*)0,&l_115},{&l_115,(void*)0,&l_115,(void*)0},{(void*)0,&l_115,&l_115,&l_115},{&l_115,&l_115,(void*)0,&l_115},{&l_115,&l_115,&l_115,(void*)0}}};
    float l_135[5];
    float *l_134 = &l_135[1];
    int32_t *l_169 = &l_117;
    int i, j, k;
    for (i = 0; i < 5; i = i + 1)
        l_135[i] = 0x0.5p-1;
    (*l_134) = (safe_div_func_float_f_f(((((l_114[4][0][3] != &l_115) != (safe_sub_func_float_f_f(((safe_div_func_float_f_f(((*l_116) != (safe_add_func_float_f_f((safe_add_func_float_f_f(p_36, ((safe_sub_func_float_f_f(0xE.9D60F7p+2, (safe_add_func_float_f_f(((((!(safe_sub_func_float_f_f(0x1.54446Dp-71, p_36))) < (-(p_38 == (-0x2.9p+1)))) > 0xF.8EFC5Dp+59) != (-0x1.9p-1)), p_38)))) == (**l_115)))), p_38))), 0x0.FBE715p-66)) != (**l_115)), p_36))) <= p_36) != (*l_116)), p_36));
    for (p_36 = 25; (p_36 == 9); p_36 = safe_sub_func_int16_t_s_s(p_36, 2))
    { /* block id: 54 */
        int32_t l_155 = 0x39CC89D9;
        if ((safe_sub_func_int8_t_s_s((-4), (((!p_38) > (!(p_37 == p_37))) || (((p_38 != 0x97) != (&p_37 == &p_37)) < (~p_36))))))
        { /* block id: 55 */
            uint32_t l_168 = 0x4AF5C048;
            (*l_134) = (((safe_div_func_float_f_f(p_36, (p_39 != p_35))) == ((safe_add_func_float_f_f(((safe_add_func_float_f_f((safe_sub_func_float_f_f(p_38, (p_36 < (p_39 == (*l_115))))), 0xD.7F8654p+84)) == (safe_sub_func_float_f_f((l_155 >= p_36), 0x6.E2DD19p+91))), p_38)) >= l_155)) <= 0xD.7E1E0Ap+89);
            for (p_38 = 0; (p_38 > 9); p_38 = safe_add_func_uint32_t_u_u(p_38, 1))
            { /* block id: 59 */
                l_168 = (safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u((l_155 && (~(safe_div_func_int16_t_s_s(p_38, (((&p_37 != &p_35) > (!(*l_116))) | (safe_rshift_func_uint16_t_u_u(((p_38 || (2 >= (*p_35))) || ((((p_36 >= 0x6490) != p_38) | p_38) & 7U)), p_38))))))), 4)), p_38));
                return p_35;
                /* statement id: 61 */
                //assert (func_34_rv == &l_41);
            }
            p_39 = func_46(func_46(l_169, ((((*p_39) || 4294967295U) != (((((((0x2B29 <= (((*l_116) >= (0xCA <= (p_38 <= (safe_sub_func_int8_t_s_s((safe_div_func_uint16_t_u_u(p_36, (safe_mod_func_uint16_t_u_u((p_38 <= (**l_115)), l_155)))), 0x75))))) || 255U)) || 0x68CF5763) || p_36) == l_168) & p_38) || l_155) > (*l_116))) >= l_155)), l_168);
            /* statement id: 63 */
            assert (p_39 == &l_117);
        }
        else
        { /* block id: 64 */
            (**l_115) = (*p_37);
            for (l_155 = 0; (l_155 == 26); l_155 = safe_add_func_uint8_t_u_u(l_155, 2))
            { /* block id: 68 */
                return p_35;
                /* statement id: 69 */
                //assert (func_34_rv == &l_41);
            }
            (*l_115) = func_46((*l_115), p_36);
        }
    }
    /* facts after for loop */
    //assert (p_39 == &l_41 || p_39 == &l_117);
    for (p_38 = 0; p_38 < 5; p_38 += 1)
    {
        l_135[p_38] = 0x0.9p-1;
    }
    return p_37;
    /* statement id: 75 */
    //assert (func_34_rv == &l_41);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_42(int32_t * p_43, int32_t * p_44, int32_t * p_45)
{ /* block id: 35 */
    int32_t **l_84[2];
    uint32_t l_85 = 1U;
    float l_87[8] = {0x7.579B7Bp+58,0x7.579B7Bp+58,0x7.579B7Bp+58,0x7.579B7Bp+58,0x7.579B7Bp+58,0x7.579B7Bp+58,0x7.579B7Bp+58,0x7.579B7Bp+58};
    float *l_86 = &l_87[1];
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_84[i] = (void*)0;
    p_44 = (void*)0;
    /* statement id: 36 */
    assert (p_44 == 0);
    (*l_86) = (l_85 >= (0xB.59CA02p-18 > ((void*)0 == p_43)));
    for (l_85 = 0; (l_85 > 11); l_85 = safe_add_func_uint32_t_u_u(l_85, 7))
    { /* block id: 40 */
        int32_t l_90 = (-6);
        const int32_t *l_96 = &l_90;
        const int32_t **l_95 = &l_96;
        const int32_t ***l_94 = &l_95;
        for (l_90 = 0; (l_90 <= 7); l_90 += 1)
        { /* block id: 43 */
            uint8_t l_93 = 0x7A;
            int i;
            l_87[l_90] = (safe_div_func_float_f_f(((0xE.885CB6p+28 >= 0x3.6p+1) > (0x1.9p-1 == l_90)), l_93));
        }
        (*l_94) = l_84[0];
        /* statement id: 46 */
        assert (l_95 == 0);
        p_44 = func_46(&l_90, (safe_div_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u((safe_add_func_uint32_t_u_u((0x9F7A & (!1U)), (*p_45))), 0)), (safe_div_func_int8_t_s_s(((((((*l_96) & (safe_unary_minus_func_uint16_t_u(4U))) != (((safe_sub_func_int32_t_s_s(0x934167AD, ((*l_96) > 0x22))) < 1) == 0xAA494CAA)) == (*l_96)) || (*l_96)) & (*l_96)), (*l_96))))));
        /* statement id: 47 */
        assert (p_44 == &l_90);
    }
    /* facts after for loop */
    //assert (p_44 == dangling || p_44 == 0);
    return (*p_45);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_46(int32_t * p_47, int32_t  p_48)
{ /* block id: 5 */
    const uint8_t l_50 = 0U;
    float l_52 = 0xE.42E5F0p+66;
    float *l_51[10][3] = {{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52},{&l_52,&l_52,&l_52}};
    int32_t l_53 = 0xE22955D4;
    uint32_t l_73 = 1U;
    uint32_t l_74 = 4294967295U;
    int32_t *l_82[7] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
    int i, j;
    l_53 = (((p_48 <= l_50) <= l_50) == l_50);
    if ((p_48 <= ((((safe_rshift_func_int16_t_s_u((safe_div_func_int8_t_s_s((((safe_lshift_func_int8_t_s_u((~(safe_mod_func_uint8_t_u_u(((safe_mod_func_uint32_t_u_u(((void*)0 != p_47), (safe_rshift_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_s(((safe_add_func_int32_t_s_s((((*p_47) > ((safe_sub_func_int32_t_s_s(l_53, (p_47 == (void*)0))) == ((&l_53 != (void*)0) & l_53))) ^ 0), 0x8404D083)) | l_73), l_50)), p_48)))) & l_74), l_53))), l_74)) || l_74) || 0x88F3), p_48)), 1)) & l_74) != l_50) > p_48)))
    { /* block id: 7 */
        int32_t *l_77 = &l_53;
lbl_81:
        for (l_53 = 2; (l_53 >= 0); l_53 -= 1)
        { /* block id: 10 */
            if ((*p_47))
                break;
            for (l_74 = 0; (l_74 <= 2); l_74 += 1)
            { /* block id: 14 */
                int i, j;
                return p_47;
                /* statement id: 15 */
                //assert (func_46_rv == &l_41 || func_46_rv == &l_90 || func_46_rv == &l_117);
            }
        }
        for (p_48 = 0; (p_48 == (-21)); p_48 = safe_sub_func_uint16_t_u_u(p_48, 1))
        { /* block id: 20 */
            const int32_t *l_79 = (void*)0;
            const int32_t **l_78 = &l_79;
            int32_t l_80 = (-1);
        }
        if (l_73)
            goto lbl_81;
    }
    else
    { /* block id: 31 */
        int32_t **l_83 = &l_82[3];
        (*l_83) = l_82[3];
    }
    return p_47;
    /* statement id: 34 */
    //assert (func_46_rv == &l_41 || func_46_rv == &l_90 || func_46_rv == &l_117);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 28
XXX total union variables: 0

XXX max expression depth: 25
breakdown:
   depth: 1, occurrence: 55
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 9, occurrence: 1
   depth: 14, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 1

XXX total number of pointers: 43

XXX times a variable address is taken: 67
XXX times a pointer is dereferenced on RHS: 26
breakdown:
   depth: 1, occurrence: 23
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 13
breakdown:
   depth: 1, occurrence: 12
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 4
XXX times a pointer is qualified to be dereferenced: 52

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 60
   level: 2, occurrence: 6
   level: 3, occurrence: 4
XXX number of pointers point to pointers: 13
XXX number of pointers point to scalars: 30
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.2
XXX average alias set size: 1.37

XXX times a non-volatile is read: 193
XXX times a non-volatile is write: 51
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 58
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 14
   depth: 2, occurrence: 10
   depth: 3, occurrence: 4

XXX percentage a fresh-made variable is used: 11.7
XXX percentage an existing variable is used: 88.3
********************* end of statistics **********************/

