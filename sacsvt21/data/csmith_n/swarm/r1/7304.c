/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --no-unions --volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1617163312
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   signed f0 : 6;
   signed f1 : 3;
   signed f2 : 25;
   int32_t  f3;
   signed f4 : 18;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_30(void);
inline static float  func_33(int8_t  p_34, uint16_t  p_35, uint16_t  p_36, int32_t  p_37, int32_t  p_38);
static int32_t  func_41(float  p_42);
inline static uint16_t  func_65(int8_t  p_66);
inline static struct S0  func_68(uint32_t  p_69);
static int32_t  func_71(int16_t  p_72, struct S0  p_73, int32_t  p_74, int32_t  p_75, float  p_76);
inline static struct S0  func_78(uint32_t  p_79, int32_t  p_80);
inline static uint32_t  func_81(int32_t  p_82);
inline static float  func_88(int8_t  p_89);
static struct S0  func_90(uint16_t  p_91);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_30(void)
{ /* block id: 36 */
    float l_31 = 0x0.2p-1;
    int32_t l_32 = 0x0D68F985;
    int32_t l_59 = 0x3EA3A722;
    int32_t l_405 = (-1);
    struct S0 l_503 = {4,1,-5710,0xA50664DF,-214};
    struct S0 l_512 = {4,-0,-1226,0xBFF92EC1,439};
    int16_t l_536 = 0x2B23;
    int32_t l_607 = 0x27E46042;
    int8_t l_612 = 0;
    if (l_32)
    { /* block id: 37 */
        int16_t l_60 = 9;
        uint32_t l_67 = 0U;
        int32_t l_406 = (-1);
        l_32 = func_33((((int16_t)(-2) << (int16_t)(func_41((((((uint16_t)(((int16_t)(((int16_t)l_32 >> (int16_t)((int16_t)(l_406 = (l_405 = ((int32_t)((uint32_t)(((uint32_t)((int16_t)(l_59 = (0x35A7AB5B | 0xC295A527)) - (int16_t)((l_60 & (((uint32_t)((uint16_t)func_65((l_67 = l_32)) >> (uint16_t)l_60) % (uint32_t)l_60) != l_60)) == l_60)) % (uint32_t)0x55DD7CDD) , l_60) % (uint32_t)l_60) - (int32_t)l_32))) >> (int16_t)l_32)) & l_32) - (int16_t)l_60) && l_32) >> (uint16_t)9) > l_32) , 0x9.Cp+1) <= 0x7.A156F8p-46)) != l_32)) , l_60), l_32, l_60, l_32, l_32);
        l_503 = (l_405 , l_503);
    }
    else
    { /* block id: 268 */
        int32_t l_505 = 0xAB08D283;
        struct S0 l_506 = {-7,1,1567,2,102};
        uint16_t l_509 = 0x5061;
        l_32 = (!l_505);
        l_506 = l_506;
        l_512 = (l_506 = func_78(l_506.f0, (__builtin_ffsl((((int32_t)(l_506.f4 = (l_506.f2 <= ((__builtin_popcount((l_59 = (l_505 && l_503.f4))) < (l_506.f2 != l_509)) , (l_506.f4 >= (((((((((l_503.f2 = ((int16_t)l_509 + (int16_t)0x2EEC)) && 0) == 1) == l_506.f1) ^ 1U) , l_503.f2) , 0xB02F) != l_506.f1) , l_509))))) / (int32_t)l_505) , l_506.f0)) , l_506.f3)));
    }
    for (l_32 = (-6); (l_32 == (-23)); l_32 -= 1)
    { /* block id: 279 */
        uint16_t l_517 = 0x52EB;
        int32_t l_524 = 0xF1668737;
        uint16_t l_525 = 0xA0E8;
        uint16_t l_526 = 65535U;
        l_524 = ((l_517 && (((int32_t)0x6F845BFB + (int32_t)5) <= l_512.f4)) | (func_41((((((l_503.f0 || ((int16_t)((int32_t)l_503.f1 % (int32_t)5) + (int16_t)(l_503.f2 ^ l_517))) ^ 0x3288) , l_517) || 5U) , 0xB.3322F8p+2)) == 0x8C586C54));
        l_526 = l_525;
        if (l_524)
            continue;
        if (l_525)
            break;
    }
    if ((l_512.f1 = l_512.f4))
    { /* block id: 286 */
        uint16_t l_527 = 0x3C01;
        int32_t l_528 = (-7);
        int32_t l_537 = 0x9E2B7C94;
        l_528 = __builtin_bswap32(l_527);
        l_503.f1 = ((l_537 = (l_512.f0 = (((((((int32_t)((8 | l_503.f4) & ((int16_t)((0x4100DE2B & ((uint16_t)(l_527 > 1) + (uint16_t)65528U)) && 0xA82C) >> (int16_t)2)) - (int32_t)(l_528 = ((l_405 = (func_71((l_32 = (l_503.f2 , (+1U))), l_503, l_527, l_528, l_536) && l_528)) != l_503.f3))) , l_503) , l_512) , 0x0C30) >= 0xDB68) , l_528))) < 0x4.Dp+1);
    }
    else
    { /* block id: 294 */
        float l_540 = 0x8.7DB0D4p+92;
        int32_t l_541 = 0xDF4B1FA8;
        int32_t l_542 = 0xDB96DCF8;
        int32_t l_556 = 0;
        uint32_t l_563 = 0xA254722D;
        int32_t l_564 = (-10);
        int32_t l_565 = 0x7D5A098B;
        struct S0 l_586 = {-0,1,-2081,0x5EBE24CA,403};
        uint16_t l_608 = 4U;
        struct S0 l_610 = {-0,-0,-2490,3,425};
        uint32_t l_611 = 0xEF2367A9;
        l_542 = ((l_541 = ((uint32_t)0U + (uint32_t)l_32)) & l_542);
        l_512.f4 = ((float)(((l_541 ^ (((((uint16_t)(l_512.f3 && ((uint16_t)(((l_59 = (((int16_t)((int16_t)0xA440 - (int16_t)l_512.f4) * (int16_t)((-(uint32_t)(((uint16_t)((l_503.f0 = l_541) && l_512.f2) << (uint16_t)l_536) , (((((((l_556 = l_512.f2) | (((int32_t)((int32_t)(l_542 = ((uint16_t)l_503.f0 + (uint16_t)l_563)) % (int32_t)0xF8AA51B1) % (int32_t)0x8C35CB5F) == 0xA5D783F6)) && l_512.f4) | 1) & l_541) , 0x3585) > l_32))) < l_563)) ^ l_512.f0)) , 1U) | l_512.f2) << (uint16_t)l_564)) - (uint16_t)0U) || 0x9E58FB84) > l_564) <= l_565)) & l_503.f1) , l_32) + (float)l_503.f2);
        for (l_536 = 0; (l_536 <= 1); l_536++)
        { /* block id: 304 */
            float l_568 = 0x7.D8770Ap-99;
            int32_t l_569 = 0x9E2C309A;
            int32_t l_572 = 0xD644DE8B;
            uint16_t l_593 = 0xFC65;
            int32_t l_601 = 0x249AC53F;
            struct S0 l_609 = {2,-1,4629,1,-42};
            if (l_556)
                break;
            if (((l_569 = l_569) != (l_542 = (l_556 || (((((int32_t)(l_572 < ((((int16_t)l_512.f1 % (int16_t)(l_563 , ((((int16_t)((int32_t)__builtin_ctzl(l_542) % (int32_t)l_503.f2) / (int16_t)((uint16_t)l_565 >> (uint16_t)l_512.f1)) > 1U) ^ 0x5675))) & l_572) || l_572)) / (int32_t)l_564) || l_512.f1) <= l_541) && 0xA606B940)))))
            { /* block id: 308 */
                int32_t l_581 = 1;
                int16_t l_594 = 0;
                float l_595 = 0x4.506CDFp-80;
                int32_t l_596 = 0x7F6B2CCB;
                int32_t l_597 = 0x1A741899;
                if (l_572)
                    break;
                if (l_536)
                    break;
                l_597 = (0x3.06B286p-30 != func_33(l_569, ((l_581 == (((int16_t)((l_594 = ((uint32_t)func_71(__builtin_clzll(l_572), l_586, (l_581 ^ (l_503.f1 <= ((uint16_t)((uint16_t)__builtin_parity(((((float)l_593 + (float)l_563) <= l_512.f4) , 0x52DF604E)) >> (uint16_t)3) + (uint16_t)l_581))), l_581, l_581) / (uint32_t)l_581)) >= l_586.f3) % (int16_t)l_541) , l_541)) > 1U), l_569, l_596, l_569));
            }
            else
            { /* block id: 313 */
                int32_t l_602 = 0;
                l_586.f1 = ((((uint16_t)(l_572 < l_563) << (uint16_t)(l_572 != (l_569 != (~((__builtin_ctzl((l_601 = l_541)) & l_602) || l_565))))) == ((uint32_t)((uint32_t)((((l_541 || l_602) ^ 0xE4598BBE) > l_607) >= l_512.f1) - (uint32_t)0) / (uint32_t)l_503.f0)) , l_569);
                return l_608;
            }
            l_610 = (l_586 = (l_609 , (l_512 = l_586)));
        }
        l_586.f2 = ((l_611 = l_503.f3) | (((((l_503.f3 != l_512.f4) >= (-0x3.Ap+1)) <= l_556) , (l_612 >= ((-(uint16_t)l_586.f0) & ((int16_t)((l_542 = ((((l_586.f4 = 0x02A9CEC2) && (l_503.f4 <= (-5))) > (-3)) >= l_610.f1)) && l_503.f2) >> (int16_t)5)))) | l_610.f1));
    }
    return l_32;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_33(int8_t  p_34, uint16_t  p_35, uint16_t  p_36, int32_t  p_37, int32_t  p_38)
{ /* block id: 232 */
    uint16_t l_431 = 0x2836;
    uint32_t l_439 = 0U;
    int32_t l_440 = (-9);
    int32_t l_447 = 0x3BFC38B6;
    int32_t l_474 = 0;
    int32_t l_502 = 0;
    l_447 = ((float)l_431 + (float)(((func_81((p_37 = (-1))) >= (((l_440 = (((int16_t)p_34 >> (int16_t)11) && ((uint32_t)(+l_431) % (uint32_t)((uint16_t)((l_439 = 4294967295U) , l_431) << (uint16_t)11)))) , ((uint16_t)((uint16_t)((((uint16_t)(l_431 <= (-1)) + (uint16_t)p_34) | (-1)) || l_439) >> (uint16_t)13) - (uint16_t)2U)) , p_36)) > l_431) >= 0x1.Ep-1));
    if (((((int16_t)(l_440 = (((int32_t)(func_81(p_37) != (__builtin_clz(((((int16_t)l_440 - (int16_t)p_34) >= ((l_440 < ((l_447 = p_37) , (l_440 && ((l_447 = p_36) && p_37)))) , 0)) != 0)) && l_431)) / (int32_t)p_36) | 0x6E3C)) + (int16_t)l_439) , 3U) , p_34))
    { /* block id: 240 */
        uint32_t l_460 = 1U;
        int32_t l_466 = 0xFBFA3C9D;
        int32_t l_467 = (-1);
        l_467 = (p_38 = ((int16_t)(((int16_t)l_447 >> (int16_t)__builtin_clzll(((-7) > (p_35 > (p_37 || (p_37 ^ ((uint16_t)l_439 / (uint16_t)l_460))))))) > (((int16_t)((!((int16_t)(l_466 = l_460) / (int16_t)0x51CD)) & l_460) % (int16_t)l_439) , 0x152F)) - (int16_t)0xEEDA));
        return l_431;
    }
    else
    { /* block id: 245 */
        uint16_t l_468 = 1U;
        int32_t l_469 = 0x82893DC6;
        l_469 = l_468;
        l_447 = l_469;
        l_469 = (-10);
    }
    for (l_439 = 0; (l_439 != 44); l_439 += 1)
    { /* block id: 252 */
        int32_t l_473 = (-6);
        struct S0 l_484 = {-0,0,-3938,0x54D7976D,349};
        uint32_t l_487 = 4294967295U;
        l_484 = func_90(((l_439 != l_439) && (!((l_473 > (l_474 || ((((int32_t)(p_38 = l_431) % (int32_t)p_34) == (l_447 = (!((int16_t)(l_473 != ((int16_t)((p_34 & ((uint16_t)(l_440 || 0xA11782B0) + (uint16_t)0x0F3F)) < l_473) << (int16_t)l_473)) << (int16_t)l_473)))) != p_34))) , p_34))));
        l_484.f1 = ((int16_t)((__builtin_clz(l_487) | ((int32_t)((l_447 = p_38) || (((int16_t)(((uint16_t)((l_484.f2 = (((l_484.f4 = __builtin_ctzll(((((int32_t)((p_36 = __builtin_popcount((((uint32_t)((l_484 , (((p_37 = (l_484.f0 & ((((((0x7A69A349 > (p_37 == (((((uint32_t)4U + (uint32_t)(((l_447 = __builtin_ffs((p_38 = ((((int32_t)(__builtin_parity(l_474) || p_34) + (int32_t)0x90DDF73C) == (-1)) | p_37)))) ^ l_484.f1) != p_35)) < l_484.f1) >= 0x1A88BAE4) == (-1)))) == l_484.f2) <= l_431) , 0xDF7C3A5E) != (-1)) , p_38))) == l_484.f2) == p_36)) < p_36) % (uint32_t)l_473) , p_34))) && l_484.f4) / (int32_t)l_484.f1) == p_35) != p_34))) ^ l_439) , l_484.f3)) == 0x4BF4) + (uint16_t)l_440) < 0x5042) + (int16_t)p_34) != l_484.f0)) % (int32_t)l_502)) == l_484.f3) << (int16_t)1);
    }
    return p_38;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_41(float  p_42)
{ /* block id: 222 */
    int32_t l_407 = 0x3813D3AF;
    int32_t l_412 = 0;
    int32_t l_425 = 0xEF8D422A;
    struct S0 l_427 = {1,0,-4980,0x13E96B69,415};
    struct S0 l_428 = {4,-0,1744,0,-295};
    l_425 = ((l_407 >= 0xE844) , ((uint16_t)((((float)__builtin_ffsl((((l_407 = l_412) & ((uint32_t)2U % (uint32_t)((uint16_t)(((l_412 != ((uint32_t)((uint16_t)((int32_t)((l_412 & l_412) , ((uint16_t)((l_412 , l_412) , l_412) >> (uint16_t)1)) + (int32_t)l_412) >> (uint16_t)l_412) - (uint32_t)l_412)) & l_412) < l_412) << (uint16_t)15))) , l_412)) / (float)0x3.03A89Fp+19) , l_407) && l_412) + (uint16_t)l_412));
    l_427.f4 = (l_425 = ((l_412 > l_412) , func_71(l_425, (((l_407 = __builtin_clzll(l_407)) || (((((+(((((l_407 = l_412) < ((((__builtin_clz(func_81(l_412)) , l_412) == 0x8.D65FC6p-35) >= l_412) , 0x238100C5)) < 1U) ^ l_425) , 0xBEE4)) < 0U) <= l_412) , l_425) | 0xDAFE4327)) , l_427), l_427.f4, l_427.f2, l_427.f4)));
    l_428 = (l_427 = (l_427.f0 , l_427));
    return l_407;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_65(int8_t  p_66)
{ /* block id: 40 */
    uint32_t l_70 = 4294967287U;
    struct S0 l_396 = {-3,1,-1617,0x358C7D61,-256};
    l_396 = func_68(l_70);
    for (l_70 = (-22); (l_70 >= 7); ++l_70)
    { /* block id: 210 */
        struct S0 l_401 = {-3,1,470,-2,282};
        uint32_t l_404 = 5U;
        for (p_66 = 7; (p_66 != 7); p_66 += 4)
        { /* block id: 213 */
            l_396.f0 = l_396.f4;
        }
        l_401 = l_401;
        l_404 = ((float)0x1.3p+1 - (float)0xD.9AC1A0p-9);
    }
    return p_66;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_68(uint32_t  p_69)
{ /* block id: 41 */
    float l_85 = 0x0.4p-1;
    int32_t l_86 = 1;
    float l_87 = 0x4.8BF514p-7;
    int32_t l_117 = 0x1B0F83D5;
    struct S0 l_118 = {-4,1,-2744,0,-326};
    l_86 = func_71((+1), (l_118 = func_78(((func_81((((((float)(((l_87 = (l_85 != __builtin_ctz(l_86))) != (((l_86 <= func_88(p_69)) == (l_117 = ((float)0x0.Dp-1 / (float)(p_69 , p_69)))) < p_69)) > 0x0.Cp+1) + (float)0xA.A68EB2p-84) , p_69) , l_118) , p_69)) != 0U) == p_69), l_86)), l_86, p_69, l_86);
    return l_118;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_71(int16_t  p_72, struct S0  p_73, int32_t  p_74, int32_t  p_75, float  p_76)
{ /* block id: 66 */
    uint32_t l_144 = 2U;
    int32_t l_148 = 4;
    int32_t l_149 = 0x70AEDAF9;
    uint32_t l_163 = 0xB0CC679C;
    uint32_t l_233 = 0x252E7EA9;
    float l_235 = 0x1.Fp-1;
    int8_t l_245 = 0x16;
    int32_t l_270 = 4;
    uint32_t l_272 = 0x9C1BF1E5;
    float l_344 = 0x6.D72287p-70;
    uint32_t l_385 = 0x6AC0404C;
    uint32_t l_395 = 0x01F39791;
lbl_171:
    l_149 = ((int32_t)((uint32_t)(p_73.f4 < (l_148 = ((int16_t)(((l_144 > ((-1) <= (func_81(l_144) < ((((((p_73.f4 || l_144) , ((!((-1) != 1)) & p_74)) != p_74) , l_144) == p_73.f0) == 0)))) , p_73.f0) , l_144) / (int16_t)8U))) + (uint32_t)l_144) + (int32_t)l_144);
    for (l_149 = 0; (l_149 == 12); l_149 += 1)
    { /* block id: 71 */
        uint32_t l_156 = 4294967295U;
        int32_t l_162 = 1;
        uint32_t l_176 = 0xDDDDEF21;
        int8_t l_185 = 0xC0;
        float l_240 = 0xE.373B64p+74;
        float l_271 = 0x7.D79F78p-20;
        int8_t l_285 = (-1);
        int32_t l_346 = 0xBCCF346C;
        int32_t l_348 = 0x35A89635;
        for (p_74 = 0; (p_74 < (-29)); p_74 -= 5)
        { /* block id: 74 */
            float l_157 = 0xA.DC2C33p-87;
            struct S0 l_170 = {7,-1,1101,0xB60DBC48,-290};
            p_73.f4 = ((p_73.f1 >= (((l_162 = ((int32_t)((l_148 = l_156) || (l_148 = ((func_81(l_156) , (p_72 = p_74)) >= p_74))) / (int32_t)(((uint32_t)l_149 / (uint32_t)l_156) || ((uint16_t)func_81((p_73.f0 = (0U < l_144))) - (uint16_t)p_73.f1)))) && p_72) >= l_149)) & l_163);
            if ((p_73.f2 = (+((int16_t)(!l_144) % (int16_t)(p_72 = ((uint16_t)p_73.f0 << (uint16_t)1))))))
            { /* block id: 83 */
                l_170 = func_78(p_73.f4, l_162);
                if (l_144)
                    goto lbl_171;
                if (l_144)
                    goto lbl_171;
                if ((((uint32_t)(((uint32_t)((l_176 > p_73.f2) | ((uint32_t)func_81(l_162) % (uint32_t)((int16_t)l_149 >> (int16_t)((p_73.f1 & (((float)0x3.6p+1 / (float)l_144) , ((uint16_t)p_72 / (uint16_t)l_170.f4))) >= 1)))) - (uint32_t)l_144) > 0x7512) - (uint32_t)l_144) == l_185))
                { /* block id: 87 */
                    p_73 = func_78(l_144, p_74);
                }
                else
                { /* block id: 89 */
                    p_73.f2 = func_81(__builtin_bswap64(l_185));
                    return p_73.f2;
                }
            }
            else
            { /* block id: 93 */
                int16_t l_186 = 0x489E;
                return l_186;
            }
            l_148 = (__builtin_ctzl(p_75) <= ((float)0x7.0p-1 / (float)p_73.f4));
            if ((p_73 , (((uint32_t)l_149 % (uint32_t)(l_170.f4 = 0x50E2895D)) , (p_73.f4 >= 0))))
            { /* block id: 98 */
                if (p_73.f4)
                    break;
            }
            else
            { /* block id: 100 */
                float l_197 = (-0x1.9p+1);
                int16_t l_200 = 1;
                int32_t l_208 = 0x67FFFD43;
                l_208 = ((uint32_t)((0xA9CE858C | ((uint16_t)((p_74 , (((int32_t)(l_162 != (l_170.f0 = ((int16_t)(l_200 = p_73.f0) / (int16_t)l_156))) % (int32_t)p_73.f3) , (((int32_t)((int16_t)(-(int16_t)(((((float)(l_185 , ((func_81(l_170.f1) , p_73.f0) == 0x4.65B968p+14)) - (float)p_73.f4) , p_72) != l_149) && l_170.f3)) - (int16_t)p_75) / (int32_t)4294967293U) , p_73.f3))) , 0x888C) << (uint16_t)2)) && 0xB944) - (uint32_t)(-1));
                p_73 = p_73;
                l_148 = ((float)(p_76 = (l_200 >= (func_81(((p_75 >= 0xD9258287) <= p_73.f1)) < (((__builtin_bswap32(((p_72 = p_73.f3) || ((int16_t)l_170.f3 << (int16_t)13))) == l_162) == l_156) > 0x1.A60D7Dp-50)))) - (float)l_170.f1);
            }
        }
        for (p_74 = (-23); (p_74 > (-13)); p_74 += 6)
        { /* block id: 112 */
            int8_t l_228 = 0x68;
            int32_t l_234 = (-9);
            p_73.f2 = ((int16_t)(p_72 = (-3)) >> (int16_t)((p_73.f4 | (p_75 == (((uint16_t)((uint32_t)l_148 - (uint32_t)(p_73.f1 = (0xEFDF ^ l_162))) / (uint16_t)p_73.f3) <= func_81(l_185)))) > 4294967295U));
            for (l_176 = (-15); (l_176 > 31); l_176++)
            { /* block id: 118 */
                uint32_t l_223 = 4294967295U;
                l_223 = 0x6.0p-1;
                l_228 = ((float)(func_81(l_149) , l_149) + (float)(l_163 == ((float)(p_72 , (-0x1.5p+1)) / (float)p_73.f3)));
                l_148 = l_185;
            }
            l_148 = func_81(((int32_t)((uint16_t)((p_73.f0 ^ l_233) || ((l_228 == (l_234 = (__builtin_parityll(l_163) != p_75))) <= l_148)) >> (uint16_t)(p_73.f4 == l_233)) % (int32_t)0xF1B4AE9B));
            if (l_176)
                continue;
        }
        if ((func_81((l_144 , (p_73.f2 || (0U >= ((int16_t)((l_162 = 0x0.Fp-1) , ((p_75 < (p_73.f2 = (((uint16_t)((l_156 < p_74) >= ((int16_t)((l_148 = p_73.f2) > ((((uint32_t)l_233 % (uint32_t)l_245) , (-10)) , p_73.f4)) << (int16_t)p_75)) + (uint16_t)l_156) , p_73.f3))) || l_144)) >> (int16_t)p_73.f1))))) != p_73.f1))
        { /* block id: 130 */
            struct S0 l_248 = {5,0,861,3,308};
            for (l_163 = (-24); (l_163 != (-3)); l_163 += 7)
            { /* block id: 133 */
                float l_255 = (-0x7.Cp-1);
                l_248 = l_248;
                p_73 = func_78(((uint32_t)l_148 / (uint32_t)(((0x040BD136 ^ 0U) , l_144) && ((int32_t)(!p_73.f3) + (int32_t)(!0x4678)))), l_156);
            }
            l_272 = ((float)(__builtin_parityl((((p_74 > ((uint32_t)l_248.f2 / (uint32_t)p_75)) & (__builtin_ffsll((l_248.f0 = ((int16_t)(l_270 = (l_162 = (((((int32_t)l_144 % (int32_t)(((uint16_t)(0x9AE6 & (0x838F != ((uint16_t)((int16_t)p_73.f1 >> (int16_t)(l_248.f4 = p_73.f3)) + (uint16_t)(l_148 = __builtin_clzll(((p_73.f0 & 0xD995) & l_245)))))) >> (uint16_t)4) && 1)) ^ p_73.f1) > p_73.f4) >= l_233))) % (int16_t)p_73.f2))) | p_73.f1)) , 2U)) < p_74) - (float)l_271);
            if (l_148)
                continue;
            for (l_185 = (-12); (l_185 > 16); l_185++)
            { /* block id: 146 */
                int32_t l_281 = 0xE0C10409;
                int32_t l_286 = 0x30D1F882;
                int32_t l_379 = 1;
                if (((int32_t)((l_162 = p_74) == 7) % (int32_t)__builtin_popcountl(((int16_t)__builtin_popcount(p_73.f1) << (int16_t)l_176))))
                { /* block id: 148 */
                    int32_t l_282 = 0x0310DE8F;
                    int32_t l_287 = 7;
                    int8_t l_292 = (-1);
                    uint16_t l_314 = 0xB6AD;
                    if (((int16_t)((((func_81(p_75) || l_281) <= 0x0F2F) , (((l_248.f4 = ((l_282 <= (p_73.f4 == ((uint16_t)(l_156 , p_73.f2) << (uint16_t)(((0x883F != p_73.f2) | 0x9CEF) & l_285)))) >= l_285)) > 65527U) == l_248.f2)) , l_162) << (int16_t)l_286))
                    { /* block id: 150 */
                        return p_72;
                    }
                    else
                    { /* block id: 152 */
                        uint32_t l_311 = 0U;
                        int32_t l_312 = 0xEF0FF016;
                        int32_t l_313 = (-1);
                        struct S0 l_315 = {-5,1,-2818,0xE3854A16,-378};
                        p_73 = ((l_287 && (__builtin_parityl((l_281 = 4294967288U)) ^ 0xCF49A6DF)) , func_78((((int16_t)p_72 + (int16_t)(l_162 = ((uint16_t)p_73.f3 << (uint16_t)7))) && (l_233 & l_292)), p_73.f4));
                        l_315 = func_78(((((((0U && l_270) || (__builtin_ctzll(((uint16_t)p_72 - (uint16_t)func_81(((-(float)((float)((float)((0x42EEB042 >= 0xB5F938C1) , (((((float)((float)((l_313 = (l_162 = ((((float)(((l_282 = (l_281 = l_248.f0)) , ((p_73.f0 >= ((float)(((l_312 = (-(int32_t)((((uint32_t)(p_73.f0 == l_311) + (uint32_t)0x993A821A) != p_73.f0) < l_248.f2))) , 0x8.2DE909p+35) != p_73.f1) - (float)0xF.794D5Bp+29)) < l_281)) == p_73.f4) / (float)p_73.f4) < p_75) >= (-0x1.Bp+1)))) != p_73.f3) + (float)(-0x1.8p+1)) / (float)0x0.1p-1) <= p_75) < p_76) <= l_248.f2)) - (float)l_292) - (float)p_73.f0)) , p_75)))) <= p_73.f4)) && l_287) <= l_314) <= p_72) || p_73.f1), p_73.f1);
                        p_73.f2 = 0x577DD6AF;
                    }
                }
                else
                { /* block id: 164 */
                    float l_347 = 0x1.8p-1;
                    int32_t l_359 = 7;
                    for (p_75 = (-7); (p_75 >= (-21)); p_75 -= 9)
                    { /* block id: 167 */
                        int8_t l_343 = 0x2E;
                        int32_t l_345 = 0xB490537F;
                        p_73 = func_78(((int16_t)p_73.f4 + (int16_t)(l_248.f0 = (((uint32_t)((int32_t)l_163 / (int32_t)l_156) % (uint32_t)(-1)) > 2))), (~((uint16_t)(((((((uint16_t)p_75 / (uint16_t)(l_162 , ((uint32_t)0xCF908FA4 % (uint32_t)(__builtin_bswap64(p_73.f3) ^ p_75)))) & l_248.f3) == p_73.f3) | 0x778E1521) | p_73.f2) <= l_176) - (uint16_t)l_285)));
                        l_348 = ((float)p_76 / (float)((l_162 = 0xE.FF1976p-12) < ((float)(-0x2.Bp+1) / (float)((float)(l_347 = (((p_72 >= p_73.f3) <= (l_346 = (0xC.F951E7p+84 <= (__builtin_ffsl((((int32_t)((uint16_t)0x48C0 >> (uint16_t)9) + (int32_t)0x54550EC8) || ((((l_148 = ((uint16_t)(l_343 = p_73.f0) >> (uint16_t)p_73.f0)) , p_75) < l_345) & p_73.f2))) , 0xE.3CCBC9p+73)))) != p_76)) - (float)0xF.06E9F9p+3))));
                        p_73 = p_73;
                        if (l_345)
                            break;
                    }
                    p_73.f2 = ((int32_t)((uint32_t)0U - (uint32_t)(__builtin_popcountll((((l_281 = l_286) & __builtin_parity((l_286 , ((int16_t)((uint32_t)(__builtin_popcountll(p_75) | (l_248.f3 || ((int32_t)l_359 + (int32_t)0xAC32E7B3))) + (uint32_t)p_75) + (int16_t)l_359)))) | 6U)) , p_73.f1)) / (int32_t)0xB7A41384);
                    for (l_272 = 0; (l_272 < 12); ++l_272)
                    { /* block id: 183 */
                        int32_t l_377 = 0x8794BD40;
                        uint16_t l_378 = 65535U;
                        l_379 = ((l_281 = (func_81((p_73.f2 = (l_248.f4 & ((p_73.f4 = l_144) & l_359)))) | 1U)) | (p_72 = ((((int32_t)((uint16_t)((int16_t)((int16_t)(!((l_149 || (0 & func_81((p_73.f0 = ((int32_t)(((int16_t)(((((uint16_t)l_176 / (uint16_t)(l_248 , 0x9392)) & l_377) ^ p_73.f1) >= 1U) >> (int16_t)l_377) != l_248.f1) / (int32_t)(-9)))))) > l_378)) >> (int16_t)9) << (int16_t)8) / (uint16_t)p_74) / (int32_t)p_72) , l_162) && 65531U)));
                    }
                }
                p_73.f2 = (4 < ((+(l_148 = p_73.f3)) >= ((int32_t)(p_73.f0 = ((int16_t)(l_281 = (l_248.f1 = (p_75 != l_248.f3))) >> (int16_t)6)) + (int32_t)__builtin_clzl(((l_385 = (2 & (l_272 > p_73.f2))) == p_74)))));
            }
        }
        else
        { /* block id: 199 */
            int16_t l_392 = 2;
            p_76 = ((float)p_73.f4 / (float)(l_285 < (((float)((float)p_75 - (float)p_73.f4) - (float)((__builtin_popcountll(((p_73.f3 = l_149) , l_392)) < ((float)((l_395 > ((((p_73.f4 != 0x3.5E760Dp-94) == 0xF.4755E3p-29) != l_392) >= l_270)) == l_392) / (float)l_348)) == (-0x1.Cp+1))) >= l_272)));
        }
    }
    return l_163;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_78(uint32_t  p_79, int32_t  p_80)
{ /* block id: 62 */
    struct S0 l_135 = {-7,-1,-4580,-10,433};
    l_135 = l_135;
    return l_135;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_81(int32_t  p_82)
{ /* block id: 58 */
    struct S0 l_119 = {-1,-0,3156,0x94FDEA94,33};
    int8_t l_134 = 0;
    l_119 = func_90((l_119 , (__builtin_ctz((((((int32_t)((int16_t)(p_82 == 0xE16D896C) >> (int16_t)2) + (int32_t)((uint16_t)((l_119.f4 = p_82) , p_82) % (uint16_t)((int32_t)((uint16_t)((uint16_t)((uint32_t)1U + (uint32_t)(l_119.f3 < (p_82 | ((l_119.f3 , p_82) == p_82)))) % (uint16_t)l_119.f0) / (uint16_t)l_119.f1) / (int32_t)l_134))) & 0x7FF4) || p_82) <= (-7))) ^ p_82)));
    return p_82;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_88(int8_t  p_89)
{ /* block id: 43 */
    int16_t l_94 = 0x403A;
    int32_t l_101 = 4;
    int32_t l_103 = 1;
    int32_t l_104 = 2;
    int32_t l_107 = (-1);
    uint32_t l_108 = 0x53F47794;
    int32_t l_109 = 0x1C1BBB80;
    struct S0 l_113 = {4,0,794,9,-457};
    int32_t l_114 = (-9);
    l_113 = func_90((l_109 = ((int16_t)l_94 << (int16_t)(((((((uint32_t)((int16_t)(l_94 == 0x5E57) - (int16_t)l_94) + (uint32_t)(l_108 = ((uint32_t)(l_104 = (l_103 = ((l_101 = p_89) && (p_89 | __builtin_bswap64((+0x0C99D02B)))))) / (uint32_t)(l_107 = ((int16_t)(p_89 | p_89) >> (int16_t)l_94))))) || p_89) == p_89) , l_103) || p_89) || 1U))));
    return l_114;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_90(uint16_t  p_91)
{ /* block id: 50 */
    uint32_t l_110 = 0x6016E5DC;
    int32_t l_111 = (-6);
    struct S0 l_112 = {4,-0,-1291,0x64CC4390,-410};
    l_111 = (l_110 , 0xF.7F440Ap-83);
    l_112 = l_112;
    l_112 = l_112;
    return l_112;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 129
   depth: 1, occurrence: 19
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 4
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 19
breakdown:
   indirect level: 0, occurrence: 19
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 27
XXX times a bitfields struct on RHS: 25
XXX times a single bitfield on LHS: 37
XXX times a single bitfield on RHS: 122

XXX max expression depth: 53
breakdown:
   depth: 1, occurrence: 107
   depth: 2, occurrence: 19
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 3
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 1
   depth: 22, occurrence: 3
   depth: 23, occurrence: 2
   depth: 24, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 4
   depth: 29, occurrence: 2
   depth: 34, occurrence: 1
   depth: 35, occurrence: 1
   depth: 43, occurrence: 1
   depth: 53, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 593
XXX times a non-volatile is write: 187
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 112
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 28
   depth: 2, occurrence: 17
   depth: 3, occurrence: 21
   depth: 4, occurrence: 7
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 19.2
XXX percentage an existing variable is used: 80.8
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

