/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --no-muls --no-safe-math --packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      1538850728
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int32_t  f0;
   uint32_t  f1;
   int32_t  f2;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */
static int16_t g_19 = 0x281D;
static int32_t g_29 = 1;
static int32_t g_70 = 0xD95921BA;
static int32_t g_75 = 0;
static int32_t g_90 = (-1);
static uint16_t g_104 = 65528U;
static int32_t *g_106 = &g_70;
static int32_t **g_105 = &g_106;
static volatile int32_t *** const *g_115 = (void*)0;
static volatile int32_t *** const **g_114 = &g_115;
static volatile struct S0 g_142 = {0xE93F460C,4294967294U,0x22C85E55};/* VOLATILE GLOBAL g_142 */
static int32_t ** const *g_156 = &g_105;
static int32_t ** const **g_155 = &g_156;
static int32_t ** const ***g_154 = &g_155;
static float g_161 = (-0x1.1p-1);
static const int32_t g_171 = 0;
static volatile int32_t g_204 = 0;/* VOLATILE GLOBAL g_204 */
static volatile int32_t g_205 = 0xEEABB79E;/* VOLATILE GLOBAL g_205 */
static volatile int32_t g_206 = 0x8EBA309C;/* VOLATILE GLOBAL g_206 */
static volatile int32_t g_207 = 0x1BAA6E91;/* VOLATILE GLOBAL g_207 */
static int32_t g_208 = 0x6F7C90A9;
static uint32_t g_223 = 0x5008D736;
static struct S0 g_254 = {0,0x28F33289,0x5802A5F0};
static struct S0 *g_253 = &g_254;
static struct S0 **g_252 = &g_253;
static int16_t g_255 = 0x432E;
static volatile int16_t g_293 = 5;/* VOLATILE GLOBAL g_293 */
static float *g_317 = &g_161;
static float * const *g_316 = &g_317;
static int16_t g_343 = 7;
static float g_395 = 0xB.EBF453p-32;
static const uint32_t *g_402 = &g_254.f1;
static const uint32_t **g_401 = &g_402;
static const volatile float g_432 = 0x0.Dp+1;/* VOLATILE GLOBAL g_432 */
static float g_434 = 0x1.7p-1;
static int16_t g_435 = 0x61E6;
static int32_t * const *g_444 = &g_106;
static int32_t * const **g_443 = &g_444;
static uint8_t g_462 = 0x53;
static float g_522 = 0xD.5EC7FBp-96;
static volatile float **g_578 = (void*)0;
static struct S0 *** const g_638 = &g_252;
static struct S0 *** const *g_637 = &g_638;
static struct S0 *** const **g_636 = &g_637;
static volatile int32_t g_673 = 4;/* VOLATILE GLOBAL g_673 */
static struct S0 ***g_678 = &g_252;
static struct S0 ****g_677 = &g_678;
static uint8_t g_694 = 1U;
static volatile int16_t *g_734 = &g_293;
static volatile int16_t **g_733 = &g_734;
static volatile int16_t ***g_732 = &g_733;
static float g_759 = 0x1.98344Dp-77;
static uint16_t g_761 = 0U;
static uint16_t g_765 = 65528U;
static volatile int16_t ****g_767 = (void*)0;
static float ***g_797 = (void*)0;
static const uint32_t g_840 = 0x2A643731;
static int32_t **g_849 = (void*)0;
static int32_t ***g_848 = &g_849;
static const struct S0 *g_918 = &g_254;
static const struct S0 **g_917 = &g_918;
static const struct S0 ***g_916 = &g_917;
static const struct S0 ****g_915 = &g_916;
static int32_t ****g_934 = &g_848;
static uint16_t g_1010 = 5U;
static uint32_t g_1048 = 4294967295U;
static struct S0 g_1089 = {0x68CC162F,0x8E3E2FDC,-1};
static float g_1108 = 0x4.74146Ep-38;


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_27(void);
static int32_t ** func_30(uint32_t  p_31, int32_t * p_32, int32_t ** p_33);
static int32_t * func_42(int32_t  p_43, int32_t *** p_44);
static int16_t  func_46(uint16_t  p_47, uint16_t  p_48, uint32_t  p_49, struct S0  p_50);
inline static uint16_t  func_51(int32_t ** p_52);
static uint32_t  func_61(uint32_t  p_62, int32_t * const ** p_63, uint16_t  p_64);
static int32_t * func_65(int32_t * const ** const  p_66);
inline static int32_t * const  func_78(struct S0  p_79, float  p_80, int32_t * p_81, float  p_82, int32_t *** p_83);
inline static struct S0  func_84(uint32_t  p_85);
static int32_t * func_88(int32_t ** p_89);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_29 g_19 g_75
 * writes: g_29 g_19 g_75
 */
static int32_t  func_27(void)
{ /* block id: 36 */
    int32_t *l_28 = &g_29;
    int32_t ***l_34 = (void*)0;
    int32_t **l_36 = &l_28;
    int32_t ***l_35 = &l_36;
    int32_t l_705 = 8;
    struct S0 l_707 = {-1,4294967286U,0x1D85A6FB};
    int16_t *l_1023 = &g_435;
    int32_t l_1029 = 0x605C8820;
    uint32_t *l_1039 = &g_254.f1;
    uint32_t **l_1038 = &l_1039;
    uint32_t *** const l_1037 = &l_1038;
    uint32_t l_1050 = 2U;
    uint16_t *l_1084 = &g_765;
    uint16_t **l_1083 = &l_1084;
    uint16_t ***l_1082 = &l_1083;
    (*l_28) = 0;
    (*l_35) = func_30((*l_28), &g_29, ((*l_35) = &l_28));
    for (g_19 = 0; (g_19 != 0); g_19 += 7)
    { /* block id: 45 */
        uint16_t *l_687 = (void*)0;
        uint16_t *l_688 = &g_104;
        uint8_t *l_693 = &g_694;
        uint8_t **l_695 = &l_693;
        int32_t l_702 = (-10);
        int32_t **l_1003 = (void*)0;
        int32_t **l_1004 = &l_28;
        if (g_29)
            break;
    }
    for (g_75 = 0; (g_75 >= 8); g_75 += 2)
    { /* block id: 678 */
        struct S0 l_1007 = {0x68912333,4294967289U,0xB8C32472};
        struct S0 ***l_1026 = &g_252;
        int32_t l_1051 = (-2);
        int32_t *l_1058 = &g_29;
        int32_t * const **l_1069 = &g_444;
        int32_t * const **l_1102 = &g_444;
        uint8_t l_1105 = 7U;
        uint32_t ***l_1111 = (void*)0;
        uint32_t ****l_1110 = &l_1111;
        uint32_t *****l_1109 = &l_1110;
    }
    return (*l_28);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_30(uint32_t  p_31, int32_t * p_32, int32_t ** p_33)
{ /* block id: 39 */
    int32_t *l_37 = &g_29;
    int32_t **l_38 = &l_37;
    int32_t **l_39 = (void*)0;
    l_37 = &g_29;
    return l_39;
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_732 g_733 g_734 g_293 g_401 g_402 g_254.f1 g_255 g_638 g_252 g_106 g_208 g_849 g_848 g_254.f2 g_142.f2 g_75 g_765 g_915 g_29 g_317 g_161 g_678 g_253 g_462 g_673 g_316 g_761 g_207 g_223 g_677
 * writes: g_765 g_254.f1 g_761 g_253 g_106 g_208 g_104 g_462 g_254.f2 g_75 g_915 g_29 g_934 g_395 g_254
 */
static int32_t * func_42(int32_t  p_43, int32_t *** p_44)
{ /* block id: 547 */
    uint16_t l_851 = 0xEA46;
    int32_t l_852 = 0x21924800;
    int32_t *l_880 = (void*)0;
    struct S0 l_899 = {-2,4294967295U,0xBA2E3686};
    int32_t **l_940 = &g_106;
    int16_t *l_960 = (void*)0;
    int16_t **l_959 = &l_960;
    int16_t ***l_958 = &l_959;
    int32_t *l_1002 = &g_70;
    if (((p_43 , (~l_851)) != (l_852 = l_851)))
    { /* block id: 549 */
        int32_t **l_853 = &g_106;
        uint32_t *l_857 = &g_254.f1;
        uint32_t **l_856 = &l_857;
        int32_t l_863 = 0xEB9246E5;
        uint16_t **l_885 = (void*)0;
        float * const **l_896 = &g_316;
        float * const *** const l_895 = &l_896;
        struct S0 l_897 = {-1,0x66E4FA23,0x1ED8499E};
        uint16_t *l_954 = (void*)0;
        uint16_t *l_955 = &l_851;
        if ((l_851 , ((int32_t)(l_856 != (void*)0) - (int32_t)p_43)))
        { /* block id: 550 */
            uint16_t *l_861 = &g_765;
            uint16_t *l_862 = &l_851;
            int32_t l_864 = 0x6F2FFB10;
            uint16_t *l_877 = &g_761;
            struct S0 *l_881 = &g_254;
            float *l_898 = &g_395;
            int32_t *l_941 = &l_899.f2;
            int32_t *l_942 = &g_29;
            if (((((uint16_t)((((+((*l_862) = ((*l_861) = g_70))) >= ((p_43 | (***g_732)) & (l_863 && (((0xC9908B09 != (l_864 = ((**l_856) = 0U))) , ((int32_t)((int16_t)((uint32_t)(**g_401) % (uint32_t)l_852) >> (int16_t)(((((uint16_t)((*l_877) = ((uint32_t)(((int32_t)l_864 / (int32_t)(*g_402)) | 0U) + (uint32_t)(**g_401))) >> (uint16_t)g_255) > l_864) == 4294967294U) < l_852)) / (int32_t)p_43)) != p_43)))) & g_255) > l_852) / (uint16_t)(-9)) & p_43) && (*g_402)))
            { /* block id: 556 */
                int32_t *l_879 = &l_863;
                if (l_864)
                { /* block id: 557 */
                    int32_t l_878 = (-1);
                    int32_t l_884 = 6;
                    if ((l_878 = l_878))
                    { /* block id: 559 */
                        return l_880;
                    }
                    else
                    { /* block id: 561 */
                        uint8_t l_892 = 0xD0;
                        l_878 = p_43;
                        (**g_638) = l_881;
                        (*l_879) = (((int32_t)(l_884 | ((void*)0 != l_885)) % (int32_t)((uint16_t)((*l_877) = ((int16_t)(*g_734) >> (int16_t)(*l_879))) + (uint16_t)(((*l_862) = p_43) == l_884))) != (((uint16_t)0xEC8A << (uint16_t)l_892) == p_43));
                    }
                }
                else
                { /* block id: 568 */
lbl_900:
                    l_899 = l_897;
                    (*l_853) = l_879;
                    (*g_106) = __builtin_parity((**g_401));
                    if (p_43)
                        goto lbl_900;
                }
                (*l_853) = &l_852;
            }
            else
            { /* block id: 577 */
                int32_t * const **l_912 = &g_444;
                int16_t *l_926 = (void*)0;
                int16_t **l_925 = &l_926;
                int16_t ***l_924 = &l_925;
                uint32_t l_931 = 4294967295U;
                for (g_208 = 0; (g_208 < 24); ++g_208)
                { /* block id: 580 */
                    const uint8_t l_903 = 0x9C;
                    int32_t *l_913 = &g_75;
                    struct S0 ****l_914 = &g_678;
                    const struct S0 *****l_919 = &g_915;
                    (*l_913) = (((*l_861) = ((*g_402) & func_61((l_903 , (((p_43 > (((int16_t)((uint32_t)((*g_734) , (**g_401)) / (uint32_t)((uint32_t)l_903 % (uint32_t)((uint16_t)p_43 >> (uint16_t)15))) >> (int16_t)14) ^ (((*p_44) == (*g_848)) == g_255))) | p_43) < (-1))), l_912, p_43))) >= g_75);
                    (*l_913) = ((g_765 , l_914) != ((*l_919) = g_915));
                }
                for (g_29 = 0; (g_29 != (-1)); --g_29)
                { /* block id: 588 */
                    int16_t *l_932 = &g_343;
                    struct S0 l_933 = {-1,0x608DE207,0x732FAD8B};
                    (*l_898) = ((*g_317) != ((g_934 = ((((int16_t)((void*)0 == l_924) - (int16_t)p_43) != (((int16_t)(***g_732) + (int16_t)(l_864 = ((int16_t)((l_931 == ((((*l_925) = l_932) == (l_933 , (__builtin_ffsl(((*g_402) > (**g_401))) , l_862))) >= l_851)) < p_43) % (int16_t)65528U))) >= 0x374A32B8)) , (void*)0)) == (void*)0));
                }
            }
            for (p_43 = 0; (p_43 == 9); p_43 += 7)
            { /* block id: 597 */
                l_940 = func_30(((-(uint32_t)(((uint32_t)(*g_402) / (uint32_t)p_43) != g_70)) & (**g_401)), &l_864, (*g_848));
            }
            return l_942;
        }
        else
        { /* block id: 601 */
            int32_t *l_950 = (void*)0;
            int32_t *l_951 = &g_29;
            for (l_899.f2 = 0; (l_899.f2 == (-4)); l_899.f2 -= 7)
            { /* block id: 604 */
                struct S0 l_945 = {1,0xB124EE66,0};
                (***g_678) = l_945;
            }
            (*l_951) = (+((uint16_t)((((((p_43 , 1U) != ((p_43 ^ (p_43 , g_462)) == ((__builtin_bswap64((l_897 , (p_43 == ((+__builtin_bswap64(p_43)) < g_673)))) >= (**g_316)) , g_208))) || g_761) , p_44) == p_44) != 0x5E68) % (uint16_t)p_43));
        }
        (*l_853) = (((uint16_t)((*l_955) = g_207) % (uint16_t)g_223) , &p_43);
    }
    else
    { /* block id: 612 */
        uint32_t l_961 = 0x57D445FD;
        int32_t *l_962 = &l_852;
        int32_t *l_969 = &g_90;
        uint16_t *l_987 = &g_104;
        uint16_t **l_986 = &l_987;
        for (l_899.f2 = 0; (l_899.f2 > 15); l_899.f2++)
        { /* block id: 615 */
            int32_t *l_963 = &g_29;
            uint32_t *l_985 = (void*)0;
            uint32_t **l_984 = &l_985;
            uint32_t ***l_983 = &l_984;
            uint16_t **l_988 = &l_987;
            struct S0 *l_999 = &g_254;
        }
        (****g_677) = (l_899 , l_899);
    }
    return l_1002;
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_732 g_90 g_254.f2 g_142.f2 g_402 g_254.f1 g_171 g_734 g_293 g_19 g_733 g_767 g_254.f0 g_223 g_637 g_678 g_638 g_252 g_253 g_317 g_765 g_797 g_759 g_75 g_316 g_161 g_636
 * writes: g_104 g_29 g_462 g_254.f2 g_254.f1 g_343 g_761 g_765 g_767 g_254.f0 g_223 g_401 g_254 g_106 g_161 g_797 g_522 g_395
 */
static int16_t  func_46(uint16_t  p_47, uint16_t  p_48, uint32_t  p_49, struct S0  p_50)
{ /* block id: 471 */
    const int32_t *l_708 = &g_171;
    int32_t **l_710 = &g_106;
    int32_t * const **l_740 = &g_444;
    int16_t l_745 = (-2);
    struct S0 **l_748 = &g_253;
    int32_t *l_777 = (void*)0;
    int32_t ***l_802 = &l_710;
    uint32_t l_807 = 1U;
    uint32_t *l_808 = &l_807;
    int16_t l_835 = 9;
    struct S0 l_837 = {0x1CF328D8,0U,0xE428ACA2};
    float l_847 = 0x2.EF5AA1p+83;
    if (p_47)
    { /* block id: 472 */
        const int32_t **l_709 = &l_708;
        int32_t * const ** const l_711 = (void*)0;
        const float *l_739 = (void*)0;
        const float **l_738 = &l_739;
        uint8_t l_744 = 252U;
        int32_t *l_779 = &g_75;
        (*l_709) = l_708;
        if (p_50.f2)
        { /* block id: 474 */
            int32_t * const ***l_712 = &g_443;
            int32_t l_741 = 0;
            float l_753 = 0x0.5p-1;
            (*l_709) = ((g_104 = p_49) , (*l_709));
            for (g_29 = 0; (g_29 == 28); g_29 += 1)
            { /* block id: 480 */
                struct S0 **l_715 = &g_253;
                int32_t l_735 = 0;
                int32_t l_742 = 0xC8ED1316;
                uint32_t *l_743 = &g_254.f1;
                int16_t *l_746 = &g_343;
                uint32_t l_747 = 0x3E0E994E;
                float **l_766 = &g_317;
                if ((l_715 == ((8U ^ (((func_61((((*l_746) = ((((~((int16_t)((int16_t)((0x4F41 ^ ((((uint32_t)p_50.f0 - (uint32_t)(((((((*l_743) = (((int32_t)(((uint16_t)0xED30 >> (uint16_t)(((int16_t)((((func_61(((uint32_t)(!(l_735 = ((void*)0 == g_732))) + (uint32_t)((uint16_t)(&g_317 != l_738) - (uint16_t)g_90)), l_740, g_29) == g_29) <= l_741) & 0xC637B559) , p_47) << (int16_t)8) < 0xA6CE)) >= l_742) / (int32_t)p_50.f2) , 1U)) != l_744) == (*l_708)) && 0xCE565BAF) > l_745) ^ p_47)) | (-10)) || p_50.f1)) , 8) % (int16_t)(*l_708)) + (int16_t)(*l_708))) & p_50.f0) != p_47) , (*g_734))) == 0xA2F0), l_740, g_90) <= l_747) | g_19) , 0x2C6E5A25)) , l_748)))
                { /* block id: 484 */
                    const int32_t *l_749 = &g_171;
                    uint16_t *l_758 = &g_104;
                    uint16_t *l_760 = &g_761;
                    uint16_t *l_762 = (void*)0;
                    uint16_t *l_763 = (void*)0;
                    uint16_t *l_764 = &g_765;
                    (*l_709) = l_749;
                    p_50.f2 = (&g_317 != ((((((uint32_t)p_48 - (uint32_t)((~65535U) < (p_50 , p_50.f0))) ^ (l_742 = ((uint16_t)p_47 / (uint16_t)((*l_764) = ((*l_760) = ((int16_t)((*l_746) = (((*l_758) = ((((l_746 != (**g_732)) , &g_104) != &p_47) > p_48)) || l_735)) >> (int16_t)4)))))) >= p_48) , (**l_709)) , l_766));
                }
                else
                { /* block id: 492 */
                    volatile int16_t *****l_768 = &g_767;
                    (*l_768) = g_767;
                    (*l_709) = &l_741;
                    for (g_254.f0 = 18; (g_254.f0 >= (-12)); g_254.f0 -= 4)
                    { /* block id: 497 */
                        return p_47;
                    }
                }
                (*l_709) = (*l_709);
                if (p_50.f1)
                    continue;
                return l_747;
            }
        }
        else
        { /* block id: 505 */
            int32_t *l_778 = &g_29;
            for (g_223 = 18; (g_223 > 19); g_223 += 4)
            { /* block id: 508 */
                const int32_t * const l_773 = (void*)0;
                const int32_t **l_774 = &l_708;
                const uint32_t ***l_775 = (void*)0;
                const uint32_t ***l_776 = &g_401;
                (*l_774) = l_773;
                (*l_776) = &g_402;
                (*l_709) = (*l_709);
                return (***g_732);
            }
            (*l_709) = (l_778 = l_777);
            (****g_637) = p_50;
        }
        (*l_709) = ((*l_710) = l_779);
    }
    else
    { /* block id: 520 */
        struct S0 l_786 = {0x0AC08BE4,5U,4};
        int32_t l_795 = 6;
        int32_t * const **l_796 = &g_444;
        float ****l_798 = &g_797;
        float *l_799 = &g_522;
        (*l_799) = ((float)(0x4.1E375Ap-45 != ((float)(((*g_317) = 0x2.D11200p-15) <= (((float)(l_786 , (((float)((float)func_61(((uint32_t)((int16_t)l_795 >> (int16_t)p_48) - (uint32_t)__builtin_ffsll(g_765)), l_796, (((*l_798) = g_797) != (void*)0)) / (float)p_48) + (float)0xB.364F09p+59) == p_47)) + (float)p_48) <= g_759)) - (float)0x7.A37ED0p-26)) - (float)p_47);
    }
    if ((((uint16_t)((l_802 = &l_710) != ((*l_708) , &l_710)) / (uint16_t)((((uint16_t)p_50.f2 << (uint16_t)10) < (((*l_808) = ((int32_t)p_48 - (int32_t)l_807)) == 0xE5669A18)) & ((int16_t)(***g_732) % (int16_t)(((int16_t)(p_50.f0 == (*g_402)) >> (int16_t)7) & (-1))))) && g_29))
    { /* block id: 527 */
        int32_t l_823 = (-1);
        float *l_824 = &g_395;
        float *l_825 = &g_522;
        int32_t **l_836 = &l_777;
        int32_t * const **l_841 = &g_444;
        const struct S0 l_845 = {6,2U,0x50B96490};
        (*g_317) = ((float)((float)((float)((((float)((float)(**g_316) - (float)(**g_316)) + (float)((-0x1.Dp-1) > (((*l_825) = ((l_823 <= p_48) , ((*l_824) = 0x4.9421FFp-51))) <= (((!l_823) , &l_823) == &l_823)))) < (-0x5.4p-1)) > p_48) + (float)0x0.Cp-1) / (float)p_50.f2) - (float)p_50.f2);
        for (g_29 = 0; (g_29 > 26); g_29 += 1)
        { /* block id: 533 */
            const uint32_t *l_839 = &g_840;
            const uint32_t **l_838 = &l_839;
            int32_t l_842 = 0xC743D4EE;
            l_842 = (p_50.f2 = __builtin_ffsl(((((func_61((((float)((*l_824) = p_50.f0) / (float)(!func_61((+(((uint16_t)65532U + (uint16_t)(l_835 && ((((*l_838) = g_317) != &g_840) , 0))) == 0x9A93)), l_841, p_47))) , (*g_402)), &g_444, l_842) || p_47) , 0xF93FCC60) ^ p_47) ^ l_842)));
        }
        (*l_836) = (*l_836);
        (*****g_636) = l_845;
    }
    else
    { /* block id: 541 */
        int32_t *l_846 = &g_90;
        (*l_710) = l_846;
        return p_50.f0;
    }
    (**g_316) = (-0x9.6p+1);
    return (**g_733);
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_70 g_75 g_104 g_207 g_142.f1 g_19 g_255 g_208 g_161 g_254.f1 g_155 g_156 g_105 g_106 g_114 g_142 g_253 g_154 g_252 g_254 g_90 g_115 g_293 g_171 g_316 g_317 g_443 g_402 g_401 g_435 g_444 g_636 g_462 g_673 g_677
 * writes: g_70 g_161 g_255 g_105 g_90 g_104 g_106 g_254 g_343 g_115 g_253 g_75 g_204 g_395 g_462 g_208 g_29 g_435 g_434 g_677 g_637
 */
inline static uint16_t  func_51(int32_t ** p_52)
{ /* block id: 47 */
    const uint32_t l_55 = 0xCFF29C21;
    int32_t *l_69 = &g_29;
    int32_t * const *l_68 = &l_69;
    int32_t * const ** const l_67 = &l_68;
    int32_t *l_442 = &g_208;
    uint32_t *l_463 = &g_254.f1;
    uint32_t l_484 = 4294967286U;
    struct S0 l_486 = {0xC5DCF132,5U,-1};
    int16_t *l_510 = &g_435;
    int16_t **l_509 = &l_510;
    int32_t ***l_528 = &g_105;
    uint8_t l_560 = 0xC5;
    uint32_t l_601 = 6U;
    int32_t *l_602 = &g_75;
    uint32_t l_646 = 0x1CB922EB;
    int32_t *****l_675 = (void*)0;
    if (((int16_t)(__builtin_parity((l_55 && ((l_55 & 0) ^ ((int16_t)(-(int16_t)(((*l_463) = ((int16_t)(func_61(g_29, (((l_69 = func_65(l_67)) == l_442) , g_443), g_29) && (*l_442)) << (int16_t)g_208)) | (-2))) << (int16_t)13)))) < g_171) >> (int16_t)12))
    { /* block id: 331 */
        uint16_t *l_472 = &g_104;
        int32_t l_479 = 0x36D6B827;
        int16_t *l_480 = &g_435;
        uint8_t l_481 = 0x35;
        uint16_t l_482 = 6U;
        uint32_t l_483 = 4294967295U;
        l_483 = ((int32_t)((*l_442) = ((**g_252) , l_482)) - (int32_t)(**g_401));
    }
    else
    { /* block id: 340 */
        const struct S0 l_485 = {0,0xCB65DE4F,0};
        int32_t l_487 = 0x8190C90D;
        struct S0 **l_495 = &g_253;
        int16_t *l_534 = (void*)0;
        int32_t *l_640 = &g_70;
        (**g_252) = (l_485 , l_486);
        if ((l_487 = (*l_442)))
        { /* block id: 343 */
            int32_t **l_488 = &g_106;
            const struct S0 *l_497 = &g_254;
            const struct S0 ** const l_496 = &l_497;
            int32_t *l_498 = (void*)0;
            int32_t *l_499 = &g_29;
            struct S0 l_529 = {0x24840EA7,0x09353299,0xBEDF1BFF};
            int32_t * const **l_550 = &g_444;
            uint8_t *l_571 = &l_560;
            float ***l_579 = (void*)0;
            (*l_488) = &l_487;
            if (((((int16_t)((int16_t)((**g_401) < (**g_401)) >> (int16_t)(__builtin_parityl((**l_488)) < ((__builtin_clzl((*l_442)) | 0xA0398727) > (((*l_499) = ((((l_495 == l_496) > 0) != 0x863D4604) , (-1))) <= l_485.f0)))) + (int16_t)g_104) , (*g_402)) ^ 0xA652AF85))
            { /* block id: 346 */
                uint32_t l_500 = 1U;
                int32_t *l_524 = (void*)0;
                struct S0 ***l_531 = &g_252;
                struct S0 ****l_530 = &l_531;
                if (func_61(l_487, &g_444, l_500))
                { /* block id: 347 */
                    (*l_499) = __builtin_clz((**g_401));
                }
                else
                { /* block id: 349 */
                    int32_t *l_507 = &g_90;
                    (*l_488) = &l_487;
                    if ((!l_500))
                    { /* block id: 351 */
                        return g_75;
                    }
                    else
                    { /* block id: 353 */
                        int16_t ***l_511 = &l_509;
                        int32_t l_514 = 1;
                        uint32_t *l_523 = &l_484;
                        int32_t **l_525 = &l_69;
                        (*l_511) = l_509;
                        (*l_525) = ((4294967295U > ((int16_t)g_142.f0 << (int16_t)g_435)) , (*l_68));
                        (*l_525) = l_507;
                        (*g_253) = l_529;
                    }
                }
                (*l_530) = &g_252;
                for (g_29 = 27; (g_29 == (-24)); g_29 -= 1)
                { /* block id: 365 */
                    (**g_316) = ((void*)0 == l_534);
                }
                return g_254.f1;
            }
            else
            { /* block id: 369 */
                uint32_t l_540 = 0x9C5781C0;
                float *l_542 = &g_395;
                float *l_543 = &g_434;
                (**g_444) = (~l_485.f1);
                (*l_543) = (((*g_317) = (__builtin_ffs(((*g_106) = l_487)) > (*g_317))) == ((float)((float)((((**l_509) = 0x3548) > l_485.f2) , 0x3.C131C9p+39) + (float)0x1.0p-1) / (float)((l_540 , (!(((*l_542) = ((l_485.f0 < l_540) != (*l_499))) >= 0x3.AFDA28p-70))) < l_540)));
            }
            (**g_316) = ((float)(*g_317) / (float)((float)(((float)func_61((*g_402), l_550, ((l_485.f1 , (~(l_487 >= (__builtin_parityll((((**g_401) || 0xF84FE9D9) , (*l_499))) >= (**l_488))))) & (***l_550))) + (float)(*g_317)) == l_485.f1) / (float)0x8.43EF6Cp-74));
            if (func_61(((*l_497) , (*g_402)), l_550, (**l_488)))
            { /* block id: 378 */
                int32_t * const **l_559 = &g_444;
                float **l_576 = &g_317;
                int32_t *l_582 = (void*)0;
                int32_t **l_583 = &l_69;
                float ****l_588 = &l_579;
                uint16_t *l_589 = &g_104;
                for (g_70 = 13; (g_70 <= 24); g_70++)
                { /* block id: 381 */
                    int32_t *l_569 = &g_70;
                }
                (*g_253) = (**g_252);
                (*l_583) = (**l_67);
                (**g_252) = l_486;
            }
            else
            { /* block id: 413 */
                return l_485.f2;
            }
        }
        else
        { /* block id: 416 */
            int32_t *l_603 = (void*)0;
            uint32_t l_641 = 4294967291U;
            (*l_442) = ((uint32_t)((**l_495) , ((int16_t)(0xDF1B | (*l_442)) - (int16_t)g_254.f0)) % (uint32_t)(l_487 = l_601));
            l_603 = l_602;
            if (l_485.f0)
            { /* block id: 420 */
                int32_t l_606 = 0x1E7EFF91;
                int32_t l_622 = 0xBA8D8953;
                float **l_631 = &g_317;
                float ***l_630 = &l_631;
                struct S0 *** const **l_639 = &g_637;
                if ((((+0xCAA051A8) < (((+(-2)) >= (l_606 < ((int32_t)(l_606 <= (((uint16_t)((((float)((((float)((float)(((*l_603) > (((-0x1.Ap+1) <= (!((((*g_317) = ((float)__builtin_ffsl((l_606 != (((uint16_t)((*g_253) , (l_606 , (*l_603))) << (uint16_t)2) <= (-1)))) / (float)l_622)) != l_487) , 0x3.CAD942p-3))) , (*g_317))) < 0x4.280BE1p+64) + (float)(*l_602)) / (float)l_606) > l_487) != (*l_603)) - (float)l_485.f0) , (*l_603)) == l_487) >> (uint16_t)l_487) < l_485.f1)) % (int32_t)l_606))) , 0xD9C48C49)) & l_606))
                { /* block id: 422 */
                    int32_t ***l_634 = &g_105;
                    for (l_486.f1 = 0; (l_486.f1 < 58); l_486.f1++)
                    { /* block id: 425 */
                        struct S0 l_625 = {0xF3275490,0U,0x6B0D0AC6};
                        int32_t **l_635 = &l_442;
                        (*l_635) = &l_487;
                    }
                    l_639 = g_636;
                }
                else
                { /* block id: 429 */
                    l_640 = &l_622;
                }
            }
            else
            { /* block id: 432 */
                int16_t l_642 = 0xAB81;
                l_641 = (*l_640);
                l_642 = 0xAF56BBDE;
            }
            return (*l_603);
        }
        for (g_208 = 0; (g_208 != 1); ++g_208)
        { /* block id: 440 */
            float l_645 = 0x3.2p+1;
            return g_75;
        }
    }
    if (l_646)
    { /* block id: 444 */
        int32_t l_649 = 0;
        uint32_t *l_659 = &l_601;
        int32_t **l_660 = &g_106;
        int32_t *l_661 = (void*)0;
        l_661 = ((*l_660) = (((int16_t)(l_649 != (!(l_486 , l_649))) >> (int16_t)0) , (void*)0));
    }
    else
    { /* block id: 450 */
        uint16_t l_664 = 0U;
        uint16_t *l_672 = &g_104;
        uint32_t *l_674 = &g_223;
        int32_t *l_676 = &g_254.f0;
        struct S0 *****l_679 = &g_677;
        int32_t **l_680 = &g_106;
        int32_t *l_681 = &g_254.f2;
        (*l_602) = ((__builtin_popcount(((uint16_t)l_664 / (uint16_t)((*l_510) = (((int32_t)l_664 + (int32_t)((((((int16_t)l_664 << (int16_t)12) , ((*l_602) = ((g_462 != ((l_664 > ((__builtin_ctzl((((((0x19016231 == ((uint16_t)(*l_442) / (uint16_t)((*l_672) = ((!((g_90 , ((0x720F && g_208) == l_664)) <= 4294967289U)) || 4294967295U)))) ^ l_664) , l_664) , g_673) , l_664)) , &l_601) == l_674)) || l_664)) ^ l_664))) , 0x01C289B0) , &g_115) != l_675)) , 4)))) ^ 4294967295U) || g_90);
        (*g_636) = ((*l_679) = (((*l_676) = __builtin_clzll(g_673)) , g_677));
        (*l_680) = (*l_68);
        (*l_680) = l_681;
    }
    for (l_486.f0 = 0; (l_486.f0 < 19); l_486.f0 += 7)
    { /* block id: 463 */
        uint16_t *l_686 = &g_104;
        (*l_442) = ((uint16_t)4U / (uint16_t)((*l_686) = 0x629F));
    }
    return g_673;
}


/* ------------------------------------------ */
/* 
 * reads : g_254.f2 g_142.f2 g_402 g_254.f1
 * writes: g_104 g_462 g_254.f2
 */
static uint32_t  func_61(uint32_t  p_62, int32_t * const ** p_63, uint16_t  p_64)
{ /* block id: 322 */
    int32_t * const ** const l_445 = &g_444;
    int32_t *l_446 = &g_254.f2;
    int32_t **l_447 = &l_446;
    int32_t l_455 = 0x8F9C780D;
    struct S0 l_458 = {0x52DE9F1D,4294967295U,6};
    int32_t l_459 = 0xA8972BC3;
    uint16_t *l_460 = (void*)0;
    uint16_t *l_461 = &g_104;
    l_446 = l_446;
    (*l_447) = l_446;
    (**l_447) = ((uint16_t)((*l_446) , (g_462 = ((*l_461) = ((uint32_t)4294967287U / (uint32_t)(((g_142.f2 & 1) > p_62) , ((uint32_t)(((+(**l_447)) || l_455) == p_62) / (uint32_t)((l_458 , 247U) , l_459))))))) / (uint16_t)0x490E);
    return (*g_402);
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_75 g_29 g_104 g_207 g_142.f1 g_19 g_255 g_208 g_161 g_254.f1 g_155 g_156 g_105 g_106 g_114 g_142 g_253 g_154 g_252 g_254 g_90 g_115 g_293 g_171 g_316 g_317
 * writes: g_70 g_161 g_255 g_105 g_90 g_104 g_106 g_254 g_343 g_115 g_253 g_75 g_204 g_395
 */
static int32_t * func_65(int32_t * const ** const  p_66)
{ /* block id: 48 */
    int32_t *l_74 = &g_75;
    struct S0 l_256 = {-1,0U,0x0B5030AC};
    uint32_t l_257 = 4294967291U;
    uint32_t *l_260 = &l_256.f1;
    float *l_262 = &g_161;
    int32_t l_263 = 0x7D269447;
    uint16_t *l_337 = &g_104;
    int32_t *l_367 = &g_70;
    int32_t *l_441 = &g_70;
    for (g_70 = 0; (g_70 <= (-16)); --g_70)
    { /* block id: 51 */
        int32_t *l_73 = &g_70;
        struct S0 *l_221 = (void*)0;
        struct S0 **l_220 = &l_221;
        struct S0 l_237 = {0x0FEA248F,0xBE4936EB,0x9B283B4B};
        l_74 = l_73;
    }
    if (((uint32_t)((*l_260) = (*l_74)) / (uint32_t)(((l_263 = ((+((*l_74) == ((*l_74) <= (((*l_262) = (*l_74)) == (*l_74))))) , (0x7.00E734p+40 == (*l_74)))) , ((***p_66) < (*l_74))) ^ (*l_74))))
    { /* block id: 179 */
        const int16_t l_271 = (-3);
        int16_t *l_272 = (void*)0;
        int16_t *l_273 = (void*)0;
        int32_t l_278 = (-1);
        int32_t *l_279 = (void*)0;
        (*l_262) = (0x8.EC8C54p-20 == g_104);
        g_105 = func_30((g_207 , (((***p_66) && ((int32_t)(-(uint16_t)((uint32_t)(p_66 == (void*)0) - (uint32_t)((int16_t)l_271 >> (int16_t)1))) - (int32_t)((g_255 = g_142.f1) || ((((uint16_t)0U % (uint16_t)(((l_256 , (l_278 = (((uint16_t)65530U << (uint16_t)12) && (*l_74)))) <= (*l_74)) | g_104)) >= g_207) || g_19)))) & 1)), l_279, &g_106);
        for (l_256.f1 = 0; (l_256.f1 > 5); l_256.f1 += 1)
        { /* block id: 186 */
            l_279 = (**p_66);
            for (g_255 = 0; (g_255 >= (-14)); g_255 -= 5)
            { /* block id: 190 */
                g_161 = 0x2.8E1F30p-82;
            }
        }
    }
    else
    { /* block id: 194 */
        uint32_t l_287 = 4294967295U;
        const int32_t *l_297 = &g_75;
        float * const *l_314 = &l_262;
        float * const *l_319 = (void*)0;
        uint32_t l_323 = 4294967295U;
        int32_t *l_384 = &g_29;
        if ((l_256.f2 = ((****g_155) = ((uint16_t)(&g_223 == &g_223) - (uint16_t)(((~((((((*l_74) && g_29) , l_287) != (((l_287 , l_287) == (-(float)(((((g_208 , (*l_74)) , l_287) && 0x40E6) , l_287) >= (*l_74)))) != (*l_74))) == g_161) , g_254.f1)) || g_19) <= l_287)))))
        { /* block id: 197 */
            const float l_291 = 0x5.C59D5Bp-74;
            const uint16_t l_307 = 1U;
            uint32_t *l_324 = &g_223;
            (*g_253) = func_84((*l_74));
            for (l_256.f2 = 0; (l_256.f2 <= (-2)); l_256.f2--)
            { /* block id: 201 */
                uint32_t l_292 = 4294967287U;
                uint16_t *l_308 = &g_104;
                int32_t **l_309 = (void*)0;
                int32_t **l_310 = (void*)0;
                int32_t **l_311 = &l_74;
                float * const **l_315 = &l_314;
                float * const **l_318 = (void*)0;
                uint32_t **l_325 = (void*)0;
                uint32_t **l_326 = &l_324;
                uint32_t l_327 = 0x5D1FD822;
                int32_t l_328 = 0xA99E674F;
            }
        }
        else
        { /* block id: 227 */
            uint32_t l_333 = 0x8256CFA1;
            struct S0 *l_366 = &g_254;
            int16_t *l_376 = &g_255;
            int32_t l_422 = (-7);
            for (l_257 = (-24); (l_257 <= 47); ++l_257)
            { /* block id: 230 */
                int32_t *l_371 = (void*)0;
                if ((*****g_154))
                { /* block id: 231 */
                    uint16_t **l_336 = (void*)0;
                    const int32_t l_338 = (-1);
                    int16_t *l_341 = &g_255;
                    int16_t *l_342 = &g_343;
                    int16_t l_348 = 8;
                    int32_t l_363 = 0x25B2F48B;
                    uint16_t * const *l_365 = &l_337;
                    (****g_154) = (***g_155);
                    (**l_314) = ((float)l_333 + (float)(-0x1.5p+1));
                    if (__builtin_parityll((((int32_t)((****g_155) = (((*l_74) , &g_104) == (l_337 = &g_104))) - (int32_t)(l_338 >= ((uint16_t)((((*l_342) = ((*l_341) = 0x1CA4)) && g_208) ^ ((int16_t)(((*l_297) < ((uint16_t)((**g_252) , (0x9A48 == l_333)) >> (uint16_t)6)) , l_348) + (int16_t)65535U)) / (uint16_t)g_90))) > l_333)))
                    { /* block id: 238 */
                        (*g_114) = (*g_114);
                        if ((***p_66))
                            break;
                    }
                    else
                    { /* block id: 241 */
                        (*g_253) = (**g_252);
                    }
                    for (g_90 = (-15); (g_90 < 3); g_90++)
                    { /* block id: 246 */
                        uint16_t ***l_353 = &l_336;
                        struct S0 *l_354 = &l_256;
                        int32_t l_364 = 0;
                        (**g_156) = (****g_154);
                        (**g_252) = ((g_254.f2 ^ (((*l_353) = (void*)0) == (((((*l_354) = l_256) , (~(-1))) ^ ((uint16_t)((int16_t)(*l_297) - (int16_t)l_348) + (uint16_t)((~((uint16_t)(((l_363 = ((**g_105) = 0xFF0B4441)) & (l_333 <= (((0x1E33 ^ 3) != l_364) , l_364))) ^ (***p_66)) << (uint16_t)3)) , 3U))) , l_365))) , l_256);
                        (*g_252) = l_366;
                    }
                }
                else
                { /* block id: 255 */
                    int32_t l_370 = (-6);
                    if ((***p_66))
                    { /* block id: 256 */
                        return l_367;
                    }
                    else
                    { /* block id: 258 */
                        (*l_367) = 0xFC249A5B;
                    }
                    for (l_256.f0 = (-20); (l_256.f0 > 0); l_256.f0++)
                    { /* block id: 263 */
                        (**g_252) = (*g_253);
                        (*l_262) = l_370;
                        return l_371;
                    }
                }
                if ((***p_66))
                    break;
            }
            if (((int16_t)((*l_297) > ((((*l_376) = g_293) | ((*g_106) <= (((int32_t)(***p_66) / (int32_t)__builtin_clz((*l_74))) != ((uint16_t)((*l_337) = ((((*l_367) , g_171) , g_254.f1) , 0x9705)) >> (uint16_t)15)))) | 0x68BF3F15)) + (int16_t)l_333))
            { /* block id: 273 */
                int16_t l_383 = (-10);
                for (l_256.f2 = 10; (l_256.f2 != 16); l_256.f2 += 6)
                { /* block id: 276 */
                    if (l_383)
                    { /* block id: 277 */
                        return l_384;
                    }
                    else
                    { /* block id: 279 */
                        int32_t l_387 = 4;
                        g_204 = (((*l_74) = (***p_66)) , (***p_66));
                        (*l_366) = func_84(((*l_260) = (((l_387 || 0U) >= ((*l_384) == ((int16_t)(-5) / (int16_t)g_254.f1))) != (((5U >= ((*l_297) == l_383)) && ((*l_376) = ((uint16_t)g_208 << (uint16_t)14))) <= 0x4760))));
                        (*g_105) = (void*)0;
                        return (*g_105);
                    }
                }
                return (***g_155);
            }
            else
            { /* block id: 290 */
                float *l_394 = &g_395;
                int32_t l_419 = 0xBC560E69;
                struct S0 l_440 = {0,0x1568D6C9,0x16F301F7};
                (*l_394) = (((*l_262) = (**g_316)) != ((float)(*l_367) - (float)0xD.D14176p+72));
                for (g_75 = 0; (g_75 > 16); ++g_75)
                { /* block id: 295 */
                    int16_t l_407 = 0;
                    (*g_252) = l_366;
                }
                (**g_252) = l_440;
            }
        }
    }
    return l_441;
}


/* ------------------------------------------ */
/* 
 * reads : g_29 g_105 g_156 g_106
 * writes: g_90 g_106
 */
inline static int32_t * const  func_78(struct S0  p_79, float  p_80, int32_t * p_81, float  p_82, int32_t *** p_83)
{ /* block id: 116 */
    int32_t *l_198 = &g_90;
    (*l_198) = (~g_29);
    (*g_105) = l_198;
    return (**g_156);
}


/* ------------------------------------------ */
/* 
 * reads : g_75 g_29 g_104 g_105 g_106 g_70 g_114 g_19 g_142 g_156
 * writes: g_90 g_104 g_106
 */
inline static struct S0  func_84(uint32_t  p_85)
{ /* block id: 56 */
    int16_t l_101 = 9;
    int32_t *l_110 = &g_70;
    struct S0 l_112 = {-10,0x6A66835A,0x29F8D9E2};
    volatile int32_t *** const **l_116 = (void*)0;
    if (((uint16_t)((((*g_105) = func_88(func_30(((g_90 = (-1)) ^ ((uint32_t)((int32_t)(g_75 == ((((uint16_t)(g_104 = (0U != (p_85 , (((((int16_t)((uint16_t)l_101 + (uint16_t)((int16_t)g_29 << (int16_t)l_101)) << (int16_t)9) <= ((void*)0 == &g_70)) <= g_75) || p_85)))) >> (uint16_t)p_85) && g_104) & 65535U)) - (int32_t)p_85) - (uint32_t)l_101)), &g_75, g_105))) == (void*)0) & 0x0705E773) % (uint16_t)l_101))
    { /* block id: 64 */
        struct S0 l_111 = {0x735AE52E,0xAD701FB0,0x350090E7};
        (*g_105) = l_110;
        return l_111;
    }
    else
    { /* block id: 67 */
        struct S0 *l_113 = &l_112;
        int32_t *l_131 = &g_29;
        int32_t ** const ***l_157 = (void*)0;
        int32_t **l_191 = &g_106;
        int32_t ***l_192 = (void*)0;
        int32_t ***l_193 = &l_191;
        (*l_113) = l_112;
lbl_194:
        if (p_85)
        { /* block id: 69 */
            struct S0 l_117 = {1,0xE3FE27FC,0};
            int32_t *l_118 = &l_112.f2;
            l_116 = g_114;
            (*l_113) = l_117;
            (*g_105) = l_118;
        }
        else
        { /* block id: 73 */
            int32_t l_119 = 0;
            struct S0 *l_159 = &l_112;
            int32_t l_174 = 0x824337CD;
            int32_t l_186 = 0x7568C23F;
            l_119 = __builtin_parityll(g_75);
            for (l_112.f0 = 18; (l_112.f0 < 23); l_112.f0 += 9)
            { /* block id: 77 */
                int32_t *l_122 = &g_90;
                volatile struct S0 **l_188 = (void*)0;
                volatile struct S0 *l_190 = &g_142;
                volatile struct S0 **l_189 = &l_190;
                (*l_122) = p_85;
            }
            (*l_159) = g_142;
        }
        (**g_156) = func_88(((*l_193) = l_191));
        if (p_85)
            goto lbl_194;
    }
    return g_142;
}


/* ------------------------------------------ */
/* 
 * reads : g_105 g_106 g_70 g_29 g_90
 * writes: g_90
 */
static int32_t * func_88(int32_t ** p_89)
{ /* block id: 59 */
    int32_t ***l_108 = &g_105;
    int32_t ****l_107 = &l_108;
    int32_t *l_109 = &g_90;
    (*l_107) = &g_105;
    (*l_109) = (**g_105);
    return (*g_105);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    transparent_crc(g_19, "g_19", print_hash_value);
    transparent_crc(g_29, "g_29", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc(g_75, "g_75", print_hash_value);
    transparent_crc(g_90, "g_90", print_hash_value);
    transparent_crc(g_104, "g_104", print_hash_value);
    transparent_crc(g_142.f0, "g_142.f0", print_hash_value);
    transparent_crc(g_142.f1, "g_142.f1", print_hash_value);
    transparent_crc(g_142.f2, "g_142.f2", print_hash_value);
    transparent_crc_bytes (&g_161, sizeof(g_161), "g_161", print_hash_value);
    transparent_crc(g_171, "g_171", print_hash_value);
    transparent_crc(g_204, "g_204", print_hash_value);
    transparent_crc(g_205, "g_205", print_hash_value);
    transparent_crc(g_206, "g_206", print_hash_value);
    transparent_crc(g_207, "g_207", print_hash_value);
    transparent_crc(g_208, "g_208", print_hash_value);
    transparent_crc(g_223, "g_223", print_hash_value);
    transparent_crc(g_254.f0, "g_254.f0", print_hash_value);
    transparent_crc(g_254.f1, "g_254.f1", print_hash_value);
    transparent_crc(g_254.f2, "g_254.f2", print_hash_value);
    transparent_crc(g_255, "g_255", print_hash_value);
    transparent_crc(g_293, "g_293", print_hash_value);
    transparent_crc(g_343, "g_343", print_hash_value);
    transparent_crc_bytes (&g_395, sizeof(g_395), "g_395", print_hash_value);
    transparent_crc_bytes (&g_432, sizeof(g_432), "g_432", print_hash_value);
    transparent_crc_bytes (&g_434, sizeof(g_434), "g_434", print_hash_value);
    transparent_crc(g_435, "g_435", print_hash_value);
    transparent_crc(g_462, "g_462", print_hash_value);
    transparent_crc_bytes (&g_522, sizeof(g_522), "g_522", print_hash_value);
    transparent_crc(g_673, "g_673", print_hash_value);
    transparent_crc(g_694, "g_694", print_hash_value);
    transparent_crc_bytes (&g_759, sizeof(g_759), "g_759", print_hash_value);
    transparent_crc(g_761, "g_761", print_hash_value);
    transparent_crc(g_765, "g_765", print_hash_value);
    transparent_crc(g_840, "g_840", print_hash_value);
    transparent_crc(g_1010, "g_1010", print_hash_value);
    transparent_crc(g_1048, "g_1048", print_hash_value);
    transparent_crc(g_1089.f0, "g_1089.f0", print_hash_value);
    transparent_crc(g_1089.f1, "g_1089.f1", print_hash_value);
    transparent_crc(g_1089.f2, "g_1089.f2", print_hash_value);
    transparent_crc_bytes (&g_1108, sizeof(g_1108), "g_1108", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 249
   depth: 1, occurrence: 28
XXX total union variables: 0

XXX max expression depth: 46
breakdown:
   depth: 1, occurrence: 215
   depth: 2, occurrence: 39
   depth: 3, occurrence: 4
   depth: 4, occurrence: 8
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 12, occurrence: 1
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 2
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 2
   depth: 20, occurrence: 3
   depth: 21, occurrence: 3
   depth: 22, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 31, occurrence: 1
   depth: 33, occurrence: 1
   depth: 46, occurrence: 1

XXX total number of pointers: 335

XXX times a variable address is taken: 324
XXX times a pointer is dereferenced on RHS: 293
breakdown:
   depth: 1, occurrence: 169
   depth: 2, occurrence: 80
   depth: 3, occurrence: 35
   depth: 4, occurrence: 7
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 274
breakdown:
   depth: 1, occurrence: 231
   depth: 2, occurrence: 29
   depth: 3, occurrence: 5
   depth: 4, occurrence: 7
   depth: 5, occurrence: 2
XXX times a pointer is compared with null: 24
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 1574

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 869
   level: 2, occurrence: 363
   level: 3, occurrence: 217
   level: 4, occurrence: 93
   level: 5, occurrence: 60
XXX number of pointers point to pointers: 168
XXX number of pointers point to scalars: 153
XXX number of pointers point to structs: 14
XXX percent of pointers has null in alias set: 25.7
XXX average alias set size: 1.24

XXX times a non-volatile is read: 1401
XXX times a non-volatile is write: 738
XXX times a volatile is read: 42
XXX    times read thru a pointer: 15
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 393
XXX percentage of non-volatile access: 98

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 192
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 36
   depth: 2, occurrence: 32
   depth: 3, occurrence: 37
   depth: 4, occurrence: 28
   depth: 5, occurrence: 27

XXX percentage a fresh-made variable is used: 18
XXX percentage an existing variable is used: 82
********************* end of statistics **********************/

