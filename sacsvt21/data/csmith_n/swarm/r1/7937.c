/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --global-variabless --no-builtins
 * Seed:      2264486290
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 23;
   signed f1 : 16;
   unsigned f2 : 18;
   unsigned f3 : 22;
   const unsigned f4 : 13;
   const unsigned f5 : 16;
   unsigned f6 : 14;
   signed f7 : 11;
   unsigned f8 : 3;
   signed f9 : 5;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_2 = (-9L);
static float g_11 = 0x2.1p+1;
static int32_t g_13 = 0x0244C3F4L;
static const uint32_t g_33 = 0UL;
static uint32_t g_36 = 9UL;
static struct S0 g_42 = {-1315,85,238,325,70,90,57,10,0,-0};
static int16_t g_64 = (-8L);
static int16_t *g_63 = &g_64;
static uint64_t g_82 = 0x8B6467BE229A0C81LL;
static int32_t *g_87 = &g_2;
static int32_t **g_86 = &g_87;
static int32_t *** const g_85 = &g_86;
static int32_t g_92 = 0L;
static uint16_t g_125 = 0x695FL;
static float g_158 = (-0x1.0p-1);
static const int16_t g_211 = 0x1EA8L;
static uint64_t g_277 = 0UL;
static struct S0 ** const g_288 = (void*)0;
static struct S0 ** const *g_287 = &g_288;
static uint64_t ***g_289 = (void*)0;
static float g_347 = 0xD.14F6FAp+26;
static int16_t **g_351 = &g_63;
static int16_t ***g_350 = &g_351;
static int16_t ****g_349 = &g_350;
static float g_372 = 0xF.AF815Ap+61;
static int32_t g_377 = 0x1C9AC6BEL;
static int64_t g_395 = 0x04BBA9FF0F2C8688LL;
static uint64_t g_400 = 0x4C65C70F8A1C5321LL;
static int16_t *****g_411 = &g_349;
static int16_t g_430 = 0x87D6L;
static const uint16_t g_520 = 0x0E07L;
static uint64_t ****g_525 = &g_289;
static uint64_t *****g_524 = &g_525;
static int16_t g_591 = (-1L);
static float g_646 = 0x0.E8DF85p+10;
static uint32_t g_650 = 0x4C0B0FD8L;
static uint32_t **g_680 = (void*)0;
static float g_722 = 0x9.6p-1;
static uint16_t g_724 = 9UL;
static float *** const g_725 = (void*)0;
static int32_t ***g_737 = &g_86;
static int32_t ****g_742 = &g_737;
static int32_t *****g_741 = &g_742;
static const int32_t *g_833 = &g_377;
static uint32_t g_852 = 6UL;
static uint64_t *g_918 = (void*)0;
static uint64_t **g_917 = &g_918;
static uint64_t ***g_916 = &g_917;


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_1(void);
inline static int32_t * func_5(int32_t  p_6, int32_t * p_7, uint64_t  p_8, uint32_t  p_9);
inline static uint32_t  func_15(int32_t * p_16, uint32_t  p_17, uint64_t  p_18);
static uint64_t  func_19(int32_t * p_20, uint64_t  p_21);
static int32_t * func_22(int16_t  p_23, const uint16_t  p_24);
static int32_t * func_37(struct S0  p_38, uint32_t  p_39, struct S0  p_40, uint32_t  p_41);
inline static uint32_t  func_44(uint16_t  p_45, int32_t * p_46, int32_t * p_47);
static int16_t  func_59(int16_t * p_60, int32_t * p_61, int32_t * p_62);
static int16_t  func_68(const struct S0  p_69, uint64_t  p_70);
inline static int32_t  func_75(int16_t  p_76, int16_t * p_77, int32_t * p_78, uint64_t  p_79);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_2 g_33 g_42 g_86 g_87 g_85 g_650 g_64 g_680 g_11 g_725 g_741 g_36 g_524 g_525 g_158 g_400 g_411 g_349 g_350 g_351 g_63 g_833 g_377 g_430 g_916 g_13
 * writes: g_2 g_13 g_36 g_87 g_11 g_158 g_377 g_125 g_724 g_650 g_737 g_347 g_287 g_289 g_646 g_833 g_722 g_372 g_64 g_92 g_430 g_852
 */
inline static struct S0  func_1(void)
{ /* block id: 0 */
    int32_t *l_14 = (void*)0;
    int32_t l_740 = 0x7D935B76L;
    uint64_t ***l_919 = &g_917;
    uint32_t l_921 = 0x96AC5459L;
    float *l_922 = &g_646;
    struct S0 l_923 = {-548,-171,141,1921,86,27,26,1,1,-0};
    uint32_t *l_924 = &g_36;
    int32_t l_925 = (-5L);
    for (g_2 = (-12); (g_2 >= 0); g_2 += 3)
    { /* block id: 3 */
        uint32_t l_10 = 0x94D03572L;
        int32_t *l_12 = &g_13;
        (*g_86) = func_5(((*l_12) = l_10), l_14, g_2, (func_15(l_14, (func_19(func_22(g_2, ((int16_t)((uint16_t)g_2 << (uint16_t)14) << (int16_t)((int16_t)((int32_t)g_33 / (int32_t)l_10) * (int16_t)((int16_t)((g_36 = 0xF06E85FCL) != g_2) >> (int16_t)g_2)))), l_740) > 0L), l_740) < g_400));
        for (g_430 = 0; (g_430 < (-29)); --g_430)
        { /* block id: 465 */
            int16_t l_906 = 5L;
            uint32_t *l_907 = &g_852;
            const uint16_t *l_912 = &g_724;
            const uint16_t **l_911 = &l_912;
            const uint16_t ***l_910 = &l_911;
            const uint16_t ****l_909 = &l_910;
            uint32_t *l_915 = &g_650;
            struct S0 l_920 = {-862,79,71,286,10,225,71,17,0,4};
            (*l_12) = ((int64_t)((uint32_t)((uint32_t)((*l_907) = l_906) / (uint32_t)((+0xB78E7ED4L) | ((void*)0 == l_909))) + (uint32_t)((((uint32_t)((*l_915) = 0x8A76C9A4L) + (uint32_t)((((**g_524) = g_916) == l_919) < (0x52EDL > ((((void*)0 == g_725) > l_906) ^ (*****g_411))))) & (*l_12)) && (*g_87))) + (int64_t)(*l_12));
            return l_920;
        }
    }
    (*l_922) = (l_921 < ((void*)0 == &l_14));
    (*g_86) = func_37(l_923, ((*l_924) = 0x711B70DEL), g_42, l_925);
    return l_923;
}


/* ------------------------------------------ */
/* 
 * reads : g_724 g_36 g_411 g_349 g_350 g_351 g_63 g_64 g_86 g_524 g_525 g_833 g_377
 * writes: g_724 g_36 g_87 g_646 g_158 g_833 g_125 g_722 g_372 g_11 g_64 g_92
 */
inline static int32_t * func_5(int32_t  p_6, int32_t * p_7, uint64_t  p_8, uint32_t  p_9)
{ /* block id: 401 */
    uint64_t l_823 = 0xBC99672B6EE797E5LL;
    int32_t l_829 = 0x40A744A1L;
    uint16_t * const l_858 = &g_724;
    uint16_t * const *l_857 = &l_858;
    uint16_t * const **l_856 = &l_857;
    uint64_t ***l_888 = (void*)0;
    uint32_t l_894 = 1UL;
    uint16_t *l_895 = &g_125;
    int32_t *l_896 = &g_92;
    int16_t l_897 = 1L;
    for (g_724 = 1; (g_724 != 9); g_724 += 4)
    { /* block id: 404 */
        int32_t l_802 = 0x1DFE7E14L;
        float l_818 = 0x8.501CDAp+78;
        float *l_870 = &g_372;
        float *l_876 = &g_11;
        uint64_t ****l_877 = &g_289;
        for (g_36 = (-7); (g_36 <= 35); g_36 += 9)
        { /* block id: 407 */
            uint32_t l_817 = 0x8266FC1BL;
            int32_t l_832 = 1L;
            uint16_t *l_842 = &g_125;
            uint64_t l_861 = 0xE9843A598163D10FLL;
            l_802 = ((int16_t)0xB417L >> (int16_t)11);
            if (p_6)
                break;
            for (p_6 = 0; (p_6 <= (-6)); --p_6)
            { /* block id: 412 */
                uint64_t l_805 = 0xFE453BFCFD2FA0CELL;
                float *l_810 = &g_646;
                int32_t *l_835 = &g_92;
                if (l_805)
                { /* block id: 413 */
                    float *l_809 = &g_646;
                    float **l_808 = &l_809;
                    float **l_811 = &l_810;
                    int32_t l_816 = 0x9895463BL;
                    if (((int16_t)(*****g_411) << (int16_t)((((*l_808) = p_7) == ((*l_811) = l_810)) & l_805)))
                    { /* block id: 416 */
                        int32_t *l_812 = (void*)0;
                        (*g_86) = l_812;
                        (**l_811) = ((float)0x1.9p+1 * (float)p_6);
                    }
                    else
                    { /* block id: 419 */
                        int32_t *l_815 = (void*)0;
                        l_815 = &p_6;
                        l_817 = l_816;
                        l_816 = ((l_818 = ((void*)0 != (*g_524))) <= 0x3.F28035p-84);
                    }
                    l_832 = ((float)(((((float)l_823 - (float)p_9) != ((float)0x1.5p+1 * (float)(l_816 > 0x0.Dp-1))) > ((float)((l_817 > (+(g_158 = l_829))) >= ((float)((((**l_811) = p_8) < ((-0x1.1p-1) > p_6)) <= 0x0.7p+1) * (float)p_6)) + (float)p_9)) > 0x3.B6A719p-37) / (float)p_8);
                }
                else
                { /* block id: 428 */
                    const int32_t **l_834 = &g_833;
                    uint32_t * const l_851 = &g_852;
                    uint32_t * const *l_850 = &l_851;
                    uint32_t * const **l_849 = &l_850;
                    uint16_t * const ***l_859 = (void*)0;
                    uint16_t * const ***l_860 = &l_856;
                    (*l_834) = g_833;
                    l_835 = (void*)0;
                    l_861 = ((float)((float)(-0x2.8p-1) / (float)(0x1.263E75p-18 >= ((float)((l_842 = &g_125) != (void*)0) + (float)(-(float)((float)(-(float)((float)((p_8 <= (((*l_849) = (void*)0) != (void*)0)) <= (+((((((0xA.F644E1p+79 < (l_832 = ((float)((((*l_860) = l_856) != &l_857) > l_823) * (float)0x4.3p+1))) >= p_9) >= (-0x1.3p+1)) < 0xD.AC4773p+12) < p_9) > (**l_834)))) - (float)p_9)) - (float)0x3.B5120Bp-87))))) + (float)p_9);
                }
                l_802 = (*g_833);
                for (l_861 = 0; (l_861 >= 53); l_861 += 1)
                { /* block id: 440 */
                    if (l_829)
                        break;
                    l_802 = ((uint16_t)((*l_842) = 0xB5AFL) << (uint16_t)p_9);
                    if (p_9)
                        continue;
                }
                g_722 = ((float)0x0.197E64p+59 + (float)((*l_810) = (p_6 >= p_9)));
            }
            return &g_377;
        }
        l_802 = ((float)(p_8 > ((*l_870) = 0x1.Dp+1)) - (float)(+((float)l_802 + (float)(((float)((p_6 > 0x1.DAE795p+22) >= (g_36 >= 0x9.F220C2p+51)) * (float)((*l_876) = p_8)) != ((*g_524) != l_877)))));
    }
    l_897 = ((int32_t)((*l_896) = (~((uint16_t)(1UL == ((p_6 != l_823) != (l_823 < ((((****g_349) = (!((l_888 != (void*)0) > 0x85C8L))) != ((int16_t)(l_829 = (!l_829)) >> (int16_t)((*l_895) = ((**l_857) = ((((uint64_t)((l_823 | 18446744073709551607UL) ^ l_894) % (uint64_t)l_894) & p_9) && 4294967294UL))))) > p_8)))) << (uint16_t)l_894))) % (int32_t)0x4B82A37BL);
    return &g_13;
}


/* ------------------------------------------ */
/* 
 * reads : g_524 g_525 g_158 g_2 g_11 g_86
 * writes: g_289 g_646 g_87
 */
inline static uint32_t  func_15(int32_t * p_16, uint32_t  p_17, uint64_t  p_18)
{ /* block id: 396 */
    uint64_t ***l_769 = (void*)0;
    uint16_t *l_779 = &g_724;
    uint16_t **l_778 = &l_779;
    uint16_t ***l_777 = &l_778;
    const uint16_t *l_782 = &g_125;
    const uint16_t **l_781 = &l_782;
    const uint16_t ***l_780 = &l_781;
    int32_t l_789 = (-3L);
    const float *l_793 = &g_372;
    const float **l_792 = &l_793;
    const float ***l_791 = &l_792;
    const float ****l_790 = &l_791;
    float *l_794 = (void*)0;
    float *l_795 = &g_646;
    (*l_795) = ((float)(((**g_524) = l_769) != l_769) * (float)(((float)((float)g_158 + (float)(((float)((!((l_777 == l_780) != ((float)(((((float)((float)(((l_789 <= ((((l_790 == (void*)0) < l_789) < l_789) >= l_789)) < p_17) > l_789) + (float)p_18) * (float)g_2) == (-0x9.3p-1)) >= 0xF.8543CEp-80) <= 0xF.5D950Ep-20) / (float)p_17))) != 0x4.916189p-60) + (float)p_18) == l_789)) - (float)0x5.B7A8F9p-13) != g_11));
    (*g_86) = &l_789;
    return p_17;
}


/* ------------------------------------------ */
/* 
 * reads : g_741 g_36
 * writes: g_347 g_11 g_287
 */
static uint64_t  func_19(int32_t * p_20, uint64_t  p_21)
{ /* block id: 389 */
    int32_t *****l_743 = &g_742;
    const float *l_752 = &g_11;
    const float **l_751 = &l_752;
    const float ***l_750 = &l_751;
    struct S0 *l_756 = &g_42;
    struct S0 * const *l_755 = &l_756;
    struct S0 * const **l_754 = &l_755;
    struct S0 * const ***l_753 = &l_754;
    uint64_t l_763 = 0UL;
    float *l_764 = &g_347;
    float *l_765 = &g_11;
    struct S0 ** const **l_766 = &g_287;
    l_743 = g_741;
    (*l_765) = (((float)((float)((((0x1.5p+1 == ((float)(l_750 == (void*)0) * (float)p_21)) == 0x1.Cp+1) > ((l_753 = l_753) == &l_754)) <= ((float)((float)((*l_764) = ((float)0x1.78D535p+72 * (float)((p_21 != l_763) == 0x1.Dp-1))) / (float)0x7.D7A2C6p-26) / (float)0x3.0C2D0Ep+80)) - (float)p_21) / (float)l_763) == g_36);
    (*l_766) = &g_288;
    return p_21;
}


/* ------------------------------------------ */
/* 
 * reads : g_42 g_36 g_86 g_87 g_85 g_2 g_33 g_650 g_64 g_680 g_11 g_725
 * writes: g_36 g_87 g_11 g_158 g_377 g_125 g_724 g_650 g_737
 */
static int32_t * func_22(int16_t  p_23, const uint16_t  p_24)
{ /* block id: 6 */
    int32_t *l_48 = &g_2;
    struct S0 l_651 = {1891,-103,61,87,26,198,83,-44,0,-0};
    int32_t ***l_735 = (void*)0;
    int32_t ****l_736 = &l_735;
    int32_t *l_738 = &g_377;
    int32_t **l_739 = &l_48;
    (*g_86) = func_37(g_42, (-(uint32_t)func_44(p_23, l_48, l_48)), l_651, (*l_48));
    g_737 = ((*l_736) = l_735);
    (*g_86) = (void*)0;
    (*l_739) = ((*g_86) = l_738);
    return (**g_85);
}


/* ------------------------------------------ */
/* 
 * reads : g_33 g_650 g_36 g_64 g_680 g_86 g_11 g_87 g_725
 * writes: g_11 g_36 g_158 g_377 g_87 g_125 g_724 g_650
 */
static int32_t * func_37(struct S0  p_38, uint32_t  p_39, struct S0  p_40, uint32_t  p_41)
{ /* block id: 337 */
    int64_t l_652 = 0x387E986DF14231C8LL;
    float *l_653 = &g_11;
    struct S0 *l_697 = (void*)0;
    uint16_t *l_719 = (void*)0;
    int32_t **l_728 = &g_87;
    (*l_653) = l_652;
    if (((!g_33) > g_650))
    { /* block id: 339 */
        int32_t l_661 = 0x67E48F12L;
        int16_t l_669 = 1L;
        int32_t l_688 = (-2L);
        int32_t *l_702 = &g_2;
        int32_t **l_701 = &l_702;
        int16_t *l_714 = &g_64;
        int16_t *****l_717 = (void*)0;
        uint16_t *l_720 = (void*)0;
        uint16_t *l_721 = (void*)0;
        uint16_t *l_723 = &g_724;
        float ***l_727 = (void*)0;
        float ****l_726 = &l_727;
        for (g_36 = 0; (g_36 >= 26); g_36 += 1)
        { /* block id: 342 */
            int32_t l_670 = 0x1C60D8EEL;
            uint64_t *****l_685 = &g_525;
            if ((((int64_t)0xA105E991380E6533LL + (int64_t)((uint64_t)0x283DA6919E9BAAB2LL - (uint64_t)l_661)) != 0x5FBFECCAL))
            { /* block id: 343 */
                float *l_677 = &g_158;
                float l_681 = 0x1.Fp-1;
                uint64_t *****l_684 = (void*)0;
                int32_t l_689 = 0x3810E5A7L;
                int32_t *l_690 = &g_377;
                (*l_677) = ((float)(+((float)((float)(&g_85 != (void*)0) / (float)((*l_653) = (l_669 <= l_670))) - (float)((float)(-0x9.Bp+1) * (float)((l_661 > g_64) > (0x7.71EE5Ap-79 >= ((float)((float)0xB.AD172Bp-35 / (float)(-0x10.5p+1)) + (float)0x0.Dp-1)))))) + (float)0x1.CAAB75p+60);
                (*l_677) = ((float)(g_680 != (void*)0) / (float)((void*)0 != &p_38));
                l_689 = ((l_670 ^ ((uint64_t)p_39 + (uint64_t)((l_685 = (l_684 = &g_525)) != &g_525))) ^ (l_688 = (p_40.f7 > ((int32_t)p_38.f2 / (int32_t)(p_40.f4 ^ 0xFA5466D1BCE73445LL)))));
                (*l_690) = (p_38.f7 = p_38.f4);
            }
            else
            { /* block id: 353 */
                float *l_694 = &g_11;
                float **l_693 = &l_694;
                p_38.f1 = p_41;
                if (((uint16_t)(l_653 == ((*l_693) = l_653)) / (uint16_t)((uint32_t)0xEF5D9433L - (uint32_t)0x45B80AEDL)))
                { /* block id: 356 */
                    struct S0 *l_699 = &g_42;
                    struct S0 **l_698 = &l_699;
                    int32_t *l_700 = &l_688;
                    (*l_698) = (l_697 = l_697);
                    l_700 = &l_688;
                }
                else
                { /* block id: 360 */
                    return l_694;
                }
            }
        }
        (*l_701) = ((*g_86) = l_653);
        (**g_86) = (((**l_701) != ((void*)0 == &g_395)) > (!(((*l_723) = (g_125 = (((uint16_t)g_64 >> (uint16_t)13) ^ ((uint16_t)((uint16_t)(((int16_t)(((uint32_t)(l_714 == &l_669) / (uint32_t)(((int32_t)(((void*)0 != l_717) <= (~((l_720 = l_719) != &g_125))) + (int32_t)0L) && 0x24ECL)) ^ 1UL) + (int16_t)l_652) >= p_39) / (uint16_t)l_652) / (uint16_t)p_40.f3)))) <= (**l_701))));
        (*l_726) = g_725;
    }
    else
    { /* block id: 372 */
        int32_t * const l_729 = (void*)0;
        int32_t **l_730 = &g_87;
        l_728 = l_728;
        (*l_730) = l_729;
    }
    for (g_650 = (-6); (g_650 >= 40); g_650++)
    { /* block id: 378 */
        uint32_t ***l_734 = &g_680;
        uint32_t ****l_733 = &l_734;
        (*l_733) = &g_680;
    }
    return (*l_728);
}


/* ------------------------------------------ */
/* 
 * reads : g_36 g_86 g_87 g_85
 * writes: g_36 g_87
 */
inline static uint32_t  func_44(uint16_t  p_45, int32_t * p_46, int32_t * p_47)
{ /* block id: 7 */
    int16_t l_51 = 0L;
    int32_t l_274 = (-2L);
    uint64_t **l_291 = (void*)0;
    uint64_t ***l_290 = &l_291;
    int32_t ***l_292 = &g_86;
    int16_t *****l_409 = (void*)0;
    uint16_t **l_473 = (void*)0;
    int32_t l_537 = 0xF21CDF8CL;
    uint64_t *****l_575 = &g_525;
    for (g_36 = (-1); (g_36 > 49); g_36 += 8)
    { /* block id: 10 */
        int16_t *l_56 = &l_51;
        int32_t *l_65 = &g_2;
        uint64_t *l_275 = (void*)0;
        uint64_t *l_276 = &g_277;
        uint64_t *l_278 = &g_82;
        int32_t l_396 = (-1L);
        int16_t ***** const l_437 = &g_349;
        uint64_t *****l_526 = &g_525;
        float l_544 = 0xB.B225CAp+29;
        int16_t *****l_546 = &g_349;
        int32_t ****l_557 = &l_292;
        struct S0 *l_580 = &g_42;
        int32_t *l_606 = (void*)0;
        l_51 = 0L;
    }
    (**g_85) = (*g_86);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads : g_2 g_42.f6 g_85 g_86 g_87 g_42.f2 g_64 g_92 g_63 g_82 g_42.f7 g_125 g_33 g_36 g_158 g_42.f0 g_42.f9 g_42.f8
 * writes: g_82 g_92 g_87 g_86 g_64 g_125 g_11 g_158 g_63
 */
static int16_t  func_59(int16_t * p_60, int32_t * p_61, int32_t * p_62)
{ /* block id: 13 */
    int64_t l_66 = 0x4A13735CA718BA30LL;
    int32_t *l_67 = &g_2;
    const struct S0 l_71 = {2459,-23,40,1078,83,36,110,30,0,-2};
    uint64_t *l_104 = &g_82;
    uint64_t *l_106 = &g_82;
    int64_t l_120 = (-1L);
    uint16_t l_131 = 0UL;
    float l_160 = 0x7.20EA90p+71;
    uint64_t ** const *l_247 = (void*)0;
    int16_t l_271 = (-9L);
    if (((*p_62) == ((l_66 >= (l_67 != (void*)0)) & (((1UL && 1L) == (*l_67)) || func_68(l_71, (!g_42.f6))))))
    { /* block id: 23 */
        int32_t l_93 = 0L;
        int32_t l_94 = 0x60D0C570L;
        uint64_t **l_105 = &l_104;
        uint64_t *l_107 = &g_82;
        int32_t *l_108 = &g_92;
        (*g_85) = (void*)0;
        (*l_108) = (((l_94 = l_93) & (*p_62)) ^ ((&p_61 == ((*g_85) = &p_61)) | ((uint16_t)(((uint64_t)((uint16_t)(((*l_107) = ((~((void*)0 == l_67)) <= (l_93 != (((uint16_t)(((*l_105) = l_104) != (l_106 = l_106)) << (uint16_t)3) ^ l_93)))) > g_42.f2) << (uint16_t)4) + (uint64_t)18446744073709551615UL) == (*p_60)) * (uint16_t)(*l_67))));
        (**g_85) = (void*)0;
        (*l_108) = ((*p_60) == 0L);
    }
    else
    { /* block id: 33 */
        int64_t l_123 = 0x83F02998B4E4A0A6LL;
        for (g_92 = 0; (g_92 < (-12)); g_92--)
        { /* block id: 36 */
            uint64_t *l_113 = (void*)0;
            int32_t l_127 = 0x17059363L;
            float *l_167 = &g_158;
            if ((*p_62))
                break;
            if (((int16_t)(*p_60) - (int16_t)((*g_63) < (-1L))))
            { /* block id: 38 */
                (**g_85) = p_62;
            }
            else
            { /* block id: 40 */
                uint16_t *l_124 = &g_125;
                int32_t l_126 = 1L;
                uint64_t l_128 = 0x127A50812B24AB74LL;
                uint64_t **l_164 = (void*)0;
                if ((((*g_63) = ((l_113 != l_113) <= ((void*)0 != &p_61))) < ((((((int16_t)((int16_t)(((uint16_t)(*l_67) * (uint16_t)((((l_120 != (((uint16_t)l_123 / (uint16_t)1UL) < (((((*l_124) = (*l_67)) == (-3L)) || 0xF42BE7AC75E1209ELL) < l_123))) <= l_126) | l_127) >= l_126)) && 0x62FE7C9D89B7A404LL) / (int16_t)0xBF5EL) >> (int16_t)13) | l_127) > (*g_87)) | 4294967292UL) > l_128)))
                { /* block id: 43 */
                    uint16_t l_159 = 0x2B7EL;
                    for (g_82 = 0; (g_82 > 33); g_82++)
                    { /* block id: 46 */
                        int32_t **l_148 = &g_87;
                        int32_t ***l_147 = &l_148;
                        float *l_156 = (void*)0;
                        float *l_157 = &g_11;
                        float *l_161 = &l_160;
                        if ((***g_85))
                            break;
                        if (l_131)
                            continue;
                        g_158 = ((*l_161) = ((((!(-0x9.Dp+1)) <= (((float)((((((float)(((float)0x1.1p-1 + (float)((float)((float)(0x1.Cp-1 != ((float)((float)(((*g_85) == ((*l_147) = (void*)0)) > ((float)((*l_157) = (+((float)(l_123 < ((((g_42.f7 < ((((float)l_127 + (float)(l_127 > g_64)) > g_125) > 0x3.FBB040p-99)) <= g_42.f2) <= g_125) < g_33)) * (float)g_36))) - (float)0x1.6p+1)) + (float)0x9.1E2934p-53) + (float)(-0x10.3p-1))) - (float)0xE.24790Dp+60) - (float)g_158)) < l_128) + (float)l_159) < l_160) >= g_64) == (*l_67)) == (*l_67)) * (float)g_42.f2) >= l_159)) > g_42.f6) > l_127));
                        return (*p_60);
                    }
                }
                else
                { /* block id: 55 */
                    uint64_t ***l_165 = &l_164;
                    for (g_125 = 0; (g_125 != 36); g_125 += 9)
                    { /* block id: 58 */
                        if ((*l_67))
                            break;
                        return (*g_63);
                    }
                    (*l_165) = l_164;
                    if (l_123)
                        continue;
                }
                if ((*l_67))
                    continue;
            }
            (*l_167) = ((g_42.f0 > (-(float)0x5.Cp+1)) > 0x2.DB7B90p+90);
        }
    }
    if ((*l_67))
    { /* block id: 70 */
        for (g_125 = 0; (g_125 < 43); ++g_125)
        { /* block id: 73 */
        }
        return (*p_60);
    }
    else
    { /* block id: 78 */
        uint64_t * const l_181 = &g_82;
        int32_t l_183 = 0xE310A61FL;
        int32_t l_187 = 2L;
        int16_t l_190 = 0L;
        int32_t *l_193 = &l_187;
        int16_t **l_212 = (void*)0;
        uint64_t ***l_249 = (void*)0;
        for (l_66 = 15; (l_66 > 25); ++l_66)
        { /* block id: 81 */
            uint16_t *l_182 = &l_131;
            int32_t l_184 = 0x6D8BF474L;
            int32_t *l_185 = (void*)0;
            int32_t *l_186 = &l_183;
            if ((((*l_67) <= ((uint16_t)(!(((-1L) <= (*p_60)) != ((*l_186) = ((int16_t)((int64_t)((uint32_t)((((void*)0 != l_181) & ((l_182 = p_60) == (void*)0)) == ((l_183 <= (*g_63)) || 0L)) % (uint32_t)l_184) + (int64_t)0xCB9547BAECA1BBDALL) >> (int16_t)6)))) / (uint16_t)(*l_67))) <= l_187))
            { /* block id: 84 */
                return (*l_67);
            }
            else
            { /* block id: 86 */
                for (l_131 = 8; (l_131 > 48); ++l_131)
                { /* block id: 89 */
                    return l_190;
                }
                if ((*p_62))
                    break;
            }
            (*l_186) = (g_42.f9 & ((*l_67) == 0x6BB93CCAL));
            (*l_186) = (((int16_t)(*g_63) + (int16_t)(*g_63)) || (-9L));
            return (*g_63);
        }
        if (((*l_193) = (*p_62)))
        { /* block id: 99 */
            uint32_t l_194 = 8UL;
            int32_t l_216 = 0L;
            int64_t *l_230 = (void*)0;
            int64_t *l_231 = (void*)0;
            int64_t *l_232 = &l_120;
            if (l_194)
            { /* block id: 100 */
                int64_t l_195 = 0xC77FF3C2B3F84D8DLL;
                (*g_86) = p_62;
                l_195 = (*l_193);
                return (*g_63);
            }
            else
            { /* block id: 104 */
                uint32_t l_196 = 3UL;
                float *l_197 = (void*)0;
                float *l_198 = &g_158;
                (*l_198) = l_196;
                (*g_86) = (*g_86);
                if (((int16_t)((l_198 != p_61) && (l_194 | ((int16_t)(*p_60) * (int16_t)(((int16_t)((*l_67) ^ ((void*)0 == l_193)) >> (int16_t)((~(&g_64 != (void*)0)) >= g_64)) == g_92)))) + (int16_t)(*l_67)))
                { /* block id: 107 */
                    int16_t *l_206 = &l_190;
                    int16_t **l_207 = (void*)0;
                    int16_t **l_208 = &l_206;
                    const int16_t *l_210 = &g_211;
                    const int16_t **l_209 = &l_210;
                    if ((((g_63 = ((*l_208) = l_206)) != ((*l_209) = (void*)0)) >= l_196))
                    { /* block id: 111 */
                        return l_196;
                    }
                    else
                    { /* block id: 113 */
                        int16_t ***l_213 = &l_207;
                        (*l_213) = l_212;
                    }
                }
                else
                { /* block id: 116 */
                    return (*p_60);
                }
            }
            l_216 = ((uint64_t)(*l_193) % (uint64_t)l_194);
            (*l_193) = (!(((int16_t)((0x3D7E0BF0L | ((uint64_t)((int16_t)((*p_60) = ((int16_t)((uint32_t)((l_216 < (l_67 != (**g_85))) ^ 0L) - (uint32_t)((~(-(int16_t)(*l_193))) <= (((((((*l_232) = (*l_193)) && (((*l_193) && (*l_67)) <= (-6L))) || (*l_67)) && (*l_193)) & 1UL) < (*p_60)))) << (int16_t)13)) * (int16_t)l_216) / (uint64_t)(*l_67))) || 0x691CFF77550297C0LL) >> (int16_t)0) == 0UL));
        }
        else
        { /* block id: 124 */
            uint16_t l_264 = 6UL;
            int32_t l_270 = 1L;
            for (l_187 = 18; (l_187 <= 13); --l_187)
            { /* block id: 127 */
                int32_t *l_235 = (void*)0;
                l_235 = ((**g_85) = (**g_85));
            }
            if (((-1L) <= g_42.f8))
            { /* block id: 131 */
                for (g_64 = (-19); (g_64 != (-21)); g_64 -= 2)
                { /* block id: 134 */
                    if ((*l_67))
                    { /* block id: 135 */
                        return (*g_63);
                    }
                    else
                    { /* block id: 137 */
                        return (*g_63);
                    }
                }
                for (g_64 = 10; (g_64 < 20); g_64 += 1)
                { /* block id: 143 */
                    uint16_t l_240 = 65532UL;
                    l_240 = 0x278E0849L;
                    for (g_82 = 9; (g_82 >= 50); ++g_82)
                    { /* block id: 147 */
                        struct S0 *l_244 = &g_42;
                        struct S0 **l_243 = &l_244;
                        if (l_240)
                            break;
                        (*l_243) = (void*)0;
                    }
                    (*l_193) = 0x94845B68L;
                    if ((*p_62))
                        continue;
                }
            }
            else
            { /* block id: 154 */
                uint64_t ** const **l_248 = &l_247;
                uint64_t ****l_250 = &l_249;
                int32_t **l_261 = &l_193;
                float l_262 = (-0x1.Cp-1);
                int16_t l_263 = 0x9E99L;
                float *l_265 = &l_160;
                struct S0 *l_267 = &g_42;
                struct S0 **l_266 = &l_267;
                int16_t ***l_268 = (void*)0;
                int16_t ***l_269 = &l_212;
                (*l_265) = ((*l_67) == ((float)(((*l_248) = l_247) == ((*l_250) = l_249)) / (float)(((float)0x2.9p-1 - (float)(((g_42.f2 >= ((float)((float)((float)(((float)g_42.f2 + (float)(((*l_261) = ((*g_86) = (**g_85))) != (void*)0)) > g_42.f2) / (float)l_262) + (float)l_263) - (float)(*l_67))) >= 0x8.1p-1) <= l_264)) != (*l_67))));
                (*l_266) = (void*)0;
                (*l_269) = &g_63;
            }
            (**g_85) = (*g_86);
            l_270 = (*l_67);
        }
        (*g_86) = p_62;
        p_62 = (void*)0;
    }
    return l_271;
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_2 g_86 g_87
 * writes: g_82 g_92 g_87
 */
static int16_t  func_68(const struct S0  p_69, uint64_t  p_70)
{ /* block id: 14 */
    int32_t *l_80 = &g_2;
    uint64_t *l_81 = &g_82;
    int32_t ***l_89 = &g_86;
    int32_t *l_90 = (void*)0;
    int32_t *l_91 = &g_92;
    (*l_91) = ((int32_t)func_75(p_69.f9, &g_64, l_80, ((*l_81) = 0xD9E1B0F05BA845DBLL)) - (int32_t)((void*)0 == l_89));
    (**g_85) = (*g_86);
    return p_69.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_2
 * writes:
 */
inline static int32_t  func_75(int16_t  p_76, int16_t * p_77, int32_t * p_78, uint64_t  p_79)
{ /* block id: 16 */
    int32_t *l_84 = &g_2;
    int32_t **l_83 = &l_84;
    int32_t ***l_88 = &l_83;
    (*l_83) = &g_2;
    l_88 = g_85;
    return (*p_78);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_2, "g_2", print_hash_value);
    transparent_crc_bytes (&g_11, sizeof(g_11), "g_11", print_hash_value);
    transparent_crc(g_13, "g_13", print_hash_value);
    transparent_crc(g_33, "g_33", print_hash_value);
    transparent_crc(g_36, "g_36", print_hash_value);
    transparent_crc(g_42.f0, "g_42.f0", print_hash_value);
    transparent_crc(g_42.f1, "g_42.f1", print_hash_value);
    transparent_crc(g_42.f2, "g_42.f2", print_hash_value);
    transparent_crc(g_42.f3, "g_42.f3", print_hash_value);
    transparent_crc(g_42.f4, "g_42.f4", print_hash_value);
    transparent_crc(g_42.f5, "g_42.f5", print_hash_value);
    transparent_crc(g_42.f6, "g_42.f6", print_hash_value);
    transparent_crc(g_42.f7, "g_42.f7", print_hash_value);
    transparent_crc(g_42.f8, "g_42.f8", print_hash_value);
    transparent_crc(g_42.f9, "g_42.f9", print_hash_value);
    transparent_crc(g_64, "g_64", print_hash_value);
    transparent_crc(g_82, "g_82", print_hash_value);
    transparent_crc(g_92, "g_92", print_hash_value);
    transparent_crc(g_125, "g_125", print_hash_value);
    transparent_crc_bytes (&g_158, sizeof(g_158), "g_158", print_hash_value);
    transparent_crc(g_211, "g_211", print_hash_value);
    transparent_crc(g_277, "g_277", print_hash_value);
    transparent_crc_bytes (&g_347, sizeof(g_347), "g_347", print_hash_value);
    transparent_crc_bytes (&g_372, sizeof(g_372), "g_372", print_hash_value);
    transparent_crc(g_377, "g_377", print_hash_value);
    transparent_crc(g_395, "g_395", print_hash_value);
    transparent_crc(g_400, "g_400", print_hash_value);
    transparent_crc(g_430, "g_430", print_hash_value);
    transparent_crc(g_520, "g_520", print_hash_value);
    transparent_crc(g_591, "g_591", print_hash_value);
    transparent_crc_bytes (&g_646, sizeof(g_646), "g_646", print_hash_value);
    transparent_crc(g_650, "g_650", print_hash_value);
    transparent_crc_bytes (&g_722, sizeof(g_722), "g_722", print_hash_value);
    transparent_crc(g_724, "g_724", print_hash_value);
    transparent_crc(g_852, "g_852", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 176
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 10
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 3
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 13
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 0
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 9
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 47

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 156
   depth: 2, occurrence: 32
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 4
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 287

XXX times a variable address is taken: 250
XXX times a pointer is dereferenced on RHS: 118
breakdown:
   depth: 1, occurrence: 102
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 4, occurrence: 0
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 158
breakdown:
   depth: 1, occurrence: 144
   depth: 2, occurrence: 13
   depth: 3, occurrence: 0
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 31
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 883

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 472
   level: 2, occurrence: 111
   level: 3, occurrence: 109
   level: 4, occurrence: 26
   level: 5, occurrence: 26
XXX number of pointers point to pointers: 128
XXX number of pointers point to scalars: 148
XXX number of pointers point to structs: 11
XXX percent of pointers has null in alias set: 30.7
XXX average alias set size: 1.18

XXX times a non-volatile is read: 744
XXX times a non-volatile is write: 437
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 147
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 23
   depth: 2, occurrence: 21
   depth: 3, occurrence: 28
   depth: 4, occurrence: 23
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 19.6
XXX percentage an existing variable is used: 80.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

