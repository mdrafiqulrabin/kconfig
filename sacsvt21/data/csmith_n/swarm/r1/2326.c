/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --float --no-math64 --inline-function --no-muls --safe-math --packed-struct --paranoid --no-pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      385688836
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   float  f0;
};

#pragma pack(push)
#pragma pack(1)
struct S1 {
   int8_t  f0;
   float  f1;
   int8_t  f2;
   uint16_t  f3;
   struct S0  f4;
   const uint32_t  f5;
   uint32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_28(void);
static struct S0  func_29(uint32_t  p_30, const uint8_t  p_31, const int32_t  p_32, uint16_t  p_33);
inline static int8_t  func_36(struct S0  p_37, struct S1  p_38);
inline static struct S0  func_39(struct S1  p_40, int16_t  p_41, struct S0  p_42, uint32_t  p_43, int8_t  p_44);
static uint8_t  func_50(uint16_t  p_51, const float  p_52, struct S0  p_53, int8_t  p_54, uint32_t  p_55);
inline static uint8_t  func_56(uint32_t  p_57, struct S1  p_58);
inline static struct S1  func_61(int32_t  p_62);
static uint8_t  func_81(const int32_t  p_82, int32_t  p_83, float  p_84, int32_t  p_85);
inline static float  func_89(uint32_t  p_90, int32_t  p_91);
static float  func_98(int32_t  p_99, float  p_100, int32_t  p_101);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_28(void)
{ /* block id: 36 */
    uint32_t l_34 = 0x7919ADB8L;
    int32_t l_35 = 7L;
    struct S1 l_244 = {0x40L,0xD.225E0Fp-70,0x18L,0x9A6AL,{-0x3.Dp-1},0x1A5E322CL,1UL};
    uint16_t l_254 = 0x0904L;
    uint32_t l_401 = 0xB95090B8L;
    struct S1 l_443 = {0xE3L,-0x6.1p-1,0L,0x919BL,{-0x3.3p-1},0x62305BAEL,4294967292UL};
    int8_t l_494 = 0x2EL;
    int8_t l_497 = 0x47L;
    l_244.f4 = func_29((__builtin_ffsll(l_34) == l_35), l_34, (func_36(func_39(((safe_add_func_uint8_t_u_u(__builtin_bswap64((~(safe_rshift_func_uint16_t_u_u((((func_50((__builtin_parityl(l_35) == func_56((safe_rshift_func_uint16_t_u_s((((func_61(l_34) , l_35) , 0xBBL) >= l_34), 3)), l_244)), l_244.f6, l_244.f4, l_254, l_244.f3) == l_244.f2) > l_244.f3) > l_34), 8)))), l_244.f2)) , l_244), l_244.f0, l_244.f4, l_244.f0, l_35), l_244) , l_35), l_254);
    if ((l_35 != (!(((safe_lshift_func_uint16_t_u_s(((safe_mod_func_int8_t_s_s((((0x00L | l_244.f3) == (l_244.f2 >= (safe_add_func_uint16_t_u_u((l_244.f4 , ((l_254 <= l_244.f2) , (l_35 != l_244.f0))), l_244.f0)))) , l_244.f6), 0xE8L)) ^ l_401), 5)) & l_254) , l_244.f6))))
    { /* block id: 154 */
        int8_t l_406 = 0xEFL;
        struct S0 l_419 = {0x0.Ep+1};
        int32_t l_425 = (-1L);
        int32_t l_428 = 0x7B5A5742L;
        const float l_441 = 0x1.Bp+1;
lbl_409:
        l_35 = (safe_add_func_uint32_t_u_u(l_244.f6, (0xEFL > (safe_lshift_func_int16_t_s_u(l_406, 11)))));
lbl_459:
        for (l_244.f6 = 0; (l_244.f6 > 47); l_244.f6 = safe_add_func_uint32_t_u_u(l_244.f6, 1))
        { /* block id: 158 */
            uint32_t l_410 = 8UL;
            uint32_t l_415 = 0x847B739BL;
            if (l_401)
                goto lbl_409;
            l_244.f4 = func_39(l_244, l_410, func_29((safe_rshift_func_uint16_t_u_u((0xEC22L ^ (safe_rshift_func_uint16_t_u_u(l_406, 4))), l_415)), l_410, l_406, l_406), l_415, l_244.f2);
        }
        for (l_244.f2 = (-29); (l_244.f2 >= (-21)); l_244.f2 = safe_add_func_uint32_t_u_u(l_244.f2, 1))
        { /* block id: 164 */
            struct S0 l_418 = {0x8.418BB6p+3};
            int32_t l_422 = 0xFC3E2CE9L;
            uint32_t l_449 = 0xE70864A0L;
            int32_t l_470 = 0L;
            l_419 = l_418;
            l_422 = (safe_add_func_float_f_f(l_406, (l_422 > ((l_35 , 0xC.8773EDp-23) >= (safe_div_func_float_f_f((((l_425 <= l_244.f2) != l_422) != l_401), 0x1.A96D1Dp-17))))));
            if (l_425)
                continue;
            for (l_425 = 8; (l_425 < 19); l_425 = safe_add_func_int8_t_s_s(l_425, 7))
            { /* block id: 170 */
                uint16_t l_431 = 0UL;
                struct S0 l_455 = {0x0.0p+1};
                l_428 = 0xB9196929L;
                if ((safe_lshift_func_uint16_t_u_u((((l_431 , (!(safe_add_func_int8_t_s_s((safe_div_func_int16_t_s_s(((l_244.f3 && ((l_431 <= (-1L)) && (safe_add_func_int8_t_s_s((0x65E6L <= l_422), (((safe_add_func_uint8_t_u_u((l_422 < l_431), (~((l_422 == l_244.f2) <= 0xE4L)))) == l_244.f2) < (-5L)))))) , l_422), l_406)), l_422)))) >= 65531UL) == l_431), l_425)))
                { /* block id: 172 */
                    uint16_t l_454 = 1UL;
                    l_455 = func_39(func_61((l_406 & l_431)), l_425, l_418, (((l_443 , (safe_rshift_func_int16_t_s_s(l_422, 4))) > (((safe_unary_minus_func_int32_t_s((safe_lshift_func_uint16_t_u_s(l_449, (((safe_div_func_uint8_t_u_u((safe_rshift_func_int16_t_s_u((l_454 & l_401), l_406)), l_449)) | l_431) , l_454))))) | 0xE7B7L) >= 0x9CE596C8L)) >= l_425), l_425);
                }
                else
                { /* block id: 174 */
                    for (l_443.f2 = 29; (l_443.f2 <= 4); l_443.f2 = safe_sub_func_uint32_t_u_u(l_443.f2, 7))
                    { /* block id: 177 */
                        int32_t l_458 = 0xBDBF143CL;
                        if (l_422)
                            break;
                        l_428 = l_425;
                        return l_458;
                    }
                }
                if (l_406)
                    goto lbl_459;
                l_470 = ((safe_lshift_func_int8_t_s_s((l_449 < (l_35 > (((((((safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s(((safe_sub_func_float_f_f((l_470 == l_406), l_425)) , (l_244.f5 , 65529UL)), 14)), (7L < ((!((safe_div_func_uint32_t_u_u((safe_mod_func_int32_t_s_s((l_449 , 0xA2760B0BL), 0x22F24E1AL)), l_443.f5)) < 0xD1B52101L)) & l_431)))) || l_431) , l_34) & l_244.f2) ^ 0x2A5E24A8L) , 0x91L) > l_431))), l_244.f3)) != 0x98L);
            }
        }
        l_419 = l_419;
    }
    else
    { /* block id: 188 */
        int32_t l_482 = 0x508C173DL;
        uint16_t l_493 = 0xFDABL;
        uint32_t l_495 = 0x1DA92B66L;
        struct S0 l_496 = {0x4.8BF5B4p+48};
        l_35 = (safe_sub_func_float_f_f((safe_add_func_float_f_f(((((0UL <= (safe_sub_func_int8_t_s_s(l_482, (((safe_mod_func_uint8_t_u_u(((safe_add_func_int32_t_s_s(((safe_lshift_func_int16_t_s_s(0xF246L, 6)) != 6L), ((safe_add_func_uint32_t_u_u((safe_add_func_uint32_t_u_u((0x25L <= func_50(l_34, (l_482 , l_244.f2), func_29(l_443.f6, l_482, l_244.f2, l_244.f2), l_482, l_443.f0)), 4294967292UL)), l_493)) >= l_443.f6))) == l_401), 0xCAL)) || l_493) < l_482)))) > 0xB2E0L) , l_493) != l_482), l_482)), 0x0.61D666p+2));
        l_496 = func_29(l_494, __builtin_bswap32(l_495), l_482, l_482);
        return l_482;
    }
    l_35 = (__builtin_popcount(l_34) < ((l_254 <= l_244.f5) <= l_497));
    return l_443.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_29(uint32_t  p_30, const uint8_t  p_31, const int32_t  p_32, uint16_t  p_33)
{ /* block id: 137 */
    uint16_t l_369 = 1UL;
    struct S1 l_370 = {-5L,0x7.Fp-1,0x59L,65532UL,{0x0.Bp+1},0xA4492F3AL,0xBD05B2C2L};
    int8_t l_375 = 1L;
    l_370.f4 = func_39((l_369 , (l_369 , l_370)), (safe_div_func_int32_t_s_s((safe_add_func_uint32_t_u_u(0x6A471C4FL, p_31)), l_370.f2)), l_370.f4, l_369, (((0L > p_31) > p_33) , l_375));
    for (l_370.f2 = (-10); (l_370.f2 <= (-12)); l_370.f2--)
    { /* block id: 141 */
        uint16_t l_387 = 0x88E5L;
        int32_t l_389 = 0x6ADAB575L;
        if ((((safe_add_func_uint16_t_u_u((((safe_lshift_func_int8_t_s_s(p_32, (safe_unary_minus_func_int16_t_s(((safe_sub_func_float_f_f((p_31 , (func_81(l_370.f0, p_32, p_33, (1UL == 0x92F8L)) > (safe_sub_func_float_f_f(((p_32 && l_387) , p_32), l_387)))), p_33)) , l_387))))) ^ 0x41L) && p_31), 65535UL)) && l_387) && 0x9BCACBB1L))
        { /* block id: 142 */
            struct S0 l_388 = {-0x6.Ep-1};
            if (p_30)
                break;
            l_388 = l_370.f4;
        }
        else
        { /* block id: 145 */
            float l_390 = (-0x1.Ep+1);
            struct S0 l_391 = {-0x4.0p-1};
            l_389 = l_375;
            l_389 = l_370.f2;
            l_370.f4 = (l_370.f2 , l_391);
        }
        if (p_30)
            break;
    }
    return l_370.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int8_t  func_36(struct S0  p_37, struct S1  p_38)
{ /* block id: 135 */
    uint32_t l_368 = 4294967295UL;
    return l_368;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_39(struct S1  p_40, int16_t  p_41, struct S0  p_42, uint32_t  p_43, int8_t  p_44)
{ /* block id: 133 */
    struct S0 l_367 = {0xD.19E3CEp-47};
    return l_367;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_50(uint16_t  p_51, const float  p_52, struct S0  p_53, int8_t  p_54, uint32_t  p_55)
{ /* block id: 102 */
    uint16_t l_265 = 0UL;
    int32_t l_290 = (-1L);
    struct S0 l_295 = {0xC.575F58p+26};
    const int8_t l_307 = 0xDAL;
    for (p_54 = 0; (p_54 > (-22)); p_54 = safe_sub_func_uint16_t_u_u(p_54, 9))
    { /* block id: 105 */
        float l_266 = 0x0.3p-1;
        int32_t l_267 = 0L;
        const uint32_t l_272 = 18446744073709551615UL;
        int32_t l_289 = 0x1352EBC1L;
        struct S0 l_302 = {0x3.0DAF64p+34};
        for (p_55 = 0; (p_55 != 16); p_55 = safe_add_func_uint16_t_u_u(p_55, 4))
        { /* block id: 108 */
            struct S1 l_273 = {0L,0xF.3E810Fp+86,9L,65528UL,{-0x10.Ap-1},0xFF738745L,0x188D95DDL};
            p_53.f0 = ((p_52 > func_56((((safe_add_func_uint32_t_u_u((safe_div_func_int8_t_s_s((((safe_add_func_uint16_t_u_u((((-1L) != p_55) | (0x51L >= l_265)), l_267)) && 4L) , (safe_sub_func_int16_t_s_s((safe_rshift_func_uint8_t_u_s((((((l_272 != __builtin_parityll(p_51)) < l_265) >= p_51) && l_272) && p_55), p_55)), l_265))), 3UL)), 0x97F5A8E2L)) ^ p_55) ^ 1UL), l_273)) >= 0x3.B3C7FFp+4);
            if (p_54)
                break;
            l_290 = ((safe_add_func_float_f_f(((safe_sub_func_float_f_f(((safe_rshift_func_int16_t_s_u(p_55, 6)) , ((safe_sub_func_float_f_f(((l_265 == (-((-0x1.Ap-1) <= (safe_add_func_float_f_f(((((safe_lshift_func_uint8_t_u_u(0xE5L, (l_273.f2 > (p_51 < (safe_sub_func_uint32_t_u_u(0x04DB0D09L, (1L <= l_273.f3))))))) ^ p_55) , p_54) != p_51), 0xA.081781p-86))))) < p_51), p_55)) > 0xB.32F726p-44)), p_55)) > l_272), p_53.f0)) > l_289);
            l_295 = (((safe_mod_func_int16_t_s_s((((p_51 || __builtin_ffsl((safe_div_func_int16_t_s_s((l_295 , (((safe_lshift_func_uint16_t_u_u(0x88B3L, 2)) <= (l_265 ^ (safe_lshift_func_int16_t_s_s(p_55, (0x78792005L || l_267))))) > ((0UL && (((safe_add_func_uint8_t_u_u(func_81((1L & p_55), p_51, l_273.f3, p_51), 0x72L)) || 0xDABBL) , 1L)) <= p_55))), p_55)))) , p_51) && p_51), p_55)) , 7UL) , p_53);
        }
        p_53.f0 = ((l_295 , (l_265 <= l_289)) >= 0x9.5p-1);
        if (p_55)
            break;
        l_302 = l_302;
    }
    if ((p_51 == (((((safe_mod_func_uint8_t_u_u((safe_div_func_uint16_t_u_u(0xD62FL, l_307)), (((0x69C0L ^ ((safe_mod_func_uint32_t_u_u(((safe_lshift_func_int16_t_s_u(func_81(l_265, l_307, l_265, (p_55 <= 0x9050L)), l_265)) ^ l_265), 8UL)) == 0x5473L)) , l_290) && p_51))) != 1UL) , p_51) ^ p_54) != l_265)))
    { /* block id: 118 */
        const float l_324 = 0x0.6p-1;
        int32_t l_325 = (-1L);
        struct S0 l_327 = {0x7.D8A9ABp-21};
        l_290 = ((((safe_sub_func_float_f_f(0xB.ADF907p-65, (safe_sub_func_float_f_f(p_54, 0xD.A6D678p+35)))) > (((safe_div_func_float_f_f((safe_sub_func_float_f_f((l_265 > __builtin_popcountll((0x8E5AL == 6L))), (((((((safe_lshift_func_uint8_t_u_s(__builtin_ia32_crc32qi((safe_sub_func_int8_t_s_s(p_51, 0L)), l_265), p_54)) , l_290) ^ p_55) | l_325) && 0x02L) , 0x3.8B8574p+15) == l_307))), p_51)) , l_265) == 0x5.A189BCp-84)) != l_325) <= 0xF.DF5632p+97);
        if (l_290)
            goto lbl_326;
lbl_326:
        p_53 = p_53;
        l_290 = l_307;
        l_327 = p_53;
    }
    else
    { /* block id: 124 */
        uint8_t l_336 = 0xF0L;
        int32_t l_345 = 0xBA8E6F8EL;
        struct S0 l_346 = {0x5.C07B78p-88};
        l_345 = (((safe_mod_func_uint32_t_u_u(((((p_53.f0 > ((safe_div_func_float_f_f((safe_sub_func_float_f_f((safe_div_func_float_f_f(l_336, (safe_add_func_float_f_f(p_51, 0x4.Ep-1)))), func_89((safe_add_func_uint16_t_u_u(((((((((safe_rshift_func_int8_t_s_s(l_290, 0)) || l_336) | (p_51 && ((safe_div_func_uint32_t_u_u((__builtin_bswap64(p_54) >= (-9L)), (-4L))) , l_290))) < p_55) == 1UL) == l_336) ^ 0x7AL) == p_55), (-4L))), p_55))), l_336)) != 0xE.F0A01Dp+9)) == (-0x5.Bp+1)) == p_53.f0) , 0x5D46D9FFL), 0x8B339EBDL)) , 0xA.51AF70p-83) != 0x9.4817D2p+98);
        l_345 = (l_346 , (l_290 | (safe_rshift_func_int16_t_s_u(__builtin_popcountl((p_53 , p_55)), 2))));
        p_53.f0 = l_345;
        p_53.f0 = (safe_sub_func_float_f_f(((safe_div_func_float_f_f((safe_add_func_float_f_f(0xD.3534EEp+97, (p_55 == l_336))), (safe_add_func_float_f_f((((safe_sub_func_float_f_f(p_53.f0, (l_336 < func_81(((((safe_add_func_uint8_t_u_u(p_55, ((safe_lshift_func_uint8_t_u_s(l_265, 1)) ^ (safe_rshift_func_int16_t_s_s((l_336 || (safe_rshift_func_int8_t_s_s(p_51, 2))), p_54))))) >= 1L) >= p_54) ^ p_54), p_55, l_307, p_51)))) < l_345) != l_345), p_54)))) <= l_336), 0x0.3p+1));
    }
    l_290 = func_81((((l_307 <= __builtin_popcountll(p_54)) > p_55) != l_265), p_54, l_290, l_290);
    p_53 = p_53;
    return l_290;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint8_t  func_56(uint32_t  p_57, struct S1  p_58)
{ /* block id: 98 */
    struct S1 l_245 = {0x29L,0xC.B660CBp-53,1L,1UL,{0x3.0C9D98p+42},18446744073709551608UL,5UL};
    int32_t l_253 = 1L;
    p_58.f4 = p_58.f4;
    l_253 = ((l_245 , ((__builtin_clz(l_245.f6) > ((safe_mod_func_int8_t_s_s(p_58.f5, (1UL && func_81(((safe_rshift_func_int16_t_s_u((safe_div_func_int32_t_s_s(1L, l_245.f3)), 7)) , ((~func_81(l_245.f0, l_245.f5, l_245.f2, l_245.f5)) != l_245.f5)), p_58.f2, p_58.f5, l_245.f6)))) > 9UL)) <= l_245.f5)) || p_58.f3);
    return l_245.f5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S1  func_61(int32_t  p_62)
{ /* block id: 37 */
    float l_136 = 0x1.Ep-1;
    int32_t l_137 = (-1L);
    int32_t l_177 = 5L;
    struct S0 l_183 = {-0x6.3p-1};
    float l_206 = 0xD.D848D3p-26;
    uint16_t l_232 = 65535UL;
    struct S1 l_243 = {0L,0x8.Cp-1,0L,65532UL,{0xF.B44B8Fp+79},0xA774E767L,0UL};
    for (p_62 = 0; (p_62 > (-19)); p_62 = safe_sub_func_int8_t_s_s(p_62, 4))
    { /* block id: 40 */
        int32_t l_65 = 0L;
        float l_80 = 0xD.7874D2p+16;
        int32_t l_152 = 0L;
        for (l_65 = 0; (l_65 >= 29); l_65 = safe_add_func_uint32_t_u_u(l_65, 5))
        { /* block id: 43 */
            int8_t l_88 = (-7L);
            l_152 = (safe_rshift_func_int8_t_s_s((safe_add_func_int16_t_s_s((safe_add_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((__builtin_clzl(l_65) , p_62), (safe_mod_func_uint32_t_u_u(0x7E7924A0L, ((((safe_mod_func_uint32_t_u_u(p_62, 4294967290UL)) < p_62) ^ (((func_81((safe_sub_func_int32_t_s_s(((l_88 >= func_89((((safe_add_func_uint16_t_u_u(1UL, p_62)) & p_62) >= 4294967294UL), p_62)) , 0L), l_137)), p_62, p_62, p_62) , l_65) == p_62) ^ l_88)) , l_88))))), 0x1D55L)), p_62)), p_62));
        }
    }
    if ((safe_div_func_int16_t_s_s(p_62, (safe_rshift_func_uint16_t_u_u(p_62, (!(safe_rshift_func_uint16_t_u_s(((!((((safe_rshift_func_uint8_t_u_u(p_62, 6)) <= (__builtin_ctzll(l_137) < p_62)) & ((safe_add_func_uint16_t_u_u(l_137, (p_62 < (__builtin_clzll((0x58D7L || 1L)) , p_62)))) , l_137)) & l_137)) > p_62), 0))))))))
    { /* block id: 67 */
        uint16_t l_167 = 0x5E2FL;
        int8_t l_168 = (-1L);
        l_137 = (((((-0x1.3p-1) != (((safe_add_func_float_f_f((l_167 >= (l_168 > 0x4.78930Fp-48)), (l_168 >= 0x9.9p+1))) <= (-(safe_sub_func_float_f_f(p_62, (l_137 != p_62))))) > 0x1.Cp+1)) <= (-0x9.Fp+1)) <= 0x0.8p+1) == p_62);
        l_137 = l_167;
    }
    else
    { /* block id: 70 */
        struct S1 l_178 = {-5L,0xB.DEC899p+24,-1L,1UL,{0x4.292C6Cp-36},0x747E018FL,5UL};
        for (l_137 = 29; (l_137 >= (-25)); l_137--)
        { /* block id: 73 */
            uint32_t l_176 = 0x3FE4262AL;
            l_176 = ((safe_sub_func_int8_t_s_s((p_62 > 4294967288UL), p_62)) , 0x5.7p-1);
            l_177 = (p_62 == l_137);
            return l_178;
        }
    }
    if (p_62)
    { /* block id: 79 */
        uint32_t l_179 = 0xF2F4379DL;
        const struct S1 l_184 = {1L,0xE.915FC1p-68,0L,0x1672L,{-0x3.7p-1},0x8CCFF5D3L,4294967295UL};
        int32_t l_207 = 0x3DE181DAL;
        uint16_t l_214 = 4UL;
        uint32_t l_235 = 0x377B0656L;
        struct S0 l_237 = {0xC.C30530p-47};
        p_62 = ((l_179 || (!l_137)) , (((((safe_div_func_uint32_t_u_u(((l_183 , ((((l_184 , (l_137 , (l_137 ^ __builtin_popcountll(p_62)))) != (((p_62 >= l_137) | l_137) , p_62)) & l_177) || p_62)) , 0x836BFEFFL), 0x72E7E9FBL)) >= l_177) < p_62) && l_137) || 1L));
        if (p_62)
        { /* block id: 81 */
            float l_193 = 0x4.AC108Ep+68;
            int32_t l_196 = 0x0B99AC91L;
            struct S0 l_197 = {0x2.4550C2p-69};
            l_196 = ((safe_rshift_func_int8_t_s_s((l_184 , 0xC0L), (safe_lshift_func_int8_t_s_u(0x61L, (safe_div_func_uint8_t_u_u((safe_lshift_func_uint8_t_u_u((p_62 , l_184.f6), 4)), l_137)))))) , (p_62 >= (safe_sub_func_float_f_f((((__builtin_ctzl(p_62) < (-0x7.Dp+1)) == p_62) >= p_62), p_62))));
            l_197 = l_183;
            l_207 = (safe_div_func_int16_t_s_s((safe_sub_func_uint8_t_u_u(func_81((__builtin_ffs(p_62) != p_62), func_81(p_62, __builtin_ffs(l_184.f3), ((safe_sub_func_float_f_f(l_184.f6, l_196)) < ((((((((safe_sub_func_uint16_t_u_u(__builtin_parity(p_62), p_62)) != p_62) != l_196) == p_62) , p_62) > (-0x1.3p+1)) == p_62) == l_177)), l_179), p_62, p_62), 0x00L)), 0xA461L));
        }
        else
        { /* block id: 85 */
            float l_216 = (-0x1.3p-1);
            int32_t l_219 = 7L;
            int32_t l_220 = (-1L);
            int16_t l_221 = 0x1BDEL;
            p_62 = (safe_div_func_int32_t_s_s(func_81((safe_div_func_uint16_t_u_u((l_184.f3 == ((p_62 || (safe_lshift_func_uint16_t_u_u(((func_81(func_81((((l_214 >= (p_62 >= (__builtin_clzl(l_184.f5) ^ (((safe_unary_minus_func_int32_t_s(l_137)) || (safe_rshift_func_int8_t_s_u(l_219, l_220))) && l_184.f0)))) != l_137) | 0L), l_137, p_62, p_62), l_184.f6, l_184.f2, p_62) <= p_62) != 5UL), p_62))) > 0xA4L)), l_184.f6)), p_62, p_62, l_221), l_137));
        }
        if ((safe_add_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s((p_62 >= (((l_184.f4 , ((__builtin_ffsll((safe_div_func_uint8_t_u_u((safe_lshift_func_uint16_t_u_s((safe_div_func_uint32_t_u_u(p_62, l_232)), 6)), 7L))) && l_184.f6) || l_184.f2)) ^ ((safe_rshift_func_int8_t_s_s(l_177, l_177)) | 8UL)) || l_235)), 11)), 8UL)))
        { /* block id: 88 */
            struct S0 l_236 = {0x8.5p-1};
            l_237 = l_236;
        }
        else
        { /* block id: 90 */
            l_137 = (safe_mod_func_int32_t_s_s(l_184.f5, p_62));
        }
    }
    else
    { /* block id: 93 */
        uint8_t l_242 = 0xC8L;
        l_242 = (l_137 < (!(!l_177)));
    }
    p_62 = p_62;
    return l_243;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_81(const int32_t  p_82, int32_t  p_83, float  p_84, int32_t  p_85)
{ /* block id: 56 */
    const float l_142 = 0x9.62DC17p-11;
    int32_t l_144 = 0x7B1C4CF8L;
    for (p_85 = 0; (p_85 != 16); p_85 = safe_add_func_uint8_t_u_u(p_85, 1))
    { /* block id: 59 */
        uint16_t l_143 = 0x8957L;
        uint32_t l_151 = 18446744073709551613UL;
        p_84 = (safe_add_func_float_f_f((func_89((((((p_82 , p_85) && (l_143 ^ p_85)) == (l_144 == (l_144 && (safe_add_func_int8_t_s_s(p_85, (((((safe_mod_func_int16_t_s_s((safe_add_func_uint32_t_u_u(l_144, (((((((p_83 < 7UL) < p_82) >= l_143) , l_143) || l_144) < l_143) > l_143))), l_143)) < 0xF0A6L) , 0x35L) == l_144) < l_143)))))) && l_151) , 5UL), l_151) == p_83), l_151));
        if (p_83)
            break;
    }
    return l_144;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_89(uint32_t  p_90, int32_t  p_91)
{ /* block id: 44 */
    int16_t l_94 = 5L;
    float l_95 = 0x0.00A5FFp+23;
    int32_t l_133 = (-9L);
    int32_t l_134 = 1L;
    p_91 = (l_94 & p_90);
    for (l_94 = (-29); (l_94 < 5); l_94 = safe_add_func_int8_t_s_s(l_94, 8))
    { /* block id: 48 */
        int16_t l_108 = 0x23AAL;
        const struct S0 l_109 = {0x1.6p-1};
        int32_t l_135 = 0x5D423D3AL;
        l_133 = func_98(((safe_div_func_uint8_t_u_u(l_94, ((p_90 & (safe_add_func_int32_t_s_s(p_91, (safe_sub_func_int16_t_s_s((l_108 | ((((l_109 , p_91) > (l_94 > ((safe_mod_func_uint8_t_u_u((p_91 <= 0UL), l_108)) , l_94))) | 0xD7L) ^ l_108)), l_94))))) & p_91))) ^ 0UL), p_90, l_108);
        l_135 = l_134;
    }
    return l_133;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_98(int32_t  p_99, float  p_100, int32_t  p_101)
{ /* block id: 49 */
    uint32_t l_115 = 0xF66244A8L;
    struct S0 l_132 = {-0x1.Dp+1};
    p_100 = (((safe_sub_func_float_f_f((-l_115), (safe_div_func_float_f_f(((safe_div_func_float_f_f((((safe_add_func_float_f_f((((p_100 >= (!(l_115 < ((((l_115 | (safe_rshift_func_uint8_t_u_u((safe_rshift_func_uint16_t_u_s((((0xA5AF80CEL > (l_115 && (safe_sub_func_uint32_t_u_u(0xE8DF325EL, (~((safe_sub_func_int16_t_s_s(l_115, ((l_132 , l_115) & l_115))) > 0xFA1DL)))))) , 0x27816D4DL) , 0xFBF9L), 0)), l_115))) , l_115) , l_115) , 0x1.CCD07Dp+6)))) > p_99) >= p_100), l_115)) < 0xE.0E7447p+7) >= (-0x1.1p-1)), p_100)) == l_115), l_115)))) > p_101) > 0x9.1F9570p+98);
    return p_99;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_28();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 2
breakdown:
   depth: 0, occurrence: 80
   depth: 1, occurrence: 17
   depth: 2, occurrence: 8
XXX total union variables: 0

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 98
   depth: 2, occurrence: 17
   depth: 4, occurrence: 3
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 9, occurrence: 2
   depth: 13, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 23, occurrence: 3
   depth: 24, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 27, occurrence: 2
   depth: 29, occurrence: 3
   depth: 30, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 523
XXX times a non-volatile is write: 66
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 2

XXX stmts: 97
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 34
   depth: 2, occurrence: 25
   depth: 3, occurrence: 4
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 18.2
XXX percentage an existing variable is used: 81.8
********************* end of statistics **********************/

