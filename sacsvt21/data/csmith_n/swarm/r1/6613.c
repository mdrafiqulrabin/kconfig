/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --no-math64 --inline-function --no-muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      3602669674
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint32_t g_5 = 4294967295U;
static int32_t g_18 = 0x9FCFBCE0;
static int32_t *g_63 = (void*)0;
static int32_t g_71 = 0x4A59E478;
static const uint32_t g_81 = 0U;
static int32_t g_82 = 0xC4999369;
static int32_t *g_103 = &g_71;
static int32_t **g_244 = &g_103;
static int32_t ***g_243 = &g_244;
static int32_t g_374 = 0x2866832C;
static uint16_t g_401 = 65535U;
static int32_t ****g_615 = &g_243;
static int32_t *****g_614 = &g_615;


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_1(void);
static const int32_t  func_8(uint32_t  p_9, int32_t  p_10, uint16_t  p_11, uint32_t  p_12);
inline static int32_t * func_20(int32_t * p_21);
static int16_t  func_24(int32_t  p_25, int16_t  p_26, uint8_t  p_27, int32_t * p_28);
static uint16_t  func_30(uint32_t  p_31);
static int32_t  func_36(uint8_t  p_37, int32_t * p_38, int32_t * p_39);
static int32_t * func_40(int32_t * p_41, int32_t * p_42, uint16_t  p_43, int32_t * p_44, uint8_t  p_45);
inline static int32_t * func_46(int32_t  p_47);
inline static int32_t  func_57(int32_t * p_58, const int32_t * p_59, uint32_t  p_60, int16_t  p_61, int32_t * p_62);
inline static const int32_t * func_64(int32_t * p_65, uint32_t  p_66, int32_t  p_67, uint16_t  p_68, int32_t * p_69);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_5 g_18 g_63 g_71 g_244 g_103 g_243 g_82 g_81 g_374 g_401 g_614 g_615
 * writes: g_18 g_71 g_103 g_374 g_82 g_5 g_63 g_401
 */
inline static uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_13 = 1U;
    int32_t *l_19 = &g_18;
    (*l_19) = ((uint32_t)((-(uint16_t)g_5) > 0xFC07E17F) + (uint32_t)((uint32_t)4294967290U + (uint32_t)((func_8(g_5, l_13, g_5, (~(g_5 > 65532U))) | 1) > g_5)));
    (**g_243) = func_20(&g_18);
    /* statement id: 274 */
    assert (g_63 == 0 || g_63 == &g_18);
    assert (g_103 == &g_374 || g_103 == &g_18);
    (****g_614) = l_19;
    /* statement id: 275 */
    assert (g_103 == &g_18);
    return (*l_19);
}


/* ------------------------------------------ */
/* 
 * reads : g_18
 * writes: g_18
 */
static const int32_t  func_8(uint32_t  p_9, int32_t  p_10, uint16_t  p_11, uint32_t  p_12)
{ /* block id: 1 */
    const uint32_t l_16 = 0xCF13E13A;
    int32_t *l_17 = &g_18;
    (*l_17) = (~l_16);
    return (*l_17);
}


/* ------------------------------------------ */
/* 
 * reads : g_5 g_18 g_63 g_71 g_244 g_103 g_243 g_82 g_81 g_374 g_401 g_614
 * writes: g_18 g_71 g_103 g_374 g_82 g_5 g_63 g_401
 */
inline static int32_t * func_20(int32_t * p_21)
{ /* block id: 5 */
    int32_t l_29 = 0x88A97331;
    int32_t *l_373 = &g_374;
    int32_t l_413 = (-1);
    int32_t l_438 = 0;
    int32_t ***l_535 = &g_244;
    int32_t l_539 = (-1);
    int32_t l_607 = (-3);
    if (((uint16_t)(func_24(g_5, (l_29 >= func_30(((int16_t)((int32_t)l_29 / (int32_t)func_36(l_29, func_40(p_21, func_46(l_29), l_29, g_63, g_82), l_373)) - (int16_t)l_29))), g_81, l_373) || (*l_373)) / (uint16_t)g_81))
    { /* block id: 154 */
        int32_t *l_442 = &g_18;
        int32_t l_481 = 8;
        uint32_t l_518 = 2U;
        for (g_82 = (-20); (g_82 != (-20)); g_82 += 8)
        { /* block id: 157 */
            const uint32_t l_439 = 0x5F71308A;
            (*l_373) = ((uint16_t)4U - (uint16_t)(0x3F65 || (*l_373)));
            for (g_71 = (-19); (g_71 < 4); g_71 += 8)
            { /* block id: 161 */
                const int32_t l_436 = (-1);
                (*g_244) = (void*)0;
                /* statement id: 162 */
                assert (g_103 == 0);
                for (g_5 = 5; (g_5 >= 35); ++g_5)
                { /* block id: 165 */
                    int16_t l_437 = 0xEC53;
                    int32_t *l_443 = &g_71;
                    (*p_21) = (*p_21);
                    (*p_21) = (((0 == ((*l_373) || (9 < l_413))) == (((7U || (*l_373)) < (((int16_t)((int16_t)((-(uint16_t)((int16_t)(((uint16_t)(((((uint32_t)((-1) ^ ((((int32_t)(-(int32_t)(((((int32_t)(((uint16_t)0xF8E4 << (uint16_t)13) >= ((int16_t)g_374 << (int16_t)5)) - (int32_t)g_82) & l_436) >= l_437) && l_437)) + (int32_t)(*p_21)) != 0U) < g_18)) / (uint32_t)l_438) || l_437) < 0) <= 0xAE33) >> (uint16_t)0) & 0xB8471116) - (int16_t)l_439)) && 1U) >> (int16_t)g_374) % (int16_t)(*l_373)) < g_374)) || g_401)) ^ 0xEDDF);
                    (*l_373) = 0x799A62C1;
                    for (l_29 = 0; (l_29 >= 28); l_29++)
                    { /* block id: 171 */
                        (**g_243) = l_442;
                        /* statement id: 172 */
                        assert (g_103 == &g_18);
                        (*l_373) = ((l_443 == l_442) && ((*g_243) != (*g_243)));
                        l_443 = l_442;
                        /* statement id: 174 */
                        assert (l_443 == &g_18);
                        if ((*p_21))
                            break;
                    }
                    /* facts after for loop */
                    assert (l_443 == &g_18 || l_443 == &g_71);
                }
                /* facts after for loop */
                assert (g_103 == &g_18 || g_103 == 0);
                (**g_243) = (**g_243);
            }
        }
        /* facts after for loop */
        //assert (g_103 == &g_18 || g_103 == 0 || g_103 == dangling);
        if ((*p_21))
        { /* block id: 181 */
            (**g_243) = p_21;
            /* statement id: 182 */
            assert (g_103 == &g_18);
        }
        else
        { /* block id: 183 */
            int32_t *l_450 = &g_18;
            (*l_442) = (&p_21 != (void*)0);
            if (((uint16_t)((int16_t)(p_21 == l_442) >> (int16_t)6) % (uint16_t)0x0620))
            { /* block id: 185 */
                int32_t **l_449 = &g_63;
                (*l_449) = func_40(p_21, p_21, (!((void*)0 != l_449)), l_450, g_5);
                /* statement id: 186 */
                assert (g_63 == &g_18);
                assert (g_103 == &g_18);
            }
            else
            { /* block id: 187 */
                uint32_t l_451 = 1U;
                int32_t ***l_471 = &g_244;
                if (l_451)
                { /* block id: 188 */
                    int32_t **l_460 = &g_103;
                    for (g_18 = 0; (g_18 != 9); g_18 += 9)
                    { /* block id: 191 */
                        int16_t l_461 = 0x5C57;
                        (*l_373) = (((uint16_t)((((uint32_t)g_374 + (uint32_t)((void*)0 == &p_21)) < (*l_450)) >= (((int16_t)g_401 - (int16_t)(*l_373)) >= (l_460 == &l_450))) << (uint16_t)3) & l_461);
                        (**g_243) = p_21;
                        /* statement id: 193 */
                        assert (g_103 == &g_18);
                    }
                    if (g_401)
                        goto lbl_482;
lbl_482:
                    (*l_373) = ((int16_t)(((int16_t)((uint32_t)(g_71 & ((int16_t)(!(*p_21)) << (int16_t)6)) % (uint32_t)((((g_18 | ((l_471 != l_471) ^ ((int16_t)((uint32_t)(((uint16_t)0x1AE8 << (uint16_t)(*l_373)) != ((((int16_t)((-(uint16_t)g_401) <= (((((*l_373) < l_481) > 7) >= (*l_450)) | (*l_373))) << (int16_t)0) < (*l_373)) || 2)) % (uint32_t)(*p_21)) - (int16_t)g_401))) == (*l_450)) != g_71) && 5)) >> (int16_t)(*l_442)) >= l_451) >> (int16_t)2);
                    (*l_373) = 0x828740C8;
                    return p_21;
                    /* statement id: 198 */
                    //assert (func_20_rv == &g_18);
                }
                else
                { /* block id: 199 */
                    uint16_t l_501 = 65535U;
                    (*g_244) = p_21;
                    /* statement id: 200 */
                    assert (g_103 == &g_18);
                    if (((void*)0 != &g_244))
                    { /* block id: 201 */
                        int32_t l_509 = (-3);
                        (**g_244) = ((uint16_t)((uint32_t)(0x9431 == ((((uint16_t)(65527U <= (-(uint32_t)((void*)0 != (*l_471)))) << (uint16_t)3) && (**g_244)) & (((8 | (((p_21 == (**l_471)) >= (***l_471)) >= (*l_442))) && l_501) != (*l_450)))) + (uint32_t)l_509) << (uint16_t)g_71);
                        (**g_243) = l_450;
                        (*p_21) = (g_71 < 0xA459);
                        (*p_21) = l_501;
                    }
                    else
                    { /* block id: 206 */
                        int32_t ****l_511 = &g_243;
                        int32_t *****l_510 = &l_511;
                        (**g_243) = (void*)0;
                        /* statement id: 207 */
                        assert (g_103 == 0);
                        (*l_510) = &g_243;
                        (*p_21) = (((0x2417 & 0x70FB) >= (((((uint16_t)((((*l_373) ^ (g_81 == g_5)) < ((uint32_t)((*l_510) == (void*)0) + (uint32_t)(*l_373))) > ((int16_t)(0x1AD5 < 1) << (int16_t)11)) >> (uint16_t)15) >= l_501) <= g_401) <= l_501)) || l_518);
                    }
                    /* facts after branching */
                    assert (g_103 == 0 || g_103 == &g_18);
                }
                /* facts after branching */
                assert (g_103 == 0 || g_103 == &g_18);
                (*p_21) = (((((*l_442) >= (~((uint16_t)((uint32_t)((&g_243 == (void*)0) > ((void*)0 != (**g_243))) + (uint32_t)((uint32_t)6U + (uint32_t)(p_21 != (*g_244)))) >> (uint16_t)g_82))) && (*p_21)) < (*p_21)) > (*l_450));
                (*p_21) = ((uint32_t)(!(*l_373)) / (uint32_t)(((uint16_t)((uint32_t)(((void*)0 != l_471) <= g_18) - (uint32_t)((-(uint16_t)(-(int32_t)((void*)0 == &p_21))) ^ (*p_21))) >> (uint16_t)((*l_442) != 0xC627)) && (*p_21)));
            }
            /* facts after branching */
            assert (g_63 == 0 || g_63 == &g_18);
            assert (g_103 == 0 || g_103 == &g_18);
            (*g_244) = l_450;
            /* statement id: 215 */
            assert (g_103 == &g_18);
            (**g_244) = (*p_21);
        }
        /* facts after branching */
        assert (g_63 == 0 || g_63 == &g_18);
        assert (g_103 == &g_18);
    }
    else
    { /* block id: 218 */
        const uint8_t l_553 = 255U;
        int32_t *l_554 = &g_18;
        const int32_t *l_556 = &l_413;
        const int32_t **l_555 = &l_556;
        (*l_555) = func_64(p_21, (((l_535 == &g_244) < ((~((uint16_t)l_539 % (uint16_t)((int16_t)((uint16_t)((((*p_21) < (((*l_373) <= ((int32_t)((uint16_t)g_18 << (uint16_t)((int16_t)(~((0xB358 && ((uint32_t)(((((void*)0 != p_21) < g_374) | g_401) ^ l_553) - (uint32_t)(*p_21))) || l_553)) % (int16_t)65533U)) / (int32_t)4U)) != g_71)) && 0xD1B7BA88) & (*l_373)) % (uint16_t)g_82) >> (int16_t)4))) >= g_18)) & g_401), l_553, l_553, l_554);
        /* statement id: 219 */
        assert (l_556 == &g_71);
        if ((((&l_555 != (void*)0) && (p_21 != p_21)) & (1U >= ((int16_t)0xC0E9 + (int16_t)g_18))))
        { /* block id: 220 */
            uint16_t l_566 = 1U;
            uint8_t l_567 = 1U;
            (**l_535) = p_21;
            /* statement id: 221 */
            assert (g_103 == &g_18);
            for (g_401 = 0; (g_401 <= 21); g_401++)
            { /* block id: 224 */
                const int16_t l_572 = (-1);
                int32_t *l_575 = &g_374;
                if (((uint16_t)((((uint16_t)(-(uint32_t)(l_566 != (l_567 < (((((**l_555) ^ ((((uint16_t)g_81 + (uint16_t)(0xF5BAD54A && ((int16_t)(((void*)0 != l_535) | 0x8D316E80) << (int16_t)6))) < 4294967295U) >= 0x2EF4)) <= (**g_244)) < (*l_554)) != 0x604514AF)))) >> (uint16_t)(**l_555)) | 0xAD99CC62) > l_567) >> (uint16_t)l_572))
                { /* block id: 225 */
                    (**g_244) = (0x3E018C51 && 0x7C38006D);
                    if ((*p_21))
                        continue;
                    (***l_535) = ((uint32_t)(g_5 > l_572) + (uint32_t)g_82);
                    (*l_555) = (*l_555);
                }
                else
                { /* block id: 230 */
                    if ((*p_21))
                        break;
                    return l_575;
                    /* statement id: 232 */
                    //assert (func_20_rv == &g_374);
                }
                p_21 = (*g_244);
                (*g_244) = p_21;
            }
        }
        else
        { /* block id: 237 */
            int32_t ****l_588 = &l_535;
            int32_t *****l_587 = &l_588;
            for (g_18 = 26; (g_18 > (-10)); g_18 -= 6)
            { /* block id: 240 */
                uint8_t l_580 = 0x8F;
                int32_t l_600 = 0x0F857443;
                if (((void*)0 == p_21))
                { /* block id: 241 */
                    int32_t l_586 = (-10);
                    for (g_374 = 0; (g_374 < 25); g_374 += 6)
                    { /* block id: 244 */
                        uint16_t l_581 = 0x8310;
                        l_580 = 1;
                        (**g_243) = func_40(p_21, p_21, l_581, p_21, l_581);
                        /* statement id: 246 */
                        assert (g_103 == &g_18);
                    }
                    (*l_373) = ((uint16_t)((int32_t)(l_586 != ((void*)0 != l_587)) - (int32_t)(((uint32_t)((uint32_t)(0xBDE0 || ((p_21 != (void*)0) | 0)) / (uint32_t)(((int32_t)((-(uint32_t)(0 | ((uint32_t)g_401 + (uint32_t)(*p_21)))) ^ l_586) / (int32_t)l_580) || (*l_554))) % (uint32_t)(*p_21)) || (*p_21))) - (uint16_t)0x0ECB);
                }
                else
                { /* block id: 249 */
                    l_600 = (*p_21);
                    if ((*p_21))
                        continue;
                }
                l_607 = ((uint16_t)(((*p_21) >= (&g_244 == &g_244)) >= (((uint16_t)(*l_554) << (uint16_t)0) >= (0x7406AB9A && (((g_71 ^ (((uint16_t)(4 && (((*l_535) == &p_21) && g_18)) / (uint16_t)l_580) ^ 0xB1B15B43)) & 4294967295U) >= (*l_556))))) / (uint16_t)g_81);
                for (l_580 = 0; (l_580 > 19); l_580 += 6)
                { /* block id: 256 */
                    int16_t l_612 = (-8);
                    for (g_374 = 0; (g_374 > 6); g_374 += 5)
                    { /* block id: 259 */
                        int32_t *l_613 = &l_438;
                        (**l_535) = func_40(p_21, p_21, l_612, l_613, (*l_554));
                        /* statement id: 260 */
                        assert (g_103 == &g_18);
                        if ((**g_244))
                            continue;
                        (*l_613) = (0 <= 0x01BA2930);
                        if ((*l_613))
                            break;
                    }
                    (*l_555) = func_64(func_40(p_21, &l_600, ((((*l_373) ^ ((void*)0 == g_614)) >= g_82) != ((int32_t)(*l_556) / (int32_t)(-4))), p_21, (**l_555)), g_71, g_71, l_612, p_21);
                    /* statement id: 265 */
                    assert (g_103 == &l_600);
                    (***g_243) = (***l_535);
                }
                /* facts after for loop */
                //assert (g_103 == &l_600 || g_103 == &g_18 || g_103 == dangling);
                if ((*l_373))
                    break;
                //assert (g_103 == &g_18 || g_103 == dangling);
            }
            /* facts after for loop */
            //assert (g_103 == &g_18 || g_103 == dangling);
        }
        /* facts after branching */
        //assert (g_103 == &g_18 || g_103 == dangling);
        (*g_244) = p_21;
        /* statement id: 271 */
        assert (g_103 == &g_18);
    }
    /* facts after branching */
    assert (g_63 == 0 || g_63 == &g_18);
    assert (g_103 == &g_18);
    return p_21;
    /* statement id: 273 */
    //assert (func_20_rv == &g_18);
}


/* ------------------------------------------ */
/* 
 * reads : g_244 g_103 g_82
 * writes: g_374 g_103
 */
static int16_t  func_24(int32_t  p_25, int16_t  p_26, uint8_t  p_27, int32_t * p_28)
{ /* block id: 149 */
    uint16_t l_404 = 2U;
    (*p_28) = (0U < (-6));
    (*g_244) = &p_25;
    /* statement id: 151 */
    assert (g_103 == &p_25);
    (**g_244) = l_404;
    return g_82;
    /* statement id: 153 */
    //assert (g_103 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_243 g_244 g_103
 * writes: g_103
 */
static uint16_t  func_30(uint32_t  p_31)
{ /* block id: 145 */
    uint8_t l_403 = 2U;
    l_403 = 0xE40E753F;
    (*g_244) = (**g_243);
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads : g_374 g_401 g_5 g_71 g_18 g_82
 * writes: g_374
 */
static int32_t  func_36(uint8_t  p_37, int32_t * p_38, int32_t * p_39)
{ /* block id: 142 */
    const int32_t *l_377 = &g_71;
    int32_t ***l_400 = &g_244;
    int32_t l_402 = 0;
    (*p_39) = ((int32_t)(((p_39 != l_377) != (((uint32_t)(((uint16_t)(((uint16_t)((int16_t)((void*)0 == l_377) % (int16_t)((int16_t)((int32_t)(~(((((((int32_t)(*p_39) / (int32_t)(-7)) & ((int16_t)(!(0x24E963F0 ^ p_37)) << (int16_t)((int16_t)((((((uint16_t)(l_400 == (void*)0) << (uint16_t)6) ^ p_37) || p_37) && 1) == g_401) >> (int16_t)g_5))) <= (*l_377)) < g_18) & (*p_39)) ^ g_82)) / (int32_t)(*l_377)) << (int16_t)11)) >> (uint16_t)l_402) == 1U) << (uint16_t)p_37) < g_18) % (uint32_t)0xBD9D387A) == (*l_377))) != 0x9A8E) / (int32_t)(*p_39));
    return (*l_377);
}


/* ------------------------------------------ */
/* 
 * reads : g_243 g_244 g_103 g_5 g_18 g_71 g_81
 * writes: g_103
 */
static int32_t * func_40(int32_t * p_41, int32_t * p_42, uint16_t  p_43, int32_t * p_44, uint8_t  p_45)
{ /* block id: 138 */
    int32_t l_348 = (-1);
    const int32_t *l_372 = &l_348;
    const int32_t **l_371 = &l_372;
    (**g_243) = p_42;
    /* statement id: 139 */
    //assert (g_103 == 0 || g_103 == &g_71 || g_103 == &g_18 || g_103 == &l_600);
    (*l_371) = func_64((*g_244), (((uint32_t)(((0xB149 <= (-1)) | g_5) < (((int32_t)((int32_t)(2 ^ (((int32_t)((uint16_t)(!((((g_18 | ((((((uint32_t)0xBC621D0D - (uint32_t)(((-(int16_t)p_43) <= ((int32_t)((uint16_t)(0xAB0AF10B && l_348) / (uint16_t)p_43) / (int32_t)(*p_41))) == g_71)) & l_348) || g_71) > 0x367C9252) && l_348)) & 0U) < l_348) || p_45)) / (uint16_t)0x0550) + (int32_t)0xC017E480) == p_43)) / (int32_t)l_348) - (int32_t)l_348) < l_348)) + (uint32_t)1U) >= g_81), p_45, p_43, (**g_243));
    /* statement id: 140 */
    assert (l_372 == &g_71);
    return (*g_244);
    /* statement id: 141 */
    //assert (func_40_rv == 0 || func_40_rv == &g_71 || func_40_rv == &g_18 || func_40_rv == &l_600);
}


/* ------------------------------------------ */
/* 
 * reads : g_18 g_5 g_63 g_71 g_244 g_103 g_243 g_82 g_81
 * writes: g_18 g_71 g_103
 */
inline static int32_t * func_46(int32_t  p_47)
{ /* block id: 6 */
    int32_t *l_70 = &g_71;
    int32_t ***l_320 = (void*)0;
    uint32_t l_341 = 4294967286U;
    int16_t l_342 = 0xC72A;
    for (p_47 = (-24); (p_47 == (-7)); p_47++)
    { /* block id: 9 */
        int32_t *l_50 = &g_18;
        (*l_50) = (-1);
        (*l_50) = (*l_50);
        (*l_70) = ((uint32_t)((((uint16_t)((func_8(p_47, p_47, p_47, g_5) == 3U) < g_5) >> (uint16_t)((int32_t)func_57(g_63, func_64(g_63, p_47, g_5, p_47, l_70), (*l_70), p_47, (*g_244)) / (int32_t)p_47)) >= 4294967287U) <= p_47) % (uint32_t)p_47);
        (***g_243) = ((uint32_t)(((*l_70) >= (4294967286U && (((void*)0 != (*g_244)) != (((uint16_t)(p_47 < ((((uint16_t)p_47 % (uint16_t)(*l_70)) != ((uint16_t)((0xA2B3 <= (((uint32_t)((1 <= g_82) & (*l_70)) / (uint32_t)p_47) == 0x3028FBC9)) & 8U) >> (uint16_t)9)) && (*l_50))) + (uint16_t)p_47) < 0xB49376F3)))) | p_47) / (uint32_t)0x21921C0D);
    }
    if (((int16_t)(*l_70) << (int16_t)4))
    { /* block id: 114 */
        int32_t ***l_321 = &g_244;
lbl_308:
        (*g_244) = &p_47;
        /* statement id: 115 */
        assert (g_103 == &p_47);
        if (((*g_244) == (void*)0))
        { /* block id: 116 */
            int32_t *l_305 = &g_71;
            return l_305;
            /* statement id: 117 */
            //assert (g_103 == dangling);
            //assert (func_46_rv == &g_71);
        }
        else
        { /* block id: 118 */
            int32_t *l_330 = (void*)0;
            for (g_71 = (-9); (g_71 != 10); ++g_71)
            { /* block id: 121 */
                (*g_103) = ((*g_244) != (*g_244));
            }
            if (g_82)
                goto lbl_308;
            (*g_103) = ((uint16_t)(((*g_243) == &l_70) ^ ((uint16_t)(((uint16_t)(~((65535U && ((int32_t)(*l_70) - (int32_t)((int16_t)((l_320 != l_321) || ((int32_t)(((int32_t)((int32_t)((int16_t)p_47 % (int16_t)9) - (int32_t)((void*)0 != l_330)) / (int32_t)p_47) & (***l_321)) / (int32_t)(***l_321))) >> (int16_t)g_18))) || g_82)) << (uint16_t)(*l_70)) != 0x0776) - (uint16_t)0)) >> (uint16_t)g_71);
            (***l_321) = p_47;
        }
    }
    else
    { /* block id: 128 */
        int32_t *l_331 = &g_18;
        (**g_243) = l_331;
        /* statement id: 129 */
        assert (g_103 == &g_18);
    }
    /* facts after branching */
    assert (g_103 == &g_18 || g_103 == &p_47);
    p_47 = ((-(uint16_t)((uint16_t)((g_82 & 1) >= p_47) << (uint16_t)(((int16_t)g_82 >> (int16_t)(g_82 || p_47)) || ((((((((((**g_244) <= ((uint32_t)(((uint32_t)(0x8418D95E && (***g_243)) + (uint32_t)0x0E8DCDA3) < g_5) + (uint32_t)p_47)) != g_81) <= l_341) == p_47) <= p_47) ^ (-7)) ^ (*g_103)) > (**g_244)) <= l_342)))) && 1);
    if ((***g_243))
    { /* block id: 132 */
        (**g_244) = p_47;
    }
    else
    { /* block id: 134 */
        int32_t *l_343 = (void*)0;
        return l_343;
        /* statement id: 135 */
        //assert (g_103 == &g_18 || g_103 == dangling);
        //assert (func_46_rv == 0);
    }
    return l_70;
    /* statement id: 137 */
    //assert (g_103 == &g_18 || g_103 == dangling);
    //assert (func_46_rv == &g_71);
}


/* ------------------------------------------ */
/* 
 * reads : g_71 g_243 g_244 g_103
 * writes: g_71
 */
inline static int32_t  func_57(int32_t * p_58, const int32_t * p_59, uint32_t  p_60, int16_t  p_61, int32_t * p_62)
{ /* block id: 108 */
    (***g_243) = (*p_62);
    return (*g_103);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int32_t * func_64(int32_t * p_65, uint32_t  p_66, int32_t  p_67, uint16_t  p_68, int32_t * p_69)
{ /* block id: 12 */
    uint16_t l_78 = 65533U;
    int32_t *l_89 = &g_71;
    const int32_t l_236 = 1;
    return l_89;
    /* statement id: 107 */
    //assert (func_64_rv == &g_71);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_5, "g_5", print_hash_value);
    transparent_crc(g_18, "g_18", print_hash_value);
    transparent_crc(g_71, "g_71", print_hash_value);
    transparent_crc(g_81, "g_81", print_hash_value);
    transparent_crc(g_82, "g_82", print_hash_value);
    transparent_crc(g_374, "g_374", print_hash_value);
    transparent_crc(g_401, "g_401", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 83
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 32
breakdown:
   depth: 1, occurrence: 133
   depth: 2, occurrence: 23
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 2
   depth: 10, occurrence: 2
   depth: 11, occurrence: 1
   depth: 12, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 4
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1

XXX total number of pointers: 68

XXX times a variable address is taken: 87
XXX times a pointer is dereferenced on RHS: 185
breakdown:
   depth: 1, occurrence: 155
   depth: 2, occurrence: 20
   depth: 3, occurrence: 10
XXX times a pointer is dereferenced on LHS: 88
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 19
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
XXX times a pointer is compared with null: 40
XXX times a pointer is compared with address of another variable: 13
XXX times a pointer is compared with another pointer: 14
XXX times a pointer is qualified to be dereferenced: 472

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 358
   level: 2, occurrence: 83
   level: 3, occurrence: 52
   level: 4, occurrence: 4
   level: 5, occurrence: 7
XXX number of pointers point to pointers: 26
XXX number of pointers point to scalars: 42
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 22.1
XXX average alias set size: 1.38

XXX times a non-volatile is read: 791
XXX times a non-volatile is write: 240
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 3
XXX backward jumps: 3

XXX stmts: 115
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 14
   depth: 2, occurrence: 15
   depth: 3, occurrence: 15
   depth: 4, occurrence: 24
   depth: 5, occurrence: 19

XXX percentage a fresh-made variable is used: 11.3
XXX percentage an existing variable is used: 88.7
********************* end of statistics **********************/

