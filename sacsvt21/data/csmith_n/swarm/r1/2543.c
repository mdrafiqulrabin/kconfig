/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2935609872
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */
static uint8_t g_3 = 6UL;
static int32_t g_46 = 0x27A4129BL;
static int32_t *g_45 = &g_46;
static int16_t g_110 = 0x9FF1L;
static uint16_t g_123 = 6UL;
static int16_t g_133 = 0xB80EL;
static uint32_t g_158 = 0x9A0A0809L;
static uint8_t g_163 = 0xE4L;
static int32_t *g_179 = &g_46;
static uint32_t g_198 = 0x948D72D2L;
static volatile uint32_t g_203 = 0x7DBBC662L;/* VOLATILE GLOBAL g_203 */
static int32_t *** volatile g_231 = (void*)0;/* VOLATILE GLOBAL g_231 */
static int32_t ** volatile g_253 = &g_179;/* VOLATILE GLOBAL g_253 */
static volatile uint32_t ** volatile g_261 = (void*)0;/* VOLATILE GLOBAL g_261 */
static int32_t ** volatile g_267 = (void*)0;/* VOLATILE GLOBAL g_267 */
static int32_t *g_269 = (void*)0;
static int32_t ** volatile g_268 = &g_269;/* VOLATILE GLOBAL g_268 */
static uint32_t **g_300 = (void*)0;
static uint32_t ***g_299 = &g_300;
static uint32_t ****g_298 = &g_299;
static uint32_t *****g_297 = &g_298;
static int32_t ** volatile g_307 = &g_269;/* VOLATILE GLOBAL g_307 */
static int32_t g_320 = (-9L);
static int32_t g_322 = 6L;
static int32_t * volatile g_321 = &g_322;/* VOLATILE GLOBAL g_321 */
static int32_t g_332 = 0x7E1BAF48L;
static int32_t ** volatile g_354 = (void*)0;/* VOLATILE GLOBAL g_354 */
static int16_t g_365 = (-8L);
static int32_t ** volatile g_388 = (void*)0;/* VOLATILE GLOBAL g_388 */
static int32_t * volatile g_399 = &g_322;/* VOLATILE GLOBAL g_399 */
static int32_t ** volatile g_434 = (void*)0;/* VOLATILE GLOBAL g_434 */
static int32_t ** volatile g_435 = &g_179;/* VOLATILE GLOBAL g_435 */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_26(void);
inline static int16_t  func_31(int16_t  p_32);
static int16_t  func_33(int32_t  p_34, uint8_t  p_35, uint32_t  p_36, uint32_t  p_37, uint8_t  p_38);
inline static int32_t * func_47(int32_t * p_48, uint16_t  p_49, int32_t  p_50, int32_t * p_51, int32_t * p_52);
inline static int16_t  func_55(uint32_t  p_56, int16_t  p_57);
inline static int32_t * func_59(int32_t  p_60, uint8_t  p_61);
static uint32_t  func_68(int16_t  p_69, uint16_t  p_70, int16_t  p_71);
inline static int16_t  func_72(int32_t  p_73, int32_t  p_74);
static uint16_t  func_78(int32_t  p_79, uint16_t  p_80, int32_t * p_81, int32_t * p_82);
inline static int32_t * func_90(int32_t * p_91, int32_t * p_92, uint8_t  p_93, int32_t  p_94, uint32_t  p_95);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_45 g_46 g_253 g_158 g_133 g_261 g_268 g_110 g_179 g_198 g_123 g_269 g_307 g_298 g_299 g_300 g_163 g_321 g_320 g_322 g_399 g_332 g_435
 * writes: g_123 g_46 g_179 g_158 g_269 g_297 g_320 g_322 g_332 g_110 g_133 g_365 g_299 g_300 g_198
 */
static uint32_t  func_26(void)
{ /* block id: 36 */
    int32_t l_39 = (-7L);
    int32_t *l_40 = &l_39;
    uint16_t l_58 = 0UL;
    uint16_t *l_414 = &l_58;
    int32_t **l_418 = &g_179;
    uint32_t l_419 = 0x69F638CFL;
    uint32_t l_420 = 0x3E9DA6D7L;
    int32_t l_421 = 0L;
    uint32_t **l_451 = (void*)0;
    uint32_t *l_453 = &g_198;
    uint32_t **l_452 = &l_453;
    uint32_t *l_454 = &l_420;
    uint32_t *l_463 = &g_198;
    int16_t *l_464 = &g_133;
    (*g_45) = ((uint16_t)__builtin_parityll(g_3) % (uint16_t)((uint16_t)(func_31(func_33(((*l_40) = l_39), ((uint16_t)((int16_t)(g_3 == ((g_45 == ((*l_418) = func_47(&g_46, ((*l_414) = ((int16_t)func_55(l_58, g_3) * (int16_t)g_198)), g_3, g_45, l_40))) != l_419)) + (int16_t)l_420) / (uint16_t)g_163), g_163, g_3, l_421)) || (*l_40)) << (uint16_t)9));
    /* statement id: 312 */
    assert (g_269 == &g_46);
    //assert (g_300 == dangling);
    //assert (g_297 == dangling || g_297 == &g_298);
    (*l_418) = (*g_435);
    (**l_418) = ((int32_t)(((int16_t)(((*l_40) || ((int32_t)((int16_t)(-(uint16_t)65528UL) * (int16_t)(+(((*l_452) = func_59((((int32_t)(4L & (*g_179)) + (int32_t)(((uint16_t)(__builtin_clz(((**g_307) != ((4L ^ 3UL) && ((**l_418) & ((*l_40) = (0x449FL & g_163)))))) | (**l_418)) << (uint16_t)4) ^ (**l_418))) >= (**l_418)), g_46)) == l_454))) / (int32_t)l_420)) > l_419) << (int16_t)g_3) | 0L) - (int32_t)g_158);
    /* statement id: 316 */
    assert (l_453 == &g_198 || l_453 == 0);
    (*l_40) = ((int16_t)((*l_464) = (g_110 = ((int16_t)((0xA0DB183BL == func_72((**g_253), (*l_40))) < 0x05448FBCL) << (int16_t)((int32_t)((*l_40) > ((int32_t)(((*l_463) = ((*l_454) = __builtin_parityl(g_322))) != 1UL) - (int32_t)0x85EC9B8CL)) / (int32_t)(*l_40))))) >> (int16_t)10);
    return g_46;
}


/* ------------------------------------------ */
/* 
 * reads : g_307 g_269 g_435
 * writes: g_179
 */
inline static int16_t  func_31(int16_t  p_32)
{ /* block id: 309 */
    int16_t l_436 = 1L;
    (*g_435) = (*g_307);
    return l_436;
}


/* ------------------------------------------ */
/* 
 * reads : g_269 g_298 g_299 g_45 g_46 g_133 g_261 g_268 g_110 g_253
 * writes: g_320 g_46 g_300 g_158 g_123 g_179 g_269
 */
static int16_t  func_33(int32_t  p_34, uint8_t  p_35, uint32_t  p_36, uint32_t  p_37, uint8_t  p_38)
{ /* block id: 303 */
    uint32_t *l_431 = &g_198;
    uint32_t **l_430 = &l_431;
    int32_t l_432 = 1L;
    uint16_t *l_433 = (void*)0;
    (*g_269) = p_37;
    p_34 = ((uint16_t)((uint16_t)((int16_t)((int32_t)(((**g_298) = l_430) != (void*)0) % (int32_t)__builtin_parity(((void*)0 != &l_431))) << (int16_t)3) - (uint16_t)(((l_432 != (func_72(p_37, p_38) || l_432)) != p_36) != p_35)) << (uint16_t)5);
    /* statement id: 306 */
    assert (g_179 == &g_46);
    assert (g_269 == &g_46);
    assert (g_300 == &l_431);
    (*g_269) = (l_433 == l_433);
    return l_432;
    /* statement id: 308 */
    //assert (g_300 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_45 g_158 g_179 g_320 g_46 g_253
 * writes: g_46 g_158 g_320
 */
inline static int32_t * func_47(int32_t * p_48, uint16_t  p_49, int32_t  p_50, int32_t * p_51, int32_t * p_52)
{ /* block id: 291 */
lbl_417:
    (*g_45) = 1L;
    for (g_158 = (-17); (g_158 <= 28); g_158 += 4)
    { /* block id: 295 */
        if (g_158)
            goto lbl_417;
        (*g_179) = (-1L);
        if ((*g_179))
            break;
        (*p_48) = 5L;
    }
    return (*g_253);
    /* statement id: 301 */
    //assert (func_47_rv == &g_320 || func_47_rv == &g_46);
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_253 g_158 g_133 g_45 g_261 g_268 g_110 g_3 g_179 g_198 g_123 g_269 g_307 g_298 g_299 g_300 g_163 g_321 g_320 g_322 g_399 g_332
 * writes: g_123 g_46 g_179 g_158 g_269 g_297 g_320 g_322 g_332 g_110 g_133 g_365 g_299
 */
inline static int16_t  func_55(uint32_t  p_56, int16_t  p_57)
{ /* block id: 38 */
    int32_t *l_67 = &g_46;
    int32_t *l_89 = &g_46;
    l_89 = func_59((+__builtin_ia32_crc32qi((((uint16_t)((int32_t)((void*)0 == l_67) / (int32_t)func_68(func_72(p_57, ((uint16_t)((+(((func_78(((int16_t)0x7A8DL << (int16_t)g_46), ((uint16_t)(6L || (((int16_t)(*l_67) >> (int16_t)1) >= ((*l_67) | ((*l_67) <= 0x3C23L)))) << (uint16_t)g_46), l_89, l_89) | p_56) < g_158) & g_133)) >= 0xA82F6642L) - (uint16_t)p_57)), g_3, g_110)) * (uint16_t)g_163) < 8UL), g_3)), g_163);
    /* statement id: 280 */
    assert (l_89 == 0);
    assert (g_179 == &g_320 || g_179 == &g_46);
    assert (g_269 == &g_320 || g_269 == &g_46);
    //assert (g_297 == dangling || g_297 == &g_298);
    for (p_56 = 16; (p_56 == 49); p_56 += 3)
    { /* block id: 283 */
        int32_t l_411 = 1L;
        (*g_269) = ((!((int16_t)(!65532UL) >> (int16_t)12)) | (l_411 | l_411));
        (*g_45) = ((int16_t)l_411 % (int16_t)(*l_67));
    }
    (*l_67) = (*g_399);
    (*l_67) = ((*l_67) < p_56);
    return (*l_67);
}


/* ------------------------------------------ */
/* 
 * reads : g_269
 * writes: g_320 g_46
 */
inline static int32_t * func_59(int32_t  p_60, uint8_t  p_61)
{ /* block id: 277 */
    int32_t *l_404 = (void*)0;
    (*g_269) = 0x37AD52E6L;
    return l_404;
    /* statement id: 279 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_253 g_179 g_46 g_45 g_198 g_123 g_269 g_307 g_298 g_299 g_300 g_110 g_163 g_133 g_3 g_321 g_320 g_261 g_268 g_158 g_322 g_399 g_332
 * writes: g_46 g_297 g_269 g_158 g_320 g_322 g_332 g_123 g_179 g_110 g_133 g_365 g_299
 */
static uint32_t  func_68(int16_t  p_69, uint16_t  p_70, int16_t  p_71)
{ /* block id: 175 */
    uint32_t l_286 = 0UL;
    int32_t *l_306 = &g_46;
    uint32_t ***l_318 = &g_300;
    int32_t *l_349 = &g_322;
    uint8_t l_379 = 249UL;
    int32_t **l_387 = &g_179;
    uint32_t l_393 = 0xF28E5AF4L;
    int16_t *l_397 = &g_133;
    int16_t *l_398 = &g_365;
    uint16_t l_403 = 65531UL;
    if (((((((int16_t)((((int16_t)((uint32_t)l_286 % (uint32_t)(**g_253)) << (int16_t)9) >= l_286) != (*g_45)) / (int16_t)p_71) == ((p_70 > ((((int32_t)l_286 % (int32_t)p_70) || (&p_69 != (void*)0)) > 0L)) ^ g_198)) != l_286) && g_123) != 0x3392L))
    { /* block id: 176 */
        uint32_t l_289 = 0xB6B1F519L;
lbl_301:
        (*g_269) = l_289;
        for (l_289 = 0; (l_289 != 4); l_289++)
        { /* block id: 180 */
            uint32_t *l_296 = &l_289;
            uint32_t **l_295 = &l_296;
            uint32_t ***l_294 = &l_295;
            uint32_t ****l_293 = &l_294;
            uint32_t *****l_292 = &l_293;
            int32_t l_302 = 5L;
            g_297 = l_292;
            /* statement id: 181 */
            assert (g_297 == &l_293);
            if (g_123)
                goto lbl_301;
            //assert (g_297 == dangling);
            if (l_302)
                continue;
            //assert (g_297 == dangling);
            (**g_253) = p_71;
        }
    }
    else
    { /* block id: 186 */
        uint16_t l_316 = 9UL;
        int32_t *l_344 = &g_320;
        uint8_t l_345 = 0xE0L;
        uint32_t *l_360 = &g_158;
        uint32_t **l_359 = &l_360;
        if (((int16_t)0x3934L << (int16_t)9))
        { /* block id: 187 */
            uint16_t l_305 = 0xF015L;
            if (((*g_179) = (l_305 = l_286)))
            { /* block id: 190 */
                uint32_t **l_308 = (void*)0;
                (*g_307) = l_306;
                (*g_269) = ((**g_298) != l_308);
                return p_70;
            }
            else
            { /* block id: 194 */
                uint32_t *l_309 = &g_158;
                uint32_t ***l_317 = (void*)0;
                int32_t *l_319 = &g_320;
                int32_t **l_353 = (void*)0;
                int32_t **l_355 = &l_349;
                (*g_321) = (((*l_306) = ((*l_306) == ((*l_309) = 4294967290UL))) | (0x94BD295DL < (((uint16_t)(g_110 & ((((uint16_t)((uint16_t)(p_69 || ((*l_319) = (l_316 >= (l_317 == l_318)))) + (uint16_t)(g_163 & 8L)) << (uint16_t)g_198) | g_133) < g_3)) * (uint16_t)0xB3E9L) & 5L)));
                for (p_71 = 9; (p_71 < (-24)); p_71 -= 1)
                { /* block id: 201 */
                    if (p_69)
                    { /* block id: 202 */
                        if (p_70)
                            break;
                    }
                    else
                    { /* block id: 204 */
                        int32_t *l_325 = &g_46;
                        int32_t **l_326 = &l_306;
                        (*l_326) = l_325;
                    }
                    for (l_316 = (-29); (l_316 != 6); ++l_316)
                    { /* block id: 209 */
                        int32_t *l_331 = &g_332;
                        uint16_t *l_335 = (void*)0;
                        uint16_t *l_336 = &l_305;
                        (*g_179) = ((int16_t)((1L == (__builtin_ffsl(((*l_331) = (p_69 & p_69))) > 6L)) & p_70) % (int16_t)((*l_336) = ((int16_t)g_320 >> (int16_t)p_71)));
                        (*l_306) = p_69;
                        (*l_306) = (p_71 <= ((0xD12EL < (((uint16_t)g_133 * (uint16_t)(p_71 ^ __builtin_parity(p_69))) < func_72((*g_269), p_69))) > (-1L)));
                    }
                }
                if (((int32_t)(*g_45) % (int32_t)p_69))
                { /* block id: 217 */
                    int32_t *l_341 = (void*)0;
                    int32_t **l_346 = &l_306;
                    uint16_t l_352 = 0x0934L;
                    (*g_179) = (*g_269);
                    (*l_346) = func_90(func_90(func_90(l_341, (*g_307), ((int16_t)0xC8D7L >> (int16_t)p_71), (*g_179), g_158), l_341, (*l_319), p_70, p_71), l_344, g_110, l_345, l_305);
                    (*l_346) = (void*)0;
                    /* statement id: 220 */
                    assert (l_306 == 0);
                    for (g_158 = 7; (g_158 <= 5); g_158 -= 3)
                    { /* block id: 223 */
                        uint8_t *l_350 = &l_345;
                        uint32_t **l_351 = &l_309;
                        (*l_346) = func_90(((*g_307) = ((*l_346) = (*l_346))), l_349, ((*l_350) = p_69), (*l_349), p_70);
                        /* statement id: 227 */
                        assert (l_306 == &g_46);
                        (*l_349) = ((**l_346) = ((*l_344) = ((**g_298) == (l_351 = l_351))));
                        (*l_319) = p_71;
                        if (l_352)
                            break;
                    }
                    /* facts after for loop */
                    assert (g_269 == 0 || g_269 == &g_46);
                    assert (l_306 == &g_46 || l_306 == 0);
                }
                else
                { /* block id: 235 */
                    return l_305;
                }
                /* facts after branching */
                assert (g_269 == 0 || g_269 == &g_46);
                assert (l_306 == &g_46 || l_306 == 0);
                (*l_355) = l_319;
                /* statement id: 238 */
                assert (l_349 == &g_320);
            }
            /* facts after branching */
            assert (g_269 == 0 || g_269 == &g_46);
            assert (l_306 == &g_46 || l_306 == 0);
            assert (l_349 == &g_320);
        }
        else
        { /* block id: 240 */
            uint32_t **l_361 = &l_360;
            int16_t *l_362 = &g_110;
            int16_t *l_363 = &g_133;
            int16_t *l_364 = &g_365;
            int32_t **l_389 = (void*)0;
            int32_t **l_390 = &l_349;
            (*g_179) = ((*l_344) || ((int16_t)(((*l_364) = ((*l_363) = ((*l_362) = (-(int16_t)(l_359 != l_361))))) == p_69) + (int16_t)5UL));
            for (g_123 = 0; (g_123 != 42); ++g_123)
            { /* block id: 247 */
                int32_t *l_374 = &g_322;
                int32_t ***l_384 = (void*)0;
                int32_t **l_386 = &l_374;
                int32_t ***l_385 = &l_386;
                if ((((int32_t)((~(~((uint16_t)(1L != (*l_349)) << (uint16_t)15))) || 0x9ADD518CL) / (int32_t)p_70) == p_71))
                { /* block id: 248 */
                    int32_t **l_375 = &l_306;
                    uint32_t l_378 = 4294967292UL;
                    (*l_375) = l_374;
                    /* statement id: 249 */
                    assert (l_306 == &g_322);
                    l_379 = (((0x0FD85092L && (*l_306)) >= ((*l_344) >= p_71)) && ((int32_t)((*l_374) = (*g_269)) / (int32_t)__builtin_ffsl(l_378)));
                }
                else
                { /* block id: 252 */
                    int16_t l_382 = 0x46EDL;
                    (*g_269) = (**g_253);
                    (*l_344) = (((int16_t)l_382 >> (int16_t)(p_71 && (-(uint32_t)p_71))) > g_198);
                }
                (*l_374) = (((*l_385) = &l_306) == (l_387 = &g_269));
                /* statement id: 258 */
                assert (l_387 == &g_269);
                assert (l_386 == &l_306);
            }
            /* facts after for loop */
            assert (l_306 == &g_46 || l_306 == &g_322);
            assert (l_387 == &g_269 || l_387 == &g_179);
            (*l_390) = ((*l_387) = (void*)0);
            /* statement id: 261 */
            assert (g_179 == 0 || g_179 == &g_46);
            assert (g_269 == 0 || g_269 == &g_46);
            assert (l_349 == 0);
        }
        /* facts after branching */
        assert (g_179 == 0 || g_179 == &g_46);
        assert (g_269 == 0 || g_269 == &g_46);
        assert (l_306 == &g_46 || l_306 == &g_322 || l_306 == 0);
        assert (l_349 == 0 || l_349 == &g_320);
        assert (l_387 == &g_269 || l_387 == &g_179);
        (*g_45) = ((uint32_t)l_393 - (uint32_t)((p_69 | (!(((*l_360) = func_72(p_70, p_71)) != 0x9181E833L))) >= (-1L)));
        /* statement id: 264 */
        assert (g_179 == &g_46);
        assert (g_269 == &g_46);
    }
    /* facts after branching */
    //assert (g_297 == dangling || g_297 == &g_298);
    assert (l_306 == &g_46 || l_306 == &g_322 || l_306 == 0);
    assert (l_349 == 0 || l_349 == &g_320 || l_349 == &g_322);
    assert (l_387 == &g_269 || l_387 == &g_179);
    (*g_399) = ((*g_179) = ((int16_t)((*l_398) = ((*l_397) = (&p_71 != (void*)0))) << (int16_t)4));
    for (g_332 = (-9); (g_332 != 19); ++g_332)
    { /* block id: 272 */
        int32_t *l_402 = &g_320;
        (*l_387) = l_402;
    }
    /* facts after for loop */
    assert (g_179 == &g_320 || g_179 == &g_46);
    assert (g_269 == &g_320 || g_269 == &g_46);
    (*g_298) = l_318;
    return l_403;
}


/* ------------------------------------------ */
/* 
 * reads : g_158 g_45 g_46 g_133 g_261 g_268 g_110 g_253
 * writes: g_158 g_46 g_123 g_179 g_269
 */
inline static int16_t  func_72(int32_t  p_73, int32_t  p_74)
{ /* block id: 160 */
    int16_t l_257 = 7L;
    uint32_t *l_263 = &g_158;
    uint32_t **l_262 = &l_263;
    int32_t l_265 = 0x15EAAFD9L;
    int32_t **l_270 = &g_269;
    uint16_t *l_277 = &g_123;
    uint32_t l_278 = 0xC386943BL;
    int32_t *l_279 = &l_265;
    for (g_158 = 0; (g_158 > 35); ++g_158)
    { /* block id: 163 */
        uint16_t *l_260 = &g_123;
        int32_t l_264 = 0xDB9B34ADL;
        int32_t **l_266 = &g_179;
        if (l_257)
            break;
        (*g_45) = (*g_45);
        l_265 = ((uint16_t)((*l_260) = g_133) + (uint16_t)((g_261 != l_262) == l_264));
        (*g_268) = ((*l_266) = &l_264);
        /* statement id: 169 */
        assert (g_179 == &l_264);
        assert (g_269 == &l_264);
    }
    /* facts after for loop */
    //assert (g_179 == dangling || g_179 == &g_46 || g_179 == 0 || g_179 == &g_320);
    //assert (g_269 == dangling || g_269 == 0 || g_269 == &g_46 || g_269 == &g_320);
    (*l_270) = func_90(&l_265, ((*l_270) = &l_265), ((uint32_t)g_110 / (uint32_t)p_73), p_74, func_78(((((int16_t)0xC989L * (int16_t)((int16_t)1L >> (int16_t)p_73)) || ((*l_277) = 0x397FL)) && p_73), l_278, &l_265, l_279));
    /* statement id: 173 */
    assert (g_179 == &g_46);
    assert (g_269 == &g_46);
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads : g_46 g_253
 * writes: g_123 g_46 g_179
 */
static uint16_t  func_78(int32_t  p_79, uint16_t  p_80, int32_t * p_81, int32_t * p_82)
{ /* block id: 39 */
    int32_t *l_96 = &g_46;
    int32_t l_97 = 0x5DFEA44EL;
    int32_t **l_254 = &l_96;
    (*g_253) = func_90(p_82, (l_96 = p_81), l_97, l_97, p_80);
    /* statement id: 157 */
    //assert (l_96 == &g_46 || l_96 == &l_265);
    assert (g_179 == &g_46);
    (*l_254) = p_81;
    return (**l_254);
}


/* ------------------------------------------ */
/* 
 * reads : g_46
 * writes: g_123 g_46
 */
inline static int32_t * func_90(int32_t * p_91, int32_t * p_92, uint8_t  p_93, int32_t  p_94, uint32_t  p_95)
{ /* block id: 41 */
    int32_t **l_98 = (void*)0;
    int32_t **l_99 = (void*)0;
    int32_t **l_100 = (void*)0;
    int32_t *l_102 = (void*)0;
    int32_t **l_101 = &l_102;
    int32_t l_173 = 0xCF63C109L;
    int32_t *l_182 = (void*)0;
    uint16_t *l_248 = (void*)0;
    uint16_t *l_249 = (void*)0;
    uint16_t *l_250 = &g_123;
    (*l_101) = &g_46;
    /* statement id: 42 */
    assert (l_102 == &g_46);
    for (p_94 = 0; (p_94 != 14); p_94++)
    { /* block id: 45 */
        int32_t *l_115 = &g_46;
        int32_t l_161 = 4L;
    }
    (**l_101) = ((-(uint16_t)0x29D4L) >= ((uint32_t)(**l_101) + (uint32_t)(((*l_250) = p_95) < ((int16_t)p_94 << (int16_t)1))));
    p_92 = &p_94;
    /* statement id: 155 */
    assert (p_92 == &p_94);
    return &g_46;
    /* statement id: 156 */
    //assert (func_90_rv == &g_46);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_26();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_46, "g_46", print_hash_value);
    transparent_crc(g_110, "g_110", print_hash_value);
    transparent_crc(g_123, "g_123", print_hash_value);
    transparent_crc(g_133, "g_133", print_hash_value);
    transparent_crc(g_158, "g_158", print_hash_value);
    transparent_crc(g_163, "g_163", print_hash_value);
    transparent_crc(g_198, "g_198", print_hash_value);
    transparent_crc(g_203, "g_203", print_hash_value);
    transparent_crc(g_320, "g_320", print_hash_value);
    transparent_crc(g_322, "g_322", print_hash_value);
    transparent_crc(g_332, "g_332", print_hash_value);
    transparent_crc(g_365, "g_365", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 84
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 18
   depth: 3, occurrence: 1
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 3
   depth: 7, occurrence: 1
   depth: 8, occurrence: 3
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 15, occurrence: 1
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 125

XXX times a variable address is taken: 117
XXX times a pointer is dereferenced on RHS: 73
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 17
XXX times a pointer is dereferenced on LHS: 111
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 4
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 423

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 349
   level: 2, occurrence: 92
   level: 3, occurrence: 10
   level: 4, occurrence: 8
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 56
XXX number of pointers point to scalars: 69
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.2
XXX average alias set size: 1.32

XXX times a non-volatile is read: 399
XXX times a non-volatile is write: 265
XXX times a volatile is read: 12
XXX    times read thru a pointer: 0
XXX times a volatile is write: 8
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 113
XXX percentage of non-volatile access: 97.1

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 15
   depth: 2, occurrence: 8
   depth: 3, occurrence: 9
   depth: 4, occurrence: 11
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 17.5
XXX percentage an existing variable is used: 82.5
********************* end of statistics **********************/

