/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --no-float --math64 --inline-function --muls --no-safe-math --packed-struct --paranoid --no-pointers --no-structs --no-unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      604243068
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int64_t  func_29(void);
static int16_t  func_34(uint64_t  p_35, uint16_t  p_36, int32_t  p_37, uint32_t  p_38, uint32_t  p_39);
inline static const uint32_t  func_43(int32_t  p_44, int32_t  p_45, uint32_t  p_46);
static int64_t  func_47(const uint8_t  p_48, uint64_t  p_49);
static const int16_t  func_52(uint8_t  p_53);
inline static uint16_t  func_54(uint32_t  p_55);
inline static uint64_t  func_65(uint16_t  p_66);
inline static int16_t  func_88(const uint32_t  p_89, int64_t  p_90, uint8_t  p_91, const int64_t  p_92);
static int32_t  func_96(uint64_t  p_97);
inline static int16_t  func_100(int16_t  p_101, uint8_t  p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int64_t  func_29(void)
{ /* block id: 36 */
    int64_t l_30 = 0xB64FDA7EF5D870A3LL;
    int32_t l_31 = 0xAA165420L;
    int32_t l_237 = (-1L);
    int32_t l_238 = 0x23DC5B1DL;
    int32_t l_239 = 1L;
    int64_t l_240 = (-8L);
    int32_t l_241 = 8L;
    uint32_t l_250 = 18446744073709551615UL;
    uint8_t l_322 = 248UL;
    int16_t l_323 = 0xD47EL;
    uint32_t l_328 = 0xD5E7484EL;
    l_31 = l_30;
    l_31 = (((int16_t)func_34((l_31 > (!((int64_t)(func_43((func_47(l_30, ((int16_t)(((func_52(l_30) <= ((int32_t)l_30 + (int32_t)(l_241 = (((uint32_t)(((((int16_t)l_30 * (int16_t)7L) == (l_31 >= (l_239 = ((l_238 = (l_237 = (((l_30 ^ 0L) == 18446744073709551610UL) == (-8L)))) != 0x6197838CL)))) <= 1UL) != l_31) / (uint32_t)0x22CCF1A2L) != l_240)))) && l_240) | l_30) * (int16_t)l_240)) > l_240), l_250, l_240) <= l_240) % (int64_t)l_30))), l_250, l_30, l_250, l_250) / (int16_t)l_250) ^ l_240);
    l_241 = ((((((uint64_t)(func_54(l_322) <= l_239) - (uint64_t)((l_31 = func_65(l_237)) && l_323)) ^ l_322) == (l_323 < ((uint64_t)(((int32_t)l_237 + (int32_t)l_239) && 0xE292FD3435ECC137LL) + (uint64_t)l_237))) > l_239) ^ l_328);
    l_241 = ((((__builtin_clz(l_31) | ((uint32_t)l_328 / (uint32_t)(l_239 = 1UL))) || l_328) <= 0x08FFL) | (-(int64_t)l_31));
    return l_30;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_34(uint64_t  p_35, uint16_t  p_36, int32_t  p_37, uint32_t  p_38, uint32_t  p_39)
{ /* block id: 217 */
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const uint32_t  func_43(int32_t  p_44, int32_t  p_45, uint32_t  p_46)
{ /* block id: 171 */
    uint32_t l_261 = 0xD46ABB7CL;
    uint32_t l_287 = 18446744073709551615UL;
    int32_t l_293 = (-2L);
    for (p_44 = (-9); (p_44 != 0); p_44 += 1)
    { /* block id: 174 */
        int64_t l_255 = (-1L);
        int32_t l_256 = 0x2C683EECL;
        int32_t l_308 = 1L;
        if (p_44)
        { /* block id: 175 */
            l_256 = ((int16_t)__builtin_clz((l_255 = 1UL)) % (int16_t)p_46);
            for (p_46 = (-28); (p_46 < 42); p_46 += 1)
            { /* block id: 180 */
                int32_t l_259 = 1L;
                int32_t l_260 = 0x93BA542BL;
                l_260 = (l_259 = l_255);
                l_261 = 0L;
            }
            return l_256;
        }
        else
        { /* block id: 186 */
            int32_t l_262 = 0L;
            if (l_255)
                break;
            l_262 = (0x140FF6F9L || (l_262 >= (((uint16_t)(((uint32_t)(((uint16_t)func_52((l_256 = p_45)) >> (uint16_t)((uint32_t)((int16_t)1L << (int16_t)6) % (uint32_t)((int32_t)p_44 + (int32_t)0xA3AFCE4FL))) && (((((int16_t)(((int16_t)(((int16_t)(((uint16_t)l_262 + (uint16_t)((uint16_t)p_44 << (uint16_t)12)) & p_44) % (int16_t)l_261) ^ l_255) * (int16_t)p_45) != p_46) >> (int16_t)p_46) || 0L) < l_261) && 65532UL)) - (uint32_t)4294967286UL) >= p_44) << (uint16_t)l_255) || l_261)));
            l_256 = p_46;
        }
        if (p_44)
            break;
        if (l_287)
        { /* block id: 193 */
            uint64_t l_290 = 18446744073709551607UL;
            if ((((int32_t)(0xDDD0333103EE402FLL < l_290) / (int32_t)0x8037F3D1L) ^ ((uint16_t)(l_293 = (func_96(l_293) & (__builtin_popcountl(p_45) || (0x04C5C06FA9791142LL < p_45)))) / (uint16_t)l_290)))
            { /* block id: 195 */
                return l_255;
            }
            else
            { /* block id: 197 */
                int64_t l_302 = 0x1BE7830CF4673FFDLL;
                int32_t l_307 = 0L;
                l_308 = (p_44 | ((uint16_t)((uint32_t)((uint64_t)(l_302 = 18446744073709551614UL) - (uint64_t)((uint16_t)((uint16_t)(p_45 >= p_46) * (uint16_t)(l_290 != (l_293 = __builtin_parityl(l_290)))) / (uint16_t)(0xE5059A09FAE64170LL & p_44))) / (uint32_t)1L) << (uint16_t)l_307));
                l_308 = l_255;
            }
        }
        else
        { /* block id: 203 */
            uint64_t l_313 = 18446744073709551615UL;
            int32_t l_314 = (-1L);
            l_314 = ((uint64_t)p_46 % (uint64_t)((l_308 = ((int16_t)(((l_293 = (l_313 = (0x4343L || 0xFA4DL))) <= 0UL) > ((func_88((l_256 = p_45), p_46, p_44, p_45) >= 0x783FL) >= l_261)) << (int16_t)2)) && l_313));
            l_314 = func_96(l_255);
            l_314 = (l_308 = ((l_256 = __builtin_clzl(l_287)) >= ((uint32_t)(0L > ((uint64_t)func_65(p_44) - (uint64_t)(l_287 && p_44))) / (uint32_t)(((-(int32_t)((l_287 > p_45) <= 0x67B04CF6092038D5LL)) < 4294967295UL) && l_314))));
        }
    }
    p_44 = l_293;
    return l_293;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_47(const uint8_t  p_48, uint64_t  p_49)
{ /* block id: 155 */
    uint32_t l_248 = 0x30205D3DL;
    int32_t l_249 = 0xE0753CE6L;
    for (p_49 = 0; (p_49 < 54); p_49 += 1)
    { /* block id: 158 */
        int32_t l_244 = 0x4F027857L;
        if (p_48)
            break;
        for (l_244 = (-13); (l_244 == (-5)); l_244 += 1)
        { /* block id: 162 */
            uint8_t l_247 = 0x3FL;
            l_248 = (l_247 = l_244);
            if (l_248)
                continue;
            l_249 = p_49;
        }
        l_244 = __builtin_parityl(l_249);
    }
    return p_48;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_52(uint8_t  p_53)
{ /* block id: 38 */
    uint32_t l_56 = 0x3B9C309AL;
    int32_t l_59 = 0xD58E7EA1L;
    uint16_t l_82 = 1UL;
    int32_t l_84 = 0xEFE6B3E9L;
    int32_t l_85 = (-1L);
    int64_t l_93 = 0L;
    uint32_t l_94 = 0UL;
    l_56 = (func_54(p_53) != 1UL);
    for (p_53 = (-24); (p_53 == 28); p_53 += 1)
    { /* block id: 44 */
        int16_t l_64 = 0xCFEBL;
        int32_t l_83 = (-1L);
        int32_t l_230 = 0xA18CC621L;
        l_59 = __builtin_popcountll(p_53);
        l_85 = ((((uint16_t)(0xB95674643A64E785LL | (l_84 = ((l_64 != ((func_65(l_64) != ((int16_t)p_53 + (int16_t)0x1BBDL)) <= ((uint16_t)p_53 << (uint16_t)(l_83 = ((l_56 | ((int32_t)((l_59 = l_82) < 0x09E9L) - (int32_t)p_53)) ^ l_56))))) ^ 7UL))) % (uint16_t)l_64) == l_82) < 0x0869L);
        l_84 = (l_64 > ((int64_t)l_82 / (int64_t)(l_83 = 18446744073709551615UL)));
        l_230 = (l_83 = ((p_53 && l_84) <= (func_88(l_84, p_53, l_93, (l_59 = (p_53 >= ((0L >= (8L && l_94)) == l_64)))) > 1L)));
    }
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_54(uint32_t  p_55)
{ /* block id: 39 */
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint64_t  func_65(uint16_t  p_66)
{ /* block id: 46 */
    int32_t l_71 = 0x9DB2213AL;
    int32_t l_72 = (-3L);
    int32_t l_75 = 0L;
    l_75 = (p_66 && ((uint64_t)(l_72 = (((int16_t)(((l_71 = p_66) != (p_66 == p_66)) == p_66) * (int16_t)func_54(p_66)) > 0x490CE61FA7BB34E4LL)) + (uint64_t)((uint16_t)l_75 << (uint16_t)l_75)));
    return l_71;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_88(const uint32_t  p_89, int64_t  p_90, uint8_t  p_91, const int64_t  p_92)
{ /* block id: 58 */
    uint16_t l_95 = 0xA224L;
    int32_t l_103 = 0x53A1071FL;
    int32_t l_104 = 0xA7919EE4L;
    int32_t l_119 = (-3L);
    int32_t l_223 = (-2L);
    int32_t l_229 = 0xBE2FE8C5L;
    l_95 = 0x160806AFL;
    l_229 = func_96((l_95 > (((int16_t)(l_223 = func_100((l_104 = (l_95 | (l_103 = 0UL))), ((!((uint16_t)(((int16_t)(__builtin_ia32_crc32qi(((int32_t)((uint32_t)p_89 - (uint32_t)(l_95 || ((int16_t)(~((uint32_t)(((l_95 != 0x205C6C2786FE95B7LL) || p_92) != (l_119 = (l_95 || p_92))) + (uint32_t)l_95)) >> (int16_t)4))) % (int32_t)p_89), l_95) > p_92) - (int16_t)l_95) <= 0L) * (uint16_t)1UL)) & l_95))) / (int16_t)l_95) == p_91)));
    return p_90;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_96(uint64_t  p_97)
{ /* block id: 141 */
    uint16_t l_226 = 65535UL;
    int32_t l_227 = 0xCC96602DL;
    int32_t l_228 = 3L;
    l_228 = (l_227 = ((int64_t)(-1L) + (int64_t)l_226));
    return p_97;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_100(int16_t  p_101, uint8_t  p_102)
{ /* block id: 63 */
    uint32_t l_121 = 18446744073709551613UL;
    int32_t l_122 = 0xA0B358DDL;
    int32_t l_151 = 0L;
    int32_t l_152 = 0L;
    uint8_t l_163 = 0x9DL;
    int32_t l_191 = 5L;
lbl_154:
    l_122 = ((!p_101) >= l_121);
    for (p_102 = (-5); (p_102 != 18); p_102 += 1)
    { /* block id: 67 */
        uint64_t l_125 = 1UL;
        int32_t l_126 = 1L;
        int32_t l_153 = 0x1F2E98D3L;
        l_126 = (l_125 = p_102);
        if (((uint16_t)l_126 * (uint16_t)__builtin_parityl(l_122)))
        { /* block id: 70 */
            uint64_t l_135 = 4UL;
            int32_t l_150 = 0xB0255DAFL;
            l_153 = ((int64_t)(l_151 = (l_126 = ((int16_t)p_101 >> (int16_t)(((int64_t)(l_135 ^ ((int16_t)func_65(l_121) * (int16_t)p_102)) - (int64_t)l_135) != (((int32_t)(((uint16_t)((int32_t)(~(((int16_t)(((uint16_t)0x8AE5L * (uint16_t)(l_122 = (l_150 = (!l_121)))) || 1L) >> (int16_t)p_101) && l_150)) - (int32_t)p_101) - (uint16_t)l_121) | l_135) / (int32_t)0xA9B3FC62L) & 0xAC2FE199L))))) + (int64_t)l_152);
        }
        else
        { /* block id: 76 */
            if (p_101)
                goto lbl_154;
            for (l_126 = (-25); (l_126 <= (-29)); l_126 -= 9)
            { /* block id: 80 */
                if (l_122)
                    break;
            }
        }
        l_122 = ((uint64_t)((0x90AFEB5AB84A4DC8LL > (l_125 & p_102)) != (p_101 = p_101)) % (uint64_t)((int32_t)(1L && (__builtin_ia32_crc32qi(p_102, l_153) && ((int64_t)((l_163 > p_102) >= 0xC551L) % (int64_t)l_125))) + (int32_t)0L));
        if ((!func_65(p_101)))
        { /* block id: 86 */
            uint8_t l_165 = 1UL;
            l_153 = ((l_151 = (p_102 > (0x87D0CCF3L ^ (((((p_101 != l_165) == l_125) >= l_165) || 2L) | __builtin_ctz(p_102))))) && l_165);
            l_126 = p_101;
            l_126 = ((uint16_t)((((uint32_t)((uint16_t)__builtin_clz((0x90E88B3BL & (~l_165))) >> (uint16_t)p_101) + (uint32_t)((int16_t)p_101 >> (int16_t)4)) && ((p_101 || 0xC054L) == 3UL)) != 0UL) - (uint16_t)l_165);
            if (p_101)
                goto lbl_154;
        }
        else
        { /* block id: 92 */
            uint64_t l_177 = 18446744073709551608UL;
            int32_t l_188 = 3L;
            for (p_101 = 18; (p_101 <= (-3)); p_101 -= 1)
            { /* block id: 95 */
                uint32_t l_186 = 1UL;
                l_177 = 4L;
                for (l_126 = 21; (l_126 >= 0); l_126 -= 1)
                { /* block id: 99 */
                    if (p_101)
                    { /* block id: 100 */
                        l_186 = (((int16_t)p_102 * (int16_t)((int16_t)(-10L) - (int16_t)(((-2L) ^ ((l_153 > func_65(p_102)) <= (4294967291UL < (((uint16_t)p_102 + (uint16_t)(p_101 > 1L)) | l_177)))) || 1L))) && 0x1FD33E800ADB170ALL);
                        if (l_177)
                            break;
                        if (p_102)
                            break;
                    }
                    else
                    { /* block id: 104 */
                        uint32_t l_187 = 0UL;
                        l_187 = (0UL ^ l_186);
                    }
                }
                l_188 = l_186;
                l_126 = (l_186 ^ p_101);
            }
        }
    }
    if (((l_151 = ((uint64_t)0x262D627FB3206E96LL - (uint64_t)1L)) & ((l_122 = (l_163 < (4294967291UL != (l_191 = l_191)))) <= l_152)))
    { /* block id: 116 */
        const uint32_t l_196 = 0xDC5626D8L;
        int32_t l_197 = (-7L);
        if (p_102)
            goto lbl_154;
        for (l_191 = 0; (l_191 <= 20); l_191 += 1)
        { /* block id: 120 */
            int16_t l_208 = 0x6E3EL;
            int32_t l_209 = 1L;
            for (l_122 = 1; (l_122 <= (-16)); l_122 -= 8)
            { /* block id: 123 */
                int32_t l_202 = 0xE324BC14L;
                int32_t l_207 = 0x6BCCE899L;
                l_197 = (l_121 <= l_196);
                l_207 = (((((uint16_t)(l_202 = ((int16_t)l_163 >> (int16_t)11)) * (uint16_t)l_196) <= (l_209 = ((int16_t)0x4120L * (int16_t)(((int16_t)(p_101 = func_54(l_197)) * (int16_t)(((((l_207 < (l_208 <= ((0x2FAD472FL == p_102) > l_196))) < l_196) == l_122) > 6UL) < 0x29A36358L)) != p_102)))) >= p_102) ^ 2L);
            }
            l_197 = (l_209 = 1L);
        }
        l_151 = ((int16_t)(+(((int16_t)((uint16_t)((((int16_t)(l_152 && l_196) << (int16_t)5) | ((l_122 = l_121) > 0x1C8EEA47A0FBCE4BLL)) <= (0UL != ((uint16_t)0x2786L * (uint16_t)(p_101 >= ((((uint16_t)(l_151 | p_101) + (uint16_t)l_196) & l_197) >= l_196))))) - (uint16_t)l_197) * (int16_t)0x046BL) < l_196)) >> (int16_t)l_197);
        l_197 = p_101;
    }
    else
    { /* block id: 136 */
        return l_121;
    }
    return p_102;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_29();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 81
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 23
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 3
   depth: 12, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 2
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 266
XXX times a non-volatile is write: 102
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 85
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 26
   depth: 1, occurrence: 19
   depth: 2, occurrence: 23
   depth: 3, occurrence: 12
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4

XXX percentage a fresh-made variable is used: 22.9
XXX percentage an existing variable is used: 77.1
********************* end of statistics **********************/

