/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --no-float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --no-volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      4085155692
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
   int16_t  f1;
   int32_t  f2;
   int16_t  f3;
   uint32_t  f4;
   int32_t  f5;
   uint32_t  f6;
   uint16_t  f7;
   int16_t  f8;
};

union U1 {
   int16_t  f0;
   signed f1 : 1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static union U1  func_33(void);
inline static int32_t  func_38(int16_t  p_39, int32_t  p_40);
static int32_t  func_43(int32_t  p_44, int32_t  p_45);
inline static int32_t  func_46(uint16_t  p_47);
static uint32_t  func_61(uint32_t  p_62, int32_t  p_63, struct S0  p_64, union U1  p_65, union U1  p_66);
static uint32_t  func_67(struct S0  p_68);
static struct S0  func_71(uint8_t  p_72, int32_t  p_73, uint16_t  p_74);
static struct S0  func_78(int16_t  p_79, struct S0  p_80, int16_t  p_81, int32_t  p_82);
inline static uint32_t  func_85(union U1  p_86);
static struct S0  func_99(uint8_t  p_100);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_33(void)
{ /* block id: 36 */
    int32_t l_34 = (-3);
    int32_t l_37 = (-1);
    struct S0 l_602 = {0x9122CF60,0,0x3E63592C,0x50F2,5U,-1,4294967287U,0x0A01,0x3CE9};
    union U1 l_603 = {-1};
    for (l_34 = (-9); (l_34 >= 14); l_34 += 1)
    { /* block id: 39 */
        uint32_t l_54 = 0U;
        int32_t l_601 = 0xDBC2A577;
        l_37 = 0xA05D7627;
        l_601 = func_38(((uint16_t)(func_43((func_46((((uint32_t)4294967295U % (uint32_t)l_34) ^ __builtin_popcount(l_37))) & (((int16_t)l_37 + (int16_t)((((l_34 ^ (!0x7C76)) & func_46(l_34)) <= l_54) == l_54)) >= 0x3E24)), l_54) >= l_34) + (uint16_t)l_34), l_34);
        l_602 = l_602;
        l_601 = (l_54 > l_601);
    }
    return l_603;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_38(int16_t  p_39, int32_t  p_40)
{ /* block id: 357 */
    uint16_t l_589 = 0xB48E;
    struct S0 l_590 = {-10,-1,0x01DB38DE,4,1U,-1,0xF01C10BE,0x9472,0xF5B6};
    l_590 = func_78(l_589, l_590, p_40, (((((((func_67(l_590) ^ p_39) < 1U) != ((int16_t)(((int16_t)(((uint16_t)(((uint32_t)0xED9D5CA0 + (uint32_t)(p_40 == 1)) == 0xFF0BE7B2) >> (uint16_t)14) != 0x3F6401EC) - (int16_t)0xC3A9) && 0U) >> (int16_t)l_590.f0)) || l_590.f2) & p_40) <= l_590.f5) == 65533U));
    l_590.f5 = p_40;
    return p_39;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_43(int32_t  p_44, int32_t  p_45)
{ /* block id: 44 */
    uint32_t l_55 = 0xAA9D707D;
    struct S0 l_69 = {-1,0x2F90,1,1,1U,-1,4294967291U,65535U,0x8767};
    union U1 l_70 = {0x94AE};
    p_44 = l_55;
    if ((((!((p_45 < 0U) >= ((uint16_t)l_55 >> (uint16_t)(func_46(l_55) ^ (((uint32_t)func_61(func_67(l_69), l_55, l_69, l_70, l_70) - (uint32_t)4294967287U) && 7U))))) & 4294967295U) <= p_45))
    { /* block id: 337 */
        uint32_t l_579 = 0x985448A6;
        int32_t l_583 = 0x075C9DB5;
        for (l_69.f6 = (-12); (l_69.f6 <= 48); l_69.f6 += 1)
        { /* block id: 340 */
            uint32_t l_575 = 4U;
            int32_t l_580 = 0x027FEC2B;
            p_44 = ((uint16_t)((uint32_t)l_575 - (uint32_t)l_575) + (uint16_t)(p_45 < (((uint32_t)4294967295U + (uint32_t)(l_575 ^ ((-(uint32_t)(l_579 >= ((l_69.f2 != (__builtin_ctzl(p_44) && 1U)) > 2))) >= p_44))) ^ 65535U)));
            l_580 = l_69.f4;
            l_70.f1 = l_579;
        }
        for (p_44 = 1; (p_44 > (-23)); p_44 -= 1)
        { /* block id: 347 */
            l_583 = p_45;
        }
        return l_69.f0;
    }
    else
    { /* block id: 351 */
        int16_t l_586 = (-1);
        p_44 = ((uint16_t)(l_69.f7 | __builtin_popcountll(l_586)) >> (uint16_t)((int16_t)l_69.f0 >> (int16_t)__builtin_ia32_crc32qi(l_586, p_44)));
    }
    l_69.f5 = l_69.f5;
    p_44 = (0xF96FA1E3 < 0xB028FD97);
    return p_45;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_46(uint16_t  p_47)
{ /* block id: 41 */
    uint16_t l_50 = 0x3050;
    l_50 = (-1);
    return l_50;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_61(uint32_t  p_62, int32_t  p_63, struct S0  p_64, union U1  p_65, union U1  p_66)
{ /* block id: 48 */
    int32_t l_75 = 0;
    int32_t l_372 = (-10);
    uint32_t l_379 = 0xC2CC62D4;
    int16_t l_387 = (-1);
    struct S0 l_475 = {1,2,6,0xF34A,0x0F5F4E35,0x5016A622,1U,0U,2};
    uint32_t l_490 = 4294967290U;
    if (((p_64.f3 ^ func_67(func_71(l_75, (l_75 == ((int32_t)l_75 % (int32_t)l_75)), l_75))) <= ((((uint16_t)__builtin_ffsll(l_75) - (uint16_t)0xD69E) && 0xD7428BB2) <= l_75)))
    { /* block id: 226 */
        int32_t l_353 = 1;
        if (__builtin_bswap32(l_75))
        { /* block id: 227 */
            return p_64.f1;
        }
        else
        { /* block id: 229 */
            for (p_66.f0 = 0; (p_66.f0 != 0); ++p_66.f0)
            { /* block id: 232 */
                uint8_t l_354 = 0x77;
                p_65.f1 = (l_353 && l_354);
                p_64.f0 = (-1);
            }
        }
        l_372 = ((l_75 <= p_64.f8) <= (((int16_t)((uint16_t)((int32_t)((p_66.f0 | (l_353 <= ((int16_t)((uint16_t)l_353 % (uint16_t)((uint32_t)0U + (uint32_t)(__builtin_clz((((int16_t)(((int32_t)((-5) == l_353) - (int32_t)(((-(uint16_t)(p_64.f8 & 0xCE88)) & 0xD818842D) == 0xD3A678C5)) != l_75) >> (int16_t)l_353) == p_64.f6)) <= l_75))) + (int16_t)l_353))) && l_353) + (int32_t)0xDF71B75F) << (uint16_t)6) >> (int16_t)4) == p_64.f3));
        p_65.f1 = ((uint16_t)(((int16_t)(p_64.f5 & l_353) >> (int16_t)((l_353 == ((int32_t)l_372 + (int32_t)(p_64.f2 && ((1U ^ l_353) || ((p_64.f7 & p_64.f8) != 65526U))))) ^ 0x8A76)) | p_62) + (uint16_t)l_379);
        p_64.f5 = ((uint16_t)(l_379 > (((!(((uint16_t)(((int16_t)(-2) << (int16_t)0) && (__builtin_parityl(l_75) < (((l_387 & l_75) && ((int16_t)(p_62 || (l_353 > ((l_372 || 3) < l_379))) - (int16_t)1U)) >= 1))) << (uint16_t)11) && p_64.f3)) <= p_64.f1) || l_372)) >> (uint16_t)p_64.f6);
    }
    else
    { /* block id: 240 */
        int32_t l_390 = 0xD725E3DA;
        struct S0 l_409 = {0x41ED1B32,-9,8,0xDB93,1U,0,1U,0xDC58,0xEA51};
        union U1 l_428 = {-1};
        struct S0 l_494 = {-9,0x2A82,0xE6746414,0x2567,4294967286U,0xBACB7DD6,0x2D901D7B,65535U,0x48F9};
        uint32_t l_554 = 0x7AFC0151;
lbl_426:
        l_390 = (l_390 ^ 0x99B2589F);
        if (p_64.f4)
        { /* block id: 242 */
            uint16_t l_402 = 0U;
            if (((__builtin_bswap32((0U > 0xD387)) <= (((uint32_t)(p_64.f3 != ((int16_t)(l_390 < 0xDCA352F5) << (int16_t)((int16_t)(-1) >> (int16_t)15))) - (uint32_t)__builtin_popcountl((0x664F176A < p_64.f4))) < l_372)) == 5))
            { /* block id: 243 */
                uint8_t l_401 = 255U;
                if ((((uint32_t)(((int16_t)l_401 >> (int16_t)(l_402 <= p_65.f0)) || (((((int16_t)l_402 << (int16_t)7) <= p_64.f6) & (l_402 || ((int16_t)l_390 - (int16_t)l_402))) && 65535U)) + (uint32_t)(-10)) & 0xE9A1CB9B))
                { /* block id: 244 */
                    p_64.f5 = (((uint32_t)p_64.f7 + (uint32_t)p_64.f3) == l_390);
                }
                else
                { /* block id: 246 */
                    return p_62;
                }
                l_409 = func_99((0x415A30E4 & l_387));
            }
            else
            { /* block id: 250 */
                uint16_t l_418 = 0x1883;
                p_64 = p_64;
                for (l_390 = 19; (l_390 <= (-23)); l_390 -= 1)
                { /* block id: 254 */
                    for (p_64.f6 = 21; (p_64.f6 <= 48); ++p_64.f6)
                    { /* block id: 257 */
                        int16_t l_423 = (-8);
                        l_409 = func_99(((int16_t)(((uint16_t)p_62 + (uint16_t)(l_418 < p_64.f4)) | (((uint16_t)((uint16_t)l_418 << (uint16_t)2) >> (uint16_t)l_423) && (l_423 >= 4294967292U))) >> (int16_t)(p_64.f7 < p_64.f6)));
                        if (p_64.f6)
                            continue;
                    }
                    for (l_418 = 0; (l_418 <= 29); l_418 += 1)
                    { /* block id: 263 */
                        return l_409.f8;
                    }
                }
            }
            if (p_64.f6)
                goto lbl_426;
            l_372 = __builtin_ia32_crc32qi(((!(0x99DD450A != p_64.f0)) || p_64.f0), l_402);
        }
        else
        { /* block id: 270 */
            int16_t l_444 = 0x7303;
            struct S0 l_468 = {0x1749861E,-4,-1,-3,0xEB0496D7,0xAB7ACE29,0x258D435C,0xE2B9,1};
            int32_t l_518 = 0x6485BB7C;
            int32_t l_524 = 0xAC08E1C6;
            if (func_85(l_428))
            { /* block id: 271 */
                uint32_t l_455 = 0xCFD67873;
                struct S0 l_474 = {1,0x59FD,0xDAF2A16E,-5,1U,0,0U,65530U,0x3D08};
                p_64.f5 = ((((int16_t)((uint32_t)((int16_t)((uint16_t)((((int32_t)(__builtin_parity(((((int32_t)(l_387 >= (-(int32_t)p_64.f7)) + (int32_t)(((((int32_t)l_444 + (int32_t)(!(l_409.f2 > ((int16_t)__builtin_bswap64(((int32_t)((uint16_t)((uint16_t)(((((l_444 || (0xC6E2BD32 <= (~((((p_64.f5 >= func_67(p_64)) | l_387) ^ 2) <= l_390)))) || 9U) != p_64.f2) == l_409.f7) & l_455) >> (uint16_t)p_63) >> (uint16_t)l_455) % (int32_t)p_64.f0)) - (int16_t)p_64.f1)))) <= p_65.f0) > l_444) | p_64.f3)) & l_455) & l_444)) >= p_64.f3) + (int32_t)p_62) || 4294967295U) > p_63) + (uint16_t)l_455) >> (int16_t)l_379) + (uint32_t)0x05339CE0) >> (int16_t)10) >= l_387) != p_64.f3);
                for (l_428.f0 = 0; (l_428.f0 < 14); l_428.f0 += 2)
                { /* block id: 275 */
                    uint32_t l_471 = 0xF6ABB0AD;
                    for (l_387 = 0; (l_387 > 12); ++l_387)
                    { /* block id: 278 */
                        p_66.f1 = ((int16_t)((uint16_t)l_444 - (uint16_t)l_444) - (int16_t)0xBA2E);
                        l_372 = (((int16_t)func_67(p_64) >> (int16_t)15) > l_409.f2);
                        l_468 = func_78(((uint16_t)p_64.f5 + (uint16_t)0x33EE), p_64, l_444, p_64.f1);
                        p_64.f0 = ((0U != ((int32_t)__builtin_ia32_crc32qi(l_471, p_64.f2) % (int32_t)(-8))) && (l_468.f1 < p_64.f2));
                    }
                    p_64.f0 = l_455;
                }
                if (p_64.f2)
                { /* block id: 286 */
                    uint32_t l_472 = 3U;
                    p_65.f1 = (l_472 != (-(uint16_t)(((l_472 <= p_64.f0) & (l_468.f4 & ((p_63 != func_67(l_474)) > (p_64.f5 ^ l_390)))) || l_474.f3)));
                    p_64.f5 = __builtin_ctzl(l_409.f8);
                }
                else
                { /* block id: 289 */
                    l_468.f0 = (l_372 <= p_64.f0);
                    l_475 = l_409;
                }
                p_64.f5 = (((uint16_t)l_474.f5 << (uint16_t)1) < ((((((uint32_t)0xECC79834 - (uint32_t)0) >= (((int16_t)((-(uint32_t)(((uint16_t)0xFB52 >> (uint16_t)15) ^ ((int16_t)l_455 << (int16_t)2))) >= (p_64.f1 | (((int32_t)(-1) + (int32_t)(l_409.f4 | ((~p_62) < p_64.f3))) & l_409.f7))) - (int16_t)0x3EF9) && 0x17E4F561)) >= p_64.f0) != l_490) || 0U));
            }
            else
            { /* block id: 294 */
                int32_t l_523 = (-2);
                for (l_409.f5 = 1; (l_409.f5 <= 26); l_409.f5 += 5)
                { /* block id: 297 */
                    struct S0 l_493 = {0xDE2CD437,0xF3C3,0xFB0633D2,0x5E4A,1U,-6,0x6067CA7E,0U,0xCAF5};
                }
                l_409 = func_99(l_523);
            }
            for (l_409.f8 = (-3); (l_409.f8 <= 10); l_409.f8 += 8)
            { /* block id: 320 */
                int32_t l_532 = 0xC12BECA3;
                p_66.f1 = ((l_468.f3 != ((int16_t)((!(~0x06FB)) == l_532) - (int16_t)l_409.f5)) ^ ((uint32_t)l_494.f6 + (uint32_t)((int16_t)(-8) % (int16_t)__builtin_clzll(l_494.f7))));
                l_524 = (l_468.f7 && __builtin_ffsl(l_532));
            }
        }
        for (l_409.f1 = 0; (l_409.f1 < (-1)); l_409.f1 -= 1)
        { /* block id: 327 */
            uint16_t l_553 = 0x0F03;
            uint32_t l_568 = 0xF312E624;
            if (p_64.f0)
                break;
            p_64.f5 = ((int16_t)((l_379 != ((func_46((((int16_t)(l_475.f0 == (l_409.f8 || p_63)) >> (int16_t)((int16_t)(-6) >> (int16_t)6)) ^ (((int16_t)((((int32_t)((((l_475.f0 < ((uint16_t)(0x5D5D54A9 <= l_75) - (uint16_t)l_494.f6)) ^ p_64.f6) <= l_379) ^ l_553) + (int32_t)p_64.f7) <= 1U) & p_64.f4) >> (int16_t)12) <= l_554))) >= 0U) != 0x6CE4)) >= l_553) >> (int16_t)p_62);
            l_475 = func_99(((((!(((uint16_t)((uint32_t)((int16_t)(((uint16_t)p_64.f1 << (uint16_t)(7 <= (((uint16_t)(p_63 | l_553) - (uint16_t)((__builtin_ctzl(p_64.f2) != p_64.f2) != ((uint16_t)(p_64.f4 | l_568) - (uint16_t)p_64.f3))) ^ l_494.f0))) < p_64.f5) >> (int16_t)p_64.f4) - (uint32_t)l_475.f5) % (uint16_t)l_409.f3) | 65535U)) < p_64.f6) ^ (-1)) ^ l_568));
            if (l_490)
                break;
        }
    }
    p_64.f0 = l_475.f0;
    l_475.f5 = p_64.f8;
    return p_64.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_67(struct S0  p_68)
{ /* block id: 46 */
    return p_68.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_71(uint8_t  p_72, int32_t  p_73, uint16_t  p_74)
{ /* block id: 49 */
    union U1 l_87 = {-2};
    struct S0 l_96 = {0x718CA402,0,3,-5,1U,7,0x53D9B4DC,1U,0x6182};
    struct S0 l_132 = {0x55A02C1B,4,0xCDDF05FF,7,0x06D60A08,0x2B8B245C,0U,65534U,0xEBAE};
    uint8_t l_222 = 1U;
lbl_319:
    l_96 = func_78((p_73 || (p_72 & ((((int32_t)0xA1FE0AFD % (int32_t)func_85(l_87)) >= p_72) != l_87.f0))), l_96, func_46(p_74), p_73);
    if (((-1) ^ (l_87.f0 == l_96.f5)))
    { /* block id: 77 */
        uint32_t l_128 = 4U;
        int32_t l_134 = 0xF31D0C90;
        struct S0 l_171 = {0x783F8197,1,0x35077A8C,-5,0xFCFD5121,0x4F299C82,1U,65535U,0x706C};
        uint8_t l_248 = 0xF7;
        union U1 l_260 = {1};
        int32_t l_279 = 0xBC47171A;
        uint32_t l_280 = 0U;
        uint16_t l_284 = 65535U;
        if (__builtin_ffsll(((((-(uint16_t)p_74) <= p_74) | ((int16_t)l_128 - (int16_t)l_96.f5)) & p_73)))
        { /* block id: 78 */
            struct S0 l_131 = {0xCF38B772,-8,0x01D75DE8,0xEC1B,8U,0x71D16DB7,0x975BB608,1U,1};
            for (l_96.f7 = 0; (l_96.f7 != 34); l_96.f7 += 1)
            { /* block id: 81 */
                uint32_t l_133 = 0xBD1CFCE0;
                l_132 = l_131;
                l_134 = l_133;
                if (l_133)
                    continue;
            }
            l_131.f0 = p_74;
            l_134 = p_73;
            if (__builtin_clz(((int16_t)((uint16_t)p_72 >> (uint16_t)4) + (int16_t)((~(l_131.f6 | (p_73 || ((((int16_t)p_73 << (int16_t)10) ^ __builtin_ctz(((p_73 & (__builtin_bswap64((func_67(l_131) > (l_132.f8 > l_131.f2))) < p_73)) != 0x5094))) < l_132.f1)))) != p_72))))
            { /* block id: 88 */
                int32_t l_148 = 0;
                struct S0 l_192 = {0xAD9C877E,6,-7,0xEE50,4294967295U,4,0x96AD940D,0x5DD2,0x7386};
lbl_191:
                for (l_132.f3 = 0; (l_132.f3 <= 16); l_132.f3 += 1)
                { /* block id: 91 */
                    int32_t l_164 = 0x287346C3;
                    for (l_132.f5 = 26; (l_132.f5 < (-11)); l_132.f5 -= 1)
                    { /* block id: 94 */
                        int16_t l_157 = 0x6092;
                        l_134 = ((uint32_t)p_72 - (uint32_t)l_148);
                        p_73 = ((-(int32_t)((uint32_t)(((~l_96.f2) < ((uint32_t)__builtin_ctzll(((int16_t)(l_157 == ((int16_t)l_148 << (int16_t)((int16_t)(p_74 & __builtin_ctzll(p_72)) + (int16_t)(((int16_t)l_164 % (int16_t)p_74) >= __builtin_clzl(p_73))))) % (int16_t)p_73)) - (uint32_t)l_96.f1)) >= l_164) - (uint32_t)l_96.f8)) != 0x199F);
                    }
                }
                for (l_132.f7 = 9; (l_132.f7 == 56); l_132.f7 += 1)
                { /* block id: 101 */
                    int16_t l_189 = 0xF4A9;
                    p_73 = ((int16_t)(p_72 < p_72) >> (int16_t)(p_72 ^ ((uint32_t)(0xB59A6631 ^ p_72) + (uint32_t)p_73)));
                    l_171 = l_132;
                    l_96 = l_131;
                    if ((((uint16_t)4U % (uint16_t)((int16_t)((int32_t)((((1 ^ 0x86712C95) == p_72) != 5) || ((~((p_72 < ((((int16_t)l_128 >> (int16_t)((__builtin_ctz(p_74) || p_72) & p_73)) & l_96.f5) >= 0x5377)) & l_131.f1)) == p_73)) % (int32_t)p_73) << (int16_t)l_148)) ^ l_171.f3))
                    { /* block id: 105 */
                        union U1 l_183 = {0x6FB8};
                        p_73 = (func_67(l_131) && (((p_73 <= ((int16_t)func_85(l_183) >> (int16_t)8)) > ((((uint32_t)(-(uint16_t)(((0xD4E5 || (~(l_131.f1 <= (((-(uint16_t)l_189) >= (3U <= 0)) ^ 65531U)))) ^ l_183.f0) >= l_148)) - (uint32_t)0xB0749740) || l_148) && 1)) && (-9)));
                        l_183.f1 = (!l_189);
                        if (l_131.f1)
                            goto lbl_191;
                    }
                    else
                    { /* block id: 109 */
                        l_192 = l_171;
                        return l_131;
                    }
                }
                return l_171;
            }
            else
            { /* block id: 115 */
                for (l_131.f0 = 0; (l_131.f0 != 26); ++l_131.f0)
                { /* block id: 118 */
                    p_73 = (((int16_t)l_171.f6 >> (int16_t)10) | (((-4) && p_74) <= ((int16_t)((!l_96.f5) == ((int32_t)((p_74 > l_96.f0) ^ ((((0xE40D <= (p_72 == 1)) == l_96.f6) >= l_132.f0) ^ l_131.f0)) - (int32_t)0xA94FD2C1)) % (int16_t)65531U)));
                    return l_132;
                }
            }
        }
        else
        { /* block id: 123 */
            int32_t l_216 = (-1);
            union U1 l_237 = {-10};
            struct S0 l_269 = {-1,8,-9,0xD64F,0x073FBF91,0,1U,0x4BFE,0};
            if ((l_96.f1 >= ((int16_t)__builtin_clz((((((int16_t)((int16_t)((uint16_t)((uint16_t)l_171.f6 << (uint16_t)((int16_t)0xF503 << (int16_t)3)) >> (uint16_t)(((uint32_t)0xCC4FDDAE * (uint32_t)(l_216 < l_87.f0)) ^ l_216)) + (int16_t)((-(int32_t)__builtin_ffs(l_171.f1)) & l_87.f0)) << (int16_t)11) & l_171.f2) | l_96.f4) || 0xDA8FA795)) << (int16_t)l_171.f2)))
            { /* block id: 124 */
                struct S0 l_223 = {0xE6C04E2F,0,0x926D8D12,0,0x6EC9F885,-4,4294967291U,0x3EFB,0x46B9};
lbl_232:
                if (((uint16_t)l_216 << (uint16_t)l_216))
                { /* block id: 125 */
                    l_96.f5 = (p_74 >= ((int16_t)__builtin_parityl(l_96.f8) >> (int16_t)10));
                }
                else
                { /* block id: 127 */
                    if ((l_222 || l_216))
                    { /* block id: 128 */
                        l_132.f5 = p_73;
                        return l_223;
                    }
                    else
                    { /* block id: 131 */
                        uint32_t l_224 = 0U;
                        int32_t l_231 = 0x3167A903;
                        l_132 = func_99((((l_224 == l_224) == (-3)) >= ((uint16_t)(p_72 < p_74) >> (uint16_t)7)));
                        p_73 = 3;
                        p_73 = ((uint16_t)(p_74 || 1) - (uint16_t)((uint16_t)(l_171.f6 || p_73) + (uint16_t)p_72));
                        l_231 = p_73;
                    }
                }
                l_134 = p_74;
                if (l_132.f4)
                    goto lbl_232;
                p_73 = ((uint16_t)((uint16_t)l_134 - (uint16_t)(__builtin_clzl(l_132.f4) != 0x6928D4B4)) << (uint16_t)12);
            }
            else
            { /* block id: 141 */
                uint8_t l_240 = 0U;
                if (((0 && (((((((func_85(l_237) < (l_171.f6 | (p_74 != l_216))) && ((uint32_t)(((4294967287U & l_171.f0) ^ l_240) & l_237.f0) + (uint32_t)l_132.f6)) <= l_240) == 0x8B1A) || p_72) && (-4)) | 1U)) > 3U))
                { /* block id: 142 */
                    union U1 l_245 = {1};
                    p_73 = ((int16_t)((((uint16_t)l_132.f3 >> (uint16_t)6) > func_85(l_245)) >= ((p_74 > ((uint16_t)(l_248 == p_72) - (uint16_t)((int16_t)p_72 >> (int16_t)3))) != p_74)) - (int16_t)((l_216 && p_74) != l_171.f2));
                }
                else
                { /* block id: 144 */
                    uint16_t l_255 = 65535U;
                    int32_t l_272 = 0;
                    int32_t l_281 = 0x88FA0A62;
                    l_171 = func_78(((uint16_t)p_74 - (uint16_t)((((int16_t)(p_72 ^ l_240) >> (int16_t)7) != l_132.f0) != __builtin_clzll(l_255))), func_78(l_171.f6, l_171, p_73, p_73), p_72, p_72);
                    if ((((int16_t)((uint32_t)p_73 + (uint32_t)(l_240 != __builtin_parityl(func_46((0x823D53BC < (func_85(l_260) <= ((l_248 | l_240) & ((((p_72 >= ((int16_t)(__builtin_ctzl(((((int32_t)((uint16_t)l_240 >> (uint16_t)10) + (int32_t)p_72) < l_255) != (-9))) >= l_96.f5) >> (int16_t)5)) && p_73) & 65531U) != p_72)))))))) >> (int16_t)15) > l_237.f0))
                    { /* block id: 146 */
                        l_96 = l_269;
                        l_132 = func_78(p_73, l_132, (l_96.f5 > (-5)), l_240);
                        l_237.f1 = ((uint16_t)l_132.f7 >> (uint16_t)8);
                        l_171.f5 = (((func_67(func_99(l_272)) & ((uint16_t)p_74 >> (uint16_t)p_72)) ^ (((p_74 | l_132.f5) < (((uint32_t)l_171.f7 % (uint32_t)((uint16_t)0x40A5 << (uint16_t)p_72)) > l_279)) | l_272)) || l_171.f2);
                    }
                    else
                    { /* block id: 151 */
                        struct S0 l_285 = {-1,-8,0xFBC3B89F,-1,0x28292101,1,8U,65530U,0x2A75};
                        l_281 = (l_280 >= p_72);
                        l_285 = func_78(p_73, l_269, (((l_240 >= ((((uint32_t)l_284 % (uint32_t)func_67(l_171)) | 0xF841FF86) & (1U < (func_67(l_171) && p_73)))) & l_284) | l_255), l_272);
                    }
                    l_281 = l_171.f1;
                    p_73 = ((int16_t)l_272 - (int16_t)0x512E);
                }
                if (((l_279 > p_74) | (((int16_t)p_73 >> (int16_t)((uint16_t)(-(uint32_t)(p_72 ^ (0x090C > 2))) % (uint16_t)l_240)) | l_280)))
                { /* block id: 158 */
                    uint16_t l_295 = 0x9526;
                    l_134 = (p_72 ^ __builtin_clzl(l_240));
                    for (l_171.f2 = 8; (l_171.f2 < 8); l_171.f2 += 2)
                    { /* block id: 162 */
                        l_295 = l_132.f1;
                    }
                    p_73 = ((int16_t)(l_295 == (0xC25E < ((int32_t)0xB3167490 + (int32_t)((int16_t)(((__builtin_ctzl((p_73 <= p_73)) ^ __builtin_ffsll(__builtin_ctzll(l_216))) || p_73) == l_295) % (int16_t)l_295)))) - (int16_t)l_240);
                }
                else
                { /* block id: 166 */
                    int32_t l_304 = (-1);
                    for (l_132.f2 = (-28); (l_132.f2 >= (-19)); l_132.f2 += 7)
                    { /* block id: 169 */
                        if (l_304)
                            break;
                        if (l_304)
                            continue;
                        p_73 = (((int16_t)(((uint16_t)0x7028 - (uint16_t)((-(uint32_t)p_72) <= l_304)) <= ((uint32_t)l_132.f4 - (uint32_t)((l_304 < (0x49218AC6 | ((uint32_t)(l_269.f1 ^ 8U) - (uint32_t)(~0xC504)))) & l_269.f3))) + (int16_t)0xF5EE) < l_128);
                    }
                }
                l_171 = l_171;
            }
            for (l_132.f2 = (-3); (l_132.f2 != (-11)); l_132.f2 -= 1)
            { /* block id: 179 */
                p_73 = 0xD657E7D9;
                for (l_132.f3 = 0; (l_132.f3 <= (-29)); l_132.f3 -= 1)
                { /* block id: 183 */
                    int32_t l_322 = 0x833B5928;
                    if (l_96.f3)
                        goto lbl_319;
                    l_322 = (((0x5FABE88D && 0) && p_73) || __builtin_popcountl((l_87.f0 == ((int16_t)((l_222 >= (l_269.f8 ^ (l_322 == l_171.f7))) || l_322) << (int16_t)p_72))));
                    for (l_132.f1 = 0; (l_132.f1 == (-4)); l_132.f1 -= 1)
                    { /* block id: 188 */
                        p_73 = 0;
                    }
                }
            }
            l_96 = l_269;
        }
        p_73 = p_74;
        for (l_171.f3 = 0; (l_171.f3 >= 13); ++l_171.f3)
        { /* block id: 198 */
            uint32_t l_327 = 0U;
            p_73 = l_327;
            p_73 = l_327;
            l_87.f1 = p_72;
        }
        for (l_280 = (-15); (l_280 == 18); ++l_280)
        { /* block id: 205 */
            uint8_t l_330 = 0x94;
            int32_t l_331 = 0x6E3BB352;
            struct S0 l_332 = {0,-10,-1,0x0136,0U,0x9D4712D9,0U,0xD181,0x2BCC};
            l_331 = __builtin_clzl(l_330);
            return l_332;
        }
    }
    else
    { /* block id: 209 */
        int32_t l_333 = 1;
        uint16_t l_343 = 0x69BB;
        int32_t l_344 = 0;
        p_73 = l_96.f3;
        p_73 = ((0xC421 > (((((-5) & (0x2387 <= (0x49BD4E48 > p_72))) || ((l_96.f6 & ((func_46(p_72) || (l_333 || l_333)) < 0x4B80B160)) & l_132.f4)) & l_222) <= p_72)) | p_74);
        if (l_333)
        { /* block id: 212 */
            p_73 = p_72;
        }
        else
        { /* block id: 214 */
            uint16_t l_345 = 1U;
            struct S0 l_348 = {0x8785AC9E,0x394C,0xB00247E3,0,0xE2E04268,0,0xB0D4290D,0xAD23,0x7260};
            l_344 = ((int32_t)0x6011E4A6 + (int32_t)((((4U > l_333) && ((-(int16_t)((int16_t)(((uint16_t)((p_73 | l_333) != ((p_74 < (((int16_t)(0xDA0E0BFF == 0x6EE21C4F) >> (int16_t)p_73) <= p_74)) > l_343)) >> (uint16_t)12) <= l_343) - (int16_t)l_96.f8)) && 65530U)) > (-1)) & (-1)));
            l_344 = (0xECCB ^ l_345);
            p_73 = func_46(p_74);
            for (l_96.f5 = 4; (l_96.f5 == (-24)); l_96.f5 -= 2)
            { /* block id: 220 */
                return l_348;
            }
        }
    }
    return l_132;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_78(int16_t  p_79, struct S0  p_80, int16_t  p_81, int32_t  p_82)
{ /* block id: 53 */
    struct S0 l_124 = {0x6C13A8A9,0,-1,0x101C,0xD3AFC3C3,-1,0x6189FD49,0U,-7};
    for (p_80.f4 = 0; (p_80.f4 != 6); p_80.f4 += 6)
    { /* block id: 56 */
        uint16_t l_101 = 0U;
        l_124 = func_99(l_101);
    }
    return l_124;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_85(union U1  p_86)
{ /* block id: 50 */
    int16_t l_92 = 0xFDF2;
    struct S0 l_95 = {-3,-7,0x70E0EEEF,0x617F,0x172C1376,0x207283BD,0x55D51B5D,0xEC32,0xDF25};
    p_86.f1 = ((0xAF72 != ((uint16_t)p_86.f0 >> (uint16_t)7)) | ((uint16_t)((l_92 == (0xB910F879 ^ p_86.f0)) | p_86.f0) - (uint16_t)(((__builtin_clzll((p_86.f0 | ((uint32_t)func_67(l_95) % (uint32_t)0xC0CAA660))) == 0xB79D8757) == l_95.f7) | 0xD67D)));
    return p_86.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_99(uint8_t  p_100)
{ /* block id: 57 */
    struct S0 l_102 = {0xDF17F541,8,0xD9B7196F,0xAD4E,4294967294U,0x9647BF50,4294967295U,0U,7};
    uint16_t l_113 = 1U;
    int16_t l_119 = 9;
    l_102 = l_102;
    l_102.f5 = (0x8389 <= 0x964C);
    for (l_102.f3 = (-14); (l_102.f3 > 22); ++l_102.f3)
    { /* block id: 62 */
        uint32_t l_114 = 1U;
        int32_t l_120 = 0xA8A8F1CD;
        l_120 = (((uint16_t)(65535U >= (((uint16_t)65530U + (uint16_t)(((uint16_t)l_102.f5 + (uint16_t)((int16_t)p_100 % (int16_t)(l_113 || l_114))) < ((int32_t)(!l_102.f4) % (int32_t)(p_100 ^ ((!((p_100 < 4) >= l_114)) ^ l_102.f7))))) != p_100)) >> (uint16_t)9) != l_119);
    }
    for (p_100 = 19; (p_100 >= 2); p_100 -= 6)
    { /* block id: 67 */
        int32_t l_123 = 0x6003B377;
        l_102.f0 = 0x6358B857;
        if (l_123)
            break;
        return l_102;
    }
    return l_102;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 92
   depth: 1, occurrence: 22
XXX total union variables: 8

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 8
breakdown:
   indirect level: 0, occurrence: 8
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 11
XXX times a single bitfield on LHS: 11
XXX times a single bitfield on RHS: 4

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 179
   depth: 2, occurrence: 48
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 4
   depth: 7, occurrence: 3
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 7
   depth: 15, occurrence: 6
   depth: 16, occurrence: 2
   depth: 17, occurrence: 3
   depth: 18, occurrence: 3
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 3
   depth: 37, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 619
XXX times a non-volatile is write: 137
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 4

XXX stmts: 181
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 27
   depth: 2, occurrence: 32
   depth: 3, occurrence: 31
   depth: 4, occurrence: 31
   depth: 5, occurrence: 31

XXX percentage a fresh-made variable is used: 16.3
XXX percentage an existing variable is used: 83.7
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

