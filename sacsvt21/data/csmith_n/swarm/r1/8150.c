/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --volatile-pointers --no-const-pointers --global-variabless --builtins
 * Seed:      2270555976
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   const uint32_t  f1;
   int32_t  f2;
   const int8_t  f3;
   unsigned f4 : 1;
   uint32_t  f5;
   float  f6;
};

union U1 {
   unsigned f0 : 8;
};

/* --- GLOBAL VARIABLES --- */
static float g_3 = (-0x1.7p-1);
static int32_t g_7 = 0;
static struct S0 g_42[4][5] = {{{0x214F,1U,0,-1,0,0x5161E33E,-0x10.0p+1},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1}},{{0x214F,1U,0,-1,0,0x5161E33E,-0x10.0p+1},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1}},{{0x214F,1U,0,-1,0,0x5161E33E,-0x10.0p+1},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1}},{{0x214F,1U,0,-1,0,0x5161E33E,-0x10.0p+1},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{3,4294967294U,0x38140A97,-3,0,0U,0x1.93F045p+30},{0,0x653649D9,4,4,0,0xB3395CC9,0x0.0p+1}}};
static const int32_t *g_63[2] = {&g_7,&g_7};
static const int32_t ** volatile g_62[4] = {&g_63[1],&g_63[1],&g_63[1],&g_63[1]};
static const int32_t ** volatile g_64 = &g_63[1];/* VOLATILE GLOBAL g_64 */
static int32_t *g_87 = &g_7;
static int32_t **g_86 = &g_87;
static const union U1 g_101 = {7U};
static union U1 g_105[5] = {{0xA24168CB},{0xA24168CB},{0xA24168CB},{0xA24168CB},{0xA24168CB}};
static float *g_114 = &g_42[0][0].f6;
static float * volatile *g_113 = &g_114;
static struct S0 g_119 = {-1,1U,-7,0xE4,0,0xDC5D4999,0xF.FA4E93p-53};
static int32_t g_149 = 0xDE1A35A1;
static const volatile float * volatile * volatile **g_257 = (void*)0;
static const volatile float g_262 = 0x3.1p-1;/* VOLATILE GLOBAL g_262 */
static const volatile float * volatile g_261 = &g_262;/* VOLATILE GLOBAL g_261 */
static const volatile float * volatile * volatile g_260 = &g_261;/* VOLATILE GLOBAL g_260 */
static struct S0 *g_335 = &g_42[0][0];
static struct S0 ** volatile g_334 = &g_335;/* VOLATILE GLOBAL g_334 */
static union U1 * volatile *g_360 = (void*)0;
static struct S0 ** volatile g_386 = &g_335;/* VOLATILE GLOBAL g_386 */
static int32_t ** volatile g_389 = (void*)0;/* VOLATILE GLOBAL g_389 */


/* --- FORWARD DECLARATIONS --- */
inline static uint32_t  func_30(void);
static float  func_33(uint32_t  p_34, int16_t  p_35, int16_t  p_36, struct S0  p_37);
inline static float  func_45(const int16_t  p_46, uint32_t  p_47, uint16_t  p_48);
static int16_t  func_54(const int32_t  p_55);
inline static int32_t * func_58(int8_t  p_59, int32_t * p_60, const int32_t  p_61);
inline static int16_t  func_77(int32_t * p_78, uint32_t  p_79, int32_t * p_80);
inline static int32_t * func_81(int32_t ** p_82);
inline static int32_t ** func_83(int32_t ** p_84, int32_t * p_85);
static int32_t * func_88(int32_t ** p_89, int8_t  p_90, uint16_t  p_91, const union U1  p_92);
static int32_t ** func_93(uint32_t  p_94);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_7 g_42 g_119.f2 g_87 g_260 g_261 g_262 g_114 g_86 g_64 g_113 g_101.f0 g_119.f0
 * writes: g_119.f2 g_7 g_42.f6 g_63 g_119.f0
 */
inline static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_38 = 0x8F5537C5;
    uint32_t l_41 = 5U;
    const float l_365 = 0x0.2p-1;
    int32_t *l_390 = (void*)0;
    int32_t l_392 = (-1);
lbl_396:
    (*g_114) = (((float)func_33((g_7 | l_38), ((65534U | g_7) <= ((uint32_t)(0xA8DB == l_38) - (uint32_t)l_41)), ((0x6B2C4EB0 >= g_7) > g_7), g_42[0][0]) - (float)l_365) < l_41);
    if ((**g_86))
    { /* block id: 283 */
        float l_368 = 0x6.6p-1;
        int32_t l_380 = 0x0B9359FE;
        for (l_41 = (-25); (l_41 <= 38); l_41 += 9)
        { /* block id: 286 */
            int8_t l_373 = 0xD4;
            const float *l_376 = &l_365;
            const float **l_375 = &l_376;
            const float ***l_374 = &l_375;
            int32_t **l_387 = (void*)0;
            (*g_64) = func_81(func_93((g_42[0][0].f4 || 0x05E9)));
            for (g_119.f2 = 1; (g_119.f2 >= 0); g_119.f2 -= 1)
            { /* block id: 290 */
                uint32_t l_381 = 1U;
                if (((int16_t)1 >> (int16_t)10))
                { /* block id: 291 */
                    float ***l_377 = (void*)0;
                    int i;
                    (*g_114) = ((func_45(l_38, func_54(((uint32_t)(l_373 ^ (0x242BF8CB == l_373)) % (uint32_t)5U)), ((l_374 == l_377) && ((int16_t)l_380 % (int16_t)0x262E))) == l_381) != 0xF.73E1BCp+51);
                }
                else
                { /* block id: 293 */
                    (*g_87) = l_381;
                }
                for (g_119.f0 = 0; (g_119.f0 <= 1); g_119.f0 += 1)
                { /* block id: 298 */
                    if (l_38)
                        break;
                }
            }
        }
        (**g_113) = l_380;
        (*g_114) = __builtin_parityl((!g_101.f0));
    }
    else
    { /* block id: 319 */
        return l_392;
    }
    (**g_86) = (((uint16_t)(g_119.f0 || 0x6CB6) >> (uint16_t)g_42[0][0].f4) < (~__builtin_ffsll(__builtin_bswap32(g_42[0][0].f5))));
    if (l_392)
        goto lbl_396;
    return g_101.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_119.f2 g_87 g_260 g_261 g_262
 * writes: g_119.f2 g_7
 */
static float  func_33(uint32_t  p_34, int16_t  p_35, int16_t  p_36, struct S0  p_37)
{ /* block id: 37 */
    const uint32_t l_56 = 0x2D78BEA8;
    float l_357 = 0x8.1011CAp+28;
    for (p_34 = 0; (p_34 < 29); p_34 += 1)
    { /* block id: 40 */
        int32_t *l_336 = (void*)0;
        float l_338[1];
        int32_t l_362 = 7;
        int32_t *l_363 = &g_7;
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_338[i] = (-0x1.8p+1);
    }
    for (g_119.f2 = 1; (g_119.f2 >= 0); g_119.f2 -= 1)
    { /* block id: 276 */
        int32_t l_364[4] = {(-1),(-1),(-1),(-1)};
        int i;
        (*g_87) = 8;
        if (l_364[3])
            continue;
        return p_37.f2;
    }
    return (**g_260);
}


/* ------------------------------------------ */
/* 
 * reads : g_87 g_113 g_114 g_42.f6
 * writes: g_7
 */
inline static float  func_45(const int16_t  p_46, uint32_t  p_47, uint16_t  p_48)
{ /* block id: 227 */
    int8_t l_322 = 0xD5;
    (*g_87) = (((int16_t)l_322 >> (int16_t)(p_48 | 5)) || (!65527U));
    return (**g_113);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_7
 */
static int16_t  func_54(const int32_t  p_55)
{ /* block id: 41 */
    int32_t *l_57 = &g_7;
    union U1 ***l_316 = (void*)0;
    union U1 ****l_315 = &l_316;
    (*l_57) = (-9);
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads : g_64 g_7 g_63 g_86 g_87 g_42.f4 g_42.f3 g_101 g_42.f0 g_42.f5 g_113 g_119.f2 g_119.f0 g_114 g_42.f6 g_119.f3 g_119.f5 g_42.f1 g_101.f0 g_149 g_42.f2 g_119.f4 g_3 g_257 g_119.f1
 * writes: g_63 g_7 g_3 g_87 g_42.f6 g_113 g_119.f0 g_119.f5 g_149 g_119.f2
 */
inline static int32_t * func_58(int8_t  p_59, int32_t * p_60, const int32_t  p_61)
{ /* block id: 43 */
    int32_t *l_71 = &g_7;
    int16_t l_308 = 0x0061;
    const float *l_311[3][1];
    const float **l_310 = &l_311[1][0];
    const float ***l_309 = &l_310;
    int i, j;
    for (i = 0; i < 3; i = i + 1)
    {
        for (j = 0; j < 1; j = j + 1)
            l_311[i][j] = &g_42[0][0].f6;
    }
    (*g_64) = &p_61;
    (*p_60) = (*p_60);
    if ((p_59 ^ (((int32_t)((&p_61 == &p_61) & ((int16_t)(((int16_t)p_59 - (int16_t)(l_71 == (*g_64))) != ((int32_t)0x768FB0C4 - (int32_t)(~((int16_t)(func_77(p_60, (*l_71), p_60) || p_61) % (int16_t)0x970F)))) + (int16_t)g_42[0][0].f3)) / (int32_t)p_61) || g_119.f1)))
    { /* block id: 209 */
        return p_60;
    }
    else
    { /* block id: 211 */
        uint32_t l_303 = 0xAB1B66BC;
        (*l_71) = (((int32_t)(*l_71) - (int32_t)((*l_71) != ((uint32_t)((int16_t)((!(g_42[0][0].f2 & 0U)) == g_119.f4) % (int16_t)((l_303 || (((((uint16_t)p_59 / (uint16_t)p_61) <= ((((uint16_t)(p_61 ^ p_59) / (uint16_t)p_61) != 1U) >= l_308)) > 0x6C89BE4A) ^ p_59)) & p_61)) - (uint32_t)g_119.f0))) > l_303);
        (*l_71) = l_303;
        l_309 = (void*)0;
    }
    (*l_71) = (**g_64);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads : g_86 g_87 g_7 g_42.f4 g_42.f3 g_101 g_42.f0 g_42.f5 g_113 g_119.f2 g_119.f0 g_114 g_42.f6 g_119.f3 g_119.f5 g_42.f1 g_101.f0 g_149 g_42.f2 g_119.f4 g_3 g_257
 * writes: g_7 g_3 g_87 g_42.f6 g_113 g_119.f0 g_119.f5 g_149 g_119.f2
 */
inline static int16_t  func_77(int32_t * p_78, uint32_t  p_79, int32_t * p_80)
{ /* block id: 46 */
    int32_t **l_96 = &g_87;
    union U1 *l_191 = (void*)0;
    int32_t **l_226 = &g_87;
    const struct S0 *l_253 = &g_119;
lbl_135:
    (*l_96) = func_81(func_83(g_86, func_88(func_93((~(0x74CA && (((((void*)0 != l_96) & (((**l_96) < p_79) != p_79)) != ((uint32_t)(((*g_87) != ((uint16_t)((**l_96) | (**l_96)) / (uint16_t)p_79)) < g_42[0][0].f4) - (uint32_t)p_79)) || (*p_80))))), g_42[0][0].f3, p_79, g_101)));
    if (((~((int16_t)g_119.f2 - (int16_t)((uint16_t)65528U - (uint16_t)(0x9397 || (((int32_t)(((*p_80) | 0xFA911A91) && (p_79 | ((uint32_t)((int16_t)(__builtin_clzl(g_119.f0) > ((int32_t)(*p_80) / (int32_t)0xAD51AC0D)) << (int16_t)9) + (uint32_t)(-7)))) + (int32_t)1) < (-3)))))) ^ p_79))
    { /* block id: 70 */
        int8_t l_156 = (-9);
        int32_t **l_157 = &g_87;
        for (g_119.f0 = 0; (g_119.f0 <= 4); g_119.f0 += 1)
        { /* block id: 73 */
            int8_t l_136 = 9;
            int32_t *l_155 = &g_149;
            (*l_96) = p_80;
            for (p_79 = 0; (p_79 <= 4); p_79 += 1)
            { /* block id: 77 */
                (**l_96) = 0x0.6p+1;
            }
            for (g_7 = 3; (g_7 >= 0); g_7 -= 1)
            { /* block id: 82 */
                int8_t l_151 = 0x76;
                if ((**g_86))
                { /* block id: 83 */
                    float l_147 = 0x1.0p-1;
                    const int32_t l_150[1] = {0xF8190269};
                    int32_t *l_154[10] = {&g_7,&g_149,(void*)0,&g_149,&g_7,&g_7,&g_149,(void*)0,&g_149,&g_7};
                    int i;
                    for (g_119.f5 = 1; (g_119.f5 <= 4); g_119.f5 += 1)
                    { /* block id: 86 */
                        if (g_119.f2)
                            goto lbl_135;
                        return p_79;
                    }
                    (**g_113) = (**g_113);
                    for (g_119.f5 = 0; (g_119.f5 <= 4); g_119.f5 += 1)
                    { /* block id: 93 */
                        int32_t *l_148[2];
                        const int32_t *l_153 = &l_150[0];
                        const int32_t **l_152 = &l_153;
                        int i;
                        for (i = 0; i < 2; i = i + 1)
                            l_148[i] = (void*)0;
                        if (p_79)
                            goto lbl_135;
                        g_149 = (l_136 ^ (((uint32_t)g_119.f3 + (uint32_t)((((uint32_t)((int16_t)(((int16_t)(p_79 <= 1U) >> (int16_t)g_42[0][0].f4) || ((int32_t)(__builtin_bswap64(p_79) & (-9)) + (int32_t)(p_79 == g_42[0][0].f3))) + (int16_t)0) + (uint32_t)0U) <= 0x9F22) & g_42[0][0].f5)) <= 9U));
                        l_151 = l_150[0];
                        (*l_152) = &l_150[0];
                    }
                    g_149 = (*p_78);
                }
                else
                { /* block id: 100 */
                    l_155 = (*g_86);
                    l_156 = (__builtin_popcountll(g_119.f2) & p_79);
                }
            }
        }
        (*l_157) = func_81(l_157);
    }
    else
    { /* block id: 107 */
        int32_t l_158 = 3;
        return l_158;
    }
lbl_231:
    for (g_119.f5 = 0; (g_119.f5 == 23); g_119.f5 += 2)
    { /* block id: 112 */
        int16_t l_170 = (-2);
        int32_t l_171 = (-5);
        int32_t l_174 = 1;
        for (p_79 = (-9); (p_79 <= 60); p_79 += 1)
        { /* block id: 115 */
            int32_t l_176 = 0x9CD97943;
            int32_t l_179 = 0xE91FFD6F;
            union U1 **l_188 = (void*)0;
            union U1 ***l_187 = &l_188;
            if (((int32_t)(p_79 == ((~g_42[0][0].f1) | ((int16_t)((int16_t)((l_170 ^ (p_79 >= l_171)) | ((uint16_t)__builtin_ffsl(l_174) >> (uint16_t)14)) / (int16_t)(-(uint16_t)g_119.f0)) / (int16_t)p_79))) % (int32_t)p_79))
            { /* block id: 116 */
                l_176 = 1;
            }
            else
            { /* block id: 118 */
                uint16_t l_178 = 65535U;
                if (l_176)
                    break;
                l_179 = (!l_178);
            }
            for (l_171 = (-22); (l_171 <= (-16)); l_171 += 9)
            { /* block id: 124 */
                int32_t *l_184 = &g_7;
                for (l_176 = (-12); (l_176 != (-17)); l_176 -= 5)
                { /* block id: 127 */
                    float l_186[3][10] = {{0xE.503D30p+72,0x5.2211D2p-90,(-0x1.4p+1),0x0.217524p-90,(-0x1.4p+1),0x5.2211D2p-90,0xE.503D30p+72,0xE.503D30p+72,0x5.2211D2p-90,(-0x1.4p+1)},{0x5.2211D2p-90,0xE.503D30p+72,0xE.503D30p+72,0x5.2211D2p-90,(-0x1.4p+1),0x0.217524p-90,(-0x1.4p+1),0x5.2211D2p-90,0xE.503D30p+72,0xE.503D30p+72},{(-0x1.4p+1),0xE.503D30p+72,0x2.01C1B6p-55,(-0x3.5p-1),(-0x3.5p-1),0x2.01C1B6p-55,0xE.503D30p+72,(-0x1.4p+1),0xE.503D30p+72,0x2.01C1B6p-55}};
                    union U1 ****l_189 = &l_187;
                    int i, j;
                    (*g_114) = ((l_184 != p_78) != ((**g_113) >= (*l_184)));
                    for (g_119.f2 = 1; (g_119.f2 <= 4); g_119.f2 += 1)
                    { /* block id: 131 */
                        (*p_80) = (((void*)0 != &l_179) && __builtin_ffs((-(uint32_t)(g_7 <= g_101.f0))));
                    }
                    (*l_189) = l_187;
                    for (l_179 = 2; (l_179 >= 0); l_179 -= 1)
                    { /* block id: 137 */
                        if ((*p_78))
                            break;
                    }
                }
            }
        }
    }
    if ((*p_78))
    { /* block id: 144 */
        int32_t *l_190 = &g_149;
        (*g_86) = l_190;
        (*g_86) = l_190;
        return (*l_190);
    }
    else
    { /* block id: 148 */
        const union U1 l_201 = {0x27C46033};
        union U1 ***l_267 = (void*)0;
        const int32_t **l_285 = &g_63[0];
        (*l_96) = func_81(l_96);
        if ((&g_105[3] == l_191))
        { /* block id: 150 */
            (*g_114) = (*g_114);
            return g_42[0][0].f2;
        }
        else
        { /* block id: 153 */
            uint16_t l_200 = 65533U;
            const float *l_220 = &g_3;
            int32_t l_246 = 5;
            union U1 **l_269[5] = {&l_191,&l_191,&l_191,&l_191,&l_191};
            union U1 ***l_268 = &l_269[2];
            int i;
            if ((((uint16_t)g_119.f3 / (uint16_t)0x5482) <= (&g_114 == (void*)0)))
            { /* block id: 154 */
                const uint32_t l_199 = 0U;
                int32_t *l_202 = &g_7;
                l_202 = func_88(&g_87, g_119.f4, (p_79 == (p_79 <= __builtin_parity((~((int16_t)((int32_t)(g_42[0][0].f3 > l_199) % (int32_t)l_200) + (int16_t)0U))))), l_201);
                if (g_149)
                    goto lbl_293;
                if (((uint16_t)((int16_t)((((uint32_t)((uint16_t)((int32_t)(*l_202) % (int32_t)((((l_201.f0 != (*p_80)) <= (~((uint16_t)l_200 % (uint16_t)((uint32_t)((*l_202) & ((void*)0 != l_220)) + (uint32_t)((uint32_t)g_7 + (uint32_t)((-(uint16_t)((uint32_t)0xF83DE727 - (uint32_t)(*l_202))) >= 0xF332)))))) || 0x02A5) & p_79)) << (uint16_t)6) / (uint32_t)p_79) != p_79) == p_79) / (int16_t)g_101.f0) << (uint16_t)13))
                { /* block id: 156 */
                    (*l_202) = (*p_78);
                    (*g_86) = (*g_86);
                    (*l_226) = func_81(l_226);
                    (*g_114) = (((float)((((float)0x0.Bp+1 / (float)((*g_114) == (*g_114))) < (__builtin_ffsll(p_79) == ((-0x3.Dp+1) != __builtin_ctz((4U > 0x47CEE369))))) > (**g_113)) / (float)(**g_113)) >= (*g_114));
                }
                else
                { /* block id: 161 */
                    if (g_119.f2)
                        goto lbl_231;
                }
            }
            else
            { /* block id: 164 */
                uint32_t l_249[2][8] = {{0x808D468F,0x9664FB15,0x808D468F,0x9664FB15,0x808D468F,0x9664FB15,0x808D468F,0x9664FB15},{0x808D468F,0x9664FB15,0x808D468F,0x9664FB15,0x808D468F,0x9664FB15,0x808D468F,0x9664FB15}};
                int16_t l_250 = (-10);
                const volatile float * volatile * volatile *l_259 = &g_260;
                const volatile float * volatile * volatile **l_258 = &l_259;
                int i, j;
                for (g_119.f2 = (-27); (g_119.f2 >= (-14)); g_119.f2 += 5)
                { /* block id: 167 */
                    (*l_96) = p_80;
                    (**l_226) = ((int32_t)(p_79 | (((uint32_t)0x965A7D26 - (uint32_t)l_200) >= (((int32_t)((((uint16_t)((int16_t)p_79 >> (int16_t)(l_246 && ((uint32_t)g_119.f4 % (uint32_t)__builtin_clzl(p_79)))) >> (uint16_t)6) <= (__builtin_bswap32((p_79 ^ (-2))) < l_249[1][6])) & l_250) - (int32_t)4294967294U) >= 0xD4CE2010))) + (int32_t)(-1));
                }
                if (l_249[1][5])
                { /* block id: 171 */
                    uint16_t l_255 = 5U;
                    int32_t l_256[3][4][9] = {{{(-9),0x8A72973F,8,0x8A72973F,(-9),0xCBE35802,0xCBE35802,(-9),0x8A72973F},{0xBC268F25,0x158891A7,0xBC268F25,0x2D1DD9B9,6,6,0x2D1DD9B9,0xBC268F25,0x158891A7},{0xE1F302E5,0x6AAE363C,0xCBE35802,8,8,0xCBE35802,0x6AAE363C,0xE1F302E5,0x6AAE363C},{0xE3F3AD76,(-8),0x2D1DD9B9,0x2D1DD9B9,(-8),0xE3F3AD76,6,0xE3F3AD76,(-8)}},{{0x8A72973F,0x6AAE363C,0x6AAE363C,0x8A72973F,0xE1F302E5,(-9),0xE1F302E5,0x8A72973F,0x6AAE363C},{0x158891A7,0x158891A7,6,(-8),0x0C4547A6,(-8),6,0x158891A7,0x158891A7},{0x6AAE363C,0x8A72973F,0xE1F302E5,(-9),0xE1F302E5,0x8A72973F,0x6AAE363C,0x6AAE363C,0x8A72973F},{(-8),0xE3F3AD76,6,0xE3F3AD76,(-8),0x2D1DD9B9,0x2D1DD9B9,(-8),0xE3F3AD76}},{{0x6AAE363C,0xE1F302E5,0x6AAE363C,0xCBE35802,8,8,0xCBE35802,0x6AAE363C,0xE1F302E5},{0x158891A7,0xBC268F25,0x2D1DD9B9,6,6,0x2D1DD9B9,0xBC268F25,0x158891A7,0xBC268F25},{0x8A72973F,(-9),0xCBE35802,0xCBE35802,(-9),0x8A72973F,8,0x8A72973F,(-9)},{0xE3F3AD76,0xBC268F25,0xBC268F25,0xE3F3AD76,0x158891A7,(-8),0x158891A7,0xE3F3AD76,0xBC268F25}}};
                    int i, j, k;
                    for (g_119.f0 = 0; (g_119.f0 != 19); g_119.f0 += 1)
                    { /* block id: 174 */
                        const struct S0 **l_254 = &l_253;
                        (*l_254) = l_253;
                        if (l_255)
                            continue;
                        l_256[1][0][6] = p_79;
                    }
                }
                else
                { /* block id: 179 */
                    (*p_80) = l_249[1][6];
                    l_258 = g_257;
                }
            }
            if (g_119.f0)
                goto lbl_293;
            (*p_78) = (((uint16_t)((uint16_t)g_42[0][0].f2 / (uint16_t)g_119.f4) + (uint16_t)(l_267 != l_268)) > (((uint32_t)(((uint32_t)((uint32_t)g_119.f3 - (uint32_t)p_79) + (uint32_t)0U) & ((p_80 == (void*)0) & 0U)) % (uint32_t)g_119.f3) <= g_7));
lbl_293:
            for (g_119.f2 = (-10); (g_119.f2 >= (-16)); --g_119.f2)
            { /* block id: 187 */
                uint32_t l_282 = 0x5F372E63;
                union U1 ****l_290 = &l_268;
                for (l_246 = (-25); (l_246 >= (-16)); l_246 += 1)
                { /* block id: 190 */
                    int8_t l_291 = (-10);
                    int32_t *l_292[9][1][9] = {{{&g_149,(void*)0,&g_149,(void*)0,&g_149,&g_149,&g_149,&g_149,&g_149}},{{&g_7,&g_149,(void*)0,&g_149,&g_7,(void*)0,&g_149,&g_149,(void*)0}},{{&g_149,(void*)0,&g_149,(void*)0,&g_149,&g_149,&g_149,&g_149,&g_149}},{{&g_7,&g_149,(void*)0,&g_149,&g_7,&g_149,(void*)0,(void*)0,&g_149}},{{&g_7,&g_149,&g_149,&g_149,&g_7,&g_149,&g_7,&g_7,&g_149}},{{&g_7,&g_7,&g_149,&g_7,&g_7,&g_149,(void*)0,(void*)0,&g_149}},{{&g_7,&g_149,&g_149,&g_149,&g_7,&g_149,&g_7,&g_7,&g_149}},{{&g_7,&g_7,&g_149,&g_7,&g_7,&g_149,(void*)0,(void*)0,&g_149}},{{&g_7,&g_149,&g_149,&g_149,&g_7,&g_149,&g_7,&g_7,&g_149}}};
                    int i, j, k;
                    (**g_113) = (((float)p_79 + (float)((**g_113) >= l_282)) == ((float)(l_96 != l_285) + (float)((float)(&g_114 != &g_114) / (float)l_282)));
                    for (g_149 = (-30); (g_149 >= 19); g_149 += 1)
                    { /* block id: 194 */
                        (*l_226) = (*g_86);
                        (*g_86) = (*g_86);
                    }
                    (*p_80) = (p_79 && (0x5E96 < (((((void*)0 == l_290) > g_42[0][0].f4) > p_79) | l_291)));
                    (*l_226) = l_292[0][0][1];
                }
            }
            (*l_226) = p_80;
        }
        (*g_86) = p_78;
    }
    return (**l_226);
}


/* ------------------------------------------ */
/* 
 * reads : g_87
 * writes:
 */
inline static int32_t * func_81(int32_t ** p_82)
{ /* block id: 67 */
    return (*p_82);
}


/* ------------------------------------------ */
/* 
 * reads : g_113
 * writes: g_42.f6 g_113 g_87 g_3
 */
inline static int32_t ** func_83(int32_t ** p_84, int32_t * p_85)
{ /* block id: 56 */
    uint32_t l_107 = 1U;
    struct S0 *l_118 = &g_119;
    uint16_t l_120 = 0xA24B;
    if ((l_107 <= l_107))
    { /* block id: 57 */
        struct S0 **l_108 = (void*)0;
        struct S0 *l_110 = &g_42[1][0];
        struct S0 **l_109 = &l_110;
        (*l_109) = &g_42[0][0];
    }
    else
    { /* block id: 59 */
        float *l_111 = (void*)0;
        float *l_112 = &g_42[0][0].f6;
        float * volatile **l_115 = &g_113;
        struct S0 *l_117 = &g_42[2][0];
        struct S0 **l_116[4] = {(void*)0,(void*)0,(void*)0,(void*)0};
        int i;
        (*l_112) = l_107;
        (*l_115) = g_113;
        l_118 = &g_42[0][3];
        (*p_84) = l_111;
    }
    (*p_85) = (65529U != (((l_120 < 0xF504) > (-(uint16_t)0x53AF)) > __builtin_ctzl(((-1) && l_107))));
    return &g_87;
}


/* ------------------------------------------ */
/* 
 * reads : g_42.f0 g_42.f5 g_87 g_86
 * writes: g_3 g_87
 */
static int32_t * func_88(int32_t ** p_89, int8_t  p_90, uint16_t  p_91, const union U1  p_92)
{ /* block id: 50 */
    float *l_102 = &g_3;
    union U1 *l_104 = &g_105[2];
    union U1 **l_106 = &l_104;
    (*l_102) = g_42[0][0].f0;
    (*l_102) = ((-(float)(-0x7.3p+1)) == g_42[0][0].f5);
    (*g_86) = (*p_89);
    (*l_106) = l_104;
    return l_102;
}


/* ------------------------------------------ */
/* 
 * reads : g_87
 * writes: g_7
 */
static int32_t ** func_93(uint32_t  p_94)
{ /* block id: 47 */
    (*g_87) = (-1);
    return &g_87;
}




/* ---------------------------------------- */
int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc_bytes (&g_3, sizeof(g_3), "g_3", print_hash_value);
    transparent_crc(g_7, "g_7", print_hash_value);
    for (i = 0; i < 4; i = i + 1)
    {
        for (j = 0; j < 5; j = j + 1)
        {
            transparent_crc(g_42[i][j].f0, "g_42[i][j].f0", print_hash_value);
            transparent_crc(g_42[i][j].f1, "g_42[i][j].f1", print_hash_value);
            transparent_crc(g_42[i][j].f2, "g_42[i][j].f2", print_hash_value);
            transparent_crc(g_42[i][j].f3, "g_42[i][j].f3", print_hash_value);
            transparent_crc(g_42[i][j].f4, "g_42[i][j].f4", print_hash_value);
            transparent_crc(g_42[i][j].f5, "g_42[i][j].f5", print_hash_value);
            transparent_crc_bytes(&g_42[i][j].f6, sizeof(g_42[i][j].f6), "g_42[i][j].f6", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_101.f0, "g_101.f0", print_hash_value);
    for (i = 0; i < 5; i = i + 1)
    {
        transparent_crc(g_105[i].f0, "g_105[i].f0", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    transparent_crc(g_119.f0, "g_119.f0", print_hash_value);
    transparent_crc(g_119.f1, "g_119.f1", print_hash_value);
    transparent_crc(g_119.f2, "g_119.f2", print_hash_value);
    transparent_crc(g_119.f3, "g_119.f3", print_hash_value);
    transparent_crc(g_119.f4, "g_119.f4", print_hash_value);
    transparent_crc(g_119.f5, "g_119.f5", print_hash_value);
    transparent_crc_bytes (&g_119.f6, sizeof(g_119.f6), "g_119.f6", print_hash_value);
    transparent_crc(g_149, "g_149", print_hash_value);
    transparent_crc_bytes (&g_262, sizeof(g_262), "g_262", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 90
   depth: 1, occurrence: 1
XXX total union variables: 2

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 14
breakdown:
   indirect level: 0, occurrence: 3
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 4
   indirect level: 4, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 11
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 7
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 17

XXX max expression depth: 21
breakdown:
   depth: 1, occurrence: 141
   depth: 2, occurrence: 29
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 1
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 21, occurrence: 1

XXX total number of pointers: 85

XXX times a variable address is taken: 96
XXX times a pointer is dereferenced on RHS: 49
breakdown:
   depth: 1, occurrence: 34
   depth: 2, occurrence: 15
XXX times a pointer is dereferenced on LHS: 68
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 11
XXX times a pointer is compared with null: 7
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 232

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 140
   level: 2, occurrence: 63
XXX number of pointers point to pointers: 45
XXX number of pointers point to scalars: 32
XXX number of pointers point to structs: 5
XXX percent of pointers has null in alias set: 28.2
XXX average alias set size: 1.21

XXX times a non-volatile is read: 372
XXX times a non-volatile is write: 183
XXX times a volatile is read: 13
XXX    times read thru a pointer: 8
XXX times a volatile is write: 11
XXX    times written thru a pointer: 7
XXX times a volatile is available for access: 27
XXX percentage of non-volatile access: 95.9

XXX forward jumps: 2
XXX backward jumps: 5

XXX stmts: 127
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 26
   depth: 2, occurrence: 14
   depth: 3, occurrence: 14
   depth: 4, occurrence: 27
   depth: 5, occurrence: 13

XXX percentage a fresh-made variable is used: 24.7
XXX percentage an existing variable is used: 75.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

