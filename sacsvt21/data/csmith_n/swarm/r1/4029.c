/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --no-consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --unary-plus-operator --no-jumps --no-longlong --int8 --no-uint8 --float --math64 --inline-function --no-muls --no-safe-math --no-packed-struct --no-paranoid --no-pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3308089496
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint32_t  f1;
   int32_t  f2;
   uint16_t  f3;
   int32_t  f4;
   int32_t  f5;
   int32_t  f6;
};

union U1 {
   float  f0;
   uint32_t  f1;
};

union U2 {
   uint32_t  f0;
   int32_t  f1;
   uint16_t  f2;
   int16_t  f3;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U1  func_27(void);
static int16_t  func_29(uint16_t  p_30, uint16_t  p_31, union U2  p_32, union U2  p_33);
static union U2  func_34(struct S0  p_35, int32_t  p_36, union U1  p_37, union U1  p_38);
static union U1  func_40(union U1  p_41, union U1  p_42, struct S0  p_43);
static union U1  func_45(int32_t  p_46, union U2  p_47);
static int16_t  func_53(struct S0  p_54, uint32_t  p_55, union U2  p_56);
static struct S0  func_57(int32_t  p_58, union U2  p_59);
static float  func_70(int32_t  p_71, int32_t  p_72, uint32_t  p_73);
inline static int32_t  func_74(uint16_t  p_75, float  p_76);
static uint32_t  func_80(int8_t  p_81, uint32_t  p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U1  func_27(void)
{ /* block id: 36 */
    uint32_t l_28 = 4294967295U;
    struct S0 l_39 = {-7,0x355C0C8F,0,0x5DAA,-7,0xD1883800,0x55205300};
    union U1 l_44 = {0x1.Fp-1};
    union U2 l_60 = {3U};
    int32_t l_420 = 0xFC28B50E;
    int32_t l_467 = 0x79746DD2;
    int32_t l_472 = 0xB19E4DCF;
    uint16_t l_529 = 0x8401;
    union U1 l_537 = {0x8.3p+1};
    l_60.f1 = (((l_28 ^ func_29(l_28, l_28, func_34(l_39, l_39.f1, func_40(l_44, func_45((((int16_t)((~(l_44.f1 ^ (l_39.f6 > ((((int16_t)func_53(func_57(l_39.f2, l_60), l_60.f3, l_60) << (int16_t)1) >= l_60.f0) || 0U)))) > l_60.f1) + (int16_t)l_420) >= l_39.f1), l_60), l_39), l_44), l_60)) & l_39.f1) != l_39.f2);
    l_39 = func_57((((uint32_t)(2U > ((((((uint32_t)(l_39.f1 && 0U) - (uint32_t)(((uint16_t)l_39.f5 >> (uint16_t)((func_74(l_28, ((+(l_39.f1 != ((l_467 <= ((float)l_467 - (float)((float)l_39.f1 - (float)l_39.f2))) == l_39.f2))) != 0x5.3p+1)) != 0x29C3) != l_467)) == l_39.f6)) < l_39.f1) <= l_472) > 0U) > l_60.f3)) - (uint32_t)l_60.f1) == l_39.f2), l_60);
    if (__builtin_ffsl(l_44.f1))
    { /* block id: 304 */
        int16_t l_478 = 0x6961;
        union U2 l_484 = {0x9036A033};
        struct S0 l_486 = {0xCE60,4294967290U,-1,0x98A3,0xF447DEA4,0xFD84C814,0x6B91523C};
        int32_t l_500 = 0x0288F146;
        union U1 l_506 = {0x3.5p-1};
        for (l_467 = 13; (l_467 > 16); l_467 += 2)
        { /* block id: 307 */
            int32_t l_477 = 0x6BFB2496;
            struct S0 l_505 = {1,1U,-5,65535U,-3,0x18528328,1};
            for (l_420 = 8; (l_420 >= 25); l_420++)
            { /* block id: 310 */
                struct S0 l_479 = {0xFCF2,0xC97FB50E,0x571A8812,0xF314,0xE94A7693,0xA6EF6812,0};
                union U1 l_485 = {0x7.97FC59p+87};
                int8_t l_489 = 0;
                if (l_477)
                { /* block id: 311 */
                    int8_t l_480 = 5;
                    union U2 l_504 = {5U};
                    l_486 = func_57(l_478, func_34(l_479, l_480, func_45((~(((uint32_t)__builtin_ctzl(l_480) + (uint32_t)l_479.f4) || l_477)), l_484), l_485));
                    l_486 = func_57((((uint32_t)((l_489 == ((uint16_t)((int32_t)((l_477 ^ (l_480 || l_489)) < ((l_480 == ((uint16_t)(((uint16_t)((int16_t)l_500 % (int16_t)l_479.f6) >> (uint16_t)8) | ((~(((((l_480 > ((uint16_t)__builtin_ffsl(l_477) >> (uint16_t)15)) < l_500) | l_477) | l_484.f0) < l_479.f6)) ^ l_484.f2)) + (uint16_t)l_485.f1)) != l_44.f1)) - (int32_t)0x2F894A01) + (uint16_t)1)) <= 0x45EB3AF6) - (uint32_t)l_479.f2) || 0xEB85CDD2), l_504);
                    l_505 = l_486;
                }
                else
                { /* block id: 315 */
                    return l_506;
                }
                l_39.f5 = (func_80(l_505.f3, l_486.f1) && (((l_479.f0 && ((l_39.f5 <= l_39.f6) < l_39.f0)) ^ (func_80(l_484.f0, l_486.f0) && l_479.f4)) <= l_489));
            }
            for (l_505.f5 = 0; (l_505.f5 != (-10)); l_505.f5 -= 5)
            { /* block id: 322 */
                l_486 = func_57(l_505.f4, l_60);
            }
            l_472 = l_477;
        }
        l_486 = func_57((((uint16_t)(((l_486.f1 | l_60.f2) < (((int32_t)0x379373BE - (int32_t)(-8)) ^ (0xD2FD9D4A < l_484.f1))) >= (((uint32_t)(l_44.f1 && 0x24B5) - (uint32_t)((((uint32_t)l_486.f3 % (uint32_t)l_506.f1) & 0) || (-1))) < l_484.f1)) + (uint16_t)l_486.f3) & l_44.f1), l_60);
    }
    else
    { /* block id: 328 */
        struct S0 l_517 = {0,1U,-1,0xBB2F,-1,0xD146A0C7,-8};
        l_39 = l_517;
        if ((l_517.f3 | (65534U >= ((int16_t)(-(uint16_t)0xE318) << (int16_t)((((int32_t)((((int32_t)((((uint16_t)(((uint16_t)(((l_529 <= l_517.f5) > ((uint32_t)((int16_t)0 + (int16_t)(l_472 >= 0x1BE4)) - (uint32_t)l_39.f1)) | l_517.f4) << (uint16_t)7) != 65528U) << (uint16_t)12) == 0x586A) > l_60.f0) + (int32_t)0x714BFF54) | 3) != 0x6B52D0B4) % (int32_t)l_39.f4) | 4294967295U) <= l_39.f4)))))
        { /* block id: 330 */
            for (l_39.f2 = 0; (l_39.f2 <= (-25)); l_39.f2 -= 8)
            { /* block id: 333 */
                l_472 = 0x1.2p+1;
            }
        }
        else
        { /* block id: 336 */
            struct S0 l_536 = {0xED32,4294967295U,4,1U,0xC3BE621C,-1,1};
            l_517.f5 = l_517.f5;
            l_536 = l_39;
        }
    }
    return l_537;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_29(uint16_t  p_30, uint16_t  p_31, union U2  p_32, union U2  p_33)
{ /* block id: 290 */
    float l_447 = 0x1.2p-1;
    int32_t l_448 = 6;
    struct S0 l_449 = {-1,0x84161E42,-1,65526U,0,0xDAC93B36,0xC8C08B6E};
    struct S0 l_452 = {7,0x0D603B30,0x0B240730,0xD26F,0x0D8CFC2A,-8,0xA42C4EBE};
    union U2 l_459 = {1U};
    l_449 = func_57(((0x08E0 >= l_448) & (l_448 ^ (p_33.f0 == p_30))), p_32);
    l_449.f5 = (p_32.f2 | l_449.f0);
    for (l_449.f1 = 20; (l_449.f1 == 59); ++l_449.f1)
    { /* block id: 295 */
        int32_t l_456 = 0xAB270CE4;
        l_452 = l_449;
        p_32.f1 = (((((((+((int32_t)p_31 - (int32_t)l_452.f2)) & l_456) >= ((uint16_t)((l_449.f5 > 6U) >= l_456) >> (uint16_t)11)) && ((__builtin_popcount(__builtin_popcountl((l_449.f2 | l_456))) > l_452.f1) >= p_33.f0)) ^ 0xBA1D) > p_32.f3) < l_456);
        if (p_32.f2)
            break;
    }
    l_452 = func_57(p_32.f2, l_459);
    return l_449.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2  func_34(struct S0  p_35, int32_t  p_36, union U1  p_37, union U1  p_38)
{ /* block id: 287 */
    int32_t l_435 = 0xE84E6DCC;
    union U2 l_438 = {0x776CCF4F};
    float l_441 = 0xE.7663CFp-43;
    uint32_t l_446 = 0x7045C10A;
    l_438.f1 = ((uint16_t)p_35.f6 >> (uint16_t)((((int16_t)(((uint16_t)(+(((((int32_t)((+(p_35.f5 != 7U)) <= l_435) - (int32_t)((int16_t)func_53(func_57(l_435, l_438), func_80(((uint16_t)l_438.f1 >> (uint16_t)((int16_t)(((uint32_t)((l_438.f2 > l_438.f1) & l_435) - (uint32_t)l_438.f1) != p_35.f5) % (int16_t)l_446)), l_446), l_438) - (int16_t)l_438.f0)) <= p_35.f6) <= l_438.f1) & 0x411F)) << (uint16_t)7) & l_438.f1) >> (int16_t)5) && p_36) & l_438.f2));
    return l_438;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_40(union U1  p_41, union U1  p_42, struct S0  p_43)
{ /* block id: 284 */
    struct S0 l_423 = {0x6BF4,4294967295U,1,1U,0x56A15EED,0x2B8BD812,0xBC739653};
    union U1 l_424 = {0xB.300B62p-7};
    p_43 = l_423;
    return l_424;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U1  func_45(int32_t  p_46, union U2  p_47)
{ /* block id: 281 */
    int16_t l_421 = 0xA4E1;
    union U1 l_422 = {0x1.16D08Bp-94};
    l_421 = 0x1.6p-1;
    return l_422;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_53(struct S0  p_54, uint32_t  p_55, union U2  p_56)
{ /* block id: 277 */
    int16_t l_418 = 1;
    int32_t l_419 = 0;
    l_419 = ((uint32_t)__builtin_popcountl(l_418) - (uint32_t)(-6));
    l_419 = p_54.f4;
    return l_419;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_57(int32_t  p_58, union U2  p_59)
{ /* block id: 37 */
    uint16_t l_64 = 0U;
    int32_t l_414 = 0x1667E6C4;
    struct S0 l_415 = {0x0150,0xAACC8931,4,65532U,0xC4EDAE71,0,0x8DE9C3CC};
    if ((p_59.f3 & ((p_59.f2 != ((((int16_t)(-(int32_t)__builtin_bswap32(p_59.f1)) << (int16_t)3) >= __builtin_popcountll(p_59.f0)) > (((__builtin_bswap64(l_64) >= (+(((uint16_t)0x3ADA % (uint16_t)p_59.f0) == l_64))) | l_64) <= l_64))) >= p_59.f1)))
    { /* block id: 38 */
        float l_77 = 0x5.29B4DBp+73;
        uint16_t l_78 = 0x97A1;
        int32_t l_412 = 0x8AEBA5A6;
        l_412 = (((((float)p_59.f3 + (float)func_70(func_74((l_78 > (l_64 != ((+((func_80(l_78, ((((uint16_t)p_59.f3 + (uint16_t)p_59.f2) != p_59.f2) && p_59.f3)) == l_64) ^ l_78)) > (-4)))), l_78), l_78, l_78)) < l_64) <= 0x9.Fp-1) <= l_78);
        p_58 = (p_59.f0 != p_59.f3);
    }
    else
    { /* block id: 271 */
        uint16_t l_413 = 0x1233;
        l_413 = (p_58 || 65530U);
        l_414 = l_64;
    }
    l_415 = l_415;
    return l_415;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_70(int32_t  p_71, int32_t  p_72, uint32_t  p_73)
{ /* block id: 123 */
    float l_177 = 0x6.5p+1;
    int32_t l_178 = (-1);
    struct S0 l_195 = {-2,0xBA6C6404,0xC0F1C837,65527U,1,-4,0x974CBE2B};
    int8_t l_229 = 0;
    int8_t l_274 = 0x63;
    float l_376 = 0x7.C9B0F4p-75;
    uint32_t l_388 = 4294967288U;
    int32_t l_404 = (-3);
    int32_t l_405 = 0x54794A07;
    if (l_178)
    { /* block id: 124 */
        float l_184 = 0x1.7p+1;
        int32_t l_185 = 0;
        struct S0 l_247 = {3,4294967295U,0x62C63C90,65526U,-1,0,0x747BD279};
        float l_349 = 0x7.8p-1;
        uint32_t l_366 = 4294967295U;
        p_71 = (~(7U || 0x459E8EBB));
        if (((int32_t)__builtin_clzl(((uint16_t)l_185 >> (uint16_t)14)) + (int32_t)(l_178 > l_185)))
        { /* block id: 126 */
            uint32_t l_192 = 0x5AE1CCF1;
            struct S0 l_246 = {0x2F3B,3U,-1,65535U,0xAFE84FE0,-1,0};
            if (((uint32_t)((int16_t)l_185 << (int16_t)(((p_72 || l_185) & 65526U) != l_185)) - (uint32_t)(p_71 || l_185)))
            { /* block id: 127 */
                uint32_t l_205 = 4294967287U;
                uint32_t l_210 = 1U;
                l_192 = ((uint16_t)0xD97B >> (uint16_t)0);
                for (p_73 = 28; (p_73 >= 41); p_73 += 1)
                { /* block id: 131 */
                    uint32_t l_198 = 4294967286U;
                    int32_t l_209 = 0xB7984CDC;
                    int32_t l_211 = 0xFFC7C3E9;
                    l_195 = l_195;
                    if (func_74((((uint16_t)(func_80(l_198, l_192) && ((p_72 | ((uint16_t)l_198 >> (uint16_t)((int16_t)((uint16_t)p_71 << (uint16_t)6) % (int16_t)__builtin_ffs(l_205)))) || ((uint16_t)(l_205 | 0x2D74585E) - (uint16_t)p_72))) >> (uint16_t)0) == p_71), l_198))
                    { /* block id: 133 */
                        return l_205;
                    }
                    else
                    { /* block id: 135 */
                        int32_t l_208 = 1;
                        int32_t l_216 = 0x09106084;
                        l_208 = func_80(p_71, l_192);
                        p_71 = (l_209 < func_74((l_210 != l_209), l_178));
                        l_211 = (p_73 >= p_72);
                        l_216 = (l_185 || (__builtin_ctzll((((int16_t)((int16_t)p_72 << (int16_t)1) >> (int16_t)13) == (-2))) || p_72));
                    }
                }
            }
            else
            { /* block id: 142 */
                float l_217 = 0xF.458F5Fp+46;
                int32_t l_219 = 0x1A3699C2;
                struct S0 l_240 = {0,4294967295U,0,0x7C5D,0xF7B942CA,9,1};
                if ((l_185 != p_71))
                { /* block id: 143 */
                    struct S0 l_218 = {0x3124,0x1641BD3B,0,0xAC38,0xD05F3529,0,0xFA422619};
                    l_217 = 0x6.FA3906p+59;
                    l_218 = l_195;
                    if ((l_195.f4 >= p_73))
                    { /* block id: 146 */
                        int32_t l_226 = 0xFE747541;
                        l_185 = __builtin_ctz(l_219);
                        p_71 = (((l_185 < ((int32_t)((((int16_t)((int32_t)l_226 - (int32_t)func_80((l_192 > (p_73 && (func_80(l_185, p_72) && (l_192 <= ((uint32_t)p_73 % (uint32_t)0x3A199CE5))))), p_73)) >> (int16_t)1) && p_71) ^ l_195.f6) - (int32_t)0xF7CC2139)) < 0U) && 0xB63680A1);
                        l_195.f5 = (((((p_73 || ((p_72 ^ 65533U) && ((((p_71 && l_229) | p_72) == (0x7AC00EF3 || ((((uint16_t)p_73 % (uint16_t)(1U ^ 0xB8F7548C)) & 4294967288U) < 0xA21E))) <= 0x36DC))) == 4) < 65533U) < l_226) ^ 0);
                        l_195.f5 = (p_71 <= (l_219 < (!((p_72 < ((((+0x1.8p+1) == (l_219 == __builtin_ffs(p_73))) < l_219) != l_185)) <= p_73))));
                    }
                    else
                    { /* block id: 151 */
                        int32_t l_234 = (-5);
                        l_234 = p_73;
                        l_234 = ((((uint32_t)((~__builtin_ffs(l_229)) <= (((((uint16_t)(p_73 | p_71) << (uint16_t)(0x0147 == 5U)) & p_73) & 4294967286U) >= l_234)) % (uint32_t)l_195.f0) <= p_71) | 0x1BB4);
                        p_71 = (-1);
                    }
                    l_240 = l_240;
                }
                else
                { /* block id: 157 */
                    uint16_t l_241 = 0xD67F;
                    l_240 = l_195;
                    l_241 = func_80(p_72, l_192);
                    for (l_195.f6 = 6; (l_195.f6 > (-4)); l_195.f6 -= 1)
                    { /* block id: 162 */
                        l_185 = ((float)l_192 - (float)p_71);
                    }
                }
                l_247 = l_246;
            }
        }
        else
        { /* block id: 168 */
            int8_t l_250 = 0;
            int32_t l_265 = 0;
            uint32_t l_303 = 1U;
            struct S0 l_309 = {0xA901,4294967289U,0xA88DE528,0xB5C6,0x15E0714F,-5,-5};
            if (((int16_t)func_80(p_71, p_73) << (int16_t)(p_73 == ((l_250 | p_71) && (1U && p_71)))))
            { /* block id: 169 */
                int16_t l_251 = (-1);
                struct S0 l_289 = {0xB604,0U,-1,1U,1,0x93B2AEE4,0xE5D3A11E};
                if ((((((0x827C | ((func_80(l_251, p_72) & p_72) >= ((((p_73 > ((p_72 >= p_72) > l_195.f4)) >= l_247.f2) < p_73) == l_195.f5))) && 8U) || p_73) > (-6)) == l_195.f3))
                { /* block id: 170 */
                    int16_t l_264 = 0xB8E4;
                    if ((p_72 | l_251))
                    { /* block id: 171 */
                        l_265 = func_80(l_250, ((int16_t)((((((func_80(((int16_t)((uint16_t)((int16_t)((uint16_t)(l_247.f6 > ((uint32_t)(l_247.f4 | l_251) + (uint32_t)0x79ECDA79)) - (uint16_t)p_72) + (int16_t)(0x2FD3 != p_73)) - (uint16_t)(__builtin_ctzll((0x5B75E65B & l_250)) >= 0x4029)) >> (int16_t)l_264), l_195.f2) <= 8) & 0x79DBF3E3) > 65530U) ^ 0x27D56CCA) || l_195.f0) <= l_250) - (int16_t)p_73));
                    }
                    else
                    { /* block id: 173 */
                        uint16_t l_284 = 65535U;
                        l_284 = (func_74(l_251, ((((float)(0x6.5p+1 != l_195.f0) + (float)((0x0.4384E5p+20 < ((float)((float)(((float)l_274 - (float)p_71) >= (((float)p_73 - (float)((((((float)((!(((float)((p_71 == ((float)l_195.f0 + (float)p_71)) == 0x1.7p+1) + (float)l_264) != p_71)) == p_72) - (float)l_229) > l_195.f6) != l_195.f1) < (-0x2.6p-1)) > p_73)) <= l_264)) - (float)p_72) - (float)l_265)) < p_72)) == p_71) == p_73)) <= l_251);
                    }
                }
                else
                { /* block id: 176 */
                    struct S0 l_285 = {0x4E3B,0x7D680730,-10,1U,0x8F184546,0x99FC5A76,3};
                    l_285 = l_195;
                }
                for (l_195.f3 = 0; (l_195.f3 == 46); l_195.f3 += 8)
                { /* block id: 181 */
                    struct S0 l_288 = {-5,0xB4845BDF,0,65535U,0x6D310122,2,0x5FD38649};
                    l_289 = l_288;
                }
                l_289.f6 = ((((((int32_t)(((p_73 == (p_71 ^ (l_289.f4 != ((int32_t)((0xE038 < p_71) != 0U) + (int32_t)l_247.f5)))) != (((((p_73 != __builtin_ffsl(l_265)) != (-5)) && l_289.f0) >= 5U) > l_247.f3)) >= 4294967295U) - (int32_t)0xCEC06D11) <= 0x77ED) || l_289.f5) > p_71) && 0xFFCF);
            }
            else
            { /* block id: 185 */
                uint32_t l_327 = 4294967295U;
                float l_334 = 0x4.EA5E7Dp+65;
                int32_t l_350 = 0xA75C8738;
                struct S0 l_370 = {-6,4294967295U,0,0x01C3,0x7F9DD4E9,2,0x13159631};
                if (__builtin_popcountl(l_195.f1))
                { /* block id: 186 */
                    int32_t l_297 = 0x9BEE199B;
                    l_297 = (!((float)l_297 + (float)0x1.6p+1));
                    return l_297;
                }
                else
                { /* block id: 189 */
                    int8_t l_298 = 5;
                    struct S0 l_306 = {0x1938,4294967295U,0x776390C7,1U,0,5,-1};
                    if (l_298)
                    { /* block id: 190 */
                        p_71 = ((l_298 && l_247.f1) < (p_73 & l_195.f4));
                        return p_71;
                    }
                    else
                    { /* block id: 193 */
                        int16_t l_300 = (-1);
                        int32_t l_304 = (-3);
                        struct S0 l_305 = {0x0471,4294967286U,0xA1B39F6D,65532U,0x3DC06B8A,1,0xDFF8A22B};
                        l_304 = (((-(int32_t)__builtin_popcount(p_71)) > l_300) & ((uint16_t)(l_303 > p_71) >> (uint16_t)p_72));
                        l_247.f6 = p_72;
                        l_304 = p_71;
                        l_306 = l_305;
                    }
                    for (l_247.f0 = 0; (l_247.f0 > (-1)); l_247.f0 -= 3)
                    { /* block id: 201 */
                        int8_t l_312 = (-10);
                        l_195 = l_309;
                        l_312 = (6U != ((uint16_t)p_72 - (uint16_t)0));
                    }
                }
                if (((((uint16_t)(((__builtin_ctzll(((((uint16_t)l_309.f5 << (uint16_t)6) ^ (((((int16_t)(l_195.f3 && ((7 == l_309.f5) == p_72)) % (int16_t)((uint32_t)p_71 + (uint32_t)l_185)) ^ (((uint16_t)(l_309.f5 ^ (__builtin_ffs(((int16_t)l_309.f4 - (int16_t)0x9CB0)) != 9)) >> (uint16_t)p_71) >= l_327)) != l_247.f1) <= 0xB7DE)) <= l_247.f4)) || 0xE5E3) && 0x1F2281E6) > l_195.f5) - (uint16_t)l_274) != l_195.f6) ^ p_73))
                { /* block id: 206 */
                    l_185 = (4294967295U >= ((uint16_t)((int16_t)func_74(l_327, p_72) << (int16_t)(p_73 == ((p_73 == ((int16_t)__builtin_ia32_crc32qi(func_74(l_247.f1, l_195.f4), l_247.f2) >> (int16_t)p_73)) >= p_71))) << (uint16_t)14));
                }
                else
                { /* block id: 208 */
                    int32_t l_337 = 0xD4037252;
                    p_71 = __builtin_ctz((l_274 == 4));
                    l_350 = (l_327 ^ (((int16_t)((l_337 | p_72) ^ __builtin_parityll((p_71 && (((int16_t)((int16_t)(((-(uint16_t)l_309.f6) | l_247.f1) && ((p_73 ^ (((uint16_t)(l_337 <= ((uint16_t)((int16_t)func_74(p_73, l_195.f4) << (int16_t)l_327) << (uint16_t)15)) >> (uint16_t)p_73) || 0x28B10FAF)) || l_250)) << (int16_t)3) << (int16_t)p_72) == p_73)))) % (int16_t)0xBBBB) > l_195.f2));
                }
                l_178 = p_72;
                if (((((int16_t)1 + (int16_t)(func_80(p_72, l_309.f5) | (p_71 & (((int16_t)(!(((uint16_t)((int16_t)((uint32_t)((uint16_t)(p_73 ^ l_309.f1) << (uint16_t)(((uint32_t)p_71 % (uint32_t)p_71) == 0x13E87386)) - (uint32_t)l_247.f5) - (int16_t)65535U) % (uint16_t)l_195.f0) | p_73)) << (int16_t)l_327) > l_178)))) || l_327) < l_366))
                { /* block id: 213 */
                    int32_t l_367 = (-8);
                    l_367 = 0x6.7D93E5p-73;
                    for (l_309.f5 = 0; (l_309.f5 <= (-2)); l_309.f5 -= 5)
                    { /* block id: 217 */
                        int32_t l_371 = 0x710A7853;
                        l_370 = l_247;
                        if (l_371)
                            break;
                        l_265 = p_71;
                        if (l_303)
                            break;
                    }
                }
                else
                { /* block id: 223 */
                    return p_71;
                }
            }
            for (l_247.f2 = 0; (l_247.f2 < 15); ++l_247.f2)
            { /* block id: 229 */
                uint32_t l_377 = 0xC3A35A31;
                int32_t l_380 = 1;
                struct S0 l_389 = {4,0x518BF8B1,0x059FE580,0x17C5,7,-1,0};
                l_377 = ((uint16_t)((l_195.f2 < l_247.f5) <= 0xA394) >> (uint16_t)(func_80(l_195.f4, l_250) || l_247.f0));
                if ((0x22F5 > (0x288BBBB0 == ((uint16_t)0x890C >> (uint16_t)12))))
                { /* block id: 231 */
                    l_380 = l_309.f5;
                }
                else
                { /* block id: 233 */
                    uint16_t l_387 = 0x0E2A;
                    float l_391 = 0x0.6p+1;
                    if (__builtin_popcount(((((int32_t)func_80(p_72, p_73) + (int32_t)0x031D18E5) || (p_72 | ((int16_t)0x092F - (int16_t)((((int32_t)((p_71 < l_387) | (0x38705546 == p_72)) % (int32_t)l_388) >= 0xA6F6C273) && (-1))))) > 4U)))
                    { /* block id: 234 */
                        struct S0 l_390 = {-1,6U,0xA1468003,0xFF32,-5,0xDF09485D,0xA29ADFA5};
                        l_389 = l_389;
                        l_389 = l_390;
                    }
                    else
                    { /* block id: 237 */
                        l_195 = l_195;
                        l_380 = func_80(func_80(l_309.f1, (__builtin_ffs(p_73) | (__builtin_ffsl(l_247.f1) < p_73))), (func_74(l_389.f3, ((float)((float)0xA.963E05p+31 + (float)p_72) - (float)0x7.BA0361p-27)) & 0));
                    }
                    l_247.f6 = 0x0429A4FD;
                    l_389.f6 = p_73;
                }
            }
        }
        l_185 = l_195.f4;
        p_71 = ((uint16_t)l_195.f0 << (uint16_t)p_71);
    }
    else
    { /* block id: 248 */
        l_195.f5 = (p_72 > (l_195.f5 == p_71));
    }
    l_178 = ((int16_t)p_71 << (int16_t)(l_388 ^ p_73));
    l_404 = ((-0x1.Fp-1) != ((((float)l_404 + (float)(l_388 >= l_195.f2)) >= func_74(l_405, p_73)) < 0x3.25628Fp-12));
    if (l_405)
    { /* block id: 253 */
        for (l_195.f2 = (-16); (l_195.f2 >= 12); l_195.f2 += 1)
        { /* block id: 256 */
            return p_73;
        }
        for (l_388 = 0; (l_388 != 52); ++l_388)
        { /* block id: 261 */
            return p_71;
        }
        l_195.f6 = (0x2.6599EEp-10 >= (!p_72));
    }
    else
    { /* block id: 265 */
        int32_t l_411 = 3;
        l_411 = l_195.f1;
    }
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_74(uint16_t  p_75, float  p_76)
{ /* block id: 85 */
    int32_t l_122 = (-1);
    int32_t l_136 = (-1);
    float l_137 = (-0x6.Ap+1);
    int32_t l_147 = 1;
    struct S0 l_158 = {1,0x592EE31D,-2,0xCBE7,8,1,1};
    int16_t l_176 = 0x62B2;
    l_122 = __builtin_parityll(p_75);
    for (l_122 = 0; (l_122 <= 22); l_122++)
    { /* block id: 89 */
        int32_t l_129 = (-8);
        int32_t l_138 = 7;
        struct S0 l_148 = {0xED02,0x9C021E97,-1,0x06E0,0x3A779F58,0xA2508C1D,0x4CFA5E24};
        l_136 = ((uint16_t)(((int16_t)l_129 << (int16_t)2) != ((l_129 < (l_122 == ((int32_t)l_129 + (int32_t)((uint16_t)((int16_t)(l_129 ^ (((p_75 ^ (p_75 < ((func_80(p_75, l_122) || 65530U) == l_122))) >= l_122) && l_129)) << (int16_t)l_122) >> (uint16_t)p_75)))) == p_75)) % (uint16_t)0x8E2B);
        l_138 = p_75;
        if (l_122)
            continue;
        for (l_136 = 2; (l_136 >= 7); l_136 += 9)
        { /* block id: 95 */
            int32_t l_143 = 5;
            struct S0 l_149 = {0x8BF0,0xE390C49C,-1,8U,0x46F7BBE7,0x6ADAD851,-1};
            l_147 = (__builtin_ffsll(l_136) && (p_75 != (((((l_138 | ((int16_t)p_75 >> (int16_t)((l_143 == p_75) & (+(((int16_t)__builtin_ctzl(p_75) - (int16_t)(-7)) <= l_122))))) ^ l_129) > p_75) | p_75) | l_138)));
            l_149 = l_148;
            l_149 = l_148;
            l_148 = l_149;
        }
    }
    if (l_147)
    { /* block id: 102 */
        uint16_t l_153 = 0x1173;
        int32_t l_156 = 0xBB1117FE;
        if ((((int16_t)l_136 >> (int16_t)(-(uint16_t)0x63A6)) & __builtin_bswap32(l_122)))
        { /* block id: 103 */
            uint32_t l_154 = 3U;
            int32_t l_155 = 0;
            l_153 = (p_75 == l_147);
            l_155 = __builtin_ffs(l_154);
            l_156 = (l_153 | 0x872FA332);
        }
        else
        { /* block id: 107 */
            uint16_t l_157 = 0xD86D;
            p_76 = p_75;
            return l_157;
        }
        l_158 = l_158;
    }
    else
    { /* block id: 112 */
        int32_t l_159 = 0xE011399F;
        l_159 = l_158.f6;
        l_136 = l_159;
        p_76 = p_76;
        for (l_158.f1 = 25; (l_158.f1 <= 47); l_158.f1 += 1)
        { /* block id: 118 */
            int16_t l_164 = (-9);
            uint32_t l_169 = 0x1057C5A9;
            l_122 = ((l_158.f2 == ((int32_t)(l_164 | 0xD35642D3) + (int32_t)((int32_t)((int16_t)(0x2313 > func_80((((l_169 || __builtin_popcountl(((int16_t)((((uint16_t)(0 < l_122) >> (uint16_t)((((int16_t)(p_75 | (((0 < l_176) > p_75) < l_159)) % (int16_t)l_147) == l_159) < p_75)) & 2) || 0xD788D995) + (int16_t)0xBE49))) != 0x0EB1AB08) == p_75), l_159)) << (int16_t)l_159) % (int32_t)l_159))) && p_75);
        }
    }
    return l_122;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_80(int8_t  p_81, uint32_t  p_82)
{ /* block id: 39 */
    struct S0 l_85 = {0x738B,4294967294U,1,0xF270,1,0,0xE83987ED};
    struct S0 l_90 = {0xFDEE,4U,0x8558EF10,8U,8,1,0x1D694BF0};
    l_85 = l_85;
    l_85.f6 = 1;
    l_85.f5 = p_82;
    for (l_85.f6 = 14; (l_85.f6 == (-10)); l_85.f6 -= 4)
    { /* block id: 45 */
        uint16_t l_97 = 0x71D4;
        int32_t l_109 = 0x52B1B1FA;
        int16_t l_116 = 0xC0F6;
        struct S0 l_119 = {0xA381,0xE0D8C1B6,0,0x4986,1,-1,6};
        if (p_81)
        { /* block id: 46 */
            uint32_t l_98 = 0x3EB33379;
            for (l_85.f3 = (-24); (l_85.f3 <= 38); l_85.f3 += 4)
            { /* block id: 49 */
                int32_t l_103 = 0;
                int32_t l_104 = 0x1A1E6DEA;
                struct S0 l_108 = {5,0U,0x84503A70,0x4D2A,0x3227D8CF,3,0x5FDDB278};
                l_90 = l_85;
                if ((p_81 <= ((((int16_t)0x0EAC >> (int16_t)15) | ((((uint16_t)((uint16_t)(l_97 & l_98) - (uint16_t)1U) >> (uint16_t)__builtin_bswap64((__builtin_bswap32((((-8) & ((int16_t)__builtin_popcountll(((int32_t)((0U != ((l_103 & (__builtin_ctzl(l_98) > 1U)) == p_81)) & p_81) - (int32_t)l_97)) >> (int16_t)p_82)) >= 0x113439BF)) < l_98))) || l_103) >= l_104)) && p_81)))
                { /* block id: 51 */
                    struct S0 l_107 = {-7,6U,2,0xB86B,0xEF1402E7,-1,8};
                    if (p_82)
                    { /* block id: 52 */
                        int32_t l_106 = 0x1B7CE843;
                        l_106 = (+(-0x1.1p-1));
                        l_106 = 7;
                    }
                    else
                    { /* block id: 55 */
                        l_108 = l_107;
                        if (p_82)
                            continue;
                    }
                    l_108.f5 = p_82;
                    l_107.f5 = l_107.f4;
                    return p_82;
                }
                else
                { /* block id: 62 */
                    l_109 = p_81;
                    l_108 = l_108;
                    l_90.f5 = p_81;
                }
                l_103 = ((0x9543 != ((int16_t)(l_90.f0 ^ 0U) << (int16_t)l_90.f6)) <= ((uint16_t)p_81 << (uint16_t)2));
            }
            l_109 = __builtin_clzll((((int16_t)(l_116 <= (((l_90.f2 > (l_85.f6 || ((uint16_t)((0x1B53E36E <= l_90.f0) >= 0x754D) << (uint16_t)2))) >= p_81) != p_82)) << (int16_t)(l_85.f3 == 6U)) || l_98));
            l_119 = l_119;
            if (l_119.f1)
                continue;
        }
        else
        { /* block id: 72 */
            for (l_90.f4 = 0; (l_90.f4 < 7); ++l_90.f4)
            { /* block id: 75 */
                if (p_81)
                    break;
                if (p_81)
                    continue;
                if (p_81)
                    break;
                l_90.f5 = 0x0.Bp+1;
            }
            l_119.f5 = (-1);
        }
    }
    return l_90.f2;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 113
   depth: 1, occurrence: 32
XXX total union variables: 11

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 214
   depth: 2, occurrence: 39
   depth: 3, occurrence: 9
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 4
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 3
   depth: 16, occurrence: 3
   depth: 17, occurrence: 2
   depth: 18, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 26, occurrence: 2
   depth: 27, occurrence: 2
   depth: 30, occurrence: 1

XXX total number of pointers: 0

XXX times a non-volatile is read: 600
XXX times a non-volatile is write: 136
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 189
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 31
   depth: 2, occurrence: 27
   depth: 3, occurrence: 24
   depth: 4, occurrence: 37
   depth: 5, occurrence: 35

XXX percentage a fresh-made variable is used: 20.4
XXX percentage an existing variable is used: 79.6
********************* end of statistics **********************/

