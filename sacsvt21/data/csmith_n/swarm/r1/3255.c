/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --no-volatiles --no-volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      1181546152
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static uint32_t  func_30(void);
static uint16_t  func_33(uint32_t  p_34, uint32_t  p_35, union U0  p_36);
static union U0  func_38(uint16_t  p_39, uint16_t  p_40);
static int32_t * func_41(uint32_t  p_42, int32_t * p_43, uint16_t  p_44);
static const union U0  func_46(uint16_t  p_47, int16_t  p_48, int32_t * p_49, int32_t  p_50);
static int32_t  func_53(int32_t * p_54, int32_t  p_55);
static int32_t * func_56(int32_t  p_57, int32_t  p_58, int32_t * p_59, int32_t * p_60);
static const int16_t  func_75(const uint32_t  p_76, union U0  p_77, int32_t * p_78);
static union U0  func_80(uint32_t  p_81);
static int32_t * func_83(uint32_t  p_84, const uint32_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_30(void)
{ /* block id: 36 */
    int32_t l_37 = (-6);
    const uint32_t l_735 = 0xE7760B88;
    int16_t l_749 = 0;
    union U0 l_750 = {0x0069};
    union U0 *l_772 = &l_750;
    union U0 **l_771 = &l_772;
    uint32_t l_779 = 0U;
    uint32_t l_780 = 0x5C9A0CE8;
    int32_t l_784 = 0x897E297A;
    int32_t *l_785 = &l_784;
    int32_t l_786 = 0x2EB57416;
    if ((safe_lshift_func_uint16_t_u_u(func_33(l_37, __builtin_popcountl((l_37 && ((func_38(l_37, l_37) , __builtin_ia32_crc32qi(__builtin_ffsll((safe_sub_func_int32_t_s_s(((safe_add_func_int32_t_s_s(l_37, l_735)) | (safe_rshift_func_uint16_t_u_u((((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_u(((safe_mod_func_uint16_t_u_u((safe_unary_minus_func_int32_t_s(((safe_sub_func_int16_t_s_s(__builtin_ctz((safe_lshift_func_uint16_t_u_s(l_37, (((l_735 > l_37) != l_37) ^ 0x89E91BA2)))), l_735)) & l_735))), l_735)) < 0x7F3E), 6)), l_37)) , l_37) <= l_37), 8))), l_749))), l_37)) <= (-1)))), l_750), l_749)))
    { /* block id: 426 */
        int32_t *l_758 = &l_37;
        int32_t **l_757 = &l_758;
        int32_t ***l_756 = &l_757;
        int32_t ****l_755 = &l_756;
        union U0 **l_781 = (void*)0;
        (****l_755) = ((void*)0 == l_755);
        (***l_756) = ((((**l_757) & ((safe_sub_func_uint32_t_u_u((l_750.f0 | 0x3547BAD1), ((((safe_sub_func_int16_t_s_s(((safe_sub_func_uint32_t_u_u((l_735 ^ (safe_add_func_int32_t_s_s((__builtin_ctzll(((safe_add_func_int32_t_s_s(__builtin_popcountll(func_75(((safe_sub_func_uint16_t_u_u(((*l_758) >= (l_771 != ((safe_rshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u((l_37 < (safe_lshift_func_uint16_t_u_s(__builtin_parity((****l_755)), (****l_755)))), l_37)), (***l_756))) , (void*)0))), (**l_757))) , (****l_755)), (**l_771), &l_37)), 8U)) , (*l_758))) , 0x8C1E4745), (****l_755)))), l_779)) < (****l_755)), (****l_755))) & l_780) , 0x9F992E5A) , 0x7454F8E0))) , 0x7A383ACE)) , l_781) != (void*)0);
    }
    else
    { /* block id: 429 */
        uint32_t l_782 = 0x0AEAC9B2;
        int32_t *l_783 = &l_37;
        (*l_783) = l_782;
    }
    (*l_785) = l_784;
    return l_786;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_33(uint32_t  p_34, uint32_t  p_35, union U0  p_36)
{ /* block id: 422 */
    int32_t l_752 = 0x5DE34237;
    int32_t *l_751 = &l_752;
    const int32_t *l_754 = (void*)0;
    const int32_t **l_753 = &l_754;
    (*l_753) = l_751;
    /* statement id: 423 */
    assert (l_754 == &l_752);
    (*l_753) = func_83((func_46((*l_754), p_35, &l_752, (*l_751)) , p_36.f0), ((**l_753) | (&l_754 == &l_754)));
    /* statement id: 424 */
    assert (l_754 == 0);
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_38(uint16_t  p_39, uint16_t  p_40)
{ /* block id: 37 */
    int32_t l_45 = 0xB2E809B4;
    int32_t l_62 = 0;
    int32_t *l_61 = &l_62;
    uint16_t l_658 = 0xE57B;
    int32_t **l_661 = (void*)0;
    int32_t **l_662 = &l_61;
    union U0 l_685 = {0xE405};
    union U0 *l_684 = &l_685;
    union U0 **l_683 = &l_684;
    union U0 ***l_682 = &l_683;
    const int32_t *l_689 = &l_62;
    int32_t l_717 = 1;
    int32_t ***l_727 = &l_662;
    int32_t ****l_726 = &l_727;
    uint32_t l_728 = 4294967295U;
    uint32_t l_729 = 0x9FC8B0D1;
    union U0 l_730 = {1U};
    (*l_662) = func_41((((p_39 , (l_45 > (((func_46(p_40, ((safe_mod_func_int32_t_s_s(func_53(func_56(p_39, l_45, l_61, &l_62), (l_45 <= l_45)), l_45)) | 0), l_61, p_39) , (*l_61)) || (-6)) | 0x2C4C))) < 0x2976) <= 65529U), l_61, l_658);
    if ((*l_61))
    { /* block id: 378 */
        uint16_t l_668 = 1U;
        union U0 l_669 = {0x098E};
        int32_t *l_670 = &l_62;
        union U0 ***l_681 = (void*)0;
        for (l_45 = 4; (l_45 <= 17); ++l_45)
        { /* block id: 381 */
            uint32_t l_667 = 4294967295U;
            union U0 l_690 = {65528U};
            int32_t l_701 = 0x9A347A0E;
            const int32_t *l_702 = &l_62;
            if (p_39)
                break;
            if (__builtin_ctzl((safe_add_func_int16_t_s_s(func_75(((((0 != (p_40 & l_667)) > (-4)) , (p_40 < 4294967295U)) <= l_668), l_669, l_670), 0x7E8A))))
            { /* block id: 383 */
                const int32_t l_674 = 0x2CF0D54F;
                int32_t *l_687 = (void*)0;
                if (p_40)
                { /* block id: 384 */
                    int16_t l_686 = (-1);
                    int32_t *l_691 = (void*)0;
                    if (((((l_667 , (func_53(l_670, ((func_75(((((safe_rshift_func_int16_t_s_u(p_39, (((!l_674) != (((safe_sub_func_int16_t_s_s(p_39, ((((0U || (safe_sub_func_int16_t_s_s(((l_674 , (l_667 && (l_681 != l_682))) && l_686), p_39))) <= (*l_61)) || (*l_61)) || 0xC37E2B9E))) || p_40) , (*l_670))) | (-10)))) == 0xACA28861) || 0x28AF2A78) | p_39), (*l_684), l_687) != p_40) , (-2))) == 0x4373)) | p_40) <= l_686) ^ 1))
                    { /* block id: 385 */
                        int32_t **l_688 = (void*)0;
                        l_689 = (p_39 , &l_674);
                        /* statement id: 386 */
                        assert (l_689 == &l_674);
                        return l_690;
                        /* statement id: 387 */
                                            }
                    else
                    { /* block id: 388 */
                        uint32_t l_700 = 4294967295U;
                        l_691 = (void*)0;
                        l_701 = (safe_sub_func_uint32_t_u_u(p_39, (safe_rshift_func_int16_t_s_u((65535U == (-10)), (((safe_mul_func_uint16_t_u_u(((void*)0 != &l_683), ((((safe_add_func_int16_t_s_s(p_39, (0xC7C1 ^ (p_40 >= l_700)))) == (*l_670)) & (*l_670)) < (-1)))) > l_700) && l_667)))));
                        l_702 = (void*)0;
                        /* statement id: 391 */
                        assert (l_702 == 0);
                        (*l_670) = p_40;
                    }
                    /* facts after branching */
                    assert (l_702 == 0);
                    for (l_686 = 27; (l_686 < 12); --l_686)
                    { /* block id: 396 */
                        (**l_662) = p_39;
                    }
                }
                else
                { /* block id: 399 */
                    union U0 ***l_705 = &l_683;
                    l_701 = ((void*)0 != l_705);
                }
                /* facts after branching */
                assert (l_702 == &l_62 || l_702 == 0);
            }
            else
            { /* block id: 402 */
                return l_690;
                /* statement id: 403 */
                            }
            /* facts after branching */
            assert (l_702 == &l_62 || l_702 == 0);
            l_670 = ((*l_61) , (*l_662));
        }
    }
    else
    { /* block id: 407 */
        uint32_t l_708 = 4294967295U;
        int32_t *l_712 = (void*)0;
        (**l_662) = (safe_mod_func_uint32_t_u_u(l_708, (safe_lshift_func_int16_t_s_u((&l_683 != ((***l_682) , &l_683)), 3))));
        if (p_40)
            goto lbl_711;
lbl_711:
        (**l_682) = (*l_683);
        l_712 = (void*)0;
    }
    for (p_39 = (-13); (p_39 > 3); p_39 = safe_add_func_int32_t_s_s(p_39, 8))
    { /* block id: 415 */
        const int32_t *l_715 = &l_62;
        int32_t **l_716 = &l_61;
        (**l_662) = 4;
        (*l_716) = l_715;
        (*l_61) = ((void*)0 == &l_61);
    }
    (****l_726) = (func_53((*l_662), (((((l_717 & (***l_727)) ^ 0x4017) != (*l_689)) | (*l_61)) , (*l_689))) ^ l_729);
    return l_730;
    /* statement id: 421 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_41(uint32_t  p_42, int32_t * p_43, uint16_t  p_44)
{ /* block id: 375 */
    int32_t l_660 = 0x3EA2E0B0;
    int32_t *l_659 = &l_660;
    return p_43;
    /* statement id: 376 */
    //assert (func_41_rv == &l_62);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const union U0  func_46(uint16_t  p_47, int16_t  p_48, int32_t * p_49, int32_t  p_50)
{ /* block id: 214 */
    int32_t l_350 = (-1);
    union U0 l_354 = {0xA857};
    union U0 *l_353 = &l_354;
    union U0 **l_352 = &l_353;
    union U0 ***l_351 = &l_352;
    const uint16_t l_357 = 65530U;
    int16_t l_358 = (-6);
    int32_t l_367 = 1;
    int32_t *l_366 = &l_367;
    int32_t **l_376 = &l_366;
    int32_t ***l_375 = &l_376;
    uint16_t l_639 = 0U;
    const union U0 l_657 = {2U};
    l_358 = (((safe_lshift_func_uint16_t_u_u(((l_350 , __builtin_clz(p_48)) , ((((void*)0 != l_351) , (((void*)0 == (*l_351)) == (*p_49))) & l_357)), p_50)) == 0x6CB6) && (*p_49));
    if (__builtin_bswap64(p_47))
    { /* block id: 216 */
        int32_t l_360 = 0x312D83D5;
        int32_t *l_359 = &l_360;
        int32_t **l_361 = &l_359;
        (*l_361) = l_359;
        (*l_359) = 0x268C0C08;
    }
    else
    { /* block id: 219 */
        const uint32_t l_362 = 0x0760AC32;
        int32_t **l_363 = (void*)0;
        int32_t **l_364 = (void*)0;
        int32_t **l_365 = (void*)0;
        union U0 l_370 = {0x0571};
        union U0 ***l_395 = &l_352;
        int32_t l_397 = (-7);
        int32_t ****l_423 = &l_375;
        int32_t *****l_427 = (void*)0;
        uint32_t l_502 = 0xA03D8602;
        const union U0 l_514 = {65535U};
        const union U0 *l_559 = &l_354;
        uint32_t l_571 = 3U;
        int32_t *l_615 = (void*)0;
        l_366 = func_83(p_48, l_362);
        /* statement id: 220 */
        assert (l_366 == 0);
        for (p_48 = 0; (p_48 == (-13)); p_48 = safe_sub_func_int32_t_s_s(p_48, 8))
        { /* block id: 223 */
            int32_t *l_371 = (void*)0;
            const int32_t **l_372 = (void*)0;
            int32_t **l_373 = &l_366;
            (*l_373) = (l_370 , l_371);
            p_49 = (void*)0;
            /* statement id: 225 */
            assert (p_49 == 0);
        }
        /* facts after for loop */
        //assert (p_49 == 0 || p_49 == &l_62 || p_49 == &l_752);
    }
    /* facts after branching */
    //assert (p_49 == 0 || p_49 == &l_62 || p_49 == &l_752);
    assert (l_366 == 0 || l_366 == &l_367);
    (**l_375) = (void*)0;
    /* statement id: 373 */
    assert (l_366 == 0);
    return l_657;
    /* statement id: 374 */
    }


/* ------------------------------------------ */
/* 
 * reads : l_62
 * writes: l_62
 */
static int32_t  func_53(int32_t * p_54, int32_t  p_55)
{ /* block id: 78 */
    int32_t l_129 = 0;
    int16_t l_130 = 0x4F91;
    int32_t *l_131 = (void*)0;
    int32_t l_134 = 0x54CFDD0F;
    int32_t **l_167 = &l_131;
    int32_t ***l_166 = &l_167;
    int32_t l_179 = 0xB2834994;
    int32_t *l_178 = &l_179;
    const uint16_t l_183 = 0xC111;
    union U0 l_290 = {7U};
    const uint16_t l_298 = 0x29B9;
    int16_t l_327 = 0xAF17;
    uint16_t l_332 = 65535U;
    int32_t l_346 = 1;
    int32_t l_347 = 0xDD6AA6D1;
    if ((safe_sub_func_uint16_t_u_u((((safe_lshift_func_uint16_t_u_u(p_55, (p_55 == __builtin_parityll((func_80((safe_sub_func_int16_t_s_s(func_75(__builtin_bswap32(l_129), func_80(l_130), l_131), (safe_add_func_uint32_t_u_u(((l_131 != (void*)0) || 4294967292U), (*p_54)))))) , l_134))))) , (-5)) , l_129), p_55)))
    { /* block id: 79 */
        uint32_t l_136 = 0xD3FBECF3;
        int32_t l_143 = 0xFE4DFDC5;
        union U0 l_165 = {0x7E53};
        int16_t l_175 = 0;
        l_143 = (((safe_unary_minus_func_int16_t_s((l_136 || ((safe_unary_minus_func_int32_t_s((safe_mod_func_int16_t_s_s(__builtin_popcountl((p_55 && ((*p_54) & ((p_55 , (safe_mod_func_int16_t_s_s(((!l_136) , (l_129 < 0x60AD585B)), __builtin_popcount(p_55)))) > (*p_54))))), p_55)))) | 4U)))) <= p_55) == l_136);
        if ((*p_54))
        { /* block id: 81 */
            int32_t **l_146 = &l_131;
            int32_t ***l_145 = &l_146;
            int32_t ****l_144 = &l_145;
            int32_t *****l_147 = &l_144;
            (*p_54) = (*p_54);
            (*l_147) = l_144;
        }
        else
        { /* block id: 84 */
            const int16_t l_159 = 8;
            const int32_t *l_170 = (void*)0;
            const int32_t **l_169 = &l_170;
            const int32_t ***l_168 = &l_169;
            for (p_55 = 9; (p_55 == 0); p_55 = safe_sub_func_uint32_t_u_u(p_55, 1))
            { /* block id: 87 */
                int16_t l_152 = 0xC5A2;
                union U0 l_156 = {0x9FE0};
                (*p_54) = 0x822E8431;
                for (l_134 = (-1); (l_134 < 23); l_134 = safe_add_func_uint16_t_u_u(l_134, 2))
                { /* block id: 91 */
                    (*p_54) = l_152;
                }
                (*p_54) = (~(l_152 ^ func_75(((((((safe_sub_func_uint16_t_u_u((l_156 , l_143), (safe_rshift_func_uint16_t_u_u(l_159, 9)))) , (!(*p_54))) , (safe_mod_func_uint32_t_u_u((((((__builtin_clzll((l_136 < (safe_add_func_uint16_t_u_u(0x223B, l_156.f0)))) , p_55) | 0x9A1ECA9F) == 4294967293U) && l_159) & p_55), l_156.f0))) > 0U) , l_152) <= l_156.f0), l_165, &l_143)));
                return (*p_54);
            }
            if ((l_166 != l_168))
            { /* block id: 97 */
                return (*p_54);
            }
            else
            { /* block id: 99 */
                for (l_165.f0 = (-11); (l_165.f0 == 16); l_165.f0 = safe_add_func_int32_t_s_s(l_165.f0, 9))
                { /* block id: 102 */
                    for (p_55 = (-10); (p_55 <= (-20)); p_55 = safe_sub_func_int16_t_s_s(p_55, 3))
                    { /* block id: 105 */
                        (*l_167) = &l_143;
                        /* statement id: 106 */
                        assert (l_131 == &l_143);
                    }
                }
                /* facts after for loop */
                assert (l_131 == &l_143 || l_131 == 0);
                return (*p_54);
            }
        }
        (*p_54) = ((0xE8ED7A3F && l_175) ^ ((((__builtin_parityll(l_143) < l_143) > l_175) | (safe_sub_func_uint32_t_u_u((__builtin_popcountl(l_143) != p_55), p_55))) > p_55));
        (*l_167) = &p_55;
        /* statement id: 113 */
        assert (l_131 == &p_55);
    }
    else
    { /* block id: 114 */
        union U0 l_184 = {0xDF11};
        int32_t *l_185 = &l_179;
        int32_t ****l_204 = &l_166;
        uint16_t l_209 = 1U;
        p_54 = l_178;
        /* statement id: 115 */
        assert (p_54 == &l_179);
        (*l_178) = (safe_sub_func_uint16_t_u_u((&p_55 == (void*)0), (!func_75(l_183, l_184, l_185))));
        if ((*l_185))
        { /* block id: 117 */
            uint16_t l_190 = 0x0A51;
            const int32_t *l_194 = &l_179;
            const int32_t **l_193 = &l_194;
            union U0 l_210 = {0xE7F3};
            int32_t *l_211 = &l_179;
            (*l_167) = (p_55 , &p_55);
            /* statement id: 118 */
            assert (l_131 == &p_55);
            (**l_167) = (__builtin_ctzll((safe_rshift_func_int16_t_s_u((safe_mod_func_int32_t_s_s(((l_190 ^ __builtin_ia32_crc32qi(l_190, l_190)) <= ((safe_add_func_uint16_t_u_u((((l_193 != (*l_166)) == 4294967295U) && (safe_add_func_int32_t_s_s((**l_167), 0xECA50655))), 0x8602)) , 0x706A3B5E)), 0x4ECBCE0E)), 9))) >= (*l_185));
            if ((safe_add_func_int16_t_s_s(__builtin_ia32_crc32qi((safe_lshift_func_int16_t_s_s((p_55 != (safe_lshift_func_int16_t_s_s((__builtin_ffs(((*l_185) | (*l_185))) <= (p_55 >= (~(-5)))), __builtin_ffsll(p_55)))), 4)), p_55), (**l_193))))
            { /* block id: 120 */
                p_54 = func_83(((1 >= ((l_204 == l_204) >= (safe_rshift_func_int16_t_s_s((__builtin_bswap64((func_75(p_55, (((func_75(((((-1) | 0) , ((safe_lshift_func_int16_t_s_u(p_55, (l_209 && (**l_193)))) < 0x0378)) , 0x184C14C3), l_210, l_211) < (****l_204)) , (*l_185)) , l_184), (***l_204)) < (*l_185))) & 0xD0560285), 0)))) , 4294967292U), p_55);
                /* statement id: 121 */
                assert (p_54 == 0);
            }
            else
            { /* block id: 122 */
                uint32_t l_223 = 1U;
                for (l_134 = 0; (l_134 < (-23)); l_134 = safe_sub_func_uint32_t_u_u(l_134, 8))
                { /* block id: 125 */
                    uint32_t l_226 = 7U;
                    (*l_211) = (*p_54);
                    (*l_185) = (((safe_add_func_uint16_t_u_u((((((~1) == (**l_167)) < (p_55 < (safe_add_func_int32_t_s_s((*p_54), (safe_add_func_int32_t_s_s(((l_223 , &p_55) == (void*)0), l_226)))))) > (*l_185)) >= (*p_54)), 0x2B1C)) | (*l_131)) != (**l_167));
                    if ((*p_54))
                        break;
                }
                (*l_131) = (l_223 ^ 0xA757);
                (*p_54) = __builtin_popcountll(l_223);
            }
            /* facts after branching */
            assert (p_54 == &l_179 || p_54 == 0);
        }
        else
        { /* block id: 133 */
            union U0 *l_228 = &l_184;
            union U0 **l_227 = &l_228;
            uint32_t l_231 = 0x33E33357;
            (*l_227) = &l_184;
            for (l_179 = (-2); (l_179 != 8); ++l_179)
            { /* block id: 137 */
                int32_t l_233 = 1;
                int32_t *l_232 = &l_233;
                int32_t *l_234 = (void*)0;
                (*l_232) = l_231;
                (*l_204) = (void*)0;
                /* statement id: 139 */
                assert (l_166 == 0);
                l_234 = l_234;
            }
            /* facts after for loop */
            assert (l_166 == 0 || l_166 == &l_167);
            (*l_167) = func_83((((((((safe_rshift_func_int16_t_s_s(p_55, (safe_lshift_func_uint16_t_u_u(func_75(((((**l_227) , l_231) & ((safe_sub_func_uint32_t_u_u((*l_185), ((p_55 <= (l_231 | (p_55 , (((*l_178) > (&l_204 != &l_204)) || (*l_178))))) , (*p_54)))) & (*p_54))) == l_231), (**l_227), l_185), l_231)))) || 0x2E6AD60D) != 0U) && (*l_178)) , 0) == (*l_185)) , p_55), p_55);
            (*l_185) = (l_231 >= l_231);
        }
        /* facts after branching */
        assert (p_54 == &l_179 || p_54 == 0);
        assert (l_131 == 0 || l_131 == &p_55);
        assert (l_166 == 0 || l_166 == &l_167);
        (*l_167) = &p_55;
        /* statement id: 145 */
        assert (l_131 == &p_55);
    }
    /* facts after branching */
    //assert (p_54 == &l_179 || p_54 == 0 || p_54 == &l_62 || p_54 == &l_396);
    assert (l_131 == &p_55);
    assert (l_166 == 0 || l_166 == &l_167);
    for (l_129 = 0; (l_129 == (-28)); l_129 = safe_sub_func_int16_t_s_s(l_129, 7))
    { /* block id: 149 */
        int32_t *l_243 = (void*)0;
        int32_t l_247 = 0;
        union U0 l_248 = {0xC69C};
        int32_t ****l_256 = &l_166;
        int32_t *****l_255 = &l_256;
        union U0 *l_267 = &l_248;
        union U0 **l_266 = &l_267;
        union U0 ***l_265 = &l_266;
        union U0 **l_301 = (void*)0;
        int32_t l_333 = 6;
        l_243 = l_243;
        for (l_179 = 0; (l_179 >= 4); ++l_179)
        { /* block id: 153 */
            int32_t l_246 = 1;
            int32_t ***l_282 = &l_167;
            uint32_t l_304 = 0U;
            int32_t *****l_336 = &l_256;
        }
    }
    (*l_131) = ((p_55 == (((safe_rshift_func_uint16_t_u_u(((((((*l_178) < (safe_add_func_int32_t_s_s((((((*l_131) >= 0x8E31144B) | __builtin_popcountl(((((!(*l_178)) >= (**l_167)) | (((~__builtin_ffsl(((**l_167) ^ l_346))) >= p_55) , 4294967295U)) ^ p_55))) == (**l_167)) < p_55), (*l_131)))) != p_55) >= p_55) & 0) >= 4294967287U), 15)) ^ (*l_178)) != p_55)) | 0xB8D7);
    return l_347;
}


/* ------------------------------------------ */
/* 
 * reads : l_62
 * writes: l_62
 */
static int32_t * func_56(int32_t  p_57, int32_t  p_58, int32_t * p_59, int32_t * p_60)
{ /* block id: 38 */
    int32_t l_82 = 0x559CDE89;
    int32_t l_122 = 0x420880F5;
    int32_t *l_121 = &l_122;
    (*p_60) = 0x0D7C8A36;
    for (p_58 = 0; (p_58 > (-23)); --p_58)
    { /* block id: 42 */
        const int32_t l_79 = 0x5662B132;
        union U0 l_119 = {65535U};
        union U0 *l_118 = &l_119;
        union U0 **l_120 = &l_118;
        (*p_59) = ((((0 <= (((((safe_lshift_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((((void*)0 != p_59) , (safe_mod_func_uint16_t_u_u((safe_lshift_func_int16_t_s_u((safe_rshift_func_int16_t_s_s(0xCC11, func_75(l_79, func_80(l_82), ((safe_sub_func_uint16_t_u_u((65535U && l_82), l_82)) , (void*)0)))), p_57)), p_57))), 9)), p_58)) > l_82) < (*p_59)) < (-8)) ^ l_79)) > l_82) | l_82) <= p_58);
        (*l_120) = l_118;
    }
    return p_60;
    /* statement id: 77 */
    //assert (func_56_rv == &l_62 || func_56_rv == &l_396);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_75(const uint32_t  p_76, union U0  p_77, int32_t * p_78)
{ /* block id: 72 */
    return p_77.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U0  func_80(uint32_t  p_81)
{ /* block id: 43 */
    union U0 l_111 = {0xCEEE};
    union U0 *l_110 = &l_111;
    union U0 l_115 = {0x4CD8};
    if (p_81)
    { /* block id: 44 */
        int32_t **l_91 = (void*)0;
        int32_t l_93 = 0x6EE4F120;
        int32_t *l_92 = &l_93;
        const union U0 l_94 = {0x1A0E};
        const int32_t *l_96 = &l_93;
        const int32_t **l_95 = &l_96;
        union U0 **l_112 = &l_110;
        l_92 = func_83(p_81, p_81);
        /* statement id: 49 */
        assert (l_92 == 0);
        (*l_95) = func_83((p_81 >= p_81), (l_94 , p_81));
        /* statement id: 50 */
        assert (l_96 == 0);
        for (p_81 = 0; (p_81 == 43); p_81 = safe_add_func_int32_t_s_s(p_81, 1))
        { /* block id: 53 */
            int32_t *l_99 = (void*)0;
            int32_t *l_100 = &l_93;
            union U0 l_109 = {0x9CFD};
            (*l_100) = 0x56627F1A;
            for (l_93 = 0; (l_93 <= 11); l_93 = safe_add_func_int16_t_s_s(l_93, 5))
            { /* block id: 57 */
                int32_t l_103 = 1;
                for (l_103 = 0; (l_103 == 3); l_103 = safe_add_func_uint16_t_u_u(l_103, 3))
                { /* block id: 60 */
                    union U0 l_107 = {65535U};
                    union U0 *l_106 = &l_107;
                    union U0 **l_108 = &l_106;
                    (*l_108) = l_106;
                }
            }
            return l_109;
            /* statement id: 64 */
                    }
        (*l_112) = l_110;
    }
    else
    { /* block id: 67 */
        int32_t l_114 = (-1);
        int32_t *l_113 = &l_114;
        (*l_113) = 1;
        (*l_113) = 0x732C3524;
    }
    return l_115;
    /* statement id: 71 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_83(uint32_t  p_84, const uint32_t  p_85)
{ /* block id: 45 */
    int32_t l_88 = 0;
    int32_t *l_87 = &l_88;
    int32_t **l_86 = &l_87;
    int32_t ***l_89 = &l_86;
    int32_t *l_90 = (void*)0;
    (*l_89) = l_86;
    (***l_89) = (__builtin_popcountll((**l_86)) || ((p_85 , (void*)0) != (*l_89)));
    return l_90;
    /* statement id: 48 */
    //assert (func_83_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 212
XXX total union variables: 27

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 129
   depth: 2, occurrence: 28
   depth: 3, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 26, occurrence: 2
   depth: 31, occurrence: 2
   depth: 33, occurrence: 1

XXX total number of pointers: 152

XXX times a variable address is taken: 161
XXX times a pointer is dereferenced on RHS: 164
breakdown:
   depth: 1, occurrence: 106
   depth: 2, occurrence: 31
   depth: 3, occurrence: 17
   depth: 4, occurrence: 10
XXX times a pointer is dereferenced on LHS: 107
breakdown:
   depth: 1, occurrence: 80
   depth: 2, occurrence: 17
   depth: 3, occurrence: 6
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 6
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 745

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 314
   level: 2, occurrence: 110
   level: 3, occurrence: 90
   level: 4, occurrence: 42
   level: 5, occurrence: 15
XXX number of pointers point to pointers: 81
XXX number of pointers point to scalars: 57
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 27.6
XXX average alias set size: 1.17

XXX times a non-volatile is read: 1164
XXX times a non-volatile is write: 316
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 115
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 33
   depth: 2, occurrence: 19
   depth: 3, occurrence: 17
   depth: 4, occurrence: 9
   depth: 5, occurrence: 8

XXX percentage a fresh-made variable is used: 15.5
XXX percentage an existing variable is used: 84.5
********************* end of statistics **********************/

