/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --muls --safe-math --packed-struct --no-paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --global-variabless --builtins
 * Seed:      3202386012
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_3 = 0x49FE387FL;
static int32_t *g_42 = (void*)0;
static int32_t g_92 = 7L;
static int32_t g_130 = (-4L);
static float g_156 = 0x4.325C60p-11;
static struct S0 g_170 = {0xCF51ADC7L};
static int32_t *g_208 = (void*)0;
static float *g_264 = &g_156;
static float **g_263 = &g_264;
static float ***g_262 = &g_263;
static struct S0 *g_348 = &g_170;
static float g_401 = (-0x6.3p+1);
static struct S0 **g_489 = (void*)0;
static struct S0 ***g_488 = &g_489;
static struct S0 **g_497 = &g_348;
static uint16_t g_527 = 1UL;
static int32_t **g_585 = &g_42;
static int32_t ***g_584 = &g_585;
static int32_t ****g_583 = &g_584;
static float **g_621 = &g_264;
static const int32_t *g_627 = &g_130;


/* --- FORWARD DECLARATIONS --- */
inline static struct S0  func_30(void);
static int32_t * func_31(int32_t  p_32, int32_t * p_33, float  p_34, int32_t  p_35);
inline static int32_t  func_37(float  p_38, int32_t * p_39, int16_t  p_40, const int32_t  p_41);
static float  func_49(uint32_t  p_50, int16_t  p_51, int16_t  p_52);
inline static struct S0  func_57(uint16_t  p_58);
inline static struct S0  func_71(float  p_72, float  p_73);
inline static int32_t * func_78(int32_t * p_79, int32_t * p_80, int16_t  p_81, const int32_t * p_82, const int32_t * p_83);
static int32_t * func_84(int32_t  p_85, int32_t  p_86, float  p_87, const uint32_t  p_88);
inline static struct S0  func_94(int32_t  p_95, int32_t  p_96, int32_t * p_97, float  p_98);
static int32_t * func_99(float  p_100, int32_t * p_101, int32_t * p_102, int32_t * p_103, uint16_t  p_104);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_3 g_42 g_92 g_130 g_170 g_208 g_262 g_264 g_156 g_263 g_348 g_488 g_497 g_489 g_527 g_401 g_583 g_584 g_585 g_621 g_627
 * writes: g_92 g_130 g_156 g_170 g_208 g_348 g_489 g_527 g_42
 */
inline static struct S0  func_30(void)
{ /* block id: 36 */
    int32_t l_43 = 0x5B3847D2L;
    int32_t *l_791 = (void*)0;
    uint32_t l_792 = 0UL;
    struct S0 **l_811 = &g_348;
    struct S0 l_812 = {1L};
    (*g_585) = func_31((safe_unary_minus_func_int32_t_s(func_37(g_3, g_42, ((l_43 >= (((safe_sub_func_float_f_f((safe_sub_func_float_f_f(l_43, (-func_49(l_43, (((safe_sub_func_uint32_t_u_u((g_3 , (((((9UL <= (safe_add_func_int32_t_s_s(l_43, __builtin_popcount((((func_57(g_3) , (**g_263)) , g_527) < l_43))))) , (void*)0) == (***g_583)) >= g_3) , 0UL)), l_43)) != 0x764FL) , 0x7A1CL), l_43)))), l_43)) > l_43) , l_43)) , 1L), g_3))), l_791, l_43, l_792);
    for (l_43 = (-4); (l_43 > (-11)); --l_43)
    { /* block id: 459 */
        int32_t *l_809 = &g_130;
        struct S0 l_810 = {0x47F23043L};
        (*g_42) = ((safe_lshift_func_uint16_t_u_u((l_809 == (**g_584)), 3)) && (-1L));
        return l_810;
    }
    l_811 = (void*)0;
    return l_812;
}


/* ------------------------------------------ */
/* 
 * reads : g_584 g_585 g_42 g_170.f0 g_3 g_130 g_92 g_488 g_263 g_264 g_527 g_156 g_583 g_170 g_627
 * writes: g_42 g_130 g_489 g_156 g_92 g_170 g_208
 */
static int32_t * func_31(int32_t  p_32, int32_t * p_33, float  p_34, int32_t  p_35)
{ /* block id: 453 */
    uint32_t l_797 = 5UL;
    int32_t *l_804 = &g_170.f0;
    (*l_804) = (safe_lshift_func_int16_t_s_s(0x65EBL, (((__builtin_clzl((0UL || ((safe_div_func_int32_t_s_s(func_37(p_32, (**g_584), ((((p_32 ^ (l_797 < ((((safe_div_func_float_f_f(p_34, (safe_add_func_float_f_f(l_797, (safe_mul_func_float_f_f(__builtin_bswap64(l_797), p_32)))))) > 0xD.8E92D2p-50) , g_170.f0) | l_797))) >= l_797) >= l_797) <= g_3), p_32), p_32)) , l_797))) , 0xDB5BL) <= p_32) != p_32)));
    return l_804;
}


/* ------------------------------------------ */
/* 
 * reads : g_585 g_42 g_130 g_3 g_584 g_92 g_488 g_263 g_264 g_527 g_170.f0 g_156 g_583 g_170 g_627
 * writes: g_42 g_130 g_489 g_156 g_92 g_170 g_208
 */
inline static int32_t  func_37(float  p_38, int32_t * p_39, int16_t  p_40, const int32_t  p_41)
{ /* block id: 435 */
    int32_t *l_749 = &g_130;
    const struct S0 l_750 = {0x830E68A2L};
    uint32_t l_751 = 7UL;
    int32_t l_764 = 0L;
    int16_t l_766 = 0xA723L;
    struct S0 **l_767 = &g_348;
    const struct S0 *l_789 = &g_170;
    const int32_t l_790 = 0x517187A3L;
    (*g_585) = l_749;
    if ((l_750 , (l_751 && (*g_42))))
    { /* block id: 437 */
        uint32_t l_765 = 4UL;
        for (p_40 = (-22); (p_40 == (-17)); ++p_40)
        { /* block id: 440 */
            struct S0 l_754 = {0x296B1B38L};
            uint32_t l_761 = 5UL;
            l_754 = l_754;
            (**g_584) = (((__builtin_parityll((g_3 , (safe_lshift_func_uint16_t_u_s(p_41, 7)))) < ((p_41 , ((safe_mul_func_float_f_f((-0x7.Ep-1), (safe_mul_func_float_f_f(p_41, l_761)))) < __builtin_popcountll((safe_lshift_func_int16_t_s_s(0xD858L, 9))))) >= l_764)) , l_765) , p_39);
            (**g_584) = p_39;
        }
        (*l_749) = (g_92 | (l_766 != g_130));
        (*g_488) = l_767;
    }
    else
    { /* block id: 447 */
        float l_768 = (-0x4.8p-1);
        int32_t l_769 = 0L;
        struct S0 l_779 = {0x1E487A11L};
        float ***l_780 = &g_263;
        (**g_263) = (g_92 , l_769);
        (*g_585) = func_99(((safe_add_func_float_f_f(((__builtin_parityll((*l_749)) , ((&l_767 == (((g_527 || (safe_unary_minus_func_uint16_t_u((safe_div_func_int32_t_s_s((safe_add_func_int16_t_s_s((-1L), (safe_rshift_func_int16_t_s_u(((l_779 , l_780) != ((safe_mul_func_uint16_t_u_u((safe_mod_func_int32_t_s_s((((void*)0 == &g_584) , l_779.f0), 0xCEDB6F3AL)), p_41)) , (void*)0)), p_40)))), g_170.f0))))) , 18446744073709551614UL) , (void*)0)) , &l_779)) == &l_779), 0x0.Bp-1)) != (*g_264)), (***g_583), &l_769, &l_764, p_41);
    }
    (*l_749) = (g_130 , ((l_750 , p_41) == (safe_rshift_func_int16_t_s_u(((p_41 & (safe_mul_func_int16_t_s_s((((l_750 , l_789) != (void*)0) <= l_790), g_3))) == (*g_627)), 11))));
    return (*l_749);
}


/* ------------------------------------------ */
/* 
 * reads : g_264 g_156 g_583 g_584 g_585 g_92 g_3 g_130 g_621 g_527 g_170.f0 g_42 g_263
 * writes: g_92 g_208 g_170.f0
 */
static float  func_49(uint32_t  p_50, int16_t  p_51, int16_t  p_52)
{ /* block id: 380 */
    int16_t l_654 = 0x6A86L;
    float l_666 = (-0x10.8p+1);
    int32_t *l_670 = (void*)0;
    struct S0 l_677 = {0xD60DFBC6L};
    int16_t l_678 = 0xBE5BL;
    int32_t ***l_701 = (void*)0;
    if (l_654)
    { /* block id: 381 */
        int32_t l_661 = (-1L);
        uint32_t l_662 = 0xFE7D913AL;
        int16_t l_663 = 0x56A4L;
        int32_t l_667 = (-1L);
        float l_668 = 0x3.FCEC9Cp-54;
        struct S0 l_676 = {0x4AE58A55L};
        int32_t **l_688 = &g_208;
        int32_t *l_689 = (void*)0;
        int32_t *l_690 = (void*)0;
        int32_t *l_691 = &g_92;
        if (((((safe_mul_func_uint16_t_u_u(((safe_add_func_float_f_f((__builtin_ctzll(l_654) , ((((-0x10.8p+1) >= (safe_sub_func_float_f_f(((*g_264) > 0xD.022C89p+48), (((((l_661 , ((**g_583) == (**g_583))) <= (((l_661 < l_654) == 0xE.541260p+0) != (-0x10.Ap+1))) <= l_661) == (-0x1.Cp+1)) != p_52)))) <= p_50) < p_52)), l_654)) , p_51), l_654)) , l_662) & p_52) || 4294967295UL))
        { /* block id: 382 */
            int32_t *l_664 = &g_92;
            int32_t **l_665 = &l_664;
            l_663 = 1L;
            (*l_664) = l_661;
            (*l_665) = l_664;
            l_667 = (*l_664);
        }
        else
        { /* block id: 387 */
            int32_t *l_669 = &l_667;
            struct S0 l_673 = {7L};
            int32_t **l_679 = (void*)0;
            int32_t **l_680 = (void*)0;
            int32_t **l_681 = &l_670;
            l_670 = l_669;
            (*l_670) = (((safe_mul_func_uint16_t_u_u((l_673 , g_3), g_130)) != p_51) | (safe_sub_func_int32_t_s_s(p_52, (((((((l_676 , ((p_52 < 0x743EL) & ((*g_621) == (*g_621)))) < l_676.f0) > (*l_669)) >= (*l_670)) , l_662) < 4294967294UL) > 0x970DL))));
            l_673 = l_677;
            (*l_681) = (l_678 , l_670);
        }
lbl_694:
        (*l_691) = (safe_mul_func_int16_t_s_s((g_130 > (((void*)0 == &g_497) >= __builtin_bswap32(g_527))), ((safe_lshift_func_uint16_t_u_s(p_52, 7)) < ((g_170.f0 == (l_688 == (p_50 , (void*)0))) ^ p_50))));
        if (__builtin_popcountll(p_52))
        { /* block id: 394 */
            struct S0 l_692 = {0x46417AEEL};
            int32_t *l_695 = &l_676.f0;
            int32_t *** const *l_696 = &g_584;
            if ((*l_691))
            { /* block id: 395 */
                int32_t *l_693 = &l_667;
                l_692 = l_692;
                l_693 = (((void*)0 == &l_677) , (**g_584));
                if (g_92)
                    goto lbl_694;
                (*l_688) = l_693;
            }
            else
            { /* block id: 400 */
                const float l_704 = (-0x9.Cp+1);
                int32_t l_707 = 0xEE08E452L;
                int32_t l_712 = (-1L);
                struct S0 l_720 = {0x73D57A24L};
                l_676 = l_692;
                for (l_663 = 10; (l_663 < 27); l_663 = safe_add_func_int32_t_s_s(l_663, 5))
                { /* block id: 404 */
                    (*l_695) = __builtin_ffsl((g_170.f0 | ((0xDC99L && g_92) >= p_52)));
                }
                l_692 = (p_52 , l_676);
                if (((safe_rshift_func_int16_t_s_u(((*l_695) > (g_170.f0 | ((((void*)0 == l_701) >= (safe_rshift_func_uint16_t_u_s((((((p_51 == (safe_mul_func_int16_t_s_s(g_92, ((*l_691) , ((((((void*)0 == (*g_263)) == l_707) <= 65535UL) > g_3) <= g_92))))) , g_527) < p_50) , g_92) & p_51), g_130))) || p_50))), p_50)) <= p_51))
                { /* block id: 408 */
                    struct S0 ** const l_709 = &g_348;
                    int32_t l_719 = 0xC6A30FF9L;
                    struct S0 *l_721 = (void*)0;
                    struct S0 *l_722 = &l_692;
                    (*l_695) = (g_130 <= g_170.f0);
                    (*l_722) = l_720;
                    for (g_170.f0 = 7; (g_170.f0 <= (-1)); g_170.f0 = safe_sub_func_uint16_t_u_u(g_170.f0, 9))
                    { /* block id: 413 */
                        l_676 = l_676;
                        (*l_691) = 2L;
                        if (l_719)
                            continue;
                    }
                }
                else
                { /* block id: 418 */
                    uint32_t l_726 = 7UL;
                    (*l_695) = (((!(l_726 >= ((safe_lshift_func_uint16_t_u_u(0xB9A6L, 10)) > (safe_sub_func_int32_t_s_s((((g_92 > ((safe_rshift_func_int16_t_s_u((-2L), (safe_mod_func_uint16_t_u_u((p_50 < 0xB75EF002L), (safe_add_func_int16_t_s_s(p_50, (safe_rshift_func_uint16_t_u_s((safe_div_func_uint16_t_u_u((safe_div_func_int32_t_s_s((+(((7L | (safe_rshift_func_int16_t_s_u(p_52, g_527))) >= 0x2B14L) >= (-10L))), p_50)), p_51)), 13)))))))) , 0xFBADL)) < p_51) & l_726), g_92))))) , g_527) | g_92);
                }
            }
        }
        else
        { /* block id: 422 */
lbl_746:
            if (g_170.f0)
                goto lbl_694;
        }
        if (l_677.f0)
            goto lbl_746;
    }
    else
    { /* block id: 426 */
        for (p_51 = 0; (p_51 >= 17); p_51 = safe_add_func_int32_t_s_s(p_51, 1))
        { /* block id: 429 */
            return p_51;
        }
    }
    l_670 = (***g_583);
    return p_52;
}


/* ------------------------------------------ */
/* 
 * reads : g_3 g_92 g_130 g_170 g_208 g_262 g_264 g_156 g_263 g_348 g_488 g_497 g_489 g_527 g_401 g_583 g_584 g_585 g_42 g_621 g_627
 * writes: g_92 g_130 g_156 g_170 g_208 g_348 g_489 g_527
 */
inline static struct S0  func_57(uint16_t  p_58)
{ /* block id: 37 */
    const int32_t l_70 = 1L;
    int32_t *l_91 = &g_92;
    uint16_t l_93 = 0xFE6BL;
    int32_t l_629 = 0L;
    struct S0 l_630 = {-10L};
    int16_t l_631 = 0xFC10L;
    const struct S0 *l_640 = &l_630;
    const struct S0 **l_639 = &l_640;
    const struct S0 ***l_638 = &l_639;
    float l_648 = 0x1.6p+1;
    int32_t l_651 = 0xAEE35622L;
    int32_t **l_652 = &g_208;
    struct S0 l_653 = {0x81C1A81DL};
    if (((((safe_add_func_int16_t_s_s((safe_unary_minus_func_int16_t_s(((__builtin_ctzll((safe_mod_func_int32_t_s_s((6L && (((safe_rshift_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(p_58, p_58)), (0x3F37L | l_70))) <= ((func_71(p_58, g_3) , func_78(func_84((((((safe_add_func_uint16_t_u_u(1UL, p_58)) < 0x4A86L) ^ 0x09E95372L) , (void*)0) == l_91), p_58, l_93, p_58), l_91, p_58, l_91, l_91)) == l_91)) , 0x5917L)), p_58))) , g_3) , 0xBD69L))), 4UL)) & l_629) >= g_527) <= p_58))
    { /* block id: 359 */
        (*l_91) = (*l_91);
        (***g_262) = (**g_621);
        return l_630;
    }
    else
    { /* block id: 363 */
        uint32_t l_632 = 6UL;
        struct S0 l_633 = {0x246A19ADL};
        l_633 = l_633;
    }
    for (l_631 = 0; (l_631 != (-24)); l_631 = safe_sub_func_uint16_t_u_u(l_631, 1))
    { /* block id: 368 */
        struct S0 l_644 = {0x6B4B0D49L};
        for (g_527 = 0; (g_527 > 57); g_527 = safe_add_func_int32_t_s_s(g_527, 1))
        { /* block id: 371 */
            l_638 = l_638;
            (**g_263) = (safe_mul_func_float_f_f((!(p_58 == p_58)), p_58));
        }
        l_630 = g_170;
        return l_644;
    }
    (*l_652) = &l_651;
    return l_653;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_71(float  p_72, float  p_73)
{ /* block id: 38 */
    uint32_t l_75 = 0UL;
    int32_t l_76 = 2L;
    struct S0 l_77 = {0xFA7BB34EL};
    l_76 = ((!__builtin_ffsll(l_75)) < l_75);
    return l_77;
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_170.f0 g_527 g_262 g_263 g_264 g_156 g_3 g_583 g_208 g_497 g_584 g_585 g_42 g_130 g_621 g_627
 * writes: g_170 g_156 g_208 g_348 g_92 g_130
 */
inline static int32_t * func_78(int32_t * p_79, int32_t * p_80, int16_t  p_81, const int32_t * p_82, const int32_t * p_83)
{ /* block id: 304 */
    int32_t l_539 = 1L;
    float ***l_542 = &g_263;
    struct S0 l_552 = {0x3816290FL};
    const int32_t *l_587 = &g_92;
    if ((safe_mod_func_uint16_t_u_u((((safe_div_func_int32_t_s_s(((safe_sub_func_uint32_t_u_u(l_539, (__builtin_ffsll((__builtin_bswap64(((safe_mod_func_uint32_t_u_u(l_539, l_539)) <= ((*p_82) <= (&g_263 != l_542)))) , (safe_mod_func_int16_t_s_s(((*p_83) & (safe_mod_func_int32_t_s_s((*p_79), l_539))), l_539)))) < p_81))) == 0xFC705CBAL), l_539)) || p_81) & 0xB825L), g_170.f0)))
    { /* block id: 305 */
        uint32_t l_551 = 18446744073709551607UL;
        struct S0 **l_590 = &g_348;
        const int32_t **l_596 = &l_587;
        const int32_t ***l_595 = &l_596;
        const int32_t ****l_594 = &l_595;
        float ***l_597 = &g_263;
        if ((p_81 , (*p_79)))
        { /* block id: 306 */
            int32_t * const * const l_567 = &g_42;
            int32_t * const * const *l_566 = &l_567;
            for (l_539 = 0; (l_539 == (-12)); l_539 = safe_sub_func_uint16_t_u_u(l_539, 6))
            { /* block id: 309 */
                uint16_t l_550 = 65533UL;
                int32_t **l_561 = &g_42;
                int32_t ***l_560 = &l_561;
                int32_t ****l_559 = &l_560;
                if ((+l_550))
                { /* block id: 310 */
                    struct S0 *l_553 = (void*)0;
                    struct S0 *l_554 = &g_170;
                    (*l_554) = l_552;
                    if ((safe_sub_func_int32_t_s_s((safe_add_func_uint16_t_u_u(((l_559 != (void*)0) > (safe_add_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s((*p_80), (l_566 == &l_567))) | g_92), (__builtin_ctz(l_551) == ((((g_527 && g_527) || 0x236D67A2L) , l_552) , g_92))))), 0xD017L)), g_92)))
                    { /* block id: 312 */
                        (***g_262) = 0x0.24EEBEp-87;
                        return p_79;
                    }
                    else
                    { /* block id: 315 */
                        int32_t *l_568 = &g_130;
                        int32_t **l_573 = &g_208;
                        l_568 = &g_92;
                        (*g_264) = (((void*)0 != (*l_542)) < (((((safe_add_func_float_f_f((**g_263), ((func_71((***g_262), ((((((l_552.f0 ^ 1L) != 0xA87FD689L) != g_3) != (safe_div_func_int32_t_s_s(((**g_263) , g_527), l_551))) && (*l_568)) , p_81)) , l_551) >= (***g_262)))) > (***g_262)) > 0xC.6262A0p-82) >= (**g_263)) != p_81));
                        (*l_573) = l_568;
                    }
                    (**g_263) = (((p_81 || 0x40F7L) , (safe_add_func_float_f_f((safe_div_func_float_f_f((-(safe_add_func_float_f_f((((***g_262) < ((***g_262) == ((*g_264) >= l_539))) >= (func_71(l_552.f0, (((safe_mul_func_uint16_t_u_u(p_81, l_551)) , g_583) != &g_584)) , (*g_264))), (***g_262)))), 0x4.Bp-1)), (**g_263)))) > (-0x5.Cp+1));
                    if ((*p_82))
                    { /* block id: 321 */
                        int16_t l_586 = 6L;
                        l_586 = (*g_208);
                        (*l_554) = l_552;
                    }
                    else
                    { /* block id: 324 */
                        l_587 = p_82;
                    }
                }
                else
                { /* block id: 327 */
                    return p_79;
                }
            }
        }
        else
        { /* block id: 331 */
            const int32_t **l_588 = (void*)0;
            const int32_t **l_589 = &l_587;
            (*g_497) = &l_552;
            (*l_589) = (((**g_584) == (void*)0) , p_83);
        }
        (*p_80) = (l_590 != l_590);
        l_552.f0 = (safe_div_func_float_f_f(((-p_81) != ((l_551 , (((void*)0 == l_587) < ((void*)0 == l_594))) <= (((((**g_263) < 0x7.5BA1E9p+52) , l_597) == l_542) <= (**g_263)))), 0xA.95BD16p+1));
    }
    else
    { /* block id: 337 */
        struct S0 * const *l_600 = &g_348;
        int32_t l_620 = 0x07668F40L;
        for (g_130 = 0; (g_130 == (-29)); g_130 = safe_sub_func_int32_t_s_s(g_130, 1))
        { /* block id: 340 */
            struct S0 * const *l_601 = &g_348;
            (*p_80) = (*p_82);
            l_601 = l_600;
        }
        if ((p_81 , (*p_79)))
        { /* block id: 344 */
            uint32_t l_622 = 0x230938E5L;
            (***g_262) = (safe_sub_func_float_f_f((safe_mul_func_float_f_f((((safe_sub_func_float_f_f(__builtin_ia32_crc32qi((((safe_sub_func_uint16_t_u_u(65533UL, p_81)) & ((((((safe_mul_func_uint16_t_u_u((safe_add_func_int32_t_s_s((safe_sub_func_int32_t_s_s(0x5E573C5DL, g_527)), __builtin_parity(g_170.f0))), (safe_mod_func_uint32_t_u_u(p_81, (safe_sub_func_uint32_t_u_u(p_81, l_620)))))) <= 0x502F8B65L) > (*l_587)) > p_81) , g_621) != (void*)0)) != p_81), g_527), (*l_587))) < 0x6.491BDFp+87) <= l_620), p_81)), l_622));
        }
        else
        { /* block id: 346 */
            struct S0 l_623 = {0x0FB9E73CL};
            (**g_621) = l_620;
            l_623 = l_552;
        }
    }
    for (g_170.f0 = 0; (g_170.f0 > (-25)); g_170.f0 = safe_sub_func_uint32_t_u_u(g_170.f0, 8))
    { /* block id: 353 */
        int32_t *l_626 = &g_170.f0;
        const int32_t **l_628 = &l_587;
        (**g_263) = (p_81 <= p_81);
        g_208 = l_626;
        (*l_628) = g_627;
    }
    return (***g_583);
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_3 g_130 g_170 g_208 g_262 g_264 g_156 g_263 g_348 g_488 g_497 g_489 g_527 g_401
 * writes: g_92 g_130 g_156 g_170 g_208 g_348 g_489
 */
static int32_t * func_84(int32_t  p_85, int32_t  p_86, float  p_87, const uint32_t  p_88)
{ /* block id: 41 */
    const int32_t l_107 = 0xC0DB1B79L;
    struct S0 l_531 = {0xC26755BEL};
    int32_t **l_532 = &g_208;
    l_531 = func_71(((func_94(p_88, p_88, func_99((safe_sub_func_float_f_f(((l_107 == 0xE.E77332p-65) == l_107), ((p_86 , &g_92) != (void*)0))), &g_92, &g_92, &g_92, p_85), p_87) , p_86) < g_401), l_107);
    (*l_532) = &p_86;
    return &g_92;
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_130 g_3 g_170 g_208 g_262 g_264 g_156 g_263 g_348 g_488 g_497 g_489 g_527
 * writes: g_92 g_130 g_156 g_170 g_208 g_348 g_489
 */
inline static struct S0  func_94(int32_t  p_95, int32_t  p_96, int32_t * p_97, float  p_98)
{ /* block id: 120 */
    uint32_t l_225 = 0x2F8A427DL;
    struct S0 l_228 = {0xCC317C6AL};
    int32_t **l_232 = (void*)0;
    int32_t **l_233 = (void*)0;
    int32_t **l_234 = &g_208;
    float ***l_235 = (void*)0;
    uint16_t l_303 = 0xC84CL;
    uint16_t l_304 = 7UL;
    int16_t l_307 = 0x795EL;
    struct S0 l_391 = {1L};
    int32_t *l_392 = &g_170.f0;
    int32_t *l_483 = &l_391.f0;
    int16_t l_498 = 0xC186L;
    struct S0 **l_499 = (void*)0;
lbl_259:
    (*l_234) = func_99(l_225, ((safe_add_func_int16_t_s_s(((l_228 , p_95) ^ (p_95 <= g_92)), (g_130 | ((0xB315FCE8L > (!(l_228.f0 && g_92))) >= 0UL)))) , &p_95), &g_130, &g_92, l_228.f0);
    if (((*p_97) != ((*g_208) && ((((l_235 != (void*)0) >= (safe_add_func_int32_t_s_s((((safe_div_func_uint32_t_u_u(((safe_div_func_int32_t_s_s((safe_rshift_func_uint16_t_u_s(g_130, 7)), p_96)) != g_130), __builtin_clz((safe_add_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((safe_lshift_func_uint16_t_u_u(((safe_add_func_uint16_t_u_u((p_95 || (safe_add_func_uint32_t_u_u(0xD585D5F9L, g_92))), g_92)) <= p_95), 14)), 15)), g_3)), p_96))))) != (**l_234)) || (**l_234)), 0UL))) , p_96) , 0x2F9674B0L))))
    { /* block id: 122 */
        int16_t l_258 = 0L;
        uint16_t l_269 = 0x5D42L;
        for (g_170.f0 = 0; (g_170.f0 == 0); g_170.f0 = safe_add_func_int32_t_s_s(g_170.f0, 1))
        { /* block id: 125 */
            if (l_258)
                break;
            (*l_234) = &g_92;
            if (g_170.f0)
                goto lbl_259;
        }
        for (l_228.f0 = 0; (l_228.f0 >= 28); l_228.f0 = safe_add_func_int32_t_s_s(l_228.f0, 1))
        { /* block id: 132 */
            int32_t l_282 = 0L;
            float *l_311 = &g_156;
            struct S0 **l_321 = (void*)0;
            struct S0 *l_323 = &l_228;
            struct S0 **l_322 = &l_323;
            (*l_234) = &g_92;
            if ((g_262 == &g_263))
            { /* block id: 134 */
                float ***l_287 = &g_263;
                int32_t *l_294 = &l_282;
                for (g_170.f0 = 0; (g_170.f0 == (-3)); g_170.f0 = safe_sub_func_uint16_t_u_u(g_170.f0, 1))
                { /* block id: 137 */
                    uint32_t l_288 = 0x50AF277EL;
                    struct S0 *l_295 = &g_170;
                    if ((((((safe_lshift_func_int16_t_s_s(__builtin_clzll(l_269), (safe_mul_func_int16_t_s_s(((safe_div_func_int32_t_s_s(((safe_add_func_uint16_t_u_u((safe_sub_func_int16_t_s_s((((safe_div_func_float_f_f(((safe_sub_func_float_f_f((((l_282 , (safe_div_func_float_f_f((safe_add_func_float_f_f((*g_264), ((((-0x1.1p-1) >= ((void*)0 != l_287)) == ((*g_264) == 0x2.83C71Bp+89)) == l_288))), 0x5.Fp+1))) < (*g_264)) < p_95), l_288)) != (*g_264)), 0x2.337C21p+87)) , g_3) ^ 1L), p_95)), g_92)) == 1UL), 0x38FC1FC8L)) > l_282), g_170.f0)))) , (*g_263)) != (void*)0) == 0x46ABL) && l_282))
                    { /* block id: 138 */
                        if ((*p_97))
                            break;
                        (*p_97) = (!(1UL ^ (safe_mod_func_int32_t_s_s(((safe_unary_minus_func_uint16_t_u(0xA8FBL)) == (p_95 , (+p_96))), 1L))));
                        (*l_234) = &l_282;
                        l_294 = &g_130;
                    }
                    else
                    { /* block id: 143 */
                        struct S0 **l_296 = &l_295;
                        (*l_296) = l_295;
                    }
                }
                if ((g_92 != g_170.f0))
                { /* block id: 147 */
                    struct S0 l_308 = {0L};
                    for (g_170.f0 = (-25); (g_170.f0 >= (-28)); g_170.f0 = safe_sub_func_int32_t_s_s(g_170.f0, 9))
                    { /* block id: 150 */
                        uint32_t l_302 = 0x130ACF16L;
                        if (p_96)
                            goto lbl_259;
                        if ((*p_97))
                            break;
                        (**l_234) = __builtin_clzll((l_282 != (safe_mul_func_uint16_t_u_u((+l_302), (func_71((***g_262), l_303) , l_304)))));
                        if ((*p_97))
                            continue;
                    }
                    if ((l_307 || 0UL))
                    { /* block id: 156 */
                        p_97 = &g_130;
                        (*g_208) = (*g_208);
                        if ((*p_97))
                            continue;
                        if ((*g_208))
                            continue;
                    }
                    else
                    { /* block id: 161 */
                        return l_308;
                    }
                    (*l_234) = ((safe_sub_func_uint32_t_u_u((l_282 != __builtin_ffs((*p_97))), (l_311 == (void*)0))) , func_99((safe_mul_func_float_f_f(__builtin_parityl((*l_294)), (safe_div_func_float_f_f((safe_mul_func_float_f_f(0xD.F3D1E7p+87, (**g_263))), 0x4.Bp-1)))), &g_92, &g_130, &g_92, p_95));
                    for (g_170.f0 = 20; (g_170.f0 == (-26)); g_170.f0 = safe_sub_func_int32_t_s_s(g_170.f0, 9))
                    { /* block id: 167 */
                        (*l_234) = &p_95;
                    }
                }
                else
                { /* block id: 170 */
                    return l_228;
                }
            }
            else
            { /* block id: 173 */
                struct S0 *l_320 = &g_170;
                (*l_320) = l_228;
            }
            (*l_322) = &g_170;
        }
    }
    else
    { /* block id: 178 */
        int32_t l_328 = 0xCF4673FFL;
        for (l_307 = 0; (l_307 > 5); ++l_307)
        { /* block id: 181 */
            int32_t l_333 = 1L;
            (*g_264) = (safe_sub_func_float_f_f(p_96, ((l_328 > (safe_add_func_float_f_f(((safe_sub_func_float_f_f(p_98, (-0x1.Bp+1))) >= p_98), (l_333 == ((((+l_333) ^ (g_3 < 0UL)) == p_96) , 0xB.17D50Ap+11))))) == 0x7.F90161p-52)));
        }
        for (l_303 = 23; (l_303 == 19); l_303 = safe_sub_func_uint16_t_u_u(l_303, 1))
        { /* block id: 186 */
            uint32_t l_339 = 0x3D8B4343L;
            for (l_307 = 0; (l_307 <= (-15)); l_307 = safe_sub_func_int32_t_s_s(l_307, 1))
            { /* block id: 189 */
                return g_170;
            }
            (*g_208) = ((0L == g_170.f0) != l_339);
        }
        for (l_303 = 0; (l_303 != 16); l_303 = safe_add_func_uint32_t_u_u(l_303, 2))
        { /* block id: 196 */
            const struct S0 **l_342 = (void*)0;
            struct S0 *l_344 = &g_170;
            struct S0 **l_343 = &l_344;
            float **l_350 = &g_264;
            float ***l_351 = &l_350;
            (*l_343) = (void*)0;
            for (l_307 = 6; (l_307 > (-9)); l_307 = safe_sub_func_uint16_t_u_u(l_307, 1))
            { /* block id: 200 */
                struct S0 *l_347 = &l_228;
                int32_t l_349 = 0x0A6ECE73L;
                g_348 = l_347;
                if ((*p_97))
                    continue;
                p_97 = &p_95;
                if (l_349)
                    continue;
            }
            (*g_208) = (l_350 != (void*)0);
            l_351 = &g_263;
        }
    }
    (*g_264) = (***g_262);
    for (l_228.f0 = 0; (l_228.f0 >= 14); l_228.f0 = safe_add_func_uint16_t_u_u(l_228.f0, 5))
    { /* block id: 213 */
        int32_t l_372 = 0x53B14A4BL;
        uint16_t l_398 = 65535UL;
        float **l_452 = &g_264;
        struct S0 **l_453 = &g_348;
        uint16_t l_484 = 0x75E7L;
        int32_t *l_491 = &g_170.f0;
        uint16_t l_508 = 1UL;
        g_170 = (*g_348);
        for (g_92 = 19; (g_92 == (-10)); --g_92)
        { /* block id: 217 */
            uint32_t l_367 = 4294967291UL;
            struct S0 * const *l_384 = &g_348;
            if (__builtin_clzll(p_95))
            { /* block id: 218 */
                uint32_t l_360 = 9UL;
                struct S0 l_375 = {0xFD3435ECL};
                (*g_264) = (p_98 != (safe_div_func_float_f_f((safe_sub_func_float_f_f(0xA.C5F0FBp-81, l_360)), (safe_add_func_float_f_f(((*g_264) < ((((((((safe_lshift_func_uint16_t_u_u((safe_mul_func_int16_t_s_s((l_367 | (safe_rshift_func_uint16_t_u_s(g_3, (p_95 && l_360)))), (safe_rshift_func_uint16_t_u_u(l_372, p_96)))), 4)) , 0xDFE3L) , (-5L)) <= 1UL) > (-9L)) , 0x3.DE8AA6p+66) >= 0x9.Fp-1) < (***g_262))), l_367)))));
                for (p_96 = 8; (p_96 != 8); p_96 = safe_add_func_int16_t_s_s(p_96, 6))
                { /* block id: 222 */
                    return l_375;
                }
                (*l_234) = (void*)0;
            }
            else
            { /* block id: 226 */
                const struct S0 *l_381 = &g_170;
                int32_t *l_382 = (void*)0;
                int32_t *l_383 = &g_170.f0;
                struct S0 * const **l_385 = &l_384;
                (*l_383) = ((safe_lshift_func_uint16_t_u_u(1UL, (!(((l_372 != (l_381 != &g_170)) , (void*)0) != (void*)0)))) >= ((func_71((***g_262), p_95) , g_3) != p_95));
                (*l_385) = l_384;
                for (l_372 = 11; (l_372 >= 8); l_372 = safe_sub_func_uint32_t_u_u(l_372, 1))
                { /* block id: 231 */
                    int32_t *l_393 = (void*)0;
                    for (l_225 = (-9); (l_225 <= 30); l_225 = safe_add_func_uint16_t_u_u(l_225, 9))
                    { /* block id: 234 */
                        int32_t l_390 = 0x7B37DF5FL;
                        l_391 = func_71((**g_263), l_390);
                    }
                    g_208 = &p_96;
                    l_393 = l_392;
                }
                if (((l_367 ^ (((safe_lshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s(l_398, 14)), (safe_rshift_func_int16_t_s_u(p_96, ((*l_383) & g_3))))) <= l_372) ^ (safe_unary_minus_func_int32_t_s(__builtin_ctzll(l_398))))) & (safe_rshift_func_int16_t_s_u((l_367 < 65535UL), 14))))
                { /* block id: 240 */
                    struct S0 *l_405 = &g_170;
                    (*l_405) = func_71((**g_263), l_398);
                }
                else
                { /* block id: 242 */
                    const uint16_t l_412 = 0UL;
                    (*l_234) = &g_92;
                    (*l_392) = (safe_div_func_int32_t_s_s((p_96 >= (g_130 , (safe_add_func_uint16_t_u_u((((safe_sub_func_uint16_t_u_u(l_412, (((((safe_add_func_int16_t_s_s(l_367, ((0x6FE32209L != (l_367 , l_412)) <= (((safe_add_func_uint32_t_u_u((safe_mod_func_int16_t_s_s(((safe_add_func_int16_t_s_s((safe_mul_func_uint16_t_u_u((safe_sub_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_u(((*p_97) && ((safe_sub_func_uint32_t_u_u((safe_add_func_uint16_t_u_u(g_130, 0xE89FL)), l_367)) || (*l_383))), p_96)) , (*l_383)), 1L)), 0xC1B2L)), g_130)) >= 0x9FDA80F4L), 0x8B3BL)), g_3)) == g_92) , (*g_208))))) , 0xDA90C6BCL) && 4294967288UL) ^ p_95) | g_130))) , &g_42) == &p_97), g_3)))), g_92));
                }
            }
            (***g_262) = p_96;
            for (l_307 = 0; (l_307 >= 23); ++l_307)
            { /* block id: 250 */
                (*l_392) = (*p_97);
            }
            (*l_392) = (g_170.f0 & 1UL);
        }
        if ((safe_mul_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(p_96, (safe_lshift_func_int16_t_s_s((-9L), 3)))), (safe_rshift_func_uint16_t_u_u(p_96, 5)))))
        { /* block id: 255 */
            struct S0 *l_441 = &g_170;
            (*l_441) = func_71((***g_262), (*g_264));
            return l_391;
        }
        else
        { /* block id: 258 */
            float l_481 = (-0x1.0p-1);
            struct S0 l_482 = {-1L};
            int32_t *l_530 = &g_130;
            if ((safe_sub_func_int32_t_s_s((safe_lshift_func_uint16_t_u_s(((1UL != ((safe_lshift_func_int16_t_s_s((safe_sub_func_int16_t_s_s(((safe_mul_func_uint16_t_u_u((((p_95 , (((*p_97) != p_96) != ((*g_262) != l_452))) && 4294967294UL) , ((*g_348) , 0x5F1FL)), p_96)) || g_3), 0xD7A9L)), 2)) != 0L)) >= p_95), 8)), (*p_97))))
            { /* block id: 259 */
                struct S0 ***l_454 = &l_453;
                int32_t l_455 = 0x26FD71BCL;
                (*l_454) = l_453;
                if (((((*p_97) , 0xF6E8L) , (*p_97)) , (l_455 & (g_3 , (l_398 == p_95)))))
                { /* block id: 261 */
                    struct S0 *l_459 = &g_170;
                    for (p_95 = (-2); (p_95 < (-29)); p_95 = safe_sub_func_uint32_t_u_u(p_95, 1))
                    { /* block id: 264 */
                        struct S0 l_458 = {-2L};
                        return l_458;
                    }
                    (*l_459) = (**l_453);
                    p_98 = __builtin_parity(g_3);
                }
                else
                { /* block id: 269 */
                    struct S0 **l_464 = &g_348;
                    int32_t l_465 = 0x098913C8L;
                    (*p_97) = (safe_mod_func_uint32_t_u_u(((((safe_add_func_int16_t_s_s(1L, p_95)) >= (l_464 == l_464)) > (*p_97)) <= (l_465 & (safe_div_func_uint16_t_u_u((((safe_add_func_uint16_t_u_u(9UL, p_95)) , (safe_lshift_func_int16_t_s_s(0x1379L, g_130))) & p_96), p_96)))), 1UL));
                    return l_391;
                }
            }
            else
            { /* block id: 273 */
                int32_t *l_492 = (void*)0;
                const float l_494 = 0x1.Cp+1;
                struct S0 l_514 = {0xF25AB8FAL};
                for (l_372 = (-4); (l_372 < (-24)); l_372 = safe_sub_func_int16_t_s_s(l_372, 2))
                { /* block id: 276 */
                    int32_t l_474 = 2L;
                    struct S0 *l_485 = &l_482;
                    (*l_485) = func_71(l_474, (((safe_sub_func_float_f_f((((func_71((***g_262), (safe_div_func_float_f_f(((safe_sub_func_float_f_f(((((func_71((__builtin_ia32_crc32qi(__builtin_ffsl(p_95), (l_482 , g_3)) > (((void*)0 == &g_348) >= (**g_263))), (***g_262)) , &g_42) == (void*)0) < p_96) <= (***g_262)), l_398)) <= p_96), 0x8.EDA587p+65))) , l_482.f0) , (void*)0) == l_483), 0xD.8EC750p+98)) == (-0x3.7p-1)) != l_484));
                    if ((g_92 < (0x7EA9L ^ (((l_474 & (0L != ((p_96 < ((g_170.f0 , g_488) != &g_489)) | l_474))) >= 0x8E1FL) > 8L))))
                    { /* block id: 278 */
                        float l_490 = 0x3.0p-1;
                        int32_t l_500 = 3L;
                        p_97 = func_99(l_490, l_491, l_492, &g_130, ((l_474 | (~(g_3 != (((safe_add_func_uint16_t_u_u(l_474, ((g_497 == ((l_498 , 65533UL) , l_499)) && 0UL))) == g_3) == (-1L))))) || g_92));
                        (*g_488) = (*g_488);
                        (*l_485) = func_71(l_482.f0, __builtin_parityl(g_170.f0));
                        if (l_500)
                            break;
                    }
                    else
                    { /* block id: 283 */
                        uint16_t l_505 = 0x2525L;
                        float **l_513 = &g_264;
                        (*l_392) = (((safe_mul_func_int16_t_s_s(__builtin_popcountl((g_170.f0 != (safe_div_func_uint16_t_u_u((l_505 & ((safe_mul_func_uint16_t_u_u((0L && g_3), ((-4L) != l_508))) >= (__builtin_parity((func_71(((safe_div_func_float_f_f((safe_div_func_float_f_f(0x5.C37ED3p-38, (l_513 == (*g_262)))), (*g_264))) > l_505), p_95) , g_92)) == g_3))), g_3)))), 0x6BE4L)) != 4L) == 0xAE07L);
                        return l_514;
                    }
                    (*l_491) = 5L;
                    if (l_482.f0)
                        continue;
                }
                for (l_303 = 17; (l_303 != 16); --l_303)
                { /* block id: 292 */
                    int32_t ***l_529 = &l_234;
                    int32_t ****l_528 = &l_529;
                    (***g_262) = (*g_264);
                    (*l_528) = (((!(((((p_96 < (g_92 && 0x5E5EL)) <= ((-10L) || (-1L))) != p_96) | (safe_mul_func_int16_t_s_s(((safe_add_func_int16_t_s_s((((safe_lshift_func_int16_t_s_u(g_130, 1)) && (~0x0E2FL)) , (safe_add_func_uint32_t_u_u(((p_96 , (void*)0) != (*g_497)), (*l_491)))), g_527)) >= 0x6937L), g_527))) , p_95)) != g_527) , &l_232);
                }
            }
            (*l_234) = func_99(p_96, l_491, l_530, &g_92, p_95);
        }
    }
    return l_391;
}


/* ------------------------------------------ */
/* 
 * reads : g_92 g_3 g_130 g_170
 * writes: g_92 g_130 g_156 g_170 g_208
 */
static int32_t * func_99(float  p_100, int32_t * p_101, int32_t * p_102, int32_t * p_103, uint16_t  p_104)
{ /* block id: 42 */
    struct S0 l_127 = {0x14E7E319L};
    float *l_200 = (void*)0;
    float ** const l_199 = &l_200;
lbl_224:
    for (g_92 = 12; (g_92 != 7); --g_92)
    { /* block id: 45 */
        int32_t l_118 = 0x9616D9CDL;
        int32_t *l_164 = &g_130;
        int32_t l_171 = 4L;
        struct S0 l_197 = {0x8D77B496L};
        for (p_104 = 18; (p_104 >= 39); p_104 = safe_add_func_int32_t_s_s(p_104, 3))
        { /* block id: 48 */
            int32_t l_125 = (-2L);
            struct S0 * const l_132 = (void*)0;
            int32_t *l_157 = &l_127.f0;
            float l_187 = 0x4.96F57Fp-97;
            int32_t *l_198 = &g_170.f0;
            float **l_202 = (void*)0;
            float ***l_201 = &l_202;
            if (g_92)
            { /* block id: 49 */
                float l_126 = 0x6.B22E00p+13;
                int32_t l_128 = 0x1A75D104L;
                int32_t *l_129 = &l_128;
                int32_t **l_131 = &l_129;
                struct S0 *l_134 = &l_127;
                struct S0 **l_133 = &l_134;
                (*l_129) = (safe_mul_func_int16_t_s_s((((g_3 <= g_92) , (safe_lshift_func_int16_t_s_s(g_92, 10))) ^ (p_104 & (((((&g_92 != (void*)0) != (((safe_add_func_float_f_f(((l_118 <= ((safe_mul_func_float_f_f((safe_add_func_float_f_f(((g_3 <= (__builtin_parityl((safe_lshift_func_int16_t_s_u((-1L), 0))) , l_125)) , l_126), g_92)), 0xB.BED92Bp+12)) < l_118)) != l_118), p_100)) > l_118) > p_104)) , l_127) , l_118) >= l_128))), g_3));
                g_130 = g_92;
                (*l_131) = (g_92 , p_102);
                (*l_133) = l_132;
            }
            else
            { /* block id: 54 */
                uint16_t l_141 = 0xEE88L;
                struct S0 l_149 = {4L};
                int32_t *l_162 = (void*)0;
                int32_t *l_192 = &g_92;
                int32_t **l_195 = (void*)0;
                int32_t **l_196 = &l_192;
                if ((*p_101))
                { /* block id: 55 */
                    uint32_t l_142 = 0x7AD18499L;
                    uint32_t l_150 = 0x5E89B025L;
                    int32_t *l_161 = (void*)0;
                    if ((((safe_mod_func_int32_t_s_s(l_125, (safe_lshift_func_int16_t_s_u((__builtin_ctzl(g_3) && p_104), ((safe_rshift_func_int16_t_s_u(g_92, 4)) < l_141))))) | ((((l_141 == l_142) && (((safe_mul_func_float_f_f(((((safe_lshift_func_int16_t_s_u(((safe_mul_func_float_f_f(p_100, g_130)) , 0x0407L), p_104)) ^ 0L) , l_149) , p_100), l_150)) < l_118) , g_92)) , 4UL) , 0x924CL)) == p_104))
                    { /* block id: 56 */
                        int32_t *l_152 = &l_149.f0;
                        int32_t **l_151 = &l_152;
                        int32_t *l_154 = &l_127.f0;
                        (*l_151) = p_101;
                        (*l_154) = (~g_130);
                        (*l_151) = (*l_151);
                    }
                    else
                    { /* block id: 60 */
                        float *l_155 = &g_156;
                        int32_t **l_158 = &l_157;
                        (*l_155) = p_104;
                        (*l_158) = l_157;
                    }
                    for (l_118 = 0; (l_118 != (-12)); --l_118)
                    { /* block id: 66 */
                        int32_t **l_163 = &l_161;
                        l_161 = &g_130;
                        (*l_163) = l_162;
                        (*l_163) = p_103;
                    }
                }
                else
                { /* block id: 71 */
                    int32_t **l_165 = &l_157;
                    struct S0 l_193 = {8L};
                    (*l_165) = l_164;
                    (*l_164) = __builtin_popcountl((safe_mul_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((((g_170 , 4294967291UL) || (*p_101)) > p_104), l_171)), p_104)));
                    for (l_171 = (-27); (l_171 == (-7)); ++l_171)
                    { /* block id: 76 */
                        float l_188 = 0x1.B5A963p-8;
                        struct S0 *l_189 = &l_127;
                        (**l_165) = (safe_rshift_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(((p_104 , g_170.f0) , (safe_add_func_uint16_t_u_u((0UL && (((((__builtin_popcountl(g_170.f0) > 0x8C202079L) >= (((0x3A0EL & (safe_lshift_func_int16_t_s_s((g_3 , (safe_lshift_func_int16_t_s_s((+((safe_mul_func_int16_t_s_s((((**l_165) < 0x6C9AL) >= l_127.f0), (-9L))) != 7UL)), (*l_157)))), g_3))) >= 65530UL) < p_104)) > p_104) , 0xE1AEL) == 1UL)), g_3))), g_3)), 4));
                        if (l_127.f0)
                            break;
                        (*l_165) = l_164;
                        (*l_189) = l_149;
                    }
                    for (l_149.f0 = 0; (l_149.f0 != (-5)); l_149.f0 = safe_sub_func_uint16_t_u_u(l_149.f0, 1))
                    { /* block id: 84 */
                        struct S0 *l_194 = &g_170;
                        (*l_165) = l_192;
                        if (l_118)
                            goto lbl_224;
                        (*l_164) = __builtin_popcountll(g_130);
                        (*l_194) = l_193;
                        return p_101;
                    }
                }
                (*l_196) = l_157;
                if ((*l_192))
                { /* block id: 92 */
                    l_197 = l_149;
                    (*l_196) = l_198;
                }
                else
                { /* block id: 95 */
                    return l_164;
                }
            }
            (*l_201) = (g_130 , l_199);
            for (l_125 = 12; (l_125 <= 23); ++l_125)
            { /* block id: 102 */
                struct S0 *l_205 = &l_127;
                int32_t l_223 = 0L;
                (*l_205) = g_170;
                for (l_127.f0 = (-24); (l_127.f0 < 26); l_127.f0 = safe_add_func_uint16_t_u_u(l_127.f0, 1))
                { /* block id: 106 */
                    g_208 = (void*)0;
                }
                for (g_130 = 0; (g_130 < 13); g_130 = safe_add_func_uint32_t_u_u(g_130, 9))
                { /* block id: 111 */
                    struct S0 l_219 = {0x24BC1480L};
                    const uint32_t l_222 = 0x9CF0C6C1L;
                    (*l_198) = (0xE6F0E40FL > 4UL);
                    l_219.f0 = (safe_add_func_float_f_f(g_92, (safe_sub_func_float_f_f(g_170.f0, (safe_mul_func_float_f_f(((safe_add_func_float_f_f((l_219 , 0x8.Bp-1), (-0x1.Bp+1))) > ((safe_mul_func_float_f_f(0x8.1931FAp-28, l_222)) , (l_223 == ((func_71((l_223 < (-0x1.Bp-1)), g_92) , g_3) , p_104)))), g_92))))));
                }
            }
        }
    }
    return &g_130;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_30();
    transparent_crc(g_3, "g_3", print_hash_value);
    transparent_crc(g_92, "g_92", print_hash_value);
    transparent_crc(g_130, "g_130", print_hash_value);
    transparent_crc_bytes (&g_156, sizeof(g_156), "g_156", print_hash_value);
    transparent_crc(g_170.f0, "g_170.f0", print_hash_value);
    transparent_crc_bytes (&g_401, sizeof(g_401), "g_401", print_hash_value);
    transparent_crc(g_527, "g_527", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 161
   depth: 1, occurrence: 31
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 33
breakdown:
   depth: 1, occurrence: 281
   depth: 2, occurrence: 57
   depth: 3, occurrence: 10
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 7, occurrence: 3
   depth: 11, occurrence: 3
   depth: 12, occurrence: 4
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 19, occurrence: 3
   depth: 20, occurrence: 1
   depth: 21, occurrence: 2
   depth: 22, occurrence: 3
   depth: 23, occurrence: 3
   depth: 25, occurrence: 2
   depth: 26, occurrence: 1
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 2

XXX total number of pointers: 151

XXX times a variable address is taken: 161
XXX times a pointer is dereferenced on RHS: 128
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 24
   depth: 3, occurrence: 19
XXX times a pointer is dereferenced on LHS: 103
breakdown:
   depth: 1, occurrence: 89
   depth: 2, occurrence: 9
   depth: 3, occurrence: 5
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 580

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 1623
   level: 2, occurrence: 209
   level: 3, occurrence: 102
   level: 4, occurrence: 20
XXX number of pointers point to pointers: 74
XXX number of pointers point to scalars: 55
XXX number of pointers point to structs: 22
XXX percent of pointers has null in alias set: 24.5
XXX average alias set size: 1.38

XXX times a non-volatile is read: 965
XXX times a non-volatile is write: 302
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 1
XXX backward jumps: 5

XXX stmts: 252
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 32
   depth: 1, occurrence: 36
   depth: 2, occurrence: 48
   depth: 3, occurrence: 39
   depth: 4, occurrence: 46
   depth: 5, occurrence: 51

XXX percentage a fresh-made variable is used: 18.8
XXX percentage an existing variable is used: 81.2
********************* end of statistics **********************/

