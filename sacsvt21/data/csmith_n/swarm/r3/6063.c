/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --longlong --no-int8 --uint8 --float --math64 --no-inline-function --muls --safe-math --no-packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2533589414
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   int64_t  f0;
   uint64_t  f1;
};

union U1 {
   uint32_t  f0;
   unsigned f1 : 20;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static float  func_1(void);
static uint16_t  func_5(float  p_6, union U0  p_7, uint32_t  p_8);
static float  func_15(float  p_16, uint8_t  p_17, int32_t  p_18, union U1  p_19, uint16_t  p_20);
static uint8_t  func_21(uint32_t  p_22, uint32_t  p_23);
static uint32_t  func_24(const union U0  p_25, int32_t  p_26, uint16_t  p_27, union U0  p_28, float  p_29);
static int32_t * func_33(int32_t * p_34, uint64_t  p_35);
static int32_t * func_36(uint64_t  p_37);
static uint16_t  func_42(uint32_t  p_43, uint64_t  p_44, int32_t * p_45, union U0  p_46, uint32_t  p_47);
static uint32_t  func_48(int64_t  p_49, float  p_50, uint8_t  p_51, int32_t * p_52, const int32_t  p_53);
static int32_t * func_56(uint8_t  p_57, union U1  p_58, int64_t  p_59, int16_t  p_60, int32_t  p_61);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_1(void)
{ /* block id: 0 */
    uint8_t l_4 = 0UL;
    const union U0 l_30 = {6L};
    uint32_t l_31 = 18446744073709551615UL;
    uint64_t l_32 = 0UL;
    int64_t l_239 = 0xB860E320F675B375LL;
    union U1 l_516 = {0x4678E7F8L};
    union U0 l_522 = {0x5AB369420EEF1A46LL};
    int32_t l_745 = (-3L);
    int32_t *l_744 = &l_745;
    int16_t l_746 = 0xFC89L;
    (*l_744) = (((safe_lshift_func_uint16_t_u_u(l_4, 9)) < (func_5((safe_sub_func_float_f_f(((safe_mul_func_float_f_f(((safe_mul_func_float_f_f((-0x8.4p+1), func_15(l_4, func_21(func_24(l_30, l_4, (l_4 && (l_30.f1 & (l_30.f1 | ((((l_30.f1 & l_4) | l_31) , l_32) , l_31)))), l_30, l_4), l_239), l_239, l_516, l_239))) != (-0x1.6p+1)), l_239)) < l_516.f0), 0x2.0A253Dp-63)), l_522, l_522.f1) & 65535UL)) | 0xD1352B8D52681281LL);
    (*l_744) = (*l_744);
    return l_746;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_5(float  p_6, union U0  p_7, uint32_t  p_8)
{ /* block id: 206 */
    uint8_t l_528 = 254UL;
    int16_t l_554 = 0L;
    float l_566 = 0x7.C306B8p-56;
    int32_t l_568 = 0x5A551108L;
    union U0 l_608 = {0L};
    union U0 *l_607 = &l_608;
    float *l_611 = &l_566;
    float **l_610 = &l_611;
    union U1 l_615 = {0x8D7DE846L};
    union U1 *l_614 = &l_615;
    union U1 **l_613 = &l_614;
    int32_t *l_619 = (void*)0;
    int64_t l_634 = 8L;
    int32_t *l_635 = &l_568;
    int32_t l_641 = (-1L);
    int32_t *l_707 = &l_568;
    union U1 ***l_724 = &l_613;
    union U1 ****l_723 = &l_724;
    union U1 *****l_722 = &l_723;
    int32_t *l_736 = &l_568;
    float *l_739 = &l_566;
    float *l_740 = &l_566;
    const float **** const *l_743 = (void*)0;
    for (p_7.f0 = 10; (p_7.f0 != (-13)); --p_7.f0)
    { /* block id: 209 */
        uint32_t l_527 = 0x804FDC04L;
        union U1 l_532 = {4294967293UL};
        union U1 *l_531 = &l_532;
        union U0 l_541 = {0x28D882C97B2767ECLL};
        union U0 *l_540 = &l_541;
        union U0 **l_539 = &l_540;
        int32_t *l_617 = &l_568;
        if ((0xD0AAL > (safe_sub_func_uint16_t_u_u((l_527 >= l_528), (((p_8 == (!((~((l_528 , (0UL != (((((void*)0 == l_531) < (p_8 , p_7.f1)) <= p_7.f0) == 0xB2ECFEDAL))) && l_527)) && l_528))) , l_532.f1) || p_7.f0)))))
        { /* block id: 210 */
            uint32_t l_542 = 0xC77EB58AL;
            int32_t **l_544 = (void*)0;
            int32_t ***l_543 = &l_544;
            float l_547 = (-0x1.8p-1);
            float *l_546 = &l_547;
            float **l_545 = &l_546;
            int32_t l_549 = 0x9A363C03L;
            int32_t *l_548 = &l_549;
            uint64_t l_567 = 18446744073709551607UL;
            (*l_548) = (safe_lshift_func_int16_t_s_s(((((((safe_mul_func_float_f_f(l_527, ((safe_mul_func_float_f_f(((((l_539 == (void*)0) < p_7.f1) == l_542) <= ((l_543 != (void*)0) != ((void*)0 != l_545))), p_8)) >= p_8))) != l_528) >= l_532.f1) , p_7.f0) > 0xCD6D06CA26BFCB97LL) , l_527), 13));
            for (l_528 = 0; (l_528 >= 53); l_528 = safe_add_func_uint64_t_u_u(l_528, 7))
            { /* block id: 214 */
                int32_t l_563 = 0xB3B2AFB7L;
                l_568 = (p_8 ^ ((((+((((~l_554) > (safe_add_func_uint64_t_u_u(((safe_mul_func_uint16_t_u_u((safe_mul_func_uint16_t_u_u(l_554, (((safe_add_func_uint16_t_u_u(((65526UL != 0x1670L) & l_563), (safe_sub_func_int64_t_s_s(p_8, l_532.f0)))) == p_7.f1) , p_8))), l_567)) , 0x24A25B0AF15DCCE0LL), l_532.f1))) >= l_541.f1) && p_7.f1)) && l_563) , (-5L)) >= (-5L)));
                return p_7.f1;
            }
            for (l_528 = 3; (l_528 < 26); l_528 = safe_add_func_uint16_t_u_u(l_528, 9))
            { /* block id: 220 */
                uint8_t l_585 = 8UL;
                const union U1 ****l_592 = (void*)0;
                int32_t **l_593 = &l_548;
            }
            if ((0UL || ((safe_mul_func_int16_t_s_s(l_532.f0, (0x03D4C543D13061C2LL && ((safe_sub_func_uint16_t_u_u(p_7.f1, (safe_mul_func_uint16_t_u_u(((safe_sub_func_int32_t_s_s(((l_568 & (((void*)0 != &l_543) | (safe_unary_minus_func_int32_t_s((safe_mul_func_int16_t_s_s(((((l_554 == (safe_sub_func_int64_t_s_s((((&p_7 == l_607) ^ 0UL) == 0xC4D17B3AL), p_7.f1))) | 1UL) | p_8) || 0xA831L), l_541.f1)))))) && (-1L)), l_608.f1)) , (*l_548)), p_8)))) & l_532.f1)))) || p_8)))
            { /* block id: 223 */
                float ***l_609 = (void*)0;
                const union U1 **l_612 = (void*)0;
                int32_t l_616 = (-1L);
                l_610 = &l_546;
                /* statement id: 224 */
                assert (l_610 == &l_546);
                l_617 = func_33(func_33(((l_612 == l_613) , func_36(l_616)), l_528), p_8);
                /* statement id: 225 */
                assert (l_617 == 0);
            }
            else
            { /* block id: 226 */
                int32_t l_618 = 0x5E89D6E7L;
                int32_t **l_620 = &l_619;
                if (l_618)
                    break;
                (*l_620) = func_33(l_619, p_8);
            }
            /* facts after branching */
            //assert (l_610 == &l_611 || l_610 == dangling || l_610 == &l_546);
            assert (l_617 == &l_568 || l_617 == 0);
        }
        else
        { /* block id: 230 */
            union U1 *l_621 = &l_615;
            l_621 = &l_532;
            /* statement id: 231 */
            assert (l_621 == &l_532);
        }
        /* facts after branching */
        assert (l_617 == &l_568 || l_617 == 0);
    }
    /* facts after for loop */
    //assert (l_610 == &l_611 || l_610 == dangling);
    (*l_635) = (safe_lshift_func_int16_t_s_s((p_7.f0 != p_7.f1), (p_7.f1 & ((p_7.f1 | ((&l_568 == (p_7 , (void*)0)) && (safe_sub_func_int16_t_s_s((safe_add_func_uint16_t_u_u(((safe_mul_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(((p_8 || (safe_add_func_int32_t_s_s(0x2E6564D6L, p_8))) , 0x7026L), p_7.f0)), l_634)) & (-10L)), l_608.f1)), 65535UL)))) ^ l_554))));
    if (((safe_add_func_float_f_f((!(safe_mul_func_float_f_f(((l_641 < p_8) <= (p_8 < (p_7.f1 >= ((safe_sub_func_float_f_f((+p_7.f0), (safe_sub_func_float_f_f(((&l_613 == (void*)0) != p_6), (p_8 >= (*l_635)))))) == p_7.f0)))), p_6))), 0xF.106C3Ep+79)) , p_7.f0))
    { /* block id: 235 */
        int32_t l_663 = 1L;
        const float *l_684 = &l_566;
        const float **l_683 = &l_684;
        union U1 ***l_690 = &l_613;
        union U1 ****l_689 = &l_690;
        union U1 **** const *l_688 = &l_689;
        l_635 = &l_568;
        (*l_611) = ((safe_mul_func_float_f_f(p_6, p_7.f0)) > 0xA.8A9A92p-64);
        for (p_7.f1 = 0; (p_7.f1 == 14); p_7.f1 = safe_add_func_uint16_t_u_u(p_7.f1, 4))
        { /* block id: 240 */
            union U0 l_659 = {-1L};
            union U1 ***l_687 = &l_613;
            union U1 ****l_686 = &l_687;
            union U1 *****l_685 = &l_686;
            for (l_608.f1 = 0; (l_608.f1 == 20); l_608.f1 = safe_add_func_uint16_t_u_u(l_608.f1, 1))
            { /* block id: 243 */
                uint32_t l_664 = 18446744073709551615UL;
                p_6 = (safe_mul_func_float_f_f(((safe_mul_func_float_f_f(p_7.f1, (safe_mul_func_float_f_f(p_8, (0x4.4p-1 >= ((l_659 , ((safe_unary_minus_func_int16_t_s(((0UL == p_7.f0) , ((safe_sub_func_uint16_t_u_u(p_7.f0, (l_663 >= p_7.f0))) & l_664)))) > p_7.f1)) , l_663)))))) < p_7.f0), l_659.f1));
            }
            /* facts after for loop */
                        l_663 = (safe_mul_func_int16_t_s_s(((((((((safe_mul_func_int16_t_s_s(((((*l_635) != (safe_mul_func_float_f_f(((safe_lshift_func_uint16_t_u_u(p_7.f0, ((l_659.f0 == (&l_568 == (void*)0)) <= (safe_add_func_int16_t_s_s(((safe_sub_func_float_f_f((*l_635), ((((safe_rshift_func_uint16_t_u_s(((safe_sub_func_uint32_t_u_u(((p_7.f1 , (((safe_mul_func_uint16_t_u_u(p_7.f0, p_7.f0)) > l_663) || (-10L))) >= p_7.f1), 0xD463A5F4L)) != 0xB202L), l_663)) , l_683) == &l_611) == p_6))) , l_663), 0x4B7FL))))) , (-0x8.Cp-1)), 0xA.13C8EFp+64))) != l_663) , p_7.f0), p_7.f1)) > (-5L)) , l_685) == l_688) , (-3L)) < 0x71A9CFEB89E98831LL) > 5UL) , l_663), l_663));
            (*l_635) = (-2L);
        }
        /* facts after for loop */
                for (l_663 = (-7); (l_663 > 18); l_663 = safe_add_func_uint16_t_u_u(l_663, 5))
        { /* block id: 251 */
            uint64_t l_705 = 0x83E292FA83594A9BLL;
            float ***l_712 = &l_610;
            float ****l_711 = &l_712;
            (*l_611) = (*l_635);
            if ((safe_mul_func_uint16_t_u_u(((+(safe_mul_func_uint16_t_u_u(((1UL > (((!(8UL ^ (0x653AL > ((*l_683) != (void*)0)))) || (safe_rshift_func_int16_t_s_s((safe_add_func_uint64_t_u_u(p_8, ((safe_mod_func_uint64_t_u_u(((l_705 , p_7.f1) >= 1L), l_663)) , p_8))), l_705))) > l_705)) || l_663), p_7.f0))) && 4294967292UL), l_663)))
            { /* block id: 253 */
                int32_t **l_706 = (void*)0;
                l_707 = &l_663;
                /* statement id: 254 */
                assert (l_707 == &l_663);
                (*l_635) = 0L;
            }
            else
            { /* block id: 256 */
                union U1 ** const *l_709 = (void*)0;
                union U1 ** const **l_708 = &l_709;
                union U1 *****l_710 = &l_689;
                float *****l_713 = &l_711;
                (*l_710) = l_708;
                /* statement id: 257 */
                assert (l_689 == &l_709);
                if (l_705)
                    break;
                //assert (l_689 == dangling);
                (*l_713) = l_711;
            }
        }
        /* facts after for loop */
        //assert (l_689 == dangling || l_689 == &l_690);
        assert (l_707 == &l_568 || l_707 == &l_663);
    }
    else
    { /* block id: 262 */
        union U1 * const **l_728 = (void*)0;
        union U1 * const ***l_727 = &l_728;
        int32_t l_729 = 0x8DDB5E0FL;
        uint8_t l_732 = 0x3BL;
        int32_t l_733 = 6L;
        uint64_t l_734 = 0xDA62A0674C4286ACLL;
        int32_t **l_735 = &l_635;
        (*l_707) = ((safe_add_func_int64_t_s_s(((safe_mul_func_float_f_f((safe_mul_func_float_f_f(0x4.F61455p-7, ((safe_mul_func_float_f_f((l_722 != ((1L > ((safe_rshift_func_int16_t_s_u((p_7.f0 | (((void*)0 == l_727) >= l_729)), 11)) ^ ((0x4CF81965B5E93562LL < (safe_mul_func_uint16_t_u_u((p_8 || 0x29422D7DD8A3D292LL), (*l_635)))) > l_732))) , &l_723)), (*l_707))) <= l_733))), p_8)) , l_732), 8UL)) , l_733);
        (*l_707) = l_732;
        (*l_735) = func_36(l_734);
        /* statement id: 265 */
        assert (l_635 == 0);
        (*l_735) = l_736;
        /* statement id: 266 */
        assert (l_635 == &l_568);
    }
    /* facts after branching */
        //assert (l_707 == &l_568 || l_707 == dangling);
    p_6 = (safe_add_func_float_f_f((p_7.f1 , ((((1UL & 1L) ^ (((p_7.f0 , l_739) == l_740) >= (safe_rshift_func_uint16_t_u_u((0x9C146A788BCEA79BLL >= (18446744073709551606UL <= ((((*l_635) | (*l_635)) ^ p_7.f0) && 0x04DBL))), p_7.f0)))) , l_743) != l_743)), p_8));
    return p_7.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_15(float  p_16, uint8_t  p_17, int32_t  p_18, union U1  p_19, uint16_t  p_20)
{ /* block id: 203 */
    int32_t l_518 = 0xB1D3B259L;
    int32_t *l_517 = &l_518;
    uint32_t l_521 = 0x0410DF2DL;
    l_517 = func_33(l_517, (safe_mod_func_int32_t_s_s(p_20, 0x22BD50EDL)));
    return l_521;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint8_t  func_21(uint32_t  p_22, uint32_t  p_23)
{ /* block id: 89 */
    float l_242 = 0x1.Fp+1;
    int32_t l_243 = (-10L);
    union U1 l_256 = {1UL};
    union U0 l_257 = {0xCDB1E1FFC80131C0LL};
    union U1 *l_265 = &l_256;
    union U1 **l_264 = &l_265;
    float *l_356 = &l_242;
    float **l_355 = &l_356;
    int32_t l_367 = 0x3A16C334L;
    union U0 *l_376 = &l_257;
    int32_t *l_382 = &l_243;
    int32_t **l_381 = &l_382;
    int32_t ***l_380 = &l_381;
    int32_t ****l_379 = &l_380;
    uint32_t l_394 = 0x37B53C0DL;
    union U0 *l_414 = &l_257;
    union U1 ***l_458 = &l_264;
    union U1 **** const l_457 = &l_458;
    uint8_t l_512 = 255UL;
    if ((safe_mod_func_int32_t_s_s((((l_243 && ((((p_22 < (((safe_sub_func_uint32_t_u_u((safe_mul_func_int16_t_s_s(((safe_lshift_func_uint16_t_u_u(((safe_add_func_int16_t_s_s(0x8FB5L, (safe_lshift_func_uint16_t_u_s(((safe_mul_func_int16_t_s_s(p_23, (l_256 , (l_257 , 0xE11BL)))) != (safe_rshift_func_uint16_t_u_s((((((p_22 , (((((safe_rshift_func_int16_t_s_u((safe_lshift_func_uint16_t_u_s(((((l_264 == &l_265) , p_22) <= l_243) && p_23), 9)), l_257.f0)) >= l_243) || l_257.f1) < 0xCB03L) <= 8L)) & l_257.f0) == 0xF209FDCAB0785E97LL) <= 0x07391C99L) ^ l_256.f1), 6))), p_22)))) < l_256.f0), 3)) | l_256.f1), p_22)), (-1L))) , 0xB121CEEEL) , l_256.f1)) != 0x299FL) >= 0x2AB11CDFF82CE327LL) , p_22)) <= 6L) || p_23), 0xDC195B6DL)))
    { /* block id: 90 */
        int32_t *l_268 = &l_243;
        int64_t l_298 = (-5L);
        uint64_t l_312 = 0x70A1CF68CDDB160ELL;
        union U0 *l_375 = &l_257;
        const int32_t *l_409 = &l_243;
        const int32_t **l_408 = &l_409;
        const int32_t ***l_407 = &l_408;
        const int32_t ****l_406 = &l_407;
        const int32_t *****l_405 = &l_406;
        union U1 l_447 = {4UL};
        int32_t l_459 = 0L;
        float **l_472 = &l_356;
        for (l_256.f0 = 22; (l_256.f0 < 15); l_256.f0--)
        { /* block id: 93 */
            int32_t **l_269 = &l_268;
            (*l_269) = l_268;
        }
        (*l_268) = (p_23 <= (safe_sub_func_int64_t_s_s((safe_rshift_func_uint16_t_u_s((((safe_sub_func_uint64_t_u_u((p_22 , p_22), ((p_23 , (safe_rshift_func_int16_t_s_s(((p_22 , (safe_sub_func_int64_t_s_s((safe_sub_func_uint16_t_u_u(((l_243 != (((l_257.f1 >= 0x3601L) || (safe_lshift_func_uint16_t_u_u(((l_257.f1 > 0xDCF2L) | 0L), (*l_268)))) , p_22)) , 65535UL), 65535UL)), (*l_268)))) , 1L), l_256.f0))) , 0xF445BDC185641E5CLL))) > p_23) <= l_257.f0), 1)), (*l_268))));
        for (l_257.f1 = 0; (l_257.f1 != 58); l_257.f1 = safe_add_func_int64_t_s_s(l_257.f1, 2))
        { /* block id: 99 */
            union U1 *l_294 = &l_256;
            int32_t l_297 = 0xD4049CAEL;
            float *l_299 = (void*)0;
            float *l_300 = (void*)0;
            float *l_301 = &l_242;
            uint32_t l_311 = 0x4D6FE356L;
            float **l_335 = (void*)0;
            float ***l_334 = &l_335;
            int32_t **l_368 = &l_268;
            int32_t ****l_421 = &l_380;
            const union U1 ***l_465 = (void*)0;
            const union U1 ****l_464 = &l_465;
            const union U1 ***** const l_463 = &l_464;
            const union U1 *****l_466 = &l_464;
            float l_471 = (-0x1.Dp-1);
            float ** const *l_480 = &l_335;
            union U0 l_481 = {0L};
            (*l_301) = (0x9.7p-1 > (safe_mul_func_float_f_f((safe_mul_func_float_f_f((safe_mul_func_float_f_f(p_23, ((safe_add_func_float_f_f(((void*)0 == l_294), p_23)) <= (((*l_265) , (safe_mul_func_float_f_f(((-0x2.9p+1) == (&l_243 != (void*)0)), l_297))) < p_23)))), l_298)), p_22)));
        }
        /* facts after for loop */
                for (l_298 = 0; (l_298 > (-16)); l_298 = safe_sub_func_int16_t_s_s(l_298, 1))
        { /* block id: 187 */
            return p_23;
        }
    }
    else
    { /* block id: 190 */
        int32_t *l_511 = &l_243;
        for (l_367 = 0; (l_367 < (-13)); l_367--)
        { /* block id: 193 */
            int32_t * const l_509 = &l_243;
            int32_t **l_510 = &l_382;
            (*l_510) = l_509;
            (**l_380) = l_511;
            return p_23;
        }
        return p_22;
    }
    /* facts after branching */
        (*l_381) = (*l_381);
    (**l_380) = func_33(func_33((***l_379), l_512), (p_23 | (((~p_23) , (*l_457)) != (*l_457))));
    return p_22;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_24(const union U0  p_25, int32_t  p_26, uint16_t  p_27, union U0  p_28, float  p_29)
{ /* block id: 1 */
    uint16_t l_54 = 0x17C9L;
    uint32_t l_55 = 0x904E20EEL;
    union U1 l_62 = {4294967295UL};
    int32_t l_167 = (-2L);
    int32_t *l_166 = &l_167;
    l_166 = func_33(func_36(((safe_mod_func_uint16_t_u_u(((&p_26 != (void*)0) || (safe_rshift_func_uint16_t_u_u(func_42(func_48(l_54, (l_54 != p_29), l_55, func_56(l_54, l_62, ((safe_add_func_uint32_t_u_u(l_62.f1, p_25.f1)) ^ 0x0F4FL), l_55, p_25.f1), l_62.f1), p_28.f0, l_166, p_28, p_26), 6))), (*l_166))) > 65535UL)), p_26);
    /* statement id: 75 */
    assert (l_166 == 0);
    l_166 = &p_26;
    /* statement id: 76 */
    assert (l_166 == &p_26);
    for (l_167 = 0; (l_167 != 29); l_167 = safe_add_func_int64_t_s_s(l_167, 1))
    { /* block id: 79 */
        uint16_t l_238 = 0x190DL;
        for (p_28.f1 = (-25); (p_28.f1 < 35); p_28.f1 = safe_add_func_uint32_t_u_u(p_28.f1, 1))
        { /* block id: 82 */
            float l_237 = 0x0.Ep+1;
            float *l_236 = &l_237;
            (*l_236) = 0x0.4p-1;
            (*l_236) = l_238;
            return p_25.f0;
        }
        /* facts after for loop */
            }
    return p_25.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_33(int32_t * p_34, uint64_t  p_35)
{ /* block id: 71 */
    union U0 l_211 = {0xF55AC2ACB64CFAA4LL};
    union U1 l_216 = {1UL};
    int32_t l_225 = (-3L);
    int32_t *l_224 = &l_225;
    int32_t **l_223 = &l_224;
    float l_231 = 0x8.A92CE8p-45;
    float *l_230 = &l_231;
    (*l_223) = func_36((((safe_mod_func_int32_t_s_s((0L != (l_211 , (safe_lshift_func_int16_t_s_u((safe_add_func_int16_t_s_s(((l_216 , l_211.f0) ^ (safe_lshift_func_uint16_t_u_u(l_211.f1, ((safe_sub_func_int16_t_s_s(0x01BEL, l_216.f1)) , (safe_mul_func_int16_t_s_s(l_211.f0, (0UL > l_216.f1))))))), l_211.f1)), p_35)))), p_35)) >= 0xA04D2973C7F1B259LL) && p_35));
    /* statement id: 72 */
    assert (l_224 == 0);
    (*l_230) = (safe_add_func_float_f_f((safe_add_func_float_f_f(p_35, p_35)), 0x1.5p+1));
    return p_34;
    /* statement id: 74 */
    //assert (func_33_rv == 0 || func_33_rv == &l_243 || func_33_rv == &l_518);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_36(uint64_t  p_37)
{ /* block id: 60 */
    float l_185 = 0xB.3AC48Bp-52;
    float *l_184 = &l_185;
    union U0 l_186 = {0x32DB0CE1991DECDDLL};
    union U1 l_187 = {0UL};
    int32_t l_197 = 2L;
    float l_198 = (-0x8.9p+1);
    const int64_t l_199 = 0L;
    int32_t *l_202 = &l_197;
    int32_t * const l_204 = &l_197;
    int32_t **l_205 = &l_202;
    const union U1 *l_207 = &l_187;
    const union U1 **l_206 = &l_207;
    int32_t *l_208 = (void*)0;
    (*l_184) = 0xC.5D45CBp+31;
    if ((((l_186 , (l_187 , l_186)) , p_37) == ((safe_add_func_uint16_t_u_u((safe_unary_minus_func_int16_t_s(0xC5C9L)), ((l_186.f1 , ((l_187.f0 , ((safe_lshift_func_uint16_t_u_s((((safe_sub_func_uint32_t_u_u((safe_mod_func_uint64_t_u_u(((l_197 , p_37) < p_37), p_37)), 0x07B652E5L)) < 65535UL) , p_37), p_37)) , l_199)) | l_187.f1)) > p_37))) | p_37)))
    { /* block id: 62 */
        int32_t *l_200 = &l_197;
        int32_t *l_201 = (void*)0;
        (*l_184) = p_37;
        return l_201;
        /* statement id: 64 */
        //assert (func_36_rv == 0);
    }
    else
    { /* block id: 65 */
        int32_t **l_203 = &l_202;
        (*l_203) = l_202;
    }
    (*l_205) = l_204;
    (*l_206) = (((*l_204) != (**l_205)) , &l_187);
    return l_208;
    /* statement id: 70 */
    //assert (func_36_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_42(uint32_t  p_43, uint64_t  p_44, int32_t * p_45, union U0  p_46, uint32_t  p_47)
{ /* block id: 57 */
    union U0 l_174 = {0xFDF27D3598B098B9LL};
    union U0 *l_173 = &l_174;
    union U0 ** const l_172 = &l_173;
    union U1 l_181 = {4294967291UL};
    float l_183 = (-0x1.3p-1);
    float *l_182 = &l_183;
    (*l_182) = (((safe_add_func_float_f_f(((((p_47 , ((((((safe_lshift_func_int16_t_s_s(((l_172 == &l_173) ^ 0x8B4FF7E3BC08C713LL), 14)) && (p_46.f1 , (safe_mul_func_int16_t_s_s((safe_add_func_int16_t_s_s(l_174.f1, (((((((safe_mod_func_int16_t_s_s((((-1L) == ((*l_172) != (void*)0)) & 0x132FC06C70737C93LL), p_44)) > l_174.f0) != p_44) & 1UL) , l_181) , (void*)0) != (void*)0))), p_47)))) , l_174.f1) >= p_43) != p_44) < p_47)) > 0x7.B7F88Ap-88) <= 0x4.5D356Ep+12) <= 0x0.Cp-1), p_43)) != l_174.f0) < (-0x2.0p-1));
    return l_174.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_48(int64_t  p_49, float  p_50, uint8_t  p_51, int32_t * p_52, const int32_t  p_53)
{ /* block id: 52 */
    uint64_t l_150 = 0xB8ED343B42109203LL;
    float *l_151 = (void*)0;
    float l_153 = 0x0.4p+1;
    float *l_152 = &l_153;
    int32_t **l_154 = (void*)0;
    union U1 l_157 = {2UL};
    int32_t **l_158 = (void*)0;
    int32_t *l_160 = (void*)0;
    int32_t **l_159 = &l_160;
    (*l_152) = l_150;
    (*l_159) = func_56((((p_49 != (p_52 == l_152)) ^ (0x9DDE94EDL != (p_49 , (l_150 | (l_154 == &p_52))))) , (safe_mod_func_int64_t_s_s(((void*)0 != &l_154), p_51))), l_157, p_49, p_53, p_51);
    (*l_152) = ((safe_rshift_func_uint16_t_u_s(((p_53 , p_51) != (safe_mod_func_int16_t_s_s((~18446744073709551608UL), p_51))), 10)) , (p_53 , p_50));
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_56(uint8_t  p_57, union U1  p_58, int64_t  p_59, int16_t  p_60, int32_t  p_61)
{ /* block id: 2 */
    uint8_t l_65 = 0UL;
    int32_t l_67 = 0xD2C82F3CL;
    int32_t *l_66 = &l_67;
    const union U0 l_68 = {1L};
    int64_t l_69 = 0x5470E9879A9257DELL;
    int32_t *l_145 = &l_67;
    int32_t *l_149 = (void*)0;
lbl_72:
    (*l_66) = (((void*)0 == &p_61) <= l_65);
    if ((l_68 , (((l_69 < 0UL) || (((safe_add_func_int64_t_s_s(p_57, ((*l_66) <= ((((void*)0 == &p_61) , (&p_61 == (void*)0)) && p_59)))) , p_58.f0) ^ 1UL)) , p_59)))
    { /* block id: 4 */
        int32_t **l_73 = &l_66;
        float l_106 = (-0x4.Ep+1);
        float *l_105 = &l_106;
        if (p_58.f0)
            goto lbl_72;
        (*l_73) = &p_61;
        /* statement id: 6 */
        assert (l_66 == &p_61);
        l_66 = (*l_73);
        if ((**l_73))
        { /* block id: 8 */
            float *l_76 = (void*)0;
            float l_78 = 0x0.Dp-1;
            float *l_77 = &l_78;
            union U0 l_87 = {0x822C3E505CE5052DLL};
            (**l_73) = p_61;
            (*l_77) = (safe_sub_func_float_f_f(p_58.f1, (-0x1.Fp+1)));
            (*l_66) = 0xA.45AB60p+13;
            for (l_65 = 0; (l_65 <= 11); l_65 = safe_add_func_int64_t_s_s(l_65, 1))
            { /* block id: 14 */
                uint32_t l_91 = 0xF72239D1L;
                const int32_t *l_133 = (void*)0;
                const int32_t * const *l_132 = &l_133;
                if ((0xB2D3F577L <= (safe_lshift_func_uint16_t_u_u((0x5D6068D11A6C9C6CLL | (safe_lshift_func_int16_t_s_u((((safe_mod_func_uint64_t_u_u(((l_87 , ((safe_mod_func_uint64_t_u_u(18446744073709551608UL, ((safe_unary_minus_func_int32_t_s(l_87.f0)) ^ l_91))) || p_60)) < ((((l_73 != l_73) < p_58.f0) || p_60) , (*l_66))), p_57)) <= p_58.f1) ^ p_58.f0), l_91))), 2))))
                { /* block id: 15 */
                    int64_t l_100 = 0x6CE7EF2A96A4AF12LL;
                    (**l_73) = ((*l_66) , (safe_add_func_float_f_f((safe_sub_func_float_f_f((((safe_add_func_float_f_f(((safe_sub_func_float_f_f(p_60, (-0x2.Ep-1))) > p_59), p_57)) > (l_87.f1 , (l_100 != p_59))) == (-0x1.5p+1)), (-0x3.3p-1))), 0xA.0A6C5Fp+79)));
                }
                else
                { /* block id: 17 */
                    uint16_t l_112 = 4UL;
                    int32_t *l_134 = &l_67;
                    if (((((-(((+(p_61 >= (safe_add_func_float_f_f(0x0.872AF4p-73, (l_105 == l_66))))) >= (((-0x7.4p+1) < ((safe_add_func_float_f_f(((p_60 == ((l_91 < l_87.f0) != (+(((safe_mul_func_uint16_t_u_u(65527UL, l_87.f1)) , 0x6.Cp+1) == p_58.f0)))) < 0x6.7DECC7p-88), (-0x1.Ep-1))) < p_60)) != l_112)) <= (**l_73))) , 0UL) ^ l_91) <= l_87.f0))
                    { /* block id: 18 */
                        union U0 l_123 = {0x1BA0D895055D0CFELL};
                        (**l_73) = (((safe_lshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s((safe_lshift_func_int16_t_s_s((((safe_add_func_uint32_t_u_u(p_57, (((((((((safe_mod_func_uint16_t_u_u((l_123 , (safe_add_func_uint32_t_u_u((safe_rshift_func_int16_t_s_s((safe_add_func_uint16_t_u_u(((safe_mul_func_int16_t_s_s(l_91, (p_61 , p_57))) != (**l_73)), ((p_61 , ((void*)0 != &p_61)) > 0x5997L))), l_87.f1)), (*l_66)))), 65535UL)) == 0x313C76A6L) < (*l_66)) ^ 0xF43A563CFC517259LL) , l_132) != &l_66) && (**l_73)) & l_123.f1) || 0x00029D1050BF12BFLL))) != p_57) ^ p_61), 10)), 8)), p_58.f1)) , l_112) > p_58.f1);
                        (*l_73) = l_134;
                        /* statement id: 20 */
                        assert (l_66 == &l_67);
                        (*l_134) = (**l_73);
                    }
                    else
                    { /* block id: 22 */
                        (*l_73) = l_77;
                        /* statement id: 23 */
                        assert (l_66 == &l_78);
                        return l_76;
                        /* statement id: 24 */
                        //assert (func_56_rv == 0);
                    }
                    /* facts after branching */
                    assert (l_66 == &l_67);
                }
                for (l_67 = (-13); (l_67 == 21); l_67 = safe_add_func_int64_t_s_s(l_67, 3))
                { /* block id: 29 */
                    union U0 *l_142 = &l_87;
                    union U0 **l_141 = &l_142;
                    for (p_61 = 3; (p_61 < 24); p_61 = safe_add_func_uint64_t_u_u(p_61, 5))
                    { /* block id: 32 */
                        (*l_73) = l_77;
                        /* statement id: 33 */
                        assert (l_66 == &l_78);
                        l_66 = &p_61;
                        /* statement id: 34 */
                        assert (l_66 == &p_61);
                    }
                    if (p_57)
                    { /* block id: 36 */
                        int32_t ***l_139 = &l_73;
                        (*l_139) = l_73;
                    }
                    else
                    { /* block id: 38 */
                        int16_t l_140 = 0xAACAL;
                        (*l_77) = (l_68 , l_140);
                    }
                    (*l_141) = &l_87;
                }
            }
            /* facts after for loop */
            assert (l_66 == &l_67 || l_66 == &p_61);
        }
        else
        { /* block id: 44 */
            int32_t *l_143 = &l_67;
            int32_t *l_144 = &l_67;
            int32_t *l_146 = &l_67;
            int32_t *l_147 = (void*)0;
            (*l_73) = &p_61;
            return l_147;
            /* statement id: 46 */
            //assert (func_56_rv == 0);
        }
        /* facts after branching */
        assert (l_66 == &l_67 || l_66 == &p_61);
    }
    else
    { /* block id: 48 */
        int32_t **l_148 = &l_145;
        (*l_148) = &p_61;
        /* statement id: 49 */
        assert (l_145 == &p_61);
    }
    /* facts after branching */
    assert (l_66 == &l_67 || l_66 == &p_61);
    assert (l_145 == &p_61 || l_145 == &l_67);
    return l_149;
    /* statement id: 51 */
    //assert (func_56_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 154
XXX total union variables: 21

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 27
breakdown:
   indirect level: 0, occurrence: 9
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 3
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 4
   indirect level: 5, occurrence: 5
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 10
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 14
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 17

XXX max expression depth: 38
breakdown:
   depth: 1, occurrence: 125
   depth: 2, occurrence: 18
   depth: 3, occurrence: 5
   depth: 4, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 2
   depth: 11, occurrence: 1
   depth: 13, occurrence: 2
   depth: 14, occurrence: 2
   depth: 16, occurrence: 4
   depth: 17, occurrence: 4
   depth: 18, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 23, occurrence: 2
   depth: 27, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 1
   depth: 38, occurrence: 1

XXX total number of pointers: 156

XXX times a variable address is taken: 161
XXX times a pointer is dereferenced on RHS: 81
breakdown:
   depth: 1, occurrence: 49
   depth: 2, occurrence: 16
   depth: 3, occurrence: 7
   depth: 4, occurrence: 8
   depth: 5, occurrence: 1
XXX times a pointer is dereferenced on LHS: 71
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 8
   depth: 3, occurrence: 5
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 28
XXX times a pointer is compared with address of another variable: 5
XXX times a pointer is compared with another pointer: 8
XXX times a pointer is qualified to be dereferenced: 236

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 135
   level: 2, occurrence: 42
   level: 3, occurrence: 17
   level: 4, occurrence: 12
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 78
XXX number of pointers point to scalars: 61
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 24.4
XXX average alias set size: 1.16

XXX times a non-volatile is read: 835
XXX times a non-volatile is write: 208
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 3

XXX stmts: 112
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 35
   depth: 1, occurrence: 24
   depth: 2, occurrence: 25
   depth: 3, occurrence: 14
   depth: 4, occurrence: 5
   depth: 5, occurrence: 9

XXX percentage a fresh-made variable is used: 18.5
XXX percentage an existing variable is used: 81.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

