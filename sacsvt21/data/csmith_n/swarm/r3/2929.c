/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-comma-operators --no-compound-assignment --no-consts --divs --embedded-assigns --pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --no-longlong --int8 --uint8 --no-float --no-math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --no-builtins
 * Seed:      1095349184
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   int8_t  f1;
   signed f2 : 1;
};

struct S1 {
   signed f0 : 29;
   signed f1 : 11;
   unsigned f2 : 4;
   unsigned f3 : 11;
   unsigned f4 : 6;
   signed f5 : 14;
   signed f6 : 2;
   unsigned f7 : 24;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int16_t  func_1(void);
static struct S0  func_42(int32_t ** p_43);
static int32_t ** func_44(int8_t  p_45, struct S0  p_46, uint8_t  p_47, uint16_t  p_48);
static struct S0  func_49(int8_t  p_50, uint32_t  p_51, uint8_t  p_52, int32_t  p_53);
static uint32_t  func_56(int32_t ** p_57, uint16_t  p_58);
static int32_t ** func_63(uint16_t  p_64, int32_t  p_65);
static int32_t * func_77(uint16_t *** p_78, uint16_t  p_79, uint8_t  p_80, int32_t  p_81);
static int8_t  func_104(uint16_t *** p_105, struct S0  p_106);
static struct S0  func_107(struct S0  p_108, struct S0  p_109, uint8_t * p_110, uint16_t ** p_111);
static struct S0 * func_134(uint32_t  p_135, struct S0 * p_136, uint8_t * p_137);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_1(void)
{ /* block id: 0 */
    uint8_t l_2 = 0x44;
    int8_t l_616 = (-1);
    int8_t *l_615 = &l_616;
    int8_t **l_614 = &l_615;
    int8_t ***l_613 = &l_614;
    int32_t l_617 = 0xA83B79B0;
    int32_t *l_624 = (void*)0;
    int32_t *l_625 = (void*)0;
    int32_t *l_626 = &l_617;
    int32_t l_627 = 0x13E9DB47;
    if ((l_2 != l_2))
    { /* block id: 1 */
        int32_t l_4 = 0xA7FE64FD;
        int32_t *l_3 = &l_4;
        int32_t **l_5 = &l_3;
        (*l_5) = l_3;
        for (l_4 = 0; (l_4 >= (-14)); l_4 -= 1)
        { /* block id: 5 */
            int32_t l_8 = 0;
            return l_8;
        }
    }
    else
    { /* block id: 8 */
        uint8_t l_17 = 0x07;
        int32_t l_20 = 0xDFDDAE97;
        int32_t *l_19 = &l_20;
        (*l_19) = ((uint8_t)(-(int8_t)((uint16_t)(((uint16_t)(!l_17) >> (uint16_t)0) && l_2) << (uint16_t)(~(l_17 <= ((-1) || l_17))))) << (uint8_t)l_2);
    }
    for (l_2 = 16; (l_2 <= 24); l_2 += 8)
    { /* block id: 13 */
        int32_t l_23 = (-5);
        for (l_23 = 0; (l_23 >= (-19)); l_23 -= 1)
        { /* block id: 16 */
            int32_t l_27 = 1;
            int32_t *l_26 = &l_27;
            int8_t l_602 = 0xBC;
            int8_t *l_601 = &l_602;
            int8_t **l_600 = &l_601;
            int8_t ***l_599 = &l_600;
            int32_t l_618 = 0x340A8E6C;
            struct S0 l_621 = {0x21A75E04,0xCA,-0};
            uint32_t l_623 = 2U;
            (*l_26) = l_23;
            for (l_27 = 0; (l_27 <= (-22)); l_27 -= 1)
            { /* block id: 20 */
                int16_t l_32 = (-1);
                int32_t l_34 = 8;
                int32_t *l_33 = &l_34;
                int32_t l_36 = 0x23C5AD05;
                int32_t *l_35 = &l_36;
                uint16_t l_590 = 3U;
                uint16_t *l_589 = &l_590;
                uint16_t **l_588 = &l_589;
                uint16_t ***l_587 = &l_588;
                uint16_t ****l_586 = &l_587;
                struct S0 *l_622 = &l_621;
                (*l_35) = ((*l_33) = ((int8_t)0x44 / (int8_t)(l_32 ^ l_32)));
                for (l_34 = 0; (l_34 >= 0); l_34 += 8)
                { /* block id: 25 */
                    uint32_t l_41 = 0x39BF5BF8;
                    uint16_t *l_59 = (void*)0;
                    uint16_t l_61 = 5U;
                    uint16_t *l_60 = &l_61;
                    int32_t **l_67 = &l_35;
                    int32_t ***l_66 = &l_67;
                    struct S0 l_580 = {4294967295U,1,-0};
                    struct S0 *l_579 = &l_580;
                    uint8_t l_592 = 255U;
                    uint8_t *l_591 = &l_592;
                    int16_t *l_619 = &l_32;
                    int32_t l_620 = 0xBE5E4751;
                    (*l_35) = ((*l_26) || ((int32_t)(l_2 <= l_2) % (int32_t)l_41));
                    (*l_579) = func_42(func_44((*l_26), func_49((func_56(&l_33, ((*l_60) = l_41)) == (func_56(func_63(l_23, func_56(((*l_66) = (void*)0), (*l_33))), (*l_35)) <= l_2)), l_23, l_2, (*l_35)), l_41, l_2));
                    /* statement id: 260 */
                    assert (l_67 == 0);
                    (*l_35) = l_2;
                    (*l_35) = (!(l_23 || (((int32_t)((uint32_t)((*l_35) < (((***l_587) = (((*l_591) = (65535U > ((void*)0 != l_586))) > (((*l_619) = ((int32_t)((uint16_t)((uint16_t)((*l_60) = ((l_599 != &l_600) <= ((((uint16_t)l_2 * (uint16_t)((int16_t)((int8_t)(((int16_t)((int16_t)(l_613 != (void*)0) % (int16_t)l_617) * (int16_t)l_2) ^ l_618) << (int8_t)(*l_35)) * (int16_t)(*l_33))) && l_23) & (*l_26)))) % (uint16_t)0x9639) << (uint16_t)(*l_33)) / (int32_t)l_616)) >= l_23))) < l_620)) - (uint32_t)(*l_35)) + (int32_t)0x3662FD13) & 0x7635144D)));
                }
                (*l_622) = l_621;
                (*l_35) = (*l_26);
            }
            return l_623;
        }
    }
    (*l_626) = l_616;
    return l_627;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_42(int32_t ** p_43)
{ /* block id: 258 */
    struct S0 l_578 = {0x9E9E7353,-1,0};
    return l_578;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_44(int8_t  p_45, struct S0  p_46, uint8_t  p_47, uint16_t  p_48)
{ /* block id: 251 */
    int32_t l_573 = 1;
    int32_t *l_572 = &l_573;
    int32_t **l_574 = &l_572;
    int32_t **l_575 = &l_572;
    int32_t **l_576 = &l_572;
    int32_t **l_577 = (void*)0;
    for (p_47 = 0; (p_47 == 57); p_47 += 4)
    { /* block id: 254 */
        int32_t l_571 = (-1);
        int32_t *l_570 = &l_571;
        l_572 = l_570;
        /* statement id: 255 */
        assert (l_572 == &l_571);
    }
    /* facts after for loop */
    //assert (l_572 == dangling || l_572 == &l_573);
    return l_577;
    /* statement id: 257 */
    //assert (func_44_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_49(int8_t  p_50, uint32_t  p_51, uint8_t  p_52, int32_t  p_53)
{ /* block id: 35 */
    uint16_t ***l_82 = (void*)0;
    int32_t l_85 = 1;
    uint8_t *l_87 = (void*)0;
    uint8_t l_89 = 7U;
    uint8_t *l_88 = &l_89;
    struct S0 l_112 = {2U,-1,-0};
    uint16_t l_115 = 9U;
    uint16_t *l_114 = &l_115;
    uint16_t **l_113 = &l_114;
    int32_t *l_301 = &l_85;
    int32_t **l_300 = &l_301;
    int32_t *l_307 = (void*)0;
    int32_t *l_308 = &l_85;
    struct S0 *l_395 = (void*)0;
    struct S0 **l_394 = &l_395;
    uint8_t l_396 = 2U;
    struct S1 l_438 = {-21342,-5,3,34,5,49,-1,1515};
    struct S1 *l_437 = &l_438;
    int8_t *l_486 = (void*)0;
    int8_t **l_485 = &l_486;
    int8_t ***l_484 = &l_485;
    int8_t ****l_483 = &l_484;
    int16_t l_492 = 0x4F5E;
    uint32_t l_505 = 0xCE66FDB4;
    struct S1 **l_544 = &l_437;
    struct S1 ***l_543 = &l_544;
    uint32_t l_552 = 0x30F8F43F;
    (*l_300) = func_77(l_82, ((uint16_t)l_85 + (uint16_t)(~l_85)), ((*l_88) = l_85), ((int32_t)(0x9D || ((uint16_t)((uint8_t)((int16_t)(((int16_t)((int32_t)(((int8_t)func_104(l_82, func_107(l_112, l_112, l_87, l_113)) * (int8_t)0x41) >= p_51) - (int32_t)p_52) - (int16_t)l_85) | 0x9E1A) + (int16_t)0x09B0) << (uint8_t)5) << (uint16_t)4)) / (int32_t)p_52));
    /* statement id: 127 */
    assert (l_301 == 0);
    (*l_308) = (((4294967295U <= ((~((int8_t)(&l_300 == &l_300) - (int8_t)0x7A)) <= ((int8_t)(4294967295U <= (p_51 > 0xAE)) % (int8_t)p_50))) >= 0x869F) || l_89);
    for (l_112.f0 = 0; (l_112.f0 != 33); ++l_112.f0)
    { /* block id: 131 */
        struct S0 *l_312 = (void*)0;
        struct S0 **l_311 = &l_312;
        int32_t l_329 = 0x7AA1D18F;
        uint16_t l_340 = 9U;
        int32_t *l_347 = &l_85;
        uint16_t ***l_348 = &l_113;
        int32_t l_397 = 0x787789EA;
        uint32_t l_399 = 3U;
        uint32_t *l_398 = &l_399;
        int32_t ***l_462 = &l_300;
        struct S1 l_468 = {-22674,-33,1,42,7,-111,-0,2313};
        int8_t ****l_487 = (void*)0;
        struct S1 **l_498 = &l_437;
        struct S1 **l_500 = &l_437;
        uint8_t *l_507 = &l_396;
        uint32_t l_562 = 0xC6B66814;
        (*l_308) = (l_311 == (void*)0);
    }
    return l_112;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_56(int32_t ** p_57, uint16_t  p_58)
{ /* block id: 28 */
    struct S0 l_62 = {0x3260039C,0xD5,-0};
    l_62 = l_62;
    return p_58;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_63(uint16_t  p_64, int32_t  p_65)
{ /* block id: 32 */
    uint16_t l_71 = 0xCD4D;
    uint16_t *l_70 = &l_71;
    uint16_t **l_69 = &l_70;
    uint16_t ***l_68 = &l_69;
    int32_t l_74 = 0xADAF8D98;
    int32_t *l_73 = &l_74;
    int32_t **l_72 = &l_73;
    int32_t **l_75 = &l_73;
    int32_t **l_76 = (void*)0;
    (*l_68) = (void*)0;
    /* statement id: 33 */
    assert (l_69 == 0);
    return l_76;
    /* statement id: 34 */
    //assert (func_63_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_77(uint16_t *** p_78, uint16_t  p_79, uint8_t  p_80, int32_t  p_81)
{ /* block id: 108 */
    uint32_t l_251 = 0U;
    uint32_t *l_250 = &l_251;
    int32_t l_254 = 0x55B3299B;
    int16_t l_258 = 0;
    int16_t *l_257 = &l_258;
    uint8_t l_270 = 0xC0;
    uint8_t *l_269 = &l_270;
    int8_t l_278 = 0x57;
    int8_t l_279 = 1;
    int32_t l_281 = 0xE4F70735;
    int32_t *l_280 = &l_281;
    uint16_t l_283 = 0xE8CA;
    uint16_t *l_282 = &l_283;
    int16_t l_285 = (-8);
    int16_t *l_284 = &l_285;
    int16_t l_287 = 0x1809;
    int16_t *l_286 = &l_287;
    int32_t *l_288 = &l_254;
    struct S1 *l_294 = (void*)0;
    struct S1 **l_293 = &l_294;
    struct S1 ***l_295 = &l_293;
    int32_t *l_296 = &l_254;
    int32_t *l_297 = &l_281;
    int32_t *l_298 = &l_281;
    int32_t *l_299 = (void*)0;
    if (((uint32_t)(((*l_250) = p_80) != (((((*l_288) = (((*l_286) = ((int16_t)((*l_284) = (l_254 | ((uint8_t)(((*l_257) = l_254) | ((*l_282) = ((uint16_t)0xD0A0 >> (uint16_t)((int16_t)((l_250 != l_250) & ((((*l_280) = ((uint16_t)((uint16_t)(((uint8_t)((*l_269) = 0x07) >> (uint8_t)(((-(int8_t)((uint16_t)(((uint16_t)(((int8_t)l_254 - (int8_t)(l_254 & 1U)) & 65534U) << (uint16_t)15) & p_81) >> (uint16_t)l_254)) || 4294967295U) & l_254)) ^ l_278) / (uint16_t)l_279) + (uint16_t)p_81)) || 1) > l_254)) - (int16_t)0x8430)))) >> (uint8_t)0))) % (int16_t)p_81)) < 2U)) || 0xE0B29614) >= 0U) < 0xD236)) % (uint32_t)l_278))
    { /* block id: 117 */
        struct S1 l_290 = {-115,-14,3,5,7,92,-1,3887};
        struct S1 *l_289 = &l_290;
        int8_t ****l_291 = (void*)0;
        l_289 = l_289;
        (*l_288) = (((void*)0 != &l_258) < (*l_280));
        l_291 = l_291;
    }
    else
    { /* block id: 121 */
        uint16_t l_292 = 0U;
        (*l_288) = l_292;
    }
    l_288 = &p_81;
    /* statement id: 124 */
    assert (l_288 == &p_81);
    (*l_295) = l_293;
    return l_299;
    /* statement id: 126 */
    //assert (func_77_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_104(uint16_t *** p_105, struct S0  p_106)
{ /* block id: 40 */
    uint16_t l_124 = 1U;
    int32_t *l_227 = (void*)0;
    uint32_t l_230 = 9U;
    uint8_t *l_231 = (void*)0;
    uint8_t **l_232 = (void*)0;
    int32_t l_235 = 0xEF8C87AC;
    int32_t *l_236 = &l_235;
    uint16_t *l_245 = &l_124;
    int32_t l_246 = 0xC7E891FE;
    int32_t **l_247 = &l_236;
    for (p_106.f0 = 0; (p_106.f0 != 2); ++p_106.f0)
    { /* block id: 43 */
        int32_t l_123 = 0x5C99C235;
        int32_t *l_125 = &l_123;
        struct S0 l_201 = {0xC05FA5AF,0x8D,0};
        struct S0 *l_200 = &l_201;
        int8_t l_211 = 0x90;
        int16_t l_219 = 0xCC42;
        int16_t *l_218 = &l_219;
        (*l_125) = ((uint16_t)l_123 % (uint16_t)l_124);
        for (l_124 = 0; (l_124 < 27); l_124 += 5)
        { /* block id: 47 */
            int32_t *l_217 = (void*)0;
            for (l_123 = (-24); (l_123 >= (-6)); l_123 += 1)
            { /* block id: 50 */
                int8_t l_138 = 6;
                struct S0 *l_203 = &l_201;
                int16_t l_212 = 0xCA7B;
                struct S1 l_214 = {-1382,-9,0,28,0,-74,1,3714};
                struct S1 *l_213 = &l_214;
                int32_t *l_216 = &l_123;
                for (p_106.f1 = 0; (p_106.f1 <= 2); p_106.f1 += 1)
                { /* block id: 53 */
                    int32_t l_133 = (-1);
                    int32_t *l_132 = &l_133;
                    (*l_132) = 0x3870B5DC;
                    if (p_106.f1)
                    { /* block id: 55 */
                        int32_t **l_139 = &l_132;
                        struct S0 l_142 = {4294967288U,0xC7,-0};
                        struct S0 *l_141 = &l_142;
                        struct S0 **l_140 = &l_141;
                        uint8_t l_144 = 248U;
                        uint8_t *l_143 = &l_144;
                        uint16_t l_205 = 65530U;
                        uint16_t *l_204 = &l_205;
                        struct S1 **l_215 = &l_213;
                        l_200 = func_134(((l_138 = p_106.f2) < ((void*)0 == l_139)), ((*l_140) = &p_106), l_143);
                        /* statement id: 79 */
                        assert (l_200 == &p_106);
                        assert (l_141 == &p_106);
                        l_212 = ((!(**l_139)) == (((*l_204) = ((((*l_140) = func_134((*l_125), l_203, &l_144)) != &p_106) ^ (p_106.f2 = p_106.f1))) != ((-(int32_t)((uint16_t)(((uint32_t)(0 <= (l_211 < (**l_139))) - (uint32_t)p_106.f1) != (*l_132)) / (uint16_t)(-4))) | l_138)));
                        /* statement id: 83 */
                        assert (l_141 == &l_201);
                        (*l_215) = l_213;
                        l_217 = l_216;
                        /* statement id: 85 */
                        assert (l_217 == &l_123);
                    }
                    else
                    { /* block id: 86 */
                        if (p_106.f1)
                            break;
                    }
                }
                p_106.f2 = (((void*)0 == l_218) && 0x9B2D93A8);
            }
            /* facts after for loop */
            assert (l_217 == 0 || l_217 == &l_123);
        }
        /* facts after for loop */
        assert (l_200 == &l_201 || l_200 == &p_106);
        for (p_106.f1 = 0; (p_106.f1 >= (-25)); p_106.f1 -= 1)
        { /* block id: 95 */
            int8_t *l_223 = &l_211;
            int8_t **l_222 = &l_223;
            int8_t ***l_224 = (void*)0;
            int32_t *l_225 = &l_123;
            int32_t **l_226 = &l_225;
            l_222 = l_222;
            (*l_226) = l_225;
            (*l_226) = l_227;
            /* statement id: 98 */
            assert (l_225 == 0);
        }
    }
    l_246 = (((int8_t)(((l_230 >= p_106.f2) == (((l_231 = l_231) != (void*)0) != ((*l_245) = ((int32_t)((*l_236) = l_235) % (int32_t)((int16_t)(p_106.f2 | ((l_124 || (p_106.f0 >= (((int8_t)((uint16_t)(((uint16_t)((p_106.f2 && 0x63) != p_106.f0) + (uint16_t)p_106.f0) && l_124) * (uint16_t)p_106.f0) + (int8_t)p_106.f2) & l_230))) & p_106.f0)) >> (int16_t)1))))) != p_106.f1) / (int8_t)p_106.f0) | l_230);
    (*l_247) = &l_235;
    (*l_236) = (**l_247);
    return p_106.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_107(struct S0  p_108, struct S0  p_109, uint8_t * p_110, uint16_t ** p_111)
{ /* block id: 37 */
    int32_t l_117 = 0x20EC44CB;
    int32_t *l_116 = &l_117;
    int32_t **l_118 = &l_116;
    (*l_118) = l_116;
    return p_109;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_134(uint32_t  p_135, struct S0 * p_136, uint8_t * p_137)
{ /* block id: 58 */
    uint16_t l_155 = 0xFBAE;
    uint16_t *l_154 = &l_155;
    int32_t l_178 = 9;
    struct S0 l_179 = {1U,0xAD,-0};
    uint8_t l_181 = 0xDD;
    uint8_t *l_180 = &l_181;
    struct S0 l_184 = {0x664A1005,-1,-0};
    int32_t *l_189 = &l_178;
    int32_t **l_199 = &l_189;
    if (((uint8_t)((int16_t)(((*p_137) != (p_135 >= (~((uint8_t)((uint16_t)((void*)0 != l_154) >> (uint16_t)3) + (uint8_t)(1 <= ((uint8_t)((int16_t)((int16_t)l_155 << (int16_t)0) / (int16_t)0x8BAC) << (uint8_t)0)))))) > (-1)) - (int16_t)((uint16_t)(~(((int8_t)(l_155 <= p_135) >> (int8_t)l_155) >= 0xA1)) + (uint16_t)0xD78A)) >> (uint8_t)l_155))
    { /* block id: 59 */
        uint32_t l_173 = 4294967295U;
        int16_t l_177 = 0x574D;
        int16_t *l_176 = &l_177;
        l_178 = ((uint16_t)((uint8_t)l_155 - (uint8_t)(1 >= (-1))) >> (uint16_t)((uint16_t)l_173 * (uint16_t)(((*p_137) = (l_155 || l_173)) <= (((*l_176) = ((int8_t)(l_173 && (l_173 & (0xCA7CC927 < p_135))) - (int8_t)l_155)) | p_135))));
    }
    else
    { /* block id: 63 */
        uint16_t **l_182 = (void*)0;
        struct S0 *l_183 = &l_179;
        uint8_t *l_185 = &l_181;
        uint8_t **l_186 = &l_180;
        int32_t **l_187 = (void*)0;
        int32_t **l_188 = (void*)0;
        int32_t *l_191 = (void*)0;
        int32_t **l_190 = &l_191;
        int32_t *l_193 = &l_178;
        int32_t **l_192 = &l_193;
        int8_t *l_194 = &l_184.f1;
        int8_t *l_195 = &l_179.f1;
        int32_t *l_198 = &l_178;
        (*l_183) = func_107(func_107((*p_136), (*p_136), p_137, &l_154), func_107(((*l_183) = func_107((*p_136), l_179, l_180, l_182)), l_184, l_185, &l_154), &l_181, l_182);
        (*l_183) = func_107(((*l_183) = func_107((*l_183), (*p_136), ((*l_186) = (p_137 = (void*)0)), &l_154)), l_184, l_185, l_182);
        /* statement id: 69 */
        assert (p_137 == 0);
        assert (l_180 == 0);
        (*l_192) = ((*l_190) = (l_189 = (void*)0));
        /* statement id: 72 */
        assert (l_189 == 0);
        assert (l_193 == 0);
        (*l_198) = (((*l_195) = ((*l_194) = p_135)) ^ ((uint16_t)p_135 << (uint16_t)p_135));
    }
    /* facts after branching */
    //assert (p_137 == 0 || p_137 == &l_144 || p_137 == &l_396);
    assert (l_180 == 0 || l_180 == &l_181);
    assert (l_189 == 0 || l_189 == &l_178);
    (*l_199) = &l_178;
    /* statement id: 77 */
    assert (l_189 == &l_178);
    return p_136;
    /* statement id: 78 */
    //assert (func_134_rv == &p_106 || func_134_rv == &l_201 || func_134_rv == &l_112);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 116
   depth: 1, occurrence: 12
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 9
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 26
breakdown:
   indirect level: 0, occurrence: 12
   indirect level: 1, occurrence: 7
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 1
XXX full-bitfields structs in the program: 1
breakdown:
   indirect level: 0, occurrence: 1
XXX times a bitfields struct's address is taken: 14
XXX times a bitfields struct on LHS: 3
XXX times a bitfields struct on RHS: 24
XXX times a single bitfield on LHS: 2
XXX times a single bitfield on RHS: 6

XXX max expression depth: 37
breakdown:
   depth: 1, occurrence: 81
   depth: 2, occurrence: 15
   depth: 3, occurrence: 3
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 1
   depth: 29, occurrence: 1
   depth: 37, occurrence: 1

XXX total number of pointers: 171

XXX times a variable address is taken: 158
XXX times a pointer is dereferenced on RHS: 48
breakdown:
   depth: 1, occurrence: 41
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is dereferenced on LHS: 110
breakdown:
   depth: 1, occurrence: 103
   depth: 2, occurrence: 6
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 12
XXX times a pointer is compared with address of another variable: 3
XXX times a pointer is compared with another pointer: 3
XXX times a pointer is qualified to be dereferenced: 382

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 330
   level: 2, occurrence: 41
   level: 3, occurrence: 22
   level: 4, occurrence: 2
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 76
XXX number of pointers point to scalars: 78
XXX number of pointers point to structs: 17
XXX percent of pointers has null in alias set: 25.7
XXX average alias set size: 1.2

XXX times a non-volatile is read: 506
XXX times a non-volatile is write: 277
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 72
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 29
   depth: 1, occurrence: 18
   depth: 2, occurrence: 8
   depth: 3, occurrence: 6
   depth: 4, occurrence: 6
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 16.5
XXX percentage an existing variable is used: 83.5
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

