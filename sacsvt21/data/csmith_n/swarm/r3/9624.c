/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --uint8 --no-float --math64 --no-inline-function --muls --no-safe-math --packed-struct --paranoid --pointers --no-structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2471342222
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
union U0 {
   uint16_t  f0;
   uint32_t  f1;
   int32_t  f2;
   uint32_t  f3;
   volatile int64_t  f4;
};

union U1 {
   volatile int8_t * f0;
   uint8_t  f1;
   int8_t * f2;
   volatile unsigned f3 : 1;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_4 = 0x0D00585BL;
static int32_t g_8[3][2] = {{0xD5B611FBL,0xD5B611FBL},{0xD5B611FBL,0xD5B611FBL},{0xD5B611FBL,0xD5B611FBL}};
static int8_t g_50 = 0x2CL;
static int32_t g_56 = (-1L);
static int32_t g_70 = (-1L);
static int8_t *g_97 = &g_50;
static int8_t **g_96 = &g_97;
static int8_t ***g_95 = &g_96;
static volatile int32_t *g_111 = (void*)0;
static volatile int32_t **g_110 = &g_111;
static union U0 *g_115[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static union U0 g_121 = {0x988DL};/* VOLATILE GLOBAL g_121 */
static int32_t *g_219[10] = {&g_8[2][0],&g_8[2][0],&g_56,&g_8[2][0],&g_56,&g_8[2][0],&g_8[2][0],&g_56,&g_8[2][0],&g_56};
static union U1 g_263[7] = {{0},{0},{0},{0},{0},{0},{0}};
static union U1 *g_262[5] = {&g_263[1],&g_263[1],&g_263[1],&g_263[1],&g_263[1]};
static volatile uint32_t g_324 = 0xBF82B213L;/* VOLATILE GLOBAL g_324 */
static int32_t *****g_376 = (void*)0;
static int8_t g_447 = (-1L);
static int32_t g_449 = 1L;
static int32_t *g_448[9] = {&g_449,&g_449,&g_449,&g_449,&g_449,&g_449,&g_449,&g_449,&g_449};
static int8_t ****g_466 = &g_95;
static int8_t *****g_465 = &g_466;
static volatile int32_t g_520 = 0x514285EEL;/* VOLATILE GLOBAL g_520 */
static union U0 g_599[8][6] = {{{1UL},{65533UL},{65531UL},{65531UL},{65533UL},{65535UL}},{{1UL},{65535UL},{65531UL},{65535UL},{1UL},{1UL}},{{65530UL},{65535UL},{65535UL},{65530UL},{65533UL},{65530UL}},{{65530UL},{65533UL},{65530UL},{65535UL},{65535UL},{65530UL}},{{1UL},{1UL},{65535UL},{65531UL},{65535UL},{1UL}},{{65535UL},{65533UL},{65531UL},{65531UL},{65533UL},{65535UL}},{{1UL},{65535UL},{65531UL},{65535UL},{1UL},{1UL}},{{65530UL},{65535UL},{65535UL},{65530UL},{65533UL},{65530UL}}};
static uint64_t g_625 = 0x6027D64C9FE9BB53LL;
static int8_t g_653[3] = {0x7DL,0x7DL,0x7DL};


/* --- FORWARD DECLARATIONS --- */
static int32_t  func_1(void);
static int16_t  func_11(int8_t * p_12, int8_t * p_13, uint16_t  p_14, int32_t * p_15, int8_t * p_16);
static int8_t * func_17(int64_t  p_18, int8_t  p_19, uint8_t  p_20, const uint8_t  p_21, int64_t  p_22);
static int32_t  func_33(uint64_t  p_34, int8_t * p_35);
static const int8_t  func_36(int64_t  p_37, int32_t * p_38);
static int32_t * func_40(int16_t  p_41, int32_t * p_42, int32_t * p_43, const uint32_t  p_44, uint16_t  p_45);
static int32_t * func_64(uint32_t  p_65, int16_t  p_66, int32_t * p_67);
static int32_t  func_74(uint32_t  p_75);
static int32_t  func_76(const int64_t  p_77, int32_t * p_78, int32_t ** p_79, int32_t * p_80, uint8_t  p_81);
static int32_t * func_82(uint32_t  p_83, uint32_t  p_84, int64_t  p_85);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_4 g_95 g_50 g_97 g_70 g_110 g_115 g_96 g_324 g_219 g_56 g_449 g_121.f1 g_121.f3 g_121.f0 g_448 g_465 g_447 g_121.f2 g_111 g_653 g_520 g_262 g_376
 * writes: g_4 g_8 g_50 g_56 g_70 g_115 g_219 g_121.f2 g_376 g_449 g_447
 */
static int32_t  func_1(void)
{ /* block id: 0 */
    int64_t l_2 = (-5L);
    int32_t *l_3 = &g_4;
    int8_t *l_446 = &g_447;
    uint32_t l_661 = 0UL;
    (*l_3) = l_2;
    for (l_2 = (-15); (l_2 < 18); l_2 += 1)
    { /* block id: 4 */
        int64_t l_7[5][10] = {{1L,0x56EE97341720348FLL,1L,0L,1L,0L,1L,0x56EE97341720348FLL,1L,(-6L)},{0L,1L,0x56EE97341720348FLL,1L,(-6L),0xC24891023F126C7FLL,(-10L),(-3L),0x9A9B8FA48A2B8EA2LL,0x609FA85F88E10E5ELL},{0x5D9B4E94F934F545LL,5L,0xCFCE2949F4FFCF33LL,1L,0x9A9B8FA48A2B8EA2LL,(-7L),(-7L),0x9A9B8FA48A2B8EA2LL,1L,0xCFCE2949F4FFCF33LL},{(-3L),(-3L),0xE24307A329EF4A04LL,0L,5L,0xB6FEB9E9D60A2215LL,(-6L),(-1L),4L,6L},{1L,(-1L),(-10L),0x5D9B4E94F934F545LL,(-7L),4L,(-6L),0L,(-6L),4L}};
        int32_t *l_46 = &g_8[2][0];
        int32_t **l_665 = &l_3;
        int32_t ***l_664 = &l_665;
        int i, j;
        for (g_4 = 0; g_4 < 5; g_4 += 1)
        {
            for (g_8[2][0] = 0; g_8[2][0] < 10; g_8[2][0] += 1)
            {
                l_7[g_4][g_8[2][0]] = 1L;
            }
        }
        if (l_7[4][4])
        { /* block id: 6 */
            uint8_t l_39 = 0UL;
            int32_t l_321 = (-4L);
            int64_t l_322[1][4][1] = {{{0xA405F35307B5E04BLL},{0xF306726C21DDFA2FLL},{0xA405F35307B5E04BLL},{0xF306726C21DDFA2FLL}}};
            uint64_t l_323 = 0x858C5241B2535BE3LL;
            int i, j, k;
            (*l_3) = ((int16_t)func_11(func_17(g_8[2][0], ((uint32_t)(0xDCD6L != ((uint8_t)0x52L << (uint8_t)6)) % (uint32_t)g_8[2][0]), ((uint32_t)(((int8_t)l_7[2][9] * (int8_t)((g_8[2][0] <= (((((int32_t)func_33((250UL <= func_36(l_39, func_40(g_4, &g_4, l_46, g_8[2][0], (*l_3)))), (*g_96)) % (int32_t)l_39) != 0x27L) & l_321) && l_39)) && l_322[0][3][0])) ^ l_322[0][3][0]) + (uint32_t)(-3L)), g_8[0][0], l_323), l_446, l_323, g_448[3], l_446) >> (int16_t)14);
            /* statement id: 336 */
        }
        else
        { /* block id: 337 */
            if ((*l_46))
                break;
            (***l_664) = (((uint8_t)l_661 - (uint8_t)((uint8_t)((((void*)0 != l_664) == ((uint16_t)((**l_665) ^ ((-1L) < (-1L))) % (uint16_t)(*l_3))) <= g_324) << (uint8_t)((uint16_t)((int16_t)((g_50 | 0x555AL) ^ (*l_3)) - (int16_t)65526UL) - (uint16_t)(*l_3)))) ^ g_4);
        }
    }
    /* facts after for loop */
    //assert (g_115[0] == &g_121 || g_115[0] == 0);
    //assert (g_219[0] == &g_56 || g_219[0] == &g_70 || g_219[0] == &g_449 || (g_219[0] >= &g_8[0][0] && g_219[0] <= &g_8[2][1]));
    return (*l_3);
}


/* ------------------------------------------ */
/* 
 * reads : g_465 g_447 g_8 g_219 g_449 g_56 g_324 g_121.f2 g_110 g_111 g_653 g_115 g_121.f1 g_520 g_4 g_262 g_376 g_70
 * writes: g_115 g_4 g_56 g_219 g_447 g_449 g_70
 */
static int16_t  func_11(int8_t * p_12, int8_t * p_13, uint16_t  p_14, int32_t * p_15, int8_t * p_16)
{ /* block id: 205 */
    union U1 **l_450 = &g_262[2];
    union U0 **l_457 = &g_115[4];
    int64_t l_460 = 0xE652F08D15717C87LL;
    const int8_t *****l_467 = (void*)0;
    int32_t **l_509 = (void*)0;
    int8_t **l_514 = (void*)0;
    uint8_t l_550[3][8] = {{255UL,0UL,255UL,255UL,0UL,255UL,255UL,0UL},{0UL,255UL,255UL,0UL,255UL,255UL,0UL,255UL},{0UL,0UL,254UL,0UL,0UL,254UL,0UL,0UL}};
    int32_t *l_570 = &g_449;
    uint16_t l_571[3];
    int32_t *****l_656[4];
    int i, j;
    for (i = 0; i < 3; i = i + 1)
        l_571[i] = 0x54A0L;
    for (i = 0; i < 4; i = i + 1)
        l_656[i] = (void*)0;
lbl_492:
    l_450 = l_450;
    if (((uint16_t)((uint16_t)(0x19421CC5L <= ((((uint16_t)((((void*)0 == l_457) & (((0x429DL & p_14) == ((int32_t)(-1L) + (int32_t)l_460)) || ((int32_t)((int16_t)((g_465 != l_467) > l_460) * (int16_t)(-10L)) % (int32_t)0xD47B57BEL))) || l_460) >> (uint16_t)g_447) ^ 18446744073709551614UL) | 0xBDL)) + (uint16_t)l_460) << (uint16_t)g_8[0][0]))
    { /* block id: 207 */
        int8_t *****l_468 = &g_466;
        int8_t *****l_469 = (void*)0;
        int32_t l_486 = 0L;
        uint32_t l_490 = 0x03D504F6L;
        int32_t *l_506 = &g_56;
        int8_t l_515[1];
        int64_t l_527 = 0L;
        union U0 *l_598 = &g_599[5][0];
        int8_t *l_619 = &g_50;
        int32_t ***l_636 = &l_509;
        int i;
        for (i = 0; i < 1; i = i + 1)
            l_515[i] = (-1L);
        l_469 = l_468;
        /* statement id: 208 */
        assert (l_469 == &g_466);
        g_115[5] = &g_121;
        for (g_4 = (-3); (g_4 <= (-19)); g_4 -= 5)
        { /* block id: 212 */
            uint64_t l_491 = 1UL;
            volatile int32_t *l_519 = &g_520;
            int32_t *l_529 = &g_56;
            int32_t *l_627 = &g_56;
            union U1 **l_630 = &g_262[4];
            for (g_56 = (-8); (g_56 <= (-15)); g_56 -= 3)
            { /* block id: 215 */
                int8_t *****l_478 = &g_466;
                const int32_t l_485 = 7L;
                for (l_460 = 0; (l_460 < (-9)); l_460 -= 1)
                { /* block id: 218 */
                    int32_t **l_476 = &g_219[1];
                    (*l_476) = p_15;
                    for (g_447 = 2; (g_447 <= 8); g_447 += 1)
                    { /* block id: 222 */
                        int i;
                        if ((**l_476))
                            break;
                    }
                    (*p_15) = ((0L & ((!((void*)0 != l_478)) && ((int8_t)((uint64_t)((*p_13) < (((uint16_t)l_485 >> (uint16_t)(l_486 > (((-(int16_t)((uint8_t)((l_450 == l_450) == (g_324 > p_14)) >> (uint8_t)2)) || l_490) ^ 0xD820L))) && g_8[2][0])) - (uint64_t)l_491) * (int8_t)p_14))) <= 0xBD5D1643CD704922LL);
                }
                (*p_15) = (0x5E7228C7L <= 6L);
                if (l_485)
                    goto lbl_492;
            }
        }
    }
    else
    { /* block id: 329 */
        const int32_t *l_652[7][10] = {{(void*)0,&g_56,&g_56,&g_8[2][0],&g_70,&g_8[2][0],&g_56,&g_4,&g_70,&g_449},{&g_56,&g_449,&g_8[1][0],&g_56,&g_70,&g_8[2][1],&g_449,&g_8[2][1],&g_70,&g_56},{&g_70,&g_56,&g_70,(void*)0,&g_8[2][0],&g_8[2][0],&g_449,&g_8[1][0],(void*)0,&g_8[2][0]},{&g_56,&g_8[2][0],&g_449,&g_56,&g_449,(void*)0,&g_8[2][0],&g_8[1][0],&g_8[1][0],&g_8[2][0]},{&g_70,(void*)0,&g_70,&g_70,(void*)0,&g_70,&g_8[1][0],&g_8[2][1],&g_8[0][1],&g_449},{&g_449,&g_4,&g_8[1][0],&g_56,(void*)0,(void*)0,(void*)0,&g_4,&g_8[2][0],&g_56},{&g_449,&g_8[2][0],&g_56,&g_70,&g_56,&g_70,(void*)0,&g_8[2][0],&g_8[2][0],&g_449}};
        const int32_t **l_651[2];
        int i, j;
        for (i = 0; i < 2; i = i + 1)
            l_651[i] = &l_652[2][7];
        g_219[9] = func_82(g_121.f2, ((uint8_t)(&p_15 == l_651[1]) >> (uint8_t)((*g_110) != p_15)), g_653[0]);
        return g_121.f1;
    }
    (*p_15) = ((uint16_t)p_14 + (uint16_t)((g_520 || ((g_4 == (1L != ((*l_450) == (*l_450)))) > (l_656[1] != g_376))) == (p_14 && 0x03FBAA5E8267D7C4LL)));
    (*p_15) = ((uint16_t)0UL * (uint16_t)0xD4E2L);
    return g_121.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_324 g_121.f2 g_8 g_219 g_56 g_4 g_50 g_95 g_96 g_97 g_121.f1 g_121.f3 g_121.f0 g_70 g_449
 * writes: g_219 g_121.f2 g_4 g_376 g_8 g_56 g_70 g_449
 */
static int8_t * func_17(int64_t  p_18, int8_t  p_19, uint8_t  p_20, const uint8_t  p_21, int64_t  p_22)
{ /* block id: 141 */
    volatile uint32_t l_325 = 0x6BB1736FL;/* VOLATILE GLOBAL l_325 */
    int32_t *l_326 = &g_8[1][0];
    int32_t **l_327 = &g_219[1];
    int8_t l_331 = (-5L);
    int8_t **l_355[5];
    int8_t ****l_368 = &g_95;
    int8_t *****l_367 = &l_368;
    uint32_t l_388 = 0UL;
    union U1 *l_412 = (void*)0;
    int8_t *l_414 = &g_50;
    const union U0 *l_439 = &g_121;
    const union U0 **l_438[6][2] = {{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0},{(void*)0,(void*)0}};
    int i, j;
    for (i = 0; i < 5; i = i + 1)
        l_355[i] = &g_97;
    l_325 = g_324;
    (*l_327) = l_326;
    for (g_121.f2 = 0; (g_121.f2 < 18); ++g_121.f2)
    { /* block id: 146 */
        int32_t l_330 = 0x9F24EA31L;
        int8_t ****l_342 = &g_95;
        int32_t ***l_346 = &l_327;
        int32_t ****l_345 = &l_346;
        union U0 **l_437 = &g_115[6];
        if (((l_330 > l_331) & ((((*l_326) != (**l_327)) || 2L) & l_330)))
        { /* block id: 147 */
            for (g_4 = 0; (g_4 == 25); g_4 += 1)
            { /* block id: 150 */
                uint32_t l_343[6];
                uint32_t l_344 = 0x595C7453L;
                int i;
                for (i = 0; i < 6; i = i + 1)
                    l_343[i] = 0UL;
            }
            if (((uint16_t)g_50 % (uint16_t)((uint8_t)(p_21 || ((((uint16_t)(&g_110 == (*l_345)) >> (uint16_t)6) <= 0x2EL) < ((void*)0 != (*l_342)))) + (uint8_t)0xEFL)))
            { /* block id: 171 */
                g_376 = (void*)0;
                if (((void*)0 != (*l_327)))
                { /* block id: 173 */
                    return (*g_96);
                    /* statement id: 174 */
                    //assert (func_17_rv == &g_50);
                }
                else
                { /* block id: 175 */
                    (**l_327) = (****l_345);
                    for (p_22 = 0; (p_22 < (-18)); p_22 -= 2)
                    { /* block id: 179 */
                        (*l_326) = (!(-8L));
                    }
                }
            }
            else
            { /* block id: 183 */
                (**l_346) = (**l_346);
            }
        }
        else
        { /* block id: 186 */
            uint16_t l_385 = 65535UL;
            int8_t *l_413 = &l_331;
            union U1 *l_419 = &g_263[1];
            int32_t l_420 = (-1L);
            (****l_345) = (4294967295UL ^ ((~g_324) ^ ((((uint16_t)((int8_t)l_385 << (int8_t)(l_385 && g_121.f1)) % (uint16_t)(((0x0481B8D09D467D12LL <= ((uint16_t)((p_22 && ((l_388 < ((uint16_t)(**l_327) << (uint16_t)g_8[1][0])) >= 0x8DA3L)) > (*l_326)) >> (uint16_t)(***l_346))) || g_121.f3) | g_121.f1)) && 0xA9L) == (-1L))));
            for (p_20 = 0; (p_20 < 54); p_20 += 1)
            { /* block id: 190 */
                uint32_t l_403 = 6UL;
                union U1 *l_411 = &g_263[1];
                (****l_345) = ((uint16_t)(((int16_t)((uint8_t)((int8_t)(***g_95) * (int8_t)((int32_t)l_403 - (int32_t)((int32_t)(((p_20 <= (((uint8_t)(*l_326) + (uint8_t)(&l_346 != (void*)0)) > (((int8_t)((((!((l_411 != l_412) <= (0L < 0x15FCD975478798FFLL))) ^ g_8[1][1]) < p_21) & 0L) - (int8_t)(****l_345)) <= p_19))) ^ 0UL) ^ p_19) + (int32_t)4294967295UL))) % (uint8_t)0xB0L) << (int16_t)p_19) & g_4) >> (uint16_t)p_18);
                for (l_388 = 0; (l_388 <= 6); l_388 += 1)
                { /* block id: 194 */
                    return l_414;
                    /* statement id: 195 */
                    //assert (func_17_rv == &g_50);
                }
                (***l_346) = ((uint16_t)p_21 * (uint16_t)((int64_t)((l_419 != (void*)0) | g_8[2][0]) - (int64_t)0x5C681E32267AD000LL));
                return (*g_96);
                /* statement id: 198 */
                //assert (func_17_rv == &g_50);
            }
            l_420 = (-1L);
        }
        (***l_346) = ((0x8C55L == (((uint8_t)((uint8_t)((uint16_t)(((int32_t)(5UL && ((int16_t)(((g_121.f0 | (((int8_t)((int8_t)((uint32_t)(((**l_342) != (***l_367)) == (((l_437 == l_438[4][0]) ^ 1UL) & ((uint16_t)(((int32_t)((uint8_t)((***l_346) && p_20) << (uint8_t)1) - (int32_t)p_19) ^ (***l_346)) >> (uint16_t)g_50))) + (uint32_t)0xE77EDE55L) * (int8_t)g_8[0][1]) - (int8_t)0xE9L) > (**l_327))) || g_121.f3) != p_21) - (int16_t)p_20)) + (int32_t)(**l_327)) != g_8[2][0]) % (uint16_t)(**l_327)) << (uint8_t)g_121.f1) * (uint8_t)(***l_346)) && g_50)) < 0x238D1B57L);
    }
    /* facts after for loop */
    return (*g_96);
    /* statement id: 204 */
    //assert (func_17_rv == &g_50);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_33(uint64_t  p_34, int8_t * p_35)
{ /* block id: 139 */
    return p_34;
}


/* ------------------------------------------ */
/* 
 * reads : g_4
 * writes:
 */
static const int8_t  func_36(int64_t  p_37, int32_t * p_38)
{ /* block id: 73 */
    const int8_t l_137 = (-1L);
    int32_t *l_143 = &g_4;
    uint8_t l_159 = 0UL;
    uint32_t l_176 = 6UL;
    int8_t ****l_199 = &g_95;
    int32_t l_220 = 0x6CB6C500L;
    uint32_t l_291 = 18446744073709551615UL;
    uint8_t l_315 = 0x6DL;
    int32_t *l_320 = &g_4;
    return (*l_143);
}


/* ------------------------------------------ */
/* 
 * reads : g_4 g_56 g_8 g_95 g_50 g_97 g_70 g_110 g_115
 * writes: g_4 g_50 g_56 g_70 g_115
 */
static int32_t * func_40(int16_t  p_41, int32_t * p_42, int32_t * p_43, const uint32_t  p_44, uint16_t  p_45)
{ /* block id: 7 */
    int8_t *l_49 = &g_50;
    int8_t **l_48 = &l_49;
    int8_t ***l_47 = &l_48;
    int32_t l_57[10][4][6] = {{{0xB46DFF61L,1L,2L,1L,0xBA057618L,0x3F992CE4L},{0xBA057618L,0xC51C80F8L,0x7DCAF6DDL,0xC51C80F8L,0xBA057618L,0xB3A3C3A8L},{(-2L),1L,8L,(-2L),0xC51C80F8L,2L},{0x2BFFD659L,0xBB358509L,0xBB11FE8BL,1L,0xBB358509L,2L}},{{(-2L),1L,8L,0xBA057618L,0x2BFFD659L,0xB3A3C3A8L},{0xBB358509L,(-2L),0x7DCAF6DDL,0x2BFFD659L,0x55EA0D0AL,0x3F992CE4L},{0xBB358509L,0x9496125BL,2L,0xBA057618L,0xF7CB2C1DL,0xA9EE2B40L},{(-2L),0x2BFFD659L,0xB7CB4D62L,1L,1L,0xB7CB4D62L}},{{0x2BFFD659L,0x2BFFD659L,0x4C660729L,(-2L),0xF7CB2C1DL,0xBB11FE8BL},{(-2L),0x9496125BL,(-7L),0xC51C80F8L,0x55EA0D0AL,0x4C660729L},{0xBA057618L,(-2L),(-7L),1L,0x2BFFD659L,0xBB11FE8BL},{0xB46DFF61L,1L,0x4C660729L,0x892F88B3L,0xBB358509L,0xB7CB4D62L}},{{0x892F88B3L,0xBB358509L,0xB7CB4D62L,0x892F88B3L,0xC51C80F8L,0xA9EE2B40L},{0xB46DFF61L,1L,2L,1L,0xBA057618L,0x3F992CE4L},{0xBA057618L,0xC51C80F8L,0x7DCAF6DDL,0xC51C80F8L,0xBA057618L,0xB3A3C3A8L},{(-2L),1L,8L,(-2L),0xC51C80F8L,2L}},{{0x2BFFD659L,0xBB358509L,0xBB11FE8BL,1L,0xBB358509L,2L},{(-2L),1L,8L,0xBA057618L,0x2BFFD659L,0xB3A3C3A8L},{0xBB358509L,(-2L),0x7DCAF6DDL,0x2BFFD659L,0x55EA0D0AL,0x3F992CE4L},{0xBB358509L,0x9496125BL,2L,0xBA057618L,0xF7CB2C1DL,0xA9EE2B40L}},{{(-2L),0x2BFFD659L,0xB7CB4D62L,1L,1L,0xB7CB4D62L},{0x2BFFD659L,0x2BFFD659L,0x4C660729L,(-2L),0xF7CB2C1DL,0xBB11FE8BL},{(-2L),0x9496125BL,(-7L),0xC51C80F8L,0x55EA0D0AL,0x4C660729L},{0xBA057618L,(-2L),(-7L),1L,0x2BFFD659L,0xBB11FE8BL}},{{0xB46DFF61L,1L,0x4C660729L,0x892F88B3L,0xBB358509L,0xB7CB4D62L},{0x892F88B3L,0xBB358509L,0xB7CB4D62L,0x892F88B3L,0xC51C80F8L,0xA9EE2B40L},{0xB46DFF61L,1L,2L,1L,0xBA057618L,0x3F992CE4L},{0xBA057618L,0xC51C80F8L,0x7DCAF6DDL,0xC51C80F8L,0xBA057618L,0xB3A3C3A8L}},{{(-2L),1L,8L,0x77355A2CL,0L,0xC51C80F8L},{(-7L),0L,0xBB358509L,5L,0L,0xC51C80F8L},{0x77355A2CL,0xFE4D3D82L,0x55EA0D0AL,(-1L),(-7L),0xF7CB2C1DL},{0L,0x17913DA5L,0xB46DFF61L,(-7L),0xD15778C4L,(-2L)}},{{0L,0xFC796D63L,0xC51C80F8L,(-1L),0x253E45BDL,0x9496125BL},{0x77355A2CL,(-7L),0x892F88B3L,5L,5L,0x892F88B3L},{(-7L),(-7L),(-2L),0x77355A2CL,0x253E45BDL,0xBB358509L},{0x17913DA5L,0xFC796D63L,1L,0L,0xD15778C4L,(-2L)}},{{(-1L),0x17913DA5L,1L,0xFE4D3D82L,(-7L),0xBB358509L},{0x39A3A415L,0xFE4D3D82L,(-2L),8L,0L,0x892F88B3L},{8L,0L,0x892F88B3L,8L,0L,0x9496125BL},{0x39A3A415L,5L,0xC51C80F8L,0xFE4D3D82L,(-1L),(-2L)}}};
    int32_t *l_61 = &l_57[4][0][1];
    int i, j, k;
    (*l_47) = (void*)0;
    /* statement id: 8 */
    assert (l_48 == 0);
    for (g_4 = 0; (g_4 >= 21); g_4 += 1)
    { /* block id: 11 */
        for (g_50 = 7; (g_50 != 7); g_50 += 4)
        { /* block id: 14 */
            int32_t *l_55[1][1];
            int32_t *l_73 = &l_57[9][2][4];
            int i, j;
            for (i = 0; i < 1; i = i + 1)
            {
                for (j = 0; j < 1; j = j + 1)
                    l_55[i][j] = &g_56;
            }
            l_57[9][2][4] = 0x22C08F49L;
            for (p_41 = (-29); (p_41 >= 0); p_41 += 1)
            { /* block id: 18 */
                int32_t **l_60[9][3] = {{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]},{&l_55[0][0],&l_55[0][0],&l_55[0][0]}};
                int8_t ***l_68 = (void*)0;
                int i, j;
                for (p_45 = 0; (p_45 <= 3); p_45 += 1)
                { /* block id: 21 */
                    for (g_56 = 0; (g_56 >= 0); g_56 -= 1)
                    { /* block id: 24 */
                        return p_43;
                        /* statement id: 25 */
                        //assert ((func_40_rv >= &g_8[0][0] && func_40_rv <= &g_8[2][1]));
                    }
                }
                l_61 = (void*)0;
                /* statement id: 28 */
                assert (l_61 == 0);
                for (g_56 = 9; (g_56 == (-8)); g_56 -= 9)
                { /* block id: 31 */
                    l_73 = func_64(p_41, (((void*)0 == l_68) | g_4), &g_56);
                    /* statement id: 37 */
                    assert (l_73 == &g_4);
                    return &g_4;
                    /* statement id: 38 */
                    //assert (func_40_rv == &g_4);
                }
                (*l_73) = func_74(g_8[2][0]);
            }
        }
        l_57[9][2][4] = (-(int32_t)((int32_t)(*p_42) + (int32_t)g_50));
    }
    /* facts after for loop */
    assert (l_61 == 0 || (l_61 >= &l_57[0][0][0] && l_61 <= &l_57[9][3][5]));
    return &g_56;
    /* statement id: 72 */
    //assert (func_40_rv == &g_56);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes: g_70
 */
static int32_t * func_64(uint32_t  p_65, int16_t  p_66, int32_t * p_67)
{ /* block id: 32 */
    int32_t *l_69[6] = {&g_4,&g_4,&g_4,&g_4,&g_4,&g_4};
    uint8_t l_71 = 0x3AL;
    int32_t **l_72 = &l_69[0];
    int i;
    g_70 = 1L;
    l_71 = (-1L);
    (*l_72) = l_69[0];
    return &g_4;
    /* statement id: 36 */
    //assert (func_64_rv == &g_4);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_95 g_50 g_97 g_70 g_110 g_115 g_4
 * writes: g_70 g_115 g_56
 */
static int32_t  func_74(uint32_t  p_75)
{ /* block id: 40 */
    int8_t *l_89 = &g_50;
    const int32_t l_90 = (-1L);
    int32_t *l_123 = &g_4;
    int32_t **l_122[2];
    int8_t ***l_125 = &g_96;
    int i;
    for (i = 0; i < 2; i = i + 1)
        l_122[i] = &l_123;
    g_56 = func_76(p_75, func_82(p_75, ((uint8_t)((-(uint16_t)(&g_50 == l_89)) <= g_8[2][0]) * (uint8_t)l_90), (-(int16_t)((~(((((uint16_t)((((void*)0 == g_95) > ((uint16_t)((uint8_t)((uint32_t)((int16_t)p_75 % (int16_t)g_50) % (uint32_t)g_8[1][0]) * (uint8_t)(*g_97)) << (uint16_t)l_90)) != l_90) >> (uint16_t)p_75) != 0xD15494F3L) || g_70) & p_75)) >= p_75))), l_122[0], &g_8[2][1], (*l_123));
    g_56 = (&g_96 != l_125);
    g_56 = p_75;
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_76(const int64_t  p_77, int32_t * p_78, int32_t ** p_79, int32_t * p_80, uint8_t  p_81)
{ /* block id: 61 */
    uint64_t l_124 = 0x2EDB36A152264B8ELL;
    return l_124;
}


/* ------------------------------------------ */
/* 
 * reads : g_70 g_110 g_115
 * writes: g_70 g_115
 */
static int32_t * func_82(uint32_t  p_83, uint32_t  p_84, int64_t  p_85)
{ /* block id: 41 */
    int64_t l_112 = 1L;
    union U0 **l_116 = (void*)0;
    union U0 **l_117 = &g_115[6];
    for (p_83 = (-4); (p_83 >= 30); ++p_83)
    { /* block id: 44 */
        const int32_t *l_108[7] = {&g_8[2][0],&g_8[2][0],&g_8[2][0],&g_8[2][0],&g_8[2][0],&g_8[2][0],&g_8[2][0]};
        const int32_t *l_109 = &g_70;
        int8_t ****l_113[7][9] = {{(void*)0,(void*)0,&g_95,(void*)0,(void*)0,(void*)0,(void*)0,&g_95,(void*)0},{(void*)0,&g_95,&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95,&g_95},{(void*)0,(void*)0,(void*)0,&g_95,(void*)0,(void*)0,(void*)0,(void*)0,&g_95},{(void*)0,&g_95,(void*)0,(void*)0,(void*)0,(void*)0,&g_95,(void*)0,(void*)0},{(void*)0,(void*)0,(void*)0,(void*)0,&g_95,(void*)0,(void*)0,(void*)0,(void*)0},{(void*)0,(void*)0,&g_95,(void*)0,(void*)0,(void*)0,(void*)0,&g_95,(void*)0},{(void*)0,&g_95,&g_95,&g_95,&g_95,(void*)0,&g_95,&g_95,&g_95}};
        int i, j;
        l_109 = l_108[0];
        /* statement id: 45 */
        assert (l_109 == &g_70 || (l_109 >= &g_8[0][0] && l_109 <= &g_8[2][1]));
        for (g_70 = 5; (g_70 >= 0); g_70 -= 1)
        { /* block id: 48 */
            int8_t *****l_114 = &l_113[4][5];
            l_112 = (g_110 != (void*)0);
            (*l_114) = l_113[4][5];
        }
    }
    (*l_117) = g_115[4];
    for (p_83 = 0; (p_83 < 4); ++p_83)
    { /* block id: 56 */
        union U0 *l_120 = &g_121;
        l_120 = g_115[3];
        /* statement id: 57 */
        assert (l_120 == 0 || l_120 == &g_121);
        return &g_70;
        /* statement id: 58 */
        //assert (func_82_rv == &g_70);
    }
    return &g_56;
    /* statement id: 60 */
    //assert (func_82_rv == &g_56);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j;
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_4, "g_4", print_hash_value);
    for (i = 0; i < 3; i = i + 1)
    {
        for (j = 0; j < 2; j = j + 1)
        {
            transparent_crc(g_8[i][j], "g_8[i][j]", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_50, "g_50", print_hash_value);
    transparent_crc(g_56, "g_56", print_hash_value);
    transparent_crc(g_70, "g_70", print_hash_value);
    transparent_crc(g_121.f0, "g_121.f0", print_hash_value);
    transparent_crc(g_324, "g_324", print_hash_value);
    transparent_crc(g_447, "g_447", print_hash_value);
    transparent_crc(g_449, "g_449", print_hash_value);
    transparent_crc(g_520, "g_520", print_hash_value);
    for (i = 0; i < 8; i = i + 1)
    {
        for (j = 0; j < 6; j = j + 1)
        {
            transparent_crc(g_599[i][j].f0, "g_599[i][j].f0", print_hash_value);
            if (print_hash_value) printf("index = [%d][%d]\n", i, j);

        }
    }
    transparent_crc(g_625, "g_625", print_hash_value);
    for (i = 0; i < 3; i = i + 1)
    {
        transparent_crc(g_653[i], "g_653[i]", print_hash_value);
        if (print_hash_value) printf("index = [%d]\n", i);

    }
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 135
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 1
XXX structs with bitfields in the program: 8
breakdown:
   indirect level: 0, occurrence: 0
   indirect level: 1, occurrence: 5
   indirect level: 2, occurrence: 3
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 5
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 1
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 85
   depth: 2, occurrence: 26
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 14, occurrence: 1
   depth: 17, occurrence: 2
   depth: 18, occurrence: 1
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 28, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 131

XXX times a variable address is taken: 228
XXX times a pointer is dereferenced on RHS: 122
breakdown:
   depth: 1, occurrence: 90
   depth: 2, occurrence: 16
   depth: 3, occurrence: 13
   depth: 4, occurrence: 3
XXX times a pointer is dereferenced on LHS: 64
breakdown:
   depth: 1, occurrence: 52
   depth: 2, occurrence: 5
   depth: 3, occurrence: 4
   depth: 4, occurrence: 3
XXX times a pointer is compared with null: 37
XXX times a pointer is compared with address of another variable: 15
XXX times a pointer is compared with another pointer: 12
XXX times a pointer is qualified to be dereferenced: 688

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 332
   level: 2, occurrence: 73
   level: 3, occurrence: 52
   level: 4, occurrence: 12
XXX number of pointers point to pointers: 70
XXX number of pointers point to scalars: 51
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 25.2
XXX average alias set size: 1.42

XXX times a non-volatile is read: 724
XXX times a non-volatile is write: 224
XXX times a volatile is read: 12
XXX    times read thru a pointer: 1
XXX times a volatile is write: 1
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 334
XXX percentage of non-volatile access: 98.6

XXX forward jumps: 0
XXX backward jumps: 6

XXX stmts: 85
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 15
   depth: 2, occurrence: 13
   depth: 3, occurrence: 14
   depth: 4, occurrence: 10
   depth: 5, occurrence: 3

XXX percentage a fresh-made variable is used: 18.6
XXX percentage an existing variable is used: 81.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

