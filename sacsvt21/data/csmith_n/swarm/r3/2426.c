/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      2173766584
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint32_t  f1;
   int32_t  f2;
   uint32_t  f3;
   int64_t  f4;
   int32_t  f5;
   int16_t  f6;
};

union U2 {
   uint64_t  f0;
   struct S0  f1;
   struct S0  f2;
   int16_t  f3;
   int64_t  f4;
};

union U3 {
   int32_t  f0;
   int32_t  f1;
   int64_t  f2;
   struct S0  f3;
   int16_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_1(void);
static int32_t * func_2(int8_t * p_3, union U3  p_4, uint64_t  p_5);
static union U3  func_7(int32_t  p_8, int8_t * p_9);
static uint16_t  func_23(uint16_t  p_24, int16_t  p_25, uint32_t  p_26, int32_t  p_27);
static uint16_t  func_30(int8_t  p_31);
static int64_t  func_32(union U2 * p_33, union U2 ** p_34, uint32_t  p_35);
static union U2 ** func_38(int16_t  p_39, struct S0 * p_40, union U2 ** p_41, struct S0  p_42, union U3  p_43);
static struct S0 * func_45(union U2 ** p_46, int32_t  p_47, int32_t  p_48);
static int16_t  func_53(union U2  p_54, uint32_t  p_55);
static struct S0  func_57(struct S0 * p_58, int64_t  p_59, int8_t * p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_1(void)
{ /* block id: 0 */
    int8_t *l_6 = (void*)0;
    int32_t l_10 = 0L;
    int32_t *l_225 = &l_10;
    int32_t **l_224 = &l_225;
    union U2 l_243 = {0UL};
    union U2 *l_242 = &l_243;
    union U2 **l_241 = &l_242;
    struct S0 l_245 = {0x9B6CL,0x735A5136L,0x2929A0D0L,0x3A199CE5L,0xD471ECD5911529E7LL,0x32A7BFF7L,0xC213L};
    int32_t *l_246 = &l_10;
    uint32_t l_247 = 4294967292UL;
    (*l_224) = func_2(l_6, func_7(l_10, l_6), l_10);
    /* statement id: 76 */
    assert (l_225 == 0);
    for (l_10 = (-23); (l_10 != (-3)); l_10 = safe_add_func_uint32_t_u_u(l_10, 1))
    { /* block id: 79 */
        struct S0 l_228 = {3L,0UL,0x4A638292L,4294967288UL,5L,0x1B58F1CDL,-1L};
        struct S0 *l_229 = &l_228;
        int16_t l_235 = 0x91CDL;
        (*l_229) = l_228;
        for (l_228.f6 = 4; (l_228.f6 >= (-4)); --l_228.f6)
        { /* block id: 83 */
            uint64_t l_234 = 2UL;
            union U2 **l_236 = (void*)0;
            int32_t *l_244 = &l_243.f1.f5;
            for (l_228.f3 = 0; (l_228.f3 <= 54); l_228.f3 = safe_add_func_int32_t_s_s(l_228.f3, 1))
            { /* block id: 86 */
                if (l_234)
                    break;
            }
            if (l_235)
                break;
            (*l_244) = (l_236 != ((safe_sub_func_uint16_t_u_u((safe_sub_func_int32_t_s_s(1L, l_228.f2)), l_228.f3)) , l_241));
        }
        (*l_229) = l_245;
    }
    (*l_246) = l_245.f6;
    return l_247;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_2(int8_t * p_3, union U3  p_4, uint64_t  p_5)
{ /* block id: 8 */
    union U2 l_37 = {0x298C245E320525C7LL};
    union U2 *l_36 = &l_37;
    uint16_t l_44 = 0UL;
    union U2 **l_175 = &l_36;
    struct S0 l_176 = {0x41B1L,4294967295UL,-6L,0x213F8C49L,0L,0x0DCD2CF2L,0L};
    union U3 l_177 = {-1L};
    int32_t *l_207 = &l_176.f2;
    int32_t *l_219 = &l_177.f1;
    int32_t *l_220 = &l_177.f0;
    int32_t *l_222 = &l_176.f5;
    int32_t *l_223 = (void*)0;
    for (p_4.f3.f2 = 0; (p_4.f3.f2 > 17); p_4.f3.f2 = safe_add_func_uint64_t_u_u(p_4.f3.f2, 7))
    { /* block id: 11 */
        struct S0 l_19 = {8L,0xE856DFC9L,-1L,4294967295UL,0x086335C0DE450BB1LL,0L,-1L};
        struct S0 *l_20 = &l_19;
        int32_t *l_21 = (void*)0;
        int32_t **l_22 = &l_21;
        (*l_20) = l_19;
        (*l_22) = l_21;
    }
    p_4.f3.f5 = 5L;
    (*l_207) = ((p_4.f1 ^ ((func_23((safe_lshift_func_uint16_t_u_s(func_30((func_32(l_36, func_38(l_44, func_45(&l_36, l_44, l_37.f3), l_175, l_176, l_177), p_5) >= 0x36850D544D09D3C4LL)), l_176.f2)), l_176.f3, l_176.f2, l_176.f2) >= p_4.f0) > l_44)) | l_176.f4);
    if (((((((p_4.f0 & p_4.f1) >= ((p_4 , &l_176) == ((((((*l_207) , (*l_36)) , (safe_div_func_uint16_t_u_u(((~(-1L)) && (safe_lshift_func_int16_t_s_s(p_4.f1, ((safe_mod_func_uint16_t_u_u(((*l_207) < (*l_207)), (*l_207))) == (*l_207))))), (*l_207)))) || (*l_207)) && (*l_207)) , &l_176))) <= (*l_207)) && 9UL) == (*l_207)) & 0x64E2L))
    { /* block id: 69 */
        uint32_t l_217 = 0xE9B9FB79L;
        (*l_207) = 0L;
        (*l_207) = (safe_mod_func_uint32_t_u_u(1UL, ((l_217 | (-1L)) , (-1L))));
    }
    else
    { /* block id: 72 */
        int32_t *l_218 = &l_176.f2;
        int32_t *l_221 = (void*)0;
        return l_221;
        /* statement id: 73 */
        //assert (func_2_rv == 0);
    }
    return l_223;
    /* statement id: 75 */
    //assert (func_2_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U3  func_7(int32_t  p_8, int8_t * p_9)
{ /* block id: 1 */
    union U3 l_16 = {0xCDF9C775L};
    for (p_8 = 0; (p_8 > (-19)); p_8--)
    { /* block id: 4 */
        union U2 l_14 = {5UL};
        union U2 *l_13 = &l_14;
        union U2 **l_15 = &l_13;
        (*l_15) = l_13;
    }
    return l_16;
    /* statement id: 7 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_23(uint16_t  p_24, int16_t  p_25, uint32_t  p_26, int32_t  p_27)
{ /* block id: 65 */
    int32_t l_206 = 1L;
    int32_t *l_205 = &l_206;
    int32_t **l_204 = &l_205;
    (*l_204) = (p_24 , &p_27);
    /* statement id: 66 */
    assert (l_205 == &p_27);
    return p_24;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_30(int8_t  p_31)
{ /* block id: 61 */
    uint32_t l_192 = 7UL;
    int32_t l_201 = 0L;
    int32_t *l_200 = &l_201;
    struct S0 l_202 = {1L,0xBE2B852CL,0x7C837AE3L,1UL,-4L,0x96C44C6DL,-4L};
    struct S0 *l_203 = &l_202;
    (*l_200) = (((0x91DAL | l_192) == (safe_lshift_func_int16_t_s_u(((l_192 >= l_192) & p_31), (0L >= (~l_192))))) == (safe_rshift_func_uint16_t_u_u(0xA32CL, (safe_add_func_int16_t_s_s(l_192, l_192)))));
    (*l_203) = l_202;
    return p_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_32(union U2 * p_33, union U2 ** p_34, uint32_t  p_35)
{ /* block id: 58 */
    struct S0 l_189 = {0L,0x87D8A3BBL,0x813AB97BL,4294967295UL,0x77D6962B2ED70B56LL,0xAF5395DFL,0x6A07L};
    struct S0 *l_188 = &l_189;
    int32_t *l_190 = (void*)0;
    int32_t *l_191 = &l_189.f2;
    (*l_191) = (((safe_unary_minus_func_uint64_t_u(((!((safe_mod_func_uint16_t_u_u(((((void*)0 == l_188) , (p_35 <= l_189.f1)) & (((p_35 ^ 0UL) > p_35) , ((0xE25E85E3D3FF892FLL == 0xD7D783D8B8248823LL) > 0x59E8EBB9L))), 0x43E8L)) >= p_35)) & p_35))) >= 0x4DA6L) && 0x744938FFB32E1920LL);
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static union U2 ** func_38(int16_t  p_39, struct S0 * p_40, union U2 ** p_41, struct S0  p_42, union U3  p_43)
{ /* block id: 54 */
    struct S0 l_179 = {0xDF83L,0x37CEF4F5L,-10L,0UL,0xC8D4623137507154LL,0x7D523876L,0xAC07L};
    struct S0 *l_178 = &l_179;
    int8_t l_181 = 0x3BL;
    int8_t *l_180 = &l_181;
    int32_t *l_182 = &l_179.f2;
    int32_t **l_183 = &l_182;
    (*l_178) = func_57(l_178, l_179.f5, l_180);
    (*l_183) = l_182;
    return p_41;
    /* statement id: 57 */
    //assert (func_38_rv == &l_36);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0 * func_45(union U2 ** p_46, int32_t  p_47, int32_t  p_48)
{ /* block id: 16 */
    int32_t l_50 = 0L;
    union U2 l_56 = {1UL};
    struct S0 l_164 = {1L,1UL,-1L,0UL,0xC2A9FDAC8820D8B5LL,1L,-1L};
    struct S0 *l_163 = &l_164;
    struct S0 **l_166 = (void*)0;
    struct S0 ***l_165 = &l_166;
    uint32_t l_167 = 1UL;
    struct S0 *l_172 = &l_164;
    struct S0 *l_173 = &l_164;
    struct S0 *l_174 = (void*)0;
    if ((((~(l_50 <= ((safe_rshift_func_uint16_t_u_s((func_53(l_56, p_48) == (l_56 , (l_163 == &l_164))), ((l_165 != (void*)0) , (-5L)))) , 0x1872L))) & l_167) < l_56.f0))
    { /* block id: 46 */
        int32_t *l_168 = &l_50;
        int32_t **l_169 = &l_168;
        int32_t ***l_170 = &l_169;
        (*l_169) = l_168;
        (**l_169) = p_48;
        (*l_170) = &l_168;
    }
    else
    { /* block id: 50 */
        struct S0 *l_171 = (void*)0;
        return l_171;
        /* statement id: 51 */
        //assert (func_45_rv == 0);
    }
    return l_174;
    /* statement id: 53 */
    //assert (func_45_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int16_t  func_53(union U2  p_54, uint32_t  p_55)
{ /* block id: 17 */
    struct S0 *l_61 = (void*)0;
    union U2 l_62 = {0x351F4A1AB70486D4LL};
    union U3 l_71 = {-9L};
    union U2 *l_73 = &l_62;
    union U2 **l_72 = &l_73;
    int8_t l_75 = 0x04L;
    int8_t *l_74 = &l_75;
    struct S0 *l_162 = &l_62.f1;
    (*l_162) = func_57(l_61, ((((l_62 , ((l_62.f4 || p_54.f4) && ((((safe_div_func_uint64_t_u_u((0L ^ ((safe_mod_func_uint32_t_u_u(((safe_mod_func_int32_t_s_s((safe_div_func_int16_t_s_s((l_71 , p_55), p_54.f4)), p_55)) < 0L), p_54.f0)) != l_71.f1)), 0xACF1929B4DB59FB1LL)) , l_71.f0) >= p_54.f3) | l_62.f0))) , l_72) != &l_73) & l_71.f4), l_74);
    /* statement id: 44 */
        return p_54.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_57(struct S0 * p_58, int64_t  p_59, int8_t * p_60)
{ /* block id: 18 */
    int32_t l_88 = 0x402E8398L;
    int32_t *l_91 = (void*)0;
    int16_t l_92 = 0L;
    union U2 l_95 = {18446744073709551614UL};
    union U2 *l_94 = &l_95;
    uint64_t l_97 = 18446744073709551612UL;
    struct S0 l_112 = {5L,4294967295UL,8L,4294967287UL,-9L,0x9346F960L,0x3385L};
    struct S0 *l_116 = &l_112;
    struct S0 **l_115 = &l_116;
    int32_t **l_118 = &l_91;
    union U2 **l_120 = &l_94;
    union U2 ***l_119 = &l_120;
    int32_t *l_127 = &l_112.f2;
    int8_t *l_149 = (void*)0;
    struct S0 l_161 = {-5L,0x26D052D8L,2L,0xD17D95D1L,0xD180367A8BF02E39LL,-6L,0L};
    if ((safe_add_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((18446744073709551609UL >= ((safe_div_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u((((safe_div_func_uint64_t_u_u(p_59, (safe_add_func_int32_t_s_s(l_88, (p_59 >= (p_59 > (l_91 != (p_59 , (l_92 , l_91))))))))) <= p_59) ^ p_59), l_88)), (-7L))) & p_59)), l_88)), 0x6AF7L)))
    { /* block id: 19 */
        int32_t *l_96 = &l_95.f1.f5;
        (*l_96) = (safe_unary_minus_func_uint32_t_u(((void*)0 == l_94)));
    }
    else
    { /* block id: 21 */
        int16_t l_108 = 0xE41AL;
        struct S0 l_111 = {0x5A1CL,0UL,0L,0x852BC533L,0x0B76A7FFA3025762LL,0xAE825D0DL,0x0074L};
        struct S0 ***l_117 = (void*)0;
        if (l_97)
        { /* block id: 22 */
            struct S0 l_100 = {0xB9DAL,0UL,7L,0x3A71B0FAL,-6L,0xFF6DE5F4L,0xC719L};
            struct S0 *l_99 = &l_100;
            struct S0 **l_98 = &l_99;
            int8_t *l_107 = (void*)0;
            int32_t **l_109 = &l_91;
            int32_t *l_110 = &l_100.f5;
            (*l_98) = p_58;
            /* statement id: 23 */
            //assert (l_99 == 0 || l_99 == &l_179);
            l_108 = (safe_rshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_s(((1UL == 1UL) & (0xB333L != ((safe_lshift_func_int16_t_s_s(((void*)0 != l_107), 5)) ^ (p_59 > l_100.f6)))), 12)), 14));
            (*l_109) = l_91;
            (*l_110) = p_59;
        }
        else
        { /* block id: 27 */
            struct S0 *l_113 = (void*)0;
            struct S0 l_114 = {-1L,6UL,0x4D2AC322L,0xD8CF631BL,0xFDDB278982BF9DFFLL,0L,0xBACEL};
            l_114 = (l_111 , l_112);
            return l_111;
        }
        l_115 = l_115;
    }
    (*l_118) = l_91;
    (*l_119) = &l_94;
    if (((8L ^ (safe_div_func_uint64_t_u_u(((void*)0 != &l_115), p_59))) | p_59))
    { /* block id: 35 */
        uint32_t l_123 = 0x799B5C0FL;
        int8_t l_126 = 0x21L;
        (*l_118) = (*l_118);
        (*l_116) = ((((l_123 == 0L) < ((void*)0 != (*l_118))) , (safe_mod_func_int32_t_s_s(l_123, l_126))) , (**l_115));
    }
    else
    { /* block id: 38 */
        int32_t *l_128 = &l_95.f2.f5;
        struct S0 l_130 = {7L,0xBF928973L,0xA75DB762L,0x6065F2B7L,0x8FFD6E93423A3813LL,1L,0xC1B6L};
        union U2 *l_158 = (void*)0;
        l_128 = l_127;
        /* statement id: 39 */
        assert (l_128 == &l_112.f2);
        (*l_127) = (~((0L >= ((l_130 , (safe_mod_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((safe_unary_minus_func_uint16_t_u(0xA4FEL)), 15)), ((((((safe_unary_minus_func_uint32_t_u((safe_add_func_int64_t_s_s((safe_add_func_uint64_t_u_u((3UL == ((*l_127) < (p_59 < (safe_rshift_func_int16_t_s_s(4L, (*l_128)))))), (safe_add_func_uint16_t_u_u(((safe_sub_func_uint64_t_u_u((safe_mod_func_int32_t_s_s(((void*)0 != &l_128), p_59)), 0xC177FA41F08C6B94LL)) == p_59), (*l_128))))), 0x6E4AE6EC67F3A6B8LL)))) == p_59) <= p_59) >= 0x9615L) & 1L) | 9UL)))) <= p_59)) <= p_59));
        (*l_127) = (((**l_115) , ((((p_60 != l_149) ^ (safe_lshift_func_int16_t_s_u((safe_sub_func_int32_t_s_s((safe_lshift_func_int16_t_s_u((safe_div_func_uint64_t_u_u(p_59, 0x46866101610A321FLL)), ((void*)0 != l_158))), p_59)), 6))) == ((((safe_rshift_func_int16_t_s_s((((void*)0 != (*l_115)) , p_59), p_59)) , (*l_127)) <= p_59) == 0xC28CL)) || p_59)) > 65526UL);
    }
    return l_161;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 55
   depth: 1, occurrence: 10
XXX total union variables: 5

XXX max expression depth: 23
breakdown:
   depth: 1, occurrence: 73
   depth: 2, occurrence: 8
   depth: 4, occurrence: 2
   depth: 5, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 1
   depth: 10, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 1
   depth: 18, occurrence: 1
   depth: 20, occurrence: 1
   depth: 21, occurrence: 1
   depth: 23, occurrence: 2

XXX total number of pointers: 77

XXX times a variable address is taken: 62
XXX times a pointer is dereferenced on RHS: 20
breakdown:
   depth: 1, occurrence: 18
   depth: 2, occurrence: 2
XXX times a pointer is dereferenced on LHS: 31
breakdown:
   depth: 1, occurrence: 30
   depth: 2, occurrence: 1
XXX times a pointer is compared with null: 9
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 146

XXX max dereference level: 2
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 65
   level: 2, occurrence: 16
XXX number of pointers point to pointers: 24
XXX number of pointers point to scalars: 29
XXX number of pointers point to structs: 17
XXX percent of pointers has null in alias set: 28.6
XXX average alias set size: 1.04

XXX times a non-volatile is read: 211
XXX times a non-volatile is write: 73
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 61
XXX max block depth: 3
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 21
   depth: 2, occurrence: 9
   depth: 3, occurrence: 1

XXX percentage a fresh-made variable is used: 20.9
XXX percentage an existing variable is used: 79.1
********************* end of statistics **********************/

