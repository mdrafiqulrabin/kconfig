/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --longlong --int8 --no-uint8 --no-float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      489123164
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   unsigned f0 : 28;
   int32_t  f1;
   const int16_t  f2;
   signed f3 : 16;
   uint32_t  f4;
   int8_t  f5;
   signed f6 : 18;
};

union U1 {
   signed f0 : 8;
   uint16_t  f1;
   const int8_t  f2;
   int32_t  f3;
   uint32_t  f4;
};

union U2 {
   const int32_t  f0;
};

union U3 {
   const int32_t  f0;
   const uint16_t  f1;
   uint16_t  f2;
   const signed f3 : 3;
   uint32_t  f4;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static union U3  func_30(void);
inline static int32_t  func_46(const uint16_t  p_47, int16_t * p_48, int16_t * p_49, struct S0  p_50, int32_t  p_51);
inline static uint16_t  func_52(int16_t * p_53, int32_t  p_54, uint16_t  p_55, union U2  p_56);
inline static int16_t * func_57(const union U1  p_58, int32_t  p_59, int32_t  p_60, union U3  p_61, int16_t * p_62);
static int32_t  func_64(union U3  p_65, uint32_t  p_66, const int16_t  p_67, const uint32_t  p_68, uint32_t  p_69);
inline static uint16_t  func_75(uint32_t  p_76, const int16_t  p_77);
inline static int32_t  func_78(union U2  p_79, struct S0  p_80, int32_t  p_81, struct S0  p_82);
inline static union U2  func_83(struct S0  p_84, union U2  p_85);
static uint32_t  func_92(int16_t * p_93, struct S0  p_94, const int16_t * p_95, int16_t * p_96, uint32_t  p_97);
inline static int16_t * func_98(int16_t * p_99, union U1  p_100, int16_t * const  p_101, uint16_t  p_102);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U3  func_30(void)
{ /* block id: 36 */
    int32_t l_31 = 7L;
    struct S0 l_86 = {12934,0x6A6C3430L,-9L,-165,4294967288UL,0L,-209};
    int16_t l_2054 = (-7L);
    int16_t *l_2053 = &l_2054;
    int16_t **l_2126 = &l_2053;
    int16_t ***l_2125 = &l_2126;
    int16_t ****l_2124 = &l_2125;
    uint16_t l_2129 = 65535UL;
    union U3 l_2134 = {0x2D14FC7AL};
    union U2 l_2148 = {0xDD4B001DL};
    union U2 *l_2147 = &l_2148;
    union U2 **l_2146 = &l_2147;
    for (l_31 = 21; (l_31 >= 11); l_31 -= 1)
    { /* block id: 39 */
        int32_t l_34 = 0x2B058EFAL;
        const union U1 l_63 = {0x44BD1A6FL};
        union U2 l_87 = {1L};
        union U3 l_2018 = {0x2AC723CCL};
        int16_t *l_2052 = (void*)0;
        uint16_t l_2102 = 0x1856L;
        uint16_t *l_2101 = &l_2102;
        int32_t *l_2103 = &l_34;
        int32_t l_2105 = 0xEE3DA6EEL;
        int32_t *l_2104 = &l_2105;
        union U3 *l_2112 = (void*)0;
        union U3 **l_2111 = &l_2112;
        for (l_34 = 0; (l_34 != 25); l_34 += 1)
        { /* block id: 42 */
            int16_t l_44 = 0x943EL;
            int16_t *l_45 = &l_44;
            union U3 l_70 = {1L};
            struct S0 l_310 = {12847,4L,0xF44CL,55,0x263576A0L,1L,-217};
            int32_t l_1972 = 0xCD57058FL;
            int32_t *l_1971 = &l_1972;
            uint32_t l_2011 = 8UL;
            uint32_t *l_2010 = &l_2011;
            union U2 l_2024 = {0L};
            l_86.f3 = ((((int16_t)l_34 + (int16_t)((int32_t)(0UL < ((uint16_t)l_31 % (uint16_t)((*l_45) = ((!7L) || l_44)))) + (int32_t)func_46(func_52(func_57(l_63, l_31, func_64(l_70, ((*l_2010) = (((uint16_t)(((uint16_t)func_75(((((*l_1971) |= func_78(func_83(l_86, l_87), l_310, l_70.f2, l_310)) | l_86.f2) >= l_86.f0), l_86.f5) >> (uint16_t)3) != l_86.f2) >> (uint16_t)4) >= 4294967295UL)), l_86.f4, l_63.f0, l_31), l_2018, l_45), l_31, l_86.f5, l_2024), l_2052, l_2053, l_86, l_63.f0))) ^ 1L) > l_87.f0);
            for (l_310.f4 = 0; (l_310.f4 <= 50); l_310.f4 += 7)
            { /* block id: 473 */
                int32_t **l_2095 = (void*)0;
                int32_t **l_2096 = &l_1971;
                (*l_2096) = (void*)0;
                /* statement id: 474 */
                assert (l_1971 == 0);
            }
            /* facts after for loop */
            assert (l_1971 == 0 || l_1971 == &l_1972);
        }
        (*l_2104) = ((*l_2103) &= (l_2018.f1 == ((int16_t)((int16_t)l_86.f3 << (int16_t)((*l_2101) &= l_87.f0)) + (int16_t)l_2054)));
        (*l_2104) = (!((uint16_t)(__builtin_popcount(l_31) >= (l_86.f2 <= ((void*)0 == l_2111))) - (uint16_t)(0x7840L == (!((*l_2101) = (*l_2103))))));
    }
    for (l_2054 = 0; (l_2054 <= (-13)); l_2054 -= 8)
    { /* block id: 485 */
        int32_t l_2120 = 1L;
        int16_t **l_2123 = &l_2053;
        int16_t *** const l_2122 = &l_2123;
        int16_t *** const *l_2121 = &l_2122;
        int8_t l_2135 = (-1L);
        int32_t l_2171 = 0x62F50EE4L;
        struct S0 l_2188 = {5211,0x7B0B8C8FL,7L,-71,1UL,-1L,-408};
        int32_t *l_2189 = &l_31;
        for (l_31 = (-8); (l_31 < (-18)); l_31 -= 1)
        { /* block id: 488 */
            int16_t *****l_2127 = &l_2124;
            uint32_t *l_2128 = &l_86.f4;
            const int32_t l_2136 = 6L;
            int16_t l_2137 = 0L;
            int32_t *l_2158 = &l_31;
            int32_t **l_2157 = &l_2158;
            int32_t ***l_2156 = &l_2157;
            union U3 l_2165 = {-8L};
            if (l_2120)
                break;
            l_2129 ^= ((l_2121 == ((*l_2127) = l_2124)) && ((*l_2128) = l_86.f2));
            if (((uint32_t)(0x62DAADDDL || 0x3BCC92E7L) - (uint32_t)((uint32_t)l_2129 % (uint32_t)func_64(l_2134, l_2135, l_2136, l_2120, l_2137))))
            { /* block id: 493 */
                int32_t l_2141 = 1L;
                int32_t l_2149 = (-1L);
                for (l_86.f5 = (-5); (l_86.f5 != (-3)); l_86.f5 += 1)
                { /* block id: 496 */
                    int32_t *l_2140 = &l_2120;
                    int32_t **l_2150 = (void*)0;
                    int32_t **l_2151 = &l_2140;
                    (*l_2140) |= l_2129;
                    if (l_2141)
                        break;
                    (*l_2140) = ((l_2149 &= ((int32_t)0x340D004CL % (int32_t)__builtin_ffs(((uint32_t)l_2120 + (uint32_t)(l_2141 ^= ((void*)0 == l_2146)))))) && (__builtin_ctzll((*l_2140)) > (*l_2140)));
                    (*l_2151) = l_2140;
                }
                l_86.f3 = l_86.f3;
                for (l_86.f4 = (-30); (l_86.f4 < 53); l_86.f4 += 5)
                { /* block id: 507 */
                    if (l_2149)
                        break;
                }
                for (l_2129 = 0; (l_2129 == 14); l_2129 += 1)
                { /* block id: 512 */
                    return l_2134;
                    /* statement id: 513 */
                                    }
            }
            else
            { /* block id: 515 */
                int8_t l_2161 = 1L;
                int32_t l_2164 = 0xEEC96587L;
                int16_t ***l_2173 = &l_2126;
                union U3 *l_2178 = &l_2165;
                union U3 **l_2179 = &l_2178;
                union U3 *l_2181 = &l_2134;
                union U3 **l_2180 = &l_2181;
                union U3 *l_2183 = &l_2165;
                union U3 **l_2182 = &l_2183;
                if ((l_2156 != &l_2157))
                { /* block id: 516 */
                    for (l_2135 = 4; (l_2135 != (-20)); l_2135 -= 2)
                    { /* block id: 519 */
                        struct S0 *l_2163 = &l_86;
                        struct S0 ** const l_2162 = &l_2163;
                        l_2120 = l_2161;
                        l_2164 = ((void*)0 != l_2162);
                        return l_2165;
                        /* statement id: 522 */
                                            }
                }
                else
                { /* block id: 524 */
                    int32_t l_2168 = 0xD33F168AL;
                    (**l_2156) = &l_2120;
                    /* statement id: 525 */
                    assert (l_2158 == &l_2120);
                    if (__builtin_ctz(((uint32_t)(0UL >= (l_2168 ^ ((l_2168 == ((int32_t)((*l_2158) = l_2161) - (int32_t)(l_2135 != __builtin_bswap32((l_2171 != l_2168))))) >= __builtin_popcount(l_31)))) % (uint32_t)l_2171)))
                    { /* block id: 527 */
                        union U3 *l_2172 = &l_2134;
                        (***l_2156) = ((void*)0 == l_2172);
                        return l_2134;
                        /* statement id: 529 */
                                            }
                    else
                    { /* block id: 530 */
                        (*l_2124) = l_2173;
                    }
                }
                /* facts after branching */
                assert (l_2158 == &l_2120 || l_2158 == &l_31);
                for (l_2171 = (-15); (l_2171 != (-12)); l_2171++)
                { /* block id: 536 */
                    union U3 *l_2176 = &l_2165;
                    union U3 **l_2177 = &l_2176;
                    (*l_2177) = l_2176;
                }
                (*l_2182) = ((*l_2180) = ((*l_2179) = l_2178));
                /* statement id: 541 */
                assert (l_2181 == &l_2165);
                return l_2134;
                /* statement id: 542 */
                            }
        }
        (*l_2189) = ((int16_t)l_2135 % (int16_t)((int16_t)l_31 * (int16_t)(l_2171 & func_78(func_83(l_86, (**l_2146)), l_86, l_2135, l_2188))));
    }
    return l_2134;
    /* statement id: 547 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_46(const uint16_t  p_47, int16_t * p_48, int16_t * p_49, struct S0  p_50, int32_t  p_51)
{ /* block id: 450 */
    int16_t l_2059 = 0x72FBL;
    int32_t l_2064 = 0xFFBA913FL;
    int32_t *l_2063 = &l_2064;
    struct S0 l_2078 = {11672,6L,0xEC54L,226,4294967295UL,0x6DL,-163};
    for (p_50.f5 = (-21); (p_50.f5 == 17); p_50.f5++)
    { /* block id: 453 */
        int32_t *l_2062 = (void*)0;
        int32_t **l_2065 = &l_2063;
        int32_t **l_2066 = (void*)0;
        int32_t **l_2067 = &l_2062;
        union U2 l_2070 = {0L};
        uint32_t l_2074 = 0x1DB99480L;
        uint32_t *l_2073 = &l_2074;
        struct S0 l_2079 = {3675,1L,0x8FB7L,214,0x5EB7EDB2L,-2L,-9};
        uint16_t *l_2080 = (void*)0;
        uint16_t l_2082 = 0xFA65L;
        uint16_t *l_2081 = &l_2082;
        int32_t l_2084 = 8L;
        int32_t *l_2083 = &l_2084;
        int32_t *l_2085 = &l_2079.f1;
        int32_t l_2086 = 0x1A8FC5FAL;
        int32_t l_2088 = 1L;
        int32_t *l_2087 = &l_2088;
        int32_t l_2090 = 0L;
        int32_t *l_2089 = &l_2090;
        p_50.f3 &= ((uint16_t)(l_2059 != (*p_49)) << (uint16_t)((int16_t)(l_2059 && 0x31F9L) >> (int16_t)15));
        (*l_2067) = ((*l_2065) = l_2063);
        /* statement id: 456 */
        assert (l_2062 == &l_2064);
        (*l_2089) ^= ((__builtin_popcount((((uint16_t)(func_78(l_2070, p_50, ((*l_2087) &= ((uint16_t)(((*l_2073) = (0x3374L != (*l_2063))) > ((((!func_52(&l_2059, ((*l_2085) = ((*l_2083) |= (((&p_47 != (void*)0) >= ((uint16_t)((*l_2081) = ((((((func_78(func_83(p_50, l_2070), l_2078, (*l_2063), l_2079) & p_47) && (**l_2067)) > (**l_2065)) >= p_51) <= (**l_2065)) ^ p_47)) >> (uint16_t)(**l_2067))) || (*l_2063)))), (*l_2063), l_2070)) < (*l_2063)) != l_2086) <= (*l_2062))) % (uint16_t)(*l_2063))), p_50) <= (*l_2063)) << (uint16_t)(*l_2062)) & p_50.f5)) == 0x61E9L) > p_50.f4);
    }
    for (p_50.f1 = (-11); (p_50.f1 >= (-26)); p_50.f1 -= 1)
    { /* block id: 466 */
        if (p_50.f3)
            break;
    }
    return p_50.f2;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_52(int16_t * p_53, int32_t  p_54, uint16_t  p_55, union U2  p_56)
{ /* block id: 441 */
    int16_t l_2025 = (-3L);
    int32_t *l_2026 = (void*)0;
    int32_t l_2028 = (-1L);
    int32_t *l_2027 = &l_2028;
    uint32_t l_2031 = 1UL;
    int16_t * const ***l_2032 = (void*)0;
    int16_t *l_2036 = (void*)0;
    int16_t **l_2035 = &l_2036;
    int16_t ***l_2034 = &l_2035;
    int16_t ****l_2033 = &l_2034;
    int16_t *****l_2037 = &l_2033;
    const union U1 l_2044 = {0x137A0A6EL};
    int32_t l_2046 = 0x824FB54FL;
    int32_t *l_2045 = &l_2046;
    int32_t l_2048 = 0xD80435D7L;
    int32_t *l_2047 = &l_2048;
    union U3 l_2049 = {0x0B20CA59L};
    struct S0 l_2050 = {16013,0x30279658L,0x517EL,-82,0x57ECDECFL,4L,-494};
    int32_t l_2051 = 5L;
    (*l_2027) &= l_2025;
    l_2027 = &l_2028;
    (*l_2027) = ((int16_t)l_2031 >> (int16_t)((l_2032 == ((*l_2037) = l_2033)) != (l_2051 |= ((uint16_t)65535UL - (uint16_t)((__builtin_parityll(((0x036DL == ((uint16_t)((int16_t)(p_56.f0 != p_56.f0) >> (int16_t)p_56.f0) >> (uint16_t)(*l_2047))) ^ p_54)) >= (*l_2027)) || (*l_2047))))));
    return p_55;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t * func_57(const union U1  p_58, int32_t  p_59, int32_t  p_60, union U3  p_61, int16_t * p_62)
{ /* block id: 438 */
    int32_t l_2019 = 0xAE274872L;
    int32_t l_2021 = 0xBB445128L;
    int32_t *l_2020 = &l_2021;
    int16_t l_2023 = 0x2535L;
    int16_t *l_2022 = &l_2023;
    (*l_2020) |= l_2019;
    return p_62;
    /* statement id: 440 */
    //assert (func_57_rv == &l_44);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_64(union U3  p_65, uint32_t  p_66, const int16_t  p_67, const uint32_t  p_68, uint32_t  p_69)
{ /* block id: 434 */
    int32_t *l_2012 = (void*)0;
    int32_t **l_2013 = &l_2012;
    uint16_t l_2014 = 0UL;
    int32_t *l_2015 = (void*)0;
    int32_t l_2017 = 0xE76CAB7AL;
    int32_t *l_2016 = &l_2017;
    (*l_2013) = l_2012;
    (*l_2016) ^= l_2014;
    return p_65.f4;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t  func_75(uint32_t  p_76, const int16_t  p_77)
{ /* block id: 418 */
    union U1 l_1976 = {1L};
    const union U1 *l_1975 = &l_1976;
    const union U1 **l_1974 = &l_1975;
    const union U1 ***l_1973 = &l_1974;
    union U1 ***l_1978 = (void*)0;
    union U1 ****l_1977 = &l_1978;
    union U3 l_1984 = {0x64F67A0EL};
    union U3 *l_1983 = &l_1984;
    union U3 **l_1982 = &l_1983;
    union U3 ***l_1981 = &l_1982;
    union U3 ****l_1980 = &l_1981;
    union U3 *****l_1979 = &l_1980;
    int32_t *l_1998 = (void*)0;
    uint32_t l_2007 = 0x22C550B6L;
    int32_t **l_2009 = &l_1998;
    (*l_1977) = l_1973;
    /* statement id: 419 */
    assert (l_1978 == &l_1974);
    l_1979 = l_1979;
    if (l_1984.f3)
    { /* block id: 421 */
        int32_t l_1993 = 0x209B2336L;
        int32_t *l_1992 = &l_1993;
        (*l_1992) &= (!((!(~((uint16_t)l_1984.f1 << (uint16_t)l_1984.f0))) <= ((uint16_t)(p_76 && 0x27E47D7CL) >> (uint16_t)10)));
    }
    else
    { /* block id: 423 */
        int32_t l_1995 = (-1L);
        int32_t *l_1994 = &l_1995;
        int32_t **l_1996 = (void*)0;
        int32_t **l_1997 = &l_1994;
        int32_t **l_1999 = &l_1998;
        int32_t *l_2001 = &l_1995;
        int32_t **l_2000 = &l_2001;
        uint32_t l_2006 = 1UL;
        int32_t *l_2008 = &l_1995;
        (*l_1997) = l_1994;
        l_1998 = l_1998;
        (*l_2000) = ((*l_1999) = ((*l_1997) = l_1998));
        /* statement id: 428 */
        assert (l_1994 == 0);
        assert (l_2001 == 0);
        (*l_2008) |= ((int32_t)((int16_t)p_77 + (int16_t)l_2006) + (int32_t)l_2007);
    }
    (*l_2009) = l_1998;
    return p_76;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_78(union U2  p_79, struct S0  p_80, int32_t  p_81, struct S0  p_82)
{ /* block id: 206 */
    int32_t l_311 = 0xB38C0F79L;
    int32_t *l_318 = &l_311;
    int32_t **l_317 = &l_318;
    int32_t *** const l_316 = &l_317;
    uint16_t l_320 = 1UL;
    uint16_t *l_319 = &l_320;
    int32_t l_370 = 0x8FEB3E27L;
    int32_t l_432 = 6L;
    int32_t l_437 = 0L;
    int32_t l_446 = 0x337E7697L;
    int32_t l_484 = 0x9A2BB022L;
    int32_t l_487 = 0L;
    int32_t l_490 = 0x7126A5E2L;
    int32_t l_494 = 0xA44A9B6DL;
    int32_t l_516 = 0xDF44F759L;
    int32_t l_535 = 0L;
    int32_t l_540 = 0xA4EE5268L;
    int32_t l_544 = 0xCCB76EA8L;
    int32_t l_546 = 7L;
    int32_t l_551 = 0xE847FF5AL;
    int32_t l_553 = 4L;
    int32_t l_574 = 0xD6D7A932L;
    int32_t l_586 = 0x755626FDL;
    int32_t l_591 = 1L;
    int32_t l_592 = 8L;
    int32_t l_604 = (-1L);
    int32_t l_615 = 0x7D66DD98L;
    int32_t l_628 = 0L;
    int32_t l_635 = 0L;
    int32_t l_639 = 1L;
    int32_t l_655 = (-4L);
    int32_t l_657 = (-4L);
    int32_t l_690 = 0xA99A04B6L;
    int32_t l_751 = 5L;
    int32_t l_775 = 0x7325FCA0L;
    int32_t l_793 = 0L;
    int32_t l_810 = 0x779C2675L;
    int32_t l_855 = (-4L);
    int32_t l_864 = 0xA3816290L;
    int16_t l_885 = 0x71D1L;
    int32_t l_912 = 0x42BDA7D3L;
    int32_t l_947 = 0xFB90FAADL;
    int32_t l_969 = 0x37D5B8DCL;
    int32_t l_977 = (-10L);
    int32_t l_983 = 0xB10C8D38L;
    int32_t l_994 = 1L;
    int32_t l_1009 = 0xC1D817BEL;
    int32_t l_1011 = 0xBA42387DL;
    int32_t l_1034 = 0xC8D47481L;
    int32_t l_1072 = (-1L);
    int32_t l_1073 = 0x13B4B872L;
    int32_t l_1082 = 0x21348D37L;
    int32_t l_1127 = 0x6B166CB1L;
    int32_t l_1158 = (-6L);
    int32_t l_1172 = 0L;
    int32_t l_1179 = 0x8D86F083L;
    int32_t l_1182 = 3L;
    int32_t l_1183 = 0xEDB1E32EL;
    int32_t l_1192 = 0x965C2F2BL;
    int32_t l_1196 = 0x60E6FBECL;
    int32_t l_1210 = 0x6A45CBF4L;
    int32_t l_1303 = 0xE23EC0D3L;
    int32_t l_1318 = 0x41A6FC38L;
    int32_t l_1323 = (-3L);
    int32_t l_1337 = 0xCFCA807BL;
    int32_t l_1342 = 0xC2E9884FL;
    int32_t l_1351 = 6L;
    int32_t l_1353 = (-3L);
    int32_t l_1355 = 0x206D4DF0L;
    int32_t l_1356 = 8L;
    int32_t l_1366 = 0xCC60A607L;
    int32_t l_1425 = (-5L);
    int32_t l_1430 = 0x0C2E2896L;
    int32_t l_1431 = 0L;
    int32_t l_1476 = 0xD957FB80L;
    int32_t l_1499 = 3L;
    int32_t l_1505 = 0L;
    int32_t l_1558 = 0x87A0334DL;
    int32_t l_1559 = 0x2890B461L;
    int32_t l_1569 = 1L;
    int32_t l_1571 = 0x5CEDB6F3L;
    int32_t l_1581 = 0xFC9ED822L;
    int32_t l_1588 = 0L;
    int32_t l_1599 = 0x0A4F5C84L;
    int32_t l_1609 = 0xCC2C7134L;
    uint16_t l_1612 = 0xB588L;
    uint16_t l_1621 = 0x1EF5L;
    struct S0 *l_1641 = (void*)0;
    struct S0 * const *l_1640 = &l_1641;
    const union U3 l_1679 = {0xA4E13B45L};
    const union U3 *l_1678 = &l_1679;
    const union U3 **l_1677 = &l_1678;
    int16_t * const *l_1694 = (void*)0;
    int16_t * const * const *l_1693 = &l_1694;
    const int32_t l_1911 = (-1L);
    union U1 l_1923 = {0xF506FF12L};
    return p_80.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static union U2  func_83(struct S0  p_84, union U2  p_85)
{ /* block id: 44 */
    int16_t l_104 = 0x0F83L;
    int16_t *l_103 = &l_104;
    union U1 l_105 = {-9L};
    uint32_t *l_303 = (void*)0;
    uint32_t l_305 = 1UL;
    uint32_t *l_304 = &l_305;
    int32_t l_306 = (-7L);
    int32_t l_308 = 9L;
    int32_t *l_307 = &l_308;
    union U2 l_309 = {0x1BABB202L};
    (*l_307) = ((int16_t)(l_306 |= ((int16_t)(((*l_304) ^= func_92(func_98(l_103, l_105, &l_104, p_84.f5), p_84, &l_104, &l_104, l_104)) ^ l_105.f0) - (int16_t)p_84.f4)) + (int16_t)l_105.f0);
    return l_309;
    /* statement id: 205 */
    }


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_92(int16_t * p_93, struct S0  p_94, const int16_t * p_95, int16_t * p_96, uint32_t  p_97)
{ /* block id: 50 */
    union U1 *l_115 = (void*)0;
    int32_t l_124 = 0x742402BBL;
    struct S0 l_131 = {11798,0xF0DE344EL,0x0A6DL,-148,0x6B4C8AB2L,0x37L,479};
    struct S0 *l_130 = &l_131;
    struct S0 **l_129 = &l_130;
    const int32_t *l_171 = &l_124;
    const int32_t **l_170 = &l_171;
    int32_t *l_217 = &l_124;
    int32_t **l_216 = &l_217;
    int32_t ***l_215 = &l_216;
    union U3 l_223 = {-4L};
    union U3 *l_222 = &l_223;
    const int16_t **l_231 = (void*)0;
    const int16_t ***l_230 = &l_231;
    struct S0 ****l_272 = (void*)0;
    const union U3 **l_286 = (void*)0;
    const union U3 ***l_285 = &l_286;
    l_115 = l_115;
    for (p_94.f1 = 0; (p_94.f1 > 20); p_94.f1 += 2)
    { /* block id: 54 */
        uint32_t l_118 = 0x1C926A5AL;
        int16_t l_157 = 1L;
        int32_t *l_164 = &l_124;
        uint32_t l_174 = 0xB3051342L;
        const int16_t **l_229 = (void*)0;
        const int16_t ***l_228 = &l_229;
        struct S0 ***l_274 = &l_129;
        struct S0 ****l_273 = &l_274;
        const union U3 **l_284 = (void*)0;
        const union U3 ***l_283 = &l_284;
        if (l_118)
            break;
        for (l_118 = 0; (l_118 > 35); l_118++)
        { /* block id: 58 */
            struct S0 **l_132 = (void*)0;
            int32_t **l_134 = (void*)0;
            uint32_t l_184 = 0UL;
            int32_t l_211 = 0L;
            union U3 l_226 = {0x1D9C254BL};
            union U3 *l_225 = &l_226;
            union U3 ** const *l_248 = (void*)0;
            int32_t l_298 = 0L;
            if ((!((int16_t)l_118 / (int16_t)l_124)))
            { /* block id: 59 */
                union U1 **l_125 = &l_115;
                struct S0 l_128 = {8944,0L,-7L,-72,0xE95B7CA3L,0x75L,-295};
                struct S0 *l_127 = &l_128;
                struct S0 **l_126 = &l_127;
                struct S0 ***l_133 = &l_132;
                (*l_125) = l_115;
                if (((l_129 = l_126) != ((*l_133) = l_132)))
                { /* block id: 63 */
                    int32_t *l_139 = (void*)0;
                    int32_t *l_140 = &l_124;
                    uint32_t *l_154 = &l_128.f4;
                    uint16_t l_156 = 0x2AF0L;
                    uint16_t *l_155 = &l_156;
                    (*l_140) = (__builtin_ia32_crc32qi(((void*)0 == l_134), l_131.f6) > (((((int16_t)(*p_96) - (int16_t)(l_131.f3 || p_94.f6)) <= 0UL) <= ((int16_t)(*p_96) << (int16_t)12)) & 0L));
                    p_94.f6 ^= ((uint32_t)p_94.f0 + (uint32_t)((uint32_t)(-(int32_t)((*l_140) |= (((uint32_t)l_128.f3 / (uint32_t)p_94.f1) < ((p_94.f2 && (((int16_t)(p_97 < ((int32_t)((uint16_t)(p_94.f0 && (&l_126 != &l_126)) * (uint16_t)((((*l_155) = (((*l_154) = l_131.f2) != 1UL)) < (*p_96)) || 0x90AFL)) + (int32_t)p_94.f4)) >> (int16_t)l_157) > (-1L))) ^ p_94.f0)))) + (uint32_t)l_128.f0));
                }
                else
                { /* block id: 69 */
                    int32_t *l_158 = &l_124;
                    if (((*l_158) = (p_97 <= 0xAFD6L)))
                    { /* block id: 71 */
                        int32_t l_163 = (-1L);
                        (*l_158) ^= ((uint16_t)((uint16_t)l_163 >> (uint16_t)1) * (uint16_t)l_128.f4);
                        p_94.f3 &= p_94.f2;
                        if (l_128.f3)
                            break;
                        //assert (l_129 == dangling);
                        l_164 = l_158;
                    }
                    else
                    { /* block id: 76 */
                        (*l_164) = p_94.f0;
                    }
                    (*l_158) ^= l_131.f6;
                    if (p_94.f1)
                        break;
                    //assert (l_129 == dangling);
                    for (l_131.f1 = 0; (l_131.f1 < (-18)); l_131.f1 -= 5)
                    { /* block id: 83 */
                        (*l_158) = 0x39393F56L;
                    }
                }
                /* facts after branching */
                assert (l_129 == &l_127);
            }
            else
            { /* block id: 87 */
                const int32_t **l_169 = (void*)0;
                struct S0 ***l_233 = &l_132;
                struct S0 ****l_232 = &l_233;
                struct S0 *** const *l_235 = &l_233;
                struct S0 *** const **l_234 = &l_235;
                for (l_131.f1 = 0; (l_131.f1 >= 24); l_131.f1++)
                { /* block id: 90 */
                    int16_t *l_175 = &l_157;
                    int32_t l_183 = 1L;
                    const struct S0 *l_185 = &l_131;
                    int16_t *l_189 = (void*)0;
                    l_170 = l_169;
                    /* statement id: 91 */
                    assert (l_170 == 0);
                    if (((((*l_175) = ((uint16_t)l_174 / (uint16_t)((*p_96) = __builtin_bswap64(__builtin_ctz((*l_164)))))) > (*l_164)) <= (p_97 ^ (~((p_94.f6 | ((uint16_t)65535UL * (uint16_t)((uint16_t)(((int16_t)__builtin_bswap32((0x1AC4L != l_183)) + (int16_t)(*l_164)) == (*l_171)) % (uint16_t)l_184))) >= (*l_164))))))
                    { /* block id: 94 */
                        const struct S0 **l_186 = &l_185;
                        (*l_186) = l_185;
                        (*l_164) = p_94.f2;
                    }
                    else
                    { /* block id: 97 */
                        int16_t **l_188 = &l_175;
                        int32_t l_196 = (-1L);
                        l_196 = ((-(uint16_t)((((*l_188) = p_96) != (p_93 = l_189)) | 0x0995485AL)) && (((int32_t)0x64895FD5L % (int32_t)l_183) == ((uint32_t)(0x33E8L || (-1L)) / (uint32_t)((int16_t)(*p_95) * (int16_t)(*l_171)))));
                        /* statement id: 100 */
                        assert (p_93 == 0);
                        //assert (l_175 == &l_104 || l_175 == &l_334 || l_175 == &l_885);
                    }
                    /* facts after branching */
                    //assert (l_175 == &l_104 || l_175 == &l_157 || l_175 == &l_334 || l_175 == &l_885);
                }
                for (p_94.f5 = 0; (p_94.f5 <= 20); p_94.f5 += 1)
                { /* block id: 105 */
                    uint32_t l_199 = 0x28A493C9L;
                    if (p_94.f0)
                    { /* block id: 106 */
                        l_199++;
                    }
                    else
                    { /* block id: 108 */
                        int32_t l_204 = 0x62D627FBL;
                        uint16_t *l_205 = (void*)0;
                        uint16_t l_207 = 0x52EEL;
                        uint16_t *l_206 = &l_207;
                        int32_t l_210 = 0x1BE5FB79L;
                        int32_t ***l_214 = (void*)0;
                        l_211 ^= (((l_204 = p_94.f6) && (p_94.f3 <= ((*l_206) = p_94.f1))) < (((((int16_t)(p_97 <= (p_97 >= (p_94.f5 && ((*l_164) != (p_94.f1 >= (*l_164)))))) >> (int16_t)l_210) < (*l_164)) && 1UL) == p_94.f5));
                        p_94.f3 = (((*l_217) = (((int16_t)0x931FL >> (int16_t)p_94.f3) != (0xCF0C6C1DL == ((l_215 = l_214) != (void*)0)))) && (((uint32_t)p_94.f6 / (uint32_t)((uint32_t)((p_94.f1 && (*l_217)) && l_199) - (uint32_t)0xF5C8C88DL)) != 6L));
                        /* statement id: 114 */
                        assert (l_215 == 0);
                    }
                    /* facts after branching */
                    assert (l_215 == 0 || l_215 == &l_216);
                    if ((*l_171))
                    { /* block id: 116 */
                        union U3 **l_224 = &l_222;
                        l_164 = (*l_216);
                        l_225 = ((*l_224) = l_222);
                        /* statement id: 119 */
                        assert (l_225 == &l_223);
                        (*l_164) |= p_94.f3;
                    }
                    else
                    { /* block id: 121 */
                        uint32_t l_227 = 18446744073709551615UL;
                        (*l_217) |= l_227;
                        (*l_217) &= (0xD8590BC5L > p_94.f4);
                    }
                    /* facts after branching */
                    assert (l_225 == &l_226 || l_225 == &l_223);
                    return p_94.f4;
                }
                l_230 = l_228;
                /* statement id: 127 */
                assert (l_230 == &l_229);
                (*l_234) = l_232;
            }
            if ((*l_217))
                break;
            (*l_216) = l_164;
            for (l_226.f2 = 8; (l_226.f2 > 44); l_226.f2++)
            { /* block id: 134 */
                union U3 **l_238 = &l_222;
                union U3 ***l_239 = &l_238;
                int32_t l_240 = 9L;
                uint16_t *l_243 = (void*)0;
                int32_t ***l_296 = (void*)0;
                l_240 &= (((*l_239) = l_238) == &l_225);
            }
            /* facts after for loop */
                    }
        /* facts after for loop */
        //assert (l_230 == &l_229 || l_230 == &l_231 || l_230 == dangling);
    }
    /* facts after for loop */
    //assert (l_129 == &l_130 || l_129 == dangling);
    assert (l_170 == 0 || l_170 == &l_171);
    //assert (l_230 == dangling || l_230 == &l_231);
    return p_94.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t * func_98(int16_t * p_99, union U1  p_100, int16_t * const  p_101, uint16_t  p_102)
{ /* block id: 45 */
    int32_t *l_106 = (void*)0;
    int32_t ***l_107 = (void*)0;
    int32_t ***l_108 = (void*)0;
    int32_t **l_110 = &l_106;
    int32_t ***l_109 = &l_110;
    struct S0 l_113 = {829,0xC6C5FB33L,-3L,-158,4294967293UL,0xFCL,-281};
    struct S0 *l_112 = &l_113;
    struct S0 **l_111 = &l_112;
    int16_t *l_114 = (void*)0;
    l_106 = (void*)0;
    (*l_109) = &l_106;
    (*l_111) = (void*)0;
    /* statement id: 48 */
    assert (l_112 == 0);
    return l_114;
    /* statement id: 49 */
    //assert (func_98_rv == 0);
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_30();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 426
   depth: 1, occurrence: 8
XXX total union variables: 16

XXX non-zero bitfields defined in structs: 5
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 55
breakdown:
   indirect level: 0, occurrence: 20
   indirect level: 1, occurrence: 10
   indirect level: 2, occurrence: 11
   indirect level: 3, occurrence: 6
   indirect level: 4, occurrence: 6
   indirect level: 5, occurrence: 2
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 25
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 55
XXX times a single bitfield on LHS: 16
XXX times a single bitfield on RHS: 76

XXX max expression depth: 44
breakdown:
   depth: 1, occurrence: 128
   depth: 2, occurrence: 25
   depth: 3, occurrence: 6
   depth: 4, occurrence: 1
   depth: 5, occurrence: 3
   depth: 6, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 2
   depth: 11, occurrence: 2
   depth: 13, occurrence: 2
   depth: 15, occurrence: 3
   depth: 17, occurrence: 1
   depth: 20, occurrence: 1
   depth: 42, occurrence: 1
   depth: 44, occurrence: 1

XXX total number of pointers: 1394

XXX times a variable address is taken: 1112
XXX times a pointer is dereferenced on RHS: 67
breakdown:
   depth: 1, occurrence: 56
   depth: 2, occurrence: 6
   depth: 3, occurrence: 5
XXX times a pointer is dereferenced on LHS: 160
breakdown:
   depth: 1, occurrence: 145
   depth: 2, occurrence: 8
   depth: 3, occurrence: 7
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 1
XXX times a pointer is compared with another pointer: 6
XXX times a pointer is qualified to be dereferenced: 2662

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 730
   level: 2, occurrence: 55
   level: 3, occurrence: 37
   level: 4, occurrence: 3
XXX number of pointers point to pointers: 129
XXX number of pointers point to scalars: 1237
XXX number of pointers point to structs: 9
XXX percent of pointers has null in alias set: 22.8
XXX average alias set size: 1.04

XXX times a non-volatile is read: 743
XXX times a non-volatile is write: 446
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 1

XXX stmts: 115
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 30
   depth: 1, occurrence: 16
   depth: 2, occurrence: 9
   depth: 3, occurrence: 16
   depth: 4, occurrence: 21
   depth: 5, occurrence: 23

XXX percentage a fresh-made variable is used: 43.7
XXX percentage an existing variable is used: 56.3
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

