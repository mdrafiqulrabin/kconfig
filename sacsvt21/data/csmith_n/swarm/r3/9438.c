/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --comma-operators --no-compound-assignment --no-consts --no-divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --int8 --no-uint8 --no-float --math64 --inline-function --muls --safe-math --packed-struct --paranoid --pointers --structs --unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      562857108
 */

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
#pragma pack(push)
#pragma pack(1)
struct S0 {
   int64_t  f0;
   uint32_t  f1;
   uint16_t  f2;
   uint32_t  f3;
   uint32_t  f4;
   int32_t  f5;
   int32_t  f6;
};
#pragma pack(pop)

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_31(void);
inline static uint32_t  func_35(int32_t ** p_36, int32_t ** p_37);
static int32_t ** func_38(int32_t ** p_39, int32_t ** p_40, int32_t  p_41);
static struct S0  func_51(int16_t  p_52, struct S0  p_53, struct S0 * p_54, struct S0  p_55, uint64_t  p_56);
static int32_t  func_59(uint32_t  p_60);
inline static int32_t * func_61(uint64_t  p_62);
inline static struct S0  func_63(int64_t  p_64);
inline static struct S0 ** func_71(int32_t ** p_72, struct S0 ** p_73, int8_t  p_74);
static int32_t ** func_75(uint64_t  p_76);
inline static struct S0 *** func_77(struct S0 *** p_78, int16_t  p_79, struct S0 *** p_80, int32_t ** p_81, struct S0 *** p_82);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_31(void)
{ /* block id: 36 */
    int32_t l_33 = 0x598AAF0AL;
    int32_t *l_32 = &l_33;
    int32_t **l_34 = &l_32;
    int32_t **l_42 = &l_32;
    struct S0 l_279 = {0x57FC2B63E0678FFELL,0xB3DE261AL,0xE968L,8UL,0xF030DFCBL,5L,2L};
    int32_t l_280 = (-1L);
    (*l_34) = l_32;
    l_279 = ((__builtin_ctzl(func_35(func_38(&l_32, l_42, (*l_32)), &l_32)) , 0x56E7L) , func_51(((**l_42) , (**l_42)), l_279, &l_279, l_279, (**l_34)));
    return l_280;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_35(int32_t ** p_36, int32_t ** p_37)
{ /* block id: 185 */
    uint64_t **l_274 = (void*)0;
    uint64_t ***l_273 = &l_274;
    uint64_t ****l_275 = &l_273;
    struct S0 l_277 = {-6L,4294967295UL,65534UL,0xE006D20AL,4294967293UL,1L,0x13F104CFL};
    struct S0 *l_276 = &l_277;
    struct S0 **l_278 = &l_276;
    (*l_275) = l_273;
    (*l_278) = l_276;
    return l_277.f6;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_38(int32_t ** p_39, int32_t ** p_40, int32_t  p_41)
{ /* block id: 38 */
    uint32_t l_43 = 0x82104667L;
    int32_t *l_272 = (void*)0;
    int32_t **l_271 = &l_272;
    if ((l_43 == l_43))
    { /* block id: 39 */
        struct S0 **l_44 = (void*)0;
        struct S0 l_47 = {0x66EF3B0639E6A413LL,0xD6C5051DL,65535UL,4294967294UL,0x4132D38CL,0x8C98AAC1L,-7L};
        struct S0 *l_46 = &l_47;
        struct S0 **l_45 = &l_46;
        int32_t **l_50 = (void*)0;
        (*l_45) = (void*)0;
        /* statement id: 40 */
        assert (l_46 == 0);
        for (l_47.f6 = 0; (l_47.f6 == (-7)); l_47.f6 = safe_sub_func_uint16_t_u_u(l_47.f6, 9))
        { /* block id: 43 */
            return l_50;
            /* statement id: 44 */
            //assert (func_38_rv == 0);
        }
    }
    else
    { /* block id: 46 */
        struct S0 l_57 = {0xEDF66798564DBB9ALL,0xF725DC8FL,0x05C8L,0x2DB6377FL,4294967290UL,0x1FA46B4CL,0x1F903A79L};
        l_57 = func_51(p_41, l_57, (p_41 , (void*)0), l_57, ((~(l_43 > (func_59(l_43) >= 1L))) ^ 0xEA9A4662F551003BLL));
        (**p_40) = l_43;
        return p_40;
        /* statement id: 182 */
        //assert (func_38_rv == &l_32);
    }
    return p_39;
    /* statement id: 184 */
    //assert (func_38_rv == &l_32);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_51(int16_t  p_52, struct S0  p_53, struct S0 * p_54, struct S0  p_55, uint64_t  p_56)
{ /* block id: 162 */
    int16_t l_244 = 0xA823L;
    uint32_t l_248 = 18446744073709551608UL;
    struct S0 *l_266 = (void*)0;
    struct S0 **l_265 = &l_266;
    uint64_t l_269 = 18446744073709551615UL;
    uint64_t *l_268 = &l_269;
    uint64_t **l_267 = &l_268;
    uint64_t ***l_270 = &l_267;
    for (p_55.f2 = 4; (p_55.f2 != 46); p_55.f2++)
    { /* block id: 165 */
        uint16_t l_243 = 0x3040L;
        uint16_t *l_242 = &l_243;
        struct S0 l_247 = {1L,4294967293UL,9UL,4294967295UL,5UL,0L,0xA0286852L};
        struct S0 *l_246 = &l_247;
        struct S0 **l_245 = &l_246;
        int32_t l_251 = (-1L);
        int32_t *l_250 = &l_251;
        int32_t **l_249 = &l_250;
        (*l_249) = func_61((((((__builtin_bswap64((((*l_242) = p_55.f4) , func_59(l_244))) & (&p_55 == ((*l_245) = &p_53))) || (p_55.f6 ^ (__builtin_ia32_crc32qi(((2UL >= p_55.f1) , p_55.f6), l_248) >= p_55.f3))) , l_247.f1) , l_244) > l_247.f2));
        /* statement id: 168 */
        assert (l_246 == &p_53);
        assert (l_250 == 0);
    }
    for (l_248 = (-25); (l_248 != 52); l_248++)
    { /* block id: 172 */
        uint32_t l_258 = 1UL;
        int64_t l_261 = 0x85A51B85FDC69A44LL;
        int64_t *l_260 = &l_261;
        int32_t l_263 = 0L;
        int32_t *l_262 = &l_263;
        struct S0 l_264 = {-5L,6UL,65535UL,5UL,1UL,0x06DDD18BL,0x939D3E18L};
        (*l_262) = ((safe_add_func_uint16_t_u_u(((safe_add_func_int64_t_s_s(l_258, ((*l_260) = (!5UL)))) , 65531UL), p_55.f1)) & l_258);
        return l_264;
    }
    l_265 = l_265;
    (*l_270) = l_267;
    return p_53;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_59(uint32_t  p_60)
{ /* block id: 47 */
    int8_t l_66 = (-7L);
    struct S0 **l_67 = (void*)0;
    int32_t l_70 = (-6L);
    struct S0 l_121 = {0xA35B98692F7AB6CDLL,0UL,0x1B69L,4294967295UL,0x5CE8A8DCL,0xE86AE0A1L,0x52B13B08L};
    struct S0 *l_120 = &l_121;
    int32_t *l_135 = &l_70;
    int32_t **l_134 = &l_135;
    int32_t l_175 = (-1L);
    int16_t **l_192 = (void*)0;
    (*l_134) = func_61((((*l_120) = func_63(((~(l_66 , (l_67 != (((safe_mod_func_uint16_t_u_u(l_66, (0x3C48L || (0x6E18L == 0UL)))) < (l_66 && (l_70 = (-1L)))) , func_71(func_75(__builtin_ffsl(p_60)), l_67, p_60))))) , p_60))) , l_121.f6));
    /* statement id: 75 */
    assert (l_135 == 0);
    if ((p_60 == ((void*)0 != &l_120)))
    { /* block id: 76 */
        uint32_t l_136 = 0xDECC6E98L;
        struct S0 *l_138 = &l_121;
        (*l_134) = (*l_134);
        if ((l_136 = p_60))
        { /* block id: 79 */
            struct S0 *l_137 = (void*)0;
            l_137 = (l_138 = l_137);
            /* statement id: 81 */
            assert (l_138 == 0);
            l_70 = (-3L);
        }
        else
        { /* block id: 83 */
            uint64_t l_139 = 18446744073709551609UL;
            return l_139;
        }
        /* facts after branching */
        assert (l_138 == 0);
    }
    else
    { /* block id: 86 */
        int32_t *l_142 = &l_70;
        struct S0 l_204 = {0xFDCFAA0CEB8E079FLL,0x3D5E54CFL,65535UL,0xDA394717L,0x9D7677ECL,0xE271CBBBL,0x6B008311L};
        for (l_121.f2 = 18; (l_121.f2 <= 12); l_121.f2 = safe_sub_func_uint32_t_u_u(l_121.f2, 1))
        { /* block id: 89 */
            (*l_134) = l_142;
            /* statement id: 90 */
            assert (l_135 == &l_70);
        }
        /* facts after for loop */
        assert (l_135 == &l_70 || l_135 == 0);
        for (l_66 = (-13); (l_66 > (-21)); l_66 = safe_sub_func_int64_t_s_s(l_66, 8))
        { /* block id: 94 */
            uint32_t *l_145 = &l_121.f4;
            int32_t l_146 = 1L;
            int64_t l_153 = 0x107FD1B8A4D6DA33LL;
            uint64_t l_157 = 0x24197F755CB3DCC7LL;
            uint64_t *l_156 = &l_157;
            int16_t l_159 = 1L;
            int16_t *l_158 = &l_159;
            int64_t *l_162 = (void*)0;
            int64_t *l_163 = &l_153;
            struct S0 l_174 = {7L,0UL,65535UL,4UL,0x534F4898L,0x3569B458L,-1L};
            (*l_142) = (((((*l_145) = p_60) >= l_146) , (p_60 < (safe_sub_func_uint16_t_u_u((safe_add_func_int16_t_s_s(0x26E0L, l_146)), ((((safe_add_func_uint32_t_u_u((l_153 == (safe_mul_func_int16_t_s_s(8L, ((((*l_156) = l_146) == 1UL) , l_153)))), 4294967286UL)) | p_60) || 0x9C2C93F0L) < 0L))))) || p_60);
            l_175 = (p_60 || (((*l_158) = 0x8AD0L) < (((*l_142) = (((safe_add_func_uint64_t_u_u(((((((((*l_163) = (*l_142)) , (((((safe_lshift_func_uint16_t_u_u(((((safe_rshift_func_int16_t_s_s(((*l_142) > (p_60 , (safe_sub_func_uint64_t_u_u((l_157 < ((*l_145) = (safe_lshift_func_int16_t_s_s(__builtin_ffs(((*l_142) && (safe_lshift_func_uint16_t_u_s(p_60, p_60)))), 13)))), 0xE02E4CAB560D96E2LL)))), p_60)) > 1L) , (*l_142)) & l_146), (*l_142))) || p_60) , 0L) < 1L) == (*l_142))) , l_174) , (*l_120)) , 0x5FF99356L) , p_60) != 1L), p_60)) , p_60) || 0L)) > p_60)));
            (*l_120) = ((*l_142) , ((((*l_163) = __builtin_parityll(((safe_sub_func_int32_t_s_s((*l_142), __builtin_ffs(p_60))) , 18446744073709551615UL))) | (func_63((!(safe_lshift_func_int16_t_s_u((-2L), 3)))) , (-1L))) , l_174));
        }
        for (p_60 = 0; (p_60 < 52); p_60 = safe_add_func_uint16_t_u_u(p_60, 7))
        { /* block id: 108 */
            uint16_t l_189 = 0x4B7CL;
            int32_t l_190 = 6L;
            struct S0 l_191 = {-5L,0UL,0UL,4294967295UL,0UL,0x03736092L,0xE14BB8DEL};
            uint32_t l_216 = 4294967295UL;
            int32_t *l_217 = &l_175;
        }
        for (l_121.f4 = 0; (l_121.f4 < 17); l_121.f4 = safe_add_func_int16_t_s_s(l_121.f4, 9))
        { /* block id: 134 */
            int32_t *l_224 = &l_175;
            int32_t **l_239 = &l_142;
            for (l_204.f2 = (-5); (l_204.f2 >= 42); l_204.f2++)
            { /* block id: 137 */
                for (l_121.f3 = 0; (l_121.f3 != 37); l_121.f3++)
                { /* block id: 140 */
                    int32_t **l_225 = (void*)0;
                    int32_t **l_226 = &l_142;
                    (*l_226) = ((*l_134) = l_224);
                    /* statement id: 142 */
                    assert (l_135 == &l_175);
                    assert (l_142 == &l_175);
                    (*l_226) = (void*)0;
                    /* statement id: 143 */
                    assert (l_142 == 0);
                    if (((safe_lshift_func_int16_t_s_u(p_60, 12)) , (*l_224)))
                    { /* block id: 144 */
                        int64_t l_235 = 2L;
                        int16_t l_237 = 0L;
                        int16_t *l_236 = &l_237;
                        (*l_135) = (((p_60 >= ((safe_rshift_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(p_60, 3)), p_60)) , p_60)) || (6UL < (safe_lshift_func_int16_t_s_s((l_204 , ((*l_236) = (p_60 == l_235))), (!p_60))))) <= p_60);
                        (*l_224) = l_237;
                        (*l_134) = (*l_226);
                        /* statement id: 148 */
                        assert (l_135 == 0);
                    }
                    else
                    { /* block id: 149 */
                        if (p_60)
                            break;
                        (*l_134) = func_61((*l_224));
                        /* statement id: 151 */
                        assert (l_135 == 0);
                    }
                    /* facts after branching */
                    assert (l_135 == 0);
                    (*l_226) = l_224;
                    /* statement id: 153 */
                    assert (l_142 == &l_175);
                }
            }
            (*l_239) = ((*l_134) = l_142);
            (*l_224) = ((p_60 > (p_60 , ((p_60 <= p_60) <= (-1L)))) || 0xFCC5ADFDL);
        }
        /* facts after for loop */
        assert (l_135 == &l_175 || l_135 == &l_70 || l_135 == 0);
        assert (l_142 == 0 || l_142 == &l_175 || l_142 == &l_70);
    }
    /* facts after branching */
    assert (l_135 == &l_175 || l_135 == &l_70 || l_135 == 0);
    return p_60;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t * func_61(uint64_t  p_62)
{ /* block id: 72 */
    int32_t l_123 = (-1L);
    int32_t *l_122 = &l_123;
    int32_t **l_124 = &l_122;
    int32_t *l_125 = &l_123;
    int32_t *l_126 = &l_123;
    int32_t *l_127 = &l_123;
    int32_t *l_128 = &l_123;
    int32_t *l_129 = &l_123;
    int32_t *l_130 = &l_123;
    int32_t *l_131 = &l_123;
    int32_t *l_132 = &l_123;
    int32_t *l_133 = (void*)0;
    (*l_124) = l_122;
    return l_133;
    /* statement id: 74 */
    //assert (func_61_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_63(int64_t  p_64)
{ /* block id: 68 */
    int32_t l_116 = (-6L);
    int32_t *l_115 = &l_116;
    int32_t **l_117 = (void*)0;
    int32_t **l_118 = &l_115;
    struct S0 l_119 = {0xED5480CDD5450317LL,0UL,0x078AL,4294967292UL,4294967295UL,0x18D08C10L,-1L};
    (*l_118) = l_115;
    return l_119;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 ** func_71(int32_t ** p_72, struct S0 ** p_73, int8_t  p_74)
{ /* block id: 56 */
    uint32_t l_102 = 0UL;
    int64_t l_104 = 0xFDDE4D78B1D69833LL;
    int64_t *l_103 = &l_104;
    int32_t l_108 = (-7L);
    int32_t *l_107 = &l_108;
    struct S0 l_113 = {0L,4294967292UL,65535UL,0UL,0xE5D8015DL,-1L,0x5DA1D3BCL};
    (*l_107) = ((((*l_103) = l_102) || p_74) && (safe_sub_func_int16_t_s_s(p_74, l_102)));
    for (l_102 = (-28); (l_102 != 35); l_102++)
    { /* block id: 61 */
        int32_t *l_111 = &l_108;
        int32_t **l_112 = &l_107;
        struct S0 *l_114 = &l_113;
        (*l_112) = l_111;
        (*l_114) = l_113;
        (*l_112) = (*l_112);
        (*l_107) = (0x5015C65DL & 0x47928101L);
    }
    return p_73;
    /* statement id: 67 */
    //assert (func_71_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t ** func_75(uint64_t  p_76)
{ /* block id: 49 */
    struct S0 ***l_83 = (void*)0;
    int32_t l_84 = 0xBD1B8438L;
    int32_t *l_86 = (void*)0;
    int32_t **l_85 = &l_86;
    struct S0 l_90 = {-1L,0xF6DC3DB8L,0x7736L,4294967295UL,0xAA0404C6L,0x30A87563L,0L};
    struct S0 *l_89 = &l_90;
    struct S0 **l_88 = &l_89;
    struct S0 ***l_87 = &l_88;
    struct S0 ****l_91 = &l_87;
    int32_t **l_92 = &l_86;
    int32_t **l_93 = &l_86;
    int32_t **l_94 = &l_86;
    int32_t **l_95 = &l_86;
    int32_t **l_96 = &l_86;
    int32_t **l_97 = &l_86;
    int32_t **l_98 = &l_86;
    int32_t **l_99 = &l_86;
    int32_t **l_100 = &l_86;
    int32_t **l_101 = (void*)0;
    (*l_91) = func_77(l_83, (p_76 && l_84), l_83, l_85, (l_87 = l_83));
    /* statement id: 53 */
    assert (l_87 == 0);
    (*l_85) = (*l_85);
    return l_101;
    /* statement id: 55 */
    //assert (func_75_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0 *** func_77(struct S0 *** p_78, int16_t  p_79, struct S0 *** p_80, int32_t ** p_81, struct S0 *** p_82)
{ /* block id: 51 */
    return p_82;
    /* statement id: 52 */
    //assert (func_77_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_31();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 70
   depth: 1, occurrence: 8
XXX total union variables: 0

XXX max expression depth: 34
breakdown:
   depth: 1, occurrence: 72
   depth: 2, occurrence: 17
   depth: 3, occurrence: 2
   depth: 5, occurrence: 1
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 15, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 20, occurrence: 1
   depth: 34, occurrence: 1

XXX total number of pointers: 98

XXX times a variable address is taken: 78
XXX times a pointer is dereferenced on RHS: 22
breakdown:
   depth: 1, occurrence: 19
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 59
breakdown:
   depth: 1, occurrence: 57
   depth: 2, occurrence: 2
XXX times a pointer is compared with null: 2
XXX times a pointer is compared with address of another variable: 0
XXX times a pointer is compared with another pointer: 0
XXX times a pointer is qualified to be dereferenced: 290

XXX max dereference level: 3
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 93
   level: 2, occurrence: 22
   level: 3, occurrence: 1
XXX number of pointers point to pointers: 52
XXX number of pointers point to scalars: 36
XXX number of pointers point to structs: 10
XXX percent of pointers has null in alias set: 32.7
XXX average alias set size: 1.09

XXX times a non-volatile is read: 247
XXX times a non-volatile is write: 142
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 66
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 27
   depth: 1, occurrence: 18
   depth: 2, occurrence: 11
   depth: 3, occurrence: 1
   depth: 4, occurrence: 4
   depth: 5, occurrence: 5

XXX percentage a fresh-made variable is used: 10.2
XXX percentage an existing variable is used: 89.8
********************* end of statistics **********************/

