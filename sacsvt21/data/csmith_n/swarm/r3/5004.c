/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --no-comma-operators --no-compound-assignment --consts --divs --embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --jumps --no-longlong --no-int8 --uint8 --float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --volatile-pointers --const-pointers --no-global-variables --builtins
 * Seed:      3781076576
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   int16_t  f0;
   uint32_t  f1;
   const uint16_t  f2;
   uint8_t  f3;
   const int32_t  f4;
   float  f5;
   int16_t  f6;
   uint32_t  f7;
   uint8_t  f8;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static const int16_t  func_33(void);
inline static uint32_t  func_40(uint32_t  p_41, float  p_42, uint32_t  p_43);
inline static uint16_t * func_44(int32_t  p_45, uint16_t * p_46, uint32_t  p_47, uint16_t * p_48);
inline static int32_t  func_66(uint8_t  p_67);
inline static uint16_t *** func_70(uint16_t * p_71, int32_t  p_72, uint32_t * p_73, uint16_t *** const  p_74, float  p_75);
inline static uint16_t * func_76(uint16_t * const ** p_77, int32_t  p_78, float  p_79, const int32_t  p_80);
static uint16_t * func_114(float * p_115, struct S0  p_116, int32_t  p_117);
inline static const float  func_124(float  p_125, uint32_t  p_126, uint32_t  p_127);
inline static uint16_t * func_130(struct S0  p_131, uint32_t * p_132);
inline static struct S0  func_133(int32_t  p_134, uint16_t *** p_135, uint16_t  p_136);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_33(void)
{ /* block id: 36 */
    uint32_t l_37 = 0x452FA814;
    uint16_t l_39 = 9U;
    uint16_t *l_38 = &l_39;
    uint32_t *l_49 = (void*)0;
    uint32_t l_51 = 4294967295U;
    uint32_t *l_50 = &l_51;
    uint16_t l_62 = 65534U;
    uint16_t *l_61 = &l_62;
    uint16_t **l_60 = &l_61;
    float *l_63 = (void*)0;
    float l_65 = 0x9.6p+1;
    float *l_64 = &l_65;
    int32_t l_558 = 0x84915D70;
    int32_t l_559 = 0x98BDFED1;
    int16_t l_561 = (-1);
    int16_t *l_560 = &l_561;
    int32_t l_562 = (-2);
    int32_t l_564 = 0x90BD9C6B;
    int32_t *l_563 = &l_564;
    int32_t *l_565 = &l_558;
    const uint32_t l_566 = 0xAD72166D;
    (*l_563) = ((l_562 = ((uint32_t)(((*l_560) = (l_559 = (-(int32_t)(((((*l_38) = l_37) & l_37) ^ l_37) & (l_558 = func_40(l_37, ((*l_64) = (((((*l_60) = func_44(__builtin_popcount(((*l_50) = 1U)), l_38, (((uint16_t)l_37 << (uint16_t)((int16_t)((int32_t)(-1) + (int32_t)l_37) << (int16_t)l_37)) > l_37), l_38)) == &l_62) != l_62) == l_37)), l_62)))))) && 0x96B4) + (uint32_t)8)) & l_37);
    /* statement id: 328 */
    assert (l_61 == &l_39);
    (*l_565) = ((*l_563) = (*l_563));
    return l_566;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint32_t  func_40(uint32_t  p_41, float  p_42, uint32_t  p_43)
{ /* block id: 43 */
    uint16_t l_557 = 0xE909;
    l_557 = func_66(p_43);
    return l_557;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t * func_44(int32_t  p_45, uint16_t * p_46, uint32_t  p_47, uint16_t * p_48)
{ /* block id: 39 */
    uint16_t l_59 = 0xBE62;
    uint16_t *l_58 = &l_59;
    return p_48;
    /* statement id: 40 */
    //assert (func_44_rv == &l_39 || func_44_rv == &l_112);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_66(uint8_t  p_67)
{ /* block id: 44 */
    int16_t l_87 = 0x231D;
    uint16_t l_100 = 65533U;
    uint16_t *l_99 = &l_100;
    uint16_t **l_102 = &l_99;
    uint16_t ***l_101 = &l_102;
    uint32_t l_539 = 0xB61E3E17;
    uint32_t *l_538 = &l_539;
    float l_553 = 0x9.Ep-1;
    float *l_552 = &l_553;
    struct S0 *l_555 = (void*)0;
    struct S0 **l_556 = &l_555;
    for (p_67 = 0; (p_67 >= 58); p_67 += 6)
    { /* block id: 47 */
        uint16_t l_84 = 0U;
        uint16_t *l_83 = &l_84;
        uint16_t * const *l_82 = &l_83;
        uint16_t * const **l_81 = &l_82;
        uint16_t **l_96 = &l_83;
        uint16_t ***l_95 = &l_96;
        int32_t l_103 = 1;
        uint16_t ****l_545 = (void*)0;
        const uint16_t *l_549 = (void*)0;
        const uint16_t ** const l_548 = &l_549;
        const uint16_t ** const *l_547 = &l_548;
        const uint16_t ** const **l_546 = &l_547;
        uint16_t ****l_550 = (void*)0;
        uint16_t * const ***l_551 = &l_81;
        (*l_551) = ((*l_546) = func_70(func_76(l_81, ((uint16_t)(l_87 == ((int32_t)(-(uint32_t)((int32_t)((uint16_t)((*l_81) == ((*l_95) = (void*)0)) % (uint16_t)(l_103 = ((l_99 == (*l_82)) | ((void*)0 == l_101)))) - (int32_t)((uint16_t)((uint16_t)(l_100 != (-6)) >> (uint16_t)p_67) + (uint16_t)p_67))) % (int32_t)l_84)) - (uint16_t)p_67), l_84, l_84), l_100, l_538, l_95, l_84));
        /* statement id: 315 */
        assert (l_81 == 0);
        assert (l_96 == 0);
        assert (l_547 == 0);
        return l_100;
    }
    if (l_87)
        goto lbl_554;
lbl_554:
    (*l_552) = l_100;
    (*l_556) = l_555;
    return l_539;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t *** func_70(uint16_t * p_71, int32_t  p_72, uint32_t * p_73, uint16_t *** const  p_74, float  p_75)
{ /* block id: 310 */
    int32_t ****l_540 = (void*)0;
    int32_t *****l_541 = &l_540;
    int32_t l_543 = (-1);
    int32_t *l_542 = &l_543;
    uint16_t ***l_544 = (void*)0;
    (*l_541) = l_540;
    l_542 = &p_72;
    /* statement id: 312 */
    assert (l_542 == &p_72);
    return l_544;
    /* statement id: 313 */
    //assert (func_70_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t * func_76(uint16_t * const ** p_77, int32_t  p_78, float  p_79, const int32_t  p_80)
{ /* block id: 50 */
    float l_108 = (-0x8.Dp-1);
    int32_t l_109 = 1;
    uint16_t l_111 = 0xD66A;
    uint16_t *l_110 = &l_111;
    uint16_t l_112 = 0xE079;
    uint16_t **l_113 = &l_110;
    float *l_118 = &l_108;
    struct S0 l_119 = {0x2D3F,0xCC827221,0xDB03,1U,0x77DF0EBE,0x2.0CFCE3p+76,2,0xCB182417,0x16};
    uint16_t *l_531 = &l_111;
    int32_t *l_532 = &l_109;
    int32_t l_536 = (-2);
    int32_t *l_535 = &l_536;
    uint16_t *l_537 = (void*)0;
    (*l_532) = (((l_109 | (((*l_113) = func_44(p_80, l_110, l_112, &l_112)) != (l_531 = func_114(l_118, l_119, (0x4C0A206E <= p_80))))) >= l_119.f8) != p_80);
    /* statement id: 305 */
    assert (l_110 == &l_112);
    assert (l_531 == 0);
    (*l_118) = p_80;
    (*l_535) = (p_80 && ((*l_532) = (8 != (*l_532))));
    return l_537;
    /* statement id: 309 */
    //assert (func_76_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t * func_114(float * p_115, struct S0  p_116, int32_t  p_117)
{ /* block id: 52 */
    float *l_120 = (void*)0;
    uint16_t l_129 = 1U;
    uint16_t *l_128 = &l_129;
    uint16_t ***l_137 = (void*)0;
    uint16_t *l_273 = &l_129;
    uint16_t **l_272 = &l_273;
    int32_t l_525 = 0x29A8D414;
    struct S0 l_527 = {-4,4294967294U,1U,1U,0xFCECC129,-0x1.Fp+1,7,0x924B5834,0x93};
    struct S0 *l_526 = &l_527;
    uint16_t *l_528 = &l_129;
    uint16_t *l_529 = &l_129;
    uint16_t *l_530 = (void*)0;
    l_525 = (((*p_115) = ((l_120 != l_120) == (((float)(!((*p_115) == func_124((l_128 == ((*l_272) = func_130(func_133((4294967295U <= l_129), l_137, p_116.f8), p_115))), p_116.f8, p_116.f0))) * (float)0x4.5p-1) < (*p_115)))) == l_129);
    /* statement id: 301 */
    assert (l_273 == 0);
    l_526 = (void*)0;
    /* statement id: 302 */
    assert (l_526 == 0);
    return l_530;
    /* statement id: 303 */
    //assert (func_114_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const float  func_124(float  p_125, uint32_t  p_126, uint32_t  p_127)
{ /* block id: 142 */
    int32_t l_274 = 0xC57EFDBF;
    float *l_297 = (void*)0;
    float **l_296 = &l_297;
    int32_t l_323 = 0x47ABF410;
    struct S0 l_353 = {4,0x5B112714,0x00EA,0x84,0x8C81BC87,0x1.Cp-1,0x9C88,0x312AFD50,0x93};
    struct S0 *l_352 = &l_353;
    struct S0 **l_351 = &l_352;
    int32_t l_362 = (-1);
    const uint16_t ****l_387 = (void*)0;
    const uint16_t *****l_386 = &l_387;
    uint16_t l_451 = 2U;
    if (l_274)
    { /* block id: 143 */
        int32_t *l_276 = &l_274;
        int32_t **l_275 = &l_276;
        struct S0 **l_442 = &l_352;
        struct S0 ***l_445 = &l_442;
        struct S0 ****l_444 = &l_445;
        struct S0 *****l_470 = &l_444;
        uint16_t *l_519 = &l_451;
        int32_t *l_520 = &l_274;
lbl_405:
        (*l_275) = &l_274;
        /* statement id: 144 */
        assert (l_276 == &l_274);
        if (l_274)
            goto lbl_512;
lbl_509:
        (**l_275) = ((((int16_t)l_274 % (int16_t)((~p_127) | (65533U < 0U))) == 0x5DF7) ^ p_127);
lbl_512:
        if (__builtin_bswap32((p_126 ^ ((int16_t)0xC68C / (int16_t)(0x1778 || 6)))))
        { /* block id: 146 */
            int16_t l_331 = 0x1DFB;
            struct S0 ***l_372 = &l_351;
            int32_t l_382 = 0x76519DB9;
            uint16_t ***l_385 = (void*)0;
            uint16_t ****l_384 = &l_385;
            uint16_t *****l_383 = &l_384;
            float * const *l_423 = &l_297;
            int32_t *l_472 = &l_274;
            (*l_275) = (void*)0;
            /* statement id: 147 */
            assert (l_276 == 0);
            if (p_127)
            { /* block id: 148 */
                uint8_t l_282 = 0x99;
                int32_t l_283 = 1;
                int32_t *l_285 = &l_283;
                int32_t **l_284 = &l_285;
                l_283 = (l_282 = (-1));
                (*l_284) = ((*l_275) = &l_283);
                /* statement id: 152 */
                assert (l_276 == &l_283);
                for (p_126 = 0; (p_126 != 6); p_126 += 1)
                { /* block id: 155 */
                    for (l_282 = 0; (l_282 == 29); l_282 += 1)
                    { /* block id: 158 */
                        return p_127;
                    }
                }
            }
            else
            { /* block id: 162 */
                float l_294 = 0xC.355CF6p-60;
                float *l_293 = &l_294;
                float **l_292 = &l_293;
                int32_t l_307 = 0;
                int32_t l_322 = 0x4E9D9957;
                const float *l_397 = &l_353.f5;
                const float **l_396 = &l_397;
                const float *** const l_395 = &l_396;
                const float *** const *l_394 = &l_395;
                for (p_126 = 27; (p_126 <= 28); p_126 += 1)
                { /* block id: 165 */
                    float ***l_295 = &l_292;
                    float l_301 = 0x5.6p+1;
                    float * const l_300 = &l_301;
                    float * const *l_299 = &l_300;
                    float * const **l_298 = &l_299;
                    float ***l_302 = (void*)0;
                    float ***l_303 = (void*)0;
                    float ***l_304 = &l_296;
                    uint16_t l_306 = 0x0A19;
                    uint16_t *l_305 = &l_306;
                    int32_t l_314 = (-1);
                    int32_t *l_315 = &l_274;
                    uint8_t l_326 = 0xD0;
                }
                for (l_274 = 0; (l_274 != (-5)); l_274 -= 5)
                { /* block id: 188 */
                    uint32_t l_366 = 0x0C550413;
                    for (p_126 = (-9); (p_126 == 60); p_126 += 1)
                    { /* block id: 191 */
                        int32_t l_365 = 0x8E89D45B;
                        uint32_t *l_368 = &l_353.f1;
                        int32_t *l_369 = &l_323;
                        (*l_275) = &l_307;
                        /* statement id: 192 */
                        assert (l_276 == &l_307);
                        (*l_369) = (l_322 != ((*l_368) = (((int32_t)((**l_275) = l_362) + (int32_t)p_127) && ((uint16_t)(l_353.f3 & (l_365 | l_366)) - (uint16_t)(-(int16_t)(**l_275))))));
                    }
                }
                /* facts after for loop */
                assert (l_276 == &l_307 || l_276 == 0);
                for (l_353.f3 = 0; (l_353.f3 == 48); l_353.f3 += 1)
                { /* block id: 200 */
                    struct S0 ****l_373 = &l_372;
                    struct S0 ***l_374 = (void*)0;
                    int32_t *l_375 = &l_307;
                    (*l_375) = ((((*l_373) = l_372) != l_374) != p_126);
                    if (l_353.f1)
                        break;
                }
                if (l_322)
                { /* block id: 205 */
                    uint32_t *l_381 = &l_353.f1;
                    (*l_275) = &l_323;
                    /* statement id: 206 */
                    assert (l_276 == &l_323);
                    l_382 = ((int32_t)(l_323 >= (((int16_t)(((*l_381) = (p_127 == (!(**l_275)))) < 0x92FC4D6C) << (int16_t)4) > p_127)) % (int32_t)p_127);
                    (*l_275) = (void*)0;
                    /* statement id: 209 */
                    assert (l_276 == 0);
                }
                else
                { /* block id: 210 */
                    float ***l_393 = (void*)0;
                    float ****l_392 = &l_393;
                    float ****l_399 = &l_393;
                    float *****l_398 = &l_399;
                    int32_t l_400 = 1;
                    l_400 = (p_127 <= (l_353.f4 == ((l_383 == (l_386 = l_386)) > ((float)(((float)((l_392 == ((*l_398) = l_394)) >= 0xC.7358A6p+67) - (float)0xD.F79517p-45) >= p_126) - (float)p_125))));
                    /* statement id: 213 */
                    assert (l_399 == &l_395);
                }
            }
            /* facts after branching */
            //assert (l_276 == dangling || l_276 == 0);
            for (l_353.f7 = 0; (l_353.f7 > 51); l_353.f7 += 1)
            { /* block id: 218 */
                int32_t ***l_418 = &l_275;
                int32_t l_426 = (-5);
                int32_t *l_494 = &l_274;
                uint32_t *l_495 = &l_353.f1;
                uint32_t l_497 = 4294967291U;
                uint32_t *l_496 = &l_497;
                if (l_331)
                { /* block id: 219 */
                    int32_t *l_408 = &l_274;
                    uint16_t l_434 = 0xD771;
                    uint16_t *l_433 = &l_434;
                    int16_t *l_437 = &l_353.f6;
                    float **l_454 = &l_297;
                    struct S0 *****l_469 = &l_444;
                    for (l_353.f3 = (-8); (l_353.f3 <= 2); l_353.f3 += 1)
                    { /* block id: 222 */
                        if (l_353.f1)
                            goto lbl_405;
                        //assert (l_276 == dangling || l_276 == 0);
                        l_382 = ((int16_t)__builtin_popcountl(__builtin_clzll(p_126)) << (int16_t)(p_127 != p_127));
                    }
                    (*l_408) = (p_127 <= l_353.f0);
                    for (l_353.f8 = 0; (l_353.f8 <= 32); l_353.f8 += 9)
                    { /* block id: 229 */
                        uint16_t l_415 = 0x49B1;
                        uint32_t *l_419 = &l_353.f1;
                        float ***l_422 = &l_296;
                        float **l_425 = &l_297;
                        float ***l_424 = &l_425;
                        (*l_408) = ((uint16_t)(((int16_t)l_415 - (int16_t)((uint16_t)((*l_408) ^ ((l_331 < ((void*)0 != l_418)) != ((*l_419) = l_415))) / (uint16_t)(((int32_t)((0 != (((*l_422) = (void*)0) != ((*l_424) = l_423))) >= l_382) % (int32_t)l_426) ^ p_127))) == 7) % (uint16_t)p_127);
                        /* statement id: 233 */
                        assert (l_296 == 0);
                    }
                    /* facts after for loop */
                    assert (l_296 == 0 || l_296 == &l_297);
                    if (((~((int16_t)((!((int16_t)0 >> (int16_t)((*l_433) = p_126))) && p_126) / (int16_t)(p_126 || ((int16_t)(__builtin_clzl(((2 < ((*l_437) = p_127)) & (0xAB55 < ((uint16_t)((int32_t)(p_127 | p_126) + (int32_t)0xC855315C) / (uint16_t)p_126)))) || p_127) % (int16_t)p_126)))) == 0xAB90))
                    { /* block id: 237 */
                        struct S0 ***l_443 = &l_442;
                        int32_t l_450 = 0x0FE0126B;
                        (*l_443) = ((*l_372) = l_442);
                        (*l_408) = (p_127 ^ (((((void*)0 == l_444) ^ __builtin_ffs(((l_353.f7 != (l_353.f1 ^ ((int32_t)((uint16_t)l_331 + (uint16_t)(l_323 != p_126)) / (int32_t)p_127))) > l_450))) < l_451) < p_126));
                        return p_127;
                    }
                    else
                    { /* block id: 242 */
                        const int32_t l_452 = (-1);
                        int32_t l_453 = 0x9D655A31;
                        float ***l_455 = &l_296;
                        int16_t *l_468 = &l_353.f0;
                        l_453 = l_452;
                        (*l_455) = l_454;
                        /* statement id: 244 */
                        assert (l_296 == &l_297);
                        (*l_408) = ((((int16_t)l_452 >> (int16_t)((uint16_t)((uint16_t)0x7323 - (uint16_t)__builtin_parityl(((int16_t)((int32_t)(p_127 && 9) - (int32_t)(!0x7493)) + (int16_t)p_127))) * (uint16_t)0xD5BF)) <= ((*l_468) = (~((*l_437) = p_127)))) && p_127);
                        l_470 = l_469;
                    }
                    /* facts after branching */
                    assert (l_296 == &l_297);
                }
                else
                { /* block id: 250 */
                    int32_t *l_471 = (void*)0;
                    struct S0 **l_475 = &l_352;
                    int32_t l_487 = 0x6909606A;
                    l_472 = ((**l_418) = l_471);
                    /* statement id: 252 */
                    assert (l_276 == 0);
                    assert (l_472 == 0);
                    for (p_127 = 0; (p_127 == 43); p_127 += 1)
                    { /* block id: 255 */
                        (*l_372) = l_475;
                        return l_353.f2;
                    }
                    for (l_274 = 0; (l_274 < 9); l_274 += 1)
                    { /* block id: 261 */
                        struct S0 *l_478 = &l_353;
                        int32_t l_483 = 0x50F9E100;
                        float *l_484 = &l_353.f5;
                        float l_486 = 0xC.4566B5p-45;
                        float *l_485 = &l_486;
                        (*l_442) = l_478;
                        (*l_485) = ((*l_484) = ((float)(p_125 <= ((*l_444) == &l_475)) * (float)((float)l_483 / (float)(p_127 > l_353.f1))));
                        (*l_442) = (*l_475);
                        l_487 = 0x688869D0;
                    }
                    p_125 = l_362;
                }
                if (p_127)
                    break;
                l_382 = (((int16_t)((uint32_t)((*l_496) = (((p_126 || p_126) && p_127) == ((((*l_495) = (0x105B != ((~(!((*l_494) = p_126))) ^ p_126))) & (-9)) <= l_362))) - (uint32_t)((int16_t)l_353.f4 * (int16_t)(-1))) << (int16_t)11) ^ p_126);
                for (l_274 = 0; (l_274 > 15); l_274 += 1)
                { /* block id: 277 */
                    float *l_506 = (void*)0;
                    float *l_507 = &l_353.f5;
                    int32_t *l_508 = &l_426;
                    (*l_507) = ((float)p_126 / (float)((float)p_125 * (float)__builtin_popcountll(p_127)));
                    (*l_508) = 0x5E980E34;
                    (*l_275) = &l_382;
                    /* statement id: 280 */
                    assert (l_276 == &l_382);
                }
            }
            /* facts after for loop */
            //assert (l_276 == &l_382 || l_276 == dangling || l_276 == 0);
            assert (l_472 == 0 || l_472 == &l_274);
        }
        else
        { /* block id: 283 */
            if (l_353.f2)
                goto lbl_509;
            for (l_362 = (-3); (l_362 > (-10)); l_362 -= 1)
            { /* block id: 287 */
                (**l_275) = p_126;
            }
        }
        /* facts after branching */
        //assert (l_276 == &l_274 || l_276 == dangling || l_276 == 0);
        (*l_520) = __builtin_clzl((((0xF0E8 <= ((uint16_t)7U * (uint16_t)(__builtin_popcount(l_362) <= p_126))) | (((((int16_t)((uint16_t)((*l_519) = p_127) + (uint16_t)l_353.f4) >> (int16_t)12) == (l_323 = (((*l_520) = p_127) || ((uint16_t)((0x33CE <= p_126) <= (*l_520)) - (uint16_t)l_362)))) >= p_127) && 65526U)) || 1));
    }
    else
    { /* block id: 296 */
        int32_t *l_524 = (void*)0;
        int32_t **l_523 = &l_524;
        (*l_523) = &l_323;
        /* statement id: 297 */
        assert (l_524 == &l_323);
    }
    return l_323;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static uint16_t * func_130(struct S0  p_131, uint32_t * p_132)
{ /* block id: 98 */
    uint32_t l_207 = 1U;
    int32_t **l_234 = (void*)0;
    int32_t ***l_235 = &l_234;
    uint16_t *l_237 = (void*)0;
    int32_t l_269 = 0x46BF440E;
    for (p_131.f0 = 0; (p_131.f0 > 1); p_131.f0 += 1)
    { /* block id: 101 */
        float l_231 = 0x2.E1A7EAp-29;
        int32_t l_232 = 4;
        int32_t *l_233 = &l_232;
        for (p_131.f6 = (-18); (p_131.f6 >= 7); p_131.f6 += 1)
        { /* block id: 104 */
            float l_215 = (-0x4.3p-1);
            int32_t l_218 = 1;
            int32_t *l_221 = &l_218;
            float *l_227 = &l_215;
            float **l_226 = &l_227;
            float ***l_225 = &l_226;
            for (p_131.f7 = 15; (p_131.f7 >= 40); p_131.f7 += 1)
            { /* block id: 107 */
                int32_t l_217 = 0xB4A2447E;
                int32_t *l_216 = &l_217;
                (*l_216) = ((float)(((float)((-0x5.Fp-1) < l_207) * (float)0x3.0p-1) == (-(float)((float)__builtin_clz(((int32_t)((1U && ((((int16_t)p_131.f2 << (int16_t)5) ^ __builtin_ia32_crc32qi(l_207, p_131.f1)) > ((*l_216) = 0))) != p_131.f4) / (int32_t)l_207)) - (float)p_131.f1))) - (float)l_218);
                for (p_131.f8 = 4; (p_131.f8 <= 34); p_131.f8 += 4)
                { /* block id: 112 */
                    int32_t *l_222 = &l_217;
                    l_222 = l_221;
                    /* statement id: 113 */
                    assert (l_222 == &l_218);
                }
                for (l_217 = 0; (l_217 > (-9)); l_217 -= 1)
                { /* block id: 117 */
                    float ****l_228 = &l_225;
                    (*l_228) = l_225;
                    for (l_207 = 0; (l_207 == 34); l_207 += 8)
                    { /* block id: 121 */
                        (*l_221) = p_131.f4;
                    }
                }
            }
        }
        (*l_233) = l_232;
    }
    (*l_235) = l_234;
    if ((!p_131.f0))
    { /* block id: 130 */
        return l_237;
        /* statement id: 131 */
        //assert (func_130_rv == 0);
    }
    else
    { /* block id: 132 */
        uint16_t l_238 = 0U;
        int32_t l_240 = (-1);
        int32_t *l_239 = &l_240;
        struct S0 l_242 = {1,6U,0x72B3,1U,1,0x5.A15E86p+20,5,0x25720279,255U};
        struct S0 *l_241 = &l_242;
        struct S0 **l_243 = &l_241;
        int32_t l_268 = 0x8430C375;
        int32_t *l_267 = &l_268;
        const uint16_t l_270 = 0xFD11;
        uint32_t *l_271 = &l_242.f1;
        (*l_239) = l_238;
        (*l_243) = l_241;
        (*l_239) = ((uint32_t)((*l_271) = (((uint16_t)((int16_t)(-2) << (int16_t)(*l_239)) / (uint16_t)(-(int16_t)p_131.f1)) == ((uint16_t)(p_131.f3 > (((uint16_t)0U % (uint16_t)((int32_t)p_131.f7 % (int32_t)((uint16_t)((p_131.f0 == (l_269 = ((*l_267) = ((uint32_t)((int16_t)(*l_239) >> (int16_t)9) % (uint32_t)((int16_t)((uint16_t)p_131.f3 >> (uint16_t)9) << (int16_t)13))))) || l_270) << (uint16_t)p_131.f1))) > (*l_239))) + (uint16_t)p_131.f4))) + (uint32_t)1);
    }
    return l_237;
    /* statement id: 140 */
    //assert (func_130_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_133(int32_t  p_134, uint16_t *** p_135, uint16_t  p_136)
{ /* block id: 53 */
    uint16_t l_138 = 0x794F;
    uint32_t *l_139 = (void*)0;
    uint32_t *l_140 = (void*)0;
    uint32_t l_142 = 9U;
    uint32_t *l_141 = &l_142;
    uint32_t l_146 = 4U;
    uint32_t *l_145 = &l_146;
    int32_t l_161 = 0;
    uint16_t **l_164 = (void*)0;
    uint16_t ***l_163 = &l_164;
    uint16_t ****l_162 = &l_163;
    int32_t *l_184 = &l_161;
    struct S0 l_196 = {0x883C,8U,7U,0x2D,0x3A861C21,0xD.742CEBp+55,-1,0xF71A791D,0xB0};
    if (((((*l_141) = l_138) < __builtin_popcountll(l_138)) >= (p_134 <= (((int16_t)p_136 % (int16_t)l_138) == __builtin_bswap64(__builtin_bswap32(((*l_145) = l_138)))))))
    { /* block id: 56 */
        int32_t l_148 = (-1);
        int32_t *l_147 = &l_148;
        struct S0 l_149 = {0x9A86,0xCAFA2358,1U,0U,0xEFE8F334,0x4.4p+1,0xDB04,0xC3DD168C,1U};
        (*l_147) = p_136;
        return l_149;
    }
    else
    { /* block id: 59 */
        struct S0 l_151 = {0,0x02E2238E,0x51F2,0x2D,-1,0xB.7CC927p-70,1,7U,0x5B};
        struct S0 *l_150 = &l_151;
        struct S0 **l_152 = &l_150;
        uint16_t l_157 = 65529U;
        int32_t *l_158 = (void*)0;
        int32_t l_160 = 0x256DA865;
        int32_t *l_159 = &l_160;
        (*l_152) = l_150;
        l_161 = ((*l_159) = (p_136 == ((int16_t)((uint16_t)l_157 % (uint16_t)l_138) * (int16_t)((*l_152) != (void*)0))));
    }
    l_162 = &p_135;
    /* statement id: 64 */
    assert (l_162 == &p_135);
    for (l_142 = (-5); (l_142 == 52); l_142 += 1)
    { /* block id: 67 */
        const uint32_t l_171 = 0U;
        float l_175 = (-0x8.2p+1);
        float *l_174 = &l_175;
        struct S0 l_194 = {0x52EC,0x757C61DA,65527U,0xD9,0,-0x1.Fp-1,0xA606,4294967287U,246U};
        int32_t **l_195 = &l_184;
        for (p_136 = (-14); (p_136 <= 13); p_136 += 7)
        { /* block id: 70 */
            float *l_176 = &l_175;
            float **l_177 = &l_176;
            uint16_t *l_178 = &l_138;
            uint16_t **l_179 = &l_178;
            (*l_174) = (((l_142 > (((float)l_171 * (float)((float)(l_174 == ((*l_177) = l_176)) - (float)0x7.6p-1)) <= 0x2.Ep+1)) > (((*l_179) = l_178) == &p_136)) < ((float)p_136 + (float)l_142));
            for (l_138 = (-20); (l_138 == 15); l_138 += 6)
            { /* block id: 76 */
                int32_t **l_185 = &l_184;
                (*l_185) = l_184;
                (*l_185) = l_174;
                /* statement id: 78 */
                assert (l_184 == &l_175);
                if (p_136)
                    continue;
            }
        }
        /* facts after for loop */
        assert (l_184 == &l_175 || l_184 == &l_161);
        for (l_138 = 0; (l_138 >= 20); l_138 += 1)
        { /* block id: 84 */
            uint16_t ** const *l_190 = &l_164;
            uint16_t ** const **l_189 = &l_190;
            uint16_t ** const ***l_188 = &l_189;
            int32_t **l_191 = &l_184;
            (*l_188) = &p_135;
            /* statement id: 85 */
            assert (l_189 == &p_135);
            (*l_191) = &l_161;
            /* statement id: 86 */
            assert (l_184 == &l_161);
            if ((**l_191))
            { /* block id: 87 */
                int32_t l_192 = 0xB2946C84;
                struct S0 l_193 = {0x8971,0xEE9290BC,65531U,252U,4,0x3.DD0B69p+31,0xD6F1,0xDAB5352C,0x7B};
                if (l_192)
                    break;
                return l_193;
            }
            else
            { /* block id: 90 */
                (*l_191) = &l_161;
                return l_194;
            }
        }
        (*l_195) = &l_161;
        /* statement id: 95 */
        assert (l_184 == &l_161);
    }
    return l_196;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_33();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 113
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 139
   depth: 2, occurrence: 31
   depth: 4, occurrence: 3
   depth: 5, occurrence: 2
   depth: 6, occurrence: 2
   depth: 7, occurrence: 1
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 3
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 16, occurrence: 1
   depth: 17, occurrence: 2
   depth: 19, occurrence: 1
   depth: 20, occurrence: 2
   depth: 25, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 179

XXX times a variable address is taken: 156
XXX times a pointer is dereferenced on RHS: 19
breakdown:
   depth: 1, occurrence: 16
   depth: 2, occurrence: 3
XXX times a pointer is dereferenced on LHS: 105
breakdown:
   depth: 1, occurrence: 100
   depth: 2, occurrence: 5
XXX times a pointer is compared with null: 4
XXX times a pointer is compared with address of another variable: 2
XXX times a pointer is compared with another pointer: 1
XXX times a pointer is qualified to be dereferenced: 434

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 185
   level: 2, occurrence: 37
   level: 3, occurrence: 22
   level: 4, occurrence: 2
   level: 5, occurrence: 1
XXX number of pointers point to pointers: 85
XXX number of pointers point to scalars: 88
XXX number of pointers point to structs: 6
XXX percent of pointers has null in alias set: 23.5
XXX average alias set size: 1.08

XXX times a non-volatile is read: 397
XXX times a non-volatile is write: 267
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 2

XXX stmts: 127
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 31
   depth: 1, occurrence: 21
   depth: 2, occurrence: 11
   depth: 3, occurrence: 22
   depth: 4, occurrence: 22
   depth: 5, occurrence: 20

XXX percentage a fresh-made variable is used: 19.2
XXX percentage an existing variable is used: 80.8
********************* end of statistics **********************/

