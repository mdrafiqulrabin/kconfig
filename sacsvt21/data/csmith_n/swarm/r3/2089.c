/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --arrays --bitfields --comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --jumps --no-longlong --int8 --no-uint8 --float --no-math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers --no-global-variables --no-builtins
 * Seed:      1601504250
 */


#define NO_LONGLONG

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const unsigned f0 : 11;
   const int8_t  f1;
};

/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
inline static int32_t  func_1(void);
static const int16_t  func_4(int8_t  p_5, uint32_t  p_6, struct S0  p_7);
inline static const int16_t  func_10(struct S0  p_11, uint32_t  p_12, int8_t  p_13);
inline static struct S0  func_15(const int8_t  p_16, const uint32_t  p_17, int16_t  p_18, uint32_t  p_19);
inline static float  func_26(uint16_t  p_27, int8_t  p_28, uint32_t  p_29);
static struct S0  func_35(int32_t  p_36, const int8_t  p_37);
static float  func_38(struct S0  p_39, const float  p_40, int32_t  p_41, const uint16_t  p_42, const uint32_t  p_43);
static struct S0  func_44(uint32_t  p_45, int16_t  p_46, uint32_t  p_47, uint32_t  p_48, const struct S0  p_49);
static struct S0  func_62(int32_t  p_63, float  p_64);
inline static struct S0  func_72(struct S0  p_73, float  p_74);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int32_t  func_1(void)
{ /* block id: 0 */
    int16_t l_2[9][1];
    int32_t l_3 = 8;
    struct S0 l_14 = {37,0xDA};
    int32_t l_1780 = 7;
    int i, j;
    for (i = 0; i < 9; i++)
    {
        for (j = 0; j < 1; j++)
            l_2[i][j] = 0xA32B;
    }
    for (l_3 = 0; (l_3 <= 0); l_3 += 1)
    { /* block id: 3 */
        const uint32_t l_25 = 1U;
        struct S0 l_830 = {28,0};
        int32_t *l_1776 = (void*)0;
        int32_t l_1778 = (-1);
        int32_t *l_1777 = &l_1778;
        (*l_1777) = (0x843046B6 == (func_4(((int16_t)func_10(l_14, l_14.f0, l_3) % (int16_t)(0xFD06 & 0x6520)), (func_10(func_15((((((uint16_t)l_2[1][0] * (uint16_t)(~(((uint16_t)l_25 / (uint16_t)l_14.f0) || 0x0881826F))) , 0U) <= l_25) == l_14.f1), l_25, l_25, l_2[5][0]), l_25, l_14.f1) , l_14.f1), l_830) | 0x9BA7));
        if ((*l_1777))
            continue;
        for (l_1778 = 0; (l_1778 <= 0); l_1778 += 1)
        { /* block id: 711 */
            int32_t l_1779 = (-1);
            float l_1795 = (-0x10.Ep-1);
            float *l_1794 = &l_1795;
            int32_t l_1801 = 0x9F5E7A18;
            for (l_1779 = 0; (l_1779 >= 0); l_1779 -= 1)
            { /* block id: 714 */
                int32_t **l_1781 = &l_1777;
                uint32_t l_1790 = 0U;
                int i, j;
                l_1780 = l_2[l_1778][l_1779];
                (*l_1781) = (void*)0;
                /* statement id: 716 */
                assert (l_1777 == 0);
                for (l_1780 = (-28); (l_1780 <= (-5)); l_1780 += 5)
                { /* block id: 719 */
                    int32_t l_1784 = 0xACC2B1B2;
                    float * const l_1796 = &l_1795;
                    for (l_1784 = 0; (l_1784 <= (-22)); l_1784 -= 1)
                    { /* block id: 722 */
                        int32_t *l_1787 = (void*)0;
                        int32_t l_1789 = (-1);
                        int32_t *l_1788 = &l_1789;
                        (*l_1781) = &l_1779;
                        /* statement id: 723 */
                        assert (l_1777 == &l_1779);
                        (*l_1788) = l_2[1][0];
                        if (l_14.f0)
                            break;
                        return l_1790;
                    }
                    for (l_1784 = 0; (l_1784 != 24); l_1784++)
                    { /* block id: 730 */
                        float l_1793 = 0xA.E04B0Ap+51;
                        int32_t l_1798[6] = {0x0A4AAEF3,0x0A4AAEF3,0x0A4AAEF3,0x0A4AAEF3,0x0A4AAEF3,0x0A4AAEF3};
                        int32_t *l_1797 = &l_1798[2];
                        int i;
                        (*l_1797) = ((l_3 , l_1794) == l_1796);
                        (*l_1781) = &l_1798[5];
                        /* statement id: 732 */
                        assert ((l_1777 >= &l_1798[0] && l_1777 <= &l_1798[5]));
                    }
                    for (l_1790 = 26; (l_1790 == 22); l_1790 -= 3)
                    { /* block id: 736 */
                        l_1801 = (l_2[8][0] != (l_3 > 0x33A4));
                        return l_1784;
                    }
                }
                /* facts after for loop */
                //assert (l_1777 == dangling || l_1777 == &l_1779 || l_1777 == 0);
            }
            /* facts after for loop */
            //assert (l_1777 == dangling || l_1777 == &l_1779 || l_1777 == 0 || l_1777 == &l_1778);
        }
        /* facts after for loop */
        //assert (l_1777 == dangling || l_1777 == 0 || l_1777 == &l_1778);
    }
    return l_14.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static const int16_t  func_4(int8_t  p_5, uint32_t  p_6, struct S0  p_7)
{ /* block id: 352 */
    int32_t l_831 = 0x91349BE2;
    int32_t ***l_843 = (void*)0;
    int32_t ****l_842[4][3][1] = {{{&l_843},{&l_843},{&l_843}},{{&l_843},{&l_843},{&l_843}},{{&l_843},{&l_843},{&l_843}},{{&l_843},{&l_843},{&l_843}}};
    int32_t **** const *l_841 = &l_842[0][2][0];
    struct S0 l_853 = {19,0};
    struct S0 **l_864 = (void*)0;
    struct S0 ***l_863 = &l_864;
    struct S0 * const ***l_892 = (void*)0;
    struct S0 * const ****l_891 = &l_892;
    int32_t *l_906[2];
    struct S0 ***l_935 = &l_864;
    float l_939 = 0x1.E9B7B8p+8;
    uint32_t l_974[5];
    uint32_t l_975[8][10][3] = {{{4294967295U,0xF6F03E44,4294967295U},{0x44B1842B,4294967286U,4294967287U},{2U,4294967295U,0x98F8CC76},{1U,4294967286U,4294967295U},{0x37E25891,0xF6F03E44,4294967291U},{0U,0xB86B3903,0U},{0x98F8CC76,4294967295U,0xDC499ACE},{0x0117A2FB,0xFAB865A3,6U},{0xDC499ACE,0U,0x37E25891},{3U,0x901451F3,4U}},{{1U,4294967295U,4294967291U},{0x94230285,1U,0x94230285},{0U,0U,4294967295U},{0U,0U,0x44B1842B},{0U,0xF6F03E44,2U},{0xC758EBDB,4294967295U,1U},{0U,4294967295U,0x37E25891},{0U,0xB86B3903,0U},{0U,2U,0x98F8CC76},{0x94230285,0x6D3B13FE,0x0117A2FB}},{{1U,0x5A9AD75E,0xDC499ACE},{2U,0xBFFA4401,3U},{4294967291U,0x5A9AD75E,1U},{0xAD8CC9A6,0x6D3B13FE,0U},{2U,2U,0x5A9AD75E},{3U,0xB86B3903,4294967287U},{0xF6F03E44,4294967295U,1U},{4294967287U,4294967295U,0xAD8CC9A6},{4294967295U,0xF6F03E44,1U},{4294967287U,0U,4294967287U}},{{0x5A9AD75E,0U,0x5A9AD75E},{4294967293U,1U,0U},{4294967295U,4294967295U,1U},{4294967295U,0x901451F3,3U},{4294967295U,1U,0xDC499ACE},{4294967295U,4294967291U,0x0117A2FB},{4294967295U,0x98F8CC76,0x98F8CC76},{4294967293U,9U,0U},{0x5A9AD75E,4294967295U,0x37E25891},{4294967287U,0xB6C18C55,1U}},{{4294967295U,0x1BDC39AB,2U},{4294967287U,0xB6C18C55,0x44B1842B},{0xF6F03E44,4294967295U,4294967295U},{3U,9U,0x94230285},{2U,0x98F8CC76,4294967291U},{0xAD8CC9A6,4294967291U,4U},{4294967291U,1U,0xF6F03E44},{2U,0x901451F3,4U},{1U,4294967295U,4294967291U},{0x94230285,1U,0x94230285}},{{0U,0U,4294967295U},{0U,0U,0x44B1842B},{0U,0xF6F03E44,2U},{0xC758EBDB,4294967295U,1U},{0U,4294967295U,0x37E25891},{0U,0xB86B3903,0U},{0U,2U,0x98F8CC76},{0x94230285,0x6D3B13FE,0x0117A2FB},{1U,0x5A9AD75E,0xDC499ACE},{2U,0xBFFA4401,3U}},{{4294967291U,0x5A9AD75E,1U},{0xAD8CC9A6,0x6D3B13FE,0U},{2U,2U,0x5A9AD75E},{3U,0xB86B3903,4294967287U},{0xF6F03E44,4294967295U,1U},{4294967287U,4294967295U,0xAD8CC9A6},{4294967295U,0xF6F03E44,1U},{4294967287U,0U,4294967287U},{0x5A9AD75E,0U,0x5A9AD75E},{4294967293U,1U,0U}},{{4294967295U,4294967295U,1U},{4294967295U,0x901451F3,3U},{4294967295U,1U,0xDC499ACE},{0x44B1842B,2U,0xAD8CC9A6},{0x5A9AD75E,2U,2U},{1U,0xFE0707CC,3U},{0U,0x98F8CC76,0xF6F03E44},{1U,0xFAB865A3,4294967287U},{0U,1U,4294967295U},{0U,0xFAB865A3,4294967287U}}};
    uint32_t l_1080 = 4294967293U;
    uint32_t l_1139 = 4294967295U;
    const uint32_t l_1156 = 0xC7EA226E;
    int16_t l_1162[7][4][2] = {{{(-1),3},{3,0x0EC8},{3,3},{(-1),0x8A29}},{{3,(-1)},{3,0x8A29},{(-1),3},{3,0x0EC8}},{{3,3},{(-1),0x8A29},{3,(-1)},{3,0x8A29}},{{(-1),3},{3,0x0EC8},{3,3},{(-1),0x8A29}},{{3,(-1)},{3,0x8A29},{(-1),3},{3,0x0EC8}},{{3,3},{(-1),0x8A29},{3,(-1)},{3,0x8A29}},{{(-1),3},{3,0x0EC8},{3,3},{(-1),0x8A29}}};
    uint32_t l_1251 = 4294967295U;
    int32_t **l_1351 = &l_906[0];
    uint16_t l_1489[9][2] = {{0xD31C,0xD31C},{0xD31C,65535U},{65535U,9U},{65535U,9U},{65535U,65535U},{0xD31C,0xD31C},{0xD31C,65535U},{65535U,9U},{65535U,9U}};
    int8_t l_1606 = 0x40;
    struct S0 * const l_1753 = &l_853;
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_906[i] = (void*)0;
    for (i = 0; i < 5; i++)
        l_974[i] = 0U;
lbl_1775:
    if (l_831)
    { /* block id: 353 */
        int32_t **** const *l_844 = (void*)0;
        float l_868 = 0x5.9p-1;
        float *l_867[4][5][7] = {{{&l_868,(void*)0,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,&l_868,(void*)0,&l_868,&l_868,&l_868,&l_868},{(void*)0,&l_868,&l_868,&l_868,&l_868,&l_868,(void*)0},{&l_868,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,&l_868,(void*)0,&l_868,&l_868,&l_868,(void*)0}},{{(void*)0,&l_868,&l_868,(void*)0,&l_868,&l_868,&l_868},{(void*)0,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868}},{{&l_868,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,(void*)0,&l_868,&l_868,&l_868,(void*)0,&l_868},{(void*)0,&l_868,&l_868,&l_868,&l_868,&l_868,(void*)0},{&l_868,&l_868,&l_868,&l_868,(void*)0,&l_868,&l_868},{&l_868,&l_868,&l_868,&l_868,&l_868,(void*)0,&l_868}},{{(void*)0,&l_868,&l_868,(void*)0,(void*)0,&l_868,&l_868},{&l_868,&l_868,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,(void*)0,(void*)0,&l_868,&l_868,(void*)0,&l_868},{(void*)0,(void*)0,&l_868,&l_868,&l_868,&l_868,&l_868},{&l_868,(void*)0,&l_868,&l_868,&l_868,&l_868,(void*)0}}};
        int32_t **l_871 = (void*)0;
        int32_t l_908[2][7][7] = {{{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6},{9,0,(-1),(-8),(-8),(-1),0},{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6},{9,0,(-1),(-8),(-8),(-1),0},{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6},{9,0,(-1),(-8),(-8),(-1),0},{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6}},{{9,0,(-1),(-8),(-8),(-1),0},{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6},{9,0,(-1),(-8),(-8),(-1),0},{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6},{9,0,(-1),(-8),(-8),(-1),0},{(-1),0x3431A5F6,1,3,3,1,0x3431A5F6},{9,0,(-1),(-8),(-8),(-1),0}}};
        int32_t *l_907 = &l_908[0][1][4];
        struct S0 ****l_964 = &l_935;
        int32_t *l_976 = &l_908[0][1][4];
        int i, j, k;
        for (p_5 = 13; (p_5 >= 19); p_5 += 1)
        { /* block id: 356 */
            int32_t *l_834 = &l_831;
            const int32_t *l_836 = &l_831;
            const int32_t **l_835 = &l_836;
            (*l_835) = l_834;
        }
        for (l_831 = (-14); (l_831 >= 21); l_831 += 6)
        { /* block id: 361 */
            uint32_t l_860 = 0x4A1844C9;
            struct S0 ** const *l_869 = &l_864;
            uint16_t l_870 = 0xAD2D;
            const int32_t **l_900 = (void*)0;
            const int32_t ***l_899[2][6][10] = {{{&l_900,(void*)0,&l_900,&l_900,(void*)0,&l_900,(void*)0,&l_900,&l_900,(void*)0},{&l_900,(void*)0,&l_900,&l_900,(void*)0,&l_900,(void*)0,&l_900,&l_900,(void*)0},{&l_900,(void*)0,&l_900,&l_900,(void*)0,&l_900,(void*)0,&l_900,&l_900,(void*)0},{&l_900,(void*)0,&l_900,&l_900,(void*)0,&l_900,(void*)0,&l_900,&l_900,(void*)0},{&l_900,(void*)0,&l_900,&l_900,(void*)0,&l_900,(void*)0,&l_900,(void*)0,(void*)0},{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0}},{{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0},{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0},{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0},{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0},{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0},{&l_900,(void*)0,(void*)0,(void*)0,(void*)0,&l_900,(void*)0,(void*)0,(void*)0,(void*)0}}};
            const int32_t ****l_898 = &l_899[0][3][2];
            int32_t *l_910 = &l_908[1][4][2];
            int32_t *l_945[6] = {&l_908[1][5][2],&l_908[1][5][2],&l_908[1][5][2],&l_908[1][5][2],&l_908[1][5][2],&l_908[1][5][2]};
            int i, j, k;
            for (p_5 = (-13); (p_5 >= (-11)); p_5 += 9)
            { /* block id: 364 */
                l_844 = l_841;
                /* statement id: 365 */
                assert ((l_844 >= &l_842[0][0][0] && l_844 <= &l_842[3][2][0]));
            }
        }
        /* facts after for loop */
        assert ((l_844 >= &l_842[0][0][0] && l_844 <= &l_842[3][2][0]) || l_844 == 0);
    }
    else
    { /* block id: 427 */
        int32_t *l_1013[4][4][1] = {{{&l_831},{&l_831},{&l_831},{&l_831}},{{&l_831},{&l_831},{&l_831},{&l_831}},{{&l_831},{&l_831},{&l_831},{&l_831}},{{&l_831},{&l_831},{&l_831},{&l_831}}};
        uint32_t l_1019 = 0xF65A26FE;
        int32_t **l_1061 = (void*)0;
        int32_t ***l_1060 = &l_1061;
        uint32_t l_1075 = 6U;
        const uint32_t l_1081 = 0xB1D29E74;
        int32_t l_1097 = 0x0FFC3B30;
        uint32_t l_1098 = 9U;
        struct S0 **l_1115 = (void*)0;
        float l_1204[3];
        int8_t l_1227 = (-10);
        int32_t l_1249 = 1;
        int32_t *l_1257 = &l_831;
        const int8_t l_1335 = 0x5B;
        int i, j, k;
        for (i = 0; i < 3; i++)
            l_1204[i] = 0xA.A8E4E5p-32;
        if ((0xECB1 > ((uint16_t)((((l_1013[2][1][0] != l_1013[2][1][0]) == ((int16_t)(((func_62(p_5, p_7.f1) , 8U) ^ (!((int16_t)(((1U >= ((p_5 <= 0x49FE409D) >= p_6)) | l_1019) == p_7.f0) << (int16_t)3))) , p_5) * (int16_t)p_5)) | p_5) <= p_6) / (uint16_t)9)))
        { /* block id: 428 */
            int32_t * const l_1024 = &l_831;
            struct S0 *l_1034 = &l_853;
            struct S0 * const *l_1033[6] = {&l_1034,&l_1034,&l_1034,&l_1034,&l_1034,&l_1034};
            struct S0 ****l_1063 = &l_935;
            struct S0 *****l_1062 = &l_1063;
            int32_t * const *l_1067[2];
            int32_t * const **l_1066 = &l_1067[0];
            int32_t l_1142 = 0x6478336C;
            int32_t *l_1141 = &l_1142;
            int16_t l_1146[9] = {0x2204,0x2204,0x2204,0x2204,0x2204,0x2204,0x2204,0x2204,0x2204};
            int i;
            for (i = 0; i < 2; i++)
                l_1067[i] = &l_906[1];
            if (((int16_t)(((((((void*)0 != &l_842[0][2][0]) && p_6) , (p_7.f0 , ((0x8AA0 != (~((-3) < (!((((void*)0 == l_1024) ^ (0xFEC72645 < (*l_1024))) || 0xDB4615E4))))) <= 9U))) <= p_7.f0) | p_7.f1) || p_7.f1) >> (int16_t)(*l_1024)))
            { /* block id: 429 */
                int32_t l_1030 = (-1);
                struct S0 *l_1032 = &l_853;
                struct S0 **l_1031 = &l_1032;
                (*l_1024) = ((uint32_t)(((uint32_t)(-(int16_t)0xFBD4) - (uint32_t)l_1030) , ((l_1031 == l_1033[3]) < (((int16_t)(&p_7 == &p_7) * (int16_t)(-(uint32_t)p_7.f1)) < ((uint16_t)0x26C3 >> (uint16_t)15)))) + (uint32_t)(((((int16_t)(*l_1024) % (int16_t)0xE912) , p_7.f1) , p_5) , 8));
                (*l_1031) = (*l_1031);
            }
            else
            { /* block id: 432 */
                struct S0 ****l_1045 = &l_935;
                struct S0 ***** const l_1044 = &l_1045;
                int32_t * const *l_1065 = (void*)0;
                int32_t * const ** const l_1064 = &l_1065;
                float *l_1112 = &l_939;
                (*l_1024) = ((uint16_t)(((((void*)0 == l_1044) > 5U) , ((uint16_t)((uint16_t)(((0x1A0876B6 == ((int32_t)p_7.f1 + (int32_t)((int16_t)(-4) + (int16_t)(0x8ED6 || ((int16_t)((uint16_t)((((void*)0 == l_1060) , 0x286FC1A4) ^ p_6) % (uint16_t)p_5) * (int16_t)9))))) > p_7.f0) ^ 0U) << (uint16_t)11) >> (uint16_t)(*l_1024))) <= 0x4314DE43) >> (uint16_t)6);
                (*l_1024) = (((((&l_892 != l_1062) , l_1064) == l_1066) & ((int16_t)(p_6 , ((uint32_t)((-(uint32_t)((uint32_t)l_1075 - (uint32_t)((int16_t)p_7.f0 / (int16_t)0xC40F))) , (((((uint16_t)(func_72(p_7, l_1080) , 65535U) % (uint16_t)l_1081) , p_7.f0) != (-1)) >= p_6)) - (uint32_t)p_5)) * (int16_t)p_7.f1)) > p_5);
                for (l_831 = (-11); (l_831 == 4); l_831 += 1)
                { /* block id: 437 */
                    int32_t l_1092 = 0;
                    const float *l_1113 = &l_939;
                    uint16_t l_1140 = 65535U;
                    uint32_t l_1144 = 0xF6B31AFE;
                    int32_t *l_1158 = &l_1142;
                    if (((p_7.f0 != (p_7.f1 >= ((int16_t)((uint16_t)((int16_t)((int16_t)((void*)0 == &l_1065) * (int16_t)(((p_7.f1 & (((l_1092 | p_7.f0) != (((int16_t)(((int32_t)p_6 - (int32_t)p_7.f1) ^ l_1097) / (int16_t)0xF165) & 0x2E75)) && p_7.f0)) != p_7.f1) & 0x7B6B4D6D)) << (int16_t)13) - (uint16_t)2) << (int16_t)9))) && 0x7FBBDF2E))
                    { /* block id: 438 */
                        int16_t l_1099 = 0xA9AA;
                        int32_t *l_1103 = &l_1092;
                        struct S0 ** const l_1114 = (void*)0;
                        l_1099 = (l_1098 == p_5);
                        (*l_1103) = ((((int16_t)((void*)0 != &l_1066) % (int16_t)0xEBA0) | (~0x2AE6FF9F)) , ((void*)0 != l_1103));
                        (*l_1103) = (((uint16_t)p_7.f1 * (uint16_t)p_7.f0) , 0x314F51F2);
                        (*l_1103) = (((((int16_t)(((p_7.f1 , ((p_6 <= ((int16_t)((int16_t)(((l_1112 != l_1113) & ((l_1114 != l_1115) && (((-(uint32_t)(*l_1024)) , 8) != 0x97507629))) & p_7.f1) >> (int16_t)12) * (int16_t)l_1092)) >= p_7.f1)) >= (*l_1103)) ^ (*l_1103)) * (int16_t)p_5) , p_6) < p_5) <= p_7.f1);
                    }
                    else
                    { /* block id: 443 */
                        uint32_t l_1118 = 0x598602CE;
                        l_1141 = ((((-(int16_t)((l_1118 >= (((int32_t)(((float)((0x1.1p+1 < (((uint32_t)p_5 / (uint32_t)((int32_t)(((int16_t)((uint16_t)l_1118 << (uint16_t)(((int16_t)p_5 - (int16_t)p_7.f1) < (((int16_t)p_7.f1 + (int16_t)((uint16_t)(((uint16_t)(0x4CF15D0A || ((((p_7.f1 ^ p_5) >= 1U) && 0x3DB98C9F) <= p_6)) * (uint16_t)p_7.f1) ^ l_1139) << (uint16_t)p_7.f1)) != p_7.f1))) * (int16_t)p_7.f1) , l_1140) - (int32_t)p_5)) , p_5)) == p_6) / (float)l_1118) , l_1118) + (int32_t)1U) ^ p_7.f0)) & p_7.f0)) && 0xA2559217) == l_1092) , (void*)0);
                        /* statement id: 444 */
                        assert (l_1141 == 0);
                        if (p_5)
                            break;
                        return l_1140;
                    }
                    if (p_7.f0)
                    { /* block id: 448 */
                        int32_t l_1143 = (-4);
                        (*l_1112) = l_1143;
                        l_1144 = (-7);
                        if (p_7.f0)
                            continue;
                    }
                    else
                    { /* block id: 452 */
                        int32_t l_1145 = (-1);
                        int32_t l_1157 = 0x367EFC2E;
                        if (p_7.f1)
                            break;
                        l_1157 = (l_1145 , ((0xE61E2BE0 && (l_1146[6] > ((((int32_t)((!1) > (((((uint16_t)(((((void*)0 != &l_1115) , (void*)0) == (void*)0) , ((uint16_t)(((uint16_t)((l_1145 , 0x44B42413) == (*l_1024)) << (uint16_t)11) || 65534U) * (uint16_t)65531U)) + (uint16_t)0xE887) , l_1156) || p_7.f0) && 5)) / (int32_t)(-1)) , p_5) != 3))) == 6U));
                        l_1158 = (p_7.f0 , (void*)0);
                        /* statement id: 455 */
                        assert (l_1158 == 0);
                    }
                    /* facts after branching */
                    assert (l_1158 == 0 || l_1158 == &l_1142);
                }
                /* facts after for loop */
                assert (l_1141 == 0 || l_1141 == &l_1142);
            }
            /* facts after branching */
            assert (l_1141 == 0 || l_1141 == &l_1142);
        }
        else
        { /* block id: 459 */
            int8_t l_1161 = (-1);
            int32_t * const *l_1166 = (void*)0;
            int32_t * const * const *l_1165 = &l_1166;
            int32_t l_1172 = 0x2456BE99;
            int32_t l_1196 = 0x2D3EE731;
            float l_1250[9] = {(-0x1.6p-1),0x1.6p-1,(-0x1.6p-1),0x1.6p-1,(-0x1.6p-1),0x1.6p-1,(-0x1.6p-1),0x1.6p-1,(-0x1.6p-1)};
            struct S0 *l_1261 = (void*)0;
            struct S0 ***l_1280[4] = {&l_864,&l_864,&l_864,&l_864};
            int32_t ***l_1311 = &l_1061;
            int i;
            if (((((((4294967295U != ((p_5 < ((uint16_t)(0x28C3 ^ ((((l_1161 || l_1162[0][0][0]) & (((l_1161 , ((int16_t)((l_1161 , l_1165) != &l_1061) >> (int16_t)p_7.f1)) > p_5) <= p_7.f0)) < 0) , 0xDBF7)) << (uint16_t)5)) | p_5)) == (-7)) < p_6) ^ p_5) , 0U) , p_7.f0))
            { /* block id: 460 */
                float *l_1171[7];
                int32_t l_1181 = 2;
                struct S0 **l_1226 = (void*)0;
                int i;
                for (i = 0; i < 7; i++)
                    l_1171[i] = &l_939;
                for (l_1075 = 0; (l_1075 != 50); l_1075 += 5)
                { /* block id: 463 */
                    for (l_1139 = 0; (l_1139 <= 54); l_1139++)
                    { /* block id: 466 */
                        if (p_6)
                            break;
                    }
                    if (p_5)
                        break;
                }
                l_1172 = (p_6 >= (&l_1061 == (void*)0));
                for (l_831 = 0; (l_831 <= 0); l_831 += 1)
                { /* block id: 474 */
                    uint32_t l_1178 = 5U;
                    const int32_t *l_1195 = &l_831;
                    int32_t l_1205 = 0xE301B1E3;
                    int i;
                    l_1181 = ((int16_t)((((int16_t)p_6 * (int16_t)(-(int32_t)(l_1178 && 0xE1A8))) | ((int16_t)l_1181 >> (int16_t)((int32_t)((int16_t)p_7.f1 << (int16_t)9) / (int32_t)((uint16_t)((int16_t)l_1178 >> (int16_t)(&l_1181 != (void*)0)) << (uint16_t)(l_1181 ^ 8))))) == p_7.f0) * (int16_t)p_7.f0);
                    if (p_7.f1)
                        continue;
                    l_906[l_831] = &l_1172;
                    for (l_1172 = 0; (l_1172 >= 0); l_1172 -= 1)
                    { /* block id: 480 */
                        l_1181 = ((uint32_t)(0xC739 != ((0xB1DA >= (((((int32_t)(~(-6)) + (int32_t)(l_1181 , ((void*)0 != &l_1060))) , p_7.f1) > (l_1195 == (void*)0)) & 0x82E83132)) | p_5)) - (uint32_t)p_5);
                        l_1196 = p_7.f1;
                        if (p_7.f1)
                            break;
                        (*l_891) = (*l_891);
                    }
                    for (l_1181 = 0; (l_1181 <= 0); l_1181 += 1)
                    { /* block id: 488 */
                        uint16_t l_1201 = 1U;
                        l_1205 = ((((((uint16_t)(l_1201 && (p_7.f0 >= l_1181)) << (uint16_t)7) | (p_5 , (65535U == 65528U))) == ((uint16_t)0xA78C >> (uint16_t)2)) & ((l_1201 || (0xA26BD9CD < p_5)) >= 0xFCFB1C62)) , 0x1.1p-1);
                        l_1227 = ((p_7 , ((8 != ((uint16_t)(-(uint16_t)(((p_7.f0 , ((int16_t)((uint16_t)((int16_t)((int32_t)(((((5U >= p_5) < p_7.f1) != p_6) & 4294967289U) > ((int16_t)((uint16_t)((-(uint16_t)((((int32_t)((uint16_t)((l_1115 != l_1226) || 0x7845EDF5) << (uint16_t)4) / (int32_t)7) , p_6) , l_1181)) <= l_1181) >> (uint16_t)p_5) % (int16_t)l_1201)) % (int32_t)p_7.f0) << (int16_t)p_5) / (uint16_t)l_1201) * (int16_t)0x9E71)) == p_5) && 0x8A2B)) + (uint16_t)p_5)) != l_1201)) ^ 0xD5DB);
                        return p_5;
                    }
                }
                /* facts after for loop */
                //assert (l_906[0] == &l_1172 || l_906[0] == 0);
            }
            else
            { /* block id: 494 */
                int32_t *l_1258 = &l_1172;
                struct S0 *l_1262 = (void*)0;
                float *l_1263 = (void*)0;
                float *l_1264 = &l_1204[1];
                int32_t *** const *l_1276[2];
                int32_t *** const **l_1275 = &l_1276[1];
                struct S0 *** const l_1281 = (void*)0;
                int i;
                for (i = 0; i < 2; i++)
                    l_1276[i] = &l_843;
                for (p_6 = 0; (p_6 <= 0); p_6 += 1)
                { /* block id: 497 */
                    int16_t l_1232 = 0x0A95;
                    int32_t l_1252[6][5] = {{(-1),0x85BD04E8,0x19A0EAA5,(-1),0},{0xFD105797,(-1),3,(-1),0xFD105797},{0x19A0EAA5,0x4B89E275,0x85BD04E8,0,0x4B89E275},{0xFD105797,0x85BD04E8,0x85BD04E8,0xFD105797,0},{(-1),0xFD105797,3,0x4B89E275,0x4B89E275},{0x19A0EAA5,0xFD105797,0x19A0EAA5,0,0xFD105797}};
                    int i, j;
                    l_1252[2][2] = (((uint16_t)((int16_t)l_974[(p_6 + 2)] % (int16_t)(p_5 & 0x98E0)) + (uint16_t)l_974[(p_6 + 2)]) < (l_1232 < ((int32_t)((uint32_t)((int16_t)((((uint16_t)((((uint16_t)(((uint32_t)((uint32_t)0x1AA937B3 + (uint32_t)(((0x1AA2 > 7) , ((int16_t)l_1249 >> (int16_t)l_974[(p_6 + 2)])) > p_7.f1)) / (uint32_t)0xEE1975C6) & l_1251) << (uint16_t)14) , p_7.f0) < p_5) * (uint16_t)0xF89A) == p_7.f0) >= 0xD2EA342F) / (int16_t)p_7.f0) % (uint32_t)0x9552F713) - (int32_t)4294967290U)));
                    if ((0xD4F55B95 <= ((uint16_t)((((uint16_t)5U % (uint16_t)p_7.f1) | (l_1257 != l_1258)) <= p_7.f1) + (uint16_t)(*l_1258))))
                    { /* block id: 499 */
                        int32_t l_1259 = 0x63AC9A2E;
                        if (p_5)
                            break;
                        if (l_1259)
                            continue;
                        return p_7.f0;
                    }
                    else
                    { /* block id: 503 */
                        int8_t l_1260 = (-7);
                        (*l_1257) = ((*l_1257) , l_1260);
                        l_1262 = l_1261;
                        return p_7.f1;
                    }
                }
                (*l_1264) = 0xA.234BF2p+10;
                if ((p_7.f1 && (p_7.f1 | ((((p_6 > (*l_1258)) != ((uint16_t)0x068B / (uint16_t)(*l_1258))) == ((int16_t)(((int16_t)((((uint32_t)(((int32_t)((l_1275 == &l_1276[0]) > ((uint32_t)(~(((l_1280[0] == l_1281) , p_6) >= 0x3C4D7C80)) % (uint32_t)(*l_1257))) / (int32_t)0x9D90C032) > p_7.f1) + (uint32_t)0xCA0B215A) ^ p_7.f1) , 0) % (int16_t)p_5) & p_7.f1) << (int16_t)p_7.f0)) > p_6))))
                { /* block id: 510 */
                    struct S0 l_1286 = {7,0xFB};
                    float *l_1287 = (void*)0;
                    int32_t **l_1316 = &l_906[1];
                    if ((((int32_t)((uint32_t)((l_1286 , l_1287) != (void*)0) + (uint32_t)((uint16_t)((*l_1257) <= (0x00FA | p_7.f0)) >> (uint16_t)(((int16_t)1 + (int16_t)((uint16_t)(-(uint32_t)((&p_7 == (void*)0) != 0x50C03084)) * (uint16_t)(-1))) != (*l_1258)))) + (int32_t)p_7.f1) && 1U))
                    { /* block id: 511 */
                        int16_t l_1305 = 0xEB1C;
                        struct S0 **l_1310[2][4] = {{&l_1262,&l_1262,&l_1262,&l_1262},{&l_1262,&l_1262,&l_1262,&l_1262}};
                        int i, j;
                        (*l_1257) = (((uint16_t)0xD731 >> (uint16_t)14) == ((uint16_t)((uint16_t)((int16_t)p_6 << (int16_t)1) * (uint16_t)(((void*)0 != l_1281) >= ((uint16_t)l_1305 << (uint16_t)p_7.f1))) * (uint16_t)((uint32_t)((uint16_t)((void*)0 != l_1310[1][2]) % (uint16_t)l_1305) + (uint32_t)0x5C8EA6B9)));
                        l_1311 = &l_1061;
                        (*l_1258) = ((p_5 , l_1287) == (((int16_t)(((uint16_t)((p_6 || (p_7.f1 != p_6)) && (l_1316 == (*l_1060))) / (uint16_t)p_6) ^ 0U) << (int16_t)1) , (void*)0));
                    }
                    else
                    { /* block id: 515 */
                        (*l_1316) = (*l_1316);
                    }
                    for (l_1080 = (-20); (l_1080 <= 55); l_1080 += 1)
                    { /* block id: 520 */
                        uint16_t l_1319[1];
                        int32_t l_1334 = (-4);
                        int i;
                        for (i = 0; i < 1; i++)
                            l_1319[i] = 0xECA0;
                        l_1334 = (l_1319[0] >= ((((float)((((float)(p_6 != ((float)(-0x1.Fp-1) - (float)(0x7.B1B6DEp+50 >= ((float)(((float)l_1319[0] / (float)((float)p_5 - (float)((((p_5 == (((int16_t)p_7.f1 * (int16_t)((0x1F77 && 1) & 0x80FD)) , 0xE.0A358Fp+67)) >= p_5) < p_7.f0) >= p_5))) < p_6) * (float)(*l_1257))))) / (float)l_1319[0]) == p_5) , l_1319[0]) / (float)l_1319[0]) , 0x0F6C) , 0U));
                        (*l_1257) = p_7.f1;
                    }
                    (*l_1316) = (*l_1316);
                    return p_7.f1;
                }
                else
                { /* block id: 526 */
                    return p_7.f1;
                }
            }
            /* facts after branching */
            //assert (l_906[0] == &l_1172 || l_906[0] == 0);
        }
        /* facts after branching */
        //assert (l_906[0] == dangling || l_906[0] == 0);
        return l_1335;
    }
    if ((((int16_t)p_7.f0 % (int16_t)((int16_t)(p_7.f1 >= ((int16_t)((uint16_t)0U >> (uint16_t)(((int32_t)0xC567BD2A + (int32_t)(p_5 , ((((int32_t)p_5 % (int32_t)((uint16_t)(~((l_1351 == (void*)0) <= 0)) << (uint16_t)10)) != 0xEC53BEE9) > p_5))) || p_7.f1)) * (int16_t)1)) >> (int16_t)p_6)) != 0xAE69299C))
    { /* block id: 533 */
        int32_t *l_1352[9][4] = {{&l_831,(void*)0,&l_831,&l_831},{&l_831,(void*)0,(void*)0,&l_831},{&l_831,&l_831,&l_831,(void*)0},{&l_831,(void*)0,&l_831,&l_831},{&l_831,&l_831,(void*)0,&l_831},{(void*)0,(void*)0,(void*)0,(void*)0},{&l_831,&l_831,&l_831,&l_831},{&l_831,(void*)0,&l_831,(void*)0},{&l_831,&l_831,&l_831,&l_831}};
        struct S0 *l_1363 = &l_853;
        struct S0 **l_1362 = &l_1363;
        struct S0 *l_1374 = &l_853;
        int32_t l_1379 = (-1);
        uint32_t l_1404[10][6] = {{0x81192714,4294967289U,4294967295U,1U,1U,4294967295U},{1U,1U,4294967295U,4294967289U,0x81192714,4294967295U},{4294967289U,0x81192714,4294967295U,0x81192714,4294967289U,4294967295U},{0x81192714,4294967289U,4294967295U,1U,1U,4294967295U},{1U,1U,4294967295U,4294967289U,0x81192714,4294967295U},{4294967289U,0x81192714,4294967295U,0x81192714,4294967289U,4294967295U},{0x81192714,4294967289U,4294967295U,1U,1U,4294967295U},{1U,1U,4294967295U,4294967289U,0x81192714,4294967295U},{4294967289U,0x81192714,4294967295U,0x81192714,4294967289U,4294967295U},{0x81192714,4294967289U,4294967295U,1U,1U,4294967295U}};
        struct S0 ****l_1422 = &l_863;
        struct S0 *****l_1421 = &l_1422;
        const int32_t ****l_1436 = (void*)0;
        const int32_t *****l_1435 = &l_1436;
        int16_t l_1448 = 0;
        uint32_t l_1523[3];
        int32_t **l_1524[2];
        uint16_t l_1538 = 0x57E3;
        int i, j;
        for (i = 0; i < 3; i++)
            l_1523[i] = 0xB50A0B6D;
        for (i = 0; i < 2; i++)
            l_1524[i] = &l_906[1];
        l_1352[3][1] = (*l_1351);
        l_1352[3][1] = l_1352[3][1];
        if (((int16_t)p_6 << (int16_t)14))
        { /* block id: 536 */
            int32_t *l_1355 = &l_831;
            l_1355 = l_1352[3][1];
            /* statement id: 537 */
            assert (l_1355 == 0 || l_1355 == &l_831);
            for (p_5 = 5; (p_5 <= (-1)); p_5--)
            { /* block id: 540 */
                return p_7.f1;
            }
        }
        else
        { /* block id: 543 */
            float l_1380 = (-0x1.6p-1);
            float *l_1381[5] = {&l_1380,&l_1380,&l_1380,&l_1380,&l_1380};
            int32_t l_1382 = (-8);
            struct S0 ****l_1385 = &l_863;
            const int32_t l_1405 = 0x300D2334;
            float l_1406 = 0x6.1D6713p+61;
            int32_t l_1417 = 0x0BB02FAB;
            int i;
            l_1382 = ((p_5 , (p_5 , (((float)((p_5 >= ((float)(((l_1362 == (*l_935)) | ((uint16_t)(((((int32_t)1 - (int32_t)(((((((uint32_t)((((uint16_t)((uint32_t)(l_1374 != (*l_1362)) - (uint32_t)((uint16_t)((int32_t)0x3451435B + (int32_t)p_7.f0) >> (uint16_t)p_7.f1)) << (uint16_t)p_6) == 0x79F061F6) ^ 0xC21C) - (uint32_t)p_5) > 0x8E2F) && p_7.f1) , p_5) || p_7.f0) == l_1379)) || 0x5D40) == 0x9320FEA9) , 7U) >> (uint16_t)p_6)) , p_7.f0) + (float)p_5)) != l_1380) + (float)p_7.f0) >= 0x0.Ep-1))) <= 0x2.D5F654p+69);
            if (p_7.f1)
                goto lbl_1407;
lbl_1407:
            (*l_1351) = ((((int16_t)(((((((*l_891) != l_1385) == 0xC96D6E39) >= p_7.f0) >= (0x87F30CAF >= ((((uint16_t)((int16_t)(((((int16_t)(l_1385 == (void*)0) >> (int16_t)((int16_t)((((uint16_t)((int16_t)((((int16_t)((uint16_t)((uint16_t)(4294967295U < ((((*l_841) == (void*)0) | l_1404[1][0]) ^ p_6)) << (uint16_t)l_1382) - (uint16_t)(-10)) + (int16_t)0x1FF4) , p_7.f0) , p_6) % (int16_t)p_5) / (uint16_t)0xAB10) | p_5) ^ l_1382) + (int16_t)0xDE7E)) && (-1)) < l_1382) < (-1)) >> (int16_t)12) * (uint16_t)0xB0FD) < l_1382) , l_1405))) <= p_5) && 0x92CA) * (int16_t)0x48F8) != p_6) , &l_1382);
            /* statement id: 545 */
            //assert (l_906[0] == &l_1382 || l_906[0] == 0);
            for (l_1139 = 0; (l_1139 < 20); l_1139 += 9)
            { /* block id: 549 */
                int8_t l_1412[10] = {0xCA,(-2),0xCA,0xCA,(-2),0xCA,0xCA,(-2),0xCA,0xCA};
                int32_t l_1414[1];
                struct S0 **l_1451 = (void*)0;
                int i;
                for (i = 0; i < 1; i++)
                    l_1414[i] = 1;
                for (p_6 = 0; (p_6 >= 3); p_6 += 1)
                { /* block id: 552 */
                    int32_t *l_1413 = &l_1379;
                    struct S0 ** const l_1420 = &l_1363;
                    struct S0 ** const *l_1425 = &l_1420;
                    struct S0 ** const **l_1424 = &l_1425;
                    struct S0 ** const ***l_1423[9][6] = {{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424},{&l_1424,&l_1424,&l_1424,&l_1424,&l_1424,&l_1424}};
                    int i, j;
                    for (l_831 = 0; (l_831 <= 5); l_831 += 1)
                    { /* block id: 555 */
                        int32_t *****l_1426[4];
                        int i;
                        for (i = 0; i < 4; i++)
                            l_1426[i] = (void*)0;
                        l_1414[0] = (((l_1412[3] && p_7.f1) <= (1U && p_6)) <= (l_1413 == ((*l_1363) , &l_1379)));
                        (*l_1413) = ((int32_t)(-8) - (int32_t)(l_1417 <= ((((uint16_t)(l_1420 == (void*)0) >> (uint16_t)(((**l_1420) , l_1421) != l_1423[0][1])) > ((void*)0 != l_1426[2])) , p_7.f1)));
                        (*l_1351) = &l_1379;
                    }
                    for (l_831 = (-11); (l_831 > 29); l_831++)
                    { /* block id: 562 */
                        const float l_1429 = 0xF.B8E051p-97;
                        return l_1414[0];
                    }
                }
                if ((((-2) | (!l_1405)) >= ((uint16_t)((int16_t)p_7.f0 * (int16_t)1) << (uint16_t)((((p_6 , &l_842[0][1][0]) != l_1435) & 0x68F17C10) ^ ((0xB19C9668 > p_6) >= l_1405)))))
                { /* block id: 566 */
                    int32_t l_1441 = 8;
                    for (l_831 = 0; (l_831 != 20); l_831 += 5)
                    { /* block id: 569 */
                        if (p_7.f1)
                            break;
                    }
                    l_1441 = ((((float)l_1441 / (float)0x0.7p+1) != (((&l_1385 != &l_1422) > p_7.f0) == (!0x1.Cp+1))) , ((void*)0 != (*l_1435)));
                    l_1417 = (-(int32_t)1);
                }
                else
                { /* block id: 574 */
                    if (p_7.f0)
                    { /* block id: 575 */
                        const uint32_t l_1444 = 0x21B29E8B;
                        return l_1444;
                    }
                    else
                    { /* block id: 577 */
                        return p_5;
                    }
                }
                (*l_1435) = (((!0U) <= (((int16_t)p_7.f0 / (int16_t)1U) ^ ((l_1448 & ((int16_t)(((((l_1405 , (void*)0) == (void*)0) , (((void*)0 != l_1451) == p_7.f0)) || 1U) == p_7.f0) * (int16_t)l_1382)) , p_7.f1))) , (void*)0);
            }
            /* facts after for loop */
            //assert (l_906[0] == &l_1379 || l_906[0] == &l_1382 || l_906[0] == 0);
        }
        /* facts after branching */
        //assert (l_906[0] == &l_1379 || l_906[0] == dangling || l_906[0] == 0);
        if (((int32_t)0xF43B720A + (int32_t)((p_7.f0 , (((uint32_t)((int16_t)(((int16_t)(((&l_1436 != &l_1436) | p_6) != (((uint16_t)(((int32_t)p_5 + (int32_t)((void*)0 != l_1352[6][3])) && p_7.f0) % (uint16_t)p_7.f0) == p_7.f0)) + (int16_t)1U) && p_7.f0) >> (int16_t)p_5) % (uint32_t)p_5) < p_5)) != 0xABA8)))
        { /* block id: 584 */
            uint32_t l_1464 = 0x04AF2BCF;
            float *l_1465 = &l_939;
            uint32_t l_1484 = 0x73C1DB89;
            const int8_t l_1485 = 0xB2;
            const int8_t l_1486 = 1;
            int32_t l_1494 = 0;
            int32_t **l_1502 = &l_906[0];
            (*l_1465) = l_1464;
            for (l_1464 = 0; (l_1464 <= 1); l_1464 += 1)
            { /* block id: 588 */
                int32_t *****l_1477 = &l_842[2][2][0];
                struct S0 **l_1488[3][1];
                int i, j;
                for (i = 0; i < 3; i++)
                {
                    for (j = 0; j < 1; j++)
                        l_1488[i][j] = &l_1363;
                }
                if (p_7.f0)
                { /* block id: 589 */
                    float *l_1478 = &l_939;
                    int32_t l_1481 = 0x68E74BCC;
                    struct S0 * const * const l_1487 = &l_1374;
                    (*l_1478) = (((int32_t)((0x48F2559A & 0xF694FCC7) <= (((uint16_t)((int16_t)(((((((l_1464 , ((((uint16_t)(~((int16_t)(l_1477 != (func_72(func_15((((((((l_1465 == l_1478) , ((((float)l_1481 * (float)((float)(((-0x1.3p-1) >= (l_1484 == l_1485)) > p_7.f1) - (float)p_7.f1)) == p_5) > (-0x3.Ep-1))) == p_5) > (-0x1.Ep+1)) , p_5) & 0x5E7CD31B) <= l_1486), p_5, p_6, p_6), p_5) , (void*)0)) / (int16_t)p_5)) - (uint16_t)0x3F6E) | 0x9B64) > 0x0BA4C1FE)) < l_1481) & p_7.f1) , l_1487) != l_1488[1][0]) & p_7.f0) < 0x5BF0) + (int16_t)(-8)) << (uint16_t)13) & 0)) + (int32_t)l_1489[4][1]) , (-0x1.5p-1));
                    l_1494 = ((uint32_t)((int16_t)(-1) << (int16_t)14) / (uint32_t)5U);
                }
                else
                { /* block id: 592 */
                    uint32_t l_1495 = 1U;
                    l_1495 = p_7.f0;
                    for (l_1484 = 0; l_1484 < 4; l_1484 += 1)
                    {
                        for (l_831 = 0; l_831 < 3; l_831 += 1)
                        {
                            for (l_1080 = 0; l_1080 < 1; l_1080 += 1)
                            {
                                l_842[l_1484][l_831][l_1080] = &l_843;
                            }
                        }
                    }
                }
                for (p_6 = 0; (p_6 <= 1); p_6 += 1)
                { /* block id: 598 */
                    int8_t l_1509[5][8][6] = {{{(-1),0x37,4,0xB2,0x02,0xF6},{0x2B,0,(-7),0x02,0x37,0xC3},{0x2B,0,0x7D,0xB2,(-1),0},{(-1),0x02,1,0x80,0x80,1},{0x02,0x02,1,(-1),(-1),(-1)},{0,0,0xEC,0xDE,0x37,1},{0xB2,0,0xEC,0x37,0x02,(-1)},{(-1),0x37,1,0x94,0x2B,1}},{{0x94,0x2B,1,0x94,0xDE,0},{(-1),0x80,0x7D,0x83,1,(-1)},{1,3,(-1),3,1,(-1)},{0,0,0x37,0x93,3,0xDE},{0xBD,(-2),0x2B,0,(-2),0xDE},{0x93,0x83,0x37,1,0xBD,(-1)},{(-2),0,(-1),0xBD,0x1C,(-1)},{(-2),0x56,0xDE,1,0xCB,0}},{{0x93,0xBD,0x94,0,0,0x94},{0xBD,0xBD,0,0x93,0xCB,0x2B},{0,0x56,0x80,3,0x1C,0},{1,0,0x80,0x83,0xBD,0x2B},{0xE9,0x83,0,(-1),(-2),0x94},{(-1),(-2),0x94,(-1),3,0},{0xE9,0,0xDE,0x83,1,(-1)},{1,3,(-1),3,1,(-1)}},{{0,0,0x37,0x93,3,0xDE},{0xBD,(-2),0x2B,0,(-2),0xDE},{0x93,0x83,0x37,1,0xBD,(-1)},{(-2),0,(-1),0xBD,0x1C,(-1)},{(-2),0x56,0xDE,1,0xCB,0},{0x93,0xBD,0x94,0,0,0x94},{0xBD,0xBD,0,0x93,0xCB,0x2B},{0,0x56,0x80,3,0x1C,0}},{{1,0,0x80,0x83,0xBD,0x2B},{0xE9,0x83,0,(-1),(-2),0x94},{(-1),(-2),0x94,(-1),3,0},{0xE9,0,0xDE,0x83,1,(-1)},{1,3,(-1),3,1,(-1)},{0,0,0x37,0x93,3,0xDE},{0xBD,(-2),0x2B,0,(-2),0xDE},{0x93,0x83,0x37,1,0xBD,(-1)}}};
                    int32_t l_1510[1];
                    struct S0 *****l_1511 = &l_1422;
                    int i, j, k;
                    for (i = 0; i < 1; i++)
                        l_1510[i] = 0x438A7B71;
                    for (l_831 = 0; (l_831 <= 2); l_831 += 1)
                    { /* block id: 601 */
                        int i, j, k;
                        l_1494 = ((int16_t)(((uint32_t)((int16_t)0xF682 + (int16_t)0xEA99) / (uint32_t)((((l_1502 != (void*)0) || ((uint32_t)((((uint32_t)(l_975[(l_831 + 5)][(l_1464 + 8)][l_1464] , (((((l_975[p_6][(l_1464 + 7)][l_831] | l_975[(p_6 + 5)][(l_831 + 1)][(p_6 + 1)]) | ((uint16_t)((*l_891) != (void*)0) / (uint16_t)0x10F1)) , 0xCAD40E70) >= p_7.f0) <= l_1509[0][3][0])) % (uint32_t)l_975[(l_831 + 5)][(l_1464 + 8)][l_1464]) <= l_1509[0][7][4]) >= 65528U) + (uint32_t)0xC26EB9FF)) != p_6) && p_7.f1)) , 0x181F) >> (int16_t)9);
                        l_1510[0] = p_5;
                    }
                    for (l_1139 = 0; (l_1139 <= 1); l_1139 += 1)
                    { /* block id: 607 */
                        l_1511 = l_1511;
                        return p_6;
                    }
                }
            }
            return p_5;
        }
        else
        { /* block id: 614 */
            uint32_t l_1514[4];
            int32_t **l_1525 = &l_906[1];
            float l_1526[7][3] = {{0x8.AAFD48p-3,0x1.7p-1,0x8.AAFD48p-3},{0x2.8C8B78p-12,0x2.8C8B78p-12,0x2.8C8B78p-12},{0x8.AAFD48p-3,0x1.7p-1,0x8.AAFD48p-3},{0x2.8C8B78p-12,0x2.8C8B78p-12,0x2.8C8B78p-12},{0x8.AAFD48p-3,0x1.7p-1,0x8.AAFD48p-3},{0x2.8C8B78p-12,0x2.8C8B78p-12,0x2.8C8B78p-12},{0x8.AAFD48p-3,0x1.7p-1,0x8.AAFD48p-3}};
            int32_t l_1527 = 0xB229D846;
            int32_t *****l_1561 = &l_842[0][2][0];
            int i, j;
            for (i = 0; i < 4; i++)
                l_1514[i] = 1U;
            l_1527 = (((uint16_t)((l_1514[1] || ((l_1514[2] , (*l_1421)) == (void*)0)) , ((((((uint32_t)p_7.f1 - (uint32_t)((((int16_t)p_7.f1 << (int16_t)10) < ((p_6 < ((uint16_t)0x26EE >> (uint16_t)3)) < ((uint32_t)(p_6 & (-2)) / (uint32_t)p_7.f1))) , l_1523[2])) == p_5) , l_1524[1]) == l_1525) <= (-1))) / (uint16_t)p_6) , 1);
            for (p_6 = 0; (p_6 <= 15); p_6++)
            { /* block id: 618 */
                int32_t l_1536 = 0;
                for (l_1379 = 0; (l_1379 >= 21); l_1379++)
                { /* block id: 621 */
                    (*l_1525) = &l_1527;
                    if (p_7.f1)
                        continue;
                }
                for (l_1448 = 0; (l_1448 != (-14)); l_1448 -= 7)
                { /* block id: 627 */
                    uint16_t l_1537 = 0xE0B4;
                    int32_t *l_1562 = (void*)0;
                    int32_t l_1563 = 0x1F25141C;
                    for (l_1080 = (-17); (l_1080 >= 40); l_1080 += 1)
                    { /* block id: 630 */
                        if (l_1536)
                            break;
                        if (p_6)
                            break;
                        if (l_1537)
                            continue;
                    }
                    l_1563 = (l_1538 >= (0xE.712C86p-27 >= ((float)((float)((float)((((float)((float)(((float)(((((int16_t)((int16_t)((((int16_t)((int16_t)((int16_t)p_7.f0 << (int16_t)l_1536) * (int16_t)(p_5 >= (((((((5 | ((**l_1421) == ((&l_1436 == l_1561) , (void*)0))) < 0x97B4BA3D) & 1U) , l_1562) != l_1562) , p_7.f0) < p_5))) / (int16_t)l_1536) && 0U) , p_6) << (int16_t)p_7.f1) >> (int16_t)l_1537) , p_6) <= 0x5029) , p_6) / (float)l_1514[0]) >= 0x6.Ap+1) - (float)0x0.8p+1) * (float)p_7.f0) >= 0x2.7p-1) < 0x0.1p+1) + (float)(-0x2.Bp-1)) * (float)l_1536) / (float)p_7.f1)));
                }
            }
            /* facts after for loop */
            //assert (l_906[0] == &l_1527 || l_906[0] == &l_1379 || l_906[0] == dangling || l_906[0] == 0);
        }
    }
    else
    { /* block id: 639 */
        uint32_t l_1566 = 8U;
        struct S0 ***l_1599 = &l_864;
        int32_t ***l_1604 = (void*)0;
        float *l_1655 = (void*)0;
        int8_t l_1719 = 0xCA;
        int32_t l_1734 = 0x7F003F05;
        for (p_5 = 0; (p_5 == 27); p_5 += 1)
        { /* block id: 642 */
            float l_1567 = 0x7.89CB5Fp-95;
            int32_t l_1568 = 0;
            l_1568 = (l_1566 , 0xA7D0B08D);
        }
        if (((int32_t)(1 & ((((uint32_t)l_1566 % (uint32_t)((int16_t)l_1566 + (int16_t)0U)) , (*l_841)) != (*l_841))) + (int32_t)(p_7.f0 & ((uint16_t)p_7.f1 * (uint16_t)2U))))
        { /* block id: 645 */
            uint16_t l_1583 = 9U;
            struct S0 ***l_1598 = &l_864;
            int32_t ***l_1605 = &l_1351;
            float l_1663 = 0x6.9FE795p-67;
            const int8_t l_1684 = 0x54;
            const int32_t *l_1696[10][3][6] = {{{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,(void*)0,&l_831,&l_831,&l_831}},{{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}},{{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,(void*)0,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,(void*)0,&l_831,&l_831}},{{&l_831,&l_831,&l_831,&l_831,&l_831,(void*)0},{&l_831,&l_831,(void*)0,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}},{{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}},{{&l_831,&l_831,&l_831,(void*)0,&l_831,&l_831},{&l_831,(void*)0,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}},{{&l_831,(void*)0,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,(void*)0,(void*)0,(void*)0,(void*)0},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}},{{(void*)0,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,(void*)0,&l_831,&l_831,&l_831},{(void*)0,&l_831,&l_831,&l_831,&l_831,&l_831}},{{&l_831,&l_831,&l_831,(void*)0,(void*)0,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}},{{&l_831,(void*)0,(void*)0,&l_831,(void*)0,&l_831},{&l_831,&l_831,&l_831,(void*)0,&l_831,&l_831},{&l_831,&l_831,&l_831,&l_831,&l_831,&l_831}}};
            uint16_t l_1717 = 65535U;
            int i, j, k;
            if (((uint32_t)(((int32_t)((uint16_t)((l_1583 || l_1583) <= (l_1566 , (((((int16_t)((((((int32_t)p_6 / (int32_t)((int16_t)(((((uint16_t)(((((1U | ((((float)(((int16_t)((((int16_t)(p_7.f0 & (l_1598 == l_1599)) * (int16_t)((((int16_t)p_5 * (int16_t)p_7.f1) ^ 0) == 0U)) && 0x6F13A0CB) != 0xB2080AB7) << (int16_t)7) , l_1583) / (float)0x4.57F82Fp+82) , l_1604) != l_1605)) & 0U) < 1) <= p_7.f1) , 0x82DB) / (uint16_t)p_7.f0) && p_6) ^ p_7.f0) & 5U) % (int16_t)p_7.f1)) >= p_6) , &l_1604) == &l_1605) || l_1606) % (int16_t)p_5) , p_5) | p_7.f1) & p_7.f1))) / (uint16_t)p_6) / (int32_t)(-1)) , p_6) % (uint32_t)0x66CD3B69))
            { /* block id: 646 */
                int32_t l_1607 = 0x722E727A;
                int8_t l_1628 = 0x30;
                int32_t l_1629[2][10] = {{0x7D2F295A,0x5BDF62D8,1,0x5BDF62D8,0x7D2F295A,1,(-1),(-1),1,0x7D2F295A},{0x7D2F295A,4,4,0x7D2F295A,0x5043BC8D,0x967AB8CD,0x7D2F295A,0x967AB8CD,0x5043BC8D,0x7D2F295A}};
                int32_t *** const l_1665[9] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
                struct S0 ****l_1674 = &l_935;
                float l_1716 = 0x1.C76F75p+31;
                int32_t l_1718[2][3][9];
                int i, j, k;
                for (i = 0; i < 2; i++)
                {
                    for (j = 0; j < 3; j++)
                    {
                        for (k = 0; k < 9; k++)
                            l_1718[i][j][k] = 1;
                    }
                }
                l_1607 = 0xF7B3A1D4;
                for (l_831 = 1; (l_831 >= 0); l_831 -= 1)
                { /* block id: 650 */
                    int32_t l_1610 = 1;
                    int32_t l_1627 = 0;
                    if ((p_7.f1 != ((int16_t)((l_1610 | ((uint16_t)(((((((((uint16_t)65533U - (uint16_t)(1U == ((int16_t)((((int32_t)p_5 - (int32_t)(-(uint16_t)((uint16_t)1U / (uint16_t)65532U))) && ((((((uint16_t)(((((int16_t)(-(int32_t)(0x43F1 && ((-1) >= p_7.f1))) % (int16_t)p_6) != l_1627) ^ (-1)) , 65535U) / (uint16_t)5) || p_6) > p_7.f0) ^ 0xF4BD3792) || p_5)) > 0xCF48) + (int16_t)p_5))) >= l_1610) > l_1627) != p_6) == p_7.f0) <= l_1607) > l_1610) > l_1610) + (uint16_t)p_6)) ^ (-1)) >> (int16_t)p_7.f0)))
                    { /* block id: 651 */
                        if (p_5)
                            break;
                    }
                    else
                    { /* block id: 653 */
                        int16_t l_1638 = 0xDCA2;
                        l_1629[1][4] = l_1628;
                        l_1610 = (((0xB3AE9EDF || ((((int16_t)((uint16_t)p_7.f0 << (uint16_t)((uint16_t)p_5 << (uint16_t)8)) % (int16_t)l_1627) >= (l_1638 , (((int16_t)l_1638 - (int16_t)((int16_t)(((((uint16_t)(((uint16_t)((((uint16_t)((uint32_t)(p_7.f0 <= ((int16_t)(p_7.f0 <= ((uint32_t)((p_5 < p_5) || p_7.f1) - (uint32_t)0x1F4CF666)) + (int16_t)p_6)) + (uint32_t)1) + (uint16_t)p_7.f1) > l_1638) == 0x6D539030) * (uint16_t)0x6B53) , l_1638) % (uint16_t)0x7EE1) < l_1627) <= p_7.f1) != l_1610) >> (int16_t)12)) >= 1U))) != 4294967295U)) || 0U) == 4294967291U);
                        if (p_7.f1)
                            break;
                    }
                    return l_1627;
                }
                if ((l_1655 != l_1655))
                { /* block id: 660 */
                    int32_t *l_1656 = (void*)0;
                    int32_t ****l_1666 = &l_1605;
                    l_1656 = l_1656;
                    for (p_6 = 15; (p_6 < 4); p_6 -= 6)
                    { /* block id: 664 */
                        (*l_1351) = (void*)0;
                        (**l_1605) = &l_1629[1][4];
                    }
                    /* facts after for loop */
                    //assert ((l_906[0] >= &l_1629[0][0] && l_906[0] <= &l_1629[1][9]) || l_906[0] == 0);
                    l_1629[1][4] = ((((float)(func_35((((float)(p_6 >= (((func_35(p_5, (((((((((-(uint32_t)((func_35(p_5, l_1628) , (((0x8.B226AAp-31 >= (-0x2.Fp+1)) != (p_6 <= (l_1598 != (void*)0))) , p_5)) | p_6)) , p_5) | p_5) , l_1607) ^ p_7.f0) || 0xE6A26528) < p_7.f0) == p_7.f0) >= p_6)) , p_5) , &l_1629[0][7]) == (**l_1605))) / (float)0x8.1EEA10p+87) , 0), p_6) , p_7.f1) * (float)0x6.6296E2p+86) , (void*)0) != &l_1598);
                    (*l_1666) = l_1665[8];
                    /* statement id: 669 */
                    assert (l_1605 == &l_1351 || l_1605 == 0);
                }
                else
                { /* block id: 670 */
                    int32_t l_1675 = 0;
                    int16_t l_1693 = 0x6D66;
                    int32_t *l_1694 = &l_831;
                    const int32_t *l_1695 = &l_1675;
                    if ((((((uint16_t)p_6 << (uint16_t)p_7.f1) >= (((~(((p_7.f0 > p_5) & (((uint16_t)((uint16_t)65535U >> (uint16_t)15) << (uint16_t)((l_1583 , p_7.f0) && p_5)) , (l_1674 == (*l_891)))) < l_1675)) >= p_7.f1) != 65535U)) ^ (-8)) >= (-1)))
                    { /* block id: 671 */
                        int16_t l_1692 = (-1);
                        l_1692 = ((int16_t)((int16_t)((uint32_t)p_7.f1 + (uint32_t)p_5) % (int16_t)((int32_t)l_1684 + (int32_t)(((uint32_t)(((~(-1)) || ((int16_t)((uint16_t)p_7.f1 * (uint16_t)p_7.f1) << (int16_t)13)) ^ (p_7.f1 >= ((-3) < p_7.f1))) - (uint32_t)l_1675) < 3))) >> (int16_t)12);
                        l_1675 = (p_7.f1 & l_1693);
                        l_1694 = (**l_1605);
                        /* statement id: 674 */
                        assert (l_1694 == 0);
                        (**l_1605) = (**l_1605);
                    }
                    else
                    { /* block id: 676 */
                        l_1696[5][1][3] = l_1695;
                        /* statement id: 677 */
                        //assert (l_1696[0][0][0] == &l_1675 || l_1696[0][0][0] == &l_831 || l_1696[0][0][0] == 0);
                        return p_6;
                    }
                    /* facts after branching */
                    assert (l_1694 == 0);
                    (**l_1605) = (*l_1351);
                    return p_6;
                }
                /* facts after branching */
                //assert ((l_906[0] >= &l_1629[0][0] && l_906[0] <= &l_1629[1][9]) || l_906[0] == 0);
                assert (l_1605 == &l_1351 || l_1605 == 0);
                if (((((((float)p_6 + (float)0x0.7p-1) , ((uint32_t)p_7.f0 - (uint32_t)(p_7 , ((int16_t)((((int16_t)((uint32_t)(0x667A || (p_6 == 0xE387C878)) - (uint32_t)((uint16_t)((0x4.8p-1 <= (!(((int16_t)((((uint16_t)(((int32_t)(((((0xA62F & p_5) , p_6) | p_6) , (void*)0) != (void*)0) - (int32_t)1) ^ p_7.f0) * (uint16_t)p_6) | l_1717) == (-10)) / (int16_t)l_1718[1][0][8]) , p_5))) , 65527U) * (uint16_t)0x3505)) >> (int16_t)p_7.f1) , &l_1604) == (void*)0) >> (int16_t)l_1719)))) & p_7.f0) && p_7.f1) == 65531U))
                { /* block id: 683 */
                    struct S0 *l_1726 = (void*)0;
                    int32_t l_1733 = (-1);
                    for (l_1080 = 0; (l_1080 < 38); l_1080++)
                    { /* block id: 686 */
                        float l_1735 = 0x1.9p-1;
                        int32_t *l_1740 = &l_1629[1][1];
                        int32_t l_1751 = 5;
                        if (p_7.f0)
                            break;
                        l_1735 = ((float)(((float)p_7.f1 * (float)((l_1726 == &p_7) > ((p_5 < 0xF.53A8F5p-37) >= (p_6 == ((p_7.f1 != ((float)((float)((float)(l_1733 , l_1734) * (float)p_5) / (float)p_6) + (float)l_1733)) != 0x5.1666A3p-96))))) < 0x2.FF6B62p-95) / (float)p_7.f1);
                        if (l_1156)
                            goto lbl_1752;
                        (*l_1351) = ((((int16_t)0 << (int16_t)9) , ((uint32_t)(((void*)0 == l_1740) ^ ((int32_t)((int16_t)((*l_1740) >= ((uint32_t)0U + (uint32_t)p_7.f1)) << (int16_t)10) - (int32_t)(((float)((float)(((((func_35(l_1733, p_6) , 0xB.91ED52p-29) == p_7.f1) < l_1751) <= (-0x10.0p-1)) == 0x0.6p-1) + (float)p_5) * (float)l_1733) , p_5))) + (uint32_t)l_1733)) , (void*)0);
                    }
lbl_1752:
                    (*l_1351) = (void*)0;
                    return l_1733;
                }
                else
                { /* block id: 694 */
                    return p_5;
                }
            }
            else
            { /* block id: 697 */
                return p_6;
            }
        }
        else
        { /* block id: 700 */
            struct S0 *l_1755 = &l_853;
            struct S0 **l_1754 = &l_1755;
            int32_t l_1773 = 0x3A3328B5;
            float *l_1774 = &l_939;
            (*l_1754) = l_1753;
            (*l_1774) = ((float)0xD.1026CAp-83 * (float)((-(uint16_t)(((uint16_t)((((((int32_t)(p_7.f1 >= ((uint16_t)((((((0x609BCC75 ^ (((int16_t)((**l_1754) , p_7.f1) % (int16_t)((uint16_t)p_7.f0 << (uint16_t)((((uint16_t)(((int16_t)(p_7.f0 , 0) * (int16_t)((0xE73E8C91 == 0x078165F3) == p_6)) < p_5) >> (uint16_t)5) ^ l_1773) >= 9U))) == p_6)) <= p_7.f1) <= p_6) == p_7.f1) | p_7.f0) ^ p_7.f0) * (uint16_t)p_7.f1)) + (int32_t)p_7.f1) , (void*)0) == (void*)0) , l_1773) & p_7.f0) >> (uint16_t)l_1773) ^ p_7.f1)) , p_7.f1));
        }
        if (l_1566)
            goto lbl_1775;
    }
    /* facts after branching */
    //assert (l_906[0] == dangling || l_906[0] == 0);
    return p_5;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static const int16_t  func_10(struct S0  p_11, uint32_t  p_12, int8_t  p_13)
{ /* block id: 4 */
    return p_11.f1;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_15(const int8_t  p_16, const uint32_t  p_17, int16_t  p_18, uint32_t  p_19)
{ /* block id: 6 */
    int32_t l_30[9][4][7] = {{{0xBFF020A7,0x0D1F898A,0,(-1),0x04D46446,0x6A0230A2,0x538770CE},{0xBFF020A7,0x9503A5A1,0x74D4A52D,0x3A38C8A2,0,1,0x6A0230A2},{0xA4087B33,1,0x2B930EEA,0x24CED0F2,0x9E9DA123,0x6A0230A2,4},{0x9E9DA123,(-1),0xACE07D3F,0x24CED0F2,0x2AB2BC8F,0x446ED9A8,0x98A97D63}},{{0xE87122A2,0x274C111B,(-1),0x3A38C8A2,1,0x538770CE,0},{1,(-1),0xDEDC87A9,(-1),0x7CEC7E9A,0x430688CD,0},{0x73D5EAA9,1,0xC411E69D,(-1),(-1),0x98A97D63,0x98A97D63},{0x7CEC7E9A,0x9503A5A1,0x5266ADDA,0x9503A5A1,0x7CEC7E9A,(-1),4}},{{(-8),0x0D1F898A,0x5266ADDA,(-1),1,0x9B17C08A,0x6A0230A2},{0x0F13E0CA,0x3A38C8A2,0xC411E69D,0x8A615B38,0x2AB2BC8F,0x49C99C4D,0x538770CE},{(-8),(-1),0xDEDC87A9,0x6AC1DEA9,0x9E9DA123,0x49C99C4D,(-1)},{0x7CEC7E9A,0xADE45A91,(-1),1,0,0x9B17C08A,(-2)}},{{0x73D5EAA9,0xE3E0ECE9,0xACE07D3F,0x6AC1DEA9,0x04D46446,(-1),0},{1,0xE3E0ECE9,0x2B930EEA,0x8A615B38,(-8),0x98A97D63,1},{0xE87122A2,0xADE45A91,0x74D4A52D,(-1),1,0x430688CD,0},{0x9E9DA123,(-1),0,0x9503A5A1,1,0x538770CE,(-2)}},{{0xA4087B33,0x3A38C8A2,(-2),(-1),(-8),0x446ED9A8,(-1)},{0xBFF020A7,0x0D1F898A,0,(-1),0x04D46446,0x6A0230A2,0x538770CE},{0xBFF020A7,0x9503A5A1,0x74D4A52D,0x3A38C8A2,0,1,0x6A0230A2},{0xA4087B33,1,0x2B930EEA,0x24CED0F2,0x9E9DA123,0x6A0230A2,4}},{{0x9E9DA123,(-1),0xACE07D3F,0x24CED0F2,0x2AB2BC8F,0x446ED9A8,0x98A97D63},{0xE87122A2,0x274C111B,(-1),0x3A38C8A2,1,0x538770CE,0},{1,(-1),0xDEDC87A9,(-1),0x7CEC7E9A,0,(-2)},{0x446ED9A8,1,1,0xCAD959FC,0x9B17C08A,0xDEDC87A9,0xDEDC87A9}},{{0x430688CD,3,0xA6652F52,3,0x430688CD,0x5266ADDA,1},{0x49C99C4D,0x9FD40FD7,0xA6652F52,0,(-1),0x2B930EEA,6},{4,0,1,(-9),(-9),0x11B6BEFC,0},{0x49C99C4D,0,0xCC0C20EB,0x8280EFF2,(-2),0x11B6BEFC,0x5266ADDA}},{{0x430688CD,0xE27A8D2C,0xCA982314,0xBA2D3C5E,0,0x2B930EEA,(-1)},{0x446ED9A8,0x3A1B4BC7,0xDCB3DF1C,0x8280EFF2,1,0x5266ADDA,0xBC712BAD},{0,0x3A1B4BC7,1,(-9),0x49C99C4D,0xDEDC87A9,0x74D4A52D},{(-2),0xE27A8D2C,0x416C28CB,0,0,0,0xBC712BAD}},{{(-2),0,0x127C80B1,3,0,0,(-1)},{1,0,(-1),0xCAD959FC,0x49C99C4D,0xC411E69D,0x5266ADDA},{0x98A97D63,0x9FD40FD7,0x127C80B1,1,1,6,0},{0x98A97D63,3,0x416C28CB,0,0,7,6}}};
    struct S0 l_31 = {20,0x91};
    uint32_t l_34 = 0x61B24C01;
    int8_t l_417 = 0x4A;
    float l_829[4] = {0x4.4D583Ap+99,0x4.4D583Ap+99,0x4.4D583Ap+99,0x4.4D583Ap+99};
    float *l_828 = &l_829[1];
    int i, j, k;
    (*l_828) = (func_26(l_30[8][2][3], func_10(l_31, l_31.f0, p_16), ((uint16_t)(l_34 | func_10(func_35(((l_34 < ((func_38(func_44(l_30[5][0][5], (func_10(l_31, l_34, p_17) || 1U), l_30[8][2][3], p_19, l_31), p_19, l_30[1][2][3], p_17, p_17) >= l_417) , p_18)) == p_19), l_30[8][2][3]), p_16, l_30[1][2][1])) - (uint16_t)0xEAB3)) <= p_18);
    return l_31;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static float  func_26(uint16_t  p_27, int8_t  p_28, uint32_t  p_29)
{ /* block id: 196 */
    float l_422[5][5][4] = {{{0xD.B7C5AFp+34,0xD.B7C5AFp+34,0x1.8A5078p-33,0x6.9p+1},{0x9.460507p-77,(-0x3.5p-1),0x3.9p-1,0xC.91C45Dp+18},{0x1.457E44p-87,0xE.D38191p-20,0xC.1DD35Ep-99,0x3.9p-1},{0x5.E690E6p-4,0xE.D38191p-20,0x0.9p-1,0xC.91C45Dp+18},{0xE.D38191p-20,(-0x3.5p-1),0x5.60F183p-53,0x6.9p+1}},{{0x3.Ep-1,0xD.B7C5AFp+34,0x1.457E44p-87,(-0x3.5p-1)},{(-0x10.3p-1),0x0.40780Ap-70,0x4.FD210Dp+3,(-0x10.3p-1)},{0x6.9p+1,(-0x1.4p-1),0x5.60F183p-53,0x5.E690E6p-4},{(-0x1.2p+1),(-0x1.2p-1),0xF.1F93E2p-65,0xB.5DCC32p-38},{0x5.E690E6p-4,0xA.723F2Fp-16,0x1.1p+1,0xA.723F2Fp-16}},{{0x0.40780Ap-70,0x3.2p+1,0x3.9p-1,0x5.E690E6p-4},{0x5.Dp-1,0xC.91C45Dp+18,0xB.5DCC32p-38,0x1.1p+1},{0xD.B7C5AFp+34,0x0.40780Ap-70,0x9.3p+1,0x5.6A05A9p-94},{0xD.B7C5AFp+34,0x3.9p-1,0xB.5DCC32p-38,0x6.9p+1},{0x5.Dp-1,0x5.6A05A9p-94,0x3.9p-1,(-0x1.4p-1)}},{{0x0.40780Ap-70,0xE.D38191p-20,0x1.1p+1,0xD.B7C5AFp+34},{0x5.E690E6p-4,(-0x1.2p+1),0xF.1F93E2p-65,0xC.91C45Dp+18},{(-0x1.2p+1),0x5.6A05A9p-94,0x5.60F183p-53,0x3.Ep-1},{0x6.9p+1,0xD.B7C5AFp+34,0x4.FD210Dp+3,0x5.6A05A9p-94},{(-0x10.3p-1),0x1.457E44p-87,0x1.457E44p-87,(-0x10.3p-1)}},{{0x3.Ep-1,0xC.91C45Dp+18,0x5.60F183p-53,0xF.1F93E2p-65},{0xE.D38191p-20,(-0x1.2p-1),0x0.9p-1,0xA.723F2Fp-16},{0x5.E690E6p-4,0xB.5DCC32p-38,0xC.1DD35Ep-99,0xA.723F2Fp-16},{0x1.457E44p-87,0x5.60F183p-53,0x1.8A5078p-33,0x9.3p+1},{0xF.1F93E2p-65,0x3.2p+1,0xE.D38191p-20,0x3.9p-1}}};
    struct S0 l_425 = {36,0xFD};
    struct S0 *l_424 = &l_425;
    struct S0 **l_423 = &l_424;
    int32_t * const l_426 = (void*)0;
    int32_t l_428 = 0x0963F13D;
    int32_t *l_427[2];
    int8_t l_450 = 1;
    int32_t **l_556[10][10][2] = {{{&l_427[0],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{(void*)0,&l_427[0]},{(void*)0,&l_427[1]},{&l_427[1],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[0],&l_427[0]},{&l_427[0],&l_427[1]}},{{&l_427[1],&l_427[1]},{(void*)0,&l_427[0]},{(void*)0,&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[1],&l_427[1]},{&l_427[0],&l_427[0]}},{{(void*)0,&l_427[1]},{&l_427[1],&l_427[1]},{(void*)0,&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]},{(void*)0,&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]}},{{&l_427[1],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{(void*)0,&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{(void*)0,&l_427[1]}},{{&l_427[1],&l_427[1]},{(void*)0,&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{(void*)0,&l_427[0]}},{{(void*)0,&l_427[1]},{&l_427[1],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[0],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[1],&l_427[1]},{(void*)0,&l_427[0]},{(void*)0,&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]}},{{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[1],&l_427[1]},{&l_427[0],&l_427[0]},{(void*)0,&l_427[1]},{&l_427[1],&l_427[1]},{(void*)0,&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]}},{{&l_427[0],&l_427[0]},{(void*)0,&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]}},{{(void*)0,&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{&l_427[0],&l_427[1]},{(void*)0,&l_427[1]},{&l_427[1],&l_427[1]},{(void*)0,&l_427[0]},{&l_427[0],&l_427[1]},{&l_427[1],&l_427[0]},{&l_427[0],&l_427[1]}},{{&l_427[0],&l_427[0]},{&l_427[1],&l_427[0]},{&l_427[1],&l_427[0]},{(void*)0,&l_427[0]},{&l_427[0],&l_427[0]},{&l_427[0],&l_427[0]},{&l_427[1],&l_427[0]},{(void*)0,(void*)0},{&l_427[1],(void*)0},{(void*)0,&l_427[0]}}};
    int32_t ***l_555 = &l_556[5][8][1];
    int32_t ****l_554 = &l_555;
    float l_663[1][10] = {{(-0x1.8p-1),(-0x1.8p-1),0x9.40597Ep-7,(-0x1.8p-1),(-0x1.8p-1),0x9.40597Ep-7,(-0x1.8p-1),(-0x1.8p-1),0x9.40597Ep-7,(-0x1.8p-1)}};
    int16_t l_697 = 0x409B;
    uint32_t l_758 = 0x26B49531;
    struct S0 ** const l_795 = &l_424;
    int32_t l_823 = 0x0B0CCC1C;
    float *l_824 = (void*)0;
    float *l_825 = &l_663[0][6];
    int32_t *l_826 = &l_428;
    int32_t *l_827[2];
    int i, j, k;
    for (i = 0; i < 2; i++)
        l_427[i] = &l_428;
    for (i = 0; i < 2; i++)
        l_827[i] = &l_428;
    for (p_27 = 0; (p_27 <= 3); p_27 += 1)
    { /* block id: 199 */
        int32_t l_430 = 0xF25C23AB;
        float *l_437 = &l_422[0][1][3];
        struct S0 * const * const l_449 = &l_424;
        struct S0 * const * const * const l_448 = &l_449;
        int32_t l_457 = (-1);
        uint32_t l_511[8][5] = {{4294967295U,4294967295U,4294967295U,4294967295U,4294967295U},{4294967293U,4294967293U,4294967293U,4294967293U,4294967293U},{4294967295U,4294967295U,4294967295U,4294967295U,4294967295U},{4294967293U,4294967293U,4294967293U,4294967293U,4294967293U},{4294967295U,4294967295U,4294967295U,4294967295U,4294967295U},{4294967293U,4294967293U,4294967293U,4294967293U,4294967293U},{4294967295U,4294967295U,4294967295U,4294967295U,4294967295U},{4294967293U,4294967293U,4294967293U,4294967293U,4294967293U}};
        float l_530 = 0x6.9p-1;
        int32_t **l_582 = (void*)0;
        int32_t l_588 = 0x25F25FBE;
        int32_t ****l_597 = &l_555;
        struct S0 l_772 = {33,-7};
        uint32_t l_788[4];
        uint16_t l_815 = 0xF085;
        int i, j;
        for (i = 0; i < 4; i++)
            l_788[i] = 0x0D3C951A;
    }
    (*l_825) = p_27;
    l_827[1] = l_826;
    return p_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_35(int32_t  p_36, const int8_t  p_37)
{ /* block id: 193 */
    uint32_t l_418[4];
    float l_420 = 0x0.Fp-1;
    float *l_419 = &l_420;
    struct S0 l_421 = {18,0x02};
    int i;
    for (i = 0; i < 4; i++)
        l_418[i] = 4294967289U;
    (*l_419) = l_418[0];
    return l_421;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static float  func_38(struct S0  p_39, const float  p_40, int32_t  p_41, const uint16_t  p_42, const uint32_t  p_43)
{ /* block id: 190 */
    int32_t l_415 = (-1);
    int32_t * const l_414 = &l_415;
    int32_t *l_416[7][6] = {{(void*)0,&l_415,&l_415,&l_415,&l_415,(void*)0},{&l_415,&l_415,(void*)0,(void*)0,&l_415,&l_415},{(void*)0,&l_415,&l_415,&l_415,&l_415,&l_415},{&l_415,&l_415,(void*)0,&l_415,&l_415,&l_415},{&l_415,(void*)0,&l_415,&l_415,&l_415,&l_415},{(void*)0,&l_415,&l_415,(void*)0,(void*)0,&l_415},{&l_415,&l_415,&l_415,&l_415,&l_415,&l_415}};
    int i, j;
    l_416[6][4] = l_414;
    return p_39.f0;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_44(uint32_t  p_45, int16_t  p_46, uint32_t  p_47, uint32_t  p_48, const struct S0  p_49)
{ /* block id: 7 */
    struct S0 l_58 = {25,-1};
    int32_t l_413 = (-1);
    int32_t *l_412 = &l_413;
    (*l_412) = (((int16_t)((uint16_t)((uint16_t)((int32_t)(func_10(l_58, l_58.f0, (l_58.f1 , ((int32_t)(!func_10(func_62(l_58.f1, (l_58.f1 , (0xB.A84738p-86 > ((float)((float)((float)(0x2.2p+1 <= p_49.f0) + (float)p_49.f1) / (float)l_58.f1) / (float)l_58.f0)))), p_48, p_49.f0)) / (int32_t)p_48))) ^ 0x61872BC7) + (int32_t)1) % (uint16_t)l_58.f1) << (uint16_t)l_58.f0) + (int16_t)l_58.f0) & p_46);
    return p_49;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static struct S0  func_62(int32_t  p_63, float  p_64)
{ /* block id: 8 */
    uint32_t l_71[1];
    struct S0 l_75 = {32,-1};
    int32_t l_376[6][1][1] = {{{0xC605E8E3}},{{(-9)}},{{(-9)}},{{0xC605E8E3}},{{(-9)}},{{(-9)}}};
    int32_t *l_375 = &l_376[1][0][0];
    int32_t **l_377 = &l_375;
    int32_t ****l_395 = (void*)0;
    int32_t **** const *l_394 = &l_395;
    int i, j, k;
    for (i = 0; i < 1; i++)
        l_71[i] = 0x176A924D;
    if ((l_71[0] <= ((func_72(l_75, p_63) , ((uint32_t)p_63 % (uint32_t)((int16_t)(((uint16_t)((int32_t)((int16_t)l_71[0] + (int16_t)p_63) % (int32_t)(-4)) * (uint16_t)p_63) > 0x2E5C) / (int16_t)l_71[0]))) <= 4294967287U)))
    { /* block id: 159 */
        uint32_t l_386[3];
        float l_388 = 0xF.E17AAAp-48;
        float *l_387 = &l_388;
        int i;
        for (i = 0; i < 3; i++)
            l_386[i] = 0x25ED15D5;
        (*l_387) = (p_63 == (((float)((((void*)0 == l_375) , (void*)0) != l_377) * (float)((float)((float)((**l_377) > ((float)(((((int32_t)p_63 / (int32_t)(**l_377)) && (p_63 < p_63)) , l_386[2]) < (**l_377)) * (float)p_63)) + (float)l_386[2]) - (float)(**l_377))) != l_386[2]));
    }
    else
    { /* block id: 161 */
        int32_t ***l_393 = (void*)0;
        int32_t ****l_392 = &l_393;
        int32_t **** const *l_391 = &l_392;
        struct S0 l_403 = {21,0};
        for (p_63 = 0; (p_63 != 0); p_63 += 8)
        { /* block id: 164 */
            int8_t l_396 = 1;
            struct S0 l_401 = {26,0};
            int32_t * const *l_406 = &l_375;
            l_394 = l_391;
            /* statement id: 165 */
            assert (l_394 == &l_392);
            if (l_396)
                break;
            for (l_396 = (-2); (l_396 != 17); l_396 += 1)
            { /* block id: 169 */
                int32_t l_399 = 0x23B12C97;
                int32_t *l_402 = &l_376[1][0][0];
                if (l_399)
                { /* block id: 170 */
                    int32_t *l_400 = &l_399;
                    (*l_377) = l_400;
                    /* statement id: 171 */
                    assert (l_375 == &l_399);
                }
                else
                { /* block id: 172 */
                    return l_401;
                }
                /* facts after branching */
                assert (l_375 == &l_399);
                l_402 = (*l_377);
                /* statement id: 175 */
                assert (l_402 == &l_399);
                (**l_406) = (((((l_401 , 0xB.353EA8p+19) , l_403) , ((int16_t)(l_401.f0 ^ ((p_63 || ((p_63 , l_406) == (void*)0)) & (((float)(0x5.4p-1 != (*l_402)) + (float)(*l_402)) , (-5)))) >> (int16_t)(*l_402))) || 0xBCD6CC34) , (**l_406));
                for (l_399 = 0; (l_399 >= 0); l_399 -= 1)
                { /* block id: 179 */
                    int32_t l_409 = 0x8AFA09FD;
                    int32_t l_410 = 0x329A4946;
                    int32_t l_411 = (-1);
                    for (l_409 = 0; l_409 < 6; l_409 += 1)
                    {
                        for (l_410 = 0; l_410 < 1; l_410 += 1)
                        {
                            for (l_411 = 0; l_411 < 1; l_411 += 1)
                            {
                                l_376[l_409][l_410][l_411] = (-1);
                            }
                        }
                    }
                    return l_401;
                }
            }
        }
        /* facts after for loop */
        //assert (l_375 == dangling || (l_375 >= &l_376[0][0][0] && l_375 <= &l_376[5][0][0]));
        assert (l_394 == &l_392 || l_394 == &l_395);
    }
    /* facts after branching */
    //assert (l_375 == dangling || (l_375 >= &l_376[0][0][0] && l_375 <= &l_376[5][0][0]));
    //assert (l_394 == dangling || l_394 == &l_395);
    (*l_377) = &l_376[1][0][0];
    /* statement id: 186 */
    assert ((l_375 >= &l_376[0][0][0] && l_375 <= &l_376[5][0][0]));
    return l_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static struct S0  func_72(struct S0  p_73, float  p_74)
{ /* block id: 9 */
    int32_t l_76 = (-1);
    struct S0 l_119 = {15,0x55};
    struct S0 *l_132 = &l_119;
    struct S0 * const *l_131 = &l_132;
    uint32_t l_156 = 1U;
    int32_t l_157[6][4] = {{0xB1F48843,8,8,0xB1F48843},{7,8,(-3),8},{8,5,(-3),(-3)},{7,7,8,(-3)},{0xB1F48843,5,0xB1F48843,8},{0xB1F48843,8,8,0xB1F48843}};
    int16_t l_293 = 0xC857;
    int32_t *l_312[4] = {&l_157[4][1],&l_157[4][1],&l_157[4][1],&l_157[4][1]};
    int32_t **l_311 = &l_312[0];
    int32_t ***l_310 = &l_311;
    int32_t ****l_309 = &l_310;
    uint32_t l_362 = 5U;
    int i, j;
    return p_73;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 349
   depth: 1, occurrence: 16
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 1
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 71
breakdown:
   indirect level: 0, occurrence: 16
   indirect level: 1, occurrence: 9
   indirect level: 2, occurrence: 23
   indirect level: 3, occurrence: 10
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 8
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 33
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 50
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 172

XXX max expression depth: 41
breakdown:
   depth: 1, occurrence: 207
   depth: 2, occurrence: 47
   depth: 3, occurrence: 5
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 11, occurrence: 2
   depth: 12, occurrence: 3
   depth: 13, occurrence: 2
   depth: 14, occurrence: 3
   depth: 15, occurrence: 3
   depth: 16, occurrence: 4
   depth: 17, occurrence: 1
   depth: 19, occurrence: 5
   depth: 20, occurrence: 1
   depth: 21, occurrence: 3
   depth: 22, occurrence: 3
   depth: 23, occurrence: 2
   depth: 25, occurrence: 1
   depth: 27, occurrence: 1
   depth: 29, occurrence: 1
   depth: 30, occurrence: 4
   depth: 31, occurrence: 1
   depth: 32, occurrence: 1
   depth: 33, occurrence: 2
   depth: 34, occurrence: 1
   depth: 40, occurrence: 1
   depth: 41, occurrence: 1

XXX total number of pointers: 268

XXX times a variable address is taken: 696
XXX times a pointer is dereferenced on RHS: 128
breakdown:
   depth: 1, occurrence: 91
   depth: 2, occurrence: 18
   depth: 3, occurrence: 9
   depth: 4, occurrence: 8
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 112
breakdown:
   depth: 1, occurrence: 99
   depth: 2, occurrence: 7
   depth: 3, occurrence: 2
   depth: 4, occurrence: 4
XXX times a pointer is compared with null: 58
XXX times a pointer is compared with address of another variable: 17
XXX times a pointer is compared with another pointer: 25
XXX times a pointer is qualified to be dereferenced: 1978

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 279
   level: 2, occurrence: 123
   level: 3, occurrence: 144
   level: 4, occurrence: 96
   level: 5, occurrence: 65
XXX number of pointers point to pointers: 153
XXX number of pointers point to scalars: 98
XXX number of pointers point to structs: 17
XXX percent of pointers has null in alias set: 32.5
XXX average alias set size: 1.29

XXX times a non-volatile is read: 1831
XXX times a non-volatile is write: 413
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 2
XXX backward jumps: 3

XXX stmts: 216
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 16
   depth: 2, occurrence: 23
   depth: 3, occurrence: 32
   depth: 4, occurrence: 52
   depth: 5, occurrence: 71

XXX percentage a fresh-made variable is used: 14.9
XXX percentage an existing variable is used: 85.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

