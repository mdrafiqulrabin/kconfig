/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --comma-operators --compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --no-pre-decr-operator --no-post-incr-operator --no-post-decr-operator --unary-plus-operator --jumps --longlong --int8 --no-uint8 --float --math64 --no-inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --no-structs --no-unions --volatiles --volatile-pointers --no-const-pointers --no-global-variables --builtins
 * Seed:      539627734
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
/* --- GLOBAL VARIABLES --- */


/* --- FORWARD DECLARATIONS --- */
static int8_t  func_27(void);
static uint32_t  func_34(int32_t  p_35);
static uint16_t  func_53(uint32_t  p_54);
static int32_t * func_59(int8_t  p_60);
static uint16_t  func_71(int8_t  p_72, const int64_t  p_73);
static int8_t  func_74(uint64_t  p_75, int8_t  p_76, int32_t * p_77, int64_t  p_78, int64_t  p_79);
static uint16_t  func_96(int32_t * p_97, uint16_t  p_98, float  p_99, int32_t * p_100, int8_t  p_101);
static int32_t * func_102(int32_t  p_103, uint64_t  p_104, int32_t  p_105, const int16_t  p_106);
static int32_t  func_107(int32_t  p_108, const int32_t * p_109, int32_t * p_110, float  p_111, int32_t  p_112);
static int32_t  func_118(int32_t * p_119, const int32_t * p_120, uint16_t  p_121, int32_t  p_122, int32_t * p_123);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_27(void)
{ /* block id: 36 */
    int32_t l_28 = 6L;
    float l_45 = 0xF.607D19p+30;
    for (l_28 = 0; (l_28 > 3); l_28 += 1)
    { /* block id: 39 */
        int32_t l_31 = 0x665969A2L;
        int32_t *l_555 = &l_31;
        for (l_31 = (-17); (l_31 <= 9); l_31 += 1)
        { /* block id: 42 */
            uint64_t l_46 = 1UL;
            int32_t l_554 = 0L;
            int32_t *l_553 = &l_554;
            (*l_553) = (func_34(((int16_t)((+l_28) , (((int32_t)(((float)((float)l_28 * (float)l_45) * (float)l_46) , l_28) + (int32_t)(((((uint16_t)(((int16_t)((((((l_46 > l_28) && ((uint16_t)func_53(((uint16_t)((int16_t)((8UL <= (0xF9F4L <= l_28)) | l_28) % (int16_t)l_28) * (uint16_t)65535UL)) >> (uint16_t)l_31)) ^ l_46) >= 9UL) , l_31) >= l_31) >> (int16_t)l_31) , l_31) << (uint16_t)l_46) != l_46) > l_31) & l_28)) || l_28)) << (int16_t)l_46)) , 5L);
        }
        (*l_555) = (l_28 , 0xE839301CL);
    }
    return l_28;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_34(int32_t  p_35)
{ /* block id: 188 */
    int32_t l_537 = 0x8D9D4BA2L;
    int32_t *l_536 = &l_537;
    int32_t **l_550 = &l_536;
    int32_t ***l_549 = &l_550;
    int32_t l_552 = 0L;
    int32_t *l_551 = &l_552;
    (*l_551) ^= ((l_536 == ((((((-5L) == (0x93F68319A3B7F192LL <= ((*l_536) , (p_35 | p_35)))) <= 65535UL) | p_35) ^ ((uint16_t)((int16_t)__builtin_clzll(((int32_t)func_107((((uint16_t)(-(uint32_t)(((uint16_t)(l_549 == &l_550) >> (uint16_t)4) && (***l_549))) + (uint16_t)(***l_549)) | (-5L)), (*l_550), (*l_550), p_35, (**l_550)) - (int32_t)0xA24062B6L)) * (int16_t)p_35) << (uint16_t)p_35)) , &p_35)) ^ (***l_549));
    return p_35;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_53(uint32_t  p_54)
{ /* block id: 43 */
    int32_t l_65 = 0x81CDFFA8L;
    int32_t *l_64 = &l_65;
    int32_t *l_66 = &l_65;
    uint32_t l_114 = 0x8F681728L;
    float l_364 = 0x2.EB4F8Ap-0;
    int32_t *l_394 = &l_65;
    const int32_t *l_450 = &l_65;
    const int32_t **l_449 = &l_450;
    const int32_t ***l_448 = &l_449;
    const int32_t ****l_447 = &l_448;
    const int32_t *****l_446 = &l_447;
    int32_t l_465 = 0x7846DEBEL;
    int32_t **l_533 = &l_64;
    int32_t ***l_532 = &l_533;
    int32_t ****l_531 = &l_532;
    int32_t *****l_530 = &l_531;
    int64_t l_534 = 0x93D664719483A7A1LL;
    l_64 = func_59(p_54);
    /* statement id: 46 */
    assert (l_64 == 0);
    l_66 = &l_65;
    if (p_54)
    { /* block id: 48 */
        int16_t l_67 = (-7L);
        int32_t l_68 = 0x03FCA5EBL;
        l_68 ^= (__builtin_ffs(l_67) < p_54);
        for (p_54 = (-24); (p_54 <= 60); p_54 += 1)
        { /* block id: 52 */
            int32_t *l_113 = &l_68;
            int32_t **l_337 = (void*)0;
            const int32_t **l_338 = (void*)0;
            int32_t **l_339 = &l_113;
            float *l_340 = (void*)0;
            float l_342 = 0x4.4p-1;
            float *l_341 = &l_342;
            if (p_54)
            { /* block id: 53 */
                int32_t l_115 = 9L;
                (*l_66) = ((func_71(func_74(((int16_t)((65530UL || ((uint64_t)p_54 % (uint64_t)l_68)) >= 0x63CCL) >> (int16_t)7), ((-(uint64_t)(((float)__builtin_ffs((((int64_t)(!(8UL & (((int16_t)(((int16_t)(-6L) << (int16_t)1) , ((uint16_t)func_96(func_102(func_107((((((l_113 != ((((l_114 == 0xC65315FAL) , l_115) | 9UL) , (void*)0)) , p_54) , (void*)0) == &l_65) , p_54), &l_115, &l_65, p_54, l_67), (*l_66), p_54, (*l_66)), l_67, (*l_66), l_113, p_54) % (uint16_t)0x88CAL)) << (int16_t)7) , l_68))) + (int64_t)p_54) && p_54)) * (float)0xB.3F4B22p+40) , p_54)) >= l_67), &l_115, p_54, (*l_66)), (*l_66)) | 8L) , p_54);
            }
            else
            { /* block id: 123 */
                return p_54;
            }
            (*l_339) = &l_65;
            /* statement id: 126 */
            assert (l_113 == &l_65);
            (*l_341) = p_54;
        }
    }
    else
    { /* block id: 129 */
        uint32_t l_346 = 0UL;
        int32_t *l_365 = &l_65;
        const int32_t *l_400 = &l_65;
        const int32_t **l_399 = &l_400;
        const int32_t ***l_398 = &l_399;
        uint16_t l_438 = 0x239BL;
        int64_t l_464 = (-2L);
        int64_t l_476 = 4L;
        int32_t l_498 = 6L;
    }
    return p_54;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_59(int8_t  p_60)
{ /* block id: 44 */
    int32_t l_62 = 0x7CC73EE4L;
    int32_t *l_61 = &l_62;
    int32_t *l_63 = (void*)0;
    return l_63;
    /* statement id: 45 */
    //assert (func_59_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_71(int8_t  p_72, const int64_t  p_73)
{ /* block id: 118 */
    uint16_t l_329 = 4UL;
    int64_t l_330 = 1L;
    int32_t l_334 = (-10L);
    int32_t *l_333 = &l_334;
    uint32_t l_335 = 4294967295UL;
    int32_t **l_336 = &l_333;
    (*l_333) = func_74(p_72, ((int16_t)((int16_t)((uint16_t)((uint32_t)(p_72 && __builtin_ctzll(l_329)) % (uint32_t)__builtin_popcountl(l_330)) - (uint16_t)l_330) * (int16_t)(((int32_t)(-7L) - (int32_t)l_330) , p_73)) * (int16_t)l_330), l_333, l_335, (*l_333));
    (*l_336) = ((p_73 && (p_72 , p_72)) , func_102((func_107(p_72, &l_334, &l_334, (((*l_333) <= p_72) != (0x1.8p+1 < 0x2.Cp+1)), p_73) , (*l_333)), (*l_333), p_73, p_72));
    /* statement id: 120 */
    assert (l_333 == 0);
    return p_73;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int8_t  func_74(uint64_t  p_75, int8_t  p_76, int32_t * p_77, int64_t  p_78, int64_t  p_79)
{ /* block id: 116 */
    return p_75;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint16_t  func_96(int32_t * p_97, uint16_t  p_98, float  p_99, int32_t * p_100, int8_t  p_101)
{ /* block id: 113 */
    uint32_t l_304 = 7UL;
    int32_t l_311 = 0x27DC5E76L;
    int32_t *l_310 = &l_311;
    int32_t **l_309 = &l_310;
    int32_t ***l_317 = &l_309;
    int32_t ****l_316 = &l_317;
    int64_t l_318 = 6L;
    float l_319 = 0x6.3E1BB0p+54;
    int32_t *****l_320 = (void*)0;
    l_320 = (((((int32_t)((((l_304 < (func_107(((((int64_t)((((uint16_t)(l_309 == ((((int64_t)p_98 + (int64_t)((uint16_t)((p_98 || (*p_100)) , ((****l_316) , 0UL)) + (uint16_t)0UL)) ^ p_101) , (void*)0)) * (uint16_t)l_318) > p_98) != p_101) + (int64_t)p_98) , p_101) > (***l_317)), p_97, (**l_317), p_98, (*p_100)) ^ 9L)) == 0x6A21F3B6L) <= (****l_316)) && (*p_100)) - (int32_t)(***l_317)) == (**l_309)) , (***l_317)) , (void*)0);
    return p_101;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * func_102(int32_t  p_103, uint64_t  p_104, int32_t  p_105, const int16_t  p_106)
{ /* block id: 56 */
    uint32_t l_124 = 0x0950CF10L;
    int32_t l_127 = 0xE2C279A1L;
    int32_t *l_126 = &l_127;
    int64_t l_229 = (-10L);
    int32_t *l_274 = &l_127;
    int32_t *l_277 = &l_127;
    int32_t *l_278 = (void*)0;
    const int32_t **l_295 = (void*)0;
    const int32_t ***l_294 = &l_295;
    const int32_t ****l_293 = &l_294;
    float l_297 = 0x7.D30E98p-30;
    float *l_296 = &l_297;
    int32_t *l_298 = &l_127;
    int32_t *l_299 = &l_127;
    int32_t *l_300 = &l_127;
    int32_t *l_301 = (void*)0;
    for (p_105 = (-28); (p_105 > (-15)); p_105 += 2)
    { /* block id: 59 */
        int8_t l_125 = (-6L);
        int32_t *l_161 = &l_127;
        float l_205 = 0x3.Ep-1;
        int32_t *l_223 = &l_127;
        int32_t ****l_260 = (void*)0;
        int32_t *l_266 = &l_127;
        int8_t l_271 = 0x6EL;
        const int32_t *l_272 = &l_127;
        (*l_126) = func_118(&p_103, func_59(l_124), l_124, l_125, l_126);
        if ((((uint16_t)((uint32_t)(((int32_t)(((uint16_t)((int16_t)((int16_t)(-7L) << (int16_t)((*l_126) && p_104)) >> (int16_t)1) >> (uint16_t)p_105) <= ((uint16_t)(*l_126) + (uint16_t)((void*)0 != l_161))) - (int32_t)(&l_161 == &l_126)) < p_105) % (uint32_t)(*l_126)) % (uint16_t)(*l_126)) >= 0UL))
        { /* block id: 65 */
            const int32_t *l_167 = (void*)0;
            const int32_t **l_166 = &l_167;
            const int32_t ***l_165 = &l_166;
            int32_t *l_192 = (void*)0;
            const int32_t *l_194 = &l_127;
            int32_t l_225 = 0x2121E25CL;
            float l_242 = (-0x1.5p+1);
            int32_t *l_251 = &l_127;
            if ((*l_161))
            { /* block id: 66 */
                int32_t *l_162 = &l_127;
                int32_t **l_163 = &l_162;
                (*l_163) = l_162;
            }
            else
            { /* block id: 68 */
                int32_t **l_164 = &l_161;
                int32_t ***l_169 = &l_164;
                int32_t ****l_168 = &l_169;
                int32_t *l_224 = (void*)0;
                int32_t l_237 = 1L;
                uint32_t l_261 = 0xCBBA2194L;
                (*l_164) = (void*)0;
                /* statement id: 69 */
                assert (l_161 == 0);
                (*l_168) = l_165;
                /* statement id: 70 */
                assert (l_169 == &l_166);
                for (p_104 = 0; (p_104 == 42); p_104 += 1)
                { /* block id: 73 */
                    uint32_t l_177 = 0x0F15219CL;
                    int32_t l_178 = (-4L);
                    int32_t ****l_189 = &l_169;
                    const int32_t *l_193 = &l_178;
                    int16_t l_195 = (-4L);
                    l_178 &= ((uint16_t)((+p_103) != __builtin_clzl((((p_103 ^ (&p_103 != &p_105)) || ((uint16_t)p_103 * (uint16_t)((*l_126) <= (((void*)0 == l_161) == (*l_126))))) >= l_177))) * (uint16_t)l_177);
                    for (l_125 = (-4); (l_125 <= 5); l_125 += 1)
                    { /* block id: 77 */
                        float l_182 = 0xF.5E51F8p-90;
                        float *l_181 = &l_182;
                        (*l_181) = l_178;
                        (*l_181) = ((!((p_104 >= p_106) && ((uint64_t)(p_104 | 0L) % (uint64_t)(~((*l_126) <= p_105))))) , p_104);
                        p_103 = 0x8C47D00CL;
                    }
                    if ((((((((!p_104) , 0UL) , l_177) <= 65531UL) == (~(((void*)0 != l_189) > l_195))) , 65530UL) > (*l_193)))
                    { /* block id: 82 */
                        int32_t l_208 = 0xBF6F6D5BL;
                        float *l_209 = &l_205;
                        (*l_209) = (!(0x7.4CD455p-29 == (((7L != (p_103 || (((((uint16_t)((int64_t)(p_103 & (p_106 != ((uint16_t)(((uint32_t)p_104 - (uint32_t)(((int64_t)p_103 - (int64_t)(p_103 <= l_208)) > l_208)) > 0x758F72B2L) << (uint16_t)p_103))) % (int64_t)p_105) * (uint16_t)65526UL) < (*l_126)) , p_103) , p_104))) , 0x3CC6ED5EL) , p_105)));
                        (**l_165) = &p_105;
                        /* statement id: 84 */
                        assert (l_167 == &p_105);
                        (*l_209) = (((l_192 != l_193) , __builtin_parityll(__builtin_ffsll(__builtin_parity((0x55AEE4DEL || ((uint16_t)((***l_169) < 0x99D2L) >> (uint16_t)9)))))) == 0x1.78F7D0p+77);
                        l_225 ^= ((uint32_t)(p_103 || ((((uint16_t)(-(uint64_t)(*l_126)) % (uint16_t)((int16_t)((((uint16_t)((*l_169) == (void*)0) + (uint16_t)(p_104 < 0x7CFBDFDE9DF1BF41LL)) ^ p_103) < (****l_189)) % (int16_t)p_103)) , (***l_168)) != (void*)0)) - (uint32_t)p_105);
                    }
                    else
                    { /* block id: 87 */
                        float *l_226 = &l_205;
                        int32_t **l_228 = &l_126;
                        p_103 |= ((l_226 != (void*)0) , ((*l_223) , p_105));
                        (**l_228) = (((+(0UL && p_104)) , (void*)0) != l_228);
                        l_229 ^= (4UL > p_104);
                    }
                }
                /* facts after for loop */
                assert (l_167 == 0 || l_167 == &p_105);
                if ((p_103 & ((int64_t)(__builtin_ctzll(((uint64_t)((uint16_t)(-(uint32_t)p_103) >> (uint16_t)l_237) + (uint64_t)((int16_t)__builtin_popcountll(p_103) + (int16_t)func_107((p_104 , ((void*)0 != l_192)), (***l_168), &l_225, (*l_126), p_105)))) , p_106) - (int64_t)p_103)))
                { /* block id: 93 */
                    uint64_t l_243 = 18446744073709551615UL;
                    float *l_244 = &l_205;
                    int32_t **l_249 = &l_126;
                    (*l_244) = ((((uint16_t)65531UL >> (uint16_t)p_106) , (l_243 > p_105)) , p_105);
                    p_103 &= (((((int64_t)(*l_194) + (int64_t)0x08B9188FDCBF5BA5LL) && func_107(p_105, func_59(((((p_106 , (**l_249)) & (*l_126)) , (void*)0) != &l_166)), l_251, (**l_249), (*l_126))) ^ (*l_126)) > 0x25B55C4BL);
                    (***l_168) = func_59(((uint16_t)65527UL >> (uint16_t)p_103));
                    /* statement id: 96 */
                    assert (l_167 == 0);
                }
                else
                { /* block id: 97 */
                    float *l_254 = &l_242;
                    (*l_126) = (*l_126);
                    (*l_223) = (((void*)0 == l_254) & (__builtin_ffsl((0UL | (((uint16_t)0UL * (uint16_t)p_105) > (((uint16_t)p_106 * (uint16_t)2L) ^ (!((&l_165 != l_260) , 0x6977L)))))) & p_104));
                    if (l_261)
                        break;
                }
            }
            /* facts after branching */
            assert (l_161 == 0 || l_161 == &l_127);
            assert (l_167 == 0 || l_167 == &p_105);
            (*l_166) = func_59(((((*l_194) == ((float)(((float)(l_266 == (void*)0) + (float)0xA.238BE1p-48) >= ((l_126 == (void*)0) != p_106)) - (float)((float)(((float)((void*)0 != (*l_165)) + (float)p_106) < l_271) + (float)(*l_126)))) , (void*)0) != l_126));
            /* statement id: 103 */
            assert (l_167 == 0);
            l_272 = (**l_165);
            /* statement id: 104 */
            assert (l_272 == 0);
        }
        else
        { /* block id: 105 */
            int32_t *l_273 = &l_127;
            int32_t *l_275 = &l_127;
            int32_t *l_276 = &l_127;
            (*l_266) |= 0xFE5E5E13L;
            (*l_126) = (0x5D6DL | p_104);
            return l_278;
            /* statement id: 108 */
            //assert (func_102_rv == 0);
        }
        /* facts after branching */
        assert (l_161 == 0 || l_161 == &l_127);
        assert (l_272 == 0);
    }
    (*l_296) = ((float)((0x6.142440p+99 >= p_104) < ((float)((float)(((void*)0 == &l_126) , (((*l_277) , &l_274) == ((((((((int32_t)((int16_t)(p_103 , ((uint16_t)(((uint16_t)((((&p_103 == &l_127) >= 0x9.84EC38p+76) >= (*l_126)) , (*l_274)) >> (uint16_t)9) < p_105) << (uint16_t)(*l_274))) << (int16_t)p_106) - (int32_t)(*l_277)) | p_105) , (void*)0) == l_293) > p_105) ^ p_104) , (*l_294)))) - (float)p_104) * (float)p_105)) + (float)(*l_274));
    return l_301;
    /* statement id: 112 */
    //assert (func_102_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_107(int32_t  p_108, const int32_t * p_109, int32_t * p_110, float  p_111, int32_t  p_112)
{ /* block id: 54 */
    return (*p_110);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t  func_118(int32_t * p_119, const int32_t * p_120, uint16_t  p_121, int32_t  p_122, int32_t * p_123)
{ /* block id: 60 */
    const int32_t l_134 = 0x403EC6B4L;
    const int32_t **l_142 = (void*)0;
    int32_t l_145 = 0x9391FD40L;
    int32_t *l_144 = &l_145;
    int32_t **l_143 = &l_144;
    int32_t l_146 = 3L;
    (*l_143) = func_59(((((int16_t)(p_121 != ((((((((((((uint16_t)((uint16_t)l_134 * (uint16_t)p_122) >> (uint16_t)14) | ((int16_t)l_134 << (int16_t)(__builtin_clzll(l_134) || p_122))) , ((((int16_t)(~(l_134 < ((((uint16_t)0x8548L << (uint16_t)12) , p_122) > 18446744073709551608UL))) << (int16_t)3) | p_121) | p_122)) < l_134) && l_134) || l_134) , p_122) & l_134) || p_122) ^ 4UL) ^ 8L)) * (int16_t)0xA8E0L) ^ l_134) , 0x01L));
    /* statement id: 61 */
    assert (l_144 == 0);
    (*p_123) = l_146;
    return (*p_123);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_27();
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 0
breakdown:
   depth: 0, occurrence: 114
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 49
breakdown:
   depth: 1, occurrence: 68
   depth: 2, occurrence: 10
   depth: 3, occurrence: 2
   depth: 4, occurrence: 2
   depth: 5, occurrence: 1
   depth: 7, occurrence: 2
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 12, occurrence: 3
   depth: 14, occurrence: 1
   depth: 15, occurrence: 3
   depth: 16, occurrence: 1
   depth: 17, occurrence: 1
   depth: 19, occurrence: 1
   depth: 25, occurrence: 1
   depth: 26, occurrence: 1
   depth: 28, occurrence: 1
   depth: 29, occurrence: 2
   depth: 49, occurrence: 1

XXX total number of pointers: 104

XXX times a variable address is taken: 117
XXX times a pointer is dereferenced on RHS: 112
breakdown:
   depth: 1, occurrence: 78
   depth: 2, occurrence: 15
   depth: 3, occurrence: 13
   depth: 4, occurrence: 6
XXX times a pointer is dereferenced on LHS: 44
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 2
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 17
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 5
XXX times a pointer is qualified to be dereferenced: 334

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 188
   level: 2, occurrence: 49
   level: 3, occurrence: 31
   level: 4, occurrence: 23
   level: 5, occurrence: 2
XXX number of pointers point to pointers: 42
XXX number of pointers point to scalars: 62
XXX number of pointers point to structs: 0
XXX percent of pointers has null in alias set: 30.8
XXX average alias set size: 1.17

XXX times a non-volatile is read: 717
XXX times a non-volatile is write: 121
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 2

XXX stmts: 64
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 22
   depth: 1, occurrence: 6
   depth: 2, occurrence: 10
   depth: 3, occurrence: 7
   depth: 4, occurrence: 9
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 14.7
XXX percentage an existing variable is used: 85.3
********************* end of statistics **********************/

