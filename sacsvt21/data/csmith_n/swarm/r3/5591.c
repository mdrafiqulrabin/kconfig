/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --argc --no-arrays --bitfields --no-comma-operators --compound-assignment --consts --divs --no-embedded-assigns --pre-incr-operator --pre-decr-operator --no-post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --inline-function --muls --no-safe-math --no-packed-struct --paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --no-const-pointers --global-variabless --no-builtins
 * Seed:      2024639694
 */


#define NO_LONGLONG

#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const signed f0 : 21;
   unsigned f1 : 22;
};

/* --- GLOBAL VARIABLES --- */
static uint32_t g_16 = 4294967290U;
static int32_t g_49 = (-6);
static const int32_t *g_48 = &g_49;
static int32_t g_105 = (-1);
static uint16_t g_143 = 65529U;
static int32_t **g_179 = (void*)0;
static int32_t g_191 = 3;
static struct S0 g_199 = {713,1069};
static volatile uint32_t g_333 = 0x5C9E55F8;/* VOLATILE GLOBAL g_333 */
static volatile int32_t g_383 = (-1);/* VOLATILE GLOBAL g_383 */
static volatile uint32_t g_395 = 1U;/* VOLATILE GLOBAL g_395 */
static int32_t g_444 = 0x36B6895E;
static volatile struct S0 g_462 = {1206,1175};/* VOLATILE GLOBAL g_462 */
static volatile struct S0 *g_461 = &g_462;
static volatile struct S0 **g_460 = &g_461;
static volatile int32_t *g_468 = (void*)0;
static volatile int32_t **g_467 = &g_468;
static volatile int32_t ***g_466 = &g_467;
static volatile int32_t ****g_465 = &g_466;
static volatile int32_t g_556 = (-5);/* VOLATILE GLOBAL g_556 */
static uint16_t g_557 = 0x4182;
static volatile uint32_t g_606 = 4294967295U;/* VOLATILE GLOBAL g_606 */
static uint32_t g_630 = 0x19A869F1;
static int32_t ***g_748 = &g_179;
static struct S0 ***g_813 = (void*)0;
static struct S0 ****g_812 = &g_813;
static uint16_t g_828 = 3U;


/* --- FORWARD DECLARATIONS --- */
inline static int16_t  func_1(void);
static int32_t  func_2(int16_t  p_3);
static int32_t  func_4(int32_t  p_5, uint32_t  p_6, uint32_t  p_7);
inline static int16_t  func_13(int16_t  p_14, int16_t  p_15);
inline static int16_t  func_23(uint32_t  p_24, int16_t  p_25, int32_t  p_26);
inline static const int32_t * func_43(struct S0  p_44, const uint32_t  p_45, uint32_t  p_46);
inline static int32_t  func_51(const int32_t * p_52, int32_t ** p_53, int32_t * p_54, uint16_t  p_55, uint16_t  p_56);
static int32_t ** func_57(int32_t ** p_58, uint32_t  p_59, uint32_t  p_60, uint32_t  p_61, int32_t * p_62);
inline static uint16_t  func_71(int32_t  p_72, const uint32_t  p_73, int32_t  p_74, int32_t  p_75);
static int16_t  func_78(uint16_t  p_79, int32_t  p_80);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_16 g_48 g_49 g_105 g_143 g_179 g_191 g_199 g_465 g_466 g_467 g_556 g_557 g_630 g_395 g_468 g_812 g_462.f1 g_828
 * writes: g_48 g_105 g_49 g_143 g_191 g_630 g_748 g_812
 */
inline static int16_t  func_1(void)
{ /* block id: 0 */
    int16_t l_8 = 0x4CCB;
    int16_t l_231 = (-1);
    int32_t *l_829 = &g_191;
    (*l_829) = ((func_2((func_4(l_8, ((uint16_t)((((int16_t)func_13(g_16, ((int16_t)((uint16_t)((uint16_t)(func_23(g_16, l_8, ((int16_t)0x85F8 - (int16_t)(((int16_t)(l_8 ^ (((int32_t)0x8EA2C39D - (int32_t)((int32_t)((int32_t)((int16_t)((uint32_t)((int16_t)0xCE35 * (int16_t)g_16) + (uint32_t)0xEF7E2919) + (int16_t)g_16) + (int32_t)0x5F992DB7) - (int32_t)l_8)) && 0x6581)) >> (int16_t)g_16) <= 1U))) || g_105) * (uint16_t)l_231) << (uint16_t)4) << (int16_t)g_16)) / (int16_t)7) == 0x953962AE) & 65531U) >> (uint16_t)9), g_199.f1) > 0x62EA4142)) < l_8) & g_828);
    return (*l_829);
}


/* ------------------------------------------ */
/* 
 * reads : g_191 g_465 g_466 g_143 g_49 g_467 g_556 g_48 g_557 g_630 g_105 g_395 g_468 g_199.f1 g_199.f0 g_16 g_812 g_462.f1 g_828
 * writes: g_191 g_630 g_105 g_748 g_812 g_48
 */
static int32_t  func_2(int16_t  p_3)
{ /* block id: 149 */
    uint32_t l_667 = 3U;
    uint32_t l_673 = 0xDC8B6CA5;
    int32_t *****l_676 = (void*)0;
    struct S0 ***l_683 = (void*)0;
    struct S0 ****l_682 = &l_683;
    int32_t *l_709 = (void*)0;
    uint16_t l_710 = 3U;
    uint16_t l_817 = 0xA458;
    int32_t l_820 = 0x0AE59138;
    struct S0 l_821 = {-772,179};
    int32_t ****l_826 = &g_748;
    const int32_t **l_827 = &g_48;
    if ((p_3 || (!(l_667 & ((g_191 && (0xFD03 && ((*g_465) == (void*)0))) == (0U <= ((5U || (((int16_t)l_667 >> (int16_t)l_667) | 0x86CF4F7B)) == l_667)))))))
    { /* block id: 150 */
        const struct S0 **l_681 = (void*)0;
        const struct S0 ***l_680 = &l_681;
        const struct S0 ****l_679 = &l_680;
        int32_t *l_684 = &g_191;
        int32_t *l_704 = &g_444;
        (*l_684) |= (((uint16_t)(~l_673) >> (uint16_t)14) != ((uint16_t)((&g_465 != l_676) && ((&g_466 == &g_466) || (0 | ((uint16_t)((l_679 != l_682) || 1U) * (uint16_t)g_143)))) + (uint16_t)g_49));
        if ((((int32_t)(!p_3) - (int32_t)((uint16_t)((((-(int16_t)(p_3 || ((void*)0 != (*l_679)))) <= (((uint16_t)(p_3 & ((uint32_t)((((*g_466) == (**g_465)) == ((((int32_t)(!((((uint16_t)p_3 << (uint16_t)5) < (((*l_684) ^ p_3) | p_3)) <= (*l_684))) % (int32_t)6) | 0x49E6) ^ l_667)) || g_556) + (uint32_t)(*g_48))) % (uint16_t)p_3) == 65535U)) & g_49) != (*l_684)) >> (uint16_t)g_557)) & (*g_48)))
        { /* block id: 152 */
            (*l_684) &= p_3;
            return (*l_684);
        }
        else
        { /* block id: 155 */
            (*l_684) = (g_556 < (((uint16_t)(*l_684) * (uint16_t)((void*)0 == (*g_465))) <= (&l_680 == (void*)0)));
        }
        for (l_667 = 0; (l_667 != 35); l_667 += 7)
        { /* block id: 160 */
            int32_t *l_705 = &g_49;
            struct S0 ****l_708 = (void*)0;
            (*l_684) = ((l_704 == l_705) && ((int16_t)(l_708 != &l_680) >> (int16_t)4));
            l_709 = l_705;
            /* statement id: 162 */
            assert (l_709 == &g_49);
        }
        /* facts after for loop */
        assert (l_709 == &g_49 || l_709 == 0);
        return l_710;
    }
    else
    { /* block id: 165 */
        int32_t ***l_736 = &g_179;
        int32_t ****l_735 = &l_736;
        for (p_3 = 0; (p_3 == 3); p_3 += 8)
        { /* block id: 168 */
            int16_t l_743 = 0xCE1C;
            uint32_t l_798 = 1U;
            struct S0 *l_815 = (void*)0;
            for (l_667 = 21; (l_667 <= 39); ++l_667)
            { /* block id: 171 */
                uint16_t l_724 = 1U;
                struct S0 *l_742 = &g_199;
                struct S0 **l_741 = &l_742;
                struct S0 ***l_740 = &l_741;
                int32_t l_792 = (-5);
                for (g_630 = (-6); (g_630 >= 16); g_630 += 1)
                { /* block id: 174 */
                    int32_t l_739 = 0x2F9CEBAA;
                    int32_t ***l_747 = &g_179;
                    struct S0 *l_753 = (void*)0;
                    for (g_105 = 0; (g_105 <= 14); g_105 += 1)
                    { /* block id: 177 */
                        int32_t *l_719 = &g_49;
                        int32_t *l_720 = (void*)0;
                        int32_t *l_721 = &g_191;
                        int32_t *l_722 = &g_444;
                        int32_t *l_723 = &g_49;
                        --l_724;
                        if (p_3)
                            continue;
                    }
                    if (((uint32_t)(((int16_t)((uint16_t)((int16_t)((void*)0 == l_735) / (int16_t)1) << (uint16_t)((p_3 && ((void*)0 == &g_461)) | p_3)) * (int16_t)g_395) | ((uint32_t)0U - (uint32_t)(*g_48))) + (uint32_t)(*g_48)))
                    { /* block id: 181 */
                        l_739 = 0xBAB20330;
                    }
                    else
                    { /* block id: 183 */
                        int32_t *l_744 = (void*)0;
                        int32_t *l_745 = (void*)0;
                        int32_t *l_746 = &g_105;
                        l_743 &= ((((void*)0 != (**g_466)) <= (l_740 != &g_460)) != 0x9F77);
                        if (p_3)
                            break;
                        (*l_746) = p_3;
                    }
                    g_748 = l_747;
                    if ((((&g_466 == &g_466) <= ((int32_t)((uint32_t)((l_753 != (void*)0) | ((uint16_t)g_630 - (uint16_t)((((int32_t)l_743 + (int32_t)((((uint16_t)0U - (uint16_t)g_191) ^ (((-(int32_t)((int32_t)((uint32_t)((int32_t)p_3 % (int32_t)0x00249590) % (uint32_t)p_3) % (int32_t)(*g_48))) > p_3) || (*g_48))) > g_143)) | 0U) != p_3))) + (uint32_t)0xE30A5FB2) / (int32_t)8U)) != 0))
                    { /* block id: 189 */
                        volatile struct S0 ***l_768 = &g_460;
                        volatile struct S0 ****l_767 = &l_768;
                        (*l_767) = &g_460;
                    }
                    else
                    { /* block id: 191 */
                        uint32_t l_810 = 0xDE286474;
                        int32_t l_811 = 0xB9FBCCDF;
                        struct S0 *****l_814 = &g_812;
                        l_792 ^= (((((uint16_t)g_630 * (uint16_t)0x668C) || (((uint16_t)((((*g_48) || l_743) < ((uint16_t)p_3 * (uint16_t)((((int32_t)((uint16_t)((((int16_t)((uint16_t)((uint32_t)((uint16_t)g_49 * (uint16_t)(((p_3 <= ((((int16_t)(-1) % (int16_t)((int16_t)(-(uint32_t)p_3) + (int16_t)0U)) > g_556) & g_199.f1)) && (*g_48)) == 0x6511)) - (uint32_t)p_3) >> (uint16_t)4) * (int16_t)9U) > 0) >= 6) << (uint16_t)g_199.f0) + (int32_t)g_557) | g_191) & 7U))) ^ l_743) >> (uint16_t)l_724) | g_199.f0)) ^ g_105) > l_724);
                        l_811 |= ((uint32_t)(l_724 > g_16) % (uint32_t)(~((uint32_t)(l_798 | ((int16_t)((((g_49 != 0x4D57) > 0x3059) >= p_3) < ((int16_t)((-(int32_t)((int32_t)((int16_t)g_49 >> (int16_t)((int16_t)l_743 >> (int16_t)g_395)) / (int32_t)l_810)) != p_3) + (int16_t)g_49)) >> (int16_t)8)) % (uint32_t)p_3)));
                        (*l_814) = g_812;
                    }
                }
                if (((g_462.f1 < l_792) < p_3))
                { /* block id: 197 */
                    (*l_741) = l_815;
                    /* statement id: 198 */
                    assert (l_742 == 0);
                    if (p_3)
                        break;
                }
                else
                { /* block id: 200 */
                    int32_t *l_816 = (void*)0;
                    l_816 = &l_792;
                    /* statement id: 201 */
                    assert (l_816 == &l_792);
                }
                /* facts after branching */
                assert (l_742 == &g_199 || l_742 == 0);
                if (p_3)
                    continue;
            }
            if (l_798)
                continue;
        }
    }
    --l_817;
    l_820 ^= (65535U && 0x7B3E);
    (*l_827) = func_43(l_821, (g_630 | ((int16_t)g_16 + (int16_t)((uint16_t)(l_826 == (void*)0) >> (uint16_t)1))), g_199.f1);
    return g_828;
}


/* ------------------------------------------ */
/* 
 * reads : g_191 g_105
 * writes: g_191
 */
static int32_t  func_4(int32_t  p_5, uint32_t  p_6, uint32_t  p_7)
{ /* block id: 68 */
    int32_t *l_245 = &g_105;
    int32_t **l_244 = &l_245;
    uint16_t l_271 = 0xF2FC;
    int32_t l_317 = 0xE6538CD0;
    int32_t l_329 = 0;
    int32_t l_331 = 0;
    int32_t ***l_339 = &l_244;
    struct S0 *l_476 = &g_199;
    uint32_t l_619 = 0U;
    for (p_7 = 0; (p_7 != 0); p_7 += 9)
    { /* block id: 71 */
        int32_t *l_236 = &g_191;
        struct S0 l_237 = {1112,933};
        int32_t l_308 = 1;
        int32_t l_326 = 0x1DDCEFBE;
        int16_t l_351 = (-8);
        int32_t l_560 = 0x5C7453D5;
        int32_t *l_631 = &l_331;
        (*l_236) ^= p_7;
    }
    return (***l_339);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
inline static int16_t  func_13(int16_t  p_14, int16_t  p_15)
{ /* block id: 65 */
    int32_t l_232 = 0xC4FB29E5;
    int32_t l_233 = 1;
    l_233 = l_232;
    return p_15;
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_48 g_49 g_105 g_143 g_179 g_191 g_199
 * writes: g_48 g_105 g_49 g_143 g_191
 */
inline static int16_t  func_23(uint32_t  p_24, int16_t  p_25, int32_t  p_26)
{ /* block id: 1 */
    struct S0 l_47 = {-767,1658};
    const int32_t **l_50 = &g_48;
    int32_t *l_64 = &g_49;
    int32_t **l_63 = &l_64;
    uint16_t l_106 = 0x39A3;
    (*l_50) = func_43(l_47, p_26, g_16);
    if (func_51((*l_50), func_57(l_63, ((int16_t)((uint32_t)(0x05DE != ((uint16_t)func_71(g_49, p_26, (g_16 <= ((int16_t)func_78((**l_50), (*g_48)) << (int16_t)6)), l_106) / (uint16_t)p_24)) / (uint32_t)(-1)) >> (int16_t)5), p_24, g_16, (*l_63)), (*l_63), g_16, p_24))
    { /* block id: 27 */
        int32_t *l_196 = (void*)0;
        int32_t l_212 = 4;
        (*l_64) = p_25;
        (*l_64) = ((uint16_t)(1U > (&g_49 == l_196)) - (uint16_t)((int16_t)0 >> (int16_t)13));
        (*l_50) = func_43(g_199, (g_49 != ((uint16_t)(((**l_63) == ((uint16_t)((uint32_t)4294967295U / (uint32_t)(((int16_t)(((void*)0 == &l_64) & (((uint32_t)(((*l_64) <= (0U >= (((((uint16_t)(((void*)0 == &g_49) > p_24) / (uint16_t)l_212) || g_105) == g_49) == p_26))) && (*l_64)) + (uint32_t)(*g_48)) != (*l_64))) / (int16_t)0x9EEE) ^ (**l_63))) / (uint16_t)p_24)) > 0xFBC4F1BB) * (uint16_t)0x3735)), p_24);
    }
    else
    { /* block id: 31 */
        uint16_t l_215 = 0xA313;
        int32_t *l_226 = &g_49;
        for (g_105 = 0; (g_105 > 27); ++g_105)
        { /* block id: 34 */
            const int32_t *l_223 = &g_49;
            --l_215;
            (**l_63) &= p_26;
            for (l_106 = 12; (l_106 == 22); l_106 += 2)
            { /* block id: 39 */
                int32_t *l_222 = &g_49;
                struct S0 *l_230 = &g_199;
                struct S0 **l_229 = &l_230;
                if ((((l_222 != (*l_63)) >= ((l_223 != l_223) >= 0x93B09627)) ^ g_199.f1))
                { /* block id: 40 */
                    for (p_26 = 3; (p_26 < (-7)); p_26 -= 2)
                    { /* block id: 43 */
                        (*l_50) = l_226;
                        if ((*g_48))
                            continue;
                        (*l_50) = (*l_50);
                        (*l_226) |= 8;
                    }
                }
                else
                { /* block id: 49 */
                    for (p_24 = (-1); (p_24 < 54); p_24 += 1)
                    { /* block id: 52 */
                        (*l_63) = l_222;
                        (*l_50) = l_223;
                        if (p_24)
                            break;
                    }
                }
                if ((*l_222))
                    break;
                (*l_229) = &g_199;
                (*l_226) ^= p_25;
            }
        }
    }
    return g_49;
}


/* ------------------------------------------ */
/* 
 * reads : g_48
 * writes:
 */
inline static const int32_t * func_43(struct S0  p_44, const uint32_t  p_45, uint32_t  p_46)
{ /* block id: 2 */
    return g_48;
    /* statement id: 3 */
    //assert (func_43_rv == &g_49);
}


/* ------------------------------------------ */
/* 
 * reads : g_48 g_49 g_16 g_105 g_191
 * writes: g_191
 */
inline static int32_t  func_51(const int32_t * p_52, int32_t ** p_53, int32_t * p_54, uint16_t  p_55, uint16_t  p_56)
{ /* block id: 23 */
    const int32_t **l_180 = &g_48;
    uint32_t l_189 = 0U;
    int32_t *l_190 = &g_191;
    l_180 = &g_48;
    (*l_190) &= ((*g_48) || ((int16_t)((**l_180) && (((((uint32_t)4294967294U % (uint32_t)((uint32_t)g_16 * (uint32_t)((0xB6E2EDB3 >= ((void*)0 == &g_49)) > (**l_180)))) ^ ((uint16_t)p_55 >> (uint16_t)l_189)) <= (**l_180)) | (*p_54))) * (int16_t)g_105));
    return (**l_180);
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_105 g_16 g_48 g_143 g_179
 * writes: g_49
 */
static int32_t ** func_57(int32_t ** p_58, uint32_t  p_59, uint32_t  p_60, uint32_t  p_61, int32_t * p_62)
{ /* block id: 18 */
    int32_t l_146 = 0xBAC11434;
    int32_t *l_178 = &g_105;
    int32_t **l_177 = &l_178;
    (*p_62) &= l_146;
    (*p_62) = (((int16_t)(!((uint16_t)0U - (uint16_t)(((((((*p_58) == (void*)0) | (((uint16_t)(((int16_t)((uint16_t)l_146 * (uint16_t)((int32_t)((int32_t)(((uint32_t)(((int16_t)((((((~(p_59 < ((uint32_t)((int16_t)8 << (int16_t)3) / (uint32_t)(((uint16_t)l_146 * (uint16_t)(0xC0817FF2 & (((int16_t)((l_177 == (void*)0) && p_59) * (int16_t)g_49) >= p_59))) & g_49)))) < (*l_178)) & 0x6528) || (*l_178)) != g_16) || (**l_177)) >> (int16_t)5) && g_49) - (uint32_t)0U) <= (**l_177)) - (int32_t)0x7563F1C1) + (int32_t)(*g_48))) % (int16_t)(**l_177)) != p_61) << (uint16_t)g_105) == g_105)) && 0) & g_143) && (*l_178)) != (*l_178)))) + (int16_t)p_60) || (*g_48));
    (*l_177) = &g_105;
    return g_179;
    /* statement id: 22 */
    //assert (func_57_rv == 0);
}


/* ------------------------------------------ */
/* 
 * reads : g_16 g_49 g_105 g_143
 * writes: g_105 g_49 g_143
 */
inline static uint16_t  func_71(int32_t  p_72, const uint32_t  p_73, int32_t  p_74, int32_t  p_75)
{ /* block id: 8 */
    uint32_t l_126 = 0xE059069C;
    int32_t *l_127 = &g_49;
    int32_t *l_128 = &g_49;
    int32_t *l_129 = &g_105;
    int32_t *l_130 = &g_105;
    int32_t l_131 = 0x4CD7C082;
    int32_t *l_132 = &g_49;
    int32_t *l_133 = &l_131;
    int32_t l_134 = 1;
    int32_t *l_135 = (void*)0;
    int32_t l_136 = 0xE99EAD79;
    int32_t *l_137 = (void*)0;
    int32_t *l_138 = &l_131;
    int32_t *l_139 = &g_49;
    int32_t *l_140 = &l_134;
    int32_t l_141 = 0;
    int32_t *l_142 = &l_131;
    for (p_74 = (-29); (p_74 == (-15)); p_74 += 3)
    { /* block id: 11 */
        int32_t l_113 = (-7);
        int32_t *l_114 = &g_105;
        uint16_t l_117 = 0x6318;
        (*l_114) = (0U == ((uint16_t)p_75 >> (uint16_t)((uint32_t)l_113 % (uint32_t)p_74)));
        g_49 = (((0x5549 < ((uint32_t)l_117 + (uint32_t)(-3))) || ((int32_t)(((int16_t)(((((uint16_t)1U * (uint16_t)65533U) ^ g_16) & g_49) <= (g_16 == (((int16_t)g_49 - (int16_t)p_73) && g_105))) << (int16_t)p_73) < g_49) + (int32_t)l_126)) != l_126);
    }
    (*l_127) = p_73;
    --g_143;
    return p_72;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_16 g_48
 * writes: g_105
 */
static int16_t  func_78(uint16_t  p_79, int32_t  p_80)
{ /* block id: 5 */
    uint32_t l_84 = 0x5A2C03FD;
    int32_t *l_104 = &g_105;
    (*l_104) = ((((int32_t)((!l_84) ^ (((~((int16_t)((uint16_t)65531U / (uint16_t)l_84) % (int16_t)((uint32_t)g_49 + (uint32_t)((&g_49 != (void*)0) ^ ((((uint16_t)((uint32_t)(((uint16_t)((uint16_t)((((int16_t)l_84 - (int16_t)0x2B46) | ((uint16_t)(g_16 > g_16) * (uint16_t)l_84)) <= (*g_48)) * (uint16_t)g_49) << (uint16_t)l_84) && 0xD6E3F992) / (uint32_t)p_79) % (uint16_t)l_84) || g_16) != l_84))))) || 0x1D3A0C94) || 0x464C)) - (int32_t)(*g_48)) & p_80) & p_79);
    return p_80;
}




/* ---------------------------------------- */
int main (int argc, char* argv[])
{
    int print_hash_value = 0;
    if (argc == 2 && strcmp(argv[1], "1") == 0) print_hash_value = 1;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_16, "g_16", print_hash_value);
    transparent_crc(g_49, "g_49", print_hash_value);
    transparent_crc(g_105, "g_105", print_hash_value);
    transparent_crc(g_143, "g_143", print_hash_value);
    transparent_crc(g_191, "g_191", print_hash_value);
    transparent_crc(g_199.f0, "g_199.f0", print_hash_value);
    transparent_crc(g_199.f1, "g_199.f1", print_hash_value);
    transparent_crc(g_333, "g_333", print_hash_value);
    transparent_crc(g_383, "g_383", print_hash_value);
    transparent_crc(g_395, "g_395", print_hash_value);
    transparent_crc(g_444, "g_444", print_hash_value);
    transparent_crc(g_462.f0, "g_462.f0", print_hash_value);
    transparent_crc(g_462.f1, "g_462.f1", print_hash_value);
    transparent_crc(g_556, "g_556", print_hash_value);
    transparent_crc(g_557, "g_557", print_hash_value);
    transparent_crc(g_606, "g_606", print_hash_value);
    transparent_crc(g_630, "g_630", print_hash_value);
    transparent_crc(g_828, "g_828", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 120
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 2
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 1
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 15
breakdown:
   indirect level: 0, occurrence: 5
   indirect level: 1, occurrence: 4
   indirect level: 2, occurrence: 1
   indirect level: 3, occurrence: 1
   indirect level: 4, occurrence: 4
XXX full-bitfields structs in the program: 5
breakdown:
   indirect level: 0, occurrence: 5
XXX times a bitfields struct's address is taken: 8
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 8
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 11

XXX max expression depth: 36
breakdown:
   depth: 1, occurrence: 93
   depth: 2, occurrence: 12
   depth: 3, occurrence: 1
   depth: 4, occurrence: 2
   depth: 5, occurrence: 3
   depth: 6, occurrence: 2
   depth: 8, occurrence: 1
   depth: 11, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 15, occurrence: 2
   depth: 20, occurrence: 1
   depth: 23, occurrence: 1
   depth: 24, occurrence: 2
   depth: 25, occurrence: 1
   depth: 28, occurrence: 1
   depth: 32, occurrence: 1
   depth: 36, occurrence: 1

XXX total number of pointers: 328

XXX times a variable address is taken: 292
XXX times a pointer is dereferenced on RHS: 84
breakdown:
   depth: 1, occurrence: 62
   depth: 2, occurrence: 20
   depth: 3, occurrence: 1
   depth: 4, occurrence: 1
XXX times a pointer is dereferenced on LHS: 49
breakdown:
   depth: 1, occurrence: 45
   depth: 2, occurrence: 3
   depth: 3, occurrence: 1
XXX times a pointer is compared with null: 23
XXX times a pointer is compared with address of another variable: 11
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 930

XXX max dereference level: 4
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 134
   level: 2, occurrence: 42
   level: 3, occurrence: 30
   level: 4, occurrence: 13
XXX number of pointers point to pointers: 47
XXX number of pointers point to scalars: 274
XXX number of pointers point to structs: 7
XXX percent of pointers has null in alias set: 19.8
XXX average alias set size: 1.02

XXX times a non-volatile is read: 489
XXX times a non-volatile is write: 143
XXX times a volatile is read: 9
XXX    times read thru a pointer: 0
XXX times a volatile is write: 3
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 106
XXX percentage of non-volatile access: 98.1

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 83
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 28
   depth: 1, occurrence: 12
   depth: 2, occurrence: 10
   depth: 3, occurrence: 7
   depth: 4, occurrence: 9
   depth: 5, occurrence: 17

XXX percentage a fresh-made variable is used: 20.9
XXX percentage an existing variable is used: 79.1
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

